{
  "module_name": "wm8903.c",
  "hash_id": "45f40835ec2066eae716224c2bf3ead907dae8c1aaf09a2f5991efb5b22f4e7d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8903.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/gpio/driver.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/wm8903.h>\n#include <trace/events/asoc.h>\n\n#include \"wm8903.h\"\n\n \nstatic const struct reg_default wm8903_reg_defaults[] = {\n\t{ 4,  0x0018 },      \n\t{ 5,  0x0000 },      \n\t{ 6,  0x0000 },      \n\t{ 8,  0x0001 },      \n\t{ 10, 0x0001 },      \n\t{ 12, 0x0000 },      \n\t{ 13, 0x0000 },      \n\t{ 14, 0x0000 },      \n\t{ 15, 0x0000 },      \n\t{ 16, 0x0000 },      \n\t{ 17, 0x0000 },      \n\t{ 18, 0x0000 },      \n\t{ 20, 0x0400 },      \n\t{ 21, 0x0D07 },      \n\t{ 22, 0x0000 },      \n\t{ 24, 0x0050 },      \n\t{ 25, 0x0242 },      \n\t{ 26, 0x0008 },      \n\t{ 27, 0x0022 },      \n\t{ 30, 0x00C0 },      \n\t{ 31, 0x00C0 },      \n\t{ 32, 0x0000 },      \n\t{ 33, 0x0000 },      \n\t{ 36, 0x00C0 },      \n\t{ 37, 0x00C0 },      \n\t{ 38, 0x0000 },      \n\t{ 39, 0x0073 },      \n\t{ 40, 0x09BF },      \n\t{ 41, 0x3241 },      \n\t{ 42, 0x0020 },      \n\t{ 43, 0x0000 },      \n\t{ 44, 0x0085 },      \n\t{ 45, 0x0085 },      \n\t{ 46, 0x0044 },      \n\t{ 47, 0x0044 },      \n\t{ 50, 0x0008 },      \n\t{ 51, 0x0004 },      \n\t{ 52, 0x0000 },      \n\t{ 53, 0x0000 },      \n\t{ 54, 0x0000 },      \n\t{ 55, 0x0000 },      \n\t{ 57, 0x002D },      \n\t{ 58, 0x002D },      \n\t{ 59, 0x0039 },      \n\t{ 60, 0x0039 },      \n\t{ 62, 0x0139 },      \n\t{ 63, 0x0139 },      \n\t{ 64, 0x0000 },      \n\t{ 67, 0x0010 },      \n\t{ 69, 0x00A4 },      \n\t{ 90, 0x0000 },      \n\t{ 94, 0x0000 },      \n\t{ 98, 0x0000 },      \n\t{ 104, 0x0000 },     \n\t{ 108, 0x0000 },     \n\t{ 109, 0x0000 },     \n\t{ 110, 0x0000 },     \n\t{ 111, 0x0000 },     \n\t{ 112, 0x0000 },     \n\t{ 114, 0x0000 },     \n\t{ 116, 0x00A8 },     \n\t{ 117, 0x00A8 },     \n\t{ 118, 0x00A8 },     \n\t{ 119, 0x0220 },     \n\t{ 120, 0x01A0 },     \n\t{ 122, 0xFFFF },     \n\t{ 123, 0x0000 },     \n\t{ 126, 0x0000 },     \n\t{ 129, 0x0000 },     \n\t{ 149, 0x6810 },     \n\t{ 164, 0x0028 },     \n\t{ 172, 0x0000 },     \n};\n\n#define WM8903_NUM_SUPPLIES 4\nstatic const char *wm8903_supply_names[WM8903_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"CPVDD\",\n\t\"DBVDD\",\n\t\"DCVDD\",\n};\n\nstruct wm8903_priv {\n\tstruct wm8903_platform_data *pdata;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8903_NUM_SUPPLIES];\n\n\tint sysclk;\n\tint irq;\n\n\tstruct mutex lock;\n\tint fs;\n\tint deemph;\n\n\tint dcs_pending;\n\tint dcs_cache[4];\n\n\t \n\tint class_w_users;\n\n\tstruct snd_soc_jack *mic_jack;\n\tint mic_det;\n\tint mic_short;\n\tint mic_last_report;\n\tint mic_delay;\n\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gpio_chip;\n#endif\n};\n\nstatic bool wm8903_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8903_SW_RESET_AND_ID:\n\tcase WM8903_REVISION_NUMBER:\n\tcase WM8903_BIAS_CONTROL_0:\n\tcase WM8903_VMID_CONTROL_0:\n\tcase WM8903_MIC_BIAS_CONTROL_0:\n\tcase WM8903_ANALOGUE_DAC_0:\n\tcase WM8903_ANALOGUE_ADC_0:\n\tcase WM8903_POWER_MANAGEMENT_0:\n\tcase WM8903_POWER_MANAGEMENT_1:\n\tcase WM8903_POWER_MANAGEMENT_2:\n\tcase WM8903_POWER_MANAGEMENT_3:\n\tcase WM8903_POWER_MANAGEMENT_4:\n\tcase WM8903_POWER_MANAGEMENT_5:\n\tcase WM8903_POWER_MANAGEMENT_6:\n\tcase WM8903_CLOCK_RATES_0:\n\tcase WM8903_CLOCK_RATES_1:\n\tcase WM8903_CLOCK_RATES_2:\n\tcase WM8903_AUDIO_INTERFACE_0:\n\tcase WM8903_AUDIO_INTERFACE_1:\n\tcase WM8903_AUDIO_INTERFACE_2:\n\tcase WM8903_AUDIO_INTERFACE_3:\n\tcase WM8903_DAC_DIGITAL_VOLUME_LEFT:\n\tcase WM8903_DAC_DIGITAL_VOLUME_RIGHT:\n\tcase WM8903_DAC_DIGITAL_0:\n\tcase WM8903_DAC_DIGITAL_1:\n\tcase WM8903_ADC_DIGITAL_VOLUME_LEFT:\n\tcase WM8903_ADC_DIGITAL_VOLUME_RIGHT:\n\tcase WM8903_ADC_DIGITAL_0:\n\tcase WM8903_DIGITAL_MICROPHONE_0:\n\tcase WM8903_DRC_0:\n\tcase WM8903_DRC_1:\n\tcase WM8903_DRC_2:\n\tcase WM8903_DRC_3:\n\tcase WM8903_ANALOGUE_LEFT_INPUT_0:\n\tcase WM8903_ANALOGUE_RIGHT_INPUT_0:\n\tcase WM8903_ANALOGUE_LEFT_INPUT_1:\n\tcase WM8903_ANALOGUE_RIGHT_INPUT_1:\n\tcase WM8903_ANALOGUE_LEFT_MIX_0:\n\tcase WM8903_ANALOGUE_RIGHT_MIX_0:\n\tcase WM8903_ANALOGUE_SPK_MIX_LEFT_0:\n\tcase WM8903_ANALOGUE_SPK_MIX_LEFT_1:\n\tcase WM8903_ANALOGUE_SPK_MIX_RIGHT_0:\n\tcase WM8903_ANALOGUE_SPK_MIX_RIGHT_1:\n\tcase WM8903_ANALOGUE_OUT1_LEFT:\n\tcase WM8903_ANALOGUE_OUT1_RIGHT:\n\tcase WM8903_ANALOGUE_OUT2_LEFT:\n\tcase WM8903_ANALOGUE_OUT2_RIGHT:\n\tcase WM8903_ANALOGUE_OUT3_LEFT:\n\tcase WM8903_ANALOGUE_OUT3_RIGHT:\n\tcase WM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0:\n\tcase WM8903_DC_SERVO_0:\n\tcase WM8903_DC_SERVO_2:\n\tcase WM8903_DC_SERVO_READBACK_1:\n\tcase WM8903_DC_SERVO_READBACK_2:\n\tcase WM8903_DC_SERVO_READBACK_3:\n\tcase WM8903_DC_SERVO_READBACK_4:\n\tcase WM8903_ANALOGUE_HP_0:\n\tcase WM8903_ANALOGUE_LINEOUT_0:\n\tcase WM8903_CHARGE_PUMP_0:\n\tcase WM8903_CLASS_W_0:\n\tcase WM8903_WRITE_SEQUENCER_0:\n\tcase WM8903_WRITE_SEQUENCER_1:\n\tcase WM8903_WRITE_SEQUENCER_2:\n\tcase WM8903_WRITE_SEQUENCER_3:\n\tcase WM8903_WRITE_SEQUENCER_4:\n\tcase WM8903_CONTROL_INTERFACE:\n\tcase WM8903_GPIO_CONTROL_1:\n\tcase WM8903_GPIO_CONTROL_2:\n\tcase WM8903_GPIO_CONTROL_3:\n\tcase WM8903_GPIO_CONTROL_4:\n\tcase WM8903_GPIO_CONTROL_5:\n\tcase WM8903_INTERRUPT_STATUS_1:\n\tcase WM8903_INTERRUPT_STATUS_1_MASK:\n\tcase WM8903_INTERRUPT_POLARITY_1:\n\tcase WM8903_INTERRUPT_CONTROL:\n\tcase WM8903_CLOCK_RATE_TEST_4:\n\tcase WM8903_ANALOGUE_OUTPUT_BIAS_0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8903_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8903_SW_RESET_AND_ID:\n\tcase WM8903_REVISION_NUMBER:\n\tcase WM8903_INTERRUPT_STATUS_1:\n\tcase WM8903_WRITE_SEQUENCER_4:\n\tcase WM8903_DC_SERVO_READBACK_1:\n\tcase WM8903_DC_SERVO_READBACK_2:\n\tcase WM8903_DC_SERVO_READBACK_3:\n\tcase WM8903_DC_SERVO_READBACK_4:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8903_cp_event(struct snd_soc_dapm_widget *w,\n\t\t\t   struct snd_kcontrol *kcontrol, int event)\n{\n\tWARN_ON(event != SND_SOC_DAPM_POST_PMU);\n\tmdelay(4);\n\n\treturn 0;\n}\n\nstatic int wm8903_dcs_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\twm8903->dcs_pending |= 1 << w->shift;\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8903_DC_SERVO_0,\n\t\t\t\t    1 << w->shift, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define WM8903_DCS_MODE_WRITE_STOP 0\n#define WM8903_DCS_MODE_START_STOP 2\n\nstatic void wm8903_seq_notifier(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_dapm_type event, int subseq)\n{\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tint dcs_mode = WM8903_DCS_MODE_WRITE_STOP;\n\tint i, val;\n\n\t \n\tif (wm8903->dcs_pending) {\n\t\tdev_dbg(component->dev, \"Starting DC servo for %x\\n\",\n\t\t\twm8903->dcs_pending);\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(wm8903->dcs_cache); i++) {\n\t\t\tif (!(wm8903->dcs_pending & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\tif (wm8903->dcs_cache[i]) {\n\t\t\t\tdev_dbg(component->dev,\n\t\t\t\t\t\"Restore DC servo %d value %x\\n\",\n\t\t\t\t\t3 - i, wm8903->dcs_cache[i]);\n\n\t\t\t\tsnd_soc_component_write(component, WM8903_DC_SERVO_4 + i,\n\t\t\t\t\t      wm8903->dcs_cache[i] & 0xff);\n\t\t\t} else {\n\t\t\t\tdev_dbg(component->dev,\n\t\t\t\t\t\"Calibrate DC servo %d\\n\", 3 - i);\n\t\t\t\tdcs_mode = WM8903_DCS_MODE_START_STOP;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (wm8903->class_w_users)\n\t\t\tdcs_mode = WM8903_DCS_MODE_START_STOP;\n\n\t\tsnd_soc_component_update_bits(component, WM8903_DC_SERVO_2,\n\t\t\t\t    WM8903_DCS_MODE_MASK, dcs_mode);\n\n\t\tsnd_soc_component_update_bits(component, WM8903_DC_SERVO_0,\n\t\t\t\t    WM8903_DCS_ENA_MASK, wm8903->dcs_pending);\n\n\t\tswitch (dcs_mode) {\n\t\tcase WM8903_DCS_MODE_WRITE_STOP:\n\t\t\tbreak;\n\n\t\tcase WM8903_DCS_MODE_START_STOP:\n\t\t\tmsleep(270);\n\n\t\t\t \n\t\t\tif (wm8903->class_w_users)\n\t\t\t\tbreak;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(wm8903->dcs_cache); i++) {\n\t\t\t\tif (!(wm8903->dcs_pending & (1 << i)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tval = snd_soc_component_read(component,\n\t\t\t\t\t\t   WM8903_DC_SERVO_READBACK_1 + i);\n\t\t\t\tdev_dbg(component->dev, \"DC servo %d: %x\\n\",\n\t\t\t\t\t3 - i, val);\n\t\t\t\twm8903->dcs_cache[i] = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"DCS mode %d delay not set\\n\", dcs_mode);\n\t\t\tbreak;\n\t\t}\n\n\t\twm8903->dcs_pending = 0;\n\t}\n}\n\n \nstatic int wm8903_class_w_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tu16 reg;\n\tint ret;\n\n\treg = snd_soc_component_read(component, WM8903_CLASS_W_0);\n\n\t \n\tif (ucontrol->value.integer.value[0]) {\n\t\tif (wm8903->class_w_users == 0) {\n\t\t\tdev_dbg(component->dev, \"Disabling Class W\\n\");\n\t\t\tsnd_soc_component_write(component, WM8903_CLASS_W_0, reg &\n\t\t\t\t     ~(WM8903_CP_DYN_FREQ | WM8903_CP_DYN_V));\n\t\t}\n\t\twm8903->class_w_users++;\n\t}\n\n\t \n\tret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\n\n\t \n\tif (!ucontrol->value.integer.value[0]) {\n\t\tif (wm8903->class_w_users == 1) {\n\t\t\tdev_dbg(component->dev, \"Enabling Class W\\n\");\n\t\t\tsnd_soc_component_write(component, WM8903_CLASS_W_0, reg |\n\t\t\t\t     WM8903_CP_DYN_FREQ | WM8903_CP_DYN_V);\n\t\t}\n\t\twm8903->class_w_users--;\n\t}\n\n\tdev_dbg(component->dev, \"Bypass use count now %d\\n\",\n\t\twm8903->class_w_users);\n\n\treturn ret;\n}\n\n#define SOC_DAPM_SINGLE_W(xname, reg, shift, max, invert) \\\n\tSOC_SINGLE_EXT(xname, reg, shift, max, invert, \\\n\t\tsnd_soc_dapm_get_volsw, wm8903_class_w_put)\n\n\nstatic int wm8903_deemph[] = { 0, 32000, 44100, 48000 };\n\nstatic int wm8903_set_deemph(struct snd_soc_component *component)\n{\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (wm8903->deemph) {\n\t\tbest = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(wm8903_deemph); i++) {\n\t\t\tif (abs(wm8903_deemph[i] - wm8903->fs) <\n\t\t\t    abs(wm8903_deemph[best] - wm8903->fs))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = best << WM8903_DEEMPH_SHIFT;\n\t} else {\n\t\tbest = 0;\n\t\tval = 0;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d (%dHz)\\n\",\n\t\tbest, wm8903_deemph[best]);\n\n\treturn snd_soc_component_update_bits(component, WM8903_DAC_DIGITAL_1,\n\t\t\t\t   WM8903_DEEMPH_MASK, val);\n}\n\nstatic int wm8903_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8903->deemph;\n\n\treturn 0;\n}\n\nstatic int wm8903_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\tint ret = 0;\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wm8903->lock);\n\tif (wm8903->deemph != deemph) {\n\t\twm8903->deemph = deemph;\n\n\t\twm8903_set_deemph(component);\n\n\t\tret = 1;\n\t}\n\tmutex_unlock(&wm8903->lock);\n\n\treturn ret;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -7200, 75, 1);\n\nstatic const DECLARE_TLV_DB_SCALE(dac_boost_tlv, 0, 600, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_sidetone_tlv, -3600, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(drc_tlv_thresh, 0, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_tlv_amp, -2250, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_tlv_min, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_tlv_max, 1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_tlv_startup, -300, 50, 0);\n\nstatic const char *hpf_mode_text[] = {\n\t\"Hi-fi\", \"Voice 1\", \"Voice 2\", \"Voice 3\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(hpf_mode,\n\t\t\t    WM8903_ADC_DIGITAL_0, 5, hpf_mode_text);\n\nstatic const char *osr_text[] = {\n\t\"Low power\", \"High performance\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adc_osr,\n\t\t\t    WM8903_ANALOGUE_ADC_0, 0, osr_text);\n\nstatic SOC_ENUM_SINGLE_DECL(dac_osr,\n\t\t\t    WM8903_DAC_DIGITAL_1, 0, osr_text);\n\nstatic const char *drc_slope_text[] = {\n\t\"1\", \"1/2\", \"1/4\", \"1/8\", \"1/16\", \"0\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_slope_r0,\n\t\t\t    WM8903_DRC_2, 3, drc_slope_text);\n\nstatic SOC_ENUM_SINGLE_DECL(drc_slope_r1,\n\t\t\t    WM8903_DRC_2, 0, drc_slope_text);\n\nstatic const char *drc_attack_text[] = {\n\t\"instantaneous\",\n\t\"363us\", \"762us\", \"1.45ms\", \"2.9ms\", \"5.8ms\", \"11.6ms\", \"23.2ms\",\n\t\"46.4ms\", \"92.8ms\", \"185.6ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_attack,\n\t\t\t    WM8903_DRC_1, 12, drc_attack_text);\n\nstatic const char *drc_decay_text[] = {\n\t\"186ms\", \"372ms\", \"743ms\", \"1.49s\", \"2.97s\", \"5.94s\", \"11.89s\",\n\t\"23.87s\", \"47.56s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_decay,\n\t\t\t    WM8903_DRC_1, 8, drc_decay_text);\n\nstatic const char *drc_ff_delay_text[] = {\n\t\"5 samples\", \"9 samples\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_ff_delay,\n\t\t\t    WM8903_DRC_0, 5, drc_ff_delay_text);\n\nstatic const char *drc_qr_decay_text[] = {\n\t\"0.725ms\", \"1.45ms\", \"5.8ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_qr_decay,\n\t\t\t    WM8903_DRC_1, 4, drc_qr_decay_text);\n\nstatic const char *drc_smoothing_text[] = {\n\t\"Low\", \"Medium\", \"High\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_smoothing,\n\t\t\t    WM8903_DRC_0, 11, drc_smoothing_text);\n\nstatic const char *soft_mute_text[] = {\n\t\"Fast (fs/2)\", \"Slow (fs/32)\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(soft_mute,\n\t\t\t    WM8903_DAC_DIGITAL_1, 10, soft_mute_text);\n\nstatic const char *mute_mode_text[] = {\n\t\"Hard\", \"Soft\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(mute_mode,\n\t\t\t    WM8903_DAC_DIGITAL_1, 9, mute_mode_text);\n\nstatic const char *companding_text[] = {\n\t\"ulaw\", \"alaw\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dac_companding,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 0, companding_text);\n\nstatic SOC_ENUM_SINGLE_DECL(adc_companding,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 2, companding_text);\n\nstatic const char *input_mode_text[] = {\n\t\"Single-Ended\", \"Differential Line\", \"Differential Mic\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(linput_mode_enum,\n\t\t\t    WM8903_ANALOGUE_LEFT_INPUT_1, 0, input_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rinput_mode_enum,\n\t\t\t    WM8903_ANALOGUE_RIGHT_INPUT_1, 0, input_mode_text);\n\nstatic const char *linput_mux_text[] = {\n\t\"IN1L\", \"IN2L\", \"IN3L\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(linput_enum,\n\t\t\t    WM8903_ANALOGUE_LEFT_INPUT_1, 2, linput_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(linput_inv_enum,\n\t\t\t    WM8903_ANALOGUE_LEFT_INPUT_1, 4, linput_mux_text);\n\nstatic const char *rinput_mux_text[] = {\n\t\"IN1R\", \"IN2R\", \"IN3R\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rinput_enum,\n\t\t\t    WM8903_ANALOGUE_RIGHT_INPUT_1, 2, rinput_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rinput_inv_enum,\n\t\t\t    WM8903_ANALOGUE_RIGHT_INPUT_1, 4, rinput_mux_text);\n\n\nstatic const char *sidetone_text[] = {\n\t\"None\", \"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(lsidetone_enum,\n\t\t\t    WM8903_DAC_DIGITAL_0, 2, sidetone_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rsidetone_enum,\n\t\t\t    WM8903_DAC_DIGITAL_0, 0, sidetone_text);\n\nstatic const char *adcinput_text[] = {\n\t\"ADC\", \"DMIC\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adcinput_enum,\n\t\t\t    WM8903_CLOCK_RATE_TEST_4, 9, adcinput_text);\n\nstatic const char *aif_text[] = {\n\t\"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(lcapture_enum,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 7, aif_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rcapture_enum,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 6, aif_text);\n\nstatic SOC_ENUM_SINGLE_DECL(lplay_enum,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 5, aif_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rplay_enum,\n\t\t\t    WM8903_AUDIO_INTERFACE_0, 4, aif_text);\n\nstatic const struct snd_kcontrol_new wm8903_snd_controls[] = {\n\n \nSOC_SINGLE(\"Left Input PGA Switch\", WM8903_ANALOGUE_LEFT_INPUT_0,\n\t   7, 1, 1),\nSOC_SINGLE(\"Left Input PGA Volume\", WM8903_ANALOGUE_LEFT_INPUT_0,\n\t   0, 31, 0),\nSOC_SINGLE(\"Left Input PGA Common Mode Switch\", WM8903_ANALOGUE_LEFT_INPUT_1,\n\t   6, 1, 0),\n\nSOC_SINGLE(\"Right Input PGA Switch\", WM8903_ANALOGUE_RIGHT_INPUT_0,\n\t   7, 1, 1),\nSOC_SINGLE(\"Right Input PGA Volume\", WM8903_ANALOGUE_RIGHT_INPUT_0,\n\t   0, 31, 0),\nSOC_SINGLE(\"Right Input PGA Common Mode Switch\", WM8903_ANALOGUE_RIGHT_INPUT_1,\n\t   6, 1, 0),\n\n \nSOC_ENUM(\"ADC OSR\", adc_osr),\nSOC_SINGLE(\"HPF Switch\", WM8903_ADC_DIGITAL_0, 4, 1, 0),\nSOC_ENUM(\"HPF Mode\", hpf_mode),\nSOC_SINGLE(\"DRC Switch\", WM8903_DRC_0, 15, 1, 0),\nSOC_ENUM(\"DRC Compressor Slope R0\", drc_slope_r0),\nSOC_ENUM(\"DRC Compressor Slope R1\", drc_slope_r1),\nSOC_SINGLE_TLV(\"DRC Compressor Threshold Volume\", WM8903_DRC_3, 5, 124, 1,\n\t       drc_tlv_thresh),\nSOC_SINGLE_TLV(\"DRC Volume\", WM8903_DRC_3, 0, 30, 1, drc_tlv_amp),\nSOC_SINGLE_TLV(\"DRC Minimum Gain Volume\", WM8903_DRC_1, 2, 3, 1, drc_tlv_min),\nSOC_SINGLE_TLV(\"DRC Maximum Gain Volume\", WM8903_DRC_1, 0, 3, 0, drc_tlv_max),\nSOC_ENUM(\"DRC Attack Rate\", drc_attack),\nSOC_ENUM(\"DRC Decay Rate\", drc_decay),\nSOC_ENUM(\"DRC FF Delay\", drc_ff_delay),\nSOC_SINGLE(\"DRC Anticlip Switch\", WM8903_DRC_0, 1, 1, 0),\nSOC_SINGLE(\"DRC QR Switch\", WM8903_DRC_0, 2, 1, 0),\nSOC_SINGLE_TLV(\"DRC QR Threshold Volume\", WM8903_DRC_0, 6, 3, 0, drc_tlv_max),\nSOC_ENUM(\"DRC QR Decay Rate\", drc_qr_decay),\nSOC_SINGLE(\"DRC Smoothing Switch\", WM8903_DRC_0, 3, 1, 0),\nSOC_SINGLE(\"DRC Smoothing Hysteresis Switch\", WM8903_DRC_0, 0, 1, 0),\nSOC_ENUM(\"DRC Smoothing Threshold\", drc_smoothing),\nSOC_SINGLE_TLV(\"DRC Startup Volume\", WM8903_DRC_0, 6, 18, 0, drc_tlv_startup),\n\nSOC_DOUBLE_R_TLV(\"Digital Capture Volume\", WM8903_ADC_DIGITAL_VOLUME_LEFT,\n\t\t WM8903_ADC_DIGITAL_VOLUME_RIGHT, 1, 120, 0, digital_tlv),\nSOC_ENUM(\"ADC Companding Mode\", adc_companding),\nSOC_SINGLE(\"ADC Companding Switch\", WM8903_AUDIO_INTERFACE_0, 3, 1, 0),\n\nSOC_DOUBLE_TLV(\"Digital Sidetone Volume\", WM8903_DAC_DIGITAL_0, 4, 8,\n\t       12, 0, digital_sidetone_tlv),\n\n \nSOC_ENUM(\"DAC OSR\", dac_osr),\nSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", WM8903_DAC_DIGITAL_VOLUME_LEFT,\n\t\t WM8903_DAC_DIGITAL_VOLUME_RIGHT, 1, 120, 0, digital_tlv),\nSOC_ENUM(\"DAC Soft Mute Rate\", soft_mute),\nSOC_ENUM(\"DAC Mute Mode\", mute_mode),\nSOC_SINGLE(\"DAC Mono Switch\", WM8903_DAC_DIGITAL_1, 12, 1, 0),\nSOC_ENUM(\"DAC Companding Mode\", dac_companding),\nSOC_SINGLE(\"DAC Companding Switch\", WM8903_AUDIO_INTERFACE_0, 1, 1, 0),\nSOC_SINGLE_TLV(\"DAC Boost Volume\", WM8903_AUDIO_INTERFACE_0, 9, 3, 0,\n\t       dac_boost_tlv),\nSOC_SINGLE_BOOL_EXT(\"Playback Deemphasis Switch\", 0,\n\t\t    wm8903_get_deemph, wm8903_put_deemph),\n\n \nSOC_DOUBLE_R(\"Headphone Switch\",\n\t     WM8903_ANALOGUE_OUT1_LEFT, WM8903_ANALOGUE_OUT1_RIGHT,\n\t     8, 1, 1),\nSOC_DOUBLE_R(\"Headphone ZC Switch\",\n\t     WM8903_ANALOGUE_OUT1_LEFT, WM8903_ANALOGUE_OUT1_RIGHT,\n\t     6, 1, 0),\nSOC_DOUBLE_R_TLV(\"Headphone Volume\",\n\t\t WM8903_ANALOGUE_OUT1_LEFT, WM8903_ANALOGUE_OUT1_RIGHT,\n\t\t 0, 63, 0, out_tlv),\n\n \nSOC_DOUBLE_R(\"Line Out Switch\",\n\t     WM8903_ANALOGUE_OUT2_LEFT, WM8903_ANALOGUE_OUT2_RIGHT,\n\t     8, 1, 1),\nSOC_DOUBLE_R(\"Line Out ZC Switch\",\n\t     WM8903_ANALOGUE_OUT2_LEFT, WM8903_ANALOGUE_OUT2_RIGHT,\n\t     6, 1, 0),\nSOC_DOUBLE_R_TLV(\"Line Out Volume\",\n\t\t WM8903_ANALOGUE_OUT2_LEFT, WM8903_ANALOGUE_OUT2_RIGHT,\n\t\t 0, 63, 0, out_tlv),\n\n \nSOC_DOUBLE_R(\"Speaker Switch\",\n\t     WM8903_ANALOGUE_OUT3_LEFT, WM8903_ANALOGUE_OUT3_RIGHT, 8, 1, 1),\nSOC_DOUBLE_R(\"Speaker ZC Switch\",\n\t     WM8903_ANALOGUE_OUT3_LEFT, WM8903_ANALOGUE_OUT3_RIGHT, 6, 1, 0),\nSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\t WM8903_ANALOGUE_OUT3_LEFT, WM8903_ANALOGUE_OUT3_RIGHT,\n\t\t 0, 63, 0, out_tlv),\n};\n\nstatic const struct snd_kcontrol_new linput_mode_mux =\n\tSOC_DAPM_ENUM(\"Left Input Mode Mux\", linput_mode_enum);\n\nstatic const struct snd_kcontrol_new rinput_mode_mux =\n\tSOC_DAPM_ENUM(\"Right Input Mode Mux\", rinput_mode_enum);\n\nstatic const struct snd_kcontrol_new linput_mux =\n\tSOC_DAPM_ENUM(\"Left Input Mux\", linput_enum);\n\nstatic const struct snd_kcontrol_new linput_inv_mux =\n\tSOC_DAPM_ENUM(\"Left Inverting Input Mux\", linput_inv_enum);\n\nstatic const struct snd_kcontrol_new rinput_mux =\n\tSOC_DAPM_ENUM(\"Right Input Mux\", rinput_enum);\n\nstatic const struct snd_kcontrol_new rinput_inv_mux =\n\tSOC_DAPM_ENUM(\"Right Inverting Input Mux\", rinput_inv_enum);\n\nstatic const struct snd_kcontrol_new lsidetone_mux =\n\tSOC_DAPM_ENUM(\"DACL Sidetone Mux\", lsidetone_enum);\n\nstatic const struct snd_kcontrol_new rsidetone_mux =\n\tSOC_DAPM_ENUM(\"DACR Sidetone Mux\", rsidetone_enum);\n\nstatic const struct snd_kcontrol_new adcinput_mux =\n\tSOC_DAPM_ENUM(\"ADC Input\", adcinput_enum);\n\nstatic const struct snd_kcontrol_new lcapture_mux =\n\tSOC_DAPM_ENUM(\"Left Capture Mux\", lcapture_enum);\n\nstatic const struct snd_kcontrol_new rcapture_mux =\n\tSOC_DAPM_ENUM(\"Right Capture Mux\", rcapture_enum);\n\nstatic const struct snd_kcontrol_new lplay_mux =\n\tSOC_DAPM_ENUM(\"Left Playback Mux\", lplay_enum);\n\nstatic const struct snd_kcontrol_new rplay_mux =\n\tSOC_DAPM_ENUM(\"Right Playback Mux\", rplay_enum);\n\nstatic const struct snd_kcontrol_new left_output_mixer[] = {\nSOC_DAPM_SINGLE(\"DACL Switch\", WM8903_ANALOGUE_LEFT_MIX_0, 3, 1, 0),\nSOC_DAPM_SINGLE(\"DACR Switch\", WM8903_ANALOGUE_LEFT_MIX_0, 2, 1, 0),\nSOC_DAPM_SINGLE_W(\"Left Bypass Switch\", WM8903_ANALOGUE_LEFT_MIX_0, 1, 1, 0),\nSOC_DAPM_SINGLE_W(\"Right Bypass Switch\", WM8903_ANALOGUE_LEFT_MIX_0, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_output_mixer[] = {\nSOC_DAPM_SINGLE(\"DACL Switch\", WM8903_ANALOGUE_RIGHT_MIX_0, 3, 1, 0),\nSOC_DAPM_SINGLE(\"DACR Switch\", WM8903_ANALOGUE_RIGHT_MIX_0, 2, 1, 0),\nSOC_DAPM_SINGLE_W(\"Left Bypass Switch\", WM8903_ANALOGUE_RIGHT_MIX_0, 1, 1, 0),\nSOC_DAPM_SINGLE_W(\"Right Bypass Switch\", WM8903_ANALOGUE_RIGHT_MIX_0, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new left_speaker_mixer[] = {\nSOC_DAPM_SINGLE(\"DACL Switch\", WM8903_ANALOGUE_SPK_MIX_LEFT_0, 3, 1, 0),\nSOC_DAPM_SINGLE(\"DACR Switch\", WM8903_ANALOGUE_SPK_MIX_LEFT_0, 2, 1, 0),\nSOC_DAPM_SINGLE(\"Left Bypass Switch\", WM8903_ANALOGUE_SPK_MIX_LEFT_0, 1, 1, 0),\nSOC_DAPM_SINGLE(\"Right Bypass Switch\", WM8903_ANALOGUE_SPK_MIX_LEFT_0,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_speaker_mixer[] = {\nSOC_DAPM_SINGLE(\"DACL Switch\", WM8903_ANALOGUE_SPK_MIX_RIGHT_0, 3, 1, 0),\nSOC_DAPM_SINGLE(\"DACR Switch\", WM8903_ANALOGUE_SPK_MIX_RIGHT_0, 2, 1, 0),\nSOC_DAPM_SINGLE(\"Left Bypass Switch\", WM8903_ANALOGUE_SPK_MIX_RIGHT_0,\n\t\t1, 1, 0),\nSOC_DAPM_SINGLE(\"Right Bypass Switch\", WM8903_ANALOGUE_SPK_MIX_RIGHT_0,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8903_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"IN1L\"),\nSND_SOC_DAPM_INPUT(\"IN1R\"),\nSND_SOC_DAPM_INPUT(\"IN2L\"),\nSND_SOC_DAPM_INPUT(\"IN2R\"),\nSND_SOC_DAPM_INPUT(\"IN3L\"),\nSND_SOC_DAPM_INPUT(\"IN3R\"),\nSND_SOC_DAPM_INPUT(\"DMICDAT\"),\n\nSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\nSND_SOC_DAPM_OUTPUT(\"LINEOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"LINEOUTR\"),\nSND_SOC_DAPM_OUTPUT(\"LOP\"),\nSND_SOC_DAPM_OUTPUT(\"LON\"),\nSND_SOC_DAPM_OUTPUT(\"ROP\"),\nSND_SOC_DAPM_OUTPUT(\"RON\"),\n\nSND_SOC_DAPM_SUPPLY(\"MICBIAS\", WM8903_MIC_BIAS_CONTROL_0, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"Left Input Mux\", SND_SOC_NOPM, 0, 0, &linput_mux),\nSND_SOC_DAPM_MUX(\"Left Input Inverting Mux\", SND_SOC_NOPM, 0, 0,\n\t\t &linput_inv_mux),\nSND_SOC_DAPM_MUX(\"Left Input Mode Mux\", SND_SOC_NOPM, 0, 0, &linput_mode_mux),\n\nSND_SOC_DAPM_MUX(\"Right Input Mux\", SND_SOC_NOPM, 0, 0, &rinput_mux),\nSND_SOC_DAPM_MUX(\"Right Input Inverting Mux\", SND_SOC_NOPM, 0, 0,\n\t\t &rinput_inv_mux),\nSND_SOC_DAPM_MUX(\"Right Input Mode Mux\", SND_SOC_NOPM, 0, 0, &rinput_mode_mux),\n\nSND_SOC_DAPM_PGA(\"Left Input PGA\", WM8903_POWER_MANAGEMENT_0, 1, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Input PGA\", WM8903_POWER_MANAGEMENT_0, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"Left ADC Input\", SND_SOC_NOPM, 0, 0, &adcinput_mux),\nSND_SOC_DAPM_MUX(\"Right ADC Input\", SND_SOC_NOPM, 0, 0, &adcinput_mux),\n\nSND_SOC_DAPM_ADC(\"ADCL\", NULL, WM8903_POWER_MANAGEMENT_6, 1, 0),\nSND_SOC_DAPM_ADC(\"ADCR\", NULL, WM8903_POWER_MANAGEMENT_6, 0, 0),\n\nSND_SOC_DAPM_MUX(\"Left Capture Mux\", SND_SOC_NOPM, 0, 0, &lcapture_mux),\nSND_SOC_DAPM_MUX(\"Right Capture Mux\", SND_SOC_NOPM, 0, 0, &rcapture_mux),\n\nSND_SOC_DAPM_AIF_OUT(\"AIFTXL\", \"Left HiFi Capture\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIFTXR\", \"Right HiFi Capture\", 0, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_MUX(\"DACL Sidetone\", SND_SOC_NOPM, 0, 0, &lsidetone_mux),\nSND_SOC_DAPM_MUX(\"DACR Sidetone\", SND_SOC_NOPM, 0, 0, &rsidetone_mux),\n\nSND_SOC_DAPM_AIF_IN(\"AIFRXL\", \"Left Playback\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_IN(\"AIFRXR\", \"Right Playback\", 0, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_MUX(\"Left Playback Mux\", SND_SOC_NOPM, 0, 0, &lplay_mux),\nSND_SOC_DAPM_MUX(\"Right Playback Mux\", SND_SOC_NOPM, 0, 0, &rplay_mux),\n\nSND_SOC_DAPM_DAC(\"DACL\", NULL, WM8903_POWER_MANAGEMENT_6, 3, 0),\nSND_SOC_DAPM_DAC(\"DACR\", NULL, WM8903_POWER_MANAGEMENT_6, 2, 0),\n\nSND_SOC_DAPM_MIXER(\"Left Output Mixer\", WM8903_POWER_MANAGEMENT_1, 1, 0,\n\t\t   left_output_mixer, ARRAY_SIZE(left_output_mixer)),\nSND_SOC_DAPM_MIXER(\"Right Output Mixer\", WM8903_POWER_MANAGEMENT_1, 0, 0,\n\t\t   right_output_mixer, ARRAY_SIZE(right_output_mixer)),\n\nSND_SOC_DAPM_MIXER(\"Left Speaker Mixer\", WM8903_POWER_MANAGEMENT_4, 1, 0,\n\t\t   left_speaker_mixer, ARRAY_SIZE(left_speaker_mixer)),\nSND_SOC_DAPM_MIXER(\"Right Speaker Mixer\", WM8903_POWER_MANAGEMENT_4, 0, 0,\n\t\t   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),\n\nSND_SOC_DAPM_PGA_S(\"Left Headphone Output PGA\", 0, WM8903_POWER_MANAGEMENT_2,\n\t\t   1, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"Right Headphone Output PGA\", 0, WM8903_POWER_MANAGEMENT_2,\n\t\t   0, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA_S(\"Left Line Output PGA\", 0, WM8903_POWER_MANAGEMENT_3, 1, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"Right Line Output PGA\", 0, WM8903_POWER_MANAGEMENT_3, 0, 0,\n\t\t   NULL, 0),\n\nSND_SOC_DAPM_PGA_S(\"HPL_RMV_SHORT\", 4, WM8903_ANALOGUE_HP_0, 7, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPL_ENA_OUTP\", 3, WM8903_ANALOGUE_HP_0, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPL_ENA_DLY\", 2, WM8903_ANALOGUE_HP_0, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPL_ENA\", 1, WM8903_ANALOGUE_HP_0, 4, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPR_RMV_SHORT\", 4, WM8903_ANALOGUE_HP_0, 3, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPR_ENA_OUTP\", 3, WM8903_ANALOGUE_HP_0, 2, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPR_ENA_DLY\", 2, WM8903_ANALOGUE_HP_0, 1, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPR_ENA\", 1, WM8903_ANALOGUE_HP_0, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA_S(\"LINEOUTL_RMV_SHORT\", 4, WM8903_ANALOGUE_LINEOUT_0, 7, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTL_ENA_OUTP\", 3, WM8903_ANALOGUE_LINEOUT_0, 6, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTL_ENA_DLY\", 2, WM8903_ANALOGUE_LINEOUT_0, 5, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTL_ENA\", 1, WM8903_ANALOGUE_LINEOUT_0, 4, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTR_RMV_SHORT\", 4, WM8903_ANALOGUE_LINEOUT_0, 3, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTR_ENA_OUTP\", 3, WM8903_ANALOGUE_LINEOUT_0, 2, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTR_ENA_DLY\", 2, WM8903_ANALOGUE_LINEOUT_0, 1, 0,\n\t\t   NULL, 0),\nSND_SOC_DAPM_PGA_S(\"LINEOUTR_ENA\", 1, WM8903_ANALOGUE_LINEOUT_0, 0, 0,\n\t\t   NULL, 0),\n\nSND_SOC_DAPM_SUPPLY(\"DCS Master\", WM8903_DC_SERVO_0, 4, 0, NULL, 0),\nSND_SOC_DAPM_PGA_S(\"HPL_DCS\", 3, SND_SOC_NOPM, 3, 0, wm8903_dcs_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\nSND_SOC_DAPM_PGA_S(\"HPR_DCS\", 3, SND_SOC_NOPM, 2, 0, wm8903_dcs_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\nSND_SOC_DAPM_PGA_S(\"LINEOUTL_DCS\", 3, SND_SOC_NOPM, 1, 0, wm8903_dcs_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\nSND_SOC_DAPM_PGA_S(\"LINEOUTR_DCS\", 3, SND_SOC_NOPM, 0, 0, wm8903_dcs_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\nSND_SOC_DAPM_PGA(\"Left Speaker PGA\", WM8903_POWER_MANAGEMENT_5, 1, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Speaker PGA\", WM8903_POWER_MANAGEMENT_5, 0, 0,\n\t\t NULL, 0),\n\nSND_SOC_DAPM_SUPPLY(\"Charge Pump\", WM8903_CHARGE_PUMP_0, 0, 0,\n\t\t    wm8903_cp_event, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_SUPPLY(\"CLK_DSP\", WM8903_CLOCK_RATES_2, 1, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"CLK_SYS\", WM8903_CLOCK_RATES_2, 2, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route wm8903_intercon[] = {\n\n\t{ \"CLK_DSP\", NULL, \"CLK_SYS\" },\n\t{ \"MICBIAS\", NULL, \"CLK_SYS\" },\n\t{ \"HPL_DCS\", NULL, \"CLK_SYS\" },\n\t{ \"HPR_DCS\", NULL, \"CLK_SYS\" },\n\t{ \"LINEOUTL_DCS\", NULL, \"CLK_SYS\" },\n\t{ \"LINEOUTR_DCS\", NULL, \"CLK_SYS\" },\n\n\t{ \"Left Input Mux\", \"IN1L\", \"IN1L\" },\n\t{ \"Left Input Mux\", \"IN2L\", \"IN2L\" },\n\t{ \"Left Input Mux\", \"IN3L\", \"IN3L\" },\n\n\t{ \"Left Input Inverting Mux\", \"IN1L\", \"IN1L\" },\n\t{ \"Left Input Inverting Mux\", \"IN2L\", \"IN2L\" },\n\t{ \"Left Input Inverting Mux\", \"IN3L\", \"IN3L\" },\n\n\t{ \"Right Input Mux\", \"IN1R\", \"IN1R\" },\n\t{ \"Right Input Mux\", \"IN2R\", \"IN2R\" },\n\t{ \"Right Input Mux\", \"IN3R\", \"IN3R\" },\n\n\t{ \"Right Input Inverting Mux\", \"IN1R\", \"IN1R\" },\n\t{ \"Right Input Inverting Mux\", \"IN2R\", \"IN2R\" },\n\t{ \"Right Input Inverting Mux\", \"IN3R\", \"IN3R\" },\n\n\t{ \"Left Input Mode Mux\", \"Single-Ended\", \"Left Input Inverting Mux\" },\n\t{ \"Left Input Mode Mux\", \"Differential Line\",\n\t  \"Left Input Mux\" },\n\t{ \"Left Input Mode Mux\", \"Differential Line\",\n\t  \"Left Input Inverting Mux\" },\n\t{ \"Left Input Mode Mux\", \"Differential Mic\",\n\t  \"Left Input Mux\" },\n\t{ \"Left Input Mode Mux\", \"Differential Mic\",\n\t  \"Left Input Inverting Mux\" },\n\n\t{ \"Right Input Mode Mux\", \"Single-Ended\",\n\t  \"Right Input Inverting Mux\" },\n\t{ \"Right Input Mode Mux\", \"Differential Line\",\n\t  \"Right Input Mux\" },\n\t{ \"Right Input Mode Mux\", \"Differential Line\",\n\t  \"Right Input Inverting Mux\" },\n\t{ \"Right Input Mode Mux\", \"Differential Mic\",\n\t  \"Right Input Mux\" },\n\t{ \"Right Input Mode Mux\", \"Differential Mic\",\n\t  \"Right Input Inverting Mux\" },\n\n\t{ \"Left Input PGA\", NULL, \"Left Input Mode Mux\" },\n\t{ \"Right Input PGA\", NULL, \"Right Input Mode Mux\" },\n\n\t{ \"Left ADC Input\", \"ADC\", \"Left Input PGA\" },\n\t{ \"Left ADC Input\", \"DMIC\", \"DMICDAT\" },\n\t{ \"Right ADC Input\", \"ADC\", \"Right Input PGA\" },\n\t{ \"Right ADC Input\", \"DMIC\", \"DMICDAT\" },\n\n\t{ \"Left Capture Mux\", \"Left\", \"ADCL\" },\n\t{ \"Left Capture Mux\", \"Right\", \"ADCR\" },\n\n\t{ \"Right Capture Mux\", \"Left\", \"ADCL\" },\n\t{ \"Right Capture Mux\", \"Right\", \"ADCR\" },\n\n\t{ \"AIFTXL\", NULL, \"Left Capture Mux\" },\n\t{ \"AIFTXR\", NULL, \"Right Capture Mux\" },\n\n\t{ \"ADCL\", NULL, \"Left ADC Input\" },\n\t{ \"ADCL\", NULL, \"CLK_DSP\" },\n\t{ \"ADCR\", NULL, \"Right ADC Input\" },\n\t{ \"ADCR\", NULL, \"CLK_DSP\" },\n\n\t{ \"Left Playback Mux\", \"Left\", \"AIFRXL\" },\n\t{ \"Left Playback Mux\", \"Right\", \"AIFRXR\" },\n\n\t{ \"Right Playback Mux\", \"Left\", \"AIFRXL\" },\n\t{ \"Right Playback Mux\", \"Right\", \"AIFRXR\" },\n\n\t{ \"DACL Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACL Sidetone\", \"Right\", \"ADCR\" },\n\t{ \"DACR Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACR Sidetone\", \"Right\", \"ADCR\" },\n\n\t{ \"DACL\", NULL, \"Left Playback Mux\" },\n\t{ \"DACL\", NULL, \"DACL Sidetone\" },\n\t{ \"DACL\", NULL, \"CLK_DSP\" },\n\n\t{ \"DACR\", NULL, \"Right Playback Mux\" },\n\t{ \"DACR\", NULL, \"DACR Sidetone\" },\n\t{ \"DACR\", NULL, \"CLK_DSP\" },\n\n\t{ \"Left Output Mixer\", \"Left Bypass Switch\", \"Left Input PGA\" },\n\t{ \"Left Output Mixer\", \"Right Bypass Switch\", \"Right Input PGA\" },\n\t{ \"Left Output Mixer\", \"DACL Switch\", \"DACL\" },\n\t{ \"Left Output Mixer\", \"DACR Switch\", \"DACR\" },\n\n\t{ \"Right Output Mixer\", \"Left Bypass Switch\", \"Left Input PGA\" },\n\t{ \"Right Output Mixer\", \"Right Bypass Switch\", \"Right Input PGA\" },\n\t{ \"Right Output Mixer\", \"DACL Switch\", \"DACL\" },\n\t{ \"Right Output Mixer\", \"DACR Switch\", \"DACR\" },\n\n\t{ \"Left Speaker Mixer\", \"Left Bypass Switch\", \"Left Input PGA\" },\n\t{ \"Left Speaker Mixer\", \"Right Bypass Switch\", \"Right Input PGA\" },\n\t{ \"Left Speaker Mixer\", \"DACL Switch\", \"DACL\" },\n\t{ \"Left Speaker Mixer\", \"DACR Switch\", \"DACR\" },\n\n\t{ \"Right Speaker Mixer\", \"Left Bypass Switch\", \"Left Input PGA\" },\n\t{ \"Right Speaker Mixer\", \"Right Bypass Switch\", \"Right Input PGA\" },\n\t{ \"Right Speaker Mixer\", \"DACL Switch\", \"DACL\" },\n\t{ \"Right Speaker Mixer\", \"DACR Switch\", \"DACR\" },\n\n\t{ \"Left Line Output PGA\", NULL, \"Left Output Mixer\" },\n\t{ \"Right Line Output PGA\", NULL, \"Right Output Mixer\" },\n\n\t{ \"Left Headphone Output PGA\", NULL, \"Left Output Mixer\" },\n\t{ \"Right Headphone Output PGA\", NULL, \"Right Output Mixer\" },\n\n\t{ \"Left Speaker PGA\", NULL, \"Left Speaker Mixer\" },\n\t{ \"Right Speaker PGA\", NULL, \"Right Speaker Mixer\" },\n\n\t{ \"HPL_ENA\", NULL, \"Left Headphone Output PGA\" },\n\t{ \"HPR_ENA\", NULL, \"Right Headphone Output PGA\" },\n\t{ \"HPL_ENA_DLY\", NULL, \"HPL_ENA\" },\n\t{ \"HPR_ENA_DLY\", NULL, \"HPR_ENA\" },\n\t{ \"LINEOUTL_ENA\", NULL, \"Left Line Output PGA\" },\n\t{ \"LINEOUTR_ENA\", NULL, \"Right Line Output PGA\" },\n\t{ \"LINEOUTL_ENA_DLY\", NULL, \"LINEOUTL_ENA\" },\n\t{ \"LINEOUTR_ENA_DLY\", NULL, \"LINEOUTR_ENA\" },\n\n\t{ \"HPL_DCS\", NULL, \"DCS Master\" },\n\t{ \"HPR_DCS\", NULL, \"DCS Master\" },\n\t{ \"LINEOUTL_DCS\", NULL, \"DCS Master\" },\n\t{ \"LINEOUTR_DCS\", NULL, \"DCS Master\" },\n\n\t{ \"HPL_DCS\", NULL, \"HPL_ENA_DLY\" },\n\t{ \"HPR_DCS\", NULL, \"HPR_ENA_DLY\" },\n\t{ \"LINEOUTL_DCS\", NULL, \"LINEOUTL_ENA_DLY\" },\n\t{ \"LINEOUTR_DCS\", NULL, \"LINEOUTR_ENA_DLY\" },\n\n\t{ \"HPL_ENA_OUTP\", NULL, \"HPL_DCS\" },\n\t{ \"HPR_ENA_OUTP\", NULL, \"HPR_DCS\" },\n\t{ \"LINEOUTL_ENA_OUTP\", NULL, \"LINEOUTL_DCS\" },\n\t{ \"LINEOUTR_ENA_OUTP\", NULL, \"LINEOUTR_DCS\" },\n\n\t{ \"HPL_RMV_SHORT\", NULL, \"HPL_ENA_OUTP\" },\n\t{ \"HPR_RMV_SHORT\", NULL, \"HPR_ENA_OUTP\" },\n\t{ \"LINEOUTL_RMV_SHORT\", NULL, \"LINEOUTL_ENA_OUTP\" },\n\t{ \"LINEOUTR_RMV_SHORT\", NULL, \"LINEOUTR_ENA_OUTP\" },\n\n\t{ \"HPOUTL\", NULL, \"HPL_RMV_SHORT\" },\n\t{ \"HPOUTR\", NULL, \"HPR_RMV_SHORT\" },\n\t{ \"LINEOUTL\", NULL, \"LINEOUTL_RMV_SHORT\" },\n\t{ \"LINEOUTR\", NULL, \"LINEOUTR_RMV_SHORT\" },\n\n\t{ \"LOP\", NULL, \"Left Speaker PGA\" },\n\t{ \"LON\", NULL, \"Left Speaker PGA\" },\n\n\t{ \"ROP\", NULL, \"Right Speaker PGA\" },\n\t{ \"RON\", NULL, \"Right Speaker PGA\" },\n\n\t{ \"Charge Pump\", NULL, \"CLK_DSP\" },\n\n\t{ \"Left Headphone Output PGA\", NULL, \"Charge Pump\" },\n\t{ \"Right Headphone Output PGA\", NULL, \"Charge Pump\" },\n\t{ \"Left Line Output PGA\", NULL, \"Charge Pump\" },\n\t{ \"Right Line Output PGA\", NULL, \"Charge Pump\" },\n};\n\nstatic int wm8903_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t    WM8903_VMID_RES_MASK,\n\t\t\t\t    WM8903_VMID_RES_50K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tsnd_soc_component_update_bits(component, WM8903_BIAS_CONTROL_0,\n\t\t\t\t\t    WM8903_POBCTRL | WM8903_ISEL_MASK |\n\t\t\t\t\t    WM8903_STARTUP_BIAS_ENA |\n\t\t\t\t\t    WM8903_BIAS_ENA,\n\t\t\t\t\t    WM8903_POBCTRL |\n\t\t\t\t\t    (2 << WM8903_ISEL_SHIFT) |\n\t\t\t\t\t    WM8903_STARTUP_BIAS_ENA);\n\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t    WM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0,\n\t\t\t\t\t    WM8903_SPK_DISCHARGE,\n\t\t\t\t\t    WM8903_SPK_DISCHARGE);\n\n\t\t\tmsleep(33);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_POWER_MANAGEMENT_5,\n\t\t\t\t\t    WM8903_SPKL_ENA | WM8903_SPKR_ENA,\n\t\t\t\t\t    WM8903_SPKL_ENA | WM8903_SPKR_ENA);\n\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t    WM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0,\n\t\t\t\t\t    WM8903_SPK_DISCHARGE, 0);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t\t    WM8903_VMID_TIE_ENA |\n\t\t\t\t\t    WM8903_BUFIO_ENA |\n\t\t\t\t\t    WM8903_VMID_IO_ENA |\n\t\t\t\t\t    WM8903_VMID_SOFT_MASK |\n\t\t\t\t\t    WM8903_VMID_RES_MASK |\n\t\t\t\t\t    WM8903_VMID_BUF_ENA,\n\t\t\t\t\t    WM8903_VMID_TIE_ENA |\n\t\t\t\t\t    WM8903_BUFIO_ENA |\n\t\t\t\t\t    WM8903_VMID_IO_ENA |\n\t\t\t\t\t    (2 << WM8903_VMID_SOFT_SHIFT) |\n\t\t\t\t\t    WM8903_VMID_RES_250K |\n\t\t\t\t\t    WM8903_VMID_BUF_ENA);\n\n\t\t\tmsleep(129);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_POWER_MANAGEMENT_5,\n\t\t\t\t\t    WM8903_SPKL_ENA | WM8903_SPKR_ENA,\n\t\t\t\t\t    0);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t\t    WM8903_VMID_SOFT_MASK, 0);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t\t    WM8903_VMID_RES_MASK,\n\t\t\t\t\t    WM8903_VMID_RES_50K);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8903_BIAS_CONTROL_0,\n\t\t\t\t\t    WM8903_BIAS_ENA | WM8903_POBCTRL,\n\t\t\t\t\t    WM8903_BIAS_ENA);\n\n\t\t\t \n\t\t\tdev_dbg(component->dev, \"Enabling Class W\\n\");\n\t\t\tsnd_soc_component_update_bits(component, WM8903_CLASS_W_0,\n\t\t\t\t\t    WM8903_CP_DYN_FREQ |\n\t\t\t\t\t    WM8903_CP_DYN_V,\n\t\t\t\t\t    WM8903_CP_DYN_FREQ |\n\t\t\t\t\t    WM8903_CP_DYN_V);\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t    WM8903_VMID_RES_MASK,\n\t\t\t\t    WM8903_VMID_RES_250K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8903_BIAS_CONTROL_0,\n\t\t\t\t    WM8903_BIAS_ENA, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t    WM8903_VMID_SOFT_MASK,\n\t\t\t\t    2 << WM8903_VMID_SOFT_SHIFT);\n\n\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t    WM8903_VMID_BUF_ENA, 0);\n\n\t\tmsleep(290);\n\n\t\tsnd_soc_component_update_bits(component, WM8903_VMID_CONTROL_0,\n\t\t\t\t    WM8903_VMID_TIE_ENA | WM8903_BUFIO_ENA |\n\t\t\t\t    WM8903_VMID_IO_ENA | WM8903_VMID_RES_MASK |\n\t\t\t\t    WM8903_VMID_SOFT_MASK |\n\t\t\t\t    WM8903_VMID_BUF_ENA, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8903_BIAS_CONTROL_0,\n\t\t\t\t    WM8903_STARTUP_BIAS_ENA, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8903_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\n\twm8903->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int wm8903_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 aif1 = snd_soc_component_read(component, WM8903_AUDIO_INTERFACE_1);\n\n\taif1 &= ~(WM8903_LRCLK_DIR | WM8903_BCLK_DIR | WM8903_AIF_FMT_MASK |\n\t\t  WM8903_AIF_LRCLK_INV | WM8903_AIF_BCLK_INV);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\taif1 |= WM8903_LRCLK_DIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif1 |= WM8903_LRCLK_DIR | WM8903_BCLK_DIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\taif1 |= WM8903_BCLK_DIR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif1 |= 0x3;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif1 |= 0x3 | WM8903_AIF_LRCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif1 |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\taif1 |= 0x1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8903_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif1 |= WM8903_AIF_BCLK_INV | WM8903_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8903_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif1 |= WM8903_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8903_AUDIO_INTERFACE_1, aif1);\n\n\treturn 0;\n}\n\nstatic int wm8903_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\n\treg = snd_soc_component_read(component, WM8903_DAC_DIGITAL_1);\n\n\tif (mute)\n\t\treg |= WM8903_DAC_MUTE;\n\telse\n\t\treg &= ~WM8903_DAC_MUTE;\n\n\tsnd_soc_component_write(component, WM8903_DAC_DIGITAL_1, reg);\n\n\treturn 0;\n}\n\n \nstatic struct {\n\tint div;\n\tint rate;\n\tint mode;\n\tint mclk_div;\n} clk_sys_ratios[] = {\n\t{   64, 0x0, 0x0, 1 },\n\t{   68, 0x0, 0x1, 1 },\n\t{  125, 0x0, 0x2, 1 },\n\t{  128, 0x1, 0x0, 1 },\n\t{  136, 0x1, 0x1, 1 },\n\t{  192, 0x2, 0x0, 1 },\n\t{  204, 0x2, 0x1, 1 },\n\n\t{   64, 0x0, 0x0, 2 },\n\t{   68, 0x0, 0x1, 2 },\n\t{  125, 0x0, 0x2, 2 },\n\t{  128, 0x1, 0x0, 2 },\n\t{  136, 0x1, 0x1, 2 },\n\t{  192, 0x2, 0x0, 2 },\n\t{  204, 0x2, 0x1, 2 },\n\n\t{  250, 0x2, 0x2, 1 },\n\t{  256, 0x3, 0x0, 1 },\n\t{  272, 0x3, 0x1, 1 },\n\t{  384, 0x4, 0x0, 1 },\n\t{  408, 0x4, 0x1, 1 },\n\t{  375, 0x4, 0x2, 1 },\n\t{  512, 0x5, 0x0, 1 },\n\t{  544, 0x5, 0x1, 1 },\n\t{  500, 0x5, 0x2, 1 },\n\t{  768, 0x6, 0x0, 1 },\n\t{  816, 0x6, 0x1, 1 },\n\t{  750, 0x6, 0x2, 1 },\n\t{ 1024, 0x7, 0x0, 1 },\n\t{ 1088, 0x7, 0x1, 1 },\n\t{ 1000, 0x7, 0x2, 1 },\n\t{ 1408, 0x8, 0x0, 1 },\n\t{ 1496, 0x8, 0x1, 1 },\n\t{ 1536, 0x9, 0x0, 1 },\n\t{ 1632, 0x9, 0x1, 1 },\n\t{ 1500, 0x9, 0x2, 1 },\n\n\t{  250, 0x2, 0x2, 2 },\n\t{  256, 0x3, 0x0, 2 },\n\t{  272, 0x3, 0x1, 2 },\n\t{  384, 0x4, 0x0, 2 },\n\t{  408, 0x4, 0x1, 2 },\n\t{  375, 0x4, 0x2, 2 },\n\t{  512, 0x5, 0x0, 2 },\n\t{  544, 0x5, 0x1, 2 },\n\t{  500, 0x5, 0x2, 2 },\n\t{  768, 0x6, 0x0, 2 },\n\t{  816, 0x6, 0x1, 2 },\n\t{  750, 0x6, 0x2, 2 },\n\t{ 1024, 0x7, 0x0, 2 },\n\t{ 1088, 0x7, 0x1, 2 },\n\t{ 1000, 0x7, 0x2, 2 },\n\t{ 1408, 0x8, 0x0, 2 },\n\t{ 1496, 0x8, 0x1, 2 },\n\t{ 1536, 0x9, 0x0, 2 },\n\t{ 1632, 0x9, 0x1, 2 },\n\t{ 1500, 0x9, 0x2, 2 },\n};\n\n \nstatic struct {\n\tint ratio;\n\tint div;\n} bclk_divs[] = {\n\t{  10,  0 },\n\t{  20,  2 },\n\t{  30,  3 },\n\t{  40,  4 },\n\t{  50,  5 },\n\t{  60,  7 },\n\t{  80,  8 },\n\t{ 100,  9 },\n\t{ 120, 11 },\n\t{ 160, 12 },\n\t{ 200, 13 },\n\t{ 220, 14 },\n\t{ 240, 15 },\n\t{ 300, 17 },\n\t{ 320, 18 },\n\t{ 440, 19 },\n\t{ 480, 20 },\n};\n\n \nstatic struct {\n\tint rate;\n\tint value;\n} sample_rates[] = {\n\t{  8000,  0 },\n\t{ 11025,  1 },\n\t{ 12000,  2 },\n\t{ 16000,  3 },\n\t{ 22050,  4 },\n\t{ 24000,  5 },\n\t{ 32000,  6 },\n\t{ 44100,  7 },\n\t{ 48000,  8 },\n\t{ 88200,  9 },\n\t{ 96000, 10 },\n\t{ 0,      0 },\n};\n\nstatic int wm8903_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tint fs = params_rate(params);\n\tint bclk;\n\tint bclk_div;\n\tint i;\n\tint dsp_config;\n\tint clk_config;\n\tint best_val;\n\tint cur_val;\n\tint clk_sys;\n\n\tu16 aif1 = snd_soc_component_read(component, WM8903_AUDIO_INTERFACE_1);\n\tu16 aif2 = snd_soc_component_read(component, WM8903_AUDIO_INTERFACE_2);\n\tu16 aif3 = snd_soc_component_read(component, WM8903_AUDIO_INTERFACE_3);\n\tu16 clock0 = snd_soc_component_read(component, WM8903_CLOCK_RATES_0);\n\tu16 clock1 = snd_soc_component_read(component, WM8903_CLOCK_RATES_1);\n\tu16 dac_digital1 = snd_soc_component_read(component, WM8903_DAC_DIGITAL_1);\n\n\t \n\tif (fs <= 24000)\n\t\tdac_digital1 |= WM8903_DAC_SB_FILT;\n\telse\n\t\tdac_digital1 &= ~WM8903_DAC_SB_FILT;\n\n\t \n\tdsp_config = 0;\n\tbest_val = abs(sample_rates[dsp_config].rate - fs);\n\tfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\n\t\tcur_val = abs(sample_rates[i].rate - fs);\n\t\tif (cur_val <= best_val) {\n\t\t\tdsp_config = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"DSP fs = %dHz\\n\", sample_rates[dsp_config].rate);\n\tclock1 &= ~WM8903_SAMPLE_RATE_MASK;\n\tclock1 |= sample_rates[dsp_config].value;\n\n\taif1 &= ~WM8903_AIF_WL_MASK;\n\tbclk = 2 * fs;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbclk *= 16;\n\t\tbreak;\n\tcase 20:\n\t\tbclk *= 20;\n\t\taif1 |= 0x4;\n\t\tbreak;\n\tcase 24:\n\t\tbclk *= 24;\n\t\taif1 |= 0x8;\n\t\tbreak;\n\tcase 32:\n\t\tbclk *= 32;\n\t\taif1 |= 0xc;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"MCLK = %dHz, target sample rate = %dHz\\n\",\n\t\twm8903->sysclk, fs);\n\n\t \n\tclk_config = 0;\n\tbest_val = abs((wm8903->sysclk /\n\t\t\t(clk_sys_ratios[0].mclk_div *\n\t\t\t clk_sys_ratios[0].div)) - fs);\n\tfor (i = 1; i < ARRAY_SIZE(clk_sys_ratios); i++) {\n\t\tcur_val = abs((wm8903->sysclk /\n\t\t\t       (clk_sys_ratios[i].mclk_div *\n\t\t\t\tclk_sys_ratios[i].div)) - fs);\n\n\t\tif (cur_val <= best_val) {\n\t\t\tclk_config = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\n\tif (clk_sys_ratios[clk_config].mclk_div == 2) {\n\t\tclock0 |= WM8903_MCLKDIV2;\n\t\tclk_sys = wm8903->sysclk / 2;\n\t} else {\n\t\tclock0 &= ~WM8903_MCLKDIV2;\n\t\tclk_sys = wm8903->sysclk;\n\t}\n\n\tclock1 &= ~(WM8903_CLK_SYS_RATE_MASK |\n\t\t    WM8903_CLK_SYS_MODE_MASK);\n\tclock1 |= clk_sys_ratios[clk_config].rate << WM8903_CLK_SYS_RATE_SHIFT;\n\tclock1 |= clk_sys_ratios[clk_config].mode << WM8903_CLK_SYS_MODE_SHIFT;\n\n\tdev_dbg(component->dev, \"CLK_SYS_RATE=%x, CLK_SYS_MODE=%x div=%d\\n\",\n\t\tclk_sys_ratios[clk_config].rate,\n\t\tclk_sys_ratios[clk_config].mode,\n\t\tclk_sys_ratios[clk_config].div);\n\n\tdev_dbg(component->dev, \"Actual CLK_SYS = %dHz\\n\", clk_sys);\n\n\t \n\tbclk_div = 0;\n\ti = 1;\n\twhile (i < ARRAY_SIZE(bclk_divs)) {\n\t\tcur_val = ((clk_sys * 10) / bclk_divs[i].ratio) - bclk;\n\t\tif (cur_val < 0)  \n\t\t\tbreak;\n\t\tbclk_div = i;\n\t\ti++;\n\t}\n\n\taif2 &= ~WM8903_BCLK_DIV_MASK;\n\taif3 &= ~WM8903_LRCLK_RATE_MASK;\n\n\tdev_dbg(component->dev, \"BCLK ratio %d for %dHz - actual BCLK = %dHz\\n\",\n\t\tbclk_divs[bclk_div].ratio / 10, bclk,\n\t\t(clk_sys * 10) / bclk_divs[bclk_div].ratio);\n\n\taif2 |= bclk_divs[bclk_div].div;\n\taif3 |= bclk / fs;\n\n\twm8903->fs = params_rate(params);\n\twm8903_set_deemph(component);\n\n\tsnd_soc_component_write(component, WM8903_CLOCK_RATES_0, clock0);\n\tsnd_soc_component_write(component, WM8903_CLOCK_RATES_1, clock1);\n\tsnd_soc_component_write(component, WM8903_AUDIO_INTERFACE_1, aif1);\n\tsnd_soc_component_write(component, WM8903_AUDIO_INTERFACE_2, aif2);\n\tsnd_soc_component_write(component, WM8903_AUDIO_INTERFACE_3, aif3);\n\tsnd_soc_component_write(component, WM8903_DAC_DIGITAL_1, dac_digital1);\n\n\treturn 0;\n}\n\n \nint wm8903_mic_detect(struct snd_soc_component *component, struct snd_soc_jack *jack,\n\t\t      int det, int shrt)\n{\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\tint irq_mask = WM8903_MICDET_EINT | WM8903_MICSHRT_EINT;\n\n\tdev_dbg(component->dev, \"Enabling microphone detection: %x %x\\n\",\n\t\tdet, shrt);\n\n\t \n\twm8903->mic_jack = jack;\n\twm8903->mic_det = det;\n\twm8903->mic_short = shrt;\n\n\t \n\tif (det)\n\t\tirq_mask &= ~WM8903_MICDET_EINT;\n\tif (shrt)\n\t\tirq_mask &= ~WM8903_MICSHRT_EINT;\n\n\tsnd_soc_component_update_bits(component, WM8903_INTERRUPT_STATUS_1_MASK,\n\t\t\t    WM8903_MICDET_EINT | WM8903_MICSHRT_EINT,\n\t\t\t    irq_mask);\n\n\tif (det || shrt) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8903_WRITE_SEQUENCER_0,\n\t\t\t\t    WM8903_WSEQ_ENA, WM8903_WSEQ_ENA);\n\t\tsnd_soc_component_update_bits(component, WM8903_MIC_BIAS_CONTROL_0,\n\t\t\t\t    WM8903_MICDET_ENA, WM8903_MICDET_ENA);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, WM8903_MIC_BIAS_CONTROL_0,\n\t\t\t\t    WM8903_MICDET_ENA, 0);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8903_mic_detect);\n\nstatic irqreturn_t wm8903_irq(int irq, void *data)\n{\n\tstruct wm8903_priv *wm8903 = data;\n\tint mic_report, ret;\n\tunsigned int int_val, mask, int_pol;\n\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_STATUS_1_MASK,\n\t\t\t  &mask);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, \"Failed to read IRQ mask: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_STATUS_1, &int_val);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, \"Failed to read IRQ status: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tint_val &= ~mask;\n\n\tif (int_val & WM8903_WSEQ_BUSY_EINT) {\n\t\tdev_warn(wm8903->dev, \"Write sequencer done\\n\");\n\t}\n\n\t \n\tmic_report = wm8903->mic_last_report;\n\tret = regmap_read(wm8903->regmap, WM8903_INTERRUPT_POLARITY_1,\n\t\t\t  &int_pol);\n\tif (ret != 0) {\n\t\tdev_err(wm8903->dev, \"Failed to read interrupt polarity: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n#ifndef CONFIG_SND_SOC_WM8903_MODULE\n\tif (int_val & (WM8903_MICSHRT_EINT | WM8903_MICDET_EINT))\n\t\ttrace_snd_soc_jack_irq(dev_name(wm8903->dev));\n#endif\n\n\tif (int_val & WM8903_MICSHRT_EINT) {\n\t\tdev_dbg(wm8903->dev, \"Microphone short (pol=%x)\\n\", int_pol);\n\n\t\tmic_report ^= wm8903->mic_short;\n\t\tint_pol ^= WM8903_MICSHRT_INV;\n\t}\n\n\tif (int_val & WM8903_MICDET_EINT) {\n\t\tdev_dbg(wm8903->dev, \"Microphone detect (pol=%x)\\n\", int_pol);\n\n\t\tmic_report ^= wm8903->mic_det;\n\t\tint_pol ^= WM8903_MICDET_INV;\n\n\t\tmsleep(wm8903->mic_delay);\n\t}\n\n\tregmap_update_bits(wm8903->regmap, WM8903_INTERRUPT_POLARITY_1,\n\t\t\t   WM8903_MICSHRT_INV | WM8903_MICDET_INV, int_pol);\n\n\tsnd_soc_jack_report(wm8903->mic_jack, mic_report,\n\t\t\t    wm8903->mic_short | wm8903->mic_det);\n\n\twm8903->mic_last_report = mic_report;\n\n\treturn IRQ_HANDLED;\n}\n\n#define WM8903_PLAYBACK_RATES (SNDRV_PCM_RATE_8000 |\\\n\t\t\t       SNDRV_PCM_RATE_11025 |\t\\\n\t\t\t       SNDRV_PCM_RATE_16000 |\t\\\n\t\t\t       SNDRV_PCM_RATE_22050 |\t\\\n\t\t\t       SNDRV_PCM_RATE_32000 |\t\\\n\t\t\t       SNDRV_PCM_RATE_44100 |\t\\\n\t\t\t       SNDRV_PCM_RATE_48000 |\t\\\n\t\t\t       SNDRV_PCM_RATE_88200 |\t\\\n\t\t\t       SNDRV_PCM_RATE_96000)\n\n#define WM8903_CAPTURE_RATES (SNDRV_PCM_RATE_8000 |\\\n\t\t\t      SNDRV_PCM_RATE_11025 |\t\\\n\t\t\t      SNDRV_PCM_RATE_16000 |\t\\\n\t\t\t      SNDRV_PCM_RATE_22050 |\t\\\n\t\t\t      SNDRV_PCM_RATE_32000 |\t\\\n\t\t\t      SNDRV_PCM_RATE_44100 |\t\\\n\t\t\t      SNDRV_PCM_RATE_48000)\n\n#define WM8903_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8903_dai_ops = {\n\t.hw_params\t= wm8903_hw_params,\n\t.mute_stream\t= wm8903_mute,\n\t.set_fmt\t= wm8903_set_dai_fmt,\n\t.set_sysclk\t= wm8903_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8903_dai = {\n\t.name = \"wm8903-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8903_PLAYBACK_RATES,\n\t\t.formats = WM8903_FORMATS,\n\t},\n\t.capture = {\n\t\t .stream_name = \"Capture\",\n\t\t .channels_min = 2,\n\t\t .channels_max = 2,\n\t\t .rates = WM8903_CAPTURE_RATES,\n\t\t .formats = WM8903_FORMATS,\n\t },\n\t.ops = &wm8903_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8903_resume(struct snd_soc_component *component)\n{\n\tstruct wm8903_priv *wm8903 = snd_soc_component_get_drvdata(component);\n\n\tregcache_sync(wm8903->regmap);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic int wm8903_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tif (offset >= WM8903_NUM_GPIO)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int wm8903_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm8903_priv *wm8903 = gpiochip_get_data(chip);\n\tunsigned int mask, val;\n\tint ret;\n\n\tmask = WM8903_GP1_FN_MASK | WM8903_GP1_DIR_MASK;\n\tval = (WM8903_GPn_FN_GPIO_INPUT << WM8903_GP1_FN_SHIFT) |\n\t\tWM8903_GP1_DIR;\n\n\tret = regmap_update_bits(wm8903->regmap,\n\t\t\t\t WM8903_GPIO_CONTROL_1 + offset, mask, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wm8903_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm8903_priv *wm8903 = gpiochip_get_data(chip);\n\tunsigned int reg;\n\n\tregmap_read(wm8903->regmap, WM8903_GPIO_CONTROL_1 + offset, &reg);\n\n\treturn !!((reg & WM8903_GP1_LVL_MASK) >> WM8903_GP1_LVL_SHIFT);\n}\n\nstatic int wm8903_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct wm8903_priv *wm8903 = gpiochip_get_data(chip);\n\tunsigned int mask, val;\n\tint ret;\n\n\tmask = WM8903_GP1_FN_MASK | WM8903_GP1_DIR_MASK | WM8903_GP1_LVL_MASK;\n\tval = (WM8903_GPn_FN_GPIO_OUTPUT << WM8903_GP1_FN_SHIFT) |\n\t\t(value << WM8903_GP2_LVL_SHIFT);\n\n\tret = regmap_update_bits(wm8903->regmap,\n\t\t\t\t WM8903_GPIO_CONTROL_1 + offset, mask, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void wm8903_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct wm8903_priv *wm8903 = gpiochip_get_data(chip);\n\n\tregmap_update_bits(wm8903->regmap, WM8903_GPIO_CONTROL_1 + offset,\n\t\t\t   WM8903_GP1_LVL_MASK,\n\t\t\t   !!value << WM8903_GP1_LVL_SHIFT);\n}\n\nstatic const struct gpio_chip wm8903_template_chip = {\n\t.label\t\t\t= \"wm8903\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= wm8903_gpio_request,\n\t.direction_input\t= wm8903_gpio_direction_in,\n\t.get\t\t\t= wm8903_gpio_get,\n\t.direction_output\t= wm8903_gpio_direction_out,\n\t.set\t\t\t= wm8903_gpio_set,\n\t.can_sleep\t\t= 1,\n};\n\nstatic void wm8903_init_gpio(struct wm8903_priv *wm8903)\n{\n\tstruct wm8903_platform_data *pdata = wm8903->pdata;\n\tint ret;\n\n\twm8903->gpio_chip = wm8903_template_chip;\n\twm8903->gpio_chip.ngpio = WM8903_NUM_GPIO;\n\twm8903->gpio_chip.parent = wm8903->dev;\n\n\tif (pdata->gpio_base)\n\t\twm8903->gpio_chip.base = pdata->gpio_base;\n\telse\n\t\twm8903->gpio_chip.base = -1;\n\n\tret = gpiochip_add_data(&wm8903->gpio_chip, wm8903);\n\tif (ret != 0)\n\t\tdev_err(wm8903->dev, \"Failed to add GPIOs: %d\\n\", ret);\n}\n\nstatic void wm8903_free_gpio(struct wm8903_priv *wm8903)\n{\n\tgpiochip_remove(&wm8903->gpio_chip);\n}\n#else\nstatic void wm8903_init_gpio(struct wm8903_priv *wm8903)\n{\n}\n\nstatic void wm8903_free_gpio(struct wm8903_priv *wm8903)\n{\n}\n#endif\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8903 = {\n\t.resume\t\t\t= wm8903_resume,\n\t.set_bias_level\t\t= wm8903_set_bias_level,\n\t.seq_notifier\t\t= wm8903_seq_notifier,\n\t.controls\t\t= wm8903_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8903_snd_controls),\n\t.dapm_widgets\t\t= wm8903_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8903_dapm_widgets),\n\t.dapm_routes\t\t= wm8903_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8903_intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8903_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM8903_MAX_REGISTER,\n\t.volatile_reg = wm8903_volatile_register,\n\t.readable_reg = wm8903_readable_register,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8903_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8903_reg_defaults),\n};\n\nstatic int wm8903_set_pdata_irq_trigger(struct i2c_client *i2c,\n\t\t\t\t\tstruct wm8903_platform_data *pdata)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(i2c->irq);\n\tif (!irq_data) {\n\t\tdev_err(&i2c->dev, \"Invalid IRQ: %d\\n\",\n\t\t\ti2c->irq);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (irqd_get_trigger_type(irq_data)) {\n\tcase IRQ_TYPE_NONE:\n\tdefault:\n\t\t \n\t\tfallthrough;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpdata->irq_active_low = false;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpdata->irq_active_low = true;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8903_set_pdata_from_of(struct i2c_client *i2c,\n\t\t\t\t    struct wm8903_platform_data *pdata)\n{\n\tconst struct device_node *np = i2c->dev.of_node;\n\tu32 val32;\n\tint i;\n\n\tif (of_property_read_u32(np, \"micdet-cfg\", &val32) >= 0)\n\t\tpdata->micdet_cfg = val32;\n\n\tif (of_property_read_u32(np, \"micdet-delay\", &val32) >= 0)\n\t\tpdata->micdet_delay = val32;\n\n\tif (of_property_read_u32_array(np, \"gpio-cfg\", pdata->gpio_cfg,\n\t\t\t\t       ARRAY_SIZE(pdata->gpio_cfg)) >= 0) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pdata->gpio_cfg); i++) {\n\t\t\tif (pdata->gpio_cfg[i] == 0) {\n\t\t\t\tpdata->gpio_cfg[i] = WM8903_GPIO_CONFIG_ZERO;\n\t\t\t} else if (pdata->gpio_cfg[i] == 0xffffffff) {\n\t\t\t\tpdata->gpio_cfg[i] = 0;\n\t\t\t} else if (pdata->gpio_cfg[i] > 0x7fff) {\n\t\t\t\tdev_err(&i2c->dev, \"Invalid gpio-cfg[%d] %x\\n\",\n\t\t\t\t\ti, pdata->gpio_cfg[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8903_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8903_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct wm8903_priv *wm8903;\n\tint trigger;\n\tbool mic_gpio = false;\n\tunsigned int val, irq_pol;\n\tint ret, i;\n\n\twm8903 = devm_kzalloc(&i2c->dev, sizeof(*wm8903), GFP_KERNEL);\n\tif (wm8903 == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wm8903->lock);\n\twm8903->dev = &i2c->dev;\n\n\twm8903->regmap = devm_regmap_init_i2c(i2c, &wm8903_regmap);\n\tif (IS_ERR(wm8903->regmap)) {\n\t\tret = PTR_ERR(wm8903->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8903);\n\n\t \n\tif (pdata) {\n\t\twm8903->pdata = pdata;\n\t} else {\n\t\twm8903->pdata = devm_kzalloc(&i2c->dev, sizeof(*wm8903->pdata),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!wm8903->pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i2c->irq) {\n\t\t\tret = wm8903_set_pdata_irq_trigger(i2c, wm8903->pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (i2c->dev.of_node) {\n\t\t\tret = wm8903_set_pdata_from_of(i2c, wm8903->pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpdata = wm8903->pdata;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8903->supplies); i++)\n\t\twm8903->supplies[i].supply = wm8903_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8903->supplies),\n\t\t\t\t      wm8903->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8903->supplies),\n\t\t\t\t    wm8903->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm8903->regmap, WM8903_SW_RESET_AND_ID, &val);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tif (val != 0x8903) {\n\t\tdev_err(&i2c->dev, \"Device with ID %x is not a WM8903\\n\", val);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(wm8903->regmap, WM8903_REVISION_NUMBER, &val);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip revision: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tdev_info(&i2c->dev, \"WM8903 revision %c\\n\",\n\t\t (val & WM8903_CHIP_REV_MASK) + 'A');\n\n\t \n\tregmap_write(wm8903->regmap, WM8903_SW_RESET_AND_ID, 0x8903);\n\n\twm8903_init_gpio(wm8903);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pdata->gpio_cfg); i++) {\n\t\tif ((!pdata->gpio_cfg[i]) ||\n\t\t    (pdata->gpio_cfg[i] > WM8903_GPIO_CONFIG_ZERO))\n\t\t\tcontinue;\n\n\t\tregmap_write(wm8903->regmap, WM8903_GPIO_CONTROL_1 + i,\n\t\t\t\tpdata->gpio_cfg[i] & 0x7fff);\n\n\t\tval = (pdata->gpio_cfg[i] & WM8903_GP1_FN_MASK)\n\t\t\t>> WM8903_GP1_FN_SHIFT;\n\n\t\tswitch (val) {\n\t\tcase WM8903_GPn_FN_MICBIAS_CURRENT_DETECT:\n\t\tcase WM8903_GPn_FN_MICBIAS_SHORT_DETECT:\n\t\t\tmic_gpio = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tregmap_write(wm8903->regmap, WM8903_MIC_BIAS_CONTROL_0,\n\t\t     pdata->micdet_cfg);\n\n\t \n\tif (pdata->micdet_cfg)\n\t\tregmap_update_bits(wm8903->regmap, WM8903_WRITE_SEQUENCER_0,\n\t\t\t\t   WM8903_WSEQ_ENA, WM8903_WSEQ_ENA);\n\n\t \n\tWARN_ON(!mic_gpio && (pdata->micdet_cfg & WM8903_MICDET_ENA));\n\n\twm8903->mic_delay = pdata->micdet_delay;\n\n\tif (i2c->irq) {\n\t\tif (pdata->irq_active_low) {\n\t\t\ttrigger = IRQF_TRIGGER_LOW;\n\t\t\tirq_pol = WM8903_IRQ_POL;\n\t\t} else {\n\t\t\ttrigger = IRQF_TRIGGER_HIGH;\n\t\t\tirq_pol = 0;\n\t\t}\n\n\t\tregmap_update_bits(wm8903->regmap, WM8903_INTERRUPT_CONTROL,\n\t\t\t\t   WM8903_IRQ_POL, irq_pol);\n\n\t\tret = request_threaded_irq(i2c->irq, NULL, wm8903_irq,\n\t\t\t\t\t   trigger | IRQF_ONESHOT,\n\t\t\t\t\t   \"wm8903\", wm8903);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm8903->dev, \"Failed to request IRQ: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(wm8903->regmap,\n\t\t\t\t   WM8903_INTERRUPT_STATUS_1_MASK,\n\t\t\t\t   WM8903_IM_WSEQ_BUSY_EINT, 0);\n\t}\n\n\t \n\tregmap_update_bits(wm8903->regmap, WM8903_ADC_DIGITAL_VOLUME_LEFT,\n\t\t\t   WM8903_ADCVU, WM8903_ADCVU);\n\tregmap_update_bits(wm8903->regmap, WM8903_ADC_DIGITAL_VOLUME_RIGHT,\n\t\t\t   WM8903_ADCVU, WM8903_ADCVU);\n\n\tregmap_update_bits(wm8903->regmap, WM8903_DAC_DIGITAL_VOLUME_LEFT,\n\t\t\t   WM8903_DACVU, WM8903_DACVU);\n\tregmap_update_bits(wm8903->regmap, WM8903_DAC_DIGITAL_VOLUME_RIGHT,\n\t\t\t   WM8903_DACVU, WM8903_DACVU);\n\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT1_LEFT,\n\t\t\t   WM8903_HPOUTVU, WM8903_HPOUTVU);\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT1_RIGHT,\n\t\t\t   WM8903_HPOUTVU, WM8903_HPOUTVU);\n\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT2_LEFT,\n\t\t\t   WM8903_LINEOUTVU, WM8903_LINEOUTVU);\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT2_RIGHT,\n\t\t\t   WM8903_LINEOUTVU, WM8903_LINEOUTVU);\n\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT3_LEFT,\n\t\t\t   WM8903_SPKVU, WM8903_SPKVU);\n\tregmap_update_bits(wm8903->regmap, WM8903_ANALOGUE_OUT3_RIGHT,\n\t\t\t   WM8903_SPKVU, WM8903_SPKVU);\n\n\t \n\tregmap_update_bits(wm8903->regmap, WM8903_DAC_DIGITAL_1,\n\t\t\t   WM8903_DAC_MUTEMODE | WM8903_DAC_MUTE,\n\t\t\t   WM8903_DAC_MUTEMODE | WM8903_DAC_MUTE);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8903, &wm8903_dai, 1);\n\tif (ret != 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8903->supplies),\n\t\t\t       wm8903->supplies);\n\treturn ret;\n}\n\nstatic void wm8903_i2c_remove(struct i2c_client *client)\n{\n\tstruct wm8903_priv *wm8903 = i2c_get_clientdata(client);\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8903->supplies),\n\t\t\t       wm8903->supplies);\n\tif (client->irq)\n\t\tfree_irq(client->irq, wm8903);\n\twm8903_free_gpio(wm8903);\n}\n\nstatic const struct of_device_id wm8903_of_match[] = {\n\t{ .compatible = \"wlf,wm8903\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, wm8903_of_match);\n\nstatic const struct i2c_device_id wm8903_i2c_id[] = {\n\t{ \"wm8903\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8903_i2c_id);\n\nstatic struct i2c_driver wm8903_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8903\",\n\t\t.of_match_table = wm8903_of_match,\n\t},\n\t.probe =    wm8903_i2c_probe,\n\t.remove =   wm8903_i2c_remove,\n\t.id_table = wm8903_i2c_id,\n};\n\nmodule_i2c_driver(wm8903_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8903 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.cm>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}