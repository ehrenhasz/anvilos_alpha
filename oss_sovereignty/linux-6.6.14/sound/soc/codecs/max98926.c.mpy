{
  "module_name": "max98926.c",
  "hash_id": "8f61f1b5d6dd93cec4c8e48710f0112959d20610f2c06700b702f63cd7b8cc24",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98926.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"max98926.h\"\n\nstatic const char * const max98926_boost_voltage_txt[] = {\n\t\"8.5V\", \"8.25V\", \"8.0V\", \"7.75V\", \"7.5V\", \"7.25V\", \"7.0V\", \"6.75V\",\n\t\"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\"\n};\n\nstatic const char *const max98926_pdm_ch_text[] = {\n\t\"Current\", \"Voltage\",\n};\n\nstatic const char *const max98926_hpf_cutoff_txt[] = {\n\t\"Disable\", \"DC Block\", \"100Hz\",\n\t\"200Hz\", \"400Hz\", \"800Hz\",\n};\n\nstatic const struct reg_default max98926_reg[] = {\n\t{ 0x0B, 0x00 },  \n\t{ 0x0C, 0x00 },  \n\t{ 0x0D, 0x00 },  \n\t{ 0x0E, 0x00 },  \n\t{ 0x0F, 0x00 },  \n\t{ 0x10, 0x00 },  \n\t{ 0x11, 0xC0 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0xF0 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0xAB },  \n\t{ 0x17, 0x89 },  \n\t{ 0x18, 0x00 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1A, 0x04 },  \n\t{ 0x1B, 0x00 },  \n\t{ 0x1C, 0x00 },  \n\t{ 0x1D, 0x00 },  \n\t{ 0x1E, 0xF0 },  \n\t{ 0x1F, 0x00 },  \n\t{ 0x20, 0x50 },  \n\t{ 0x21, 0x00 },  \n\t{ 0x22, 0x00 },  \n\t{ 0x23, 0x00 },  \n\t{ 0x24, 0x00 },  \n\t{ 0x25, 0x00 },  \n\t{ 0x26, 0x00 },  \n\t{ 0x27, 0xFF },  \n\t{ 0x28, 0xFF },  \n\t{ 0x29, 0xFF },  \n\t{ 0x2A, 0xFF },  \n\t{ 0x2B, 0x02 },  \n\t{ 0x2C, 0x90 },  \n\t{ 0x2D, 0x00 },  \n\t{ 0x2E, 0x02 },  \n\t{ 0x2F, 0x00 },  \n\t{ 0x30, 0x0A },  \n\t{ 0x31, 0x00 },  \n\t{ 0x32, 0x80 },  \n\t{ 0x33, 0x00 },  \n\t{ 0x34, 0x92 },  \n\t{ 0x35, 0x01 },  \n\t{ 0x36, 0x00 },  \n\t{ 0x37, 0x00 },  \n\t{ 0x38, 0x00 },  \n\t{ 0x3A, 0x00 },  \n};\n\nstatic const struct soc_enum max98926_voltage_enum[] = {\n\tSOC_ENUM_SINGLE(MAX98926_DAI_CLK_DIV_N_LSBS, 0,\n\t\tARRAY_SIZE(max98926_pdm_ch_text),\n\t\tmax98926_pdm_ch_text),\n};\n\nstatic const struct snd_kcontrol_new max98926_voltage_control =\n\tSOC_DAPM_ENUM(\"Route\", max98926_voltage_enum);\n\nstatic const struct soc_enum max98926_current_enum[] = {\n\tSOC_ENUM_SINGLE(MAX98926_DAI_CLK_DIV_N_LSBS,\n\t\tMAX98926_PDM_SOURCE_1_SHIFT,\n\t\tARRAY_SIZE(max98926_pdm_ch_text),\n\t\tmax98926_pdm_ch_text),\n};\n\nstatic const struct snd_kcontrol_new max98926_current_control =\n\tSOC_DAPM_ENUM(\"Route\", max98926_current_enum);\n\nstatic const struct snd_kcontrol_new max98926_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PCM Single Switch\", MAX98926_SPK_AMP,\n\t\tMAX98926_INSELECT_MODE_SHIFT, 0, 0),\n\tSOC_DAPM_SINGLE(\"PDM Single Switch\", MAX98926_SPK_AMP,\n\t\tMAX98926_INSELECT_MODE_SHIFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new max98926_dai_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left\", MAX98926_GAIN,\n\t\tMAX98926_DAC_IN_SEL_SHIFT, 0, 0),\n\tSOC_DAPM_SINGLE(\"Right\", MAX98926_GAIN,\n\t\tMAX98926_DAC_IN_SEL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LeftRight\", MAX98926_GAIN,\n\t\tMAX98926_DAC_IN_SEL_SHIFT, 2, 0),\n\tSOC_DAPM_SINGLE(\"(Left+Right)/2 Switch\", MAX98926_GAIN,\n\t\tMAX98926_DAC_IN_SEL_SHIFT, 3, 0),\n};\n\nstatic const struct snd_soc_dapm_widget max98926_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"DAI_OUT\", \"HiFi Playback\", 0,\n\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"Amp Enable\", NULL, MAX98926_BLOCK_ENABLE,\n\t\tMAX98926_SPK_EN_SHIFT, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Global Enable\", MAX98926_GLOBAL_ENABLE,\n\t\tMAX98926_EN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VI Enable\", MAX98926_BLOCK_ENABLE,\n\t\tMAX98926_ADC_IMON_EN_WIDTH |\n\t\tMAX98926_ADC_VMON_EN_SHIFT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"BST Enable\", MAX98926_BLOCK_ENABLE,\n\t\tMAX98926_BST_EN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n\tSND_SOC_DAPM_MIXER(\"PCM Sel\", MAX98926_SPK_AMP,\n\t\tMAX98926_INSELECT_MODE_SHIFT, 0,\n\t\t&max98926_mixer_controls[0],\n\t\tARRAY_SIZE(max98926_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"DAI Sel\",\n\t\tMAX98926_GAIN, MAX98926_DAC_IN_SEL_SHIFT, 0,\n\t\t&max98926_dai_controls[0],\n\t\tARRAY_SIZE(max98926_dai_controls)),\n\tSND_SOC_DAPM_MUX(\"PDM CH1 Source\",\n\t\tMAX98926_DAI_CLK_DIV_N_LSBS,\n\t\tMAX98926_PDM_CURRENT_SHIFT,\n\t\t0, &max98926_current_control),\n\tSND_SOC_DAPM_MUX(\"PDM CH0 Source\",\n\t\tMAX98926_DAI_CLK_DIV_N_LSBS,\n\t\tMAX98926_PDM_VOLTAGE_SHIFT,\n\t\t0, &max98926_voltage_control),\n};\n\nstatic const struct snd_soc_dapm_route max98926_audio_map[] = {\n\t{\"VI Enable\", NULL, \"DAI_OUT\"},\n\t{\"DAI Sel\", \"Left\", \"VI Enable\"},\n\t{\"DAI Sel\", \"Right\", \"VI Enable\"},\n\t{\"DAI Sel\", \"LeftRight\", \"VI Enable\"},\n\t{\"DAI Sel\", \"LeftRightDiv2\", \"VI Enable\"},\n\t{\"PCM Sel\", \"PCM\", \"DAI Sel\"},\n\n\t{\"PDM CH1 Source\", \"Current\", \"DAI_OUT\"},\n\t{\"PDM CH1 Source\", \"Voltage\", \"DAI_OUT\"},\n\t{\"PDM CH0 Source\", \"Current\", \"DAI_OUT\"},\n\t{\"PDM CH0 Source\", \"Voltage\", \"DAI_OUT\"},\n\t{\"PCM Sel\", \"Analog\", \"PDM CH1 Source\"},\n\t{\"PCM Sel\", \"Analog\", \"PDM CH0 Source\"},\n\t{\"Amp Enable\", NULL, \"PCM Sel\"},\n\n\t{\"BST Enable\", NULL, \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"BST Enable\"},\n};\n\nstatic bool max98926_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98926_VBAT_DATA:\n\tcase MAX98926_VBST_DATA:\n\tcase MAX98926_LIVE_STATUS0:\n\tcase MAX98926_LIVE_STATUS1:\n\tcase MAX98926_LIVE_STATUS2:\n\tcase MAX98926_STATE0:\n\tcase MAX98926_STATE1:\n\tcase MAX98926_STATE2:\n\tcase MAX98926_FLAG0:\n\tcase MAX98926_FLAG1:\n\tcase MAX98926_FLAG2:\n\tcase MAX98926_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98926_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98926_IRQ_CLEAR0:\n\tcase MAX98926_IRQ_CLEAR1:\n\tcase MAX98926_IRQ_CLEAR2:\n\tcase MAX98926_ALC_HOLD_RLS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n};\n\nstatic DECLARE_TLV_DB_SCALE(max98926_spk_tlv, -600, 100, 0);\nstatic DECLARE_TLV_DB_RANGE(max98926_current_tlv,\n\t0, 11, TLV_DB_SCALE_ITEM(20, 20, 0),\n\t12, 15, TLV_DB_SCALE_ITEM(320, 40, 0),\n);\n\nstatic SOC_ENUM_SINGLE_DECL(max98926_dac_hpf_cutoff,\n\t\tMAX98926_FILTERS, MAX98926_DAC_HPF_SHIFT,\n\t\tmax98926_hpf_cutoff_txt);\n\nstatic SOC_ENUM_SINGLE_DECL(max98926_boost_voltage,\n\t\tMAX98926_CONFIGURATION, MAX98926_BST_VOUT_SHIFT,\n\t\tmax98926_boost_voltage_txt);\n\nstatic const struct snd_kcontrol_new max98926_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98926_GAIN,\n\t\tMAX98926_SPK_GAIN_SHIFT,\n\t\t(1<<MAX98926_SPK_GAIN_WIDTH)-1, 0,\n\t\tmax98926_spk_tlv),\n\tSOC_SINGLE(\"Ramp Switch\", MAX98926_GAIN_RAMPING,\n\t\tMAX98926_SPK_RMP_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ZCD Switch\", MAX98926_GAIN_RAMPING,\n\t\tMAX98926_SPK_ZCD_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Switch\", MAX98926_THRESHOLD,\n\t\tMAX98926_ALC_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Threshold\", MAX98926_THRESHOLD,\n\t\tMAX98926_ALC_TH_SHIFT,\n\t\t(1<<MAX98926_ALC_TH_WIDTH)-1, 0),\n\tSOC_ENUM(\"Boost Output Voltage\", max98926_boost_voltage),\n\tSOC_SINGLE_TLV(\"Boost Current Limit\", MAX98926_BOOST_LIMITER,\n\t\tMAX98926_BST_ILIM_SHIFT,\n\t\t(1<<MAX98926_BST_ILIM_SHIFT)-1, 0,\n\t\tmax98926_current_tlv),\n\tSOC_ENUM(\"DAC HPF Cutoff\", max98926_dac_hpf_cutoff),\n\tSOC_DOUBLE(\"PDM Channel One\", MAX98926_DAI_CLK_DIV_N_LSBS,\n\t\tMAX98926_PDM_CHANNEL_1_SHIFT,\n\t\tMAX98926_PDM_CHANNEL_1_HIZ, 1, 0),\n\tSOC_DOUBLE(\"PDM Channel Zero\", MAX98926_DAI_CLK_DIV_N_LSBS,\n\t\tMAX98926_PDM_CHANNEL_0_SHIFT,\n\t\tMAX98926_PDM_CHANNEL_0_HIZ, 1, 0),\n};\n\nstatic const struct {\n\tint rate;\n\tint  sr;\n} rate_table[] = {\n\t{\n\t\t.rate = 8000,\n\t\t.sr = 0,\n\t},\n\t{\n\t\t.rate = 11025,\n\t\t.sr = 1,\n\t},\n\t{\n\t\t.rate = 12000,\n\t\t.sr = 2,\n\t},\n\t{\n\t\t.rate = 16000,\n\t\t.sr = 3,\n\t},\n\t{\n\t\t.rate = 22050,\n\t\t.sr = 4,\n\t},\n\t{\n\t\t.rate = 24000,\n\t\t.sr = 5,\n\t},\n\t{\n\t\t.rate = 32000,\n\t\t.sr = 6,\n\t},\n\t{\n\t\t.rate = 44100,\n\t\t.sr = 7,\n\t},\n\t{\n\t\t.rate = 48000,\n\t\t.sr = 8,\n\t},\n};\n\nstatic void max98926_set_sense_data(struct max98926_priv *max98926)\n{\n\tregmap_update_bits(max98926->regmap,\n\t\tMAX98926_DOUT_CFG_VMON,\n\t\tMAX98926_DAI_VMON_EN_MASK,\n\t\tMAX98926_DAI_VMON_EN_MASK);\n\tregmap_update_bits(max98926->regmap,\n\t\tMAX98926_DOUT_CFG_IMON,\n\t\tMAX98926_DAI_IMON_EN_MASK,\n\t\tMAX98926_DAI_IMON_EN_MASK);\n\n\tif (!max98926->interleave_mode) {\n\t\t \n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DOUT_CFG_VMON,\n\t\t\tMAX98926_DAI_VMON_SLOT_MASK,\n\t\t\tmax98926->v_slot);\n\t\t \n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DOUT_CFG_IMON,\n\t\t\tMAX98926_DAI_IMON_SLOT_MASK,\n\t\t\tmax98926->i_slot);\n\t} else {\n\t\t \n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_FORMAT,\n\t\t\tMAX98926_DAI_INTERLEAVE_MASK,\n\t\t\tMAX98926_DAI_INTERLEAVE_MASK);\n\t\t \n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DOUT_CFG_VBAT,\n\t\t\tMAX98926_DAI_INTERLEAVE_SLOT_MASK,\n\t\t\tmax98926->v_slot);\n\t}\n}\n\nstatic int max98926_dai_set_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98926_priv *max98926 = snd_soc_component_get_drvdata(component);\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmax98926_set_sense_data(max98926);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI clock mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert = MAX98926_DAI_WCI_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98926_DAI_BCI_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tinvert = MAX98926_DAI_BCI_MASK | MAX98926_DAI_WCI_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(max98926->regmap,\n\t\t\tMAX98926_FORMAT, MAX98926_DAI_DLY_MASK);\n\tregmap_update_bits(max98926->regmap, MAX98926_FORMAT,\n\t\t\tMAX98926_DAI_BCI_MASK, invert);\n\treturn 0;\n}\n\nstatic int max98926_dai_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tint dai_sr = -EINVAL;\n\tint rate = params_rate(params), i;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98926_priv *max98926 = snd_soc_component_get_drvdata(component);\n\tint blr_clk_ratio;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_FORMAT,\n\t\t\tMAX98926_DAI_CHANSZ_MASK,\n\t\t\tMAX98926_DAI_CHANSZ_16);\n\t\tmax98926->ch_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_FORMAT,\n\t\t\tMAX98926_DAI_CHANSZ_MASK,\n\t\t\tMAX98926_DAI_CHANSZ_24);\n\t\tmax98926->ch_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_FORMAT,\n\t\t\tMAX98926_DAI_CHANSZ_MASK,\n\t\t\tMAX98926_DAI_CHANSZ_32);\n\t\tmax98926->ch_size = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tblr_clk_ratio = params_channels(params) * max98926->ch_size;\n\n\tswitch (blr_clk_ratio) {\n\tcase 32:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DAI_CLK_MODE2,\n\t\t\tMAX98926_DAI_BSEL_MASK,\n\t\t\tMAX98926_DAI_BSEL_32);\n\t\tbreak;\n\tcase 48:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DAI_CLK_MODE2,\n\t\t\tMAX98926_DAI_BSEL_MASK,\n\t\t\tMAX98926_DAI_BSEL_48);\n\t\tbreak;\n\tcase 64:\n\t\tregmap_update_bits(max98926->regmap,\n\t\t\tMAX98926_DAI_CLK_MODE2,\n\t\t\tMAX98926_DAI_BSEL_MASK,\n\t\t\tMAX98926_DAI_BSEL_64);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n\t\tif (rate_table[i].rate >= rate) {\n\t\t\tdai_sr = rate_table[i].sr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dai_sr < 0)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(max98926->regmap,\n\t\tMAX98926_DAI_CLK_MODE2,\n\t\tMAX98926_DAI_SR_MASK, dai_sr << MAX98926_DAI_SR_SHIFT);\n\treturn 0;\n}\n\n#define MAX98926_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops max98926_dai_ops = {\n\t.set_fmt = max98926_dai_set_fmt,\n\t.hw_params = max98926_dai_hw_params,\n};\n\nstatic struct snd_soc_dai_driver max98926_dai[] = {\n{\n\t.name = \"max98926-aif1\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = MAX98926_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = MAX98926_FORMATS,\n\t},\n\t.ops = &max98926_dai_ops,\n}\n};\n\nstatic int max98926_probe(struct snd_soc_component *component)\n{\n\tstruct max98926_priv *max98926 = snd_soc_component_get_drvdata(component);\n\n\tmax98926->component = component;\n\n\t \n\tregmap_write(max98926->regmap, MAX98926_DOUT_HIZ_CFG4, 0xF0);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98926 = {\n\t.probe\t\t\t= max98926_probe,\n\t.controls\t\t= max98926_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98926_snd_controls),\n\t.dapm_routes\t\t= max98926_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98926_audio_map),\n\t.dapm_widgets\t\t= max98926_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98926_dapm_widgets),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98926_regmap = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= MAX98926_VERSION,\n\t.reg_defaults\t= max98926_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98926_reg),\n\t.volatile_reg\t= max98926_volatile_register,\n\t.readable_reg\t= max98926_readable_register,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic int max98926_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret, reg;\n\tu32 value;\n\tstruct max98926_priv *max98926;\n\n\tmax98926 = devm_kzalloc(&i2c->dev,\n\t\t\tsizeof(*max98926), GFP_KERNEL);\n\tif (!max98926)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max98926);\n\tmax98926->regmap = devm_regmap_init_i2c(i2c, &max98926_regmap);\n\tif (IS_ERR(max98926->regmap)) {\n\t\tret = PTR_ERR(max98926->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\tgoto err_out;\n\t}\n\tif (of_property_read_bool(i2c->dev.of_node, \"maxim,interleave-mode\") ||\n\t    of_property_read_bool(i2c->dev.of_node, \"interleave-mode\"))\n\t\tmax98926->interleave_mode = true;\n\n\tif (!of_property_read_u32(i2c->dev.of_node, \"vmon-slot-no\", &value)) {\n\t\tif (value > MAX98926_DAI_VMON_SLOT_1E_1F) {\n\t\t\tdev_err(&i2c->dev, \"vmon slot number is wrong:\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax98926->v_slot = value;\n\t}\n\tif (!of_property_read_u32(i2c->dev.of_node, \"imon-slot-no\", &value)) {\n\t\tif (value > MAX98926_DAI_IMON_SLOT_1E_1F) {\n\t\t\tdev_err(&i2c->dev, \"imon slot number is wrong:\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax98926->i_slot = value;\n\t}\n\tret = regmap_read(max98926->regmap,\n\t\t\tMAX98926_VERSION, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read: %x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_max98926,\n\t\t\tmax98926_dai, ARRAY_SIZE(max98926_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to register component: %d\\n\", ret);\n\tdev_info(&i2c->dev, \"device version: %x\\n\", reg);\nerr_out:\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98926_i2c_id[] = {\n\t{ \"max98926\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max98926_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98926_of_match[] = {\n\t{ .compatible = \"maxim,max98926\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98926_of_match);\n#endif\n\nstatic struct i2c_driver max98926_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98926\",\n\t\t.of_match_table = of_match_ptr(max98926_of_match),\n\t},\n\t.probe = max98926_i2c_probe,\n\t.id_table = max98926_i2c_id,\n};\n\nmodule_i2c_driver(max98926_i2c_driver)\nMODULE_DESCRIPTION(\"ALSA SoC MAX98926 driver\");\nMODULE_AUTHOR(\"Anish kumar <anish.kumar@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}