{
  "module_name": "max9850.c",
  "hash_id": "857ff21a682082f65ff484165fd6ba17428f798f4fda82d901cf28008bbc02dc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max9850.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"max9850.h\"\n\nstruct max9850_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n};\n\n \nstatic bool max9850_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX9850_STATUSA:\n\tcase MAX9850_STATUSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max9850_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = MAX9850_DIGITAL_AUDIO,\n\t.volatile_reg = max9850_volatile_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const DECLARE_TLV_DB_RANGE(max9850_tlv,\n\t0x18, 0x1f, TLV_DB_SCALE_ITEM(-7450, 400, 0),\n\t0x20, 0x33, TLV_DB_SCALE_ITEM(-4150, 200, 0),\n\t0x34, 0x37, TLV_DB_SCALE_ITEM(-150, 100, 0),\n\t0x38, 0x3f, TLV_DB_SCALE_ITEM(250, 50, 0)\n);\n\nstatic const struct snd_kcontrol_new max9850_controls[] = {\nSOC_SINGLE_TLV(\"Headphone Volume\", MAX9850_VOLUME, 0, 0x3f, 1, max9850_tlv),\nSOC_SINGLE(\"Headphone Switch\", MAX9850_VOLUME, 7, 1, 1),\nSOC_SINGLE(\"Mono Switch\", MAX9850_GENERAL_PURPOSE, 2, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new max9850_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line In Switch\", MAX9850_ENABLE, 1, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget max9850_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"Charge Pump 1\", MAX9850_ENABLE, 4, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"Charge Pump 2\", MAX9850_ENABLE, 5, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"MCLK\", MAX9850_ENABLE, 6, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"SHDN\", MAX9850_ENABLE, 7, 0, NULL, 0),\nSND_SOC_DAPM_MIXER_NAMED_CTL(\"Output Mixer\", MAX9850_ENABLE, 2, 0,\n\t\t&max9850_mixer_controls[0],\n\t\tARRAY_SIZE(max9850_mixer_controls)),\nSND_SOC_DAPM_PGA(\"Headphone Output\", MAX9850_ENABLE, 3, 0, NULL, 0),\nSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", MAX9850_ENABLE, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"OUTL\"),\nSND_SOC_DAPM_OUTPUT(\"HPL\"),\nSND_SOC_DAPM_OUTPUT(\"OUTR\"),\nSND_SOC_DAPM_OUTPUT(\"HPR\"),\nSND_SOC_DAPM_MIXER(\"Line Input\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_INPUT(\"INL\"),\nSND_SOC_DAPM_INPUT(\"INR\"),\n};\n\nstatic const struct snd_soc_dapm_route max9850_dapm_routes[] = {\n\t \n\t{\"Output Mixer\", NULL, \"DAC\"},\n\t{\"Output Mixer\", \"Line In Switch\", \"Line Input\"},\n\n\t \n\t{\"Headphone Output\", NULL, \"Output Mixer\"},\n\t{\"HPL\", NULL, \"Headphone Output\"},\n\t{\"HPR\", NULL, \"Headphone Output\"},\n\t{\"OUTL\", NULL, \"Output Mixer\"},\n\t{\"OUTR\", NULL, \"Output Mixer\"},\n\n\t \n\t{\"Line Input\", NULL, \"INL\"},\n\t{\"Line Input\", NULL, \"INR\"},\n\n\t \n\t{\"Output Mixer\", NULL, \"Charge Pump 1\"},\n\t{\"Output Mixer\", NULL, \"Charge Pump 2\"},\n\t{\"Output Mixer\", NULL, \"SHDN\"},\n\t{\"DAC\", NULL, \"MCLK\"},\n};\n\nstatic int max9850_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max9850_priv *max9850 = snd_soc_component_get_drvdata(component);\n\tu64 lrclk_div;\n\tu8 sf, da;\n\n\tif (!max9850->sysclk)\n\t\treturn -EINVAL;\n\n\t \n\tsf = (snd_soc_component_read(component, MAX9850_CLOCK) >> 2) + 1;\n\tlrclk_div = (1 << 22);\n\tlrclk_div *= params_rate(params);\n\tlrclk_div *= sf;\n\tdo_div(lrclk_div, max9850->sysclk);\n\n\tsnd_soc_component_write(component, MAX9850_LRCLK_MSB, (lrclk_div >> 8) & 0x7f);\n\tsnd_soc_component_write(component, MAX9850_LRCLK_LSB, lrclk_div & 0xff);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tda = 0;\n\t\tbreak;\n\tcase 20:\n\t\tda = 0x2;\n\t\tbreak;\n\tcase 24:\n\t\tda = 0x3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, MAX9850_DIGITAL_AUDIO, 0x3, da);\n\n\treturn 0;\n}\n\nstatic int max9850_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max9850_priv *max9850 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (freq <= 13000000)\n\t\tsnd_soc_component_write(component, MAX9850_CLOCK, 0x0);\n\telse if (freq <= 26000000)\n\t\tsnd_soc_component_write(component, MAX9850_CLOCK, 0x4);\n\telse if (freq <= 40000000)\n\t\tsnd_soc_component_write(component, MAX9850_CLOCK, 0x8);\n\telse\n\t\treturn -EINVAL;\n\n\tmax9850->sysclk = freq;\n\treturn 0;\n}\n\nstatic int max9850_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 da = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tda |= MAX9850_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tda |= MAX9850_DLY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tda |= MAX9850_RTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tda |= MAX9850_BCINV | MAX9850_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tda |= MAX9850_BCINV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tda |= MAX9850_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_write(component, MAX9850_DIGITAL_AUDIO, da);\n\n\treturn 0;\n}\n\nstatic int max9850_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct max9850_priv *max9850 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regcache_sync(max9850->regmap);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define MAX9850_RATES SNDRV_PCM_RATE_8000_48000\n\n#define MAX9850_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops max9850_dai_ops = {\n\t.hw_params\t= max9850_hw_params,\n\t.set_sysclk\t= max9850_set_dai_sysclk,\n\t.set_fmt\t= max9850_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver max9850_dai = {\n\t.name = \"max9850-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MAX9850_RATES,\n\t\t.formats = MAX9850_FORMATS\n\t},\n\t.ops = &max9850_dai_ops,\n};\n\nstatic int max9850_probe(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_update_bits(component, MAX9850_GENERAL_PURPOSE, 1, 1);\n\t \n\tsnd_soc_component_update_bits(component, MAX9850_VOLUME, 0x40, 0x40);\n\t \n\tsnd_soc_component_update_bits(component, MAX9850_CHARGE_PUMP, 0xff, 0xc0);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max9850 = {\n\t.probe\t\t\t= max9850_probe,\n\t.set_bias_level\t\t= max9850_set_bias_level,\n\t.controls\t\t= max9850_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max9850_controls),\n\t.dapm_widgets\t\t= max9850_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max9850_dapm_widgets),\n\t.dapm_routes\t\t= max9850_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(max9850_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int max9850_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max9850_priv *max9850;\n\tint ret;\n\n\tmax9850 = devm_kzalloc(&i2c->dev, sizeof(struct max9850_priv),\n\t\t\t       GFP_KERNEL);\n\tif (max9850 == NULL)\n\t\treturn -ENOMEM;\n\n\tmax9850->regmap = devm_regmap_init_i2c(i2c, &max9850_regmap);\n\tif (IS_ERR(max9850->regmap))\n\t\treturn PTR_ERR(max9850->regmap);\n\n\ti2c_set_clientdata(i2c, max9850);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_max9850, &max9850_dai, 1);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max9850_i2c_id[] = {\n\t{ \"max9850\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max9850_i2c_id);\n\nstatic struct i2c_driver max9850_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max9850\",\n\t},\n\t.probe = max9850_i2c_probe,\n\t.id_table = max9850_i2c_id,\n};\n\nmodule_i2c_driver(max9850_i2c_driver);\n\nMODULE_AUTHOR(\"Christian Glindkamp <christian.glindkamp@taskit.de>\");\nMODULE_DESCRIPTION(\"ASoC MAX9850 codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}