{
  "module_name": "rl6347a.c",
  "hash_id": "0faec5d1353b874f294cbfb6bd8b098d5f9ba8f91524a5653180f4d60c0473f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rl6347a.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n\n#include \"rl6347a.h\"\n\nint rl6347a_hw_write(void *context, unsigned int reg, unsigned int value)\n{\n\tstruct i2c_client *client = context;\n\tstruct rl6347a_priv *rl6347a = i2c_get_clientdata(client);\n\tu8 data[4];\n\tint ret, i;\n\n\t \n\tif (reg <= 0xff) {\n\t\trl6347a_hw_write(client, RL6347A_COEF_INDEX, reg);\n\t\tfor (i = 0; i < rl6347a->index_cache_size; i++) {\n\t\t\tif (reg == rl6347a->index_cache[i].reg) {\n\t\t\t\trl6347a->index_cache[i].def = value;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\treg = RL6347A_PROC_COEF;\n\t}\n\n\tdata[0] = (reg >> 24) & 0xff;\n\tdata[1] = (reg >> 16) & 0xff;\n\t \n\tdata[2] = ((reg >> 8) & 0xff) | ((value >> 8) & 0xff);\n\tdata[3] = value & 0xff;\n\n\tret = i2c_master_send(client, data, 4);\n\n\tif (ret == 4)\n\t\treturn 0;\n\telse\n\t\tdev_err(&client->dev, \"I2C error %d\\n\", ret);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\nEXPORT_SYMBOL_GPL(rl6347a_hw_write);\n\nint rl6347a_hw_read(void *context, unsigned int reg, unsigned int *value)\n{\n\tstruct i2c_client *client = context;\n\tstruct i2c_msg xfer[2];\n\tint ret;\n\t__be32 be_reg, buf = 0x0;\n\tunsigned int index, vid;\n\n\t \n\tif (reg <= 0xff) {\n\t\trl6347a_hw_write(client, RL6347A_COEF_INDEX, reg);\n\t\treg = RL6347A_PROC_COEF;\n\t}\n\n\treg = reg | 0x80000;\n\tvid = (reg >> 8) & 0xfff;\n\n\tif (AC_VERB_GET_AMP_GAIN_MUTE == (vid & 0xf00)) {\n\t\tindex = (reg >> 8) & 0xf;\n\t\treg = (reg & ~0xf0f) | index;\n\t}\n\tbe_reg = cpu_to_be32(reg);\n\n\t \n\txfer[0].addr = client->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = 4;\n\txfer[0].buf = (u8 *)&be_reg;\n\n\t \n\txfer[1].addr = client->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = 4;\n\txfer[1].buf = (u8 *)&buf;\n\n\tret = i2c_transfer(client->adapter, xfer, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 2)\n\t\treturn -EIO;\n\n\t*value = be32_to_cpu(buf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rl6347a_hw_read);\n\nMODULE_DESCRIPTION(\"RL6347A class device shared support\");\nMODULE_AUTHOR(\"Oder Chiou <oder_chiou@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}