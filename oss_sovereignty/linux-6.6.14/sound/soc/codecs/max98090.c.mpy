{
  "module_name": "max98090.c",
  "hash_id": "4945d8a0d4ee9fd200fd92c60fdbe110fb011a9c393b84a011895752e332b5e0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98090.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/max98090.h>\n#include \"max98090.h\"\n\n \nstatic const struct reg_default max98090_reg[] = {\n\t{ 0x00, 0x00 },  \n\t{ 0x03, 0x04 },  \n\t{ 0x04, 0x00 },  \n\t{ 0x05, 0x00 },  \n\t{ 0x06, 0x00 },  \n\t{ 0x07, 0x00 },  \n\t{ 0x08, 0x00 },  \n\t{ 0x09, 0x00 },  \n\t{ 0x0A, 0x00 },  \n\t{ 0x0B, 0x00 },  \n\t{ 0x0C, 0x00 },  \n\t{ 0x0D, 0x00 },  \n\t{ 0x0E, 0x1B },  \n\t{ 0x0F, 0x00 },  \n\n\t{ 0x10, 0x14 },  \n\t{ 0x11, 0x14 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0x00 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0x00 },  \n\t{ 0x17, 0x03 },  \n\t{ 0x18, 0x03 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1A, 0x00 },  \n\t{ 0x1B, 0x00 },  \n\t{ 0x1C, 0x00 },  \n\t{ 0x1D, 0x00 },  \n\t{ 0x1E, 0x00 },  \n\t{ 0x1F, 0x00 },  \n\n\t{ 0x20, 0x00 },  \n\t{ 0x21, 0x00 },  \n\t{ 0x22, 0x00 },  \n\t{ 0x23, 0x00 },  \n\t{ 0x24, 0x00 },  \n\t{ 0x25, 0x00 },  \n\t{ 0x26, 0x80 },  \n\t{ 0x27, 0x00 },  \n\t{ 0x28, 0x00 },  \n\t{ 0x29, 0x00 },  \n\t{ 0x2A, 0x00 },  \n\t{ 0x2B, 0x00 },  \n\t{ 0x2C, 0x1A },  \n\t{ 0x2D, 0x1A },  \n\t{ 0x2E, 0x00 },  \n\t{ 0x2F, 0x00 },  \n\n\t{ 0x30, 0x00 },  \n\t{ 0x31, 0x2C },  \n\t{ 0x32, 0x2C },  \n\t{ 0x33, 0x00 },  \n\t{ 0x34, 0x00 },  \n\t{ 0x35, 0x00 },  \n\t{ 0x36, 0x00 },  \n\t{ 0x37, 0x00 },  \n\t{ 0x38, 0x00 },  \n\t{ 0x39, 0x15 },  \n\t{ 0x3A, 0x00 },  \n\t{ 0x3B, 0x00 },  \n\t{ 0x3C, 0x15 },  \n\t{ 0x3D, 0x00 },  \n\t{ 0x3E, 0x00 },  \n\t{ 0x3F, 0x00 },  \n\n\t{ 0x40, 0x00 },  \n\t{ 0x41, 0x00 },  \n\t{ 0x42, 0x00 },  \n\t{ 0x43, 0x00 },  \n\t{ 0x44, 0x06 },  \n\t{ 0x45, 0x00 },  \n\t{ 0x46, 0x00 },  \n\t{ 0x47, 0x00 },  \n\t{ 0x48, 0x00 },  \n\t{ 0x49, 0x00 },  \n\t{ 0x4A, 0x00 },  \n\t{ 0x4B, 0x00 },  \n\t{ 0x4C, 0x00 },  \n\t{ 0x4D, 0x00 },  \n\t{ 0x4E, 0x00 },  \n\t{ 0x4F, 0x00 },  \n\n\t{ 0x50, 0x00 },  \n\t{ 0x51, 0x00 },  \n\t{ 0x52, 0x00 },  \n\t{ 0x53, 0x00 },  \n\t{ 0x54, 0x00 },  \n\t{ 0x55, 0x00 },  \n\t{ 0x56, 0x00 },  \n\t{ 0x57, 0x00 },  \n\t{ 0x58, 0x00 },  \n\t{ 0x59, 0x00 },  \n\t{ 0x5A, 0x00 },  \n\t{ 0x5B, 0x00 },  \n\t{ 0x5C, 0x00 },  \n\t{ 0x5D, 0x00 },  \n\t{ 0x5E, 0x00 },  \n\t{ 0x5F, 0x00 },  \n\n\t{ 0x60, 0x00 },  \n\t{ 0x61, 0x00 },  \n\t{ 0x62, 0x00 },  \n\t{ 0x63, 0x00 },  \n\t{ 0x64, 0x00 },  \n\t{ 0x65, 0x00 },  \n\t{ 0x66, 0x00 },  \n\t{ 0x67, 0x00 },  \n\t{ 0x68, 0x00 },  \n\t{ 0x69, 0x00 },  \n\t{ 0x6A, 0x00 },  \n\t{ 0x6B, 0x00 },  \n\t{ 0x6C, 0x00 },  \n\t{ 0x6D, 0x00 },  \n\t{ 0x6E, 0x00 },  \n\t{ 0x6F, 0x00 },  \n\n\t{ 0x70, 0x00 },  \n\t{ 0x71, 0x00 },  \n\t{ 0x72, 0x00 },  \n\t{ 0x73, 0x00 },  \n\t{ 0x74, 0x00 },  \n\t{ 0x75, 0x00 },  \n\t{ 0x76, 0x00 },  \n\t{ 0x77, 0x00 },  \n\t{ 0x78, 0x00 },  \n\t{ 0x79, 0x00 },  \n\t{ 0x7A, 0x00 },  \n\t{ 0x7B, 0x00 },  \n\t{ 0x7C, 0x00 },  \n\t{ 0x7D, 0x00 },  \n\t{ 0x7E, 0x00 },  \n\t{ 0x7F, 0x00 },  \n\n\t{ 0x80, 0x00 },  \n\t{ 0x81, 0x00 },  \n\t{ 0x82, 0x00 },  \n\t{ 0x83, 0x00 },  \n\t{ 0x84, 0x00 },  \n\t{ 0x85, 0x00 },  \n\t{ 0x86, 0x00 },  \n\t{ 0x87, 0x00 },  \n\t{ 0x88, 0x00 },  \n\t{ 0x89, 0x00 },  \n\t{ 0x8A, 0x00 },  \n\t{ 0x8B, 0x00 },  \n\t{ 0x8C, 0x00 },  \n\t{ 0x8D, 0x00 },  \n\t{ 0x8E, 0x00 },  \n\t{ 0x8F, 0x00 },  \n\n\t{ 0x90, 0x00 },  \n\t{ 0x91, 0x00 },  \n\t{ 0x92, 0x00 },  \n\t{ 0x93, 0x00 },  \n\t{ 0x94, 0x00 },  \n\t{ 0x95, 0x00 },  \n\t{ 0x96, 0x00 },  \n\t{ 0x97, 0x00 },  \n\t{ 0x98, 0x00 },  \n\t{ 0x99, 0x00 },  \n\t{ 0x9A, 0x00 },  \n\t{ 0x9B, 0x00 },  \n\t{ 0x9C, 0x00 },  \n\t{ 0x9D, 0x00 },  \n\t{ 0x9E, 0x00 },  \n\t{ 0x9F, 0x00 },  \n\n\t{ 0xA0, 0x00 },  \n\t{ 0xA1, 0x00 },  \n\t{ 0xA2, 0x00 },  \n\t{ 0xA3, 0x00 },  \n\t{ 0xA4, 0x00 },  \n\t{ 0xA5, 0x00 },  \n\t{ 0xA6, 0x00 },  \n\t{ 0xA7, 0x00 },  \n\t{ 0xA8, 0x00 },  \n\t{ 0xA9, 0x00 },  \n\t{ 0xAA, 0x00 },  \n\t{ 0xAB, 0x00 },  \n\t{ 0xAC, 0x00 },  \n\t{ 0xAD, 0x00 },  \n\t{ 0xAE, 0x00 },  \n\t{ 0xAF, 0x00 },  \n\n\t{ 0xB0, 0x00 },  \n\t{ 0xB1, 0x00 },  \n\t{ 0xB2, 0x00 },  \n\t{ 0xB3, 0x00 },  \n\t{ 0xB4, 0x00 },  \n\t{ 0xB5, 0x00 },  \n\t{ 0xB6, 0x00 },  \n\t{ 0xB7, 0x00 },  \n\t{ 0xB8, 0x00 },  \n\t{ 0xB9, 0x00 },  \n\t{ 0xBA, 0x00 },  \n\t{ 0xBB, 0x00 },  \n\t{ 0xBC, 0x00 },  \n\t{ 0xBD, 0x00 },  \n\t{ 0xBE, 0x00 },  \n\t{ 0xBF, 0x00 },  \n\n\t{ 0xC0, 0x00 },  \n\t{ 0xC1, 0x00 },  \n\t{ 0xC2, 0x00 },  \n\t{ 0xC3, 0x00 },  \n\t{ 0xC4, 0x00 },  \n\t{ 0xC5, 0x00 },  \n\t{ 0xC6, 0x00 },  \n\t{ 0xC7, 0x00 },  \n\t{ 0xC8, 0x00 },  \n\t{ 0xC9, 0x00 },  \n\t{ 0xCA, 0x00 },  \n\t{ 0xCB, 0x00 },  \n\t{ 0xCC, 0x00 },  \n\t{ 0xCD, 0x00 },  \n\t{ 0xCE, 0x00 },  \n\t{ 0xCF, 0x00 },  \n\n\t{ 0xD0, 0x00 },  \n\t{ 0xD1, 0x00 },  \n};\n\nstatic bool max98090_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98090_REG_SOFTWARE_RESET:\n\tcase M98090_REG_DEVICE_STATUS:\n\tcase M98090_REG_JACK_STATUS:\n\tcase M98090_REG_REVISION_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98090_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98090_REG_DEVICE_STATUS ... M98090_REG_INTERRUPT_S:\n\tcase M98090_REG_LINE_INPUT_CONFIG ... 0xD1:\n\tcase M98090_REG_REVISION_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int max98090_reset(struct max98090_priv *max98090)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(max98090->regmap, M98090_REG_SOFTWARE_RESET,\n\t\tM98090_SWRESET_MASK);\n\tif (ret < 0) {\n\t\tdev_err(max98090->component->dev,\n\t\t\t\"Failed to reset codec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(20);\n\treturn ret;\n}\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_micboost_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(max98090_mic_tlv, 0, 100, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(max98090_line_single_ended_tlv,\n\t-600, 600, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_line_tlv,\n\t0, 3, TLV_DB_SCALE_ITEM(-600, 300, 0),\n\t4, 5, TLV_DB_SCALE_ITEM(1400, 600, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(max98090_avg_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98090_av_tlv, -1200, 100, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(max98090_dvg_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98090_dv_tlv, -1500, 100, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98090_sdg_tlv, 50, 200, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_mixout_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-1200, 250, 0),\n\t2, 3, TLV_DB_SCALE_ITEM(-600, 600, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_hp_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6700, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-4000, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1700, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(-400, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(150, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_spk_tlv,\n\t0, 4, TLV_DB_SCALE_ITEM(-4800, 400, 0),\n\t5, 10, TLV_DB_SCALE_ITEM(-2900, 300, 0),\n\t11, 14, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t15, 29, TLV_DB_SCALE_ITEM(-500, 100, 0),\n\t30, 39, TLV_DB_SCALE_ITEM(950, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98090_rcv_lout_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6200, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-3500, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(100, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(650, 50, 0)\n);\n\nstatic int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int mask = (1 << fls(mc->max)) - 1;\n\tunsigned int val = snd_soc_component_read(component, mc->reg);\n\tunsigned int *select;\n\n\tswitch (mc->reg) {\n\tcase M98090_REG_MIC1_INPUT_LEVEL:\n\t\tselect = &(max98090->pa1en);\n\t\tbreak;\n\tcase M98090_REG_MIC2_INPUT_LEVEL:\n\t\tselect = &(max98090->pa2en);\n\t\tbreak;\n\tcase M98090_REG_ADC_SIDETONE:\n\t\tselect = &(max98090->sidetone);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = (val >> mc->shift) & mask;\n\n\tif (val >= 1) {\n\t\t \n\t\tval = val - 1;\n\t\t*select = val;\n\t} else {\n\t\t \n\t\tval = *select;\n\t}\n\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int mask = (1 << fls(mc->max)) - 1;\n\tint sel_unchecked = ucontrol->value.integer.value[0];\n\tunsigned int sel;\n\tunsigned int val = snd_soc_component_read(component, mc->reg);\n\tunsigned int *select;\n\tint change;\n\n\tswitch (mc->reg) {\n\tcase M98090_REG_MIC1_INPUT_LEVEL:\n\t\tselect = &(max98090->pa1en);\n\t\tbreak;\n\tcase M98090_REG_MIC2_INPUT_LEVEL:\n\t\tselect = &(max98090->pa2en);\n\t\tbreak;\n\tcase M98090_REG_ADC_SIDETONE:\n\t\tselect = &(max98090->sidetone);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = (val >> mc->shift) & mask;\n\n\tif (sel_unchecked < 0 || sel_unchecked > mc->max)\n\t\treturn -EINVAL;\n\tsel = sel_unchecked;\n\n\tchange = *select != sel;\n\t*select = sel;\n\n\t \n\tif (val >= 1) {\n\t\tsel = sel + 1;\n\t} else {\n\t\t \n\t\tsel = val;\n\t}\n\n\tsnd_soc_component_update_bits(component, mc->reg,\n\t\tmask << mc->shift,\n\t\tsel << mc->shift);\n\n\treturn change;\n}\n\nstatic const char *max98090_perf_pwr_text[] =\n\t{ \"High Performance\", \"Low Power\" };\nstatic const char *max98090_pwr_perf_text[] =\n\t{ \"Low Power\", \"High Performance\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_vcmbandgap_enum,\n\t\t\t    M98090_REG_BIAS_CONTROL,\n\t\t\t    M98090_VCM_MODE_SHIFT,\n\t\t\t    max98090_pwr_perf_text);\n\nstatic const char *max98090_osr128_text[] = { \"64*fs\", \"128*fs\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_osr128_enum,\n\t\t\t    M98090_REG_ADC_CONTROL,\n\t\t\t    M98090_OSR128_SHIFT,\n\t\t\t    max98090_osr128_text);\n\nstatic const char *max98090_mode_text[] = { \"Voice\", \"Music\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_mode_enum,\n\t\t\t    M98090_REG_FILTER_CONFIG,\n\t\t\t    M98090_MODE_SHIFT,\n\t\t\t    max98090_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_filter_dmic34mode_enum,\n\t\t\t    M98090_REG_FILTER_CONFIG,\n\t\t\t    M98090_FLT_DMIC34MODE_SHIFT,\n\t\t\t    max98090_mode_text);\n\nstatic const char *max98090_drcatk_text[] =\n\t{ \"0.5ms\", \"1ms\", \"5ms\", \"10ms\", \"25ms\", \"50ms\", \"100ms\", \"200ms\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_drcatk_enum,\n\t\t\t    M98090_REG_DRC_TIMING,\n\t\t\t    M98090_DRCATK_SHIFT,\n\t\t\t    max98090_drcatk_text);\n\nstatic const char *max98090_drcrls_text[] =\n\t{ \"8s\", \"4s\", \"2s\", \"1s\", \"0.5s\", \"0.25s\", \"0.125s\", \"0.0625s\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_drcrls_enum,\n\t\t\t    M98090_REG_DRC_TIMING,\n\t\t\t    M98090_DRCRLS_SHIFT,\n\t\t\t    max98090_drcrls_text);\n\nstatic const char *max98090_alccmp_text[] =\n\t{ \"1:1\", \"1:1.5\", \"1:2\", \"1:4\", \"1:INF\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_alccmp_enum,\n\t\t\t    M98090_REG_DRC_COMPRESSOR,\n\t\t\t    M98090_DRCCMP_SHIFT,\n\t\t\t    max98090_alccmp_text);\n\nstatic const char *max98090_drcexp_text[] = { \"1:1\", \"2:1\", \"3:1\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_drcexp_enum,\n\t\t\t    M98090_REG_DRC_EXPANDER,\n\t\t\t    M98090_DRCEXP_SHIFT,\n\t\t\t    max98090_drcexp_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_dac_perfmode_enum,\n\t\t\t    M98090_REG_DAC_CONTROL,\n\t\t\t    M98090_PERFMODE_SHIFT,\n\t\t\t    max98090_perf_pwr_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_dachp_enum,\n\t\t\t    M98090_REG_DAC_CONTROL,\n\t\t\t    M98090_DACHP_SHIFT,\n\t\t\t    max98090_pwr_perf_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98090_adchp_enum,\n\t\t\t    M98090_REG_ADC_CONTROL,\n\t\t\t    M98090_ADCHP_SHIFT,\n\t\t\t    max98090_pwr_perf_text);\n\nstatic const struct snd_kcontrol_new max98090_snd_controls[] = {\n\tSOC_ENUM(\"MIC Bias VCM Bandgap\", max98090_vcmbandgap_enum),\n\n\tSOC_SINGLE(\"DMIC MIC Comp Filter Config\", M98090_REG_DIGITAL_MIC_CONFIG,\n\t\tM98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0),\n\n\tSOC_SINGLE_EXT_TLV(\"MIC1 Boost Volume\",\n\t\tM98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,\n\t\tM98090_MIC_PA1EN_NUM - 1, 0, max98090_get_enab_tlv,\n\t\tmax98090_put_enab_tlv, max98090_micboost_tlv),\n\n\tSOC_SINGLE_EXT_TLV(\"MIC2 Boost Volume\",\n\t\tM98090_REG_MIC2_INPUT_LEVEL, M98090_MIC_PA2EN_SHIFT,\n\t\tM98090_MIC_PA2EN_NUM - 1, 0, max98090_get_enab_tlv,\n\t\tmax98090_put_enab_tlv, max98090_micboost_tlv),\n\n\tSOC_SINGLE_TLV(\"MIC1 Volume\", M98090_REG_MIC1_INPUT_LEVEL,\n\t\tM98090_MIC_PGAM1_SHIFT, M98090_MIC_PGAM1_NUM - 1, 1,\n\t\tmax98090_mic_tlv),\n\n\tSOC_SINGLE_TLV(\"MIC2 Volume\", M98090_REG_MIC2_INPUT_LEVEL,\n\t\tM98090_MIC_PGAM2_SHIFT, M98090_MIC_PGAM2_NUM - 1, 1,\n\t\tmax98090_mic_tlv),\n\n\tSOC_SINGLE_RANGE_TLV(\"LINEA Single Ended Volume\",\n\t\tM98090_REG_LINE_INPUT_LEVEL, M98090_MIXG135_SHIFT, 0,\n\t\tM98090_MIXG135_NUM - 1, 1, max98090_line_single_ended_tlv),\n\n\tSOC_SINGLE_RANGE_TLV(\"LINEB Single Ended Volume\",\n\t\tM98090_REG_LINE_INPUT_LEVEL, M98090_MIXG246_SHIFT, 0,\n\t\tM98090_MIXG246_NUM - 1, 1, max98090_line_single_ended_tlv),\n\n\tSOC_SINGLE_RANGE_TLV(\"LINEA Volume\", M98090_REG_LINE_INPUT_LEVEL,\n\t\tM98090_LINAPGA_SHIFT, 0, M98090_LINAPGA_NUM - 1, 1,\n\t\tmax98090_line_tlv),\n\n\tSOC_SINGLE_RANGE_TLV(\"LINEB Volume\", M98090_REG_LINE_INPUT_LEVEL,\n\t\tM98090_LINBPGA_SHIFT, 0, M98090_LINBPGA_NUM - 1, 1,\n\t\tmax98090_line_tlv),\n\n\tSOC_SINGLE(\"LINEA Ext Resistor Gain Mode\", M98090_REG_INPUT_MODE,\n\t\tM98090_EXTBUFA_SHIFT, M98090_EXTBUFA_NUM - 1, 0),\n\tSOC_SINGLE(\"LINEB Ext Resistor Gain Mode\", M98090_REG_INPUT_MODE,\n\t\tM98090_EXTBUFB_SHIFT, M98090_EXTBUFB_NUM - 1, 0),\n\n\tSOC_SINGLE_TLV(\"ADCL Boost Volume\", M98090_REG_LEFT_ADC_LEVEL,\n\t\tM98090_AVLG_SHIFT, M98090_AVLG_NUM - 1, 0,\n\t\tmax98090_avg_tlv),\n\tSOC_SINGLE_TLV(\"ADCR Boost Volume\", M98090_REG_RIGHT_ADC_LEVEL,\n\t\tM98090_AVRG_SHIFT, M98090_AVLG_NUM - 1, 0,\n\t\tmax98090_avg_tlv),\n\n\tSOC_SINGLE_TLV(\"ADCL Volume\", M98090_REG_LEFT_ADC_LEVEL,\n\t\tM98090_AVL_SHIFT, M98090_AVL_NUM - 1, 1,\n\t\tmax98090_av_tlv),\n\tSOC_SINGLE_TLV(\"ADCR Volume\", M98090_REG_RIGHT_ADC_LEVEL,\n\t\tM98090_AVR_SHIFT, M98090_AVR_NUM - 1, 1,\n\t\tmax98090_av_tlv),\n\n\tSOC_ENUM(\"ADC Oversampling Rate\", max98090_osr128_enum),\n\tSOC_SINGLE(\"ADC Quantizer Dither\", M98090_REG_ADC_CONTROL,\n\t\tM98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0),\n\tSOC_ENUM(\"ADC High Performance Mode\", max98090_adchp_enum),\n\n\tSOC_SINGLE(\"DAC Mono Mode\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0),\n\tSOC_SINGLE(\"SDIN Mode\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0),\n\tSOC_SINGLE(\"SDOUT Mode\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0),\n\tSOC_SINGLE(\"SDOUT Hi-Z Mode\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1),\n\tSOC_ENUM(\"Filter Mode\", max98090_mode_enum),\n\tSOC_SINGLE(\"Record Path DC Blocking\", M98090_REG_FILTER_CONFIG,\n\t\tM98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0),\n\tSOC_SINGLE(\"Playback Path DC Blocking\", M98090_REG_FILTER_CONFIG,\n\t\tM98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0),\n\tSOC_SINGLE_TLV(\"Digital BQ Volume\", M98090_REG_ADC_BIQUAD_LEVEL,\n\t\tM98090_AVBQ_SHIFT, M98090_AVBQ_NUM - 1, 1, max98090_dv_tlv),\n\tSOC_SINGLE_EXT_TLV(\"Digital Sidetone Volume\",\n\t\tM98090_REG_ADC_SIDETONE, M98090_DVST_SHIFT,\n\t\tM98090_DVST_NUM - 1, 1, max98090_get_enab_tlv,\n\t\tmax98090_put_enab_tlv, max98090_sdg_tlv),\n\tSOC_SINGLE_TLV(\"Digital Coarse Volume\", M98090_REG_DAI_PLAYBACK_LEVEL,\n\t\tM98090_DVG_SHIFT, M98090_DVG_NUM - 1, 0,\n\t\tmax98090_dvg_tlv),\n\tSOC_SINGLE_TLV(\"Digital Volume\", M98090_REG_DAI_PLAYBACK_LEVEL,\n\t\tM98090_DV_SHIFT, M98090_DV_NUM - 1, 1,\n\t\tmax98090_dv_tlv),\n\tSND_SOC_BYTES(\"EQ Coefficients\", M98090_REG_EQUALIZER_BASE, 105),\n\tSOC_SINGLE(\"Digital EQ 3 Band Switch\", M98090_REG_DSP_FILTER_ENABLE,\n\t\tM98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0),\n\tSOC_SINGLE(\"Digital EQ 5 Band Switch\", M98090_REG_DSP_FILTER_ENABLE,\n\t\tM98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0),\n\tSOC_SINGLE(\"Digital EQ 7 Band Switch\", M98090_REG_DSP_FILTER_ENABLE,\n\t\tM98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0),\n\tSOC_SINGLE(\"Digital EQ Clipping Detection\", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,\n\t\tM98090_EQCLPN_SHIFT, M98090_EQCLPN_NUM - 1,\n\t\t1),\n\tSOC_SINGLE_TLV(\"Digital EQ Volume\", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,\n\t\tM98090_DVEQ_SHIFT, M98090_DVEQ_NUM - 1, 1,\n\t\tmax98090_dv_tlv),\n\n\tSOC_SINGLE(\"ALC Enable\", M98090_REG_DRC_TIMING,\n\t\tM98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0),\n\tSOC_ENUM(\"ALC Attack Time\", max98090_drcatk_enum),\n\tSOC_ENUM(\"ALC Release Time\", max98090_drcrls_enum),\n\tSOC_SINGLE_TLV(\"ALC Make Up Volume\", M98090_REG_DRC_GAIN,\n\t\tM98090_DRCG_SHIFT, M98090_DRCG_NUM - 1, 0,\n\t\tmax98090_alcmakeup_tlv),\n\tSOC_ENUM(\"ALC Compression Ratio\", max98090_alccmp_enum),\n\tSOC_ENUM(\"ALC Expansion Ratio\", max98090_drcexp_enum),\n\tSOC_SINGLE_TLV(\"ALC Compression Threshold Volume\",\n\t\tM98090_REG_DRC_COMPRESSOR, M98090_DRCTHC_SHIFT,\n\t\tM98090_DRCTHC_NUM - 1, 1, max98090_alccomp_tlv),\n\tSOC_SINGLE_TLV(\"ALC Expansion Threshold Volume\",\n\t\tM98090_REG_DRC_EXPANDER, M98090_DRCTHE_SHIFT,\n\t\tM98090_DRCTHE_NUM - 1, 1, max98090_drcexp_tlv),\n\n\tSOC_ENUM(\"DAC HP Playback Performance Mode\",\n\t\tmax98090_dac_perfmode_enum),\n\tSOC_ENUM(\"DAC High Performance Mode\", max98090_dachp_enum),\n\n\tSOC_SINGLE_TLV(\"Headphone Left Mixer Volume\",\n\t\tM98090_REG_HP_CONTROL, M98090_MIXHPLG_SHIFT,\n\t\tM98090_MIXHPLG_NUM - 1, 1, max98090_mixout_tlv),\n\tSOC_SINGLE_TLV(\"Headphone Right Mixer Volume\",\n\t\tM98090_REG_HP_CONTROL, M98090_MIXHPRG_SHIFT,\n\t\tM98090_MIXHPRG_NUM - 1, 1, max98090_mixout_tlv),\n\n\tSOC_SINGLE_TLV(\"Speaker Left Mixer Volume\",\n\t\tM98090_REG_SPK_CONTROL, M98090_MIXSPLG_SHIFT,\n\t\tM98090_MIXSPLG_NUM - 1, 1, max98090_mixout_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Right Mixer Volume\",\n\t\tM98090_REG_SPK_CONTROL, M98090_MIXSPRG_SHIFT,\n\t\tM98090_MIXSPRG_NUM - 1, 1, max98090_mixout_tlv),\n\n\tSOC_SINGLE_TLV(\"Receiver Left Mixer Volume\",\n\t\tM98090_REG_RCV_LOUTL_CONTROL, M98090_MIXRCVLG_SHIFT,\n\t\tM98090_MIXRCVLG_NUM - 1, 1, max98090_mixout_tlv),\n\tSOC_SINGLE_TLV(\"Receiver Right Mixer Volume\",\n\t\tM98090_REG_LOUTR_CONTROL, M98090_MIXRCVRG_SHIFT,\n\t\tM98090_MIXRCVRG_NUM - 1, 1, max98090_mixout_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", M98090_REG_LEFT_HP_VOLUME,\n\t\tM98090_REG_RIGHT_HP_VOLUME, M98090_HPVOLL_SHIFT,\n\t\tM98090_HPVOLL_NUM - 1, 0, max98090_hp_tlv),\n\n\tSOC_DOUBLE_R_RANGE_TLV(\"Speaker Volume\",\n\t\tM98090_REG_LEFT_SPK_VOLUME, M98090_REG_RIGHT_SPK_VOLUME,\n\t\tM98090_SPVOLL_SHIFT, 24, M98090_SPVOLL_NUM - 1 + 24,\n\t\t0, max98090_spk_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Receiver Volume\", M98090_REG_RCV_LOUTL_VOLUME,\n\t\tM98090_REG_LOUTR_VOLUME, M98090_RCVLVOL_SHIFT,\n\t\tM98090_RCVLVOL_NUM - 1, 0, max98090_rcv_lout_tlv),\n\n\tSOC_SINGLE(\"Headphone Left Switch\", M98090_REG_LEFT_HP_VOLUME,\n\t\tM98090_HPLM_SHIFT, 1, 1),\n\tSOC_SINGLE(\"Headphone Right Switch\", M98090_REG_RIGHT_HP_VOLUME,\n\t\tM98090_HPRM_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"Speaker Left Switch\", M98090_REG_LEFT_SPK_VOLUME,\n\t\tM98090_SPLM_SHIFT, 1, 1),\n\tSOC_SINGLE(\"Speaker Right Switch\", M98090_REG_RIGHT_SPK_VOLUME,\n\t\tM98090_SPRM_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"Receiver Left Switch\", M98090_REG_RCV_LOUTL_VOLUME,\n\t\tM98090_RCVLM_SHIFT, 1, 1),\n\tSOC_SINGLE(\"Receiver Right Switch\", M98090_REG_LOUTR_VOLUME,\n\t\tM98090_RCVRM_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"Zero-Crossing Detection\", M98090_REG_LEVEL_CONTROL,\n\t\tM98090_ZDENN_SHIFT, M98090_ZDENN_NUM - 1, 1),\n\tSOC_SINGLE(\"Enhanced Vol Smoothing\", M98090_REG_LEVEL_CONTROL,\n\t\tM98090_VS2ENN_SHIFT, M98090_VS2ENN_NUM - 1, 1),\n\tSOC_SINGLE(\"Volume Adjustment Smoothing\", M98090_REG_LEVEL_CONTROL,\n\t\tM98090_VSENN_SHIFT, M98090_VSENN_NUM - 1, 1),\n\n\tSND_SOC_BYTES(\"Biquad Coefficients\", M98090_REG_RECORD_BIQUAD_BASE, 15),\n\tSOC_SINGLE(\"Biquad Switch\", M98090_REG_DSP_FILTER_ENABLE,\n\t\tM98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0),\n};\n\nstatic const struct snd_kcontrol_new max98091_snd_controls[] = {\n\n\tSOC_SINGLE(\"DMIC34 Zeropad\", M98090_REG_SAMPLE_RATE,\n\t\tM98090_DMIC34_ZEROPAD_SHIFT,\n\t\tM98090_DMIC34_ZEROPAD_NUM - 1, 0),\n\n\tSOC_ENUM(\"Filter DMIC34 Mode\", max98090_filter_dmic34mode_enum),\n\tSOC_SINGLE(\"DMIC34 DC Blocking\", M98090_REG_FILTER_CONFIG,\n\t\tM98090_FLT_DMIC34HPF_SHIFT,\n\t\tM98090_FLT_DMIC34HPF_NUM - 1, 0),\n\n\tSOC_SINGLE_TLV(\"DMIC3 Boost Volume\", M98090_REG_DMIC3_VOLUME,\n\t\tM98090_DMIC_AV3G_SHIFT, M98090_DMIC_AV3G_NUM - 1, 0,\n\t\tmax98090_avg_tlv),\n\tSOC_SINGLE_TLV(\"DMIC4 Boost Volume\", M98090_REG_DMIC4_VOLUME,\n\t\tM98090_DMIC_AV4G_SHIFT, M98090_DMIC_AV4G_NUM - 1, 0,\n\t\tmax98090_avg_tlv),\n\n\tSOC_SINGLE_TLV(\"DMIC3 Volume\", M98090_REG_DMIC3_VOLUME,\n\t\tM98090_DMIC_AV3_SHIFT, M98090_DMIC_AV3_NUM - 1, 1,\n\t\tmax98090_av_tlv),\n\tSOC_SINGLE_TLV(\"DMIC4 Volume\", M98090_REG_DMIC4_VOLUME,\n\t\tM98090_DMIC_AV4_SHIFT, M98090_DMIC_AV4_NUM - 1, 1,\n\t\tmax98090_av_tlv),\n\n\tSND_SOC_BYTES(\"DMIC34 Biquad Coefficients\",\n\t\tM98090_REG_DMIC34_BIQUAD_BASE, 15),\n\tSOC_SINGLE(\"DMIC34 Biquad Switch\", M98090_REG_DSP_FILTER_ENABLE,\n\t\tM98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0),\n\n\tSOC_SINGLE_TLV(\"DMIC34 BQ PreAttenuation Volume\",\n\t\tM98090_REG_DMIC34_BQ_PREATTEN, M98090_AV34BQ_SHIFT,\n\t\tM98090_AV34BQ_NUM - 1, 1, max98090_dv_tlv),\n};\n\nstatic int max98090_micinput_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tunsigned int val = snd_soc_component_read(component, w->reg);\n\n\tif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\n\t\tval = (val & M98090_MIC_PA1EN_MASK) >> M98090_MIC_PA1EN_SHIFT;\n\telse\n\t\tval = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;\n\n\tif (val >= 1) {\n\t\tif (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {\n\t\t\tmax98090->pa1en = val - 1;  \n\t\t} else {\n\t\t\tmax98090->pa2en = val - 1;  \n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\n\t\t\tval = max98090->pa1en + 1;\n\t\telse\n\t\t\tval = max98090->pa2en + 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\n\t\tsnd_soc_component_update_bits(component, w->reg, M98090_MIC_PA1EN_MASK,\n\t\t\tval << M98090_MIC_PA1EN_SHIFT);\n\telse\n\t\tsnd_soc_component_update_bits(component, w->reg, M98090_MIC_PA2EN_MASK,\n\t\t\tval << M98090_MIC_PA2EN_SHIFT);\n\n\treturn 0;\n}\n\nstatic int max98090_shdn_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tif (event & SND_SOC_DAPM_POST_PMU)\n\t\tmax98090->shdn_pending = true;\n\n\treturn 0;\n\n}\n\nstatic const char *mic1_mux_text[] = { \"IN12\", \"IN56\" };\n\nstatic SOC_ENUM_SINGLE_DECL(mic1_mux_enum,\n\t\t\t    M98090_REG_INPUT_MODE,\n\t\t\t    M98090_EXTMIC1_SHIFT,\n\t\t\t    mic1_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_mic1_mux =\n\tSOC_DAPM_ENUM(\"MIC1 Mux\", mic1_mux_enum);\n\nstatic const char *mic2_mux_text[] = { \"IN34\", \"IN56\" };\n\nstatic SOC_ENUM_SINGLE_DECL(mic2_mux_enum,\n\t\t\t    M98090_REG_INPUT_MODE,\n\t\t\t    M98090_EXTMIC2_SHIFT,\n\t\t\t    mic2_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_mic2_mux =\n\tSOC_DAPM_ENUM(\"MIC2 Mux\", mic2_mux_enum);\n\nstatic const char *dmic_mux_text[] = { \"ADC\", \"DMIC\" };\n\nstatic SOC_ENUM_SINGLE_VIRT_DECL(dmic_mux_enum, dmic_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_dmic_mux =\n\tSOC_DAPM_ENUM(\"DMIC Mux\", dmic_mux_enum);\n\n \nstatic const struct snd_kcontrol_new max98090_linea_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN1SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN3 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN3SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN5 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN5SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN34 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN34DIFF_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_lineb_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN2SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN4 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN4SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN6 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN6SEEN_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN56 Switch\", M98090_REG_LINE_INPUT_CONFIG,\n\t\tM98090_IN56DIFF_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_left_adc_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN12 Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_IN12DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN34 Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_IN34DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN56 Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_IN65DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_LEFT_ADC_MIXER,\n\t\tM98090_MIXADL_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_right_adc_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN12 Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_IN12DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN34 Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_IN34DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN56 Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_IN65DIFF_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_RIGHT_ADC_MIXER,\n\t\tM98090_MIXADR_MIC2_SHIFT, 1, 0),\n};\n\nstatic const char *lten_mux_text[] = { \"Normal\", \"Loopthrough\" };\n\nstatic SOC_ENUM_SINGLE_DECL(ltenl_mux_enum,\n\t\t\t    M98090_REG_IO_CONFIGURATION,\n\t\t\t    M98090_LTEN_SHIFT,\n\t\t\t    lten_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(ltenr_mux_enum,\n\t\t\t    M98090_REG_IO_CONFIGURATION,\n\t\t\t    M98090_LTEN_SHIFT,\n\t\t\t    lten_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_ltenl_mux =\n\tSOC_DAPM_ENUM(\"LTENL Mux\", ltenl_mux_enum);\n\nstatic const struct snd_kcontrol_new max98090_ltenr_mux =\n\tSOC_DAPM_ENUM(\"LTENR Mux\", ltenr_mux_enum);\n\nstatic const char *lben_mux_text[] = { \"Normal\", \"Loopback\" };\n\nstatic SOC_ENUM_SINGLE_DECL(lbenl_mux_enum,\n\t\t\t    M98090_REG_IO_CONFIGURATION,\n\t\t\t    M98090_LBEN_SHIFT,\n\t\t\t    lben_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(lbenr_mux_enum,\n\t\t\t    M98090_REG_IO_CONFIGURATION,\n\t\t\t    M98090_LBEN_SHIFT,\n\t\t\t    lben_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_lbenl_mux =\n\tSOC_DAPM_ENUM(\"LBENL Mux\", lbenl_mux_enum);\n\nstatic const struct snd_kcontrol_new max98090_lbenr_mux =\n\tSOC_DAPM_ENUM(\"LBENR Mux\", lbenr_mux_enum);\n\nstatic const char *stenl_mux_text[] = { \"Normal\", \"Sidetone Left\" };\n\nstatic const char *stenr_mux_text[] = { \"Normal\", \"Sidetone Right\" };\n\nstatic SOC_ENUM_SINGLE_DECL(stenl_mux_enum,\n\t\t\t    M98090_REG_ADC_SIDETONE,\n\t\t\t    M98090_DSTSL_SHIFT,\n\t\t\t    stenl_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(stenr_mux_enum,\n\t\t\t    M98090_REG_ADC_SIDETONE,\n\t\t\t    M98090_DSTSR_SHIFT,\n\t\t\t    stenr_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_stenl_mux =\n\tSOC_DAPM_ENUM(\"STENL Mux\", stenl_mux_enum);\n\nstatic const struct snd_kcontrol_new max98090_stenr_mux =\n\tSOC_DAPM_ENUM(\"STENR Mux\", stenr_mux_enum);\n\n \nstatic const struct\n\tsnd_kcontrol_new max98090_left_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_LEFT_SPK_MIXER,\n\t\tM98090_MIXSPL_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct\n\tsnd_kcontrol_new max98090_right_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_RIGHT_SPK_MIXER,\n\t\tM98090_MIXSPR_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_left_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_LEFT_HP_MIXER,\n\t\tM98090_MIXHPL_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_right_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_RIGHT_HP_MIXER,\n\t\tM98090_MIXHPR_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_left_rcv_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_RCV_LOUTL_MIXER,\n\t\tM98090_MIXRCVL_MIC2_SHIFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98090_right_rcv_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_DACL_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_DACR_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEA Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_LINEA_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINEB Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_LINEB_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_MIC1_SHIFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98090_REG_LOUTR_MIXER,\n\t\tM98090_MIXRCVR_MIC2_SHIFT, 1, 0),\n};\n\nstatic const char *linmod_mux_text[] = { \"Left Only\", \"Left and Right\" };\n\nstatic SOC_ENUM_SINGLE_DECL(linmod_mux_enum,\n\t\t\t    M98090_REG_LOUTR_MIXER,\n\t\t\t    M98090_LINMOD_SHIFT,\n\t\t\t    linmod_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_linmod_mux =\n\tSOC_DAPM_ENUM(\"LINMOD Mux\", linmod_mux_enum);\n\nstatic const char *mixhpsel_mux_text[] = { \"DAC Only\", \"HP Mixer\" };\n\n \nstatic SOC_ENUM_SINGLE_DECL(mixhplsel_mux_enum,\n\t\t\t    M98090_REG_HP_CONTROL,\n\t\t\t    M98090_MIXHPLSEL_SHIFT,\n\t\t\t    mixhpsel_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_mixhplsel_mux =\n\tSOC_DAPM_ENUM(\"MIXHPLSEL Mux\", mixhplsel_mux_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(mixhprsel_mux_enum,\n\t\t\t    M98090_REG_HP_CONTROL,\n\t\t\t    M98090_MIXHPRSEL_SHIFT,\n\t\t\t    mixhpsel_mux_text);\n\nstatic const struct snd_kcontrol_new max98090_mixhprsel_mux =\n\tSOC_DAPM_ENUM(\"MIXHPRSEL Mux\", mixhprsel_mux_enum);\n\nstatic const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"DMICL\"),\n\tSND_SOC_DAPM_INPUT(\"DMICR\"),\n\tSND_SOC_DAPM_INPUT(\"IN1\"),\n\tSND_SOC_DAPM_INPUT(\"IN2\"),\n\tSND_SOC_DAPM_INPUT(\"IN3\"),\n\tSND_SOC_DAPM_INPUT(\"IN4\"),\n\tSND_SOC_DAPM_INPUT(\"IN5\"),\n\tSND_SOC_DAPM_INPUT(\"IN6\"),\n\tSND_SOC_DAPM_INPUT(\"IN12\"),\n\tSND_SOC_DAPM_INPUT(\"IN34\"),\n\tSND_SOC_DAPM_INPUT(\"IN56\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", M98090_REG_INPUT_ENABLE,\n\t\tM98090_MBEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"SHDN\", M98090_REG_DEVICE_SHUTDOWN,\n\t\tM98090_SHDNN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"SDIEN\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_SDIEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"SDOEN\", M98090_REG_IO_CONFIGURATION,\n\t\tM98090_SDOEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMICL_ENA\", M98090_REG_DIGITAL_MIC_ENABLE,\n\t\t M98090_DIGMICL_SHIFT, 0, max98090_shdn_event,\n\t\t\tSND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_SUPPLY(\"DMICR_ENA\", M98090_REG_DIGITAL_MIC_ENABLE,\n\t\t M98090_DIGMICR_SHIFT, 0, max98090_shdn_event,\n\t\t\t SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_SUPPLY(\"AHPF\", M98090_REG_FILTER_CONFIG,\n\t\tM98090_AHPF_SHIFT, 0, NULL, 0),\n\n \n\n\tSND_SOC_DAPM_MUX(\"MIC1 Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_mic1_mux),\n\n\tSND_SOC_DAPM_MUX(\"MIC2 Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_mic2_mux),\n\n\tSND_SOC_DAPM_MUX(\"DMIC Mux\", SND_SOC_NOPM, 0, 0, &max98090_dmic_mux),\n\n\tSND_SOC_DAPM_PGA_E(\"MIC1 Input\", M98090_REG_MIC1_INPUT_LEVEL,\n\t\tM98090_MIC_PA1EN_SHIFT, 0, NULL, 0, max98090_micinput_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA_E(\"MIC2 Input\", M98090_REG_MIC2_INPUT_LEVEL,\n\t\tM98090_MIC_PA2EN_SHIFT, 0, NULL, 0, max98090_micinput_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MIXER(\"LINEA Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_linea_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_linea_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"LINEB Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_lineb_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_lineb_mixer_controls)),\n\n\tSND_SOC_DAPM_PGA(\"LINEA Input\", M98090_REG_INPUT_ENABLE,\n\t\tM98090_LINEAEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"LINEB Input\", M98090_REG_INPUT_ENABLE,\n\t\tM98090_LINEBEN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left ADC Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_left_adc_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_left_adc_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right ADC Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_right_adc_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_right_adc_mixer_controls)),\n\n\tSND_SOC_DAPM_ADC_E(\"ADCL\", NULL, M98090_REG_INPUT_ENABLE,\n\t\tM98090_ADLEN_SHIFT, 0, max98090_shdn_event,\n\t\tSND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_ADC_E(\"ADCR\", NULL, M98090_REG_INPUT_ENABLE,\n\t\tM98090_ADREN_SHIFT, 0, max98090_shdn_event,\n\t\tSND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUTL\", \"HiFi Capture\", 0,\n\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUTR\", \"HiFi Capture\", 1,\n\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"LBENL Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_lbenl_mux),\n\n\tSND_SOC_DAPM_MUX(\"LBENR Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_lbenr_mux),\n\n\tSND_SOC_DAPM_MUX(\"LTENL Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_ltenl_mux),\n\n\tSND_SOC_DAPM_MUX(\"LTENR Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_ltenr_mux),\n\n\tSND_SOC_DAPM_MUX(\"STENL Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_stenl_mux),\n\n\tSND_SOC_DAPM_MUX(\"STENR Mux\", SND_SOC_NOPM,\n\t\t0, 0, &max98090_stenr_mux),\n\n\tSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"HiFi Playback\", 1, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_DAC(\"DACL\", NULL, M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_DALEN_SHIFT, 0),\n\tSND_SOC_DAPM_DAC(\"DACR\", NULL, M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_DAREN_SHIFT, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_left_hp_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_left_hp_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_right_hp_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_right_hp_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Speaker Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_left_speaker_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_left_speaker_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Speaker Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_right_speaker_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_right_speaker_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Receiver Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_left_rcv_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_left_rcv_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Receiver Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_right_rcv_mixer_controls[0],\n\t\tARRAY_SIZE(max98090_right_rcv_mixer_controls)),\n\n\tSND_SOC_DAPM_MUX(\"LINMOD Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_linmod_mux),\n\n\tSND_SOC_DAPM_MUX(\"MIXHPLSEL Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_mixhplsel_mux),\n\n\tSND_SOC_DAPM_MUX(\"MIXHPRSEL Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&max98090_mixhprsel_mux),\n\n\tSND_SOC_DAPM_PGA(\"HP Left Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_HPLEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP Right Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_HPREN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"SPK Left Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_SPLEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPK Right Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_SPREN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"RCV Left Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_RCVLEN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"RCV Right Out\", M98090_REG_OUTPUT_ENABLE,\n\t\tM98090_RCVREN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n\tSND_SOC_DAPM_OUTPUT(\"RCVL\"),\n\tSND_SOC_DAPM_OUTPUT(\"RCVR\"),\n};\n\nstatic const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC3\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC4\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"DMIC3_ENA\", M98090_REG_DIGITAL_MIC_ENABLE,\n\t\t M98090_DIGMIC3_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC4_ENA\", M98090_REG_DIGITAL_MIC_ENABLE,\n\t\t M98090_DIGMIC4_SHIFT, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route max98090_dapm_routes[] = {\n\t{\"MIC1 Input\", NULL, \"MIC1\"},\n\t{\"MIC2 Input\", NULL, \"MIC2\"},\n\n\t{\"DMICL\", NULL, \"DMICL_ENA\"},\n\t{\"DMICL\", NULL, \"DMICR_ENA\"},\n\t{\"DMICR\", NULL, \"DMICL_ENA\"},\n\t{\"DMICR\", NULL, \"DMICR_ENA\"},\n\t{\"DMICL\", NULL, \"AHPF\"},\n\t{\"DMICR\", NULL, \"AHPF\"},\n\n\t \n\t{\"MIC1 Mux\", \"IN12\", \"IN12\"},\n\t{\"MIC1 Mux\", \"IN56\", \"IN56\"},\n\n\t \n\t{\"MIC2 Mux\", \"IN34\", \"IN34\"},\n\t{\"MIC2 Mux\", \"IN56\", \"IN56\"},\n\n\t{\"MIC1 Input\", NULL, \"MIC1 Mux\"},\n\t{\"MIC2 Input\", NULL, \"MIC2 Mux\"},\n\n\t \n\t{\"Left ADC Mixer\", \"IN12 Switch\", \"IN12\"},\n\t{\"Left ADC Mixer\", \"IN34 Switch\", \"IN34\"},\n\t{\"Left ADC Mixer\", \"IN56 Switch\", \"IN56\"},\n\t{\"Left ADC Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Left ADC Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\t{\"Left ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\n\t \n\t{\"Right ADC Mixer\", \"IN12 Switch\", \"IN12\"},\n\t{\"Right ADC Mixer\", \"IN34 Switch\", \"IN34\"},\n\t{\"Right ADC Mixer\", \"IN56 Switch\", \"IN56\"},\n\t{\"Right ADC Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Right ADC Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\t{\"Right ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\n\t \n\t{\"LINEA Mixer\", \"IN1 Switch\", \"IN1\"},\n\t{\"LINEA Mixer\", \"IN3 Switch\", \"IN3\"},\n\t{\"LINEA Mixer\", \"IN5 Switch\", \"IN5\"},\n\t{\"LINEA Mixer\", \"IN34 Switch\", \"IN34\"},\n\n\t \n\t{\"LINEB Mixer\", \"IN2 Switch\", \"IN2\"},\n\t{\"LINEB Mixer\", \"IN4 Switch\", \"IN4\"},\n\t{\"LINEB Mixer\", \"IN6 Switch\", \"IN6\"},\n\t{\"LINEB Mixer\", \"IN56 Switch\", \"IN56\"},\n\n\t{\"LINEA Input\", NULL, \"LINEA Mixer\"},\n\t{\"LINEB Input\", NULL, \"LINEB Mixer\"},\n\n\t \n\t{\"ADCL\", NULL, \"Left ADC Mixer\"},\n\t{\"ADCR\", NULL, \"Right ADC Mixer\"},\n\t{\"ADCL\", NULL, \"SHDN\"},\n\t{\"ADCR\", NULL, \"SHDN\"},\n\n\t{\"DMIC Mux\", \"ADC\", \"ADCL\"},\n\t{\"DMIC Mux\", \"ADC\", \"ADCR\"},\n\t{\"DMIC Mux\", \"DMIC\", \"DMICL\"},\n\t{\"DMIC Mux\", \"DMIC\", \"DMICR\"},\n\n\t{\"LBENL Mux\", \"Normal\", \"DMIC Mux\"},\n\t{\"LBENL Mux\", \"Loopback\", \"LTENL Mux\"},\n\t{\"LBENR Mux\", \"Normal\", \"DMIC Mux\"},\n\t{\"LBENR Mux\", \"Loopback\", \"LTENR Mux\"},\n\n\t{\"AIFOUTL\", NULL, \"LBENL Mux\"},\n\t{\"AIFOUTR\", NULL, \"LBENR Mux\"},\n\t{\"AIFOUTL\", NULL, \"SHDN\"},\n\t{\"AIFOUTR\", NULL, \"SHDN\"},\n\t{\"AIFOUTL\", NULL, \"SDOEN\"},\n\t{\"AIFOUTR\", NULL, \"SDOEN\"},\n\n\t{\"LTENL Mux\", \"Normal\", \"AIFINL\"},\n\t{\"LTENL Mux\", \"Loopthrough\", \"LBENL Mux\"},\n\t{\"LTENR Mux\", \"Normal\", \"AIFINR\"},\n\t{\"LTENR Mux\", \"Loopthrough\", \"LBENR Mux\"},\n\n\t{\"DACL\", NULL, \"LTENL Mux\"},\n\t{\"DACR\", NULL, \"LTENR Mux\"},\n\n\t{\"STENL Mux\", \"Sidetone Left\", \"ADCL\"},\n\t{\"STENL Mux\", \"Sidetone Left\", \"DMICL\"},\n\t{\"STENR Mux\", \"Sidetone Right\", \"ADCR\"},\n\t{\"STENR Mux\", \"Sidetone Right\", \"DMICR\"},\n\t{\"DACL\", NULL, \"STENL Mux\"},\n\t{\"DACR\", NULL, \"STENR Mux\"},\n\n\t{\"AIFINL\", NULL, \"SHDN\"},\n\t{\"AIFINR\", NULL, \"SHDN\"},\n\t{\"AIFINL\", NULL, \"SDIEN\"},\n\t{\"AIFINR\", NULL, \"SDIEN\"},\n\t{\"DACL\", NULL, \"SHDN\"},\n\t{\"DACR\", NULL, \"SHDN\"},\n\n\t \n\t{\"Left Headphone Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Left Headphone Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Left Headphone Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Headphone Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Headphone Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Left Headphone Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t \n\t{\"Right Headphone Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Right Headphone Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Right Headphone Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Headphone Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Headphone Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Right Headphone Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t \n\t{\"Left Speaker Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Left Speaker Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Left Speaker Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Speaker Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Speaker Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Left Speaker Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t \n\t{\"Right Speaker Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Right Speaker Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Right Speaker Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Speaker Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Speaker Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Right Speaker Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t \n\t{\"Left Receiver Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Left Receiver Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Left Receiver Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Receiver Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Receiver Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Left Receiver Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t \n\t{\"Right Receiver Mixer\", \"Left DAC Switch\", \"DACL\"},\n\t{\"Right Receiver Mixer\", \"Right DAC Switch\", \"DACR\"},\n\t{\"Right Receiver Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Receiver Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Receiver Mixer\", \"LINEA Switch\", \"LINEA Input\"},\n\t{\"Right Receiver Mixer\", \"LINEB Switch\", \"LINEB Input\"},\n\n\t{\"MIXHPLSEL Mux\", \"HP Mixer\", \"Left Headphone Mixer\"},\n\n\t \n\t{\"HP Left Out\", NULL, \"DACL\"},\n\t{\"HP Left Out\", NULL, \"MIXHPLSEL Mux\"},\n\n\t{\"MIXHPRSEL Mux\", \"HP Mixer\", \"Right Headphone Mixer\"},\n\n\t \n\t{\"HP Right Out\", NULL, \"DACR\"},\n\t{\"HP Right Out\", NULL, \"MIXHPRSEL Mux\"},\n\n\t{\"SPK Left Out\", NULL, \"Left Speaker Mixer\"},\n\t{\"SPK Right Out\", NULL, \"Right Speaker Mixer\"},\n\t{\"RCV Left Out\", NULL, \"Left Receiver Mixer\"},\n\n\t{\"LINMOD Mux\", \"Left and Right\", \"Right Receiver Mixer\"},\n\t{\"LINMOD Mux\", \"Left Only\",  \"Left Receiver Mixer\"},\n\t{\"RCV Right Out\", NULL, \"LINMOD Mux\"},\n\n\t{\"HPL\", NULL, \"HP Left Out\"},\n\t{\"HPR\", NULL, \"HP Right Out\"},\n\t{\"SPKL\", NULL, \"SPK Left Out\"},\n\t{\"SPKR\", NULL, \"SPK Right Out\"},\n\t{\"RCVL\", NULL, \"RCV Left Out\"},\n\t{\"RCVR\", NULL, \"RCV Right Out\"},\n};\n\nstatic const struct snd_soc_dapm_route max98091_dapm_routes[] = {\n\t \n\t{\"DMIC3\", NULL, \"DMIC3_ENA\"},\n\t{\"DMIC4\", NULL, \"DMIC4_ENA\"},\n\t{\"DMIC3\", NULL, \"AHPF\"},\n\t{\"DMIC4\", NULL, \"AHPF\"},\n};\n\nstatic int max98090_add_widgets(struct snd_soc_component *component)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_add_component_controls(component, max98090_snd_controls,\n\t\tARRAY_SIZE(max98090_snd_controls));\n\n\tif (max98090->devtype == MAX98091) {\n\t\tsnd_soc_add_component_controls(component, max98091_snd_controls,\n\t\t\tARRAY_SIZE(max98091_snd_controls));\n\t}\n\n\tsnd_soc_dapm_new_controls(dapm, max98090_dapm_widgets,\n\t\tARRAY_SIZE(max98090_dapm_widgets));\n\n\tsnd_soc_dapm_add_routes(dapm, max98090_dapm_routes,\n\t\tARRAY_SIZE(max98090_dapm_routes));\n\n\tif (max98090->devtype == MAX98091) {\n\t\tsnd_soc_dapm_new_controls(dapm, max98091_dapm_widgets,\n\t\t\tARRAY_SIZE(max98091_dapm_widgets));\n\n\t\tsnd_soc_dapm_add_routes(dapm, max98091_dapm_routes,\n\t\t\tARRAY_SIZE(max98091_dapm_routes));\n\t}\n\n\treturn 0;\n}\n\nstatic const int pclk_rates[] = {\n\t12000000, 12000000, 13000000, 13000000,\n\t16000000, 16000000, 19200000, 19200000\n};\n\nstatic const int lrclk_rates[] = {\n\t8000, 16000, 8000, 16000,\n\t8000, 16000, 8000, 16000\n};\n\nstatic const int user_pclk_rates[] = {\n\t13000000, 13000000, 19200000, 19200000,\n};\n\nstatic const int user_lrclk_rates[] = {\n\t44100, 48000, 44100, 48000,\n};\n\nstatic const unsigned long long ni_value[] = {\n\t3528, 768, 441, 8\n};\n\nstatic const unsigned long long mi_value[] = {\n\t8125, 1625, 1500, 25\n};\n\nstatic void max98090_configure_bclk(struct snd_soc_component *component)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tunsigned long long ni;\n\tint i;\n\n\tif (!max98090->sysclk) {\n\t\tdev_err(component->dev, \"No SYSCLK configured\\n\");\n\t\treturn;\n\t}\n\n\tif (!max98090->bclk || !max98090->lrclk) {\n\t\tdev_err(component->dev, \"No audio clocks configured\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!(snd_soc_component_read(component, M98090_REG_MASTER_MODE) &\n\t\tM98090_MAS_MASK)) {\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {\n\t\tif ((pclk_rates[i] == max98090->sysclk) &&\n\t\t\t(lrclk_rates[i] == max98090->lrclk)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Found supported PCLK to LRCLK rates 0x%x\\n\",\n\t\t\t\ti + 0x8);\n\n\t\t\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\t\t\tM98090_FREQ_MASK,\n\t\t\t\t(i + 0x8) << M98090_FREQ_SHIFT);\n\t\t\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\t\t\tM98090_USE_M1_MASK, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(user_pclk_rates); i++) {\n\t\tif ((user_pclk_rates[i] == max98090->sysclk) &&\n\t\t\t(user_lrclk_rates[i] == max98090->lrclk)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Found user supported PCLK to LRCLK rates\\n\");\n\t\t\tdev_dbg(component->dev, \"i %d ni %lld mi %lld\\n\",\n\t\t\t\ti, ni_value[i], mi_value[i]);\n\n\t\t\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\t\t\tM98090_FREQ_MASK, 0);\n\t\t\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\t\t\tM98090_USE_M1_MASK,\n\t\t\t\t\t1 << M98090_USE_M1_SHIFT);\n\n\t\t\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_MSB,\n\t\t\t\t(ni_value[i] >> 8) & 0x7F);\n\t\t\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_LSB,\n\t\t\t\tni_value[i] & 0xFF);\n\t\t\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_MI_MSB,\n\t\t\t\t(mi_value[i] >> 8) & 0x7F);\n\t\t\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_MI_LSB,\n\t\t\t\tmi_value[i] & 0xFF);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\tM98090_FREQ_MASK, 0);\n\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\tM98090_USE_M1_MASK, 0);\n\n\t \n\tni = 65536ULL * (max98090->lrclk < 50000 ? 96ULL : 48ULL)\n\t\t\t* (unsigned long long int)max98090->lrclk;\n\tdo_div(ni, (unsigned long long int)max98090->sysclk);\n\tdev_info(component->dev, \"No better method found\\n\");\n\tdev_info(component->dev, \"Calculating ni %lld with mi 65536\\n\", ni);\n\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_MSB,\n\t\t(ni >> 8) & 0x7F);\n\tsnd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);\n}\n\nstatic int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct max98090_cdata *cdata;\n\tu8 regval, tdm_regval;\n\n\tmax98090->dai_fmt = fmt;\n\tcdata = &max98090->dai[0];\n\n\tif (fmt != cdata->fmt) {\n\t\tcdata->fmt = fmt;\n\n\t\tregval = 0;\n\t\ttdm_regval = 0;\n\t\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\t\t \n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tM98090_REG_CLOCK_RATIO_NI_MSB, 0x00);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tM98090_REG_CLOCK_RATIO_NI_LSB, 0x00);\n\t\t\tsnd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,\n\t\t\t\tM98090_USE_M1_MASK, 0);\n\t\t\tmax98090->master = false;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t\t \n\t\t\tif (max98090->tdm_slots == 4) {\n\t\t\t\t \n\t\t\t\tregval |= M98090_MAS_MASK |\n\t\t\t\t\tM98090_BSEL_64;\n\t\t\t} else if (max98090->tdm_slots == 3) {\n\t\t\t\t \n\t\t\t\tregval |= M98090_MAS_MASK |\n\t\t\t\t\tM98090_BSEL_48;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tregval |= M98090_MAS_MASK |\n\t\t\t\t\tM98090_BSEL_32;\n\t\t\t}\n\t\t\tmax98090->master = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"DAI clock mode unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_write(component, M98090_REG_MASTER_MODE, regval);\n\n\t\tregval = 0;\n\t\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tregval |= M98090_DLY_MASK;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tregval |= M98090_RJ_MASK;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t\ttdm_regval |= M98090_TDM_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"DAI format unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tregval |= M98090_WCI_MASK;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tregval |= M98090_BCI_MASK;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tregval |= M98090_BCI_MASK|M98090_WCI_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"DAI invert mode unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (tdm_regval)\n\t\t\tregval ^= M98090_BCI_MASK;\n\n\t\tsnd_soc_component_write(component,\n\t\t\tM98090_REG_INTERFACE_FORMAT, regval);\n\n\t\tregval = 0;\n\t\tif (tdm_regval)\n\t\t\tregval = max98090->tdm_lslot << M98090_TDM_SLOTL_SHIFT |\n\t\t\t\t max98090->tdm_rslot << M98090_TDM_SLOTR_SHIFT |\n\t\t\t\t 0 << M98090_TDM_SLOTDLY_SHIFT;\n\n\t\tsnd_soc_component_write(component, M98090_REG_TDM_FORMAT, regval);\n\t\tsnd_soc_component_write(component, M98090_REG_TDM_CONTROL, tdm_regval);\n\t}\n\n\treturn 0;\n}\n\nstatic int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tif (slots < 0 || slots > 4)\n\t\treturn -EINVAL;\n\n\tif (slot_width != 16)\n\t\treturn -EINVAL;\n\n\tif (rx_mask != tx_mask)\n\t\treturn -EINVAL;\n\n\tif (!rx_mask)\n\t\treturn -EINVAL;\n\n\tmax98090->tdm_slots = slots;\n\tmax98090->tdm_lslot = ffs(rx_mask) - 1;\n\tmax98090->tdm_rslot = fls(rx_mask) - 1;\n\n\treturn 0;\n}\n\nstatic int max98090_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (IS_ERR(max98090->mclk))\n\t\t\tbreak;\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_ON) {\n\t\t\tclk_disable_unprepare(max98090->mclk);\n\t\t} else {\n\t\t\tret = clk_prepare_enable(max98090->mclk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regcache_sync(max98090->regmap);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,\n\t\t\tM98090_JDWK_MASK, M98090_JDWK_MASK);\n\t\tregcache_mark_dirty(max98090->regmap);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const int dmic_divisors[] = { 2, 3, 4, 5, 6, 8 };\n\nstatic const int comp_lrclk_rates[] = {\n\t8000, 16000, 32000, 44100, 48000, 96000\n};\n\nstruct dmic_table {\n\tint pclk;\n\tstruct {\n\t\tint freq;\n\t\tint comp[6];  \n\t} settings[6];  \n};\n\nstatic const struct dmic_table dmic_table[] = {  \n\t{\n\t\t.pclk = 11289600,\n\t\t.settings = {\n\t\t\t{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t},\n\t},\n\t{\n\t\t.pclk = 12000000,\n\t\t.settings = {\n\t\t\t{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t}\n\t},\n\t{\n\t\t.pclk = 12288000,\n\t\t.settings = {\n\t\t\t{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },\n\t\t}\n\t},\n\t{\n\t\t.pclk = 13000000,\n\t\t.settings = {\n\t\t\t{ .freq = 2, .comp = { 7, 8, 1, 1, 1, 1 } },\n\t\t\t{ .freq = 1, .comp = { 7, 8, 0, 0, 0, 0 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 4, 4, 5, 5 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },\n\t\t}\n\t},\n\t{\n\t\t.pclk = 19200000,\n\t\t.settings = {\n\t\t\t{ .freq = 2, .comp = { 0, 0, 0, 0, 0, 0 } },\n\t\t\t{ .freq = 1, .comp = { 7, 8, 1, 1, 1, 1 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 2, 2, 3, 3 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 1, 1, 2, 2 } },\n\t\t\t{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },\n\t\t}\n\t},\n};\n\nstatic int max98090_find_divisor(int target_freq, int pclk)\n{\n\tint current_diff = INT_MAX;\n\tint test_diff;\n\tint divisor_index = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dmic_divisors); i++) {\n\t\ttest_diff = abs(target_freq - (pclk / dmic_divisors[i]));\n\t\tif (test_diff < current_diff) {\n\t\t\tcurrent_diff = test_diff;\n\t\t\tdivisor_index = i;\n\t\t}\n\t}\n\n\treturn divisor_index;\n}\n\nstatic int max98090_find_closest_pclk(int pclk)\n{\n\tint m1;\n\tint m2;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dmic_table); i++) {\n\t\tif (pclk == dmic_table[i].pclk)\n\t\t\treturn i;\n\t\tif (pclk < dmic_table[i].pclk) {\n\t\t\tif (i == 0)\n\t\t\t\treturn i;\n\t\t\tm1 = pclk - dmic_table[i-1].pclk;\n\t\t\tm2 = dmic_table[i].pclk - pclk;\n\t\t\tif (m1 < m2)\n\t\t\t\treturn i - 1;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int max98090_configure_dmic(struct max98090_priv *max98090,\n\t\t\t\t   int target_dmic_clk, int pclk, int fs)\n{\n\tint micclk_index;\n\tint pclk_index;\n\tint dmic_freq;\n\tint dmic_comp;\n\tint i;\n\n\tpclk_index = max98090_find_closest_pclk(pclk);\n\tif (pclk_index < 0)\n\t\treturn pclk_index;\n\n\tmicclk_index = max98090_find_divisor(target_dmic_clk, pclk);\n\n\tfor (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {\n\t\tif (fs <= (comp_lrclk_rates[i] + comp_lrclk_rates[i+1]) / 2)\n\t\t\tbreak;\n\t}\n\n\tdmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;\n\tdmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];\n\n\tregmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,\n\t\t\t   M98090_MICCLK_MASK,\n\t\t\t   micclk_index << M98090_MICCLK_SHIFT);\n\n\tregmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_CONFIG,\n\t\t\t   M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,\n\t\t\t   dmic_comp << M98090_DMIC_COMP_SHIFT |\n\t\t\t   dmic_freq << M98090_DMIC_FREQ_SHIFT);\n\n\treturn 0;\n}\n\nstatic int max98090_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tunsigned int fmt = max98090->dai_fmt;\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_RIGHT_J) {\n\t\tsubstream->runtime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\n\t\tsnd_pcm_hw_constraint_msbits(substream->runtime, 0, 16, 16);\n\t}\n\treturn 0;\n}\n\nstatic int max98090_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct max98090_cdata *cdata;\n\n\tcdata = &max98090->dai[0];\n\tmax98090->bclk = snd_soc_params_to_bclk(params);\n\tif (params_channels(params) == 1)\n\t\tmax98090->bclk *= 2;\n\n\tmax98090->lrclk = params_rate(params);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tsnd_soc_component_update_bits(component, M98090_REG_INTERFACE_FORMAT,\n\t\t\tM98090_WS_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (max98090->master)\n\t\tmax98090_configure_bclk(component);\n\n\tcdata->rate = max98090->lrclk;\n\n\t \n\tif (max98090->lrclk < 24000)\n\t\tsnd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,\n\t\t\tM98090_MODE_MASK, 0);\n\telse\n\t\tsnd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,\n\t\t\tM98090_MODE_MASK, M98090_MODE_MASK);\n\n\t \n\tif (max98090->lrclk < 50000)\n\t\tsnd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,\n\t\t\tM98090_DHF_MASK, 0);\n\telse\n\t\tsnd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,\n\t\t\tM98090_DHF_MASK, M98090_DHF_MASK);\n\n\tmax98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,\n\t\t\t\tmax98090->lrclk);\n\n\treturn 0;\n}\n\n \nstatic int max98090_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t   int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (freq == max98090->sysclk)\n\t\treturn 0;\n\n\tif (!IS_ERR(max98090->mclk)) {\n\t\tfreq = clk_round_rate(max98090->mclk, freq);\n\t\tclk_set_rate(max98090->mclk, freq);\n\t}\n\n\t \n\tif ((freq >= 10000000) && (freq <= 20000000)) {\n\t\tsnd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,\n\t\t\tM98090_PSCLK_DIV1);\n\t\tmax98090->pclk = freq;\n\t} else if ((freq > 20000000) && (freq <= 40000000)) {\n\t\tsnd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,\n\t\t\tM98090_PSCLK_DIV2);\n\t\tmax98090->pclk = freq >> 1;\n\t} else if ((freq > 40000000) && (freq <= 60000000)) {\n\t\tsnd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,\n\t\t\tM98090_PSCLK_DIV4);\n\t\tmax98090->pclk = freq >> 2;\n\t} else {\n\t\tdev_err(component->dev, \"Invalid master clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax98090->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int max98090_dai_mute(struct snd_soc_dai *codec_dai, int mute,\n\t\t\t     int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint regval;\n\n\tregval = mute ? M98090_DVM_MASK : 0;\n\tsnd_soc_component_update_bits(component, M98090_REG_DAI_PLAYBACK_LEVEL,\n\t\tM98090_DVM_MASK, regval);\n\n\treturn 0;\n}\n\nstatic int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (!max98090->master && snd_soc_dai_active(dai) == 1)\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t   &max98090->pll_det_enable_work,\n\t\t\t\t\t   msecs_to_jiffies(10));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (!max98090->master && snd_soc_dai_active(dai) == 1)\n\t\t\tschedule_work(&max98090->pll_det_disable_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void max98090_pll_det_enable_work(struct work_struct *work)\n{\n\tstruct max98090_priv *max98090 =\n\t\tcontainer_of(work, struct max98090_priv,\n\t\t\t     pll_det_enable_work.work);\n\tstruct snd_soc_component *component = max98090->component;\n\tunsigned int status, mask;\n\n\t \n\tregmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);\n\n\t \n\tregmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\n\tstatus &= mask;\n\tif (status & M98090_JDET_MASK)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t   &max98090->jack_work,\n\t\t\t\t   msecs_to_jiffies(100));\n\n\t \n\tsnd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,\n\t\t\t    M98090_IULK_MASK,\n\t\t\t    1 << M98090_IULK_SHIFT);\n}\n\nstatic void max98090_pll_det_disable_work(struct work_struct *work)\n{\n\tstruct max98090_priv *max98090 =\n\t\tcontainer_of(work, struct max98090_priv, pll_det_disable_work);\n\tstruct snd_soc_component *component = max98090->component;\n\n\tcancel_delayed_work_sync(&max98090->pll_det_enable_work);\n\n\t \n\tsnd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,\n\t\t\t    M98090_IULK_MASK, 0);\n}\n\nstatic void max98090_pll_work(struct max98090_priv *max98090)\n{\n\tstruct snd_soc_component *component = max98090->component;\n\tunsigned int pll;\n\tint i;\n\n\tif (!snd_soc_component_active(component))\n\t\treturn;\n\n\tdev_info_ratelimited(component->dev, \"PLL unlocked\\n\");\n\n\t \n\n\t \n\tsnd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,\n\t\t\t    M98090_SHDNN_MASK, 0);\n\tsnd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,\n\t\t\t    M98090_SHDNN_MASK, M98090_SHDNN_MASK);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\t \n\t\tusleep_range(1000, 1200);\n\n\t\t \n\t\tpll = snd_soc_component_read(\n\t\t\t\tcomponent, M98090_REG_DEVICE_STATUS);\n\t\tif (!(pll & M98090_ULK_MASK))\n\t\t\tbreak;\n\t}\n}\n\nstatic void max98090_jack_work(struct work_struct *work)\n{\n\tstruct max98090_priv *max98090 = container_of(work,\n\t\tstruct max98090_priv,\n\t\tjack_work.work);\n\tstruct snd_soc_component *component = max98090->component;\n\tint status = 0;\n\tint reg;\n\n\t \n\tif (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,\n\t\t\tM98090_JDWK_MASK, 0);\n\n\t\tmsleep(50);\n\n\t\tsnd_soc_component_read(component, M98090_REG_JACK_STATUS);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,\n\t\t\tM98090_JDWK_MASK, M98090_JDWK_MASK);\n\t}\n\n\treg = snd_soc_component_read(component, M98090_REG_JACK_STATUS);\n\n\tswitch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {\n\t\tcase M98090_LSNS_MASK | M98090_JKSNS_MASK:\n\t\t\tdev_dbg(component->dev, \"No Headset Detected\\n\");\n\n\t\t\tmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\n\n\t\t\tstatus |= 0;\n\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\tif (max98090->jack_state ==\n\t\t\t\tM98090_JACK_STATE_HEADSET) {\n\n\t\t\t\tdev_dbg(component->dev,\n\t\t\t\t\t\"Headset Button Down Detected\\n\");\n\n\t\t\t\t \n\n\t\t\t\tstatus |= SND_JACK_HEADSET;\n\t\t\t\tstatus |= SND_JACK_BTN_0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tdev_dbg(component->dev, \"Headphone Detected\\n\");\n\n\t\t\tmax98090->jack_state = M98090_JACK_STATE_HEADPHONE;\n\n\t\t\tstatus |= SND_JACK_HEADPHONE;\n\n\t\t\tbreak;\n\n\t\tcase M98090_JKSNS_MASK:\n\t\t\tdev_dbg(component->dev, \"Headset Detected\\n\");\n\n\t\t\tmax98090->jack_state = M98090_JACK_STATE_HEADSET;\n\n\t\t\tstatus |= SND_JACK_HEADSET;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(component->dev, \"Unrecognized Jack Status\\n\");\n\t\t\tbreak;\n\t}\n\n\tsnd_soc_jack_report(max98090->jack, status,\n\t\t\t    SND_JACK_HEADSET | SND_JACK_BTN_0);\n}\n\nstatic irqreturn_t max98090_interrupt(int irq, void *data)\n{\n\tstruct max98090_priv *max98090 = data;\n\tstruct snd_soc_component *component = max98090->component;\n\tint ret;\n\tunsigned int mask;\n\tunsigned int active;\n\n\t \n\tif (component == NULL)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(component->dev, \"***** max98090_interrupt *****\\n\");\n\n\tret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\n\n\tif (ret != 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"failed to read M98090_REG_INTERRUPT_S: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);\n\n\tif (ret != 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"failed to read M98090_REG_DEVICE_STATUS: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_dbg(component->dev, \"active=0x%02x mask=0x%02x -> active=0x%02x\\n\",\n\t\tactive, mask, active & mask);\n\n\tactive &= mask;\n\n\tif (!active)\n\t\treturn IRQ_NONE;\n\n\tif (active & M98090_CLD_MASK)\n\t\tdev_err(component->dev, \"M98090_CLD_MASK\\n\");\n\n\tif (active & M98090_SLD_MASK)\n\t\tdev_dbg(component->dev, \"M98090_SLD_MASK\\n\");\n\n\tif (active & M98090_ULK_MASK) {\n\t\tdev_dbg(component->dev, \"M98090_ULK_MASK\\n\");\n\t\tmax98090_pll_work(max98090);\n\t}\n\n\tif (active & M98090_JDET_MASK) {\n\t\tdev_dbg(component->dev, \"M98090_JDET_MASK\\n\");\n\n\t\tpm_wakeup_event(component->dev, 100);\n\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t   &max98090->jack_work,\n\t\t\t\t   msecs_to_jiffies(100));\n\t}\n\n\tif (active & M98090_DRCACT_MASK)\n\t\tdev_dbg(component->dev, \"M98090_DRCACT_MASK\\n\");\n\n\tif (active & M98090_DRCCLP_MASK)\n\t\tdev_err(component->dev, \"M98090_DRCCLP_MASK\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nint max98090_mic_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *jack)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"max98090_mic_detect\\n\");\n\n\tmax98090->jack = jack;\n\tif (jack) {\n\t\tsnd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,\n\t\t\tM98090_IJDET_MASK,\n\t\t\t1 << M98090_IJDET_SHIFT);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,\n\t\t\tM98090_IJDET_MASK,\n\t\t\t0);\n\t}\n\n\t \n\tsnd_soc_jack_report(max98090->jack, 0,\n\t\t\t    SND_JACK_HEADSET | SND_JACK_BTN_0);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &max98090->jack_work,\n\t\t\t   msecs_to_jiffies(100));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(max98090_mic_detect);\n\n#define MAX98090_RATES SNDRV_PCM_RATE_8000_96000\n#define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops max98090_dai_ops = {\n\t.startup = max98090_dai_startup,\n\t.set_sysclk = max98090_dai_set_sysclk,\n\t.set_fmt = max98090_dai_set_fmt,\n\t.set_tdm_slot = max98090_set_tdm_slot,\n\t.hw_params = max98090_dai_hw_params,\n\t.mute_stream = max98090_dai_mute,\n\t.trigger = max98090_dai_trigger,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver max98090_dai = {\n\t.name = \"HiFi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = MAX98090_RATES,\n\t\t.formats = MAX98090_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MAX98090_RATES,\n\t\t.formats = MAX98090_FORMATS,\n\t},\n\t .ops = &max98090_dai_ops,\n};\n\nstatic int max98090_probe(struct snd_soc_component *component)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\tstruct max98090_cdata *cdata;\n\tenum max98090_type devtype;\n\tint ret = 0;\n\tint err;\n\tunsigned int micbias;\n\n\tdev_dbg(component->dev, \"max98090_probe\\n\");\n\n\tmax98090->mclk = devm_clk_get(component->dev, \"mclk\");\n\tif (PTR_ERR(max98090->mclk) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tmax98090->component = component;\n\n\t \n\tmax98090_reset(max98090);\n\n\t \n\n\tmax98090->sysclk = (unsigned)-1;\n\tmax98090->pclk = (unsigned)-1;\n\tmax98090->master = false;\n\n\tcdata = &max98090->dai[0];\n\tcdata->rate = (unsigned)-1;\n\tcdata->fmt  = (unsigned)-1;\n\n\tmax98090->lin_state = 0;\n\tmax98090->pa1en = 0;\n\tmax98090->pa2en = 0;\n\n\tmax98090->tdm_lslot = 0;\n\tmax98090->tdm_rslot = 1;\n\n\tret = snd_soc_component_read(component, M98090_REG_REVISION_ID);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to read device revision: %d\\n\",\n\t\t\tret);\n\t\tgoto err_access;\n\t}\n\n\tif ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {\n\t\tdevtype = MAX98090;\n\t\tdev_info(component->dev, \"MAX98090 REVID=0x%02x\\n\", ret);\n\t} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {\n\t\tdevtype = MAX98091;\n\t\tdev_info(component->dev, \"MAX98091 REVID=0x%02x\\n\", ret);\n\t} else {\n\t\tdevtype = MAX98090;\n\t\tdev_err(component->dev, \"Unrecognized revision 0x%02x\\n\", ret);\n\t}\n\n\tif (max98090->devtype != devtype) {\n\t\tdev_warn(component->dev, \"Mismatch in DT specified CODEC type.\\n\");\n\t\tmax98090->devtype = devtype;\n\t}\n\n\tmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\n\n\tINIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);\n\tINIT_DELAYED_WORK(&max98090->pll_det_enable_work,\n\t\t\t  max98090_pll_det_enable_work);\n\tINIT_WORK(&max98090->pll_det_disable_work,\n\t\t  max98090_pll_det_disable_work);\n\n\t \n\tsnd_soc_component_write(component, M98090_REG_JACK_DETECT,\n\t\tM98090_JDETEN_MASK | M98090_JDEB_25MS);\n\n\t \n\tsnd_soc_component_read(component, M98090_REG_DEVICE_STATUS);\n\n\t \n\tsnd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,\n\t\tM98090_DACHP_MASK,\n\t\t1 << M98090_DACHP_SHIFT);\n\tsnd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,\n\t\tM98090_PERFMODE_MASK,\n\t\t0 << M98090_PERFMODE_SHIFT);\n\tsnd_soc_component_update_bits(component, M98090_REG_ADC_CONTROL,\n\t\tM98090_ADCHP_MASK,\n\t\t1 << M98090_ADCHP_SHIFT);\n\n\t \n\tsnd_soc_component_write(component, M98090_REG_BIAS_CONTROL,\n\t\tM98090_VCM_MODE_MASK);\n\n\terr = device_property_read_u32(component->dev, \"maxim,micbias\", &micbias);\n\tif (err) {\n\t\tmicbias = M98090_MBVSEL_2V8;\n\t\tdev_info(component->dev, \"use default 2.8v micbias\\n\");\n\t} else if (micbias > M98090_MBVSEL_2V8) {\n\t\tdev_err(component->dev, \"micbias out of range 0x%x\\n\", micbias);\n\t\tmicbias = M98090_MBVSEL_2V8;\n\t}\n\n\tsnd_soc_component_update_bits(component, M98090_REG_MIC_BIAS_VOLTAGE,\n\t\tM98090_MBVSEL_MASK, micbias);\n\n\tmax98090_add_widgets(component);\n\nerr_access:\n\treturn ret;\n}\n\nstatic void max98090_remove(struct snd_soc_component *component)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&max98090->jack_work);\n\tcancel_delayed_work_sync(&max98090->pll_det_enable_work);\n\tcancel_work_sync(&max98090->pll_det_disable_work);\n\tmax98090->component = NULL;\n}\n\nstatic void max98090_seq_notifier(struct snd_soc_component *component,\n\tenum snd_soc_dapm_type event, int subseq)\n{\n\tstruct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);\n\n\tif (max98090->shdn_pending) {\n\t\tsnd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,\n\t\t\t\tM98090_SHDNN_MASK, 0);\n\t\tmsleep(40);\n\t\tsnd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,\n\t\t\t\tM98090_SHDNN_MASK, M98090_SHDNN_MASK);\n\t\tmax98090->shdn_pending = false;\n\t}\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98090 = {\n\t.probe\t\t\t= max98090_probe,\n\t.remove\t\t\t= max98090_remove,\n\t.seq_notifier\t\t= max98090_seq_notifier,\n\t.set_bias_level\t\t= max98090_set_bias_level,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98090_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = MAX98090_MAX_REGISTER,\n\t.reg_defaults = max98090_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98090_reg),\n\t.volatile_reg = max98090_volatile_register,\n\t.readable_reg = max98090_readable_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct i2c_device_id max98090_i2c_id[] = {\n\t{ \"max98090\", MAX98090 },\n\t{ \"max98091\", MAX98091 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max98090_i2c_id);\n\nstatic int max98090_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max98090_priv *max98090;\n\tconst struct acpi_device_id *acpi_id;\n\tkernel_ulong_t driver_data = 0;\n\tint ret;\n\n\tpr_debug(\"max98090_i2c_probe\\n\");\n\n\tmax98090 = devm_kzalloc(&i2c->dev, sizeof(struct max98090_priv),\n\t\tGFP_KERNEL);\n\tif (max98090 == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ACPI_HANDLE(&i2c->dev)) {\n\t\tacpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,\n\t\t\t\t\t    &i2c->dev);\n\t\tif (!acpi_id) {\n\t\t\tdev_err(&i2c->dev, \"No driver data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdriver_data = acpi_id->driver_data;\n\t} else {\n\t\tconst struct i2c_device_id *i2c_id =\n\t\t\ti2c_match_id(max98090_i2c_id, i2c);\n\t\tdriver_data = i2c_id->driver_data;\n\t}\n\n\tmax98090->devtype = driver_data;\n\ti2c_set_clientdata(i2c, max98090);\n\tmax98090->pdata = i2c->dev.platform_data;\n\n\tret = of_property_read_u32(i2c->dev.of_node, \"maxim,dmic-freq\",\n\t\t\t\t   &max98090->dmic_freq);\n\tif (ret < 0)\n\t\tmax98090->dmic_freq = MAX98090_DEFAULT_DMIC_FREQ;\n\n\tmax98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);\n\tif (IS_ERR(max98090->regmap)) {\n\t\tret = PTR_ERR(max98090->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\n\t\tmax98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\"max98090_interrupt\", max98090);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"request_irq failed: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t      &soc_component_dev_max98090,\n\t\t\t\t\t      &max98090_dai, 1);\nerr_enable:\n\treturn ret;\n}\n\nstatic void max98090_i2c_shutdown(struct i2c_client *i2c)\n{\n\tstruct max98090_priv *max98090 = dev_get_drvdata(&i2c->dev);\n\n\t \n\tregmap_write(max98090->regmap,\n\t\tM98090_REG_LEVEL_CONTROL, M98090_VSENN_MASK);\n\tregmap_write(max98090->regmap,\n\t\tM98090_REG_DEVICE_SHUTDOWN, 0x00);\n\tmsleep(40);\n}\n\nstatic void max98090_i2c_remove(struct i2c_client *client)\n{\n\tmax98090_i2c_shutdown(client);\n}\n\n#ifdef CONFIG_PM\nstatic int max98090_runtime_resume(struct device *dev)\n{\n\tstruct max98090_priv *max98090 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98090->regmap, false);\n\n\tmax98090_reset(max98090);\n\n\tregcache_sync(max98090->regmap);\n\n\treturn 0;\n}\n\nstatic int max98090_runtime_suspend(struct device *dev)\n{\n\tstruct max98090_priv *max98090 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98090->regmap, true);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max98090_resume(struct device *dev)\n{\n\tstruct max98090_priv *max98090 = dev_get_drvdata(dev);\n\tunsigned int status;\n\n\tregcache_mark_dirty(max98090->regmap);\n\n\tmax98090_reset(max98090);\n\n\t \n\tregmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);\n\n\tregcache_sync(max98090->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops max98090_pm = {\n\tSET_RUNTIME_PM_OPS(max98090_runtime_suspend,\n\t\tmax98090_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, max98090_resume)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98090_of_match[] = {\n\t{ .compatible = \"maxim,max98090\", },\n\t{ .compatible = \"maxim,max98091\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98090_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max98090_acpi_match[] = {\n\t{ \"193C9890\", MAX98090 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, max98090_acpi_match);\n#endif\n\nstatic struct i2c_driver max98090_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98090\",\n\t\t.pm = &max98090_pm,\n\t\t.of_match_table = of_match_ptr(max98090_of_match),\n\t\t.acpi_match_table = ACPI_PTR(max98090_acpi_match),\n\t},\n\t.probe = max98090_i2c_probe,\n\t.shutdown = max98090_i2c_shutdown,\n\t.remove = max98090_i2c_remove,\n\t.id_table = max98090_i2c_id,\n};\n\nmodule_i2c_driver(max98090_i2c_driver);\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98090 driver\");\nMODULE_AUTHOR(\"Peter Hsiang, Jesse Marroqin, Jerry Wong\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}