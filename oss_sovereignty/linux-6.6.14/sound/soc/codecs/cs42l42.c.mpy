{
  "module_name": "cs42l42.c",
  "hash_id": "4f7823d1f431092134c2b6565ab7455a0cfb1832fb014b4f6e9b4a0ab83104ff",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l42.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/version.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <dt-bindings/sound/cs42l42.h>\n\n#include \"cs42l42.h\"\n#include \"cirrus_legacy.h\"\n\nstatic const char * const cs42l42_supply_names[] = {\n\t\"VA\",\n\t\"VP\",\n\t\"VCP\",\n\t\"VD_FILT\",\n\t\"VL\",\n};\n\nstatic const struct reg_default cs42l42_reg_defaults[] = {\n\t{ CS42L42_FRZ_CTL,\t\t\t0x00 },\n\t{ CS42L42_SRC_CTL,\t\t\t0x10 },\n\t{ CS42L42_MCLK_CTL,\t\t\t0x02 },\n\t{ CS42L42_SFTRAMP_RATE,\t\t\t0xA4 },\n\t{ CS42L42_SLOW_START_ENABLE,\t\t0x70 },\n\t{ CS42L42_I2C_DEBOUNCE,\t\t\t0x88 },\n\t{ CS42L42_I2C_STRETCH,\t\t\t0x03 },\n\t{ CS42L42_I2C_TIMEOUT,\t\t\t0xB7 },\n\t{ CS42L42_PWR_CTL1,\t\t\t0xFF },\n\t{ CS42L42_PWR_CTL2,\t\t\t0x84 },\n\t{ CS42L42_PWR_CTL3,\t\t\t0x20 },\n\t{ CS42L42_RSENSE_CTL1,\t\t\t0x40 },\n\t{ CS42L42_RSENSE_CTL2,\t\t\t0x00 },\n\t{ CS42L42_OSC_SWITCH,\t\t\t0x00 },\n\t{ CS42L42_RSENSE_CTL3,\t\t\t0x1B },\n\t{ CS42L42_TSENSE_CTL,\t\t\t0x1B },\n\t{ CS42L42_TSRS_INT_DISABLE,\t\t0x00 },\n\t{ CS42L42_HSDET_CTL1,\t\t\t0x77 },\n\t{ CS42L42_HSDET_CTL2,\t\t\t0x00 },\n\t{ CS42L42_HS_SWITCH_CTL,\t\t0xF3 },\n\t{ CS42L42_HS_CLAMP_DISABLE,\t\t0x00 },\n\t{ CS42L42_MCLK_SRC_SEL,\t\t\t0x00 },\n\t{ CS42L42_SPDIF_CLK_CFG,\t\t0x00 },\n\t{ CS42L42_FSYNC_PW_LOWER,\t\t0x00 },\n\t{ CS42L42_FSYNC_PW_UPPER,\t\t0x00 },\n\t{ CS42L42_FSYNC_P_LOWER,\t\t0xF9 },\n\t{ CS42L42_FSYNC_P_UPPER,\t\t0x00 },\n\t{ CS42L42_ASP_CLK_CFG,\t\t\t0x00 },\n\t{ CS42L42_ASP_FRM_CFG,\t\t\t0x10 },\n\t{ CS42L42_FS_RATE_EN,\t\t\t0x00 },\n\t{ CS42L42_IN_ASRC_CLK,\t\t\t0x00 },\n\t{ CS42L42_OUT_ASRC_CLK,\t\t\t0x00 },\n\t{ CS42L42_PLL_DIV_CFG1,\t\t\t0x00 },\n\t{ CS42L42_ADC_OVFL_INT_MASK,\t\t0x01 },\n\t{ CS42L42_MIXER_INT_MASK,\t\t0x0F },\n\t{ CS42L42_SRC_INT_MASK,\t\t\t0x0F },\n\t{ CS42L42_ASP_RX_INT_MASK,\t\t0x1F },\n\t{ CS42L42_ASP_TX_INT_MASK,\t\t0x0F },\n\t{ CS42L42_CODEC_INT_MASK,\t\t0x03 },\n\t{ CS42L42_SRCPL_INT_MASK,\t\t0x7F },\n\t{ CS42L42_VPMON_INT_MASK,\t\t0x01 },\n\t{ CS42L42_PLL_LOCK_INT_MASK,\t\t0x01 },\n\t{ CS42L42_TSRS_PLUG_INT_MASK,\t\t0x0F },\n\t{ CS42L42_PLL_CTL1,\t\t\t0x00 },\n\t{ CS42L42_PLL_DIV_FRAC0,\t\t0x00 },\n\t{ CS42L42_PLL_DIV_FRAC1,\t\t0x00 },\n\t{ CS42L42_PLL_DIV_FRAC2,\t\t0x00 },\n\t{ CS42L42_PLL_DIV_INT,\t\t\t0x40 },\n\t{ CS42L42_PLL_CTL3,\t\t\t0x10 },\n\t{ CS42L42_PLL_CAL_RATIO,\t\t0x80 },\n\t{ CS42L42_PLL_CTL4,\t\t\t0x03 },\n\t{ CS42L42_LOAD_DET_EN,\t\t\t0x00 },\n\t{ CS42L42_HSBIAS_SC_AUTOCTL,\t\t0x03 },\n\t{ CS42L42_WAKE_CTL,\t\t\t0xC0 },\n\t{ CS42L42_ADC_DISABLE_MUTE,\t\t0x00 },\n\t{ CS42L42_TIPSENSE_CTL,\t\t\t0x02 },\n\t{ CS42L42_MISC_DET_CTL,\t\t\t0x03 },\n\t{ CS42L42_MIC_DET_CTL1,\t\t\t0x1F },\n\t{ CS42L42_MIC_DET_CTL2,\t\t\t0x2F },\n\t{ CS42L42_DET_INT1_MASK,\t\t0xE0 },\n\t{ CS42L42_DET_INT2_MASK,\t\t0xFF },\n\t{ CS42L42_HS_BIAS_CTL,\t\t\t0xC2 },\n\t{ CS42L42_ADC_CTL,\t\t\t0x00 },\n\t{ CS42L42_ADC_VOLUME,\t\t\t0x00 },\n\t{ CS42L42_ADC_WNF_HPF_CTL,\t\t0x71 },\n\t{ CS42L42_DAC_CTL1,\t\t\t0x00 },\n\t{ CS42L42_DAC_CTL2,\t\t\t0x02 },\n\t{ CS42L42_HP_CTL,\t\t\t0x0D },\n\t{ CS42L42_CLASSH_CTL,\t\t\t0x07 },\n\t{ CS42L42_MIXER_CHA_VOL,\t\t0x3F },\n\t{ CS42L42_MIXER_ADC_VOL,\t\t0x3F },\n\t{ CS42L42_MIXER_CHB_VOL,\t\t0x3F },\n\t{ CS42L42_EQ_COEF_IN0,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_IN1,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_IN2,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_IN3,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_RW,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_OUT0,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_OUT1,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_OUT2,\t\t\t0x00 },\n\t{ CS42L42_EQ_COEF_OUT3,\t\t\t0x00 },\n\t{ CS42L42_EQ_INIT_STAT,\t\t\t0x00 },\n\t{ CS42L42_EQ_START_FILT,\t\t0x00 },\n\t{ CS42L42_EQ_MUTE_CTL,\t\t\t0x00 },\n\t{ CS42L42_SP_RX_CH_SEL,\t\t\t0x04 },\n\t{ CS42L42_SP_RX_ISOC_CTL,\t\t0x04 },\n\t{ CS42L42_SP_RX_FS,\t\t\t0x8C },\n\t{ CS42l42_SPDIF_CH_SEL,\t\t\t0x0E },\n\t{ CS42L42_SP_TX_ISOC_CTL,\t\t0x04 },\n\t{ CS42L42_SP_TX_FS,\t\t\t0xCC },\n\t{ CS42L42_SPDIF_SW_CTL1,\t\t0x3F },\n\t{ CS42L42_SRC_SDIN_FS,\t\t\t0x40 },\n\t{ CS42L42_SRC_SDOUT_FS,\t\t\t0x40 },\n\t{ CS42L42_SPDIF_CTL1,\t\t\t0x01 },\n\t{ CS42L42_SPDIF_CTL2,\t\t\t0x00 },\n\t{ CS42L42_SPDIF_CTL3,\t\t\t0x00 },\n\t{ CS42L42_SPDIF_CTL4,\t\t\t0x42 },\n\t{ CS42L42_ASP_TX_SZ_EN,\t\t\t0x00 },\n\t{ CS42L42_ASP_TX_CH_EN,\t\t\t0x00 },\n\t{ CS42L42_ASP_TX_CH_AP_RES,\t\t0x0F },\n\t{ CS42L42_ASP_TX_CH1_BIT_MSB,\t\t0x00 },\n\t{ CS42L42_ASP_TX_CH1_BIT_LSB,\t\t0x00 },\n\t{ CS42L42_ASP_TX_HIZ_DLY_CFG,\t\t0x00 },\n\t{ CS42L42_ASP_TX_CH2_BIT_MSB,\t\t0x00 },\n\t{ CS42L42_ASP_TX_CH2_BIT_LSB,\t\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_EN,\t\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH1_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI0_CH1_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH1_BIT_LSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH2_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI0_CH2_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH2_BIT_LSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH3_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI0_CH3_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH3_BIT_LSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH4_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI0_CH4_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI0_CH4_BIT_LSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI1_CH1_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI1_CH1_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI1_CH1_BIT_LSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI1_CH2_AP_RES,\t0x03 },\n\t{ CS42L42_ASP_RX_DAI1_CH2_BIT_MSB,\t0x00 },\n\t{ CS42L42_ASP_RX_DAI1_CH2_BIT_LSB,\t0x00 },\n};\n\nbool cs42l42_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L42_PAGE_REGISTER:\n\tcase CS42L42_DEVID_AB:\n\tcase CS42L42_DEVID_CD:\n\tcase CS42L42_DEVID_E:\n\tcase CS42L42_FABID:\n\tcase CS42L42_REVID:\n\tcase CS42L42_FRZ_CTL:\n\tcase CS42L42_SRC_CTL:\n\tcase CS42L42_MCLK_STATUS:\n\tcase CS42L42_MCLK_CTL:\n\tcase CS42L42_SFTRAMP_RATE:\n\tcase CS42L42_SLOW_START_ENABLE:\n\tcase CS42L42_I2C_DEBOUNCE:\n\tcase CS42L42_I2C_STRETCH:\n\tcase CS42L42_I2C_TIMEOUT:\n\tcase CS42L42_PWR_CTL1:\n\tcase CS42L42_PWR_CTL2:\n\tcase CS42L42_PWR_CTL3:\n\tcase CS42L42_RSENSE_CTL1:\n\tcase CS42L42_RSENSE_CTL2:\n\tcase CS42L42_OSC_SWITCH:\n\tcase CS42L42_OSC_SWITCH_STATUS:\n\tcase CS42L42_RSENSE_CTL3:\n\tcase CS42L42_TSENSE_CTL:\n\tcase CS42L42_TSRS_INT_DISABLE:\n\tcase CS42L42_TRSENSE_STATUS:\n\tcase CS42L42_HSDET_CTL1:\n\tcase CS42L42_HSDET_CTL2:\n\tcase CS42L42_HS_SWITCH_CTL:\n\tcase CS42L42_HS_DET_STATUS:\n\tcase CS42L42_HS_CLAMP_DISABLE:\n\tcase CS42L42_MCLK_SRC_SEL:\n\tcase CS42L42_SPDIF_CLK_CFG:\n\tcase CS42L42_FSYNC_PW_LOWER:\n\tcase CS42L42_FSYNC_PW_UPPER:\n\tcase CS42L42_FSYNC_P_LOWER:\n\tcase CS42L42_FSYNC_P_UPPER:\n\tcase CS42L42_ASP_CLK_CFG:\n\tcase CS42L42_ASP_FRM_CFG:\n\tcase CS42L42_FS_RATE_EN:\n\tcase CS42L42_IN_ASRC_CLK:\n\tcase CS42L42_OUT_ASRC_CLK:\n\tcase CS42L42_PLL_DIV_CFG1:\n\tcase CS42L42_ADC_OVFL_STATUS:\n\tcase CS42L42_MIXER_STATUS:\n\tcase CS42L42_SRC_STATUS:\n\tcase CS42L42_ASP_RX_STATUS:\n\tcase CS42L42_ASP_TX_STATUS:\n\tcase CS42L42_CODEC_STATUS:\n\tcase CS42L42_DET_INT_STATUS1:\n\tcase CS42L42_DET_INT_STATUS2:\n\tcase CS42L42_SRCPL_INT_STATUS:\n\tcase CS42L42_VPMON_STATUS:\n\tcase CS42L42_PLL_LOCK_STATUS:\n\tcase CS42L42_TSRS_PLUG_STATUS:\n\tcase CS42L42_ADC_OVFL_INT_MASK:\n\tcase CS42L42_MIXER_INT_MASK:\n\tcase CS42L42_SRC_INT_MASK:\n\tcase CS42L42_ASP_RX_INT_MASK:\n\tcase CS42L42_ASP_TX_INT_MASK:\n\tcase CS42L42_CODEC_INT_MASK:\n\tcase CS42L42_SRCPL_INT_MASK:\n\tcase CS42L42_VPMON_INT_MASK:\n\tcase CS42L42_PLL_LOCK_INT_MASK:\n\tcase CS42L42_TSRS_PLUG_INT_MASK:\n\tcase CS42L42_PLL_CTL1:\n\tcase CS42L42_PLL_DIV_FRAC0:\n\tcase CS42L42_PLL_DIV_FRAC1:\n\tcase CS42L42_PLL_DIV_FRAC2:\n\tcase CS42L42_PLL_DIV_INT:\n\tcase CS42L42_PLL_CTL3:\n\tcase CS42L42_PLL_CAL_RATIO:\n\tcase CS42L42_PLL_CTL4:\n\tcase CS42L42_LOAD_DET_RCSTAT:\n\tcase CS42L42_LOAD_DET_DONE:\n\tcase CS42L42_LOAD_DET_EN:\n\tcase CS42L42_HSBIAS_SC_AUTOCTL:\n\tcase CS42L42_WAKE_CTL:\n\tcase CS42L42_ADC_DISABLE_MUTE:\n\tcase CS42L42_TIPSENSE_CTL:\n\tcase CS42L42_MISC_DET_CTL:\n\tcase CS42L42_MIC_DET_CTL1:\n\tcase CS42L42_MIC_DET_CTL2:\n\tcase CS42L42_DET_STATUS1:\n\tcase CS42L42_DET_STATUS2:\n\tcase CS42L42_DET_INT1_MASK:\n\tcase CS42L42_DET_INT2_MASK:\n\tcase CS42L42_HS_BIAS_CTL:\n\tcase CS42L42_ADC_CTL:\n\tcase CS42L42_ADC_VOLUME:\n\tcase CS42L42_ADC_WNF_HPF_CTL:\n\tcase CS42L42_DAC_CTL1:\n\tcase CS42L42_DAC_CTL2:\n\tcase CS42L42_HP_CTL:\n\tcase CS42L42_CLASSH_CTL:\n\tcase CS42L42_MIXER_CHA_VOL:\n\tcase CS42L42_MIXER_ADC_VOL:\n\tcase CS42L42_MIXER_CHB_VOL:\n\tcase CS42L42_EQ_COEF_IN0:\n\tcase CS42L42_EQ_COEF_IN1:\n\tcase CS42L42_EQ_COEF_IN2:\n\tcase CS42L42_EQ_COEF_IN3:\n\tcase CS42L42_EQ_COEF_RW:\n\tcase CS42L42_EQ_COEF_OUT0:\n\tcase CS42L42_EQ_COEF_OUT1:\n\tcase CS42L42_EQ_COEF_OUT2:\n\tcase CS42L42_EQ_COEF_OUT3:\n\tcase CS42L42_EQ_INIT_STAT:\n\tcase CS42L42_EQ_START_FILT:\n\tcase CS42L42_EQ_MUTE_CTL:\n\tcase CS42L42_SP_RX_CH_SEL:\n\tcase CS42L42_SP_RX_ISOC_CTL:\n\tcase CS42L42_SP_RX_FS:\n\tcase CS42l42_SPDIF_CH_SEL:\n\tcase CS42L42_SP_TX_ISOC_CTL:\n\tcase CS42L42_SP_TX_FS:\n\tcase CS42L42_SPDIF_SW_CTL1:\n\tcase CS42L42_SRC_SDIN_FS:\n\tcase CS42L42_SRC_SDOUT_FS:\n\tcase CS42L42_SOFT_RESET_REBOOT:\n\tcase CS42L42_SPDIF_CTL1:\n\tcase CS42L42_SPDIF_CTL2:\n\tcase CS42L42_SPDIF_CTL3:\n\tcase CS42L42_SPDIF_CTL4:\n\tcase CS42L42_ASP_TX_SZ_EN:\n\tcase CS42L42_ASP_TX_CH_EN:\n\tcase CS42L42_ASP_TX_CH_AP_RES:\n\tcase CS42L42_ASP_TX_CH1_BIT_MSB:\n\tcase CS42L42_ASP_TX_CH1_BIT_LSB:\n\tcase CS42L42_ASP_TX_HIZ_DLY_CFG:\n\tcase CS42L42_ASP_TX_CH2_BIT_MSB:\n\tcase CS42L42_ASP_TX_CH2_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI0_EN:\n\tcase CS42L42_ASP_RX_DAI0_CH1_AP_RES:\n\tcase CS42L42_ASP_RX_DAI0_CH1_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI0_CH1_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI0_CH2_AP_RES:\n\tcase CS42L42_ASP_RX_DAI0_CH2_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI0_CH2_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI0_CH3_AP_RES:\n\tcase CS42L42_ASP_RX_DAI0_CH3_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI0_CH3_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI0_CH4_AP_RES:\n\tcase CS42L42_ASP_RX_DAI0_CH4_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI0_CH4_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI1_CH1_AP_RES:\n\tcase CS42L42_ASP_RX_DAI1_CH1_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI1_CH1_BIT_LSB:\n\tcase CS42L42_ASP_RX_DAI1_CH2_AP_RES:\n\tcase CS42L42_ASP_RX_DAI1_CH2_BIT_MSB:\n\tcase CS42L42_ASP_RX_DAI1_CH2_BIT_LSB:\n\tcase CS42L42_SUB_REVID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_readable_register, SND_SOC_CS42L42_CORE);\n\nbool cs42l42_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L42_DEVID_AB:\n\tcase CS42L42_DEVID_CD:\n\tcase CS42L42_DEVID_E:\n\tcase CS42L42_MCLK_STATUS:\n\tcase CS42L42_OSC_SWITCH_STATUS:\n\tcase CS42L42_TRSENSE_STATUS:\n\tcase CS42L42_HS_DET_STATUS:\n\tcase CS42L42_ADC_OVFL_STATUS:\n\tcase CS42L42_MIXER_STATUS:\n\tcase CS42L42_SRC_STATUS:\n\tcase CS42L42_ASP_RX_STATUS:\n\tcase CS42L42_ASP_TX_STATUS:\n\tcase CS42L42_CODEC_STATUS:\n\tcase CS42L42_DET_INT_STATUS1:\n\tcase CS42L42_DET_INT_STATUS2:\n\tcase CS42L42_SRCPL_INT_STATUS:\n\tcase CS42L42_VPMON_STATUS:\n\tcase CS42L42_PLL_LOCK_STATUS:\n\tcase CS42L42_TSRS_PLUG_STATUS:\n\tcase CS42L42_LOAD_DET_RCSTAT:\n\tcase CS42L42_LOAD_DET_DONE:\n\tcase CS42L42_DET_STATUS1:\n\tcase CS42L42_DET_STATUS2:\n\tcase CS42L42_SOFT_RESET_REBOOT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_volatile_register, SND_SOC_CS42L42_CORE);\n\nconst struct regmap_range_cfg cs42l42_page_range = {\n\t.name = \"Pages\",\n\t.range_min = 0,\n\t.range_max = CS42L42_MAX_REGISTER,\n\t.selector_reg = CS42L42_PAGE_REGISTER,\n\t.selector_mask = 0xff,\n\t.selector_shift = 0,\n\t.window_start = 0,\n\t.window_len = 256,\n};\nEXPORT_SYMBOL_NS_GPL(cs42l42_page_range, SND_SOC_CS42L42_CORE);\n\nconst struct regmap_config cs42l42_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.readable_reg = cs42l42_readable_register,\n\t.volatile_reg = cs42l42_volatile_register,\n\n\t.ranges = &cs42l42_page_range,\n\t.num_ranges = 1,\n\n\t.max_register = CS42L42_MAX_REGISTER,\n\t.reg_defaults = cs42l42_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs42l42_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\nEXPORT_SYMBOL_NS_GPL(cs42l42_regmap, SND_SOC_CS42L42_CORE);\n\nstatic DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 100, true);\nstatic DECLARE_TLV_DB_SCALE(mixer_tlv, -6300, 100, true);\n\nstatic int cs42l42_slow_start_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tu8 val;\n\n\t \n\tswitch (ucontrol->value.integer.value[0]) {\n\tcase 0:\n\t\tval = 0;\n\t\tbreak;\n\tcase 1:\n\t\tval = CS42L42_SLOW_START_EN_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_component_update_bits(component, CS42L42_SLOW_START_ENABLE,\n\t\t\t\t\t     CS42L42_SLOW_START_EN_MASK, val);\n}\n\nstatic const char * const cs42l42_hpf_freq_text[] = {\n\t\"1.86Hz\", \"120Hz\", \"235Hz\", \"466Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(cs42l42_hpf_freq_enum, CS42L42_ADC_WNF_HPF_CTL,\n\t\t\t    CS42L42_ADC_HPF_CF_SHIFT,\n\t\t\t    cs42l42_hpf_freq_text);\n\nstatic const char * const cs42l42_wnf3_freq_text[] = {\n\t\"160Hz\", \"180Hz\", \"200Hz\", \"220Hz\",\n\t\"240Hz\", \"260Hz\", \"280Hz\", \"300Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(cs42l42_wnf3_freq_enum, CS42L42_ADC_WNF_HPF_CTL,\n\t\t\t    CS42L42_ADC_WNF_CF_SHIFT,\n\t\t\t    cs42l42_wnf3_freq_text);\n\nstatic const struct snd_kcontrol_new cs42l42_snd_controls[] = {\n\t \n\tSOC_SINGLE(\"ADC Notch Switch\", CS42L42_ADC_CTL,\n\t\t\t\tCS42L42_ADC_NOTCH_DIS_SHIFT, true, true),\n\tSOC_SINGLE(\"ADC Weak Force Switch\", CS42L42_ADC_CTL,\n\t\t\t\tCS42L42_ADC_FORCE_WEAK_VCM_SHIFT, true, false),\n\tSOC_SINGLE(\"ADC Invert Switch\", CS42L42_ADC_CTL,\n\t\t\t\tCS42L42_ADC_INV_SHIFT, true, false),\n\tSOC_SINGLE(\"ADC Boost Switch\", CS42L42_ADC_CTL,\n\t\t\t\tCS42L42_ADC_DIG_BOOST_SHIFT, true, false),\n\tSOC_SINGLE_S8_TLV(\"ADC Volume\", CS42L42_ADC_VOLUME, -97, 12, adc_tlv),\n\tSOC_SINGLE(\"ADC WNF Switch\", CS42L42_ADC_WNF_HPF_CTL,\n\t\t\t\tCS42L42_ADC_WNF_EN_SHIFT, true, false),\n\tSOC_SINGLE(\"ADC HPF Switch\", CS42L42_ADC_WNF_HPF_CTL,\n\t\t\t\tCS42L42_ADC_HPF_EN_SHIFT, true, false),\n\tSOC_ENUM(\"HPF Corner Freq\", cs42l42_hpf_freq_enum),\n\tSOC_ENUM(\"WNF 3dB Freq\", cs42l42_wnf3_freq_enum),\n\n\t \n\tSOC_SINGLE(\"DACA Invert Switch\", CS42L42_DAC_CTL1,\n\t\t\t\tCS42L42_DACA_INV_SHIFT, true, false),\n\tSOC_SINGLE(\"DACB Invert Switch\", CS42L42_DAC_CTL1,\n\t\t\t\tCS42L42_DACB_INV_SHIFT, true, false),\n\tSOC_SINGLE(\"DAC HPF Switch\", CS42L42_DAC_CTL2,\n\t\t\t\tCS42L42_DAC_HPF_EN_SHIFT, true, false),\n\tSOC_DOUBLE_R_TLV(\"Mixer Volume\", CS42L42_MIXER_CHA_VOL,\n\t\t\t CS42L42_MIXER_CHB_VOL, CS42L42_MIXER_CH_VOL_SHIFT,\n\t\t\t\t0x3f, 1, mixer_tlv),\n\n\tSOC_SINGLE_EXT(\"Slow Start Switch\", CS42L42_SLOW_START_ENABLE,\n\t\t\tCS42L42_SLOW_START_EN_SHIFT, true, false,\n\t\t\tsnd_soc_get_volsw, cs42l42_slow_start_put),\n};\n\nstatic int cs42l42_hp_adc_ev(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tcs42l42->hp_adc_up_pending = true;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tif (cs42l42->hp_adc_up_pending) {\n\t\t\tusleep_range(CS42L42_HP_ADC_EN_TIME_US,\n\t\t\t\t     CS42L42_HP_ADC_EN_TIME_US + 1000);\n\t\t\tcs42l42->hp_adc_up_pending = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs42l42_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HP\"),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, CS42L42_PWR_CTL1, CS42L42_HP_PDN_SHIFT, 1,\n\t\t\t   cs42l42_hp_adc_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_MIXER(\"MIXER\", CS42L42_PWR_CTL1, CS42L42_MIXER_PDN_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDIN1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDIN2\", NULL, 1, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"ASP DAI0\", CS42L42_PWR_CTL1, CS42L42_ASP_DAI_PDN_SHIFT, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"HS\"),\n\tSND_SOC_DAPM_ADC_E(\"ADC\", NULL, CS42L42_PWR_CTL1, CS42L42_ADC_PDN_SHIFT, 1,\n\t\t\t   cs42l42_hp_adc_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT1\", NULL, 0, CS42L42_ASP_TX_CH_EN, CS42L42_ASP_TX0_CH1_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT2\", NULL, 1, CS42L42_ASP_TX_CH_EN, CS42L42_ASP_TX0_CH2_SHIFT, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"ASP DAO0\", CS42L42_PWR_CTL1, CS42L42_ASP_DAO_PDN_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ASP TX EN\", CS42L42_ASP_TX_SZ_EN, CS42L42_ASP_TX_EN_SHIFT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"SCLK\", CS42L42_ASP_CLK_CFG, CS42L42_ASP_SCLK_EN_SHIFT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA(\"DACSRC\", CS42L42_PWR_CTL2, CS42L42_DAC_SRC_PDNB_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADCSRC\", CS42L42_PWR_CTL2, CS42L42_ADC_SRC_PDNB_SHIFT, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route cs42l42_audio_map[] = {\n\t \n\t{\"HP\", NULL, \"DAC\"},\n\t{\"DAC\", NULL, \"MIXER\"},\n\t{\"MIXER\", NULL, \"SDIN1\"},\n\t{\"MIXER\", NULL, \"SDIN2\"},\n\t{\"SDIN1\", NULL, \"Playback\"},\n\t{\"SDIN2\", NULL, \"Playback\"},\n\n\t \n\t{\"SDIN1\", NULL, \"ASP DAI0\"},\n\t{\"SDIN2\", NULL, \"ASP DAI0\"},\n\t{\"SDIN1\", NULL, \"SCLK\"},\n\t{\"SDIN2\", NULL, \"SCLK\"},\n\n\t \n\t{\"ADC\", NULL, \"HS\"},\n\t{ \"SDOUT1\", NULL, \"ADC\" },\n\t{ \"SDOUT2\", NULL, \"ADC\" },\n\t{ \"Capture\", NULL, \"SDOUT1\" },\n\t{ \"Capture\", NULL, \"SDOUT2\" },\n\n\t \n\t{ \"SDOUT1\", NULL, \"ASP DAO0\" },\n\t{ \"SDOUT2\", NULL, \"ASP DAO0\" },\n\t{ \"SDOUT1\", NULL, \"SCLK\" },\n\t{ \"SDOUT2\", NULL, \"SCLK\" },\n\t{ \"SDOUT1\", NULL, \"ASP TX EN\" },\n\t{ \"SDOUT2\", NULL, \"ASP TX EN\" },\n};\n\nstatic int cs42l42_set_jack(struct snd_soc_component *component, struct snd_soc_jack *jk, void *d)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\n\t \n\tmutex_lock(&cs42l42->irq_lock);\n\tcs42l42->jack = jk;\n\n\tif (jk) {\n\t\tswitch (cs42l42->hs_type) {\n\t\tcase CS42L42_PLUG_CTIA:\n\t\tcase CS42L42_PLUG_OMTP:\n\t\t\tsnd_soc_jack_report(jk, SND_JACK_HEADSET, SND_JACK_HEADSET);\n\t\t\tbreak;\n\t\tcase CS42L42_PLUG_HEADPHONE:\n\t\t\tsnd_soc_jack_report(jk, SND_JACK_HEADPHONE, SND_JACK_HEADPHONE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&cs42l42->irq_lock);\n\n\treturn 0;\n}\n\nconst struct snd_soc_component_driver cs42l42_soc_component = {\n\t.set_jack\t\t= cs42l42_set_jack,\n\t.dapm_widgets\t\t= cs42l42_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42l42_dapm_widgets),\n\t.dapm_routes\t\t= cs42l42_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42l42_audio_map),\n\t.controls\t\t= cs42l42_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42l42_snd_controls),\n\t.endianness\t\t= 1,\n};\nEXPORT_SYMBOL_NS_GPL(cs42l42_soc_component, SND_SOC_CS42L42_CORE);\n\n \nstatic const struct reg_sequence cs42l42_to_sclk_seq[] = {\n\t{\n\t\t.reg = CS42L42_OSC_SWITCH,\n\t\t.def = CS42L42_SCLK_PRESENT_MASK,\n\t\t.delay_us = CS42L42_CLOCK_SWITCH_DELAY_US,\n\t},\n};\n\n \nstatic const struct reg_sequence cs42l42_to_osc_seq[] = {\n\t{\n\t\t.reg = CS42L42_OSC_SWITCH,\n\t\t.def = 0,\n\t\t.delay_us = CS42L42_CLOCK_SWITCH_DELAY_US,\n\t},\n};\n\nstruct cs42l42_pll_params {\n\tu32 sclk;\n\tu8 mclk_src_sel;\n\tu8 sclk_prediv;\n\tu8 pll_div_int;\n\tu32 pll_div_frac;\n\tu8 pll_mode;\n\tu8 pll_divout;\n\tu32 mclk_int;\n\tu8 pll_cal_ratio;\n\tu8 n;\n};\n\n \nstatic const struct cs42l42_pll_params pll_ratio_table[] = {\n\t{ 1411200,  1, 0x00, 0x80, 0x000000, 0x03, 0x10, 11289600, 128, 2},\n\t{ 1536000,  1, 0x00, 0x7D, 0x000000, 0x03, 0x10, 12000000, 125, 2},\n\t{ 2304000,  1, 0x00, 0x55, 0xC00000, 0x02, 0x10, 12288000,  85, 2},\n\t{ 2400000,  1, 0x00, 0x50, 0x000000, 0x03, 0x10, 12000000,  80, 2},\n\t{ 2822400,  1, 0x00, 0x40, 0x000000, 0x03, 0x10, 11289600, 128, 1},\n\t{ 3000000,  1, 0x00, 0x40, 0x000000, 0x03, 0x10, 12000000, 128, 1},\n\t{ 3072000,  1, 0x00, 0x3E, 0x800000, 0x03, 0x10, 12000000, 125, 1},\n\t{ 4000000,  1, 0x00, 0x30, 0x800000, 0x03, 0x10, 12000000,  96, 1},\n\t{ 4096000,  1, 0x00, 0x2E, 0xE00000, 0x03, 0x10, 12000000,  94, 1},\n\t{ 4800000,  1, 0x01, 0x50, 0x000000, 0x03, 0x10, 12000000,  80, 2},\n\t{ 4800000,  1, 0x01, 0x50, 0x000000, 0x01, 0x10, 12288000,  82, 2},\n\t{ 5644800,  1, 0x01, 0x40, 0x000000, 0x03, 0x10, 11289600, 128, 1},\n\t{ 6000000,  1, 0x01, 0x40, 0x000000, 0x03, 0x10, 12000000, 128, 1},\n\t{ 6144000,  1, 0x01, 0x3E, 0x800000, 0x03, 0x10, 12000000, 125, 1},\n\t{ 6144000,  1, 0x01, 0x40, 0x000000, 0x03, 0x10, 12288000, 128, 1},\n\t{ 9600000,  1, 0x02, 0x50, 0x000000, 0x03, 0x10, 12000000,  80, 2},\n\t{ 9600000,  1, 0x02, 0x50, 0x000000, 0x01, 0x10, 12288000,  82, 2},\n\t{ 11289600, 0, 0, 0, 0, 0, 0, 11289600, 0, 1},\n\t{ 12000000, 0, 0, 0, 0, 0, 0, 12000000, 0, 1},\n\t{ 12288000, 0, 0, 0, 0, 0, 0, 12288000, 0, 1},\n\t{ 19200000, 1, 0x03, 0x50, 0x000000, 0x03, 0x10, 12000000,  80, 2},\n\t{ 19200000, 1, 0x03, 0x50, 0x000000, 0x01, 0x10, 12288000,  82, 2},\n\t{ 22579200, 1, 0x03, 0x40, 0x000000, 0x03, 0x10, 11289600, 128, 1},\n\t{ 24000000, 1, 0x03, 0x40, 0x000000, 0x03, 0x10, 12000000, 128, 1},\n\t{ 24576000, 1, 0x03, 0x40, 0x000000, 0x03, 0x10, 12288000, 128, 1}\n};\n\nint cs42l42_pll_config(struct snd_soc_component *component, unsigned int clk,\n\t\t       unsigned int sample_rate)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\t \n\tif (cs42l42->stream_use) {\n\t\tif (pll_ratio_table[cs42l42->pll_config].sclk == clk)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_ratio_table); i++) {\n\t\t \n\t\tif (pll_ratio_table[i].mclk_int % sample_rate)\n\t\t\tcontinue;\n\n\t\tif (pll_ratio_table[i].sclk == clk) {\n\t\t\tcs42l42->pll_config = i;\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, CS42L42_MCLK_CTL,\n\t\t\t\t\tCS42L42_INTERNAL_FS_MASK,\n\t\t\t\t\t((pll_ratio_table[i].mclk_int !=\n\t\t\t\t\t12000000) &&\n\t\t\t\t\t(pll_ratio_table[i].mclk_int !=\n\t\t\t\t\t24000000)) <<\n\t\t\t\t\tCS42L42_INTERNAL_FS_SHIFT);\n\t\t\tif (pll_ratio_table[i].mclk_src_sel == 0) {\n\t\t\t\t \n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_CTL1,\n\t\t\t\t\tCS42L42_PLL_START_MASK,\t0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_DIV_CFG1,\n\t\t\t\t\tCS42L42_SCLK_PREDIV_MASK,\n\t\t\t\t\tpll_ratio_table[i].sclk_prediv\n\t\t\t\t\t<< CS42L42_SCLK_PREDIV_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_DIV_INT,\n\t\t\t\t\tCS42L42_PLL_DIV_INT_MASK,\n\t\t\t\t\tpll_ratio_table[i].pll_div_int\n\t\t\t\t\t<< CS42L42_PLL_DIV_INT_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC0,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC_MASK,\n\t\t\t\t\tCS42L42_FRAC0_VAL(\n\t\t\t\t\tpll_ratio_table[i].pll_div_frac)\n\t\t\t\t\t<< CS42L42_PLL_DIV_FRAC_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC1,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC_MASK,\n\t\t\t\t\tCS42L42_FRAC1_VAL(\n\t\t\t\t\tpll_ratio_table[i].pll_div_frac)\n\t\t\t\t\t<< CS42L42_PLL_DIV_FRAC_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC2,\n\t\t\t\t\tCS42L42_PLL_DIV_FRAC_MASK,\n\t\t\t\t\tCS42L42_FRAC2_VAL(\n\t\t\t\t\tpll_ratio_table[i].pll_div_frac)\n\t\t\t\t\t<< CS42L42_PLL_DIV_FRAC_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_CTL4,\n\t\t\t\t\tCS42L42_PLL_MODE_MASK,\n\t\t\t\t\tpll_ratio_table[i].pll_mode\n\t\t\t\t\t<< CS42L42_PLL_MODE_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_CTL3,\n\t\t\t\t\tCS42L42_PLL_DIVOUT_MASK,\n\t\t\t\t\t(pll_ratio_table[i].pll_divout * pll_ratio_table[i].n)\n\t\t\t\t\t<< CS42L42_PLL_DIVOUT_SHIFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tCS42L42_PLL_CAL_RATIO,\n\t\t\t\t\tCS42L42_PLL_CAL_RATIO_MASK,\n\t\t\t\t\tpll_ratio_table[i].pll_cal_ratio\n\t\t\t\t\t<< CS42L42_PLL_CAL_RATIO_SHIFT);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_pll_config, SND_SOC_CS42L42_CORE);\n\nvoid cs42l42_src_config(struct snd_soc_component *component, unsigned int sample_rate)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\tunsigned int fs;\n\n\t \n\tif (cs42l42->stream_use)\n\t\treturn;\n\n\t \n\tif (sample_rate <= 48000)\n\t\tfs = CS42L42_CLK_IASRC_SEL_6;\n\telse\n\t\tfs = CS42L42_CLK_IASRC_SEL_12;\n\n\t \n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_FS_RATE_EN,\n\t\t\t\t      CS42L42_FS_EN_MASK,\n\t\t\t\t      (CS42L42_FS_EN_IASRC_96K |\n\t\t\t\t       CS42L42_FS_EN_OASRC_96K) <<\n\t\t\t\t      CS42L42_FS_EN_SHIFT);\n\n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_IN_ASRC_CLK,\n\t\t\t\t      CS42L42_CLK_IASRC_SEL_MASK,\n\t\t\t\t      fs << CS42L42_CLK_IASRC_SEL_SHIFT);\n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_OUT_ASRC_CLK,\n\t\t\t\t      CS42L42_CLK_OASRC_SEL_MASK,\n\t\t\t\t      fs << CS42L42_CLK_OASRC_SEL_SHIFT);\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_src_config, SND_SOC_CS42L42_CORE);\n\nstatic int cs42l42_asp_config(struct snd_soc_component *component,\n\t\t\t      unsigned int sclk, unsigned int sample_rate)\n{\n\tu32 fsync = sclk / sample_rate;\n\n\t \n\tif (((fsync * sample_rate) != sclk) || ((fsync % 2) != 0)) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unsupported sclk %d/sample rate %d\\n\",\n\t\t\tsclk,\n\t\t\tsample_rate);\n\t\treturn -EINVAL;\n\t}\n\t \n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_FSYNC_P_LOWER,\n\t\t\t\t      CS42L42_FSYNC_PERIOD_MASK,\n\t\t\t\t      CS42L42_FRAC0_VAL(fsync - 1) <<\n\t\t\t\t      CS42L42_FSYNC_PERIOD_SHIFT);\n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_FSYNC_P_UPPER,\n\t\t\t\t      CS42L42_FSYNC_PERIOD_MASK,\n\t\t\t\t      CS42L42_FRAC1_VAL(fsync - 1) <<\n\t\t\t\t      CS42L42_FSYNC_PERIOD_SHIFT);\n\t \n\tfsync = fsync / 2;\n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_FSYNC_PW_LOWER,\n\t\t\t\t      CS42L42_FSYNC_PULSE_WIDTH_MASK,\n\t\t\t\t      CS42L42_FRAC0_VAL(fsync - 1) <<\n\t\t\t\t      CS42L42_FSYNC_PULSE_WIDTH_SHIFT);\n\tsnd_soc_component_update_bits(component,\n\t\t\t\t      CS42L42_FSYNC_PW_UPPER,\n\t\t\t\t      CS42L42_FSYNC_PULSE_WIDTH_MASK,\n\t\t\t\t      CS42L42_FRAC1_VAL(fsync - 1) <<\n\t\t\t\t      CS42L42_FSYNC_PULSE_WIDTH_SHIFT);\n\n\treturn 0;\n}\n\nstatic int cs42l42_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu32 asp_cfg_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\tasp_cfg_val |= CS42L42_ASP_MASTER_MODE <<\n\t\t\t\tCS42L42_ASP_MODE_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tasp_cfg_val |= CS42L42_ASP_SLAVE_MODE <<\n\t\t\t\tCS42L42_ASP_MODE_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t      CS42L42_ASP_FRM_CFG,\n\t\t\t\t\t      CS42L42_ASP_STP_MASK |\n\t\t\t\t\t      CS42L42_ASP_5050_MASK |\n\t\t\t\t\t      CS42L42_ASP_FSD_MASK,\n\t\t\t\t\t      CS42L42_ASP_5050_MASK |\n\t\t\t\t\t      (CS42L42_ASP_FSD_1_0 <<\n\t\t\t\t\t\tCS42L42_ASP_FSD_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tasp_cfg_val |= CS42L42_ASP_SCPOL_NOR << CS42L42_ASP_SCPOL_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tasp_cfg_val |= CS42L42_ASP_SCPOL_NOR << CS42L42_ASP_SCPOL_SHIFT;\n\t\tasp_cfg_val |= CS42L42_ASP_LCPOL_INV << CS42L42_ASP_LCPOL_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tasp_cfg_val |= CS42L42_ASP_LCPOL_INV << CS42L42_ASP_LCPOL_SHIFT;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_update_bits(component, CS42L42_ASP_CLK_CFG, CS42L42_ASP_MODE_MASK |\n\t\t\t\t\t\t\t\t      CS42L42_ASP_SCPOL_MASK |\n\t\t\t\t\t\t\t\t      CS42L42_ASP_LCPOL_MASK,\n\t\t\t\t\t\t\t\t      asp_cfg_val);\n\n\treturn 0;\n}\n\nstatic int cs42l42_dai_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (cs42l42->sclk)\n\t\treturn 0;\n\n\t \n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    44100, 96000);\n}\n\nstatic int cs42l42_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\tunsigned int channels = params_channels(params);\n\tunsigned int width = (params_width(params) / 8) - 1;\n\tunsigned int sample_rate = params_rate(params);\n\tunsigned int slot_width = 0;\n\tunsigned int val = 0;\n\tunsigned int bclk;\n\tint ret;\n\n\tif (cs42l42->bclk_ratio) {\n\t\t \n\t\tbclk = cs42l42->bclk_ratio * params_rate(params);\n\t} else if (cs42l42->sclk) {\n\t\t \n\t\tbclk = cs42l42->sclk;\n\t} else {\n\t\t \n\t\tif (params_width(params) == 24)\n\t\t\tslot_width = 32;\n\n\t\t \n\t\tbclk = snd_soc_tdm_params_to_bclk(params, slot_width, 0, 2);\n\t}\n\n\tswitch (substream->stream) {\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\t \n\t\tval = CS42L42_ASP_TX_CH2_AP_MASK |\n\t\t      (width << CS42L42_ASP_TX_CH2_RES_SHIFT) |\n\t\t      (width << CS42L42_ASP_TX_CH1_RES_SHIFT);\n\n\t\tsnd_soc_component_update_bits(component, CS42L42_ASP_TX_CH_AP_RES,\n\t\t\t\tCS42L42_ASP_TX_CH1_AP_MASK | CS42L42_ASP_TX_CH2_AP_MASK |\n\t\t\t\tCS42L42_ASP_TX_CH2_RES_MASK | CS42L42_ASP_TX_CH1_RES_MASK, val);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tval |= width << CS42L42_ASP_RX_CH_RES_SHIFT;\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L42_ASP_RX_DAI0_CH1_AP_RES,\n\t\t\t\t\t\t\t CS42L42_ASP_RX_CH_AP_MASK |\n\t\t\t\t\t\t\t CS42L42_ASP_RX_CH_RES_MASK, val);\n\t\t \n\t\tval |= CS42L42_ASP_RX_CH_AP_HI << CS42L42_ASP_RX_CH_AP_SHIFT;\n\t\tsnd_soc_component_update_bits(component, CS42L42_ASP_RX_DAI0_CH2_AP_RES,\n\t\t\t\t\t\t\t CS42L42_ASP_RX_CH_AP_MASK |\n\t\t\t\t\t\t\t CS42L42_ASP_RX_CH_RES_MASK, val);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L42_SP_RX_CH_SEL,\n\t\t\t\t\t      CS42L42_SP_RX_CHB_SEL_MASK,\n\t\t\t\t\t      (channels - 1) << CS42L42_SP_RX_CHB_SEL_SHIFT);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L42_ASP_RX_DAI0_EN,\n\t\t\t\t\t      CS42L42_ASP_RX0_CH_EN_MASK,\n\t\t\t\t\t      BIT(CS42L42_ASP_RX0_CH1_SHIFT) |\n\t\t\t\t\t      BIT(CS42L42_ASP_RX0_CH2_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = cs42l42_pll_config(component, bclk, sample_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cs42l42_asp_config(component, bclk, sample_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tcs42l42_src_config(component, sample_rate);\n\n\treturn 0;\n}\n\nstatic int cs42l42_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tif (freq == 0) {\n\t\tcs42l42->sclk = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_ratio_table); i++) {\n\t\tif (pll_ratio_table[i].sclk == freq) {\n\t\t\tcs42l42->sclk = freq;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(component->dev, \"SCLK %u not supported\\n\", freq);\n\n\treturn -EINVAL;\n}\n\nstatic int cs42l42_set_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int bclk_ratio)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\n\tcs42l42->bclk_ratio = bclk_ratio;\n\n\treturn 0;\n}\n\nint cs42l42_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(component);\n\tunsigned int regval;\n\tint ret;\n\n\tif (mute) {\n\t\t \n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsnd_soc_component_update_bits(component, CS42L42_HP_CTL,\n\t\t\t\t\t\t      CS42L42_HP_ANA_AMUTE_MASK |\n\t\t\t\t\t\t      CS42L42_HP_ANA_BMUTE_MASK,\n\t\t\t\t\t\t      CS42L42_HP_ANA_AMUTE_MASK |\n\t\t\t\t\t\t      CS42L42_HP_ANA_BMUTE_MASK);\n\n\t\tcs42l42->stream_use &= ~(1 << stream);\n\t\tif (!cs42l42->stream_use) {\n\t\t\t \n\t\t\tregmap_multi_reg_write(cs42l42->regmap, cs42l42_to_osc_seq,\n\t\t\t\t\t       ARRAY_SIZE(cs42l42_to_osc_seq));\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t      CS42L42_MCLK_SRC_SEL,\n\t\t\t\t\t\t      CS42L42_MCLK_SRC_SEL_MASK,\n\t\t\t\t\t\t      0);\n\t\t\tusleep_range(100, 200);\n\n\t\t\tsnd_soc_component_update_bits(component, CS42L42_PLL_CTL1,\n\t\t\t\t\t\t      CS42L42_PLL_START_MASK, 0);\n\t\t}\n\t} else {\n\t\tif (!cs42l42->stream_use) {\n\t\t\t \n\t\t\tif (pll_ratio_table[cs42l42->pll_config].mclk_src_sel) {\n\t\t\t\tsnd_soc_component_update_bits(component, CS42L42_PLL_CTL1,\n\t\t\t\t\t\t\t      CS42L42_PLL_START_MASK, 1);\n\n\t\t\t\tif (pll_ratio_table[cs42l42->pll_config].n > 1) {\n\t\t\t\t\tusleep_range(CS42L42_PLL_DIVOUT_TIME_US,\n\t\t\t\t\t\t     CS42L42_PLL_DIVOUT_TIME_US * 2);\n\t\t\t\t\tregval = pll_ratio_table[cs42l42->pll_config].pll_divout;\n\t\t\t\t\tsnd_soc_component_update_bits(component, CS42L42_PLL_CTL3,\n\t\t\t\t\t\t\t\t      CS42L42_PLL_DIVOUT_MASK,\n\t\t\t\t\t\t\t\t      regval <<\n\t\t\t\t\t\t\t\t      CS42L42_PLL_DIVOUT_SHIFT);\n\t\t\t\t}\n\n\t\t\t\tret = regmap_read_poll_timeout(cs42l42->regmap,\n\t\t\t\t\t\t\t       CS42L42_PLL_LOCK_STATUS,\n\t\t\t\t\t\t\t       regval,\n\t\t\t\t\t\t\t       (regval & 1),\n\t\t\t\t\t\t\t       CS42L42_PLL_LOCK_POLL_US,\n\t\t\t\t\t\t\t       CS42L42_PLL_LOCK_TIMEOUT_US);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tdev_warn(component->dev, \"PLL failed to lock: %d\\n\", ret);\n\n\t\t\t\t \n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t\t      CS42L42_MCLK_SRC_SEL,\n\t\t\t\t\t\t\t      CS42L42_MCLK_SRC_SEL_MASK,\n\t\t\t\t\t\t\t      CS42L42_MCLK_SRC_SEL_MASK);\n\t\t\t}\n\n\t\t\t \n\t\t\tregmap_multi_reg_write(cs42l42->regmap, cs42l42_to_sclk_seq,\n\t\t\t\t\t       ARRAY_SIZE(cs42l42_to_sclk_seq));\n\t\t}\n\t\tcs42l42->stream_use |= 1 << stream;\n\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, CS42L42_HP_CTL,\n\t\t\t\t\t\t      CS42L42_HP_ANA_AMUTE_MASK |\n\t\t\t\t\t\t      CS42L42_HP_ANA_BMUTE_MASK,\n\t\t\t\t\t\t      0);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_mute_stream, SND_SOC_CS42L42_CORE);\n\n#define CS42L42_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops cs42l42_ops = {\n\t.startup\t= cs42l42_dai_startup,\n\t.hw_params\t= cs42l42_pcm_hw_params,\n\t.set_fmt\t= cs42l42_set_dai_fmt,\n\t.set_sysclk\t= cs42l42_set_sysclk,\n\t.set_bclk_ratio\t= cs42l42_set_bclk_ratio,\n\t.mute_stream\t= cs42l42_mute_stream,\n};\n\nstruct snd_soc_dai_driver cs42l42_dai = {\n\t\t.name = \"cs42l42\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = CS42L42_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = CS42L42_FORMATS,\n\t\t},\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_sample_bits = 1,\n\t\t.ops = &cs42l42_ops,\n};\nEXPORT_SYMBOL_NS_GPL(cs42l42_dai, SND_SOC_CS42L42_CORE);\n\nstatic void cs42l42_manual_hs_type_detect(struct cs42l42_private *cs42l42)\n{\n\tunsigned int hs_det_status;\n\tunsigned int hs_det_comp1;\n\tunsigned int hs_det_comp2;\n\tunsigned int hs_det_sw;\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_HSDET_CTL2,\n\t\tCS42L42_HSDET_CTRL_MASK |\n\t\tCS42L42_HSDET_SET_MASK |\n\t\tCS42L42_HSBIAS_REF_MASK |\n\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t(1 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t(0 << CS42L42_HSDET_SET_SHIFT) |\n\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t(0 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSDET_CTL1,\n\t\t\t\tCS42L42_HSDET_COMP1_LVL_MASK |\n\t\t\t\tCS42L42_HSDET_COMP2_LVL_MASK,\n\t\t\t\t(CS42L42_HSDET_COMP1_LVL_VAL << CS42L42_HSDET_COMP1_LVL_SHIFT) |\n\t\t\t\t(CS42L42_HSDET_COMP2_LVL_VAL << CS42L42_HSDET_COMP2_LVL_SHIFT));\n\n\t \n\tregmap_write(cs42l42->regmap, CS42L42_HS_SWITCH_CTL, CS42L42_HSDET_SW_COMP1);\n\n\tmsleep(100);\n\n\tregmap_read(cs42l42->regmap, CS42L42_HS_DET_STATUS, &hs_det_status);\n\n\ths_det_comp1 = (hs_det_status & CS42L42_HSDET_COMP1_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP1_OUT_SHIFT;\n\ths_det_comp2 = (hs_det_status & CS42L42_HSDET_COMP2_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP2_OUT_SHIFT;\n\n\t \n\tregmap_write(cs42l42->regmap, CS42L42_HS_SWITCH_CTL, CS42L42_HSDET_SW_COMP2);\n\n\tmsleep(100);\n\n\tregmap_read(cs42l42->regmap, CS42L42_HS_DET_STATUS, &hs_det_status);\n\n\ths_det_comp1 |= ((hs_det_status & CS42L42_HSDET_COMP1_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP1_OUT_SHIFT) << 1;\n\ths_det_comp2 |= ((hs_det_status & CS42L42_HSDET_COMP2_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP2_OUT_SHIFT) << 1;\n\n\t \n\tswitch (hs_det_comp1) {\n\tcase CS42L42_HSDET_COMP_TYPE1:\n\t\tcs42l42->hs_type = CS42L42_PLUG_CTIA;\n\t\ths_det_sw = CS42L42_HSDET_SW_TYPE1;\n\t\tbreak;\n\tcase CS42L42_HSDET_COMP_TYPE2:\n\t\tcs42l42->hs_type = CS42L42_PLUG_OMTP;\n\t\ths_det_sw = CS42L42_HSDET_SW_TYPE2;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tswitch (hs_det_comp2) {\n\t\tcase CS42L42_HSDET_COMP_TYPE1:\n\t\t\tcs42l42->hs_type = CS42L42_PLUG_CTIA;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE1;\n\t\t\tbreak;\n\t\tcase CS42L42_HSDET_COMP_TYPE2:\n\t\t\tcs42l42->hs_type = CS42L42_PLUG_OMTP;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE2;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tcs42l42->hs_type = CS42L42_PLUG_HEADPHONE;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE3;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tregmap_write(cs42l42->regmap, CS42L42_HS_SWITCH_CTL, hs_det_sw);\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_HSDET_CTL2,\n\t\tCS42L42_HSDET_CTRL_MASK |\n\t\tCS42L42_HSDET_SET_MASK |\n\t\tCS42L42_HSBIAS_REF_MASK |\n\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t(0 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t(0 << CS42L42_HSDET_SET_SHIFT) |\n\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t(0 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSDET_CTL1,\n\t\t\t\tCS42L42_HSDET_COMP1_LVL_MASK |\n\t\t\t\tCS42L42_HSDET_COMP2_LVL_MASK,\n\t\t\t\t(CS42L42_HSDET_COMP1_LVL_DEFAULT << CS42L42_HSDET_COMP1_LVL_SHIFT) |\n\t\t\t\t(CS42L42_HSDET_COMP2_LVL_DEFAULT << CS42L42_HSDET_COMP2_LVL_SHIFT));\n}\n\nstatic void cs42l42_process_hs_type_detect(struct cs42l42_private *cs42l42)\n{\n\tunsigned int hs_det_status;\n\tunsigned int int_status;\n\n\t \n\tregmap_read(cs42l42->regmap, CS42L42_HS_DET_STATUS, &hs_det_status);\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_CODEC_INT_MASK,\n\t\tCS42L42_PDN_DONE_MASK |\n\t\tCS42L42_HSDET_AUTO_DONE_MASK,\n\t\t(1 << CS42L42_PDN_DONE_SHIFT) |\n\t\t(1 << CS42L42_HSDET_AUTO_DONE_SHIFT));\n\n\n\tcs42l42->hs_type = (hs_det_status & CS42L42_HSDET_TYPE_MASK) >>\n\t\t\t\tCS42L42_HSDET_TYPE_SHIFT;\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_HSDET_CTL2,\n\t\tCS42L42_HSDET_CTRL_MASK |\n\t\tCS42L42_HSDET_SET_MASK |\n\t\tCS42L42_HSBIAS_REF_MASK |\n\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t(2 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t(2 << CS42L42_HSDET_SET_SHIFT) |\n\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t \n\tif (cs42l42->hs_type == CS42L42_PLUG_INVALID ||\n\t\tcs42l42->hs_type == CS42L42_PLUG_HEADPHONE) {\n\t\tdev_dbg(cs42l42->dev, \"Running Manual Detection Fallback\\n\");\n\t\tcs42l42_manual_hs_type_detect(cs42l42);\n\t}\n\n\t \n\tif ((cs42l42->hs_type == CS42L42_PLUG_CTIA) ||\n\t      (cs42l42->hs_type == CS42L42_PLUG_OMTP)) {\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_HSBIAS_SC_AUTOCTL,\n\t\t\tCS42L42_HSBIAS_SENSE_EN_MASK |\n\t\t\tCS42L42_AUTO_HSBIAS_HIZ_MASK |\n\t\t\tCS42L42_TIP_SENSE_EN_MASK |\n\t\t\tCS42L42_HSBIAS_SENSE_TRIP_MASK,\n\t\t\t(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\n\t\t\t(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\n\t\t\t(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\n\t\t\t(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\n\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_MIC_DET_CTL1,\n\t\t\tCS42L42_LATCH_TO_VP_MASK |\n\t\t\tCS42L42_EVENT_STAT_SEL_MASK |\n\t\t\tCS42L42_HS_DET_LEVEL_MASK,\n\t\t\t(1 << CS42L42_LATCH_TO_VP_SHIFT) |\n\t\t\t(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\n\t\t\t(cs42l42->bias_thresholds[0] <<\n\t\t\tCS42L42_HS_DET_LEVEL_SHIFT));\n\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_HSBIAS_SC_AUTOCTL,\n\t\t\tCS42L42_HSBIAS_SENSE_EN_MASK |\n\t\t\tCS42L42_AUTO_HSBIAS_HIZ_MASK |\n\t\t\tCS42L42_TIP_SENSE_EN_MASK |\n\t\t\tCS42L42_HSBIAS_SENSE_TRIP_MASK,\n\t\t\t(cs42l42->hs_bias_sense_en << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\n\t\t\t(1 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\n\t\t\t(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\n\t\t\t(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\n\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_MISC_DET_CTL,\n\t\t\tCS42L42_HSBIAS_CTL_MASK |\n\t\t\tCS42L42_PDN_MIC_LVL_DET_MASK,\n\t\t\t(3 << CS42L42_HSBIAS_CTL_SHIFT) |\n\t\t\t(0 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\n\n\t\tmsleep(cs42l42->btn_det_init_dbnce);\n\n\t\t \n\t\tregmap_read(cs42l42->regmap, CS42L42_DET_INT_STATUS2,\n\t\t\t    &int_status);\n\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_DET_INT2_MASK,\n\t\t\tCS42L42_M_DETECT_TF_MASK |\n\t\t\tCS42L42_M_DETECT_FT_MASK |\n\t\t\tCS42L42_M_HSBIAS_HIZ_MASK |\n\t\t\tCS42L42_M_SHORT_RLS_MASK |\n\t\t\tCS42L42_M_SHORT_DET_MASK,\n\t\t\t(0 << CS42L42_M_DETECT_TF_SHIFT) |\n\t\t\t(0 << CS42L42_M_DETECT_FT_SHIFT) |\n\t\t\t(0 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\n\t\t\t(1 << CS42L42_M_SHORT_RLS_SHIFT) |\n\t\t\t(1 << CS42L42_M_SHORT_DET_SHIFT));\n\t} else {\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_MISC_DET_CTL,\n\t\t\tCS42L42_HSBIAS_CTL_MASK |\n\t\t\tCS42L42_PDN_MIC_LVL_DET_MASK,\n\t\t\t(1 << CS42L42_HSBIAS_CTL_SHIFT) |\n\t\t\t(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\n\t}\n\n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_DAC_CTL2,\n\t\t\t\tCS42L42_HPOUT_PULLDOWN_MASK |\n\t\t\t\tCS42L42_HPOUT_LOAD_MASK |\n\t\t\t\tCS42L42_HPOUT_CLAMP_MASK |\n\t\t\t\tCS42L42_DAC_HPF_EN_MASK |\n\t\t\t\tCS42L42_DAC_MON_EN_MASK,\n\t\t\t\t(0 << CS42L42_HPOUT_PULLDOWN_SHIFT) |\n\t\t\t\t(0 << CS42L42_HPOUT_LOAD_SHIFT) |\n\t\t\t\t(0 << CS42L42_HPOUT_CLAMP_SHIFT) |\n\t\t\t\t(1 << CS42L42_DAC_HPF_EN_SHIFT) |\n\t\t\t\t(0 << CS42L42_DAC_MON_EN_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_TSRS_PLUG_INT_MASK,\n\t\tCS42L42_TS_PLUG_MASK |\n\t\tCS42L42_TS_UNPLUG_MASK,\n\t\t(0 << CS42L42_TS_PLUG_SHIFT) |\n\t\t(0 << CS42L42_TS_UNPLUG_SHIFT));\n}\n\nstatic void cs42l42_init_hs_type_detect(struct cs42l42_private *cs42l42)\n{\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_TSRS_PLUG_INT_MASK,\n\t\t\t\tCS42L42_TS_PLUG_MASK |\n\t\t\t\tCS42L42_TS_UNPLUG_MASK,\n\t\t\t\t(1 << CS42L42_TS_PLUG_SHIFT) |\n\t\t\t\t(1 << CS42L42_TS_UNPLUG_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_MISC_DET_CTL,\n\t\t\t\tCS42L42_HSBIAS_CTL_MASK |\n\t\t\t\tCS42L42_PDN_MIC_LVL_DET_MASK,\n\t\t\t\t(1 << CS42L42_HSBIAS_CTL_SHIFT) |\n\t\t\t\t(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSBIAS_SC_AUTOCTL,\n\t\t\t\tCS42L42_HSBIAS_SENSE_EN_MASK |\n\t\t\t\tCS42L42_AUTO_HSBIAS_HIZ_MASK |\n\t\t\t\tCS42L42_TIP_SENSE_EN_MASK |\n\t\t\t\tCS42L42_HSBIAS_SENSE_TRIP_MASK,\n\t\t\t\t(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\n\t\t\t\t(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\n\t\t\t\t(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\n\t\t\t\t(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSDET_CTL2,\n\t\t\t\tCS42L42_HSDET_CTRL_MASK |\n\t\t\t\tCS42L42_HSDET_SET_MASK |\n\t\t\t\tCS42L42_HSBIAS_REF_MASK |\n\t\t\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t\t\t(0 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t\t\t(2 << CS42L42_HSDET_SET_SHIFT) |\n\t\t\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t\t\t(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_DAC_CTL2,\n\t\t\t\tCS42L42_HPOUT_PULLDOWN_MASK |\n\t\t\t\tCS42L42_HPOUT_LOAD_MASK |\n\t\t\t\tCS42L42_HPOUT_CLAMP_MASK |\n\t\t\t\tCS42L42_DAC_HPF_EN_MASK |\n\t\t\t\tCS42L42_DAC_MON_EN_MASK,\n\t\t\t\t(8 << CS42L42_HPOUT_PULLDOWN_SHIFT) |\n\t\t\t\t(0 << CS42L42_HPOUT_LOAD_SHIFT) |\n\t\t\t\t(1 << CS42L42_HPOUT_CLAMP_SHIFT) |\n\t\t\t\t(1 << CS42L42_DAC_HPF_EN_SHIFT) |\n\t\t\t\t(1 << CS42L42_DAC_MON_EN_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_MISC_DET_CTL,\n\t\t\t\tCS42L42_HSBIAS_CTL_MASK |\n\t\t\t\tCS42L42_PDN_MIC_LVL_DET_MASK,\n\t\t\t\t(3 << CS42L42_HSBIAS_CTL_SHIFT) |\n\t\t\t\t(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\n\n\t \n\tmsleep(cs42l42->hs_bias_ramp_time);\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_CODEC_INT_MASK,\n\t\t\t\tCS42L42_PDN_DONE_MASK |\n\t\t\t\tCS42L42_HSDET_AUTO_DONE_MASK,\n\t\t\t\t(1 << CS42L42_PDN_DONE_SHIFT) |\n\t\t\t\t(0 << CS42L42_HSDET_AUTO_DONE_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSDET_CTL2,\n\t\t\t\tCS42L42_HSDET_CTRL_MASK |\n\t\t\t\tCS42L42_HSDET_SET_MASK |\n\t\t\t\tCS42L42_HSBIAS_REF_MASK |\n\t\t\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t\t\t(3 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t\t\t(2 << CS42L42_HSDET_SET_SHIFT) |\n\t\t\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t\t\t(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n}\n\nstatic void cs42l42_cancel_hs_type_detect(struct cs42l42_private *cs42l42)\n{\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_DET_INT2_MASK,\n\t\tCS42L42_M_DETECT_TF_MASK |\n\t\tCS42L42_M_DETECT_FT_MASK |\n\t\tCS42L42_M_HSBIAS_HIZ_MASK |\n\t\tCS42L42_M_SHORT_RLS_MASK |\n\t\tCS42L42_M_SHORT_DET_MASK,\n\t\t(1 << CS42L42_M_DETECT_TF_SHIFT) |\n\t\t(1 << CS42L42_M_DETECT_FT_SHIFT) |\n\t\t(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_RLS_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_DET_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_MISC_DET_CTL,\n\t\t\t\tCS42L42_HSBIAS_CTL_MASK |\n\t\t\t\tCS42L42_PDN_MIC_LVL_DET_MASK,\n\t\t\t\t(1 << CS42L42_HSBIAS_CTL_SHIFT) |\n\t\t\t\t(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSBIAS_SC_AUTOCTL,\n\t\t\t\tCS42L42_HSBIAS_SENSE_EN_MASK |\n\t\t\t\tCS42L42_AUTO_HSBIAS_HIZ_MASK |\n\t\t\t\tCS42L42_TIP_SENSE_EN_MASK |\n\t\t\t\tCS42L42_HSBIAS_SENSE_TRIP_MASK,\n\t\t\t\t(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\n\t\t\t\t(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\n\t\t\t\t(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\n\t\t\t\t(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\t\tCS42L42_HSDET_CTL2,\n\t\t\t\tCS42L42_HSDET_CTRL_MASK |\n\t\t\t\tCS42L42_HSDET_SET_MASK |\n\t\t\t\tCS42L42_HSBIAS_REF_MASK |\n\t\t\t\tCS42L42_HSDET_AUTO_TIME_MASK,\n\t\t\t\t(0 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t\t\t(2 << CS42L42_HSDET_SET_SHIFT) |\n\t\t\t\t(0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t\t\t(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n}\n\nstatic int cs42l42_handle_button_press(struct cs42l42_private *cs42l42)\n{\n\tint bias_level;\n\tunsigned int detect_status;\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_DET_INT2_MASK,\n\t\tCS42L42_M_DETECT_TF_MASK |\n\t\tCS42L42_M_DETECT_FT_MASK |\n\t\tCS42L42_M_HSBIAS_HIZ_MASK |\n\t\tCS42L42_M_SHORT_RLS_MASK |\n\t\tCS42L42_M_SHORT_DET_MASK,\n\t\t(1 << CS42L42_M_DETECT_TF_SHIFT) |\n\t\t(1 << CS42L42_M_DETECT_FT_SHIFT) |\n\t\t(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_RLS_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_DET_SHIFT));\n\n\tusleep_range(cs42l42->btn_det_event_dbnce * 1000,\n\t\t     cs42l42->btn_det_event_dbnce * 2000);\n\n\t \n\tbias_level = 1;\n\tdo {\n\t\t \n\t\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_MIC_DET_CTL1,\n\t\t\tCS42L42_LATCH_TO_VP_MASK |\n\t\t\tCS42L42_EVENT_STAT_SEL_MASK |\n\t\t\tCS42L42_HS_DET_LEVEL_MASK,\n\t\t\t(1 << CS42L42_LATCH_TO_VP_SHIFT) |\n\t\t\t(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\n\t\t\t(cs42l42->bias_thresholds[bias_level] <<\n\t\t\tCS42L42_HS_DET_LEVEL_SHIFT));\n\n\t\tregmap_read(cs42l42->regmap, CS42L42_DET_STATUS2,\n\t\t\t\t&detect_status);\n\t} while ((detect_status & CS42L42_HS_TRUE_MASK) &&\n\t\t(++bias_level < CS42L42_NUM_BIASES));\n\n\tswitch (bias_level) {\n\tcase 1:  \n\t\tbias_level = SND_JACK_BTN_2;\n\t\tdev_dbg(cs42l42->dev, \"Function C button press\\n\");\n\t\tbreak;\n\tcase 2:  \n\t\tbias_level = SND_JACK_BTN_1;\n\t\tdev_dbg(cs42l42->dev, \"Function B button press\\n\");\n\t\tbreak;\n\tcase 3:  \n\t\tbias_level = SND_JACK_BTN_3;\n\t\tdev_dbg(cs42l42->dev, \"Function D button press\\n\");\n\t\tbreak;\n\tcase 4:  \n\t\tbias_level = SND_JACK_BTN_0;\n\t\tdev_dbg(cs42l42->dev, \"Function A button press\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbias_level = 0;\n\t\tbreak;\n\t}\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_MIC_DET_CTL1,\n\t\tCS42L42_LATCH_TO_VP_MASK |\n\t\tCS42L42_EVENT_STAT_SEL_MASK |\n\t\tCS42L42_HS_DET_LEVEL_MASK,\n\t\t(1 << CS42L42_LATCH_TO_VP_SHIFT) |\n\t\t(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\n\t\t(cs42l42->bias_thresholds[0] << CS42L42_HS_DET_LEVEL_SHIFT));\n\n\t \n\tregmap_read(cs42l42->regmap, CS42L42_DET_INT_STATUS2,\n\t\t    &detect_status);\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\tCS42L42_DET_INT2_MASK,\n\t\tCS42L42_M_DETECT_TF_MASK |\n\t\tCS42L42_M_DETECT_FT_MASK |\n\t\tCS42L42_M_HSBIAS_HIZ_MASK |\n\t\tCS42L42_M_SHORT_RLS_MASK |\n\t\tCS42L42_M_SHORT_DET_MASK,\n\t\t(0 << CS42L42_M_DETECT_TF_SHIFT) |\n\t\t(0 << CS42L42_M_DETECT_FT_SHIFT) |\n\t\t(0 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_RLS_SHIFT) |\n\t\t(1 << CS42L42_M_SHORT_DET_SHIFT));\n\n\treturn bias_level;\n}\n\nstruct cs42l42_irq_params {\n\tu16 status_addr;\n\tu16 mask_addr;\n\tu8 mask;\n};\n\nstatic const struct cs42l42_irq_params irq_params_table[] = {\n\t{CS42L42_ADC_OVFL_STATUS, CS42L42_ADC_OVFL_INT_MASK,\n\t\tCS42L42_ADC_OVFL_VAL_MASK},\n\t{CS42L42_MIXER_STATUS, CS42L42_MIXER_INT_MASK,\n\t\tCS42L42_MIXER_VAL_MASK},\n\t{CS42L42_SRC_STATUS, CS42L42_SRC_INT_MASK,\n\t\tCS42L42_SRC_VAL_MASK},\n\t{CS42L42_ASP_RX_STATUS, CS42L42_ASP_RX_INT_MASK,\n\t\tCS42L42_ASP_RX_VAL_MASK},\n\t{CS42L42_ASP_TX_STATUS, CS42L42_ASP_TX_INT_MASK,\n\t\tCS42L42_ASP_TX_VAL_MASK},\n\t{CS42L42_CODEC_STATUS, CS42L42_CODEC_INT_MASK,\n\t\tCS42L42_CODEC_VAL_MASK},\n\t{CS42L42_DET_INT_STATUS1, CS42L42_DET_INT1_MASK,\n\t\tCS42L42_DET_INT_VAL1_MASK},\n\t{CS42L42_DET_INT_STATUS2, CS42L42_DET_INT2_MASK,\n\t\tCS42L42_DET_INT_VAL2_MASK},\n\t{CS42L42_SRCPL_INT_STATUS, CS42L42_SRCPL_INT_MASK,\n\t\tCS42L42_SRCPL_VAL_MASK},\n\t{CS42L42_VPMON_STATUS, CS42L42_VPMON_INT_MASK,\n\t\tCS42L42_VPMON_VAL_MASK},\n\t{CS42L42_PLL_LOCK_STATUS, CS42L42_PLL_LOCK_INT_MASK,\n\t\tCS42L42_PLL_LOCK_VAL_MASK},\n\t{CS42L42_TSRS_PLUG_STATUS, CS42L42_TSRS_PLUG_INT_MASK,\n\t\tCS42L42_TSRS_PLUG_VAL_MASK}\n};\n\nirqreturn_t cs42l42_irq_thread(int irq, void *data)\n{\n\tstruct cs42l42_private *cs42l42 = (struct cs42l42_private *)data;\n\tunsigned int stickies[12];\n\tunsigned int masks[12];\n\tunsigned int current_plug_status;\n\tunsigned int current_button_status;\n\tunsigned int i;\n\n\tpm_runtime_get_sync(cs42l42->dev);\n\tmutex_lock(&cs42l42->irq_lock);\n\tif (cs42l42->suspended || !cs42l42->init_done) {\n\t\tmutex_unlock(&cs42l42->irq_lock);\n\t\tpm_runtime_put_autosuspend(cs42l42->dev);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(stickies); i++) {\n\t\tregmap_read(cs42l42->regmap, irq_params_table[i].status_addr,\n\t\t\t\t&(stickies[i]));\n\t\tregmap_read(cs42l42->regmap, irq_params_table[i].mask_addr,\n\t\t\t\t&(masks[i]));\n\t\tstickies[i] = stickies[i] & (~masks[i]) &\n\t\t\t\tirq_params_table[i].mask;\n\t}\n\n\t \n\tcurrent_plug_status = (stickies[11] &\n\t\t(CS42L42_TS_PLUG_MASK | CS42L42_TS_UNPLUG_MASK)) >>\n\t\tCS42L42_TS_PLUG_SHIFT;\n\n\t \n\tcurrent_button_status = stickies[7] &\n\t\t(CS42L42_M_DETECT_TF_MASK |\n\t\tCS42L42_M_DETECT_FT_MASK |\n\t\tCS42L42_M_HSBIAS_HIZ_MASK);\n\n\t \n\tif ((~masks[5]) & irq_params_table[5].mask) {\n\t\tif (stickies[5] & CS42L42_HSDET_AUTO_DONE_MASK) {\n\t\t\tcs42l42_process_hs_type_detect(cs42l42);\n\t\t\tswitch (cs42l42->hs_type) {\n\t\t\tcase CS42L42_PLUG_CTIA:\n\t\t\tcase CS42L42_PLUG_OMTP:\n\t\t\t\tsnd_soc_jack_report(cs42l42->jack, SND_JACK_HEADSET,\n\t\t\t\t\t\t    SND_JACK_HEADSET |\n\t\t\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3);\n\t\t\t\tbreak;\n\t\t\tcase CS42L42_PLUG_HEADPHONE:\n\t\t\t\tsnd_soc_jack_report(cs42l42->jack, SND_JACK_HEADPHONE,\n\t\t\t\t\t\t    SND_JACK_HEADSET |\n\t\t\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_dbg(cs42l42->dev, \"Auto detect done (%d)\\n\", cs42l42->hs_type);\n\t\t}\n\t}\n\n\t \n\tif ((~masks[11]) & irq_params_table[11].mask) {\n\t\tswitch (current_plug_status) {\n\t\tcase CS42L42_TS_PLUG:\n\t\t\tif (cs42l42->plug_state != CS42L42_TS_PLUG) {\n\t\t\t\tcs42l42->plug_state = CS42L42_TS_PLUG;\n\t\t\t\tcs42l42_init_hs_type_detect(cs42l42);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CS42L42_TS_UNPLUG:\n\t\t\tif (cs42l42->plug_state != CS42L42_TS_UNPLUG) {\n\t\t\t\tcs42l42->plug_state = CS42L42_TS_UNPLUG;\n\t\t\t\tcs42l42_cancel_hs_type_detect(cs42l42);\n\n\t\t\t\tsnd_soc_jack_report(cs42l42->jack, 0,\n\t\t\t\t\t\t    SND_JACK_HEADSET |\n\t\t\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\t\t\t\tdev_dbg(cs42l42->dev, \"Unplug event\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcs42l42->plug_state = CS42L42_TS_TRANS;\n\t\t}\n\t}\n\n\t \n\tif (cs42l42->plug_state == CS42L42_TS_PLUG && ((~masks[7]) & irq_params_table[7].mask)) {\n\t\tif (!(current_button_status &\n\t\t\tCS42L42_M_HSBIAS_HIZ_MASK)) {\n\n\t\t\tif (current_button_status & CS42L42_M_DETECT_TF_MASK) {\n\t\t\t\tdev_dbg(cs42l42->dev, \"Button released\\n\");\n\t\t\t\tsnd_soc_jack_report(cs42l42->jack, 0,\n\t\t\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3);\n\t\t\t} else if (current_button_status & CS42L42_M_DETECT_FT_MASK) {\n\t\t\t\tsnd_soc_jack_report(cs42l42->jack,\n\t\t\t\t\t\t    cs42l42_handle_button_press(cs42l42),\n\t\t\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&cs42l42->irq_lock);\n\tpm_runtime_mark_last_busy(cs42l42->dev);\n\tpm_runtime_put_autosuspend(cs42l42->dev);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_irq_thread, SND_SOC_CS42L42_CORE);\n\nstatic void cs42l42_set_interrupt_masks(struct cs42l42_private *cs42l42)\n{\n\tregmap_update_bits(cs42l42->regmap, CS42L42_ADC_OVFL_INT_MASK,\n\t\t\tCS42L42_ADC_OVFL_MASK,\n\t\t\t(1 << CS42L42_ADC_OVFL_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_MIXER_INT_MASK,\n\t\t\tCS42L42_MIX_CHB_OVFL_MASK |\n\t\t\tCS42L42_MIX_CHA_OVFL_MASK |\n\t\t\tCS42L42_EQ_OVFL_MASK |\n\t\t\tCS42L42_EQ_BIQUAD_OVFL_MASK,\n\t\t\t(1 << CS42L42_MIX_CHB_OVFL_SHIFT) |\n\t\t\t(1 << CS42L42_MIX_CHA_OVFL_SHIFT) |\n\t\t\t(1 << CS42L42_EQ_OVFL_SHIFT) |\n\t\t\t(1 << CS42L42_EQ_BIQUAD_OVFL_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_SRC_INT_MASK,\n\t\t\tCS42L42_SRC_ILK_MASK |\n\t\t\tCS42L42_SRC_OLK_MASK |\n\t\t\tCS42L42_SRC_IUNLK_MASK |\n\t\t\tCS42L42_SRC_OUNLK_MASK,\n\t\t\t(1 << CS42L42_SRC_ILK_SHIFT) |\n\t\t\t(1 << CS42L42_SRC_OLK_SHIFT) |\n\t\t\t(1 << CS42L42_SRC_IUNLK_SHIFT) |\n\t\t\t(1 << CS42L42_SRC_OUNLK_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_ASP_RX_INT_MASK,\n\t\t\tCS42L42_ASPRX_NOLRCK_MASK |\n\t\t\tCS42L42_ASPRX_EARLY_MASK |\n\t\t\tCS42L42_ASPRX_LATE_MASK |\n\t\t\tCS42L42_ASPRX_ERROR_MASK |\n\t\t\tCS42L42_ASPRX_OVLD_MASK,\n\t\t\t(1 << CS42L42_ASPRX_NOLRCK_SHIFT) |\n\t\t\t(1 << CS42L42_ASPRX_EARLY_SHIFT) |\n\t\t\t(1 << CS42L42_ASPRX_LATE_SHIFT) |\n\t\t\t(1 << CS42L42_ASPRX_ERROR_SHIFT) |\n\t\t\t(1 << CS42L42_ASPRX_OVLD_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_ASP_TX_INT_MASK,\n\t\t\tCS42L42_ASPTX_NOLRCK_MASK |\n\t\t\tCS42L42_ASPTX_EARLY_MASK |\n\t\t\tCS42L42_ASPTX_LATE_MASK |\n\t\t\tCS42L42_ASPTX_SMERROR_MASK,\n\t\t\t(1 << CS42L42_ASPTX_NOLRCK_SHIFT) |\n\t\t\t(1 << CS42L42_ASPTX_EARLY_SHIFT) |\n\t\t\t(1 << CS42L42_ASPTX_LATE_SHIFT) |\n\t\t\t(1 << CS42L42_ASPTX_SMERROR_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_CODEC_INT_MASK,\n\t\t\tCS42L42_PDN_DONE_MASK |\n\t\t\tCS42L42_HSDET_AUTO_DONE_MASK,\n\t\t\t(1 << CS42L42_PDN_DONE_SHIFT) |\n\t\t\t(1 << CS42L42_HSDET_AUTO_DONE_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_SRCPL_INT_MASK,\n\t\t\tCS42L42_SRCPL_ADC_LK_MASK |\n\t\t\tCS42L42_SRCPL_DAC_LK_MASK |\n\t\t\tCS42L42_SRCPL_ADC_UNLK_MASK |\n\t\t\tCS42L42_SRCPL_DAC_UNLK_MASK,\n\t\t\t(1 << CS42L42_SRCPL_ADC_LK_SHIFT) |\n\t\t\t(1 << CS42L42_SRCPL_DAC_LK_SHIFT) |\n\t\t\t(1 << CS42L42_SRCPL_ADC_UNLK_SHIFT) |\n\t\t\t(1 << CS42L42_SRCPL_DAC_UNLK_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_DET_INT1_MASK,\n\t\t\tCS42L42_TIP_SENSE_UNPLUG_MASK |\n\t\t\tCS42L42_TIP_SENSE_PLUG_MASK |\n\t\t\tCS42L42_HSBIAS_SENSE_MASK,\n\t\t\t(1 << CS42L42_TIP_SENSE_UNPLUG_SHIFT) |\n\t\t\t(1 << CS42L42_TIP_SENSE_PLUG_SHIFT) |\n\t\t\t(1 << CS42L42_HSBIAS_SENSE_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_DET_INT2_MASK,\n\t\t\tCS42L42_M_DETECT_TF_MASK |\n\t\t\tCS42L42_M_DETECT_FT_MASK |\n\t\t\tCS42L42_M_HSBIAS_HIZ_MASK |\n\t\t\tCS42L42_M_SHORT_RLS_MASK |\n\t\t\tCS42L42_M_SHORT_DET_MASK,\n\t\t\t(1 << CS42L42_M_DETECT_TF_SHIFT) |\n\t\t\t(1 << CS42L42_M_DETECT_FT_SHIFT) |\n\t\t\t(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\n\t\t\t(1 << CS42L42_M_SHORT_RLS_SHIFT) |\n\t\t\t(1 << CS42L42_M_SHORT_DET_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_VPMON_INT_MASK,\n\t\t\tCS42L42_VPMON_MASK,\n\t\t\t(1 << CS42L42_VPMON_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_PLL_LOCK_INT_MASK,\n\t\t\tCS42L42_PLL_LOCK_MASK,\n\t\t\t(1 << CS42L42_PLL_LOCK_SHIFT));\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_TSRS_PLUG_INT_MASK,\n\t\t\tCS42L42_RS_PLUG_MASK |\n\t\t\tCS42L42_RS_UNPLUG_MASK |\n\t\t\tCS42L42_TS_PLUG_MASK |\n\t\t\tCS42L42_TS_UNPLUG_MASK,\n\t\t\t(1 << CS42L42_RS_PLUG_SHIFT) |\n\t\t\t(1 << CS42L42_RS_UNPLUG_SHIFT) |\n\t\t\t(0 << CS42L42_TS_PLUG_SHIFT) |\n\t\t\t(0 << CS42L42_TS_UNPLUG_SHIFT));\n}\n\nstatic void cs42l42_setup_hs_type_detect(struct cs42l42_private *cs42l42)\n{\n\tunsigned int reg;\n\n\tcs42l42->hs_type = CS42L42_PLUG_INVALID;\n\n\t \n\tregmap_update_bits(cs42l42->regmap, CS42L42_MISC_DET_CTL,\n\t\t\t   CS42L42_DETECT_MODE_MASK, 0);\n\n\t \n\tregmap_update_bits(cs42l42->regmap, CS42L42_MIC_DET_CTL1,\n\t\t\tCS42L42_LATCH_TO_VP_MASK |\n\t\t\tCS42L42_EVENT_STAT_SEL_MASK |\n\t\t\tCS42L42_HS_DET_LEVEL_MASK,\n\t\t\t(1 << CS42L42_LATCH_TO_VP_SHIFT) |\n\t\t\t(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\n\t\t\t(cs42l42->bias_thresholds[0] <<\n\t\t\tCS42L42_HS_DET_LEVEL_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap,\n\t\t\tCS42L42_HS_CLAMP_DISABLE,\n\t\t\tCS42L42_HS_CLAMP_DISABLE_MASK,\n\t\t\t(1 << CS42L42_HS_CLAMP_DISABLE_SHIFT));\n\n\t \n\tregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\n\t\t\t   CS42L42_TS_INV_MASK, CS42L42_TS_INV_MASK);\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_TIPSENSE_CTL,\n\t\t\tCS42L42_TIP_SENSE_CTRL_MASK |\n\t\t\tCS42L42_TIP_SENSE_INV_MASK |\n\t\t\tCS42L42_TIP_SENSE_DEBOUNCE_MASK,\n\t\t\t(3 << CS42L42_TIP_SENSE_CTRL_SHIFT) |\n\t\t\t(!cs42l42->ts_inv << CS42L42_TIP_SENSE_INV_SHIFT) |\n\t\t\t(2 << CS42L42_TIP_SENSE_DEBOUNCE_SHIFT));\n\n\t \n\tregmap_read(cs42l42->regmap,\n\t\t\t  CS42L42_TSRS_PLUG_STATUS,\n\t\t\t  &reg);\n\tcs42l42->plug_state = (((char) reg) &\n\t\t      (CS42L42_TS_PLUG_MASK | CS42L42_TS_UNPLUG_MASK)) >>\n\t\t      CS42L42_TS_PLUG_SHIFT;\n}\n\nstatic const unsigned int threshold_defaults[] = {\n\tCS42L42_HS_DET_LEVEL_15,\n\tCS42L42_HS_DET_LEVEL_8,\n\tCS42L42_HS_DET_LEVEL_4,\n\tCS42L42_HS_DET_LEVEL_1\n};\n\nstatic int cs42l42_handle_device_data(struct device *dev,\n\t\t\t\t\tstruct cs42l42_private *cs42l42)\n{\n\tunsigned int val;\n\tu32 thresholds[CS42L42_NUM_BIASES];\n\tint ret;\n\tint i;\n\n\tret = device_property_read_u32(dev, \"cirrus,ts-inv\", &val);\n\tif (!ret) {\n\t\tswitch (val) {\n\t\tcase CS42L42_TS_INV_EN:\n\t\tcase CS42L42_TS_INV_DIS:\n\t\t\tcs42l42->ts_inv = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,ts-inv DT value %d\\n\",\n\t\t\t\tval);\n\t\t\tcs42l42->ts_inv = CS42L42_TS_INV_DIS;\n\t\t}\n\t} else {\n\t\tcs42l42->ts_inv = CS42L42_TS_INV_DIS;\n\t}\n\n\tret = device_property_read_u32(dev, \"cirrus,ts-dbnc-rise\", &val);\n\tif (!ret) {\n\t\tswitch (val) {\n\t\tcase CS42L42_TS_DBNCE_0:\n\t\tcase CS42L42_TS_DBNCE_125:\n\t\tcase CS42L42_TS_DBNCE_250:\n\t\tcase CS42L42_TS_DBNCE_500:\n\t\tcase CS42L42_TS_DBNCE_750:\n\t\tcase CS42L42_TS_DBNCE_1000:\n\t\tcase CS42L42_TS_DBNCE_1250:\n\t\tcase CS42L42_TS_DBNCE_1500:\n\t\t\tcs42l42->ts_dbnc_rise = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,ts-dbnc-rise DT value %d\\n\",\n\t\t\t\tval);\n\t\t\tcs42l42->ts_dbnc_rise = CS42L42_TS_DBNCE_1000;\n\t\t}\n\t} else {\n\t\tcs42l42->ts_dbnc_rise = CS42L42_TS_DBNCE_1000;\n\t}\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\n\t\t\tCS42L42_TS_RISE_DBNCE_TIME_MASK,\n\t\t\t(cs42l42->ts_dbnc_rise <<\n\t\t\tCS42L42_TS_RISE_DBNCE_TIME_SHIFT));\n\n\tret = device_property_read_u32(dev, \"cirrus,ts-dbnc-fall\", &val);\n\tif (!ret) {\n\t\tswitch (val) {\n\t\tcase CS42L42_TS_DBNCE_0:\n\t\tcase CS42L42_TS_DBNCE_125:\n\t\tcase CS42L42_TS_DBNCE_250:\n\t\tcase CS42L42_TS_DBNCE_500:\n\t\tcase CS42L42_TS_DBNCE_750:\n\t\tcase CS42L42_TS_DBNCE_1000:\n\t\tcase CS42L42_TS_DBNCE_1250:\n\t\tcase CS42L42_TS_DBNCE_1500:\n\t\t\tcs42l42->ts_dbnc_fall = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,ts-dbnc-fall DT value %d\\n\",\n\t\t\t\tval);\n\t\t\tcs42l42->ts_dbnc_fall = CS42L42_TS_DBNCE_0;\n\t\t}\n\t} else {\n\t\tcs42l42->ts_dbnc_fall = CS42L42_TS_DBNCE_0;\n\t}\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\n\t\t\tCS42L42_TS_FALL_DBNCE_TIME_MASK,\n\t\t\t(cs42l42->ts_dbnc_fall <<\n\t\t\tCS42L42_TS_FALL_DBNCE_TIME_SHIFT));\n\n\tret = device_property_read_u32(dev, \"cirrus,btn-det-init-dbnce\", &val);\n\tif (!ret) {\n\t\tif (val <= CS42L42_BTN_DET_INIT_DBNCE_MAX)\n\t\t\tcs42l42->btn_det_init_dbnce = val;\n\t\telse {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,btn-det-init-dbnce DT value %d\\n\",\n\t\t\t\tval);\n\t\t\tcs42l42->btn_det_init_dbnce =\n\t\t\t\tCS42L42_BTN_DET_INIT_DBNCE_DEFAULT;\n\t\t}\n\t} else {\n\t\tcs42l42->btn_det_init_dbnce =\n\t\t\tCS42L42_BTN_DET_INIT_DBNCE_DEFAULT;\n\t}\n\n\tret = device_property_read_u32(dev, \"cirrus,btn-det-event-dbnce\", &val);\n\tif (!ret) {\n\t\tif (val <= CS42L42_BTN_DET_EVENT_DBNCE_MAX)\n\t\t\tcs42l42->btn_det_event_dbnce = val;\n\t\telse {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,btn-det-event-dbnce DT value %d\\n\", val);\n\t\t\tcs42l42->btn_det_event_dbnce =\n\t\t\t\tCS42L42_BTN_DET_EVENT_DBNCE_DEFAULT;\n\t\t}\n\t} else {\n\t\tcs42l42->btn_det_event_dbnce =\n\t\t\tCS42L42_BTN_DET_EVENT_DBNCE_DEFAULT;\n\t}\n\n\tret = device_property_read_u32_array(dev, \"cirrus,bias-lvls\",\n\t\t\t\t\t     thresholds, ARRAY_SIZE(thresholds));\n\tif (!ret) {\n\t\tfor (i = 0; i < CS42L42_NUM_BIASES; i++) {\n\t\t\tif (thresholds[i] <= CS42L42_HS_DET_LEVEL_MAX)\n\t\t\t\tcs42l42->bias_thresholds[i] = thresholds[i];\n\t\t\telse {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Wrong cirrus,bias-lvls[%d] DT value %d\\n\", i,\n\t\t\t\t\tthresholds[i]);\n\t\t\t\tcs42l42->bias_thresholds[i] = threshold_defaults[i];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < CS42L42_NUM_BIASES; i++)\n\t\t\tcs42l42->bias_thresholds[i] = threshold_defaults[i];\n\t}\n\n\tret = device_property_read_u32(dev, \"cirrus,hs-bias-ramp-rate\", &val);\n\tif (!ret) {\n\t\tswitch (val) {\n\t\tcase CS42L42_HSBIAS_RAMP_FAST_RISE_SLOW_FALL:\n\t\t\tcs42l42->hs_bias_ramp_rate = val;\n\t\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME0;\n\t\t\tbreak;\n\t\tcase CS42L42_HSBIAS_RAMP_FAST:\n\t\t\tcs42l42->hs_bias_ramp_rate = val;\n\t\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME1;\n\t\t\tbreak;\n\t\tcase CS42L42_HSBIAS_RAMP_SLOW:\n\t\t\tcs42l42->hs_bias_ramp_rate = val;\n\t\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\n\t\t\tbreak;\n\t\tcase CS42L42_HSBIAS_RAMP_SLOWEST:\n\t\t\tcs42l42->hs_bias_ramp_rate = val;\n\t\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev,\n\t\t\t\t\"Wrong cirrus,hs-bias-ramp-rate DT value %d\\n\",\n\t\t\t\tval);\n\t\t\tcs42l42->hs_bias_ramp_rate = CS42L42_HSBIAS_RAMP_SLOW;\n\t\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\n\t\t}\n\t} else {\n\t\tcs42l42->hs_bias_ramp_rate = CS42L42_HSBIAS_RAMP_SLOW;\n\t\tcs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\n\t}\n\n\tregmap_update_bits(cs42l42->regmap, CS42L42_HS_BIAS_CTL,\n\t\t\tCS42L42_HSBIAS_RAMP_MASK,\n\t\t\t(cs42l42->hs_bias_ramp_rate <<\n\t\t\tCS42L42_HSBIAS_RAMP_SHIFT));\n\n\tif (device_property_read_bool(dev, \"cirrus,hs-bias-sense-disable\"))\n\t\tcs42l42->hs_bias_sense_en = 0;\n\telse\n\t\tcs42l42->hs_bias_sense_en = 1;\n\n\treturn 0;\n}\n\n \nstatic const struct reg_sequence __maybe_unused cs42l42_shutdown_seq[] = {\n\tREG_SEQ0(CS42L42_MIC_DET_CTL1,\t\t0x9F),\n\tREG_SEQ0(CS42L42_ADC_OVFL_INT_MASK,\t0x01),\n\tREG_SEQ0(CS42L42_MIXER_INT_MASK,\t0x0F),\n\tREG_SEQ0(CS42L42_SRC_INT_MASK,\t\t0x0F),\n\tREG_SEQ0(CS42L42_ASP_RX_INT_MASK,\t0x1F),\n\tREG_SEQ0(CS42L42_ASP_TX_INT_MASK,\t0x0F),\n\tREG_SEQ0(CS42L42_CODEC_INT_MASK,\t0x03),\n\tREG_SEQ0(CS42L42_SRCPL_INT_MASK,\t0x7F),\n\tREG_SEQ0(CS42L42_VPMON_INT_MASK,\t0x01),\n\tREG_SEQ0(CS42L42_PLL_LOCK_INT_MASK,\t0x01),\n\tREG_SEQ0(CS42L42_TSRS_PLUG_INT_MASK,\t0x0F),\n\tREG_SEQ0(CS42L42_WAKE_CTL,\t\t0xE1),\n\tREG_SEQ0(CS42L42_DET_INT1_MASK,\t\t0xE0),\n\tREG_SEQ0(CS42L42_DET_INT2_MASK,\t\t0xFF),\n\tREG_SEQ0(CS42L42_MIXER_CHA_VOL,\t\t0x3F),\n\tREG_SEQ0(CS42L42_MIXER_ADC_VOL,\t\t0x3F),\n\tREG_SEQ0(CS42L42_MIXER_CHB_VOL,\t\t0x3F),\n\tREG_SEQ0(CS42L42_HP_CTL,\t\t0x0F),\n\tREG_SEQ0(CS42L42_ASP_RX_DAI0_EN,\t0x00),\n\tREG_SEQ0(CS42L42_ASP_CLK_CFG,\t\t0x00),\n\tREG_SEQ0(CS42L42_HSDET_CTL2,\t\t0x00),\n\tREG_SEQ0(CS42L42_PWR_CTL1,\t\t0xFE),\n\tREG_SEQ0(CS42L42_PWR_CTL2,\t\t0x8C),\n\tREG_SEQ0(CS42L42_DAC_CTL2,\t\t0x02),\n\tREG_SEQ0(CS42L42_HS_CLAMP_DISABLE,\t0x00),\n\tREG_SEQ0(CS42L42_MISC_DET_CTL,\t\t0x03),\n\tREG_SEQ0(CS42L42_TIPSENSE_CTL,\t\t0x02),\n\tREG_SEQ0(CS42L42_HSBIAS_SC_AUTOCTL,\t0x03),\n\tREG_SEQ0(CS42L42_PWR_CTL1,\t\t0xFF)\n};\n\nint cs42l42_suspend(struct device *dev)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\tunsigned int reg;\n\tu8 save_regs[ARRAY_SIZE(cs42l42_shutdown_seq)];\n\tint i, ret;\n\n\tif (!cs42l42->init_done)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&cs42l42->irq_lock);\n\tcs42l42->suspended = true;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cs42l42_shutdown_seq); ++i) {\n\t\tregmap_read(cs42l42->regmap, cs42l42_shutdown_seq[i].reg, &reg);\n\t\tsave_regs[i] = (u8)reg;\n\t}\n\n\t \n\tregmap_multi_reg_write(cs42l42->regmap,\n\t\t\t       cs42l42_shutdown_seq,\n\t\t\t       ARRAY_SIZE(cs42l42_shutdown_seq));\n\n\t \n\tmutex_unlock(&cs42l42->irq_lock);\n\n\t \n\tmsleep(CS42L42_PDN_DONE_TIME_MS);\n\tret = regmap_read_poll_timeout(cs42l42->regmap,\n\t\t\t\t       CS42L42_CODEC_STATUS, reg,\n\t\t\t\t       (reg & CS42L42_PDN_DONE_MASK),\n\t\t\t\t       CS42L42_PDN_DONE_POLL_US,\n\t\t\t\t       CS42L42_PDN_DONE_TIMEOUT_US);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to get PDN_DONE: %d\\n\", ret);\n\n\t \n\tregmap_update_bits(cs42l42->regmap, CS42L42_PWR_CTL2,\n\t\t\t   CS42L42_DISCHARGE_FILT_MASK, CS42L42_DISCHARGE_FILT_MASK);\n\tmsleep(CS42L42_FILT_DISCHARGE_TIME_MS);\n\n\tregcache_cache_only(cs42l42->regmap, true);\n\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies), cs42l42->supplies);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cs42l42_shutdown_seq); ++i)\n\t\tregmap_write(cs42l42->regmap, cs42l42_shutdown_seq[i].reg, save_regs[i]);\n\n\t \n\tregcache_drop_region(cs42l42->regmap, CS42L42_PAGE_REGISTER, CS42L42_PAGE_REGISTER);\n\n\tdev_dbg(dev, \"System suspended\\n\");\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_suspend, SND_SOC_CS42L42_CORE);\n\nint cs42l42_resume(struct device *dev)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!cs42l42->init_done)\n\t\treturn 0;\n\n\t \n\tif (cs42l42->plug_state != CS42L42_TS_UNPLUG)\n\t\tcs42l42->plug_state = CS42L42_TS_TRANS;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l42->supplies), cs42l42->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\n\tusleep_range(CS42L42_BOOT_TIME_US, CS42L42_BOOT_TIME_US * 2);\n\n\tdev_dbg(dev, \"System resume powered up\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_resume, SND_SOC_CS42L42_CORE);\n\nvoid cs42l42_resume_restore(struct device *dev)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs42l42->regmap, false);\n\tregcache_mark_dirty(cs42l42->regmap);\n\n\tmutex_lock(&cs42l42->irq_lock);\n\t \n\tregcache_sync_region(cs42l42->regmap, CS42L42_MIC_DET_CTL1, CS42L42_MIC_DET_CTL1);\n\tregcache_sync(cs42l42->regmap);\n\n\tcs42l42->suspended = false;\n\tmutex_unlock(&cs42l42->irq_lock);\n\n\tdev_dbg(dev, \"System resumed\\n\");\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_resume_restore, SND_SOC_CS42L42_CORE);\n\nstatic int __maybe_unused cs42l42_i2c_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = cs42l42_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tcs42l42_resume_restore(dev);\n\n\treturn 0;\n}\n\nint cs42l42_common_probe(struct cs42l42_private *cs42l42,\n\t\t\t const struct snd_soc_component_driver *component_drv,\n\t\t\t struct snd_soc_dai_driver *dai)\n{\n\tint ret, i;\n\n\tdev_set_drvdata(cs42l42->dev, cs42l42);\n\tmutex_init(&cs42l42->irq_lock);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs42l42_supply_names) != ARRAY_SIZE(cs42l42->supplies));\n\tfor (i = 0; i < ARRAY_SIZE(cs42l42->supplies); i++)\n\t\tcs42l42->supplies[i].supply = cs42l42_supply_names[i];\n\n\tret = devm_regulator_bulk_get(cs42l42->dev,\n\t\t\t\t      ARRAY_SIZE(cs42l42->supplies),\n\t\t\t\t      cs42l42->supplies);\n\tif (ret != 0) {\n\t\tdev_err(cs42l42->dev,\n\t\t\t\"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l42->supplies),\n\t\t\t\t    cs42l42->supplies);\n\tif (ret != 0) {\n\t\tdev_err(cs42l42->dev,\n\t\t\t\"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs42l42->reset_gpio = devm_gpiod_get_optional(cs42l42->dev,\n\t\t\"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs42l42->reset_gpio)) {\n\t\tret = PTR_ERR(cs42l42->reset_gpio);\n\t\tgoto err_disable_noreset;\n\t}\n\n\tif (cs42l42->reset_gpio) {\n\t\tdev_dbg(cs42l42->dev, \"Found reset GPIO\\n\");\n\n\t\t \n\t\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\n\n\t\t \n\t\tusleep_range(10, 500);\n\n\t\t \n\t\tif (cs42l42->sdw_peripheral)\n\t\t\tcs42l42->sdw_waiting_first_unattach = true;\n\t\telse\n\t\t\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\n\t}\n\tusleep_range(CS42L42_BOOT_TIME_US, CS42L42_BOOT_TIME_US * 2);\n\n\t \n\tif (cs42l42->irq) {\n\t\tret = request_threaded_irq(cs42l42->irq,\n\t\t\t\t\t   NULL, cs42l42_irq_thread,\n\t\t\t\t\t   IRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\t\t   \"cs42l42\", cs42l42);\n\t\tif (ret) {\n\t\t\tdev_err_probe(cs42l42->dev, ret,\n\t\t\t\t\"Failed to request IRQ\\n\");\n\t\t\tgoto err_disable_noirq;\n\t\t}\n\t}\n\n\t \n\tret = devm_snd_soc_register_component(cs42l42->dev, component_drv, dai, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (cs42l42->irq)\n\t\tfree_irq(cs42l42->irq, cs42l42);\n\nerr_disable_noirq:\n\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\nerr_disable_noreset:\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies), cs42l42->supplies);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_common_probe, SND_SOC_CS42L42_CORE);\n\nint cs42l42_init(struct cs42l42_private *cs42l42)\n{\n\tunsigned int reg;\n\tint devid, ret;\n\n\t \n\tdevid = cirrus_read_device_id(cs42l42->regmap, CS42L42_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(cs42l42->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tif (devid != cs42l42->devid) {\n\t\tret = -ENODEV;\n\t\tdev_err(cs42l42->dev,\n\t\t\t\"CS42L%x Device ID (%X). Expected %X\\n\",\n\t\t\tcs42l42->devid & 0xff, devid, cs42l42->devid);\n\t\tgoto err_disable;\n\t}\n\n\tret = regmap_read(cs42l42->regmap, CS42L42_REVID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(cs42l42->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err_shutdown;\n\t}\n\n\tdev_info(cs42l42->dev,\n\t\t \"Cirrus Logic CS42L%x, Revision: %02X\\n\",\n\t\t cs42l42->devid & 0xff, reg & 0xFF);\n\n\t \n\tregmap_update_bits(cs42l42->regmap, CS42L42_PWR_CTL1,\n\t\t\tCS42L42_ASP_DAO_PDN_MASK |\n\t\t\tCS42L42_ASP_DAI_PDN_MASK |\n\t\t\tCS42L42_MIXER_PDN_MASK |\n\t\t\tCS42L42_EQ_PDN_MASK |\n\t\t\tCS42L42_HP_PDN_MASK |\n\t\t\tCS42L42_ADC_PDN_MASK |\n\t\t\tCS42L42_PDN_ALL_MASK,\n\t\t\t(1 << CS42L42_ASP_DAO_PDN_SHIFT) |\n\t\t\t(1 << CS42L42_ASP_DAI_PDN_SHIFT) |\n\t\t\t(1 << CS42L42_MIXER_PDN_SHIFT) |\n\t\t\t(1 << CS42L42_EQ_PDN_SHIFT) |\n\t\t\t(1 << CS42L42_HP_PDN_SHIFT) |\n\t\t\t(1 << CS42L42_ADC_PDN_SHIFT) |\n\t\t\t(0 << CS42L42_PDN_ALL_SHIFT));\n\n\tret = cs42l42_handle_device_data(cs42l42->dev, cs42l42);\n\tif (ret != 0)\n\t\tgoto err_shutdown;\n\n\t \n\tif (cs42l42->sdw_peripheral) {\n\t\tregmap_update_bits(cs42l42->regmap, CS42L42_PWR_CTL2,\n\t\t\t\t   CS42L42_SRC_PDN_OVERRIDE_MASK |\n\t\t\t\t   CS42L42_DAC_SRC_PDNB_MASK |\n\t\t\t\t   CS42L42_ADC_SRC_PDNB_MASK,\n\t\t\t\t   CS42L42_SRC_PDN_OVERRIDE_MASK);\n\t}\n\n\t \n\tcs42l42_setup_hs_type_detect(cs42l42);\n\n\t \n\tcs42l42->init_done = true;\n\n\t \n\tcs42l42_set_interrupt_masks(cs42l42);\n\n\treturn 0;\n\nerr_shutdown:\n\tregmap_write(cs42l42->regmap, CS42L42_CODEC_INT_MASK, 0xff);\n\tregmap_write(cs42l42->regmap, CS42L42_TSRS_PLUG_INT_MASK, 0xff);\n\tregmap_write(cs42l42->regmap, CS42L42_PWR_CTL1, 0xff);\n\nerr_disable:\n\tif (cs42l42->irq)\n\t\tfree_irq(cs42l42->irq, cs42l42);\n\n\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies),\n\t\t\t\tcs42l42->supplies);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_init, SND_SOC_CS42L42_CORE);\n\nvoid cs42l42_common_remove(struct cs42l42_private *cs42l42)\n{\n\tif (cs42l42->irq)\n\t\tfree_irq(cs42l42->irq, cs42l42);\n\n\t \n\tif (cs42l42->init_done) {\n\t\tregmap_write(cs42l42->regmap, CS42L42_CODEC_INT_MASK, 0xff);\n\t\tregmap_write(cs42l42->regmap, CS42L42_TSRS_PLUG_INT_MASK, 0xff);\n\t\tregmap_write(cs42l42->regmap, CS42L42_PWR_CTL1, 0xff);\n\t}\n\n\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies), cs42l42->supplies);\n}\nEXPORT_SYMBOL_NS_GPL(cs42l42_common_remove, SND_SOC_CS42L42_CORE);\n\nMODULE_DESCRIPTION(\"ASoC CS42L42 driver\");\nMODULE_AUTHOR(\"James Schulman, Cirrus Logic Inc, <james.schulman@cirrus.com>\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_AUTHOR(\"Michael White, Cirrus Logic Inc, <michael.white@cirrus.com>\");\nMODULE_AUTHOR(\"Lucas Tanure <tanureal@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Vitaly Rodionov <vitalyr@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}