{
  "module_name": "tlv320adcx140.c",
  "hash_id": "28711c4fea21bfe918b78b88ab86b598f66d6b53e9ce1586f2799f93e0b64e2a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320adcx140.c",
  "human_readable_source": "\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"tlv320adcx140.h\"\n\nstruct adcx140_priv {\n\tstruct snd_soc_component *component;\n\tstruct regulator *supply_areg;\n\tstruct gpio_desc *gpio_reset;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\n\tbool micbias_vg;\n\tbool phase_calib_on;\n\n\tunsigned int dai_fmt;\n\tunsigned int slot_width;\n};\n\nstatic const char * const gpo_config_names[] = {\n\t\"ti,gpo-config-1\",\n\t\"ti,gpo-config-2\",\n\t\"ti,gpo-config-3\",\n\t\"ti,gpo-config-4\",\n};\n\nstatic const struct reg_default adcx140_reg_defaults[] = {\n\t{ ADCX140_PAGE_SELECT, 0x00 },\n\t{ ADCX140_SW_RESET, 0x00 },\n\t{ ADCX140_SLEEP_CFG, 0x00 },\n\t{ ADCX140_SHDN_CFG, 0x05 },\n\t{ ADCX140_ASI_CFG0, 0x30 },\n\t{ ADCX140_ASI_CFG1, 0x00 },\n\t{ ADCX140_ASI_CFG2, 0x00 },\n\t{ ADCX140_ASI_CH1, 0x00 },\n\t{ ADCX140_ASI_CH2, 0x01 },\n\t{ ADCX140_ASI_CH3, 0x02 },\n\t{ ADCX140_ASI_CH4, 0x03 },\n\t{ ADCX140_ASI_CH5, 0x04 },\n\t{ ADCX140_ASI_CH6, 0x05 },\n\t{ ADCX140_ASI_CH7, 0x06 },\n\t{ ADCX140_ASI_CH8, 0x07 },\n\t{ ADCX140_MST_CFG0, 0x02 },\n\t{ ADCX140_MST_CFG1, 0x48 },\n\t{ ADCX140_ASI_STS, 0xff },\n\t{ ADCX140_CLK_SRC, 0x10 },\n\t{ ADCX140_PDMCLK_CFG, 0x40 },\n\t{ ADCX140_PDM_CFG, 0x00 },\n\t{ ADCX140_GPIO_CFG0, 0x22 },\n\t{ ADCX140_GPO_CFG0, 0x00 },\n\t{ ADCX140_GPO_CFG1, 0x00 },\n\t{ ADCX140_GPO_CFG2, 0x00 },\n\t{ ADCX140_GPO_CFG3, 0x00 },\n\t{ ADCX140_GPO_VAL, 0x00 },\n\t{ ADCX140_GPIO_MON, 0x00 },\n\t{ ADCX140_GPI_CFG0, 0x00 },\n\t{ ADCX140_GPI_CFG1, 0x00 },\n\t{ ADCX140_GPI_MON, 0x00 },\n\t{ ADCX140_INT_CFG, 0x00 },\n\t{ ADCX140_INT_MASK0, 0xff },\n\t{ ADCX140_INT_LTCH0, 0x00 },\n\t{ ADCX140_BIAS_CFG, 0x00 },\n\t{ ADCX140_CH1_CFG0, 0x00 },\n\t{ ADCX140_CH1_CFG1, 0x00 },\n\t{ ADCX140_CH1_CFG2, 0xc9 },\n\t{ ADCX140_CH1_CFG3, 0x80 },\n\t{ ADCX140_CH1_CFG4, 0x00 },\n\t{ ADCX140_CH2_CFG0, 0x00 },\n\t{ ADCX140_CH2_CFG1, 0x00 },\n\t{ ADCX140_CH2_CFG2, 0xc9 },\n\t{ ADCX140_CH2_CFG3, 0x80 },\n\t{ ADCX140_CH2_CFG4, 0x00 },\n\t{ ADCX140_CH3_CFG0, 0x00 },\n\t{ ADCX140_CH3_CFG1, 0x00 },\n\t{ ADCX140_CH3_CFG2, 0xc9 },\n\t{ ADCX140_CH3_CFG3, 0x80 },\n\t{ ADCX140_CH3_CFG4, 0x00 },\n\t{ ADCX140_CH4_CFG0, 0x00 },\n\t{ ADCX140_CH4_CFG1, 0x00 },\n\t{ ADCX140_CH4_CFG2, 0xc9 },\n\t{ ADCX140_CH4_CFG3, 0x80 },\n\t{ ADCX140_CH4_CFG4, 0x00 },\n\t{ ADCX140_CH5_CFG2, 0xc9 },\n\t{ ADCX140_CH5_CFG3, 0x80 },\n\t{ ADCX140_CH5_CFG4, 0x00 },\n\t{ ADCX140_CH6_CFG2, 0xc9 },\n\t{ ADCX140_CH6_CFG3, 0x80 },\n\t{ ADCX140_CH6_CFG4, 0x00 },\n\t{ ADCX140_CH7_CFG2, 0xc9 },\n\t{ ADCX140_CH7_CFG3, 0x80 },\n\t{ ADCX140_CH7_CFG4, 0x00 },\n\t{ ADCX140_CH8_CFG2, 0xc9 },\n\t{ ADCX140_CH8_CFG3, 0x80 },\n\t{ ADCX140_CH8_CFG4, 0x00 },\n\t{ ADCX140_DSP_CFG0, 0x01 },\n\t{ ADCX140_DSP_CFG1, 0x40 },\n\t{ ADCX140_DRE_CFG0, 0x7b },\n\t{ ADCX140_AGC_CFG0, 0xe7 },\n\t{ ADCX140_IN_CH_EN, 0xf0 },\n\t{ ADCX140_ASI_OUT_CH_EN, 0x00 },\n\t{ ADCX140_PWR_CFG, 0x00 },\n\t{ ADCX140_DEV_STS0, 0x00 },\n\t{ ADCX140_DEV_STS1, 0x80 },\n};\n\nstatic const struct regmap_range_cfg adcx140_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 12 * 128,\n\t\t.selector_reg = ADCX140_PAGE_SELECT,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t},\n};\n\nstatic bool adcx140_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADCX140_SW_RESET:\n\tcase ADCX140_DEV_STS0:\n\tcase ADCX140_DEV_STS1:\n\tcase ADCX140_ASI_STS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config adcx140_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_defaults = adcx140_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adcx140_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n\t.ranges = adcx140_ranges,\n\t.num_ranges = ARRAY_SIZE(adcx140_ranges),\n\t.max_register = 12 * 128,\n\t.volatile_reg = adcx140_volatile,\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(dig_vol_tlv, -10050, 50, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(adc_tlv, 0, 100, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(dre_thresh_tlv, -6600, 100, 0);\n \nstatic DECLARE_TLV_DB_SCALE(dre_gain_tlv, 200, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(agc_thresh_tlv, -3600, 200, 0);\n \nstatic DECLARE_TLV_DB_SCALE(agc_gain_tlv, 300, 300, 0);\n\nstatic const char * const decimation_filter_text[] = {\n\t\"Linear Phase\", \"Low Latency\", \"Ultra-low Latency\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(decimation_filter_enum, ADCX140_DSP_CFG0, 4,\n\t\t\t    decimation_filter_text);\n\nstatic const struct snd_kcontrol_new decimation_filter_controls[] = {\n\tSOC_DAPM_ENUM(\"Decimation Filter\", decimation_filter_enum),\n};\n\nstatic const char * const pdmclk_text[] = {\n\t\"2.8224 MHz\", \"1.4112 MHz\", \"705.6 kHz\", \"5.6448 MHz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(pdmclk_select_enum, ADCX140_PDMCLK_CFG, 0,\n\t\t\t    pdmclk_text);\n\nstatic const struct snd_kcontrol_new pdmclk_div_controls[] = {\n\tSOC_DAPM_ENUM(\"PDM Clk Divider Select\", pdmclk_select_enum),\n};\n\nstatic const char * const resistor_text[] = {\n\t\"2.5 kOhm\", \"10 kOhm\", \"20 kOhm\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(in1_resistor_enum, ADCX140_CH1_CFG0, 2,\n\t\t\t    resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in2_resistor_enum, ADCX140_CH2_CFG0, 2,\n\t\t\t    resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in3_resistor_enum, ADCX140_CH3_CFG0, 2,\n\t\t\t    resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in4_resistor_enum, ADCX140_CH4_CFG0, 2,\n\t\t\t    resistor_text);\n\nstatic const struct snd_kcontrol_new in1_resistor_controls[] = {\n\tSOC_DAPM_ENUM(\"CH1 Resistor Select\", in1_resistor_enum),\n};\nstatic const struct snd_kcontrol_new in2_resistor_controls[] = {\n\tSOC_DAPM_ENUM(\"CH2 Resistor Select\", in2_resistor_enum),\n};\nstatic const struct snd_kcontrol_new in3_resistor_controls[] = {\n\tSOC_DAPM_ENUM(\"CH3 Resistor Select\", in3_resistor_enum),\n};\nstatic const struct snd_kcontrol_new in4_resistor_controls[] = {\n\tSOC_DAPM_ENUM(\"CH4 Resistor Select\", in4_resistor_enum),\n};\n\n \nstatic const char * const adcx140_mic_sel_text[] = {\"Analog\", \"Line In\", \"Digital\"};\nstatic const char * const adcx140_analog_sel_text[] = {\"Analog\", \"Line In\"};\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic1p_enum,\n\t\t\t    ADCX140_CH1_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic1p_control =\nSOC_DAPM_ENUM(\"MIC1P MUX\", adcx140_mic1p_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic1_analog_enum,\n\t\t\t    ADCX140_CH1_CFG0, 7,\n\t\t\t    adcx140_analog_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic1_analog_control =\nSOC_DAPM_ENUM(\"MIC1 Analog MUX\", adcx140_mic1_analog_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic1m_enum,\n\t\t\t    ADCX140_CH1_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic1m_control =\nSOC_DAPM_ENUM(\"MIC1M MUX\", adcx140_mic1m_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic2p_enum,\n\t\t\t    ADCX140_CH2_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic2p_control =\nSOC_DAPM_ENUM(\"MIC2P MUX\", adcx140_mic2p_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic2_analog_enum,\n\t\t\t    ADCX140_CH2_CFG0, 7,\n\t\t\t    adcx140_analog_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic2_analog_control =\nSOC_DAPM_ENUM(\"MIC2 Analog MUX\", adcx140_mic2_analog_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic2m_enum,\n\t\t\t    ADCX140_CH2_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic2m_control =\nSOC_DAPM_ENUM(\"MIC2M MUX\", adcx140_mic2m_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic3p_enum,\n\t\t\t    ADCX140_CH3_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic3p_control =\nSOC_DAPM_ENUM(\"MIC3P MUX\", adcx140_mic3p_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic3_analog_enum,\n\t\t\t    ADCX140_CH3_CFG0, 7,\n\t\t\t    adcx140_analog_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic3_analog_control =\nSOC_DAPM_ENUM(\"MIC3 Analog MUX\", adcx140_mic3_analog_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic3m_enum,\n\t\t\t    ADCX140_CH3_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic3m_control =\nSOC_DAPM_ENUM(\"MIC3M MUX\", adcx140_mic3m_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic4p_enum,\n\t\t\t    ADCX140_CH4_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic4p_control =\nSOC_DAPM_ENUM(\"MIC4P MUX\", adcx140_mic4p_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic4_analog_enum,\n\t\t\t    ADCX140_CH4_CFG0, 7,\n\t\t\t    adcx140_analog_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic4_analog_control =\nSOC_DAPM_ENUM(\"MIC4 Analog MUX\", adcx140_mic4_analog_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adcx140_mic4m_enum,\n\t\t\t    ADCX140_CH4_CFG0, 5,\n\t\t\t    adcx140_mic_sel_text);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_mic4m_control =\nSOC_DAPM_ENUM(\"MIC4M MUX\", adcx140_mic4m_enum);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_ch1_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 7, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch2_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 6, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch3_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 5, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch4_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 4, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch5_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 3, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch6_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 2, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch7_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 1, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch8_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_ASI_OUT_CH_EN, 0, 1, 0);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_ch1_dre_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_CH1_CFG0, 0, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch2_dre_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_CH2_CFG0, 0, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch3_dre_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_CH3_CFG0, 0, 1, 0);\nstatic const struct snd_kcontrol_new adcx140_dapm_ch4_dre_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_CH4_CFG0, 0, 1, 0);\n\nstatic const struct snd_kcontrol_new adcx140_dapm_dre_en_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", ADCX140_DSP_CFG1, 3, 1, 0);\n\n \nstatic const struct snd_kcontrol_new adcx140_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Digital CH1 Switch\", 0, 0, 0, 0),\n\tSOC_DAPM_SINGLE(\"Digital CH2 Switch\", 0, 0, 0, 0),\n\tSOC_DAPM_SINGLE(\"Digital CH3 Switch\", 0, 0, 0, 0),\n\tSOC_DAPM_SINGLE(\"Digital CH4 Switch\", 0, 0, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_widget adcx140_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"MIC1P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1M\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2M\"),\n\tSND_SOC_DAPM_INPUT(\"MIC3P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC3M\"),\n\tSND_SOC_DAPM_INPUT(\"MIC4P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC4M\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"CH1_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH2_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH3_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH4_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH5_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH6_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH7_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"CH8_OUT\"),\n\n\tSND_SOC_DAPM_MIXER(\"Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&adcx140_output_mixer_controls[0],\n\t\tARRAY_SIZE(adcx140_output_mixer_controls)),\n\n\t \n\tSND_SOC_DAPM_MUX(\"MIC1P Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic1p_control),\n\tSND_SOC_DAPM_MUX(\"MIC2P Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic2p_control),\n\tSND_SOC_DAPM_MUX(\"MIC3P Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic3p_control),\n\tSND_SOC_DAPM_MUX(\"MIC4P Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic4p_control),\n\n\t \n\tSND_SOC_DAPM_MUX(\"MIC1 Analog Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic1_analog_control),\n\tSND_SOC_DAPM_MUX(\"MIC2 Analog Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic2_analog_control),\n\tSND_SOC_DAPM_MUX(\"MIC3 Analog Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic3_analog_control),\n\tSND_SOC_DAPM_MUX(\"MIC4 Analog Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic4_analog_control),\n\n\tSND_SOC_DAPM_MUX(\"MIC1M Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic1m_control),\n\tSND_SOC_DAPM_MUX(\"MIC2M Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic2m_control),\n\tSND_SOC_DAPM_MUX(\"MIC3M Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic3m_control),\n\tSND_SOC_DAPM_MUX(\"MIC4M Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adcx140_dapm_mic4m_control),\n\n\tSND_SOC_DAPM_PGA(\"MIC_GAIN_CTL_CH1\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"MIC_GAIN_CTL_CH2\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"MIC_GAIN_CTL_CH3\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"MIC_GAIN_CTL_CH4\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"CH1_ADC\", \"CH1 Capture\", ADCX140_IN_CH_EN, 7, 0),\n\tSND_SOC_DAPM_ADC(\"CH2_ADC\", \"CH2 Capture\", ADCX140_IN_CH_EN, 6, 0),\n\tSND_SOC_DAPM_ADC(\"CH3_ADC\", \"CH3 Capture\", ADCX140_IN_CH_EN, 5, 0),\n\tSND_SOC_DAPM_ADC(\"CH4_ADC\", \"CH4 Capture\", ADCX140_IN_CH_EN, 4, 0),\n\n\tSND_SOC_DAPM_ADC(\"CH1_DIG\", \"CH1 Capture\", ADCX140_IN_CH_EN, 7, 0),\n\tSND_SOC_DAPM_ADC(\"CH2_DIG\", \"CH2 Capture\", ADCX140_IN_CH_EN, 6, 0),\n\tSND_SOC_DAPM_ADC(\"CH3_DIG\", \"CH3 Capture\", ADCX140_IN_CH_EN, 5, 0),\n\tSND_SOC_DAPM_ADC(\"CH4_DIG\", \"CH4 Capture\", ADCX140_IN_CH_EN, 4, 0),\n\tSND_SOC_DAPM_ADC(\"CH5_DIG\", \"CH5 Capture\", ADCX140_IN_CH_EN, 3, 0),\n\tSND_SOC_DAPM_ADC(\"CH6_DIG\", \"CH6 Capture\", ADCX140_IN_CH_EN, 2, 0),\n\tSND_SOC_DAPM_ADC(\"CH7_DIG\", \"CH7 Capture\", ADCX140_IN_CH_EN, 1, 0),\n\tSND_SOC_DAPM_ADC(\"CH8_DIG\", \"CH8 Capture\", ADCX140_IN_CH_EN, 0, 0),\n\n\n\tSND_SOC_DAPM_SWITCH(\"CH1_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch1_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH2_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch2_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH3_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch3_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH4_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch4_en_switch),\n\n\tSND_SOC_DAPM_SWITCH(\"CH5_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch5_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH6_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch6_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH7_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch7_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH8_ASI_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch8_en_switch),\n\n\tSND_SOC_DAPM_SWITCH(\"DRE_ENABLE\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_dre_en_switch),\n\n\tSND_SOC_DAPM_SWITCH(\"CH1_DRE_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch1_dre_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH2_DRE_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch2_dre_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH3_DRE_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch3_dre_en_switch),\n\tSND_SOC_DAPM_SWITCH(\"CH4_DRE_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adcx140_dapm_ch4_dre_en_switch),\n\n\tSND_SOC_DAPM_MUX(\"IN1 Analog Mic Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin1_resistor_controls),\n\tSND_SOC_DAPM_MUX(\"IN2 Analog Mic Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin2_resistor_controls),\n\tSND_SOC_DAPM_MUX(\"IN3 Analog Mic Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin3_resistor_controls),\n\tSND_SOC_DAPM_MUX(\"IN4 Analog Mic Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin4_resistor_controls),\n\n\tSND_SOC_DAPM_MUX(\"PDM Clk Div Select\", SND_SOC_NOPM, 0, 0,\n\t\t\tpdmclk_div_controls),\n\n\tSND_SOC_DAPM_MUX(\"Decimation Filter\", SND_SOC_NOPM, 0, 0,\n\t\t\tdecimation_filter_controls),\n};\n\nstatic const struct snd_soc_dapm_route adcx140_audio_map[] = {\n\t \n\t{\"CH1_OUT\", NULL, \"Output Mixer\"},\n\t{\"CH2_OUT\", NULL, \"Output Mixer\"},\n\t{\"CH3_OUT\", NULL, \"Output Mixer\"},\n\t{\"CH4_OUT\", NULL, \"Output Mixer\"},\n\n\t{\"CH1_ASI_EN\", \"Switch\", \"CH1_ADC\"},\n\t{\"CH2_ASI_EN\", \"Switch\", \"CH2_ADC\"},\n\t{\"CH3_ASI_EN\", \"Switch\", \"CH3_ADC\"},\n\t{\"CH4_ASI_EN\", \"Switch\", \"CH4_ADC\"},\n\n\t{\"CH1_ASI_EN\", \"Switch\", \"CH1_DIG\"},\n\t{\"CH2_ASI_EN\", \"Switch\", \"CH2_DIG\"},\n\t{\"CH3_ASI_EN\", \"Switch\", \"CH3_DIG\"},\n\t{\"CH4_ASI_EN\", \"Switch\", \"CH4_DIG\"},\n\t{\"CH5_ASI_EN\", \"Switch\", \"CH5_DIG\"},\n\t{\"CH6_ASI_EN\", \"Switch\", \"CH6_DIG\"},\n\t{\"CH7_ASI_EN\", \"Switch\", \"CH7_DIG\"},\n\t{\"CH8_ASI_EN\", \"Switch\", \"CH8_DIG\"},\n\n\t{\"CH5_ASI_EN\", \"Switch\", \"CH5_OUT\"},\n\t{\"CH6_ASI_EN\", \"Switch\", \"CH6_OUT\"},\n\t{\"CH7_ASI_EN\", \"Switch\", \"CH7_OUT\"},\n\t{\"CH8_ASI_EN\", \"Switch\", \"CH8_OUT\"},\n\n\t{\"Decimation Filter\", \"Linear Phase\", \"DRE_ENABLE\"},\n\t{\"Decimation Filter\", \"Low Latency\", \"DRE_ENABLE\"},\n\t{\"Decimation Filter\", \"Ultra-low Latency\", \"DRE_ENABLE\"},\n\n\t{\"DRE_ENABLE\", \"Switch\", \"CH1_DRE_EN\"},\n\t{\"DRE_ENABLE\", \"Switch\", \"CH2_DRE_EN\"},\n\t{\"DRE_ENABLE\", \"Switch\", \"CH3_DRE_EN\"},\n\t{\"DRE_ENABLE\", \"Switch\", \"CH4_DRE_EN\"},\n\n\t{\"CH1_DRE_EN\", \"Switch\", \"CH1_ADC\"},\n\t{\"CH2_DRE_EN\", \"Switch\", \"CH2_ADC\"},\n\t{\"CH3_DRE_EN\", \"Switch\", \"CH3_ADC\"},\n\t{\"CH4_DRE_EN\", \"Switch\", \"CH4_ADC\"},\n\n\t \n\t{\"CH1_ADC\", NULL, \"MIC_GAIN_CTL_CH1\"},\n\t{\"CH2_ADC\", NULL, \"MIC_GAIN_CTL_CH2\"},\n\t{\"CH3_ADC\", NULL, \"MIC_GAIN_CTL_CH3\"},\n\t{\"CH4_ADC\", NULL, \"MIC_GAIN_CTL_CH4\"},\n\n\t{\"MIC_GAIN_CTL_CH1\", NULL, \"IN1 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH1\", NULL, \"IN1 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH2\", NULL, \"IN2 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH2\", NULL, \"IN2 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH3\", NULL, \"IN3 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH3\", NULL, \"IN3 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH4\", NULL, \"IN4 Analog Mic Resistor\"},\n\t{\"MIC_GAIN_CTL_CH4\", NULL, \"IN4 Analog Mic Resistor\"},\n\n\t{\"IN1 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC1P Input Mux\"},\n\t{\"IN1 Analog Mic Resistor\", \"10 kOhm\", \"MIC1P Input Mux\"},\n\t{\"IN1 Analog Mic Resistor\", \"20 kOhm\", \"MIC1P Input Mux\"},\n\n\t{\"IN1 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC1M Input Mux\"},\n\t{\"IN1 Analog Mic Resistor\", \"10 kOhm\", \"MIC1M Input Mux\"},\n\t{\"IN1 Analog Mic Resistor\", \"20 kOhm\", \"MIC1M Input Mux\"},\n\n\t{\"IN2 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC2P Input Mux\"},\n\t{\"IN2 Analog Mic Resistor\", \"10 kOhm\", \"MIC2P Input Mux\"},\n\t{\"IN2 Analog Mic Resistor\", \"20 kOhm\", \"MIC2P Input Mux\"},\n\n\t{\"IN2 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC2M Input Mux\"},\n\t{\"IN2 Analog Mic Resistor\", \"10 kOhm\", \"MIC2M Input Mux\"},\n\t{\"IN2 Analog Mic Resistor\", \"20 kOhm\", \"MIC2M Input Mux\"},\n\n\t{\"IN3 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC3P Input Mux\"},\n\t{\"IN3 Analog Mic Resistor\", \"10 kOhm\", \"MIC3P Input Mux\"},\n\t{\"IN3 Analog Mic Resistor\", \"20 kOhm\", \"MIC3P Input Mux\"},\n\n\t{\"IN3 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC3M Input Mux\"},\n\t{\"IN3 Analog Mic Resistor\", \"10 kOhm\", \"MIC3M Input Mux\"},\n\t{\"IN3 Analog Mic Resistor\", \"20 kOhm\", \"MIC3M Input Mux\"},\n\n\t{\"IN4 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC4P Input Mux\"},\n\t{\"IN4 Analog Mic Resistor\", \"10 kOhm\", \"MIC4P Input Mux\"},\n\t{\"IN4 Analog Mic Resistor\", \"20 kOhm\", \"MIC4P Input Mux\"},\n\n\t{\"IN4 Analog Mic Resistor\", \"2.5 kOhm\", \"MIC4M Input Mux\"},\n\t{\"IN4 Analog Mic Resistor\", \"10 kOhm\", \"MIC4M Input Mux\"},\n\t{\"IN4 Analog Mic Resistor\", \"20 kOhm\", \"MIC4M Input Mux\"},\n\n\t{\"PDM Clk Div Select\", \"2.8224 MHz\", \"MIC1P Input Mux\"},\n\t{\"PDM Clk Div Select\", \"1.4112 MHz\", \"MIC1P Input Mux\"},\n\t{\"PDM Clk Div Select\", \"705.6 kHz\", \"MIC1P Input Mux\"},\n\t{\"PDM Clk Div Select\", \"5.6448 MHz\", \"MIC1P Input Mux\"},\n\n\t{\"MIC1P Input Mux\", NULL, \"CH1_DIG\"},\n\t{\"MIC1M Input Mux\", NULL, \"CH2_DIG\"},\n\t{\"MIC2P Input Mux\", NULL, \"CH3_DIG\"},\n\t{\"MIC2M Input Mux\", NULL, \"CH4_DIG\"},\n\t{\"MIC3P Input Mux\", NULL, \"CH5_DIG\"},\n\t{\"MIC3M Input Mux\", NULL, \"CH6_DIG\"},\n\t{\"MIC4P Input Mux\", NULL, \"CH7_DIG\"},\n\t{\"MIC4M Input Mux\", NULL, \"CH8_DIG\"},\n\n\t{\"MIC1 Analog Mux\", \"Line In\", \"MIC1P\"},\n\t{\"MIC2 Analog Mux\", \"Line In\", \"MIC2P\"},\n\t{\"MIC3 Analog Mux\", \"Line In\", \"MIC3P\"},\n\t{\"MIC4 Analog Mux\", \"Line In\", \"MIC4P\"},\n\n\t{\"MIC1P Input Mux\", \"Analog\", \"MIC1P\"},\n\t{\"MIC1M Input Mux\", \"Analog\", \"MIC1M\"},\n\t{\"MIC2P Input Mux\", \"Analog\", \"MIC2P\"},\n\t{\"MIC2M Input Mux\", \"Analog\", \"MIC2M\"},\n\t{\"MIC3P Input Mux\", \"Analog\", \"MIC3P\"},\n\t{\"MIC3M Input Mux\", \"Analog\", \"MIC3M\"},\n\t{\"MIC4P Input Mux\", \"Analog\", \"MIC4P\"},\n\t{\"MIC4M Input Mux\", \"Analog\", \"MIC4M\"},\n\n\t{\"MIC1P Input Mux\", \"Digital\", \"MIC1P\"},\n\t{\"MIC1M Input Mux\", \"Digital\", \"MIC1M\"},\n\t{\"MIC2P Input Mux\", \"Digital\", \"MIC2P\"},\n\t{\"MIC2M Input Mux\", \"Digital\", \"MIC2M\"},\n\t{\"MIC3P Input Mux\", \"Digital\", \"MIC3P\"},\n\t{\"MIC3M Input Mux\", \"Digital\", \"MIC3M\"},\n\t{\"MIC4P Input Mux\", \"Digital\", \"MIC4P\"},\n\t{\"MIC4M Input Mux\", \"Digital\", \"MIC4M\"},\n};\n\n#define ADCX140_PHASE_CALIB_SWITCH(xname) {\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.info = adcx140_phase_calib_info, \\\n\t.get = adcx140_phase_calib_get, \\\n\t.put = adcx140_phase_calib_put}\n\nstatic int adcx140_phase_calib_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int adcx140_phase_calib_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_soc_component *codec =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(codec);\n\n\tvalue->value.integer.value[0] = adcx140->phase_calib_on ? 1 : 0;\n\n\n\treturn 0;\n}\n\nstatic int adcx140_phase_calib_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_soc_component *codec\n\t\t= snd_soc_kcontrol_component(kcontrol);\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(codec);\n\n\tbool v = value->value.integer.value[0] ? true : false;\n\n\tif (adcx140->phase_calib_on != v) {\n\t\tadcx140->phase_calib_on = v;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new adcx140_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Analog CH1 Mic Gain Volume\", ADCX140_CH1_CFG1, 2, 42, 0,\n\t\t\tadc_tlv),\n\tSOC_SINGLE_TLV(\"Analog CH2 Mic Gain Volume\", ADCX140_CH2_CFG1, 2, 42, 0,\n\t\t\tadc_tlv),\n\tSOC_SINGLE_TLV(\"Analog CH3 Mic Gain Volume\", ADCX140_CH3_CFG1, 2, 42, 0,\n\t\t\tadc_tlv),\n\tSOC_SINGLE_TLV(\"Analog CH4 Mic Gain Volume\", ADCX140_CH4_CFG1, 2, 42, 0,\n\t\t\tadc_tlv),\n\n\tSOC_SINGLE_TLV(\"DRE Threshold\", ADCX140_DRE_CFG0, 4, 9, 0,\n\t\t       dre_thresh_tlv),\n\tSOC_SINGLE_TLV(\"DRE Max Gain\", ADCX140_DRE_CFG0, 0, 12, 0,\n\t\t       dre_gain_tlv),\n\n\tSOC_SINGLE_TLV(\"AGC Threshold\", ADCX140_AGC_CFG0, 4, 15, 0,\n\t\t       agc_thresh_tlv),\n\tSOC_SINGLE_TLV(\"AGC Max Gain\", ADCX140_AGC_CFG0, 0, 13, 0,\n\t\t       agc_gain_tlv),\n\n\tSOC_SINGLE_TLV(\"Digital CH1 Out Volume\", ADCX140_CH1_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH2 Out Volume\", ADCX140_CH2_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH3 Out Volume\", ADCX140_CH3_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH4 Out Volume\", ADCX140_CH4_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH5 Out Volume\", ADCX140_CH5_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH6 Out Volume\", ADCX140_CH6_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH7 Out Volume\", ADCX140_CH7_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital CH8 Out Volume\", ADCX140_CH8_CFG2,\n\t\t\t0, 0xff, 0, dig_vol_tlv),\n\tADCX140_PHASE_CALIB_SWITCH(\"Phase Calibration Switch\"),\n};\n\nstatic int adcx140_reset(struct adcx140_priv *adcx140)\n{\n\tint ret = 0;\n\n\tif (adcx140->gpio_reset) {\n\t\tgpiod_direction_output(adcx140->gpio_reset, 0);\n\t\t \n\t\tusleep_range(30000, 100000);\n\t\tgpiod_direction_output(adcx140->gpio_reset, 1);\n\t} else {\n\t\tret = regmap_write(adcx140->regmap, ADCX140_SW_RESET,\n\t\t\t\t   ADCX140_RESET);\n\t}\n\n\t \n\tusleep_range(10000, 100000);\n\n\treturn ret;\n}\n\nstatic void adcx140_pwr_ctrl(struct adcx140_priv *adcx140, bool power_state)\n{\n\tint pwr_ctrl = 0;\n\tint ret = 0;\n\tstruct snd_soc_component *component = adcx140->component;\n\n\tif (power_state)\n\t\tpwr_ctrl = ADCX140_PWR_CFG_ADC_PDZ | ADCX140_PWR_CFG_PLL_PDZ;\n\n\tif (adcx140->micbias_vg && power_state)\n\t\tpwr_ctrl |= ADCX140_PWR_CFG_BIAS_PDZ;\n\n\tif (pwr_ctrl) {\n\t\tret = regmap_write(adcx140->regmap, ADCX140_PHASE_CALIB,\n\t\t\tadcx140->phase_calib_on ? 0x00 : 0x40);\n\t\tif (ret)\n\t\t\tdev_err(component->dev, \"%s: register write error %d\\n\",\n\t\t\t\t__func__, ret);\n\t}\n\n\tregmap_update_bits(adcx140->regmap, ADCX140_PWR_CFG,\n\t\t\t   ADCX140_PWR_CTRL_MSK, pwr_ctrl);\n}\n\nstatic int adcx140_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(component);\n\tu8 data = 0;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tdata = ADCX140_16_BIT_WORD;\n\t\tbreak;\n\tcase 20:\n\t\tdata = ADCX140_20_BIT_WORD;\n\t\tbreak;\n\tcase 24:\n\t\tdata = ADCX140_24_BIT_WORD;\n\t\tbreak;\n\tcase 32:\n\t\tdata = ADCX140_32_BIT_WORD;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: Unsupported width %d\\n\",\n\t\t\t__func__, params_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tadcx140_pwr_ctrl(adcx140, false);\n\n\tsnd_soc_component_update_bits(component, ADCX140_ASI_CFG0,\n\t\t\t    ADCX140_WORD_LEN_MSK, data);\n\n\tadcx140_pwr_ctrl(adcx140, true);\n\n\treturn 0;\n}\n\nstatic int adcx140_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(component);\n\tu8 iface_reg1 = 0;\n\tu8 iface_reg2 = 0;\n\tint offset = 0;\n\tbool inverted_bclk = false;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface_reg2 |= ADCX140_BCLK_FSYNC_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock provider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface_reg1 |= ADCX140_I2S_MODE_BIT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface_reg1 |= ADCX140_LEFT_JUST_BIT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\toffset = 1;\n\t\tinverted_bclk = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tinverted_bclk = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI interface format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tinverted_bclk = !inverted_bclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface_reg1 |= ADCX140_FSYNCINV_BIT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock signal polarity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (inverted_bclk)\n\t\tiface_reg1 |= ADCX140_BCLKINV_BIT;\n\n\tadcx140->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tadcx140_pwr_ctrl(adcx140, false);\n\n\tsnd_soc_component_update_bits(component, ADCX140_ASI_CFG0,\n\t\t\t\t      ADCX140_FSYNCINV_BIT |\n\t\t\t\t      ADCX140_BCLKINV_BIT |\n\t\t\t\t      ADCX140_ASI_FORMAT_MSK,\n\t\t\t\t      iface_reg1);\n\tsnd_soc_component_update_bits(component, ADCX140_MST_CFG0,\n\t\t\t\t      ADCX140_BCLK_FSYNC_MASTER, iface_reg2);\n\n\t \n\tsnd_soc_component_update_bits(component, ADCX140_ASI_CFG1,\n\t\t\t\t      ADCX140_TX_OFFSET_MASK, offset);\n\n\tadcx140_pwr_ctrl(adcx140, true);\n\n\treturn 0;\n}\n\nstatic int adcx140_set_dai_tdm_slot(struct snd_soc_dai *codec_dai,\n\t\t\t\t  unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t  int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (tx_mask != GENMASK(__fls(tx_mask), 0)) {\n\t\tdev_err(component->dev, \"Only lower adjacent slots are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slot_width) {\n\tcase 16:\n\tcase 20:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported slot width %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tadcx140->slot_width = slot_width;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops adcx140_dai_ops = {\n\t.hw_params\t= adcx140_hw_params,\n\t.set_fmt\t= adcx140_set_dai_fmt,\n\t.set_tdm_slot\t= adcx140_set_dai_tdm_slot,\n};\n\nstatic int adcx140_configure_gpo(struct adcx140_priv *adcx140)\n{\n\tu32 gpo_outputs[ADCX140_NUM_GPOS];\n\tu32 gpo_output_val = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ADCX140_NUM_GPOS; i++) {\n\t\tret = device_property_read_u32_array(adcx140->dev,\n\t\t\t\t\t\t     gpo_config_names[i],\n\t\t\t\t\t\t     gpo_outputs,\n\t\t\t\t\t\t     ADCX140_NUM_GPO_CFGS);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (gpo_outputs[0] > ADCX140_GPO_CFG_MAX) {\n\t\t\tdev_err(adcx140->dev, \"GPO%d config out of range\\n\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (gpo_outputs[1] > ADCX140_GPO_DRV_MAX) {\n\t\t\tdev_err(adcx140->dev, \"GPO%d drive out of range\\n\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgpo_output_val = gpo_outputs[0] << ADCX140_GPO_SHIFT |\n\t\t\t\t gpo_outputs[1];\n\t\tret = regmap_write(adcx140->regmap, ADCX140_GPO_CFG0 + i,\n\t\t\t\t   gpo_output_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int adcx140_configure_gpio(struct adcx140_priv *adcx140)\n{\n\tint gpio_count = 0;\n\tu32 gpio_outputs[ADCX140_NUM_GPIO_CFGS];\n\tu32 gpio_output_val = 0;\n\tint ret;\n\n\tgpio_count = device_property_count_u32(adcx140->dev,\n\t\t\t\"ti,gpio-config\");\n\tif (gpio_count <= 0)\n\t\treturn 0;\n\n\tif (gpio_count != ADCX140_NUM_GPIO_CFGS)\n\t\treturn -EINVAL;\n\n\tret = device_property_read_u32_array(adcx140->dev, \"ti,gpio-config\",\n\t\t\tgpio_outputs, gpio_count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gpio_outputs[0] > ADCX140_GPIO_CFG_MAX) {\n\t\tdev_err(adcx140->dev, \"GPIO config out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gpio_outputs[1] > ADCX140_GPIO_DRV_MAX) {\n\t\tdev_err(adcx140->dev, \"GPIO drive out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_output_val = gpio_outputs[0] << ADCX140_GPIO_SHIFT\n\t\t| gpio_outputs[1];\n\n\treturn regmap_write(adcx140->regmap, ADCX140_GPIO_CFG0, gpio_output_val);\n}\n\nstatic int adcx140_codec_probe(struct snd_soc_component *component)\n{\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(component);\n\tint sleep_cfg_val = ADCX140_WAKE_DEV;\n\tu32 bias_source;\n\tu32 vref_source;\n\tu8 bias_cfg;\n\tint pdm_count;\n\tu32 pdm_edges[ADCX140_NUM_PDM_EDGES];\n\tu32 pdm_edge_val = 0;\n\tint gpi_count;\n\tu32 gpi_inputs[ADCX140_NUM_GPI_PINS];\n\tu32 gpi_input_val = 0;\n\tint i;\n\tint ret;\n\tbool tx_high_z;\n\n\tret = device_property_read_u32(adcx140->dev, \"ti,mic-bias-source\",\n\t\t\t\t      &bias_source);\n\tif (ret || bias_source > ADCX140_MIC_BIAS_VAL_AVDD) {\n\t\tbias_source = ADCX140_MIC_BIAS_VAL_VREF;\n\t\tadcx140->micbias_vg = false;\n\t} else {\n\t\tadcx140->micbias_vg = true;\n\t}\n\n\tret = device_property_read_u32(adcx140->dev, \"ti,vref-source\",\n\t\t\t\t      &vref_source);\n\tif (ret)\n\t\tvref_source = ADCX140_MIC_BIAS_VREF_275V;\n\n\tif (vref_source > ADCX140_MIC_BIAS_VREF_1375V) {\n\t\tdev_err(adcx140->dev, \"Mic Bias source value is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbias_cfg = bias_source << ADCX140_MIC_BIAS_SHIFT | vref_source;\n\n\tret = adcx140_reset(adcx140);\n\tif (ret)\n\t\tgoto out;\n\n\tif (adcx140->supply_areg == NULL)\n\t\tsleep_cfg_val |= ADCX140_AREG_INTERNAL;\n\n\tret = regmap_write(adcx140->regmap, ADCX140_SLEEP_CFG, sleep_cfg_val);\n\tif (ret) {\n\t\tdev_err(adcx140->dev, \"setting sleep config failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tusleep_range(1000, 100000);\n\n\tpdm_count = device_property_count_u32(adcx140->dev,\n\t\t\t\t\t      \"ti,pdm-edge-select\");\n\tif (pdm_count <= ADCX140_NUM_PDM_EDGES && pdm_count > 0) {\n\t\tret = device_property_read_u32_array(adcx140->dev,\n\t\t\t\t\t\t     \"ti,pdm-edge-select\",\n\t\t\t\t\t\t     pdm_edges, pdm_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < pdm_count; i++)\n\t\t\tpdm_edge_val |= pdm_edges[i] << (ADCX140_PDM_EDGE_SHIFT - i);\n\n\t\tret = regmap_write(adcx140->regmap, ADCX140_PDM_CFG,\n\t\t\t\t   pdm_edge_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tgpi_count = device_property_count_u32(adcx140->dev, \"ti,gpi-config\");\n\tif (gpi_count <= ADCX140_NUM_GPI_PINS && gpi_count > 0) {\n\t\tret = device_property_read_u32_array(adcx140->dev,\n\t\t\t\t\t\t     \"ti,gpi-config\",\n\t\t\t\t\t\t     gpi_inputs, gpi_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgpi_input_val = gpi_inputs[ADCX140_GPI1_INDEX] << ADCX140_GPI_SHIFT |\n\t\t\t\tgpi_inputs[ADCX140_GPI2_INDEX];\n\n\t\tret = regmap_write(adcx140->regmap, ADCX140_GPI_CFG0,\n\t\t\t\t   gpi_input_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgpi_input_val = gpi_inputs[ADCX140_GPI3_INDEX] << ADCX140_GPI_SHIFT |\n\t\t\t\tgpi_inputs[ADCX140_GPI4_INDEX];\n\n\t\tret = regmap_write(adcx140->regmap, ADCX140_GPI_CFG1,\n\t\t\t\t   gpi_input_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adcx140_configure_gpio(adcx140);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adcx140_configure_gpo(adcx140);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_update_bits(adcx140->regmap, ADCX140_BIAS_CFG,\n\t\t\t\tADCX140_MIC_BIAS_VAL_MSK |\n\t\t\t\tADCX140_MIC_BIAS_VREF_MSK, bias_cfg);\n\tif (ret)\n\t\tdev_err(adcx140->dev, \"setting MIC bias failed %d\\n\", ret);\n\n\ttx_high_z = device_property_read_bool(adcx140->dev, \"ti,asi-tx-drive\");\n\tif (tx_high_z) {\n\t\tret = regmap_update_bits(adcx140->regmap, ADCX140_ASI_CFG0,\n\t\t\t\t ADCX140_TX_FILL, ADCX140_TX_FILL);\n\t\tif (ret) {\n\t\t\tdev_err(adcx140->dev, \"Setting Tx drive failed %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tadcx140_pwr_ctrl(adcx140, true);\nout:\n\treturn ret;\n}\n\nstatic int adcx140_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct adcx140_priv *adcx140 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tadcx140_pwr_ctrl(adcx140, true);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tadcx140_pwr_ctrl(adcx140, false);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_driver_adcx140 = {\n\t.probe\t\t\t= adcx140_codec_probe,\n\t.set_bias_level\t\t= adcx140_set_bias_level,\n\t.controls\t\t= adcx140_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adcx140_snd_controls),\n\t.dapm_widgets\t\t= adcx140_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adcx140_dapm_widgets),\n\t.dapm_routes\t\t= adcx140_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(adcx140_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 0,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver adcx140_dai_driver[] = {\n\t{\n\t\t.name = \"tlv320adcx140-codec\",\n\t\t.capture = {\n\t\t\t.stream_name\t = \"Capture\",\n\t\t\t.channels_min\t = 2,\n\t\t\t.channels_max\t = ADCX140_MAX_CHANNELS,\n\t\t\t.rates\t\t = ADCX140_RATES,\n\t\t\t.formats\t = ADCX140_FORMATS,\n\t\t},\n\t\t.ops = &adcx140_dai_ops,\n\t\t.symmetric_rate = 1,\n\t}\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tlv320adcx140_of_match[] = {\n\t{ .compatible = \"ti,tlv320adc3140\" },\n\t{ .compatible = \"ti,tlv320adc5140\" },\n\t{ .compatible = \"ti,tlv320adc6140\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tlv320adcx140_of_match);\n#endif\n\nstatic void adcx140_disable_regulator(void *arg)\n{\n\tstruct adcx140_priv *adcx140 = arg;\n\n\tregulator_disable(adcx140->supply_areg);\n}\n\nstatic int adcx140_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct adcx140_priv *adcx140;\n\tint ret;\n\n\tadcx140 = devm_kzalloc(&i2c->dev, sizeof(*adcx140), GFP_KERNEL);\n\tif (!adcx140)\n\t\treturn -ENOMEM;\n\n\tadcx140->phase_calib_on = false;\n\tadcx140->dev = &i2c->dev;\n\n\tadcx140->gpio_reset = devm_gpiod_get_optional(adcx140->dev,\n\t\t\t\t\t\t      \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(adcx140->gpio_reset))\n\t\tdev_info(&i2c->dev, \"Reset GPIO not defined\\n\");\n\n\tadcx140->supply_areg = devm_regulator_get_optional(adcx140->dev,\n\t\t\t\t\t\t\t   \"areg\");\n\tif (IS_ERR(adcx140->supply_areg)) {\n\t\tif (PTR_ERR(adcx140->supply_areg) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tadcx140->supply_areg = NULL;\n\t} else {\n\t\tret = regulator_enable(adcx140->supply_areg);\n\t\tif (ret) {\n\t\t\tdev_err(adcx140->dev, \"Failed to enable areg\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&i2c->dev, adcx140_disable_regulator, adcx140);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tadcx140->regmap = devm_regmap_init_i2c(i2c, &adcx140_i2c_regmap);\n\tif (IS_ERR(adcx140->regmap)) {\n\t\tret = PTR_ERR(adcx140->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, adcx140);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t       &soc_codec_driver_adcx140,\n\t\t\t\t\t       adcx140_dai_driver, 1);\n}\n\nstatic const struct i2c_device_id adcx140_i2c_id[] = {\n\t{ \"tlv320adc3140\", 0 },\n\t{ \"tlv320adc5140\", 1 },\n\t{ \"tlv320adc6140\", 2 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, adcx140_i2c_id);\n\nstatic struct i2c_driver adcx140_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"tlv320adcx140-codec\",\n\t\t.of_match_table = of_match_ptr(tlv320adcx140_of_match),\n\t},\n\t.probe\t\t= adcx140_i2c_probe,\n\t.id_table\t= adcx140_i2c_id,\n};\nmodule_i2c_driver(adcx140_i2c_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"ASoC TLV320ADCX140 CODEC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}