{
  "module_name": "wm8974.c",
  "hash_id": "b9f4ed306ff6f22ac1483b27d60b730d80280495934aeaa60db03bae5f41b2c0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8974.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8974.h\"\n\nstruct wm8974_priv {\n\tunsigned int mclk;\n\tunsigned int fs;\n};\n\nstatic const struct reg_default wm8974_reg_defaults[] = {\n\t{  0, 0x0000 }, {  1, 0x0000 }, {  2, 0x0000 }, {  3, 0x0000 },\n\t{  4, 0x0050 }, {  5, 0x0000 }, {  6, 0x0140 }, {  7, 0x0000 },\n\t{  8, 0x0000 }, {  9, 0x0000 }, { 10, 0x0000 }, { 11, 0x00ff },\n\t{ 12, 0x0000 }, { 13, 0x0000 }, { 14, 0x0100 }, { 15, 0x00ff },\n\t{ 16, 0x0000 }, { 17, 0x0000 }, { 18, 0x012c }, { 19, 0x002c },\n\t{ 20, 0x002c }, { 21, 0x002c }, { 22, 0x002c }, { 23, 0x0000 },\n\t{ 24, 0x0032 }, { 25, 0x0000 }, { 26, 0x0000 }, { 27, 0x0000 },\n\t{ 28, 0x0000 }, { 29, 0x0000 }, { 30, 0x0000 }, { 31, 0x0000 },\n\t{ 32, 0x0038 }, { 33, 0x000b }, { 34, 0x0032 }, { 35, 0x0000 },\n\t{ 36, 0x0008 }, { 37, 0x000c }, { 38, 0x0093 }, { 39, 0x00e9 },\n\t{ 40, 0x0000 }, { 41, 0x0000 }, { 42, 0x0000 }, { 43, 0x0000 },\n\t{ 44, 0x0003 }, { 45, 0x0010 }, { 46, 0x0000 }, { 47, 0x0000 },\n\t{ 48, 0x0000 }, { 49, 0x0002 }, { 50, 0x0000 }, { 51, 0x0000 },\n\t{ 52, 0x0000 }, { 53, 0x0000 }, { 54, 0x0039 }, { 55, 0x0000 },\n\t{ 56, 0x0000 },\n};\n\n#define WM8974_POWER1_BIASEN  0x08\n#define WM8974_POWER1_BUFIOEN 0x04\n\n#define wm8974_reset(c)\tsnd_soc_component_write(c, WM8974_RESET, 0)\n\nstatic const char *wm8974_companding[] = {\"Off\", \"NC\", \"u-law\", \"A-law\" };\nstatic const char *wm8974_deemp[] = {\"None\", \"32kHz\", \"44.1kHz\", \"48kHz\" };\nstatic const char *wm8974_eqmode[] = {\"Capture\", \"Playback\" };\nstatic const char *wm8974_bw[] = {\"Narrow\", \"Wide\" };\nstatic const char *wm8974_eq1[] = {\"80Hz\", \"105Hz\", \"135Hz\", \"175Hz\" };\nstatic const char *wm8974_eq2[] = {\"230Hz\", \"300Hz\", \"385Hz\", \"500Hz\" };\nstatic const char *wm8974_eq3[] = {\"650Hz\", \"850Hz\", \"1.1kHz\", \"1.4kHz\" };\nstatic const char *wm8974_eq4[] = {\"1.8kHz\", \"2.4kHz\", \"3.2kHz\", \"4.1kHz\" };\nstatic const char *wm8974_eq5[] = {\"5.3kHz\", \"6.9kHz\", \"9kHz\", \"11.7kHz\" };\nstatic const char *wm8974_alc[] = {\"ALC\", \"Limiter\" };\n\nstatic const struct soc_enum wm8974_enum[] = {\n\tSOC_ENUM_SINGLE(WM8974_COMP, 1, 4, wm8974_companding),  \n\tSOC_ENUM_SINGLE(WM8974_COMP, 3, 4, wm8974_companding),  \n\tSOC_ENUM_SINGLE(WM8974_DAC,  4, 4, wm8974_deemp),\n\tSOC_ENUM_SINGLE(WM8974_EQ1,  8, 2, wm8974_eqmode),\n\n\tSOC_ENUM_SINGLE(WM8974_EQ1,  5, 4, wm8974_eq1),\n\tSOC_ENUM_SINGLE(WM8974_EQ2,  8, 2, wm8974_bw),\n\tSOC_ENUM_SINGLE(WM8974_EQ2,  5, 4, wm8974_eq2),\n\tSOC_ENUM_SINGLE(WM8974_EQ3,  8, 2, wm8974_bw),\n\n\tSOC_ENUM_SINGLE(WM8974_EQ3,  5, 4, wm8974_eq3),\n\tSOC_ENUM_SINGLE(WM8974_EQ4,  8, 2, wm8974_bw),\n\tSOC_ENUM_SINGLE(WM8974_EQ4,  5, 4, wm8974_eq4),\n\tSOC_ENUM_SINGLE(WM8974_EQ5,  8, 2, wm8974_bw),\n\n\tSOC_ENUM_SINGLE(WM8974_EQ5,  5, 4, wm8974_eq5),\n\tSOC_ENUM_SINGLE(WM8974_ALC3,  8, 2, wm8974_alc),\n};\n\nstatic const char *wm8974_auxmode_text[] = { \"Buffer\", \"Mixer\" };\n\nstatic SOC_ENUM_SINGLE_DECL(wm8974_auxmode,\n\t\t\t    WM8974_INPUT,  3, wm8974_auxmode_text);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);\n\nstatic const struct snd_kcontrol_new wm8974_snd_controls[] = {\n\nSOC_SINGLE(\"Digital Loopback Switch\", WM8974_COMP, 0, 1, 0),\n\nSOC_ENUM(\"DAC Companding\", wm8974_enum[1]),\nSOC_ENUM(\"ADC Companding\", wm8974_enum[0]),\n\nSOC_ENUM(\"Playback De-emphasis\", wm8974_enum[2]),\nSOC_SINGLE(\"DAC Inversion Switch\", WM8974_DAC, 0, 1, 0),\n\nSOC_SINGLE_TLV(\"PCM Volume\", WM8974_DACVOL, 0, 255, 0, digital_tlv),\n\nSOC_SINGLE(\"High Pass Filter Switch\", WM8974_ADC, 8, 1, 0),\nSOC_SINGLE(\"High Pass Cut Off\", WM8974_ADC, 4, 7, 0),\nSOC_SINGLE(\"ADC Inversion Switch\", WM8974_ADC, 0, 1, 0),\n\nSOC_SINGLE_TLV(\"Capture Volume\", WM8974_ADCVOL,  0, 255, 0, digital_tlv),\n\nSOC_ENUM(\"Equaliser Function\", wm8974_enum[3]),\nSOC_ENUM(\"EQ1 Cut Off\", wm8974_enum[4]),\nSOC_SINGLE_TLV(\"EQ1 Volume\", WM8974_EQ1,  0, 24, 1, eq_tlv),\n\nSOC_ENUM(\"Equaliser EQ2 Bandwidth\", wm8974_enum[5]),\nSOC_ENUM(\"EQ2 Cut Off\", wm8974_enum[6]),\nSOC_SINGLE_TLV(\"EQ2 Volume\", WM8974_EQ2,  0, 24, 1, eq_tlv),\n\nSOC_ENUM(\"Equaliser EQ3 Bandwidth\", wm8974_enum[7]),\nSOC_ENUM(\"EQ3 Cut Off\", wm8974_enum[8]),\nSOC_SINGLE_TLV(\"EQ3 Volume\", WM8974_EQ3,  0, 24, 1, eq_tlv),\n\nSOC_ENUM(\"Equaliser EQ4 Bandwidth\", wm8974_enum[9]),\nSOC_ENUM(\"EQ4 Cut Off\", wm8974_enum[10]),\nSOC_SINGLE_TLV(\"EQ4 Volume\", WM8974_EQ4,  0, 24, 1, eq_tlv),\n\nSOC_ENUM(\"Equaliser EQ5 Bandwidth\", wm8974_enum[11]),\nSOC_ENUM(\"EQ5 Cut Off\", wm8974_enum[12]),\nSOC_SINGLE_TLV(\"EQ5 Volume\", WM8974_EQ5,  0, 24, 1, eq_tlv),\n\nSOC_SINGLE(\"DAC Playback Limiter Switch\", WM8974_DACLIM1,  8, 1, 0),\nSOC_SINGLE(\"DAC Playback Limiter Decay\", WM8974_DACLIM1,  4, 15, 0),\nSOC_SINGLE(\"DAC Playback Limiter Attack\", WM8974_DACLIM1,  0, 15, 0),\n\nSOC_SINGLE(\"DAC Playback Limiter Threshold\", WM8974_DACLIM2,  4, 7, 0),\nSOC_SINGLE(\"DAC Playback Limiter Boost\", WM8974_DACLIM2,  0, 15, 0),\n\nSOC_SINGLE(\"ALC Enable Switch\", WM8974_ALC1,  8, 1, 0),\nSOC_SINGLE(\"ALC Capture Max Gain\", WM8974_ALC1,  3, 7, 0),\nSOC_SINGLE(\"ALC Capture Min Gain\", WM8974_ALC1,  0, 7, 0),\n\nSOC_SINGLE(\"ALC Capture ZC Switch\", WM8974_ALC2,  8, 1, 0),\nSOC_SINGLE(\"ALC Capture Hold\", WM8974_ALC2,  4, 7, 0),\nSOC_SINGLE(\"ALC Capture Target\", WM8974_ALC2,  0, 15, 0),\n\nSOC_ENUM(\"ALC Capture Mode\", wm8974_enum[13]),\nSOC_SINGLE(\"ALC Capture Decay\", WM8974_ALC3,  4, 15, 0),\nSOC_SINGLE(\"ALC Capture Attack\", WM8974_ALC3,  0, 15, 0),\n\nSOC_SINGLE(\"ALC Capture Noise Gate Switch\", WM8974_NGATE,  3, 1, 0),\nSOC_SINGLE(\"ALC Capture Noise Gate Threshold\", WM8974_NGATE,  0, 7, 0),\n\nSOC_SINGLE(\"Capture PGA ZC Switch\", WM8974_INPPGA,  7, 1, 0),\nSOC_SINGLE_TLV(\"Capture PGA Volume\", WM8974_INPPGA,  0, 63, 0, inpga_tlv),\n\nSOC_SINGLE(\"Speaker Playback ZC Switch\", WM8974_SPKVOL,  7, 1, 0),\nSOC_SINGLE(\"Speaker Playback Switch\", WM8974_SPKVOL,  6, 1, 1),\nSOC_SINGLE_TLV(\"Speaker Playback Volume\", WM8974_SPKVOL,  0, 63, 0, spk_tlv),\n\nSOC_ENUM(\"Aux Mode\", wm8974_auxmode),\n\nSOC_SINGLE(\"Capture Boost(+20dB)\", WM8974_ADCBOOST,  8, 1, 0),\nSOC_SINGLE(\"Mono Playback Switch\", WM8974_MONOMIX, 6, 1, 1),\n\n \nSOC_SINGLE(\"DAC 128x Oversampling Switch\", WM8974_DAC, 8, 1, 0),\nSOC_SINGLE(\"ADC 128x Oversampling Switch\", WM8974_ADC, 8, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8974_speaker_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8974_SPKMIX, 1, 1, 0),\nSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8974_SPKMIX, 5, 1, 0),\nSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8974_SPKMIX, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8974_mono_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8974_MONOMIX, 1, 1, 0),\nSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8974_MONOMIX, 2, 1, 0),\nSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8974_MONOMIX, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8974_boost_mixer[] = {\nSOC_DAPM_SINGLE(\"PGA Switch\", WM8974_INPPGA, 6, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new wm8974_inpga[] = {\nSOC_DAPM_SINGLE(\"Aux Switch\", WM8974_INPUT, 2, 1, 0),\nSOC_DAPM_SINGLE(\"MicN Switch\", WM8974_INPUT, 1, 1, 0),\nSOC_DAPM_SINGLE(\"MicP Switch\", WM8974_INPUT, 0, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8974_dapm_widgets[] = {\nSND_SOC_DAPM_MIXER(\"Speaker Mixer\", WM8974_POWER3, 2, 0,\n\t&wm8974_speaker_mixer_controls[0],\n\tARRAY_SIZE(wm8974_speaker_mixer_controls)),\nSND_SOC_DAPM_MIXER(\"Mono Mixer\", WM8974_POWER3, 3, 0,\n\t&wm8974_mono_mixer_controls[0],\n\tARRAY_SIZE(wm8974_mono_mixer_controls)),\nSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", WM8974_POWER3, 0, 0),\nSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", WM8974_POWER2, 0, 0),\nSND_SOC_DAPM_PGA(\"Aux Input\", WM8974_POWER1, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"SpkN Out\", WM8974_POWER3, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"SpkP Out\", WM8974_POWER3, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Mono Out\", WM8974_POWER3, 7, 0, NULL, 0),\n\nSND_SOC_DAPM_MIXER(\"Input PGA\", WM8974_POWER2, 2, 0, wm8974_inpga,\n\t\t   ARRAY_SIZE(wm8974_inpga)),\nSND_SOC_DAPM_MIXER(\"Boost Mixer\", WM8974_POWER2, 4, 0,\n\t\t   wm8974_boost_mixer, ARRAY_SIZE(wm8974_boost_mixer)),\n\nSND_SOC_DAPM_SUPPLY(\"Mic Bias\", WM8974_POWER1, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_INPUT(\"MICN\"),\nSND_SOC_DAPM_INPUT(\"MICP\"),\nSND_SOC_DAPM_INPUT(\"AUX\"),\nSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\nSND_SOC_DAPM_OUTPUT(\"SPKOUTP\"),\nSND_SOC_DAPM_OUTPUT(\"SPKOUTN\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8974_dapm_routes[] = {\n\t \n\t{\"Mono Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Mono Mixer\", \"Aux Playback Switch\", \"Aux Input\"},\n\t{\"Mono Mixer\", \"Line Bypass Switch\", \"Boost Mixer\"},\n\n\t \n\t{\"Speaker Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Speaker Mixer\", \"Aux Playback Switch\", \"Aux Input\"},\n\t{\"Speaker Mixer\", \"Line Bypass Switch\", \"Boost Mixer\"},\n\n\t \n\t{\"Mono Out\", NULL, \"Mono Mixer\"},\n\t{\"MONOOUT\", NULL, \"Mono Out\"},\n\t{\"SpkN Out\", NULL, \"Speaker Mixer\"},\n\t{\"SpkP Out\", NULL, \"Speaker Mixer\"},\n\t{\"SPKOUTN\", NULL, \"SpkN Out\"},\n\t{\"SPKOUTP\", NULL, \"SpkP Out\"},\n\n\t \n\t{\"ADC\", NULL, \"Boost Mixer\"},\n\t{\"Boost Mixer\", NULL, \"Aux Input\"},\n\t{\"Boost Mixer\", \"PGA Switch\", \"Input PGA\"},\n\t{\"Boost Mixer\", NULL, \"MICP\"},\n\n\t \n\t{\"Input PGA\", \"Aux Switch\", \"Aux Input\"},\n\t{\"Input PGA\", \"MicN Switch\", \"MICN\"},\n\t{\"Input PGA\", \"MicP Switch\", \"MICP\"},\n\n\t \n\t{\"Aux Input\", NULL, \"AUX\"},\n};\n\nstruct pll_ {\n\tunsigned int pre_div:1;\n\tunsigned int n:4;\n\tunsigned int k;\n};\n\n \n#define FIXED_PLL_SIZE ((1 << 24) * 10)\n\nstatic void pll_factors(struct pll_ *pll_div,\n\t\t\tunsigned int target, unsigned int source)\n{\n\tunsigned long long Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\n\t \n\ttarget *= 4;\n\n\tNdiv = target / source;\n\tif (Ndiv < 6) {\n\t\tsource /= 2;\n\t\tpll_div->pre_div = 1;\n\t\tNdiv = target / source;\n\t} else\n\t\tpll_div->pre_div = 0;\n\n\tif ((Ndiv < 6) || (Ndiv > 12))\n\t\tprintk(KERN_WARNING\n\t\t\t\"WM8974 N value %u outwith recommended range!\\n\",\n\t\t\tNdiv);\n\n\tpll_div->n = Ndiv;\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\t \n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tK /= 10;\n\n\tpll_div->k = K;\n}\n\nstatic int wm8974_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct pll_ pll_div;\n\tu16 reg;\n\n\tif (freq_in == 0 || freq_out == 0) {\n\t\t \n\t\treg = snd_soc_component_read(component, WM8974_CLOCK);\n\t\tsnd_soc_component_write(component, WM8974_CLOCK, reg & 0x0ff);\n\n\t\t \n\t\treg = snd_soc_component_read(component, WM8974_POWER1);\n\t\tsnd_soc_component_write(component, WM8974_POWER1, reg & 0x1df);\n\t\treturn 0;\n\t}\n\n\tpll_factors(&pll_div, freq_out, freq_in);\n\n\tsnd_soc_component_write(component, WM8974_PLLN, (pll_div.pre_div << 4) | pll_div.n);\n\tsnd_soc_component_write(component, WM8974_PLLK1, pll_div.k >> 18);\n\tsnd_soc_component_write(component, WM8974_PLLK2, (pll_div.k >> 9) & 0x1ff);\n\tsnd_soc_component_write(component, WM8974_PLLK3, pll_div.k & 0x1ff);\n\treg = snd_soc_component_read(component, WM8974_POWER1);\n\tsnd_soc_component_write(component, WM8974_POWER1, reg | 0x020);\n\n\t \n\treg = snd_soc_component_read(component, WM8974_CLOCK);\n\tsnd_soc_component_write(component, WM8974_CLOCK, reg | 0x100);\n\n\treturn 0;\n}\n\n \nstatic int wm8974_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\tint div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\n\tswitch (div_id) {\n\tcase WM8974_OPCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8974_GPIO) & 0x1cf;\n\t\tsnd_soc_component_write(component, WM8974_GPIO, reg | div);\n\t\tbreak;\n\tcase WM8974_MCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8974_CLOCK) & 0x11f;\n\t\tsnd_soc_component_write(component, WM8974_CLOCK, reg | div);\n\t\tbreak;\n\tcase WM8974_BCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8974_CLOCK) & 0x1e3;\n\t\tsnd_soc_component_write(component, WM8974_CLOCK, reg | div);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int wm8974_get_mclkdiv(unsigned int f_in, unsigned int f_out,\n\t\t\t\t       int *mclkdiv)\n{\n\tunsigned int ratio = 2 * f_in / f_out;\n\n\tif (ratio <= 2) {\n\t\t*mclkdiv = WM8974_MCLKDIV_1;\n\t\tratio = 2;\n\t} else if (ratio == 3) {\n\t\t*mclkdiv = WM8974_MCLKDIV_1_5;\n\t} else if (ratio == 4) {\n\t\t*mclkdiv = WM8974_MCLKDIV_2;\n\t} else if (ratio <= 6) {\n\t\t*mclkdiv = WM8974_MCLKDIV_3;\n\t\tratio = 6;\n\t} else if (ratio <= 8) {\n\t\t*mclkdiv = WM8974_MCLKDIV_4;\n\t\tratio = 8;\n\t} else if (ratio <= 12) {\n\t\t*mclkdiv = WM8974_MCLKDIV_6;\n\t\tratio = 12;\n\t} else if (ratio <= 16) {\n\t\t*mclkdiv = WM8974_MCLKDIV_8;\n\t\tratio = 16;\n\t} else {\n\t\t*mclkdiv = WM8974_MCLKDIV_12;\n\t\tratio = 24;\n\t}\n\n\treturn f_out * ratio / 2;\n}\n\nstatic int wm8974_update_clocks(struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8974_priv *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int fs256;\n\tunsigned int fpll = 0;\n\tunsigned int f;\n\tint mclkdiv;\n\n\tif (!priv->mclk || !priv->fs)\n\t\treturn 0;\n\n\tfs256 = 256 * priv->fs;\n\n\tf = wm8974_get_mclkdiv(priv->mclk, fs256, &mclkdiv);\n\n\tif (f != priv->mclk) {\n\t\t \n\t\tfpll = wm8974_get_mclkdiv(22500000, fs256, &mclkdiv);\n\t}\n\n\twm8974_set_dai_pll(dai, 0, 0, priv->mclk, fpll);\n\twm8974_set_dai_clkdiv(dai, WM8974_MCLKDIV, mclkdiv);\n\n\treturn 0;\n}\n\nstatic int wm8974_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8974_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tif (dir != SND_SOC_CLOCK_IN)\n\t\treturn -EINVAL;\n\n\tpriv->mclk = freq;\n\n\treturn wm8974_update_clocks(dai);\n}\n\nstatic int wm8974_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = 0;\n\tu16 clk = snd_soc_component_read(component, WM8974_CLOCK) & 0x1fe;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tclk |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0008;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) == SND_SOC_DAIFMT_IB_IF ||\n\t\t    (fmt & SND_SOC_DAIFMT_INV_MASK) == SND_SOC_DAIFMT_NB_IF) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tiface |= 0x00018;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0180;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0100;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8974_IFACE, iface);\n\tsnd_soc_component_write(component, WM8974_CLOCK, clk);\n\treturn 0;\n}\n\nstatic int wm8974_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8974_priv *priv = snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8974_IFACE) & 0x19f;\n\tu16 adn = snd_soc_component_read(component, WM8974_ADD) & 0x1f1;\n\tint err;\n\n\tpriv->fs = params_rate(params);\n\terr = wm8974_update_clocks(dai);\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x0020;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x0040;\n\t\tbreak;\n\tcase 32:\n\t\tiface |= 0x0060;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tadn |= 0x5 << 1;\n\t\tbreak;\n\tcase 11025:\n\t\tadn |= 0x4 << 1;\n\t\tbreak;\n\tcase 16000:\n\t\tadn |= 0x3 << 1;\n\t\tbreak;\n\tcase 22050:\n\t\tadn |= 0x2 << 1;\n\t\tbreak;\n\tcase 32000:\n\t\tadn |= 0x1 << 1;\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8974_IFACE, iface);\n\tsnd_soc_component_write(component, WM8974_ADD, adn);\n\treturn 0;\n}\n\nstatic int wm8974_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8974_DAC) & 0xffbf;\n\n\tif (mute)\n\t\tsnd_soc_component_write(component, WM8974_DAC, mute_reg | 0x40);\n\telse\n\t\tsnd_soc_component_write(component, WM8974_DAC, mute_reg);\n\treturn 0;\n}\n\n \nstatic int wm8974_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tu16 power1 = snd_soc_component_read(component, WM8974_POWER1) & ~0x3;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tpower1 |= 0x1;   \n\t\tsnd_soc_component_write(component, WM8974_POWER1, power1);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tpower1 |= WM8974_POWER1_BIASEN | WM8974_POWER1_BUFIOEN;\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_sync(dev_get_regmap(component->dev, NULL));\n\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8974_POWER1, power1 | 0x3);\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tpower1 |= 0x2;   \n\t\tsnd_soc_component_write(component, WM8974_POWER1, power1);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component, WM8974_POWER1, 0);\n\t\tsnd_soc_component_write(component, WM8974_POWER2, 0);\n\t\tsnd_soc_component_write(component, WM8974_POWER3, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define WM8974_RATES (SNDRV_PCM_RATE_8000_48000)\n\n#define WM8974_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8974_ops = {\n\t.hw_params = wm8974_pcm_hw_params,\n\t.mute_stream = wm8974_mute,\n\t.set_fmt = wm8974_set_dai_fmt,\n\t.set_clkdiv = wm8974_set_dai_clkdiv,\n\t.set_pll = wm8974_set_dai_pll,\n\t.set_sysclk = wm8974_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8974_dai = {\n\t.name = \"wm8974-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,    \n\t\t.rates = WM8974_RATES,\n\t\t.formats = WM8974_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,    \n\t\t.rates = WM8974_RATES,\n\t\t.formats = WM8974_FORMATS,},\n\t.ops = &wm8974_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct regmap_config wm8974_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8974_MONOMIX,\n\t.reg_defaults = wm8974_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8974_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int wm8974_probe(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\tret = wm8974_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8974 = {\n\t.probe\t\t\t= wm8974_probe,\n\t.set_bias_level\t\t= wm8974_set_bias_level,\n\t.controls\t\t= wm8974_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8974_snd_controls),\n\t.dapm_widgets\t\t= wm8974_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8974_dapm_widgets),\n\t.dapm_routes\t\t= wm8974_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8974_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm8974_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8974_priv *priv;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tregmap = devm_regmap_init_i2c(i2c, &wm8974_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8974, &wm8974_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8974_i2c_id[] = {\n\t{ \"wm8974\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8974_i2c_id);\n\nstatic const struct of_device_id wm8974_of_match[] = {\n       { .compatible = \"wlf,wm8974\", },\n       { }\n};\nMODULE_DEVICE_TABLE(of, wm8974_of_match);\n\nstatic struct i2c_driver wm8974_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8974\",\n\t\t.of_match_table = wm8974_of_match,\n\t},\n\t.probe = wm8974_i2c_probe,\n\t.id_table = wm8974_i2c_id,\n};\n\nmodule_i2c_driver(wm8974_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8974 driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}