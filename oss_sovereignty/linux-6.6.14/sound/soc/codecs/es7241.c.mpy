{
  "module_name": "es7241.c",
  "hash_id": "02acb3ff26d443d75ee5c4c01d3f7431d03cfce552da74a6517ad7ce806cd938",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/es7241.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/of_platform.h>\n#include <linux/module.h>\n#include <sound/soc.h>\n\nstruct es7241_clock_mode {\n\tunsigned int rate_min;\n\tunsigned int rate_max;\n\tunsigned int *slv_mfs;\n\tunsigned int slv_mfs_num;\n\tunsigned int mst_mfs;\n\tunsigned int mst_m0:1;\n\tunsigned int mst_m1:1;\n};\n\nstruct es7241_chip {\n\tconst struct es7241_clock_mode *modes;\n\tunsigned int mode_num;\n};\n\nstruct es7241_data {\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *m0;\n\tstruct gpio_desc *m1;\n\tunsigned int fmt;\n\tunsigned int mclk;\n\tbool is_consumer;\n\tconst struct es7241_chip *chip;\n};\n\nstatic void es7241_set_mode(struct es7241_data *priv,  int m0, int m1)\n{\n\t \n\tgpiod_set_value_cansleep(priv->reset, 0);\n\n\t \n\tgpiod_set_value_cansleep(priv->m0, m0);\n\tgpiod_set_value_cansleep(priv->m1, m1);\n\n\t \n\tgpiod_set_value_cansleep(priv->reset, 1);\n}\n\nstatic int es7241_set_consumer_mode(struct es7241_data *priv,\n\t\t\t\t    const struct es7241_clock_mode *mode,\n\t\t\t\t    unsigned int mfs)\n{\n\tint j;\n\n\tif (!mfs)\n\t\tgoto out_ok;\n\n\tfor (j = 0; j < mode->slv_mfs_num; j++) {\n\t\tif (mode->slv_mfs[j] == mfs)\n\t\t\tgoto out_ok;\n\t}\n\n\treturn -EINVAL;\n\nout_ok:\n\tes7241_set_mode(priv, 1, 1);\n\treturn 0;\n}\n\nstatic int es7241_set_provider_mode(struct es7241_data *priv,\n\t\t\t\t    const struct es7241_clock_mode *mode,\n\t\t\t\t    unsigned int mfs)\n{\n\t \n\tif (mfs && mfs != mode->mst_mfs)\n\t\treturn -EINVAL;\n\n\tes7241_set_mode(priv, mode->mst_m0, mode->mst_m1);\n\n\treturn 0;\n}\n\nstatic int es7241_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct es7241_data *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int rate = params_rate(params);\n\tunsigned int mfs = priv->mclk / rate;\n\tint i;\n\n\tfor (i = 0; i < priv->chip->mode_num; i++) {\n\t\tconst struct es7241_clock_mode *mode = &priv->chip->modes[i];\n\n\t\tif (rate < mode->rate_min || rate >= mode->rate_max)\n\t\t\tcontinue;\n\n\t\tif (priv->is_consumer)\n\t\t\treturn es7241_set_consumer_mode(priv, mode, mfs);\n\t\telse\n\t\t\treturn es7241_set_provider_mode(priv, mode, mfs);\n\t}\n\n\t \n\tdev_err(dai->dev, \"unsupported rate: %u\\n\", rate);\n\treturn -EINVAL;\n}\n\nstatic int es7241_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq, int dir)\n{\n\tstruct es7241_data *priv = snd_soc_dai_get_drvdata(dai);\n\n\tif (dir == SND_SOC_CLOCK_IN && clk_id == 0) {\n\t\tpriv->mclk = freq;\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int es7241_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct es7241_data *priv = snd_soc_dai_get_drvdata(dai);\n\n\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF) {\n\t\tdev_err(dai->dev, \"Unsupported dai clock inversion\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != priv->fmt) {\n\t\tdev_err(dai->dev, \"Invalid dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tpriv->is_consumer = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tpriv->is_consumer = false;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported clock configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops es7241_dai_ops = {\n\t.set_fmt\t= es7241_set_fmt,\n\t.hw_params\t= es7241_hw_params,\n\t.set_sysclk\t= es7241_set_sysclk,\n};\n\nstatic struct snd_soc_dai_driver es7241_dai = {\n\t.name = \"es7241-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE  |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE),\n\t},\n\t.ops = &es7241_dai_ops,\n};\n\nstatic const struct es7241_clock_mode es7241_modes[] = {\n\t{\n\t\t \n\t\t.rate_min = 8000,\n\t\t.rate_max = 50000,\n\t\t.slv_mfs = (unsigned int[]) { 256, 384, 512, 768, 1024 },\n\t\t.slv_mfs_num = 5,\n\t\t.mst_mfs = 256,\n\t\t.mst_m0 = 0,\n\t\t.mst_m1 = 0,\n\t}, {\n\t\t \n\t\t.rate_min = 50000,\n\t\t.rate_max = 100000,\n\t\t.slv_mfs = (unsigned int[]) { 128, 192 },\n\t\t.slv_mfs_num = 2,\n\t\t.mst_mfs = 128,\n\t\t.mst_m0 = 1,\n\t\t.mst_m1 = 0,\n\t}, {\n\t\t \n\t\t.rate_min = 100000,\n\t\t.rate_max = 200000,\n\t\t.slv_mfs = (unsigned int[]) { 64 },\n\t\t.slv_mfs_num = 1,\n\t\t.mst_mfs = 64,\n\t\t.mst_m0 = 0,\n\t\t.mst_m1 = 1,\n\t},\n};\n\nstatic const struct es7241_chip es7241_chip __maybe_unused = {\n\t.modes = es7241_modes,\n\t.mode_num = ARRAY_SIZE(es7241_modes),\n};\n\nstatic const struct snd_soc_dapm_widget es7241_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"AINL\"),\n\tSND_SOC_DAPM_INPUT(\"AINR\"),\n\tSND_SOC_DAPM_DAC(\"ADC\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDDP\", 0, 0),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDDD\", 0, 0),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDDA\", 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route es7241_dapm_routes[] = {\n\t{ \"ADC\", NULL, \"AINL\", },\n\t{ \"ADC\", NULL, \"AINR\", },\n\t{ \"ADC\", NULL, \"VDDA\", },\n\t{ \"Capture\", NULL, \"VDDP\", },\n\t{ \"Capture\", NULL, \"VDDD\", },\n};\n\nstatic const struct snd_soc_component_driver es7241_component_driver = {\n\t.dapm_widgets\t\t= es7241_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(es7241_dapm_widgets),\n\t.dapm_routes\t\t= es7241_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(es7241_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void es7241_parse_fmt(struct device *dev, struct es7241_data *priv)\n{\n\tbool is_leftj;\n\n\t \n\tis_leftj = of_property_read_bool(dev->of_node,\n\t\t\t\t\t \"everest,sdout-pull-down\");\n\tif (is_leftj)\n\t\tpriv->fmt = SND_SOC_DAIFMT_LEFT_J;\n\telse\n\t\tpriv->fmt = SND_SOC_DAIFMT_I2S;\n}\n\nstatic int es7241_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct es7241_data *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->chip = of_device_get_match_data(dev);\n\tif (!priv->chip) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tes7241_parse_fmt(dev, priv);\n\n\tpriv->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->reset),\n\t\t\t\t     \"Failed to get 'reset' gpio\");\n\n\tpriv->m0 = devm_gpiod_get_optional(dev, \"m0\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->m0))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->m0),\n\t\t\t\t     \"Failed to get 'm0' gpio\");\n\n\tpriv->m1 = devm_gpiod_get_optional(dev, \"m1\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->m1))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->m1),\n\t\t\t\t     \"Failed to get 'm1' gpio\");\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &es7241_component_driver,\n\t\t\t\t      &es7241_dai, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id es7241_ids[] = {\n\t{ .compatible = \"everest,es7241\", .data = &es7241_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, es7241_ids);\n#endif\n\nstatic struct platform_driver es7241_driver = {\n\t.driver = {\n\t\t.name = \"es7241\",\n\t\t.of_match_table = of_match_ptr(es7241_ids),\n\t},\n\t.probe = es7241_probe,\n};\n\nmodule_platform_driver(es7241_driver);\n\nMODULE_DESCRIPTION(\"ASoC ES7241 audio codec driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}