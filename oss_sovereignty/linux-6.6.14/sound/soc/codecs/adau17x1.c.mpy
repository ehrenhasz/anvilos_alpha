{
  "module_name": "adau17x1.c",
  "hash_id": "7c95f237420560e1f3633c6f6b1b82930c4c5c130c92477b72be64eefe8841e3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau17x1.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <asm/unaligned.h>\n\n#include \"sigmadsp.h\"\n#include \"adau17x1.h\"\n#include \"adau-utils.h\"\n\n#define ADAU17X1_SAFELOAD_TARGET_ADDRESS 0x0006\n#define ADAU17X1_SAFELOAD_TRIGGER 0x0007\n#define ADAU17X1_SAFELOAD_DATA 0x0001\n#define ADAU17X1_SAFELOAD_DATA_SIZE 20\n#define ADAU17X1_WORD_SIZE 4\n\nstatic const char * const adau17x1_capture_mixer_boost_text[] = {\n\t\"Normal operation\", \"Boost Level 1\", \"Boost Level 2\", \"Boost Level 3\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau17x1_capture_boost_enum,\n\tADAU17X1_REC_POWER_MGMT, 5, adau17x1_capture_mixer_boost_text);\n\nstatic const char * const adau17x1_mic_bias_mode_text[] = {\n\t\"Normal operation\", \"High performance\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau17x1_mic_bias_mode_enum,\n\tADAU17X1_MICBIAS, 3, adau17x1_mic_bias_mode_text);\n\nstatic const DECLARE_TLV_DB_MINMAX(adau17x1_digital_tlv, -9563, 0);\n\nstatic const struct snd_kcontrol_new adau17x1_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Digital Capture Volume\",\n\t\tADAU17X1_LEFT_INPUT_DIGITAL_VOL,\n\t\tADAU17X1_RIGHT_INPUT_DIGITAL_VOL,\n\t\t0, 0xff, 1, adau17x1_digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", ADAU17X1_DAC_CONTROL1,\n\t\tADAU17X1_DAC_CONTROL2, 0, 0xff, 1, adau17x1_digital_tlv),\n\n\tSOC_SINGLE(\"ADC High Pass Filter Switch\", ADAU17X1_ADC_CONTROL,\n\t\t5, 1, 0),\n\tSOC_SINGLE(\"Playback De-emphasis Switch\", ADAU17X1_DAC_CONTROL0,\n\t\t2, 1, 0),\n\n\tSOC_ENUM(\"Capture Boost\", adau17x1_capture_boost_enum),\n\n\tSOC_ENUM(\"Mic Bias Mode\", adau17x1_mic_bias_mode_enum),\n};\n\nstatic int adau17x1_setup_firmware(struct snd_soc_component *component,\n\tunsigned int rate);\n\nstatic int adau17x1_pll_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tadau->pll_regs[5] = 1;\n\t} else {\n\t\tadau->pll_regs[5] = 0;\n\t\t \n\t\tregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\n\t\t\tADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL, 0);\n\t}\n\n\t \n\tregmap_raw_write(adau->regmap, ADAU17X1_PLL_CONTROL,\n\t\t\tadau->pll_regs, ARRAY_SIZE(adau->pll_regs));\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tmdelay(5);\n\t\tregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\n\t\t\tADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL,\n\t\t\tADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL);\n\t}\n\n\treturn 0;\n}\n\nstatic int adau17x1_adc_fixup(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\t \n\tregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\n\t\tADAU17X1_CONVERTER0_ADOSR, ADAU17X1_CONVERTER0_ADOSR);\n\tregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\n\t\tADAU17X1_CONVERTER0_ADOSR, 0);\n\n\treturn 0;\n}\n\nstatic const char * const adau17x1_mono_stereo_text[] = {\n\t\"Stereo\",\n\t\"Mono Left Channel (L+R)\",\n\t\"Mono Right Channel (L+R)\",\n\t\"Mono (L+R)\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau17x1_dac_mode_enum,\n\tADAU17X1_DAC_CONTROL0, 6, adau17x1_mono_stereo_text);\n\nstatic const struct snd_kcontrol_new adau17x1_dac_mode_mux =\n\tSOC_DAPM_ENUM(\"DAC Mono-Stereo-Mode\", adau17x1_dac_mode_enum);\n\nstatic const struct snd_soc_dapm_widget adau17x1_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY_S(\"PLL\", 3, SND_SOC_NOPM, 0, 0, adau17x1_pll_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_SUPPLY(\"AIFCLK\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", ADAU17X1_MICBIAS, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Left Playback Enable\", ADAU17X1_PLAY_POWER_MGMT,\n\t\t0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Right Playback Enable\", ADAU17X1_PLAY_POWER_MGMT,\n\t\t1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Left DAC Mode Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau17x1_dac_mode_mux),\n\tSND_SOC_DAPM_MUX(\"Right DAC Mode Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau17x1_dac_mode_mux),\n\n\tSND_SOC_DAPM_ADC_E(\"Left Decimator\", NULL, ADAU17X1_ADC_CONTROL, 0, 0,\n\t\t\t   adau17x1_adc_fixup, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_ADC(\"Right Decimator\", NULL, ADAU17X1_ADC_CONTROL, 1, 0),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", NULL, ADAU17X1_DAC_CONTROL0, 0, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", NULL, ADAU17X1_DAC_CONTROL0, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau17x1_dapm_routes[] = {\n\t{ \"Left Decimator\", NULL, \"SYSCLK\" },\n\t{ \"Right Decimator\", NULL, \"SYSCLK\" },\n\t{ \"Left DAC\", NULL, \"SYSCLK\" },\n\t{ \"Right DAC\", NULL, \"SYSCLK\" },\n\t{ \"Capture\", NULL, \"SYSCLK\" },\n\t{ \"Playback\", NULL, \"SYSCLK\" },\n\n\t{ \"Left DAC\", NULL, \"Left DAC Mode Mux\" },\n\t{ \"Right DAC\", NULL, \"Right DAC Mode Mux\" },\n\n\t{ \"Capture\", NULL, \"AIFCLK\" },\n\t{ \"Playback\", NULL, \"AIFCLK\" },\n};\n\nstatic const struct snd_soc_dapm_route adau17x1_dapm_pll_route = {\n\t\"SYSCLK\", NULL, \"PLL\",\n};\n\n \nstatic int adau17x1_dsp_mux_enum_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_soc_dapm_update update = {};\n\tunsigned int stream = e->shift_l;\n\tunsigned int val, change;\n\tint reg;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tswitch (ucontrol->value.enumerated.item[0]) {\n\tcase 0:\n\t\tval = 0;\n\t\tadau->dsp_bypass[stream] = false;\n\t\tbreak;\n\tdefault:\n\t\tval = (adau->tdm_slot[stream] * 2) + 1;\n\t\tadau->dsp_bypass[stream] = true;\n\t\tbreak;\n\t}\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treg = ADAU17X1_SERIAL_INPUT_ROUTE;\n\telse\n\t\treg = ADAU17X1_SERIAL_OUTPUT_ROUTE;\n\n\tchange = snd_soc_component_test_bits(component, reg, 0xff, val);\n\tif (change) {\n\t\tupdate.kcontrol = kcontrol;\n\t\tupdate.mask = 0xff;\n\t\tupdate.reg = reg;\n\t\tupdate.val = val;\n\n\t\tsnd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\t\t\tucontrol->value.enumerated.item[0], e, &update);\n\t}\n\n\treturn change;\n}\n\nstatic int adau17x1_dsp_mux_enum_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int stream = e->shift_l;\n\tunsigned int reg, val;\n\tint ret;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treg = ADAU17X1_SERIAL_INPUT_ROUTE;\n\telse\n\t\treg = ADAU17X1_SERIAL_OUTPUT_ROUTE;\n\n\tret = regmap_read(adau->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0)\n\t\tval = 1;\n\tucontrol->value.enumerated.item[0] = val;\n\n\treturn 0;\n}\n\n#define DECLARE_ADAU17X1_DSP_MUX_CTRL(_name, _label, _stream, _text) \\\n\tconst struct snd_kcontrol_new _name = \\\n\t\tSOC_DAPM_ENUM_EXT(_label, (const struct soc_enum)\\\n\t\t\tSOC_ENUM_SINGLE(SND_SOC_NOPM, _stream, \\\n\t\t\t\tARRAY_SIZE(_text), _text), \\\n\t\t\tadau17x1_dsp_mux_enum_get, adau17x1_dsp_mux_enum_put)\n\nstatic const char * const adau17x1_dac_mux_text[] = {\n\t\"DSP\",\n\t\"AIFIN\",\n};\n\nstatic const char * const adau17x1_capture_mux_text[] = {\n\t\"DSP\",\n\t\"Decimator\",\n};\n\nstatic DECLARE_ADAU17X1_DSP_MUX_CTRL(adau17x1_dac_mux, \"DAC Playback Mux\",\n\tSNDRV_PCM_STREAM_PLAYBACK, adau17x1_dac_mux_text);\n\nstatic DECLARE_ADAU17X1_DSP_MUX_CTRL(adau17x1_capture_mux, \"Capture Mux\",\n\tSNDRV_PCM_STREAM_CAPTURE, adau17x1_capture_mux_text);\n\nstatic const struct snd_soc_dapm_widget adau17x1_dsp_dapm_widgets[] = {\n\tSND_SOC_DAPM_PGA(\"DSP\", ADAU17X1_DSP_RUN, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SIGGEN(\"DSP Siggen\"),\n\n\tSND_SOC_DAPM_MUX(\"DAC Playback Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau17x1_dac_mux),\n\tSND_SOC_DAPM_MUX(\"Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau17x1_capture_mux),\n};\n\nstatic const struct snd_soc_dapm_route adau17x1_dsp_dapm_routes[] = {\n\t{ \"DAC Playback Mux\", \"DSP\", \"DSP\" },\n\t{ \"DAC Playback Mux\", \"AIFIN\", \"Playback\" },\n\n\t{ \"Left DAC Mode Mux\", \"Stereo\", \"DAC Playback Mux\" },\n\t{ \"Left DAC Mode Mux\", \"Mono (L+R)\", \"DAC Playback Mux\" },\n\t{ \"Left DAC Mode Mux\", \"Mono Left Channel (L+R)\", \"DAC Playback Mux\" },\n\t{ \"Right DAC Mode Mux\", \"Stereo\", \"DAC Playback Mux\" },\n\t{ \"Right DAC Mode Mux\", \"Mono (L+R)\", \"DAC Playback Mux\" },\n\t{ \"Right DAC Mode Mux\", \"Mono Right Channel (L+R)\", \"DAC Playback Mux\" },\n\n\t{ \"Capture Mux\", \"DSP\", \"DSP\" },\n\t{ \"Capture Mux\", \"Decimator\", \"Left Decimator\" },\n\t{ \"Capture Mux\", \"Decimator\", \"Right Decimator\" },\n\n\t{ \"Capture\", NULL, \"Capture Mux\" },\n\n\t{ \"DSP\", NULL, \"DSP Siggen\" },\n\n\t{ \"DSP\", NULL, \"Left Decimator\" },\n\t{ \"DSP\", NULL, \"Right Decimator\" },\n\t{ \"DSP\", NULL, \"Playback\" },\n};\n\nstatic const struct snd_soc_dapm_route adau17x1_no_dsp_dapm_routes[] = {\n\t{ \"Left DAC Mode Mux\", \"Stereo\", \"Playback\" },\n\t{ \"Left DAC Mode Mux\", \"Mono (L+R)\", \"Playback\" },\n\t{ \"Left DAC Mode Mux\", \"Mono Left Channel (L+R)\", \"Playback\" },\n\t{ \"Right DAC Mode Mux\", \"Stereo\", \"Playback\" },\n\t{ \"Right DAC Mode Mux\", \"Mono (L+R)\", \"Playback\" },\n\t{ \"Right DAC Mode Mux\", \"Mono Right Channel (L+R)\", \"Playback\" },\n\t{ \"Capture\", NULL, \"Left Decimator\" },\n\t{ \"Capture\", NULL, \"Right Decimator\" },\n};\n\nstatic bool adau17x1_has_dsp(struct adau *adau)\n{\n\tswitch (adau->type) {\n\tcase ADAU1761:\n\tcase ADAU1381:\n\tcase ADAU1781:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic bool adau17x1_has_disused_dsp(struct adau *adau)\n{\n\tswitch (adau->type) {\n\tcase ADAU1761_AS_1361:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool adau17x1_has_safeload(struct adau *adau)\n{\n\tswitch (adau->type) {\n\tcase ADAU1761:\n\tcase ADAU1781:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int adau17x1_set_dai_pll(struct snd_soc_dai *dai, int pll_id,\n\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (freq_in < 8000000 || freq_in > 27000000)\n\t\treturn -EINVAL;\n\n\tret = adau_calc_pll_cfg(freq_in, freq_out, adau->pll_regs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_raw_write(adau->regmap, ADAU17X1_PLL_CONTROL,\n\t\t\tadau->pll_regs, ARRAY_SIZE(adau->pll_regs));\n\tif (ret)\n\t\treturn ret;\n\n\tadau->pll_freq = freq_out;\n\n\treturn 0;\n}\n\nstatic int adau17x1_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(dai->component);\n\tstruct adau *adau = snd_soc_component_get_drvdata(dai->component);\n\tbool is_pll;\n\tbool was_pll;\n\n\tswitch (clk_id) {\n\tcase ADAU17X1_CLK_SRC_MCLK:\n\t\tis_pll = false;\n\t\tbreak;\n\tcase ADAU17X1_CLK_SRC_PLL_AUTO:\n\t\tif (!adau->mclk)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase ADAU17X1_CLK_SRC_PLL:\n\t\tis_pll = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (adau->clk_src) {\n\tcase ADAU17X1_CLK_SRC_MCLK:\n\t\twas_pll = false;\n\t\tbreak;\n\tcase ADAU17X1_CLK_SRC_PLL:\n\tcase ADAU17X1_CLK_SRC_PLL_AUTO:\n\t\twas_pll = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadau->sysclk = freq;\n\n\tif (is_pll != was_pll) {\n\t\tif (is_pll) {\n\t\t\tsnd_soc_dapm_add_routes(dapm,\n\t\t\t\t&adau17x1_dapm_pll_route, 1);\n\t\t} else {\n\t\t\tsnd_soc_dapm_del_routes(dapm,\n\t\t\t\t&adau17x1_dapm_pll_route, 1);\n\t\t}\n\t}\n\n\tadau->clk_src = clk_id;\n\n\treturn 0;\n}\n\nstatic int adau17x1_auto_pll(struct snd_soc_dai *dai,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct adau *adau = snd_soc_dai_get_drvdata(dai);\n\tunsigned int pll_rate;\n\n\tswitch (params_rate(params)) {\n\tcase 48000:\n\tcase 8000:\n\tcase 12000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 96000:\n\t\tpll_rate = 48000 * 1024;\n\t\tbreak;\n\tcase 44100:\n\tcase 7350:\n\tcase 11025:\n\tcase 14700:\n\tcase 22050:\n\tcase 29400:\n\tcase 88200:\n\t\tpll_rate = 44100 * 1024;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn adau17x1_set_dai_pll(dai, ADAU17X1_PLL, ADAU17X1_PLL_SRC_MCLK,\n\t\tclk_get_rate(adau->mclk), pll_rate);\n}\n\nstatic int adau17x1_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tunsigned int val, div, dsp_div;\n\tunsigned int freq;\n\tint ret;\n\n\tswitch (adau->clk_src) {\n\tcase ADAU17X1_CLK_SRC_PLL_AUTO:\n\t\tret = adau17x1_auto_pll(dai, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tcase ADAU17X1_CLK_SRC_PLL:\n\t\tfreq = adau->pll_freq;\n\t\tbreak;\n\tdefault:\n\t\tfreq = adau->sysclk;\n\t\tbreak;\n\t}\n\n\tif (freq % params_rate(params) != 0)\n\t\treturn -EINVAL;\n\n\tswitch (freq / params_rate(params)) {\n\tcase 1024:  \n\t\tdiv = 0;\n\t\tdsp_div = 1;\n\t\tbreak;\n\tcase 6144:  \n\t\tdiv = 1;\n\t\tdsp_div = 6;\n\t\tbreak;\n\tcase 4096:  \n\t\tdiv = 2;\n\t\tdsp_div = 5;\n\t\tbreak;\n\tcase 3072:  \n\t\tdiv = 3;\n\t\tdsp_div = 4;\n\t\tbreak;\n\tcase 2048:  \n\t\tdiv = 4;\n\t\tdsp_div = 3;\n\t\tbreak;\n\tcase 1536:  \n\t\tdiv = 5;\n\t\tdsp_div = 2;\n\t\tbreak;\n\tcase 512:  \n\t\tdiv = 6;\n\t\tdsp_div = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\n\t\tADAU17X1_CONVERTER0_CONVSR_MASK, div);\n\n\tif (adau17x1_has_dsp(adau) || adau17x1_has_disused_dsp(adau))\n\t\tregmap_write(adau->regmap, ADAU17X1_SERIAL_SAMPLING_RATE, div);\n\tif (adau17x1_has_dsp(adau))\n\t\tregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, dsp_div);\n\n\tif (adau->sigmadsp) {\n\t\tret = adau17x1_setup_firmware(component, params_rate(params));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (adau->dai_fmt != SND_SOC_DAIFMT_RIGHT_J)\n\t\treturn 0;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval = ADAU17X1_SERIAL_PORT1_DELAY16;\n\t\tbreak;\n\tcase 24:\n\t\tval = ADAU17X1_SERIAL_PORT1_DELAY8;\n\t\tbreak;\n\tcase 32:\n\t\tval = ADAU17X1_SERIAL_PORT1_DELAY0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT1,\n\t\t\tADAU17X1_SERIAL_PORT1_DELAY_MASK, val);\n}\n\nstatic int adau17x1_set_dai_fmt(struct snd_soc_dai *dai,\n\t\tunsigned int fmt)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ctrl0, ctrl1;\n\tunsigned int ctrl0_mask;\n\tint lrclk_pol;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tctrl0 = ADAU17X1_SERIAL_PORT0_MASTER;\n\t\tadau->master = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tctrl0 = 0;\n\t\tadau->master = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tlrclk_pol = 0;\n\t\tctrl1 = ADAU17X1_SERIAL_PORT1_DELAY1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tlrclk_pol = 1;\n\t\tctrl1 = ADAU17X1_SERIAL_PORT1_DELAY0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tlrclk_pol = 1;\n\t\tctrl0 |= ADAU17X1_SERIAL_PORT0_PULSE_MODE;\n\t\tctrl1 = ADAU17X1_SERIAL_PORT1_DELAY1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tlrclk_pol = 1;\n\t\tctrl0 |= ADAU17X1_SERIAL_PORT0_PULSE_MODE;\n\t\tctrl1 = ADAU17X1_SERIAL_PORT1_DELAY0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl0 |= ADAU17X1_SERIAL_PORT0_BCLK_POL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrclk_pol = !lrclk_pol;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tctrl0 |= ADAU17X1_SERIAL_PORT0_BCLK_POL;\n\t\tlrclk_pol = !lrclk_pol;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (lrclk_pol)\n\t\tctrl0 |= ADAU17X1_SERIAL_PORT0_LRCLK_POL;\n\n\t \n\tctrl0_mask = ADAU17X1_SERIAL_PORT0_MASTER |\n\t\t     ADAU17X1_SERIAL_PORT0_LRCLK_POL |\n\t\t     ADAU17X1_SERIAL_PORT0_BCLK_POL |\n\t\t     ADAU17X1_SERIAL_PORT0_PULSE_MODE;\n\n\tregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT0, ctrl0_mask,\n\t\t\t   ctrl0);\n\tregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT1,\n\t\t\t   ADAU17X1_SERIAL_PORT1_DELAY_MASK, ctrl1);\n\n\tadau->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\treturn 0;\n}\n\nstatic int adau17x1_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ser_ctrl0, ser_ctrl1;\n\tunsigned int conv_ctrl0, conv_ctrl1;\n\n\t \n\tif (slots == 0) {\n\t\tslots = 2;\n\t\trx_mask = 3;\n\t\ttx_mask = 3;\n\t\tslot_width = 32;\n\t}\n\n\tswitch (slots) {\n\tcase 2:\n\t\tser_ctrl0 = ADAU17X1_SERIAL_PORT0_STEREO;\n\t\tbreak;\n\tcase 4:\n\t\tser_ctrl0 = ADAU17X1_SERIAL_PORT0_TDM4;\n\t\tbreak;\n\tcase 8:\n\t\tif (adau->type == ADAU1361)\n\t\t\treturn -EINVAL;\n\n\t\tser_ctrl0 = ADAU17X1_SERIAL_PORT0_TDM8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slot_width * slots) {\n\tcase 32:\n\t\tif (adau->type == ADAU1761 || adau->type == ADAU1761_AS_1361)\n\t\t\treturn -EINVAL;\n\n\t\tser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK32;\n\t\tbreak;\n\tcase 64:\n\t\tser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK64;\n\t\tbreak;\n\tcase 48:\n\t\tser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK48;\n\t\tbreak;\n\tcase 128:\n\t\tser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK128;\n\t\tbreak;\n\tcase 256:\n\t\tif (adau->type == ADAU1361)\n\t\t\treturn -EINVAL;\n\n\t\tser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (rx_mask) {\n\tcase 0x03:\n\t\tconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(1);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 0;\n\t\tbreak;\n\tcase 0x0c:\n\t\tconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(2);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 1;\n\t\tbreak;\n\tcase 0x30:\n\t\tconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(3);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 2;\n\t\tbreak;\n\tcase 0xc0:\n\t\tconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(4);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tx_mask) {\n\tcase 0x03:\n\t\tconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(1);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 0;\n\t\tbreak;\n\tcase 0x0c:\n\t\tconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(2);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 1;\n\t\tbreak;\n\tcase 0x30:\n\t\tconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(3);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 2;\n\t\tbreak;\n\tcase 0xc0:\n\t\tconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(4);\n\t\tadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\n\t\tADAU17X1_CONVERTER0_DAC_PAIR_MASK, conv_ctrl0);\n\tregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER1,\n\t\tADAU17X1_CONVERTER1_ADC_PAIR_MASK, conv_ctrl1);\n\tregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT0,\n\t\tADAU17X1_SERIAL_PORT0_TDM_MASK, ser_ctrl0);\n\tregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT1,\n\t\tADAU17X1_SERIAL_PORT1_BCLK_MASK, ser_ctrl1);\n\n\tif (!adau17x1_has_dsp(adau) && !adau17x1_has_disused_dsp(adau))\n\t\treturn 0;\n\n\tif (adau->dsp_bypass[SNDRV_PCM_STREAM_PLAYBACK]) {\n\t\tregmap_write(adau->regmap, ADAU17X1_SERIAL_INPUT_ROUTE,\n\t\t\t(adau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] * 2) + 1);\n\t}\n\n\tif (adau->dsp_bypass[SNDRV_PCM_STREAM_CAPTURE]) {\n\t\tregmap_write(adau->regmap, ADAU17X1_SERIAL_OUTPUT_ROUTE,\n\t\t\t(adau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] * 2) + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int adau17x1_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(dai->component);\n\n\tif (adau->sigmadsp)\n\t\treturn sigmadsp_restrict_params(adau->sigmadsp, substream);\n\n\treturn 0;\n}\n\nconst struct snd_soc_dai_ops adau17x1_dai_ops = {\n\t.hw_params\t= adau17x1_hw_params,\n\t.set_sysclk\t= adau17x1_set_dai_sysclk,\n\t.set_fmt\t= adau17x1_set_dai_fmt,\n\t.set_pll\t= adau17x1_set_dai_pll,\n\t.set_tdm_slot\t= adau17x1_set_dai_tdm_slot,\n\t.startup\t= adau17x1_startup,\n};\nEXPORT_SYMBOL_GPL(adau17x1_dai_ops);\n\nint adau17x1_set_micbias_voltage(struct snd_soc_component *component,\n\tenum adau17x1_micbias_voltage micbias)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\tswitch (micbias) {\n\tcase ADAU17X1_MICBIAS_0_90_AVDD:\n\tcase ADAU17X1_MICBIAS_0_65_AVDD:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(adau->regmap, ADAU17X1_MICBIAS, micbias << 2);\n}\nEXPORT_SYMBOL_GPL(adau17x1_set_micbias_voltage);\n\nbool adau17x1_precious_register(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg < 0x400)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(adau17x1_precious_register);\n\nbool adau17x1_readable_register(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg < 0x400)\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase ADAU17X1_CLOCK_CONTROL:\n\tcase ADAU17X1_PLL_CONTROL:\n\tcase ADAU17X1_REC_POWER_MGMT:\n\tcase ADAU17X1_MICBIAS:\n\tcase ADAU17X1_SERIAL_PORT0:\n\tcase ADAU17X1_SERIAL_PORT1:\n\tcase ADAU17X1_CONVERTER0:\n\tcase ADAU17X1_CONVERTER1:\n\tcase ADAU17X1_LEFT_INPUT_DIGITAL_VOL:\n\tcase ADAU17X1_RIGHT_INPUT_DIGITAL_VOL:\n\tcase ADAU17X1_ADC_CONTROL:\n\tcase ADAU17X1_PLAY_POWER_MGMT:\n\tcase ADAU17X1_DAC_CONTROL0:\n\tcase ADAU17X1_DAC_CONTROL1:\n\tcase ADAU17X1_DAC_CONTROL2:\n\tcase ADAU17X1_SERIAL_PORT_PAD:\n\tcase ADAU17X1_CONTROL_PORT_PAD0:\n\tcase ADAU17X1_CONTROL_PORT_PAD1:\n\tcase ADAU17X1_DSP_SAMPLING_RATE:\n\tcase ADAU17X1_SERIAL_INPUT_ROUTE:\n\tcase ADAU17X1_SERIAL_OUTPUT_ROUTE:\n\tcase ADAU17X1_DSP_ENABLE:\n\tcase ADAU17X1_DSP_RUN:\n\tcase ADAU17X1_SERIAL_SAMPLING_RATE:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(adau17x1_readable_register);\n\nbool adau17x1_volatile_register(struct device *dev, unsigned int reg)\n{\n\t \n\tif (reg < 0x4000)\n\t\treturn true;\n\n\tswitch (reg) {\n\t \n\tcase ADAU17X1_PLL_CONTROL:\n\tcase ADAU17X1_PLL_CONTROL + 1:\n\tcase ADAU17X1_PLL_CONTROL + 2:\n\tcase ADAU17X1_PLL_CONTROL + 3:\n\tcase ADAU17X1_PLL_CONTROL + 4:\n\tcase ADAU17X1_PLL_CONTROL + 5:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(adau17x1_volatile_register);\n\nstatic int adau17x1_setup_firmware(struct snd_soc_component *component,\n\tunsigned int rate)\n{\n\tint ret;\n\tint dspsr, dsp_run;\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\t \n\tif (adau->sigmadsp->current_samplerate == rate)\n\t\treturn 0;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tret = regmap_read(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, &dspsr);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_read(adau->regmap, ADAU17X1_DSP_RUN, &dsp_run);\n\tif (ret)\n\t\tgoto err;\n\n\tregmap_write(adau->regmap, ADAU17X1_DSP_ENABLE, 1);\n\tregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, 0xf);\n\tregmap_write(adau->regmap, ADAU17X1_DSP_RUN, 0);\n\n\tret = sigmadsp_setup(adau->sigmadsp, rate);\n\tif (ret) {\n\t\tregmap_write(adau->regmap, ADAU17X1_DSP_ENABLE, 0);\n\t\tgoto err;\n\t}\n\tregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, dspsr);\n\tregmap_write(adau->regmap, ADAU17X1_DSP_RUN, dsp_run);\n\nerr:\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\n\nint adau17x1_add_widgets(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_add_component_controls(component, adau17x1_controls,\n\t\tARRAY_SIZE(adau17x1_controls));\n\tif (ret)\n\t\treturn ret;\n\tret = snd_soc_dapm_new_controls(dapm, adau17x1_dapm_widgets,\n\t\tARRAY_SIZE(adau17x1_dapm_widgets));\n\tif (ret)\n\t\treturn ret;\n\n\tif (adau17x1_has_dsp(adau)) {\n\t\tret = snd_soc_dapm_new_controls(dapm, adau17x1_dsp_dapm_widgets,\n\t\t\tARRAY_SIZE(adau17x1_dsp_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!adau->sigmadsp)\n\t\t\treturn 0;\n\n\t\tret = sigmadsp_attach(adau->sigmadsp, component);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to attach firmware: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adau17x1_add_widgets);\n\nint adau17x1_add_routes(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_dapm_add_routes(dapm, adau17x1_dapm_routes,\n\t\tARRAY_SIZE(adau17x1_dapm_routes));\n\tif (ret)\n\t\treturn ret;\n\n\tif (adau17x1_has_dsp(adau)) {\n\t\tret = snd_soc_dapm_add_routes(dapm, adau17x1_dsp_dapm_routes,\n\t\t\tARRAY_SIZE(adau17x1_dsp_dapm_routes));\n\t} else {\n\t\tret = snd_soc_dapm_add_routes(dapm, adau17x1_no_dsp_dapm_routes,\n\t\t\tARRAY_SIZE(adau17x1_no_dsp_dapm_routes));\n\t}\n\n\tif (adau->clk_src != ADAU17X1_CLK_SRC_MCLK)\n\t\tsnd_soc_dapm_add_routes(dapm, &adau17x1_dapm_pll_route, 1);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adau17x1_add_routes);\n\nint adau17x1_resume(struct snd_soc_component *component)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\tif (adau->switch_mode)\n\t\tadau->switch_mode(component->dev);\n\n\tregcache_sync(adau->regmap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adau17x1_resume);\n\nstatic int adau17x1_safeload(struct sigmadsp *sigmadsp, unsigned int addr,\n\tconst uint8_t bytes[], size_t len)\n{\n\tuint8_t buf[ADAU17X1_WORD_SIZE];\n\tuint8_t data[ADAU17X1_SAFELOAD_DATA_SIZE];\n\tunsigned int addr_offset;\n\tunsigned int nbr_words;\n\tint ret;\n\n\t \n\tnbr_words = len / ADAU17X1_WORD_SIZE;\n\tif ((len - nbr_words * ADAU17X1_WORD_SIZE) == 0) {\n\t\tret = regmap_raw_write(sigmadsp->control_data,\n\t\t\tADAU17X1_SAFELOAD_DATA, bytes, len);\n\t} else {\n\t\tnbr_words++;\n\t\tmemset(data, 0, ADAU17X1_SAFELOAD_DATA_SIZE);\n\t\tmemcpy(data, bytes, len);\n\t\tret = regmap_raw_write(sigmadsp->control_data,\n\t\t\tADAU17X1_SAFELOAD_DATA, data,\n\t\t\tnbr_words * ADAU17X1_WORD_SIZE);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\taddr_offset = addr - 1;\n\tput_unaligned_be32(addr_offset, buf);\n\tret = regmap_raw_write(sigmadsp->control_data,\n\t\tADAU17X1_SAFELOAD_TARGET_ADDRESS, buf, ADAU17X1_WORD_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tput_unaligned_be32(nbr_words, buf);\n\tret = regmap_raw_write(sigmadsp->control_data,\n\t\tADAU17X1_SAFELOAD_TRIGGER, buf, ADAU17X1_WORD_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct sigmadsp_ops adau17x1_sigmadsp_ops = {\n\t.safeload = adau17x1_safeload,\n};\n\nint adau17x1_probe(struct device *dev, struct regmap *regmap,\n\tenum adau17x1_type type, void (*switch_mode)(struct device *dev),\n\tconst char *firmware_name)\n{\n\tstruct adau *adau;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tadau = devm_kzalloc(dev, sizeof(*adau), GFP_KERNEL);\n\tif (!adau)\n\t\treturn -ENOMEM;\n\n\t \n\tadau->mclk = devm_clk_get_optional(dev, \"mclk\");\n\tif (IS_ERR(adau->mclk))\n\t\treturn PTR_ERR(adau->mclk);\n\n\tif (adau->mclk) {\n\t\tadau->clk_src = ADAU17X1_CLK_SRC_PLL_AUTO;\n\n\t\t \n\t\tret = adau_calc_pll_cfg(clk_get_rate(adau->mclk), 48000 * 1024,\n\t\t\t\tadau->pll_regs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(adau->mclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tadau->regmap = regmap;\n\tadau->switch_mode = switch_mode;\n\tadau->type = type;\n\n\tdev_set_drvdata(dev, adau);\n\n\tif (firmware_name) {\n\t\tif (adau17x1_has_safeload(adau)) {\n\t\t\tadau->sigmadsp = devm_sigmadsp_init_regmap(dev, regmap,\n\t\t\t\t&adau17x1_sigmadsp_ops, firmware_name);\n\t\t} else {\n\t\t\tadau->sigmadsp = devm_sigmadsp_init_regmap(dev, regmap,\n\t\t\t\tNULL, firmware_name);\n\t\t}\n\t\tif (IS_ERR(adau->sigmadsp)) {\n\t\t\tdev_warn(dev, \"Could not find firmware file: %ld\\n\",\n\t\t\t\tPTR_ERR(adau->sigmadsp));\n\t\t\tadau->sigmadsp = NULL;\n\t\t}\n\t}\n\n\tif (switch_mode)\n\t\tswitch_mode(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adau17x1_probe);\n\nvoid adau17x1_remove(struct device *dev)\n{\n\tstruct adau *adau = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(adau->mclk);\n}\nEXPORT_SYMBOL_GPL(adau17x1_remove);\n\nMODULE_DESCRIPTION(\"ASoC ADAU1X61/ADAU1X81 common code\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}