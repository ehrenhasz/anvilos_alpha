{
  "module_name": "xtfpga-i2s.c",
  "hash_id": "06601454b428046cf61e2bf604403ada978c65f052c93dfb954d2ee10def35f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/xtensa/xtfpga-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#define DRV_NAME\t\"xtfpga-i2s\"\n\n#define XTFPGA_I2S_VERSION\t0x00\n#define XTFPGA_I2S_CONFIG\t0x04\n#define XTFPGA_I2S_INT_MASK\t0x08\n#define XTFPGA_I2S_INT_STATUS\t0x0c\n#define XTFPGA_I2S_CHAN0_DATA\t0x10\n#define XTFPGA_I2S_CHAN1_DATA\t0x14\n#define XTFPGA_I2S_CHAN2_DATA\t0x18\n#define XTFPGA_I2S_CHAN3_DATA\t0x1c\n\n#define XTFPGA_I2S_CONFIG_TX_ENABLE\t0x1\n#define XTFPGA_I2S_CONFIG_INT_ENABLE\t0x2\n#define XTFPGA_I2S_CONFIG_LEFT\t\t0x4\n#define XTFPGA_I2S_CONFIG_RATIO_BASE\t8\n#define XTFPGA_I2S_CONFIG_RATIO_MASK\t0x0000ff00\n#define XTFPGA_I2S_CONFIG_RES_BASE\t16\n#define XTFPGA_I2S_CONFIG_RES_MASK\t0x003f0000\n#define XTFPGA_I2S_CONFIG_LEVEL_BASE\t24\n#define XTFPGA_I2S_CONFIG_LEVEL_MASK\t0x0f000000\n#define XTFPGA_I2S_CONFIG_CHANNEL_BASE\t28\n\n#define XTFPGA_I2S_INT_UNDERRUN\t\t0x1\n#define XTFPGA_I2S_INT_LEVEL\t\t0x2\n#define XTFPGA_I2S_INT_VALID\t\t0x3\n\n#define XTFPGA_I2S_FIFO_SIZE\t\t8192\n\n \nstruct xtfpga_i2s {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tvoid __iomem *regs;\n\n\t \n\tstruct snd_pcm_substream __rcu *tx_substream;\n\tunsigned (*tx_fn)(struct xtfpga_i2s *i2s,\n\t\t\t  struct snd_pcm_runtime *runtime,\n\t\t\t  unsigned tx_ptr);\n\tunsigned tx_ptr;  \n\n\t \n\tunsigned tx_fifo_level;\n\n\t \n\tunsigned tx_fifo_low;\n\n\t \n\tunsigned tx_fifo_high;\n};\n\nstatic bool xtfpga_i2s_wr_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg >= XTFPGA_I2S_CONFIG;\n}\n\nstatic bool xtfpga_i2s_rd_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg < XTFPGA_I2S_CHAN0_DATA;\n}\n\nstatic bool xtfpga_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == XTFPGA_I2S_INT_STATUS;\n}\n\nstatic const struct regmap_config xtfpga_i2s_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = XTFPGA_I2S_CHAN3_DATA,\n\t.writeable_reg = xtfpga_i2s_wr_reg,\n\t.readable_reg = xtfpga_i2s_rd_reg,\n\t.volatile_reg = xtfpga_i2s_volatile_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\n \n#define xtfpga_pcm_tx_fn(channels, sample_bits) \\\nstatic unsigned xtfpga_pcm_tx_##channels##x##sample_bits( \\\n\tstruct xtfpga_i2s *i2s, struct snd_pcm_runtime *runtime, \\\n\tunsigned tx_ptr) \\\n{ \\\n\tconst u##sample_bits (*p)[channels] = \\\n\t\t(void *)runtime->dma_area; \\\n\\\n\tfor (; i2s->tx_fifo_level < i2s->tx_fifo_high; \\\n\t     i2s->tx_fifo_level += 2) { \\\n\t\tiowrite32(p[tx_ptr][0], \\\n\t\t\t  i2s->regs + XTFPGA_I2S_CHAN0_DATA); \\\n\t\tiowrite32(p[tx_ptr][channels - 1], \\\n\t\t\t  i2s->regs + XTFPGA_I2S_CHAN0_DATA); \\\n\t\tif (++tx_ptr >= runtime->buffer_size) \\\n\t\t\ttx_ptr = 0; \\\n\t} \\\n\treturn tx_ptr; \\\n}\n\nxtfpga_pcm_tx_fn(1, 16)\nxtfpga_pcm_tx_fn(2, 16)\nxtfpga_pcm_tx_fn(1, 32)\nxtfpga_pcm_tx_fn(2, 32)\n\n#undef xtfpga_pcm_tx_fn\n\nstatic bool xtfpga_pcm_push_tx(struct xtfpga_i2s *i2s)\n{\n\tstruct snd_pcm_substream *tx_substream;\n\tbool tx_active;\n\n\trcu_read_lock();\n\ttx_substream = rcu_dereference(i2s->tx_substream);\n\ttx_active = tx_substream && snd_pcm_running(tx_substream);\n\tif (tx_active) {\n\t\tunsigned tx_ptr = READ_ONCE(i2s->tx_ptr);\n\t\tunsigned new_tx_ptr = i2s->tx_fn(i2s, tx_substream->runtime,\n\t\t\t\t\t\t tx_ptr);\n\n\t\tcmpxchg(&i2s->tx_ptr, tx_ptr, new_tx_ptr);\n\t}\n\trcu_read_unlock();\n\n\treturn tx_active;\n}\n\nstatic void xtfpga_pcm_refill_fifo(struct xtfpga_i2s *i2s)\n{\n\tunsigned int_status;\n\tunsigned i;\n\n\tregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS,\n\t\t    &int_status);\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tbool tx_active = xtfpga_pcm_push_tx(i2s);\n\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS,\n\t\t\t     XTFPGA_I2S_INT_VALID);\n\t\tif (tx_active)\n\t\t\tregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS,\n\t\t\t\t    &int_status);\n\n\t\tif (!tx_active ||\n\t\t    !(int_status & XTFPGA_I2S_INT_LEVEL))\n\t\t\tbreak;\n\n\t\t \n\t\ti2s->tx_fifo_level = i2s->tx_fifo_low;\n\t}\n\n\tif (!(int_status & XTFPGA_I2S_INT_LEVEL))\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK,\n\t\t\t     XTFPGA_I2S_INT_VALID);\n\telse if (!(int_status & XTFPGA_I2S_INT_UNDERRUN))\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK,\n\t\t\t     XTFPGA_I2S_INT_UNDERRUN);\n\n\tif (!(int_status & XTFPGA_I2S_INT_UNDERRUN))\n\t\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t\t   XTFPGA_I2S_CONFIG_INT_ENABLE |\n\t\t\t\t   XTFPGA_I2S_CONFIG_TX_ENABLE,\n\t\t\t\t   XTFPGA_I2S_CONFIG_INT_ENABLE |\n\t\t\t\t   XTFPGA_I2S_CONFIG_TX_ENABLE);\n\telse\n\t\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t\t   XTFPGA_I2S_CONFIG_INT_ENABLE |\n\t\t\t\t   XTFPGA_I2S_CONFIG_TX_ENABLE, 0);\n}\n\nstatic irqreturn_t xtfpga_i2s_threaded_irq_handler(int irq, void *dev_id)\n{\n\tstruct xtfpga_i2s *i2s = dev_id;\n\tstruct snd_pcm_substream *tx_substream;\n\tunsigned config, int_status, int_mask;\n\n\tregmap_read(i2s->regmap, XTFPGA_I2S_CONFIG, &config);\n\tregmap_read(i2s->regmap, XTFPGA_I2S_INT_MASK, &int_mask);\n\tregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS, &int_status);\n\n\tif (!(config & XTFPGA_I2S_CONFIG_INT_ENABLE) ||\n\t    !(int_status & int_mask & XTFPGA_I2S_INT_VALID))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (int_status & XTFPGA_I2S_INT_UNDERRUN) {\n\t\ti2s->tx_fifo_level = 0;\n\t\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t\t   XTFPGA_I2S_CONFIG_TX_ENABLE, 0);\n\t} else {\n\t\t \n\t\ti2s->tx_fifo_level = i2s->tx_fifo_low;\n\t}\n\n\trcu_read_lock();\n\ttx_substream = rcu_dereference(i2s->tx_substream);\n\n\tif (tx_substream && snd_pcm_running(tx_substream)) {\n\t\tsnd_pcm_period_elapsed(tx_substream);\n\t\tif (int_status & XTFPGA_I2S_INT_UNDERRUN)\n\t\t\tdev_dbg_ratelimited(i2s->dev, \"%s: underrun\\n\",\n\t\t\t\t\t    __func__);\n\t}\n\trcu_read_unlock();\n\n\t \n\txtfpga_pcm_refill_fifo(i2s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xtfpga_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct xtfpga_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_set_dma_data(dai, substream, i2s);\n\treturn 0;\n}\n\nstatic int xtfpga_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct xtfpga_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tunsigned srate = params_rate(params);\n\tunsigned channels = params_channels(params);\n\tunsigned period_size = params_period_size(params);\n\tunsigned sample_size = snd_pcm_format_width(params_format(params));\n\tunsigned freq, ratio, level;\n\tint err;\n\n\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t   XTFPGA_I2S_CONFIG_RES_MASK,\n\t\t\t   sample_size << XTFPGA_I2S_CONFIG_RES_BASE);\n\n\tfreq = 256 * srate;\n\terr = clk_set_rate(i2s->clk, freq);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tratio = (freq - (srate * sample_size * 8)) /\n\t\t(srate * sample_size * 4);\n\n\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t   XTFPGA_I2S_CONFIG_RATIO_MASK,\n\t\t\t   ratio << XTFPGA_I2S_CONFIG_RATIO_BASE);\n\n\ti2s->tx_fifo_low = XTFPGA_I2S_FIFO_SIZE / 2;\n\n\t \n\tfor (level = 1;\n\t     i2s->tx_fifo_low / 2 >= period_size * 2 &&\n\t     level < (XTFPGA_I2S_CONFIG_LEVEL_MASK >>\n\t\t      XTFPGA_I2S_CONFIG_LEVEL_BASE); ++level)\n\t\ti2s->tx_fifo_low /= 2;\n\n\ti2s->tx_fifo_high = 2 * i2s->tx_fifo_low;\n\n\tregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t\t   XTFPGA_I2S_CONFIG_LEVEL_MASK,\n\t\t\t   level << XTFPGA_I2S_CONFIG_LEVEL_BASE);\n\n\tdev_dbg(i2s->dev,\n\t\t\"%s srate: %u, channels: %u, sample_size: %u, period_size: %u\\n\",\n\t\t__func__, srate, channels, sample_size, period_size);\n\tdev_dbg(i2s->dev, \"%s freq: %u, ratio: %u, level: %u\\n\",\n\t\t__func__, freq, ratio, level);\n\n\treturn 0;\n}\n\nstatic int xtfpga_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t      unsigned int fmt)\n{\n\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\n\t\treturn -EINVAL;\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_BP_FP)\n\t\treturn -EINVAL;\n\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_hardware xtfpga_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.period_bytes_min\t= 2,\n\t.period_bytes_max\t= XTFPGA_I2S_FIFO_SIZE / 2 * 8,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= XTFPGA_I2S_FIFO_SIZE * 8 / 2,\n\t.buffer_bytes_max\t= XTFPGA_I2S_FIFO_SIZE * 8,\n\t.fifo_size\t\t= 16,\n};\n\nstatic int xtfpga_pcm_open(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tvoid *p;\n\n\tsnd_soc_set_runtime_hwparams(substream, &xtfpga_pcm_hardware);\n\tp = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\truntime->private_data = p;\n\n\treturn 0;\n}\n\nstatic int xtfpga_pcm_close(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tsynchronize_rcu();\n\treturn 0;\n}\n\nstatic int xtfpga_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xtfpga_i2s *i2s = runtime->private_data;\n\tunsigned channels = params_channels(hw_params);\n\n\tswitch (channels) {\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\tswitch (params_format(hw_params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\ti2s->tx_fn = (channels == 1) ?\n\t\t\txtfpga_pcm_tx_1x16 :\n\t\t\txtfpga_pcm_tx_2x16;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\ti2s->tx_fn = (channels == 1) ?\n\t\t\txtfpga_pcm_tx_1x32 :\n\t\t\txtfpga_pcm_tx_2x32;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int xtfpga_pcm_trigger(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xtfpga_i2s *i2s = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tWRITE_ONCE(i2s->tx_ptr, 0);\n\t\trcu_assign_pointer(i2s->tx_substream, substream);\n\t\txtfpga_pcm_refill_fifo(i2s);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\trcu_assign_pointer(i2s->tx_substream, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t xtfpga_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xtfpga_i2s *i2s = runtime->private_data;\n\tsnd_pcm_uframes_t pos = READ_ONCE(i2s->tx_ptr);\n\n\treturn pos < runtime->buffer_size ? pos : 0;\n}\n\nstatic int xtfpga_pcm_new(struct snd_soc_component *component,\n\t\t\t  struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tsize_t size = xtfpga_pcm_hardware.buffer_bytes_max;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, size, size);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver xtfpga_i2s_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.open\t\t\t= xtfpga_pcm_open,\n\t.close\t\t\t= xtfpga_pcm_close,\n\t.hw_params\t\t= xtfpga_pcm_hw_params,\n\t.trigger\t\t= xtfpga_pcm_trigger,\n\t.pointer\t\t= xtfpga_pcm_pointer,\n\t.pcm_construct\t\t= xtfpga_pcm_new,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops xtfpga_i2s_dai_ops = {\n\t.startup\t= xtfpga_i2s_startup,\n\t.hw_params      = xtfpga_i2s_hw_params,\n\t.set_fmt\t= xtfpga_i2s_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver xtfpga_i2s_dai[] = {\n\t{\n\t\t.name = \"xtfpga-i2s\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &xtfpga_i2s_dai_ops,\n\t},\n};\n\nstatic int xtfpga_i2s_runtime_suspend(struct device *dev)\n{\n\tstruct xtfpga_i2s *i2s = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(i2s->clk);\n\treturn 0;\n}\n\nstatic int xtfpga_i2s_runtime_resume(struct device *dev)\n{\n\tstruct xtfpga_i2s *i2s = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(i2s->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"clk_prepare_enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int xtfpga_i2s_probe(struct platform_device *pdev)\n{\n\tstruct xtfpga_i2s *i2s;\n\tint err, irq;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tplatform_set_drvdata(pdev, i2s);\n\ti2s->dev = &pdev->dev;\n\tdev_dbg(&pdev->dev, \"dev: %p, i2s: %p\\n\", &pdev->dev, i2s);\n\n\ti2s->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2s->regs)) {\n\t\terr = PTR_ERR(i2s->regs);\n\t\tgoto err;\n\t}\n\n\ti2s->regmap = devm_regmap_init_mmio(&pdev->dev, i2s->regs,\n\t\t\t\t\t    &xtfpga_i2s_regmap_config);\n\tif (IS_ERR(i2s->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\terr = PTR_ERR(i2s->regmap);\n\t\tgoto err;\n\t}\n\n\ti2s->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2s->clk)) {\n\t\tdev_err(&pdev->dev, \"couldn't get clock\\n\");\n\t\terr = PTR_ERR(i2s->clk);\n\t\tgoto err;\n\t}\n\n\tregmap_write(i2s->regmap, XTFPGA_I2S_CONFIG,\n\t\t     (0x1 << XTFPGA_I2S_CONFIG_CHANNEL_BASE));\n\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS, XTFPGA_I2S_INT_VALID);\n\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK, XTFPGA_I2S_INT_UNDERRUN);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto err;\n\t}\n\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\txtfpga_i2s_threaded_irq_handler,\n\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, i2s);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto err;\n\t}\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &xtfpga_i2s_component,\n\t\t\t\t\t      xtfpga_i2s_dai,\n\t\t\t\t\t      ARRAY_SIZE(xtfpga_i2s_dai));\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"couldn't register component\\n\");\n\t\tgoto err;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\terr = xtfpga_i2s_runtime_resume(&pdev->dev);\n\t\tif (err)\n\t\t\tgoto err_pm_disable;\n\t}\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nerr:\n\tdev_err(&pdev->dev, \"%s: err = %d\\n\", __func__, err);\n\treturn err;\n}\n\nstatic void xtfpga_i2s_remove(struct platform_device *pdev)\n{\n\tstruct xtfpga_i2s *i2s = dev_get_drvdata(&pdev->dev);\n\n\tif (i2s->regmap && !IS_ERR(i2s->regmap)) {\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_CONFIG, 0);\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK, 0);\n\t\tregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS,\n\t\t\t     XTFPGA_I2S_INT_VALID);\n\t}\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\txtfpga_i2s_runtime_suspend(&pdev->dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id xtfpga_i2s_of_match[] = {\n\t{ .compatible = \"cdns,xtfpga-i2s\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xtfpga_i2s_of_match);\n#endif\n\nstatic const struct dev_pm_ops xtfpga_i2s_pm_ops = {\n\tSET_RUNTIME_PM_OPS(xtfpga_i2s_runtime_suspend,\n\t\t\t   xtfpga_i2s_runtime_resume, NULL)\n};\n\nstatic struct platform_driver xtfpga_i2s_driver = {\n\t.probe   = xtfpga_i2s_probe,\n\t.remove_new = xtfpga_i2s_remove,\n\t.driver  = {\n\t\t.name = \"xtfpga-i2s\",\n\t\t.of_match_table = of_match_ptr(xtfpga_i2s_of_match),\n\t\t.pm = &xtfpga_i2s_pm_ops,\n\t},\n};\n\nmodule_platform_driver(xtfpga_i2s_driver);\n\nMODULE_AUTHOR(\"Max Filippov <jcmvbkbc@gmail.com>\");\nMODULE_DESCRIPTION(\"xtfpga I2S controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}