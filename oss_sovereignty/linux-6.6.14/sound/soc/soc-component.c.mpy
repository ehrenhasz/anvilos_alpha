{
  "module_name": "soc-component.c",
  "hash_id": "c6b6d38892f412e8d37224a2eb135fb141b7d225f91896b5eb4569eda1a80427",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-component.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <linux/bitops.h>\n\n#define soc_component_ret(dai, ret) _soc_component_ret(dai, __func__, ret, -1)\n#define soc_component_ret_reg_rw(dai, ret, reg) _soc_component_ret(dai, __func__, ret, reg)\nstatic inline int _soc_component_ret(struct snd_soc_component *component,\n\t\t\t\t     const char *func, int ret, int reg)\n{\n\t \n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\tswitch (ret) {\n\tcase -EPROBE_DEFER:\n\tcase -ENOTSUPP:\n\t\tbreak;\n\tdefault:\n\t\tif (reg == -1)\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"ASoC: error at %s on %s: %d\\n\",\n\t\t\t\tfunc, component->name, ret);\n\t\telse\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"ASoC: error at %s on %s for register: [0x%08x] %d\\n\",\n\t\t\t\tfunc, component->name, reg, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic inline int soc_component_field_shift(struct snd_soc_component *component,\n\t\t\t\t\t    unsigned int mask)\n{\n\tif (!mask) {\n\t\tdev_err(component->dev,\t\"ASoC: error field mask is zero for %s\\n\",\n\t\t\tcomponent->name);\n\t\treturn 0;\n\t}\n\n\treturn (ffs(mask) - 1);\n}\n\n \n#define soc_component_mark_push(component, substream, tgt)\t((component)->mark_##tgt = substream)\n#define soc_component_mark_pop(component, substream, tgt)\t((component)->mark_##tgt = NULL)\n#define soc_component_mark_match(component, substream, tgt)\t((component)->mark_##tgt == substream)\n\nvoid snd_soc_component_set_aux(struct snd_soc_component *component,\n\t\t\t       struct snd_soc_aux_dev *aux)\n{\n\tcomponent->init = (aux) ? aux->init : NULL;\n}\n\nint snd_soc_component_init(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\tif (component->init)\n\t\tret = component->init(component);\n\n\treturn soc_component_ret(component, ret);\n}\n\n \nint snd_soc_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\t int clk_id, int source, unsigned int freq,\n\t\t\t\t int dir)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (component->driver->set_sysclk)\n\t\tret = component->driver->set_sysclk(component, clk_id, source,\n\t\t\t\t\t\t     freq, dir);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);\n\n \nint snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,\n\t\t\t      int source, unsigned int freq_in,\n\t\t\t      unsigned int freq_out)\n{\n\tint ret = -EINVAL;\n\n\tif (component->driver->set_pll)\n\t\tret = component->driver->set_pll(component, pll_id, source,\n\t\t\t\t\t\t  freq_in, freq_out);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_set_pll);\n\nvoid snd_soc_component_seq_notifier(struct snd_soc_component *component,\n\t\t\t\t    enum snd_soc_dapm_type type, int subseq)\n{\n\tif (component->driver->seq_notifier)\n\t\tcomponent->driver->seq_notifier(component, type, subseq);\n}\n\nint snd_soc_component_stream_event(struct snd_soc_component *component,\n\t\t\t\t   int event)\n{\n\tint ret = 0;\n\n\tif (component->driver->stream_event)\n\t\tret = component->driver->stream_event(component, event);\n\n\treturn soc_component_ret(component, ret);\n}\n\nint snd_soc_component_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t     enum snd_soc_bias_level level)\n{\n\tint ret = 0;\n\n\tif (component->driver->set_bias_level)\n\t\tret = component->driver->set_bias_level(component, level);\n\n\treturn soc_component_ret(component, ret);\n}\n\nint snd_soc_component_enable_pin(struct snd_soc_component *component,\n\t\t\t\t const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_enable_pin(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_enable_pin);\n\nint snd_soc_component_enable_pin_unlocked(struct snd_soc_component *component,\n\t\t\t\t\t  const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_enable_pin_unlocked(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_enable_pin_unlocked);\n\nint snd_soc_component_disable_pin(struct snd_soc_component *component,\n\t\t\t\t  const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_disable_pin(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_disable_pin);\n\nint snd_soc_component_disable_pin_unlocked(struct snd_soc_component *component,\n\t\t\t\t\t   const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm = \n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_disable_pin_unlocked(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_disable_pin_unlocked);\n\nint snd_soc_component_nc_pin(struct snd_soc_component *component,\n\t\t\t     const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_nc_pin(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_nc_pin);\n\nint snd_soc_component_nc_pin_unlocked(struct snd_soc_component *component,\n\t\t\t\t      const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_nc_pin_unlocked(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_nc_pin_unlocked);\n\nint snd_soc_component_get_pin_status(struct snd_soc_component *component,\n\t\t\t\t     const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_get_pin_status(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_get_pin_status);\n\nint snd_soc_component_force_enable_pin(struct snd_soc_component *component,\n\t\t\t\t       const char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_force_enable_pin(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_force_enable_pin);\n\nint snd_soc_component_force_enable_pin_unlocked(\n\tstruct snd_soc_component *component,\n\tconst char *pin)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\treturn snd_soc_dapm_force_enable_pin_unlocked(dapm, pin);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_force_enable_pin_unlocked);\n\nint snd_soc_component_notify_control(struct snd_soc_component *component,\n\t\t\t\t     const char * const ctl)\n{\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tstruct snd_kcontrol *kctl;\n\n\t \n\tif (component->name_prefix)\n\t\tsnprintf(name, ARRAY_SIZE(name), \"%s %s\", component->name_prefix, ctl);\n\telse\n\t\tsnprintf(name, ARRAY_SIZE(name), \"%s\", ctl);\n\n\tkctl = snd_soc_card_get_kcontrol(component->card, name);\n\tif (!kctl)\n\t\treturn soc_component_ret(component, -EINVAL);\n\n\tsnd_ctl_notify(component->card->snd_card,\n\t\t       SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_notify_control);\n\n \nint snd_soc_component_set_jack(struct snd_soc_component *component,\n\t\t\t       struct snd_soc_jack *jack, void *data)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (component->driver->set_jack)\n\t\tret = component->driver->set_jack(component, jack, data);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_set_jack);\n\n \nint snd_soc_component_get_jack_type(\n\tstruct snd_soc_component *component)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (component->driver->get_jack_type)\n\t\tret = component->driver->get_jack_type(component);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_get_jack_type);\n\nint snd_soc_component_module_get(struct snd_soc_component *component,\n\t\t\t\t void *mark, int upon_open)\n{\n\tint ret = 0;\n\n\tif (component->driver->module_get_upon_open == !!upon_open &&\n\t    !try_module_get(component->dev->driver->owner))\n\t\tret = -ENODEV;\n\n\t \n\tif (ret == 0)\n\t\tsoc_component_mark_push(component, mark, module);\n\n\treturn soc_component_ret(component, ret);\n}\n\nvoid snd_soc_component_module_put(struct snd_soc_component *component,\n\t\t\t\t  void *mark, int upon_open, int rollback)\n{\n\tif (rollback && !soc_component_mark_match(component, mark, module))\n\t\treturn;\n\n\tif (component->driver->module_get_upon_open == !!upon_open)\n\t\tmodule_put(component->dev->driver->owner);\n\n\t \n\tsoc_component_mark_pop(component, mark, module);\n}\n\nint snd_soc_component_open(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tint ret = 0;\n\n\tif (component->driver->open)\n\t\tret = component->driver->open(component, substream);\n\n\t \n\tif (ret == 0)\n\t\tsoc_component_mark_push(component, substream, open);\n\n\treturn soc_component_ret(component, ret);\n}\n\nint snd_soc_component_close(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t    int rollback)\n{\n\tint ret = 0;\n\n\tif (rollback && !soc_component_mark_match(component, substream, open))\n\t\treturn 0;\n\n\tif (component->driver->close)\n\t\tret = component->driver->close(component, substream);\n\n\t \n\tsoc_component_mark_pop(component, substream, open);\n\n\treturn soc_component_ret(component, ret);\n}\n\nvoid snd_soc_component_suspend(struct snd_soc_component *component)\n{\n\tif (component->driver->suspend)\n\t\tcomponent->driver->suspend(component);\n\tcomponent->suspended = 1;\n}\n\nvoid snd_soc_component_resume(struct snd_soc_component *component)\n{\n\tif (component->driver->resume)\n\t\tcomponent->driver->resume(component);\n\tcomponent->suspended = 0;\n}\n\nint snd_soc_component_is_suspended(struct snd_soc_component *component)\n{\n\treturn component->suspended;\n}\n\nint snd_soc_component_probe(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\tif (component->driver->probe)\n\t\tret = component->driver->probe(component);\n\n\treturn soc_component_ret(component, ret);\n}\n\nvoid snd_soc_component_remove(struct snd_soc_component *component)\n{\n\tif (component->driver->remove)\n\t\tcomponent->driver->remove(component);\n}\n\nint snd_soc_component_of_xlate_dai_id(struct snd_soc_component *component,\n\t\t\t\t      struct device_node *ep)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (component->driver->of_xlate_dai_id)\n\t\tret = component->driver->of_xlate_dai_id(component, ep);\n\n\treturn soc_component_ret(component, ret);\n}\n\nint snd_soc_component_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t\tconst struct of_phandle_args *args,\n\t\t\t\t\tconst char **dai_name)\n{\n\tif (component->driver->of_xlate_dai_name)\n\t\treturn component->driver->of_xlate_dai_name(component,\n\t\t\t\t\t\t\t    args, dai_name);\n\t \n\treturn -ENOTSUPP;\n}\n\nvoid snd_soc_component_setup_regmap(struct snd_soc_component *component)\n{\n\tint val_bytes = regmap_get_val_bytes(component->regmap);\n\n\t \n\tif (val_bytes > 0)\n\t\tcomponent->val_bytes = val_bytes;\n}\n\n#ifdef CONFIG_REGMAP\n\n \nvoid snd_soc_component_init_regmap(struct snd_soc_component *component,\n\t\t\t\t   struct regmap *regmap)\n{\n\tcomponent->regmap = regmap;\n\tsnd_soc_component_setup_regmap(component);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_init_regmap);\n\n \nvoid snd_soc_component_exit_regmap(struct snd_soc_component *component)\n{\n\tregmap_exit(component->regmap);\n\tcomponent->regmap = NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);\n\n#endif\n\nint snd_soc_component_compr_open(struct snd_soc_component *component,\n\t\t\t\t struct snd_compr_stream *cstream)\n{\n\tint ret = 0;\n\n\tif (component->driver->compress_ops &&\n\t    component->driver->compress_ops->open)\n\t\tret = component->driver->compress_ops->open(component, cstream);\n\n\t \n\tif (ret == 0)\n\t\tsoc_component_mark_push(component, cstream, compr_open);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_open);\n\nvoid snd_soc_component_compr_free(struct snd_soc_component *component,\n\t\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t\t  int rollback)\n{\n\tif (rollback && !soc_component_mark_match(component, cstream, compr_open))\n\t\treturn;\n\n\tif (component->driver->compress_ops &&\n\t    component->driver->compress_ops->free)\n\t\tcomponent->driver->compress_ops->free(component, cstream);\n\n\t \n\tsoc_component_mark_pop(component, cstream, compr_open);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_free);\n\nint snd_soc_component_compr_trigger(struct snd_compr_stream *cstream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->trigger) {\n\t\t\tret = component->driver->compress_ops->trigger(\n\t\t\t\tcomponent, cstream, cmd);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_trigger);\n\nint snd_soc_component_compr_set_params(struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_compr_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->set_params) {\n\t\t\tret = component->driver->compress_ops->set_params(\n\t\t\t\tcomponent, cstream, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_set_params);\n\nint snd_soc_component_compr_get_params(struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_codec *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->get_params) {\n\t\t\tret = component->driver->compress_ops->get_params(\n\t\t\t\tcomponent, cstream, params);\n\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_get_params);\n\nint snd_soc_component_compr_get_caps(struct snd_compr_stream *cstream,\n\t\t\t\t     struct snd_compr_caps *caps)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->get_caps) {\n\t\t\tret = component->driver->compress_ops->get_caps(\n\t\t\t\tcomponent, cstream, caps);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_get_caps);\n\nint snd_soc_component_compr_get_codec_caps(struct snd_compr_stream *cstream,\n\t\t\t\t\t   struct snd_compr_codec_caps *codec)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->get_codec_caps) {\n\t\t\tret = component->driver->compress_ops->get_codec_caps(\n\t\t\t\tcomponent, cstream, codec);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_get_codec_caps);\n\nint snd_soc_component_compr_ack(struct snd_compr_stream *cstream, size_t bytes)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->ack) {\n\t\t\tret = component->driver->compress_ops->ack(\n\t\t\t\tcomponent, cstream, bytes);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_ack);\n\nint snd_soc_component_compr_pointer(struct snd_compr_stream *cstream,\n\t\t\t\t    struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->pointer) {\n\t\t\tret = component->driver->compress_ops->pointer(\n\t\t\t\tcomponent, cstream, tstamp);\n\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_pointer);\n\nint snd_soc_component_compr_copy(struct snd_compr_stream *cstream,\n\t\t\t\t char __user *buf, size_t count)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->copy) {\n\t\t\tret = component->driver->compress_ops->copy(\n\t\t\t\tcomponent, cstream, buf, count);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\n\treturn soc_component_ret(component, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_copy);\n\nint snd_soc_component_compr_set_metadata(struct snd_compr_stream *cstream,\n\t\t\t\t\t struct snd_compr_metadata *metadata)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->set_metadata) {\n\t\t\tret = component->driver->compress_ops->set_metadata(\n\t\t\t\tcomponent, cstream, metadata);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_set_metadata);\n\nint snd_soc_component_compr_get_metadata(struct snd_compr_stream *cstream,\n\t\t\t\t\t struct snd_compr_metadata *metadata)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->compress_ops &&\n\t\t    component->driver->compress_ops->get_metadata) {\n\t\t\tret = component->driver->compress_ops->get_metadata(\n\t\t\t\tcomponent, cstream, metadata);\n\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_compr_get_metadata);\n\nstatic unsigned int soc_component_read_no_lock(\n\tstruct snd_soc_component *component,\n\tunsigned int reg)\n{\n\tint ret;\n\tunsigned int val = 0;\n\n\tif (component->regmap)\n\t\tret = regmap_read(component->regmap, reg, &val);\n\telse if (component->driver->read) {\n\t\tret = 0;\n\t\tval = component->driver->read(component, reg);\n\t}\n\telse\n\t\tret = -EIO;\n\n\tif (ret < 0)\n\t\treturn soc_component_ret_reg_rw(component, ret, reg);\n\n\treturn val;\n}\n\n \nunsigned int snd_soc_component_read(struct snd_soc_component *component,\n\t\t\t\t    unsigned int reg)\n{\n\tunsigned int val;\n\n\tmutex_lock(&component->io_mutex);\n\tval = soc_component_read_no_lock(component, reg);\n\tmutex_unlock(&component->io_mutex);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_read);\n\nstatic int soc_component_write_no_lock(\n\tstruct snd_soc_component *component,\n\tunsigned int reg, unsigned int val)\n{\n\tint ret = -EIO;\n\n\tif (component->regmap)\n\t\tret = regmap_write(component->regmap, reg, val);\n\telse if (component->driver->write)\n\t\tret = component->driver->write(component, reg, val);\n\n\treturn soc_component_ret_reg_rw(component, ret, reg);\n}\n\n \nint snd_soc_component_write(struct snd_soc_component *component,\n\t\t\t    unsigned int reg, unsigned int val)\n{\n\tint ret;\n\n\tmutex_lock(&component->io_mutex);\n\tret = soc_component_write_no_lock(component, reg, val);\n\tmutex_unlock(&component->io_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_write);\n\nstatic int snd_soc_component_update_bits_legacy(\n\tstruct snd_soc_component *component, unsigned int reg,\n\tunsigned int mask, unsigned int val, bool *change)\n{\n\tunsigned int old, new;\n\tint ret = 0;\n\n\tmutex_lock(&component->io_mutex);\n\n\told = soc_component_read_no_lock(component, reg);\n\n\tnew = (old & ~mask) | (val & mask);\n\t*change = old != new;\n\tif (*change)\n\t\tret = soc_component_write_no_lock(component, reg, new);\n\n\tmutex_unlock(&component->io_mutex);\n\n\treturn soc_component_ret_reg_rw(component, ret, reg);\n}\n\n \nint snd_soc_component_update_bits(struct snd_soc_component *component,\n\t\t\t\t  unsigned int reg, unsigned int mask, unsigned int val)\n{\n\tbool change;\n\tint ret;\n\n\tif (component->regmap)\n\t\tret = regmap_update_bits_check(component->regmap, reg, mask,\n\t\t\t\t\t       val, &change);\n\telse\n\t\tret = snd_soc_component_update_bits_legacy(component, reg,\n\t\t\t\t\t\t\t   mask, val, &change);\n\n\tif (ret < 0)\n\t\treturn soc_component_ret_reg_rw(component, ret, reg);\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_update_bits);\n\n \nint snd_soc_component_update_bits_async(struct snd_soc_component *component,\n\t\t\t\t\tunsigned int reg, unsigned int mask, unsigned int val)\n{\n\tbool change;\n\tint ret;\n\n\tif (component->regmap)\n\t\tret = regmap_update_bits_check_async(component->regmap, reg,\n\t\t\t\t\t\t     mask, val, &change);\n\telse\n\t\tret = snd_soc_component_update_bits_legacy(component, reg,\n\t\t\t\t\t\t\t   mask, val, &change);\n\n\tif (ret < 0)\n\t\treturn soc_component_ret_reg_rw(component, ret, reg);\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_update_bits_async);\n\n \nunsigned int snd_soc_component_read_field(struct snd_soc_component *component,\n\t\t\t\t\t  unsigned int reg, unsigned int mask)\n{\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, reg);\n\n\tval = (val & mask) >> soc_component_field_shift(component, mask);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_read_field);\n\n \nint snd_soc_component_write_field(struct snd_soc_component *component,\n\t\t\t\t  unsigned int reg, unsigned int mask,\n\t\t\t\t  unsigned int val)\n{\n\n\tval = (val << soc_component_field_shift(component, mask)) & mask;\n\n\treturn snd_soc_component_update_bits(component, reg, mask, val);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_write_field);\n\n \nvoid snd_soc_component_async_complete(struct snd_soc_component *component)\n{\n\tif (component->regmap)\n\t\tregmap_async_complete(component->regmap);\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_async_complete);\n\n \nint snd_soc_component_test_bits(struct snd_soc_component *component,\n\t\t\t\tunsigned int reg, unsigned int mask, unsigned int value)\n{\n\tunsigned int old, new;\n\n\told = snd_soc_component_read(component, reg);\n\tnew = (old & ~mask) | value;\n\treturn old != new;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_test_bits);\n\nint snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->pointer)\n\t\t\treturn component->driver->pointer(component, substream);\n\n\treturn 0;\n}\n\nstatic bool snd_soc_component_is_codec_on_rtd(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t      struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tfor_each_rtd_codec_dais(rtd, i, dai) {\n\t\tif (dai->component == component)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid snd_soc_pcm_component_delay(struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_sframes_t *cpu_delay,\n\t\t\t\t snd_pcm_sframes_t *codec_delay)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tsnd_pcm_sframes_t delay;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (!component->driver->delay)\n\t\t\tcontinue;\n\n\t\tdelay = component->driver->delay(component, substream);\n\n\t\tif (snd_soc_component_is_codec_on_rtd(rtd, component))\n\t\t\t*codec_delay = max(*codec_delay, delay);\n\t\telse\n\t\t\t*cpu_delay = max(*cpu_delay, delay);\n\t}\n}\n\nint snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,\n\t\t\t\tunsigned int cmd, void *arg)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->ioctl)\n\t\t\treturn soc_component_ret(\n\t\t\t\tcomponent,\n\t\t\t\tcomponent->driver->ioctl(component,\n\t\t\t\t\t\t\t substream, cmd, arg));\n\n\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nint snd_soc_pcm_component_sync_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->sync_stop) {\n\t\t\tret = component->driver->sync_stop(component,\n\t\t\t\t\t\t\t   substream);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_soc_pcm_component_copy(struct snd_pcm_substream *substream,\n\t\t\t       int channel, unsigned long pos,\n\t\t\t       struct iov_iter *iter, unsigned long bytes)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->copy)\n\t\t\treturn soc_component_ret(component,\n\t\t\t\tcomponent->driver->copy(component, substream,\n\t\t\t\t\tchannel, pos, iter, bytes));\n\n\treturn -EINVAL;\n}\n\nstruct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,\n\t\t\t\t\tunsigned long offset)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tstruct page *page;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->page) {\n\t\t\tpage = component->driver->page(component,\n\t\t\t\t\t\t       substream, offset);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,\n\t\t\t       struct vm_area_struct *vma)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->mmap)\n\t\t\treturn soc_component_ret(\n\t\t\t\tcomponent,\n\t\t\t\tcomponent->driver->mmap(component,\n\t\t\t\t\t\t\tsubstream, vma));\n\n\treturn -EINVAL;\n}\n\nint snd_soc_pcm_component_new(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component;\n\tint ret;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->pcm_construct) {\n\t\t\tret = component->driver->pcm_construct(component, rtd);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid snd_soc_pcm_component_free(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component;\n\tint i;\n\n\tif (!rtd->pcm)\n\t\treturn;\n\n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->pcm_destruct)\n\t\t\tcomponent->driver->pcm_destruct(component, rtd->pcm);\n}\n\nint snd_soc_pcm_component_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->prepare) {\n\t\t\tret = component->driver->prepare(component, substream);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_soc_pcm_component_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->hw_params) {\n\t\t\tret = component->driver->hw_params(component,\n\t\t\t\t\t\t\t   substream, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t\t \n\t\tsoc_component_mark_push(component, substream, hw_params);\n\t}\n\n\treturn 0;\n}\n\nvoid snd_soc_pcm_component_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t   int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (rollback && !soc_component_mark_match(component, substream, hw_params))\n\t\t\tcontinue;\n\n\t\tif (component->driver->hw_free) {\n\t\t\tret = component->driver->hw_free(component, substream);\n\t\t\tif (ret < 0)\n\t\t\t\tsoc_component_ret(component, ret);\n\t\t}\n\n\t\t \n\t\tsoc_component_mark_pop(component, substream, hw_params);\n\t}\n}\n\nstatic int soc_component_trigger(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t int cmd)\n{\n\tint ret = 0;\n\n\tif (component->driver->trigger)\n\t\tret = component->driver->trigger(component, substream, cmd);\n\n\treturn soc_component_ret(component, ret);\n}\n\nint snd_soc_pcm_component_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t  int cmd, int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, r, ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\tret = soc_component_trigger(component, substream, cmd);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tsoc_component_mark_push(component, substream, trigger);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\tif (rollback && !soc_component_mark_match(component, substream, trigger))\n\t\t\t\tcontinue;\n\n\t\t\tr = soc_component_trigger(component, substream, cmd);\n\t\t\tif (r < 0)\n\t\t\t\tret = r;  \n\t\t\tsoc_component_mark_pop(component, substream, trigger);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint snd_soc_pcm_component_pm_runtime_get(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t void *stream)\n{\n\tstruct snd_soc_component *component;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tint ret = pm_runtime_get_sync(component->dev);\n\t\tif (ret < 0 && ret != -EACCES) {\n\t\t\tpm_runtime_put_noidle(component->dev);\n\t\t\treturn soc_component_ret(component, ret);\n\t\t}\n\t\t \n\t\tsoc_component_mark_push(component, stream, pm);\n\t}\n\n\treturn 0;\n}\n\nvoid snd_soc_pcm_component_pm_runtime_put(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t  void *stream, int rollback)\n{\n\tstruct snd_soc_component *component;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (rollback && !soc_component_mark_match(component, stream, pm))\n\t\t\tcontinue;\n\n\t\tpm_runtime_mark_last_busy(component->dev);\n\t\tpm_runtime_put_autosuspend(component->dev);\n\n\t\t \n\t\tsoc_component_mark_pop(component, stream, pm);\n\t}\n}\n\nint snd_soc_pcm_component_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i;\n\n\t \n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (component->driver->ack)\n\t\t\treturn component->driver->ack(component, substream);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}