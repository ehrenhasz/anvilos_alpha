{
  "module_name": "soc-ops.c",
  "hash_id": "e302e63465776edfe2d3c462d6d9a9ffd0e38cfd350405500ea56108d706cb19",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-ops.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dpcm.h>\n#include <sound/initval.h>\n\n \nint snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\n\treturn snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,\n\t\t\t\t e->items, e->texts);\n}\nEXPORT_SYMBOL_GPL(snd_soc_info_enum_double);\n\n \nint snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int val, item;\n\tunsigned int reg_val;\n\n\treg_val = snd_soc_component_read(component, e->reg);\n\tval = (reg_val >> e->shift_l) & e->mask;\n\titem = snd_soc_enum_val_to_item(e, val);\n\tucontrol->value.enumerated.item[0] = item;\n\tif (e->shift_l != e->shift_r) {\n\t\tval = (reg_val >> e->shift_r) & e->mask;\n\t\titem = snd_soc_enum_val_to_item(e, val);\n\t\tucontrol->value.enumerated.item[1] = item;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_enum_double);\n\n \nint snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val;\n\tunsigned int mask;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\tmask = e->mask << e->shift_l;\n\tif (e->shift_l != e->shift_r) {\n\t\tif (item[1] >= e->items)\n\t\t\treturn -EINVAL;\n\t\tval |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;\n\t\tmask |= e->mask << e->shift_r;\n\t}\n\n\treturn snd_soc_component_update_bits(component, e->reg, mask, val);\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_enum_double);\n\n \nstatic int snd_soc_read_signed(struct snd_soc_component *component,\n\tunsigned int reg, unsigned int mask, unsigned int shift,\n\tunsigned int sign_bit, int *signed_val)\n{\n\tint ret;\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, reg);\n\tval = (val >> shift) & mask;\n\n\tif (!sign_bit) {\n\t\t*signed_val = val;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(val & BIT(sign_bit))) {\n\t\t*signed_val = val;\n\t\treturn 0;\n\t}\n\n\tret = val;\n\n\t \n\tret |= ~((int)(BIT(sign_bit) - 1));\n\n\t*signed_val = ret;\n\n\treturn 0;\n}\n\n \nint snd_soc_info_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tconst char *vol_string = NULL;\n\tint max;\n\n\tmax = uinfo->value.integer.max = mc->max - mc->min;\n\tif (mc->platform_max && mc->platform_max < max)\n\t\tmax = mc->platform_max;\n\n\tif (max == 1) {\n\t\t \n\t\tvol_string = strstr(kcontrol->id.name, \" Volume\");\n\t\tif (vol_string && !strcmp(vol_string, \" Volume\"))\n\t\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\t\telse\n\t\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\t} else {\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\t}\n\n\tuinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_info_volsw);\n\n \nint snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint max;\n\n\tif (mc->platform_max)\n\t\tmax = mc->platform_max;\n\telse\n\t\tmax = mc->max;\n\n\tif (max == 1 && !strstr(kcontrol->id.name, \" Volume\"))\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\n\tuinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_info_volsw_sx);\n\n \nint snd_soc_get_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint min = mc->min;\n\tint sign_bit = mc->sign_bit;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tint val;\n\tint ret;\n\n\tif (sign_bit)\n\t\tmask = BIT(sign_bit + 1) - 1;\n\n\tret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tucontrol->value.integer.value[0] = val - min;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmax - ucontrol->value.integer.value[0];\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tif (reg == reg2)\n\t\t\tret = snd_soc_read_signed(component, reg, mask, rshift,\n\t\t\t\tsign_bit, &val);\n\t\telse\n\t\t\tret = snd_soc_read_signed(component, reg2, mask, shift,\n\t\t\t\tsign_bit, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tucontrol->value.integer.value[1] = val - min;\n\t\tif (invert)\n\t\t\tucontrol->value.integer.value[1] =\n\t\t\t\tmax - ucontrol->value.integer.value[1];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_volsw);\n\n \nint snd_soc_put_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint min = mc->min;\n\tunsigned int sign_bit = mc->sign_bit;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tint err, ret;\n\tbool type_2r = false;\n\tunsigned int val2 = 0;\n\tunsigned int val, val_mask;\n\n\tif (sign_bit)\n\t\tmask = BIT(sign_bit + 1) - 1;\n\n\tif (ucontrol->value.integer.value[0] < 0)\n\t\treturn -EINVAL;\n\tval = ucontrol->value.integer.value[0];\n\tif (mc->platform_max && ((int)val + min) > mc->platform_max)\n\t\treturn -EINVAL;\n\tif (val > max - min)\n\t\treturn -EINVAL;\n\tval = (val + min) & mask;\n\tif (invert)\n\t\tval = max - val;\n\tval_mask = mask << shift;\n\tval = val << shift;\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tif (ucontrol->value.integer.value[1] < 0)\n\t\t\treturn -EINVAL;\n\t\tval2 = ucontrol->value.integer.value[1];\n\t\tif (mc->platform_max && ((int)val2 + min) > mc->platform_max)\n\t\t\treturn -EINVAL;\n\t\tif (val2 > max - min)\n\t\t\treturn -EINVAL;\n\t\tval2 = (val2 + min) & mask;\n\t\tif (invert)\n\t\t\tval2 = max - val2;\n\t\tif (reg == reg2) {\n\t\t\tval_mask |= mask << rshift;\n\t\t\tval |= val2 << rshift;\n\t\t} else {\n\t\t\tval2 = val2 << shift;\n\t\t\ttype_2r = true;\n\t\t}\n\t}\n\terr = snd_soc_component_update_bits(component, reg, val_mask, val);\n\tif (err < 0)\n\t\treturn err;\n\tret = err;\n\n\tif (type_2r) {\n\t\terr = snd_soc_component_update_bits(component, reg2, val_mask,\n\t\t\t\t\t\t    val2);\n\t\t \n\t\tif (ret == 0 || err < 0) {\n\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_volsw);\n\n \nint snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t    (struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint min = mc->min;\n\tunsigned int mask = (1U << (fls(min + max) - 1)) - 1;\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, reg);\n\tucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tval = snd_soc_component_read(component, reg2);\n\t\tval = ((val >> rshift) - min) & mask;\n\t\tucontrol->value.integer.value[1] = val;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);\n\n \nint snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t    (struct soc_mixer_control *)kcontrol->private_value;\n\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint min = mc->min;\n\tunsigned int mask = (1U << (fls(min + max) - 1)) - 1;\n\tint err = 0;\n\tint ret;\n\tunsigned int val, val_mask;\n\n\tif (ucontrol->value.integer.value[0] < 0)\n\t\treturn -EINVAL;\n\tval = ucontrol->value.integer.value[0];\n\tif (mc->platform_max && val > mc->platform_max)\n\t\treturn -EINVAL;\n\tif (val > max)\n\t\treturn -EINVAL;\n\tval_mask = mask << shift;\n\tval = (val + min) & mask;\n\tval = val << shift;\n\n\terr = snd_soc_component_update_bits(component, reg, val_mask, val);\n\tif (err < 0)\n\t\treturn err;\n\tret = err;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tunsigned int val2 = ucontrol->value.integer.value[1];\n\n\t\tif (mc->platform_max && val2 > mc->platform_max)\n\t\t\treturn -EINVAL;\n\t\tif (val2 > max)\n\t\t\treturn -EINVAL;\n\n\t\tval_mask = mask << rshift;\n\t\tval2 = (val2 + min) & mask;\n\t\tval2 = val2 << rshift;\n\n\t\terr = snd_soc_component_update_bits(component, reg2, val_mask,\n\t\t\tval2);\n\n\t\t \n\t\tif (ret == 0 || err < 0) {\n\t\t\tret = err;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);\n\n \nint snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint platform_max;\n\tint min = mc->min;\n\n\tif (!mc->platform_max)\n\t\tmc->platform_max = mc->max;\n\tplatform_max = mc->platform_max;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = platform_max - min;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);\n\n \nint snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = mc->reg;\n\tunsigned int rreg = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tint min = mc->min;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned int val, val_mask;\n\tint err, ret, tmp;\n\n\ttmp = ucontrol->value.integer.value[0];\n\tif (tmp < 0)\n\t\treturn -EINVAL;\n\tif (mc->platform_max && tmp > mc->platform_max)\n\t\treturn -EINVAL;\n\tif (tmp > mc->max - mc->min)\n\t\treturn -EINVAL;\n\n\tif (invert)\n\t\tval = (max - ucontrol->value.integer.value[0]) & mask;\n\telse\n\t\tval = ((ucontrol->value.integer.value[0] + min) & mask);\n\tval_mask = mask << shift;\n\tval = val << shift;\n\n\terr = snd_soc_component_update_bits(component, reg, val_mask, val);\n\tif (err < 0)\n\t\treturn err;\n\tret = err;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\ttmp = ucontrol->value.integer.value[1];\n\t\tif (tmp < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mc->platform_max && tmp > mc->platform_max)\n\t\t\treturn -EINVAL;\n\t\tif (tmp > mc->max - mc->min)\n\t\t\treturn -EINVAL;\n\n\t\tif (invert)\n\t\t\tval = (max - ucontrol->value.integer.value[1]) & mask;\n\t\telse\n\t\t\tval = ((ucontrol->value.integer.value[1] + min) & mask);\n\t\tval_mask = mask << shift;\n\t\tval = val << shift;\n\n\t\terr = snd_soc_component_update_bits(component, rreg, val_mask,\n\t\t\tval);\n\t\t \n\t\tif (ret == 0 || err < 0) {\n\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);\n\n \nint snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int rreg = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tint min = mc->min;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, reg);\n\tucontrol->value.integer.value[0] = (val >> shift) & mask;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmax - ucontrol->value.integer.value[0];\n\telse\n\t\tucontrol->value.integer.value[0] =\n\t\t\tucontrol->value.integer.value[0] - min;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tval = snd_soc_component_read(component, rreg);\n\t\tucontrol->value.integer.value[1] = (val >> shift) & mask;\n\t\tif (invert)\n\t\t\tucontrol->value.integer.value[1] =\n\t\t\t\tmax - ucontrol->value.integer.value[1];\n\t\telse\n\t\t\tucontrol->value.integer.value[1] =\n\t\t\t\tucontrol->value.integer.value[1] - min;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);\n\n \nint snd_soc_limit_volume(struct snd_soc_card *card,\n\tconst char *name, int max)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret = -EINVAL;\n\n\t \n\tif (unlikely(!name || max <= 0))\n\t\treturn -EINVAL;\n\n\tkctl = snd_soc_card_get_kcontrol(card, name);\n\tif (kctl) {\n\t\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kctl->private_value;\n\t\tif (max <= mc->max - mc->min) {\n\t\t\tmc->platform_max = max;\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_limit_volume);\n\nint snd_soc_bytes_info(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes *params = (void *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = params->num_regs * component->val_bytes;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_bytes_info);\n\nint snd_soc_bytes_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes *params = (void *)kcontrol->private_value;\n\tint ret;\n\n\tif (component->regmap)\n\t\tret = regmap_raw_read(component->regmap, params->base,\n\t\t\t\t      ucontrol->value.bytes.data,\n\t\t\t\t      params->num_regs * component->val_bytes);\n\telse\n\t\tret = -EINVAL;\n\n\t \n\tif (ret == 0 && params->mask) {\n\t\tswitch (component->val_bytes) {\n\t\tcase 1:\n\t\t\tucontrol->value.bytes.data[0] &= ~params->mask;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t((u16 *)(&ucontrol->value.bytes.data))[0]\n\t\t\t\t&= cpu_to_be16(~params->mask);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t((u32 *)(&ucontrol->value.bytes.data))[0]\n\t\t\t\t&= cpu_to_be32(~params->mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_bytes_get);\n\nint snd_soc_bytes_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes *params = (void *)kcontrol->private_value;\n\tint ret, len;\n\tunsigned int val, mask;\n\tvoid *data;\n\n\tif (!component->regmap || !params->num_regs)\n\t\treturn -EINVAL;\n\n\tlen = params->num_regs * component->val_bytes;\n\n\tdata = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tif (params->mask) {\n\t\tret = regmap_read(component->regmap, params->base, &val);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\n\t\tval &= params->mask;\n\n\t\tswitch (component->val_bytes) {\n\t\tcase 1:\n\t\t\t((u8 *)data)[0] &= ~params->mask;\n\t\t\t((u8 *)data)[0] |= val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmask = ~params->mask;\n\t\t\tret = regmap_parse_val(component->regmap,\n\t\t\t\t\t\t\t&mask, &mask);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\t((u16 *)data)[0] &= mask;\n\n\t\t\tret = regmap_parse_val(component->regmap,\n\t\t\t\t\t\t\t&val, &val);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\t((u16 *)data)[0] |= val;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmask = ~params->mask;\n\t\t\tret = regmap_parse_val(component->regmap,\n\t\t\t\t\t\t\t&mask, &mask);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\t((u32 *)data)[0] &= mask;\n\n\t\t\tret = regmap_parse_val(component->regmap,\n\t\t\t\t\t\t\t&val, &val);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\n\t\t\t((u32 *)data)[0] |= val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = regmap_raw_write(component->regmap, params->base,\n\t\t\t       data, len);\n\nout:\n\tkfree(data);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_bytes_put);\n\nint snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *ucontrol)\n{\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\n\tucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tucontrol->count = params->max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);\n\nint snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t\tunsigned int size, unsigned int __user *tlv)\n{\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tunsigned int count = size < params->max ? size : params->max;\n\tint ret = -ENXIO;\n\n\tswitch (op_flag) {\n\tcase SNDRV_CTL_TLV_OP_READ:\n\t\tif (params->get)\n\t\t\tret = params->get(kcontrol, tlv, count);\n\t\tbreak;\n\tcase SNDRV_CTL_TLV_OP_WRITE:\n\t\tif (params->put)\n\t\t\tret = params->put(kcontrol, tlv, count);\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);\n\n \nint snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = mc->min;\n\tuinfo->value.integer.max = mc->max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);\n\n \nint snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tunsigned int regbase = mc->regbase;\n\tunsigned int regcount = mc->regcount;\n\tunsigned int regwshift = component->val_bytes * BITS_PER_BYTE;\n\tunsigned int regwmask = (1UL<<regwshift)-1;\n\tunsigned int invert = mc->invert;\n\tunsigned long mask = (1UL<<mc->nbits)-1;\n\tlong min = mc->min;\n\tlong max = mc->max;\n\tlong val = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < regcount; i++) {\n\t\tunsigned int regval = snd_soc_component_read(component, regbase+i);\n\t\tval |= (regval & regwmask) << (regwshift*(regcount-i-1));\n\t}\n\tval &= mask;\n\tif (min < 0 && val > max)\n\t\tval |= ~mask;\n\tif (invert)\n\t\tval = max - val;\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);\n\n \nint snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tunsigned int regbase = mc->regbase;\n\tunsigned int regcount = mc->regcount;\n\tunsigned int regwshift = component->val_bytes * BITS_PER_BYTE;\n\tunsigned int regwmask = (1UL<<regwshift)-1;\n\tunsigned int invert = mc->invert;\n\tunsigned long mask = (1UL<<mc->nbits)-1;\n\tlong max = mc->max;\n\tlong val = ucontrol->value.integer.value[0];\n\tint ret = 0;\n\tunsigned int i;\n\n\tif (val < mc->min || val > mc->max)\n\t\treturn -EINVAL;\n\tif (invert)\n\t\tval = max - val;\n\tval &= mask;\n\tfor (i = 0; i < regcount; i++) {\n\t\tunsigned int regval = (val >> (regwshift*(regcount-i-1))) & regwmask;\n\t\tunsigned int regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;\n\t\tint err = snd_soc_component_update_bits(component, regbase+i,\n\t\t\t\t\t\t\tregmask, regval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err > 0)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);\n\n \nint snd_soc_get_strobe(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tunsigned int mask = 1 << shift;\n\tunsigned int invert = mc->invert != 0;\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, reg);\n\tval &= mask;\n\n\tif (shift != 0 && val != 0)\n\t\tval = val >> shift;\n\tucontrol->value.enumerated.item[0] = val ^ invert;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_strobe);\n\n \nint snd_soc_put_strobe(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tunsigned int mask = 1 << shift;\n\tunsigned int invert = mc->invert != 0;\n\tunsigned int strobe = ucontrol->value.enumerated.item[0] != 0;\n\tunsigned int val1 = (strobe ^ invert) ? mask : 0;\n\tunsigned int val2 = (strobe ^ invert) ? 0 : mask;\n\tint err;\n\n\terr = snd_soc_component_update_bits(component, reg, mask, val1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn snd_soc_component_update_bits(component, reg, mask, val2);\n}\nEXPORT_SYMBOL_GPL(snd_soc_put_strobe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}