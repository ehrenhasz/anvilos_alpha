{
  "module_name": "cygnus-ssp.c",
  "hash_id": "48cdaee36a2e8790cb344b6c726a1078c60536c475d50eeea51ebf510b90a08e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/bcm/cygnus-ssp.c",
  "human_readable_source": "\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"cygnus-ssp.h\"\n\n#define DEFAULT_VCO    1354750204\n\n#define CAPTURE_FCI_ID_BASE 0x180\n#define CYGNUS_SSP_TRISTATE_MASK 0x001fff\n#define CYGNUS_PLLCLKSEL_MASK 0xf\n\n \n#define  PLAYBACK_STREAM_MASK   BIT(0)\n#define  CAPTURE_STREAM_MASK    BIT(1)\n\n#define I2S_STREAM_CFG_MASK      0xff003ff\n#define I2S_CAP_STREAM_CFG_MASK  0xf0\n#define SPDIF_STREAM_CFG_MASK    0x3ff\n#define CH_GRP_STEREO            0x1\n\n \n#define AUD_MISC_SEROUT_OE_REG_BASE  0x01c\n#define AUD_MISC_SEROUT_SPDIF_OE  12\n#define AUD_MISC_SEROUT_MCLK_OE   3\n#define AUD_MISC_SEROUT_LRCK_OE   2\n#define AUD_MISC_SEROUT_SCLK_OE   1\n#define AUD_MISC_SEROUT_SDAT_OE   0\n\n \n#define BF_DST_CFG0_OFFSET  0x100\n#define BF_DST_CFG1_OFFSET  0x104\n#define BF_DST_CFG2_OFFSET  0x108\n\n#define BF_DST_CTRL0_OFFSET 0x130\n#define BF_DST_CTRL1_OFFSET 0x134\n#define BF_DST_CTRL2_OFFSET 0x138\n\n#define BF_SRC_CFG0_OFFSET  0x148\n#define BF_SRC_CFG1_OFFSET  0x14c\n#define BF_SRC_CFG2_OFFSET  0x150\n#define BF_SRC_CFG3_OFFSET  0x154\n\n#define BF_SRC_CTRL0_OFFSET 0x1c0\n#define BF_SRC_CTRL1_OFFSET 0x1c4\n#define BF_SRC_CTRL2_OFFSET 0x1c8\n#define BF_SRC_CTRL3_OFFSET 0x1cc\n\n#define BF_SRC_GRP0_OFFSET  0x1fc\n#define BF_SRC_GRP1_OFFSET  0x200\n#define BF_SRC_GRP2_OFFSET  0x204\n#define BF_SRC_GRP3_OFFSET  0x208\n\n#define BF_SRC_GRP_EN_OFFSET        0x320\n#define BF_SRC_GRP_FLOWON_OFFSET    0x324\n#define BF_SRC_GRP_SYNC_DIS_OFFSET  0x328\n\n \n#define OUT_I2S_0_STREAM_CFG_OFFSET 0xa00\n#define OUT_I2S_0_CFG_OFFSET        0xa04\n#define OUT_I2S_0_MCLK_CFG_OFFSET   0xa0c\n\n#define OUT_I2S_1_STREAM_CFG_OFFSET 0xa40\n#define OUT_I2S_1_CFG_OFFSET        0xa44\n#define OUT_I2S_1_MCLK_CFG_OFFSET   0xa4c\n\n#define OUT_I2S_2_STREAM_CFG_OFFSET 0xa80\n#define OUT_I2S_2_CFG_OFFSET        0xa84\n#define OUT_I2S_2_MCLK_CFG_OFFSET   0xa8c\n\n \n#define SPDIF_STREAM_CFG_OFFSET  0xac0\n#define SPDIF_CTRL_OFFSET        0xac4\n#define SPDIF_FORMAT_CFG_OFFSET  0xad8\n#define SPDIF_MCLK_CFG_OFFSET    0xadc\n\n \n#define IOP_PLL_0_MACRO_OFFSET    0xb00\n#define IOP_PLL_0_MDIV_Ch0_OFFSET 0xb14\n#define IOP_PLL_0_MDIV_Ch1_OFFSET 0xb18\n#define IOP_PLL_0_MDIV_Ch2_OFFSET 0xb1c\n\n#define IOP_PLL_0_ACTIVE_MDIV_Ch0_OFFSET 0xb30\n#define IOP_PLL_0_ACTIVE_MDIV_Ch1_OFFSET 0xb34\n#define IOP_PLL_0_ACTIVE_MDIV_Ch2_OFFSET 0xb38\n\n \n#define IOP_PLL_0_CONTROL_OFFSET     0xb04\n#define IOP_PLL_0_USER_NDIV_OFFSET   0xb08\n#define IOP_PLL_0_ACTIVE_NDIV_OFFSET 0xb20\n#define IOP_PLL_0_RESET_OFFSET       0xb5c\n\n \n#define IN_I2S_0_STREAM_CFG_OFFSET 0x00\n#define IN_I2S_0_CFG_OFFSET        0x04\n#define IN_I2S_1_STREAM_CFG_OFFSET 0x40\n#define IN_I2S_1_CFG_OFFSET        0x44\n#define IN_I2S_2_STREAM_CFG_OFFSET 0x80\n#define IN_I2S_2_CFG_OFFSET        0x84\n\n \n#define IOP_SW_INIT_LOGIC          0x1c0\n\n \n\n\n \n#define I2S_OUT_MCLKRATE_SHIFT 16\n\n \n#define I2S_OUT_PLLCLKSEL_SHIFT  0\n\n \n#define I2S_OUT_STREAM_ENA  31\n#define I2S_OUT_STREAM_CFG_GROUP_ID  20\n#define I2S_OUT_STREAM_CFG_CHANNEL_GROUPING  24\n\n \n#define I2S_IN_STREAM_CFG_CAP_ENA   31\n#define I2S_IN_STREAM_CFG_0_GROUP_ID 4\n\n \n#define I2S_OUT_CFGX_CLK_ENA         0\n#define I2S_OUT_CFGX_DATA_ENABLE     1\n#define I2S_OUT_CFGX_DATA_ALIGNMENT  6\n#define I2S_OUT_CFGX_BITS_PER_SLOT  13\n#define I2S_OUT_CFGX_VALID_SLOT     14\n#define I2S_OUT_CFGX_FSYNC_WIDTH    18\n#define I2S_OUT_CFGX_SCLKS_PER_1FS_DIV32 26\n#define I2S_OUT_CFGX_SLAVE_MODE     30\n#define I2S_OUT_CFGX_TDM_MODE       31\n\n \n#define BF_SRC_CFGX_SFIFO_ENA              0\n#define BF_SRC_CFGX_BUFFER_PAIR_ENABLE     1\n#define BF_SRC_CFGX_SAMPLE_CH_MODE         2\n#define BF_SRC_CFGX_SFIFO_SZ_DOUBLE        5\n#define BF_SRC_CFGX_NOT_PAUSE_WHEN_EMPTY  10\n#define BF_SRC_CFGX_BIT_RES               20\n#define BF_SRC_CFGX_PROCESS_SEQ_ID_VALID  31\n\n \n#define BF_DST_CFGX_CAP_ENA              0\n#define BF_DST_CFGX_BUFFER_PAIR_ENABLE   1\n#define BF_DST_CFGX_DFIFO_SZ_DOUBLE      2\n#define BF_DST_CFGX_NOT_PAUSE_WHEN_FULL 11\n#define BF_DST_CFGX_FCI_ID              12\n#define BF_DST_CFGX_CAP_MODE            24\n#define BF_DST_CFGX_PROC_SEQ_ID_VALID   31\n\n \n#define SPDIF_0_OUT_DITHER_ENA     3\n#define SPDIF_0_OUT_STREAM_ENA    31\n\n \n#define IOP_PLL_0_USER_NDIV_FRAC   10\n\n \n#define IOP_PLL_0_ACTIVE_NDIV_FRAC 10\n\n\n#define INIT_SSP_REGS(num) (struct cygnus_ssp_regs){ \\\n\t\t.i2s_stream_cfg = OUT_I2S_ ##num## _STREAM_CFG_OFFSET, \\\n\t\t.i2s_cap_stream_cfg = IN_I2S_ ##num## _STREAM_CFG_OFFSET, \\\n\t\t.i2s_cfg = OUT_I2S_ ##num## _CFG_OFFSET, \\\n\t\t.i2s_cap_cfg = IN_I2S_ ##num## _CFG_OFFSET, \\\n\t\t.i2s_mclk_cfg = OUT_I2S_ ##num## _MCLK_CFG_OFFSET, \\\n\t\t.bf_destch_ctrl = BF_DST_CTRL ##num## _OFFSET, \\\n\t\t.bf_destch_cfg = BF_DST_CFG ##num## _OFFSET, \\\n\t\t.bf_sourcech_ctrl = BF_SRC_CTRL ##num## _OFFSET, \\\n\t\t.bf_sourcech_cfg = BF_SRC_CFG ##num## _OFFSET, \\\n\t\t.bf_sourcech_grp = BF_SRC_GRP ##num## _OFFSET \\\n}\n\nstruct pll_macro_entry {\n\tu32 mclk;\n\tu32 pll_ch_num;\n};\n\n \nstatic const struct pll_macro_entry pll_predef_mclk[] = {\n\t{ 4096000, 0},\n\t{ 8192000, 1},\n\t{16384000, 2},\n\n\t{ 5644800, 0},\n\t{11289600, 1},\n\t{22579200, 2},\n\n\t{ 6144000, 0},\n\t{12288000, 1},\n\t{24576000, 2},\n\n\t{12288000, 0},\n\t{24576000, 1},\n\t{49152000, 2},\n\n\t{22579200, 0},\n\t{45158400, 1},\n\t{90316800, 2},\n\n\t{24576000, 0},\n\t{49152000, 1},\n\t{98304000, 2},\n};\n\n#define CYGNUS_RATE_MIN     8000\n#define CYGNUS_RATE_MAX   384000\n\n \nstatic const int ssp_valid_tdm_framesize[] = {32, 64, 128, 256, 512};\n\nstatic const unsigned int cygnus_rates[] = {\n\t 8000, 11025,  16000,  22050,  32000,  44100, 48000,\n\t88200, 96000, 176400, 192000, 352800, 384000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cygnus_rate_constraint = {\n\t.count = ARRAY_SIZE(cygnus_rates),\n\t.list = cygnus_rates,\n};\n\nstatic struct cygnus_aio_port *cygnus_dai_get_portinfo(struct snd_soc_dai *dai)\n{\n\tstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\n\n\treturn &cygaud->portinfo[dai->id];\n}\n\nstatic int audio_ssp_init_portregs(struct cygnus_aio_port *aio)\n{\n\tu32 value, fci_id;\n\tint status = 0;\n\n\tswitch (aio->port_type) {\n\tcase PORT_TDM:\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\t\tvalue &= ~I2S_STREAM_CFG_MASK;\n\n\t\t \n\t\twritel(aio->portnum,\n\t\t\taio->cygaud->audio + aio->regs.bf_sourcech_grp);\n\n\t\t \n\t\tvalue |= aio->portnum << I2S_OUT_STREAM_CFG_GROUP_ID;\n\t\tvalue |= aio->portnum;  \n\t\tvalue |= CH_GRP_STEREO << I2S_OUT_STREAM_CFG_CHANNEL_GROUPING;\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_NOT_PAUSE_WHEN_EMPTY);\n\t\tvalue |= BIT(BF_SRC_CFGX_SFIFO_SZ_DOUBLE);\n\t\tvalue |= BIT(BF_SRC_CFGX_PROCESS_SEQ_ID_VALID);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->i2s_in +\n\t\t\taio->regs.i2s_cap_stream_cfg);\n\t\tvalue &= ~I2S_CAP_STREAM_CFG_MASK;\n\t\tvalue |= aio->portnum << I2S_IN_STREAM_CFG_0_GROUP_ID;\n\t\twritel(value, aio->cygaud->i2s_in +\n\t\t\taio->regs.i2s_cap_stream_cfg);\n\n\t\t \n\t\tfci_id = CAPTURE_FCI_ID_BASE + aio->portnum;\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\n\t\tvalue |= BIT(BF_DST_CFGX_DFIFO_SZ_DOUBLE);\n\t\tvalue &= ~BIT(BF_DST_CFGX_NOT_PAUSE_WHEN_FULL);\n\t\tvalue |= (fci_id << BF_DST_CFGX_FCI_ID);\n\t\tvalue |= BIT(BF_DST_CFGX_PROC_SEQ_ID_VALID);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\t\tvalue &= ~BIT((aio->portnum * 4) + AUD_MISC_SEROUT_SDAT_OE);\n\t\twritel(value, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\t\tbreak;\n\tcase PORT_SPDIF:\n\t\twritel(aio->portnum, aio->cygaud->audio + BF_SRC_GRP3_OFFSET);\n\n\t\tvalue = readl(aio->cygaud->audio + SPDIF_CTRL_OFFSET);\n\t\tvalue |= BIT(SPDIF_0_OUT_DITHER_ENA);\n\t\twritel(value, aio->cygaud->audio + SPDIF_CTRL_OFFSET);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + SPDIF_STREAM_CFG_OFFSET);\n\t\tvalue &= ~SPDIF_STREAM_CFG_MASK;\n\t\tvalue |= aio->portnum;  \n\t\tvalue |= BIT(SPDIF_0_OUT_STREAM_ENA);\n\t\twritel(value, aio->cygaud->audio + SPDIF_STREAM_CFG_OFFSET);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_NOT_PAUSE_WHEN_EMPTY);\n\t\tvalue |= BIT(BF_SRC_CFGX_SFIFO_SZ_DOUBLE);\n\t\tvalue |= BIT(BF_SRC_CFGX_PROCESS_SEQ_ID_VALID);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\t\tvalue &= ~BIT(AUD_MISC_SEROUT_SPDIF_OE);\n\t\twritel(value, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aio->cygaud->dev, \"Port not supported\\n\");\n\t\tstatus = -EINVAL;\n\t}\n\n\treturn status;\n}\n\nstatic void audio_ssp_in_enable(struct cygnus_aio_port *aio)\n{\n\tu32 value;\n\n\tvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\n\tvalue |= BIT(BF_DST_CFGX_CAP_ENA);\n\twritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\n\n\twritel(0x1, aio->cygaud->audio + aio->regs.bf_destch_ctrl);\n\n\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\tvalue |= BIT(I2S_OUT_CFGX_CLK_ENA);\n\tvalue |= BIT(I2S_OUT_CFGX_DATA_ENABLE);\n\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\n\tvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\n\tvalue |= BIT(I2S_IN_STREAM_CFG_CAP_ENA);\n\twritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\n\n\taio->streams_on |= CAPTURE_STREAM_MASK;\n}\n\nstatic void audio_ssp_in_disable(struct cygnus_aio_port *aio)\n{\n\tu32 value;\n\n\tvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\n\tvalue &= ~BIT(I2S_IN_STREAM_CFG_CAP_ENA);\n\twritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\n\n\taio->streams_on &= ~CAPTURE_STREAM_MASK;\n\n\t \n\tif (!aio->streams_on) {\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\tvalue &= ~BIT(I2S_OUT_CFGX_CLK_ENA);\n\t\tvalue &= ~BIT(I2S_OUT_CFGX_DATA_ENABLE);\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\t}\n\n\twritel(0x0, aio->cygaud->audio + aio->regs.bf_destch_ctrl);\n\n\tvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\n\tvalue &= ~BIT(BF_DST_CFGX_CAP_ENA);\n\twritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\n}\n\nstatic int audio_ssp_out_enable(struct cygnus_aio_port *aio)\n{\n\tu32 value;\n\tint status = 0;\n\n\tswitch (aio->port_type) {\n\tcase PORT_TDM:\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\t\tvalue |= BIT(I2S_OUT_STREAM_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\n\t\twritel(1, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\tvalue |= BIT(I2S_OUT_CFGX_CLK_ENA);\n\t\tvalue |= BIT(I2S_OUT_CFGX_DATA_ENABLE);\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue |= BIT(BF_SRC_CFGX_SFIFO_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t\taio->streams_on |= PLAYBACK_STREAM_MASK;\n\t\tbreak;\n\tcase PORT_SPDIF:\n\t\tvalue = readl(aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\n\t\tvalue |= 0x3;\n\t\twritel(value, aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\n\n\t\twritel(1, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue |= BIT(BF_SRC_CFGX_SFIFO_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"Port not supported %d\\n\", aio->portnum);\n\t\tstatus = -EINVAL;\n\t}\n\n\treturn status;\n}\n\nstatic int audio_ssp_out_disable(struct cygnus_aio_port *aio)\n{\n\tu32 value;\n\tint status = 0;\n\n\tswitch (aio->port_type) {\n\tcase PORT_TDM:\n\t\taio->streams_on &= ~PLAYBACK_STREAM_MASK;\n\n\t\t \n\t\tif (!aio->streams_on) {\n\t\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\t\tvalue &= ~BIT(I2S_OUT_CFGX_CLK_ENA);\n\t\t\tvalue &= ~BIT(I2S_OUT_CFGX_DATA_ENABLE);\n\t\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\t}\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\n\t\tvalue |= BIT(aio->portnum);\n\t\twritel(value, aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\n\n\t\twritel(0, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_SFIFO_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\n\t\tvalue &= ~BIT(aio->portnum);\n\t\twritel(value, aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\t\tvalue &= ~BIT(I2S_OUT_STREAM_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\n\n\t\t \n\t\tvalue = readl(aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\n\t\tvalue |= BIT(aio->portnum);\n\t\twritel(value, aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\n\t\tvalue &= ~BIT(aio->portnum);\n\t\twritel(value, aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\n\t\tbreak;\n\tcase PORT_SPDIF:\n\t\tvalue = readl(aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\n\t\tvalue &= ~0x3;\n\t\twritel(value, aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\n\t\twritel(0, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_SFIFO_ENA);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"Port not supported %d\\n\", aio->portnum);\n\t\tstatus = -EINVAL;\n\t}\n\n\treturn status;\n}\n\nstatic int pll_configure_mclk(struct cygnus_audio *cygaud, u32 mclk,\n\tstruct cygnus_aio_port *aio)\n{\n\tint i = 0, error;\n\tbool found = false;\n\tconst struct pll_macro_entry *p_entry;\n\tstruct clk *ch_clk;\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_predef_mclk); i++) {\n\t\tp_entry = &pll_predef_mclk[i];\n\t\tif (p_entry->mclk == mclk) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tdev_err(cygaud->dev,\n\t\t\t\"%s No valid mclk freq (%u) found!\\n\", __func__, mclk);\n\t\treturn -EINVAL;\n\t}\n\n\tch_clk = cygaud->audio_clk[p_entry->pll_ch_num];\n\n\tif ((aio->clk_trace.cap_en) && (!aio->clk_trace.cap_clk_en)) {\n\t\terror = clk_prepare_enable(ch_clk);\n\t\tif (error) {\n\t\t\tdev_err(cygaud->dev, \"%s clk_prepare_enable failed %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\taio->clk_trace.cap_clk_en = true;\n\t}\n\n\tif ((aio->clk_trace.play_en) && (!aio->clk_trace.play_clk_en)) {\n\t\terror = clk_prepare_enable(ch_clk);\n\t\tif (error) {\n\t\t\tdev_err(cygaud->dev, \"%s clk_prepare_enable failed %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t\taio->clk_trace.play_clk_en = true;\n\t}\n\n\terror = clk_set_rate(ch_clk, mclk);\n\tif (error) {\n\t\tdev_err(cygaud->dev, \"%s Set MCLK rate failed: %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\treturn p_entry->pll_ch_num;\n}\n\nstatic int cygnus_ssp_set_clocks(struct cygnus_aio_port *aio)\n{\n\tu32 value;\n\tu32 mask = 0xf;\n\tu32 sclk;\n\tu32 mclk_rate;\n\tunsigned int bit_rate;\n\tunsigned int ratio;\n\n\tbit_rate = aio->bit_per_frame * aio->lrclk;\n\n\t \n\tif ((aio->mclk % bit_rate) != 0)\n\t\treturn -EINVAL;\n\n\tratio = aio->mclk / bit_rate;\n\tswitch (ratio) {\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\t\tmclk_rate = ratio / 2;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"Invalid combination of MCLK and BCLK\\n\");\n\t\tdev_err(aio->cygaud->dev, \"lrclk = %u, bits/frame = %u, mclk = %u\\n\",\n\t\t\taio->lrclk, aio->bit_per_frame, aio->mclk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (aio->port_type) {\n\tcase PORT_TDM:\n\t\tsclk = aio->bit_per_frame;\n\t\tif (sclk == 512)\n\t\t\tsclk = 0;\n\n\t\t \n\t\tsclk /= 32;\n\n\t\t \n\t\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\tvalue &= ~(mask << I2S_OUT_CFGX_SCLKS_PER_1FS_DIV32);\n\t\tvalue |= sclk << I2S_OUT_CFGX_SCLKS_PER_1FS_DIV32;\n\t\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\t\tdev_dbg(aio->cygaud->dev,\n\t\t\t\"SCLKS_PER_1FS_DIV32 = 0x%x\\n\", value);\n\t\tbreak;\n\tcase PORT_SPDIF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aio->cygaud->dev, \"Unknown port type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\tvalue &= ~(0xf << I2S_OUT_MCLKRATE_SHIFT);\n\tvalue |= (mclk_rate << I2S_OUT_MCLKRATE_SHIFT);\n\twritel(value, aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\n\tdev_dbg(aio->cygaud->dev, \"mclk cfg reg = 0x%x\\n\", value);\n\tdev_dbg(aio->cygaud->dev, \"bits per frame = %u, mclk = %u Hz, lrclk = %u Hz\\n\",\n\t\t\taio->bit_per_frame, aio->mclk, aio->lrclk);\n\treturn 0;\n}\n\nstatic int cygnus_ssp_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\n\tint rate, bitres;\n\tu32 value;\n\tu32 mask = 0x1f;\n\tint ret = 0;\n\n\tdev_dbg(aio->cygaud->dev, \"%s port = %d\\n\", __func__, aio->portnum);\n\tdev_dbg(aio->cygaud->dev, \"params_channels %d\\n\",\n\t\t\tparams_channels(params));\n\tdev_dbg(aio->cygaud->dev, \"rate %d\\n\", params_rate(params));\n\tdev_dbg(aio->cygaud->dev, \"format %d\\n\", params_format(params));\n\n\trate = params_rate(params);\n\n\tswitch (aio->mode) {\n\tcase CYGNUS_SSPMODE_TDM:\n\t\tif ((rate == 192000) && (params_channels(params) > 4)) {\n\t\t\tdev_err(aio->cygaud->dev, \"Cannot run %d channels at %dHz\\n\",\n\t\t\t\tparams_channels(params), rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CYGNUS_SSPMODE_I2S:\n\t\taio->bit_per_frame = 64;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"%s port running in unknown mode\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_BUFFER_PAIR_ENABLE);\n\t\tvalue &= ~BIT(BF_SRC_CFGX_SAMPLE_CH_MODE);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t\tswitch (params_format(params)) {\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tbitres = 16;\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t\t \n\t\t\tbitres = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\t\tvalue &= ~(mask << BF_SRC_CFGX_BIT_RES);\n\t\tvalue |= (bitres << BF_SRC_CFGX_BIT_RES);\n\t\twritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\n\n\t} else {\n\n\t\tswitch (params_format(params)) {\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tvalue = readl(aio->cygaud->audio +\n\t\t\t\t\taio->regs.bf_destch_cfg);\n\t\t\tvalue |= BIT(BF_DST_CFGX_CAP_MODE);\n\t\t\twritel(value, aio->cygaud->audio +\n\t\t\t\t\taio->regs.bf_destch_cfg);\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t\tvalue = readl(aio->cygaud->audio +\n\t\t\t\t\taio->regs.bf_destch_cfg);\n\t\t\tvalue &= ~BIT(BF_DST_CFGX_CAP_MODE);\n\t\t\twritel(value, aio->cygaud->audio +\n\t\t\t\t\taio->regs.bf_destch_cfg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\taio->lrclk = rate;\n\n\tif (!aio->is_slave)\n\t\tret = cygnus_ssp_set_clocks(aio);\n\n\treturn ret;\n}\n\n \nstatic int cygnus_ssp_set_sysclk(struct snd_soc_dai *dai,\n\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tint sel;\n\tu32 value;\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\n\tstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(aio->cygaud->dev,\n\t\t\"%s Enter port = %d\\n\", __func__, aio->portnum);\n\tsel = pll_configure_mclk(cygaud, freq, aio);\n\tif (sel < 0) {\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"%s Setting mclk failed.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\taio->mclk = freq;\n\n\tdev_dbg(aio->cygaud->dev, \"%s Setting MCLKSEL to %d\\n\", __func__, sel);\n\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\tvalue &= ~(0xf << I2S_OUT_PLLCLKSEL_SHIFT);\n\tvalue |= (sel << I2S_OUT_PLLCLKSEL_SHIFT);\n\twritel(value, aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\n\treturn 0;\n}\n\nstatic int cygnus_ssp_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\n\n\tsnd_soc_dai_set_dma_data(dai, substream, aio);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\taio->clk_trace.play_en = true;\n\telse\n\t\taio->clk_trace.cap_en = true;\n\n\tsubstream->runtime->hw.rate_min = CYGNUS_RATE_MIN;\n\tsubstream->runtime->hw.rate_max = CYGNUS_RATE_MAX;\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &cygnus_rate_constraint);\n\treturn 0;\n}\n\nstatic void cygnus_ssp_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\taio->clk_trace.play_en = false;\n\telse\n\t\taio->clk_trace.cap_en = false;\n\n\tif (!aio->is_slave) {\n\t\tu32 val;\n\n\t\tval = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\t\tval &= CYGNUS_PLLCLKSEL_MASK;\n\t\tif (val >= ARRAY_SIZE(aio->cygaud->audio_clk)) {\n\t\t\tdev_err(aio->cygaud->dev, \"Clk index %u is out of bounds\\n\",\n\t\t\t\tval);\n\t\t\treturn;\n\t\t}\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tif (aio->clk_trace.play_clk_en) {\n\t\t\t\tclk_disable_unprepare(aio->cygaud->\n\t\t\t\t\t\taudio_clk[val]);\n\t\t\t\taio->clk_trace.play_clk_en = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (aio->clk_trace.cap_clk_en) {\n\t\t\t\tclk_disable_unprepare(aio->cygaud->\n\t\t\t\t\t\taudio_clk[val]);\n\t\t\t\taio->clk_trace.cap_clk_en = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n#define I2S_OUT_CFG_REG_UPDATE_MASK   0x3C03FF03\n\n \n#define I2S_IN_CFG_REG_UPDATE_MASK  (I2S_OUT_CFG_REG_UPDATE_MASK | 0x03FC0000)\n\nint cygnus_ssp_set_custom_fsync_width(struct snd_soc_dai *cpu_dai, int len)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\n\n\tif ((len > 0) && (len < 256)) {\n\t\taio->fsync_width = len;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(cygnus_ssp_set_custom_fsync_width);\n\nstatic int cygnus_ssp_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\n\tu32 ssp_curcfg;\n\tu32 ssp_newcfg;\n\tu32 ssp_outcfg;\n\tu32 ssp_incfg;\n\tu32 val;\n\tu32 mask;\n\n\tdev_dbg(aio->cygaud->dev, \"%s Enter  fmt: %x\\n\", __func__, fmt);\n\n\tif (aio->port_type == PORT_SPDIF)\n\t\treturn -EINVAL;\n\n\tssp_newcfg = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_SLAVE_MODE);\n\t\taio->is_slave = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tssp_newcfg &= ~BIT(I2S_OUT_CFGX_SLAVE_MODE);\n\t\taio->is_slave = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_DATA_ALIGNMENT);\n\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_FSYNC_WIDTH);\n\t\taio->mode = CYGNUS_SSPMODE_I2S;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_TDM_MODE);\n\n\t\t \n\t\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A)\n\t\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_DATA_ALIGNMENT);\n\n\t\tif ((aio->fsync_width > 0) && (aio->fsync_width < 256))\n\t\t\tssp_newcfg |=\n\t\t\t\t(aio->fsync_width << I2S_OUT_CFGX_FSYNC_WIDTH);\n\t\telse\n\t\t\tssp_newcfg |= BIT(I2S_OUT_CFGX_FSYNC_WIDTH);\n\n\t\taio->mode = CYGNUS_SSPMODE_TDM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tssp_curcfg = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\tssp_outcfg = (ssp_curcfg & I2S_OUT_CFG_REG_UPDATE_MASK) | ssp_newcfg;\n\twritel(ssp_outcfg, aio->cygaud->audio + aio->regs.i2s_cfg);\n\n\t \n\tssp_curcfg = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\n\tssp_incfg = (ssp_curcfg & I2S_IN_CFG_REG_UPDATE_MASK) | ssp_newcfg;\n\twritel(ssp_incfg, aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\n\n\tval = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\n\t \n\tmask = BIT(AUD_MISC_SEROUT_LRCK_OE)\n\t\t\t| BIT(AUD_MISC_SEROUT_SCLK_OE)\n\t\t\t| BIT(AUD_MISC_SEROUT_MCLK_OE);\n\tmask = mask << (aio->portnum * 4);\n\tif (aio->is_slave)\n\t\t \n\t\tval |= mask;\n\telse\n\t\t \n\t\tval &= ~mask;\n\n\tdev_dbg(aio->cygaud->dev, \"%s  Set OE bits 0x%x\\n\", __func__, val);\n\twritel(val, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\n\treturn 0;\n}\n\nstatic int cygnus_ssp_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\n\tstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(aio->cygaud->dev,\n\t\t\"%s cmd %d at port = %d\\n\", __func__, cmd, aio->portnum);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\taudio_ssp_out_enable(aio);\n\t\telse\n\t\t\taudio_ssp_in_enable(aio);\n\t\tcygaud->active_ports++;\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\taudio_ssp_out_disable(aio);\n\t\telse\n\t\t\taudio_ssp_in_disable(aio);\n\t\tcygaud->active_ports--;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cygnus_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\n\tu32 value;\n\tint bits_per_slot = 0;      \n\tint frame_bits;\n\tunsigned int active_slots;\n\tbool found = false;\n\tint i;\n\n\tif (tx_mask != rx_mask) {\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"%s tx_mask must equal rx_mask\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tactive_slots = hweight32(tx_mask);\n\n\tif (active_slots > 16)\n\t\treturn -EINVAL;\n\n\t \n\tif (active_slots % 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (active_slots == 16)\n\t\tactive_slots = 0;\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tbits_per_slot = 1;\n\t\tbreak;\n\tcase 32:\n\t\tbits_per_slot = 0;\n\t\tbreak;\n\tdefault:\n\t\tbits_per_slot = 0;\n\t\tdev_warn(aio->cygaud->dev,\n\t\t\t\"%s Defaulting Slot Width to 32\\n\", __func__);\n\t}\n\n\tframe_bits = slots * slot_width;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssp_valid_tdm_framesize); i++) {\n\t\tif (ssp_valid_tdm_framesize[i] == frame_bits) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tdev_err(aio->cygaud->dev,\n\t\t\t\"%s In TDM mode, frame bits INVALID (%d)\\n\",\n\t\t\t__func__, frame_bits);\n\t\treturn -EINVAL;\n\t}\n\n\taio->bit_per_frame = frame_bits;\n\n\tdev_dbg(aio->cygaud->dev, \"%s active_slots %u, bits per frame %d\\n\",\n\t\t\t__func__, active_slots, frame_bits);\n\n\t \n\tvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\n\tvalue &= ~(0xf << I2S_OUT_CFGX_VALID_SLOT);\n\tvalue |= (active_slots << I2S_OUT_CFGX_VALID_SLOT);\n\tvalue &= ~BIT(I2S_OUT_CFGX_BITS_PER_SLOT);\n\tvalue |= (bits_per_slot << I2S_OUT_CFGX_BITS_PER_SLOT);\n\twritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\n\n\t \n\tvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\n\tvalue &= ~(0xf << I2S_OUT_CFGX_VALID_SLOT);\n\tvalue |= (active_slots << I2S_OUT_CFGX_VALID_SLOT);\n\tvalue &= ~BIT(I2S_OUT_CFGX_BITS_PER_SLOT);\n\tvalue |= (bits_per_slot << I2S_OUT_CFGX_BITS_PER_SLOT);\n\twritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int __cygnus_ssp_suspend(struct snd_soc_dai *cpu_dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\n\n\tif (!snd_soc_dai_active(cpu_dai))\n\t\treturn 0;\n\n\tif (!aio->is_slave) {\n\t\tu32 val;\n\n\t\tval = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\n\t\tval &= CYGNUS_PLLCLKSEL_MASK;\n\t\tif (val >= ARRAY_SIZE(aio->cygaud->audio_clk)) {\n\t\t\tdev_err(aio->cygaud->dev, \"Clk index %u is out of bounds\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aio->clk_trace.cap_clk_en)\n\t\t\tclk_disable_unprepare(aio->cygaud->audio_clk[val]);\n\t\tif (aio->clk_trace.play_clk_en)\n\t\t\tclk_disable_unprepare(aio->cygaud->audio_clk[val]);\n\n\t\taio->pll_clk_num = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int cygnus_ssp_suspend(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\tint ret = 0;\n\n\tfor_each_component_dais(component, dai)\n\t\tret |= __cygnus_ssp_suspend(dai);\n\n\treturn ret;\n}\n\nstatic int __cygnus_ssp_resume(struct snd_soc_dai *cpu_dai)\n{\n\tstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\n\tint error;\n\n\tif (!snd_soc_dai_active(cpu_dai))\n\t\treturn 0;\n\n\tif (!aio->is_slave) {\n\t\tif (aio->clk_trace.cap_clk_en) {\n\t\t\terror = clk_prepare_enable(aio->cygaud->\n\t\t\t\t\taudio_clk[aio->pll_clk_num]);\n\t\t\tif (error) {\n\t\t\t\tdev_err(aio->cygaud->dev, \"%s clk_prepare_enable failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (aio->clk_trace.play_clk_en) {\n\t\t\terror = clk_prepare_enable(aio->cygaud->\n\t\t\t\t\taudio_clk[aio->pll_clk_num]);\n\t\t\tif (error) {\n\t\t\t\tif (aio->clk_trace.cap_clk_en)\n\t\t\t\t\tclk_disable_unprepare(aio->cygaud->\n\t\t\t\t\t\taudio_clk[aio->pll_clk_num]);\n\t\t\t\tdev_err(aio->cygaud->dev, \"%s clk_prepare_enable failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cygnus_ssp_resume(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\tint ret = 0;\n\n\tfor_each_component_dais(component, dai)\n\t\tret |= __cygnus_ssp_resume(dai);\n\n\treturn ret;\n}\n\n#else\n#define cygnus_ssp_suspend NULL\n#define cygnus_ssp_resume  NULL\n#endif\n\nstatic const struct snd_soc_dai_ops cygnus_ssp_dai_ops = {\n\t.startup\t= cygnus_ssp_startup,\n\t.shutdown\t= cygnus_ssp_shutdown,\n\t.trigger\t= cygnus_ssp_trigger,\n\t.hw_params\t= cygnus_ssp_hw_params,\n\t.set_fmt\t= cygnus_ssp_set_fmt,\n\t.set_sysclk\t= cygnus_ssp_set_sysclk,\n\t.set_tdm_slot\t= cygnus_set_dai_tdm_slot,\n};\n\nstatic const struct snd_soc_dai_ops cygnus_spdif_dai_ops = {\n\t.startup\t= cygnus_ssp_startup,\n\t.shutdown\t= cygnus_ssp_shutdown,\n\t.trigger\t= cygnus_ssp_trigger,\n\t.hw_params\t= cygnus_ssp_hw_params,\n\t.set_sysclk\t= cygnus_ssp_set_sysclk,\n};\n\n#define INIT_CPU_DAI(num) { \\\n\t.name = \"cygnus-ssp\" #num, \\\n\t.playback = { \\\n\t\t.channels_min = 2, \\\n\t\t.channels_max = 16, \\\n\t\t.rates = SNDRV_PCM_RATE_KNOT, \\\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE, \\\n\t}, \\\n\t.capture = { \\\n\t\t.channels_min = 2, \\\n\t\t.channels_max = 16, \\\n\t\t.rates = SNDRV_PCM_RATE_KNOT, \\\n\t\t.formats =  SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE, \\\n\t}, \\\n\t.ops = &cygnus_ssp_dai_ops, \\\n}\n\nstatic const struct snd_soc_dai_driver cygnus_ssp_dai_info[] = {\n\tINIT_CPU_DAI(0),\n\tINIT_CPU_DAI(1),\n\tINIT_CPU_DAI(2),\n};\n\nstatic const struct snd_soc_dai_driver cygnus_spdif_dai_info = {\n\t.name = \"cygnus-spdif\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.ops = &cygnus_spdif_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver cygnus_ssp_dai[CYGNUS_MAX_PORTS];\n\nstatic const struct snd_soc_component_driver cygnus_ssp_component = {\n\t.name\t\t\t= \"cygnus-audio\",\n\t.suspend\t\t= cygnus_ssp_suspend,\n\t.resume\t\t\t= cygnus_ssp_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic int parse_ssp_child_node(struct platform_device *pdev,\n\t\t\t\tstruct device_node *dn,\n\t\t\t\tstruct cygnus_audio *cygaud,\n\t\t\t\tstruct snd_soc_dai_driver *p_dai)\n{\n\tstruct cygnus_aio_port *aio;\n\tstruct cygnus_ssp_regs ssp_regs[3];\n\tu32 rawval;\n\tint portnum = -1;\n\tenum cygnus_audio_port_type port_type;\n\n\tif (of_property_read_u32(dn, \"reg\", &rawval)) {\n\t\tdev_err(&pdev->dev, \"Missing reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tportnum = rawval;\n\tswitch (rawval) {\n\tcase 0:\n\t\tssp_regs[0] = INIT_SSP_REGS(0);\n\t\tport_type = PORT_TDM;\n\t\tbreak;\n\tcase 1:\n\t\tssp_regs[1] = INIT_SSP_REGS(1);\n\t\tport_type = PORT_TDM;\n\t\tbreak;\n\tcase 2:\n\t\tssp_regs[2] = INIT_SSP_REGS(2);\n\t\tport_type = PORT_TDM;\n\t\tbreak;\n\tcase 3:\n\t\tport_type = PORT_SPDIF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Bad value for reg %u\\n\", rawval);\n\t\treturn -EINVAL;\n\t}\n\n\taio = &cygaud->portinfo[portnum];\n\taio->cygaud = cygaud;\n\taio->portnum = portnum;\n\taio->port_type = port_type;\n\taio->fsync_width = -1;\n\n\tswitch (port_type) {\n\tcase PORT_TDM:\n\t\taio->regs = ssp_regs[portnum];\n\t\t*p_dai = cygnus_ssp_dai_info[portnum];\n\t\taio->mode = CYGNUS_SSPMODE_UNKNOWN;\n\t\tbreak;\n\n\tcase PORT_SPDIF:\n\t\taio->regs.bf_sourcech_cfg = BF_SRC_CFG3_OFFSET;\n\t\taio->regs.bf_sourcech_ctrl = BF_SRC_CTRL3_OFFSET;\n\t\taio->regs.i2s_mclk_cfg = SPDIF_MCLK_CFG_OFFSET;\n\t\taio->regs.i2s_stream_cfg = SPDIF_STREAM_CFG_OFFSET;\n\t\t*p_dai = cygnus_spdif_dai_info;\n\n\t\t \n\t\taio->mode = CYGNUS_SSPMODE_I2S;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Bad value for port_type %d\\n\", port_type);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&pdev->dev, \"%s portnum = %d\\n\", __func__, aio->portnum);\n\taio->streams_on = 0;\n\taio->cygaud->dev = &pdev->dev;\n\taio->clk_trace.play_en = false;\n\taio->clk_trace.cap_en = false;\n\n\taudio_ssp_init_portregs(aio);\n\treturn 0;\n}\n\nstatic int audio_clk_init(struct platform_device *pdev,\n\t\t\t\t\t\tstruct cygnus_audio *cygaud)\n{\n\tint i;\n\tchar clk_name[PROP_LEN_MAX];\n\n\tfor (i = 0; i < ARRAY_SIZE(cygaud->audio_clk); i++) {\n\t\tsnprintf(clk_name, PROP_LEN_MAX, \"ch%d_audio\", i);\n\n\t\tcygaud->audio_clk[i] = devm_clk_get(&pdev->dev, clk_name);\n\t\tif (IS_ERR(cygaud->audio_clk[i]))\n\t\t\treturn PTR_ERR(cygaud->audio_clk[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int cygnus_ssp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child_node;\n\tstruct cygnus_audio *cygaud;\n\tint err;\n\tint node_count;\n\tint active_port_count;\n\n\tcygaud = devm_kzalloc(dev, sizeof(struct cygnus_audio), GFP_KERNEL);\n\tif (!cygaud)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, cygaud);\n\n\tcygaud->audio = devm_platform_ioremap_resource_byname(pdev, \"aud\");\n\tif (IS_ERR(cygaud->audio))\n\t\treturn PTR_ERR(cygaud->audio);\n\n\tcygaud->i2s_in = devm_platform_ioremap_resource_byname(pdev, \"i2s_in\");\n\tif (IS_ERR(cygaud->i2s_in))\n\t\treturn PTR_ERR(cygaud->i2s_in);\n\n\t \n\twritel(CYGNUS_SSP_TRISTATE_MASK,\n\t\t\tcygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\n\n\tnode_count = of_get_child_count(pdev->dev.of_node);\n\tif ((node_count < 1) || (node_count > CYGNUS_MAX_PORTS)) {\n\t\tdev_err(dev, \"child nodes is %d.  Must be between 1 and %d\\n\",\n\t\t\tnode_count, CYGNUS_MAX_PORTS);\n\t\treturn -EINVAL;\n\t}\n\n\tactive_port_count = 0;\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, child_node) {\n\t\terr = parse_ssp_child_node(pdev, child_node, cygaud,\n\t\t\t\t\t&cygnus_ssp_dai[active_port_count]);\n\n\t\t \n\t\tif (err < 0) {\n\t\t\tof_node_put(child_node);\n\t\t\treturn err;\n\t\t}\n\t\telse if (!err) {\n\t\t\tdev_dbg(dev, \"Activating DAI: %s\\n\",\n\t\t\t\tcygnus_ssp_dai[active_port_count].name);\n\t\t\tactive_port_count++;\n\t\t}\n\t}\n\n\tcygaud->dev = dev;\n\tcygaud->active_ports = 0;\n\n\tdev_dbg(dev, \"Registering %d DAIs\\n\", active_port_count);\n\terr = devm_snd_soc_register_component(dev, &cygnus_ssp_component,\n\t\t\t\tcygnus_ssp_dai, active_port_count);\n\tif (err) {\n\t\tdev_err(dev, \"snd_soc_register_dai failed\\n\");\n\t\treturn err;\n\t}\n\n\tcygaud->irq_num = platform_get_irq(pdev, 0);\n\tif (cygaud->irq_num <= 0)\n\t\treturn cygaud->irq_num;\n\n\terr = audio_clk_init(pdev, cygaud);\n\tif (err) {\n\t\tdev_err(dev, \"audio clock initialization failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = cygnus_soc_platform_register(dev, cygaud);\n\tif (err) {\n\t\tdev_err(dev, \"platform reg error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void cygnus_ssp_remove(struct platform_device *pdev)\n{\n\tcygnus_soc_platform_unregister(&pdev->dev);\n}\n\nstatic const struct of_device_id cygnus_ssp_of_match[] = {\n\t{ .compatible = \"brcm,cygnus-audio\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cygnus_ssp_of_match);\n\nstatic struct platform_driver cygnus_ssp_driver = {\n\t.probe\t\t= cygnus_ssp_probe,\n\t.remove_new\t= cygnus_ssp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cygnus-ssp\",\n\t\t.of_match_table = cygnus_ssp_of_match,\n\t},\n};\n\nmodule_platform_driver(cygnus_ssp_driver);\n\nMODULE_ALIAS(\"platform:cygnus-ssp\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Cygnus ASoC SSP Interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}