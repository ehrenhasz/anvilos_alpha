{
  "module_name": "cygnus-pcm.c",
  "hash_id": "ac0e35a15d32507e1aa45f903f0c11b54d69a0b676980849f4858cf6fc5a70d2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/bcm/cygnus-pcm.c",
  "human_readable_source": "\n\n#include <linux/debugfs.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"cygnus-ssp.h\"\n\n \n\n#define INTH_R5F_STATUS_OFFSET     0x040\n#define INTH_R5F_CLEAR_OFFSET      0x048\n#define INTH_R5F_MASK_SET_OFFSET   0x050\n#define INTH_R5F_MASK_CLEAR_OFFSET 0x054\n\n#define BF_REARM_FREE_MARK_OFFSET 0x344\n#define BF_REARM_FULL_MARK_OFFSET 0x348\n\n \n \n#define SRC_RBUF_0_RDADDR_OFFSET 0x500\n#define SRC_RBUF_1_RDADDR_OFFSET 0x518\n#define SRC_RBUF_2_RDADDR_OFFSET 0x530\n#define SRC_RBUF_3_RDADDR_OFFSET 0x548\n#define SRC_RBUF_4_RDADDR_OFFSET 0x560\n#define SRC_RBUF_5_RDADDR_OFFSET 0x578\n#define SRC_RBUF_6_RDADDR_OFFSET 0x590\n\n \n#define SRC_RBUF_0_WRADDR_OFFSET 0x504\n#define SRC_RBUF_1_WRADDR_OFFSET 0x51c\n#define SRC_RBUF_2_WRADDR_OFFSET 0x534\n#define SRC_RBUF_3_WRADDR_OFFSET 0x54c\n#define SRC_RBUF_4_WRADDR_OFFSET 0x564\n#define SRC_RBUF_5_WRADDR_OFFSET 0x57c\n#define SRC_RBUF_6_WRADDR_OFFSET 0x594\n\n \n#define SRC_RBUF_0_BASEADDR_OFFSET 0x508\n#define SRC_RBUF_1_BASEADDR_OFFSET 0x520\n#define SRC_RBUF_2_BASEADDR_OFFSET 0x538\n#define SRC_RBUF_3_BASEADDR_OFFSET 0x550\n#define SRC_RBUF_4_BASEADDR_OFFSET 0x568\n#define SRC_RBUF_5_BASEADDR_OFFSET 0x580\n#define SRC_RBUF_6_BASEADDR_OFFSET 0x598\n\n \n#define SRC_RBUF_0_ENDADDR_OFFSET 0x50c\n#define SRC_RBUF_1_ENDADDR_OFFSET 0x524\n#define SRC_RBUF_2_ENDADDR_OFFSET 0x53c\n#define SRC_RBUF_3_ENDADDR_OFFSET 0x554\n#define SRC_RBUF_4_ENDADDR_OFFSET 0x56c\n#define SRC_RBUF_5_ENDADDR_OFFSET 0x584\n#define SRC_RBUF_6_ENDADDR_OFFSET 0x59c\n\n \n#define SRC_RBUF_0_FREE_MARK_OFFSET 0x510\n#define SRC_RBUF_1_FREE_MARK_OFFSET 0x528\n#define SRC_RBUF_2_FREE_MARK_OFFSET 0x540\n#define SRC_RBUF_3_FREE_MARK_OFFSET 0x558\n#define SRC_RBUF_4_FREE_MARK_OFFSET 0x570\n#define SRC_RBUF_5_FREE_MARK_OFFSET 0x588\n#define SRC_RBUF_6_FREE_MARK_OFFSET 0x5a0\n\n \n#define DST_RBUF_0_RDADDR_OFFSET 0x5c0\n#define DST_RBUF_1_RDADDR_OFFSET 0x5d8\n#define DST_RBUF_2_RDADDR_OFFSET 0x5f0\n#define DST_RBUF_3_RDADDR_OFFSET 0x608\n#define DST_RBUF_4_RDADDR_OFFSET 0x620\n#define DST_RBUF_5_RDADDR_OFFSET 0x638\n\n \n#define DST_RBUF_0_WRADDR_OFFSET 0x5c4\n#define DST_RBUF_1_WRADDR_OFFSET 0x5dc\n#define DST_RBUF_2_WRADDR_OFFSET 0x5f4\n#define DST_RBUF_3_WRADDR_OFFSET 0x60c\n#define DST_RBUF_4_WRADDR_OFFSET 0x624\n#define DST_RBUF_5_WRADDR_OFFSET 0x63c\n\n \n#define DST_RBUF_0_BASEADDR_OFFSET 0x5c8\n#define DST_RBUF_1_BASEADDR_OFFSET 0x5e0\n#define DST_RBUF_2_BASEADDR_OFFSET 0x5f8\n#define DST_RBUF_3_BASEADDR_OFFSET 0x610\n#define DST_RBUF_4_BASEADDR_OFFSET 0x628\n#define DST_RBUF_5_BASEADDR_OFFSET 0x640\n\n \n#define DST_RBUF_0_ENDADDR_OFFSET 0x5cc\n#define DST_RBUF_1_ENDADDR_OFFSET 0x5e4\n#define DST_RBUF_2_ENDADDR_OFFSET 0x5fc\n#define DST_RBUF_3_ENDADDR_OFFSET 0x614\n#define DST_RBUF_4_ENDADDR_OFFSET 0x62c\n#define DST_RBUF_5_ENDADDR_OFFSET 0x644\n\n \n#define DST_RBUF_0_FULL_MARK_OFFSET 0x5d0\n#define DST_RBUF_1_FULL_MARK_OFFSET 0x5e8\n#define DST_RBUF_2_FULL_MARK_OFFSET 0x600\n#define DST_RBUF_3_FULL_MARK_OFFSET 0x618\n#define DST_RBUF_4_FULL_MARK_OFFSET 0x630\n#define DST_RBUF_5_FULL_MARK_OFFSET 0x648\n \n\n \n \n#define ESR0_STATUS_OFFSET 0x900\n#define ESR1_STATUS_OFFSET 0x918\n#define ESR2_STATUS_OFFSET 0x930\n#define ESR3_STATUS_OFFSET 0x948\n#define ESR4_STATUS_OFFSET 0x960\n\n \n#define ESR0_STATUS_CLR_OFFSET 0x908\n#define ESR1_STATUS_CLR_OFFSET 0x920\n#define ESR2_STATUS_CLR_OFFSET 0x938\n#define ESR3_STATUS_CLR_OFFSET 0x950\n#define ESR4_STATUS_CLR_OFFSET 0x968\n\n \n#define ESR0_MASK_STATUS_OFFSET 0x90c\n#define ESR1_MASK_STATUS_OFFSET 0x924\n#define ESR2_MASK_STATUS_OFFSET 0x93c\n#define ESR3_MASK_STATUS_OFFSET 0x954\n#define ESR4_MASK_STATUS_OFFSET 0x96c\n\n \n#define ESR0_MASK_SET_OFFSET 0x910\n#define ESR1_MASK_SET_OFFSET 0x928\n#define ESR2_MASK_SET_OFFSET 0x940\n#define ESR3_MASK_SET_OFFSET 0x958\n#define ESR4_MASK_SET_OFFSET 0x970\n\n \n#define ESR0_MASK_CLR_OFFSET 0x914\n#define ESR1_MASK_CLR_OFFSET 0x92c\n#define ESR2_MASK_CLR_OFFSET 0x944\n#define ESR3_MASK_CLR_OFFSET 0x95c\n#define ESR4_MASK_CLR_OFFSET 0x974\n \n\n#define R5F_ESR0_SHIFT  0     \n#define R5F_ESR1_SHIFT  1     \n#define R5F_ESR2_SHIFT  2     \n#define R5F_ESR3_SHIFT  3     \n#define R5F_ESR4_SHIFT  4     \n\n\n \n#define ANY_PLAYBACK_IRQ  (BIT(R5F_ESR0_SHIFT) | \\\n\t\t\t   BIT(R5F_ESR1_SHIFT) | \\\n\t\t\t   BIT(R5F_ESR3_SHIFT))\n\n \n#define ANY_CAPTURE_IRQ   (BIT(R5F_ESR2_SHIFT) | BIT(R5F_ESR4_SHIFT))\n\n \n#define PERIOD_BYTES_MIN 0x100\n\nstatic const struct snd_pcm_hardware cygnus_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\n\t \n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = 0x10000,\n\n\t \n\t.periods_min = 2,\n\t.periods_max = 8,\n\n\t \n\t.buffer_bytes_max = 4 * 0x8000,\n};\n\nstatic u64 cygnus_dma_dmamask = DMA_BIT_MASK(32);\n\nstatic struct cygnus_aio_port *cygnus_dai_get_dma_data(\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\n\treturn snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(soc_runtime, 0), substream);\n}\n\nstatic void ringbuf_set_initial(void __iomem *audio_io,\n\t\tstruct ringbuf_regs *p_rbuf,\n\t\tbool is_playback,\n\t\tu32 start,\n\t\tu32 periodsize,\n\t\tu32 bufsize)\n{\n\tu32 initial_rd;\n\tu32 initial_wr;\n\tu32 end;\n\tu32 fmark_val;  \n\n\tp_rbuf->period_bytes = periodsize;\n\tp_rbuf->buf_size = bufsize;\n\n\tif (is_playback) {\n\t\t \n\t\tinitial_rd = start;\n\t\tinitial_wr = initial_rd ^ BIT(31);\n\t} else {\n\t\t \n\t\tinitial_wr = start;\n\t\tinitial_rd = initial_wr;\n\t}\n\n\tend = start + bufsize - 1;\n\n\t \n\tfmark_val = periodsize - PERIOD_BYTES_MIN;\n\n\twritel(start, audio_io + p_rbuf->baseaddr);\n\twritel(end, audio_io + p_rbuf->endaddr);\n\twritel(fmark_val, audio_io + p_rbuf->fmark);\n\twritel(initial_rd, audio_io + p_rbuf->rdaddr);\n\twritel(initial_wr, audio_io + p_rbuf->wraddr);\n}\n\nstatic int configure_ringbuf_regs(struct snd_pcm_substream *substream)\n{\n\tstruct cygnus_aio_port *aio;\n\tstruct ringbuf_regs *p_rbuf;\n\tint status = 0;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tp_rbuf = &aio->play_rb_regs;\n\n\t\tswitch (aio->portnum) {\n\t\tcase 0:\n\t\t\t*p_rbuf = RINGBUF_REG_PLAYBACK(0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*p_rbuf = RINGBUF_REG_PLAYBACK(2);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*p_rbuf = RINGBUF_REG_PLAYBACK(4);\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\t*p_rbuf = RINGBUF_REG_PLAYBACK(6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t} else {\n\t\tp_rbuf = &aio->capture_rb_regs;\n\n\t\tswitch (aio->portnum) {\n\t\tcase 0:\n\t\t\t*p_rbuf = RINGBUF_REG_CAPTURE(0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*p_rbuf = RINGBUF_REG_CAPTURE(2);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*p_rbuf = RINGBUF_REG_CAPTURE(4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic struct ringbuf_regs *get_ringbuf(struct snd_pcm_substream *substream)\n{\n\tstruct cygnus_aio_port *aio;\n\tstruct ringbuf_regs *p_rbuf = NULL;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tp_rbuf = &aio->play_rb_regs;\n\telse\n\t\tp_rbuf = &aio->capture_rb_regs;\n\n\treturn p_rbuf;\n}\n\nstatic void enable_intr(struct snd_pcm_substream *substream)\n{\n\tstruct cygnus_aio_port *aio;\n\tu32 clear_mask;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\t \n\tclear_mask = BIT(aio->portnum);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\twritel(clear_mask, aio->cygaud->audio + ESR0_STATUS_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR1_STATUS_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR3_STATUS_CLR_OFFSET);\n\t\t \n\t\twritel(clear_mask, aio->cygaud->audio + ESR0_MASK_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR1_MASK_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR3_MASK_CLR_OFFSET);\n\n\t\twritel(ANY_PLAYBACK_IRQ,\n\t\t\taio->cygaud->audio + INTH_R5F_MASK_CLEAR_OFFSET);\n\t} else {\n\t\twritel(clear_mask, aio->cygaud->audio + ESR2_STATUS_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR4_STATUS_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR2_MASK_CLR_OFFSET);\n\t\twritel(clear_mask, aio->cygaud->audio + ESR4_MASK_CLR_OFFSET);\n\n\t\twritel(ANY_CAPTURE_IRQ,\n\t\t\taio->cygaud->audio + INTH_R5F_MASK_CLEAR_OFFSET);\n\t}\n\n}\n\nstatic void disable_intr(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct cygnus_aio_port *aio;\n\tu32 set_mask;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"%s on port %d\\n\", __func__, aio->portnum);\n\n\t \n\tset_mask = BIT(aio->portnum);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\twritel(set_mask, aio->cygaud->audio + ESR0_MASK_SET_OFFSET);\n\t\twritel(set_mask, aio->cygaud->audio + ESR1_MASK_SET_OFFSET);\n\t\twritel(set_mask, aio->cygaud->audio + ESR3_MASK_SET_OFFSET);\n\t} else {\n\t\twritel(set_mask, aio->cygaud->audio + ESR2_MASK_SET_OFFSET);\n\t\twritel(set_mask, aio->cygaud->audio + ESR4_MASK_SET_OFFSET);\n\t}\n\n}\n\nstatic int cygnus_pcm_trigger(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tenable_intr(substream);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdisable_intr(substream);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void cygnus_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct cygnus_aio_port *aio;\n\tstruct ringbuf_regs *p_rbuf = NULL;\n\tu32 regval;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\tp_rbuf = get_ringbuf(substream);\n\n\t \n\tsnd_pcm_period_elapsed(substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\tregval = readl(aio->cygaud->audio + p_rbuf->rdaddr);\n\t\tregval = regval ^ BIT(31);\n\t\twritel(regval, aio->cygaud->audio + p_rbuf->wraddr);\n\t} else {\n\t\t \n\t\tregval = readl(aio->cygaud->audio + p_rbuf->wraddr);\n\t\twritel(regval, aio->cygaud->audio + p_rbuf->rdaddr);\n\t}\n}\n\n \nstatic void handle_playback_irq(struct cygnus_audio *cygaud)\n{\n\tvoid __iomem *audio_io;\n\tu32 port;\n\tu32 esr_status0, esr_status1, esr_status3;\n\n\taudio_io = cygaud->audio;\n\n\t \n\tesr_status0 = readl(audio_io + ESR0_STATUS_OFFSET);\n\tesr_status0 &= ~readl(audio_io + ESR0_MASK_STATUS_OFFSET);\n\tesr_status1 = readl(audio_io + ESR1_STATUS_OFFSET);\n\tesr_status1 &= ~readl(audio_io + ESR1_MASK_STATUS_OFFSET);\n\tesr_status3 = readl(audio_io + ESR3_STATUS_OFFSET);\n\tesr_status3 &= ~readl(audio_io + ESR3_MASK_STATUS_OFFSET);\n\n\tfor (port = 0; port < CYGNUS_MAX_PLAYBACK_PORTS; port++) {\n\t\tu32 esrmask = BIT(port);\n\n\t\t \n\t\tif ((esrmask & esr_status1) || (esrmask & esr_status0)) {\n\t\t\tdev_dbg(cygaud->dev,\n\t\t\t\t\"Underrun: esr0=0x%x, esr1=0x%x esr3=0x%x\\n\",\n\t\t\t\tesr_status0, esr_status1, esr_status3);\n\t\t}\n\n\t\t \n\t\tif (esrmask & esr_status3) {\n\t\t\tstruct snd_pcm_substream *playstr;\n\n\t\t\tplaystr = cygaud->portinfo[port].play_stream;\n\t\t\tcygnus_pcm_period_elapsed(playstr);\n\t\t}\n\t}\n\n\t \n\twritel(esr_status0, audio_io + ESR0_STATUS_CLR_OFFSET);\n\twritel(esr_status1, audio_io + ESR1_STATUS_CLR_OFFSET);\n\twritel(esr_status3, audio_io + ESR3_STATUS_CLR_OFFSET);\n\t \n\twritel(esr_status3, audio_io + BF_REARM_FREE_MARK_OFFSET);\n}\n\n \nstatic void handle_capture_irq(struct cygnus_audio *cygaud)\n{\n\tvoid __iomem *audio_io;\n\tu32 port;\n\tu32 esr_status2, esr_status4;\n\n\taudio_io = cygaud->audio;\n\n\t \n\tesr_status2 = readl(audio_io + ESR2_STATUS_OFFSET);\n\tesr_status2 &= ~readl(audio_io + ESR2_MASK_STATUS_OFFSET);\n\tesr_status4 = readl(audio_io + ESR4_STATUS_OFFSET);\n\tesr_status4 &= ~readl(audio_io + ESR4_MASK_STATUS_OFFSET);\n\n\tfor (port = 0; port < CYGNUS_MAX_CAPTURE_PORTS; port++) {\n\t\tu32 esrmask = BIT(port);\n\n\t\t \n\t\tif (esrmask & esr_status2)\n\t\t\tdev_dbg(cygaud->dev,\n\t\t\t\t\"Overflow: esr2=0x%x\\n\", esr_status2);\n\n\t\tif (esrmask & esr_status4) {\n\t\t\tstruct snd_pcm_substream *capstr;\n\n\t\t\tcapstr = cygaud->portinfo[port].capture_stream;\n\t\t\tcygnus_pcm_period_elapsed(capstr);\n\t\t}\n\t}\n\n\twritel(esr_status2, audio_io + ESR2_STATUS_CLR_OFFSET);\n\twritel(esr_status4, audio_io + ESR4_STATUS_CLR_OFFSET);\n\t \n\twritel(esr_status4, audio_io + BF_REARM_FULL_MARK_OFFSET);\n}\n\nstatic irqreturn_t cygnus_dma_irq(int irq, void *data)\n{\n\tu32 r5_status;\n\tstruct cygnus_audio *cygaud = data;\n\n\t \n\tr5_status = readl(cygaud->audio + INTH_R5F_STATUS_OFFSET);\n\n\tif (!(r5_status & (ANY_PLAYBACK_IRQ | ANY_CAPTURE_IRQ)))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (ANY_PLAYBACK_IRQ & r5_status) {\n\t\thandle_playback_irq(cygaud);\n\t\twritel(ANY_PLAYBACK_IRQ & r5_status,\n\t\t\tcygaud->audio + INTH_R5F_CLEAR_OFFSET);\n\t}\n\n\t \n\tif (ANY_CAPTURE_IRQ & r5_status) {\n\t\thandle_capture_irq(cygaud);\n\t\twritel(ANY_CAPTURE_IRQ & r5_status,\n\t\t\tcygaud->audio + INTH_R5F_CLEAR_OFFSET);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cygnus_pcm_open(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cygnus_aio_port *aio;\n\tint ret;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\tif (!aio)\n\t\treturn -ENODEV;\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"%s port %d\\n\", __func__, aio->portnum);\n\n\tsnd_soc_set_runtime_hwparams(substream, &cygnus_pcm_hw);\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_PERIOD_BYTES, PERIOD_BYTES_MIN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES, PERIOD_BYTES_MIN);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\taio->play_stream = substream;\n\telse\n\t\taio->capture_stream = substream;\n\n\treturn 0;\n}\n\nstatic int cygnus_pcm_close(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct cygnus_aio_port *aio;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"%s  port %d\\n\", __func__, aio->portnum);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\taio->play_stream = NULL;\n\telse\n\t\taio->capture_stream = NULL;\n\n\tif (!aio->play_stream && !aio->capture_stream)\n\t\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"freed  port %d\\n\", aio->portnum);\n\n\treturn 0;\n}\n\nstatic int cygnus_pcm_prepare(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cygnus_aio_port *aio;\n\tunsigned long bufsize, periodsize;\n\tbool is_play;\n\tu32 start;\n\tstruct ringbuf_regs *p_rbuf = NULL;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"%s port %d\\n\", __func__, aio->portnum);\n\n\tbufsize = snd_pcm_lib_buffer_bytes(substream);\n\tperiodsize = snd_pcm_lib_period_bytes(substream);\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"%s (buf_size %lu) (period_size %lu)\\n\",\n\t\t\t__func__, bufsize, periodsize);\n\n\tconfigure_ringbuf_regs(substream);\n\n\tp_rbuf = get_ringbuf(substream);\n\n\tstart = runtime->dma_addr;\n\n\tis_play = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 1 : 0;\n\n\tringbuf_set_initial(aio->cygaud->audio, p_rbuf, is_play, start,\n\t\t\t\tperiodsize, bufsize);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t cygnus_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct cygnus_aio_port *aio;\n\tunsigned int res = 0, cur = 0, base = 0;\n\tstruct ringbuf_regs *p_rbuf = NULL;\n\n\taio = cygnus_dai_get_dma_data(substream);\n\n\t \n\tp_rbuf = get_ringbuf(substream);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tcur = readl(aio->cygaud->audio + p_rbuf->rdaddr);\n\telse\n\t\tcur = readl(aio->cygaud->audio + p_rbuf->wraddr);\n\n\tbase = readl(aio->cygaud->audio + p_rbuf->baseaddr);\n\n\t \n\tres = (cur & 0x7fffffff) - (base & 0x7fffffff);\n\n\treturn bytes_to_frames(substream->runtime, res);\n}\n\nstatic int cygnus_dma_new(struct snd_soc_component *component,\n\t\t\t  struct snd_soc_pcm_runtime *rtd)\n{\n\tsize_t size = cygnus_pcm_hw.buffer_bytes_max;\n\tstruct snd_card *card = rtd->card->snd_card;\n\n\tif (!card->dev->dma_mask)\n\t\tcard->dev->dma_mask = &cygnus_dma_dmamask;\n\tif (!card->dev->coherent_dma_mask)\n\t\tcard->dev->coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, size, size);\n\n\treturn 0;\n}\n\nstatic struct snd_soc_component_driver cygnus_soc_platform = {\n\t.open\t\t= cygnus_pcm_open,\n\t.close\t\t= cygnus_pcm_close,\n\t.prepare\t= cygnus_pcm_prepare,\n\t.trigger\t= cygnus_pcm_trigger,\n\t.pointer\t= cygnus_pcm_pointer,\n\t.pcm_construct\t= cygnus_dma_new,\n};\n\nint cygnus_soc_platform_register(struct device *dev,\n\t\t\t\t struct cygnus_audio *cygaud)\n{\n\tint rc;\n\n\tdev_dbg(dev, \"%s Enter\\n\", __func__);\n\n\trc = devm_request_irq(dev, cygaud->irq_num, cygnus_dma_irq,\n\t\t\t\tIRQF_SHARED, \"cygnus-audio\", cygaud);\n\tif (rc) {\n\t\tdev_err(dev, \"%s request_irq error %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = devm_snd_soc_register_component(dev, &cygnus_soc_platform,\n\t\t\t\t\t     NULL, 0);\n\tif (rc) {\n\t\tdev_err(dev, \"%s failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint cygnus_soc_platform_unregister(struct device *dev)\n{\n\treturn 0;\n}\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Cygnus ASoC PCM module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}