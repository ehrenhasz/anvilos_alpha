{
  "module_name": "bcm63xx-pcm-whistler.c",
  "hash_id": "fd18a2e69794a03bd23acca7a50d361ab93b6ace18580e481ad295c1f9f4b274",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/bcm/bcm63xx-pcm-whistler.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <linux/of_device.h>\n#include <sound/soc.h>\n#include \"bcm63xx-i2s.h\"\n\n\nstruct i2s_dma_desc {\n\tunsigned char *dma_area;\n\tdma_addr_t dma_addr;\n\tunsigned int dma_len;\n};\n\nstruct bcm63xx_runtime_data {\n\tint dma_len;\n\tdma_addr_t dma_addr;\n\tdma_addr_t dma_addr_next;\n};\n\nstatic const struct snd_pcm_hardware bcm63xx_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,  \n\t.period_bytes_max = 8192 - 32,\n\t.periods_min = 1,\n\t.periods_max = PAGE_SIZE/sizeof(struct i2s_dma_desc),\n\t.buffer_bytes_max = 128 * 1024,\n\t.fifo_size = 32,\n};\n\nstatic int bcm63xx_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct i2s_dma_desc *dma_desc;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tdma_desc = kzalloc(sizeof(*dma_desc), GFP_NOWAIT);\n\tif (!dma_desc)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_dai_set_dma_data(asoc_rtd_to_cpu(rtd, 0), substream, dma_desc);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_pcm_hw_free(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct i2s_dma_desc\t*dma_desc;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tdma_desc = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tkfree(dma_desc);\n\n\treturn 0;\n}\n\nstatic int bcm63xx_pcm_trigger(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret = 0;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct bcm_i2s_priv *i2s_priv;\n\tstruct regmap   *regmap_i2s;\n\n\trtd = asoc_substream_to_rtd(substream);\n\ti2s_priv = dev_get_drvdata(asoc_rtd_to_cpu(rtd, 0)->dev);\n\tregmap_i2s = i2s_priv->regmap_i2s;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_TX_IRQ_EN,\n\t\t\t\t\t   I2S_TX_DESC_OFF_INTR_EN,\n\t\t\t\t\t   I2S_TX_DESC_OFF_INTR_EN);\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_TX_CFG,\n\t\t\t\t\t   I2S_TX_ENABLE_MASK,\n\t\t\t\t\t   I2S_TX_ENABLE);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tregmap_write(regmap_i2s,\n\t\t\t\t     I2S_TX_IRQ_EN,\n\t\t\t\t     0);\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_TX_CFG,\n\t\t\t\t\t   I2S_TX_ENABLE_MASK,\n\t\t\t\t\t   0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_RX_IRQ_EN,\n\t\t\t\t\t   I2S_RX_DESC_OFF_INTR_EN_MSK,\n\t\t\t\t\t   I2S_RX_DESC_OFF_INTR_EN);\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_RX_CFG,\n\t\t\t\t\t   I2S_RX_ENABLE_MASK,\n\t\t\t\t\t   I2S_RX_ENABLE);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_RX_IRQ_EN,\n\t\t\t\t\t   I2S_RX_DESC_OFF_INTR_EN_MSK,\n\t\t\t\t\t   0);\n\t\t\tregmap_update_bits(regmap_i2s,\n\t\t\t\t\t   I2S_RX_CFG,\n\t\t\t\t\t   I2S_RX_ENABLE_MASK,\n\t\t\t\t\t   0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int bcm63xx_pcm_prepare(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct i2s_dma_desc\t*dma_desc;\n\tstruct regmap\t\t*regmap_i2s;\n\tstruct bcm_i2s_priv\t*i2s_priv;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tuint32_t regaddr_desclen, regaddr_descaddr;\n\n\tdma_desc = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tdma_desc->dma_len  = snd_pcm_lib_period_bytes(substream);\n\tdma_desc->dma_addr = runtime->dma_addr;\n\tdma_desc->dma_area = runtime->dma_area;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregaddr_desclen = I2S_TX_DESC_IFF_LEN;\n\t\tregaddr_descaddr = I2S_TX_DESC_IFF_ADDR;\n\t} else {\n\t\tregaddr_desclen = I2S_RX_DESC_IFF_LEN;\n\t\tregaddr_descaddr = I2S_RX_DESC_IFF_ADDR;\n\t}\n\n\ti2s_priv = dev_get_drvdata(asoc_rtd_to_cpu(rtd, 0)->dev);\n\tregmap_i2s = i2s_priv->regmap_i2s;\n\n\tregmap_write(regmap_i2s, regaddr_desclen, dma_desc->dma_len);\n\tregmap_write(regmap_i2s, regaddr_descaddr, dma_desc->dma_addr);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nbcm63xx_pcm_pointer(struct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tsnd_pcm_uframes_t x;\n\tstruct bcm63xx_runtime_data *prtd = substream->runtime->private_data;\n\n\tif (!prtd->dma_addr_next)\n\t\tprtd->dma_addr_next = substream->runtime->dma_addr;\n\n\tx = bytes_to_frames(substream->runtime,\n\t\tprtd->dma_addr_next - substream->runtime->dma_addr);\n\n\treturn x == substream->runtime->buffer_size ? 0 : x;\n}\n\nstatic int bcm63xx_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tint ret = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm63xx_runtime_data *prtd;\n\n\truntime->hw = bcm63xx_pcm_hardware;\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tif (ret)\n\t\tgoto out;\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\n\tif (ret)\n\t\tgoto out;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (!prtd)\n\t\tgoto out;\n\n\truntime->private_data = prtd;\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int bcm63xx_pcm_close(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct bcm63xx_runtime_data *prtd = runtime->private_data;\n\n\tkfree(prtd);\n\treturn 0;\n}\n\nstatic irqreturn_t i2s_dma_isr(int irq, void *bcm_i2s_priv)\n{\n\tunsigned int availdepth, ifflevel, offlevel, int_status, val_1, val_2;\n\tstruct bcm63xx_runtime_data *prtd;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct regmap *regmap_i2s;\n\tstruct i2s_dma_desc *dma_desc;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct bcm_i2s_priv *i2s_priv;\n\n\ti2s_priv = (struct bcm_i2s_priv *)bcm_i2s_priv;\n\tregmap_i2s = i2s_priv->regmap_i2s;\n\n\t \n\tregmap_read(regmap_i2s, I2S_RX_IRQ_CTL, &int_status);\n\n\tif (int_status & I2S_RX_DESC_OFF_INTR_EN_MSK) {\n\t\tsubstream = i2s_priv->capture_substream;\n\t\truntime = substream->runtime;\n\t\trtd = asoc_substream_to_rtd(substream);\n\t\tprtd = runtime->private_data;\n\t\tdma_desc = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\t\tofflevel = (int_status & I2S_RX_DESC_OFF_LEVEL_MASK) >>\n\t\t\t   I2S_RX_DESC_OFF_LEVEL_SHIFT;\n\t\twhile (offlevel) {\n\t\t\tregmap_read(regmap_i2s, I2S_RX_DESC_OFF_ADDR, &val_1);\n\t\t\tregmap_read(regmap_i2s, I2S_RX_DESC_OFF_LEN, &val_2);\n\t\t\tofflevel--;\n\t\t}\n\t\tprtd->dma_addr_next = val_1 + val_2;\n\t\tifflevel = (int_status & I2S_RX_DESC_IFF_LEVEL_MASK) >>\n\t\t\t   I2S_RX_DESC_IFF_LEVEL_SHIFT;\n\n\t\tavaildepth = I2S_DESC_FIFO_DEPTH - ifflevel;\n\t\twhile (availdepth) {\n\t\t\tdma_desc->dma_addr +=\n\t\t\t\t\tsnd_pcm_lib_period_bytes(substream);\n\t\t\tdma_desc->dma_area +=\n\t\t\t\t\tsnd_pcm_lib_period_bytes(substream);\n\t\t\tif (dma_desc->dma_addr - runtime->dma_addr >=\n\t\t\t\t\t\truntime->dma_bytes) {\n\t\t\t\tdma_desc->dma_addr = runtime->dma_addr;\n\t\t\t\tdma_desc->dma_area = runtime->dma_area;\n\t\t\t}\n\n\t\t\tprtd->dma_addr = dma_desc->dma_addr;\n\t\t\tregmap_write(regmap_i2s, I2S_RX_DESC_IFF_LEN,\n\t\t\t\t     snd_pcm_lib_period_bytes(substream));\n\t\t\tregmap_write(regmap_i2s, I2S_RX_DESC_IFF_ADDR,\n\t\t\t\t     dma_desc->dma_addr);\n\t\t\tavaildepth--;\n\t\t}\n\n\t\tsnd_pcm_period_elapsed(substream);\n\n\t\t \n\t\tregmap_update_bits(regmap_i2s, I2S_RX_IRQ_CTL,\n\t\t\t\t   I2S_RX_INTR_MASK, 0);\n\t}\n\n\t \n\tregmap_read(regmap_i2s, I2S_TX_IRQ_CTL, &int_status);\n\n\tif (int_status & I2S_TX_DESC_OFF_INTR_EN_MSK) {\n\t\tsubstream = i2s_priv->play_substream;\n\t\truntime = substream->runtime;\n\t\trtd = asoc_substream_to_rtd(substream);\n\t\tprtd = runtime->private_data;\n\t\tdma_desc = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\t\tofflevel = (int_status & I2S_TX_DESC_OFF_LEVEL_MASK) >>\n\t\t\t   I2S_TX_DESC_OFF_LEVEL_SHIFT;\n\t\twhile (offlevel) {\n\t\t\tregmap_read(regmap_i2s, I2S_TX_DESC_OFF_ADDR, &val_1);\n\t\t\tregmap_read(regmap_i2s, I2S_TX_DESC_OFF_LEN,  &val_2);\n\t\t\tprtd->dma_addr_next = val_1 + val_2;\n\t\t\tofflevel--;\n\t\t}\n\n\t\tifflevel = (int_status & I2S_TX_DESC_IFF_LEVEL_MASK) >>\n\t\t\tI2S_TX_DESC_IFF_LEVEL_SHIFT;\n\t\tavaildepth = I2S_DESC_FIFO_DEPTH - ifflevel;\n\n\t\twhile (availdepth) {\n\t\t\tdma_desc->dma_addr +=\n\t\t\t\t\tsnd_pcm_lib_period_bytes(substream);\n\t\t\tdma_desc->dma_area +=\n\t\t\t\t\tsnd_pcm_lib_period_bytes(substream);\n\n\t\t\tif (dma_desc->dma_addr - runtime->dma_addr >=\n\t\t\t\t\t\t\truntime->dma_bytes) {\n\t\t\t\tdma_desc->dma_addr = runtime->dma_addr;\n\t\t\t\tdma_desc->dma_area = runtime->dma_area;\n\t\t\t}\n\n\t\t\tprtd->dma_addr = dma_desc->dma_addr;\n\t\t\tregmap_write(regmap_i2s, I2S_TX_DESC_IFF_LEN,\n\t\t\t\tsnd_pcm_lib_period_bytes(substream));\n\t\t\tregmap_write(regmap_i2s, I2S_TX_DESC_IFF_ADDR,\n\t\t\t\t\tdma_desc->dma_addr);\n\t\t\tavaildepth--;\n\t\t}\n\n\t\tsnd_pcm_period_elapsed(substream);\n\n\t\t \n\t\tregmap_update_bits(regmap_i2s, I2S_TX_IRQ_CTL,\n\t\t\t\t   I2S_TX_INTR_MASK, 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm63xx_soc_pcm_new(struct snd_soc_component *component,\n\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct bcm_i2s_priv *i2s_priv;\n\tint ret;\n\n\ti2s_priv = dev_get_drvdata(asoc_rtd_to_cpu(rtd, 0)->dev);\n\n\tof_dma_configure(pcm->card->dev, pcm->card->dev->of_node, 1);\n\n\tret = dma_coerce_mask_and_coherent(pcm->card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)\n\t\ti2s_priv->play_substream =\n\t\t\tpcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\tif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)\n\t\ti2s_priv->capture_substream =\n\t\t\tpcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC,\n\t\t\t\t\t    pcm->card->dev,\n\t\t\t\t\t    bcm63xx_pcm_hardware.buffer_bytes_max);\n}\n\nstatic const struct snd_soc_component_driver bcm63xx_soc_platform = {\n\t.open = bcm63xx_pcm_open,\n\t.close = bcm63xx_pcm_close,\n\t.hw_params = bcm63xx_pcm_hw_params,\n\t.hw_free = bcm63xx_pcm_hw_free,\n\t.prepare = bcm63xx_pcm_prepare,\n\t.trigger = bcm63xx_pcm_trigger,\n\t.pointer = bcm63xx_pcm_pointer,\n\t.pcm_construct = bcm63xx_soc_pcm_new,\n};\n\nint bcm63xx_soc_platform_probe(struct platform_device *pdev,\n\t\t\t       struct bcm_i2s_priv *i2s_priv)\n{\n\tint ret;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(&pdev->dev, ret, i2s_dma_isr,\n\t\t\t       irq_get_trigger_type(ret), \"i2s_dma\", (void *)i2s_priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"i2s_init: failed to request interrupt.ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t&bcm63xx_soc_platform, NULL, 0);\n}\n\nint bcm63xx_soc_platform_remove(struct platform_device *pdev)\n{\n\treturn 0;\n}\n\nMODULE_AUTHOR(\"Kevin,Li <kevin-ke.li@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom DSL XPON ASOC PCM Interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}