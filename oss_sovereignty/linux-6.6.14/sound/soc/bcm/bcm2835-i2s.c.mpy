{
  "module_name": "bcm2835-i2s.c",
  "hash_id": "6aec620b8e078b264542c29cd6aeb864c5fcab40ce429f901936b7a0f7f9fe09",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/bcm/bcm2835-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n \n#define BCM2835_I2S_CS_A_REG\t\t0x00\n#define BCM2835_I2S_FIFO_A_REG\t\t0x04\n#define BCM2835_I2S_MODE_A_REG\t\t0x08\n#define BCM2835_I2S_RXC_A_REG\t\t0x0c\n#define BCM2835_I2S_TXC_A_REG\t\t0x10\n#define BCM2835_I2S_DREQ_A_REG\t\t0x14\n#define BCM2835_I2S_INTEN_A_REG\t0x18\n#define BCM2835_I2S_INTSTC_A_REG\t0x1c\n#define BCM2835_I2S_GRAY_REG\t\t0x20\n\n \n#define BCM2835_I2S_STBY\t\tBIT(25)\n#define BCM2835_I2S_SYNC\t\tBIT(24)\n#define BCM2835_I2S_RXSEX\t\tBIT(23)\n#define BCM2835_I2S_RXF\t\tBIT(22)\n#define BCM2835_I2S_TXE\t\tBIT(21)\n#define BCM2835_I2S_RXD\t\tBIT(20)\n#define BCM2835_I2S_TXD\t\tBIT(19)\n#define BCM2835_I2S_RXR\t\tBIT(18)\n#define BCM2835_I2S_TXW\t\tBIT(17)\n#define BCM2835_I2S_CS_RXERR\t\tBIT(16)\n#define BCM2835_I2S_CS_TXERR\t\tBIT(15)\n#define BCM2835_I2S_RXSYNC\t\tBIT(14)\n#define BCM2835_I2S_TXSYNC\t\tBIT(13)\n#define BCM2835_I2S_DMAEN\t\tBIT(9)\n#define BCM2835_I2S_RXTHR(v)\t\t((v) << 7)\n#define BCM2835_I2S_TXTHR(v)\t\t((v) << 5)\n#define BCM2835_I2S_RXCLR\t\tBIT(4)\n#define BCM2835_I2S_TXCLR\t\tBIT(3)\n#define BCM2835_I2S_TXON\t\tBIT(2)\n#define BCM2835_I2S_RXON\t\tBIT(1)\n#define BCM2835_I2S_EN\t\t\t(1)\n\n#define BCM2835_I2S_CLKDIS\t\tBIT(28)\n#define BCM2835_I2S_PDMN\t\tBIT(27)\n#define BCM2835_I2S_PDME\t\tBIT(26)\n#define BCM2835_I2S_FRXP\t\tBIT(25)\n#define BCM2835_I2S_FTXP\t\tBIT(24)\n#define BCM2835_I2S_CLKM\t\tBIT(23)\n#define BCM2835_I2S_CLKI\t\tBIT(22)\n#define BCM2835_I2S_FSM\t\tBIT(21)\n#define BCM2835_I2S_FSI\t\tBIT(20)\n#define BCM2835_I2S_FLEN(v)\t\t((v) << 10)\n#define BCM2835_I2S_FSLEN(v)\t\t(v)\n\n#define BCM2835_I2S_CHWEX\t\tBIT(15)\n#define BCM2835_I2S_CHEN\t\tBIT(14)\n#define BCM2835_I2S_CHPOS(v)\t\t((v) << 4)\n#define BCM2835_I2S_CHWID(v)\t\t(v)\n#define BCM2835_I2S_CH1(v)\t\t((v) << 16)\n#define BCM2835_I2S_CH2(v)\t\t(v)\n#define BCM2835_I2S_CH1_POS(v)\t\tBCM2835_I2S_CH1(BCM2835_I2S_CHPOS(v))\n#define BCM2835_I2S_CH2_POS(v)\t\tBCM2835_I2S_CH2(BCM2835_I2S_CHPOS(v))\n\n#define BCM2835_I2S_TX_PANIC(v)\t((v) << 24)\n#define BCM2835_I2S_RX_PANIC(v)\t((v) << 16)\n#define BCM2835_I2S_TX(v)\t\t((v) << 8)\n#define BCM2835_I2S_RX(v)\t\t(v)\n\n#define BCM2835_I2S_INT_RXERR\t\tBIT(3)\n#define BCM2835_I2S_INT_TXERR\t\tBIT(2)\n#define BCM2835_I2S_INT_RXR\t\tBIT(1)\n#define BCM2835_I2S_INT_TXW\t\tBIT(0)\n\n \n#define BCM2835_I2S_MAX_FRAME_LENGTH\t1024\n\n \nstruct bcm2835_i2s_dev {\n\tstruct device\t\t\t\t*dev;\n\tstruct snd_dmaengine_dai_dma_data\tdma_data[2];\n\tunsigned int\t\t\t\tfmt;\n\tunsigned int\t\t\t\ttdm_slots;\n\tunsigned int\t\t\t\trx_mask;\n\tunsigned int\t\t\t\ttx_mask;\n\tunsigned int\t\t\t\tslot_width;\n\tunsigned int\t\t\t\tframe_length;\n\n\tstruct regmap\t\t\t\t*i2s_regmap;\n\tstruct clk\t\t\t\t*clk;\n\tbool\t\t\t\t\tclk_prepared;\n\tint\t\t\t\t\tclk_rate;\n};\n\nstatic void bcm2835_i2s_start_clock(struct bcm2835_i2s_dev *dev)\n{\n\tunsigned int provider = dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\n\tif (dev->clk_prepared)\n\t\treturn;\n\n\tswitch (provider) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\tclk_prepare_enable(dev->clk);\n\t\tdev->clk_prepared = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void bcm2835_i2s_stop_clock(struct bcm2835_i2s_dev *dev)\n{\n\tif (dev->clk_prepared)\n\t\tclk_disable_unprepare(dev->clk);\n\tdev->clk_prepared = false;\n}\n\nstatic void bcm2835_i2s_clear_fifos(struct bcm2835_i2s_dev *dev,\n\t\t\t\t    bool tx, bool rx)\n{\n\tint timeout = 1000;\n\tuint32_t syncval;\n\tuint32_t csreg;\n\tuint32_t i2s_active_state;\n\tbool clk_was_prepared;\n\tuint32_t off;\n\tuint32_t clr;\n\n\toff =  tx ? BCM2835_I2S_TXON : 0;\n\toff |= rx ? BCM2835_I2S_RXON : 0;\n\n\tclr =  tx ? BCM2835_I2S_TXCLR : 0;\n\tclr |= rx ? BCM2835_I2S_RXCLR : 0;\n\n\t \n\tregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\n\ti2s_active_state = csreg & (BCM2835_I2S_RXON | BCM2835_I2S_TXON);\n\n\t \n\tclk_was_prepared = dev->clk_prepared;\n\tif (!clk_was_prepared)\n\t\tbcm2835_i2s_start_clock(dev);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, off, 0);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, clr, clr);\n\n\t \n\n\t \n\tregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &syncval);\n\tsyncval &= BCM2835_I2S_SYNC;\n\n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_SYNC, ~syncval);\n\n\t \n\twhile (--timeout) {\n\t\tregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\n\t\tif ((csreg & BCM2835_I2S_SYNC) != syncval)\n\t\t\tbreak;\n\t}\n\n\tif (!timeout)\n\t\tdev_err(dev->dev, \"I2S SYNC error!\\n\");\n\n\t \n\tif (!clk_was_prepared)\n\t\tbcm2835_i2s_stop_clock(dev);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_RXON | BCM2835_I2S_TXON, i2s_active_state);\n}\n\nstatic int bcm2835_i2s_set_dai_fmt(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int fmt)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tdev->fmt = fmt;\n\treturn 0;\n}\n\nstatic int bcm2835_i2s_set_dai_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int ratio)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tif (!ratio) {\n\t\tdev->tdm_slots = 0;\n\t\treturn 0;\n\t}\n\n\tif (ratio > BCM2835_I2S_MAX_FRAME_LENGTH)\n\t\treturn -EINVAL;\n\n\tdev->tdm_slots = 2;\n\tdev->rx_mask = 0x03;\n\tdev->tx_mask = 0x03;\n\tdev->slot_width = ratio / 2;\n\tdev->frame_length = ratio;\n\n\treturn 0;\n}\n\nstatic int bcm2835_i2s_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask,\n\tint slots, int width)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tif (slots) {\n\t\tif (slots < 0 || width < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trx_mask &= GENMASK(slots - 1, 0);\n\t\ttx_mask &= GENMASK(slots - 1, 0);\n\n\t\t \n\t\tif (hweight_long((unsigned long) rx_mask) != 2\n\t\t    || hweight_long((unsigned long) tx_mask) != 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (slots * width > BCM2835_I2S_MAX_FRAME_LENGTH)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->tdm_slots = slots;\n\n\tdev->rx_mask = rx_mask;\n\tdev->tx_mask = tx_mask;\n\tdev->slot_width = width;\n\tdev->frame_length = slots * width;\n\n\treturn 0;\n}\n\n \nstatic int bcm2835_i2s_convert_slot(unsigned int slot, unsigned int odd_offset)\n{\n\tif (!odd_offset)\n\t\treturn slot;\n\n\tif (slot & 1)\n\t\treturn (slot >> 1) + odd_offset;\n\n\treturn slot >> 1;\n}\n\n \nstatic void bcm2835_i2s_calc_channel_pos(\n\tunsigned int *ch1_pos, unsigned int *ch2_pos,\n\tunsigned int mask, unsigned int width,\n\tunsigned int bit_offset, unsigned int odd_offset)\n{\n\t*ch1_pos = bcm2835_i2s_convert_slot((ffs(mask) - 1), odd_offset)\n\t\t\t* width + bit_offset;\n\t*ch2_pos = bcm2835_i2s_convert_slot((fls(mask) - 1), odd_offset)\n\t\t\t* width + bit_offset;\n}\n\nstatic int bcm2835_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tunsigned int data_length, data_delay, framesync_length;\n\tunsigned int slots, slot_width, odd_slot_offset;\n\tint frame_length, bclk_rate;\n\tunsigned int rx_mask, tx_mask;\n\tunsigned int rx_ch1_pos, rx_ch2_pos, tx_ch1_pos, tx_ch2_pos;\n\tunsigned int mode, format;\n\tbool bit_clock_provider = false;\n\tbool frame_sync_provider = false;\n\tbool frame_start_falling_edge = false;\n\tuint32_t csreg;\n\tint ret = 0;\n\n\t \n\tregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\n\n\tif (csreg & (BCM2835_I2S_TXON | BCM2835_I2S_RXON))\n\t\treturn 0;\n\n\tdata_length = params_width(params);\n\tdata_delay = 0;\n\todd_slot_offset = 0;\n\tmode = 0;\n\n\tif (dev->tdm_slots) {\n\t\tslots = dev->tdm_slots;\n\t\tslot_width = dev->slot_width;\n\t\tframe_length = dev->frame_length;\n\t\trx_mask = dev->rx_mask;\n\t\ttx_mask = dev->tx_mask;\n\t\tbclk_rate = dev->frame_length * params_rate(params);\n\t} else {\n\t\tslots = 2;\n\t\tslot_width = params_width(params);\n\t\trx_mask = 0x03;\n\t\ttx_mask = 0x03;\n\n\t\tframe_length = snd_soc_params_to_frame_size(params);\n\t\tif (frame_length < 0)\n\t\t\treturn frame_length;\n\n\t\tbclk_rate = snd_soc_params_to_bclk(params);\n\t\tif (bclk_rate < 0)\n\t\t\treturn bclk_rate;\n\t}\n\n\t \n\tif (data_length > slot_width)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\tbit_clock_provider = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbit_clock_provider = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tframe_sync_provider = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tframe_sync_provider = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bit_clock_provider &&\n\t    (!dev->clk_prepared || dev->clk_rate != bclk_rate)) {\n\t\tif (dev->clk_prepared)\n\t\t\tbcm2835_i2s_stop_clock(dev);\n\n\t\tif (dev->clk_rate != bclk_rate) {\n\t\t\tret = clk_set_rate(dev->clk, bclk_rate);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdev->clk_rate = bclk_rate;\n\t\t}\n\n\t\tbcm2835_i2s_start_clock(dev);\n\t}\n\n\t \n\tformat = BCM2835_I2S_CHEN;\n\n\tif (data_length >= 24)\n\t\tformat |= BCM2835_I2S_CHWEX;\n\n\tformat |= BCM2835_I2S_CHWID((data_length-8)&0xf);\n\n\t \n\tformat = BCM2835_I2S_CH1(format) | BCM2835_I2S_CH2(format);\n\n\tswitch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tif (slots & 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\todd_slot_offset = slots >> 1;\n\n\t\t \n\t\tdata_delay = 1;\n\n\t\t \n\t\tframesync_length = frame_length / 2;\n\t\tframe_start_falling_edge = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tif (slots & 1)\n\t\t\treturn -EINVAL;\n\n\t\todd_slot_offset = slots >> 1;\n\t\tdata_delay = 0;\n\t\tframesync_length = frame_length / 2;\n\t\tframe_start_falling_edge = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tif (slots & 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (frame_length & 1)\n\t\t\treturn -EINVAL;\n\n\t\todd_slot_offset = slots >> 1;\n\t\tdata_delay = slot_width - data_length;\n\t\tframesync_length = frame_length / 2;\n\t\tframe_start_falling_edge = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tdata_delay = 1;\n\t\tframesync_length = 1;\n\t\tframe_start_falling_edge = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tdata_delay = 0;\n\t\tframesync_length = 1;\n\t\tframe_start_falling_edge = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbcm2835_i2s_calc_channel_pos(&rx_ch1_pos, &rx_ch2_pos,\n\t\trx_mask, slot_width, data_delay, odd_slot_offset);\n\tbcm2835_i2s_calc_channel_pos(&tx_ch1_pos, &tx_ch2_pos,\n\t\ttx_mask, slot_width, data_delay, odd_slot_offset);\n\n\t \n\tif ((!rx_ch1_pos || !tx_ch1_pos) && !frame_sync_provider)\n\t\tdev_warn(dev->dev,\n\t\t\t\"Unstable consumer config detected, L/R may be swapped\");\n\n\t \n\tregmap_write(dev->i2s_regmap, BCM2835_I2S_RXC_A_REG, \n\t\t  format\n\t\t| BCM2835_I2S_CH1_POS(rx_ch1_pos)\n\t\t| BCM2835_I2S_CH2_POS(rx_ch2_pos));\n\tregmap_write(dev->i2s_regmap, BCM2835_I2S_TXC_A_REG, \n\t\t  format\n\t\t| BCM2835_I2S_CH1_POS(tx_ch1_pos)\n\t\t| BCM2835_I2S_CH2_POS(tx_ch2_pos));\n\n\t \n\n\tif (data_length <= 16) {\n\t\t \n\t\tmode |= BCM2835_I2S_FTXP | BCM2835_I2S_FRXP;\n\t}\n\n\tmode |= BCM2835_I2S_FLEN(frame_length - 1);\n\tmode |= BCM2835_I2S_FSLEN(framesync_length);\n\n\t \n\tif (!bit_clock_provider)\n\t\tmode |= BCM2835_I2S_CLKM;\n\n\t \n\tif (!frame_sync_provider)\n\t\tmode |= BCM2835_I2S_FSM;\n\n\t \n        switch (dev->fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tmode |= BCM2835_I2S_CLKI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (dev->fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tif (frame_start_falling_edge)\n\t\t\tmode |= BCM2835_I2S_FSI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tif (!frame_start_falling_edge)\n\t\t\tmode |= BCM2835_I2S_FSI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(dev->i2s_regmap, BCM2835_I2S_MODE_A_REG, mode);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_RXTHR(1)\n\t\t\t| BCM2835_I2S_TXTHR(1)\n\t\t\t| BCM2835_I2S_DMAEN, 0xffffffff);\n\n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_DREQ_A_REG,\n\t\t\t  BCM2835_I2S_TX_PANIC(0x10)\n\t\t\t| BCM2835_I2S_RX_PANIC(0x30)\n\t\t\t| BCM2835_I2S_TX(0x30)\n\t\t\t| BCM2835_I2S_RX(0x20), 0xffffffff);\n\n\t \n\tbcm2835_i2s_clear_fifos(dev, true, true);\n\n\tdev_dbg(dev->dev,\n\t\t\"slots: %d width: %d rx mask: 0x%02x tx_mask: 0x%02x\\n\",\n\t\tslots, slot_width, rx_mask, tx_mask);\n\n\tdev_dbg(dev->dev, \"frame len: %d sync len: %d data len: %d\\n\",\n\t\tframe_length, framesync_length, data_length);\n\n\tdev_dbg(dev->dev, \"rx pos: %d,%d tx pos: %d,%d\\n\",\n\t\trx_ch1_pos, rx_ch2_pos, tx_ch1_pos, tx_ch2_pos);\n\n\tdev_dbg(dev->dev, \"sampling rate: %d bclk rate: %d\\n\",\n\t\tparams_rate(params), bclk_rate);\n\n\tdev_dbg(dev->dev, \"CLKM: %d CLKI: %d FSM: %d FSI: %d frame start: %s edge\\n\",\n\t\t!!(mode & BCM2835_I2S_CLKM),\n\t\t!!(mode & BCM2835_I2S_CLKI),\n\t\t!!(mode & BCM2835_I2S_FSM),\n\t\t!!(mode & BCM2835_I2S_FSI),\n\t\t(mode & BCM2835_I2S_FSI) ? \"falling\" : \"rising\");\n\n\treturn ret;\n}\n\nstatic int bcm2835_i2s_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tuint32_t cs_reg;\n\n\t \n\tregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &cs_reg);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK\n\t\t\t&& !(cs_reg & BCM2835_I2S_TXE))\n\t\tbcm2835_i2s_clear_fifos(dev, true, false);\n\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE\n\t\t\t&& (cs_reg & BCM2835_I2S_RXD))\n\t\tbcm2835_i2s_clear_fifos(dev, false, true);\n\n\treturn 0;\n}\n\nstatic void bcm2835_i2s_stop(struct bcm2835_i2s_dev *dev,\n\t\tstruct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tuint32_t mask;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tmask = BCM2835_I2S_RXON;\n\telse\n\t\tmask = BCM2835_I2S_TXON;\n\n\tregmap_update_bits(dev->i2s_regmap,\n\t\t\tBCM2835_I2S_CS_A_REG, mask, 0);\n\n\t \n\tif (!snd_soc_dai_active(dai) && !(dev->fmt & SND_SOC_DAIFMT_CONT))\n\t\tbcm2835_i2s_stop_clock(dev);\n}\n\nstatic int bcm2835_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tuint32_t mask;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tbcm2835_i2s_start_clock(dev);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tmask = BCM2835_I2S_RXON;\n\t\telse\n\t\t\tmask = BCM2835_I2S_TXON;\n\n\t\tregmap_update_bits(dev->i2s_regmap,\n\t\t\t\tBCM2835_I2S_CS_A_REG, mask, mask);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbcm2835_i2s_stop(dev, substream, dai);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm2835_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tif (snd_soc_dai_active(dai))\n\t\treturn 0;\n\n\t \n\tbcm2835_i2s_stop_clock(dev);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_EN, BCM2835_I2S_EN);\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_STBY, BCM2835_I2S_STBY);\n\n\treturn 0;\n}\n\nstatic void bcm2835_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tbcm2835_i2s_stop(dev, substream, dai);\n\n\t \n\tif (snd_soc_dai_active(dai))\n\t\treturn;\n\n\t \n\tregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\n\t\t\tBCM2835_I2S_EN, 0);\n\n\t \n\tbcm2835_i2s_stop_clock(dev);\n}\n\nstatic int bcm2835_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai,\n\t\t\t\t  &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t  &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops bcm2835_i2s_dai_ops = {\n\t.probe\t\t= bcm2835_i2s_dai_probe,\n\t.startup\t= bcm2835_i2s_startup,\n\t.shutdown\t= bcm2835_i2s_shutdown,\n\t.prepare\t= bcm2835_i2s_prepare,\n\t.trigger\t= bcm2835_i2s_trigger,\n\t.hw_params\t= bcm2835_i2s_hw_params,\n\t.set_fmt\t= bcm2835_i2s_set_dai_fmt,\n\t.set_bclk_ratio\t= bcm2835_i2s_set_dai_bclk_ratio,\n\t.set_tdm_slot\t= bcm2835_i2s_set_dai_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver bcm2835_i2s_dai = {\n\t.name\t= \"bcm2835-i2s\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates =\tSNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min =\t8000,\n\t\t.rate_max =\t384000,\n\t\t.formats =\tSNDRV_PCM_FMTBIT_S16_LE\n\t\t\t\t| SNDRV_PCM_FMTBIT_S24_LE\n\t\t\t\t| SNDRV_PCM_FMTBIT_S32_LE\n\t\t},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates =\tSNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min =\t8000,\n\t\t.rate_max =\t384000,\n\t\t.formats =\tSNDRV_PCM_FMTBIT_S16_LE\n\t\t\t\t| SNDRV_PCM_FMTBIT_S24_LE\n\t\t\t\t| SNDRV_PCM_FMTBIT_S32_LE\n\t\t},\n\t.ops = &bcm2835_i2s_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n};\n\nstatic bool bcm2835_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BCM2835_I2S_CS_A_REG:\n\tcase BCM2835_I2S_FIFO_A_REG:\n\tcase BCM2835_I2S_INTSTC_A_REG:\n\tcase BCM2835_I2S_GRAY_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool bcm2835_i2s_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BCM2835_I2S_FIFO_A_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config bcm2835_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = BCM2835_I2S_GRAY_REG,\n\t.precious_reg = bcm2835_i2s_precious_reg,\n\t.volatile_reg = bcm2835_i2s_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct snd_soc_component_driver bcm2835_i2s_component = {\n\t.name\t\t\t= \"bcm2835-i2s-comp\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int bcm2835_i2s_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_i2s_dev *dev;\n\tint ret;\n\tvoid __iomem *base;\n\tconst __be32 *addr;\n\tdma_addr_t dma_base;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev),\n\t\t\t   GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->clk_prepared = false;\n\tdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dev->clk),\n\t\t\t\t     \"could not get clk\\n\");\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdev->i2s_regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t&bcm2835_regmap_config);\n\tif (IS_ERR(dev->i2s_regmap))\n\t\treturn PTR_ERR(dev->i2s_regmap);\n\n\t \n\taddr = of_get_address(pdev->dev.of_node, 0, NULL, NULL);\n\tif (!addr) {\n\t\tdev_err(&pdev->dev, \"could not get DMA-register address\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdma_base = be32_to_cpup(addr);\n\n\tdev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr =\n\t\tdma_base + BCM2835_I2S_FIFO_A_REG;\n\n\tdev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr =\n\t\tdma_base + BCM2835_I2S_FIFO_A_REG;\n\n\t \n\tdev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\t \n\tdev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 2;\n\tdev->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 2;\n\n\t \n\tdev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].flags =\n\t\tSND_DMAENGINE_PCM_DAI_FLAG_PACK;\n\tdev->dma_data[SNDRV_PCM_STREAM_CAPTURE].flags =\n\t\tSND_DMAENGINE_PCM_DAI_FLAG_PACK;\n\n\t \n\tdev->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, dev);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&bcm2835_i2s_component, &bcm2835_i2s_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register PCM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm2835_i2s_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-i2s\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, bcm2835_i2s_of_match);\n\nstatic struct platform_driver bcm2835_i2s_driver = {\n\t.probe\t\t= bcm2835_i2s_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"bcm2835-i2s\",\n\t\t.of_match_table = bcm2835_i2s_of_match,\n\t},\n};\n\nmodule_platform_driver(bcm2835_i2s_driver);\n\nMODULE_ALIAS(\"platform:bcm2835-i2s\");\nMODULE_DESCRIPTION(\"BCM2835 I2S interface\");\nMODULE_AUTHOR(\"Florian Meier <florian.meier@koalo.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}