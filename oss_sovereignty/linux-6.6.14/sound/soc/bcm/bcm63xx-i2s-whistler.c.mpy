{
  "module_name": "bcm63xx-i2s-whistler.c",
  "hash_id": "692182a79818b5f8a6c6d19c8b7816220f4c7329a1429b1f38885af4913968e4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/bcm/bcm63xx-i2s-whistler.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"bcm63xx-i2s.h\"\n\n#define DRV_NAME \"brcm-i2s\"\n\nstatic bool brcm_i2s_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TX_CFG ... I2S_TX_DESC_IFF_LEN:\n\tcase I2S_TX_CFG_2 ... I2S_RX_DESC_IFF_LEN:\n\tcase I2S_RX_CFG_2 ... I2S_REG_MAX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool brcm_i2s_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TX_CFG ... I2S_REG_MAX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool brcm_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TX_CFG:\n\tcase I2S_TX_IRQ_CTL:\n\tcase I2S_TX_DESC_IFF_ADDR:\n\tcase I2S_TX_DESC_IFF_LEN:\n\tcase I2S_TX_DESC_OFF_ADDR:\n\tcase I2S_TX_DESC_OFF_LEN:\n\tcase I2S_TX_CFG_2:\n\tcase I2S_RX_CFG:\n\tcase I2S_RX_IRQ_CTL:\n\tcase I2S_RX_DESC_OFF_ADDR:\n\tcase I2S_RX_DESC_OFF_LEN:\n\tcase I2S_RX_DESC_IFF_LEN:\n\tcase I2S_RX_DESC_IFF_ADDR:\n\tcase I2S_RX_CFG_2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config brcm_i2s_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = I2S_REG_MAX,\n\t.writeable_reg = brcm_i2s_wr_reg,\n\t.readable_reg = brcm_i2s_rd_reg,\n\t.volatile_reg = brcm_i2s_volatile_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int bcm63xx_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\tstruct bcm_i2s_priv *i2s_priv = snd_soc_dai_get_drvdata(dai);\n\n\tret = clk_set_rate(i2s_priv->i2s_clk, params_rate(params));\n\tif (ret < 0)\n\t\tdev_err(i2s_priv->dev,\n\t\t\t\"Can't set sample rate, err: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int bcm63xx_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tunsigned int slavemode;\n\tstruct bcm_i2s_priv *i2s_priv = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *regmap_i2s = i2s_priv->regmap_i2s;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG,\n\t\t\t\t   I2S_TX_OUT_R | I2S_TX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_TX_DATA_ENABLE | I2S_TX_CLOCK_ENABLE,\n\t\t\t\t   I2S_TX_OUT_R | I2S_TX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_TX_DATA_ENABLE | I2S_TX_CLOCK_ENABLE);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_CTL, 0);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_IFF_THLD, 0);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_OFF_THLD, 1);\n\n\t\t \n\t\tregmap_read(regmap_i2s, I2S_RX_CFG_2, &slavemode);\n\t\tif (slavemode & I2S_RX_SLAVE_MODE_MASK)\n\t\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG_2,\n\t\t\t\t\t   I2S_TX_SLAVE_MODE_MASK,\n\t\t\t\t\t   I2S_TX_MASTER_MODE);\n\t\telse\n\t\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG_2,\n\t\t\t\t\t   I2S_TX_SLAVE_MODE_MASK,\n\t\t\t\t\t   I2S_TX_SLAVE_MODE);\n\t} else {\n\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG,\n\t\t\t\t   I2S_RX_IN_R | I2S_RX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_RX_CLOCK_ENABLE,\n\t\t\t\t   I2S_RX_IN_R | I2S_RX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_RX_CLOCK_ENABLE);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_CTL, 0);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_IFF_THLD, 0);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_OFF_THLD, 1);\n\n\t\tregmap_read(regmap_i2s, I2S_TX_CFG_2, &slavemode);\n\t\tif (slavemode & I2S_TX_SLAVE_MODE_MASK)\n\t\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG_2,\n\t\t\t\t\t   I2S_RX_SLAVE_MODE_MASK, 0);\n\t\telse\n\t\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG_2,\n\t\t\t\t\t   I2S_RX_SLAVE_MODE_MASK,\n\t\t\t\t\t   I2S_RX_SLAVE_MODE);\n\t}\n\treturn 0;\n}\n\nstatic void bcm63xx_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tunsigned int enabled, slavemode;\n\tstruct bcm_i2s_priv *i2s_priv = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *regmap_i2s = i2s_priv->regmap_i2s;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG,\n\t\t\t\t   I2S_TX_OUT_R | I2S_TX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_TX_DATA_ENABLE | I2S_TX_CLOCK_ENABLE, 0);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_CTL, 1);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_IFF_THLD, 4);\n\t\tregmap_write(regmap_i2s, I2S_TX_IRQ_OFF_THLD, 4);\n\n\t\tregmap_read(regmap_i2s, I2S_TX_CFG_2, &slavemode);\n\t\tslavemode = slavemode & I2S_TX_SLAVE_MODE_MASK;\n\t\tif (!slavemode) {\n\t\t\tregmap_read(regmap_i2s, I2S_RX_CFG, &enabled);\n\t\t\tenabled = enabled & I2S_RX_ENABLE_MASK;\n\t\t\tif (enabled)\n\t\t\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG_2,\n\t\t\t\t\t\t   I2S_RX_SLAVE_MODE_MASK,\n\t\t\t\t\t\t   I2S_RX_MASTER_MODE);\n\t\t}\n\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG_2,\n\t\t\t\t   I2S_TX_SLAVE_MODE_MASK,\n\t\t\t\t   I2S_TX_SLAVE_MODE);\n\t} else {\n\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG,\n\t\t\t\t   I2S_RX_IN_R | I2S_RX_DATA_ALIGNMENT |\n\t\t\t\t   I2S_RX_CLOCK_ENABLE, 0);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_CTL, 1);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_IFF_THLD, 4);\n\t\tregmap_write(regmap_i2s, I2S_RX_IRQ_OFF_THLD, 4);\n\n\t\tregmap_read(regmap_i2s, I2S_RX_CFG_2, &slavemode);\n\t\tslavemode = slavemode & I2S_RX_SLAVE_MODE_MASK;\n\t\tif (!slavemode) {\n\t\t\tregmap_read(regmap_i2s, I2S_TX_CFG, &enabled);\n\t\t\tenabled = enabled & I2S_TX_ENABLE_MASK;\n\t\t\tif (enabled)\n\t\t\t\tregmap_update_bits(regmap_i2s, I2S_TX_CFG_2,\n\t\t\t\t\t\t   I2S_TX_SLAVE_MODE_MASK,\n\t\t\t\t\t\t   I2S_TX_MASTER_MODE);\n\t\t}\n\n\t\tregmap_update_bits(regmap_i2s, I2S_RX_CFG_2,\n\t\t\t\t   I2S_RX_SLAVE_MODE_MASK, I2S_RX_SLAVE_MODE);\n\t}\n}\n\nstatic const struct snd_soc_dai_ops bcm63xx_i2s_dai_ops = {\n\t.startup = bcm63xx_i2s_startup,\n\t.shutdown = bcm63xx_i2s_shutdown,\n\t.hw_params = bcm63xx_i2s_hw_params,\n};\n\nstatic struct snd_soc_dai_driver bcm63xx_i2s_dai = {\n\t.name = DRV_NAME,\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.ops = &bcm63xx_i2s_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_channels = 1,\n};\n\nstatic const struct snd_soc_component_driver bcm63xx_i2s_component = {\n\t.name = \"bcm63xx\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic int bcm63xx_i2s_dev_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tvoid __iomem *regs;\n\tstruct bcm_i2s_priv *i2s_priv;\n\tstruct regmap *regmap_i2s;\n\tstruct clk *i2s_clk;\n\n\ti2s_priv = devm_kzalloc(&pdev->dev, sizeof(*i2s_priv), GFP_KERNEL);\n\tif (!i2s_priv)\n\t\treturn -ENOMEM;\n\n\ti2s_clk = devm_clk_get(&pdev->dev, \"i2sclk\");\n\tif (IS_ERR(i2s_clk)) {\n\t\tdev_err(&pdev->dev, \"%s: cannot get a brcm clock: %ld\\n\",\n\t\t\t\t\t__func__, PTR_ERR(i2s_clk));\n\t\treturn PTR_ERR(i2s_clk);\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\treturn ret;\n\t}\n\n\tregmap_i2s = devm_regmap_init_mmio(&pdev->dev,\n\t\t\t\t\tregs, &brcm_i2s_regmap_config);\n\tif (IS_ERR(regmap_i2s))\n\t\treturn PTR_ERR(regmap_i2s);\n\n\tregmap_update_bits(regmap_i2s, I2S_MISC_CFG,\n\t\t\t   I2S_PAD_LVL_LOOP_DIS_MASK,\n\t\t\t   I2S_PAD_LVL_LOOP_DIS_ENABLE);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &bcm63xx_i2s_component,\n\t\t\t\t\t      &bcm63xx_i2s_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register the dai\\n\");\n\t\treturn ret;\n\t}\n\n\ti2s_priv->dev = &pdev->dev;\n\ti2s_priv->i2s_clk = i2s_clk;\n\ti2s_priv->regmap_i2s = regmap_i2s;\n\tdev_set_drvdata(&pdev->dev, i2s_priv);\n\n\tret = bcm63xx_soc_platform_probe(pdev, i2s_priv);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to register the pcm\\n\");\n\n\treturn ret;\n}\n\nstatic void bcm63xx_i2s_dev_remove(struct platform_device *pdev)\n{\n\tbcm63xx_soc_platform_remove(pdev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id snd_soc_bcm_audio_match[] = {\n\t{.compatible = \"brcm,bcm63xx-i2s\"},\n\t{ }\n};\n#endif\n\nstatic struct platform_driver bcm63xx_i2s_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(snd_soc_bcm_audio_match),\n\t},\n\t.probe = bcm63xx_i2s_dev_probe,\n\t.remove_new = bcm63xx_i2s_dev_remove,\n};\n\nmodule_platform_driver(bcm63xx_i2s_driver);\n\nMODULE_AUTHOR(\"Kevin,Li <kevin-ke.li@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom DSL XPON ASOC I2S Interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}