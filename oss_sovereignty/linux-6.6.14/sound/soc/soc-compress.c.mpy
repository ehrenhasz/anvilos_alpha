{
  "module_name": "soc-compress.c",
  "hash_id": "4ebb74848796f5a04ea8425090e08f67f5bb310b2f582b8df4dfd7f9b251b135",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-compress.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <sound/core.h>\n#include <sound/compress_params.h>\n#include <sound/compress_driver.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/soc-dpcm.h>\n#include <sound/soc-link.h>\n\nstatic int snd_soc_compr_components_open(struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint ret = 0;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tret = snd_soc_component_module_get_when_open(component, cstream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = snd_soc_component_compr_open(component, cstream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void snd_soc_compr_components_free(struct snd_compr_stream *cstream,\n\t\t\t\t\t  int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_component *component;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tsnd_soc_component_compr_free(component, cstream, rollback);\n\t\tsnd_soc_component_module_put_when_close(component, cstream, rollback);\n\t}\n}\n\nstatic int soc_compr_clean(struct snd_compr_stream *cstream, int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint stream = cstream->direction;  \n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tif (!rollback)\n\t\tsnd_soc_runtime_deactivate(rtd, stream);\n\n\tsnd_soc_dai_digital_mute(codec_dai, 1, stream);\n\n\tif (!snd_soc_dai_active(cpu_dai))\n\t\tcpu_dai->rate = 0;\n\n\tif (!snd_soc_dai_active(codec_dai))\n\t\tcodec_dai->rate = 0;\n\n\tsnd_soc_link_compr_shutdown(cstream, rollback);\n\n\tsnd_soc_compr_components_free(cstream, rollback);\n\n\tsnd_soc_dai_compr_shutdown(cpu_dai, cstream, rollback);\n\n\tif (!rollback)\n\t\tsnd_soc_dapm_stream_stop(rtd, stream);\n\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\n\tsnd_soc_pcm_component_pm_runtime_put(rtd, cstream, rollback);\n\n\treturn 0;\n}\n\nstatic int soc_compr_free(struct snd_compr_stream *cstream)\n{\n\treturn soc_compr_clean(cstream, 0);\n}\n\nstatic int soc_compr_open(struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tret = snd_soc_pcm_component_pm_runtime_get(rtd, cstream);\n\tif (ret < 0)\n\t\tgoto err_no_lock;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tret = snd_soc_dai_compr_startup(cpu_dai, cstream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_compr_components_open(cstream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_link_compr_startup(cstream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsnd_soc_runtime_activate(rtd, stream);\nerr:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\nerr_no_lock:\n\tif (ret < 0)\n\t\tsoc_compr_clean(cstream, 1);\n\n\treturn ret;\n}\n\nstatic int soc_compr_open_fe(struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *fe = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(fe, 0);\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct snd_soc_dapm_widget_list *list;\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tsnd_soc_card_mutex_lock(fe->card);\n\n\tret = dpcm_path_get(fe, stream, &list);\n\tif (ret < 0)\n\t\tgoto be_err;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\n\t \n\tdpcm_process_paths(fe, stream, &list, 1);\n\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\n\n\tret = dpcm_be_dai_startup(fe, stream);\n\tif (ret < 0) {\n\t\t \n\t\tfor_each_dpcm_be(fe, stream, dpcm)\n\t\t\tdpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\n\n\t\tdpcm_be_disconnect(fe, stream);\n\t\tgoto out;\n\t}\n\n\tret = snd_soc_dai_compr_startup(cpu_dai, cstream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_compr_components_open(cstream);\n\tif (ret < 0)\n\t\tgoto open_err;\n\n\tret = snd_soc_link_compr_startup(cstream);\n\tif (ret < 0)\n\t\tgoto machine_err;\n\n\tdpcm_clear_pending_state(fe, stream);\n\tdpcm_path_put(&list);\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\n\tsnd_soc_runtime_activate(fe, stream);\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\n\tsnd_soc_card_mutex_unlock(fe->card);\n\n\treturn 0;\n\nmachine_err:\n\tsnd_soc_compr_components_free(cstream, 1);\nopen_err:\n\tsnd_soc_dai_compr_shutdown(cpu_dai, cstream, 1);\nout:\n\tdpcm_path_put(&list);\n\tsnd_soc_dpcm_mutex_unlock(fe);\nbe_err:\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\tsnd_soc_card_mutex_unlock(fe->card);\n\treturn ret;\n}\n\nstatic int soc_compr_free_fe(struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *fe = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(fe, 0);\n\tstruct snd_soc_dpcm *dpcm;\n\tint stream = cstream->direction;  \n\n\tsnd_soc_card_mutex_lock(fe->card);\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tsnd_soc_runtime_deactivate(fe, stream);\n\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\n\n\tdpcm_be_dai_hw_free(fe, stream);\n\n\tdpcm_be_dai_shutdown(fe, stream);\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm)\n\t\tdpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\n\n\tdpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\n\tdpcm_be_disconnect(fe, stream);\n\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\n\tsnd_soc_link_compr_shutdown(cstream, 0);\n\n\tsnd_soc_compr_components_free(cstream, 0);\n\n\tsnd_soc_dai_compr_shutdown(cpu_dai, cstream, 0);\n\n\tsnd_soc_card_mutex_unlock(fe->card);\n\treturn 0;\n}\n\nstatic int soc_compr_trigger(struct snd_compr_stream *cstream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tret = snd_soc_component_compr_trigger(cstream, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_dai_compr_trigger(cpu_dai, cstream, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_soc_dai_digital_mute(codec_dai, 0, stream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_soc_dai_digital_mute(codec_dai, 1, stream);\n\t\tbreak;\n\t}\n\nout:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic int soc_compr_trigger_fe(struct snd_compr_stream *cstream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *fe = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(fe, 0);\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tif (cmd == SND_COMPR_TRIGGER_PARTIAL_DRAIN ||\n\t    cmd == SND_COMPR_TRIGGER_DRAIN)\n\t\treturn snd_soc_component_compr_trigger(cstream, cmd);\n\n\tsnd_soc_card_mutex_lock(fe->card);\n\n\tret = snd_soc_dai_compr_trigger(cpu_dai, cstream, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_component_compr_trigger(cstream, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\n\n\tret = dpcm_be_dai_trigger(fe, stream, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\n\t\tbreak;\n\t}\n\nout:\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\tsnd_soc_card_mutex_unlock(fe->card);\n\treturn ret;\n}\n\nstatic int soc_compr_set_params(struct snd_compr_stream *cstream,\n\t\t\t\tstruct snd_compr_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\t \n\tret = snd_soc_dai_compr_set_params(cpu_dai, cstream, params);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_component_compr_set_params(cstream, params);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_link_compr_set_params(cstream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsnd_soc_dapm_stream_event(rtd, stream, SND_SOC_DAPM_STREAM_START);\n\n\t \n\trtd->pop_wait = 0;\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\n\tcancel_delayed_work_sync(&rtd->delayed_work);\n\n\treturn 0;\n\nerr:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic int soc_compr_set_params_fe(struct snd_compr_stream *cstream,\n\t\t\t\t   struct snd_compr_params *params)\n{\n\tstruct snd_soc_pcm_runtime *fe = cstream->private_data;\n\tstruct snd_pcm_substream *fe_substream =\n\t\t fe->pcm->streams[cstream->direction].substream;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(fe, 0);\n\tint stream = cstream->direction;  \n\tint ret;\n\n\tsnd_soc_card_mutex_lock(fe->card);\n\n\t \n\tmemset(&fe->dpcm[fe_substream->stream].hw_params, 0,\n\t\tsizeof(struct snd_pcm_hw_params));\n\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\n\n\tret = dpcm_be_dai_hw_params(fe, stream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = dpcm_be_dai_prepare(fe, stream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_dai_compr_set_params(cpu_dai, cstream, params);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_component_compr_set_params(cstream, params);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_link_compr_set_params(cstream);\n\tif (ret < 0)\n\t\tgoto out;\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tdpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\n\nout:\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\tsnd_soc_card_mutex_unlock(fe->card);\n\treturn ret;\n}\n\nstatic int soc_compr_get_params(struct snd_compr_stream *cstream,\n\t\t\t\tstruct snd_codec *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tret = snd_soc_dai_compr_get_params(cpu_dai, cstream, params);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_component_compr_get_params(cstream, params);\nerr:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic int soc_compr_ack(struct snd_compr_stream *cstream, size_t bytes)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tret = snd_soc_dai_compr_ack(cpu_dai, cstream, bytes);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_component_compr_ack(cstream, bytes);\nerr:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic int soc_compr_pointer(struct snd_compr_stream *cstream,\n\t\t\t     struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tint ret;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tret = snd_soc_dai_compr_pointer(cpu_dai, cstream, tstamp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_component_compr_pointer(cstream, tstamp);\nout:\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic int soc_compr_set_metadata(struct snd_compr_stream *cstream,\n\t\t\t\t  struct snd_compr_metadata *metadata)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tret = snd_soc_dai_compr_set_metadata(cpu_dai, cstream, metadata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_component_compr_set_metadata(cstream, metadata);\n}\n\nstatic int soc_compr_get_metadata(struct snd_compr_stream *cstream,\n\t\t\t\t  struct snd_compr_metadata *metadata)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tret = snd_soc_dai_compr_get_metadata(cpu_dai, cstream, metadata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_component_compr_get_metadata(cstream, metadata);\n}\n\n \nstatic struct snd_compr_ops soc_compr_ops = {\n\t.open\t\t= soc_compr_open,\n\t.free\t\t= soc_compr_free,\n\t.set_params\t= soc_compr_set_params,\n\t.set_metadata   = soc_compr_set_metadata,\n\t.get_metadata\t= soc_compr_get_metadata,\n\t.get_params\t= soc_compr_get_params,\n\t.trigger\t= soc_compr_trigger,\n\t.pointer\t= soc_compr_pointer,\n\t.ack\t\t= soc_compr_ack,\n\t.get_caps\t= snd_soc_component_compr_get_caps,\n\t.get_codec_caps = snd_soc_component_compr_get_codec_caps,\n};\n\n \nstatic struct snd_compr_ops soc_compr_dyn_ops = {\n\t.open\t\t= soc_compr_open_fe,\n\t.free\t\t= soc_compr_free_fe,\n\t.set_params\t= soc_compr_set_params_fe,\n\t.get_params\t= soc_compr_get_params,\n\t.set_metadata   = soc_compr_set_metadata,\n\t.get_metadata\t= soc_compr_get_metadata,\n\t.trigger\t= soc_compr_trigger_fe,\n\t.pointer\t= soc_compr_pointer,\n\t.ack\t\t= soc_compr_ack,\n\t.get_caps\t= snd_soc_component_compr_get_caps,\n\t.get_codec_caps = snd_soc_component_compr_get_codec_caps,\n};\n\n \nint snd_soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_compr *compr;\n\tstruct snd_pcm *be_pcm;\n\tchar new_name[64];\n\tint ret = 0, direction = 0;\n\tint playback = 0, capture = 0;\n\tint i;\n\n\t \n\tBUILD_BUG_ON((int)SNDRV_PCM_STREAM_PLAYBACK != (int)SND_COMPRESS_PLAYBACK);\n\tBUILD_BUG_ON((int)SNDRV_PCM_STREAM_CAPTURE  != (int)SND_COMPRESS_CAPTURE);\n\n\tif (rtd->dai_link->num_cpus > 1 ||\n\t    rtd->dai_link->num_codecs > 1) {\n\t\tdev_err(rtd->card->dev,\n\t\t\t\"Compress ASoC: Multi CPU/Codec not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!codec_dai) {\n\t\tdev_err(rtd->card->dev, \"Missing codec\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (snd_soc_dai_stream_valid(codec_dai, SNDRV_PCM_STREAM_PLAYBACK) &&\n\t    snd_soc_dai_stream_valid(cpu_dai,   SNDRV_PCM_STREAM_PLAYBACK))\n\t\tplayback = 1;\n\tif (snd_soc_dai_stream_valid(codec_dai, SNDRV_PCM_STREAM_CAPTURE) &&\n\t    snd_soc_dai_stream_valid(cpu_dai,   SNDRV_PCM_STREAM_CAPTURE))\n\t\tcapture = 1;\n\n\t \n\tif (playback + capture != 1) {\n\t\tdev_err(rtd->card->dev,\n\t\t\t\"Compress ASoC: Invalid direction for P %d, C %d\\n\",\n\t\t\tplayback, capture);\n\t\treturn -EINVAL;\n\t}\n\n\tif (playback)\n\t\tdirection = SND_COMPRESS_PLAYBACK;\n\telse\n\t\tdirection = SND_COMPRESS_CAPTURE;\n\n\tcompr = devm_kzalloc(rtd->card->dev, sizeof(*compr), GFP_KERNEL);\n\tif (!compr)\n\t\treturn -ENOMEM;\n\n\tcompr->ops = devm_kzalloc(rtd->card->dev, sizeof(soc_compr_ops),\n\t\t\t\t  GFP_KERNEL);\n\tif (!compr->ops)\n\t\treturn -ENOMEM;\n\n\tif (rtd->dai_link->dynamic) {\n\t\tsnprintf(new_name, sizeof(new_name), \"(%s)\",\n\t\t\trtd->dai_link->stream_name);\n\n\t\tret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\n\t\t\t\trtd->dai_link->dpcm_playback,\n\t\t\t\trtd->dai_link->dpcm_capture, &be_pcm);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->card->dev,\n\t\t\t\t\"Compress ASoC: can't create compressed for %s: %d\\n\",\n\t\t\t\trtd->dai_link->name, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tbe_pcm->nonatomic = rtd->dai_link->nonatomic;\n\n\t\trtd->pcm = be_pcm;\n\t\trtd->fe_compr = 1;\n\t\tif (rtd->dai_link->dpcm_playback)\n\t\t\tbe_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;\n\t\tif (rtd->dai_link->dpcm_capture)\n\t\t\tbe_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;\n\t\tmemcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));\n\t} else {\n\t\tsnprintf(new_name, sizeof(new_name), \"%s %s-%d\",\n\t\t\trtd->dai_link->stream_name, codec_dai->name, num);\n\n\t\tmemcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));\n\t}\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (!component->driver->compress_ops ||\n\t\t    !component->driver->compress_ops->copy)\n\t\t\tcontinue;\n\n\t\tcompr->ops->copy = snd_soc_component_compr_copy;\n\t\tbreak;\n\t}\n\n\tret = snd_compress_new(rtd->card->snd_card, num, direction,\n\t\t\t\tnew_name, compr);\n\tif (ret < 0) {\n\t\tcomponent = asoc_rtd_to_codec(rtd, 0)->component;\n\t\tdev_err(component->dev,\n\t\t\t\"Compress ASoC: can't create compress for codec %s: %d\\n\",\n\t\t\tcomponent->name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\trtd->close_delayed_work_func = snd_soc_close_delayed_work;\n\n\trtd->compr = compr;\n\tcompr->private_data = rtd;\n\n\tdev_dbg(rtd->card->dev, \"Compress ASoC: %s <-> %s mapping ok\\n\",\n\t\tcodec_dai->name, cpu_dai->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_new_compress);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}