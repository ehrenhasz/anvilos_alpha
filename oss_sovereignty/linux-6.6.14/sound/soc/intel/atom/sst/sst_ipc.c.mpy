{
  "module_name": "sst_ipc.c",
  "hash_id": "75bad6712d382e0953eac1d002ae48c66c160f9cd9c1e974f314d762b322f0de",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_ipc.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/intel-mid.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\nstruct sst_block *sst_create_block(struct intel_sst_drv *ctx,\n\t\t\t\t\tu32 msg_id, u32 drv_id)\n{\n\tstruct sst_block *msg;\n\n\tdev_dbg(ctx->dev, \"Enter\\n\");\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\tmsg->condition = false;\n\tmsg->on = true;\n\tmsg->msg_id = msg_id;\n\tmsg->drv_id = drv_id;\n\tspin_lock_bh(&ctx->block_lock);\n\tlist_add_tail(&msg->node, &ctx->block_list);\n\tspin_unlock_bh(&ctx->block_lock);\n\n\treturn msg;\n}\n\n \nint sst_wake_up_block(struct intel_sst_drv *ctx, int result,\n\t\tu32 drv_id, u32 ipc, void *data, u32 size)\n{\n\tstruct sst_block *block;\n\n\tdev_dbg(ctx->dev, \"Enter\\n\");\n\n\tspin_lock_bh(&ctx->block_lock);\n\tlist_for_each_entry(block, &ctx->block_list, node) {\n\t\tdev_dbg(ctx->dev, \"Block ipc %d, drv_id %d\\n\", block->msg_id,\n\t\t\t\t\t\t\tblock->drv_id);\n\t\tif (block->msg_id == ipc && block->drv_id == drv_id) {\n\t\t\tdev_dbg(ctx->dev, \"free up the block\\n\");\n\t\t\tblock->ret_code = result;\n\t\t\tblock->data = data;\n\t\t\tblock->size = size;\n\t\t\tblock->condition = true;\n\t\t\tspin_unlock_bh(&ctx->block_lock);\n\t\t\twake_up(&ctx->wait_queue);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&ctx->block_lock);\n\tdev_dbg(ctx->dev,\n\t\t\"Block not found or a response received for a short msg for ipc %d, drv_id %d\\n\",\n\t\tipc, drv_id);\n\treturn -EINVAL;\n}\n\nint sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed)\n{\n\tstruct sst_block *block, *__block;\n\n\tdev_dbg(ctx->dev, \"Enter\\n\");\n\tspin_lock_bh(&ctx->block_lock);\n\tlist_for_each_entry_safe(block, __block, &ctx->block_list, node) {\n\t\tif (block == freed) {\n\t\t\tpr_debug(\"pvt_id freed --> %d\\n\", freed->drv_id);\n\t\t\t \n\t\t\tlist_del(&freed->node);\n\t\t\tspin_unlock_bh(&ctx->block_lock);\n\t\t\tkfree(freed->data);\n\t\t\tfreed->data = NULL;\n\t\t\tkfree(freed);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&ctx->block_lock);\n\tdev_err(ctx->dev, \"block is already freed!!!\\n\");\n\treturn -EINVAL;\n}\n\nint sst_post_message_mrfld(struct intel_sst_drv *sst_drv_ctx,\n\t\tstruct ipc_post *ipc_msg, bool sync)\n{\n\tstruct ipc_post *msg = ipc_msg;\n\tunion ipc_header_mrfld header;\n\tunsigned int loop_count = 0;\n\tint retval = 0;\n\tunsigned long irq_flags;\n\n\tdev_dbg(sst_drv_ctx->dev, \"Enter: sync: %d\\n\", sync);\n\tspin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n\theader.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);\n\tif (sync) {\n\t\twhile (header.p.header_high.part.busy) {\n\t\t\tif (loop_count > 25) {\n\t\t\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\t\t\"sst: Busy wait failed, can't send this msg\\n\");\n\t\t\t\tretval = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t\tloop_count++;\n\t\t\theader.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);\n\t\t}\n\t} else {\n\t\tif (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n\t\t\tdev_dbg(sst_drv_ctx->dev,\n\t\t\t\t\t\"Empty msg queue... NO Action\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (header.p.header_high.part.busy) {\n\t\t\tspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n\t\t\tdev_dbg(sst_drv_ctx->dev, \"Busy not free... post later\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tmsg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,\n\t\t\t\tstruct ipc_post, node);\n\t\tlist_del(&msg->node);\n\t}\n\tdev_dbg(sst_drv_ctx->dev, \"sst: Post message: header = %x\\n\",\n\t\t\t\tmsg->mrfld_header.p.header_high.full);\n\tdev_dbg(sst_drv_ctx->dev, \"sst: size = 0x%x\\n\",\n\t\t\tmsg->mrfld_header.p.header_low_payload);\n\n\tif (msg->mrfld_header.p.header_high.part.large)\n\t\tmemcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,\n\t\t\tmsg->mailbox_data,\n\t\t\tmsg->mrfld_header.p.header_low_payload);\n\n\tsst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);\n\nout:\n\tspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n\tkfree(msg->mailbox_data);\n\tkfree(msg);\n\treturn retval;\n}\n\nvoid intel_sst_clear_intr_mrfld(struct intel_sst_drv *sst_drv_ctx)\n{\n\tunion interrupt_reg_mrfld isr;\n\tunion interrupt_reg_mrfld imr;\n\tunion ipc_header_mrfld clear_ipc;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n\timr.full = sst_shim_read64(sst_drv_ctx->shim, SST_IMRX);\n\tisr.full = sst_shim_read64(sst_drv_ctx->shim, SST_ISRX);\n\n\t \n\tisr.part.busy_interrupt = 1;\n\tsst_shim_write64(sst_drv_ctx->shim, SST_ISRX, isr.full);\n\n\t \n\tclear_ipc.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCD);\n\n\tclear_ipc.p.header_high.part.busy = 0;\n\tclear_ipc.p.header_high.part.done = 1;\n\tclear_ipc.p.header_low_payload = IPC_ACK_SUCCESS;\n\tsst_shim_write64(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);\n\t \n\timr.part.busy_interrupt = 0;\n\tsst_shim_write64(sst_drv_ctx->shim, SST_IMRX, imr.full);\n\tspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\n}\n\n\n \nstatic void process_fw_init(struct intel_sst_drv *sst_drv_ctx,\n\t\t\tvoid *msg)\n{\n\tstruct ipc_header_fw_init *init =\n\t\t(struct ipc_header_fw_init *)msg;\n\tint retval = 0;\n\n\tdev_dbg(sst_drv_ctx->dev, \"*** FW Init msg came***\\n\");\n\tif (init->result) {\n\t\tsst_set_fw_state_locked(sst_drv_ctx, SST_RESET);\n\t\tdev_err(sst_drv_ctx->dev, \"FW Init failed, Error %x\\n\",\n\t\t\t\tinit->result);\n\t\tretval = init->result;\n\t\tgoto ret;\n\t}\n\tif (memcmp(&sst_drv_ctx->fw_version, &init->fw_version,\n\t\t   sizeof(init->fw_version)))\n\t\tdev_info(sst_drv_ctx->dev, \"FW Version %02x.%02x.%02x.%02x\\n\",\n\t\t\tinit->fw_version.type, init->fw_version.major,\n\t\t\tinit->fw_version.minor, init->fw_version.build);\n\tdev_dbg(sst_drv_ctx->dev, \"Build date %s Time %s\\n\",\n\t\t\tinit->build_info.date, init->build_info.time);\n\n\t \n\tsst_drv_ctx->fw_version.type = init->fw_version.type;\n\tsst_drv_ctx->fw_version.major = init->fw_version.major;\n\tsst_drv_ctx->fw_version.minor = init->fw_version.minor;\n\tsst_drv_ctx->fw_version.build = init->fw_version.build;\n\nret:\n\tsst_wake_up_block(sst_drv_ctx, retval, FW_DWNL_ID, 0 , NULL, 0);\n}\n\nstatic void process_fw_async_msg(struct intel_sst_drv *sst_drv_ctx,\n\t\t\tstruct ipc_post *msg)\n{\n\tu32 msg_id;\n\tint str_id;\n\tu32 data_size, i;\n\tvoid *data_offset;\n\tstruct stream_info *stream;\n\tu32 msg_low, pipe_id;\n\n\tmsg_low = msg->mrfld_header.p.header_low_payload;\n\tmsg_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->cmd_id;\n\tdata_offset = (msg->mailbox_data + sizeof(struct ipc_dsp_hdr));\n\tdata_size =  msg_low - (sizeof(struct ipc_dsp_hdr));\n\n\tswitch (msg_id) {\n\tcase IPC_SST_PERIOD_ELAPSED_MRFLD:\n\t\tpipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\n\t\tstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\n\t\tif (str_id > 0) {\n\t\t\tdev_dbg(sst_drv_ctx->dev,\n\t\t\t\t\"Period elapsed rcvd for pipe id 0x%x\\n\",\n\t\t\t\tpipe_id);\n\t\t\tstream = &sst_drv_ctx->streams[str_id];\n\t\t\t \n\t\t\tif (stream->status == STREAM_INIT)\n\t\t\t\tbreak;\n\t\t\tif (stream->period_elapsed)\n\t\t\t\tstream->period_elapsed(stream->pcm_substream);\n\t\t\tif (stream->compr_cb)\n\t\t\t\tstream->compr_cb(stream->compr_cb_param);\n\t\t}\n\t\tbreak;\n\n\tcase IPC_IA_DRAIN_STREAM_MRFLD:\n\t\tpipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\n\t\tstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\n\t\tif (str_id > 0) {\n\t\t\tstream = &sst_drv_ctx->streams[str_id];\n\t\t\tif (stream->drain_notify)\n\t\t\t\tstream->drain_notify(stream->drain_cb_param);\n\t\t}\n\t\tbreak;\n\n\tcase IPC_IA_FW_ASYNC_ERR_MRFLD:\n\t\tdev_err(sst_drv_ctx->dev, \"FW sent async error msg:\\n\");\n\t\tfor (i = 0; i < (data_size/4); i++)\n\t\t\tprint_hex_dump(KERN_DEBUG, NULL, DUMP_PREFIX_NONE,\n\t\t\t\t\t16, 4, data_offset, data_size, false);\n\t\tbreak;\n\n\tcase IPC_IA_FW_INIT_CMPLT_MRFLD:\n\t\tprocess_fw_init(sst_drv_ctx, data_offset);\n\t\tbreak;\n\n\tcase IPC_IA_BUF_UNDER_RUN_MRFLD:\n\t\tpipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\n\t\tstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\n\t\tif (str_id > 0)\n\t\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\t\"Buffer under-run for pipe:%#x str_id:%d\\n\",\n\t\t\t\tpipe_id, str_id);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\"Unrecognized async msg from FW msg_id %#x\\n\", msg_id);\n\t}\n}\n\nvoid sst_process_reply_mrfld(struct intel_sst_drv *sst_drv_ctx,\n\t\tstruct ipc_post *msg)\n{\n\tunsigned int drv_id;\n\tvoid *data;\n\tunion ipc_header_high msg_high;\n\tu32 msg_low;\n\tstruct ipc_dsp_hdr *dsp_hdr;\n\n\tmsg_high = msg->mrfld_header.p.header_high;\n\tmsg_low = msg->mrfld_header.p.header_low_payload;\n\n\tdev_dbg(sst_drv_ctx->dev, \"IPC process message header %x payload %x\\n\",\n\t\t\tmsg->mrfld_header.p.header_high.full,\n\t\t\tmsg->mrfld_header.p.header_low_payload);\n\n\tdrv_id = msg_high.part.drv_id;\n\n\t \n\tif (drv_id == SST_ASYNC_DRV_ID) {\n\t\t \n\t\tprocess_fw_async_msg(sst_drv_ctx, msg);\n\t\treturn;\n\t}\n\n\t \n\tif (msg_high.part.result && !msg_high.part.large) {\n\t\t \n\t\tdev_err(sst_drv_ctx->dev, \"FW sent error response 0x%x\", msg_low);\n\t\tsst_wake_up_block(sst_drv_ctx, msg_high.part.result,\n\t\t\tmsg_high.part.drv_id,\n\t\t\tmsg_high.part.msg_id, NULL, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (msg_high.part.large) {\n\t\tdata = kmemdup((void *)msg->mailbox_data, msg_low, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn;\n\t\t \n\t\tdsp_hdr = (struct ipc_dsp_hdr *)data;\n\t\tdev_dbg(sst_drv_ctx->dev, \"cmd_id %d\\n\", dsp_hdr->cmd_id);\n\t\tif (sst_wake_up_block(sst_drv_ctx, msg_high.part.result,\n\t\t\t\tmsg_high.part.drv_id,\n\t\t\t\tmsg_high.part.msg_id, data, msg_low))\n\t\t\tkfree(data);\n\t} else {\n\t\tsst_wake_up_block(sst_drv_ctx, msg_high.part.result,\n\t\t\t\tmsg_high.part.drv_id,\n\t\t\t\tmsg_high.part.msg_id, NULL, 0);\n\t}\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}