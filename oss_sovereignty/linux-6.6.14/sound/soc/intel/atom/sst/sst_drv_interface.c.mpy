{
  "module_name": "sst_drv_interface.c",
  "hash_id": "262e97b4ae5c77caffeaa73538555ea1271d9999f35e9e49a958be913f9943cb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_drv_interface.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/fs.h>\n#include <linux/firmware.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/math64.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\n#define NUM_CODEC 2\n#define MIN_FRAGMENT 2\n#define MAX_FRAGMENT 4\n#define MIN_FRAGMENT_SIZE (50 * 1024)\n#define MAX_FRAGMENT_SIZE (1024 * 1024)\n#define SST_GET_BYTES_PER_SAMPLE(pcm_wd_sz)  (((pcm_wd_sz + 15) >> 4) << 1)\n#ifdef CONFIG_PM\n#define GET_USAGE_COUNT(dev) (atomic_read(&dev->power.usage_count))\n#else\n#define GET_USAGE_COUNT(dev) 1\n#endif\n\nint free_stream_context(struct intel_sst_drv *ctx, unsigned int str_id)\n{\n\tstruct stream_info *stream;\n\tint ret = 0;\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (stream) {\n\t\t \n\t\tret = sst_free_stream(ctx, str_id);\n\t\tif (ret)\n\t\t\tsst_clean_stream(&ctx->streams[str_id]);\n\t\treturn ret;\n\t} else {\n\t\tdev_err(ctx->dev, \"we tried to free stream context %d which was freed!!!\\n\", str_id);\n\t}\n\treturn ret;\n}\n\nint sst_get_stream_allocated(struct intel_sst_drv *ctx,\n\tstruct snd_sst_params *str_param,\n\tstruct snd_sst_lib_download **lib_dnld)\n{\n\tint retval;\n\n\tretval = ctx->ops->alloc_stream(ctx, str_param);\n\tif (retval > 0)\n\t\tdev_dbg(ctx->dev, \"Stream allocated %d\\n\", retval);\n\treturn retval;\n\n}\n\n \nint sst_get_sfreq(struct snd_sst_params *str_param)\n{\n\tswitch (str_param->codec) {\n\tcase SST_CODEC_TYPE_PCM:\n\t\treturn str_param->sparams.uc.pcm_params.sfreq;\n\tcase SST_CODEC_TYPE_AAC:\n\t\treturn str_param->sparams.uc.aac_params.externalsr;\n\tcase SST_CODEC_TYPE_MP3:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint sst_get_num_channel(struct snd_sst_params *str_param)\n{\n\tswitch (str_param->codec) {\n\tcase SST_CODEC_TYPE_PCM:\n\t\treturn str_param->sparams.uc.pcm_params.num_chan;\n\tcase SST_CODEC_TYPE_MP3:\n\t\treturn str_param->sparams.uc.mp3_params.num_chan;\n\tcase SST_CODEC_TYPE_AAC:\n\t\treturn str_param->sparams.uc.aac_params.num_chan;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint sst_get_stream(struct intel_sst_drv *ctx,\n\t\t\tstruct snd_sst_params *str_param)\n{\n\tint retval;\n\tstruct stream_info *str_info;\n\n\t \n\tretval = ctx->ops->alloc_stream(ctx, str_param);\n\tif (retval <= 0) {\n\t\treturn -EIO;\n\t}\n\t \n\tstr_info = &ctx->streams[retval];\n\tstr_info->sfreq = sst_get_sfreq(str_param);\n\n\treturn retval;\n}\n\nstatic int sst_power_control(struct device *dev, bool state)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\tint ret = 0;\n\tint usage_count = 0;\n\n\tif (state) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tusage_count = GET_USAGE_COUNT(dev);\n\t\tdev_dbg(ctx->dev, \"Enable: pm usage count: %d\\n\", usage_count);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"Runtime get failed with err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif ((ctx->sst_state == SST_RESET) && (usage_count == 1)) {\n\t\t\tret = sst_load_fw(ctx);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"FW download fail %d\\n\", ret);\n\t\t\t\tsst_set_fw_state_locked(ctx, SST_RESET);\n\t\t\t\tret = sst_pm_runtime_put(ctx);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tusage_count = GET_USAGE_COUNT(dev);\n\t\tdev_dbg(ctx->dev, \"Disable: pm usage count: %d\\n\", usage_count);\n\t\treturn sst_pm_runtime_put(ctx);\n\t}\n\treturn ret;\n}\n\n \nstatic int sst_open_pcm_stream(struct device *dev,\n\t\tstruct snd_sst_params *str_param)\n{\n\tint retval;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (!str_param)\n\t\treturn -EINVAL;\n\n\tretval = sst_get_stream(ctx, str_param);\n\tif (retval > 0)\n\t\tctx->stream_cnt++;\n\telse\n\t\tdev_err(ctx->dev, \"sst_get_stream returned err %d\\n\", retval);\n\n\treturn retval;\n}\n\nstatic int sst_cdev_open(struct device *dev,\n\t\tstruct snd_sst_params *str_params, struct sst_compress_cb *cb)\n{\n\tint str_id, retval;\n\tstruct stream_info *stream;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tretval = pm_runtime_resume_and_get(ctx->dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tstr_id = sst_get_stream(ctx, str_params);\n\tif (str_id > 0) {\n\t\tdev_dbg(dev, \"stream allocated in sst_cdev_open %d\\n\", str_id);\n\t\tstream = &ctx->streams[str_id];\n\t\tstream->compr_cb = cb->compr_cb;\n\t\tstream->compr_cb_param = cb->param;\n\t\tstream->drain_notify = cb->drain_notify;\n\t\tstream->drain_cb_param = cb->drain_cb_param;\n\t} else {\n\t\tdev_err(dev, \"stream encountered error during alloc %d\\n\", str_id);\n\t\tstr_id = -EINVAL;\n\t\tsst_pm_runtime_put(ctx);\n\t}\n\treturn str_id;\n}\n\nstatic int sst_cdev_close(struct device *dev, unsigned int str_id)\n{\n\tint retval;\n\tstruct stream_info *stream;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream) {\n\t\tdev_err(dev, \"stream info is NULL for str %d!!!\\n\", str_id);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = sst_free_stream(ctx, str_id);\n\tstream->compr_cb_param = NULL;\n\tstream->compr_cb = NULL;\n\n\tif (retval)\n\t\tdev_err(dev, \"free stream returned err %d\\n\", retval);\n\n\tdev_dbg(dev, \"End\\n\");\n\treturn retval;\n}\n\nstatic int sst_cdev_ack(struct device *dev, unsigned int str_id,\n\t\tunsigned long bytes)\n{\n\tstruct stream_info *stream;\n\tstruct snd_sst_tstamp fw_tstamp = {0,};\n\tint offset;\n\tvoid __iomem *addr;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\t \n\tstream->cumm_bytes += bytes;\n\tdev_dbg(dev, \"bytes copied %d inc by %ld\\n\", stream->cumm_bytes, bytes);\n\n\taddr =  ((void __iomem *)(ctx->mailbox + ctx->tstamp)) +\n\t\t(str_id * sizeof(fw_tstamp));\n\n\tmemcpy_fromio(&fw_tstamp, addr, sizeof(fw_tstamp));\n\n\tfw_tstamp.bytes_copied = stream->cumm_bytes;\n\tdev_dbg(dev, \"bytes sent to fw %llu inc by %ld\\n\",\n\t\t\tfw_tstamp.bytes_copied, bytes);\n\n\toffset =  offsetof(struct snd_sst_tstamp, bytes_copied);\n\tsst_shim_write(addr, offset, fw_tstamp.bytes_copied);\n\treturn 0;\n}\n\nstatic int sst_cdev_set_metadata(struct device *dev,\n\t\tunsigned int str_id, struct snd_compr_metadata *metadata)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"set metadata for stream %d\\n\", str_id);\n\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"pipe id = %d\\n\", str_info->pipe_id);\n\tretval = sst_prepare_and_post_msg(ctx, str_info->task_id, IPC_CMD,\n\t\t\tIPC_IA_SET_STREAM_PARAMS_MRFLD, str_info->pipe_id,\n\t\t\tsizeof(*metadata), metadata, NULL,\n\t\t\ttrue, true, true, false);\n\n\treturn retval;\n}\n\nstatic int sst_cdev_stream_pause(struct device *dev, unsigned int str_id)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\treturn sst_pause_stream(ctx, str_id);\n}\n\nstatic int sst_cdev_stream_pause_release(struct device *dev,\n\t\tunsigned int str_id)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\treturn sst_resume_stream(ctx, str_id);\n}\n\nstatic int sst_cdev_stream_start(struct device *dev, unsigned int str_id)\n{\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tstr_info->prev = str_info->status;\n\tstr_info->status = STREAM_RUNNING;\n\treturn sst_start_stream(ctx, str_id);\n}\n\nstatic int sst_cdev_stream_drop(struct device *dev, unsigned int str_id)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\treturn sst_drop_stream(ctx, str_id);\n}\n\nstatic int sst_cdev_stream_drain(struct device *dev, unsigned int str_id)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\treturn sst_drain_stream(ctx, str_id, false);\n}\n\nstatic int sst_cdev_stream_partial_drain(struct device *dev,\n\t\tunsigned int str_id)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\treturn sst_drain_stream(ctx, str_id, true);\n}\n\nstatic int sst_cdev_tstamp(struct device *dev, unsigned int str_id,\n\t\tstruct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_sst_tstamp fw_tstamp = {0,};\n\tstruct stream_info *stream;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\tvoid __iomem *addr;\n\n\taddr = (void __iomem *)(ctx->mailbox + ctx->tstamp) +\n\t\t(str_id * sizeof(fw_tstamp));\n\n\tmemcpy_fromio(&fw_tstamp, addr, sizeof(fw_tstamp));\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream)\n\t\treturn -EINVAL;\n\tdev_dbg(dev, \"rb_counter %llu in bytes\\n\", fw_tstamp.ring_buffer_counter);\n\n\ttstamp->copied_total = fw_tstamp.ring_buffer_counter;\n\ttstamp->pcm_frames = fw_tstamp.frames_decoded;\n\ttstamp->pcm_io_frames = div_u64(fw_tstamp.hardware_counter,\n\t\t\t(u64)stream->num_ch * SST_GET_BYTES_PER_SAMPLE(24));\n\ttstamp->sampling_rate = fw_tstamp.sampling_frequency;\n\n\tdev_dbg(dev, \"PCM  = %u\\n\", tstamp->pcm_io_frames);\n\tdev_dbg(dev, \"Ptr Query on strid = %d  copied_total %d, decodec %d\\n\",\n\t\tstr_id, tstamp->copied_total, tstamp->pcm_frames);\n\tdev_dbg(dev, \"rendered %d\\n\", tstamp->pcm_io_frames);\n\n\treturn 0;\n}\n\nstatic int sst_cdev_caps(struct snd_compr_caps *caps)\n{\n\tcaps->num_codecs = NUM_CODEC;\n\tcaps->min_fragment_size = MIN_FRAGMENT_SIZE;   \n\tcaps->max_fragment_size = MAX_FRAGMENT_SIZE;   \n\tcaps->min_fragments = MIN_FRAGMENT;\n\tcaps->max_fragments = MAX_FRAGMENT;\n\tcaps->codecs[0] = SND_AUDIOCODEC_MP3;\n\tcaps->codecs[1] = SND_AUDIOCODEC_AAC;\n\treturn 0;\n}\n\nstatic const struct snd_compr_codec_caps caps_mp3 = {\n\t.num_descriptors = 1,\n\t.descriptor[0].max_ch = 2,\n\t.descriptor[0].sample_rates[0] = 48000,\n\t.descriptor[0].sample_rates[1] = 44100,\n\t.descriptor[0].sample_rates[2] = 32000,\n\t.descriptor[0].sample_rates[3] = 16000,\n\t.descriptor[0].sample_rates[4] = 8000,\n\t.descriptor[0].num_sample_rates = 5,\n\t.descriptor[0].bit_rate[0] = 320,\n\t.descriptor[0].bit_rate[1] = 192,\n\t.descriptor[0].num_bitrates = 2,\n\t.descriptor[0].profiles = 0,\n\t.descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO,\n\t.descriptor[0].formats = 0,\n};\n\nstatic const struct snd_compr_codec_caps caps_aac = {\n\t.num_descriptors = 2,\n\t.descriptor[1].max_ch = 2,\n\t.descriptor[0].sample_rates[0] = 48000,\n\t.descriptor[0].sample_rates[1] = 44100,\n\t.descriptor[0].sample_rates[2] = 32000,\n\t.descriptor[0].sample_rates[3] = 16000,\n\t.descriptor[0].sample_rates[4] = 8000,\n\t.descriptor[0].num_sample_rates = 5,\n\t.descriptor[1].bit_rate[0] = 320,\n\t.descriptor[1].bit_rate[1] = 192,\n\t.descriptor[1].num_bitrates = 2,\n\t.descriptor[1].profiles = 0,\n\t.descriptor[1].modes = 0,\n\t.descriptor[1].formats =\n\t\t\t(SND_AUDIOSTREAMFORMAT_MP4ADTS |\n\t\t\t\tSND_AUDIOSTREAMFORMAT_RAW),\n};\n\nstatic int sst_cdev_codec_caps(struct snd_compr_codec_caps *codec)\n{\n\tif (codec->codec == SND_AUDIOCODEC_MP3)\n\t\t*codec = caps_mp3;\n\telse if (codec->codec == SND_AUDIOCODEC_AAC)\n\t\t*codec = caps_aac;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nvoid sst_cdev_fragment_elapsed(struct intel_sst_drv *ctx, int str_id)\n{\n\tstruct stream_info *stream;\n\n\tdev_dbg(ctx->dev, \"fragment elapsed from firmware for str_id %d\\n\",\n\t\t\tstr_id);\n\tstream = &ctx->streams[str_id];\n\tif (stream->compr_cb)\n\t\tstream->compr_cb(stream->compr_cb_param);\n}\n\n \nstatic int sst_close_pcm_stream(struct device *dev, unsigned int str_id)\n{\n\tstruct stream_info *stream;\n\tint retval = 0;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream) {\n\t\tdev_err(ctx->dev, \"stream info is NULL for str %d!!!\\n\", str_id);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = free_stream_context(ctx, str_id);\n\tstream->pcm_substream = NULL;\n\tstream->status = STREAM_UN_INIT;\n\tstream->period_elapsed = NULL;\n\tctx->stream_cnt--;\n\n\tif (retval)\n\t\tdev_err(ctx->dev, \"free stream returned err %d\\n\", retval);\n\n\tdev_dbg(ctx->dev, \"Exit\\n\");\n\treturn 0;\n}\n\nstatic inline int sst_calc_tstamp(struct intel_sst_drv *ctx,\n\t\tstruct pcm_stream_info *info,\n\t\tstruct snd_pcm_substream *substream,\n\t\tstruct snd_sst_tstamp *fw_tstamp)\n{\n\tsize_t delay_bytes, delay_frames;\n\tsize_t buffer_sz;\n\tu32 pointer_bytes, pointer_samples;\n\n\tdev_dbg(ctx->dev, \"mrfld ring_buffer_counter %llu in bytes\\n\",\n\t\t\tfw_tstamp->ring_buffer_counter);\n\tdev_dbg(ctx->dev, \"mrfld hardware_counter %llu in bytes\\n\",\n\t\t\t fw_tstamp->hardware_counter);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdelay_bytes = (size_t) (fw_tstamp->ring_buffer_counter -\n\t\t\t\t\tfw_tstamp->hardware_counter);\n\telse\n\t\tdelay_bytes = (size_t) (fw_tstamp->hardware_counter -\n\t\t\t\t\tfw_tstamp->ring_buffer_counter);\n\tdelay_frames = bytes_to_frames(substream->runtime, delay_bytes);\n\tbuffer_sz = snd_pcm_lib_buffer_bytes(substream);\n\tdiv_u64_rem(fw_tstamp->ring_buffer_counter, buffer_sz, &pointer_bytes);\n\tpointer_samples = bytes_to_samples(substream->runtime, pointer_bytes);\n\n\tdev_dbg(ctx->dev, \"pcm delay %zu in bytes\\n\", delay_bytes);\n\n\tinfo->buffer_ptr = pointer_samples / substream->runtime->channels;\n\n\tinfo->pcm_delay = delay_frames;\n\tdev_dbg(ctx->dev, \"buffer ptr %llu pcm_delay rep: %llu\\n\",\n\t\t\tinfo->buffer_ptr, info->pcm_delay);\n\treturn 0;\n}\n\nstatic int sst_read_timestamp(struct device *dev, struct pcm_stream_info *info)\n{\n\tstruct stream_info *stream;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_sst_tstamp fw_tstamp;\n\tunsigned int str_id;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\tvoid __iomem *addr;\n\n\tstr_id = info->str_id;\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tif (!stream->pcm_substream)\n\t\treturn -EINVAL;\n\tsubstream = stream->pcm_substream;\n\n\taddr = (void __iomem *)(ctx->mailbox + ctx->tstamp) +\n\t\t(str_id * sizeof(fw_tstamp));\n\n\tmemcpy_fromio(&fw_tstamp, addr, sizeof(fw_tstamp));\n\n\treturn sst_calc_tstamp(ctx, info, substream, &fw_tstamp);\n}\n\nstatic int sst_stream_start(struct device *dev, int str_id)\n{\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->sst_state != SST_FW_RUNNING)\n\t\treturn 0;\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tstr_info->prev = str_info->status;\n\tstr_info->status = STREAM_RUNNING;\n\tsst_start_stream(ctx, str_id);\n\n\treturn 0;\n}\n\nstatic int sst_stream_drop(struct device *dev, int str_id)\n{\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->sst_state != SST_FW_RUNNING)\n\t\treturn 0;\n\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tstr_info->prev = STREAM_UN_INIT;\n\tstr_info->status = STREAM_INIT;\n\treturn sst_drop_stream(ctx, str_id);\n}\n\nstatic int sst_stream_pause(struct device *dev, int str_id)\n{\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->sst_state != SST_FW_RUNNING)\n\t\treturn 0;\n\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\treturn sst_pause_stream(ctx, str_id);\n}\n\nstatic int sst_stream_resume(struct device *dev, int str_id)\n{\n\tstruct stream_info *str_info;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->sst_state != SST_FW_RUNNING)\n\t\treturn 0;\n\n\tstr_info = get_stream_info(ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\treturn sst_resume_stream(ctx, str_id);\n}\n\nstatic int sst_stream_init(struct device *dev, struct pcm_stream_info *str_info)\n{\n\tint str_id = 0;\n\tstruct stream_info *stream;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tstr_id = str_info->str_id;\n\n\tif (ctx->sst_state != SST_FW_RUNNING)\n\t\treturn 0;\n\n\tstream = get_stream_info(ctx, str_id);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tdev_dbg(ctx->dev, \"setting the period ptrs\\n\");\n\tstream->pcm_substream = str_info->arg;\n\tstream->period_elapsed = str_info->period_elapsed;\n\tstream->sfreq = str_info->sfreq;\n\tstream->prev = stream->status;\n\tstream->status = STREAM_INIT;\n\tdev_dbg(ctx->dev,\n\t\t\"pcm_substream %p, period_elapsed %p, sfreq %d, status %d\\n\",\n\t\tstream->pcm_substream, stream->period_elapsed,\n\t\tstream->sfreq, stream->status);\n\n\treturn 0;\n}\n\n \nstatic int sst_send_byte_stream(struct device *dev,\n\t\tstruct snd_sst_bytes_v2 *bytes)\n{\n\tint ret_val = 0;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (NULL == bytes)\n\t\treturn -EINVAL;\n\tret_val = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tret_val = sst_send_byte_stream_mrfld(ctx, bytes);\n\tsst_pm_runtime_put(ctx);\n\n\treturn ret_val;\n}\n\nstatic struct sst_ops pcm_ops = {\n\t.open = sst_open_pcm_stream,\n\t.stream_init = sst_stream_init,\n\t.stream_start = sst_stream_start,\n\t.stream_drop = sst_stream_drop,\n\t.stream_pause = sst_stream_pause,\n\t.stream_pause_release = sst_stream_resume,\n\t.stream_read_tstamp = sst_read_timestamp,\n\t.send_byte_stream = sst_send_byte_stream,\n\t.close = sst_close_pcm_stream,\n\t.power = sst_power_control,\n};\n\nstatic struct compress_sst_ops compr_ops = {\n\t.open = sst_cdev_open,\n\t.close = sst_cdev_close,\n\t.stream_pause = sst_cdev_stream_pause,\n\t.stream_pause_release = sst_cdev_stream_pause_release,\n\t.stream_start = sst_cdev_stream_start,\n\t.stream_drop = sst_cdev_stream_drop,\n\t.stream_drain = sst_cdev_stream_drain,\n\t.stream_partial_drain = sst_cdev_stream_partial_drain,\n\t.tstamp = sst_cdev_tstamp,\n\t.ack = sst_cdev_ack,\n\t.get_caps = sst_cdev_caps,\n\t.get_codec_caps = sst_cdev_codec_caps,\n\t.set_metadata = sst_cdev_set_metadata,\n\t.power = sst_power_control,\n};\n\nstatic struct sst_device sst_dsp_device = {\n\t.name = \"Intel(R) SST LPE\",\n\t.dev = NULL,\n\t.ops = &pcm_ops,\n\t.compr_ops = &compr_ops,\n};\n\n \nint sst_register(struct device *dev)\n{\n\tint ret_val;\n\n\tsst_dsp_device.dev = dev;\n\tret_val = sst_register_dsp(&sst_dsp_device);\n\tif (ret_val)\n\t\tdev_err(dev, \"Unable to register DSP with platform driver\\n\");\n\n\treturn ret_val;\n}\n\nint sst_unregister(struct device *dev)\n{\n\treturn sst_unregister_dsp(&sst_dsp_device);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}