{
  "module_name": "sst_loader.c",
  "hash_id": "4b5862b800715427700c576fc907bac0050d634acad9a424fc27ba470ff7c52a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_loader.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/firmware.h>\n#include <linux/dmaengine.h>\n#include <linux/pm_qos.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\nvoid memcpy32_toio(void __iomem *dst, const void *src, int count)\n{\n\t \n\t__iowrite32_copy(dst, src, count / 4);\n}\n\nvoid memcpy32_fromio(void *dst, const void __iomem *src, int count)\n{\n\t \n\t__ioread32_copy(dst, src, count / 4);\n}\n\n \nint intel_sst_reset_dsp_mrfld(struct intel_sst_drv *sst_drv_ctx)\n{\n\tunion config_status_reg_mrfld csr;\n\n\tdev_dbg(sst_drv_ctx->dev, \"sst: Resetting the DSP in mrfld\\n\");\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\n\tdev_dbg(sst_drv_ctx->dev, \"value:0x%llx\\n\", csr.full);\n\n\tcsr.full |= 0x7;\n\tsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\n\tdev_dbg(sst_drv_ctx->dev, \"value:0x%llx\\n\", csr.full);\n\n\tcsr.full &= ~(0x1);\n\tsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\n\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\tdev_dbg(sst_drv_ctx->dev, \"value:0x%llx\\n\", csr.full);\n\treturn 0;\n}\n\n \nint sst_start_mrfld(struct intel_sst_drv *sst_drv_ctx)\n{\n\tunion config_status_reg_mrfld csr;\n\n\tdev_dbg(sst_drv_ctx->dev, \"sst: Starting the DSP in mrfld LALALALA\\n\");\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\tdev_dbg(sst_drv_ctx->dev, \"value:0x%llx\\n\", csr.full);\n\n\tcsr.full |= 0x7;\n\tsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\n\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\tdev_dbg(sst_drv_ctx->dev, \"value:0x%llx\\n\", csr.full);\n\n\tcsr.part.xt_snoop = 1;\n\tcsr.full &= ~(0x5);\n\tsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\n\n\tcsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\n\tdev_dbg(sst_drv_ctx->dev, \"sst: Starting the DSP_merrifield:%llx\\n\",\n\t\t\tcsr.full);\n\treturn 0;\n}\n\nstatic int sst_validate_fw_image(struct intel_sst_drv *ctx, unsigned long size,\n\t\tstruct fw_module_header **module, u32 *num_modules)\n{\n\tstruct sst_fw_header *header;\n\tconst void *sst_fw_in_mem = ctx->fw_in_mem;\n\n\tdev_dbg(ctx->dev, \"Enter\\n\");\n\n\t \n\theader = (struct sst_fw_header *)sst_fw_in_mem;\n\tdev_dbg(ctx->dev,\n\t\t\"header sign=%s size=%x modules=%x fmt=%x size=%zx\\n\",\n\t\theader->signature, header->file_size, header->modules,\n\t\theader->file_format, sizeof(*header));\n\n\t \n\tif ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||\n\t\t(size != header->file_size + sizeof(*header))) {\n\t\t \n\t\tdev_err(ctx->dev, \"InvalidFW sign/filesize mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*num_modules = header->modules;\n\t*module = (void *)sst_fw_in_mem + sizeof(*header);\n\n\treturn 0;\n}\n\n \nstatic int sst_fill_memcpy_list(struct list_head *memcpy_list,\n\t\t\tvoid *destn, const void *src, u32 size, bool is_io)\n{\n\tstruct sst_memcpy_list *listnode;\n\n\tlistnode = kzalloc(sizeof(*listnode), GFP_KERNEL);\n\tif (listnode == NULL)\n\t\treturn -ENOMEM;\n\tlistnode->dstn = destn;\n\tlistnode->src = src;\n\tlistnode->size = size;\n\tlistnode->is_io = is_io;\n\tlist_add_tail(&listnode->memcpylist, memcpy_list);\n\n\treturn 0;\n}\n\n \nstatic int sst_parse_module_memcpy(struct intel_sst_drv *sst_drv_ctx,\n\t\tstruct fw_module_header *module, struct list_head *memcpy_list)\n{\n\tstruct fw_block_info *block;\n\tu32 count;\n\tint ret_val = 0;\n\tvoid __iomem *ram_iomem;\n\n\tdev_dbg(sst_drv_ctx->dev, \"module sign %s size %x blocks %x type %x\\n\",\n\t\t\tmodule->signature, module->mod_size,\n\t\t\tmodule->blocks, module->type);\n\tdev_dbg(sst_drv_ctx->dev, \"module entrypoint 0x%x\\n\", module->entry_point);\n\n\tblock = (void *)module + sizeof(*module);\n\n\tfor (count = 0; count < module->blocks; count++) {\n\t\tif (block->size <= 0) {\n\t\t\tdev_err(sst_drv_ctx->dev, \"block size invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (block->type) {\n\t\tcase SST_IRAM:\n\t\t\tram_iomem = sst_drv_ctx->iram;\n\t\t\tbreak;\n\t\tcase SST_DRAM:\n\t\t\tram_iomem = sst_drv_ctx->dram;\n\t\t\tbreak;\n\t\tcase SST_DDR:\n\t\t\tram_iomem = sst_drv_ctx->ddr;\n\t\t\tbreak;\n\t\tcase SST_CUSTOM_INFO:\n\t\t\tblock = (void *)block + sizeof(*block) + block->size;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tdev_err(sst_drv_ctx->dev, \"wrong ram type0x%x in block0x%x\\n\",\n\t\t\t\t\tblock->type, count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret_val = sst_fill_memcpy_list(memcpy_list,\n\t\t\t\tram_iomem + block->ram_offset,\n\t\t\t\t(void *)block + sizeof(*block), block->size, 1);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\n\t\tblock = (void *)block + sizeof(*block) + block->size;\n\t}\n\treturn 0;\n}\n\n \nstatic int sst_parse_fw_memcpy(struct intel_sst_drv *ctx, unsigned long size,\n\t\t\t\tstruct list_head *fw_list)\n{\n\tstruct fw_module_header *module;\n\tu32 count, num_modules;\n\tint ret_val;\n\n\tret_val = sst_validate_fw_image(ctx, size, &module, &num_modules);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tfor (count = 0; count < num_modules; count++) {\n\t\tret_val = sst_parse_module_memcpy(ctx, module, fw_list);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t\tmodule = (void *)module + sizeof(*module) + module->mod_size;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sst_do_memcpy(struct list_head *memcpy_list)\n{\n\tstruct sst_memcpy_list *listnode;\n\n\tlist_for_each_entry(listnode, memcpy_list, memcpylist) {\n\t\tif (listnode->is_io)\n\t\t\tmemcpy32_toio((void __iomem *)listnode->dstn,\n\t\t\t\t\tlistnode->src, listnode->size);\n\t\telse\n\t\t\tmemcpy(listnode->dstn, listnode->src, listnode->size);\n\t}\n}\n\nvoid sst_memcpy_free_resources(struct intel_sst_drv *sst_drv_ctx)\n{\n\tstruct sst_memcpy_list *listnode, *tmplistnode;\n\n\t \n\tlist_for_each_entry_safe(listnode, tmplistnode,\n\t\t\t\t &sst_drv_ctx->memcpy_list, memcpylist) {\n\t\tlist_del(&listnode->memcpylist);\n\t\tkfree(listnode);\n\t}\n}\n\nstatic int sst_cache_and_parse_fw(struct intel_sst_drv *sst,\n\t\tconst struct firmware *fw)\n{\n\tint retval = 0;\n\n\tsst->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);\n\tif (!sst->fw_in_mem) {\n\t\tretval = -ENOMEM;\n\t\tgoto end_release;\n\t}\n\tdev_dbg(sst->dev, \"copied fw to %p\", sst->fw_in_mem);\n\tdev_dbg(sst->dev, \"phys: %lx\", (unsigned long)virt_to_phys(sst->fw_in_mem));\n\tmemcpy(sst->fw_in_mem, fw->data, fw->size);\n\tretval = sst_parse_fw_memcpy(sst, fw->size, &sst->memcpy_list);\n\tif (retval) {\n\t\tdev_err(sst->dev, \"Failed to parse fw\\n\");\n\t\tkfree(sst->fw_in_mem);\n\t\tsst->fw_in_mem = NULL;\n\t}\n\nend_release:\n\trelease_firmware(fw);\n\treturn retval;\n\n}\n\nvoid sst_firmware_load_cb(const struct firmware *fw, void *context)\n{\n\tstruct intel_sst_drv *ctx = context;\n\n\tdev_dbg(ctx->dev, \"Enter\\n\");\n\n\tif (fw == NULL) {\n\t\tdev_err(ctx->dev, \"request fw failed\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ctx->sst_lock);\n\n\tif (ctx->sst_state != SST_RESET ||\n\t\t\tctx->fw_in_mem != NULL) {\n\t\trelease_firmware(fw);\n\t\tmutex_unlock(&ctx->sst_lock);\n\t\treturn;\n\t}\n\n\tdev_dbg(ctx->dev, \"Request Fw completed\\n\");\n\tsst_cache_and_parse_fw(ctx, fw);\n\tmutex_unlock(&ctx->sst_lock);\n}\n\n \nstatic int sst_request_fw(struct intel_sst_drv *sst)\n{\n\tint retval = 0;\n\tconst struct firmware *fw;\n\n\tretval = request_firmware(&fw, sst->firmware_name, sst->dev);\n\tif (retval) {\n\t\tdev_err(sst->dev, \"request fw failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (fw == NULL) {\n\t\tdev_err(sst->dev, \"fw is returning as null\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&sst->sst_lock);\n\tretval = sst_cache_and_parse_fw(sst, fw);\n\tmutex_unlock(&sst->sst_lock);\n\n\treturn retval;\n}\n\n \nstatic void sst_dccm_config_write(void __iomem *dram_base,\n\t\tunsigned int ddr_base)\n{\n\tvoid __iomem *addr;\n\tu32 bss_reset = 0;\n\n\taddr = (void __iomem *)(dram_base + MRFLD_FW_DDR_BASE_OFFSET);\n\tmemcpy32_toio(addr, (void *)&ddr_base, sizeof(u32));\n\tbss_reset |= (1 << MRFLD_FW_BSS_RESET_BIT);\n\taddr = (void __iomem *)(dram_base + MRFLD_FW_FEATURE_BASE_OFFSET);\n\tmemcpy32_toio(addr, &bss_reset, sizeof(u32));\n\n}\n\nvoid sst_post_download_mrfld(struct intel_sst_drv *ctx)\n{\n\tsst_dccm_config_write(ctx->dram, ctx->ddr_base);\n\tdev_dbg(ctx->dev, \"config written to DCCM\\n\");\n}\n\n \nint sst_load_fw(struct intel_sst_drv *sst_drv_ctx)\n{\n\tint ret_val = 0;\n\tstruct sst_block *block;\n\n\tdev_dbg(sst_drv_ctx->dev, \"sst_load_fw\\n\");\n\n\tif (sst_drv_ctx->sst_state !=  SST_RESET)\n\t\treturn -EAGAIN;\n\n\tif (!sst_drv_ctx->fw_in_mem) {\n\t\tdev_dbg(sst_drv_ctx->dev, \"sst: FW not in memory retry to download\\n\");\n\t\tret_val = sst_request_fw(sst_drv_ctx);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\tblock = sst_create_block(sst_drv_ctx, 0, FW_DWNL_ID);\n\tif (block == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tcpu_latency_qos_update_request(sst_drv_ctx->qos, 0);\n\n\tsst_drv_ctx->sst_state = SST_FW_LOADING;\n\n\tret_val = sst_drv_ctx->ops->reset(sst_drv_ctx);\n\tif (ret_val)\n\t\tgoto restore;\n\n\tsst_do_memcpy(&sst_drv_ctx->memcpy_list);\n\n\t \n\tif (sst_drv_ctx->ops->post_download)\n\t\tsst_drv_ctx->ops->post_download(sst_drv_ctx);\n\n\t \n\tret_val = sst_drv_ctx->ops->start(sst_drv_ctx);\n\tif (ret_val)\n\t\tgoto restore;\n\n\tret_val = sst_wait_timeout(sst_drv_ctx, block);\n\tif (ret_val) {\n\t\tdev_err(sst_drv_ctx->dev, \"fw download failed %d\\n\" , ret_val);\n\t\t \n\t\tret_val = -EBUSY;\n\n\t}\n\n\nrestore:\n\t \n\tcpu_latency_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);\n\tsst_free_block(sst_drv_ctx, block);\n\tdev_dbg(sst_drv_ctx->dev, \"fw load successful!!!\\n\");\n\n\tif (sst_drv_ctx->ops->restore_dsp_context)\n\t\tsst_drv_ctx->ops->restore_dsp_context();\n\tsst_drv_ctx->sst_state = SST_FW_RUNNING;\n\treturn ret_val;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}