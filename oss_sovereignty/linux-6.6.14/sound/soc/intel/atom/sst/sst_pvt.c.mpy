{
  "module_name": "sst_pvt.c",
  "hash_id": "707b158fd610985050a7ad1fbccfeb9e70307d0f852e1e6edc8b09735b542412",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_pvt.c",
  "human_readable_source": "\n \n#include <linux/kobject.h>\n#include <linux/pci.h>\n#include <linux/fs.h>\n#include <linux/firmware.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <sound/asound.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\nint sst_shim_write(void __iomem *addr, int offset, int value)\n{\n\twritel(value, addr + offset);\n\treturn 0;\n}\n\nu32 sst_shim_read(void __iomem *addr, int offset)\n{\n\treturn readl(addr + offset);\n}\n\nu64 sst_reg_read64(void __iomem *addr, int offset)\n{\n\tu64 val = 0;\n\n\tmemcpy_fromio(&val, addr + offset, sizeof(val));\n\n\treturn val;\n}\n\nint sst_shim_write64(void __iomem *addr, int offset, u64 value)\n{\n\tmemcpy_toio(addr + offset, &value, sizeof(value));\n\treturn 0;\n}\n\nu64 sst_shim_read64(void __iomem *addr, int offset)\n{\n\tu64 val = 0;\n\n\tmemcpy_fromio(&val, addr + offset, sizeof(val));\n\treturn val;\n}\n\nvoid sst_set_fw_state_locked(\n\t\tstruct intel_sst_drv *sst_drv_ctx, int sst_state)\n{\n\tmutex_lock(&sst_drv_ctx->sst_lock);\n\tsst_drv_ctx->sst_state = sst_state;\n\tmutex_unlock(&sst_drv_ctx->sst_lock);\n}\n\n \nint sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,\n\t\t\t\tstruct sst_block *block)\n{\n\tint retval = 0;\n\n\tif (!wait_event_interruptible(sst_drv_ctx->wait_queue,\n\t\t\t\tblock->condition)) {\n\t\t \n\t\tif (block->ret_code < 0) {\n\t\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\t\"stream failed %d\\n\", block->ret_code);\n\t\t\tretval = -EBUSY;\n\t\t} else {\n\t\t\tdev_dbg(sst_drv_ctx->dev, \"event up\\n\");\n\t\t\tretval = 0;\n\t\t}\n\t} else {\n\t\tdev_err(sst_drv_ctx->dev, \"signal interrupted\\n\");\n\t\tretval = -EINTR;\n\t}\n\treturn retval;\n\n}\n\n \nint sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx, struct sst_block *block)\n{\n\tint retval = 0;\n\n\t \n\tdev_dbg(sst_drv_ctx->dev,\n\t\t\"waiting for condition %x ipc %d drv_id %d\\n\",\n\t\tblock->condition, block->msg_id, block->drv_id);\n\tif (wait_event_timeout(sst_drv_ctx->wait_queue,\n\t\t\t\tblock->condition,\n\t\t\t\tmsecs_to_jiffies(SST_BLOCK_TIMEOUT))) {\n\t\t \n\t\tdev_dbg(sst_drv_ctx->dev, \"Event wake %x\\n\",\n\t\t\t\tblock->condition);\n\t\tdev_dbg(sst_drv_ctx->dev, \"message ret: %d\\n\",\n\t\t\t\tblock->ret_code);\n\t\tretval = -block->ret_code;\n\t} else {\n\t\tblock->on = false;\n\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\"Wait timed-out condition:%#x, msg_id:%#x fw_state %#x\\n\",\n\t\t\tblock->condition, block->msg_id, sst_drv_ctx->sst_state);\n\t\tsst_drv_ctx->sst_state = SST_RESET;\n\n\t\tretval = -EBUSY;\n\t}\n\treturn retval;\n}\n\n \nint sst_create_ipc_msg(struct ipc_post **arg, bool large)\n{\n\tstruct ipc_post *msg;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tif (large) {\n\t\tmsg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);\n\t\tif (!msg->mailbox_data) {\n\t\t\tkfree(msg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tmsg->mailbox_data = NULL;\n\t}\n\tmsg->is_large = large;\n\t*arg = msg;\n\treturn 0;\n}\n\n \nint sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,\n\t\tstruct intel_sst_drv *sst_drv_ctx, struct sst_block **block,\n\t\tu32 msg_id, u32 drv_id)\n{\n\tint retval;\n\n\tretval = sst_create_ipc_msg(arg, large);\n\tif (retval)\n\t\treturn retval;\n\t*block = sst_create_block(sst_drv_ctx, msg_id, drv_id);\n\tif (*block == NULL) {\n\t\tkfree(*arg);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nvoid sst_clean_stream(struct stream_info *stream)\n{\n\tstream->status = STREAM_UN_INIT;\n\tstream->prev = STREAM_UN_INIT;\n\tmutex_lock(&stream->lock);\n\tstream->cumm_bytes = 0;\n\tmutex_unlock(&stream->lock);\n}\n\nint sst_prepare_and_post_msg(struct intel_sst_drv *sst,\n\t\tint task_id, int ipc_msg, int cmd_id, int pipe_id,\n\t\tsize_t mbox_data_len, const void *mbox_data, void **data,\n\t\tbool large, bool fill_dsp, bool sync, bool response)\n{\n\tstruct sst_block *block = NULL;\n\tstruct ipc_post *msg = NULL;\n\tstruct ipc_dsp_hdr dsp_hdr;\n\tint ret = 0, pvt_id;\n\n\tpvt_id = sst_assign_pvt_id(sst);\n\tif (pvt_id < 0)\n\t\treturn pvt_id;\n\n\tif (response)\n\t\tret = sst_create_block_and_ipc_msg(\n\t\t\t\t&msg, large, sst, &block, ipc_msg, pvt_id);\n\telse\n\t\tret = sst_create_ipc_msg(&msg, large);\n\n\tif (ret < 0) {\n\t\ttest_and_clear_bit(pvt_id, &sst->pvt_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(sst->dev, \"pvt_id = %d, pipe id = %d, task = %d ipc_msg: %d\\n\",\n\t\t pvt_id, pipe_id, task_id, ipc_msg);\n\tsst_fill_header_mrfld(&msg->mrfld_header, ipc_msg,\n\t\t\t\t\ttask_id, large, pvt_id);\n\tmsg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr) + mbox_data_len;\n\tmsg->mrfld_header.p.header_high.part.res_rqd = !sync;\n\tdev_dbg(sst->dev, \"header:%x\\n\",\n\t\t\tmsg->mrfld_header.p.header_high.full);\n\tdev_dbg(sst->dev, \"response rqd: %x\",\n\t\t\tmsg->mrfld_header.p.header_high.part.res_rqd);\n\tdev_dbg(sst->dev, \"msg->mrfld_header.p.header_low_payload:%d\",\n\t\t\tmsg->mrfld_header.p.header_low_payload);\n\tif (fill_dsp) {\n\t\tsst_fill_header_dsp(&dsp_hdr, cmd_id, pipe_id, mbox_data_len);\n\t\tmemcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));\n\t\tif (mbox_data_len) {\n\t\t\tmemcpy(msg->mailbox_data + sizeof(dsp_hdr),\n\t\t\t\t\tmbox_data, mbox_data_len);\n\t\t}\n\t}\n\n\tif (sync)\n\t\tsst->ops->post_message(sst, msg, true);\n\telse\n\t\tsst_add_to_dispatch_list_and_post(sst, msg);\n\n\tif (response) {\n\t\tret = sst_wait_timeout(sst, block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (data && block->data) {\n\t\t\t*data = kmemdup(block->data, block->size, GFP_KERNEL);\n\t\t\tif (!*data) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (response)\n\t\tsst_free_block(sst, block);\n\ttest_and_clear_bit(pvt_id, &sst->pvt_id);\n\treturn ret;\n}\n\nint sst_pm_runtime_put(struct intel_sst_drv *sst_drv)\n{\n\tint ret;\n\n\tpm_runtime_mark_last_busy(sst_drv->dev);\n\tret = pm_runtime_put_autosuspend(sst_drv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nvoid sst_fill_header_mrfld(union ipc_header_mrfld *header,\n\t\t\t\tint msg, int task_id, int large, int drv_id)\n{\n\theader->full = 0;\n\theader->p.header_high.part.msg_id = msg;\n\theader->p.header_high.part.task_id = task_id;\n\theader->p.header_high.part.large = large;\n\theader->p.header_high.part.drv_id = drv_id;\n\theader->p.header_high.part.done = 0;\n\theader->p.header_high.part.busy = 1;\n\theader->p.header_high.part.res_rqd = 1;\n}\n\nvoid sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,\n\t\t\t\t\tint pipe_id, int len)\n{\n\tdsp->cmd_id = msg;\n\tdsp->mod_index_id = 0xff;\n\tdsp->pipe_id = pipe_id;\n\tdsp->length = len;\n\tdsp->mod_id = 0;\n}\n\n#define SST_MAX_BLOCKS 15\n \nint sst_assign_pvt_id(struct intel_sst_drv *drv)\n{\n\tint local;\n\n\tspin_lock(&drv->block_lock);\n\t \n\tlocal = ffz(drv->pvt_id);\n\tdev_dbg(drv->dev, \"pvt_id assigned --> %d\\n\", local);\n\tif (local >= SST_MAX_BLOCKS){\n\t\tspin_unlock(&drv->block_lock);\n\t\tdev_err(drv->dev, \"PVT _ID error: no free id blocks \");\n\t\treturn -EINVAL;\n\t}\n\t \n\tchange_bit(local, &drv->pvt_id);\n\tspin_unlock(&drv->block_lock);\n\treturn local;\n}\n\nint sst_validate_strid(\n\t\tstruct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tif (str_id <= 0 || str_id > sst_drv_ctx->info.max_streams) {\n\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\"SST ERR: invalid stream id : %d, max %d\\n\",\n\t\t\tstr_id, sst_drv_ctx->info.max_streams);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct stream_info *get_stream_info(\n\t\tstruct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tif (sst_validate_strid(sst_drv_ctx, str_id))\n\t\treturn NULL;\n\treturn &sst_drv_ctx->streams[str_id];\n}\n\nint get_stream_id_mrfld(struct intel_sst_drv *sst_drv_ctx,\n\t\tu32 pipe_id)\n{\n\tint i;\n\n\tfor (i = 1; i <= sst_drv_ctx->info.max_streams; i++)\n\t\tif (pipe_id == sst_drv_ctx->streams[i].pipe_id)\n\t\t\treturn i;\n\n\tdev_dbg(sst_drv_ctx->dev, \"no such pipe_id(%u)\", pipe_id);\n\treturn -1;\n}\n\nu32 relocate_imr_addr_mrfld(u32 base_addr)\n{\n\t \n\t \n\tbase_addr = MRFLD_FW_VIRTUAL_BASE + (base_addr % (512 * 1024 * 1024));\n\treturn base_addr;\n}\nEXPORT_SYMBOL_GPL(relocate_imr_addr_mrfld);\n\nvoid sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,\n\t\t\t\t\t\tstruct ipc_post *msg)\n{\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);\n\tlist_add_tail(&msg->node, &sst->ipc_dispatch_list);\n\tspin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);\n\tsst->ops->post_message(sst, NULL, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}