{
  "module_name": "sst.c",
  "hash_id": "dc97b1bed7a4463aa47329949e1c325e7abcb84117e38a98e8dcba19a0eb35f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/async.h>\n#include <linux/acpi.h>\n#include <linux/sysfs.h>\n#include <sound/core.h>\n#include <sound/soc.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\nMODULE_AUTHOR(\"Vinod Koul <vinod.koul@intel.com>\");\nMODULE_AUTHOR(\"Harsha Priya <priya.harsha@intel.com>\");\nMODULE_DESCRIPTION(\"Intel (R) SST(R) Audio Engine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic inline bool sst_is_process_reply(u32 msg_id)\n{\n\treturn ((msg_id & PROCESS_MSG) ? true : false);\n}\n\nstatic inline bool sst_validate_mailbox_size(unsigned int size)\n{\n\treturn ((size <= SST_MAILBOX_SIZE) ? true : false);\n}\n\nstatic irqreturn_t intel_sst_interrupt_mrfld(int irq, void *context)\n{\n\tunion interrupt_reg_mrfld isr;\n\tunion ipc_header_mrfld header;\n\tunion sst_imr_reg_mrfld imr;\n\tstruct ipc_post *msg = NULL;\n\tunsigned int size;\n\tstruct intel_sst_drv *drv = (struct intel_sst_drv *) context;\n\tirqreturn_t retval = IRQ_HANDLED;\n\n\t \n\tisr.full = sst_shim_read64(drv->shim, SST_ISRX);\n\n\tif (isr.part.done_interrupt) {\n\t\t \n\t\tspin_lock(&drv->ipc_spin_lock);\n\t\theader.full = sst_shim_read64(drv->shim,\n\t\t\t\t\tdrv->ipc_reg.ipcx);\n\t\theader.p.header_high.part.done = 0;\n\t\tsst_shim_write64(drv->shim, drv->ipc_reg.ipcx, header.full);\n\n\t\t ;\n\t\tisr.part.done_interrupt = 1;\n\t\tsst_shim_write64(drv->shim, SST_ISRX, isr.full);\n\t\tspin_unlock(&drv->ipc_spin_lock);\n\n\t\t \n\t\tqueue_work(drv->post_msg_wq, &drv->ipc_post_msg_wq);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif (isr.part.busy_interrupt) {\n\t\t \n\t\tspin_lock(&drv->ipc_spin_lock);\n\t\timr.full = sst_shim_read64(drv->shim, SST_IMRX);\n\t\timr.part.busy_interrupt = 1;\n\t\tsst_shim_write64(drv->shim, SST_IMRX, imr.full);\n\t\tspin_unlock(&drv->ipc_spin_lock);\n\t\theader.full =  sst_shim_read64(drv->shim, drv->ipc_reg.ipcd);\n\n\t\tif (sst_create_ipc_msg(&msg, header.p.header_high.part.large)) {\n\t\t\tdrv->ops->clear_interrupt(drv);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (header.p.header_high.part.large) {\n\t\t\tsize = header.p.header_low_payload;\n\t\t\tif (sst_validate_mailbox_size(size)) {\n\t\t\t\tmemcpy_fromio(msg->mailbox_data,\n\t\t\t\t\tdrv->mailbox + drv->mailbox_recv_offset, size);\n\t\t\t} else {\n\t\t\t\tdev_err(drv->dev,\n\t\t\t\t\t\"Mailbox not copied, payload size is: %u\\n\", size);\n\t\t\t\theader.p.header_low_payload = 0;\n\t\t\t}\n\t\t}\n\n\t\tmsg->mrfld_header = header;\n\t\tmsg->is_process_reply =\n\t\t\tsst_is_process_reply(header.p.header_high.part.msg_id);\n\t\tspin_lock(&drv->rx_msg_lock);\n\t\tlist_add_tail(&msg->node, &drv->rx_list);\n\t\tspin_unlock(&drv->rx_msg_lock);\n\t\tdrv->ops->clear_interrupt(drv);\n\t\tretval = IRQ_WAKE_THREAD;\n\t}\n\treturn retval;\n}\n\nstatic irqreturn_t intel_sst_irq_thread_mrfld(int irq, void *context)\n{\n\tstruct intel_sst_drv *drv = (struct intel_sst_drv *) context;\n\tstruct ipc_post *__msg, *msg;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&drv->rx_msg_lock, irq_flags);\n\tif (list_empty(&drv->rx_list)) {\n\t\tspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tlist_for_each_entry_safe(msg, __msg, &drv->rx_list, node) {\n\t\tlist_del(&msg->node);\n\t\tspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\n\t\tif (msg->is_process_reply)\n\t\t\tdrv->ops->process_message(msg);\n\t\telse\n\t\t\tdrv->ops->process_reply(drv, msg);\n\n\t\tif (msg->is_large)\n\t\t\tkfree(msg->mailbox_data);\n\t\tkfree(msg);\n\t\tspin_lock_irqsave(&drv->rx_msg_lock, irq_flags);\n\t}\n\tspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int sst_save_dsp_context_v2(struct intel_sst_drv *sst)\n{\n\tint ret = 0;\n\n\tret = sst_prepare_and_post_msg(sst, SST_TASK_ID_MEDIA, IPC_CMD,\n\t\t\tIPC_PREP_D3, PIPE_RSVD, 0, NULL, NULL,\n\t\t\ttrue, true, false, true);\n\n\tif (ret < 0) {\n\t\tdev_err(sst->dev, \"not suspending FW!!, Err: %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct intel_sst_ops mrfld_ops = {\n\t.interrupt = intel_sst_interrupt_mrfld,\n\t.irq_thread = intel_sst_irq_thread_mrfld,\n\t.clear_interrupt = intel_sst_clear_intr_mrfld,\n\t.start = sst_start_mrfld,\n\t.reset = intel_sst_reset_dsp_mrfld,\n\t.post_message = sst_post_message_mrfld,\n\t.process_reply = sst_process_reply_mrfld,\n\t.save_dsp_context =  sst_save_dsp_context_v2,\n\t.alloc_stream = sst_alloc_stream_mrfld,\n\t.post_download = sst_post_download_mrfld,\n};\n\nint sst_driver_ops(struct intel_sst_drv *sst)\n{\n\n\tswitch (sst->dev_id) {\n\tcase PCI_DEVICE_ID_INTEL_SST_TNG:\n\tcase PCI_DEVICE_ID_INTEL_SST_BYT:\n\tcase PCI_DEVICE_ID_INTEL_SST_BSW:\n\t\tsst->tstamp = SST_TIME_STAMP_MRFLD;\n\t\tsst->ops = &mrfld_ops;\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(sst->dev,\n\t\t\t\"SST Driver capabilities missing for dev_id: %x\",\n\t\t\tsst->dev_id);\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid sst_process_pending_msg(struct work_struct *work)\n{\n\tstruct intel_sst_drv *ctx = container_of(work,\n\t\t\tstruct intel_sst_drv, ipc_post_msg_wq);\n\n\tctx->ops->post_message(ctx, NULL, false);\n}\n\nstatic int sst_workqueue_init(struct intel_sst_drv *ctx)\n{\n\tINIT_LIST_HEAD(&ctx->memcpy_list);\n\tINIT_LIST_HEAD(&ctx->rx_list);\n\tINIT_LIST_HEAD(&ctx->ipc_dispatch_list);\n\tINIT_LIST_HEAD(&ctx->block_list);\n\tINIT_WORK(&ctx->ipc_post_msg_wq, sst_process_pending_msg);\n\tinit_waitqueue_head(&ctx->wait_queue);\n\n\tctx->post_msg_wq =\n\t\tcreate_singlethread_workqueue(\"sst_post_msg_wq\");\n\tif (!ctx->post_msg_wq)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic void sst_init_locks(struct intel_sst_drv *ctx)\n{\n\tmutex_init(&ctx->sst_lock);\n\tspin_lock_init(&ctx->rx_msg_lock);\n\tspin_lock_init(&ctx->ipc_spin_lock);\n\tspin_lock_init(&ctx->block_lock);\n}\n\n \nint sst_alloc_drv_context(struct intel_sst_drv **ctx,\n\t\tstruct device *dev, unsigned short dev_id)\n{\n\t*ctx = devm_kzalloc(dev, sizeof(struct intel_sst_drv), GFP_KERNEL);\n\tif (!(*ctx))\n\t\treturn -ENOMEM;\n\n\t(*ctx)->dev = dev;\n\t(*ctx)->dev_id = dev_id;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sst_alloc_drv_context);\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->fw_version.type == 0 && ctx->fw_version.major == 0 &&\n\t    ctx->fw_version.minor == 0 && ctx->fw_version.build == 0)\n\t\treturn sysfs_emit(buf, \"FW not yet loaded\\n\");\n\telse\n\t\treturn sysfs_emit(buf, \"v%02x.%02x.%02x.%02x\\n\",\n\t\t\t\t  ctx->fw_version.type, ctx->fw_version.major,\n\t\t\t\t  ctx->fw_version.minor, ctx->fw_version.build);\n\n}\n\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic const struct attribute *sst_fw_version_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sst_fw_version_attr_group = {\n\t.attrs = (struct attribute **)sst_fw_version_attrs,\n};\n\nint sst_context_init(struct intel_sst_drv *ctx)\n{\n\tint ret = 0, i;\n\n\tif (!ctx->pdata)\n\t\treturn -EINVAL;\n\n\tif (!ctx->pdata->probe_data)\n\t\treturn -EINVAL;\n\n\tmemcpy(&ctx->info, ctx->pdata->probe_data, sizeof(ctx->info));\n\n\tret = sst_driver_ops(ctx);\n\tif (ret != 0)\n\t\treturn -EINVAL;\n\n\tsst_init_locks(ctx);\n\tsst_set_fw_state_locked(ctx, SST_RESET);\n\n\t \n\tctx->pvt_id = 1;\n\tctx->stream_cnt = 0;\n\tctx->fw_in_mem = NULL;\n\t \n\tctx->use_dma = 0;\n\tctx->use_lli = 0;\n\n\tif (sst_workqueue_init(ctx))\n\t\treturn -EINVAL;\n\n\tctx->mailbox_recv_offset = ctx->pdata->ipc_info->mbox_recv_off;\n\tctx->ipc_reg.ipcx = SST_IPCX + ctx->pdata->ipc_info->ipc_offset;\n\tctx->ipc_reg.ipcd = SST_IPCD + ctx->pdata->ipc_info->ipc_offset;\n\n\tdev_info(ctx->dev, \"Got drv data max stream %d\\n\",\n\t\t\t\tctx->info.max_streams);\n\n\tfor (i = 1; i <= ctx->info.max_streams; i++) {\n\t\tstruct stream_info *stream = &ctx->streams[i];\n\n\t\tmemset(stream, 0, sizeof(*stream));\n\t\tstream->pipe_id = PIPE_RSVD;\n\t\tmutex_init(&stream->lock);\n\t}\n\n\t \n\tret = devm_request_threaded_irq(ctx->dev, ctx->irq_num, ctx->ops->interrupt,\n\t\t\t\t\tctx->ops->irq_thread, 0, SST_DRV_NAME,\n\t\t\t\t\tctx);\n\tif (ret)\n\t\tgoto do_free_mem;\n\n\tdev_dbg(ctx->dev, \"Registered IRQ %#x\\n\", ctx->irq_num);\n\n\t \n\tsst_shim_write64(ctx->shim, SST_IMRX, 0xFFFF0038);\n\n\tctx->qos = devm_kzalloc(ctx->dev,\n\t\tsizeof(struct pm_qos_request), GFP_KERNEL);\n\tif (!ctx->qos) {\n\t\tret = -ENOMEM;\n\t\tgoto do_free_mem;\n\t}\n\tcpu_latency_qos_add_request(ctx->qos, PM_QOS_DEFAULT_VALUE);\n\n\tdev_dbg(ctx->dev, \"Requesting FW %s now...\\n\", ctx->firmware_name);\n\tret = request_firmware_nowait(THIS_MODULE, true, ctx->firmware_name,\n\t\t\t\t      ctx->dev, GFP_KERNEL, ctx, sst_firmware_load_cb);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"Firmware download failed:%d\\n\", ret);\n\t\tgoto do_free_mem;\n\t}\n\n\tret = sysfs_create_group(&ctx->dev->kobj,\n\t\t\t\t &sst_fw_version_attr_group);\n\tif (ret) {\n\t\tdev_err(ctx->dev,\n\t\t\t\"Unable to create sysfs\\n\");\n\t\tgoto err_sysfs;\n\t}\n\n\tsst_register(ctx->dev);\n\treturn 0;\nerr_sysfs:\n\tsysfs_remove_group(&ctx->dev->kobj, &sst_fw_version_attr_group);\n\ndo_free_mem:\n\tdestroy_workqueue(ctx->post_msg_wq);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sst_context_init);\n\nvoid sst_context_cleanup(struct intel_sst_drv *ctx)\n{\n\tpm_runtime_get_noresume(ctx->dev);\n\tpm_runtime_disable(ctx->dev);\n\tsst_unregister(ctx->dev);\n\tsst_set_fw_state_locked(ctx, SST_SHUTDOWN);\n\tsysfs_remove_group(&ctx->dev->kobj, &sst_fw_version_attr_group);\n\tdestroy_workqueue(ctx->post_msg_wq);\n\tcpu_latency_qos_remove_request(ctx->qos);\n\tkfree(ctx->fw_sg_list.src);\n\tkfree(ctx->fw_sg_list.dst);\n\tctx->fw_sg_list.list_len = 0;\n\tkfree(ctx->fw_in_mem);\n\tctx->fw_in_mem = NULL;\n\tsst_memcpy_free_resources(ctx);\n}\nEXPORT_SYMBOL_GPL(sst_context_cleanup);\n\nvoid sst_configure_runtime_pm(struct intel_sst_drv *ctx)\n{\n\tpm_runtime_set_autosuspend_delay(ctx->dev, SST_SUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(ctx->dev);\n\t \n\n\tif (!acpi_disabled)\n\t\tpm_runtime_set_active(ctx->dev);\n\n\tpm_runtime_enable(ctx->dev);\n\n\tif (acpi_disabled)\n\t\tpm_runtime_set_active(ctx->dev);\n\telse\n\t\tpm_runtime_put_noidle(ctx->dev);\n}\nEXPORT_SYMBOL_GPL(sst_configure_runtime_pm);\n\nstatic int intel_sst_runtime_suspend(struct device *dev)\n{\n\tint ret = 0;\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\n\tif (ctx->sst_state == SST_RESET) {\n\t\tdev_dbg(dev, \"LPE is already in RESET state, No action\\n\");\n\t\treturn 0;\n\t}\n\t \n\tif (ctx->ops->save_dsp_context(ctx))\n\t\treturn -EBUSY;\n\n\t \n\tsst_set_fw_state_locked(ctx, SST_RESET);\n\n\tsynchronize_irq(ctx->irq_num);\n\tflush_workqueue(ctx->post_msg_wq);\n\n\tctx->ops->reset(ctx);\n\n\treturn ret;\n}\n\nstatic int intel_sst_suspend(struct device *dev)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\tstruct sst_fw_save *fw_save;\n\tint i, ret;\n\n\t \n\tif (ctx->sst_state == SST_RESET)\n\t\treturn 0;\n\n\t \n\tfor (i = 1; i <= ctx->info.max_streams; i++) {\n\t\tstruct stream_info *stream = &ctx->streams[i];\n\n\t\tif (stream->status == STREAM_RUNNING) {\n\t\t\tdev_err(dev, \"stream %d is running, can't suspend, abort\\n\", i);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (ctx->pdata->streams_lost_on_suspend) {\n\t\t\tstream->resume_status = stream->status;\n\t\t\tstream->resume_prev = stream->prev;\n\t\t\tif (stream->status != STREAM_UN_INIT)\n\t\t\t\tsst_free_stream(ctx, i);\n\t\t}\n\t}\n\tsynchronize_irq(ctx->irq_num);\n\tflush_workqueue(ctx->post_msg_wq);\n\n\t \n\tsst_set_fw_state_locked(ctx, SST_RESET);\n\n\t \n\tif (ctx->ops->save_dsp_context(ctx))\n\t\treturn -EBUSY;\n\n\t \n\tfw_save = kzalloc(sizeof(*fw_save), GFP_KERNEL);\n\tif (!fw_save)\n\t\treturn -ENOMEM;\n\tfw_save->iram = kvzalloc(ctx->iram_end - ctx->iram_base, GFP_KERNEL);\n\tif (!fw_save->iram) {\n\t\tret = -ENOMEM;\n\t\tgoto iram;\n\t}\n\tfw_save->dram = kvzalloc(ctx->dram_end - ctx->dram_base, GFP_KERNEL);\n\tif (!fw_save->dram) {\n\t\tret = -ENOMEM;\n\t\tgoto dram;\n\t}\n\tfw_save->sram = kvzalloc(SST_MAILBOX_SIZE, GFP_KERNEL);\n\tif (!fw_save->sram) {\n\t\tret = -ENOMEM;\n\t\tgoto sram;\n\t}\n\n\tfw_save->ddr = kvzalloc(ctx->ddr_end - ctx->ddr_base, GFP_KERNEL);\n\tif (!fw_save->ddr) {\n\t\tret = -ENOMEM;\n\t\tgoto ddr;\n\t}\n\n\tmemcpy32_fromio(fw_save->iram, ctx->iram, ctx->iram_end - ctx->iram_base);\n\tmemcpy32_fromio(fw_save->dram, ctx->dram, ctx->dram_end - ctx->dram_base);\n\tmemcpy32_fromio(fw_save->sram, ctx->mailbox, SST_MAILBOX_SIZE);\n\tmemcpy32_fromio(fw_save->ddr, ctx->ddr, ctx->ddr_end - ctx->ddr_base);\n\n\tctx->fw_save = fw_save;\n\tctx->ops->reset(ctx);\n\treturn 0;\nddr:\n\tkvfree(fw_save->sram);\nsram:\n\tkvfree(fw_save->dram);\ndram:\n\tkvfree(fw_save->iram);\niram:\n\tkfree(fw_save);\n\treturn ret;\n}\n\nstatic int intel_sst_resume(struct device *dev)\n{\n\tstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\n\tstruct sst_fw_save *fw_save = ctx->fw_save;\n\tstruct sst_block *block;\n\tint i, ret = 0;\n\n\tif (!fw_save)\n\t\treturn 0;\n\n\tsst_set_fw_state_locked(ctx, SST_FW_LOADING);\n\n\t \n\tctx->ops->reset(ctx);\n\n\tctx->fw_save = NULL;\n\n\tmemcpy32_toio(ctx->iram, fw_save->iram, ctx->iram_end - ctx->iram_base);\n\tmemcpy32_toio(ctx->dram, fw_save->dram, ctx->dram_end - ctx->dram_base);\n\tmemcpy32_toio(ctx->mailbox, fw_save->sram, SST_MAILBOX_SIZE);\n\tmemcpy32_toio(ctx->ddr, fw_save->ddr, ctx->ddr_end - ctx->ddr_base);\n\n\tkvfree(fw_save->sram);\n\tkvfree(fw_save->dram);\n\tkvfree(fw_save->iram);\n\tkvfree(fw_save->ddr);\n\tkfree(fw_save);\n\n\tblock = sst_create_block(ctx, 0, FW_DWNL_ID);\n\tif (block == NULL)\n\t\treturn -ENOMEM;\n\n\n\t \n\tctx->ops->start(ctx);\n\tret = sst_wait_timeout(ctx, block);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"fw download failed %d\\n\", ret);\n\t\t \n\t\tret = -EBUSY;\n\n\t} else {\n\t\tsst_set_fw_state_locked(ctx, SST_FW_RUNNING);\n\t}\n\n\tif (ctx->pdata->streams_lost_on_suspend) {\n\t\tfor (i = 1; i <= ctx->info.max_streams; i++) {\n\t\t\tstruct stream_info *stream = &ctx->streams[i];\n\n\t\t\tif (stream->resume_status != STREAM_UN_INIT) {\n\t\t\t\tdev_dbg(ctx->dev, \"Re-allocing stream %d status %d prev %d\\n\",\n\t\t\t\t\ti, stream->resume_status,\n\t\t\t\t\tstream->resume_prev);\n\t\t\t\tsst_realloc_stream(ctx, i);\n\t\t\t\tstream->status = stream->resume_status;\n\t\t\t\tstream->prev = stream->resume_prev;\n\t\t\t}\n\t\t}\n\t}\n\n\tsst_free_block(ctx, block);\n\treturn ret;\n}\n\nconst struct dev_pm_ops intel_sst_pm = {\n\t.suspend = intel_sst_suspend,\n\t.resume = intel_sst_resume,\n\t.runtime_suspend = intel_sst_runtime_suspend,\n};\nEXPORT_SYMBOL_GPL(intel_sst_pm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}