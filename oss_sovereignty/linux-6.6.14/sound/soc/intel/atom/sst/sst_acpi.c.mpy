{
  "module_name": "sst_acpi.c",
  "hash_id": "150378facf3ef66f29a9af66d9f86b6b2d386fc6828370752c6b435a7307d0fd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <linux/pm_qos.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <asm/platform_sst_audio.h>\n#include <sound/core.h>\n#include <sound/intel-dsp-config.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <acpi/acbuffer.h>\n#include <acpi/platform/acenv.h>\n#include <acpi/platform/aclinux.h>\n#include <acpi/actypes.h>\n#include <acpi/acpi_bus.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include \"../sst-mfld-platform.h\"\n#include \"../../common/soc-intel-quirks.h\"\n#include \"sst.h\"\n\n \n#define SST_BYT_IRAM_PHY_START\t0xff2c0000\n#define SST_BYT_IRAM_PHY_END\t0xff2d4000\n#define SST_BYT_DRAM_PHY_START\t0xff300000\n#define SST_BYT_DRAM_PHY_END\t0xff320000\n#define SST_BYT_IMR_VIRT_START\t0xc0000000  \n#define SST_BYT_IMR_VIRT_END\t0xc01fffff\n#define SST_BYT_SHIM_PHY_ADDR\t0xff340000\n#define SST_BYT_MBOX_PHY_ADDR\t0xff344000\n#define SST_BYT_DMA0_PHY_ADDR\t0xff298000\n#define SST_BYT_DMA1_PHY_ADDR\t0xff29c000\n#define SST_BYT_SSP0_PHY_ADDR\t0xff2a0000\n#define SST_BYT_SSP2_PHY_ADDR\t0xff2a2000\n\n#define BYT_FW_MOD_TABLE_OFFSET\t0x80000\n#define BYT_FW_MOD_TABLE_SIZE\t0x100\n#define BYT_FW_MOD_OFFSET\t(BYT_FW_MOD_TABLE_OFFSET + BYT_FW_MOD_TABLE_SIZE)\n\nstatic const struct sst_info byt_fwparse_info = {\n\t.use_elf\t= false,\n\t.max_streams\t= 25,\n\t.iram_start\t= SST_BYT_IRAM_PHY_START,\n\t.iram_end\t= SST_BYT_IRAM_PHY_END,\n\t.iram_use\t= true,\n\t.dram_start\t= SST_BYT_DRAM_PHY_START,\n\t.dram_end\t= SST_BYT_DRAM_PHY_END,\n\t.dram_use\t= true,\n\t.imr_start\t= SST_BYT_IMR_VIRT_START,\n\t.imr_end\t= SST_BYT_IMR_VIRT_END,\n\t.imr_use\t= true,\n\t.mailbox_start\t= SST_BYT_MBOX_PHY_ADDR,\n\t.num_probes\t= 0,\n\t.lpe_viewpt_rqd  = true,\n};\n\nstatic const struct sst_ipc_info byt_ipc_info = {\n\t.ipc_offset = 0,\n\t.mbox_recv_off = 0x400,\n};\n\nstatic const struct sst_lib_dnld_info  byt_lib_dnld_info = {\n\t.mod_base           = SST_BYT_IMR_VIRT_START,\n\t.mod_end            = SST_BYT_IMR_VIRT_END,\n\t.mod_table_offset   = BYT_FW_MOD_TABLE_OFFSET,\n\t.mod_table_size     = BYT_FW_MOD_TABLE_SIZE,\n\t.mod_ddr_dnld       = false,\n};\n\nstatic const struct sst_res_info byt_rvp_res_info = {\n\t.shim_offset = 0x140000,\n\t.shim_size = 0x000100,\n\t.shim_phy_addr = SST_BYT_SHIM_PHY_ADDR,\n\t.ssp0_offset = 0xa0000,\n\t.ssp0_size = 0x1000,\n\t.dma0_offset = 0x98000,\n\t.dma0_size = 0x4000,\n\t.dma1_offset = 0x9c000,\n\t.dma1_size = 0x4000,\n\t.iram_offset = 0x0c0000,\n\t.iram_size = 0x14000,\n\t.dram_offset = 0x100000,\n\t.dram_size = 0x28000,\n\t.mbox_offset = 0x144000,\n\t.mbox_size = 0x1000,\n\t.acpi_lpe_res_index = 0,\n\t.acpi_ddr_index = 2,\n\t.acpi_ipc_irq_index = 5,\n};\n\n \nstatic const struct sst_res_info bytcr_res_info = {\n\t.shim_offset = 0x140000,\n\t.shim_size = 0x000100,\n\t.shim_phy_addr = SST_BYT_SHIM_PHY_ADDR,\n\t.ssp0_offset = 0xa0000,\n\t.ssp0_size = 0x1000,\n\t.dma0_offset = 0x98000,\n\t.dma0_size = 0x4000,\n\t.dma1_offset = 0x9c000,\n\t.dma1_size = 0x4000,\n\t.iram_offset = 0x0c0000,\n\t.iram_size = 0x14000,\n\t.dram_offset = 0x100000,\n\t.dram_size = 0x28000,\n\t.mbox_offset = 0x144000,\n\t.mbox_size = 0x1000,\n\t.acpi_lpe_res_index = 0,\n\t.acpi_ddr_index = 2,\n\t.acpi_ipc_irq_index = 0\n};\n\nstatic struct sst_platform_info byt_rvp_platform_data = {\n\t.probe_data = &byt_fwparse_info,\n\t.ipc_info = &byt_ipc_info,\n\t.lib_info = &byt_lib_dnld_info,\n\t.res_info = &byt_rvp_res_info,\n\t.platform = \"sst-mfld-platform\",\n\t.streams_lost_on_suspend = true,\n};\n\n \nstatic struct sst_platform_info chv_platform_data = {\n\t.probe_data = &byt_fwparse_info,\n\t.ipc_info = &byt_ipc_info,\n\t.lib_info = &byt_lib_dnld_info,\n\t.res_info = &byt_rvp_res_info,\n\t.platform = \"sst-mfld-platform\",\n};\n\nstatic int sst_platform_get_resources(struct intel_sst_drv *ctx)\n{\n\tstruct resource *rsrc;\n\tstruct platform_device *pdev = to_platform_device(ctx->dev);\n\n\t \n\t \n\trsrc = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\tctx->pdata->res_info->acpi_lpe_res_index);\n\tif (!rsrc) {\n\t\tdev_err(ctx->dev, \"Invalid SHIM base from IFWI\\n\");\n\t\treturn -EIO;\n\t}\n\tdev_info(ctx->dev, \"LPE base: %#x size:%#x\", (unsigned int) rsrc->start,\n\t\t\t\t\t(unsigned int)resource_size(rsrc));\n\n\tctx->iram_base = rsrc->start + ctx->pdata->res_info->iram_offset;\n\tctx->iram_end =  ctx->iram_base + ctx->pdata->res_info->iram_size - 1;\n\tdev_info(ctx->dev, \"IRAM base: %#x\", ctx->iram_base);\n\tctx->iram = devm_ioremap(ctx->dev, ctx->iram_base,\n\t\t\t\t\t ctx->pdata->res_info->iram_size);\n\tif (!ctx->iram) {\n\t\tdev_err(ctx->dev, \"unable to map IRAM\\n\");\n\t\treturn -EIO;\n\t}\n\n\tctx->dram_base = rsrc->start + ctx->pdata->res_info->dram_offset;\n\tctx->dram_end = ctx->dram_base + ctx->pdata->res_info->dram_size - 1;\n\tdev_info(ctx->dev, \"DRAM base: %#x\", ctx->dram_base);\n\tctx->dram = devm_ioremap(ctx->dev, ctx->dram_base,\n\t\t\t\t\t ctx->pdata->res_info->dram_size);\n\tif (!ctx->dram) {\n\t\tdev_err(ctx->dev, \"unable to map DRAM\\n\");\n\t\treturn -EIO;\n\t}\n\n\tctx->shim_phy_add = rsrc->start + ctx->pdata->res_info->shim_offset;\n\tdev_info(ctx->dev, \"SHIM base: %#x\", ctx->shim_phy_add);\n\tctx->shim = devm_ioremap(ctx->dev, ctx->shim_phy_add,\n\t\t\t\t\tctx->pdata->res_info->shim_size);\n\tif (!ctx->shim) {\n\t\tdev_err(ctx->dev, \"unable to map SHIM\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tctx->shim_phy_add = ctx->pdata->res_info->shim_phy_addr;\n\n\t \n\tctx->mailbox_add = rsrc->start + ctx->pdata->res_info->mbox_offset;\n\tdev_info(ctx->dev, \"Mailbox base: %#x\", ctx->mailbox_add);\n\tctx->mailbox = devm_ioremap(ctx->dev, ctx->mailbox_add,\n\t\t\t\t\t    ctx->pdata->res_info->mbox_size);\n\tif (!ctx->mailbox) {\n\t\tdev_err(ctx->dev, \"unable to map mailbox\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tctx->mailbox_add = ctx->info.mailbox_start;\n\n\trsrc = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\tctx->pdata->res_info->acpi_ddr_index);\n\tif (!rsrc) {\n\t\tdev_err(ctx->dev, \"Invalid DDR base from IFWI\\n\");\n\t\treturn -EIO;\n\t}\n\tctx->ddr_base = rsrc->start;\n\tctx->ddr_end = rsrc->end;\n\tdev_info(ctx->dev, \"DDR base: %#x\", ctx->ddr_base);\n\tctx->ddr = devm_ioremap(ctx->dev, ctx->ddr_base,\n\t\t\t\t\tresource_size(rsrc));\n\tif (!ctx->ddr) {\n\t\tdev_err(ctx->dev, \"unable to map DDR\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tctx->irq_num = platform_get_irq(pdev,\n\t\t\t\tctx->pdata->res_info->acpi_ipc_irq_index);\n\tif (ctx->irq_num <= 0)\n\t\treturn ctx->irq_num < 0 ? ctx->irq_num : -EIO;\n\n\treturn 0;\n}\n\nstatic int sst_acpi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\tstruct intel_sst_drv *ctx;\n\tconst struct acpi_device_id *id;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct platform_device *mdev;\n\tstruct platform_device *plat_dev;\n\tstruct sst_platform_info *pdata;\n\tunsigned int dev_id;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = snd_intel_acpi_dsp_driver_probe(dev, id->id);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_SST) {\n\t\tdev_dbg(dev, \"SST ACPI driver not selected, aborting probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(dev, \"for %s\\n\", id->id);\n\n\tmach = (struct snd_soc_acpi_mach *)id->driver_data;\n\tmach = snd_soc_acpi_find_machine(mach);\n\tif (mach == NULL) {\n\t\tdev_err(dev, \"No matching machine driver found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (soc_intel_is_byt())\n\t\tmach->pdata = &byt_rvp_platform_data;\n\telse\n\t\tmach->pdata = &chv_platform_data;\n\tpdata = mach->pdata;\n\n\tret = kstrtouint(id->id, 16, &dev_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unique device id conversion error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"ACPI device id: %x\\n\", dev_id);\n\n\tret = sst_alloc_drv_context(&ctx, dev, dev_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (soc_intel_is_byt_cr(pdev)) {\n\t\t \n\t\tbyt_rvp_platform_data.res_info = &bytcr_res_info;\n\t}\n\n\t \n\tmach->mach_params.acpi_ipc_irq_index =\n\t\tpdata->res_info->acpi_ipc_irq_index;\n\n\tplat_dev = platform_device_register_data(dev, pdata->platform, -1,\n\t\t\t\t\t\tNULL, 0);\n\tif (IS_ERR(plat_dev)) {\n\t\tdev_err(dev, \"Failed to create machine device: %s\\n\",\n\t\t\tpdata->platform);\n\t\treturn PTR_ERR(plat_dev);\n\t}\n\n\t \n\tmdev = platform_device_register_data(dev, mach->drv_name, -1,\n\t\t\t\t\t(const void *)mach, sizeof(*mach));\n\tif (IS_ERR(mdev)) {\n\t\tdev_err(dev, \"Failed to create machine device: %s\\n\",\n\t\t\tmach->drv_name);\n\t\treturn PTR_ERR(mdev);\n\t}\n\n\t \n\tctx->pdata = pdata;\n\tstrcpy(ctx->firmware_name, mach->fw_filename);\n\n\tret = sst_platform_get_resources(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sst_context_init(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsst_configure_runtime_pm(ctx);\n\tplatform_set_drvdata(pdev, ctx);\n\treturn ret;\n}\n\n \nstatic void sst_acpi_remove(struct platform_device *pdev)\n{\n\tstruct intel_sst_drv *ctx;\n\n\tctx = platform_get_drvdata(pdev);\n\tsst_context_cleanup(ctx);\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct acpi_device_id sst_acpi_ids[] = {\n\t{ \"80860F28\", (unsigned long)&snd_soc_acpi_intel_baytrail_machines},\n\t{ \"808622A8\", (unsigned long)&snd_soc_acpi_intel_cherrytrail_machines},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(acpi, sst_acpi_ids);\n\nstatic struct platform_driver sst_acpi_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"intel_sst_acpi\",\n\t\t.acpi_match_table\t= ACPI_PTR(sst_acpi_ids),\n\t\t.pm\t\t\t= &intel_sst_pm,\n\t},\n\t.probe\t= sst_acpi_probe,\n\t.remove_new = sst_acpi_remove,\n};\n\nmodule_platform_driver(sst_acpi_driver);\n\nMODULE_DESCRIPTION(\"Intel (R) SST(R) Audio Engine ACPI Driver\");\nMODULE_AUTHOR(\"Ramesh Babu K V\");\nMODULE_AUTHOR(\"Omair Mohammed Abdullah\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"sst\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}