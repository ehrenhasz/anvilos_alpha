{
  "module_name": "sst_stream.c",
  "hash_id": "a576f3fca3f1f4525f9c61b90e8592bbdb41a8d5ffad166fdc9e82d007368e31",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst/sst_stream.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/platform_sst_audio.h>\n#include \"../sst-mfld-platform.h\"\n#include \"sst.h\"\n\nint sst_alloc_stream_mrfld(struct intel_sst_drv *sst_drv_ctx, void *params)\n{\n\tstruct snd_pcm_params *pcm_params;\n\tstruct snd_sst_params *str_params;\n\tstruct snd_sst_tstamp fw_tstamp;\n\tstruct stream_info *str_info;\n\tint i, num_ch, str_id;\n\n\tdev_dbg(sst_drv_ctx->dev, \"Enter\\n\");\n\n\tstr_params = (struct snd_sst_params *)params;\n\tstr_id = str_params->stream_id;\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\tmemset(&str_info->alloc_param, 0, sizeof(str_info->alloc_param));\n\tstr_info->alloc_param.operation = str_params->ops;\n\tstr_info->alloc_param.codec_type = str_params->codec;\n\tstr_info->alloc_param.sg_count = str_params->aparams.sg_count;\n\tstr_info->alloc_param.ring_buf_info[0].addr =\n\t\tstr_params->aparams.ring_buf_info[0].addr;\n\tstr_info->alloc_param.ring_buf_info[0].size =\n\t\tstr_params->aparams.ring_buf_info[0].size;\n\tstr_info->alloc_param.frag_size = str_params->aparams.frag_size;\n\n\tmemcpy(&str_info->alloc_param.codec_params, &str_params->sparams,\n\t\t\tsizeof(struct snd_sst_stream_params));\n\n\t \n\tnum_ch = sst_get_num_channel(str_params);\n\tpcm_params = &str_info->alloc_param.codec_params.uc.pcm_params;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < num_ch)\n\t\t\tpcm_params->channel_map[i] = i;\n\t\telse\n\t\t\tpcm_params->channel_map[i] = 0xff;\n\t}\n\n\tsst_drv_ctx->streams[str_id].status = STREAM_INIT;\n\tsst_drv_ctx->streams[str_id].prev = STREAM_UN_INIT;\n\tsst_drv_ctx->streams[str_id].pipe_id = str_params->device_type;\n\tsst_drv_ctx->streams[str_id].task_id = str_params->task;\n\tsst_drv_ctx->streams[str_id].num_ch = num_ch;\n\n\tif (sst_drv_ctx->info.lpe_viewpt_rqd)\n\t\tstr_info->alloc_param.ts = sst_drv_ctx->info.mailbox_start +\n\t\t\tsst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));\n\telse\n\t\tstr_info->alloc_param.ts = sst_drv_ctx->mailbox_add +\n\t\t\tsst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));\n\n\tdev_dbg(sst_drv_ctx->dev, \"alloc tstamp location = 0x%x\\n\",\n\t\t\tstr_info->alloc_param.ts);\n\tdev_dbg(sst_drv_ctx->dev, \"assigned pipe id 0x%x to task %d\\n\",\n\t\t\tstr_info->pipe_id, str_info->task_id);\n\n\treturn sst_realloc_stream(sst_drv_ctx, str_id);\n}\n\n \nint sst_realloc_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tstruct snd_sst_alloc_response *response;\n\tstruct stream_info *str_info;\n\tvoid *data = NULL;\n\tint ret;\n\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\tdev_dbg(sst_drv_ctx->dev, \"Alloc for str %d pipe %#x\\n\",\n\t\tstr_id, str_info->pipe_id);\n\n\tret = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\n\t\t\tIPC_IA_ALLOC_STREAM_MRFLD, str_info->pipe_id,\n\t\t\tsizeof(str_info->alloc_param), &str_info->alloc_param,\n\t\t\t&data, true, true, false, true);\n\n\tif (ret < 0) {\n\t\tdev_err(sst_drv_ctx->dev, \"FW alloc failed ret %d\\n\", ret);\n\t\t \n\t\tstr_info->status = STREAM_UN_INIT;\n\t\tstr_id = ret;\n\t} else if (data) {\n\t\tresponse = (struct snd_sst_alloc_response *)data;\n\t\tret = response->str_type.result;\n\t\tif (!ret)\n\t\t\tgoto out;\n\t\tdev_err(sst_drv_ctx->dev, \"FW alloc failed ret %d\\n\", ret);\n\t\tif (ret == SST_ERR_STREAM_IN_USE) {\n\t\t\tdev_err(sst_drv_ctx->dev,\n\t\t\t\t\"FW not in clean state, send free for:%d\\n\", str_id);\n\t\t\tsst_free_stream(sst_drv_ctx, str_id);\n\t\t}\n\t\tstr_id = -ret;\n\t}\nout:\n\tkfree(data);\n\treturn str_id;\n}\n\n \nint sst_start_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\tu16 data = 0;\n\n\tdev_dbg(sst_drv_ctx->dev, \"sst_start_stream for %d\\n\", str_id);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tif (str_info->status != STREAM_RUNNING)\n\t\treturn -EBADRQC;\n\n\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\n\t\t\tIPC_CMD, IPC_IA_START_STREAM_MRFLD, str_info->pipe_id,\n\t\t\tsizeof(u16), &data, NULL, true, true, true, false);\n\n\treturn retval;\n}\n\nint sst_send_byte_stream_mrfld(struct intel_sst_drv *sst_drv_ctx,\n\t\tstruct snd_sst_bytes_v2 *bytes)\n{\tstruct ipc_post *msg = NULL;\n\tu32 length;\n\tint pvt_id, ret = 0;\n\tstruct sst_block *block = NULL;\n\tu8 bytes_block = bytes->block;\n\n\tdev_dbg(sst_drv_ctx->dev,\n\t\t\"type:%u ipc_msg:%u block:%u task_id:%u pipe: %#x length:%#x\\n\",\n\t\tbytes->type, bytes->ipc_msg, bytes_block, bytes->task_id,\n\t\tbytes->pipe_id, bytes->len);\n\n\tif (sst_create_ipc_msg(&msg, true))\n\t\treturn -ENOMEM;\n\n\tpvt_id = sst_assign_pvt_id(sst_drv_ctx);\n\tsst_fill_header_mrfld(&msg->mrfld_header, bytes->ipc_msg,\n\t\t\tbytes->task_id, 1, pvt_id);\n\tmsg->mrfld_header.p.header_high.part.res_rqd = bytes_block;\n\tlength = bytes->len;\n\tmsg->mrfld_header.p.header_low_payload = length;\n\tdev_dbg(sst_drv_ctx->dev, \"length is %d\\n\", length);\n\tmemcpy(msg->mailbox_data, &bytes->bytes, bytes->len);\n\tif (bytes_block) {\n\t\tblock = sst_create_block(sst_drv_ctx, bytes->ipc_msg, pvt_id);\n\t\tif (block == NULL) {\n\t\t\tkfree(msg);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);\n\tdev_dbg(sst_drv_ctx->dev, \"msg->mrfld_header.p.header_low_payload:%d\",\n\t\t\tmsg->mrfld_header.p.header_low_payload);\n\n\tif (bytes_block) {\n\t\tret = sst_wait_timeout(sst_drv_ctx, block);\n\t\tif (ret) {\n\t\t\tdev_err(sst_drv_ctx->dev, \"fw returned err %d\\n\", ret);\n\t\t\tsst_free_block(sst_drv_ctx, block);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (bytes->type == SND_SST_BYTES_GET) {\n\t\t \n\t\tif (bytes_block) {\n\t\t\tunsigned char *r = block->data;\n\n\t\t\tdev_dbg(sst_drv_ctx->dev, \"read back %d bytes\",\n\t\t\t\t\tbytes->len);\n\t\t\tmemcpy(bytes->bytes, r, bytes->len);\n\t\t}\n\t}\n\tif (bytes_block)\n\t\tsst_free_block(sst_drv_ctx, block);\nout:\n\ttest_and_clear_bit(pvt_id, &sst_drv_ctx->pvt_id);\n\treturn ret;\n}\n\n \nint sst_pause_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\n\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:sst_pause_stream for %d\\n\", str_id);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tif (str_info->status == STREAM_PAUSED)\n\t\treturn 0;\n\tif (str_info->status == STREAM_RUNNING ||\n\t\tstr_info->status == STREAM_INIT) {\n\t\tif (str_info->prev == STREAM_UN_INIT)\n\t\t\treturn -EBADRQC;\n\n\t\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\n\t\t\t\tIPC_IA_PAUSE_STREAM_MRFLD, str_info->pipe_id,\n\t\t\t\t0, NULL, NULL, true, true, false, true);\n\n\t\tif (retval == 0) {\n\t\t\tstr_info->prev = str_info->status;\n\t\t\tstr_info->status = STREAM_PAUSED;\n\t\t} else if (retval == -SST_ERR_INVALID_STREAM_ID) {\n\t\t\tretval = -EINVAL;\n\t\t\tmutex_lock(&sst_drv_ctx->sst_lock);\n\t\t\tsst_clean_stream(str_info);\n\t\t\tmutex_unlock(&sst_drv_ctx->sst_lock);\n\t\t}\n\t} else {\n\t\tretval = -EBADRQC;\n\t\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:BADRQC for stream\\n\");\n\t}\n\n\treturn retval;\n}\n\n \nint sst_resume_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\n\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:sst_resume_stream for %d\\n\", str_id);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tif (str_info->status == STREAM_RUNNING)\n\t\treturn 0;\n\n\tif (str_info->resume_status == STREAM_PAUSED &&\n\t    str_info->resume_prev == STREAM_RUNNING) {\n\t\t \n\t\tdev_dbg(sst_drv_ctx->dev, \"restart recreated stream after resume\\n\");\n\t\tstr_info->status = STREAM_RUNNING;\n\t\tstr_info->prev = STREAM_PAUSED;\n\t\tretval = sst_start_stream(sst_drv_ctx, str_id);\n\t\tstr_info->resume_status = STREAM_UN_INIT;\n\t} else if (str_info->resume_status == STREAM_PAUSED &&\n\t\t   str_info->resume_prev == STREAM_INIT) {\n\t\t \n\t\tdev_dbg(sst_drv_ctx->dev, \"leaving recreated stream idle after resume\\n\");\n\t\tstr_info->status = STREAM_INIT;\n\t\tstr_info->prev = STREAM_PAUSED;\n\t\tstr_info->resume_status = STREAM_UN_INIT;\n\t} else if (str_info->status == STREAM_PAUSED) {\n\t\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\n\t\t\t\tIPC_CMD, IPC_IA_RESUME_STREAM_MRFLD,\n\t\t\t\tstr_info->pipe_id, 0, NULL, NULL,\n\t\t\t\ttrue, true, false, true);\n\n\t\tif (!retval) {\n\t\t\tif (str_info->prev == STREAM_RUNNING)\n\t\t\t\tstr_info->status = STREAM_RUNNING;\n\t\t\telse\n\t\t\t\tstr_info->status = STREAM_INIT;\n\t\t\tstr_info->prev = STREAM_PAUSED;\n\t\t} else if (retval == -SST_ERR_INVALID_STREAM_ID) {\n\t\t\tretval = -EINVAL;\n\t\t\tmutex_lock(&sst_drv_ctx->sst_lock);\n\t\t\tsst_clean_stream(str_info);\n\t\t\tmutex_unlock(&sst_drv_ctx->sst_lock);\n\t\t}\n\t} else {\n\t\tretval = -EBADRQC;\n\t\tdev_err(sst_drv_ctx->dev, \"SST ERR: BADQRC for stream\\n\");\n\t}\n\n\treturn retval;\n}\n\n\n \nint sst_drop_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\n\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:sst_drop_stream for %d\\n\", str_id);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\tif (str_info->status != STREAM_UN_INIT) {\n\t\tstr_info->prev = STREAM_UN_INIT;\n\t\tstr_info->status = STREAM_INIT;\n\t\tstr_info->cumm_bytes = 0;\n\t\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\n\t\t\t\tIPC_CMD, IPC_IA_DROP_STREAM_MRFLD,\n\t\t\t\tstr_info->pipe_id, 0, NULL, NULL,\n\t\t\t\ttrue, true, true, false);\n\t} else {\n\t\tretval = -EBADRQC;\n\t\tdev_dbg(sst_drv_ctx->dev, \"BADQRC for stream, state %x\\n\",\n\t\t\t\tstr_info->status);\n\t}\n\treturn retval;\n}\n\n \nint sst_drain_stream(struct intel_sst_drv *sst_drv_ctx,\n\t\t\tint str_id, bool partial_drain)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\n\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:sst_drain_stream for %d\\n\", str_id);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\tif (str_info->status != STREAM_RUNNING &&\n\t\tstr_info->status != STREAM_INIT &&\n\t\tstr_info->status != STREAM_PAUSED) {\n\t\t\tdev_err(sst_drv_ctx->dev, \"SST ERR: BADQRC for stream = %d\\n\",\n\t\t\t\t       str_info->status);\n\t\t\treturn -EBADRQC;\n\t}\n\n\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\n\t\t\tIPC_IA_DRAIN_STREAM_MRFLD, str_info->pipe_id,\n\t\t\tsizeof(u8), &partial_drain, NULL, true, true, false, false);\n\t \n\n\treturn retval;\n}\n\n \nint sst_free_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\n{\n\tint retval = 0;\n\tstruct stream_info *str_info;\n\n\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:sst_free_stream for %d\\n\", str_id);\n\n\tmutex_lock(&sst_drv_ctx->sst_lock);\n\tif (sst_drv_ctx->sst_state == SST_RESET) {\n\t\tmutex_unlock(&sst_drv_ctx->sst_lock);\n\t\treturn -ENODEV;\n\t}\n\tmutex_unlock(&sst_drv_ctx->sst_lock);\n\tstr_info = get_stream_info(sst_drv_ctx, str_id);\n\tif (!str_info)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&str_info->lock);\n\tif (str_info->status != STREAM_UN_INIT) {\n\t\tstr_info->prev =  str_info->status;\n\t\tstr_info->status = STREAM_UN_INIT;\n\t\tmutex_unlock(&str_info->lock);\n\n\t\tdev_dbg(sst_drv_ctx->dev, \"Free for str %d pipe %#x\\n\",\n\t\t\t\tstr_id, str_info->pipe_id);\n\t\tretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\n\t\t\t\tIPC_IA_FREE_STREAM_MRFLD, str_info->pipe_id, 0,\n\t\t\t\tNULL, NULL, true, true, false, true);\n\n\t\tdev_dbg(sst_drv_ctx->dev, \"sst: wait for free returned %d\\n\",\n\t\t\t\tretval);\n\t\tmutex_lock(&sst_drv_ctx->sst_lock);\n\t\tsst_clean_stream(str_info);\n\t\tmutex_unlock(&sst_drv_ctx->sst_lock);\n\t\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:Stream freed\\n\");\n\t} else {\n\t\tmutex_unlock(&str_info->lock);\n\t\tretval = -EBADRQC;\n\t\tdev_dbg(sst_drv_ctx->dev, \"SST DBG:BADQRC for stream\\n\");\n\t}\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}