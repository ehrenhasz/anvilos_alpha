{
  "module_name": "sst-mfld-platform-compress.c",
  "hash_id": "00a8b5c70796a4500778bab0d7da01eea0b66c0442aba550d1f24dfe31208ed0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst-mfld-platform-compress.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include \"sst-mfld-platform.h\"\n\n \nstatic void sst_compr_fragment_elapsed(void *arg)\n{\n\tstruct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;\n\n\tpr_debug(\"fragment elapsed by driver\\n\");\n\tif (cstream)\n\t\tsnd_compr_fragment_elapsed(cstream);\n}\n\nstatic void sst_drain_notify(void *arg)\n{\n\tstruct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;\n\n\tpr_debug(\"drain notify by driver\\n\");\n\tif (cstream)\n\t\tsnd_compr_drain_notify(cstream);\n}\n\nstatic int sst_platform_compr_open(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream)\n{\n\tint ret_val;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sst_runtime_stream *stream;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&stream->status_lock);\n\n\t \n\tif (!sst || !try_module_get(sst->dev->driver->owner)) {\n\t\tpr_err(\"no device available to run\\n\");\n\t\tret_val = -ENODEV;\n\t\tgoto out_ops;\n\t}\n\tstream->compr_ops = sst->compr_ops;\n\tstream->id = 0;\n\n\t \n\tsst->compr_ops->power(sst->dev, true);\n\n\tsst_set_stream_status(stream, SST_PLATFORM_INIT);\n\truntime->private_data = stream;\n\treturn 0;\nout_ops:\n\tkfree(stream);\n\treturn ret_val;\n}\n\nstatic int sst_platform_compr_free(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream)\n{\n\tstruct sst_runtime_stream *stream;\n\tint ret_val = 0, str_id;\n\n\tstream = cstream->runtime->private_data;\n\t \n\tsst->compr_ops->power(sst->dev, false);\n\n\t \n\tstr_id = stream->id;\n\tif (str_id)\n\t\tret_val = stream->compr_ops->close(sst->dev, str_id);\n\tmodule_put(sst->dev->driver->owner);\n\tkfree(stream);\n\tpr_debug(\"%s: %d\\n\", __func__, ret_val);\n\treturn 0;\n}\n\nstatic int sst_platform_compr_set_params(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t\t struct snd_compr_params *params)\n{\n\tstruct sst_runtime_stream *stream;\n\tint retval;\n\tstruct snd_sst_params str_params;\n\tstruct sst_compress_cb cb;\n\tstruct sst_data *ctx = snd_soc_component_get_drvdata(component);\n\n\tstream = cstream->runtime->private_data;\n\t \n\tmemset(&str_params, 0, sizeof(str_params));\n\n\t \n\tretval = sst_fill_stream_params(cstream, ctx, &str_params, true);\n\tpr_debug(\"compr_set_params: fill stream params ret_val = 0x%x\\n\", retval);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tswitch (params->codec.id) {\n\tcase SND_AUDIOCODEC_MP3: {\n\t\tstr_params.codec = SST_CODEC_TYPE_MP3;\n\t\tstr_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;\n\t\tstr_params.sparams.uc.mp3_params.pcm_wd_sz = 16;\n\t\tbreak;\n\t}\n\n\tcase SND_AUDIOCODEC_AAC: {\n\t\tstr_params.codec = SST_CODEC_TYPE_AAC;\n\t\tstr_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;\n\t\tstr_params.sparams.uc.aac_params.pcm_wd_sz = 16;\n\t\tif (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)\n\t\t\tstr_params.sparams.uc.aac_params.bs_format =\n\t\t\t\t\t\t\tAAC_BIT_STREAM_ADTS;\n\t\telse if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)\n\t\t\tstr_params.sparams.uc.aac_params.bs_format =\n\t\t\t\t\t\t\tAAC_BIT_STREAM_RAW;\n\t\telse {\n\t\t\tpr_err(\"Undefined format%d\\n\", params->codec.format);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstr_params.sparams.uc.aac_params.externalsr =\n\t\t\t\t\t\tparams->codec.sample_rate;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tpr_err(\"codec not supported, id =%d\\n\", params->codec.id);\n\t\treturn -EINVAL;\n\t}\n\n\tstr_params.aparams.ring_buf_info[0].addr  =\n\t\t\t\t\tvirt_to_phys(cstream->runtime->buffer);\n\tstr_params.aparams.ring_buf_info[0].size =\n\t\t\t\t\tcstream->runtime->buffer_size;\n\tstr_params.aparams.sg_count = 1;\n\tstr_params.aparams.frag_size = cstream->runtime->fragment_size;\n\n\tcb.param = cstream;\n\tcb.compr_cb = sst_compr_fragment_elapsed;\n\tcb.drain_cb_param = cstream;\n\tcb.drain_notify = sst_drain_notify;\n\n\tretval = stream->compr_ops->open(sst->dev, &str_params, &cb);\n\tif (retval < 0) {\n\t\tpr_err(\"stream allocation failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tstream->id = retval;\n\treturn 0;\n}\n\nstatic int sst_platform_compr_trigger(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream, int cmd)\n{\n\tstruct sst_runtime_stream *stream = cstream->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (stream->compr_ops->stream_start)\n\t\t\treturn stream->compr_ops->stream_start(sst->dev, stream->id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (stream->compr_ops->stream_drop)\n\t\t\treturn stream->compr_ops->stream_drop(sst->dev, stream->id);\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_DRAIN:\n\t\tif (stream->compr_ops->stream_drain)\n\t\t\treturn stream->compr_ops->stream_drain(sst->dev, stream->id);\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_PARTIAL_DRAIN:\n\t\tif (stream->compr_ops->stream_partial_drain)\n\t\t\treturn stream->compr_ops->stream_partial_drain(sst->dev, stream->id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (stream->compr_ops->stream_pause)\n\t\t\treturn stream->compr_ops->stream_pause(sst->dev, stream->id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (stream->compr_ops->stream_pause_release)\n\t\t\treturn stream->compr_ops->stream_pause_release(sst->dev, stream->id);\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sst_platform_compr_pointer(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream,\n\t\t\t\t      struct snd_compr_tstamp *tstamp)\n{\n\tstruct sst_runtime_stream *stream;\n\n\tstream  = cstream->runtime->private_data;\n\tstream->compr_ops->tstamp(sst->dev, stream->id, tstamp);\n\ttstamp->byte_offset = tstamp->copied_total %\n\t\t\t\t (u32)cstream->runtime->buffer_size;\n\tpr_debug(\"calc bytes offset/copied bytes as %d\\n\", tstamp->byte_offset);\n\treturn 0;\n}\n\nstatic int sst_platform_compr_ack(struct snd_soc_component *component,\n\t\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t\t  size_t bytes)\n{\n\tstruct sst_runtime_stream *stream;\n\n\tstream  = cstream->runtime->private_data;\n\tstream->compr_ops->ack(sst->dev, stream->id, (unsigned long)bytes);\n\tstream->bytes_written += bytes;\n\n\treturn 0;\n}\n\nstatic int sst_platform_compr_get_caps(struct snd_soc_component *component,\n\t\t\t\t       struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_compr_caps *caps)\n{\n\tstruct sst_runtime_stream *stream =\n\t\tcstream->runtime->private_data;\n\n\treturn stream->compr_ops->get_caps(caps);\n}\n\nstatic int sst_platform_compr_get_codec_caps(struct snd_soc_component *component,\n\t\t\t\t\t     struct snd_compr_stream *cstream,\n\t\t\t\t\t     struct snd_compr_codec_caps *codec)\n{\n\tstruct sst_runtime_stream *stream =\n\t\tcstream->runtime->private_data;\n\n\treturn stream->compr_ops->get_codec_caps(codec);\n}\n\nstatic int sst_platform_compr_set_metadata(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_compr_stream *cstream,\n\t\t\t\t\t   struct snd_compr_metadata *metadata)\n{\n\tstruct sst_runtime_stream *stream  =\n\t\t cstream->runtime->private_data;\n\n\treturn stream->compr_ops->set_metadata(sst->dev, stream->id, metadata);\n}\n\nconst struct snd_compress_ops sst_platform_compress_ops = {\n\n\t.open = sst_platform_compr_open,\n\t.free = sst_platform_compr_free,\n\t.set_params = sst_platform_compr_set_params,\n\t.set_metadata = sst_platform_compr_set_metadata,\n\t.trigger = sst_platform_compr_trigger,\n\t.pointer = sst_platform_compr_pointer,\n\t.ack = sst_platform_compr_ack,\n\t.get_caps = sst_platform_compr_get_caps,\n\t.get_codec_caps = sst_platform_compr_get_codec_caps,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}