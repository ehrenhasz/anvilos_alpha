{
  "module_name": "sst-mfld-platform-pcm.c",
  "hash_id": "0b2bf896878734107a96de1121a337d22578d58f98b396c8685fa14f0e0fe291",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst-mfld-platform-pcm.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n#include <asm/platform_sst_audio.h>\n#include \"sst-mfld-platform.h\"\n#include \"sst-atom-controls.h\"\n\nstruct sst_device *sst;\nstatic DEFINE_MUTEX(sst_lock);\n\nint sst_register_dsp(struct sst_device *dev)\n{\n\tif (WARN_ON(!dev))\n\t\treturn -EINVAL;\n\tif (!try_module_get(dev->dev->driver->owner))\n\t\treturn -ENODEV;\n\tmutex_lock(&sst_lock);\n\tif (sst) {\n\t\tdev_err(dev->dev, \"we already have a device %s\\n\", sst->name);\n\t\tmodule_put(dev->dev->driver->owner);\n\t\tmutex_unlock(&sst_lock);\n\t\treturn -EEXIST;\n\t}\n\tdev_dbg(dev->dev, \"registering device %s\\n\", dev->name);\n\tsst = dev;\n\tmutex_unlock(&sst_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sst_register_dsp);\n\nint sst_unregister_dsp(struct sst_device *dev)\n{\n\tif (WARN_ON(!dev))\n\t\treturn -EINVAL;\n\tif (dev != sst)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sst_lock);\n\n\tif (!sst) {\n\t\tmutex_unlock(&sst_lock);\n\t\treturn -EIO;\n\t}\n\n\tmodule_put(sst->dev->driver->owner);\n\tdev_dbg(dev->dev, \"unreg %s\\n\", sst->name);\n\tsst = NULL;\n\tmutex_unlock(&sst_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sst_unregister_dsp);\n\nstatic const struct snd_pcm_hardware sst_platform_pcm_hw = {\n\t.info =\t(SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_DOUBLE |\n\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\tSNDRV_PCM_INFO_RESUME |\n\t\t\tSNDRV_PCM_INFO_MMAP|\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\tSNDRV_PCM_INFO_SYNC_START),\n\t.buffer_bytes_max = SST_MAX_BUFFER,\n\t.period_bytes_min = SST_MIN_PERIOD_BYTES,\n\t.period_bytes_max = SST_MAX_PERIOD_BYTES,\n\t.periods_min = SST_MIN_PERIODS,\n\t.periods_max = SST_MAX_PERIODS,\n\t.fifo_size = SST_FIFO_SIZE,\n};\n\nstatic struct sst_dev_stream_map dpcm_strm_map[] = {\n\t{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},  \n\t{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA1_IN, SST_TASK_ID_MEDIA, 0},\n\t{MERR_DPCM_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, 0},\n\t{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, 0},\n\t{MERR_DPCM_DEEP_BUFFER, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA3_IN, SST_TASK_ID_MEDIA, 0},\n};\n\nstatic int sst_media_digital_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\n\treturn sst_send_pipe_gains(dai, stream, mute);\n}\n\n \nvoid sst_set_stream_status(struct sst_runtime_stream *stream,\n\t\t\t\t\tint state)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&stream->status_lock, flags);\n\tstream->stream_status = state;\n\tspin_unlock_irqrestore(&stream->status_lock, flags);\n}\n\nstatic inline int sst_get_stream_status(struct sst_runtime_stream *stream)\n{\n\tint state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&stream->status_lock, flags);\n\tstate = stream->stream_status;\n\tspin_unlock_irqrestore(&stream->status_lock, flags);\n\treturn state;\n}\n\nstatic void sst_fill_alloc_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_sst_alloc_params_ext *alloc_param)\n{\n\tunsigned int channels;\n\tsnd_pcm_uframes_t period_size;\n\tssize_t periodbytes;\n\tssize_t buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\tu32 buffer_addr = substream->runtime->dma_addr;\n\n\tchannels = substream->runtime->channels;\n\tperiod_size = substream->runtime->period_size;\n\tperiodbytes = samples_to_bytes(substream->runtime, period_size);\n\talloc_param->ring_buf_info[0].addr = buffer_addr;\n\talloc_param->ring_buf_info[0].size = buffer_bytes;\n\talloc_param->sg_count = 1;\n\talloc_param->reserved = 0;\n\talloc_param->frag_size = periodbytes * channels;\n\n}\nstatic void sst_fill_pcm_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_sst_stream_params *param)\n{\n\tparam->uc.pcm_params.num_chan = (u8) substream->runtime->channels;\n\tparam->uc.pcm_params.pcm_wd_sz = substream->runtime->sample_bits;\n\tparam->uc.pcm_params.sfreq = substream->runtime->rate;\n\n\t \n\tparam->uc.pcm_params.use_offload_path = 0;\n\tparam->uc.pcm_params.reserved2 = 0;\n\tmemset(param->uc.pcm_params.channel_map, 0, sizeof(u8));\n\n}\n\nstatic int sst_get_stream_mapping(int dev, int sdev, int dir,\n\tstruct sst_dev_stream_map *map, int size)\n{\n\tint i;\n\n\tif (map == NULL)\n\t\treturn -EINVAL;\n\n\n\t \n\tfor (i = 1; i < size; i++) {\n\t\tif ((map[i].dev_num == dev) && (map[i].direction == dir))\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nint sst_fill_stream_params(void *substream,\n\tconst struct sst_data *ctx, struct snd_sst_params *str_params, bool is_compress)\n{\n\tint map_size;\n\tint index;\n\tstruct sst_dev_stream_map *map;\n\tstruct snd_pcm_substream *pstream = NULL;\n\tstruct snd_compr_stream *cstream = NULL;\n\n\tmap = ctx->pdata->pdev_strm_map;\n\tmap_size = ctx->pdata->strm_map_size;\n\n\tif (is_compress)\n\t\tcstream = (struct snd_compr_stream *)substream;\n\telse\n\t\tpstream = (struct snd_pcm_substream *)substream;\n\n\tstr_params->stream_type = SST_STREAM_TYPE_MUSIC;\n\n\t \n\tif (pstream) {\n\t\tindex = sst_get_stream_mapping(pstream->pcm->device,\n\t\t\t\t\t  pstream->number, pstream->stream,\n\t\t\t\t\t  map, map_size);\n\t\tif (index <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tstr_params->stream_id = index;\n\t\tstr_params->device_type = map[index].device_id;\n\t\tstr_params->task = map[index].task_id;\n\n\t\tstr_params->ops = (u8)pstream->stream;\n\t}\n\n\tif (cstream) {\n\t\tindex = sst_get_stream_mapping(cstream->device->device,\n\t\t\t\t\t       0, cstream->direction,\n\t\t\t\t\t       map, map_size);\n\t\tif (index <= 0)\n\t\t\treturn -EINVAL;\n\t\tstr_params->stream_id = index;\n\t\tstr_params->device_type = map[index].device_id;\n\t\tstr_params->task = map[index].task_id;\n\n\t\tstr_params->ops = (u8)cstream->direction;\n\t}\n\treturn 0;\n}\n\nstatic int sst_platform_alloc_stream(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sst_runtime_stream *stream =\n\t\t\tsubstream->runtime->private_data;\n\tstruct snd_sst_stream_params param = {{{0,},},};\n\tstruct snd_sst_params str_params = {0};\n\tstruct snd_sst_alloc_params_ext alloc_params = {0};\n\tint ret_val = 0;\n\tstruct sst_data *ctx = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tsst_fill_pcm_params(substream, &param);\n\tsst_fill_alloc_params(substream, &alloc_params);\n\tstr_params.sparams = param;\n\tstr_params.aparams = alloc_params;\n\tstr_params.codec = SST_CODEC_TYPE_PCM;\n\n\t \n\tret_val = sst_fill_stream_params(substream, ctx, &str_params, false);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tstream->stream_info.str_id = str_params.stream_id;\n\n\tret_val = stream->ops->open(sst->dev, &str_params);\n\tif (ret_val <= 0)\n\t\treturn ret_val;\n\n\n\treturn ret_val;\n}\n\nstatic void sst_period_elapsed(void *arg)\n{\n\tstruct snd_pcm_substream *substream = arg;\n\tstruct sst_runtime_stream *stream;\n\tint status;\n\n\tif (!substream || !substream->runtime)\n\t\treturn;\n\tstream = substream->runtime->private_data;\n\tif (!stream)\n\t\treturn;\n\tstatus = sst_get_stream_status(stream);\n\tif (status != SST_PLATFORM_RUNNING)\n\t\treturn;\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int sst_platform_init_stream(struct snd_pcm_substream *substream)\n{\n\tstruct sst_runtime_stream *stream =\n\t\t\tsubstream->runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret_val;\n\n\tdev_dbg(rtd->dev, \"setting buffer ptr param\\n\");\n\tsst_set_stream_status(stream, SST_PLATFORM_INIT);\n\tstream->stream_info.period_elapsed = sst_period_elapsed;\n\tstream->stream_info.arg = substream;\n\tstream->stream_info.buffer_ptr = 0;\n\tstream->stream_info.sfreq = substream->runtime->rate;\n\tret_val = stream->ops->stream_init(sst->dev, &stream->stream_info);\n\tif (ret_val)\n\t\tdev_err(rtd->dev, \"control_set ret error %d\\n\", ret_val);\n\treturn ret_val;\n\n}\n\nstatic int power_up_sst(struct sst_runtime_stream *stream)\n{\n\treturn stream->ops->power(sst->dev, true);\n}\n\nstatic void power_down_sst(struct sst_runtime_stream *stream)\n{\n\tstream->ops->power(sst->dev, false);\n}\n\nstatic int sst_media_open(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tint ret_val = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sst_runtime_stream *stream;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&stream->status_lock);\n\n\t \n\tmutex_lock(&sst_lock);\n\tif (!sst ||\n\t    !try_module_get(sst->dev->driver->owner)) {\n\t\tdev_err(dai->dev, \"no device available to run\\n\");\n\t\tret_val = -ENODEV;\n\t\tgoto out_ops;\n\t}\n\tstream->ops = sst->ops;\n\tmutex_unlock(&sst_lock);\n\n\tstream->stream_info.str_id = 0;\n\n\tstream->stream_info.arg = substream;\n\t \n\truntime->private_data = stream;\n\n\tret_val = power_up_sst(stream);\n\tif (ret_val < 0)\n\t\tgoto out_power_up;\n\n\t \n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 48);\n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 48);\n\n\t \n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t   SNDRV_PCM_HW_PARAM_PERIODS, 2);\n\n\treturn snd_pcm_hw_constraint_integer(runtime,\n\t\t\t SNDRV_PCM_HW_PARAM_PERIODS);\nout_ops:\n\tmutex_unlock(&sst_lock);\nout_power_up:\n\tkfree(stream);\n\treturn ret_val;\n}\n\nstatic void sst_media_close(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sst_runtime_stream *stream;\n\tint str_id;\n\n\tstream = substream->runtime->private_data;\n\tpower_down_sst(stream);\n\n\tstr_id = stream->stream_info.str_id;\n\tif (str_id)\n\t\tstream->ops->close(sst->dev, str_id);\n\tmodule_put(sst->dev->driver->owner);\n\tkfree(stream);\n}\n\nstatic int sst_media_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sst_runtime_stream *stream;\n\tint ret_val, str_id;\n\n\tstream = substream->runtime->private_data;\n\tstr_id = stream->stream_info.str_id;\n\tif (stream->stream_info.str_id) {\n\t\tret_val = stream->ops->stream_drop(sst->dev, str_id);\n\t\treturn ret_val;\n\t}\n\n\tret_val = sst_platform_alloc_stream(substream, dai);\n\tif (ret_val <= 0)\n\t\treturn ret_val;\n\tsnprintf(substream->pcm->id, sizeof(substream->pcm->id),\n\t\t\t\"%d\", stream->stream_info.str_id);\n\n\tret_val = sst_platform_init_stream(substream);\n\tif (ret_val)\n\t\treturn ret_val;\n\tsubstream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;\n\treturn 0;\n}\n\nstatic int sst_enable_ssp(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\n\tif (!snd_soc_dai_active(dai)) {\n\t\tret = sst_handle_vb_timer(dai, true);\n\t\tsst_fill_ssp_defaults(dai);\n\t}\n\treturn ret;\n}\n\nstatic int sst_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\n\tif (snd_soc_dai_active(dai) == 1)\n\t\tret = send_ssp_cmd(dai, dai->name, 1);\n\treturn ret;\n}\n\nstatic int sst_set_format(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tint ret = 0;\n\n\tif (!snd_soc_dai_active(dai))\n\t\treturn 0;\n\n\tret = sst_fill_ssp_config(dai, fmt);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"sst_set_format failed..\\n\");\n\n\treturn ret;\n}\n\nstatic int sst_platform_set_ssp_slot(struct snd_soc_dai *dai,\n\t\t\tunsigned int tx_mask, unsigned int rx_mask,\n\t\t\tint slots, int slot_width) {\n\tint ret = 0;\n\n\tif (!snd_soc_dai_active(dai))\n\t\treturn ret;\n\n\tret = sst_fill_ssp_slot(dai, tx_mask, rx_mask, slots, slot_width);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"sst_fill_ssp_slot failed..%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void sst_disable_ssp(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tif (!snd_soc_dai_active(dai)) {\n\t\tsend_ssp_cmd(dai, dai->name, 0);\n\t\tsst_handle_vb_timer(dai, false);\n\t}\n}\n\nstatic const struct snd_soc_dai_ops sst_media_dai_ops = {\n\t.startup = sst_media_open,\n\t.shutdown = sst_media_close,\n\t.prepare = sst_media_prepare,\n\t.mute_stream = sst_media_digital_mute,\n};\n\nstatic const struct snd_soc_dai_ops sst_compr_dai_ops = {\n\t.compress_new = snd_soc_new_compress,\n\t.mute_stream = sst_media_digital_mute,\n};\n\nstatic const struct snd_soc_dai_ops sst_be_dai_ops = {\n\t.startup = sst_enable_ssp,\n\t.hw_params = sst_be_hw_params,\n\t.set_fmt = sst_set_format,\n\t.set_tdm_slot = sst_platform_set_ssp_slot,\n\t.shutdown = sst_disable_ssp,\n};\n\nstatic struct snd_soc_dai_driver sst_platform_dai[] = {\n{\n\t.name = \"media-cpu-dai\",\n\t.ops = &sst_media_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Headset Playback\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Headset Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"deepbuffer-cpu-dai\",\n\t.ops = &sst_media_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Deepbuffer Playback\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"compress-cpu-dai\",\n\t.ops = &sst_compr_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Compress Playback\",\n\t\t.channels_min = 1,\n\t},\n},\n \n{\n\t.name = \"ssp0-port\",\n\t.ops = &sst_be_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp0 Tx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp0 Rx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"ssp1-port\",\n\t.ops = &sst_be_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp1 Tx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp1 Rx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"ssp2-port\",\n\t.ops = &sst_be_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp2 Tx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp2 Rx\",\n\t\t.channels_min = SST_STEREO,\n\t\t.channels_max = SST_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n};\n\nstatic int sst_soc_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (substream->pcm->internal)\n\t\treturn 0;\n\n\truntime = substream->runtime;\n\truntime->hw = sst_platform_pcm_hw;\n\treturn 0;\n}\n\nstatic int sst_soc_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret_val = 0, str_id;\n\tstruct sst_runtime_stream *stream;\n\tint status;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tdev_dbg(rtd->dev, \"%s called\\n\", __func__);\n\tif (substream->pcm->internal)\n\t\treturn 0;\n\tstream = substream->runtime->private_data;\n\tstr_id = stream->stream_info.str_id;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdev_dbg(rtd->dev, \"sst: Trigger Start\\n\");\n\t\tstatus = SST_PLATFORM_RUNNING;\n\t\tstream->stream_info.arg = substream;\n\t\tret_val = stream->ops->stream_start(sst->dev, str_id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(rtd->dev, \"sst: in stop\\n\");\n\t\tstatus = SST_PLATFORM_DROPPED;\n\t\tret_val = stream->ops->stream_drop(sst->dev, str_id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdev_dbg(rtd->dev, \"sst: in pause\\n\");\n\t\tstatus = SST_PLATFORM_PAUSED;\n\t\tret_val = stream->ops->stream_pause(sst->dev, str_id);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tdev_dbg(rtd->dev, \"sst: in pause release\\n\");\n\t\tstatus = SST_PLATFORM_RUNNING;\n\t\tret_val = stream->ops->stream_pause_release(sst->dev, str_id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ret_val)\n\t\tsst_set_stream_status(stream, status);\n\n\treturn ret_val;\n}\n\n\nstatic snd_pcm_uframes_t sst_soc_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct sst_runtime_stream *stream;\n\tint ret_val, status;\n\tstruct pcm_stream_info *str_info;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tstream = substream->runtime->private_data;\n\tstatus = sst_get_stream_status(stream);\n\tif (status == SST_PLATFORM_INIT)\n\t\treturn 0;\n\tstr_info = &stream->stream_info;\n\tret_val = stream->ops->stream_read_tstamp(sst->dev, str_info);\n\tif (ret_val) {\n\t\tdev_err(rtd->dev, \"sst: error code = %d\\n\", ret_val);\n\t\treturn ret_val;\n\t}\n\treturn str_info->buffer_ptr;\n}\n\nstatic snd_pcm_sframes_t sst_soc_delay(struct snd_soc_component *component,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct sst_runtime_stream *stream = substream->runtime->private_data;\n\tstruct pcm_stream_info *str_info = &stream->stream_info;\n\n\tif (sst_get_stream_status(stream) == SST_PLATFORM_INIT)\n\t\treturn 0;\n\n\treturn str_info->pcm_delay;\n}\n\nstatic int sst_soc_pcm_new(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_pcm *pcm = rtd->pcm;\n\n\tif (dai->driver->playback.channels_min ||\n\t\t\tdai->driver->capture.channels_min) {\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       pcm->card->dev,\n\t\t\t\t\t       SST_MIN_BUFFER, SST_MAX_BUFFER);\n\t}\n\treturn 0;\n}\n\nstatic int sst_soc_probe(struct snd_soc_component *component)\n{\n\tstruct sst_data *drv = dev_get_drvdata(component->dev);\n\n\tdrv->soc_card = component->card;\n\treturn sst_dsp_init_v2_dpcm(component);\n}\n\nstatic void sst_soc_remove(struct snd_soc_component *component)\n{\n\tstruct sst_data *drv = dev_get_drvdata(component->dev);\n\n\tdrv->soc_card = NULL;\n}\n\nstatic const struct snd_soc_component_driver sst_soc_platform_drv  = {\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= sst_soc_probe,\n\t.remove\t\t= sst_soc_remove,\n\t.open\t\t= sst_soc_open,\n\t.trigger\t= sst_soc_trigger,\n\t.pointer\t= sst_soc_pointer,\n\t.delay\t\t= sst_soc_delay,\n\t.compress_ops\t= &sst_platform_compress_ops,\n\t.pcm_construct\t= sst_soc_pcm_new,\n};\n\nstatic int sst_platform_probe(struct platform_device *pdev)\n{\n\tstruct sst_data *drv;\n\tint ret;\n\tstruct sst_platform_data *pdata;\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (drv == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (pdata == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata->pdev_strm_map = dpcm_strm_map;\n\tpdata->strm_map_size = ARRAY_SIZE(dpcm_strm_map);\n\tdrv->pdata = pdata;\n\tdrv->pdev = pdev;\n\tmutex_init(&drv->lock);\n\tdev_set_drvdata(&pdev->dev, drv);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &sst_soc_platform_drv,\n\t\t\t\tsst_platform_dai, ARRAY_SIZE(sst_platform_dai));\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"registering cpu dais failed\\n\");\n\n\treturn ret;\n}\n\nstatic void sst_platform_remove(struct platform_device *pdev)\n{\n\tdev_dbg(&pdev->dev, \"sst_platform_remove success\\n\");\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int sst_soc_prepare(struct device *dev)\n{\n\tstruct sst_data *drv = dev_get_drvdata(dev);\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tif (!drv->soc_card)\n\t\treturn 0;\n\n\t \n\tsnd_soc_suspend(drv->soc_card->dev);\n\tsnd_soc_poweroff(drv->soc_card->dev);\n\n\t \n\tfor_each_card_rtds(drv->soc_card, rtd) {\n\t\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\n\t\tif (snd_soc_dai_active(dai)) {\n\t\t\tsend_ssp_cmd(dai, dai->name, 0);\n\t\t\tsst_handle_vb_timer(dai, false);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sst_soc_complete(struct device *dev)\n{\n\tstruct sst_data *drv = dev_get_drvdata(dev);\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tif (!drv->soc_card)\n\t\treturn;\n\n\t \n\tfor_each_card_rtds(drv->soc_card, rtd) {\n\t\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\n\t\tif (snd_soc_dai_active(dai)) {\n\t\t\tsst_handle_vb_timer(dai, true);\n\t\t\tsend_ssp_cmd(dai, dai->name, 1);\n\t\t}\n\t}\n\tsnd_soc_resume(drv->soc_card->dev);\n}\n\n#else\n\n#define sst_soc_prepare NULL\n#define sst_soc_complete NULL\n\n#endif\n\n\nstatic const struct dev_pm_ops sst_platform_pm = {\n\t.prepare\t= sst_soc_prepare,\n\t.complete\t= sst_soc_complete,\n};\n\nstatic struct platform_driver sst_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"sst-mfld-platform\",\n\t\t.pm             = &sst_platform_pm,\n\t},\n\t.probe\t\t= sst_platform_probe,\n\t.remove_new\t= sst_platform_remove,\n};\n\nmodule_platform_driver(sst_platform_driver);\n\nMODULE_DESCRIPTION(\"ASoC Intel(R) MID Platform driver\");\nMODULE_AUTHOR(\"Vinod Koul <vinod.koul@intel.com>\");\nMODULE_AUTHOR(\"Harsha Priya <priya.harsha@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sst-atom-hifi2-platform\");\nMODULE_ALIAS(\"platform:sst-mfld-platform\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}