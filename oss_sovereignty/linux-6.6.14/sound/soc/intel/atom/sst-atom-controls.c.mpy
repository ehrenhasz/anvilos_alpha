{
  "module_name": "sst-atom-controls.c",
  "hash_id": "9c9f4ee15d2afa18cde9ce9d00efb75f24e0621484bb7ca010885fa0d483fef7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/atom/sst-atom-controls.c",
  "human_readable_source": "\n  \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"sst-mfld-platform.h\"\n#include \"sst-atom-controls.h\"\n\nstatic int sst_fill_byte_control(struct sst_data *drv,\n\t\t\t\t\t u8 ipc_msg, u8 block,\n\t\t\t\t\t u8 task_id, u8 pipe_id,\n\t\t\t\t\t u16 len, void *cmd_data)\n{\n\tstruct snd_sst_bytes_v2 *byte_data = drv->byte_stream;\n\n\tbyte_data->type = SST_CMD_BYTES_SET;\n\tbyte_data->ipc_msg = ipc_msg;\n\tbyte_data->block = block;\n\tbyte_data->task_id = task_id;\n\tbyte_data->pipe_id = pipe_id;\n\n\tif (len > SST_MAX_BIN_BYTES - sizeof(*byte_data)) {\n\t\tdev_err(&drv->pdev->dev, \"command length too big (%u)\", len);\n\t\treturn -EINVAL;\n\t}\n\tbyte_data->len = len;\n\tmemcpy(byte_data->bytes, cmd_data, len);\n\tprint_hex_dump_bytes(\"writing to lpe: \", DUMP_PREFIX_OFFSET,\n\t\t\t     byte_data, len + sizeof(*byte_data));\n\treturn 0;\n}\n\nstatic int sst_fill_and_send_cmd_unlocked(struct sst_data *drv,\n\t\t\t\t u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,\n\t\t\t\t void *cmd_data, u16 len)\n{\n\tint ret = 0;\n\n\tWARN_ON(!mutex_is_locked(&drv->lock));\n\n\tret = sst_fill_byte_control(drv, ipc_msg,\n\t\t\t\tblock, task_id, pipe_id, len, cmd_data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sst->ops->send_byte_stream(sst->dev, drv->byte_stream);\n}\n\n \nstatic int sst_fill_and_send_cmd(struct sst_data *drv,\n\t\t\t\t u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,\n\t\t\t\t void *cmd_data, u16 len)\n{\n\tint ret;\n\n\tmutex_lock(&drv->lock);\n\tret = sst_fill_and_send_cmd_unlocked(drv, ipc_msg, block,\n\t\t\t\t\ttask_id, pipe_id, cmd_data, len);\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\n \nstatic u8 sst_ssp_tx_map[SST_MAX_TDM_SLOTS] = {\n\t0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,  \n};\n\n \nstatic u8 sst_ssp_rx_map[SST_MAX_TDM_SLOTS] = {\n\t0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,  \n};\n\n \nstatic int sst_send_slot_map(struct sst_data *drv)\n{\n\tstruct sst_param_sba_ssp_slot_map cmd;\n\n\tSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\n\tcmd.header.command_id = SBA_SET_SSP_SLOT_MAP;\n\tcmd.header.length = sizeof(struct sst_param_sba_ssp_slot_map)\n\t\t\t\t- sizeof(struct sst_dsp_header);\n\n\tcmd.param_id = SBA_SET_SSP_SLOT_MAP;\n\tcmd.param_len = sizeof(cmd.rx_slot_map) + sizeof(cmd.tx_slot_map)\n\t\t\t\t\t+ sizeof(cmd.ssp_index);\n\tcmd.ssp_index = SSP_CODEC;\n\n\tmemcpy(cmd.rx_slot_map, &sst_ssp_tx_map[0], sizeof(cmd.rx_slot_map));\n\tmemcpy(cmd.tx_slot_map, &sst_ssp_rx_map[0], sizeof(cmd.tx_slot_map));\n\n\treturn sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\n\t\t\tSST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,\n\t\t\t      sizeof(cmd.header) + cmd.header.length);\n}\n\nstatic int sst_slot_enum_info(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct sst_enum *e = (struct sst_enum *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = e->max;\n\n\tif (uinfo->value.enumerated.item > e->max - 1)\n\t\tuinfo->value.enumerated.item = e->max - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\te->texts[uinfo->value.enumerated.item]);\n\n\treturn 0;\n}\n\n \nstatic int sst_slot_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sst_enum *e = (void *)kcontrol->private_value;\n\tstruct snd_soc_component *c = snd_kcontrol_chip(kcontrol);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\tunsigned int ctl_no = e->reg;\n\tunsigned int is_tx = e->tx;\n\tunsigned int val, mux;\n\tu8 *map = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;\n\n\tmutex_lock(&drv->lock);\n\tval = 1 << ctl_no;\n\t \n\tfor (mux = e->max; mux > 0;  mux--)\n\t\tif (map[mux - 1] & val)\n\t\t\tbreak;\n\n\tucontrol->value.enumerated.item[0] = mux;\n\tmutex_unlock(&drv->lock);\n\n\tdev_dbg(c->dev, \"%s - %s map = %#x\\n\",\n\t\t\tis_tx ? \"tx channel\" : \"rx slot\",\n\t\t\t e->texts[mux], mux ? map[mux - 1] : -1);\n\treturn 0;\n}\n\n \nstatic int sst_check_and_send_slot_map(struct sst_data *drv, struct snd_kcontrol *kcontrol)\n{\n\tstruct sst_enum *e = (void *)kcontrol->private_value;\n\tint ret = 0;\n\n\tif (e->w && e->w->power)\n\t\tret = sst_send_slot_map(drv);\n\telse if (!e->w)\n\t\tdev_err(&drv->pdev->dev, \"Slot control: %s doesn't have DAPM widget!!!\\n\",\n\t\t\t\tkcontrol->id.name);\n\treturn ret;\n}\n\n \nstatic int sst_slot_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *c = snd_soc_kcontrol_component(kcontrol);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\tstruct sst_enum *e = (void *)kcontrol->private_value;\n\tint i, ret = 0;\n\tunsigned int ctl_no = e->reg;\n\tunsigned int is_tx = e->tx;\n\tunsigned int slot_channel_no;\n\tunsigned int val, mux;\n\tu8 *map;\n\n\tmap = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;\n\n\tval = 1 << ctl_no;\n\tmux = ucontrol->value.enumerated.item[0];\n\tif (mux > e->max - 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&drv->lock);\n\t \n\tfor (i = 0; i < e->max; i++)\n\t\tmap[i] &= ~val;\n\n\tif (mux == 0) {\n\t\t \n\t\tret = sst_check_and_send_slot_map(drv, kcontrol);\n\n\t\tmutex_unlock(&drv->lock);\n\t\treturn ret;\n\t}\n\n\t \n\tslot_channel_no = mux - 1;\n\tmap[slot_channel_no] |= val;\n\n\tdev_dbg(c->dev, \"%s %s map = %#x\\n\",\n\t\t\tis_tx ? \"tx channel\" : \"rx slot\",\n\t\t\te->texts[mux], map[slot_channel_no]);\n\n\tret = sst_check_and_send_slot_map(drv, kcontrol);\n\n\tmutex_unlock(&drv->lock);\n\treturn ret;\n}\n\nstatic int sst_send_algo_cmd(struct sst_data *drv,\n\t\t\t      struct sst_algo_control *bc)\n{\n\tint len, ret = 0;\n\tstruct sst_cmd_set_params *cmd;\n\n\t \n\tlen = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;\n\n\tcmd = kzalloc(len, GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tSST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);\n\tcmd->command_id = bc->cmd_id;\n\tmemcpy(cmd->params, bc->params, bc->max);\n\n\tret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\n\t\t\t\tSST_FLAG_BLOCKED, bc->task_id, 0, cmd, len);\n\tkfree(cmd);\n\treturn ret;\n}\n\n \nstatic int sst_find_and_send_pipe_algo(struct sst_data *drv,\n\t\t\t\t\tconst char *pipe, struct sst_ids *ids)\n{\n\tint ret = 0;\n\tstruct sst_algo_control *bc;\n\tstruct sst_module *algo;\n\n\tdev_dbg(&drv->pdev->dev, \"Enter: widget=%s\\n\", pipe);\n\n\tlist_for_each_entry(algo, &ids->algo_list, node) {\n\t\tbc = (void *)algo->kctl->private_value;\n\n\t\tdev_dbg(&drv->pdev->dev, \"Found algo control name=%s pipe=%s\\n\",\n\t\t\t\talgo->kctl->id.name, pipe);\n\t\tret = sst_send_algo_cmd(drv, bc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int sst_algo_bytes_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct sst_algo_control *bc = (void *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = bc->max;\n\n\treturn 0;\n}\n\nstatic int sst_algo_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sst_algo_control *bc = (void *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\n\tswitch (bc->type) {\n\tcase SST_ALGO_PARAMS:\n\t\tmemcpy(ucontrol->value.bytes.data, bc->params, bc->max);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid Input- algo type:%d\\n\",\n\t\t\t\tbc->type);\n\t\treturn -EINVAL;\n\n\t}\n\treturn 0;\n}\n\nstatic int sst_algo_control_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint ret = 0;\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\n\tstruct sst_algo_control *bc = (void *)kcontrol->private_value;\n\n\tdev_dbg(cmpnt->dev, \"control_name=%s\\n\", kcontrol->id.name);\n\tmutex_lock(&drv->lock);\n\tswitch (bc->type) {\n\tcase SST_ALGO_PARAMS:\n\t\tmemcpy(bc->params, ucontrol->value.bytes.data, bc->max);\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&drv->lock);\n\t\tdev_err(cmpnt->dev, \"Invalid Input- algo type:%d\\n\",\n\t\t\t\tbc->type);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (bc->w && bc->w->power)\n\t\tret = sst_send_algo_cmd(drv, bc);\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\nstatic int sst_gain_ctl_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = mc->stereo ? 2 : 1;\n\tuinfo->value.integer.min = mc->min;\n\tuinfo->value.integer.max = mc->max;\n\n\treturn 0;\n}\n\n \nstatic int sst_send_gain_cmd(struct sst_data *drv, struct sst_gain_value *gv,\n\t\t\t      u16 task_id, u16 loc_id, u16 module_id, int mute)\n{\n\tstruct sst_cmd_set_gain_dual cmd;\n\n\tdev_dbg(&drv->pdev->dev, \"Enter\\n\");\n\n\tcmd.header.command_id = MMX_SET_GAIN;\n\tSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\n\tcmd.gain_cell_num = 1;\n\n\tif (mute || gv->mute) {\n\t\tcmd.cell_gains[0].cell_gain_left = SST_GAIN_MIN_VALUE;\n\t\tcmd.cell_gains[0].cell_gain_right = SST_GAIN_MIN_VALUE;\n\t} else {\n\t\tcmd.cell_gains[0].cell_gain_left = gv->l_gain;\n\t\tcmd.cell_gains[0].cell_gain_right = gv->r_gain;\n\t}\n\n\tSST_FILL_DESTINATION(2, cmd.cell_gains[0].dest,\n\t\t\t     loc_id, module_id);\n\tcmd.cell_gains[0].gain_time_constant = gv->ramp_duration;\n\n\tcmd.header.length = sizeof(struct sst_cmd_set_gain_dual)\n\t\t\t\t- sizeof(struct sst_dsp_header);\n\n\t \n\treturn sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\n\t\t\t\tSST_FLAG_BLOCKED, task_id, 0, &cmd,\n\t\t\t      sizeof(cmd.header) + cmd.header.length);\n}\n\nstatic int sst_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\n\tstruct sst_gain_value *gv = mc->gain_val;\n\n\tswitch (mc->type) {\n\tcase SST_GAIN_TLV:\n\t\tucontrol->value.integer.value[0] = gv->l_gain;\n\t\tucontrol->value.integer.value[1] = gv->r_gain;\n\t\tbreak;\n\n\tcase SST_GAIN_MUTE:\n\t\tucontrol->value.integer.value[0] = gv->mute ? 0 : 1;\n\t\tbreak;\n\n\tcase SST_GAIN_RAMP_DURATION:\n\t\tucontrol->value.integer.value[0] = gv->ramp_duration;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid Input- gain type:%d\\n\",\n\t\t\t\tmc->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sst_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint ret = 0;\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\n\tstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\n\tstruct sst_gain_value *gv = mc->gain_val;\n\n\tmutex_lock(&drv->lock);\n\n\tswitch (mc->type) {\n\tcase SST_GAIN_TLV:\n\t\tgv->l_gain = ucontrol->value.integer.value[0];\n\t\tgv->r_gain = ucontrol->value.integer.value[1];\n\t\tdev_dbg(cmpnt->dev, \"%s: Volume %d, %d\\n\",\n\t\t\t\tmc->pname, gv->l_gain, gv->r_gain);\n\t\tbreak;\n\n\tcase SST_GAIN_MUTE:\n\t\tgv->mute = !ucontrol->value.integer.value[0];\n\t\tdev_dbg(cmpnt->dev, \"%s: Mute %d\\n\", mc->pname, gv->mute);\n\t\tbreak;\n\n\tcase SST_GAIN_RAMP_DURATION:\n\t\tgv->ramp_duration = ucontrol->value.integer.value[0];\n\t\tdev_dbg(cmpnt->dev, \"%s: Ramp Delay%d\\n\",\n\t\t\t\t\tmc->pname, gv->ramp_duration);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&drv->lock);\n\t\tdev_err(cmpnt->dev, \"Invalid Input- gain type:%d\\n\",\n\t\t\t\tmc->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mc->w && mc->w->power)\n\t\tret = sst_send_gain_cmd(drv, gv, mc->task_id,\n\t\t\tmc->pipe_id | mc->instance_id, mc->module_id, 0);\n\tmutex_unlock(&drv->lock);\n\n\treturn ret;\n}\n\nstatic int sst_set_pipe_gain(struct sst_ids *ids,\n\t\t\t\tstruct sst_data *drv, int mute);\n\nstatic int sst_send_pipe_module_params(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol)\n{\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\tstruct sst_ids *ids = w->priv;\n\n\tmutex_lock(&drv->lock);\n\tsst_find_and_send_pipe_algo(drv, w->name, ids);\n\tsst_set_pipe_gain(ids, drv, 0);\n\tmutex_unlock(&drv->lock);\n\n\treturn 0;\n}\n\nstatic int sst_generic_modules_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t     struct snd_kcontrol *k, int event)\n{\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\treturn sst_send_pipe_module_params(w, k);\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(sst_gain_tlv_common, SST_GAIN_MIN_VALUE * 10, 10, 0);\n\n \nstatic const uint swm_mixer_input_ids[SST_SWM_INPUT_COUNT] = {\n\t[SST_IP_MODEM]\t\t= SST_SWM_IN_MODEM,\n\t[SST_IP_CODEC0]\t\t= SST_SWM_IN_CODEC0,\n\t[SST_IP_CODEC1]\t\t= SST_SWM_IN_CODEC1,\n\t[SST_IP_LOOP0]\t\t= SST_SWM_IN_SPROT_LOOP,\n\t[SST_IP_LOOP1]\t\t= SST_SWM_IN_MEDIA_LOOP1,\n\t[SST_IP_LOOP2]\t\t= SST_SWM_IN_MEDIA_LOOP2,\n\t[SST_IP_PCM0]\t\t= SST_SWM_IN_PCM0,\n\t[SST_IP_PCM1]\t\t= SST_SWM_IN_PCM1,\n\t[SST_IP_MEDIA0]\t\t= SST_SWM_IN_MEDIA0,\n\t[SST_IP_MEDIA1]\t\t= SST_SWM_IN_MEDIA1,\n\t[SST_IP_MEDIA2]\t\t= SST_SWM_IN_MEDIA2,\n\t[SST_IP_MEDIA3]\t\t= SST_SWM_IN_MEDIA3,\n};\n\n \nstatic int fill_swm_input(struct snd_soc_component *cmpnt,\n\t\tstruct swm_input_ids *swm_input, unsigned int reg)\n{\n\tuint i, is_set, nb_inputs = 0;\n\tu16 input_loc_id;\n\n\tdev_dbg(cmpnt->dev, \"reg: %#x\\n\", reg);\n\tfor (i = 0; i < SST_SWM_INPUT_COUNT; i++) {\n\t\tis_set = reg & BIT(i);\n\t\tif (!is_set)\n\t\t\tcontinue;\n\n\t\tinput_loc_id = swm_mixer_input_ids[i];\n\t\tSST_FILL_DESTINATION(2, swm_input->input_id,\n\t\t\t\t     input_loc_id, SST_DEFAULT_MODULE_ID);\n\t\tnb_inputs++;\n\t\tswm_input++;\n\t\tdev_dbg(cmpnt->dev, \"input id: %#x, nb_inputs: %d\\n\",\n\t\t\t\tinput_loc_id, nb_inputs);\n\n\t\tif (nb_inputs == SST_CMD_SWM_MAX_INPUTS) {\n\t\t\tdev_warn(cmpnt->dev, \"SET_SWM cmd max inputs reached\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nb_inputs;\n}\n\n\n \nstatic int sst_set_pipe_gain(struct sst_ids *ids,\n\t\t\tstruct sst_data *drv, int mute)\n{\n\tint ret = 0;\n\tstruct sst_gain_mixer_control *mc;\n\tstruct sst_gain_value *gv;\n\tstruct sst_module *gain;\n\n\tlist_for_each_entry(gain, &ids->gain_list, node) {\n\t\tstruct snd_kcontrol *kctl = gain->kctl;\n\n\t\tdev_dbg(&drv->pdev->dev, \"control name=%s\\n\", kctl->id.name);\n\t\tmc = (void *)kctl->private_value;\n\t\tgv = mc->gain_val;\n\n\t\tret = sst_send_gain_cmd(drv, gv, mc->task_id,\n\t\t\tmc->pipe_id | mc->instance_id, mc->module_id, mute);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int sst_swm_mixer_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *k, int event)\n{\n\tstruct sst_cmd_set_swm cmd;\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\n\tstruct sst_ids *ids = w->priv;\n\tbool set_mixer = false;\n\tstruct soc_mixer_control *mc;\n\tint val = 0;\n\tint i = 0;\n\n\tdev_dbg(cmpnt->dev, \"widget = %s\\n\", w->name);\n\t \n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tif (dapm_kcontrol_get_value(w->kcontrols[i])) {\n\t\t\tmc = (struct soc_mixer_control *)(w->kcontrols[i])->private_value;\n\t\t\tval |= 1 << mc->shift;\n\t\t}\n\t}\n\tdev_dbg(cmpnt->dev, \"val = %#x\\n\", val);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tset_mixer = true;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_REG:\n\t\tif (w->power)\n\t\t\tset_mixer = true;\n\t\tbreak;\n\tdefault:\n\t\tset_mixer = false;\n\t}\n\n\tif (!set_mixer)\n\t\treturn 0;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event) ||\n\t    event == SND_SOC_DAPM_POST_REG)\n\t\tcmd.switch_state = SST_SWM_ON;\n\telse\n\t\tcmd.switch_state = SST_SWM_OFF;\n\n\tSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\n\t \n\tcmd.header.command_id = SBA_SET_SWM;\n\n\tSST_FILL_DESTINATION(2, cmd.output_id,\n\t\t\t     ids->location_id, SST_DEFAULT_MODULE_ID);\n\tcmd.nb_inputs =\tfill_swm_input(cmpnt, &cmd.input[0], val);\n\tcmd.header.length = offsetof(struct sst_cmd_set_swm, input)\n\t\t\t\t- sizeof(struct sst_dsp_header)\n\t\t\t\t+ (cmd.nb_inputs * sizeof(cmd.input[0]));\n\n\treturn sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\n\t\t\t      ids->task_id, 0, &cmd,\n\t\t\t      sizeof(cmd.header) + cmd.header.length);\n}\n\n \n#define SST_SBA_DECLARE_MIX_CONTROLS(kctl_name)\t\t\t\t\t\t\t\\\n\tstatic const struct snd_kcontrol_new kctl_name[] = {\t\t\t\t\t\\\n\t\tSOC_DAPM_SINGLE(\"modem_in Switch\", SND_SOC_NOPM, SST_IP_MODEM, 1, 0),\t\t\\\n\t\tSOC_DAPM_SINGLE(\"codec_in0 Switch\", SND_SOC_NOPM, SST_IP_CODEC0, 1, 0),\t\t\\\n\t\tSOC_DAPM_SINGLE(\"codec_in1 Switch\", SND_SOC_NOPM, SST_IP_CODEC1, 1, 0),\t\t\\\n\t\tSOC_DAPM_SINGLE(\"sprot_loop_in Switch\", SND_SOC_NOPM, SST_IP_LOOP0, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"media_loop1_in Switch\", SND_SOC_NOPM, SST_IP_LOOP1, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"media_loop2_in Switch\", SND_SOC_NOPM, SST_IP_LOOP2, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"pcm0_in Switch\", SND_SOC_NOPM, SST_IP_PCM0, 1, 0),\t\t\\\n\t\tSOC_DAPM_SINGLE(\"pcm1_in Switch\", SND_SOC_NOPM, SST_IP_PCM1, 1, 0),\t\t\\\n\t}\n\n#define SST_SBA_MIXER_GRAPH_MAP(mix_name)\t\t\t\\\n\t{ mix_name, \"modem_in Switch\",\t\"modem_in\" },\t\t\\\n\t{ mix_name, \"codec_in0 Switch\",\t\"codec_in0\" },\t\t\\\n\t{ mix_name, \"codec_in1 Switch\",\t\"codec_in1\" },\t\t\\\n\t{ mix_name, \"sprot_loop_in Switch\",\t\"sprot_loop_in\" },\t\\\n\t{ mix_name, \"media_loop1_in Switch\",\t\"media_loop1_in\" },\t\\\n\t{ mix_name, \"media_loop2_in Switch\",\t\"media_loop2_in\" },\t\\\n\t{ mix_name, \"pcm0_in Switch\",\t\t\"pcm0_in\" },\t\t\\\n\t{ mix_name, \"pcm1_in Switch\",\t\t\"pcm1_in\" }\n\n#define SST_MMX_DECLARE_MIX_CONTROLS(kctl_name)\t\t\t\t\t\t\\\n\tstatic const struct snd_kcontrol_new kctl_name[] = {\t\t\t\t\\\n\t\tSOC_DAPM_SINGLE(\"media0_in Switch\", SND_SOC_NOPM, SST_IP_MEDIA0, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"media1_in Switch\", SND_SOC_NOPM, SST_IP_MEDIA1, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"media2_in Switch\", SND_SOC_NOPM, SST_IP_MEDIA2, 1, 0),\t\\\n\t\tSOC_DAPM_SINGLE(\"media3_in Switch\", SND_SOC_NOPM, SST_IP_MEDIA3, 1, 0),\t\\\n\t}\n\nSST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media0_controls);\nSST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media1_controls);\n\n \nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm0_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm1_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm2_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_sprot_l0_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l1_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l2_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(__maybe_unused sst_mix_voip_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec0_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec1_controls);\nSST_SBA_DECLARE_MIX_CONTROLS(sst_mix_modem_controls);\n\n \nint sst_handle_vb_timer(struct snd_soc_dai *dai, bool enable)\n{\n\tint ret = 0;\n\tstruct sst_cmd_generic cmd;\n\tstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\n\tstatic int timer_usage;\n\n\tif (enable)\n\t\tcmd.header.command_id = SBA_VB_START;\n\telse\n\t\tcmd.header.command_id = SBA_IDLE;\n\tdev_dbg(dai->dev, \"enable=%u, usage=%d\\n\", enable, timer_usage);\n\n\tSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\n\tcmd.header.length = 0;\n\n\tif (enable) {\n\t\tret = sst->ops->power(sst->dev, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&drv->lock);\n\tif (enable)\n\t\ttimer_usage++;\n\telse\n\t\ttimer_usage--;\n\n\t \n\tif ((enable && (timer_usage == 1)) ||\n\t    (!enable && (timer_usage == 0))) {\n\t\tret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_CMD,\n\t\t\t\tSST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,\n\t\t\t\tsizeof(cmd.header) + cmd.header.length);\n\t\tif (ret && enable) {\n\t\t\ttimer_usage--;\n\t\t\tenable  = false;\n\t\t}\n\t}\n\tmutex_unlock(&drv->lock);\n\n\tif (!enable)\n\t\tsst->ops->power(sst->dev, false);\n\treturn ret;\n}\n\nint sst_fill_ssp_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct sst_data *ctx = snd_soc_dai_get_drvdata(dai);\n\n\tctx->ssp_cmd.nb_slots = slots;\n\tctx->ssp_cmd.active_tx_slot_map = tx_mask;\n\tctx->ssp_cmd.active_rx_slot_map = rx_mask;\n\tctx->ssp_cmd.nb_bits_per_slots = slot_width;\n\n\treturn 0;\n}\n\nstatic int sst_get_frame_sync_polarity(struct snd_soc_dai *dai,\n\t\tunsigned int fmt)\n{\n\tint format;\n\n\tformat = fmt & SND_SOC_DAIFMT_INV_MASK;\n\tdev_dbg(dai->dev, \"Enter:%s, format=%x\\n\", __func__, format);\n\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treturn SSP_FS_ACTIVE_HIGH;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\treturn SSP_FS_ACTIVE_LOW;\n\tdefault:\n\t\tdev_err(dai->dev, \"Invalid frame sync polarity %d\\n\", format);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sst_get_ssp_mode(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tint format;\n\n\tformat = (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\tdev_dbg(dai->dev, \"Enter:%s, format=%x\\n\", __func__, format);\n\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\treturn SSP_MODE_PROVIDER;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\treturn SSP_MODE_CONSUMER;\n\tdefault:\n\t\tdev_err(dai->dev, \"Invalid ssp protocol: %d\\n\", format);\n\t}\n\n\treturn -EINVAL;\n}\n\n\nint sst_fill_ssp_config(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tunsigned int mode;\n\tint fs_polarity;\n\tstruct sst_data *ctx = snd_soc_dai_get_drvdata(dai);\n\n\tmode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tswitch (mode) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctx->ssp_cmd.ssp_protocol = SSP_MODE_PCM;\n\t\tctx->ssp_cmd.mode = sst_get_ssp_mode(dai, fmt) | (SSP_PCM_MODE_NETWORK << 1);\n\t\tctx->ssp_cmd.start_delay = 0;\n\t\tctx->ssp_cmd.data_polarity = 1;\n\t\tctx->ssp_cmd.frame_sync_width = 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctx->ssp_cmd.ssp_protocol = SSP_MODE_PCM;\n\t\tctx->ssp_cmd.mode = sst_get_ssp_mode(dai, fmt) | (SSP_PCM_MODE_NETWORK << 1);\n\t\tctx->ssp_cmd.start_delay = 1;\n\t\tctx->ssp_cmd.data_polarity = 1;\n\t\tctx->ssp_cmd.frame_sync_width = 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctx->ssp_cmd.ssp_protocol = SSP_MODE_I2S;\n\t\tctx->ssp_cmd.mode = sst_get_ssp_mode(dai, fmt) | (SSP_PCM_MODE_NORMAL << 1);\n\t\tctx->ssp_cmd.start_delay = 1;\n\t\tctx->ssp_cmd.data_polarity = 0;\n\t\tctx->ssp_cmd.frame_sync_width = ctx->ssp_cmd.nb_bits_per_slots;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctx->ssp_cmd.ssp_protocol = SSP_MODE_I2S;\n\t\tctx->ssp_cmd.mode = sst_get_ssp_mode(dai, fmt) | (SSP_PCM_MODE_NORMAL << 1);\n\t\tctx->ssp_cmd.start_delay = 0;\n\t\tctx->ssp_cmd.data_polarity = 0;\n\t\tctx->ssp_cmd.frame_sync_width = ctx->ssp_cmd.nb_bits_per_slots;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(dai->dev, \"using default ssp configs\\n\");\n\t}\n\n\tfs_polarity = sst_get_frame_sync_polarity(dai, fmt);\n\tif (fs_polarity < 0)\n\t\treturn fs_polarity;\n\n\tctx->ssp_cmd.frame_sync_polarity = fs_polarity;\n\n\treturn 0;\n}\n\n \nstatic const struct sst_ssp_config sst_ssp_configs = {\n\t.ssp_id = SSP_CODEC,\n\t.bits_per_slot = 24,\n\t.slots = 4,\n\t.ssp_mode = SSP_MODE_PROVIDER,\n\t.pcm_mode = SSP_PCM_MODE_NETWORK,\n\t.duplex = SSP_DUPLEX,\n\t.ssp_protocol = SSP_MODE_PCM,\n\t.fs_width = 1,\n\t.fs_frequency = SSP_FS_48_KHZ,\n\t.active_slot_map = 0xF,\n\t.start_delay = 0,\n\t.frame_sync_polarity = SSP_FS_ACTIVE_HIGH,\n\t.data_polarity = 1,\n};\n\nvoid sst_fill_ssp_defaults(struct snd_soc_dai *dai)\n{\n\tconst struct sst_ssp_config *config;\n\tstruct sst_data *ctx = snd_soc_dai_get_drvdata(dai);\n\n\tconfig = &sst_ssp_configs;\n\n\tctx->ssp_cmd.selection = config->ssp_id;\n\tctx->ssp_cmd.nb_bits_per_slots = config->bits_per_slot;\n\tctx->ssp_cmd.nb_slots = config->slots;\n\tctx->ssp_cmd.mode = config->ssp_mode | (config->pcm_mode << 1);\n\tctx->ssp_cmd.duplex = config->duplex;\n\tctx->ssp_cmd.active_tx_slot_map = config->active_slot_map;\n\tctx->ssp_cmd.active_rx_slot_map = config->active_slot_map;\n\tctx->ssp_cmd.frame_sync_frequency = config->fs_frequency;\n\tctx->ssp_cmd.frame_sync_polarity = config->frame_sync_polarity;\n\tctx->ssp_cmd.data_polarity = config->data_polarity;\n\tctx->ssp_cmd.frame_sync_width = config->fs_width;\n\tctx->ssp_cmd.ssp_protocol = config->ssp_protocol;\n\tctx->ssp_cmd.start_delay = config->start_delay;\n\tctx->ssp_cmd.reserved1 = ctx->ssp_cmd.reserved2 = 0xFF;\n}\n\nint send_ssp_cmd(struct snd_soc_dai *dai, const char *id, bool enable)\n{\n\tstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\n\tint ssp_id;\n\n\tdev_dbg(dai->dev, \"Enter: enable=%d port_name=%s\\n\", enable, id);\n\n\tif (strcmp(id, \"ssp0-port\") == 0)\n\t\tssp_id = SSP_MODEM;\n\telse if (strcmp(id, \"ssp2-port\") == 0)\n\t\tssp_id = SSP_CODEC;\n\telse {\n\t\tdev_dbg(dai->dev, \"port %s is not supported\\n\", id);\n\t\treturn -1;\n\t}\n\n\tSST_FILL_DEFAULT_DESTINATION(drv->ssp_cmd.header.dst);\n\tdrv->ssp_cmd.header.command_id = SBA_HW_SET_SSP;\n\tdrv->ssp_cmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)\n\t\t\t\t- sizeof(struct sst_dsp_header);\n\n\tdrv->ssp_cmd.selection = ssp_id;\n\tdev_dbg(dai->dev, \"ssp_id: %u\\n\", ssp_id);\n\n\tif (enable)\n\t\tdrv->ssp_cmd.switch_state = SST_SWITCH_ON;\n\telse\n\t\tdrv->ssp_cmd.switch_state = SST_SWITCH_OFF;\n\n\treturn sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\n\t\t\t\tSST_TASK_SBA, 0, &drv->ssp_cmd,\n\t\t\t\tsizeof(drv->ssp_cmd.header) + drv->ssp_cmd.header.length);\n}\n\nstatic int sst_set_be_modules(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *k, int event)\n{\n\tint ret = 0;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\n\tdev_dbg(c->dev, \"Enter: widget=%s\\n\", w->name);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tmutex_lock(&drv->lock);\n\t\tret = sst_send_slot_map(drv);\n\t\tmutex_unlock(&drv->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = sst_send_pipe_module_params(w, k);\n\t}\n\treturn ret;\n}\n\nstatic int sst_set_media_path(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *k, int event)\n{\n\tint ret = 0;\n\tstruct sst_cmd_set_media_path cmd;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\tstruct sst_ids *ids = w->priv;\n\n\tdev_dbg(c->dev, \"widget=%s\\n\", w->name);\n\tdev_dbg(c->dev, \"task=%u, location=%#x\\n\",\n\t\t\t\tids->task_id, ids->location_id);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tcmd.switch_state = SST_PATH_ON;\n\telse\n\t\tcmd.switch_state = SST_PATH_OFF;\n\n\tSST_FILL_DESTINATION(2, cmd.header.dst,\n\t\t\t     ids->location_id, SST_DEFAULT_MODULE_ID);\n\n\t \n\tcmd.header.command_id = MMX_SET_MEDIA_PATH;\n\tcmd.header.length = sizeof(struct sst_cmd_set_media_path)\n\t\t\t\t- sizeof(struct sst_dsp_header);\n\n\tret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\n\t\t\t      ids->task_id, 0, &cmd,\n\t\t\t      sizeof(cmd.header) + cmd.header.length);\n\tif (ret)\n\t\treturn ret;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tret = sst_send_pipe_module_params(w, k);\n\treturn ret;\n}\n\nstatic int sst_set_media_loop(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *k, int event)\n{\n\tint ret = 0;\n\tstruct sst_cmd_sba_set_media_loop_map cmd;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(c);\n\tstruct sst_ids *ids = w->priv;\n\n\tdev_dbg(c->dev, \"Enter:widget=%s\\n\", w->name);\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tcmd.switch_state = SST_SWITCH_ON;\n\telse\n\t\tcmd.switch_state = SST_SWITCH_OFF;\n\n\tSST_FILL_DESTINATION(2, cmd.header.dst,\n\t\t\t     ids->location_id, SST_DEFAULT_MODULE_ID);\n\n\tcmd.header.command_id = SBA_SET_MEDIA_LOOP_MAP;\n\tcmd.header.length = sizeof(struct sst_cmd_sba_set_media_loop_map)\n\t\t\t\t - sizeof(struct sst_dsp_header);\n\tcmd.param.part.cfg.rate = 2;  \n\n\tcmd.param.part.cfg.format = ids->format;  \n\tcmd.param.part.cfg.s_length = 1;  \n\tcmd.map = 0;  \n\n\tret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\n\t\t\t      SST_TASK_SBA, 0, &cmd,\n\t\t\t      sizeof(cmd.header) + cmd.header.length);\n\tif (ret)\n\t\treturn ret;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tret = sst_send_pipe_module_params(w, k);\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget sst_dapm_widgets[] = {\n\tSST_AIF_IN(\"modem_in\", sst_set_be_modules),\n\tSST_AIF_IN(\"codec_in0\", sst_set_be_modules),\n\tSST_AIF_IN(\"codec_in1\", sst_set_be_modules),\n\tSST_AIF_OUT(\"modem_out\", sst_set_be_modules),\n\tSST_AIF_OUT(\"codec_out0\", sst_set_be_modules),\n\tSST_AIF_OUT(\"codec_out1\", sst_set_be_modules),\n\n\t \n\t \n\tSST_PATH_INPUT(\"media0_in\", SST_TASK_MMX, SST_SWM_IN_MEDIA0, sst_generic_modules_event),\n\tSST_PATH_INPUT(\"media1_in\", SST_TASK_MMX, SST_SWM_IN_MEDIA1, NULL),\n\tSST_PATH_INPUT(\"media2_in\", SST_TASK_MMX, SST_SWM_IN_MEDIA2, sst_set_media_path),\n\tSST_PATH_INPUT(\"media3_in\", SST_TASK_MMX, SST_SWM_IN_MEDIA3, NULL),\n\tSST_PATH_OUTPUT(\"media0_out\", SST_TASK_MMX, SST_SWM_OUT_MEDIA0, sst_set_media_path),\n\tSST_PATH_OUTPUT(\"media1_out\", SST_TASK_MMX, SST_SWM_OUT_MEDIA1, sst_set_media_path),\n\n\t \n\tSST_PATH_INPUT(\"pcm0_in\", SST_TASK_SBA, SST_SWM_IN_PCM0, sst_set_media_path),\n\tSST_PATH_INPUT(\"pcm1_in\", SST_TASK_SBA, SST_SWM_IN_PCM1, sst_set_media_path),\n\tSST_PATH_OUTPUT(\"pcm0_out\", SST_TASK_SBA, SST_SWM_OUT_PCM0, sst_set_media_path),\n\tSST_PATH_OUTPUT(\"pcm1_out\", SST_TASK_SBA, SST_SWM_OUT_PCM1, sst_set_media_path),\n\tSST_PATH_OUTPUT(\"pcm2_out\", SST_TASK_SBA, SST_SWM_OUT_PCM2, sst_set_media_path),\n\n\t \n\tSST_PATH_INPUT(\"sprot_loop_in\", SST_TASK_SBA, SST_SWM_IN_SPROT_LOOP, NULL),\n\tSST_PATH_INPUT(\"media_loop1_in\", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP1, NULL),\n\tSST_PATH_INPUT(\"media_loop2_in\", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP2, NULL),\n\tSST_PATH_MEDIA_LOOP_OUTPUT(\"sprot_loop_out\", SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP, SST_FMT_STEREO, sst_set_media_loop),\n\tSST_PATH_MEDIA_LOOP_OUTPUT(\"media_loop1_out\", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1, SST_FMT_STEREO, sst_set_media_loop),\n\tSST_PATH_MEDIA_LOOP_OUTPUT(\"media_loop2_out\", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2, SST_FMT_STEREO, sst_set_media_loop),\n\n\t \n\tSST_SWM_MIXER(\"media0_out mix 0\", SND_SOC_NOPM, SST_TASK_MMX, SST_SWM_OUT_MEDIA0,\n\t\t      sst_mix_media0_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"media1_out mix 0\", SND_SOC_NOPM, SST_TASK_MMX, SST_SWM_OUT_MEDIA1,\n\t\t      sst_mix_media1_controls, sst_swm_mixer_event),\n\n\t \n\tSST_SWM_MIXER(\"pcm0_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM0,\n\t\t      sst_mix_pcm0_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"pcm1_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM1,\n\t\t      sst_mix_pcm1_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"pcm2_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM2,\n\t\t      sst_mix_pcm2_controls, sst_swm_mixer_event),\n\n\t \n\tSST_SWM_MIXER(\"sprot_loop_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP,\n\t\t      sst_mix_sprot_l0_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"media_loop1_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1,\n\t\t      sst_mix_media_l1_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"media_loop2_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2,\n\t\t      sst_mix_media_l2_controls, sst_swm_mixer_event),\n\n\t \n\tSST_SWM_MIXER(\"codec_out0 mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_CODEC0,\n\t\t      sst_mix_codec0_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"codec_out1 mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_CODEC1,\n\t\t      sst_mix_codec1_controls, sst_swm_mixer_event),\n\tSST_SWM_MIXER(\"modem_out mix 0\", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MODEM,\n\t\t      sst_mix_modem_controls, sst_swm_mixer_event),\n\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t{\"media0_in\", NULL, \"Compress Playback\"},\n\t{\"media1_in\", NULL, \"Headset Playback\"},\n\t{\"media2_in\", NULL, \"pcm0_out\"},\n\t{\"media3_in\", NULL, \"Deepbuffer Playback\"},\n\n\t{\"media0_out mix 0\", \"media0_in Switch\", \"media0_in\"},\n\t{\"media0_out mix 0\", \"media1_in Switch\", \"media1_in\"},\n\t{\"media0_out mix 0\", \"media2_in Switch\", \"media2_in\"},\n\t{\"media0_out mix 0\", \"media3_in Switch\", \"media3_in\"},\n\t{\"media1_out mix 0\", \"media0_in Switch\", \"media0_in\"},\n\t{\"media1_out mix 0\", \"media1_in Switch\", \"media1_in\"},\n\t{\"media1_out mix 0\", \"media2_in Switch\", \"media2_in\"},\n\t{\"media1_out mix 0\", \"media3_in Switch\", \"media3_in\"},\n\n\t{\"media0_out\", NULL, \"media0_out mix 0\"},\n\t{\"media1_out\", NULL, \"media1_out mix 0\"},\n\t{\"pcm0_in\", NULL, \"media0_out\"},\n\t{\"pcm1_in\", NULL, \"media1_out\"},\n\n\t{\"Headset Capture\", NULL, \"pcm1_out\"},\n\t{\"Headset Capture\", NULL, \"pcm2_out\"},\n\t{\"pcm0_out\", NULL, \"pcm0_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"pcm0_out mix 0\"),\n\t{\"pcm1_out\", NULL, \"pcm1_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"pcm1_out mix 0\"),\n\t{\"pcm2_out\", NULL, \"pcm2_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"pcm2_out mix 0\"),\n\n\t{\"media_loop1_in\", NULL, \"media_loop1_out\"},\n\t{\"media_loop1_out\", NULL, \"media_loop1_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"media_loop1_out mix 0\"),\n\t{\"media_loop2_in\", NULL, \"media_loop2_out\"},\n\t{\"media_loop2_out\", NULL, \"media_loop2_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"media_loop2_out mix 0\"),\n\t{\"sprot_loop_in\", NULL, \"sprot_loop_out\"},\n\t{\"sprot_loop_out\", NULL, \"sprot_loop_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"sprot_loop_out mix 0\"),\n\n\t{\"codec_out0\", NULL, \"codec_out0 mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"codec_out0 mix 0\"),\n\t{\"codec_out1\", NULL, \"codec_out1 mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"codec_out1 mix 0\"),\n\t{\"modem_out\", NULL, \"modem_out mix 0\"},\n\tSST_SBA_MIXER_GRAPH_MAP(\"modem_out mix 0\"),\n\n\n};\nstatic const char * const slot_names[] = {\n\t\"none\",\n\t\"slot 0\", \"slot 1\", \"slot 2\", \"slot 3\",\n\t\"slot 4\", \"slot 5\", \"slot 6\", \"slot 7\",  \n};\n\nstatic const char * const channel_names[] = {\n\t\"none\",\n\t\"codec_out0_0\", \"codec_out0_1\", \"codec_out1_0\", \"codec_out1_1\",\n\t\"codec_out2_0\", \"codec_out2_1\", \"codec_out3_0\", \"codec_out3_1\",  \n};\n\n#define SST_INTERLEAVER(xpname, slot_name, slotno) \\\n\tSST_SSP_SLOT_CTL(xpname, \"tx interleaver\", slot_name, slotno, true, \\\n\t\t\t channel_names, sst_slot_get, sst_slot_put)\n\n#define SST_DEINTERLEAVER(xpname, channel_name, channel_no) \\\n\tSST_SSP_SLOT_CTL(xpname, \"rx deinterleaver\", channel_name, channel_no, false, \\\n\t\t\t slot_names, sst_slot_get, sst_slot_put)\n\nstatic const struct snd_kcontrol_new sst_slot_controls[] = {\n\tSST_INTERLEAVER(\"codec_out\", \"slot 0\", 0),\n\tSST_INTERLEAVER(\"codec_out\", \"slot 1\", 1),\n\tSST_INTERLEAVER(\"codec_out\", \"slot 2\", 2),\n\tSST_INTERLEAVER(\"codec_out\", \"slot 3\", 3),\n\tSST_DEINTERLEAVER(\"codec_in\", \"codec_in0_0\", 0),\n\tSST_DEINTERLEAVER(\"codec_in\", \"codec_in0_1\", 1),\n\tSST_DEINTERLEAVER(\"codec_in\", \"codec_in1_0\", 2),\n\tSST_DEINTERLEAVER(\"codec_in\", \"codec_in1_1\", 3),\n};\n\n \n#define SST_GAIN(name, path_id, task_id, instance, gain_var)\t\t\t\t\\\n\tSST_GAIN_KCONTROLS(name, \"Gain\", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,\t\\\n\t\tSST_GAIN_TC_MIN, SST_GAIN_TC_MAX,\t\t\t\t\t\\\n\t\tsst_gain_get, sst_gain_put,\t\t\t\t\t\t\\\n\t\tSST_MODULE_ID_GAIN_CELL, path_id, instance, task_id,\t\t\t\\\n\t\tsst_gain_tlv_common, gain_var)\n\n#define SST_VOLUME(name, path_id, task_id, instance, gain_var)\t\t\t\t\\\n\tSST_GAIN_KCONTROLS(name, \"Volume\", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,\t\\\n\t\tSST_GAIN_TC_MIN, SST_GAIN_TC_MAX,\t\t\t\t\t\\\n\t\tsst_gain_get, sst_gain_put,\t\t\t\t\t\t\\\n\t\tSST_MODULE_ID_VOLUME, path_id, instance, task_id,\t\t\t\\\n\t\tsst_gain_tlv_common, gain_var)\n\nstatic struct sst_gain_value sst_gains[];\n\nstatic const struct snd_kcontrol_new sst_gain_controls[] = {\n\tSST_GAIN(\"media0_in\", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[0]),\n\tSST_GAIN(\"media1_in\", SST_PATH_INDEX_MEDIA1_IN, SST_TASK_MMX, 0, &sst_gains[1]),\n\tSST_GAIN(\"media2_in\", SST_PATH_INDEX_MEDIA2_IN, SST_TASK_MMX, 0, &sst_gains[2]),\n\tSST_GAIN(\"media3_in\", SST_PATH_INDEX_MEDIA3_IN, SST_TASK_MMX, 0, &sst_gains[3]),\n\n\tSST_GAIN(\"pcm0_in\", SST_PATH_INDEX_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[4]),\n\tSST_GAIN(\"pcm1_in\", SST_PATH_INDEX_PCM1_IN, SST_TASK_SBA, 0, &sst_gains[5]),\n\tSST_GAIN(\"pcm1_out\", SST_PATH_INDEX_PCM1_OUT, SST_TASK_SBA, 0, &sst_gains[6]),\n\tSST_GAIN(\"pcm2_out\", SST_PATH_INDEX_PCM2_OUT, SST_TASK_SBA, 0, &sst_gains[7]),\n\n\tSST_GAIN(\"codec_in0\", SST_PATH_INDEX_CODEC_IN0, SST_TASK_SBA, 0, &sst_gains[8]),\n\tSST_GAIN(\"codec_in1\", SST_PATH_INDEX_CODEC_IN1, SST_TASK_SBA, 0, &sst_gains[9]),\n\tSST_GAIN(\"codec_out0\", SST_PATH_INDEX_CODEC_OUT0, SST_TASK_SBA, 0, &sst_gains[10]),\n\tSST_GAIN(\"codec_out1\", SST_PATH_INDEX_CODEC_OUT1, SST_TASK_SBA, 0, &sst_gains[11]),\n\tSST_GAIN(\"media_loop1_out\", SST_PATH_INDEX_MEDIA_LOOP1_OUT, SST_TASK_SBA, 0, &sst_gains[12]),\n\tSST_GAIN(\"media_loop2_out\", SST_PATH_INDEX_MEDIA_LOOP2_OUT, SST_TASK_SBA, 0, &sst_gains[13]),\n\tSST_GAIN(\"sprot_loop_out\", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_TASK_SBA, 0, &sst_gains[14]),\n\tSST_VOLUME(\"media0_in\", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[15]),\n\tSST_GAIN(\"modem_in\", SST_PATH_INDEX_MODEM_IN, SST_TASK_SBA, 0, &sst_gains[16]),\n\tSST_GAIN(\"modem_out\", SST_PATH_INDEX_MODEM_OUT, SST_TASK_SBA, 0, &sst_gains[17]),\n\n};\n\n#define SST_GAIN_NUM_CONTROLS 3\n \nstatic struct sst_gain_value sst_gains[ARRAY_SIZE(sst_gain_controls)/SST_GAIN_NUM_CONTROLS];\n\nstatic const struct snd_kcontrol_new sst_algo_controls[] = {\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop1_out\", \"fir\", 272, SST_MODULE_ID_FIR_24,\n\t\t SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop1_out\", \"iir\", 300, SST_MODULE_ID_IIR_24,\n\t\tSST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop1_out\", \"mdrp\", 286, SST_MODULE_ID_MDRP,\n\t\tSST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop2_out\", \"fir\", 272, SST_MODULE_ID_FIR_24,\n\t\tSST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop2_out\", \"iir\", 300, SST_MODULE_ID_IIR_24,\n\t\tSST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),\n\tSST_ALGO_KCONTROL_BYTES(\"media_loop2_out\", \"mdrp\", 286, SST_MODULE_ID_MDRP,\n\t\tSST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),\n\tSST_ALGO_KCONTROL_BYTES(\"sprot_loop_out\", \"lpro\", 192, SST_MODULE_ID_SPROT,\n\t\tSST_PATH_INDEX_SPROT_LOOP_OUT, 0, SST_TASK_SBA, SBA_VB_LPRO),\n\tSST_ALGO_KCONTROL_BYTES(\"codec_in0\", \"dcr\", 52, SST_MODULE_ID_FILT_DCR,\n\t\tSST_PATH_INDEX_CODEC_IN0, 0, SST_TASK_SBA, SBA_VB_SET_IIR),\n\tSST_ALGO_KCONTROL_BYTES(\"codec_in1\", \"dcr\", 52, SST_MODULE_ID_FILT_DCR,\n\t\tSST_PATH_INDEX_CODEC_IN1, 0, SST_TASK_SBA, SBA_VB_SET_IIR),\n\n};\n\nstatic int sst_algo_control_init(struct device *dev)\n{\n\tint i = 0;\n\tstruct sst_algo_control *bc;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sst_algo_controls); i++) {\n\t\tbc = (struct sst_algo_control *)sst_algo_controls[i].private_value;\n\t\tbc->params = devm_kzalloc(dev, bc->max, GFP_KERNEL);\n\t\tif (bc->params == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic bool is_sst_dapm_widget(struct snd_soc_dapm_widget *w)\n{\n\tswitch (w->id) {\n\tcase snd_soc_dapm_pga:\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_input:\n\tcase snd_soc_dapm_output:\n\tcase snd_soc_dapm_mixer:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nint sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute)\n{\n\tstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, stream);\n\tstruct snd_soc_dapm_path *p;\n\n\tdev_dbg(dai->dev, \"enter, dai-name=%s dir=%d\\n\", dai->name, stream);\n\tdev_dbg(dai->dev, \"Stream name=%s\\n\", w->name);\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\t\tif (p->connected && !p->connected(w, p->sink))\n\t\t\t\tcontinue;\n\n\t\t\tif (p->connect && p->sink->power &&\n\t\t\t\t\tis_sst_dapm_widget(p->sink)) {\n\t\t\t\tstruct sst_ids *ids = p->sink->priv;\n\n\t\t\t\tdev_dbg(dai->dev, \"send gains for widget=%s\\n\",\n\t\t\t\t\t\tp->sink->name);\n\t\t\t\tmutex_lock(&drv->lock);\n\t\t\t\tsst_set_pipe_gain(ids, drv, mute);\n\t\t\t\tmutex_unlock(&drv->lock);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\t\tif (p->connected && !p->connected(w, p->source))\n\t\t\t\tcontinue;\n\n\t\t\tif (p->connect &&  p->source->power &&\n\t\t\t\t\tis_sst_dapm_widget(p->source)) {\n\t\t\t\tstruct sst_ids *ids = p->source->priv;\n\n\t\t\t\tdev_dbg(dai->dev, \"send gain for widget=%s\\n\",\n\t\t\t\t\t\tp->source->name);\n\t\t\t\tmutex_lock(&drv->lock);\n\t\t\t\tsst_set_pipe_gain(ids, drv, mute);\n\t\t\t\tmutex_unlock(&drv->lock);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int sst_fill_module_list(struct snd_kcontrol *kctl,\n\t struct snd_soc_dapm_widget *w, int type)\n{\n\tstruct sst_module *module;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct sst_ids *ids = w->priv;\n\tint ret = 0;\n\n\tmodule = devm_kzalloc(c->dev, sizeof(*module), GFP_KERNEL);\n\tif (!module)\n\t\treturn -ENOMEM;\n\n\tif (type == SST_MODULE_GAIN) {\n\t\tstruct sst_gain_mixer_control *mc = (void *)kctl->private_value;\n\n\t\tmc->w = w;\n\t\tmodule->kctl = kctl;\n\t\tlist_add_tail(&module->node, &ids->gain_list);\n\t} else if (type == SST_MODULE_ALGO) {\n\t\tstruct sst_algo_control *bc = (void *)kctl->private_value;\n\n\t\tbc->w = w;\n\t\tmodule->kctl = kctl;\n\t\tlist_add_tail(&module->node, &ids->algo_list);\n\t} else {\n\t\tdev_err(c->dev, \"invoked for unknown type %d module %s\",\n\t\t\t\ttype, kctl->id.name);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sst_fill_widget_module_info(struct snd_soc_dapm_widget *w,\n\tstruct snd_soc_component *component)\n{\n\tstruct snd_kcontrol *kctl;\n\tint index, ret = 0;\n\tstruct snd_card *card = component->card->snd_card;\n\tchar *idx;\n\n\tdown_read(&card->controls_rwsem);\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tidx = strchr(kctl->id.name, ' ');\n\t\tif (idx == NULL)\n\t\t\tcontinue;\n\t\tindex = idx - (char*)kctl->id.name;\n\t\tif (strncmp(kctl->id.name, w->name, index))\n\t\t\tcontinue;\n\n\t\tif (strstr(kctl->id.name, \"Volume\"))\n\t\t\tret = sst_fill_module_list(kctl, w, SST_MODULE_GAIN);\n\n\t\telse if (strstr(kctl->id.name, \"params\"))\n\t\t\tret = sst_fill_module_list(kctl, w, SST_MODULE_ALGO);\n\n\t\telse if (strstr(kctl->id.name, \"Switch\") &&\n\t\t\t strstr(kctl->id.name, \"Gain\")) {\n\t\t\tstruct sst_gain_mixer_control *mc =\n\t\t\t\t\t\t(void *)kctl->private_value;\n\n\t\t\tmc->w = w;\n\n\t\t} else if (strstr(kctl->id.name, \"interleaver\")) {\n\t\t\tstruct sst_enum *e = (void *)kctl->private_value;\n\n\t\t\te->w = w;\n\n\t\t} else if (strstr(kctl->id.name, \"deinterleaver\")) {\n\t\t\tstruct sst_enum *e = (void *)kctl->private_value;\n\n\t\t\te->w = w;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tup_read(&card->controls_rwsem);\n\treturn 0;\n}\n\n \nstatic void sst_fill_linked_widgets(struct snd_soc_component *component,\n\t\t\t\t\t\tstruct sst_ids *ids)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tunsigned int len = strlen(ids->parent_wname);\n\n\tlist_for_each_entry(w, &component->card->widgets, list) {\n\t\tif (!strncmp(ids->parent_wname, w->name, len)) {\n\t\t\tids->parent_w = w;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int sst_map_modules_to_pipe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tint ret = 0;\n\n\tlist_for_each_entry(w, &component->card->widgets, list) {\n\t\tif (is_sst_dapm_widget(w) && (w->priv)) {\n\t\t\tstruct sst_ids *ids = w->priv;\n\n\t\t\tdev_dbg(component->dev, \"widget type=%d name=%s\\n\",\n\t\t\t\t\tw->id, w->name);\n\t\t\tINIT_LIST_HEAD(&ids->algo_list);\n\t\t\tINIT_LIST_HEAD(&ids->gain_list);\n\t\t\tret = sst_fill_widget_module_info(w, component);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (ids->parent_wname !=  NULL)\n\t\t\t\tsst_fill_linked_widgets(component, ids);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint sst_dsp_init_v2_dpcm(struct snd_soc_component *component)\n{\n\tint i, ret = 0;\n\tstruct snd_soc_dapm_context *dapm =\n\t\t\tsnd_soc_component_get_dapm(component);\n\tstruct sst_data *drv = snd_soc_component_get_drvdata(component);\n\tunsigned int gains = ARRAY_SIZE(sst_gain_controls)/3;\n\n\tdrv->byte_stream = devm_kzalloc(component->dev,\n\t\t\t\t\tSST_MAX_BIN_BYTES, GFP_KERNEL);\n\tif (!drv->byte_stream)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_dapm_new_controls(dapm, sst_dapm_widgets,\n\t\t\tARRAY_SIZE(sst_dapm_widgets));\n\tsnd_soc_dapm_add_routes(dapm, intercon,\n\t\t\tARRAY_SIZE(intercon));\n\tsnd_soc_dapm_new_widgets(dapm->card);\n\n\tfor (i = 0; i < gains; i++) {\n\t\tsst_gains[i].mute = SST_GAIN_MUTE_DEFAULT;\n\t\tsst_gains[i].l_gain = SST_GAIN_VOLUME_DEFAULT;\n\t\tsst_gains[i].r_gain = SST_GAIN_VOLUME_DEFAULT;\n\t\tsst_gains[i].ramp_duration = SST_GAIN_RAMP_DURATION_DEFAULT;\n\t}\n\n\tret = snd_soc_add_component_controls(component, sst_gain_controls,\n\t\t\tARRAY_SIZE(sst_gain_controls));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = sst_algo_control_init(component->dev);\n\tif (ret)\n\t\treturn ret;\n\tret = snd_soc_add_component_controls(component, sst_algo_controls,\n\t\t\tARRAY_SIZE(sst_algo_controls));\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_add_component_controls(component, sst_slot_controls,\n\t\t\tARRAY_SIZE(sst_slot_controls));\n\tif (ret)\n\t\treturn ret;\n\n\tret = sst_map_modules_to_pipe(component);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}