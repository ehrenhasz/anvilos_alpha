{
  "module_name": "sst-ipc.c",
  "hash_id": "e1e18b0c1c5b5439d1cf5eb6b35067a472cc95342c53d6ec9aa5fe428efe899a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/common/sst-ipc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <sound/asound.h>\n\n#include \"sst-dsp.h\"\n#include \"sst-dsp-priv.h\"\n#include \"sst-ipc.h\"\n\n \n#define IPC_TIMEOUT_MSECS\t300\n\n#define IPC_EMPTY_LIST_SIZE\t8\n\n \nstatic struct ipc_message *msg_get_empty(struct sst_generic_ipc *ipc)\n{\n\tstruct ipc_message *msg = NULL;\n\n\tif (!list_empty(&ipc->empty_list)) {\n\t\tmsg = list_first_entry(&ipc->empty_list, struct ipc_message,\n\t\t\tlist);\n\t\tlist_del(&msg->list);\n\t}\n\n\treturn msg;\n}\n\nstatic int tx_wait_done(struct sst_generic_ipc *ipc,\n\tstruct ipc_message *msg, struct sst_ipc_message *reply)\n{\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tret = wait_event_timeout(msg->waitq, msg->complete,\n\t\tmsecs_to_jiffies(IPC_TIMEOUT_MSECS));\n\n\tspin_lock_irqsave(&ipc->dsp->spinlock, flags);\n\tif (ret == 0) {\n\t\tif (ipc->ops.shim_dbg != NULL)\n\t\t\tipc->ops.shim_dbg(ipc, \"message timeout\");\n\n\t\tlist_del(&msg->list);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\n\t\t \n\t\tif (reply) {\n\t\t\treply->header = msg->rx.header;\n\t\t\tif (reply->data)\n\t\t\t\tmemcpy(reply->data, msg->rx.data, msg->rx.size);\n\t\t}\n\t\tret = msg->errno;\n\t}\n\n\tlist_add_tail(&msg->list, &ipc->empty_list);\n\tspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\n\treturn ret;\n}\n\nstatic int ipc_tx_message(struct sst_generic_ipc *ipc,\n\tstruct sst_ipc_message request,\n\tstruct sst_ipc_message *reply, int wait)\n{\n\tstruct ipc_message *msg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipc->dsp->spinlock, flags);\n\n\tmsg = msg_get_empty(ipc);\n\tif (msg == NULL) {\n\t\tspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tmsg->tx.header = request.header;\n\tmsg->tx.size = request.size;\n\tmsg->rx.header = 0;\n\tmsg->rx.size = reply ? reply->size : 0;\n\tmsg->wait = wait;\n\tmsg->errno = 0;\n\tmsg->pending = false;\n\tmsg->complete = false;\n\n\tif ((request.size) && (ipc->ops.tx_data_copy != NULL))\n\t\tipc->ops.tx_data_copy(msg, request.data, request.size);\n\n\tlist_add_tail(&msg->list, &ipc->tx_list);\n\tschedule_work(&ipc->kwork);\n\tspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\n\n\tif (wait)\n\t\treturn tx_wait_done(ipc, msg, reply);\n\telse\n\t\treturn 0;\n}\n\nstatic int msg_empty_list_init(struct sst_generic_ipc *ipc)\n{\n\tint i;\n\n\tipc->msg = kcalloc(IPC_EMPTY_LIST_SIZE, sizeof(struct ipc_message),\n\t\t\t   GFP_KERNEL);\n\tif (ipc->msg == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {\n\t\tipc->msg[i].tx.data = kzalloc(ipc->tx_data_max_size, GFP_KERNEL);\n\t\tif (ipc->msg[i].tx.data == NULL)\n\t\t\tgoto free_mem;\n\n\t\tipc->msg[i].rx.data = kzalloc(ipc->rx_data_max_size, GFP_KERNEL);\n\t\tif (ipc->msg[i].rx.data == NULL) {\n\t\t\tkfree(ipc->msg[i].tx.data);\n\t\t\tgoto free_mem;\n\t\t}\n\n\t\tinit_waitqueue_head(&ipc->msg[i].waitq);\n\t\tlist_add(&ipc->msg[i].list, &ipc->empty_list);\n\t}\n\n\treturn 0;\n\nfree_mem:\n\twhile (i > 0) {\n\t\tkfree(ipc->msg[i-1].tx.data);\n\t\tkfree(ipc->msg[i-1].rx.data);\n\t\t--i;\n\t}\n\tkfree(ipc->msg);\n\n\treturn -ENOMEM;\n}\n\nstatic void ipc_tx_msgs(struct work_struct *work)\n{\n\tstruct sst_generic_ipc *ipc =\n\t\tcontainer_of(work, struct sst_generic_ipc, kwork);\n\tstruct ipc_message *msg;\n\n\tspin_lock_irq(&ipc->dsp->spinlock);\n\n\twhile (!list_empty(&ipc->tx_list) && !ipc->pending) {\n\t\t \n\t\tif (ipc->ops.is_dsp_busy && ipc->ops.is_dsp_busy(ipc->dsp)) {\n\t\t\tdev_dbg(ipc->dev, \"ipc_tx_msgs dsp busy\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = list_first_entry(&ipc->tx_list, struct ipc_message, list);\n\t\tlist_move(&msg->list, &ipc->rx_list);\n\n\t\tif (ipc->ops.tx_msg != NULL)\n\t\t\tipc->ops.tx_msg(ipc, msg);\n\t}\n\n\tspin_unlock_irq(&ipc->dsp->spinlock);\n}\n\nint sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc,\n\tstruct sst_ipc_message request, struct sst_ipc_message *reply)\n{\n\tint ret;\n\n\t \n\tif (ipc->ops.check_dsp_lp_on)\n\t\tif (ipc->ops.check_dsp_lp_on(ipc->dsp, true))\n\t\t\treturn -EIO;\n\n\tret = ipc_tx_message(ipc, request, reply, 1);\n\n\tif (ipc->ops.check_dsp_lp_on)\n\t\tif (ipc->ops.check_dsp_lp_on(ipc->dsp, false))\n\t\t\treturn -EIO;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sst_ipc_tx_message_wait);\n\nint sst_ipc_tx_message_nowait(struct sst_generic_ipc *ipc,\n\tstruct sst_ipc_message request)\n{\n\treturn ipc_tx_message(ipc, request, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(sst_ipc_tx_message_nowait);\n\nint sst_ipc_tx_message_nopm(struct sst_generic_ipc *ipc,\n\tstruct sst_ipc_message request, struct sst_ipc_message *reply)\n{\n\treturn ipc_tx_message(ipc, request, reply, 1);\n}\nEXPORT_SYMBOL_GPL(sst_ipc_tx_message_nopm);\n\nstruct ipc_message *sst_ipc_reply_find_msg(struct sst_generic_ipc *ipc,\n\tu64 header)\n{\n\tstruct ipc_message *msg;\n\tu64 mask;\n\n\tif (ipc->ops.reply_msg_match != NULL)\n\t\theader = ipc->ops.reply_msg_match(header, &mask);\n\telse\n\t\tmask = (u64)-1;\n\n\tif (list_empty(&ipc->rx_list)) {\n\t\tdev_err(ipc->dev, \"error: rx list empty but received 0x%llx\\n\",\n\t\t\theader);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(msg, &ipc->rx_list, list) {\n\t\tif ((msg->tx.header & mask) == header)\n\t\t\treturn msg;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(sst_ipc_reply_find_msg);\n\n \nvoid sst_ipc_tx_msg_reply_complete(struct sst_generic_ipc *ipc,\n\tstruct ipc_message *msg)\n{\n\tmsg->complete = true;\n\n\tif (!msg->wait)\n\t\tlist_add_tail(&msg->list, &ipc->empty_list);\n\telse\n\t\twake_up(&msg->waitq);\n}\nEXPORT_SYMBOL_GPL(sst_ipc_tx_msg_reply_complete);\n\nint sst_ipc_init(struct sst_generic_ipc *ipc)\n{\n\tint ret;\n\n\tINIT_LIST_HEAD(&ipc->tx_list);\n\tINIT_LIST_HEAD(&ipc->rx_list);\n\tINIT_LIST_HEAD(&ipc->empty_list);\n\tinit_waitqueue_head(&ipc->wait_txq);\n\n\tret = msg_empty_list_init(ipc);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ipc->kwork, ipc_tx_msgs);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sst_ipc_init);\n\nvoid sst_ipc_fini(struct sst_generic_ipc *ipc)\n{\n\tint i;\n\n\tcancel_work_sync(&ipc->kwork);\n\n\tif (ipc->msg) {\n\t\tfor (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {\n\t\t\tkfree(ipc->msg[i].tx.data);\n\t\t\tkfree(ipc->msg[i].rx.data);\n\t\t}\n\t\tkfree(ipc->msg);\n\t}\n}\nEXPORT_SYMBOL_GPL(sst_ipc_fini);\n\n \nMODULE_AUTHOR(\"Jin Yao\");\nMODULE_DESCRIPTION(\"Intel SST IPC generic\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}