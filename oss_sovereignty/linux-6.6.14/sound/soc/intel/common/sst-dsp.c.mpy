{
  "module_name": "sst-dsp.c",
  "hash_id": "1c9edc967bd73b11c7a0f8c384bac7ef3853a318d42844d441963ba28a686408",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/common/sst-dsp.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/delay.h>\n\n#include \"sst-dsp.h\"\n#include \"sst-dsp-priv.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/intel-sst.h>\n\n \nvoid sst_shim32_write(void __iomem *addr, u32 offset, u32 value)\n{\n\twritel(value, addr + offset);\n}\nEXPORT_SYMBOL_GPL(sst_shim32_write);\n\nu32 sst_shim32_read(void __iomem *addr, u32 offset)\n{\n\treturn readl(addr + offset);\n}\nEXPORT_SYMBOL_GPL(sst_shim32_read);\n\nvoid sst_shim32_write64(void __iomem *addr, u32 offset, u64 value)\n{\n\twriteq(value, addr + offset);\n}\nEXPORT_SYMBOL_GPL(sst_shim32_write64);\n\nu64 sst_shim32_read64(void __iomem *addr, u32 offset)\n{\n\treturn readq(addr + offset);\n}\nEXPORT_SYMBOL_GPL(sst_shim32_read64);\n\n \nvoid sst_dsp_shim_write(struct sst_dsp *sst, u32 offset, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sst->spinlock, flags);\n\tsst->ops->write(sst->addr.shim, offset, value);\n\tspin_unlock_irqrestore(&sst->spinlock, flags);\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_write);\n\nu32 sst_dsp_shim_read(struct sst_dsp *sst, u32 offset)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&sst->spinlock, flags);\n\tval = sst->ops->read(sst->addr.shim, offset);\n\tspin_unlock_irqrestore(&sst->spinlock, flags);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_read);\n\nvoid sst_dsp_shim_write_unlocked(struct sst_dsp *sst, u32 offset, u32 value)\n{\n\tsst->ops->write(sst->addr.shim, offset, value);\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_write_unlocked);\n\nu32 sst_dsp_shim_read_unlocked(struct sst_dsp *sst, u32 offset)\n{\n\treturn sst->ops->read(sst->addr.shim, offset);\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_read_unlocked);\n\nint sst_dsp_shim_update_bits_unlocked(struct sst_dsp *sst, u32 offset,\n\t\t\t\tu32 mask, u32 value)\n{\n\tbool change;\n\tunsigned int old, new;\n\tu32 ret;\n\n\tret = sst_dsp_shim_read_unlocked(sst, offset);\n\n\told = ret;\n\tnew = (old & (~mask)) | (value & mask);\n\n\tchange = (old != new);\n\tif (change)\n\t\tsst_dsp_shim_write_unlocked(sst, offset, new);\n\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits_unlocked);\n\n \nvoid sst_dsp_shim_update_bits_forced_unlocked(struct sst_dsp *sst, u32 offset,\n\t\t\t\tu32 mask, u32 value)\n{\n\tunsigned int old, new;\n\tu32 ret;\n\n\tret = sst_dsp_shim_read_unlocked(sst, offset);\n\n\told = ret;\n\tnew = (old & (~mask)) | (value & mask);\n\n\tsst_dsp_shim_write_unlocked(sst, offset, new);\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits_forced_unlocked);\n\nint sst_dsp_shim_update_bits(struct sst_dsp *sst, u32 offset,\n\t\t\t\tu32 mask, u32 value)\n{\n\tunsigned long flags;\n\tbool change;\n\n\tspin_lock_irqsave(&sst->spinlock, flags);\n\tchange = sst_dsp_shim_update_bits_unlocked(sst, offset, mask, value);\n\tspin_unlock_irqrestore(&sst->spinlock, flags);\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits);\n\n \nvoid sst_dsp_shim_update_bits_forced(struct sst_dsp *sst, u32 offset,\n\t\t\t\tu32 mask, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sst->spinlock, flags);\n\tsst_dsp_shim_update_bits_forced_unlocked(sst, offset, mask, value);\n\tspin_unlock_irqrestore(&sst->spinlock, flags);\n}\nEXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits_forced);\n\nint sst_dsp_register_poll(struct sst_dsp *ctx, u32 offset, u32 mask,\n\t\t\t u32 target, u32 time, char *operation)\n{\n\tu32 reg;\n\tunsigned long timeout;\n\tint k = 0, s = 500;\n\n\t \n\n\ttimeout = jiffies + msecs_to_jiffies(time);\n\twhile ((((reg = sst_dsp_shim_read_unlocked(ctx, offset)) & mask) != target)\n\t\t&& time_before(jiffies, timeout)) {\n\t\tk++;\n\t\tif (k > 10)\n\t\t\ts = 5000;\n\n\t\tusleep_range(s, 2*s);\n\t}\n\n\tif ((reg & mask) == target) {\n\t\tdev_dbg(ctx->dev, \"FW Poll Status: reg=%#x %s successful\\n\",\n\t\t\t\t\treg, operation);\n\n\t\treturn 0;\n\t}\n\n\tdev_dbg(ctx->dev, \"FW Poll Status: reg=%#x %s timedout\\n\",\n\t\t\t\t\treg, operation);\n\treturn -ETIME;\n}\nEXPORT_SYMBOL_GPL(sst_dsp_register_poll);\n\nint sst_dsp_mailbox_init(struct sst_dsp *sst, u32 inbox_offset, size_t inbox_size,\n\tu32 outbox_offset, size_t outbox_size)\n{\n\tsst->mailbox.in_base = sst->addr.lpe + inbox_offset;\n\tsst->mailbox.out_base = sst->addr.lpe + outbox_offset;\n\tsst->mailbox.in_size = inbox_size;\n\tsst->mailbox.out_size = outbox_size;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sst_dsp_mailbox_init);\n\nvoid sst_dsp_outbox_write(struct sst_dsp *sst, void *message, size_t bytes)\n{\n\tu32 i;\n\n\ttrace_sst_ipc_outbox_write(bytes);\n\n\tmemcpy_toio(sst->mailbox.out_base, message, bytes);\n\n\tfor (i = 0; i < bytes; i += 4)\n\t\ttrace_sst_ipc_outbox_wdata(i, *(u32 *)(message + i));\n}\nEXPORT_SYMBOL_GPL(sst_dsp_outbox_write);\n\nvoid sst_dsp_outbox_read(struct sst_dsp *sst, void *message, size_t bytes)\n{\n\tu32 i;\n\n\ttrace_sst_ipc_outbox_read(bytes);\n\n\tmemcpy_fromio(message, sst->mailbox.out_base, bytes);\n\n\tfor (i = 0; i < bytes; i += 4)\n\t\ttrace_sst_ipc_outbox_rdata(i, *(u32 *)(message + i));\n}\nEXPORT_SYMBOL_GPL(sst_dsp_outbox_read);\n\nvoid sst_dsp_inbox_write(struct sst_dsp *sst, void *message, size_t bytes)\n{\n\tu32 i;\n\n\ttrace_sst_ipc_inbox_write(bytes);\n\n\tmemcpy_toio(sst->mailbox.in_base, message, bytes);\n\n\tfor (i = 0; i < bytes; i += 4)\n\t\ttrace_sst_ipc_inbox_wdata(i, *(u32 *)(message + i));\n}\nEXPORT_SYMBOL_GPL(sst_dsp_inbox_write);\n\nvoid sst_dsp_inbox_read(struct sst_dsp *sst, void *message, size_t bytes)\n{\n\tu32 i;\n\n\ttrace_sst_ipc_inbox_read(bytes);\n\n\tmemcpy_fromio(message, sst->mailbox.in_base, bytes);\n\n\tfor (i = 0; i < bytes; i += 4)\n\t\ttrace_sst_ipc_inbox_rdata(i, *(u32 *)(message + i));\n}\nEXPORT_SYMBOL_GPL(sst_dsp_inbox_read);\n\n \nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_DESCRIPTION(\"Intel SST Core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}