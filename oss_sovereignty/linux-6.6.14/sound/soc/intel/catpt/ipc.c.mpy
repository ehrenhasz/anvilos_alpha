{
  "module_name": "ipc.c",
  "hash_id": "5d0efae741b5b6685a694740d1935c261974a31addce69e28b8880a785d4c077",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/catpt/ipc.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/irqreturn.h>\n#include \"core.h\"\n#include \"messages.h\"\n#include \"registers.h\"\n#include \"trace.h\"\n\n#define CATPT_IPC_TIMEOUT_MS\t300\n\nvoid catpt_ipc_init(struct catpt_ipc *ipc, struct device *dev)\n{\n\tipc->dev = dev;\n\tipc->ready = false;\n\tipc->default_timeout = CATPT_IPC_TIMEOUT_MS;\n\tinit_completion(&ipc->done_completion);\n\tinit_completion(&ipc->busy_completion);\n\tspin_lock_init(&ipc->lock);\n\tmutex_init(&ipc->mutex);\n}\n\nstatic int catpt_ipc_arm(struct catpt_ipc *ipc, struct catpt_fw_ready *config)\n{\n\t \n\tipc->rx.data = devm_kzalloc(ipc->dev, config->outbox_size, GFP_KERNEL);\n\tif (!ipc->rx.data)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&ipc->config, config, sizeof(*config));\n\tipc->ready = true;\n\n\treturn 0;\n}\n\nstatic void catpt_ipc_msg_init(struct catpt_ipc *ipc,\n\t\t\t       struct catpt_ipc_msg *reply)\n{\n\tlockdep_assert_held(&ipc->lock);\n\n\tipc->rx.header = 0;\n\tipc->rx.size = reply ? reply->size : 0;\n\treinit_completion(&ipc->done_completion);\n\treinit_completion(&ipc->busy_completion);\n}\n\nstatic void catpt_dsp_send_tx(struct catpt_dev *cdev,\n\t\t\t      const struct catpt_ipc_msg *tx)\n{\n\tu32 header = tx->header | CATPT_IPCC_BUSY;\n\n\ttrace_catpt_ipc_request(header);\n\ttrace_catpt_ipc_payload(tx->data, tx->size);\n\n\tmemcpy_toio(catpt_outbox_addr(cdev), tx->data, tx->size);\n\tcatpt_writel_shim(cdev, IPCC, header);\n}\n\nstatic int catpt_wait_msg_completion(struct catpt_dev *cdev, int timeout)\n{\n\tstruct catpt_ipc *ipc = &cdev->ipc;\n\tint ret;\n\n\tret = wait_for_completion_timeout(&ipc->done_completion,\n\t\t\t\t\t  msecs_to_jiffies(timeout));\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\tif (ipc->rx.rsp.status != CATPT_REPLY_PENDING)\n\t\treturn 0;\n\n\t \n\tret = wait_for_completion_timeout(&ipc->busy_completion,\n\t\t\t\t\t  msecs_to_jiffies(timeout));\n\treturn ret ? 0 : -ETIMEDOUT;\n}\n\nstatic int catpt_dsp_do_send_msg(struct catpt_dev *cdev,\n\t\t\t\t struct catpt_ipc_msg request,\n\t\t\t\t struct catpt_ipc_msg *reply, int timeout)\n{\n\tstruct catpt_ipc *ipc = &cdev->ipc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!ipc->ready)\n\t\treturn -EPERM;\n\tif (request.size > ipc->config.outbox_size ||\n\t    (reply && reply->size > ipc->config.outbox_size))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ipc->lock, flags);\n\tcatpt_ipc_msg_init(ipc, reply);\n\tcatpt_dsp_send_tx(cdev, &request);\n\tspin_unlock_irqrestore(&ipc->lock, flags);\n\n\tret = catpt_wait_msg_completion(cdev, timeout);\n\tif (ret) {\n\t\tdev_crit(cdev->dev, \"communication severed: %d, rebooting dsp..\\n\",\n\t\t\t ret);\n\t\tipc->ready = false;\n\t\t \n\t\treturn ret;\n\t}\n\n\tret = ipc->rx.rsp.status;\n\tif (reply) {\n\t\treply->header = ipc->rx.header;\n\n\t\tif (!ret && reply->data)\n\t\t\tmemcpy(reply->data, ipc->rx.data, reply->size);\n\t}\n\n\treturn ret;\n}\n\nint catpt_dsp_send_msg_timeout(struct catpt_dev *cdev,\n\t\t\t       struct catpt_ipc_msg request,\n\t\t\t       struct catpt_ipc_msg *reply, int timeout)\n{\n\tstruct catpt_ipc *ipc = &cdev->ipc;\n\tint ret;\n\n\tmutex_lock(&ipc->mutex);\n\tret = catpt_dsp_do_send_msg(cdev, request, reply, timeout);\n\tmutex_unlock(&ipc->mutex);\n\n\treturn ret;\n}\n\nint catpt_dsp_send_msg(struct catpt_dev *cdev, struct catpt_ipc_msg request,\n\t\t       struct catpt_ipc_msg *reply)\n{\n\treturn catpt_dsp_send_msg_timeout(cdev, request, reply,\n\t\t\t\t\t  cdev->ipc.default_timeout);\n}\n\nstatic void\ncatpt_dsp_notify_stream(struct catpt_dev *cdev, union catpt_notify_msg msg)\n{\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_notify_position pos;\n\tstruct catpt_notify_glitch glitch;\n\n\tstream = catpt_stream_find(cdev, msg.stream_hw_id);\n\tif (!stream) {\n\t\tdev_warn(cdev->dev, \"notify %d for non-existent stream %d\\n\",\n\t\t\t msg.notify_reason, msg.stream_hw_id);\n\t\treturn;\n\t}\n\n\tswitch (msg.notify_reason) {\n\tcase CATPT_NOTIFY_POSITION_CHANGED:\n\t\tmemcpy_fromio(&pos, catpt_inbox_addr(cdev), sizeof(pos));\n\t\ttrace_catpt_ipc_payload((u8 *)&pos, sizeof(pos));\n\n\t\tcatpt_stream_update_position(cdev, stream, &pos);\n\t\tbreak;\n\n\tcase CATPT_NOTIFY_GLITCH_OCCURRED:\n\t\tmemcpy_fromio(&glitch, catpt_inbox_addr(cdev), sizeof(glitch));\n\t\ttrace_catpt_ipc_payload((u8 *)&glitch, sizeof(glitch));\n\n\t\tdev_warn(cdev->dev, \"glitch %d at pos: 0x%08llx, wp: 0x%08x\\n\",\n\t\t\t glitch.type, glitch.presentation_pos,\n\t\t\t glitch.write_pos);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(cdev->dev, \"unknown notification: %d received\\n\",\n\t\t\t msg.notify_reason);\n\t\tbreak;\n\t}\n}\n\nstatic void catpt_dsp_copy_rx(struct catpt_dev *cdev, u32 header)\n{\n\tstruct catpt_ipc *ipc = &cdev->ipc;\n\n\tipc->rx.header = header;\n\tif (ipc->rx.rsp.status != CATPT_REPLY_SUCCESS)\n\t\treturn;\n\n\tmemcpy_fromio(ipc->rx.data, catpt_outbox_addr(cdev), ipc->rx.size);\n\ttrace_catpt_ipc_payload(ipc->rx.data, ipc->rx.size);\n}\n\nstatic void catpt_dsp_process_response(struct catpt_dev *cdev, u32 header)\n{\n\tunion catpt_notify_msg msg = CATPT_MSG(header);\n\tstruct catpt_ipc *ipc = &cdev->ipc;\n\n\tif (msg.fw_ready) {\n\t\tstruct catpt_fw_ready config;\n\t\t \n\t\tu32 off = msg.mailbox_address << 3;\n\n\t\tmemcpy_fromio(&config, cdev->lpe_ba + off, sizeof(config));\n\t\ttrace_catpt_ipc_payload((u8 *)&config, sizeof(config));\n\n\t\tcatpt_ipc_arm(ipc, &config);\n\t\tcomplete(&cdev->fw_ready);\n\t\treturn;\n\t}\n\n\tswitch (msg.global_msg_type) {\n\tcase CATPT_GLB_REQUEST_CORE_DUMP:\n\t\tdev_err(cdev->dev, \"ADSP device coredump received\\n\");\n\t\tipc->ready = false;\n\t\tcatpt_coredump(cdev);\n\t\t \n\t\tbreak;\n\n\tcase CATPT_GLB_STREAM_MESSAGE:\n\t\tswitch (msg.stream_msg_type) {\n\t\tcase CATPT_STRM_NOTIFICATION:\n\t\t\tcatpt_dsp_notify_stream(cdev, msg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcatpt_dsp_copy_rx(cdev, header);\n\t\t\t \n\t\t\tcomplete(&ipc->busy_completion);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(cdev->dev, \"unknown response: %d received\\n\",\n\t\t\t msg.global_msg_type);\n\t\tbreak;\n\t}\n}\n\nirqreturn_t catpt_dsp_irq_thread(int irq, void *dev_id)\n{\n\tstruct catpt_dev *cdev = dev_id;\n\tu32 ipcd;\n\n\tipcd = catpt_readl_shim(cdev, IPCD);\n\ttrace_catpt_ipc_notify(ipcd);\n\n\t \n\tif (!(ipcd & CATPT_IPCD_BUSY))\n\t\treturn IRQ_NONE;\n\n\tcatpt_dsp_process_response(cdev, ipcd);\n\n\t \n\tcatpt_updatel_shim(cdev, IPCD, CATPT_IPCD_BUSY | CATPT_IPCD_DONE,\n\t\t\t   CATPT_IPCD_DONE);\n\t \n\tcatpt_updatel_shim(cdev, IMC, CATPT_IMC_IPCDB, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t catpt_dsp_irq_handler(int irq, void *dev_id)\n{\n\tstruct catpt_dev *cdev = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 isc, ipcc;\n\n\tisc = catpt_readl_shim(cdev, ISC);\n\ttrace_catpt_irq(isc);\n\n\t \n\tif (isc & CATPT_ISC_IPCCD) {\n\t\t \n\t\tcatpt_updatel_shim(cdev, IMC, CATPT_IMC_IPCCD, CATPT_IMC_IPCCD);\n\n\t\tipcc = catpt_readl_shim(cdev, IPCC);\n\t\ttrace_catpt_ipc_reply(ipcc);\n\t\tcatpt_dsp_copy_rx(cdev, ipcc);\n\t\tcomplete(&cdev->ipc.done_completion);\n\n\t\t \n\t\tcatpt_updatel_shim(cdev, IPCC, CATPT_IPCC_DONE, 0);\n\t\t \n\t\tcatpt_updatel_shim(cdev, IMC, CATPT_IMC_IPCCD, 0);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (isc & CATPT_ISC_IPCDB) {\n\t\t \n\t\tcatpt_updatel_shim(cdev, IMC, CATPT_IMC_IPCDB, CATPT_IMC_IPCDB);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}