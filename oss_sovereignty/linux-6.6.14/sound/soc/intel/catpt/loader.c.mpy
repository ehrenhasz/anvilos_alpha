{
  "module_name": "loader.c",
  "hash_id": "a5f4de750f2d0fbec0cfe7a9e072ed9c687a7479bab0376566959164136ceea0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/catpt/loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include \"core.h\"\n#include \"registers.h\"\n\n \n#define FW_READY_TIMEOUT_MS\t250\n\n#define FW_SIGNATURE\t\t\"$SST\"\n#define FW_SIGNATURE_SIZE\t4\n\nstruct catpt_fw_hdr {\n\tchar signature[FW_SIGNATURE_SIZE];\n\tu32 file_size;\n\tu32 modules;\n\tu32 file_format;\n\tu32 reserved[4];\n} __packed;\n\nstruct catpt_fw_mod_hdr {\n\tchar signature[FW_SIGNATURE_SIZE];\n\tu32 mod_size;\n\tu32 blocks;\n\tu16 slot;\n\tu16 module_id;\n\tu32 entry_point;\n\tu32 persistent_size;\n\tu32 scratch_size;\n} __packed;\n\nenum catpt_ram_type {\n\tCATPT_RAM_TYPE_IRAM = 1,\n\tCATPT_RAM_TYPE_DRAM = 2,\n\t \n\tCATPT_RAM_TYPE_INSTANCE = 3,\n};\n\nstruct catpt_fw_block_hdr {\n\tu32 ram_type;\n\tu32 size;\n\tu32 ram_offset;\n\tu32 rsvd;\n} __packed;\n\nvoid catpt_sram_init(struct resource *sram, u32 start, u32 size)\n{\n\tsram->start = start;\n\tsram->end = start + size - 1;\n}\n\nvoid catpt_sram_free(struct resource *sram)\n{\n\tstruct resource *res, *save;\n\n\tfor (res = sram->child; res;) {\n\t\tsave = res->sibling;\n\t\trelease_resource(res);\n\t\tkfree(res);\n\t\tres = save;\n\t}\n}\n\nstruct resource *\ncatpt_request_region(struct resource *root, resource_size_t size)\n{\n\tstruct resource *res = root->child;\n\tresource_size_t addr = root->start;\n\n\tfor (;;) {\n\t\tif (res->start - addr >= size)\n\t\t\tbreak;\n\t\taddr = res->end + 1;\n\t\tres = res->sibling;\n\t\tif (!res)\n\t\t\treturn NULL;\n\t}\n\n\treturn __request_region(root, addr, size, NULL, 0);\n}\n\nint catpt_store_streams_context(struct catpt_dev *cdev, struct dma_chan *chan)\n{\n\tstruct catpt_stream_runtime *stream;\n\n\tlist_for_each_entry(stream, &cdev->stream_list, node) {\n\t\tu32 off, size;\n\t\tint ret;\n\n\t\toff = stream->persistent->start;\n\t\tsize = resource_size(stream->persistent);\n\t\tdev_dbg(cdev->dev, \"storing stream %d ctx: off 0x%08x size %d\\n\",\n\t\t\tstream->info.stream_hw_id, off, size);\n\n\t\tret = catpt_dma_memcpy_fromdsp(cdev, chan,\n\t\t\t\t\t       cdev->dxbuf_paddr + off,\n\t\t\t\t\t       cdev->lpe_base + off,\n\t\t\t\t\t       ALIGN(size, 4));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"memcpy fromdsp failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint catpt_store_module_states(struct catpt_dev *cdev, struct dma_chan *chan)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdev->modules); i++) {\n\t\tstruct catpt_module_type *type;\n\t\tu32 off;\n\t\tint ret;\n\n\t\ttype = &cdev->modules[i];\n\t\tif (!type->loaded || !type->state_size)\n\t\t\tcontinue;\n\n\t\toff = type->state_offset;\n\t\tdev_dbg(cdev->dev, \"storing mod %d state: off 0x%08x size %d\\n\",\n\t\t\ti, off, type->state_size);\n\n\t\tret = catpt_dma_memcpy_fromdsp(cdev, chan,\n\t\t\t\t\t       cdev->dxbuf_paddr + off,\n\t\t\t\t\t       cdev->lpe_base + off,\n\t\t\t\t\t       ALIGN(type->state_size, 4));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"memcpy fromdsp failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint catpt_store_memdumps(struct catpt_dev *cdev, struct dma_chan *chan)\n{\n\tint i;\n\n\tfor (i = 0; i < cdev->dx_ctx.num_meminfo; i++) {\n\t\tstruct catpt_save_meminfo *info;\n\t\tu32 off;\n\t\tint ret;\n\n\t\tinfo = &cdev->dx_ctx.meminfo[i];\n\t\tif (info->source != CATPT_DX_TYPE_MEMORY_DUMP)\n\t\t\tcontinue;\n\n\t\toff = catpt_to_host_offset(info->offset);\n\t\tif (off < cdev->dram.start || off > cdev->dram.end)\n\t\t\tcontinue;\n\n\t\tdev_dbg(cdev->dev, \"storing memdump: off 0x%08x size %d\\n\",\n\t\t\toff, info->size);\n\n\t\tret = catpt_dma_memcpy_fromdsp(cdev, chan,\n\t\t\t\t\t       cdev->dxbuf_paddr + off,\n\t\t\t\t\t       cdev->lpe_base + off,\n\t\t\t\t\t       ALIGN(info->size, 4));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"memcpy fromdsp failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncatpt_restore_streams_context(struct catpt_dev *cdev, struct dma_chan *chan)\n{\n\tstruct catpt_stream_runtime *stream;\n\n\tlist_for_each_entry(stream, &cdev->stream_list, node) {\n\t\tu32 off, size;\n\t\tint ret;\n\n\t\toff = stream->persistent->start;\n\t\tsize = resource_size(stream->persistent);\n\t\tdev_dbg(cdev->dev, \"restoring stream %d ctx: off 0x%08x size %d\\n\",\n\t\t\tstream->info.stream_hw_id, off, size);\n\n\t\tret = catpt_dma_memcpy_todsp(cdev, chan,\n\t\t\t\t\t     cdev->lpe_base + off,\n\t\t\t\t\t     cdev->dxbuf_paddr + off,\n\t\t\t\t\t     ALIGN(size, 4));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"memcpy fromdsp failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_restore_memdumps(struct catpt_dev *cdev, struct dma_chan *chan)\n{\n\tint i;\n\n\tfor (i = 0; i < cdev->dx_ctx.num_meminfo; i++) {\n\t\tstruct catpt_save_meminfo *info;\n\t\tu32 off;\n\t\tint ret;\n\n\t\tinfo = &cdev->dx_ctx.meminfo[i];\n\t\tif (info->source != CATPT_DX_TYPE_MEMORY_DUMP)\n\t\t\tcontinue;\n\n\t\toff = catpt_to_host_offset(info->offset);\n\t\tif (off < cdev->dram.start || off > cdev->dram.end)\n\t\t\tcontinue;\n\n\t\tdev_dbg(cdev->dev, \"restoring memdump: off 0x%08x size %d\\n\",\n\t\t\toff, info->size);\n\n\t\tret = catpt_dma_memcpy_todsp(cdev, chan,\n\t\t\t\t\t     cdev->lpe_base + off,\n\t\t\t\t\t     cdev->dxbuf_paddr + off,\n\t\t\t\t\t     ALIGN(info->size, 4));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"restore block failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_restore_fwimage(struct catpt_dev *cdev,\n\t\t\t\t struct dma_chan *chan, dma_addr_t paddr,\n\t\t\t\t struct catpt_fw_block_hdr *blk)\n{\n\tstruct resource r1, r2, common;\n\tint i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     blk, sizeof(*blk), false);\n\n\tr1.start = cdev->dram.start + blk->ram_offset;\n\tr1.end = r1.start + blk->size - 1;\n\t \n\tpaddr += sizeof(*blk);\n\n\tfor (i = 0; i < cdev->dx_ctx.num_meminfo; i++) {\n\t\tstruct catpt_save_meminfo *info;\n\t\tu32 off;\n\t\tint ret;\n\n\t\tinfo = &cdev->dx_ctx.meminfo[i];\n\n\t\tif (info->source != CATPT_DX_TYPE_FW_IMAGE)\n\t\t\tcontinue;\n\n\t\toff = catpt_to_host_offset(info->offset);\n\t\tif (off < cdev->dram.start || off > cdev->dram.end)\n\t\t\tcontinue;\n\n\t\tr2.start = off;\n\t\tr2.end = r2.start + info->size - 1;\n\n\t\tif (!resource_intersection(&r2, &r1, &common))\n\t\t\tcontinue;\n\t\t \n\t\toff = common.start - r1.start;\n\n\t\tdev_dbg(cdev->dev, \"restoring fwimage: %pr\\n\", &common);\n\n\t\tret = catpt_dma_memcpy_todsp(cdev, chan, common.start,\n\t\t\t\t\t     paddr + off,\n\t\t\t\t\t     resource_size(&common));\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"memcpy todsp failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_load_block(struct catpt_dev *cdev,\n\t\t\t    struct dma_chan *chan, dma_addr_t paddr,\n\t\t\t    struct catpt_fw_block_hdr *blk, bool alloc)\n{\n\tstruct resource *sram, *res;\n\tdma_addr_t dst_addr;\n\tint ret;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     blk, sizeof(*blk), false);\n\n\tswitch (blk->ram_type) {\n\tcase CATPT_RAM_TYPE_IRAM:\n\t\tsram = &cdev->iram;\n\t\tbreak;\n\tdefault:\n\t\tsram = &cdev->dram;\n\t\tbreak;\n\t}\n\n\tdst_addr = sram->start + blk->ram_offset;\n\tif (alloc) {\n\t\tres = __request_region(sram, dst_addr, blk->size, NULL, 0);\n\t\tif (!res)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tpaddr += sizeof(*blk);\n\n\tret = catpt_dma_memcpy_todsp(cdev, chan, dst_addr, paddr, blk->size);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"memcpy error: %d\\n\", ret);\n\t\t__release_region(sram, dst_addr, blk->size);\n\t}\n\n\treturn ret;\n}\n\nstatic int catpt_restore_basefw(struct catpt_dev *cdev,\n\t\t\t\tstruct dma_chan *chan, dma_addr_t paddr,\n\t\t\t\tstruct catpt_fw_mod_hdr *basefw)\n{\n\tu32 offset = sizeof(*basefw);\n\tint ret, i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     basefw, sizeof(*basefw), false);\n\n\t \n\tfor (i = 0; i < basefw->blocks; i++) {\n\t\tstruct catpt_fw_block_hdr *blk;\n\n\t\tblk = (struct catpt_fw_block_hdr *)((u8 *)basefw + offset);\n\n\t\tswitch (blk->ram_type) {\n\t\tcase CATPT_RAM_TYPE_IRAM:\n\t\t\tret = catpt_load_block(cdev, chan, paddr + offset,\n\t\t\t\t\t       blk, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = catpt_restore_fwimage(cdev, chan, paddr + offset,\n\t\t\t\t\t\t    blk);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"restore block failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += sizeof(*blk) + blk->size;\n\t}\n\n\t \n\tret = catpt_restore_memdumps(cdev, chan);\n\tif (ret)\n\t\tdev_err(cdev->dev, \"restore memdumps failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int catpt_restore_module(struct catpt_dev *cdev,\n\t\t\t\tstruct dma_chan *chan, dma_addr_t paddr,\n\t\t\t\tstruct catpt_fw_mod_hdr *mod)\n{\n\tu32 offset = sizeof(*mod);\n\tint i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     mod, sizeof(*mod), false);\n\n\tfor (i = 0; i < mod->blocks; i++) {\n\t\tstruct catpt_fw_block_hdr *blk;\n\t\tint ret;\n\n\t\tblk = (struct catpt_fw_block_hdr *)((u8 *)mod + offset);\n\n\t\tswitch (blk->ram_type) {\n\t\tcase CATPT_RAM_TYPE_INSTANCE:\n\t\t\t \n\t\t\tret = catpt_dma_memcpy_todsp(cdev, chan,\n\t\t\t\t\tcdev->lpe_base + blk->ram_offset,\n\t\t\t\t\tcdev->dxbuf_paddr + blk->ram_offset,\n\t\t\t\t\tALIGN(blk->size, 4));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = catpt_load_block(cdev, chan, paddr + offset,\n\t\t\t\t\t       blk, false);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"restore block failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += sizeof(*blk) + blk->size;\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_load_module(struct catpt_dev *cdev,\n\t\t\t     struct dma_chan *chan, dma_addr_t paddr,\n\t\t\t     struct catpt_fw_mod_hdr *mod)\n{\n\tstruct catpt_module_type *type;\n\tu32 offset = sizeof(*mod);\n\tint i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     mod, sizeof(*mod), false);\n\n\ttype = &cdev->modules[mod->module_id];\n\n\tfor (i = 0; i < mod->blocks; i++) {\n\t\tstruct catpt_fw_block_hdr *blk;\n\t\tint ret;\n\n\t\tblk = (struct catpt_fw_block_hdr *)((u8 *)mod + offset);\n\n\t\tret = catpt_load_block(cdev, chan, paddr + offset, blk, true);\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"load block failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (blk->ram_type == CATPT_RAM_TYPE_INSTANCE) {\n\t\t\ttype->state_offset = blk->ram_offset;\n\t\t\ttype->state_size = blk->size;\n\t\t}\n\n\t\toffset += sizeof(*blk) + blk->size;\n\t}\n\n\t \n\ttype->loaded = true;\n\t \n\ttype->entry_point = mod->entry_point - 4;\n\ttype->persistent_size = mod->persistent_size;\n\ttype->scratch_size = mod->scratch_size;\n\n\treturn 0;\n}\n\nstatic int catpt_restore_firmware(struct catpt_dev *cdev,\n\t\t\t\t  struct dma_chan *chan, dma_addr_t paddr,\n\t\t\t\t  struct catpt_fw_hdr *fw)\n{\n\tu32 offset = sizeof(*fw);\n\tint i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     fw, sizeof(*fw), false);\n\n\tfor (i = 0; i < fw->modules; i++) {\n\t\tstruct catpt_fw_mod_hdr *mod;\n\t\tint ret;\n\n\t\tmod = (struct catpt_fw_mod_hdr *)((u8 *)fw + offset);\n\t\tif (strncmp(fw->signature, mod->signature,\n\t\t\t    FW_SIGNATURE_SIZE)) {\n\t\t\tdev_err(cdev->dev, \"module signature mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mod->module_id > CATPT_MODID_LAST)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (mod->module_id) {\n\t\tcase CATPT_MODID_BASE_FW:\n\t\t\tret = catpt_restore_basefw(cdev, chan, paddr + offset,\n\t\t\t\t\t\t   mod);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = catpt_restore_module(cdev, chan, paddr + offset,\n\t\t\t\t\t\t   mod);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"restore module failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += sizeof(*mod) + mod->mod_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_load_firmware(struct catpt_dev *cdev,\n\t\t\t       struct dma_chan *chan, dma_addr_t paddr,\n\t\t\t       struct catpt_fw_hdr *fw)\n{\n\tu32 offset = sizeof(*fw);\n\tint i;\n\n\tprint_hex_dump_debug(__func__, DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t     fw, sizeof(*fw), false);\n\n\tfor (i = 0; i < fw->modules; i++) {\n\t\tstruct catpt_fw_mod_hdr *mod;\n\t\tint ret;\n\n\t\tmod = (struct catpt_fw_mod_hdr *)((u8 *)fw + offset);\n\t\tif (strncmp(fw->signature, mod->signature,\n\t\t\t    FW_SIGNATURE_SIZE)) {\n\t\t\tdev_err(cdev->dev, \"module signature mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mod->module_id > CATPT_MODID_LAST)\n\t\t\treturn -EINVAL;\n\n\t\tret = catpt_load_module(cdev, chan, paddr + offset, mod);\n\t\tif (ret) {\n\t\t\tdev_err(cdev->dev, \"load module failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += sizeof(*mod) + mod->mod_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int catpt_load_image(struct catpt_dev *cdev, struct dma_chan *chan,\n\t\t\t    const char *name, const char *signature,\n\t\t\t    bool restore)\n{\n\tstruct catpt_fw_hdr *fw;\n\tstruct firmware *img;\n\tdma_addr_t paddr;\n\tvoid *vaddr;\n\tint ret;\n\n\tret = request_firmware((const struct firmware **)&img, name, cdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfw = (struct catpt_fw_hdr *)img->data;\n\tif (strncmp(fw->signature, signature, FW_SIGNATURE_SIZE)) {\n\t\tdev_err(cdev->dev, \"firmware signature mismatch\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\tvaddr = dma_alloc_coherent(cdev->dev, img->size, &paddr, GFP_KERNEL);\n\tif (!vaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto release_fw;\n\t}\n\n\tmemcpy(vaddr, img->data, img->size);\n\tfw = (struct catpt_fw_hdr *)vaddr;\n\tif (restore)\n\t\tret = catpt_restore_firmware(cdev, chan, paddr, fw);\n\telse\n\t\tret = catpt_load_firmware(cdev, chan, paddr, fw);\n\n\tdma_free_coherent(cdev->dev, img->size, vaddr, paddr);\nrelease_fw:\n\trelease_firmware(img);\n\treturn ret;\n}\n\nstatic int catpt_load_images(struct catpt_dev *cdev, bool restore)\n{\n\tstatic const char *const names[] = {\n\t\t\"intel/IntcSST1.bin\",\n\t\t\"intel/IntcSST2.bin\",\n\t};\n\tstruct dma_chan *chan;\n\tint ret;\n\n\tchan = catpt_dma_request_config_chan(cdev);\n\tif (IS_ERR(chan))\n\t\treturn PTR_ERR(chan);\n\n\tret = catpt_load_image(cdev, chan, names[cdev->spec->core_id - 1],\n\t\t\t       FW_SIGNATURE, restore);\n\tif (ret)\n\t\tgoto release_dma_chan;\n\n\tif (!restore)\n\t\tgoto release_dma_chan;\n\tret = catpt_restore_streams_context(cdev, chan);\n\tif (ret)\n\t\tdev_err(cdev->dev, \"restore streams ctx failed: %d\\n\", ret);\nrelease_dma_chan:\n\tdma_release_channel(chan);\n\treturn ret;\n}\n\nint catpt_boot_firmware(struct catpt_dev *cdev, bool restore)\n{\n\tint ret;\n\n\tcatpt_dsp_stall(cdev, true);\n\n\tret = catpt_load_images(cdev, restore);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"load binaries failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treinit_completion(&cdev->fw_ready);\n\tcatpt_dsp_stall(cdev, false);\n\n\tret = wait_for_completion_timeout(&cdev->fw_ready,\n\t\t\tmsecs_to_jiffies(FW_READY_TIMEOUT_MS));\n\tif (!ret) {\n\t\tdev_err(cdev->dev, \"firmware ready timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tcatpt_dsp_update_srampge(cdev, &cdev->dram, cdev->spec->dram_mask);\n\tcatpt_dsp_update_srampge(cdev, &cdev->iram, cdev->spec->iram_mask);\n\n\treturn catpt_dsp_update_lpclock(cdev);\n}\n\nint catpt_first_boot_firmware(struct catpt_dev *cdev)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tret = catpt_boot_firmware(cdev, false);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"basefw boot failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\t__request_region(&cdev->dram, 0, 0x200, NULL, 0);\n\t \n\tfor (res = cdev->dram.child; res->sibling; res = res->sibling)\n\t\t;\n\t__request_region(&cdev->dram, res->end + 1,\n\t\t\t cdev->dram.end - res->end, NULL, 0);\n\n\tret = catpt_ipc_get_mixer_stream_info(cdev, &cdev->mixer);\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\tret = catpt_arm_stream_templates(cdev);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"arm templates failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcatpt_dsp_update_srampge(cdev, &cdev->dram, cdev->spec->dram_mask);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}