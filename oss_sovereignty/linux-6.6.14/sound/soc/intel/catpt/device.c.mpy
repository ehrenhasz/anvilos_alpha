{
  "module_name": "device.c",
  "hash_id": "bd339ed0100df7b17a26f51f668103c4b9a392bc23dc8000d1758b4f92be237d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/catpt/device.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <sound/intel-dsp-config.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"core.h\"\n#include \"registers.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nstatic int __maybe_unused catpt_suspend(struct device *dev)\n{\n\tstruct catpt_dev *cdev = dev_get_drvdata(dev);\n\tstruct dma_chan *chan;\n\tint ret;\n\n\tchan = catpt_dma_request_config_chan(cdev);\n\tif (IS_ERR(chan))\n\t\treturn PTR_ERR(chan);\n\n\tmemset(&cdev->dx_ctx, 0, sizeof(cdev->dx_ctx));\n\tret = catpt_ipc_enter_dxstate(cdev, CATPT_DX_STATE_D3, &cdev->dx_ctx);\n\tif (ret) {\n\t\tret = CATPT_IPC_ERROR(ret);\n\t\tgoto release_dma_chan;\n\t}\n\n\tret = catpt_dsp_stall(cdev, true);\n\tif (ret)\n\t\tgoto release_dma_chan;\n\n\tret = catpt_store_memdumps(cdev, chan);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"store memdumps failed: %d\\n\", ret);\n\t\tgoto release_dma_chan;\n\t}\n\n\tret = catpt_store_module_states(cdev, chan);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"store module states failed: %d\\n\", ret);\n\t\tgoto release_dma_chan;\n\t}\n\n\tret = catpt_store_streams_context(cdev, chan);\n\tif (ret)\n\t\tdev_err(cdev->dev, \"store streams ctx failed: %d\\n\", ret);\n\nrelease_dma_chan:\n\tdma_release_channel(chan);\n\tif (ret)\n\t\treturn ret;\n\treturn catpt_dsp_power_down(cdev);\n}\n\nstatic int __maybe_unused catpt_resume(struct device *dev)\n{\n\tstruct catpt_dev *cdev = dev_get_drvdata(dev);\n\tint ret, i;\n\n\tret = catpt_dsp_power_up(cdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!try_module_get(dev->driver->owner)) {\n\t\tdev_info(dev, \"module unloading, skipping fw boot\\n\");\n\t\treturn 0;\n\t}\n\tmodule_put(dev->driver->owner);\n\n\tret = catpt_boot_firmware(cdev, true);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"boot firmware failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < CATPT_SSP_COUNT; i++) {\n\t\tif (cdev->devfmt[i].iface == UINT_MAX)\n\t\t\tcontinue;\n\n\t\tret = catpt_ipc_set_device_format(cdev, &cdev->devfmt[i]);\n\t\tif (ret)\n\t\t\treturn CATPT_IPC_ERROR(ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused catpt_runtime_suspend(struct device *dev)\n{\n\tif (!try_module_get(dev->driver->owner)) {\n\t\tdev_info(dev, \"module unloading, skipping suspend\\n\");\n\t\treturn 0;\n\t}\n\tmodule_put(dev->driver->owner);\n\n\treturn catpt_suspend(dev);\n}\n\nstatic int __maybe_unused catpt_runtime_resume(struct device *dev)\n{\n\treturn catpt_resume(dev);\n}\n\nstatic const struct dev_pm_ops catpt_dev_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(catpt_suspend, catpt_resume)\n\tSET_RUNTIME_PM_OPS(catpt_runtime_suspend, catpt_runtime_resume, NULL)\n};\n\n \nstatic void board_pdev_unregister(void *data)\n{\n\tplatform_device_unregister(data);\n}\n\nstatic int catpt_register_board(struct catpt_dev *cdev)\n{\n\tconst struct catpt_spec *spec = cdev->spec;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct platform_device *board;\n\n\tmach = snd_soc_acpi_find_machine(spec->machines);\n\tif (!mach) {\n\t\tdev_info(cdev->dev, \"no machines present\\n\");\n\t\treturn 0;\n\t}\n\n\tmach->mach_params.platform = \"catpt-platform\";\n\tboard = platform_device_register_data(NULL, mach->drv_name,\n\t\t\t\t\tPLATFORM_DEVID_NONE,\n\t\t\t\t\t(const void *)mach, sizeof(*mach));\n\tif (IS_ERR(board)) {\n\t\tdev_err(cdev->dev, \"board register failed\\n\");\n\t\treturn PTR_ERR(board);\n\t}\n\n\treturn devm_add_action_or_reset(cdev->dev, board_pdev_unregister,\n\t\t\t\t\tboard);\n}\n\nstatic int catpt_probe_components(struct catpt_dev *cdev)\n{\n\tint ret;\n\n\tret = catpt_dsp_power_up(cdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = catpt_dmac_probe(cdev);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"DMAC probe failed: %d\\n\", ret);\n\t\tgoto err_dmac_probe;\n\t}\n\n\tret = catpt_first_boot_firmware(cdev);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"first fw boot failed: %d\\n\", ret);\n\t\tgoto err_boot_fw;\n\t}\n\n\tret = catpt_register_plat_component(cdev);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"register plat comp failed: %d\\n\", ret);\n\t\tgoto err_boot_fw;\n\t}\n\n\tret = catpt_register_board(cdev);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"register board failed: %d\\n\", ret);\n\t\tgoto err_reg_board;\n\t}\n\n\t \n\tpm_runtime_set_active(cdev->dev);\n\n\tpm_runtime_set_autosuspend_delay(cdev->dev, 2000);\n\tpm_runtime_use_autosuspend(cdev->dev);\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_enable(cdev->dev);\n\treturn 0;\n\nerr_reg_board:\n\tsnd_soc_unregister_component(cdev->dev);\nerr_boot_fw:\n\tcatpt_dmac_remove(cdev);\nerr_dmac_probe:\n\tcatpt_dsp_power_down(cdev);\n\n\treturn ret;\n}\n\nstatic void catpt_dev_init(struct catpt_dev *cdev, struct device *dev,\n\t\t\t   const struct catpt_spec *spec)\n{\n\tcdev->dev = dev;\n\tcdev->spec = spec;\n\tinit_completion(&cdev->fw_ready);\n\tINIT_LIST_HEAD(&cdev->stream_list);\n\tspin_lock_init(&cdev->list_lock);\n\tmutex_init(&cdev->clk_mutex);\n\n\t \n\tcdev->devfmt[CATPT_SSP_IFACE_0].iface = UINT_MAX;\n\tcdev->devfmt[CATPT_SSP_IFACE_1].iface = UINT_MAX;\n\n\tcatpt_ipc_init(&cdev->ipc, dev);\n\n\tcatpt_sram_init(&cdev->dram, spec->host_dram_offset,\n\t\t\tcatpt_dram_size(cdev));\n\tcatpt_sram_init(&cdev->iram, spec->host_iram_offset,\n\t\t\tcatpt_iram_size(cdev));\n}\n\nstatic int catpt_acpi_probe(struct platform_device *pdev)\n{\n\tconst struct catpt_spec *spec;\n\tstruct catpt_dev *cdev;\n\tstruct device *dev = &pdev->dev;\n\tconst struct acpi_device_id *id;\n\tstruct resource *res;\n\tint ret;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = snd_intel_acpi_dsp_driver_probe(dev, id->id);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_SST) {\n\t\tdev_dbg(dev, \"CATPT ACPI driver not selected, aborting probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tspec = (const struct catpt_spec *)id->driver_data;\n\tcatpt_dev_init(cdev, dev, spec);\n\n\t \n\tcdev->lpe_ba = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(cdev->lpe_ba))\n\t\treturn PTR_ERR(cdev->lpe_ba);\n\tcdev->lpe_base = res->start;\n\n\t \n\tcdev->pci_ba = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(cdev->pci_ba))\n\t\treturn PTR_ERR(cdev->pci_ba);\n\n\t \n\tcdev->dxbuf_vaddr = dmam_alloc_coherent(dev, catpt_dram_size(cdev),\n\t\t\t\t\t\t&cdev->dxbuf_paddr, GFP_KERNEL);\n\tif (!cdev->dxbuf_vaddr)\n\t\treturn -ENOMEM;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tcdev->irq = ret;\n\n\tplatform_set_drvdata(pdev, cdev);\n\n\tret = devm_request_threaded_irq(dev, cdev->irq, catpt_dsp_irq_handler,\n\t\t\t\t\tcatpt_dsp_irq_thread,\n\t\t\t\t\tIRQF_SHARED, \"AudioDSP\", cdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn catpt_probe_components(cdev);\n}\n\nstatic void catpt_acpi_remove(struct platform_device *pdev)\n{\n\tstruct catpt_dev *cdev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(cdev->dev);\n\n\tsnd_soc_unregister_component(cdev->dev);\n\tcatpt_dmac_remove(cdev);\n\tcatpt_dsp_power_down(cdev);\n\n\tcatpt_sram_free(&cdev->iram);\n\tcatpt_sram_free(&cdev->dram);\n}\n\nstatic struct snd_soc_acpi_mach lpt_machines[] = {\n\t{\n\t\t.id = \"INT33CA\",\n\t\t.drv_name = \"hsw_rt5640\",\n\t},\n\t{}\n};\n\nstatic struct snd_soc_acpi_mach wpt_machines[] = {\n\t{\n\t\t.id = \"INT33CA\",\n\t\t.drv_name = \"hsw_rt5640\",\n\t},\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"bdw_rt286\",\n\t},\n\t{\n\t\t.id = \"10EC5650\",\n\t\t.drv_name = \"bdw-rt5650\",\n\t},\n\t{\n\t\t.id = \"RT5677CE\",\n\t\t.drv_name = \"bdw-rt5677\",\n\t},\n\t{}\n};\n\nstatic struct catpt_spec lpt_desc = {\n\t.machines = lpt_machines,\n\t.core_id = 0x01,\n\t.host_dram_offset = 0x000000,\n\t.host_iram_offset = 0x080000,\n\t.host_shim_offset = 0x0E7000,\n\t.host_dma_offset = { 0x0F0000, 0x0F8000 },\n\t.host_ssp_offset = { 0x0E8000, 0x0E9000 },\n\t.dram_mask = LPT_VDRTCTL0_DSRAMPGE_MASK,\n\t.iram_mask = LPT_VDRTCTL0_ISRAMPGE_MASK,\n\t.d3srampgd_bit = LPT_VDRTCTL0_D3SRAMPGD,\n\t.d3pgd_bit = LPT_VDRTCTL0_D3PGD,\n\t.pll_shutdown = lpt_dsp_pll_shutdown,\n};\n\nstatic struct catpt_spec wpt_desc = {\n\t.machines = wpt_machines,\n\t.core_id = 0x02,\n\t.host_dram_offset = 0x000000,\n\t.host_iram_offset = 0x0A0000,\n\t.host_shim_offset = 0x0FB000,\n\t.host_dma_offset = { 0x0FE000, 0x0FF000 },\n\t.host_ssp_offset = { 0x0FC000, 0x0FD000 },\n\t.dram_mask = WPT_VDRTCTL0_DSRAMPGE_MASK,\n\t.iram_mask = WPT_VDRTCTL0_ISRAMPGE_MASK,\n\t.d3srampgd_bit = WPT_VDRTCTL0_D3SRAMPGD,\n\t.d3pgd_bit = WPT_VDRTCTL0_D3PGD,\n\t.pll_shutdown = wpt_dsp_pll_shutdown,\n};\n\nstatic const struct acpi_device_id catpt_ids[] = {\n\t{ \"INT33C8\", (unsigned long)&lpt_desc },\n\t{ \"INT3438\", (unsigned long)&wpt_desc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, catpt_ids);\n\nstatic struct platform_driver catpt_acpi_driver = {\n\t.probe = catpt_acpi_probe,\n\t.remove_new = catpt_acpi_remove,\n\t.driver = {\n\t\t.name = \"intel_catpt\",\n\t\t.acpi_match_table = catpt_ids,\n\t\t.pm = &catpt_dev_pm,\n\t\t.dev_groups = catpt_attr_groups,\n\t},\n};\nmodule_platform_driver(catpt_acpi_driver);\n\nMODULE_AUTHOR(\"Cezary Rojewski <cezary.rojewski@intel.com>\");\nMODULE_DESCRIPTION(\"Intel LPT/WPT AudioDSP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}