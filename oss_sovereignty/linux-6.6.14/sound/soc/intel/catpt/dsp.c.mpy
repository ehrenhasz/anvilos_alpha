{
  "module_name": "dsp.c",
  "hash_id": "9ee4d4bf2522c03107962f7b8aa3277362a2e92faeb17943090c8cb5345dc809",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/catpt/dsp.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/devcoredump.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/pxa2xx_ssp.h>\n#include \"core.h\"\n#include \"messages.h\"\n#include \"registers.h\"\n\nstatic bool catpt_dma_filter(struct dma_chan *chan, void *param)\n{\n\treturn param == chan->device->dev;\n}\n\n \n#define CATPT_DMA_DEVID\t\t1\n#define CATPT_DMA_DSP_ADDR_MASK\tGENMASK(31, 20)\n\nstruct dma_chan *catpt_dma_request_config_chan(struct catpt_dev *cdev)\n{\n\tstruct dma_slave_config config;\n\tstruct dma_chan *chan;\n\tdma_cap_mask_t mask;\n\tint ret;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tchan = dma_request_channel(mask, catpt_dma_filter, cdev->dev);\n\tif (!chan) {\n\t\tdev_err(cdev->dev, \"request channel failed\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.direction = DMA_MEM_TO_DEV;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.src_maxburst = 16;\n\tconfig.dst_maxburst = 16;\n\n\tret = dmaengine_slave_config(chan, &config);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"slave config failed: %d\\n\", ret);\n\t\tdma_release_channel(chan);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn chan;\n}\n\nstatic int catpt_dma_memcpy(struct catpt_dev *cdev, struct dma_chan *chan,\n\t\t\t    dma_addr_t dst_addr, dma_addr_t src_addr,\n\t\t\t    size_t size)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tenum dma_status status;\n\tint ret;\n\n\tdesc = dmaengine_prep_dma_memcpy(chan, dst_addr, src_addr, size,\n\t\t\t\t\t DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(cdev->dev, \"prep dma memcpy failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tcatpt_updatel_shim(cdev, HMDC,\n\t\t\t   CATPT_HMDC_HDDA(CATPT_DMA_DEVID, chan->chan_id),\n\t\t\t   CATPT_HMDC_HDDA(CATPT_DMA_DEVID, chan->chan_id));\n\n\tret = dma_submit_error(dmaengine_submit(desc));\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"submit tx failed: %d\\n\", ret);\n\t\tgoto clear_hdda;\n\t}\n\n\tstatus = dma_wait_for_async_tx(desc);\n\tret = (status == DMA_COMPLETE) ? 0 : -EPROTO;\n\nclear_hdda:\n\t \n\tcatpt_updatel_shim(cdev, HMDC,\n\t\t\t   CATPT_HMDC_HDDA(CATPT_DMA_DEVID, chan->chan_id), 0);\n\n\treturn ret;\n}\n\nint catpt_dma_memcpy_todsp(struct catpt_dev *cdev, struct dma_chan *chan,\n\t\t\t   dma_addr_t dst_addr, dma_addr_t src_addr,\n\t\t\t   size_t size)\n{\n\treturn catpt_dma_memcpy(cdev, chan, dst_addr | CATPT_DMA_DSP_ADDR_MASK,\n\t\t\t\tsrc_addr, size);\n}\n\nint catpt_dma_memcpy_fromdsp(struct catpt_dev *cdev, struct dma_chan *chan,\n\t\t\t     dma_addr_t dst_addr, dma_addr_t src_addr,\n\t\t\t     size_t size)\n{\n\treturn catpt_dma_memcpy(cdev, chan, dst_addr,\n\t\t\t\tsrc_addr | CATPT_DMA_DSP_ADDR_MASK, size);\n}\n\nint catpt_dmac_probe(struct catpt_dev *cdev)\n{\n\tstruct dw_dma_chip *dmac;\n\tint ret;\n\n\tdmac = devm_kzalloc(cdev->dev, sizeof(*dmac), GFP_KERNEL);\n\tif (!dmac)\n\t\treturn -ENOMEM;\n\n\tdmac->regs = cdev->lpe_ba + cdev->spec->host_dma_offset[CATPT_DMA_DEVID];\n\tdmac->dev = cdev->dev;\n\tdmac->irq = cdev->irq;\n\n\tret = dma_coerce_mask_and_coherent(cdev->dev, DMA_BIT_MASK(31));\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = dw_dma_probe(dmac);\n\tif (ret)\n\t\treturn ret;\n\n\tcdev->dmac = dmac;\n\treturn 0;\n}\n\nvoid catpt_dmac_remove(struct catpt_dev *cdev)\n{\n\t \n\tdw_dma_remove(cdev->dmac);\n}\n\nstatic void catpt_dsp_set_srampge(struct catpt_dev *cdev, struct resource *sram,\n\t\t\t\t  unsigned long mask, unsigned long new)\n{\n\tunsigned long old;\n\tu32 off = sram->start;\n\tu32 b = __ffs(mask);\n\n\told = catpt_readl_pci(cdev, VDRTCTL0) & mask;\n\tdev_dbg(cdev->dev, \"SRAMPGE [0x%08lx] 0x%08lx -> 0x%08lx\",\n\t\tmask, old, new);\n\n\tif (old == new)\n\t\treturn;\n\n\tcatpt_updatel_pci(cdev, VDRTCTL0, mask, new);\n\t \n\tudelay(60);\n\n\t \n\tfor_each_clear_bit_from(b, &new, fls_long(mask)) {\n\t\tu8 buf[4];\n\n\t\t \n\t\tif (test_bit(b, &old)) {\n\t\t\tdev_dbg(cdev->dev, \"sanitize block %ld: off 0x%08x\\n\",\n\t\t\t\tb - __ffs(mask), off);\n\t\t\tmemcpy_fromio(buf, cdev->lpe_ba + off, sizeof(buf));\n\t\t}\n\t\toff += CATPT_MEMBLOCK_SIZE;\n\t}\n}\n\nvoid catpt_dsp_update_srampge(struct catpt_dev *cdev, struct resource *sram,\n\t\t\t      unsigned long mask)\n{\n\tstruct resource *res;\n\tunsigned long new = 0;\n\n\t \n\tfor (res = sram->child; res; res = res->sibling) {\n\t\tu32 h, l;\n\n\t\th = (res->end - sram->start) / CATPT_MEMBLOCK_SIZE;\n\t\tl = (res->start - sram->start) / CATPT_MEMBLOCK_SIZE;\n\t\tnew |= GENMASK(h, l);\n\t}\n\n\t \n\tnew = ~(new << __ffs(mask)) & mask;\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE, 0);\n\n\tcatpt_dsp_set_srampge(cdev, sram, mask, new);\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE,\n\t\t\t  CATPT_VDRTCTL2_DCLCGE);\n}\n\nint catpt_dsp_stall(struct catpt_dev *cdev, bool stall)\n{\n\tu32 reg, val;\n\n\tval = stall ? CATPT_CS_STALL : 0;\n\tcatpt_updatel_shim(cdev, CS1, CATPT_CS_STALL, val);\n\n\treturn catpt_readl_poll_shim(cdev, CS1,\n\t\t\t\t     reg, (reg & CATPT_CS_STALL) == val,\n\t\t\t\t     500, 10000);\n}\n\nstatic int catpt_dsp_reset(struct catpt_dev *cdev, bool reset)\n{\n\tu32 reg, val;\n\n\tval = reset ? CATPT_CS_RST : 0;\n\tcatpt_updatel_shim(cdev, CS1, CATPT_CS_RST, val);\n\n\treturn catpt_readl_poll_shim(cdev, CS1,\n\t\t\t\t     reg, (reg & CATPT_CS_RST) == val,\n\t\t\t\t     500, 10000);\n}\n\nvoid lpt_dsp_pll_shutdown(struct catpt_dev *cdev, bool enable)\n{\n\tu32 val;\n\n\tval = enable ? LPT_VDRTCTL0_APLLSE : 0;\n\tcatpt_updatel_pci(cdev, VDRTCTL0, LPT_VDRTCTL0_APLLSE, val);\n}\n\nvoid wpt_dsp_pll_shutdown(struct catpt_dev *cdev, bool enable)\n{\n\tu32 val;\n\n\tval = enable ? WPT_VDRTCTL2_APLLSE : 0;\n\tcatpt_updatel_pci(cdev, VDRTCTL2, WPT_VDRTCTL2_APLLSE, val);\n}\n\nstatic int catpt_dsp_select_lpclock(struct catpt_dev *cdev, bool lp, bool waiti)\n{\n\tu32 mask, reg, val;\n\tint ret;\n\n\tmutex_lock(&cdev->clk_mutex);\n\n\tval = lp ? CATPT_CS_LPCS : 0;\n\treg = catpt_readl_shim(cdev, CS1) & CATPT_CS_LPCS;\n\tdev_dbg(cdev->dev, \"LPCS [0x%08lx] 0x%08x -> 0x%08x\",\n\t\tCATPT_CS_LPCS, reg, val);\n\n\tif (reg == val) {\n\t\tmutex_unlock(&cdev->clk_mutex);\n\t\treturn 0;\n\t}\n\n\tif (waiti) {\n\t\t \n\t\tret = catpt_readl_poll_shim(cdev, ISD,\n\t\t\t\t\t    reg, (reg & CATPT_ISD_DCPWM),\n\t\t\t\t\t    500, 10000);\n\t\tif (ret) {\n\t\t\tdev_warn(cdev->dev, \"await WAITI timeout\\n\");\n\t\t\t \n\t\t\tif (lp) {\n\t\t\t\tmutex_unlock(&cdev->clk_mutex);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = catpt_readl_poll_shim(cdev, CLKCTL,\n\t\t\t\t    reg, !(reg & CATPT_CLKCTL_CFCIP),\n\t\t\t\t    500, 10000);\n\tif (ret)\n\t\tdev_warn(cdev->dev, \"clock change still in progress\\n\");\n\n\t \n\tval |= CATPT_CS_DCS_HIGH;\n\tmask = CATPT_CS_LPCS | CATPT_CS_DCS;\n\tcatpt_updatel_shim(cdev, CS1, mask, val);\n\n\tret = catpt_readl_poll_shim(cdev, CLKCTL,\n\t\t\t\t    reg, !(reg & CATPT_CLKCTL_CFCIP),\n\t\t\t\t    500, 10000);\n\tif (ret)\n\t\tdev_warn(cdev->dev, \"clock change still in progress\\n\");\n\n\t \n\tcdev->spec->pll_shutdown(cdev, lp);\n\n\tmutex_unlock(&cdev->clk_mutex);\n\treturn 0;\n}\n\nint catpt_dsp_update_lpclock(struct catpt_dev *cdev)\n{\n\tstruct catpt_stream_runtime *stream;\n\n\tlist_for_each_entry(stream, &cdev->stream_list, node)\n\t\tif (stream->prepared)\n\t\t\treturn catpt_dsp_select_lpclock(cdev, false, true);\n\n\treturn catpt_dsp_select_lpclock(cdev, true, true);\n}\n\n \nstatic void catpt_dsp_set_regs_defaults(struct catpt_dev *cdev)\n{\n\tint i;\n\n\tcatpt_writel_shim(cdev, CS1, CATPT_CS_DEFAULT);\n\tcatpt_writel_shim(cdev, ISC, CATPT_ISC_DEFAULT);\n\tcatpt_writel_shim(cdev, ISD, CATPT_ISD_DEFAULT);\n\tcatpt_writel_shim(cdev, IMC, CATPT_IMC_DEFAULT);\n\tcatpt_writel_shim(cdev, IMD, CATPT_IMD_DEFAULT);\n\tcatpt_writel_shim(cdev, IPCC, CATPT_IPCC_DEFAULT);\n\tcatpt_writel_shim(cdev, IPCD, CATPT_IPCD_DEFAULT);\n\tcatpt_writel_shim(cdev, CLKCTL, CATPT_CLKCTL_DEFAULT);\n\tcatpt_writel_shim(cdev, CS2, CATPT_CS2_DEFAULT);\n\tcatpt_writel_shim(cdev, LTRC, CATPT_LTRC_DEFAULT);\n\tcatpt_writel_shim(cdev, HMDC, CATPT_HMDC_DEFAULT);\n\n\tfor (i = 0; i < CATPT_SSP_COUNT; i++) {\n\t\tcatpt_writel_ssp(cdev, i, SSCR0, CATPT_SSC0_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSCR1, CATPT_SSC1_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSSR, CATPT_SSS_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSITR, CATPT_SSIT_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSDR, CATPT_SSD_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSTO, CATPT_SSTO_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSPSP, CATPT_SSPSP_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSTSA, CATPT_SSTSA_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSRSA, CATPT_SSRSA_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSTSS, CATPT_SSTSS_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSCR2, CATPT_SSCR2_DEFAULT);\n\t\tcatpt_writel_ssp(cdev, i, SSPSP2, CATPT_SSPSP2_DEFAULT);\n\t}\n}\n\nint catpt_dsp_power_down(struct catpt_dev *cdev)\n{\n\tu32 mask, val;\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE, 0);\n\n\tcatpt_dsp_reset(cdev, true);\n\t \n\tcatpt_updatel_shim(cdev, CS1, CATPT_CS_SBCS(0) | CATPT_CS_SBCS(1),\n\t\t\t   CATPT_CS_SBCS(0) | CATPT_CS_SBCS(1));\n\tcatpt_dsp_select_lpclock(cdev, true, false);\n\t \n\tcatpt_updatel_shim(cdev, CLKCTL, CATPT_CLKCTL_SMOS, 0);\n\n\tcatpt_dsp_set_regs_defaults(cdev);\n\n\t \n\tmask = CATPT_VDRTCTL2_CGEALL & (~CATPT_VDRTCTL2_DCLCGE);\n\tval = mask & (~CATPT_VDRTCTL2_DTCGE);\n\tcatpt_updatel_pci(cdev, VDRTCTL2, mask, val);\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DTCGE,\n\t\t\t  CATPT_VDRTCTL2_DTCGE);\n\n\t \n\tcatpt_dsp_set_srampge(cdev, &cdev->dram, cdev->spec->dram_mask,\n\t\t\t      cdev->spec->dram_mask);\n\tcatpt_dsp_set_srampge(cdev, &cdev->iram, cdev->spec->iram_mask,\n\t\t\t      cdev->spec->iram_mask);\n\tmask = cdev->spec->d3srampgd_bit | cdev->spec->d3pgd_bit;\n\tcatpt_updatel_pci(cdev, VDRTCTL0, mask, cdev->spec->d3pgd_bit);\n\n\tcatpt_updatel_pci(cdev, PMCS, PCI_PM_CTRL_STATE_MASK, PCI_D3hot);\n\t \n\tudelay(50);\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE,\n\t\t\t  CATPT_VDRTCTL2_DCLCGE);\n\tudelay(50);\n\n\treturn 0;\n}\n\nint catpt_dsp_power_up(struct catpt_dev *cdev)\n{\n\tu32 mask, val;\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE, 0);\n\n\t \n\tmask = CATPT_VDRTCTL2_CGEALL & (~CATPT_VDRTCTL2_DCLCGE);\n\tval = mask & (~CATPT_VDRTCTL2_DTCGE);\n\tcatpt_updatel_pci(cdev, VDRTCTL2, mask, val);\n\n\tcatpt_updatel_pci(cdev, PMCS, PCI_PM_CTRL_STATE_MASK, PCI_D0);\n\n\t \n\tmask = cdev->spec->d3srampgd_bit | cdev->spec->d3pgd_bit;\n\tcatpt_updatel_pci(cdev, VDRTCTL0, mask, mask);\n\tcatpt_dsp_set_srampge(cdev, &cdev->dram, cdev->spec->dram_mask, 0);\n\tcatpt_dsp_set_srampge(cdev, &cdev->iram, cdev->spec->iram_mask, 0);\n\n\tcatpt_dsp_set_regs_defaults(cdev);\n\n\t \n\tcatpt_updatel_shim(cdev, CLKCTL, CATPT_CLKCTL_SMOS, CATPT_CLKCTL_SMOS);\n\tcatpt_dsp_select_lpclock(cdev, false, false);\n\t \n\tcatpt_updatel_shim(cdev, CS1, CATPT_CS_SBCS(0) | CATPT_CS_SBCS(1),\n\t\t\t   CATPT_CS_SBCS(0) | CATPT_CS_SBCS(1));\n\tcatpt_dsp_reset(cdev, false);\n\n\t \n\tcatpt_updatel_pci(cdev, VDRTCTL2, CATPT_VDRTCTL2_DCLCGE,\n\t\t\t  CATPT_VDRTCTL2_DCLCGE);\n\n\t \n\tcatpt_updatel_shim(cdev, IMC, CATPT_IMC_IPCDB | CATPT_IMC_IPCCD, 0);\n\n\treturn 0;\n}\n\n#define CATPT_DUMP_MAGIC\t\t0xcd42\n#define CATPT_DUMP_SECTION_ID_FILE\t0x00\n#define CATPT_DUMP_SECTION_ID_IRAM\t0x01\n#define CATPT_DUMP_SECTION_ID_DRAM\t0x02\n#define CATPT_DUMP_SECTION_ID_REGS\t0x03\n#define CATPT_DUMP_HASH_SIZE\t\t20\n\nstruct catpt_dump_section_hdr {\n\tu16 magic;\n\tu8 core_id;\n\tu8 section_id;\n\tu32 size;\n};\n\nint catpt_coredump(struct catpt_dev *cdev)\n{\n\tstruct catpt_dump_section_hdr *hdr;\n\tsize_t dump_size, regs_size;\n\tu8 *dump, *pos;\n\tconst char *eof;\n\tchar *info;\n\tint i;\n\n\tregs_size = CATPT_SHIM_REGS_SIZE;\n\tregs_size += CATPT_DMA_COUNT * CATPT_DMA_REGS_SIZE;\n\tregs_size += CATPT_SSP_COUNT * CATPT_SSP_REGS_SIZE;\n\tdump_size = resource_size(&cdev->dram);\n\tdump_size += resource_size(&cdev->iram);\n\tdump_size += regs_size;\n\t \n\tdump_size += 4 * sizeof(*hdr) + CATPT_DUMP_HASH_SIZE;\n\n\tdump = vzalloc(dump_size);\n\tif (!dump)\n\t\treturn -ENOMEM;\n\n\tpos = dump;\n\n\thdr = (struct catpt_dump_section_hdr *)pos;\n\thdr->magic = CATPT_DUMP_MAGIC;\n\thdr->core_id = cdev->spec->core_id;\n\thdr->section_id = CATPT_DUMP_SECTION_ID_FILE;\n\thdr->size = dump_size - sizeof(*hdr);\n\tpos += sizeof(*hdr);\n\n\tinfo = cdev->ipc.config.fw_info;\n\teof = info + FW_INFO_SIZE_MAX;\n\t \n\tfor (i = 0; i < 4 && info < eof; i++, info++) {\n\t\t \n\t\tinfo = strnchr(info, eof - info, ' ');\n\t\tif (!info)\n\t\t\tbreak;\n\t}\n\n\tif (i == 4 && info)\n\t\tmemcpy(pos, info, min_t(u32, eof - info, CATPT_DUMP_HASH_SIZE));\n\tpos += CATPT_DUMP_HASH_SIZE;\n\n\thdr = (struct catpt_dump_section_hdr *)pos;\n\thdr->magic = CATPT_DUMP_MAGIC;\n\thdr->core_id = cdev->spec->core_id;\n\thdr->section_id = CATPT_DUMP_SECTION_ID_IRAM;\n\thdr->size = resource_size(&cdev->iram);\n\tpos += sizeof(*hdr);\n\n\tmemcpy_fromio(pos, cdev->lpe_ba + cdev->iram.start, hdr->size);\n\tpos += hdr->size;\n\n\thdr = (struct catpt_dump_section_hdr *)pos;\n\thdr->magic = CATPT_DUMP_MAGIC;\n\thdr->core_id = cdev->spec->core_id;\n\thdr->section_id = CATPT_DUMP_SECTION_ID_DRAM;\n\thdr->size = resource_size(&cdev->dram);\n\tpos += sizeof(*hdr);\n\n\tmemcpy_fromio(pos, cdev->lpe_ba + cdev->dram.start, hdr->size);\n\tpos += hdr->size;\n\n\thdr = (struct catpt_dump_section_hdr *)pos;\n\thdr->magic = CATPT_DUMP_MAGIC;\n\thdr->core_id = cdev->spec->core_id;\n\thdr->section_id = CATPT_DUMP_SECTION_ID_REGS;\n\thdr->size = regs_size;\n\tpos += sizeof(*hdr);\n\n\tmemcpy_fromio(pos, catpt_shim_addr(cdev), CATPT_SHIM_REGS_SIZE);\n\tpos += CATPT_SHIM_REGS_SIZE;\n\n\tfor (i = 0; i < CATPT_SSP_COUNT; i++) {\n\t\tmemcpy_fromio(pos, catpt_ssp_addr(cdev, i),\n\t\t\t      CATPT_SSP_REGS_SIZE);\n\t\tpos += CATPT_SSP_REGS_SIZE;\n\t}\n\tfor (i = 0; i < CATPT_DMA_COUNT; i++) {\n\t\tmemcpy_fromio(pos, catpt_dma_addr(cdev, i),\n\t\t\t      CATPT_DMA_REGS_SIZE);\n\t\tpos += CATPT_DMA_REGS_SIZE;\n\t}\n\n\tdev_coredumpv(cdev->dev, dump, dump_size, GFP_KERNEL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}