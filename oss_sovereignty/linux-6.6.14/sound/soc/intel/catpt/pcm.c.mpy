{
  "module_name": "pcm.c",
  "hash_id": "cdc45ac11a1cb810fa9eb54c03d16884d472610f59566e8a4104a3a4b69bc4c1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/catpt/pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <uapi/sound/tlv.h>\n#include \"core.h\"\n#include \"messages.h\"\n\nstruct catpt_stream_template {\n\tenum catpt_path_id path_id;\n\tenum catpt_stream_type type;\n\tu32 persistent_size;\n\tu8 num_entries;\n\tstruct catpt_module_entry entries[];\n};\n\nstatic struct catpt_stream_template system_pb = {\n\t.path_id = CATPT_PATH_SSP0_OUT,\n\t.type = CATPT_STRM_TYPE_SYSTEM,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_PCM_SYSTEM, 0 }},\n};\n\nstatic struct catpt_stream_template system_cp = {\n\t.path_id = CATPT_PATH_SSP0_IN,\n\t.type = CATPT_STRM_TYPE_CAPTURE,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_PCM_CAPTURE, 0 }},\n};\n\nstatic struct catpt_stream_template offload_pb = {\n\t.path_id = CATPT_PATH_SSP0_OUT,\n\t.type = CATPT_STRM_TYPE_RENDER,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_PCM, 0 }},\n};\n\nstatic struct catpt_stream_template loopback_cp = {\n\t.path_id = CATPT_PATH_SSP0_OUT,\n\t.type = CATPT_STRM_TYPE_LOOPBACK,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_PCM_REFERENCE, 0 }},\n};\n\nstatic struct catpt_stream_template bluetooth_pb = {\n\t.path_id = CATPT_PATH_SSP1_OUT,\n\t.type = CATPT_STRM_TYPE_BLUETOOTH_RENDER,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_BLUETOOTH_RENDER, 0 }},\n};\n\nstatic struct catpt_stream_template bluetooth_cp = {\n\t.path_id = CATPT_PATH_SSP1_IN,\n\t.type = CATPT_STRM_TYPE_BLUETOOTH_CAPTURE,\n\t.num_entries = 1,\n\t.entries = {{ CATPT_MODID_BLUETOOTH_CAPTURE, 0 }},\n};\n\nstatic struct catpt_stream_template *catpt_topology[] = {\n\t[CATPT_STRM_TYPE_RENDER]\t\t= &offload_pb,\n\t[CATPT_STRM_TYPE_SYSTEM]\t\t= &system_pb,\n\t[CATPT_STRM_TYPE_CAPTURE]\t\t= &system_cp,\n\t[CATPT_STRM_TYPE_LOOPBACK]\t\t= &loopback_cp,\n\t[CATPT_STRM_TYPE_BLUETOOTH_RENDER]\t= &bluetooth_pb,\n\t[CATPT_STRM_TYPE_BLUETOOTH_CAPTURE]\t= &bluetooth_cp,\n};\n\nstatic struct catpt_stream_template *\ncatpt_get_stream_template(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtm = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtm, 0);\n\tenum catpt_stream_type type;\n\n\ttype = cpu_dai->driver->id;\n\n\t \n\tswitch (type) {\n\tcase CATPT_STRM_TYPE_SYSTEM:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\ttype = CATPT_STRM_TYPE_CAPTURE;\n\t\tbreak;\n\tcase CATPT_STRM_TYPE_BLUETOOTH_RENDER:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\ttype = CATPT_STRM_TYPE_BLUETOOTH_CAPTURE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn catpt_topology[type];\n}\n\nstruct catpt_stream_runtime *\ncatpt_stream_find(struct catpt_dev *cdev, u8 stream_hw_id)\n{\n\tstruct catpt_stream_runtime *pos, *result = NULL;\n\n\tspin_lock(&cdev->list_lock);\n\tlist_for_each_entry(pos, &cdev->stream_list, node) {\n\t\tif (pos->info.stream_hw_id == stream_hw_id) {\n\t\t\tresult = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&cdev->list_lock);\n\treturn result;\n}\n\nstatic u32 catpt_stream_read_position(struct catpt_dev *cdev,\n\t\t\t\t      struct catpt_stream_runtime *stream)\n{\n\tu32 pos;\n\n\tmemcpy_fromio(&pos, cdev->lpe_ba + stream->info.read_pos_regaddr,\n\t\t      sizeof(pos));\n\treturn pos;\n}\n\nstatic u32 catpt_stream_volume(struct catpt_dev *cdev,\n\t\t\t       struct catpt_stream_runtime *stream, u32 channel)\n{\n\tu32 volume, offset;\n\n\tif (channel >= CATPT_CHANNELS_MAX)\n\t\tchannel = 0;\n\n\toffset = stream->info.volume_regaddr[channel];\n\tmemcpy_fromio(&volume, cdev->lpe_ba + offset, sizeof(volume));\n\treturn volume;\n}\n\nstatic u32 catpt_mixer_volume(struct catpt_dev *cdev,\n\t\t\t      struct catpt_mixer_stream_info *info, u32 channel)\n{\n\tu32 volume, offset;\n\n\tif (channel >= CATPT_CHANNELS_MAX)\n\t\tchannel = 0;\n\n\toffset = info->volume_regaddr[channel];\n\tmemcpy_fromio(&volume, cdev->lpe_ba + offset, sizeof(volume));\n\treturn volume;\n}\n\nstatic void catpt_arrange_page_table(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_dma_buffer *pgtbl)\n{\n\tstruct snd_pcm_runtime *rtm = substream->runtime;\n\tstruct snd_dma_buffer *databuf = snd_pcm_get_dma_buf(substream);\n\tint i, pages;\n\n\tpages = snd_sgbuf_aligned_pages(rtm->dma_bytes);\n\n\tfor (i = 0; i < pages; i++) {\n\t\tu32 pfn, offset;\n\t\tu32 *page_table;\n\n\t\tpfn = PFN_DOWN(snd_sgbuf_get_addr(databuf, i * PAGE_SIZE));\n\t\t \n\t\toffset = ((i << 2) + i) >> 1;\n\t\tpage_table = (u32 *)(pgtbl->area + offset);\n\n\t\tif (i & 1)\n\t\t\t*page_table |= (pfn << 4);\n\t\telse\n\t\t\t*page_table |= pfn;\n\t}\n}\n\nstatic u32 catpt_get_channel_map(enum catpt_channel_config config)\n{\n\tswitch (config) {\n\tcase CATPT_CHANNEL_CONFIG_MONO:\n\t\treturn GENMASK(31, 4) | CATPT_CHANNEL_CENTER;\n\n\tcase CATPT_CHANNEL_CONFIG_STEREO:\n\t\treturn GENMASK(31, 8) | CATPT_CHANNEL_LEFT\n\t\t\t\t      | (CATPT_CHANNEL_RIGHT << 4);\n\n\tcase CATPT_CHANNEL_CONFIG_2_POINT_1:\n\t\treturn GENMASK(31, 12) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 4)\n\t\t\t\t       | (CATPT_CHANNEL_LFE << 8);\n\n\tcase CATPT_CHANNEL_CONFIG_3_POINT_0:\n\t\treturn GENMASK(31, 12) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_CENTER << 4)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 8);\n\n\tcase CATPT_CHANNEL_CONFIG_3_POINT_1:\n\t\treturn GENMASK(31, 16) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_CENTER << 4)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 8)\n\t\t\t\t       | (CATPT_CHANNEL_LFE << 12);\n\n\tcase CATPT_CHANNEL_CONFIG_QUATRO:\n\t\treturn GENMASK(31, 16) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 4)\n\t\t\t\t       | (CATPT_CHANNEL_LEFT_SURROUND << 8)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT_SURROUND << 12);\n\n\tcase CATPT_CHANNEL_CONFIG_4_POINT_0:\n\t\treturn GENMASK(31, 16) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_CENTER << 4)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 8)\n\t\t\t\t       | (CATPT_CHANNEL_CENTER_SURROUND << 12);\n\n\tcase CATPT_CHANNEL_CONFIG_5_POINT_0:\n\t\treturn GENMASK(31, 20) | CATPT_CHANNEL_LEFT\n\t\t\t\t       | (CATPT_CHANNEL_CENTER << 4)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 8)\n\t\t\t\t       | (CATPT_CHANNEL_LEFT_SURROUND << 12)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT_SURROUND << 16);\n\n\tcase CATPT_CHANNEL_CONFIG_5_POINT_1:\n\t\treturn GENMASK(31, 24) | CATPT_CHANNEL_CENTER\n\t\t\t\t       | (CATPT_CHANNEL_LEFT << 4)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT << 8)\n\t\t\t\t       | (CATPT_CHANNEL_LEFT_SURROUND << 12)\n\t\t\t\t       | (CATPT_CHANNEL_RIGHT_SURROUND << 16)\n\t\t\t\t       | (CATPT_CHANNEL_LFE << 20);\n\n\tcase CATPT_CHANNEL_CONFIG_DUAL_MONO:\n\t\treturn GENMASK(31, 8) | CATPT_CHANNEL_LEFT\n\t\t\t\t      | (CATPT_CHANNEL_LEFT << 4);\n\n\tdefault:\n\t\treturn U32_MAX;\n\t}\n}\n\nstatic enum catpt_channel_config catpt_get_channel_config(u32 num_channels)\n{\n\tswitch (num_channels) {\n\tcase 6:\n\t\treturn CATPT_CHANNEL_CONFIG_5_POINT_1;\n\tcase 5:\n\t\treturn CATPT_CHANNEL_CONFIG_5_POINT_0;\n\tcase 4:\n\t\treturn CATPT_CHANNEL_CONFIG_QUATRO;\n\tcase 3:\n\t\treturn CATPT_CHANNEL_CONFIG_2_POINT_1;\n\tcase 1:\n\t\treturn CATPT_CHANNEL_CONFIG_MONO;\n\tcase 2:\n\tdefault:\n\t\treturn CATPT_CHANNEL_CONFIG_STEREO;\n\t}\n}\n\nstatic int catpt_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct catpt_stream_template *template;\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tstruct resource *res;\n\tint ret;\n\n\ttemplate = catpt_get_stream_template(substream);\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, cdev->dev, PAGE_SIZE,\n\t\t\t\t  &stream->pgtbl);\n\tif (ret)\n\t\tgoto err_pgtbl;\n\n\tres = catpt_request_region(&cdev->dram, template->persistent_size);\n\tif (!res) {\n\t\tret = -EBUSY;\n\t\tgoto err_request;\n\t}\n\n\tcatpt_dsp_update_srampge(cdev, &cdev->dram, cdev->spec->dram_mask);\n\n\tstream->template = template;\n\tstream->persistent = res;\n\tstream->substream = substream;\n\tINIT_LIST_HEAD(&stream->node);\n\tsnd_soc_dai_set_dma_data(dai, substream, stream);\n\n\tspin_lock(&cdev->list_lock);\n\tlist_add_tail(&stream->node, &cdev->stream_list);\n\tspin_unlock(&cdev->list_lock);\n\n\treturn 0;\n\nerr_request:\n\tsnd_dma_free_pages(&stream->pgtbl);\nerr_pgtbl:\n\tkfree(stream);\n\treturn ret;\n}\n\nstatic void catpt_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tspin_lock(&cdev->list_lock);\n\tlist_del(&stream->node);\n\tspin_unlock(&cdev->list_lock);\n\n\trelease_resource(stream->persistent);\n\tkfree(stream->persistent);\n\tcatpt_dsp_update_srampge(cdev, &cdev->dram, cdev->spec->dram_mask);\n\n\tsnd_dma_free_pages(&stream->pgtbl);\n\tkfree(stream);\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int catpt_set_dspvol(struct catpt_dev *cdev, u8 stream_id, long *ctlvol);\n\nstatic int catpt_dai_apply_usettings(struct snd_soc_dai *dai,\n\t\t\t\t     struct catpt_stream_runtime *stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct snd_kcontrol *pos;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tconst char *name;\n\tint ret;\n\tu32 id = stream->info.stream_hw_id;\n\n\t \n\tswitch (id) {\n\tcase CATPT_PIN_ID_OFFLOAD1:\n\t\tname = \"Media0 Playback Volume\";\n\t\tbreak;\n\tcase CATPT_PIN_ID_OFFLOAD2:\n\t\tname = \"Media1 Playback Volume\";\n\t\tbreak;\n\tcase CATPT_PIN_ID_CAPTURE1:\n\t\tname = \"Mic Capture Volume\";\n\t\tbreak;\n\tcase CATPT_PIN_ID_REFERENCE:\n\t\tname = \"Loopback Mute\";\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(pos, &component->card->snd_card->controls, list) {\n\t\tif (pos->private_data == component &&\n\t\t    !strncmp(name, pos->id.name, sizeof(pos->id.name)))\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(pos, &component->card->snd_card->controls, list))\n\t\treturn -ENOENT;\n\n\tif (stream->template->type != CATPT_STRM_TYPE_LOOPBACK)\n\t\treturn catpt_set_dspvol(cdev, id, (long *)pos->private_value);\n\tret = catpt_ipc_mute_loopback(cdev, id, *(bool *)pos->private_value);\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\treturn 0;\n}\n\nstatic int catpt_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *rtm = substream->runtime;\n\tstruct snd_dma_buffer *dmab;\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_audio_format afmt;\n\tstruct catpt_ring_info rinfo;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tint ret;\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\tif (stream->allocated)\n\t\treturn 0;\n\n\tmemset(&afmt, 0, sizeof(afmt));\n\tafmt.sample_rate = params_rate(params);\n\tafmt.bit_depth = params_physical_width(params);\n\tafmt.valid_bit_depth = params_width(params);\n\tafmt.num_channels = params_channels(params);\n\tafmt.channel_config = catpt_get_channel_config(afmt.num_channels);\n\tafmt.channel_map = catpt_get_channel_map(afmt.channel_config);\n\tafmt.interleaving = CATPT_INTERLEAVING_PER_CHANNEL;\n\n\tdmab = snd_pcm_get_dma_buf(substream);\n\tcatpt_arrange_page_table(substream, &stream->pgtbl);\n\n\tmemset(&rinfo, 0, sizeof(rinfo));\n\trinfo.page_table_addr = stream->pgtbl.addr;\n\trinfo.num_pages = DIV_ROUND_UP(rtm->dma_bytes, PAGE_SIZE);\n\trinfo.size = rtm->dma_bytes;\n\trinfo.offset = 0;\n\trinfo.ring_first_page_pfn = PFN_DOWN(snd_sgbuf_get_addr(dmab, 0));\n\n\tret = catpt_ipc_alloc_stream(cdev, stream->template->path_id,\n\t\t\t\t     stream->template->type,\n\t\t\t\t     &afmt, &rinfo,\n\t\t\t\t     stream->template->num_entries,\n\t\t\t\t     stream->template->entries,\n\t\t\t\t     stream->persistent,\n\t\t\t\t     cdev->scratch,\n\t\t\t\t     &stream->info);\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\tret = catpt_dai_apply_usettings(dai, stream);\n\tif (ret)\n\t\treturn ret;\n\n\tstream->allocated = true;\n\treturn 0;\n}\n\nstatic int catpt_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\tif (!stream->allocated)\n\t\treturn 0;\n\n\tcatpt_ipc_reset_stream(cdev, stream->info.stream_hw_id);\n\tcatpt_ipc_free_stream(cdev, stream->info.stream_hw_id);\n\n\tstream->allocated = false;\n\treturn 0;\n}\n\nstatic int catpt_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tint ret;\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\tif (stream->prepared)\n\t\treturn 0;\n\n\tret = catpt_ipc_reset_stream(cdev, stream->info.stream_hw_id);\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\tret = catpt_ipc_pause_stream(cdev, stream->info.stream_hw_id);\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\tstream->prepared = true;\n\treturn 0;\n}\n\nstatic int catpt_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tsnd_pcm_uframes_t pos;\n\tint ret;\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tif (stream->template->type != CATPT_STRM_TYPE_RENDER)\n\t\t\tgoto resume_stream;\n\n\t\tpos = frames_to_bytes(runtime, runtime->start_threshold);\n\t\t \n\t\tret = catpt_ipc_set_write_pos(cdev, stream->info.stream_hw_id,\n\t\t\t\t\t      pos, false, false);\n\t\tif (ret)\n\t\t\treturn CATPT_IPC_ERROR(ret);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tresume_stream:\n\t\tcatpt_dsp_update_lpclock(cdev);\n\t\tret = catpt_ipc_resume_stream(cdev, stream->info.stream_hw_id);\n\t\tif (ret)\n\t\t\treturn CATPT_IPC_ERROR(ret);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstream->prepared = false;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = catpt_ipc_pause_stream(cdev, stream->info.stream_hw_id);\n\t\tcatpt_dsp_update_lpclock(cdev);\n\t\tif (ret)\n\t\t\treturn CATPT_IPC_ERROR(ret);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid catpt_stream_update_position(struct catpt_dev *cdev,\n\t\t\t\t  struct catpt_stream_runtime *stream,\n\t\t\t\t  struct catpt_notify_position *pos)\n{\n\tstruct snd_pcm_substream *substream = stream->substream;\n\tstruct snd_pcm_runtime *r = substream->runtime;\n\tsnd_pcm_uframes_t dsppos, newpos;\n\tint ret;\n\n\tdsppos = bytes_to_frames(r, pos->stream_position);\n\n\tif (!stream->prepared)\n\t\tgoto exit;\n\t \n\tif (stream->template->type != CATPT_STRM_TYPE_RENDER)\n\t\tgoto exit;\n\n\tif (dsppos >= r->buffer_size / 2)\n\t\tnewpos = r->buffer_size / 2;\n\telse\n\t\tnewpos = 0;\n\t \n\tret = catpt_ipc_set_write_pos(cdev, stream->info.stream_hw_id,\n\t\t\t\t      frames_to_bytes(r, newpos),\n\t\t\t\t      false, false);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"update position for stream %d failed: %d\\n\",\n\t\t\tstream->info.stream_hw_id, ret);\n\t\treturn;\n\t}\nexit:\n\tsnd_pcm_period_elapsed(substream);\n}\n\n \n#define CATPT_BUFFER_MAX_SIZE\t76800\n#define CATPT_PCM_PERIODS_MAX\t4\n#define CATPT_PCM_PERIODS_MIN\t2\n\nstatic const struct snd_pcm_hardware catpt_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t  SNDRV_PCM_INFO_RESUME |\n\t\t\t\t  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t.period_bytes_min\t= PAGE_SIZE,\n\t.period_bytes_max\t= CATPT_BUFFER_MAX_SIZE / CATPT_PCM_PERIODS_MIN,\n\t.periods_min\t\t= CATPT_PCM_PERIODS_MIN,\n\t.periods_max\t\t= CATPT_PCM_PERIODS_MAX,\n\t.buffer_bytes_max\t= CATPT_BUFFER_MAX_SIZE,\n};\n\nstatic int catpt_component_pcm_construct(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_soc_pcm_runtime *rtm)\n{\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\n\tsnd_pcm_set_managed_buffer_all(rtm->pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       cdev->dev,\n\t\t\t\t       catpt_pcm_hardware.buffer_bytes_max,\n\t\t\t\t       catpt_pcm_hardware.buffer_bytes_max);\n\n\treturn 0;\n}\n\nstatic int catpt_component_open(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtm = asoc_substream_to_rtd(substream);\n\n\tif (!rtm->dai_link->no_pcm)\n\t\tsnd_soc_set_runtime_hwparams(substream, &catpt_pcm_hardware);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\ncatpt_component_pointer(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtm = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtm, 0);\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tu32 pos;\n\n\tif (rtm->dai_link->no_pcm)\n\t\treturn 0;\n\n\tstream = snd_soc_dai_get_dma_data(cpu_dai, substream);\n\tpos = catpt_stream_read_position(cdev, stream);\n\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic const struct snd_soc_dai_ops catpt_fe_dai_ops = {\n\t.startup = catpt_dai_startup,\n\t.shutdown = catpt_dai_shutdown,\n\t.hw_params = catpt_dai_hw_params,\n\t.hw_free = catpt_dai_hw_free,\n\t.prepare = catpt_dai_prepare,\n\t.trigger = catpt_dai_trigger,\n};\n\nstatic int catpt_dai_pcm_new(struct snd_soc_pcm_runtime *rtm,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtm, 0);\n\tstruct catpt_ssp_device_format devfmt;\n\tstruct catpt_dev *cdev = dev_get_drvdata(dai->dev);\n\tint ret;\n\n\tdevfmt.iface = dai->driver->id;\n\tdevfmt.channels = codec_dai->driver->capture.channels_max;\n\n\tswitch (devfmt.iface) {\n\tcase CATPT_SSP_IFACE_0:\n\t\tdevfmt.mclk = CATPT_MCLK_FREQ_24_MHZ;\n\n\t\tswitch (devfmt.channels) {\n\t\tcase 4:\n\t\t\tdevfmt.mode = CATPT_SSP_MODE_TDM_PROVIDER;\n\t\t\tdevfmt.clock_divider = 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\tdevfmt.mode = CATPT_SSP_MODE_I2S_PROVIDER;\n\t\t\tdevfmt.clock_divider = 9;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase CATPT_SSP_IFACE_1:\n\t\tdevfmt.mclk = CATPT_MCLK_OFF;\n\t\tdevfmt.mode = CATPT_SSP_MODE_I2S_CONSUMER;\n\t\tdevfmt.clock_divider = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (!memcmp(&cdev->devfmt[devfmt.iface], &devfmt, sizeof(devfmt)))\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tret = catpt_ipc_set_device_format(cdev, &devfmt);\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\t \n\tmemcpy(&cdev->devfmt[devfmt.iface], &devfmt, sizeof(devfmt));\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops catpt_dai_ops = {\n\t.pcm_new = catpt_dai_pcm_new,\n};\n\nstatic struct snd_soc_dai_driver dai_drivers[] = {\n \n{\n\t.name  = \"System Pin\",\n\t.id = CATPT_STRM_TYPE_SYSTEM,\n\t.ops = &catpt_fe_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"System Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Analog Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 4,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name  = \"Offload0 Pin\",\n\t.id = CATPT_STRM_TYPE_RENDER,\n\t.ops = &catpt_fe_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Offload0 Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name  = \"Offload1 Pin\",\n\t.id = CATPT_STRM_TYPE_RENDER,\n\t.ops = &catpt_fe_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Offload1 Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name  = \"Loopback Pin\",\n\t.id = CATPT_STRM_TYPE_LOOPBACK,\n\t.ops = &catpt_fe_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"Loopback Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name  = \"Bluetooth Pin\",\n\t.id = CATPT_STRM_TYPE_BLUETOOTH_RENDER,\n\t.ops = &catpt_fe_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Bluetooth Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Bluetooth Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n \n{\n\t.name = \"ssp0-port\",\n\t.id = CATPT_SSP_IFACE_0,\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.ops = &catpt_dai_ops,\n},\n{\n\t.name = \"ssp1-port\",\n\t.id = CATPT_SSP_IFACE_1,\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.ops = &catpt_dai_ops,\n},\n};\n\n#define DSP_VOLUME_MAX\t\tS32_MAX  \n#define DSP_VOLUME_STEP_MAX\t30\n\nstatic u32 ctlvol_to_dspvol(u32 value)\n{\n\tif (value > DSP_VOLUME_STEP_MAX)\n\t\tvalue = 0;\n\treturn DSP_VOLUME_MAX >> (DSP_VOLUME_STEP_MAX - value);\n}\n\nstatic u32 dspvol_to_ctlvol(u32 volume)\n{\n\tif (volume > DSP_VOLUME_MAX)\n\t\treturn DSP_VOLUME_STEP_MAX;\n\treturn volume ? __fls(volume) : 0;\n}\n\nstatic int catpt_set_dspvol(struct catpt_dev *cdev, u8 stream_id, long *ctlvol)\n{\n\tu32 dspvol;\n\tint ret, i;\n\n\tfor (i = 1; i < CATPT_CHANNELS_MAX; i++)\n\t\tif (ctlvol[i] != ctlvol[0])\n\t\t\tbreak;\n\n\tif (i == CATPT_CHANNELS_MAX) {\n\t\tdspvol = ctlvol_to_dspvol(ctlvol[0]);\n\n\t\tret = catpt_ipc_set_volume(cdev, stream_id,\n\t\t\t\t\t   CATPT_ALL_CHANNELS_MASK, dspvol,\n\t\t\t\t\t   0, CATPT_AUDIO_CURVE_NONE);\n\t} else {\n\t\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++) {\n\t\t\tdspvol = ctlvol_to_dspvol(ctlvol[i]);\n\n\t\t\tret = catpt_ipc_set_volume(cdev, stream_id,\n\t\t\t\t\t\t   i, dspvol,\n\t\t\t\t\t\t   0, CATPT_AUDIO_CURVE_NONE);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\treturn 0;\n}\n\nstatic int catpt_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = CATPT_CHANNELS_MAX;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = DSP_VOLUME_STEP_MAX;\n\treturn 0;\n}\n\nstatic int catpt_mixer_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tu32 dspvol;\n\tint ret;\n\tint i;\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++) {\n\t\tdspvol = catpt_mixer_volume(cdev, &cdev->mixer, i);\n\t\tucontrol->value.integer.value[i] = dspvol_to_ctlvol(dspvol);\n\t}\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\treturn 0;\n}\n\nstatic int catpt_mixer_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tret = catpt_set_dspvol(cdev, cdev->mixer.mixer_hw_id,\n\t\t\t       ucontrol->value.integer.value);\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\treturn ret;\n}\n\nstatic int catpt_stream_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t   enum catpt_pin_id pin_id)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tlong *ctlvol = (long *)kcontrol->private_value;\n\tu32 dspvol;\n\tint ret;\n\tint i;\n\n\tstream = catpt_stream_find(cdev, pin_id);\n\tif (!stream) {\n\t\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++)\n\t\t\tucontrol->value.integer.value[i] = ctlvol[i];\n\t\treturn 0;\n\t}\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++) {\n\t\tdspvol = catpt_stream_volume(cdev, stream, i);\n\t\tucontrol->value.integer.value[i] = dspvol_to_ctlvol(dspvol);\n\t}\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\treturn 0;\n}\n\nstatic int catpt_stream_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t   enum catpt_pin_id pin_id)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tlong *ctlvol = (long *)kcontrol->private_value;\n\tint ret, i;\n\n\tstream = catpt_stream_find(cdev, pin_id);\n\tif (!stream) {\n\t\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++)\n\t\t\tctlvol[i] = ucontrol->value.integer.value[i];\n\t\treturn 0;\n\t}\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tret = catpt_set_dspvol(cdev, stream->info.stream_hw_id,\n\t\t\t       ucontrol->value.integer.value);\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < CATPT_CHANNELS_MAX; i++)\n\t\tctlvol[i] = ucontrol->value.integer.value[i];\n\treturn 0;\n}\n\nstatic int catpt_offload1_volume_get(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_get(kctl, uctl, CATPT_PIN_ID_OFFLOAD1);\n}\n\nstatic int catpt_offload1_volume_put(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_put(kctl, uctl, CATPT_PIN_ID_OFFLOAD1);\n}\n\nstatic int catpt_offload2_volume_get(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_get(kctl, uctl, CATPT_PIN_ID_OFFLOAD2);\n}\n\nstatic int catpt_offload2_volume_put(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_put(kctl, uctl, CATPT_PIN_ID_OFFLOAD2);\n}\n\nstatic int catpt_capture_volume_get(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_get(kctl, uctl, CATPT_PIN_ID_CAPTURE1);\n}\n\nstatic int catpt_capture_volume_put(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *uctl)\n{\n\treturn catpt_stream_volume_put(kctl, uctl, CATPT_PIN_ID_CAPTURE1);\n}\n\nstatic int catpt_loopback_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = *(bool *)kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int catpt_loopback_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct catpt_stream_runtime *stream;\n\tstruct catpt_dev *cdev = dev_get_drvdata(component->dev);\n\tbool mute;\n\tint ret;\n\n\tmute = (bool)ucontrol->value.integer.value[0];\n\tstream = catpt_stream_find(cdev, CATPT_PIN_ID_REFERENCE);\n\tif (!stream) {\n\t\t*(bool *)kcontrol->private_value = mute;\n\t\treturn 0;\n\t}\n\n\tret = pm_runtime_resume_and_get(cdev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tret = catpt_ipc_mute_loopback(cdev, stream->info.stream_hw_id, mute);\n\n\tpm_runtime_mark_last_busy(cdev->dev);\n\tpm_runtime_put_autosuspend(cdev->dev);\n\n\tif (ret)\n\t\treturn CATPT_IPC_ERROR(ret);\n\n\t*(bool *)kcontrol->private_value = mute;\n\treturn 0;\n}\n\nstatic int catpt_waves_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\treturn 0;\n}\n\nstatic int catpt_waves_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\treturn 0;\n}\n\nstatic int catpt_waves_param_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t unsigned int __user *bytes,\n\t\t\t\t unsigned int size)\n{\n\treturn 0;\n}\n\nstatic int catpt_waves_param_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t const unsigned int __user *bytes,\n\t\t\t\t unsigned int size)\n{\n\treturn 0;\n}\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(catpt_volume_tlv, -9000, 300, 1);\n\n#define CATPT_VOLUME_CTL(kname, sname) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = (kname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.info = catpt_volume_info, \\\n\t.get = catpt_##sname##_volume_get, \\\n\t.put = catpt_##sname##_volume_put, \\\n\t.tlv.p = catpt_volume_tlv, \\\n\t.private_value = (unsigned long) \\\n\t\t&(long[CATPT_CHANNELS_MAX]) {0} }\n\nstatic const struct snd_kcontrol_new component_kcontrols[] = {\n \nCATPT_VOLUME_CTL(\"Master Playback Volume\", mixer),\n \nCATPT_VOLUME_CTL(\"Media0 Playback Volume\", offload1),\nCATPT_VOLUME_CTL(\"Media1 Playback Volume\", offload2),\nCATPT_VOLUME_CTL(\"Mic Capture Volume\", capture),\nSOC_SINGLE_BOOL_EXT(\"Loopback Mute\", (unsigned long)&(bool[1]) {0},\n\t\t    catpt_loopback_switch_get, catpt_loopback_switch_put),\n \nSOC_SINGLE_BOOL_EXT(\"Waves Switch\", 0,\n\t\t    catpt_waves_switch_get, catpt_waves_switch_put),\n \nSND_SOC_BYTES_TLV(\"Waves Set Param\", 128,\n\t\t  catpt_waves_param_get, catpt_waves_param_put),\n};\n\nstatic const struct snd_soc_dapm_widget component_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"SSP0 CODEC IN\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"SSP0 CODEC OUT\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SSP1 BT IN\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"SSP1 BT OUT\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Playback VMixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route component_routes[] = {\n\t{\"Playback VMixer\", NULL, \"System Playback\"},\n\t{\"Playback VMixer\", NULL, \"Offload0 Playback\"},\n\t{\"Playback VMixer\", NULL, \"Offload1 Playback\"},\n\n\t{\"SSP0 CODEC OUT\", NULL, \"Playback VMixer\"},\n\n\t{\"Analog Capture\", NULL, \"SSP0 CODEC IN\"},\n\t{\"Loopback Capture\", NULL, \"SSP0 CODEC IN\"},\n\n\t{\"SSP1 BT OUT\", NULL, \"Bluetooth Playback\"},\n\t{\"Bluetooth Capture\", NULL, \"SSP1 BT IN\"},\n};\n\nstatic const struct snd_soc_component_driver catpt_comp_driver = {\n\t.name = \"catpt-platform\",\n\n\t.pcm_construct = catpt_component_pcm_construct,\n\t.open = catpt_component_open,\n\t.pointer = catpt_component_pointer,\n\n\t.controls = component_kcontrols,\n\t.num_controls = ARRAY_SIZE(component_kcontrols),\n\t.dapm_widgets = component_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(component_widgets),\n\t.dapm_routes = component_routes,\n\t.num_dapm_routes = ARRAY_SIZE(component_routes),\n};\n\nint catpt_arm_stream_templates(struct catpt_dev *cdev)\n{\n\tstruct resource *res;\n\tu32 scratch_size = 0;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(catpt_topology); i++) {\n\t\tstruct catpt_stream_template *template;\n\t\tstruct catpt_module_entry *entry;\n\t\tstruct catpt_module_type *type;\n\n\t\ttemplate = catpt_topology[i];\n\t\ttemplate->persistent_size = 0;\n\n\t\tfor (j = 0; j < template->num_entries; j++) {\n\t\t\tentry = &template->entries[j];\n\t\t\ttype = &cdev->modules[entry->module_id];\n\n\t\t\tif (!type->loaded)\n\t\t\t\treturn -ENOENT;\n\n\t\t\tentry->entry_point = type->entry_point;\n\t\t\ttemplate->persistent_size += type->persistent_size;\n\t\t\tif (type->scratch_size > scratch_size)\n\t\t\t\tscratch_size = type->scratch_size;\n\t\t}\n\t}\n\n\tif (scratch_size) {\n\t\t \n\t\tres = catpt_request_region(&cdev->dram, scratch_size);\n\t\tif (!res)\n\t\t\treturn -EBUSY;\n\t\tcdev->scratch = res;\n\t}\n\n\treturn 0;\n}\n\nint catpt_register_plat_component(struct catpt_dev *cdev)\n{\n\tstruct snd_soc_component *component;\n\tint ret;\n\n\tcomponent = devm_kzalloc(cdev->dev, sizeof(*component), GFP_KERNEL);\n\tif (!component)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_component_initialize(component, &catpt_comp_driver,\n\t\t\t\t\t   cdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tcomponent->name = catpt_comp_driver.name;\n\treturn snd_soc_add_component(component, dai_drivers,\n\t\t\t\t     ARRAY_SIZE(dai_drivers));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}