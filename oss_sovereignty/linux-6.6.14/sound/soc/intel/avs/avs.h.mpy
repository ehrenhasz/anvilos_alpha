{
  "module_name": "avs.h",
  "hash_id": "9b1bc6eda8bc0299772e8166fd557bafc183fdabb242687a3bbbecaf225bd312",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/avs.h",
  "human_readable_source": " \n \n\n#ifndef __SOUND_SOC_INTEL_AVS_H\n#define __SOUND_SOC_INTEL_AVS_H\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/kfifo.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_register.h>\n#include <sound/soc-component.h>\n#include \"messages.h\"\n#include \"registers.h\"\n\nstruct avs_dev;\nstruct avs_tplg;\nstruct avs_tplg_library;\nstruct avs_soc_component;\nstruct avs_ipc_msg;\n\n#ifdef CONFIG_ACPI\n#define AVS_S0IX_SUPPORTED \\\n\t(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)\n#else\n#define AVS_S0IX_SUPPORTED false\n#endif\n\n \nstruct avs_dsp_ops {\n\tint (* const power)(struct avs_dev *, u32, bool);\n\tint (* const reset)(struct avs_dev *, u32, bool);\n\tint (* const stall)(struct avs_dev *, u32, bool);\n\tirqreturn_t (* const irq_handler)(int, void *);\n\tirqreturn_t (* const irq_thread)(int, void *);\n\tvoid (* const int_control)(struct avs_dev *, bool);\n\tint (* const load_basefw)(struct avs_dev *, struct firmware *);\n\tint (* const load_lib)(struct avs_dev *, struct firmware *, u32);\n\tint (* const transfer_mods)(struct avs_dev *, bool, struct avs_module_entry *, u32);\n\tint (* const enable_logs)(struct avs_dev *, enum avs_log_enable, u32, u32, unsigned long,\n\t\t\t\t  u32 *);\n\tint (* const log_buffer_offset)(struct avs_dev *, u32);\n\tint (* const log_buffer_status)(struct avs_dev *, union avs_notify_msg *);\n\tint (* const coredump)(struct avs_dev *, union avs_notify_msg *);\n\tbool (* const d0ix_toggle)(struct avs_dev *, struct avs_ipc_msg *, bool);\n\tint (* const set_d0ix)(struct avs_dev *, bool);\n};\n\n#define avs_dsp_op(adev, op, ...) \\\n\t((adev)->spec->dsp_ops->op(adev, ## __VA_ARGS__))\n\nextern const struct avs_dsp_ops skl_dsp_ops;\nextern const struct avs_dsp_ops apl_dsp_ops;\n\n#define AVS_PLATATTR_CLDMA\t\tBIT_ULL(0)\n#define AVS_PLATATTR_IMR\t\tBIT_ULL(1)\n\n#define avs_platattr_test(adev, attr) \\\n\t((adev)->spec->attributes & AVS_PLATATTR_##attr)\n\n \nstruct avs_spec {\n\tconst char *name;\n\n\tconst struct avs_dsp_ops *const dsp_ops;\n\tstruct avs_fw_version min_fw_version;  \n\n\tconst u32 core_init_mask;\t \n\tconst u64 attributes;\t\t \n\tconst u32 sram_base_offset;\n\tconst u32 sram_window_size;\n\tconst u32 rom_status;\n};\n\nstruct avs_fw_entry {\n\tchar *name;\n\tconst struct firmware *fw;\n\n\tstruct list_head node;\n};\n\n \nstruct avs_dev {\n\tstruct hda_bus base;\n\tstruct device *dev;\n\n\tvoid __iomem *dsp_ba;\n\tconst struct avs_spec *spec;\n\tstruct avs_ipc *ipc;\n\n\tstruct avs_fw_cfg fw_cfg;\n\tstruct avs_hw_cfg hw_cfg;\n\tstruct avs_mods_info *mods_info;\n\tstruct ida **mod_idas;\n\tstruct mutex modres_mutex;\n\tstruct ida ppl_ida;\n\tstruct list_head fw_list;\n\tint *core_refs;\t\t \n\tchar **lib_names;\n\tint num_lp_paths;\n\n\tstruct completion fw_ready;\n\tstruct work_struct probe_work;\n\n\tstruct nhlt_acpi_table *nhlt;\n\tstruct list_head comp_list;\n\tstruct mutex comp_list_mutex;\n\tstruct list_head path_list;\n\tspinlock_t path_list_lock;\n\tstruct mutex path_mutex;\n\n\tspinlock_t trace_lock;\t \n#ifdef CONFIG_DEBUG_FS\n\tstruct kfifo trace_fifo;\n\twait_queue_head_t trace_waitq;\n\tu32 aging_timer_period;\n\tu32 fifo_full_timer_period;\n\tu32 logged_resources;\t \n\tstruct dentry *debugfs_root;\n\t \n\tstruct hdac_ext_stream *extractor;\n\tunsigned int num_probe_streams;\n#endif\n};\n\n \n#define hda_to_avs(hda) container_of(hda, struct avs_dev, base)\n \n#define hdac_to_avs(hdac) hda_to_avs(to_hda_bus(hdac))\n \n#define to_avs_dev(dev) \\\n({ \\\n\tstruct hdac_bus *__bus = dev_get_drvdata(dev); \\\n\thdac_to_avs(__bus); \\\n})\n\nint avs_dsp_core_power(struct avs_dev *adev, u32 core_mask, bool power);\nint avs_dsp_core_reset(struct avs_dev *adev, u32 core_mask, bool reset);\nint avs_dsp_core_stall(struct avs_dev *adev, u32 core_mask, bool stall);\nint avs_dsp_core_enable(struct avs_dev *adev, u32 core_mask);\nint avs_dsp_core_disable(struct avs_dev *adev, u32 core_mask);\n\n \n\nstruct avs_ipc_msg {\n\tunion {\n\t\tu64 header;\n\t\tunion avs_global_msg glb;\n\t\tunion avs_reply_msg rsp;\n\t};\n\tvoid *data;\n\tsize_t size;\n};\n\n \nstruct avs_ipc {\n\tstruct device *dev;\n\n\tstruct avs_ipc_msg rx;\n\tu32 default_timeout_ms;\n\tbool ready;\n\tatomic_t recovering;\n\n\tbool rx_completed;\n\tspinlock_t rx_lock;\n\tstruct mutex msg_mutex;\n\tstruct completion done_completion;\n\tstruct completion busy_completion;\n\n\tstruct work_struct recovery_work;\n\tstruct delayed_work d0ix_work;\n\tatomic_t d0ix_disable_depth;\n\tbool in_d0ix;\n};\n\n#define AVS_EIPC\tEREMOTEIO\n \n#define AVS_IPC_RET(ret) \\\n\t(((ret) <= 0) ? (ret) : -AVS_EIPC)\n\nstatic inline void avs_ipc_err(struct avs_dev *adev, struct avs_ipc_msg *tx,\n\t\t\t       const char *name, int error)\n{\n\t \n\tif (error == -EPERM || error == AVS_IPC_NOT_SUPPORTED)\n\t\tdev_dbg(adev->dev, \"%s 0x%08x 0x%08x failed: %d\\n\", name,\n\t\t\ttx->glb.primary, tx->glb.ext.val, error);\n\telse\n\t\tdev_err(adev->dev, \"%s 0x%08x 0x%08x failed: %d\\n\", name,\n\t\t\ttx->glb.primary, tx->glb.ext.val, error);\n}\n\nirqreturn_t avs_dsp_irq_handler(int irq, void *dev_id);\nirqreturn_t avs_dsp_irq_thread(int irq, void *dev_id);\nvoid avs_dsp_process_response(struct avs_dev *adev, u64 header);\nint avs_dsp_send_msg_timeout(struct avs_dev *adev,\n\t\t\t     struct avs_ipc_msg *request,\n\t\t\t     struct avs_ipc_msg *reply, int timeout);\nint avs_dsp_send_msg(struct avs_dev *adev,\n\t\t     struct avs_ipc_msg *request, struct avs_ipc_msg *reply);\n \nint avs_dsp_send_pm_msg_timeout(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\t\tstruct avs_ipc_msg *reply, int timeout, bool wake_d0i0);\nint avs_dsp_send_pm_msg(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\tstruct avs_ipc_msg *reply, bool wake_d0i0);\nint avs_dsp_send_rom_msg_timeout(struct avs_dev *adev,\n\t\t\t\t struct avs_ipc_msg *request, int timeout);\nint avs_dsp_send_rom_msg(struct avs_dev *adev, struct avs_ipc_msg *request);\nvoid avs_dsp_interrupt_control(struct avs_dev *adev, bool enable);\nint avs_ipc_init(struct avs_ipc *ipc, struct device *dev);\nvoid avs_ipc_block(struct avs_ipc *ipc);\n\nint avs_dsp_disable_d0ix(struct avs_dev *adev);\nint avs_dsp_enable_d0ix(struct avs_dev *adev);\n\nint skl_log_buffer_offset(struct avs_dev *adev, u32 core);\n\n \n\nint avs_get_module_entry(struct avs_dev *adev, const guid_t *uuid, struct avs_module_entry *entry);\nint avs_get_module_id_entry(struct avs_dev *adev, u32 module_id, struct avs_module_entry *entry);\nint avs_get_module_id(struct avs_dev *adev, const guid_t *uuid);\nbool avs_is_module_ida_empty(struct avs_dev *adev, u32 module_id);\n\nint avs_module_info_init(struct avs_dev *adev, bool purge);\nvoid avs_module_info_free(struct avs_dev *adev);\nint avs_module_id_alloc(struct avs_dev *adev, u16 module_id);\nvoid avs_module_id_free(struct avs_dev *adev, u16 module_id, u8 instance_id);\nint avs_request_firmware(struct avs_dev *adev, const struct firmware **fw_p, const char *name);\nvoid avs_release_last_firmware(struct avs_dev *adev);\nvoid avs_release_firmwares(struct avs_dev *adev);\n\nint avs_dsp_init_module(struct avs_dev *adev, u16 module_id, u8 ppl_instance_id,\n\t\t\tu8 core_id, u8 domain, void *param, u32 param_size,\n\t\t\tu8 *instance_id);\nvoid avs_dsp_delete_module(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t   u8 ppl_instance_id, u8 core_id);\nint avs_dsp_create_pipeline(struct avs_dev *adev, u16 req_size, u8 priority,\n\t\t\t    bool lp, u16 attributes, u8 *instance_id);\nint avs_dsp_delete_pipeline(struct avs_dev *adev, u8 instance_id);\n\n \n\nvoid avs_hda_clock_gating_enable(struct avs_dev *adev, bool enable);\nvoid avs_hda_power_gating_enable(struct avs_dev *adev, bool enable);\nvoid avs_hda_l1sen_enable(struct avs_dev *adev, bool enable);\n\nint avs_dsp_load_libraries(struct avs_dev *adev, struct avs_tplg_library *libs, u32 num_libs);\nint avs_dsp_boot_firmware(struct avs_dev *adev, bool purge);\nint avs_dsp_first_boot_firmware(struct avs_dev *adev);\n\nint avs_cldma_load_basefw(struct avs_dev *adev, struct firmware *fw);\nint avs_cldma_load_library(struct avs_dev *adev, struct firmware *lib, u32 id);\nint avs_cldma_transfer_modules(struct avs_dev *adev, bool load,\n\t\t\t       struct avs_module_entry *mods, u32 num_mods);\nint avs_hda_load_basefw(struct avs_dev *adev, struct firmware *fw);\nint avs_hda_load_library(struct avs_dev *adev, struct firmware *lib, u32 id);\nint avs_hda_transfer_modules(struct avs_dev *adev, bool load,\n\t\t\t     struct avs_module_entry *mods, u32 num_mods);\n\n \n\nstruct avs_soc_component {\n\tstruct snd_soc_component base;\n\tstruct avs_tplg *tplg;\n\n\tstruct list_head node;\n};\n\n#define to_avs_soc_component(comp) \\\n\tcontainer_of(comp, struct avs_soc_component, base)\n\nextern const struct snd_soc_dai_ops avs_dai_fe_ops;\n\nint avs_soc_component_register(struct device *dev, const char *name,\n\t\t\t       const struct snd_soc_component_driver *drv,\n\t\t\t       struct snd_soc_dai_driver *cpu_dais, int num_cpu_dais);\nint avs_dmic_platform_register(struct avs_dev *adev, const char *name);\nint avs_i2s_platform_register(struct avs_dev *adev, const char *name, unsigned long port_mask,\n\t\t\t      unsigned long *tdms);\nint avs_hda_platform_register(struct avs_dev *adev, const char *name);\n\nint avs_register_all_boards(struct avs_dev *adev);\nvoid avs_unregister_all_boards(struct avs_dev *adev);\n\n \n\n#define avs_log_buffer_size(adev) \\\n\t((adev)->fw_cfg.trace_log_bytes / (adev)->hw_cfg.dsp_cores)\n\n#define avs_log_buffer_addr(adev, core) \\\n({ \\\n\ts32 __offset = avs_dsp_op(adev, log_buffer_offset, core); \\\n\t(__offset < 0) ? NULL : \\\n\t\t\t (avs_sram_addr(adev, AVS_DEBUG_WINDOW) + __offset); \\\n})\n\nstatic inline int avs_log_buffer_status_locked(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&adev->trace_lock, flags);\n\tret = avs_dsp_op(adev, log_buffer_status, msg);\n\tspin_unlock_irqrestore(&adev->trace_lock, flags);\n\n\treturn ret;\n}\n\nstruct apl_log_buffer_layout {\n\tu32 read_ptr;\n\tu32 write_ptr;\n\tu8 buffer[];\n} __packed;\n\n#define apl_log_payload_size(adev) \\\n\t(avs_log_buffer_size(adev) - sizeof(struct apl_log_buffer_layout))\n\n#define apl_log_payload_addr(addr) \\\n\t(addr + sizeof(struct apl_log_buffer_layout))\n\n#ifdef CONFIG_DEBUG_FS\n#define AVS_SET_ENABLE_LOGS_OP(name) \\\n\t.enable_logs = name##_enable_logs\n\nbool avs_logging_fw(struct avs_dev *adev);\nvoid avs_dump_fw_log(struct avs_dev *adev, const void __iomem *src, unsigned int len);\nvoid avs_dump_fw_log_wakeup(struct avs_dev *adev, const void __iomem *src, unsigned int len);\n\nint avs_probe_platform_register(struct avs_dev *adev, const char *name);\n\nvoid avs_debugfs_init(struct avs_dev *adev);\nvoid avs_debugfs_exit(struct avs_dev *adev);\n#else\n#define AVS_SET_ENABLE_LOGS_OP(name)\n\nstatic inline bool avs_logging_fw(struct avs_dev *adev)\n{\n\treturn false;\n}\n\nstatic inline void avs_dump_fw_log(struct avs_dev *adev, const void __iomem *src, unsigned int len)\n{\n}\n\nstatic inline void\navs_dump_fw_log_wakeup(struct avs_dev *adev, const void __iomem *src, unsigned int len)\n{\n}\n\nstatic inline int avs_probe_platform_register(struct avs_dev *adev, const char *name)\n{\n\treturn 0;\n}\n\nstatic inline void avs_debugfs_init(struct avs_dev *adev) { }\nstatic inline void avs_debugfs_exit(struct avs_dev *adev) { }\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}