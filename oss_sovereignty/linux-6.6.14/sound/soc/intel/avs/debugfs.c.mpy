{
  "module_name": "debugfs.c",
  "hash_id": "03cb905120d5a554342df13f57223a61b23614d8678df4b4e9c3f6b0e64d68e4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/debugfs.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/kfifo.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <sound/soc.h>\n#include \"avs.h\"\n#include \"messages.h\"\n\nstatic unsigned int __kfifo_fromio(struct kfifo *fifo, const void __iomem *src, unsigned int len)\n{\n\tstruct __kfifo *__fifo = &fifo->kfifo;\n\tunsigned int l, off;\n\n\tlen = min(len, kfifo_avail(fifo));\n\toff = __fifo->in & __fifo->mask;\n\tl = min(len, kfifo_size(fifo) - off);\n\n\tmemcpy_fromio(__fifo->data + off, src, l);\n\tmemcpy_fromio(__fifo->data, src + l, len - l);\n\t \n\tsmp_mb();\n\t__fifo->in += len;\n\n\treturn len;\n}\n\nbool avs_logging_fw(struct avs_dev *adev)\n{\n\treturn kfifo_initialized(&adev->trace_fifo);\n}\n\nvoid avs_dump_fw_log(struct avs_dev *adev, const void __iomem *src, unsigned int len)\n{\n\t__kfifo_fromio(&adev->trace_fifo, src, len);\n}\n\nvoid avs_dump_fw_log_wakeup(struct avs_dev *adev, const void __iomem *src, unsigned int len)\n{\n\tavs_dump_fw_log(adev, src, len);\n\twake_up(&adev->trace_waitq);\n}\n\nstatic ssize_t fw_regs_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(AVS_FW_REGS_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(buf, avs_sram_addr(adev, AVS_FW_REGS_WINDOW), AVS_FW_REGS_SIZE);\n\n\tret = simple_read_from_buffer(to, count, ppos, buf, AVS_FW_REGS_SIZE);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations fw_regs_fops = {\n\t.open = simple_open,\n\t.read = fw_regs_read,\n\t.llseek = no_llseek,\n};\n\nstatic ssize_t debug_window_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tsize_t size;\n\tchar *buf;\n\tint ret;\n\n\tsize = adev->hw_cfg.dsp_cores * AVS_WINDOW_CHUNK_SIZE;\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(buf, avs_sram_addr(adev, AVS_DEBUG_WINDOW), size);\n\n\tret = simple_read_from_buffer(to, count, ppos, buf, size);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations debug_window_fops = {\n\t.open = simple_open,\n\t.read = debug_window_read,\n\t.llseek = no_llseek,\n};\n\nstatic ssize_t probe_points_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tstruct avs_probe_point_desc *desc;\n\tsize_t num_desc, len = 0;\n\tchar *buf;\n\tint i, ret;\n\n\t \n\tif (*ppos)\n\t\treturn 0;\n\n\tbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = avs_ipc_probe_get_points(adev, &desc, &num_desc);\n\tif (ret) {\n\t\tret = AVS_IPC_RET(ret);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < num_desc; i++) {\n\t\tret = snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t       \"Id: %#010x  Purpose: %d  Node id: %#x\\n\",\n\t\t\t       desc[i].id.value, desc[i].purpose, desc[i].node_id.val);\n\t\tif (ret < 0)\n\t\t\tgoto free_desc;\n\t\tlen += ret;\n\t}\n\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\nfree_desc:\n\tkfree(desc);\nexit:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t probe_points_write(struct file *file, const char __user *from, size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tstruct avs_probe_point_desc *desc;\n\tu32 *array, num_elems;\n\tsize_t bytes;\n\tint ret;\n\n\tret = parse_int_array_user(from, count, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_elems = *array;\n\tbytes = sizeof(*array) * num_elems;\n\tif (bytes % sizeof(*desc)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tdesc = (struct avs_probe_point_desc *)&array[1];\n\tret = avs_ipc_probe_connect_points(adev, desc, bytes / sizeof(*desc));\n\tif (ret)\n\t\tret = AVS_IPC_RET(ret);\n\telse\n\t\tret = count;\nexit:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic const struct file_operations probe_points_fops = {\n\t.open = simple_open,\n\t.read = probe_points_read,\n\t.write = probe_points_write,\n\t.llseek = no_llseek,\n};\n\nstatic ssize_t probe_points_disconnect_write(struct file *file, const char __user *from,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tunion avs_probe_point_id *id;\n\tu32 *array, num_elems;\n\tsize_t bytes;\n\tint ret;\n\n\tret = parse_int_array_user(from, count, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_elems = *array;\n\tbytes = sizeof(*array) * num_elems;\n\tif (bytes % sizeof(*id)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tid = (union avs_probe_point_id *)&array[1];\n\tret = avs_ipc_probe_disconnect_points(adev, id, bytes / sizeof(*id));\n\tif (ret)\n\t\tret = AVS_IPC_RET(ret);\n\telse\n\t\tret = count;\nexit:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic const struct file_operations probe_points_disconnect_fops = {\n\t.open = simple_open,\n\t.write = probe_points_disconnect_write,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t strace_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tstruct kfifo *fifo = &adev->trace_fifo;\n\tunsigned int copied;\n\n\tif (kfifo_is_empty(fifo)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&adev->trace_waitq, &wait, TASK_INTERRUPTIBLE);\n\t\tif (!signal_pending(current))\n\t\t\tschedule();\n\t\tfinish_wait(&adev->trace_waitq, &wait);\n\t}\n\n\tif (kfifo_to_user(fifo, to, count, &copied))\n\t\treturn -EFAULT;\n\t*ppos += copied;\n\treturn copied;\n}\n\nstatic int strace_open(struct inode *inode, struct file *file)\n{\n\tstruct avs_dev *adev = inode->i_private;\n\tint ret;\n\n\tif (kfifo_initialized(&adev->trace_fifo))\n\t\treturn -EBUSY;\n\n\tret = kfifo_alloc(&adev->trace_fifo, PAGE_SIZE, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfile->private_data = adev;\n\treturn 0;\n}\n\nstatic int strace_release(struct inode *inode, struct file *file)\n{\n\tunion avs_notify_msg msg = AVS_NOTIFICATION(LOG_BUFFER_STATUS);\n\tstruct avs_dev *adev = file->private_data;\n\tunsigned long resource_mask;\n\tunsigned long flags, i;\n\tu32 num_cores;\n\n\tresource_mask = adev->logged_resources;\n\tnum_cores = adev->hw_cfg.dsp_cores;\n\n\tspin_lock_irqsave(&adev->trace_lock, flags);\n\n\t \n\tfor_each_set_bit(i, &resource_mask, num_cores) {\n\t\tmsg.log.core = i;\n\t\tavs_dsp_op(adev, log_buffer_status, &msg);\n\t}\n\n\tkfifo_free(&adev->trace_fifo);\n\n\tspin_unlock_irqrestore(&adev->trace_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct file_operations strace_fops = {\n\t.llseek = default_llseek,\n\t.read = strace_read,\n\t.open = strace_open,\n\t.release = strace_release,\n};\n\n#define DISABLE_TIMERS\tUINT_MAX\n\nstatic int enable_logs(struct avs_dev *adev, u32 resource_mask, u32 *priorities)\n{\n\tint ret;\n\n\t \n\tif (!adev->logged_resources) {\n\t\tpm_runtime_get_sync(adev->dev);\n\n\t\tret = avs_dsp_disable_d0ix(adev);\n\t\tif (ret)\n\t\t\tgoto err_d0ix;\n\t}\n\n\tret = avs_ipc_set_system_time(adev);\n\tif (ret && ret != AVS_IPC_NOT_SUPPORTED) {\n\t\tret = AVS_IPC_RET(ret);\n\t\tgoto err_ipc;\n\t}\n\n\tret = avs_dsp_op(adev, enable_logs, AVS_LOG_ENABLE, adev->aging_timer_period,\n\t\t\t adev->fifo_full_timer_period, resource_mask, priorities);\n\tif (ret)\n\t\tgoto err_ipc;\n\n\tadev->logged_resources |= resource_mask;\n\treturn 0;\n\nerr_ipc:\n\tif (!adev->logged_resources) {\n\t\tavs_dsp_enable_d0ix(adev);\nerr_d0ix:\n\t\tpm_runtime_mark_last_busy(adev->dev);\n\t\tpm_runtime_put_autosuspend(adev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int disable_logs(struct avs_dev *adev, u32 resource_mask)\n{\n\tint ret;\n\n\t \n\tif (!adev->logged_resources)\n\t\treturn 0;\n\n\tret = avs_dsp_op(adev, enable_logs, AVS_LOG_DISABLE, DISABLE_TIMERS, DISABLE_TIMERS,\n\t\t\t resource_mask, NULL);\n\n\t \n\tadev->logged_resources &= ~resource_mask;\n\n\t \n\tif (!adev->logged_resources) {\n\t\tavs_dsp_enable_d0ix(adev);\n\t\tpm_runtime_mark_last_busy(adev->dev);\n\t\tpm_runtime_put_autosuspend(adev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t trace_control_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tchar buf[64];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), \"0x%08x\\n\", adev->logged_resources);\n\n\treturn simple_read_from_buffer(to, count, ppos, buf, len);\n}\n\nstatic ssize_t trace_control_write(struct file *file, const char __user *from, size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct avs_dev *adev = file->private_data;\n\tu32 *array, num_elems;\n\tu32 resource_mask;\n\tint ret;\n\n\tret = parse_int_array_user(from, count, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_elems = *array;\n\tresource_mask = array[1];\n\n\t \n\tif (num_elems == 1) {\n\t\tret = disable_logs(adev, resource_mask);\n\t} else {\n\t\tif (num_elems != (hweight_long(resource_mask) + 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_array;\n\t\t}\n\n\t\tret = enable_logs(adev, resource_mask, &array[2]);\n\t}\n\n\tif (!ret)\n\t\tret = count;\nfree_array:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic const struct file_operations trace_control_fops = {\n\t.llseek = default_llseek,\n\t.read = trace_control_read,\n\t.write = trace_control_write,\n\t.open = simple_open,\n};\n\nvoid avs_debugfs_init(struct avs_dev *adev)\n{\n\tinit_waitqueue_head(&adev->trace_waitq);\n\tspin_lock_init(&adev->trace_lock);\n\n\tadev->debugfs_root = debugfs_create_dir(\"avs\", snd_soc_debugfs_root);\n\n\t \n\tadev->aging_timer_period = 10;\n\tadev->fifo_full_timer_period = 10;\n\n\tdebugfs_create_file(\"strace\", 0444, adev->debugfs_root, adev, &strace_fops);\n\tdebugfs_create_file(\"trace_control\", 0644, adev->debugfs_root, adev, &trace_control_fops);\n\tdebugfs_create_file(\"fw_regs\", 0444, adev->debugfs_root, adev, &fw_regs_fops);\n\tdebugfs_create_file(\"debug_window\", 0444, adev->debugfs_root, adev, &debug_window_fops);\n\n\tdebugfs_create_u32(\"trace_aging_period\", 0644, adev->debugfs_root,\n\t\t\t   &adev->aging_timer_period);\n\tdebugfs_create_u32(\"trace_fifo_full_period\", 0644, adev->debugfs_root,\n\t\t\t   &adev->fifo_full_timer_period);\n\n\tdebugfs_create_file(\"probe_points\", 0644, adev->debugfs_root, adev, &probe_points_fops);\n\tdebugfs_create_file(\"probe_points_disconnect\", 0200, adev->debugfs_root, adev,\n\t\t\t    &probe_points_disconnect_fops);\n}\n\nvoid avs_debugfs_exit(struct avs_dev *adev)\n{\n\tdebugfs_remove_recursive(adev->debugfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}