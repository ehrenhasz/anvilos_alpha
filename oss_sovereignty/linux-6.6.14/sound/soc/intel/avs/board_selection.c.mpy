{
  "module_name": "board_selection.c",
  "hash_id": "fb5ec41bc3a65d098514e6f2d4c549d66467f95561337485592baaad6b8da557",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/board_selection.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_register.h>\n#include <sound/intel-nhlt.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-component.h>\n#include \"avs.h\"\n\nstatic bool i2s_test;\nmodule_param(i2s_test, bool, 0444);\nMODULE_PARM_DESC(i2s_test, \"Probe I2S test-board and skip all other I2S boards\");\n\nstatic const struct dmi_system_id kbl_dmi_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Skylake Y LPDDR3 RVP3\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"AmberLake Y\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic const struct dmi_system_id kblr_dmi_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Kabylake R DDR4 RVP\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic struct snd_soc_acpi_mach *dmi_match_quirk(void *arg)\n{\n\tstruct snd_soc_acpi_mach *mach = arg;\n\tconst struct dmi_system_id *dmi_id;\n\tstruct dmi_system_id *dmi_table;\n\n\tif (mach->quirk_data == NULL)\n\t\treturn mach;\n\n\tdmi_table = (struct dmi_system_id *)mach->quirk_data;\n\n\tdmi_id = dmi_first_match(dmi_table);\n\tif (!dmi_id)\n\t\treturn NULL;\n\n\treturn mach;\n}\n\n#define AVS_SSP(x)\t\t(BIT(x))\n#define AVS_SSP_RANGE(a, b)\t(GENMASK(b, a))\n\n \nstatic struct snd_soc_acpi_mach avs_skl_i2s_machines[] = {\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"avs_rt286\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"rt286-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"10508825\",\n\t\t.drv_name = \"avs_nau8825\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(1),\n\t\t},\n\t\t.tplg_filename = \"nau8825-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"INT343B\",\n\t\t.drv_name = \"avs_ssm4567\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"ssm4567-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"MX98357A\",\n\t\t.drv_name = \"avs_max98357a\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"max98357a-tplg.bin\",\n\t},\n\t{},\n};\n\nstatic struct snd_soc_acpi_mach avs_kbl_i2s_machines[] = {\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"avs_rt286\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.quirk_data = &kbl_dmi_table,\n\t\t.machine_quirk = dmi_match_quirk,\n\t\t.tplg_filename = \"rt286-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"avs_rt298\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.quirk_data = &kblr_dmi_table,\n\t\t.machine_quirk = dmi_match_quirk,\n\t\t.tplg_filename = \"rt298-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"MX98927\",\n\t\t.drv_name = \"avs_max98927\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"max98927-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"10EC5663\",\n\t\t.drv_name = \"avs_rt5663\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(1),\n\t\t},\n\t\t.tplg_filename = \"rt5663-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"MX98373\",\n\t\t.drv_name = \"avs_max98373\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"max98373-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"MX98357A\",\n\t\t.drv_name = \"avs_max98357a\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"max98357a-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"DLGS7219\",\n\t\t.drv_name = \"avs_da7219\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(1),\n\t\t},\n\t\t.tplg_filename = \"da7219-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"ESSX8336\",\n\t\t.drv_name = \"avs_es8336\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"es8336-tplg.bin\",\n\t},\n\t{},\n};\n\nstatic struct snd_soc_acpi_mach avs_apl_i2s_machines[] = {\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"avs_rt298\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(5),\n\t\t},\n\t\t.tplg_filename = \"rt298-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"INT34C3\",\n\t\t.drv_name = \"avs_tdf8532\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP_RANGE(0, 5),\n\t\t},\n\t\t.pdata = (unsigned long[]){ 0, 0, 0x14, 0, 0, 0 },  \n\t\t.tplg_filename = \"tdf8532-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"MX98357A\",\n\t\t.drv_name = \"avs_max98357a\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(5),\n\t\t},\n\t\t.tplg_filename = \"max98357a-tplg.bin\",\n\t},\n\t{\n\t\t.id = \"DLGS7219\",\n\t\t.drv_name = \"avs_da7219\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(1),\n\t\t},\n\t\t.tplg_filename = \"da7219-tplg.bin\",\n\t},\n\t{},\n};\n\nstatic struct snd_soc_acpi_mach avs_gml_i2s_machines[] = {\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"avs_rt298\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(2),\n\t\t},\n\t\t.tplg_filename = \"rt298-tplg.bin\",\n\t},\n\t{},\n};\n\nstatic struct snd_soc_acpi_mach avs_test_i2s_machines[] = {\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(0),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(1),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(2),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(3),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(4),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t{\n\t\t.drv_name = \"avs_i2s_test\",\n\t\t.mach_params = {\n\t\t\t.i2s_link_mask = AVS_SSP(5),\n\t\t},\n\t\t.tplg_filename = \"i2s-test-tplg.bin\",\n\t},\n\t \n};\n\nstruct avs_acpi_boards {\n\tint id;\n\tstruct snd_soc_acpi_mach *machs;\n};\n\n#define AVS_MACH_ENTRY(_id, _mach) \\\n\t{ .id = PCI_DEVICE_ID_INTEL_##_id, .machs = (_mach), }\n\n \nstatic const struct avs_acpi_boards i2s_boards[] = {\n\tAVS_MACH_ENTRY(HDA_SKL_LP, avs_skl_i2s_machines),\n\tAVS_MACH_ENTRY(HDA_KBL_LP, avs_kbl_i2s_machines),\n\tAVS_MACH_ENTRY(HDA_APL, avs_apl_i2s_machines),\n\tAVS_MACH_ENTRY(HDA_GML, avs_gml_i2s_machines),\n\t{},\n};\n\nstatic const struct avs_acpi_boards *avs_get_i2s_boards(struct avs_dev *adev)\n{\n\tint id, i;\n\n\tid = adev->base.pci->device;\n\tfor (i = 0; i < ARRAY_SIZE(i2s_boards); i++)\n\t\tif (i2s_boards[i].id == id)\n\t\t\treturn &i2s_boards[i];\n\treturn NULL;\n}\n\n \nstatic void board_pdev_unregister(void *data)\n{\n\tplatform_device_unregister(data);\n}\n\nstatic int __maybe_unused avs_register_probe_board(struct avs_dev *adev)\n{\n\tstruct platform_device *board;\n\tstruct snd_soc_acpi_mach mach = {{0}};\n\tint ret;\n\n\tret = avs_probe_platform_register(adev, \"probe-platform\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmach.mach_params.platform = \"probe-platform\";\n\n\tboard = platform_device_register_data(NULL, \"avs_probe_mb\", PLATFORM_DEVID_NONE,\n\t\t\t\t\t      (const void *)&mach, sizeof(mach));\n\tif (IS_ERR(board)) {\n\t\tdev_err(adev->dev, \"probe board register failed\\n\");\n\t\treturn PTR_ERR(board);\n\t}\n\n\tret = devm_add_action(adev->dev, board_pdev_unregister, board);\n\tif (ret < 0) {\n\t\tplatform_device_unregister(board);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int avs_register_dmic_board(struct avs_dev *adev)\n{\n\tstruct platform_device *codec, *board;\n\tstruct snd_soc_acpi_mach mach = {{0}};\n\tint ret;\n\n\tif (!adev->nhlt ||\n\t    !intel_nhlt_has_endpoint_type(adev->nhlt, NHLT_LINK_DMIC)) {\n\t\tdev_dbg(adev->dev, \"no DMIC endpoints present\\n\");\n\t\treturn 0;\n\t}\n\n\tcodec = platform_device_register_simple(\"dmic-codec\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(codec)) {\n\t\tdev_err(adev->dev, \"dmic codec register failed\\n\");\n\t\treturn PTR_ERR(codec);\n\t}\n\n\tret = devm_add_action(adev->dev, board_pdev_unregister, codec);\n\tif (ret < 0) {\n\t\tplatform_device_unregister(codec);\n\t\treturn ret;\n\t}\n\n\tret = avs_dmic_platform_register(adev, \"dmic-platform\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmach.tplg_filename = \"dmic-tplg.bin\";\n\tmach.mach_params.platform = \"dmic-platform\";\n\n\tboard = platform_device_register_data(NULL, \"avs_dmic\", PLATFORM_DEVID_NONE,\n\t\t\t\t\t(const void *)&mach, sizeof(mach));\n\tif (IS_ERR(board)) {\n\t\tdev_err(adev->dev, \"dmic board register failed\\n\");\n\t\treturn PTR_ERR(board);\n\t}\n\n\tret = devm_add_action(adev->dev, board_pdev_unregister, board);\n\tif (ret < 0) {\n\t\tplatform_device_unregister(board);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_register_i2s_board(struct avs_dev *adev, struct snd_soc_acpi_mach *mach)\n{\n\tstruct platform_device *board;\n\tint num_ssps;\n\tchar *name;\n\tint ret;\n\n\tnum_ssps = adev->hw_cfg.i2s_caps.ctrl_count;\n\tif (fls(mach->mach_params.i2s_link_mask) > num_ssps) {\n\t\tdev_err(adev->dev, \"Platform supports %d SSPs but board %s requires SSP%ld\\n\",\n\t\t\tnum_ssps, mach->drv_name,\n\t\t\t(unsigned long)__fls(mach->mach_params.i2s_link_mask));\n\t\treturn -ENODEV;\n\t}\n\n\tname = devm_kasprintf(adev->dev, GFP_KERNEL, \"%s.%d-platform\", mach->drv_name,\n\t\t\t      mach->mach_params.i2s_link_mask);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = avs_i2s_platform_register(adev, name, mach->mach_params.i2s_link_mask, mach->pdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmach->mach_params.platform = name;\n\n\tboard = platform_device_register_data(NULL, mach->drv_name, mach->mach_params.i2s_link_mask,\n\t\t\t\t\t      (const void *)mach, sizeof(*mach));\n\tif (IS_ERR(board)) {\n\t\tdev_err(adev->dev, \"ssp board register failed\\n\");\n\t\treturn PTR_ERR(board);\n\t}\n\n\tret = devm_add_action(adev->dev, board_pdev_unregister, board);\n\tif (ret < 0) {\n\t\tplatform_device_unregister(board);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_register_i2s_boards(struct avs_dev *adev)\n{\n\tconst struct avs_acpi_boards *boards;\n\tstruct snd_soc_acpi_mach *mach;\n\tint ret;\n\n\tif (!adev->nhlt || !intel_nhlt_has_endpoint_type(adev->nhlt, NHLT_LINK_SSP)) {\n\t\tdev_dbg(adev->dev, \"no I2S endpoints present\\n\");\n\t\treturn 0;\n\t}\n\n\tif (i2s_test) {\n\t\tint i, num_ssps;\n\n\t\tnum_ssps = adev->hw_cfg.i2s_caps.ctrl_count;\n\t\t \n\t\tnum_ssps = min_t(int, ARRAY_SIZE(avs_test_i2s_machines), num_ssps);\n\n\t\tmach = avs_test_i2s_machines;\n\n\t\tfor (i = 0; i < num_ssps; i++) {\n\t\t\tret = avs_register_i2s_board(adev, &mach[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(adev->dev, \"register i2s %s failed: %d\\n\", mach->drv_name,\n\t\t\t\t\t ret);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tboards = avs_get_i2s_boards(adev);\n\tif (!boards) {\n\t\tdev_dbg(adev->dev, \"no I2S endpoints supported\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (mach = boards->machs; mach->id[0]; mach++) {\n\t\tif (!acpi_dev_present(mach->id, mach->uid, -1))\n\t\t\tcontinue;\n\n\t\tif (mach->machine_quirk)\n\t\t\tif (!mach->machine_quirk(mach))\n\t\t\t\tcontinue;\n\n\t\tret = avs_register_i2s_board(adev, mach);\n\t\tif (ret < 0)\n\t\t\tdev_warn(adev->dev, \"register i2s %s failed: %d\\n\", mach->drv_name, ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_register_hda_board(struct avs_dev *adev, struct hda_codec *codec)\n{\n\tstruct snd_soc_acpi_mach mach = {{0}};\n\tstruct platform_device *board;\n\tstruct hdac_device *hdev = &codec->core;\n\tchar *pname;\n\tint ret, id;\n\n\tpname = devm_kasprintf(adev->dev, GFP_KERNEL, \"%s-platform\", dev_name(&hdev->dev));\n\tif (!pname)\n\t\treturn -ENOMEM;\n\n\tret = avs_hda_platform_register(adev, pname);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmach.pdata = codec;\n\tmach.mach_params.platform = pname;\n\tmach.tplg_filename = devm_kasprintf(adev->dev, GFP_KERNEL, \"hda-%08x-tplg.bin\",\n\t\t\t\t\t    hdev->vendor_id);\n\tif (!mach.tplg_filename)\n\t\treturn -ENOMEM;\n\n\tid = adev->base.core.idx * HDA_MAX_CODECS + hdev->addr;\n\tboard = platform_device_register_data(NULL, \"avs_hdaudio\", id, (const void *)&mach,\n\t\t\t\t\t      sizeof(mach));\n\tif (IS_ERR(board)) {\n\t\tdev_err(adev->dev, \"hda board register failed\\n\");\n\t\treturn PTR_ERR(board);\n\t}\n\n\tret = devm_add_action(adev->dev, board_pdev_unregister, board);\n\tif (ret < 0) {\n\t\tplatform_device_unregister(board);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_register_hda_boards(struct avs_dev *adev)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct hdac_device *hdev;\n\tint ret;\n\n\tif (!bus->num_codecs) {\n\t\tdev_dbg(adev->dev, \"no HDA endpoints present\\n\");\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(hdev, &bus->codec_list, list) {\n\t\tstruct hda_codec *codec;\n\n\t\tcodec = dev_to_hda_codec(&hdev->dev);\n\n\t\tret = avs_register_hda_board(adev, codec);\n\t\tif (ret < 0)\n\t\t\tdev_warn(adev->dev, \"register hda-%08x failed: %d\\n\",\n\t\t\t\t codec->core.vendor_id, ret);\n\t}\n\n\treturn 0;\n}\n\nint avs_register_all_boards(struct avs_dev *adev)\n{\n\tint ret;\n\n#ifdef CONFIG_DEBUG_FS\n\tret = avs_register_probe_board(adev);\n\tif (ret < 0)\n\t\tdev_warn(adev->dev, \"enumerate PROBE endpoints failed: %d\\n\", ret);\n#endif\n\n\tret = avs_register_dmic_board(adev);\n\tif (ret < 0)\n\t\tdev_warn(adev->dev, \"enumerate DMIC endpoints failed: %d\\n\",\n\t\t\t ret);\n\n\tret = avs_register_i2s_boards(adev);\n\tif (ret < 0)\n\t\tdev_warn(adev->dev, \"enumerate I2S endpoints failed: %d\\n\",\n\t\t\t ret);\n\n\tret = avs_register_hda_boards(adev);\n\tif (ret < 0)\n\t\tdev_warn(adev->dev, \"enumerate HDA endpoints failed: %d\\n\",\n\t\t\t ret);\n\n\treturn 0;\n}\n\nvoid avs_unregister_all_boards(struct avs_dev *adev)\n{\n\tsnd_soc_unregister_component(adev->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}