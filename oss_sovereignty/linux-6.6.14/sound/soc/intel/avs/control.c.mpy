{
  "module_name": "control.c",
  "hash_id": "8d2b66f18b23ff2c44457d8681516b0df8eb500643624e10ff1d76bf9956d7c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/control.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/soc.h>\n#include \"avs.h\"\n#include \"control.h\"\n#include \"messages.h\"\n#include \"path.h\"\n\nstatic struct avs_dev *avs_get_kcontrol_adev(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tw = snd_soc_dapm_kcontrol_widget(kcontrol);\n\n\treturn to_avs_dev(w->dapm->component->dev);\n}\n\nstatic struct avs_path_module *avs_get_volume_module(struct avs_dev *adev, u32 id)\n{\n\tstruct avs_path *path;\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_path_module *mod;\n\n\tspin_lock(&adev->path_list_lock);\n\tlist_for_each_entry(path, &adev->path_list, node) {\n\t\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\t\tlist_for_each_entry(mod, &ppl->mod_list, node) {\n\t\t\t\tif (guid_equal(&mod->template->cfg_ext->type, &AVS_PEAKVOL_MOD_UUID)\n\t\t\t\t    && mod->template->ctl_id == id) {\n\t\t\t\t\tspin_unlock(&adev->path_list_lock);\n\t\t\t\t\treturn mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&adev->path_list_lock);\n\n\treturn NULL;\n}\n\nint avs_control_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct avs_control_data *ctl_data = (struct avs_control_data *)mc->dobj.private;\n\tstruct avs_dev *adev = avs_get_kcontrol_adev(kcontrol);\n\tstruct avs_volume_cfg *dspvols = NULL;\n\tstruct avs_path_module *active_module;\n\tsize_t num_dspvols;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&adev->path_mutex);\n\n\tactive_module = avs_get_volume_module(adev, ctl_data->id);\n\tif (active_module) {\n\t\tret = avs_ipc_peakvol_get_volume(adev, active_module->module_id,\n\t\t\t\t\t\t active_module->instance_id, &dspvols,\n\t\t\t\t\t\t &num_dspvols);\n\t\tif (!ret)\n\t\t\tucontrol->value.integer.value[0] = dspvols[0].target_volume;\n\n\t\tret = AVS_IPC_RET(ret);\n\t\tkfree(dspvols);\n\t} else {\n\t\tucontrol->value.integer.value[0] = ctl_data->volume;\n\t}\n\n\tmutex_unlock(&adev->path_mutex);\n\treturn ret;\n}\n\nint avs_control_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct avs_control_data *ctl_data = (struct avs_control_data *)mc->dobj.private;\n\tstruct avs_dev *adev = avs_get_kcontrol_adev(kcontrol);\n\tlong *volume = &ctl_data->volume;\n\tstruct avs_path_module *active_module;\n\tstruct avs_volume_cfg dspvol = {0};\n\tlong ctlvol = ucontrol->value.integer.value[0];\n\tint ret = 0, changed = 0;\n\n\tif (ctlvol < 0 || ctlvol > mc->max)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&adev->path_mutex);\n\n\tif (*volume != ctlvol) {\n\t\t*volume = ctlvol;\n\t\tchanged = 1;\n\t}\n\n\tactive_module = avs_get_volume_module(adev, ctl_data->id);\n\tif (active_module) {\n\t\tdspvol.channel_id = AVS_ALL_CHANNELS_MASK;\n\t\tdspvol.target_volume = *volume;\n\n\t\tret = avs_ipc_peakvol_set_volume(adev, active_module->module_id,\n\t\t\t\t\t\t active_module->instance_id, &dspvol);\n\t\tret = AVS_IPC_RET(ret);\n\t}\n\n\tmutex_unlock(&adev->path_mutex);\n\n\treturn ret ? ret : changed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}