{
  "module_name": "core.c",
  "hash_id": "cfebcca8f580ea7be22f6d0baeb8975f212ea812c9c0e1661fdbcc12147fdfee",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_i915.h>\n#include <sound/hda_register.h>\n#include <sound/hdaudio.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/intel-dsp-config.h>\n#include <sound/intel-nhlt.h>\n#include \"../../codecs/hda.h\"\n#include \"avs.h\"\n#include \"cldma.h\"\n\nstatic u32 pgctl_mask = AZX_PGCTL_LSRMD_MASK;\nmodule_param(pgctl_mask, uint, 0444);\nMODULE_PARM_DESC(pgctl_mask, \"PCI PGCTL policy override\");\n\nstatic u32 cgctl_mask = AZX_CGCTL_MISCBDCGE_MASK;\nmodule_param(cgctl_mask, uint, 0444);\nMODULE_PARM_DESC(cgctl_mask, \"PCI CGCTL policy override\");\n\nstatic void\navs_hda_update_config_dword(struct hdac_bus *bus, u32 reg, u32 mask, u32 value)\n{\n\tstruct pci_dev *pci = to_pci_dev(bus->dev);\n\tu32 data;\n\n\tpci_read_config_dword(pci, reg, &data);\n\tdata &= ~mask;\n\tdata |= (value & mask);\n\tpci_write_config_dword(pci, reg, data);\n}\n\nvoid avs_hda_power_gating_enable(struct avs_dev *adev, bool enable)\n{\n\tu32 value = enable ? 0 : pgctl_mask;\n\n\tavs_hda_update_config_dword(&adev->base.core, AZX_PCIREG_PGCTL, pgctl_mask, value);\n}\n\nstatic void avs_hdac_clock_gating_enable(struct hdac_bus *bus, bool enable)\n{\n\tu32 value = enable ? cgctl_mask : 0;\n\n\tavs_hda_update_config_dword(bus, AZX_PCIREG_CGCTL, cgctl_mask, value);\n}\n\nvoid avs_hda_clock_gating_enable(struct avs_dev *adev, bool enable)\n{\n\tavs_hdac_clock_gating_enable(&adev->base.core, enable);\n}\n\nvoid avs_hda_l1sen_enable(struct avs_dev *adev, bool enable)\n{\n\tu32 value = enable ? AZX_VS_EM2_L1SEN : 0;\n\n\tsnd_hdac_chip_updatel(&adev->base.core, VS_EM2, AZX_VS_EM2_L1SEN, value);\n}\n\nstatic int avs_hdac_bus_init_streams(struct hdac_bus *bus)\n{\n\tunsigned int cp_streams, pb_streams;\n\tunsigned int gcap;\n\n\tgcap = snd_hdac_chip_readw(bus, GCAP);\n\tcp_streams = (gcap >> 8) & 0x0F;\n\tpb_streams = (gcap >> 12) & 0x0F;\n\tbus->num_streams = cp_streams + pb_streams;\n\n\tsnd_hdac_ext_stream_init_all(bus, 0, cp_streams, SNDRV_PCM_STREAM_CAPTURE);\n\tsnd_hdac_ext_stream_init_all(bus, cp_streams, pb_streams, SNDRV_PCM_STREAM_PLAYBACK);\n\n\treturn snd_hdac_bus_alloc_stream_pages(bus);\n}\n\nstatic bool avs_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)\n{\n\tstruct hdac_ext_link *hlink;\n\tbool ret;\n\n\tavs_hdac_clock_gating_enable(bus, false);\n\tret = snd_hdac_bus_init_chip(bus, full_reset);\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\twritel(0, hlink->ml_addr + AZX_REG_ML_LOSIDV);\n\n\tavs_hdac_clock_gating_enable(bus, true);\n\n\t \n\tsnd_hdac_chip_updatel(bus, VS_EM2, AZX_VS_EM2_DUM, AZX_VS_EM2_DUM);\n\n\treturn ret;\n}\n\nstatic int probe_codec(struct hdac_bus *bus, int addr)\n{\n\tstruct hda_codec *codec;\n\tunsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |\n\t\t\t   (AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;\n\tunsigned int res = -1;\n\tint ret;\n\n\tmutex_lock(&bus->cmd_mutex);\n\tsnd_hdac_bus_send_cmd(bus, cmd);\n\tsnd_hdac_bus_get_response(bus, addr, &res);\n\tmutex_unlock(&bus->cmd_mutex);\n\tif (res == -1)\n\t\treturn -EIO;\n\n\tdev_dbg(bus->dev, \"codec #%d probed OK: 0x%x\\n\", addr, res);\n\n\tcodec = snd_hda_codec_device_init(to_hda_bus(bus), addr, \"hdaudioB%dD%d\", bus->idx, addr);\n\tif (IS_ERR(codec)) {\n\t\tdev_err(bus->dev, \"init codec failed: %ld\\n\", PTR_ERR(codec));\n\t\treturn PTR_ERR(codec);\n\t}\n\t \n\tpm_runtime_set_suspended(hda_codec_dev(codec));\n\n\t \n\tret = snd_hda_codec_configure(codec);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"failed to config codec %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void avs_hdac_bus_probe_codecs(struct hdac_bus *bus)\n{\n\tint c;\n\n\t \n\tfor (c = 0; c < HDA_MAX_CODECS; c++) {\n\t\tif (!(bus->codec_mask & BIT(c)))\n\t\t\tcontinue;\n\n\t\tif (!probe_codec(bus, c))\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tdev_warn(bus->dev, \"Codec #%d probe error; disabling it...\\n\", c);\n\t\tbus->codec_mask &= ~BIT(c);\n\t\t \n\t\tsnd_hdac_bus_stop_chip(bus);\n\t\tavs_hdac_bus_init_chip(bus, true);\n\t}\n}\n\nstatic void avs_hda_probe_work(struct work_struct *work)\n{\n\tstruct avs_dev *adev = container_of(work, struct avs_dev, probe_work);\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\tpm_runtime_set_active(bus->dev);  \n\n\tret = snd_hdac_i915_init(bus);\n\tif (ret < 0)\n\t\tdev_info(bus->dev, \"i915 init unsuccessful: %d\\n\", ret);\n\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, true);\n\tavs_hdac_bus_init_chip(bus, true);\n\tavs_hdac_bus_probe_codecs(bus);\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\n\tsnd_hdac_ext_bus_ppcap_enable(bus, true);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, true);\n\n\tret = avs_dsp_first_boot_firmware(adev);\n\tif (ret < 0)\n\t\treturn;\n\n\tadev->nhlt = intel_nhlt_init(adev->dev);\n\tif (!adev->nhlt)\n\t\tdev_info(bus->dev, \"platform has no NHLT\\n\");\n\tavs_debugfs_init(adev);\n\n\tavs_register_all_boards(adev);\n\n\t \n\tpm_runtime_set_autosuspend_delay(bus->dev, 2000);\n\tpm_runtime_use_autosuspend(bus->dev);\n\tpm_runtime_mark_last_busy(bus->dev);\n\tpm_runtime_put_autosuspend(bus->dev);\n\tpm_runtime_allow(bus->dev);\n}\n\nstatic void hdac_stream_update_pos(struct hdac_stream *stream, u64 buffer_size)\n{\n\tu64 prev_pos, pos, num_bytes;\n\n\tdiv64_u64_rem(stream->curr_pos, buffer_size, &prev_pos);\n\tpos = snd_hdac_stream_get_pos_posbuf(stream);\n\n\tif (pos < prev_pos)\n\t\tnum_bytes = (buffer_size - prev_pos) +  pos;\n\telse\n\t\tnum_bytes = pos - prev_pos;\n\n\tstream->curr_pos += num_bytes;\n}\n\n \nstatic void hdac_update_stream(struct hdac_bus *bus, struct hdac_stream *stream)\n{\n\tif (stream->substream) {\n\t\tsnd_pcm_period_elapsed(stream->substream);\n\t} else if (stream->cstream) {\n\t\tu64 buffer_size = stream->cstream->runtime->buffer_size;\n\n\t\thdac_stream_update_pos(stream, buffer_size);\n\t\tsnd_compr_fragment_elapsed(stream->cstream);\n\t}\n}\n\nstatic irqreturn_t hdac_bus_irq_handler(int irq, void *context)\n{\n\tstruct hdac_bus *bus = context;\n\tu32 mask, int_enable;\n\tu32 status;\n\tint ret = IRQ_NONE;\n\n\tif (!pm_runtime_active(bus->dev))\n\t\treturn ret;\n\n\tspin_lock(&bus->reg_lock);\n\n\tstatus = snd_hdac_chip_readl(bus, INTSTS);\n\tif (status == 0 || status == UINT_MAX) {\n\t\tspin_unlock(&bus->reg_lock);\n\t\treturn ret;\n\t}\n\n\t \n\tstatus = snd_hdac_chip_readb(bus, RIRBSTS);\n\tif (status & RIRB_INT_MASK) {\n\t\tif (status & RIRB_INT_RESPONSE)\n\t\t\tsnd_hdac_bus_update_rirb(bus);\n\t\tsnd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);\n\t}\n\n\tmask = (0x1 << bus->num_streams) - 1;\n\n\tstatus = snd_hdac_chip_readl(bus, INTSTS);\n\tstatus &= mask;\n\tif (status) {\n\t\t \n\t\tint_enable = snd_hdac_chip_readl(bus, INTCTL);\n\t\tsnd_hdac_chip_writel(bus, INTCTL, (int_enable & (~mask)));\n\t\tret = IRQ_WAKE_THREAD;\n\t} else {\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&bus->reg_lock);\n\treturn ret;\n}\n\nstatic irqreturn_t hdac_bus_irq_thread(int irq, void *context)\n{\n\tstruct hdac_bus *bus = context;\n\tu32 status;\n\tu32 int_enable;\n\tu32 mask;\n\tunsigned long flags;\n\n\tstatus = snd_hdac_chip_readl(bus, INTSTS);\n\n\tsnd_hdac_bus_handle_stream_irq(bus, status, hdac_update_stream);\n\n\t \n\tmask = (0x1 << bus->num_streams) - 1;\n\tspin_lock_irqsave(&bus->reg_lock, flags);\n\tint_enable = snd_hdac_chip_readl(bus, INTCTL);\n\tsnd_hdac_chip_writel(bus, INTCTL, (int_enable | mask));\n\tspin_unlock_irqrestore(&bus->reg_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int avs_hdac_acquire_irq(struct avs_dev *adev)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct pci_dev *pci = to_pci_dev(bus->dev);\n\tint ret;\n\n\t \n\tret = pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_MSI | PCI_IRQ_LEGACY);\n\tif (ret != 1) {\n\t\tdev_err(adev->dev, \"Failed to allocate IRQ vector: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_request_irq(pci, 0, hdac_bus_irq_handler, hdac_bus_irq_thread, bus,\n\t\t\t      KBUILD_MODNAME);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"Failed to request stream IRQ handler: %d\\n\", ret);\n\t\tgoto free_vector;\n\t}\n\n\tret = pci_request_irq(pci, 0, avs_dsp_irq_handler, avs_dsp_irq_thread, adev,\n\t\t\t      KBUILD_MODNAME);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"Failed to request IPC IRQ handler: %d\\n\", ret);\n\t\tgoto free_stream_irq;\n\t}\n\n\treturn 0;\n\nfree_stream_irq:\n\tpci_free_irq(pci, 0, bus);\nfree_vector:\n\tpci_free_irq_vectors(pci);\n\treturn ret;\n}\n\nstatic int avs_bus_init(struct avs_dev *adev, struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct hda_bus *bus = &adev->base;\n\tstruct avs_ipc *ipc;\n\tstruct device *dev = &pci->dev;\n\tint ret;\n\n\tret = snd_hdac_ext_bus_init(&bus->core, dev, NULL, &soc_hda_ext_bus_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbus->core.use_posbuf = 1;\n\tbus->core.bdl_pos_adj = 0;\n\tbus->core.sync_write = 1;\n\tbus->pci = pci;\n\tbus->mixer_assigned = -1;\n\tmutex_init(&bus->prepare_mutex);\n\n\tipc = devm_kzalloc(dev, sizeof(*ipc), GFP_KERNEL);\n\tif (!ipc)\n\t\treturn -ENOMEM;\n\tret = avs_ipc_init(ipc, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadev->dev = dev;\n\tadev->spec = (const struct avs_spec *)id->driver_data;\n\tadev->ipc = ipc;\n\tadev->hw_cfg.dsp_cores = hweight_long(AVS_MAIN_CORE_MASK);\n\tINIT_WORK(&adev->probe_work, avs_hda_probe_work);\n\tINIT_LIST_HEAD(&adev->comp_list);\n\tINIT_LIST_HEAD(&adev->path_list);\n\tINIT_LIST_HEAD(&adev->fw_list);\n\tinit_completion(&adev->fw_ready);\n\tspin_lock_init(&adev->path_list_lock);\n\tmutex_init(&adev->modres_mutex);\n\tmutex_init(&adev->comp_list_mutex);\n\tmutex_init(&adev->path_mutex);\n\n\treturn 0;\n}\n\nstatic int avs_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct hdac_bus *bus;\n\tstruct avs_dev *adev;\n\tstruct device *dev = &pci->dev;\n\tint ret;\n\n\tret = snd_intel_dsp_driver_probe(pci);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_AVS)\n\t\treturn -ENODEV;\n\n\tret = pcim_enable_device(pci);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadev = devm_kzalloc(dev, sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\treturn -ENOMEM;\n\tret = avs_bus_init(adev, pci, id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to init avs bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_request_regions(pci, \"AVS HDAudio\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbus = &adev->base.core;\n\tbus->addr = pci_resource_start(pci, 0);\n\tbus->remap_addr = pci_ioremap_bar(pci, 0);\n\tif (!bus->remap_addr) {\n\t\tdev_err(bus->dev, \"ioremap error\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_remap_bar0;\n\t}\n\n\tadev->dsp_ba = pci_ioremap_bar(pci, 4);\n\tif (!adev->dsp_ba) {\n\t\tdev_err(bus->dev, \"ioremap error\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_remap_bar4;\n\t}\n\n\tsnd_hdac_bus_parse_capabilities(bus);\n\tif (bus->mlcap)\n\t\tsnd_hdac_ext_bus_get_ml_capabilities(bus);\n\n\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)))\n\t\tdma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tdma_set_max_seg_size(dev, UINT_MAX);\n\n\tret = avs_hdac_bus_init_streams(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to init streams: %d\\n\", ret);\n\t\tgoto err_init_streams;\n\t}\n\n\tret = avs_hdac_acquire_irq(adev);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"failed to acquire irq: %d\\n\", ret);\n\t\tgoto err_acquire_irq;\n\t}\n\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, bus);\n\tdevice_disable_async_suspend(dev);\n\n\tschedule_work(&adev->probe_work);\n\n\treturn 0;\n\nerr_acquire_irq:\n\tsnd_hdac_bus_free_stream_pages(bus);\n\tsnd_hdac_ext_stream_free_all(bus);\nerr_init_streams:\n\tiounmap(adev->dsp_ba);\nerr_remap_bar4:\n\tiounmap(bus->remap_addr);\nerr_remap_bar0:\n\tpci_release_regions(pci);\n\treturn ret;\n}\n\nstatic void avs_pci_shutdown(struct pci_dev *pci)\n{\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct avs_dev *adev = hdac_to_avs(bus);\n\n\tcancel_work_sync(&adev->probe_work);\n\tavs_ipc_block(adev->ipc);\n\n\tsnd_hdac_stop_streams(bus);\n\tavs_dsp_op(adev, int_control, false);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, false);\n\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\n\tsnd_hdac_bus_stop_chip(bus);\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\n\tif (avs_platattr_test(adev, CLDMA))\n\t\tpci_free_irq(pci, 0, &code_loader);\n\tpci_free_irq(pci, 0, adev);\n\tpci_free_irq(pci, 0, bus);\n\tpci_free_irq_vectors(pci);\n}\n\nstatic void avs_pci_remove(struct pci_dev *pci)\n{\n\tstruct hdac_device *hdev, *save;\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct avs_dev *adev = hdac_to_avs(bus);\n\n\tcancel_work_sync(&adev->probe_work);\n\tavs_ipc_block(adev->ipc);\n\n\tavs_unregister_all_boards(adev);\n\n\tavs_debugfs_exit(adev);\n\tif (adev->nhlt)\n\t\tintel_nhlt_free(adev->nhlt);\n\n\tif (avs_platattr_test(adev, CLDMA))\n\t\thda_cldma_free(&code_loader);\n\n\tsnd_hdac_stop_streams_and_chip(bus);\n\tavs_dsp_op(adev, int_control, false);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, false);\n\n\t \n\tlist_for_each_entry_safe(hdev, save, &bus->codec_list, list)\n\t\tsnd_hda_codec_unregister(hdac_to_hda_codec(hdev));\n\n\tsnd_hdac_bus_free_stream_pages(bus);\n\tsnd_hdac_ext_stream_free_all(bus);\n\t \n\tsnd_hdac_ext_link_free_all(bus);\n\tsnd_hdac_ext_bus_exit(bus);\n\n\tavs_dsp_core_disable(adev, GENMASK(adev->hw_cfg.dsp_cores - 1, 0));\n\tsnd_hdac_ext_bus_ppcap_enable(bus, false);\n\n\t \n\tsnd_hdac_bus_stop_chip(bus);\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\tif (bus->audio_component)\n\t\tsnd_hdac_i915_exit(bus);\n\n\tavs_module_info_free(adev);\n\tpci_free_irq(pci, 0, adev);\n\tpci_free_irq(pci, 0, bus);\n\tpci_free_irq_vectors(pci);\n\tiounmap(bus->remap_addr);\n\tiounmap(adev->dsp_ba);\n\tpci_release_regions(pci);\n\n\t \n\tavs_release_firmwares(adev);\n\n\t \n\tpm_runtime_disable(&pci->dev);\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_enable(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n}\n\nstatic int avs_suspend_standby(struct avs_dev *adev)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct pci_dev *pci = adev->base.pci;\n\n\tif (bus->cmd_dma_state)\n\t\tsnd_hdac_bus_stop_cmd_io(bus);\n\n\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\n\tenable_irq_wake(pci->irq);\n\tpci_save_state(pci);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused avs_suspend_common(struct avs_dev *adev, bool low_power)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tint ret;\n\n\tflush_work(&adev->probe_work);\n\tif (low_power && adev->num_lp_paths)\n\t\treturn avs_suspend_standby(adev);\n\n\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\n\tret = avs_ipc_set_dx(adev, AVS_MAIN_CORE_MASK, false);\n\t \n\tif (ret && ret != -EPERM) {\n\t\tdev_err(adev->dev, \"set dx failed: %d\\n\", ret);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\tavs_ipc_block(adev->ipc);\n\tavs_dsp_op(adev, int_control, false);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, false);\n\n\tret = avs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"core_mask %ld disable failed: %d\\n\", AVS_MAIN_CORE_MASK, ret);\n\t\treturn ret;\n\t}\n\n\tsnd_hdac_ext_bus_ppcap_enable(bus, false);\n\t \n\tavs_hda_power_gating_enable(adev, false);\n\tsnd_hdac_bus_stop_chip(bus);\n\t \n\tavs_hdac_clock_gating_enable(bus, false);\n\tsnd_hdac_bus_enter_link_reset(bus);\n\tavs_hdac_clock_gating_enable(bus, true);\n\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\n\treturn 0;\n}\n\nstatic int avs_resume_standby(struct avs_dev *adev)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct pci_dev *pci = adev->base.pci;\n\n\tpci_restore_state(pci);\n\tdisable_irq_wake(pci->irq);\n\n\tsnd_hdac_ext_bus_link_power_up_all(bus);\n\n\tif (bus->cmd_dma_state)\n\t\tsnd_hdac_bus_init_cmd_io(bus);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused avs_resume_common(struct avs_dev *adev, bool low_power, bool purge)\n{\n\tstruct hdac_bus *bus = &adev->base.core;\n\tint ret;\n\n\tif (low_power && adev->num_lp_paths)\n\t\treturn avs_resume_standby(adev);\n\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, true);\n\tavs_hdac_bus_init_chip(bus, true);\n\n\tsnd_hdac_ext_bus_ppcap_enable(bus, true);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, true);\n\n\tret = avs_dsp_boot_firmware(adev, purge);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"firmware boot failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused avs_suspend(struct device *dev)\n{\n\treturn avs_suspend_common(to_avs_dev(dev), true);\n}\n\nstatic int __maybe_unused avs_resume(struct device *dev)\n{\n\treturn avs_resume_common(to_avs_dev(dev), true, true);\n}\n\nstatic int __maybe_unused avs_runtime_suspend(struct device *dev)\n{\n\treturn avs_suspend_common(to_avs_dev(dev), true);\n}\n\nstatic int __maybe_unused avs_runtime_resume(struct device *dev)\n{\n\treturn avs_resume_common(to_avs_dev(dev), true, false);\n}\n\nstatic int __maybe_unused avs_freeze(struct device *dev)\n{\n\treturn avs_suspend_common(to_avs_dev(dev), false);\n}\nstatic int __maybe_unused avs_thaw(struct device *dev)\n{\n\treturn avs_resume_common(to_avs_dev(dev), false, true);\n}\n\nstatic int __maybe_unused avs_poweroff(struct device *dev)\n{\n\treturn avs_suspend_common(to_avs_dev(dev), false);\n}\n\nstatic int __maybe_unused avs_restore(struct device *dev)\n{\n\treturn avs_resume_common(to_avs_dev(dev), false, true);\n}\n\nstatic const struct dev_pm_ops avs_dev_pm = {\n\t.suspend = avs_suspend,\n\t.resume = avs_resume,\n\t.freeze = avs_freeze,\n\t.thaw = avs_thaw,\n\t.poweroff = avs_poweroff,\n\t.restore = avs_restore,\n\tSET_RUNTIME_PM_OPS(avs_runtime_suspend, avs_runtime_resume, NULL)\n};\n\nstatic const struct avs_spec skl_desc = {\n\t.name = \"skl\",\n\t.min_fw_version = {\n\t\t.major = 9,\n\t\t.minor = 21,\n\t\t.hotfix = 0,\n\t\t.build = 4732,\n\t},\n\t.dsp_ops = &skl_dsp_ops,\n\t.core_init_mask = 1,\n\t.attributes = AVS_PLATATTR_CLDMA,\n\t.sram_base_offset = SKL_ADSP_SRAM_BASE_OFFSET,\n\t.sram_window_size = SKL_ADSP_SRAM_WINDOW_SIZE,\n\t.rom_status = SKL_ADSP_SRAM_BASE_OFFSET,\n};\n\nstatic const struct avs_spec apl_desc = {\n\t.name = \"apl\",\n\t.min_fw_version = {\n\t\t.major = 9,\n\t\t.minor = 22,\n\t\t.hotfix = 1,\n\t\t.build = 4323,\n\t},\n\t.dsp_ops = &apl_dsp_ops,\n\t.core_init_mask = 3,\n\t.attributes = AVS_PLATATTR_IMR,\n\t.sram_base_offset = APL_ADSP_SRAM_BASE_OFFSET,\n\t.sram_window_size = APL_ADSP_SRAM_WINDOW_SIZE,\n\t.rom_status = APL_ADSP_SRAM_BASE_OFFSET,\n};\n\nstatic const struct pci_device_id avs_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, HDA_SKL_LP, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_SKL, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL_LP, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL_H, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_S, &skl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_APL, &apl_desc) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_GML, &apl_desc) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, avs_ids);\n\nstatic struct pci_driver avs_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = avs_ids,\n\t.probe = avs_pci_probe,\n\t.remove = avs_pci_remove,\n\t.shutdown = avs_pci_shutdown,\n\t.driver = {\n\t\t.pm = &avs_dev_pm,\n\t},\n};\nmodule_pci_driver(avs_pci_driver);\n\nMODULE_AUTHOR(\"Cezary Rojewski <cezary.rojewski@intel.com>\");\nMODULE_AUTHOR(\"Amadeusz Slawinski <amadeuszx.slawinski@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel cAVS sound driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}