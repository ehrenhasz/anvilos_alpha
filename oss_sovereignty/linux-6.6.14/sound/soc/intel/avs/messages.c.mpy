{
  "module_name": "messages.c",
  "hash_id": "c193d1bab2b2afe968410f600a86fa145dac6a27e9060db5a4f70c8fa8200905",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/messages.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/slab.h>\n#include \"avs.h\"\n#include \"messages.h\"\n\n#define AVS_CL_TIMEOUT_MS\t5000\n\nint avs_ipc_set_boot_config(struct avs_dev *adev, u32 dma_id, u32 purge)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(ROM_CONTROL);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.boot_cfg.rom_ctrl_msg_type = AVS_ROM_SET_BOOT_CONFIG;\n\tmsg.boot_cfg.dma_id = dma_id;\n\tmsg.boot_cfg.purge_request = purge;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_rom_msg(adev, &request);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"set boot config\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_load_modules(struct avs_dev *adev, u16 *mod_ids, u32 num_mod_ids)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(LOAD_MULTIPLE_MODULES);\n\tstruct avs_ipc_msg request;\n\tint ret;\n\n\tmsg.load_multi_mods.mod_cnt = num_mod_ids;\n\trequest.header = msg.val;\n\trequest.data = mod_ids;\n\trequest.size = sizeof(*mod_ids) * num_mod_ids;\n\n\tret = avs_dsp_send_msg_timeout(adev, &request, NULL, AVS_CL_TIMEOUT_MS);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"load multiple modules\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_unload_modules(struct avs_dev *adev, u16 *mod_ids, u32 num_mod_ids)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(UNLOAD_MULTIPLE_MODULES);\n\tstruct avs_ipc_msg request;\n\tint ret;\n\n\tmsg.load_multi_mods.mod_cnt = num_mod_ids;\n\trequest.header = msg.val;\n\trequest.data = mod_ids;\n\trequest.size = sizeof(*mod_ids) * num_mod_ids;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"unload multiple modules\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_load_library(struct avs_dev *adev, u32 dma_id, u32 lib_id)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(LOAD_LIBRARY);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.load_lib.dma_id = dma_id;\n\tmsg.load_lib.lib_id = lib_id;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg_timeout(adev, &request, NULL, AVS_CL_TIMEOUT_MS);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"load library\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_create_pipeline(struct avs_dev *adev, u16 req_size, u8 priority,\n\t\t\t    u8 instance_id, bool lp, u16 attributes)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(CREATE_PIPELINE);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.create_ppl.ppl_mem_size = req_size;\n\tmsg.create_ppl.ppl_priority = priority;\n\tmsg.create_ppl.instance_id = instance_id;\n\tmsg.ext.create_ppl.lp = lp;\n\tmsg.ext.create_ppl.attributes = attributes;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"create pipeline\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_delete_pipeline(struct avs_dev *adev, u8 instance_id)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(DELETE_PIPELINE);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.ppl.instance_id = instance_id;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"delete pipeline\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_set_pipeline_state(struct avs_dev *adev, u8 instance_id,\n\t\t\t       enum avs_pipeline_state state)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(SET_PIPELINE_STATE);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.set_ppl_state.ppl_id = instance_id;\n\tmsg.set_ppl_state.state = state;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"set pipeline state\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_get_pipeline_state(struct avs_dev *adev, u8 instance_id,\n\t\t\t       enum avs_pipeline_state *state)\n{\n\tunion avs_global_msg msg = AVS_GLOBAL_REQUEST(GET_PIPELINE_STATE);\n\tstruct avs_ipc_msg request = {{0}};\n\tstruct avs_ipc_msg reply = {{0}};\n\tint ret;\n\n\tmsg.get_ppl_state.ppl_id = instance_id;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, &reply);\n\tif (ret) {\n\t\tavs_ipc_err(adev, &request, \"get pipeline state\", ret);\n\t\treturn ret;\n\t}\n\n\t*state = reply.rsp.ext.get_ppl_state.state;\n\treturn ret;\n}\n\n \nint avs_ipc_init_instance(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t  u8 ppl_id, u8 core_id, u8 domain,\n\t\t\t  void *param, u32 param_size)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(INIT_INSTANCE);\n\tstruct avs_ipc_msg request;\n\tint ret;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\t \n\tmsg.ext.init_instance.param_block_size = DIV_ROUND_UP(param_size, sizeof(u32));\n\tmsg.ext.init_instance.ppl_instance_id = ppl_id;\n\tmsg.ext.init_instance.core_id = core_id;\n\tmsg.ext.init_instance.proc_domain = domain;\n\n\trequest.header = msg.val;\n\trequest.data = param;\n\trequest.size = param_size;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"init instance\", ret);\n\n\treturn ret;\n}\n\n \nint avs_ipc_delete_instance(struct avs_dev *adev, u16 module_id, u8 instance_id)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(DELETE_INSTANCE);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"delete instance\", ret);\n\n\treturn ret;\n}\n\n \nint avs_ipc_bind(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t u16 dst_module_id, u8 dst_instance_id,\n\t\t u8 dst_queue, u8 src_queue)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(BIND);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\tmsg.ext.bind_unbind.dst_module_id = dst_module_id;\n\tmsg.ext.bind_unbind.dst_instance_id = dst_instance_id;\n\tmsg.ext.bind_unbind.dst_queue = dst_queue;\n\tmsg.ext.bind_unbind.src_queue = src_queue;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"bind modules\", ret);\n\n\treturn ret;\n}\n\n \nint avs_ipc_unbind(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t   u16 dst_module_id, u8 dst_instance_id,\n\t\t   u8 dst_queue, u8 src_queue)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(UNBIND);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\tmsg.ext.bind_unbind.dst_module_id = dst_module_id;\n\tmsg.ext.bind_unbind.dst_instance_id = dst_instance_id;\n\tmsg.ext.bind_unbind.dst_queue = dst_queue;\n\tmsg.ext.bind_unbind.src_queue = src_queue;\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"unbind modules\", ret);\n\n\treturn ret;\n}\n\nstatic int __avs_ipc_set_large_config(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t\t      u8 param_id, bool init_block, bool final_block,\n\t\t\t\t      u8 *request_data, size_t request_size, size_t off_size)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(LARGE_CONFIG_SET);\n\tstruct avs_ipc_msg request;\n\tint ret;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\tmsg.ext.large_config.data_off_size = off_size;\n\tmsg.ext.large_config.large_param_id = param_id;\n\tmsg.ext.large_config.final_block = final_block;\n\tmsg.ext.large_config.init_block = init_block;\n\n\trequest.header = msg.val;\n\trequest.data = request_data;\n\trequest.size = request_size;\n\n\tret = avs_dsp_send_msg(adev, &request, NULL);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"large config set\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_set_large_config(struct avs_dev *adev, u16 module_id,\n\t\t\t     u8 instance_id, u8 param_id,\n\t\t\t     u8 *request, size_t request_size)\n{\n\tsize_t remaining, tx_size;\n\tbool final;\n\tint ret;\n\n\tremaining = request_size;\n\ttx_size = min_t(size_t, AVS_MAILBOX_SIZE, remaining);\n\tfinal = (tx_size == remaining);\n\n\t \n\tret = __avs_ipc_set_large_config(adev, module_id, instance_id,\n\t\t\t\t\t param_id, 1, final, request, tx_size,\n\t\t\t\t\t request_size);\n\tif (ret)\n\t\treturn ret;\n\n\tremaining -= tx_size;\n\n\t \n\twhile (remaining) {\n\t\tsize_t offset;\n\n\t\toffset = request_size - remaining;\n\t\ttx_size = min_t(size_t, AVS_MAILBOX_SIZE, remaining);\n\t\tfinal = (tx_size == remaining);\n\n\t\tret = __avs_ipc_set_large_config(adev, module_id, instance_id,\n\t\t\t\t\t\t param_id, 0, final,\n\t\t\t\t\t\t request + offset, tx_size,\n\t\t\t\t\t\t offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tremaining -= tx_size;\n\t}\n\n\treturn 0;\n}\n\nint avs_ipc_get_large_config(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t     u8 param_id, u8 *request_data, size_t request_size,\n\t\t\t     u8 **reply_data, size_t *reply_size)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(LARGE_CONFIG_GET);\n\tstruct avs_ipc_msg request;\n\tstruct avs_ipc_msg reply = {{0}};\n\tvoid *buf;\n\tint ret;\n\n\treply.data = kzalloc(AVS_MAILBOX_SIZE, GFP_KERNEL);\n\tif (!reply.data)\n\t\treturn -ENOMEM;\n\n\tmsg.module_id = module_id;\n\tmsg.instance_id = instance_id;\n\tmsg.ext.large_config.data_off_size = request_size;\n\tmsg.ext.large_config.large_param_id = param_id;\n\t \n\tmsg.ext.large_config.final_block = 0;\n\tmsg.ext.large_config.init_block = 1;\n\n\trequest.header = msg.val;\n\trequest.data = request_data;\n\trequest.size = request_size;\n\treply.size = AVS_MAILBOX_SIZE;\n\n\tret = avs_dsp_send_msg(adev, &request, &reply);\n\tif (ret) {\n\t\tavs_ipc_err(adev, &request, \"large config get\", ret);\n\t\tkfree(reply.data);\n\t\treturn ret;\n\t}\n\n\tbuf = krealloc(reply.data, reply.size, GFP_KERNEL);\n\tif (!buf) {\n\t\tkfree(reply.data);\n\t\treturn -ENOMEM;\n\t}\n\n\t*reply_data = buf;\n\t*reply_size = reply.size;\n\n\treturn 0;\n}\n\nint avs_ipc_set_dx(struct avs_dev *adev, u32 core_mask, bool powerup)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(SET_DX);\n\tstruct avs_ipc_msg request;\n\tstruct avs_dxstate_info dx;\n\tint ret;\n\n\tdx.core_mask = core_mask;\n\tdx.dx_mask = powerup ? core_mask : 0;\n\trequest.header = msg.val;\n\trequest.data = &dx;\n\trequest.size = sizeof(dx);\n\n\tret = avs_dsp_send_pm_msg(adev, &request, NULL, true);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"set dx\", ret);\n\n\treturn ret;\n}\n\n \nint avs_ipc_set_d0ix(struct avs_dev *adev, bool enable_pg, bool streaming)\n{\n\tunion avs_module_msg msg = AVS_MODULE_REQUEST(SET_D0IX);\n\tstruct avs_ipc_msg request = {{0}};\n\tint ret;\n\n\tmsg.ext.set_d0ix.wake = enable_pg;\n\tmsg.ext.set_d0ix.streaming = streaming;\n\n\trequest.header = msg.val;\n\n\tret = avs_dsp_send_pm_msg(adev, &request, NULL, false);\n\tif (ret)\n\t\tavs_ipc_err(adev, &request, \"set d0ix\", ret);\n\n\treturn ret;\n}\n\nint avs_ipc_get_fw_config(struct avs_dev *adev, struct avs_fw_cfg *cfg)\n{\n\tstruct avs_tlv *tlv;\n\tsize_t payload_size;\n\tsize_t offset = 0;\n\tu8 *payload;\n\tint ret;\n\n\tret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,\n\t\t\t\t       AVS_BASEFW_FIRMWARE_CONFIG, NULL, 0,\n\t\t\t\t       &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (!payload_size)\n\t\treturn -EREMOTEIO;\n\n\twhile (offset < payload_size) {\n\t\ttlv = (struct avs_tlv *)(payload + offset);\n\n\t\tswitch (tlv->type) {\n\t\tcase AVS_FW_CFG_FW_VERSION:\n\t\t\tmemcpy(&cfg->fw_version, tlv->value, sizeof(cfg->fw_version));\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MEMORY_RECLAIMED:\n\t\t\tcfg->memory_reclaimed = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_SLOW_CLOCK_FREQ_HZ:\n\t\t\tcfg->slow_clock_freq_hz = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_FAST_CLOCK_FREQ_HZ:\n\t\t\tcfg->fast_clock_freq_hz = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_ALH_SUPPORT_LEVEL:\n\t\t\tcfg->alh_support = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_IPC_DL_MAILBOX_BYTES:\n\t\t\tcfg->ipc_dl_mailbox_bytes = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_IPC_UL_MAILBOX_BYTES:\n\t\t\tcfg->ipc_ul_mailbox_bytes = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_TRACE_LOG_BYTES:\n\t\t\tcfg->trace_log_bytes = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_PPL_COUNT:\n\t\t\tcfg->max_ppl_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_ASTATE_COUNT:\n\t\t\tcfg->max_astate_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_MODULE_PIN_COUNT:\n\t\t\tcfg->max_module_pin_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MODULES_COUNT:\n\t\t\tcfg->modules_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_MOD_INST_COUNT:\n\t\t\tcfg->max_mod_inst_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_LL_TASKS_PER_PRI_COUNT:\n\t\t\tcfg->max_ll_tasks_per_pri_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_LL_PRI_COUNT:\n\t\t\tcfg->ll_pri_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_DP_TASKS_COUNT:\n\t\t\tcfg->max_dp_tasks_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_MAX_LIBS_COUNT:\n\t\t\tcfg->max_libs_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_XTAL_FREQ_HZ:\n\t\t\tcfg->xtal_freq_hz = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_FW_CFG_POWER_GATING_POLICY:\n\t\t\tcfg->power_gating_policy = *tlv->value;\n\t\t\tbreak;\n\n\t\t \n\t\tcase AVS_FW_CFG_DMA_BUFFER_CONFIG:\n\t\tcase AVS_FW_CFG_SCHEDULER_CONFIG:\n\t\tcase AVS_FW_CFG_CLOCKS_CONFIG:\n\t\tcase AVS_FW_CFG_RESERVED:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_info(adev->dev, \"Unrecognized fw param: %d\\n\", tlv->type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += sizeof(*tlv) + tlv->length;\n\t}\n\n\t \n\tkfree(payload);\n\treturn ret;\n}\n\nint avs_ipc_get_hw_config(struct avs_dev *adev, struct avs_hw_cfg *cfg)\n{\n\tstruct avs_tlv *tlv;\n\tsize_t payload_size;\n\tsize_t size, offset = 0;\n\tu8 *payload;\n\tint ret;\n\n\tret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,\n\t\t\t\t       AVS_BASEFW_HARDWARE_CONFIG, NULL, 0,\n\t\t\t\t       &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (!payload_size)\n\t\treturn -EREMOTEIO;\n\n\twhile (offset < payload_size) {\n\t\ttlv = (struct avs_tlv *)(payload + offset);\n\n\t\tswitch (tlv->type) {\n\t\tcase AVS_HW_CFG_AVS_VER:\n\t\t\tcfg->avs_version = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_DSP_CORES:\n\t\t\tcfg->dsp_cores = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_MEM_PAGE_BYTES:\n\t\t\tcfg->mem_page_bytes = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_TOTAL_PHYS_MEM_PAGES:\n\t\t\tcfg->total_phys_mem_pages = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_I2S_CAPS:\n\t\t\tcfg->i2s_caps.i2s_version = tlv->value[0];\n\t\t\tsize = tlv->value[1];\n\t\t\tcfg->i2s_caps.ctrl_count = size;\n\t\t\tif (!size)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tsize *= sizeof(*cfg->i2s_caps.ctrl_base_addr);\n\t\t\tcfg->i2s_caps.ctrl_base_addr = devm_kmemdup(adev->dev,\n\t\t\t\t\t\t\t\t    &tlv->value[2],\n\t\t\t\t\t\t\t\t    size, GFP_KERNEL);\n\t\t\tif (!cfg->i2s_caps.ctrl_base_addr) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_GATEWAY_COUNT:\n\t\t\tcfg->gateway_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_HP_EBB_COUNT:\n\t\t\tcfg->hp_ebb_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_LP_EBB_COUNT:\n\t\t\tcfg->lp_ebb_count = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_EBB_SIZE_BYTES:\n\t\t\tcfg->ebb_size_bytes = *tlv->value;\n\t\t\tbreak;\n\n\t\tcase AVS_HW_CFG_GPDMA_CAPS:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_info(adev->dev, \"Unrecognized hw config: %d\\n\", tlv->type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += sizeof(*tlv) + tlv->length;\n\t}\n\nexit:\n\t \n\tkfree(payload);\n\treturn ret;\n}\n\nint avs_ipc_get_modules_info(struct avs_dev *adev, struct avs_mods_info **info)\n{\n\tsize_t payload_size;\n\tu8 *payload;\n\tint ret;\n\n\tret = avs_ipc_get_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,\n\t\t\t\t       AVS_BASEFW_MODULES_INFO, NULL, 0,\n\t\t\t\t       &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (!payload_size)\n\t\treturn -EREMOTEIO;\n\n\t*info = (struct avs_mods_info *)payload;\n\treturn 0;\n}\n\nint avs_ipc_copier_set_sink_format(struct avs_dev *adev, u16 module_id,\n\t\t\t\t   u8 instance_id, u32 sink_id,\n\t\t\t\t   const struct avs_audio_format *src_fmt,\n\t\t\t\t   const struct avs_audio_format *sink_fmt)\n{\n\tstruct avs_copier_sink_format cpr_fmt;\n\n\tcpr_fmt.sink_id = sink_id;\n\t \n\tcpr_fmt.src_fmt = *src_fmt;\n\tcpr_fmt.sink_fmt = *sink_fmt;\n\n\treturn avs_ipc_set_large_config(adev, module_id, instance_id,\n\t\t\t\t\tAVS_COPIER_SET_SINK_FORMAT,\n\t\t\t\t\t(u8 *)&cpr_fmt, sizeof(cpr_fmt));\n}\n\nint avs_ipc_peakvol_set_volume(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t       struct avs_volume_cfg *vol)\n{\n\treturn avs_ipc_set_large_config(adev, module_id, instance_id, AVS_PEAKVOL_VOLUME, (u8 *)vol,\n\t\t\t\t\tsizeof(*vol));\n}\n\nint avs_ipc_peakvol_get_volume(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t       struct avs_volume_cfg **vols, size_t *num_vols)\n{\n\tsize_t payload_size;\n\tu8 *payload;\n\tint ret;\n\n\tret = avs_ipc_get_large_config(adev, module_id, instance_id, AVS_PEAKVOL_VOLUME, NULL, 0,\n\t\t\t\t       &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!payload_size)\n\t\treturn -EREMOTEIO;\n\n\t*vols = (struct avs_volume_cfg *)payload;\n\t*num_vols = payload_size / sizeof(**vols);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nint avs_ipc_set_enable_logs(struct avs_dev *adev, u8 *log_info, size_t size)\n{\n\treturn avs_ipc_set_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,\n\t\t\t\t\tAVS_BASEFW_ENABLE_LOGS, log_info, size);\n}\n\nint avs_ipc_set_system_time(struct avs_dev *adev)\n{\n\tstruct avs_sys_time sys_time;\n\tu64 us;\n\n\t \n\tus = ktime_to_us(ktime_get());\n\tsys_time.val_l = us & UINT_MAX;\n\tsys_time.val_u = us >> 32;\n\n\treturn avs_ipc_set_large_config(adev, AVS_BASEFW_MOD_ID, AVS_BASEFW_INST_ID,\n\t\t\t\t\tAVS_BASEFW_SYSTEM_TIME, (u8 *)&sys_time, sizeof(sys_time));\n}\n\nint avs_ipc_probe_get_dma(struct avs_dev *adev, struct avs_probe_dma **dmas, size_t *num_dmas)\n{\n\tsize_t payload_size;\n\tu32 module_id;\n\tu8 *payload;\n\tint ret;\n\n\tmodule_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\tret = avs_ipc_get_large_config(adev, module_id, AVS_PROBE_INST_ID, AVS_PROBE_INJECTION_DMA,\n\t\t\t\t       NULL, 0, &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\n\t*dmas = (struct avs_probe_dma *)payload;\n\t*num_dmas = payload_size / sizeof(**dmas);\n\n\treturn 0;\n}\n\nint avs_ipc_probe_attach_dma(struct avs_dev *adev, struct avs_probe_dma *dmas, size_t num_dmas)\n{\n\tu32 module_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\treturn avs_ipc_set_large_config(adev, module_id, AVS_PROBE_INST_ID, AVS_PROBE_INJECTION_DMA,\n\t\t\t\t\t(u8 *)dmas, array_size(sizeof(*dmas), num_dmas));\n}\n\nint avs_ipc_probe_detach_dma(struct avs_dev *adev, union avs_connector_node_id *node_ids,\n\t\t\t     size_t num_node_ids)\n{\n\tu32 module_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\treturn avs_ipc_set_large_config(adev, module_id, AVS_PROBE_INST_ID,\n\t\t\t\t\tAVS_PROBE_INJECTION_DMA_DETACH, (u8 *)node_ids,\n\t\t\t\t\tarray_size(sizeof(*node_ids), num_node_ids));\n}\n\nint avs_ipc_probe_get_points(struct avs_dev *adev, struct avs_probe_point_desc **descs,\n\t\t\t     size_t *num_descs)\n{\n\tsize_t payload_size;\n\tu32 module_id;\n\tu8 *payload;\n\tint ret;\n\n\tmodule_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\tret = avs_ipc_get_large_config(adev, module_id, AVS_PROBE_INST_ID, AVS_PROBE_POINTS, NULL,\n\t\t\t\t       0, &payload, &payload_size);\n\tif (ret)\n\t\treturn ret;\n\n\t*descs = (struct avs_probe_point_desc *)payload;\n\t*num_descs = payload_size / sizeof(**descs);\n\n\treturn 0;\n}\n\nint avs_ipc_probe_connect_points(struct avs_dev *adev, struct avs_probe_point_desc *descs,\n\t\t\t\t size_t num_descs)\n{\n\tu32 module_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\treturn avs_ipc_set_large_config(adev, module_id, AVS_PROBE_INST_ID, AVS_PROBE_POINTS,\n\t\t\t\t\t(u8 *)descs, array_size(sizeof(*descs), num_descs));\n}\n\nint avs_ipc_probe_disconnect_points(struct avs_dev *adev, union avs_probe_point_id *ids,\n\t\t\t\t    size_t num_ids)\n{\n\tu32 module_id = avs_get_module_id(adev, &AVS_PROBE_MOD_UUID);\n\n\treturn avs_ipc_set_large_config(adev, module_id, AVS_PROBE_INST_ID,\n\t\t\t\t\tAVS_PROBE_POINTS_DISCONNECT, (u8 *)ids,\n\t\t\t\t\tarray_size(sizeof(*ids), num_ids));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}