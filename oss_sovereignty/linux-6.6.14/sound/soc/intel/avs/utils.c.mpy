{
  "module_name": "utils.c",
  "hash_id": "b731e4703183522b2a2060201d93a293442d49ec57be2cec892ff8c806fba331",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/utils.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n#include \"avs.h\"\n#include \"messages.h\"\n\n \nstatic int avs_module_entry_index(struct avs_dev *adev, const guid_t *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->mods_info->count; i++) {\n\t\tstruct avs_module_entry *module;\n\n\t\tmodule = &adev->mods_info->entries[i];\n\t\tif (guid_equal(&module->uuid, uuid))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int avs_module_id_entry_index(struct avs_dev *adev, u32 module_id)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->mods_info->count; i++) {\n\t\tstruct avs_module_entry *module;\n\n\t\tmodule = &adev->mods_info->entries[i];\n\t\tif (module->module_id == module_id)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nint avs_get_module_entry(struct avs_dev *adev, const guid_t *uuid, struct avs_module_entry *entry)\n{\n\tint idx;\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tidx = avs_module_entry_index(adev, uuid);\n\tif (idx >= 0)\n\t\tmemcpy(entry, &adev->mods_info->entries[idx], sizeof(*entry));\n\n\tmutex_unlock(&adev->modres_mutex);\n\treturn (idx < 0) ? idx : 0;\n}\n\nint avs_get_module_id_entry(struct avs_dev *adev, u32 module_id, struct avs_module_entry *entry)\n{\n\tint idx;\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tidx = avs_module_id_entry_index(adev, module_id);\n\tif (idx >= 0)\n\t\tmemcpy(entry, &adev->mods_info->entries[idx], sizeof(*entry));\n\n\tmutex_unlock(&adev->modres_mutex);\n\treturn (idx < 0) ? idx : 0;\n}\n\nint avs_get_module_id(struct avs_dev *adev, const guid_t *uuid)\n{\n\tstruct avs_module_entry module;\n\tint ret;\n\n\tret = avs_get_module_entry(adev, uuid, &module);\n\treturn !ret ? module.module_id : -ENOENT;\n}\n\nbool avs_is_module_ida_empty(struct avs_dev *adev, u32 module_id)\n{\n\tbool ret = false;\n\tint idx;\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tidx = avs_module_id_entry_index(adev, module_id);\n\tif (idx >= 0)\n\t\tret = ida_is_empty(adev->mod_idas[idx]);\n\n\tmutex_unlock(&adev->modres_mutex);\n\treturn ret;\n}\n\n \nstatic void avs_module_ida_destroy(struct avs_dev *adev)\n{\n\tint i = adev->mods_info ? adev->mods_info->count : 0;\n\n\twhile (i--) {\n\t\tida_destroy(adev->mod_idas[i]);\n\t\tkfree(adev->mod_idas[i]);\n\t}\n\tkfree(adev->mod_idas);\n}\n\n \nstatic int\navs_module_ida_alloc(struct avs_dev *adev, struct avs_mods_info *newinfo, bool purge)\n{\n\tstruct avs_mods_info *oldinfo = adev->mods_info;\n\tstruct ida **ida_ptrs;\n\tu32 tocopy_count = 0;\n\tint i;\n\n\tif (!purge && oldinfo) {\n\t\tif (oldinfo->count >= newinfo->count)\n\t\t\tdev_warn(adev->dev, \"refreshing %d modules info with %d\\n\",\n\t\t\t\t oldinfo->count, newinfo->count);\n\t\ttocopy_count = oldinfo->count;\n\t}\n\n\tida_ptrs = kcalloc(newinfo->count, sizeof(*ida_ptrs), GFP_KERNEL);\n\tif (!ida_ptrs)\n\t\treturn -ENOMEM;\n\n\tif (tocopy_count)\n\t\tmemcpy(ida_ptrs, adev->mod_idas, tocopy_count * sizeof(*ida_ptrs));\n\n\tfor (i = tocopy_count; i < newinfo->count; i++) {\n\t\tida_ptrs[i] = kzalloc(sizeof(**ida_ptrs), GFP_KERNEL);\n\t\tif (!ida_ptrs[i]) {\n\t\t\twhile (i--)\n\t\t\t\tkfree(ida_ptrs[i]);\n\n\t\t\tkfree(ida_ptrs);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tida_init(ida_ptrs[i]);\n\t}\n\n\t \n\tif (tocopy_count)\n\t\tkfree(adev->mod_idas);\n\telse\n\t\tavs_module_ida_destroy(adev);\n\n\tadev->mod_idas = ida_ptrs;\n\treturn 0;\n}\n\nint avs_module_info_init(struct avs_dev *adev, bool purge)\n{\n\tstruct avs_mods_info *info;\n\tint ret;\n\n\tret = avs_ipc_get_modules_info(adev, &info);\n\tif (ret)\n\t\treturn AVS_IPC_RET(ret);\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tret = avs_module_ida_alloc(adev, info, purge);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"initialize module idas failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\t \n\tkfree(adev->mods_info);\n\tadev->mods_info = info;\n\nexit:\n\tmutex_unlock(&adev->modres_mutex);\n\treturn ret;\n}\n\nvoid avs_module_info_free(struct avs_dev *adev)\n{\n\tmutex_lock(&adev->modres_mutex);\n\n\tavs_module_ida_destroy(adev);\n\tkfree(adev->mods_info);\n\tadev->mods_info = NULL;\n\n\tmutex_unlock(&adev->modres_mutex);\n}\n\nint avs_module_id_alloc(struct avs_dev *adev, u16 module_id)\n{\n\tint ret, idx, max_id;\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tidx = avs_module_id_entry_index(adev, module_id);\n\tif (idx == -ENOENT) {\n\t\tdev_err(adev->dev, \"invalid module id: %d\", module_id);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\tmax_id = adev->mods_info->entries[idx].instance_max_count - 1;\n\tret = ida_alloc_max(adev->mod_idas[idx], max_id, GFP_KERNEL);\nexit:\n\tmutex_unlock(&adev->modres_mutex);\n\treturn ret;\n}\n\nvoid avs_module_id_free(struct avs_dev *adev, u16 module_id, u8 instance_id)\n{\n\tint idx;\n\n\tmutex_lock(&adev->modres_mutex);\n\n\tidx = avs_module_id_entry_index(adev, module_id);\n\tif (idx == -ENOENT) {\n\t\tdev_err(adev->dev, \"invalid module id: %d\", module_id);\n\t\tgoto exit;\n\t}\n\n\tida_free(adev->mod_idas[idx], instance_id);\nexit:\n\tmutex_unlock(&adev->modres_mutex);\n}\n\n \nint avs_request_firmware(struct avs_dev *adev, const struct firmware **fw_p, const char *name)\n{\n\tstruct avs_fw_entry *entry;\n\tint ret;\n\n\t \n\tlist_for_each_entry(entry, &adev->fw_list, node) {\n\t\tif (!strcmp(name, entry->name)) {\n\t\t\t*fw_p = entry->fw;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->name = kstrdup(name, GFP_KERNEL);\n\tif (!entry->name) {\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = request_firmware(&entry->fw, name, adev->dev);\n\tif (ret < 0) {\n\t\tkfree(entry->name);\n\t\tkfree(entry);\n\t\treturn ret;\n\t}\n\n\t*fw_p = entry->fw;\n\n\tlist_add_tail(&entry->node, &adev->fw_list);\n\n\treturn 0;\n}\n\n \nvoid avs_release_last_firmware(struct avs_dev *adev)\n{\n\tstruct avs_fw_entry *entry;\n\n\tentry = list_last_entry(&adev->fw_list, typeof(*entry), node);\n\n\tlist_del(&entry->node);\n\trelease_firmware(entry->fw);\n\tkfree(entry->name);\n\tkfree(entry);\n}\n\n \nvoid avs_release_firmwares(struct avs_dev *adev)\n{\n\tstruct avs_fw_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &adev->fw_list, node) {\n\t\tlist_del(&entry->node);\n\t\trelease_firmware(entry->fw);\n\t\tkfree(entry->name);\n\t\tkfree(entry);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}