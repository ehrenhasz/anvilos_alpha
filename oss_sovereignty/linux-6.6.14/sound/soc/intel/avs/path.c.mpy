{
  "module_name": "path.c",
  "hash_id": "c3a4e611696683583f5f211c4802760ae56d16a0e70bc6f2234a22f6917a4dc2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/path.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/intel-nhlt.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"avs.h\"\n#include \"control.h\"\n#include \"path.h\"\n#include \"topology.h\"\n\n \nstatic struct avs_tplg *\navs_path_find_tplg(struct avs_dev *adev, const char *name)\n{\n\tstruct avs_soc_component *acomp;\n\n\tlist_for_each_entry(acomp, &adev->comp_list, node)\n\t\tif (!strcmp(acomp->tplg->name, name))\n\t\t\treturn acomp->tplg;\n\treturn NULL;\n}\n\nstatic struct avs_path_module *\navs_path_find_module(struct avs_path_pipeline *ppl, u32 template_id)\n{\n\tstruct avs_path_module *mod;\n\n\tlist_for_each_entry(mod, &ppl->mod_list, node)\n\t\tif (mod->template->id == template_id)\n\t\t\treturn mod;\n\treturn NULL;\n}\n\nstatic struct avs_path_pipeline *\navs_path_find_pipeline(struct avs_path *path, u32 template_id)\n{\n\tstruct avs_path_pipeline *ppl;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node)\n\t\tif (ppl->template->id == template_id)\n\t\t\treturn ppl;\n\treturn NULL;\n}\n\nstatic struct avs_path *\navs_path_find_path(struct avs_dev *adev, const char *name, u32 template_id)\n{\n\tstruct avs_tplg_path_template *pos, *template = NULL;\n\tstruct avs_tplg *tplg;\n\tstruct avs_path *path;\n\n\ttplg = avs_path_find_tplg(adev, name);\n\tif (!tplg)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pos, &tplg->path_tmpl_list, node) {\n\t\tif (pos->id == template_id) {\n\t\t\ttemplate = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!template)\n\t\treturn NULL;\n\n\tspin_lock(&adev->path_list_lock);\n\t \n\tlist_for_each_entry(path, &adev->path_list, node) {\n\t\tif (path->template->owner == template) {\n\t\t\tspin_unlock(&adev->path_list_lock);\n\t\t\treturn path;\n\t\t}\n\t}\n\n\tspin_unlock(&adev->path_list_lock);\n\treturn NULL;\n}\n\nstatic bool avs_test_hw_params(struct snd_pcm_hw_params *params,\n\t\t\t       struct avs_audio_format *fmt)\n{\n\treturn (params_rate(params) == fmt->sampling_freq &&\n\t\tparams_channels(params) == fmt->num_channels &&\n\t\tparams_physical_width(params) == fmt->bit_depth &&\n\t\tparams_width(params) == fmt->valid_bit_depth);\n}\n\nstatic struct avs_tplg_path *\navs_path_find_variant(struct avs_dev *adev,\n\t\t      struct avs_tplg_path_template *template,\n\t\t      struct snd_pcm_hw_params *fe_params,\n\t\t      struct snd_pcm_hw_params *be_params)\n{\n\tstruct avs_tplg_path *variant;\n\n\tlist_for_each_entry(variant, &template->path_list, node) {\n\t\tdev_dbg(adev->dev, \"check FE rate %d chn %d vbd %d bd %d\\n\",\n\t\t\tvariant->fe_fmt->sampling_freq, variant->fe_fmt->num_channels,\n\t\t\tvariant->fe_fmt->valid_bit_depth, variant->fe_fmt->bit_depth);\n\t\tdev_dbg(adev->dev, \"check BE rate %d chn %d vbd %d bd %d\\n\",\n\t\t\tvariant->be_fmt->sampling_freq, variant->be_fmt->num_channels,\n\t\t\tvariant->be_fmt->valid_bit_depth, variant->be_fmt->bit_depth);\n\n\t\tif (variant->fe_fmt && avs_test_hw_params(fe_params, variant->fe_fmt) &&\n\t\t    variant->be_fmt && avs_test_hw_params(be_params, variant->be_fmt))\n\t\t\treturn variant;\n\t}\n\n\treturn NULL;\n}\n\n__maybe_unused\nstatic bool avs_dma_type_is_host(u32 dma_type)\n{\n\treturn dma_type == AVS_DMA_HDA_HOST_OUTPUT ||\n\t       dma_type == AVS_DMA_HDA_HOST_INPUT;\n}\n\n__maybe_unused\nstatic bool avs_dma_type_is_link(u32 dma_type)\n{\n\treturn !avs_dma_type_is_host(dma_type);\n}\n\n__maybe_unused\nstatic bool avs_dma_type_is_output(u32 dma_type)\n{\n\treturn dma_type == AVS_DMA_HDA_HOST_OUTPUT ||\n\t       dma_type == AVS_DMA_HDA_LINK_OUTPUT ||\n\t       dma_type == AVS_DMA_I2S_LINK_OUTPUT;\n}\n\n__maybe_unused\nstatic bool avs_dma_type_is_input(u32 dma_type)\n{\n\treturn !avs_dma_type_is_output(dma_type);\n}\n\nstatic int avs_copier_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct nhlt_acpi_table *nhlt = adev->nhlt;\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_copier_cfg *cfg;\n\tstruct nhlt_specific_cfg *ep_blob;\n\tunion avs_connector_node_id node_id = {0};\n\tsize_t cfg_size, data_size = 0;\n\tvoid *data = NULL;\n\tu32 dma_type;\n\tint ret;\n\n\tdma_type = t->cfg_ext->copier.dma_type;\n\tnode_id.dma_type = dma_type;\n\n\tswitch (dma_type) {\n\t\tstruct avs_audio_format *fmt;\n\t\tint direction;\n\n\tcase AVS_DMA_I2S_LINK_OUTPUT:\n\tcase AVS_DMA_I2S_LINK_INPUT:\n\t\tif (avs_dma_type_is_input(dma_type))\n\t\t\tdirection = SNDRV_PCM_STREAM_CAPTURE;\n\t\telse\n\t\t\tdirection = SNDRV_PCM_STREAM_PLAYBACK;\n\n\t\tif (t->cfg_ext->copier.blob_fmt)\n\t\t\tfmt = t->cfg_ext->copier.blob_fmt;\n\t\telse if (direction == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tfmt = t->in_fmt;\n\t\telse\n\t\t\tfmt = t->cfg_ext->copier.out_fmt;\n\n\t\tep_blob = intel_nhlt_get_endpoint_blob(adev->dev,\n\t\t\tnhlt, t->cfg_ext->copier.vindex.i2s.instance,\n\t\t\tNHLT_LINK_SSP, fmt->valid_bit_depth, fmt->bit_depth,\n\t\t\tfmt->num_channels, fmt->sampling_freq, direction,\n\t\t\tNHLT_DEVICE_I2S);\n\t\tif (!ep_blob) {\n\t\t\tdev_err(adev->dev, \"no I2S ep_blob found\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdata = ep_blob->caps;\n\t\tdata_size = ep_blob->size;\n\t\t \n\t\tnode_id.vindex = t->cfg_ext->copier.vindex.val;\n\n\t\tbreak;\n\n\tcase AVS_DMA_DMIC_LINK_INPUT:\n\t\tdirection = SNDRV_PCM_STREAM_CAPTURE;\n\n\t\tif (t->cfg_ext->copier.blob_fmt)\n\t\t\tfmt = t->cfg_ext->copier.blob_fmt;\n\t\telse\n\t\t\tfmt = t->in_fmt;\n\n\t\tep_blob = intel_nhlt_get_endpoint_blob(adev->dev, nhlt, 0,\n\t\t\t\tNHLT_LINK_DMIC, fmt->valid_bit_depth,\n\t\t\t\tfmt->bit_depth, fmt->num_channels,\n\t\t\t\tfmt->sampling_freq, direction, NHLT_DEVICE_DMIC);\n\t\tif (!ep_blob) {\n\t\t\tdev_err(adev->dev, \"no DMIC ep_blob found\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tdata = ep_blob->caps;\n\t\tdata_size = ep_blob->size;\n\t\t \n\t\tnode_id.vindex = t->cfg_ext->copier.vindex.val;\n\n\t\tbreak;\n\n\tcase AVS_DMA_HDA_HOST_OUTPUT:\n\tcase AVS_DMA_HDA_HOST_INPUT:\n\t\t \n\t\tnode_id.vindex = mod->owner->owner->dma_id;\n\t\tbreak;\n\n\tcase AVS_DMA_HDA_LINK_OUTPUT:\n\tcase AVS_DMA_HDA_LINK_INPUT:\n\t\tnode_id.vindex = t->cfg_ext->copier.vindex.val |\n\t\t\t\t mod->owner->owner->dma_id;\n\t\tbreak;\n\n\tcase INVALID_OBJECT_ID:\n\tdefault:\n\t\tnode_id = INVALID_NODE_ID;\n\t\tbreak;\n\t}\n\n\tcfg_size = sizeof(*cfg) + data_size;\n\t \n\tif (data_size)\n\t\tcfg_size -= sizeof(cfg->gtw_cfg.config.attrs);\n\n\tcfg = kzalloc(cfg_size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->base.cpc = t->cfg_base->cpc;\n\tcfg->base.ibs = t->cfg_base->ibs;\n\tcfg->base.obs = t->cfg_base->obs;\n\tcfg->base.is_pages = t->cfg_base->is_pages;\n\tcfg->base.audio_fmt = *t->in_fmt;\n\tcfg->out_fmt = *t->cfg_ext->copier.out_fmt;\n\tcfg->feature_mask = t->cfg_ext->copier.feature_mask;\n\tcfg->gtw_cfg.node_id = node_id;\n\tcfg->gtw_cfg.dma_buffer_size = t->cfg_ext->copier.dma_buffer_size;\n\t \n\tcfg->gtw_cfg.config_length = DIV_ROUND_UP(data_size, 4);\n\tif (data)\n\t\tmemcpy(&cfg->gtw_cfg.config, data, data_size);\n\n\tmod->gtw_attrs = cfg->gtw_cfg.config.attrs;\n\n\tret = avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t  t->core_id, t->domain, cfg, cfg_size,\n\t\t\t\t  &mod->instance_id);\n\tkfree(cfg);\n\treturn ret;\n}\n\nstatic struct avs_control_data *avs_get_module_control(struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_tplg_path_template *path_tmpl;\n\tstruct snd_soc_dapm_widget *w;\n\tint i;\n\n\tpath_tmpl = t->owner->owner->owner;\n\tw = path_tmpl->w;\n\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tstruct avs_control_data *ctl_data;\n\t\tstruct soc_mixer_control *mc;\n\n\t\tmc = (struct soc_mixer_control *)w->kcontrols[i]->private_value;\n\t\tctl_data = (struct avs_control_data *)mc->dobj.private;\n\t\tif (ctl_data->id == t->ctl_id)\n\t\t\treturn ctl_data;\n\t}\n\n\treturn NULL;\n}\n\nstatic int avs_peakvol_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_control_data *ctl_data;\n\tstruct avs_peakvol_cfg *cfg;\n\tint volume = S32_MAX;\n\tsize_t size;\n\tint ret;\n\n\tctl_data = avs_get_module_control(mod);\n\tif (ctl_data)\n\t\tvolume = ctl_data->volume;\n\n\t \n\tsize = struct_size(cfg, vols, 1);\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->base.cpc = t->cfg_base->cpc;\n\tcfg->base.ibs = t->cfg_base->ibs;\n\tcfg->base.obs = t->cfg_base->obs;\n\tcfg->base.is_pages = t->cfg_base->is_pages;\n\tcfg->base.audio_fmt = *t->in_fmt;\n\tcfg->vols[0].target_volume = volume;\n\tcfg->vols[0].channel_id = AVS_ALL_CHANNELS_MASK;\n\tcfg->vols[0].curve_type = AVS_AUDIO_CURVE_NONE;\n\tcfg->vols[0].curve_duration = 0;\n\n\tret = avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id, t->core_id,\n\t\t\t\t  t->domain, cfg, size, &mod->instance_id);\n\n\tkfree(cfg);\n\treturn ret;\n}\n\nstatic int avs_updown_mix_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_updown_mixer_cfg cfg;\n\tint i;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.out_channel_config = t->cfg_ext->updown_mix.out_channel_config;\n\tcfg.coefficients_select = t->cfg_ext->updown_mix.coefficients_select;\n\tfor (i = 0; i < AVS_CHANNELS_MAX; i++)\n\t\tcfg.coefficients[i] = t->cfg_ext->updown_mix.coefficients[i];\n\tcfg.channel_map = t->cfg_ext->updown_mix.channel_map;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_src_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_src_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.out_freq = t->cfg_ext->src.out_freq;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_asrc_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_asrc_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.out_freq = t->cfg_ext->asrc.out_freq;\n\tcfg.mode = t->cfg_ext->asrc.mode;\n\tcfg.disable_jitter_buffer = t->cfg_ext->asrc.disable_jitter_buffer;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_aec_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_aec_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.ref_fmt = *t->cfg_ext->aec.ref_fmt;\n\tcfg.out_fmt = *t->cfg_ext->aec.out_fmt;\n\tcfg.cpc_lp_mode = t->cfg_ext->aec.cpc_lp_mode;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_mux_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_mux_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.ref_fmt = *t->cfg_ext->mux.ref_fmt;\n\tcfg.out_fmt = *t->cfg_ext->mux.out_fmt;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_wov_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_wov_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.cpc_lp_mode = t->cfg_ext->wov.cpc_lp_mode;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_micsel_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_micsel_cfg cfg;\n\n\tcfg.base.cpc = t->cfg_base->cpc;\n\tcfg.base.ibs = t->cfg_base->ibs;\n\tcfg.base.obs = t->cfg_base->obs;\n\tcfg.base.is_pages = t->cfg_base->is_pages;\n\tcfg.base.audio_fmt = *t->in_fmt;\n\tcfg.out_fmt = *t->cfg_ext->micsel.out_fmt;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_modbase_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_modcfg_base cfg;\n\n\tcfg.cpc = t->cfg_base->cpc;\n\tcfg.ibs = t->cfg_base->ibs;\n\tcfg.obs = t->cfg_base->obs;\n\tcfg.is_pages = t->cfg_base->is_pages;\n\tcfg.audio_fmt = *t->in_fmt;\n\n\treturn avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t   t->core_id, t->domain, &cfg, sizeof(cfg),\n\t\t\t\t   &mod->instance_id);\n}\n\nstatic int avs_modext_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tstruct avs_tplg_module *t = mod->template;\n\tstruct avs_tplg_modcfg_ext *tcfg = t->cfg_ext;\n\tstruct avs_modcfg_ext *cfg;\n\tsize_t cfg_size, num_pins;\n\tint ret, i;\n\n\tnum_pins = tcfg->generic.num_input_pins + tcfg->generic.num_output_pins;\n\tcfg_size = struct_size(cfg, pin_fmts, num_pins);\n\n\tcfg = kzalloc(cfg_size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->base.cpc = t->cfg_base->cpc;\n\tcfg->base.ibs = t->cfg_base->ibs;\n\tcfg->base.obs = t->cfg_base->obs;\n\tcfg->base.is_pages = t->cfg_base->is_pages;\n\tcfg->base.audio_fmt = *t->in_fmt;\n\tcfg->num_input_pins = tcfg->generic.num_input_pins;\n\tcfg->num_output_pins = tcfg->generic.num_output_pins;\n\n\t \n\tfor (i = 0; i < num_pins; i++) {\n\t\tstruct avs_tplg_pin_format *tpin = &tcfg->generic.pin_fmts[i];\n\t\tstruct avs_pin_format *pin = &cfg->pin_fmts[i];\n\n\t\tpin->pin_index = tpin->pin_index;\n\t\tpin->iobs = tpin->iobs;\n\t\tpin->audio_fmt = *tpin->fmt;\n\t}\n\n\tret = avs_dsp_init_module(adev, mod->module_id, mod->owner->instance_id,\n\t\t\t\t  t->core_id, t->domain, cfg, cfg_size,\n\t\t\t\t  &mod->instance_id);\n\tkfree(cfg);\n\treturn ret;\n}\n\nstatic int avs_probe_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tdev_err(adev->dev, \"Probe module can't be instantiated by topology\");\n\treturn -EINVAL;\n}\n\nstruct avs_module_create {\n\tguid_t *guid;\n\tint (*create)(struct avs_dev *adev, struct avs_path_module *mod);\n};\n\nstatic struct avs_module_create avs_module_create[] = {\n\t{ &AVS_MIXIN_MOD_UUID, avs_modbase_create },\n\t{ &AVS_MIXOUT_MOD_UUID, avs_modbase_create },\n\t{ &AVS_KPBUFF_MOD_UUID, avs_modbase_create },\n\t{ &AVS_COPIER_MOD_UUID, avs_copier_create },\n\t{ &AVS_PEAKVOL_MOD_UUID, avs_peakvol_create },\n\t{ &AVS_GAIN_MOD_UUID, avs_peakvol_create },\n\t{ &AVS_MICSEL_MOD_UUID, avs_micsel_create },\n\t{ &AVS_MUX_MOD_UUID, avs_mux_create },\n\t{ &AVS_UPDWMIX_MOD_UUID, avs_updown_mix_create },\n\t{ &AVS_SRCINTC_MOD_UUID, avs_src_create },\n\t{ &AVS_AEC_MOD_UUID, avs_aec_create },\n\t{ &AVS_ASRC_MOD_UUID, avs_asrc_create },\n\t{ &AVS_INTELWOV_MOD_UUID, avs_wov_create },\n\t{ &AVS_PROBE_MOD_UUID, avs_probe_create },\n};\n\nstatic int avs_path_module_type_create(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tconst guid_t *type = &mod->template->cfg_ext->type;\n\n\tfor (int i = 0; i < ARRAY_SIZE(avs_module_create); i++)\n\t\tif (guid_equal(type, avs_module_create[i].guid))\n\t\t\treturn avs_module_create[i].create(adev, mod);\n\n\treturn avs_modext_create(adev, mod);\n}\n\nstatic void avs_path_module_free(struct avs_dev *adev, struct avs_path_module *mod)\n{\n\tkfree(mod);\n}\n\nstatic struct avs_path_module *\navs_path_module_create(struct avs_dev *adev,\n\t\t       struct avs_path_pipeline *owner,\n\t\t       struct avs_tplg_module *template)\n{\n\tstruct avs_path_module *mod;\n\tint module_id, ret;\n\n\tmodule_id = avs_get_module_id(adev, &template->cfg_ext->type);\n\tif (module_id < 0)\n\t\treturn ERR_PTR(module_id);\n\n\tmod = kzalloc(sizeof(*mod), GFP_KERNEL);\n\tif (!mod)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmod->template = template;\n\tmod->module_id = module_id;\n\tmod->owner = owner;\n\tINIT_LIST_HEAD(&mod->node);\n\n\tret = avs_path_module_type_create(adev, mod);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"module-type create failed: %d\\n\", ret);\n\t\tkfree(mod);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mod;\n}\n\nstatic int avs_path_binding_arm(struct avs_dev *adev, struct avs_path_binding *binding)\n{\n\tstruct avs_path_module *this_mod, *target_mod;\n\tstruct avs_path_pipeline *target_ppl;\n\tstruct avs_path *target_path;\n\tstruct avs_tplg_binding *t;\n\n\tt = binding->template;\n\tthis_mod = avs_path_find_module(binding->owner,\n\t\t\t\t\tt->mod_id);\n\tif (!this_mod) {\n\t\tdev_err(adev->dev, \"path mod %d not found\\n\", t->mod_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttarget_path = avs_path_find_path(adev, t->target_tplg_name,\n\t\t\t\t\t t->target_path_tmpl_id);\n\tif (!target_path) {\n\t\tdev_err(adev->dev, \"target path %s:%d not found\\n\",\n\t\t\tt->target_tplg_name, t->target_path_tmpl_id);\n\t\treturn -EINVAL;\n\t}\n\n\ttarget_ppl = avs_path_find_pipeline(target_path,\n\t\t\t\t\t    t->target_ppl_id);\n\tif (!target_ppl) {\n\t\tdev_err(adev->dev, \"target ppl %d not found\\n\", t->target_ppl_id);\n\t\treturn -EINVAL;\n\t}\n\n\ttarget_mod = avs_path_find_module(target_ppl, t->target_mod_id);\n\tif (!target_mod) {\n\t\tdev_err(adev->dev, \"target mod %d not found\\n\", t->target_mod_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->is_sink) {\n\t\tbinding->sink = this_mod;\n\t\tbinding->sink_pin = t->mod_pin;\n\t\tbinding->source = target_mod;\n\t\tbinding->source_pin = t->target_mod_pin;\n\t} else {\n\t\tbinding->sink = target_mod;\n\t\tbinding->sink_pin = t->target_mod_pin;\n\t\tbinding->source = this_mod;\n\t\tbinding->source_pin = t->mod_pin;\n\t}\n\n\treturn 0;\n}\n\nstatic void avs_path_binding_free(struct avs_dev *adev, struct avs_path_binding *binding)\n{\n\tkfree(binding);\n}\n\nstatic struct avs_path_binding *avs_path_binding_create(struct avs_dev *adev,\n\t\t\t\t\t\t\tstruct avs_path_pipeline *owner,\n\t\t\t\t\t\t\tstruct avs_tplg_binding *t)\n{\n\tstruct avs_path_binding *binding;\n\n\tbinding = kzalloc(sizeof(*binding), GFP_KERNEL);\n\tif (!binding)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbinding->template = t;\n\tbinding->owner = owner;\n\tINIT_LIST_HEAD(&binding->node);\n\n\treturn binding;\n}\n\nstatic int avs_path_pipeline_arm(struct avs_dev *adev,\n\t\t\t\t struct avs_path_pipeline *ppl)\n{\n\tstruct avs_path_module *mod;\n\n\tlist_for_each_entry(mod, &ppl->mod_list, node) {\n\t\tstruct avs_path_module *source, *sink;\n\t\tint ret;\n\n\t\t \n\t\tif (mod == list_last_entry(&ppl->mod_list,\n\t\t\t\t\t   struct avs_path_module, node))\n\t\t\tbreak;\n\n\t\t \n\t\tsource = mod;\n\t\tsink = list_next_entry(mod, node);\n\t\tif (!source || !sink)\n\t\t\treturn -EINVAL;\n\n\t\tret = avs_ipc_bind(adev, source->module_id, source->instance_id,\n\t\t\t\t   sink->module_id, sink->instance_id, 0, 0);\n\t\tif (ret)\n\t\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\treturn 0;\n}\n\nstatic void avs_path_pipeline_free(struct avs_dev *adev,\n\t\t\t\t   struct avs_path_pipeline *ppl)\n{\n\tstruct avs_path_binding *binding, *bsave;\n\tstruct avs_path_module *mod, *save;\n\n\tlist_for_each_entry_safe(binding, bsave, &ppl->binding_list, node) {\n\t\tlist_del(&binding->node);\n\t\tavs_path_binding_free(adev, binding);\n\t}\n\n\tavs_dsp_delete_pipeline(adev, ppl->instance_id);\n\n\t \n\tlist_for_each_entry_safe(mod, save, &ppl->mod_list, node) {\n\t\tavs_dsp_delete_module(adev, mod->module_id, mod->instance_id,\n\t\t\t\t      mod->owner->instance_id,\n\t\t\t\t      mod->template->core_id);\n\t\tavs_path_module_free(adev, mod);\n\t}\n\n\tlist_del(&ppl->node);\n\tkfree(ppl);\n}\n\nstatic struct avs_path_pipeline *\navs_path_pipeline_create(struct avs_dev *adev, struct avs_path *owner,\n\t\t\t struct avs_tplg_pipeline *template)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_tplg_pplcfg *cfg = template->cfg;\n\tstruct avs_tplg_module *tmod;\n\tint ret, i;\n\n\tppl = kzalloc(sizeof(*ppl), GFP_KERNEL);\n\tif (!ppl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tppl->template = template;\n\tppl->owner = owner;\n\tINIT_LIST_HEAD(&ppl->binding_list);\n\tINIT_LIST_HEAD(&ppl->mod_list);\n\tINIT_LIST_HEAD(&ppl->node);\n\n\tret = avs_dsp_create_pipeline(adev, cfg->req_size, cfg->priority,\n\t\t\t\t      cfg->lp, cfg->attributes,\n\t\t\t\t      &ppl->instance_id);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"error creating pipeline %d\\n\", ret);\n\t\tkfree(ppl);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tlist_for_each_entry(tmod, &template->mod_list, node) {\n\t\tstruct avs_path_module *mod;\n\n\t\tmod = avs_path_module_create(adev, ppl, tmod);\n\t\tif (IS_ERR(mod)) {\n\t\t\tret = PTR_ERR(mod);\n\t\t\tdev_err(adev->dev, \"error creating module %d\\n\", ret);\n\t\t\tgoto init_err;\n\t\t}\n\n\t\tlist_add_tail(&mod->node, &ppl->mod_list);\n\t}\n\n\tfor (i = 0; i < template->num_bindings; i++) {\n\t\tstruct avs_path_binding *binding;\n\n\t\tbinding = avs_path_binding_create(adev, ppl, template->bindings[i]);\n\t\tif (IS_ERR(binding)) {\n\t\t\tret = PTR_ERR(binding);\n\t\t\tdev_err(adev->dev, \"error creating binding %d\\n\", ret);\n\t\t\tgoto init_err;\n\t\t}\n\n\t\tlist_add_tail(&binding->node, &ppl->binding_list);\n\t}\n\n\treturn ppl;\n\ninit_err:\n\tavs_path_pipeline_free(adev, ppl);\n\treturn ERR_PTR(ret);\n}\n\nstatic int avs_path_init(struct avs_dev *adev, struct avs_path *path,\n\t\t\t struct avs_tplg_path *template, u32 dma_id)\n{\n\tstruct avs_tplg_pipeline *tppl;\n\n\tpath->owner = adev;\n\tpath->template = template;\n\tpath->dma_id = dma_id;\n\tINIT_LIST_HEAD(&path->ppl_list);\n\tINIT_LIST_HEAD(&path->node);\n\n\t \n\tlist_for_each_entry(tppl, &template->ppl_list, node) {\n\t\tstruct avs_path_pipeline *ppl;\n\n\t\tppl = avs_path_pipeline_create(adev, path, tppl);\n\t\tif (IS_ERR(ppl))\n\t\t\treturn PTR_ERR(ppl);\n\n\t\tlist_add_tail(&ppl->node, &path->ppl_list);\n\t}\n\n\tspin_lock(&adev->path_list_lock);\n\tlist_add_tail(&path->node, &adev->path_list);\n\tspin_unlock(&adev->path_list_lock);\n\n\treturn 0;\n}\n\nstatic int avs_path_arm(struct avs_dev *adev, struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_path_binding *binding;\n\tint ret;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\t \n\t\tlist_for_each_entry(binding, &ppl->binding_list, node) {\n\t\t\tret = avs_path_binding_arm(adev, binding);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = avs_path_pipeline_arm(adev, ppl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void avs_path_free_unlocked(struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl, *save;\n\n\tspin_lock(&path->owner->path_list_lock);\n\tlist_del(&path->node);\n\tspin_unlock(&path->owner->path_list_lock);\n\n\tlist_for_each_entry_safe(ppl, save, &path->ppl_list, node)\n\t\tavs_path_pipeline_free(path->owner, ppl);\n\n\tkfree(path);\n}\n\nstatic struct avs_path *avs_path_create_unlocked(struct avs_dev *adev, u32 dma_id,\n\t\t\t\t\t\t struct avs_tplg_path *template)\n{\n\tstruct avs_path *path;\n\tint ret;\n\n\tpath = kzalloc(sizeof(*path), GFP_KERNEL);\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = avs_path_init(adev, path, template, dma_id);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = avs_path_arm(adev, path);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tpath->state = AVS_PPL_STATE_INVALID;\n\treturn path;\nerr:\n\tavs_path_free_unlocked(path);\n\treturn ERR_PTR(ret);\n}\n\nvoid avs_path_free(struct avs_path *path)\n{\n\tstruct avs_dev *adev = path->owner;\n\n\tmutex_lock(&adev->path_mutex);\n\tavs_path_free_unlocked(path);\n\tmutex_unlock(&adev->path_mutex);\n}\n\nstruct avs_path *avs_path_create(struct avs_dev *adev, u32 dma_id,\n\t\t\t\t struct avs_tplg_path_template *template,\n\t\t\t\t struct snd_pcm_hw_params *fe_params,\n\t\t\t\t struct snd_pcm_hw_params *be_params)\n{\n\tstruct avs_tplg_path *variant;\n\tstruct avs_path *path;\n\n\tvariant = avs_path_find_variant(adev, template, fe_params, be_params);\n\tif (!variant) {\n\t\tdev_err(adev->dev, \"no matching variant found\\n\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t \n\tmutex_lock(&adev->path_mutex);\n\t \n\tmutex_lock(&adev->comp_list_mutex);\n\n\tpath = avs_path_create_unlocked(adev, dma_id, variant);\n\n\tmutex_unlock(&adev->comp_list_mutex);\n\tmutex_unlock(&adev->path_mutex);\n\n\treturn path;\n}\n\nstatic int avs_path_bind_prepare(struct avs_dev *adev,\n\t\t\t\t struct avs_path_binding *binding)\n{\n\tconst struct avs_audio_format *src_fmt, *sink_fmt;\n\tstruct avs_tplg_module *tsource = binding->source->template;\n\tstruct avs_path_module *source = binding->source;\n\tint ret;\n\n\t \n\tif (!binding->source_pin)\n\t\treturn 0;\n\tif (!guid_equal(&tsource->cfg_ext->type, &AVS_COPIER_MOD_UUID))\n\t\treturn 0;\n\n\tsrc_fmt = tsource->in_fmt;\n\tsink_fmt = binding->sink->template->in_fmt;\n\n\tret = avs_ipc_copier_set_sink_format(adev, source->module_id,\n\t\t\t\t\t     source->instance_id, binding->source_pin,\n\t\t\t\t\t     src_fmt, sink_fmt);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"config copier failed: %d\\n\", ret);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\treturn 0;\n}\n\nint avs_path_bind(struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_dev *adev = path->owner;\n\tint ret;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\tstruct avs_path_binding *binding;\n\n\t\tlist_for_each_entry(binding, &ppl->binding_list, node) {\n\t\t\tstruct avs_path_module *source, *sink;\n\n\t\t\tsource = binding->source;\n\t\t\tsink = binding->sink;\n\n\t\t\tret = avs_path_bind_prepare(adev, binding);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = avs_ipc_bind(adev, source->module_id,\n\t\t\t\t\t   source->instance_id, sink->module_id,\n\t\t\t\t\t   sink->instance_id, binding->sink_pin,\n\t\t\t\t\t   binding->source_pin);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(adev->dev, \"bind path failed: %d\\n\", ret);\n\t\t\t\treturn AVS_IPC_RET(ret);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint avs_path_unbind(struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_dev *adev = path->owner;\n\tint ret;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\tstruct avs_path_binding *binding;\n\n\t\tlist_for_each_entry(binding, &ppl->binding_list, node) {\n\t\t\tstruct avs_path_module *source, *sink;\n\n\t\t\tsource = binding->source;\n\t\t\tsink = binding->sink;\n\n\t\t\tret = avs_ipc_unbind(adev, source->module_id,\n\t\t\t\t\t     source->instance_id, sink->module_id,\n\t\t\t\t\t     sink->instance_id, binding->sink_pin,\n\t\t\t\t\t     binding->source_pin);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(adev->dev, \"unbind path failed: %d\\n\", ret);\n\t\t\t\treturn AVS_IPC_RET(ret);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint avs_path_reset(struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_dev *adev = path->owner;\n\tint ret;\n\n\tif (path->state == AVS_PPL_STATE_RESET)\n\t\treturn 0;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\tret = avs_ipc_set_pipeline_state(adev, ppl->instance_id,\n\t\t\t\t\t\t AVS_PPL_STATE_RESET);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"reset path failed: %d\\n\", ret);\n\t\t\tpath->state = AVS_PPL_STATE_INVALID;\n\t\t\treturn AVS_IPC_RET(ret);\n\t\t}\n\t}\n\n\tpath->state = AVS_PPL_STATE_RESET;\n\treturn 0;\n}\n\nint avs_path_pause(struct avs_path *path)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_dev *adev = path->owner;\n\tint ret;\n\n\tif (path->state == AVS_PPL_STATE_PAUSED)\n\t\treturn 0;\n\n\tlist_for_each_entry_reverse(ppl, &path->ppl_list, node) {\n\t\tret = avs_ipc_set_pipeline_state(adev, ppl->instance_id,\n\t\t\t\t\t\t AVS_PPL_STATE_PAUSED);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"pause path failed: %d\\n\", ret);\n\t\t\tpath->state = AVS_PPL_STATE_INVALID;\n\t\t\treturn AVS_IPC_RET(ret);\n\t\t}\n\t}\n\n\tpath->state = AVS_PPL_STATE_PAUSED;\n\treturn 0;\n}\n\nint avs_path_run(struct avs_path *path, int trigger)\n{\n\tstruct avs_path_pipeline *ppl;\n\tstruct avs_dev *adev = path->owner;\n\tint ret;\n\n\tif (path->state == AVS_PPL_STATE_RUNNING && trigger == AVS_TPLG_TRIGGER_AUTO)\n\t\treturn 0;\n\n\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\tif (ppl->template->cfg->trigger != trigger)\n\t\t\tcontinue;\n\n\t\tret = avs_ipc_set_pipeline_state(adev, ppl->instance_id,\n\t\t\t\t\t\t AVS_PPL_STATE_RUNNING);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"run path failed: %d\\n\", ret);\n\t\t\tpath->state = AVS_PPL_STATE_INVALID;\n\t\t\treturn AVS_IPC_RET(ret);\n\t\t}\n\t}\n\n\tpath->state = AVS_PPL_STATE_RUNNING;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}