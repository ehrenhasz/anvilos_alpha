{
  "module_name": "ipc.c",
  "hash_id": "0313b214f4f8257e780ac8304063fe597cf85aeea791a23d51fd48b870499b65",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/ipc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/slab.h>\n#include <sound/hdaudio_ext.h>\n#include \"avs.h\"\n#include \"messages.h\"\n#include \"registers.h\"\n#include \"trace.h\"\n\n#define AVS_IPC_TIMEOUT_MS\t300\n#define AVS_D0IX_DELAY_MS\t300\n\nstatic int\navs_dsp_set_d0ix(struct avs_dev *adev, bool enable)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\tint ret;\n\n\t \n\tif (ipc->in_d0ix == enable)\n\t\treturn 0;\n\n\tret = avs_dsp_op(adev, set_d0ix, enable);\n\tif (ret) {\n\t\t \n\t\tif (ret == -AVS_EIPC)\n\t\t\tatomic_inc(&ipc->d0ix_disable_depth);\n\n\t\tipc->in_d0ix = false;\n\t\treturn ret;\n\t}\n\n\tipc->in_d0ix = enable;\n\treturn 0;\n}\n\nstatic void avs_dsp_schedule_d0ix(struct avs_dev *adev, struct avs_ipc_msg *tx)\n{\n\tif (atomic_read(&adev->ipc->d0ix_disable_depth))\n\t\treturn;\n\n\tmod_delayed_work(system_power_efficient_wq, &adev->ipc->d0ix_work,\n\t\t\t msecs_to_jiffies(AVS_D0IX_DELAY_MS));\n}\n\nstatic void avs_dsp_d0ix_work(struct work_struct *work)\n{\n\tstruct avs_ipc *ipc = container_of(work, struct avs_ipc, d0ix_work.work);\n\n\tavs_dsp_set_d0ix(to_avs_dev(ipc->dev), true);\n}\n\nstatic int avs_dsp_wake_d0i0(struct avs_dev *adev, struct avs_ipc_msg *tx)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\n\tif (!atomic_read(&ipc->d0ix_disable_depth)) {\n\t\tcancel_delayed_work_sync(&ipc->d0ix_work);\n\t\treturn avs_dsp_set_d0ix(adev, false);\n\t}\n\n\treturn 0;\n}\n\nint avs_dsp_disable_d0ix(struct avs_dev *adev)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\n\t \n\tif (atomic_inc_return(&ipc->d0ix_disable_depth) == 1) {\n\t\tcancel_delayed_work_sync(&ipc->d0ix_work);\n\t\treturn avs_dsp_set_d0ix(adev, false);\n\t}\n\n\treturn 0;\n}\n\nint avs_dsp_enable_d0ix(struct avs_dev *adev)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\n\tif (atomic_dec_and_test(&ipc->d0ix_disable_depth))\n\t\tqueue_delayed_work(system_power_efficient_wq, &ipc->d0ix_work,\n\t\t\t\t   msecs_to_jiffies(AVS_D0IX_DELAY_MS));\n\treturn 0;\n}\n\nstatic void avs_dsp_recovery(struct avs_dev *adev)\n{\n\tstruct avs_soc_component *acomp;\n\tunsigned int core_mask;\n\tint ret;\n\n\tmutex_lock(&adev->comp_list_mutex);\n\t \n\tlist_for_each_entry(acomp, &adev->comp_list, node) {\n\t\tstruct snd_soc_pcm_runtime *rtd;\n\t\tstruct snd_soc_card *card;\n\n\t\tcard = acomp->base.card;\n\t\tif (!card)\n\t\t\tcontinue;\n\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\tstruct snd_pcm *pcm;\n\t\t\tint dir;\n\n\t\t\tpcm = rtd->pcm;\n\t\t\tif (!pcm || rtd->dai_link->no_pcm)\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_pcm_streams(dir) {\n\t\t\t\tstruct snd_pcm_substream *substream;\n\n\t\t\t\tsubstream = pcm->streams[dir].substream;\n\t\t\t\tif (!substream || !substream->runtime)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tsnd_pcm_stream_lock(substream);\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);\n\t\t\t\tsnd_pcm_stream_unlock(substream);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&adev->comp_list_mutex);\n\n\t \n\tcore_mask = GENMASK(adev->hw_cfg.dsp_cores - 1, 0);\n\tavs_dsp_core_disable(adev, core_mask);\n\n\t \n\tret = avs_dsp_boot_firmware(adev, true);\n\tif (ret < 0)\n\t\tdev_err(adev->dev, \"dsp reboot failed: %d\\n\", ret);\n\n\tpm_runtime_mark_last_busy(adev->dev);\n\tpm_runtime_enable(adev->dev);\n\tpm_request_autosuspend(adev->dev);\n\n\tatomic_set(&adev->ipc->recovering, 0);\n}\n\nstatic void avs_dsp_recovery_work(struct work_struct *work)\n{\n\tstruct avs_ipc *ipc = container_of(work, struct avs_ipc, recovery_work);\n\n\tavs_dsp_recovery(to_avs_dev(ipc->dev));\n}\n\nstatic void avs_dsp_exception_caught(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\n\t \n\tipc->ready = false;\n\n\tif (!atomic_add_unless(&ipc->recovering, 1, 1)) {\n\t\tdev_err(adev->dev, \"dsp recovery is already in progress\\n\");\n\t\treturn;\n\t}\n\n\tdev_crit(adev->dev, \"communication severed, rebooting dsp..\\n\");\n\n\tcancel_delayed_work_sync(&ipc->d0ix_work);\n\tipc->in_d0ix = false;\n\t \n\tpm_runtime_disable(adev->dev);\n\n\t \n\tavs_dsp_op(adev, coredump, msg);\n\n\tschedule_work(&ipc->recovery_work);\n}\n\nstatic void avs_dsp_receive_rx(struct avs_dev *adev, u64 header)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\tunion avs_reply_msg msg = AVS_MSG(header);\n\tu64 reg;\n\n\treg = readq(avs_sram_addr(adev, AVS_FW_REGS_WINDOW));\n\ttrace_avs_ipc_reply_msg(header, reg);\n\n\tipc->rx.header = header;\n\t \n\tif (!msg.status) {\n\t\t \n\t\tif (msg.msg_target == AVS_MOD_MSG &&\n\t\t    msg.global_msg_type == AVS_MOD_LARGE_CONFIG_GET)\n\t\t\tipc->rx.size = min_t(u32, AVS_MAILBOX_SIZE,\n\t\t\t\t\t     msg.ext.large_config.data_off_size);\n\n\t\tmemcpy_fromio(ipc->rx.data, avs_uplink_addr(adev), ipc->rx.size);\n\t\ttrace_avs_msg_payload(ipc->rx.data, ipc->rx.size);\n\t}\n}\n\nstatic void avs_dsp_process_notification(struct avs_dev *adev, u64 header)\n{\n\tstruct avs_notify_mod_data mod_data;\n\tunion avs_notify_msg msg = AVS_MSG(header);\n\tsize_t data_size = 0;\n\tvoid *data = NULL;\n\tu64 reg;\n\n\treg = readq(avs_sram_addr(adev, AVS_FW_REGS_WINDOW));\n\ttrace_avs_ipc_notify_msg(header, reg);\n\n\t \n\tif (!adev->ipc->ready && msg.notify_msg_type != AVS_NOTIFY_FW_READY) {\n\t\tdev_dbg(adev->dev, \"FW not ready, skip notification: 0x%08x\\n\", msg.primary);\n\t\treturn;\n\t}\n\n\t \n\tswitch (msg.notify_msg_type) {\n\tcase AVS_NOTIFY_FW_READY:\n\t\tbreak;\n\n\tcase AVS_NOTIFY_PHRASE_DETECTED:\n\t\tdata_size = sizeof(struct avs_notify_voice_data);\n\t\tbreak;\n\n\tcase AVS_NOTIFY_RESOURCE_EVENT:\n\t\tdata_size = sizeof(struct avs_notify_res_data);\n\t\tbreak;\n\n\tcase AVS_NOTIFY_LOG_BUFFER_STATUS:\n\tcase AVS_NOTIFY_EXCEPTION_CAUGHT:\n\t\tbreak;\n\n\tcase AVS_NOTIFY_MODULE_EVENT:\n\t\t \n\t\tmemcpy_fromio(&mod_data, avs_uplink_addr(adev), sizeof(mod_data));\n\t\tdata_size = sizeof(mod_data) + mod_data.data_size;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(adev->dev, \"unknown notification: 0x%08x\\n\", msg.primary);\n\t\tbreak;\n\t}\n\n\tif (data_size) {\n\t\tdata = kmalloc(data_size, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn;\n\n\t\tmemcpy_fromio(data, avs_uplink_addr(adev), data_size);\n\t\ttrace_avs_msg_payload(data, data_size);\n\t}\n\n\t \n\tswitch (msg.notify_msg_type) {\n\tcase AVS_NOTIFY_FW_READY:\n\t\tdev_dbg(adev->dev, \"FW READY 0x%08x\\n\", msg.primary);\n\t\tadev->ipc->ready = true;\n\t\tcomplete(&adev->fw_ready);\n\t\tbreak;\n\n\tcase AVS_NOTIFY_LOG_BUFFER_STATUS:\n\t\tavs_log_buffer_status_locked(adev, &msg);\n\t\tbreak;\n\n\tcase AVS_NOTIFY_EXCEPTION_CAUGHT:\n\t\tavs_dsp_exception_caught(adev, &msg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(data);\n}\n\nvoid avs_dsp_process_response(struct avs_dev *adev, u64 header)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\n\t \n\tif (avs_msg_is_reply(header)) {\n\t\t \n\t\tspin_lock_irq(&ipc->rx_lock);\n\t\tavs_dsp_receive_rx(adev, header);\n\t\tipc->rx_completed = true;\n\t\tspin_unlock_irq(&ipc->rx_lock);\n\t} else {\n\t\tavs_dsp_process_notification(adev, header);\n\t}\n\n\tcomplete(&ipc->busy_completion);\n}\n\nirqreturn_t avs_dsp_irq_handler(int irq, void *dev_id)\n{\n\tstruct avs_dev *adev = dev_id;\n\tstruct avs_ipc *ipc = adev->ipc;\n\tu32 adspis, hipc_rsp, hipc_ack;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tadspis = snd_hdac_adsp_readl(adev, AVS_ADSP_REG_ADSPIS);\n\tif (adspis == UINT_MAX || !(adspis & AVS_ADSP_ADSPIS_IPC))\n\t\treturn ret;\n\n\thipc_ack = snd_hdac_adsp_readl(adev, SKL_ADSP_REG_HIPCIE);\n\thipc_rsp = snd_hdac_adsp_readl(adev, SKL_ADSP_REG_HIPCT);\n\n\t \n\tif (hipc_ack & SKL_ADSP_HIPCIE_DONE) {\n\t\t \n\t\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCCTL,\n\t\t\t\t      AVS_ADSP_HIPCCTL_DONE, 0);\n\n\t\tcomplete(&ipc->done_completion);\n\n\t\t \n\t\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCIE,\n\t\t\t\t      SKL_ADSP_HIPCIE_DONE,\n\t\t\t\t      SKL_ADSP_HIPCIE_DONE);\n\t\t \n\t\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCCTL,\n\t\t\t\t      AVS_ADSP_HIPCCTL_DONE,\n\t\t\t\t      AVS_ADSP_HIPCCTL_DONE);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (hipc_rsp & SKL_ADSP_HIPCT_BUSY) {\n\t\t \n\t\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCCTL,\n\t\t\t\t      AVS_ADSP_HIPCCTL_BUSY, 0);\n\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nirqreturn_t avs_dsp_irq_thread(int irq, void *dev_id)\n{\n\tstruct avs_dev *adev = dev_id;\n\tunion avs_reply_msg msg;\n\tu32 hipct, hipcte;\n\n\thipct = snd_hdac_adsp_readl(adev, SKL_ADSP_REG_HIPCT);\n\thipcte = snd_hdac_adsp_readl(adev, SKL_ADSP_REG_HIPCTE);\n\n\t \n\tif (!(hipct & SKL_ADSP_HIPCT_BUSY))\n\t\treturn IRQ_NONE;\n\n\tmsg.primary = hipct;\n\tmsg.ext.val = hipcte;\n\tavs_dsp_process_response(adev, msg.val);\n\n\t \n\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCT,\n\t\t\t      SKL_ADSP_HIPCT_BUSY, SKL_ADSP_HIPCT_BUSY);\n\t \n\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCCTL,\n\t\t\t      AVS_ADSP_HIPCCTL_BUSY, AVS_ADSP_HIPCCTL_BUSY);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool avs_ipc_is_busy(struct avs_ipc *ipc)\n{\n\tstruct avs_dev *adev = to_avs_dev(ipc->dev);\n\tu32 hipc_rsp;\n\n\thipc_rsp = snd_hdac_adsp_readl(adev, SKL_ADSP_REG_HIPCT);\n\treturn hipc_rsp & SKL_ADSP_HIPCT_BUSY;\n}\n\nstatic int avs_ipc_wait_busy_completion(struct avs_ipc *ipc, int timeout)\n{\n\tu32 repeats_left = 128;  \n\tint ret;\n\nagain:\n\tret = wait_for_completion_timeout(&ipc->busy_completion, msecs_to_jiffies(timeout));\n\n\t \n\tif (!ipc->ready)\n\t\treturn -EPERM;\n\n\tif (!ret) {\n\t\tif (!avs_ipc_is_busy(ipc))\n\t\t\treturn -ETIMEDOUT;\n\t\t \n\t\twait_for_completion_killable(&ipc->busy_completion);\n\t}\n\n\t \n\tspin_lock(&ipc->rx_lock);\n\tif (!ipc->rx_completed) {\n\t\tif (repeats_left) {\n\t\t\t \n\t\t\trepeats_left--;\n\t\t\treinit_completion(&ipc->busy_completion);\n\t\t\tspin_unlock(&ipc->rx_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tspin_unlock(&ipc->rx_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_unlock(&ipc->rx_lock);\n\treturn 0;\n}\n\nstatic void avs_ipc_msg_init(struct avs_ipc *ipc, struct avs_ipc_msg *reply)\n{\n\tlockdep_assert_held(&ipc->rx_lock);\n\n\tipc->rx.header = 0;\n\tipc->rx.size = reply ? reply->size : 0;\n\tipc->rx_completed = false;\n\n\treinit_completion(&ipc->done_completion);\n\treinit_completion(&ipc->busy_completion);\n}\n\nstatic void avs_dsp_send_tx(struct avs_dev *adev, struct avs_ipc_msg *tx, bool read_fwregs)\n{\n\tu64 reg = ULONG_MAX;\n\n\ttx->header |= SKL_ADSP_HIPCI_BUSY;\n\tif (read_fwregs)\n\t\treg = readq(avs_sram_addr(adev, AVS_FW_REGS_WINDOW));\n\n\ttrace_avs_request(tx, reg);\n\n\tif (tx->size)\n\t\tmemcpy_toio(avs_downlink_addr(adev), tx->data, tx->size);\n\tsnd_hdac_adsp_writel(adev, SKL_ADSP_REG_HIPCIE, tx->header >> 32);\n\tsnd_hdac_adsp_writel(adev, SKL_ADSP_REG_HIPCI, tx->header & UINT_MAX);\n}\n\nstatic int avs_dsp_do_send_msg(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\t       struct avs_ipc_msg *reply, int timeout)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\tint ret;\n\n\tif (!ipc->ready)\n\t\treturn -EPERM;\n\n\tmutex_lock(&ipc->msg_mutex);\n\n\tspin_lock(&ipc->rx_lock);\n\tavs_ipc_msg_init(ipc, reply);\n\tavs_dsp_send_tx(adev, request, true);\n\tspin_unlock(&ipc->rx_lock);\n\n\tret = avs_ipc_wait_busy_completion(ipc, timeout);\n\tif (ret) {\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tunion avs_notify_msg msg = AVS_NOTIFICATION(EXCEPTION_CAUGHT);\n\n\t\t\t \n\t\t\tavs_dsp_exception_caught(adev, &msg);\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tret = ipc->rx.rsp.status;\n\tif (reply) {\n\t\treply->header = ipc->rx.header;\n\t\treply->size = ipc->rx.size;\n\t\tif (reply->data && ipc->rx.size)\n\t\t\tmemcpy(reply->data, ipc->rx.data, reply->size);\n\t}\n\nexit:\n\tmutex_unlock(&ipc->msg_mutex);\n\treturn ret;\n}\n\nstatic int avs_dsp_send_msg_sequence(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\t\t     struct avs_ipc_msg *reply, int timeout, bool wake_d0i0,\n\t\t\t\t     bool schedule_d0ix)\n{\n\tint ret;\n\n\ttrace_avs_d0ix(\"wake\", wake_d0i0, request->header);\n\tif (wake_d0i0) {\n\t\tret = avs_dsp_wake_d0i0(adev, request);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = avs_dsp_do_send_msg(adev, request, reply, timeout);\n\tif (ret)\n\t\treturn ret;\n\n\ttrace_avs_d0ix(\"schedule\", schedule_d0ix, request->header);\n\tif (schedule_d0ix)\n\t\tavs_dsp_schedule_d0ix(adev, request);\n\n\treturn 0;\n}\n\nint avs_dsp_send_msg_timeout(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\t     struct avs_ipc_msg *reply, int timeout)\n{\n\tbool wake_d0i0 = avs_dsp_op(adev, d0ix_toggle, request, true);\n\tbool schedule_d0ix = avs_dsp_op(adev, d0ix_toggle, request, false);\n\n\treturn avs_dsp_send_msg_sequence(adev, request, reply, timeout, wake_d0i0, schedule_d0ix);\n}\n\nint avs_dsp_send_msg(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t     struct avs_ipc_msg *reply)\n{\n\treturn avs_dsp_send_msg_timeout(adev, request, reply, adev->ipc->default_timeout_ms);\n}\n\nint avs_dsp_send_pm_msg_timeout(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\t\tstruct avs_ipc_msg *reply, int timeout, bool wake_d0i0)\n{\n\treturn avs_dsp_send_msg_sequence(adev, request, reply, timeout, wake_d0i0, false);\n}\n\nint avs_dsp_send_pm_msg(struct avs_dev *adev, struct avs_ipc_msg *request,\n\t\t\tstruct avs_ipc_msg *reply, bool wake_d0i0)\n{\n\treturn avs_dsp_send_pm_msg_timeout(adev, request, reply, adev->ipc->default_timeout_ms,\n\t\t\t\t\t   wake_d0i0);\n}\n\nstatic int avs_dsp_do_send_rom_msg(struct avs_dev *adev, struct avs_ipc_msg *request, int timeout)\n{\n\tstruct avs_ipc *ipc = adev->ipc;\n\tint ret;\n\n\tmutex_lock(&ipc->msg_mutex);\n\n\tspin_lock(&ipc->rx_lock);\n\tavs_ipc_msg_init(ipc, NULL);\n\t \n\tavs_dsp_send_tx(adev, request, false);\n\tspin_unlock(&ipc->rx_lock);\n\n\t \n\tret = avs_dsp_op(adev, stall, AVS_MAIN_CORE_MASK, false);\n\tif (!ret) {\n\t\tret = wait_for_completion_timeout(&ipc->done_completion, msecs_to_jiffies(timeout));\n\t\tret = ret ? 0 : -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&ipc->msg_mutex);\n\n\treturn ret;\n}\n\nint avs_dsp_send_rom_msg_timeout(struct avs_dev *adev, struct avs_ipc_msg *request, int timeout)\n{\n\treturn avs_dsp_do_send_rom_msg(adev, request, timeout);\n}\n\nint avs_dsp_send_rom_msg(struct avs_dev *adev, struct avs_ipc_msg *request)\n{\n\treturn avs_dsp_send_rom_msg_timeout(adev, request, adev->ipc->default_timeout_ms);\n}\n\nvoid avs_dsp_interrupt_control(struct avs_dev *adev, bool enable)\n{\n\tu32 value, mask;\n\n\t \n\tvalue = enable ? AVS_ADSP_ADSPIC_IPC : 0;\n\tsnd_hdac_adsp_updatel(adev, AVS_ADSP_REG_ADSPIC, AVS_ADSP_ADSPIC_IPC, value);\n\n\tmask = AVS_ADSP_HIPCCTL_DONE | AVS_ADSP_HIPCCTL_BUSY;\n\tvalue = enable ? mask : 0;\n\tsnd_hdac_adsp_updatel(adev, SKL_ADSP_REG_HIPCCTL, mask, value);\n}\n\nint avs_ipc_init(struct avs_ipc *ipc, struct device *dev)\n{\n\tipc->rx.data = devm_kzalloc(dev, AVS_MAILBOX_SIZE, GFP_KERNEL);\n\tif (!ipc->rx.data)\n\t\treturn -ENOMEM;\n\n\tipc->dev = dev;\n\tipc->ready = false;\n\tipc->default_timeout_ms = AVS_IPC_TIMEOUT_MS;\n\tINIT_WORK(&ipc->recovery_work, avs_dsp_recovery_work);\n\tINIT_DELAYED_WORK(&ipc->d0ix_work, avs_dsp_d0ix_work);\n\tinit_completion(&ipc->done_completion);\n\tinit_completion(&ipc->busy_completion);\n\tspin_lock_init(&ipc->rx_lock);\n\tmutex_init(&ipc->msg_mutex);\n\n\treturn 0;\n}\n\nvoid avs_ipc_block(struct avs_ipc *ipc)\n{\n\tipc->ready = false;\n\tcancel_work_sync(&ipc->recovery_work);\n\tcancel_delayed_work_sync(&ipc->d0ix_work);\n\tipc->in_d0ix = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}