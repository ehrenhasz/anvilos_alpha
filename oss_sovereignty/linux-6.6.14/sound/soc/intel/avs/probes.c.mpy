{
  "module_name": "probes.c",
  "hash_id": "1b57c733b7c4c83dee70110928dd541eafdbb9e24b0a0985ec1795e4797a1159",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/probes.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/compress_driver.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hdaudio.h>\n#include <sound/soc.h>\n#include \"avs.h\"\n#include \"messages.h\"\n\nstatic int avs_dsp_init_probe(struct avs_dev *adev, union avs_connector_node_id node_id,\n\t\t\t      size_t buffer_size)\n{\n\tstruct avs_probe_cfg cfg = {{0}};\n\tstruct avs_module_entry mentry;\n\tu8 dummy;\n\n\tavs_get_module_entry(adev, &AVS_PROBE_MOD_UUID, &mentry);\n\n\t \n\tcfg.base.ibs = 1;\n\t \n\tcfg.base.is_pages = mentry.segments[2].flags.length;\n\tcfg.gtw_cfg.node_id = node_id;\n\tcfg.gtw_cfg.dma_buffer_size = buffer_size;\n\n\treturn avs_dsp_init_module(adev, mentry.module_id, INVALID_PIPELINE_ID, 0, 0, &cfg,\n\t\t\t\t   sizeof(cfg), &dummy);\n}\n\nstatic void avs_dsp_delete_probe(struct avs_dev *adev)\n{\n\tstruct avs_module_entry mentry;\n\n\tavs_get_module_entry(adev, &AVS_PROBE_MOD_UUID, &mentry);\n\n\t \n\tavs_dsp_delete_module(adev, mentry.module_id, 0, INVALID_PIPELINE_ID, 0);\n}\n\nstatic inline struct hdac_ext_stream *avs_compr_get_host_stream(struct snd_compr_stream *cstream)\n{\n\treturn cstream->runtime->private_data;\n}\n\nstatic int avs_probe_compr_open(struct snd_compr_stream *cstream, struct snd_soc_dai *dai)\n{\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct hdac_ext_stream *host_stream;\n\n\tif (adev->extractor) {\n\t\tdev_err(dai->dev, \"Cannot open more than one extractor stream\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\thost_stream = snd_hdac_ext_cstream_assign(bus, cstream);\n\tif (!host_stream) {\n\t\tdev_err(dai->dev, \"Failed to assign HDAudio stream for extraction\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tadev->extractor = host_stream;\n\thdac_stream(host_stream)->curr_pos = 0;\n\tcstream->runtime->private_data = host_stream;\n\n\treturn 0;\n}\n\nstatic int avs_probe_compr_free(struct snd_compr_stream *cstream, struct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *host_stream = avs_compr_get_host_stream(cstream);\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct avs_probe_point_desc *desc;\n\t \n\tunsigned int vindex = INVALID_NODE_ID.vindex;\n\tsize_t num_desc;\n\tint i, ret;\n\n\t \n\tret = avs_ipc_probe_get_points(adev, &desc, &num_desc);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"get probe points failed: %d\\n\", ret);\n\t\tret = AVS_IPC_RET(ret);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < num_desc; i++)\n\t\tif (desc[i].node_id.vindex == vindex)\n\t\t\tavs_ipc_probe_disconnect_points(adev, &desc[i].id, 1);\n\tkfree(desc);\n\nexit:\n\tif (adev->num_probe_streams) {\n\t\tadev->num_probe_streams--;\n\t\tif (!adev->num_probe_streams) {\n\t\t\tavs_dsp_delete_probe(adev);\n\t\t\tavs_dsp_enable_d0ix(adev);\n\t\t}\n\t}\n\n\tsnd_hdac_stream_cleanup(hdac_stream(host_stream));\n\thdac_stream(host_stream)->prepared = 0;\n\tsnd_hdac_ext_stream_release(host_stream, HDAC_EXT_STREAM_TYPE_HOST);\n\n\tsnd_compr_free_pages(cstream);\n\tadev->extractor = NULL;\n\n\treturn ret;\n}\n\nstatic int avs_probe_compr_set_params(struct snd_compr_stream *cstream,\n\t\t\t\t      struct snd_compr_params *params, struct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *host_stream = avs_compr_get_host_stream(cstream);\n\tstruct snd_compr_runtime *rtd = cstream->runtime;\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\t \n\tsnd_pcm_format_t format = SNDRV_PCM_FORMAT_S32_LE;\n\tunsigned int format_val;\n\tint bps, ret;\n\n\thdac_stream(host_stream)->bufsize = 0;\n\thdac_stream(host_stream)->period_bytes = 0;\n\thdac_stream(host_stream)->format_val = 0;\n\tcstream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV_SG;\n\tcstream->dma_buffer.dev.dev = adev->dev;\n\n\tret = snd_compr_malloc_pages(cstream, rtd->buffer_size);\n\tif (ret < 0)\n\t\treturn ret;\n\tbps = snd_pcm_format_physical_width(format);\n\tif (bps < 0)\n\t\treturn bps;\n\tformat_val = snd_hdac_calc_stream_format(params->codec.sample_rate, params->codec.ch_out,\n\t\t\t\t\t\t format, bps, 0);\n\tret = snd_hdac_stream_set_params(hdac_stream(host_stream), format_val);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_hdac_stream_setup(hdac_stream(host_stream));\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdac_stream(host_stream)->prepared = 1;\n\n\tif (!adev->num_probe_streams) {\n\t\tunion avs_connector_node_id node_id;\n\n\t\t \n\t\tret = avs_dsp_disable_d0ix(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnode_id.vindex = hdac_stream(host_stream)->stream_tag - 1;\n\t\tnode_id.dma_type = AVS_DMA_HDA_HOST_INPUT;\n\n\t\tret = avs_dsp_init_probe(adev, node_id, rtd->dma_bytes);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"probe init failed: %d\\n\", ret);\n\t\t\tavs_dsp_enable_d0ix(adev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tadev->num_probe_streams++;\n\treturn 0;\n}\n\nstatic int avs_probe_compr_trigger(struct snd_compr_stream *cstream, int cmd,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *host_stream = avs_compr_get_host_stream(cstream);\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct hdac_bus *bus = &adev->base.core;\n\tunsigned long cookie;\n\n\tif (!hdac_stream(host_stream)->prepared)\n\t\treturn -EPIPE;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tspin_lock_irqsave(&bus->reg_lock, cookie);\n\t\tsnd_hdac_stream_start(hdac_stream(host_stream));\n\t\tspin_unlock_irqrestore(&bus->reg_lock, cookie);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock_irqsave(&bus->reg_lock, cookie);\n\t\tsnd_hdac_stream_stop(hdac_stream(host_stream));\n\t\tspin_unlock_irqrestore(&bus->reg_lock, cookie);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_probe_compr_pointer(struct snd_compr_stream *cstream,\n\t\t\t\t   struct snd_compr_tstamp *tstamp, struct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *host_stream = avs_compr_get_host_stream(cstream);\n\tstruct snd_soc_pcm_stream *pstream;\n\n\tpstream = &dai->driver->capture;\n\ttstamp->copied_total = hdac_stream(host_stream)->curr_pos;\n\ttstamp->sampling_rate = snd_pcm_rate_bit_to_rate(pstream->rates);\n\n\treturn 0;\n}\n\nstatic int avs_probe_compr_copy(struct snd_soc_component *comp, struct snd_compr_stream *cstream,\n\t\t\t\tchar __user *buf, size_t count)\n{\n\tstruct snd_compr_runtime *rtd = cstream->runtime;\n\tunsigned int offset, n;\n\tvoid *ptr;\n\tint ret;\n\n\tif (count > rtd->buffer_size)\n\t\tcount = rtd->buffer_size;\n\n\tdiv_u64_rem(rtd->total_bytes_transferred, rtd->buffer_size, &offset);\n\tptr = rtd->dma_area + offset;\n\tn = rtd->buffer_size - offset;\n\n\tif (count < n) {\n\t\tret = copy_to_user(buf, ptr, count);\n\t} else {\n\t\tret = copy_to_user(buf, ptr, n);\n\t\tret += copy_to_user(buf + n, rtd->dma_area, count - n);\n\t}\n\n\tif (ret)\n\t\treturn count - ret;\n\treturn count;\n}\n\nstatic const struct snd_soc_cdai_ops avs_probe_cdai_ops = {\n\t.startup = avs_probe_compr_open,\n\t.shutdown = avs_probe_compr_free,\n\t.set_params = avs_probe_compr_set_params,\n\t.trigger = avs_probe_compr_trigger,\n\t.pointer = avs_probe_compr_pointer,\n};\n\nstatic const struct snd_soc_dai_ops avs_probe_dai_ops = {\n\t.compress_new = snd_soc_new_compress,\n};\n\nstatic const struct snd_compress_ops avs_probe_compress_ops = {\n\t.copy = avs_probe_compr_copy,\n};\n\nstatic struct snd_soc_dai_driver probe_cpu_dais[] = {\n{\n\t.name = \"Probe Extraction CPU DAI\",\n\t.cops = &avs_probe_cdai_ops,\n\t.ops  = &avs_probe_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"Probe Extraction\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.rate_min = 48000,\n\t\t.rate_max = 48000,\n\t},\n},\n};\n\nstatic const struct snd_soc_component_driver avs_probe_component_driver = {\n\t.name\t\t\t= \"avs-probe-compr\",\n\t.compress_ops\t\t= &avs_probe_compress_ops,\n\t.module_get_upon_open\t= 1,  \n};\n\nint avs_probe_platform_register(struct avs_dev *adev, const char *name)\n{\n\treturn avs_soc_component_register(adev->dev, name, &avs_probe_component_driver,\n\t\t\t\t\t  probe_cpu_dais, ARRAY_SIZE(probe_cpu_dais));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}