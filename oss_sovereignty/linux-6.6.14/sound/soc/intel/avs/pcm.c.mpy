{
  "module_name": "pcm.c",
  "hash_id": "a471c192ac359e7e782501b30e0e47b668a094d9f6f3c1a61eed2511cfe2dc94",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <sound/hda_register.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/pcm_params.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/soc-component.h>\n#include \"avs.h\"\n#include \"path.h\"\n#include \"topology.h\"\n\nstruct avs_dma_data {\n\tstruct avs_tplg_path_template *template;\n\tstruct avs_path *path;\n\t \n\tstruct hdac_ext_stream *host_stream;\n\n\tstruct snd_pcm_substream *substream;\n};\n\nstatic struct avs_tplg_path_template *\navs_dai_find_path_template(struct snd_soc_dai *dai, bool is_fe, int direction)\n{\n\tstruct snd_soc_dapm_widget *dw = snd_soc_dai_get_widget(dai, direction);\n\tstruct snd_soc_dapm_path *dp;\n\tenum snd_soc_dapm_direction dir;\n\n\tif (direction == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tdir = is_fe ? SND_SOC_DAPM_DIR_OUT : SND_SOC_DAPM_DIR_IN;\n\t} else {\n\t\tdir = is_fe ? SND_SOC_DAPM_DIR_IN : SND_SOC_DAPM_DIR_OUT;\n\t}\n\n\tdp = list_first_entry_or_null(&dw->edges[dir], typeof(*dp), list_node[dir]);\n\tif (!dp)\n\t\treturn NULL;\n\n\t \n\tdw = (dp->source == dw) ? dp->sink : dp->source;\n\n\treturn dw->priv;\n}\n\nstatic int avs_dai_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai, bool is_fe,\n\t\t\t   const struct snd_soc_dai_ops *ops)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct avs_tplg_path_template *template;\n\tstruct avs_dma_data *data;\n\n\ttemplate = avs_dai_find_path_template(dai, is_fe, substream->stream);\n\tif (!template) {\n\t\tdev_err(dai->dev, \"no %s path for dai %s, invalid tplg?\\n\",\n\t\t\tsnd_pcm_stream_str(substream), dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->substream = substream;\n\tdata->template = template;\n\tsnd_soc_dai_set_dma_data(dai, substream, data);\n\n\tif (rtd->dai_link->ignore_suspend)\n\t\tadev->num_lp_paths++;\n\n\treturn 0;\n}\n\nstatic int avs_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *fe_hw_params,\n\t\t\t     struct snd_pcm_hw_params *be_hw_params, struct snd_soc_dai *dai,\n\t\t\t     int dma_id)\n{\n\tstruct avs_dma_data *data;\n\tstruct avs_path *path;\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tint ret;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\n\tdev_dbg(dai->dev, \"%s FE hw_params str %p rtd %p\",\n\t\t__func__, substream, substream->runtime);\n\tdev_dbg(dai->dev, \"rate %d chn %d vbd %d bd %d\\n\",\n\t\tparams_rate(fe_hw_params), params_channels(fe_hw_params),\n\t\tparams_width(fe_hw_params), params_physical_width(fe_hw_params));\n\n\tdev_dbg(dai->dev, \"%s BE hw_params str %p rtd %p\",\n\t\t__func__, substream, substream->runtime);\n\tdev_dbg(dai->dev, \"rate %d chn %d vbd %d bd %d\\n\",\n\t\tparams_rate(be_hw_params), params_channels(be_hw_params),\n\t\tparams_width(be_hw_params), params_physical_width(be_hw_params));\n\n\tpath = avs_path_create(adev, dma_id, data->template, fe_hw_params, be_hw_params);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tdev_err(dai->dev, \"create path failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->path = path;\n\treturn 0;\n}\n\nstatic int avs_dai_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *be_hw_params, struct snd_soc_dai *dai,\n\t\t\t\tint dma_id)\n{\n\tstruct snd_pcm_hw_params *fe_hw_params = NULL;\n\tstruct snd_soc_pcm_runtime *fe, *be;\n\tstruct snd_soc_dpcm *dpcm;\n\n\tbe = asoc_substream_to_rtd(substream);\n\tfor_each_dpcm_fe(be, substream->stream, dpcm) {\n\t\tfe = dpcm->fe;\n\t\tfe_hw_params = &fe->dpcm[substream->stream].hw_params;\n\t}\n\n\treturn avs_dai_hw_params(substream, fe_hw_params, be_hw_params, dai, dma_id);\n}\n\nstatic int avs_dai_prepare(struct avs_dev *adev, struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\tint ret;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (!data->path)\n\t\treturn 0;\n\n\tret = avs_path_reset(data->path);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"reset path failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = avs_path_pause(data->path);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"pause path failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops avs_dai_nonhda_be_ops;\n\nstatic int avs_dai_nonhda_be_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\treturn avs_dai_startup(substream, dai, false, &avs_dai_nonhda_be_ops);\n}\n\nstatic void avs_dai_nonhda_be_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct avs_dma_data *data;\n\n\tif (rtd->dai_link->ignore_suspend)\n\t\tadev->num_lp_paths--;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n\tkfree(data);\n}\n\nstatic int avs_dai_nonhda_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_hw_params *hw_params, struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (data->path)\n\t\treturn 0;\n\n\t \n\treturn avs_dai_be_hw_params(substream, hw_params, dai, 0);\n}\n\nstatic int avs_dai_nonhda_be_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (data->path) {\n\t\tavs_path_free(data->path);\n\t\tdata->path = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_dai_nonhda_be_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\treturn avs_dai_prepare(to_avs_dev(dai->dev), substream, dai);\n}\n\nstatic int avs_dai_nonhda_be_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dma_data *data;\n\tint ret = 0;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"pause BE path failed: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = avs_path_run(data->path, AVS_TPLG_TRIGGER_AUTO);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"run BE path failed: %d\\n\", ret);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"pause BE path failed: %d\\n\", ret);\n\n\t\tret = avs_path_reset(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"reset BE path failed: %d\\n\", ret);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops avs_dai_nonhda_be_ops = {\n\t.startup = avs_dai_nonhda_be_startup,\n\t.shutdown = avs_dai_nonhda_be_shutdown,\n\t.hw_params = avs_dai_nonhda_be_hw_params,\n\t.hw_free = avs_dai_nonhda_be_hw_free,\n\t.prepare = avs_dai_nonhda_be_prepare,\n\t.trigger = avs_dai_nonhda_be_trigger,\n};\n\nstatic const struct snd_soc_dai_ops avs_dai_hda_be_ops;\n\nstatic int avs_dai_hda_be_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\treturn avs_dai_startup(substream, dai, false, &avs_dai_hda_be_ops);\n}\n\nstatic void avs_dai_hda_be_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\treturn avs_dai_nonhda_be_shutdown(substream, dai);\n}\n\nstatic int avs_dai_hda_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params, struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\tstruct hdac_ext_stream *link_stream;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (data->path)\n\t\treturn 0;\n\n\tlink_stream = substream->runtime->private_data;\n\n\treturn avs_dai_be_hw_params(substream, hw_params, dai,\n\t\t\t\t    hdac_stream(link_stream)->stream_tag - 1);\n}\n\nstatic int avs_dai_hda_be_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct hdac_ext_stream *link_stream;\n\tstruct hdac_ext_link *link;\n\tstruct hda_codec *codec;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (!data->path)\n\t\treturn 0;\n\n\tlink_stream = substream->runtime->private_data;\n\tlink_stream->link_prepared = false;\n\tavs_path_free(data->path);\n\tdata->path = NULL;\n\n\t \n\tcodec = dev_to_hda_codec(asoc_rtd_to_codec(rtd, 0)->dev);\n\tlink = snd_hdac_ext_bus_get_hlink_by_addr(&codec->bus->core, codec->core.addr);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_hdac_ext_bus_link_clear_stream_id(link, hdac_stream(link_stream)->stream_tag);\n\n\treturn 0;\n}\n\nstatic int avs_dai_hda_be_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct hdac_ext_stream *link_stream = runtime->private_data;\n\tstruct hdac_ext_link *link;\n\tstruct hda_codec *codec;\n\tstruct hdac_bus *bus;\n\tunsigned int format_val;\n\tint ret;\n\n\tif (link_stream->link_prepared)\n\t\treturn 0;\n\n\tcodec = dev_to_hda_codec(asoc_rtd_to_codec(rtd, 0)->dev);\n\tbus = &codec->bus->core;\n\tformat_val = snd_hdac_calc_stream_format(runtime->rate, runtime->channels, runtime->format,\n\t\t\t\t\t\t runtime->sample_bits, 0);\n\n\tsnd_hdac_ext_stream_decouple(bus, link_stream, true);\n\tsnd_hdac_ext_stream_reset(link_stream);\n\tsnd_hdac_ext_stream_setup(link_stream, format_val);\n\n\tlink = snd_hdac_ext_bus_get_hlink_by_addr(bus, codec->core.addr);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_hdac_ext_bus_link_set_stream_id(link, hdac_stream(link_stream)->stream_tag);\n\n\tret = avs_dai_prepare(to_avs_dev(dai->dev), substream, dai);\n\tif (ret)\n\t\treturn ret;\n\n\tlink_stream->link_prepared = true;\n\treturn 0;\n}\n\nstatic int avs_dai_hda_be_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct hdac_ext_stream *link_stream;\n\tstruct avs_dma_data *data;\n\tint ret = 0;\n\n\tdev_dbg(dai->dev, \"entry %s cmd=%d\\n\", __func__, cmd);\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tlink_stream = substream->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_hdac_ext_stream_start(link_stream);\n\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"pause BE path failed: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = avs_path_run(data->path, AVS_TPLG_TRIGGER_AUTO);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"run BE path failed: %d\\n\", ret);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"pause BE path failed: %d\\n\", ret);\n\n\t\tsnd_hdac_ext_stream_clear(link_stream);\n\n\t\tret = avs_path_reset(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"reset BE path failed: %d\\n\", ret);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops avs_dai_hda_be_ops = {\n\t.startup = avs_dai_hda_be_startup,\n\t.shutdown = avs_dai_hda_be_shutdown,\n\t.hw_params = avs_dai_hda_be_hw_params,\n\t.hw_free = avs_dai_hda_be_hw_free,\n\t.prepare = avs_dai_hda_be_prepare,\n\t.trigger = avs_dai_hda_be_trigger,\n};\n\nstatic const unsigned int rates[] = {\n\t8000, 11025, 12000, 16000,\n\t22050, 24000, 32000, 44100,\n\t48000, 64000, 88200, 96000,\n\t128000, 176400, 192000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nconst struct snd_soc_dai_ops avs_dai_fe_ops;\n\nstatic int avs_dai_fe_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct avs_dma_data *data;\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct hdac_bus *bus = &adev->base.core;\n\tstruct hdac_ext_stream *host_stream;\n\tint ret;\n\n\tret = avs_dai_startup(substream, dai, true, &avs_dai_fe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\n\thost_stream = snd_hdac_ext_stream_assign(bus, substream, HDAC_EXT_STREAM_TYPE_HOST);\n\tif (!host_stream) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tdata->host_stream = host_stream;\n\tret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME, 20, 178000000);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_rates);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsnd_pcm_set_sync(substream);\n\n\tdev_dbg(dai->dev, \"%s fe STARTUP tag %d str %p\",\n\t\t__func__, hdac_stream(host_stream)->stream_tag, substream);\n\n\treturn 0;\n\nerr:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic void avs_dai_fe_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct avs_dma_data *data;\n\n\tif (rtd->dai_link->ignore_suspend)\n\t\tadev->num_lp_paths--;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n\tsnd_hdac_ext_stream_release(data->host_stream, HDAC_EXT_STREAM_TYPE_HOST);\n\tkfree(data);\n}\n\nstatic int avs_dai_fe_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *hw_params, struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_hw_params *be_hw_params = NULL;\n\tstruct snd_soc_pcm_runtime *fe, *be;\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct avs_dma_data *data;\n\tstruct hdac_ext_stream *host_stream;\n\tint ret;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (data->path)\n\t\treturn 0;\n\n\thost_stream = data->host_stream;\n\n\thdac_stream(host_stream)->bufsize = 0;\n\thdac_stream(host_stream)->period_bytes = 0;\n\thdac_stream(host_stream)->format_val = 0;\n\n\tfe = asoc_substream_to_rtd(substream);\n\tfor_each_dpcm_be(fe, substream->stream, dpcm) {\n\t\tbe = dpcm->be;\n\t\tbe_hw_params = &be->dpcm[substream->stream].hw_params;\n\t}\n\n\tret = avs_dai_hw_params(substream, hw_params, be_hw_params, dai,\n\t\t\t\thdac_stream(host_stream)->stream_tag - 1);\n\tif (ret)\n\t\tgoto create_err;\n\n\tret = avs_path_bind(data->path);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"bind FE <-> BE failed: %d\\n\", ret);\n\t\tgoto bind_err;\n\t}\n\n\treturn 0;\n\nbind_err:\n\tavs_path_free(data->path);\n\tdata->path = NULL;\ncreate_err:\n\tsnd_pcm_lib_free_pages(substream);\n\treturn ret;\n}\n\nstatic int __avs_dai_fe_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct avs_dma_data *data;\n\tstruct hdac_ext_stream *host_stream;\n\tint ret;\n\n\tdev_dbg(dai->dev, \"%s fe HW_FREE str %p rtd %p\",\n\t\t__func__, substream, substream->runtime);\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\tif (!data->path)\n\t\treturn 0;\n\n\thost_stream = data->host_stream;\n\n\tret = avs_path_unbind(data->path);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"unbind FE <-> BE failed: %d\\n\", ret);\n\n\tavs_path_free(data->path);\n\tdata->path = NULL;\n\tsnd_hdac_stream_cleanup(hdac_stream(host_stream));\n\thdac_stream(host_stream)->prepared = false;\n\n\treturn ret;\n}\n\nstatic int avs_dai_fe_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tint ret;\n\n\tret = __avs_dai_fe_hw_free(substream, dai);\n\tsnd_pcm_lib_free_pages(substream);\n\n\treturn ret;\n}\n\nstatic int avs_dai_fe_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct avs_dma_data *data;\n\tstruct avs_dev *adev = to_avs_dev(dai->dev);\n\tstruct hdac_ext_stream *host_stream;\n\tstruct hdac_bus *bus;\n\tunsigned int format_val;\n\tint ret;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\thost_stream = data->host_stream;\n\n\tif (hdac_stream(host_stream)->prepared)\n\t\treturn 0;\n\n\tbus = hdac_stream(host_stream)->bus;\n\tsnd_hdac_ext_stream_decouple(bus, data->host_stream, true);\n\tsnd_hdac_stream_reset(hdac_stream(host_stream));\n\n\tformat_val = snd_hdac_calc_stream_format(runtime->rate, runtime->channels, runtime->format,\n\t\t\t\t\t\t runtime->sample_bits, 0);\n\n\tret = snd_hdac_stream_set_params(hdac_stream(host_stream), format_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_hdac_stream_setup(hdac_stream(host_stream));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = avs_dai_prepare(adev, substream, dai);\n\tif (ret)\n\t\treturn ret;\n\n\thdac_stream(host_stream)->prepared = true;\n\treturn 0;\n}\n\nstatic int avs_dai_fe_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dma_data *data;\n\tstruct hdac_ext_stream *host_stream;\n\tstruct hdac_bus *bus;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdata = snd_soc_dai_get_dma_data(dai, substream);\n\thost_stream = data->host_stream;\n\tbus = hdac_stream(host_stream)->bus;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&bus->reg_lock, flags);\n\t\tsnd_hdac_stream_start(hdac_stream(host_stream));\n\t\tspin_unlock_irqrestore(&bus->reg_lock, flags);\n\n\t\t \n\t\tif (cmd == SNDRV_PCM_TRIGGER_RESUME)\n\t\t\tsnd_hdac_stream_wait_drsm(hdac_stream(host_stream));\n\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"pause FE path failed: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = avs_path_run(data->path, AVS_TPLG_TRIGGER_AUTO);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"run FE path failed: %d\\n\", ret);\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = avs_path_pause(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"pause FE path failed: %d\\n\", ret);\n\n\t\tspin_lock_irqsave(&bus->reg_lock, flags);\n\t\tsnd_hdac_stream_stop(hdac_stream(host_stream));\n\t\tspin_unlock_irqrestore(&bus->reg_lock, flags);\n\n\t\tret = avs_path_reset(data->path);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"reset FE path failed: %d\\n\", ret);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nconst struct snd_soc_dai_ops avs_dai_fe_ops = {\n\t.startup = avs_dai_fe_startup,\n\t.shutdown = avs_dai_fe_shutdown,\n\t.hw_params = avs_dai_fe_hw_params,\n\t.hw_free = avs_dai_fe_hw_free,\n\t.prepare = avs_dai_fe_prepare,\n\t.trigger = avs_dai_fe_trigger,\n};\n\nstatic ssize_t topology_name_read(struct file *file, char __user *user_buf, size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct snd_soc_component *component = file->private_data;\n\tstruct snd_soc_card *card = component->card;\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(card->dev);\n\tchar buf[64];\n\tsize_t len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%s/%s\\n\", component->driver->topology_name_prefix,\n\t\t\tmach->tplg_filename);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations topology_name_fops = {\n\t.open = simple_open,\n\t.read = topology_name_read,\n\t.llseek = default_llseek,\n};\n\nstatic int avs_component_load_libraries(struct avs_soc_component *acomp)\n{\n\tstruct avs_tplg *tplg = acomp->tplg;\n\tstruct avs_dev *adev = to_avs_dev(acomp->base.dev);\n\tint ret;\n\n\tif (!tplg->num_libs)\n\t\treturn 0;\n\n\t \n\tret = pm_runtime_resume_and_get(adev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tavs_hda_power_gating_enable(adev, false);\n\tavs_hda_clock_gating_enable(adev, false);\n\tavs_hda_l1sen_enable(adev, false);\n\n\tret = avs_dsp_load_libraries(adev, tplg->libs, tplg->num_libs);\n\n\tavs_hda_l1sen_enable(adev, true);\n\tavs_hda_clock_gating_enable(adev, true);\n\tavs_hda_power_gating_enable(adev, true);\n\n\tif (!ret)\n\t\tret = avs_module_info_init(adev, false);\n\n\tpm_runtime_mark_last_busy(adev->dev);\n\tpm_runtime_put_autosuspend(adev->dev);\n\n\treturn ret;\n}\n\nstatic int avs_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = component->card;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct avs_soc_component *acomp;\n\tstruct avs_dev *adev;\n\tchar *filename;\n\tint ret;\n\n\tdev_dbg(card->dev, \"probing %s card %s\\n\", component->name, card->name);\n\tmach = dev_get_platdata(card->dev);\n\tacomp = to_avs_soc_component(component);\n\tadev = to_avs_dev(component->dev);\n\n\tacomp->tplg = avs_tplg_new(component);\n\tif (!acomp->tplg)\n\t\treturn -ENOMEM;\n\n\tif (!mach->tplg_filename)\n\t\tgoto finalize;\n\n\t \n\tfilename = kasprintf(GFP_KERNEL, \"%s/%s\", component->driver->topology_name_prefix,\n\t\t\t     mach->tplg_filename);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\tret = avs_load_topology(component, filename);\n\tkfree(filename);\n\tif (ret == -ENOENT && !strncmp(mach->tplg_filename, \"hda-\", 4)) {\n\t\tunsigned int vendor_id;\n\n\t\tif (sscanf(mach->tplg_filename, \"hda-%08x-tplg.bin\", &vendor_id) != 1)\n\t\t\treturn ret;\n\n\t\tif (((vendor_id >> 16) & 0xFFFF) == 0x8086)\n\t\t\tmach->tplg_filename = devm_kasprintf(adev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t     \"hda-8086-generic-tplg.bin\");\n\t\telse\n\t\t\tmach->tplg_filename = devm_kasprintf(adev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t     \"hda-generic-tplg.bin\");\n\n\t\tfilename = kasprintf(GFP_KERNEL, \"%s/%s\", component->driver->topology_name_prefix,\n\t\t\t\t     mach->tplg_filename);\n\t\tif (!filename)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_info(card->dev, \"trying to load fallback topology %s\\n\", mach->tplg_filename);\n\t\tret = avs_load_topology(component, filename);\n\t\tkfree(filename);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = avs_component_load_libraries(acomp);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"libraries loading failed: %d\\n\", ret);\n\t\tgoto err_load_libs;\n\t}\n\nfinalize:\n\tdebugfs_create_file(\"topology_name\", 0444, component->debugfs_root, component,\n\t\t\t    &topology_name_fops);\n\n\tmutex_lock(&adev->comp_list_mutex);\n\tlist_add_tail(&acomp->node, &adev->comp_list);\n\tmutex_unlock(&adev->comp_list_mutex);\n\n\treturn 0;\n\nerr_load_libs:\n\tavs_remove_topology(component);\n\treturn ret;\n}\n\nstatic void avs_component_remove(struct snd_soc_component *component)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(component);\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct avs_dev *adev = to_avs_dev(component->dev);\n\tint ret;\n\n\tmach = dev_get_platdata(component->card->dev);\n\n\tmutex_lock(&adev->comp_list_mutex);\n\tlist_del(&acomp->node);\n\tmutex_unlock(&adev->comp_list_mutex);\n\n\tif (mach->tplg_filename) {\n\t\tret = avs_remove_topology(component);\n\t\tif (ret < 0)\n\t\t\tdev_err(component->dev, \"unload topology failed: %d\\n\", ret);\n\t}\n}\n\nstatic int avs_dai_resume_hw_params(struct snd_soc_dai *dai, struct avs_dma_data *data)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint ret;\n\n\tsubstream = data->substream;\n\trtd = asoc_substream_to_rtd(substream);\n\n\tret = dai->driver->ops->hw_params(substream, &rtd->dpcm[substream->stream].hw_params, dai);\n\tif (ret)\n\t\tdev_err(dai->dev, \"hw_params on resume failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int avs_dai_resume_fe_prepare(struct snd_soc_dai *dai, struct avs_dma_data *data)\n{\n\tstruct hdac_ext_stream *host_stream;\n\tstruct hdac_stream *hstream;\n\tstruct hdac_bus *bus;\n\tint ret;\n\n\thost_stream = data->host_stream;\n\thstream = hdac_stream(host_stream);\n\tbus = hdac_stream(host_stream)->bus;\n\n\t \n\tsnd_hdac_stream_drsm_enable(bus, true, hstream->index);\n\n\tret = dai->driver->ops->prepare(data->substream, dai);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"prepare FE on resume failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twritel(host_stream->pphcllpl, host_stream->pphc_addr + AZX_REG_PPHCLLPL);\n\twritel(host_stream->pphcllpu, host_stream->pphc_addr + AZX_REG_PPHCLLPU);\n\twritel(host_stream->pphcldpl, host_stream->pphc_addr + AZX_REG_PPHCLDPL);\n\twritel(host_stream->pphcldpu, host_stream->pphc_addr + AZX_REG_PPHCLDPU);\n\n\t \n\tsnd_hdac_stream_set_lpib(hstream, hstream->lpib);\n\tsnd_hdac_stream_set_dpibr(bus, hstream, hstream->lpib);\n\n\treturn 0;\n}\n\nstatic int avs_dai_resume_be_prepare(struct snd_soc_dai *dai, struct avs_dma_data *data)\n{\n\tint ret;\n\n\tret = dai->driver->ops->prepare(data->substream, dai);\n\tif (ret)\n\t\tdev_err(dai->dev, \"prepare BE on resume failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int avs_dai_suspend_fe_hw_free(struct snd_soc_dai *dai, struct avs_dma_data *data)\n{\n\tstruct hdac_ext_stream *host_stream;\n\tint ret;\n\n\thost_stream = data->host_stream;\n\n\t \n\thdac_stream(host_stream)->lpib = snd_hdac_stream_get_pos_lpib(hdac_stream(host_stream));\n\thost_stream->pphcllpl = readl(host_stream->pphc_addr + AZX_REG_PPHCLLPL);\n\thost_stream->pphcllpu = readl(host_stream->pphc_addr + AZX_REG_PPHCLLPU);\n\thost_stream->pphcldpl = readl(host_stream->pphc_addr + AZX_REG_PPHCLDPL);\n\thost_stream->pphcldpu = readl(host_stream->pphc_addr + AZX_REG_PPHCLDPU);\n\n\tret = __avs_dai_fe_hw_free(data->substream, dai);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"hw_free FE on suspend failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int avs_dai_suspend_be_hw_free(struct snd_soc_dai *dai, struct avs_dma_data *data)\n{\n\tint ret;\n\n\tret = dai->driver->ops->hw_free(data->substream, dai);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"hw_free BE on suspend failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int avs_component_pm_op(struct snd_soc_component *component, bool be,\n\t\t\t       int (*op)(struct snd_soc_dai *, struct avs_dma_data *))\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct avs_dma_data *data;\n\tstruct snd_soc_dai *dai;\n\tint ret;\n\n\tfor_each_component_dais(component, dai) {\n\t\tdata = snd_soc_dai_dma_data_get_playback(dai);\n\t\tif (data) {\n\t\t\trtd = asoc_substream_to_rtd(data->substream);\n\t\t\tif (rtd->dai_link->no_pcm == be && !rtd->dai_link->ignore_suspend) {\n\t\t\t\tret = op(dai, data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\t__snd_pcm_set_state(data->substream->runtime,\n\t\t\t\t\t\t\t    SNDRV_PCM_STATE_DISCONNECTED);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdata = snd_soc_dai_dma_data_get_capture(dai);\n\t\tif (data) {\n\t\t\trtd = asoc_substream_to_rtd(data->substream);\n\t\t\tif (rtd->dai_link->no_pcm == be && !rtd->dai_link->ignore_suspend) {\n\t\t\t\tret = op(dai, data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\t__snd_pcm_set_state(data->substream->runtime,\n\t\t\t\t\t\t\t    SNDRV_PCM_STATE_DISCONNECTED);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_component_resume_hw_params(struct snd_soc_component *component, bool be)\n{\n\treturn avs_component_pm_op(component, be, &avs_dai_resume_hw_params);\n}\n\nstatic int avs_component_resume_prepare(struct snd_soc_component *component, bool be)\n{\n\tint (*prepare_cb)(struct snd_soc_dai *dai, struct avs_dma_data *data);\n\n\tif (be)\n\t\tprepare_cb = &avs_dai_resume_be_prepare;\n\telse\n\t\tprepare_cb = &avs_dai_resume_fe_prepare;\n\n\treturn avs_component_pm_op(component, be, prepare_cb);\n}\n\nstatic int avs_component_suspend_hw_free(struct snd_soc_component *component, bool be)\n{\n\tint (*hw_free_cb)(struct snd_soc_dai *dai, struct avs_dma_data *data);\n\n\tif (be)\n\t\thw_free_cb = &avs_dai_suspend_be_hw_free;\n\telse\n\t\thw_free_cb = &avs_dai_suspend_fe_hw_free;\n\n\treturn avs_component_pm_op(component, be, hw_free_cb);\n}\n\nstatic int avs_component_suspend(struct snd_soc_component *component)\n{\n\tint ret;\n\n\t \n\tret = avs_component_suspend_hw_free(component, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn avs_component_suspend_hw_free(component, true);\n}\n\nstatic int avs_component_resume(struct snd_soc_component *component)\n{\n\tint ret;\n\n\t \n\tret = avs_component_resume_hw_params(component, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = avs_component_resume_hw_params(component, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = avs_component_resume_prepare(component, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn avs_component_resume_prepare(component, false);\n}\n\nstatic const struct snd_pcm_hardware avs_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t  SNDRV_PCM_INFO_RESUME |\n\t\t\t\t  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t.buffer_bytes_max\t= AZX_MAX_BUF_SIZE,\n\t.period_bytes_min\t= 128,\n\t.period_bytes_max\t= AZX_MAX_BUF_SIZE / 2,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= AZX_MAX_FRAG,\n\t.fifo_size\t\t= 0,\n};\n\nstatic int avs_component_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\treturn snd_soc_set_runtime_hwparams(substream, &avs_pcm_hardware);\n}\n\nstatic unsigned int avs_hda_stream_dpib_read(struct hdac_ext_stream *stream)\n{\n\treturn readl(hdac_stream(stream)->bus->remap_addr + AZX_REG_VS_SDXDPIB_XBASE +\n\t\t     (AZX_REG_VS_SDXDPIB_XINTERVAL * hdac_stream(stream)->index));\n}\n\nstatic snd_pcm_uframes_t\navs_component_pointer(struct snd_soc_component *component, struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct avs_dma_data *data;\n\tstruct hdac_ext_stream *host_stream;\n\tunsigned int pos;\n\n\tdata = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tif (!data->host_stream)\n\t\treturn 0;\n\n\thost_stream = data->host_stream;\n\tpos = avs_hda_stream_dpib_read(host_stream);\n\n\tif (pos >= hdac_stream(host_stream)->bufsize)\n\t\tpos = 0;\n\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic int avs_component_mmap(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t      struct vm_area_struct *vma)\n{\n\treturn snd_pcm_lib_default_mmap(substream, vma);\n}\n\n#define MAX_PREALLOC_SIZE\t(32 * 1024 * 1024)\n\nstatic int avs_component_construct(struct snd_soc_component *component,\n\t\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_pcm *pcm = rtd->pcm;\n\n\tif (dai->driver->playback.channels_min)\n\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_DEV_SG, component->dev, 0,\n\t\t\t\t\t   MAX_PREALLOC_SIZE);\n\n\tif (dai->driver->capture.channels_min)\n\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_DEV_SG, component->dev, 0,\n\t\t\t\t\t   MAX_PREALLOC_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver avs_component_driver = {\n\t.name\t\t\t= \"avs-pcm\",\n\t.probe\t\t\t= avs_component_probe,\n\t.remove\t\t\t= avs_component_remove,\n\t.suspend\t\t= avs_component_suspend,\n\t.resume\t\t\t= avs_component_resume,\n\t.open\t\t\t= avs_component_open,\n\t.pointer\t\t= avs_component_pointer,\n\t.mmap\t\t\t= avs_component_mmap,\n\t.pcm_construct\t\t= avs_component_construct,\n\t.module_get_upon_open\t= 1,  \n\t.topology_name_prefix\t= \"intel/avs\",\n};\n\nint avs_soc_component_register(struct device *dev, const char *name,\n\t\t\t       const struct snd_soc_component_driver *drv,\n\t\t\t       struct snd_soc_dai_driver *cpu_dais, int num_cpu_dais)\n{\n\tstruct avs_soc_component *acomp;\n\tint ret;\n\n\tacomp = devm_kzalloc(dev, sizeof(*acomp), GFP_KERNEL);\n\tif (!acomp)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_component_initialize(&acomp->base, drv, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tacomp->base.name = name;\n\tINIT_LIST_HEAD(&acomp->node);\n\n\treturn snd_soc_add_component(&acomp->base, cpu_dais, num_cpu_dais);\n}\n\nstatic struct snd_soc_dai_driver dmic_cpu_dais[] = {\n{\n\t.name = \"DMIC Pin\",\n\t.ops = &avs_dai_nonhda_be_ops,\n\t.capture = {\n\t\t.stream_name\t= \"DMIC Rx\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 4,\n\t\t.rates\t\t= SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_48000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name = \"DMIC WoV Pin\",\n\t.ops = &avs_dai_nonhda_be_ops,\n\t.capture = {\n\t\t.stream_name\t= \"DMIC WoV Rx\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 4,\n\t\t.rates\t\t= SNDRV_PCM_RATE_16000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n};\n\nint avs_dmic_platform_register(struct avs_dev *adev, const char *name)\n{\n\treturn avs_soc_component_register(adev->dev, name, &avs_component_driver, dmic_cpu_dais,\n\t\t\t\t\t  ARRAY_SIZE(dmic_cpu_dais));\n}\n\nstatic const struct snd_soc_dai_driver i2s_dai_template = {\n\t.ops = &avs_dai_nonhda_be_ops,\n\t.playback = {\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000 |\n\t\t\t\t  SNDRV_PCM_RATE_KNOT,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000 |\n\t\t\t\t  SNDRV_PCM_RATE_KNOT,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n};\n\nint avs_i2s_platform_register(struct avs_dev *adev, const char *name, unsigned long port_mask,\n\t\t\t      unsigned long *tdms)\n{\n\tstruct snd_soc_dai_driver *cpus, *dai;\n\tsize_t ssp_count, cpu_count;\n\tint i, j;\n\n\tssp_count = adev->hw_cfg.i2s_caps.ctrl_count;\n\tcpu_count = hweight_long(port_mask);\n\tif (tdms)\n\t\tfor_each_set_bit(i, &port_mask, ssp_count)\n\t\t\tcpu_count += hweight_long(tdms[i]);\n\n\tcpus = devm_kzalloc(adev->dev, sizeof(*cpus) * cpu_count, GFP_KERNEL);\n\tif (!cpus)\n\t\treturn -ENOMEM;\n\n\tdai = cpus;\n\tfor_each_set_bit(i, &port_mask, ssp_count) {\n\t\tmemcpy(dai, &i2s_dai_template, sizeof(*dai));\n\n\t\tdai->name =\n\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"SSP%d Pin\", i);\n\t\tdai->playback.stream_name =\n\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"ssp%d Tx\", i);\n\t\tdai->capture.stream_name =\n\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"ssp%d Rx\", i);\n\n\t\tif (!dai->name || !dai->playback.stream_name || !dai->capture.stream_name)\n\t\t\treturn -ENOMEM;\n\t\tdai++;\n\t}\n\n\tif (!tdms)\n\t\tgoto plat_register;\n\n\tfor_each_set_bit(i, &port_mask, ssp_count) {\n\t\tfor_each_set_bit(j, &tdms[i], ssp_count) {\n\t\t\tmemcpy(dai, &i2s_dai_template, sizeof(*dai));\n\n\t\t\tdai->name =\n\t\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"SSP%d:%d Pin\", i, j);\n\t\t\tdai->playback.stream_name =\n\t\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"ssp%d:%d Tx\", i, j);\n\t\t\tdai->capture.stream_name =\n\t\t\t\tdevm_kasprintf(adev->dev, GFP_KERNEL, \"ssp%d:%d Rx\", i, j);\n\n\t\t\tif (!dai->name || !dai->playback.stream_name || !dai->capture.stream_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdai++;\n\t\t}\n\t}\n\nplat_register:\n\treturn avs_soc_component_register(adev->dev, name, &avs_component_driver, cpus, cpu_count);\n}\n\n \nstatic const struct snd_soc_dai_driver hda_cpu_dai = {\n\t.ops = &avs_dai_hda_be_ops,\n\t.playback = {\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n};\n\nstatic void avs_component_hda_unregister_dais(struct snd_soc_component *component)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct snd_soc_dai *dai, *save;\n\tstruct hda_codec *codec;\n\tchar name[32];\n\n\tmach = dev_get_platdata(component->card->dev);\n\tcodec = mach->pdata;\n\tsprintf(name, \"%s-cpu\", dev_name(&codec->core.dev));\n\n\tfor_each_component_dais_safe(component, dai, save) {\n\t\tint stream;\n\n\t\tif (!strstr(dai->driver->name, name))\n\t\t\tcontinue;\n\n\t\tfor_each_pcm_streams(stream)\n\t\t\tsnd_soc_dapm_free_widget(snd_soc_dai_get_widget(dai, stream));\n\n\t\tsnd_soc_unregister_dai(dai);\n\t}\n}\n\nstatic int avs_component_hda_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct snd_soc_dai_driver *dais;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct hda_codec *codec;\n\tstruct hda_pcm *pcm;\n\tconst char *cname;\n\tint pcm_count = 0, ret, i;\n\n\tmach = dev_get_platdata(component->card->dev);\n\tif (!mach)\n\t\treturn -EINVAL;\n\n\tcodec = mach->pdata;\n\tif (list_empty(&codec->pcm_list_head))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list)\n\t\tpcm_count++;\n\n\tdais = devm_kcalloc(component->dev, pcm_count, sizeof(*dais),\n\t\t\t    GFP_KERNEL);\n\tif (!dais)\n\t\treturn -ENOMEM;\n\n\tcname = dev_name(&codec->core.dev);\n\tdapm = snd_soc_component_get_dapm(component);\n\tpcm = list_first_entry(&codec->pcm_list_head, struct hda_pcm, list);\n\n\tfor (i = 0; i < pcm_count; i++, pcm = list_next_entry(pcm, list)) {\n\t\tstruct snd_soc_dai *dai;\n\n\t\tmemcpy(&dais[i], &hda_cpu_dai, sizeof(*dais));\n\t\tdais[i].id = i;\n\t\tdais[i].name = devm_kasprintf(component->dev, GFP_KERNEL,\n\t\t\t\t\t      \"%s-cpu%d\", cname, i);\n\t\tif (!dais[i].name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pcm->stream[0].substreams) {\n\t\t\tdais[i].playback.stream_name =\n\t\t\t\tdevm_kasprintf(component->dev, GFP_KERNEL,\n\t\t\t\t\t       \"%s-cpu%d Tx\", cname, i);\n\t\t\tif (!dais[i].playback.stream_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (pcm->stream[1].substreams) {\n\t\t\tdais[i].capture.stream_name =\n\t\t\t\tdevm_kasprintf(component->dev, GFP_KERNEL,\n\t\t\t\t\t       \"%s-cpu%d Rx\", cname, i);\n\t\t\tif (!dais[i].capture.stream_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tdai = snd_soc_register_dai(component, &dais[i], false);\n\t\tif (!dai) {\n\t\t\tdev_err(component->dev, \"register dai for %s failed\\n\",\n\t\t\t\tpcm->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = snd_soc_dapm_new_dai_widgets(dapm, dai);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"create widgets failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = avs_component_probe(component);\nexit:\n\tif (ret)\n\t\tavs_component_hda_unregister_dais(component);\n\n\treturn ret;\n}\n\nstatic void avs_component_hda_remove(struct snd_soc_component *component)\n{\n\tavs_component_hda_unregister_dais(component);\n\tavs_component_remove(component);\n}\n\nstatic int avs_component_hda_open(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct hdac_ext_stream *link_stream;\n\tstruct hda_codec *codec;\n\n\tif (!rtd->dai_link->no_pcm) {\n\t\tstruct snd_pcm_hardware hwparams = avs_pcm_hardware;\n\t\tstruct snd_soc_pcm_runtime *be;\n\t\tstruct snd_soc_dpcm *dpcm;\n\t\tint dir = substream->stream;\n\n\t\t \n\t\tfor_each_dpcm_be(rtd, dir, dpcm) {\n\t\t\tstruct snd_pcm_substream *be_substream;\n\n\t\t\tbe = dpcm->be;\n\t\t\tif (be->dpcm[dir].users == 1)\n\t\t\t\tbreak;\n\n\t\t\tbe_substream = snd_soc_dpcm_get_substream(be, dir);\n\t\t\tsubstream->runtime->private_data = be_substream->runtime->private_data;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dir == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\thwparams.info &= ~SNDRV_PCM_INFO_RESUME;\n\n\t\treturn snd_soc_set_runtime_hwparams(substream, &hwparams);\n\t}\n\n\tcodec = dev_to_hda_codec(asoc_rtd_to_codec(rtd, 0)->dev);\n\tlink_stream = snd_hdac_ext_stream_assign(&codec->bus->core, substream,\n\t\t\t\t\t     HDAC_EXT_STREAM_TYPE_LINK);\n\tif (!link_stream)\n\t\treturn -EBUSY;\n\n\tsubstream->runtime->private_data = link_stream;\n\treturn 0;\n}\n\nstatic int avs_component_hda_close(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct hdac_ext_stream *link_stream;\n\n\t \n\tif (!rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tlink_stream = substream->runtime->private_data;\n\tsnd_hdac_ext_stream_release(link_stream, HDAC_EXT_STREAM_TYPE_LINK);\n\tsubstream->runtime->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver avs_hda_component_driver = {\n\t.name\t\t\t= \"avs-hda-pcm\",\n\t.probe\t\t\t= avs_component_hda_probe,\n\t.remove\t\t\t= avs_component_hda_remove,\n\t.suspend\t\t= avs_component_suspend,\n\t.resume\t\t\t= avs_component_resume,\n\t.open\t\t\t= avs_component_hda_open,\n\t.close\t\t\t= avs_component_hda_close,\n\t.pointer\t\t= avs_component_pointer,\n\t.mmap\t\t\t= avs_component_mmap,\n\t.pcm_construct\t\t= avs_component_construct,\n\t \n\t.probe_order\t\t= SND_SOC_COMP_ORDER_LATE,\n\t.remove_order\t\t= SND_SOC_COMP_ORDER_EARLY,\n\t.module_get_upon_open\t= 1,\n\t.topology_name_prefix\t= \"intel/avs\",\n};\n\nint avs_hda_platform_register(struct avs_dev *adev, const char *name)\n{\n\treturn avs_soc_component_register(adev->dev, name,\n\t\t\t\t\t  &avs_hda_component_driver, NULL, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}