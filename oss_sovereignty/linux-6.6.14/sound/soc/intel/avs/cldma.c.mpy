{
  "module_name": "cldma.c",
  "hash_id": "b004fd1beafb26f67f4dec9180c81a7735261bec8a071f023f3b7ec40f4d0a52",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/cldma.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/pci.h>\n#include <sound/hda_register.h>\n#include <sound/hdaudio_ext.h>\n#include \"cldma.h\"\n#include \"registers.h\"\n\n \n#define AZX_CL_SD_BASE\t\t\t0x80\n#define AZX_SD_CTL_STRM_MASK\t\tGENMASK(23, 20)\n#define AZX_SD_CTL_STRM(s)\t\t(((s)->stream_tag << 20) & AZX_SD_CTL_STRM_MASK)\n#define AZX_SD_BDLPL_BDLPLBA_MASK\tGENMASK(31, 7)\n#define AZX_SD_BDLPL_BDLPLBA(lb)\t((lb) & AZX_SD_BDLPL_BDLPLBA_MASK)\n\n \n#define AZX_CL_SPBFCS\t\t\t0x20\n#define AZX_REG_CL_SPBFCTL\t\t(AZX_CL_SPBFCS + 0x4)\n#define AZX_REG_CL_SD_SPIB\t\t(AZX_CL_SPBFCS + 0x8)\n\n#define AVS_CL_OP_INTERVAL_US\t\t3\n#define AVS_CL_OP_TIMEOUT_US\t\t300\n#define AVS_CL_IOC_TIMEOUT_MS\t\t300\n#define AVS_CL_STREAM_INDEX\t\t0\n\nstruct hda_cldma {\n\tstruct device *dev;\n\tstruct hdac_bus *bus;\n\tvoid __iomem *dsp_ba;\n\n\tunsigned int buffer_size;\n\tunsigned int num_periods;\n\tunsigned int stream_tag;\n\tvoid __iomem *sd_addr;\n\n\tstruct snd_dma_buffer dmab_data;\n\tstruct snd_dma_buffer dmab_bdl;\n\tstruct delayed_work memcpy_work;\n\tstruct completion completion;\n\n\t \n\tvoid *position;\n\tunsigned int remaining;\n\tunsigned int sd_status;\n};\n\nstatic void cldma_memcpy_work(struct work_struct *work);\n\nstruct hda_cldma code_loader = {\n\t.stream_tag\t= AVS_CL_STREAM_INDEX + 1,\n\t.memcpy_work\t= __DELAYED_WORK_INITIALIZER(code_loader.memcpy_work, cldma_memcpy_work, 0),\n\t.completion\t= COMPLETION_INITIALIZER(code_loader.completion),\n};\n\nvoid hda_cldma_fill(struct hda_cldma *cl)\n{\n\tunsigned int size, offset;\n\n\tif (cl->remaining > cl->buffer_size)\n\t\tsize = cl->buffer_size;\n\telse\n\t\tsize = cl->remaining;\n\n\toffset = snd_hdac_stream_readl(cl, CL_SD_SPIB);\n\tif (offset + size > cl->buffer_size) {\n\t\tunsigned int ss;\n\n\t\tss = cl->buffer_size - offset;\n\t\tmemcpy(cl->dmab_data.area + offset, cl->position, ss);\n\t\toffset = 0;\n\t\tsize -= ss;\n\t\tcl->position += ss;\n\t\tcl->remaining -= ss;\n\t}\n\n\tmemcpy(cl->dmab_data.area + offset, cl->position, size);\n\tcl->position += size;\n\tcl->remaining -= size;\n\n\tsnd_hdac_stream_writel(cl, CL_SD_SPIB, offset + size);\n}\n\nstatic void cldma_memcpy_work(struct work_struct *work)\n{\n\tstruct hda_cldma *cl = container_of(work, struct hda_cldma, memcpy_work.work);\n\tint ret;\n\n\tret = hda_cldma_start(cl);\n\tif (ret < 0) {\n\t\tdev_err(cl->dev, \"cldma set RUN failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\twhile (true) {\n\t\tret = wait_for_completion_timeout(&cl->completion,\n\t\t\t\t\t\t  msecs_to_jiffies(AVS_CL_IOC_TIMEOUT_MS));\n\t\tif (!ret) {\n\t\t\tdev_err(cl->dev, \"cldma IOC timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(cl->sd_status & SD_INT_COMPLETE)) {\n\t\t\tdev_err(cl->dev, \"cldma transfer error, SD status: 0x%08x\\n\",\n\t\t\t\tcl->sd_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cl->remaining)\n\t\t\tbreak;\n\n\t\treinit_completion(&cl->completion);\n\t\thda_cldma_fill(cl);\n\t\t \n\t\tsnd_hdac_adsp_updatel(cl, AVS_ADSP_REG_ADSPIC, AVS_ADSP_ADSPIC_CLDMA,\n\t\t\t\t      AVS_ADSP_ADSPIC_CLDMA);\n\t}\n}\n\nvoid hda_cldma_transfer(struct hda_cldma *cl, unsigned long start_delay)\n{\n\tif (!cl->remaining)\n\t\treturn;\n\n\treinit_completion(&cl->completion);\n\t \n\thda_cldma_fill(cl);\n\n\tschedule_delayed_work(&cl->memcpy_work, start_delay);\n}\n\nint hda_cldma_start(struct hda_cldma *cl)\n{\n\tunsigned int reg;\n\n\t \n\tsnd_hdac_adsp_updatel(cl, AVS_ADSP_REG_ADSPIC, AVS_ADSP_ADSPIC_CLDMA,\n\t\t\t      AVS_ADSP_ADSPIC_CLDMA);\n\tsnd_hdac_stream_updateb(cl, SD_CTL, SD_INT_MASK | SD_CTL_DMA_START,\n\t\t\t\tSD_INT_MASK | SD_CTL_DMA_START);\n\n\t \n\treturn snd_hdac_stream_readb_poll(cl, SD_CTL, reg, reg & SD_CTL_DMA_START,\n\t\t\t\t\t  AVS_CL_OP_INTERVAL_US, AVS_CL_OP_TIMEOUT_US);\n}\n\nint hda_cldma_stop(struct hda_cldma *cl)\n{\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tsnd_hdac_adsp_updatel(cl, AVS_ADSP_REG_ADSPIC, AVS_ADSP_ADSPIC_CLDMA, 0);\n\tsnd_hdac_stream_updateb(cl, SD_CTL, SD_INT_MASK | SD_CTL_DMA_START, 0);\n\n\t \n\tret = snd_hdac_stream_readb_poll(cl, SD_CTL, reg, !(reg & SD_CTL_DMA_START),\n\t\t\t\t\t AVS_CL_OP_INTERVAL_US, AVS_CL_OP_TIMEOUT_US);\n\tcancel_delayed_work_sync(&cl->memcpy_work);\n\n\treturn ret;\n}\n\nint hda_cldma_reset(struct hda_cldma *cl)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = hda_cldma_stop(cl);\n\tif (ret < 0) {\n\t\tdev_err(cl->dev, \"cldma stop failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_hdac_stream_updateb(cl, SD_CTL, SD_CTL_STREAM_RESET, SD_CTL_STREAM_RESET);\n\tret = snd_hdac_stream_readb_poll(cl, SD_CTL, reg, (reg & SD_CTL_STREAM_RESET),\n\t\t\t\t\t AVS_CL_OP_INTERVAL_US, AVS_CL_OP_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(cl->dev, \"cldma set SRST failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_hdac_stream_updateb(cl, SD_CTL, SD_CTL_STREAM_RESET, 0);\n\tret = snd_hdac_stream_readb_poll(cl, SD_CTL, reg, !(reg & SD_CTL_STREAM_RESET),\n\t\t\t\t\t AVS_CL_OP_INTERVAL_US, AVS_CL_OP_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(cl->dev, \"cldma unset SRST failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid hda_cldma_set_data(struct hda_cldma *cl, void *data, unsigned int size)\n{\n\t \n\tcl->position = data;\n\tcl->remaining = size;\n}\n\nstatic void cldma_setup_bdle(struct hda_cldma *cl, u32 bdle_size)\n{\n\tstruct snd_dma_buffer *dmab = &cl->dmab_data;\n\t__le32 *bdl = (__le32 *)cl->dmab_bdl.area;\n\tint remaining = cl->buffer_size;\n\tint offset = 0;\n\n\tcl->num_periods = 0;\n\n\twhile (remaining > 0) {\n\t\tphys_addr_t addr;\n\t\tint chunk;\n\n\t\taddr = snd_sgbuf_get_addr(dmab, offset);\n\t\tbdl[0] = cpu_to_le32(lower_32_bits(addr));\n\t\tbdl[1] = cpu_to_le32(upper_32_bits(addr));\n\t\tchunk = snd_sgbuf_get_chunk_size(dmab, offset, bdle_size);\n\t\tbdl[2] = cpu_to_le32(chunk);\n\n\t\tremaining -= chunk;\n\t\t \n\t\tbdl[3] = (remaining > 0) ? 0 : cpu_to_le32(0x01);\n\n\t\tbdl += 4;\n\t\toffset += chunk;\n\t\tcl->num_periods++;\n\t}\n}\n\nvoid hda_cldma_setup(struct hda_cldma *cl)\n{\n\tdma_addr_t bdl_addr = cl->dmab_bdl.addr;\n\n\tcldma_setup_bdle(cl, cl->buffer_size / 2);\n\n\tsnd_hdac_stream_writel(cl, SD_BDLPL, AZX_SD_BDLPL_BDLPLBA(lower_32_bits(bdl_addr)));\n\tsnd_hdac_stream_writel(cl, SD_BDLPU, upper_32_bits(bdl_addr));\n\n\tsnd_hdac_stream_writel(cl, SD_CBL, cl->buffer_size);\n\tsnd_hdac_stream_writeb(cl, SD_LVI, cl->num_periods - 1);\n\n\tsnd_hdac_stream_updatel(cl, SD_CTL, AZX_SD_CTL_STRM_MASK, AZX_SD_CTL_STRM(cl));\n\t \n\tsnd_hdac_stream_writel(cl, CL_SPBFCTL, 1);\n}\n\nstatic irqreturn_t cldma_irq_handler(int irq, void *dev_id)\n{\n\tstruct hda_cldma *cl = dev_id;\n\tu32 adspis;\n\n\tadspis = snd_hdac_adsp_readl(cl, AVS_ADSP_REG_ADSPIS);\n\tif (adspis == UINT_MAX)\n\t\treturn IRQ_NONE;\n\tif (!(adspis & AVS_ADSP_ADSPIS_CLDMA))\n\t\treturn IRQ_NONE;\n\n\tcl->sd_status = snd_hdac_stream_readb(cl, SD_STS);\n\tdev_warn(cl->dev, \"%s sd_status: 0x%08x\\n\", __func__, cl->sd_status);\n\n\t \n\tsnd_hdac_adsp_updatel(cl, AVS_ADSP_REG_ADSPIC, AVS_ADSP_ADSPIC_CLDMA, 0);\n\n\tcomplete(&cl->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nint hda_cldma_init(struct hda_cldma *cl, struct hdac_bus *bus, void __iomem *dsp_ba,\n\t\t   unsigned int buffer_size)\n{\n\tstruct pci_dev *pci = to_pci_dev(bus->dev);\n\tint ret;\n\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG, bus->dev, buffer_size, &cl->dmab_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, bus->dev, BDL_SIZE, &cl->dmab_bdl);\n\tif (ret < 0)\n\t\tgoto alloc_err;\n\n\tcl->dev = bus->dev;\n\tcl->bus = bus;\n\tcl->dsp_ba = dsp_ba;\n\tcl->buffer_size = buffer_size;\n\tcl->sd_addr = dsp_ba + AZX_CL_SD_BASE;\n\n\tret = pci_request_irq(pci, 0, cldma_irq_handler, NULL, cl, \"CLDMA\");\n\tif (ret < 0) {\n\t\tdev_err(cl->dev, \"Failed to request CLDMA IRQ handler: %d\\n\", ret);\n\t\tgoto req_err;\n\t}\n\n\treturn 0;\n\nreq_err:\n\tsnd_dma_free_pages(&cl->dmab_bdl);\nalloc_err:\n\tsnd_dma_free_pages(&cl->dmab_data);\n\n\treturn ret;\n}\n\nvoid hda_cldma_free(struct hda_cldma *cl)\n{\n\tstruct pci_dev *pci = to_pci_dev(cl->dev);\n\n\tpci_free_irq(pci, 0, cl);\n\tsnd_dma_free_pages(&cl->dmab_data);\n\tsnd_dma_free_pages(&cl->dmab_bdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}