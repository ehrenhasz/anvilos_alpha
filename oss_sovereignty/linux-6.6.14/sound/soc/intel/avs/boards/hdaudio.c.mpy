{
  "module_name": "hdaudio.c",
  "hash_id": "72c94f20fcdcb0c0900dfca875787f8e71938605c3dc61c4a0d0d594929bc575",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/boards/hdaudio.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_i915.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"../../../codecs/hda.h\"\n\nstatic int avs_create_dai_links(struct device *dev, struct hda_codec *codec, int pcm_count,\n\t\t\t\tconst char *platform_name, struct snd_soc_dai_link **links)\n{\n\tstruct snd_soc_dai_link_component *platform;\n\tstruct snd_soc_dai_link *dl;\n\tstruct hda_pcm *pcm;\n\tconst char *cname = dev_name(&codec->core.dev);\n\tint i;\n\n\tdl = devm_kcalloc(dev, pcm_count, sizeof(*dl), GFP_KERNEL);\n\tplatform = devm_kzalloc(dev, sizeof(*platform), GFP_KERNEL);\n\tif (!dl || !platform)\n\t\treturn -ENOMEM;\n\n\tplatform->name = platform_name;\n\tpcm = list_first_entry(&codec->pcm_list_head, struct hda_pcm, list);\n\n\tfor (i = 0; i < pcm_count; i++, pcm = list_next_entry(pcm, list)) {\n\t\tdl[i].name = devm_kasprintf(dev, GFP_KERNEL, \"%s link%d\", cname, i);\n\t\tif (!dl[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tdl[i].id = i;\n\t\tdl[i].nonatomic = 1;\n\t\tdl[i].no_pcm = 1;\n\t\tdl[i].dpcm_playback = 1;\n\t\tdl[i].dpcm_capture = 1;\n\t\tdl[i].platforms = platform;\n\t\tdl[i].num_platforms = 1;\n\t\tdl[i].ignore_pmdown_time = 1;\n\n\t\tdl[i].codecs = devm_kzalloc(dev, sizeof(*dl->codecs), GFP_KERNEL);\n\t\tdl[i].cpus = devm_kzalloc(dev, sizeof(*dl->cpus), GFP_KERNEL);\n\t\tif (!dl[i].codecs || !dl[i].cpus)\n\t\t\treturn -ENOMEM;\n\n\t\tdl[i].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL, \"%s-cpu%d\", cname, i);\n\t\tif (!dl[i].cpus->dai_name)\n\t\t\treturn -ENOMEM;\n\n\t\tdl[i].codecs->name = devm_kstrdup(dev, cname, GFP_KERNEL);\n\t\tif (!dl[i].codecs->name)\n\t\t\treturn -ENOMEM;\n\n\t\tdl[i].codecs->dai_name = pcm->name;\n\t\tdl[i].num_codecs = 1;\n\t\tdl[i].num_cpus = 1;\n\t}\n\n\t*links = dl;\n\treturn 0;\n}\n\n \n#define FEDAI_NAME_PREFIX \"HDMI\"\n\nstatic struct snd_pcm *\navs_card_hdmi_pcm_at(struct snd_soc_card *card, int hdmi_idx)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint dir = SNDRV_PCM_STREAM_PLAYBACK;\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tstruct snd_pcm *spcm;\n\t\tint ret, n;\n\n\t\tspcm = rtd->pcm ? rtd->pcm->streams[dir].pcm : NULL;\n\t\tif (!spcm || !strstr(spcm->id, FEDAI_NAME_PREFIX))\n\t\t\tcontinue;\n\n\t\tret = sscanf(spcm->id, FEDAI_NAME_PREFIX \"%d\", &n);\n\t\tif (ret != 1)\n\t\t\tcontinue;\n\t\tif (n == hdmi_idx)\n\t\t\treturn rtd->pcm;\n\t}\n\n\treturn NULL;\n}\n\nstatic int avs_card_late_probe(struct snd_soc_card *card)\n{\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(card->dev);\n\tstruct hda_codec *codec = mach->pdata;\n\tstruct hda_pcm *hpcm;\n\t \n\tint i = 1;\n\n\tlist_for_each_entry(hpcm, &codec->pcm_list_head, list) {\n\t\tstruct snd_pcm *spcm;\n\n\t\tspcm = avs_card_hdmi_pcm_at(card, i);\n\t\tif (spcm) {\n\t\t\thpcm->pcm = spcm;\n\t\t\thpcm->device = spcm->device;\n\t\t\tdev_info(card->dev, \"%s: mapping HDMI converter %d to PCM %d (%p)\\n\",\n\t\t\t\t __func__, i, hpcm->device, spcm);\n\t\t} else {\n\t\t\thpcm->pcm = NULL;\n\t\t\thpcm->device = SNDRV_PCM_INVALID_DEVICE;\n\t\t\tdev_warn(card->dev, \"%s: no PCM in topology for HDMI converter %d\\n\",\n\t\t\t\t __func__, i);\n\t\t}\n\t\ti++;\n\t}\n\n\treturn hda_codec_probe_complete(codec);\n}\n\nstatic int avs_probing_link_init(struct snd_soc_pcm_runtime *rtm)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct snd_soc_dai_link *links = NULL;\n\tstruct snd_soc_card *card = rtm->card;\n\tstruct hda_codec *codec;\n\tstruct hda_pcm *pcm;\n\tint ret, pcm_count = 0;\n\n\tmach = dev_get_platdata(card->dev);\n\tcodec = mach->pdata;\n\n\tif (list_empty(&codec->pcm_list_head))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list)\n\t\tpcm_count++;\n\n\tret = avs_create_dai_links(card->dev, codec, pcm_count, mach->mach_params.platform, &links);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"create links failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_pcm_runtimes(card, links, pcm_count);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"add links failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nSND_SOC_DAILINK_DEF(dummy, DAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nstatic struct snd_soc_dai_link probing_link = {\n\t.name = \"probing-LINK\",\n\t.id = -1,\n\t.nonatomic = 1,\n\t.no_pcm = 1,\n\t.dpcm_playback = 1,\n\t.dpcm_capture = 1,\n\t.cpus = dummy,\n\t.num_cpus = ARRAY_SIZE(dummy),\n\t.init = avs_probing_link_init,\n};\n\nstatic int avs_hdaudio_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_dai_link *binder;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct snd_soc_card *card;\n\tstruct device *dev = &pdev->dev;\n\tstruct hda_codec *codec;\n\n\tmach = dev_get_platdata(dev);\n\tcodec = mach->pdata;\n\n\t \n\tif (!device_is_registered(&codec->core.dev))\n\t\treturn -ENODEV;\n\n\tbinder = devm_kmemdup(dev, &probing_link, sizeof(probing_link), GFP_KERNEL);\n\tif (!binder)\n\t\treturn -ENOMEM;\n\n\tbinder->platforms = devm_kzalloc(dev, sizeof(*binder->platforms), GFP_KERNEL);\n\tbinder->codecs = devm_kzalloc(dev, sizeof(*binder->codecs), GFP_KERNEL);\n\tif (!binder->platforms || !binder->codecs)\n\t\treturn -ENOMEM;\n\n\tbinder->codecs->name = devm_kstrdup(dev, dev_name(&codec->core.dev), GFP_KERNEL);\n\tif (!binder->codecs->name)\n\t\treturn -ENOMEM;\n\n\tbinder->platforms->name = mach->mach_params.platform;\n\tbinder->num_platforms = 1;\n\tbinder->codecs->dai_name = \"codec-probing-DAI\";\n\tbinder->num_codecs = 1;\n\n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->name = binder->codecs->name;\n\tcard->dev = dev;\n\tcard->owner = THIS_MODULE;\n\tcard->dai_link = binder;\n\tcard->num_links = 1;\n\tcard->fully_routed = true;\n\tif (hda_codec_is_display(codec))\n\t\tcard->late_probe = avs_card_late_probe;\n\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic struct platform_driver avs_hdaudio_driver = {\n\t.probe = avs_hdaudio_probe,\n\t.driver = {\n\t\t.name = \"avs_hdaudio\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(avs_hdaudio_driver)\n\nMODULE_DESCRIPTION(\"Intel HD-Audio machine driver\");\nMODULE_AUTHOR(\"Cezary Rojewski <cezary.rojewski@intel.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:avs_hdaudio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}