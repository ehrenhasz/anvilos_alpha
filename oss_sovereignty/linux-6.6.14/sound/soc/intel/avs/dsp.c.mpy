{
  "module_name": "dsp.c",
  "hash_id": "35d2871fa6c772fdefb0f0cba6c63b053a3a351048c29f6eea6a79e98f7b3313",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/dsp.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/hdaudio_ext.h>\n#include \"avs.h\"\n#include \"registers.h\"\n#include \"trace.h\"\n\n#define AVS_ADSPCS_INTERVAL_US\t\t500\n#define AVS_ADSPCS_TIMEOUT_US\t\t50000\n#define AVS_ADSPCS_DELAY_US\t\t1000\n\nint avs_dsp_core_power(struct avs_dev *adev, u32 core_mask, bool power)\n{\n\tu32 value, mask, reg;\n\tint ret;\n\n\tvalue = snd_hdac_adsp_readl(adev, AVS_ADSP_REG_ADSPCS);\n\ttrace_avs_dsp_core_op(value, core_mask, \"power\", power);\n\n\tmask = AVS_ADSPCS_SPA_MASK(core_mask);\n\tvalue = power ? mask : 0;\n\n\tsnd_hdac_adsp_updatel(adev, AVS_ADSP_REG_ADSPCS, mask, value);\n\t \n\tusleep_range(AVS_ADSPCS_DELAY_US, 2 * AVS_ADSPCS_DELAY_US);\n\n\tmask = AVS_ADSPCS_CPA_MASK(core_mask);\n\tvalue = power ? mask : 0;\n\n\tret = snd_hdac_adsp_readl_poll(adev, AVS_ADSP_REG_ADSPCS,\n\t\t\t\t       reg, (reg & mask) == value,\n\t\t\t\t       AVS_ADSPCS_INTERVAL_US,\n\t\t\t\t       AVS_ADSPCS_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(adev->dev, \"core_mask %d power %s failed: %d\\n\",\n\t\t\tcore_mask, power ? \"on\" : \"off\", ret);\n\n\treturn ret;\n}\n\nint avs_dsp_core_reset(struct avs_dev *adev, u32 core_mask, bool reset)\n{\n\tu32 value, mask, reg;\n\tint ret;\n\n\tvalue = snd_hdac_adsp_readl(adev, AVS_ADSP_REG_ADSPCS);\n\ttrace_avs_dsp_core_op(value, core_mask, \"reset\", reset);\n\n\tmask = AVS_ADSPCS_CRST_MASK(core_mask);\n\tvalue = reset ? mask : 0;\n\n\tsnd_hdac_adsp_updatel(adev, AVS_ADSP_REG_ADSPCS, mask, value);\n\n\tret = snd_hdac_adsp_readl_poll(adev, AVS_ADSP_REG_ADSPCS,\n\t\t\t\t       reg, (reg & mask) == value,\n\t\t\t\t       AVS_ADSPCS_INTERVAL_US,\n\t\t\t\t       AVS_ADSPCS_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(adev->dev, \"core_mask %d %s reset failed: %d\\n\",\n\t\t\tcore_mask, reset ? \"enter\" : \"exit\", ret);\n\n\treturn ret;\n}\n\nint avs_dsp_core_stall(struct avs_dev *adev, u32 core_mask, bool stall)\n{\n\tu32 value, mask, reg;\n\tint ret;\n\n\tvalue = snd_hdac_adsp_readl(adev, AVS_ADSP_REG_ADSPCS);\n\ttrace_avs_dsp_core_op(value, core_mask, \"stall\", stall);\n\n\tmask = AVS_ADSPCS_CSTALL_MASK(core_mask);\n\tvalue = stall ? mask : 0;\n\n\tsnd_hdac_adsp_updatel(adev, AVS_ADSP_REG_ADSPCS, mask, value);\n\n\tret = snd_hdac_adsp_readl_poll(adev, AVS_ADSP_REG_ADSPCS,\n\t\t\t\t       reg, (reg & mask) == value,\n\t\t\t\t       AVS_ADSPCS_INTERVAL_US,\n\t\t\t\t       AVS_ADSPCS_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"core_mask %d %sstall failed: %d\\n\",\n\t\t\tcore_mask, stall ? \"\" : \"un\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(AVS_ADSPCS_DELAY_US, 2 * AVS_ADSPCS_DELAY_US);\n\treturn 0;\n}\n\nint avs_dsp_core_enable(struct avs_dev *adev, u32 core_mask)\n{\n\tint ret;\n\n\tret = avs_dsp_op(adev, power, core_mask, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = avs_dsp_op(adev, reset, core_mask, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn avs_dsp_op(adev, stall, core_mask, false);\n}\n\nint avs_dsp_core_disable(struct avs_dev *adev, u32 core_mask)\n{\n\t \n\tavs_dsp_op(adev, stall, core_mask, true);\n\tavs_dsp_op(adev, reset, core_mask, true);\n\n\treturn avs_dsp_op(adev, power, core_mask, false);\n}\n\nstatic int avs_dsp_enable(struct avs_dev *adev, u32 core_mask)\n{\n\tu32 mask;\n\tint ret;\n\n\tret = avs_dsp_core_enable(adev, core_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmask = core_mask & ~AVS_MAIN_CORE_MASK;\n\tif (!mask)\n\t\t \n\t\treturn 0;\n\n\tret = avs_ipc_set_dx(adev, mask, true);\n\treturn AVS_IPC_RET(ret);\n}\n\nstatic int avs_dsp_disable(struct avs_dev *adev, u32 core_mask)\n{\n\tint ret;\n\n\tret = avs_ipc_set_dx(adev, core_mask, false);\n\tif (ret)\n\t\treturn AVS_IPC_RET(ret);\n\n\treturn avs_dsp_core_disable(adev, core_mask);\n}\n\nstatic int avs_dsp_get_core(struct avs_dev *adev, u32 core_id)\n{\n\tu32 mask;\n\tint ret;\n\n\tmask = BIT_MASK(core_id);\n\tif (mask == AVS_MAIN_CORE_MASK)\n\t\t \n\t\treturn 0;\n\tif (core_id >= adev->hw_cfg.dsp_cores) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tadev->core_refs[core_id]++;\n\tif (adev->core_refs[core_id] == 1) {\n\t\t \n\t\tret = avs_dsp_disable_d0ix(adev);\n\t\tif (ret && ret != -AVS_EIPC)\n\t\t\tgoto err_disable_d0ix;\n\n\t\tret = avs_dsp_enable(adev, mask);\n\t\tif (ret)\n\t\t\tgoto err_enable_dsp;\n\t}\n\n\treturn 0;\n\nerr_enable_dsp:\n\tavs_dsp_enable_d0ix(adev);\nerr_disable_d0ix:\n\tadev->core_refs[core_id]--;\nerr:\n\tdev_err(adev->dev, \"get core %d failed: %d\\n\", core_id, ret);\n\treturn ret;\n}\n\nstatic int avs_dsp_put_core(struct avs_dev *adev, u32 core_id)\n{\n\tu32 mask;\n\tint ret;\n\n\tmask = BIT_MASK(core_id);\n\tif (mask == AVS_MAIN_CORE_MASK)\n\t\t \n\t\treturn 0;\n\tif (core_id >= adev->hw_cfg.dsp_cores) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tadev->core_refs[core_id]--;\n\tif (!adev->core_refs[core_id]) {\n\t\tret = avs_dsp_disable(adev, mask);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tavs_dsp_enable_d0ix(adev);\n\t}\n\n\treturn 0;\nerr:\n\tdev_err(adev->dev, \"put core %d failed: %d\\n\", core_id, ret);\n\treturn ret;\n}\n\nint avs_dsp_init_module(struct avs_dev *adev, u16 module_id, u8 ppl_instance_id,\n\t\t\tu8 core_id, u8 domain, void *param, u32 param_size,\n\t\t\tu8 *instance_id)\n{\n\tstruct avs_module_entry mentry;\n\tbool was_loaded = false;\n\tint ret, id;\n\n\tid = avs_module_id_alloc(adev, module_id);\n\tif (id < 0)\n\t\treturn id;\n\n\tret = avs_get_module_id_entry(adev, module_id, &mentry);\n\tif (ret)\n\t\tgoto err_mod_entry;\n\n\tret = avs_dsp_get_core(adev, core_id);\n\tif (ret)\n\t\tgoto err_mod_entry;\n\n\t \n\tif (!id && !avs_module_entry_is_loaded(&mentry)) {\n\t\tret = avs_dsp_op(adev, transfer_mods, true, &mentry, 1);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"load modules failed: %d\\n\", ret);\n\t\t\tgoto err_mod_entry;\n\t\t}\n\t\twas_loaded = true;\n\t}\n\n\tret = avs_ipc_init_instance(adev, module_id, id, ppl_instance_id,\n\t\t\t\t    core_id, domain, param, param_size);\n\tif (ret) {\n\t\tret = AVS_IPC_RET(ret);\n\t\tgoto err_ipc;\n\t}\n\n\t*instance_id = id;\n\treturn 0;\n\nerr_ipc:\n\tif (was_loaded)\n\t\tavs_dsp_op(adev, transfer_mods, false, &mentry, 1);\n\tavs_dsp_put_core(adev, core_id);\nerr_mod_entry:\n\tavs_module_id_free(adev, module_id, id);\n\treturn ret;\n}\n\nvoid avs_dsp_delete_module(struct avs_dev *adev, u16 module_id, u8 instance_id,\n\t\t\t   u8 ppl_instance_id, u8 core_id)\n{\n\tstruct avs_module_entry mentry;\n\tint ret;\n\n\t \n\tif (ppl_instance_id == INVALID_PIPELINE_ID)\n\t\tavs_ipc_delete_instance(adev, module_id, instance_id);\n\n\tavs_module_id_free(adev, module_id, instance_id);\n\n\tret = avs_get_module_id_entry(adev, module_id, &mentry);\n\t \n\tif (!ret && mentry.type.load_type == AVS_MODULE_LOAD_TYPE_LOADABLE) {\n\t\tif (avs_is_module_ida_empty(adev, module_id)) {\n\t\t\tret = avs_dsp_op(adev, transfer_mods, false, &mentry, 1);\n\t\t\tif (ret)\n\t\t\t\tdev_err(adev->dev, \"unload modules failed: %d\\n\", ret);\n\t\t}\n\t}\n\n\tavs_dsp_put_core(adev, core_id);\n}\n\nint avs_dsp_create_pipeline(struct avs_dev *adev, u16 req_size, u8 priority,\n\t\t\t    bool lp, u16 attributes, u8 *instance_id)\n{\n\tstruct avs_fw_cfg *fw_cfg = &adev->fw_cfg;\n\tint ret, id;\n\n\tid = ida_alloc_max(&adev->ppl_ida, fw_cfg->max_ppl_count - 1, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tret = avs_ipc_create_pipeline(adev, req_size, priority, id, lp, attributes);\n\tif (ret) {\n\t\tida_free(&adev->ppl_ida, id);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\t*instance_id = id;\n\treturn 0;\n}\n\nint avs_dsp_delete_pipeline(struct avs_dev *adev, u8 instance_id)\n{\n\tint ret;\n\n\tret = avs_ipc_delete_pipeline(adev, instance_id);\n\tif (ret)\n\t\tret = AVS_IPC_RET(ret);\n\n\tida_free(&adev->ppl_ida, instance_id);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}