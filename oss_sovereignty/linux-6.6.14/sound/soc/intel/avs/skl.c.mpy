{
  "module_name": "skl.c",
  "hash_id": "04840db787f84b5a59ae548af1906a4b33f30a5c2ef1c19dcacf9065557d7572",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/skl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/devcoredump.h>\n#include <linux/slab.h>\n#include <sound/hdaudio_ext.h>\n#include \"avs.h\"\n#include \"messages.h\"\n\nstatic int __maybe_unused\nskl_enable_logs(struct avs_dev *adev, enum avs_log_enable enable, u32 aging_period,\n\t\tu32 fifo_full_period, unsigned long resource_mask, u32 *priorities)\n{\n\tstruct skl_log_state_info *info;\n\tu32 size, num_cores = adev->hw_cfg.dsp_cores;\n\tint ret, i;\n\n\tif (fls_long(resource_mask) > num_cores)\n\t\treturn -EINVAL;\n\tsize = struct_size(info, logs_core, num_cores);\n\tinfo = kzalloc(size, GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->core_mask = resource_mask;\n\tif (enable)\n\t\tfor_each_set_bit(i, &resource_mask, num_cores) {\n\t\t\tinfo->logs_core[i].enable = enable;\n\t\t\tinfo->logs_core[i].min_priority = *priorities++;\n\t\t}\n\telse\n\t\tfor_each_set_bit(i, &resource_mask, num_cores)\n\t\t\tinfo->logs_core[i].enable = enable;\n\n\tret = avs_ipc_set_enable_logs(adev, (u8 *)info, size);\n\tkfree(info);\n\tif (ret)\n\t\treturn AVS_IPC_RET(ret);\n\n\treturn 0;\n}\n\nint skl_log_buffer_offset(struct avs_dev *adev, u32 core)\n{\n\treturn core * avs_log_buffer_size(adev);\n}\n\n \n#define FW_REGS_DBG_LOG_WP(core) (0x30 + 0x4 * core)\n\nstatic int\nskl_log_buffer_status(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tvoid __iomem *buf;\n\tu16 size, write, offset;\n\n\tif (!avs_logging_fw(adev))\n\t\treturn 0;\n\n\tsize = avs_log_buffer_size(adev) / 2;\n\twrite = readl(avs_sram_addr(adev, AVS_FW_REGS_WINDOW) + FW_REGS_DBG_LOG_WP(msg->log.core));\n\t \n\toffset = (write < size) ? size : 0;\n\n\t \n\tbuf = avs_log_buffer_addr(adev, msg->log.core) + offset;\n\tavs_dump_fw_log_wakeup(adev, buf, size);\n\n\treturn 0;\n}\n\nstatic int skl_coredump(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tu8 *dump;\n\n\tdump = vzalloc(AVS_FW_REGS_SIZE);\n\tif (!dump)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(dump, avs_sram_addr(adev, AVS_FW_REGS_WINDOW), AVS_FW_REGS_SIZE);\n\tdev_coredumpv(adev->dev, dump, AVS_FW_REGS_SIZE, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic bool\nskl_d0ix_toggle(struct avs_dev *adev, struct avs_ipc_msg *tx, bool wake)\n{\n\t \n\treturn false;\n}\n\nstatic int skl_set_d0ix(struct avs_dev *adev, bool enable)\n{\n\t \n\treturn 0;\n}\n\nconst struct avs_dsp_ops skl_dsp_ops = {\n\t.power = avs_dsp_core_power,\n\t.reset = avs_dsp_core_reset,\n\t.stall = avs_dsp_core_stall,\n\t.irq_handler = avs_dsp_irq_handler,\n\t.irq_thread = avs_dsp_irq_thread,\n\t.int_control = avs_dsp_interrupt_control,\n\t.load_basefw = avs_cldma_load_basefw,\n\t.load_lib = avs_cldma_load_library,\n\t.transfer_mods = avs_cldma_transfer_modules,\n\t.log_buffer_offset = skl_log_buffer_offset,\n\t.log_buffer_status = skl_log_buffer_status,\n\t.coredump = skl_coredump,\n\t.d0ix_toggle = skl_d0ix_toggle,\n\t.set_d0ix = skl_set_d0ix,\n\tAVS_SET_ENABLE_LOGS_OP(skl)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}