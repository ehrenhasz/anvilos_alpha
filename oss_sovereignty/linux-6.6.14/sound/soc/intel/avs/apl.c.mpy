{
  "module_name": "apl.c",
  "hash_id": "98e25af675299a8f62949990310fe8eb33e3b2af0c2ffb76c53997f1c57d6f08",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/apl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/devcoredump.h>\n#include <linux/slab.h>\n#include \"avs.h\"\n#include \"messages.h\"\n#include \"path.h\"\n#include \"topology.h\"\n\nstatic int __maybe_unused\napl_enable_logs(struct avs_dev *adev, enum avs_log_enable enable, u32 aging_period,\n\t\tu32 fifo_full_period, unsigned long resource_mask, u32 *priorities)\n{\n\tstruct apl_log_state_info *info;\n\tu32 size, num_cores = adev->hw_cfg.dsp_cores;\n\tint ret, i;\n\n\tif (fls_long(resource_mask) > num_cores)\n\t\treturn -EINVAL;\n\tsize = struct_size(info, logs_core, num_cores);\n\tinfo = kzalloc(size, GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->aging_timer_period = aging_period;\n\tinfo->fifo_full_timer_period = fifo_full_period;\n\tinfo->core_mask = resource_mask;\n\tif (enable)\n\t\tfor_each_set_bit(i, &resource_mask, num_cores) {\n\t\t\tinfo->logs_core[i].enable = enable;\n\t\t\tinfo->logs_core[i].min_priority = *priorities++;\n\t\t}\n\telse\n\t\tfor_each_set_bit(i, &resource_mask, num_cores)\n\t\t\tinfo->logs_core[i].enable = enable;\n\n\tret = avs_ipc_set_enable_logs(adev, (u8 *)info, size);\n\tkfree(info);\n\tif (ret)\n\t\treturn AVS_IPC_RET(ret);\n\n\treturn 0;\n}\n\nstatic int apl_log_buffer_status(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tstruct apl_log_buffer_layout layout;\n\tvoid __iomem *addr, *buf;\n\n\taddr = avs_log_buffer_addr(adev, msg->log.core);\n\tif (!addr)\n\t\treturn -ENXIO;\n\n\tmemcpy_fromio(&layout, addr, sizeof(layout));\n\n\tif (!avs_logging_fw(adev))\n\t\t \n\t\tgoto update_read_ptr;\n\n\tbuf = apl_log_payload_addr(addr);\n\n\tif (layout.read_ptr > layout.write_ptr) {\n\t\tavs_dump_fw_log(adev, buf + layout.read_ptr,\n\t\t\t\tapl_log_payload_size(adev) - layout.read_ptr);\n\t\tlayout.read_ptr = 0;\n\t}\n\tavs_dump_fw_log_wakeup(adev, buf + layout.read_ptr, layout.write_ptr - layout.read_ptr);\n\nupdate_read_ptr:\n\twritel(layout.write_ptr, addr);\n\treturn 0;\n}\n\nstatic int apl_wait_log_entry(struct avs_dev *adev, u32 core, struct apl_log_buffer_layout *layout)\n{\n\tunsigned long timeout;\n\tvoid __iomem *addr;\n\n\taddr = avs_log_buffer_addr(adev, core);\n\tif (!addr)\n\t\treturn -ENXIO;\n\n\ttimeout = jiffies + msecs_to_jiffies(10);\n\n\tdo {\n\t\tmemcpy_fromio(layout, addr, sizeof(*layout));\n\t\tif (layout->read_ptr != layout->write_ptr)\n\t\t\treturn 0;\n\t\tusleep_range(500, 1000);\n\t} while (!time_after(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\n \n#define apl_is_entry_stackdump(addr) ((readl(addr) >> 30) & 0x1)\n\nstatic int apl_coredump(struct avs_dev *adev, union avs_notify_msg *msg)\n{\n\tstruct apl_log_buffer_layout layout;\n\tvoid __iomem *addr, *buf;\n\tsize_t dump_size;\n\tu16 offset = 0;\n\tu8 *dump, *pos;\n\n\tdump_size = AVS_FW_REGS_SIZE + msg->ext.coredump.stack_dump_size;\n\tdump = vzalloc(dump_size);\n\tif (!dump)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(dump, avs_sram_addr(adev, AVS_FW_REGS_WINDOW), AVS_FW_REGS_SIZE);\n\n\tif (!msg->ext.coredump.stack_dump_size)\n\t\tgoto exit;\n\n\t \n\taddr = avs_log_buffer_addr(adev, msg->ext.coredump.core_id);\n\tif (!addr)\n\t\tgoto exit;\n\n\tbuf = apl_log_payload_addr(addr);\n\tmemcpy_fromio(&layout, addr, sizeof(layout));\n\tif (!apl_is_entry_stackdump(buf + layout.read_ptr)) {\n\t\tunion avs_notify_msg lbs_msg = AVS_NOTIFICATION(LOG_BUFFER_STATUS);\n\n\t\t \n\t\tlbs_msg.log.core = msg->ext.coredump.core_id;\n\t\tavs_log_buffer_status_locked(adev, &lbs_msg);\n\t}\n\n\tpos = dump + AVS_FW_REGS_SIZE;\n\t \n\tdo {\n\t\tu32 count;\n\n\t\tif (apl_wait_log_entry(adev, msg->ext.coredump.core_id, &layout))\n\t\t\tbreak;\n\n\t\tif (layout.read_ptr > layout.write_ptr) {\n\t\t\tcount = apl_log_payload_size(adev) - layout.read_ptr;\n\t\t\tmemcpy_fromio(pos + offset, buf + layout.read_ptr, count);\n\t\t\tlayout.read_ptr = 0;\n\t\t\toffset += count;\n\t\t}\n\t\tcount = layout.write_ptr - layout.read_ptr;\n\t\tmemcpy_fromio(pos + offset, buf + layout.read_ptr, count);\n\t\toffset += count;\n\n\t\t \n\t\twritel(layout.write_ptr, addr);\n\t} while (offset < msg->ext.coredump.stack_dump_size);\n\nexit:\n\tdev_coredumpv(adev->dev, dump, dump_size, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic bool apl_lp_streaming(struct avs_dev *adev)\n{\n\tstruct avs_path *path;\n\n\tspin_lock(&adev->path_list_lock);\n\t \n\tlist_for_each_entry(path, &adev->path_list, node) {\n\t\tstruct avs_path_pipeline *ppl;\n\n\t\tlist_for_each_entry(ppl, &path->ppl_list, node) {\n\t\t\tstruct avs_path_module *mod;\n\n\t\t\tlist_for_each_entry(mod, &ppl->mod_list, node) {\n\t\t\t\tstruct avs_tplg_modcfg_ext *cfg;\n\n\t\t\t\tcfg = mod->template->cfg_ext;\n\n\t\t\t\t \n\t\t\t\tif (!guid_equal(&cfg->type, &AVS_COPIER_MOD_UUID))\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (cfg->copier.dma_type == INVALID_OBJECT_ID)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!mod->gtw_attrs.lp_buffer_alloc) {\n\t\t\t\t\tspin_unlock(&adev->path_list_lock);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&adev->path_list_lock);\n\n\treturn true;\n}\n\nstatic bool apl_d0ix_toggle(struct avs_dev *adev, struct avs_ipc_msg *tx, bool wake)\n{\n\t \n\tif (wake)\n\t\treturn true;\n\n\t \n\treturn apl_lp_streaming(adev);\n}\n\nstatic int apl_set_d0ix(struct avs_dev *adev, bool enable)\n{\n\tbool streaming = false;\n\tint ret;\n\n\tif (enable)\n\t\t \n\t\tstreaming = !list_empty(&adev->path_list);\n\n\tret = avs_ipc_set_d0ix(adev, enable, streaming);\n\treturn AVS_IPC_RET(ret);\n}\n\nconst struct avs_dsp_ops apl_dsp_ops = {\n\t.power = avs_dsp_core_power,\n\t.reset = avs_dsp_core_reset,\n\t.stall = avs_dsp_core_stall,\n\t.irq_handler = avs_dsp_irq_handler,\n\t.irq_thread = avs_dsp_irq_thread,\n\t.int_control = avs_dsp_interrupt_control,\n\t.load_basefw = avs_hda_load_basefw,\n\t.load_lib = avs_hda_load_library,\n\t.transfer_mods = avs_hda_transfer_modules,\n\t.log_buffer_offset = skl_log_buffer_offset,\n\t.log_buffer_status = apl_log_buffer_status,\n\t.coredump = apl_coredump,\n\t.d0ix_toggle = apl_d0ix_toggle,\n\t.set_d0ix = apl_set_d0ix,\n\tAVS_SET_ENABLE_LOGS_OP(apl)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}