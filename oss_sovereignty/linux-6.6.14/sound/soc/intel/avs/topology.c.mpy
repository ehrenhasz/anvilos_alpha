{
  "module_name": "topology.c",
  "hash_id": "de7dbaf806a14aef4dca8c19a5c74d7af6222ed26bc7c04f4ba09732e48f852e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/topology.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <linux/uuid.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-topology.h>\n#include <uapi/sound/intel/avs/tokens.h>\n#include \"avs.h\"\n#include \"control.h\"\n#include \"topology.h\"\n\n \n#define avs_tplg_vendor_array_at(array, offset) \\\n\t((struct snd_soc_tplg_vendor_array *)((u8 *)array + offset))\n\n \n#define avs_tplg_vendor_array_next(array) \\\n\t(avs_tplg_vendor_array_at(array, le32_to_cpu((array)->size)))\n\n \nstatic int\navs_tplg_vendor_array_lookup(struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t     u32 block_size, u32 token, u32 *offset)\n{\n\tu32 pos = 0;\n\n\twhile (block_size > 0) {\n\t\tstruct snd_soc_tplg_vendor_value_elem *tuple;\n\t\tu32 tuples_size = le32_to_cpu(tuples->size);\n\n\t\tif (tuples_size > block_size)\n\t\t\treturn -EINVAL;\n\n\t\ttuple = tuples->value;\n\t\tif (le32_to_cpu(tuple->token) == token) {\n\t\t\t*offset = pos;\n\t\t\treturn 0;\n\t\t}\n\n\t\tblock_size -= tuples_size;\n\t\tpos += tuples_size;\n\t\ttuples = avs_tplg_vendor_array_next(tuples);\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int\navs_tplg_vendor_array_lookup_next(struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t  u32 block_size, u32 token, u32 *offset)\n{\n\tu32 tuples_size = le32_to_cpu(tuples->size);\n\tint ret;\n\n\tif (tuples_size > block_size)\n\t\treturn -EINVAL;\n\n\ttuples = avs_tplg_vendor_array_next(tuples);\n\tblock_size -= tuples_size;\n\n\tret = avs_tplg_vendor_array_lookup(tuples, block_size, token, offset);\n\tif (!ret)\n\t\t*offset += tuples_size;\n\treturn ret;\n}\n\n \nstatic int\navs_tplg_vendor_entry_size(struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t   u32 block_size, u32 entry_id_token, u32 *size)\n{\n\tint ret;\n\n\tret = avs_tplg_vendor_array_lookup_next(tuples, block_size, entry_id_token, size);\n\tif (ret == -ENOENT) {\n\t\t*size = block_size;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstruct avs_tplg_token_parser {\n\tenum avs_tplg_token token;\n\tu32 type;\n\tu32 offset;\n\tint (*parse)(struct snd_soc_component *comp, void *elem, void *object, u32 offset);\n};\n\nstatic int\navs_parse_uuid_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_uuid_elem *tuple = elem;\n\tguid_t *val = (guid_t *)((u8 *)object + offset);\n\n\tguid_copy((guid_t *)val, (const guid_t *)&tuple->uuid);\n\n\treturn 0;\n}\n\nstatic int\navs_parse_bool_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple = elem;\n\tbool *val = (bool *)((u8 *)object + offset);\n\n\t*val = le32_to_cpu(tuple->value);\n\n\treturn 0;\n}\n\nstatic int\navs_parse_byte_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple = elem;\n\tu8 *val = ((u8 *)object + offset);\n\n\t*val = le32_to_cpu(tuple->value);\n\n\treturn 0;\n}\n\nstatic int\navs_parse_short_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple = elem;\n\tu16 *val = (u16 *)((u8 *)object + offset);\n\n\t*val = le32_to_cpu(tuple->value);\n\n\treturn 0;\n}\n\nstatic int\navs_parse_word_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple = elem;\n\tu32 *val = (u32 *)((u8 *)object + offset);\n\n\t*val = le32_to_cpu(tuple->value);\n\n\treturn 0;\n}\n\nstatic int\navs_parse_string_token(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_string_elem *tuple = elem;\n\tchar *val = (char *)((u8 *)object + offset);\n\n\tsnprintf(val, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, \"%s\", tuple->string);\n\n\treturn 0;\n}\n\nstatic int avs_parse_uuid_tokens(struct snd_soc_component *comp, void *object,\n\t\t\t\t const struct avs_tplg_token_parser *parsers, int count,\n\t\t\t\t struct snd_soc_tplg_vendor_array *tuples)\n{\n\tstruct snd_soc_tplg_vendor_uuid_elem *tuple;\n\tint ret, i, j;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(tuples->num_elems); i++) {\n\t\ttuple = &tuples->uuid[i];\n\n\t\tfor (j = 0; j < count; j++) {\n\t\t\t \n\t\t\tif (parsers[j].type != SND_SOC_TPLG_TUPLE_TYPE_UUID ||\n\t\t\t    parsers[j].token != le32_to_cpu(tuple->token))\n\t\t\t\tcontinue;\n\n\t\t\tret = parsers[j].parse(comp, tuple, object, parsers[j].offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_parse_string_tokens(struct snd_soc_component *comp, void *object,\n\t\t\t\t   const struct avs_tplg_token_parser *parsers, int count,\n\t\t\t\t   struct snd_soc_tplg_vendor_array *tuples)\n{\n\tstruct snd_soc_tplg_vendor_string_elem *tuple;\n\tint ret, i, j;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(tuples->num_elems); i++) {\n\t\ttuple = &tuples->string[i];\n\n\t\tfor (j = 0; j < count; j++) {\n\t\t\t \n\t\t\tif (parsers[j].type != SND_SOC_TPLG_TUPLE_TYPE_STRING ||\n\t\t\t    parsers[j].token != le32_to_cpu(tuple->token))\n\t\t\t\tcontinue;\n\n\t\t\tret = parsers[j].parse(comp, tuple, object, parsers[j].offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_parse_word_tokens(struct snd_soc_component *comp, void *object,\n\t\t\t\t const struct avs_tplg_token_parser *parsers, int count,\n\t\t\t\t struct snd_soc_tplg_vendor_array *tuples)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple;\n\tint ret, i, j;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(tuples->num_elems); i++) {\n\t\ttuple = &tuples->value[i];\n\n\t\tfor (j = 0; j < count; j++) {\n\t\t\t \n\t\t\tif (!(parsers[j].type == SND_SOC_TPLG_TUPLE_TYPE_WORD ||\n\t\t\t      parsers[j].type == SND_SOC_TPLG_TUPLE_TYPE_SHORT ||\n\t\t\t      parsers[j].type == SND_SOC_TPLG_TUPLE_TYPE_BYTE ||\n\t\t\t      parsers[j].type == SND_SOC_TPLG_TUPLE_TYPE_BOOL))\n\t\t\t\tcontinue;\n\n\t\t\tif (parsers[j].token != le32_to_cpu(tuple->token))\n\t\t\t\tcontinue;\n\n\t\t\tret = parsers[j].parse(comp, tuple, object, parsers[j].offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_parse_tokens(struct snd_soc_component *comp, void *object,\n\t\t\t    const struct avs_tplg_token_parser *parsers, size_t count,\n\t\t\t    struct snd_soc_tplg_vendor_array *tuples, int priv_size)\n{\n\tint array_size, ret;\n\n\twhile (priv_size > 0) {\n\t\tarray_size = le32_to_cpu(tuples->size);\n\n\t\tif (array_size <= 0) {\n\t\t\tdev_err(comp->dev, \"invalid array size 0x%x\\n\", array_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpriv_size -= array_size;\n\t\tif (priv_size < 0) {\n\t\t\tdev_err(comp->dev, \"invalid array size 0x%x\\n\", array_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (le32_to_cpu(tuples->type)) {\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_UUID:\n\t\t\tret = avs_parse_uuid_tokens(comp, object, parsers, count, tuples);\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_STRING:\n\t\t\tret = avs_parse_string_tokens(comp, object, parsers, count, tuples);\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_BOOL:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_BYTE:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_SHORT:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_WORD:\n\t\t\tret = avs_parse_word_tokens(comp, object, parsers, count, tuples);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(comp->dev, \"unknown token type %d\\n\", tuples->type);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(comp->dev, \"parsing %zu tokens of %d type failed: %d\\n\",\n\t\t\t\tcount, tuples->type, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttuples = avs_tplg_vendor_array_next(tuples);\n\t}\n\n\treturn 0;\n}\n\n#define AVS_DEFINE_PTR_PARSER(name, type, member) \\\nstatic int \\\navs_parse_##name##_ptr(struct snd_soc_component *comp, void *elem, void *object, u32 offset) \\\n{ \\\n\tstruct snd_soc_tplg_vendor_value_elem *tuple = elem;\t\t\\\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\t\\\n\ttype **val = (type **)(object + offset);\t\t\t\\\n\tu32 idx;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tidx = le32_to_cpu(tuple->value);\t\t\t\t\\\n\tif (idx >= acomp->tplg->num_##member)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t*val = &acomp->tplg->member[idx];\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nAVS_DEFINE_PTR_PARSER(audio_format, struct avs_audio_format, fmts);\nAVS_DEFINE_PTR_PARSER(modcfg_base, struct avs_tplg_modcfg_base, modcfgs_base);\nAVS_DEFINE_PTR_PARSER(modcfg_ext, struct avs_tplg_modcfg_ext, modcfgs_ext);\nAVS_DEFINE_PTR_PARSER(pplcfg, struct avs_tplg_pplcfg, pplcfgs);\nAVS_DEFINE_PTR_PARSER(binding, struct avs_tplg_binding, bindings);\n\nstatic int\nparse_audio_format_bitfield(struct snd_soc_component *comp, void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *velem = elem;\n\tstruct avs_audio_format *audio_format = object;\n\n\tswitch (offset) {\n\tcase AVS_TKN_AFMT_NUM_CHANNELS_U32:\n\t\taudio_format->num_channels = le32_to_cpu(velem->value);\n\t\tbreak;\n\tcase AVS_TKN_AFMT_VALID_BIT_DEPTH_U32:\n\t\taudio_format->valid_bit_depth = le32_to_cpu(velem->value);\n\t\tbreak;\n\tcase AVS_TKN_AFMT_SAMPLE_TYPE_U32:\n\t\taudio_format->sample_type = le32_to_cpu(velem->value);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_link_formatted_string(struct snd_soc_component *comp, void *elem,\n\t\t\t\t       void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_string_elem *tuple = elem;\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(comp->card->dev);\n\tchar *val = (char *)((u8 *)object + offset);\n\n\t \n\tif (hweight_long(mach->mach_params.i2s_link_mask) != 1)\n\t\treturn avs_parse_string_token(comp, elem, object, offset);\n\n\tsnprintf(val, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, tuple->string,\n\t\t __ffs(mach->mach_params.i2s_link_mask));\n\n\treturn 0;\n}\n\nstatic int\nparse_dictionary_header(struct snd_soc_component *comp,\n\t\t\tstruct snd_soc_tplg_vendor_array *tuples,\n\t\t\tvoid **dict, u32 *num_entries, size_t entry_size,\n\t\t\tu32 num_entries_token)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tuple;\n\n\t \n\ttuple = tuples->value;\n\tif (le32_to_cpu(tuple->token) != num_entries_token) {\n\t\tdev_err(comp->dev, \"invalid dictionary header, expected: %d\\n\",\n\t\t\tnum_entries_token);\n\t\treturn -EINVAL;\n\t}\n\n\t*num_entries = le32_to_cpu(tuple->value);\n\t*dict = devm_kcalloc(comp->card->dev, *num_entries, entry_size, GFP_KERNEL);\n\tif (!*dict)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int\nparse_dictionary_entries(struct snd_soc_component *comp,\n\t\t\t struct snd_soc_tplg_vendor_array *tuples, u32 block_size,\n\t\t\t void *dict, u32 num_entries, size_t entry_size,\n\t\t\t u32 entry_id_token,\n\t\t\t const struct avs_tplg_token_parser *parsers, size_t num_parsers)\n{\n\tvoid *pos = dict;\n\tint i;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 esize;\n\t\tint ret;\n\n\t\tret = avs_tplg_vendor_entry_size(tuples, block_size,\n\t\t\t\t\t\t entry_id_token, &esize);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = avs_parse_tokens(comp, pos, parsers, num_parsers, tuples, esize);\n\t\tif (ret < 0) {\n\t\t\tdev_err(comp->dev, \"parse entry: %d of type: %d failed: %d\\n\",\n\t\t\t\ti, entry_id_token, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpos += entry_size;\n\t\tblock_size -= esize;\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_dictionary(struct snd_soc_component *comp,\n\t\t\t    struct snd_soc_tplg_vendor_array *tuples, u32 block_size,\n\t\t\t    void **dict, u32 *num_entries, size_t entry_size,\n\t\t\t    u32 num_entries_token, u32 entry_id_token,\n\t\t\t    const struct avs_tplg_token_parser *parsers, size_t num_parsers)\n{\n\tint ret;\n\n\tret = parse_dictionary_header(comp, tuples, dict, num_entries,\n\t\t\t\t      entry_size, num_entries_token);\n\tif (ret)\n\t\treturn ret;\n\n\tblock_size -= le32_to_cpu(tuples->size);\n\t \n\ttuples = avs_tplg_vendor_array_next(tuples);\n\n\treturn parse_dictionary_entries(comp, tuples, block_size, *dict,\n\t\t\t\t\t*num_entries, entry_size,\n\t\t\t\t\tentry_id_token, parsers, num_parsers);\n}\n\nstatic const struct avs_tplg_token_parser library_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_LIBRARY_NAME_STRING,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_STRING,\n\t\t.offset = offsetof(struct avs_tplg_library, name),\n\t\t.parse = avs_parse_string_token,\n\t},\n};\n\nstatic int avs_tplg_parse_libraries(struct snd_soc_component *comp,\n\t\t\t\t    struct snd_soc_tplg_vendor_array *tuples, u32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\n\treturn parse_dictionary(comp, tuples, block_size, (void **)&tplg->libs,\n\t\t\t\t&tplg->num_libs, sizeof(*tplg->libs),\n\t\t\t\tAVS_TKN_MANIFEST_NUM_LIBRARIES_U32,\n\t\t\t\tAVS_TKN_LIBRARY_ID_U32,\n\t\t\t\tlibrary_parsers, ARRAY_SIZE(library_parsers));\n}\n\nstatic const struct avs_tplg_token_parser audio_format_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_AFMT_SAMPLE_RATE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_audio_format, sampling_freq),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_BIT_DEPTH_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_audio_format, bit_depth),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_CHANNEL_MAP_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_audio_format, channel_map),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_CHANNEL_CFG_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_audio_format, channel_config),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_INTERLEAVING_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_audio_format, interleaving),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_NUM_CHANNELS_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = AVS_TKN_AFMT_NUM_CHANNELS_U32,\n\t\t.parse = parse_audio_format_bitfield,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_VALID_BIT_DEPTH_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = AVS_TKN_AFMT_VALID_BIT_DEPTH_U32,\n\t\t.parse = parse_audio_format_bitfield,\n\t},\n\t{\n\t\t.token = AVS_TKN_AFMT_SAMPLE_TYPE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = AVS_TKN_AFMT_SAMPLE_TYPE_U32,\n\t\t.parse = parse_audio_format_bitfield,\n\t},\n};\n\nstatic int avs_tplg_parse_audio_formats(struct snd_soc_component *comp,\n\t\t\t\t\tstruct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t\tu32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\n\treturn parse_dictionary(comp, tuples, block_size, (void **)&tplg->fmts,\n\t\t\t\t&tplg->num_fmts, sizeof(*tplg->fmts),\n\t\t\t\tAVS_TKN_MANIFEST_NUM_AFMTS_U32,\n\t\t\t\tAVS_TKN_AFMT_ID_U32,\n\t\t\t\taudio_format_parsers, ARRAY_SIZE(audio_format_parsers));\n}\n\nstatic const struct avs_tplg_token_parser modcfg_base_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_MODCFG_BASE_CPC_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_base, cpc),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_BASE_IBS_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_base, ibs),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_BASE_OBS_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_base, obs),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_BASE_PAGES_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_base, is_pages),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic int avs_tplg_parse_modcfgs_base(struct snd_soc_component *comp,\n\t\t\t\t       struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t       u32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\n\treturn parse_dictionary(comp, tuples, block_size, (void **)&tplg->modcfgs_base,\n\t\t\t\t&tplg->num_modcfgs_base, sizeof(*tplg->modcfgs_base),\n\t\t\t\tAVS_TKN_MANIFEST_NUM_MODCFGS_BASE_U32,\n\t\t\t\tAVS_TKN_MODCFG_BASE_ID_U32,\n\t\t\t\tmodcfg_base_parsers, ARRAY_SIZE(modcfg_base_parsers));\n}\n\nstatic const struct avs_tplg_token_parser modcfg_ext_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_MODCFG_EXT_TYPE_UUID,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_UUID,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, type),\n\t\t.parse = avs_parse_uuid_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_OUT_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.out_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_FEATURE_MASK_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.feature_mask),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_VINDEX_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.vindex),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_DMA_TYPE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.dma_type),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_DMABUFF_SIZE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.dma_buffer_size),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_CPR_BLOB_FMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, copier.blob_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_MICSEL_OUT_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, micsel.out_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_INTELWOV_CPC_LP_MODE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, wov.cpc_lp_mode),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_SRC_OUT_FREQ_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, src.out_freq),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_MUX_REF_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, mux.ref_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_MUX_OUT_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, mux.out_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_AEC_REF_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, aec.ref_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_AEC_OUT_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, aec.out_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_AEC_CPC_LP_MODE_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, aec.cpc_lp_mode),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_ASRC_OUT_FREQ_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, asrc.out_freq),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_ASRC_MODE_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, asrc.mode),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_ASRC_DISABLE_JITTER_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, asrc.disable_jitter_buffer),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_OUT_CHAN_CFG_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.out_channel_config),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_SELECT_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients_select),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_0_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[0]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_1_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[1]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_2_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[2]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_3_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[3]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_4_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[4]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_5_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[5]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_6_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[6]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_COEFF_7_S32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.coefficients[7]),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_UPDOWN_MIX_CHAN_MAP_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, updown_mix.channel_map),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_EXT_NUM_INPUT_PINS_U16,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_SHORT,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, generic.num_input_pins),\n\t\t.parse = avs_parse_short_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MODCFG_EXT_NUM_OUTPUT_PINS_U16,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_SHORT,\n\t\t.offset = offsetof(struct avs_tplg_modcfg_ext, generic.num_output_pins),\n\t\t.parse = avs_parse_short_token,\n\t},\n};\n\nstatic const struct avs_tplg_token_parser pin_format_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PIN_FMT_INDEX_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pin_format, pin_index),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PIN_FMT_IOBS_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pin_format, iobs),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PIN_FMT_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pin_format, fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n};\n\nstatic void\nassign_copier_gtw_instance(struct snd_soc_component *comp, struct avs_tplg_modcfg_ext *cfg)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\n\tif (!guid_equal(&cfg->type, &AVS_COPIER_MOD_UUID))\n\t\treturn;\n\n\t \n\tswitch (cfg->copier.dma_type) {\n\tcase AVS_DMA_I2S_LINK_OUTPUT:\n\tcase AVS_DMA_I2S_LINK_INPUT:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmach = dev_get_platdata(comp->card->dev);\n\n\t \n\tif (hweight_long(mach->mach_params.i2s_link_mask) == 1 && !cfg->copier.vindex.i2s.instance)\n\t\tcfg->copier.vindex.i2s.instance = __ffs(mach->mach_params.i2s_link_mask);\n}\n\nstatic int avs_tplg_parse_modcfg_ext(struct snd_soc_component *comp,\n\t\t\t\t     struct avs_tplg_modcfg_ext *cfg,\n\t\t\t\t     struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t     u32 block_size)\n{\n\tu32 esize;\n\tint ret;\n\n\t \n\tret = avs_tplg_vendor_entry_size(tuples, block_size,\n\t\t\t\t\t AVS_TKN_PIN_FMT_INDEX_U32, &esize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = avs_parse_tokens(comp, cfg, modcfg_ext_parsers,\n\t\t\t       ARRAY_SIZE(modcfg_ext_parsers), tuples, esize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tassign_copier_gtw_instance(comp, cfg);\n\n\tblock_size -= esize;\n\t \n\tif (block_size) {\n\t\tstruct avs_tplg_pin_format *pins;\n\t\tu32 num_pins;\n\n\t\tnum_pins = cfg->generic.num_input_pins + cfg->generic.num_output_pins;\n\t\tif (!num_pins)\n\t\t\treturn -EINVAL;\n\n\t\tpins = devm_kcalloc(comp->card->dev, num_pins, sizeof(*pins), GFP_KERNEL);\n\t\tif (!pins)\n\t\t\treturn -ENOMEM;\n\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t\tret = parse_dictionary_entries(comp, tuples, block_size,\n\t\t\t\t\t       pins, num_pins, sizeof(*pins),\n\t\t\t\t\t       AVS_TKN_PIN_FMT_INDEX_U32,\n\t\t\t\t\t       pin_format_parsers,\n\t\t\t\t\t       ARRAY_SIZE(pin_format_parsers));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcfg->generic.pin_fmts = pins;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_tplg_parse_modcfgs_ext(struct snd_soc_component *comp,\n\t\t\t\t      struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t      u32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\tint ret, i;\n\n\tret = parse_dictionary_header(comp, tuples, (void **)&tplg->modcfgs_ext,\n\t\t\t\t      &tplg->num_modcfgs_ext,\n\t\t\t\t      sizeof(*tplg->modcfgs_ext),\n\t\t\t\t      AVS_TKN_MANIFEST_NUM_MODCFGS_EXT_U32);\n\tif (ret)\n\t\treturn ret;\n\n\tblock_size -= le32_to_cpu(tuples->size);\n\t \n\ttuples = avs_tplg_vendor_array_next(tuples);\n\n\tfor (i = 0; i < tplg->num_modcfgs_ext; i++) {\n\t\tstruct avs_tplg_modcfg_ext *cfg = &tplg->modcfgs_ext[i];\n\t\tu32 esize;\n\n\t\tret = avs_tplg_vendor_entry_size(tuples, block_size,\n\t\t\t\t\t\t AVS_TKN_MODCFG_EXT_ID_U32, &esize);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = avs_tplg_parse_modcfg_ext(comp, cfg, tuples, esize);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tblock_size -= esize;\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct avs_tplg_token_parser pplcfg_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PPLCFG_REQ_SIZE_U16,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_SHORT,\n\t\t.offset = offsetof(struct avs_tplg_pplcfg, req_size),\n\t\t.parse = avs_parse_short_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPLCFG_PRIORITY_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_pplcfg, priority),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPLCFG_LOW_POWER_BOOL,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BOOL,\n\t\t.offset = offsetof(struct avs_tplg_pplcfg, lp),\n\t\t.parse = avs_parse_bool_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPLCFG_ATTRIBUTES_U16,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_SHORT,\n\t\t.offset = offsetof(struct avs_tplg_pplcfg, attributes),\n\t\t.parse = avs_parse_short_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPLCFG_TRIGGER_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pplcfg, trigger),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic int avs_tplg_parse_pplcfgs(struct snd_soc_component *comp,\n\t\t\t\t  struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t  u32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\n\treturn parse_dictionary(comp, tuples, block_size, (void **)&tplg->pplcfgs,\n\t\t\t\t&tplg->num_pplcfgs, sizeof(*tplg->pplcfgs),\n\t\t\t\tAVS_TKN_MANIFEST_NUM_PPLCFGS_U32,\n\t\t\t\tAVS_TKN_PPLCFG_ID_U32,\n\t\t\t\tpplcfg_parsers, ARRAY_SIZE(pplcfg_parsers));\n}\n\nstatic const struct avs_tplg_token_parser binding_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_BINDING_TARGET_TPLG_NAME_STRING,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_STRING,\n\t\t.offset = offsetof(struct avs_tplg_binding, target_tplg_name),\n\t\t.parse = parse_link_formatted_string,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_TARGET_PATH_TMPL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_binding, target_path_tmpl_id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_TARGET_PPL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_binding, target_ppl_id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_TARGET_MOD_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_binding, target_mod_id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_TARGET_MOD_PIN_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_binding, target_mod_pin),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_MOD_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_binding, mod_id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_MOD_PIN_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_binding, mod_pin),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_BINDING_IS_SINK_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_binding, is_sink),\n\t\t.parse = avs_parse_byte_token,\n\t},\n};\n\nstatic int avs_tplg_parse_bindings(struct snd_soc_component *comp,\n\t\t\t\t   struct snd_soc_tplg_vendor_array *tuples,\n\t\t\t\t   u32 block_size)\n{\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg = acomp->tplg;\n\n\treturn parse_dictionary(comp, tuples, block_size, (void **)&tplg->bindings,\n\t\t\t\t&tplg->num_bindings, sizeof(*tplg->bindings),\n\t\t\t\tAVS_TKN_MANIFEST_NUM_BINDINGS_U32,\n\t\t\t\tAVS_TKN_BINDING_ID_U32,\n\t\t\t\tbinding_parsers, ARRAY_SIZE(binding_parsers));\n}\n\nstatic const struct avs_tplg_token_parser module_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_MOD_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_module, id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_MODCFG_BASE_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_module, cfg_base),\n\t\t.parse = avs_parse_modcfg_base_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_IN_AFMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_module, in_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_CORE_ID_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_module, core_id),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_PROC_DOMAIN_U8,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_BYTE,\n\t\t.offset = offsetof(struct avs_tplg_module, domain),\n\t\t.parse = avs_parse_byte_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_MODCFG_EXT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_module, cfg_ext),\n\t\t.parse = avs_parse_modcfg_ext_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_MOD_KCONTROL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_module, ctl_id),\n\t\t.parse = avs_parse_byte_token,\n\t},\n};\n\nstatic struct avs_tplg_module *\navs_tplg_module_create(struct snd_soc_component *comp, struct avs_tplg_pipeline *owner,\n\t\t       struct snd_soc_tplg_vendor_array *tuples, u32 block_size)\n{\n\tstruct avs_tplg_module *module;\n\tint ret;\n\n\tmodule = devm_kzalloc(comp->card->dev, sizeof(*module), GFP_KERNEL);\n\tif (!module)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = avs_parse_tokens(comp, module, module_parsers,\n\t\t\t       ARRAY_SIZE(module_parsers), tuples, block_size);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tmodule->owner = owner;\n\tINIT_LIST_HEAD(&module->node);\n\n\treturn module;\n}\n\nstatic const struct avs_tplg_token_parser pipeline_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PPL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pipeline, id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPL_PPLCFG_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pipeline, cfg),\n\t\t.parse = avs_parse_pplcfg_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_PPL_NUM_BINDING_IDS_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_pipeline, num_bindings),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic const struct avs_tplg_token_parser bindings_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PPL_BINDING_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = 0,  \n\t\t.parse = avs_parse_binding_ptr,\n\t},\n};\n\nstatic struct avs_tplg_pipeline *\navs_tplg_pipeline_create(struct snd_soc_component *comp, struct avs_tplg_path *owner,\n\t\t\t struct snd_soc_tplg_vendor_array *tuples, u32 block_size)\n{\n\tstruct avs_tplg_pipeline *pipeline;\n\tu32 modblk_size, offset;\n\tint ret;\n\n\tpipeline = devm_kzalloc(comp->card->dev, sizeof(*pipeline), GFP_KERNEL);\n\tif (!pipeline)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpipeline->owner = owner;\n\tINIT_LIST_HEAD(&pipeline->mod_list);\n\n\t \n\tret = avs_tplg_vendor_array_lookup(tuples, block_size,\n\t\t\t\t\t   AVS_TKN_MOD_ID_U32, &offset);\n\tif (!ret && !offset)\n\t\tret = -EINVAL;\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tret = avs_parse_tokens(comp, pipeline, pipeline_parsers,\n\t\t\t       ARRAY_SIZE(pipeline_parsers), tuples, offset);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tblock_size -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\t \n\tret = avs_tplg_vendor_array_lookup_next(tuples, block_size,\n\t\t\t\t\t\tAVS_TKN_PPL_BINDING_ID_U32, &offset);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\treturn ERR_PTR(ret);\n\n\t\t \n\t\tif (pipeline->num_bindings)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tmodblk_size = block_size;\n\t} else {\n\t\tpipeline->bindings = devm_kcalloc(comp->card->dev, pipeline->num_bindings,\n\t\t\t\t\t\t  sizeof(*pipeline->bindings), GFP_KERNEL);\n\t\tif (!pipeline->bindings)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tmodblk_size = offset;\n\t}\n\n\tblock_size -= modblk_size;\n\tdo {\n\t\tstruct avs_tplg_module *module;\n\t\tu32 esize;\n\n\t\tret = avs_tplg_vendor_entry_size(tuples, modblk_size,\n\t\t\t\t\t\t AVS_TKN_MOD_ID_U32, &esize);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tmodule = avs_tplg_module_create(comp, pipeline, tuples, esize);\n\t\tif (IS_ERR(module)) {\n\t\t\tdev_err(comp->dev, \"parse module failed: %ld\\n\",\n\t\t\t\tPTR_ERR(module));\n\t\t\treturn ERR_CAST(module);\n\t\t}\n\n\t\tlist_add_tail(&module->node, &pipeline->mod_list);\n\t\tmodblk_size -= esize;\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t} while (modblk_size > 0);\n\n\t \n\tret = parse_dictionary_entries(comp, tuples, block_size, pipeline->bindings,\n\t\t\t\t       pipeline->num_bindings, sizeof(*pipeline->bindings),\n\t\t\t\t       AVS_TKN_PPL_BINDING_ID_U32,\n\t\t\t\t       bindings_parsers, ARRAY_SIZE(bindings_parsers));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn pipeline;\n}\n\nstatic const struct avs_tplg_token_parser path_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PATH_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_path, id),\n\t\t.parse = avs_parse_word_token,\n\t},\n\t{\n\t\t.token = AVS_TKN_PATH_FE_FMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_path, fe_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n\t{\n\t\t.token = AVS_TKN_PATH_BE_FMT_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_path, be_fmt),\n\t\t.parse = avs_parse_audio_format_ptr,\n\t},\n};\n\nstatic struct avs_tplg_path *\navs_tplg_path_create(struct snd_soc_component *comp, struct avs_tplg_path_template *owner,\n\t\t     struct snd_soc_tplg_vendor_array *tuples, u32 block_size,\n\t\t     const struct avs_tplg_token_parser *parsers, u32 num_parsers)\n{\n\tstruct avs_tplg_pipeline *pipeline;\n\tstruct avs_tplg_path *path;\n\tu32 offset;\n\tint ret;\n\n\tpath = devm_kzalloc(comp->card->dev, sizeof(*path), GFP_KERNEL);\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpath->owner = owner;\n\tINIT_LIST_HEAD(&path->ppl_list);\n\tINIT_LIST_HEAD(&path->node);\n\n\t \n\tret = avs_tplg_vendor_array_lookup(tuples, block_size,\n\t\t\t\t\t   AVS_TKN_PPL_ID_U32, &offset);\n\tif (ret == -ENOENT)\n\t\toffset = block_size;\n\telse if (ret)\n\t\treturn ERR_PTR(ret);\n\telse if (!offset)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tret = avs_parse_tokens(comp, path, parsers, num_parsers, tuples, offset);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tblock_size -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\twhile (block_size > 0) {\n\t\tu32 esize;\n\n\t\tret = avs_tplg_vendor_entry_size(tuples, block_size,\n\t\t\t\t\t\t AVS_TKN_PPL_ID_U32, &esize);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tpipeline = avs_tplg_pipeline_create(comp, path, tuples, esize);\n\t\tif (IS_ERR(pipeline)) {\n\t\t\tdev_err(comp->dev, \"parse pipeline failed: %ld\\n\",\n\t\t\t\tPTR_ERR(pipeline));\n\t\t\treturn ERR_CAST(pipeline);\n\t\t}\n\n\t\tlist_add_tail(&pipeline->node, &path->ppl_list);\n\t\tblock_size -= esize;\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t}\n\n\treturn path;\n}\n\nstatic const struct avs_tplg_token_parser path_tmpl_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_PATH_TMPL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg_path_template, id),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic int parse_path_template(struct snd_soc_component *comp,\n\t\t\t       struct snd_soc_tplg_vendor_array *tuples, u32 block_size,\n\t\t\t       struct avs_tplg_path_template *template,\n\t\t\t       const struct avs_tplg_token_parser *tmpl_tokens, u32 num_tmpl_tokens,\n\t\t\t       const struct avs_tplg_token_parser *path_tokens, u32 num_path_tokens)\n{\n\tstruct avs_tplg_path *path;\n\tu32 offset;\n\tint ret;\n\n\t \n\tret = avs_tplg_vendor_array_lookup(tuples, block_size,\n\t\t\t\t\t   AVS_TKN_PATH_ID_U32, &offset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = avs_parse_tokens(comp, template, tmpl_tokens, num_tmpl_tokens, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tblock_size -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\tdo {\n\t\tu32 esize;\n\n\t\tret = avs_tplg_vendor_entry_size(tuples, block_size,\n\t\t\t\t\t\t AVS_TKN_PATH_ID_U32, &esize);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpath = avs_tplg_path_create(comp, template, tuples, esize, path_tokens,\n\t\t\t\t\t    num_path_tokens);\n\t\tif (IS_ERR(path)) {\n\t\t\tdev_err(comp->dev, \"parse path failed: %ld\\n\", PTR_ERR(path));\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\n\t\tlist_add_tail(&path->node, &template->path_list);\n\t\tblock_size -= esize;\n\t\ttuples = avs_tplg_vendor_array_at(tuples, esize);\n\t} while (block_size > 0);\n\n\treturn 0;\n}\n\nstatic struct avs_tplg_path_template *\navs_tplg_path_template_create(struct snd_soc_component *comp, struct avs_tplg *owner,\n\t\t\t      struct snd_soc_tplg_vendor_array *tuples, u32 block_size)\n{\n\tstruct avs_tplg_path_template *template;\n\tint ret;\n\n\ttemplate = devm_kzalloc(comp->card->dev, sizeof(*template), GFP_KERNEL);\n\tif (!template)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttemplate->owner = owner;  \n\tINIT_LIST_HEAD(&template->path_list);\n\tINIT_LIST_HEAD(&template->node);\n\n\tret = parse_path_template(comp, tuples, block_size, template, path_tmpl_parsers,\n\t\t\t\t  ARRAY_SIZE(path_tmpl_parsers), path_parsers,\n\t\t\t\t  ARRAY_SIZE(path_parsers));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn template;\n}\n\nstatic int avs_route_load(struct snd_soc_component *comp, int index,\n\t\t\t  struct snd_soc_dapm_route *route)\n{\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(comp->card->dev);\n\tsize_t len = SNDRV_CTL_ELEM_ID_NAME_MAXLEN;\n\tchar buf[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tu32 port;\n\n\t \n\tif (hweight_long(mach->mach_params.i2s_link_mask) == 1) {\n\t\tport = __ffs(mach->mach_params.i2s_link_mask);\n\n\t\tsnprintf(buf, len, route->source, port);\n\t\tstrscpy((char *)route->source, buf, len);\n\t\tsnprintf(buf, len, route->sink, port);\n\t\tstrscpy((char *)route->sink, buf, len);\n\t\tif (route->control) {\n\t\t\tsnprintf(buf, len, route->control, port);\n\t\t\tstrscpy((char *)route->control, buf, len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_widget_load(struct snd_soc_component *comp, int index,\n\t\t\t   struct snd_soc_dapm_widget *w,\n\t\t\t   struct snd_soc_tplg_dapm_widget *dw)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct avs_tplg_path_template *template;\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tstruct avs_tplg *tplg;\n\n\tif (!le32_to_cpu(dw->priv.size))\n\t\treturn 0;\n\n\tif (w->ignore_suspend && !AVS_S0IX_SUPPORTED) {\n\t\tdev_info_once(comp->dev, \"Device does not support S0IX, check BIOS settings\\n\");\n\t\tw->ignore_suspend = false;\n\t}\n\n\ttplg = acomp->tplg;\n\tmach = dev_get_platdata(comp->card->dev);\n\n\t \n\tif (hweight_long(mach->mach_params.i2s_link_mask) == 1) {\n\t\tkfree(w->name);\n\t\t \n\t\tw->name = kasprintf(GFP_KERNEL, dw->name, __ffs(mach->mach_params.i2s_link_mask));\n\t\tif (!w->name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttemplate = avs_tplg_path_template_create(comp, tplg, dw->priv.array,\n\t\t\t\t\t\t le32_to_cpu(dw->priv.size));\n\tif (IS_ERR(template)) {\n\t\tdev_err(comp->dev, \"widget %s load failed: %ld\\n\", dw->name,\n\t\t\tPTR_ERR(template));\n\t\treturn PTR_ERR(template);\n\t}\n\n\tw->priv = template;  \n\tlist_add_tail(&template->node, &tplg->path_tmpl_list);\n\treturn 0;\n}\n\nstatic int avs_widget_ready(struct snd_soc_component *comp, int index,\n\t\t\t    struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_soc_tplg_dapm_widget *dw)\n{\n\tstruct avs_tplg_path_template *template = w->priv;\n\n\ttemplate->w = w;\n\treturn 0;\n}\n\nstatic int avs_dai_load(struct snd_soc_component *comp, int index,\n\t\t\tstruct snd_soc_dai_driver *dai_drv, struct snd_soc_tplg_pcm *pcm,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tif (pcm)\n\t\tdai_drv->ops = &avs_dai_fe_ops;\n\treturn 0;\n}\n\nstatic int avs_link_load(struct snd_soc_component *comp, int index, struct snd_soc_dai_link *link,\n\t\t\t struct snd_soc_tplg_link_config *cfg)\n{\n\tif (link->ignore_suspend && !AVS_S0IX_SUPPORTED) {\n\t\tdev_info_once(comp->dev, \"Device does not support S0IX, check BIOS settings\\n\");\n\t\tlink->ignore_suspend = false;\n\t}\n\n\tif (!link->no_pcm) {\n\t\t \n\t\tlink->nonatomic = true;\n\n\t\t \n\t\tlink->trigger[0] = SND_SOC_DPCM_TRIGGER_PRE;\n\t\tlink->trigger[1] = SND_SOC_DPCM_TRIGGER_PRE;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct avs_tplg_token_parser manifest_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_MANIFEST_NAME_STRING,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_STRING,\n\t\t.offset = offsetof(struct avs_tplg, name),\n\t\t.parse = parse_link_formatted_string,\n\t},\n\t{\n\t\t.token = AVS_TKN_MANIFEST_VERSION_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_tplg, version),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic int avs_manifest(struct snd_soc_component *comp, int index,\n\t\t\tstruct snd_soc_tplg_manifest *manifest)\n{\n\tstruct snd_soc_tplg_vendor_array *tuples = manifest->priv.array;\n\tstruct avs_soc_component *acomp = to_avs_soc_component(comp);\n\tsize_t remaining = le32_to_cpu(manifest->priv.size);\n\tu32 offset;\n\tint ret;\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_LIBRARIES_U32, &offset);\n\t \n\tif (!ret && !offset)\n\t\tret = -EINVAL;\n\tif (ret) {\n\t\tdev_err(comp->dev, \"incorrect manifest format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_parse_tokens(comp, acomp->tplg, manifest_parsers,\n\t\t\t       ARRAY_SIZE(manifest_parsers), tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_AFMTS_U32, &offset);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"audio formats lookup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_tplg_parse_libraries(comp, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_MODCFGS_BASE_U32, &offset);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"modcfgs_base lookup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_tplg_parse_audio_formats(comp, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_MODCFGS_EXT_U32, &offset);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"modcfgs_ext lookup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_tplg_parse_modcfgs_base(comp, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_PPLCFGS_U32, &offset);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"pplcfgs lookup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_tplg_parse_modcfgs_ext(comp, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\tret = avs_tplg_vendor_array_lookup(tuples, remaining,\n\t\t\t\t\t   AVS_TKN_MANIFEST_NUM_BINDINGS_U32, &offset);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"bindings lookup failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = avs_tplg_parse_pplcfgs(comp, tuples, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tremaining -= offset;\n\ttuples = avs_tplg_vendor_array_at(tuples, offset);\n\n\t \n\treturn avs_tplg_parse_bindings(comp, tuples, remaining);\n}\n\n#define AVS_CONTROL_OPS_VOLUME\t257\n\nstatic const struct snd_soc_tplg_kcontrol_ops avs_control_ops[] = {\n\t{\n\t\t.id = AVS_CONTROL_OPS_VOLUME,\n\t\t.get = avs_control_volume_get,\n\t\t.put = avs_control_volume_put,\n\t},\n};\n\nstatic const struct avs_tplg_token_parser control_parsers[] = {\n\t{\n\t\t.token = AVS_TKN_KCONTROL_ID_U32,\n\t\t.type = SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\t.offset = offsetof(struct avs_control_data, id),\n\t\t.parse = avs_parse_word_token,\n\t},\n};\n\nstatic int\navs_control_load(struct snd_soc_component *comp, int index, struct snd_kcontrol_new *ctmpl,\n\t\t struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_soc_tplg_vendor_array *tuples;\n\tstruct snd_soc_tplg_mixer_control *tmc;\n\tstruct avs_control_data *ctl_data;\n\tstruct soc_mixer_control *mc;\n\tsize_t block_size;\n\tint ret;\n\n\tswitch (le32_to_cpu(hdr->type)) {\n\tcase SND_SOC_TPLG_TYPE_MIXER:\n\t\ttmc = container_of(hdr, typeof(*tmc), hdr);\n\t\ttuples = tmc->priv.array;\n\t\tblock_size = le32_to_cpu(tmc->priv.size);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tctl_data = devm_kzalloc(comp->card->dev, sizeof(*ctl_data), GFP_KERNEL);\n\tif (!ctl_data)\n\t\treturn -ENOMEM;\n\n\tret = parse_dictionary_entries(comp, tuples, block_size, ctl_data, 1, sizeof(*ctl_data),\n\t\t\t\t       AVS_TKN_KCONTROL_ID_U32, control_parsers,\n\t\t\t\t       ARRAY_SIZE(control_parsers));\n\tif (ret)\n\t\treturn ret;\n\n\tmc = (struct soc_mixer_control *)ctmpl->private_value;\n\tmc->dobj.private = ctl_data;\n\treturn 0;\n}\n\nstatic struct snd_soc_tplg_ops avs_tplg_ops = {\n\t.io_ops\t\t\t= avs_control_ops,\n\t.io_ops_count\t\t= ARRAY_SIZE(avs_control_ops),\n\t.control_load\t\t= avs_control_load,\n\t.dapm_route_load\t= avs_route_load,\n\t.widget_load\t\t= avs_widget_load,\n\t.widget_ready\t\t= avs_widget_ready,\n\t.dai_load\t\t= avs_dai_load,\n\t.link_load\t\t= avs_link_load,\n\t.manifest\t\t= avs_manifest,\n};\n\nstruct avs_tplg *avs_tplg_new(struct snd_soc_component *comp)\n{\n\tstruct avs_tplg *tplg;\n\n\ttplg = devm_kzalloc(comp->card->dev, sizeof(*tplg), GFP_KERNEL);\n\tif (!tplg)\n\t\treturn NULL;\n\n\ttplg->comp = comp;\n\tINIT_LIST_HEAD(&tplg->path_tmpl_list);\n\n\treturn tplg;\n}\n\nint avs_load_topology(struct snd_soc_component *comp, const char *filename)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, filename, comp->dev);\n\tif (ret < 0) {\n\t\tdev_err(comp->dev, \"request topology \\\"%s\\\" failed: %d\\n\", filename, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_tplg_component_load(comp, &avs_tplg_ops, fw);\n\tif (ret < 0)\n\t\tdev_err(comp->dev, \"load topology \\\"%s\\\" failed: %d\\n\", filename, ret);\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nint avs_remove_topology(struct snd_soc_component *comp)\n{\n\tsnd_soc_tplg_component_remove(comp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}