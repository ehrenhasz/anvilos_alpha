{
  "module_name": "loader.c",
  "hash_id": "72c3a71b805a9547150defd2d58d9b60a2b8a47fff609a3cb6b01ca43e64a623",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/avs/loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/hdaudio.h>\n#include <sound/hdaudio_ext.h>\n#include \"avs.h\"\n#include \"cldma.h\"\n#include \"messages.h\"\n#include \"registers.h\"\n#include \"topology.h\"\n\n#define AVS_ROM_STS_MASK\t\t0xFF\n#define AVS_ROM_INIT_DONE\t\t0x1\n#define SKL_ROM_BASEFW_ENTERED\t\t0xF\n#define APL_ROM_FW_ENTERED\t\t0x5\n#define AVS_ROM_INIT_POLLING_US\t\t5\n#define SKL_ROM_INIT_TIMEOUT_US\t\t1000000\n#define APL_ROM_INIT_TIMEOUT_US\t\t300000\n#define APL_ROM_INIT_RETRIES\t\t3\n\n#define AVS_FW_INIT_POLLING_US\t\t500\n#define AVS_FW_INIT_TIMEOUT_MS\t\t3000\n#define AVS_FW_INIT_TIMEOUT_US\t\t(AVS_FW_INIT_TIMEOUT_MS * 1000)\n\n#define AVS_CLDMA_START_DELAY_MS\t100\n\n#define AVS_ROOT_DIR\t\t\t\"intel/avs\"\n#define AVS_BASEFW_FILENAME\t\t\"dsp_basefw.bin\"\n#define AVS_EXT_MANIFEST_MAGIC\t\t0x31454124\n#define SKL_MANIFEST_MAGIC\t\t0x00000006\n#define SKL_ADSPFW_OFFSET\t\t0x284\n#define APL_MANIFEST_MAGIC\t\t0x44504324\n#define APL_ADSPFW_OFFSET\t\t0x2000\n\n \nstatic bool debug_ignore_fw_version;\nmodule_param_named(ignore_fw_version, debug_ignore_fw_version, bool, 0444);\nMODULE_PARM_DESC(ignore_fw_version, \"Ignore firmware version check 0=no (default), 1=yes\");\n\n#define AVS_LIB_NAME_SIZE\t8\n\nstruct avs_fw_manifest {\n\tu32 id;\n\tu32 len;\n\tchar name[AVS_LIB_NAME_SIZE];\n\tu32 preload_page_count;\n\tu32 img_flags;\n\tu32 feature_mask;\n\tstruct avs_fw_version version;\n} __packed;\n\nstruct avs_fw_ext_manifest {\n\tu32 id;\n\tu32 len;\n\tu16 version_major;\n\tu16 version_minor;\n\tu32 entries;\n} __packed;\n\nstatic int avs_fw_ext_manifest_strip(struct firmware *fw)\n{\n\tstruct avs_fw_ext_manifest *man;\n\n\tif (fw->size < sizeof(*man))\n\t\treturn -EINVAL;\n\n\tman = (struct avs_fw_ext_manifest *)fw->data;\n\tif (man->id == AVS_EXT_MANIFEST_MAGIC) {\n\t\tfw->data += man->len;\n\t\tfw->size -= man->len;\n\t}\n\n\treturn 0;\n}\n\nstatic int avs_fw_manifest_offset(struct firmware *fw)\n{\n\t \n\tu32 magic = *(u32 *)fw->data;\n\n\tswitch (magic) {\n\tcase SKL_MANIFEST_MAGIC:\n\t\treturn SKL_ADSPFW_OFFSET;\n\tcase APL_MANIFEST_MAGIC:\n\t\treturn APL_ADSPFW_OFFSET;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int avs_fw_manifest_strip_verify(struct avs_dev *adev, struct firmware *fw,\n\t\t\t\t\tconst struct avs_fw_version *min)\n{\n\tstruct avs_fw_manifest *man;\n\tint offset, ret;\n\n\tret = avs_fw_ext_manifest_strip(fw);\n\tif (ret)\n\t\treturn ret;\n\n\toffset = avs_fw_manifest_offset(fw);\n\tif (offset < 0)\n\t\treturn offset;\n\n\tif (fw->size < offset + sizeof(*man))\n\t\treturn -EINVAL;\n\tif (!min)\n\t\treturn 0;\n\n\tman = (struct avs_fw_manifest *)(fw->data + offset);\n\tif (man->version.major != min->major ||\n\t    man->version.minor != min->minor ||\n\t    man->version.hotfix != min->hotfix ||\n\t    man->version.build < min->build) {\n\t\tdev_warn(adev->dev, \"bad FW version %d.%d.%d.%d, expected %d.%d.%d.%d or newer\\n\",\n\t\t\t man->version.major, man->version.minor,\n\t\t\t man->version.hotfix, man->version.build,\n\t\t\t min->major, min->minor, min->hotfix, min->build);\n\n\t\tif (!debug_ignore_fw_version)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint avs_cldma_load_basefw(struct avs_dev *adev, struct firmware *fw)\n{\n\tstruct hda_cldma *cl = &code_loader;\n\tunsigned int reg;\n\tint ret;\n\n\tret = avs_dsp_op(adev, power, AVS_MAIN_CORE_MASK, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = avs_dsp_op(adev, reset, AVS_MAIN_CORE_MASK, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hda_cldma_reset(cl);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"cldma reset failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\thda_cldma_setup(cl);\n\n\tret = avs_dsp_op(adev, stall, AVS_MAIN_CORE_MASK, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treinit_completion(&adev->fw_ready);\n\tavs_dsp_op(adev, int_control, true);\n\n\t \n\tret = snd_hdac_adsp_readl_poll(adev, AVS_FW_REG_STATUS(adev), reg,\n\t\t\t\t       (reg & AVS_ROM_INIT_DONE) == AVS_ROM_INIT_DONE,\n\t\t\t\t       AVS_ROM_INIT_POLLING_US, SKL_ROM_INIT_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"rom init timeout: %d\\n\", ret);\n\t\tavs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\t\treturn ret;\n\t}\n\n\thda_cldma_set_data(cl, (void *)fw->data, fw->size);\n\t \n\thda_cldma_transfer(cl, 0);\n\tret = snd_hdac_adsp_readl_poll(adev, AVS_FW_REG_STATUS(adev), reg,\n\t\t\t\t       (reg & AVS_ROM_STS_MASK) == SKL_ROM_BASEFW_ENTERED,\n\t\t\t\t       AVS_FW_INIT_POLLING_US, AVS_FW_INIT_TIMEOUT_US);\n\thda_cldma_stop(cl);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"transfer fw failed: %d\\n\", ret);\n\t\tavs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint avs_cldma_load_library(struct avs_dev *adev, struct firmware *lib, u32 id)\n{\n\tstruct hda_cldma *cl = &code_loader;\n\tint ret;\n\n\thda_cldma_set_data(cl, (void *)lib->data, lib->size);\n\t \n\thda_cldma_transfer(cl, msecs_to_jiffies(AVS_CLDMA_START_DELAY_MS));\n\n\t \n\tret = avs_ipc_load_library(adev, 0, id);\n\thda_cldma_stop(cl);\n\n\tif (ret) {\n\t\tret = AVS_IPC_RET(ret);\n\t\tdev_err(adev->dev, \"transfer lib %d failed: %d\\n\", id, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int avs_cldma_load_module(struct avs_dev *adev, struct avs_module_entry *mentry)\n{\n\tstruct hda_cldma *cl = &code_loader;\n\tconst struct firmware *mod;\n\tchar *mod_name;\n\tint ret;\n\n\tmod_name = kasprintf(GFP_KERNEL, \"%s/%s/dsp_mod_%pUL.bin\", AVS_ROOT_DIR,\n\t\t\t     adev->spec->name, mentry->uuid.b);\n\tif (!mod_name)\n\t\treturn -ENOMEM;\n\n\tret = avs_request_firmware(adev, &mod, mod_name);\n\tkfree(mod_name);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tavs_hda_power_gating_enable(adev, false);\n\tavs_hda_clock_gating_enable(adev, false);\n\tavs_hda_l1sen_enable(adev, false);\n\n\thda_cldma_set_data(cl, (void *)mod->data, mod->size);\n\thda_cldma_transfer(cl, msecs_to_jiffies(AVS_CLDMA_START_DELAY_MS));\n\tret = avs_ipc_load_modules(adev, &mentry->module_id, 1);\n\thda_cldma_stop(cl);\n\n\tavs_hda_l1sen_enable(adev, true);\n\tavs_hda_clock_gating_enable(adev, true);\n\tavs_hda_power_gating_enable(adev, true);\n\n\tif (ret) {\n\t\tdev_err(adev->dev, \"load module %d failed: %d\\n\", mentry->module_id, ret);\n\t\tavs_release_last_firmware(adev);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\treturn 0;\n}\n\nint avs_cldma_transfer_modules(struct avs_dev *adev, bool load,\n\t\t\t       struct avs_module_entry *mods, u32 num_mods)\n{\n\tu16 *mod_ids;\n\tint ret, i;\n\n\t \n\tif (load) {\n\t\tfor (i = 0; i < num_mods; i++) {\n\t\t\tret = avs_cldma_load_module(adev, &mods[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tmod_ids = kcalloc(num_mods, sizeof(u16), GFP_KERNEL);\n\tif (!mod_ids)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_mods; i++)\n\t\tmod_ids[i] = mods[i].module_id;\n\n\tret = avs_ipc_unload_modules(adev, mod_ids, num_mods);\n\tkfree(mod_ids);\n\tif (ret)\n\t\treturn AVS_IPC_RET(ret);\n\n\treturn 0;\n}\n\nstatic int\navs_hda_init_rom(struct avs_dev *adev, unsigned int dma_id, bool purge)\n{\n\tconst struct avs_spec *const spec = adev->spec;\n\tunsigned int corex_mask, reg;\n\tint ret;\n\n\tcorex_mask = spec->core_init_mask & ~AVS_MAIN_CORE_MASK;\n\n\tret = avs_dsp_op(adev, power, spec->core_init_mask, true);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = avs_dsp_op(adev, reset, AVS_MAIN_CORE_MASK, false);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treinit_completion(&adev->fw_ready);\n\tavs_dsp_op(adev, int_control, true);\n\n\t \n\tret = avs_ipc_set_boot_config(adev, dma_id, purge);\n\tif (ret) {\n\t\tret = AVS_IPC_RET(ret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = snd_hdac_adsp_readq_poll(adev, spec->rom_status, reg,\n\t\t\t\t       (reg & 0xF) == AVS_ROM_INIT_DONE ||\n\t\t\t\t       (reg & 0xF) == APL_ROM_FW_ENTERED,\n\t\t\t\t       AVS_ROM_INIT_POLLING_US, APL_ROM_INIT_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"rom init timeout: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tif (corex_mask) {\n\t\tret = avs_dsp_op(adev, power, corex_mask, false);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tavs_dsp_core_disable(adev, spec->core_init_mask);\n\treturn ret;\n}\n\nstatic int avs_imr_load_basefw(struct avs_dev *adev)\n{\n\tint ret;\n\n\t \n\tret = avs_hda_init_rom(adev, 0, false);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"rom init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&adev->fw_ready,\n\t\t\t\t\t  msecs_to_jiffies(AVS_FW_INIT_TIMEOUT_MS));\n\tif (!ret) {\n\t\tdev_err(adev->dev, \"firmware ready timeout\\n\");\n\t\tavs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint avs_hda_load_basefw(struct avs_dev *adev, struct firmware *fw)\n{\n\tstruct snd_pcm_substream substream;\n\tstruct snd_dma_buffer dmab;\n\tstruct hdac_ext_stream *estream;\n\tstruct hdac_stream *hstream;\n\tstruct hdac_bus *bus = &adev->base.core;\n\tunsigned int sdfmt, reg;\n\tint ret, i;\n\n\t \n\tmemset(&substream, 0, sizeof(substream));\n\tsubstream.stream = SNDRV_PCM_STREAM_PLAYBACK;\n\testream = snd_hdac_ext_stream_assign(bus, &substream,\n\t\t\t\t\t     HDAC_EXT_STREAM_TYPE_HOST);\n\tif (!estream)\n\t\treturn -ENODEV;\n\thstream = hdac_stream(estream);\n\n\t \n\tsdfmt = snd_hdac_calc_stream_format(48000, 1, SNDRV_PCM_FORMAT_S32_LE, 32, 0);\n\tret = snd_hdac_dsp_prepare(hstream, sdfmt, fw->size, &dmab);\n\tif (ret < 0)\n\t\tgoto release_stream;\n\n\t \n\tsnd_hdac_stream_spbcap_enable(bus, true, hstream->index);\n\tret = snd_hdac_stream_set_spib(bus, hstream, fw->size);\n\tif (ret)\n\t\tgoto cleanup_resources;\n\n\tmemcpy(dmab.area, fw->data, fw->size);\n\n\tfor (i = 0; i < APL_ROM_INIT_RETRIES; i++) {\n\t\tunsigned int dma_id = hstream->stream_tag - 1;\n\n\t\tret = avs_hda_init_rom(adev, dma_id, true);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tdev_info(adev->dev, \"#%d rom init fail: %d\\n\", i + 1, ret);\n\t}\n\tif (ret < 0)\n\t\tgoto cleanup_resources;\n\n\t \n\tsnd_hdac_dsp_trigger(hstream, true);\n\tret = snd_hdac_adsp_readl_poll(adev, AVS_FW_REG_STATUS(adev), reg,\n\t\t\t\t       (reg & AVS_ROM_STS_MASK) == APL_ROM_FW_ENTERED,\n\t\t\t\t       AVS_FW_INIT_POLLING_US, AVS_FW_INIT_TIMEOUT_US);\n\tsnd_hdac_dsp_trigger(hstream, false);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"transfer fw failed: %d\\n\", ret);\n\t\tavs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\t}\n\ncleanup_resources:\n\t \n\tsnd_hdac_stream_spbcap_enable(bus, false, hstream->index);\n\tsnd_hdac_stream_set_spib(bus, hstream, 0);\n\n\tsnd_hdac_dsp_cleanup(hstream, &dmab);\nrelease_stream:\n\tsnd_hdac_ext_stream_release(estream, HDAC_EXT_STREAM_TYPE_HOST);\n\n\treturn ret;\n}\n\nint avs_hda_load_library(struct avs_dev *adev, struct firmware *lib, u32 id)\n{\n\tstruct snd_pcm_substream substream;\n\tstruct snd_dma_buffer dmab;\n\tstruct hdac_ext_stream *estream;\n\tstruct hdac_stream *stream;\n\tstruct hdac_bus *bus = &adev->base.core;\n\tunsigned int sdfmt;\n\tint ret;\n\n\t \n\tmemset(&substream, 0, sizeof(substream));\n\tsubstream.stream = SNDRV_PCM_STREAM_PLAYBACK;\n\testream = snd_hdac_ext_stream_assign(bus, &substream,\n\t\t\t\t\t     HDAC_EXT_STREAM_TYPE_HOST);\n\tif (!estream)\n\t\treturn -ENODEV;\n\tstream = hdac_stream(estream);\n\n\t \n\tsdfmt = snd_hdac_calc_stream_format(48000, 1, SNDRV_PCM_FORMAT_S32_LE, 32, 0);\n\tret = snd_hdac_dsp_prepare(stream, sdfmt, lib->size, &dmab);\n\tif (ret < 0)\n\t\tgoto release_stream;\n\n\t \n\tsnd_hdac_stream_spbcap_enable(bus, true, stream->index);\n\tsnd_hdac_stream_set_spib(bus, stream, lib->size);\n\n\tmemcpy(dmab.area, lib->data, lib->size);\n\n\t \n\tsnd_hdac_dsp_trigger(stream, true);\n\tret = avs_ipc_load_library(adev, stream->stream_tag - 1, id);\n\tsnd_hdac_dsp_trigger(stream, false);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"transfer lib %d failed: %d\\n\", id, ret);\n\t\tret = AVS_IPC_RET(ret);\n\t}\n\n\t \n\tsnd_hdac_stream_spbcap_enable(bus, false, stream->index);\n\tsnd_hdac_stream_set_spib(bus, stream, 0);\n\n\tsnd_hdac_dsp_cleanup(stream, &dmab);\nrelease_stream:\n\tsnd_hdac_ext_stream_release(estream, HDAC_EXT_STREAM_TYPE_HOST);\n\n\treturn ret;\n}\n\nint avs_hda_transfer_modules(struct avs_dev *adev, bool load,\n\t\t\t     struct avs_module_entry *mods, u32 num_mods)\n{\n\t \n\treturn 0;\n}\n\nint avs_dsp_load_libraries(struct avs_dev *adev, struct avs_tplg_library *libs, u32 num_libs)\n{\n\tint start, id, i = 0;\n\tint ret;\n\n\t \n\tfor (id = 0; id < adev->fw_cfg.max_libs_count; id++)\n\t\tif (adev->lib_names[id][0] == '\\0')\n\t\t\tbreak;\n\tif (id + num_libs >= adev->fw_cfg.max_libs_count)\n\t\treturn -EINVAL;\n\n\tstart = id;\n\twhile (i < num_libs) {\n\t\tstruct avs_fw_manifest *man;\n\t\tconst struct firmware *fw;\n\t\tstruct firmware stripped_fw;\n\t\tchar *filename;\n\t\tint j;\n\n\t\tfilename = kasprintf(GFP_KERNEL, \"%s/%s/%s\", AVS_ROOT_DIR, adev->spec->name,\n\t\t\t\t     libs[i].name);\n\t\tif (!filename)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tret = avs_request_firmware(adev, &fw, filename);\n\t\tkfree(filename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstripped_fw = *fw;\n\t\tret = avs_fw_manifest_strip_verify(adev, &stripped_fw, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"invalid library data: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = avs_fw_manifest_offset(&stripped_fw);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tman = (struct avs_fw_manifest *)(stripped_fw.data + ret);\n\n\t\t \n\t\tfor (j = 0; j < id; j++)\n\t\t\tif (!strncmp(adev->lib_names[j], man->name, AVS_LIB_NAME_SIZE))\n\t\t\t\tgoto next_lib;\n\n\t\tret = avs_dsp_op(adev, load_lib, &stripped_fw, id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstrncpy(adev->lib_names[id], man->name, AVS_LIB_NAME_SIZE);\n\t\tid++;\nnext_lib:\n\t\ti++;\n\t}\n\n\treturn start == id ? 1 : 0;\n}\n\nstatic int avs_dsp_load_basefw(struct avs_dev *adev)\n{\n\tconst struct avs_fw_version *min_req;\n\tconst struct avs_spec *const spec = adev->spec;\n\tconst struct firmware *fw;\n\tstruct firmware stripped_fw;\n\tchar *filename;\n\tint ret;\n\n\tfilename = kasprintf(GFP_KERNEL, \"%s/%s/%s\", AVS_ROOT_DIR, spec->name, AVS_BASEFW_FILENAME);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\tret = avs_request_firmware(adev, &fw, filename);\n\tkfree(filename);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"request firmware failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tstripped_fw = *fw;\n\tmin_req = &adev->spec->min_fw_version;\n\n\tret = avs_fw_manifest_strip_verify(adev, &stripped_fw, min_req);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"invalid firmware data: %d\\n\", ret);\n\t\tgoto release_fw;\n\t}\n\n\tret = avs_dsp_op(adev, load_basefw, &stripped_fw);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"basefw load failed: %d\\n\", ret);\n\t\tgoto release_fw;\n\t}\n\n\tret = wait_for_completion_timeout(&adev->fw_ready,\n\t\t\t\t\t  msecs_to_jiffies(AVS_FW_INIT_TIMEOUT_MS));\n\tif (!ret) {\n\t\tdev_err(adev->dev, \"firmware ready timeout\\n\");\n\t\tavs_dsp_core_disable(adev, AVS_MAIN_CORE_MASK);\n\t\tret = -ETIMEDOUT;\n\t\tgoto release_fw;\n\t}\n\n\treturn 0;\n\nrelease_fw:\n\tavs_release_last_firmware(adev);\n\treturn ret;\n}\n\nint avs_dsp_boot_firmware(struct avs_dev *adev, bool purge)\n{\n\tstruct avs_soc_component *acomp;\n\tint ret, i;\n\n\t \n\tif (!purge && avs_platattr_test(adev, IMR)) {\n\t\tret = avs_imr_load_basefw(adev);\n\t\tif (!ret)\n\t\t\treturn 0;\n\n\t\tdev_dbg(adev->dev, \"firmware flash from imr failed: %d\\n\", ret);\n\t}\n\n\t \n\tfor (i = 1; i < adev->fw_cfg.max_libs_count; i++)\n\t\tmemset(adev->lib_names[i], 0, AVS_LIB_NAME_SIZE);\n\n\tavs_hda_power_gating_enable(adev, false);\n\tavs_hda_clock_gating_enable(adev, false);\n\tavs_hda_l1sen_enable(adev, false);\n\n\tret = avs_dsp_load_basefw(adev);\n\tif (ret)\n\t\tgoto reenable_gating;\n\n\tmutex_lock(&adev->comp_list_mutex);\n\tlist_for_each_entry(acomp, &adev->comp_list, node) {\n\t\tstruct avs_tplg *tplg = acomp->tplg;\n\n\t\tret = avs_dsp_load_libraries(adev, tplg->libs, tplg->num_libs);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&adev->comp_list_mutex);\n\nreenable_gating:\n\tavs_hda_l1sen_enable(adev, true);\n\tavs_hda_clock_gating_enable(adev, true);\n\tavs_hda_power_gating_enable(adev, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = avs_module_info_init(adev, true);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"init module info failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint avs_dsp_first_boot_firmware(struct avs_dev *adev)\n{\n\tint ret, i;\n\n\tif (avs_platattr_test(adev, CLDMA)) {\n\t\tret = hda_cldma_init(&code_loader, &adev->base.core,\n\t\t\t\t     adev->dsp_ba, AVS_CL_DEFAULT_BUFFER_SIZE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adev->dev, \"cldma init failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = avs_dsp_boot_firmware(adev, true);\n\tif (ret < 0) {\n\t\tdev_err(adev->dev, \"firmware boot failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = avs_ipc_get_hw_config(adev, &adev->hw_cfg);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"get hw cfg failed: %d\\n\", ret);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\tret = avs_ipc_get_fw_config(adev, &adev->fw_cfg);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"get fw cfg failed: %d\\n\", ret);\n\t\treturn AVS_IPC_RET(ret);\n\t}\n\n\tadev->core_refs = devm_kcalloc(adev->dev, adev->hw_cfg.dsp_cores,\n\t\t\t\t       sizeof(*adev->core_refs), GFP_KERNEL);\n\tadev->lib_names = devm_kcalloc(adev->dev, adev->fw_cfg.max_libs_count,\n\t\t\t\t       sizeof(*adev->lib_names), GFP_KERNEL);\n\tif (!adev->core_refs || !adev->lib_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < adev->fw_cfg.max_libs_count; i++) {\n\t\tadev->lib_names[i] = devm_kzalloc(adev->dev, AVS_LIB_NAME_SIZE, GFP_KERNEL);\n\t\tif (!adev->lib_names[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tstrcpy(&adev->lib_names[0][0], \"BASEFW\");\n\n\tida_init(&adev->ppl_ida);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}