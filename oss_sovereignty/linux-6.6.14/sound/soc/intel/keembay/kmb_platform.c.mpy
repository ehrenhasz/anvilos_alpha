{
  "module_name": "kmb_platform.c",
  "hash_id": "be4cb1b5d240f28b29b72d8637be6e7956cb39461acd89729bc1d24f167d03d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/keembay/kmb_platform.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bitrev.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"kmb_platform.h\"\n\n#define PERIODS_MIN\t\t2\n#define PERIODS_MAX\t\t48\n#define PERIOD_BYTES_MIN\t4096\n#define BUFFER_BYTES_MAX\t(PERIODS_MAX * PERIOD_BYTES_MIN)\n#define TDM_OPERATION\t\t5\n#define I2S_OPERATION\t\t0\n#define DATA_WIDTH_CONFIG_BIT\t6\n#define TDM_CHANNEL_CONFIG_BIT\t3\n\nstatic const struct snd_pcm_hardware kmb_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.rates = SNDRV_PCM_RATE_8000 |\n\t\t SNDRV_PCM_RATE_16000 |\n\t\t SNDRV_PCM_RATE_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t   SNDRV_PCM_FMTBIT_S32_LE |\n\t\t   SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,\n\t.periods_min = PERIODS_MIN,\n\t.periods_max = PERIODS_MAX,\n\t.fifo_size = 16,\n};\n\n \nstatic void hdmi_reformat_iec958(struct snd_pcm_runtime *runtime,\n\t\t\t\t struct kmb_i2s_info *kmb_i2s,\n\t\t\t\t unsigned int tx_ptr)\n{\n\tu32(*buf)[2] = (void *)runtime->dma_area;\n\tunsigned long temp;\n\tu32 i, j, sample;\n\n\tfor (i = 0; i < kmb_i2s->fifo_th; i++) {\n\t\tj = 0;\n\t\tdo {\n\t\t\ttemp = buf[tx_ptr][j];\n\t\t\t \n\t\t\tassign_bit(31, &temp, (BIT(3) & temp));\n\t\t\tsample = bitrev32(temp);\n\t\t\tbuf[tx_ptr][j] = sample << 4;\n\t\t\tj++;\n\t\t} while (j < 2);\n\t\ttx_ptr++;\n\t}\n}\n\nstatic unsigned int kmb_pcm_tx_fn(struct kmb_i2s_info *kmb_i2s,\n\t\t\t\t  struct snd_pcm_runtime *runtime,\n\t\t\t\t  unsigned int tx_ptr, bool *period_elapsed)\n{\n\tunsigned int period_pos = tx_ptr % runtime->period_size;\n\tvoid __iomem *i2s_base = kmb_i2s->i2s_base;\n\tvoid *buf = runtime->dma_area;\n\tint i;\n\n\tif (kmb_i2s->iec958_fmt)\n\t\thdmi_reformat_iec958(runtime, kmb_i2s, tx_ptr);\n\n\t \n\tfor (i = 0; i < kmb_i2s->fifo_th; i++) {\n\t\tif (kmb_i2s->config.data_width == 16) {\n\t\t\twritel(((u16(*)[2])buf)[tx_ptr][0], i2s_base + LRBR_LTHR(0));\n\t\t\twritel(((u16(*)[2])buf)[tx_ptr][1], i2s_base + RRBR_RTHR(0));\n\t\t} else {\n\t\t\twritel(((u32(*)[2])buf)[tx_ptr][0], i2s_base + LRBR_LTHR(0));\n\t\t\twritel(((u32(*)[2])buf)[tx_ptr][1], i2s_base + RRBR_RTHR(0));\n\t\t}\n\n\t\tperiod_pos++;\n\n\t\tif (++tx_ptr >= runtime->buffer_size)\n\t\t\ttx_ptr = 0;\n\t}\n\n\t*period_elapsed = period_pos >= runtime->period_size;\n\n\treturn tx_ptr;\n}\n\nstatic unsigned int kmb_pcm_rx_fn(struct kmb_i2s_info *kmb_i2s,\n\t\t\t\t  struct snd_pcm_runtime *runtime,\n\t\t\t\t  unsigned int rx_ptr, bool *period_elapsed)\n{\n\tunsigned int period_pos = rx_ptr % runtime->period_size;\n\tvoid __iomem *i2s_base = kmb_i2s->i2s_base;\n\tint chan = kmb_i2s->config.chan_nr;\n\tvoid *buf = runtime->dma_area;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < kmb_i2s->fifo_th; i++) {\n\t\tfor (j = 0; j < chan / 2; j++) {\n\t\t\tif (kmb_i2s->config.data_width == 16) {\n\t\t\t\t((u16 *)buf)[rx_ptr * chan + (j * 2)] =\n\t\t\t\t\t\treadl(i2s_base + LRBR_LTHR(j));\n\t\t\t\t((u16 *)buf)[rx_ptr * chan + ((j * 2) + 1)] =\n\t\t\t\t\t\treadl(i2s_base + RRBR_RTHR(j));\n\t\t\t} else {\n\t\t\t\t((u32 *)buf)[rx_ptr * chan + (j * 2)] =\n\t\t\t\t\t\treadl(i2s_base + LRBR_LTHR(j));\n\t\t\t\t((u32 *)buf)[rx_ptr * chan + ((j * 2) + 1)] =\n\t\t\t\t\t\treadl(i2s_base + RRBR_RTHR(j));\n\t\t\t}\n\t\t}\n\t\tperiod_pos++;\n\n\t\tif (++rx_ptr >= runtime->buffer_size)\n\t\t\trx_ptr = 0;\n\t}\n\n\t*period_elapsed = period_pos >= runtime->period_size;\n\n\treturn rx_ptr;\n}\n\nstatic inline void kmb_i2s_disable_channels(struct kmb_i2s_info *kmb_i2s,\n\t\t\t\t\t    u32 stream)\n{\n\tu32 i;\n\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tfor (i = 0; i < MAX_ISR; i++)\n\t\t\twritel(0, kmb_i2s->i2s_base + TER(i));\n\t} else {\n\t\tfor (i = 0; i < MAX_ISR; i++)\n\t\t\twritel(0, kmb_i2s->i2s_base + RER(i));\n\t}\n}\n\nstatic inline void kmb_i2s_clear_irqs(struct kmb_i2s_info *kmb_i2s, u32 stream)\n{\n\tstruct i2s_clk_config_data *config = &kmb_i2s->config;\n\tu32 i;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tfor (i = 0; i < config->chan_nr / 2; i++)\n\t\t\treadl(kmb_i2s->i2s_base + TOR(i));\n\t} else {\n\t\tfor (i = 0; i < config->chan_nr / 2; i++)\n\t\t\treadl(kmb_i2s->i2s_base + ROR(i));\n\t}\n}\n\nstatic inline void kmb_i2s_irq_trigger(struct kmb_i2s_info *kmb_i2s,\n\t\t\t\t       u32 stream, int chan_nr, bool trigger)\n{\n\tu32 i, irq;\n\tu32 flag;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tflag = TX_INT_FLAG;\n\telse\n\t\tflag = RX_INT_FLAG;\n\n\tfor (i = 0; i < chan_nr / 2; i++) {\n\t\tirq = readl(kmb_i2s->i2s_base + IMR(i));\n\n\t\tif (trigger)\n\t\t\tirq = irq & ~flag;\n\t\telse\n\t\t\tirq = irq | flag;\n\n\t\twritel(irq, kmb_i2s->i2s_base + IMR(i));\n\t}\n}\n\nstatic void kmb_pcm_operation(struct kmb_i2s_info *kmb_i2s, bool playback)\n{\n\tstruct snd_pcm_substream *substream;\n\tbool period_elapsed;\n\tunsigned int new_ptr;\n\tunsigned int ptr;\n\n\tif (playback)\n\t\tsubstream = kmb_i2s->tx_substream;\n\telse\n\t\tsubstream = kmb_i2s->rx_substream;\n\n\tif (!substream || !snd_pcm_running(substream))\n\t\treturn;\n\n\tif (playback) {\n\t\tptr = kmb_i2s->tx_ptr;\n\t\tnew_ptr = kmb_pcm_tx_fn(kmb_i2s, substream->runtime,\n\t\t\t\t\tptr, &period_elapsed);\n\t\tcmpxchg(&kmb_i2s->tx_ptr, ptr, new_ptr);\n\t} else {\n\t\tptr = kmb_i2s->rx_ptr;\n\t\tnew_ptr = kmb_pcm_rx_fn(kmb_i2s, substream->runtime,\n\t\t\t\t\tptr, &period_elapsed);\n\t\tcmpxchg(&kmb_i2s->rx_ptr, ptr, new_ptr);\n\t}\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int kmb_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct kmb_i2s_info *kmb_i2s;\n\n\tkmb_i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tsnd_soc_set_runtime_hwparams(substream, &kmb_pcm_hardware);\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\truntime->private_data = kmb_i2s;\n\n\treturn 0;\n}\n\nstatic int kmb_pcm_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct kmb_i2s_info *kmb_i2s = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tkmb_i2s->tx_ptr = 0;\n\t\t\tkmb_i2s->tx_substream = substream;\n\t\t} else {\n\t\t\tkmb_i2s->rx_ptr = 0;\n\t\t\tkmb_i2s->rx_substream = substream;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tkmb_i2s->tx_substream = NULL;\n\t\telse\n\t\t\tkmb_i2s->rx_substream = NULL;\n\t\tkmb_i2s->iec958_fmt = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t kmb_i2s_irq_handler(int irq, void *dev_id)\n{\n\tstruct kmb_i2s_info *kmb_i2s = dev_id;\n\tstruct i2s_clk_config_data *config = &kmb_i2s->config;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 tx_enabled = 0;\n\tu32 isr[4];\n\tint i;\n\n\tfor (i = 0; i < config->chan_nr / 2; i++)\n\t\tisr[i] = readl(kmb_i2s->i2s_base + ISR(i));\n\n\tkmb_i2s_clear_irqs(kmb_i2s, SNDRV_PCM_STREAM_PLAYBACK);\n\tkmb_i2s_clear_irqs(kmb_i2s, SNDRV_PCM_STREAM_CAPTURE);\n\t \n\ttx_enabled = readl(kmb_i2s->i2s_base + ITER);\n\n\t \n\n\t \n\tswitch (config->chan_nr) {\n\tcase 2:\n\t\tif (isr[0] & ISR_RXDA)\n\t\t\tkmb_pcm_operation(kmb_i2s, false);\n\t\tret = IRQ_HANDLED;\n\t\tbreak;\n\tcase 4:\n\t\tif (isr[1] & ISR_RXDA)\n\t\t\tkmb_pcm_operation(kmb_i2s, false);\n\t\tret = IRQ_HANDLED;\n\t\tbreak;\n\tcase 8:\n\t\tif (isr[3] & ISR_RXDA)\n\t\t\tkmb_pcm_operation(kmb_i2s, false);\n\t\tret = IRQ_HANDLED;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < config->chan_nr / 2; i++) {\n\t\t \n\t\tif ((isr[i] & ISR_TXFE) && tx_enabled) {\n\t\t\tkmb_pcm_operation(kmb_i2s, true);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\tif (isr[i] & ISR_TXFO) {\n\t\t\tdev_dbg(kmb_i2s->dev, \"TX overrun (ch_id=%d)\\n\", i);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t\t \n\t\tif (isr[i] & ISR_RXFO) {\n\t\t\tdev_dbg(kmb_i2s->dev, \"RX overrun (ch_id=%d)\\n\", i);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int kmb_platform_pcm_new(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_pcm_runtime *soc_runtime)\n{\n\tsize_t size = kmb_pcm_hardware.buffer_bytes_max;\n\t \n\tsnd_pcm_set_managed_buffer_all(soc_runtime->pcm,\n\t\t\t\t       SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, size, size);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t kmb_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct kmb_i2s_info *kmb_i2s = runtime->private_data;\n\tsnd_pcm_uframes_t pos;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tpos = kmb_i2s->tx_ptr;\n\telse\n\t\tpos = kmb_i2s->rx_ptr;\n\n\treturn pos < runtime->buffer_size ? pos : 0;\n}\n\nstatic const struct snd_soc_component_driver kmb_component = {\n\t.name\t\t\t= \"kmb\",\n\t.pcm_construct\t\t= kmb_platform_pcm_new,\n\t.open\t\t\t= kmb_pcm_open,\n\t.trigger\t\t= kmb_pcm_trigger,\n\t.pointer\t\t= kmb_pcm_pointer,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct snd_soc_component_driver kmb_component_dma = {\n\t.name\t\t\t= \"kmb\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int kmb_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (kmb_i2s->use_pio)\n\t\treturn 0;\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, &kmb_i2s->play_dma_data,\n\t\t\t\t  &kmb_i2s->capture_dma_data);\n\n\treturn 0;\n}\n\nstatic inline void kmb_i2s_enable_dma(struct kmb_i2s_info *kmb_i2s, u32 stream)\n{\n\tu32 dma_reg;\n\n\tdma_reg = readl(kmb_i2s->i2s_base + I2S_DMACR);\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_reg |= I2S_DMAEN_TXBLOCK;\n\telse\n\t\tdma_reg |= I2S_DMAEN_RXBLOCK;\n\n\twritel(dma_reg, kmb_i2s->i2s_base + I2S_DMACR);\n}\n\nstatic inline void kmb_i2s_disable_dma(struct kmb_i2s_info *kmb_i2s, u32 stream)\n{\n\tu32 dma_reg;\n\n\tdma_reg = readl(kmb_i2s->i2s_base + I2S_DMACR);\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdma_reg &= ~I2S_DMAEN_TXBLOCK;\n\t\twritel(1, kmb_i2s->i2s_base + I2S_RTXDMA);\n\t} else {\n\t\tdma_reg &= ~I2S_DMAEN_RXBLOCK;\n\t\twritel(1, kmb_i2s->i2s_base + I2S_RRXDMA);\n\t}\n\twritel(dma_reg, kmb_i2s->i2s_base + I2S_DMACR);\n}\n\nstatic void kmb_i2s_start(struct kmb_i2s_info *kmb_i2s,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct i2s_clk_config_data *config = &kmb_i2s->config;\n\n\t \n\twritel(1, kmb_i2s->i2s_base + IER);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\twritel(1, kmb_i2s->i2s_base + ITER);\n\telse\n\t\twritel(1, kmb_i2s->i2s_base + IRER);\n\n\tif (kmb_i2s->use_pio)\n\t\tkmb_i2s_irq_trigger(kmb_i2s, substream->stream,\n\t\t\t\t    config->chan_nr, true);\n\telse\n\t\tkmb_i2s_enable_dma(kmb_i2s, substream->stream);\n\n\tif (kmb_i2s->clock_provider)\n\t\twritel(1, kmb_i2s->i2s_base + CER);\n\telse\n\t\twritel(0, kmb_i2s->i2s_base + CER);\n}\n\nstatic void kmb_i2s_stop(struct kmb_i2s_info *kmb_i2s,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\t \n\tkmb_i2s_clear_irqs(kmb_i2s, substream->stream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\twritel(0, kmb_i2s->i2s_base + ITER);\n\telse\n\t\twritel(0, kmb_i2s->i2s_base + IRER);\n\n\tkmb_i2s_irq_trigger(kmb_i2s, substream->stream, 8, false);\n\n\tif (!kmb_i2s->active) {\n\t\twritel(0, kmb_i2s->i2s_base + CER);\n\t\twritel(0, kmb_i2s->i2s_base + IER);\n\t}\n}\n\nstatic void kmb_disable_clk(void *clk)\n{\n\tclk_disable_unprepare(clk);\n}\n\nstatic int kmb_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tkmb_i2s->clock_provider = false;\n\t\tret = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\twritel(CLOCK_PROVIDER_MODE, kmb_i2s->pss_base + I2S_GEN_CFG_0);\n\n\t\tret = clk_prepare_enable(kmb_i2s->clk_i2s);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(kmb_i2s->dev, kmb_disable_clk,\n\t\t\t\t\t       kmb_i2s->clk_i2s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkmb_i2s->clock_provider = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int kmb_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t   int cmd, struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s  = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tkmb_i2s->active++;\n\t\tkmb_i2s_start(kmb_i2s, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tkmb_i2s->active--;\n\t\tif (kmb_i2s->use_pio)\n\t\t\tkmb_i2s_stop(kmb_i2s, substream);\n\t\tbreak;\n\tdefault:\n\t\treturn  -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void kmb_i2s_config(struct kmb_i2s_info *kmb_i2s, int stream)\n{\n\tstruct i2s_clk_config_data *config = &kmb_i2s->config;\n\tu32 ch_reg;\n\n\tkmb_i2s_disable_channels(kmb_i2s, stream);\n\n\tfor (ch_reg = 0; ch_reg < config->chan_nr / 2; ch_reg++) {\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\twritel(kmb_i2s->xfer_resolution,\n\t\t\t       kmb_i2s->i2s_base + TCR(ch_reg));\n\n\t\t\twritel(kmb_i2s->fifo_th - 1,\n\t\t\t       kmb_i2s->i2s_base + TFCR(ch_reg));\n\n\t\t\twritel(1, kmb_i2s->i2s_base + TER(ch_reg));\n\t\t} else {\n\t\t\twritel(kmb_i2s->xfer_resolution,\n\t\t\t       kmb_i2s->i2s_base + RCR(ch_reg));\n\n\t\t\twritel(kmb_i2s->fifo_th - 1,\n\t\t\t       kmb_i2s->i2s_base + RFCR(ch_reg));\n\n\t\t\twritel(1, kmb_i2s->i2s_base + RER(ch_reg));\n\t\t}\n\t}\n}\n\nstatic int kmb_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct i2s_clk_config_data *config = &kmb_i2s->config;\n\tu32 write_val;\n\tint ret;\n\n\tswitch (params_format(hw_params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tconfig->data_width = 16;\n\t\tkmb_i2s->ccr = 0x00;\n\t\tkmb_i2s->xfer_resolution = 0x02;\n\t\tkmb_i2s->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tkmb_i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tconfig->data_width = 32;\n\t\tkmb_i2s->ccr = 0x14;\n\t\tkmb_i2s->xfer_resolution = 0x05;\n\t\tkmb_i2s->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tkmb_i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\n\t\tkmb_i2s->iec958_fmt = true;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tconfig->data_width = 32;\n\t\tkmb_i2s->ccr = 0x10;\n\t\tkmb_i2s->xfer_resolution = 0x05;\n\t\tkmb_i2s->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tkmb_i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(kmb_i2s->dev, \"kmb: unsupported PCM fmt\");\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->chan_nr = params_channels(hw_params);\n\n\tswitch (config->chan_nr) {\n\tcase 8:\n\tcase 4:\n\t\t \n\t\tif (kmb_i2s->clock_provider)\n\t\t\treturn -EINVAL;\n\n\t\twrite_val = ((config->chan_nr / 2) << TDM_CHANNEL_CONFIG_BIT) |\n\t\t\t\t(config->data_width << DATA_WIDTH_CONFIG_BIT) |\n\t\t\t\tTDM_OPERATION;\n\n\t\twritel(write_val, kmb_i2s->pss_base + I2S_GEN_CFG_0);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tif (!(kmb_i2s->clock_provider))\n\t\t\treturn -EINVAL;\n\n\t\twrite_val = ((config->chan_nr / 2) << TDM_CHANNEL_CONFIG_BIT) |\n\t\t\t\t(config->data_width << DATA_WIDTH_CONFIG_BIT) |\n\t\t\t\tCLOCK_PROVIDER_MODE | I2S_OPERATION;\n\n\t\twritel(write_val, kmb_i2s->pss_base + I2S_GEN_CFG_0);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(kmb_i2s->dev, \"channel not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkmb_i2s_config(kmb_i2s, substream->stream);\n\n\twritel(kmb_i2s->ccr, kmb_i2s->i2s_base + CCR);\n\n\tconfig->sample_rate = params_rate(hw_params);\n\n\tif (kmb_i2s->clock_provider) {\n\t\t \n\t\tu32 bitclk = config->sample_rate * config->data_width * 2;\n\n\t\tret = clk_set_rate(kmb_i2s->clk_i2s, bitclk);\n\t\tif (ret) {\n\t\t\tdev_err(kmb_i2s->dev,\n\t\t\t\t\"Can't set I2S clock rate: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kmb_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\twritel(1, kmb_i2s->i2s_base + TXFFR);\n\telse\n\t\twritel(1, kmb_i2s->i2s_base + RXFFR);\n\n\treturn 0;\n}\n\nstatic int kmb_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\n\tif (kmb_i2s->use_pio)\n\t\treturn 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_data = &kmb_i2s->play_dma_data;\n\telse\n\t\tdma_data = &kmb_i2s->capture_dma_data;\n\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);\n\n\treturn 0;\n}\n\nstatic int kmb_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct kmb_i2s_info *kmb_i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\t \n\tif (kmb_i2s->use_pio)\n\t\tkmb_i2s_clear_irqs(kmb_i2s, substream->stream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\twritel(0, kmb_i2s->i2s_base + ITER);\n\telse\n\t\twritel(0, kmb_i2s->i2s_base + IRER);\n\n\tif (kmb_i2s->use_pio)\n\t\tkmb_i2s_irq_trigger(kmb_i2s, substream->stream, 8, false);\n\telse\n\t\tkmb_i2s_disable_dma(kmb_i2s, substream->stream);\n\n\tif (!kmb_i2s->active) {\n\t\twritel(0, kmb_i2s->i2s_base + CER);\n\t\twritel(0, kmb_i2s->i2s_base + IER);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops kmb_dai_ops = {\n\t.probe\t\t= kmb_probe,\n\t.startup\t= kmb_dai_startup,\n\t.trigger\t= kmb_dai_trigger,\n\t.hw_params\t= kmb_dai_hw_params,\n\t.hw_free\t= kmb_dai_hw_free,\n\t.prepare\t= kmb_dai_prepare,\n\t.set_fmt\t= kmb_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver intel_kmb_hdmi_dai[] = {\n\t{\n\t\t.name = \"intel_kmb_hdmi_i2s\",\n\t\t.playback = {\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min = 48000,\n\t\t\t.rate_max = 48000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),\n\t\t},\n\t\t.ops = &kmb_dai_ops,\n\t},\n};\n\nstatic struct snd_soc_dai_driver intel_kmb_i2s_dai[] = {\n\t{\n\t\t.name = \"intel_kmb_i2s\",\n\t\t.playback = {\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_16000 |\n\t\t\t\t SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 48000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S16_LE),\n\t\t},\n\t\t.capture = {\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_16000 |\n\t\t\t\t SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 48000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S16_LE),\n\t\t},\n\t\t.ops = &kmb_dai_ops,\n\t},\n};\n\nstatic struct snd_soc_dai_driver intel_kmb_tdm_dai[] = {\n\t{\n\t\t.name = \"intel_kmb_tdm\",\n\t\t.capture = {\n\t\t\t.channels_min = 4,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_16000 |\n\t\t\t\t SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 48000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S16_LE),\n\t\t},\n\t\t.ops = &kmb_dai_ops,\n\t},\n};\n\nstatic const struct of_device_id kmb_plat_of_match[] = {\n\t{ .compatible = \"intel,keembay-i2s\", .data = &intel_kmb_i2s_dai},\n\t{ .compatible = \"intel,keembay-hdmi-i2s\", .data = &intel_kmb_hdmi_dai},\n\t{ .compatible = \"intel,keembay-tdm\", .data = &intel_kmb_tdm_dai},\n\t{}\n};\n\nstatic int kmb_plat_dai_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct snd_soc_dai_driver *kmb_i2s_dai;\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct kmb_i2s_info *kmb_i2s;\n\tstruct resource *res;\n\tint ret, irq;\n\tu32 comp1_reg;\n\n\tkmb_i2s = devm_kzalloc(dev, sizeof(*kmb_i2s), GFP_KERNEL);\n\tif (!kmb_i2s)\n\t\treturn -ENOMEM;\n\n\tkmb_i2s_dai = devm_kzalloc(dev, sizeof(*kmb_i2s_dai), GFP_KERNEL);\n\tif (!kmb_i2s_dai)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(kmb_plat_of_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tkmb_i2s_dai = (struct snd_soc_dai_driver *) match->data;\n\n\t \n\tkmb_i2s->clk_apb = devm_clk_get(dev, \"apb_clk\");\n\tif (IS_ERR(kmb_i2s->clk_apb)) {\n\t\tdev_err(dev, \"Failed to get apb clock\\n\");\n\t\treturn PTR_ERR(kmb_i2s->clk_apb);\n\t}\n\n\tret = clk_prepare_enable(kmb_i2s->clk_apb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, kmb_disable_clk, kmb_i2s->clk_apb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add clk_apb reset action\\n\");\n\t\treturn ret;\n\t}\n\n\tkmb_i2s->clk_i2s = devm_clk_get(dev, \"osc\");\n\tif (IS_ERR(kmb_i2s->clk_i2s)) {\n\t\tdev_err(dev, \"Failed to get osc clock\\n\");\n\t\treturn PTR_ERR(kmb_i2s->clk_i2s);\n\t}\n\n\tkmb_i2s->i2s_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(kmb_i2s->i2s_base))\n\t\treturn PTR_ERR(kmb_i2s->i2s_base);\n\n\tkmb_i2s->pss_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(kmb_i2s->pss_base))\n\t\treturn PTR_ERR(kmb_i2s->pss_base);\n\n\tkmb_i2s->dev = &pdev->dev;\n\n\tcomp1_reg = readl(kmb_i2s->i2s_base + I2S_COMP_PARAM_1);\n\n\tkmb_i2s->fifo_th = (1 << COMP1_FIFO_DEPTH(comp1_reg)) / 2;\n\n\tkmb_i2s->use_pio = !(of_property_read_bool(np, \"dmas\"));\n\n\tif (kmb_i2s->use_pio) {\n\t\tirq = platform_get_irq_optional(pdev, 0);\n\t\tif (irq > 0) {\n\t\t\tret = devm_request_irq(dev, irq, kmb_i2s_irq_handler, 0,\n\t\t\t\t\t       pdev->name, kmb_i2s);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tret = devm_snd_soc_register_component(dev, &kmb_component,\n\t\t\t\t\t\t      kmb_i2s_dai, 1);\n\t} else {\n\t\tkmb_i2s->play_dma_data.addr = res->start + I2S_TXDMA;\n\t\tkmb_i2s->capture_dma_data.addr = res->start + I2S_RXDMA;\n\t\tret = snd_dmaengine_pcm_register(&pdev->dev,\n\t\t\t\t\t\t NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not register dmaengine: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = devm_snd_soc_register_component(dev, &kmb_component_dma,\n\t\t\t\t\t\t      kmb_i2s_dai, 1);\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"not able to register dai\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tkmb_i2s_disable_channels(kmb_i2s, SNDRV_PCM_STREAM_PLAYBACK);\n\tkmb_i2s_disable_channels(kmb_i2s, SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_set_drvdata(dev, kmb_i2s);\n\n\treturn ret;\n}\n\nstatic struct platform_driver kmb_plat_dai_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"kmb-plat-dai\",\n\t\t.of_match_table = kmb_plat_of_match,\n\t},\n\t.probe\t\t= kmb_plat_dai_probe,\n};\n\nmodule_platform_driver(kmb_plat_dai_driver);\n\nMODULE_DESCRIPTION(\"ASoC Intel KeemBay Platform driver\");\nMODULE_AUTHOR(\"Sia Jee Heng <jee.heng.sia@intel.com>\");\nMODULE_AUTHOR(\"Sit, Michael Wei Hong <michael.wei.hong.sit@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:kmb_platform\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}