{
  "module_name": "skl-messages.c",
  "hash_id": "72c4fd8eef542552b2892ea5cd96166ea1626d57c8c779b73d92489d19ff11ae",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-messages.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <uapi/sound/skl-tplg-interface.h>\n#include \"skl-sst-dsp.h\"\n#include \"cnl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n#include \"skl.h\"\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"skl-topology.h\"\n\nstatic int skl_alloc_dma_buf(struct device *dev,\n\t\tstruct snd_dma_buffer *dmab, size_t size)\n{\n\treturn snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dev, size, dmab);\n}\n\nstatic int skl_free_dma_buf(struct device *dev, struct snd_dma_buffer *dmab)\n{\n\tsnd_dma_free_pages(dmab);\n\treturn 0;\n}\n\n#define SKL_ASTATE_PARAM_ID\t4\n\nvoid skl_dsp_set_astate_cfg(struct skl_dev *skl, u32 cnt, void *data)\n{\n\tstruct skl_ipc_large_config_msg\tmsg = {0};\n\n\tmsg.large_param_id = SKL_ASTATE_PARAM_ID;\n\tmsg.param_data_size = (cnt * sizeof(struct skl_astate_param) +\n\t\t\t\tsizeof(cnt));\n\n\tskl_ipc_set_large_config(&skl->ipc, &msg, data);\n}\n\nstatic int skl_dsp_setup_spib(struct device *dev, unsigned int size,\n\t\t\t\tint stream_tag, int enable)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct hdac_stream *stream = snd_hdac_get_stream(bus,\n\t\t\tSNDRV_PCM_STREAM_PLAYBACK, stream_tag);\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_hdac_stream_spbcap_enable(bus, enable, stream->index);\n\n\t \n\tsnd_hdac_stream_set_spib(bus, stream, size);\n\n\treturn 0;\n}\n\nstatic int skl_dsp_prepare(struct device *dev, unsigned int format,\n\t\t\tunsigned int size, struct snd_dma_buffer *dmab)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct hdac_ext_stream *estream;\n\tstruct hdac_stream *stream;\n\tstruct snd_pcm_substream substream;\n\tint ret;\n\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\tmemset(&substream, 0, sizeof(substream));\n\tsubstream.stream = SNDRV_PCM_STREAM_PLAYBACK;\n\n\testream = snd_hdac_ext_stream_assign(bus, &substream,\n\t\t\t\t\tHDAC_EXT_STREAM_TYPE_HOST);\n\tif (!estream)\n\t\treturn -ENODEV;\n\n\tstream = hdac_stream(estream);\n\n\t \n\tret = snd_hdac_dsp_prepare(stream, format, size, dmab);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tskl_dsp_setup_spib(dev, size, stream->stream_tag, true);\n\n\treturn stream->stream_tag;\n}\n\nstatic int skl_dsp_trigger(struct device *dev, bool start, int stream_tag)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct hdac_stream *stream;\n\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\tstream = snd_hdac_get_stream(bus,\n\t\tSNDRV_PCM_STREAM_PLAYBACK, stream_tag);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tsnd_hdac_dsp_trigger(stream, start);\n\n\treturn 0;\n}\n\nstatic int skl_dsp_cleanup(struct device *dev,\n\t\tstruct snd_dma_buffer *dmab, int stream_tag)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct hdac_stream *stream;\n\tstruct hdac_ext_stream *estream;\n\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\tstream = snd_hdac_get_stream(bus,\n\t\tSNDRV_PCM_STREAM_PLAYBACK, stream_tag);\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\testream = stream_to_hdac_ext_stream(stream);\n\tskl_dsp_setup_spib(dev, 0, stream_tag, false);\n\tsnd_hdac_ext_stream_release(estream, HDAC_EXT_STREAM_TYPE_HOST);\n\n\tsnd_hdac_dsp_cleanup(stream, dmab);\n\n\treturn 0;\n}\n\nstatic struct skl_dsp_loader_ops skl_get_loader_ops(void)\n{\n\tstruct skl_dsp_loader_ops loader_ops;\n\n\tmemset(&loader_ops, 0, sizeof(struct skl_dsp_loader_ops));\n\n\tloader_ops.alloc_dma_buf = skl_alloc_dma_buf;\n\tloader_ops.free_dma_buf = skl_free_dma_buf;\n\n\treturn loader_ops;\n};\n\nstatic struct skl_dsp_loader_ops bxt_get_loader_ops(void)\n{\n\tstruct skl_dsp_loader_ops loader_ops;\n\n\tmemset(&loader_ops, 0, sizeof(loader_ops));\n\n\tloader_ops.alloc_dma_buf = skl_alloc_dma_buf;\n\tloader_ops.free_dma_buf = skl_free_dma_buf;\n\tloader_ops.prepare = skl_dsp_prepare;\n\tloader_ops.trigger = skl_dsp_trigger;\n\tloader_ops.cleanup = skl_dsp_cleanup;\n\n\treturn loader_ops;\n};\n\nstatic const struct skl_dsp_ops dsp_ops[] = {\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_SKL_LP,\n\t\t.num_cores = 2,\n\t\t.loader_ops = skl_get_loader_ops,\n\t\t.init = skl_sst_dsp_init,\n\t\t.init_fw = skl_sst_init_fw,\n\t\t.cleanup = skl_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_KBL_LP,\n\t\t.num_cores = 2,\n\t\t.loader_ops = skl_get_loader_ops,\n\t\t.init = skl_sst_dsp_init,\n\t\t.init_fw = skl_sst_init_fw,\n\t\t.cleanup = skl_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_APL,\n\t\t.num_cores = 2,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = bxt_sst_dsp_init,\n\t\t.init_fw = bxt_sst_init_fw,\n\t\t.cleanup = bxt_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_GML,\n\t\t.num_cores = 2,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = bxt_sst_dsp_init,\n\t\t.init_fw = bxt_sst_init_fw,\n\t\t.cleanup = bxt_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_CNL_LP,\n\t\t.num_cores = 4,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = cnl_sst_dsp_init,\n\t\t.init_fw = cnl_sst_init_fw,\n\t\t.cleanup = cnl_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_CNL_H,\n\t\t.num_cores = 4,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = cnl_sst_dsp_init,\n\t\t.init_fw = cnl_sst_init_fw,\n\t\t.cleanup = cnl_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_CML_LP,\n\t\t.num_cores = 4,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = cnl_sst_dsp_init,\n\t\t.init_fw = cnl_sst_init_fw,\n\t\t.cleanup = cnl_sst_dsp_cleanup\n\t},\n\t{\n\t\t.id = PCI_DEVICE_ID_INTEL_HDA_CML_H,\n\t\t.num_cores = 4,\n\t\t.loader_ops = bxt_get_loader_ops,\n\t\t.init = cnl_sst_dsp_init,\n\t\t.init_fw = cnl_sst_init_fw,\n\t\t.cleanup = cnl_sst_dsp_cleanup\n\t},\n};\n\nconst struct skl_dsp_ops *skl_get_dsp_ops(int pci_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dsp_ops); i++) {\n\t\tif (dsp_ops[i].id == pci_id)\n\t\t\treturn &dsp_ops[i];\n\t}\n\n\treturn NULL;\n}\n\nint skl_init_dsp(struct skl_dev *skl)\n{\n\tvoid __iomem *mmio_base;\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct skl_dsp_loader_ops loader_ops;\n\tint irq = bus->irq;\n\tconst struct skl_dsp_ops *ops;\n\tstruct skl_dsp_cores *cores;\n\tint ret;\n\n\t \n\tsnd_hdac_ext_bus_ppcap_enable(bus, true);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, true);\n\n\t \n\tmmio_base = pci_ioremap_bar(skl->pci, 4);\n\tif (mmio_base == NULL) {\n\t\tdev_err(bus->dev, \"ioremap error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tops = skl_get_dsp_ops(skl->pci->device);\n\tif (!ops) {\n\t\tret = -EIO;\n\t\tgoto unmap_mmio;\n\t}\n\n\tloader_ops = ops->loader_ops();\n\tret = ops->init(bus->dev, mmio_base, irq,\n\t\t\t\tskl->fw_name, loader_ops,\n\t\t\t\t&skl);\n\n\tif (ret < 0)\n\t\tgoto unmap_mmio;\n\n\tskl->dsp_ops = ops;\n\tcores = &skl->cores;\n\tcores->count = ops->num_cores;\n\n\tcores->state = kcalloc(cores->count, sizeof(*cores->state), GFP_KERNEL);\n\tif (!cores->state) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap_mmio;\n\t}\n\n\tcores->usage_count = kcalloc(cores->count, sizeof(*cores->usage_count),\n\t\t\t\t     GFP_KERNEL);\n\tif (!cores->usage_count) {\n\t\tret = -ENOMEM;\n\t\tgoto free_core_state;\n\t}\n\n\tdev_dbg(bus->dev, \"dsp registration status=%d\\n\", ret);\n\n\treturn 0;\n\nfree_core_state:\n\tkfree(cores->state);\n\nunmap_mmio:\n\tiounmap(mmio_base);\n\n\treturn ret;\n}\n\nint skl_free_dsp(struct skl_dev *skl)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\n\t \n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, false);\n\n\tskl->dsp_ops->cleanup(bus->dev, skl);\n\n\tkfree(skl->cores.state);\n\tkfree(skl->cores.usage_count);\n\n\tif (skl->dsp->addr.lpe)\n\t\tiounmap(skl->dsp->addr.lpe);\n\n\treturn 0;\n}\n\n \nint skl_suspend_late_dsp(struct skl_dev *skl)\n{\n\tstruct delayed_work *dwork;\n\n\tif (!skl)\n\t\treturn 0;\n\n\tdwork = &skl->d0i3.work;\n\n\tif (dwork->work.func) {\n\t\tif (skl->supend_active)\n\t\t\tflush_delayed_work(dwork);\n\t\telse\n\t\t\tcancel_delayed_work_sync(dwork);\n\t}\n\n\treturn 0;\n}\n\nint skl_suspend_dsp(struct skl_dev *skl)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tint ret;\n\n\t \n\tif (!bus->ppcap)\n\t\treturn 0;\n\n\tret = skl_dsp_sleep(skl->dsp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, false);\n\tsnd_hdac_ext_bus_ppcap_enable(bus, false);\n\n\treturn 0;\n}\n\nint skl_resume_dsp(struct skl_dev *skl)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tint ret;\n\n\t \n\tif (!bus->ppcap)\n\t\treturn 0;\n\n\t \n\tsnd_hdac_ext_bus_ppcap_enable(bus, true);\n\tsnd_hdac_ext_bus_ppcap_int_enable(bus, true);\n\n\t \n\tif (skl->is_first_boot)\n\t\treturn 0;\n\n\t \n\tskl->enable_miscbdcge(skl->dev, false);\n\tskl->clock_power_gating(skl->dev, false);\n\n\tret = skl_dsp_wake(skl->dsp);\n\tskl->enable_miscbdcge(skl->dev, true);\n\tskl->clock_power_gating(skl->dev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (skl->cfg.astate_cfg != NULL) {\n\t\tskl_dsp_set_astate_cfg(skl, skl->cfg.astate_cfg->count,\n\t\t\t\t\tskl->cfg.astate_cfg);\n\t}\n\treturn ret;\n}\n\nenum skl_bitdepth skl_get_bit_depth(int params)\n{\n\tswitch (params) {\n\tcase 8:\n\t\treturn SKL_DEPTH_8BIT;\n\n\tcase 16:\n\t\treturn SKL_DEPTH_16BIT;\n\n\tcase 24:\n\t\treturn SKL_DEPTH_24BIT;\n\n\tcase 32:\n\t\treturn SKL_DEPTH_32BIT;\n\n\tdefault:\n\t\treturn SKL_DEPTH_INVALID;\n\n\t}\n}\n\n \nstatic void skl_set_base_module_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_base_cfg *base_cfg)\n{\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_res *res = &module->resources[mconfig->res_idx];\n\tstruct skl_module_iface *fmt = &module->formats[mconfig->fmt_idx];\n\tstruct skl_module_fmt *format = &fmt->inputs[0].fmt;\n\n\tbase_cfg->audio_fmt.number_of_channels = format->channels;\n\n\tbase_cfg->audio_fmt.s_freq = format->s_freq;\n\tbase_cfg->audio_fmt.bit_depth = format->bit_depth;\n\tbase_cfg->audio_fmt.valid_bit_depth = format->valid_bit_depth;\n\tbase_cfg->audio_fmt.ch_cfg = format->ch_cfg;\n\tbase_cfg->audio_fmt.sample_type = format->sample_type;\n\n\tdev_dbg(skl->dev, \"bit_depth=%x valid_bd=%x ch_config=%x\\n\",\n\t\t\tformat->bit_depth, format->valid_bit_depth,\n\t\t\tformat->ch_cfg);\n\n\tbase_cfg->audio_fmt.channel_map = format->ch_map;\n\n\tbase_cfg->audio_fmt.interleaving = format->interleaving_style;\n\n\tbase_cfg->cpc = res->cpc;\n\tbase_cfg->ibs = res->ibs;\n\tbase_cfg->obs = res->obs;\n\tbase_cfg->is_pages = res->is_pages;\n}\n\nstatic void fill_pin_params(struct skl_audio_data_format *pin_fmt,\n\t\t\t    struct skl_module_fmt *format)\n{\n\tpin_fmt->number_of_channels = format->channels;\n\tpin_fmt->s_freq = format->s_freq;\n\tpin_fmt->bit_depth = format->bit_depth;\n\tpin_fmt->valid_bit_depth = format->valid_bit_depth;\n\tpin_fmt->ch_cfg = format->ch_cfg;\n\tpin_fmt->sample_type = format->sample_type;\n\tpin_fmt->channel_map = format->ch_map;\n\tpin_fmt->interleaving = format->interleaving_style;\n}\n\n \nstatic void skl_set_base_ext_module_format(struct skl_dev *skl,\n\t\t\t\t\t   struct skl_module_cfg *mconfig,\n\t\t\t\t\t   struct skl_base_cfg_ext *base_cfg_ext)\n{\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_pin_resources *pin_res;\n\tstruct skl_module_iface *fmt = &module->formats[mconfig->fmt_idx];\n\tstruct skl_module_res *res = &module->resources[mconfig->res_idx];\n\tstruct skl_module_fmt *format;\n\tstruct skl_pin_format *pin_fmt;\n\tchar *params;\n\tint i;\n\n\tbase_cfg_ext->nr_input_pins = res->nr_input_pins;\n\tbase_cfg_ext->nr_output_pins = res->nr_output_pins;\n\tbase_cfg_ext->priv_param_length =\n\t\tmconfig->formats_config[SKL_PARAM_INIT].caps_size;\n\n\tfor (i = 0; i < res->nr_input_pins; i++) {\n\t\tpin_res = &res->input[i];\n\t\tpin_fmt = &base_cfg_ext->pins_fmt[i];\n\n\t\tpin_fmt->pin_idx = pin_res->pin_index;\n\t\tpin_fmt->buf_size = pin_res->buf_size;\n\n\t\tformat = &fmt->inputs[pin_res->pin_index].fmt;\n\t\tfill_pin_params(&pin_fmt->audio_fmt, format);\n\t}\n\n\tfor (i = 0; i < res->nr_output_pins; i++) {\n\t\tpin_res = &res->output[i];\n\t\tpin_fmt = &base_cfg_ext->pins_fmt[res->nr_input_pins + i];\n\n\t\tpin_fmt->pin_idx = pin_res->pin_index;\n\t\tpin_fmt->buf_size = pin_res->buf_size;\n\n\t\tformat = &fmt->outputs[pin_res->pin_index].fmt;\n\t\tfill_pin_params(&pin_fmt->audio_fmt, format);\n\t}\n\n\tif (!base_cfg_ext->priv_param_length)\n\t\treturn;\n\n\tparams = (char *)base_cfg_ext + sizeof(struct skl_base_cfg_ext);\n\tparams += (base_cfg_ext->nr_input_pins + base_cfg_ext->nr_output_pins) *\n\t\t  sizeof(struct skl_pin_format);\n\n\tmemcpy(params, mconfig->formats_config[SKL_PARAM_INIT].caps,\n\t       mconfig->formats_config[SKL_PARAM_INIT].caps_size);\n}\n\n \nstatic void skl_copy_copier_caps(struct skl_module_cfg *mconfig,\n\t\t\t\tstruct skl_cpr_cfg *cpr_mconfig)\n{\n\tif (mconfig->formats_config[SKL_PARAM_INIT].caps_size == 0)\n\t\treturn;\n\n\tmemcpy(&cpr_mconfig->gtw_cfg.config_data,\n\t\t\tmconfig->formats_config[SKL_PARAM_INIT].caps,\n\t\t\tmconfig->formats_config[SKL_PARAM_INIT].caps_size);\n\n\tcpr_mconfig->gtw_cfg.config_length =\n\t\t\t(mconfig->formats_config[SKL_PARAM_INIT].caps_size) / 4;\n}\n\n#define SKL_NON_GATEWAY_CPR_NODE_ID 0xFFFFFFFF\n \nstatic u32 skl_get_node_id(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig)\n{\n\tunion skl_connector_node_id node_id = {0};\n\tunion skl_ssp_dma_node ssp_node  = {0};\n\tstruct skl_pipe_params *params = mconfig->pipe->p_params;\n\n\tswitch (mconfig->dev_type) {\n\tcase SKL_DEVICE_BT:\n\t\tnode_id.node.dma_type =\n\t\t\t(SKL_CONN_SOURCE == mconfig->hw_conn_type) ?\n\t\t\tSKL_DMA_I2S_LINK_OUTPUT_CLASS :\n\t\t\tSKL_DMA_I2S_LINK_INPUT_CLASS;\n\t\tnode_id.node.vindex = params->host_dma_id +\n\t\t\t\t\t(mconfig->vbus_id << 3);\n\t\tbreak;\n\n\tcase SKL_DEVICE_I2S:\n\t\tnode_id.node.dma_type =\n\t\t\t(SKL_CONN_SOURCE == mconfig->hw_conn_type) ?\n\t\t\tSKL_DMA_I2S_LINK_OUTPUT_CLASS :\n\t\t\tSKL_DMA_I2S_LINK_INPUT_CLASS;\n\t\tssp_node.dma_node.time_slot_index = mconfig->time_slot;\n\t\tssp_node.dma_node.i2s_instance = mconfig->vbus_id;\n\t\tnode_id.node.vindex = ssp_node.val;\n\t\tbreak;\n\n\tcase SKL_DEVICE_DMIC:\n\t\tnode_id.node.dma_type = SKL_DMA_DMIC_LINK_INPUT_CLASS;\n\t\tnode_id.node.vindex = mconfig->vbus_id +\n\t\t\t\t\t (mconfig->time_slot);\n\t\tbreak;\n\n\tcase SKL_DEVICE_HDALINK:\n\t\tnode_id.node.dma_type =\n\t\t\t(SKL_CONN_SOURCE == mconfig->hw_conn_type) ?\n\t\t\tSKL_DMA_HDA_LINK_OUTPUT_CLASS :\n\t\t\tSKL_DMA_HDA_LINK_INPUT_CLASS;\n\t\tnode_id.node.vindex = params->link_dma_id;\n\t\tbreak;\n\n\tcase SKL_DEVICE_HDAHOST:\n\t\tnode_id.node.dma_type =\n\t\t\t(SKL_CONN_SOURCE == mconfig->hw_conn_type) ?\n\t\t\tSKL_DMA_HDA_HOST_OUTPUT_CLASS :\n\t\t\tSKL_DMA_HDA_HOST_INPUT_CLASS;\n\t\tnode_id.node.vindex = params->host_dma_id;\n\t\tbreak;\n\n\tdefault:\n\t\tnode_id.val = 0xFFFFFFFF;\n\t\tbreak;\n\t}\n\n\treturn node_id.val;\n}\n\nstatic void skl_setup_cpr_gateway_cfg(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_cpr_cfg *cpr_mconfig)\n{\n\tu32 dma_io_buf;\n\tstruct skl_module_res *res;\n\tint res_idx = mconfig->res_idx;\n\n\tcpr_mconfig->gtw_cfg.node_id = skl_get_node_id(skl, mconfig);\n\n\tif (cpr_mconfig->gtw_cfg.node_id == SKL_NON_GATEWAY_CPR_NODE_ID) {\n\t\tcpr_mconfig->cpr_feature_mask = 0;\n\t\treturn;\n\t}\n\n\tif (skl->nr_modules) {\n\t\tres = &mconfig->module->resources[mconfig->res_idx];\n\t\tcpr_mconfig->gtw_cfg.dma_buffer_size = res->dma_buffer_size;\n\t\tgoto skip_buf_size_calc;\n\t} else {\n\t\tres = &mconfig->module->resources[res_idx];\n\t}\n\n\tswitch (mconfig->hw_conn_type) {\n\tcase SKL_CONN_SOURCE:\n\t\tif (mconfig->dev_type == SKL_DEVICE_HDAHOST)\n\t\t\tdma_io_buf =  res->ibs;\n\t\telse\n\t\t\tdma_io_buf =  res->obs;\n\t\tbreak;\n\n\tcase SKL_CONN_SINK:\n\t\tif (mconfig->dev_type == SKL_DEVICE_HDAHOST)\n\t\t\tdma_io_buf =  res->obs;\n\t\telse\n\t\t\tdma_io_buf =  res->ibs;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(skl->dev, \"wrong connection type: %d\\n\",\n\t\t\t\tmconfig->hw_conn_type);\n\t\treturn;\n\t}\n\n\tcpr_mconfig->gtw_cfg.dma_buffer_size =\n\t\t\t\tmconfig->dma_buffer_size * dma_io_buf;\n\n\t \n\tif (!cpr_mconfig->gtw_cfg.dma_buffer_size) {\n\t\tif (mconfig->hw_conn_type == SKL_CONN_SOURCE)\n\t\t\tcpr_mconfig->gtw_cfg.dma_buffer_size = 2 * res->obs;\n\t\telse\n\t\t\tcpr_mconfig->gtw_cfg.dma_buffer_size = 2 * res->ibs;\n\t}\n\nskip_buf_size_calc:\n\tcpr_mconfig->cpr_feature_mask = 0;\n\tcpr_mconfig->gtw_cfg.config_length  = 0;\n\n\tskl_copy_copier_caps(mconfig, cpr_mconfig);\n}\n\n#define DMA_CONTROL_ID 5\n#define DMA_I2S_BLOB_SIZE 21\n\nint skl_dsp_set_dma_control(struct skl_dev *skl, u32 *caps,\n\t\t\t\tu32 caps_size, u32 node_id)\n{\n\tstruct skl_dma_control *dma_ctrl;\n\tstruct skl_ipc_large_config_msg msg = {0};\n\tint err = 0;\n\n\n\t \n\tif (caps_size == 0)\n\t\treturn 0;\n\n\tmsg.large_param_id = DMA_CONTROL_ID;\n\tmsg.param_data_size = sizeof(struct skl_dma_control) + caps_size;\n\n\tdma_ctrl = kzalloc(msg.param_data_size, GFP_KERNEL);\n\tif (dma_ctrl == NULL)\n\t\treturn -ENOMEM;\n\n\tdma_ctrl->node_id = node_id;\n\n\t \n\tdma_ctrl->config_length = DMA_I2S_BLOB_SIZE;\n\n\tmemcpy(dma_ctrl->config_data, caps, caps_size);\n\n\terr = skl_ipc_set_large_config(&skl->ipc, &msg, (u32 *)dma_ctrl);\n\n\tkfree(dma_ctrl);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(skl_dsp_set_dma_control);\n\nstatic void skl_setup_out_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_audio_data_format *out_fmt)\n{\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_iface *fmt = &module->formats[mconfig->fmt_idx];\n\tstruct skl_module_fmt *format = &fmt->outputs[0].fmt;\n\n\tout_fmt->number_of_channels = (u8)format->channels;\n\tout_fmt->s_freq = format->s_freq;\n\tout_fmt->bit_depth = format->bit_depth;\n\tout_fmt->valid_bit_depth = format->valid_bit_depth;\n\tout_fmt->ch_cfg = format->ch_cfg;\n\n\tout_fmt->channel_map = format->ch_map;\n\tout_fmt->interleaving = format->interleaving_style;\n\tout_fmt->sample_type = format->sample_type;\n\n\tdev_dbg(skl->dev, \"copier out format chan=%d fre=%d bitdepth=%d\\n\",\n\t\tout_fmt->number_of_channels, format->s_freq, format->bit_depth);\n}\n\n \nstatic void skl_set_src_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_src_module_cfg *src_mconfig)\n{\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_iface *iface = &module->formats[mconfig->fmt_idx];\n\tstruct skl_module_fmt *fmt = &iface->outputs[0].fmt;\n\n\tskl_set_base_module_format(skl, mconfig,\n\t\t(struct skl_base_cfg *)src_mconfig);\n\n\tsrc_mconfig->src_cfg = fmt->s_freq;\n}\n\n \nstatic void skl_set_updown_mixer_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_up_down_mixer_cfg *mixer_mconfig)\n{\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_iface *iface = &module->formats[mconfig->fmt_idx];\n\tstruct skl_module_fmt *fmt = &iface->outputs[0].fmt;\n\n\tskl_set_base_module_format(skl,\tmconfig,\n\t\t(struct skl_base_cfg *)mixer_mconfig);\n\tmixer_mconfig->out_ch_cfg = fmt->ch_cfg;\n\tmixer_mconfig->ch_map = fmt->ch_map;\n}\n\n \nstatic void skl_set_copier_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_cpr_cfg *cpr_mconfig)\n{\n\tstruct skl_audio_data_format *out_fmt = &cpr_mconfig->out_fmt;\n\tstruct skl_base_cfg *base_cfg = (struct skl_base_cfg *)cpr_mconfig;\n\n\tskl_set_base_module_format(skl, mconfig, base_cfg);\n\n\tskl_setup_out_format(skl, mconfig, out_fmt);\n\tskl_setup_cpr_gateway_cfg(skl, mconfig, cpr_mconfig);\n}\n\n \nstatic void skl_set_base_outfmt_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_base_outfmt_cfg *base_outfmt_mcfg)\n{\n\tstruct skl_audio_data_format *out_fmt = &base_outfmt_mcfg->out_fmt;\n\tstruct skl_base_cfg *base_cfg =\n\t\t\t\t(struct skl_base_cfg *)base_outfmt_mcfg;\n\n\tskl_set_base_module_format(skl, mconfig, base_cfg);\n\tskl_setup_out_format(skl, mconfig, out_fmt);\n}\n\nstatic u16 skl_get_module_param_size(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig)\n{\n\tstruct skl_module_res *res;\n\tstruct skl_module *module = mconfig->module;\n\tu16 param_size;\n\n\tswitch (mconfig->m_type) {\n\tcase SKL_MODULE_TYPE_COPIER:\n\t\tparam_size = sizeof(struct skl_cpr_cfg);\n\t\tparam_size += mconfig->formats_config[SKL_PARAM_INIT].caps_size;\n\t\treturn param_size;\n\n\tcase SKL_MODULE_TYPE_SRCINT:\n\t\treturn sizeof(struct skl_src_module_cfg);\n\n\tcase SKL_MODULE_TYPE_UPDWMIX:\n\t\treturn sizeof(struct skl_up_down_mixer_cfg);\n\n\tcase SKL_MODULE_TYPE_BASE_OUTFMT:\n\tcase SKL_MODULE_TYPE_MIC_SELECT:\n\t\treturn sizeof(struct skl_base_outfmt_cfg);\n\n\tcase SKL_MODULE_TYPE_MIXER:\n\tcase SKL_MODULE_TYPE_KPB:\n\t\treturn sizeof(struct skl_base_cfg);\n\n\tcase SKL_MODULE_TYPE_ALGO:\n\tdefault:\n\t\tres = &module->resources[mconfig->res_idx];\n\n\t\tparam_size = sizeof(struct skl_base_cfg) + sizeof(struct skl_base_cfg_ext);\n\t\tparam_size += (res->nr_input_pins + res->nr_output_pins) *\n\t\t\t      sizeof(struct skl_pin_format);\n\t\tparam_size += mconfig->formats_config[SKL_PARAM_INIT].caps_size;\n\n\t\treturn param_size;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int skl_set_module_format(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *module_config,\n\t\t\tu16 *module_config_size,\n\t\t\tvoid **param_data)\n{\n\tu16 param_size;\n\n\tparam_size  = skl_get_module_param_size(skl, module_config);\n\n\t*param_data = kzalloc(param_size, GFP_KERNEL);\n\tif (NULL == *param_data)\n\t\treturn -ENOMEM;\n\n\t*module_config_size = param_size;\n\n\tswitch (module_config->m_type) {\n\tcase SKL_MODULE_TYPE_COPIER:\n\t\tskl_set_copier_format(skl, module_config, *param_data);\n\t\tbreak;\n\n\tcase SKL_MODULE_TYPE_SRCINT:\n\t\tskl_set_src_format(skl, module_config, *param_data);\n\t\tbreak;\n\n\tcase SKL_MODULE_TYPE_UPDWMIX:\n\t\tskl_set_updown_mixer_format(skl, module_config, *param_data);\n\t\tbreak;\n\n\tcase SKL_MODULE_TYPE_BASE_OUTFMT:\n\tcase SKL_MODULE_TYPE_MIC_SELECT:\n\t\tskl_set_base_outfmt_format(skl, module_config, *param_data);\n\t\tbreak;\n\n\tcase SKL_MODULE_TYPE_MIXER:\n\tcase SKL_MODULE_TYPE_KPB:\n\t\tskl_set_base_module_format(skl, module_config, *param_data);\n\t\tbreak;\n\n\tcase SKL_MODULE_TYPE_ALGO:\n\tdefault:\n\t\tskl_set_base_module_format(skl, module_config, *param_data);\n\t\tskl_set_base_ext_module_format(skl, module_config,\n\t\t\t\t\t       *param_data +\n\t\t\t\t\t       sizeof(struct skl_base_cfg));\n\t\tbreak;\n\t}\n\n\tdev_dbg(skl->dev, \"Module type=%d id=%d config size: %d bytes\\n\",\n\t\t\tmodule_config->m_type, module_config->id.module_id,\n\t\t\tparam_size);\n\tprint_hex_dump_debug(\"Module params:\", DUMP_PREFIX_OFFSET, 8, 4,\n\t\t\t*param_data, param_size, false);\n\treturn 0;\n}\n\nstatic int skl_get_queue_index(struct skl_module_pin *mpin,\n\t\t\t\tstruct skl_module_inst_id id, int max)\n{\n\tint i;\n\n\tfor (i = 0; i < max; i++)  {\n\t\tif (mpin[i].id.module_id == id.module_id &&\n\t\t\tmpin[i].id.instance_id == id.instance_id)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int skl_alloc_queue(struct skl_module_pin *mpin,\n\t\t\tstruct skl_module_cfg *tgt_cfg, int max)\n{\n\tint i;\n\tstruct skl_module_inst_id id = tgt_cfg->id;\n\t \n\tfor (i = 0; i < max; i++)  {\n\t\tif (mpin[i].is_dynamic) {\n\t\t\tif (!mpin[i].in_use &&\n\t\t\t\tmpin[i].pin_state == SKL_PIN_UNBIND) {\n\n\t\t\t\tmpin[i].in_use = true;\n\t\t\t\tmpin[i].id.module_id = id.module_id;\n\t\t\t\tmpin[i].id.instance_id = id.instance_id;\n\t\t\t\tmpin[i].id.pvt_id = id.pvt_id;\n\t\t\t\tmpin[i].tgt_mcfg = tgt_cfg;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mpin[i].id.module_id == id.module_id &&\n\t\t\t\tmpin[i].id.instance_id == id.instance_id &&\n\t\t\t\tmpin[i].pin_state == SKL_PIN_UNBIND) {\n\n\t\t\t\tmpin[i].tgt_mcfg = tgt_cfg;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void skl_free_queue(struct skl_module_pin *mpin, int q_index)\n{\n\tif (mpin[q_index].is_dynamic) {\n\t\tmpin[q_index].in_use = false;\n\t\tmpin[q_index].id.module_id = 0;\n\t\tmpin[q_index].id.instance_id = 0;\n\t\tmpin[q_index].id.pvt_id = 0;\n\t}\n\tmpin[q_index].pin_state = SKL_PIN_UNBIND;\n\tmpin[q_index].tgt_mcfg = NULL;\n}\n\n \n\nstatic void skl_clear_module_state(struct skl_module_pin *mpin, int max,\n\t\t\t\t\t\tstruct skl_module_cfg *mcfg)\n{\n\tint i;\n\tbool found = false;\n\n\tfor (i = 0; i < max; i++)  {\n\t\tif (mpin[i].pin_state == SKL_PIN_UNBIND)\n\t\t\tcontinue;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tmcfg->m_state = SKL_MODULE_INIT_DONE;\n\treturn;\n}\n\n \nint skl_init_module(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *mconfig)\n{\n\tu16 module_config_size = 0;\n\tvoid *param_data = NULL;\n\tint ret;\n\tstruct skl_ipc_init_instance_msg msg;\n\n\tdev_dbg(skl->dev, \"%s: module_id = %d instance=%d\\n\", __func__,\n\t\t mconfig->id.module_id, mconfig->id.pvt_id);\n\n\tif (mconfig->pipe->state != SKL_PIPE_CREATED) {\n\t\tdev_err(skl->dev, \"Pipe not created state= %d pipe_id= %d\\n\",\n\t\t\t\t mconfig->pipe->state, mconfig->pipe->ppl_id);\n\t\treturn -EIO;\n\t}\n\n\tret = skl_set_module_format(skl, mconfig,\n\t\t\t&module_config_size, &param_data);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to set module format ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsg.module_id = mconfig->id.module_id;\n\tmsg.instance_id = mconfig->id.pvt_id;\n\tmsg.ppl_instance_id = mconfig->pipe->ppl_id;\n\tmsg.param_data_size = module_config_size;\n\tmsg.core_id = mconfig->core_id;\n\tmsg.domain = mconfig->domain;\n\n\tret = skl_ipc_init_instance(&skl->ipc, &msg, param_data);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to init instance ret=%d\\n\", ret);\n\t\tkfree(param_data);\n\t\treturn ret;\n\t}\n\tmconfig->m_state = SKL_MODULE_INIT_DONE;\n\tkfree(param_data);\n\treturn ret;\n}\n\nstatic void skl_dump_bind_info(struct skl_dev *skl, struct skl_module_cfg\n\t*src_module, struct skl_module_cfg *dst_module)\n{\n\tdev_dbg(skl->dev, \"%s: src module_id = %d  src_instance=%d\\n\",\n\t\t__func__, src_module->id.module_id, src_module->id.pvt_id);\n\tdev_dbg(skl->dev, \"%s: dst_module=%d dst_instance=%d\\n\", __func__,\n\t\t dst_module->id.module_id, dst_module->id.pvt_id);\n\n\tdev_dbg(skl->dev, \"src_module state = %d dst module state = %d\\n\",\n\t\tsrc_module->m_state, dst_module->m_state);\n}\n\n \nint skl_unbind_modules(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *src_mcfg,\n\t\t\tstruct skl_module_cfg *dst_mcfg)\n{\n\tint ret;\n\tstruct skl_ipc_bind_unbind_msg msg;\n\tstruct skl_module_inst_id src_id = src_mcfg->id;\n\tstruct skl_module_inst_id dst_id = dst_mcfg->id;\n\tint in_max = dst_mcfg->module->max_input_pins;\n\tint out_max = src_mcfg->module->max_output_pins;\n\tint src_index, dst_index, src_pin_state, dst_pin_state;\n\n\tskl_dump_bind_info(skl, src_mcfg, dst_mcfg);\n\n\t \n\tsrc_index = skl_get_queue_index(src_mcfg->m_out_pin, dst_id, out_max);\n\tif (src_index < 0)\n\t\treturn 0;\n\n\tmsg.src_queue = src_index;\n\n\t \n\tdst_index  = skl_get_queue_index(dst_mcfg->m_in_pin, src_id, in_max);\n\tif (dst_index < 0)\n\t\treturn 0;\n\n\tmsg.dst_queue = dst_index;\n\n\tsrc_pin_state = src_mcfg->m_out_pin[src_index].pin_state;\n\tdst_pin_state = dst_mcfg->m_in_pin[dst_index].pin_state;\n\n\tif (src_pin_state != SKL_PIN_BIND_DONE ||\n\t\tdst_pin_state != SKL_PIN_BIND_DONE)\n\t\treturn 0;\n\n\tmsg.module_id = src_mcfg->id.module_id;\n\tmsg.instance_id = src_mcfg->id.pvt_id;\n\tmsg.dst_module_id = dst_mcfg->id.module_id;\n\tmsg.dst_instance_id = dst_mcfg->id.pvt_id;\n\tmsg.bind = false;\n\n\tret = skl_ipc_bind_unbind(&skl->ipc, &msg);\n\tif (!ret) {\n\t\t \n\t\tskl_free_queue(src_mcfg->m_out_pin, src_index);\n\t\tskl_free_queue(dst_mcfg->m_in_pin, dst_index);\n\n\t\t \n\t\tskl_clear_module_state(src_mcfg->m_out_pin, out_max, src_mcfg);\n\t}\n\n\treturn ret;\n}\n\n#define CPR_SINK_FMT_PARAM_ID 2\n\n \nint skl_bind_modules(struct skl_dev *skl,\n\t\t\tstruct skl_module_cfg *src_mcfg,\n\t\t\tstruct skl_module_cfg *dst_mcfg)\n{\n\tint ret = 0;\n\tstruct skl_ipc_bind_unbind_msg msg;\n\tint in_max = dst_mcfg->module->max_input_pins;\n\tint out_max = src_mcfg->module->max_output_pins;\n\tint src_index, dst_index;\n\tstruct skl_module_fmt *format;\n\tstruct skl_cpr_pin_fmt pin_fmt;\n\tstruct skl_module *module;\n\tstruct skl_module_iface *fmt;\n\n\tskl_dump_bind_info(skl, src_mcfg, dst_mcfg);\n\n\tif (src_mcfg->m_state < SKL_MODULE_INIT_DONE ||\n\t\tdst_mcfg->m_state < SKL_MODULE_INIT_DONE)\n\t\treturn 0;\n\n\tsrc_index = skl_alloc_queue(src_mcfg->m_out_pin, dst_mcfg, out_max);\n\tif (src_index < 0)\n\t\treturn -EINVAL;\n\n\tmsg.src_queue = src_index;\n\tdst_index = skl_alloc_queue(dst_mcfg->m_in_pin, src_mcfg, in_max);\n\tif (dst_index < 0) {\n\t\tskl_free_queue(src_mcfg->m_out_pin, src_index);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (src_mcfg->m_type == SKL_MODULE_TYPE_COPIER && src_index > 0) {\n\t\tpin_fmt.sink_id = src_index;\n\t\tmodule = src_mcfg->module;\n\t\tfmt = &module->formats[src_mcfg->fmt_idx];\n\n\t\t \n\t\tformat = &fmt->inputs[0].fmt;\n\t\tfill_pin_params(&(pin_fmt.src_fmt), format);\n\n\t\tformat = &fmt->outputs[src_index].fmt;\n\t\tfill_pin_params(&(pin_fmt.dst_fmt), format);\n\t\tret = skl_set_module_params(skl, (void *)&pin_fmt,\n\t\t\t\t\tsizeof(struct skl_cpr_pin_fmt),\n\t\t\t\t\tCPR_SINK_FMT_PARAM_ID, src_mcfg);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tmsg.dst_queue = dst_index;\n\n\tdev_dbg(skl->dev, \"src queue = %d dst queue =%d\\n\",\n\t\t\t msg.src_queue, msg.dst_queue);\n\n\tmsg.module_id = src_mcfg->id.module_id;\n\tmsg.instance_id = src_mcfg->id.pvt_id;\n\tmsg.dst_module_id = dst_mcfg->id.module_id;\n\tmsg.dst_instance_id = dst_mcfg->id.pvt_id;\n\tmsg.bind = true;\n\n\tret = skl_ipc_bind_unbind(&skl->ipc, &msg);\n\n\tif (!ret) {\n\t\tsrc_mcfg->m_state = SKL_MODULE_BIND_DONE;\n\t\tsrc_mcfg->m_out_pin[src_index].pin_state = SKL_PIN_BIND_DONE;\n\t\tdst_mcfg->m_in_pin[dst_index].pin_state = SKL_PIN_BIND_DONE;\n\t\treturn ret;\n\t}\nout:\n\t \n\tskl_free_queue(src_mcfg->m_out_pin, src_index);\n\tskl_free_queue(dst_mcfg->m_in_pin, dst_index);\n\n\treturn ret;\n}\n\nstatic int skl_set_pipe_state(struct skl_dev *skl, struct skl_pipe *pipe,\n\tenum skl_ipc_pipeline_state state)\n{\n\tdev_dbg(skl->dev, \"%s: pipe_state = %d\\n\", __func__, state);\n\n\treturn skl_ipc_set_pipeline_state(&skl->ipc, pipe->ppl_id, state);\n}\n\n \nint skl_create_pipeline(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tint ret;\n\n\tdev_dbg(skl->dev, \"%s: pipe_id = %d\\n\", __func__, pipe->ppl_id);\n\n\tret = skl_ipc_create_pipeline(&skl->ipc, pipe->memory_pages,\n\t\t\t\tpipe->pipe_priority, pipe->ppl_id,\n\t\t\t\tpipe->lp_mode);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to create pipeline\\n\");\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_CREATED;\n\n\treturn 0;\n}\n\n \nint skl_delete_pipe(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tint ret;\n\n\tdev_dbg(skl->dev, \"%s: pipe = %d\\n\", __func__, pipe->ppl_id);\n\n\t \n\tif (pipe->state < SKL_PIPE_CREATED)\n\t\treturn 0;\n\n\t \n\tif (pipe->state >= SKL_PIPE_STARTED) {\n\t\tret = skl_set_pipe_state(skl, pipe, PPL_PAUSED);\n\t\tif (ret < 0) {\n\t\t\tdev_err(skl->dev, \"Failed to stop pipeline\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tpipe->state = SKL_PIPE_PAUSED;\n\t}\n\n\t \n\tret = skl_set_pipe_state(skl, pipe, PPL_RESET);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to reset pipe ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_RESET;\n\n\tret = skl_ipc_delete_pipeline(&skl->ipc, pipe->ppl_id);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to delete pipeline\\n\");\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_INVALID;\n\n\treturn ret;\n}\n\n \nint skl_run_pipe(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tint ret;\n\n\tdev_dbg(skl->dev, \"%s: pipe = %d\\n\", __func__, pipe->ppl_id);\n\n\t \n\tif (pipe->state < SKL_PIPE_CREATED)\n\t\treturn 0;\n\n\t \n\tret = skl_set_pipe_state(skl, pipe, PPL_PAUSED);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to pause pipe\\n\");\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_PAUSED;\n\n\tret = skl_set_pipe_state(skl, pipe, PPL_RUNNING);\n\tif (ret < 0) {\n\t\tdev_err(skl->dev, \"Failed to start pipe\\n\");\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_STARTED;\n\n\treturn 0;\n}\n\n \nint skl_stop_pipe(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tint ret;\n\n\tdev_dbg(skl->dev, \"In %s pipe=%d\\n\", __func__, pipe->ppl_id);\n\n\t \n\tif (pipe->state < SKL_PIPE_PAUSED)\n\t\treturn 0;\n\n\tret = skl_set_pipe_state(skl, pipe, PPL_PAUSED);\n\tif (ret < 0) {\n\t\tdev_dbg(skl->dev, \"Failed to stop pipe\\n\");\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_PAUSED;\n\n\treturn 0;\n}\n\n \nint skl_reset_pipe(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tint ret;\n\n\t \n\tif (pipe->state < SKL_PIPE_PAUSED)\n\t\treturn 0;\n\n\tret = skl_set_pipe_state(skl, pipe, PPL_RESET);\n\tif (ret < 0) {\n\t\tdev_dbg(skl->dev, \"Failed to reset pipe ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpipe->state = SKL_PIPE_RESET;\n\n\treturn 0;\n}\n\n \nint skl_set_module_params(struct skl_dev *skl, u32 *params, int size,\n\t\t\t\tu32 param_id, struct skl_module_cfg *mcfg)\n{\n\tstruct skl_ipc_large_config_msg msg;\n\n\tmsg.module_id = mcfg->id.module_id;\n\tmsg.instance_id = mcfg->id.pvt_id;\n\tmsg.param_data_size = size;\n\tmsg.large_param_id = param_id;\n\n\treturn skl_ipc_set_large_config(&skl->ipc, &msg, params);\n}\n\nint skl_get_module_params(struct skl_dev *skl, u32 *params, int size,\n\t\t\t  u32 param_id, struct skl_module_cfg *mcfg)\n{\n\tstruct skl_ipc_large_config_msg msg;\n\tsize_t bytes = size;\n\n\tmsg.module_id = mcfg->id.module_id;\n\tmsg.instance_id = mcfg->id.pvt_id;\n\tmsg.param_data_size = size;\n\tmsg.large_param_id = param_id;\n\n\treturn skl_ipc_get_large_config(&skl->ipc, &msg, &params, &bytes);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}