{
  "module_name": "skl-sst.c",
  "hash_id": "2caa5b8f2c5dfa8d94984dded4619cfa511b4844e07f14720cfe2c244bfd89d4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-sst.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/uuid.h>\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"../common/sst-ipc.h\"\n#include \"skl.h\"\n\n#define SKL_BASEFW_TIMEOUT\t300\n#define SKL_INIT_TIMEOUT\t1000\n\n \n#define SKL_ADSP_SRAM0_BASE\t0x8000\n\n \n#define SKL_ADSP_FW_STATUS\tSKL_ADSP_SRAM0_BASE\n#define SKL_ADSP_ERROR_CODE\t(SKL_ADSP_FW_STATUS + 0x4)\n\n#define SKL_NUM_MODULES\t\t1\n\nstatic bool skl_check_fw_status(struct sst_dsp *ctx, u32 status)\n{\n\tu32 cur_sts;\n\n\tcur_sts = sst_dsp_shim_read(ctx, SKL_ADSP_FW_STATUS) & SKL_FW_STS_MASK;\n\n\treturn (cur_sts == status);\n}\n\nstatic int skl_transfer_firmware(struct sst_dsp *ctx,\n\t\tconst void *basefw, u32 base_fw_size)\n{\n\tint ret = 0;\n\n\tret = ctx->cl_dev.ops.cl_copy_to_dmabuf(ctx, basefw, base_fw_size,\n\t\t\t\t\t\t\t\ttrue);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sst_dsp_register_poll(ctx,\n\t\t\tSKL_ADSP_FW_STATUS,\n\t\t\tSKL_FW_STS_MASK,\n\t\t\tSKL_FW_RFW_START,\n\t\t\tSKL_BASEFW_TIMEOUT,\n\t\t\t\"Firmware boot\");\n\n\tctx->cl_dev.ops.cl_stop_dma(ctx);\n\n\treturn ret;\n}\n\n#define SKL_ADSP_FW_BIN_HDR_OFFSET 0x284\n\nstatic int skl_load_base_firmware(struct sst_dsp *ctx)\n{\n\tint ret = 0, i;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct firmware stripped_fw;\n\tu32 reg;\n\n\tskl->boot_complete = false;\n\tinit_waitqueue_head(&skl->boot_wait);\n\n\tif (ctx->fw == NULL) {\n\t\tret = request_firmware(&ctx->fw, ctx->fw_name, ctx->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"Request firmware failed %d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tif (skl->is_first_boot) {\n\t\tret = snd_skl_parse_uuids(ctx, ctx->fw, SKL_ADSP_FW_BIN_HDR_OFFSET, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"UUID parsing err: %d\\n\", ret);\n\t\t\trelease_firmware(ctx->fw);\n\t\t\tskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tstripped_fw.data = ctx->fw->data;\n\tstripped_fw.size = ctx->fw->size;\n\n\tskl_dsp_strip_extended_manifest(&stripped_fw);\n\n\tret = skl_dsp_boot(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Boot dsp core failed ret: %d\\n\", ret);\n\t\tgoto skl_load_base_firmware_failed;\n\t}\n\n\tret = skl_cldma_prepare(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"CL dma prepare failed : %d\\n\", ret);\n\t\tgoto skl_load_base_firmware_failed;\n\t}\n\n\t \n\tskl_ipc_int_enable(ctx);\n\tskl_ipc_op_int_enable(ctx);\n\n\t \n\tfor (i = SKL_INIT_TIMEOUT; i > 0; --i) {\n\t\tif (skl_check_fw_status(ctx, SKL_FW_INIT)) {\n\t\t\tdev_dbg(ctx->dev,\n\t\t\t\t\"ROM loaded, we can continue with FW loading\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n\tif (!i) {\n\t\treg = sst_dsp_shim_read(ctx, SKL_ADSP_FW_STATUS);\n\t\tdev_err(ctx->dev,\n\t\t\t\"Timeout waiting for ROM init done, reg:0x%x\\n\", reg);\n\t\tret = -EIO;\n\t\tgoto transfer_firmware_failed;\n\t}\n\n\tret = skl_transfer_firmware(ctx, stripped_fw.data, stripped_fw.size);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Transfer firmware failed%d\\n\", ret);\n\t\tgoto transfer_firmware_failed;\n\t} else {\n\t\tret = wait_event_timeout(skl->boot_wait, skl->boot_complete,\n\t\t\t\t\tmsecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\t\tif (ret == 0) {\n\t\t\tdev_err(ctx->dev, \"DSP boot failed, FW Ready timed-out\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto transfer_firmware_failed;\n\t\t}\n\n\t\tdev_dbg(ctx->dev, \"Download firmware successful%d\\n\", ret);\n\t\tskl->fw_loaded = true;\n\t}\n\treturn 0;\ntransfer_firmware_failed:\n\tctx->cl_dev.ops.cl_cleanup_controller(ctx);\nskl_load_base_firmware_failed:\n\tskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\trelease_firmware(ctx->fw);\n\tctx->fw = NULL;\n\treturn ret;\n}\n\nstatic int skl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tint ret;\n\tstruct skl_ipc_dxstate_info dx;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\n\t \n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\tret = skl_load_base_firmware(ctx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"unable to load firmware\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (skl->lib_count > 1) {\n\t\t\tret = ctx->fw_ops.load_library(ctx, skl->lib_info,\n\t\t\t\t\t\t\tskl->lib_count);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(ctx->dev, \"reload libs failed: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t \n\tif (core_id != SKL_DSP_CORE0_ID) {\n\t\tret = skl_dsp_enable_core(ctx, core_mask);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdx.core_mask = core_mask;\n\t\tdx.dx_mask = core_mask;\n\n\t\tret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID,\n\t\t\t\t\tSKL_BASE_FW_MODULE_ID, &dx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"Failed to set dsp to D0:core id= %d\\n\",\n\t\t\t\t\tcore_id);\n\t\t\tskl_dsp_disable_core(ctx, core_mask);\n\t\t}\n\t}\n\n\tskl->cores.state[core_id] = SKL_DSP_RUNNING;\n\n\treturn 0;\n}\n\nstatic int skl_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tint ret;\n\tstruct skl_ipc_dxstate_info dx;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\n\tdx.core_mask = core_mask;\n\tdx.dx_mask = SKL_IPC_D3_MASK;\n\n\tret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID, SKL_BASE_FW_MODULE_ID, &dx);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"set Dx core %d fail: %d\\n\", core_id, ret);\n\n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\t \n\t\tctx->cl_dev.ops.cl_cleanup_controller(ctx);\n\t\tskl_cldma_int_disable(ctx);\n\t\tskl_ipc_op_int_disable(ctx);\n\t\tskl_ipc_int_disable(ctx);\n\t}\n\n\tret = skl_dsp_disable_core(ctx, core_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tskl->cores.state[core_id] = SKL_DSP_RESET;\n\treturn ret;\n}\n\nstatic unsigned int skl_get_errorcode(struct sst_dsp *ctx)\n{\n\t return sst_dsp_shim_read(ctx, SKL_ADSP_ERROR_CODE);\n}\n\n \nstatic int skl_get_module(struct sst_dsp *ctx, u16 mod_id)\n{\n\tstruct skl_module_table *module;\n\n\tlist_for_each_entry(module, &ctx->module_list, list) {\n\t\tif (module->mod_info->mod_id == mod_id)\n\t\t\treturn ++module->usage_cnt;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int skl_put_module(struct sst_dsp *ctx, u16 mod_id)\n{\n\tstruct skl_module_table *module;\n\n\tlist_for_each_entry(module, &ctx->module_list, list) {\n\t\tif (module->mod_info->mod_id == mod_id)\n\t\t\treturn --module->usage_cnt;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic struct skl_module_table *skl_fill_module_table(struct sst_dsp *ctx,\n\t\t\t\t\t\tchar *mod_name, int mod_id)\n{\n\tconst struct firmware *fw;\n\tstruct skl_module_table *skl_module;\n\tunsigned int size;\n\tint ret;\n\n\tret = request_firmware(&fw, mod_name, ctx->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Request Module %s failed :%d\\n\",\n\t\t\t\t\t\t\tmod_name, ret);\n\t\treturn NULL;\n\t}\n\n\tskl_module = devm_kzalloc(ctx->dev, sizeof(*skl_module), GFP_KERNEL);\n\tif (skl_module == NULL) {\n\t\trelease_firmware(fw);\n\t\treturn NULL;\n\t}\n\n\tsize = sizeof(*skl_module->mod_info);\n\tskl_module->mod_info = devm_kzalloc(ctx->dev, size, GFP_KERNEL);\n\tif (skl_module->mod_info == NULL) {\n\t\trelease_firmware(fw);\n\t\treturn NULL;\n\t}\n\n\tskl_module->mod_info->mod_id = mod_id;\n\tskl_module->mod_info->fw = fw;\n\tlist_add(&skl_module->list, &ctx->module_list);\n\n\treturn skl_module;\n}\n\n \nstatic struct skl_module_table *skl_module_get_from_id(\n\t\t\tstruct sst_dsp *ctx, u16 mod_id)\n{\n\tstruct skl_module_table *module;\n\n\tif (list_empty(&ctx->module_list)) {\n\t\tdev_err(ctx->dev, \"Module list is empty\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(module, &ctx->module_list, list) {\n\t\tif (module->mod_info->mod_id == mod_id)\n\t\t\treturn module;\n\t}\n\n\treturn NULL;\n}\n\nstatic int skl_transfer_module(struct sst_dsp *ctx, const void *data,\n\t\t\tu32 size, u16 mod_id, u8 table_id, bool is_module)\n{\n\tint ret, bytes_left, curr_pos;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tskl->mod_load_complete = false;\n\n\tbytes_left = ctx->cl_dev.ops.cl_copy_to_dmabuf(ctx, data, size, false);\n\tif (bytes_left < 0)\n\t\treturn bytes_left;\n\n\t \n\tif (is_module)\n\t\tret = skl_ipc_load_modules(&skl->ipc, SKL_NUM_MODULES, &mod_id);\n\telse\n\t\tret = skl_sst_ipc_load_library(&skl->ipc, 0, table_id, false);\n\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to Load %s with err %d\\n\",\n\t\t\t\tis_module ? \"module\" : \"lib\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\twhile (bytes_left > 0) {\n\t\tcurr_pos = size - bytes_left;\n\n\t\tret = skl_cldma_wait_interruptible(ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbytes_left = ctx->cl_dev.ops.cl_copy_to_dmabuf(ctx,\n\t\t\t\t\t\t\tdata + curr_pos,\n\t\t\t\t\t\t\tbytes_left, false);\n\t}\n\n\tret = wait_event_timeout(skl->mod_load_wait, skl->mod_load_complete,\n\t\t\t\tmsecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\tif (ret == 0 || !skl->mod_load_status) {\n\t\tdev_err(ctx->dev, \"Module Load failed\\n\");\n\t\tret = -EIO;\n\t}\n\nout:\n\tctx->cl_dev.ops.cl_stop_dma(ctx);\n\n\treturn ret;\n}\n\nstatic int\nskl_load_library(struct sst_dsp *ctx, struct skl_lib_info *linfo, int lib_count)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct firmware stripped_fw;\n\tint ret, i;\n\n\t \n\tfor (i = 1; i < lib_count; i++) {\n\t\tret = skl_prepare_lib_load(skl, &skl->lib_info[i], &stripped_fw,\n\t\t\t\t\tSKL_ADSP_FW_BIN_HDR_OFFSET, i);\n\t\tif (ret < 0)\n\t\t\tgoto load_library_failed;\n\t\tret = skl_transfer_module(ctx, stripped_fw.data,\n\t\t\t\tstripped_fw.size, 0, i, false);\n\t\tif (ret < 0)\n\t\t\tgoto load_library_failed;\n\t}\n\n\treturn 0;\n\nload_library_failed:\n\tskl_release_library(linfo, lib_count);\n\treturn ret;\n}\n\nstatic int skl_load_module(struct sst_dsp *ctx, u16 mod_id, u8 *guid)\n{\n\tstruct skl_module_table *module_entry = NULL;\n\tint ret = 0;\n\tchar mod_name[64];  \n\n\tsnprintf(mod_name, sizeof(mod_name), \"intel/dsp_fw_%pUL.bin\", guid);\n\n\tmodule_entry = skl_module_get_from_id(ctx, mod_id);\n\tif (module_entry == NULL) {\n\t\tmodule_entry = skl_fill_module_table(ctx, mod_name, mod_id);\n\t\tif (module_entry == NULL) {\n\t\t\tdev_err(ctx->dev, \"Failed to Load module\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!module_entry->usage_cnt) {\n\t\tret = skl_transfer_module(ctx, module_entry->mod_info->fw->data,\n\t\t\t\tmodule_entry->mod_info->fw->size,\n\t\t\t\tmod_id, 0, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"Failed to Load module\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = skl_get_module(ctx, mod_id);\n\n\treturn ret;\n}\n\nstatic int skl_unload_module(struct sst_dsp *ctx, u16 mod_id)\n{\n\tint usage_cnt;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint ret = 0;\n\n\tusage_cnt = skl_put_module(ctx, mod_id);\n\tif (usage_cnt < 0) {\n\t\tdev_err(ctx->dev, \"Module bad usage cnt!:%d\\n\", usage_cnt);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (usage_cnt > 0)\n\t\treturn 0;\n\n\tret = skl_ipc_unload_modules(&skl->ipc,\n\t\t\tSKL_NUM_MODULES, &mod_id);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to UnLoad module\\n\");\n\t\tskl_get_module(ctx, mod_id);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid skl_clear_module_cnt(struct sst_dsp *ctx)\n{\n\tstruct skl_module_table *module;\n\n\tif (list_empty(&ctx->module_list))\n\t\treturn;\n\n\tlist_for_each_entry(module, &ctx->module_list, list) {\n\t\tmodule->usage_cnt = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(skl_clear_module_cnt);\n\nstatic void skl_clear_module_table(struct sst_dsp *ctx)\n{\n\tstruct skl_module_table *module, *tmp;\n\n\tif (list_empty(&ctx->module_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(module, tmp, &ctx->module_list, list) {\n\t\tlist_del(&module->list);\n\t\trelease_firmware(module->mod_info->fw);\n\t}\n}\n\nstatic const struct skl_dsp_fw_ops skl_fw_ops = {\n\t.set_state_D0 = skl_set_dsp_D0,\n\t.set_state_D3 = skl_set_dsp_D3,\n\t.load_fw = skl_load_base_firmware,\n\t.get_fw_errcode = skl_get_errorcode,\n\t.load_library = skl_load_library,\n\t.load_mod = skl_load_module,\n\t.unload_mod = skl_unload_module,\n};\n\nstatic struct sst_ops skl_ops = {\n\t.irq_handler = skl_dsp_sst_interrupt,\n\t.write = sst_shim32_write,\n\t.read = sst_shim32_read,\n\t.free = skl_dsp_free,\n};\n\nstatic struct sst_dsp_device skl_dev = {\n\t.thread = skl_dsp_irq_thread_handler,\n\t.ops = &skl_ops,\n};\n\nint skl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,\n\t\tconst char *fw_name, struct skl_dsp_loader_ops dsp_ops,\n\t\tstruct skl_dev **dsp)\n{\n\tstruct skl_dev *skl;\n\tstruct sst_dsp *sst;\n\tint ret;\n\n\tret = skl_sst_ctx_init(dev, irq, fw_name, dsp_ops, dsp, &skl_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: no device\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tskl = *dsp;\n\tsst = skl->dsp;\n\tsst->addr.lpe = mmio_base;\n\tsst->addr.shim = mmio_base;\n\tsst->addr.sram0_base = SKL_ADSP_SRAM0_BASE;\n\tsst->addr.sram1_base = SKL_ADSP_SRAM1_BASE;\n\tsst->addr.w0_stat_sz = SKL_ADSP_W0_STAT_SZ;\n\tsst->addr.w0_up_sz = SKL_ADSP_W0_UP_SZ;\n\n\tsst_dsp_mailbox_init(sst, (SKL_ADSP_SRAM0_BASE + SKL_ADSP_W0_STAT_SZ),\n\t\t\tSKL_ADSP_W0_UP_SZ, SKL_ADSP_SRAM1_BASE, SKL_ADSP_W1_SZ);\n\n\tret = skl_ipc_init(dev, skl);\n\tif (ret) {\n\t\tskl_dsp_free(sst);\n\t\treturn ret;\n\t}\n\n\tsst->fw_ops = skl_fw_ops;\n\n\treturn skl_dsp_acquire_irq(sst);\n}\nEXPORT_SYMBOL_GPL(skl_sst_dsp_init);\n\nint skl_sst_init_fw(struct device *dev, struct skl_dev *skl)\n{\n\tint ret;\n\tstruct sst_dsp *sst = skl->dsp;\n\n\tret = sst->fw_ops.load_fw(sst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Load base fw failed : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tskl_dsp_init_core_state(sst);\n\n\tif (skl->lib_count > 1) {\n\t\tret = sst->fw_ops.load_library(sst, skl->lib_info,\n\t\t\t\t\t\tskl->lib_count);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Load Library failed : %x\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tskl->is_first_boot = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(skl_sst_init_fw);\n\nvoid skl_sst_dsp_cleanup(struct device *dev, struct skl_dev *skl)\n{\n\n\tif (skl->dsp->fw)\n\t\trelease_firmware(skl->dsp->fw);\n\tskl_clear_module_table(skl->dsp);\n\tskl_freeup_uuid_list(skl);\n\tskl_ipc_free(&skl->ipc);\n\tskl->dsp->ops->free(skl->dsp);\n\tif (skl->boot_complete) {\n\t\tskl->dsp->cl_dev.ops.cl_cleanup_controller(skl->dsp);\n\t\tskl_cldma_int_disable(skl->dsp);\n\t}\n}\nEXPORT_SYMBOL_GPL(skl_sst_dsp_cleanup);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Skylake IPC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}