{
  "module_name": "skl-sst-utils.c",
  "hash_id": "54ab6b2b728779eab77d7bd58457e964ae9a7b6abcf263703cd4842f2f2be6dd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-sst-utils.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"skl.h\"\n\n#define DEFAULT_HASH_SHA256_LEN 32\n\n \n#define SKL_EXT_MANIFEST_HEADER_MAGIC   0x31454124\n\nunion seg_flags {\n\tu32 ul;\n\tstruct {\n\t\tu32 contents : 1;\n\t\tu32 alloc    : 1;\n\t\tu32 load     : 1;\n\t\tu32 read_only : 1;\n\t\tu32 code     : 1;\n\t\tu32 data     : 1;\n\t\tu32 _rsvd0   : 2;\n\t\tu32 type     : 4;\n\t\tu32 _rsvd1   : 4;\n\t\tu32 length   : 16;\n\t} r;\n} __packed;\n\nstruct segment_desc {\n\tunion seg_flags flags;\n\tu32 v_base_addr;\n\tu32 file_offset;\n};\n\nstruct module_type {\n\tu32 load_type  : 4;\n\tu32 auto_start : 1;\n\tu32 domain_ll  : 1;\n\tu32 domain_dp  : 1;\n\tu32 rsvd       : 25;\n} __packed;\n\nstruct adsp_module_entry {\n\tu32 struct_id;\n\tu8  name[8];\n\tu8  uuid[16];\n\tstruct module_type type;\n\tu8  hash1[DEFAULT_HASH_SHA256_LEN];\n\tu32 entry_point;\n\tu16 cfg_offset;\n\tu16 cfg_count;\n\tu32 affinity_mask;\n\tu16 instance_max_count;\n\tu16 instance_bss_size;\n\tstruct segment_desc segments[3];\n} __packed;\n\nstruct adsp_fw_hdr {\n\tu32 id;\n\tu32 len;\n\tu8  name[8];\n\tu32 preload_page_count;\n\tu32 fw_image_flags;\n\tu32 feature_mask;\n\tu16 major;\n\tu16 minor;\n\tu16 hotfix;\n\tu16 build;\n\tu32 num_modules;\n\tu32 hw_buf_base;\n\tu32 hw_buf_length;\n\tu32 load_offset;\n} __packed;\n\nstruct skl_ext_manifest_hdr {\n\tu32 id;\n\tu32 len;\n\tu16 version_major;\n\tu16 version_minor;\n\tu32 entries;\n};\n\nstatic int skl_get_pvtid_map(struct uuid_module *module, int instance_id)\n{\n\tint pvt_id;\n\n\tfor (pvt_id = 0; pvt_id < module->max_instance; pvt_id++) {\n\t\tif (module->instance_id[pvt_id] == instance_id)\n\t\t\treturn pvt_id;\n\t}\n\treturn -EINVAL;\n}\n\nint skl_get_pvt_instance_id_map(struct skl_dev *skl,\n\t\t\t\tint module_id, int instance_id)\n{\n\tstruct uuid_module *module;\n\n\tlist_for_each_entry(module, &skl->uuid_list, list) {\n\t\tif (module->id == module_id)\n\t\t\treturn skl_get_pvtid_map(module, instance_id);\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(skl_get_pvt_instance_id_map);\n\nstatic inline int skl_getid_32(struct uuid_module *module, u64 *val,\n\t\t\t\tint word1_mask, int word2_mask)\n{\n\tint index, max_inst, pvt_id;\n\tu32 mask_val;\n\n\tmax_inst =  module->max_instance;\n\tmask_val = (u32)(*val >> word1_mask);\n\n\tif (mask_val != 0xffffffff) {\n\t\tindex = ffz(mask_val);\n\t\tpvt_id = index + word1_mask + word2_mask;\n\t\tif (pvt_id <= (max_inst - 1)) {\n\t\t\t*val |= 1ULL << (index + word1_mask);\n\t\t\treturn pvt_id;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline int skl_pvtid_128(struct uuid_module *module)\n{\n\tint j, i, word1_mask, word2_mask = 0, pvt_id;\n\n\tfor (j = 0; j < MAX_INSTANCE_BUFF; j++) {\n\t\tword1_mask = 0;\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tpvt_id = skl_getid_32(module, &module->pvt_id[j],\n\t\t\t\t\t\tword1_mask, word2_mask);\n\t\t\tif (pvt_id >= 0)\n\t\t\t\treturn pvt_id;\n\n\t\t\tword1_mask += 32;\n\t\t\tif ((word1_mask + word2_mask) >= module->max_instance)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tword2_mask += 64;\n\t\tif (word2_mask >= module->max_instance)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint skl_get_pvt_id(struct skl_dev *skl, guid_t *uuid_mod, int instance_id)\n{\n\tstruct uuid_module *module;\n\tint pvt_id;\n\n\tlist_for_each_entry(module, &skl->uuid_list, list) {\n\t\tif (guid_equal(uuid_mod, &module->uuid)) {\n\n\t\t\tpvt_id = skl_pvtid_128(module);\n\t\t\tif (pvt_id >= 0) {\n\t\t\t\tmodule->instance_id[pvt_id] = instance_id;\n\n\t\t\t\treturn pvt_id;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(skl_get_pvt_id);\n\n \nint skl_put_pvt_id(struct skl_dev *skl, guid_t *uuid_mod, int *pvt_id)\n{\n\tint i;\n\tstruct uuid_module *module;\n\n\tlist_for_each_entry(module, &skl->uuid_list, list) {\n\t\tif (guid_equal(uuid_mod, &module->uuid)) {\n\n\t\t\tif (*pvt_id != 0)\n\t\t\t\ti = (*pvt_id) / 64;\n\t\t\telse\n\t\t\t\ti = 0;\n\n\t\t\tmodule->pvt_id[i] &= ~(1 << (*pvt_id));\n\t\t\t*pvt_id = -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(skl_put_pvt_id);\n\n \nint snd_skl_parse_uuids(struct sst_dsp *ctx, const struct firmware *fw,\n\t\t\tunsigned int offset, int index)\n{\n\tstruct adsp_fw_hdr *adsp_hdr;\n\tstruct adsp_module_entry *mod_entry;\n\tint i, num_entry, size;\n\tconst char *buf;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct uuid_module *module;\n\tstruct firmware stripped_fw;\n\tunsigned int safe_file;\n\tint ret;\n\n\t \n\tstripped_fw.data = fw->data;\n\tstripped_fw.size = fw->size;\n\n\tskl_dsp_strip_extended_manifest(&stripped_fw);\n\n\tbuf = stripped_fw.data;\n\n\t \n\tsafe_file = sizeof(*adsp_hdr) + offset;\n\tif (stripped_fw.size <= safe_file) {\n\t\tdev_err(ctx->dev, \"Small fw file size, No space for hdr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadsp_hdr = (struct adsp_fw_hdr *)(buf + offset);\n\n\t \n\tsafe_file += adsp_hdr->len + sizeof(*mod_entry);\n\tif (stripped_fw.size <= safe_file) {\n\t\tdev_err(ctx->dev, \"Small fw file size, No module entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmod_entry = (struct adsp_module_entry *)(buf + offset + adsp_hdr->len);\n\n\tnum_entry = adsp_hdr->num_modules;\n\n\t \n\tsafe_file += num_entry * sizeof(*mod_entry);\n\tif (stripped_fw.size <= safe_file) {\n\t\tdev_err(ctx->dev, \"Small fw file size, No modules\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\n\t \n\n\tfor (i = 0; i < num_entry; i++, mod_entry++) {\n\t\tmodule = kzalloc(sizeof(*module), GFP_KERNEL);\n\t\tif (!module) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_uuid_list;\n\t\t}\n\n\t\timport_guid(&module->uuid, mod_entry->uuid);\n\n\t\tmodule->id = (i | (index << 12));\n\t\tmodule->is_loadable = mod_entry->type.load_type;\n\t\tmodule->max_instance = mod_entry->instance_max_count;\n\t\tsize = sizeof(int) * mod_entry->instance_max_count;\n\t\tmodule->instance_id = devm_kzalloc(ctx->dev, size, GFP_KERNEL);\n\t\tif (!module->instance_id) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(module);\n\t\t\tgoto free_uuid_list;\n\t\t}\n\n\t\tlist_add_tail(&module->list, &skl->uuid_list);\n\n\t\tdev_dbg(ctx->dev,\n\t\t\t\"Adding uuid :%pUL   mod id: %d  Loadable: %d\\n\",\n\t\t\t&module->uuid, module->id, module->is_loadable);\n\t}\n\n\treturn 0;\n\nfree_uuid_list:\n\tskl_freeup_uuid_list(skl);\n\treturn ret;\n}\n\nvoid skl_freeup_uuid_list(struct skl_dev *skl)\n{\n\tstruct uuid_module *uuid, *_uuid;\n\n\tlist_for_each_entry_safe(uuid, _uuid, &skl->uuid_list, list) {\n\t\tlist_del(&uuid->list);\n\t\tkfree(uuid);\n\t}\n}\n\n \nint skl_dsp_strip_extended_manifest(struct firmware *fw)\n{\n\tstruct skl_ext_manifest_hdr *hdr;\n\n\t \n\tif (fw->size < sizeof(hdr)) {\n\t\tpr_err(\"%s: Firmware file small, no hdr\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thdr = (struct skl_ext_manifest_hdr *)fw->data;\n\n\tif (hdr->id == SKL_EXT_MANIFEST_HEADER_MAGIC) {\n\t\tfw->size -= hdr->len;\n\t\tfw->data += hdr->len;\n\t}\n\n\treturn 0;\n}\n\nint skl_sst_ctx_init(struct device *dev, int irq, const char *fw_name,\n\tstruct skl_dsp_loader_ops dsp_ops, struct skl_dev **dsp,\n\tstruct sst_dsp_device *skl_dev)\n{\n\tstruct skl_dev *skl = *dsp;\n\tstruct sst_dsp *sst;\n\n\tskl->dev = dev;\n\tskl_dev->thread_context = skl;\n\tINIT_LIST_HEAD(&skl->uuid_list);\n\tskl->dsp = skl_dsp_ctx_init(dev, skl_dev, irq);\n\tif (!skl->dsp) {\n\t\tdev_err(skl->dev, \"%s: no device\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tsst = skl->dsp;\n\tsst->fw_name = fw_name;\n\tsst->dsp_ops = dsp_ops;\n\tinit_waitqueue_head(&skl->mod_load_wait);\n\tINIT_LIST_HEAD(&sst->module_list);\n\n\tskl->is_first_boot = true;\n\n\treturn 0;\n}\n\nint skl_prepare_lib_load(struct skl_dev *skl, struct skl_lib_info *linfo,\n\t\tstruct firmware *stripped_fw,\n\t\tunsigned int hdr_offset, int index)\n{\n\tint ret;\n\tstruct sst_dsp *dsp = skl->dsp;\n\n\tif (linfo->fw == NULL) {\n\t\tret = request_firmware(&linfo->fw, linfo->name,\n\t\t\t\t\tskl->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(skl->dev, \"Request lib %s failed:%d\\n\",\n\t\t\t\tlinfo->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (skl->is_first_boot) {\n\t\tret = snd_skl_parse_uuids(dsp, linfo->fw, hdr_offset, index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstripped_fw->data = linfo->fw->data;\n\tstripped_fw->size = linfo->fw->size;\n\tskl_dsp_strip_extended_manifest(stripped_fw);\n\n\treturn 0;\n}\n\nvoid skl_release_library(struct skl_lib_info *linfo, int lib_count)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i < lib_count; i++) {\n\t\tif (linfo[i].fw) {\n\t\t\trelease_firmware(linfo[i].fw);\n\t\t\tlinfo[i].fw = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}