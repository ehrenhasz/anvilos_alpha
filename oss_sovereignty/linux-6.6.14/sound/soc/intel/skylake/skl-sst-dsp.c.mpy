{
  "module_name": "skl-sst-dsp.c",
  "hash_id": "4e8800c903442bf77f9c5a860f0207733e2ac7b75bb17ace795feffdb9f1d049",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-sst-dsp.c",
  "human_readable_source": "\n \n#include <sound/pcm.h>\n\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-ipc.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"skl.h\"\n\n \n#define SKL_DSP_PU_TO\t\t50\n#define SKL_DSP_PD_TO\t\t50\n#define SKL_DSP_RESET_TO\t50\n\nvoid skl_dsp_set_state_locked(struct sst_dsp *ctx, int state)\n{\n\tmutex_lock(&ctx->mutex);\n\tctx->sst_state = state;\n\tmutex_unlock(&ctx->mutex);\n}\n\n \nvoid skl_dsp_init_core_state(struct sst_dsp *ctx)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint i;\n\n\tskl->cores.state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING;\n\tskl->cores.usage_count[SKL_DSP_CORE0_ID] = 1;\n\n\tfor (i = SKL_DSP_CORE0_ID + 1; i < skl->cores.count; i++) {\n\t\tskl->cores.state[i] = SKL_DSP_RESET;\n\t\tskl->cores.usage_count[i] = 0;\n\t}\n}\n\n \nunsigned int skl_dsp_get_enabled_cores(struct sst_dsp *ctx)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tunsigned int core_mask, en_cores_mask;\n\tu32 val;\n\n\tcore_mask = SKL_DSP_CORES_MASK(skl->cores.count);\n\n\tval = sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS);\n\n\t \n\ten_cores_mask = (val & SKL_ADSPCS_CPA_MASK(core_mask)) >>\n\t\t\tSKL_ADSPCS_CPA_SHIFT;\n\n\t \n\ten_cores_mask &= (~val & SKL_ADSPCS_CRST_MASK(core_mask)) >>\n\t\t\tSKL_ADSPCS_CRST_SHIFT;\n\n\t \n\ten_cores_mask &= (~val & SKL_ADSPCS_CSTALL_MASK(core_mask)) >>\n\t\t\tSKL_ADSPCS_CSTALL_SHIFT;\n\ten_cores_mask &= core_mask;\n\n\tdev_dbg(ctx->dev, \"DSP enabled cores mask = %x\\n\", en_cores_mask);\n\n\treturn en_cores_mask;\n}\n\nstatic int\nskl_dsp_core_set_reset_state(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx,\n\t\t\tSKL_ADSP_REG_ADSPCS, SKL_ADSPCS_CRST_MASK(core_mask),\n\t\t\tSKL_ADSPCS_CRST_MASK(core_mask));\n\n\t \n\tret = sst_dsp_register_poll(ctx,\n\t\t\tSKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CRST_MASK(core_mask),\n\t\t\tSKL_ADSPCS_CRST_MASK(core_mask),\n\t\t\tSKL_DSP_RESET_TO,\n\t\t\t\"Set reset\");\n\tif ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &\n\t\t\t\tSKL_ADSPCS_CRST_MASK(core_mask)) !=\n\t\t\t\tSKL_ADSPCS_CRST_MASK(core_mask)) {\n\t\tdev_err(ctx->dev, \"Set reset state failed: core_mask %x\\n\",\n\t\t\t\t\t\t\tcore_mask);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nint skl_dsp_core_unset_reset_state(\n\t\tstruct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\tdev_dbg(ctx->dev, \"In %s\\n\", __func__);\n\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,\n\t\t\t\tSKL_ADSPCS_CRST_MASK(core_mask), 0);\n\n\t \n\tret = sst_dsp_register_poll(ctx,\n\t\t\tSKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CRST_MASK(core_mask),\n\t\t\t0,\n\t\t\tSKL_DSP_RESET_TO,\n\t\t\t\"Unset reset\");\n\n\tif ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &\n\t\t\t\tSKL_ADSPCS_CRST_MASK(core_mask)) != 0) {\n\t\tdev_err(ctx->dev, \"Unset reset state failed: core_mask %x\\n\",\n\t\t\t\tcore_mask);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic bool\nis_skl_dsp_core_enable(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint val;\n\tbool is_enable;\n\n\tval = sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS);\n\n\tis_enable = ((val & SKL_ADSPCS_CPA_MASK(core_mask)) &&\n\t\t\t(val & SKL_ADSPCS_SPA_MASK(core_mask)) &&\n\t\t\t!(val & SKL_ADSPCS_CRST_MASK(core_mask)) &&\n\t\t\t!(val & SKL_ADSPCS_CSTALL_MASK(core_mask)));\n\n\tdev_dbg(ctx->dev, \"DSP core(s) enabled? %d : core_mask %x\\n\",\n\t\t\t\t\t\tis_enable, core_mask);\n\n\treturn is_enable;\n}\n\nstatic int skl_dsp_reset_core(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CSTALL_MASK(core_mask),\n\t\t\tSKL_ADSPCS_CSTALL_MASK(core_mask));\n\n\t \n\treturn skl_dsp_core_set_reset_state(ctx, core_mask);\n}\n\nint skl_dsp_start_core(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\t \n\tret = skl_dsp_core_unset_reset_state(ctx, core_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdev_dbg(ctx->dev, \"unstall/run core: core_mask = %x\\n\", core_mask);\n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CSTALL_MASK(core_mask), 0);\n\n\tif (!is_skl_dsp_core_enable(ctx, core_mask)) {\n\t\tskl_dsp_reset_core(ctx, core_mask);\n\t\tdev_err(ctx->dev, \"DSP start core failed: core_mask %x\\n\",\n\t\t\t\t\t\t\tcore_mask);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nint skl_dsp_core_power_up(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_SPA_MASK(core_mask),\n\t\t\tSKL_ADSPCS_SPA_MASK(core_mask));\n\n\t \n\tret = sst_dsp_register_poll(ctx,\n\t\t\tSKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CPA_MASK(core_mask),\n\t\t\tSKL_ADSPCS_CPA_MASK(core_mask),\n\t\t\tSKL_DSP_PU_TO,\n\t\t\t\"Power up\");\n\n\tif ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &\n\t\t\tSKL_ADSPCS_CPA_MASK(core_mask)) !=\n\t\t\tSKL_ADSPCS_CPA_MASK(core_mask)) {\n\t\tdev_err(ctx->dev, \"DSP core power up failed: core_mask %x\\n\",\n\t\t\t\tcore_mask);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nint skl_dsp_core_power_down(struct sst_dsp  *ctx, unsigned int core_mask)\n{\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,\n\t\t\t\tSKL_ADSPCS_SPA_MASK(core_mask), 0);\n\n\t \n\treturn sst_dsp_register_poll(ctx,\n\t\t\tSKL_ADSP_REG_ADSPCS,\n\t\t\tSKL_ADSPCS_CPA_MASK(core_mask),\n\t\t\t0,\n\t\t\tSKL_DSP_PD_TO,\n\t\t\t\"Power down\");\n}\n\nint skl_dsp_enable_core(struct sst_dsp  *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\t \n\tret = skl_dsp_core_power_up(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core power up failed: core_mask %x\\n\",\n\t\t\t\t\t\t\tcore_mask);\n\t\treturn ret;\n\t}\n\n\treturn skl_dsp_start_core(ctx, core_mask);\n}\n\nint skl_dsp_disable_core(struct sst_dsp *ctx, unsigned int core_mask)\n{\n\tint ret;\n\n\tret = skl_dsp_reset_core(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core reset failed: core_mask %x\\n\",\n\t\t\t\t\t\t\tcore_mask);\n\t\treturn ret;\n\t}\n\n\t \n\tret = skl_dsp_core_power_down(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core power down fail mask %x: %d\\n\",\n\t\t\t\t\t\t\tcore_mask, ret);\n\t\treturn ret;\n\t}\n\n\tif (is_skl_dsp_core_enable(ctx, core_mask)) {\n\t\tdev_err(ctx->dev, \"dsp core disable fail mask %x: %d\\n\",\n\t\t\t\t\t\t\tcore_mask, ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nint skl_dsp_boot(struct sst_dsp *ctx)\n{\n\tint ret;\n\n\tif (is_skl_dsp_core_enable(ctx, SKL_DSP_CORE0_MASK)) {\n\t\tret = skl_dsp_reset_core(ctx, SKL_DSP_CORE0_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"dsp core0 reset fail: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = skl_dsp_start_core(ctx, SKL_DSP_CORE0_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"dsp core0 start fail: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"dsp core0 disable fail: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = skl_dsp_enable_core(ctx, SKL_DSP_CORE0_MASK);\n\t}\n\n\treturn ret;\n}\n\nirqreturn_t skl_dsp_sst_interrupt(int irq, void *dev_id)\n{\n\tstruct sst_dsp *ctx = dev_id;\n\tu32 val;\n\tirqreturn_t result = IRQ_NONE;\n\n\tspin_lock(&ctx->spinlock);\n\n\tval = sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPIS);\n\tctx->intr_status = val;\n\n\tif (val == 0xffffffff) {\n\t\tspin_unlock(&ctx->spinlock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (val & SKL_ADSPIS_IPC) {\n\t\tskl_ipc_int_disable(ctx);\n\t\tresult = IRQ_WAKE_THREAD;\n\t}\n\n\tif (val & SKL_ADSPIS_CL_DMA) {\n\t\tskl_cldma_int_disable(ctx);\n\t\tresult = IRQ_WAKE_THREAD;\n\t}\n\n\tspin_unlock(&ctx->spinlock);\n\n\treturn result;\n}\n \nint skl_dsp_get_core(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint ret = 0;\n\n\tif (core_id >= skl->cores.count) {\n\t\tdev_err(ctx->dev, \"invalid core id: %d\\n\", core_id);\n\t\treturn -EINVAL;\n\t}\n\n\tskl->cores.usage_count[core_id]++;\n\n\tif (skl->cores.state[core_id] == SKL_DSP_RESET) {\n\t\tret = ctx->fw_ops.set_state_D0(ctx, core_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"unable to get core%d\\n\", core_id);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tdev_dbg(ctx->dev, \"core id %d state %d usage_count %d\\n\",\n\t\t\tcore_id, skl->cores.state[core_id],\n\t\t\tskl->cores.usage_count[core_id]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_dsp_get_core);\n\nint skl_dsp_put_core(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint ret = 0;\n\n\tif (core_id >= skl->cores.count) {\n\t\tdev_err(ctx->dev, \"invalid core id: %d\\n\", core_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((--skl->cores.usage_count[core_id] == 0) &&\n\t\t(skl->cores.state[core_id] != SKL_DSP_RESET)) {\n\t\tret = ctx->fw_ops.set_state_D3(ctx, core_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"unable to put core %d: %d\\n\",\n\t\t\t\t\tcore_id, ret);\n\t\t\tskl->cores.usage_count[core_id]++;\n\t\t}\n\t}\n\n\tdev_dbg(ctx->dev, \"core id %d state %d usage_count %d\\n\",\n\t\t\tcore_id, skl->cores.state[core_id],\n\t\t\tskl->cores.usage_count[core_id]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_dsp_put_core);\n\nint skl_dsp_wake(struct sst_dsp *ctx)\n{\n\treturn skl_dsp_get_core(ctx, SKL_DSP_CORE0_ID);\n}\nEXPORT_SYMBOL_GPL(skl_dsp_wake);\n\nint skl_dsp_sleep(struct sst_dsp *ctx)\n{\n\treturn skl_dsp_put_core(ctx, SKL_DSP_CORE0_ID);\n}\nEXPORT_SYMBOL_GPL(skl_dsp_sleep);\n\nstruct sst_dsp *skl_dsp_ctx_init(struct device *dev,\n\t\tstruct sst_dsp_device *sst_dev, int irq)\n{\n\tint ret;\n\tstruct sst_dsp *sst;\n\n\tsst = devm_kzalloc(dev, sizeof(*sst), GFP_KERNEL);\n\tif (sst == NULL)\n\t\treturn NULL;\n\n\tspin_lock_init(&sst->spinlock);\n\tmutex_init(&sst->mutex);\n\tsst->dev = dev;\n\tsst->sst_dev = sst_dev;\n\tsst->irq = irq;\n\tsst->ops = sst_dev->ops;\n\tsst->thread_context = sst_dev->thread_context;\n\n\t \n\tif (sst->ops->init) {\n\t\tret = sst->ops->init(sst);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn sst;\n}\n\nint skl_dsp_acquire_irq(struct sst_dsp *sst)\n{\n\tstruct sst_dsp_device *sst_dev = sst->sst_dev;\n\tint ret;\n\n\t \n\tret = request_threaded_irq(sst->irq, sst->ops->irq_handler,\n\t\tsst_dev->thread, IRQF_SHARED, \"AudioDSP\", sst);\n\tif (ret)\n\t\tdev_err(sst->dev, \"unable to grab threaded IRQ %d, disabling device\\n\",\n\t\t\t       sst->irq);\n\n\treturn ret;\n}\n\nvoid skl_dsp_free(struct sst_dsp *dsp)\n{\n\tskl_ipc_int_disable(dsp);\n\n\tfree_irq(dsp->irq, dsp);\n\tskl_ipc_op_int_disable(dsp);\n\tskl_dsp_disable_core(dsp, SKL_DSP_CORE0_MASK);\n}\nEXPORT_SYMBOL_GPL(skl_dsp_free);\n\nbool is_skl_dsp_running(struct sst_dsp *ctx)\n{\n\treturn (ctx->sst_state == SKL_DSP_RUNNING);\n}\nEXPORT_SYMBOL_GPL(is_skl_dsp_running);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}