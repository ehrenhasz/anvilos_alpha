{
  "module_name": "skl.c",
  "hash_id": "c762d08df13317a0fa3d4b028a7699ed6ddf0254f3053d349f43a2c4646e9a77",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <sound/pcm.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/hda_register.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_i915.h>\n#include <sound/hda_codec.h>\n#include <sound/intel-nhlt.h>\n#include <sound/intel-dsp-config.h>\n#include \"skl.h\"\n#include \"skl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n#include \"../../../soc/codecs/hdac_hda.h\"\n#endif\nstatic int skl_pci_binding;\nmodule_param_named(pci_binding, skl_pci_binding, int, 0444);\nMODULE_PARM_DESC(pci_binding, \"PCI binding (0=auto, 1=only legacy, 2=only asoc\");\n\n \nstatic void skl_update_pci_byte(struct pci_dev *pci, unsigned int reg,\n\t\t\t    unsigned char mask, unsigned char val)\n{\n\tunsigned char data;\n\n\tpci_read_config_byte(pci, reg, &data);\n\tdata &= ~mask;\n\tdata |= (val & mask);\n\tpci_write_config_byte(pci, reg, data);\n}\n\nstatic void skl_init_pci(struct skl_dev *skl)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\n\t \n\tdev_dbg(bus->dev, \"Clearing TCSEL\\n\");\n\tskl_update_pci_byte(skl->pci, AZX_PCIREG_TCSEL, 0x07, 0);\n}\n\nstatic void update_pci_dword(struct pci_dev *pci,\n\t\t\tunsigned int reg, u32 mask, u32 val)\n{\n\tu32 data = 0;\n\n\tpci_read_config_dword(pci, reg, &data);\n\tdata &= ~mask;\n\tdata |= (val & mask);\n\tpci_write_config_dword(pci, reg, data);\n}\n\n \nstatic void skl_enable_miscbdcge(struct device *dev, bool enable)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tu32 val;\n\n\tval = enable ? AZX_CGCTL_MISCBDCGE_MASK : 0;\n\n\tupdate_pci_dword(pci, AZX_PCIREG_CGCTL, AZX_CGCTL_MISCBDCGE_MASK, val);\n}\n\n \nstatic void skl_clock_power_gating(struct device *dev, bool enable)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tu32 val;\n\n\t \n\tval = enable ? AZX_CGCTL_ADSPDCGE : 0;\n\tupdate_pci_dword(pci, AZX_PCIREG_CGCTL, AZX_CGCTL_ADSPDCGE, val);\n\n\t \n\tval = enable ? AZX_REG_VS_EM2_L1SEN : 0;\n\tsnd_hdac_chip_updatel(bus, VS_EM2, AZX_REG_VS_EM2_L1SEN, val);\n\n\t \n\tval = enable ? 0 : AZX_PGCTL_ADSPPGD;\n\tupdate_pci_dword(pci, AZX_PCIREG_PGCTL, AZX_PGCTL_ADSPPGD, val);\n}\n\n \nstatic int skl_init_chip(struct hdac_bus *bus, bool full_reset)\n{\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\tsnd_hdac_set_codec_wakeup(bus, true);\n\tskl_enable_miscbdcge(bus->dev, false);\n\tret = snd_hdac_bus_init_chip(bus, full_reset);\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\twritel(0, hlink->ml_addr + AZX_REG_ML_LOSIDV);\n\n\tskl_enable_miscbdcge(bus->dev, true);\n\tsnd_hdac_set_codec_wakeup(bus, false);\n\n\treturn ret;\n}\n\nvoid skl_update_d0i3c(struct device *dev, bool enable)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tu8 reg;\n\tint timeout = 50;\n\n\treg = snd_hdac_chip_readb(bus, VS_D0I3C);\n\t \n\twhile ((reg & AZX_REG_VS_D0I3C_CIP) && --timeout) {\n\t\tudelay(10);\n\t\treg = snd_hdac_chip_readb(bus, VS_D0I3C);\n\t}\n\n\t \n\tif (!timeout) {\n\t\tdev_err(bus->dev, \"Before D0I3C update: D0I3C CIP timeout\\n\");\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\treg = reg | AZX_REG_VS_D0I3C_I3;\n\telse\n\t\treg = reg & (~AZX_REG_VS_D0I3C_I3);\n\n\tsnd_hdac_chip_writeb(bus, VS_D0I3C, reg);\n\n\ttimeout = 50;\n\t \n\treg = snd_hdac_chip_readb(bus, VS_D0I3C);\n\twhile ((reg & AZX_REG_VS_D0I3C_CIP) && --timeout) {\n\t\tudelay(10);\n\t\treg = snd_hdac_chip_readb(bus, VS_D0I3C);\n\t}\n\n\t \n\tif (!timeout) {\n\t\tdev_err(bus->dev, \"After D0I3C update: D0I3C CIP timeout\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(bus->dev, \"D0I3C register = 0x%x\\n\",\n\t\t\tsnd_hdac_chip_readb(bus, VS_D0I3C));\n}\n\n \nstatic void skl_dum_set(struct hdac_bus *bus)\n{\n\t \n\tif (!(snd_hdac_chip_readb(bus, GCTL) & AZX_GCTL_RESET)) {\n\t\tskl_enable_miscbdcge(bus->dev, false);\n\t\tsnd_hdac_bus_exit_link_reset(bus);\n\t\tskl_enable_miscbdcge(bus->dev, true);\n\t}\n\n\tsnd_hdac_chip_updatel(bus, VS_EM2, AZX_VS_EM2_DUM, AZX_VS_EM2_DUM);\n}\n\n \nstatic void skl_stream_update(struct hdac_bus *bus, struct hdac_stream *hstr)\n{\n\tsnd_pcm_period_elapsed(hstr->substream);\n}\n\nstatic irqreturn_t skl_interrupt(int irq, void *dev_id)\n{\n\tstruct hdac_bus *bus = dev_id;\n\tu32 status;\n\n\tif (!pm_runtime_active(bus->dev))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&bus->reg_lock);\n\n\tstatus = snd_hdac_chip_readl(bus, INTSTS);\n\tif (status == 0 || status == 0xffffffff) {\n\t\tspin_unlock(&bus->reg_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tstatus = snd_hdac_chip_readb(bus, RIRBSTS);\n\tif (status & RIRB_INT_MASK) {\n\t\tif (status & RIRB_INT_RESPONSE)\n\t\t\tsnd_hdac_bus_update_rirb(bus);\n\t\tsnd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);\n\t}\n\n\tspin_unlock(&bus->reg_lock);\n\n\treturn snd_hdac_chip_readl(bus, INTSTS) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}\n\nstatic irqreturn_t skl_threaded_handler(int irq, void *dev_id)\n{\n\tstruct hdac_bus *bus = dev_id;\n\tu32 status;\n\n\tstatus = snd_hdac_chip_readl(bus, INTSTS);\n\n\tsnd_hdac_bus_handle_stream_irq(bus, status, skl_stream_update);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int skl_acquire_irq(struct hdac_bus *bus, int do_disconnect)\n{\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tint ret;\n\n\tret = request_threaded_irq(skl->pci->irq, skl_interrupt,\n\t\t\tskl_threaded_handler,\n\t\t\tIRQF_SHARED,\n\t\t\tKBUILD_MODNAME, bus);\n\tif (ret) {\n\t\tdev_err(bus->dev,\n\t\t\t\"unable to grab IRQ %d, disabling device\\n\",\n\t\t\tskl->pci->irq);\n\t\treturn ret;\n\t}\n\n\tbus->irq = skl->pci->irq;\n\tpci_intx(skl->pci, 1);\n\n\treturn 0;\n}\n\nstatic int skl_suspend_late(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\treturn skl_suspend_late_dsp(skl);\n}\n\n#ifdef CONFIG_PM\nstatic int _skl_suspend(struct hdac_bus *bus)\n{\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct pci_dev *pci = to_pci_dev(bus->dev);\n\tint ret;\n\n\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\n\tret = skl_suspend_dsp(skl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnd_hdac_bus_stop_chip(bus);\n\tupdate_pci_dword(pci, AZX_PCIREG_PGCTL,\n\t\tAZX_PGCTL_LSRMD_MASK, AZX_PGCTL_LSRMD_MASK);\n\tskl_enable_miscbdcge(bus->dev, false);\n\tsnd_hdac_bus_enter_link_reset(bus);\n\tskl_enable_miscbdcge(bus->dev, true);\n\tskl_cleanup_resources(skl);\n\n\treturn 0;\n}\n\nstatic int _skl_resume(struct hdac_bus *bus)\n{\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tskl_init_pci(skl);\n\tskl_dum_set(bus);\n\tskl_init_chip(bus, true);\n\n\treturn skl_resume_dsp(skl);\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int skl_suspend(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct skl_dev *skl  = bus_to_skl(bus);\n\tint ret;\n\n\t \n\tif (skl->supend_active) {\n\t\t \n\t\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\n\t\tif (bus->cmd_dma_state)\n\t\t\tsnd_hdac_bus_stop_cmd_io(bus);\n\n\t\tenable_irq_wake(bus->irq);\n\t\tpci_save_state(pci);\n\t} else {\n\t\tret = _skl_suspend(bus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tskl->fw_loaded = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct skl_dev *skl  = bus_to_skl(bus);\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\t \n\tif (skl->supend_active) {\n\t\tpci_restore_state(pci);\n\t\tsnd_hdac_ext_bus_link_power_up_all(bus);\n\t\tdisable_irq_wake(bus->irq);\n\t\t \n\t\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\t\tif (hlink->ref_count)\n\t\t\t\tsnd_hdac_ext_bus_link_power_up(hlink);\n\t\t}\n\n\t\tret = 0;\n\t\tif (bus->cmd_dma_state)\n\t\t\tsnd_hdac_bus_init_cmd_io(bus);\n\t} else {\n\t\tret = _skl_resume(bus);\n\t}\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int skl_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\n\tdev_dbg(bus->dev, \"in %s\\n\", __func__);\n\n\treturn _skl_suspend(bus);\n}\n\nstatic int skl_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\n\tdev_dbg(bus->dev, \"in %s\\n\", __func__);\n\n\treturn _skl_resume(bus);\n}\n#endif  \n\nstatic const struct dev_pm_ops skl_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(skl_suspend, skl_resume)\n\tSET_RUNTIME_PM_OPS(skl_runtime_suspend, skl_runtime_resume, NULL)\n\t.suspend_late = skl_suspend_late,\n};\n\n \nstatic int skl_free(struct hdac_bus *bus)\n{\n\tstruct skl_dev *skl  = bus_to_skl(bus);\n\n\tskl->init_done = 0;  \n\n\tsnd_hdac_stop_streams_and_chip(bus);\n\n\tif (bus->irq >= 0)\n\t\tfree_irq(bus->irq, (void *)bus);\n\tsnd_hdac_bus_free_stream_pages(bus);\n\tsnd_hdac_ext_stream_free_all(bus);\n\tsnd_hdac_ext_link_free_all(bus);\n\n\tif (bus->remap_addr)\n\t\tiounmap(bus->remap_addr);\n\n\tpci_release_regions(skl->pci);\n\tpci_disable_device(skl->pci);\n\n\tsnd_hdac_ext_bus_exit(bus);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_HDAC_HDMI)) {\n\t\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\t\tsnd_hdac_i915_exit(bus);\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct skl_ssp_clk skl_ssp_clks[] = {\n\t{.name = \"ssp0_mclk\"}, {.name = \"ssp1_mclk\"}, {.name = \"ssp2_mclk\"},\n\t{.name = \"ssp3_mclk\"}, {.name = \"ssp4_mclk\"}, {.name = \"ssp5_mclk\"},\n\t{.name = \"ssp0_sclk\"}, {.name = \"ssp1_sclk\"}, {.name = \"ssp2_sclk\"},\n\t{.name = \"ssp3_sclk\"}, {.name = \"ssp4_sclk\"}, {.name = \"ssp5_sclk\"},\n\t{.name = \"ssp0_sclkfs\"}, {.name = \"ssp1_sclkfs\"},\n\t\t\t\t\t\t{.name = \"ssp2_sclkfs\"},\n\t{.name = \"ssp3_sclkfs\"}, {.name = \"ssp4_sclkfs\"},\n\t\t\t\t\t\t{.name = \"ssp5_sclkfs\"},\n};\n\nstatic struct snd_soc_acpi_mach *skl_find_hda_machine(struct skl_dev *skl,\n\t\t\t\t\tstruct snd_soc_acpi_mach *machines)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\n\t \n\tmach = snd_soc_acpi_intel_hda_machines;\n\n\t \n\tmach->fw_filename = machines->fw_filename;\n\n\treturn mach;\n}\n\nstatic int skl_find_machine(struct skl_dev *skl, void *driver_data)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct snd_soc_acpi_mach *mach = driver_data;\n\tstruct skl_machine_pdata *pdata;\n\n\tmach = snd_soc_acpi_find_machine(mach);\n\tif (!mach) {\n\t\tdev_dbg(bus->dev, \"No matching I2S machine driver found\\n\");\n\t\tmach = skl_find_hda_machine(skl, driver_data);\n\t\tif (!mach) {\n\t\t\tdev_err(bus->dev, \"No matching machine driver found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tskl->mach = mach;\n\tskl->fw_name = mach->fw_filename;\n\tpdata = mach->pdata;\n\n\tif (pdata) {\n\t\tskl->use_tplg_pcm = pdata->use_tplg_pcm;\n\t\tmach->mach_params.dmic_num =\n\t\t\tintel_nhlt_get_dmic_geo(&skl->pci->dev,\n\t\t\t\t\t\tskl->nhlt);\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_machine_device_register(struct skl_dev *skl)\n{\n\tstruct snd_soc_acpi_mach *mach = skl->mach;\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tpdev = platform_device_alloc(mach->drv_name, -1);\n\tif (pdev == NULL) {\n\t\tdev_err(bus->dev, \"platform device alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmach->mach_params.platform = dev_name(bus->dev);\n\tmach->mach_params.codec_mask = bus->codec_mask;\n\n\tret = platform_device_add_data(pdev, (const void *)mach, sizeof(*mach));\n\tif (ret) {\n\t\tdev_err(bus->dev, \"failed to add machine device platform data\\n\");\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tdev_err(bus->dev, \"failed to add machine device\\n\");\n\t\tplatform_device_put(pdev);\n\t\treturn -EIO;\n\t}\n\n\n\tskl->i2s_dev = pdev;\n\n\treturn 0;\n}\n\nstatic void skl_machine_device_unregister(struct skl_dev *skl)\n{\n\tif (skl->i2s_dev)\n\t\tplatform_device_unregister(skl->i2s_dev);\n}\n\nstatic int skl_dmic_device_register(struct skl_dev *skl)\n{\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct platform_device *pdev;\n\tint ret;\n\n\t \n\tpdev = platform_device_alloc(\"dmic-codec\", -1);\n\tif (!pdev) {\n\t\tdev_err(bus->dev, \"failed to allocate dmic device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tdev_err(bus->dev, \"failed to add dmic device: %d\\n\", ret);\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\tskl->dmic_dev = pdev;\n\n\treturn 0;\n}\n\nstatic void skl_dmic_device_unregister(struct skl_dev *skl)\n{\n\tif (skl->dmic_dev)\n\t\tplatform_device_unregister(skl->dmic_dev);\n}\n\nstatic struct skl_clk_parent_src skl_clk_src[] = {\n\t{ .clk_id = SKL_XTAL, .name = \"xtal\" },\n\t{ .clk_id = SKL_CARDINAL, .name = \"cardinal\", .rate = 24576000 },\n\t{ .clk_id = SKL_PLL, .name = \"pll\", .rate = 96000000 },\n};\n\nstruct skl_clk_parent_src *skl_get_parent_clk(u8 clk_id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(skl_clk_src); i++) {\n\t\tif (skl_clk_src[i].clk_id == clk_id)\n\t\t\treturn &skl_clk_src[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void init_skl_xtal_rate(int pci_id)\n{\n\tswitch (pci_id) {\n\tcase PCI_DEVICE_ID_INTEL_HDA_SKL_LP:\n\tcase PCI_DEVICE_ID_INTEL_HDA_KBL_LP:\n\t\tskl_clk_src[0].rate = 24000000;\n\t\treturn;\n\n\tdefault:\n\t\tskl_clk_src[0].rate = 19200000;\n\t\treturn;\n\t}\n}\n\nstatic int skl_clock_device_register(struct skl_dev *skl)\n{\n\tstruct platform_device_info pdevinfo = {NULL};\n\tstruct skl_clk_pdata *clk_pdata;\n\n\tif (!skl->nhlt)\n\t\treturn 0;\n\n\tclk_pdata = devm_kzalloc(&skl->pci->dev, sizeof(*clk_pdata),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!clk_pdata)\n\t\treturn -ENOMEM;\n\n\tinit_skl_xtal_rate(skl->pci->device);\n\n\tclk_pdata->parent_clks = skl_clk_src;\n\tclk_pdata->ssp_clks = skl_ssp_clks;\n\tclk_pdata->num_clks = ARRAY_SIZE(skl_ssp_clks);\n\n\t \n\tskl_get_clks(skl, clk_pdata->ssp_clks);\n\tclk_pdata->pvt_data = skl;\n\n\t \n\tpdevinfo.parent = &skl->pci->dev;\n\tpdevinfo.id = -1;\n\tpdevinfo.name = \"skl-ssp-clk\";\n\tpdevinfo.data = clk_pdata;\n\tpdevinfo.size_data = sizeof(*clk_pdata);\n\tskl->clk_dev = platform_device_register_full(&pdevinfo);\n\treturn PTR_ERR_OR_ZERO(skl->clk_dev);\n}\n\nstatic void skl_clock_device_unregister(struct skl_dev *skl)\n{\n\tif (skl->clk_dev)\n\t\tplatform_device_unregister(skl->clk_dev);\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n\n#define IDISP_INTEL_VENDOR_ID\t0x80860000\n\n \nstatic void load_codec_module(struct hda_codec *codec)\n{\n#ifdef MODULE\n\tchar modalias[MODULE_NAME_LEN];\n\tconst char *mod = NULL;\n\n\tsnd_hdac_codec_modalias(&codec->core, modalias, sizeof(modalias));\n\tmod = modalias;\n\tdev_dbg(&codec->core.dev, \"loading %s codec module\\n\", mod);\n\trequest_module(mod);\n#endif\n}\n\n#endif  \n\nstatic struct hda_codec *skl_codec_device_init(struct hdac_bus *bus, int addr)\n{\n\tstruct hda_codec *codec;\n\tint ret;\n\n\tcodec = snd_hda_codec_device_init(to_hda_bus(bus), addr, \"ehdaudio%dD%d\", bus->idx, addr);\n\tif (IS_ERR(codec)) {\n\t\tdev_err(bus->dev, \"device init failed for hdac device\\n\");\n\t\treturn codec;\n\t}\n\n\tcodec->core.type = HDA_DEV_ASOC;\n\n\tret = snd_hdac_device_register(&codec->core);\n\tif (ret) {\n\t\tdev_err(bus->dev, \"failed to register hdac device\\n\");\n\t\tput_device(&codec->core.dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn codec;\n}\n\n \nstatic int probe_codec(struct hdac_bus *bus, int addr)\n{\n\tunsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |\n\t\t(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;\n\tunsigned int res = -1;\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct hdac_hda_priv *hda_codec;\n#endif\n\tstruct hda_codec *codec;\n\n\tmutex_lock(&bus->cmd_mutex);\n\tsnd_hdac_bus_send_cmd(bus, cmd);\n\tsnd_hdac_bus_get_response(bus, addr, &res);\n\tmutex_unlock(&bus->cmd_mutex);\n\tif (res == -1)\n\t\treturn -EIO;\n\tdev_dbg(bus->dev, \"codec #%d probed OK: %x\\n\", addr, res);\n\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n\thda_codec = devm_kzalloc(&skl->pci->dev, sizeof(*hda_codec),\n\t\t\t\t GFP_KERNEL);\n\tif (!hda_codec)\n\t\treturn -ENOMEM;\n\n\tcodec = skl_codec_device_init(bus, addr);\n\tif (IS_ERR(codec))\n\t\treturn PTR_ERR(codec);\n\n\thda_codec->codec = codec;\n\tdev_set_drvdata(&codec->core.dev, hda_codec);\n\n\t \n\tif ((res & 0xFFFF0000) != IDISP_INTEL_VENDOR_ID) {\n\t\tcodec->core.type = HDA_DEV_LEGACY;\n\t\tload_codec_module(hda_codec->codec);\n\t}\n\treturn 0;\n#else\n\tcodec = skl_codec_device_init(bus, addr);\n\treturn PTR_ERR_OR_ZERO(codec);\n#endif  \n}\n\n \nstatic void skl_codec_create(struct hdac_bus *bus)\n{\n\tint c, max_slots;\n\n\tmax_slots = HDA_MAX_CODECS;\n\n\t \n\tfor (c = 0; c < max_slots; c++) {\n\t\tif ((bus->codec_mask & (1 << c))) {\n\t\t\tif (probe_codec(bus, c) < 0) {\n\t\t\t\t \n\t\t\t\tdev_warn(bus->dev,\n\t\t\t\t\t \"Codec #%d probe error; disabling it...\\n\", c);\n\t\t\t\tbus->codec_mask &= ~(1 << c);\n\t\t\t\t \n\t\t\t\tsnd_hdac_bus_stop_chip(bus);\n\t\t\t\tskl_init_chip(bus, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int skl_i915_init(struct hdac_bus *bus)\n{\n\tint err;\n\n\t \n\terr = snd_hdac_i915_init(bus);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, true);\n\n\treturn 0;\n}\n\nstatic void skl_probe_work(struct work_struct *work)\n{\n\tstruct skl_dev *skl = container_of(work, struct skl_dev, probe_work);\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct hdac_ext_link *hlink;\n\tint err;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_HDAC_HDMI)) {\n\t\terr = skl_i915_init(bus);\n\t\tif (err < 0)\n\t\t\treturn;\n\t}\n\n\tskl_init_pci(skl);\n\tskl_dum_set(bus);\n\n\terr = skl_init_chip(bus, true);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"Init chip failed with err: %d\\n\", err);\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (!bus->codec_mask)\n\t\tdev_info(bus->dev, \"no hda codecs found!\\n\");\n\n\t \n\tskl_codec_create(bus);\n\n\t \n\terr = skl_platform_register(bus->dev);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"platform register failed: %d\\n\", err);\n\t\tgoto out_err;\n\t}\n\n\terr = skl_machine_device_register(skl);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"machine register failed: %d\\n\", err);\n\t\tgoto out_err;\n\t}\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_HDAC_HDMI))\n\t\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\n\t \n\tpm_runtime_put_noidle(bus->dev);\n\tpm_runtime_allow(bus->dev);\n\tskl->init_done = 1;\n\n\treturn;\n\nout_err:\n\tif (IS_ENABLED(CONFIG_SND_SOC_HDAC_HDMI))\n\t\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n}\n\n \nstatic int skl_create(struct pci_dev *pci,\n\t\t      struct skl_dev **rskl)\n{\n\tstruct hdac_ext_bus_ops *ext_ops = NULL;\n\tstruct skl_dev *skl;\n\tstruct hdac_bus *bus;\n\tstruct hda_bus *hbus;\n\tint err;\n\n\t*rskl = NULL;\n\n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tskl = devm_kzalloc(&pci->dev, sizeof(*skl), GFP_KERNEL);\n\tif (!skl) {\n\t\tpci_disable_device(pci);\n\t\treturn -ENOMEM;\n\t}\n\n\thbus = skl_to_hbus(skl);\n\tbus = skl_to_bus(skl);\n\n\tINIT_LIST_HEAD(&skl->ppl_list);\n\tINIT_LIST_HEAD(&skl->bind_list);\n\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n\text_ops = snd_soc_hdac_hda_get_ops();\n#endif\n\tsnd_hdac_ext_bus_init(bus, &pci->dev, NULL, ext_ops);\n\tbus->use_posbuf = 1;\n\tskl->pci = pci;\n\tINIT_WORK(&skl->probe_work, skl_probe_work);\n\tbus->bdl_pos_adj = 0;\n\n\tmutex_init(&hbus->prepare_mutex);\n\thbus->pci = pci;\n\thbus->mixer_assigned = -1;\n\thbus->modelname = \"sklbus\";\n\n\t*rskl = skl;\n\n\treturn 0;\n}\n\nstatic int skl_first_init(struct hdac_bus *bus)\n{\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct pci_dev *pci = skl->pci;\n\tint err;\n\tunsigned short gcap;\n\tint cp_streams, pb_streams, start_idx;\n\n\terr = pci_request_regions(pci, \"Skylake HD audio\");\n\tif (err < 0)\n\t\treturn err;\n\n\tbus->addr = pci_resource_start(pci, 0);\n\tbus->remap_addr = pci_ioremap_bar(pci, 0);\n\tif (bus->remap_addr == NULL) {\n\t\tdev_err(bus->dev, \"ioremap error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tsnd_hdac_bus_parse_capabilities(bus);\n\n\t \n\tif (!bus->ppcap) {\n\t\tdev_err(bus->dev, \"bus ppcap not set, HDAudio or DSP not present?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (skl_acquire_irq(bus, 0) < 0)\n\t\treturn -EBUSY;\n\n\tpci_set_master(pci);\n\tsynchronize_irq(bus->irq);\n\n\tgcap = snd_hdac_chip_readw(bus, GCAP);\n\tdev_dbg(bus->dev, \"chipset global capabilities = 0x%x\\n\", gcap);\n\n\t \n\tcp_streams = (gcap >> 8) & 0x0f;\n\tpb_streams = (gcap >> 12) & 0x0f;\n\n\tif (!pb_streams && !cp_streams) {\n\t\tdev_err(bus->dev, \"no streams found in GCAP definitions?\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbus->num_streams = cp_streams + pb_streams;\n\n\t \n\tif (dma_set_mask_and_coherent(bus->dev, DMA_BIT_MASK(64)))\n\t\tdma_set_mask_and_coherent(bus->dev, DMA_BIT_MASK(32));\n\tdma_set_max_seg_size(bus->dev, UINT_MAX);\n\n\t \n\tsnd_hdac_ext_stream_init_all\n\t\t(bus, 0, cp_streams, SNDRV_PCM_STREAM_CAPTURE);\n\tstart_idx = cp_streams;\n\tsnd_hdac_ext_stream_init_all\n\t\t(bus, start_idx, pb_streams, SNDRV_PCM_STREAM_PLAYBACK);\n\n\terr = snd_hdac_bus_alloc_stream_pages(bus);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int skl_probe(struct pci_dev *pci,\n\t\t     const struct pci_device_id *pci_id)\n{\n\tstruct skl_dev *skl;\n\tstruct hdac_bus *bus = NULL;\n\tint err;\n\n\tswitch (skl_pci_binding) {\n\tcase SND_SKL_PCI_BIND_AUTO:\n\t\terr = snd_intel_dsp_driver_probe(pci);\n\t\tif (err != SND_INTEL_DSP_DRIVER_ANY &&\n\t\t    err != SND_INTEL_DSP_DRIVER_SST)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase SND_SKL_PCI_BIND_LEGACY:\n\t\tdev_info(&pci->dev, \"Module parameter forced binding with HDAudio legacy, aborting probe\\n\");\n\t\treturn -ENODEV;\n\tcase SND_SKL_PCI_BIND_ASOC:\n\t\tdev_info(&pci->dev, \"Module parameter forced binding with SKL driver, bypassed detection logic\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pci->dev, \"invalid value for skl_pci_binding module parameter, ignored\\n\");\n\t\tbreak;\n\t}\n\n\t \n\terr = skl_create(pci, &skl);\n\tif (err < 0)\n\t\treturn err;\n\n\tbus = skl_to_bus(skl);\n\n\terr = skl_first_init(bus);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"skl_first_init failed with err: %d\\n\", err);\n\t\tgoto out_free;\n\t}\n\n\tskl->pci_id = pci->device;\n\n\tdevice_disable_async_suspend(bus->dev);\n\n\tskl->nhlt = intel_nhlt_init(bus->dev);\n\n\tif (skl->nhlt == NULL) {\n#if !IS_ENABLED(CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC)\n\t\tdev_err(bus->dev, \"no nhlt info found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_free;\n#else\n\t\tdev_warn(bus->dev, \"no nhlt info found, continuing to try to enable HDAudio codec\\n\");\n#endif\n\t} else {\n\n\t\terr = skl_nhlt_create_sysfs(skl);\n\t\tif (err < 0) {\n\t\t\tdev_err(bus->dev, \"skl_nhlt_create_sysfs failed with err: %d\\n\", err);\n\t\t\tgoto out_nhlt_free;\n\t\t}\n\n\t\tskl_nhlt_update_topology_bin(skl);\n\n\t\t \n\t\terr = skl_clock_device_register(skl);\n\t\tif (err < 0) {\n\t\t\tdev_err(bus->dev, \"skl_clock_device_register failed with err: %d\\n\", err);\n\t\t\tgoto out_clk_free;\n\t\t}\n\t}\n\n\tpci_set_drvdata(skl->pci, bus);\n\n\n\terr = skl_find_machine(skl, (void *)pci_id->driver_data);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"skl_find_machine failed with err: %d\\n\", err);\n\t\tgoto out_nhlt_free;\n\t}\n\n\terr = skl_init_dsp(skl);\n\tif (err < 0) {\n\t\tdev_dbg(bus->dev, \"error failed to register dsp\\n\");\n\t\tgoto out_nhlt_free;\n\t}\n\tskl->enable_miscbdcge = skl_enable_miscbdcge;\n\tskl->clock_power_gating = skl_clock_power_gating;\n\n\tif (bus->mlcap)\n\t\tsnd_hdac_ext_bus_get_ml_capabilities(bus);\n\n\t \n\terr = skl_dmic_device_register(skl);\n\tif (err < 0) {\n\t\tdev_err(bus->dev, \"skl_dmic_device_register failed with err: %d\\n\", err);\n\t\tgoto out_dsp_free;\n\t}\n\n\tschedule_work(&skl->probe_work);\n\n\treturn 0;\n\nout_dsp_free:\n\tskl_free_dsp(skl);\nout_clk_free:\n\tskl_clock_device_unregister(skl);\nout_nhlt_free:\n\tif (skl->nhlt)\n\t\tintel_nhlt_free(skl->nhlt);\nout_free:\n\tskl_free(bus);\n\n\treturn err;\n}\n\nstatic void skl_shutdown(struct pci_dev *pci)\n{\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct hdac_stream *s;\n\tstruct hdac_ext_stream *stream;\n\tstruct skl_dev *skl;\n\n\tif (!bus)\n\t\treturn;\n\n\tskl = bus_to_skl(bus);\n\n\tif (!skl->init_done)\n\t\treturn;\n\n\tsnd_hdac_stop_streams(bus);\n\tsnd_hdac_ext_bus_link_power_down_all(bus);\n\tskl_dsp_sleep(skl->dsp);\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tstream = stream_to_hdac_ext_stream(s);\n\t\tsnd_hdac_ext_stream_decouple(bus, stream, false);\n\t}\n\n\tsnd_hdac_bus_stop_chip(bus);\n}\n\nstatic void skl_remove(struct pci_dev *pci)\n{\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tcancel_work_sync(&skl->probe_work);\n\n\tpm_runtime_get_noresume(&pci->dev);\n\n\t \n\tsnd_hdac_ext_bus_device_remove(bus);\n\n\tskl_platform_unregister(&pci->dev);\n\tskl_free_dsp(skl);\n\tskl_machine_device_unregister(skl);\n\tskl_dmic_device_unregister(skl);\n\tskl_clock_device_unregister(skl);\n\tskl_nhlt_remove_sysfs(skl);\n\tif (skl->nhlt)\n\t\tintel_nhlt_free(skl->nhlt);\n\tskl_free(bus);\n}\n\n \nstatic const struct pci_device_id skl_ids[] = {\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_SKL)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_SKL_LP, &snd_soc_acpi_intel_skl_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_APL)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_APL, &snd_soc_acpi_intel_bxt_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_KBL)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL_LP, &snd_soc_acpi_intel_kbl_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_GLK)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_GML, &snd_soc_acpi_intel_glk_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_CNL_LP, &snd_soc_acpi_intel_cnl_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CFL)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_CNL_H, &snd_soc_acpi_intel_cnl_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CML_LP)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_LP, &snd_soc_acpi_intel_cnl_machines) },\n#endif\n#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CML_H)\n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_H, &snd_soc_acpi_intel_cnl_machines) },\n#endif\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, skl_ids);\n\n \nstatic struct pci_driver skl_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = skl_ids,\n\t.probe = skl_probe,\n\t.remove = skl_remove,\n\t.shutdown = skl_shutdown,\n\t.driver = {\n\t\t.pm = &skl_pm,\n\t},\n};\nmodule_pci_driver(skl_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Skylake ASoC HDA driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}