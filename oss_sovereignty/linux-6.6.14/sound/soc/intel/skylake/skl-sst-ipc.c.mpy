{
  "module_name": "skl-sst-ipc.c",
  "hash_id": "82ee885fca57a2f1632e11d0e6a8cb50faca749004c5de315395f05e199118ca",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-sst-ipc.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"skl.h\"\n#include \"skl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n#include \"sound/hdaudio_ext.h\"\n\n\n#define IPC_IXC_STATUS_BITS\t\t24\n\n \n#define IPC_GLB_TYPE_SHIFT\t\t24\n#define IPC_GLB_TYPE_MASK\t\t(0xf << IPC_GLB_TYPE_SHIFT)\n#define IPC_GLB_TYPE(x)\t\t\t((x) << IPC_GLB_TYPE_SHIFT)\n\n \n#define IPC_GLB_REPLY_STATUS_SHIFT\t24\n#define IPC_GLB_REPLY_STATUS_MASK\t((0x1 << IPC_GLB_REPLY_STATUS_SHIFT) - 1)\n#define IPC_GLB_REPLY_STATUS(x)\t\t((x) << IPC_GLB_REPLY_STATUS_SHIFT)\n\n#define IPC_GLB_REPLY_TYPE_SHIFT\t29\n#define IPC_GLB_REPLY_TYPE_MASK\t\t0x1F\n#define IPC_GLB_REPLY_TYPE(x)\t\t(((x) >> IPC_GLB_REPLY_TYPE_SHIFT) \\\n\t\t\t\t\t& IPC_GLB_RPLY_TYPE_MASK)\n\n#define IPC_TIMEOUT_MSECS\t\t3000\n\n#define IPC_EMPTY_LIST_SIZE\t\t8\n\n#define IPC_MSG_TARGET_SHIFT\t\t30\n#define IPC_MSG_TARGET_MASK\t\t0x1\n#define IPC_MSG_TARGET(x)\t\t(((x) & IPC_MSG_TARGET_MASK) \\\n\t\t\t\t\t<< IPC_MSG_TARGET_SHIFT)\n\n#define IPC_MSG_DIR_SHIFT\t\t29\n#define IPC_MSG_DIR_MASK\t\t0x1\n#define IPC_MSG_DIR(x)\t\t\t(((x) & IPC_MSG_DIR_MASK) \\\n\t\t\t\t\t<< IPC_MSG_DIR_SHIFT)\n \n#define IPC_GLB_NOTIFY_TYPE_SHIFT\t16\n#define IPC_GLB_NOTIFY_TYPE_MASK\t0xFF\n#define IPC_GLB_NOTIFY_TYPE(x)\t\t(((x) >> IPC_GLB_NOTIFY_TYPE_SHIFT) \\\n\t\t\t\t\t& IPC_GLB_NOTIFY_TYPE_MASK)\n\n#define IPC_GLB_NOTIFY_MSG_TYPE_SHIFT\t24\n#define IPC_GLB_NOTIFY_MSG_TYPE_MASK\t0x1F\n#define IPC_GLB_NOTIFY_MSG_TYPE(x)\t(((x) >> IPC_GLB_NOTIFY_MSG_TYPE_SHIFT)\t\\\n\t\t\t\t\t\t& IPC_GLB_NOTIFY_MSG_TYPE_MASK)\n\n#define IPC_GLB_NOTIFY_RSP_SHIFT\t29\n#define IPC_GLB_NOTIFY_RSP_MASK\t\t0x1\n#define IPC_GLB_NOTIFY_RSP_TYPE(x)\t(((x) >> IPC_GLB_NOTIFY_RSP_SHIFT) \\\n\t\t\t\t\t& IPC_GLB_NOTIFY_RSP_MASK)\n\n \n\n \n#define IPC_PPL_MEM_SIZE_SHIFT\t\t0\n#define IPC_PPL_MEM_SIZE_MASK\t\t0x7FF\n#define IPC_PPL_MEM_SIZE(x)\t\t(((x) & IPC_PPL_MEM_SIZE_MASK) \\\n\t\t\t\t\t<< IPC_PPL_MEM_SIZE_SHIFT)\n\n#define IPC_PPL_TYPE_SHIFT\t\t11\n#define IPC_PPL_TYPE_MASK\t\t0x1F\n#define IPC_PPL_TYPE(x)\t\t\t(((x) & IPC_PPL_TYPE_MASK) \\\n\t\t\t\t\t<< IPC_PPL_TYPE_SHIFT)\n\n#define IPC_INSTANCE_ID_SHIFT\t\t16\n#define IPC_INSTANCE_ID_MASK\t\t0xFF\n#define IPC_INSTANCE_ID(x)\t\t(((x) & IPC_INSTANCE_ID_MASK) \\\n\t\t\t\t\t<< IPC_INSTANCE_ID_SHIFT)\n\n#define IPC_PPL_LP_MODE_SHIFT           0\n#define IPC_PPL_LP_MODE_MASK            0x1\n#define IPC_PPL_LP_MODE(x)              (((x) & IPC_PPL_LP_MODE_MASK) \\\n\t\t\t\t\t<< IPC_PPL_LP_MODE_SHIFT)\n\n \n#define IPC_PPL_STATE_SHIFT\t\t0\n#define IPC_PPL_STATE_MASK\t\t0x1F\n#define IPC_PPL_STATE(x)\t\t(((x) & IPC_PPL_STATE_MASK) \\\n\t\t\t\t\t<< IPC_PPL_STATE_SHIFT)\n\n \n#define IPC_MOD_ID_SHIFT\t\t0\n#define IPC_MOD_ID_MASK\t\t0xFFFF\n#define IPC_MOD_ID(x)\t\t(((x) & IPC_MOD_ID_MASK) \\\n\t\t\t\t\t<< IPC_MOD_ID_SHIFT)\n\n#define IPC_MOD_INSTANCE_ID_SHIFT\t16\n#define IPC_MOD_INSTANCE_ID_MASK\t0xFF\n#define IPC_MOD_INSTANCE_ID(x)\t(((x) & IPC_MOD_INSTANCE_ID_MASK) \\\n\t\t\t\t\t<< IPC_MOD_INSTANCE_ID_SHIFT)\n\n \n#define IPC_PARAM_BLOCK_SIZE_SHIFT\t0\n#define IPC_PARAM_BLOCK_SIZE_MASK\t0xFFFF\n#define IPC_PARAM_BLOCK_SIZE(x)\t\t(((x) & IPC_PARAM_BLOCK_SIZE_MASK) \\\n\t\t\t\t\t<< IPC_PARAM_BLOCK_SIZE_SHIFT)\n\n#define IPC_PPL_INSTANCE_ID_SHIFT\t16\n#define IPC_PPL_INSTANCE_ID_MASK\t0xFF\n#define IPC_PPL_INSTANCE_ID(x)\t\t(((x) & IPC_PPL_INSTANCE_ID_MASK) \\\n\t\t\t\t\t<< IPC_PPL_INSTANCE_ID_SHIFT)\n\n#define IPC_CORE_ID_SHIFT\t\t24\n#define IPC_CORE_ID_MASK\t\t0x1F\n#define IPC_CORE_ID(x)\t\t\t(((x) & IPC_CORE_ID_MASK) \\\n\t\t\t\t\t<< IPC_CORE_ID_SHIFT)\n\n#define IPC_DOMAIN_SHIFT                28\n#define IPC_DOMAIN_MASK                 0x1\n#define IPC_DOMAIN(x)                   (((x) & IPC_DOMAIN_MASK) \\\n\t\t\t\t\t<< IPC_DOMAIN_SHIFT)\n\n \n#define IPC_DST_MOD_ID_SHIFT\t\t0\n#define IPC_DST_MOD_ID(x)\t\t(((x) & IPC_MOD_ID_MASK) \\\n\t\t\t\t\t<< IPC_DST_MOD_ID_SHIFT)\n\n#define IPC_DST_MOD_INSTANCE_ID_SHIFT 16\n#define IPC_DST_MOD_INSTANCE_ID(x)\t(((x) & IPC_MOD_INSTANCE_ID_MASK) \\\n\t\t\t\t\t<< IPC_DST_MOD_INSTANCE_ID_SHIFT)\n\n#define IPC_DST_QUEUE_SHIFT\t\t24\n#define IPC_DST_QUEUE_MASK\t\t0x7\n#define IPC_DST_QUEUE(x)\t\t(((x) & IPC_DST_QUEUE_MASK) \\\n\t\t\t\t\t<< IPC_DST_QUEUE_SHIFT)\n\n#define IPC_SRC_QUEUE_SHIFT\t\t27\n#define IPC_SRC_QUEUE_MASK\t\t0x7\n#define IPC_SRC_QUEUE(x)\t\t(((x) & IPC_SRC_QUEUE_MASK) \\\n\t\t\t\t\t<< IPC_SRC_QUEUE_SHIFT)\n \n#define IPC_LOAD_MODULE_SHIFT\t\t0\n#define IPC_LOAD_MODULE_MASK\t\t0xFF\n#define IPC_LOAD_MODULE_CNT(x)\t\t(((x) & IPC_LOAD_MODULE_MASK) \\\n\t\t\t\t\t<< IPC_LOAD_MODULE_SHIFT)\n\n \n#define IPC_DMA_ID_SHIFT\t\t0\n#define IPC_DMA_ID_MASK\t\t\t0x1F\n#define IPC_DMA_ID(x)\t\t\t(((x) & IPC_DMA_ID_MASK) \\\n\t\t\t\t\t<< IPC_DMA_ID_SHIFT)\n \n#define IPC_DATA_OFFSET_SZ_SHIFT\t0\n#define IPC_DATA_OFFSET_SZ_MASK\t\t0xFFFFF\n#define IPC_DATA_OFFSET_SZ(x)\t\t(((x) & IPC_DATA_OFFSET_SZ_MASK) \\\n\t\t\t\t\t<< IPC_DATA_OFFSET_SZ_SHIFT)\n#define IPC_DATA_OFFSET_SZ_CLEAR\t~(IPC_DATA_OFFSET_SZ_MASK \\\n\t\t\t\t\t  << IPC_DATA_OFFSET_SZ_SHIFT)\n\n#define IPC_LARGE_PARAM_ID_SHIFT\t20\n#define IPC_LARGE_PARAM_ID_MASK\t\t0xFF\n#define IPC_LARGE_PARAM_ID(x)\t\t(((x) & IPC_LARGE_PARAM_ID_MASK) \\\n\t\t\t\t\t<< IPC_LARGE_PARAM_ID_SHIFT)\n\n#define IPC_FINAL_BLOCK_SHIFT\t\t28\n#define IPC_FINAL_BLOCK_MASK\t\t0x1\n#define IPC_FINAL_BLOCK(x)\t\t(((x) & IPC_FINAL_BLOCK_MASK) \\\n\t\t\t\t\t<< IPC_FINAL_BLOCK_SHIFT)\n\n#define IPC_INITIAL_BLOCK_SHIFT\t\t29\n#define IPC_INITIAL_BLOCK_MASK\t\t0x1\n#define IPC_INITIAL_BLOCK(x)\t\t(((x) & IPC_INITIAL_BLOCK_MASK) \\\n\t\t\t\t\t<< IPC_INITIAL_BLOCK_SHIFT)\n#define IPC_INITIAL_BLOCK_CLEAR\t\t~(IPC_INITIAL_BLOCK_MASK \\\n\t\t\t\t\t  << IPC_INITIAL_BLOCK_SHIFT)\n \n#define IPC_D0IX_WAKE_SHIFT\t\t0\n#define IPC_D0IX_WAKE_MASK\t\t0x1\n#define IPC_D0IX_WAKE(x)\t\t(((x) & IPC_D0IX_WAKE_MASK) \\\n\t\t\t\t\t<< IPC_D0IX_WAKE_SHIFT)\n\n#define IPC_D0IX_STREAMING_SHIFT\t1\n#define IPC_D0IX_STREAMING_MASK\t\t0x1\n#define IPC_D0IX_STREAMING(x)\t\t(((x) & IPC_D0IX_STREAMING_MASK) \\\n\t\t\t\t\t<< IPC_D0IX_STREAMING_SHIFT)\n\n\nenum skl_ipc_msg_target {\n\tIPC_FW_GEN_MSG = 0,\n\tIPC_MOD_MSG = 1\n};\n\nenum skl_ipc_msg_direction {\n\tIPC_MSG_REQUEST = 0,\n\tIPC_MSG_REPLY = 1\n};\n\n \nenum skl_ipc_glb_type {\n\tIPC_GLB_GET_FW_VERSION = 0,  \n\tIPC_GLB_LOAD_MULTIPLE_MODS = 15,\n\tIPC_GLB_UNLOAD_MULTIPLE_MODS = 16,\n\tIPC_GLB_CREATE_PPL = 17,\n\tIPC_GLB_DELETE_PPL = 18,\n\tIPC_GLB_SET_PPL_STATE = 19,\n\tIPC_GLB_GET_PPL_STATE = 20,\n\tIPC_GLB_GET_PPL_CONTEXT_SIZE = 21,\n\tIPC_GLB_SAVE_PPL = 22,\n\tIPC_GLB_RESTORE_PPL = 23,\n\tIPC_GLB_LOAD_LIBRARY = 24,\n\tIPC_GLB_NOTIFY = 26,\n\tIPC_GLB_MAX_IPC_MSG_NUMBER = 31  \n};\n\nenum skl_ipc_glb_reply {\n\tIPC_GLB_REPLY_SUCCESS = 0,\n\n\tIPC_GLB_REPLY_UNKNOWN_MSG_TYPE = 1,\n\tIPC_GLB_REPLY_ERROR_INVALID_PARAM = 2,\n\n\tIPC_GLB_REPLY_BUSY = 3,\n\tIPC_GLB_REPLY_PENDING = 4,\n\tIPC_GLB_REPLY_FAILURE = 5,\n\tIPC_GLB_REPLY_INVALID_REQUEST = 6,\n\n\tIPC_GLB_REPLY_OUT_OF_MEMORY = 7,\n\tIPC_GLB_REPLY_OUT_OF_MIPS = 8,\n\n\tIPC_GLB_REPLY_INVALID_RESOURCE_ID = 9,\n\tIPC_GLB_REPLY_INVALID_RESOURCE_STATE = 10,\n\n\tIPC_GLB_REPLY_MOD_MGMT_ERROR = 100,\n\tIPC_GLB_REPLY_MOD_LOAD_CL_FAILED = 101,\n\tIPC_GLB_REPLY_MOD_LOAD_INVALID_HASH = 102,\n\n\tIPC_GLB_REPLY_MOD_UNLOAD_INST_EXIST = 103,\n\tIPC_GLB_REPLY_MOD_NOT_INITIALIZED = 104,\n\n\tIPC_GLB_REPLY_INVALID_CONFIG_PARAM_ID = 120,\n\tIPC_GLB_REPLY_INVALID_CONFIG_DATA_LEN = 121,\n\tIPC_GLB_REPLY_GATEWAY_NOT_INITIALIZED = 140,\n\tIPC_GLB_REPLY_GATEWAY_NOT_EXIST = 141,\n\tIPC_GLB_REPLY_SCLK_ALREADY_RUNNING = 150,\n\tIPC_GLB_REPLY_MCLK_ALREADY_RUNNING = 151,\n\n\tIPC_GLB_REPLY_PPL_NOT_INITIALIZED = 160,\n\tIPC_GLB_REPLY_PPL_NOT_EXIST = 161,\n\tIPC_GLB_REPLY_PPL_SAVE_FAILED = 162,\n\tIPC_GLB_REPLY_PPL_RESTORE_FAILED = 163,\n\n\tIPC_MAX_STATUS = ((1<<IPC_IXC_STATUS_BITS)-1)\n};\n\nenum skl_ipc_notification_type {\n\tIPC_GLB_NOTIFY_GLITCH = 0,\n\tIPC_GLB_NOTIFY_OVERRUN = 1,\n\tIPC_GLB_NOTIFY_UNDERRUN = 2,\n\tIPC_GLB_NOTIFY_END_STREAM = 3,\n\tIPC_GLB_NOTIFY_PHRASE_DETECTED = 4,\n\tIPC_GLB_NOTIFY_RESOURCE_EVENT = 5,\n\tIPC_GLB_NOTIFY_LOG_BUFFER_STATUS = 6,\n\tIPC_GLB_NOTIFY_TIMESTAMP_CAPTURED = 7,\n\tIPC_GLB_NOTIFY_FW_READY = 8\n};\n\n \nenum skl_ipc_module_msg {\n\tIPC_MOD_INIT_INSTANCE = 0,\n\tIPC_MOD_CONFIG_GET = 1,\n\tIPC_MOD_CONFIG_SET = 2,\n\tIPC_MOD_LARGE_CONFIG_GET = 3,\n\tIPC_MOD_LARGE_CONFIG_SET = 4,\n\tIPC_MOD_BIND = 5,\n\tIPC_MOD_UNBIND = 6,\n\tIPC_MOD_SET_DX = 7,\n\tIPC_MOD_SET_D0IX = 8\n};\n\nvoid skl_ipc_tx_data_copy(struct ipc_message *msg, char *tx_data,\n\t\tsize_t tx_size)\n{\n\tif (tx_size)\n\t\tmemcpy(msg->tx.data, tx_data, tx_size);\n}\n\nstatic bool skl_ipc_is_dsp_busy(struct sst_dsp *dsp)\n{\n\tu32 hipci;\n\n\thipci = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCI);\n\treturn (hipci & SKL_ADSP_REG_HIPCI_BUSY);\n}\n\n \nstatic void skl_ipc_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)\n{\n\tstruct skl_ipc_header *header = (struct skl_ipc_header *)(&msg->tx.header);\n\n\tif (msg->tx.size)\n\t\tsst_dsp_outbox_write(ipc->dsp, msg->tx.data, msg->tx.size);\n\tsst_dsp_shim_write_unlocked(ipc->dsp, SKL_ADSP_REG_HIPCIE,\n\t\t\t\t\t\theader->extension);\n\tsst_dsp_shim_write_unlocked(ipc->dsp, SKL_ADSP_REG_HIPCI,\n\t\theader->primary | SKL_ADSP_REG_HIPCI_BUSY);\n}\n\nint skl_ipc_check_D0i0(struct sst_dsp *dsp, bool state)\n{\n\tint ret;\n\n\t \n\tif (!dsp->fw_ops.set_state_D0i0)\n\t\treturn 0;\n\n\t \n\tif (state)\n\t\tret = dsp->fw_ops.set_state_D0i0(dsp);\n\telse\n\t\tret = dsp->fw_ops.set_state_D0i3(dsp);\n\n\treturn ret;\n}\n\nstatic struct ipc_message *skl_ipc_reply_get_msg(struct sst_generic_ipc *ipc,\n\t\t\t\tu64 ipc_header)\n{\n\tstruct ipc_message *msg =  NULL;\n\tstruct skl_ipc_header *header = (struct skl_ipc_header *)(&ipc_header);\n\n\tif (list_empty(&ipc->rx_list)) {\n\t\tdev_err(ipc->dev, \"ipc: rx list is empty but received 0x%x\\n\",\n\t\t\theader->primary);\n\t\tgoto out;\n\t}\n\n\tmsg = list_first_entry(&ipc->rx_list, struct ipc_message, list);\n\n\tlist_del(&msg->list);\nout:\n\treturn msg;\n\n}\n\nint skl_ipc_process_notification(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_header header)\n{\n\tstruct skl_dev *skl = container_of(ipc, struct skl_dev, ipc);\n\n\tif (IPC_GLB_NOTIFY_MSG_TYPE(header.primary)) {\n\t\tswitch (IPC_GLB_NOTIFY_TYPE(header.primary)) {\n\n\t\tcase IPC_GLB_NOTIFY_UNDERRUN:\n\t\t\tdev_err(ipc->dev, \"FW Underrun %x\\n\", header.primary);\n\t\t\tbreak;\n\n\t\tcase IPC_GLB_NOTIFY_RESOURCE_EVENT:\n\t\t\tdev_err(ipc->dev, \"MCPS Budget Violation: %x\\n\",\n\t\t\t\t\t\theader.primary);\n\t\t\tbreak;\n\n\t\tcase IPC_GLB_NOTIFY_FW_READY:\n\t\t\tskl->boot_complete = true;\n\t\t\twake_up(&skl->boot_wait);\n\t\t\tbreak;\n\n\t\tcase IPC_GLB_NOTIFY_PHRASE_DETECTED:\n\t\t\tdev_dbg(ipc->dev, \"***** Phrase Detected **********\\n\");\n\n\t\t\t \n\t\t\tskl->enable_miscbdcge(ipc->dev, false);\n\t\t\tskl->miscbdcg_disabled = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(ipc->dev, \"ipc: Unhandled error msg=%x\\n\",\n\t\t\t\t\t\theader.primary);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct skl_ipc_err_map {\n\tconst char *msg;\n\tenum skl_ipc_glb_reply reply;\n\tint err;\n};\n\nstatic struct skl_ipc_err_map skl_err_map[] = {\n\t{\"DSP out of memory\", IPC_GLB_REPLY_OUT_OF_MEMORY, -ENOMEM},\n\t{\"DSP busy\", IPC_GLB_REPLY_BUSY, -EBUSY},\n\t{\"SCLK already running\", IPC_GLB_REPLY_SCLK_ALREADY_RUNNING,\n\t\t\tIPC_GLB_REPLY_SCLK_ALREADY_RUNNING},\n\t{\"MCLK already running\", IPC_GLB_REPLY_MCLK_ALREADY_RUNNING,\n\t\t\tIPC_GLB_REPLY_MCLK_ALREADY_RUNNING},\n};\n\nstatic int skl_ipc_set_reply_error_code(struct sst_generic_ipc *ipc, u32 reply)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(skl_err_map); i++) {\n\t\tif (skl_err_map[i].reply == reply)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(skl_err_map)) {\n\t\tdev_err(ipc->dev, \"ipc FW reply: %d FW Error Code: %u\\n\",\n\t\t\t\treply,\n\t\t\t\tipc->dsp->fw_ops.get_fw_errcode(ipc->dsp));\n\t\treturn -EINVAL;\n\t}\n\n\tif (skl_err_map[i].err < 0)\n\t\tdev_err(ipc->dev, \"ipc FW reply: %s FW Error Code: %u\\n\",\n\t\t\t\tskl_err_map[i].msg,\n\t\t\t\tipc->dsp->fw_ops.get_fw_errcode(ipc->dsp));\n\telse\n\t\tdev_info(ipc->dev, \"ipc FW reply: %s FW Error Code: %u\\n\",\n\t\t\t\tskl_err_map[i].msg,\n\t\t\t\tipc->dsp->fw_ops.get_fw_errcode(ipc->dsp));\n\n\treturn skl_err_map[i].err;\n}\n\nvoid skl_ipc_process_reply(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_header header)\n{\n\tstruct ipc_message *msg;\n\tu32 reply = header.primary & IPC_GLB_REPLY_STATUS_MASK;\n\tu64 *ipc_header = (u64 *)(&header);\n\tstruct skl_dev *skl = container_of(ipc, struct skl_dev, ipc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipc->dsp->spinlock, flags);\n\tmsg = skl_ipc_reply_get_msg(ipc, *ipc_header);\n\tspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\n\tif (msg == NULL) {\n\t\tdev_dbg(ipc->dev, \"ipc: rx list is empty\\n\");\n\t\treturn;\n\t}\n\n\tmsg->rx.header = *ipc_header;\n\t \n\tif (reply == IPC_GLB_REPLY_SUCCESS) {\n\t\tdev_dbg(ipc->dev, \"ipc FW reply %x: success\\n\", header.primary);\n\t\t \n\t\tsst_dsp_inbox_read(ipc->dsp, msg->rx.data, msg->rx.size);\n\t\tswitch (IPC_GLB_NOTIFY_MSG_TYPE(header.primary)) {\n\t\tcase IPC_GLB_LOAD_MULTIPLE_MODS:\n\t\tcase IPC_GLB_LOAD_LIBRARY:\n\t\t\tskl->mod_load_complete = true;\n\t\t\tskl->mod_load_status = true;\n\t\t\twake_up(&skl->mod_load_wait);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\tmsg->errno = skl_ipc_set_reply_error_code(ipc, reply);\n\t\tswitch (IPC_GLB_NOTIFY_MSG_TYPE(header.primary)) {\n\t\tcase IPC_GLB_LOAD_MULTIPLE_MODS:\n\t\tcase IPC_GLB_LOAD_LIBRARY:\n\t\t\tskl->mod_load_complete = true;\n\t\t\tskl->mod_load_status = false;\n\t\t\twake_up(&skl->mod_load_wait);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ipc->dsp->spinlock, flags);\n\tsst_ipc_tx_msg_reply_complete(ipc, msg);\n\tspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\n}\n\nirqreturn_t skl_dsp_irq_thread_handler(int irq, void *context)\n{\n\tstruct sst_dsp *dsp = context;\n\tstruct skl_dev *skl = dsp->thread_context;\n\tstruct sst_generic_ipc *ipc = &skl->ipc;\n\tstruct skl_ipc_header header = {0};\n\tu32 hipcie, hipct, hipcte;\n\tint ipc_irq = 0;\n\n\tif (dsp->intr_status & SKL_ADSPIS_CL_DMA)\n\t\tskl_cldma_process_intr(dsp);\n\n\t \n\tif (!(dsp->intr_status & SKL_ADSPIS_IPC))\n\t\treturn IRQ_NONE;\n\n\thipcie = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCIE);\n\thipct = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCT);\n\thipcte = sst_dsp_shim_read_unlocked(dsp, SKL_ADSP_REG_HIPCTE);\n\n\t \n\tif (hipcie & SKL_ADSP_REG_HIPCIE_DONE) {\n\t\tsst_dsp_shim_update_bits(dsp, SKL_ADSP_REG_HIPCCTL,\n\t\t\tSKL_ADSP_REG_HIPCCTL_DONE, 0);\n\n\t\t \n\t\tsst_dsp_shim_update_bits_forced(dsp, SKL_ADSP_REG_HIPCIE,\n\t\t\tSKL_ADSP_REG_HIPCIE_DONE, SKL_ADSP_REG_HIPCIE_DONE);\n\n\t\tipc_irq = 1;\n\n\t\t \n\t\tsst_dsp_shim_update_bits(dsp, SKL_ADSP_REG_HIPCCTL,\n\t\t\tSKL_ADSP_REG_HIPCCTL_DONE, SKL_ADSP_REG_HIPCCTL_DONE);\n\t}\n\n\t \n\tif (hipct & SKL_ADSP_REG_HIPCT_BUSY) {\n\t\theader.primary = hipct;\n\t\theader.extension = hipcte;\n\t\tdev_dbg(dsp->dev, \"IPC irq: Firmware respond primary:%x\\n\",\n\t\t\t\t\t\theader.primary);\n\t\tdev_dbg(dsp->dev, \"IPC irq: Firmware respond extension:%x\\n\",\n\t\t\t\t\t\theader.extension);\n\n\t\tif (IPC_GLB_NOTIFY_RSP_TYPE(header.primary)) {\n\t\t\t \n\t\t\tskl_ipc_process_reply(ipc, header);\n\t\t} else {\n\t\t\tdev_dbg(dsp->dev, \"IPC irq: Notification from firmware\\n\");\n\t\t\tskl_ipc_process_notification(ipc, header);\n\t\t}\n\t\t \n\t\tsst_dsp_shim_update_bits_forced(dsp, SKL_ADSP_REG_HIPCT,\n\t\t\tSKL_ADSP_REG_HIPCT_BUSY, SKL_ADSP_REG_HIPCT_BUSY);\n\t\tipc_irq = 1;\n\t}\n\n\tif (ipc_irq == 0)\n\t\treturn IRQ_NONE;\n\n\tskl_ipc_int_enable(dsp);\n\n\t \n\tschedule_work(&ipc->kwork);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid skl_ipc_int_enable(struct sst_dsp *ctx)\n{\n\tsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_ADSPIC,\n\t\t\tSKL_ADSPIC_IPC, SKL_ADSPIC_IPC);\n}\n\nvoid skl_ipc_int_disable(struct sst_dsp *ctx)\n{\n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPIC,\n\t\t\tSKL_ADSPIC_IPC, 0);\n}\n\nvoid skl_ipc_op_int_enable(struct sst_dsp *ctx)\n{\n\t \n\tsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_HIPCCTL,\n\t\tSKL_ADSP_REG_HIPCCTL_DONE, SKL_ADSP_REG_HIPCCTL_DONE);\n\n\t \n\tsst_dsp_shim_update_bits(ctx, SKL_ADSP_REG_HIPCCTL,\n\t\tSKL_ADSP_REG_HIPCCTL_BUSY, SKL_ADSP_REG_HIPCCTL_BUSY);\n}\n\nvoid skl_ipc_op_int_disable(struct sst_dsp *ctx)\n{\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_HIPCCTL,\n\t\t\t\t\tSKL_ADSP_REG_HIPCCTL_DONE, 0);\n\n\t \n\tsst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_HIPCCTL,\n\t\t\t\t\tSKL_ADSP_REG_HIPCCTL_BUSY, 0);\n\n}\n\nbool skl_ipc_int_status(struct sst_dsp *ctx)\n{\n\treturn sst_dsp_shim_read_unlocked(ctx,\n\t\t\tSKL_ADSP_REG_ADSPIS) & SKL_ADSPIS_IPC;\n}\n\nint skl_ipc_init(struct device *dev, struct skl_dev *skl)\n{\n\tstruct sst_generic_ipc *ipc;\n\tint err;\n\n\tipc = &skl->ipc;\n\tipc->dsp = skl->dsp;\n\tipc->dev = dev;\n\n\tipc->tx_data_max_size = SKL_ADSP_W1_SZ;\n\tipc->rx_data_max_size = SKL_ADSP_W0_UP_SZ;\n\n\terr = sst_ipc_init(ipc);\n\tif (err)\n\t\treturn err;\n\n\tipc->ops.tx_msg = skl_ipc_tx_msg;\n\tipc->ops.tx_data_copy = skl_ipc_tx_data_copy;\n\tipc->ops.is_dsp_busy = skl_ipc_is_dsp_busy;\n\n\treturn 0;\n}\n\nvoid skl_ipc_free(struct sst_generic_ipc *ipc)\n{\n\t \n\tsst_dsp_shim_update_bits(ipc->dsp, SKL_ADSP_REG_HIPCCTL,\n\t\tSKL_ADSP_REG_HIPCCTL_DONE, 0);\n\n\t \n\tsst_dsp_shim_update_bits(ipc->dsp, SKL_ADSP_REG_HIPCCTL,\n\t\tSKL_ADSP_REG_HIPCCTL_BUSY, 0);\n\n\tsst_ipc_fini(ipc);\n}\n\nint skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,\n\t\tu16 ppl_mem_size, u8 ppl_type, u8 instance_id, u8 lp_mode)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_CREATE_PPL);\n\theader.primary |= IPC_INSTANCE_ID(instance_id);\n\theader.primary |= IPC_PPL_TYPE(ppl_type);\n\theader.primary |= IPC_PPL_MEM_SIZE(ppl_mem_size);\n\n\theader.extension = IPC_PPL_LP_MODE(lp_mode);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s header=%d\\n\", __func__, header.primary);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: create pipeline fail, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_create_pipeline);\n\nint skl_ipc_delete_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_DELETE_PPL);\n\theader.primary |= IPC_INSTANCE_ID(instance_id);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s header=%d\\n\", __func__, header.primary);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: delete pipeline failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_delete_pipeline);\n\nint skl_ipc_set_pipeline_state(struct sst_generic_ipc *ipc,\n\t\tu8 instance_id, enum skl_ipc_pipeline_state state)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_SET_PPL_STATE);\n\theader.primary |= IPC_INSTANCE_ID(instance_id);\n\theader.primary |= IPC_PPL_STATE(state);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s header=%d\\n\", __func__, header.primary);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: set pipeline state failed, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_set_pipeline_state);\n\nint\nskl_ipc_save_pipeline(struct sst_generic_ipc *ipc, u8 instance_id, int dma_id)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_SAVE_PPL);\n\theader.primary |= IPC_INSTANCE_ID(instance_id);\n\n\theader.extension = IPC_DMA_ID(dma_id);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s header=%d\\n\", __func__, header.primary);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: save pipeline failed, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_save_pipeline);\n\nint skl_ipc_restore_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_RESTORE_PPL);\n\theader.primary |= IPC_INSTANCE_ID(instance_id);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s header=%d\\n\", __func__, header.primary);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: restore  pipeline failed, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_restore_pipeline);\n\nint skl_ipc_set_dx(struct sst_generic_ipc *ipc, u8 instance_id,\n\t\tu16 module_id, struct skl_ipc_dxstate_info *dx)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request;\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_MOD_SET_DX);\n\theader.primary |= IPC_MOD_INSTANCE_ID(instance_id);\n\theader.primary |= IPC_MOD_ID(module_id);\n\n\trequest.header = *(u64 *)(&header);\n\trequest.data = dx;\n\trequest.size = sizeof(*dx);\n\n\tdev_dbg(ipc->dev, \"In %s primary =%x ext=%x\\n\", __func__,\n\t\t\t header.primary, header.extension);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: set dx failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_set_dx);\n\nint skl_ipc_init_instance(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_init_instance_msg *msg, void *param_data)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request;\n\tint ret;\n\tu32 *buffer = (u32 *)param_data;\n\t  \n\tu16 param_block_size = msg->param_data_size / sizeof(u32);\n\n\tprint_hex_dump_debug(\"Param data:\", DUMP_PREFIX_NONE,\n\t\t16, 4, buffer, param_block_size, false);\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_MOD_INIT_INSTANCE);\n\theader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\n\theader.primary |= IPC_MOD_ID(msg->module_id);\n\n\theader.extension = IPC_CORE_ID(msg->core_id);\n\theader.extension |= IPC_PPL_INSTANCE_ID(msg->ppl_instance_id);\n\theader.extension |= IPC_PARAM_BLOCK_SIZE(param_block_size);\n\theader.extension |= IPC_DOMAIN(msg->domain);\n\n\trequest.header = *(u64 *)(&header);\n\trequest.data = param_data;\n\trequest.size = msg->param_data_size;\n\n\tdev_dbg(ipc->dev, \"In %s primary =%x ext=%x\\n\", __func__,\n\t\t\t header.primary, header.extension);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: init instance failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_init_instance);\n\nint skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_bind_unbind_msg *msg)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tu8 bind_unbind = msg->bind ? IPC_MOD_BIND : IPC_MOD_UNBIND;\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(bind_unbind);\n\theader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\n\theader.primary |= IPC_MOD_ID(msg->module_id);\n\n\theader.extension = IPC_DST_MOD_ID(msg->dst_module_id);\n\theader.extension |= IPC_DST_MOD_INSTANCE_ID(msg->dst_instance_id);\n\theader.extension |= IPC_DST_QUEUE(msg->dst_queue);\n\theader.extension |= IPC_SRC_QUEUE(msg->src_queue);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s hdr=%x ext=%x\\n\", __func__, header.primary,\n\t\t\t header.extension);\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ipc->dev, \"ipc: bind/unbind failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_bind_unbind);\n\n \nint skl_ipc_load_modules(struct sst_generic_ipc *ipc,\n\t\t\t\tu8 module_cnt, void *data)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request;\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_MULTIPLE_MODS);\n\theader.primary |= IPC_LOAD_MODULE_CNT(module_cnt);\n\n\trequest.header = *(u64 *)(&header);\n\trequest.data = data;\n\trequest.size = sizeof(u16) * module_cnt;\n\n\tret = sst_ipc_tx_message_nowait(ipc, request);\n\tif (ret < 0)\n\t\tdev_err(ipc->dev, \"ipc: load modules failed :%d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_load_modules);\n\nint skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,\n\t\t\t\t\t\t\tvoid *data)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request;\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_UNLOAD_MULTIPLE_MODS);\n\theader.primary |= IPC_LOAD_MODULE_CNT(module_cnt);\n\n\trequest.header = *(u64 *)(&header);\n\trequest.data = data;\n\trequest.size = sizeof(u16) * module_cnt;\n\n\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\tif (ret < 0)\n\t\tdev_err(ipc->dev, \"ipc: unload modules failed :%d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_unload_modules);\n\nint skl_ipc_set_large_config(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_large_config_msg *msg, u32 *param)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request;\n\tint ret = 0;\n\tsize_t sz_remaining, tx_size, data_offset;\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_MOD_LARGE_CONFIG_SET);\n\theader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\n\theader.primary |= IPC_MOD_ID(msg->module_id);\n\n\theader.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);\n\theader.extension |= IPC_LARGE_PARAM_ID(msg->large_param_id);\n\theader.extension |= IPC_FINAL_BLOCK(0);\n\theader.extension |= IPC_INITIAL_BLOCK(1);\n\n\tsz_remaining = msg->param_data_size;\n\tdata_offset = 0;\n\twhile (sz_remaining != 0) {\n\t\ttx_size = sz_remaining > SKL_ADSP_W1_SZ\n\t\t\t\t? SKL_ADSP_W1_SZ : sz_remaining;\n\t\tif (tx_size == sz_remaining)\n\t\t\theader.extension |= IPC_FINAL_BLOCK(1);\n\n\t\tdev_dbg(ipc->dev, \"In %s primary=%#x ext=%#x\\n\", __func__,\n\t\t\theader.primary, header.extension);\n\t\tdev_dbg(ipc->dev, \"transmitting offset: %#x, size: %#x\\n\",\n\t\t\t(unsigned)data_offset, (unsigned)tx_size);\n\n\t\trequest.header = *(u64 *)(&header);\n\t\trequest.data = ((char *)param) + data_offset;\n\t\trequest.size = tx_size;\n\t\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ipc->dev,\n\t\t\t\t\"ipc: set large config fail, err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tsz_remaining -= tx_size;\n\t\tdata_offset = msg->param_data_size - sz_remaining;\n\n\t\t \n\t\theader.extension &= IPC_INITIAL_BLOCK_CLEAR;\n\t\theader.extension &= IPC_DATA_OFFSET_SZ_CLEAR;\n\t\t \n\t\theader.extension |= IPC_INITIAL_BLOCK(0);\n\t\theader.extension |= IPC_DATA_OFFSET_SZ(data_offset);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_set_large_config);\n\nint skl_ipc_get_large_config(struct sst_generic_ipc *ipc,\n\t\tstruct skl_ipc_large_config_msg *msg,\n\t\tu32 **payload, size_t *bytes)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request, reply = {0};\n\tunsigned int *buf;\n\tint ret;\n\n\treply.data = kzalloc(SKL_ADSP_W1_SZ, GFP_KERNEL);\n\tif (!reply.data)\n\t\treturn -ENOMEM;\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_MOD_LARGE_CONFIG_GET);\n\theader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\n\theader.primary |= IPC_MOD_ID(msg->module_id);\n\n\theader.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);\n\theader.extension |= IPC_LARGE_PARAM_ID(msg->large_param_id);\n\theader.extension |= IPC_FINAL_BLOCK(1);\n\theader.extension |= IPC_INITIAL_BLOCK(1);\n\n\trequest.header = *(u64 *)&header;\n\trequest.data = *payload;\n\trequest.size = *bytes;\n\treply.size = SKL_ADSP_W1_SZ;\n\n\tret = sst_ipc_tx_message_wait(ipc, request, &reply);\n\tif (ret < 0)\n\t\tdev_err(ipc->dev, \"ipc: get large config fail, err: %d\\n\", ret);\n\n\treply.size = (reply.header >> 32) & IPC_DATA_OFFSET_SZ_MASK;\n\tbuf = krealloc(reply.data, reply.size, GFP_KERNEL);\n\tif (!buf) {\n\t\tkfree(reply.data);\n\t\treturn -ENOMEM;\n\t}\n\t*payload = buf;\n\t*bytes = reply.size;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_get_large_config);\n\nint skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,\n\t\t\t\tu8 dma_id, u8 table_id, bool wait)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret = 0;\n\n\theader.primary = IPC_MSG_TARGET(IPC_FW_GEN_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_GLB_LOAD_LIBRARY);\n\theader.primary |= IPC_MOD_INSTANCE_ID(table_id);\n\theader.primary |= IPC_MOD_ID(dma_id);\n\trequest.header = *(u64 *)(&header);\n\n\tif (wait)\n\t\tret = sst_ipc_tx_message_wait(ipc, request, NULL);\n\telse\n\t\tret = sst_ipc_tx_message_nowait(ipc, request);\n\n\tif (ret < 0)\n\t\tdev_err(ipc->dev, \"ipc: load lib failed\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_sst_ipc_load_library);\n\nint skl_ipc_set_d0ix(struct sst_generic_ipc *ipc, struct skl_ipc_d0ix_msg *msg)\n{\n\tstruct skl_ipc_header header = {0};\n\tstruct sst_ipc_message request = {0};\n\tint ret;\n\n\theader.primary = IPC_MSG_TARGET(IPC_MOD_MSG);\n\theader.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);\n\theader.primary |= IPC_GLB_TYPE(IPC_MOD_SET_D0IX);\n\theader.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);\n\theader.primary |= IPC_MOD_ID(msg->module_id);\n\n\theader.extension = IPC_D0IX_WAKE(msg->wake);\n\theader.extension |= IPC_D0IX_STREAMING(msg->streaming);\n\trequest.header = *(u64 *)(&header);\n\n\tdev_dbg(ipc->dev, \"In %s primary=%x ext=%x\\n\", __func__,\n\t\t\theader.primary,\theader.extension);\n\n\t \n\tret = sst_ipc_tx_message_nopm(ipc, request, NULL);\n\tif (ret < 0)\n\t\tdev_err(ipc->dev, \"ipc: set d0ix failed, err %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(skl_ipc_set_d0ix);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}