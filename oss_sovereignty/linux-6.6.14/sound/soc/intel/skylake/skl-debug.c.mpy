{
  "module_name": "skl-debug.c",
  "hash_id": "7f9ed203ef03222c7e8d5ebc6adfe05c0c593a0d37b2d837ce011f9906511531",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-debug.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/debugfs.h>\n#include <uapi/sound/skl-tplg-interface.h>\n#include \"skl.h\"\n#include \"skl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n#include \"skl-topology.h\"\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n\n#define MOD_BUF\t\tPAGE_SIZE\n#define FW_REG_BUF\tPAGE_SIZE\n#define FW_REG_SIZE\t0x60\n\nstruct skl_debug {\n\tstruct skl_dev *skl;\n\tstruct device *dev;\n\n\tstruct dentry *fs;\n\tstruct dentry *modules;\n\tu8 fw_read_buff[FW_REG_BUF];\n};\n\nstatic ssize_t skl_print_pins(struct skl_module_pin *m_pin, char *buf,\n\t\t\t\tint max_pin, ssize_t size, bool direction)\n{\n\tint i;\n\tssize_t ret = 0;\n\n\tfor (i = 0; i < max_pin; i++) {\n\t\tret += scnprintf(buf + size, MOD_BUF - size,\n\t\t\t\t\"%s %d\\n\\tModule %d\\n\\tInstance %d\\n\\t\"\n\t\t\t\t\"In-used %s\\n\\tType %s\\n\"\n\t\t\t\t\"\\tState %d\\n\\tIndex %d\\n\",\n\t\t\t\tdirection ? \"Input Pin:\" : \"Output Pin:\",\n\t\t\t\ti, m_pin[i].id.module_id,\n\t\t\t\tm_pin[i].id.instance_id,\n\t\t\t\tm_pin[i].in_use ? \"Used\" : \"Unused\",\n\t\t\t\tm_pin[i].is_dynamic ? \"Dynamic\" : \"Static\",\n\t\t\t\tm_pin[i].pin_state, i);\n\t\tsize += ret;\n\t}\n\treturn ret;\n}\n\nstatic ssize_t skl_print_fmt(struct skl_module_fmt *fmt, char *buf,\n\t\t\t\t\tssize_t size, bool direction)\n{\n\treturn scnprintf(buf + size, MOD_BUF - size,\n\t\t\t\"%s\\n\\tCh %d\\n\\tFreq %d\\n\\tBit depth %d\\n\\t\"\n\t\t\t\"Valid bit depth %d\\n\\tCh config %#x\\n\\tInterleaving %d\\n\\t\"\n\t\t\t\"Sample Type %d\\n\\tCh Map %#x\\n\",\n\t\t\tdirection ? \"Input Format:\" : \"Output Format:\",\n\t\t\tfmt->channels, fmt->s_freq, fmt->bit_depth,\n\t\t\tfmt->valid_bit_depth, fmt->ch_cfg,\n\t\t\tfmt->interleaving_style, fmt->sample_type,\n\t\t\tfmt->ch_map);\n}\n\nstatic ssize_t module_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct skl_module_cfg *mconfig = file->private_data;\n\tstruct skl_module *module = mconfig->module;\n\tstruct skl_module_res *res = &module->resources[mconfig->res_idx];\n\tchar *buf;\n\tssize_t ret;\n\n\tbuf = kzalloc(MOD_BUF, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = scnprintf(buf, MOD_BUF, \"Module:\\n\\tUUID %pUL\\n\\tModule id %d\\n\"\n\t\t\t\"\\tInstance id %d\\n\\tPvt_id %d\\n\", mconfig->guid,\n\t\t\tmconfig->id.module_id, mconfig->id.instance_id,\n\t\t\tmconfig->id.pvt_id);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Resources:\\n\\tCPC %#x\\n\\tIBS %#x\\n\\tOBS %#x\\t\\n\",\n\t\t\tres->cpc, res->ibs, res->obs);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Module data:\\n\\tCore %d\\n\\tIn queue %d\\n\\t\"\n\t\t\t\"Out queue %d\\n\\tType %s\\n\",\n\t\t\tmconfig->core_id, mconfig->max_in_queue,\n\t\t\tmconfig->max_out_queue,\n\t\t\tmconfig->is_loadable ? \"loadable\" : \"inbuilt\");\n\n\tret += skl_print_fmt(mconfig->in_fmt, buf, ret, true);\n\tret += skl_print_fmt(mconfig->out_fmt, buf, ret, false);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Fixup:\\n\\tParams %#x\\n\\tConverter %#x\\n\",\n\t\t\tmconfig->params_fixup, mconfig->converter);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Module Gateway:\\n\\tType %#x\\n\\tVbus %#x\\n\\tHW conn %#x\\n\\tSlot %#x\\n\",\n\t\t\tmconfig->dev_type, mconfig->vbus_id,\n\t\t\tmconfig->hw_conn_type, mconfig->time_slot);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Pipeline:\\n\\tID %d\\n\\tPriority %d\\n\\tConn Type %d\\n\\t\"\n\t\t\t\"Pages %#x\\n\", mconfig->pipe->ppl_id,\n\t\t\tmconfig->pipe->pipe_priority, mconfig->pipe->conn_type,\n\t\t\tmconfig->pipe->memory_pages);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"\\tParams:\\n\\t\\tHost DMA %d\\n\\t\\tLink DMA %d\\n\",\n\t\t\tmconfig->pipe->p_params->host_dma_id,\n\t\t\tmconfig->pipe->p_params->link_dma_id);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"\\tPCM params:\\n\\t\\tCh %d\\n\\t\\tFreq %d\\n\\t\\tFormat %d\\n\",\n\t\t\tmconfig->pipe->p_params->ch,\n\t\t\tmconfig->pipe->p_params->s_freq,\n\t\t\tmconfig->pipe->p_params->s_fmt);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"\\tLink %#x\\n\\tStream %#x\\n\",\n\t\t\tmconfig->pipe->p_params->linktype,\n\t\t\tmconfig->pipe->p_params->stream);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"\\tState %d\\n\\tPassthru %s\\n\",\n\t\t\tmconfig->pipe->state,\n\t\t\tmconfig->pipe->passthru ? \"true\" : \"false\");\n\n\tret += skl_print_pins(mconfig->m_in_pin, buf,\n\t\t\tmconfig->max_in_queue, ret, true);\n\tret += skl_print_pins(mconfig->m_out_pin, buf,\n\t\t\tmconfig->max_out_queue, ret, false);\n\n\tret += scnprintf(buf + ret, MOD_BUF - ret,\n\t\t\t\"Other:\\n\\tDomain %d\\n\\tHomogeneous Input %s\\n\\t\"\n\t\t\t\"Homogeneous Output %s\\n\\tIn Queue Mask %d\\n\\t\"\n\t\t\t\"Out Queue Mask %d\\n\\tDMA ID %d\\n\\tMem Pages %d\\n\\t\"\n\t\t\t\"Module Type %d\\n\\tModule State %d\\n\",\n\t\t\tmconfig->domain,\n\t\t\tmconfig->homogenous_inputs ? \"true\" : \"false\",\n\t\t\tmconfig->homogenous_outputs ? \"true\" : \"false\",\n\t\t\tmconfig->in_queue_mask, mconfig->out_queue_mask,\n\t\t\tmconfig->dma_id, mconfig->mem_pages, mconfig->m_state,\n\t\t\tmconfig->m_type);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations mcfg_fops = {\n\t.open = simple_open,\n\t.read = module_read,\n\t.llseek = default_llseek,\n};\n\n\nvoid skl_debug_init_module(struct skl_debug *d,\n\t\t\tstruct snd_soc_dapm_widget *w,\n\t\t\tstruct skl_module_cfg *mconfig)\n{\n\tdebugfs_create_file(w->name, 0444, d->modules, mconfig,\n\t\t\t    &mcfg_fops);\n}\n\nstatic ssize_t fw_softreg_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct skl_debug *d = file->private_data;\n\tstruct sst_dsp *sst = d->skl->dsp;\n\tsize_t w0_stat_sz = sst->addr.w0_stat_sz;\n\tvoid __iomem *in_base = sst->mailbox.in_base;\n\tvoid __iomem *fw_reg_addr;\n\tunsigned int offset;\n\tchar *tmp;\n\tssize_t ret = 0;\n\n\ttmp = kzalloc(FW_REG_BUF, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tfw_reg_addr = in_base - w0_stat_sz;\n\tmemset(d->fw_read_buff, 0, FW_REG_BUF);\n\n\tif (w0_stat_sz > 0)\n\t\t__ioread32_copy(d->fw_read_buff, fw_reg_addr, w0_stat_sz >> 2);\n\n\tfor (offset = 0; offset < FW_REG_SIZE; offset += 16) {\n\t\tret += scnprintf(tmp + ret, FW_REG_BUF - ret, \"%#.4x: \", offset);\n\t\thex_dump_to_buffer(d->fw_read_buff + offset, 16, 16, 4,\n\t\t\t\t   tmp + ret, FW_REG_BUF - ret, 0);\n\t\tret += strlen(tmp + ret);\n\n\t\t \n\t\tif (FW_REG_BUF - ret > 0)\n\t\t\ttmp[ret++] = '\\n';\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, tmp, ret);\n\tkfree(tmp);\n\n\treturn ret;\n}\n\nstatic const struct file_operations soft_regs_ctrl_fops = {\n\t.open = simple_open,\n\t.read = fw_softreg_read,\n\t.llseek = default_llseek,\n};\n\nstruct skl_debug *skl_debugfs_init(struct skl_dev *skl)\n{\n\tstruct skl_debug *d;\n\n\td = devm_kzalloc(&skl->pci->dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn NULL;\n\n\t \n\td->fs = debugfs_create_dir(\"dsp\", skl->component->debugfs_root);\n\n\td->skl = skl;\n\td->dev = &skl->pci->dev;\n\n\t \n\td->modules = debugfs_create_dir(\"modules\", d->fs);\n\n\tdebugfs_create_file(\"fw_soft_regs_rd\", 0444, d->fs, d,\n\t\t\t    &soft_regs_ctrl_fops);\n\n\treturn d;\n}\n\nvoid skl_debugfs_exit(struct skl_dev *skl)\n{\n\tstruct skl_debug *d = skl->debugfs;\n\n\tdebugfs_remove_recursive(d->fs);\n\n\td = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}