{
  "module_name": "skl-ssp-clk.c",
  "hash_id": "48d9a007c4c91ee53e3b6531e77e65363736749c9af24f8014fb9f7bdcd3c3ec",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-ssp-clk.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <sound/intel-nhlt.h>\n#include \"skl.h\"\n#include \"skl-ssp-clk.h\"\n#include \"skl-topology.h\"\n\n#define to_skl_clk(_hw)\tcontainer_of(_hw, struct skl_clk, hw)\n\nstruct skl_clk_parent {\n\tstruct clk_hw *hw;\n\tstruct clk_lookup *lookup;\n};\n\nstruct skl_clk {\n\tstruct clk_hw hw;\n\tstruct clk_lookup *lookup;\n\tunsigned long rate;\n\tstruct skl_clk_pdata *pdata;\n\tu32 id;\n};\n\nstruct skl_clk_data {\n\tstruct skl_clk_parent parent[SKL_MAX_CLK_SRC];\n\tstruct skl_clk *clk[SKL_MAX_CLK_CNT];\n\tu8 avail_clk_cnt;\n};\n\nstatic int skl_get_clk_type(u32 index)\n{\n\tswitch (index) {\n\tcase 0 ... (SKL_SCLK_OFS - 1):\n\t\treturn SKL_MCLK;\n\n\tcase SKL_SCLK_OFS ... (SKL_SCLKFS_OFS - 1):\n\t\treturn SKL_SCLK;\n\n\tcase SKL_SCLKFS_OFS ... (SKL_MAX_CLK_CNT - 1):\n\t\treturn SKL_SCLK_FS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int skl_get_vbus_id(u32 index, u8 clk_type)\n{\n\tswitch (clk_type) {\n\tcase SKL_MCLK:\n\t\treturn index;\n\n\tcase SKL_SCLK:\n\t\treturn index - SKL_SCLK_OFS;\n\n\tcase SKL_SCLK_FS:\n\t\treturn index - SKL_SCLKFS_OFS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void skl_fill_clk_ipc(struct skl_clk_rate_cfg_table *rcfg, u8 clk_type)\n{\n\tstruct nhlt_fmt_cfg *fmt_cfg;\n\tunion skl_clk_ctrl_ipc *ipc;\n\tstruct wav_fmt *wfmt;\n\n\tif (!rcfg)\n\t\treturn;\n\n\tipc = &rcfg->dma_ctl_ipc;\n\tif (clk_type == SKL_SCLK_FS) {\n\t\tfmt_cfg = (struct nhlt_fmt_cfg *)rcfg->config;\n\t\twfmt = &fmt_cfg->fmt_ext.fmt;\n\n\t\t \n\t\tipc->sclk_fs.hdr.size = sizeof(struct skl_dmactrl_sclkfs_cfg) -\n\t\t\t\t\t\tsizeof(struct skl_tlv_hdr);\n\t\tipc->sclk_fs.sampling_frequency = wfmt->samples_per_sec;\n\t\tipc->sclk_fs.bit_depth = wfmt->bits_per_sample;\n\t\tipc->sclk_fs.valid_bit_depth =\n\t\t\tfmt_cfg->fmt_ext.sample.valid_bits_per_sample;\n\t\tipc->sclk_fs.number_of_channels = wfmt->channels;\n\t} else {\n\t\tipc->mclk.hdr.type = DMA_CLK_CONTROLS;\n\t\t \n\t\tipc->mclk.hdr.size = sizeof(struct skl_dmactrl_mclk_cfg) -\n\t\t\t\t\t\tsizeof(struct skl_tlv_hdr);\n\t}\n}\n\n \nstatic int skl_send_clk_dma_control(struct skl_dev *skl,\n\t\t\t\tstruct skl_clk_rate_cfg_table *rcfg,\n\t\t\t\tu32 vbus_id, u8 clk_type,\n\t\t\t\tbool enable)\n{\n\tstruct nhlt_specific_cfg *sp_cfg;\n\tu32 i2s_config_size, node_id = 0;\n\tstruct nhlt_fmt_cfg *fmt_cfg;\n\tunion skl_clk_ctrl_ipc *ipc;\n\tvoid *i2s_config = NULL;\n\tu8 *data, size;\n\tint ret;\n\n\tif (!rcfg)\n\t\treturn -EIO;\n\n\tipc = &rcfg->dma_ctl_ipc;\n\tfmt_cfg = (struct nhlt_fmt_cfg *)rcfg->config;\n\tsp_cfg = &fmt_cfg->config;\n\n\tif (clk_type == SKL_SCLK_FS) {\n\t\tipc->sclk_fs.hdr.type =\n\t\t\tenable ? DMA_TRANSMITION_START : DMA_TRANSMITION_STOP;\n\t\tdata = (u8 *)&ipc->sclk_fs;\n\t\tsize = sizeof(struct skl_dmactrl_sclkfs_cfg);\n\t} else {\n\t\t \n\t\tif (clk_type == SKL_SCLK)\n\t\t\tipc->mclk.mclk = 0;\n\t\telse\n\t\t\tipc->mclk.mclk = 1;\n\n\t\tipc->mclk.keep_running = enable;\n\t\tipc->mclk.warm_up_over = enable;\n\t\tipc->mclk.clk_stop_over = !enable;\n\t\tdata = (u8 *)&ipc->mclk;\n\t\tsize = sizeof(struct skl_dmactrl_mclk_cfg);\n\t}\n\n\ti2s_config_size = sp_cfg->size + size;\n\ti2s_config = kzalloc(i2s_config_size, GFP_KERNEL);\n\tif (!i2s_config)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(i2s_config, sp_cfg->caps, sp_cfg->size);\n\n\t \n\tmemcpy(i2s_config + sp_cfg->size, data, size);\n\n\tnode_id = ((SKL_DMA_I2S_LINK_INPUT_CLASS << 8) | (vbus_id << 4));\n\tret = skl_dsp_set_dma_control(skl, (u32 *)i2s_config,\n\t\t\t\t\ti2s_config_size, node_id);\n\tkfree(i2s_config);\n\n\treturn ret;\n}\n\nstatic struct skl_clk_rate_cfg_table *skl_get_rate_cfg(\n\t\tstruct skl_clk_rate_cfg_table *rcfg,\n\t\t\t\tunsigned long rate)\n{\n\tint i;\n\n\tfor (i = 0; (i < SKL_MAX_CLK_RATES) && rcfg[i].rate; i++) {\n\t\tif (rcfg[i].rate == rate)\n\t\t\treturn &rcfg[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int skl_clk_change_status(struct skl_clk *clkdev,\n\t\t\t\tbool enable)\n{\n\tstruct skl_clk_rate_cfg_table *rcfg;\n\tint vbus_id, clk_type;\n\n\tclk_type = skl_get_clk_type(clkdev->id);\n\tif (clk_type < 0)\n\t\treturn clk_type;\n\n\tvbus_id = skl_get_vbus_id(clkdev->id, clk_type);\n\tif (vbus_id < 0)\n\t\treturn vbus_id;\n\n\trcfg = skl_get_rate_cfg(clkdev->pdata->ssp_clks[clkdev->id].rate_cfg,\n\t\t\t\t\t\tclkdev->rate);\n\tif (!rcfg)\n\t\treturn -EINVAL;\n\n\treturn skl_send_clk_dma_control(clkdev->pdata->pvt_data, rcfg,\n\t\t\t\t\tvbus_id, clk_type, enable);\n}\n\nstatic int skl_clk_prepare(struct clk_hw *hw)\n{\n\tstruct skl_clk *clkdev = to_skl_clk(hw);\n\n\treturn skl_clk_change_status(clkdev, true);\n}\n\nstatic void skl_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct skl_clk *clkdev = to_skl_clk(hw);\n\n\tskl_clk_change_status(clkdev, false);\n}\n\nstatic int skl_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct skl_clk *clkdev = to_skl_clk(hw);\n\tstruct skl_clk_rate_cfg_table *rcfg;\n\tint clk_type;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\trcfg = skl_get_rate_cfg(clkdev->pdata->ssp_clks[clkdev->id].rate_cfg,\n\t\t\t\t\t\t\trate);\n\tif (!rcfg)\n\t\treturn -EINVAL;\n\n\tclk_type = skl_get_clk_type(clkdev->id);\n\tif (clk_type < 0)\n\t\treturn clk_type;\n\n\tskl_fill_clk_ipc(rcfg, clk_type);\n\tclkdev->rate = rate;\n\n\treturn 0;\n}\n\nstatic unsigned long skl_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct skl_clk *clkdev = to_skl_clk(hw);\n\n\tif (clkdev->rate)\n\t\treturn clkdev->rate;\n\n\treturn 0;\n}\n\n \nstatic long skl_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long *parent_rate)\n{\n\treturn rate;\n}\n\n \nstatic const struct clk_ops skl_clk_ops = {\n\t.prepare = skl_clk_prepare,\n\t.unprepare = skl_clk_unprepare,\n\t.set_rate = skl_clk_set_rate,\n\t.round_rate = skl_clk_round_rate,\n\t.recalc_rate = skl_clk_recalc_rate,\n};\n\nstatic void unregister_parent_src_clk(struct skl_clk_parent *pclk,\n\t\t\t\t\tunsigned int id)\n{\n\twhile (id--) {\n\t\tclkdev_drop(pclk[id].lookup);\n\t\tclk_hw_unregister_fixed_rate(pclk[id].hw);\n\t}\n}\n\nstatic void unregister_src_clk(struct skl_clk_data *dclk)\n{\n\twhile (dclk->avail_clk_cnt--)\n\t\tclkdev_drop(dclk->clk[dclk->avail_clk_cnt]->lookup);\n}\n\nstatic int skl_register_parent_clks(struct device *dev,\n\t\t\tstruct skl_clk_parent *parent,\n\t\t\tstruct skl_clk_parent_src *pclk)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < SKL_MAX_CLK_SRC; i++) {\n\n\t\t \n\t\tparent[i].hw = clk_hw_register_fixed_rate(dev, pclk[i].name,\n\t\t\t\tpclk[i].parent_name, 0, pclk[i].rate);\n\t\tif (IS_ERR(parent[i].hw)) {\n\t\t\tret = PTR_ERR(parent[i].hw);\n\t\t\tgoto err;\n\t\t}\n\n\t\tparent[i].lookup = clkdev_hw_create(parent[i].hw, pclk[i].name,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\tif (!parent[i].lookup) {\n\t\t\tclk_hw_unregister_fixed_rate(parent[i].hw);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tunregister_parent_src_clk(parent, i);\n\treturn ret;\n}\n\n \nstatic struct skl_clk *register_skl_clk(struct device *dev,\n\t\t\tstruct skl_ssp_clk *clk,\n\t\t\tstruct skl_clk_pdata *clk_pdata, int id)\n{\n\tstruct clk_init_data init;\n\tstruct skl_clk *clkdev;\n\tint ret;\n\n\tclkdev = devm_kzalloc(dev, sizeof(*clkdev), GFP_KERNEL);\n\tif (!clkdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = clk->name;\n\tinit.ops = &skl_clk_ops;\n\tinit.flags = CLK_SET_RATE_GATE;\n\tinit.parent_names = &clk->parent_name;\n\tinit.num_parents = 1;\n\tclkdev->hw.init = &init;\n\tclkdev->pdata = clk_pdata;\n\n\tclkdev->id = id;\n\tret = devm_clk_hw_register(dev, &clkdev->hw);\n\tif (ret) {\n\t\tclkdev = ERR_PTR(ret);\n\t\treturn clkdev;\n\t}\n\n\tclkdev->lookup = clkdev_hw_create(&clkdev->hw, init.name, NULL);\n\tif (!clkdev->lookup)\n\t\tclkdev = ERR_PTR(-ENOMEM);\n\n\treturn clkdev;\n}\n\nstatic int skl_clk_dev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent_dev = dev->parent;\n\tstruct skl_clk_parent_src *parent_clks;\n\tstruct skl_clk_pdata *clk_pdata;\n\tstruct skl_clk_data *data;\n\tstruct skl_ssp_clk *clks;\n\tint ret, i;\n\n\tclk_pdata = dev_get_platdata(&pdev->dev);\n\tparent_clks = clk_pdata->parent_clks;\n\tclks = clk_pdata->ssp_clks;\n\tif (!parent_clks || !clks)\n\t\treturn -EIO;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tret = skl_register_parent_clks(parent_dev, data->parent, parent_clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < clk_pdata->num_clks; i++) {\n\t\t \n\t\tif (clks[i].rate_cfg[0].rate == 0)\n\t\t\tcontinue;\n\n\t\tdata->clk[data->avail_clk_cnt] = register_skl_clk(dev,\n\t\t\t\t&clks[i], clk_pdata, i);\n\n\t\tif (IS_ERR(data->clk[data->avail_clk_cnt])) {\n\t\t\tret = PTR_ERR(data->clk[data->avail_clk_cnt]);\n\t\t\tgoto err_unreg_skl_clk;\n\t\t}\n\n\t\tdata->avail_clk_cnt++;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\nerr_unreg_skl_clk:\n\tunregister_src_clk(data);\n\tunregister_parent_src_clk(data->parent, SKL_MAX_CLK_SRC);\n\n\treturn ret;\n}\n\nstatic void skl_clk_dev_remove(struct platform_device *pdev)\n{\n\tstruct skl_clk_data *data;\n\n\tdata = platform_get_drvdata(pdev);\n\tunregister_src_clk(data);\n\tunregister_parent_src_clk(data->parent, SKL_MAX_CLK_SRC);\n}\n\nstatic struct platform_driver skl_clk_driver = {\n\t.driver = {\n\t\t.name = \"skl-ssp-clk\",\n\t},\n\t.probe = skl_clk_dev_probe,\n\t.remove_new = skl_clk_dev_remove,\n};\n\nmodule_platform_driver(skl_clk_driver);\n\nMODULE_DESCRIPTION(\"Skylake clock driver\");\nMODULE_AUTHOR(\"Jaikrishna Nemallapudi <jaikrishnax.nemallapudi@intel.com>\");\nMODULE_AUTHOR(\"Subhransu S. Prusty <subhransu.s.prusty@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:skl-ssp-clk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}