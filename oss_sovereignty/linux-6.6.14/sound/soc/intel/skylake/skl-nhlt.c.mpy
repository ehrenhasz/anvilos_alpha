{
  "module_name": "skl-nhlt.c",
  "hash_id": "593a70e889fbe9b2ef0381f3e3f8de59cd4ec486f3dd5a8992cabccea58bb634",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-nhlt.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <sound/intel-nhlt.h>\n#include \"skl.h\"\n#include \"skl-i2s.h\"\n\nstatic void skl_nhlt_trim_space(char *trim)\n{\n\tchar *s = trim;\n\tint cnt;\n\tint i;\n\n\tcnt = 0;\n\tfor (i = 0; s[i]; i++) {\n\t\tif (!isspace(s[i]))\n\t\t\ts[cnt++] = s[i];\n\t}\n\n\ts[cnt] = '\\0';\n}\n\nint skl_nhlt_update_topology_bin(struct skl_dev *skl)\n{\n\tstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tstruct device *dev = bus->dev;\n\n\tdev_dbg(dev, \"oem_id %.6s, oem_table_id %.8s oem_revision %d\\n\",\n\t\tnhlt->header.oem_id, nhlt->header.oem_table_id,\n\t\tnhlt->header.oem_revision);\n\n\tsnprintf(skl->tplg_name, sizeof(skl->tplg_name), \"%x-%.6s-%.8s-%d%s\",\n\t\tskl->pci_id, nhlt->header.oem_id, nhlt->header.oem_table_id,\n\t\tnhlt->header.oem_revision, \"-tplg.bin\");\n\n\tskl_nhlt_trim_space(skl->tplg_name);\n\n\treturn 0;\n}\n\nstatic ssize_t platform_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct hdac_bus *bus = pci_get_drvdata(pci);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\n\tchar platform_id[32];\n\n\tsprintf(platform_id, \"%x-%.6s-%.8s-%d\", skl->pci_id,\n\t\t\tnhlt->header.oem_id, nhlt->header.oem_table_id,\n\t\t\tnhlt->header.oem_revision);\n\n\tskl_nhlt_trim_space(platform_id);\n\treturn sysfs_emit(buf, \"%s\\n\", platform_id);\n}\n\nstatic DEVICE_ATTR_RO(platform_id);\n\nint skl_nhlt_create_sysfs(struct skl_dev *skl)\n{\n\tstruct device *dev = &skl->pci->dev;\n\n\tif (sysfs_create_file(&dev->kobj, &dev_attr_platform_id.attr))\n\t\tdev_warn(dev, \"Error creating sysfs entry\\n\");\n\n\treturn 0;\n}\n\nvoid skl_nhlt_remove_sysfs(struct skl_dev *skl)\n{\n\tstruct device *dev = &skl->pci->dev;\n\n\tif (skl->nhlt)\n\t\tsysfs_remove_file(&dev->kobj, &dev_attr_platform_id.attr);\n}\n\n \nstatic void skl_get_ssp_clks(struct skl_dev *skl, struct skl_ssp_clk *ssp_clks,\n\t\t\t\tstruct nhlt_fmt *fmt, u8 id)\n{\n\tstruct skl_i2s_config_blob_ext *i2s_config_ext;\n\tstruct skl_i2s_config_blob_legacy *i2s_config;\n\tstruct skl_clk_parent_src *parent;\n\tstruct skl_ssp_clk *sclk, *sclkfs;\n\tstruct nhlt_fmt_cfg *fmt_cfg;\n\tstruct wav_fmt_ext *wav_fmt;\n\tunsigned long rate;\n\tint rate_index = 0;\n\tu16 channels, bps;\n\tu8 clk_src;\n\tint i, j;\n\tu32 fs;\n\n\tsclk = &ssp_clks[SKL_SCLK_OFS];\n\tsclkfs = &ssp_clks[SKL_SCLKFS_OFS];\n\n\tif (fmt->fmt_count == 0)\n\t\treturn;\n\n\tfmt_cfg = (struct nhlt_fmt_cfg *)fmt->fmt_config;\n\tfor (i = 0; i < fmt->fmt_count; i++) {\n\t\tstruct nhlt_fmt_cfg *saved_fmt_cfg = fmt_cfg;\n\t\tbool present = false;\n\n\t\twav_fmt = &saved_fmt_cfg->fmt_ext;\n\n\t\tchannels = wav_fmt->fmt.channels;\n\t\tbps = wav_fmt->fmt.bits_per_sample;\n\t\tfs = wav_fmt->fmt.samples_per_sec;\n\n\t\t \n\t\tfor (j = i; j < fmt->fmt_count; j++) {\n\t\t\tstruct nhlt_fmt_cfg *tmp_fmt_cfg = fmt_cfg;\n\n\t\t\twav_fmt = &tmp_fmt_cfg->fmt_ext;\n\t\t\tif ((fs == wav_fmt->fmt.samples_per_sec) &&\n\t\t\t   (bps == wav_fmt->fmt.bits_per_sample)) {\n\t\t\t\tchannels = max_t(u16, channels,\n\t\t\t\t\t\twav_fmt->fmt.channels);\n\t\t\t\tsaved_fmt_cfg = tmp_fmt_cfg;\n\t\t\t}\n\t\t\t \n\t\t\ttmp_fmt_cfg = (struct nhlt_fmt_cfg *)(tmp_fmt_cfg->config.caps +\n\t\t\t\t\t\t\t      tmp_fmt_cfg->config.size);\n\t\t}\n\n\t\trate = channels * bps * fs;\n\n\t\t \n\t\tfor (j = 0; (j < SKL_MAX_CLK_RATES) &&\n\t\t\t    (sclk[id].rate_cfg[j].rate != 0); j++) {\n\t\t\tif (sclk[id].rate_cfg[j].rate == rate) {\n\t\t\t\tpresent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!present) {\n\t\t\tstruct nhlt_fmt_cfg *first_fmt_cfg;\n\n\t\t\tfirst_fmt_cfg = (struct nhlt_fmt_cfg *)fmt->fmt_config;\n\t\t\ti2s_config_ext = (struct skl_i2s_config_blob_ext *)\n\t\t\t\t\t\tfirst_fmt_cfg->config.caps;\n\n\t\t\t \n\t\t\tif (is_legacy_blob(i2s_config_ext->hdr.sig)) {\n\t\t\t\ti2s_config = ext_to_legacy_blob(i2s_config_ext);\n\t\t\t\tclk_src = get_clk_src(i2s_config->mclk,\n\t\t\t\t\t\tSKL_MNDSS_DIV_CLK_SRC_MASK);\n\t\t\t} else {\n\t\t\t\tclk_src = get_clk_src(i2s_config_ext->mclk,\n\t\t\t\t\t\tSKL_MNDSS_DIV_CLK_SRC_MASK);\n\t\t\t}\n\n\t\t\tparent = skl_get_parent_clk(clk_src);\n\n\t\t\t \n\t\t\tfmt_cfg = (struct nhlt_fmt_cfg *)(fmt_cfg->config.caps +\n\t\t\t\t\t\t\t  fmt_cfg->config.size);\n\t\t\t \n\t\t\tif (!parent)\n\t\t\t\tcontinue;\n\n\t\t\tsclk[id].rate_cfg[rate_index].rate = rate;\n\t\t\tsclk[id].rate_cfg[rate_index].config = saved_fmt_cfg;\n\t\t\tsclkfs[id].rate_cfg[rate_index].rate = rate;\n\t\t\tsclkfs[id].rate_cfg[rate_index].config = saved_fmt_cfg;\n\t\t\tsclk[id].parent_name = parent->name;\n\t\t\tsclkfs[id].parent_name = parent->name;\n\n\t\t\trate_index++;\n\t\t}\n\t}\n}\n\nstatic void skl_get_mclk(struct skl_dev *skl, struct skl_ssp_clk *mclk,\n\t\t\t\tstruct nhlt_fmt *fmt, u8 id)\n{\n\tstruct skl_i2s_config_blob_ext *i2s_config_ext;\n\tstruct skl_i2s_config_blob_legacy *i2s_config;\n\tstruct nhlt_fmt_cfg *fmt_cfg;\n\tstruct skl_clk_parent_src *parent;\n\tu32 clkdiv, div_ratio;\n\tu8 clk_src;\n\n\tfmt_cfg = (struct nhlt_fmt_cfg *)fmt->fmt_config;\n\ti2s_config_ext = (struct skl_i2s_config_blob_ext *)fmt_cfg->config.caps;\n\n\t \n\tif (is_legacy_blob(i2s_config_ext->hdr.sig)) {\n\t\ti2s_config = ext_to_legacy_blob(i2s_config_ext);\n\t\tclk_src = get_clk_src(i2s_config->mclk,\n\t\t\t\tSKL_MCLK_DIV_CLK_SRC_MASK);\n\t\tclkdiv = i2s_config->mclk.mdivr &\n\t\t\t\tSKL_MCLK_DIV_RATIO_MASK;\n\t} else {\n\t\tclk_src = get_clk_src(i2s_config_ext->mclk,\n\t\t\t\tSKL_MCLK_DIV_CLK_SRC_MASK);\n\t\tclkdiv = i2s_config_ext->mclk.mdivr[0] &\n\t\t\t\tSKL_MCLK_DIV_RATIO_MASK;\n\t}\n\n\t \n\tdiv_ratio = 1;\n\n\tif (clkdiv != SKL_MCLK_DIV_RATIO_MASK)\n\t\t \n\t\tdiv_ratio = clkdiv + 2;\n\n\t \n\tparent = skl_get_parent_clk(clk_src);\n\tif (!parent)\n\t\treturn;\n\n\tmclk[id].rate_cfg[0].rate = parent->rate/div_ratio;\n\tmclk[id].rate_cfg[0].config = fmt_cfg;\n\tmclk[id].parent_name = parent->name;\n}\n\nvoid skl_get_clks(struct skl_dev *skl, struct skl_ssp_clk *ssp_clks)\n{\n\tstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\n\tstruct nhlt_endpoint *epnt;\n\tstruct nhlt_fmt *fmt;\n\tint i;\n\tu8 id;\n\n\tepnt = (struct nhlt_endpoint *)nhlt->desc;\n\tfor (i = 0; i < nhlt->endpoint_count; i++) {\n\t\tif (epnt->linktype == NHLT_LINK_SSP) {\n\t\t\tid = epnt->virtual_bus_id;\n\n\t\t\tfmt = (struct nhlt_fmt *)(epnt->config.caps\n\t\t\t\t\t+ epnt->config.size);\n\n\t\t\tskl_get_ssp_clks(skl, ssp_clks, fmt, id);\n\t\t\tskl_get_mclk(skl, ssp_clks, fmt, id);\n\t\t}\n\t\tepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}