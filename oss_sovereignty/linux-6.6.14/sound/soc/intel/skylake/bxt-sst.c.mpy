{
  "module_name": "bxt-sst.c",
  "hash_id": "712e891b63338d96435f7b077a0963bfe0d04ab3d74936416ca1569f9efcad28",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/bxt-sst.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"skl.h\"\n\n#define BXT_BASEFW_TIMEOUT\t3000\n#define BXT_ROM_INIT_TIMEOUT\t70\n#define BXT_IPC_PURGE_FW\t0x01004000\n\n#define BXT_ROM_INIT\t\t0x5\n#define BXT_ADSP_SRAM0_BASE\t0x80000\n\n \n#define BXT_ADSP_FW_STATUS\tBXT_ADSP_SRAM0_BASE\n#define BXT_ADSP_ERROR_CODE     (BXT_ADSP_FW_STATUS + 0x4)\n\n#define BXT_ADSP_SRAM1_BASE\t0xA0000\n\n#define BXT_INSTANCE_ID 0\n#define BXT_BASE_FW_MODULE_ID 0\n\n#define BXT_ADSP_FW_BIN_HDR_OFFSET 0x2000\n\n \n#define BXT_D0I3_DELAY 5000\n\nstatic unsigned int bxt_get_errorcode(struct sst_dsp *ctx)\n{\n\t return sst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE);\n}\n\nstatic int\nbxt_load_library(struct sst_dsp *ctx, struct skl_lib_info *linfo, int lib_count)\n{\n\tstruct snd_dma_buffer dmab;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct firmware stripped_fw;\n\tint ret = 0, i, dma_id, stream_tag;\n\n\t \n\tfor (i = 1; i < lib_count; i++) {\n\t\tret = skl_prepare_lib_load(skl, &skl->lib_info[i], &stripped_fw,\n\t\t\t\t\tBXT_ADSP_FW_BIN_HDR_OFFSET, i);\n\t\tif (ret < 0)\n\t\t\tgoto load_library_failed;\n\n\t\tstream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40,\n\t\t\t\t\tstripped_fw.size, &dmab);\n\t\tif (stream_tag <= 0) {\n\t\t\tdev_err(ctx->dev, \"Lib prepare DMA err: %x\\n\",\n\t\t\t\t\tstream_tag);\n\t\t\tret = stream_tag;\n\t\t\tgoto load_library_failed;\n\t\t}\n\n\t\tdma_id = stream_tag - 1;\n\t\tmemcpy(dmab.area, stripped_fw.data, stripped_fw.size);\n\n\t\tctx->dsp_ops.trigger(ctx->dev, true, stream_tag);\n\t\tret = skl_sst_ipc_load_library(&skl->ipc, dma_id, i, true);\n\t\tif (ret < 0)\n\t\t\tdev_err(ctx->dev, \"IPC Load Lib for %s fail: %d\\n\",\n\t\t\t\t\tlinfo[i].name, ret);\n\n\t\tctx->dsp_ops.trigger(ctx->dev, false, stream_tag);\n\t\tctx->dsp_ops.cleanup(ctx->dev, &dmab, stream_tag);\n\t}\n\n\treturn ret;\n\nload_library_failed:\n\tskl_release_library(linfo, lib_count);\n\treturn ret;\n}\n\n \nstatic int sst_bxt_prepare_fw(struct sst_dsp *ctx,\n\t\t\tconst void *fwdata, u32 fwsize)\n{\n\tint stream_tag, ret;\n\n\tstream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fwsize, &ctx->dmab);\n\tif (stream_tag <= 0) {\n\t\tdev_err(ctx->dev, \"Failed to prepare DMA FW loading err: %x\\n\",\n\t\t\t\tstream_tag);\n\t\treturn stream_tag;\n\t}\n\n\tctx->dsp_ops.stream_tag = stream_tag;\n\tmemcpy(ctx->dmab.area, fwdata, fwsize);\n\n\t \n\tret = skl_dsp_core_power_up(ctx, SKL_DSP_CORE0_MASK |\n\t\t\t\tSKL_DSP_CORE_MASK(1));\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core0/1 power up failed\\n\");\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tsst_dsp_shim_write(ctx, SKL_ADSP_REG_HIPCI, SKL_ADSP_REG_HIPCI_BUSY |\n\t\t\t\t(BXT_IPC_PURGE_FW | ((stream_tag - 1) << 9)));\n\n\t \n\tret = skl_dsp_start_core(ctx, SKL_DSP_CORE0_MASK);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Start dsp core failed ret: %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tret = sst_dsp_register_poll(ctx, SKL_ADSP_REG_HIPCIE,\n\t\t\t\t\tSKL_ADSP_REG_HIPCIE_DONE,\n\t\t\t\t\tSKL_ADSP_REG_HIPCIE_DONE,\n\t\t\t\t\tBXT_INIT_TIMEOUT, \"HIPCIE Done\");\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Timeout for Purge Request%d\\n\", ret);\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tret = skl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core1 power down failed\\n\");\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tskl_ipc_int_enable(ctx);\n\tskl_ipc_op_int_enable(ctx);\n\n\t \n\tret = sst_dsp_register_poll(ctx, BXT_ADSP_FW_STATUS, SKL_FW_STS_MASK,\n\t\t\tSKL_FW_INIT, BXT_ROM_INIT_TIMEOUT, \"ROM Load\");\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Timeout for ROM init, ret:%d\\n\", ret);\n\t\tgoto base_fw_load_failed;\n\t}\n\n\treturn ret;\n\nbase_fw_load_failed:\n\tctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);\n\tskl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));\n\tskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\treturn ret;\n}\n\nstatic int sst_transfer_fw_host_dma(struct sst_dsp *ctx)\n{\n\tint ret;\n\n\tctx->dsp_ops.trigger(ctx->dev, true, ctx->dsp_ops.stream_tag);\n\tret = sst_dsp_register_poll(ctx, BXT_ADSP_FW_STATUS, SKL_FW_STS_MASK,\n\t\t\tBXT_ROM_INIT, BXT_BASEFW_TIMEOUT, \"Firmware boot\");\n\n\tctx->dsp_ops.trigger(ctx->dev, false, ctx->dsp_ops.stream_tag);\n\tctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, ctx->dsp_ops.stream_tag);\n\n\treturn ret;\n}\n\nstatic int bxt_load_base_firmware(struct sst_dsp *ctx)\n{\n\tstruct firmware stripped_fw;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint ret, i;\n\n\tif (ctx->fw == NULL) {\n\t\tret = request_firmware(&ctx->fw, ctx->fw_name, ctx->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"Request firmware failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (skl->is_first_boot) {\n\t\tret = snd_skl_parse_uuids(ctx, ctx->fw, BXT_ADSP_FW_BIN_HDR_OFFSET, 0);\n\t\tif (ret < 0)\n\t\t\tgoto sst_load_base_firmware_failed;\n\t}\n\n\tstripped_fw.data = ctx->fw->data;\n\tstripped_fw.size = ctx->fw->size;\n\tskl_dsp_strip_extended_manifest(&stripped_fw);\n\n\n\tfor (i = 0; i < BXT_FW_ROM_INIT_RETRY; i++) {\n\t\tret = sst_bxt_prepare_fw(ctx, stripped_fw.data, stripped_fw.size);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Error code=0x%x: FW status=0x%x\\n\",\n\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),\n\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_FW_STATUS));\n\n\t\tdev_err(ctx->dev, \"Core En/ROM load fail:%d\\n\", ret);\n\t\tgoto sst_load_base_firmware_failed;\n\t}\n\n\tret = sst_transfer_fw_host_dma(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Transfer firmware failed %d\\n\", ret);\n\t\tdev_info(ctx->dev, \"Error code=0x%x: FW status=0x%x\\n\",\n\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),\n\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_FW_STATUS));\n\n\t\tskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t} else {\n\t\tdev_dbg(ctx->dev, \"Firmware download successful\\n\");\n\t\tret = wait_event_timeout(skl->boot_wait, skl->boot_complete,\n\t\t\t\t\tmsecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\t\tif (ret == 0) {\n\t\t\tdev_err(ctx->dev, \"DSP boot fail, FW Ready timeout\\n\");\n\t\t\tskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tret = 0;\n\t\t\tskl->fw_loaded = true;\n\t\t}\n\t}\n\n\treturn ret;\n\nsst_load_base_firmware_failed:\n\trelease_firmware(ctx->fw);\n\tctx->fw = NULL;\n\treturn ret;\n}\n\n \nstatic int bxt_d0i3_target_state(struct sst_dsp *ctx)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct skl_d0i3_data *d0i3 = &skl->d0i3;\n\n\tif (skl->cores.state[SKL_DSP_CORE0_ID] != SKL_DSP_RUNNING)\n\t\treturn SKL_DSP_D0I3_NONE;\n\n\tif (d0i3->non_d0i3)\n\t\treturn SKL_DSP_D0I3_NONE;\n\telse if (d0i3->streaming)\n\t\treturn SKL_DSP_D0I3_STREAMING;\n\telse if (d0i3->non_streaming)\n\t\treturn SKL_DSP_D0I3_NON_STREAMING;\n\telse\n\t\treturn SKL_DSP_D0I3_NONE;\n}\n\nstatic void bxt_set_dsp_D0i3(struct work_struct *work)\n{\n\tint ret;\n\tstruct skl_ipc_d0ix_msg msg;\n\tstruct skl_dev *skl = container_of(work,\n\t\t\tstruct skl_dev, d0i3.work.work);\n\tstruct sst_dsp *ctx = skl->dsp;\n\tstruct skl_d0i3_data *d0i3 = &skl->d0i3;\n\tint target_state;\n\n\tdev_dbg(ctx->dev, \"In %s:\\n\", __func__);\n\n\t \n\tif (skl_dsp_get_enabled_cores(ctx) !=  SKL_DSP_CORE0_MASK) {\n\t\tdev_warn(ctx->dev,\n\t\t\t\t\"D0i3 allowed when only core0 running:Exit\\n\");\n\t\treturn;\n\t}\n\n\ttarget_state = bxt_d0i3_target_state(ctx);\n\tif (target_state == SKL_DSP_D0I3_NONE)\n\t\treturn;\n\n\tmsg.instance_id = 0;\n\tmsg.module_id = 0;\n\tmsg.wake = 1;\n\tmsg.streaming = 0;\n\tif (target_state == SKL_DSP_D0I3_STREAMING)\n\t\tmsg.streaming = 1;\n\n\tret =  skl_ipc_set_d0ix(&skl->ipc, &msg);\n\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to set DSP to D0i3 state\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (skl->update_d0i3c)\n\t\tskl->update_d0i3c(skl->dev, true);\n\n\td0i3->state = target_state;\n\tskl->cores.state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING_D0I3;\n}\n\nstatic int bxt_schedule_dsp_D0i3(struct sst_dsp *ctx)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tstruct skl_d0i3_data *d0i3 = &skl->d0i3;\n\n\t \n\tif (bxt_d0i3_target_state(ctx) != SKL_DSP_D0I3_NONE) {\n\n\t\tdev_dbg(ctx->dev, \"%s: Schedule D0i3\\n\", __func__);\n\n\t\tschedule_delayed_work(&d0i3->work,\n\t\t\t\tmsecs_to_jiffies(BXT_D0I3_DELAY));\n\t}\n\n\treturn 0;\n}\n\nstatic int bxt_set_dsp_D0i0(struct sst_dsp *ctx)\n{\n\tint ret;\n\tstruct skl_ipc_d0ix_msg msg;\n\tstruct skl_dev *skl = ctx->thread_context;\n\n\tdev_dbg(ctx->dev, \"In %s:\\n\", __func__);\n\n\t \n\tcancel_delayed_work_sync(&skl->d0i3.work);\n\n\t \n\tif (skl->cores.state[SKL_DSP_CORE0_ID] != SKL_DSP_RUNNING_D0I3)\n\t\treturn 0;\n\n\tdev_dbg(ctx->dev, \"Set DSP to D0i0\\n\");\n\n\tmsg.instance_id = 0;\n\tmsg.module_id = 0;\n\tmsg.streaming = 0;\n\tmsg.wake = 0;\n\n\tif (skl->d0i3.state == SKL_DSP_D0I3_STREAMING)\n\t\tmsg.streaming = 1;\n\n\t \n\tif (skl->update_d0i3c)\n\t\tskl->update_d0i3c(skl->dev, false);\n\n\tret =  skl_ipc_set_d0ix(&skl->ipc, &msg);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to set DSP to D0i0\\n\");\n\t\treturn ret;\n\t}\n\n\tskl->cores.state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING;\n\tskl->d0i3.state = SKL_DSP_D0I3_NONE;\n\n\treturn 0;\n}\n\nstatic int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tstruct skl_dev *skl = ctx->thread_context;\n\tint ret;\n\tstruct skl_ipc_dxstate_info dx;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\n\tif (skl->fw_loaded == false) {\n\t\tskl->boot_complete = false;\n\t\tret = bxt_load_base_firmware(ctx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"reload fw failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (skl->lib_count > 1) {\n\t\t\tret = bxt_load_library(ctx, skl->lib_info,\n\t\t\t\t\t\tskl->lib_count);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(ctx->dev, \"reload libs failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tskl->cores.state[core_id] = SKL_DSP_RUNNING;\n\t\treturn ret;\n\t}\n\n\t \n\tif (core_id == SKL_DSP_CORE0_ID)\n\t\tret = skl_dsp_core_power_up(ctx, core_mask |\n\t\t\t\tSKL_DSP_CORE_MASK(1));\n\telse\n\t\tret = skl_dsp_core_power_up(ctx, core_mask);\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (core_id == SKL_DSP_CORE0_ID) {\n\n\t\t \n\t\tskl_ipc_int_enable(ctx);\n\t\tskl_ipc_op_int_enable(ctx);\n\t\tskl->boot_complete = false;\n\t}\n\n\tret = skl_dsp_start_core(ctx, core_mask);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\tret = wait_event_timeout(skl->boot_wait,\n\t\t\t\tskl->boot_complete,\n\t\t\t\tmsecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\n\t \n\t\tskl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));\n\t\tif (ret == 0) {\n\t\t\tdev_err(ctx->dev, \"%s: DSP boot timeout\\n\", __func__);\n\t\t\tdev_err(ctx->dev, \"Error code=0x%x: FW status=0x%x\\n\",\n\t\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),\n\t\t\t\tsst_dsp_shim_read(ctx, BXT_ADSP_FW_STATUS));\n\t\t\tdev_err(ctx->dev, \"Failed to set core0 to D0 state\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\n\tif (core_id != SKL_DSP_CORE0_ID) {\n\t\tdx.core_mask = core_mask;\n\t\tdx.dx_mask = core_mask;\n\n\t\tret = skl_ipc_set_dx(&skl->ipc, BXT_INSTANCE_ID,\n\t\t\t\t\tBXT_BASE_FW_MODULE_ID, &dx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"IPC set_dx for core %d fail: %d\\n\",\n\t\t\t\t\t\t\t\tcore_id, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tskl->cores.state[core_id] = SKL_DSP_RUNNING;\n\treturn 0;\nerr:\n\tif (core_id == SKL_DSP_CORE0_ID)\n\t\tcore_mask |= SKL_DSP_CORE_MASK(1);\n\tskl_dsp_disable_core(ctx, core_mask);\n\n\treturn ret;\n}\n\nstatic int bxt_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tint ret;\n\tstruct skl_ipc_dxstate_info dx;\n\tstruct skl_dev *skl = ctx->thread_context;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\n\tdx.core_mask = core_mask;\n\tdx.dx_mask = SKL_IPC_D3_MASK;\n\n\tdev_dbg(ctx->dev, \"core mask=%x dx_mask=%x\\n\",\n\t\t\tdx.core_mask, dx.dx_mask);\n\n\tret = skl_ipc_set_dx(&skl->ipc, BXT_INSTANCE_ID,\n\t\t\t\tBXT_BASE_FW_MODULE_ID, &dx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev,\n\t\t\"Failed to set DSP to D3:core id = %d;Continue reset\\n\",\n\t\tcore_id);\n\t\t \n\t\tskl->fw_loaded = false;\n\t}\n\n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\t \n\t\tskl_ipc_op_int_disable(ctx);\n\t\tskl_ipc_int_disable(ctx);\n\t}\n\tret = skl_dsp_disable_core(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to disable core %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tskl->cores.state[core_id] = SKL_DSP_RESET;\n\treturn 0;\n}\n\nstatic const struct skl_dsp_fw_ops bxt_fw_ops = {\n\t.set_state_D0 = bxt_set_dsp_D0,\n\t.set_state_D3 = bxt_set_dsp_D3,\n\t.set_state_D0i3 = bxt_schedule_dsp_D0i3,\n\t.set_state_D0i0 = bxt_set_dsp_D0i0,\n\t.load_fw = bxt_load_base_firmware,\n\t.get_fw_errcode = bxt_get_errorcode,\n\t.load_library = bxt_load_library,\n};\n\nstatic struct sst_ops skl_ops = {\n\t.irq_handler = skl_dsp_sst_interrupt,\n\t.write = sst_shim32_write,\n\t.read = sst_shim32_read,\n\t.free = skl_dsp_free,\n};\n\nstatic struct sst_dsp_device skl_dev = {\n\t.thread = skl_dsp_irq_thread_handler,\n\t.ops = &skl_ops,\n};\n\nint bxt_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,\n\t\t\tconst char *fw_name, struct skl_dsp_loader_ops dsp_ops,\n\t\t\tstruct skl_dev **dsp)\n{\n\tstruct skl_dev *skl;\n\tstruct sst_dsp *sst;\n\tint ret;\n\n\tret = skl_sst_ctx_init(dev, irq, fw_name, dsp_ops, dsp, &skl_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: no device\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tskl = *dsp;\n\tsst = skl->dsp;\n\tsst->fw_ops = bxt_fw_ops;\n\tsst->addr.lpe = mmio_base;\n\tsst->addr.shim = mmio_base;\n\tsst->addr.sram0_base = BXT_ADSP_SRAM0_BASE;\n\tsst->addr.sram1_base = BXT_ADSP_SRAM1_BASE;\n\tsst->addr.w0_stat_sz = SKL_ADSP_W0_STAT_SZ;\n\tsst->addr.w0_up_sz = SKL_ADSP_W0_UP_SZ;\n\n\tsst_dsp_mailbox_init(sst, (BXT_ADSP_SRAM0_BASE + SKL_ADSP_W0_STAT_SZ),\n\t\t\tSKL_ADSP_W0_UP_SZ, BXT_ADSP_SRAM1_BASE, SKL_ADSP_W1_SZ);\n\n\tret = skl_ipc_init(dev, skl);\n\tif (ret) {\n\t\tskl_dsp_free(sst);\n\t\treturn ret;\n\t}\n\n\t \n\tskl->ipc.ops.check_dsp_lp_on = skl_ipc_check_D0i0;\n\n\tskl->boot_complete = false;\n\tinit_waitqueue_head(&skl->boot_wait);\n\tINIT_DELAYED_WORK(&skl->d0i3.work, bxt_set_dsp_D0i3);\n\tskl->d0i3.state = SKL_DSP_D0I3_NONE;\n\n\treturn skl_dsp_acquire_irq(sst);\n}\nEXPORT_SYMBOL_GPL(bxt_sst_dsp_init);\n\nint bxt_sst_init_fw(struct device *dev, struct skl_dev *skl)\n{\n\tint ret;\n\tstruct sst_dsp *sst = skl->dsp;\n\n\tret = sst->fw_ops.load_fw(sst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Load base fw failed: %x\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tskl_dsp_init_core_state(sst);\n\n\tif (skl->lib_count > 1) {\n\t\tret = sst->fw_ops.load_library(sst, skl->lib_info,\n\t\t\t\t\t\tskl->lib_count);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Load Library failed : %x\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tskl->is_first_boot = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bxt_sst_init_fw);\n\nvoid bxt_sst_dsp_cleanup(struct device *dev, struct skl_dev *skl)\n{\n\n\tskl_release_library(skl->lib_info, skl->lib_count);\n\tif (skl->dsp->fw)\n\t\trelease_firmware(skl->dsp->fw);\n\tskl_freeup_uuid_list(skl);\n\tskl_ipc_free(&skl->ipc);\n\tskl->dsp->ops->free(skl->dsp);\n}\nEXPORT_SYMBOL_GPL(bxt_sst_dsp_cleanup);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Broxton IPC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}