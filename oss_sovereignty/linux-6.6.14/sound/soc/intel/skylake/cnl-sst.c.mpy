{
  "module_name": "cnl-sst.c",
  "hash_id": "ae2b51c9a50813de160c321e59a30f26644c826c7874da8f56ec61c51a12bfa4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/cnl-sst.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n#include \"../common/sst-ipc.h\"\n#include \"cnl-sst-dsp.h\"\n#include \"skl.h\"\n\n#define CNL_FW_ROM_INIT\t\t0x1\n#define CNL_FW_INIT\t\t0x5\n#define CNL_IPC_PURGE\t\t0x01004000\n#define CNL_INIT_TIMEOUT\t300\n#define CNL_BASEFW_TIMEOUT\t3000\n\n#define CNL_ADSP_SRAM0_BASE\t0x80000\n\n \n#define CNL_ADSP_FW_STATUS\tCNL_ADSP_SRAM0_BASE\n#define CNL_ADSP_ERROR_CODE\t(CNL_ADSP_FW_STATUS + 0x4)\n\n#define CNL_INSTANCE_ID\t\t0\n#define CNL_BASE_FW_MODULE_ID\t0\n#define CNL_ADSP_FW_HDR_OFFSET\t0x2000\n#define CNL_ROM_CTRL_DMA_ID\t0x9\n\nstatic int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata, u32 fwsize)\n{\n\n\tint ret, stream_tag;\n\n\tstream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fwsize, &ctx->dmab);\n\tif (stream_tag <= 0) {\n\t\tdev_err(ctx->dev, \"dma prepare failed: 0%#x\\n\", stream_tag);\n\t\treturn stream_tag;\n\t}\n\n\tctx->dsp_ops.stream_tag = stream_tag;\n\tmemcpy(ctx->dmab.area, fwdata, fwsize);\n\n\tret = skl_dsp_core_power_up(ctx, SKL_DSP_CORE0_MASK);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"dsp core0 power up failed\\n\");\n\t\tret = -EIO;\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tsst_dsp_shim_write(ctx, CNL_ADSP_REG_HIPCIDR,\n\t\t\t   CNL_ADSP_REG_HIPCIDR_BUSY | (CNL_IPC_PURGE |\n\t\t\t   ((stream_tag - 1) << CNL_ROM_CTRL_DMA_ID)));\n\n\tret = skl_dsp_start_core(ctx, SKL_DSP_CORE0_MASK);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Start dsp core failed ret: %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto base_fw_load_failed;\n\t}\n\n\tret = sst_dsp_register_poll(ctx, CNL_ADSP_REG_HIPCIDA,\n\t\t\t\t    CNL_ADSP_REG_HIPCIDA_DONE,\n\t\t\t\t    CNL_ADSP_REG_HIPCIDA_DONE,\n\t\t\t\t    BXT_INIT_TIMEOUT, \"HIPCIDA Done\");\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"timeout for purge request: %d\\n\", ret);\n\t\tgoto base_fw_load_failed;\n\t}\n\n\t \n\tcnl_ipc_int_enable(ctx);\n\tcnl_ipc_op_int_enable(ctx);\n\n\tret = sst_dsp_register_poll(ctx, CNL_ADSP_FW_STATUS, CNL_FW_STS_MASK,\n\t\t\t\t    CNL_FW_ROM_INIT, CNL_INIT_TIMEOUT,\n\t\t\t\t    \"rom load\");\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"rom init timeout, ret: %d\\n\", ret);\n\t\tgoto base_fw_load_failed;\n\t}\n\n\treturn 0;\n\nbase_fw_load_failed:\n\tctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);\n\tcnl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\n\treturn ret;\n}\n\nstatic int sst_transfer_fw_host_dma(struct sst_dsp *ctx)\n{\n\tint ret;\n\n\tctx->dsp_ops.trigger(ctx->dev, true, ctx->dsp_ops.stream_tag);\n\tret = sst_dsp_register_poll(ctx, CNL_ADSP_FW_STATUS, CNL_FW_STS_MASK,\n\t\t\t\t    CNL_FW_INIT, CNL_BASEFW_TIMEOUT,\n\t\t\t\t    \"firmware boot\");\n\n\tctx->dsp_ops.trigger(ctx->dev, false, ctx->dsp_ops.stream_tag);\n\tctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, ctx->dsp_ops.stream_tag);\n\n\treturn ret;\n}\n\nstatic int cnl_load_base_firmware(struct sst_dsp *ctx)\n{\n\tstruct firmware stripped_fw;\n\tstruct skl_dev *cnl = ctx->thread_context;\n\tint ret, i;\n\n\tif (!ctx->fw) {\n\t\tret = request_firmware(&ctx->fw, ctx->fw_name, ctx->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"request firmware failed: %d\\n\", ret);\n\t\t\tgoto cnl_load_base_firmware_failed;\n\t\t}\n\t}\n\n\t \n\tif (cnl->is_first_boot) {\n\t\tret = snd_skl_parse_uuids(ctx, ctx->fw,\n\t\t\t\t\t  CNL_ADSP_FW_HDR_OFFSET, 0);\n\t\tif (ret < 0)\n\t\t\tgoto cnl_load_base_firmware_failed;\n\t}\n\n\tstripped_fw.data = ctx->fw->data;\n\tstripped_fw.size = ctx->fw->size;\n\tskl_dsp_strip_extended_manifest(&stripped_fw);\n\n\tfor (i = 0; i < BXT_FW_ROM_INIT_RETRY; i++) {\n\t\tret = cnl_prepare_fw(ctx, stripped_fw.data, stripped_fw.size);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tdev_dbg(ctx->dev, \"prepare firmware failed: %d\\n\", ret);\n\t}\n\n\tif (ret < 0)\n\t\tgoto cnl_load_base_firmware_failed;\n\n\tret = sst_transfer_fw_host_dma(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"transfer firmware failed: %d\\n\", ret);\n\t\tcnl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t\tgoto cnl_load_base_firmware_failed;\n\t}\n\n\tret = wait_event_timeout(cnl->boot_wait, cnl->boot_complete,\n\t\t\t\t msecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\tif (ret == 0) {\n\t\tdev_err(ctx->dev, \"FW ready timed-out\\n\");\n\t\tcnl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\n\t\tret = -EIO;\n\t\tgoto cnl_load_base_firmware_failed;\n\t}\n\n\tcnl->fw_loaded = true;\n\n\treturn 0;\n\ncnl_load_base_firmware_failed:\n\tdev_err(ctx->dev, \"firmware load failed: %d\\n\", ret);\n\trelease_firmware(ctx->fw);\n\tctx->fw = NULL;\n\n\treturn ret;\n}\n\nstatic int cnl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tstruct skl_dev *cnl = ctx->thread_context;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\tstruct skl_ipc_dxstate_info dx;\n\tint ret;\n\n\tif (!cnl->fw_loaded) {\n\t\tcnl->boot_complete = false;\n\t\tret = cnl_load_base_firmware(ctx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"fw reload failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcnl->cores.state[core_id] = SKL_DSP_RUNNING;\n\t\treturn ret;\n\t}\n\n\tret = cnl_dsp_enable_core(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"enable dsp core %d failed: %d\\n\",\n\t\t\tcore_id, ret);\n\t\tgoto err;\n\t}\n\n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\t \n\t\tcnl_ipc_int_enable(ctx);\n\t\tcnl_ipc_op_int_enable(ctx);\n\t\tcnl->boot_complete = false;\n\n\t\tret = wait_event_timeout(cnl->boot_wait, cnl->boot_complete,\n\t\t\t\t\t msecs_to_jiffies(SKL_IPC_BOOT_MSECS));\n\t\tif (ret == 0) {\n\t\t\tdev_err(ctx->dev,\n\t\t\t\t\"dsp boot timeout, status=%#x error=%#x\\n\",\n\t\t\t\tsst_dsp_shim_read(ctx, CNL_ADSP_FW_STATUS),\n\t\t\t\tsst_dsp_shim_read(ctx, CNL_ADSP_ERROR_CODE));\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tdx.core_mask = core_mask;\n\t\tdx.dx_mask = core_mask;\n\n\t\tret = skl_ipc_set_dx(&cnl->ipc, CNL_INSTANCE_ID,\n\t\t\t\t     CNL_BASE_FW_MODULE_ID, &dx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"set_dx failed, core: %d ret: %d\\n\",\n\t\t\t\tcore_id, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tcnl->cores.state[core_id] = SKL_DSP_RUNNING;\n\n\treturn 0;\nerr:\n\tcnl_dsp_disable_core(ctx, core_mask);\n\n\treturn ret;\n}\n\nstatic int cnl_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)\n{\n\tstruct skl_dev *cnl = ctx->thread_context;\n\tunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\n\tstruct skl_ipc_dxstate_info dx;\n\tint ret;\n\n\tdx.core_mask = core_mask;\n\tdx.dx_mask = SKL_IPC_D3_MASK;\n\n\tret = skl_ipc_set_dx(&cnl->ipc, CNL_INSTANCE_ID,\n\t\t\t     CNL_BASE_FW_MODULE_ID, &dx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev,\n\t\t\t\"dsp core %d to d3 failed; continue reset\\n\",\n\t\t\tcore_id);\n\t\tcnl->fw_loaded = false;\n\t}\n\n\t \n\tif (core_id == SKL_DSP_CORE0_ID) {\n\t\tskl_ipc_op_int_disable(ctx);\n\t\tskl_ipc_int_disable(ctx);\n\t}\n\n\tret = cnl_dsp_disable_core(ctx, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"disable dsp core %d failed: %d\\n\",\n\t\t\tcore_id, ret);\n\t\treturn ret;\n\t}\n\n\tcnl->cores.state[core_id] = SKL_DSP_RESET;\n\n\treturn ret;\n}\n\nstatic unsigned int cnl_get_errno(struct sst_dsp *ctx)\n{\n\treturn sst_dsp_shim_read(ctx, CNL_ADSP_ERROR_CODE);\n}\n\nstatic const struct skl_dsp_fw_ops cnl_fw_ops = {\n\t.set_state_D0 = cnl_set_dsp_D0,\n\t.set_state_D3 = cnl_set_dsp_D3,\n\t.load_fw = cnl_load_base_firmware,\n\t.get_fw_errcode = cnl_get_errno,\n};\n\nstatic struct sst_ops cnl_ops = {\n\t.irq_handler = cnl_dsp_sst_interrupt,\n\t.write = sst_shim32_write,\n\t.read = sst_shim32_read,\n\t.free = cnl_dsp_free,\n};\n\n#define CNL_IPC_GLB_NOTIFY_RSP_SHIFT\t29\n#define CNL_IPC_GLB_NOTIFY_RSP_MASK\t0x1\n#define CNL_IPC_GLB_NOTIFY_RSP_TYPE(x)\t(((x) >> CNL_IPC_GLB_NOTIFY_RSP_SHIFT) \\\n\t\t\t\t\t& CNL_IPC_GLB_NOTIFY_RSP_MASK)\n\nstatic irqreturn_t cnl_dsp_irq_thread_handler(int irq, void *context)\n{\n\tstruct sst_dsp *dsp = context;\n\tstruct skl_dev *cnl = dsp->thread_context;\n\tstruct sst_generic_ipc *ipc = &cnl->ipc;\n\tstruct skl_ipc_header header = {0};\n\tu32 hipcida, hipctdr, hipctdd;\n\tint ipc_irq = 0;\n\n\t \n\tif (!(dsp->intr_status & CNL_ADSPIS_IPC))\n\t\treturn IRQ_NONE;\n\n\thipcida = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCIDA);\n\thipctdr = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCTDR);\n\thipctdd = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCTDD);\n\n\t \n\tif (hipcida & CNL_ADSP_REG_HIPCIDA_DONE) {\n\t\tsst_dsp_shim_update_bits(dsp, CNL_ADSP_REG_HIPCCTL,\n\t\t\tCNL_ADSP_REG_HIPCCTL_DONE, 0);\n\n\t\t \n\t\tsst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCIDA,\n\t\t\tCNL_ADSP_REG_HIPCIDA_DONE, CNL_ADSP_REG_HIPCIDA_DONE);\n\n\t\tipc_irq = 1;\n\n\t\t \n\t\tsst_dsp_shim_update_bits(dsp, CNL_ADSP_REG_HIPCCTL,\n\t\t\tCNL_ADSP_REG_HIPCCTL_DONE, CNL_ADSP_REG_HIPCCTL_DONE);\n\t}\n\n\t \n\tif (hipctdr & CNL_ADSP_REG_HIPCTDR_BUSY) {\n\t\theader.primary = hipctdr;\n\t\theader.extension = hipctdd;\n\t\tdev_dbg(dsp->dev, \"IPC irq: Firmware respond primary:%x\",\n\t\t\t\t\t\theader.primary);\n\t\tdev_dbg(dsp->dev, \"IPC irq: Firmware respond extension:%x\",\n\t\t\t\t\t\theader.extension);\n\n\t\tif (CNL_IPC_GLB_NOTIFY_RSP_TYPE(header.primary)) {\n\t\t\t \n\t\t\tskl_ipc_process_reply(ipc, header);\n\t\t} else {\n\t\t\tdev_dbg(dsp->dev, \"IPC irq: Notification from firmware\\n\");\n\t\t\tskl_ipc_process_notification(ipc, header);\n\t\t}\n\t\t \n\t\tsst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCTDR,\n\t\t\tCNL_ADSP_REG_HIPCTDR_BUSY, CNL_ADSP_REG_HIPCTDR_BUSY);\n\n\t\t \n\t\tsst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCTDA,\n\t\t\tCNL_ADSP_REG_HIPCTDA_DONE, CNL_ADSP_REG_HIPCTDA_DONE);\n\t\tipc_irq = 1;\n\t}\n\n\tif (ipc_irq == 0)\n\t\treturn IRQ_NONE;\n\n\tcnl_ipc_int_enable(dsp);\n\n\t \n\tschedule_work(&ipc->kwork);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sst_dsp_device cnl_dev = {\n\t.thread = cnl_dsp_irq_thread_handler,\n\t.ops = &cnl_ops,\n};\n\nstatic void cnl_ipc_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)\n{\n\tstruct skl_ipc_header *header = (struct skl_ipc_header *)(&msg->tx.header);\n\n\tif (msg->tx.size)\n\t\tsst_dsp_outbox_write(ipc->dsp, msg->tx.data, msg->tx.size);\n\tsst_dsp_shim_write_unlocked(ipc->dsp, CNL_ADSP_REG_HIPCIDD,\n\t\t\t\t    header->extension);\n\tsst_dsp_shim_write_unlocked(ipc->dsp, CNL_ADSP_REG_HIPCIDR,\n\t\t\t\theader->primary | CNL_ADSP_REG_HIPCIDR_BUSY);\n}\n\nstatic bool cnl_ipc_is_dsp_busy(struct sst_dsp *dsp)\n{\n\tu32 hipcidr;\n\n\thipcidr = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCIDR);\n\n\treturn (hipcidr & CNL_ADSP_REG_HIPCIDR_BUSY);\n}\n\nstatic int cnl_ipc_init(struct device *dev, struct skl_dev *cnl)\n{\n\tstruct sst_generic_ipc *ipc;\n\tint err;\n\n\tipc = &cnl->ipc;\n\tipc->dsp = cnl->dsp;\n\tipc->dev = dev;\n\n\tipc->tx_data_max_size = CNL_ADSP_W1_SZ;\n\tipc->rx_data_max_size = CNL_ADSP_W0_UP_SZ;\n\n\terr = sst_ipc_init(ipc);\n\tif (err)\n\t\treturn err;\n\n\t \n\tipc->ops.tx_msg = cnl_ipc_tx_msg;\n\tipc->ops.tx_data_copy = skl_ipc_tx_data_copy;\n\tipc->ops.is_dsp_busy = cnl_ipc_is_dsp_busy;\n\n\treturn 0;\n}\n\nint cnl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,\n\t\t     const char *fw_name, struct skl_dsp_loader_ops dsp_ops,\n\t\t     struct skl_dev **dsp)\n{\n\tstruct skl_dev *cnl;\n\tstruct sst_dsp *sst;\n\tint ret;\n\n\tret = skl_sst_ctx_init(dev, irq, fw_name, dsp_ops, dsp, &cnl_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: no device\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tcnl = *dsp;\n\tsst = cnl->dsp;\n\tsst->fw_ops = cnl_fw_ops;\n\tsst->addr.lpe = mmio_base;\n\tsst->addr.shim = mmio_base;\n\tsst->addr.sram0_base = CNL_ADSP_SRAM0_BASE;\n\tsst->addr.sram1_base = CNL_ADSP_SRAM1_BASE;\n\tsst->addr.w0_stat_sz = CNL_ADSP_W0_STAT_SZ;\n\tsst->addr.w0_up_sz = CNL_ADSP_W0_UP_SZ;\n\n\tsst_dsp_mailbox_init(sst, (CNL_ADSP_SRAM0_BASE + CNL_ADSP_W0_STAT_SZ),\n\t\t\t     CNL_ADSP_W0_UP_SZ, CNL_ADSP_SRAM1_BASE,\n\t\t\t     CNL_ADSP_W1_SZ);\n\n\tret = cnl_ipc_init(dev, cnl);\n\tif (ret) {\n\t\tskl_dsp_free(sst);\n\t\treturn ret;\n\t}\n\n\tcnl->boot_complete = false;\n\tinit_waitqueue_head(&cnl->boot_wait);\n\n\treturn skl_dsp_acquire_irq(sst);\n}\nEXPORT_SYMBOL_GPL(cnl_sst_dsp_init);\n\nint cnl_sst_init_fw(struct device *dev, struct skl_dev *skl)\n{\n\tint ret;\n\tstruct sst_dsp *sst = skl->dsp;\n\n\tret = skl->dsp->fw_ops.load_fw(sst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"load base fw failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tskl_dsp_init_core_state(sst);\n\n\tskl->is_first_boot = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cnl_sst_init_fw);\n\nvoid cnl_sst_dsp_cleanup(struct device *dev, struct skl_dev *skl)\n{\n\tif (skl->dsp->fw)\n\t\trelease_firmware(skl->dsp->fw);\n\n\tskl_freeup_uuid_list(skl);\n\tcnl_ipc_free(&skl->ipc);\n\n\tskl->dsp->ops->free(skl->dsp);\n}\nEXPORT_SYMBOL_GPL(cnl_sst_dsp_cleanup);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Cannonlake IPC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}