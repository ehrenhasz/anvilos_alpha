{
  "module_name": "skl-pcm.c",
  "hash_id": "73f8942f7284277a145acc207d0f401f11eb31c543a9082734b9496035540a80",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-pcm.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <sound/hdaudio.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"skl.h\"\n#include \"skl-topology.h\"\n#include \"skl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n\n#define HDA_MONO 1\n#define HDA_STEREO 2\n#define HDA_QUAD 4\n#define HDA_MAX 8\n\nstatic const struct snd_pcm_hardware azx_pcm_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_HAS_WALL_CLOCK |  \n\t\t\t\t SNDRV_PCM_INFO_HAS_LINK_ATIME |\n\t\t\t\t SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |\n\t\t\t\tSNDRV_PCM_RATE_8000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t8,\n\t.buffer_bytes_max =\tAZX_MAX_BUF_SIZE,\n\t.period_bytes_min =\t128,\n\t.period_bytes_max =\tAZX_MAX_BUF_SIZE / 2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tAZX_MAX_FRAG,\n\t.fifo_size =\t\t0,\n};\n\nstatic inline\nstruct hdac_ext_stream *get_hdac_ext_stream(struct snd_pcm_substream *substream)\n{\n\treturn substream->runtime->private_data;\n}\n\nstatic struct hdac_bus *get_bus_ctx(struct snd_pcm_substream *substream)\n{\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\tstruct hdac_stream *hstream = hdac_stream(stream);\n\tstruct hdac_bus *bus = hstream->bus;\n\treturn bus;\n}\n\nstatic int skl_substream_alloc_pages(struct hdac_bus *bus,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t size_t size)\n{\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\n\thdac_stream(stream)->bufsize = 0;\n\thdac_stream(stream)->period_bytes = 0;\n\thdac_stream(stream)->format_val = 0;\n\n\treturn 0;\n}\n\nstatic void skl_set_pcm_constrains(struct hdac_bus *bus,\n\t\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\n\t \n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME,\n\t\t\t\t     20, 178000000);\n}\n\nstatic enum hdac_ext_stream_type skl_get_host_stream_type(struct hdac_bus *bus)\n{\n\tif (bus->ppcap)\n\t\treturn HDAC_EXT_STREAM_TYPE_HOST;\n\telse\n\t\treturn HDAC_EXT_STREAM_TYPE_COUPLED;\n}\n\n \nstatic void skl_set_suspend_active(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_soc_dai *dai, bool enable)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct snd_soc_dapm_widget *w;\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tw = snd_soc_dai_get_widget(dai, substream->stream);\n\n\tif (w->ignore_suspend && enable)\n\t\tskl->supend_active++;\n\telse if (w->ignore_suspend && !enable)\n\t\tskl->supend_active--;\n}\n\nint skl_pcm_host_dma_prepare(struct device *dev, struct skl_pipe_params *params)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tunsigned int format_val;\n\tstruct hdac_stream *hstream;\n\tstruct hdac_ext_stream *stream;\n\tint err;\n\n\thstream = snd_hdac_get_stream(bus, params->stream,\n\t\t\t\t\tparams->host_dma_id + 1);\n\tif (!hstream)\n\t\treturn -EINVAL;\n\n\tstream = stream_to_hdac_ext_stream(hstream);\n\tsnd_hdac_ext_stream_decouple(bus, stream, true);\n\n\tformat_val = snd_hdac_calc_stream_format(params->s_freq,\n\t\t\tparams->ch, params->format, params->host_bps, 0);\n\n\tdev_dbg(dev, \"format_val=%d, rate=%d, ch=%d, format=%d\\n\",\n\t\tformat_val, params->s_freq, params->ch, params->format);\n\n\tsnd_hdac_stream_reset(hdac_stream(stream));\n\terr = snd_hdac_stream_set_params(hdac_stream(stream), format_val);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (HDA_CONTROLLER_IS_APL(skl->pci)) {\n\t\tsnd_hdac_ext_stream_decouple(bus, stream, false);\n\t\terr = snd_hdac_stream_setup(hdac_stream(stream));\n\t\tsnd_hdac_ext_stream_decouple(bus, stream, true);\n\t} else {\n\t\terr = snd_hdac_stream_setup(hdac_stream(stream));\n\t}\n\n\tif (err < 0)\n\t\treturn err;\n\n\thdac_stream(stream)->prepared = 1;\n\n\treturn 0;\n}\n\nint skl_pcm_link_dma_prepare(struct device *dev, struct skl_pipe_params *params)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tunsigned int format_val;\n\tstruct hdac_stream *hstream;\n\tstruct hdac_ext_stream *stream;\n\tstruct hdac_ext_link *link;\n\tunsigned char stream_tag;\n\n\thstream = snd_hdac_get_stream(bus, params->stream,\n\t\t\t\t\tparams->link_dma_id + 1);\n\tif (!hstream)\n\t\treturn -EINVAL;\n\n\tstream = stream_to_hdac_ext_stream(hstream);\n\tsnd_hdac_ext_stream_decouple(bus, stream, true);\n\tformat_val = snd_hdac_calc_stream_format(params->s_freq, params->ch,\n\t\t\t\t\tparams->format, params->link_bps, 0);\n\n\tdev_dbg(dev, \"format_val=%d, rate=%d, ch=%d, format=%d\\n\",\n\t\tformat_val, params->s_freq, params->ch, params->format);\n\n\tsnd_hdac_ext_stream_reset(stream);\n\n\tsnd_hdac_ext_stream_setup(stream, format_val);\n\n\tstream_tag = hstream->stream_tag;\n\tif (stream->hstream.direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tlist_for_each_entry(link, &bus->hlink_list, list) {\n\t\t\tif (link->index == params->link_index)\n\t\t\t\tsnd_hdac_ext_bus_link_set_stream_id(link,\n\t\t\t\t\t\t\t\t    stream_tag);\n\t\t}\n\t}\n\n\tstream->link_prepared = 1;\n\n\treturn 0;\n}\n\nstatic int skl_pcm_open(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct hdac_ext_stream *stream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct skl_dma_params *dma_params;\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tstruct skl_module_cfg *mconfig;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tstream = snd_hdac_ext_stream_assign(bus, substream,\n\t\t\t\t\tskl_get_host_stream_type(bus));\n\tif (stream == NULL)\n\t\treturn -EBUSY;\n\n\tskl_set_pcm_constrains(bus, runtime);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\truntime->hw.info &= ~SNDRV_PCM_INFO_HAS_WALL_CLOCK;  \n\t\truntime->hw.info &= ~SNDRV_PCM_INFO_HAS_LINK_ATIME;\n\t}\n\n\truntime->private_data = stream;\n\n\tdma_params = kzalloc(sizeof(*dma_params), GFP_KERNEL);\n\tif (!dma_params)\n\t\treturn -ENOMEM;\n\n\tdma_params->stream_tag = hdac_stream(stream)->stream_tag;\n\tsnd_soc_dai_set_dma_data(dai, substream, dma_params);\n\n\tdev_dbg(dai->dev, \"stream tag set in dma params=%d\\n\",\n\t\t\t\t dma_params->stream_tag);\n\tskl_set_suspend_active(substream, dai, true);\n\tsnd_pcm_set_sync(substream);\n\n\tmconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);\n\tif (!mconfig) {\n\t\tkfree(dma_params);\n\t\treturn -EINVAL;\n\t}\n\n\tskl_tplg_d0i3_get(skl, mconfig->d0i3_caps);\n\n\treturn 0;\n}\n\nstatic int skl_pcm_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tstruct skl_module_cfg *mconfig;\n\tint ret;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tmconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);\n\n\t \n\tif (mconfig &&\n\t\t(substream->runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\t mconfig->pipe->state == SKL_PIPE_CREATED ||\n\t\t mconfig->pipe->state == SKL_PIPE_PAUSED)) {\n\n\t\tret = skl_reset_pipe(skl, mconfig->pipe);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = skl_pcm_host_dma_prepare(dai->dev,\n\t\t\t\t\tmconfig->pipe->p_params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct skl_pipe_params p_params = {0};\n\tstruct skl_module_cfg *m_cfg;\n\tint ret, dma_id;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\tret = skl_substream_alloc_pages(bus, substream,\n\t\t\t\t\t  params_buffer_bytes(params));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dai->dev, \"format_val, rate=%d, ch=%d, format=%d\\n\",\n\t\t\truntime->rate, runtime->channels, runtime->format);\n\n\tdma_id = hdac_stream(stream)->stream_tag - 1;\n\tdev_dbg(dai->dev, \"dma_id=%d\\n\", dma_id);\n\n\tp_params.s_fmt = snd_pcm_format_width(params_format(params));\n\tp_params.s_cont = snd_pcm_format_physical_width(params_format(params));\n\tp_params.ch = params_channels(params);\n\tp_params.s_freq = params_rate(params);\n\tp_params.host_dma_id = dma_id;\n\tp_params.stream = substream->stream;\n\tp_params.format = params_format(params);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tp_params.host_bps = dai->driver->playback.sig_bits;\n\telse\n\t\tp_params.host_bps = dai->driver->capture.sig_bits;\n\n\n\tm_cfg = skl_tplg_fe_get_cpr_module(dai, p_params.stream);\n\tif (m_cfg)\n\t\tskl_tplg_update_pipe_params(dai->dev, m_cfg, &p_params);\n\n\treturn 0;\n}\n\nstatic void skl_pcm_close(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct skl_dma_params *dma_params = NULL;\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_module_cfg *mconfig;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tsnd_hdac_ext_stream_release(stream, skl_get_host_stream_type(bus));\n\n\tdma_params = snd_soc_dai_get_dma_data(dai, substream);\n\t \n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n\tskl_set_suspend_active(substream, dai, false);\n\n\t \n\tif (!strncmp(dai->name, \"Reference Pin\", 13) &&\n\t\t\tskl->miscbdcg_disabled) {\n\t\tskl->enable_miscbdcge(dai->dev, true);\n\t\tskl->miscbdcg_disabled = false;\n\t}\n\n\tmconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);\n\tif (mconfig)\n\t\tskl_tplg_d0i3_put(skl, mconfig->d0i3_caps);\n\n\tkfree(dma_params);\n}\n\nstatic int skl_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tstruct skl_module_cfg *mconfig;\n\tint ret;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tmconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);\n\n\tif (mconfig) {\n\t\tret = skl_reset_pipe(skl, mconfig->pipe);\n\t\tif (ret < 0)\n\t\t\tdev_err(dai->dev, \"%s:Reset failed ret =%d\",\n\t\t\t\t\t\t__func__, ret);\n\t}\n\n\tsnd_hdac_stream_cleanup(hdac_stream(stream));\n\thdac_stream(stream)->prepared = 0;\n\n\treturn 0;\n}\n\nstatic int skl_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct skl_pipe_params p_params = {0};\n\n\tp_params.s_fmt = snd_pcm_format_width(params_format(params));\n\tp_params.s_cont = snd_pcm_format_physical_width(params_format(params));\n\tp_params.ch = params_channels(params);\n\tp_params.s_freq = params_rate(params);\n\tp_params.stream = substream->stream;\n\n\treturn skl_tplg_be_update_params(dai, &p_params);\n}\n\nstatic int skl_decoupled_trigger(struct snd_pcm_substream *substream,\n\t\tint cmd)\n{\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\tstruct hdac_ext_stream *stream;\n\tint start;\n\tunsigned long cookie;\n\tstruct hdac_stream *hstr;\n\n\tstream = get_hdac_ext_stream(substream);\n\thstr = hdac_stream(stream);\n\n\tif (!hstr->prepared)\n\t\treturn -EPIPE;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tstart = 1;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstart = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&bus->reg_lock, cookie);\n\n\tif (start) {\n\t\tsnd_hdac_stream_start(hdac_stream(stream));\n\t\tsnd_hdac_stream_timecounter_init(hstr, 0);\n\t} else {\n\t\tsnd_hdac_stream_stop(hdac_stream(stream));\n\t}\n\n\tspin_unlock_irqrestore(&bus->reg_lock, cookie);\n\n\treturn 0;\n}\n\nstatic int skl_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tstruct skl_module_cfg *mconfig;\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\tstruct hdac_stream *hstream = hdac_stream(stream);\n\tstruct snd_soc_dapm_widget *w;\n\tint ret;\n\n\tmconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);\n\tif (!mconfig)\n\t\treturn -EIO;\n\n\tw = snd_soc_dai_get_widget(dai, substream->stream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (!w->ignore_suspend) {\n\t\t\t \n\t\t\tsnd_hdac_stream_drsm_enable(bus, true, hstream->index);\n\t\t\tsnd_hdac_stream_set_dpibr(bus, hstream, hstream->lpib);\n\t\t\tsnd_hdac_stream_set_lpib(hstream, hstream->lpib);\n\t\t}\n\t\tfallthrough;\n\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tret = skl_decoupled_trigger(substream, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn skl_run_pipe(skl, mconfig->pipe);\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t \n\t\tret = skl_stop_pipe(skl, mconfig->pipe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = skl_decoupled_trigger(substream, cmd);\n\t\tif ((cmd == SNDRV_PCM_TRIGGER_SUSPEND) && !w->ignore_suspend) {\n\t\t\t \n\t\t\thstream->dpib = readl(bus->remap_addr +\n\t\t\t\t\tAZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t\t(AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\t\thstream->index));\n\n\t\t\thstream->lpib = snd_hdac_stream_get_pos_lpib(hstream);\n\n\t\t\tsnd_hdac_ext_stream_decouple(bus, stream, false);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int skl_link_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct hdac_ext_stream *link_dev;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct skl_pipe_params p_params = {0};\n\tstruct hdac_ext_link *link;\n\tint stream_tag;\n\n\tlink_dev = snd_hdac_ext_stream_assign(bus, substream,\n\t\t\t\t\tHDAC_EXT_STREAM_TYPE_LINK);\n\tif (!link_dev)\n\t\treturn -EBUSY;\n\n\tsnd_soc_dai_set_dma_data(dai, substream, (void *)link_dev);\n\n\tlink = snd_hdac_ext_bus_get_hlink_by_name(bus, codec_dai->component->name);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tstream_tag = hdac_stream(link_dev)->stream_tag;\n\n\t \n\tsnd_soc_dai_set_stream(codec_dai, hdac_stream(link_dev), substream->stream);\n\n\tp_params.s_fmt = snd_pcm_format_width(params_format(params));\n\tp_params.s_cont = snd_pcm_format_physical_width(params_format(params));\n\tp_params.ch = params_channels(params);\n\tp_params.s_freq = params_rate(params);\n\tp_params.stream = substream->stream;\n\tp_params.link_dma_id = stream_tag - 1;\n\tp_params.link_index = link->index;\n\tp_params.format = params_format(params);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tp_params.link_bps = codec_dai->driver->playback.sig_bits;\n\telse\n\t\tp_params.link_bps = codec_dai->driver->capture.sig_bits;\n\n\treturn skl_tplg_be_update_params(dai, &p_params);\n}\n\nstatic int skl_link_pcm_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tstruct skl_module_cfg *mconfig = NULL;\n\n\t \n\tmconfig = skl_tplg_be_get_cpr_module(dai, substream->stream);\n\tif (mconfig && !mconfig->pipe->passthru &&\n\t\t(substream->runtime->state == SNDRV_PCM_STATE_XRUN))\n\t\tskl_reset_pipe(skl, mconfig->pipe);\n\n\treturn 0;\n}\n\nstatic int skl_link_pcm_trigger(struct snd_pcm_substream *substream,\n\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct hdac_ext_stream *link_dev =\n\t\t\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\tstruct hdac_ext_stream *stream = get_hdac_ext_stream(substream);\n\n\tdev_dbg(dai->dev, \"In %s cmd=%d\\n\", __func__, cmd);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_hdac_ext_stream_start(link_dev);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_hdac_ext_stream_clear(link_dev);\n\t\tif (cmd == SNDRV_PCM_TRIGGER_SUSPEND)\n\t\t\tsnd_hdac_ext_stream_decouple(bus, stream, false);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int skl_link_hw_free(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct hdac_ext_stream *link_dev =\n\t\t\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\tstruct hdac_ext_link *link;\n\tunsigned char stream_tag;\n\n\tdev_dbg(dai->dev, \"%s: %s\\n\", __func__, dai->name);\n\n\tlink_dev->link_prepared = 0;\n\n\tlink = snd_hdac_ext_bus_get_hlink_by_name(bus, asoc_rtd_to_codec(rtd, 0)->component->name);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tstream_tag = hdac_stream(link_dev)->stream_tag;\n\t\tsnd_hdac_ext_bus_link_clear_stream_id(link, stream_tag);\n\t}\n\n\tsnd_hdac_ext_stream_release(link_dev, HDAC_EXT_STREAM_TYPE_LINK);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops skl_pcm_dai_ops = {\n\t.startup = skl_pcm_open,\n\t.shutdown = skl_pcm_close,\n\t.prepare = skl_pcm_prepare,\n\t.hw_params = skl_pcm_hw_params,\n\t.hw_free = skl_pcm_hw_free,\n\t.trigger = skl_pcm_trigger,\n};\n\nstatic const struct snd_soc_dai_ops skl_dmic_dai_ops = {\n\t.hw_params = skl_be_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops skl_be_ssp_dai_ops = {\n\t.hw_params = skl_be_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops skl_link_dai_ops = {\n\t.prepare = skl_link_pcm_prepare,\n\t.hw_params = skl_link_hw_params,\n\t.hw_free = skl_link_hw_free,\n\t.trigger = skl_link_pcm_trigger,\n};\n\nstatic struct snd_soc_dai_driver skl_fe_dai[] = {\n{\n\t.name = \"System Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"System Playback\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 32,\n\t},\n\t.capture = {\n\t\t.stream_name = \"System Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"System Pin2\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Headset Playback\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |\n\t\t\tSNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n},\n{\n\t.name = \"Echoref Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"Echoreference Capture\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |\n\t\t\tSNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n},\n{\n\t.name = \"Reference Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"Reference Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_QUAD,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"Deepbuffer Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Deepbuffer Playback\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"LowLatency Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Low Latency Playback\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"DMIC Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"DMIC Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_QUAD,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"HDMI1 Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"HDMI1 Playback\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\tSNDRV_PCM_RATE_44100 |\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\tSNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"HDMI2 Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"HDMI2 Playback\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\tSNDRV_PCM_RATE_44100 |\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\tSNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n{\n\t.name = \"HDMI3 Pin\",\n\t.ops = &skl_pcm_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"HDMI3 Playback\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\tSNDRV_PCM_RATE_44100 |\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\tSNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 32,\n\t},\n},\n};\n\n \nstatic struct snd_soc_dai_driver skl_platform_dai[] = {\n{\n\t.name = \"SSP0 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp0 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp0 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"SSP1 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp1 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp1 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"SSP2 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp2 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp2 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"SSP3 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp3 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp3 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"SSP4 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp4 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp4 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"SSP5 Pin\",\n\t.ops = &skl_be_ssp_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"ssp5 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ssp5 Rx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = HDA_STEREO,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"iDisp1 Pin\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"iDisp1 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name = \"iDisp2 Pin\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"iDisp2 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|\n\t\t\tSNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name = \"iDisp3 Pin\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"iDisp3 Tx\",\n\t\t.channels_min = HDA_STEREO,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|\n\t\t\tSNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name = \"DMIC01 Pin\",\n\t.ops = &skl_dmic_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"DMIC01 Rx\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_QUAD,\n\t\t.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n},\n{\n\t.name = \"DMIC16k Pin\",\n\t.ops = &skl_dmic_dai_ops,\n\t.capture = {\n\t\t.stream_name = \"DMIC16k Rx\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_QUAD,\n\t\t.rates = SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n},\n{\n\t.name = \"Analog CPU DAI\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Analog CPU Playback\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Analog CPU Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n},\n{\n\t.name = \"Alt Analog CPU DAI\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Alt Analog CPU Playback\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Alt Analog CPU Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n},\n{\n\t.name = \"Digital CPU DAI\",\n\t.ops = &skl_link_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"Digital CPU Playback\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Digital CPU Capture\",\n\t\t.channels_min = HDA_MONO,\n\t\t.channels_max = HDA_MAX,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t},\n},\n};\n\nint skl_dai_load(struct snd_soc_component *cmp, int index,\n\t\t\tstruct snd_soc_dai_driver *dai_drv,\n\t\t\tstruct snd_soc_tplg_pcm *pcm, struct snd_soc_dai *dai)\n{\n\tdai_drv->ops = &skl_pcm_dai_ops;\n\n\treturn 0;\n}\n\nstatic int skl_platform_soc_open(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"In %s:%s\\n\", __func__,\n\t\t\t\t\tdai_link->cpus->dai_name);\n\n\tsnd_soc_set_runtime_hwparams(substream, &azx_pcm_hw);\n\n\treturn 0;\n}\n\nstatic int skl_coupled_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\tstruct hdac_ext_stream *stream;\n\tstruct snd_pcm_substream *s;\n\tbool start;\n\tint sbits = 0;\n\tunsigned long cookie;\n\tstruct hdac_stream *hstr;\n\n\tstream = get_hdac_ext_stream(substream);\n\thstr = hdac_stream(stream);\n\n\tdev_dbg(bus->dev, \"In %s cmd=%d\\n\", __func__, cmd);\n\n\tif (!hstr->prepared)\n\t\treturn -EPIPE;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tstart = true;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstart = false;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\tcontinue;\n\t\tstream = get_hdac_ext_stream(s);\n\t\tsbits |= 1 << hdac_stream(stream)->index;\n\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\n\tspin_lock_irqsave(&bus->reg_lock, cookie);\n\n\t \n\tsnd_hdac_stream_sync_trigger(hstr, true, sbits, AZX_REG_SSYNC);\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\tcontinue;\n\t\tstream = get_hdac_ext_stream(s);\n\t\tif (start)\n\t\t\tsnd_hdac_stream_start(hdac_stream(stream));\n\t\telse\n\t\t\tsnd_hdac_stream_stop(hdac_stream(stream));\n\t}\n\tspin_unlock_irqrestore(&bus->reg_lock, cookie);\n\n\tsnd_hdac_stream_sync(hstr, start, sbits);\n\n\tspin_lock_irqsave(&bus->reg_lock, cookie);\n\n\t \n\tsnd_hdac_stream_sync_trigger(hstr, false, sbits, AZX_REG_SSYNC);\n\tif (start)\n\t\tsnd_hdac_stream_timecounter_init(hstr, sbits);\n\tspin_unlock_irqrestore(&bus->reg_lock, cookie);\n\n\treturn 0;\n}\n\nstatic int skl_platform_soc_trigger(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\n\tif (!bus->ppcap)\n\t\treturn skl_coupled_trigger(substream, cmd);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t skl_platform_soc_pointer(\n\tstruct snd_soc_component *component,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct hdac_ext_stream *hstream = get_hdac_ext_stream(substream);\n\tstruct hdac_bus *bus = get_bus_ctx(substream);\n\tunsigned int pos;\n\n\t \n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tpos = readl(bus->remap_addr + AZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t(AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\thdac_stream(hstream)->index));\n\t} else {\n\t\tudelay(20);\n\t\treadl(bus->remap_addr +\n\t\t\t\tAZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t(AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\t hdac_stream(hstream)->index));\n\t\tpos = snd_hdac_stream_get_pos_posbuf(hdac_stream(hstream));\n\t}\n\n\tif (pos >= hdac_stream(hstream)->bufsize)\n\t\tpos = 0;\n\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic u64 skl_adjust_codec_delay(struct snd_pcm_substream *substream,\n\t\t\t\tu64 nsec)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tu64 codec_frames, codec_nsecs;\n\n\tif (!codec_dai->driver->ops->delay)\n\t\treturn nsec;\n\n\tcodec_frames = codec_dai->driver->ops->delay(substream, codec_dai);\n\tcodec_nsecs = div_u64(codec_frames * 1000000000LL,\n\t\t\t      substream->runtime->rate);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn nsec + codec_nsecs;\n\n\treturn (nsec > codec_nsecs) ? nsec - codec_nsecs : 0;\n}\n\nstatic int skl_platform_soc_get_time_info(\n\t\t\tstruct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct timespec64 *system_ts, struct timespec64 *audio_ts,\n\t\t\tstruct snd_pcm_audio_tstamp_config *audio_tstamp_config,\n\t\t\tstruct snd_pcm_audio_tstamp_report *audio_tstamp_report)\n{\n\tstruct hdac_ext_stream *sstream = get_hdac_ext_stream(substream);\n\tstruct hdac_stream *hstr = hdac_stream(sstream);\n\tu64 nsec;\n\n\tif ((substream->runtime->hw.info & SNDRV_PCM_INFO_HAS_LINK_ATIME) &&\n\t\t(audio_tstamp_config->type_requested == SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK)) {\n\n\t\tsnd_pcm_gettime(substream->runtime, system_ts);\n\n\t\tnsec = timecounter_read(&hstr->tc);\n\t\tif (audio_tstamp_config->report_delay)\n\t\t\tnsec = skl_adjust_codec_delay(substream, nsec);\n\n\t\t*audio_ts = ns_to_timespec64(nsec);\n\n\t\taudio_tstamp_report->actual_type = SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK;\n\t\taudio_tstamp_report->accuracy_report = 1;  \n\t\taudio_tstamp_report->accuracy = 42;  \n\n\t} else {\n\t\taudio_tstamp_report->actual_type = SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT;\n\t}\n\n\treturn 0;\n}\n\n#define MAX_PREALLOC_SIZE\t(32 * 1024 * 1024)\n\nstatic int skl_platform_soc_new(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct hdac_bus *bus = dev_get_drvdata(dai->dev);\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tunsigned int size;\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tif (dai->driver->playback.channels_min ||\n\t\tdai->driver->capture.channels_min) {\n\t\t \n\t\tsize = CONFIG_SND_HDA_PREALLOC_SIZE * 1024;\n\t\tif (size > MAX_PREALLOC_SIZE)\n\t\t\tsize = MAX_PREALLOC_SIZE;\n\t\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\t\t\t       SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t       &skl->pci->dev,\n\t\t\t\t\t       size, MAX_PREALLOC_SIZE);\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_get_module_info(struct skl_dev *skl,\n\t\tstruct skl_module_cfg *mconfig)\n{\n\tstruct skl_module_inst_id *pin_id;\n\tguid_t *uuid_mod, *uuid_tplg;\n\tstruct skl_module *skl_module;\n\tstruct uuid_module *module;\n\tint i, ret = -EIO;\n\n\tuuid_mod = (guid_t *)mconfig->guid;\n\n\tif (list_empty(&skl->uuid_list)) {\n\t\tdev_err(skl->dev, \"Module list is empty\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < skl->nr_modules; i++) {\n\t\tskl_module = skl->modules[i];\n\t\tuuid_tplg = &skl_module->uuid;\n\t\tif (guid_equal(uuid_mod, uuid_tplg)) {\n\t\t\tmconfig->module = skl_module;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skl->nr_modules && ret)\n\t\treturn ret;\n\n\tret = -EIO;\n\tlist_for_each_entry(module, &skl->uuid_list, list) {\n\t\tif (guid_equal(uuid_mod, &module->uuid)) {\n\t\t\tmconfig->id.module_id = module->id;\n\t\t\tmconfig->module->loadable = module->is_loadable;\n\t\t\tret = 0;\n\t\t}\n\n\t\tfor (i = 0; i < MAX_IN_QUEUE; i++) {\n\t\t\tpin_id = &mconfig->m_in_pin[i].id;\n\t\t\tif (guid_equal(&pin_id->mod_uuid, &module->uuid))\n\t\t\t\tpin_id->module_id = module->id;\n\t\t}\n\n\t\tfor (i = 0; i < MAX_OUT_QUEUE; i++) {\n\t\t\tpin_id = &mconfig->m_out_pin[i].id;\n\t\t\tif (guid_equal(&pin_id->mod_uuid, &module->uuid))\n\t\t\t\tpin_id->module_id = module->id;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int skl_populate_modules(struct skl_dev *skl)\n{\n\tstruct skl_pipeline *p;\n\tstruct skl_pipe_module *m;\n\tstruct snd_soc_dapm_widget *w;\n\tstruct skl_module_cfg *mconfig;\n\tint ret = 0;\n\n\tlist_for_each_entry(p, &skl->ppl_list, node) {\n\t\tlist_for_each_entry(m, &p->pipe->w_list, node) {\n\t\t\tw = m->w;\n\t\t\tmconfig = w->priv;\n\n\t\t\tret = skl_get_module_info(skl, mconfig);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(skl->dev,\n\t\t\t\t\t\"query module info failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tskl_tplg_add_moduleid_in_bind_params(skl, w);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int skl_platform_soc_probe(struct snd_soc_component *component)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(component->dev);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tconst struct skl_dsp_ops *ops;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tif (bus->ppcap) {\n\t\tskl->component = component;\n\n\t\t \n\t\tskl->debugfs = skl_debugfs_init(skl);\n\n\t\tret = skl_tplg_init(component, bus);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to init topology!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tops = skl_get_dsp_ops(skl->pci->device);\n\t\tif (!ops)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tskl->enable_miscbdcge(component->dev, false);\n\t\tskl->clock_power_gating(component->dev, false);\n\n\t\tret = ops->init_fw(component->dev, skl);\n\t\tskl->enable_miscbdcge(component->dev, true);\n\t\tskl->clock_power_gating(component->dev, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to boot first fw: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tskl_populate_modules(skl);\n\t\tskl->update_d0i3c = skl_update_d0i3c;\n\n\t\tif (skl->cfg.astate_cfg != NULL) {\n\t\t\tskl_dsp_set_astate_cfg(skl,\n\t\t\t\t\tskl->cfg.astate_cfg->count,\n\t\t\t\t\tskl->cfg.astate_cfg);\n\t\t}\n\t}\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n\n\treturn 0;\n}\n\nstatic void skl_platform_soc_remove(struct snd_soc_component *component)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(component->dev);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tskl_tplg_exit(component, bus);\n\n\tskl_debugfs_exit(skl);\n}\n\nstatic const struct snd_soc_component_driver skl_component  = {\n\t.name\t\t= \"pcm\",\n\t.probe\t\t= skl_platform_soc_probe,\n\t.remove\t\t= skl_platform_soc_remove,\n\t.open\t\t= skl_platform_soc_open,\n\t.trigger\t= skl_platform_soc_trigger,\n\t.pointer\t= skl_platform_soc_pointer,\n\t.get_time_info\t= skl_platform_soc_get_time_info,\n\t.pcm_construct\t= skl_platform_soc_new,\n\t.module_get_upon_open = 1,  \n};\n\nint skl_platform_register(struct device *dev)\n{\n\tint ret;\n\tstruct snd_soc_dai_driver *dais;\n\tint num_dais = ARRAY_SIZE(skl_platform_dai);\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\tskl->dais = kmemdup(skl_platform_dai, sizeof(skl_platform_dai),\n\t\t\t    GFP_KERNEL);\n\tif (!skl->dais) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (!skl->use_tplg_pcm) {\n\t\tdais = krealloc(skl->dais, sizeof(skl_fe_dai) +\n\t\t\t\tsizeof(skl_platform_dai), GFP_KERNEL);\n\t\tif (!dais) {\n\t\t\tkfree(skl->dais);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskl->dais = dais;\n\t\tmemcpy(&skl->dais[ARRAY_SIZE(skl_platform_dai)], skl_fe_dai,\n\t\t       sizeof(skl_fe_dai));\n\t\tnum_dais += ARRAY_SIZE(skl_fe_dai);\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &skl_component,\n\t\t\t\t\t skl->dais, num_dais);\n\tif (ret) {\n\t\tkfree(skl->dais);\n\t\tdev_err(dev, \"soc component registration failed %d\\n\", ret);\n\t}\nerr:\n\treturn ret;\n}\n\nint skl_platform_unregister(struct device *dev)\n{\n\tstruct hdac_bus *bus = dev_get_drvdata(dev);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_module_deferred_bind *modules, *tmp;\n\n\tlist_for_each_entry_safe(modules, tmp, &skl->bind_list, node) {\n\t\tlist_del(&modules->node);\n\t\tkfree(modules);\n\t}\n\n\tkfree(skl->dais);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}