{
  "module_name": "skl-topology.c",
  "hash_id": "53e2da04281a8d0258c7de5cdd4682a4e04b39225d72b228aec296c1cd00a9c1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/skylake/skl-topology.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/firmware.h>\n#include <linux/uuid.h>\n#include <sound/intel-nhlt.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-topology.h>\n#include <uapi/sound/snd_sst_tokens.h>\n#include <uapi/sound/skl-tplg-interface.h>\n#include \"skl-sst-dsp.h\"\n#include \"skl-sst-ipc.h\"\n#include \"skl-topology.h\"\n#include \"skl.h\"\n#include \"../common/sst-dsp.h\"\n#include \"../common/sst-dsp-priv.h\"\n\n#define SKL_CH_FIXUP_MASK\t\t(1 << 0)\n#define SKL_RATE_FIXUP_MASK\t\t(1 << 1)\n#define SKL_FMT_FIXUP_MASK\t\t(1 << 2)\n#define SKL_IN_DIR_BIT_MASK\t\tBIT(0)\n#define SKL_PIN_COUNT_MASK\t\tGENMASK(7, 4)\n\nstatic const int mic_mono_list[] = {\n0, 1, 2, 3,\n};\nstatic const int mic_stereo_list[][SKL_CH_STEREO] = {\n{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3},\n};\nstatic const int mic_trio_list[][SKL_CH_TRIO] = {\n{0, 1, 2}, {0, 1, 3}, {0, 2, 3}, {1, 2, 3},\n};\nstatic const int mic_quatro_list[][SKL_CH_QUATRO] = {\n{0, 1, 2, 3},\n};\n\n#define CHECK_HW_PARAMS(ch, freq, bps, prm_ch, prm_freq, prm_bps) \\\n\t((ch == prm_ch) && (bps == prm_bps) && (freq == prm_freq))\n\nvoid skl_tplg_d0i3_get(struct skl_dev *skl, enum d0i3_capability caps)\n{\n\tstruct skl_d0i3_data *d0i3 =  &skl->d0i3;\n\n\tswitch (caps) {\n\tcase SKL_D0I3_NONE:\n\t\td0i3->non_d0i3++;\n\t\tbreak;\n\n\tcase SKL_D0I3_STREAMING:\n\t\td0i3->streaming++;\n\t\tbreak;\n\n\tcase SKL_D0I3_NON_STREAMING:\n\t\td0i3->non_streaming++;\n\t\tbreak;\n\t}\n}\n\nvoid skl_tplg_d0i3_put(struct skl_dev *skl, enum d0i3_capability caps)\n{\n\tstruct skl_d0i3_data *d0i3 =  &skl->d0i3;\n\n\tswitch (caps) {\n\tcase SKL_D0I3_NONE:\n\t\td0i3->non_d0i3--;\n\t\tbreak;\n\n\tcase SKL_D0I3_STREAMING:\n\t\td0i3->streaming--;\n\t\tbreak;\n\n\tcase SKL_D0I3_NON_STREAMING:\n\t\td0i3->non_streaming--;\n\t\tbreak;\n\t}\n}\n\n \nstatic int is_skl_dsp_widget_type(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct device *dev)\n{\n\tif (w->dapm->dev != dev)\n\t\treturn false;\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_dai_link:\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_dai_out:\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_output:\n\tcase snd_soc_dapm_mux:\n\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void skl_dump_mconfig(struct skl_dev *skl, struct skl_module_cfg *mcfg)\n{\n\tstruct skl_module_iface *iface = &mcfg->module->formats[mcfg->fmt_idx];\n\n\tdev_dbg(skl->dev, \"Dumping config\\n\");\n\tdev_dbg(skl->dev, \"Input Format:\\n\");\n\tdev_dbg(skl->dev, \"channels = %d\\n\", iface->inputs[0].fmt.channels);\n\tdev_dbg(skl->dev, \"s_freq = %d\\n\", iface->inputs[0].fmt.s_freq);\n\tdev_dbg(skl->dev, \"ch_cfg = %d\\n\", iface->inputs[0].fmt.ch_cfg);\n\tdev_dbg(skl->dev, \"valid bit depth = %d\\n\",\n\t\t\t\tiface->inputs[0].fmt.valid_bit_depth);\n\tdev_dbg(skl->dev, \"Output Format:\\n\");\n\tdev_dbg(skl->dev, \"channels = %d\\n\", iface->outputs[0].fmt.channels);\n\tdev_dbg(skl->dev, \"s_freq = %d\\n\", iface->outputs[0].fmt.s_freq);\n\tdev_dbg(skl->dev, \"valid bit depth = %d\\n\",\n\t\t\t\tiface->outputs[0].fmt.valid_bit_depth);\n\tdev_dbg(skl->dev, \"ch_cfg = %d\\n\", iface->outputs[0].fmt.ch_cfg);\n}\n\nstatic void skl_tplg_update_chmap(struct skl_module_fmt *fmt, int chs)\n{\n\tint slot_map = 0xFFFFFFFF;\n\tint start_slot = 0;\n\tint i;\n\n\tfor (i = 0; i < chs; i++) {\n\t\t \n\t\tslot_map &= (~(0xF << (4 * i)) | (start_slot << (4 * i)));\n\t\tstart_slot++;\n\t}\n\tfmt->ch_map = slot_map;\n}\n\nstatic void skl_tplg_update_params(struct skl_module_fmt *fmt,\n\t\t\tstruct skl_pipe_params *params, int fixup)\n{\n\tif (fixup & SKL_RATE_FIXUP_MASK)\n\t\tfmt->s_freq = params->s_freq;\n\tif (fixup & SKL_CH_FIXUP_MASK) {\n\t\tfmt->channels = params->ch;\n\t\tskl_tplg_update_chmap(fmt, fmt->channels);\n\t}\n\tif (fixup & SKL_FMT_FIXUP_MASK) {\n\t\tfmt->valid_bit_depth = skl_get_bit_depth(params->s_fmt);\n\n\t\t \n\t\tswitch (fmt->valid_bit_depth) {\n\t\tcase SKL_DEPTH_16BIT:\n\t\t\tfmt->bit_depth = fmt->valid_bit_depth;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt->bit_depth = SKL_DEPTH_32BIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\n \nstatic void skl_tplg_update_params_fixup(struct skl_module_cfg *m_cfg,\n\t\tstruct skl_pipe_params *params, bool is_fe)\n{\n\tint in_fixup, out_fixup;\n\tstruct skl_module_fmt *in_fmt, *out_fmt;\n\n\t \n\tin_fmt = &m_cfg->module->formats[m_cfg->fmt_idx].inputs[0].fmt;\n\tout_fmt = &m_cfg->module->formats[m_cfg->fmt_idx].outputs[0].fmt;\n\n\tif (params->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (is_fe) {\n\t\t\tin_fixup = m_cfg->params_fixup;\n\t\t\tout_fixup = (~m_cfg->converter) &\n\t\t\t\t\tm_cfg->params_fixup;\n\t\t} else {\n\t\t\tout_fixup = m_cfg->params_fixup;\n\t\t\tin_fixup = (~m_cfg->converter) &\n\t\t\t\t\tm_cfg->params_fixup;\n\t\t}\n\t} else {\n\t\tif (is_fe) {\n\t\t\tout_fixup = m_cfg->params_fixup;\n\t\t\tin_fixup = (~m_cfg->converter) &\n\t\t\t\t\tm_cfg->params_fixup;\n\t\t} else {\n\t\t\tin_fixup = m_cfg->params_fixup;\n\t\t\tout_fixup = (~m_cfg->converter) &\n\t\t\t\t\tm_cfg->params_fixup;\n\t\t}\n\t}\n\n\tskl_tplg_update_params(in_fmt, params, in_fixup);\n\tskl_tplg_update_params(out_fmt, params, out_fixup);\n}\n\n \nstatic void skl_tplg_update_buffer_size(struct skl_dev *skl,\n\t\t\t\tstruct skl_module_cfg *mcfg)\n{\n\tint multiplier = 1;\n\tstruct skl_module_fmt *in_fmt, *out_fmt;\n\tstruct skl_module_res *res;\n\n\t \n\tres = &mcfg->module->resources[mcfg->res_idx];\n\tin_fmt = &mcfg->module->formats[mcfg->fmt_idx].inputs[0].fmt;\n\tout_fmt = &mcfg->module->formats[mcfg->fmt_idx].outputs[0].fmt;\n\n\tif (mcfg->m_type == SKL_MODULE_TYPE_SRCINT)\n\t\tmultiplier = 5;\n\n\tres->ibs = DIV_ROUND_UP(in_fmt->s_freq, 1000) *\n\t\t\tin_fmt->channels * (in_fmt->bit_depth >> 3) *\n\t\t\tmultiplier;\n\n\tres->obs = DIV_ROUND_UP(out_fmt->s_freq, 1000) *\n\t\t\tout_fmt->channels * (out_fmt->bit_depth >> 3) *\n\t\t\tmultiplier;\n}\n\nstatic u8 skl_tplg_be_dev_type(int dev_type)\n{\n\tint ret;\n\n\tswitch (dev_type) {\n\tcase SKL_DEVICE_BT:\n\t\tret = NHLT_DEVICE_BT;\n\t\tbreak;\n\n\tcase SKL_DEVICE_DMIC:\n\t\tret = NHLT_DEVICE_DMIC;\n\t\tbreak;\n\n\tcase SKL_DEVICE_I2S:\n\t\tret = NHLT_DEVICE_I2S;\n\t\tbreak;\n\n\tdefault:\n\t\tret = NHLT_DEVICE_INVALID;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int skl_tplg_update_be_blob(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *m_cfg = w->priv;\n\tint link_type, dir;\n\tu32 ch, s_freq, s_fmt, s_cont;\n\tstruct nhlt_specific_cfg *cfg;\n\tu8 dev_type = skl_tplg_be_dev_type(m_cfg->dev_type);\n\tint fmt_idx = m_cfg->fmt_idx;\n\tstruct skl_module_iface *m_iface = &m_cfg->module->formats[fmt_idx];\n\n\t \n\tif (m_cfg->formats_config[SKL_PARAM_INIT].caps_size > 0)\n\t\treturn 0;\n\n\tdev_dbg(skl->dev, \"Applying default cfg blob\\n\");\n\tswitch (m_cfg->dev_type) {\n\tcase SKL_DEVICE_DMIC:\n\t\tlink_type = NHLT_LINK_DMIC;\n\t\tdir = SNDRV_PCM_STREAM_CAPTURE;\n\t\ts_freq = m_iface->inputs[0].fmt.s_freq;\n\t\ts_fmt = m_iface->inputs[0].fmt.valid_bit_depth;\n\t\ts_cont = m_iface->inputs[0].fmt.bit_depth;\n\t\tch = m_iface->inputs[0].fmt.channels;\n\t\tbreak;\n\n\tcase SKL_DEVICE_I2S:\n\t\tlink_type = NHLT_LINK_SSP;\n\t\tif (m_cfg->hw_conn_type == SKL_CONN_SOURCE) {\n\t\t\tdir = SNDRV_PCM_STREAM_PLAYBACK;\n\t\t\ts_freq = m_iface->outputs[0].fmt.s_freq;\n\t\t\ts_fmt = m_iface->outputs[0].fmt.valid_bit_depth;\n\t\t\ts_cont = m_iface->outputs[0].fmt.bit_depth;\n\t\t\tch = m_iface->outputs[0].fmt.channels;\n\t\t} else {\n\t\t\tdir = SNDRV_PCM_STREAM_CAPTURE;\n\t\t\ts_freq = m_iface->inputs[0].fmt.s_freq;\n\t\t\ts_fmt = m_iface->inputs[0].fmt.valid_bit_depth;\n\t\t\ts_cont = m_iface->inputs[0].fmt.bit_depth;\n\t\t\tch = m_iface->inputs[0].fmt.channels;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcfg = intel_nhlt_get_endpoint_blob(skl->dev, skl->nhlt, m_cfg->vbus_id,\n\t\t\t\t\t   link_type, s_fmt, s_cont, ch,\n\t\t\t\t\t   s_freq, dir, dev_type);\n\tif (cfg) {\n\t\tm_cfg->formats_config[SKL_PARAM_INIT].caps_size = cfg->size;\n\t\tm_cfg->formats_config[SKL_PARAM_INIT].caps = (u32 *)&cfg->caps;\n\t} else {\n\t\tdev_err(skl->dev, \"Blob NULL for id %x type %d dirn %d\\n\",\n\t\t\t\t\tm_cfg->vbus_id, link_type, dir);\n\t\tdev_err(skl->dev, \"PCM: ch %d, freq %d, fmt %d/%d\\n\",\n\t\t\t\t\tch, s_freq, s_fmt, s_cont);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void skl_tplg_update_module_params(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *m_cfg = w->priv;\n\tstruct skl_pipe_params *params = m_cfg->pipe->p_params;\n\tint p_conn_type = m_cfg->pipe->conn_type;\n\tbool is_fe;\n\n\tif (!m_cfg->params_fixup)\n\t\treturn;\n\n\tdev_dbg(skl->dev, \"Mconfig for widget=%s BEFORE updation\\n\",\n\t\t\t\tw->name);\n\n\tskl_dump_mconfig(skl, m_cfg);\n\n\tif (p_conn_type == SKL_PIPE_CONN_TYPE_FE)\n\t\tis_fe = true;\n\telse\n\t\tis_fe = false;\n\n\tskl_tplg_update_params_fixup(m_cfg, params, is_fe);\n\tskl_tplg_update_buffer_size(skl, m_cfg);\n\n\tdev_dbg(skl->dev, \"Mconfig for widget=%s AFTER updation\\n\",\n\t\t\t\tw->name);\n\n\tskl_dump_mconfig(skl, m_cfg);\n}\n\n \nstatic int skl_tplg_set_module_params(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tint i, ret;\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tconst struct snd_kcontrol_new *k;\n\tstruct soc_bytes_ext *sb;\n\tstruct skl_algo_data *bc;\n\tstruct skl_specific_cfg *sp_cfg;\n\n\tif (mconfig->formats_config[SKL_PARAM_SET].caps_size > 0 &&\n\t    mconfig->formats_config[SKL_PARAM_SET].set_params == SKL_PARAM_SET) {\n\t\tsp_cfg = &mconfig->formats_config[SKL_PARAM_SET];\n\t\tret = skl_set_module_params(skl, sp_cfg->caps,\n\t\t\t\t\tsp_cfg->caps_size,\n\t\t\t\t\tsp_cfg->param_id, mconfig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tk = &w->kcontrol_news[i];\n\t\tif (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\t\tsb = (void *) k->private_value;\n\t\t\tbc = (struct skl_algo_data *)sb->dobj.private;\n\n\t\t\tif (bc->set_params == SKL_PARAM_SET) {\n\t\t\t\tret = skl_set_module_params(skl,\n\t\t\t\t\t\t(u32 *)bc->params, bc->size,\n\t\t\t\t\t\tbc->param_id, mconfig);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_set_module_init_data(struct snd_soc_dapm_widget *w)\n{\n\tconst struct snd_kcontrol_new *k;\n\tstruct soc_bytes_ext *sb;\n\tstruct skl_algo_data *bc;\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tint i;\n\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tk = &w->kcontrol_news[i];\n\t\tif (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\t\tsb = (struct soc_bytes_ext *)k->private_value;\n\t\t\tbc = (struct skl_algo_data *)sb->dobj.private;\n\n\t\t\tif (bc->set_params != SKL_PARAM_INIT)\n\t\t\t\tcontinue;\n\n\t\t\tmconfig->formats_config[SKL_PARAM_INIT].caps =\n\t\t\t\t\t\t\t(u32 *)bc->params;\n\t\t\tmconfig->formats_config[SKL_PARAM_INIT].caps_size =\n\t\t\t\t\t\t\t\tbc->size;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_module_prepare(struct skl_dev *skl, struct skl_pipe *pipe,\n\t\tstruct snd_soc_dapm_widget *w, struct skl_module_cfg *mcfg)\n{\n\tswitch (mcfg->dev_type) {\n\tcase SKL_DEVICE_HDAHOST:\n\t\treturn skl_pcm_host_dma_prepare(skl->dev, pipe->p_params);\n\n\tcase SKL_DEVICE_HDALINK:\n\t\treturn skl_pcm_link_dma_prepare(skl->dev, pipe->p_params);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nskl_tplg_init_pipe_modules(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tstruct skl_pipe_module *w_module;\n\tstruct snd_soc_dapm_widget *w;\n\tstruct skl_module_cfg *mconfig;\n\tu8 cfg_idx;\n\tint ret = 0;\n\n\tlist_for_each_entry(w_module, &pipe->w_list, node) {\n\t\tguid_t *uuid_mod;\n\t\tw = w_module->w;\n\t\tmconfig = w->priv;\n\n\t\t \n\t\tif (mconfig->id.module_id < 0) {\n\t\t\tdev_err(skl->dev,\n\t\t\t\t\t\"module %pUL id not populated\\n\",\n\t\t\t\t\t(guid_t *)mconfig->guid);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcfg_idx = mconfig->pipe->cur_config_idx;\n\t\tmconfig->fmt_idx = mconfig->mod_cfg[cfg_idx].fmt_idx;\n\t\tmconfig->res_idx = mconfig->mod_cfg[cfg_idx].res_idx;\n\n\t\tif (mconfig->module->loadable && skl->dsp->fw_ops.load_mod) {\n\t\t\tret = skl->dsp->fw_ops.load_mod(skl->dsp,\n\t\t\t\tmconfig->id.module_id, mconfig->guid);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = skl_tplg_module_prepare(skl, pipe, w, mconfig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tskl_tplg_update_be_blob(w, skl);\n\n\t\t \n\t\tskl_tplg_update_module_params(w, skl);\n\t\tuuid_mod = (guid_t *)mconfig->guid;\n\t\tmconfig->id.pvt_id = skl_get_pvt_id(skl, uuid_mod,\n\t\t\t\t\t\tmconfig->id.instance_id);\n\t\tif (mconfig->id.pvt_id < 0)\n\t\t\treturn ret;\n\t\tskl_tplg_set_module_init_data(w);\n\n\t\tret = skl_dsp_get_core(skl->dsp, mconfig->core_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(skl->dev, \"Failed to wake up core %d ret=%d\\n\",\n\t\t\t\t\t\tmconfig->core_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = skl_init_module(skl, mconfig);\n\t\tif (ret < 0) {\n\t\t\tskl_put_pvt_id(skl, uuid_mod, &mconfig->id.pvt_id);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = skl_tplg_set_module_params(w, skl);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tskl_dsp_put_core(skl->dsp, mconfig->core_id);\n\treturn ret;\n}\n\nstatic int skl_tplg_unload_pipe_modules(struct skl_dev *skl,\n\t struct skl_pipe *pipe)\n{\n\tint ret = 0;\n\tstruct skl_pipe_module *w_module;\n\tstruct skl_module_cfg *mconfig;\n\n\tlist_for_each_entry(w_module, &pipe->w_list, node) {\n\t\tguid_t *uuid_mod;\n\t\tmconfig  = w_module->w->priv;\n\t\tuuid_mod = (guid_t *)mconfig->guid;\n\n\t\tif (mconfig->module->loadable && skl->dsp->fw_ops.unload_mod) {\n\t\t\tret = skl->dsp->fw_ops.unload_mod(skl->dsp,\n\t\t\t\t\t\tmconfig->id.module_id);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tskl_put_pvt_id(skl, uuid_mod, &mconfig->id.pvt_id);\n\n\t\tret = skl_dsp_put_core(skl->dsp, mconfig->core_id);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_err(skl->dev, \"Failed to sleep core %d ret=%d\\n\",\n\t\t\t\tmconfig->core_id, ret);\n\t\t}\n\t}\n\n\t \n\treturn ret;\n}\n\nstatic void skl_tplg_set_pipe_config_idx(struct skl_pipe *pipe, int idx)\n{\n\tpipe->cur_config_idx = idx;\n\tpipe->memory_pages = pipe->configs[idx].mem_pages;\n}\n\n \nstatic int\nskl_tplg_get_pipe_config(struct skl_dev *skl, struct skl_module_cfg *mconfig)\n{\n\tstruct skl_pipe *pipe = mconfig->pipe;\n\tstruct skl_pipe_params *params = pipe->p_params;\n\tstruct skl_path_config *pconfig = &pipe->configs[0];\n\tstruct skl_pipe_fmt *fmt = NULL;\n\tbool in_fmt = false;\n\tint i;\n\n\tif (pipe->nr_cfgs == 0) {\n\t\tskl_tplg_set_pipe_config_idx(pipe, 0);\n\t\treturn 0;\n\t}\n\n\tif (pipe->conn_type == SKL_PIPE_CONN_TYPE_NONE || pipe->nr_cfgs == 1) {\n\t\tdev_dbg(skl->dev, \"No conn_type or just 1 pathcfg, taking 0th for %d\\n\",\n\t\t\tpipe->ppl_id);\n\t\tskl_tplg_set_pipe_config_idx(pipe, 0);\n\t\treturn 0;\n\t}\n\n\tif ((pipe->conn_type == SKL_PIPE_CONN_TYPE_FE &&\n\t     pipe->direction == SNDRV_PCM_STREAM_PLAYBACK) ||\n\t     (pipe->conn_type == SKL_PIPE_CONN_TYPE_BE &&\n\t     pipe->direction == SNDRV_PCM_STREAM_CAPTURE))\n\t\tin_fmt = true;\n\n\tfor (i = 0; i < pipe->nr_cfgs; i++) {\n\t\tpconfig = &pipe->configs[i];\n\t\tif (in_fmt)\n\t\t\tfmt = &pconfig->in_fmt;\n\t\telse\n\t\t\tfmt = &pconfig->out_fmt;\n\n\t\tif (CHECK_HW_PARAMS(params->ch, params->s_freq, params->s_fmt,\n\t\t\t\t    fmt->channels, fmt->freq, fmt->bps)) {\n\t\t\tskl_tplg_set_pipe_config_idx(pipe, i);\n\t\t\tdev_dbg(skl->dev, \"Using pipe config: %d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(skl->dev, \"Invalid pipe config: %d %d %d for pipe: %d\\n\",\n\t\tparams->ch, params->s_freq, params->s_fmt, pipe->ppl_id);\n\treturn -EINVAL;\n}\n\n \nstatic int skl_tplg_mixer_dapm_pre_pmu_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tint ret;\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct skl_pipe_module *w_module;\n\tstruct skl_pipe *s_pipe = mconfig->pipe;\n\tstruct skl_module_cfg *src_module = NULL, *dst_module, *module;\n\tstruct skl_module_deferred_bind *modules;\n\n\tret = skl_tplg_get_pipe_config(skl, mconfig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = skl_create_pipeline(skl, mconfig->pipe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = skl_tplg_init_pipe_modules(skl, s_pipe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(w_module, &s_pipe->w_list, node) {\n\t\tdst_module = w_module->w->priv;\n\n\t\tif (src_module == NULL) {\n\t\t\tsrc_module = dst_module;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = skl_bind_modules(skl, src_module, dst_module);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsrc_module = dst_module;\n\t}\n\n\t \n\tlist_for_each_entry(w_module, &s_pipe->w_list, node) {\n\t\tif (list_empty(&skl->bind_list))\n\t\t\tbreak;\n\n\t\tlist_for_each_entry(modules, &skl->bind_list, node) {\n\t\t\tmodule = w_module->w->priv;\n\t\t\tif (modules->dst == module)\n\t\t\t\tskl_bind_modules(skl, modules->src,\n\t\t\t\t\t\t\tmodules->dst);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_fill_sink_instance_id(struct skl_dev *skl, u32 *params,\n\t\t\t\tint size, struct skl_module_cfg *mcfg)\n{\n\tint i, pvt_id;\n\n\tif (mcfg->m_type == SKL_MODULE_TYPE_KPB) {\n\t\tstruct skl_kpb_params *kpb_params =\n\t\t\t\t(struct skl_kpb_params *)params;\n\t\tstruct skl_mod_inst_map *inst = kpb_params->u.map;\n\n\t\tfor (i = 0; i < kpb_params->num_modules; i++) {\n\t\t\tpvt_id = skl_get_pvt_instance_id_map(skl, inst->mod_id,\n\t\t\t\t\t\t\t\tinst->inst_id);\n\t\t\tif (pvt_id < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinst->inst_id = pvt_id;\n\t\t\tinst++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n \nstatic int skl_tplg_set_module_bind_params(struct snd_soc_dapm_widget *w,\n\t\t\tstruct skl_module_cfg *mcfg, struct skl_dev *skl)\n{\n\tint i, ret;\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tconst struct snd_kcontrol_new *k;\n\tstruct soc_bytes_ext *sb;\n\tstruct skl_algo_data *bc;\n\tstruct skl_specific_cfg *sp_cfg;\n\tu32 *params;\n\n\t \n\tfor (i = 0; i < mcfg->module->max_output_pins; i++) {\n\t\tif (mcfg->m_out_pin[i].pin_state != SKL_PIN_BIND_DONE)\n\t\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < mcfg->module->max_input_pins; i++) {\n\t\tif (mcfg->m_in_pin[i].pin_state != SKL_PIN_BIND_DONE)\n\t\t\treturn 0;\n\t}\n\n\tif (mconfig->formats_config[SKL_PARAM_BIND].caps_size > 0 &&\n\t    mconfig->formats_config[SKL_PARAM_BIND].set_params ==\n\t\t\t\t\t\t\t\tSKL_PARAM_BIND) {\n\t\tsp_cfg = &mconfig->formats_config[SKL_PARAM_BIND];\n\t\tret = skl_set_module_params(skl, sp_cfg->caps,\n\t\t\t\t\tsp_cfg->caps_size,\n\t\t\t\t\tsp_cfg->param_id, mconfig);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tk = &w->kcontrol_news[i];\n\t\tif (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\t\tsb = (void *) k->private_value;\n\t\t\tbc = (struct skl_algo_data *)sb->dobj.private;\n\n\t\t\tif (bc->set_params == SKL_PARAM_BIND) {\n\t\t\t\tparams = kmemdup(bc->params, bc->max, GFP_KERNEL);\n\t\t\t\tif (!params)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tskl_fill_sink_instance_id(skl, params, bc->max,\n\t\t\t\t\t\t\t\tmconfig);\n\n\t\t\t\tret = skl_set_module_params(skl, params,\n\t\t\t\t\t\tbc->max, bc->param_id, mconfig);\n\t\t\t\tkfree(params);\n\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_get_module_id(struct skl_dev *skl, guid_t *uuid)\n{\n\tstruct uuid_module *module;\n\n\tlist_for_each_entry(module, &skl->uuid_list, list) {\n\t\tif (guid_equal(uuid, &module->uuid))\n\t\t\treturn module->id;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int skl_tplg_find_moduleid_from_uuid(struct skl_dev *skl,\n\t\t\t\t\tconst struct snd_kcontrol_new *k)\n{\n\tstruct soc_bytes_ext *sb = (void *) k->private_value;\n\tstruct skl_algo_data *bc = (struct skl_algo_data *)sb->dobj.private;\n\tstruct skl_kpb_params *uuid_params, *params;\n\tstruct hdac_bus *bus = skl_to_bus(skl);\n\tint i, size, module_id;\n\n\tif (bc->set_params == SKL_PARAM_BIND && bc->max) {\n\t\tuuid_params = (struct skl_kpb_params *)bc->params;\n\t\tsize = struct_size(params, u.map, uuid_params->num_modules);\n\n\t\tparams = devm_kzalloc(bus->dev, size, GFP_KERNEL);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\n\t\tparams->num_modules = uuid_params->num_modules;\n\n\t\tfor (i = 0; i < uuid_params->num_modules; i++) {\n\t\t\tmodule_id = skl_get_module_id(skl,\n\t\t\t\t&uuid_params->u.map_uuid[i].mod_uuid);\n\t\t\tif (module_id < 0) {\n\t\t\t\tdevm_kfree(bus->dev, params);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tparams->u.map[i].mod_id = module_id;\n\t\t\tparams->u.map[i].inst_id =\n\t\t\t\tuuid_params->u.map_uuid[i].inst_id;\n\t\t}\n\n\t\tdevm_kfree(bus->dev, bc->params);\n\t\tbc->params = (char *)params;\n\t\tbc->max = size;\n\t}\n\n\treturn 0;\n}\n\n \nvoid skl_tplg_add_moduleid_in_bind_params(struct skl_dev *skl,\n\t\t\t\tstruct snd_soc_dapm_widget *w)\n{\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tint i;\n\n\t \n\tif (mconfig->m_type != SKL_MODULE_TYPE_KPB)\n\t\treturn;\n\n\tfor (i = 0; i < w->num_kcontrols; i++)\n\t\tif ((w->kcontrol_news[i].access &\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) &&\n\t\t\t(skl_tplg_find_moduleid_from_uuid(skl,\n\t\t\t&w->kcontrol_news[i]) < 0))\n\t\t\tdev_err(skl->dev,\n\t\t\t\t\"%s: invalid kpb post bind params\\n\",\n\t\t\t\t__func__);\n}\n\nstatic int skl_tplg_module_add_deferred_bind(struct skl_dev *skl,\n\tstruct skl_module_cfg *src, struct skl_module_cfg *dst)\n{\n\tstruct skl_module_deferred_bind *m_list, *modules;\n\tint i;\n\n\t \n\tfor (i = 0; i < dst->module->max_input_pins; i++) {\n\t\tstruct skl_module_pin *pin = &dst->m_in_pin[i];\n\n\t\tif (pin->is_dynamic)\n\t\t\tcontinue;\n\n\t\tif ((pin->id.module_id  == src->id.module_id) &&\n\t\t\t(pin->id.instance_id  == src->id.instance_id)) {\n\n\t\t\tif (!list_empty(&skl->bind_list)) {\n\t\t\t\tlist_for_each_entry(modules, &skl->bind_list, node) {\n\t\t\t\t\tif (modules->src == src && modules->dst == dst)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm_list = kzalloc(sizeof(*m_list), GFP_KERNEL);\n\t\t\tif (!m_list)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tm_list->src = src;\n\t\t\tm_list->dst = dst;\n\n\t\t\tlist_add(&m_list->node, &skl->bind_list);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_bind_sinks(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct skl_dev *skl,\n\t\t\t\tstruct snd_soc_dapm_widget *src_w,\n\t\t\t\tstruct skl_module_cfg *src_mconfig)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct snd_soc_dapm_widget *sink = NULL, *next_sink = NULL;\n\tstruct skl_module_cfg *sink_mconfig;\n\tint ret;\n\n\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\tif (!p->connect)\n\t\t\tcontinue;\n\n\t\tdev_dbg(skl->dev,\n\t\t\t\"%s: src widget=%s\\n\", __func__, w->name);\n\t\tdev_dbg(skl->dev,\n\t\t\t\"%s: sink widget=%s\\n\", __func__, p->sink->name);\n\n\t\tnext_sink = p->sink;\n\n\t\tif (!is_skl_dsp_widget_type(p->sink, skl->dev))\n\t\t\treturn skl_tplg_bind_sinks(p->sink, skl, src_w, src_mconfig);\n\n\t\t \n\t\tif ((p->sink->priv != NULL) &&\n\t\t\t\tis_skl_dsp_widget_type(p->sink, skl->dev)) {\n\n\t\t\tsink = p->sink;\n\t\t\tsink_mconfig = sink->priv;\n\n\t\t\t \n\t\t\tif (((src_mconfig->m_state == SKL_MODULE_INIT_DONE)\n\t\t\t\t&& (sink_mconfig->m_state == SKL_MODULE_UNINIT))) {\n\n\t\t\t\tret = skl_tplg_module_add_deferred_bind(skl,\n\t\t\t\t\t\tsrc_mconfig, sink_mconfig);\n\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t}\n\n\n\t\t\tif (src_mconfig->m_state == SKL_MODULE_UNINIT ||\n\t\t\t\tsink_mconfig->m_state == SKL_MODULE_UNINIT)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = skl_bind_modules(skl, src_mconfig, sink_mconfig);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tskl_tplg_set_module_bind_params(src_w,\n\t\t\t\t\tsrc_mconfig, skl);\n\t\t\tskl_tplg_set_module_bind_params(sink,\n\t\t\t\t\tsink_mconfig, skl);\n\n\t\t\t \n\t\t\tif (sink_mconfig->pipe->state != SKL_PIPE_STARTED) {\n\t\t\t\tif (sink_mconfig->pipe->conn_type !=\n\t\t\t\t\t\t\tSKL_PIPE_CONN_TYPE_FE)\n\t\t\t\t\tret = skl_run_pipe(skl,\n\t\t\t\t\t\t\tsink_mconfig->pipe);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sink && next_sink)\n\t\treturn skl_tplg_bind_sinks(next_sink, skl, src_w, src_mconfig);\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_pga_dapm_pre_pmu_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *src_mconfig;\n\tint ret = 0;\n\n\tsrc_mconfig = w->priv;\n\n\t \n\tret = skl_tplg_bind_sinks(w, skl, w, src_mconfig);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (src_mconfig->pipe->conn_type != SKL_PIPE_CONN_TYPE_FE)\n\t\treturn skl_run_pipe(skl, src_mconfig->pipe);\n\n\treturn 0;\n}\n\nstatic struct snd_soc_dapm_widget *skl_get_src_dsp_widget(\n\t\tstruct snd_soc_dapm_widget *w, struct skl_dev *skl)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct snd_soc_dapm_widget *src_w = NULL;\n\n\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\tsrc_w = p->source;\n\t\tif (!p->connect)\n\t\t\tcontinue;\n\n\t\tdev_dbg(skl->dev, \"sink widget=%s\\n\", w->name);\n\t\tdev_dbg(skl->dev, \"src widget=%s\\n\", p->source->name);\n\n\t\t \n\t\tif ((p->source->priv != NULL) &&\n\t\t\t\tis_skl_dsp_widget_type(p->source, skl->dev)) {\n\t\t\treturn p->source;\n\t\t}\n\t}\n\n\tif (src_w != NULL)\n\t\treturn skl_get_src_dsp_widget(src_w, skl);\n\n\treturn NULL;\n}\n\n \nstatic int skl_tplg_mixer_dapm_post_pmu_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tint ret = 0;\n\tstruct snd_soc_dapm_widget *source, *sink;\n\tstruct skl_module_cfg *src_mconfig, *sink_mconfig;\n\tint src_pipe_started = 0;\n\n\tsink = w;\n\tsink_mconfig = sink->priv;\n\n\t \n\tsource = skl_get_src_dsp_widget(w, skl);\n\tif (source != NULL) {\n\t\tsrc_mconfig = source->priv;\n\t\tsink_mconfig = sink->priv;\n\t\tsrc_pipe_started = 1;\n\n\t\t \n\t\tif (src_mconfig->pipe->state != SKL_PIPE_STARTED)\n\t\t\tsrc_pipe_started = 0;\n\t}\n\n\tif (src_pipe_started) {\n\t\tret = skl_bind_modules(skl, src_mconfig, sink_mconfig);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tskl_tplg_set_module_bind_params(source, src_mconfig, skl);\n\t\tskl_tplg_set_module_bind_params(sink, sink_mconfig, skl);\n\n\t\tif (sink_mconfig->pipe->conn_type != SKL_PIPE_CONN_TYPE_FE)\n\t\t\tret = skl_run_pipe(skl, sink_mconfig->pipe);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int skl_tplg_mixer_dapm_pre_pmd_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *src_mconfig, *sink_mconfig;\n\tint ret = 0, i;\n\n\tsink_mconfig = w->priv;\n\n\t \n\tret = skl_stop_pipe(skl, sink_mconfig->pipe);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < sink_mconfig->module->max_input_pins; i++) {\n\t\tif (sink_mconfig->m_in_pin[i].pin_state == SKL_PIN_BIND_DONE) {\n\t\t\tsrc_mconfig = sink_mconfig->m_in_pin[i].tgt_mcfg;\n\t\t\tif (!src_mconfig)\n\t\t\t\tcontinue;\n\n\t\t\tret = skl_unbind_modules(skl,\n\t\t\t\t\t\tsrc_mconfig, sink_mconfig);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int skl_tplg_mixer_dapm_post_pmd_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct skl_pipe_module *w_module;\n\tstruct skl_module_cfg *src_module = NULL, *dst_module;\n\tstruct skl_pipe *s_pipe = mconfig->pipe;\n\tstruct skl_module_deferred_bind *modules, *tmp;\n\n\tif (s_pipe->state == SKL_PIPE_INVALID)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(w_module, &s_pipe->w_list, node) {\n\t\tif (list_empty(&skl->bind_list))\n\t\t\tbreak;\n\n\t\tsrc_module = w_module->w->priv;\n\n\t\tlist_for_each_entry_safe(modules, tmp, &skl->bind_list, node) {\n\t\t\t \n\t\t\tif (modules->dst == src_module) {\n\t\t\t\tskl_unbind_modules(skl, modules->src,\n\t\t\t\t\t\tmodules->dst);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (modules->src == src_module) {\n\t\t\t\tlist_del(&modules->node);\n\t\t\t\tmodules->src = NULL;\n\t\t\t\tmodules->dst = NULL;\n\t\t\t\tkfree(modules);\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(w_module, &s_pipe->w_list, node) {\n\t\tdst_module = w_module->w->priv;\n\n\t\tif (src_module == NULL) {\n\t\t\tsrc_module = dst_module;\n\t\t\tcontinue;\n\t\t}\n\n\t\tskl_unbind_modules(skl, src_module, dst_module);\n\t\tsrc_module = dst_module;\n\t}\n\n\tskl_delete_pipe(skl, mconfig->pipe);\n\n\tlist_for_each_entry(w_module, &s_pipe->w_list, node) {\n\t\tsrc_module = w_module->w->priv;\n\t\tsrc_module->m_state = SKL_MODULE_UNINIT;\n\t}\n\n\treturn skl_tplg_unload_pipe_modules(skl, s_pipe);\n}\n\n \nstatic int skl_tplg_pga_dapm_post_pmd_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\tstruct skl_dev *skl)\n{\n\tstruct skl_module_cfg *src_mconfig, *sink_mconfig;\n\tint ret = 0, i;\n\n\tsrc_mconfig = w->priv;\n\n\t \n\tret = skl_stop_pipe(skl, src_mconfig->pipe);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < src_mconfig->module->max_output_pins; i++) {\n\t\tif (src_mconfig->m_out_pin[i].pin_state == SKL_PIN_BIND_DONE) {\n\t\t\tsink_mconfig = src_mconfig->m_out_pin[i].tgt_mcfg;\n\t\t\tif (!sink_mconfig)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tret = skl_unbind_modules(skl, src_mconfig,\n\t\t\t\t\t\t\tsink_mconfig);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int skl_tplg_mixer_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *k, int event)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct skl_dev *skl = get_skl_ctx(dapm->dev);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn skl_tplg_mixer_dapm_pre_pmu_event(w, skl);\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\treturn skl_tplg_mixer_dapm_post_pmu_event(w, skl);\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\treturn skl_tplg_mixer_dapm_pre_pmd_event(w, skl);\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn skl_tplg_mixer_dapm_post_pmd_event(w, skl);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_pga_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *k, int event)\n\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct skl_dev *skl = get_skl_ctx(dapm->dev);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn skl_tplg_pga_dapm_pre_pmu_event(w, skl);\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn skl_tplg_pga_dapm_post_pmd_event(w, skl);\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_multi_config_set_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t\t bool is_set)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct hdac_bus *bus = snd_soc_component_get_drvdata(component);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_pipeline *ppl;\n\tstruct skl_pipe *pipe = NULL;\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tu32 *pipe_id;\n\n\tif (!ec)\n\t\treturn -EINVAL;\n\n\tif (is_set && ucontrol->value.enumerated.item[0] > ec->items)\n\t\treturn -EINVAL;\n\n\tpipe_id = ec->dobj.private;\n\n\tlist_for_each_entry(ppl, &skl->ppl_list, node) {\n\t\tif (ppl->pipe->ppl_id == *pipe_id) {\n\t\t\tpipe = ppl->pipe;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!pipe)\n\t\treturn -EIO;\n\n\tif (is_set)\n\t\tskl_tplg_set_pipe_config_idx(pipe, ucontrol->value.enumerated.item[0]);\n\telse\n\t\tucontrol->value.enumerated.item[0] = pipe->cur_config_idx;\n\n\treturn 0;\n}\n\nstatic int skl_tplg_multi_config_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\treturn skl_tplg_multi_config_set_get(kcontrol, ucontrol, false);\n}\n\nstatic int skl_tplg_multi_config_set(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\treturn skl_tplg_multi_config_set_get(kcontrol, ucontrol, true);\n}\n\nstatic int skl_tplg_multi_config_get_dmic(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\treturn skl_tplg_multi_config_set_get(kcontrol, ucontrol, false);\n}\n\nstatic int skl_tplg_multi_config_set_dmic(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\treturn skl_tplg_multi_config_set_get(kcontrol, ucontrol, true);\n}\n\nstatic int skl_tplg_tlv_control_get(struct snd_kcontrol *kcontrol,\n\t\t\tunsigned int __user *data, unsigned int size)\n{\n\tstruct soc_bytes_ext *sb =\n\t\t\t(struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct skl_algo_data *bc = (struct skl_algo_data *)sb->dobj.private;\n\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct skl_dev *skl = get_skl_ctx(w->dapm->dev);\n\n\tif (w->power)\n\t\tskl_get_module_params(skl, (u32 *)bc->params,\n\t\t\t\t      bc->size, bc->param_id, mconfig);\n\n\t \n\tsize -= 2 * sizeof(u32);\n\n\t \n\tif (size > bc->max)\n\t\tsize = bc->max;\n\n\tif (bc->params) {\n\t\tif (copy_to_user(data, &bc->param_id, sizeof(u32)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(data + 1, &size, sizeof(u32)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(data + 2, bc->params, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#define SKL_PARAM_VENDOR_ID 0xff\n\nstatic int skl_tplg_tlv_control_set(struct snd_kcontrol *kcontrol,\n\t\t\tconst unsigned int __user *data, unsigned int size)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct soc_bytes_ext *sb =\n\t\t\t(struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct skl_algo_data *ac = (struct skl_algo_data *)sb->dobj.private;\n\tstruct skl_dev *skl = get_skl_ctx(w->dapm->dev);\n\n\tif (ac->params) {\n\t\tif (size > ac->max)\n\t\t\treturn -EINVAL;\n\t\tac->size = size;\n\n\t\tif (copy_from_user(ac->params, data, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (w->power)\n\t\t\treturn skl_set_module_params(skl,\n\t\t\t\t\t\t(u32 *)ac->params, ac->size,\n\t\t\t\t\t\tac->param_id, mconfig);\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_mic_control_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tu32 ch_type = *((u32 *)ec->dobj.private);\n\n\tif (mconfig->dmic_ch_type == ch_type)\n\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\t\tmconfig->dmic_ch_combo_index;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\n\treturn 0;\n}\n\nstatic int skl_fill_mic_sel_params(struct skl_module_cfg *mconfig,\n\tstruct skl_mic_sel_config *mic_cfg, struct device *dev)\n{\n\tstruct skl_specific_cfg *sp_cfg =\n\t\t\t\t&mconfig->formats_config[SKL_PARAM_INIT];\n\n\tsp_cfg->caps_size = sizeof(struct skl_mic_sel_config);\n\tsp_cfg->set_params = SKL_PARAM_SET;\n\tsp_cfg->param_id = 0x00;\n\tif (!sp_cfg->caps) {\n\t\tsp_cfg->caps = devm_kzalloc(dev, sp_cfg->caps_size, GFP_KERNEL);\n\t\tif (!sp_cfg->caps)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmic_cfg->mic_switch = SKL_MIC_SEL_SWITCH;\n\tmic_cfg->flags = 0;\n\tmemcpy(sp_cfg->caps, mic_cfg, sp_cfg->caps_size);\n\n\treturn 0;\n}\n\nstatic int skl_tplg_mic_control_set(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct skl_module_cfg *mconfig = w->priv;\n\tstruct skl_mic_sel_config mic_cfg = {0};\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tu32 ch_type = *((u32 *)ec->dobj.private);\n\tconst int *list;\n\tu8 in_ch, out_ch, index;\n\n\tmconfig->dmic_ch_type = ch_type;\n\tmconfig->dmic_ch_combo_index = ucontrol->value.enumerated.item[0];\n\n\t \n\tif (mconfig->dmic_ch_combo_index == 0)\n\t\treturn 0;\n\n\t \n\tindex = mconfig->dmic_ch_combo_index - 1;\n\n\tswitch (ch_type) {\n\tcase SKL_CH_MONO:\n\t\tif (mconfig->dmic_ch_combo_index > ARRAY_SIZE(mic_mono_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = &mic_mono_list[index];\n\t\tbreak;\n\n\tcase SKL_CH_STEREO:\n\t\tif (mconfig->dmic_ch_combo_index > ARRAY_SIZE(mic_stereo_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = mic_stereo_list[index];\n\t\tbreak;\n\n\tcase SKL_CH_TRIO:\n\t\tif (mconfig->dmic_ch_combo_index > ARRAY_SIZE(mic_trio_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = mic_trio_list[index];\n\t\tbreak;\n\n\tcase SKL_CH_QUATRO:\n\t\tif (mconfig->dmic_ch_combo_index > ARRAY_SIZE(mic_quatro_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = mic_quatro_list[index];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(w->dapm->dev,\n\t\t\t\t\"Invalid channel %d for mic_select module\\n\",\n\t\t\t\tch_type);\n\t\treturn -EINVAL;\n\n\t}\n\n\t \n\tfor (out_ch = 0; out_ch < ch_type; out_ch++) {\n\t\tin_ch = list[out_ch];\n\t\tmic_cfg.blob[out_ch][in_ch] = SKL_DEFAULT_MIC_SEL_GAIN;\n\t}\n\n\treturn skl_fill_mic_sel_params(mconfig, &mic_cfg, w->dapm->dev);\n}\n\n \nstatic void skl_tplg_fill_dma_id(struct skl_module_cfg *mcfg,\n\t\t\t\tstruct skl_pipe_params *params)\n{\n\tstruct skl_pipe *pipe = mcfg->pipe;\n\n\tif (pipe->passthru) {\n\t\tswitch (mcfg->dev_type) {\n\t\tcase SKL_DEVICE_HDALINK:\n\t\t\tpipe->p_params->link_dma_id = params->link_dma_id;\n\t\t\tpipe->p_params->link_index = params->link_index;\n\t\t\tpipe->p_params->link_bps = params->link_bps;\n\t\t\tbreak;\n\n\t\tcase SKL_DEVICE_HDAHOST:\n\t\t\tpipe->p_params->host_dma_id = params->host_dma_id;\n\t\t\tpipe->p_params->host_bps = params->host_bps;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tpipe->p_params->s_fmt = params->s_fmt;\n\t\tpipe->p_params->ch = params->ch;\n\t\tpipe->p_params->s_freq = params->s_freq;\n\t\tpipe->p_params->stream = params->stream;\n\t\tpipe->p_params->format = params->format;\n\n\t} else {\n\t\tmemcpy(pipe->p_params, params, sizeof(*params));\n\t}\n}\n\n \nint skl_tplg_update_pipe_params(struct device *dev,\n\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\tstruct skl_pipe_params *params)\n{\n\tstruct skl_module_res *res;\n\tstruct skl_dev *skl = get_skl_ctx(dev);\n\tstruct skl_module_fmt *format = NULL;\n\tu8 cfg_idx = mconfig->pipe->cur_config_idx;\n\n\tres = &mconfig->module->resources[mconfig->res_idx];\n\tskl_tplg_fill_dma_id(mconfig, params);\n\tmconfig->fmt_idx = mconfig->mod_cfg[cfg_idx].fmt_idx;\n\tmconfig->res_idx = mconfig->mod_cfg[cfg_idx].res_idx;\n\n\tif (skl->nr_modules)\n\t\treturn 0;\n\n\tif (params->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tformat = &mconfig->module->formats[mconfig->fmt_idx].inputs[0].fmt;\n\telse\n\t\tformat = &mconfig->module->formats[mconfig->fmt_idx].outputs[0].fmt;\n\n\t \n\tformat->s_freq = params->s_freq;\n\tformat->channels = params->ch;\n\tformat->valid_bit_depth = skl_get_bit_depth(params->s_fmt);\n\n\t \n\tswitch (format->valid_bit_depth) {\n\tcase SKL_DEPTH_16BIT:\n\t\tformat->bit_depth = format->valid_bit_depth;\n\t\tbreak;\n\n\tcase SKL_DEPTH_24BIT:\n\tcase SKL_DEPTH_32BIT:\n\t\tformat->bit_depth = SKL_DEPTH_32BIT;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid bit depth %x for pipe\\n\",\n\t\t\t\tformat->valid_bit_depth);\n\t\treturn -EINVAL;\n\t}\n\n\tif (params->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tres->ibs = (format->s_freq / 1000) *\n\t\t\t\t(format->channels) *\n\t\t\t\t(format->bit_depth >> 3);\n\t} else {\n\t\tres->obs = (format->s_freq / 1000) *\n\t\t\t\t(format->channels) *\n\t\t\t\t(format->bit_depth >> 3);\n\t}\n\n\treturn 0;\n}\n\n \nstruct skl_module_cfg *\nskl_tplg_fe_get_cpr_module(struct snd_soc_dai *dai, int stream)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, stream);\n\tstruct snd_soc_dapm_path *p = NULL;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\t\tif (p->connect && p->sink->power &&\n\t\t\t\t!is_skl_dsp_widget_type(p->sink, dai->dev))\n\t\t\t\tcontinue;\n\n\t\t\tif (p->sink->priv) {\n\t\t\t\tdev_dbg(dai->dev, \"set params for %s\\n\",\n\t\t\t\t\t\tp->sink->name);\n\t\t\t\treturn p->sink->priv;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\t\tif (p->connect && p->source->power &&\n\t\t\t\t!is_skl_dsp_widget_type(p->source, dai->dev))\n\t\t\t\tcontinue;\n\n\t\t\tif (p->source->priv) {\n\t\t\t\tdev_dbg(dai->dev, \"set params for %s\\n\",\n\t\t\t\t\t\tp->source->name);\n\t\t\t\treturn p->source->priv;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct skl_module_cfg *skl_get_mconfig_pb_cpr(\n\t\tstruct snd_soc_dai *dai, struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct skl_module_cfg *mconfig = NULL;\n\n\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\tif (w->endpoints[SND_SOC_DAPM_DIR_OUT] > 0) {\n\t\t\tif (p->connect &&\n\t\t\t\t    (p->sink->id == snd_soc_dapm_aif_out) &&\n\t\t\t\t    p->source->priv) {\n\t\t\t\tmconfig = p->source->priv;\n\t\t\t\treturn mconfig;\n\t\t\t}\n\t\t\tmconfig = skl_get_mconfig_pb_cpr(dai, p->source);\n\t\t\tif (mconfig)\n\t\t\t\treturn mconfig;\n\t\t}\n\t}\n\treturn mconfig;\n}\n\nstatic struct skl_module_cfg *skl_get_mconfig_cap_cpr(\n\t\tstruct snd_soc_dai *dai, struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct skl_module_cfg *mconfig = NULL;\n\n\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\tif (w->endpoints[SND_SOC_DAPM_DIR_IN] > 0) {\n\t\t\tif (p->connect &&\n\t\t\t\t    (p->source->id == snd_soc_dapm_aif_in) &&\n\t\t\t\t    p->sink->priv) {\n\t\t\t\tmconfig = p->sink->priv;\n\t\t\t\treturn mconfig;\n\t\t\t}\n\t\t\tmconfig = skl_get_mconfig_cap_cpr(dai, p->sink);\n\t\t\tif (mconfig)\n\t\t\t\treturn mconfig;\n\t\t}\n\t}\n\treturn mconfig;\n}\n\nstruct skl_module_cfg *\nskl_tplg_be_get_cpr_module(struct snd_soc_dai *dai, int stream)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, stream);\n\tstruct skl_module_cfg *mconfig;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmconfig = skl_get_mconfig_pb_cpr(dai, w);\n\t} else {\n\t\tmconfig = skl_get_mconfig_cap_cpr(dai, w);\n\t}\n\treturn mconfig;\n}\n\nstatic u8 skl_tplg_be_link_type(int dev_type)\n{\n\tint ret;\n\n\tswitch (dev_type) {\n\tcase SKL_DEVICE_BT:\n\t\tret = NHLT_LINK_SSP;\n\t\tbreak;\n\n\tcase SKL_DEVICE_DMIC:\n\t\tret = NHLT_LINK_DMIC;\n\t\tbreak;\n\n\tcase SKL_DEVICE_I2S:\n\t\tret = NHLT_LINK_SSP;\n\t\tbreak;\n\n\tcase SKL_DEVICE_HDALINK:\n\t\tret = NHLT_LINK_HDA;\n\t\tbreak;\n\n\tdefault:\n\t\tret = NHLT_LINK_INVALID;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int skl_tplg_be_fill_pipe_params(struct snd_soc_dai *dai,\n\t\t\t\tstruct skl_module_cfg *mconfig,\n\t\t\t\tstruct skl_pipe_params *params)\n{\n\tstruct nhlt_specific_cfg *cfg;\n\tstruct skl_pipe *pipe = mconfig->pipe;\n\tstruct skl_pipe_params save = *pipe->p_params;\n\tstruct skl_pipe_fmt *pipe_fmt;\n\tstruct skl_dev *skl = get_skl_ctx(dai->dev);\n\tint link_type = skl_tplg_be_link_type(mconfig->dev_type);\n\tu8 dev_type = skl_tplg_be_dev_type(mconfig->dev_type);\n\tint ret;\n\n\tskl_tplg_fill_dma_id(mconfig, params);\n\n\tif (link_type == NHLT_LINK_HDA)\n\t\treturn 0;\n\n\t*pipe->p_params = *params;\n\tret = skl_tplg_get_pipe_config(skl, mconfig);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(skl->dev, \"%s using pipe config: %d\\n\", __func__, pipe->cur_config_idx);\n\tif (pipe->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tpipe_fmt = &pipe->configs[pipe->cur_config_idx].out_fmt;\n\telse\n\t\tpipe_fmt = &pipe->configs[pipe->cur_config_idx].in_fmt;\n\n\t \n\tcfg = intel_nhlt_get_endpoint_blob(dai->dev, skl->nhlt,\n\t\t\t\t\tmconfig->vbus_id, link_type,\n\t\t\t\t\tpipe_fmt->bps, params->s_cont,\n\t\t\t\t\tpipe_fmt->channels, pipe_fmt->freq,\n\t\t\t\t\tpipe->direction, dev_type);\n\tif (cfg) {\n\t\tmconfig->formats_config[SKL_PARAM_INIT].caps_size = cfg->size;\n\t\tmconfig->formats_config[SKL_PARAM_INIT].caps = (u32 *)&cfg->caps;\n\t} else {\n\t\tdev_err(dai->dev, \"Blob NULL for id:%d type:%d dirn:%d ch:%d, freq:%d, fmt:%d\\n\",\n\t\t\tmconfig->vbus_id, link_type, params->stream,\n\t\t\tparams->ch, params->s_freq, params->s_fmt);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\t*pipe->p_params = save;\n\treturn ret;\n}\n\nstatic int skl_tplg_be_set_src_pipe_params(struct snd_soc_dai *dai,\n\t\t\t\tstruct snd_soc_dapm_widget *w,\n\t\t\t\tstruct skl_pipe_params *params)\n{\n\tstruct snd_soc_dapm_path *p;\n\tint ret = -EIO;\n\n\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\tif (p->connect && is_skl_dsp_widget_type(p->source, dai->dev) &&\n\t\t\t\t\t\tp->source->priv) {\n\n\t\t\tret = skl_tplg_be_fill_pipe_params(dai,\n\t\t\t\t\t\tp->source->priv, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = skl_tplg_be_set_src_pipe_params(dai,\n\t\t\t\t\t\tp->source, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int skl_tplg_be_set_sink_pipe_params(struct snd_soc_dai *dai,\n\tstruct snd_soc_dapm_widget *w, struct skl_pipe_params *params)\n{\n\tstruct snd_soc_dapm_path *p;\n\tint ret = -EIO;\n\n\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\tif (p->connect && is_skl_dsp_widget_type(p->sink, dai->dev) &&\n\t\t\t\t\t\tp->sink->priv) {\n\n\t\t\tret = skl_tplg_be_fill_pipe_params(dai,\n\t\t\t\t\t\tp->sink->priv, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = skl_tplg_be_set_sink_pipe_params(\n\t\t\t\t\t\tdai, p->sink, params);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint skl_tplg_be_update_params(struct snd_soc_dai *dai,\n\t\t\t\tstruct skl_pipe_params *params)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, params->stream);\n\n\tif (params->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\treturn skl_tplg_be_set_src_pipe_params(dai, w, params);\n\t} else {\n\t\treturn skl_tplg_be_set_sink_pipe_params(dai, w, params);\n\t}\n}\n\nstatic const struct snd_soc_tplg_widget_events skl_tplg_widget_ops[] = {\n\t{SKL_MIXER_EVENT, skl_tplg_mixer_event},\n\t{SKL_VMIXER_EVENT, skl_tplg_mixer_event},\n\t{SKL_PGA_EVENT, skl_tplg_pga_event},\n};\n\nstatic const struct snd_soc_tplg_bytes_ext_ops skl_tlv_ops[] = {\n\t{SKL_CONTROL_TYPE_BYTE_TLV, skl_tplg_tlv_control_get,\n\t\t\t\t\tskl_tplg_tlv_control_set},\n};\n\nstatic const struct snd_soc_tplg_kcontrol_ops skl_tplg_kcontrol_ops[] = {\n\t{\n\t\t.id = SKL_CONTROL_TYPE_MIC_SELECT,\n\t\t.get = skl_tplg_mic_control_get,\n\t\t.put = skl_tplg_mic_control_set,\n\t},\n\t{\n\t\t.id = SKL_CONTROL_TYPE_MULTI_IO_SELECT,\n\t\t.get = skl_tplg_multi_config_get,\n\t\t.put = skl_tplg_multi_config_set,\n\t},\n\t{\n\t\t.id = SKL_CONTROL_TYPE_MULTI_IO_SELECT_DMIC,\n\t\t.get = skl_tplg_multi_config_get_dmic,\n\t\t.put = skl_tplg_multi_config_set_dmic,\n\t}\n};\n\nstatic int skl_tplg_fill_pipe_cfg(struct device *dev,\n\t\t\tstruct skl_pipe *pipe, u32 tkn,\n\t\t\tu32 tkn_val, int conf_idx, int dir)\n{\n\tstruct skl_pipe_fmt *fmt;\n\tstruct skl_path_config *config;\n\n\tswitch (dir) {\n\tcase SKL_DIR_IN:\n\t\tfmt = &pipe->configs[conf_idx].in_fmt;\n\t\tbreak;\n\n\tcase SKL_DIR_OUT:\n\t\tfmt = &pipe->configs[conf_idx].out_fmt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid direction: %d\\n\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = &pipe->configs[conf_idx];\n\n\tswitch (tkn) {\n\tcase SKL_TKN_U32_CFG_FREQ:\n\t\tfmt->freq = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_CFG_CHAN:\n\t\tfmt->channels = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_CFG_BPS:\n\t\tfmt->bps = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PATH_MEM_PGS:\n\t\tconfig->mem_pages = tkn_val;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid token config: %d\\n\", tkn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_fill_pipe_tkn(struct device *dev,\n\t\t\tstruct skl_pipe *pipe, u32 tkn,\n\t\t\tu32 tkn_val)\n{\n\n\tswitch (tkn) {\n\tcase SKL_TKN_U32_PIPE_CONN_TYPE:\n\t\tpipe->conn_type = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_PRIORITY:\n\t\tpipe->pipe_priority = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_MEM_PGS:\n\t\tpipe->memory_pages = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PMODE:\n\t\tpipe->lp_mode = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_DIRECTION:\n\t\tpipe->direction = tkn_val;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_NUM_CONFIGS:\n\t\tpipe->nr_cfgs = tkn_val;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Token not handled %d\\n\", tkn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_add_pipe(struct device *dev,\n\t\tstruct skl_module_cfg *mconfig, struct skl_dev *skl,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem)\n{\n\tstruct skl_pipeline *ppl;\n\tstruct skl_pipe *pipe;\n\tstruct skl_pipe_params *params;\n\n\tlist_for_each_entry(ppl, &skl->ppl_list, node) {\n\t\tif (ppl->pipe->ppl_id == tkn_elem->value) {\n\t\t\tmconfig->pipe = ppl->pipe;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tppl = devm_kzalloc(dev, sizeof(*ppl), GFP_KERNEL);\n\tif (!ppl)\n\t\treturn -ENOMEM;\n\n\tpipe = devm_kzalloc(dev, sizeof(*pipe), GFP_KERNEL);\n\tif (!pipe)\n\t\treturn -ENOMEM;\n\n\tparams = devm_kzalloc(dev, sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tpipe->p_params = params;\n\tpipe->ppl_id = tkn_elem->value;\n\tINIT_LIST_HEAD(&pipe->w_list);\n\n\tppl->pipe = pipe;\n\tlist_add(&ppl->node, &skl->ppl_list);\n\n\tmconfig->pipe = pipe;\n\tmconfig->pipe->state = SKL_PIPE_INVALID;\n\n\treturn 0;\n}\n\nstatic int skl_tplg_get_uuid(struct device *dev, guid_t *guid,\n\t      struct snd_soc_tplg_vendor_uuid_elem *uuid_tkn)\n{\n\tif (uuid_tkn->token == SKL_TKN_UUID) {\n\t\timport_guid(guid, uuid_tkn->uuid);\n\t\treturn 0;\n\t}\n\n\tdev_err(dev, \"Not an UUID token %d\\n\", uuid_tkn->token);\n\n\treturn -EINVAL;\n}\n\nstatic int skl_tplg_fill_pin(struct device *dev,\n\t\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\t\tstruct skl_module_pin *m_pin,\n\t\t\tint pin_index)\n{\n\tint ret;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_U32_PIN_MOD_ID:\n\t\tm_pin[pin_index].id.module_id = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIN_INST_ID:\n\t\tm_pin[pin_index].id.instance_id = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_UUID:\n\t\tret = skl_tplg_get_uuid(dev, &m_pin[pin_index].id.mod_uuid,\n\t\t\t(struct snd_soc_tplg_vendor_uuid_elem *)tkn_elem);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"%d Not a pin token\\n\", tkn_elem->token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_fill_pins_info(struct device *dev,\n\t\tstruct skl_module_cfg *mconfig,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tint dir, int pin_count)\n{\n\tint ret;\n\tstruct skl_module_pin *m_pin;\n\n\tswitch (dir) {\n\tcase SKL_DIR_IN:\n\t\tm_pin = mconfig->m_in_pin;\n\t\tbreak;\n\n\tcase SKL_DIR_OUT:\n\t\tm_pin = mconfig->m_out_pin;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid direction value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = skl_tplg_fill_pin(dev, tkn_elem, m_pin, pin_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm_pin[pin_count].in_use = false;\n\tm_pin[pin_count].pin_state = SKL_PIN_UNBIND;\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_fill_fmt(struct device *dev,\n\t\tstruct skl_module_fmt *dst_fmt,\n\t\tu32 tkn, u32 value)\n{\n\tswitch (tkn) {\n\tcase SKL_TKN_U32_FMT_CH:\n\t\tdst_fmt->channels  = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_FREQ:\n\t\tdst_fmt->s_freq = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_BIT_DEPTH:\n\t\tdst_fmt->bit_depth = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_SAMPLE_SIZE:\n\t\tdst_fmt->valid_bit_depth = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_CH_CONFIG:\n\t\tdst_fmt->ch_cfg = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_INTERLEAVE:\n\t\tdst_fmt->interleaving_style = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_SAMPLE_TYPE:\n\t\tdst_fmt->sample_type = value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_CH_MAP:\n\t\tdst_fmt->ch_map = value;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid token %d\\n\", tkn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_widget_fill_fmt(struct device *dev,\n\t\tstruct skl_module_iface *fmt,\n\t\tu32 tkn, u32 val, u32 dir, int fmt_idx)\n{\n\tstruct skl_module_fmt *dst_fmt;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tswitch (dir) {\n\tcase SKL_DIR_IN:\n\t\tdst_fmt = &fmt->inputs[fmt_idx].fmt;\n\t\tbreak;\n\n\tcase SKL_DIR_OUT:\n\t\tdst_fmt = &fmt->outputs[fmt_idx].fmt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid direction: %d\\n\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\treturn skl_tplg_fill_fmt(dev, dst_fmt, tkn, val);\n}\n\nstatic void skl_tplg_fill_pin_dynamic_val(\n\t\tstruct skl_module_pin *mpin, u32 pin_count, u32 value)\n{\n\tint i;\n\n\tfor (i = 0; i < pin_count; i++)\n\t\tmpin[i].is_dynamic = value;\n}\n\n \nstatic int skl_tplg_manifest_pin_res_tkn(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tstruct skl_module_res *res, int pin_idx, int dir)\n{\n\tstruct skl_module_pin_resources *m_pin;\n\n\tswitch (dir) {\n\tcase SKL_DIR_IN:\n\t\tm_pin = &res->input[pin_idx];\n\t\tbreak;\n\n\tcase SKL_DIR_OUT:\n\t\tm_pin = &res->output[pin_idx];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid pin direction: %d\\n\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_MM_U32_RES_PIN_ID:\n\t\tm_pin->pin_index = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_PIN_BUF:\n\t\tm_pin->buf_size = tkn_elem->value;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid token: %d\\n\", tkn_elem->token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int skl_tplg_fill_res_tkn(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tstruct skl_module_res *res,\n\t\tint pin_idx, int dir)\n{\n\tint ret, tkn_count = 0;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_MM_U32_DMA_SIZE:\n\t\tres->dma_buffer_size = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_CPC:\n\t\tres->cpc = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_MEM_PAGES:\n\t\tres->is_pages = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_OBS:\n\t\tres->obs = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_IBS:\n\t\tres->ibs = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_RES_PIN_ID:\n\tcase SKL_TKN_MM_U32_PIN_BUF:\n\t\tret = skl_tplg_manifest_pin_res_tkn(dev, tkn_elem, res,\n\t\t\t\t\t\t    pin_idx, dir);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_CPS:\n\tcase SKL_TKN_U32_MAX_MCPS:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Not a res type token: %d\", tkn_elem->token);\n\t\treturn -EINVAL;\n\n\t}\n\ttkn_count++;\n\n\treturn tkn_count;\n}\n\n \nstatic int skl_tplg_get_token(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tstruct skl_dev *skl, struct skl_module_cfg *mconfig)\n{\n\tint tkn_count = 0;\n\tint ret;\n\tstatic int is_pipe_exists;\n\tstatic int pin_index, dir, conf_idx;\n\tstruct skl_module_iface *iface = NULL;\n\tstruct skl_module_res *res = NULL;\n\tint res_idx = mconfig->res_idx;\n\tint fmt_idx = mconfig->fmt_idx;\n\n\t \n\tif (skl->nr_modules == 0) {\n\t\tres = &mconfig->module->resources[res_idx];\n\t\tiface = &mconfig->module->formats[fmt_idx];\n\t}\n\n\tif (tkn_elem->token > SKL_TKN_MAX)\n\t\treturn -EINVAL;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_U8_IN_QUEUE_COUNT:\n\t\tmconfig->module->max_input_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_OUT_QUEUE_COUNT:\n\t\tmconfig->module->max_output_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_DYN_IN_PIN:\n\t\tif (!mconfig->m_in_pin)\n\t\t\tmconfig->m_in_pin =\n\t\t\t\tdevm_kcalloc(dev, MAX_IN_QUEUE,\n\t\t\t\t\t     sizeof(*mconfig->m_in_pin),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!mconfig->m_in_pin)\n\t\t\treturn -ENOMEM;\n\n\t\tskl_tplg_fill_pin_dynamic_val(mconfig->m_in_pin, MAX_IN_QUEUE,\n\t\t\t\t\t      tkn_elem->value);\n\t\tbreak;\n\n\tcase SKL_TKN_U8_DYN_OUT_PIN:\n\t\tif (!mconfig->m_out_pin)\n\t\t\tmconfig->m_out_pin =\n\t\t\t\tdevm_kcalloc(dev, MAX_IN_QUEUE,\n\t\t\t\t\t     sizeof(*mconfig->m_in_pin),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!mconfig->m_out_pin)\n\t\t\treturn -ENOMEM;\n\n\t\tskl_tplg_fill_pin_dynamic_val(mconfig->m_out_pin, MAX_OUT_QUEUE,\n\t\t\t\t\t      tkn_elem->value);\n\t\tbreak;\n\n\tcase SKL_TKN_U8_TIME_SLOT:\n\t\tmconfig->time_slot = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_CORE_ID:\n\t\tmconfig->core_id = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_MOD_TYPE:\n\t\tmconfig->m_type = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_DEV_TYPE:\n\t\tmconfig->dev_type = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_HW_CONN_TYPE:\n\t\tmconfig->hw_conn_type = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U16_MOD_INST_ID:\n\t\tmconfig->id.instance_id =\n\t\ttkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_MEM_PAGES:\n\tcase SKL_TKN_U32_MAX_MCPS:\n\tcase SKL_TKN_U32_OBS:\n\tcase SKL_TKN_U32_IBS:\n\t\tret = skl_tplg_fill_res_tkn(dev, tkn_elem, res, pin_index, dir);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_VBUS_ID:\n\t\tmconfig->vbus_id = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PARAMS_FIXUP:\n\t\tmconfig->params_fixup = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_CONVERTER:\n\t\tmconfig->converter = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_D0I3_CAPS:\n\t\tmconfig->d0i3_caps = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_ID:\n\t\tret = skl_tplg_add_pipe(dev,\n\t\t\t\tmconfig, skl, tkn_elem);\n\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tis_pipe_exists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn is_pipe_exists;\n\t\t}\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_CONFIG_ID:\n\t\tconf_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIPE_CONN_TYPE:\n\tcase SKL_TKN_U32_PIPE_PRIORITY:\n\tcase SKL_TKN_U32_PIPE_MEM_PGS:\n\tcase SKL_TKN_U32_PMODE:\n\tcase SKL_TKN_U32_PIPE_DIRECTION:\n\tcase SKL_TKN_U32_NUM_CONFIGS:\n\t\tif (is_pipe_exists) {\n\t\t\tret = skl_tplg_fill_pipe_tkn(dev, mconfig->pipe,\n\t\t\t\t\ttkn_elem->token, tkn_elem->value);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PATH_MEM_PGS:\n\tcase SKL_TKN_U32_CFG_FREQ:\n\tcase SKL_TKN_U8_CFG_CHAN:\n\tcase SKL_TKN_U8_CFG_BPS:\n\t\tif (mconfig->pipe->nr_cfgs) {\n\t\t\tret = skl_tplg_fill_pipe_cfg(dev, mconfig->pipe,\n\t\t\t\t\ttkn_elem->token, tkn_elem->value,\n\t\t\t\t\tconf_idx, dir);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase SKL_TKN_CFG_MOD_RES_ID:\n\t\tmconfig->mod_cfg[conf_idx].res_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_CFG_MOD_FMT_ID:\n\t\tmconfig->mod_cfg[conf_idx].fmt_idx = tkn_elem->value;\n\t\tbreak;\n\n\t \n\tcase SKL_TKN_U32_DIR_PIN_COUNT:\n\t\tdir = tkn_elem->value & SKL_IN_DIR_BIT_MASK;\n\t\tpin_index = (tkn_elem->value &\n\t\t\tSKL_PIN_COUNT_MASK) >> 4;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_CH:\n\tcase SKL_TKN_U32_FMT_FREQ:\n\tcase SKL_TKN_U32_FMT_BIT_DEPTH:\n\tcase SKL_TKN_U32_FMT_SAMPLE_SIZE:\n\tcase SKL_TKN_U32_FMT_CH_CONFIG:\n\tcase SKL_TKN_U32_FMT_INTERLEAVE:\n\tcase SKL_TKN_U32_FMT_SAMPLE_TYPE:\n\tcase SKL_TKN_U32_FMT_CH_MAP:\n\t\tret = skl_tplg_widget_fill_fmt(dev, iface, tkn_elem->token,\n\t\t\t\ttkn_elem->value, dir, pin_index);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PIN_MOD_ID:\n\tcase SKL_TKN_U32_PIN_INST_ID:\n\tcase SKL_TKN_UUID:\n\t\tret = skl_tplg_fill_pins_info(dev,\n\t\t\t\tmconfig, tkn_elem, dir,\n\t\t\t\tpin_index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_CFG_IDX:\n\t\tif (tkn_elem->value > SKL_MAX_PARAMS_TYPES)\n\t\t\treturn -EINVAL;\n\n\t\tmconfig->fmt_cfg_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_CAPS_SIZE:\n\t\tmconfig->formats_config[mconfig->fmt_cfg_idx].caps_size =\n\t\t\ttkn_elem->value;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_CAPS_SET_PARAMS:\n\t\tmconfig->formats_config[mconfig->fmt_cfg_idx].set_params =\n\t\t\t\ttkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_CAPS_PARAMS_ID:\n\t\tmconfig->formats_config[mconfig->fmt_cfg_idx].param_id =\n\t\t\t\ttkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_PROC_DOMAIN:\n\t\tmconfig->domain =\n\t\t\ttkn_elem->value;\n\n\t\tbreak;\n\n\tcase SKL_TKN_U32_DMA_BUF_SIZE:\n\t\tmconfig->dma_buffer_size = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_IN_PIN_TYPE:\n\tcase SKL_TKN_U8_OUT_PIN_TYPE:\n\tcase SKL_TKN_U8_CONN_TYPE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Token %d not handled\\n\",\n\t\t\t\ttkn_elem->token);\n\t\treturn -EINVAL;\n\t}\n\n\ttkn_count++;\n\n\treturn tkn_count;\n}\n\n \nstatic int skl_tplg_get_tokens(struct device *dev,\n\t\tchar *pvt_data,\tstruct skl_dev *skl,\n\t\tstruct skl_module_cfg *mconfig, int block_size)\n{\n\tstruct snd_soc_tplg_vendor_array *array;\n\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem;\n\tint tkn_count = 0, ret;\n\tint off = 0, tuple_size = 0;\n\tbool is_module_guid = true;\n\n\tif (block_size <= 0)\n\t\treturn -EINVAL;\n\n\twhile (tuple_size < block_size) {\n\t\tarray = (struct snd_soc_tplg_vendor_array *)(pvt_data + off);\n\n\t\toff += array->size;\n\n\t\tswitch (array->type) {\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_STRING:\n\t\t\tdev_warn(dev, \"no string tokens expected for skl tplg\\n\");\n\t\t\tcontinue;\n\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_UUID:\n\t\t\tif (is_module_guid) {\n\t\t\t\tret = skl_tplg_get_uuid(dev, (guid_t *)mconfig->guid,\n\t\t\t\t\t\t\tarray->uuid);\n\t\t\t\tis_module_guid = false;\n\t\t\t} else {\n\t\t\t\tret = skl_tplg_get_token(dev, array->value, skl,\n\t\t\t\t\t\t\t mconfig);\n\t\t\t}\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\ttuple_size += sizeof(*array->uuid);\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\ttkn_elem = array->value;\n\t\t\ttkn_count = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (tkn_count <= (array->num_elems - 1)) {\n\t\t\tret = skl_tplg_get_token(dev, tkn_elem,\n\t\t\t\t\tskl, mconfig);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\ttkn_count = tkn_count + ret;\n\t\t\ttkn_elem++;\n\t\t}\n\n\t\ttuple_size += tkn_count * sizeof(*tkn_elem);\n\t}\n\n\treturn off;\n}\n\n \nstatic int skl_tplg_get_desc_blocks(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_array *array)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem;\n\n\ttkn_elem = array->value;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_U8_NUM_BLOCKS:\n\tcase SKL_TKN_U8_BLOCK_TYPE:\n\tcase SKL_TKN_U16_BLOCK_SIZE:\n\t\treturn tkn_elem->value;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid descriptor token %d\\n\", tkn_elem->token);\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\n \nstatic int skl_tplg_add_pipe_v4(struct device *dev,\n\t\t\tstruct skl_module_cfg *mconfig, struct skl_dev *skl,\n\t\t\tstruct skl_dfw_v4_pipe *dfw_pipe)\n{\n\tstruct skl_pipeline *ppl;\n\tstruct skl_pipe *pipe;\n\tstruct skl_pipe_params *params;\n\n\tlist_for_each_entry(ppl, &skl->ppl_list, node) {\n\t\tif (ppl->pipe->ppl_id == dfw_pipe->pipe_id) {\n\t\t\tmconfig->pipe = ppl->pipe;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tppl = devm_kzalloc(dev, sizeof(*ppl), GFP_KERNEL);\n\tif (!ppl)\n\t\treturn -ENOMEM;\n\n\tpipe = devm_kzalloc(dev, sizeof(*pipe), GFP_KERNEL);\n\tif (!pipe)\n\t\treturn -ENOMEM;\n\n\tparams = devm_kzalloc(dev, sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tpipe->ppl_id = dfw_pipe->pipe_id;\n\tpipe->memory_pages = dfw_pipe->memory_pages;\n\tpipe->pipe_priority = dfw_pipe->pipe_priority;\n\tpipe->conn_type = dfw_pipe->conn_type;\n\tpipe->state = SKL_PIPE_INVALID;\n\tpipe->p_params = params;\n\tINIT_LIST_HEAD(&pipe->w_list);\n\n\tppl->pipe = pipe;\n\tlist_add(&ppl->node, &skl->ppl_list);\n\n\tmconfig->pipe = pipe;\n\n\treturn 0;\n}\n\nstatic void skl_fill_module_pin_info_v4(struct skl_dfw_v4_module_pin *dfw_pin,\n\t\t\t\t\tstruct skl_module_pin *m_pin,\n\t\t\t\t\tbool is_dynamic, int max_pin)\n{\n\tint i;\n\n\tfor (i = 0; i < max_pin; i++) {\n\t\tm_pin[i].id.module_id = dfw_pin[i].module_id;\n\t\tm_pin[i].id.instance_id = dfw_pin[i].instance_id;\n\t\tm_pin[i].in_use = false;\n\t\tm_pin[i].is_dynamic = is_dynamic;\n\t\tm_pin[i].pin_state = SKL_PIN_UNBIND;\n\t}\n}\n\nstatic void skl_tplg_fill_fmt_v4(struct skl_module_pin_fmt *dst_fmt,\n\t\t\t\t struct skl_dfw_v4_module_fmt *src_fmt,\n\t\t\t\t int pins)\n{\n\tint i;\n\n\tfor (i = 0; i < pins; i++) {\n\t\tdst_fmt[i].fmt.channels  = src_fmt[i].channels;\n\t\tdst_fmt[i].fmt.s_freq = src_fmt[i].freq;\n\t\tdst_fmt[i].fmt.bit_depth = src_fmt[i].bit_depth;\n\t\tdst_fmt[i].fmt.valid_bit_depth = src_fmt[i].valid_bit_depth;\n\t\tdst_fmt[i].fmt.ch_cfg = src_fmt[i].ch_cfg;\n\t\tdst_fmt[i].fmt.ch_map = src_fmt[i].ch_map;\n\t\tdst_fmt[i].fmt.interleaving_style =\n\t\t\t\t\t\tsrc_fmt[i].interleaving_style;\n\t\tdst_fmt[i].fmt.sample_type = src_fmt[i].sample_type;\n\t}\n}\n\nstatic int skl_tplg_get_pvt_data_v4(struct snd_soc_tplg_dapm_widget *tplg_w,\n\t\t\t\t    struct skl_dev *skl, struct device *dev,\n\t\t\t\t    struct skl_module_cfg *mconfig)\n{\n\tstruct skl_dfw_v4_module *dfw =\n\t\t\t\t(struct skl_dfw_v4_module *)tplg_w->priv.data;\n\tint ret;\n\tint idx = mconfig->fmt_cfg_idx;\n\n\tdev_dbg(dev, \"Parsing Skylake v4 widget topology data\\n\");\n\n\tret = guid_parse(dfw->uuid, (guid_t *)mconfig->guid);\n\tif (ret)\n\t\treturn ret;\n\tmconfig->id.module_id = -1;\n\tmconfig->id.instance_id = dfw->instance_id;\n\tmconfig->module->resources[0].cpc = dfw->max_mcps / 1000;\n\tmconfig->module->resources[0].ibs = dfw->ibs;\n\tmconfig->module->resources[0].obs = dfw->obs;\n\tmconfig->core_id = dfw->core_id;\n\tmconfig->module->max_input_pins = dfw->max_in_queue;\n\tmconfig->module->max_output_pins = dfw->max_out_queue;\n\tmconfig->module->loadable = dfw->is_loadable;\n\tskl_tplg_fill_fmt_v4(mconfig->module->formats[0].inputs, dfw->in_fmt,\n\t\t\t     MAX_IN_QUEUE);\n\tskl_tplg_fill_fmt_v4(mconfig->module->formats[0].outputs, dfw->out_fmt,\n\t\t\t     MAX_OUT_QUEUE);\n\n\tmconfig->params_fixup = dfw->params_fixup;\n\tmconfig->converter = dfw->converter;\n\tmconfig->m_type = dfw->module_type;\n\tmconfig->vbus_id = dfw->vbus_id;\n\tmconfig->module->resources[0].is_pages = dfw->mem_pages;\n\n\tret = skl_tplg_add_pipe_v4(dev, mconfig, skl, &dfw->pipe);\n\tif (ret)\n\t\treturn ret;\n\n\tmconfig->dev_type = dfw->dev_type;\n\tmconfig->hw_conn_type = dfw->hw_conn_type;\n\tmconfig->time_slot = dfw->time_slot;\n\tmconfig->formats_config[idx].caps_size = dfw->caps.caps_size;\n\n\tmconfig->m_in_pin = devm_kcalloc(dev,\n\t\t\t\tMAX_IN_QUEUE, sizeof(*mconfig->m_in_pin),\n\t\t\t\tGFP_KERNEL);\n\tif (!mconfig->m_in_pin)\n\t\treturn -ENOMEM;\n\n\tmconfig->m_out_pin = devm_kcalloc(dev,\n\t\t\t\tMAX_OUT_QUEUE, sizeof(*mconfig->m_out_pin),\n\t\t\t\tGFP_KERNEL);\n\tif (!mconfig->m_out_pin)\n\t\treturn -ENOMEM;\n\n\tskl_fill_module_pin_info_v4(dfw->in_pin, mconfig->m_in_pin,\n\t\t\t\t    dfw->is_dynamic_in_pin,\n\t\t\t\t    mconfig->module->max_input_pins);\n\tskl_fill_module_pin_info_v4(dfw->out_pin, mconfig->m_out_pin,\n\t\t\t\t    dfw->is_dynamic_out_pin,\n\t\t\t\t    mconfig->module->max_output_pins);\n\n\tif (mconfig->formats_config[idx].caps_size) {\n\t\tmconfig->formats_config[idx].set_params = dfw->caps.set_params;\n\t\tmconfig->formats_config[idx].param_id = dfw->caps.param_id;\n\t\tmconfig->formats_config[idx].caps =\n\t\tdevm_kzalloc(dev, mconfig->formats_config[idx].caps_size,\n\t\t\t     GFP_KERNEL);\n\t\tif (!mconfig->formats_config[idx].caps)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(mconfig->formats_config[idx].caps, dfw->caps.caps,\n\t\t       dfw->caps.caps_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_get_caps_data(struct device *dev, char *data,\n\t\t\t\t  struct skl_module_cfg *mconfig)\n{\n\tint idx = mconfig->fmt_cfg_idx;\n\n\tif (mconfig->formats_config[idx].caps_size > 0) {\n\t\tmconfig->formats_config[idx].caps =\n\t\t\tdevm_kzalloc(dev, mconfig->formats_config[idx].caps_size,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!mconfig->formats_config[idx].caps)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(mconfig->formats_config[idx].caps, data,\n\t\t       mconfig->formats_config[idx].caps_size);\n\t}\n\n\treturn mconfig->formats_config[idx].caps_size;\n}\n\n \nstatic int skl_tplg_get_pvt_data(struct snd_soc_tplg_dapm_widget *tplg_w,\n\t\t\t\tstruct skl_dev *skl, struct device *dev,\n\t\t\t\tstruct skl_module_cfg *mconfig)\n{\n\tstruct snd_soc_tplg_vendor_array *array;\n\tint num_blocks, block_size, block_type, off = 0;\n\tchar *data;\n\tint ret;\n\n\t \n\tif (uuid_is_valid((char *)tplg_w->priv.data))\n\t\treturn skl_tplg_get_pvt_data_v4(tplg_w, skl, dev, mconfig);\n\n\t \n\tarray = (struct snd_soc_tplg_vendor_array *)tplg_w->priv.data;\n\tret = skl_tplg_get_desc_blocks(dev, array);\n\tif (ret < 0)\n\t\treturn ret;\n\tnum_blocks = ret;\n\n\toff += array->size;\n\t \n\twhile (num_blocks > 0) {\n\t\tarray = (struct snd_soc_tplg_vendor_array *)\n\t\t\t\t(tplg_w->priv.data + off);\n\n\t\tret = skl_tplg_get_desc_blocks(dev, array);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tblock_type = ret;\n\t\toff += array->size;\n\n\t\tarray = (struct snd_soc_tplg_vendor_array *)\n\t\t\t(tplg_w->priv.data + off);\n\n\t\tret = skl_tplg_get_desc_blocks(dev, array);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tblock_size = ret;\n\t\toff += array->size;\n\n\t\tdata = (tplg_w->priv.data + off);\n\n\t\tif (block_type == SKL_TYPE_TUPLE) {\n\t\t\tret = skl_tplg_get_tokens(dev, data,\n\t\t\t\t\tskl, mconfig, block_size);\n\t\t} else {\n\t\t\tret = skl_tplg_get_caps_data(dev, data, mconfig);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t--num_blocks;\n\t\toff += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void skl_clear_pin_config(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_dapm_widget *w)\n{\n\tint i;\n\tstruct skl_module_cfg *mconfig;\n\tstruct skl_pipe *pipe;\n\n\tif (!strncmp(w->dapm->component->name, component->name,\n\t\t\t\t\tstrlen(component->name))) {\n\t\tmconfig = w->priv;\n\t\tpipe = mconfig->pipe;\n\t\tfor (i = 0; i < mconfig->module->max_input_pins; i++) {\n\t\t\tmconfig->m_in_pin[i].in_use = false;\n\t\t\tmconfig->m_in_pin[i].pin_state = SKL_PIN_UNBIND;\n\t\t}\n\t\tfor (i = 0; i < mconfig->module->max_output_pins; i++) {\n\t\t\tmconfig->m_out_pin[i].in_use = false;\n\t\t\tmconfig->m_out_pin[i].pin_state = SKL_PIN_UNBIND;\n\t\t}\n\t\tpipe->state = SKL_PIPE_INVALID;\n\t\tmconfig->m_state = SKL_MODULE_UNINIT;\n\t}\n}\n\nvoid skl_cleanup_resources(struct skl_dev *skl)\n{\n\tstruct snd_soc_component *soc_component = skl->component;\n\tstruct snd_soc_dapm_widget *w;\n\tstruct snd_soc_card *card;\n\n\tif (soc_component == NULL)\n\t\treturn;\n\n\tcard = soc_component->card;\n\tif (!snd_soc_card_is_instantiated(card))\n\t\treturn;\n\n\tlist_for_each_entry(w, &card->widgets, list) {\n\t\tif (is_skl_dsp_widget_type(w, skl->dev) && w->priv != NULL)\n\t\t\tskl_clear_pin_config(soc_component, w);\n\t}\n\n\tskl_clear_module_cnt(skl->dsp);\n}\n\n \nstatic int skl_tplg_widget_load(struct snd_soc_component *cmpnt, int index,\n\t\t\t\tstruct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tint ret;\n\tstruct hdac_bus *bus = snd_soc_component_get_drvdata(cmpnt);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_module_cfg *mconfig;\n\n\tif (!tplg_w->priv.size)\n\t\tgoto bind_event;\n\n\tmconfig = devm_kzalloc(bus->dev, sizeof(*mconfig), GFP_KERNEL);\n\n\tif (!mconfig)\n\t\treturn -ENOMEM;\n\n\tif (skl->nr_modules == 0) {\n\t\tmconfig->module = devm_kzalloc(bus->dev,\n\t\t\t\tsizeof(*mconfig->module), GFP_KERNEL);\n\t\tif (!mconfig->module)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tw->priv = mconfig;\n\n\t \n\tmconfig->id.module_id = -1;\n\n\t \n\tmconfig->fmt_cfg_idx = SKL_PARAM_INIT;\n\n\t \n\tret = skl_tplg_get_pvt_data(tplg_w, skl, bus->dev, mconfig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tskl_debug_init_module(skl->debugfs, w, mconfig);\n\nbind_event:\n\tif (tplg_w->event_type == 0) {\n\t\tdev_dbg(bus->dev, \"ASoC: No event handler required\\n\");\n\t\treturn 0;\n\t}\n\n\tret = snd_soc_tplg_widget_bind_event(w, skl_tplg_widget_ops,\n\t\t\t\t\tARRAY_SIZE(skl_tplg_widget_ops),\n\t\t\t\t\ttplg_w->event_type);\n\n\tif (ret) {\n\t\tdev_err(bus->dev, \"%s: No matching event handlers found for %d\\n\",\n\t\t\t\t\t__func__, tplg_w->event_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_init_algo_data(struct device *dev, struct soc_bytes_ext *be,\n\t\t\t\t\tstruct snd_soc_tplg_bytes_control *bc)\n{\n\tstruct skl_algo_data *ac;\n\tstruct skl_dfw_algo_data *dfw_ac =\n\t\t\t\t(struct skl_dfw_algo_data *)bc->priv.data;\n\n\tac = devm_kzalloc(dev, sizeof(*ac), GFP_KERNEL);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\t \n\tac->max = dfw_ac->max;\n\tac->param_id = dfw_ac->param_id;\n\tac->set_params = dfw_ac->set_params;\n\tac->size = dfw_ac->max;\n\n\tif (ac->max) {\n\t\tac->params = devm_kzalloc(dev, ac->max, GFP_KERNEL);\n\t\tif (!ac->params)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(ac->params, dfw_ac->params, ac->max);\n\t}\n\n\tbe->dobj.private  = ac;\n\treturn 0;\n}\n\nstatic int skl_init_enum_data(struct device *dev, struct soc_enum *se,\n\t\t\t\tstruct snd_soc_tplg_enum_control *ec)\n{\n\n\tvoid *data;\n\n\tif (ec->priv.size) {\n\t\tdata = devm_kzalloc(dev, sizeof(ec->priv.size), GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(data, ec->priv.data, ec->priv.size);\n\t\tse->dobj.private = data;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int skl_tplg_control_load(struct snd_soc_component *cmpnt,\n\t\t\t\tint index,\n\t\t\t\tstruct snd_kcontrol_new *kctl,\n\t\t\t\tstruct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct soc_bytes_ext *sb;\n\tstruct snd_soc_tplg_bytes_control *tplg_bc;\n\tstruct snd_soc_tplg_enum_control *tplg_ec;\n\tstruct hdac_bus *bus  = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *se;\n\n\tswitch (hdr->ops.info) {\n\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\ttplg_bc = container_of(hdr,\n\t\t\t\tstruct snd_soc_tplg_bytes_control, hdr);\n\t\tif (kctl->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\t\tsb = (struct soc_bytes_ext *)kctl->private_value;\n\t\t\tif (tplg_bc->priv.size)\n\t\t\t\treturn skl_init_algo_data(\n\t\t\t\t\t\tbus->dev, sb, tplg_bc);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_TPLG_CTL_ENUM:\n\t\ttplg_ec = container_of(hdr,\n\t\t\t\tstruct snd_soc_tplg_enum_control, hdr);\n\t\tif (kctl->access & SNDRV_CTL_ELEM_ACCESS_READ) {\n\t\t\tse = (struct soc_enum *)kctl->private_value;\n\t\t\tif (tplg_ec->priv.size)\n\t\t\t\tskl_init_enum_data(bus->dev, se, tplg_ec);\n\t\t}\n\n\t\t \n\n\t\tif (hdr->ops.get == SKL_CONTROL_TYPE_MULTI_IO_SELECT_DMIC)\n\t\t\tkctl->access = SNDRV_CTL_ELEM_ACCESS_READ;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(bus->dev, \"Control load not supported %d:%d:%d\\n\",\n\t\t\thdr->ops.get, hdr->ops.put, hdr->ops.info);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_fill_str_mfest_tkn(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_string_elem *str_elem,\n\t\tstruct skl_dev *skl)\n{\n\tint tkn_count = 0;\n\tstatic int ref_count;\n\n\tswitch (str_elem->token) {\n\tcase SKL_TKN_STR_LIB_NAME:\n\t\tif (ref_count > skl->lib_count - 1) {\n\t\t\tref_count = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstrncpy(skl->lib_info[ref_count].name,\n\t\t\tstr_elem->string,\n\t\t\tARRAY_SIZE(skl->lib_info[ref_count].name));\n\t\tref_count++;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Not a string token %d\\n\", str_elem->token);\n\t\tbreak;\n\t}\n\ttkn_count++;\n\n\treturn tkn_count;\n}\n\nstatic int skl_tplg_get_str_tkn(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_array *array,\n\t\tstruct skl_dev *skl)\n{\n\tint tkn_count = 0, ret;\n\tstruct snd_soc_tplg_vendor_string_elem *str_elem;\n\n\tstr_elem = (struct snd_soc_tplg_vendor_string_elem *)array->value;\n\twhile (tkn_count < array->num_elems) {\n\t\tret = skl_tplg_fill_str_mfest_tkn(dev, str_elem, skl);\n\t\tstr_elem++;\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttkn_count = tkn_count + ret;\n\t}\n\n\treturn tkn_count;\n}\n\nstatic int skl_tplg_manifest_fill_fmt(struct device *dev,\n\t\tstruct skl_module_iface *fmt,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tu32 dir, int fmt_idx)\n{\n\tstruct skl_module_pin_fmt *dst_fmt;\n\tstruct skl_module_fmt *mod_fmt;\n\tint ret;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tswitch (dir) {\n\tcase SKL_DIR_IN:\n\t\tdst_fmt = &fmt->inputs[fmt_idx];\n\t\tbreak;\n\n\tcase SKL_DIR_OUT:\n\t\tdst_fmt = &fmt->outputs[fmt_idx];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid direction: %d\\n\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\tmod_fmt = &dst_fmt->fmt;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_MM_U32_INTF_PIN_ID:\n\t\tdst_fmt->id = tkn_elem->value;\n\t\tbreak;\n\n\tdefault:\n\t\tret = skl_tplg_fill_fmt(dev, mod_fmt, tkn_elem->token,\n\t\t\t\t\ttkn_elem->value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_fill_mod_info(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tstruct skl_module *mod)\n{\n\n\tif (!mod)\n\t\treturn -EINVAL;\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_U8_IN_PIN_TYPE:\n\t\tmod->input_pin_type = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_OUT_PIN_TYPE:\n\t\tmod->output_pin_type = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_IN_QUEUE_COUNT:\n\t\tmod->max_input_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_OUT_QUEUE_COUNT:\n\t\tmod->max_output_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U8_NUM_RES:\n\t\tmod->nr_resources = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U8_NUM_INTF:\n\t\tmod->nr_interfaces = tkn_elem->value;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid mod info token %d\", tkn_elem->token);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int skl_tplg_get_int_tkn(struct device *dev,\n\t\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem,\n\t\tstruct skl_dev *skl)\n{\n\tint tkn_count = 0, ret;\n\tstatic int mod_idx, res_val_idx, intf_val_idx, dir, pin_idx;\n\tstruct skl_module_res *res = NULL;\n\tstruct skl_module_iface *fmt = NULL;\n\tstruct skl_module *mod = NULL;\n\tstatic struct skl_astate_param *astate_table;\n\tstatic int astate_cfg_idx, count;\n\tint i;\n\tsize_t size;\n\n\tif (skl->modules) {\n\t\tmod = skl->modules[mod_idx];\n\t\tres = &mod->resources[res_val_idx];\n\t\tfmt = &mod->formats[intf_val_idx];\n\t}\n\n\tswitch (tkn_elem->token) {\n\tcase SKL_TKN_U32_LIB_COUNT:\n\t\tskl->lib_count = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_NUM_MOD:\n\t\tskl->nr_modules = tkn_elem->value;\n\t\tskl->modules = devm_kcalloc(dev, skl->nr_modules,\n\t\t\t\tsizeof(*skl->modules), GFP_KERNEL);\n\t\tif (!skl->modules)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < skl->nr_modules; i++) {\n\t\t\tskl->modules[i] = devm_kzalloc(dev,\n\t\t\t\t\tsizeof(struct skl_module), GFP_KERNEL);\n\t\t\tif (!skl->modules[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U8_MOD_IDX:\n\t\tmod_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_ASTATE_COUNT:\n\t\tif (astate_table != NULL) {\n\t\t\tdev_err(dev, \"More than one entry for A-State count\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tkn_elem->value > SKL_MAX_ASTATE_CFG) {\n\t\t\tdev_err(dev, \"Invalid A-State count %d\\n\",\n\t\t\t\ttkn_elem->value);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsize = struct_size(skl->cfg.astate_cfg, astate_table,\n\t\t\t\t   tkn_elem->value);\n\t\tskl->cfg.astate_cfg = devm_kzalloc(dev, size, GFP_KERNEL);\n\t\tif (!skl->cfg.astate_cfg)\n\t\t\treturn -ENOMEM;\n\n\t\tastate_table = skl->cfg.astate_cfg->astate_table;\n\t\tcount = skl->cfg.astate_cfg->count = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_ASTATE_IDX:\n\t\tif (tkn_elem->value >= count) {\n\t\t\tdev_err(dev, \"Invalid A-State index %d\\n\",\n\t\t\t\ttkn_elem->value);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tastate_cfg_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_ASTATE_KCPS:\n\t\tastate_table[astate_cfg_idx].kcps = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_ASTATE_CLK_SRC:\n\t\tastate_table[astate_cfg_idx].clk_src = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U8_IN_PIN_TYPE:\n\tcase SKL_TKN_U8_OUT_PIN_TYPE:\n\tcase SKL_TKN_U8_IN_QUEUE_COUNT:\n\tcase SKL_TKN_U8_OUT_QUEUE_COUNT:\n\tcase SKL_TKN_MM_U8_NUM_RES:\n\tcase SKL_TKN_MM_U8_NUM_INTF:\n\t\tret = skl_tplg_fill_mod_info(dev, tkn_elem, mod);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_DIR_PIN_COUNT:\n\t\tdir = tkn_elem->value & SKL_IN_DIR_BIT_MASK;\n\t\tpin_idx = (tkn_elem->value & SKL_PIN_COUNT_MASK) >> 4;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_RES_ID:\n\t\tif (!res)\n\t\t\treturn -EINVAL;\n\n\t\tres->id = tkn_elem->value;\n\t\tres_val_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_FMT_ID:\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\n\t\tfmt->fmt_idx = tkn_elem->value;\n\t\tintf_val_idx = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_CPS:\n\tcase SKL_TKN_MM_U32_DMA_SIZE:\n\tcase SKL_TKN_MM_U32_CPC:\n\tcase SKL_TKN_U32_MEM_PAGES:\n\tcase SKL_TKN_U32_OBS:\n\tcase SKL_TKN_U32_IBS:\n\tcase SKL_TKN_MM_U32_RES_PIN_ID:\n\tcase SKL_TKN_MM_U32_PIN_BUF:\n\t\tret = skl_tplg_fill_res_tkn(dev, tkn_elem, res, pin_idx, dir);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_NUM_IN_FMT:\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\n\t\tres->nr_input_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_MM_U32_NUM_OUT_FMT:\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\n\t\tres->nr_output_pins = tkn_elem->value;\n\t\tbreak;\n\n\tcase SKL_TKN_U32_FMT_CH:\n\tcase SKL_TKN_U32_FMT_FREQ:\n\tcase SKL_TKN_U32_FMT_BIT_DEPTH:\n\tcase SKL_TKN_U32_FMT_SAMPLE_SIZE:\n\tcase SKL_TKN_U32_FMT_CH_CONFIG:\n\tcase SKL_TKN_U32_FMT_INTERLEAVE:\n\tcase SKL_TKN_U32_FMT_SAMPLE_TYPE:\n\tcase SKL_TKN_U32_FMT_CH_MAP:\n\tcase SKL_TKN_MM_U32_INTF_PIN_ID:\n\t\tret = skl_tplg_manifest_fill_fmt(dev, fmt, tkn_elem,\n\t\t\t\t\t\t dir, pin_idx);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Not a manifest token %d\\n\", tkn_elem->token);\n\t\treturn -EINVAL;\n\t}\n\ttkn_count++;\n\n\treturn tkn_count;\n}\n\n \nstatic int skl_tplg_get_manifest_tkn(struct device *dev,\n\t\tchar *pvt_data, struct skl_dev *skl,\n\t\tint block_size)\n{\n\tint tkn_count = 0, ret;\n\tint off = 0, tuple_size = 0;\n\tu8 uuid_index = 0;\n\tstruct snd_soc_tplg_vendor_array *array;\n\tstruct snd_soc_tplg_vendor_value_elem *tkn_elem;\n\n\tif (block_size <= 0)\n\t\treturn -EINVAL;\n\n\twhile (tuple_size < block_size) {\n\t\tarray = (struct snd_soc_tplg_vendor_array *)(pvt_data + off);\n\t\toff += array->size;\n\t\tswitch (array->type) {\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_STRING:\n\t\t\tret = skl_tplg_get_str_tkn(dev, array, skl);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\ttkn_count = ret;\n\n\t\t\ttuple_size += tkn_count *\n\t\t\t\tsizeof(struct snd_soc_tplg_vendor_string_elem);\n\t\t\tcontinue;\n\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_UUID:\n\t\t\tif (array->uuid->token != SKL_TKN_UUID) {\n\t\t\t\tdev_err(dev, \"Not an UUID token: %d\\n\",\n\t\t\t\t\tarray->uuid->token);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (uuid_index >= skl->nr_modules) {\n\t\t\t\tdev_err(dev, \"Too many UUID tokens\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\timport_guid(&skl->modules[uuid_index++]->uuid,\n\t\t\t\t    array->uuid->uuid);\n\n\t\t\ttuple_size += sizeof(*array->uuid);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\ttkn_elem = array->value;\n\t\t\ttkn_count = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (tkn_count <= array->num_elems - 1) {\n\t\t\tret = skl_tplg_get_int_tkn(dev,\n\t\t\t\t\ttkn_elem, skl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\ttkn_count = tkn_count + ret;\n\t\t\ttkn_elem++;\n\t\t}\n\t\ttuple_size += (tkn_count * sizeof(*tkn_elem));\n\t\ttkn_count = 0;\n\t}\n\n\treturn off;\n}\n\n \nstatic int skl_tplg_get_manifest_data(struct snd_soc_tplg_manifest *manifest,\n\t\t\tstruct device *dev, struct skl_dev *skl)\n{\n\tstruct snd_soc_tplg_vendor_array *array;\n\tint num_blocks, block_size = 0, block_type, off = 0;\n\tchar *data;\n\tint ret;\n\n\t \n\tarray = (struct snd_soc_tplg_vendor_array *)manifest->priv.data;\n\tret = skl_tplg_get_desc_blocks(dev, array);\n\tif (ret < 0)\n\t\treturn ret;\n\tnum_blocks = ret;\n\n\toff += array->size;\n\t \n\twhile (num_blocks > 0) {\n\t\tarray = (struct snd_soc_tplg_vendor_array *)\n\t\t\t\t(manifest->priv.data + off);\n\t\tret = skl_tplg_get_desc_blocks(dev, array);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tblock_type = ret;\n\t\toff += array->size;\n\n\t\tarray = (struct snd_soc_tplg_vendor_array *)\n\t\t\t(manifest->priv.data + off);\n\n\t\tret = skl_tplg_get_desc_blocks(dev, array);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tblock_size = ret;\n\t\toff += array->size;\n\n\t\tdata = (manifest->priv.data + off);\n\n\t\tif (block_type == SKL_TYPE_TUPLE) {\n\t\t\tret = skl_tplg_get_manifest_tkn(dev, data, skl,\n\t\t\t\t\tblock_size);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t--num_blocks;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toff += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_manifest_load(struct snd_soc_component *cmpnt, int index,\n\t\t\t\tstruct snd_soc_tplg_manifest *manifest)\n{\n\tstruct hdac_bus *bus = snd_soc_component_get_drvdata(cmpnt);\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\n\t \n\tif (manifest->priv.size == 0)\n\t\treturn 0;\n\n\tskl_tplg_get_manifest_data(manifest, bus->dev, skl);\n\n\tif (skl->lib_count > SKL_MAX_LIB) {\n\t\tdev_err(bus->dev, \"Exceeding max Library count. Got:%d\\n\",\n\t\t\t\t\tskl->lib_count);\n\t\treturn  -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int skl_tplg_complete(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dobj *dobj;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct snd_ctl_elem_value *val;\n\tint i;\n\n\tval = kmalloc(sizeof(*val), GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tmach = dev_get_platdata(component->card->dev);\n\tlist_for_each_entry(dobj, &component->dobj_list, list) {\n\t\tstruct snd_kcontrol *kcontrol = dobj->control.kcontrol;\n\t\tstruct soc_enum *se;\n\t\tchar **texts;\n\t\tchar chan_text[4];\n\n\t\tif (dobj->type != SND_SOC_DOBJ_ENUM || !kcontrol ||\n\t\t    kcontrol->put != skl_tplg_multi_config_set_dmic)\n\t\t\tcontinue;\n\n\t\tse = (struct soc_enum *)kcontrol->private_value;\n\t\ttexts = dobj->control.dtexts;\n\t\tsprintf(chan_text, \"c%d\", mach->mach_params.dmic_num);\n\n\t\tfor (i = 0; i < se->items; i++) {\n\t\t\tif (strstr(texts[i], chan_text)) {\n\t\t\t\tmemset(val, 0, sizeof(*val));\n\t\t\t\tval->value.enumerated.item[0] = i;\n\t\t\t\tkcontrol->put(kcontrol, val);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(val);\n\treturn 0;\n}\n\nstatic struct snd_soc_tplg_ops skl_tplg_ops  = {\n\t.widget_load = skl_tplg_widget_load,\n\t.control_load = skl_tplg_control_load,\n\t.bytes_ext_ops = skl_tlv_ops,\n\t.bytes_ext_ops_count = ARRAY_SIZE(skl_tlv_ops),\n\t.io_ops = skl_tplg_kcontrol_ops,\n\t.io_ops_count = ARRAY_SIZE(skl_tplg_kcontrol_ops),\n\t.manifest = skl_manifest_load,\n\t.dai_load = skl_dai_load,\n\t.complete = skl_tplg_complete,\n};\n\n \nstatic int skl_tplg_create_pipe_widget_list(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tstruct skl_module_cfg *mcfg = NULL;\n\tstruct skl_pipe_module *p_module = NULL;\n\tstruct skl_pipe *pipe;\n\n\tlist_for_each_entry(w, &component->card->widgets, list) {\n\t\tif (is_skl_dsp_widget_type(w, component->dev) && w->priv) {\n\t\t\tmcfg = w->priv;\n\t\t\tpipe = mcfg->pipe;\n\n\t\t\tp_module = devm_kzalloc(component->dev,\n\t\t\t\t\t\tsizeof(*p_module), GFP_KERNEL);\n\t\t\tif (!p_module)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tp_module->w = w;\n\t\t\tlist_add_tail(&p_module->node, &pipe->w_list);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void skl_tplg_set_pipe_type(struct skl_dev *skl, struct skl_pipe *pipe)\n{\n\tstruct skl_pipe_module *w_module;\n\tstruct snd_soc_dapm_widget *w;\n\tstruct skl_module_cfg *mconfig;\n\tbool host_found = false, link_found = false;\n\n\tlist_for_each_entry(w_module, &pipe->w_list, node) {\n\t\tw = w_module->w;\n\t\tmconfig = w->priv;\n\n\t\tif (mconfig->dev_type == SKL_DEVICE_HDAHOST)\n\t\t\thost_found = true;\n\t\telse if (mconfig->dev_type != SKL_DEVICE_NONE)\n\t\t\tlink_found = true;\n\t}\n\n\tif (host_found && link_found)\n\t\tpipe->passthru = true;\n\telse\n\t\tpipe->passthru = false;\n}\n\n \nint skl_tplg_init(struct snd_soc_component *component, struct hdac_bus *bus)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_pipeline *ppl;\n\n\tret = request_firmware(&fw, skl->tplg_name, bus->dev);\n\tif (ret < 0) {\n\t\tchar alt_tplg_name[64];\n\n\t\tsnprintf(alt_tplg_name, sizeof(alt_tplg_name), \"%s-tplg.bin\",\n\t\t\t skl->mach->drv_name);\n\t\tdev_info(bus->dev, \"tplg fw %s load failed with %d, trying alternative tplg name %s\",\n\t\t\t skl->tplg_name, ret, alt_tplg_name);\n\n\t\tret = request_firmware(&fw, alt_tplg_name, bus->dev);\n\t\tif (!ret)\n\t\t\tgoto component_load;\n\n\t\tdev_info(bus->dev, \"tplg %s failed with %d, falling back to dfw_sst.bin\",\n\t\t\t alt_tplg_name, ret);\n\n\t\tret = request_firmware(&fw, \"dfw_sst.bin\", bus->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Fallback tplg fw %s load failed with %d\\n\",\n\t\t\t\t\t\"dfw_sst.bin\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\ncomponent_load:\n\tret = snd_soc_tplg_component_load(component, &skl_tplg_ops, fw);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"tplg component load failed%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = skl_tplg_create_pipe_widget_list(component);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"tplg create pipe widget list failed%d\\n\",\n\t\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(ppl, &skl->ppl_list, node)\n\t\tskl_tplg_set_pipe_type(skl, ppl->pipe);\n\nerr:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nvoid skl_tplg_exit(struct snd_soc_component *component, struct hdac_bus *bus)\n{\n\tstruct skl_dev *skl = bus_to_skl(bus);\n\tstruct skl_pipeline *ppl, *tmp;\n\n\tlist_for_each_entry_safe(ppl, tmp, &skl->ppl_list, node)\n\t\tlist_del(&ppl->node);\n\n\t \n\tsnd_soc_tplg_component_remove(component);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}