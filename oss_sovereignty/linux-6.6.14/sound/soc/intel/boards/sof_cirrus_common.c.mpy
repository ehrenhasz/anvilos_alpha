{
  "module_name": "sof_cirrus_common.c",
  "hash_id": "dfcb461067096e5f5042921419900247ee55ec5a966eac7b9970a296f81bd5ad",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/sof_cirrus_common.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <sound/sof.h>\n#include \"../../codecs/cs35l41.h\"\n#include \"sof_cirrus_common.h\"\n\n#define CS35L41_HID \"CSC3541\"\n#define CS35L41_MAX_AMPS 4\n\n \nstatic const struct snd_kcontrol_new cs35l41_kcontrols[] = {\n\tSOC_DAPM_PIN_SWITCH(\"WL Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"WR Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"TL Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"TR Spk\"),\n};\n\nstatic const struct snd_soc_dapm_widget cs35l41_dapm_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"WL Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"WR Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"TL Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"TR Spk\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route cs35l41_dapm_routes[] = {\n\t \n\t{\"WL Spk\", NULL, \"WL SPK\"},\n\t{\"WR Spk\", NULL, \"WR SPK\"},\n\t{\"TL Spk\", NULL, \"TL SPK\"},\n\t{\"TR Spk\", NULL, \"TR SPK\"},\n};\n\nstatic struct snd_soc_dai_link_component cs35l41_components[CS35L41_MAX_AMPS];\n\n \nstatic struct snd_soc_codec_conf cs35l41_codec_conf[CS35L41_MAX_AMPS];\n\nstatic int cs35l41_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tint ret;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, cs35l41_dapm_widgets,\n\t\t\t\t\tARRAY_SIZE(cs35l41_dapm_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"fail to add dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, cs35l41_kcontrols,\n\t\t\t\t\tARRAY_SIZE(cs35l41_kcontrols));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"fail to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, cs35l41_dapm_routes,\n\t\t\t\t      ARRAY_SIZE(cs35l41_dapm_routes));\n\n\tif (ret)\n\t\tdev_err(rtd->dev, \"fail to add dapm routes, ret %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic const struct {\n\tunsigned int rx[2];\n} cs35l41_channel_map[] = {\n\t{.rx = {0, 1}},  \n\t{.rx = {1, 0}},  \n\t{.rx = {0, 1}},  \n\t{.rx = {1, 0}},  \n};\n\nstatic int cs35l41_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai;\n\tint clk_freq, i, ret;\n\n\tclk_freq = sof_dai_get_bclk(rtd);  \n\n\tif (clk_freq <= 0) {\n\t\tdev_err(rtd->dev, \"fail to get bclk freq, ret %d\\n\", clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t \n\t\tret = snd_soc_dai_set_sysclk(codec_dai, CS35L41_CLKID_SCLK,\n\t\t\t\t\t     clk_freq, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tdev_err(codec_dai->dev, \"fail to set sysclk, ret %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = snd_soc_component_set_sysclk(codec_dai->component,\n\t\t\t\t\t\t   CS35L41_CLKID_SCLK, 0,\n\t\t\t\t\t\t   clk_freq, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tdev_err(codec_dai->dev, \"fail to set component sysclk, ret %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = snd_soc_dai_set_channel_map(codec_dai, 0, NULL,\n\t\t\t\t\t\t  ARRAY_SIZE(cs35l41_channel_map[i].rx),\n\t\t\t\t\t\t  (unsigned int *)cs35l41_channel_map[i].rx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(codec_dai->dev, \"fail to set channel map, ret %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops cs35l41_ops = {\n\t.hw_params = cs35l41_hw_params,\n};\n\nstatic const char * const cs35l41_name_prefixes[] = { \"WL\", \"WR\", \"TL\", \"TR\" };\n\n \nstatic int cs35l41_compute_codec_conf(void)\n{\n\tstatic const char * const uid_strings[] = { \"0\", \"1\", \"2\", \"3\" };\n\tunsigned int uid, sz = 0;\n\tstruct acpi_device *adev;\n\tstruct device *physdev;\n\n\tfor (uid = 0; uid < CS35L41_MAX_AMPS; uid++) {\n\t\tadev = acpi_dev_get_first_match_dev(CS35L41_HID, uid_strings[uid], -1);\n\t\tif (!adev) {\n\t\t\tpr_devel(\"Cannot find match for HID %s UID %u (%s)\\n\", CS35L41_HID, uid,\n\t\t\t\t cs35l41_name_prefixes[uid]);\n\t\t\tcontinue;\n\t\t}\n\t\tphysdev = get_device(acpi_get_first_physical_node(adev));\n\t\tacpi_dev_put(adev);\n\t\tif (!physdev) {\n\t\t\tpr_devel(\"Cannot find physical node for HID %s UID %u (%s)\\n\", CS35L41_HID,\n\t\t\t\t\tuid, cs35l41_name_prefixes[uid]);\n\t\t\treturn 0;\n\t\t}\n\t\tcs35l41_components[sz].name = dev_name(physdev);\n\t\tcs35l41_components[sz].dai_name = CS35L41_CODEC_DAI;\n\t\tcs35l41_codec_conf[sz].dlc.name = dev_name(physdev);\n\t\tcs35l41_codec_conf[sz].name_prefix = cs35l41_name_prefixes[uid];\n\t\tsz++;\n\t}\n\n\tif (sz != 2 && sz != 4)\n\t\tpr_warn(\"Invalid number of cs35l41 amps found: %d, expected 2 or 4\\n\", sz);\n\treturn sz;\n}\n\nvoid cs35l41_set_dai_link(struct snd_soc_dai_link *link)\n{\n\tlink->num_codecs = cs35l41_compute_codec_conf();\n\tlink->codecs = cs35l41_components;\n\tlink->init = cs35l41_init;\n\tlink->ops = &cs35l41_ops;\n}\nEXPORT_SYMBOL_NS(cs35l41_set_dai_link, SND_SOC_INTEL_SOF_CIRRUS_COMMON);\n\nvoid cs35l41_set_codec_conf(struct snd_soc_card *card)\n{\n\tcard->codec_conf = cs35l41_codec_conf;\n\tcard->num_configs = ARRAY_SIZE(cs35l41_codec_conf);\n}\nEXPORT_SYMBOL_NS(cs35l41_set_codec_conf, SND_SOC_INTEL_SOF_CIRRUS_COMMON);\n\nMODULE_DESCRIPTION(\"ASoC Intel SOF Cirrus Logic helpers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}