{
  "module_name": "sof_es8336.c",
  "hash_id": "731b27a059b1e1133643c0ed3a050353dc7e37d5494218c07fb70bcdf27898bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/sof_es8336.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"hda_dsp_common.h\"\n\n \n#define MAX_NO_PROPS 2\n\n#define SOF_ES8336_SSP_CODEC(quirk)\t\t((quirk) & GENMASK(3, 0))\n#define SOF_ES8336_SSP_CODEC_MASK\t\t(GENMASK(3, 0))\n\n#define SOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK\tBIT(4)\n\n \n#define SOF_SSP_HDMI_CAPTURE_PRESENT\t\tBIT(14)\n#define SOF_NO_OF_HDMI_CAPTURE_SSP_SHIFT\t\t15\n#define SOF_NO_OF_HDMI_CAPTURE_SSP_MASK\t\t(GENMASK(16, 15))\n#define SOF_NO_OF_HDMI_CAPTURE_SSP(quirk)\t\\\n\t(((quirk) << SOF_NO_OF_HDMI_CAPTURE_SSP_SHIFT) & SOF_NO_OF_HDMI_CAPTURE_SSP_MASK)\n\n#define SOF_HDMI_CAPTURE_1_SSP_SHIFT\t\t7\n#define SOF_HDMI_CAPTURE_1_SSP_MASK\t\t(GENMASK(9, 7))\n#define SOF_HDMI_CAPTURE_1_SSP(quirk)\t\\\n\t(((quirk) << SOF_HDMI_CAPTURE_1_SSP_SHIFT) & SOF_HDMI_CAPTURE_1_SSP_MASK)\n\n#define SOF_HDMI_CAPTURE_2_SSP_SHIFT\t\t10\n#define SOF_HDMI_CAPTURE_2_SSP_MASK\t\t(GENMASK(12, 10))\n#define SOF_HDMI_CAPTURE_2_SSP(quirk)\t\\\n\t(((quirk) << SOF_HDMI_CAPTURE_2_SSP_SHIFT) & SOF_HDMI_CAPTURE_2_SSP_MASK)\n\n#define SOF_ES8336_ENABLE_DMIC\t\t\tBIT(5)\n#define SOF_ES8336_JD_INVERTED\t\t\tBIT(6)\n#define SOF_ES8336_HEADPHONE_GPIO\t\tBIT(7)\n#define SOC_ES8336_HEADSET_MIC1\t\t\tBIT(8)\n\nstatic unsigned long quirk;\n\nstatic int quirk_override = -1;\nmodule_param_named(quirk, quirk_override, int, 0444);\nMODULE_PARM_DESC(quirk, \"Board-specific quirk override\");\n\nstruct sof_es8336_private {\n\tstruct device *codec_dev;\n\tstruct gpio_desc *gpio_speakers, *gpio_headphone;\n\tstruct snd_soc_jack jack;\n\tstruct list_head hdmi_pcm_list;\n\tbool speaker_en;\n\tstruct delayed_work pcm_pop_work;\n};\n\nstruct sof_hdmi_pcm {\n\tstruct list_head head;\n\tstruct snd_soc_dai *codec_dai;\n\tint device;\n};\n\nstatic const struct acpi_gpio_params enable_gpio0 = { 0, 0, true };\nstatic const struct acpi_gpio_params enable_gpio1 = { 1, 0, true };\n\nstatic const struct acpi_gpio_mapping acpi_speakers_enable_gpio0[] = {\n\t{ \"speakers-enable-gpios\", &enable_gpio0, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ }\n};\n\nstatic const struct acpi_gpio_mapping acpi_speakers_enable_gpio1[] = {\n\t{ \"speakers-enable-gpios\", &enable_gpio1, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n};\n\nstatic const struct acpi_gpio_mapping acpi_enable_both_gpios[] = {\n\t{ \"speakers-enable-gpios\", &enable_gpio0, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ \"headphone-enable-gpios\", &enable_gpio1, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ }\n};\n\nstatic const struct acpi_gpio_mapping acpi_enable_both_gpios_rev_order[] = {\n\t{ \"speakers-enable-gpios\", &enable_gpio1, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ \"headphone-enable-gpios\", &enable_gpio0, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ }\n};\n\nstatic void log_quirks(struct device *dev)\n{\n\tdev_info(dev, \"quirk mask %#lx\\n\", quirk);\n\tdev_info(dev, \"quirk SSP%ld\\n\",  SOF_ES8336_SSP_CODEC(quirk));\n\tif (quirk & SOF_ES8336_ENABLE_DMIC)\n\t\tdev_info(dev, \"quirk DMIC enabled\\n\");\n\tif (quirk & SOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK)\n\t\tdev_info(dev, \"Speakers GPIO1 quirk enabled\\n\");\n\tif (quirk & SOF_ES8336_HEADPHONE_GPIO)\n\t\tdev_info(dev, \"quirk headphone GPIO enabled\\n\");\n\tif (quirk & SOF_ES8336_JD_INVERTED)\n\t\tdev_info(dev, \"quirk JD inverted enabled\\n\");\n\tif (quirk & SOC_ES8336_HEADSET_MIC1)\n\t\tdev_info(dev, \"quirk headset at mic1 port enabled\\n\");\n}\n\nstatic void pcm_pop_work_events(struct work_struct *work)\n{\n\tstruct sof_es8336_private *priv =\n\t\tcontainer_of(work, struct sof_es8336_private, pcm_pop_work.work);\n\n\tgpiod_set_value_cansleep(priv->gpio_speakers, priv->speaker_en);\n\n\tif (quirk & SOF_ES8336_HEADPHONE_GPIO)\n\t\tgpiod_set_value_cansleep(priv->gpio_headphone, priv->speaker_en);\n\n}\n\nstatic int sof_8336_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(card);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (priv->speaker_en == false)\n\t\t\tif (substream->stream == 0) {\n\t\t\t\tcancel_delayed_work(&priv->pcm_pop_work);\n\t\t\t\tgpiod_set_value_cansleep(priv->gpio_speakers, true);\n\t\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_es8316_speaker_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(card);\n\n\tif (priv->speaker_en == !SND_SOC_DAPM_EVENT_ON(event))\n\t\treturn 0;\n\n\tpriv->speaker_en = !SND_SOC_DAPM_EVENT_ON(event);\n\n\tqueue_delayed_work(system_wq, &priv->pcm_pop_work, msecs_to_jiffies(70));\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget sof_es8316_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Internal Mic\", NULL),\n\n\tSND_SOC_DAPM_SUPPLY(\"Speaker Power\", SND_SOC_NOPM, 0, 0,\n\t\t\t    sof_es8316_speaker_power_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n};\n\nstatic const struct snd_soc_dapm_widget dmic_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"SoC DMIC\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route sof_es8316_audio_map[] = {\n\t{\"Headphone\", NULL, \"HPOL\"},\n\t{\"Headphone\", NULL, \"HPOR\"},\n\n\t \n\t{\"Speaker\", NULL, \"HPOL\"},\n\t{\"Speaker\", NULL, \"HPOR\"},\n\t{\"Speaker\", NULL, \"Speaker Power\"},\n};\n\nstatic const struct snd_soc_dapm_route sof_es8316_headset_mic2_map[] = {\n\t{\"MIC1\", NULL, \"Internal Mic\"},\n\t{\"MIC2\", NULL, \"Headset Mic\"},\n};\n\nstatic const struct snd_soc_dapm_route sof_es8316_headset_mic1_map[] = {\n\t{\"MIC2\", NULL, \"Internal Mic\"},\n\t{\"MIC1\", NULL, \"Headset Mic\"},\n};\n\nstatic const struct snd_soc_dapm_route dmic_map[] = {\n\t \n\t{\"DMic\", NULL, \"SoC DMIC\"},\n};\n\nstatic const struct snd_kcontrol_new sof_es8316_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Internal Mic\"),\n};\n\nstatic struct snd_soc_jack_pin sof_es8316_jack_pins[] = {\n\t{\n\t\t.pin\t= \"Headphone\",\n\t\t.mask\t= SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin\t= \"Headset Mic\",\n\t\t.mask\t= SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int dmic_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct snd_soc_card *card = runtime->card;\n\tint ret;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, dmic_widgets,\n\t\t\t\t\tARRAY_SIZE(dmic_widgets));\n\tif (ret) {\n\t\tdev_err(card->dev, \"DMic widget addition failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, dmic_map,\n\t\t\t\t      ARRAY_SIZE(dmic_map));\n\tif (ret)\n\t\tdev_err(card->dev, \"DMic map addition failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int sof_hdmi_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(runtime->card);\n\tstruct snd_soc_dai *dai = asoc_rtd_to_codec(runtime, 0);\n\tstruct sof_hdmi_pcm *pcm;\n\n\tpcm = devm_kzalloc(runtime->card->dev, sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\n\t \n\tpcm->device = runtime->dai_link->id;\n\tpcm->codec_dai = dai;\n\n\tlist_add_tail(&pcm->head, &priv->hdmi_pcm_list);\n\n\treturn 0;\n}\n\nstatic int sof_es8316_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct snd_soc_component *codec = asoc_rtd_to_codec(runtime, 0)->component;\n\tstruct snd_soc_card *card = runtime->card;\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(card);\n\tconst struct snd_soc_dapm_route *custom_map;\n\tint num_routes;\n\tint ret;\n\n\tcard->dapm.idle_bias_off = true;\n\n\tif (quirk & SOC_ES8336_HEADSET_MIC1) {\n\t\tcustom_map = sof_es8316_headset_mic1_map;\n\t\tnum_routes = ARRAY_SIZE(sof_es8316_headset_mic1_map);\n\t} else {\n\t\tcustom_map = sof_es8316_headset_mic2_map;\n\t\tnum_routes = ARRAY_SIZE(sof_es8316_headset_mic2_map);\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, custom_map, num_routes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_BTN_0,\n\t\t\t\t\t &priv->jack, sof_es8316_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(sof_es8316_jack_pins));\n\tif (ret) {\n\t\tdev_err(card->dev, \"jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(priv->jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\n\tsnd_soc_component_set_jack(codec, &priv->jack, NULL);\n\n\treturn 0;\n}\n\nstatic void sof_es8316_exit(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\n\tsnd_soc_component_set_jack(component, NULL, NULL);\n}\n\nstatic int sof_es8336_quirk_cb(const struct dmi_system_id *id)\n{\n\tquirk = (unsigned long)id->driver_data;\n\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id sof_es8336_quirk_table[] = {\n\t{\n\t\t.callback = sof_es8336_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IP3 tech\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"WN1\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK)\n\t},\n\t{\n\t\t.callback = sof_es8336_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HUAWEI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"BOHB-WAX9-PCB-B2\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_ES8336_HEADPHONE_GPIO |\n\t\t\t\t\tSOC_ES8336_HEADSET_MIC1)\n\t},\n\t{}\n};\n\nstatic int sof_es8336_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tconst int sysclk = 19200000;\n\tint ret;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, 1, sysclk, SND_SOC_CLOCK_OUT);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"%s, Failed to set ES8336 SYSCLK: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct snd_soc_ops sof_es8336_ops = {\n\t.hw_params = sof_es8336_hw_params,\n\t.trigger = sof_8336_trigger,\n};\n\nstatic struct snd_soc_dai_link_component platform_component[] = {\n\t{\n\t\t \n\t\t.name = \"0000:00:1f.3\"\n\t}\n};\n\nSND_SOC_DAILINK_DEF(es8336_codec,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-ESSX8336:00\", \"ES8316 HiFi\")));\n\nstatic struct snd_soc_dai_link_component dmic_component[] = {\n\t{\n\t\t.name = \"dmic-codec\",\n\t\t.dai_name = \"dmic-hifi\",\n\t}\n};\n\nstatic int sof_es8336_late_probe(struct snd_soc_card *card)\n{\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(card);\n\tstruct sof_hdmi_pcm *pcm;\n\n\tif (list_empty(&priv->hdmi_pcm_list))\n\t\treturn -ENOENT;\n\n\tpcm = list_first_entry(&priv->hdmi_pcm_list, struct sof_hdmi_pcm, head);\n\n\treturn hda_dsp_hdmi_build_controls(card, pcm->codec_dai->component);\n}\n\n \nstatic struct snd_soc_card sof_es8336_card = {\n\t.name = \"essx8336\",  \n\t.owner = THIS_MODULE,\n\t.dapm_widgets = sof_es8316_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(sof_es8316_widgets),\n\t.dapm_routes = sof_es8316_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(sof_es8316_audio_map),\n\t.controls = sof_es8316_controls,\n\t.num_controls = ARRAY_SIZE(sof_es8316_controls),\n\t.fully_routed = true,\n\t.late_probe = sof_es8336_late_probe,\n\t.num_links = 1,\n};\n\nstatic struct snd_soc_dai_link *sof_card_dai_links_create(struct device *dev,\n\t\t\t\t\t\t\t  int ssp_codec,\n\t\t\t\t\t\t\t  int dmic_be_num,\n\t\t\t\t\t\t\t  int hdmi_num)\n{\n\tstruct snd_soc_dai_link_component *cpus;\n\tstruct snd_soc_dai_link *links;\n\tstruct snd_soc_dai_link_component *idisp_components;\n\tint hdmi_id_offset = 0;\n\tint id = 0;\n\tint i;\n\n\tlinks = devm_kcalloc(dev, sof_es8336_card.num_links,\n\t\t\t     sizeof(struct snd_soc_dai_link), GFP_KERNEL);\n\tcpus = devm_kcalloc(dev, sof_es8336_card.num_links,\n\t\t\t    sizeof(struct snd_soc_dai_link_component), GFP_KERNEL);\n\tif (!links || !cpus)\n\t\tgoto devm_err;\n\n\t \n\tlinks[id].name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\"SSP%d-Codec\", ssp_codec);\n\tif (!links[id].name)\n\t\tgoto devm_err;\n\n\tlinks[id].id = id;\n\tlinks[id].codecs = es8336_codec;\n\tlinks[id].num_codecs = ARRAY_SIZE(es8336_codec);\n\tlinks[id].platforms = platform_component;\n\tlinks[id].num_platforms = ARRAY_SIZE(platform_component);\n\tlinks[id].init = sof_es8316_init;\n\tlinks[id].exit = sof_es8316_exit;\n\tlinks[id].ops = &sof_es8336_ops;\n\tlinks[id].nonatomic = true;\n\tlinks[id].dpcm_playback = 1;\n\tlinks[id].dpcm_capture = 1;\n\tlinks[id].no_pcm = 1;\n\tlinks[id].cpus = &cpus[id];\n\tlinks[id].num_cpus = 1;\n\n\tlinks[id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t  \"SSP%d Pin\",\n\t\t\t\t\t\t  ssp_codec);\n\tif (!links[id].cpus->dai_name)\n\t\tgoto devm_err;\n\n\tid++;\n\n\t \n\tif (dmic_be_num > 0) {\n\t\t \n\t\tlinks[id].name = \"dmic01\";\n\t\tlinks[id].cpus = &cpus[id];\n\t\tlinks[id].cpus->dai_name = \"DMIC01 Pin\";\n\t\tlinks[id].init = dmic_init;\n\t\tif (dmic_be_num > 1) {\n\t\t\t \n\t\t\tlinks[id + 1].name = \"dmic16k\";\n\t\t\tlinks[id + 1].cpus = &cpus[id + 1];\n\t\t\tlinks[id + 1].cpus->dai_name = \"DMIC16k Pin\";\n\t\t\tdmic_be_num = 2;\n\t\t}\n\t} else {\n\t\t \n\t\thdmi_id_offset = 2;\n\t}\n\n\tfor (i = 0; i < dmic_be_num; i++) {\n\t\tlinks[id].id = id;\n\t\tlinks[id].num_cpus = 1;\n\t\tlinks[id].codecs = dmic_component;\n\t\tlinks[id].num_codecs = ARRAY_SIZE(dmic_component);\n\t\tlinks[id].platforms = platform_component;\n\t\tlinks[id].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[id].ignore_suspend = 1;\n\t\tlinks[id].dpcm_capture = 1;\n\t\tlinks[id].no_pcm = 1;\n\n\t\tid++;\n\t}\n\n\t \n\tif (hdmi_num > 0) {\n\t\tidisp_components = devm_kcalloc(dev,\n\t\t\t\t\t\thdmi_num,\n\t\t\t\t\t\tsizeof(struct snd_soc_dai_link_component),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!idisp_components)\n\t\t\tgoto devm_err;\n\t}\n\n\tfor (i = 1; i <= hdmi_num; i++) {\n\t\tlinks[id].name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\"iDisp%d\", i);\n\t\tif (!links[id].name)\n\t\t\tgoto devm_err;\n\n\t\tlinks[id].id = id + hdmi_id_offset;\n\t\tlinks[id].cpus = &cpus[id];\n\t\tlinks[id].num_cpus = 1;\n\t\tlinks[id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t  \"iDisp%d Pin\", i);\n\t\tif (!links[id].cpus->dai_name)\n\t\t\tgoto devm_err;\n\n\t\tidisp_components[i - 1].name = \"ehdaudio0D2\";\n\t\tidisp_components[i - 1].dai_name = devm_kasprintf(dev,\n\t\t\t\t\t\t\t\t  GFP_KERNEL,\n\t\t\t\t\t\t\t\t  \"intel-hdmi-hifi%d\",\n\t\t\t\t\t\t\t\t  i);\n\t\tif (!idisp_components[i - 1].dai_name)\n\t\t\tgoto devm_err;\n\n\t\tlinks[id].codecs = &idisp_components[i - 1];\n\t\tlinks[id].num_codecs = 1;\n\t\tlinks[id].platforms = platform_component;\n\t\tlinks[id].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[id].init = sof_hdmi_init;\n\t\tlinks[id].dpcm_playback = 1;\n\t\tlinks[id].no_pcm = 1;\n\n\t\tid++;\n\t}\n\n\t \n\tif (quirk & SOF_SSP_HDMI_CAPTURE_PRESENT) {\n\t\tint num_of_hdmi_ssp = (quirk & SOF_NO_OF_HDMI_CAPTURE_SSP_MASK) >>\n\t\t\t\tSOF_NO_OF_HDMI_CAPTURE_SSP_SHIFT;\n\n\t\tfor (i = 1; i <= num_of_hdmi_ssp; i++) {\n\t\t\tint port = (i == 1 ? (quirk & SOF_HDMI_CAPTURE_1_SSP_MASK) >>\n\t\t\t\t\t\tSOF_HDMI_CAPTURE_1_SSP_SHIFT :\n\t\t\t\t\t\t(quirk & SOF_HDMI_CAPTURE_2_SSP_MASK) >>\n\t\t\t\t\t\tSOF_HDMI_CAPTURE_2_SSP_SHIFT);\n\n\t\t\tlinks[id].cpus = &cpus[id];\n\t\t\tlinks[id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\t  \"SSP%d Pin\", port);\n\t\t\tif (!links[id].cpus->dai_name)\n\t\t\t\treturn NULL;\n\t\t\tlinks[id].name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d-HDMI\", port);\n\t\t\tif (!links[id].name)\n\t\t\t\treturn NULL;\n\t\t\tlinks[id].id = id + hdmi_id_offset;\n\t\t\tlinks[id].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[id].num_codecs = 1;\n\t\t\tlinks[id].platforms = platform_component;\n\t\t\tlinks[id].num_platforms = ARRAY_SIZE(platform_component);\n\t\t\tlinks[id].dpcm_capture = 1;\n\t\t\tlinks[id].no_pcm = 1;\n\t\t\tlinks[id].num_cpus = 1;\n\t\t\tid++;\n\t\t}\n\t}\n\n\treturn links;\n\ndevm_err:\n\treturn NULL;\n}\n\nstatic char soc_components[30];\n\n  \nstatic char codec_name[SND_ACPI_I2C_ID_LEN];\n\nstatic int sof_es8336_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_card *card;\n\tstruct snd_soc_acpi_mach *mach = pdev->dev.platform_data;\n\tstruct property_entry props[MAX_NO_PROPS] = {};\n\tstruct sof_es8336_private *priv;\n\tstruct fwnode_handle *fwnode;\n\tstruct acpi_device *adev;\n\tstruct snd_soc_dai_link *dai_links;\n\tstruct device *codec_dev;\n\tconst struct acpi_gpio_mapping *gpio_mapping;\n\tunsigned int cnt = 0;\n\tint dmic_be_num = 0;\n\tint hdmi_num = 3;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tcard = &sof_es8336_card;\n\tcard->dev = dev;\n\n\tif (pdev->id_entry && pdev->id_entry->driver_data)\n\t\tquirk = (unsigned long)pdev->id_entry->driver_data;\n\n\t \n\tdmi_check_system(sof_es8336_quirk_table);\n\n\t \n\tif (mach->tplg_quirk_mask & SND_SOC_ACPI_TPLG_INTEL_SSP_NUMBER) {\n\t\tif (!mach->mach_params.i2s_link_mask) {\n\t\t\tdev_warn(dev, \"No I2S link information provided, using SSP0. This may need to be modified with the quirk module parameter\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tunsigned long ssp;\n\n\t\t\t \n\t\t\tssp = fls(mach->mach_params.i2s_link_mask) - 1;\n\n\t\t\tquirk |= ssp;\n\t\t}\n\t}\n\n\tif (mach->mach_params.dmic_num)\n\t\tquirk |= SOF_ES8336_ENABLE_DMIC;\n\n\tif (quirk_override != -1) {\n\t\tdev_info(dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t quirk, quirk_override);\n\t\tquirk = quirk_override;\n\t}\n\tlog_quirks(dev);\n\n\tif (quirk & SOF_ES8336_ENABLE_DMIC)\n\t\tdmic_be_num = 2;\n\n\t \n\tsof_es8336_card.num_links = 1 + dmic_be_num + hdmi_num;\n\n\tif (quirk & SOF_SSP_HDMI_CAPTURE_PRESENT)\n\t\tsof_es8336_card.num_links += (quirk & SOF_NO_OF_HDMI_CAPTURE_SSP_MASK) >>\n\t\t\t\tSOF_NO_OF_HDMI_CAPTURE_SSP_SHIFT;\n\n\tdai_links = sof_card_dai_links_create(dev,\n\t\t\t\t\t      SOF_ES8336_SSP_CODEC(quirk),\n\t\t\t\t\t      dmic_be_num, hdmi_num);\n\tif (!dai_links)\n\t\treturn -ENOMEM;\n\n\tsof_es8336_card.dai_link = dai_links;\n\n\t \n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(codec_name, sizeof(codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tdai_links[0].codecs->name = codec_name;\n\n\t\t \n\t\tif (!strncmp(mach->id, \"ESSX8326\", SND_ACPI_I2C_ID_LEN))\n\t\t\tdai_links[0].codecs->dai_name = \"ES8326 HiFi\";\n\t} else {\n\t\tdev_err(dev, \"Error cannot find '%s' dev\\n\", mach->id);\n\t\treturn -ENXIO;\n\t}\n\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\tpriv->codec_dev = get_device(codec_dev);\n\n\tret = snd_soc_fixup_dai_links_platform_name(&sof_es8336_card,\n\t\t\t\t\t\t    mach->mach_params.platform);\n\tif (ret) {\n\t\tput_device(codec_dev);\n\t\treturn ret;\n\t}\n\n\tif (quirk & SOF_ES8336_JD_INVERTED)\n\t\tprops[cnt++] = PROPERTY_ENTRY_BOOL(\"everest,jack-detect-inverted\");\n\n\tif (cnt) {\n\t\tfwnode = fwnode_create_software_node(props, NULL);\n\t\tif (IS_ERR(fwnode)) {\n\t\t\tput_device(codec_dev);\n\t\t\treturn PTR_ERR(fwnode);\n\t\t}\n\n\t\tret = device_add_software_node(codec_dev, to_software_node(fwnode));\n\n\t\tfwnode_handle_put(fwnode);\n\n\t\tif (ret) {\n\t\t\tput_device(codec_dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (quirk & SOF_ES8336_HEADPHONE_GPIO) {\n\t\tif (quirk & SOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK)\n\t\t\tgpio_mapping = acpi_enable_both_gpios;\n\t\telse\n\t\t\tgpio_mapping = acpi_enable_both_gpios_rev_order;\n\t} else if (quirk & SOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK) {\n\t\tgpio_mapping = acpi_speakers_enable_gpio1;\n\t} else {\n\t\tgpio_mapping = acpi_speakers_enable_gpio0;\n\t}\n\n\tret = devm_acpi_dev_add_driver_gpios(codec_dev, gpio_mapping);\n\tif (ret)\n\t\tdev_warn(codec_dev, \"unable to add GPIO mapping table\\n\");\n\n\tpriv->gpio_speakers = gpiod_get_optional(codec_dev, \"speakers-enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpio_speakers)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(priv->gpio_speakers),\n\t\t\t\t    \"could not get speakers-enable GPIO\\n\");\n\t\tgoto err_put_codec;\n\t}\n\n\tpriv->gpio_headphone = gpiod_get_optional(codec_dev, \"headphone-enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpio_headphone)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(priv->gpio_headphone),\n\t\t\t\t    \"could not get headphone-enable GPIO\\n\");\n\t\tgoto err_put_codec;\n\t}\n\n\tINIT_LIST_HEAD(&priv->hdmi_pcm_list);\n\tINIT_DELAYED_WORK(&priv->pcm_pop_work,\n\t\t\t\tpcm_pop_work_events);\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tif (mach->mach_params.dmic_num > 0) {\n\t\tsnprintf(soc_components, sizeof(soc_components),\n\t\t\t \"cfg-dmics:%d\", mach->mach_params.dmic_num);\n\t\tcard->components = soc_components;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret) {\n\t\tgpiod_put(priv->gpio_speakers);\n\t\tdev_err(dev, \"snd_soc_register_card failed: %d\\n\", ret);\n\t\tgoto err_put_codec;\n\t}\n\tplatform_set_drvdata(pdev, &sof_es8336_card);\n\treturn 0;\n\nerr_put_codec:\n\tdevice_remove_software_node(priv->codec_dev);\n\tput_device(codec_dev);\n\treturn ret;\n}\n\nstatic void sof_es8336_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct sof_es8336_private *priv = snd_soc_card_get_drvdata(card);\n\n\tcancel_delayed_work_sync(&priv->pcm_pop_work);\n\tgpiod_put(priv->gpio_speakers);\n\tdevice_remove_software_node(priv->codec_dev);\n\tput_device(priv->codec_dev);\n}\n\nstatic const struct platform_device_id board_ids[] = {\n\t{\n\t\t.name = \"sof-essx8336\",  \n\t},\n\t{\n\t\t.name = \"adl_es83x6_c1_h02\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_ES8336_SSP_CODEC(1) |\n\t\t\t\t\tSOF_NO_OF_HDMI_CAPTURE_SSP(2) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_1_SSP(0) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_2_SSP(2) |\n\t\t\t\t\tSOF_SSP_HDMI_CAPTURE_PRESENT |\n\t\t\t\t\tSOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK |\n\t\t\t\t\tSOF_ES8336_JD_INVERTED),\n\t},\n\t{\n\t\t.name = \"rpl_es83x6_c1_h02\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_ES8336_SSP_CODEC(1) |\n\t\t\t\t\tSOF_NO_OF_HDMI_CAPTURE_SSP(2) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_1_SSP(0) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_2_SSP(2) |\n\t\t\t\t\tSOF_SSP_HDMI_CAPTURE_PRESENT |\n\t\t\t\t\tSOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK |\n\t\t\t\t\tSOF_ES8336_JD_INVERTED),\n\t},\n\t{\n\t\t.name = \"mtl_es83x6_c1_h02\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_ES8336_SSP_CODEC(1) |\n\t\t\t\t\tSOF_NO_OF_HDMI_CAPTURE_SSP(2) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_1_SSP(0) |\n\t\t\t\t\tSOF_HDMI_CAPTURE_2_SSP(2) |\n\t\t\t\t\tSOF_SSP_HDMI_CAPTURE_PRESENT |\n\t\t\t\t\tSOF_ES8336_SPEAKERS_EN_GPIO1_QUIRK |\n\t\t\t\t\tSOF_ES8336_JD_INVERTED),\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, board_ids);\n\nstatic struct platform_driver sof_es8336_driver = {\n\t.driver = {\n\t\t.name = \"sof-essx8336\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = sof_es8336_probe,\n\t.remove_new = sof_es8336_remove,\n\t.id_table = board_ids,\n};\nmodule_platform_driver(sof_es8336_driver);\n\nMODULE_DESCRIPTION(\"ASoC Intel(R) SOF + ES8336 Machine driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_INTEL_HDA_DSP_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}