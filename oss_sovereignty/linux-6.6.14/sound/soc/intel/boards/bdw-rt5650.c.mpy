{
  "module_name": "bdw-rt5650.c",
  "hash_id": "289afec2136a2490f08e0eb9f8454a81c99ecf0749ef907261da3d4b6f1d0b08",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/bdw-rt5650.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n\n#include \"../../codecs/rt5645.h\"\n\nstruct bdw_rt5650_priv {\n\tstruct gpio_desc *gpio_hp_en;\n\tstruct snd_soc_component *component;\n};\n\nstatic const struct snd_soc_dapm_widget bdw_rt5650_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"DMIC Pair1\", NULL),\n\tSND_SOC_DAPM_MIC(\"DMIC Pair2\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route bdw_rt5650_map[] = {\n\t \n\t{\"Speaker\", NULL, \"SPOL\"},\n\t{\"Speaker\", NULL, \"SPOR\"},\n\n\t \n\t{\"Headphone\", NULL, \"HPOL\"},\n\t{\"Headphone\", NULL, \"HPOR\"},\n\t{\"IN1P\", NULL, \"Headset Mic\"},\n\t{\"IN1N\", NULL, \"Headset Mic\"},\n\n\t \n\t{\"DMIC L1\", NULL, \"DMIC Pair1\"},\n\t{\"DMIC R1\", NULL, \"DMIC Pair1\"},\n\t{\"DMIC L2\", NULL, \"DMIC Pair2\"},\n\t{\"DMIC R2\", NULL, \"DMIC Pair2\"},\n\n\t \n\t{\"SSP0 CODEC IN\", NULL, \"AIF1 Capture\"},\n\t{\"AIF1 Playback\", NULL, \"SSP0 CODEC OUT\"},\n};\n\nstatic const struct snd_kcontrol_new bdw_rt5650_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMIC Pair1\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMIC Pair2\"),\n};\n\n\nstatic struct snd_soc_jack headphone_jack;\nstatic struct snd_soc_jack mic_jack;\n\nstatic struct snd_soc_jack_pin headphone_jack_pin = {\n\t.pin\t= \"Headphone\",\n\t.mask\t= SND_JACK_HEADPHONE,\n};\n\nstatic struct snd_soc_jack_pin mic_jack_pin = {\n\t.pin\t= \"Headset Mic\",\n\t.mask\t= SND_JACK_MICROPHONE,\n};\n\nstatic int broadwell_ssp0_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\t\t      SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *chan = hw_param_interval(params,\n\t\t\t\t\t\t      SNDRV_PCM_HW_PARAM_CHANNELS);\n\n\t \n\trate->min = rate->max = 48000;\n\tchan->min = 2;\n\tchan->max = 4;\n\n\t \n\tsnd_mask_set_format(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),\n\t\t\t    SNDRV_PCM_FORMAT_S24_LE);\n\n\treturn 0;\n}\n\nstatic int bdw_rt5650_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\n\t \n\tret = snd_soc_dai_set_pll(codec_dai, 0, RT5645_PLL1_S_MCLK,\n\t\t24000000, 19200000);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set codec pll: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_PLL1, 24576000,\n\t\tSND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set codec sysclk configuration\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic struct snd_soc_ops bdw_rt5650_ops = {\n\t.hw_params = bdw_rt5650_hw_params,\n};\n\nstatic const unsigned int channels[] = {\n\t2, 4,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_channels = {\n\t.count = ARRAY_SIZE(channels),\n\t.list = channels,\n\t.mask = 0,\n};\n\nstatic int bdw_rt5650_fe_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t \n\tif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn 0;\n\n\truntime->hw.channels_max = 4;\n\treturn snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t  &constraints_channels);\n}\n\nstatic const struct snd_soc_ops bdw_rt5650_fe_ops = {\n\t.startup = bdw_rt5650_fe_startup,\n};\n\nstatic int bdw_rt5650_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct bdw_rt5650_priv *bdw_rt5650 =\n\t\tsnd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\t \n\trt5645_sel_asrc_clk_src(component,\n\t\t\t\tRT5645_DA_STEREO_FILTER |\n\t\t\t\tRT5645_DA_MONO_L_FILTER |\n\t\t\t\tRT5645_DA_MONO_R_FILTER |\n\t\t\t\tRT5645_AD_STEREO_FILTER |\n\t\t\t\tRT5645_AD_MONO_L_FILTER |\n\t\t\t\tRT5645_AD_MONO_R_FILTER,\n\t\t\t\tRT5645_CLK_SEL_I2S1_ASRC);\n\n\t \n\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4, 24);\n\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set codec TDM slot %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (snd_soc_card_jack_new_pins(rtd->card, \"Headphone Jack\",\n\t\t\tSND_JACK_HEADPHONE, &headphone_jack,\n\t\t\t&headphone_jack_pin, 1)) {\n\t\tdev_err(component->dev, \"Can't create headphone jack\\n\");\n\t}\n\n\t \n\tif (snd_soc_card_jack_new_pins(rtd->card, \"Mic Jack\",\n\t\t\tSND_JACK_MICROPHONE, &mic_jack, &mic_jack_pin, 1)) {\n\t\tdev_err(component->dev, \"Can't create mic jack\\n\");\n\t}\n\n\trt5645_set_jack_detect(component, &headphone_jack, &mic_jack, NULL);\n\n\tbdw_rt5650->component = component;\n\n\treturn 0;\n}\n\n \nSND_SOC_DAILINK_DEF(dummy,\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nSND_SOC_DAILINK_DEF(fe,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"System Pin\")));\n\nSND_SOC_DAILINK_DEF(platform,\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"haswell-pcm-audio\")));\n\nSND_SOC_DAILINK_DEF(be,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-10EC5650:00\", \"rt5645-aif1\")));\n\nSND_SOC_DAILINK_DEF(ssp0_port,\n\t    DAILINK_COMP_ARRAY(COMP_CPU(\"ssp0-port\")));\n\nstatic struct snd_soc_dai_link bdw_rt5650_dais[] = {\n\t \n\t{\n\t\t.name = \"System PCM\",\n\t\t.stream_name = \"System Playback\",\n\t\t.nonatomic = 1,\n\t\t.dynamic = 1,\n\t\t.ops = &bdw_rt5650_fe_ops,\n\t\t.trigger = {\n\t\t\tSND_SOC_DPCM_TRIGGER_POST,\n\t\t\tSND_SOC_DPCM_TRIGGER_POST\n\t\t},\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\tSND_SOC_DAILINK_REG(fe, dummy, platform),\n\t},\n\n\t \n\t{\n\t\t \n\t\t.name = \"Codec\",\n\t\t.id = 0,\n\t\t.nonatomic = 1,\n\t\t.no_pcm = 1,\n\t\t.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBC_CFC,\n\t\t.ignore_pmdown_time = 1,\n\t\t.be_hw_params_fixup = broadwell_ssp0_fixup,\n\t\t.ops = &bdw_rt5650_ops,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.init = bdw_rt5650_init,\n\t\tSND_SOC_DAILINK_REG(ssp0_port, be, platform),\n\t},\n};\n\n \n#define SOF_CARD_NAME \"bdw rt5650\"  \n#define SOF_DRIVER_NAME \"SOF\"\n\n#define CARD_NAME \"bdw-rt5650\"\n#define DRIVER_NAME NULL  \n\n \nstatic struct snd_soc_card bdw_rt5650_card = {\n\t.name = CARD_NAME,\n\t.driver_name = DRIVER_NAME,\n\t.owner = THIS_MODULE,\n\t.dai_link = bdw_rt5650_dais,\n\t.num_links = ARRAY_SIZE(bdw_rt5650_dais),\n\t.dapm_widgets = bdw_rt5650_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(bdw_rt5650_widgets),\n\t.dapm_routes = bdw_rt5650_map,\n\t.num_dapm_routes = ARRAY_SIZE(bdw_rt5650_map),\n\t.controls = bdw_rt5650_controls,\n\t.num_controls = ARRAY_SIZE(bdw_rt5650_controls),\n\t.fully_routed = true,\n};\n\nstatic int bdw_rt5650_probe(struct platform_device *pdev)\n{\n\tstruct bdw_rt5650_priv *bdw_rt5650;\n\tstruct snd_soc_acpi_mach *mach;\n\tint ret;\n\n\tbdw_rt5650_card.dev = &pdev->dev;\n\n\t \n\tbdw_rt5650 = devm_kzalloc(&pdev->dev, sizeof(struct bdw_rt5650_priv),\n\t\tGFP_KERNEL);\n\tif (!bdw_rt5650)\n\t\treturn -ENOMEM;\n\n\t \n\tmach = pdev->dev.platform_data;\n\tret = snd_soc_fixup_dai_links_platform_name(&bdw_rt5650_card,\n\t\t\t\t\t\t    mach->mach_params.platform);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (snd_soc_acpi_sof_parent(&pdev->dev)) {\n\t\tbdw_rt5650_card.name = SOF_CARD_NAME;\n\t\tbdw_rt5650_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbdw_rt5650_card.name = CARD_NAME;\n\t\tbdw_rt5650_card.driver_name = DRIVER_NAME;\n\t}\n\n\tsnd_soc_card_set_drvdata(&bdw_rt5650_card, bdw_rt5650);\n\n\treturn devm_snd_soc_register_card(&pdev->dev, &bdw_rt5650_card);\n}\n\nstatic struct platform_driver bdw_rt5650_audio = {\n\t.probe = bdw_rt5650_probe,\n\t.driver = {\n\t\t.name = \"bdw-rt5650\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(bdw_rt5650_audio)\n\n \nMODULE_AUTHOR(\"Ben Zhang <benzh@chromium.org>\");\nMODULE_DESCRIPTION(\"Intel Broadwell RT5650 machine driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:bdw-rt5650\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}