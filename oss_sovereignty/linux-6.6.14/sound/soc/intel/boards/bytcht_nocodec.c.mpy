{
  "module_name": "bytcht_nocodec.c",
  "hash_id": "69821beab7b297797af2a53de7df119004c2184f30611ece224ea53cb3b4a5cf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/bytcht_nocodec.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"../atom/sst-atom-controls.h\"\n\nstatic const struct snd_soc_dapm_widget widgets[] = {\n\tSND_SOC_DAPM_MIC(\"Mic\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n};\n\nstatic const struct snd_kcontrol_new controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\"),\n};\n\nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t{\"ssp2 Tx\", NULL, \"codec_out0\"},\n\t{\"ssp2 Tx\", NULL, \"codec_out1\"},\n\t{\"codec_in0\", NULL, \"ssp2 Rx\"},\n\t{\"codec_in1\", NULL, \"ssp2 Rx\"},\n\n\t{\"ssp2 Rx\", NULL, \"Mic\"},\n\t{\"Speaker\", NULL, \"ssp2 Tx\"},\n};\n\nstatic int codec_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tint ret;\n\n\t \n\trate->min = rate->max = 48000;\n\tchannels->min = channels->max = 2;\n\n\t \n\tparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_cpu(rtd, 0),\n\t\t\t\t  SND_SOC_DAIFMT_I2S     |\n\t\t\t\t  SND_SOC_DAIFMT_NB_NF   |\n\t\t\t\t  SND_SOC_DAIFMT_BP_FP);\n\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set format to I2S, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0x3, 0x3, 2, 24);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set I2S config, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const unsigned int rates_48000[] = {\n\t48000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_48000 = {\n\t.count = ARRAY_SIZE(rates_48000),\n\t.list  = rates_48000,\n};\n\nstatic int aif1_startup(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t&constraints_48000);\n}\n\nstatic const struct snd_soc_ops aif1_ops = {\n\t.startup = aif1_startup,\n};\n\nSND_SOC_DAILINK_DEF(dummy,\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nSND_SOC_DAILINK_DEF(media,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"media-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(deepbuffer,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"deepbuffer-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(ssp2_port,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"ssp2-port\")));\n\nSND_SOC_DAILINK_DEF(platform,\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"sst-mfld-platform\")));\n\nstatic struct snd_soc_dai_link dais[] = {\n\t[MERR_DPCM_AUDIO] = {\n\t\t.name = \"Audio Port\",\n\t\t.stream_name = \"Audio\",\n\t\t.ignore_suspend = 1,\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.ops = &aif1_ops,\n\t\tSND_SOC_DAILINK_REG(media, dummy, platform),\n\t},\n\t[MERR_DPCM_DEEP_BUFFER] = {\n\t\t.name = \"Deep-Buffer Audio Port\",\n\t\t.stream_name = \"Deep-Buffer Audio\",\n\t\t.ignore_suspend = 1,\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.ops = &aif1_ops,\n\t\tSND_SOC_DAILINK_REG(deepbuffer, dummy, platform),\n\t},\n\t \n\t \n\t{\n\t\t.name = \"SSP2-LowSpeed Connector\",\n\t\t.id = 0,\n\t\t.no_pcm = 1,\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF\n\t\t\t\t\t\t| SND_SOC_DAIFMT_CBC_CFC,\n\t\t.be_hw_params_fixup = codec_fixup,\n\t\t.ignore_suspend = 1,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\tSND_SOC_DAILINK_REG(ssp2_port, dummy, platform),\n\t},\n};\n\n \nstatic struct snd_soc_card bytcht_nocodec_card = {\n\t.name = \"bytcht-nocodec\",\n\t.owner = THIS_MODULE,\n\t.dai_link = dais,\n\t.num_links = ARRAY_SIZE(dais),\n\t.dapm_widgets = widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(widgets),\n\t.dapm_routes = audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(audio_map),\n\t.controls = controls,\n\t.num_controls = ARRAY_SIZE(controls),\n\t.fully_routed = true,\n};\n\nstatic int snd_bytcht_nocodec_mc_probe(struct platform_device *pdev)\n{\n\tint ret_val = 0;\n\n\t \n\tbytcht_nocodec_card.dev = &pdev->dev;\n\n\tret_val = devm_snd_soc_register_card(&pdev->dev, &bytcht_nocodec_card);\n\n\tif (ret_val) {\n\t\tdev_err(&pdev->dev, \"devm_snd_soc_register_card failed %d\\n\",\n\t\t\tret_val);\n\t\treturn ret_val;\n\t}\n\tplatform_set_drvdata(pdev, &bytcht_nocodec_card);\n\treturn ret_val;\n}\n\nstatic struct platform_driver snd_bytcht_nocodec_mc_driver = {\n\t.driver = {\n\t\t.name = \"bytcht_nocodec\",\n\t},\n\t.probe = snd_bytcht_nocodec_mc_probe,\n};\nmodule_platform_driver(snd_bytcht_nocodec_mc_driver);\n\nMODULE_DESCRIPTION(\"ASoC Intel(R) Baytrail/Cherrytrail Nocodec Machine driver\");\nMODULE_AUTHOR(\"Pierre-Louis Bossart <pierre-louis.bossart at linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:bytcht_nocodec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}