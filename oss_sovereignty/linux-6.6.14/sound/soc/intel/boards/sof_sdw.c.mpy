{
  "module_name": "sof_sdw.c",
  "hash_id": "f0d2dbc92b4aaa73837ef28b046e0a64b6daffcd6b65d0a69ca04fa145a2cd55",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/sof_sdw.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"sof_sdw_common.h\"\n#include \"../../codecs/rt711.h\"\n\nunsigned long sof_sdw_quirk = RT711_JD1;\nstatic int quirk_override = -1;\nmodule_param_named(quirk, quirk_override, int, 0444);\nMODULE_PARM_DESC(quirk, \"Board-specific quirk override\");\n\n#define INC_ID(BE, CPU, LINK)\tdo { (BE)++; (CPU)++; (LINK)++; } while (0)\n\n#define SDW_MAX_LINKS\t\t4\n\n \nstatic unsigned int sdw_pin_index[SDW_MAX_LINKS];\n\nstatic void log_quirks(struct device *dev)\n{\n\tif (SOF_JACK_JDSRC(sof_sdw_quirk))\n\t\tdev_dbg(dev, \"quirk realtek,jack-detect-source %ld\\n\",\n\t\t\tSOF_JACK_JDSRC(sof_sdw_quirk));\n\tif (sof_sdw_quirk & SOF_SDW_FOUR_SPK)\n\t\tdev_dbg(dev, \"quirk SOF_SDW_FOUR_SPK enabled\\n\");\n\tif (sof_sdw_quirk & SOF_SDW_TGL_HDMI)\n\t\tdev_dbg(dev, \"quirk SOF_SDW_TGL_HDMI enabled\\n\");\n\tif (sof_sdw_quirk & SOF_SDW_PCH_DMIC)\n\t\tdev_dbg(dev, \"quirk SOF_SDW_PCH_DMIC enabled\\n\");\n\tif (SOF_SSP_GET_PORT(sof_sdw_quirk))\n\t\tdev_dbg(dev, \"SSP port %ld\\n\",\n\t\t\tSOF_SSP_GET_PORT(sof_sdw_quirk));\n\tif (sof_sdw_quirk & SOF_SDW_NO_AGGREGATION)\n\t\tdev_dbg(dev, \"quirk SOF_SDW_NO_AGGREGATION enabled\\n\");\n}\n\nstatic int sof_sdw_quirk_cb(const struct dmi_system_id *id)\n{\n\tsof_sdw_quirk = (unsigned long)id->driver_data;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id sof_sdw_quirk_table[] = {\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CometLake Client\"),\n\t\t},\n\t\t.driver_data = (void *)SOF_SDW_PCH_DMIC,\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"09C6\")\n\t\t},\n\t\t.driver_data = (void *)RT711_JD2,\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0983\")\n\t\t},\n\t\t.driver_data = (void *)RT711_JD2,\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"098F\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0990\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Ice Lake Client\"),\n\t\t},\n\t\t.driver_data = (void *)SOF_SDW_PCH_DMIC,\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME,\n\t\t\t\t  \"Tiger Lake Client Platform\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD1 |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tSOF_SSP_PORT(SOF_I2S_SSP2)),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A3E\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A3F\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A5D\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A5E\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Volteer\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tSOF_SDW_FOUR_SPK |\n\t\t\t\t\tSOF_BT_OFFLOAD_SSP(2) |\n\t\t\t\t\tSOF_SSP_BT_OFFLOAD_PRESENT),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Ripto\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Spectre x360 Conv\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tRT711_JD1),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"8709\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tRT711_JD1),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel(R) Client Systems\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LAPBC\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tRT711_JD1),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"LAPBC710\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tRT711_JD1),\n\t},\n\t{\n\t\t \n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel(R) Client Systems\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LAPRC\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tRT711_JD2_100K),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A32\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A45\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Alder Lake Client Platform\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD2_100K |\n\t\t\t\t\tSOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_BT_OFFLOAD_SSP(2) |\n\t\t\t\t\tSOF_SSP_BT_OFFLOAD_PRESENT),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Brya\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_PCH_DMIC |\n\t\t\t\t\tSOF_SDW_FOUR_SPK |\n\t\t\t\t\tSOF_BT_OFFLOAD_SSP(2) |\n\t\t\t\t\tSOF_SSP_BT_OFFLOAD_PRESENT),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AF0\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AF3\"),\n\t\t},\n\t\t \n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AFE\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AFF\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B00\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B01\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B11\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B12\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B13\"),\n\t\t},\n\t\t \n\t\t.driver_data = (void *)SOF_SDW_TGL_HDMI,\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B14\"),\n\t\t},\n\t\t \n\t\t.driver_data = (void *)SOF_SDW_TGL_HDMI,\n\t},\n\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B29\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B34\"),\n\t\t},\n\t\t \n\t\t.driver_data = (void *)SOF_SDW_TGL_HDMI,\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OMEN by HP Gaming Laptop 16-k0xxx\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0BDA\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0C10\"),\n\t\t},\n\t\t \n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0C11\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0C40\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0C4F\")\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_TGL_HDMI |\n\t\t\t\t\tRT711_JD2 |\n\t\t\t\t\tSOF_SDW_FOUR_SPK),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Intel_mtlrvp\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD1),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Meteor Lake Client Platform\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD2_100K),\n\t},\n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Rex\"),\n\t\t},\n\t\t.driver_data = (void *)(SOF_SDW_PCH_DMIC |\n\t\t\t\t\tSOF_BT_OFFLOAD_SSP(1) |\n\t\t\t\t\tSOF_SSP_BT_OFFLOAD_PRESENT),\n\t},\n\t \n\t{\n\t\t.callback = sof_sdw_quirk_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Lunar Lake Client Platform\"),\n\t\t},\n\t\t.driver_data = (void *)(RT711_JD2),\n\t},\n\t{}\n};\n\nstatic struct snd_soc_dai_link_component dmic_component[] = {\n\t{\n\t\t.name = \"dmic-codec\",\n\t\t.dai_name = \"dmic-hifi\",\n\t}\n};\n\nstatic struct snd_soc_dai_link_component platform_component[] = {\n\t{\n\t\t \n\t\t.name = \"0000:00:1f.3\"\n\t}\n};\n\n \nint sdw_startup(struct snd_pcm_substream *substream)\n{\n\treturn sdw_startup_stream(substream);\n}\n\nint sdw_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sdw_stream_runtime *sdw_stream;\n\tstruct snd_soc_dai *dai;\n\n\t \n\tdai = asoc_rtd_to_cpu(rtd, 0);\n\n\tsdw_stream = snd_soc_dai_get_stream(dai, substream->stream);\n\tif (IS_ERR(sdw_stream)) {\n\t\tdev_err(rtd->dev, \"no stream found for DAI %s\\n\", dai->name);\n\t\treturn PTR_ERR(sdw_stream);\n\t}\n\n\treturn sdw_prepare_stream(sdw_stream);\n}\n\nint sdw_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sdw_stream_runtime *sdw_stream;\n\tstruct snd_soc_dai *dai;\n\tint ret;\n\n\t \n\tdai = asoc_rtd_to_cpu(rtd, 0);\n\n\tsdw_stream = snd_soc_dai_get_stream(dai, substream->stream);\n\tif (IS_ERR(sdw_stream)) {\n\t\tdev_err(rtd->dev, \"no stream found for DAI %s\\n\", dai->name);\n\t\treturn PTR_ERR(sdw_stream);\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tret = sdw_enable_stream(sdw_stream);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = sdw_disable_stream(sdw_stream);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(rtd->dev, \"%s trigger %d failed: %d\\n\", __func__, cmd, ret);\n\n\treturn ret;\n}\n\nint sdw_hw_params(struct snd_pcm_substream *substream,\n\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ch = params_channels(params);\n\tstruct snd_soc_dai *codec_dai;\n\tstruct snd_soc_dai *cpu_dai;\n\tunsigned int ch_mask;\n\tint num_codecs;\n\tint step;\n\tint i;\n\tint j;\n\n\tif (!rtd->dai_link->codec_ch_maps)\n\t\treturn 0;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tch_mask = GENMASK(ch - 1, 0);\n\t\tstep = 0;\n\t} else {\n\t\tnum_codecs = rtd->dai_link->num_codecs;\n\n\t\tif (ch < num_codecs || ch % num_codecs != 0) {\n\t\t\tdev_err(rtd->dev, \"Channels number %d is invalid when codec number = %d\\n\",\n\t\t\t\tch, num_codecs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tch_mask = GENMASK(ch / num_codecs - 1, 0);\n\t\tstep = hweight_long(ch_mask);\n\n\t}\n\n\t \n\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\tfor_each_rtd_codec_dais(rtd, j, codec_dai) {\n\t\t\tif (rtd->dai_link->codec_ch_maps[j].connected_cpu_id != i)\n\t\t\t\tcontinue;\n\t\t\trtd->dai_link->codec_ch_maps[j].ch_mask = ch_mask << (j * step);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint sdw_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sdw_stream_runtime *sdw_stream;\n\tstruct snd_soc_dai *dai;\n\n\t \n\tdai = asoc_rtd_to_cpu(rtd, 0);\n\n\tsdw_stream = snd_soc_dai_get_stream(dai, substream->stream);\n\tif (IS_ERR(sdw_stream)) {\n\t\tdev_err(rtd->dev, \"no stream found for DAI %s\\n\", dai->name);\n\t\treturn PTR_ERR(sdw_stream);\n\t}\n\n\treturn sdw_deprepare_stream(sdw_stream);\n}\n\nvoid sdw_shutdown(struct snd_pcm_substream *substream)\n{\n\tsdw_shutdown_stream(substream);\n}\n\nstatic const struct snd_soc_ops sdw_ops = {\n\t.startup = sdw_startup,\n\t.prepare = sdw_prepare,\n\t.trigger = sdw_trigger,\n\t.hw_params = sdw_hw_params,\n\t.hw_free = sdw_hw_free,\n\t.shutdown = sdw_shutdown,\n};\n\nstatic struct sof_sdw_codec_info codec_info_list[] = {\n\t{\n\t\t.part_id = 0x700,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt700-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt700_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x711,\n\t\t.version_id = 3,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt711-sdca-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_sdca_jack_init,\n\t\t\t\t.exit = sof_sdw_rt_sdca_jack_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x711,\n\t\t.version_id = 2,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt711-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt711_init,\n\t\t\t\t.exit = sof_sdw_rt711_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x712,\n\t\t.version_id = 3,\n\t\t.dais =\t{\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt712-sdca-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_sdca_jack_init,\n\t\t\t\t.exit = sof_sdw_rt_sdca_jack_exit,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.direction = {true, false},\n\t\t\t\t.dai_name = \"rt712-sdca-aif2\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_UNUSED_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt712_spk_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 2,\n\t},\n\t{\n\t\t.part_id = 0x1712,\n\t\t.version_id = 3,\n\t\t.dais =\t{\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt712-sdca-dmic-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt712_sdca_dmic_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x713,\n\t\t.version_id = 3,\n\t\t.dais =\t{\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt712-sdca-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_sdca_jack_init,\n\t\t\t\t.exit = sof_sdw_rt_sdca_jack_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x1713,\n\t\t.version_id = 3,\n\t\t.dais =\t{\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt712-sdca-dmic-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt712_sdca_dmic_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x1308,\n\t\t.acpi_id = \"10EC1308\",\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, false},\n\t\t\t\t.dai_name = \"rt1308-aif\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_UNUSED_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_amp_init,\n\t\t\t\t.exit = sof_sdw_rt_amp_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t\t.ops = &sof_sdw_rt1308_i2s_ops,\n\t},\n\t{\n\t\t.part_id = 0x1316,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt1316-aif\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_AMP_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_amp_init,\n\t\t\t\t.exit = sof_sdw_rt_amp_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x1318,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt1318-aif\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_AMP_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt_amp_init,\n\t\t\t\t.exit = sof_sdw_rt_amp_exit,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x714,\n\t\t.version_id = 3,\n\t\t.ignore_pch_dmic = true,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt715-aif2\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt715_sdca_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x715,\n\t\t.version_id = 3,\n\t\t.ignore_pch_dmic = true,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt715-aif2\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt715_sdca_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x714,\n\t\t.version_id = 2,\n\t\t.ignore_pch_dmic = true,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt715-aif2\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt715_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x715,\n\t\t.version_id = 2,\n\t\t.ignore_pch_dmic = true,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_name = \"rt715-aif2\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt715_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x8373,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"max98373-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_AMP_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_maxim_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x8363,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, false},\n\t\t\t\t.dai_name = \"max98363-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_UNUSED_DAI_ID},\n\t\t\t\t.init = sof_sdw_maxim_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x5682,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"rt5682-sdw\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_rt5682_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x3556,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"cs35l56-sdw1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_AMP_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_cs_amp_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x4242,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"cs42l42-sdw\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = sof_sdw_cs42l42_init,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0xaaaa,  \n\t\t.version_id = 0,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"sdw-mockup-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = NULL,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0xaa55,  \n\t\t.version_id = 0,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"sdw-mockup-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_JACK,\n\t\t\t\t.dailink = {SDW_JACK_OUT_DAI_ID, SDW_JACK_IN_DAI_ID},\n\t\t\t\t.init = NULL,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x55aa,  \n\t\t.version_id = 0,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.direction = {true, true},\n\t\t\t\t.dai_name = \"sdw-mockup-aif1\",\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_AMP,\n\t\t\t\t.dailink = {SDW_AMP_OUT_DAI_ID, SDW_AMP_IN_DAI_ID},\n\t\t\t\t.init = NULL,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n\t{\n\t\t.part_id = 0x5555,\n\t\t.version_id = 0,\n\t\t.dais = {\n\t\t\t{\n\t\t\t\t.dai_name = \"sdw-mockup-aif1\",\n\t\t\t\t.direction = {false, true},\n\t\t\t\t.dai_type = SOF_SDW_DAI_TYPE_MIC,\n\t\t\t\t.dailink = {SDW_UNUSED_DAI_ID, SDW_DMIC_DAI_ID},\n\t\t\t\t.init = NULL,\n\t\t\t},\n\t\t},\n\t\t.dai_num = 1,\n\t},\n};\n\nstatic inline int find_codec_info_part(const u64 adr)\n{\n\tunsigned int part_id, sdw_version;\n\tint i;\n\n\tpart_id = SDW_PART_ID(adr);\n\tsdw_version = SDW_VERSION(adr);\n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++)\n\t\t \n\t\tif (part_id == codec_info_list[i].part_id &&\n\t\t    (!codec_info_list[i].version_id ||\n\t\t     sdw_version == codec_info_list[i].version_id))\n\t\t\treturn i;\n\n\treturn -EINVAL;\n\n}\n\nstatic inline int find_codec_info_acpi(const u8 *acpi_id)\n{\n\tint i;\n\n\tif (!acpi_id[0])\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++)\n\t\tif (!memcmp(codec_info_list[i].acpi_id, acpi_id, ACPI_ID_LEN))\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n \nstatic int get_dailink_info(struct device *dev,\n\t\t\t    const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t    int *sdw_be_num, int *sdw_cpu_dai_num, int *codecs_num)\n{\n\tbool group_visited[SDW_MAX_GROUPS];\n\tbool no_aggregation;\n\tint i;\n\tint j;\n\n\tno_aggregation = sof_sdw_quirk & SOF_SDW_NO_AGGREGATION;\n\t*sdw_cpu_dai_num = 0;\n\t*sdw_be_num  = 0;\n\n\tif (!adr_link)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < SDW_MAX_GROUPS; i++)\n\t\tgroup_visited[i] = false;\n\n\tfor (; adr_link->num_adr; adr_link++) {\n\t\tconst struct snd_soc_acpi_endpoint *endpoint;\n\t\tstruct sof_sdw_codec_info *codec_info;\n\t\tint codec_index;\n\t\tint stream;\n\t\tu64 adr;\n\n\t\t \n\t\tif (!is_power_of_2(adr_link->mask))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < adr_link->num_adr; i++) {\n\t\t\tadr = adr_link->adr_d[i].adr;\n\t\t\tcodec_index = find_codec_info_part(adr);\n\t\t\tif (codec_index < 0)\n\t\t\t\treturn codec_index;\n\n\t\t\tcodec_info = &codec_info_list[codec_index];\n\n\t\t\t*codecs_num += codec_info->dai_num;\n\n\t\t\tif (!adr_link->adr_d[i].name_prefix) {\n\t\t\t\tdev_err(dev, \"codec 0x%llx does not have a name prefix\\n\",\n\t\t\t\t\tadr_link->adr_d[i].adr);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tendpoint = adr_link->adr_d[i].endpoints;\n\t\t\tif (endpoint->aggregated && !endpoint->group_id) {\n\t\t\t\tdev_err(dev, \"invalid group id on link %x\\n\",\n\t\t\t\t\tadr_link->mask);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < codec_info->dai_num; j++) {\n\t\t\t\t \n\t\t\t\tfor_each_pcm_streams(stream) {\n\t\t\t\t\tif (!codec_info->dais[j].direction[stream])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t(*sdw_cpu_dai_num)++;\n\n\t\t\t\t\t \n\t\t\t\t\tif (!endpoint->aggregated || no_aggregation ||\n\t\t\t\t\t    !group_visited[endpoint->group_id])\n\t\t\t\t\t\t(*sdw_be_num)++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endpoint->aggregated)\n\t\t\t\tgroup_visited[endpoint->group_id] = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void init_dai_link(struct device *dev, struct snd_soc_dai_link *dai_links,\n\t\t\t  int be_id, char *name, int playback, int capture,\n\t\t\t  struct snd_soc_dai_link_component *cpus, int cpus_num,\n\t\t\t  struct snd_soc_dai_link_component *codecs, int codecs_num,\n\t\t\t  int (*init)(struct snd_soc_pcm_runtime *rtd),\n\t\t\t  const struct snd_soc_ops *ops)\n{\n\tdev_dbg(dev, \"create dai link %s, id %d\\n\", name, be_id);\n\tdai_links->id = be_id;\n\tdai_links->name = name;\n\tdai_links->platforms = platform_component;\n\tdai_links->num_platforms = ARRAY_SIZE(platform_component);\n\tdai_links->no_pcm = 1;\n\tdai_links->cpus = cpus;\n\tdai_links->num_cpus = cpus_num;\n\tdai_links->codecs = codecs;\n\tdai_links->num_codecs = codecs_num;\n\tdai_links->dpcm_playback = playback;\n\tdai_links->dpcm_capture = capture;\n\tdai_links->init = init;\n\tdai_links->ops = ops;\n}\n\nstatic bool is_unique_device(const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t     unsigned int sdw_version,\n\t\t\t     unsigned int mfg_id,\n\t\t\t     unsigned int part_id,\n\t\t\t     unsigned int class_id,\n\t\t\t     int index_in_link)\n{\n\tint i;\n\n\tfor (i = 0; i < adr_link->num_adr; i++) {\n\t\tunsigned int sdw1_version, mfg1_id, part1_id, class1_id;\n\t\tu64 adr;\n\n\t\t \n\t\tif (i == index_in_link)\n\t\t\tcontinue;\n\n\t\tadr = adr_link->adr_d[i].adr;\n\n\t\tsdw1_version = SDW_VERSION(adr);\n\t\tmfg1_id = SDW_MFG_ID(adr);\n\t\tpart1_id = SDW_PART_ID(adr);\n\t\tclass1_id = SDW_CLASS_ID(adr);\n\n\t\tif (sdw_version == sdw1_version &&\n\t\t    mfg_id == mfg1_id &&\n\t\t    part_id == part1_id &&\n\t\t    class_id == class1_id)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int fill_sdw_codec_dlc(struct device *dev,\n\t\t\t      const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t      struct snd_soc_dai_link_component *codec,\n\t\t\t      int adr_index, int dai_index)\n{\n\tunsigned int sdw_version, unique_id, mfg_id, link_id, part_id, class_id;\n\tu64 adr = adr_link->adr_d[adr_index].adr;\n\tint codec_index;\n\n\tcodec_index = find_codec_info_part(adr);\n\tif (codec_index < 0)\n\t\treturn codec_index;\n\n\tsdw_version = SDW_VERSION(adr);\n\tlink_id = SDW_DISCO_LINK_ID(adr);\n\tunique_id = SDW_UNIQUE_ID(adr);\n\tmfg_id = SDW_MFG_ID(adr);\n\tpart_id = SDW_PART_ID(adr);\n\tclass_id = SDW_CLASS_ID(adr);\n\n\tif (codec_info_list[codec_index].codec_name)\n\t\tcodec->name = devm_kstrdup(dev,\n\t\t\t\t\t   codec_info_list[codec_index].codec_name,\n\t\t\t\t\t   GFP_KERNEL);\n\telse if (is_unique_device(adr_link, sdw_version, mfg_id, part_id,\n\t\t\t\t  class_id, adr_index))\n\t\tcodec->name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t     \"sdw:%01x:%04x:%04x:%02x\", link_id,\n\t\t\t\t\t     mfg_id, part_id, class_id);\n\telse\n\t\tcodec->name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t     \"sdw:%01x:%04x:%04x:%02x:%01x\", link_id,\n\t\t\t\t\t     mfg_id, part_id, class_id, unique_id);\n\n\tif (!codec->name)\n\t\treturn -ENOMEM;\n\n\tcodec->dai_name = codec_info_list[codec_index].dais[dai_index].dai_name;\n\n\treturn 0;\n}\n\nstatic int set_codec_init_func(struct snd_soc_card *card,\n\t\t\t       const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t       struct snd_soc_dai_link *dai_links,\n\t\t\t       bool playback, int group_id, int adr_index, int dai_index)\n{\n\tint i = adr_index;\n\n\tdo {\n\t\t \n\t\tfor ( ; i < adr_link->num_adr; i++) {\n\t\t\tint codec_index;\n\n\t\t\tcodec_index = find_codec_info_part(adr_link->adr_d[i].adr);\n\t\t\tif (codec_index < 0)\n\t\t\t\treturn codec_index;\n\n\t\t\t \n\t\t\tif (adr_link->adr_d[i].endpoints->group_id != group_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (codec_info_list[codec_index].dais[dai_index].init)\n\t\t\t\tcodec_info_list[codec_index].dais[dai_index].init(card,\n\t\t\t\t\t\tadr_link,\n\t\t\t\t\t\tdai_links,\n\t\t\t\t\t\t&codec_info_list[codec_index],\n\t\t\t\t\t\tplayback);\n\t\t\tif (!group_id)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\ti = 0;\n\t\tadr_link++;\n\t} while (adr_link->mask);\n\n\treturn 0;\n}\n\n \nstatic int get_slave_info(const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t  struct device *dev, int *cpu_dai_id, int *cpu_dai_num,\n\t\t\t  int *codec_num, unsigned int *group_id,\n\t\t\t  int adr_index)\n{\n\tbool no_aggregation = sof_sdw_quirk & SOF_SDW_NO_AGGREGATION;\n\tint i;\n\n\tif (!adr_link->adr_d[adr_index].endpoints->aggregated || no_aggregation) {\n\t\tcpu_dai_id[0] = ffs(adr_link->mask) - 1;\n\t\t*cpu_dai_num = 1;\n\t\t*codec_num = 1;\n\t\t*group_id = 0;\n\t\treturn 0;\n\t}\n\n\t*codec_num = 0;\n\t*cpu_dai_num = 0;\n\t*group_id = adr_link->adr_d[adr_index].endpoints->group_id;\n\n\t \n\tfor (; adr_link && adr_link->num_adr; adr_link++) {\n\t\tunsigned int link_codecs = 0;\n\n\t\tfor (i = 0; i < adr_link->num_adr; i++) {\n\t\t\tif (adr_link->adr_d[i].endpoints->aggregated &&\n\t\t\t    adr_link->adr_d[i].endpoints->group_id == *group_id)\n\t\t\t\tlink_codecs++;\n\t\t}\n\n\t\tif (link_codecs) {\n\t\t\t*codec_num += link_codecs;\n\n\t\t\tif (*cpu_dai_num >= SDW_MAX_CPU_DAIS) {\n\t\t\t\tdev_err(dev, \"cpu_dai_id array overflowed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcpu_dai_id[(*cpu_dai_num)++] = ffs(adr_link->mask) - 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void set_dailink_map(struct snd_soc_dai_link_codec_ch_map *sdw_codec_ch_maps,\n\t\t\t    int codec_num, int cpu_num)\n{\n\tint step;\n\tint i;\n\n\tstep = codec_num / cpu_num;\n\tfor (i = 0; i < codec_num; i++)\n\t\tsdw_codec_ch_maps[i].connected_cpu_id = i / step;\n}\n\nstatic const char * const type_strings[] = {\"SimpleJack\", \"SmartAmp\", \"SmartMic\"};\n\nstatic int create_sdw_dailink(struct snd_soc_card *card, int *link_index,\n\t\t\t      struct snd_soc_dai_link *dai_links,\n\t\t\t      int sdw_be_num, int sdw_cpu_dai_num,\n\t\t\t      struct snd_soc_dai_link_component *cpus,\n\t\t\t      const struct snd_soc_acpi_link_adr *adr_link,\n\t\t\t      int *cpu_id, struct snd_soc_codec_conf *codec_conf,\n\t\t\t      int codec_count, int *be_id,\n\t\t\t      int *codec_conf_index,\n\t\t\t      bool *ignore_pch_dmic,\n\t\t\t      bool append_dai_type,\n\t\t\t      int adr_index,\n\t\t\t      int dai_index)\n{\n\tstruct device *dev = card->dev;\n\tconst struct snd_soc_acpi_link_adr *adr_link_next;\n\tstruct snd_soc_dai_link_component *codecs;\n\tstruct sof_sdw_codec_info *codec_info;\n\tint cpu_dai_id[SDW_MAX_CPU_DAIS];\n\tint cpu_dai_num, cpu_dai_index;\n\tunsigned int group_id;\n\tint codec_dlc_index = 0;\n\tint codec_index;\n\tint codec_num;\n\tint stream;\n\tint i = 0;\n\tint j, k;\n\tint ret;\n\n\tret = get_slave_info(adr_link, dev, cpu_dai_id, &cpu_dai_num, &codec_num,\n\t\t\t     &group_id, adr_index);\n\tif (ret)\n\t\treturn ret;\n\n\tcodecs = devm_kcalloc(dev, codec_num, sizeof(*codecs), GFP_KERNEL);\n\tif (!codecs)\n\t\treturn -ENOMEM;\n\n\t \n\tj = adr_index;\n\tfor (adr_link_next = adr_link; adr_link_next && adr_link_next->num_adr &&\n\t     i < cpu_dai_num; adr_link_next++) {\n\t\t \n\t\tif (cpu_dai_id[i] != ffs(adr_link_next->mask) - 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (; j < adr_link_next->num_adr && codec_dlc_index < codec_num; j++) {\n\t\t\tconst struct snd_soc_acpi_endpoint *endpoints;\n\n\t\t\tendpoints = adr_link_next->adr_d[j].endpoints;\n\n\t\t\tif (group_id && (!endpoints->aggregated ||\n\t\t\t\t\t endpoints->group_id != group_id))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (*codec_conf_index >= codec_count) {\n\t\t\t\tdev_err(dev, \"codec_conf array overflowed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = fill_sdw_codec_dlc(dev, adr_link_next,\n\t\t\t\t\t\t &codecs[codec_dlc_index],\n\t\t\t\t\t\t j, dai_index);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcodec_conf[*codec_conf_index].dlc = codecs[codec_dlc_index];\n\t\t\tcodec_conf[*codec_conf_index].name_prefix =\n\t\t\t\t\tadr_link_next->adr_d[j].name_prefix;\n\n\t\t\tcodec_dlc_index++;\n\t\t\t(*codec_conf_index)++;\n\t\t}\n\t\tj = 0;\n\n\t\t \n\t\ti++;\n\t}\n\n\t \n\tcodec_index = find_codec_info_part(adr_link->adr_d[adr_index].adr);\n\tif (codec_index < 0)\n\t\treturn codec_index;\n\tcodec_info = &codec_info_list[codec_index];\n\n\tif (codec_info->ignore_pch_dmic)\n\t\t*ignore_pch_dmic = true;\n\n\tcpu_dai_index = *cpu_id;\n\tfor_each_pcm_streams(stream) {\n\t\tstruct snd_soc_dai_link_codec_ch_map *sdw_codec_ch_maps;\n\t\tchar *name, *cpu_name;\n\t\tint playback, capture;\n\t\tstatic const char * const sdw_stream_name[] = {\n\t\t\t\"SDW%d-Playback\",\n\t\t\t\"SDW%d-Capture\",\n\t\t\t\"SDW%d-Playback-%s\",\n\t\t\t\"SDW%d-Capture-%s\",\n\t\t};\n\n\t\tif (!codec_info->dais[dai_index].direction[stream])\n\t\t\tcontinue;\n\n\t\t*be_id = codec_info->dais[dai_index].dailink[stream];\n\t\tif (*be_id < 0) {\n\t\t\tdev_err(dev, \"Invalid dailink id %d\\n\", *be_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsdw_codec_ch_maps = devm_kcalloc(dev, codec_num,\n\t\t\t\t\t\t sizeof(*sdw_codec_ch_maps), GFP_KERNEL);\n\t\tif (!sdw_codec_ch_maps)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (append_dai_type) {\n\t\t\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t      sdw_stream_name[stream + 2], cpu_dai_id[0],\n\t\t\t\t\t      type_strings[codec_info->dais[dai_index].dai_type]);\n\t\t} else {\n\t\t\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t      sdw_stream_name[stream], cpu_dai_id[0]);\n\t\t}\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (k = 0; k < cpu_dai_num; k++) {\n\t\t\tcpu_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t  \"SDW%d Pin%d\", cpu_dai_id[k],\n\t\t\t\t\t\t  sdw_pin_index[cpu_dai_id[k]]++);\n\t\t\tif (!cpu_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (cpu_dai_index >= sdw_cpu_dai_num) {\n\t\t\t\tdev_err(dev, \"invalid cpu dai index %d\\n\",\n\t\t\t\t\tcpu_dai_index);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcpus[cpu_dai_index++].dai_name = cpu_name;\n\t\t}\n\n\t\t \n\t\tif (*link_index >= sdw_be_num) {\n\t\t\tdev_err(dev, \"invalid dai link index %d\\n\", *link_index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (*cpu_id >= sdw_cpu_dai_num) {\n\t\t\tdev_err(dev, \"invalid cpu dai index %d\\n\", *cpu_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tplayback = (stream == SNDRV_PCM_STREAM_PLAYBACK);\n\t\tcapture = (stream == SNDRV_PCM_STREAM_CAPTURE);\n\t\tinit_dai_link(dev, dai_links + *link_index, (*be_id)++, name,\n\t\t\t      playback, capture,\n\t\t\t      cpus + *cpu_id, cpu_dai_num,\n\t\t\t      codecs, codec_num,\n\t\t\t      NULL, &sdw_ops);\n\n\t\t \n\t\tdai_links[*link_index].nonatomic = true;\n\n\t\tset_dailink_map(sdw_codec_ch_maps, codec_num, cpu_dai_num);\n\t\tdai_links[*link_index].codec_ch_maps = sdw_codec_ch_maps;\n\t\tret = set_codec_init_func(card, adr_link, dai_links + (*link_index)++,\n\t\t\t\t\t  playback, group_id, adr_index, dai_index);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to init codec %d\\n\", codec_index);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*cpu_id += cpu_dai_num;\n\t}\n\n\treturn 0;\n}\n\n#define IDISP_CODEC_MASK\t0x4\n\nstatic int sof_card_dai_links_create(struct snd_soc_card *card)\n{\n\tstruct device *dev = card->dev;\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(card->dev);\n\tint sdw_be_num = 0, ssp_num = 0, dmic_num = 0, hdmi_num = 0, bt_num = 0;\n\tstruct mc_private *ctx = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link_component *idisp_components;\n\tstruct snd_soc_dai_link_component *ssp_components;\n\tstruct snd_soc_acpi_mach_params *mach_params = &mach->mach_params;\n\tconst struct snd_soc_acpi_link_adr *adr_link = mach_params->links;\n\tbool aggregation = !(sof_sdw_quirk & SOF_SDW_NO_AGGREGATION);\n\tstruct snd_soc_dai_link_component *cpus;\n\tstruct snd_soc_codec_conf *codec_conf;\n\tbool append_dai_type = false;\n\tbool ignore_pch_dmic = false;\n\tint codec_conf_num = 0;\n\tint codec_conf_index = 0;\n\tbool group_generated[SDW_MAX_GROUPS] = { };\n\tint ssp_codec_index, ssp_mask;\n\tstruct snd_soc_dai_link *dai_links;\n\tint num_links, link_index = 0;\n\tchar *name, *cpu_name;\n\tint total_cpu_dai_num;\n\tint sdw_cpu_dai_num;\n\tint i, j, be_id = 0;\n\tint codec_index;\n\tint cpu_id = 0;\n\tint ret;\n\n\tret = get_dailink_info(dev, adr_link, &sdw_be_num, &sdw_cpu_dai_num,\n\t\t\t       &codec_conf_num);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get sdw link info %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tssp_codec_index = find_codec_info_acpi(mach->id);\n\tif (ssp_codec_index >= 0) {\n\t\tssp_mask = SOF_SSP_GET_PORT(sof_sdw_quirk);\n\t\tssp_num = hweight_long(ssp_mask);\n\t}\n\n\tif (mach_params->codec_mask & IDISP_CODEC_MASK) {\n\t\tctx->idisp_codec = true;\n\n\t\tif (sof_sdw_quirk & SOF_SDW_TGL_HDMI)\n\t\t\thdmi_num = SOF_TGL_HDMI_COUNT;\n\t\telse\n\t\t\thdmi_num = SOF_PRE_TGL_HDMI_COUNT;\n\t}\n\n\t \n\tif (sof_sdw_quirk & SOF_SDW_PCH_DMIC || mach_params->dmic_num)\n\t\tdmic_num = 2;\n\n\tif (sof_sdw_quirk & SOF_SSP_BT_OFFLOAD_PRESENT)\n\t\tbt_num = 1;\n\n\tdev_dbg(dev, \"sdw %d, ssp %d, dmic %d, hdmi %d, bt: %d\\n\",\n\t\tsdw_be_num, ssp_num, dmic_num, hdmi_num, bt_num);\n\n\t \n\tnum_links = sdw_be_num + ssp_num + dmic_num + hdmi_num + bt_num;\n\tdai_links = devm_kcalloc(dev, num_links, sizeof(*dai_links), GFP_KERNEL);\n\tif (!dai_links)\n\t\treturn -ENOMEM;\n\n\t \n\ttotal_cpu_dai_num = sdw_cpu_dai_num + ssp_num + dmic_num + hdmi_num + bt_num;\n\tcpus = devm_kcalloc(dev, total_cpu_dai_num, sizeof(*cpus), GFP_KERNEL);\n\tif (!cpus)\n\t\treturn -ENOMEM;\n\n\t \n\tcodec_conf = devm_kcalloc(dev, codec_conf_num, sizeof(*codec_conf),\n\t\t\t\t  GFP_KERNEL);\n\tif (!codec_conf)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!sdw_be_num)\n\t\tgoto SSP;\n\n\tfor (i = 0; i < SDW_MAX_LINKS; i++)\n\t\tsdw_pin_index[i] = SDW_INTEL_BIDIR_PDI_BASE;\n\n\tfor (; adr_link->num_adr; adr_link++) {\n\t\t \n\t\tfor (i = 0; i < adr_link->num_adr; i++) {\n\t\t\t \n\t\t\tcodec_index = find_codec_info_part(adr_link->adr_d[i].adr);\n\t\t\tif (codec_index < 0)\n\t\t\t\treturn codec_index;\n\t\t\tif (codec_info_list[codec_index].dai_num > 1) {\n\t\t\t\tappend_dai_type = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif ((SDW_PART_ID(adr_link->adr_d[i].adr) !=\n\t\t\t\t    SDW_PART_ID(adr_link->adr_d[j].adr)) ||\n\t\t\t\t    (SDW_MFG_ID(adr_link->adr_d[i].adr) !=\n\t\t\t\t    SDW_MFG_ID(adr_link->adr_d[j].adr))) {\n\t\t\t\t\tappend_dai_type = true;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nout:\n\n\t \n\tfor (adr_link = mach_params->links ; adr_link->num_adr; adr_link++) {\n\t\tfor (i = 0; i < adr_link->num_adr; i++) {\n\t\t\tconst struct snd_soc_acpi_endpoint *endpoint;\n\n\t\t\tendpoint = adr_link->adr_d[i].endpoints;\n\n\t\t\t \n\t\t\tif (endpoint->aggregated &&\n\t\t\t    group_generated[endpoint->group_id])\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tcodec_index = find_codec_info_part(adr_link->adr_d[i].adr);\n\t\t\tif (codec_index < 0)\n\t\t\t\treturn codec_index;\n\n\t\t\tfor (j = 0; j < codec_info_list[codec_index].dai_num ; j++) {\n\t\t\t\tret = create_sdw_dailink(card, &link_index, dai_links,\n\t\t\t\t\t\t\t sdw_be_num, sdw_cpu_dai_num, cpus,\n\t\t\t\t\t\t\t adr_link, &cpu_id,\n\t\t\t\t\t\t\t codec_conf, codec_conf_num,\n\t\t\t\t\t\t\t &be_id, &codec_conf_index,\n\t\t\t\t\t\t\t &ignore_pch_dmic, append_dai_type, i, j);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dev, \"failed to create dai link %d\\n\", link_index);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (aggregation && endpoint->aggregated)\n\t\t\t\tgroup_generated[endpoint->group_id] = true;\n\t\t}\n\t}\n\nSSP:\n\t \n\tif (!ssp_num)\n\t\tgoto DMIC;\n\n\tfor (i = 0, j = 0; ssp_mask; i++, ssp_mask >>= 1) {\n\t\tstruct sof_sdw_codec_info *info;\n\t\tint playback, capture;\n\t\tchar *codec_name;\n\n\t\tif (!(ssp_mask & 0x1))\n\t\t\tcontinue;\n\n\t\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t      \"SSP%d-Codec\", i);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tcpu_name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d Pin\", i);\n\t\tif (!cpu_name)\n\t\t\treturn -ENOMEM;\n\n\t\tssp_components = devm_kzalloc(dev, sizeof(*ssp_components),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!ssp_components)\n\t\t\treturn -ENOMEM;\n\n\t\tinfo = &codec_info_list[ssp_codec_index];\n\t\tcodec_name = devm_kasprintf(dev, GFP_KERNEL, \"i2c-%s:0%d\",\n\t\t\t\t\t    info->acpi_id, j++);\n\t\tif (!codec_name)\n\t\t\treturn -ENOMEM;\n\n\t\tssp_components->name = codec_name;\n\t\t \n\t\tssp_components->dai_name = info->dais[0].dai_name;\n\t\tcpus[cpu_id].dai_name = cpu_name;\n\n\t\tplayback = info->dais[0].direction[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tcapture = info->dais[0].direction[SNDRV_PCM_STREAM_CAPTURE];\n\t\tinit_dai_link(dev, dai_links + link_index, be_id, name,\n\t\t\t      playback, capture,\n\t\t\t      cpus + cpu_id, 1,\n\t\t\t      ssp_components, 1,\n\t\t\t      NULL, info->ops);\n\n\t\tret = info->dais[0].init(card, NULL, dai_links + link_index, info, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tINC_ID(be_id, cpu_id, link_index);\n\t}\n\nDMIC:\n\t \n\tif (dmic_num > 0) {\n\t\tif (ignore_pch_dmic) {\n\t\t\tdev_warn(dev, \"Ignoring PCH DMIC\\n\");\n\t\t\tgoto HDMI;\n\t\t}\n\t\tcpus[cpu_id].dai_name = \"DMIC01 Pin\";\n\t\tinit_dai_link(dev, dai_links + link_index, be_id, \"dmic01\",\n\t\t\t      0, 1,  \n\t\t\t      cpus + cpu_id, 1,\n\t\t\t      dmic_component, 1,\n\t\t\t      sof_sdw_dmic_init, NULL);\n\t\tINC_ID(be_id, cpu_id, link_index);\n\n\t\tcpus[cpu_id].dai_name = \"DMIC16k Pin\";\n\t\tinit_dai_link(dev, dai_links + link_index, be_id, \"dmic16k\",\n\t\t\t      0, 1,  \n\t\t\t      cpus + cpu_id, 1,\n\t\t\t      dmic_component, 1,\n\t\t\t       \n\t\t\t      NULL, NULL);\n\t\tINC_ID(be_id, cpu_id, link_index);\n\t}\n\nHDMI:\n\t \n\tif (hdmi_num > 0) {\n\t\tidisp_components = devm_kcalloc(dev, hdmi_num,\n\t\t\t\t\t\tsizeof(*idisp_components),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!idisp_components)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < hdmi_num; i++) {\n\t\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t      \"iDisp%d\", i + 1);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (ctx->idisp_codec) {\n\t\t\tidisp_components[i].name = \"ehdaudio0D2\";\n\t\t\tidisp_components[i].dai_name = devm_kasprintf(dev,\n\t\t\t\t\t\t\t\t      GFP_KERNEL,\n\t\t\t\t\t\t\t\t      \"intel-hdmi-hifi%d\",\n\t\t\t\t\t\t\t\t      i + 1);\n\t\t\tif (!idisp_components[i].dai_name)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tidisp_components[i] = asoc_dummy_dlc;\n\t\t}\n\n\t\tcpu_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t  \"iDisp%d Pin\", i + 1);\n\t\tif (!cpu_name)\n\t\t\treturn -ENOMEM;\n\n\t\tcpus[cpu_id].dai_name = cpu_name;\n\t\tinit_dai_link(dev, dai_links + link_index, be_id, name,\n\t\t\t      1, 0, \n\t\t\t      cpus + cpu_id, 1,\n\t\t\t      idisp_components + i, 1,\n\t\t\t      sof_sdw_hdmi_init, NULL);\n\t\tINC_ID(be_id, cpu_id, link_index);\n\t}\n\n\tif (sof_sdw_quirk & SOF_SSP_BT_OFFLOAD_PRESENT) {\n\t\tint port = (sof_sdw_quirk & SOF_BT_OFFLOAD_SSP_MASK) >>\n\t\t\t\tSOF_BT_OFFLOAD_SSP_SHIFT;\n\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d-BT\", port);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tcpu_name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d Pin\", port);\n\t\tif (!cpu_name)\n\t\t\treturn -ENOMEM;\n\n\t\tcpus[cpu_id].dai_name = cpu_name;\n\t\tinit_dai_link(dev, dai_links + link_index, be_id, name, 1, 1,\n\t\t\t      cpus + cpu_id, 1, &asoc_dummy_dlc, 1, NULL, NULL);\n\t}\n\n\tcard->dai_link = dai_links;\n\tcard->num_links = num_links;\n\n\tcard->codec_conf = codec_conf;\n\tcard->num_configs = codec_conf_num;\n\n\treturn 0;\n}\n\nstatic int sof_sdw_card_late_probe(struct snd_soc_card *card)\n{\n\tstruct mc_private *ctx = snd_soc_card_get_drvdata(card);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++) {\n\t\tif (codec_info_list[i].codec_card_late_probe) {\n\t\t\tret = codec_info_list[i].codec_card_late_probe(card);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ctx->idisp_codec)\n\t\tret = sof_sdw_hdmi_card_late_probe(card);\n\n\treturn ret;\n}\n\n \nstatic const char sdw_card_long_name[] = \"Intel Soundwire SOF\";\n\nstatic struct snd_soc_card card_sof_sdw = {\n\t.name = \"soundwire\",\n\t.owner = THIS_MODULE,\n\t.late_probe = sof_sdw_card_late_probe,\n};\n\n \nstatic struct snd_soc_dai_link *mc_find_codec_dai_used(struct snd_soc_card *card,\n\t\t\t\t\t\t       const char *dai_name)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tint i;\n\tint j;\n\n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tfor (j = 0; j < dai_link->num_codecs; j++) {\n\t\t\t \n\t\t\tif (!strcmp(dai_link->codecs[j].dai_name, dai_name))\n\t\t\t\treturn dai_link;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void mc_dailink_exit_loop(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tint ret;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++) {\n\t\tfor (j = 0; j < codec_info_list[i].dai_num; j++) {\n\t\t\t \n\t\t\tif (!codec_info_list[i].dais[j].exit)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdai_link = mc_find_codec_dai_used(card,\n\t\t\t\t\t\t\t  codec_info_list[i].dais[j].dai_name);\n\t\t\tif (dai_link) {\n\t\t\t\t \n\t\t\t\tret = codec_info_list[i].dais[j].exit(card, dai_link);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_warn(card->dev,\n\t\t\t\t\t\t \"codec exit failed %d\\n\",\n\t\t\t\t\t\t ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int mc_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = &card_sof_sdw;\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(&pdev->dev);\n\tstruct mc_private *ctx;\n\tint amp_num = 0, i;\n\tint ret;\n\n\tcard->dev = &pdev->dev;\n\n\tdev_dbg(card->dev, \"Entry\\n\");\n\n\tctx = devm_kzalloc(card->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ctx->hdmi_pcm_list);\n\n\tsnd_soc_card_set_drvdata(card, ctx);\n\n\tdmi_check_system(sof_sdw_quirk_table);\n\n\tif (quirk_override != -1) {\n\t\tdev_info(card->dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t sof_sdw_quirk, quirk_override);\n\t\tsof_sdw_quirk = quirk_override;\n\t}\n\n\tlog_quirks(card->dev);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++)\n\t\tcodec_info_list[i].amp_num = 0;\n\n\tif (mach->mach_params.subsystem_id_set) {\n\t\tsnd_soc_card_set_pci_ssid(card,\n\t\t\t\t\t  mach->mach_params.subsystem_vendor,\n\t\t\t\t\t  mach->mach_params.subsystem_device);\n\t}\n\n\tret = sof_card_dai_links_create(card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(codec_info_list); i++)\n\t\tamp_num += codec_info_list[i].amp_num;\n\n\tcard->components = devm_kasprintf(card->dev, GFP_KERNEL,\n\t\t\t\t\t  \"cfg-spk:%d cfg-amp:%d\",\n\t\t\t\t\t  (sof_sdw_quirk & SOF_SDW_FOUR_SPK)\n\t\t\t\t\t  ? 4 : 2, amp_num);\n\tif (!card->components)\n\t\treturn -ENOMEM;\n\n\tif (mach->mach_params.dmic_num) {\n\t\tcard->components = devm_kasprintf(card->dev, GFP_KERNEL,\n\t\t\t\t\t\t  \"%s mic:dmic cfg-mics:%d\",\n\t\t\t\t\t\t  card->components,\n\t\t\t\t\t\t  mach->mach_params.dmic_num);\n\t\tif (!card->components)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tcard->long_name = sdw_card_long_name;\n\n\t \n\tret = devm_snd_soc_register_card(card->dev, card);\n\tif (ret) {\n\t\tdev_err(card->dev, \"snd_soc_register_card failed %d\\n\", ret);\n\t\tmc_dailink_exit_loop(card);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, card);\n\n\treturn ret;\n}\n\nstatic void mc_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\n\tmc_dailink_exit_loop(card);\n}\n\nstatic const struct platform_device_id mc_id_table[] = {\n\t{ \"sof_sdw\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, mc_id_table);\n\nstatic struct platform_driver sof_sdw_driver = {\n\t.driver = {\n\t\t.name = \"sof_sdw\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = mc_probe,\n\t.remove_new = mc_remove,\n\t.id_table = mc_id_table,\n};\n\nmodule_platform_driver(sof_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC SoundWire Generic Machine driver\");\nMODULE_AUTHOR(\"Bard Liao <yung-chuan.liao@linux.intel.com>\");\nMODULE_AUTHOR(\"Rander Wang <rander.wang@linux.intel.com>\");\nMODULE_AUTHOR(\"Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SND_SOC_INTEL_HDA_DSP_COMMON);\nMODULE_IMPORT_NS(SND_SOC_INTEL_SOF_MAXIM_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}