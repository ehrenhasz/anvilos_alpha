{
  "module_name": "bytcr_wm5102.c",
  "hash_id": "212248b8e4d18b8ff6a2f7f2f3c91b81f523cf3dd1890a77030b08469ba06c70",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/bytcr_wm5102.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"../../codecs/wm5102.h\"\n#include \"../atom/sst-atom-controls.h\"\n\n#define MCLK_FREQ\t\t25000000\n\n#define WM5102_MAX_SYSCLK_4K\t49152000  \n#define WM5102_MAX_SYSCLK_11025\t45158400  \n\nstruct byt_wm5102_private {\n\tstruct snd_soc_jack jack;\n\tstruct clk *mclk;\n\tstruct gpio_desc *spkvdd_en_gpio;\n};\n\nstatic int byt_wm5102_spkvdd_power_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct byt_wm5102_private *priv = snd_soc_card_get_drvdata(card);\n\n\tgpiod_set_value_cansleep(priv->spkvdd_en_gpio,\n\t\t\t\t !!SND_SOC_DAPM_EVENT_ON(event));\n\n\treturn 0;\n}\n\nstatic int byt_wm5102_prepare_and_enable_pll1(struct snd_soc_dai *codec_dai, int rate)\n{\n\tstruct snd_soc_component *codec_component = codec_dai->component;\n\tint sr_mult = ((rate % 4000) == 0) ?\n\t\t(WM5102_MAX_SYSCLK_4K / rate) :\n\t\t(WM5102_MAX_SYSCLK_11025 / rate);\n\tint ret;\n\n\t \n\tsnd_soc_dai_set_pll(codec_dai, WM5102_FLL1_REFCLK, ARIZONA_FLL_SRC_NONE, 0, 0);\n\tsnd_soc_dai_set_pll(codec_dai, WM5102_FLL1, ARIZONA_FLL_SRC_NONE, 0, 0);\n\n\t \n\tret = snd_soc_dai_set_pll(codec_dai, WM5102_FLL1, ARIZONA_CLK_SRC_MCLK1,\n\t\t\t\t  MCLK_FREQ, rate * sr_mult);\n\tif (ret) {\n\t\tdev_err(codec_component->dev, \"Error setting PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_sysclk(codec_component, ARIZONA_CLK_SYSCLK,\n\t\t\t\t\t   ARIZONA_CLK_SRC_FLL1, rate * sr_mult,\n\t\t\t\t\t   SND_SOC_CLOCK_IN);\n\tif (ret) {\n\t\tdev_err(codec_component->dev, \"Error setting SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, ARIZONA_CLK_SYSCLK,\n\t\t\t\t     rate * 512, SND_SOC_CLOCK_IN);\n\tif (ret) {\n\t\tdev_err(codec_component->dev, \"Error setting clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *k, int event)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct snd_soc_dai *codec_dai;\n\tstruct byt_wm5102_private *priv = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\tcodec_dai = snd_soc_card_get_codec_dai(card, \"wm5102-aif1\");\n\tif (!codec_dai) {\n\t\tdev_err(card->dev, \"Error codec DAI not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tret = clk_prepare_enable(priv->mclk);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev, \"Error enabling MCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = byt_wm5102_prepare_and_enable_pll1(codec_dai, 48000);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev, \"Error setting codec sysclk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tsnd_soc_dai_set_pll(codec_dai, WM5102_FLL1, ARIZONA_FLL_SRC_NONE, 0, 0);\n\t\tclk_disable_unprepare(priv->mclk);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget byt_wm5102_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Internal Mic\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line Out\", NULL),\n\tSND_SOC_DAPM_SUPPLY(\"Platform Clock\", SND_SOC_NOPM, 0, 0,\n\t\t\t    platform_clock_control, SND_SOC_DAPM_PRE_PMU |\n\t\t\t    SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"Speaker VDD\", SND_SOC_NOPM, 0, 0,\n\t\t\t    byt_wm5102_spkvdd_power_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n};\n\nstatic const struct snd_soc_dapm_route byt_wm5102_audio_map[] = {\n\t{\"Headphone\", NULL, \"Platform Clock\"},\n\t{\"Headset Mic\", NULL, \"Platform Clock\"},\n\t{\"Internal Mic\", NULL, \"Platform Clock\"},\n\t{\"Speaker\", NULL, \"Platform Clock\"},\n\t{\"Line Out\", NULL, \"Platform Clock\"},\n\n\t{\"Speaker\", NULL, \"SPKOUTLP\"},\n\t{\"Speaker\", NULL, \"SPKOUTLN\"},\n\t{\"Speaker\", NULL, \"SPKOUTRP\"},\n\t{\"Speaker\", NULL, \"SPKOUTRN\"},\n\t{\"Speaker\", NULL, \"Speaker VDD\"},\n\n\t{\"Headphone\", NULL, \"HPOUT1L\"},\n\t{\"Headphone\", NULL, \"HPOUT1R\"},\n\n\t{\"Internal Mic\", NULL, \"MICBIAS3\"},\n\t{\"IN3L\", NULL, \"Internal Mic\"},\n\n\t \n\t{\"Headset Mic\", NULL, \"MICBIAS1\"},\n\t{\"Headset Mic\", NULL, \"MICBIAS2\"},\n\t{\"IN1L\", NULL, \"Headset Mic\"},\n\n\t{\"AIF1 Playback\", NULL, \"ssp0 Tx\"},\n\t{\"ssp0 Tx\", NULL, \"modem_out\"},\n\n\t{\"modem_in\", NULL, \"ssp0 Rx\"},\n\t{\"ssp0 Rx\", NULL, \"AIF1 Capture\"},\n};\n\nstatic const struct snd_kcontrol_new byt_wm5102_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Internal Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\"),\n\tSOC_DAPM_PIN_SWITCH(\"Line Out\"),\n};\n\nstatic struct snd_soc_jack_pin byt_wm5102_pins[] = {\n\t{\n\t\t.pin\t= \"Headphone\",\n\t\t.mask\t= SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin\t= \"Headset Mic\",\n\t\t.mask\t= SND_JACK_MICROPHONE,\n\t},\n\t{\n\t\t.pin\t= \"Line Out\",\n\t\t.mask\t= SND_JACK_LINEOUT,\n\t},\n};\n\nstatic int byt_wm5102_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct snd_soc_card *card = runtime->card;\n\tstruct byt_wm5102_private *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(runtime, 0)->component;\n\tint ret, jack_type;\n\n\tcard->dapm.idle_bias_off = true;\n\n\tret = snd_soc_add_card_controls(card, byt_wm5102_controls,\n\t\t\t\t\tARRAY_SIZE(byt_wm5102_controls));\n\tif (ret) {\n\t\tdev_err(card->dev, \"Error adding card controls: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_prepare_enable(priv->mclk);\n\tif (!ret)\n\t\tclk_disable_unprepare(priv->mclk);\n\n\tret = clk_set_rate(priv->mclk, MCLK_FREQ);\n\tif (ret) {\n\t\tdev_err(card->dev, \"Error setting MCLK rate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tjack_type = ARIZONA_JACK_MASK | SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t    SND_JACK_BTN_2 | SND_JACK_BTN_3;\n\tret = snd_soc_card_jack_new_pins(card, \"Headset\", jack_type,\n\t\t\t\t\t &priv->jack, byt_wm5102_pins,\n\t\t\t\t\t ARRAY_SIZE(byt_wm5102_pins));\n\tif (ret) {\n\t\tdev_err(card->dev, \"Error creating jack: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_soc_component_set_jack(component, &priv->jack, NULL);\n\n\treturn 0;\n}\n\nstatic int byt_wm5102_codec_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\t\t      SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS);\n\tint ret;\n\n\t \n\trate->min = 48000;\n\trate->max = 48000;\n\tchannels->min = 2;\n\tchannels->max = 2;\n\n\t \n\tparams_set_format(params, SNDRV_PCM_FORMAT_S16_LE);\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_cpu(rtd, 0),\n\t\t\t\t  SND_SOC_DAIFMT_I2S     |\n\t\t\t\t  SND_SOC_DAIFMT_NB_NF   |\n\t\t\t\t  SND_SOC_DAIFMT_BP_FP);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Error setting format to I2S: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0x3, 0x3, 2, 16);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Error setting I2S config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int byt_wm5102_aif1_startup(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE, 48000);\n}\n\nstatic const struct snd_soc_ops byt_wm5102_aif1_ops = {\n\t.startup = byt_wm5102_aif1_startup,\n};\n\nSND_SOC_DAILINK_DEF(dummy,\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nSND_SOC_DAILINK_DEF(media,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"media-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(deepbuffer,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"deepbuffer-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(ssp0_port,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"ssp0-port\")));\n\nSND_SOC_DAILINK_DEF(ssp0_codec,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\n\t \n\t\"wm5102-codec\",\n\t\"wm5102-aif1\")));\n\nSND_SOC_DAILINK_DEF(platform,\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"sst-mfld-platform\")));\n\nstatic struct snd_soc_dai_link byt_wm5102_dais[] = {\n\t[MERR_DPCM_AUDIO] = {\n\t\t.name = \"Baytrail Audio Port\",\n\t\t.stream_name = \"Baytrail Audio\",\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.ops = &byt_wm5102_aif1_ops,\n\t\tSND_SOC_DAILINK_REG(media, dummy, platform),\n\n\t},\n\t[MERR_DPCM_DEEP_BUFFER] = {\n\t\t.name = \"Deep-Buffer Audio Port\",\n\t\t.stream_name = \"Deep-Buffer Audio\",\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.ops = &byt_wm5102_aif1_ops,\n\t\tSND_SOC_DAILINK_REG(deepbuffer, dummy, platform),\n\t},\n\t\t \n\t{\n\t\t \n\t\t.name = \"SSP2-Codec\",\n\t\t.id = 0,\n\t\t.no_pcm = 1,\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF\n\t\t\t\t\t\t| SND_SOC_DAIFMT_CBC_CFC,\n\t\t.be_hw_params_fixup = byt_wm5102_codec_fixup,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.init = byt_wm5102_init,\n\t\tSND_SOC_DAILINK_REG(ssp0_port, ssp0_codec, platform),\n\t},\n};\n\n \n#define SOF_CARD_NAME \"bytcht wm5102\"  \n#define SOF_DRIVER_NAME \"SOF\"\n\n#define CARD_NAME \"bytcr-wm5102\"\n#define DRIVER_NAME NULL  \n\n \nstatic struct snd_soc_card byt_wm5102_card = {\n\t.owner = THIS_MODULE,\n\t.dai_link = byt_wm5102_dais,\n\t.num_links = ARRAY_SIZE(byt_wm5102_dais),\n\t.dapm_widgets = byt_wm5102_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(byt_wm5102_widgets),\n\t.dapm_routes = byt_wm5102_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(byt_wm5102_audio_map),\n\t.fully_routed = true,\n};\n\nstatic int snd_byt_wm5102_mc_probe(struct platform_device *pdev)\n{\n\tchar codec_name[SND_ACPI_I2C_ID_LEN];\n\tstruct device *dev = &pdev->dev;\n\tstruct byt_wm5102_private *priv;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tbool sof_parent;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->mclk = devm_clk_get(dev, \"pmc_plt_clk_3\");\n\tif (IS_ERR(priv->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->mclk), \"getting pmc_plt_clk_3\\n\");\n\n\t \n\tmach = dev->platform_data;\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (!adev) {\n\t\tdev_err(dev, \"Error cannot find acpi-dev for codec\\n\");\n\t\treturn -ENOENT;\n\t}\n\tsnprintf(codec_name, sizeof(codec_name), \"spi-%s\", acpi_dev_name(adev));\n\n\tcodec_dev = bus_find_device_by_name(&spi_bus_type, NULL, codec_name);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tpriv->spkvdd_en_gpio = gpiod_get(codec_dev, \"wlf,spkvdd-ena\", GPIOD_OUT_LOW);\n\tput_device(codec_dev);\n\n\tif (IS_ERR(priv->spkvdd_en_gpio)) {\n\t\tret = PTR_ERR(priv->spkvdd_en_gpio);\n\t\t \n\t\tif (ret == -ENOENT)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\treturn dev_err_probe(dev, ret, \"getting spkvdd-GPIO\\n\");\n\t}\n\n\t \n\tbyt_wm5102_card.dev = dev;\n\tplatform_name = mach->mach_params.platform;\n\tret = snd_soc_fixup_dai_links_platform_name(&byt_wm5102_card, platform_name);\n\tif (ret)\n\t\tgoto out_put_gpio;\n\n\t \n\tsof_parent = snd_soc_acpi_sof_parent(dev);\n\tif (sof_parent) {\n\t\tbyt_wm5102_card.name = SOF_CARD_NAME;\n\t\tbyt_wm5102_card.driver_name = SOF_DRIVER_NAME;\n\t\tdev->driver->pm = &snd_soc_pm_ops;\n\t} else {\n\t\tbyt_wm5102_card.name = CARD_NAME;\n\t\tbyt_wm5102_card.driver_name = DRIVER_NAME;\n\t}\n\n\tsnd_soc_card_set_drvdata(&byt_wm5102_card, priv);\n\tret = devm_snd_soc_register_card(dev, &byt_wm5102_card);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"registering card\\n\");\n\t\tgoto out_put_gpio;\n\t}\n\n\tplatform_set_drvdata(pdev, &byt_wm5102_card);\n\treturn 0;\n\nout_put_gpio:\n\tgpiod_put(priv->spkvdd_en_gpio);\n\treturn ret;\n}\n\nstatic void snd_byt_wm5102_mc_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct byt_wm5102_private *priv = snd_soc_card_get_drvdata(card);\n\n\tgpiod_put(priv->spkvdd_en_gpio);\n}\n\nstatic struct platform_driver snd_byt_wm5102_mc_driver = {\n\t.driver = {\n\t\t.name = \"bytcr_wm5102\",\n\t},\n\t.probe = snd_byt_wm5102_mc_probe,\n\t.remove_new = snd_byt_wm5102_mc_remove,\n};\n\nmodule_platform_driver(snd_byt_wm5102_mc_driver);\n\nMODULE_DESCRIPTION(\"ASoC Baytrail with WM5102 codec machine driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:bytcr_wm5102\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}