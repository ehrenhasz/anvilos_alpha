{
  "module_name": "sof_cs42l42.c",
  "hash_id": "92f6def371df8eaa2df0837c50eefed717b94d7fb1d4bb3e4e5aa241ecb585e5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/sof_cs42l42.c",
  "human_readable_source": "\n\n\n \n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/dmi.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/sof.h>\n#include <sound/soc-acpi.h>\n#include <dt-bindings/sound/cs42l42.h>\n#include \"../../codecs/hdac_hdmi.h\"\n#include \"../common/soc-intel-quirks.h\"\n#include \"hda_dsp_common.h\"\n#include \"sof_maxim_common.h\"\n\n#define NAME_SIZE 32\n\n#define SOF_CS42L42_SSP_CODEC(quirk)\t\t((quirk) & GENMASK(2, 0))\n#define SOF_CS42L42_SSP_CODEC_MASK\t\t(GENMASK(2, 0))\n#define SOF_SPEAKER_AMP_PRESENT\t\t\tBIT(3)\n#define SOF_CS42L42_SSP_AMP_SHIFT\t\t4\n#define SOF_CS42L42_SSP_AMP_MASK\t\t(GENMASK(6, 4))\n#define SOF_CS42L42_SSP_AMP(quirk)\t\\\n\t(((quirk) << SOF_CS42L42_SSP_AMP_SHIFT) & SOF_CS42L42_SSP_AMP_MASK)\n#define SOF_CS42L42_NUM_HDMIDEV_SHIFT\t\t7\n#define SOF_CS42L42_NUM_HDMIDEV_MASK\t\t(GENMASK(9, 7))\n#define SOF_CS42L42_NUM_HDMIDEV(quirk)\t\\\n\t(((quirk) << SOF_CS42L42_NUM_HDMIDEV_SHIFT) & SOF_CS42L42_NUM_HDMIDEV_MASK)\n#define SOF_CS42L42_DAILINK_SHIFT\t\t10\n#define SOF_CS42L42_DAILINK_MASK\t\t(GENMASK(24, 10))\n#define SOF_CS42L42_DAILINK(link1, link2, link3, link4, link5) \\\n\t((((link1) | ((link2) << 3) | ((link3) << 6) | ((link4) << 9) | ((link5) << 12)) << SOF_CS42L42_DAILINK_SHIFT) & SOF_CS42L42_DAILINK_MASK)\n#define SOF_BT_OFFLOAD_PRESENT\t\t\tBIT(25)\n#define SOF_CS42L42_SSP_BT_SHIFT\t\t26\n#define SOF_CS42L42_SSP_BT_MASK\t\t\t(GENMASK(28, 26))\n#define SOF_CS42L42_SSP_BT(quirk)\t\\\n\t(((quirk) << SOF_CS42L42_SSP_BT_SHIFT) & SOF_CS42L42_SSP_BT_MASK)\n#define SOF_MAX98357A_SPEAKER_AMP_PRESENT\tBIT(29)\n#define SOF_MAX98360A_SPEAKER_AMP_PRESENT\tBIT(30)\n\nenum {\n\tLINK_NONE = 0,\n\tLINK_HP = 1,\n\tLINK_SPK = 2,\n\tLINK_DMIC = 3,\n\tLINK_HDMI = 4,\n\tLINK_BT = 5,\n};\n\nstatic struct snd_soc_jack_pin jack_pins[] = {\n\t{\n\t\t.pin    = \"Headphone Jack\",\n\t\t.mask   = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin    = \"Headset Mic\",\n\t\t.mask   = SND_JACK_MICROPHONE,\n\t},\n};\n\n \nstatic unsigned long sof_cs42l42_quirk = SOF_CS42L42_SSP_CODEC(2);\n\nstruct sof_hdmi_pcm {\n\tstruct list_head head;\n\tstruct snd_soc_dai *codec_dai;\n\tstruct snd_soc_jack hdmi_jack;\n\tint device;\n};\n\nstruct sof_card_private {\n\tstruct snd_soc_jack headset_jack;\n\tstruct list_head hdmi_pcm_list;\n\tbool common_hdmi_codec_drv;\n};\n\nstatic int sof_hdmi_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct sof_card_private *ctx = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct sof_hdmi_pcm *pcm;\n\n\tpcm = devm_kzalloc(rtd->card->dev, sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\n\t \n\tpcm->device = rtd->dai_link->id;\n\tpcm->codec_dai = dai;\n\n\tlist_add_tail(&pcm->head, &ctx->hdmi_pcm_list);\n\n\treturn 0;\n}\n\nstatic int sof_cs42l42_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct sof_card_private *ctx = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\tstruct snd_soc_jack *jack = &ctx->headset_jack;\n\tint ret;\n\n\t \n\tret = snd_soc_card_jack_new_pins(rtd->card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_BTN_0 |\n\t\t\t\t\t SND_JACK_BTN_1 | SND_JACK_BTN_2 |\n\t\t\t\t\t SND_JACK_BTN_3,\n\t\t\t\t\t jack,\n\t\t\t\t\t jack_pins,\n\t\t\t\t\t ARRAY_SIZE(jack_pins));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack creation failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_1, KEY_VOLUMEUP);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_3, KEY_VOICECOMMAND);\n\n\tret = snd_soc_component_set_jack(component, jack, NULL);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack call-back failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n};\n\nstatic void sof_cs42l42_exit(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\n\tsnd_soc_component_set_jack(component, NULL, NULL);\n}\n\nstatic int sof_cs42l42_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint clk_freq, ret;\n\n\tclk_freq = sof_dai_get_bclk(rtd);  \n\n\tif (clk_freq <= 0) {\n\t\tdev_err(rtd->dev, \"get bclk freq failed: %d\\n\", clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, 0,\n\t\t\t\t     clk_freq, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\tdev_err(rtd->dev, \"snd_soc_dai_set_sysclk err = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops sof_cs42l42_ops = {\n\t.hw_params = sof_cs42l42_hw_params,\n};\n\nstatic struct snd_soc_dai_link_component platform_component[] = {\n\t{\n\t\t \n\t\t.name = \"0000:00:1f.3\"\n\t}\n};\n\nstatic int sof_card_late_probe(struct snd_soc_card *card)\n{\n\tstruct sof_card_private *ctx = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_component *component = NULL;\n\tchar jack_name[NAME_SIZE];\n\tstruct sof_hdmi_pcm *pcm;\n\tint err;\n\n\tif (list_empty(&ctx->hdmi_pcm_list))\n\t\treturn -EINVAL;\n\n\tif (ctx->common_hdmi_codec_drv) {\n\t\tpcm = list_first_entry(&ctx->hdmi_pcm_list, struct sof_hdmi_pcm,\n\t\t\t\t       head);\n\t\tcomponent = pcm->codec_dai->component;\n\t\treturn hda_dsp_hdmi_build_controls(card, component);\n\t}\n\n\tlist_for_each_entry(pcm, &ctx->hdmi_pcm_list, head) {\n\t\tcomponent = pcm->codec_dai->component;\n\t\tsnprintf(jack_name, sizeof(jack_name),\n\t\t\t \"HDMI/DP, pcm=%d Jack\", pcm->device);\n\t\terr = snd_soc_card_jack_new(card, jack_name,\n\t\t\t\t\t    SND_JACK_AVOUT, &pcm->hdmi_jack);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hdac_hdmi_jack_init(pcm->codec_dai, pcm->device,\n\t\t\t\t\t  &pcm->hdmi_jack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn hdac_hdmi_jack_port_init(component, &card->dapm);\n}\n\nstatic const struct snd_kcontrol_new sof_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget sof_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_widget dmic_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"SoC DMIC\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route sof_map[] = {\n\t \n\t{\"Headphone Jack\", NULL, \"HP\"},\n\n\t \n\t{\"HS\", NULL, \"Headset Mic\"},\n};\n\nstatic const struct snd_soc_dapm_route dmic_map[] = {\n\t \n\t{\"DMic\", NULL, \"SoC DMIC\"},\n};\n\nstatic int dmic_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tint ret;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, dmic_widgets,\n\t\t\t\t\tARRAY_SIZE(dmic_widgets));\n\tif (ret) {\n\t\tdev_err(card->dev, \"DMic widget addition failed: %d\\n\", ret);\n\t\t \n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, dmic_map,\n\t\t\t\t      ARRAY_SIZE(dmic_map));\n\n\tif (ret)\n\t\tdev_err(card->dev, \"DMic map addition failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic struct snd_soc_card sof_audio_card_cs42l42 = {\n\t.name = \"cs42l42\",  \n\t.owner = THIS_MODULE,\n\t.controls = sof_controls,\n\t.num_controls = ARRAY_SIZE(sof_controls),\n\t.dapm_widgets = sof_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(sof_widgets),\n\t.dapm_routes = sof_map,\n\t.num_dapm_routes = ARRAY_SIZE(sof_map),\n\t.fully_routed = true,\n\t.late_probe = sof_card_late_probe,\n};\n\nstatic struct snd_soc_dai_link_component cs42l42_component[] = {\n\t{\n\t\t.name = \"i2c-10134242:00\",\n\t\t.dai_name = \"cs42l42\",\n\t}\n};\n\nstatic struct snd_soc_dai_link_component dmic_component[] = {\n\t{\n\t\t.name = \"dmic-codec\",\n\t\t.dai_name = \"dmic-hifi\",\n\t}\n};\n\nstatic int create_spk_amp_dai_links(struct device *dev,\n\t\t\t\t    struct snd_soc_dai_link *links,\n\t\t\t\t    struct snd_soc_dai_link_component *cpus,\n\t\t\t\t    int *id, int ssp_amp)\n{\n\tint ret = 0;\n\n\t \n\tif (!(sof_cs42l42_quirk & SOF_SPEAKER_AMP_PRESENT))\n\t\treturn 0;\n\n\tlinks[*id].name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d-Codec\",\n\t\t\t\t\t ssp_amp);\n\tif (!links[*id].name) {\n\t\tret = -ENOMEM;\n\t\tgoto devm_err;\n\t}\n\n\tlinks[*id].id = *id;\n\n\tif (sof_cs42l42_quirk & SOF_MAX98357A_SPEAKER_AMP_PRESENT) {\n\t\tmax_98357a_dai_link(&links[*id]);\n\t} else if (sof_cs42l42_quirk & SOF_MAX98360A_SPEAKER_AMP_PRESENT) {\n\t\tmax_98360a_dai_link(&links[*id]);\n\t} else {\n\t\tdev_err(dev, \"no amp defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto devm_err;\n\t}\n\n\tlinks[*id].platforms = platform_component;\n\tlinks[*id].num_platforms = ARRAY_SIZE(platform_component);\n\tlinks[*id].dpcm_playback = 1;\n\t \n\tlinks[*id].dpcm_capture = 1;\n\n\tlinks[*id].no_pcm = 1;\n\tlinks[*id].cpus = &cpus[*id];\n\tlinks[*id].num_cpus = 1;\n\n\tlinks[*id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t   \"SSP%d Pin\", ssp_amp);\n\tif (!links[*id].cpus->dai_name) {\n\t\tret = -ENOMEM;\n\t\tgoto devm_err;\n\t}\n\n\t(*id)++;\n\ndevm_err:\n\treturn ret;\n}\n\nstatic int create_hp_codec_dai_links(struct device *dev,\n\t\t\t\t     struct snd_soc_dai_link *links,\n\t\t\t\t     struct snd_soc_dai_link_component *cpus,\n\t\t\t\t     int *id, int ssp_codec)\n{\n\t \n\tlinks[*id].name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d-Codec\",\n\t\t\t\t\t ssp_codec);\n\tif (!links[*id].name)\n\t\tgoto devm_err;\n\n\tlinks[*id].id = *id;\n\tlinks[*id].codecs = cs42l42_component;\n\tlinks[*id].num_codecs = ARRAY_SIZE(cs42l42_component);\n\tlinks[*id].platforms = platform_component;\n\tlinks[*id].num_platforms = ARRAY_SIZE(platform_component);\n\tlinks[*id].init = sof_cs42l42_init;\n\tlinks[*id].exit = sof_cs42l42_exit;\n\tlinks[*id].ops = &sof_cs42l42_ops;\n\tlinks[*id].dpcm_playback = 1;\n\tlinks[*id].dpcm_capture = 1;\n\tlinks[*id].no_pcm = 1;\n\tlinks[*id].cpus = &cpus[*id];\n\tlinks[*id].num_cpus = 1;\n\n\tlinks[*id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t   \"SSP%d Pin\",\n\t\t\t\t\t\t   ssp_codec);\n\tif (!links[*id].cpus->dai_name)\n\t\tgoto devm_err;\n\n\t(*id)++;\n\n\treturn 0;\n\ndevm_err:\n\treturn -ENOMEM;\n}\n\nstatic int create_dmic_dai_links(struct device *dev,\n\t\t\t\t struct snd_soc_dai_link *links,\n\t\t\t\t struct snd_soc_dai_link_component *cpus,\n\t\t\t\t int *id, int dmic_be_num)\n{\n\tint i;\n\n\t \n\tif (dmic_be_num <= 0)\n\t\treturn 0;\n\n\t \n\tlinks[*id].name = \"dmic01\";\n\tlinks[*id].cpus = &cpus[*id];\n\tlinks[*id].cpus->dai_name = \"DMIC01 Pin\";\n\tlinks[*id].init = dmic_init;\n\tif (dmic_be_num > 1) {\n\t\t \n\t\tlinks[*id + 1].name = \"dmic16k\";\n\t\tlinks[*id + 1].cpus = &cpus[*id + 1];\n\t\tlinks[*id + 1].cpus->dai_name = \"DMIC16k Pin\";\n\t\tdmic_be_num = 2;\n\t}\n\n\tfor (i = 0; i < dmic_be_num; i++) {\n\t\tlinks[*id].id = *id;\n\t\tlinks[*id].num_cpus = 1;\n\t\tlinks[*id].codecs = dmic_component;\n\t\tlinks[*id].num_codecs = ARRAY_SIZE(dmic_component);\n\t\tlinks[*id].platforms = platform_component;\n\t\tlinks[*id].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[*id].ignore_suspend = 1;\n\t\tlinks[*id].dpcm_capture = 1;\n\t\tlinks[*id].no_pcm = 1;\n\n\t\t(*id)++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_hdmi_dai_links(struct device *dev,\n\t\t\t\t struct snd_soc_dai_link *links,\n\t\t\t\t struct snd_soc_dai_link_component *cpus,\n\t\t\t\t int *id, int hdmi_num)\n{\n\tstruct snd_soc_dai_link_component *idisp_components;\n\tint i;\n\n\t \n\tif (hdmi_num <= 0)\n\t\treturn 0;\n\n\tidisp_components = devm_kcalloc(dev,\n\t\t\t\t\thdmi_num,\n\t\t\t\t\tsizeof(struct snd_soc_dai_link_component), GFP_KERNEL);\n\tif (!idisp_components)\n\t\tgoto devm_err;\n\n\tfor (i = 1; i <= hdmi_num; i++) {\n\t\tlinks[*id].name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t \"iDisp%d\", i);\n\t\tif (!links[*id].name)\n\t\t\tgoto devm_err;\n\n\t\tlinks[*id].id = *id;\n\t\tlinks[*id].cpus = &cpus[*id];\n\t\tlinks[*id].num_cpus = 1;\n\t\tlinks[*id].cpus->dai_name = devm_kasprintf(dev,\n\t\t\t\t\t\t\t   GFP_KERNEL,\n\t\t\t\t\t\t\t   \"iDisp%d Pin\",\n\t\t\t\t\t\t\t   i);\n\t\tif (!links[*id].cpus->dai_name)\n\t\t\tgoto devm_err;\n\n\t\tidisp_components[i - 1].name = \"ehdaudio0D2\";\n\t\tidisp_components[i - 1].dai_name = devm_kasprintf(dev,\n\t\t\t\t\t\t\t\t  GFP_KERNEL,\n\t\t\t\t\t\t\t\t  \"intel-hdmi-hifi%d\",\n\t\t\t\t\t\t\t\t  i);\n\t\tif (!idisp_components[i - 1].dai_name)\n\t\t\tgoto devm_err;\n\n\t\tlinks[*id].codecs = &idisp_components[i - 1];\n\t\tlinks[*id].num_codecs = 1;\n\t\tlinks[*id].platforms = platform_component;\n\t\tlinks[*id].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[*id].init = sof_hdmi_init;\n\t\tlinks[*id].dpcm_playback = 1;\n\t\tlinks[*id].no_pcm = 1;\n\n\t\t(*id)++;\n\t}\n\n\treturn 0;\n\ndevm_err:\n\treturn -ENOMEM;\n}\n\nstatic int create_bt_offload_dai_links(struct device *dev,\n\t\t\t\t       struct snd_soc_dai_link *links,\n\t\t\t\t       struct snd_soc_dai_link_component *cpus,\n\t\t\t\t       int *id, int ssp_bt)\n{\n\t \n\tif (!(sof_cs42l42_quirk & SOF_BT_OFFLOAD_PRESENT))\n\t\treturn 0;\n\n\tlinks[*id].name = devm_kasprintf(dev, GFP_KERNEL, \"SSP%d-BT\",\n\t\t\t\t\t ssp_bt);\n\tif (!links[*id].name)\n\t\tgoto devm_err;\n\n\tlinks[*id].id = *id;\n\tlinks[*id].codecs = &asoc_dummy_dlc;\n\tlinks[*id].num_codecs = 1;\n\tlinks[*id].platforms = platform_component;\n\tlinks[*id].num_platforms = ARRAY_SIZE(platform_component);\n\n\tlinks[*id].dpcm_playback = 1;\n\tlinks[*id].dpcm_capture = 1;\n\tlinks[*id].no_pcm = 1;\n\tlinks[*id].cpus = &cpus[*id];\n\tlinks[*id].num_cpus = 1;\n\n\tlinks[*id].cpus->dai_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t   \"SSP%d Pin\",\n\t\t\t\t\t\t   ssp_bt);\n\tif (!links[*id].cpus->dai_name)\n\t\tgoto devm_err;\n\n\t(*id)++;\n\n\treturn 0;\n\ndevm_err:\n\treturn -ENOMEM;\n}\n\nstatic struct snd_soc_dai_link *sof_card_dai_links_create(struct device *dev,\n\t\t\t\t\t\t\t  int ssp_codec,\n\t\t\t\t\t\t\t  int ssp_amp,\n\t\t\t\t\t\t\t  int ssp_bt,\n\t\t\t\t\t\t\t  int dmic_be_num,\n\t\t\t\t\t\t\t  int hdmi_num)\n{\n\tstruct snd_soc_dai_link_component *cpus;\n\tstruct snd_soc_dai_link *links;\n\tint ret, id = 0, link_seq;\n\n\tlinks = devm_kcalloc(dev, sof_audio_card_cs42l42.num_links,\n\t\t\t    sizeof(struct snd_soc_dai_link), GFP_KERNEL);\n\tcpus = devm_kcalloc(dev, sof_audio_card_cs42l42.num_links,\n\t\t\t    sizeof(struct snd_soc_dai_link_component), GFP_KERNEL);\n\tif (!links || !cpus)\n\t\tgoto devm_err;\n\n\tlink_seq = (sof_cs42l42_quirk & SOF_CS42L42_DAILINK_MASK) >> SOF_CS42L42_DAILINK_SHIFT;\n\n\twhile (link_seq) {\n\t\tint link_type = link_seq & 0x07;\n\n\t\tswitch (link_type) {\n\t\tcase LINK_HP:\n\t\t\tret = create_hp_codec_dai_links(dev, links, cpus, &id, ssp_codec);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"fail to create hp codec dai links, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto devm_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LINK_SPK:\n\t\t\tret = create_spk_amp_dai_links(dev, links, cpus, &id, ssp_amp);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"fail to create spk amp dai links, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto devm_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LINK_DMIC:\n\t\t\tret = create_dmic_dai_links(dev, links, cpus, &id, dmic_be_num);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"fail to create dmic dai links, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto devm_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LINK_HDMI:\n\t\t\tret = create_hdmi_dai_links(dev, links, cpus, &id, hdmi_num);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"fail to create hdmi dai links, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto devm_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LINK_BT:\n\t\t\tret = create_bt_offload_dai_links(dev, links, cpus, &id, ssp_bt);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"fail to create bt offload dai links, ret %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto devm_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LINK_NONE:\n\t\t\t \n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid link type %d\\n\", link_type);\n\t\t\tgoto devm_err;\n\t\t}\n\n\t\tlink_seq >>= 3;\n\t}\n\n\treturn links;\ndevm_err:\n\treturn NULL;\n}\n\nstatic int sof_audio_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_dai_link *dai_links;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct sof_card_private *ctx;\n\tint dmic_be_num, hdmi_num;\n\tint ret, ssp_bt, ssp_amp, ssp_codec;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (pdev->id_entry && pdev->id_entry->driver_data)\n\t\tsof_cs42l42_quirk = (unsigned long)pdev->id_entry->driver_data;\n\n\tmach = pdev->dev.platform_data;\n\n\tif (soc_intel_is_glk()) {\n\t\tdmic_be_num = 1;\n\t\thdmi_num = 3;\n\t} else {\n\t\tdmic_be_num = 2;\n\t\thdmi_num = (sof_cs42l42_quirk & SOF_CS42L42_NUM_HDMIDEV_MASK) >>\n\t\t\t SOF_CS42L42_NUM_HDMIDEV_SHIFT;\n\t\t \n\t\tif (!hdmi_num)\n\t\t\thdmi_num = 3;\n\t}\n\n\tdev_dbg(&pdev->dev, \"sof_cs42l42_quirk = %lx\\n\", sof_cs42l42_quirk);\n\n\tssp_bt = (sof_cs42l42_quirk & SOF_CS42L42_SSP_BT_MASK) >>\n\t\t\tSOF_CS42L42_SSP_BT_SHIFT;\n\n\tssp_amp = (sof_cs42l42_quirk & SOF_CS42L42_SSP_AMP_MASK) >>\n\t\t\tSOF_CS42L42_SSP_AMP_SHIFT;\n\n\tssp_codec = sof_cs42l42_quirk & SOF_CS42L42_SSP_CODEC_MASK;\n\n\t \n\tsof_audio_card_cs42l42.num_links = 1 + dmic_be_num + hdmi_num;\n\n\tif (sof_cs42l42_quirk & SOF_SPEAKER_AMP_PRESENT)\n\t\tsof_audio_card_cs42l42.num_links++;\n\tif (sof_cs42l42_quirk & SOF_BT_OFFLOAD_PRESENT)\n\t\tsof_audio_card_cs42l42.num_links++;\n\n\tdai_links = sof_card_dai_links_create(&pdev->dev, ssp_codec, ssp_amp,\n\t\t\t\t\t      ssp_bt, dmic_be_num, hdmi_num);\n\tif (!dai_links)\n\t\treturn -ENOMEM;\n\n\tsof_audio_card_cs42l42.dai_link = dai_links;\n\n\tINIT_LIST_HEAD(&ctx->hdmi_pcm_list);\n\n\tsof_audio_card_cs42l42.dev = &pdev->dev;\n\n\t \n\tret = snd_soc_fixup_dai_links_platform_name(&sof_audio_card_cs42l42,\n\t\t\t\t\t\t    mach->mach_params.platform);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->common_hdmi_codec_drv = mach->mach_params.common_hdmi_codec_drv;\n\n\tsnd_soc_card_set_drvdata(&sof_audio_card_cs42l42, ctx);\n\n\treturn devm_snd_soc_register_card(&pdev->dev,\n\t\t\t\t\t  &sof_audio_card_cs42l42);\n}\n\nstatic const struct platform_device_id board_ids[] = {\n\t{\n\t\t.name = \"glk_cs4242_mx98357a\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_CS42L42_SSP_CODEC(2) |\n\t\t\t\t\tSOF_SPEAKER_AMP_PRESENT |\n\t\t\t\t\tSOF_MAX98357A_SPEAKER_AMP_PRESENT |\n\t\t\t\t\tSOF_CS42L42_SSP_AMP(1)) |\n\t\t\t\t\tSOF_CS42L42_DAILINK(LINK_SPK, LINK_HP, LINK_DMIC, LINK_HDMI, LINK_NONE),\n\t},\n\t{\n\t\t.name = \"jsl_cs4242_mx98360a\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_CS42L42_SSP_CODEC(0) |\n\t\t\t\t\tSOF_SPEAKER_AMP_PRESENT |\n\t\t\t\t\tSOF_MAX98360A_SPEAKER_AMP_PRESENT |\n\t\t\t\t\tSOF_CS42L42_SSP_AMP(1)) |\n\t\t\t\t\tSOF_CS42L42_DAILINK(LINK_HP, LINK_DMIC, LINK_HDMI, LINK_SPK, LINK_NONE),\n\t},\n\t{\n\t\t.name = \"adl_mx98360a_cs4242\",\n\t\t.driver_data = (kernel_ulong_t)(SOF_CS42L42_SSP_CODEC(0) |\n\t\t\t\tSOF_SPEAKER_AMP_PRESENT |\n\t\t\t\tSOF_MAX98360A_SPEAKER_AMP_PRESENT |\n\t\t\t\tSOF_CS42L42_SSP_AMP(1) |\n\t\t\t\tSOF_CS42L42_NUM_HDMIDEV(4) |\n\t\t\t\tSOF_BT_OFFLOAD_PRESENT |\n\t\t\t\tSOF_CS42L42_SSP_BT(2) |\n\t\t\t\tSOF_CS42L42_DAILINK(LINK_HP, LINK_DMIC, LINK_HDMI, LINK_SPK, LINK_BT)),\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, board_ids);\n\nstatic struct platform_driver sof_audio = {\n\t.probe = sof_audio_probe,\n\t.driver = {\n\t\t.name = \"sof_cs42l42\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.id_table = board_ids,\n};\nmodule_platform_driver(sof_audio)\n\n \nMODULE_DESCRIPTION(\"SOF Audio Machine driver for CS42L42\");\nMODULE_AUTHOR(\"Brent Lu <brent.lu@intel.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_INTEL_HDA_DSP_COMMON);\nMODULE_IMPORT_NS(SND_SOC_INTEL_SOF_MAXIM_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}