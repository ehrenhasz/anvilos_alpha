{
  "module_name": "sof_sdw_rt_amp.c",
  "hash_id": "b207cc7503249aa0aaff7dd35cadfe2296751d2e0879fa55054791b377f6006c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/sof_sdw_rt_amp.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <sound/control.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-dapm.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/dmi.h>\n#include \"sof_sdw_common.h\"\n#include \"sof_sdw_amp_coeff_tables.h\"\n#include \"../../codecs/rt1308.h\"\n\n#define CODEC_NAME_SIZE\t7\n\n \n#define RT_AMP_MAX_BQ_REG RT1316_MAX_BQ_REG\n\nstruct rt_amp_platform_data {\n\tconst unsigned char *bq_params;\n\tconst unsigned int bq_params_cnt;\n};\n\nstatic const struct rt_amp_platform_data dell_0a5d_platform_data = {\n\t.bq_params = dell_0a5d_bq_params,\n\t.bq_params_cnt = ARRAY_SIZE(dell_0a5d_bq_params),\n};\n\nstatic const struct rt_amp_platform_data dell_0b00_platform_data = {\n\t.bq_params = dell_0b00_bq_params,\n\t.bq_params_cnt = ARRAY_SIZE(dell_0b00_bq_params),\n};\n\nstatic const struct dmi_system_id dmi_platform_data[] = {\n\t \n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0990\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0a5d_platform_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"098F\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0a5d_platform_data,\n\t},\n\t \n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A5D\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0a5d_platform_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0A5E\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0a5d_platform_data,\n\t},\n\t \n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B00\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0b00_platform_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0B01\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0b00_platform_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AFF\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0b00_platform_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"0AFE\")\n\t\t},\n\t\t.driver_data = (void *)&dell_0b00_platform_data,\n\t},\n\t{},\n};\n\nstatic int rt_amp_add_device_props(struct device *sdw_dev)\n{\n\tstruct property_entry props[3] = {};\n\tstruct fwnode_handle *fwnode;\n\tconst struct dmi_system_id *dmi_data;\n\tconst struct rt_amp_platform_data *pdata;\n\tunsigned char params[RT_AMP_MAX_BQ_REG];\n\tint ret;\n\n\tdmi_data = dmi_first_match(dmi_platform_data);\n\tif (!dmi_data)\n\t\treturn 0;\n\n\tpdata = dmi_data->driver_data;\n\tmemcpy(&params, pdata->bq_params, sizeof(unsigned char) * pdata->bq_params_cnt);\n\n\tprops[0] = PROPERTY_ENTRY_U8_ARRAY(\"realtek,bq-params\", params);\n\tprops[1] = PROPERTY_ENTRY_U32(\"realtek,bq-params-cnt\", pdata->bq_params_cnt);\n\n\tfwnode = fwnode_create_software_node(props, NULL);\n\tif (IS_ERR(fwnode))\n\t\treturn PTR_ERR(fwnode);\n\n\tret = device_add_software_node(sdw_dev, to_software_node(fwnode));\n\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new rt_amp_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\"),\n};\n\nstatic const struct snd_soc_dapm_widget rt_amp_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n};\n\n \nstatic const struct snd_soc_dapm_route rt1308_map[] = {\n\t{ \"Speaker\", NULL, \"rt1308-1 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1308-1 SPOR\" },\n\t{ \"Speaker\", NULL, \"rt1308-2 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1308-2 SPOR\" },\n};\n\nstatic const struct snd_soc_dapm_route rt1316_map[] = {\n\t{ \"Speaker\", NULL, \"rt1316-1 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1316-1 SPOR\" },\n\t{ \"Speaker\", NULL, \"rt1316-2 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1316-2 SPOR\" },\n};\n\nstatic const struct snd_soc_dapm_route rt1318_map[] = {\n\t{ \"Speaker\", NULL, \"rt1318-1 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1318-1 SPOR\" },\n\t{ \"Speaker\", NULL, \"rt1318-2 SPOL\" },\n\t{ \"Speaker\", NULL, \"rt1318-2 SPOR\" },\n};\n\nstatic const struct snd_soc_dapm_route *get_codec_name_and_route(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t\t\t\t char *codec_name)\n{\n\tconst char *dai_name;\n\n\tdai_name = rtd->dai_link->codecs->dai_name;\n\n\t \n\tsnprintf(codec_name, CODEC_NAME_SIZE, \"%s\", dai_name);\n\n\t \n\tif (strcmp(codec_name, \"rt1308\") == 0)\n\t\treturn rt1308_map;\n\telse if (strcmp(codec_name, \"rt1316\") == 0)\n\t\treturn rt1316_map;\n\telse\n\t\treturn rt1318_map;\n}\n\nstatic int first_spk_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tconst struct snd_soc_dapm_route *rt_amp_map;\n\tchar codec_name[CODEC_NAME_SIZE];\n\tint ret;\n\n\trt_amp_map = get_codec_name_and_route(rtd, codec_name);\n\n\tcard->components = devm_kasprintf(card->dev, GFP_KERNEL,\n\t\t\t\t\t  \"%s spk:%s\",\n\t\t\t\t\t  card->components, codec_name);\n\tif (!card->components)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_add_card_controls(card, rt_amp_controls,\n\t\t\t\t\tARRAY_SIZE(rt_amp_controls));\n\tif (ret) {\n\t\tdev_err(card->dev, \"%s controls addition failed: %d\\n\", codec_name, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, rt_amp_widgets,\n\t\t\t\t\tARRAY_SIZE(rt_amp_widgets));\n\tif (ret) {\n\t\tdev_err(card->dev, \"%s widgets addition failed: %d\\n\", codec_name, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, rt_amp_map, 2);\n\tif (ret)\n\t\tdev_err(rtd->dev, \"failed to add first SPK map: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int second_spk_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tconst struct snd_soc_dapm_route *rt_amp_map;\n\tchar codec_name[CODEC_NAME_SIZE];\n\tint ret;\n\n\trt_amp_map = get_codec_name_and_route(rtd, codec_name);\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, rt_amp_map + 2, 2);\n\tif (ret)\n\t\tdev_err(rtd->dev, \"failed to add second SPK map: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int all_spk_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tint ret;\n\n\tret = first_spk_init(rtd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn second_spk_init(rtd);\n}\n\nstatic int rt1308_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint clk_id, clk_freq, pll_out;\n\tint err;\n\n\tclk_id = RT1308_PLL_S_MCLK;\n\tclk_freq = 38400000;\n\n\tpll_out = params_rate(params) * 512;\n\n\t \n\terr = snd_soc_dai_set_pll(codec_dai, 0, clk_id, clk_freq, pll_out);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Failed to set RT1308 PLL: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = snd_soc_dai_set_sysclk(codec_dai, RT1308_FS_SYS_S_PLL, pll_out,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Failed to set RT1308 SYSCLK: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstruct snd_soc_ops sof_sdw_rt1308_i2s_ops = {\n\t.hw_params = rt1308_i2s_hw_params,\n};\n\nint sof_sdw_rt_amp_exit(struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)\n{\n\tstruct mc_private *ctx = snd_soc_card_get_drvdata(card);\n\n\tif (ctx->amp_dev1) {\n\t\tdevice_remove_software_node(ctx->amp_dev1);\n\t\tput_device(ctx->amp_dev1);\n\t}\n\n\tif (ctx->amp_dev2) {\n\t\tdevice_remove_software_node(ctx->amp_dev2);\n\t\tput_device(ctx->amp_dev2);\n\t}\n\n\treturn 0;\n}\n\nint sof_sdw_rt_amp_init(struct snd_soc_card *card,\n\t\t\tconst struct snd_soc_acpi_link_adr *link,\n\t\t\tstruct snd_soc_dai_link *dai_links,\n\t\t\tstruct sof_sdw_codec_info *info,\n\t\t\tbool playback)\n{\n\tstruct mc_private *ctx = snd_soc_card_get_drvdata(card);\n\tstruct device *sdw_dev1, *sdw_dev2;\n\tint ret;\n\n\t \n\tif (!playback)\n\t\treturn 0;\n\n\tinfo->amp_num++;\n\tif (info->amp_num == 1)\n\t\tdai_links->init = first_spk_init;\n\n\tif (info->amp_num == 2) {\n\t\tsdw_dev1 = bus_find_device_by_name(&sdw_bus_type, NULL, dai_links->codecs[0].name);\n\t\tif (!sdw_dev1)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tret = rt_amp_add_device_props(sdw_dev1);\n\t\tif (ret < 0) {\n\t\t\tput_device(sdw_dev1);\n\t\t\treturn ret;\n\t\t}\n\t\tctx->amp_dev1 = sdw_dev1;\n\n\t\tsdw_dev2 = bus_find_device_by_name(&sdw_bus_type, NULL, dai_links->codecs[1].name);\n\t\tif (!sdw_dev2)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tret = rt_amp_add_device_props(sdw_dev2);\n\t\tif (ret < 0) {\n\t\t\tput_device(sdw_dev2);\n\t\t\treturn ret;\n\t\t}\n\t\tctx->amp_dev2 = sdw_dev2;\n\n\t\t \n\t\tif (dai_links->init)\n\t\t\tdai_links->init = all_spk_init;\n\t\telse\n\t\t\tdai_links->init = second_spk_init;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}