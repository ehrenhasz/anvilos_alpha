{
  "module_name": "skl_hda_dsp_generic.c",
  "hash_id": "490ed4c8737eef9f6e469a3223b5f0adcec9bb2169aa65f568678a63e32d7c42",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/skl_hda_dsp_generic.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include \"../../codecs/hdac_hdmi.h\"\n#include \"skl_hda_dsp_common.h\"\n\nstatic const struct snd_soc_dapm_widget skl_hda_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Analog Out\", NULL),\n\tSND_SOC_DAPM_MIC(\"Analog In\", NULL),\n\tSND_SOC_DAPM_HP(\"Alt Analog Out\", NULL),\n\tSND_SOC_DAPM_MIC(\"Alt Analog In\", NULL),\n\tSND_SOC_DAPM_SPK(\"Digital Out\", NULL),\n\tSND_SOC_DAPM_MIC(\"Digital In\", NULL),\n\tSND_SOC_DAPM_MIC(\"SoC DMIC\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route skl_hda_map[] = {\n\t{ \"hifi3\", NULL, \"iDisp3 Tx\"},\n\t{ \"iDisp3 Tx\", NULL, \"iDisp3_out\"},\n\t{ \"hifi2\", NULL, \"iDisp2 Tx\"},\n\t{ \"iDisp2 Tx\", NULL, \"iDisp2_out\"},\n\t{ \"hifi1\", NULL, \"iDisp1 Tx\"},\n\t{ \"iDisp1 Tx\", NULL, \"iDisp1_out\"},\n\n\t{ \"Analog Out\", NULL, \"Codec Output Pin1\" },\n\t{ \"Digital Out\", NULL, \"Codec Output Pin2\" },\n\t{ \"Alt Analog Out\", NULL, \"Codec Output Pin3\" },\n\n\t{ \"Codec Input Pin1\", NULL, \"Analog In\" },\n\t{ \"Codec Input Pin2\", NULL, \"Digital In\" },\n\t{ \"Codec Input Pin3\", NULL, \"Alt Analog In\" },\n\n\t \n\t{\"DMic\", NULL, \"SoC DMIC\"},\n\n\t \n\t{ \"Analog Codec Playback\", NULL, \"Analog CPU Playback\" },\n\t{ \"Analog CPU Playback\", NULL, \"codec0_out\" },\n\t{ \"Digital Codec Playback\", NULL, \"Digital CPU Playback\" },\n\t{ \"Digital CPU Playback\", NULL, \"codec1_out\" },\n\t{ \"Alt Analog Codec Playback\", NULL, \"Alt Analog CPU Playback\" },\n\t{ \"Alt Analog CPU Playback\", NULL, \"codec2_out\" },\n\n\t{ \"codec0_in\", NULL, \"Analog CPU Capture\" },\n\t{ \"Analog CPU Capture\", NULL, \"Analog Codec Capture\" },\n\t{ \"codec1_in\", NULL, \"Digital CPU Capture\" },\n\t{ \"Digital CPU Capture\", NULL, \"Digital Codec Capture\" },\n\t{ \"codec2_in\", NULL, \"Alt Analog CPU Capture\" },\n\t{ \"Alt Analog CPU Capture\", NULL, \"Alt Analog Codec Capture\" },\n};\n\nstatic int skl_hda_card_late_probe(struct snd_soc_card *card)\n{\n\treturn skl_hda_hdmi_jack_init(card);\n}\n\nstatic int\nskl_hda_add_dai_link(struct snd_soc_card *card, struct snd_soc_dai_link *link)\n{\n\tstruct skl_hda_private *ctx = snd_soc_card_get_drvdata(card);\n\tint ret = 0;\n\n\tdev_dbg(card->dev, \"dai link name - %s\\n\", link->name);\n\tlink->platforms->name = ctx->platform_name;\n\tlink->nonatomic = 1;\n\n\tif (!ctx->idisp_codec)\n\t\treturn 0;\n\n\tif (strstr(link->name, \"HDMI\")) {\n\t\tret = skl_hda_hdmi_add_pcm(card, ctx->pcm_count);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tctx->dai_index++;\n\t}\n\n\tctx->pcm_count++;\n\treturn ret;\n}\n\nstatic struct snd_soc_card hda_soc_card = {\n\t.name = \"hda-dsp\",\n\t.owner = THIS_MODULE,\n\t.dai_link = skl_hda_be_dai_links,\n\t.dapm_widgets = skl_hda_widgets,\n\t.dapm_routes = skl_hda_map,\n\t.add_dai_link = skl_hda_add_dai_link,\n\t.fully_routed = true,\n\t.late_probe = skl_hda_card_late_probe,\n};\n\nstatic char hda_soc_components[30];\n\n#define IDISP_DAI_COUNT\t\t3\n#define HDAC_DAI_COUNT\t\t2\n#define DMIC_DAI_COUNT\t\t2\n\n \n#define IDISP_ROUTE_COUNT\t(IDISP_DAI_COUNT * 2)\n#define IDISP_CODEC_MASK\t0x4\n\n#define HDA_CODEC_AUTOSUSPEND_DELAY_MS 1000\n\nstatic int skl_hda_fill_card_info(struct snd_soc_acpi_mach_params *mach_params)\n{\n\tstruct snd_soc_card *card = &hda_soc_card;\n\tstruct skl_hda_private *ctx = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *dai_link;\n\tu32 codec_count, codec_mask;\n\tint i, num_links, num_route;\n\n\tcodec_mask = mach_params->codec_mask;\n\tcodec_count = hweight_long(codec_mask);\n\tctx->idisp_codec = !!(codec_mask & IDISP_CODEC_MASK);\n\n\tif (!codec_count || codec_count > 2 ||\n\t    (codec_count == 2 && !ctx->idisp_codec))\n\t\treturn -EINVAL;\n\n\tif (codec_mask == IDISP_CODEC_MASK) {\n\t\t \n\t\tnum_links = IDISP_DAI_COUNT + DMIC_DAI_COUNT;\n\t\tnum_route = IDISP_ROUTE_COUNT;\n\n\t\t \n\t\tfor (i = 0; i < DMIC_DAI_COUNT; i++) {\n\t\t\tskl_hda_be_dai_links[IDISP_DAI_COUNT + i] =\n\t\t\t\tskl_hda_be_dai_links[IDISP_DAI_COUNT +\n\t\t\t\t\tHDAC_DAI_COUNT + i];\n\t\t}\n\t} else {\n\t\t \n\t\tnum_links = ARRAY_SIZE(skl_hda_be_dai_links);\n\t\tnum_route = ARRAY_SIZE(skl_hda_map);\n\t\tcard->dapm_widgets = skl_hda_widgets;\n\t\tcard->num_dapm_widgets = ARRAY_SIZE(skl_hda_widgets);\n\t\tif (!ctx->idisp_codec) {\n\t\t\tcard->dapm_routes = &skl_hda_map[IDISP_ROUTE_COUNT];\n\t\t\tnum_route -= IDISP_ROUTE_COUNT;\n\t\t\tfor (i = 0; i < IDISP_DAI_COUNT; i++) {\n\t\t\t\tskl_hda_be_dai_links[i].codecs = &asoc_dummy_dlc;\n\t\t\t\tskl_hda_be_dai_links[i].num_codecs = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcard->num_links = num_links;\n\tcard->num_dapm_routes = num_route;\n\n\tfor_each_card_prelinks(card, i, dai_link)\n\t\tdai_link->platforms->name = mach_params->platform;\n\n\treturn 0;\n}\n\nstatic void skl_set_hda_codec_autosuspend_delay(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct snd_soc_dai *dai;\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tif (!strstr(rtd->dai_link->codecs->name, \"ehdaudio0D0\"))\n\t\t\tcontinue;\n\t\tdai = asoc_rtd_to_codec(rtd, 0);\n\t\thda_pvt = snd_soc_component_get_drvdata(dai->component);\n\t\tif (hda_pvt) {\n\t\t\t \n\t\t\tsnd_hda_set_power_save(hda_pvt->codec->bus,\n\t\t\t\t\t       HDA_CODEC_AUTOSUSPEND_DELAY_MS);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int skl_hda_audio_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct skl_hda_private *ctx;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"entry\\n\");\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ctx->hdmi_pcm_list);\n\n\tmach = pdev->dev.platform_data;\n\tif (!mach)\n\t\treturn -EINVAL;\n\n\tsnd_soc_card_set_drvdata(&hda_soc_card, ctx);\n\n\tret = skl_hda_fill_card_info(&mach->mach_params);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unsupported HDAudio/iDisp configuration found\\n\");\n\t\treturn ret;\n\t}\n\n\tctx->pcm_count = hda_soc_card.num_links;\n\tctx->dai_index = 1;  \n\tctx->platform_name = mach->mach_params.platform;\n\tctx->common_hdmi_codec_drv = mach->mach_params.common_hdmi_codec_drv;\n\n\thda_soc_card.dev = &pdev->dev;\n\n\tif (mach->mach_params.dmic_num > 0) {\n\t\tsnprintf(hda_soc_components, sizeof(hda_soc_components),\n\t\t\t\t\"cfg-dmics:%d\", mach->mach_params.dmic_num);\n\t\thda_soc_card.components = hda_soc_components;\n\t}\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &hda_soc_card);\n\tif (!ret)\n\t\tskl_set_hda_codec_autosuspend_delay(&hda_soc_card);\n\n\treturn ret;\n}\n\nstatic struct platform_driver skl_hda_audio = {\n\t.probe = skl_hda_audio_probe,\n\t.driver = {\n\t\t.name = \"skl_hda_dsp_generic\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(skl_hda_audio)\n\n \nMODULE_DESCRIPTION(\"SKL/KBL/BXT/APL HDA Generic Machine driver\");\nMODULE_AUTHOR(\"Rakesh Ughreja <rakesh.a.ughreja@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:skl_hda_dsp_generic\");\nMODULE_IMPORT_NS(SND_SOC_INTEL_HDA_DSP_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}