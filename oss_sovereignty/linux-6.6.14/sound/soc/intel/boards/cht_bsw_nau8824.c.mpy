{
  "module_name": "cht_bsw_nau8824.c",
  "hash_id": "561f04d8dbd2667e322f5ae88cd1c6c1ad38771e206e2fca0b00f3a33ac81d01",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/intel/boards/cht_bsw_nau8824.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include <sound/jack.h>\n#include <linux/input.h>\n#include \"../atom/sst-atom-controls.h\"\n#include \"../../codecs/nau8824.h\"\n\nstruct cht_mc_private {\n\tstruct snd_soc_jack jack;\n};\n\nstatic struct snd_soc_jack_pin cht_bsw_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic const struct snd_soc_dapm_widget cht_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Int Mic\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route cht_audio_map[] = {\n\t{\"Ext Spk\", NULL, \"SPKOUTL\"},\n\t{\"Ext Spk\", NULL, \"SPKOUTR\"},\n\t{\"Headphone\", NULL, \"HPOL\"},\n\t{\"Headphone\", NULL, \"HPOR\"},\n\t{\"MIC1\", NULL, \"Int Mic\"},\n\t{\"MIC2\", NULL, \"Int Mic\"},\n\t{\"HSMIC1\", NULL, \"Headset Mic\"},\n\t{\"HSMIC2\", NULL, \"Headset Mic\"},\n\t{\"Playback\", NULL, \"ssp2 Tx\"},\n\t{\"ssp2 Tx\", NULL, \"codec_out0\"},\n\t{\"ssp2 Tx\", NULL, \"codec_out1\"},\n\t{\"codec_in0\", NULL, \"ssp2 Rx\" },\n\t{\"codec_in1\", NULL, \"ssp2 Rx\" },\n\t{\"ssp2 Rx\", NULL, \"Capture\"},\n};\n\nstatic const struct snd_kcontrol_new cht_mc_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Int Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Ext Spk\"),\n};\n\nstatic int cht_aif1_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, NAU8824_CLK_FLL_FS, 0,\n\t\tSND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(codec_dai->dev, \"can't set FS clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_dai_set_pll(codec_dai, 0, 0, params_rate(params),\n\t\tparams_rate(params) * 256);\n\tif (ret < 0) {\n\t\tdev_err(codec_dai->dev, \"can't set FLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cht_codec_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);\n\tstruct snd_soc_jack *jack = &ctx->jack;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(runtime, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret, jack_type;\n\n\t \n\tjack_type = SND_JACK_HEADSET | SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3;\n\tret = snd_soc_card_jack_new_pins(runtime->card, \"Headset\", jack_type,\n\t\tjack, cht_bsw_jack_pins, ARRAY_SIZE(cht_bsw_jack_pins));\n\tif (ret) {\n\t\tdev_err(runtime->dev,\n\t\t\t\"Headset Jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tnau8824_enable_jack_detect(component, jack);\n\n\treturn ret;\n}\n\nstatic int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *fmt =\n\t\thw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tint ret;\n\n\t \n\trate->min = rate->max = 48000;\n\tchannels->min = channels->max = 2;\n\n\t \n\tsnd_mask_none(fmt);\n\tparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\n\n\t \n\tret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_codec(rtd, 0), 0xf, 0x1, 4, 24);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set codec TDM slot %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cht_aif1_startup(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_hw_constraint_single(substream->runtime,\n\t\tSNDRV_PCM_HW_PARAM_RATE, 48000);\n}\n\nstatic const struct snd_soc_ops cht_aif1_ops = {\n\t.startup = cht_aif1_startup,\n};\n\nstatic const struct snd_soc_ops cht_be_ssp2_ops = {\n\t.hw_params = cht_aif1_hw_params,\n};\n\nSND_SOC_DAILINK_DEF(dummy,\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nSND_SOC_DAILINK_DEF(media,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"media-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(deepbuffer,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"deepbuffer-cpu-dai\")));\n\nSND_SOC_DAILINK_DEF(ssp2_port,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"ssp2-port\")));\nSND_SOC_DAILINK_DEF(ssp2_codec,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-10508824:00\",\n\t\t\t\t      NAU8824_CODEC_DAI)));\n\nSND_SOC_DAILINK_DEF(platform,\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"sst-mfld-platform\")));\n\nstatic struct snd_soc_dai_link cht_dailink[] = {\n\t \n\t[MERR_DPCM_AUDIO] = {\n\t\t.name = \"Audio Port\",\n\t\t.stream_name = \"Audio\",\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.ops = &cht_aif1_ops,\n\t\tSND_SOC_DAILINK_REG(media, dummy, platform),\n\t},\n\t[MERR_DPCM_DEEP_BUFFER] = {\n\t\t.name = \"Deep-Buffer Audio Port\",\n\t\t.stream_name = \"Deep-Buffer Audio\",\n\t\t.nonatomic = true,\n\t\t.dynamic = 1,\n\t\t.dpcm_playback = 1,\n\t\t.ops = &cht_aif1_ops,\n\t\tSND_SOC_DAILINK_REG(deepbuffer, dummy, platform),\n\t},\n\t \n\t{\n\t\t \n\t\t.name = \"SSP2-Codec\",\n\t\t.id = 0,\n\t\t.no_pcm = 1,\n\t\t.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF\n\t\t\t| SND_SOC_DAIFMT_CBC_CFC,\n\t\t.init = cht_codec_init,\n\t\t.be_hw_params_fixup = cht_codec_fixup,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.ops = &cht_be_ssp2_ops,\n\t\tSND_SOC_DAILINK_REG(ssp2_port, ssp2_codec, platform),\n\t},\n};\n\n \n#define SOF_CARD_NAME \"bytcht nau8824\"  \n#define SOF_DRIVER_NAME \"SOF\"\n\n#define CARD_NAME \"chtnau8824\"\n#define DRIVER_NAME NULL  \n\n \nstatic struct snd_soc_card snd_soc_card_cht = {\n\t.owner = THIS_MODULE,\n\t.dai_link = cht_dailink,\n\t.num_links = ARRAY_SIZE(cht_dailink),\n\t.dapm_widgets = cht_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(cht_dapm_widgets),\n\t.dapm_routes = cht_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(cht_audio_map),\n\t.controls = cht_mc_controls,\n\t.num_controls = ARRAY_SIZE(cht_mc_controls),\n};\n\nstatic int snd_cht_mc_probe(struct platform_device *pdev)\n{\n\tstruct cht_mc_private *drv;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tbool sof_parent;\n\tint ret_val;\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\tsnd_soc_card_set_drvdata(&snd_soc_card_cht, drv);\n\n\t \n\tsnd_soc_card_cht.dev = &pdev->dev;\n\tmach = pdev->dev.platform_data;\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(&snd_soc_card_cht,\n\t\t\t\t\t\t\tplatform_name);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tsof_parent = snd_soc_acpi_sof_parent(&pdev->dev);\n\n\t \n\tif (sof_parent) {\n\t\tsnd_soc_card_cht.name = SOF_CARD_NAME;\n\t\tsnd_soc_card_cht.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tsnd_soc_card_cht.name = CARD_NAME;\n\t\tsnd_soc_card_cht.driver_name = DRIVER_NAME;\n\t}\n\n\tsnd_soc_card_cht.components = nau8824_components();\n\n\t \n\tif (sof_parent)\n\t\tpdev->dev.driver->pm = &snd_soc_pm_ops;\n\n\t \n\tret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cht);\n\tif (ret_val) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"snd_soc_register_card failed %d\\n\", ret_val);\n\t\treturn ret_val;\n\t}\n\tplatform_set_drvdata(pdev, &snd_soc_card_cht);\n\n\treturn ret_val;\n}\n\nstatic struct platform_driver snd_cht_mc_driver = {\n\t.driver = {\n\t\t.name = \"cht-bsw-nau8824\",\n\t},\n\t.probe = snd_cht_mc_probe,\n};\n\nmodule_platform_driver(snd_cht_mc_driver);\n\nMODULE_DESCRIPTION(\"ASoC Intel(R) Baytrail CR Machine driver\");\nMODULE_AUTHOR(\"Wang, Joseph C <joequant@gmail.com>\");\nMODULE_AUTHOR(\"John Hsu <KCHSU0@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:cht-bsw-nau8824\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}