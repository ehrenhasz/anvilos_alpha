{
  "module_name": "mchp-i2s-mcc.c",
  "hash_id": "8aa1248d29421adcb09a74167a61e370da6832cda62e00034176a79df1f2cc5e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/mchp-i2s-mcc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/lcm.h>\n#include <linux/of_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n \n#define MCHP_I2SMCC_CR\t\t0x0000\t \n#define MCHP_I2SMCC_MRA\t\t0x0004\t \n#define MCHP_I2SMCC_MRB\t\t0x0008\t \n#define MCHP_I2SMCC_SR\t\t0x000C\t \n#define MCHP_I2SMCC_IERA\t0x0010\t \n#define MCHP_I2SMCC_IDRA\t0x0014\t \n#define MCHP_I2SMCC_IMRA\t0x0018\t \n#define MCHP_I2SMCC_ISRA\t0X001C\t \n\n#define MCHP_I2SMCC_IERB\t0x0020\t \n#define MCHP_I2SMCC_IDRB\t0x0024\t \n#define MCHP_I2SMCC_IMRB\t0x0028\t \n#define MCHP_I2SMCC_ISRB\t0X002C\t \n\n#define MCHP_I2SMCC_RHR\t\t0x0030\t \n#define MCHP_I2SMCC_THR\t\t0x0034\t \n\n#define MCHP_I2SMCC_RHL0R\t0x0040\t \n#define MCHP_I2SMCC_RHR0R\t0x0044\t \n\n#define MCHP_I2SMCC_RHL1R\t0x0048\t \n#define MCHP_I2SMCC_RHR1R\t0x004C\t \n\n#define MCHP_I2SMCC_RHL2R\t0x0050\t \n#define MCHP_I2SMCC_RHR2R\t0x0054\t \n\n#define MCHP_I2SMCC_RHL3R\t0x0058\t \n#define MCHP_I2SMCC_RHR3R\t0x005C\t \n\n#define MCHP_I2SMCC_THL0R\t0x0060\t \n#define MCHP_I2SMCC_THR0R\t0x0064\t \n\n#define MCHP_I2SMCC_THL1R\t0x0068\t \n#define MCHP_I2SMCC_THR1R\t0x006C\t \n\n#define MCHP_I2SMCC_THL2R\t0x0070\t \n#define MCHP_I2SMCC_THR2R\t0x0074\t \n\n#define MCHP_I2SMCC_THL3R\t0x0078\t \n#define MCHP_I2SMCC_THR3R\t0x007C\t \n\n#define MCHP_I2SMCC_VERSION\t0x00FC\t \n\n \n#define MCHP_I2SMCC_CR_RXEN\t\tBIT(0)\t \n#define MCHP_I2SMCC_CR_RXDIS\t\tBIT(1)\t \n#define MCHP_I2SMCC_CR_CKEN\t\tBIT(2)\t \n#define MCHP_I2SMCC_CR_CKDIS\t\tBIT(3)\t \n#define MCHP_I2SMCC_CR_TXEN\t\tBIT(4)\t \n#define MCHP_I2SMCC_CR_TXDIS\t\tBIT(5)\t \n#define MCHP_I2SMCC_CR_SWRST\t\tBIT(7)\t \n\n \n#define MCHP_I2SMCC_MRA_MODE_MASK\t\tGENMASK(0, 0)\n#define MCHP_I2SMCC_MRA_MODE_SLAVE\t\t(0 << 0)\n#define MCHP_I2SMCC_MRA_MODE_MASTER\t\t(1 << 0)\n\n#define MCHP_I2SMCC_MRA_DATALENGTH_MASK\t\t\tGENMASK(3, 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_32_BITS\t\t(0 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_24_BITS\t\t(1 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_20_BITS\t\t(2 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_18_BITS\t\t(3 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_16_BITS\t\t(4 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_16_BITS_COMPACT\t(5 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_8_BITS\t\t(6 << 1)\n#define MCHP_I2SMCC_MRA_DATALENGTH_8_BITS_COMPACT\t(7 << 1)\n\n#define MCHP_I2SMCC_MRA_WIRECFG_MASK\t\tGENMASK(5, 4)\n#define MCHP_I2SMCC_MRA_WIRECFG_TDM(pin)\t(((pin) << 4) & \\\n\t\t\t\t\t\t MCHP_I2SMCC_MRA_WIRECFG_MASK)\n#define MCHP_I2SMCC_MRA_WIRECFG_I2S_1_TDM_0\t(0 << 4)\n#define MCHP_I2SMCC_MRA_WIRECFG_I2S_2_TDM_1\t(1 << 4)\n#define MCHP_I2SMCC_MRA_WIRECFG_I2S_4_TDM_2\t(2 << 4)\n#define MCHP_I2SMCC_MRA_WIRECFG_TDM_3\t\t(3 << 4)\n\n#define MCHP_I2SMCC_MRA_FORMAT_MASK\t\tGENMASK(7, 6)\n#define MCHP_I2SMCC_MRA_FORMAT_I2S\t\t(0 << 6)\n#define MCHP_I2SMCC_MRA_FORMAT_LJ\t\t(1 << 6)  \n#define MCHP_I2SMCC_MRA_FORMAT_TDM\t\t(2 << 6)\n#define MCHP_I2SMCC_MRA_FORMAT_TDMLJ\t\t(3 << 6)\n\n \n \n#define MCHP_I2SMCC_MRA_RXMONO\t\t\tBIT(8)\n\n \n#define MCHP_I2SMCC_MRA_RXLOOP\t\t\tBIT(9)\n\n \n \n#define MCHP_I2SMCC_MRA_TXMONO\t\t\tBIT(10)\n\n \n#define MCHP_I2SMCC_MRA_TXSAME_ZERO\t\t(0 << 11)  \n#define MCHP_I2SMCC_MRA_TXSAME_PREVIOUS\t\t(1 << 11)  \n\n \n#define MCHP_I2SMCC_MRA_SRCCLK_PCLK\t\t(0 << 12)\n#define MCHP_I2SMCC_MRA_SRCCLK_GCLK\t\t(1 << 12)\n\n \n#define MCHP_I2SMCC_MRA_NBCHAN_MASK\t\tGENMASK(15, 13)\n#define MCHP_I2SMCC_MRA_NBCHAN(ch) \\\n\t((((ch) - 1) << 13) & MCHP_I2SMCC_MRA_NBCHAN_MASK)\n\n \n#define MCHP_I2SMCC_MRA_IMCKDIV_MASK\t\tGENMASK(21, 16)\n#define MCHP_I2SMCC_MRA_IMCKDIV(div) \\\n\t(((div) << 16) & MCHP_I2SMCC_MRA_IMCKDIV_MASK)\n\n \n#define MCHP_I2SMCC_MRA_TDMFS_MASK\t\tGENMASK(23, 22)\n#define MCHP_I2SMCC_MRA_TDMFS_SLOT\t\t(0 << 22)\n#define MCHP_I2SMCC_MRA_TDMFS_HALF\t\t(1 << 22)\n#define MCHP_I2SMCC_MRA_TDMFS_BIT\t\t(2 << 22)\n\n \n#define MCHP_I2SMCC_MRA_ISCKDIV_MASK\t\tGENMASK(29, 24)\n#define MCHP_I2SMCC_MRA_ISCKDIV(div) \\\n\t(((div) << 24) & MCHP_I2SMCC_MRA_ISCKDIV_MASK)\n\n \n#define MCHP_I2SMCC_MRA_IMCKMODE_MASK\t\tGENMASK(30, 30)\n \n#define MCHP_I2SMCC_MRA_IMCKMODE_NONE\t\t(0 << 30)\n \n#define MCHP_I2SMCC_MRA_IMCKMODE_GEN\t\t(1 << 30)\n\n \n \n \n#define MCHP_I2SMCC_MRA_IWS\t\t\tBIT(31)\n\n \n \n#define MCHP_I2SMCC_MRB_CRAMODE_LEFT_FIRST\t(0 << 0)\n \n#define MCHP_I2SMCC_MRB_CRAMODE_REGULAR\t\t(1 << 0)\n\n#define MCHP_I2SMCC_MRB_FIFOEN\t\t\tBIT(4)\n\n#define MCHP_I2SMCC_MRB_DMACHUNK_MASK\t\tGENMASK(9, 8)\n#define MCHP_I2SMCC_MRB_DMACHUNK(no_words) \\\n\t(((fls(no_words) - 1) << 8) & MCHP_I2SMCC_MRB_DMACHUNK_MASK)\n\n#define MCHP_I2SMCC_MRB_CLKSEL_MASK\t\tGENMASK(16, 16)\n#define MCHP_I2SMCC_MRB_CLKSEL_EXT\t\t(0 << 16)\n#define MCHP_I2SMCC_MRB_CLKSEL_INT\t\t(1 << 16)\n\n \n#define MCHP_I2SMCC_SR_RXEN\t\tBIT(0)\t \n#define MCHP_I2SMCC_SR_TXEN\t\tBIT(4)\t \n\n \n#define MCHP_I2SMCC_INT_TXRDY_MASK(ch)\t\tGENMASK((ch) - 1, 0)\n#define MCHP_I2SMCC_INT_TXRDYCH(ch)\t\tBIT(ch)\n#define MCHP_I2SMCC_INT_TXUNF_MASK(ch)\t\tGENMASK((ch) + 7, 8)\n#define MCHP_I2SMCC_INT_TXUNFCH(ch)\t\tBIT((ch) + 8)\n#define MCHP_I2SMCC_INT_RXRDY_MASK(ch)\t\tGENMASK((ch) + 15, 16)\n#define MCHP_I2SMCC_INT_RXRDYCH(ch)\t\tBIT((ch) + 16)\n#define MCHP_I2SMCC_INT_RXOVF_MASK(ch)\t\tGENMASK((ch) + 23, 24)\n#define MCHP_I2SMCC_INT_RXOVFCH(ch)\t\tBIT((ch) + 24)\n\n \n#define MCHP_I2SMCC_INT_WERR\t\t\tBIT(0)\n#define MCHP_I2SMCC_INT_TXFFRDY\t\t\tBIT(8)\n#define MCHP_I2SMCC_INT_TXFFEMP\t\t\tBIT(9)\n#define MCHP_I2SMCC_INT_RXFFRDY\t\t\tBIT(12)\n#define MCHP_I2SMCC_INT_RXFFFUL\t\t\tBIT(13)\n\n \n#define MCHP_I2SMCC_VERSION_MASK\t\tGENMASK(11, 0)\n\n#define MCHP_I2SMCC_MAX_CHANNELS\t\t8\n#define MCHP_I2MCC_TDM_SLOT_WIDTH\t\t32\n\nstatic const struct regmap_config mchp_i2s_mcc_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = MCHP_I2SMCC_VERSION,\n};\n\nstruct mchp_i2s_mcc_soc_data {\n\tunsigned int\tdata_pin_pair_num;\n\tbool\t\thas_fifo;\n};\n\nstruct mchp_i2s_mcc_dev {\n\tstruct wait_queue_head\t\t\twq_txrdy;\n\tstruct wait_queue_head\t\t\twq_rxrdy;\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct clk\t\t\t\t*pclk;\n\tstruct clk\t\t\t\t*gclk;\n\tconst struct mchp_i2s_mcc_soc_data\t*soc;\n\tstruct snd_dmaengine_dai_dma_data\tplayback;\n\tstruct snd_dmaengine_dai_dma_data\tcapture;\n\tunsigned int\t\t\t\tfmt;\n\tunsigned int\t\t\t\tsysclk;\n\tunsigned int\t\t\t\tframe_length;\n\tint\t\t\t\t\ttdm_slots;\n\tint\t\t\t\t\tchannels;\n\tu8\t\t\t\t\ttdm_data_pair;\n\tunsigned int\t\t\t\tgclk_use:1;\n\tunsigned int\t\t\t\tgclk_running:1;\n\tunsigned int\t\t\t\ttx_rdy:1;\n\tunsigned int\t\t\t\trx_rdy:1;\n};\n\nstatic irqreturn_t mchp_i2s_mcc_interrupt(int irq, void *dev_id)\n{\n\tstruct mchp_i2s_mcc_dev *dev = dev_id;\n\tu32 sra, imra, srb, imrb, pendinga, pendingb, idra = 0, idrb = 0;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(dev->regmap, MCHP_I2SMCC_IMRA, &imra);\n\tregmap_read(dev->regmap, MCHP_I2SMCC_ISRA, &sra);\n\tpendinga = imra & sra;\n\n\tregmap_read(dev->regmap, MCHP_I2SMCC_IMRB, &imrb);\n\tregmap_read(dev->regmap, MCHP_I2SMCC_ISRB, &srb);\n\tpendingb = imrb & srb;\n\n\tif (!pendinga && !pendingb)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (dev->soc->has_fifo) {\n\t\tidrb |= pendingb & (MCHP_I2SMCC_INT_TXFFRDY |\n\t\t\t\t    MCHP_I2SMCC_INT_RXFFRDY);\n\t} else {\n\t\tidra |= pendinga & (MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels) |\n\t\t\t\t    MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels));\n\t}\n\tif (idra || idrb)\n\t\tret = IRQ_HANDLED;\n\n\tif ((!dev->soc->has_fifo &&\n\t     (imra & MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels)) &&\n\t     (imra & MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels)) ==\n\t     (idra & MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels))) ||\n\t    (dev->soc->has_fifo && imrb & MCHP_I2SMCC_INT_TXFFRDY)) {\n\t\tdev->tx_rdy = 1;\n\t\twake_up_interruptible(&dev->wq_txrdy);\n\t}\n\tif ((!dev->soc->has_fifo &&\n\t     (imra & MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels)) &&\n\t     (imra & MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels)) ==\n\t     (idra & MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels))) ||\n\t    (dev->soc->has_fifo && imrb & MCHP_I2SMCC_INT_RXFFRDY)) {\n\t\tdev->rx_rdy = 1;\n\t\twake_up_interruptible(&dev->wq_rxrdy);\n\t}\n\tif (dev->soc->has_fifo)\n\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRB, idrb);\n\telse\n\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRA, idra);\n\n\treturn ret;\n}\n\nstatic int mchp_i2s_mcc_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t   int clk_id, unsigned int freq, int dir)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(dev->dev, \"%s() clk_id=%d freq=%u dir=%d\\n\",\n\t\t__func__, clk_id, freq, dir);\n\n\t \n\tif (dir == SND_SOC_CLOCK_IN)\n\t\treturn 0;\n\n\tdev->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_set_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t       unsigned int ratio)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(dev->dev, \"%s() ratio=%u\\n\", __func__, ratio);\n\n\tdev->frame_length = ratio;\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(dev->dev, \"%s() fmt=%#x\\n\", __func__, fmt);\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\n\t\treturn -EINVAL;\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) == SND_SOC_DAIFMT_BC_FP)\n\t\treturn -EINVAL;\n\n\t \n\tif (fmt & SND_SOC_DAIFMT_CONT)\n\t\treturn -EINVAL;\n\n\tdev->fmt = fmt;\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t\t unsigned int tx_mask,\n\t\t\t\t\t unsigned int rx_mask,\n\t\t\t\t\t int slots, int slot_width)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(dev->dev,\n\t\t\"%s() tx_mask=0x%08x rx_mask=0x%08x slots=%d width=%d\\n\",\n\t\t__func__, tx_mask, rx_mask, slots, slot_width);\n\n\tif (slots < 0 || slots > MCHP_I2SMCC_MAX_CHANNELS ||\n\t    slot_width != MCHP_I2MCC_TDM_SLOT_WIDTH)\n\t\treturn -EINVAL;\n\n\tif (slots) {\n\t\t \n\t\tif (rx_mask != GENMASK(slots - 1, 0) ||\n\t\t    rx_mask != tx_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->tdm_slots = slots;\n\tdev->frame_length = slots * MCHP_I2MCC_TDM_SLOT_WIDTH;\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_clk_get_rate_diff(struct clk *clk,\n\t\t\t\t\t  unsigned long rate,\n\t\t\t\t\t  struct clk **best_clk,\n\t\t\t\t\t  unsigned long *best_rate,\n\t\t\t\t\t  unsigned long *best_diff_rate)\n{\n\tlong round_rate;\n\tunsigned int diff_rate;\n\n\tround_rate = clk_round_rate(clk, rate);\n\tif (round_rate < 0)\n\t\treturn (int)round_rate;\n\n\tdiff_rate = abs(rate - round_rate);\n\tif (diff_rate < *best_diff_rate) {\n\t\t*best_clk = clk;\n\t\t*best_diff_rate = diff_rate;\n\t\t*best_rate = rate;\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_config_divs(struct mchp_i2s_mcc_dev *dev,\n\t\t\t\t    unsigned int bclk, unsigned int *mra,\n\t\t\t\t    unsigned long *best_rate)\n{\n\tunsigned long clk_rate;\n\tunsigned long lcm_rate;\n\tunsigned long best_diff_rate = ~0;\n\tunsigned int sysclk;\n\tstruct clk *best_clk = NULL;\n\tint ret;\n\n\t \n\tif (!dev->sysclk)\n\t\tsysclk = bclk;\n\telse\n\t\tsysclk = dev->sysclk;\n\n\t \n\tlcm_rate = lcm(sysclk, bclk);\n\tif ((lcm_rate / sysclk % 2 == 1 && lcm_rate / sysclk > 2) ||\n\t    (lcm_rate / bclk % 2 == 1 && lcm_rate / bclk > 2))\n\t\tlcm_rate *= 2;\n\n\tfor (clk_rate = lcm_rate;\n\t     (clk_rate == sysclk || clk_rate / (sysclk * 2) <= GENMASK(5, 0)) &&\n\t     (clk_rate == bclk || clk_rate / (bclk * 2) <= GENMASK(5, 0));\n\t     clk_rate += lcm_rate) {\n\t\tret = mchp_i2s_mcc_clk_get_rate_diff(dev->gclk, clk_rate,\n\t\t\t\t\t\t     &best_clk, best_rate,\n\t\t\t\t\t\t     &best_diff_rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"gclk error for rate %lu: %d\",\n\t\t\t\tclk_rate, ret);\n\t\t} else {\n\t\t\tif (!best_diff_rate) {\n\t\t\t\tdev_dbg(dev->dev, \"found perfect rate on gclk: %lu\\n\",\n\t\t\t\t\tclk_rate);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret = mchp_i2s_mcc_clk_get_rate_diff(dev->pclk, clk_rate,\n\t\t\t\t\t\t     &best_clk, best_rate,\n\t\t\t\t\t\t     &best_diff_rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"pclk error for rate %lu: %d\",\n\t\t\t\tclk_rate, ret);\n\t\t} else {\n\t\t\tif (!best_diff_rate) {\n\t\t\t\tdev_dbg(dev->dev, \"found perfect rate on pclk: %lu\\n\",\n\t\t\t\t\tclk_rate);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!best_clk) {\n\t\tdev_err(dev->dev, \"unable to change rate to clocks\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev->dev, \"source CLK is %s with rate %lu, diff %lu\\n\",\n\t\tbest_clk == dev->pclk ? \"pclk\" : \"gclk\",\n\t\t*best_rate, best_diff_rate);\n\n\t \n\tif (dev->sysclk)\n\t\t*mra |= MCHP_I2SMCC_MRA_IMCKDIV(*best_rate / (2 * sysclk));\n\t*mra |= MCHP_I2SMCC_MRA_ISCKDIV(*best_rate / (2 * bclk));\n\n\tif (best_clk == dev->gclk)\n\t\t*mra |= MCHP_I2SMCC_MRA_SRCCLK_GCLK;\n\telse\n\t\t*mra |= MCHP_I2SMCC_MRA_SRCCLK_PCLK;\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_is_running(struct mchp_i2s_mcc_dev *dev)\n{\n\tu32 sr;\n\n\tregmap_read(dev->regmap, MCHP_I2SMCC_SR, &sr);\n\treturn !!(sr & (MCHP_I2SMCC_SR_TXEN | MCHP_I2SMCC_SR_RXEN));\n}\n\nstatic int mchp_i2s_mcc_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tunsigned long rate = 0;\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tu32 mra = 0;\n\tu32 mrb = 0;\n\tunsigned int channels = params_channels(params);\n\tunsigned int frame_length = dev->frame_length;\n\tunsigned int bclk_rate;\n\tint set_divs = 0;\n\tint ret;\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tdev_dbg(dev->dev, \"%s() rate=%u format=%#x width=%u channels=%u\\n\",\n\t\t__func__, params_rate(params), params_format(params),\n\t\tparams_width(params), params_channels(params));\n\n\tswitch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tif (dev->tdm_slots) {\n\t\t\tdev_err(dev->dev, \"I2S with TDM is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmra |= MCHP_I2SMCC_MRA_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tif (dev->tdm_slots) {\n\t\t\tdev_err(dev->dev, \"Left-Justified with TDM is not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmra |= MCHP_I2SMCC_MRA_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tmra |= MCHP_I2SMCC_MRA_FORMAT_TDM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported bus format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tmra |= MCHP_I2SMCC_MRA_MODE_MASTER;\n\t\tif (dev->sysclk)\n\t\t\tmra |= MCHP_I2SMCC_MRA_IMCKMODE_GEN;\n\t\tset_divs = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\t \n\t\tmrb |= MCHP_I2SMCC_MRB_CLKSEL_INT;\n\t\tset_divs = 1;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tmra |= MCHP_I2SMCC_MRA_MODE_SLAVE;\n\t\tif (dev->sysclk)\n\t\t\tdev_warn(dev->dev, \"Unable to generate MCLK in Slave mode\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported master/slave mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->fmt & (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J)) {\n\t\t \n\t\tif (channels > dev->soc->data_pin_pair_num * 2) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unsupported number of audio channels: %d\\n\",\n\t\t\t\tchannels);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tmrb |= MCHP_I2SMCC_MRB_CRAMODE_REGULAR;\n\n\t\tswitch (channels) {\n\t\tcase 1:\n\t\t\tif (is_playback)\n\t\t\t\tmra |= MCHP_I2SMCC_MRA_TXMONO;\n\t\t\telse\n\t\t\t\tmra |= MCHP_I2SMCC_MRA_RXMONO;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmra |= MCHP_I2SMCC_MRA_WIRECFG_I2S_2_TDM_1;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmra |= MCHP_I2SMCC_MRA_WIRECFG_I2S_4_TDM_2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev, \"unsupported number of audio channels\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!frame_length)\n\t\t\tframe_length = 2 * params_physical_width(params);\n\t} else if (dev->fmt & SND_SOC_DAIFMT_DSP_A) {\n\t\tmra |= MCHP_I2SMCC_MRA_WIRECFG_TDM(dev->tdm_data_pair);\n\n\t\tif (dev->tdm_slots) {\n\t\t\tif (channels % 2 && channels * 2 <= dev->tdm_slots) {\n\t\t\t\t \n\t\t\t\tif (is_playback)\n\t\t\t\t\tmra |= MCHP_I2SMCC_MRA_TXMONO;\n\t\t\t\telse\n\t\t\t\t\tmra |= MCHP_I2SMCC_MRA_RXMONO;\n\t\t\t}\n\t\t\tchannels = dev->tdm_slots;\n\t\t}\n\n\t\tmra |= MCHP_I2SMCC_MRA_NBCHAN(channels);\n\t\tif (!frame_length)\n\t\t\tframe_length = channels * MCHP_I2MCC_TDM_SLOT_WIDTH;\n\t}\n\n\t \n\tmrb |= MCHP_I2SMCC_MRB_DMACHUNK(channels);\n\tif (is_playback)\n\t\tdev->playback.maxburst = 1 << (fls(channels) - 1);\n\telse\n\t\tdev->capture.maxburst = 1 << (fls(channels) - 1);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_8_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_16_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_18_BITS |\n\t\t       MCHP_I2SMCC_MRA_IWS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_20_BITS |\n\t\t       MCHP_I2SMCC_MRA_IWS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_24_BITS |\n\t\t       MCHP_I2SMCC_MRA_IWS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_24_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tmra |= MCHP_I2SMCC_MRA_DATALENGTH_32_BITS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported size/endianness for audio samples\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (set_divs) {\n\t\tbclk_rate = frame_length * params_rate(params);\n\t\tret = mchp_i2s_mcc_config_divs(dev, bclk_rate, &mra,\n\t\t\t\t\t       &rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unable to configure the divisors: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (dev->soc->has_fifo)\n\t\tmrb |= MCHP_I2SMCC_MRB_FIFOEN;\n\n\t \n\tif (mchp_i2s_mcc_is_running(dev)) {\n\t\tu32 mra_cur;\n\t\tu32 mrb_cur;\n\n\t\tregmap_read(dev->regmap, MCHP_I2SMCC_MRA, &mra_cur);\n\t\tregmap_read(dev->regmap, MCHP_I2SMCC_MRB, &mrb_cur);\n\t\tif (mra != mra_cur || mrb != mrb_cur)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (mra & MCHP_I2SMCC_MRA_SRCCLK_GCLK && !dev->gclk_use) {\n\t\t \n\t\tret = clk_set_rate(dev->gclk, rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unable to set rate %lu to GCLK: %d\\n\",\n\t\t\t\trate, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare(dev->gclk);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->dev, \"unable to prepare GCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev->gclk_use = 1;\n\t}\n\n\t \n\tdev->channels = channels;\n\n\tret = regmap_write(dev->regmap, MCHP_I2SMCC_MRA, mra);\n\tif (ret < 0) {\n\t\tif (dev->gclk_use) {\n\t\t\tclk_unprepare(dev->gclk);\n\t\t\tdev->gclk_use = 0;\n\t\t}\n\t\treturn ret;\n\t}\n\treturn regmap_write(dev->regmap, MCHP_I2SMCC_MRB, mrb);\n}\n\nstatic int mchp_i2s_mcc_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tlong err;\n\n\tif (is_playback) {\n\t\terr = wait_event_interruptible_timeout(dev->wq_txrdy,\n\t\t\t\t\t\t       dev->tx_rdy,\n\t\t\t\t\t\t       msecs_to_jiffies(500));\n\t\tif (err == 0) {\n\t\t\tdev_warn_once(dev->dev,\n\t\t\t\t      \"Timeout waiting for Tx ready\\n\");\n\t\t\tif (dev->soc->has_fifo)\n\t\t\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRB,\n\t\t\t\t\t     MCHP_I2SMCC_INT_TXFFRDY);\n\t\t\telse\n\t\t\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRA,\n\t\t\t\t\t     MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels));\n\n\t\t\tdev->tx_rdy = 1;\n\t\t}\n\t} else {\n\t\terr = wait_event_interruptible_timeout(dev->wq_rxrdy,\n\t\t\t\t\t\t       dev->rx_rdy,\n\t\t\t\t\t\t       msecs_to_jiffies(500));\n\t\tif (err == 0) {\n\t\t\tdev_warn_once(dev->dev,\n\t\t\t\t      \"Timeout waiting for Rx ready\\n\");\n\t\t\tif (dev->soc->has_fifo)\n\t\t\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRB,\n\t\t\t\t\t     MCHP_I2SMCC_INT_RXFFRDY);\n\t\t\telse\n\t\t\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IDRA,\n\t\t\t\t\t     MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels));\n\t\t\tdev->rx_rdy = 1;\n\t\t}\n\t}\n\n\tif (!mchp_i2s_mcc_is_running(dev)) {\n\t\tregmap_write(dev->regmap, MCHP_I2SMCC_CR, MCHP_I2SMCC_CR_CKDIS);\n\n\t\tif (dev->gclk_running) {\n\t\t\tclk_disable(dev->gclk);\n\t\t\tdev->gclk_running = 0;\n\t\t}\n\t\tif (dev->gclk_use) {\n\t\t\tclk_unprepare(dev->gclk);\n\t\t\tdev->gclk_use = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tu32 cr = 0;\n\tu32 iera = 0, ierb = 0;\n\tu32 sr;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (is_playback)\n\t\t\tcr = MCHP_I2SMCC_CR_TXEN | MCHP_I2SMCC_CR_CKEN;\n\t\telse\n\t\t\tcr = MCHP_I2SMCC_CR_RXEN | MCHP_I2SMCC_CR_CKEN;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tregmap_read(dev->regmap, MCHP_I2SMCC_SR, &sr);\n\t\tif (is_playback && (sr & MCHP_I2SMCC_SR_TXEN)) {\n\t\t\tcr = MCHP_I2SMCC_CR_TXDIS;\n\t\t\tdev->tx_rdy = 0;\n\t\t\t \n\t\t\tif (dev->soc->has_fifo)\n\t\t\t\tierb = MCHP_I2SMCC_INT_TXFFRDY;\n\t\t\telse\n\t\t\t\tiera = MCHP_I2SMCC_INT_TXRDY_MASK(dev->channels);\n\t\t} else if (!is_playback && (sr & MCHP_I2SMCC_SR_RXEN)) {\n\t\t\tcr = MCHP_I2SMCC_CR_RXDIS;\n\t\t\tdev->rx_rdy = 0;\n\t\t\t \n\t\t\tif (dev->soc->has_fifo)\n\t\t\t\tierb = MCHP_I2SMCC_INT_RXFFRDY;\n\t\t\telse\n\t\t\t\tiera = MCHP_I2SMCC_INT_RXRDY_MASK(dev->channels);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((cr & MCHP_I2SMCC_CR_CKEN) && dev->gclk_use &&\n\t    !dev->gclk_running) {\n\t\terr = clk_enable(dev->gclk);\n\t\tif (err) {\n\t\t\tdev_err_once(dev->dev, \"failed to enable GCLK: %d\\n\",\n\t\t\t\t     err);\n\t\t} else {\n\t\t\tdev->gclk_running = 1;\n\t\t}\n\t}\n\n\tif (dev->soc->has_fifo)\n\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IERB, ierb);\n\telse\n\t\tregmap_write(dev->regmap, MCHP_I2SMCC_IERA, iera);\n\tregmap_write(dev->regmap, MCHP_I2SMCC_CR, cr);\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tif (!mchp_i2s_mcc_is_running(dev)) {\n\t\treturn regmap_write(dev->regmap, MCHP_I2SMCC_CR,\n\t\t\t\t    MCHP_I2SMCC_CR_SWRST);\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct mchp_i2s_mcc_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tinit_waitqueue_head(&dev->wq_txrdy);\n\tinit_waitqueue_head(&dev->wq_rxrdy);\n\tdev->tx_rdy = 1;\n\tdev->rx_rdy = 1;\n\n\tsnd_soc_dai_init_dma_data(dai, &dev->playback, &dev->capture);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mchp_i2s_mcc_dai_ops = {\n\t.probe\t\t= mchp_i2s_mcc_dai_probe,\n\t.set_sysclk\t= mchp_i2s_mcc_set_sysclk,\n\t.set_bclk_ratio\t= mchp_i2s_mcc_set_bclk_ratio,\n\t.startup\t= mchp_i2s_mcc_startup,\n\t.trigger\t= mchp_i2s_mcc_trigger,\n\t.hw_params\t= mchp_i2s_mcc_hw_params,\n\t.hw_free\t= mchp_i2s_mcc_hw_free,\n\t.set_fmt\t= mchp_i2s_mcc_set_dai_fmt,\n\t.set_tdm_slot\t= mchp_i2s_mcc_set_dai_tdm_slot,\n};\n\n#define MCHP_I2SMCC_RATES              SNDRV_PCM_RATE_8000_192000\n\n#define MCHP_I2SMCC_FORMATS\t(SNDRV_PCM_FMTBIT_S8 |          \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE |      \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S18_3LE |     \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE |     \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE |     \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |      \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mchp_i2s_mcc_dai = {\n\t.playback = {\n\t\t.stream_name = \"I2SMCC-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = MCHP_I2SMCC_RATES,\n\t\t.formats = MCHP_I2SMCC_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2SMCC-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = MCHP_I2SMCC_RATES,\n\t\t.formats = MCHP_I2SMCC_FORMATS,\n\t},\n\t.ops = &mchp_i2s_mcc_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n\t.symmetric_channels = 1,\n};\n\nstatic const struct snd_soc_component_driver mchp_i2s_mcc_component = {\n\t.name\t\t\t= \"mchp-i2s-mcc\",\n\t.legacy_dai_naming\t= 1,\n};\n\n#ifdef CONFIG_OF\nstatic struct mchp_i2s_mcc_soc_data mchp_i2s_mcc_sam9x60 = {\n\t.data_pin_pair_num = 1,\n};\n\nstatic struct mchp_i2s_mcc_soc_data mchp_i2s_mcc_sama7g5 = {\n\t.data_pin_pair_num = 4,\n\t.has_fifo = true,\n};\n\nstatic const struct of_device_id mchp_i2s_mcc_dt_ids[] = {\n\t{\n\t\t.compatible = \"microchip,sam9x60-i2smcc\",\n\t\t.data = &mchp_i2s_mcc_sam9x60,\n\t},\n\t{\n\t\t.compatible = \"microchip,sama7g5-i2smcc\",\n\t\t.data = &mchp_i2s_mcc_sama7g5,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_i2s_mcc_dt_ids);\n#endif\n\nstatic int mchp_i2s_mcc_soc_data_parse(struct platform_device *pdev,\n\t\t\t\t       struct mchp_i2s_mcc_dev *dev)\n{\n\tint err;\n\n\tif (!dev->soc) {\n\t\tdev_err(&pdev->dev, \"failed to get soc data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev->soc->data_pin_pair_num == 1)\n\t\treturn 0;\n\n\terr = of_property_read_u8(pdev->dev.of_node, \"microchip,tdm-data-pair\",\n\t\t\t\t  &dev->tdm_data_pair);\n\tif (err < 0 && err != -EINVAL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"bad property data for 'microchip,tdm-data-pair': %d\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\tif (err == -EINVAL) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"'microchip,tdm-data-pair' not found; assuming DIN/DOUT 0 for TDM\\n\");\n\t\tdev->tdm_data_pair = 0;\n\t} else {\n\t\tif (dev->tdm_data_pair > dev->soc->data_pin_pair_num - 1) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"invalid value for 'microchip,tdm-data-pair': %d\\n\",\n\t\t\t\tdev->tdm_data_pair);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_dbg(&pdev->dev, \"TMD format on DIN/DOUT %d pins\\n\",\n\t\t\tdev->tdm_data_pair);\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_i2s_mcc_probe(struct platform_device *pdev)\n{\n\tstruct mchp_i2s_mcc_dev *dev;\n\tstruct resource *mem;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tu32 version;\n\tint irq;\n\tint err;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t       &mchp_i2s_mcc_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(&pdev->dev, irq, mchp_i2s_mcc_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dev);\n\tif (err)\n\t\treturn err;\n\n\tdev->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dev->pclk)) {\n\t\terr = PTR_ERR(dev->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get the peripheral clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdev->gclk = devm_clk_get(&pdev->dev, \"gclk\");\n\tif (IS_ERR(dev->gclk)) {\n\t\tif (PTR_ERR(dev->gclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"generated clock not found: %d\\n\", err);\n\t\tdev->gclk = NULL;\n\t}\n\n\tdev->soc = of_device_get_match_data(&pdev->dev);\n\terr = mchp_i2s_mcc_soc_data_parse(pdev, dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev->dev = &pdev->dev;\n\tdev->regmap = regmap;\n\tplatform_set_drvdata(pdev, dev);\n\n\terr = clk_prepare_enable(dev->pclk);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to enable the peripheral clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &mchp_i2s_mcc_component,\n\t\t\t\t\t      &mchp_i2s_mcc_dai, 1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register DAI: %d\\n\", err);\n\t\tclk_disable_unprepare(dev->pclk);\n\t\treturn err;\n\t}\n\n\tdev->playback.addr\t= (dma_addr_t)mem->start + MCHP_I2SMCC_THR;\n\tdev->capture.addr\t= (dma_addr_t)mem->start + MCHP_I2SMCC_RHR;\n\n\terr = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register PCM: %d\\n\", err);\n\t\tclk_disable_unprepare(dev->pclk);\n\t\treturn err;\n\t}\n\n\t \n\tregmap_read(dev->regmap, MCHP_I2SMCC_VERSION, &version);\n\tdev_info(&pdev->dev, \"hw version: %#lx\\n\",\n\t\t version & MCHP_I2SMCC_VERSION_MASK);\n\n\treturn 0;\n}\n\nstatic void mchp_i2s_mcc_remove(struct platform_device *pdev)\n{\n\tstruct mchp_i2s_mcc_dev *dev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(dev->pclk);\n}\n\nstatic struct platform_driver mchp_i2s_mcc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mchp_i2s_mcc\",\n\t\t.of_match_table\t= mchp_i2s_mcc_dt_ids,\n\t},\n\t.probe\t\t= mchp_i2s_mcc_probe,\n\t.remove_new\t= mchp_i2s_mcc_remove,\n};\nmodule_platform_driver(mchp_i2s_mcc_driver);\n\nMODULE_DESCRIPTION(\"Microchip I2S Multi-Channel Controller driver\");\nMODULE_AUTHOR(\"Codrin Ciubotariu <codrin.ciubotariu@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}