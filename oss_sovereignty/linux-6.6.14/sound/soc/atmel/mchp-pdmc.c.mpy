{
  "module_name": "mchp-pdmc.c",
  "hash_id": "9c2fe163def5a4f51fd710495d9bf533c244fd05a33b123a77be507d0cd7185e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/mchp-pdmc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <dt-bindings/sound/microchip,pdmc.h>\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n\n \n#define MCHP_PDMC_CR\t\t\t0x00\t \n#define MCHP_PDMC_MR\t\t\t0x04\t \n#define MCHP_PDMC_CFGR\t\t\t0x08\t \n#define MCHP_PDMC_RHR\t\t\t0x0C\t \n#define MCHP_PDMC_IER\t\t\t0x14\t \n#define MCHP_PDMC_IDR\t\t\t0x18\t \n#define MCHP_PDMC_IMR\t\t\t0x1C\t \n#define MCHP_PDMC_ISR\t\t\t0x20\t \n#define MCHP_PDMC_VER\t\t\t0x50\t \n\n \n#define MCHP_PDMC_CR_SWRST\t\tBIT(0)\t \n\n \n#define MCHP_PDMC_MR_PDMCEN_MASK\tGENMASK(3, 0)\n#define MCHP_PDMC_MR_PDMCEN(ch)\t\t(BIT(ch) & MCHP_PDMC_MR_PDMCEN_MASK)\n\n#define MCHP_PDMC_MR_OSR_MASK\t\tGENMASK(17, 16)\n#define MCHP_PDMC_MR_OSR64\t\t(1 << 16)\n#define MCHP_PDMC_MR_OSR128\t\t(2 << 16)\n#define MCHP_PDMC_MR_OSR256\t\t(3 << 16)\n\n#define MCHP_PDMC_MR_SINCORDER_MASK\tGENMASK(23, 20)\n\n#define MCHP_PDMC_MR_SINC_OSR_MASK\tGENMASK(27, 24)\n#define MCHP_PDMC_MR_SINC_OSR_DIS\t(0 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_8\t\t(1 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_16\t(2 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_32\t(3 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_64\t(4 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_128\t(5 << 24)\n#define MCHP_PDMC_MR_SINC_OSR_256\t(6 << 24)\n\n#define MCHP_PDMC_MR_CHUNK_MASK\t\tGENMASK(31, 28)\n\n \n#define MCHP_PDMC_CFGR_BSSEL_MASK\t(BIT(0) | BIT(2) | BIT(4) | BIT(6))\n#define MCHP_PDMC_CFGR_BSSEL(ch)\tBIT((ch) * 2)\n\n#define MCHP_PDMC_CFGR_PDMSEL_MASK\t(BIT(16) | BIT(18) | BIT(20) | BIT(22))\n#define MCHP_PDMC_CFGR_PDMSEL(ch)\tBIT((ch) * 2 + 16)\n\n \n#define MCHP_PDMC_IR_RXRDY\t\tBIT(0)\n#define MCHP_PDMC_IR_RXEMPTY\t\tBIT(1)\n#define MCHP_PDMC_IR_RXFULL\t\tBIT(2)\n#define MCHP_PDMC_IR_RXCHUNK\t\tBIT(3)\n#define MCHP_PDMC_IR_RXUDR\t\tBIT(4)\n#define MCHP_PDMC_IR_RXOVR\t\tBIT(5)\n\n \n#define MCHP_PDMC_VER_VERSION\t\tGENMASK(11, 0)\n\n#define MCHP_PDMC_MAX_CHANNELS\t\t4\n#define MCHP_PDMC_DS_NO\t\t\t2\n#define MCHP_PDMC_EDGE_NO\t\t2\n\nstruct mic_map {\n\tint ds_pos;\n\tint clk_edge;\n};\n\nstruct mchp_pdmc_chmap {\n\tstruct snd_pcm_chmap_elem *chmap;\n\tstruct mchp_pdmc *dd;\n\tstruct snd_pcm *pcm;\n\tstruct snd_kcontrol *kctl;\n};\n\nstruct mchp_pdmc {\n\tstruct mic_map channel_mic_map[MCHP_PDMC_MAX_CHANNELS];\n\tstruct device *dev;\n\tstruct snd_dmaengine_dai_dma_data addr;\n\tstruct regmap *regmap;\n\tstruct clk *pclk;\n\tstruct clk *gclk;\n\tu32 pdmcen;\n\tu32 suspend_irq;\n\tu32 startup_delay_us;\n\tint mic_no;\n\tint sinc_order;\n\tbool audio_filter_en;\n};\n\nstatic const char *const mchp_pdmc_sinc_filter_order_text[] = {\n\t\"1\", \"2\", \"3\", \"4\", \"5\"\n};\n\nstatic const unsigned int mchp_pdmc_sinc_filter_order_values[] = {\n\t1, 2, 3, 4, 5,\n};\n\nstatic const struct soc_enum mchp_pdmc_sinc_filter_order_enum = {\n\t.items = ARRAY_SIZE(mchp_pdmc_sinc_filter_order_text),\n\t.texts = mchp_pdmc_sinc_filter_order_text,\n\t.values = mchp_pdmc_sinc_filter_order_values,\n};\n\nstatic int mchp_pdmc_sinc_order_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int item;\n\n\titem = snd_soc_enum_val_to_item(e, dd->sinc_order);\n\tuvalue->value.enumerated.item[0] = item;\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_sinc_order_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = uvalue->value.enumerated.item;\n\tunsigned int val;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\tif (val == dd->sinc_order)\n\t\treturn 0;\n\n\tdd->sinc_order = val;\n\n\treturn 1;\n}\n\nstatic int mchp_pdmc_af_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = snd_soc_component_get_drvdata(component);\n\n\tuvalue->value.integer.value[0] = !!dd->audio_filter_en;\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_af_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = snd_soc_component_get_drvdata(component);\n\tbool af = uvalue->value.integer.value[0] ? true : false;\n\n\tif (dd->audio_filter_en == af)\n\t\treturn 0;\n\n\tdd->audio_filter_en = af;\n\n\treturn 1;\n}\n\nstatic int mchp_pdmc_chmap_ctl_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct mchp_pdmc_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = info->dd->mic_no;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_RR;  \n\treturn 0;\n}\n\nstatic inline struct snd_pcm_substream *\nmchp_pdmc_chmap_substream(struct mchp_pdmc_chmap *info, unsigned int idx)\n{\n\tstruct snd_pcm_substream *s;\n\n\tfor (s = info->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; s; s = s->next)\n\t\tif (s->number == idx)\n\t\t\treturn s;\n\treturn NULL;\n}\n\nstatic struct snd_pcm_chmap_elem *mchp_pdmc_chmap_get(struct snd_pcm_substream *substream,\n\t\t\t\t\t\t      struct mchp_pdmc_chmap *ch_info)\n{\n\tstruct snd_pcm_chmap_elem *map;\n\n\tfor (map = ch_info->chmap; map->channels; map++) {\n\t\tif (map->channels == substream->runtime->channels)\n\t\t\treturn map;\n\t}\n\treturn NULL;\n}\n\nstatic int mchp_pdmc_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct mchp_pdmc_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = info->dd;\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_pcm_substream *substream;\n\tconst struct snd_pcm_chmap_elem *map;\n\tint i;\n\tu32 cfgr_val = 0;\n\n\tif (!info->chmap)\n\t\treturn -EINVAL;\n\tsubstream = mchp_pdmc_chmap_substream(info, idx);\n\tif (!substream)\n\t\treturn -ENODEV;\n\tmemset(ucontrol->value.integer.value, 0, sizeof(long) * info->dd->mic_no);\n\tif (!substream->runtime)\n\t\treturn 0;  \n\n\tmap = mchp_pdmc_chmap_get(substream, info);\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < map->channels; i++) {\n\t\tint map_idx = map->channels == 1 ? map->map[i] - SNDRV_CHMAP_MONO :\n\t\t\t\t\t\t   map->map[i] - SNDRV_CHMAP_FL;\n\n\t\t \n\t\tif (dd->channel_mic_map[map_idx].ds_pos)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_PDMSEL(i);\n\t\tif (dd->channel_mic_map[map_idx].clk_edge)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_BSSEL(i);\n\n\t\tucontrol->value.integer.value[i] = map->map[i];\n\t}\n\n\tregmap_write(dd->regmap, MCHP_PDMC_CFGR, cfgr_val);\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_chmap_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct mchp_pdmc_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_pdmc *dd = info->dd;\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_chmap_elem *map;\n\tu32 cfgr_val = 0;\n\tint i;\n\n\tif (!info->chmap)\n\t\treturn -EINVAL;\n\tsubstream = mchp_pdmc_chmap_substream(info, idx);\n\tif (!substream)\n\t\treturn -ENODEV;\n\n\tmap = mchp_pdmc_chmap_get(substream, info);\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < map->channels; i++) {\n\t\tint map_idx;\n\n\t\tmap->map[i] = ucontrol->value.integer.value[i];\n\t\tmap_idx = map->channels == 1 ? map->map[i] - SNDRV_CHMAP_MONO :\n\t\t\t\t\t       map->map[i] - SNDRV_CHMAP_FL;\n\n\t\t \n\t\tif (dd->channel_mic_map[map_idx].ds_pos)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_PDMSEL(i);\n\t\tif (dd->channel_mic_map[map_idx].clk_edge)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_BSSEL(i);\n\t}\n\n\tregmap_write(dd->regmap, MCHP_PDMC_CFGR, cfgr_val);\n\n\treturn 0;\n}\n\nstatic void mchp_pdmc_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct mchp_pdmc_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tinfo->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].chmap_kctl = NULL;\n\tkfree(info);\n}\n\nstatic int mchp_pdmc_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t\t   unsigned int size, unsigned int __user *tlv)\n{\n\tstruct mchp_pdmc_chmap *info = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_pcm_chmap_elem *map;\n\tunsigned int __user *dst;\n\tint c, count = 0;\n\n\tif (!info->chmap)\n\t\treturn -EINVAL;\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint chs_bytes = map->channels * 4;\n\n\t\tif (size < 8)\n\t\t\treturn -ENOMEM;\n\t\tif (put_user(SNDRV_CTL_TLVT_CHMAP_VAR, dst) ||\n\t\t    put_user(chs_bytes, dst + 1))\n\t\t\treturn -EFAULT;\n\t\tdst += 2;\n\t\tsize -= 8;\n\t\tcount += 8;\n\t\tif (size < chs_bytes)\n\t\t\treturn -ENOMEM;\n\t\tsize -= chs_bytes;\n\t\tcount += chs_bytes;\n\t\tfor (c = 0; c < map->channels; c++) {\n\t\t\tif (put_user(map->map[c], dst))\n\t\t\t\treturn -EFAULT;\n\t\t\tdst++;\n\t\t}\n\t}\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new mchp_pdmc_snd_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"Audio Filter\", 0, &mchp_pdmc_af_get, &mchp_pdmc_af_put),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"SINC Filter Order\",\n\t\t.info = snd_soc_info_enum_double,\n\t\t.get = mchp_pdmc_sinc_order_get,\n\t\t.put = mchp_pdmc_sinc_order_put,\n\t\t.private_value = (unsigned long)&mchp_pdmc_sinc_filter_order_enum,\n\t},\n};\n\nstatic int mchp_pdmc_close(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\treturn snd_soc_add_component_controls(component, mchp_pdmc_snd_controls,\n\t\t\t\t\t      ARRAY_SIZE(mchp_pdmc_snd_controls));\n}\n\nstatic int mchp_pdmc_open(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mchp_pdmc_snd_controls); i++) {\n\t\tconst struct snd_kcontrol_new *control = &mchp_pdmc_snd_controls[i];\n\t\tstruct snd_ctl_elem_id id;\n\t\tint err;\n\n\t\tif (component->name_prefix)\n\t\t\tsnprintf(id.name, sizeof(id.name), \"%s %s\", component->name_prefix,\n\t\t\t\t control->name);\n\t\telse\n\t\t\tstrscpy(id.name, control->name, sizeof(id.name));\n\n\t\tid.numid = 0;\n\t\tid.iface = control->iface;\n\t\tid.device = control->device;\n\t\tid.subdevice = control->subdevice;\n\t\tid.index = control->index;\n\t\terr = snd_ctl_remove_id(component->card->snd_card, &id);\n\t\tif (err < 0)\n\t\t\tdev_err(component->dev, \"%d: Failed to remove %s\\n\", err,\n\t\t\t\tcontrol->name);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver mchp_pdmc_dai_component = {\n\t.name = \"mchp-pdmc\",\n\t.controls = mchp_pdmc_snd_controls,\n\t.num_controls = ARRAY_SIZE(mchp_pdmc_snd_controls),\n\t.open = &mchp_pdmc_open,\n\t.close = &mchp_pdmc_close,\n\t.legacy_dai_naming = 1,\n\t.trigger_start = SND_SOC_TRIGGER_ORDER_LDC,\n};\n\nstatic const unsigned int mchp_pdmc_1mic[] = {1};\nstatic const unsigned int mchp_pdmc_2mic[] = {1, 2};\nstatic const unsigned int mchp_pdmc_3mic[] = {1, 2, 3};\nstatic const unsigned int mchp_pdmc_4mic[] = {1, 2, 3, 4};\n\nstatic const struct snd_pcm_hw_constraint_list mchp_pdmc_chan_constr[] = {\n\t{\n\t\t.list = mchp_pdmc_1mic,\n\t\t.count = ARRAY_SIZE(mchp_pdmc_1mic),\n\t},\n\t{\n\t\t.list = mchp_pdmc_2mic,\n\t\t.count = ARRAY_SIZE(mchp_pdmc_2mic),\n\t},\n\t{\n\t\t.list = mchp_pdmc_3mic,\n\t\t.count = ARRAY_SIZE(mchp_pdmc_3mic),\n\t},\n\t{\n\t\t.list = mchp_pdmc_4mic,\n\t\t.count = ARRAY_SIZE(mchp_pdmc_4mic),\n\t},\n};\n\nstatic int mchp_pdmc_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);\n\n\tregmap_write(dd->regmap, MCHP_PDMC_CR, MCHP_PDMC_CR_SWRST);\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &mchp_pdmc_chan_constr[dd->mic_no - 1]);\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, NULL, &dd->addr);\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tunsigned int fmt_master = fmt & SND_SOC_DAIFMT_MASTER_MASK;\n\tunsigned int fmt_format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\t \n\tif (fmt_master != SND_SOC_DAIFMT_BP_FP &&\n\t    fmt_master != SND_SOC_DAIFMT_BP_FC)\n\t\treturn -EINVAL;\n\n\t \n\tif (fmt_format != SND_SOC_DAIFMT_PDM)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u32 mchp_pdmc_mr_set_osr(int audio_filter_en, unsigned int osr)\n{\n\tif (audio_filter_en) {\n\t\tswitch (osr) {\n\t\tcase 64:\n\t\t\treturn MCHP_PDMC_MR_OSR64;\n\t\tcase 128:\n\t\t\treturn MCHP_PDMC_MR_OSR128;\n\t\tcase 256:\n\t\t\treturn MCHP_PDMC_MR_OSR256;\n\t\t}\n\t} else {\n\t\tswitch (osr) {\n\t\tcase 8:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_8;\n\t\tcase 16:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_16;\n\t\tcase 32:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_32;\n\t\tcase 64:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_64;\n\t\tcase 128:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_128;\n\t\tcase 256:\n\t\t\treturn MCHP_PDMC_MR_SINC_OSR_256;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline int mchp_pdmc_period_to_maxburst(int period_size)\n{\n\tif (!(period_size % 8))\n\t\treturn 8;\n\tif (!(period_size % 4))\n\t\treturn 4;\n\tif (!(period_size % 2))\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic struct snd_pcm_chmap_elem mchp_pdmc_std_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 3,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nstatic int mchp_pdmc_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_component *comp = dai->component;\n\tunsigned long gclk_rate = 0;\n\tunsigned long best_diff_rate = ~0UL;\n\tunsigned int channels = params_channels(params);\n\tunsigned int osr = 0, osr_start;\n\tunsigned int fs = params_rate(params);\n\tu32 mr_val = 0;\n\tu32 cfgr_val = 0;\n\tint i;\n\tint ret;\n\n\tdev_dbg(comp->dev, \"%s() rate=%u format=%#x width=%u channels=%u\\n\",\n\t\t__func__, params_rate(params), params_format(params),\n\t\tparams_width(params), params_channels(params));\n\n\tif (channels > dd->mic_no) {\n\t\tdev_err(comp->dev, \"more channels %u than microphones %d\\n\",\n\t\t\tchannels, dd->mic_no);\n\t\treturn -EINVAL;\n\t}\n\n\tdd->pdmcen = 0;\n\tfor (i = 0; i < channels; i++) {\n\t\tdd->pdmcen |= MCHP_PDMC_MR_PDMCEN(i);\n\t\tif (dd->channel_mic_map[i].ds_pos)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_PDMSEL(i);\n\t\tif (dd->channel_mic_map[i].clk_edge)\n\t\t\tcfgr_val |= MCHP_PDMC_CFGR_BSSEL(i);\n\t}\n\n\tfor (osr_start = dd->audio_filter_en ? 64 : 8;\n\t     osr_start <= 256 && best_diff_rate; osr_start *= 2) {\n\t\tlong round_rate;\n\t\tunsigned long diff_rate;\n\n\t\tround_rate = clk_round_rate(dd->gclk,\n\t\t\t\t\t    (unsigned long)fs * 16 * osr_start);\n\t\tif (round_rate < 0)\n\t\t\tcontinue;\n\t\tdiff_rate = abs((fs * 16 * osr_start) - round_rate);\n\t\tif (diff_rate < best_diff_rate) {\n\t\t\tbest_diff_rate = diff_rate;\n\t\t\tosr = osr_start;\n\t\t\tgclk_rate = fs * 16 * osr;\n\t\t}\n\t}\n\tif (!gclk_rate) {\n\t\tdev_err(comp->dev, \"invalid sampling rate: %u\\n\", fs);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclk_disable_unprepare(dd->gclk);\n\n\t \n\tret = clk_set_rate(dd->gclk, gclk_rate);\n\tclk_prepare_enable(dd->gclk);\n\tif (ret) {\n\t\tdev_err(comp->dev, \"unable to set rate %lu to GCLK: %d\\n\",\n\t\t\tgclk_rate, ret);\n\t\treturn ret;\n\t}\n\n\tmr_val |= mchp_pdmc_mr_set_osr(dd->audio_filter_en, osr);\n\n\tmr_val |= FIELD_PREP(MCHP_PDMC_MR_SINCORDER_MASK, dd->sinc_order);\n\n\tdd->addr.maxburst = mchp_pdmc_period_to_maxburst(snd_pcm_lib_period_bytes(substream));\n\tmr_val |= FIELD_PREP(MCHP_PDMC_MR_CHUNK_MASK, dd->addr.maxburst);\n\tdev_dbg(comp->dev, \"maxburst set to %d\\n\", dd->addr.maxburst);\n\n\tsnd_soc_component_update_bits(comp, MCHP_PDMC_MR,\n\t\t\t\t      MCHP_PDMC_MR_OSR_MASK |\n\t\t\t\t      MCHP_PDMC_MR_SINCORDER_MASK |\n\t\t\t\t      MCHP_PDMC_MR_SINC_OSR_MASK |\n\t\t\t\t      MCHP_PDMC_MR_CHUNK_MASK, mr_val);\n\n\tsnd_soc_component_write(comp, MCHP_PDMC_CFGR, cfgr_val);\n\n\treturn 0;\n}\n\nstatic void mchp_pdmc_noise_filter_workaround(struct mchp_pdmc *dd)\n{\n\tu32 tmp, steps = 16;\n\n\t \n\tusleep_range(dd->startup_delay_us, dd->startup_delay_us + 5);\n\n\twhile (steps--)\n\t\tregmap_read(dd->regmap, MCHP_PDMC_RHR, &tmp);\n\n\t \n\tregmap_read(dd->regmap, MCHP_PDMC_ISR, &tmp);\n}\n\nstatic int mchp_pdmc_trigger(struct snd_pcm_substream *substream,\n\t\t\t     int cmd, struct snd_soc_dai *dai)\n{\n\tstruct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_component *cpu = dai->component;\n#ifdef DEBUG\n\tu32 val;\n#endif\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_soc_component_update_bits(cpu, MCHP_PDMC_MR,\n\t\t\t\t\t      MCHP_PDMC_MR_PDMCEN_MASK,\n\t\t\t\t\t      dd->pdmcen);\n\n\t\tmchp_pdmc_noise_filter_workaround(dd);\n\n\t\t \n\t\tregmap_write(dd->regmap, MCHP_PDMC_IER, dd->suspend_irq |\n\t\t\t     MCHP_PDMC_IR_RXOVR | MCHP_PDMC_IR_RXUDR);\n\t\tdd->suspend_irq = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tregmap_read(dd->regmap, MCHP_PDMC_IMR, &dd->suspend_irq);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t \n\t\tregmap_write(dd->regmap, MCHP_PDMC_IDR, dd->suspend_irq |\n\t\t\t     MCHP_PDMC_IR_RXOVR | MCHP_PDMC_IR_RXUDR);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tsnd_soc_component_update_bits(cpu, MCHP_PDMC_MR,\n\t\t\t\t\t      MCHP_PDMC_MR_PDMCEN_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n#ifdef DEBUG\n\tregmap_read(dd->regmap, MCHP_PDMC_MR, &val);\n\tdev_dbg(dd->dev, \"MR (0x%02x): 0x%08x\\n\", MCHP_PDMC_MR, val);\n\tregmap_read(dd->regmap, MCHP_PDMC_CFGR, &val);\n\tdev_dbg(dd->dev, \"CFGR (0x%02x): 0x%08x\\n\", MCHP_PDMC_CFGR, val);\n\tregmap_read(dd->regmap, MCHP_PDMC_IMR, &val);\n\tdev_dbg(dd->dev, \"IMR (0x%02x): 0x%08x\\n\", MCHP_PDMC_IMR, val);\n#endif\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_add_chmap_ctls(struct snd_pcm *pcm, struct mchp_pdmc *dd)\n{\n\tstruct mchp_pdmc_chmap *info;\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\n\t\t.info = mchp_pdmc_chmap_ctl_info,\n\t\t.get = mchp_pdmc_chmap_ctl_get,\n\t\t.put = mchp_pdmc_chmap_ctl_put,\n\t\t.tlv.c = mchp_pdmc_chmap_ctl_tlv,\n\t};\n\tint err;\n\n\tif (WARN_ON(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].chmap_kctl))\n\t\treturn -EBUSY;\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm = pcm;\n\tinfo->dd = dd;\n\tinfo->chmap = mchp_pdmc_std_chmaps;\n\tknew.name = \"Capture Channel Map\";\n\tknew.device = pcm->device;\n\tknew.count = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count;\n\tinfo->kctl = snd_ctl_new1(&knew, info);\n\tif (!info->kctl) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->kctl->private_free = mchp_pdmc_chmap_ctl_private_free;\n\terr = snd_ctl_add(pcm->card, info->kctl);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->streams[SNDRV_PCM_STREAM_CAPTURE].chmap_kctl = info->kctl;\n\treturn 0;\n}\n\nstatic int mchp_pdmc_pcm_new(struct snd_soc_pcm_runtime *rtd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = mchp_pdmc_add_chmap_ctls(rtd->pcm, dd);\n\tif (ret < 0)\n\t\tdev_err(dd->dev, \"failed to add channel map controls: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops mchp_pdmc_dai_ops = {\n\t.probe\t\t= mchp_pdmc_dai_probe,\n\t.set_fmt\t= mchp_pdmc_set_fmt,\n\t.startup\t= mchp_pdmc_startup,\n\t.hw_params\t= mchp_pdmc_hw_params,\n\t.trigger\t= mchp_pdmc_trigger,\n\t.pcm_new\t= &mchp_pdmc_pcm_new,\n};\n\nstatic struct snd_soc_dai_driver mchp_pdmc_dai = {\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 4,\n\t\t.rate_min\t= 8000,\n\t\t.rate_max\t= 192000,\n\t\t.rates\t\t= SNDRV_PCM_RATE_KNOT,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.ops = &mchp_pdmc_dai_ops,\n};\n\n \nstatic irqreturn_t mchp_pdmc_interrupt(int irq, void *dev_id)\n{\n\tstruct mchp_pdmc *dd = dev_id;\n\tu32 isr, msr, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(dd->regmap, MCHP_PDMC_ISR, &isr);\n\tregmap_read(dd->regmap, MCHP_PDMC_IMR, &msr);\n\n\tpending = isr & msr;\n\tdev_dbg(dd->dev, \"ISR (0x%02x): 0x%08x, IMR (0x%02x): 0x%08x, pending: 0x%08x\\n\",\n\t\tMCHP_PDMC_ISR, isr, MCHP_PDMC_IMR, msr, pending);\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\tif (pending & MCHP_PDMC_IR_RXUDR) {\n\t\tdev_warn(dd->dev, \"underrun detected\\n\");\n\t\tregmap_write(dd->regmap, MCHP_PDMC_IDR, MCHP_PDMC_IR_RXUDR);\n\t\tret = IRQ_HANDLED;\n\t}\n\tif (pending & MCHP_PDMC_IR_RXOVR) {\n\t\tdev_warn(dd->dev, \"overrun detected\\n\");\n\t\tregmap_write(dd->regmap, MCHP_PDMC_IDR, MCHP_PDMC_IR_RXOVR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool mchp_pdmc_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MCHP_PDMC_MR:\n\tcase MCHP_PDMC_CFGR:\n\tcase MCHP_PDMC_IMR:\n\tcase MCHP_PDMC_ISR:\n\tcase MCHP_PDMC_RHR:\n\tcase MCHP_PDMC_VER:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_pdmc_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MCHP_PDMC_CR:\n\tcase MCHP_PDMC_MR:\n\tcase MCHP_PDMC_CFGR:\n\tcase MCHP_PDMC_IER:\n\tcase MCHP_PDMC_IDR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_pdmc_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MCHP_PDMC_ISR:\n\tcase MCHP_PDMC_RHR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_pdmc_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MCHP_PDMC_RHR:\n\tcase MCHP_PDMC_ISR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mchp_pdmc_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= MCHP_PDMC_VER,\n\t.readable_reg\t= mchp_pdmc_readable_reg,\n\t.writeable_reg\t= mchp_pdmc_writeable_reg,\n\t.precious_reg\t= mchp_pdmc_precious_reg,\n\t.volatile_reg\t= mchp_pdmc_volatile_reg,\n\t.cache_type\t= REGCACHE_FLAT,\n};\n\nstatic int mchp_pdmc_dt_init(struct mchp_pdmc *dd)\n{\n\tstruct device_node *np = dd->dev->of_node;\n\tbool mic_ch[MCHP_PDMC_DS_NO][MCHP_PDMC_EDGE_NO] = {0};\n\tint i;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(dd->dev, \"device node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdd->mic_no = of_property_count_u32_elems(np, \"microchip,mic-pos\");\n\tif (dd->mic_no < 0) {\n\t\tdev_err(dd->dev, \"failed to get microchip,mic-pos: %d\",\n\t\t\tdd->mic_no);\n\t\treturn dd->mic_no;\n\t}\n\tif (!dd->mic_no || dd->mic_no % 2 ||\n\t    dd->mic_no / 2 > MCHP_PDMC_MAX_CHANNELS) {\n\t\tdev_err(dd->dev, \"invalid array length for microchip,mic-pos: %d\",\n\t\t\tdd->mic_no);\n\t\treturn -EINVAL;\n\t}\n\n\tdd->mic_no /= 2;\n\n\tdev_info(dd->dev, \"%d PDM microphones declared\\n\", dd->mic_no);\n\n\t \n\tfor (i = 0; i < dd->mic_no; i++) {\n\t\tint ds;\n\t\tint edge;\n\n\t\tret = of_property_read_u32_index(np, \"microchip,mic-pos\", i * 2,\n\t\t\t\t\t\t &ds);\n\t\tif (ret) {\n\t\t\tdev_err(dd->dev,\n\t\t\t\t\"failed to get value no %d value from microchip,mic-pos: %d\",\n\t\t\t\ti * 2, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ds >= MCHP_PDMC_DS_NO) {\n\t\t\tdev_err(dd->dev,\n\t\t\t\t\"invalid DS index in microchip,mic-pos array: %d\",\n\t\t\t\tds);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = of_property_read_u32_index(np, \"microchip,mic-pos\", i * 2 + 1,\n\t\t\t\t\t\t &edge);\n\t\tif (ret) {\n\t\t\tdev_err(dd->dev,\n\t\t\t\t\"failed to get value no %d value from microchip,mic-pos: %d\",\n\t\t\t\ti * 2 + 1, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (edge != MCHP_PDMC_CLK_POSITIVE &&\n\t\t    edge != MCHP_PDMC_CLK_NEGATIVE) {\n\t\t\tdev_err(dd->dev,\n\t\t\t\t\"invalid edge in microchip,mic-pos array: %d\", edge);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (mic_ch[ds][edge]) {\n\t\t\tdev_err(dd->dev,\n\t\t\t\t\"duplicated mic (DS %d, edge %d) in microchip,mic-pos array\",\n\t\t\t\tds, edge);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmic_ch[ds][edge] = true;\n\t\tdd->channel_mic_map[i].ds_pos = ds;\n\t\tdd->channel_mic_map[i].clk_edge = edge;\n\t}\n\n\tdd->startup_delay_us = 150000;\n\tof_property_read_u32(np, \"microchip,startup-delay-us\", &dd->startup_delay_us);\n\n\treturn 0;\n}\n\n \nstatic int mchp_pdmc_process(struct snd_pcm_substream *substream,\n\t\t\t     int channel, unsigned long hwoff,\n\t\t\t     unsigned long bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu8 *dma_ptr = runtime->dma_area + hwoff +\n\t\t      channel * (runtime->dma_bytes / runtime->channels);\n\tu8 *dma_ptr_end = dma_ptr + bytes;\n\tunsigned int sample_size = samples_to_bytes(runtime, 1);\n\n\tfor (; dma_ptr < dma_ptr_end; dma_ptr += sample_size)\n\t\t*dma_ptr = 0;\n\n\treturn 0;\n}\n\nstatic struct snd_dmaengine_pcm_config mchp_pdmc_config = {\n\t.process = mchp_pdmc_process,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\nstatic int mchp_pdmc_runtime_suspend(struct device *dev)\n{\n\tstruct mchp_pdmc *dd = dev_get_drvdata(dev);\n\n\tregcache_cache_only(dd->regmap, true);\n\n\tclk_disable_unprepare(dd->gclk);\n\tclk_disable_unprepare(dd->pclk);\n\n\treturn 0;\n}\n\nstatic int mchp_pdmc_runtime_resume(struct device *dev)\n{\n\tstruct mchp_pdmc *dd = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(dd->pclk);\n\tif (ret) {\n\t\tdev_err(dd->dev,\n\t\t\t\"failed to enable the peripheral clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(dd->gclk);\n\tif (ret) {\n\t\tdev_err(dd->dev,\n\t\t\t\"failed to enable generic clock: %d\\n\", ret);\n\t\tgoto disable_pclk;\n\t}\n\n\tregcache_cache_only(dd->regmap, false);\n\tregcache_mark_dirty(dd->regmap);\n\tret = regcache_sync(dd->regmap);\n\tif (ret) {\n\t\tregcache_cache_only(dd->regmap, true);\n\t\tclk_disable_unprepare(dd->gclk);\ndisable_pclk:\n\t\tclk_disable_unprepare(dd->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic int mchp_pdmc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mchp_pdmc *dd;\n\tstruct resource *res;\n\tvoid __iomem *io_base;\n\tu32 version;\n\tint irq;\n\tint ret;\n\n\tdd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tdd->dev = &pdev->dev;\n\tret = mchp_pdmc_dt_init(dd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdd->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dd->pclk)) {\n\t\tret = PTR_ERR(dd->pclk);\n\t\tdev_err(dev, \"failed to get peripheral clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdd->gclk = devm_clk_get(dev, \"gclk\");\n\tif (IS_ERR(dd->gclk)) {\n\t\tret = PTR_ERR(dd->gclk);\n\t\tdev_err(dev, \"failed to get GCK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tio_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(io_base)) {\n\t\tret = PTR_ERR(io_base);\n\t\tdev_err(dev, \"failed to remap register memory: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdd->regmap = devm_regmap_init_mmio(dev, io_base,\n\t\t\t\t\t   &mchp_pdmc_regmap_config);\n\tif (IS_ERR(dd->regmap)) {\n\t\tret = PTR_ERR(dd->regmap);\n\t\tdev_err(dev, \"failed to init register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, irq, mchp_pdmc_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register ISR for IRQ %u (ret=%i)\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdd->audio_filter_en = true;\n\tdd->sinc_order = 3;\n\n\tdd->addr.addr = (dma_addr_t)res->start + MCHP_PDMC_RHR;\n\tplatform_set_drvdata(pdev, dd);\n\n\tpm_runtime_enable(dd->dev);\n\tif (!pm_runtime_enabled(dd->dev)) {\n\t\tret = mchp_pdmc_runtime_resume(dd->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = devm_snd_dmaengine_pcm_register(dev, &mchp_pdmc_config, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register platform: %d\\n\", ret);\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &mchp_pdmc_dai_component,\n\t\t\t\t\t      &mchp_pdmc_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register CPU DAI: %d\\n\", ret);\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\t \n\tregmap_read(dd->regmap, MCHP_PDMC_VER, &version);\n\tdev_info(dd->dev, \"hw version: %#lx\\n\",\n\t\t version & MCHP_PDMC_VER_VERSION);\n\n\treturn 0;\n\npm_runtime_suspend:\n\tif (!pm_runtime_status_suspended(dd->dev))\n\t\tmchp_pdmc_runtime_suspend(dd->dev);\n\tpm_runtime_disable(dd->dev);\n\n\treturn ret;\n}\n\nstatic void mchp_pdmc_remove(struct platform_device *pdev)\n{\n\tstruct mchp_pdmc *dd = platform_get_drvdata(pdev);\n\n\tif (!pm_runtime_status_suspended(dd->dev))\n\t\tmchp_pdmc_runtime_suspend(dd->dev);\n\n\tpm_runtime_disable(dd->dev);\n}\n\nstatic const struct of_device_id mchp_pdmc_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,sama7g5-pdmc\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, mchp_pdmc_of_match);\n\nstatic const struct dev_pm_ops mchp_pdmc_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n\tRUNTIME_PM_OPS(mchp_pdmc_runtime_suspend, mchp_pdmc_runtime_resume,\n\t\t       NULL)\n};\n\nstatic struct platform_driver mchp_pdmc_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"mchp-pdmc\",\n\t\t.of_match_table\t= of_match_ptr(mchp_pdmc_of_match),\n\t\t.pm\t\t= pm_ptr(&mchp_pdmc_pm_ops),\n\t},\n\t.probe\t= mchp_pdmc_probe,\n\t.remove_new = mchp_pdmc_remove,\n};\nmodule_platform_driver(mchp_pdmc_driver);\n\nMODULE_DESCRIPTION(\"Microchip PDMC driver under ALSA SoC architecture\");\nMODULE_AUTHOR(\"Codrin Ciubotariu <codrin.ciubotariu@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}