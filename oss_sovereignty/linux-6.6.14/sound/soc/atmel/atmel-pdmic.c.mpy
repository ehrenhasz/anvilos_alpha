{
  "module_name": "atmel-pdmic.c",
  "hash_id": "03574affba6a9c541913275671e5665a06a44c61275ab2c2980b80232a7330d8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel-pdmic.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"atmel-pdmic.h\"\n\nstruct atmel_pdmic_pdata {\n\tu32 mic_min_freq;\n\tu32 mic_max_freq;\n\ts32 mic_offset;\n\tconst char *card_name;\n};\n\nstruct atmel_pdmic {\n\tdma_addr_t phy_base;\n\tstruct regmap *regmap;\n\tstruct clk *pclk;\n\tstruct clk *gclk;\n\tstruct device *dev;\n\tint irq;\n\tstruct snd_pcm_substream *substream;\n\tconst struct atmel_pdmic_pdata *pdata;\n};\n\nstatic const struct of_device_id atmel_pdmic_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-pdmic\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_pdmic_of_match);\n\n#define PDMIC_OFFSET_MAX_VAL\tS16_MAX\n#define PDMIC_OFFSET_MIN_VAL\tS16_MIN\n\nstatic struct atmel_pdmic_pdata *atmel_pdmic_dt_init(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct atmel_pdmic_pdata *pdata;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device node not found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (of_property_read_string(np, \"atmel,model\", &pdata->card_name))\n\t\tpdata->card_name = \"PDMIC\";\n\n\tif (of_property_read_u32(np, \"atmel,mic-min-freq\",\n\t\t\t\t &pdata->mic_min_freq)) {\n\t\tdev_err(dev, \"failed to get mic-min-freq\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (of_property_read_u32(np, \"atmel,mic-max-freq\",\n\t\t\t\t &pdata->mic_max_freq)) {\n\t\tdev_err(dev, \"failed to get mic-max-freq\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (pdata->mic_max_freq < pdata->mic_min_freq) {\n\t\tdev_err(dev,\n\t\t\t\"mic-max-freq should not be less than mic-min-freq\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (of_property_read_s32(np, \"atmel,mic-offset\", &pdata->mic_offset))\n\t\tpdata->mic_offset = 0;\n\n\tif (pdata->mic_offset > PDMIC_OFFSET_MAX_VAL) {\n\t\tdev_warn(dev,\n\t\t\t \"mic-offset value %d is larger than the max value %d, the max value is specified\\n\",\n\t\t\t pdata->mic_offset, PDMIC_OFFSET_MAX_VAL);\n\t\tpdata->mic_offset = PDMIC_OFFSET_MAX_VAL;\n\t} else if (pdata->mic_offset < PDMIC_OFFSET_MIN_VAL) {\n\t\tdev_warn(dev,\n\t\t\t \"mic-offset value %d is less than the min value %d, the min value is specified\\n\",\n\t\t\t pdata->mic_offset, PDMIC_OFFSET_MIN_VAL);\n\t\tpdata->mic_offset = PDMIC_OFFSET_MIN_VAL;\n\t}\n\n\treturn pdata;\n}\n\n \nstatic int atmel_pdmic_cpu_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\n\tint ret;\n\n\tret = clk_prepare_enable(dd->gclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret =  clk_prepare_enable(dd->pclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(dd->gclk);\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write(dd->regmap, PDMIC_CR, 0);\n\n\tdd->substream = substream;\n\n\t \n\tregmap_write(dd->regmap, PDMIC_IER, PDMIC_IER_OVRE);\n\n\treturn 0;\n}\n\nstatic void atmel_pdmic_cpu_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\n\n\t \n\tregmap_write(dd->regmap, PDMIC_IDR, PDMIC_IDR_OVRE);\n\n\tclk_disable_unprepare(dd->gclk);\n\tclk_disable_unprepare(dd->pclk);\n}\n\nstatic int atmel_pdmic_cpu_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = regmap_read(dd->regmap, PDMIC_CDR, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret = snd_soc_component_update_bits(component, PDMIC_CR,\n\t\t\t\t\t    PDMIC_CR_ENPDM_MASK,\n\t\t\t\t\t    PDMIC_CR_ENPDM_DIS <<\n\t\t\t\t\t    PDMIC_CR_ENPDM_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define ATMEL_PDMIC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\n \n#define ATMEL_PDMIC_MAX_BUF_SIZE  (64 * 1024)\n#define ATMEL_PDMIC_PREALLOC_BUF_SIZE  ATMEL_PDMIC_MAX_BUF_SIZE\n\nstatic const struct snd_pcm_hardware atmel_pdmic_hw = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP\n\t\t\t\t| SNDRV_PCM_INFO_MMAP_VALID\n\t\t\t\t| SNDRV_PCM_INFO_INTERLEAVED\n\t\t\t\t| SNDRV_PCM_INFO_RESUME\n\t\t\t\t| SNDRV_PCM_INFO_PAUSE,\n\t.formats\t\t= ATMEL_PDMIC_FORMATS,\n\t.buffer_bytes_max\t= ATMEL_PDMIC_MAX_BUF_SIZE,\n\t.period_bytes_min\t= 256,\n\t.period_bytes_max\t= 32 * 1024,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 256,\n};\n\nstatic int\natmel_pdmic_platform_configure_dma(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct dma_slave_config *slave_config)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\n\tint ret;\n\n\tret = snd_hwparams_to_dma_slave_config(substream, params,\n\t\t\t\t\t       slave_config);\n\tif (ret) {\n\t\tdev_err(dd->dev,\n\t\t\t\"hw params to dma slave configure failed\\n\");\n\t\treturn ret;\n\t}\n\n\tslave_config->src_addr\t\t= dd->phy_base + PDMIC_CDR;\n\tslave_config->src_maxburst\t= 1;\n\tslave_config->dst_maxburst\t= 1;\n\n\treturn 0;\n}\n\nstatic const struct snd_dmaengine_pcm_config\natmel_pdmic_dmaengine_pcm_config = {\n\t.prepare_slave_config\t= atmel_pdmic_platform_configure_dma,\n\t.pcm_hardware\t\t= &atmel_pdmic_hw,\n\t.prealloc_buffer_size\t= ATMEL_PDMIC_PREALLOC_BUF_SIZE,\n};\n\n \n \nstruct mic_gain {\n\tunsigned int dgain;\n\tunsigned int scale;\n};\n\n \nstatic const struct mic_gain mic_gain_table[] = {\n{    1, 15}, {    1, 14},                            \n{    3, 15}, {    1, 13}, {    3, 14}, {    1, 12},  \n{    5, 14}, {   13, 15},                            \n{    9, 14}, {   21, 15}, {   23, 15}, {   13, 14},  \n{   29, 15}, {   33, 15}, {   37, 15}, {   41, 15},  \n{   23, 14}, {   13, 13}, {   58, 15}, {   65, 15},  \n{   73, 15}, {   41, 14}, {   23, 13}, {   13, 12},  \n{   29, 13}, {   65, 14}, {   73, 14}, {   41, 13},  \n{   23, 12}, {  207, 15}, {   29, 12}, {   65, 13},  \n{   73, 13}, {   41, 12}, {   23, 11}, {  413, 15},  \n{  463, 15}, {  519, 15}, {  583, 15}, {  327, 14},  \n{  367, 14}, {  823, 15}, {  231, 13}, { 1036, 15},  \n{ 1163, 15}, { 1305, 15}, {  183, 12}, { 1642, 15},  \n{ 1843, 15}, { 2068, 15}, {  145, 11}, { 2603, 15},  \n{  365, 12}, { 3277, 15}, { 3677, 15}, { 4125, 15},  \n{ 4629, 15}, { 5193, 15}, { 5827, 15}, { 3269, 14},  \n{  917, 12}, { 8231, 15}, { 9235, 15}, { 5181, 14},  \n{11627, 15}, {13045, 15}, {14637, 15}, {16423, 15},  \n{18427, 15}, {20675, 15}, { 5799, 13}, {26029, 15},  \n{ 7301, 13}, {    1,  0}, {18383, 14}, {10313, 13},  \n{23143, 14}, {25967, 14}, {29135, 14}, {16345, 13},  \n{ 4585, 11}, {20577, 13}, { 1443,  9}, {25905, 13},  \n{14533, 12}, { 8153, 11}, { 2287,  9}, {20529, 12},  \n{11517, 11}, { 6461, 10}, {28997, 12}, { 4067,  9},  \n{18253, 11}, {   10,  0}, {22979, 11}, {25783, 11},  \n{28929, 11}, {32459, 11}, { 9105,  9}, {20431, 10},  \n{22925, 10}, {12861,  9}, { 7215,  8}, {16191,  9},  \n{ 9083,  8}, {20383,  9}, {11435,  8}, { 6145,  7},  \n{ 3599,  6}, {32305,  9}, {18123,  8}, {20335,  8},  \n{  713,  3}, {  100,  0}, { 7181,  6}, { 8057,  6},  \n{  565,  2}, {20287,  7}, {11381,  6}, {25539,  7},  \n{ 1791,  3}, { 4019,  4}, { 9019,  5}, {20239,  6},  \n{ 5677,  4}, {25479,  6}, { 7147,  4}, { 8019,  4},  \n{17995,  5}, {20191,  5}, {11327,  4}, {12709,  4},  \n{ 3565,  2}, { 1000,  0}, { 1122,  0}, { 1259,  0},  \n{ 2825,  1}, {12679,  3}, { 7113,  2}, { 7981,  2},  \n{ 8955,  2}, {20095,  3}, {22547,  3}, {12649,  2},  \n{28385,  3}, { 3981,  0}, {17867,  2}, {20047,  2},  \n{11247,  1}, {12619,  1}, {14159,  1}, {31773,  2},  \n{17825,  1}, {10000,  0}, {11220,  0}, {12589,  0},  \n{28251,  1}, {15849,  0}, {17783,  0}, {19953,  0},  \n{22387,  0}, {25119,  0}, {28184,  0}, {31623,  0},  \n};\n\nstatic const DECLARE_TLV_DB_RANGE(mic_gain_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-9000, 600, 0),\n\t2, 5, TLV_DB_SCALE_ITEM(-8100, 300, 0),\n\t6, 7, TLV_DB_SCALE_ITEM(-7000, 200, 0),\n\t8, ARRAY_SIZE(mic_gain_table)-1, TLV_DB_SCALE_ITEM(-6500, 100, 0),\n);\n\nstatic int pdmic_get_mic_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int dgain_val, scale_val;\n\tint i;\n\n\tdgain_val = (snd_soc_component_read(component, PDMIC_DSPR1) & PDMIC_DSPR1_DGAIN_MASK)\n\t\t    >> PDMIC_DSPR1_DGAIN_SHIFT;\n\n\tscale_val = (snd_soc_component_read(component, PDMIC_DSPR0) & PDMIC_DSPR0_SCALE_MASK)\n\t\t    >> PDMIC_DSPR0_SCALE_SHIFT;\n\n\tfor (i = 0; i < ARRAY_SIZE(mic_gain_table); i++) {\n\t\tif ((mic_gain_table[i].dgain == dgain_val) &&\n\t\t    (mic_gain_table[i].scale == scale_val))\n\t\t\tucontrol->value.integer.value[0] = i;\n\t}\n\n\treturn 0;\n}\n\nstatic int pdmic_put_mic_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint max = mc->max;\n\tunsigned int val;\n\tint ret;\n\n\tval = ucontrol->value.integer.value[0];\n\n\tif (val > max)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_component_update_bits(component, PDMIC_DSPR1, PDMIC_DSPR1_DGAIN_MASK,\n\t\t\t mic_gain_table[val].dgain << PDMIC_DSPR1_DGAIN_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, PDMIC_DSPR0, PDMIC_DSPR0_SCALE_MASK,\n\t\t\t mic_gain_table[val].scale << PDMIC_DSPR0_SCALE_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new atmel_pdmic_snd_controls[] = {\nSOC_SINGLE_EXT_TLV(\"Mic Capture Volume\", PDMIC_DSPR1, PDMIC_DSPR1_DGAIN_SHIFT,\n\t\t   ARRAY_SIZE(mic_gain_table)-1, 0,\n\t\t   pdmic_get_mic_volsw, pdmic_put_mic_volsw, mic_gain_tlv),\n\nSOC_SINGLE(\"High Pass Filter Switch\", PDMIC_DSPR0,\n\t   PDMIC_DSPR0_HPFBYP_SHIFT, 1, 1),\n\nSOC_SINGLE(\"SINCC Filter Switch\", PDMIC_DSPR0, PDMIC_DSPR0_SINBYP_SHIFT, 1, 1),\n};\n\nstatic int atmel_pdmic_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(component);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(card);\n\n\tsnd_soc_component_update_bits(component, PDMIC_DSPR1, PDMIC_DSPR1_OFFSET_MASK,\n\t\t     (u32)(dd->pdata->mic_offset << PDMIC_DSPR1_OFFSET_SHIFT));\n\n\treturn 0;\n}\n\n#define PDMIC_MR_PRESCAL_MAX_VAL 127\n\nstatic int\natmel_pdmic_cpu_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tunsigned int rate_min = substream->runtime->hw.rate_min;\n\tunsigned int rate_max = substream->runtime->hw.rate_max;\n\tint fs = params_rate(params);\n\tint bits = params_width(params);\n\tunsigned long pclk_rate, gclk_rate;\n\tunsigned int f_pdmic;\n\tu32 mr_val, dspr0_val, pclk_prescal, gclk_prescal;\n\n\tif (params_channels(params) != 1) {\n\t\tdev_err(component->dev,\n\t\t\t\"only supports one channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fs < rate_min) || (fs > rate_max)) {\n\t\tdev_err(component->dev,\n\t\t\t\"sample rate is %dHz, min rate is %dHz, max rate is %dHz\\n\",\n\t\t\tfs, rate_min, rate_max);\n\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (bits) {\n\tcase 16:\n\t\tdspr0_val = (PDMIC_DSPR0_SIZE_16_BITS\n\t\t\t     << PDMIC_DSPR0_SIZE_SHIFT);\n\t\tbreak;\n\tcase 32:\n\t\tdspr0_val = (PDMIC_DSPR0_SIZE_32_BITS\n\t\t\t     << PDMIC_DSPR0_SIZE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((fs << 7) > (rate_max << 6)) {\n\t\tf_pdmic = fs << 6;\n\t\tdspr0_val |= PDMIC_DSPR0_OSR_64 << PDMIC_DSPR0_OSR_SHIFT;\n\t} else {\n\t\tf_pdmic = fs << 7;\n\t\tdspr0_val |= PDMIC_DSPR0_OSR_128 << PDMIC_DSPR0_OSR_SHIFT;\n\t}\n\n\tpclk_rate = clk_get_rate(dd->pclk);\n\tgclk_rate = clk_get_rate(dd->gclk);\n\n\t \n\tpclk_prescal = (u32)(pclk_rate/(f_pdmic << 1)) - 1;\n\tgclk_prescal = (u32)(gclk_rate/(f_pdmic << 1)) - 1;\n\n\tif ((pclk_prescal > PDMIC_MR_PRESCAL_MAX_VAL) ||\n\t    (gclk_rate/((gclk_prescal + 1) << 1) <\n\t     pclk_rate/((pclk_prescal + 1) << 1))) {\n\t\tmr_val = gclk_prescal << PDMIC_MR_PRESCAL_SHIFT;\n\t\tmr_val |= PDMIC_MR_CLKS_GCK << PDMIC_MR_CLKS_SHIFT;\n\t} else {\n\t\tmr_val = pclk_prescal << PDMIC_MR_PRESCAL_SHIFT;\n\t\tmr_val |= PDMIC_MR_CLKS_PCK << PDMIC_MR_CLKS_SHIFT;\n\t}\n\n\tsnd_soc_component_update_bits(component, PDMIC_MR,\n\t\tPDMIC_MR_PRESCAL_MASK | PDMIC_MR_CLKS_MASK, mr_val);\n\n\tsnd_soc_component_update_bits(component, PDMIC_DSPR0,\n\t\tPDMIC_DSPR0_OSR_MASK | PDMIC_DSPR0_SIZE_MASK, dspr0_val);\n\n\treturn 0;\n}\n\nstatic int atmel_pdmic_cpu_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd, struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tu32 val;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = PDMIC_CR_ENPDM_EN << PDMIC_CR_ENPDM_SHIFT;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = PDMIC_CR_ENPDM_DIS << PDMIC_CR_ENPDM_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, PDMIC_CR, PDMIC_CR_ENPDM_MASK, val);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops atmel_pdmic_cpu_dai_ops = {\n\t.startup\t= atmel_pdmic_cpu_dai_startup,\n\t.shutdown\t= atmel_pdmic_cpu_dai_shutdown,\n\t.prepare\t= atmel_pdmic_cpu_dai_prepare,\n\t.hw_params\t= atmel_pdmic_cpu_dai_hw_params,\n\t.trigger\t= atmel_pdmic_cpu_dai_trigger,\n};\n\n\nstatic struct snd_soc_dai_driver atmel_pdmic_cpu_dai = {\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 1,\n\t\t.rates\t\t= SNDRV_PCM_RATE_KNOT,\n\t\t.formats\t= ATMEL_PDMIC_FORMATS,\n\t},\n\t.ops = &atmel_pdmic_cpu_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver atmel_pdmic_cpu_dai_component = {\n\t.name\t\t\t= \"atmel-pdmic\",\n\t.probe\t\t\t= atmel_pdmic_component_probe,\n\t.controls\t\t= atmel_pdmic_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(atmel_pdmic_snd_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic int atmel_pdmic_asoc_card_init(struct device *dev,\n\t\t\t\tstruct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct atmel_pdmic *dd = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link_component *comp;\n\n\tdai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);\n\tif (!dai_link)\n\t\treturn -ENOMEM;\n\n\tcomp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);\n\tif (!comp)\n\t\treturn -ENOMEM;\n\n\tdai_link->cpus\t\t= comp;\n\tdai_link->codecs\t= &asoc_dummy_dlc;\n\n\tdai_link->num_cpus\t= 1;\n\tdai_link->num_codecs\t= 1;\n\n\tdai_link->name\t\t\t= \"PDMIC\";\n\tdai_link->stream_name\t\t= \"PDMIC PCM\";\n\tdai_link->cpus->dai_name\t= dev_name(dev);\n\n\tcard->dai_link\t= dai_link;\n\tcard->num_links\t= 1;\n\tcard->name\t= dd->pdata->card_name;\n\tcard->dev\t= dev;\n\n\treturn 0;\n}\n\nstatic void atmel_pdmic_get_sample_rate(struct atmel_pdmic *dd,\n\tunsigned int *rate_min, unsigned int *rate_max)\n{\n\tu32 mic_min_freq = dd->pdata->mic_min_freq;\n\tu32 mic_max_freq = dd->pdata->mic_max_freq;\n\tu32 clk_max_rate = (u32)(clk_get_rate(dd->pclk) >> 1);\n\tu32 clk_min_rate = (u32)(clk_get_rate(dd->gclk) >> 8);\n\n\tif (mic_max_freq > clk_max_rate)\n\t\tmic_max_freq = clk_max_rate;\n\n\tif (mic_min_freq < clk_min_rate)\n\t\tmic_min_freq = clk_min_rate;\n\n\t*rate_min = DIV_ROUND_CLOSEST(mic_min_freq, 128);\n\t*rate_max = mic_max_freq >> 6;\n}\n\n \nstatic irqreturn_t atmel_pdmic_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_pdmic *dd = (struct atmel_pdmic *)dev_id;\n\tu32 pdmic_isr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(dd->regmap, PDMIC_ISR, &pdmic_isr);\n\n\tif (pdmic_isr & PDMIC_ISR_OVRE) {\n\t\tregmap_update_bits(dd->regmap, PDMIC_CR, PDMIC_CR_ENPDM_MASK,\n\t\t\t\t   PDMIC_CR_ENPDM_DIS << PDMIC_CR_ENPDM_SHIFT);\n\n\t\tsnd_pcm_stop_xrun(dd->substream);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \n#define ATMEL_PDMIC_REG_MAX    0x124\nstatic const struct regmap_config atmel_pdmic_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= ATMEL_PDMIC_REG_MAX,\n};\n\nstatic int atmel_pdmic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_pdmic *dd;\n\tstruct resource *res;\n\tvoid __iomem *io_base;\n\tconst struct atmel_pdmic_pdata *pdata;\n\tstruct snd_soc_card *card;\n\tunsigned int rate_min, rate_max;\n\tint ret;\n\n\tpdata = atmel_pdmic_dt_init(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tdd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tdd->pdata = pdata;\n\tdd->dev = dev;\n\n\tdd->irq = platform_get_irq(pdev, 0);\n\tif (dd->irq < 0)\n\t\treturn dd->irq;\n\n\tdd->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dd->pclk)) {\n\t\tret = PTR_ERR(dd->pclk);\n\t\tdev_err(dev, \"failed to get peripheral clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdd->gclk = devm_clk_get(dev, \"gclk\");\n\tif (IS_ERR(dd->gclk)) {\n\t\tret = PTR_ERR(dd->gclk);\n\t\tdev_err(dev, \"failed to get GCK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_set_rate(dd->gclk, clk_get_rate(dd->pclk)/3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set GCK clock rate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tio_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tdd->phy_base = res->start;\n\n\tdd->regmap = devm_regmap_init_mmio(dev, io_base,\n\t\t\t\t\t   &atmel_pdmic_regmap_config);\n\tif (IS_ERR(dd->regmap)) {\n\t\tret = PTR_ERR(dd->regmap);\n\t\tdev_err(dev, \"failed to init register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret =  devm_request_irq(dev, dd->irq, atmel_pdmic_interrupt, 0,\n\t\t\t\t\"PDMIC\", (void *)dd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register ISR for IRQ %u (ret=%i)\\n\",\n\t\t\tdd->irq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tatmel_pdmic_get_sample_rate(dd, &rate_min, &rate_max);\n\n\t \n\tatmel_pdmic_cpu_dai.capture.rate_min = rate_min;\n\tatmel_pdmic_cpu_dai.capture.rate_max = rate_max;\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t\t\t      &atmel_pdmic_cpu_dai_component,\n\t\t\t\t\t      &atmel_pdmic_cpu_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register CPU DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_snd_dmaengine_pcm_register(dev,\n\t\t\t\t\t     &atmel_pdmic_dmaengine_pcm_config,\n\t\t\t\t\t     0);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register platform: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_codec;\n\t}\n\n\tsnd_soc_card_set_drvdata(card, dd);\n\n\tret = atmel_pdmic_asoc_card_init(dev, card);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init sound card: %d\\n\", ret);\n\t\tgoto unregister_codec;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register sound card: %d\\n\", ret);\n\t\tgoto unregister_codec;\n\t}\n\n\treturn 0;\n\nunregister_codec:\n\treturn ret;\n}\n\nstatic struct platform_driver atmel_pdmic_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"atmel-pdmic\",\n\t\t.of_match_table\t= atmel_pdmic_of_match,\n\t\t.pm\t\t= &snd_soc_pm_ops,\n\t},\n\t.probe\t= atmel_pdmic_probe,\n};\nmodule_platform_driver(atmel_pdmic_driver);\n\nMODULE_DESCRIPTION(\"Atmel PDMIC driver under ALSA SoC architecture\");\nMODULE_AUTHOR(\"Songjun Wu <songjun.wu@atmel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}