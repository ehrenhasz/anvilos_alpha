{
  "module_name": "mchp-spdiftx.c",
  "hash_id": "373e70b3472bda7601f4a87bcd09da99c0219efc3223d3150e2588e8c0bddd98",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/mchp-spdiftx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#include <sound/asoundef.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n \n#define SPDIFTX_CR\t\t\t0x00\t \n#define SPDIFTX_MR\t\t\t0x04\t \n#define SPDIFTX_CDR\t\t\t0x0C\t \n\n#define SPDIFTX_IER\t\t\t0x14\t \n#define SPDIFTX_IDR\t\t\t0x18\t \n#define SPDIFTX_IMR\t\t\t0x1C\t \n#define SPDIFTX_ISR\t\t\t0x20\t \n\n#define SPDIFTX_CH1UD(reg)\t(0x50 + (reg) * 4)\t \n#define SPDIFTX_CH1S(reg)\t(0x80 + (reg) * 4)\t \n\n#define SPDIFTX_VERSION\t\t\t0xF0\n\n \n#define SPDIFTX_CR_SWRST\t\tBIT(0)\t \n#define SPDIFTX_CR_FCLR\t\t\tBIT(1)\t \n\n \n \n#define SPDIFTX_MR_TXEN_MASK\t\tGENMASK(0, 0)\n#define SPDIFTX_MR_TXEN_DISABLE\t\t(0 << 0)\n#define SPDIFTX_MR_TXEN_ENABLE\t\t(1 << 0)\n\n \n#define SPDIFTX_MR_MULTICH_MASK\t\tGENAMSK(1, 1)\n#define SPDIFTX_MR_MULTICH_MONO\t\t(0 << 1)\n#define SPDIFTX_MR_MULTICH_DUAL\t\t(1 << 1)\n\n \n#define SPDIFTX_MR_ENDIAN_MASK\t\tGENMASK(2, 2)\n#define SPDIFTX_MR_ENDIAN_LITTLE\t(0 << 2)\n#define SPDIFTX_MR_ENDIAN_BIG\t\t(1 << 2)\n\n \n#define SPDIFTX_MR_JUSTIFY_MASK\t\tGENMASK(3, 3)\n#define SPDIFTX_MR_JUSTIFY_LSB\t\t(0 << 3)\n#define SPDIFTX_MR_JUSTIFY_MSB\t\t(1 << 3)\n\n \n#define SPDIFTX_MR_CMODE_MASK\t\t\tGENMASK(5, 4)\n#define SPDIFTX_MR_CMODE_INDEX_ACCESS\t\t(0 << 4)\n#define SPDIFTX_MR_CMODE_TOGGLE_ACCESS\t\t(1 << 4)\n#define SPDIFTX_MR_CMODE_INTERLVD_ACCESS\t(2 << 4)\n\n \n#define SPDIFTX_MR_VBPS_MASK\t\tGENMASK(13, 8)\n\n \n#define SPDIFTX_MR_CHUNK_MASK\t\tGENMASK(19, 16)\n\n \n#define SPDIFTX_MR_VALID1\t\t\tBIT(24)\n#define SPDIFTX_MR_VALID2\t\t\tBIT(25)\n\n \n#define SPDIFTX_MR_DNFR_MASK\t\tGENMASK(27, 27)\n#define SPDIFTX_MR_DNFR_INVALID\t\t(0 << 27)\n#define SPDIFTX_MR_DNFR_VALID\t\t(1 << 27)\n\n \n#define SPDIFTX_MR_BPS_MASK\t\tGENMASK(29, 28)\n\n \n#define SPDIFTX_IR_TXRDY\t\tBIT(0)\n#define SPDIFTX_IR_TXEMPTY\t\tBIT(1)\n#define SPDIFTX_IR_TXFULL\t\tBIT(2)\n#define SPDIFTX_IR_TXCHUNK\t\tBIT(3)\n#define SPDIFTX_IR_TXUDR\t\tBIT(4)\n#define SPDIFTX_IR_TXOVR\t\tBIT(5)\n#define SPDIFTX_IR_CSRDY\t\tBIT(6)\n#define SPDIFTX_IR_UDRDY\t\tBIT(7)\n#define SPDIFTX_IR_TXRDYCH(ch)\t\tBIT((ch) + 8)\n#define SPDIFTX_IR_SECE\t\t\tBIT(10)\n#define SPDIFTX_IR_TXUDRCH(ch)\t\tBIT((ch) + 11)\n#define SPDIFTX_IR_BEND\t\t\tBIT(13)\n\nstatic bool mchp_spdiftx_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFTX_MR:\n\tcase SPDIFTX_IMR:\n\tcase SPDIFTX_ISR:\n\tcase SPDIFTX_CH1UD(0):\n\tcase SPDIFTX_CH1UD(1):\n\tcase SPDIFTX_CH1UD(2):\n\tcase SPDIFTX_CH1UD(3):\n\tcase SPDIFTX_CH1UD(4):\n\tcase SPDIFTX_CH1UD(5):\n\tcase SPDIFTX_CH1S(0):\n\tcase SPDIFTX_CH1S(1):\n\tcase SPDIFTX_CH1S(2):\n\tcase SPDIFTX_CH1S(3):\n\tcase SPDIFTX_CH1S(4):\n\tcase SPDIFTX_CH1S(5):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_spdiftx_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFTX_CR:\n\tcase SPDIFTX_MR:\n\tcase SPDIFTX_CDR:\n\tcase SPDIFTX_IER:\n\tcase SPDIFTX_IDR:\n\tcase SPDIFTX_CH1UD(0):\n\tcase SPDIFTX_CH1UD(1):\n\tcase SPDIFTX_CH1UD(2):\n\tcase SPDIFTX_CH1UD(3):\n\tcase SPDIFTX_CH1UD(4):\n\tcase SPDIFTX_CH1UD(5):\n\tcase SPDIFTX_CH1S(0):\n\tcase SPDIFTX_CH1S(1):\n\tcase SPDIFTX_CH1S(2):\n\tcase SPDIFTX_CH1S(3):\n\tcase SPDIFTX_CH1S(4):\n\tcase SPDIFTX_CH1S(5):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_spdiftx_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFTX_CDR:\n\tcase SPDIFTX_ISR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mchp_spdiftx_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = SPDIFTX_VERSION,\n\t.readable_reg = mchp_spdiftx_readable_reg,\n\t.writeable_reg = mchp_spdiftx_writeable_reg,\n\t.precious_reg = mchp_spdiftx_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\n#define SPDIFTX_GCLK_RATIO\t128\n\n#define SPDIFTX_CS_BITS\t\t192\n#define SPDIFTX_UD_BITS\t\t192\n\nstruct mchp_spdiftx_mixer_control {\n\tunsigned char\t\t\t\tch_stat[SPDIFTX_CS_BITS / 8];\n\tunsigned char\t\t\t\tuser_data[SPDIFTX_UD_BITS / 8];\n\tspinlock_t\t\t\t\tlock;  \n};\n\nstruct mchp_spdiftx_dev {\n\tstruct mchp_spdiftx_mixer_control\tcontrol;\n\tstruct snd_dmaengine_dai_dma_data\tplayback;\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct clk\t\t\t\t*pclk;\n\tstruct clk\t\t\t\t*gclk;\n\tunsigned int\t\t\t\tfmt;\n\tunsigned int\t\t\t\tsuspend_irq;\n};\n\nstatic inline int mchp_spdiftx_is_running(struct mchp_spdiftx_dev *dev)\n{\n\tu32 mr;\n\n\tregmap_read(dev->regmap, SPDIFTX_MR, &mr);\n\treturn !!(mr & SPDIFTX_MR_TXEN_ENABLE);\n}\n\nstatic void mchp_spdiftx_channel_status_write(struct mchp_spdiftx_dev *dev)\n{\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->ch_stat) / 4; i++) {\n\t\tval = (ctrl->ch_stat[(i * 4) + 0] << 0) |\n\t\t      (ctrl->ch_stat[(i * 4) + 1] << 8) |\n\t\t      (ctrl->ch_stat[(i * 4) + 2] << 16) |\n\t\t      (ctrl->ch_stat[(i * 4) + 3] << 24);\n\n\t\tregmap_write(dev->regmap, SPDIFTX_CH1S(i), val);\n\t}\n}\n\nstatic void mchp_spdiftx_user_data_write(struct mchp_spdiftx_dev *dev)\n{\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->user_data) / 4; i++) {\n\t\tval = (ctrl->user_data[(i * 4) + 0] << 0) |\n\t\t      (ctrl->user_data[(i * 4) + 1] << 8) |\n\t\t      (ctrl->user_data[(i * 4) + 2] << 16) |\n\t\t      (ctrl->user_data[(i * 4) + 3] << 24);\n\n\t\tregmap_write(dev->regmap, SPDIFTX_CH1UD(i), val);\n\t}\n}\n\nstatic irqreturn_t mchp_spdiftx_interrupt(int irq, void *dev_id)\n{\n\tstruct mchp_spdiftx_dev *dev = dev_id;\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tu32 sr, imr, pending, idr = 0;\n\n\tregmap_read(dev->regmap, SPDIFTX_ISR, &sr);\n\tregmap_read(dev->regmap, SPDIFTX_IMR, &imr);\n\tpending = sr & imr;\n\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\tif (pending & SPDIFTX_IR_TXUDR) {\n\t\tdev_warn(dev->dev, \"underflow detected\\n\");\n\t\tidr |= SPDIFTX_IR_TXUDR;\n\t}\n\n\tif (pending & SPDIFTX_IR_TXOVR) {\n\t\tdev_warn(dev->dev, \"overflow detected\\n\");\n\t\tidr |= SPDIFTX_IR_TXOVR;\n\t}\n\n\tif (pending & SPDIFTX_IR_UDRDY) {\n\t\tspin_lock(&ctrl->lock);\n\t\tmchp_spdiftx_user_data_write(dev);\n\t\tspin_unlock(&ctrl->lock);\n\t\tidr |= SPDIFTX_IR_UDRDY;\n\t}\n\n\tif (pending & SPDIFTX_IR_CSRDY) {\n\t\tspin_lock(&ctrl->lock);\n\t\tmchp_spdiftx_channel_status_write(dev);\n\t\tspin_unlock(&ctrl->lock);\n\t\tidr |= SPDIFTX_IR_CSRDY;\n\t}\n\n\tregmap_write(dev->regmap, SPDIFTX_IDR, idr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mchp_spdiftx_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_write(dev->regmap, SPDIFTX_CR,\n\t\t     SPDIFTX_CR_SWRST | SPDIFTX_CR_FCLR);\n\n\treturn 0;\n}\n\nstatic void mchp_spdiftx_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_write(dev->regmap, SPDIFTX_IDR, 0xffffffff);\n}\n\nstatic int mchp_spdiftx_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tint ret;\n\n\t \n\tspin_lock(&ctrl->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tregmap_write(dev->regmap, SPDIFTX_IER, dev->suspend_irq |\n\t\t\t     SPDIFTX_IR_TXUDR | SPDIFTX_IR_TXOVR);\n\t\tdev->suspend_irq = 0;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = regmap_update_bits(dev->regmap, SPDIFTX_MR, SPDIFTX_MR_TXEN_MASK,\n\t\t\t\t\t SPDIFTX_MR_TXEN_ENABLE);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tregmap_read(dev->regmap, SPDIFTX_IMR, &dev->suspend_irq);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tregmap_write(dev->regmap, SPDIFTX_IDR, dev->suspend_irq |\n\t\t\t     SPDIFTX_IR_TXUDR | SPDIFTX_IR_TXOVR);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = regmap_update_bits(dev->regmap, SPDIFTX_MR, SPDIFTX_MR_TXEN_MASK,\n\t\t\t\t\t SPDIFTX_MR_TXEN_DISABLE);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock(&ctrl->lock);\n\tif (ret)\n\t\tdev_err(dev->dev, \"unable to start/stop TX: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int mchp_spdiftx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tunsigned long flags;\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tu32 mr;\n\tunsigned int bps = params_physical_width(params) / 8;\n\tunsigned char aes3;\n\tint ret;\n\n\tdev_dbg(dev->dev, \"%s() rate=%u format=%#x width=%u channels=%u\\n\",\n\t\t__func__, params_rate(params), params_format(params),\n\t\tparams_width(params), params_channels(params));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tdev_err(dev->dev, \"Capture is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(dev->regmap, SPDIFTX_MR, &mr);\n\n\tif (mr & SPDIFTX_MR_TXEN_ENABLE) {\n\t\tdev_err(dev->dev, \"PCM already running\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tmr = SPDIFTX_MR_CMODE_TOGGLE_ACCESS | SPDIFTX_MR_JUSTIFY_LSB;\n\tdev->playback.maxburst = 1;\n\tswitch (params_channels(params)) {\n\tcase 1:\n\t\tmr |= SPDIFTX_MR_MULTICH_MONO;\n\t\tbreak;\n\tcase 2:\n\t\tmr |= SPDIFTX_MR_MULTICH_DUAL;\n\t\tif (bps > 2)\n\t\t\tdev->playback.maxburst = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported number of channels: %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\tmr |= FIELD_PREP(SPDIFTX_MR_CHUNK_MASK, dev->playback.maxburst);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 8);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 18);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 20);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 24);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 24);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_BE:\n\t\tmr |= SPDIFTX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tmr |= FIELD_PREP(SPDIFTX_MR_VBPS_MASK, 32);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported PCM format: %d\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tmr |= FIELD_PREP(SPDIFTX_MR_BPS_MASK, bps - 1);\n\n\tswitch (params_rate(params)) {\n\tcase 22050:\n\t\taes3 = IEC958_AES3_CON_FS_22050;\n\t\tbreak;\n\tcase 24000:\n\t\taes3 = IEC958_AES3_CON_FS_24000;\n\t\tbreak;\n\tcase 32000:\n\t\taes3 = IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\taes3 = IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\taes3 = IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\taes3 = IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\taes3 = IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 176400:\n\t\taes3 = IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 192000:\n\t\taes3 = IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tcase 8000:\n\tcase 11025:\n\tcase 16000:\n\tcase 64000:\n\t\taes3 = IEC958_AES3_CON_FS_NOTID;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported sample frequency: %u\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tctrl->ch_stat[3] &= ~IEC958_AES3_CON_FS;\n\tctrl->ch_stat[3] |= aes3;\n\tmchp_spdiftx_channel_status_write(dev);\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\t \n\tclk_disable_unprepare(dev->gclk);\n\n\tret = clk_set_rate(dev->gclk, params_rate(params) *\n\t\t\t\t      SPDIFTX_GCLK_RATIO);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"unable to change gclk rate to: rate %u * ratio %u\\n\",\n\t\t\tparams_rate(params), SPDIFTX_GCLK_RATIO);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(dev->gclk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"unable to enable gclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev->dev, \"%s(): GCLK set to %d\\n\", __func__,\n\t\tparams_rate(params) * SPDIFTX_GCLK_RATIO);\n\n\tregmap_write(dev->regmap, SPDIFTX_MR, mr);\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\treturn regmap_write(dev->regmap, SPDIFTX_CR,\n\t\t\t    SPDIFTX_CR_SWRST | SPDIFTX_CR_FCLR);\n}\n\n#define MCHP_SPDIFTX_RATES\tSNDRV_PCM_RATE_8000_192000\n\n#define MCHP_SPDIFTX_FORMATS\t(SNDRV_PCM_FMTBIT_S8 |\t\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_U16_BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S18_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S18_3BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_BE\t\\\n\t\t\t\t )\n\nstatic int mchp_spdiftx_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_cs_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *uvalue)\n{\n\tunsigned long flags;\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tmemcpy(uvalue->value.iec958.status, ctrl->ch_stat,\n\t       sizeof(ctrl->ch_stat));\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_cs_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *uvalue)\n{\n\tunsigned long flags;\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tint changed = 0;\n\tint i;\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->ch_stat); i++) {\n\t\tif (ctrl->ch_stat[i] != uvalue->value.iec958.status[i])\n\t\t\tchanged = 1;\n\t\tctrl->ch_stat[i] = uvalue->value.iec958.status[i];\n\t}\n\n\tif (changed) {\n\t\t \n\t\tif (mchp_spdiftx_is_running(dev)) {\n\t\t\t \n\t\t\tregmap_write(dev->regmap, SPDIFTX_IER,\n\t\t\t\t     SPDIFTX_IR_CSRDY);\n\t\t} else {\n\t\t\tmchp_spdiftx_channel_status_write(dev);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn changed;\n}\n\nstatic int mchp_spdiftx_cs_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tmemset(uvalue->value.iec958.status, 0xff,\n\t       sizeof(uvalue->value.iec958.status));\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_subcode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tmemcpy(uvalue->value.iec958.subcode, ctrl->user_data,\n\t       sizeof(ctrl->user_data));\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_subcode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uvalue)\n{\n\tunsigned long flags;\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdiftx_mixer_control *ctrl = &dev->control;\n\tint changed = 0;\n\tint i;\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->user_data); i++) {\n\t\tif (ctrl->user_data[i] != uvalue->value.iec958.subcode[i])\n\t\t\tchanged = 1;\n\n\t\tctrl->user_data[i] = uvalue->value.iec958.subcode[i];\n\t}\n\tif (changed) {\n\t\tif (mchp_spdiftx_is_running(dev)) {\n\t\t\t \n\t\t\tregmap_write(dev->regmap, SPDIFTX_IER,\n\t\t\t\t     SPDIFTX_IR_UDRDY);\n\t\t} else {\n\t\t\tmchp_spdiftx_user_data_write(dev);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new mchp_spdiftx_ctrls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdiftx_info,\n\t\t.get = mchp_spdiftx_cs_get,\n\t\t.put = mchp_spdiftx_cs_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, MASK),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdiftx_info,\n\t\t.get = mchp_spdiftx_cs_mask,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Subcode Playback Default\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = mchp_spdiftx_info,\n\t\t.get = mchp_spdiftx_subcode_get,\n\t\t.put = mchp_spdiftx_subcode_put,\n\t},\n};\n\nstatic int mchp_spdiftx_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdiftx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &dev->playback, NULL);\n\n\t \n\tsnd_soc_add_dai_controls(dai, mchp_spdiftx_ctrls,\n\t\t\t\t ARRAY_SIZE(mchp_spdiftx_ctrls));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mchp_spdiftx_dai_ops = {\n\t.probe\t\t= mchp_spdiftx_dai_probe,\n\t.startup\t= mchp_spdiftx_dai_startup,\n\t.shutdown\t= mchp_spdiftx_dai_shutdown,\n\t.trigger\t= mchp_spdiftx_trigger,\n\t.hw_params\t= mchp_spdiftx_hw_params,\n\t.hw_free\t= mchp_spdiftx_hw_free,\n};\n\nstatic struct snd_soc_dai_driver mchp_spdiftx_dai = {\n\t.name = \"mchp-spdiftx\",\n\t.playback = {\n\t\t.stream_name = \"S/PDIF Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MCHP_SPDIFTX_RATES,\n\t\t.formats = MCHP_SPDIFTX_FORMATS,\n\t},\n\t.ops = &mchp_spdiftx_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver mchp_spdiftx_component = {\n\t.name\t\t\t= \"mchp-spdiftx\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct of_device_id mchp_spdiftx_dt_ids[] = {\n\t{\n\t\t.compatible = \"microchip,sama7g5-spdiftx\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_spdiftx_dt_ids);\n\nstatic int mchp_spdiftx_runtime_suspend(struct device *dev)\n{\n\tstruct mchp_spdiftx_dev *spdiftx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(spdiftx->regmap, true);\n\n\tclk_disable_unprepare(spdiftx->gclk);\n\tclk_disable_unprepare(spdiftx->pclk);\n\n\treturn 0;\n}\n\nstatic int mchp_spdiftx_runtime_resume(struct device *dev)\n{\n\tstruct mchp_spdiftx_dev *spdiftx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(spdiftx->pclk);\n\tif (ret) {\n\t\tdev_err(spdiftx->dev,\n\t\t\t\"failed to enable the peripheral clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(spdiftx->gclk);\n\tif (ret) {\n\t\tdev_err(spdiftx->dev,\n\t\t\t\"failed to enable generic clock: %d\\n\", ret);\n\t\tgoto disable_pclk;\n\t}\n\n\tregcache_cache_only(spdiftx->regmap, false);\n\tregcache_mark_dirty(spdiftx->regmap);\n\tret = regcache_sync(spdiftx->regmap);\n\tif (ret) {\n\t\tregcache_cache_only(spdiftx->regmap, true);\n\t\tclk_disable_unprepare(spdiftx->gclk);\ndisable_pclk:\n\t\tclk_disable_unprepare(spdiftx->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mchp_spdiftx_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n\tRUNTIME_PM_OPS(mchp_spdiftx_runtime_suspend, mchp_spdiftx_runtime_resume,\n\t\t       NULL)\n};\n\nstatic int mchp_spdiftx_probe(struct platform_device *pdev)\n{\n\tstruct mchp_spdiftx_dev *dev;\n\tstruct resource *mem;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct mchp_spdiftx_mixer_control *ctrl;\n\tint irq;\n\tint err;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t       &mchp_spdiftx_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(&pdev->dev, irq, mchp_spdiftx_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdev->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dev->pclk)) {\n\t\terr = PTR_ERR(dev->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get the peripheral clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdev->gclk = devm_clk_get(&pdev->dev, \"gclk\");\n\tif (IS_ERR(dev->gclk)) {\n\t\terr = PTR_ERR(dev->gclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get the PMC generic clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tctrl = &dev->control;\n\tspin_lock_init(&ctrl->lock);\n\n\t \n\tctrl->ch_stat[0] = IEC958_AES0_CON_NOT_COPYRIGHT |\n\t\t\t   IEC958_AES0_CON_EMPHASIS_NONE;\n\n\tdev->dev = &pdev->dev;\n\tdev->regmap = regmap;\n\tplatform_set_drvdata(pdev, dev);\n\n\tpm_runtime_enable(dev->dev);\n\tif (!pm_runtime_enabled(dev->dev)) {\n\t\terr = mchp_spdiftx_runtime_resume(dev->dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdev->playback.addr = (dma_addr_t)mem->start + SPDIFTX_CDR;\n\tdev->playback.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\terr = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register PMC: %d\\n\", err);\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &mchp_spdiftx_component,\n\t\t\t\t\t      &mchp_spdiftx_dai, 1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register component: %d\\n\", err);\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\treturn 0;\n\npm_runtime_suspend:\n\tif (!pm_runtime_status_suspended(dev->dev))\n\t\tmchp_spdiftx_runtime_suspend(dev->dev);\n\tpm_runtime_disable(dev->dev);\n\n\treturn err;\n}\n\nstatic void mchp_spdiftx_remove(struct platform_device *pdev)\n{\n\tstruct mchp_spdiftx_dev *dev = platform_get_drvdata(pdev);\n\n\tif (!pm_runtime_status_suspended(dev->dev))\n\t\tmchp_spdiftx_runtime_suspend(dev->dev);\n\n\tpm_runtime_disable(dev->dev);\n}\n\nstatic struct platform_driver mchp_spdiftx_driver = {\n\t.probe\t= mchp_spdiftx_probe,\n\t.remove_new = mchp_spdiftx_remove,\n\t.driver\t= {\n\t\t.name\t= \"mchp_spdiftx\",\n\t\t.of_match_table = mchp_spdiftx_dt_ids,\n\t\t.pm = pm_ptr(&mchp_spdiftx_pm_ops)\n\t},\n};\n\nmodule_platform_driver(mchp_spdiftx_driver);\n\nMODULE_AUTHOR(\"Codrin Ciubotariu <codrin.ciubotariu@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip S/PDIF TX Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}