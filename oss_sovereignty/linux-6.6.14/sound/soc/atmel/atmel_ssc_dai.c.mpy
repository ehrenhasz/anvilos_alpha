{
  "module_name": "atmel_ssc_dai.c",
  "hash_id": "9abff576a64bce2438c0576fc95dc984e5a9c14b1c5336ab1cfab3a189dc6f15",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel_ssc_dai.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/atmel_pdc.h>\n\n#include <linux/atmel-ssc.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\n#include \"atmel-pcm.h\"\n#include \"atmel_ssc_dai.h\"\n\n\n#define NUM_SSC_DEVICES\t\t3\n\n \nstatic struct atmel_pdc_regs pdc_tx_reg = {\n\t.xpr\t\t= ATMEL_PDC_TPR,\n\t.xcr\t\t= ATMEL_PDC_TCR,\n\t.xnpr\t\t= ATMEL_PDC_TNPR,\n\t.xncr\t\t= ATMEL_PDC_TNCR,\n};\n\nstatic struct atmel_pdc_regs pdc_rx_reg = {\n\t.xpr\t\t= ATMEL_PDC_RPR,\n\t.xcr\t\t= ATMEL_PDC_RCR,\n\t.xnpr\t\t= ATMEL_PDC_RNPR,\n\t.xncr\t\t= ATMEL_PDC_RNCR,\n};\n\n \nstatic struct atmel_ssc_mask ssc_tx_mask = {\n\t.ssc_enable\t= SSC_BIT(CR_TXEN),\n\t.ssc_disable\t= SSC_BIT(CR_TXDIS),\n\t.ssc_endx\t= SSC_BIT(SR_ENDTX),\n\t.ssc_endbuf\t= SSC_BIT(SR_TXBUFE),\n\t.ssc_error\t= SSC_BIT(SR_OVRUN),\n\t.pdc_enable\t= ATMEL_PDC_TXTEN,\n\t.pdc_disable\t= ATMEL_PDC_TXTDIS,\n};\n\nstatic struct atmel_ssc_mask ssc_rx_mask = {\n\t.ssc_enable\t= SSC_BIT(CR_RXEN),\n\t.ssc_disable\t= SSC_BIT(CR_RXDIS),\n\t.ssc_endx\t= SSC_BIT(SR_ENDRX),\n\t.ssc_endbuf\t= SSC_BIT(SR_RXBUFF),\n\t.ssc_error\t= SSC_BIT(SR_OVRUN),\n\t.pdc_enable\t= ATMEL_PDC_RXTEN,\n\t.pdc_disable\t= ATMEL_PDC_RXTDIS,\n};\n\n\n \nstatic struct atmel_pcm_dma_params ssc_dma_params[NUM_SSC_DEVICES][2] = {\n\t{{\n\t.name\t\t= \"SSC0 PCM out\",\n\t.pdc\t\t= &pdc_tx_reg,\n\t.mask\t\t= &ssc_tx_mask,\n\t},\n\t{\n\t.name\t\t= \"SSC0 PCM in\",\n\t.pdc\t\t= &pdc_rx_reg,\n\t.mask\t\t= &ssc_rx_mask,\n\t} },\n\t{{\n\t.name\t\t= \"SSC1 PCM out\",\n\t.pdc\t\t= &pdc_tx_reg,\n\t.mask\t\t= &ssc_tx_mask,\n\t},\n\t{\n\t.name\t\t= \"SSC1 PCM in\",\n\t.pdc\t\t= &pdc_rx_reg,\n\t.mask\t\t= &ssc_rx_mask,\n\t} },\n\t{{\n\t.name\t\t= \"SSC2 PCM out\",\n\t.pdc\t\t= &pdc_tx_reg,\n\t.mask\t\t= &ssc_tx_mask,\n\t},\n\t{\n\t.name\t\t= \"SSC2 PCM in\",\n\t.pdc\t\t= &pdc_rx_reg,\n\t.mask\t\t= &ssc_rx_mask,\n\t} },\n};\n\n\nstatic struct atmel_ssc_info ssc_info[NUM_SSC_DEVICES] = {\n\t{\n\t.name\t\t= \"ssc0\",\n\t.dir_mask\t= SSC_DIR_MASK_UNUSED,\n\t.initialized\t= 0,\n\t},\n\t{\n\t.name\t\t= \"ssc1\",\n\t.dir_mask\t= SSC_DIR_MASK_UNUSED,\n\t.initialized\t= 0,\n\t},\n\t{\n\t.name\t\t= \"ssc2\",\n\t.dir_mask\t= SSC_DIR_MASK_UNUSED,\n\t.initialized\t= 0,\n\t},\n};\n\n\n \nstatic irqreturn_t atmel_ssc_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_ssc_info *ssc_p = dev_id;\n\tstruct atmel_pcm_dma_params *dma_params;\n\tu32 ssc_sr;\n\tu32 ssc_substream_mask;\n\tint i;\n\n\tssc_sr = (unsigned long)ssc_readl(ssc_p->ssc->regs, SR)\n\t\t\t& (unsigned long)ssc_readl(ssc_p->ssc->regs, IMR);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ssc_p->dma_params); i++) {\n\t\tdma_params = ssc_p->dma_params[i];\n\n\t\tif ((dma_params != NULL) &&\n\t\t\t(dma_params->dma_intr_handler != NULL)) {\n\t\t\tssc_substream_mask = (dma_params->mask->ssc_endx |\n\t\t\t\t\tdma_params->mask->ssc_endbuf);\n\t\t\tif (ssc_sr & ssc_substream_mask) {\n\t\t\t\tdma_params->dma_intr_handler(ssc_sr,\n\t\t\t\t\t\tdma_params->\n\t\t\t\t\t\tsubstream);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int atmel_ssc_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct atmel_ssc_info *ssc_p = rule->private;\n\tstruct ssc_device *ssc = ssc_p->ssc;\n\tstruct snd_interval *i = hw_param_interval(params, rule->var);\n\tstruct snd_interval t;\n\tstruct snd_ratnum r = {\n\t\t.den_min = 1,\n\t\t.den_max = 4095,\n\t\t.den_step = 1,\n\t};\n\tunsigned int num = 0, den = 0;\n\tint frame_size;\n\tint mck_div = 2;\n\tint ret;\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0)\n\t\treturn frame_size;\n\n\tswitch (ssc_p->daifmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tif ((ssc_p->dir_mask & SSC_DIR_MASK_CAPTURE)\n\t\t    && ssc->clk_from_rk_pin)\n\t\t\t \n\t\t\tmck_div = 3;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tif ((ssc_p->dir_mask & SSC_DIR_MASK_PLAYBACK)\n\t\t    && !ssc->clk_from_rk_pin)\n\t\t\t \n\t\t\tmck_div = 6;\n\t\tbreak;\n\t}\n\n\tswitch (ssc_p->daifmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tr.num = ssc_p->mck_rate / mck_div / frame_size;\n\n\t\tret = snd_interval_ratnum(i, 1, &r, &num, &den);\n\t\tif (ret >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\t\tparams->rate_num = num;\n\t\t\tparams->rate_den = den;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BC_FP:\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tt.min = 8000;\n\t\tt.max = ssc_p->mck_rate / mck_div / frame_size;\n\t\tt.openmin = t.openmax = 0;\n\t\tt.integer = 0;\n\t\tret = snd_interval_refine(i, &t);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n \nstatic int atmel_ssc_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct platform_device *pdev = to_platform_device(dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\tstruct atmel_pcm_dma_params *dma_params;\n\tint dir, dir_mask;\n\tint ret;\n\n\tpr_debug(\"atmel_ssc_startup: SSC_SR=0x%x\\n\",\n\t\tssc_readl(ssc_p->ssc->regs, SR));\n\n\t \n\tpr_debug(\"atmel_ssc_dai: Starting clock\\n\");\n\tret = clk_enable(ssc_p->ssc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tssc_p->mck_rate = clk_get_rate(ssc_p->ssc->clk);\n\n\t \n\tif (!ssc_p->initialized)\n\t\tssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdir = 0;\n\t\tdir_mask = SSC_DIR_MASK_PLAYBACK;\n\t} else {\n\t\tdir = 1;\n\t\tdir_mask = SSC_DIR_MASK_CAPTURE;\n\t}\n\n\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  atmel_ssc_hw_rule_rate,\n\t\t\t\t  ssc_p,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FRAME_BITS,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Failed to specify rate rule: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdma_params = &ssc_dma_params[pdev->id][dir];\n\tdma_params->ssc = ssc_p->ssc;\n\tdma_params->substream = substream;\n\n\tssc_p->dma_params[dir] = dma_params;\n\n\tsnd_soc_dai_set_dma_data(dai, substream, dma_params);\n\n\tif (ssc_p->dir_mask & dir_mask)\n\t\treturn -EBUSY;\n\n\tssc_p->dir_mask |= dir_mask;\n\n\treturn 0;\n}\n\n \nstatic void atmel_ssc_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct platform_device *pdev = to_platform_device(dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\tstruct atmel_pcm_dma_params *dma_params;\n\tint dir, dir_mask;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = 0;\n\telse\n\t\tdir = 1;\n\n\tdma_params = ssc_p->dma_params[dir];\n\n\tif (dma_params != NULL) {\n\t\tdma_params->ssc = NULL;\n\t\tdma_params->substream = NULL;\n\t\tssc_p->dma_params[dir] = NULL;\n\t}\n\n\tdir_mask = 1 << dir;\n\n\tssc_p->dir_mask &= ~dir_mask;\n\tif (!ssc_p->dir_mask) {\n\t\tif (ssc_p->initialized) {\n\t\t\tfree_irq(ssc_p->ssc->irq, ssc_p);\n\t\t\tssc_p->initialized = 0;\n\t\t}\n\n\t\t \n\t\tssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\n\t\t \n\t\tssc_p->cmr_div = ssc_p->tcmr_period = ssc_p->rcmr_period = 0;\n\t\tssc_p->forced_divider = 0;\n\t}\n\n\t \n\tpr_debug(\"atmel_ssc_dai: Stopping clock\\n\");\n\tclk_disable(ssc_p->ssc->clk);\n}\n\n\n \nstatic int atmel_ssc_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\tunsigned int fmt)\n{\n\tstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\n\tssc_p->daifmt = fmt;\n\treturn 0;\n}\n\n \nstatic int atmel_ssc_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,\n\tint div_id, int div)\n{\n\tstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\n\tswitch (div_id) {\n\tcase ATMEL_SSC_CMR_DIV:\n\t\t \n\t\tif (ssc_p->dir_mask !=\n\t\t\t(SSC_DIR_MASK_PLAYBACK | SSC_DIR_MASK_CAPTURE))\n\t\t\tssc_p->cmr_div = div;\n\t\telse if (ssc_p->cmr_div == 0)\n\t\t\tssc_p->cmr_div = div;\n\t\telse\n\t\t\tif (div != ssc_p->cmr_div)\n\t\t\t\treturn -EBUSY;\n\t\tssc_p->forced_divider |= BIT(ATMEL_SSC_CMR_DIV);\n\t\tbreak;\n\n\tcase ATMEL_SSC_TCMR_PERIOD:\n\t\tssc_p->tcmr_period = div;\n\t\tssc_p->forced_divider |= BIT(ATMEL_SSC_TCMR_PERIOD);\n\t\tbreak;\n\n\tcase ATMEL_SSC_RCMR_PERIOD:\n\t\tssc_p->rcmr_period = div;\n\t\tssc_p->forced_divider |= BIT(ATMEL_SSC_RCMR_PERIOD);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int atmel_ssc_cfs(struct atmel_ssc_info *ssc_p)\n{\n\tswitch (ssc_p->daifmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FP:\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int atmel_ssc_cbs(struct atmel_ssc_info *ssc_p)\n{\n\tswitch (ssc_p->daifmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FC:\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int atmel_ssc_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct platform_device *pdev = to_platform_device(dai->dev);\n\tint id = pdev->id;\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[id];\n\tstruct ssc_device *ssc = ssc_p->ssc;\n\tstruct atmel_pcm_dma_params *dma_params;\n\tint dir, channels, bits;\n\tu32 tfmr, rfmr, tcmr, rcmr;\n\tint ret;\n\tint fslen, fslen_ext, fs_osync, fs_edge;\n\tu32 cmr_div;\n\tu32 tcmr_period;\n\tu32 rcmr_period;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = 0;\n\telse\n\t\tdir = 1;\n\n\t \n\tcmr_div = ssc_p->cmr_div;\n\tif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_CMR_DIV)) &&\n\t    atmel_ssc_cbs(ssc_p)) {\n\t\tint bclk_rate = snd_soc_params_to_bclk(params);\n\n\t\tif (bclk_rate < 0) {\n\t\t\tdev_err(dai->dev, \"unable to calculate cmr_div: %d\\n\",\n\t\t\t\tbclk_rate);\n\t\t\treturn bclk_rate;\n\t\t}\n\n\t\tcmr_div = DIV_ROUND_CLOSEST(ssc_p->mck_rate, 2 * bclk_rate);\n\t}\n\n\t \n\ttcmr_period = ssc_p->tcmr_period;\n\trcmr_period = ssc_p->rcmr_period;\n\tif (atmel_ssc_cfs(ssc_p)) {\n\t\tint frame_size = snd_soc_params_to_frame_size(params);\n\n\t\tif (frame_size < 0) {\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"unable to calculate tx/rx cmr_period: %d\\n\",\n\t\t\t\tframe_size);\n\t\t\treturn frame_size;\n\t\t}\n\n\t\tif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_TCMR_PERIOD)))\n\t\t\ttcmr_period = frame_size / 2 - 1;\n\t\tif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_RCMR_PERIOD)))\n\t\t\trcmr_period = frame_size / 2 - 1;\n\t}\n\n\tdma_params = ssc_p->dma_params[dir];\n\n\tchannels = params_channels(params);\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tbits = 8;\n\t\tdma_params->pdc_xfer_size = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbits = 16;\n\t\tdma_params->pdc_xfer_size = 2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tbits = 24;\n\t\tdma_params->pdc_xfer_size = 4;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tbits = 32;\n\t\tdma_params->pdc_xfer_size = 4;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"atmel_ssc_dai: unsupported PCM format\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tfslen_ext = (bits - 1) / 16;\n\tfslen = (bits - 1) % 16;\n\n\tswitch (ssc_p->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfs_osync = SSC_FSOS_POSITIVE;\n\t\tfs_edge = SSC_START_RISING_RF;\n\n\t\trcmr =\t  SSC_BF(RCMR_STTDLY, 0);\n\t\ttcmr =\t  SSC_BF(TCMR_STTDLY, 0);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfs_osync = SSC_FSOS_NEGATIVE;\n\t\tfs_edge = SSC_START_FALLING_RF;\n\n\t\trcmr =\t  SSC_BF(RCMR_STTDLY, 1);\n\t\ttcmr =\t  SSC_BF(TCMR_STTDLY, 1);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\tfs_osync = SSC_FSOS_POSITIVE;\n\t\tfs_edge = SSC_START_RISING_RF;\n\t\tfslen = fslen_ext = 0;\n\n\t\trcmr =\t  SSC_BF(RCMR_STTDLY, 1);\n\t\ttcmr =\t  SSC_BF(TCMR_STTDLY, 1);\n\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"atmel_ssc_dai: unsupported DAI format 0x%x\\n\",\n\t\t\tssc_p->daifmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!atmel_ssc_cfs(ssc_p)) {\n\t\tfslen = fslen_ext = 0;\n\t\trcmr_period = tcmr_period = 0;\n\t\tfs_osync = SSC_FSOS_NONE;\n\t}\n\n\trcmr |=\t  SSC_BF(RCMR_START, fs_edge);\n\ttcmr |=\t  SSC_BF(TCMR_START, fs_edge);\n\n\tif (atmel_ssc_cbs(ssc_p)) {\n\t\t \n\t\trcmr |=\t  SSC_BF(RCMR_CKS, SSC_CKS_DIV)\n\t\t\t| SSC_BF(RCMR_CKO, SSC_CKO_NONE);\n\n\t\ttcmr |=\t  SSC_BF(TCMR_CKS, SSC_CKS_DIV)\n\t\t\t| SSC_BF(TCMR_CKO, SSC_CKO_CONTINUOUS);\n\t} else {\n\t\trcmr |=\t  SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\n\t\t\t\t\tSSC_CKS_PIN : SSC_CKS_CLOCK)\n\t\t\t| SSC_BF(RCMR_CKO, SSC_CKO_NONE);\n\n\t\ttcmr |=\t  SSC_BF(TCMR_CKS, ssc->clk_from_rk_pin ?\n\t\t\t\t\tSSC_CKS_CLOCK : SSC_CKS_PIN)\n\t\t\t| SSC_BF(TCMR_CKO, SSC_CKO_NONE);\n\t}\n\n\trcmr |=\t  SSC_BF(RCMR_PERIOD, rcmr_period)\n\t\t| SSC_BF(RCMR_CKI, SSC_CKI_RISING);\n\n\ttcmr |=   SSC_BF(TCMR_PERIOD, tcmr_period)\n\t\t| SSC_BF(TCMR_CKI, SSC_CKI_FALLING);\n\n\trfmr =    SSC_BF(RFMR_FSLEN_EXT, fslen_ext)\n\t\t| SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\n\t\t| SSC_BF(RFMR_FSOS, fs_osync)\n\t\t| SSC_BF(RFMR_FSLEN, fslen)\n\t\t| SSC_BF(RFMR_DATNB, (channels - 1))\n\t\t| SSC_BIT(RFMR_MSBF)\n\t\t| SSC_BF(RFMR_LOOP, 0)\n\t\t| SSC_BF(RFMR_DATLEN, (bits - 1));\n\n\ttfmr =    SSC_BF(TFMR_FSLEN_EXT, fslen_ext)\n\t\t| SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\n\t\t| SSC_BF(TFMR_FSDEN, 0)\n\t\t| SSC_BF(TFMR_FSOS, fs_osync)\n\t\t| SSC_BF(TFMR_FSLEN, fslen)\n\t\t| SSC_BF(TFMR_DATNB, (channels - 1))\n\t\t| SSC_BIT(TFMR_MSBF)\n\t\t| SSC_BF(TFMR_DATDEF, 0)\n\t\t| SSC_BF(TFMR_DATLEN, (bits - 1));\n\n\tif (fslen_ext && !ssc->pdata->has_fslen_ext) {\n\t\tdev_err(dai->dev, \"sample size %d is too large for SSC device\\n\",\n\t\t\tbits);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"atmel_ssc_hw_params: \"\n\t\t\t\"RCMR=%08x RFMR=%08x TCMR=%08x TFMR=%08x\\n\",\n\t\t\trcmr, rfmr, tcmr, tfmr);\n\n\tif (!ssc_p->initialized) {\n\t\tif (!ssc_p->ssc->pdata->use_dma) {\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_RPR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_RCR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_RNPR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_RNCR, 0);\n\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_TPR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_TCR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_TNPR, 0);\n\t\t\tssc_writel(ssc_p->ssc->regs, PDC_TNCR, 0);\n\t\t}\n\n\t\tret = request_irq(ssc_p->ssc->irq, atmel_ssc_interrupt, 0,\n\t\t\t\tssc_p->name, ssc_p);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"atmel_ssc_dai: request_irq failure\\n\");\n\t\t\tpr_debug(\"Atmel_ssc_dai: Stopping clock\\n\");\n\t\t\tclk_disable(ssc_p->ssc->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tssc_p->initialized = 1;\n\t}\n\n\t \n\tssc_writel(ssc_p->ssc->regs, CMR, cmr_div);\n\n\t \n\tssc_writel(ssc_p->ssc->regs, RCMR, rcmr);\n\tssc_writel(ssc_p->ssc->regs, RFMR, rfmr);\n\n\t \n\tssc_writel(ssc_p->ssc->regs, TCMR, tcmr);\n\tssc_writel(ssc_p->ssc->regs, TFMR, tfmr);\n\n\tpr_debug(\"atmel_ssc_dai,hw_params: SSC initialized\\n\");\n\treturn 0;\n}\n\n\nstatic int atmel_ssc_prepare(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct platform_device *pdev = to_platform_device(dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\tstruct atmel_pcm_dma_params *dma_params;\n\tint dir;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = 0;\n\telse\n\t\tdir = 1;\n\n\tdma_params = ssc_p->dma_params[dir];\n\n\tssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\n\tssc_writel(ssc_p->ssc->regs, IDR, dma_params->mask->ssc_error);\n\n\tpr_debug(\"%s enabled SSC_SR=0x%08x\\n\",\n\t\t\tdir ? \"receive\" : \"transmit\",\n\t\t\tssc_readl(ssc_p->ssc->regs, SR));\n\treturn 0;\n}\n\nstatic int atmel_ssc_trigger(struct snd_pcm_substream *substream,\n\t\t\t     int cmd, struct snd_soc_dai *dai)\n{\n\tstruct platform_device *pdev = to_platform_device(dai->dev);\n\tstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\n\tstruct atmel_pcm_dma_params *dma_params;\n\tint dir;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = 0;\n\telse\n\t\tdir = 1;\n\n\tdma_params = ssc_p->dma_params[dir];\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_enable);\n\t\tbreak;\n\tdefault:\n\t\tssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_ssc_suspend(struct snd_soc_component *component)\n{\n\tstruct atmel_ssc_info *ssc_p;\n\tstruct platform_device *pdev = to_platform_device(component->dev);\n\n\tif (!snd_soc_component_active(component))\n\t\treturn 0;\n\n\tssc_p = &ssc_info[pdev->id];\n\n\t \n\tssc_p->ssc_state.ssc_sr = ssc_readl(ssc_p->ssc->regs, SR);\n\tssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_TXDIS) | SSC_BIT(CR_RXDIS));\n\n\t \n\tssc_p->ssc_state.ssc_imr = ssc_readl(ssc_p->ssc->regs, IMR);\n\tssc_writel(ssc_p->ssc->regs, IDR, ssc_p->ssc_state.ssc_imr);\n\n\tssc_p->ssc_state.ssc_cmr = ssc_readl(ssc_p->ssc->regs, CMR);\n\tssc_p->ssc_state.ssc_rcmr = ssc_readl(ssc_p->ssc->regs, RCMR);\n\tssc_p->ssc_state.ssc_rfmr = ssc_readl(ssc_p->ssc->regs, RFMR);\n\tssc_p->ssc_state.ssc_tcmr = ssc_readl(ssc_p->ssc->regs, TCMR);\n\tssc_p->ssc_state.ssc_tfmr = ssc_readl(ssc_p->ssc->regs, TFMR);\n\n\treturn 0;\n}\n\nstatic int atmel_ssc_resume(struct snd_soc_component *component)\n{\n\tstruct atmel_ssc_info *ssc_p;\n\tstruct platform_device *pdev = to_platform_device(component->dev);\n\tu32 cr;\n\n\tif (!snd_soc_component_active(component))\n\t\treturn 0;\n\n\tssc_p = &ssc_info[pdev->id];\n\n\t \n\tssc_writel(ssc_p->ssc->regs, TFMR, ssc_p->ssc_state.ssc_tfmr);\n\tssc_writel(ssc_p->ssc->regs, TCMR, ssc_p->ssc_state.ssc_tcmr);\n\tssc_writel(ssc_p->ssc->regs, RFMR, ssc_p->ssc_state.ssc_rfmr);\n\tssc_writel(ssc_p->ssc->regs, RCMR, ssc_p->ssc_state.ssc_rcmr);\n\tssc_writel(ssc_p->ssc->regs, CMR, ssc_p->ssc_state.ssc_cmr);\n\n\t \n\tssc_writel(ssc_p->ssc->regs, IER, ssc_p->ssc_state.ssc_imr);\n\n\t \n\tcr = 0;\n\tcr |=\n\t    (ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_RXEN)) ? SSC_BIT(CR_RXEN) : 0;\n\tcr |=\n\t    (ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_TXEN)) ? SSC_BIT(CR_TXEN) : 0;\n\tssc_writel(ssc_p->ssc->regs, CR, cr);\n\n\treturn 0;\n}\n\n#define ATMEL_SSC_FORMATS (SNDRV_PCM_FMTBIT_S8     | SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops atmel_ssc_dai_ops = {\n\t.startup\t= atmel_ssc_startup,\n\t.shutdown\t= atmel_ssc_shutdown,\n\t.prepare\t= atmel_ssc_prepare,\n\t.trigger\t= atmel_ssc_trigger,\n\t.hw_params\t= atmel_ssc_hw_params,\n\t.set_fmt\t= atmel_ssc_set_dai_fmt,\n\t.set_clkdiv\t= atmel_ssc_set_dai_clkdiv,\n};\n\nstatic struct snd_soc_dai_driver atmel_ssc_dai = {\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 384000,\n\t\t\t.formats = ATMEL_SSC_FORMATS,},\n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 384000,\n\t\t\t.formats = ATMEL_SSC_FORMATS,},\n\t\t.ops = &atmel_ssc_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver atmel_ssc_component = {\n\t.name\t\t\t= \"atmel-ssc\",\n\t.suspend\t\t= pm_ptr(atmel_ssc_suspend),\n\t.resume\t\t\t= pm_ptr(atmel_ssc_resume),\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int asoc_ssc_init(struct device *dev)\n{\n\tstruct ssc_device *ssc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = devm_snd_soc_register_component(dev, &atmel_ssc_component,\n\t\t\t\t\t &atmel_ssc_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ssc->pdata->use_dma)\n\t\tret = atmel_pcm_dma_platform_register(dev);\n\telse\n\t\tret = atmel_pcm_pdc_platform_register(dev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register PCM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint atmel_ssc_set_audio(int ssc_id)\n{\n\tstruct ssc_device *ssc;\n\n\t \n\tssc = ssc_request(ssc_id);\n\tif (IS_ERR(ssc)) {\n\t\tpr_err(\"Unable to parent ASoC SSC DAI on SSC: %ld\\n\",\n\t\t\tPTR_ERR(ssc));\n\t\treturn PTR_ERR(ssc);\n\t} else {\n\t\tssc_info[ssc_id].ssc = ssc;\n\t}\n\n\treturn asoc_ssc_init(&ssc->pdev->dev);\n}\nEXPORT_SYMBOL_GPL(atmel_ssc_set_audio);\n\nvoid atmel_ssc_put_audio(int ssc_id)\n{\n\tstruct ssc_device *ssc = ssc_info[ssc_id].ssc;\n\n\tssc_free(ssc);\n}\nEXPORT_SYMBOL_GPL(atmel_ssc_put_audio);\n\n \nMODULE_AUTHOR(\"Sedji Gaouaou, sedji.gaouaou@atmel.com, www.atmel.com\");\nMODULE_DESCRIPTION(\"ATMEL SSC ASoC Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}