{
  "module_name": "atmel-pcm-dma.c",
  "hash_id": "358c7db44802d7e0c7a816a1bf7d9d5b7266a935458ccff082e71fb0d2d9fea3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel-pcm-dma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/atmel-ssc.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"atmel-pcm.h\"\n\n \nstatic const struct snd_pcm_hardware atmel_pcm_dma_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_RESUME |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE,\n\t.period_bytes_min\t= 256,\t\t \n\t.period_bytes_max\t= 2 * 0xffff,\t \n\t.periods_min\t\t= 8,\n\t.periods_max\t\t= 1024,\t\t \n\t.buffer_bytes_max\t= 512 * 1024,\n};\n\n \nstatic void atmel_pcm_dma_irq(u32 ssc_sr,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pcm_dma_params *prtd;\n\n\tprtd = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\tif (ssc_sr & prtd->mask->ssc_error) {\n\t\tif (snd_pcm_running(substream))\n\t\t\tpr_warn(\"atmel-pcm: buffer %s on %s (SSC_SR=%#x)\\n\",\n\t\t\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK\n\t\t\t\t? \"underrun\" : \"overrun\", prtd->name,\n\t\t\t\tssc_sr);\n\n\t\t \n\t\tssc_writex(prtd->ssc->regs, SSC_CR, prtd->mask->ssc_disable);\n\t\tsnd_pcm_stop_xrun(substream);\n\n\t\t \n\t\tssc_readx(prtd->ssc->regs, SSC_RHR);\n\t\tssc_readx(prtd->ssc->regs, SSC_SR);\n\t}\n}\n\nstatic int atmel_pcm_configure_dma(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct dma_slave_config *slave_config)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_pcm_dma_params *prtd;\n\tstruct ssc_device *ssc;\n\tint ret;\n\n\tprtd = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tssc = prtd->ssc;\n\n\tret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\n\tif (ret) {\n\t\tpr_err(\"atmel-pcm: hwparams to dma slave configure failed\\n\");\n\t\treturn ret;\n\t}\n\n\tslave_config->dst_addr = ssc->phybase + SSC_THR;\n\tslave_config->dst_maxburst = 1;\n\n\tslave_config->src_addr = ssc->phybase + SSC_RHR;\n\tslave_config->src_maxburst = 1;\n\n\tprtd->dma_intr_handler = atmel_pcm_dma_irq;\n\n\treturn 0;\n}\n\nstatic const struct snd_dmaengine_pcm_config atmel_dmaengine_pcm_config = {\n\t.prepare_slave_config = atmel_pcm_configure_dma,\n\t.pcm_hardware = &atmel_pcm_dma_hardware,\n\t.prealloc_buffer_size = 64 * 1024,\n};\n\nint atmel_pcm_dma_platform_register(struct device *dev)\n{\n\treturn devm_snd_dmaengine_pcm_register(dev,\n\t\t\t\t\t&atmel_dmaengine_pcm_config, 0);\n}\nEXPORT_SYMBOL(atmel_pcm_dma_platform_register);\n\nMODULE_AUTHOR(\"Bo Shen <voice.shen@atmel.com>\");\nMODULE_DESCRIPTION(\"Atmel DMA based PCM module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}