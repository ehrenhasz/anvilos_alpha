{
  "module_name": "atmel-classd.c",
  "hash_id": "ad44a331183ebb6719d644b5a59d90f634a59a192c2390b2224a81d74f0331d7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel-classd.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"atmel-classd.h\"\n\nstruct atmel_classd_pdata {\n\tbool non_overlap_enable;\n\tint non_overlap_time;\n\tint pwm_type;\n\tconst char *card_name;\n};\n\nstruct atmel_classd {\n\tdma_addr_t phy_base;\n\tstruct regmap *regmap;\n\tstruct clk *pclk;\n\tstruct clk *gclk;\n\tstruct device *dev;\n\tint irq;\n\tconst struct atmel_classd_pdata *pdata;\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id atmel_classd_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-classd\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_classd_of_match);\n\nstatic struct atmel_classd_pdata *atmel_classd_dt_init(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct atmel_classd_pdata *pdata;\n\tconst char *pwm_type_s;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device node not found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = of_property_read_string(np, \"atmel,pwm-type\", &pwm_type_s);\n\tif ((ret == 0) && (strcmp(pwm_type_s, \"diff\") == 0))\n\t\tpdata->pwm_type = CLASSD_MR_PWMTYP_DIFF;\n\telse\n\t\tpdata->pwm_type = CLASSD_MR_PWMTYP_SINGLE;\n\n\tret = of_property_read_u32(np,\n\t\t\t\"atmel,non-overlap-time\", &pdata->non_overlap_time);\n\tif (ret)\n\t\tpdata->non_overlap_enable = false;\n\telse\n\t\tpdata->non_overlap_enable = true;\n\n\tret = of_property_read_string(np, \"atmel,model\", &pdata->card_name);\n\tif (ret)\n\t\tpdata->card_name = \"CLASSD\";\n\n\treturn pdata;\n}\n#else\nstatic inline struct atmel_classd_pdata *\natmel_classd_dt_init(struct device *dev)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\n#define ATMEL_CLASSD_RATES (SNDRV_PCM_RATE_8000 \\\n\t\t\t| SNDRV_PCM_RATE_16000\t| SNDRV_PCM_RATE_22050 \\\n\t\t\t| SNDRV_PCM_RATE_32000\t| SNDRV_PCM_RATE_44100 \\\n\t\t\t| SNDRV_PCM_RATE_48000\t| SNDRV_PCM_RATE_88200 \\\n\t\t\t| SNDRV_PCM_RATE_96000)\n\nstatic const struct snd_pcm_hardware atmel_classd_hw = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP\n\t\t\t\t| SNDRV_PCM_INFO_MMAP_VALID\n\t\t\t\t| SNDRV_PCM_INFO_INTERLEAVED\n\t\t\t\t| SNDRV_PCM_INFO_RESUME\n\t\t\t\t| SNDRV_PCM_INFO_PAUSE,\n\t.formats\t\t= (SNDRV_PCM_FMTBIT_S16_LE),\n\t.rates\t\t\t= ATMEL_CLASSD_RATES,\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 96000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 64 * 1024,\n\t.period_bytes_min\t= 256,\n\t.period_bytes_max\t= 32 * 1024,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 256,\n};\n\n#define ATMEL_CLASSD_PREALLOC_BUF_SIZE  (64 * 1024)\n\n \nstatic int atmel_classd_cpu_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\n\tint err;\n\n\tregmap_write(dd->regmap, CLASSD_THR, 0x0);\n\n\terr = clk_prepare_enable(dd->pclk);\n\tif (err)\n\t\treturn err;\n\terr = clk_prepare_enable(dd->gclk);\n\tif (err) {\n\t\tclk_disable_unprepare(dd->pclk);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int\natmel_classd_platform_configure_dma(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct dma_slave_config *slave_config)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\n\n\tif (params_physical_width(params) != 16) {\n\t\tdev_err(dd->dev,\n\t\t\t\"only supports 16-bit audio data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_channels(params) == 1)\n\t\tslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse\n\t\tslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tslave_config->direction\t\t= DMA_MEM_TO_DEV;\n\tslave_config->dst_addr\t\t= dd->phy_base + CLASSD_THR;\n\tslave_config->dst_maxburst\t= 1;\n\tslave_config->src_maxburst\t= 1;\n\tslave_config->device_fc\t\t= false;\n\n\treturn 0;\n}\n\nstatic const struct snd_dmaengine_pcm_config\natmel_classd_dmaengine_pcm_config = {\n\t.prepare_slave_config\t= atmel_classd_platform_configure_dma,\n\t.pcm_hardware\t\t= &atmel_classd_hw,\n\t.prealloc_buffer_size\t= ATMEL_CLASSD_PREALLOC_BUF_SIZE,\n};\n\n \nstatic const char * const mono_mode_text[] = {\n\t\"mix\", \"sat\", \"left\", \"right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(classd_mono_mode_enum,\n\t\t\tCLASSD_INTPMR, CLASSD_INTPMR_MONO_MODE_SHIFT,\n\t\t\tmono_mode_text);\n\nstatic const char * const eqcfg_text[] = {\n\t\"Treble-12dB\", \"Treble-6dB\",\n\t\"Medium-8dB\", \"Medium-3dB\",\n\t\"Bass-12dB\", \"Bass-6dB\",\n\t\"0 dB\",\n\t\"Bass+6dB\", \"Bass+12dB\",\n\t\"Medium+3dB\", \"Medium+8dB\",\n\t\"Treble+6dB\", \"Treble+12dB\",\n};\n\nstatic const unsigned int eqcfg_value[] = {\n\tCLASSD_INTPMR_EQCFG_T_CUT_12, CLASSD_INTPMR_EQCFG_T_CUT_6,\n\tCLASSD_INTPMR_EQCFG_M_CUT_8, CLASSD_INTPMR_EQCFG_M_CUT_3,\n\tCLASSD_INTPMR_EQCFG_B_CUT_12, CLASSD_INTPMR_EQCFG_B_CUT_6,\n\tCLASSD_INTPMR_EQCFG_FLAT,\n\tCLASSD_INTPMR_EQCFG_B_BOOST_6, CLASSD_INTPMR_EQCFG_B_BOOST_12,\n\tCLASSD_INTPMR_EQCFG_M_BOOST_3, CLASSD_INTPMR_EQCFG_M_BOOST_8,\n\tCLASSD_INTPMR_EQCFG_T_BOOST_6, CLASSD_INTPMR_EQCFG_T_BOOST_12,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(classd_eqcfg_enum,\n\t\tCLASSD_INTPMR, CLASSD_INTPMR_EQCFG_SHIFT, 0xf,\n\t\teqcfg_text, eqcfg_value);\n\nstatic const DECLARE_TLV_DB_SCALE(classd_digital_tlv, -7800, 100, 1);\n\nstatic const struct snd_kcontrol_new atmel_classd_snd_controls[] = {\nSOC_DOUBLE_TLV(\"Playback Volume\", CLASSD_INTPMR,\n\t\tCLASSD_INTPMR_ATTL_SHIFT, CLASSD_INTPMR_ATTR_SHIFT,\n\t\t78, 1, classd_digital_tlv),\n\nSOC_SINGLE(\"Deemphasis Switch\", CLASSD_INTPMR,\n\t\tCLASSD_INTPMR_DEEMP_SHIFT, 1, 0),\n\nSOC_SINGLE(\"Mono Switch\", CLASSD_INTPMR, CLASSD_INTPMR_MONO_SHIFT, 1, 0),\n\nSOC_SINGLE(\"Swap Switch\", CLASSD_INTPMR, CLASSD_INTPMR_SWAP_SHIFT, 1, 0),\n\nSOC_ENUM(\"Mono Mode\", classd_mono_mode_enum),\n\nSOC_ENUM(\"EQ\", classd_eqcfg_enum),\n};\n\nstatic const char * const pwm_type[] = {\n\t\"Single ended\", \"Differential\"\n};\n\nstatic int atmel_classd_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(component);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(card);\n\tconst struct atmel_classd_pdata *pdata = dd->pdata;\n\tu32 mask, val;\n\n\tmask = CLASSD_MR_PWMTYP_MASK;\n\tval = pdata->pwm_type << CLASSD_MR_PWMTYP_SHIFT;\n\n\tmask |= CLASSD_MR_NON_OVERLAP_MASK;\n\tif (pdata->non_overlap_enable) {\n\t\tval |= (CLASSD_MR_NON_OVERLAP_EN\n\t\t\t<< CLASSD_MR_NON_OVERLAP_SHIFT);\n\n\t\tmask |= CLASSD_MR_NOVR_VAL_MASK;\n\t\tswitch (pdata->non_overlap_time) {\n\t\tcase 5:\n\t\t\tval |= (CLASSD_MR_NOVR_VAL_5NS\n\t\t\t\t<< CLASSD_MR_NOVR_VAL_SHIFT);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tval |= (CLASSD_MR_NOVR_VAL_10NS\n\t\t\t\t<< CLASSD_MR_NOVR_VAL_SHIFT);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tval |= (CLASSD_MR_NOVR_VAL_15NS\n\t\t\t\t<< CLASSD_MR_NOVR_VAL_SHIFT);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tval |= (CLASSD_MR_NOVR_VAL_20NS\n\t\t\t\t<< CLASSD_MR_NOVR_VAL_SHIFT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval |= (CLASSD_MR_NOVR_VAL_10NS\n\t\t\t\t<< CLASSD_MR_NOVR_VAL_SHIFT);\n\t\t\tdev_warn(component->dev,\n\t\t\t\t\"non-overlapping value %d is invalid, the default value 10 is specified\\n\",\n\t\t\t\tpdata->non_overlap_time);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_soc_component_update_bits(component, CLASSD_MR, mask, val);\n\n\tdev_info(component->dev,\n\t\t\"PWM modulation type is %s, non-overlapping is %s\\n\",\n\t\tpwm_type[pdata->pwm_type],\n\t\tpdata->non_overlap_enable?\"enabled\":\"disabled\");\n\n\treturn 0;\n}\n\nstatic int atmel_classd_component_resume(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(component);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(card);\n\n\treturn regcache_sync(dd->regmap);\n}\n\nstatic int atmel_classd_cpu_dai_mute_stream(struct snd_soc_dai *cpu_dai,\n\t\t\t\t\t    int mute, int direction)\n{\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tu32 mask, val;\n\n\tmask = CLASSD_MR_LMUTE_MASK | CLASSD_MR_RMUTE_MASK;\n\n\tif (mute)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tsnd_soc_component_update_bits(component, CLASSD_MR, mask, val);\n\n\treturn 0;\n}\n\n#define CLASSD_GCLK_RATE_11M2896_MPY_8 (112896 * 100 * 8)\n#define CLASSD_GCLK_RATE_12M288_MPY_8  (12288 * 1000 * 8)\n\nstatic struct {\n\tint rate;\n\tint sample_rate;\n\tint dsp_clk;\n\tunsigned long gclk_rate;\n} const sample_rates[] = {\n\t{ 8000,  CLASSD_INTPMR_FRAME_8K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_12M288, CLASSD_GCLK_RATE_12M288_MPY_8 },\n\t{ 16000, CLASSD_INTPMR_FRAME_16K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_12M288, CLASSD_GCLK_RATE_12M288_MPY_8 },\n\t{ 32000, CLASSD_INTPMR_FRAME_32K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_12M288, CLASSD_GCLK_RATE_12M288_MPY_8 },\n\t{ 48000, CLASSD_INTPMR_FRAME_48K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_12M288, CLASSD_GCLK_RATE_12M288_MPY_8 },\n\t{ 96000, CLASSD_INTPMR_FRAME_96K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_12M288, CLASSD_GCLK_RATE_12M288_MPY_8 },\n\t{ 22050, CLASSD_INTPMR_FRAME_22K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_11M2896, CLASSD_GCLK_RATE_11M2896_MPY_8 },\n\t{ 44100, CLASSD_INTPMR_FRAME_44K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_11M2896, CLASSD_GCLK_RATE_11M2896_MPY_8 },\n\t{ 88200, CLASSD_INTPMR_FRAME_88K,\n\tCLASSD_INTPMR_DSP_CLK_FREQ_11M2896, CLASSD_GCLK_RATE_11M2896_MPY_8 },\n};\n\nstatic int\natmel_classd_cpu_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tint fs;\n\tint i, best, best_val, cur_val, ret;\n\tu32 mask, val;\n\n\tfs = params_rate(params);\n\n\tbest = 0;\n\tbest_val = abs(fs - sample_rates[0].rate);\n\tfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\n\t\t \n\t\tcur_val = abs(fs - sample_rates[i].rate);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\n\tdev_dbg(component->dev,\n\t\t\"Selected SAMPLE_RATE of %dHz, GCLK_RATE of %ldHz\\n\",\n\t\tsample_rates[best].rate, sample_rates[best].gclk_rate);\n\n\tclk_disable_unprepare(dd->gclk);\n\n\tret = clk_set_rate(dd->gclk, sample_rates[best].gclk_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = CLASSD_INTPMR_DSP_CLK_FREQ_MASK | CLASSD_INTPMR_FRAME_MASK;\n\tval = (sample_rates[best].dsp_clk << CLASSD_INTPMR_DSP_CLK_FREQ_SHIFT)\n\t| (sample_rates[best].sample_rate << CLASSD_INTPMR_FRAME_SHIFT);\n\n\tsnd_soc_component_update_bits(component, CLASSD_INTPMR, mask, val);\n\n\treturn clk_prepare_enable(dd->gclk);\n}\n\nstatic void\natmel_classd_cpu_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(rtd->card);\n\n\tclk_disable_unprepare(dd->gclk);\n}\n\nstatic int atmel_classd_cpu_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_component *component = cpu_dai->component;\n\n\tsnd_soc_component_update_bits(component, CLASSD_MR,\n\t\t\t\tCLASSD_MR_LEN_MASK | CLASSD_MR_REN_MASK,\n\t\t\t\t(CLASSD_MR_LEN_DIS << CLASSD_MR_LEN_SHIFT)\n\t\t\t\t|(CLASSD_MR_REN_DIS << CLASSD_MR_REN_SHIFT));\n\n\treturn 0;\n}\n\nstatic int atmel_classd_cpu_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd, struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_component *component = cpu_dai->component;\n\tu32 mask, val;\n\n\tmask = CLASSD_MR_LEN_MASK | CLASSD_MR_REN_MASK;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = mask;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = (CLASSD_MR_LEN_DIS << CLASSD_MR_LEN_SHIFT)\n\t\t\t| (CLASSD_MR_REN_DIS << CLASSD_MR_REN_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, CLASSD_MR, mask, val);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops atmel_classd_cpu_dai_ops = {\n\t.startup        = atmel_classd_cpu_dai_startup,\n\t.shutdown       = atmel_classd_cpu_dai_shutdown,\n\t.mute_stream\t= atmel_classd_cpu_dai_mute_stream,\n\t.hw_params\t= atmel_classd_cpu_dai_hw_params,\n\t.prepare\t= atmel_classd_cpu_dai_prepare,\n\t.trigger\t= atmel_classd_cpu_dai_trigger,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver atmel_classd_cpu_dai = {\n\t.playback = {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= ATMEL_CLASSD_RATES,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &atmel_classd_cpu_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver atmel_classd_cpu_dai_component = {\n\t.name\t\t\t= \"atmel-classd\",\n\t.probe\t\t\t= atmel_classd_component_probe,\n\t.resume\t\t\t= atmel_classd_component_resume,\n\t.controls\t\t= atmel_classd_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(atmel_classd_snd_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic int atmel_classd_asoc_card_init(struct device *dev,\n\t\t\t\t\tstruct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct atmel_classd *dd = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link_component *comp;\n\n\tdai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);\n\tif (!dai_link)\n\t\treturn -ENOMEM;\n\n\tcomp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);\n\tif (!comp)\n\t\treturn -ENOMEM;\n\n\tdai_link->cpus\t\t= comp;\n\tdai_link->codecs\t= &asoc_dummy_dlc;\n\n\tdai_link->num_cpus\t= 1;\n\tdai_link->num_codecs\t= 1;\n\n\tdai_link->name\t\t\t= \"CLASSD\";\n\tdai_link->stream_name\t\t= \"CLASSD PCM\";\n\tdai_link->cpus->dai_name\t= dev_name(dev);\n\n\tcard->dai_link\t= dai_link;\n\tcard->num_links\t= 1;\n\tcard->name\t= dd->pdata->card_name;\n\tcard->dev\t= dev;\n\n\treturn 0;\n};\n\n \nstatic const struct reg_default atmel_classd_reg_defaults[] = {\n\t{ CLASSD_INTPMR,   0x00301212 },\n};\n\n#define ATMEL_CLASSD_REG_MAX    0xE4\nstatic const struct regmap_config atmel_classd_regmap_config = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n\t.max_register\t= ATMEL_CLASSD_REG_MAX,\n\n\t.cache_type\t\t= REGCACHE_FLAT,\n\t.reg_defaults\t\t= atmel_classd_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(atmel_classd_reg_defaults),\n};\n\nstatic int atmel_classd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_classd *dd;\n\tstruct resource *res;\n\tvoid __iomem *io_base;\n\tconst struct atmel_classd_pdata *pdata;\n\tstruct snd_soc_card *card;\n\tint ret;\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tpdata = atmel_classd_dt_init(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tdd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tdd->pdata = pdata;\n\n\tdd->irq = platform_get_irq(pdev, 0);\n\tif (dd->irq < 0)\n\t\treturn dd->irq;\n\n\tdd->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(dd->pclk)) {\n\t\tret = PTR_ERR(dd->pclk);\n\t\tdev_err(dev, \"failed to get peripheral clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdd->gclk = devm_clk_get(dev, \"gclk\");\n\tif (IS_ERR(dd->gclk)) {\n\t\tret = PTR_ERR(dd->gclk);\n\t\tdev_err(dev, \"failed to get GCK clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tio_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tdd->phy_base = res->start;\n\tdd->dev = dev;\n\n\tdd->regmap = devm_regmap_init_mmio(dev, io_base,\n\t\t\t\t\t&atmel_classd_regmap_config);\n\tif (IS_ERR(dd->regmap)) {\n\t\tret = PTR_ERR(dd->regmap);\n\t\tdev_err(dev, \"failed to init register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t\t\t&atmel_classd_cpu_dai_component,\n\t\t\t\t\t&atmel_classd_cpu_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register CPU DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(dev,\n\t\t\t\t\t&atmel_classd_dmaengine_pcm_config,\n\t\t\t\t\t0);\n\tif (ret) {\n\t\tdev_err(dev, \"could not register platform: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_codec;\n\t}\n\n\tsnd_soc_card_set_drvdata(card, dd);\n\n\tret = atmel_classd_asoc_card_init(dev, card);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init sound card\\n\");\n\t\tgoto unregister_codec;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register sound card: %d\\n\", ret);\n\t\tgoto unregister_codec;\n\t}\n\n\treturn 0;\n\nunregister_codec:\n\treturn ret;\n}\n\nstatic struct platform_driver atmel_classd_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"atmel-classd\",\n\t\t.of_match_table\t= of_match_ptr(atmel_classd_of_match),\n\t\t.pm\t\t= &snd_soc_pm_ops,\n\t},\n\t.probe\t= atmel_classd_probe,\n};\nmodule_platform_driver(atmel_classd_driver);\n\nMODULE_DESCRIPTION(\"Atmel ClassD driver under ALSA SoC architecture\");\nMODULE_AUTHOR(\"Songjun Wu <songjun.wu@atmel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}