{
  "module_name": "atmel-i2s.c",
  "hash_id": "8fceadd9498316a51d637e671c36ca5b9f5575cd4b6aed71b0d599f05d428e2b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#define ATMEL_I2SC_MAX_TDM_CHANNELS\t8\n\n \n#define ATMEL_I2SC_CR\t\t0x0000\t \n#define ATMEL_I2SC_MR\t\t0x0004\t \n#define ATMEL_I2SC_SR\t\t0x0008\t \n#define ATMEL_I2SC_SCR\t\t0x000c\t \n#define ATMEL_I2SC_SSR\t\t0x0010\t \n#define ATMEL_I2SC_IER\t\t0x0014\t \n#define ATMEL_I2SC_IDR\t\t0x0018\t \n#define ATMEL_I2SC_IMR\t\t0x001c\t \n#define ATMEL_I2SC_RHR\t\t0x0020\t \n#define ATMEL_I2SC_THR\t\t0x0024\t \n#define ATMEL_I2SC_VERSION\t0x0028\t \n\n \n#define ATMEL_I2SC_CR_RXEN\tBIT(0)\t \n#define ATMEL_I2SC_CR_RXDIS\tBIT(1)\t \n#define ATMEL_I2SC_CR_CKEN\tBIT(2)\t \n#define ATMEL_I2SC_CR_CKDIS\tBIT(3)\t \n#define ATMEL_I2SC_CR_TXEN\tBIT(4)\t \n#define ATMEL_I2SC_CR_TXDIS\tBIT(5)\t \n#define ATMEL_I2SC_CR_SWRST\tBIT(7)\t \n\n \n#define ATMEL_I2SC_MR_MODE_MASK\t\tGENMASK(0, 0)\n#define ATMEL_I2SC_MR_MODE_SLAVE\t(0 << 0)\n#define ATMEL_I2SC_MR_MODE_MASTER\t(1 << 0)\n\n#define ATMEL_I2SC_MR_DATALENGTH_MASK\t\tGENMASK(4, 2)\n#define ATMEL_I2SC_MR_DATALENGTH_32_BITS\t(0 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_24_BITS\t(1 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_20_BITS\t(2 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_18_BITS\t(3 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_16_BITS\t(4 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_16_BITS_COMPACT\t(5 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_8_BITS\t\t(6 << 2)\n#define ATMEL_I2SC_MR_DATALENGTH_8_BITS_COMPACT\t(7 << 2)\n\n#define ATMEL_I2SC_MR_FORMAT_MASK\tGENMASK(7, 6)\n#define ATMEL_I2SC_MR_FORMAT_I2S\t(0 << 6)\n#define ATMEL_I2SC_MR_FORMAT_LJ\t\t(1 << 6)   \n#define ATMEL_I2SC_MR_FORMAT_TDM\t(2 << 6)\n#define ATMEL_I2SC_MR_FORMAT_TDMLJ\t(3 << 6)\n\n \n#define ATMEL_I2SC_MR_RXMONO\t\tBIT(8)\n\n \n#define ATMEL_I2SC_MR_RXDMA_MASK\tGENMASK(9, 9)\n#define ATMEL_I2SC_MR_RXDMA_SINGLE\t(0 << 9)   \n#define ATMEL_I2SC_MR_RXDMA_MULTIPLE\t(1 << 9)   \n\n \n#define ATMEL_I2SC_MR_RXLOOP\t\tBIT(10)\n\n \n#define ATMEL_I2SC_MR_TXMONO\t\tBIT(12)\n\n \n#define ATMEL_I2SC_MR_TXDMA_MASK\tGENMASK(13, 13)\n#define ATMEL_I2SC_MR_TXDMA_SINGLE\t(0 << 13)   \n#define ATMEL_I2SC_MR_TXDME_MULTIPLE\t(1 << 13)   \n\n \n#define ATMEL_I2SC_MR_TXSAME_MASK\tGENMASK(14, 14)\n#define ATMEL_I2SC_MR_TXSAME_ZERO\t(0 << 14)   \n#define ATMEL_I2SC_MR_TXSAME_PREVIOUS\t(1 << 14)   \n\n \n#define ATMEL_I2SC_MR_IMCKDIV_MASK\tGENMASK(21, 16)\n#define ATMEL_I2SC_MR_IMCKDIV(div) \\\n\t(((div) << 16) & ATMEL_I2SC_MR_IMCKDIV_MASK)\n\n \n#define ATMEL_I2SC_MR_IMCKFS_MASK\tGENMASK(29, 24)\n#define ATMEL_I2SC_MR_IMCKFS(fs) \\\n\t(((fs) << 24) & ATMEL_I2SC_MR_IMCKFS_MASK)\n\n \n#define ATMEL_I2SC_MR_IMCKMODE_MASK\tGENMASK(30, 30)\n \n#define ATMEL_I2SC_MR_IMCKMODE_I2SCK\t(0 << 30)\n \n#define ATMEL_I2SC_MR_IMCKMODE_I2SMCK\t(1 << 30)\n\n \n \n \n#define ATMEL_I2SC_MR_IWS\t\tBIT(31)\n\n \n#define ATMEL_I2SC_SR_RXEN\tBIT(0)\t \n#define ATMEL_I2SC_SR_RXRDY\tBIT(1)\t \n#define ATMEL_I2SC_SR_RXOR\tBIT(2)\t \n\n#define ATMEL_I2SC_SR_TXEN\tBIT(4)\t \n#define ATMEL_I2SC_SR_TXRDY\tBIT(5)\t \n#define ATMEL_I2SC_SR_TXUR\tBIT(6)\t \n\n \n#define ATMEL_I2SC_SR_RXORCH_MASK\tGENMASK(15, 8)\n#define ATMEL_I2SC_SR_RXORCH(ch)\t(1 << (((ch) & 0x7) + 8))\n\n \n#define ATMEL_I2SC_SR_TXURCH_MASK\tGENMASK(27, 20)\n#define ATMEL_I2SC_SR_TXURCH(ch)\t(1 << (((ch) & 0x7) + 20))\n\n \n#define ATMEL_I2SC_INT_RXRDY\tATMEL_I2SC_SR_RXRDY\n#define ATMEL_I2SC_INT_RXOR\tATMEL_I2SC_SR_RXOR\n#define ATMEL_I2SC_INT_TXRDY\tATMEL_I2SC_SR_TXRDY\n#define ATMEL_I2SC_INT_TXUR\tATMEL_I2SC_SR_TXUR\n\nstatic const struct regmap_config atmel_i2s_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = ATMEL_I2SC_VERSION,\n};\n\nstruct atmel_i2s_gck_param {\n\tint\t\tfs;\n\tunsigned long\tmck;\n\tint\t\timckdiv;\n\tint\t\timckfs;\n};\n\n#define I2S_MCK_12M288\t\t12288000UL\n#define I2S_MCK_11M2896\t\t11289600UL\n#define I2S_MCK_6M144\t\t6144000UL\n\n \nstatic const struct atmel_i2s_gck_param gck_params[] = {\n\t \n\t{  8000, I2S_MCK_6M144,  1, 47},\t \n\n\t \n\t{ 16000, I2S_MCK_12M288, 1, 47},\t \n\t{ 24000, I2S_MCK_12M288, 3, 63},\t \n\t{ 32000, I2S_MCK_12M288, 3, 47},\t \n\t{ 48000, I2S_MCK_12M288, 7, 63},\t \n\t{ 64000, I2S_MCK_12M288, 7, 47},\t \n\t{ 96000, I2S_MCK_12M288, 7, 31},\t \n\t{192000, I2S_MCK_12M288, 7, 15},\t \n\n\t \n\t{ 11025, I2S_MCK_11M2896, 1, 63},\t \n\t{ 22050, I2S_MCK_11M2896, 3, 63},\t \n\t{ 44100, I2S_MCK_11M2896, 7, 63},\t \n\t{ 88200, I2S_MCK_11M2896, 7, 31},\t \n\t{176400, I2S_MCK_11M2896, 7, 15},\t \n};\n\nstruct atmel_i2s_dev;\n\nstruct atmel_i2s_caps {\n\tint\t(*mck_init)(struct atmel_i2s_dev *, struct device_node *np);\n};\n\nstruct atmel_i2s_dev {\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct clk\t\t\t\t*pclk;\n\tstruct clk\t\t\t\t*gclk;\n\tstruct snd_dmaengine_dai_dma_data\tplayback;\n\tstruct snd_dmaengine_dai_dma_data\tcapture;\n\tunsigned int\t\t\t\tfmt;\n\tconst struct atmel_i2s_gck_param\t*gck_param;\n\tconst struct atmel_i2s_caps\t\t*caps;\n\tint\t\t\t\t\tclk_use_no;\n};\n\nstatic irqreturn_t atmel_i2s_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_i2s_dev *dev = dev_id;\n\tunsigned int sr, imr, pending, ch, mask;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tregmap_read(dev->regmap, ATMEL_I2SC_SR, &sr);\n\tregmap_read(dev->regmap, ATMEL_I2SC_IMR, &imr);\n\tpending = sr & imr;\n\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\tif (pending & ATMEL_I2SC_INT_RXOR) {\n\t\tmask = ATMEL_I2SC_SR_RXOR;\n\n\t\tfor (ch = 0; ch < ATMEL_I2SC_MAX_TDM_CHANNELS; ++ch) {\n\t\t\tif (sr & ATMEL_I2SC_SR_RXORCH(ch)) {\n\t\t\t\tmask |= ATMEL_I2SC_SR_RXORCH(ch);\n\t\t\t\tdev_err(dev->dev,\n\t\t\t\t\t\"RX overrun on channel %d\\n\", ch);\n\t\t\t}\n\t\t}\n\t\tregmap_write(dev->regmap, ATMEL_I2SC_SCR, mask);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (pending & ATMEL_I2SC_INT_TXUR) {\n\t\tmask = ATMEL_I2SC_SR_TXUR;\n\n\t\tfor (ch = 0; ch < ATMEL_I2SC_MAX_TDM_CHANNELS; ++ch) {\n\t\t\tif (sr & ATMEL_I2SC_SR_TXURCH(ch)) {\n\t\t\t\tmask |= ATMEL_I2SC_SR_TXURCH(ch);\n\t\t\t\tdev_err(dev->dev,\n\t\t\t\t\t\"TX underrun on channel %d\\n\", ch);\n\t\t\t}\n\t\t}\n\t\tregmap_write(dev->regmap, ATMEL_I2SC_SCR, mask);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n#define ATMEL_I2S_RATES\t\tSNDRV_PCM_RATE_8000_192000\n\n#define ATMEL_I2S_FORMATS\t(SNDRV_PCM_FMTBIT_S8 |\t\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S18_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int atmel_i2s_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct atmel_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tdev->fmt = fmt;\n\treturn 0;\n}\n\nstatic int atmel_i2s_prepare(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct atmel_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tunsigned int rhr, sr = 0;\n\n\tif (is_playback) {\n\t\tregmap_read(dev->regmap, ATMEL_I2SC_SR, &sr);\n\t\tif (sr & ATMEL_I2SC_SR_RXRDY) {\n\t\t\t \n\t\t\tdev_dbg(dev->dev, \"RXRDY is set\\n\");\n\t\t\tregmap_read(dev->regmap, ATMEL_I2SC_RHR, &rhr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_i2s_get_gck_param(struct atmel_i2s_dev *dev, int fs)\n{\n\tint i, best;\n\n\tif (!dev->gclk) {\n\t\tdev_err(dev->dev, \"cannot generate the I2S Master Clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev->gck_param = NULL;\n\tbest = INT_MAX;\n\tfor (i = 0; i < ARRAY_SIZE(gck_params); ++i) {\n\t\tconst struct atmel_i2s_gck_param *gck_param = &gck_params[i];\n\t\tint val = abs(fs - gck_param->fs);\n\n\t\tif (val < best) {\n\t\t\tbest = val;\n\t\t\tdev->gck_param = gck_param;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct atmel_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tunsigned int mr = 0, mr_mask;\n\tint ret;\n\n\tmr_mask = ATMEL_I2SC_MR_FORMAT_MASK | ATMEL_I2SC_MR_MODE_MASK |\n\t\tATMEL_I2SC_MR_DATALENGTH_MASK;\n\tif (is_playback)\n\t\tmr_mask |= ATMEL_I2SC_MR_TXMONO;\n\telse\n\t\tmr_mask |= ATMEL_I2SC_MR_RXMONO;\n\n\tswitch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmr |= ATMEL_I2SC_MR_FORMAT_I2S;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported bus format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tmr |= ATMEL_I2SC_MR_MODE_MASTER;\n\t\tret = atmel_i2s_get_gck_param(dev, params_rate(params));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tmr |= ATMEL_I2SC_MR_MODE_SLAVE;\n\t\tdev->gck_param = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported master/slave mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 1:\n\t\tif (is_playback)\n\t\t\tmr |= ATMEL_I2SC_MR_TXMONO;\n\t\telse\n\t\t\tmr |= ATMEL_I2SC_MR_RXMONO;\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported number of audio channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_8_BITS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_16_BITS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_18_BITS | ATMEL_I2SC_MR_IWS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_20_BITS | ATMEL_I2SC_MR_IWS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_24_BITS | ATMEL_I2SC_MR_IWS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_24_BITS;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tmr |= ATMEL_I2SC_MR_DATALENGTH_32_BITS;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported size/endianness for audio samples\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(dev->regmap, ATMEL_I2SC_MR, mr_mask, mr);\n}\n\nstatic int atmel_i2s_switch_mck_generator(struct atmel_i2s_dev *dev,\n\t\t\t\t\t  bool enabled)\n{\n\tunsigned int mr, mr_mask;\n\tunsigned long gclk_rate;\n\tint ret;\n\n\tmr = 0;\n\tmr_mask = (ATMEL_I2SC_MR_IMCKDIV_MASK |\n\t\t   ATMEL_I2SC_MR_IMCKFS_MASK |\n\t\t   ATMEL_I2SC_MR_IMCKMODE_MASK);\n\n\tif (!enabled) {\n\t\t \n\t\tret = regmap_write(dev->regmap, ATMEL_I2SC_CR,\n\t\t\t\t   ATMEL_I2SC_CR_CKDIS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(dev->regmap, ATMEL_I2SC_MR,\n\t\t\t\t\t mr_mask, mr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tclk_disable_unprepare(dev->gclk);\n\n\t\treturn 0;\n\t}\n\n\tif (!dev->gck_param)\n\t\treturn -EINVAL;\n\n\tgclk_rate = dev->gck_param->mck * (dev->gck_param->imckdiv + 1);\n\n\tret = clk_set_rate(dev->gclk, gclk_rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(dev->gclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmr |= ATMEL_I2SC_MR_IMCKDIV(dev->gck_param->imckdiv);\n\tmr |= ATMEL_I2SC_MR_IMCKFS(dev->gck_param->imckfs);\n\tmr |= ATMEL_I2SC_MR_IMCKMODE_I2SMCK;\n\tret = regmap_update_bits(dev->regmap, ATMEL_I2SC_MR, mr_mask, mr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_write(dev->regmap, ATMEL_I2SC_CR,\n\t\t\t    ATMEL_I2SC_CR_CKEN);\n}\n\nstatic int atmel_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct atmel_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tbool is_master, mck_enabled;\n\tunsigned int cr, mr;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tcr = is_playback ? ATMEL_I2SC_CR_TXEN : ATMEL_I2SC_CR_RXEN;\n\t\tmck_enabled = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tcr = is_playback ? ATMEL_I2SC_CR_TXDIS : ATMEL_I2SC_CR_RXDIS;\n\t\tmck_enabled = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = regmap_read(dev->regmap, ATMEL_I2SC_MR, &mr);\n\tif (err)\n\t\treturn err;\n\tis_master = (mr & ATMEL_I2SC_MR_MODE_MASK) == ATMEL_I2SC_MR_MODE_MASTER;\n\n\t \n\tif (is_master && mck_enabled) {\n\t\tif (!dev->clk_use_no) {\n\t\t\terr = atmel_i2s_switch_mck_generator(dev, true);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdev->clk_use_no++;\n\t}\n\n\terr = regmap_write(dev->regmap, ATMEL_I2SC_CR, cr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (is_master && !mck_enabled) {\n\t\tif (dev->clk_use_no == 1) {\n\t\t\terr = atmel_i2s_switch_mck_generator(dev, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdev->clk_use_no--;\n\t}\n\n\treturn err;\n}\n\nstatic int atmel_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct atmel_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &dev->playback, &dev->capture);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops atmel_i2s_dai_ops = {\n\t.probe\t\t= atmel_i2s_dai_probe,\n\t.prepare\t= atmel_i2s_prepare,\n\t.trigger\t= atmel_i2s_trigger,\n\t.hw_params\t= atmel_i2s_hw_params,\n\t.set_fmt\t= atmel_i2s_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver atmel_i2s_dai = {\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = ATMEL_I2S_RATES,\n\t\t.formats = ATMEL_I2S_FORMATS,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = ATMEL_I2S_RATES,\n\t\t.formats = ATMEL_I2S_FORMATS,\n\t},\n\t.ops = &atmel_i2s_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n};\n\nstatic const struct snd_soc_component_driver atmel_i2s_component = {\n\t.name\t\t\t= \"atmel-i2s\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int atmel_i2s_sama5d2_mck_init(struct atmel_i2s_dev *dev,\n\t\t\t\t      struct device_node *np)\n{\n\tstruct clk *muxclk;\n\tint err;\n\n\tif (!dev->gclk)\n\t\treturn 0;\n\n\t \n\tmuxclk = devm_clk_get(dev->dev, \"muxclk\");\n\tif (IS_ERR(muxclk)) {\n\t\terr = PTR_ERR(muxclk);\n\t\tif (err == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(dev->dev,\n\t\t\t\"failed to get the I2S clock control: %d\\n\", err);\n\t\treturn 0;\n\t}\n\n\treturn clk_set_parent(muxclk, dev->gclk);\n}\n\nstatic const struct atmel_i2s_caps atmel_i2s_sama5d2_caps = {\n\t.mck_init = atmel_i2s_sama5d2_mck_init,\n};\n\nstatic const struct of_device_id atmel_i2s_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-i2s\",\n\t\t.data = (void *)&atmel_i2s_sama5d2_caps,\n\t},\n\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_i2s_dt_ids);\n\nstatic int atmel_i2s_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct atmel_i2s_dev *dev;\n\tstruct resource *mem;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint irq;\n\tint err;\n\tunsigned int pcm_flags = 0;\n\tunsigned int version;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tmatch = of_match_node(atmel_i2s_dt_ids, np);\n\tif (match)\n\t\tdev->caps = match->data;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t       &atmel_i2s_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(&pdev->dev, irq, atmel_i2s_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdev->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dev->pclk)) {\n\t\terr = PTR_ERR(dev->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get the peripheral clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdev->gclk = devm_clk_get(&pdev->dev, \"gclk\");\n\tif (IS_ERR(dev->gclk)) {\n\t\tif (PTR_ERR(dev->gclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\t \n\t\tdev->gclk = NULL;\n\t}\n\tdev->dev = &pdev->dev;\n\tdev->regmap = regmap;\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\tif (dev->caps && dev->caps->mck_init) {\n\t\terr = dev->caps->mck_init(dev, np);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = clk_prepare_enable(dev->pclk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tregmap_read(dev->regmap, ATMEL_I2SC_VERSION, &version);\n\tdev_info(&pdev->dev, \"hw version: %#x\\n\", version);\n\n\t \n\tregmap_write(dev->regmap, ATMEL_I2SC_IER,\n\t\t     ATMEL_I2SC_INT_RXOR | ATMEL_I2SC_INT_TXUR);\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &atmel_i2s_component,\n\t\t\t\t\t      &atmel_i2s_dai, 1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register DAI: %d\\n\", err);\n\t\tclk_disable_unprepare(dev->pclk);\n\t\treturn err;\n\t}\n\n\t \n\tdev->playback.addr\t= (dma_addr_t)mem->start + ATMEL_I2SC_THR;\n\tdev->playback.maxburst\t= 1;\n\tdev->capture.addr\t= (dma_addr_t)mem->start + ATMEL_I2SC_RHR;\n\tdev->capture.maxburst\t= 1;\n\n\tif (of_property_match_string(np, \"dma-names\", \"rx-tx\") == 0)\n\t\tpcm_flags |= SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX;\n\terr = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, pcm_flags);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register PCM: %d\\n\", err);\n\t\tclk_disable_unprepare(dev->pclk);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void atmel_i2s_remove(struct platform_device *pdev)\n{\n\tstruct atmel_i2s_dev *dev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(dev->pclk);\n}\n\nstatic struct platform_driver atmel_i2s_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_i2s\",\n\t\t.of_match_table\t= atmel_i2s_dt_ids,\n\t},\n\t.probe\t\t= atmel_i2s_probe,\n\t.remove_new\t= atmel_i2s_remove,\n};\nmodule_platform_driver(atmel_i2s_driver);\n\nMODULE_DESCRIPTION(\"Atmel I2S Controller driver\");\nMODULE_AUTHOR(\"Cyrille Pitchen <cyrille.pitchen@atmel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}