{
  "module_name": "mchp-spdifrx.c",
  "hash_id": "16da3b35d03dbb0b86c14b18e6b85f6685d56003034fbd27fc14a976f7753a0a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/mchp-spdifrx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n \n#define SPDIFRX_CR\t\t\t0x00\t \n#define SPDIFRX_MR\t\t\t0x04\t \n\n#define SPDIFRX_IER\t\t\t0x10\t \n#define SPDIFRX_IDR\t\t\t0x14\t \n#define SPDIFRX_IMR\t\t\t0x18\t \n#define SPDIFRX_ISR\t\t\t0x1c\t \n#define SPDIFRX_RSR\t\t\t0x20\t \n#define SPDIFRX_RHR\t\t\t0x24\t \n\n#define SPDIFRX_CHSR(channel, reg)\t\\\n\t(0x30 + (channel) * 0x30 + (reg) * 4)\t \n\n#define SPDIFRX_CHUD(channel, reg)\t\\\n\t(0x48 + (channel) * 0x30 + (reg) * 4)\t \n\n#define SPDIFRX_WPMR\t\t\t0xE4\t \n#define SPDIFRX_WPSR\t\t\t0xE8\t \n\n#define SPDIFRX_VERSION\t\t\t0xFC\t \n\n \n#define SPDIFRX_CR_SWRST\t\tBIT(0)\t \n\n \n \n#define SPDIFRX_MR_RXEN_MASK\t\tGENMASK(0, 0)\n#define SPDIFRX_MR_RXEN_DISABLE\t\t(0 << 0)\t \n#define SPDIFRX_MR_RXEN_ENABLE\t\t(1 << 0)\t \n\n \n#define SPDIFRX_MR_VBMODE_MASK\t\tGENAMSK(1, 1)\n#define SPDIFRX_MR_VBMODE_ALWAYS_LOAD \\\n\t(0 << 1)\t \n#define SPDIFRX_MR_VBMODE_DISCARD_IF_VB1 \\\n\t(1 << 1)\t \n\n \n#define SPDIFRX_MR_ENDIAN_MASK\t\tGENMASK(2, 2)\n#define SPDIFRX_MR_ENDIAN_LITTLE\t(0 << 2)\t \n#define SPDIFRX_MR_ENDIAN_BIG\t\t(1 << 2)\t \n\n \n#define SPDIFRX_MR_PBMODE_MASK\t\tGENMASK(3, 3)\n#define SPDIFRX_MR_PBMODE_PARCHECK\t(0 << 3)\t \n#define SPDIFRX_MR_PBMODE_NOPARCHECK\t(1 << 3)\t \n\n \n#define SPDIFRX_MR_DATAWIDTH_MASK\tGENMASK(5, 4)\n#define SPDIFRX_MR_DATAWIDTH(width) \\\n\t(((6 - (width) / 4) << 4) & SPDIFRX_MR_DATAWIDTH_MASK)\n\n \n#define SPDIFRX_MR_PACK_MASK\t\tGENMASK(7, 7)\n#define SPDIFRX_MR_PACK_DISABLED\t(0 << 7)\n#define SPDIFRX_MR_PACK_ENABLED\t\t(1 << 7)\n\n \n#define SPDIFRX_MR_SBMODE_MASK\t\tGENMASK(8, 8)\n#define SPDIFRX_MR_SBMODE_ALWAYS_LOAD\t(0 << 8)\n#define SPDIFRX_MR_SBMODE_DISCARD\t(1 << 8)\n\n \n#define SPDIFRX_MR_AUTORST_MASK\t\t\tGENMASK(24, 24)\n#define SPDIFRX_MR_AUTORST_NOACTION\t\t(0 << 24)\n#define SPDIFRX_MR_AUTORST_UNLOCK_ON_PRE_ERR\t(1 << 24)\n\n \n#define SPDIFRX_IR_RXRDY\t\t\tBIT(0)\n#define SPDIFRX_IR_LOCKED\t\t\tBIT(1)\n#define SPDIFRX_IR_LOSS\t\t\t\tBIT(2)\n#define SPDIFRX_IR_BLOCKEND\t\t\tBIT(3)\n#define SPDIFRX_IR_SFE\t\t\t\tBIT(4)\n#define SPDIFRX_IR_PAR_ERR\t\t\tBIT(5)\n#define SPDIFRX_IR_OVERRUN\t\t\tBIT(6)\n#define SPDIFRX_IR_RXFULL\t\t\tBIT(7)\n#define SPDIFRX_IR_CSC(ch)\t\t\tBIT((ch) + 8)\n#define SPDIFRX_IR_SECE\t\t\t\tBIT(10)\n#define SPDIFRX_IR_BLOCKST\t\t\tBIT(11)\n#define SPDIFRX_IR_NRZ_ERR\t\t\tBIT(12)\n#define SPDIFRX_IR_PRE_ERR\t\t\tBIT(13)\n#define SPDIFRX_IR_CP_ERR\t\t\tBIT(14)\n\n \n \n#define SPDIFRX_RSR_ULOCK\t\t\tBIT(0)\n#define SPDIFRX_RSR_BADF\t\t\tBIT(1)\n#define SPDIFRX_RSR_LOWF\t\t\tBIT(2)\n#define SPDIFRX_RSR_NOSIGNAL\t\t\tBIT(3)\n#define SPDIFRX_RSR_IFS_MASK\t\t\tGENMASK(27, 16)\n#define SPDIFRX_RSR_IFS(reg)\t\t\t\\\n\t(((reg) & SPDIFRX_RSR_IFS_MASK) >> 16)\n\n \n#define SPDIFRX_VERSION_MASK\t\tGENMASK(11, 0)\n#define SPDIFRX_VERSION_MFN_MASK\tGENMASK(18, 16)\n#define SPDIFRX_VERSION_MFN(reg)\t(((reg) & SPDIFRX_VERSION_MFN_MASK) >> 16)\n\nstatic bool mchp_spdifrx_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFRX_MR:\n\tcase SPDIFRX_IMR:\n\tcase SPDIFRX_ISR:\n\tcase SPDIFRX_RSR:\n\tcase SPDIFRX_CHSR(0, 0):\n\tcase SPDIFRX_CHSR(0, 1):\n\tcase SPDIFRX_CHSR(0, 2):\n\tcase SPDIFRX_CHSR(0, 3):\n\tcase SPDIFRX_CHSR(0, 4):\n\tcase SPDIFRX_CHSR(0, 5):\n\tcase SPDIFRX_CHUD(0, 0):\n\tcase SPDIFRX_CHUD(0, 1):\n\tcase SPDIFRX_CHUD(0, 2):\n\tcase SPDIFRX_CHUD(0, 3):\n\tcase SPDIFRX_CHUD(0, 4):\n\tcase SPDIFRX_CHUD(0, 5):\n\tcase SPDIFRX_CHSR(1, 0):\n\tcase SPDIFRX_CHSR(1, 1):\n\tcase SPDIFRX_CHSR(1, 2):\n\tcase SPDIFRX_CHSR(1, 3):\n\tcase SPDIFRX_CHSR(1, 4):\n\tcase SPDIFRX_CHSR(1, 5):\n\tcase SPDIFRX_CHUD(1, 0):\n\tcase SPDIFRX_CHUD(1, 1):\n\tcase SPDIFRX_CHUD(1, 2):\n\tcase SPDIFRX_CHUD(1, 3):\n\tcase SPDIFRX_CHUD(1, 4):\n\tcase SPDIFRX_CHUD(1, 5):\n\tcase SPDIFRX_WPMR:\n\tcase SPDIFRX_WPSR:\n\tcase SPDIFRX_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_spdifrx_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFRX_CR:\n\tcase SPDIFRX_MR:\n\tcase SPDIFRX_IER:\n\tcase SPDIFRX_IDR:\n\tcase SPDIFRX_WPMR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_spdifrx_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFRX_ISR:\n\tcase SPDIFRX_RHR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool mchp_spdifrx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SPDIFRX_IMR:\n\tcase SPDIFRX_ISR:\n\tcase SPDIFRX_RSR:\n\tcase SPDIFRX_CHSR(0, 0):\n\tcase SPDIFRX_CHSR(0, 1):\n\tcase SPDIFRX_CHSR(0, 2):\n\tcase SPDIFRX_CHSR(0, 3):\n\tcase SPDIFRX_CHSR(0, 4):\n\tcase SPDIFRX_CHSR(0, 5):\n\tcase SPDIFRX_CHUD(0, 0):\n\tcase SPDIFRX_CHUD(0, 1):\n\tcase SPDIFRX_CHUD(0, 2):\n\tcase SPDIFRX_CHUD(0, 3):\n\tcase SPDIFRX_CHUD(0, 4):\n\tcase SPDIFRX_CHUD(0, 5):\n\tcase SPDIFRX_CHSR(1, 0):\n\tcase SPDIFRX_CHSR(1, 1):\n\tcase SPDIFRX_CHSR(1, 2):\n\tcase SPDIFRX_CHSR(1, 3):\n\tcase SPDIFRX_CHSR(1, 4):\n\tcase SPDIFRX_CHSR(1, 5):\n\tcase SPDIFRX_CHUD(1, 0):\n\tcase SPDIFRX_CHUD(1, 1):\n\tcase SPDIFRX_CHUD(1, 2):\n\tcase SPDIFRX_CHUD(1, 3):\n\tcase SPDIFRX_CHUD(1, 4):\n\tcase SPDIFRX_CHUD(1, 5):\n\tcase SPDIFRX_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mchp_spdifrx_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = SPDIFRX_VERSION,\n\t.readable_reg = mchp_spdifrx_readable_reg,\n\t.writeable_reg = mchp_spdifrx_writeable_reg,\n\t.precious_reg = mchp_spdifrx_precious_reg,\n\t.volatile_reg = mchp_spdifrx_volatile_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\n#define SPDIFRX_GCLK_RATIO_MIN\t(12 * 64)\n\n#define SPDIFRX_CS_BITS\t\t192\n#define SPDIFRX_UD_BITS\t\t192\n\n#define SPDIFRX_CHANNELS\t2\n\n \nstruct mchp_spdifrx_ch_stat {\n\tunsigned char data[SPDIFRX_CS_BITS / 8];\n\tstruct completion done;\n};\n\n \nstruct mchp_spdifrx_user_data {\n\tunsigned char data[SPDIFRX_UD_BITS / 8];\n\tstruct completion done;\n};\n\n \nstruct mchp_spdifrx_mixer_control {\n\tstruct mchp_spdifrx_ch_stat ch_stat[SPDIFRX_CHANNELS];\n\tstruct mchp_spdifrx_user_data user_data[SPDIFRX_CHANNELS];\n\tbool ulock;\n\tbool badf;\n\tbool signal;\n};\n\n \nstruct mchp_spdifrx_dev {\n\tstruct snd_dmaengine_dai_dma_data\tcapture;\n\tstruct mchp_spdifrx_mixer_control\tcontrol;\n\tstruct mutex\t\t\t\tmlock;\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct clk\t\t\t\t*pclk;\n\tstruct clk\t\t\t\t*gclk;\n\tunsigned int\t\t\t\ttrigger_enabled;\n};\n\nstatic void mchp_spdifrx_channel_status_read(struct mchp_spdifrx_dev *dev,\n\t\t\t\t\t     int channel)\n{\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu8 *ch_stat = &ctrl->ch_stat[channel].data[0];\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->ch_stat[channel].data) / 4; i++) {\n\t\tregmap_read(dev->regmap, SPDIFRX_CHSR(channel, i), &val);\n\t\t*ch_stat++ = val & 0xFF;\n\t\t*ch_stat++ = (val >> 8) & 0xFF;\n\t\t*ch_stat++ = (val >> 16) & 0xFF;\n\t\t*ch_stat++ = (val >> 24) & 0xFF;\n\t}\n}\n\nstatic void mchp_spdifrx_channel_user_data_read(struct mchp_spdifrx_dev *dev,\n\t\t\t\t\t\tint channel)\n{\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu8 *user_data = &ctrl->user_data[channel].data[0];\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->user_data[channel].data) / 4; i++) {\n\t\tregmap_read(dev->regmap, SPDIFRX_CHUD(channel, i), &val);\n\t\t*user_data++ = val & 0xFF;\n\t\t*user_data++ = (val >> 8) & 0xFF;\n\t\t*user_data++ = (val >> 16) & 0xFF;\n\t\t*user_data++ = (val >> 24) & 0xFF;\n\t}\n}\n\nstatic irqreturn_t mchp_spdif_interrupt(int irq, void *dev_id)\n{\n\tstruct mchp_spdifrx_dev *dev = dev_id;\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu32 sr, imr, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\tint ch;\n\n\tregmap_read(dev->regmap, SPDIFRX_ISR, &sr);\n\tregmap_read(dev->regmap, SPDIFRX_IMR, &imr);\n\tpending = sr & imr;\n\tdev_dbg(dev->dev, \"ISR: %#x, IMR: %#x, pending: %#x\\n\", sr, imr,\n\t\tpending);\n\n\tif (!pending)\n\t\treturn IRQ_NONE;\n\n\tif (pending & SPDIFRX_IR_BLOCKEND) {\n\t\tfor (ch = 0; ch < SPDIFRX_CHANNELS; ch++) {\n\t\t\tmchp_spdifrx_channel_user_data_read(dev, ch);\n\t\t\tcomplete(&ctrl->user_data[ch].done);\n\t\t}\n\t\tregmap_write(dev->regmap, SPDIFRX_IDR, SPDIFRX_IR_BLOCKEND);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tfor (ch = 0; ch < SPDIFRX_CHANNELS; ch++) {\n\t\tif (pending & SPDIFRX_IR_CSC(ch)) {\n\t\t\tmchp_spdifrx_channel_status_read(dev, ch);\n\t\t\tcomplete(&ctrl->ch_stat[ch].done);\n\t\t\tregmap_write(dev->regmap, SPDIFRX_IDR, SPDIFRX_IR_CSC(ch));\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (pending & SPDIFRX_IR_OVERRUN) {\n\t\tdev_warn(dev->dev, \"Overrun detected\\n\");\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int mchp_spdifrx_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tmutex_lock(&dev->mlock);\n\t\t \n\t\tregmap_write(dev->regmap, SPDIFRX_IER, SPDIFRX_IR_OVERRUN);\n\n\t\t \n\t\tregmap_update_bits(dev->regmap, SPDIFRX_MR, SPDIFRX_MR_RXEN_MASK,\n\t\t\t\t   SPDIFRX_MR_RXEN_ENABLE);\n\t\tdev->trigger_enabled = true;\n\t\tmutex_unlock(&dev->mlock);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tmutex_lock(&dev->mlock);\n\t\t \n\t\tregmap_write(dev->regmap, SPDIFRX_IDR, SPDIFRX_IR_OVERRUN);\n\n\t\t \n\t\tregmap_update_bits(dev->regmap, SPDIFRX_MR, SPDIFRX_MR_RXEN_MASK,\n\t\t\t\t   SPDIFRX_MR_RXEN_DISABLE);\n\t\tdev->trigger_enabled = false;\n\t\tmutex_unlock(&dev->mlock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mchp_spdifrx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tu32 mr = 0;\n\tint ret;\n\n\tdev_dbg(dev->dev, \"%s() rate=%u format=%#x width=%u channels=%u\\n\",\n\t\t__func__, params_rate(params), params_format(params),\n\t\tparams_width(params), params_channels(params));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdev_err(dev->dev, \"Playback is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_channels(params) != SPDIFRX_CHANNELS) {\n\t\tdev_err(dev->dev, \"unsupported number of channels: %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\tcase SNDRV_PCM_FORMAT_S20_3BE:\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\tcase SNDRV_PCM_FORMAT_S24_BE:\n\t\tmr |= SPDIFRX_MR_ENDIAN_BIG;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tmr |= SPDIFRX_MR_DATAWIDTH(params_width(params));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported PCM format: %d\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mlock);\n\tif (dev->trigger_enabled) {\n\t\tdev_err(dev->dev, \"PCM already running\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tclk_disable_unprepare(dev->gclk);\n\n\tret = clk_set_min_rate(dev->gclk, params_rate(params) *\n\t\t\t\t\t  SPDIFRX_GCLK_RATIO_MIN + 1);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"unable to set gclk min rate: rate %u * ratio %u + 1\\n\",\n\t\t\tparams_rate(params), SPDIFRX_GCLK_RATIO_MIN);\n\t\t \n\t\tclk_prepare_enable(dev->gclk);\n\t\tgoto unlock;\n\t}\n\tret = clk_prepare_enable(dev->gclk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"unable to enable gclk: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tdev_dbg(dev->dev, \"GCLK range min set to %d\\n\",\n\t\tparams_rate(params) * SPDIFRX_GCLK_RATIO_MIN + 1);\n\n\tret = regmap_write(dev->regmap, SPDIFRX_MR, mr);\n\nunlock:\n\tmutex_unlock(&dev->mlock);\n\n\treturn ret;\n}\n\n#define MCHP_SPDIF_RATES\tSNDRV_PCM_RATE_8000_192000\n\n#define MCHP_SPDIF_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_U16_BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3BE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_BE\t\\\n\t\t\t\t)\n\nstatic int mchp_spdifrx_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_cs_get(struct mchp_spdifrx_dev *dev,\n\t\t\t       int channel,\n\t\t\t       struct snd_ctl_elem_value *uvalue)\n{\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tstruct mchp_spdifrx_ch_stat *ch_stat = &ctrl->ch_stat[channel];\n\tint ret = 0;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\n\tif (dev->trigger_enabled) {\n\t\treinit_completion(&ch_stat->done);\n\t\tregmap_write(dev->regmap, SPDIFRX_IER, SPDIFRX_IR_CSC(channel));\n\t\t \n\t\tret = wait_for_completion_interruptible_timeout(&ch_stat->done,\n\t\t\t\t\t\t\t\tmsecs_to_jiffies(100));\n\t\t \n\t\tif (ret <= 0) {\n\t\t\tdev_dbg(dev->dev, \"channel status for channel %d timeout\\n\",\n\t\t\t\tchannel);\n\t\t\tregmap_write(dev->regmap, SPDIFRX_IDR, SPDIFRX_IR_CSC(channel));\n\t\t\tret = ret ? : -ETIMEDOUT;\n\t\t\tgoto pm_runtime_put;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tmchp_spdifrx_channel_status_read(dev, channel);\n\t}\n\n\tmemcpy(uvalue->value.iec958.status, ch_stat->data,\n\t       sizeof(ch_stat->data));\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\nunlock:\n\tmutex_unlock(&dev->mlock);\n\treturn ret;\n}\n\nstatic int mchp_spdifrx_cs1_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\treturn mchp_spdifrx_cs_get(dev, 0, uvalue);\n}\n\nstatic int mchp_spdifrx_cs2_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\treturn mchp_spdifrx_cs_get(dev, 1, uvalue);\n}\n\nstatic int mchp_spdifrx_cs_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tmemset(uvalue->value.iec958.status, 0xff,\n\t       sizeof(uvalue->value.iec958.status));\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_subcode_ch_get(struct mchp_spdifrx_dev *dev,\n\t\t\t\t       int channel,\n\t\t\t\t       struct snd_ctl_elem_value *uvalue)\n{\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tstruct mchp_spdifrx_user_data *user_data = &ctrl->user_data[channel];\n\tint ret = 0;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\n\tif (dev->trigger_enabled) {\n\t\treinit_completion(&user_data->done);\n\t\tregmap_write(dev->regmap, SPDIFRX_IER, SPDIFRX_IR_BLOCKEND);\n\t\tret = wait_for_completion_interruptible_timeout(&user_data->done,\n\t\t\t\t\t\t\t\tmsecs_to_jiffies(100));\n\t\t \n\t\tif (ret <= 0) {\n\t\t\tdev_dbg(dev->dev, \"user data for channel %d timeout\\n\",\n\t\t\t\tchannel);\n\t\t\tregmap_write(dev->regmap, SPDIFRX_IDR, SPDIFRX_IR_BLOCKEND);\n\t\t\tret = ret ? : -ETIMEDOUT;\n\t\t\tgoto pm_runtime_put;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tmchp_spdifrx_channel_user_data_read(dev, channel);\n\t}\n\n\tmemcpy(uvalue->value.iec958.subcode, user_data->data,\n\t       sizeof(user_data->data));\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\nunlock:\n\tmutex_unlock(&dev->mlock);\n\treturn ret;\n}\n\nstatic int mchp_spdifrx_subcode_ch1_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\treturn mchp_spdifrx_subcode_ch_get(dev, 0, uvalue);\n}\n\nstatic int mchp_spdifrx_subcode_ch2_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\treturn mchp_spdifrx_subcode_ch_get(dev, 1, uvalue);\n}\n\nstatic int mchp_spdifrx_boolean_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_ulock_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu32 val;\n\tint ret;\n\tbool ulock_old = ctrl->ulock;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tif (dev->trigger_enabled) {\n\t\tregmap_read(dev->regmap, SPDIFRX_RSR, &val);\n\t\tctrl->ulock = !(val & SPDIFRX_RSR_ULOCK);\n\t} else {\n\t\tctrl->ulock = 0;\n\t}\n\n\tuvalue->value.integer.value[0] = ctrl->ulock;\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\nunlock:\n\tmutex_unlock(&dev->mlock);\n\n\treturn ulock_old != ctrl->ulock;\n}\n\nstatic int mchp_spdifrx_badf_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu32 val;\n\tint ret;\n\tbool badf_old = ctrl->badf;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tif (dev->trigger_enabled) {\n\t\tregmap_read(dev->regmap, SPDIFRX_RSR, &val);\n\t\tctrl->badf = !!(val & SPDIFRX_RSR_BADF);\n\t} else {\n\t\tctrl->badf = 0;\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\nunlock:\n\tmutex_unlock(&dev->mlock);\n\n\tuvalue->value.integer.value[0] = ctrl->badf;\n\n\treturn badf_old != ctrl->badf;\n}\n\nstatic int mchp_spdifrx_signal_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tu32 val = ~0U, loops = 10;\n\tint ret;\n\tbool signal_old = ctrl->signal;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tif (!dev->trigger_enabled) {\n\t\tregmap_update_bits(dev->regmap, SPDIFRX_MR, SPDIFRX_MR_RXEN_MASK,\n\t\t\t\t   SPDIFRX_MR_RXEN_ENABLE);\n\n\t\t \n\t\twhile (--loops) {\n\t\t\tregmap_read(dev->regmap, SPDIFRX_RSR, &val);\n\t\t\tif (!(val & SPDIFRX_RSR_ULOCK))\n\t\t\t\tbreak;\n\t\t\tusleep_range(100, 150);\n\t\t}\n\n\t\tregmap_update_bits(dev->regmap, SPDIFRX_MR, SPDIFRX_MR_RXEN_MASK,\n\t\t\t\t   SPDIFRX_MR_RXEN_DISABLE);\n\t} else {\n\t\tregmap_read(dev->regmap, SPDIFRX_RSR, &val);\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\nunlock:\n\tmutex_unlock(&dev->mlock);\n\n\tif (!(val & SPDIFRX_RSR_ULOCK))\n\t\tctrl->signal = !(val & SPDIFRX_RSR_NOSIGNAL);\n\telse\n\t\tctrl->signal = 0;\n\tuvalue->value.integer.value[0] = ctrl->signal;\n\n\treturn signal_old != ctrl->signal;\n}\n\nstatic int mchp_spdifrx_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tunsigned long rate;\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&dev->mlock);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tif (dev->trigger_enabled) {\n\t\tregmap_read(dev->regmap, SPDIFRX_RSR, &val);\n\t\t \n\t\tif (val & SPDIFRX_RSR_ULOCK || !(val & SPDIFRX_RSR_IFS_MASK)) {\n\t\t\tucontrol->value.integer.value[0] = 0;\n\t\t\tgoto pm_runtime_put;\n\t\t}\n\t} else {\n\t\t \n\t\tucontrol->value.integer.value[0] = 0;\n\t\tgoto pm_runtime_put;\n\t}\n\n\trate = clk_get_rate(dev->gclk);\n\n\tucontrol->value.integer.value[0] = rate / (32 * SPDIFRX_RSR_IFS(val));\n\npm_runtime_put:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\nunlock:\n\tmutex_unlock(&dev->mlock);\n\treturn ret;\n}\n\nstatic struct snd_kcontrol_new mchp_spdifrx_ctrls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT)\n\t\t\t\" Channel 1\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_info,\n\t\t.get = mchp_spdifrx_cs1_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT)\n\t\t\t\" Channel 2\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_info,\n\t\t.get = mchp_spdifrx_cs2_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, MASK),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = mchp_spdifrx_info,\n\t\t.get = mchp_spdifrx_cs_mask,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Subcode Capture Default Channel 1\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_info,\n\t\t.get = mchp_spdifrx_subcode_ch1_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Subcode Capture Default Channel 2\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_info,\n\t\t.get = mchp_spdifrx_subcode_ch2_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Unlocked\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_boolean_info,\n\t\t.get = mchp_spdifrx_ulock_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE)\"Bad Format\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_boolean_info,\n\t\t.get = mchp_spdifrx_badf_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Signal\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_boolean_info,\n\t\t.get = mchp_spdifrx_signal_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Rate\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = mchp_spdifrx_rate_info,\n\t\t.get = mchp_spdifrx_rate_get,\n\t},\n};\n\nstatic int mchp_spdifrx_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct mchp_spdifrx_mixer_control *ctrl = &dev->control;\n\tint ch;\n\n\tsnd_soc_dai_init_dma_data(dai, NULL, &dev->capture);\n\n\t \n\tregmap_write(dev->regmap, SPDIFRX_CR, SPDIFRX_CR_SWRST);\n\n\t \n\tregmap_write(dev->regmap, SPDIFRX_MR,\n\t\t     SPDIFRX_MR_VBMODE_DISCARD_IF_VB1 |\n\t\t     SPDIFRX_MR_SBMODE_DISCARD |\n\t\t     SPDIFRX_MR_AUTORST_NOACTION |\n\t\t     SPDIFRX_MR_PACK_DISABLED);\n\n\tfor (ch = 0; ch < SPDIFRX_CHANNELS; ch++) {\n\t\tinit_completion(&ctrl->ch_stat[ch].done);\n\t\tinit_completion(&ctrl->user_data[ch].done);\n\t}\n\n\t \n\tsnd_soc_add_dai_controls(dai, mchp_spdifrx_ctrls,\n\t\t\t\t ARRAY_SIZE(mchp_spdifrx_ctrls));\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_dai_remove(struct snd_soc_dai *dai)\n{\n\tstruct mchp_spdifrx_dev *dev = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_write(dev->regmap, SPDIFRX_IDR, GENMASK(14, 0));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mchp_spdifrx_dai_ops = {\n\t.probe\t\t= mchp_spdifrx_dai_probe,\n\t.remove\t\t= mchp_spdifrx_dai_remove,\n\t.trigger\t= mchp_spdifrx_trigger,\n\t.hw_params\t= mchp_spdifrx_hw_params,\n};\n\nstatic struct snd_soc_dai_driver mchp_spdifrx_dai = {\n\t.name = \"mchp-spdifrx\",\n\t.capture = {\n\t\t.stream_name = \"S/PDIF Capture\",\n\t\t.channels_min = SPDIFRX_CHANNELS,\n\t\t.channels_max = SPDIFRX_CHANNELS,\n\t\t.rates = MCHP_SPDIF_RATES,\n\t\t.formats = MCHP_SPDIF_FORMATS,\n\t},\n\t.ops = &mchp_spdifrx_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver mchp_spdifrx_component = {\n\t.name\t\t\t= \"mchp-spdifrx\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct of_device_id mchp_spdifrx_dt_ids[] = {\n\t{\n\t\t.compatible = \"microchip,sama7g5-spdifrx\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_spdifrx_dt_ids);\n\nstatic int mchp_spdifrx_runtime_suspend(struct device *dev)\n{\n\tstruct mchp_spdifrx_dev *spdifrx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(spdifrx->regmap, true);\n\tclk_disable_unprepare(spdifrx->gclk);\n\tclk_disable_unprepare(spdifrx->pclk);\n\n\treturn 0;\n}\n\nstatic int mchp_spdifrx_runtime_resume(struct device *dev)\n{\n\tstruct mchp_spdifrx_dev *spdifrx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(spdifrx->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(spdifrx->gclk);\n\tif (ret)\n\t\tgoto disable_pclk;\n\n\tregcache_cache_only(spdifrx->regmap, false);\n\tregcache_mark_dirty(spdifrx->regmap);\n\tret = regcache_sync(spdifrx->regmap);\n\tif (ret) {\n\t\tregcache_cache_only(spdifrx->regmap, true);\n\t\tclk_disable_unprepare(spdifrx->gclk);\ndisable_pclk:\n\t\tclk_disable_unprepare(spdifrx->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mchp_spdifrx_pm_ops = {\n\tRUNTIME_PM_OPS(mchp_spdifrx_runtime_suspend, mchp_spdifrx_runtime_resume,\n\t\t       NULL)\n};\n\nstatic int mchp_spdifrx_probe(struct platform_device *pdev)\n{\n\tstruct mchp_spdifrx_dev *dev;\n\tstruct resource *mem;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint irq;\n\tint err;\n\tu32 vers;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t       &mchp_spdifrx_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(&pdev->dev, irq, mchp_spdif_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdev->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dev->pclk)) {\n\t\terr = PTR_ERR(dev->pclk);\n\t\tdev_err(&pdev->dev, \"failed to get the peripheral clock: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tdev->gclk = devm_clk_get(&pdev->dev, \"gclk\");\n\tif (IS_ERR(dev->gclk)) {\n\t\terr = PTR_ERR(dev->gclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get the PMC generated clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tclk_set_min_rate(dev->gclk, 48000 * SPDIFRX_GCLK_RATIO_MIN + 1);\n\n\tmutex_init(&dev->mlock);\n\n\tdev->dev = &pdev->dev;\n\tdev->regmap = regmap;\n\tplatform_set_drvdata(pdev, dev);\n\n\tpm_runtime_enable(dev->dev);\n\tif (!pm_runtime_enabled(dev->dev)) {\n\t\terr = mchp_spdifrx_runtime_resume(dev->dev);\n\t\tif (err)\n\t\t\tgoto pm_runtime_disable;\n\t}\n\n\tdev->capture.addr\t= (dma_addr_t)mem->start + SPDIFRX_RHR;\n\tdev->capture.maxburst\t= 1;\n\n\terr = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register PCM: %d\\n\", err);\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &mchp_spdifrx_component,\n\t\t\t\t\t      &mchp_spdifrx_dai, 1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"fail to register dai\\n\");\n\t\tgoto pm_runtime_suspend;\n\t}\n\n\tregmap_read(regmap, SPDIFRX_VERSION, &vers);\n\tdev_info(&pdev->dev, \"hw version: %#lx\\n\", vers & SPDIFRX_VERSION_MASK);\n\n\treturn 0;\n\npm_runtime_suspend:\n\tif (!pm_runtime_status_suspended(dev->dev))\n\t\tmchp_spdifrx_runtime_suspend(dev->dev);\npm_runtime_disable:\n\tpm_runtime_disable(dev->dev);\n\treturn err;\n}\n\nstatic void mchp_spdifrx_remove(struct platform_device *pdev)\n{\n\tstruct mchp_spdifrx_dev *dev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(dev->dev);\n\tif (!pm_runtime_status_suspended(dev->dev))\n\t\tmchp_spdifrx_runtime_suspend(dev->dev);\n}\n\nstatic struct platform_driver mchp_spdifrx_driver = {\n\t.probe\t= mchp_spdifrx_probe,\n\t.remove_new = mchp_spdifrx_remove,\n\t.driver\t= {\n\t\t.name\t= \"mchp_spdifrx\",\n\t\t.of_match_table = mchp_spdifrx_dt_ids,\n\t\t.pm\t= pm_ptr(&mchp_spdifrx_pm_ops),\n\t},\n};\n\nmodule_platform_driver(mchp_spdifrx_driver);\n\nMODULE_AUTHOR(\"Codrin Ciubotariu <codrin.ciubotariu@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip S/PDIF RX Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}