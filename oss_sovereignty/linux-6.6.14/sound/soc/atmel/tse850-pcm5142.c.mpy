{
  "module_name": "tse850-pcm5142.c",
  "hash_id": "f99e56bcb1e5381ee2d9370e275e95a2ce2be16f99a0b03e2a245af2f4253a65",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/tse850-pcm5142.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\nstruct tse850_priv {\n\tstruct gpio_desc *add;\n\tstruct gpio_desc *loop1;\n\tstruct gpio_desc *loop2;\n\n\tstruct regulator *ana;\n\n\tint add_cache;\n\tint loop1_cache;\n\tint loop2_cache;\n};\n\nstatic int tse850_get_mux1(struct snd_kcontrol *kctrl,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\n\tucontrol->value.enumerated.item[0] = tse850->loop1_cache;\n\n\treturn 0;\n}\n\nstatic int tse850_put_mux1(struct snd_kcontrol *kctrl,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\tstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\n\tif (val >= e->items)\n\t\treturn -EINVAL;\n\n\tgpiod_set_value_cansleep(tse850->loop1, val);\n\ttse850->loop1_cache = val;\n\n\treturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\n}\n\nstatic int tse850_get_mux2(struct snd_kcontrol *kctrl,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\n\tucontrol->value.enumerated.item[0] = tse850->loop2_cache;\n\n\treturn 0;\n}\n\nstatic int tse850_put_mux2(struct snd_kcontrol *kctrl,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\tstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\n\tif (val >= e->items)\n\t\treturn -EINVAL;\n\n\tgpiod_set_value_cansleep(tse850->loop2, val);\n\ttse850->loop2_cache = val;\n\n\treturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\n}\n\nstatic int tse850_get_mix(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\n\tucontrol->value.enumerated.item[0] = tse850->add_cache;\n\n\treturn 0;\n}\n\nstatic int tse850_put_mix(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\tint connect = !!ucontrol->value.integer.value[0];\n\n\tif (tse850->add_cache == connect)\n\t\treturn 0;\n\n\t \n\tgpiod_set_value_cansleep(tse850->add, connect);\n\ttse850->add_cache = connect;\n\n\tsnd_soc_dapm_mixer_update_power(dapm, kctrl, connect, NULL);\n\treturn 1;\n}\n\nstatic int tse850_get_ana(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\tret = regulator_get_voltage(tse850->ana);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret < 11000000)\n\t\tret = 11000000;\n\telse if (ret > 20000000)\n\t\tret = 20000000;\n\tret -= 11000000;\n\tret = (ret + 500000) / 1000000;\n\n\tucontrol->value.enumerated.item[0] = ret;\n\n\treturn 0;\n}\n\nstatic int tse850_put_ana(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\tstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\n\tunsigned int uV = ucontrol->value.enumerated.item[0];\n\tint ret;\n\n\tif (uV >= e->items)\n\t\treturn -EINVAL;\n\n\t \n\tif (uV)\n\t\tuV = 11000000 + (1000000 * uV);\n\telse\n\t\tuV = 2000000;\n\n\tret = regulator_set_voltage(tse850->ana, uV, uV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\n}\n\nstatic const char * const mux_text[] = { \"Mixer\", \"Loop\" };\n\nstatic const struct soc_enum mux_enum =\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(mux_text), mux_text);\n\nstatic const struct snd_kcontrol_new mux1 =\n\tSOC_DAPM_ENUM_EXT(\"MUX1\", mux_enum, tse850_get_mux1, tse850_put_mux1);\n\nstatic const struct snd_kcontrol_new mux2 =\n\tSOC_DAPM_ENUM_EXT(\"MUX2\", mux_enum, tse850_get_mux2, tse850_put_mux2);\n\n#define TSE850_DAPM_SINGLE_EXT(xname, reg, shift, max, invert, xget, xput) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xget, \\\n\t.put = xput, \\\n\t.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }\n\nstatic const struct snd_kcontrol_new mix[] = {\n\tTSE850_DAPM_SINGLE_EXT(\"IN Switch\", SND_SOC_NOPM, 0, 1, 0,\n\t\t\t       tse850_get_mix, tse850_put_mix),\n};\n\nstatic const char * const ana_text[] = {\n\t\"Low\", \"12V\", \"13V\", \"14V\", \"15V\", \"16V\", \"17V\", \"18V\", \"19V\", \"20V\"\n};\n\nstatic const struct soc_enum ana_enum =\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(ana_text), ana_text);\n\nstatic const struct snd_kcontrol_new out =\n\tSOC_DAPM_ENUM_EXT(\"ANA\", ana_enum, tse850_get_ana, tse850_put_ana);\n\nstatic const struct snd_soc_dapm_widget tse850_dapm_widgets[] = {\n\tSND_SOC_DAPM_LINE(\"OUT1\", NULL),\n\tSND_SOC_DAPM_LINE(\"OUT2\", NULL),\n\tSND_SOC_DAPM_LINE(\"IN1\", NULL),\n\tSND_SOC_DAPM_LINE(\"IN2\", NULL),\n\tSND_SOC_DAPM_INPUT(\"DAC\"),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\n\tSOC_MIXER_ARRAY(\"MIX\", SND_SOC_NOPM, 0, 0, mix),\n\tSND_SOC_DAPM_MUX(\"MUX1\", SND_SOC_NOPM, 0, 0, &mux1),\n\tSND_SOC_DAPM_MUX(\"MUX2\", SND_SOC_NOPM, 0, 0, &mux2),\n\tSND_SOC_DAPM_OUT_DRV(\"OUT\", SND_SOC_NOPM, 0, 0, &out, 1),\n};\n\n \nstatic const struct snd_soc_dapm_route tse850_intercon[] = {\n\t{ \"OUT1\", NULL, \"MUX1\" },\n\t{ \"OUT2\", NULL, \"MUX2\" },\n\n\t{ \"MUX1\", \"Loop\",  \"IN1\" },\n\t{ \"MUX1\", \"Mixer\", \"OUT\" },\n\n\t{ \"MUX2\", \"Loop\",  \"IN2\" },\n\t{ \"MUX2\", \"Mixer\", \"OUT\" },\n\n\t{ \"OUT\", NULL, \"MIX\" },\n\n\t{ \"MIX\", NULL, \"DAC\" },\n\t{ \"MIX\", \"IN Switch\", \"IN1\" },\n\t{ \"MIX\", \"IN Switch\", \"IN2\" },\n\n\t \n\t{ \"DAC\", NULL, \"OUTL\" },\n};\n\nSND_SOC_DAILINK_DEFS(pcm,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"pcm512x-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tse850_dailink = {\n\t.name = \"TSE-850\",\n\t.stream_name = \"TSE-850-PCM\",\n\t.dai_fmt = SND_SOC_DAIFMT_I2S\n\t\t | SND_SOC_DAIFMT_NB_NF\n\t\t | SND_SOC_DAIFMT_CBP_CFC,\n\tSND_SOC_DAILINK_REG(pcm),\n};\n\nstatic struct snd_soc_card tse850_card = {\n\t.name = \"TSE-850-ASoC\",\n\t.owner = THIS_MODULE,\n\t.dai_link = &tse850_dailink,\n\t.num_links = 1,\n\t.dapm_widgets = tse850_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(tse850_dapm_widgets),\n\t.dapm_routes = tse850_intercon,\n\t.num_dapm_routes = ARRAY_SIZE(tse850_intercon),\n\t.fully_routed = true,\n};\n\nstatic int tse850_dt_init(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *codec_np, *cpu_np;\n\tstruct snd_soc_dai_link *dailink = &tse850_dailink;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"only device tree supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcpu_np = of_parse_phandle(np, \"axentia,cpu-dai\", 0);\n\tif (!cpu_np) {\n\t\tdev_err(&pdev->dev, \"failed to get cpu dai\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdailink->cpus->of_node = cpu_np;\n\tdailink->platforms->of_node = cpu_np;\n\tof_node_put(cpu_np);\n\n\tcodec_np = of_parse_phandle(np, \"axentia,audio-codec\", 0);\n\tif (!codec_np) {\n\t\tdev_err(&pdev->dev, \"failed to get codec info\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdailink->codecs->of_node = codec_np;\n\tof_node_put(codec_np);\n\n\treturn 0;\n}\n\nstatic int tse850_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = &tse850_card;\n\tstruct device *dev = card->dev = &pdev->dev;\n\tstruct tse850_priv *tse850;\n\tint ret;\n\n\ttse850 = devm_kzalloc(dev, sizeof(*tse850), GFP_KERNEL);\n\tif (!tse850)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_card_set_drvdata(card, tse850);\n\n\tret = tse850_dt_init(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init dt info\\n\");\n\t\treturn ret;\n\t}\n\n\ttse850->add = devm_gpiod_get(dev, \"axentia,add\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tse850->add))\n\t\treturn dev_err_probe(dev, PTR_ERR(tse850->add),\n\t\t\t\t     \"failed to get 'add' gpio\\n\");\n\ttse850->add_cache = 1;\n\n\ttse850->loop1 = devm_gpiod_get(dev, \"axentia,loop1\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tse850->loop1))\n\t\treturn dev_err_probe(dev, PTR_ERR(tse850->loop1),\n\t\t\t\t     \"failed to get 'loop1' gpio\\n\");\n\ttse850->loop1_cache = 1;\n\n\ttse850->loop2 = devm_gpiod_get(dev, \"axentia,loop2\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tse850->loop2))\n\t\treturn dev_err_probe(dev, PTR_ERR(tse850->loop2),\n\t\t\t\t     \"failed to get 'loop2' gpio\\n\");\n\ttse850->loop2_cache = 1;\n\n\ttse850->ana = devm_regulator_get(dev, \"axentia,ana\");\n\tif (IS_ERR(tse850->ana))\n\t\treturn dev_err_probe(dev, PTR_ERR(tse850->ana),\n\t\t\t\t     \"failed to get 'ana' regulator\\n\");\n\n\tret = regulator_enable(tse850->ana);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable the 'ana' regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_register_card(card);\n\tif (ret) {\n\t\tdev_err(dev, \"snd_soc_register_card failed\\n\");\n\t\tgoto err_disable_ana;\n\t}\n\n\treturn 0;\n\nerr_disable_ana:\n\tregulator_disable(tse850->ana);\n\treturn ret;\n}\n\nstatic void tse850_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\n\n\tsnd_soc_unregister_card(card);\n\tregulator_disable(tse850->ana);\n}\n\nstatic const struct of_device_id tse850_dt_ids[] = {\n\t{ .compatible = \"axentia,tse850-pcm5142\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tse850_dt_ids);\n\nstatic struct platform_driver tse850_driver = {\n\t.driver = {\n\t\t.name = \"axentia-tse850-pcm5142\",\n\t\t.of_match_table = tse850_dt_ids,\n\t},\n\t.probe = tse850_probe,\n\t.remove_new = tse850_remove,\n};\n\nmodule_platform_driver(tse850_driver);\n\n \nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_DESCRIPTION(\"ALSA SoC driver for TSE-850 with PCM5142 codec\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}