{
  "module_name": "atmel-pcm-pdc.c",
  "hash_id": "b30ae7d1634db9245d804972f0e86bb28cc199dcf82c641e49664148e9fd3e92",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/atmel/atmel-pcm-pdc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/atmel_pdc.h>\n#include <linux/atmel-ssc.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"atmel-pcm.h\"\n\n\nstatic int atmel_pcm_new(struct snd_soc_component *component,\n\t\t\t struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, ATMEL_SSC_DMABUF_SIZE,\n\t\t\t\t       ATMEL_SSC_DMABUF_SIZE);\n\n\treturn 0;\n}\n\n \n \nstatic const struct snd_pcm_hardware atmel_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 8192,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 1024,\n\t.buffer_bytes_max\t= ATMEL_SSC_DMABUF_SIZE,\n};\n\n\n \nstruct atmel_runtime_data {\n\tstruct atmel_pcm_dma_params *params;\n\tdma_addr_t dma_buffer;\t\t \n\tdma_addr_t dma_buffer_end;\t \n\tsize_t period_size;\n\n\tdma_addr_t period_ptr;\t\t \n};\n\n \nstatic void atmel_pcm_dma_irq(u32 ssc_sr,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct atmel_runtime_data *prtd = substream->runtime->private_data;\n\tstruct atmel_pcm_dma_params *params = prtd->params;\n\tstatic int count;\n\n\tcount++;\n\n\tif (ssc_sr & params->mask->ssc_endbuf) {\n\t\tpr_warn(\"atmel-pcm: buffer %s on %s (SSC_SR=%#x, count=%d)\\n\",\n\t\t\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK\n\t\t\t\t? \"underrun\" : \"overrun\",\n\t\t\t\tparams->name, ssc_sr, count);\n\n\t\t \n\t\tssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,\n\t\t\t   params->mask->pdc_disable);\n\t\tprtd->period_ptr += prtd->period_size;\n\t\tif (prtd->period_ptr >= prtd->dma_buffer_end)\n\t\t\tprtd->period_ptr = prtd->dma_buffer;\n\n\t\tssc_writex(params->ssc->regs, params->pdc->xpr,\n\t\t\t   prtd->period_ptr);\n\t\tssc_writex(params->ssc->regs, params->pdc->xcr,\n\t\t\t   prtd->period_size / params->pdc_xfer_size);\n\t\tssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,\n\t\t\t   params->mask->pdc_enable);\n\t}\n\n\tif (ssc_sr & params->mask->ssc_endx) {\n\t\t \n\t\tprtd->period_ptr += prtd->period_size;\n\t\tif (prtd->period_ptr >= prtd->dma_buffer_end)\n\t\t\tprtd->period_ptr = prtd->dma_buffer;\n\n\t\tssc_writex(params->ssc->regs, params->pdc->xnpr,\n\t\t\t   prtd->period_ptr);\n\t\tssc_writex(params->ssc->regs, params->pdc->xncr,\n\t\t\t   prtd->period_size / params->pdc_xfer_size);\n\t}\n\n\tsnd_pcm_period_elapsed(substream);\n}\n\n\n \nstatic int atmel_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct atmel_runtime_data *prtd = runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\t \n\n\tprtd->params = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tprtd->params->dma_intr_handler = atmel_pcm_dma_irq;\n\n\tprtd->dma_buffer = runtime->dma_addr;\n\tprtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;\n\tprtd->period_size = params_period_bytes(params);\n\n\tpr_debug(\"atmel-pcm: \"\n\t\t\"hw_params: DMA for %s initialized \"\n\t\t\"(dma_bytes=%zu, period_size=%zu)\\n\",\n\t\tprtd->params->name,\n\t\truntime->dma_bytes,\n\t\tprtd->period_size);\n\treturn 0;\n}\n\nstatic int atmel_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct atmel_runtime_data *prtd = substream->runtime->private_data;\n\tstruct atmel_pcm_dma_params *params = prtd->params;\n\n\tif (params != NULL) {\n\t\tssc_writex(params->ssc->regs, SSC_PDC_PTCR,\n\t\t\t   params->mask->pdc_disable);\n\t\tprtd->params->dma_intr_handler = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_pcm_prepare(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct atmel_runtime_data *prtd = substream->runtime->private_data;\n\tstruct atmel_pcm_dma_params *params = prtd->params;\n\n\tssc_writex(params->ssc->regs, SSC_IDR,\n\t\t   params->mask->ssc_endx | params->mask->ssc_endbuf);\n\tssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,\n\t\t   params->mask->pdc_disable);\n\treturn 0;\n}\n\nstatic int atmel_pcm_trigger(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *rtd = substream->runtime;\n\tstruct atmel_runtime_data *prtd = rtd->private_data;\n\tstruct atmel_pcm_dma_params *params = prtd->params;\n\tint ret = 0;\n\n\tpr_debug(\"atmel-pcm:buffer_size = %ld,\"\n\t\t\"dma_area = %p, dma_bytes = %zu\\n\",\n\t\trtd->buffer_size, rtd->dma_area, rtd->dma_bytes);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tprtd->period_ptr = prtd->dma_buffer;\n\n\t\tssc_writex(params->ssc->regs, params->pdc->xpr,\n\t\t\t   prtd->period_ptr);\n\t\tssc_writex(params->ssc->regs, params->pdc->xcr,\n\t\t\t   prtd->period_size / params->pdc_xfer_size);\n\n\t\tprtd->period_ptr += prtd->period_size;\n\t\tssc_writex(params->ssc->regs, params->pdc->xnpr,\n\t\t\t   prtd->period_ptr);\n\t\tssc_writex(params->ssc->regs, params->pdc->xncr,\n\t\t\t   prtd->period_size / params->pdc_xfer_size);\n\n\t\tpr_debug(\"atmel-pcm: trigger: \"\n\t\t\t\"period_ptr=%lx, xpr=%u, \"\n\t\t\t\"xcr=%u, xnpr=%u, xncr=%u\\n\",\n\t\t\t(unsigned long)prtd->period_ptr,\n\t\t\tssc_readx(params->ssc->regs, params->pdc->xpr),\n\t\t\tssc_readx(params->ssc->regs, params->pdc->xcr),\n\t\t\tssc_readx(params->ssc->regs, params->pdc->xnpr),\n\t\t\tssc_readx(params->ssc->regs, params->pdc->xncr));\n\n\t\tssc_writex(params->ssc->regs, SSC_IER,\n\t\t\t   params->mask->ssc_endx | params->mask->ssc_endbuf);\n\t\tssc_writex(params->ssc->regs, SSC_PDC_PTCR,\n\t\t\t   params->mask->pdc_enable);\n\n\t\tpr_debug(\"sr=%u imr=%u\\n\",\n\t\t\tssc_readx(params->ssc->regs, SSC_SR),\n\t\t\tssc_readx(params->ssc->regs, SSC_IER));\n\t\tbreak;\t\t \n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,\n\t\t\t   params->mask->pdc_disable);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,\n\t\t\t   params->mask->pdc_enable);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t atmel_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct atmel_runtime_data *prtd = runtime->private_data;\n\tstruct atmel_pcm_dma_params *params = prtd->params;\n\tdma_addr_t ptr;\n\tsnd_pcm_uframes_t x;\n\n\tptr = (dma_addr_t) ssc_readx(params->ssc->regs, params->pdc->xpr);\n\tx = bytes_to_frames(runtime, ptr - prtd->dma_buffer);\n\n\tif (x == runtime->buffer_size)\n\t\tx = 0;\n\n\treturn x;\n}\n\nstatic int atmel_pcm_open(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct atmel_runtime_data *prtd;\n\tint ret = 0;\n\n\tsnd_soc_set_runtime_hwparams(substream, &atmel_pcm_hardware);\n\n\t \n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tprtd = kzalloc(sizeof(struct atmel_runtime_data), GFP_KERNEL);\n\tif (prtd == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\truntime->private_data = prtd;\n\n out:\n\treturn ret;\n}\n\nstatic int atmel_pcm_close(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct atmel_runtime_data *prtd = substream->runtime->private_data;\n\n\tkfree(prtd);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver atmel_soc_platform = {\n\t.open\t\t= atmel_pcm_open,\n\t.close\t\t= atmel_pcm_close,\n\t.hw_params\t= atmel_pcm_hw_params,\n\t.hw_free\t= atmel_pcm_hw_free,\n\t.prepare\t= atmel_pcm_prepare,\n\t.trigger\t= atmel_pcm_trigger,\n\t.pointer\t= atmel_pcm_pointer,\n\t.pcm_construct\t= atmel_pcm_new,\n};\n\nint atmel_pcm_pdc_platform_register(struct device *dev)\n{\n\treturn devm_snd_soc_register_component(dev, &atmel_soc_platform,\n\t\t\t\t\t       NULL, 0);\n}\nEXPORT_SYMBOL(atmel_pcm_pdc_platform_register);\n\nMODULE_AUTHOR(\"Sedji Gaouaou <sedji.gaouaou@atmel.com>\");\nMODULE_DESCRIPTION(\"Atmel PCM module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}