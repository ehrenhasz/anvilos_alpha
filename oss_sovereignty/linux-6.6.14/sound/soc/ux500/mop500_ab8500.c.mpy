{
  "module_name": "mop500_ab8500.c",
  "hash_id": "9d3f472aaebe2a672ffb1d584ff80152a4003d1c273d441123c53eb1e622a87d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ux500/mop500_ab8500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mutex.h>\n\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"ux500_pcm.h\"\n#include \"ux500_msp_dai.h\"\n#include \"mop500_ab8500.h\"\n#include \"../codecs/ab8500-codec.h\"\n\n#define TX_SLOT_MONO\t0x0008\n#define TX_SLOT_STEREO\t0x000a\n#define RX_SLOT_MONO\t0x0001\n#define RX_SLOT_STEREO\t0x0003\n#define TX_SLOT_8CH\t0x00FF\n#define RX_SLOT_8CH\t0x00FF\n\n#define DEF_TX_SLOTS\tTX_SLOT_STEREO\n#define DEF_RX_SLOTS\tRX_SLOT_MONO\n\n#define DRIVERMODE_NORMAL\t0\n#define DRIVERMODE_CODEC_ONLY\t1\n\n \nstatic unsigned int tx_slots = DEF_TX_SLOTS;\nstatic unsigned int rx_slots = DEF_RX_SLOTS;\n\n \nstatic DEFINE_MUTEX(mop500_ab8500_params_lock);\nstatic unsigned long mop500_ab8500_usage;\nstatic int mop500_ab8500_rate;\nstatic int mop500_ab8500_channels;\n\n \nstatic const char * const enum_mclk[] = {\n\t\"SYSCLK\",\n\t\"ULPCLK\"\n};\nenum mclk {\n\tMCLK_SYSCLK,\n\tMCLK_ULPCLK,\n};\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(soc_enum_mclk, enum_mclk);\n\n \nstruct mop500_ab8500_drvdata {\n\t \n\tenum mclk mclk_sel;\n\tstruct clk *clk_ptr_intclk;\n\tstruct clk *clk_ptr_sysclk;\n\tstruct clk *clk_ptr_ulpclk;\n};\n\nstatic inline const char *get_mclk_str(enum mclk mclk_sel)\n{\n\tswitch (mclk_sel) {\n\tcase MCLK_SYSCLK:\n\t\treturn \"SYSCLK\";\n\tcase MCLK_ULPCLK:\n\t\treturn \"ULPCLK\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int mop500_ab8500_set_mclk(struct device *dev,\n\t\t\t\tstruct mop500_ab8500_drvdata *drvdata)\n{\n\tint status;\n\tstruct clk *clk_ptr;\n\n\tif (IS_ERR(drvdata->clk_ptr_intclk)) {\n\t\tdev_err(dev,\n\t\t\t\"%s: ERROR: intclk not initialized!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tswitch (drvdata->mclk_sel) {\n\tcase MCLK_SYSCLK:\n\t\tclk_ptr = drvdata->clk_ptr_sysclk;\n\t\tbreak;\n\tcase MCLK_ULPCLK:\n\t\tclk_ptr = drvdata->clk_ptr_ulpclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(clk_ptr)) {\n\t\tdev_err(dev, \"%s: ERROR: %s not initialized!\\n\", __func__,\n\t\t\tget_mclk_str(drvdata->mclk_sel));\n\t\treturn -EIO;\n\t}\n\n\tstatus = clk_set_parent(drvdata->clk_ptr_intclk, clk_ptr);\n\tif (status)\n\t\tdev_err(dev,\n\t\t\t\"%s: ERROR: Setting intclk parent to %s failed (ret = %d)!\",\n\t\t\t__func__, get_mclk_str(drvdata->mclk_sel), status);\n\telse\n\t\tdev_dbg(dev,\n\t\t\t\"%s: intclk parent changed to %s.\\n\",\n\t\t\t__func__, get_mclk_str(drvdata->mclk_sel));\n\n\treturn status;\n}\n\n \n\nstatic int mclk_input_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tstruct mop500_ab8500_drvdata *drvdata =\n\t\t\t\tsnd_soc_card_get_drvdata(card);\n\n\tucontrol->value.enumerated.item[0] = drvdata->mclk_sel;\n\n\treturn 0;\n}\n\nstatic int mclk_input_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tstruct mop500_ab8500_drvdata *drvdata =\n\t\t\t\tsnd_soc_card_get_drvdata(card);\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\n\tif (val > (unsigned int)MCLK_ULPCLK)\n\t\treturn -EINVAL;\n\tif (drvdata->mclk_sel == val)\n\t\treturn 0;\n\n\tdrvdata->mclk_sel = val;\n\n\treturn 1;\n}\n\n \n\nstatic struct snd_kcontrol_new mop500_ab8500_ctrls[] = {\n\tSOC_ENUM_EXT(\"Master Clock Select\",\n\t\tsoc_enum_mclk,\n\t\tmclk_input_control_get, mclk_input_control_put),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Left\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Right\"),\n\tSOC_DAPM_PIN_SWITCH(\"Earpiece\"),\n\tSOC_DAPM_PIN_SWITCH(\"Speaker Left\"),\n\tSOC_DAPM_PIN_SWITCH(\"Speaker Right\"),\n\tSOC_DAPM_PIN_SWITCH(\"LineOut Left\"),\n\tSOC_DAPM_PIN_SWITCH(\"LineOut Right\"),\n\tSOC_DAPM_PIN_SWITCH(\"Vibra 1\"),\n\tSOC_DAPM_PIN_SWITCH(\"Vibra 2\"),\n\tSOC_DAPM_PIN_SWITCH(\"Mic 1\"),\n\tSOC_DAPM_PIN_SWITCH(\"Mic 2\"),\n\tSOC_DAPM_PIN_SWITCH(\"LineIn Left\"),\n\tSOC_DAPM_PIN_SWITCH(\"LineIn Right\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 1\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 2\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 3\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 4\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 5\"),\n\tSOC_DAPM_PIN_SWITCH(\"DMic 6\"),\n};\n\n \n\nstatic int mop500_ab8500_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\t \n\treturn mop500_ab8500_set_mclk(rtd->card->dev,\n\t\t\t\tsnd_soc_card_get_drvdata(rtd->card));\n}\n\nstatic void mop500_ab8500_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct device *dev = rtd->card->dev;\n\n\tdev_dbg(dev, \"%s: Enter\\n\", __func__);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\ttx_slots = DEF_TX_SLOTS;\n\telse\n\t\trx_slots = DEF_RX_SLOTS;\n}\n\nstatic int mop500_ab8500_hw_params(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct device *dev = rtd->card->dev;\n\tunsigned int fmt;\n\tint channels, ret = 0, driver_mode, slots;\n\tunsigned int sw_codec, sw_cpu;\n\tbool is_playback;\n\n\tdev_dbg(dev, \"%s: Enter\\n\", __func__);\n\n\tdev_dbg(dev, \"%s: substream->pcm->name = %s\\n\"\n\t\t\"substream->pcm->id = %s.\\n\"\n\t\t\"substream->name = %s.\\n\"\n\t\t\"substream->number = %d.\\n\",\n\t\t__func__,\n\t\tsubstream->pcm->name,\n\t\tsubstream->pcm->id,\n\t\tsubstream->name,\n\t\tsubstream->number);\n\n\t \n\tmutex_lock(&mop500_ab8500_params_lock);\n\tif (mop500_ab8500_usage) {\n\t\tif (mop500_ab8500_rate != params_rate(params) ||\n\t\t    mop500_ab8500_channels != params_channels(params)) {\n\t\t\tmutex_unlock(&mop500_ab8500_params_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tmop500_ab8500_rate = params_rate(params);\n\t\tmop500_ab8500_channels = params_channels(params);\n\t}\n\t__set_bit(cpu_dai->id, &mop500_ab8500_usage);\n\tmutex_unlock(&mop500_ab8500_params_lock);\n\n\tchannels = params_channels(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tsw_cpu = 32;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tsw_cpu = 16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (channels == 8)\n\t\tdriver_mode = DRIVERMODE_CODEC_ONLY;\n\telse\n\t\tdriver_mode = DRIVERMODE_NORMAL;\n\tdev_dbg(dev, \"%s: Driver-mode: %s.\\n\", __func__,\n\t\t(driver_mode == DRIVERMODE_NORMAL) ? \"NORMAL\" : \"CODEC_ONLY\");\n\n\t \n\n\tif (driver_mode == DRIVERMODE_NORMAL) {\n\t\tfmt = SND_SOC_DAIFMT_DSP_A |\n\t\t\tSND_SOC_DAIFMT_CBM_CFM |\n\t\t\tSND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CONT;\n\t} else {\n\t\tfmt = SND_SOC_DAIFMT_DSP_A |\n\t\t\tSND_SOC_DAIFMT_CBM_CFM |\n\t\t\tSND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_GATED;\n\t}\n\n\tret = snd_soc_runtime_set_dai_fmt(rtd, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tis_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tswitch (channels) {\n\tcase 1:\n\t\tslots = 16;\n\t\ttx_slots = (is_playback) ? TX_SLOT_MONO : 0;\n\t\trx_slots = (is_playback) ? 0 : RX_SLOT_MONO;\n\t\tbreak;\n\tcase 2:\n\t\tslots = 16;\n\t\ttx_slots = (is_playback) ? TX_SLOT_STEREO : 0;\n\t\trx_slots = (is_playback) ? 0 : RX_SLOT_STEREO;\n\t\tbreak;\n\tcase 8:\n\t\tslots = 16;\n\t\ttx_slots = (is_playback) ? TX_SLOT_8CH : 0;\n\t\trx_slots = (is_playback) ? 0 : RX_SLOT_8CH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (driver_mode == DRIVERMODE_NORMAL)\n\t\tsw_codec = sw_cpu;\n\telse\n\t\tsw_codec = 20;\n\n\tdev_dbg(dev, \"%s: CPU-DAI TDM: TX=0x%04X RX=0x%04x\\n\", __func__,\n\t\ttx_slots, rx_slots);\n\tret = snd_soc_dai_set_tdm_slot(cpu_dai, tx_slots, rx_slots, slots,\n\t\t\t\tsw_cpu);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"%s: CODEC-DAI TDM: TX=0x%04X RX=0x%04x\\n\", __func__,\n\t\ttx_slots, rx_slots);\n\tret = snd_soc_dai_set_tdm_slot(codec_dai, tx_slots, rx_slots, slots,\n\t\t\t\tsw_codec);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mop500_ab8500_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tmutex_lock(&mop500_ab8500_params_lock);\n\t__clear_bit(cpu_dai->id, &mop500_ab8500_usage);\n\tmutex_unlock(&mop500_ab8500_params_lock);\n\n\treturn 0;\n}\n\nconst struct snd_soc_ops mop500_ab8500_ops[] = {\n\t{\n\t\t.hw_params = mop500_ab8500_hw_params,\n\t\t.hw_free = mop500_ab8500_hw_free,\n\t\t.startup = mop500_ab8500_startup,\n\t\t.shutdown = mop500_ab8500_shutdown,\n\t}\n};\n\nint mop500_ab8500_machine_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dapm_context *dapm = &rtd->card->dapm;\n\tstruct device *dev = rtd->card->dev;\n\tstruct mop500_ab8500_drvdata *drvdata;\n\tint ret;\n\n\tdev_dbg(dev, \"%s Enter.\\n\", __func__);\n\n\t \n\tdrvdata = devm_kzalloc(dev, sizeof(struct mop500_ab8500_drvdata),\n\t\t\tGFP_KERNEL);\n\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_card_set_drvdata(rtd->card, drvdata);\n\n\t \n\n\tdrvdata->clk_ptr_sysclk = clk_get(dev, \"sysclk\");\n\tif (IS_ERR(drvdata->clk_ptr_sysclk))\n\t\tdev_warn(dev, \"%s: WARNING: clk_get failed for 'sysclk'!\\n\",\n\t\t\t__func__);\n\tdrvdata->clk_ptr_ulpclk = clk_get(dev, \"ulpclk\");\n\tif (IS_ERR(drvdata->clk_ptr_ulpclk))\n\t\tdev_warn(dev, \"%s: WARNING: clk_get failed for 'ulpclk'!\\n\",\n\t\t\t__func__);\n\tdrvdata->clk_ptr_intclk = clk_get(dev, \"intclk\");\n\tif (IS_ERR(drvdata->clk_ptr_intclk))\n\t\tdev_warn(dev, \"%s: WARNING: clk_get failed for 'intclk'!\\n\",\n\t\t\t__func__);\n\n\t \n\tdrvdata->mclk_sel = MCLK_ULPCLK;\n\tret = mop500_ab8500_set_mclk(dev, drvdata);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"%s: WARNING: mop500_ab8500_set_mclk!\\n\",\n\t\t\t__func__);\n\n\tdrvdata->mclk_sel = MCLK_ULPCLK;\n\n\t \n\tret = snd_soc_add_card_controls(rtd->card, mop500_ab8500_ctrls,\n\t\t\tARRAY_SIZE(mop500_ab8500_ctrls));\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to add machine-controls (%d)!\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dapm_disable_pin(dapm, \"Earpiece\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Speaker Left\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Speaker Right\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"LineOut Left\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"LineOut Right\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Vibra 1\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Vibra 2\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Mic 1\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"Mic 2\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"LineIn Left\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"LineIn Right\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 1\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 2\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 3\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 4\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 5\");\n\tret |= snd_soc_dapm_disable_pin(dapm, \"DMic 6\");\n\n\treturn ret;\n}\n\nvoid mop500_ab8500_remove(struct snd_soc_card *card)\n{\n\tstruct mop500_ab8500_drvdata *drvdata = snd_soc_card_get_drvdata(card);\n\n\tclk_put(drvdata->clk_ptr_sysclk);\n\tclk_put(drvdata->clk_ptr_ulpclk);\n\tclk_put(drvdata->clk_ptr_intclk);\n\n\tsnd_soc_card_set_drvdata(card, drvdata);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}