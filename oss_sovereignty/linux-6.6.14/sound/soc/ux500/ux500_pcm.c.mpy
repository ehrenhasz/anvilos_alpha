{
  "module_name": "ux500_pcm.c",
  "hash_id": "3110e856b007befb4d12387e68d11b848034bf7e0d5b8a224aa13b0d533ef44c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ux500/ux500_pcm.c",
  "human_readable_source": "\n \n\n#include <asm/page.h>\n\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/slab.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"ux500_msp_i2s.h\"\n#include \"ux500_pcm.h\"\n\n#define UX500_PLATFORM_PERIODS_BYTES_MIN\t128\n#define UX500_PLATFORM_PERIODS_BYTES_MAX\t(64 * PAGE_SIZE)\n#define UX500_PLATFORM_PERIODS_MIN\t\t2\n#define UX500_PLATFORM_PERIODS_MAX\t\t48\n#define UX500_PLATFORM_BUFFER_BYTES_MAX\t\t(2048 * PAGE_SIZE)\n\nstatic int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct dma_slave_config *slave_config)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_dmaengine_dai_dma_data *snd_dma_params;\n\tdma_addr_t dma_addr;\n\tint ret;\n\n\tsnd_dma_params = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tdma_addr = snd_dma_params->addr;\n\n\tret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\n\tif (ret)\n\t\treturn ret;\n\n\tslave_config->dst_maxburst = 4;\n\tslave_config->src_maxburst = 4;\n\n\tslave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tslave_config->dst_addr = dma_addr;\n\telse\n\t\tslave_config->src_addr = dma_addr;\n\n\treturn 0;\n}\n\nstatic const struct snd_dmaengine_pcm_config ux500_dmaengine_of_pcm_config = {\n\t.prepare_slave_config = ux500_pcm_prepare_slave_config,\n};\n\nint ux500_pcm_register_platform(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = snd_dmaengine_pcm_register(&pdev->dev,\n\t\t\t\t\t &ux500_dmaengine_of_pcm_config, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: ERROR: Failed to register platform '%s' (%d)!\\n\",\n\t\t\t__func__, pdev->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ux500_pcm_register_platform);\n\nint ux500_pcm_unregister_platform(struct platform_device *pdev)\n{\n\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ux500_pcm_unregister_platform);\n\nMODULE_AUTHOR(\"Ola Lilja\");\nMODULE_AUTHOR(\"Roger Nilsson\");\nMODULE_DESCRIPTION(\"ASoC UX500 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}