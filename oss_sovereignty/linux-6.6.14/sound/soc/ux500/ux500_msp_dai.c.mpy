{
  "module_name": "ux500_msp_dai.c",
  "hash_id": "aff03f905c13d800064cf2064e0d03d8fe43746db391a952b6c5b09f9f8b85bb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ux500/ux500_msp_dai.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mfd/dbx500-prcmu.h>\n\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"ux500_msp_i2s.h\"\n#include \"ux500_msp_dai.h\"\n#include \"ux500_pcm.h\"\n\nstatic int setup_pcm_multichan(struct snd_soc_dai *dai,\n\t\t\tstruct ux500_msp_config *msp_config)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tstruct msp_multichannel_config *multi =\n\t\t\t\t\t&msp_config->multichannel_config;\n\n\tif (drvdata->slots > 1) {\n\t\tmsp_config->multichannel_configured = 1;\n\n\t\tmulti->tx_multichannel_enable = true;\n\t\tmulti->rx_multichannel_enable = true;\n\t\tmulti->rx_comparison_enable_mode = MSP_COMPARISON_DISABLED;\n\n\t\tmulti->tx_channel_0_enable = drvdata->tx_mask;\n\t\tmulti->tx_channel_1_enable = 0;\n\t\tmulti->tx_channel_2_enable = 0;\n\t\tmulti->tx_channel_3_enable = 0;\n\n\t\tmulti->rx_channel_0_enable = drvdata->rx_mask;\n\t\tmulti->rx_channel_1_enable = 0;\n\t\tmulti->rx_channel_2_enable = 0;\n\t\tmulti->rx_channel_3_enable = 0;\n\n\t\tdev_dbg(dai->dev,\n\t\t\t\"%s: Multichannel enabled. Slots: %d, TX: %u, RX: %u\\n\",\n\t\t\t__func__, drvdata->slots, multi->tx_channel_0_enable,\n\t\t\tmulti->rx_channel_0_enable);\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_frameper(struct snd_soc_dai *dai, unsigned int rate,\n\t\t\tstruct msp_protdesc *prot_desc)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tswitch (drvdata->slots) {\n\tcase 1:\n\t\tswitch (rate) {\n\t\tcase 8000:\n\t\t\tprot_desc->frame_period =\n\t\t\t\tFRAME_PER_SINGLE_SLOT_8_KHZ;\n\t\t\tbreak;\n\n\t\tcase 16000:\n\t\t\tprot_desc->frame_period =\n\t\t\t\tFRAME_PER_SINGLE_SLOT_16_KHZ;\n\t\t\tbreak;\n\n\t\tcase 44100:\n\t\t\tprot_desc->frame_period =\n\t\t\t\tFRAME_PER_SINGLE_SLOT_44_1_KHZ;\n\t\t\tbreak;\n\n\t\tcase 48000:\n\t\t\tprot_desc->frame_period =\n\t\t\t\tFRAME_PER_SINGLE_SLOT_48_KHZ;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"%s: Error: Unsupported sample-rate (freq = %d)!\\n\",\n\t\t\t\t__func__, rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tprot_desc->frame_period = FRAME_PER_2_SLOTS;\n\t\tbreak;\n\n\tcase 8:\n\t\tprot_desc->frame_period = FRAME_PER_8_SLOTS;\n\t\tbreak;\n\n\tcase 16:\n\t\tprot_desc->frame_period = FRAME_PER_16_SLOTS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported slot-count (slots = %d)!\\n\",\n\t\t\t__func__, drvdata->slots);\n\t\treturn -EINVAL;\n\t}\n\n\tprot_desc->clocks_per_frame =\n\t\t\tprot_desc->frame_period+1;\n\n\tdev_dbg(dai->dev, \"%s: Clocks per frame: %u\\n\",\n\t\t__func__,\n\t\tprot_desc->clocks_per_frame);\n\n\treturn 0;\n}\n\nstatic int setup_pcm_framing(struct snd_soc_dai *dai, unsigned int rate,\n\t\t\tstruct msp_protdesc *prot_desc)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tu32 frame_length = MSP_FRAME_LEN_1;\n\n\tprot_desc->frame_width = 0;\n\n\tswitch (drvdata->slots) {\n\tcase 1:\n\t\tframe_length = MSP_FRAME_LEN_1;\n\t\tbreak;\n\n\tcase 2:\n\t\tframe_length = MSP_FRAME_LEN_2;\n\t\tbreak;\n\n\tcase 8:\n\t\tframe_length = MSP_FRAME_LEN_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tframe_length = MSP_FRAME_LEN_16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported slot-count (slots = %d)!\\n\",\n\t\t\t__func__, drvdata->slots);\n\t\treturn -EINVAL;\n\t}\n\n\tprot_desc->tx_frame_len_1 = frame_length;\n\tprot_desc->rx_frame_len_1 = frame_length;\n\tprot_desc->tx_frame_len_2 = frame_length;\n\tprot_desc->rx_frame_len_2 = frame_length;\n\n\tprot_desc->tx_elem_len_1 = MSP_ELEM_LEN_16;\n\tprot_desc->rx_elem_len_1 = MSP_ELEM_LEN_16;\n\tprot_desc->tx_elem_len_2 = MSP_ELEM_LEN_16;\n\tprot_desc->rx_elem_len_2 = MSP_ELEM_LEN_16;\n\n\treturn setup_frameper(dai, rate, prot_desc);\n}\n\nstatic int setup_clocking(struct snd_soc_dai *dai,\n\t\t\tunsigned int fmt,\n\t\t\tstruct ux500_msp_config *msp_config)\n{\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tmsp_config->tx_fsync_pol ^= 1 << TFSPOL_SHIFT;\n\t\tmsp_config->rx_fsync_pol ^= 1 << RFSPOL_SHIFT;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported inversion (fmt = 0x%x)!\\n\",\n\t\t\t__func__, fmt);\n\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tdev_dbg(dai->dev, \"%s: Codec is master.\\n\", __func__);\n\n\t\tmsp_config->iodelay = 0x20;\n\t\tmsp_config->rx_fsync_sel = 0;\n\t\tmsp_config->tx_fsync_sel = 1 << TFSSEL_SHIFT;\n\t\tmsp_config->tx_clk_sel = 0;\n\t\tmsp_config->rx_clk_sel = 0;\n\t\tmsp_config->srg_clk_sel = 0x2 << SCKSEL_SHIFT;\n\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tdev_dbg(dai->dev, \"%s: Codec is slave.\\n\", __func__);\n\n\t\tmsp_config->tx_clk_sel = TX_CLK_SEL_SRG;\n\t\tmsp_config->tx_fsync_sel = TX_SYNC_SRG_PROG;\n\t\tmsp_config->rx_clk_sel = RX_CLK_SEL_SRG;\n\t\tmsp_config->rx_fsync_sel = RX_SYNC_SRG;\n\t\tmsp_config->srg_clk_sel = 1 << SCKSEL_SHIFT;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev, \"%s: Error: Unsupported master (fmt = 0x%x)!\\n\",\n\t\t\t__func__, fmt);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_pcm_protdesc(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int fmt,\n\t\t\t\tstruct msp_protdesc *prot_desc)\n{\n\tprot_desc->rx_phase_mode = MSP_SINGLE_PHASE;\n\tprot_desc->tx_phase_mode = MSP_SINGLE_PHASE;\n\tprot_desc->rx_phase2_start_mode = MSP_PHASE2_START_MODE_IMEDIATE;\n\tprot_desc->tx_phase2_start_mode = MSP_PHASE2_START_MODE_IMEDIATE;\n\tprot_desc->rx_byte_order = MSP_BTF_MS_BIT_FIRST;\n\tprot_desc->tx_byte_order = MSP_BTF_MS_BIT_FIRST;\n\tprot_desc->tx_fsync_pol = MSP_FSYNC_POL(MSP_FSYNC_POL_ACT_HI);\n\tprot_desc->rx_fsync_pol = MSP_FSYNC_POL_ACT_HI << RFSPOL_SHIFT;\n\n\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) {\n\t\tdev_dbg(dai->dev, \"%s: DSP_A.\\n\", __func__);\n\t\tprot_desc->rx_clk_pol = MSP_RISING_EDGE;\n\t\tprot_desc->tx_clk_pol = MSP_FALLING_EDGE;\n\n\t\tprot_desc->rx_data_delay = MSP_DELAY_1;\n\t\tprot_desc->tx_data_delay = MSP_DELAY_1;\n\t} else {\n\t\tdev_dbg(dai->dev, \"%s: DSP_B.\\n\", __func__);\n\t\tprot_desc->rx_clk_pol = MSP_FALLING_EDGE;\n\t\tprot_desc->tx_clk_pol = MSP_RISING_EDGE;\n\n\t\tprot_desc->rx_data_delay = MSP_DELAY_0;\n\t\tprot_desc->tx_data_delay = MSP_DELAY_0;\n\t}\n\n\tprot_desc->rx_half_word_swap = MSP_SWAP_NONE;\n\tprot_desc->tx_half_word_swap = MSP_SWAP_NONE;\n\tprot_desc->compression_mode = MSP_COMPRESS_MODE_LINEAR;\n\tprot_desc->expansion_mode = MSP_EXPAND_MODE_LINEAR;\n\tprot_desc->frame_sync_ignore = MSP_FSYNC_IGNORE;\n\n\treturn 0;\n}\n\nstatic int setup_i2s_protdesc(struct msp_protdesc *prot_desc)\n{\n\tprot_desc->rx_phase_mode = MSP_DUAL_PHASE;\n\tprot_desc->tx_phase_mode = MSP_DUAL_PHASE;\n\tprot_desc->rx_phase2_start_mode = MSP_PHASE2_START_MODE_FSYNC;\n\tprot_desc->tx_phase2_start_mode = MSP_PHASE2_START_MODE_FSYNC;\n\tprot_desc->rx_byte_order = MSP_BTF_MS_BIT_FIRST;\n\tprot_desc->tx_byte_order = MSP_BTF_MS_BIT_FIRST;\n\tprot_desc->tx_fsync_pol = MSP_FSYNC_POL(MSP_FSYNC_POL_ACT_LO);\n\tprot_desc->rx_fsync_pol = MSP_FSYNC_POL_ACT_LO << RFSPOL_SHIFT;\n\n\tprot_desc->rx_frame_len_1 = MSP_FRAME_LEN_1;\n\tprot_desc->rx_frame_len_2 = MSP_FRAME_LEN_1;\n\tprot_desc->tx_frame_len_1 = MSP_FRAME_LEN_1;\n\tprot_desc->tx_frame_len_2 = MSP_FRAME_LEN_1;\n\tprot_desc->rx_elem_len_1 = MSP_ELEM_LEN_16;\n\tprot_desc->rx_elem_len_2 = MSP_ELEM_LEN_16;\n\tprot_desc->tx_elem_len_1 = MSP_ELEM_LEN_16;\n\tprot_desc->tx_elem_len_2 = MSP_ELEM_LEN_16;\n\n\tprot_desc->rx_clk_pol = MSP_RISING_EDGE;\n\tprot_desc->tx_clk_pol = MSP_FALLING_EDGE;\n\n\tprot_desc->rx_data_delay = MSP_DELAY_0;\n\tprot_desc->tx_data_delay = MSP_DELAY_0;\n\n\tprot_desc->tx_half_word_swap = MSP_SWAP_NONE;\n\tprot_desc->rx_half_word_swap = MSP_SWAP_NONE;\n\tprot_desc->compression_mode = MSP_COMPRESS_MODE_LINEAR;\n\tprot_desc->expansion_mode = MSP_EXPAND_MODE_LINEAR;\n\tprot_desc->frame_sync_ignore = MSP_FSYNC_IGNORE;\n\n\treturn 0;\n}\n\nstatic int setup_msp_config(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai,\n\t\t\tstruct ux500_msp_config *msp_config)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tstruct msp_protdesc *prot_desc = &msp_config->protdesc;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int fmt = drvdata->fmt;\n\tint ret;\n\n\tmemset(msp_config, 0, sizeof(*msp_config));\n\n\tmsp_config->f_inputclk = drvdata->master_clk;\n\n\tmsp_config->tx_fifo_config = TX_FIFO_ENABLE;\n\tmsp_config->rx_fifo_config = RX_FIFO_ENABLE;\n\tmsp_config->def_elem_len = 1;\n\tmsp_config->direction = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\t\tMSP_DIR_TX : MSP_DIR_RX;\n\tmsp_config->data_size = MSP_DATA_BITS_32;\n\tmsp_config->frame_freq = runtime->rate;\n\n\tdev_dbg(dai->dev, \"%s: f_inputclk = %u, frame_freq = %u.\\n\",\n\t       __func__, msp_config->f_inputclk, msp_config->frame_freq);\n\t \n\tprot_desc->clocks_per_frame = 1;\n\n\tdev_dbg(dai->dev, \"%s: rate: %u, channels: %d.\\n\", __func__,\n\t\truntime->rate, runtime->channels);\n\tswitch (fmt &\n\t\t(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK)) {\n\tcase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_BP_FP:\n\t\tdev_dbg(dai->dev, \"%s: SND_SOC_DAIFMT_I2S.\\n\", __func__);\n\n\t\tmsp_config->default_protdesc = 1;\n\t\tmsp_config->protocol = MSP_I2S_PROTOCOL;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_BC_FC:\n\t\tdev_dbg(dai->dev, \"%s: SND_SOC_DAIFMT_I2S.\\n\", __func__);\n\n\t\tmsp_config->data_size = MSP_DATA_BITS_16;\n\t\tmsp_config->protocol = MSP_I2S_PROTOCOL;\n\n\t\tret = setup_i2s_protdesc(prot_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_BC_FC:\n\t\tdev_dbg(dai->dev, \"%s: PCM format.\\n\", __func__);\n\n\t\tmsp_config->data_size = MSP_DATA_BITS_16;\n\t\tmsp_config->protocol = MSP_PCM_PROTOCOL;\n\n\t\tret = setup_pcm_protdesc(dai, fmt, prot_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = setup_pcm_multichan(dai, msp_config);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = setup_pcm_framing(dai, runtime->rate, prot_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev, \"%s: Error: Unsupported format (%d)!\\n\",\n\t\t\t__func__, fmt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn setup_clocking(dai, fmt, msp_config);\n}\n\nstatic int ux500_msp_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d (%s): Enter.\\n\", __func__, dai->id,\n\t\tsnd_pcm_stream_str(substream));\n\n\t \n\tret = regulator_enable(drvdata->reg_vape);\n\tif (ret != 0) {\n\t\tdev_err(drvdata->msp->dev,\n\t\t\t\"%s: Failed to enable regulator!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tdev_dbg(dai->dev, \"%s: Enabling MSP-clocks.\\n\", __func__);\n\tret = clk_prepare_enable(drvdata->pclk);\n\tif (ret) {\n\t\tdev_err(drvdata->msp->dev,\n\t\t\t\"%s: Failed to prepare/enable pclk!\\n\", __func__);\n\t\tgoto err_pclk;\n\t}\n\n\tret = clk_prepare_enable(drvdata->clk);\n\tif (ret) {\n\t\tdev_err(drvdata->msp->dev,\n\t\t\t\"%s: Failed to prepare/enable clk!\\n\", __func__);\n\t\tgoto err_clk;\n\t}\n\n\treturn ret;\nerr_clk:\n\tclk_disable_unprepare(drvdata->pclk);\nerr_pclk:\n\tregulator_disable(drvdata->reg_vape);\n\treturn ret;\n}\n\nstatic void ux500_msp_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tint ret;\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d (%s): Enter.\\n\", __func__, dai->id,\n\t\tsnd_pcm_stream_str(substream));\n\n\tif (drvdata->vape_opp_constraint == 1) {\n\t\tprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\n\t\t\t\t\t\"ux500_msp_i2s\", 50);\n\t\tdrvdata->vape_opp_constraint = 0;\n\t}\n\n\tif (ux500_msp_i2s_close(drvdata->msp,\n\t\t\t\tis_playback ? MSP_DIR_TX : MSP_DIR_RX)) {\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: MSP %d (%s): Unable to close i2s.\\n\",\n\t\t\t__func__, dai->id, snd_pcm_stream_str(substream));\n\t}\n\n\t \n\tclk_disable_unprepare(drvdata->clk);\n\tclk_disable_unprepare(drvdata->pclk);\n\n\t \n\tret = regulator_disable(drvdata->reg_vape);\n\tif (ret < 0)\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: ERROR: Failed to disable regulator (%d)!\\n\",\n\t\t\t__func__, ret);\n}\n\nstatic int ux500_msp_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ux500_msp_config msp_config;\n\n\tdev_dbg(dai->dev, \"%s: MSP %d (%s): Enter (rate = %d).\\n\", __func__,\n\t\tdai->id, snd_pcm_stream_str(substream), runtime->rate);\n\n\tsetup_msp_config(substream, dai, &msp_config);\n\n\tret = ux500_msp_i2s_open(drvdata->msp, &msp_config);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"%s: Error: msp_setup failed (ret = %d)!\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((drvdata->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) &&\n\t\t(drvdata->msp->f_bitclk > 19200000)) {\n\t\t \n\t\tprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\n\t\t\t\t\t\"ux500-msp-i2s\", 100);\n\t\tdrvdata->vape_opp_constraint = 1;\n\t} else {\n\t\tprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\n\t\t\t\t\t\"ux500-msp-i2s\", 50);\n\t\tdrvdata->vape_opp_constraint = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int ux500_msp_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tunsigned int mask, slots_active;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d (%s): Enter.\\n\",\n\t\t\t__func__, dai->id, snd_pcm_stream_str(substream));\n\n\tswitch (drvdata->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsnd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t1, 2);\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_B:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tmask = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\tdrvdata->tx_mask :\n\t\t\tdrvdata->rx_mask;\n\n\t\tslots_active = hweight32(mask);\n\t\tdev_dbg(dai->dev, \"TDM-slots active: %d\", slots_active);\n\n\t\tsnd_pcm_hw_constraint_single(runtime,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\tslots_active);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported protocol (fmt = 0x%x)!\\n\",\n\t\t\t__func__, drvdata->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ux500_msp_dai_set_dai_fmt(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int fmt)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d: Enter.\\n\", __func__, dai->id);\n\n\tswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\n\t\tSND_SOC_DAIFMT_CLOCK_PROVIDER_MASK)) {\n\tcase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported protocol/master (fmt = 0x%x)!\\n\",\n\t\t\t__func__, drvdata->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"%s: Error: Unsupported inversion (fmt = 0x%x)!\\n\",\n\t\t\t__func__, drvdata->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata->fmt = fmt;\n\treturn 0;\n}\n\nstatic int ux500_msp_dai_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask,\n\t\t\t\tint slots, int slot_width)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tunsigned int cap;\n\n\tswitch (slots) {\n\tcase 1:\n\t\tcap = 0x01;\n\t\tbreak;\n\tcase 2:\n\t\tcap = 0x03;\n\t\tbreak;\n\tcase 8:\n\t\tcap = 0xFF;\n\t\tbreak;\n\tcase 16:\n\t\tcap = 0xFFFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"%s: Error: Unsupported slot-count (%d)!\\n\",\n\t\t\t__func__, slots);\n\t\treturn -EINVAL;\n\t}\n\tdrvdata->slots = slots;\n\n\tif (!(slot_width == 16)) {\n\t\tdev_err(dai->dev, \"%s: Error: Unsupported slot-width (%d)!\\n\",\n\t\t\t__func__, slot_width);\n\t\treturn -EINVAL;\n\t}\n\tdrvdata->slot_width = slot_width;\n\n\tdrvdata->tx_mask = tx_mask & cap;\n\tdrvdata->rx_mask = rx_mask & cap;\n\n\treturn 0;\n}\n\nstatic int ux500_msp_dai_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d: Enter. clk-id: %d, freq: %u.\\n\",\n\t\t__func__, dai->id, clk_id, freq);\n\n\tswitch (clk_id) {\n\tcase UX500_MSP_MASTER_CLOCK:\n\t\tdrvdata->master_clk = freq;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev, \"%s: MSP %d: Invalid clk-id (%d)!\\n\",\n\t\t\t__func__, dai->id, clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ux500_msp_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\n\tdev_dbg(dai->dev, \"%s: MSP %d (%s): Enter (msp->id = %d, cmd = %d).\\n\",\n\t\t__func__, dai->id, snd_pcm_stream_str(substream),\n\t\t(int)drvdata->msp->id, cmd);\n\n\tret = ux500_msp_i2s_trigger(drvdata->msp, cmd, substream->stream);\n\n\treturn ret;\n}\n\nstatic int ux500_msp_dai_of_probe(struct snd_soc_dai *dai)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\n\tstruct snd_dmaengine_dai_dma_data *playback_dma_data;\n\tstruct snd_dmaengine_dai_dma_data *capture_dma_data;\n\n\tplayback_dma_data = devm_kzalloc(dai->dev,\n\t\t\t\t\t sizeof(*playback_dma_data),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!playback_dma_data)\n\t\treturn -ENOMEM;\n\n\tcapture_dma_data = devm_kzalloc(dai->dev,\n\t\t\t\t\tsizeof(*capture_dma_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!capture_dma_data)\n\t\treturn -ENOMEM;\n\n\tplayback_dma_data->addr = drvdata->msp->tx_rx_addr;\n\tcapture_dma_data->addr = drvdata->msp->tx_rx_addr;\n\n\tplayback_dma_data->maxburst = 4;\n\tcapture_dma_data->maxburst = 4;\n\n\tsnd_soc_dai_init_dma_data(dai, playback_dma_data, capture_dma_data);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ux500_msp_dai_ops[] = {\n\t{\n\t\t.probe = ux500_msp_dai_of_probe,\n\t\t.set_sysclk = ux500_msp_dai_set_dai_sysclk,\n\t\t.set_fmt = ux500_msp_dai_set_dai_fmt,\n\t\t.set_tdm_slot = ux500_msp_dai_set_tdm_slot,\n\t\t.startup = ux500_msp_dai_startup,\n\t\t.shutdown = ux500_msp_dai_shutdown,\n\t\t.prepare = ux500_msp_dai_prepare,\n\t\t.trigger = ux500_msp_dai_trigger,\n\t\t.hw_params = ux500_msp_dai_hw_params,\n\t}\n};\n\nstatic struct snd_soc_dai_driver ux500_msp_dai_drv = {\n\t.playback.channels_min = UX500_MSP_MIN_CHANNELS,\n\t.playback.channels_max = UX500_MSP_MAX_CHANNELS,\n\t.playback.rates        = UX500_I2S_RATES,\n\t.playback.formats      = UX500_I2S_FORMATS,\n\t.capture.channels_min  = UX500_MSP_MIN_CHANNELS,\n\t.capture.channels_max  = UX500_MSP_MAX_CHANNELS,\n\t.capture.rates         = UX500_I2S_RATES,\n\t.capture.formats       = UX500_I2S_FORMATS,\n\t.ops                   = ux500_msp_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver ux500_msp_component = {\n\t.name\t\t\t= \"ux500-msp\",\n\t.legacy_dai_naming\t= 1,\n};\n\n\nstatic int ux500_msp_drv_probe(struct platform_device *pdev)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata;\n\tint ret = 0;\n\n\tdrvdata = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct ux500_msp_i2s_drvdata),\n\t\t\t\tGFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->fmt = 0;\n\tdrvdata->slots = 1;\n\tdrvdata->tx_mask = 0x01;\n\tdrvdata->rx_mask = 0x01;\n\tdrvdata->slot_width = 16;\n\tdrvdata->master_clk = MSP_INPUT_FREQ_APB;\n\n\tdrvdata->reg_vape = devm_regulator_get(&pdev->dev, \"v-ape\");\n\tif (IS_ERR(drvdata->reg_vape)) {\n\t\tret = (int)PTR_ERR(drvdata->reg_vape);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: ERROR: Failed to get Vape supply (%d)!\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\tprcmu_qos_add_requirement(PRCMU_QOS_APE_OPP, (char *)pdev->name, 50);\n\n\tdrvdata->pclk = devm_clk_get(&pdev->dev, \"apb_pclk\");\n\tif (IS_ERR(drvdata->pclk)) {\n\t\tret = (int)PTR_ERR(drvdata->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: ERROR: devm_clk_get of pclk failed (%d)!\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tdrvdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(drvdata->clk)) {\n\t\tret = (int)PTR_ERR(drvdata->clk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: ERROR: devm_clk_get failed (%d)!\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = ux500_msp_i2s_init_msp(pdev, &drvdata->msp);\n\tif (!drvdata->msp) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: ERROR: Failed to init MSP-struct (%d)!\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\tdev_set_drvdata(&pdev->dev, drvdata);\n\n\tret = snd_soc_register_component(&pdev->dev, &ux500_msp_component,\n\t\t\t\t\t &ux500_msp_dai_drv, 1);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Error: %s: Failed to register MSP%d!\\n\",\n\t\t\t__func__, drvdata->msp->id);\n\t\treturn ret;\n\t}\n\n\tret = ux500_pcm_register_platform(pdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error: %s: Failed to register PCM platform device!\\n\",\n\t\t\t__func__);\n\t\tgoto err_reg_plat;\n\t}\n\n\treturn 0;\n\nerr_reg_plat:\n\tsnd_soc_unregister_component(&pdev->dev);\n\treturn ret;\n}\n\nstatic void ux500_msp_drv_remove(struct platform_device *pdev)\n{\n\tstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(&pdev->dev);\n\n\tux500_pcm_unregister_platform(pdev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\tprcmu_qos_remove_requirement(PRCMU_QOS_APE_OPP, \"ux500_msp_i2s\");\n\n\tux500_msp_i2s_cleanup_msp(pdev, drvdata->msp);\n}\n\nstatic const struct of_device_id ux500_msp_i2s_match[] = {\n\t{ .compatible = \"stericsson,ux500-msp-i2s\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ux500_msp_i2s_match);\n\nstatic struct platform_driver msp_i2s_driver = {\n\t.driver = {\n\t\t.name = \"ux500-msp-i2s\",\n\t\t.of_match_table = ux500_msp_i2s_match,\n\t},\n\t.probe = ux500_msp_drv_probe,\n\t.remove_new = ux500_msp_drv_remove,\n};\nmodule_platform_driver(msp_i2s_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}