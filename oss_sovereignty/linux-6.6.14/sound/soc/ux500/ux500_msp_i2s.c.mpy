{
  "module_name": "ux500_msp_i2s.c",
  "hash_id": "2ce939b74d52d1440b953edef8aacdf748e5efe64c82d87afe5092f7f7fa4a33",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ux500/ux500_msp_i2s.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include <sound/soc.h>\n\n#include \"ux500_msp_i2s.h\"\n\n  \nstatic const struct msp_protdesc prot_descs[] = {\n\t{  \n\t\tMSP_SINGLE_PHASE,\n\t\tMSP_SINGLE_PHASE,\n\t\tMSP_PHASE2_START_MODE_IMEDIATE,\n\t\tMSP_PHASE2_START_MODE_IMEDIATE,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_ELEM_LEN_32,\n\t\tMSP_ELEM_LEN_32,\n\t\tMSP_ELEM_LEN_32,\n\t\tMSP_ELEM_LEN_32,\n\t\tMSP_DELAY_1,\n\t\tMSP_DELAY_1,\n\t\tMSP_RISING_EDGE,\n\t\tMSP_FALLING_EDGE,\n\t\tMSP_FSYNC_POL_ACT_LO,\n\t\tMSP_FSYNC_POL_ACT_LO,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_COMPRESS_MODE_LINEAR,\n\t\tMSP_EXPAND_MODE_LINEAR,\n\t\tMSP_FSYNC_IGNORE,\n\t\t31,\n\t\t15,\n\t\t32,\n\t}, {  \n\t\tMSP_DUAL_PHASE,\n\t\tMSP_DUAL_PHASE,\n\t\tMSP_PHASE2_START_MODE_FSYNC,\n\t\tMSP_PHASE2_START_MODE_FSYNC,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_ELEM_LEN_16,\n\t\tMSP_ELEM_LEN_16,\n\t\tMSP_ELEM_LEN_16,\n\t\tMSP_ELEM_LEN_16,\n\t\tMSP_DELAY_0,\n\t\tMSP_DELAY_0,\n\t\tMSP_RISING_EDGE,\n\t\tMSP_FALLING_EDGE,\n\t\tMSP_FSYNC_POL_ACT_HI,\n\t\tMSP_FSYNC_POL_ACT_HI,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_COMPRESS_MODE_LINEAR,\n\t\tMSP_EXPAND_MODE_LINEAR,\n\t\tMSP_FSYNC_IGNORE,\n\t\t255,\n\t\t0,\n\t\t256,\n\t}, {  \n\t\tMSP_SINGLE_PHASE,\n\t\tMSP_SINGLE_PHASE,\n\t\tMSP_PHASE2_START_MODE_FSYNC,\n\t\tMSP_PHASE2_START_MODE_FSYNC,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_BTF_MS_BIT_FIRST,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_FRAME_LEN_1,\n\t\tMSP_ELEM_LEN_8,\n\t\tMSP_ELEM_LEN_8,\n\t\tMSP_ELEM_LEN_8,\n\t\tMSP_ELEM_LEN_8,\n\t\tMSP_DELAY_0,\n\t\tMSP_DELAY_0,\n\t\tMSP_RISING_EDGE,\n\t\tMSP_RISING_EDGE,\n\t\tMSP_FSYNC_POL_ACT_HI,\n\t\tMSP_FSYNC_POL_ACT_HI,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_SWAP_NONE,\n\t\tMSP_COMPRESS_MODE_LINEAR,\n\t\tMSP_EXPAND_MODE_LINEAR,\n\t\tMSP_FSYNC_IGNORE,\n\t\t255,\n\t\t0,\n\t\t256,\n\t},\n};\n\nstatic void set_prot_desc_tx(struct ux500_msp *msp,\n\t\t\tstruct msp_protdesc *protdesc,\n\t\t\tenum msp_data_size data_size)\n{\n\tu32 temp_reg = 0;\n\n\ttemp_reg |= MSP_P2_ENABLE_BIT(protdesc->tx_phase_mode);\n\ttemp_reg |= MSP_P2_START_MODE_BIT(protdesc->tx_phase2_start_mode);\n\ttemp_reg |= MSP_P1_FRAME_LEN_BITS(protdesc->tx_frame_len_1);\n\ttemp_reg |= MSP_P2_FRAME_LEN_BITS(protdesc->tx_frame_len_2);\n\tif (msp->def_elem_len) {\n\t\ttemp_reg |= MSP_P1_ELEM_LEN_BITS(protdesc->tx_elem_len_1);\n\t\ttemp_reg |= MSP_P2_ELEM_LEN_BITS(protdesc->tx_elem_len_2);\n\t} else {\n\t\ttemp_reg |= MSP_P1_ELEM_LEN_BITS(data_size);\n\t\ttemp_reg |= MSP_P2_ELEM_LEN_BITS(data_size);\n\t}\n\ttemp_reg |= MSP_DATA_DELAY_BITS(protdesc->tx_data_delay);\n\ttemp_reg |= MSP_SET_ENDIANNES_BIT(protdesc->tx_byte_order);\n\ttemp_reg |= MSP_FSYNC_POL(protdesc->tx_fsync_pol);\n\ttemp_reg |= MSP_DATA_WORD_SWAP(protdesc->tx_half_word_swap);\n\ttemp_reg |= MSP_SET_COMPANDING_MODE(protdesc->compression_mode);\n\ttemp_reg |= MSP_SET_FSYNC_IGNORE(protdesc->frame_sync_ignore);\n\n\twritel(temp_reg, msp->registers + MSP_TCF);\n}\n\nstatic void set_prot_desc_rx(struct ux500_msp *msp,\n\t\t\tstruct msp_protdesc *protdesc,\n\t\t\tenum msp_data_size data_size)\n{\n\tu32 temp_reg = 0;\n\n\ttemp_reg |= MSP_P2_ENABLE_BIT(protdesc->rx_phase_mode);\n\ttemp_reg |= MSP_P2_START_MODE_BIT(protdesc->rx_phase2_start_mode);\n\ttemp_reg |= MSP_P1_FRAME_LEN_BITS(protdesc->rx_frame_len_1);\n\ttemp_reg |= MSP_P2_FRAME_LEN_BITS(protdesc->rx_frame_len_2);\n\tif (msp->def_elem_len) {\n\t\ttemp_reg |= MSP_P1_ELEM_LEN_BITS(protdesc->rx_elem_len_1);\n\t\ttemp_reg |= MSP_P2_ELEM_LEN_BITS(protdesc->rx_elem_len_2);\n\t} else {\n\t\ttemp_reg |= MSP_P1_ELEM_LEN_BITS(data_size);\n\t\ttemp_reg |= MSP_P2_ELEM_LEN_BITS(data_size);\n\t}\n\n\ttemp_reg |= MSP_DATA_DELAY_BITS(protdesc->rx_data_delay);\n\ttemp_reg |= MSP_SET_ENDIANNES_BIT(protdesc->rx_byte_order);\n\ttemp_reg |= MSP_FSYNC_POL(protdesc->rx_fsync_pol);\n\ttemp_reg |= MSP_DATA_WORD_SWAP(protdesc->rx_half_word_swap);\n\ttemp_reg |= MSP_SET_COMPANDING_MODE(protdesc->expansion_mode);\n\ttemp_reg |= MSP_SET_FSYNC_IGNORE(protdesc->frame_sync_ignore);\n\n\twritel(temp_reg, msp->registers + MSP_RCF);\n}\n\nstatic int configure_protocol(struct ux500_msp *msp,\n\t\t\tstruct ux500_msp_config *config)\n{\n\tstruct msp_protdesc *protdesc;\n\tenum msp_data_size data_size;\n\tu32 temp_reg = 0;\n\n\tdata_size = config->data_size;\n\tmsp->def_elem_len = config->def_elem_len;\n\tif (config->default_protdesc == 1) {\n\t\tif (config->protocol >= MSP_INVALID_PROTOCOL) {\n\t\t\tdev_err(msp->dev, \"%s: ERROR: Invalid protocol!\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprotdesc =\n\t\t    (struct msp_protdesc *)&prot_descs[config->protocol];\n\t} else {\n\t\tprotdesc = (struct msp_protdesc *)&config->protdesc;\n\t}\n\n\tif (data_size < MSP_DATA_BITS_DEFAULT || data_size > MSP_DATA_BITS_32) {\n\t\tdev_err(msp->dev,\n\t\t\t\"%s: ERROR: Invalid data-size requested (data_size = %d)!\\n\",\n\t\t\t__func__, data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (config->direction & MSP_DIR_TX)\n\t\tset_prot_desc_tx(msp, protdesc, data_size);\n\tif (config->direction & MSP_DIR_RX)\n\t\tset_prot_desc_rx(msp, protdesc, data_size);\n\n\t \n\ttemp_reg = readl(msp->registers + MSP_GCR) & ~TX_CLK_POL_RISING;\n\ttemp_reg |= MSP_TX_CLKPOL_BIT(~protdesc->tx_clk_pol);\n\twritel(temp_reg, msp->registers + MSP_GCR);\n\ttemp_reg = readl(msp->registers + MSP_GCR) & ~RX_CLK_POL_RISING;\n\ttemp_reg |= MSP_RX_CLKPOL_BIT(protdesc->rx_clk_pol);\n\twritel(temp_reg, msp->registers + MSP_GCR);\n\n\treturn 0;\n}\n\nstatic int setup_bitclk(struct ux500_msp *msp, struct ux500_msp_config *config)\n{\n\tu32 reg_val_GCR;\n\tu32 frame_per = 0;\n\tu32 sck_div = 0;\n\tu32 frame_width = 0;\n\tu32 temp_reg = 0;\n\tstruct msp_protdesc *protdesc = NULL;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR & ~SRG_ENABLE, msp->registers + MSP_GCR);\n\n\tif (config->default_protdesc)\n\t\tprotdesc =\n\t\t\t(struct msp_protdesc *)&prot_descs[config->protocol];\n\telse\n\t\tprotdesc = (struct msp_protdesc *)&config->protdesc;\n\n\tswitch (config->protocol) {\n\tcase MSP_PCM_PROTOCOL:\n\tcase MSP_PCM_COMPAND_PROTOCOL:\n\t\tframe_width = protdesc->frame_width;\n\t\tsck_div = config->f_inputclk / (config->frame_freq *\n\t\t\t(protdesc->clocks_per_frame));\n\t\tframe_per = protdesc->frame_period;\n\t\tbreak;\n\tcase MSP_I2S_PROTOCOL:\n\t\tframe_width = protdesc->frame_width;\n\t\tsck_div = config->f_inputclk / (config->frame_freq *\n\t\t\t(protdesc->clocks_per_frame));\n\t\tframe_per = protdesc->frame_period;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(msp->dev, \"%s: ERROR: Unknown protocol (%d)!\\n\",\n\t\t\t__func__,\n\t\t\tconfig->protocol);\n\t\treturn -EINVAL;\n\t}\n\n\ttemp_reg = (sck_div - 1) & SCK_DIV_MASK;\n\ttemp_reg |= FRAME_WIDTH_BITS(frame_width);\n\ttemp_reg |= FRAME_PERIOD_BITS(frame_per);\n\twritel(temp_reg, msp->registers + MSP_SRG);\n\n\tmsp->f_bitclk = (config->f_inputclk)/(sck_div + 1);\n\n\t \n\tudelay(100);\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR | SRG_ENABLE, msp->registers + MSP_GCR);\n\tudelay(100);\n\n\treturn 0;\n}\n\nstatic int configure_multichannel(struct ux500_msp *msp,\n\t\t\t\tstruct ux500_msp_config *config)\n{\n\tstruct msp_protdesc *protdesc;\n\tstruct msp_multichannel_config *mcfg;\n\tu32 reg_val_MCR;\n\n\tif (config->default_protdesc == 1) {\n\t\tif (config->protocol >= MSP_INVALID_PROTOCOL) {\n\t\t\tdev_err(msp->dev,\n\t\t\t\t\"%s: ERROR: Invalid protocol (%d)!\\n\",\n\t\t\t\t__func__, config->protocol);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprotdesc = (struct msp_protdesc *)\n\t\t\t\t&prot_descs[config->protocol];\n\t} else {\n\t\tprotdesc = (struct msp_protdesc *)&config->protdesc;\n\t}\n\n\tmcfg = &config->multichannel_config;\n\tif (mcfg->tx_multichannel_enable) {\n\t\tif (protdesc->tx_phase_mode == MSP_SINGLE_PHASE) {\n\t\t\treg_val_MCR = readl(msp->registers + MSP_MCR);\n\t\t\twritel(reg_val_MCR | (mcfg->tx_multichannel_enable ?\n\t\t\t\t\t\t1 << TMCEN_BIT : 0),\n\t\t\t\tmsp->registers + MSP_MCR);\n\t\t\twritel(mcfg->tx_channel_0_enable,\n\t\t\t\tmsp->registers + MSP_TCE0);\n\t\t\twritel(mcfg->tx_channel_1_enable,\n\t\t\t\tmsp->registers + MSP_TCE1);\n\t\t\twritel(mcfg->tx_channel_2_enable,\n\t\t\t\tmsp->registers + MSP_TCE2);\n\t\t\twritel(mcfg->tx_channel_3_enable,\n\t\t\t\tmsp->registers + MSP_TCE3);\n\t\t} else {\n\t\t\tdev_err(msp->dev,\n\t\t\t\t\"%s: ERROR: Only single-phase supported (TX-mode: %d)!\\n\",\n\t\t\t\t__func__, protdesc->tx_phase_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (mcfg->rx_multichannel_enable) {\n\t\tif (protdesc->rx_phase_mode == MSP_SINGLE_PHASE) {\n\t\t\treg_val_MCR = readl(msp->registers + MSP_MCR);\n\t\t\twritel(reg_val_MCR | (mcfg->rx_multichannel_enable ?\n\t\t\t\t\t\t1 << RMCEN_BIT : 0),\n\t\t\t\tmsp->registers + MSP_MCR);\n\t\t\twritel(mcfg->rx_channel_0_enable,\n\t\t\t\t\tmsp->registers + MSP_RCE0);\n\t\t\twritel(mcfg->rx_channel_1_enable,\n\t\t\t\t\tmsp->registers + MSP_RCE1);\n\t\t\twritel(mcfg->rx_channel_2_enable,\n\t\t\t\t\tmsp->registers + MSP_RCE2);\n\t\t\twritel(mcfg->rx_channel_3_enable,\n\t\t\t\t\tmsp->registers + MSP_RCE3);\n\t\t} else {\n\t\t\tdev_err(msp->dev,\n\t\t\t\t\"%s: ERROR: Only single-phase supported (RX-mode: %d)!\\n\",\n\t\t\t\t__func__, protdesc->rx_phase_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (mcfg->rx_comparison_enable_mode) {\n\t\t\treg_val_MCR = readl(msp->registers + MSP_MCR);\n\t\t\twritel(reg_val_MCR |\n\t\t\t\t(mcfg->rx_comparison_enable_mode << RCMPM_BIT),\n\t\t\t\tmsp->registers + MSP_MCR);\n\n\t\t\twritel(mcfg->comparison_mask,\n\t\t\t\t\tmsp->registers + MSP_RCM);\n\t\t\twritel(mcfg->comparison_value,\n\t\t\t\t\tmsp->registers + MSP_RCV);\n\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int enable_msp(struct ux500_msp *msp, struct ux500_msp_config *config)\n{\n\tint status = 0;\n\tu32 reg_val_DMACR, reg_val_GCR;\n\n\t \n\tconfigure_protocol(msp, config);\n\tsetup_bitclk(msp, config);\n\tif (config->multichannel_configured == 1) {\n\t\tstatus = configure_multichannel(msp, config);\n\t\tif (status)\n\t\t\tdev_warn(msp->dev,\n\t\t\t\t\"%s: WARN: configure_multichannel failed (%d)!\\n\",\n\t\t\t\t__func__, status);\n\t}\n\n\treg_val_DMACR = readl(msp->registers + MSP_DMACR);\n\tif (config->direction & MSP_DIR_RX)\n\t\treg_val_DMACR |= RX_DMA_ENABLE;\n\tif (config->direction & MSP_DIR_TX)\n\t\treg_val_DMACR |= TX_DMA_ENABLE;\n\twritel(reg_val_DMACR, msp->registers + MSP_DMACR);\n\n\twritel(config->iodelay, msp->registers + MSP_IODLY);\n\n\t \n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR | FRAME_GEN_ENABLE, msp->registers + MSP_GCR);\n\n\treturn status;\n}\n\nstatic void flush_fifo_rx(struct ux500_msp *msp)\n{\n\tu32 reg_val_GCR, reg_val_FLR;\n\tu32 limit = 32;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR | RX_ENABLE, msp->registers + MSP_GCR);\n\n\treg_val_FLR = readl(msp->registers + MSP_FLR);\n\twhile (!(reg_val_FLR & RX_FIFO_EMPTY) && limit--) {\n\t\treadl(msp->registers + MSP_DR);\n\t\treg_val_FLR = readl(msp->registers + MSP_FLR);\n\t}\n\n\twritel(reg_val_GCR, msp->registers + MSP_GCR);\n}\n\nstatic void flush_fifo_tx(struct ux500_msp *msp)\n{\n\tu32 reg_val_GCR, reg_val_FLR;\n\tu32 limit = 32;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR | TX_ENABLE, msp->registers + MSP_GCR);\n\twritel(MSP_ITCR_ITEN | MSP_ITCR_TESTFIFO, msp->registers + MSP_ITCR);\n\n\treg_val_FLR = readl(msp->registers + MSP_FLR);\n\twhile (!(reg_val_FLR & TX_FIFO_EMPTY) && limit--) {\n\t\treadl(msp->registers + MSP_TSTDR);\n\t\treg_val_FLR = readl(msp->registers + MSP_FLR);\n\t}\n\twritel(0x0, msp->registers + MSP_ITCR);\n\twritel(reg_val_GCR, msp->registers + MSP_GCR);\n}\n\nint ux500_msp_i2s_open(struct ux500_msp *msp,\n\t\tstruct ux500_msp_config *config)\n{\n\tu32 old_reg, new_reg, mask;\n\tint res;\n\tunsigned int tx_sel, rx_sel, tx_busy, rx_busy;\n\n\tif (in_interrupt()) {\n\t\tdev_err(msp->dev,\n\t\t\t\"%s: ERROR: Open called in interrupt context!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\ttx_sel = (config->direction & MSP_DIR_TX) > 0;\n\trx_sel = (config->direction & MSP_DIR_RX) > 0;\n\tif (!tx_sel && !rx_sel) {\n\t\tdev_err(msp->dev, \"%s: Error: No direction selected!\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttx_busy = (msp->dir_busy & MSP_DIR_TX) > 0;\n\trx_busy = (msp->dir_busy & MSP_DIR_RX) > 0;\n\tif (tx_busy && tx_sel) {\n\t\tdev_err(msp->dev, \"%s: Error: TX is in use!\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\tif (rx_busy && rx_sel) {\n\t\tdev_err(msp->dev, \"%s: Error: RX is in use!\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tmsp->dir_busy |= (tx_sel ? MSP_DIR_TX : 0) | (rx_sel ? MSP_DIR_RX : 0);\n\n\t \n\tmask = RX_CLK_SEL_MASK | TX_CLK_SEL_MASK | RX_FSYNC_MASK |\n\t    TX_FSYNC_MASK | RX_SYNC_SEL_MASK | TX_SYNC_SEL_MASK |\n\t    RX_FIFO_ENABLE_MASK | TX_FIFO_ENABLE_MASK | SRG_CLK_SEL_MASK |\n\t    LOOPBACK_MASK | TX_EXTRA_DELAY_MASK;\n\n\tnew_reg = (config->tx_clk_sel | config->rx_clk_sel |\n\t\tconfig->rx_fsync_pol | config->tx_fsync_pol |\n\t\tconfig->rx_fsync_sel | config->tx_fsync_sel |\n\t\tconfig->rx_fifo_config | config->tx_fifo_config |\n\t\tconfig->srg_clk_sel | config->loopback_enable |\n\t\tconfig->tx_data_enable);\n\n\told_reg = readl(msp->registers + MSP_GCR);\n\told_reg &= ~mask;\n\tnew_reg |= old_reg;\n\twritel(new_reg, msp->registers + MSP_GCR);\n\n\tres = enable_msp(msp, config);\n\tif (res < 0) {\n\t\tdev_err(msp->dev, \"%s: ERROR: enable_msp failed (%d)!\\n\",\n\t\t\t__func__, res);\n\t\treturn -EBUSY;\n\t}\n\tif (config->loopback_enable & 0x80)\n\t\tmsp->loopback_enable = 1;\n\n\t \n\tflush_fifo_tx(msp);\n\tflush_fifo_rx(msp);\n\n\tmsp->msp_state = MSP_STATE_CONFIGURED;\n\treturn 0;\n}\n\nstatic void disable_msp_rx(struct ux500_msp *msp)\n{\n\tu32 reg_val_GCR, reg_val_DMACR, reg_val_IMSC;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR & ~RX_ENABLE, msp->registers + MSP_GCR);\n\treg_val_DMACR = readl(msp->registers + MSP_DMACR);\n\twritel(reg_val_DMACR & ~RX_DMA_ENABLE, msp->registers + MSP_DMACR);\n\treg_val_IMSC = readl(msp->registers + MSP_IMSC);\n\twritel(reg_val_IMSC &\n\t\t\t~(RX_SERVICE_INT | RX_OVERRUN_ERROR_INT),\n\t\t\tmsp->registers + MSP_IMSC);\n\n\tmsp->dir_busy &= ~MSP_DIR_RX;\n}\n\nstatic void disable_msp_tx(struct ux500_msp *msp)\n{\n\tu32 reg_val_GCR, reg_val_DMACR, reg_val_IMSC;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\twritel(reg_val_GCR & ~TX_ENABLE, msp->registers + MSP_GCR);\n\treg_val_DMACR = readl(msp->registers + MSP_DMACR);\n\twritel(reg_val_DMACR & ~TX_DMA_ENABLE, msp->registers + MSP_DMACR);\n\treg_val_IMSC = readl(msp->registers + MSP_IMSC);\n\twritel(reg_val_IMSC &\n\t\t\t~(TX_SERVICE_INT | TX_UNDERRUN_ERR_INT),\n\t\t\tmsp->registers + MSP_IMSC);\n\n\tmsp->dir_busy &= ~MSP_DIR_TX;\n}\n\nstatic int disable_msp(struct ux500_msp *msp, unsigned int dir)\n{\n\tu32 reg_val_GCR;\n\tunsigned int disable_tx, disable_rx;\n\n\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\tdisable_tx = dir & MSP_DIR_TX;\n\tdisable_rx = dir & MSP_DIR_TX;\n\tif (disable_tx && disable_rx) {\n\t\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\t\twritel(reg_val_GCR | LOOPBACK_MASK,\n\t\t\t\tmsp->registers + MSP_GCR);\n\n\t\t \n\t\tflush_fifo_tx(msp);\n\n\t\t \n\t\twritel((readl(msp->registers + MSP_GCR) &\n\t\t\t       (~TX_ENABLE)), msp->registers + MSP_GCR);\n\n\t\t \n\t\tflush_fifo_rx(msp);\n\n\t\t \n\t\twritel((readl(msp->registers + MSP_GCR) &\n\t\t\t\t(~(RX_ENABLE | LOOPBACK_MASK))),\n\t\t\t\tmsp->registers + MSP_GCR);\n\n\t\tdisable_msp_tx(msp);\n\t\tdisable_msp_rx(msp);\n\t} else if (disable_tx)\n\t\tdisable_msp_tx(msp);\n\telse if (disable_rx)\n\t\tdisable_msp_rx(msp);\n\n\treturn 0;\n}\n\nint ux500_msp_i2s_trigger(struct ux500_msp *msp, int cmd, int direction)\n{\n\tu32 reg_val_GCR, enable_bit;\n\n\tif (msp->msp_state == MSP_STATE_IDLE) {\n\t\tdev_err(msp->dev, \"%s: ERROR: MSP is not configured!\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tenable_bit = TX_ENABLE;\n\t\telse\n\t\t\tenable_bit = RX_ENABLE;\n\t\treg_val_GCR = readl(msp->registers + MSP_GCR);\n\t\twritel(reg_val_GCR | enable_bit, msp->registers + MSP_GCR);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tdisable_msp_tx(msp);\n\t\telse\n\t\t\tdisable_msp_rx(msp);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint ux500_msp_i2s_close(struct ux500_msp *msp, unsigned int dir)\n{\n\tint status = 0;\n\n\tdev_dbg(msp->dev, \"%s: Enter (dir = 0x%01x).\\n\", __func__, dir);\n\n\tstatus = disable_msp(msp, dir);\n\tif (msp->dir_busy == 0) {\n\t\t \n\t\tmsp->msp_state = MSP_STATE_IDLE;\n\t\twritel((readl(msp->registers + MSP_GCR) &\n\t\t\t       (~(FRAME_GEN_ENABLE | SRG_ENABLE))),\n\t\t\t      msp->registers + MSP_GCR);\n\n\t\twritel(0, msp->registers + MSP_GCR);\n\t\twritel(0, msp->registers + MSP_TCF);\n\t\twritel(0, msp->registers + MSP_RCF);\n\t\twritel(0, msp->registers + MSP_DMACR);\n\t\twritel(0, msp->registers + MSP_SRG);\n\t\twritel(0, msp->registers + MSP_MCR);\n\t\twritel(0, msp->registers + MSP_RCM);\n\t\twritel(0, msp->registers + MSP_RCV);\n\t\twritel(0, msp->registers + MSP_TCE0);\n\t\twritel(0, msp->registers + MSP_TCE1);\n\t\twritel(0, msp->registers + MSP_TCE2);\n\t\twritel(0, msp->registers + MSP_TCE3);\n\t\twritel(0, msp->registers + MSP_RCE0);\n\t\twritel(0, msp->registers + MSP_RCE1);\n\t\twritel(0, msp->registers + MSP_RCE2);\n\t\twritel(0, msp->registers + MSP_RCE3);\n\t}\n\n\treturn status;\n\n}\n\nint ux500_msp_i2s_init_msp(struct platform_device *pdev,\n\t\t\tstruct ux500_msp **msp_p)\n{\n\tstruct resource *res = NULL;\n\tstruct ux500_msp *msp;\n\n\t*msp_p = devm_kzalloc(&pdev->dev, sizeof(struct ux500_msp), GFP_KERNEL);\n\tmsp = *msp_p;\n\tif (!msp)\n\t\treturn -ENOMEM;\n\n\tmsp->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"%s: ERROR: Unable to get resource!\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsp->tx_rx_addr = res->start + MSP_DR;\n\tmsp->registers = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t      resource_size(res));\n\tif (msp->registers == NULL) {\n\t\tdev_err(&pdev->dev, \"%s: ERROR: ioremap failed!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsp->msp_state = MSP_STATE_IDLE;\n\tmsp->loopback_enable = 0;\n\n\treturn 0;\n}\n\nvoid ux500_msp_i2s_cleanup_msp(struct platform_device *pdev,\n\t\t\tstruct ux500_msp *msp)\n{\n\tdev_dbg(msp->dev, \"%s: Enter (id = %d).\\n\", __func__, msp->id);\n}\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}