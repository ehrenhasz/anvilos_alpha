{
  "module_name": "aio-compress.c",
  "hash_id": "ae464ecc1d36018ac9140154d5b7df6fe57fedc609188a1c778205845399489f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/uniphier/aio-compress.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/circ_buf.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#include \"aio.h\"\n\nstatic int uniphier_aio_compr_prepare(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream);\nstatic int uniphier_aio_compr_hw_free(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream);\n\nstatic int uniphier_aio_comprdma_new(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_compr *compr = rtd->compr;\n\tstruct device *dev = compr->card->dev;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[compr->direction];\n\tsize_t size = AUD_RING_SIZE;\n\tint dma_dir = DMA_FROM_DEVICE, ret;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(33));\n\tif (ret)\n\t\treturn ret;\n\n\tsub->compr_area = kzalloc(size, GFP_KERNEL);\n\tif (!sub->compr_area)\n\t\treturn -ENOMEM;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\tdma_dir = DMA_TO_DEVICE;\n\n\tsub->compr_addr = dma_map_single(dev, sub->compr_area, size, dma_dir);\n\tif (dma_mapping_error(dev, sub->compr_addr)) {\n\t\tkfree(sub->compr_area);\n\t\tsub->compr_area = NULL;\n\n\t\treturn -ENOMEM;\n\t}\n\n\tsub->compr_bytes = size;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_comprdma_free(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_compr *compr = rtd->compr;\n\tstruct device *dev = compr->card->dev;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[compr->direction];\n\tint dma_dir = DMA_FROM_DEVICE;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\tdma_dir = DMA_TO_DEVICE;\n\n\tdma_unmap_single(dev, sub->compr_addr, sub->compr_bytes, dma_dir);\n\tkfree(sub->compr_area);\n\tsub->compr_area = NULL;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_open(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tint ret;\n\n\tif (sub->cstream)\n\t\treturn -EBUSY;\n\n\tsub->cstream = cstream;\n\tsub->pass_through = 1;\n\tsub->use_mmap = false;\n\n\tret = uniphier_aio_comprdma_new(rtd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aio_init(sub);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_free(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tint ret;\n\n\tret = uniphier_aio_compr_hw_free(component, cstream);\n\tif (ret)\n\t\treturn ret;\n\tret = uniphier_aio_comprdma_free(rtd);\n\tif (ret)\n\t\treturn ret;\n\n\tsub->cstream = NULL;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_get_params(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t\t struct snd_codec *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\n\t*params = sub->cparams.codec;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_set_params(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t\t struct snd_compr_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tstruct device *dev = &aio->chip->pdev->dev;\n\n\tif (params->codec.id != SND_AUDIOCODEC_IEC61937) {\n\t\tdev_err(dev, \"Codec ID is not supported(%d)\\n\",\n\t\t\tparams->codec.id);\n\t\treturn -EINVAL;\n\t}\n\tif (params->codec.profile != SND_AUDIOPROFILE_IEC61937_SPDIF) {\n\t\tdev_err(dev, \"Codec profile is not supported(%d)\\n\",\n\t\t\tparams->codec.profile);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsub->iec_pc = IEC61937_PC_AAC;\n\n\tsub->cparams = *params;\n\tsub->setting = 1;\n\n\taio_port_reset(sub);\n\taio_src_reset(sub);\n\n\treturn uniphier_aio_compr_prepare(component, cstream);\n}\n\nstatic int uniphier_aio_compr_hw_free(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\n\tsub->setting = 0;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_prepare(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tint bytes = runtime->fragment_size;\n\tunsigned long flags;\n\tint ret;\n\n\tret = aiodma_ch_set_param(sub);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tret = aiodma_rb_set_buffer(sub, sub->compr_addr,\n\t\t\t\t   sub->compr_addr + sub->compr_bytes,\n\t\t\t\t   bytes);\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aio_port_set_param(sub, sub->pass_through, &sub->params);\n\tif (ret)\n\t\treturn ret;\n\tret = aio_oport_set_stream_type(sub, sub->iec_pc);\n\tif (ret)\n\t\treturn ret;\n\taio_port_set_enable(sub, 1);\n\n\tret = aio_if_set_param(sub, sub->pass_through);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_trigger(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream,\n\t\t\t\t      int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tstruct device *dev = &aio->chip->pdev->dev;\n\tint bytes = runtime->fragment_size, ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\taiodma_rb_sync(sub, sub->compr_addr, sub->compr_bytes, bytes);\n\t\taiodma_ch_set_enable(sub, 1);\n\t\tsub->running = 1;\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsub->running = 0;\n\t\taiodma_ch_set_enable(sub, 0);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown trigger(%d)\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\treturn ret;\n}\n\nstatic int uniphier_aio_compr_pointer(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *cstream,\n\t\t\t\t      struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tint bytes = runtime->fragment_size;\n\tunsigned long flags;\n\tu32 pos;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\n\taiodma_rb_sync(sub, sub->compr_addr, sub->compr_bytes, bytes);\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tpos = sub->rd_offs;\n\t\t \n\t\ttstamp->copied_total = sub->rd_total / 2;\n\t} else {\n\t\tpos = sub->wr_offs;\n\t\ttstamp->copied_total = sub->rd_total;\n\t}\n\ttstamp->byte_offset = pos;\n\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aio_compr_send_to_hw(struct uniphier_aio_sub *sub,\n\t\t\t\tchar __user *buf, size_t dstsize)\n{\n\tu32 __user *srcbuf = (u32 __user *)buf;\n\tu32 *dstbuf = (u32 *)(sub->compr_area + sub->wr_offs);\n\tint src = 0, dst = 0, ret;\n\tu32 frm, frm_a, frm_b;\n\n\twhile (dstsize > 0) {\n\t\tret = get_user(frm, srcbuf + src);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsrc++;\n\n\t\tfrm_a = frm & 0xffff;\n\t\tfrm_b = (frm >> 16) & 0xffff;\n\n\t\tif (frm == IEC61937_HEADER_SIGN) {\n\t\t\tfrm_a |= 0x01000000;\n\n\t\t\t \n\t\t\tsub->iec_header = true;\n\t\t} else {\n\t\t\tu16 pc = be16_to_cpu((__be16)frm_a);\n\n\t\t\tif (sub->iec_header && sub->iec_pc != pc) {\n\t\t\t\t \n\t\t\t\tsub->iec_pc = pc;\n\t\t\t\tret = aio_oport_set_stream_type(sub, pc);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsub->iec_header = false;\n\t\t}\n\t\tdstbuf[dst++] = frm_a;\n\t\tdstbuf[dst++] = frm_b;\n\n\t\tdstsize -= sizeof(u32) * 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_compr_copy(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream,\n\t\t\t\t   char __user *buf, size_t count)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct device *carddev = rtd->compr->card->dev;\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[cstream->direction];\n\tsize_t cnt = min_t(size_t, count, aio_rb_space_to_end(sub) / 2);\n\tint bytes = runtime->fragment_size;\n\tunsigned long flags;\n\tsize_t s;\n\tint ret;\n\n\tif (cnt < sizeof(u32))\n\t\treturn 0;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tdma_addr_t dmapos = sub->compr_addr + sub->wr_offs;\n\n\t\t \n\t\ts = cnt * 2;\n\n\t\tdma_sync_single_for_cpu(carddev, dmapos, s, DMA_TO_DEVICE);\n\t\tret = aio_compr_send_to_hw(sub, buf, s);\n\t\tdma_sync_single_for_device(carddev, dmapos, s, DMA_TO_DEVICE);\n\t} else {\n\t\tdma_addr_t dmapos = sub->compr_addr + sub->rd_offs;\n\n\t\ts = cnt;\n\n\t\tdma_sync_single_for_cpu(carddev, dmapos, s, DMA_FROM_DEVICE);\n\t\tret = copy_to_user(buf, sub->compr_area + sub->rd_offs, s);\n\t\tdma_sync_single_for_device(carddev, dmapos, s, DMA_FROM_DEVICE);\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\n\tsub->threshold = 2 * bytes;\n\taiodma_rb_set_threshold(sub, sub->compr_bytes, 2 * bytes);\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tsub->wr_offs += s;\n\t\tif (sub->wr_offs >= sub->compr_bytes)\n\t\t\tsub->wr_offs -= sub->compr_bytes;\n\t} else {\n\t\tsub->rd_offs += s;\n\t\tif (sub->rd_offs >= sub->compr_bytes)\n\t\t\tsub->rd_offs -= sub->compr_bytes;\n\t}\n\taiodma_rb_sync(sub, sub->compr_addr, sub->compr_bytes, bytes);\n\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\treturn cnt;\n}\n\nstatic int uniphier_aio_compr_get_caps(struct snd_soc_component *component,\n\t\t\t\t       struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_compr_caps *caps)\n{\n\tcaps->num_codecs = 1;\n\tcaps->min_fragment_size = AUD_MIN_FRAGMENT_SIZE;\n\tcaps->max_fragment_size = AUD_MAX_FRAGMENT_SIZE;\n\tcaps->min_fragments = AUD_MIN_FRAGMENT;\n\tcaps->max_fragments = AUD_MAX_FRAGMENT;\n\tcaps->codecs[0] = SND_AUDIOCODEC_IEC61937;\n\n\treturn 0;\n}\n\nstatic const struct snd_compr_codec_caps caps_iec = {\n\t.num_descriptors = 1,\n\t.descriptor[0].max_ch = 8,\n\t.descriptor[0].num_sample_rates = 0,\n\t.descriptor[0].num_bitrates = 0,\n\t.descriptor[0].profiles = SND_AUDIOPROFILE_IEC61937_SPDIF,\n\t.descriptor[0].modes = SND_AUDIOMODE_IEC_AC3 |\n\t\t\t\tSND_AUDIOMODE_IEC_MPEG1 |\n\t\t\t\tSND_AUDIOMODE_IEC_MP3 |\n\t\t\t\tSND_AUDIOMODE_IEC_DTS,\n\t.descriptor[0].formats = 0,\n};\n\nstatic int uniphier_aio_compr_get_codec_caps(struct snd_soc_component *component,\n\t\t\t\t\t     struct snd_compr_stream *stream,\n\t\t\t\t\t     struct snd_compr_codec_caps *codec)\n{\n\tif (codec->codec == SND_AUDIOCODEC_IEC61937)\n\t\t*codec = caps_iec;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nconst struct snd_compress_ops uniphier_aio_compress_ops = {\n\t.open           = uniphier_aio_compr_open,\n\t.free           = uniphier_aio_compr_free,\n\t.get_params     = uniphier_aio_compr_get_params,\n\t.set_params     = uniphier_aio_compr_set_params,\n\t.trigger        = uniphier_aio_compr_trigger,\n\t.pointer        = uniphier_aio_compr_pointer,\n\t.copy           = uniphier_aio_compr_copy,\n\t.get_caps       = uniphier_aio_compr_get_caps,\n\t.get_codec_caps = uniphier_aio_compr_get_codec_caps,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}