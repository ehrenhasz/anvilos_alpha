{
  "module_name": "aio-cpu.c",
  "hash_id": "948001c5f5e26e16d5d0480ec0203db30766813fd1aace08ec272e678fbf647c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/uniphier/aio-cpu.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"aio.h\"\n\nstatic bool is_valid_pll(struct uniphier_aio_chip *chip, int pll_id)\n{\n\tstruct device *dev = &chip->pdev->dev;\n\n\tif (pll_id < 0 || chip->num_plls <= pll_id) {\n\t\tdev_err(dev, \"PLL(%d) is not supported\\n\", pll_id);\n\t\treturn false;\n\t}\n\n\treturn chip->plls[pll_id].enable;\n}\n\n \nstatic struct uniphier_aio_sub *find_volume(struct uniphier_aio_chip *chip,\n\t\t\t\t\t    int oport_hw)\n{\n\tint i;\n\n\tfor (i = 0; i < chip->num_aios; i++) {\n\t\tstruct uniphier_aio_sub *sub = &chip->aios[i].sub[0];\n\n\t\tif (!sub->swm)\n\t\t\tcontinue;\n\n\t\tif (sub->swm->oport.hw == oport_hw)\n\t\t\treturn sub;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool match_spec(const struct uniphier_aio_spec *spec,\n\t\t       const char *name, int dir)\n{\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    spec->swm.dir != PORT_DIR_OUTPUT) {\n\t\treturn false;\n\t}\n\n\tif (dir == SNDRV_PCM_STREAM_CAPTURE &&\n\t    spec->swm.dir != PORT_DIR_INPUT) {\n\t\treturn false;\n\t}\n\n\tif (spec->name && strcmp(spec->name, name) == 0)\n\t\treturn true;\n\n\tif (spec->gname && strcmp(spec->gname, name) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic const struct uniphier_aio_spec *find_spec(struct uniphier_aio *aio,\n\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t int direction)\n{\n\tconst struct uniphier_aio_chip_spec *chip_spec = aio->chip->chip_spec;\n\tint i;\n\n\tfor (i = 0; i < chip_spec->num_specs; i++) {\n\t\tconst struct uniphier_aio_spec *spec = &chip_spec->specs[i];\n\n\t\tif (match_spec(spec, name, direction))\n\t\t\treturn spec;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int find_divider(struct uniphier_aio *aio, int pll_id, unsigned int freq)\n{\n\tstruct uniphier_aio_pll *pll;\n\tstatic const int mul[] = { 1, 1, 1, 2, };\n\tstatic const int div[] = { 2, 3, 1, 3, };\n\tint i;\n\n\tif (!is_valid_pll(aio->chip, pll_id))\n\t\treturn -EINVAL;\n\n\tpll = &aio->chip->plls[pll_id];\n\tfor (i = 0; i < ARRAY_SIZE(mul); i++)\n\t\tif (pll->freq * mul[i] / div[i] == freq)\n\t\t\treturn i;\n\n\treturn -ENOTSUPP;\n}\n\nstatic int uniphier_aio_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t   unsigned int freq, int dir)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct device *dev = &aio->chip->pdev->dev;\n\tbool pll_auto = false;\n\tint pll_id, div_id;\n\n\tswitch (clk_id) {\n\tcase AUD_CLK_IO:\n\t\treturn -ENOTSUPP;\n\tcase AUD_CLK_A1:\n\t\tpll_id = AUD_PLL_A1;\n\t\tbreak;\n\tcase AUD_CLK_F1:\n\t\tpll_id = AUD_PLL_F1;\n\t\tbreak;\n\tcase AUD_CLK_A2:\n\t\tpll_id = AUD_PLL_A2;\n\t\tbreak;\n\tcase AUD_CLK_F2:\n\t\tpll_id = AUD_PLL_F2;\n\t\tbreak;\n\tcase AUD_CLK_A:\n\t\tpll_id = AUD_PLL_A1;\n\t\tpll_auto = true;\n\t\tbreak;\n\tcase AUD_CLK_F:\n\t\tpll_id = AUD_PLL_F1;\n\t\tpll_auto = true;\n\t\tbreak;\n\tcase AUD_CLK_APLL:\n\t\tpll_id = AUD_PLL_APLL;\n\t\tbreak;\n\tcase AUD_CLK_RX0:\n\t\tpll_id = AUD_PLL_RX0;\n\t\tbreak;\n\tcase AUD_CLK_USB0:\n\t\tpll_id = AUD_PLL_USB0;\n\t\tbreak;\n\tcase AUD_CLK_HSC0:\n\t\tpll_id = AUD_PLL_HSC0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Sysclk(%d) is not supported\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pll_auto) {\n\t\tfor (pll_id = 0; pll_id < aio->chip->num_plls; pll_id++) {\n\t\t\tdiv_id = find_divider(aio, pll_id, freq);\n\t\t\tif (div_id >= 0) {\n\t\t\t\taio->plldiv = div_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pll_id == aio->chip->num_plls) {\n\t\t\tdev_err(dev, \"Sysclk frequency is not supported(%d)\\n\",\n\t\t\t\tfreq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (dir == SND_SOC_CLOCK_OUT)\n\t\taio->pll_out = pll_id;\n\telse\n\t\taio->pll_in = pll_id;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_set_pll(struct snd_soc_dai *dai, int pll_id,\n\t\t\t\tint source, unsigned int freq_in,\n\t\t\t\tunsigned int freq_out)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tint ret;\n\n\tif (!is_valid_pll(aio->chip, pll_id))\n\t\treturn -EINVAL;\n\n\tret = aio_chip_set_pll(aio->chip, pll_id, freq_out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct device *dev = &aio->chip->pdev->dev;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taio->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Format is not supported(%d)\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\n\tsub->substream = substream;\n\tsub->pass_through = 0;\n\tsub->use_mmap = true;\n\n\treturn aio_init(sub);\n}\n\nstatic void uniphier_aio_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\n\tsub->substream = NULL;\n}\n\nstatic int uniphier_aio_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\tstruct device *dev = &aio->chip->pdev->dev;\n\tint freq, ret;\n\n\tswitch (params_rate(params)) {\n\tcase 48000:\n\tcase 32000:\n\tcase 24000:\n\t\tfreq = 12288000;\n\t\tbreak;\n\tcase 44100:\n\tcase 22050:\n\t\tfreq = 11289600;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Rate is not supported(%d)\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\tret = snd_soc_dai_set_sysclk(dai, AUD_CLK_A,\n\t\t\t\t     freq, SND_SOC_CLOCK_OUT);\n\tif (ret)\n\t\treturn ret;\n\n\tsub->params = *params;\n\tsub->setting = 1;\n\n\taio_port_reset(sub);\n\taio_port_set_volume(sub, sub->vol);\n\taio_src_reset(sub);\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\n\tsub->setting = 0;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_prepare(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\tint ret;\n\n\tret = aio_port_set_param(sub, sub->pass_through, &sub->params);\n\tif (ret)\n\t\treturn ret;\n\tret = aio_src_set_param(sub, &sub->params);\n\tif (ret)\n\t\treturn ret;\n\taio_port_set_enable(sub, 1);\n\n\tret = aio_if_set_param(sub, sub->pass_through);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sub->swm->type == PORT_TYPE_CONV) {\n\t\tret = aio_srcif_set_param(sub);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = aio_srcch_set_param(sub);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\taio_srcch_set_enable(sub, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(aio->sub); i++) {\n\t\tstruct uniphier_aio_sub *sub = &aio->sub[i];\n\t\tconst struct uniphier_aio_spec *spec;\n\n\t\tspec = find_spec(aio, dai->name, i);\n\t\tif (!spec)\n\t\t\tcontinue;\n\n\t\tsub->swm = &spec->swm;\n\t\tsub->spec = spec;\n\n\t\tsub->vol = AUD_VOL_INIT;\n\t}\n\n\taio_iecout_set_enable(aio->chip, true);\n\taio_chip_init(aio->chip);\n\taio->chip->active = 1;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_dai_remove(struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\n\taio->chip->active = 0;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_ld11_probe(struct snd_soc_dai *dai)\n{\n\tint ret;\n\n\tret = uniphier_aio_dai_probe(dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_A1, 0, 0, 36864000);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_F1, 0, 0, 36864000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_A2, 0, 0, 33868800);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_F2, 0, 0, 33868800);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_pxs2_probe(struct snd_soc_dai *dai)\n{\n\tint ret;\n\n\tret = uniphier_aio_dai_probe(dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_A1, 0, 0, 36864000);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_F1, 0, 0, 36864000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_A2, 0, 0, 33868800);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_soc_dai_set_pll(dai, AUD_PLL_F2, 0, 0, 33868800);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nconst struct snd_soc_dai_ops uniphier_aio_i2s_ld11_ops = {\n\t.probe\t\t= uniphier_aio_ld11_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.set_fmt\t= uniphier_aio_set_fmt,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_i2s_ld11_ops);\n\nconst struct snd_soc_dai_ops uniphier_aio_spdif_ld11_ops = {\n\t.probe\t\t= uniphier_aio_ld11_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_spdif_ld11_ops);\n\nconst struct snd_soc_dai_ops uniphier_aio_spdif_ld11_ops2 = {\n\t.probe\t\t= uniphier_aio_ld11_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n\t.compress_new\t= snd_soc_new_compress,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_spdif_ld11_ops2);\n\nconst struct snd_soc_dai_ops uniphier_aio_i2s_pxs2_ops = {\n\t.probe\t\t= uniphier_aio_pxs2_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.set_fmt\t= uniphier_aio_set_fmt,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_i2s_pxs2_ops);\n\nconst struct snd_soc_dai_ops uniphier_aio_spdif_pxs2_ops = {\n\t.probe\t\t= uniphier_aio_pxs2_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_spdif_pxs2_ops);\n\nconst struct snd_soc_dai_ops uniphier_aio_spdif_pxs2_ops2 = {\n\t.probe\t\t= uniphier_aio_pxs2_probe,\n\t.remove\t\t= uniphier_aio_dai_remove,\n\t.set_sysclk\t= uniphier_aio_set_sysclk,\n\t.set_pll\t= uniphier_aio_set_pll,\n\t.startup\t= uniphier_aio_startup,\n\t.shutdown\t= uniphier_aio_shutdown,\n\t.hw_params\t= uniphier_aio_hw_params,\n\t.hw_free\t= uniphier_aio_hw_free,\n\t.prepare\t= uniphier_aio_prepare,\n\t.compress_new\t= snd_soc_new_compress,\n};\nEXPORT_SYMBOL_GPL(uniphier_aio_spdif_pxs2_ops2);\n\nstatic void uniphier_aio_dai_suspend(struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\n\tif (!snd_soc_dai_active(dai))\n\t\treturn;\n\n\taio->chip->num_wup_aios--;\n\tif (!aio->chip->num_wup_aios) {\n\t\treset_control_assert(aio->chip->rst);\n\t\tclk_disable_unprepare(aio->chip->clk);\n\t}\n}\n\nstatic int uniphier_aio_suspend(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\n\tfor_each_component_dais(component, dai)\n\t\tuniphier_aio_dai_suspend(dai);\n\treturn 0;\n}\n\nstatic int uniphier_aio_dai_resume(struct snd_soc_dai *dai)\n{\n\tstruct uniphier_aio *aio = uniphier_priv(dai);\n\tint ret, i;\n\n\tif (!snd_soc_dai_active(dai))\n\t\treturn 0;\n\n\tif (!aio->chip->active)\n\t\treturn 0;\n\n\tif (!aio->chip->num_wup_aios) {\n\t\tret = clk_prepare_enable(aio->chip->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = reset_control_deassert(aio->chip->rst);\n\t\tif (ret)\n\t\t\tgoto err_out_clock;\n\t}\n\n\taio_iecout_set_enable(aio->chip, true);\n\taio_chip_init(aio->chip);\n\n\tfor (i = 0; i < ARRAY_SIZE(aio->sub); i++) {\n\t\tstruct uniphier_aio_sub *sub = &aio->sub[i];\n\n\t\tif (!sub->spec || !sub->substream)\n\t\t\tcontinue;\n\n\t\tret = aio_init(sub);\n\t\tif (ret)\n\t\t\tgoto err_out_reset;\n\n\t\tif (!sub->setting)\n\t\t\tcontinue;\n\n\t\taio_port_reset(sub);\n\t\taio_src_reset(sub);\n\t}\n\taio->chip->num_wup_aios++;\n\n\treturn 0;\n\nerr_out_reset:\n\tif (!aio->chip->num_wup_aios)\n\t\treset_control_assert(aio->chip->rst);\nerr_out_clock:\n\tif (!aio->chip->num_wup_aios)\n\t\tclk_disable_unprepare(aio->chip->clk);\n\n\treturn ret;\n}\n\nstatic int uniphier_aio_resume(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\tint ret = 0;\n\n\tfor_each_component_dais(component, dai)\n\t\tret |= uniphier_aio_dai_resume(dai);\n\treturn ret;\n}\n\nstatic int uniphier_aio_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = AUD_VOL_MAX;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct uniphier_aio_chip *chip = snd_soc_component_get_drvdata(comp);\n\tstruct uniphier_aio_sub *sub;\n\tint oport_hw = kcontrol->private_value;\n\n\tsub = find_volume(chip, oport_hw);\n\tif (!sub)\n\t\treturn 0;\n\n\tucontrol->value.integer.value[0] = sub->vol;\n\n\treturn 0;\n}\n\nstatic int uniphier_aio_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct uniphier_aio_chip *chip = snd_soc_component_get_drvdata(comp);\n\tstruct uniphier_aio_sub *sub;\n\tint oport_hw = kcontrol->private_value;\n\n\tsub = find_volume(chip, oport_hw);\n\tif (!sub)\n\t\treturn 0;\n\n\tif (sub->vol == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\tsub->vol = ucontrol->value.integer.value[0];\n\n\taio_port_set_volume(sub, sub->vol);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new uniphier_aio_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"HPCMOUT1 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_HPCMOUT1,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"PCMOUT1 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_PCMOUT1,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"PCMOUT2 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_PCMOUT2,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"PCMOUT3 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_PCMOUT3,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"HIECOUT1 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_HIECOUT1,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.name = \"IECOUT1 Volume\",\n\t\t.info = uniphier_aio_vol_info,\n\t\t.get = uniphier_aio_vol_get,\n\t\t.put = uniphier_aio_vol_put,\n\t\t.private_value = AUD_HW_IECOUT1,\n\t},\n};\n\nstatic const struct snd_soc_component_driver uniphier_aio_component = {\n\t.name = \"uniphier-aio\",\n\t.controls = uniphier_aio_controls,\n\t.num_controls = ARRAY_SIZE(uniphier_aio_controls),\n\t.suspend = uniphier_aio_suspend,\n\t.resume  = uniphier_aio_resume,\n};\n\nint uniphier_aio_probe(struct platform_device *pdev)\n{\n\tstruct uniphier_aio_chip *chip;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i, j;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->chip_spec = of_device_get_match_data(dev);\n\tif (!chip->chip_spec)\n\t\treturn -EINVAL;\n\n\tchip->regmap_sg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t  \"socionext,syscon\");\n\tif (IS_ERR(chip->regmap_sg)) {\n\t\tif (PTR_ERR(chip->regmap_sg) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tchip->regmap_sg = NULL;\n\t}\n\n\tchip->clk = devm_clk_get(dev, \"aio\");\n\tif (IS_ERR(chip->clk))\n\t\treturn PTR_ERR(chip->clk);\n\n\tchip->rst = devm_reset_control_get_shared(dev, \"aio\");\n\tif (IS_ERR(chip->rst))\n\t\treturn PTR_ERR(chip->rst);\n\n\tchip->num_aios = chip->chip_spec->num_dais;\n\tchip->num_wup_aios = chip->num_aios;\n\tchip->aios = devm_kcalloc(dev,\n\t\t\t\t  chip->num_aios, sizeof(struct uniphier_aio),\n\t\t\t\t  GFP_KERNEL);\n\tif (!chip->aios)\n\t\treturn -ENOMEM;\n\n\tchip->num_plls = chip->chip_spec->num_plls;\n\tchip->plls = devm_kcalloc(dev,\n\t\t\t\t  chip->num_plls,\n\t\t\t\t  sizeof(struct uniphier_aio_pll),\n\t\t\t\t  GFP_KERNEL);\n\tif (!chip->plls)\n\t\treturn -ENOMEM;\n\tmemcpy(chip->plls, chip->chip_spec->plls,\n\t       sizeof(struct uniphier_aio_pll) * chip->num_plls);\n\n\tfor (i = 0; i < chip->num_aios; i++) {\n\t\tstruct uniphier_aio *aio = &chip->aios[i];\n\n\t\taio->chip = chip;\n\t\taio->fmt = SND_SOC_DAIFMT_I2S;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(aio->sub); j++) {\n\t\t\tstruct uniphier_aio_sub *sub = &aio->sub[j];\n\n\t\t\tsub->aio = aio;\n\t\t\tspin_lock_init(&sub->lock);\n\t\t}\n\t}\n\n\tchip->pdev = pdev;\n\tplatform_set_drvdata(pdev, chip);\n\n\tret = clk_prepare_enable(chip->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(chip->rst);\n\tif (ret)\n\t\tgoto err_out_clock;\n\n\tret = devm_snd_soc_register_component(dev, &uniphier_aio_component,\n\t\t\t\t\t      chip->chip_spec->dais,\n\t\t\t\t\t      chip->chip_spec->num_dais);\n\tif (ret) {\n\t\tdev_err(dev, \"Register component failed.\\n\");\n\t\tgoto err_out_reset;\n\t}\n\n\tret = uniphier_aiodma_soc_register_platform(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Register platform failed.\\n\");\n\t\tgoto err_out_reset;\n\t}\n\n\treturn 0;\n\nerr_out_reset:\n\treset_control_assert(chip->rst);\n\nerr_out_clock:\n\tclk_disable_unprepare(chip->clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(uniphier_aio_probe);\n\nint uniphier_aio_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_aio_chip *chip = platform_get_drvdata(pdev);\n\n\treset_control_assert(chip->rst);\n\tclk_disable_unprepare(chip->clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uniphier_aio_remove);\n\nMODULE_AUTHOR(\"Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier AIO CPU DAI driver.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}