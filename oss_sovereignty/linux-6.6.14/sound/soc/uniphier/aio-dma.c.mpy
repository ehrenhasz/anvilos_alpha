{
  "module_name": "aio-dma.c",
  "hash_id": "8f0e3c7f046c82fc0c922e675f5fc5c3e4115e73ac7fef2585c3e92ac89cab30",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/uniphier/aio-dma.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#include \"aio.h\"\n\nstatic struct snd_pcm_hardware uniphier_aiodma_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED,\n\t.period_bytes_min = 256,\n\t.period_bytes_max = 4096,\n\t.periods_min      = 4,\n\t.periods_max      = 1024,\n\t.buffer_bytes_max = 128 * 1024,\n};\n\nstatic void aiodma_pcm_irq(struct uniphier_aio_sub *sub)\n{\n\tstruct snd_pcm_runtime *runtime = sub->substream->runtime;\n\tint bytes = runtime->period_size *\n\t\truntime->channels * samples_to_bytes(runtime, 1);\n\tint ret;\n\n\tspin_lock(&sub->lock);\n\tret = aiodma_rb_set_threshold(sub, runtime->dma_bytes,\n\t\t\t\t      sub->threshold + bytes);\n\tif (!ret)\n\t\tsub->threshold += bytes;\n\n\taiodma_rb_sync(sub, runtime->dma_addr, runtime->dma_bytes, bytes);\n\taiodma_rb_clear_irq(sub);\n\tspin_unlock(&sub->lock);\n\n\tsnd_pcm_period_elapsed(sub->substream);\n}\n\nstatic void aiodma_compr_irq(struct uniphier_aio_sub *sub)\n{\n\tstruct snd_compr_runtime *runtime = sub->cstream->runtime;\n\tint bytes = runtime->fragment_size;\n\tint ret;\n\n\tspin_lock(&sub->lock);\n\tret = aiodma_rb_set_threshold(sub, sub->compr_bytes,\n\t\t\t\t      sub->threshold + bytes);\n\tif (!ret)\n\t\tsub->threshold += bytes;\n\n\taiodma_rb_sync(sub, sub->compr_addr, sub->compr_bytes, bytes);\n\taiodma_rb_clear_irq(sub);\n\tspin_unlock(&sub->lock);\n\n\tsnd_compr_fragment_elapsed(sub->cstream);\n}\n\nstatic irqreturn_t aiodma_irq(int irq, void *p)\n{\n\tstruct platform_device *pdev = p;\n\tstruct uniphier_aio_chip *chip = platform_get_drvdata(pdev);\n\tirqreturn_t ret = IRQ_NONE;\n\tint i, j;\n\n\tfor (i = 0; i < chip->num_aios; i++) {\n\t\tstruct uniphier_aio *aio = &chip->aios[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(aio->sub); j++) {\n\t\t\tstruct uniphier_aio_sub *sub = &aio->sub[j];\n\n\t\t\t \n\t\t\tif (!sub->running || !aiodma_rb_is_irq(sub))\n\t\t\t\tcontinue;\n\n\t\t\tif (sub->substream)\n\t\t\t\taiodma_pcm_irq(sub);\n\t\t\tif (sub->cstream)\n\t\t\t\taiodma_compr_irq(sub);\n\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int uniphier_aiodma_open(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_soc_set_runtime_hwparams(substream, &uniphier_aiodma_hw);\n\n\treturn snd_pcm_hw_constraint_step(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256);\n}\n\nstatic int uniphier_aiodma_prepare(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\tint bytes = runtime->period_size *\n\t\truntime->channels * samples_to_bytes(runtime, 1);\n\tunsigned long flags;\n\tint ret;\n\n\tret = aiodma_ch_set_param(sub);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tret = aiodma_rb_set_buffer(sub, runtime->dma_addr,\n\t\t\t\t   runtime->dma_addr + runtime->dma_bytes,\n\t\t\t\t   bytes);\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_aiodma_trigger(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\tstruct device *dev = &aio->chip->pdev->dev;\n\tint bytes = runtime->period_size *\n\t\truntime->channels * samples_to_bytes(runtime, 1);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\taiodma_rb_sync(sub, runtime->dma_addr, runtime->dma_bytes,\n\t\t\t       bytes);\n\t\taiodma_ch_set_enable(sub, 1);\n\t\tsub->running = 1;\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsub->running = 0;\n\t\taiodma_ch_set_enable(sub, 0);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown trigger(%d) ignored\\n\", cmd);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t uniphier_aiodma_pointer(\n\t\t\t\t\tstruct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct uniphier_aio *aio = uniphier_priv(asoc_rtd_to_cpu(rtd, 0));\n\tstruct uniphier_aio_sub *sub = &aio->sub[substream->stream];\n\tint bytes = runtime->period_size *\n\t\truntime->channels * samples_to_bytes(runtime, 1);\n\tunsigned long flags;\n\tsnd_pcm_uframes_t pos;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\taiodma_rb_sync(sub, runtime->dma_addr, runtime->dma_bytes, bytes);\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\tpos = bytes_to_frames(runtime, sub->rd_offs);\n\telse\n\t\tpos = bytes_to_frames(runtime, sub->wr_offs);\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\treturn pos;\n}\n\nstatic int uniphier_aiodma_mmap(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       substream->runtime->dma_addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start, vma->vm_page_prot);\n}\n\nstatic int uniphier_aiodma_new(struct snd_soc_component *component,\n\t\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *dev = rtd->card->snd_card->dev;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(33));\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\tSNDRV_DMA_TYPE_DEV, dev,\n\t\tuniphier_aiodma_hw.buffer_bytes_max,\n\t\tuniphier_aiodma_hw.buffer_bytes_max);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver uniphier_soc_platform = {\n\t.open\t\t= uniphier_aiodma_open,\n\t.prepare\t= uniphier_aiodma_prepare,\n\t.trigger\t= uniphier_aiodma_trigger,\n\t.pointer\t= uniphier_aiodma_pointer,\n\t.mmap\t\t= uniphier_aiodma_mmap,\n\t.pcm_construct\t= uniphier_aiodma_new,\n\t.compress_ops\t= &uniphier_aio_compress_ops,\n};\n\nstatic const struct regmap_config aiodma_regmap_config = {\n\t.reg_bits      = 32,\n\t.reg_stride    = 4,\n\t.val_bits      = 32,\n\t.max_register  = 0x7fffc,\n\t.cache_type    = REGCACHE_NONE,\n};\n\n \nint uniphier_aiodma_soc_register_platform(struct platform_device *pdev)\n{\n\tstruct uniphier_aio_chip *chip = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *preg;\n\tint irq, ret;\n\n\tpreg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(preg))\n\t\treturn PTR_ERR(preg);\n\n\tchip->regmap = devm_regmap_init_mmio(dev, preg,\n\t\t\t\t\t     &aiodma_regmap_config);\n\tif (IS_ERR(chip->regmap))\n\t\treturn PTR_ERR(chip->regmap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, aiodma_irq,\n\t\t\t       IRQF_SHARED, dev_name(dev), pdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(dev, &uniphier_soc_platform,\n\t\t\t\t\t       NULL, 0);\n}\nEXPORT_SYMBOL_GPL(uniphier_aiodma_soc_register_platform);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}