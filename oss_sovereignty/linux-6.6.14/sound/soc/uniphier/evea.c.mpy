{
  "module_name": "evea.c",
  "hash_id": "e994fa81eb06094a7dbda6573aac27337a2ad27fae0d9e3055eca12c3431a787",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/uniphier/evea.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#define DRV_NAME        \"evea\"\n#define EVEA_RATES      SNDRV_PCM_RATE_48000\n#define EVEA_FORMATS    SNDRV_PCM_FMTBIT_S32_LE\n\n#define AADCPOW(n)                           (0x0078 + 0x04 * (n))\n#define   AADCPOW_AADC_POWD                   BIT(0)\n#define ALINSW1                              0x0088\n#define   ALINSW1_SEL1_SHIFT                  3\n#define AHPOUTPOW                            0x0098\n#define   AHPOUTPOW_HP_ON                     BIT(4)\n#define ALINEPOW                             0x009c\n#define   ALINEPOW_LIN2_POWD                  BIT(3)\n#define   ALINEPOW_LIN1_POWD                  BIT(4)\n#define ALO1OUTPOW                           0x00a8\n#define   ALO1OUTPOW_LO1_ON                   BIT(4)\n#define ALO2OUTPOW                           0x00ac\n#define   ALO2OUTPOW_ADAC2_MUTE               BIT(0)\n#define   ALO2OUTPOW_LO2_ON                   BIT(4)\n#define AANAPOW                              0x00b8\n#define   AANAPOW_A_POWD                      BIT(4)\n#define ADACSEQ1(n)                          (0x0144 + 0x40 * (n))\n#define   ADACSEQ1_MMUTE                      BIT(1)\n#define ADACSEQ2(n)                          (0x0160 + 0x40 * (n))\n#define   ADACSEQ2_ADACIN_FIX                 BIT(0)\n#define ADAC1ODC                             0x0200\n#define   ADAC1ODC_HP_DIS_RES_MASK            GENMASK(2, 1)\n#define   ADAC1ODC_HP_DIS_RES_OFF             (0x0 << 1)\n#define   ADAC1ODC_HP_DIS_RES_ON              (0x3 << 1)\n#define   ADAC1ODC_ADAC_RAMPCLT_MASK          GENMASK(8, 7)\n#define   ADAC1ODC_ADAC_RAMPCLT_NORMAL        (0x0 << 7)\n#define   ADAC1ODC_ADAC_RAMPCLT_REDUCE        (0x1 << 7)\n\nstruct evea_priv {\n\tstruct clk *clk, *clk_exiv;\n\tstruct reset_control *rst, *rst_exiv, *rst_adamv;\n\tstruct regmap *regmap;\n\n\tint switch_lin;\n\tint switch_lo;\n\tint switch_hp;\n};\n\nstatic const char * const linsw1_sel1_text[] = {\n\t\"LIN1\", \"LIN2\", \"LIN3\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(linsw1_sel1_enum,\n\tALINSW1, ALINSW1_SEL1_SHIFT,\n\tlinsw1_sel1_text);\n\nstatic const struct snd_kcontrol_new linesw1_mux[] = {\n\tSOC_DAPM_ENUM(\"Line In 1 Source\", linsw1_sel1_enum),\n};\n\nstatic const struct snd_soc_dapm_widget evea_widgets[] = {\n\tSND_SOC_DAPM_ADC(\"ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"Line In 1 Mux\", SND_SOC_NOPM, 0, 0, linesw1_mux),\n\tSND_SOC_DAPM_INPUT(\"LIN1_LP\"),\n\tSND_SOC_DAPM_INPUT(\"LIN1_RP\"),\n\tSND_SOC_DAPM_INPUT(\"LIN2_LP\"),\n\tSND_SOC_DAPM_INPUT(\"LIN2_RP\"),\n\tSND_SOC_DAPM_INPUT(\"LIN3_LP\"),\n\tSND_SOC_DAPM_INPUT(\"LIN3_RP\"),\n\n\tSND_SOC_DAPM_DAC(\"DAC HP\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC LO1\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC LO2\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"HP1_L\"),\n\tSND_SOC_DAPM_OUTPUT(\"HP1_R\"),\n\tSND_SOC_DAPM_OUTPUT(\"LO2_L\"),\n\tSND_SOC_DAPM_OUTPUT(\"LO2_R\"),\n};\n\nstatic const struct snd_soc_dapm_route evea_routes[] = {\n\t{ \"Line In 1\", NULL, \"ADC\" },\n\t{ \"ADC\", NULL, \"Line In 1 Mux\" },\n\t{ \"Line In 1 Mux\", \"LIN1\", \"LIN1_LP\" },\n\t{ \"Line In 1 Mux\", \"LIN1\", \"LIN1_RP\" },\n\t{ \"Line In 1 Mux\", \"LIN2\", \"LIN2_LP\" },\n\t{ \"Line In 1 Mux\", \"LIN2\", \"LIN2_RP\" },\n\t{ \"Line In 1 Mux\", \"LIN3\", \"LIN3_LP\" },\n\t{ \"Line In 1 Mux\", \"LIN3\", \"LIN3_RP\" },\n\n\t{ \"DAC HP\", NULL, \"Headphone 1\" },\n\t{ \"DAC LO1\", NULL, \"Line Out 1\" },\n\t{ \"DAC LO2\", NULL, \"Line Out 2\" },\n\t{ \"HP1_L\", NULL, \"DAC HP\" },\n\t{ \"HP1_R\", NULL, \"DAC HP\" },\n\t{ \"LO2_L\", NULL, \"DAC LO2\" },\n\t{ \"LO2_R\", NULL, \"DAC LO2\" },\n};\n\nstatic void evea_set_power_state_on(struct evea_priv *evea)\n{\n\tstruct regmap *map = evea->regmap;\n\n\tregmap_update_bits(map, AANAPOW, AANAPOW_A_POWD,\n\t\t\t   AANAPOW_A_POWD);\n\n\tregmap_update_bits(map, ADAC1ODC, ADAC1ODC_HP_DIS_RES_MASK,\n\t\t\t   ADAC1ODC_HP_DIS_RES_ON);\n\n\tregmap_update_bits(map, ADAC1ODC, ADAC1ODC_ADAC_RAMPCLT_MASK,\n\t\t\t   ADAC1ODC_ADAC_RAMPCLT_REDUCE);\n\n\tregmap_update_bits(map, ADACSEQ2(0), ADACSEQ2_ADACIN_FIX, 0);\n\tregmap_update_bits(map, ADACSEQ2(1), ADACSEQ2_ADACIN_FIX, 0);\n\tregmap_update_bits(map, ADACSEQ2(2), ADACSEQ2_ADACIN_FIX, 0);\n}\n\nstatic void evea_set_power_state_off(struct evea_priv *evea)\n{\n\tstruct regmap *map = evea->regmap;\n\n\tregmap_update_bits(map, ADAC1ODC, ADAC1ODC_HP_DIS_RES_MASK,\n\t\t\t   ADAC1ODC_HP_DIS_RES_ON);\n\n\tregmap_update_bits(map, ADACSEQ1(0), ADACSEQ1_MMUTE,\n\t\t\t   ADACSEQ1_MMUTE);\n\tregmap_update_bits(map, ADACSEQ1(1), ADACSEQ1_MMUTE,\n\t\t\t   ADACSEQ1_MMUTE);\n\tregmap_update_bits(map, ADACSEQ1(2), ADACSEQ1_MMUTE,\n\t\t\t   ADACSEQ1_MMUTE);\n\n\tregmap_update_bits(map, ALO1OUTPOW, ALO1OUTPOW_LO1_ON, 0);\n\tregmap_update_bits(map, ALO2OUTPOW, ALO2OUTPOW_LO2_ON, 0);\n\tregmap_update_bits(map, AHPOUTPOW, AHPOUTPOW_HP_ON, 0);\n}\n\nstatic int evea_update_switch_lin(struct evea_priv *evea)\n{\n\tstruct regmap *map = evea->regmap;\n\n\tif (evea->switch_lin) {\n\t\tregmap_update_bits(map, ALINEPOW,\n\t\t\t\t   ALINEPOW_LIN2_POWD | ALINEPOW_LIN1_POWD,\n\t\t\t\t   ALINEPOW_LIN2_POWD | ALINEPOW_LIN1_POWD);\n\n\t\tregmap_update_bits(map, AADCPOW(0), AADCPOW_AADC_POWD,\n\t\t\t\t   AADCPOW_AADC_POWD);\n\t\tregmap_update_bits(map, AADCPOW(1), AADCPOW_AADC_POWD,\n\t\t\t\t   AADCPOW_AADC_POWD);\n\t} else {\n\t\tregmap_update_bits(map, AADCPOW(0), AADCPOW_AADC_POWD, 0);\n\t\tregmap_update_bits(map, AADCPOW(1), AADCPOW_AADC_POWD, 0);\n\n\t\tregmap_update_bits(map, ALINEPOW,\n\t\t\t\t   ALINEPOW_LIN2_POWD | ALINEPOW_LIN1_POWD, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int evea_update_switch_lo(struct evea_priv *evea)\n{\n\tstruct regmap *map = evea->regmap;\n\n\tif (evea->switch_lo) {\n\t\tregmap_update_bits(map, ADACSEQ1(0), ADACSEQ1_MMUTE, 0);\n\t\tregmap_update_bits(map, ADACSEQ1(2), ADACSEQ1_MMUTE, 0);\n\n\t\tregmap_update_bits(map, ALO1OUTPOW, ALO1OUTPOW_LO1_ON,\n\t\t\t\t   ALO1OUTPOW_LO1_ON);\n\t\tregmap_update_bits(map, ALO2OUTPOW,\n\t\t\t\t   ALO2OUTPOW_ADAC2_MUTE | ALO2OUTPOW_LO2_ON,\n\t\t\t\t   ALO2OUTPOW_ADAC2_MUTE | ALO2OUTPOW_LO2_ON);\n\t} else {\n\t\tregmap_update_bits(map, ADACSEQ1(0), ADACSEQ1_MMUTE,\n\t\t\t\t   ADACSEQ1_MMUTE);\n\t\tregmap_update_bits(map, ADACSEQ1(2), ADACSEQ1_MMUTE,\n\t\t\t\t   ADACSEQ1_MMUTE);\n\n\t\tregmap_update_bits(map, ALO1OUTPOW, ALO1OUTPOW_LO1_ON, 0);\n\t\tregmap_update_bits(map, ALO2OUTPOW,\n\t\t\t\t   ALO2OUTPOW_ADAC2_MUTE | ALO2OUTPOW_LO2_ON,\n\t\t\t\t   0);\n\t}\n\n\treturn 0;\n}\n\nstatic int evea_update_switch_hp(struct evea_priv *evea)\n{\n\tstruct regmap *map = evea->regmap;\n\n\tif (evea->switch_hp) {\n\t\tregmap_update_bits(map, ADACSEQ1(1), ADACSEQ1_MMUTE, 0);\n\n\t\tregmap_update_bits(map, AHPOUTPOW, AHPOUTPOW_HP_ON,\n\t\t\t\t   AHPOUTPOW_HP_ON);\n\n\t\tregmap_update_bits(map, ADAC1ODC, ADAC1ODC_HP_DIS_RES_MASK,\n\t\t\t\t   ADAC1ODC_HP_DIS_RES_OFF);\n\t} else {\n\t\tregmap_update_bits(map, ADAC1ODC, ADAC1ODC_HP_DIS_RES_MASK,\n\t\t\t\t   ADAC1ODC_HP_DIS_RES_ON);\n\n\t\tregmap_update_bits(map, ADACSEQ1(1), ADACSEQ1_MMUTE,\n\t\t\t\t   ADACSEQ1_MMUTE);\n\n\t\tregmap_update_bits(map, AHPOUTPOW, AHPOUTPOW_HP_ON, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void evea_update_switch_all(struct evea_priv *evea)\n{\n\tevea_update_switch_lin(evea);\n\tevea_update_switch_lo(evea);\n\tevea_update_switch_hp(evea);\n}\n\nstatic int evea_get_switch_lin(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = evea->switch_lin;\n\n\treturn 0;\n}\n\nstatic int evea_set_switch_lin(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tif (evea->switch_lin == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tevea->switch_lin = ucontrol->value.integer.value[0];\n\n\treturn evea_update_switch_lin(evea);\n}\n\nstatic int evea_get_switch_lo(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = evea->switch_lo;\n\n\treturn 0;\n}\n\nstatic int evea_set_switch_lo(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tif (evea->switch_lo == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tevea->switch_lo = ucontrol->value.integer.value[0];\n\n\treturn evea_update_switch_lo(evea);\n}\n\nstatic int evea_get_switch_hp(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = evea->switch_hp;\n\n\treturn 0;\n}\n\nstatic int evea_set_switch_hp(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tif (evea->switch_hp == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tevea->switch_hp = ucontrol->value.integer.value[0];\n\n\treturn evea_update_switch_hp(evea);\n}\n\nstatic const struct snd_kcontrol_new evea_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"Line Capture Switch\", 0,\n\t\t\t    evea_get_switch_lin, evea_set_switch_lin),\n\tSOC_SINGLE_BOOL_EXT(\"Line Playback Switch\", 0,\n\t\t\t    evea_get_switch_lo, evea_set_switch_lo),\n\tSOC_SINGLE_BOOL_EXT(\"Headphone Playback Switch\", 0,\n\t\t\t    evea_get_switch_hp, evea_set_switch_hp),\n};\n\nstatic int evea_codec_probe(struct snd_soc_component *component)\n{\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tevea->switch_lin = 1;\n\tevea->switch_lo = 1;\n\tevea->switch_hp = 1;\n\n\tevea_set_power_state_on(evea);\n\tevea_update_switch_all(evea);\n\n\treturn 0;\n}\n\nstatic int evea_codec_suspend(struct snd_soc_component *component)\n{\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\n\tevea_set_power_state_off(evea);\n\n\treset_control_assert(evea->rst_adamv);\n\treset_control_assert(evea->rst_exiv);\n\treset_control_assert(evea->rst);\n\n\tclk_disable_unprepare(evea->clk_exiv);\n\tclk_disable_unprepare(evea->clk);\n\n\treturn 0;\n}\n\nstatic int evea_codec_resume(struct snd_soc_component *component)\n{\n\tstruct evea_priv *evea = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = clk_prepare_enable(evea->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(evea->clk_exiv);\n\tif (ret)\n\t\tgoto err_out_clock;\n\n\tret = reset_control_deassert(evea->rst);\n\tif (ret)\n\t\tgoto err_out_clock_exiv;\n\n\tret = reset_control_deassert(evea->rst_exiv);\n\tif (ret)\n\t\tgoto err_out_reset;\n\n\tret = reset_control_deassert(evea->rst_adamv);\n\tif (ret)\n\t\tgoto err_out_reset_exiv;\n\n\tevea_set_power_state_on(evea);\n\tevea_update_switch_all(evea);\n\n\treturn 0;\n\nerr_out_reset_exiv:\n\treset_control_assert(evea->rst_exiv);\n\nerr_out_reset:\n\treset_control_assert(evea->rst);\n\nerr_out_clock_exiv:\n\tclk_disable_unprepare(evea->clk_exiv);\n\nerr_out_clock:\n\tclk_disable_unprepare(evea->clk);\n\n\treturn ret;\n}\n\nstatic struct snd_soc_component_driver soc_codec_evea = {\n\t.probe\t\t\t= evea_codec_probe,\n\t.suspend\t\t= evea_codec_suspend,\n\t.resume\t\t\t= evea_codec_resume,\n\t.dapm_widgets\t\t= evea_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(evea_widgets),\n\t.dapm_routes\t\t= evea_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(evea_routes),\n\t.controls\t\t= evea_controls,\n\t.num_controls\t\t= ARRAY_SIZE(evea_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver soc_dai_evea[] = {\n\t{\n\t\t.name     = DRV_NAME \"-line1\",\n\t\t.playback = {\n\t\t\t.stream_name  = \"Line Out 1\",\n\t\t\t.formats      = EVEA_FORMATS,\n\t\t\t.rates        = EVEA_RATES,\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name  = \"Line In 1\",\n\t\t\t.formats      = EVEA_FORMATS,\n\t\t\t.rates        = EVEA_RATES,\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t},\n\t},\n\t{\n\t\t.name     = DRV_NAME \"-hp1\",\n\t\t.playback = {\n\t\t\t.stream_name  = \"Headphone 1\",\n\t\t\t.formats      = EVEA_FORMATS,\n\t\t\t.rates        = EVEA_RATES,\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t},\n\t},\n\t{\n\t\t.name     = DRV_NAME \"-lo2\",\n\t\t.playback = {\n\t\t\t.stream_name  = \"Line Out 2\",\n\t\t\t.formats      = EVEA_FORMATS,\n\t\t\t.rates        = EVEA_RATES,\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t},\n\t},\n};\n\nstatic const struct regmap_config evea_regmap_config = {\n\t.reg_bits      = 32,\n\t.reg_stride    = 4,\n\t.val_bits      = 32,\n\t.max_register  = 0xffc,\n\t.cache_type    = REGCACHE_NONE,\n};\n\nstatic int evea_probe(struct platform_device *pdev)\n{\n\tstruct evea_priv *evea;\n\tvoid __iomem *preg;\n\tint ret;\n\n\tevea = devm_kzalloc(&pdev->dev, sizeof(struct evea_priv), GFP_KERNEL);\n\tif (!evea)\n\t\treturn -ENOMEM;\n\n\tevea->clk = devm_clk_get(&pdev->dev, \"evea\");\n\tif (IS_ERR(evea->clk))\n\t\treturn PTR_ERR(evea->clk);\n\n\tevea->clk_exiv = devm_clk_get(&pdev->dev, \"exiv\");\n\tif (IS_ERR(evea->clk_exiv))\n\t\treturn PTR_ERR(evea->clk_exiv);\n\n\tevea->rst = devm_reset_control_get_shared(&pdev->dev, \"evea\");\n\tif (IS_ERR(evea->rst))\n\t\treturn PTR_ERR(evea->rst);\n\n\tevea->rst_exiv = devm_reset_control_get_shared(&pdev->dev, \"exiv\");\n\tif (IS_ERR(evea->rst_exiv))\n\t\treturn PTR_ERR(evea->rst_exiv);\n\n\tpreg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(preg))\n\t\treturn PTR_ERR(preg);\n\n\tevea->regmap = devm_regmap_init_mmio(&pdev->dev, preg,\n\t\t\t\t\t     &evea_regmap_config);\n\tif (IS_ERR(evea->regmap))\n\t\treturn PTR_ERR(evea->regmap);\n\n\tret = clk_prepare_enable(evea->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(evea->clk_exiv);\n\tif (ret)\n\t\tgoto err_out_clock;\n\n\tret = reset_control_deassert(evea->rst);\n\tif (ret)\n\t\tgoto err_out_clock_exiv;\n\n\tret = reset_control_deassert(evea->rst_exiv);\n\tif (ret)\n\t\tgoto err_out_reset;\n\n\t \n\tevea->rst_adamv = devm_reset_control_get_shared(&pdev->dev, \"adamv\");\n\tif (IS_ERR(evea->rst_adamv)) {\n\t\tret = PTR_ERR(evea->rst_adamv);\n\t\tgoto err_out_reset_exiv;\n\t}\n\n\tret = reset_control_deassert(evea->rst_adamv);\n\tif (ret)\n\t\tgoto err_out_reset_exiv;\n\n\tplatform_set_drvdata(pdev, evea);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_evea,\n\t\t\t\t     soc_dai_evea, ARRAY_SIZE(soc_dai_evea));\n\tif (ret)\n\t\tgoto err_out_reset_adamv;\n\n\treturn 0;\n\nerr_out_reset_adamv:\n\treset_control_assert(evea->rst_adamv);\n\nerr_out_reset_exiv:\n\treset_control_assert(evea->rst_exiv);\n\nerr_out_reset:\n\treset_control_assert(evea->rst);\n\nerr_out_clock_exiv:\n\tclk_disable_unprepare(evea->clk_exiv);\n\nerr_out_clock:\n\tclk_disable_unprepare(evea->clk);\n\n\treturn ret;\n}\n\nstatic void evea_remove(struct platform_device *pdev)\n{\n\tstruct evea_priv *evea = platform_get_drvdata(pdev);\n\n\treset_control_assert(evea->rst_adamv);\n\treset_control_assert(evea->rst_exiv);\n\treset_control_assert(evea->rst);\n\n\tclk_disable_unprepare(evea->clk_exiv);\n\tclk_disable_unprepare(evea->clk);\n}\n\nstatic const struct of_device_id evea_of_match[] __maybe_unused = {\n\t{ .compatible = \"socionext,uniphier-evea\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, evea_of_match);\n\nstatic struct platform_driver evea_codec_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(evea_of_match),\n\t},\n\t.probe  = evea_probe,\n\t.remove_new = evea_remove,\n};\nmodule_platform_driver(evea_codec_driver);\n\nMODULE_AUTHOR(\"Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier EVEA codec driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}