{
  "module_name": "aio-core.c",
  "hash_id": "dc57350b55eafee2ab5e4855a1ef0a7a645456ec3f09b86c05d8446ab44d001c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/uniphier/aio-core.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"aio.h\"\n#include \"aio-reg.h\"\n\nstatic u64 rb_cnt(u64 wr, u64 rd, u64 len)\n{\n\tif (rd <= wr)\n\t\treturn wr - rd;\n\telse\n\t\treturn len - (rd - wr);\n}\n\nstatic u64 rb_cnt_to_end(u64 wr, u64 rd, u64 len)\n{\n\tif (rd <= wr)\n\t\treturn wr - rd;\n\telse\n\t\treturn len - rd;\n}\n\nstatic u64 rb_space(u64 wr, u64 rd, u64 len)\n{\n\tif (rd <= wr)\n\t\treturn len - (wr - rd) - 8;\n\telse\n\t\treturn rd - wr - 8;\n}\n\nstatic u64 rb_space_to_end(u64 wr, u64 rd, u64 len)\n{\n\tif (rd > wr)\n\t\treturn rd - wr - 8;\n\telse if (rd > 0)\n\t\treturn len - wr;\n\telse\n\t\treturn len - wr - 8;\n}\n\nu64 aio_rb_cnt(struct uniphier_aio_sub *sub)\n{\n\treturn rb_cnt(sub->wr_offs, sub->rd_offs, sub->compr_bytes);\n}\n\nu64 aio_rbt_cnt_to_end(struct uniphier_aio_sub *sub)\n{\n\treturn rb_cnt_to_end(sub->wr_offs, sub->rd_offs, sub->compr_bytes);\n}\n\nu64 aio_rb_space(struct uniphier_aio_sub *sub)\n{\n\treturn rb_space(sub->wr_offs, sub->rd_offs, sub->compr_bytes);\n}\n\nu64 aio_rb_space_to_end(struct uniphier_aio_sub *sub)\n{\n\treturn rb_space_to_end(sub->wr_offs, sub->rd_offs, sub->compr_bytes);\n}\n\n \nvoid aio_iecout_set_enable(struct uniphier_aio_chip *chip, bool enable)\n{\n\tstruct regmap *r = chip->regmap_sg;\n\n\tif (!r)\n\t\treturn;\n\n\tregmap_write(r, SG_AOUTEN, (enable) ? ~0 : 0);\n}\n\n \nint aio_chip_set_pll(struct uniphier_aio_chip *chip, int pll_id,\n\t\t     unsigned int freq)\n{\n\tstruct device *dev = &chip->pdev->dev;\n\tstruct regmap *r = chip->regmap;\n\tint shift;\n\tu32 v;\n\n\t \n\tif (freq == 0)\n\t\treturn 0;\n\n\tswitch (pll_id) {\n\tcase AUD_PLL_A1:\n\t\tshift = 0;\n\t\tbreak;\n\tcase AUD_PLL_F1:\n\t\tshift = 1;\n\t\tbreak;\n\tcase AUD_PLL_A2:\n\t\tshift = 2;\n\t\tbreak;\n\tcase AUD_PLL_F2:\n\t\tshift = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"PLL(%d) not supported\\n\", pll_id);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 36864000:\n\t\tv = A2APLLCTR1_APLLX_36MHZ;\n\t\tbreak;\n\tcase 33868800:\n\t\tv = A2APLLCTR1_APLLX_33MHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"PLL frequency not supported(%d)\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\tchip->plls[pll_id].freq = freq;\n\n\tregmap_update_bits(r, A2APLLCTR1, A2APLLCTR1_APLLX_MASK << shift,\n\t\t\t   v << shift);\n\n\treturn 0;\n}\n\n \nvoid aio_chip_init(struct uniphier_aio_chip *chip)\n{\n\tstruct regmap *r = chip->regmap;\n\n\tregmap_update_bits(r, A2APLLCTR0,\n\t\t\t   A2APLLCTR0_APLLXPOW_MASK,\n\t\t\t   A2APLLCTR0_APLLXPOW_PWON);\n\n\tregmap_update_bits(r, A2EXMCLKSEL0,\n\t\t\t   A2EXMCLKSEL0_EXMCLK_MASK,\n\t\t\t   A2EXMCLKSEL0_EXMCLK_OUTPUT);\n\n\tregmap_update_bits(r, A2AIOINPUTSEL, A2AIOINPUTSEL_RXSEL_MASK,\n\t\t\t   A2AIOINPUTSEL_RXSEL_PCMI1_HDMIRX1 |\n\t\t\t   A2AIOINPUTSEL_RXSEL_PCMI2_SIF |\n\t\t\t   A2AIOINPUTSEL_RXSEL_PCMI3_EVEA |\n\t\t\t   A2AIOINPUTSEL_RXSEL_IECI1_HDMIRX1);\n\n\tif (chip->chip_spec->addr_ext)\n\t\tregmap_update_bits(r, CDA2D_TEST, CDA2D_TEST_DDR_MODE_MASK,\n\t\t\t\t   CDA2D_TEST_DDR_MODE_EXTON0);\n\telse\n\t\tregmap_update_bits(r, CDA2D_TEST, CDA2D_TEST_DDR_MODE_MASK,\n\t\t\t\t   CDA2D_TEST_DDR_MODE_EXTOFF1);\n}\n\n \nint aio_init(struct uniphier_aio_sub *sub)\n{\n\tstruct device *dev = &sub->aio->chip->pdev->dev;\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tregmap_write(r, A2RBNMAPCTR0(sub->swm->rb.hw),\n\t\t     MAPCTR0_EN | sub->swm->rb.map);\n\tregmap_write(r, A2CHNMAPCTR0(sub->swm->ch.hw),\n\t\t     MAPCTR0_EN | sub->swm->ch.map);\n\n\tswitch (sub->swm->type) {\n\tcase PORT_TYPE_I2S:\n\tcase PORT_TYPE_SPDIF:\n\tcase PORT_TYPE_EVE:\n\t\tif (sub->swm->dir == PORT_DIR_INPUT) {\n\t\t\tregmap_write(r, A2IIFNMAPCTR0(sub->swm->iif.hw),\n\t\t\t\t     MAPCTR0_EN | sub->swm->iif.map);\n\t\t\tregmap_write(r, A2IPORTNMAPCTR0(sub->swm->iport.hw),\n\t\t\t\t     MAPCTR0_EN | sub->swm->iport.map);\n\t\t} else {\n\t\t\tregmap_write(r, A2OIFNMAPCTR0(sub->swm->oif.hw),\n\t\t\t\t     MAPCTR0_EN | sub->swm->oif.map);\n\t\t\tregmap_write(r, A2OPORTNMAPCTR0(sub->swm->oport.hw),\n\t\t\t\t     MAPCTR0_EN | sub->swm->oport.map);\n\t\t}\n\t\tbreak;\n\tcase PORT_TYPE_CONV:\n\t\tregmap_write(r, A2OIFNMAPCTR0(sub->swm->oif.hw),\n\t\t\t     MAPCTR0_EN | sub->swm->oif.map);\n\t\tregmap_write(r, A2OPORTNMAPCTR0(sub->swm->oport.hw),\n\t\t\t     MAPCTR0_EN | sub->swm->oport.map);\n\t\tregmap_write(r, A2CHNMAPCTR0(sub->swm->och.hw),\n\t\t\t     MAPCTR0_EN | sub->swm->och.map);\n\t\tregmap_write(r, A2IIFNMAPCTR0(sub->swm->iif.hw),\n\t\t\t     MAPCTR0_EN | sub->swm->iif.map);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown port type %d.\\n\", sub->swm->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid aio_port_reset(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tregmap_write(r, AOUTRSTCTR0, BIT(sub->swm->oport.map));\n\t\tregmap_write(r, AOUTRSTCTR1, BIT(sub->swm->oport.map));\n\t} else {\n\t\tregmap_update_bits(r, IPORTMXRSTCTR(sub->swm->iport.map),\n\t\t\t\t   IPORTMXRSTCTR_RSTPI_MASK,\n\t\t\t\t   IPORTMXRSTCTR_RSTPI_RESET);\n\t\tregmap_update_bits(r, IPORTMXRSTCTR(sub->swm->iport.map),\n\t\t\t\t   IPORTMXRSTCTR_RSTPI_MASK,\n\t\t\t\t   IPORTMXRSTCTR_RSTPI_RELEASE);\n\t}\n}\n\n \nstatic int aio_port_set_ch(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tstatic const u32 slotsel_2ch[] = {\n\t\t0, 0, 0, 0, 0,\n\t};\n\tstatic const u32 slotsel_multi[] = {\n\t\tOPORTMXTYSLOTCTR_SLOTSEL_SLOT0,\n\t\tOPORTMXTYSLOTCTR_SLOTSEL_SLOT1,\n\t\tOPORTMXTYSLOTCTR_SLOTSEL_SLOT2,\n\t\tOPORTMXTYSLOTCTR_SLOTSEL_SLOT3,\n\t\tOPORTMXTYSLOTCTR_SLOTSEL_SLOT4,\n\t};\n\tu32 mode;\n\tconst u32 *slotsel;\n\tint i;\n\n\tswitch (params_channels(&sub->params)) {\n\tcase 8:\n\tcase 6:\n\t\tmode = OPORTMXTYSLOTCTR_MODE;\n\t\tslotsel = slotsel_multi;\n\t\tbreak;\n\tcase 2:\n\t\tmode = 0;\n\t\tslotsel = slotsel_2ch;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < AUD_MAX_SLOTSEL; i++) {\n\t\tregmap_update_bits(r, OPORTMXTYSLOTCTR(sub->swm->oport.map, i),\n\t\t\t\t   OPORTMXTYSLOTCTR_MODE, mode);\n\t\tregmap_update_bits(r, OPORTMXTYSLOTCTR(sub->swm->oport.map, i),\n\t\t\t\t   OPORTMXTYSLOTCTR_SLOTSEL_MASK, slotsel[i]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aio_port_set_rate(struct uniphier_aio_sub *sub, int rate)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tstruct device *dev = &sub->aio->chip->pdev->dev;\n\tu32 v;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tswitch (rate) {\n\t\tcase 8000:\n\t\t\tv = OPORTMXCTR1_FSSEL_8;\n\t\t\tbreak;\n\t\tcase 11025:\n\t\t\tv = OPORTMXCTR1_FSSEL_11_025;\n\t\t\tbreak;\n\t\tcase 12000:\n\t\t\tv = OPORTMXCTR1_FSSEL_12;\n\t\t\tbreak;\n\t\tcase 16000:\n\t\t\tv = OPORTMXCTR1_FSSEL_16;\n\t\t\tbreak;\n\t\tcase 22050:\n\t\t\tv = OPORTMXCTR1_FSSEL_22_05;\n\t\t\tbreak;\n\t\tcase 24000:\n\t\t\tv = OPORTMXCTR1_FSSEL_24;\n\t\t\tbreak;\n\t\tcase 32000:\n\t\t\tv = OPORTMXCTR1_FSSEL_32;\n\t\t\tbreak;\n\t\tcase 44100:\n\t\t\tv = OPORTMXCTR1_FSSEL_44_1;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tv = OPORTMXCTR1_FSSEL_48;\n\t\t\tbreak;\n\t\tcase 88200:\n\t\t\tv = OPORTMXCTR1_FSSEL_88_2;\n\t\t\tbreak;\n\t\tcase 96000:\n\t\t\tv = OPORTMXCTR1_FSSEL_96;\n\t\t\tbreak;\n\t\tcase 176400:\n\t\t\tv = OPORTMXCTR1_FSSEL_176_4;\n\t\t\tbreak;\n\t\tcase 192000:\n\t\t\tv = OPORTMXCTR1_FSSEL_192;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Rate not supported(%d)\\n\", rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(r, OPORTMXCTR1(sub->swm->oport.map),\n\t\t\t\t   OPORTMXCTR1_FSSEL_MASK, v);\n\t} else {\n\t\tswitch (rate) {\n\t\tcase 8000:\n\t\t\tv = IPORTMXCTR1_FSSEL_8;\n\t\t\tbreak;\n\t\tcase 11025:\n\t\t\tv = IPORTMXCTR1_FSSEL_11_025;\n\t\t\tbreak;\n\t\tcase 12000:\n\t\t\tv = IPORTMXCTR1_FSSEL_12;\n\t\t\tbreak;\n\t\tcase 16000:\n\t\t\tv = IPORTMXCTR1_FSSEL_16;\n\t\t\tbreak;\n\t\tcase 22050:\n\t\t\tv = IPORTMXCTR1_FSSEL_22_05;\n\t\t\tbreak;\n\t\tcase 24000:\n\t\t\tv = IPORTMXCTR1_FSSEL_24;\n\t\t\tbreak;\n\t\tcase 32000:\n\t\t\tv = IPORTMXCTR1_FSSEL_32;\n\t\t\tbreak;\n\t\tcase 44100:\n\t\t\tv = IPORTMXCTR1_FSSEL_44_1;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tv = IPORTMXCTR1_FSSEL_48;\n\t\t\tbreak;\n\t\tcase 88200:\n\t\t\tv = IPORTMXCTR1_FSSEL_88_2;\n\t\t\tbreak;\n\t\tcase 96000:\n\t\t\tv = IPORTMXCTR1_FSSEL_96;\n\t\t\tbreak;\n\t\tcase 176400:\n\t\t\tv = IPORTMXCTR1_FSSEL_176_4;\n\t\t\tbreak;\n\t\tcase 192000:\n\t\t\tv = IPORTMXCTR1_FSSEL_192;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Rate not supported(%d)\\n\", rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(r, IPORTMXCTR1(sub->swm->iport.map),\n\t\t\t\t   IPORTMXCTR1_FSSEL_MASK, v);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aio_port_set_fmt(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tstruct device *dev = &sub->aio->chip->pdev->dev;\n\tu32 v;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tswitch (sub->aio->fmt) {\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tv = OPORTMXCTR1_I2SLRSEL_LEFT;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tv = OPORTMXCTR1_I2SLRSEL_RIGHT;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tv = OPORTMXCTR1_I2SLRSEL_I2S;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Format is not supported(%d)\\n\",\n\t\t\t\tsub->aio->fmt);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tv |= OPORTMXCTR1_OUTBITSEL_24;\n\t\tregmap_update_bits(r, OPORTMXCTR1(sub->swm->oport.map),\n\t\t\t\t   OPORTMXCTR1_I2SLRSEL_MASK |\n\t\t\t\t   OPORTMXCTR1_OUTBITSEL_MASK, v);\n\t} else {\n\t\tswitch (sub->aio->fmt) {\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tv = IPORTMXCTR1_LRSEL_LEFT;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tv = IPORTMXCTR1_LRSEL_RIGHT;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tv = IPORTMXCTR1_LRSEL_I2S;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Format is not supported(%d)\\n\",\n\t\t\t\tsub->aio->fmt);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tv |= IPORTMXCTR1_OUTBITSEL_24 |\n\t\t\tIPORTMXCTR1_CHSEL_ALL;\n\t\tregmap_update_bits(r, IPORTMXCTR1(sub->swm->iport.map),\n\t\t\t\t   IPORTMXCTR1_LRSEL_MASK |\n\t\t\t\t   IPORTMXCTR1_OUTBITSEL_MASK |\n\t\t\t\t   IPORTMXCTR1_CHSEL_MASK, v);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aio_port_set_clk(struct uniphier_aio_sub *sub)\n{\n\tstruct uniphier_aio_chip *chip = sub->aio->chip;\n\tstruct device *dev = &sub->aio->chip->pdev->dev;\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tstatic const u32 v_pll[] = {\n\t\tOPORTMXCTR2_ACLKSEL_A1, OPORTMXCTR2_ACLKSEL_F1,\n\t\tOPORTMXCTR2_ACLKSEL_A2, OPORTMXCTR2_ACLKSEL_F2,\n\t\tOPORTMXCTR2_ACLKSEL_A2PLL,\n\t\tOPORTMXCTR2_ACLKSEL_RX1,\n\t};\n\tstatic const u32 v_div[] = {\n\t\tOPORTMXCTR2_DACCKSEL_1_2, OPORTMXCTR2_DACCKSEL_1_3,\n\t\tOPORTMXCTR2_DACCKSEL_1_1, OPORTMXCTR2_DACCKSEL_2_3,\n\t};\n\tu32 v;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tif (sub->swm->type == PORT_TYPE_I2S) {\n\t\t\tif (sub->aio->pll_out >= ARRAY_SIZE(v_pll)) {\n\t\t\t\tdev_err(dev, \"PLL(%d) is invalid\\n\",\n\t\t\t\t\tsub->aio->pll_out);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (sub->aio->plldiv >= ARRAY_SIZE(v_div)) {\n\t\t\t\tdev_err(dev, \"PLL divider(%d) is invalid\\n\",\n\t\t\t\t\tsub->aio->plldiv);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tv = v_pll[sub->aio->pll_out] |\n\t\t\t\tOPORTMXCTR2_MSSEL_MASTER |\n\t\t\t\tv_div[sub->aio->plldiv];\n\n\t\t\tswitch (chip->plls[sub->aio->pll_out].freq) {\n\t\t\tcase 0:\n\t\t\tcase 36864000:\n\t\t\tcase 33868800:\n\t\t\t\tv |= OPORTMXCTR2_EXTLSIFSSEL_36;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv |= OPORTMXCTR2_EXTLSIFSSEL_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (sub->swm->type == PORT_TYPE_EVE) {\n\t\t\tv = OPORTMXCTR2_ACLKSEL_A2PLL |\n\t\t\t\tOPORTMXCTR2_MSSEL_MASTER |\n\t\t\t\tOPORTMXCTR2_EXTLSIFSSEL_36 |\n\t\t\t\tOPORTMXCTR2_DACCKSEL_1_2;\n\t\t} else if (sub->swm->type == PORT_TYPE_SPDIF) {\n\t\t\tif (sub->aio->pll_out >= ARRAY_SIZE(v_pll)) {\n\t\t\t\tdev_err(dev, \"PLL(%d) is invalid\\n\",\n\t\t\t\t\tsub->aio->pll_out);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tv = v_pll[sub->aio->pll_out] |\n\t\t\t\tOPORTMXCTR2_MSSEL_MASTER |\n\t\t\t\tOPORTMXCTR2_DACCKSEL_1_2;\n\n\t\t\tswitch (chip->plls[sub->aio->pll_out].freq) {\n\t\t\tcase 0:\n\t\t\tcase 36864000:\n\t\t\tcase 33868800:\n\t\t\t\tv |= OPORTMXCTR2_EXTLSIFSSEL_36;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv |= OPORTMXCTR2_EXTLSIFSSEL_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tv = OPORTMXCTR2_ACLKSEL_A1 |\n\t\t\t\tOPORTMXCTR2_MSSEL_MASTER |\n\t\t\t\tOPORTMXCTR2_EXTLSIFSSEL_36 |\n\t\t\t\tOPORTMXCTR2_DACCKSEL_1_2;\n\t\t}\n\t\tregmap_write(r, OPORTMXCTR2(sub->swm->oport.map), v);\n\t} else {\n\t\tv = IPORTMXCTR2_ACLKSEL_A1 |\n\t\t\tIPORTMXCTR2_MSSEL_SLAVE |\n\t\t\tIPORTMXCTR2_EXTLSIFSSEL_36 |\n\t\t\tIPORTMXCTR2_DACCKSEL_1_2;\n\t\tregmap_write(r, IPORTMXCTR2(sub->swm->iport.map), v);\n\t}\n\n\treturn 0;\n}\n\n \nint aio_port_set_param(struct uniphier_aio_sub *sub, int pass_through,\n\t\t       const struct snd_pcm_hw_params *params)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tunsigned int rate;\n\tu32 v;\n\tint ret;\n\n\tif (!pass_through) {\n\t\tif (sub->swm->type == PORT_TYPE_EVE ||\n\t\t    sub->swm->type == PORT_TYPE_CONV) {\n\t\t\trate = 48000;\n\t\t} else {\n\t\t\trate = params_rate(params);\n\t\t}\n\n\t\tret = aio_port_set_ch(sub);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = aio_port_set_rate(sub, rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = aio_port_set_fmt(sub);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = aio_port_set_clk(sub);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tif (pass_through)\n\t\t\tv = OPORTMXCTR3_SRCSEL_STREAM |\n\t\t\t\tOPORTMXCTR3_VALID_STREAM;\n\t\telse\n\t\t\tv = OPORTMXCTR3_SRCSEL_PCM |\n\t\t\t\tOPORTMXCTR3_VALID_PCM;\n\n\t\tv |= OPORTMXCTR3_IECTHUR_IECOUT |\n\t\t\tOPORTMXCTR3_PMSEL_PAUSE |\n\t\t\tOPORTMXCTR3_PMSW_MUTE_OFF;\n\t\tregmap_write(r, OPORTMXCTR3(sub->swm->oport.map), v);\n\t} else {\n\t\tregmap_write(r, IPORTMXACLKSEL0EX(sub->swm->iport.map),\n\t\t\t     IPORTMXACLKSEL0EX_ACLKSEL0EX_INTERNAL);\n\t\tregmap_write(r, IPORTMXEXNOE(sub->swm->iport.map),\n\t\t\t     IPORTMXEXNOE_PCMINOE_INPUT);\n\t}\n\n\treturn 0;\n}\n\n \nvoid aio_port_set_enable(struct uniphier_aio_sub *sub, int enable)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tregmap_write(r, OPORTMXPATH(sub->swm->oport.map),\n\t\t\t     sub->swm->oif.map);\n\n\t\tregmap_update_bits(r, OPORTMXMASK(sub->swm->oport.map),\n\t\t\t\t   OPORTMXMASK_IUDXMSK_MASK |\n\t\t\t\t   OPORTMXMASK_IUXCKMSK_MASK |\n\t\t\t\t   OPORTMXMASK_DXMSK_MASK |\n\t\t\t\t   OPORTMXMASK_XCKMSK_MASK,\n\t\t\t\t   OPORTMXMASK_IUDXMSK_OFF |\n\t\t\t\t   OPORTMXMASK_IUXCKMSK_OFF |\n\t\t\t\t   OPORTMXMASK_DXMSK_OFF |\n\t\t\t\t   OPORTMXMASK_XCKMSK_OFF);\n\n\t\tif (enable)\n\t\t\tregmap_write(r, AOUTENCTR0, BIT(sub->swm->oport.map));\n\t\telse\n\t\t\tregmap_write(r, AOUTENCTR1, BIT(sub->swm->oport.map));\n\t} else {\n\t\tregmap_update_bits(r, IPORTMXMASK(sub->swm->iport.map),\n\t\t\t\t   IPORTMXMASK_IUXCKMSK_MASK |\n\t\t\t\t   IPORTMXMASK_XCKMSK_MASK,\n\t\t\t\t   IPORTMXMASK_IUXCKMSK_OFF |\n\t\t\t\t   IPORTMXMASK_XCKMSK_OFF);\n\n\t\tif (enable)\n\t\t\tregmap_update_bits(r,\n\t\t\t\t\t   IPORTMXCTR2(sub->swm->iport.map),\n\t\t\t\t\t   IPORTMXCTR2_REQEN_MASK,\n\t\t\t\t\t   IPORTMXCTR2_REQEN_ENABLE);\n\t\telse\n\t\t\tregmap_update_bits(r,\n\t\t\t\t\t   IPORTMXCTR2(sub->swm->iport.map),\n\t\t\t\t\t   IPORTMXCTR2_REQEN_MASK,\n\t\t\t\t\t   IPORTMXCTR2_REQEN_DISABLE);\n\t}\n}\n\n \nint aio_port_get_volume(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 v;\n\n\tregmap_read(r, OPORTMXTYVOLGAINSTATUS(sub->swm->oport.map, 0), &v);\n\n\treturn FIELD_GET(OPORTMXTYVOLGAINSTATUS_CUR_MASK, v);\n}\n\n \nvoid aio_port_set_volume(struct uniphier_aio_sub *sub, int vol)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tint oport_map = sub->swm->oport.map;\n\tint cur, diff, slope = 0, fs;\n\n\tif (sub->swm->dir == PORT_DIR_INPUT)\n\t\treturn;\n\n\tcur = aio_port_get_volume(sub);\n\tdiff = abs(vol - cur);\n\tfs = params_rate(&sub->params);\n\tif (fs)\n\t\tslope = diff / AUD_VOL_FADE_TIME * 1000 / fs;\n\tslope = max(1, slope);\n\n\tregmap_update_bits(r, OPORTMXTYVOLPARA1(oport_map, 0),\n\t\t\t   OPORTMXTYVOLPARA1_SLOPEU_MASK, slope << 16);\n\tregmap_update_bits(r, OPORTMXTYVOLPARA2(oport_map, 0),\n\t\t\t   OPORTMXTYVOLPARA2_TARGET_MASK, vol);\n\n\tif (cur < vol)\n\t\tregmap_update_bits(r, OPORTMXTYVOLPARA2(oport_map, 0),\n\t\t\t\t   OPORTMXTYVOLPARA2_FADE_MASK,\n\t\t\t\t   OPORTMXTYVOLPARA2_FADE_FADEIN);\n\telse\n\t\tregmap_update_bits(r, OPORTMXTYVOLPARA2(oport_map, 0),\n\t\t\t\t   OPORTMXTYVOLPARA2_FADE_MASK,\n\t\t\t\t   OPORTMXTYVOLPARA2_FADE_FADEOUT);\n\n\tregmap_write(r, AOUTFADECTR0, BIT(oport_map));\n}\n\n \nint aio_if_set_param(struct uniphier_aio_sub *sub, int pass_through)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 memfmt, v;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tif (pass_through) {\n\t\t\tv = PBOUTMXCTR0_ENDIAN_0123 |\n\t\t\t\tPBOUTMXCTR0_MEMFMT_STREAM;\n\t\t} else {\n\t\t\tswitch (params_channels(&sub->params)) {\n\t\t\tcase 2:\n\t\t\t\tmemfmt = PBOUTMXCTR0_MEMFMT_2CH;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tmemfmt = PBOUTMXCTR0_MEMFMT_6CH;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tmemfmt = PBOUTMXCTR0_MEMFMT_8CH;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tv = PBOUTMXCTR0_ENDIAN_3210 | memfmt;\n\t\t}\n\n\t\tregmap_write(r, PBOUTMXCTR0(sub->swm->oif.map), v);\n\t\tregmap_write(r, PBOUTMXCTR1(sub->swm->oif.map), 0);\n\t} else {\n\t\tregmap_write(r, PBINMXCTR(sub->swm->iif.map),\n\t\t\t     PBINMXCTR_NCONNECT_CONNECT |\n\t\t\t     PBINMXCTR_INOUTSEL_IN |\n\t\t\t     (sub->swm->iport.map << PBINMXCTR_PBINSEL_SHIFT) |\n\t\t\t     PBINMXCTR_ENDIAN_3210 |\n\t\t\t     PBINMXCTR_MEMFMT_D0);\n\t}\n\n\treturn 0;\n}\n\n \nint aio_oport_set_stream_type(struct uniphier_aio_sub *sub,\n\t\t\t      enum IEC61937_PC pc)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 repet = 0, pause = OPORTMXPAUDAT_PAUSEPC_CMN;\n\n\tswitch (pc) {\n\tcase IEC61937_PC_AC3:\n\t\trepet = OPORTMXREPET_STRLENGTH_AC3 |\n\t\t\tOPORTMXREPET_PMLENGTH_AC3;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_AC3;\n\t\tbreak;\n\tcase IEC61937_PC_MPA:\n\t\trepet = OPORTMXREPET_STRLENGTH_MPA |\n\t\t\tOPORTMXREPET_PMLENGTH_MPA;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_MPA;\n\t\tbreak;\n\tcase IEC61937_PC_MP3:\n\t\trepet = OPORTMXREPET_STRLENGTH_MP3 |\n\t\t\tOPORTMXREPET_PMLENGTH_MP3;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_MP3;\n\t\tbreak;\n\tcase IEC61937_PC_DTS1:\n\t\trepet = OPORTMXREPET_STRLENGTH_DTS1 |\n\t\t\tOPORTMXREPET_PMLENGTH_DTS1;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_DTS1;\n\t\tbreak;\n\tcase IEC61937_PC_DTS2:\n\t\trepet = OPORTMXREPET_STRLENGTH_DTS2 |\n\t\t\tOPORTMXREPET_PMLENGTH_DTS2;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_DTS2;\n\t\tbreak;\n\tcase IEC61937_PC_DTS3:\n\t\trepet = OPORTMXREPET_STRLENGTH_DTS3 |\n\t\t\tOPORTMXREPET_PMLENGTH_DTS3;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_DTS3;\n\t\tbreak;\n\tcase IEC61937_PC_AAC:\n\t\trepet = OPORTMXREPET_STRLENGTH_AAC |\n\t\t\tOPORTMXREPET_PMLENGTH_AAC;\n\t\tpause |= OPORTMXPAUDAT_PAUSEPD_AAC;\n\t\tbreak;\n\tcase IEC61937_PC_PAUSE:\n\t\t \n\t\tbreak;\n\t}\n\n\tregmap_write(r, OPORTMXREPET(sub->swm->oport.map), repet);\n\tregmap_write(r, OPORTMXPAUDAT(sub->swm->oport.map), pause);\n\n\treturn 0;\n}\n\n \nvoid aio_src_reset(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (sub->swm->dir != PORT_DIR_OUTPUT)\n\t\treturn;\n\n\tregmap_write(r, AOUTSRCRSTCTR0, BIT(sub->swm->oport.map));\n\tregmap_write(r, AOUTSRCRSTCTR1, BIT(sub->swm->oport.map));\n}\n\n \nint aio_src_set_param(struct uniphier_aio_sub *sub,\n\t\t      const struct snd_pcm_hw_params *params)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 v;\n\n\tif (sub->swm->dir != PORT_DIR_OUTPUT)\n\t\treturn 0;\n\n\tregmap_write(r, OPORTMXSRC1CTR(sub->swm->oport.map),\n\t\t     OPORTMXSRC1CTR_THMODE_SRC |\n\t\t     OPORTMXSRC1CTR_SRCPATH_CALC |\n\t\t     OPORTMXSRC1CTR_SYNC_ASYNC |\n\t\t     OPORTMXSRC1CTR_FSIIPSEL_INNER |\n\t\t     OPORTMXSRC1CTR_FSISEL_ACLK);\n\n\tswitch (params_rate(params)) {\n\tdefault:\n\tcase 48000:\n\t\tv = OPORTMXRATE_I_ACLKSEL_APLLA1 |\n\t\t\tOPORTMXRATE_I_MCKSEL_36 |\n\t\t\tOPORTMXRATE_I_FSSEL_48;\n\t\tbreak;\n\tcase 44100:\n\t\tv = OPORTMXRATE_I_ACLKSEL_APLLA2 |\n\t\t\tOPORTMXRATE_I_MCKSEL_33 |\n\t\t\tOPORTMXRATE_I_FSSEL_44_1;\n\t\tbreak;\n\tcase 32000:\n\t\tv = OPORTMXRATE_I_ACLKSEL_APLLA1 |\n\t\t\tOPORTMXRATE_I_MCKSEL_36 |\n\t\t\tOPORTMXRATE_I_FSSEL_32;\n\t\tbreak;\n\t}\n\n\tregmap_write(r, OPORTMXRATE_I(sub->swm->oport.map),\n\t\t     v | OPORTMXRATE_I_ACLKSRC_APLL |\n\t\t     OPORTMXRATE_I_LRCKSTP_STOP);\n\tregmap_update_bits(r, OPORTMXRATE_I(sub->swm->oport.map),\n\t\t\t   OPORTMXRATE_I_LRCKSTP_MASK,\n\t\t\t   OPORTMXRATE_I_LRCKSTP_START);\n\n\treturn 0;\n}\n\nint aio_srcif_set_param(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tregmap_write(r, PBINMXCTR(sub->swm->iif.map),\n\t\t     PBINMXCTR_NCONNECT_CONNECT |\n\t\t     PBINMXCTR_INOUTSEL_OUT |\n\t\t     (sub->swm->oport.map << PBINMXCTR_PBINSEL_SHIFT) |\n\t\t     PBINMXCTR_ENDIAN_3210 |\n\t\t     PBINMXCTR_MEMFMT_D0);\n\n\treturn 0;\n}\n\nint aio_srcch_set_param(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tregmap_write(r, CDA2D_CHMXCTRL1(sub->swm->och.map),\n\t\t     CDA2D_CHMXCTRL1_INDSIZE_INFINITE);\n\n\tregmap_write(r, CDA2D_CHMXSRCAMODE(sub->swm->och.map),\n\t\t     CDA2D_CHMXAMODE_ENDIAN_3210 |\n\t\t     CDA2D_CHMXAMODE_AUPDT_FIX |\n\t\t     CDA2D_CHMXAMODE_TYPE_NORMAL);\n\n\tregmap_write(r, CDA2D_CHMXDSTAMODE(sub->swm->och.map),\n\t\t     CDA2D_CHMXAMODE_ENDIAN_3210 |\n\t\t     CDA2D_CHMXAMODE_AUPDT_INC |\n\t\t     CDA2D_CHMXAMODE_TYPE_RING |\n\t\t     (sub->swm->och.map << CDA2D_CHMXAMODE_RSSEL_SHIFT));\n\n\treturn 0;\n}\n\nvoid aio_srcch_set_enable(struct uniphier_aio_sub *sub, int enable)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 v;\n\n\tif (enable)\n\t\tv = CDA2D_STRT0_STOP_START;\n\telse\n\t\tv = CDA2D_STRT0_STOP_STOP;\n\n\tregmap_write(r, CDA2D_STRT0,\n\t\t     v | BIT(sub->swm->och.map));\n}\n\nint aiodma_ch_set_param(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 v;\n\n\tregmap_write(r, CDA2D_CHMXCTRL1(sub->swm->ch.map),\n\t\t     CDA2D_CHMXCTRL1_INDSIZE_INFINITE);\n\n\tv = CDA2D_CHMXAMODE_ENDIAN_3210 |\n\t\tCDA2D_CHMXAMODE_AUPDT_INC |\n\t\tCDA2D_CHMXAMODE_TYPE_NORMAL |\n\t\t(sub->swm->rb.map << CDA2D_CHMXAMODE_RSSEL_SHIFT);\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\tregmap_write(r, CDA2D_CHMXSRCAMODE(sub->swm->ch.map), v);\n\telse\n\t\tregmap_write(r, CDA2D_CHMXDSTAMODE(sub->swm->ch.map), v);\n\n\treturn 0;\n}\n\nvoid aiodma_ch_set_enable(struct uniphier_aio_sub *sub, int enable)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (enable) {\n\t\tregmap_write(r, CDA2D_STRT0,\n\t\t\t     CDA2D_STRT0_STOP_START | BIT(sub->swm->ch.map));\n\n\t\tregmap_update_bits(r, INTRBIM(0),\n\t\t\t\t   BIT(sub->swm->rb.map),\n\t\t\t\t   BIT(sub->swm->rb.map));\n\t} else {\n\t\tregmap_write(r, CDA2D_STRT0,\n\t\t\t     CDA2D_STRT0_STOP_STOP | BIT(sub->swm->ch.map));\n\n\t\tregmap_update_bits(r, INTRBIM(0),\n\t\t\t\t   BIT(sub->swm->rb.map),\n\t\t\t\t   0);\n\t}\n}\n\nstatic u64 aiodma_rb_get_rp(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 pos_u, pos_l;\n\tint i;\n\n\tregmap_write(r, CDA2D_RDPTRLOAD,\n\t\t     CDA2D_RDPTRLOAD_LSFLAG_STORE | BIT(sub->swm->rb.map));\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tregmap_read(r, CDA2D_RBMXRDPTR(sub->swm->rb.map), &pos_l);\n\n\tregmap_read(r, CDA2D_RBMXRDPTR(sub->swm->rb.map), &pos_l);\n\tregmap_read(r, CDA2D_RBMXRDPTRU(sub->swm->rb.map), &pos_u);\n\tpos_u = FIELD_GET(CDA2D_RBMXPTRU_PTRU_MASK, pos_u);\n\n\treturn ((u64)pos_u << 32) | pos_l;\n}\n\nstatic void aiodma_rb_set_rp(struct uniphier_aio_sub *sub, u64 pos)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 tmp;\n\tint i;\n\n\tregmap_write(r, CDA2D_RBMXRDPTR(sub->swm->rb.map), (u32)pos);\n\tregmap_write(r, CDA2D_RBMXRDPTRU(sub->swm->rb.map), (u32)(pos >> 32));\n\tregmap_write(r, CDA2D_RDPTRLOAD, BIT(sub->swm->rb.map));\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tregmap_read(r, CDA2D_RBMXRDPTR(sub->swm->rb.map), &tmp);\n}\n\nstatic u64 aiodma_rb_get_wp(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 pos_u, pos_l;\n\tint i;\n\n\tregmap_write(r, CDA2D_WRPTRLOAD,\n\t\t     CDA2D_WRPTRLOAD_LSFLAG_STORE | BIT(sub->swm->rb.map));\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tregmap_read(r, CDA2D_RBMXWRPTR(sub->swm->rb.map), &pos_l);\n\n\tregmap_read(r, CDA2D_RBMXWRPTR(sub->swm->rb.map), &pos_l);\n\tregmap_read(r, CDA2D_RBMXWRPTRU(sub->swm->rb.map), &pos_u);\n\tpos_u = FIELD_GET(CDA2D_RBMXPTRU_PTRU_MASK, pos_u);\n\n\treturn ((u64)pos_u << 32) | pos_l;\n}\n\nstatic void aiodma_rb_set_wp(struct uniphier_aio_sub *sub, u64 pos)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 tmp;\n\tint i;\n\n\tregmap_write(r, CDA2D_RBMXWRPTR(sub->swm->rb.map),\n\t\t     lower_32_bits(pos));\n\tregmap_write(r, CDA2D_RBMXWRPTRU(sub->swm->rb.map),\n\t\t     upper_32_bits(pos));\n\tregmap_write(r, CDA2D_WRPTRLOAD, BIT(sub->swm->rb.map));\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tregmap_read(r, CDA2D_RBMXWRPTR(sub->swm->rb.map), &tmp);\n}\n\nint aiodma_rb_set_threshold(struct uniphier_aio_sub *sub, u64 size, u32 th)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (size <= th)\n\t\treturn -EINVAL;\n\n\tregmap_write(r, CDA2D_RBMXBTH(sub->swm->rb.map), th);\n\tregmap_write(r, CDA2D_RBMXRTH(sub->swm->rb.map), th);\n\n\treturn 0;\n}\n\nint aiodma_rb_set_buffer(struct uniphier_aio_sub *sub, u64 start, u64 end,\n\t\t\t int period)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu64 size = end - start;\n\tint ret;\n\n\tif (end < start || period < 0)\n\t\treturn -EINVAL;\n\n\tregmap_write(r, CDA2D_RBMXCNFG(sub->swm->rb.map), 0);\n\tregmap_write(r, CDA2D_RBMXBGNADRS(sub->swm->rb.map),\n\t\t     lower_32_bits(start));\n\tregmap_write(r, CDA2D_RBMXBGNADRSU(sub->swm->rb.map),\n\t\t     upper_32_bits(start));\n\tregmap_write(r, CDA2D_RBMXENDADRS(sub->swm->rb.map),\n\t\t     lower_32_bits(end));\n\tregmap_write(r, CDA2D_RBMXENDADRSU(sub->swm->rb.map),\n\t\t     upper_32_bits(end));\n\n\tregmap_write(r, CDA2D_RBADRSLOAD, BIT(sub->swm->rb.map));\n\n\tret = aiodma_rb_set_threshold(sub, size, 2 * period);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\taiodma_rb_set_rp(sub, start);\n\t\taiodma_rb_set_wp(sub, end - period);\n\n\t\tregmap_update_bits(r, CDA2D_RBMXIE(sub->swm->rb.map),\n\t\t\t\t   CDA2D_RBMXIX_SPACE,\n\t\t\t\t   CDA2D_RBMXIX_SPACE);\n\t} else {\n\t\taiodma_rb_set_rp(sub, end - period);\n\t\taiodma_rb_set_wp(sub, start);\n\n\t\tregmap_update_bits(r, CDA2D_RBMXIE(sub->swm->rb.map),\n\t\t\t\t   CDA2D_RBMXIX_REMAIN,\n\t\t\t\t   CDA2D_RBMXIX_REMAIN);\n\t}\n\n\tsub->threshold = 2 * period;\n\tsub->rd_offs = 0;\n\tsub->wr_offs = 0;\n\tsub->rd_org = 0;\n\tsub->wr_org = 0;\n\tsub->rd_total = 0;\n\tsub->wr_total = 0;\n\n\treturn 0;\n}\n\nvoid aiodma_rb_sync(struct uniphier_aio_sub *sub, u64 start, u64 size,\n\t\t    int period)\n{\n\tif (sub->swm->dir == PORT_DIR_OUTPUT) {\n\t\tsub->rd_offs = aiodma_rb_get_rp(sub) - start;\n\n\t\tif (sub->use_mmap) {\n\t\t\tsub->threshold = 2 * period;\n\t\t\taiodma_rb_set_threshold(sub, size, 2 * period);\n\n\t\t\tsub->wr_offs = sub->rd_offs - period;\n\t\t\tif (sub->rd_offs < period)\n\t\t\t\tsub->wr_offs += size;\n\t\t}\n\t\taiodma_rb_set_wp(sub, sub->wr_offs + start);\n\t} else {\n\t\tsub->wr_offs = aiodma_rb_get_wp(sub) - start;\n\n\t\tif (sub->use_mmap) {\n\t\t\tsub->threshold = 2 * period;\n\t\t\taiodma_rb_set_threshold(sub, size, 2 * period);\n\n\t\t\tsub->rd_offs = sub->wr_offs - period;\n\t\t\tif (sub->wr_offs < period)\n\t\t\t\tsub->rd_offs += size;\n\t\t}\n\t\taiodma_rb_set_rp(sub, sub->rd_offs + start);\n\t}\n\n\tsub->rd_total += sub->rd_offs - sub->rd_org;\n\tif (sub->rd_offs < sub->rd_org)\n\t\tsub->rd_total += size;\n\tsub->wr_total += sub->wr_offs - sub->wr_org;\n\tif (sub->wr_offs < sub->wr_org)\n\t\tsub->wr_total += size;\n\n\tsub->rd_org = sub->rd_offs;\n\tsub->wr_org = sub->wr_offs;\n}\n\nbool aiodma_rb_is_irq(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\tu32 ir;\n\n\tregmap_read(r, CDA2D_RBMXIR(sub->swm->rb.map), &ir);\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\treturn !!(ir & CDA2D_RBMXIX_SPACE);\n\telse\n\t\treturn !!(ir & CDA2D_RBMXIX_REMAIN);\n}\n\nvoid aiodma_rb_clear_irq(struct uniphier_aio_sub *sub)\n{\n\tstruct regmap *r = sub->aio->chip->regmap;\n\n\tif (sub->swm->dir == PORT_DIR_OUTPUT)\n\t\tregmap_write(r, CDA2D_RBMXIR(sub->swm->rb.map),\n\t\t\t     CDA2D_RBMXIX_SPACE);\n\telse\n\t\tregmap_write(r, CDA2D_RBMXIR(sub->swm->rb.map),\n\t\t\t     CDA2D_RBMXIX_REMAIN);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}