{
  "module_name": "rockchip_pdm.c",
  "hash_id": "e63314fe4dd3a0bd007ffcc703f771befca5cab4e224aa020f8c9128c61edca3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/rockchip/rockchip_pdm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rational.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"rockchip_pdm.h\"\n\n#define PDM_DMA_BURST_SIZE\t(8)  \n#define PDM_SIGNOFF_CLK_RATE\t(100000000)\n#define PDM_PATH_MAX\t\t(4)\n\nenum rk_pdm_version {\n\tRK_PDM_RK3229,\n\tRK_PDM_RK3308,\n\tRK_PDM_RV1126,\n};\n\nstruct rk_pdm_dev {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct clk *hclk;\n\tstruct regmap *regmap;\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tstruct reset_control *reset;\n\tenum rk_pdm_version version;\n};\n\nstruct rk_pdm_clkref {\n\tunsigned int sr;\n\tunsigned int clk;\n\tunsigned int clk_out;\n};\n\nstruct rk_pdm_ds_ratio {\n\tunsigned int ratio;\n\tunsigned int sr;\n};\n\nstatic struct rk_pdm_clkref clkref[] = {\n\t{ 8000, 40960000, 2048000 },\n\t{ 11025, 56448000, 2822400 },\n\t{ 12000, 61440000, 3072000 },\n\t{ 8000, 98304000, 2048000 },\n\t{ 12000, 98304000, 3072000 },\n};\n\nstatic struct rk_pdm_ds_ratio ds_ratio[] = {\n\t{ 0, 192000 },\n\t{ 0, 176400 },\n\t{ 0, 128000 },\n\t{ 1, 96000 },\n\t{ 1, 88200 },\n\t{ 1, 64000 },\n\t{ 2, 48000 },\n\t{ 2, 44100 },\n\t{ 2, 32000 },\n\t{ 3, 24000 },\n\t{ 3, 22050 },\n\t{ 3, 16000 },\n\t{ 4, 12000 },\n\t{ 4, 11025 },\n\t{ 4, 8000 },\n};\n\nstatic unsigned int get_pdm_clk(struct rk_pdm_dev *pdm, unsigned int sr,\n\t\t\t\tunsigned int *clk_src, unsigned int *clk_out)\n{\n\tunsigned int i, count, clk, div, rate;\n\n\tclk = 0;\n\tif (!sr)\n\t\treturn clk;\n\n\tcount = ARRAY_SIZE(clkref);\n\tfor (i = 0; i < count; i++) {\n\t\tif (sr % clkref[i].sr)\n\t\t\tcontinue;\n\t\tdiv = sr / clkref[i].sr;\n\t\tif ((div & (div - 1)) == 0) {\n\t\t\t*clk_out = clkref[i].clk_out;\n\t\t\trate = clk_round_rate(pdm->clk, clkref[i].clk);\n\t\t\tif (rate != clkref[i].clk)\n\t\t\t\tcontinue;\n\t\t\tclk = clkref[i].clk;\n\t\t\t*clk_src = clkref[i].clk;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!clk) {\n\t\tclk = clk_round_rate(pdm->clk, PDM_SIGNOFF_CLK_RATE);\n\t\t*clk_src = clk;\n\t}\n\treturn clk;\n}\n\nstatic unsigned int get_pdm_ds_ratio(unsigned int sr)\n{\n\tunsigned int i, count, ratio;\n\n\tratio = 0;\n\tif (!sr)\n\t\treturn ratio;\n\n\tcount = ARRAY_SIZE(ds_ratio);\n\tfor (i = 0; i < count; i++) {\n\t\tif (sr == ds_ratio[i].sr)\n\t\t\tratio = ds_ratio[i].ratio;\n\t}\n\treturn ratio;\n}\n\nstatic unsigned int get_pdm_cic_ratio(unsigned int clk)\n{\n\tswitch (clk) {\n\tcase 4096000:\n\tcase 5644800:\n\tcase 6144000:\n\t\treturn 0;\n\tcase 2048000:\n\tcase 2822400:\n\tcase 3072000:\n\t\treturn 1;\n\tcase 1024000:\n\tcase 1411200:\n\tcase 1536000:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic unsigned int samplerate_to_bit(unsigned int samplerate)\n{\n\tswitch (samplerate) {\n\tcase 8000:\n\tcase 11025:\n\tcase 12000:\n\t\treturn 0;\n\tcase 16000:\n\tcase 22050:\n\tcase 24000:\n\t\treturn 1;\n\tcase 32000:\n\t\treturn 2;\n\tcase 44100:\n\tcase 48000:\n\t\treturn 3;\n\tcase 64000:\n\tcase 88200:\n\tcase 96000:\n\t\treturn 4;\n\tcase 128000:\n\tcase 176400:\n\tcase 192000:\n\t\treturn 5;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic inline struct rk_pdm_dev *to_info(struct snd_soc_dai *dai)\n{\n\treturn snd_soc_dai_get_drvdata(dai);\n}\n\nstatic void rockchip_pdm_rxctrl(struct rk_pdm_dev *pdm, int on)\n{\n\tif (on) {\n\t\tregmap_update_bits(pdm->regmap, PDM_DMA_CTRL,\n\t\t\t\t   PDM_DMA_RD_MSK, PDM_DMA_RD_EN);\n\t\tregmap_update_bits(pdm->regmap, PDM_SYSCONFIG,\n\t\t\t\t   PDM_RX_MASK, PDM_RX_START);\n\t} else {\n\t\tregmap_update_bits(pdm->regmap, PDM_DMA_CTRL,\n\t\t\t\t   PDM_DMA_RD_MSK, PDM_DMA_RD_DIS);\n\t\tregmap_update_bits(pdm->regmap, PDM_SYSCONFIG,\n\t\t\t\t   PDM_RX_MASK | PDM_RX_CLR_MASK,\n\t\t\t\t   PDM_RX_STOP | PDM_RX_CLR_WR);\n\t}\n}\n\nstatic int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct rk_pdm_dev *pdm = to_info(dai);\n\tunsigned int val = 0;\n\tunsigned int clk_rate, clk_div, samplerate;\n\tunsigned int clk_src, clk_out = 0;\n\tunsigned long m, n;\n\tbool change;\n\tint ret;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn 0;\n\n\tsamplerate = params_rate(params);\n\tclk_rate = get_pdm_clk(pdm, samplerate, &clk_src, &clk_out);\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\tret = clk_set_rate(pdm->clk, clk_src);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (pdm->version == RK_PDM_RK3308 ||\n\t    pdm->version == RK_PDM_RV1126) {\n\t\trational_best_approximation(clk_out, clk_src,\n\t\t\t\t\t    GENMASK(16 - 1, 0),\n\t\t\t\t\t    GENMASK(16 - 1, 0),\n\t\t\t\t\t    &m, &n);\n\n\t\tval = (m << PDM_FD_NUMERATOR_SFT) |\n\t\t\t(n << PDM_FD_DENOMINATOR_SFT);\n\t\tregmap_update_bits_check(pdm->regmap, PDM_CTRL1,\n\t\t\t\t\t PDM_FD_NUMERATOR_MSK |\n\t\t\t\t\t PDM_FD_DENOMINATOR_MSK,\n\t\t\t\t\t val, &change);\n\t\tif (change) {\n\t\t\treset_control_assert(pdm->reset);\n\t\t\treset_control_deassert(pdm->reset);\n\t\t\trockchip_pdm_rxctrl(pdm, 0);\n\t\t}\n\t\tclk_div = n / m;\n\t\tif (clk_div >= 40)\n\t\t\tval = PDM_CLK_FD_RATIO_40;\n\t\telse if (clk_div <= 35)\n\t\t\tval = PDM_CLK_FD_RATIO_35;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL,\n\t\t\t\t   PDM_CLK_FD_RATIO_MSK,\n\t\t\t\t   val);\n\t}\n\n\tif (pdm->version == RK_PDM_RV1126) {\n\t\tval = get_pdm_cic_ratio(clk_out);\n\t\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CIC_RATIO_MSK, val);\n\t\tval = samplerate_to_bit(samplerate);\n\t\tregmap_update_bits(pdm->regmap, PDM_CTRL0,\n\t\t\t\t   PDM_SAMPLERATE_MSK, PDM_SAMPLERATE(val));\n\t} else {\n\t\tval = get_pdm_ds_ratio(samplerate);\n\t\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_DS_RATIO_MSK, val);\n\t}\n\n\tregmap_update_bits(pdm->regmap, PDM_HPF_CTRL,\n\t\t\t   PDM_HPF_CF_MSK, PDM_HPF_60HZ);\n\tregmap_update_bits(pdm->regmap, PDM_HPF_CTRL,\n\t\t\t   PDM_HPF_LE | PDM_HPF_RE, PDM_HPF_LE | PDM_HPF_RE);\n\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CLK_EN, PDM_CLK_EN);\n\tif (pdm->version != RK_PDM_RK3229)\n\t\tregmap_update_bits(pdm->regmap, PDM_CTRL0,\n\t\t\t\t   PDM_MODE_MSK, PDM_MODE_LJ);\n\n\tval = 0;\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tval |= PDM_VDW(8);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tval |= PDM_VDW(16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tval |= PDM_VDW(20);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tval |= PDM_VDW(24);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval |= PDM_VDW(32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 8:\n\t\tval |= PDM_PATH3_EN;\n\t\tfallthrough;\n\tcase 6:\n\t\tval |= PDM_PATH2_EN;\n\t\tfallthrough;\n\tcase 4:\n\t\tval |= PDM_PATH1_EN;\n\t\tfallthrough;\n\tcase 2:\n\t\tval |= PDM_PATH0_EN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdm->dev, \"invalid channel: %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(pdm->regmap, PDM_CTRL0,\n\t\t\t   PDM_PATH_MSK | PDM_VDW_MSK,\n\t\t\t   val);\n\t \n\tregmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,\n\t\t\t   PDM_DMA_RDL(8 * params_channels(params)));\n\n\treturn 0;\n}\n\nstatic int rockchip_pdm_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\tunsigned int fmt)\n{\n\tstruct rk_pdm_dev *pdm = to_info(cpu_dai);\n\tunsigned int mask = 0, val = 0;\n\n\tmask = PDM_CKP_MSK;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval = PDM_CKP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval = PDM_CKP_INVERTED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(cpu_dai->dev);\n\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL, mask, val);\n\tpm_runtime_put(cpu_dai->dev);\n\n\treturn 0;\n}\n\nstatic int rockchip_pdm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct rk_pdm_dev *pdm = to_info(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\trockchip_pdm_rxctrl(pdm, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\trockchip_pdm_rxctrl(pdm, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_pdm_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct rk_pdm_dev *pdm = to_info(dai);\n\n\tsnd_soc_dai_dma_data_set_capture(dai, &pdm->capture_dma_data);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rockchip_pdm_dai_ops = {\n\t.probe = rockchip_pdm_dai_probe,\n\t.set_fmt = rockchip_pdm_set_fmt,\n\t.trigger = rockchip_pdm_trigger,\n\t.hw_params = rockchip_pdm_hw_params,\n};\n\n#define ROCKCHIP_PDM_RATES SNDRV_PCM_RATE_8000_192000\n#define ROCKCHIP_PDM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t      SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t      SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t      SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver rockchip_pdm_dai = {\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = ROCKCHIP_PDM_RATES,\n\t\t.formats = ROCKCHIP_PDM_FORMATS,\n\t},\n\t.ops = &rockchip_pdm_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver rockchip_pdm_component = {\n\t.name = \"rockchip-pdm\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic int rockchip_pdm_runtime_suspend(struct device *dev)\n{\n\tstruct rk_pdm_dev *pdm = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(pdm->clk);\n\tclk_disable_unprepare(pdm->hclk);\n\n\treturn 0;\n}\n\nstatic int rockchip_pdm_runtime_resume(struct device *dev)\n{\n\tstruct rk_pdm_dev *pdm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(pdm->clk);\n\tif (ret) {\n\t\tdev_err(pdm->dev, \"clock enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(pdm->hclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(pdm->clk);\n\t\tdev_err(pdm->dev, \"hclock enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool rockchip_pdm_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PDM_SYSCONFIG:\n\tcase PDM_CTRL0:\n\tcase PDM_CTRL1:\n\tcase PDM_CLK_CTRL:\n\tcase PDM_HPF_CTRL:\n\tcase PDM_FIFO_CTRL:\n\tcase PDM_DMA_CTRL:\n\tcase PDM_INT_EN:\n\tcase PDM_INT_CLR:\n\tcase PDM_DATA_VALID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_pdm_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PDM_SYSCONFIG:\n\tcase PDM_CTRL0:\n\tcase PDM_CTRL1:\n\tcase PDM_CLK_CTRL:\n\tcase PDM_HPF_CTRL:\n\tcase PDM_FIFO_CTRL:\n\tcase PDM_DMA_CTRL:\n\tcase PDM_INT_EN:\n\tcase PDM_INT_CLR:\n\tcase PDM_INT_ST:\n\tcase PDM_DATA_VALID:\n\tcase PDM_RXFIFO_DATA:\n\tcase PDM_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_pdm_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PDM_SYSCONFIG:\n\tcase PDM_FIFO_CTRL:\n\tcase PDM_INT_CLR:\n\tcase PDM_INT_ST:\n\tcase PDM_RXFIFO_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_pdm_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PDM_RXFIFO_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default rockchip_pdm_reg_defaults[] = {\n\t{ PDM_CTRL0, 0x78000017 },\n\t{ PDM_CTRL1, 0x0bb8ea60 },\n\t{ PDM_CLK_CTRL, 0x0000e401 },\n\t{ PDM_DMA_CTRL, 0x0000001f },\n};\n\nstatic const struct regmap_config rockchip_pdm_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = PDM_VERSION,\n\t.reg_defaults = rockchip_pdm_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rockchip_pdm_reg_defaults),\n\t.writeable_reg = rockchip_pdm_wr_reg,\n\t.readable_reg = rockchip_pdm_rd_reg,\n\t.volatile_reg = rockchip_pdm_volatile_reg,\n\t.precious_reg = rockchip_pdm_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct of_device_id rockchip_pdm_match[] __maybe_unused = {\n\t{ .compatible = \"rockchip,pdm\",\n\t  .data = (void *)RK_PDM_RK3229 },\n\t{ .compatible = \"rockchip,px30-pdm\",\n\t  .data = (void *)RK_PDM_RK3308 },\n\t{ .compatible = \"rockchip,rk1808-pdm\",\n\t  .data = (void *)RK_PDM_RK3308 },\n\t{ .compatible = \"rockchip,rk3308-pdm\",\n\t  .data = (void *)RK_PDM_RK3308 },\n\t{ .compatible = \"rockchip,rk3568-pdm\",\n\t  .data = (void *)RK_PDM_RV1126 },\n\t{ .compatible = \"rockchip,rv1126-pdm\",\n\t  .data = (void *)RK_PDM_RV1126 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rockchip_pdm_match);\n\nstatic int rockchip_pdm_path_parse(struct rk_pdm_dev *pdm, struct device_node *node)\n{\n\tunsigned int path[PDM_PATH_MAX];\n\tint cnt = 0, ret = 0, i = 0, val = 0, msk = 0;\n\n\tcnt = of_count_phandle_with_args(node, \"rockchip,path-map\",\n\t\t\t\t\t NULL);\n\tif (cnt != PDM_PATH_MAX)\n\t\treturn cnt;\n\n\tret = of_property_read_u32_array(node, \"rockchip,path-map\",\n\t\t\t\t\t path, cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (path[i] >= PDM_PATH_MAX)\n\t\t\treturn -EINVAL;\n\t\tmsk |= PDM_PATH_MASK(i);\n\t\tval |= PDM_PATH(i, path[i]);\n\t}\n\n\tregmap_update_bits(pdm->regmap, PDM_CLK_CTRL, msk, val);\n\n\treturn 0;\n}\n\nstatic int rockchip_pdm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct rk_pdm_dev *pdm;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tpdm = devm_kzalloc(&pdev->dev, sizeof(*pdm), GFP_KERNEL);\n\tif (!pdm)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(rockchip_pdm_match, &pdev->dev);\n\tif (match)\n\t\tpdm->version = (uintptr_t)match->data;\n\n\tif (pdm->version == RK_PDM_RK3308) {\n\t\tpdm->reset = devm_reset_control_get(&pdev->dev, \"pdm-m\");\n\t\tif (IS_ERR(pdm->reset))\n\t\t\treturn PTR_ERR(pdm->reset);\n\t}\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t    &rockchip_pdm_regmap_config);\n\tif (IS_ERR(pdm->regmap))\n\t\treturn PTR_ERR(pdm->regmap);\n\n\tpdm->capture_dma_data.addr = res->start + PDM_RXFIFO_DATA;\n\tpdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tpdm->capture_dma_data.maxburst = PDM_DMA_BURST_SIZE;\n\n\tpdm->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, pdm);\n\n\tpdm->clk = devm_clk_get(&pdev->dev, \"pdm_clk\");\n\tif (IS_ERR(pdm->clk))\n\t\treturn PTR_ERR(pdm->clk);\n\n\tpdm->hclk = devm_clk_get(&pdev->dev, \"pdm_hclk\");\n\tif (IS_ERR(pdm->hclk))\n\t\treturn PTR_ERR(pdm->hclk);\n\n\tret = clk_prepare_enable(pdm->hclk);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = rockchip_pdm_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &rockchip_pdm_component,\n\t\t\t\t\t      &rockchip_pdm_dai, 1);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register dai: %d\\n\", ret);\n\t\tgoto err_suspend;\n\t}\n\n\trockchip_pdm_rxctrl(pdm, 0);\n\n\tret = rockchip_pdm_path_parse(pdm, node);\n\tif (ret != 0 && ret != -ENOENT)\n\t\tgoto err_suspend;\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register pcm: %d\\n\", ret);\n\t\tgoto err_suspend;\n\t}\n\n\treturn 0;\n\nerr_suspend:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\trockchip_pdm_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(pdm->hclk);\n\n\treturn ret;\n}\n\nstatic void rockchip_pdm_remove(struct platform_device *pdev)\n{\n\tstruct rk_pdm_dev *pdm = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\trockchip_pdm_runtime_suspend(&pdev->dev);\n\n\tclk_disable_unprepare(pdm->clk);\n\tclk_disable_unprepare(pdm->hclk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rockchip_pdm_suspend(struct device *dev)\n{\n\tstruct rk_pdm_dev *pdm = dev_get_drvdata(dev);\n\n\tregcache_mark_dirty(pdm->regmap);\n\n\treturn 0;\n}\n\nstatic int rockchip_pdm_resume(struct device *dev)\n{\n\tstruct rk_pdm_dev *pdm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regcache_sync(pdm->regmap);\n\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops rockchip_pdm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rockchip_pdm_runtime_suspend,\n\t\t\t   rockchip_pdm_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(rockchip_pdm_suspend, rockchip_pdm_resume)\n};\n\nstatic struct platform_driver rockchip_pdm_driver = {\n\t.probe  = rockchip_pdm_probe,\n\t.remove_new = rockchip_pdm_remove,\n\t.driver = {\n\t\t.name = \"rockchip-pdm\",\n\t\t.of_match_table = of_match_ptr(rockchip_pdm_match),\n\t\t.pm = &rockchip_pdm_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rockchip_pdm_driver);\n\nMODULE_AUTHOR(\"Sugar <sugar.zhang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip PDM Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}