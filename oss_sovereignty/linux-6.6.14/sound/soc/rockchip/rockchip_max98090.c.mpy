{
  "module_name": "rockchip_max98090.c",
  "hash_id": "4829c72752280787971f742bfbb52039246669411d8bcd83328780d27ac929b3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/rockchip/rockchip_max98090.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"rockchip_i2s.h\"\n#include \"../codecs/ts3a227e.h\"\n\n#define DRV_NAME \"rockchip-snd-max98090\"\n\nstatic struct snd_soc_jack headset_jack;\n\n \nstatic struct snd_soc_jack_pin headset_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n\n};\n\n#define RK_MAX98090_WIDGETS \\\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL), \\\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL), \\\n\tSND_SOC_DAPM_MIC(\"Int Mic\", NULL), \\\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL)\n\n#define RK_HDMI_WIDGETS \\\n\tSND_SOC_DAPM_LINE(\"HDMI\", NULL)\n\nstatic const struct snd_soc_dapm_widget rk_max98090_dapm_widgets[] = {\n\tRK_MAX98090_WIDGETS,\n};\n\nstatic const struct snd_soc_dapm_widget rk_hdmi_dapm_widgets[] = {\n\tRK_HDMI_WIDGETS,\n};\n\nstatic const struct snd_soc_dapm_widget rk_max98090_hdmi_dapm_widgets[] = {\n\tRK_MAX98090_WIDGETS,\n\tRK_HDMI_WIDGETS,\n};\n\n#define RK_MAX98090_AUDIO_MAP \\\n\t{\"IN34\", NULL, \"Headset Mic\"}, \\\n\t{\"Headset Mic\", NULL, \"MICBIAS\"}, \\\n\t{\"DMICL\", NULL, \"Int Mic\"}, \\\n\t{\"Headphone\", NULL, \"HPL\"}, \\\n\t{\"Headphone\", NULL, \"HPR\"}, \\\n\t{\"Speaker\", NULL, \"SPKL\"}, \\\n\t{\"Speaker\", NULL, \"SPKR\"}\n\n#define RK_HDMI_AUDIO_MAP \\\n\t{\"HDMI\", NULL, \"TX\"}\n\nstatic const struct snd_soc_dapm_route rk_max98090_audio_map[] = {\n\tRK_MAX98090_AUDIO_MAP,\n};\n\nstatic const struct snd_soc_dapm_route rk_hdmi_audio_map[] = {\n\tRK_HDMI_AUDIO_MAP,\n};\n\nstatic const struct snd_soc_dapm_route rk_max98090_hdmi_audio_map[] = {\n\tRK_MAX98090_AUDIO_MAP,\n\tRK_HDMI_AUDIO_MAP,\n};\n\n#define RK_MAX98090_CONTROLS \\\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"), \\\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"), \\\n\tSOC_DAPM_PIN_SWITCH(\"Int Mic\"), \\\n\tSOC_DAPM_PIN_SWITCH(\"Speaker\")\n\n#define RK_HDMI_CONTROLS \\\n\tSOC_DAPM_PIN_SWITCH(\"HDMI\")\n\nstatic const struct snd_kcontrol_new rk_max98090_controls[] = {\n\tRK_MAX98090_CONTROLS,\n};\n\nstatic const struct snd_kcontrol_new rk_hdmi_controls[] = {\n\tRK_HDMI_CONTROLS,\n};\n\nstatic const struct snd_kcontrol_new rk_max98090_hdmi_controls[] = {\n\tRK_MAX98090_CONTROLS,\n\tRK_HDMI_CONTROLS,\n};\n\nstatic int rk_jack_event(struct notifier_block *nb, unsigned long event,\n\t\t\t void *data)\n{\n\tstruct snd_soc_jack *jack = (struct snd_soc_jack *)data;\n\tstruct snd_soc_dapm_context *dapm = &jack->card->dapm;\n\n\tif (event & SND_JACK_MICROPHONE) {\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"SHDN\");\n\t} else {\n\t\tsnd_soc_dapm_disable_pin(dapm, \"MICBIAS\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"SHDN\");\n\t}\n\n\tsnd_soc_dapm_sync(dapm);\n\n\treturn 0;\n}\n\nstatic struct notifier_block rk_jack_nb = {\n\t.notifier_call = rk_jack_event,\n};\n\nstatic int rk_init(struct snd_soc_pcm_runtime *runtime)\n{\n\t \n\tsnd_soc_jack_notifier_register(&headset_jack, &rk_jack_nb);\n\n\treturn 0;\n}\n\nstatic int rk_aif1_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tint ret = 0;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint mclk;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\tcase 64000:\n\tcase 96000:\n\t\tmclk = 12288000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\t\tmclk = 11289600;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,\n\t\t\t\t     SND_SOC_CLOCK_OUT);\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev, \"Can't set cpu dai clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\n\t \n\tif (!strcmp(rtd->dai_link->name, \"HDMI\"))\n\t\treturn 0;\n\n\tif (ret) {\n\t\tdev_err(codec_dai->dev, \"Can't set codec dai clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rk_aif1_startup(struct snd_pcm_substream *substream)\n{\n\t \n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 240, 240);\n}\n\nstatic const struct snd_soc_ops rk_aif1_ops = {\n\t.hw_params = rk_aif1_hw_params,\n\t.startup = rk_aif1_startup,\n};\n\nSND_SOC_DAILINK_DEFS(analog,\n\t\t     DAILINK_COMP_ARRAY(COMP_EMPTY()),\n\t\t     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"HiFi\")),\n\t\t     DAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(hdmi,\n\t\t     DAILINK_COMP_ARRAY(COMP_EMPTY()),\n\t\t     DAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"i2s-hifi\")),\n\t\t     DAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nenum {\n\tDAILINK_MAX98090,\n\tDAILINK_HDMI,\n};\n\nstatic struct snd_soc_jack rk_hdmi_jack;\n\nstatic int rk_hdmi_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct snd_soc_card *card = runtime->card;\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(runtime, 0)->component;\n\tint ret;\n\n\t \n\tret = snd_soc_card_jack_new(card, \"HDMI Jack\", SND_JACK_LINEOUT,\n\t\t\t\t    &rk_hdmi_jack);\n\tif (ret) {\n\t\tdev_err(card->dev, \"Can't new HDMI Jack %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_component_set_jack(component, &rk_hdmi_jack, NULL);\n}\n\n \nstatic struct snd_soc_dai_link rk_max98090_dailinks[] = {\n\t{\n\t\t.name = \"max98090\",\n\t\t.stream_name = \"Analog\",\n\t\t.init = rk_init,\n\t\t.ops = &rk_aif1_ops,\n\t\t \n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBS_CFS,\n\t\tSND_SOC_DAILINK_REG(analog),\n\t},\n};\n\n \nstatic struct snd_soc_dai_link rk_hdmi_dailinks[] = {\n\t{\n\t\t.name = \"HDMI\",\n\t\t.stream_name = \"HDMI\",\n\t\t.init = rk_hdmi_init,\n\t\t.ops = &rk_aif1_ops,\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBS_CFS,\n\t\tSND_SOC_DAILINK_REG(hdmi),\n\t}\n};\n\n \nstatic struct snd_soc_dai_link rk_max98090_hdmi_dailinks[] = {\n\t[DAILINK_MAX98090] = {\n\t\t.name = \"max98090\",\n\t\t.stream_name = \"Analog\",\n\t\t.init = rk_init,\n\t\t.ops = &rk_aif1_ops,\n\t\t \n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBS_CFS,\n\t\tSND_SOC_DAILINK_REG(analog),\n\t},\n\t[DAILINK_HDMI] = {\n\t\t.name = \"HDMI\",\n\t\t.stream_name = \"HDMI\",\n\t\t.init = rk_hdmi_init,\n\t\t.ops = &rk_aif1_ops,\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBS_CFS,\n\t\tSND_SOC_DAILINK_REG(hdmi),\n\t}\n};\n\nstatic int rk_98090_headset_init(struct snd_soc_component *component);\n\nstatic struct snd_soc_aux_dev rk_98090_headset_dev = {\n\t.dlc = COMP_EMPTY(),\n\t.init = rk_98090_headset_init,\n};\n\nstatic struct snd_soc_card rockchip_max98090_card = {\n\t.name = \"ROCKCHIP-I2S\",\n\t.owner = THIS_MODULE,\n\t.dai_link = rk_max98090_dailinks,\n\t.num_links = ARRAY_SIZE(rk_max98090_dailinks),\n\t.aux_dev = &rk_98090_headset_dev,\n\t.num_aux_devs = 1,\n\t.dapm_widgets = rk_max98090_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rk_max98090_dapm_widgets),\n\t.dapm_routes = rk_max98090_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rk_max98090_audio_map),\n\t.controls = rk_max98090_controls,\n\t.num_controls = ARRAY_SIZE(rk_max98090_controls),\n};\n\nstatic struct snd_soc_card rockchip_hdmi_card = {\n\t.name = \"ROCKCHIP-HDMI\",\n\t.owner = THIS_MODULE,\n\t.dai_link = rk_hdmi_dailinks,\n\t.num_links = ARRAY_SIZE(rk_hdmi_dailinks),\n\t.dapm_widgets = rk_hdmi_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rk_hdmi_dapm_widgets),\n\t.dapm_routes = rk_hdmi_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rk_hdmi_audio_map),\n\t.controls = rk_hdmi_controls,\n\t.num_controls = ARRAY_SIZE(rk_hdmi_controls),\n};\n\nstatic struct snd_soc_card rockchip_max98090_hdmi_card = {\n\t.name = \"ROCKCHIP-MAX98090-HDMI\",\n\t.owner = THIS_MODULE,\n\t.dai_link = rk_max98090_hdmi_dailinks,\n\t.num_links = ARRAY_SIZE(rk_max98090_hdmi_dailinks),\n\t.aux_dev = &rk_98090_headset_dev,\n\t.num_aux_devs = 1,\n\t.dapm_widgets = rk_max98090_hdmi_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rk_max98090_hdmi_dapm_widgets),\n\t.dapm_routes = rk_max98090_hdmi_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rk_max98090_hdmi_audio_map),\n\t.controls = rk_max98090_hdmi_controls,\n\t.num_controls = ARRAY_SIZE(rk_max98090_hdmi_controls),\n};\n\nstatic int rk_98090_headset_init(struct snd_soc_component *component)\n{\n\tint ret;\n\n\t \n\tret = snd_soc_card_jack_new_pins(component->card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t &headset_jack,\n\t\t\t\t\t headset_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(headset_jack_pins));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ts3a227e_enable_jack_detect(component, &headset_jack);\n\n\treturn ret;\n}\n\nstatic int rk_parse_headset_from_of(struct device *dev, struct device_node *np)\n{\n\trk_98090_headset_dev.dlc.of_node = of_parse_phandle(\n\t\t\tnp, \"rockchip,headset-codec\", 0);\n\tif (!rk_98090_headset_dev.dlc.of_node) {\n\t\tdev_err(dev,\n\t\t\t\"Property 'rockchip,headset-codec' missing/invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_rk_mc_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct snd_soc_card *card;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *np_cpu;\n\tstruct device_node *np_audio, *np_hdmi;\n\n\t \n\tnp_cpu = of_parse_phandle(np, \"rockchip,i2s-controller\", 0);\n\n\tif (!np_cpu) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Property 'rockchip,i2s-controller missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnp_audio = of_parse_phandle(np, \"rockchip,audio-codec\", 0);\n\tnp_hdmi = of_parse_phandle(np, \"rockchip,hdmi-codec\", 0);\n\tif (np_audio && np_hdmi) {\n\t\tcard = &rockchip_max98090_hdmi_card;\n\t\tcard->dai_link[DAILINK_MAX98090].codecs->of_node = np_audio;\n\t\tcard->dai_link[DAILINK_HDMI].codecs->of_node = np_hdmi;\n\t\tcard->dai_link[DAILINK_MAX98090].cpus->of_node = np_cpu;\n\t\tcard->dai_link[DAILINK_MAX98090].platforms->of_node = np_cpu;\n\t\tcard->dai_link[DAILINK_HDMI].cpus->of_node = np_cpu;\n\t\tcard->dai_link[DAILINK_HDMI].platforms->of_node = np_cpu;\n\t} else if (np_audio) {\n\t\tcard = &rockchip_max98090_card;\n\t\tcard->dai_link[0].codecs->of_node = np_audio;\n\t\tcard->dai_link[0].cpus->of_node = np_cpu;\n\t\tcard->dai_link[0].platforms->of_node = np_cpu;\n\t} else if (np_hdmi) {\n\t\tcard = &rockchip_hdmi_card;\n\t\tcard->dai_link[0].codecs->of_node = np_hdmi;\n\t\tcard->dai_link[0].cpus->of_node = np_cpu;\n\t\tcard->dai_link[0].platforms->of_node = np_cpu;\n\t} else {\n\t\tdev_err(dev, \"At least one of codecs should be specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcard->dev = dev;\n\n\t \n\tif (np_audio) {\n\t\tret = rk_parse_headset_from_of(dev, np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_of_parse_card_name(card, \"rockchip,model\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Soc parse card name failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Soc register card failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id rockchip_max98090_of_match[] = {\n\t{ .compatible = \"rockchip,rockchip-audio-max98090\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_max98090_of_match);\n\nstatic struct platform_driver snd_rk_mc_driver = {\n\t.probe = snd_rk_mc_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = rockchip_max98090_of_match,\n\t},\n};\n\nmodule_platform_driver(snd_rk_mc_driver);\n\nMODULE_AUTHOR(\"jianqun <jay.xu@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip max98090 machine ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}