{
  "module_name": "rk3288_hdmi_analog.c",
  "hash_id": "25643dc4a704aab27a1b1bc3c6541f0ef1ac8d47d9134b5ef75e418fdd66dc83",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/rockchip/rk3288_hdmi_analog.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n#include \"rockchip_i2s.h\"\n\n#define DRV_NAME \"rk3288-snd-hdmi-analog\"\n\nstruct rk_drvdata {\n\tint gpio_hp_en;\n\tint gpio_hp_det;\n};\n\nstatic int rk_hp_power(struct snd_soc_dapm_widget *w,\n\t\t       struct snd_kcontrol *k, int event)\n{\n\tstruct rk_drvdata *machine = snd_soc_card_get_drvdata(w->dapm->card);\n\n\tif (!gpio_is_valid(machine->gpio_hp_en))\n\t\treturn 0;\n\n\tgpio_set_value_cansleep(machine->gpio_hp_en,\n\t\t\t\tSND_SOC_DAPM_EVENT_ON(event));\n\n\treturn 0;\n}\n\nstatic struct snd_soc_jack headphone_jack;\nstatic struct snd_soc_jack_pin headphone_jack_pins[] = {\n\t{\n\t\t.pin = \"Analog\",\n\t\t.mask = SND_JACK_HEADPHONE\n\t},\n};\n\nstatic const struct snd_soc_dapm_widget rk_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Analog\", rk_hp_power),\n\tSND_SOC_DAPM_LINE(\"HDMI\", NULL),\n};\n\nstatic const struct snd_kcontrol_new rk_mc_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Analog\"),\n\tSOC_DAPM_PIN_SWITCH(\"HDMI\"),\n};\n\nstatic int rk_hw_params(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tint ret = 0;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint mclk;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\tcase 64000:\n\tcase 96000:\n\t\tmclk = 12288000;\n\t\tbreak;\n\tcase 192000:\n\t\tmclk = 24576000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\t\tmclk = 11289600;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,\n\t\t\t\t     SND_SOC_CLOCK_OUT);\n\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(codec_dai->dev, \"Can't set cpu clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(codec_dai->dev, \"Can't set codec clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_jack_gpio rk_hp_jack_gpio = {\n\t.name = \"Headphone detection\",\n\t.report = SND_JACK_HEADPHONE,\n\t.debounce_time = 150\n};\n\nstatic int rk_init(struct snd_soc_pcm_runtime *runtime)\n{\n\tstruct rk_drvdata *machine = snd_soc_card_get_drvdata(runtime->card);\n\n\t \n\tif (gpio_is_valid(machine->gpio_hp_det)) {\n\t\tsnd_soc_card_jack_new_pins(runtime->card, \"Headphone Jack\",\n\t\t\t\t\t   SND_JACK_HEADPHONE, &headphone_jack,\n\t\t\t\t\t   headphone_jack_pins,\n\t\t\t\t\t   ARRAY_SIZE(headphone_jack_pins));\n\t\trk_hp_jack_gpio.gpio = machine->gpio_hp_det;\n\t\tsnd_soc_jack_add_gpios(&headphone_jack, 1, &rk_hp_jack_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops rk_ops = {\n\t.hw_params = rk_hw_params,\n};\n\nSND_SOC_DAILINK_DEFS(audio,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, NULL),\n\t\t\t   COMP_CODEC(\"hdmi-audio-codec.2.auto\", \"i2s-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link rk_dailink = {\n\t.name = \"Codecs\",\n\t.stream_name = \"Audio\",\n\t.init = rk_init,\n\t.ops = &rk_ops,\n\t \n\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\tSND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(audio),\n};\n\nstatic struct snd_soc_card snd_soc_card_rk = {\n\t.name = \"ROCKCHIP-I2S\",\n\t.dai_link = &rk_dailink,\n\t.num_links = 1,\n\t.num_aux_devs = 0,\n\t.dapm_widgets = rk_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rk_dapm_widgets),\n\t.controls = rk_mc_controls,\n\t.num_controls = ARRAY_SIZE(rk_mc_controls),\n};\n\nstatic int snd_rk_mc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct snd_soc_card *card = &snd_soc_card_rk;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct rk_drvdata *machine;\n\tstruct of_phandle_args args;\n\n\tmachine = devm_kzalloc(&pdev->dev, sizeof(struct rk_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (!machine)\n\t\treturn -ENOMEM;\n\n\tcard->dev = &pdev->dev;\n\n\tmachine->gpio_hp_det = of_get_named_gpio(np,\n\t\t\"rockchip,hp-det-gpios\", 0);\n\tif (!gpio_is_valid(machine->gpio_hp_det) && machine->gpio_hp_det != -ENODEV)\n\t\treturn machine->gpio_hp_det;\n\n\tmachine->gpio_hp_en = of_get_named_gpio(np,\n\t\t\"rockchip,hp-en-gpios\", 0);\n\tif (!gpio_is_valid(machine->gpio_hp_en) && machine->gpio_hp_en != -ENODEV)\n\t\treturn machine->gpio_hp_en;\n\n\tif (gpio_is_valid(machine->gpio_hp_en)) {\n\t\tret = devm_gpio_request_one(&pdev->dev, machine->gpio_hp_en,\n\t\t\t\t\t    GPIOF_OUT_INIT_LOW, \"hp_en\");\n\t\tif (ret) {\n\t\t\tdev_err(card->dev, \"cannot get hp_en gpio\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = snd_soc_of_parse_card_name(card, \"rockchip,model\");\n\tif (ret) {\n\t\tdev_err(card->dev, \"SoC parse card name failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trk_dailink.codecs[0].of_node = of_parse_phandle(np,\n\t\t\t\t\t\t\t\"rockchip,audio-codec\",\n\t\t\t\t\t\t\t0);\n\tif (!rk_dailink.codecs[0].of_node) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Property 'rockchip,audio-codec' missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = of_parse_phandle_with_fixed_args(np, \"rockchip,audio-codec\",\n\t\t\t\t\t       0, 0, &args);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to parse property 'rockchip,audio-codec'\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_get_dai_name(&args, &rk_dailink.codecs[0].dai_name);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to get codec_dai_name\\n\");\n\t\treturn ret;\n\t}\n\n\trk_dailink.cpus->of_node = of_parse_phandle(np, \"rockchip,i2s-controller\",\n\t\t\t\t\t\t  0);\n\tif (!rk_dailink.cpus->of_node) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Property 'rockchip,i2s-controller' missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trk_dailink.platforms->of_node = rk_dailink.cpus->of_node;\n\n\tret = snd_soc_of_parse_audio_routing(card, \"rockchip,routing\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to parse 'rockchip,routing' property\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_soc_card_set_drvdata(card, machine);\n\n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Soc register card failed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rockchip_sound_of_match[] = {\n\t{ .compatible = \"rockchip,rk3288-hdmi-analog\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_sound_of_match);\n\nstatic struct platform_driver rockchip_sound_driver = {\n\t.probe = snd_rk_mc_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = rockchip_sound_of_match,\n\t},\n};\n\nmodule_platform_driver(rockchip_sound_driver);\n\nMODULE_AUTHOR(\"Sjoerd Simons <sjoerd.simons@collabora.com>\");\nMODULE_DESCRIPTION(\"Rockchip RK3288 machine ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}