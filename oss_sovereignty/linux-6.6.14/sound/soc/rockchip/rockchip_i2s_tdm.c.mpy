{
  "module_name": "rockchip_i2s_tdm.c",
  "hash_id": "1eedd4cfbf1d40dc62af98299466f7de9cd7eff3e4ebc5fef410a76a3d837fca",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/rockchip/rockchip_i2s_tdm.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"rockchip_i2s_tdm.h\"\n\n#define DRV_NAME \"rockchip-i2s-tdm\"\n\n#define DEFAULT_MCLK_FS\t\t\t\t256\n#define CH_GRP_MAX\t\t\t\t4   \n#define MULTIPLEX_CH_MAX\t\t\t10\n#define CLK_PPM_MIN\t\t\t\t-1000\n#define CLK_PPM_MAX\t\t\t\t1000\n\n#define TRCM_TXRX 0\n#define TRCM_TX 1\n#define TRCM_RX 2\n\nstruct txrx_config {\n\tu32 addr;\n\tu32 reg;\n\tu32 txonly;\n\tu32 rxonly;\n};\n\nstruct rk_i2s_soc_data {\n\tu32 softrst_offset;\n\tu32 grf_reg_offset;\n\tu32 grf_shift;\n\tint config_count;\n\tconst struct txrx_config *configs;\n\tint (*init)(struct device *dev, u32 addr);\n};\n\nstruct rk_i2s_tdm_dev {\n\tstruct device *dev;\n\tstruct clk *hclk;\n\tstruct clk *mclk_tx;\n\tstruct clk *mclk_rx;\n\t \n\tstruct clk *mclk_tx_src;\n\t \n\tstruct clk *mclk_rx_src;\n\t \n\tstruct clk *mclk_root0;\n\tstruct clk *mclk_root1;\n\tstruct regmap *regmap;\n\tstruct regmap *grf;\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tstruct snd_dmaengine_dai_dma_data playback_dma_data;\n\tstruct reset_control *tx_reset;\n\tstruct reset_control *rx_reset;\n\tstruct rk_i2s_soc_data *soc_data;\n\tbool is_master_mode;\n\tbool io_multiplex;\n\tbool mclk_calibrate;\n\tbool tdm_mode;\n\tunsigned int mclk_rx_freq;\n\tunsigned int mclk_tx_freq;\n\tunsigned int mclk_root0_freq;\n\tunsigned int mclk_root1_freq;\n\tunsigned int mclk_root0_initial_freq;\n\tunsigned int mclk_root1_initial_freq;\n\tunsigned int frame_width;\n\tunsigned int clk_trcm;\n\tunsigned int i2s_sdis[CH_GRP_MAX];\n\tunsigned int i2s_sdos[CH_GRP_MAX];\n\tint clk_ppm;\n\tint refcount;\n\tspinlock_t lock;  \n\tbool has_playback;\n\tbool has_capture;\n\tstruct snd_soc_dai_driver *dai;\n};\n\nstatic int to_ch_num(unsigned int val)\n{\n\tswitch (val) {\n\tcase I2S_CHN_4:\n\t\treturn 4;\n\tcase I2S_CHN_6:\n\t\treturn 6;\n\tcase I2S_CHN_8:\n\t\treturn 8;\n\tdefault:\n\t\treturn 2;\n\t}\n}\n\nstatic void i2s_tdm_disable_unprepare_mclk(struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tclk_disable_unprepare(i2s_tdm->mclk_tx);\n\tclk_disable_unprepare(i2s_tdm->mclk_rx);\n\tif (i2s_tdm->mclk_calibrate) {\n\t\tclk_disable_unprepare(i2s_tdm->mclk_tx_src);\n\t\tclk_disable_unprepare(i2s_tdm->mclk_rx_src);\n\t\tclk_disable_unprepare(i2s_tdm->mclk_root0);\n\t\tclk_disable_unprepare(i2s_tdm->mclk_root1);\n\t}\n}\n\n \nstatic int i2s_tdm_prepare_enable_mclk(struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tint ret = 0;\n\n\tret = clk_prepare_enable(i2s_tdm->mclk_tx);\n\tif (ret)\n\t\tgoto err_mclk_tx;\n\tret = clk_prepare_enable(i2s_tdm->mclk_rx);\n\tif (ret)\n\t\tgoto err_mclk_rx;\n\tif (i2s_tdm->mclk_calibrate) {\n\t\tret = clk_prepare_enable(i2s_tdm->mclk_tx_src);\n\t\tif (ret)\n\t\t\tgoto err_mclk_rx;\n\t\tret = clk_prepare_enable(i2s_tdm->mclk_rx_src);\n\t\tif (ret)\n\t\t\tgoto err_mclk_rx_src;\n\t\tret = clk_prepare_enable(i2s_tdm->mclk_root0);\n\t\tif (ret)\n\t\t\tgoto err_mclk_root0;\n\t\tret = clk_prepare_enable(i2s_tdm->mclk_root1);\n\t\tif (ret)\n\t\t\tgoto err_mclk_root1;\n\t}\n\n\treturn 0;\n\nerr_mclk_root1:\n\tclk_disable_unprepare(i2s_tdm->mclk_root0);\nerr_mclk_root0:\n\tclk_disable_unprepare(i2s_tdm->mclk_rx_src);\nerr_mclk_rx_src:\n\tclk_disable_unprepare(i2s_tdm->mclk_tx_src);\nerr_mclk_rx:\n\tclk_disable_unprepare(i2s_tdm->mclk_tx);\nerr_mclk_tx:\n\treturn ret;\n}\n\nstatic int __maybe_unused i2s_tdm_runtime_suspend(struct device *dev)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s_tdm->regmap, true);\n\ti2s_tdm_disable_unprepare_mclk(i2s_tdm);\n\n\tclk_disable_unprepare(i2s_tdm->hclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused i2s_tdm_runtime_resume(struct device *dev)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(i2s_tdm->hclk);\n\tif (ret)\n\t\tgoto err_hclk;\n\n\tret = i2s_tdm_prepare_enable_mclk(i2s_tdm);\n\tif (ret)\n\t\tgoto err_mclk;\n\n\tregcache_cache_only(i2s_tdm->regmap, false);\n\tregcache_mark_dirty(i2s_tdm->regmap);\n\n\tret = regcache_sync(i2s_tdm->regmap);\n\tif (ret)\n\t\tgoto err_regcache;\n\n\treturn 0;\n\nerr_regcache:\n\ti2s_tdm_disable_unprepare_mclk(i2s_tdm);\nerr_mclk:\n\tclk_disable_unprepare(i2s_tdm->hclk);\nerr_hclk:\n\treturn ret;\n}\n\nstatic inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)\n{\n\treturn snd_soc_dai_get_drvdata(dai);\n}\n\n \nstatic void rockchip_snd_xfer_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\t \n\n\treset_control_assert(i2s_tdm->tx_reset);\n\treset_control_assert(i2s_tdm->rx_reset);\n\tudelay(10);\n\treset_control_deassert(i2s_tdm->tx_reset);\n\treset_control_deassert(i2s_tdm->rx_reset);\n\tudelay(10);\n}\n\nstatic void rockchip_snd_reset(struct reset_control *rc)\n{\n\treset_control_assert(rc);\n\tudelay(10);\n\treset_control_deassert(rc);\n\tudelay(10);\n}\n\nstatic void rockchip_snd_xfer_clear(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t    unsigned int clr)\n{\n\tunsigned int xfer_mask = 0;\n\tunsigned int xfer_val = 0;\n\tunsigned int val;\n\tint retry = 10;\n\tbool tx = clr & I2S_CLR_TXC;\n\tbool rx = clr & I2S_CLR_RXC;\n\n\tif (!(rx || tx))\n\t\treturn;\n\n\tif (tx) {\n\t\txfer_mask = I2S_XFER_TXS_START;\n\t\txfer_val = I2S_XFER_TXS_STOP;\n\t}\n\tif (rx) {\n\t\txfer_mask |= I2S_XFER_RXS_START;\n\t\txfer_val |= I2S_XFER_RXS_STOP;\n\t}\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_XFER, xfer_mask, xfer_val);\n\tudelay(150);\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);\n\n\tregmap_read(i2s_tdm->regmap, I2S_CLR, &val);\n\t \n\twhile (val) {\n\t\tudelay(15);\n\t\tregmap_read(i2s_tdm->regmap, I2S_CLR, &val);\n\t\tretry--;\n\t\tif (!retry) {\n\t\t\tdev_warn(i2s_tdm->dev, \"clear failed, reset %s%s\\n\",\n\t\t\t\t tx ? \"tx\" : \"\", rx ? \"rx\" : \"\");\n\t\t\tif (rx && tx)\n\t\t\t\trockchip_snd_xfer_sync_reset(i2s_tdm);\n\t\t\telse if (tx)\n\t\t\t\trockchip_snd_reset(i2s_tdm->tx_reset);\n\t\t\telse if (rx)\n\t\t\t\trockchip_snd_reset(i2s_tdm->rx_reset);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline void rockchip_enable_tde(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, I2S_DMACR, I2S_DMACR_TDE_ENABLE,\n\t\t\t   I2S_DMACR_TDE_ENABLE);\n}\n\nstatic inline void rockchip_disable_tde(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, I2S_DMACR, I2S_DMACR_TDE_ENABLE,\n\t\t\t   I2S_DMACR_TDE_DISABLE);\n}\n\nstatic inline void rockchip_enable_rde(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, I2S_DMACR, I2S_DMACR_RDE_ENABLE,\n\t\t\t   I2S_DMACR_RDE_ENABLE);\n}\n\nstatic inline void rockchip_disable_rde(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, I2S_DMACR, I2S_DMACR_RDE_ENABLE,\n\t\t\t   I2S_DMACR_RDE_DISABLE);\n}\n\n \nstatic void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai, int on)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2s_tdm->lock, flags);\n\tif (on) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trockchip_enable_tde(i2s_tdm->regmap);\n\t\telse\n\t\t\trockchip_enable_rde(i2s_tdm->regmap);\n\n\t\tif (++i2s_tdm->refcount == 1) {\n\t\t\trockchip_snd_xfer_sync_reset(i2s_tdm);\n\t\t\tregmap_update_bits(i2s_tdm->regmap, I2S_XFER,\n\t\t\t\t\t   I2S_XFER_TXS_START |\n\t\t\t\t\t   I2S_XFER_RXS_START,\n\t\t\t\t\t   I2S_XFER_TXS_START |\n\t\t\t\t\t   I2S_XFER_RXS_START);\n\t\t}\n\t} else {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trockchip_disable_tde(i2s_tdm->regmap);\n\t\telse\n\t\t\trockchip_disable_rde(i2s_tdm->regmap);\n\n\t\tif (--i2s_tdm->refcount == 0) {\n\t\t\trockchip_snd_xfer_clear(i2s_tdm,\n\t\t\t\t\t\tI2S_CLR_TXC | I2S_CLR_RXC);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&i2s_tdm->lock, flags);\n}\n\nstatic void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)\n{\n\tif (on) {\n\t\trockchip_enable_tde(i2s_tdm->regmap);\n\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_XFER,\n\t\t\t\t   I2S_XFER_TXS_START,\n\t\t\t\t   I2S_XFER_TXS_START);\n\t} else {\n\t\trockchip_disable_tde(i2s_tdm->regmap);\n\n\t\trockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);\n\t}\n}\n\nstatic void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)\n{\n\tif (on) {\n\t\trockchip_enable_rde(i2s_tdm->regmap);\n\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_XFER,\n\t\t\t\t   I2S_XFER_RXS_START,\n\t\t\t\t   I2S_XFER_RXS_START);\n\t} else {\n\t\trockchip_disable_rde(i2s_tdm->regmap);\n\n\t\trockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_RXC);\n\t}\n}\n\nstatic int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t    unsigned int fmt)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);\n\tunsigned int mask, val, tdm_val, txcr_val, rxcr_val;\n\tint ret;\n\tbool is_tdm = i2s_tdm->tdm_mode;\n\n\tret = pm_runtime_resume_and_get(cpu_dai->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tmask = I2S_CKR_MSS_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tval = I2S_CKR_MSS_MASTER;\n\t\ti2s_tdm->is_master_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tval = I2S_CKR_MSS_SLAVE;\n\t\ti2s_tdm->is_master_mode = false;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);\n\n\tmask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval = I2S_CKR_CKP_NORMAL |\n\t\t      I2S_CKR_TLP_NORMAL |\n\t\t      I2S_CKR_RLP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval = I2S_CKR_CKP_NORMAL |\n\t\t      I2S_CKR_TLP_INVERTED |\n\t\t      I2S_CKR_RLP_INVERTED;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval = I2S_CKR_CKP_INVERTED |\n\t\t      I2S_CKR_TLP_NORMAL |\n\t\t      I2S_CKR_RLP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval = I2S_CKR_CKP_INVERTED |\n\t\t      I2S_CKR_TLP_INVERTED |\n\t\t      I2S_CKR_RLP_INVERTED;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\ttxcr_val = I2S_TXCR_IBM_RSJM;\n\t\trxcr_val = I2S_RXCR_IBM_RSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ttxcr_val = I2S_TXCR_IBM_LSJM;\n\t\trxcr_val = I2S_RXCR_IBM_LSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\ttxcr_val = I2S_TXCR_IBM_NORMAL;\n\t\trxcr_val = I2S_RXCR_IBM_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:  \n\t\ttxcr_val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);\n\t\trxcr_val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:  \n\t\ttxcr_val = I2S_TXCR_TFS_PCM;\n\t\trxcr_val = I2S_RXCR_TFS_PCM;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tmask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;\n\tregmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, txcr_val);\n\n\tmask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;\n\tregmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, rxcr_val);\n\n\tif (is_tdm) {\n\t\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tval = I2S_TXCR_TFS_TDM_I2S;\n\t\t\ttdm_val = TDM_SHIFT_CTRL(2);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tval = I2S_TXCR_TFS_TDM_I2S;\n\t\t\ttdm_val = TDM_SHIFT_CTRL(1);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tval = I2S_TXCR_TFS_TDM_I2S;\n\t\t\ttdm_val = TDM_SHIFT_CTRL(0);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t\tval = I2S_TXCR_TFS_TDM_PCM;\n\t\t\ttdm_val = TDM_SHIFT_CTRL(0);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\tval = I2S_TXCR_TFS_TDM_PCM;\n\t\t\ttdm_val = TDM_SHIFT_CTRL(2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_pm_put;\n\t\t}\n\n\t\ttdm_val |= TDM_FSYNC_WIDTH_SEL1(1);\n\t\ttdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;\n\n\t\tmask = I2S_TXCR_TFS_MASK;\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);\n\n\t\tmask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |\n\t\t       TDM_SHIFT_CTRL_MSK;\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,\n\t\t\t\t   mask, tdm_val);\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,\n\t\t\t\t   mask, tdm_val);\n\t}\n\nerr_pm_put:\n\tpm_runtime_put(cpu_dai->dev);\n\n\treturn ret;\n}\n\nstatic void rockchip_i2s_tdm_xfer_pause(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tint stream;\n\n\tstream = SNDRV_PCM_STREAM_LAST - substream->stream;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\trockchip_disable_tde(i2s_tdm->regmap);\n\telse\n\t\trockchip_disable_rde(i2s_tdm->regmap);\n\n\trockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC | I2S_CLR_RXC);\n}\n\nstatic void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tint stream;\n\n\tstream = SNDRV_PCM_STREAM_LAST - substream->stream;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\trockchip_enable_tde(i2s_tdm->regmap);\n\telse\n\t\trockchip_enable_rde(i2s_tdm->regmap);\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_XFER,\n\t\t\t   I2S_XFER_TXS_START |\n\t\t\t   I2S_XFER_RXS_START,\n\t\t\t   I2S_XFER_TXS_START |\n\t\t\t   I2S_XFER_RXS_START);\n}\n\nstatic int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t struct clk *clk, unsigned long rate,\n\t\t\t\t\t int ppm)\n{\n\tunsigned long rate_target;\n\tint delta, ret;\n\n\tif (ppm == i2s_tdm->clk_ppm)\n\t\treturn 0;\n\n\tif (ppm < 0)\n\t\tdelta = -1;\n\telse\n\t\tdelta = 1;\n\n\tdelta *= (int)div64_u64((u64)rate * (u64)abs(ppm) + 500000,\n\t\t\t\t1000000);\n\n\trate_target = rate + delta;\n\n\tif (!rate_target)\n\t\treturn -EINVAL;\n\n\tret = clk_set_rate(clk, rate_target);\n\tif (ret)\n\t\treturn ret;\n\n\ti2s_tdm->clk_ppm = ppm;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t\t   unsigned int lrck_freq)\n{\n\tstruct clk *mclk_root;\n\tstruct clk *mclk_parent;\n\tunsigned int mclk_root_freq;\n\tunsigned int mclk_root_initial_freq;\n\tunsigned int mclk_parent_freq;\n\tunsigned int div, delta;\n\tu64 ppm;\n\tint ret;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmclk_parent = i2s_tdm->mclk_tx_src;\n\telse\n\t\tmclk_parent = i2s_tdm->mclk_rx_src;\n\n\tswitch (lrck_freq) {\n\tcase 8000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\tcase 64000:\n\tcase 96000:\n\tcase 192000:\n\t\tmclk_root = i2s_tdm->mclk_root0;\n\t\tmclk_root_freq = i2s_tdm->mclk_root0_freq;\n\t\tmclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;\n\t\tmclk_parent_freq = DEFAULT_MCLK_FS * 192000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\tcase 176400:\n\t\tmclk_root = i2s_tdm->mclk_root1;\n\t\tmclk_root_freq = i2s_tdm->mclk_root1_freq;\n\t\tmclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;\n\t\tmclk_parent_freq = DEFAULT_MCLK_FS * 176400;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(i2s_tdm->dev, \"Invalid LRCK frequency: %u Hz\\n\",\n\t\t\tlrck_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_parent(mclk_parent, mclk_root);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,\n\t\t\t\t\t    mclk_root_freq, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdelta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);\n\tppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);\n\n\tif (ppm) {\n\t\tdiv = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);\n\t\tif (!div)\n\t\t\treturn -EINVAL;\n\n\t\tmclk_root_freq = mclk_parent_freq * round_up(div, 2);\n\n\t\tret = clk_set_rate(mclk_root, mclk_root_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ti2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);\n\t\ti2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);\n\t}\n\n\treturn clk_set_rate(mclk_parent, mclk_parent_freq);\n}\n\nstatic int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t\t     struct clk **mclk)\n{\n\tunsigned int mclk_freq;\n\tint ret;\n\n\tif (i2s_tdm->clk_trcm) {\n\t\tif (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {\n\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\"clk_trcm, tx: %d and rx: %d should be the same\\n\",\n\t\t\t\ti2s_tdm->mclk_tx_freq,\n\t\t\t\ti2s_tdm->mclk_rx_freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\t*mclk = i2s_tdm->mclk_tx;\n\t} else {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t*mclk = i2s_tdm->mclk_tx;\n\t\t\tmclk_freq = i2s_tdm->mclk_tx_freq;\n\t\t} else {\n\t\t\t*mclk = i2s_tdm->mclk_rx;\n\t\t\tmclk_freq = i2s_tdm->mclk_rx_freq;\n\t\t}\n\n\t\tret = clk_set_rate(*mclk, mclk_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_ch_to_io(unsigned int ch, bool substream_capture)\n{\n\tif (substream_capture) {\n\t\tswitch (ch) {\n\t\tcase I2S_CHN_4:\n\t\t\treturn I2S_IO_6CH_OUT_4CH_IN;\n\t\tcase I2S_CHN_6:\n\t\t\treturn I2S_IO_4CH_OUT_6CH_IN;\n\t\tcase I2S_CHN_8:\n\t\t\treturn I2S_IO_2CH_OUT_8CH_IN;\n\t\tdefault:\n\t\t\treturn I2S_IO_8CH_OUT_2CH_IN;\n\t\t}\n\t} else {\n\t\tswitch (ch) {\n\t\tcase I2S_CHN_4:\n\t\t\treturn I2S_IO_4CH_OUT_6CH_IN;\n\t\tcase I2S_CHN_6:\n\t\t\treturn I2S_IO_6CH_OUT_4CH_IN;\n\t\tcase I2S_CHN_8:\n\t\t\treturn I2S_IO_8CH_OUT_2CH_IN;\n\t\tdefault:\n\t\t\treturn I2S_IO_2CH_OUT_8CH_IN;\n\t\t}\n\t}\n}\n\nstatic int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);\n\tint usable_chs = MULTIPLEX_CH_MAX;\n\tunsigned int val = 0;\n\n\tif (!i2s_tdm->io_multiplex)\n\t\treturn 0;\n\n\tif (IS_ERR_OR_NULL(i2s_tdm->grf)) {\n\t\tdev_err(i2s_tdm->dev,\n\t\t\t\"io multiplex not supported for this device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tstruct snd_pcm_str *playback_str =\n\t\t\t&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\n\t\tif (playback_str->substream_opened) {\n\t\t\tregmap_read(i2s_tdm->regmap, I2S_TXCR, &val);\n\t\t\tval &= I2S_TXCR_CSR_MASK;\n\t\t\tusable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);\n\t\t}\n\n\t\tregmap_read(i2s_tdm->regmap, I2S_RXCR, &val);\n\t\tval &= I2S_RXCR_CSR_MASK;\n\n\t\tif (to_ch_num(val) > usable_chs) {\n\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\"Capture channels (%d) > usable channels (%d)\\n\",\n\t\t\t\tto_ch_num(val), usable_chs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trockchip_i2s_ch_to_io(val, true);\n\t} else {\n\t\tstruct snd_pcm_str *capture_str =\n\t\t\t&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];\n\n\t\tif (capture_str->substream_opened) {\n\t\t\tregmap_read(i2s_tdm->regmap, I2S_RXCR, &val);\n\t\t\tval &= I2S_RXCR_CSR_MASK;\n\t\t\tusable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);\n\t\t}\n\n\t\tregmap_read(i2s_tdm->regmap, I2S_TXCR, &val);\n\t\tval &= I2S_TXCR_CSR_MASK;\n\n\t\tif (to_ch_num(val) > usable_chs) {\n\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\"Playback channels (%d) > usable channels (%d)\\n\",\n\t\t\t\tto_ch_num(val), usable_chs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tval <<= i2s_tdm->soc_data->grf_shift;\n\tval |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;\n\tregmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_trcm_mode(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai,\n\t\t\t\t  unsigned int div_bclk,\n\t\t\t\t  unsigned int div_lrck,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);\n\tunsigned long flags;\n\n\tif (!i2s_tdm->clk_trcm)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&i2s_tdm->lock, flags);\n\tif (i2s_tdm->refcount)\n\t\trockchip_i2s_tdm_xfer_pause(substream, i2s_tdm);\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,\n\t\t\t   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,\n\t\t\t   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR,\n\t\t\t   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,\n\t\t\t   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TXCR,\n\t\t\t\t   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,\n\t\t\t\t   fmt);\n\telse\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_RXCR,\n\t\t\t\t   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,\n\t\t\t\t   fmt);\n\n\tif (i2s_tdm->refcount)\n\t\trockchip_i2s_tdm_xfer_resume(substream, i2s_tdm);\n\tspin_unlock_irqrestore(&i2s_tdm->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);\n\tstruct clk *mclk;\n\tint ret = 0;\n\tunsigned int val = 0;\n\tunsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;\n\n\tif (i2s_tdm->is_master_mode) {\n\t\tif (i2s_tdm->mclk_calibrate)\n\t\t\trockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,\n\t\t\t\t\t\t\tparams_rate(params));\n\n\t\tret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmclk_rate = clk_get_rate(mclk);\n\t\tbclk_rate = i2s_tdm->frame_width * params_rate(params);\n\t\tif (!bclk_rate)\n\t\t\treturn -EINVAL;\n\n\t\tdiv_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);\n\t\tdiv_lrck = bclk_rate / params_rate(params);\n\t}\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tval |= I2S_TXCR_VDW(8);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tval |= I2S_TXCR_VDW(16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tval |= I2S_TXCR_VDW(20);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tval |= I2S_TXCR_VDW(24);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval |= I2S_TXCR_VDW(32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 8:\n\t\tval |= I2S_CHN_8;\n\t\tbreak;\n\tcase 6:\n\t\tval |= I2S_CHN_6;\n\t\tbreak;\n\tcase 4:\n\t\tval |= I2S_CHN_4;\n\t\tbreak;\n\tcase 2:\n\t\tval |= I2S_CHN_2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (i2s_tdm->clk_trcm) {\n\t\trockchip_i2s_trcm_mode(substream, dai, div_bclk, div_lrck, val);\n\t} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,\n\t\t\t\t   I2S_CLKDIV_TXM_MASK,\n\t\t\t\t   I2S_CLKDIV_TXM(div_bclk));\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR,\n\t\t\t\t   I2S_CKR_TSD_MASK,\n\t\t\t\t   I2S_CKR_TSD(div_lrck));\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TXCR,\n\t\t\t\t   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,\n\t\t\t\t   val);\n\t} else {\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,\n\t\t\t\t   I2S_CLKDIV_RXM_MASK,\n\t\t\t\t   I2S_CLKDIV_RXM(div_bclk));\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR,\n\t\t\t\t   I2S_CKR_RSD_MASK,\n\t\t\t\t   I2S_CKR_RSD(div_lrck));\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_RXCR,\n\t\t\t\t   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,\n\t\t\t\t   val);\n\t}\n\n\treturn rockchip_i2s_io_multiplex(substream, dai);\n}\n\nstatic int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd, struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (i2s_tdm->clk_trcm)\n\t\t\trockchip_snd_txrxctrl(substream, dai, 1);\n\t\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\trockchip_snd_rxctrl(i2s_tdm, 1);\n\t\telse\n\t\t\trockchip_snd_txctrl(i2s_tdm, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (i2s_tdm->clk_trcm)\n\t\t\trockchip_snd_txrxctrl(substream, dai, 0);\n\t\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\trockchip_snd_rxctrl(i2s_tdm, 0);\n\t\telse\n\t\t\trockchip_snd_txctrl(i2s_tdm, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,\n\t\t\t\t       unsigned int freq, int dir)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);\n\n\t \n\tif (i2s_tdm->clk_trcm) {\n\t\ti2s_tdm->mclk_tx_freq = freq;\n\t\ti2s_tdm->mclk_rx_freq = freq;\n\t} else {\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ti2s_tdm->mclk_tx_freq = freq;\n\t\telse\n\t\t\ti2s_tdm->mclk_rx_freq = freq;\n\t}\n\n\tdev_dbg(i2s_tdm->dev, \"The target mclk_%s freq is: %d\\n\",\n\t\tstream ? \"rx\" : \"tx\", freq);\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = CLK_PPM_MIN;\n\tuinfo->value.integer.max = CLK_PPM_MAX;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);\n\n\tucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0, ppm = 0;\n\tint changed = 0;\n\tunsigned long old_rate;\n\n\tif (ucontrol->value.integer.value[0] < CLK_PPM_MIN ||\n\t    ucontrol->value.integer.value[0] > CLK_PPM_MAX)\n\t\treturn -EINVAL;\n\n\tppm = ucontrol->value.integer.value[0];\n\n\told_rate = clk_get_rate(i2s_tdm->mclk_root0);\n\tret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,\n\t\t\t\t\t    i2s_tdm->mclk_root0_freq, ppm);\n\tif (ret)\n\t\treturn ret;\n\tif (old_rate != clk_get_rate(i2s_tdm->mclk_root0))\n\t\tchanged = 1;\n\n\tif (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))\n\t\treturn changed;\n\n\told_rate = clk_get_rate(i2s_tdm->mclk_root1);\n\tret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,\n\t\t\t\t\t    i2s_tdm->mclk_root1_freq, ppm);\n\tif (ret)\n\t\treturn ret;\n\tif (old_rate != clk_get_rate(i2s_tdm->mclk_root1))\n\t\tchanged = 1;\n\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"PCM Clock Compensation in PPM\",\n\t.info = rockchip_i2s_tdm_clk_compensation_info,\n\t.get = rockchip_i2s_tdm_clk_compensation_get,\n\t.put = rockchip_i2s_tdm_clk_compensation_put,\n};\n\nstatic int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);\n\n\tif (i2s_tdm->has_capture)\n\t\tsnd_soc_dai_dma_data_set_capture(dai,  &i2s_tdm->capture_dma_data);\n\tif (i2s_tdm->has_playback)\n\t\tsnd_soc_dai_dma_data_set_playback(dai, &i2s_tdm->playback_dma_data);\n\n\tif (i2s_tdm->mclk_calibrate)\n\t\tsnd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);\n\n\treturn 0;\n}\n\nstatic int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t int slots, int slot_width)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);\n\tunsigned int mask, val;\n\n\ti2s_tdm->tdm_mode = true;\n\ti2s_tdm->frame_width = slots * slot_width;\n\tmask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;\n\tval = TDM_SLOT_BIT_WIDTH(slot_width) |\n\t      TDM_FRAME_WIDTH(slots * slot_width);\n\tregmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,\n\t\t\t   mask, val);\n\tregmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,\n\t\t\t   mask, val);\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_set_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t\t   unsigned int ratio)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);\n\n\tif (ratio < 32 || ratio > 512 || ratio % 2 == 1)\n\t\treturn -EINVAL;\n\n\ti2s_tdm->frame_width = ratio;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {\n\t.probe = rockchip_i2s_tdm_dai_probe,\n\t.hw_params = rockchip_i2s_tdm_hw_params,\n\t.set_bclk_ratio\t= rockchip_i2s_tdm_set_bclk_ratio,\n\t.set_sysclk = rockchip_i2s_tdm_set_sysclk,\n\t.set_fmt = rockchip_i2s_tdm_set_fmt,\n\t.set_tdm_slot = rockchip_dai_tdm_slot,\n\t.trigger = rockchip_i2s_tdm_trigger,\n};\n\nstatic const struct snd_soc_component_driver rockchip_i2s_tdm_component = {\n\t.name = DRV_NAME,\n\t.legacy_dai_naming = 1,\n};\n\nstatic bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TXCR:\n\tcase I2S_RXCR:\n\tcase I2S_CKR:\n\tcase I2S_DMACR:\n\tcase I2S_INTCR:\n\tcase I2S_XFER:\n\tcase I2S_CLR:\n\tcase I2S_TXDR:\n\tcase I2S_TDM_TXCR:\n\tcase I2S_TDM_RXCR:\n\tcase I2S_CLKDIV:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TXCR:\n\tcase I2S_RXCR:\n\tcase I2S_CKR:\n\tcase I2S_DMACR:\n\tcase I2S_INTCR:\n\tcase I2S_XFER:\n\tcase I2S_CLR:\n\tcase I2S_TXDR:\n\tcase I2S_RXDR:\n\tcase I2S_TXFIFOLR:\n\tcase I2S_INTSR:\n\tcase I2S_RXFIFOLR:\n\tcase I2S_TDM_TXCR:\n\tcase I2S_TDM_RXCR:\n\tcase I2S_CLKDIV:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TXFIFOLR:\n\tcase I2S_INTSR:\n\tcase I2S_CLR:\n\tcase I2S_TXDR:\n\tcase I2S_RXDR:\n\tcase I2S_RXFIFOLR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == I2S_RXDR)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {\n\t{0x00, 0x7200000f},\n\t{0x04, 0x01c8000f},\n\t{0x08, 0x00001f1f},\n\t{0x10, 0x001f0000},\n\t{0x14, 0x01f00000},\n\t{0x30, 0x00003eff},\n\t{0x34, 0x00003eff},\n\t{0x38, 0x00000707},\n};\n\nstatic const struct regmap_config rockchip_i2s_tdm_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = I2S_CLKDIV,\n\t.reg_defaults = rockchip_i2s_tdm_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),\n\t.writeable_reg = rockchip_i2s_tdm_wr_reg,\n\t.readable_reg = rockchip_i2s_tdm_rd_reg,\n\t.volatile_reg = rockchip_i2s_tdm_volatile_reg,\n\t.precious_reg = rockchip_i2s_tdm_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int common_soc_init(struct device *dev, u32 addr)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);\n\tconst struct txrx_config *configs = i2s_tdm->soc_data->configs;\n\tu32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;\n\tint i;\n\n\tif (trcm == TRCM_TXRX)\n\t\treturn 0;\n\n\tif (IS_ERR_OR_NULL(i2s_tdm->grf)) {\n\t\tdev_err(i2s_tdm->dev,\n\t\t\t\"no grf present but non-txrx TRCM specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < i2s_tdm->soc_data->config_count; i++) {\n\t\tif (addr != configs[i].addr)\n\t\t\tcontinue;\n\t\treg = configs[i].reg;\n\t\tif (trcm == TRCM_TX)\n\t\t\tval = configs[i].txonly;\n\t\telse\n\t\t\tval = configs[i].rxonly;\n\n\t\tif (reg)\n\t\t\tregmap_write(i2s_tdm->grf, reg, val);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct txrx_config px30_txrx_config[] = {\n\t{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },\n};\n\nstatic const struct txrx_config rk1808_txrx_config[] = {\n\t{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },\n};\n\nstatic const struct txrx_config rk3308_txrx_config[] = {\n\t{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },\n\t{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },\n};\n\nstatic const struct txrx_config rk3568_txrx_config[] = {\n\t{ 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },\n\t{ 0xfe410000, 0x508, RK3568_I2S1_MCLK_TX_OE, RK3568_I2S1_MCLK_RX_OE },\n\t{ 0xfe420000, 0x508, RK3568_I2S2_MCLK_OE, RK3568_I2S2_MCLK_OE },\n\t{ 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },\n\t{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },\n\t{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_OE, RK3568_I2S3_MCLK_OE },\n};\n\nstatic const struct txrx_config rv1126_txrx_config[] = {\n\t{ 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },\n};\n\nstatic struct rk_i2s_soc_data px30_i2s_soc_data = {\n\t.softrst_offset = 0x0300,\n\t.configs = px30_txrx_config,\n\t.config_count = ARRAY_SIZE(px30_txrx_config),\n\t.init = common_soc_init,\n};\n\nstatic struct rk_i2s_soc_data rk1808_i2s_soc_data = {\n\t.softrst_offset = 0x0300,\n\t.configs = rk1808_txrx_config,\n\t.config_count = ARRAY_SIZE(rk1808_txrx_config),\n\t.init = common_soc_init,\n};\n\nstatic struct rk_i2s_soc_data rk3308_i2s_soc_data = {\n\t.softrst_offset = 0x0400,\n\t.grf_reg_offset = 0x0308,\n\t.grf_shift = 5,\n\t.configs = rk3308_txrx_config,\n\t.config_count = ARRAY_SIZE(rk3308_txrx_config),\n\t.init = common_soc_init,\n};\n\nstatic struct rk_i2s_soc_data rk3568_i2s_soc_data = {\n\t.softrst_offset = 0x0400,\n\t.configs = rk3568_txrx_config,\n\t.config_count = ARRAY_SIZE(rk3568_txrx_config),\n\t.init = common_soc_init,\n};\n\nstatic struct rk_i2s_soc_data rv1126_i2s_soc_data = {\n\t.softrst_offset = 0x0300,\n\t.configs = rv1126_txrx_config,\n\t.config_count = ARRAY_SIZE(rv1126_txrx_config),\n\t.init = common_soc_init,\n};\n\nstatic const struct of_device_id rockchip_i2s_tdm_match[] = {\n\t{ .compatible = \"rockchip,px30-i2s-tdm\", .data = &px30_i2s_soc_data },\n\t{ .compatible = \"rockchip,rk1808-i2s-tdm\", .data = &rk1808_i2s_soc_data },\n\t{ .compatible = \"rockchip,rk3308-i2s-tdm\", .data = &rk3308_i2s_soc_data },\n\t{ .compatible = \"rockchip,rk3568-i2s-tdm\", .data = &rk3568_i2s_soc_data },\n\t{ .compatible = \"rockchip,rk3588-i2s-tdm\" },\n\t{ .compatible = \"rockchip,rv1126-i2s-tdm\", .data = &rv1126_i2s_soc_data },\n\t{},\n};\n\nstatic const struct snd_soc_dai_driver i2s_tdm_dai = {\n\t.ops = &rockchip_i2s_tdm_dai_ops,\n};\n\nstatic int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tstruct snd_soc_dai_driver *dai;\n\tstruct property *dma_names;\n\tconst char *dma_name;\n\tu64 formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t       SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t       SNDRV_PCM_FMTBIT_S32_LE);\n\tstruct device_node *node = i2s_tdm->dev->of_node;\n\n\tof_property_for_each_string(node, \"dma-names\", dma_names, dma_name) {\n\t\tif (!strcmp(dma_name, \"tx\"))\n\t\t\ti2s_tdm->has_playback = true;\n\t\tif (!strcmp(dma_name, \"rx\"))\n\t\t\ti2s_tdm->has_capture = true;\n\t}\n\n\tdai = devm_kmemdup(i2s_tdm->dev, &i2s_tdm_dai,\n\t\t\t   sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tif (i2s_tdm->has_playback) {\n\t\tdai->playback.stream_name  = \"Playback\";\n\t\tdai->playback.channels_min = 2;\n\t\tdai->playback.channels_max = 8;\n\t\tdai->playback.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tdai->playback.formats = formats;\n\t}\n\n\tif (i2s_tdm->has_capture) {\n\t\tdai->capture.stream_name  = \"Capture\";\n\t\tdai->capture.channels_min = 2;\n\t\tdai->capture.channels_max = 8;\n\t\tdai->capture.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tdai->capture.formats = formats;\n\t}\n\n\tif (i2s_tdm->clk_trcm != TRCM_TXRX)\n\t\tdai->symmetric_rate = 1;\n\n\ti2s_tdm->dai = dai;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t       int num,\n\t\t\t\t       bool is_rx_path)\n{\n\tunsigned int *i2s_data;\n\tint i, j;\n\n\tif (is_rx_path)\n\t\ti2s_data = i2s_tdm->i2s_sdis;\n\telse\n\t\ti2s_data = i2s_tdm->i2s_sdos;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (i2s_data[i] > CH_GRP_MAX - 1) {\n\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\"%s path i2s_data[%d]: %d is too high, max is: %d\\n\",\n\t\t\t\tis_rx_path ? \"RX\" : \"TX\",\n\t\t\t\ti, i2s_data[i], CH_GRP_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\tif (i2s_data[i] == i2s_data[j]) {\n\t\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\t\"%s path invalid routed i2s_data: [%d]%d == [%d]%d\\n\",\n\t\t\t\t\tis_rx_path ? \"RX\" : \"TX\",\n\t\t\t\t\ti, i2s_data[i],\n\t\t\t\t\tj, i2s_data[j]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t    int num)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < num; idx++) {\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_TXCR,\n\t\t\t\t   I2S_TXCR_PATH_MASK(idx),\n\t\t\t\t   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));\n\t}\n}\n\nstatic void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t    int num)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < num; idx++) {\n\t\tregmap_update_bits(i2s_tdm->regmap, I2S_RXCR,\n\t\t\t\t   I2S_RXCR_PATH_MASK(idx),\n\t\t\t\t   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));\n\t}\n}\n\nstatic void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t int num, bool is_rx_path)\n{\n\tif (is_rx_path)\n\t\trockchip_i2s_tdm_rx_path_config(i2s_tdm, num);\n\telse\n\t\trockchip_i2s_tdm_tx_path_config(i2s_tdm, num);\n}\n\nstatic int rockchip_i2s_tdm_get_calibrate_mclks(struct rk_i2s_tdm_dev *i2s_tdm)\n{\n\tint num_mclks = 0;\n\n\ti2s_tdm->mclk_tx_src = devm_clk_get(i2s_tdm->dev, \"mclk_tx_src\");\n\tif (!IS_ERR(i2s_tdm->mclk_tx_src))\n\t\tnum_mclks++;\n\n\ti2s_tdm->mclk_rx_src = devm_clk_get(i2s_tdm->dev, \"mclk_rx_src\");\n\tif (!IS_ERR(i2s_tdm->mclk_rx_src))\n\t\tnum_mclks++;\n\n\ti2s_tdm->mclk_root0 = devm_clk_get(i2s_tdm->dev, \"mclk_root0\");\n\tif (!IS_ERR(i2s_tdm->mclk_root0))\n\t\tnum_mclks++;\n\n\ti2s_tdm->mclk_root1 = devm_clk_get(i2s_tdm->dev, \"mclk_root1\");\n\tif (!IS_ERR(i2s_tdm->mclk_root1))\n\t\tnum_mclks++;\n\n\tif (num_mclks < 4 && num_mclks != 0)\n\t\treturn -ENOENT;\n\n\tif (num_mclks == 4)\n\t\ti2s_tdm->mclk_calibrate = 1;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t bool is_rx_path)\n{\n\tchar *i2s_tx_path_prop = \"rockchip,i2s-tx-route\";\n\tchar *i2s_rx_path_prop = \"rockchip,i2s-rx-route\";\n\tchar *i2s_path_prop;\n\tunsigned int *i2s_data;\n\tint num, ret = 0;\n\n\tif (is_rx_path) {\n\t\ti2s_path_prop = i2s_rx_path_prop;\n\t\ti2s_data = i2s_tdm->i2s_sdis;\n\t} else {\n\t\ti2s_path_prop = i2s_tx_path_prop;\n\t\ti2s_data = i2s_tdm->i2s_sdos;\n\t}\n\n\tnum = of_count_phandle_with_args(np, i2s_path_prop, NULL);\n\tif (num < 0) {\n\t\tif (num != -ENOENT) {\n\t\t\tdev_err(i2s_tdm->dev,\n\t\t\t\t\"Failed to read '%s' num: %d\\n\",\n\t\t\t\ti2s_path_prop, num);\n\t\t\tret = num;\n\t\t}\n\t\treturn ret;\n\t} else if (num != CH_GRP_MAX) {\n\t\tdev_err(i2s_tdm->dev,\n\t\t\t\"The num: %d should be: %d\\n\", num, CH_GRP_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_array(np, i2s_path_prop,\n\t\t\t\t\t i2s_data, num);\n\tif (ret < 0) {\n\t\tdev_err(i2s_tdm->dev,\n\t\t\t\"Failed to read '%s': %d\\n\",\n\t\t\ti2s_path_prop, ret);\n\t\treturn ret;\n\t}\n\n\tret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);\n\tif (ret < 0) {\n\t\tdev_err(i2s_tdm->dev,\n\t\t\t\"Failed to check i2s data bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t    struct device_node *np)\n{\n\treturn rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);\n}\n\nstatic int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,\n\t\t\t\t\t    struct device_node *np)\n{\n\treturn rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);\n}\n\nstatic int rockchip_i2s_tdm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tstruct rk_i2s_tdm_dev *i2s_tdm;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint ret;\n\n\ti2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);\n\tif (!i2s_tdm)\n\t\treturn -ENOMEM;\n\n\ti2s_tdm->dev = &pdev->dev;\n\n\tof_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&i2s_tdm->lock);\n\ti2s_tdm->soc_data = (struct rk_i2s_soc_data *)of_id->data;\n\n\ti2s_tdm->frame_width = 64;\n\n\ti2s_tdm->clk_trcm = TRCM_TXRX;\n\tif (of_property_read_bool(node, \"rockchip,trcm-sync-tx-only\"))\n\t\ti2s_tdm->clk_trcm = TRCM_TX;\n\tif (of_property_read_bool(node, \"rockchip,trcm-sync-rx-only\")) {\n\t\tif (i2s_tdm->clk_trcm) {\n\t\t\tdev_err(i2s_tdm->dev, \"invalid trcm-sync configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti2s_tdm->clk_trcm = TRCM_RX;\n\t}\n\n\tret = rockchip_i2s_tdm_init_dai(i2s_tdm);\n\tif (ret)\n\t\treturn ret;\n\n\ti2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, \"rockchip,grf\");\n\ti2s_tdm->tx_reset = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t      \"tx-m\");\n\tif (IS_ERR(i2s_tdm->tx_reset)) {\n\t\tret = PTR_ERR(i2s_tdm->tx_reset);\n\t\treturn dev_err_probe(i2s_tdm->dev, ret,\n\t\t\t\t     \"Error in tx-m reset control\\n\");\n\t}\n\n\ti2s_tdm->rx_reset = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t      \"rx-m\");\n\tif (IS_ERR(i2s_tdm->rx_reset)) {\n\t\tret = PTR_ERR(i2s_tdm->rx_reset);\n\t\treturn dev_err_probe(i2s_tdm->dev, ret,\n\t\t\t\t     \"Error in rx-m reset control\\n\");\n\t}\n\n\ti2s_tdm->hclk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(i2s_tdm->hclk)) {\n\t\treturn dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->hclk),\n\t\t\t\t     \"Failed to get clock hclk\\n\");\n\t}\n\n\ti2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, \"mclk_tx\");\n\tif (IS_ERR(i2s_tdm->mclk_tx)) {\n\t\treturn dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_tx),\n\t\t\t\t     \"Failed to get clock mclk_tx\\n\");\n\t}\n\n\ti2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, \"mclk_rx\");\n\tif (IS_ERR(i2s_tdm->mclk_rx)) {\n\t\treturn dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_rx),\n\t\t\t\t     \"Failed to get clock mclk_rx\\n\");\n\t}\n\n\ti2s_tdm->io_multiplex =\n\t\tof_property_read_bool(node, \"rockchip,io-multiplex\");\n\n\tret = rockchip_i2s_tdm_get_calibrate_mclks(i2s_tdm);\n\tif (ret)\n\t\treturn dev_err_probe(i2s_tdm->dev, ret,\n\t\t\t\t     \"mclk-calibrate clocks missing\");\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs)) {\n\t\treturn dev_err_probe(i2s_tdm->dev, PTR_ERR(regs),\n\t\t\t\t     \"Failed to get resource IORESOURCE_MEM\\n\");\n\t}\n\n\ti2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t\t&rockchip_i2s_tdm_regmap_config);\n\tif (IS_ERR(i2s_tdm->regmap)) {\n\t\treturn dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->regmap),\n\t\t\t\t     \"Failed to initialise regmap\\n\");\n\t}\n\n\tif (i2s_tdm->has_playback) {\n\t\ti2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;\n\t\ti2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\ti2s_tdm->playback_dma_data.maxburst = 8;\n\t}\n\n\tif (i2s_tdm->has_capture) {\n\t\ti2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;\n\t\ti2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\ti2s_tdm->capture_dma_data.maxburst = 8;\n\t}\n\n\tret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"I2S TX path prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"I2S RX path prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, i2s_tdm);\n\n\tret = clk_prepare_enable(i2s_tdm->hclk);\n\tif (ret) {\n\t\treturn dev_err_probe(i2s_tdm->dev, ret,\n\t\t\t\t     \"Failed to enable clock hclk\\n\");\n\t}\n\n\tret = i2s_tdm_prepare_enable_mclk(i2s_tdm);\n\tif (ret) {\n\t\tret = dev_err_probe(i2s_tdm->dev, ret,\n\t\t\t\t    \"Failed to enable one or more mclks\\n\");\n\t\tgoto err_disable_hclk;\n\t}\n\n\tif (i2s_tdm->mclk_calibrate) {\n\t\ti2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);\n\t\ti2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);\n\t\ti2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;\n\t\ti2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tregmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,\n\t\t\t   I2S_DMACR_TDL(16));\n\tregmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,\n\t\t\t   I2S_DMACR_RDL(16));\n\tregmap_update_bits(i2s_tdm->regmap, I2S_CKR, I2S_CKR_TRCM_MASK,\n\t\t\t   i2s_tdm->clk_trcm << I2S_CKR_TRCM_SHIFT);\n\n\tif (i2s_tdm->soc_data && i2s_tdm->soc_data->init)\n\t\ti2s_tdm->soc_data->init(&pdev->dev, res->start);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &rockchip_i2s_tdm_component,\n\t\t\t\t\t      i2s_tdm->dai, 1);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register DAI\\n\");\n\t\tgoto err_suspend;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register PCM\\n\");\n\t\tgoto err_suspend;\n\t}\n\n\treturn 0;\n\nerr_suspend:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ti2s_tdm_runtime_suspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\nerr_disable_hclk:\n\tclk_disable_unprepare(i2s_tdm->hclk);\n\n\treturn ret;\n}\n\nstatic int rockchip_i2s_tdm_remove(struct platform_device *pdev)\n{\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ti2s_tdm_runtime_suspend(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rockchip_i2s_tdm_suspend(struct device *dev)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);\n\n\tregcache_mark_dirty(i2s_tdm->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rockchip_i2s_tdm_resume(struct device *dev)\n{\n\tstruct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regcache_sync(i2s_tdm->regmap);\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,\n\t\t\t\trockchip_i2s_tdm_resume)\n};\n\nstatic struct platform_driver rockchip_i2s_tdm_driver = {\n\t.probe = rockchip_i2s_tdm_probe,\n\t.remove = rockchip_i2s_tdm_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),\n\t\t.pm = &rockchip_i2s_tdm_pm_ops,\n\t},\n};\nmodule_platform_driver(rockchip_i2s_tdm_driver);\n\nMODULE_DESCRIPTION(\"ROCKCHIP I2S/TDM ASoC Interface\");\nMODULE_AUTHOR(\"Sugar Zhang <sugar.zhang@rock-chips.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}