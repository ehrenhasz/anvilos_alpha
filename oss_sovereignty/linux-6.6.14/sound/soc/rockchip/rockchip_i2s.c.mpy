{
  "module_name": "rockchip_i2s.c",
  "hash_id": "cf6e455e6d9889bf20e48830acac1eb9f5856fc74efb386bf65c623231668b29",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/rockchip/rockchip_i2s.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/of_device.h>\n#include <linux/clk.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <sound/pcm_params.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"rockchip_i2s.h\"\n\n#define DRV_NAME \"rockchip-i2s\"\n\nstruct rk_i2s_pins {\n\tu32 reg_offset;\n\tu32 shift;\n};\n\nstruct rk_i2s_dev {\n\tstruct device *dev;\n\n\tstruct clk *hclk;\n\tstruct clk *mclk;\n\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tstruct snd_dmaengine_dai_dma_data playback_dma_data;\n\n\tstruct regmap *regmap;\n\tstruct regmap *grf;\n\n\tbool has_capture;\n\tbool has_playback;\n\n \n\tbool tx_start;\n\tbool rx_start;\n\tbool is_master_mode;\n\tconst struct rk_i2s_pins *pins;\n\tunsigned int bclk_ratio;\n\tspinlock_t lock;  \n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *bclk_on;\n\tstruct pinctrl_state *bclk_off;\n};\n\nstatic int i2s_pinctrl_select_bclk_on(struct rk_i2s_dev *i2s)\n{\n\tint ret = 0;\n\n\tif (!IS_ERR(i2s->pinctrl) && !IS_ERR_OR_NULL(i2s->bclk_on))\n\t\tret = pinctrl_select_state(i2s->pinctrl, i2s->bclk_on);\n\n\tif (ret)\n\t\tdev_err(i2s->dev, \"bclk enable failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int i2s_pinctrl_select_bclk_off(struct rk_i2s_dev *i2s)\n{\n\n\tint ret = 0;\n\n\tif (!IS_ERR(i2s->pinctrl) && !IS_ERR_OR_NULL(i2s->bclk_off))\n\t\tret = pinctrl_select_state(i2s->pinctrl, i2s->bclk_off);\n\n\tif (ret)\n\t\tdev_err(i2s->dev, \"bclk disable failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int i2s_runtime_suspend(struct device *dev)\n{\n\tstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s->regmap, true);\n\tclk_disable_unprepare(i2s->mclk);\n\n\treturn 0;\n}\n\nstatic int i2s_runtime_resume(struct device *dev)\n{\n\tstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(i2s->mclk);\n\tif (ret) {\n\t\tdev_err(i2s->dev, \"clock enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(i2s->regmap, false);\n\tregcache_mark_dirty(i2s->regmap);\n\n\tret = regcache_sync(i2s->regmap);\n\tif (ret)\n\t\tclk_disable_unprepare(i2s->mclk);\n\n\treturn ret;\n}\n\nstatic inline struct rk_i2s_dev *to_info(struct snd_soc_dai *dai)\n{\n\treturn snd_soc_dai_get_drvdata(dai);\n}\n\nstatic int rockchip_snd_txctrl(struct rk_i2s_dev *i2s, int on)\n{\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\tspin_lock(&i2s->lock);\n\tif (on) {\n\t\tret = regmap_update_bits(i2s->regmap, I2S_DMACR,\n\t\t\t\t\t I2S_DMACR_TDE_ENABLE,\n\t\t\t\t\t I2S_DMACR_TDE_ENABLE);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tret = regmap_update_bits(i2s->regmap, I2S_XFER,\n\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START,\n\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\ti2s->tx_start = true;\n\t} else {\n\t\ti2s->tx_start = false;\n\n\t\tret = regmap_update_bits(i2s->regmap, I2S_DMACR,\n\t\t\t\t\t I2S_DMACR_TDE_ENABLE,\n\t\t\t\t\t I2S_DMACR_TDE_DISABLE);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\n\t\tif (!i2s->rx_start) {\n\t\t\tret = regmap_update_bits(i2s->regmap, I2S_XFER,\n\t\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START,\n\t\t\t\t\t\t I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\t\t\tudelay(150);\n\t\t\tret = regmap_update_bits(i2s->regmap, I2S_CLR,\n\t\t\t\t\t\t I2S_CLR_TXC | I2S_CLR_RXC,\n\t\t\t\t\t\t I2S_CLR_TXC | I2S_CLR_RXC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\t\t      I2S_CLR,\n\t\t\t\t\t\t\t      val,\n\t\t\t\t\t\t\t      val == 0,\n\t\t\t\t\t\t\t      20,\n\t\t\t\t\t\t\t      200);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(i2s->dev, \"fail to clear: %d\\n\", ret);\n\t\t}\n\t}\nend:\n\tspin_unlock(&i2s->lock);\n\tif (ret < 0)\n\t\tdev_err(i2s->dev, \"lrclk update failed\\n\");\n\n\treturn ret;\n}\n\nstatic int rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)\n{\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\tspin_lock(&i2s->lock);\n\tif (on) {\n\t\tret = regmap_update_bits(i2s->regmap, I2S_DMACR,\n\t\t\t\t\t I2S_DMACR_RDE_ENABLE,\n\t\t\t\t\t I2S_DMACR_RDE_ENABLE);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\n\t\tret = regmap_update_bits(i2s->regmap, I2S_XFER,\n\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START,\n\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\ti2s->rx_start = true;\n\t} else {\n\t\ti2s->rx_start = false;\n\n\t\tret = regmap_update_bits(i2s->regmap, I2S_DMACR,\n\t\t\t\t\t I2S_DMACR_RDE_ENABLE,\n\t\t\t\t\t I2S_DMACR_RDE_DISABLE);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\n\t\tif (!i2s->tx_start) {\n\t\t\tret = regmap_update_bits(i2s->regmap, I2S_XFER,\n\t\t\t\t\t\t I2S_XFER_TXS_START | I2S_XFER_RXS_START,\n\t\t\t\t\t\t I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\t\t\tudelay(150);\n\t\t\tret = regmap_update_bits(i2s->regmap, I2S_CLR,\n\t\t\t\t\t\t I2S_CLR_TXC | I2S_CLR_RXC,\n\t\t\t\t\t\t I2S_CLR_TXC | I2S_CLR_RXC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto end;\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\t\t      I2S_CLR,\n\t\t\t\t\t\t\t      val,\n\t\t\t\t\t\t\t      val == 0,\n\t\t\t\t\t\t\t      20,\n\t\t\t\t\t\t\t      200);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(i2s->dev, \"fail to clear: %d\\n\", ret);\n\t\t}\n\t}\nend:\n\tspin_unlock(&i2s->lock);\n\tif (ret < 0)\n\t\tdev_err(i2s->dev, \"lrclk update failed\\n\");\n\n\treturn ret;\n}\n\nstatic int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\tunsigned int fmt)\n{\n\tstruct rk_i2s_dev *i2s = to_info(cpu_dai);\n\tunsigned int mask = 0, val = 0;\n\tint ret = 0;\n\n\tpm_runtime_get_sync(cpu_dai->dev);\n\tmask = I2S_CKR_MSS_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tval = I2S_CKR_MSS_MASTER;\n\t\ti2s->is_master_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tval = I2S_CKR_MSS_SLAVE;\n\t\ti2s->is_master_mode = false;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s->regmap, I2S_CKR, mask, val);\n\n\tmask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval = I2S_CKR_CKP_NORMAL |\n\t\t      I2S_CKR_TLP_NORMAL |\n\t\t      I2S_CKR_RLP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval = I2S_CKR_CKP_NORMAL |\n\t\t      I2S_CKR_TLP_INVERTED |\n\t\t      I2S_CKR_RLP_INVERTED;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval = I2S_CKR_CKP_INVERTED |\n\t\t      I2S_CKR_TLP_NORMAL |\n\t\t      I2S_CKR_RLP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval = I2S_CKR_CKP_INVERTED |\n\t\t      I2S_CKR_TLP_INVERTED |\n\t\t      I2S_CKR_RLP_INVERTED;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s->regmap, I2S_CKR, mask, val);\n\n\tmask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = I2S_TXCR_IBM_RSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = I2S_TXCR_IBM_LSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = I2S_TXCR_IBM_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:  \n\t\tval = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:  \n\t\tval = I2S_TXCR_TFS_PCM;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s->regmap, I2S_TXCR, mask, val);\n\n\tmask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = I2S_RXCR_IBM_RSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = I2S_RXCR_IBM_LSJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = I2S_RXCR_IBM_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:  \n\t\tval = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:  \n\t\tval = I2S_RXCR_TFS_PCM;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_pm_put;\n\t}\n\n\tregmap_update_bits(i2s->regmap, I2S_RXCR, mask, val);\n\nerr_pm_put:\n\tpm_runtime_put(cpu_dai->dev);\n\n\treturn ret;\n}\n\nstatic int rockchip_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_dev *i2s = to_info(dai);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tunsigned int val = 0;\n\tunsigned int mclk_rate, bclk_rate, div_bclk, div_lrck;\n\n\tif (i2s->is_master_mode) {\n\t\tmclk_rate = clk_get_rate(i2s->mclk);\n\t\tbclk_rate = i2s->bclk_ratio * params_rate(params);\n\t\tif (!bclk_rate)\n\t\t\treturn -EINVAL;\n\n\t\tdiv_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);\n\t\tdiv_lrck = bclk_rate / params_rate(params);\n\t\tregmap_update_bits(i2s->regmap, I2S_CKR,\n\t\t\t\t   I2S_CKR_MDIV_MASK,\n\t\t\t\t   I2S_CKR_MDIV(div_bclk));\n\n\t\tregmap_update_bits(i2s->regmap, I2S_CKR,\n\t\t\t\t   I2S_CKR_TSD_MASK |\n\t\t\t\t   I2S_CKR_RSD_MASK,\n\t\t\t\t   I2S_CKR_TSD(div_lrck) |\n\t\t\t\t   I2S_CKR_RSD(div_lrck));\n\t}\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tval |= I2S_TXCR_VDW(8);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tval |= I2S_TXCR_VDW(16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tval |= I2S_TXCR_VDW(20);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tval |= I2S_TXCR_VDW(24);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval |= I2S_TXCR_VDW(32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 8:\n\t\tval |= I2S_CHN_8;\n\t\tbreak;\n\tcase 6:\n\t\tval |= I2S_CHN_6;\n\t\tbreak;\n\tcase 4:\n\t\tval |= I2S_CHN_4;\n\t\tbreak;\n\tcase 2:\n\t\tval |= I2S_CHN_2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(i2s->dev, \"invalid channel: %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tregmap_update_bits(i2s->regmap, I2S_RXCR,\n\t\t\t\t   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,\n\t\t\t\t   val);\n\telse\n\t\tregmap_update_bits(i2s->regmap, I2S_TXCR,\n\t\t\t\t   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,\n\t\t\t\t   val);\n\n\tif (!IS_ERR(i2s->grf) && i2s->pins) {\n\t\tregmap_read(i2s->regmap, I2S_TXCR, &val);\n\t\tval &= I2S_TXCR_CSR_MASK;\n\n\t\tswitch (val) {\n\t\tcase I2S_CHN_4:\n\t\t\tval = I2S_IO_4CH_OUT_6CH_IN;\n\t\t\tbreak;\n\t\tcase I2S_CHN_6:\n\t\t\tval = I2S_IO_6CH_OUT_4CH_IN;\n\t\t\tbreak;\n\t\tcase I2S_CHN_8:\n\t\t\tval = I2S_IO_8CH_OUT_2CH_IN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = I2S_IO_2CH_OUT_8CH_IN;\n\t\t\tbreak;\n\t\t}\n\n\t\tval <<= i2s->pins->shift;\n\t\tval |= (I2S_IO_DIRECTION_MASK << i2s->pins->shift) << 16;\n\t\tregmap_write(i2s->grf, i2s->pins->reg_offset, val);\n\t}\n\n\tregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,\n\t\t\t   I2S_DMACR_TDL(16));\n\tregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,\n\t\t\t   I2S_DMACR_RDL(16));\n\n\tval = I2S_CKR_TRCM_TXRX;\n\tif (dai->driver->symmetric_rate && rtd->dai_link->symmetric_rate)\n\t\tval = I2S_CKR_TRCM_TXONLY;\n\n\tregmap_update_bits(i2s->regmap, I2S_CKR,\n\t\t\t   I2S_CKR_TRCM_MASK,\n\t\t\t   val);\n\treturn 0;\n}\n\nstatic int rockchip_i2s_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_dev *i2s = to_info(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tret = rockchip_snd_rxctrl(i2s, 1);\n\t\telse\n\t\t\tret = rockchip_snd_txctrl(i2s, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti2s_pinctrl_select_bclk_on(i2s);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tif (!i2s->tx_start)\n\t\t\t\ti2s_pinctrl_select_bclk_off(i2s);\n\t\t\tret = rockchip_snd_rxctrl(i2s, 0);\n\t\t} else {\n\t\t\tif (!i2s->rx_start)\n\t\t\t\ti2s_pinctrl_select_bclk_off(i2s);\n\t\t\tret = rockchip_snd_txctrl(i2s, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_i2s_set_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t       unsigned int ratio)\n{\n\tstruct rk_i2s_dev *i2s = to_info(dai);\n\n\ti2s->bclk_ratio = ratio;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\n\t\t\t\t   unsigned int freq, int dir)\n{\n\tstruct rk_i2s_dev *i2s = to_info(cpu_dai);\n\tint ret;\n\n\tif (freq == 0)\n\t\treturn 0;\n\n\tret = clk_set_rate(i2s->mclk, freq);\n\tif (ret)\n\t\tdev_err(i2s->dev, \"Fail to set mclk %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct rk_i2s_dev *i2s = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai,\n\t\ti2s->has_playback ? &i2s->playback_dma_data : NULL,\n\t\ti2s->has_capture  ? &i2s->capture_dma_data  : NULL);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rockchip_i2s_dai_ops = {\n\t.probe = rockchip_i2s_dai_probe,\n\t.hw_params = rockchip_i2s_hw_params,\n\t.set_bclk_ratio\t= rockchip_i2s_set_bclk_ratio,\n\t.set_sysclk = rockchip_i2s_set_sysclk,\n\t.set_fmt = rockchip_i2s_set_fmt,\n\t.trigger = rockchip_i2s_trigger,\n};\n\nstatic struct snd_soc_dai_driver rockchip_i2s_dai = {\n\t.ops = &rockchip_i2s_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver rockchip_i2s_component = {\n\t.name = DRV_NAME,\n\t.legacy_dai_naming = 1,\n};\n\nstatic bool rockchip_i2s_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TXCR:\n\tcase I2S_RXCR:\n\tcase I2S_CKR:\n\tcase I2S_DMACR:\n\tcase I2S_INTCR:\n\tcase I2S_XFER:\n\tcase I2S_CLR:\n\tcase I2S_TXDR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_TXCR:\n\tcase I2S_RXCR:\n\tcase I2S_CKR:\n\tcase I2S_DMACR:\n\tcase I2S_INTCR:\n\tcase I2S_XFER:\n\tcase I2S_CLR:\n\tcase I2S_TXDR:\n\tcase I2S_RXDR:\n\tcase I2S_FIFOLR:\n\tcase I2S_INTSR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_INTSR:\n\tcase I2S_CLR:\n\tcase I2S_FIFOLR:\n\tcase I2S_TXDR:\n\tcase I2S_RXDR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rockchip_i2s_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase I2S_RXDR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default rockchip_i2s_reg_defaults[] = {\n\t{0x00, 0x0000000f},\n\t{0x04, 0x0000000f},\n\t{0x08, 0x00071f1f},\n\t{0x10, 0x001f0000},\n\t{0x14, 0x01f00000},\n};\n\nstatic const struct regmap_config rockchip_i2s_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = I2S_RXDR,\n\t.reg_defaults = rockchip_i2s_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_reg_defaults),\n\t.writeable_reg = rockchip_i2s_wr_reg,\n\t.readable_reg = rockchip_i2s_rd_reg,\n\t.volatile_reg = rockchip_i2s_volatile_reg,\n\t.precious_reg = rockchip_i2s_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct rk_i2s_pins rk3399_i2s_pins = {\n\t.reg_offset = 0xe220,\n\t.shift = 11,\n};\n\nstatic const struct of_device_id rockchip_i2s_match[] __maybe_unused = {\n\t{ .compatible = \"rockchip,px30-i2s\", },\n\t{ .compatible = \"rockchip,rk1808-i2s\", },\n\t{ .compatible = \"rockchip,rk3036-i2s\", },\n\t{ .compatible = \"rockchip,rk3066-i2s\", },\n\t{ .compatible = \"rockchip,rk3128-i2s\", },\n\t{ .compatible = \"rockchip,rk3188-i2s\", },\n\t{ .compatible = \"rockchip,rk3228-i2s\", },\n\t{ .compatible = \"rockchip,rk3288-i2s\", },\n\t{ .compatible = \"rockchip,rk3308-i2s\", },\n\t{ .compatible = \"rockchip,rk3328-i2s\", },\n\t{ .compatible = \"rockchip,rk3366-i2s\", },\n\t{ .compatible = \"rockchip,rk3368-i2s\", },\n\t{ .compatible = \"rockchip,rk3399-i2s\", .data = &rk3399_i2s_pins },\n\t{ .compatible = \"rockchip,rk3588-i2s\", },\n\t{ .compatible = \"rockchip,rv1126-i2s\", },\n\t{},\n};\n\nstatic int rockchip_i2s_init_dai(struct rk_i2s_dev *i2s, struct resource *res,\n\t\t\t\t struct snd_soc_dai_driver **dp)\n{\n\tstruct device_node *node = i2s->dev->of_node;\n\tstruct snd_soc_dai_driver *dai;\n\tstruct property *dma_names;\n\tconst char *dma_name;\n\tunsigned int val;\n\n\tof_property_for_each_string(node, \"dma-names\", dma_names, dma_name) {\n\t\tif (!strcmp(dma_name, \"tx\"))\n\t\t\ti2s->has_playback = true;\n\t\tif (!strcmp(dma_name, \"rx\"))\n\t\t\ti2s->has_capture = true;\n\t}\n\n\tdai = devm_kmemdup(i2s->dev, &rockchip_i2s_dai,\n\t\t\t   sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tif (i2s->has_playback) {\n\t\tdai->playback.stream_name = \"Playback\";\n\t\tdai->playback.channels_min = 2;\n\t\tdai->playback.channels_max = 8;\n\t\tdai->playback.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tdai->playback.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE;\n\n\t\ti2s->playback_dma_data.addr = res->start + I2S_TXDR;\n\t\ti2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\ti2s->playback_dma_data.maxburst = 8;\n\n\t\tif (!of_property_read_u32(node, \"rockchip,playback-channels\", &val)) {\n\t\t\tif (val >= 2 && val <= 8)\n\t\t\t\tdai->playback.channels_max = val;\n\t\t}\n\t}\n\n\tif (i2s->has_capture) {\n\t\tdai->capture.stream_name = \"Capture\";\n\t\tdai->capture.channels_min = 2;\n\t\tdai->capture.channels_max = 8;\n\t\tdai->capture.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tdai->capture.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\t       SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t       SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t\t       SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t       SNDRV_PCM_FMTBIT_S32_LE;\n\n\t\ti2s->capture_dma_data.addr = res->start + I2S_RXDR;\n\t\ti2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\ti2s->capture_dma_data.maxburst = 8;\n\n\t\tif (!of_property_read_u32(node, \"rockchip,capture-channels\", &val)) {\n\t\t\tif (val >= 2 && val <= 8)\n\t\t\t\tdai->capture.channels_max = val;\n\t\t}\n\t}\n\n\tif (dp)\n\t\t*dp = dai;\n\n\treturn 0;\n}\n\nstatic int rockchip_i2s_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tstruct rk_i2s_dev *i2s;\n\tstruct snd_soc_dai_driver *dai;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint ret;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&i2s->lock);\n\ti2s->dev = &pdev->dev;\n\n\ti2s->grf = syscon_regmap_lookup_by_phandle(node, \"rockchip,grf\");\n\tif (!IS_ERR(i2s->grf)) {\n\t\tof_id = of_match_device(rockchip_i2s_match, &pdev->dev);\n\t\tif (!of_id || !of_id->data)\n\t\t\treturn -EINVAL;\n\n\t\ti2s->pins = of_id->data;\n\t}\n\n\t \n\ti2s->hclk = devm_clk_get(&pdev->dev, \"i2s_hclk\");\n\tif (IS_ERR(i2s->hclk)) {\n\t\tdev_err(&pdev->dev, \"Can't retrieve i2s bus clock\\n\");\n\t\treturn PTR_ERR(i2s->hclk);\n\t}\n\tret = clk_prepare_enable(i2s->hclk);\n\tif (ret) {\n\t\tdev_err(i2s->dev, \"hclock enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2s->mclk = devm_clk_get(&pdev->dev, \"i2s_clk\");\n\tif (IS_ERR(i2s->mclk)) {\n\t\tdev_err(&pdev->dev, \"Can't retrieve i2s master clock\\n\");\n\t\tret = PTR_ERR(i2s->mclk);\n\t\tgoto err_clk;\n\t}\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\tgoto err_clk;\n\t}\n\n\ti2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t    &rockchip_i2s_regmap_config);\n\tif (IS_ERR(i2s->regmap)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to initialise managed register map\\n\");\n\t\tret = PTR_ERR(i2s->regmap);\n\t\tgoto err_clk;\n\t}\n\n\ti2s->bclk_ratio = 64;\n\ti2s->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (!IS_ERR(i2s->pinctrl)) {\n\t\ti2s->bclk_on = pinctrl_lookup_state(i2s->pinctrl, \"bclk_on\");\n\t\tif (!IS_ERR_OR_NULL(i2s->bclk_on)) {\n\t\t\ti2s->bclk_off = pinctrl_lookup_state(i2s->pinctrl, \"bclk_off\");\n\t\t\tif (IS_ERR_OR_NULL(i2s->bclk_off)) {\n\t\t\t\tdev_err(&pdev->dev, \"failed to find i2s bclk_off\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_clk;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_dbg(&pdev->dev, \"failed to find i2s pinctrl\\n\");\n\t}\n\n\ti2s_pinctrl_select_bclk_off(i2s);\n\n\tdev_set_drvdata(&pdev->dev, i2s);\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = i2s_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = rockchip_i2s_init_dai(i2s, res, &dai);\n\tif (ret)\n\t\tgoto err_pm_disable;\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &rockchip_i2s_component,\n\t\t\t\t\t      dai, 1);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register DAI\\n\");\n\t\tgoto err_suspend;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register PCM\\n\");\n\t\tgoto err_suspend;\n\t}\n\n\treturn 0;\n\nerr_suspend:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ti2s_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nerr_clk:\n\tclk_disable_unprepare(i2s->hclk);\n\treturn ret;\n}\n\nstatic void rockchip_i2s_remove(struct platform_device *pdev)\n{\n\tstruct rk_i2s_dev *i2s = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\ti2s_runtime_suspend(&pdev->dev);\n\n\tclk_disable_unprepare(i2s->hclk);\n}\n\nstatic const struct dev_pm_ops rockchip_i2s_pm_ops = {\n\tSET_RUNTIME_PM_OPS(i2s_runtime_suspend, i2s_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver rockchip_i2s_driver = {\n\t.probe = rockchip_i2s_probe,\n\t.remove_new = rockchip_i2s_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(rockchip_i2s_match),\n\t\t.pm = &rockchip_i2s_pm_ops,\n\t},\n};\nmodule_platform_driver(rockchip_i2s_driver);\n\nMODULE_DESCRIPTION(\"ROCKCHIP IIS ASoC Interface\");\nMODULE_AUTHOR(\"jianqun <jay.xu@rock-chips.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_DEVICE_TABLE(of, rockchip_i2s_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}