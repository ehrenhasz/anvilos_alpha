{
  "module_name": "axi-i2s.c",
  "hash_id": "00b14d91b70aab0d915caa1bbff00d28c8a14688778cabd7cba7451be4bef43f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/adi/axi-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#define AXI_I2S_REG_RESET\t0x00\n#define AXI_I2S_REG_CTRL\t0x04\n#define AXI_I2S_REG_CLK_CTRL\t0x08\n#define AXI_I2S_REG_STATUS\t0x10\n\n#define AXI_I2S_REG_RX_FIFO\t0x28\n#define AXI_I2S_REG_TX_FIFO\t0x2C\n\n#define AXI_I2S_RESET_GLOBAL\tBIT(0)\n#define AXI_I2S_RESET_TX_FIFO\tBIT(1)\n#define AXI_I2S_RESET_RX_FIFO\tBIT(2)\n\n#define AXI_I2S_CTRL_TX_EN\tBIT(0)\n#define AXI_I2S_CTRL_RX_EN\tBIT(1)\n\n \n#define AXI_I2S_BITS_PER_FRAME 64\n\nstruct axi_i2s {\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct clk *clk_ref;\n\n\tbool   has_capture;\n\tbool   has_playback;\n\n\tstruct snd_soc_dai_driver dai_driver;\n\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tstruct snd_dmaengine_dai_dma_data playback_dma_data;\n\n\tstruct snd_ratnum ratnum;\n\tstruct snd_pcm_hw_constraint_ratnums rate_constraints;\n};\n\nstatic int axi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tunsigned int mask, val;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tmask = AXI_I2S_CTRL_RX_EN;\n\telse\n\t\tmask = AXI_I2S_CTRL_TX_EN;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = mask;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(i2s->regmap, AXI_I2S_REG_CTRL, mask, val);\n\n\treturn 0;\n}\n\nstatic int axi_i2s_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tunsigned int bclk_div, word_size;\n\tunsigned int bclk_rate;\n\n\tbclk_rate = params_rate(params) * AXI_I2S_BITS_PER_FRAME;\n\n\tword_size = AXI_I2S_BITS_PER_FRAME / 2 - 1;\n\tbclk_div = DIV_ROUND_UP(clk_get_rate(i2s->clk_ref), bclk_rate) / 2 - 1;\n\n\tregmap_write(i2s->regmap, AXI_I2S_REG_CLK_CTRL, (word_size << 16) |\n\t\tbclk_div);\n\n\treturn 0;\n}\n\nstatic int axi_i2s_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tuint32_t mask;\n\tint ret;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tmask = AXI_I2S_RESET_RX_FIFO;\n\telse\n\t\tmask = AXI_I2S_RESET_TX_FIFO;\n\n\tregmap_write(i2s->regmap, AXI_I2S_REG_RESET, mask);\n\n\tret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,\n\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t   &i2s->rate_constraints);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(i2s->clk_ref);\n}\n\nstatic void axi_i2s_shutdown(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\tclk_disable_unprepare(i2s->clk_ref);\n}\n\nstatic int axi_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(\n\t\tdai,\n\t\ti2s->has_playback ? &i2s->playback_dma_data : NULL,\n\t\ti2s->has_capture  ? &i2s->capture_dma_data  : NULL);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops axi_i2s_dai_ops = {\n\t.probe = axi_i2s_dai_probe,\n\t.startup = axi_i2s_startup,\n\t.shutdown = axi_i2s_shutdown,\n\t.trigger = axi_i2s_trigger,\n\t.hw_params = axi_i2s_hw_params,\n};\n\nstatic struct snd_soc_dai_driver axi_i2s_dai = {\n\t.ops = &axi_i2s_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver axi_i2s_component = {\n\t.name = \"axi-i2s\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct regmap_config axi_i2s_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = AXI_I2S_REG_STATUS,\n};\n\nstatic void axi_i2s_parse_of(struct axi_i2s *i2s, const struct device_node *np)\n{\n\tstruct property *dma_names;\n\tconst char *dma_name;\n\n\tof_property_for_each_string(np, \"dma-names\", dma_names, dma_name) {\n\t\tif (strcmp(dma_name, \"rx\") == 0)\n\t\t\ti2s->has_capture = true;\n\t\tif (strcmp(dma_name, \"tx\") == 0)\n\t\t\ti2s->has_playback = true;\n\t}\n}\n\nstatic int axi_i2s_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct axi_i2s *i2s;\n\tvoid __iomem *base;\n\tint ret;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, i2s);\n\n\taxi_i2s_parse_of(i2s, pdev->dev.of_node);\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\ti2s->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t&axi_i2s_regmap_config);\n\tif (IS_ERR(i2s->regmap))\n\t\treturn PTR_ERR(i2s->regmap);\n\n\ti2s->clk = devm_clk_get(&pdev->dev, \"axi\");\n\tif (IS_ERR(i2s->clk))\n\t\treturn PTR_ERR(i2s->clk);\n\n\ti2s->clk_ref = devm_clk_get(&pdev->dev, \"ref\");\n\tif (IS_ERR(i2s->clk_ref))\n\t\treturn PTR_ERR(i2s->clk_ref);\n\n\tret = clk_prepare_enable(i2s->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (i2s->has_playback) {\n\t\taxi_i2s_dai.playback.channels_min = 2;\n\t\taxi_i2s_dai.playback.channels_max = 2;\n\t\taxi_i2s_dai.playback.rates = SNDRV_PCM_RATE_KNOT;\n\t\taxi_i2s_dai.playback.formats =\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_U32_LE;\n\n\t\ti2s->playback_dma_data.addr = res->start + AXI_I2S_REG_TX_FIFO;\n\t\ti2s->playback_dma_data.addr_width = 4;\n\t\ti2s->playback_dma_data.maxburst = 1;\n\t}\n\n\tif (i2s->has_capture) {\n\t\taxi_i2s_dai.capture.channels_min = 2;\n\t\taxi_i2s_dai.capture.channels_max = 2;\n\t\taxi_i2s_dai.capture.rates = SNDRV_PCM_RATE_KNOT;\n\t\taxi_i2s_dai.capture.formats =\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_U32_LE;\n\n\t\ti2s->capture_dma_data.addr = res->start + AXI_I2S_REG_RX_FIFO;\n\t\ti2s->capture_dma_data.addr_width = 4;\n\t\ti2s->capture_dma_data.maxburst = 1;\n\t}\n\n\ti2s->ratnum.num = clk_get_rate(i2s->clk_ref) / 2 / AXI_I2S_BITS_PER_FRAME;\n\ti2s->ratnum.den_step = 1;\n\ti2s->ratnum.den_min = 1;\n\ti2s->ratnum.den_max = 64;\n\n\ti2s->rate_constraints.rats = &i2s->ratnum;\n\ti2s->rate_constraints.nrats = 1;\n\n\tregmap_write(i2s->regmap, AXI_I2S_REG_RESET, AXI_I2S_RESET_GLOBAL);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &axi_i2s_component,\n\t\t\t\t\t &axi_i2s_dai, 1);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tdev_info(&pdev->dev, \"probed, capture %s, playback %s\\n\",\n\t\t i2s->has_capture ? \"enabled\" : \"disabled\",\n\t\t i2s->has_playback ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(i2s->clk);\n\treturn ret;\n}\n\nstatic void axi_i2s_dev_remove(struct platform_device *pdev)\n{\n\tstruct axi_i2s *i2s = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(i2s->clk);\n}\n\nstatic const struct of_device_id axi_i2s_of_match[] = {\n\t{ .compatible = \"adi,axi-i2s-1.00.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, axi_i2s_of_match);\n\nstatic struct platform_driver axi_i2s_driver = {\n\t.driver = {\n\t\t.name = \"axi-i2s\",\n\t\t.of_match_table = axi_i2s_of_match,\n\t},\n\t.probe = axi_i2s_probe,\n\t.remove_new = axi_i2s_dev_remove,\n};\nmodule_platform_driver(axi_i2s_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"AXI I2S driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}