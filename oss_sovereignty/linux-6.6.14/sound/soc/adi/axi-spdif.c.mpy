{
  "module_name": "axi-spdif.c",
  "hash_id": "2418faab62afd0d70811c4f62a91dde8d49ea2998f8bb79ed667f968b9c96eb4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/adi/axi-spdif.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/dmaengine_pcm.h>\n\n#define AXI_SPDIF_REG_CTRL\t0x0\n#define AXI_SPDIF_REG_STAT\t0x4\n#define AXI_SPDIF_REG_TX_FIFO\t0xc\n\n#define AXI_SPDIF_CTRL_TXDATA BIT(1)\n#define AXI_SPDIF_CTRL_TXEN BIT(0)\n#define AXI_SPDIF_CTRL_CLKDIV_OFFSET 8\n#define AXI_SPDIF_CTRL_CLKDIV_MASK (0xff << 8)\n\n#define AXI_SPDIF_FREQ_44100\t(0x0 << 6)\n#define AXI_SPDIF_FREQ_48000\t(0x1 << 6)\n#define AXI_SPDIF_FREQ_32000\t(0x2 << 6)\n#define AXI_SPDIF_FREQ_NA\t(0x3 << 6)\n\nstruct axi_spdif {\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct clk *clk_ref;\n\n\tstruct snd_dmaengine_dai_dma_data dma_data;\n\n\tstruct snd_ratnum ratnum;\n\tstruct snd_pcm_hw_constraint_ratnums rate_constraints;\n};\n\nstatic int axi_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);\n\tunsigned int val;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = AXI_SPDIF_CTRL_TXDATA;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,\n\t\tAXI_SPDIF_CTRL_TXDATA, val);\n\n\treturn 0;\n}\n\nstatic int axi_spdif_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);\n\tunsigned int rate = params_rate(params);\n\tunsigned int clkdiv, stat;\n\n\tswitch (params_rate(params)) {\n\tcase 32000:\n\t\tstat = AXI_SPDIF_FREQ_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tstat = AXI_SPDIF_FREQ_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tstat = AXI_SPDIF_FREQ_48000;\n\t\tbreak;\n\tdefault:\n\t\tstat = AXI_SPDIF_FREQ_NA;\n\t\tbreak;\n\t}\n\n\tclkdiv = DIV_ROUND_CLOSEST(clk_get_rate(spdif->clk_ref),\n\t\t\trate * 64 * 2) - 1;\n\tclkdiv <<= AXI_SPDIF_CTRL_CLKDIV_OFFSET;\n\n\tregmap_write(spdif->regmap, AXI_SPDIF_REG_STAT, stat);\n\tregmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,\n\t\tAXI_SPDIF_CTRL_CLKDIV_MASK, clkdiv);\n\n\treturn 0;\n}\n\nstatic int axi_spdif_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &spdif->dma_data, NULL);\n\n\treturn 0;\n}\n\nstatic int axi_spdif_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,\n\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t   &spdif->rate_constraints);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(spdif->clk_ref);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,\n\t\tAXI_SPDIF_CTRL_TXEN, AXI_SPDIF_CTRL_TXEN);\n\n\treturn 0;\n}\n\nstatic void axi_spdif_shutdown(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct axi_spdif *spdif = snd_soc_dai_get_drvdata(dai);\n\n\tregmap_update_bits(spdif->regmap, AXI_SPDIF_REG_CTRL,\n\t\tAXI_SPDIF_CTRL_TXEN, 0);\n\n\tclk_disable_unprepare(spdif->clk_ref);\n}\n\nstatic const struct snd_soc_dai_ops axi_spdif_dai_ops = {\n\t.probe = axi_spdif_dai_probe,\n\t.startup = axi_spdif_startup,\n\t.shutdown = axi_spdif_shutdown,\n\t.trigger = axi_spdif_trigger,\n\t.hw_params = axi_spdif_hw_params,\n};\n\nstatic struct snd_soc_dai_driver axi_spdif_dai = {\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &axi_spdif_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver axi_spdif_component = {\n\t.name = \"axi-spdif\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct regmap_config axi_spdif_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = AXI_SPDIF_REG_STAT,\n};\n\nstatic int axi_spdif_probe(struct platform_device *pdev)\n{\n\tstruct axi_spdif *spdif;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret;\n\n\tspdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);\n\tif (!spdif)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, spdif);\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tspdif->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t    &axi_spdif_regmap_config);\n\tif (IS_ERR(spdif->regmap))\n\t\treturn PTR_ERR(spdif->regmap);\n\n\tspdif->clk = devm_clk_get(&pdev->dev, \"axi\");\n\tif (IS_ERR(spdif->clk))\n\t\treturn PTR_ERR(spdif->clk);\n\n\tspdif->clk_ref = devm_clk_get(&pdev->dev, \"ref\");\n\tif (IS_ERR(spdif->clk_ref))\n\t\treturn PTR_ERR(spdif->clk_ref);\n\n\tret = clk_prepare_enable(spdif->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tspdif->dma_data.addr = res->start + AXI_SPDIF_REG_TX_FIFO;\n\tspdif->dma_data.addr_width = 4;\n\tspdif->dma_data.maxburst = 1;\n\n\tspdif->ratnum.num = clk_get_rate(spdif->clk_ref) / 128;\n\tspdif->ratnum.den_step = 1;\n\tspdif->ratnum.den_min = 1;\n\tspdif->ratnum.den_max = 64;\n\n\tspdif->rate_constraints.rats = &spdif->ratnum;\n\tspdif->rate_constraints.nrats = 1;\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &axi_spdif_component,\n\t\t\t\t\t &axi_spdif_dai, 1);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(spdif->clk);\n\treturn ret;\n}\n\nstatic void axi_spdif_dev_remove(struct platform_device *pdev)\n{\n\tstruct axi_spdif *spdif = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(spdif->clk);\n}\n\nstatic const struct of_device_id axi_spdif_of_match[] = {\n\t{ .compatible = \"adi,axi-spdif-tx-1.00.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, axi_spdif_of_match);\n\nstatic struct platform_driver axi_spdif_driver = {\n\t.driver = {\n\t\t.name = \"axi-spdif\",\n\t\t.of_match_table = axi_spdif_of_match,\n\t},\n\t.probe = axi_spdif_probe,\n\t.remove_new = axi_spdif_dev_remove,\n};\nmodule_platform_driver(axi_spdif_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"AXI SPDIF driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}