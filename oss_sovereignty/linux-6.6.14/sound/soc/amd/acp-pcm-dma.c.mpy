{
  "module_name": "acp-pcm-dma.c",
  "hash_id": "76b2851590414b8c6d1d1950b9c84c16d5da46e2bfb8fa35fa9ff9ceeb669380",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp-pcm-dma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/sizes.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/soc.h>\n#include <drm/amd_asic_type.h>\n#include \"acp.h\"\n\n#define DRV_NAME \"acp_audio_dma\"\n\n#define PLAYBACK_MIN_NUM_PERIODS    2\n#define PLAYBACK_MAX_NUM_PERIODS    2\n#define PLAYBACK_MAX_PERIOD_SIZE    16384\n#define PLAYBACK_MIN_PERIOD_SIZE    1024\n#define CAPTURE_MIN_NUM_PERIODS     2\n#define CAPTURE_MAX_NUM_PERIODS     2\n#define CAPTURE_MAX_PERIOD_SIZE     16384\n#define CAPTURE_MIN_PERIOD_SIZE     1024\n\n#define MAX_BUFFER (PLAYBACK_MAX_PERIOD_SIZE * PLAYBACK_MAX_NUM_PERIODS)\n#define MIN_BUFFER MAX_BUFFER\n\n#define ST_PLAYBACK_MAX_PERIOD_SIZE 4096\n#define ST_CAPTURE_MAX_PERIOD_SIZE  ST_PLAYBACK_MAX_PERIOD_SIZE\n#define ST_MAX_BUFFER (ST_PLAYBACK_MAX_PERIOD_SIZE * PLAYBACK_MAX_NUM_PERIODS)\n#define ST_MIN_BUFFER ST_MAX_BUFFER\n\n#define DRV_NAME \"acp_audio_dma\"\nbool acp_bt_uart_enable = true;\nEXPORT_SYMBOL(acp_bt_uart_enable);\n\nstatic const struct snd_pcm_hardware acp_pcm_hardware_playback = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 1,\n\t.channels_max = 8,\n\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t.rate_min = 8000,\n\t.rate_max = 96000,\n\t.buffer_bytes_max = PLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE,\n\t.period_bytes_min = PLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max = PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min = PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max = PLAYBACK_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp_pcm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BATCH |\n\t    SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp_st_pcm_hardware_playback = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 1,\n\t.channels_max = 8,\n\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t.rate_min = 8000,\n\t.rate_max = 96000,\n\t.buffer_bytes_max = ST_MAX_BUFFER,\n\t.period_bytes_min = PLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max = ST_PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min = PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max = PLAYBACK_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp_st_pcm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = ST_MAX_BUFFER,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = ST_CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic u32 acp_reg_read(void __iomem *acp_mmio, u32 reg)\n{\n\treturn readl(acp_mmio + (reg * 4));\n}\n\nstatic void acp_reg_write(u32 val, void __iomem *acp_mmio, u32 reg)\n{\n\twritel(val, acp_mmio + (reg * 4));\n}\n\n \nstatic void config_acp_dma_channel(void __iomem *acp_mmio, u8 ch_num,\n\t\t\t\t   u16 dscr_strt_idx, u16 num_dscrs,\n\t\t\t\t   enum acp_dma_priority_level priority_level)\n{\n\tu32 dma_ctrl;\n\n\t \n\tdma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;\n\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\n\t \n\tacp_reg_write((ACP_DMA_DSCR_STRT_IDX_0__DMAChDscrStrtIdx_MASK\n\t\t\t& dscr_strt_idx),\n\t\t\tacp_mmio, mmACP_DMA_DSCR_STRT_IDX_0 + ch_num);\n\n\t \n\tacp_reg_write(ACP_DMA_DSCR_CNT_0__DMAChDscrCnt_MASK & num_dscrs,\n\t\t      acp_mmio, mmACP_DMA_DSCR_CNT_0 + ch_num);\n\n\t \n\tacp_reg_write(priority_level, acp_mmio, mmACP_DMA_PRIO_0 + ch_num);\n}\n\n \nstatic void config_dma_descriptor_in_sram(void __iomem *acp_mmio,\n\t\t\t\t\t  u16 descr_idx,\n\t\t\t\t\t  acp_dma_dscr_transfer_t *descr_info)\n{\n\tu32 sram_offset;\n\n\tsram_offset = (descr_idx * sizeof(acp_dma_dscr_transfer_t));\n\n\t \n\tacp_reg_write(sram_offset, acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\n\tacp_reg_write(descr_info->src,\tacp_mmio, mmACP_SRBM_Targ_Idx_Data);\n\t \n\tacp_reg_write(sram_offset + 4,\tacp_mmio, mmACP_SRBM_Targ_Idx_Addr);\n\tacp_reg_write(descr_info->dest, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\n\n\t \n\tacp_reg_write(sram_offset + 8,\tacp_mmio, mmACP_SRBM_Targ_Idx_Addr);\n\tacp_reg_write(descr_info->xfer_val, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\n}\n\nstatic void pre_config_reset(void __iomem *acp_mmio, u16 ch_num)\n{\n\tu32 dma_ctrl;\n\tint ret;\n\n\t \n\tdma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRst_MASK;\n\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\t \n\tret = readl_poll_timeout(acp_mmio + ((mmACP_DMA_CNTL_0 + ch_num) * 4),\n\t\t\t\t dma_ctrl,\n\t\t\t\t !(dma_ctrl & ACP_DMA_CNTL_0__DMAChRst_MASK),\n\t\t\t\t 100, ACP_DMA_RESET_TIME);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to clear reset of channel : %d\\n\", ch_num);\n}\n\n \nstatic void set_acp_sysmem_dma_descriptors(void __iomem *acp_mmio,\n\t\t\t\t\t   u32 size, int direction,\n\t\t\t\t\t   u32 pte_offset, u16 ch,\n\t\t\t\t\t   u32 sram_bank, u16 dma_dscr_idx,\n\t\t\t\t\t   u32 asic_type)\n{\n\tu16 i;\n\tacp_dma_dscr_transfer_t dmadscr[NUM_DSCRS_PER_CHANNEL];\n\n\tfor (i = 0; i < NUM_DSCRS_PER_CHANNEL; i++) {\n\t\tdmadscr[i].xfer_val = 0;\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tdma_dscr_idx = dma_dscr_idx + i;\n\t\t\tdmadscr[i].dest = sram_bank + (i * (size / 2));\n\t\t\tdmadscr[i].src = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS\n\t\t\t\t+ (pte_offset * SZ_4K) + (i * (size / 2));\n\t\t\tswitch (asic_type) {\n\t\t\tcase CHIP_STONEY:\n\t\t\t\tdmadscr[i].xfer_val |=\n\t\t\t\t(ACP_DMA_ATTR_DAGB_GARLIC_TO_SHAREDMEM  << 16) |\n\t\t\t\t(size / 2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdmadscr[i].xfer_val |=\n\t\t\t\t(ACP_DMA_ATTR_DAGB_ONION_TO_SHAREDMEM  << 16) |\n\t\t\t\t(size / 2);\n\t\t\t}\n\t\t} else {\n\t\t\tdma_dscr_idx = dma_dscr_idx + i;\n\t\t\tdmadscr[i].src = sram_bank + (i * (size / 2));\n\t\t\tdmadscr[i].dest =\n\t\t\tACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +\n\t\t\t(pte_offset * SZ_4K) + (i * (size / 2));\n\t\t\tswitch (asic_type) {\n\t\t\tcase CHIP_STONEY:\n\t\t\t\tdmadscr[i].xfer_val |=\n\t\t\t\t(ACP_DMA_ATTR_SHARED_MEM_TO_DAGB_GARLIC << 16) |\n\t\t\t\t(size / 2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdmadscr[i].xfer_val |=\n\t\t\t\t(ACP_DMA_ATTR_SHAREDMEM_TO_DAGB_ONION << 16) |\n\t\t\t\t(size / 2);\n\t\t\t}\n\t\t}\n\t\tconfig_dma_descriptor_in_sram(acp_mmio, dma_dscr_idx,\n\t\t\t\t\t      &dmadscr[i]);\n\t}\n\tpre_config_reset(acp_mmio, ch);\n\tconfig_acp_dma_channel(acp_mmio, ch,\n\t\t\t       dma_dscr_idx - 1,\n\t\t\t       NUM_DSCRS_PER_CHANNEL,\n\t\t\t       ACP_DMA_PRIORITY_LEVEL_NORMAL);\n}\n\n \nstatic void set_acp_to_i2s_dma_descriptors(void __iomem *acp_mmio, u32 size,\n\t\t\t\t\t   int direction, u32 sram_bank,\n\t\t\t\t\t   u16 destination, u16 ch,\n\t\t\t\t\t   u16 dma_dscr_idx, u32 asic_type)\n{\n\tu16 i;\n\tacp_dma_dscr_transfer_t dmadscr[NUM_DSCRS_PER_CHANNEL];\n\n\tfor (i = 0; i < NUM_DSCRS_PER_CHANNEL; i++) {\n\t\tdmadscr[i].xfer_val = 0;\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tdma_dscr_idx = dma_dscr_idx + i;\n\t\t\tdmadscr[i].src = sram_bank  + (i * (size / 2));\n\t\t\t \n\t\t\tdmadscr[i].dest = 0;\n\t\t\tdmadscr[i].xfer_val |= BIT(22) | (destination << 16) |\n\t\t\t\t\t\t(size / 2);\n\t\t} else {\n\t\t\tdma_dscr_idx = dma_dscr_idx + i;\n\t\t\t \n\t\t\tdmadscr[i].src = 0;\n\t\t\tdmadscr[i].dest =\n\t\t\t\t sram_bank + (i * (size / 2));\n\t\t\tdmadscr[i].xfer_val |= BIT(22) |\n\t\t\t\t(destination << 16) | (size / 2);\n\t\t}\n\t\tconfig_dma_descriptor_in_sram(acp_mmio, dma_dscr_idx,\n\t\t\t\t\t      &dmadscr[i]);\n\t}\n\tpre_config_reset(acp_mmio, ch);\n\t \n\tconfig_acp_dma_channel(acp_mmio, ch, dma_dscr_idx - 1,\n\t\t\t       NUM_DSCRS_PER_CHANNEL,\n\t\t\t       ACP_DMA_PRIORITY_LEVEL_NORMAL);\n}\n\n \nstatic void acp_pte_config(void __iomem *acp_mmio, dma_addr_t addr,\n\t\t\t   u16 num_of_pages, u32 pte_offset)\n{\n\tu16 page_idx;\n\tu32 low;\n\tu32 high;\n\tu32 offset;\n\n\toffset\t= ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET + (pte_offset * 8);\n\tfor (page_idx = 0; page_idx < (num_of_pages); page_idx++) {\n\t\t \n\t\tacp_reg_write((offset + (page_idx * 8)),\n\t\t\t      acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\n\n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\n\t\tacp_reg_write(low, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\n\n\t\t \n\t\tacp_reg_write((offset + (page_idx * 8) + 4),\n\t\t\t      acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\n\n\t\t \n\t\thigh |= BIT(31);\n\t\tacp_reg_write(high, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\n\n\t\t \n\t\taddr += PAGE_SIZE;\n\t}\n}\n\nstatic void config_acp_dma(void __iomem *acp_mmio,\n\t\t\t   struct audio_substream_data *rtd,\n\t\t\t   u32 asic_type)\n{\n\tu16 ch_acp_sysmem, ch_acp_i2s;\n\n\tacp_pte_config(acp_mmio, rtd->dma_addr, rtd->num_of_pages,\n\t\t       rtd->pte_offset);\n\n\tif (rtd->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tch_acp_sysmem = rtd->ch1;\n\t\tch_acp_i2s = rtd->ch2;\n\t} else {\n\t\tch_acp_i2s = rtd->ch1;\n\t\tch_acp_sysmem = rtd->ch2;\n\t}\n\t \n\tset_acp_sysmem_dma_descriptors(acp_mmio, rtd->size,\n\t\t\t\t       rtd->direction, rtd->pte_offset,\n\t\t\t\t       ch_acp_sysmem, rtd->sram_bank,\n\t\t\t\t       rtd->dma_dscr_idx_1, asic_type);\n\t \n\tset_acp_to_i2s_dma_descriptors(acp_mmio, rtd->size,\n\t\t\t\t       rtd->direction, rtd->sram_bank,\n\t\t\t\t       rtd->destination, ch_acp_i2s,\n\t\t\t\t       rtd->dma_dscr_idx_2, asic_type);\n}\n\nstatic void acp_dma_cap_channel_enable(void __iomem *acp_mmio,\n\t\t\t\t       u16 cap_channel)\n{\n\tu32 val, ch_reg, imr_reg, res_reg;\n\n\tswitch (cap_channel) {\n\tcase CAP_CHANNEL1:\n\t\tch_reg = mmACP_I2SMICSP_RER1;\n\t\tres_reg = mmACP_I2SMICSP_RCR1;\n\t\timr_reg = mmACP_I2SMICSP_IMR1;\n\t\tbreak;\n\tcase CAP_CHANNEL0:\n\tdefault:\n\t\tch_reg = mmACP_I2SMICSP_RER0;\n\t\tres_reg = mmACP_I2SMICSP_RCR0;\n\t\timr_reg = mmACP_I2SMICSP_IMR0;\n\t\tbreak;\n\t}\n\tval = acp_reg_read(acp_mmio,\n\t\t\t   mmACP_I2S_16BIT_RESOLUTION_EN);\n\tif (val & ACP_I2S_MIC_16BIT_RESOLUTION_EN) {\n\t\tacp_reg_write(0x0, acp_mmio, ch_reg);\n\t\t \n\t\tacp_reg_write(0x2, acp_mmio, res_reg);\n\t}\n\tval = acp_reg_read(acp_mmio, imr_reg);\n\tval &= ~ACP_I2SMICSP_IMR1__I2SMICSP_RXDAM_MASK;\n\tval &= ~ACP_I2SMICSP_IMR1__I2SMICSP_RXFOM_MASK;\n\tacp_reg_write(val, acp_mmio, imr_reg);\n\tacp_reg_write(0x1, acp_mmio, ch_reg);\n}\n\nstatic void acp_dma_cap_channel_disable(void __iomem *acp_mmio,\n\t\t\t\t\tu16 cap_channel)\n{\n\tu32 val, ch_reg, imr_reg;\n\n\tswitch (cap_channel) {\n\tcase CAP_CHANNEL1:\n\t\timr_reg = mmACP_I2SMICSP_IMR1;\n\t\tch_reg = mmACP_I2SMICSP_RER1;\n\t\tbreak;\n\tcase CAP_CHANNEL0:\n\tdefault:\n\t\timr_reg = mmACP_I2SMICSP_IMR0;\n\t\tch_reg = mmACP_I2SMICSP_RER0;\n\t\tbreak;\n\t}\n\tval = acp_reg_read(acp_mmio, imr_reg);\n\tval |= ACP_I2SMICSP_IMR1__I2SMICSP_RXDAM_MASK;\n\tval |= ACP_I2SMICSP_IMR1__I2SMICSP_RXFOM_MASK;\n\tacp_reg_write(val, acp_mmio, imr_reg);\n\tacp_reg_write(0x0, acp_mmio, ch_reg);\n}\n\n \nstatic void acp_dma_start(void __iomem *acp_mmio, u16 ch_num, bool is_circular)\n{\n\tu32 dma_ctrl;\n\n\t \n\tdma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\n\t \n\tacp_reg_write(1, acp_mmio, mmACP_DAGB_ATU_CTRL);\n\n\t \n\tdma_ctrl |= ACP_DMA_CNTL_0__DMAChRun_MASK;\n\n\tswitch (ch_num) {\n\tcase ACP_TO_I2S_DMA_CH_NUM:\n\tcase I2S_TO_ACP_DMA_CH_NUM:\n\tcase ACP_TO_I2S_DMA_BT_INSTANCE_CH_NUM:\n\tcase I2S_TO_ACP_DMA_BT_INSTANCE_CH_NUM:\n\tcase ACP_TO_I2S_DMA_MICSP_INSTANCE_CH_NUM:\n\t\tdma_ctrl |= ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\n\t\tbreak;\n\t}\n\n\t \n\tif (is_circular == true)\n\t\tdma_ctrl |= ACP_DMA_CNTL_0__Circular_DMA_En_MASK;\n\telse\n\t\tdma_ctrl &= ~ACP_DMA_CNTL_0__Circular_DMA_En_MASK;\n\n\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n}\n\n \nstatic int acp_dma_stop(void __iomem *acp_mmio, u8 ch_num)\n{\n\tu32 dma_ctrl;\n\tu32 dma_ch_sts;\n\tu32 count = ACP_DMA_RESET_TIME;\n\n\tdma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\n\t \n\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;\n\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\n\n\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\tdma_ch_sts = acp_reg_read(acp_mmio, mmACP_DMA_CH_STS);\n\n\tif (dma_ch_sts & BIT(ch_num)) {\n\t\t \n\t\tdma_ctrl |= ACP_DMA_CNTL_0__DMAChRst_MASK;\n\t\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\n\t}\n\n\t \n\twhile (true) {\n\t\tdma_ch_sts = acp_reg_read(acp_mmio, mmACP_DMA_CH_STS);\n\t\tif (!(dma_ch_sts & BIT(ch_num))) {\n\t\t\t \n\t\t\tdma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRst_MASK;\n\n\t\t\tacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0\n\t\t\t\t      + ch_num);\n\t\t\tbreak;\n\t\t}\n\t\tif (--count == 0) {\n\t\t\tpr_err(\"Failed to stop ACP DMA channel : %d\\n\", ch_num);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\treturn 0;\n}\n\nstatic void acp_set_sram_bank_state(void __iomem *acp_mmio, u16 bank,\n\t\t\t\t    bool power_on)\n{\n\tu32 val, req_reg, sts_reg, sts_reg_mask;\n\tu32 loops = 1000;\n\n\tif (bank < 32) {\n\t\treq_reg = mmACP_MEM_SHUT_DOWN_REQ_LO;\n\t\tsts_reg = mmACP_MEM_SHUT_DOWN_STS_LO;\n\t\tsts_reg_mask = 0xFFFFFFFF;\n\n\t} else {\n\t\tbank -= 32;\n\t\treq_reg = mmACP_MEM_SHUT_DOWN_REQ_HI;\n\t\tsts_reg = mmACP_MEM_SHUT_DOWN_STS_HI;\n\t\tsts_reg_mask = 0x0000FFFF;\n\t}\n\n\tval = acp_reg_read(acp_mmio, req_reg);\n\tif (val & (1 << bank)) {\n\t\t \n\t\tif (power_on == true)\n\t\t\t \n\t\t\tval &= ~(1 << bank);\n\t\telse\n\t\t\t \n\t\t\treturn;\n\t} else {\n\t\t \n\t\tif (power_on == false)\n\t\t\t \n\t\t\tval |= 1 << bank;\n\t\telse\n\t\t\t \n\t\t\treturn;\n\t}\n\tacp_reg_write(val, acp_mmio, req_reg);\n\n\twhile (acp_reg_read(acp_mmio, sts_reg) != sts_reg_mask) {\n\t\tif (!loops--) {\n\t\t\tpr_err(\"ACP SRAM bank %d state change failed\\n\", bank);\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\n \nstatic int acp_init(void __iomem *acp_mmio, u32 asic_type)\n{\n\tu16 bank;\n\tu32 val, count, sram_pte_offset;\n\n\t \n\tval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tpr_err(\"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\t \n\tval = acp_reg_read(acp_mmio, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tacp_reg_write(val, acp_mmio, mmACP_CONTROL);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = acp_reg_read(acp_mmio, mmACP_STATUS);\n\t\tif (val & (u32)0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tpr_err(\"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\t \n\tval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\n\n\t \n\tif (!acp_bt_uart_enable) {\n\t\tval = acp_reg_read(acp_mmio, mmACP_BT_UART_PAD_SEL);\n\t\tval |= ACP_BT_UART_PAD_SELECT_MASK;\n\t\tacp_reg_write(val, acp_mmio, mmACP_BT_UART_PAD_SEL);\n\t}\n\n\t \n\tacp_reg_write(ACP_ONION_CNTL_DEFAULT, acp_mmio,\n\t\t      mmACP_AXI2DAGB_ONION_CNTL);\n\n\t \n\tacp_reg_write(ACP_GARLIC_CNTL_DEFAULT, acp_mmio,\n\t\t      mmACP_AXI2DAGB_GARLIC_CNTL);\n\n\tsram_pte_offset = ACP_DAGB_GRP_SRAM_BASE_ADDRESS |\n\t\t\tACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBSnoopSel_MASK |\n\t\t\tACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBTargetMemSel_MASK |\n\t\t\tACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBGrpEnable_MASK;\n\tacp_reg_write(sram_pte_offset,  acp_mmio, mmACP_DAGB_BASE_ADDR_GRP_1);\n\tacp_reg_write(ACP_PAGE_SIZE_4K_ENABLE, acp_mmio,\n\t\t      mmACP_DAGB_PAGE_SIZE_GRP_1);\n\n\tacp_reg_write(ACP_SRAM_BASE_ADDRESS, acp_mmio,\n\t\t      mmACP_DMA_DESC_BASE_ADDR);\n\n\t \n\tacp_reg_write(0x4, acp_mmio, mmACP_DMA_DESC_MAX_NUM_DSCR);\n\tacp_reg_write(ACP_EXTERNAL_INTR_CNTL__DMAIOCMask_MASK,\n\t\t      acp_mmio, mmACP_EXTERNAL_INTR_CNTL);\n\n        \n\tif (asic_type != CHIP_STONEY) {\n\t\tfor (bank = 1; bank < 48; bank++)\n\t\t\tacp_set_sram_bank_state(acp_mmio, bank, false);\n\t}\n\treturn 0;\n}\n\n \nstatic int acp_deinit(void __iomem *acp_mmio)\n{\n\tu32 val;\n\tu32 count;\n\n\t \n\tval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tpr_err(\"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t \n\tval = acp_reg_read(acp_mmio, mmACP_CONTROL);\n\tval &= ~ACP_CONTROL__ClkEn_MASK;\n\tacp_reg_write(val, acp_mmio, mmACP_CONTROL);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = acp_reg_read(acp_mmio, mmACP_STATUS);\n\t\tif (!(val & (u32)0x1))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tpr_err(\"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\treturn 0;\n}\n\n \nstatic irqreturn_t dma_irq_handler(int irq, void *arg)\n{\n\tu16 dscr_idx;\n\tu32 intr_flag, ext_intr_status;\n\tstruct audio_drv_data *irq_data;\n\tvoid __iomem *acp_mmio;\n\tstruct device *dev = arg;\n\tbool valid_irq = false;\n\n\tirq_data = dev_get_drvdata(dev);\n\tacp_mmio = irq_data->acp_mmio;\n\n\text_intr_status = acp_reg_read(acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\tintr_flag = (((ext_intr_status &\n\t\t      ACP_EXTERNAL_INTR_STAT__DMAIOCStat_MASK) >>\n\t\t     ACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT));\n\n\tif ((intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM)) != 0) {\n\t\tvalid_irq = true;\n\t\tsnd_pcm_period_elapsed(irq_data->play_i2ssp_stream);\n\t\tacp_reg_write((intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM)) << 16,\n\t\t\t      acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\t}\n\n\tif ((intr_flag & BIT(ACP_TO_I2S_DMA_MICSP_INSTANCE_CH_NUM)) != 0) {\n\t\tvalid_irq = true;\n\t\tsnd_pcm_period_elapsed(irq_data->play_i2s_micsp_stream);\n\t\tacp_reg_write((intr_flag & BIT(ACP_TO_I2S_DMA_MICSP_INSTANCE_CH_NUM)) << 16,\n\t\t\t      acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\t}\n\n\tif ((intr_flag & BIT(ACP_TO_I2S_DMA_BT_INSTANCE_CH_NUM)) != 0) {\n\t\tvalid_irq = true;\n\t\tsnd_pcm_period_elapsed(irq_data->play_i2sbt_stream);\n\t\tacp_reg_write((intr_flag &\n\t\t\t      BIT(ACP_TO_I2S_DMA_BT_INSTANCE_CH_NUM)) << 16,\n\t\t\t      acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\t}\n\n\tif ((intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM)) != 0) {\n\t\tvalid_irq = true;\n\t\tif (acp_reg_read(acp_mmio, mmACP_DMA_CUR_DSCR_14) ==\n\t\t\t\tCAPTURE_START_DMA_DESCR_CH15)\n\t\t\tdscr_idx = CAPTURE_END_DMA_DESCR_CH14;\n\t\telse\n\t\t\tdscr_idx = CAPTURE_START_DMA_DESCR_CH14;\n\t\tconfig_acp_dma_channel(acp_mmio, ACP_TO_SYSRAM_CH_NUM, dscr_idx,\n\t\t\t\t       1, 0);\n\t\tacp_dma_start(acp_mmio, ACP_TO_SYSRAM_CH_NUM, false);\n\n\t\tsnd_pcm_period_elapsed(irq_data->capture_i2ssp_stream);\n\t\tacp_reg_write((intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM)) << 16,\n\t\t\t      acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\t}\n\n\tif ((intr_flag & BIT(I2S_TO_ACP_DMA_BT_INSTANCE_CH_NUM)) != 0) {\n\t\tvalid_irq = true;\n\t\tif (acp_reg_read(acp_mmio, mmACP_DMA_CUR_DSCR_10) ==\n\t\t\tCAPTURE_START_DMA_DESCR_CH11)\n\t\t\tdscr_idx = CAPTURE_END_DMA_DESCR_CH10;\n\t\telse\n\t\t\tdscr_idx = CAPTURE_START_DMA_DESCR_CH10;\n\t\tconfig_acp_dma_channel(acp_mmio,\n\t\t\t\t       ACP_TO_SYSRAM_BT_INSTANCE_CH_NUM,\n\t\t\t\t       dscr_idx, 1, 0);\n\t\tacp_dma_start(acp_mmio, ACP_TO_SYSRAM_BT_INSTANCE_CH_NUM,\n\t\t\t      false);\n\n\t\tsnd_pcm_period_elapsed(irq_data->capture_i2sbt_stream);\n\t\tacp_reg_write((intr_flag &\n\t\t\t      BIT(I2S_TO_ACP_DMA_BT_INSTANCE_CH_NUM)) << 16,\n\t\t\t      acp_mmio, mmACP_EXTERNAL_INTR_STAT);\n\t}\n\n\tif (valid_irq)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic int acp_dma_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tu16 bank;\n\tint ret = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audio_drv_data *intr_data = dev_get_drvdata(component->dev);\n\tstruct audio_substream_data *adata =\n\t\tkzalloc(sizeof(struct audio_substream_data), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (intr_data->asic_type) {\n\t\tcase CHIP_STONEY:\n\t\t\truntime->hw = acp_st_pcm_hardware_playback;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\truntime->hw = acp_pcm_hardware_playback;\n\t\t}\n\t} else {\n\t\tswitch (intr_data->asic_type) {\n\t\tcase CHIP_STONEY:\n\t\t\truntime->hw = acp_st_pcm_hardware_capture;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\truntime->hw = acp_pcm_hardware_capture;\n\t\t}\n\t}\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(adata);\n\t\treturn ret;\n\t}\n\n\tadata->acp_mmio = intr_data->acp_mmio;\n\truntime->private_data = adata;\n\n\t \n\tif (!intr_data->play_i2ssp_stream && !intr_data->capture_i2ssp_stream &&\n\t    !intr_data->play_i2sbt_stream && !intr_data->capture_i2sbt_stream &&\n\t    !intr_data->play_i2s_micsp_stream)\n\t\tacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\tif (intr_data->asic_type != CHIP_STONEY) {\n\t\t\tfor (bank = 1; bank <= 4; bank++)\n\t\t\t\tacp_set_sram_bank_state(intr_data->acp_mmio,\n\t\t\t\t\t\t\tbank, true);\n\t\t}\n\t} else {\n\t\tif (intr_data->asic_type != CHIP_STONEY) {\n\t\t\tfor (bank = 5; bank <= 8; bank++)\n\t\t\t\tacp_set_sram_bank_state(intr_data->acp_mmio,\n\t\t\t\t\t\t\tbank, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int acp_dma_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tuint64_t size;\n\tu32 val = 0;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct audio_substream_data *rtd;\n\tstruct snd_soc_pcm_runtime *prtd = asoc_substream_to_rtd(substream);\n\tstruct audio_drv_data *adata = dev_get_drvdata(component->dev);\n\tstruct snd_soc_card *card = prtd->card;\n\tstruct acp_platform_info *pinfo = snd_soc_card_get_drvdata(card);\n\n\truntime = substream->runtime;\n\trtd = runtime->private_data;\n\n\tif (WARN_ON(!rtd))\n\t\treturn -EINVAL;\n\n\tif (pinfo) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\trtd->i2s_instance = pinfo->play_i2s_instance;\n\t\t} else {\n\t\t\trtd->i2s_instance = pinfo->cap_i2s_instance;\n\t\t\trtd->capture_channel = pinfo->capture_channel;\n\t\t}\n\t}\n\tif (adata->asic_type == CHIP_STONEY) {\n\t\tval = acp_reg_read(adata->acp_mmio,\n\t\t\t\t   mmACP_I2S_16BIT_RESOLUTION_EN);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\tval |= ACP_I2S_BT_16BIT_RESOLUTION_EN;\n\t\t\t\tbreak;\n\t\t\tcase I2S_MICSP_INSTANCE:\n\t\t\t\tval |= ACP_I2S_MICSP_16BIT_RESOLUTION_EN;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\tval |= ACP_I2S_SP_16BIT_RESOLUTION_EN;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\tval |= ACP_I2S_BT_16BIT_RESOLUTION_EN;\n\t\t\t\tbreak;\n\t\t\tcase I2S_MICSP_INSTANCE:\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\tval |= ACP_I2S_MIC_16BIT_RESOLUTION_EN;\n\t\t\t}\n\t\t}\n\t\tacp_reg_write(val, adata->acp_mmio,\n\t\t\t      mmACP_I2S_16BIT_RESOLUTION_EN);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\trtd->pte_offset = ACP_ST_BT_PLAYBACK_PTE_OFFSET;\n\t\t\trtd->ch1 = SYSRAM_TO_ACP_BT_INSTANCE_CH_NUM;\n\t\t\trtd->ch2 = ACP_TO_I2S_DMA_BT_INSTANCE_CH_NUM;\n\t\t\trtd->sram_bank = ACP_SRAM_BANK_3_ADDRESS;\n\t\t\trtd->destination = TO_BLUETOOTH;\n\t\t\trtd->dma_dscr_idx_1 = PLAYBACK_START_DMA_DESCR_CH8;\n\t\t\trtd->dma_dscr_idx_2 = PLAYBACK_START_DMA_DESCR_CH9;\n\t\t\trtd->byte_cnt_high_reg_offset =\n\t\t\t\t\tmmACP_I2S_BT_TRANSMIT_BYTE_CNT_HIGH;\n\t\t\trtd->byte_cnt_low_reg_offset =\n\t\t\t\t\tmmACP_I2S_BT_TRANSMIT_BYTE_CNT_LOW;\n\t\t\tadata->play_i2sbt_stream = substream;\n\t\t\tbreak;\n\t\tcase I2S_MICSP_INSTANCE:\n\t\t\tswitch (adata->asic_type) {\n\t\t\tcase CHIP_STONEY:\n\t\t\t\trtd->pte_offset = ACP_ST_PLAYBACK_PTE_OFFSET;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtd->pte_offset = ACP_PLAYBACK_PTE_OFFSET;\n\t\t\t}\n\t\t\trtd->ch1 = SYSRAM_TO_ACP_MICSP_INSTANCE_CH_NUM;\n\t\t\trtd->ch2 = ACP_TO_I2S_DMA_MICSP_INSTANCE_CH_NUM;\n\t\t\trtd->sram_bank = ACP_SRAM_BANK_1_ADDRESS;\n\t\t\trtd->destination = TO_ACP_I2S_2;\n\t\t\trtd->dma_dscr_idx_1 = PLAYBACK_START_DMA_DESCR_CH4;\n\t\t\trtd->dma_dscr_idx_2 = PLAYBACK_START_DMA_DESCR_CH5;\n\t\t\trtd->byte_cnt_high_reg_offset =\n\t\t\t\t\tmmACP_I2S_MICSP_TRANSMIT_BYTE_CNT_HIGH;\n\t\t\trtd->byte_cnt_low_reg_offset =\n\t\t\t\t\tmmACP_I2S_MICSP_TRANSMIT_BYTE_CNT_LOW;\n\n\t\t\tadata->play_i2s_micsp_stream = substream;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tswitch (adata->asic_type) {\n\t\t\tcase CHIP_STONEY:\n\t\t\t\trtd->pte_offset = ACP_ST_PLAYBACK_PTE_OFFSET;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtd->pte_offset = ACP_PLAYBACK_PTE_OFFSET;\n\t\t\t}\n\t\t\trtd->ch1 = SYSRAM_TO_ACP_CH_NUM;\n\t\t\trtd->ch2 = ACP_TO_I2S_DMA_CH_NUM;\n\t\t\trtd->sram_bank = ACP_SRAM_BANK_1_ADDRESS;\n\t\t\trtd->destination = TO_ACP_I2S_1;\n\t\t\trtd->dma_dscr_idx_1 = PLAYBACK_START_DMA_DESCR_CH12;\n\t\t\trtd->dma_dscr_idx_2 = PLAYBACK_START_DMA_DESCR_CH13;\n\t\t\trtd->byte_cnt_high_reg_offset =\n\t\t\t\t\tmmACP_I2S_TRANSMIT_BYTE_CNT_HIGH;\n\t\t\trtd->byte_cnt_low_reg_offset =\n\t\t\t\t\tmmACP_I2S_TRANSMIT_BYTE_CNT_LOW;\n\t\t\tadata->play_i2ssp_stream = substream;\n\t\t}\n\t} else {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\trtd->pte_offset = ACP_ST_BT_CAPTURE_PTE_OFFSET;\n\t\t\trtd->ch1 = I2S_TO_ACP_DMA_BT_INSTANCE_CH_NUM;\n\t\t\trtd->ch2 = ACP_TO_SYSRAM_BT_INSTANCE_CH_NUM;\n\t\t\trtd->sram_bank = ACP_SRAM_BANK_4_ADDRESS;\n\t\t\trtd->destination = FROM_BLUETOOTH;\n\t\t\trtd->dma_dscr_idx_1 = CAPTURE_START_DMA_DESCR_CH10;\n\t\t\trtd->dma_dscr_idx_2 = CAPTURE_START_DMA_DESCR_CH11;\n\t\t\trtd->byte_cnt_high_reg_offset =\n\t\t\t\t\tmmACP_I2S_BT_RECEIVE_BYTE_CNT_HIGH;\n\t\t\trtd->byte_cnt_low_reg_offset =\n\t\t\t\t\tmmACP_I2S_BT_RECEIVE_BYTE_CNT_LOW;\n\t\t\trtd->dma_curr_dscr = mmACP_DMA_CUR_DSCR_11;\n\t\t\tadata->capture_i2sbt_stream = substream;\n\t\t\tbreak;\n\t\tcase I2S_MICSP_INSTANCE:\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\trtd->pte_offset = ACP_CAPTURE_PTE_OFFSET;\n\t\t\trtd->ch1 = I2S_TO_ACP_DMA_CH_NUM;\n\t\t\trtd->ch2 = ACP_TO_SYSRAM_CH_NUM;\n\t\t\tswitch (adata->asic_type) {\n\t\t\tcase CHIP_STONEY:\n\t\t\t\trtd->pte_offset = ACP_ST_CAPTURE_PTE_OFFSET;\n\t\t\t\trtd->sram_bank = ACP_SRAM_BANK_2_ADDRESS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtd->pte_offset = ACP_CAPTURE_PTE_OFFSET;\n\t\t\t\trtd->sram_bank = ACP_SRAM_BANK_5_ADDRESS;\n\t\t\t}\n\t\t\trtd->destination = FROM_ACP_I2S_1;\n\t\t\trtd->dma_dscr_idx_1 = CAPTURE_START_DMA_DESCR_CH14;\n\t\t\trtd->dma_dscr_idx_2 = CAPTURE_START_DMA_DESCR_CH15;\n\t\t\trtd->byte_cnt_high_reg_offset =\n\t\t\t\t\tmmACP_I2S_RECEIVED_BYTE_CNT_HIGH;\n\t\t\trtd->byte_cnt_low_reg_offset =\n\t\t\t\t\tmmACP_I2S_RECEIVED_BYTE_CNT_LOW;\n\t\t\trtd->dma_curr_dscr = mmACP_DMA_CUR_DSCR_15;\n\t\t\tadata->capture_i2ssp_stream = substream;\n\t\t}\n\t}\n\n\tsize = params_buffer_bytes(params);\n\n\tacp_set_sram_bank_state(rtd->acp_mmio, 0, true);\n\t \n\trtd->dma_addr = runtime->dma_addr;\n\trtd->order = get_order(size);\n\n\t \n\trtd->size = size;\n\trtd->num_of_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\trtd->direction = substream->stream;\n\n\tconfig_acp_dma(rtd->acp_mmio, rtd, adata->asic_type);\n\treturn 0;\n}\n\nstatic u64 acp_get_byte_count(struct audio_substream_data *rtd)\n{\n\tunion acp_dma_count byte_count;\n\n\tbyte_count.bcount.high = acp_reg_read(rtd->acp_mmio,\n\t\t\t\t\t      rtd->byte_cnt_high_reg_offset);\n\tbyte_count.bcount.low  = acp_reg_read(rtd->acp_mmio,\n\t\t\t\t\t      rtd->byte_cnt_low_reg_offset);\n\treturn byte_count.bytescount;\n}\n\nstatic snd_pcm_uframes_t acp_dma_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tu32 buffersize;\n\tu32 pos = 0;\n\tu64 bytescount = 0;\n\tu16 dscr;\n\tu32 period_bytes, delay;\n\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audio_substream_data *rtd = runtime->private_data;\n\tstruct audio_drv_data *adata = dev_get_drvdata(component->dev);\n\n\tif (!rtd)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\t\tbytescount = acp_get_byte_count(rtd);\n\t\tif (bytescount >= rtd->bytescount)\n\t\t\tbytescount -= rtd->bytescount;\n\t\tif (bytescount < period_bytes) {\n\t\t\tpos = 0;\n\t\t} else {\n\t\t\tdscr = acp_reg_read(rtd->acp_mmio, rtd->dma_curr_dscr);\n\t\t\tif (dscr == rtd->dma_dscr_idx_1)\n\t\t\t\tpos = period_bytes;\n\t\t\telse\n\t\t\t\tpos = 0;\n\t\t}\n\t\tif (bytescount > 0) {\n\t\t\tdelay = do_div(bytescount, period_bytes);\n\t\t\tadata->delay += bytes_to_frames(runtime, delay);\n\t\t}\n\t} else {\n\t\tbuffersize = frames_to_bytes(runtime, runtime->buffer_size);\n\t\tbytescount = acp_get_byte_count(rtd);\n\t\tif (bytescount > rtd->bytescount)\n\t\t\tbytescount -= rtd->bytescount;\n\t\tpos = do_div(bytescount, buffersize);\n\t}\n\treturn bytes_to_frames(runtime, pos);\n}\n\nstatic snd_pcm_sframes_t acp_dma_delay(struct snd_soc_component *component,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct audio_drv_data *adata = dev_get_drvdata(component->dev);\n\tsnd_pcm_sframes_t delay = adata->delay;\n\n\tadata->delay = 0;\n\n\treturn delay;\n}\n\nstatic int acp_dma_prepare(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audio_substream_data *rtd = runtime->private_data;\n\tu16 ch_acp_sysmem, ch_acp_i2s;\n\n\tif (!rtd)\n\t\treturn -EINVAL;\n\n\tif (rtd->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tch_acp_sysmem = rtd->ch1;\n\t\tch_acp_i2s = rtd->ch2;\n\t} else {\n\t\tch_acp_i2s = rtd->ch1;\n\t\tch_acp_sysmem = rtd->ch2;\n\t}\n\tconfig_acp_dma_channel(rtd->acp_mmio,\n\t\t\t       ch_acp_sysmem,\n\t\t\t       rtd->dma_dscr_idx_1,\n\t\t\t       NUM_DSCRS_PER_CHANNEL, 0);\n\tconfig_acp_dma_channel(rtd->acp_mmio,\n\t\t\t       ch_acp_i2s,\n\t\t\t       rtd->dma_dscr_idx_2,\n\t\t\t       NUM_DSCRS_PER_CHANNEL, 0);\n\treturn 0;\n}\n\nstatic int acp_dma_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret;\n\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audio_substream_data *rtd = runtime->private_data;\n\n\tif (!rtd)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\trtd->bytescount = acp_get_byte_count(rtd);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tif (rtd->capture_channel == CAP_CHANNEL0) {\n\t\t\t\tacp_dma_cap_channel_disable(rtd->acp_mmio,\n\t\t\t\t\t\t\t    CAP_CHANNEL1);\n\t\t\t\tacp_dma_cap_channel_enable(rtd->acp_mmio,\n\t\t\t\t\t\t\t   CAP_CHANNEL0);\n\t\t\t}\n\t\t\tif (rtd->capture_channel == CAP_CHANNEL1) {\n\t\t\t\tacp_dma_cap_channel_disable(rtd->acp_mmio,\n\t\t\t\t\t\t\t    CAP_CHANNEL0);\n\t\t\t\tacp_dma_cap_channel_enable(rtd->acp_mmio,\n\t\t\t\t\t\t\t   CAP_CHANNEL1);\n\t\t\t}\n\t\t\tacp_dma_start(rtd->acp_mmio, rtd->ch1, true);\n\t\t} else {\n\t\t\tacp_dma_start(rtd->acp_mmio, rtd->ch1, true);\n\t\t\tacp_dma_start(rtd->acp_mmio, rtd->ch2, true);\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tacp_dma_stop(rtd->acp_mmio, rtd->ch2);\n\t\tret = acp_dma_stop(rtd->acp_mmio, rtd->ch1);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int acp_dma_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct audio_drv_data *adata = dev_get_drvdata(component->dev);\n\tstruct device *parent = component->dev->parent;\n\n\tswitch (adata->asic_type) {\n\tcase CHIP_STONEY:\n\t\tsnd_pcm_set_managed_buffer_all(rtd->pcm,\n\t\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       parent,\n\t\t\t\t\t       ST_MIN_BUFFER,\n\t\t\t\t\t       ST_MAX_BUFFER);\n\t\tbreak;\n\tdefault:\n\t\tsnd_pcm_set_managed_buffer_all(rtd->pcm,\n\t\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       parent,\n\t\t\t\t\t       MIN_BUFFER,\n\t\t\t\t\t       MAX_BUFFER);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int acp_dma_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tu16 bank;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audio_substream_data *rtd = runtime->private_data;\n\tstruct audio_drv_data *adata = dev_get_drvdata(component->dev);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tadata->play_i2sbt_stream = NULL;\n\t\t\tbreak;\n\t\tcase I2S_MICSP_INSTANCE:\n\t\t\tadata->play_i2s_micsp_stream = NULL;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tadata->play_i2ssp_stream = NULL;\n\t\t\t \n\t\t\tif (adata->asic_type != CHIP_STONEY) {\n\t\t\t\tfor (bank = 1; bank <= 4; bank++)\n\t\t\t\t\tacp_set_sram_bank_state(adata->acp_mmio,\n\t\t\t\t\t\t\t\tbank, false);\n\t\t\t}\n\t\t}\n\t} else  {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tadata->capture_i2sbt_stream = NULL;\n\t\t\tbreak;\n\t\tcase I2S_MICSP_INSTANCE:\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tadata->capture_i2ssp_stream = NULL;\n\t\t\tif (adata->asic_type != CHIP_STONEY) {\n\t\t\t\tfor (bank = 5; bank <= 8; bank++)\n\t\t\t\t\tacp_set_sram_bank_state(adata->acp_mmio,\n\t\t\t\t\t\t\t\tbank, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!adata->play_i2ssp_stream && !adata->capture_i2ssp_stream &&\n\t    !adata->play_i2sbt_stream && !adata->capture_i2sbt_stream &&\n\t    !adata->play_i2s_micsp_stream)\n\t\tacp_reg_write(0, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\n\tkfree(rtd);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver acp_asoc_platform = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= acp_dma_open,\n\t.close\t\t= acp_dma_close,\n\t.hw_params\t= acp_dma_hw_params,\n\t.trigger\t= acp_dma_trigger,\n\t.pointer\t= acp_dma_pointer,\n\t.delay\t\t= acp_dma_delay,\n\t.prepare\t= acp_dma_prepare,\n\t.pcm_construct\t= acp_dma_new,\n};\n\nstatic int acp_audio_probe(struct platform_device *pdev)\n{\n\tint status, irq;\n\tstruct audio_drv_data *audio_drv_data;\n\tconst u32 *pdata = pdev->dev.platform_data;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\taudio_drv_data = devm_kzalloc(&pdev->dev, sizeof(struct audio_drv_data),\n\t\t\t\t      GFP_KERNEL);\n\tif (!audio_drv_data)\n\t\treturn -ENOMEM;\n\n\taudio_drv_data->acp_mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(audio_drv_data->acp_mmio))\n\t\treturn PTR_ERR(audio_drv_data->acp_mmio);\n\n\t \n\n\taudio_drv_data->play_i2ssp_stream = NULL;\n\taudio_drv_data->capture_i2ssp_stream = NULL;\n\taudio_drv_data->play_i2sbt_stream = NULL;\n\taudio_drv_data->capture_i2sbt_stream = NULL;\n\taudio_drv_data->play_i2s_micsp_stream = NULL;\n\n\taudio_drv_data->asic_type =  *pdata;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENODEV;\n\n\tstatus = devm_request_irq(&pdev->dev, irq, dma_irq_handler,\n\t\t\t\t  0, \"ACP_IRQ\", &pdev->dev);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"ACP IRQ request failed\\n\");\n\t\treturn status;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, audio_drv_data);\n\n\t \n\tstatus = acp_init(audio_drv_data->acp_mmio, audio_drv_data->asic_type);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"ACP Init failed status:%d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t\t &acp_asoc_platform, NULL, 0);\n\tif (status != 0) {\n\t\tdev_err(&pdev->dev, \"Fail to register ALSA platform device\\n\");\n\t\treturn status;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 10000);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn status;\n}\n\nstatic void acp_audio_remove(struct platform_device *pdev)\n{\n\tint status;\n\tstruct audio_drv_data *adata = dev_get_drvdata(&pdev->dev);\n\n\tstatus = acp_deinit(adata->acp_mmio);\n\tif (status)\n\t\tdev_err(&pdev->dev, \"ACP Deinit failed status:%d\\n\", status);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int acp_pcm_resume(struct device *dev)\n{\n\tu16 bank;\n\tint status;\n\tstruct audio_substream_data *rtd;\n\tstruct audio_drv_data *adata = dev_get_drvdata(dev);\n\n\tstatus = acp_init(adata->acp_mmio, adata->asic_type);\n\tif (status) {\n\t\tdev_err(dev, \"ACP Init failed status:%d\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (adata->play_i2ssp_stream && adata->play_i2ssp_stream->runtime) {\n\t\t \n\t\tif (adata->asic_type != CHIP_STONEY) {\n\t\t\tfor (bank = 1; bank <= 4; bank++)\n\t\t\t\tacp_set_sram_bank_state(adata->acp_mmio, bank,\n\t\t\t\t\t\t\ttrue);\n\t\t}\n\t\trtd = adata->play_i2ssp_stream->runtime->private_data;\n\t\tconfig_acp_dma(adata->acp_mmio, rtd, adata->asic_type);\n\t}\n\tif (adata->capture_i2ssp_stream &&\n\t    adata->capture_i2ssp_stream->runtime) {\n\t\tif (adata->asic_type != CHIP_STONEY) {\n\t\t\tfor (bank = 5; bank <= 8; bank++)\n\t\t\t\tacp_set_sram_bank_state(adata->acp_mmio, bank,\n\t\t\t\t\t\t\ttrue);\n\t\t}\n\t\trtd =  adata->capture_i2ssp_stream->runtime->private_data;\n\t\tconfig_acp_dma(adata->acp_mmio, rtd, adata->asic_type);\n\t}\n\tif (adata->asic_type != CHIP_CARRIZO) {\n\t\tif (adata->play_i2s_micsp_stream &&\n\t\t    adata->play_i2s_micsp_stream->runtime) {\n\t\t\trtd = adata->play_i2s_micsp_stream->runtime->private_data;\n\t\t\tconfig_acp_dma(adata->acp_mmio, rtd, adata->asic_type);\n\t\t}\n\t\tif (adata->play_i2sbt_stream &&\n\t\t    adata->play_i2sbt_stream->runtime) {\n\t\t\trtd = adata->play_i2sbt_stream->runtime->private_data;\n\t\t\tconfig_acp_dma(adata->acp_mmio, rtd, adata->asic_type);\n\t\t}\n\t\tif (adata->capture_i2sbt_stream &&\n\t\t    adata->capture_i2sbt_stream->runtime) {\n\t\t\trtd = adata->capture_i2sbt_stream->runtime->private_data;\n\t\t\tconfig_acp_dma(adata->acp_mmio, rtd, adata->asic_type);\n\t\t}\n\t}\n\tacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\n\treturn 0;\n}\n\nstatic int acp_pcm_runtime_suspend(struct device *dev)\n{\n\tint status;\n\tstruct audio_drv_data *adata = dev_get_drvdata(dev);\n\n\tstatus = acp_deinit(adata->acp_mmio);\n\tif (status)\n\t\tdev_err(dev, \"ACP Deinit failed status:%d\\n\", status);\n\tacp_reg_write(0, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\n\treturn 0;\n}\n\nstatic int acp_pcm_runtime_resume(struct device *dev)\n{\n\tint status;\n\tstruct audio_drv_data *adata = dev_get_drvdata(dev);\n\n\tstatus = acp_init(adata->acp_mmio, adata->asic_type);\n\tif (status) {\n\t\tdev_err(dev, \"ACP Init failed status:%d\\n\", status);\n\t\treturn status;\n\t}\n\tacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp_pm_ops = {\n\t.resume = acp_pcm_resume,\n\t.runtime_suspend = acp_pcm_runtime_suspend,\n\t.runtime_resume = acp_pcm_runtime_resume,\n};\n\nstatic struct platform_driver acp_dma_driver = {\n\t.probe = acp_audio_probe,\n\t.remove_new = acp_audio_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &acp_pm_ops,\n\t},\n};\n\nmodule_platform_driver(acp_dma_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_AUTHOR(\"Maruthi.Bayyavarapu@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP PCM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\"DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}