{
  "module_name": "rn-pci-acp3x.c",
  "hash_id": "aa1295eba47d4daf5310606f818c5e6959d6e8d2371e82767e8f17039c054fb9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/renoir/rn-pci-acp3x.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include \"rn_acp3x.h\"\n\nstatic int acp_power_gating;\nmodule_param(acp_power_gating, int, 0644);\nMODULE_PARM_DESC(acp_power_gating, \"Enable acp power gating\");\n\n \nstatic int dmic_acpi_check = ACP_DMIC_AUTO;\nmodule_param(dmic_acpi_check, bint, 0644);\nMODULE_PARM_DESC(dmic_acpi_check, \"Digital microphone presence (-1=auto, 0=none, 1=force)\");\n\nstruct acp_dev_data {\n\tvoid __iomem *acp_base;\n\tstruct resource *res;\n\tstruct platform_device *pdev[ACP_DEVS];\n};\n\nstatic int rn_acp_power_on(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tval = rn_readl(acp_base + ACP_PGFSM_STATUS);\n\n\tif (val == 0)\n\t\treturn val;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) !=\n\t\t\t\tACP_POWER_ON_IN_PROGRESS)\n\t\trn_writel(ACP_PGFSM_CNTL_POWER_ON_MASK,\n\t\t\t  acp_base + ACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rn_readl(acp_base + ACP_PGFSM_STATUS);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int rn_acp_power_off(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\trn_writel(ACP_PGFSM_CNTL_POWER_OFF_MASK,\n\t\t  acp_base + ACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rn_readl(acp_base + ACP_PGFSM_STATUS);\n\t\tif ((val & ACP_PGFSM_STATUS_MASK) == ACP_POWERED_OFF)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int rn_acp_reset(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\trn_writel(1, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rn_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\trn_writel(0, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rn_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic void rn_acp_enable_interrupts(void __iomem *acp_base)\n{\n\tu32 ext_intr_ctrl;\n\n\trn_writel(0x01, acp_base + ACP_EXTERNAL_INTR_ENB);\n\text_intr_ctrl = rn_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);\n\text_intr_ctrl |= ACP_ERROR_MASK;\n\trn_writel(ext_intr_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);\n}\n\nstatic void rn_acp_disable_interrupts(void __iomem *acp_base)\n{\n\trn_writel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp_base +\n\t\t  ACP_EXTERNAL_INTR_STAT);\n\trn_writel(0x00, acp_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic int rn_acp_init(void __iomem *acp_base)\n{\n\tint ret;\n\n\t \n\tret = rn_acp_power_on(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\trn_writel(0x01, acp_base + ACP_CONTROL);\n\t \n\tret = rn_acp_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\trn_writel(0x03, acp_base + ACP_CLKMUX_SEL);\n\trn_acp_enable_interrupts(acp_base);\n\treturn 0;\n}\n\nstatic int rn_acp_deinit(void __iomem *acp_base)\n{\n\tint ret;\n\n\trn_acp_disable_interrupts(acp_base);\n\t \n\tret = rn_acp_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\trn_writel(0x00, acp_base + ACP_CLKMUX_SEL);\n\trn_writel(0x00, acp_base + ACP_CONTROL);\n\t \n\tif (acp_power_gating) {\n\t\tret = rn_acp_power_off(acp_base);\n\t\tif (ret) {\n\t\t\tpr_err(\"ACP power off failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct dmi_system_id rn_acp_quirk_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"81NB\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"81X2\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"81YQ\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"20T6CTO1WW\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"20NLCTO1WW\"),\n\t\t}\n\t},\n\t{}\n};\n\nstatic int snd_rn_acp_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstruct acp_dev_data *adata;\n\tstruct platform_device_info pdevinfo[ACP_DEVS];\n#if defined(CONFIG_ACPI)\n\tacpi_handle handle;\n\tacpi_integer dmic_status;\n#endif\n\tconst struct dmi_system_id *dmi_id;\n\tunsigned int irqflags, flag;\n\tint ret, index;\n\tu32 addr;\n\n\t \n\tflag = snd_amd_acp_find_config(pci);\n\tif (flag)\n\t\treturn -ENODEV;\n\n\t \n\tif (pci->revision != 0x01)\n\t\treturn -ENODEV;\n\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP3x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct acp_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n\t \n\tret = pci_enable_msi(pci);\n\tif (ret)\n\t\t \n\t\tirqflags = IRQF_SHARED;\n\telse\n\t\t \n\t\tirqflags = 0;\n\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t       pci_resource_len(pci, 0));\n\tif (!adata->acp_base) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_msi;\n\t}\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\tret = rn_acp_init(adata->acp_base);\n\tif (ret)\n\t\tgoto disable_msi;\n\n\tif (!dmic_acpi_check) {\n\t\tret = -ENODEV;\n\t\tgoto de_init;\n\t} else if (dmic_acpi_check == ACP_DMIC_AUTO) {\n#if defined(CONFIG_ACPI)\n\t\thandle = ACPI_HANDLE(&pci->dev);\n\t\tret = acpi_evaluate_integer(handle, \"_WOV\", NULL, &dmic_status);\n\t\tif (ACPI_FAILURE(ret)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto de_init;\n\t\t}\n\t\tif (!dmic_status) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto de_init;\n\t\t}\n#endif\n\t\tdmi_id = dmi_first_match(rn_acp_quirk_table);\n\t\tif (dmi_id && !dmi_id->driver_data) {\n\t\t\tdev_info(&pci->dev, \"ACPI settings override using DMI (ACP mic is not present)\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto de_init;\n\t\t}\n\t}\n\n\tadata->res = devm_kzalloc(&pci->dev,\n\t\t\t\t  sizeof(struct resource) * 2,\n\t\t\t\t  GFP_KERNEL);\n\tif (!adata->res) {\n\t\tret = -ENOMEM;\n\t\tgoto de_init;\n\t}\n\n\tadata->res[0].name = \"acp_pdm_iomem\";\n\tadata->res[0].flags = IORESOURCE_MEM;\n\tadata->res[0].start = addr;\n\tadata->res[0].end = addr + (ACP_REG_END - ACP_REG_START);\n\tadata->res[1].name = \"acp_pdm_irq\";\n\tadata->res[1].flags = IORESOURCE_IRQ;\n\tadata->res[1].start = pci->irq;\n\tadata->res[1].end = pci->irq;\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\tpdevinfo[0].name = \"acp_rn_pdm_dma\";\n\tpdevinfo[0].id = 0;\n\tpdevinfo[0].parent = &pci->dev;\n\tpdevinfo[0].num_res = 2;\n\tpdevinfo[0].res = adata->res;\n\tpdevinfo[0].data = &irqflags;\n\tpdevinfo[0].size_data = sizeof(irqflags);\n\n\tpdevinfo[1].name = \"dmic-codec\";\n\tpdevinfo[1].id = 0;\n\tpdevinfo[1].parent = &pci->dev;\n\tpdevinfo[2].name = \"acp_pdm_mach\";\n\tpdevinfo[2].id = 0;\n\tpdevinfo[2].parent = &pci->dev;\n\tfor (index = 0; index < ACP_DEVS; index++) {\n\t\tadata->pdev[index] =\n\t\t\t\tplatform_device_register_full(&pdevinfo[index]);\n\t\tif (IS_ERR(adata->pdev[index])) {\n\t\t\tdev_err(&pci->dev, \"cannot register %s device\\n\",\n\t\t\t\tpdevinfo[index].name);\n\t\t\tret = PTR_ERR(adata->pdev[index]);\n\t\t\tgoto unregister_devs;\n\t\t}\n\t}\n\tpm_runtime_set_autosuspend_delay(&pci->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\treturn 0;\n\nunregister_devs:\n\tfor (index = 0; index < ACP_DEVS; index++)\n\t\tplatform_device_unregister(adata->pdev[index]);\nde_init:\n\tif (rn_acp_deinit(adata->acp_base))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\ndisable_msi:\n\tpci_disable_msi(pci);\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int snd_rn_acp_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct acp_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = rn_acp_deinit(adata->acp_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\telse\n\t\tdev_dbg(dev, \"ACP de-initialized\\n\");\n\n\treturn ret;\n}\n\nstatic int snd_rn_acp_resume(struct device *dev)\n{\n\tint ret;\n\tstruct acp_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = rn_acp_init(adata->acp_base);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rn_acp_pm = {\n\t.runtime_suspend = snd_rn_acp_suspend,\n\t.runtime_resume =  snd_rn_acp_resume,\n\t.suspend = snd_rn_acp_suspend,\n\t.resume =\tsnd_rn_acp_resume,\n\t.restore =\tsnd_rn_acp_resume,\n\t.poweroff =\tsnd_rn_acp_suspend,\n};\n\nstatic void snd_rn_acp_remove(struct pci_dev *pci)\n{\n\tstruct acp_dev_data *adata;\n\tint ret, index;\n\n\tadata = pci_get_drvdata(pci);\n\tfor (index = 0; index < ACP_DEVS; index++)\n\t\tplatform_device_unregister(adata->pdev[index]);\n\tret = rn_acp_deinit(adata->acp_base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_disable_msi(pci);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_rn_acp_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_rn_acp_ids);\n\nstatic struct pci_driver rn_acp_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_rn_acp_ids,\n\t.probe = snd_rn_acp_probe,\n\t.remove = snd_rn_acp_remove,\n\t.driver = {\n\t\t.pm = &rn_acp_pm,\n\t}\n};\n\nmodule_pci_driver(rn_acp_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP Renoir PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}