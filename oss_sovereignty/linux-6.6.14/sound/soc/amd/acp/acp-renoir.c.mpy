{
  "module_name": "acp-renoir.c",
  "hash_id": "7c03c62d1cdbcab2f864bf654cd8219a8e781e68d615f8e7afd30aa9877ab37f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-renoir.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n\n#include \"amd.h\"\n\n#define DRV_NAME \"acp_asoc_renoir\"\n\nstatic struct acp_resource rsrc = {\n\t.offset = 20,\n\t.no_of_ctrls = 1,\n\t.irqp_used = 0,\n\t.irq_reg_offset = 0x1800,\n\t.i2s_pin_cfg_offset = 0x1400,\n\t.i2s_mode = 0x04,\n\t.scratch_reg_offset = 0x12800,\n\t.sram_pte_offset = 0x02052800,\n};\n\nstatic struct snd_soc_acpi_codecs amp_rt1019 = {\n\t.num_codecs = 1,\n\t.codecs = {\"10EC1019\"}\n};\n\nstatic struct snd_soc_acpi_codecs amp_max = {\n\t.num_codecs = 1,\n\t.codecs = {\"MX98360A\"}\n};\n\nstatic struct snd_soc_acpi_mach snd_soc_acpi_amd_acp_machines[] = {\n\t{\n\t\t.id = \"10EC5682\",\n\t\t.drv_name = \"acp3xalc56821019\",\n\t\t.machine_quirk = snd_soc_acpi_codec_list,\n\t\t.quirk_data = &amp_rt1019,\n\t},\n\t{\n\t\t.id = \"RTL5682\",\n\t\t.drv_name = \"acp3xalc5682sm98360\",\n\t\t.machine_quirk = snd_soc_acpi_codec_list,\n\t\t.quirk_data = &amp_max,\n\t},\n\t{\n\t\t.id = \"RTL5682\",\n\t\t.drv_name = \"acp3xalc5682s1019\",\n\t\t.machine_quirk = snd_soc_acpi_codec_list,\n\t\t.quirk_data = &amp_rt1019,\n\t},\n\t{\n\t\t.id = \"AMDI1019\",\n\t\t.drv_name = \"renoir-acp\",\n\t},\n\t{},\n};\n\nstatic struct snd_soc_dai_driver acp_renoir_dai[] = {\n{\n\t.name = \"acp-i2s-sp\",\n\t.id = I2S_SP_INSTANCE,\n\t.playback = {\n\t\t.stream_name = \"I2S SP Playback\",\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S SP Capture\",\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &asoc_acp_cpu_dai_ops,\n},\n{\n\t.name = \"acp-i2s-bt\",\n\t.id = I2S_BT_INSTANCE,\n\t.playback = {\n\t\t.stream_name = \"I2S BT Playback\",\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S BT Capture\",\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &asoc_acp_cpu_dai_ops,\n},\n{\n\t.name = \"acp-pdm-dmic\",\n\t.id = DMIC_INSTANCE,\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &acp_dmic_dai_ops,\n},\n};\n\n\nstatic int renoir_audio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acp_chip_info *chip;\n\tstruct acp_dev_data *adata;\n\tstruct resource *res;\n\tint ret;\n\n\tchip = dev_get_platdata(&pdev->dev);\n\tif (!chip || !chip->base) {\n\t\tdev_err(&pdev->dev, \"ACP chip data is NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip->acp_rev != ACP3X_DEV) {\n\t\tdev_err(&pdev->dev, \"Un-supported ACP Revision %d\\n\", chip->acp_rev);\n\t\treturn -ENODEV;\n\t}\n\n\tadata = devm_kzalloc(dev, sizeof(struct acp_dev_data), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"acp_mem\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata->acp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!adata->acp_base)\n\t\treturn -ENOMEM;\n\n\tret = platform_get_irq_byname(pdev, \"acp_dai_irq\");\n\tif (ret < 0)\n\t\treturn ret;\n\tadata->i2s_irq = ret;\n\n\tadata->dev = dev;\n\tadata->dai_driver = acp_renoir_dai;\n\tadata->num_dai = ARRAY_SIZE(acp_renoir_dai);\n\tadata->rsrc = &rsrc;\n\n\tadata->machines = snd_soc_acpi_amd_acp_machines;\n\tacp_machine_select(adata);\n\n\tdev_set_drvdata(dev, adata);\n\tacp_enable_interrupts(adata);\n\tacp_platform_register(dev);\n\n\treturn 0;\n}\n\nstatic void renoir_audio_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\n\tacp_disable_interrupts(adata);\n\tacp_platform_unregister(dev);\n}\n\nstatic struct platform_driver renoir_driver = {\n\t.probe = renoir_audio_probe,\n\t.remove_new = renoir_audio_remove,\n\t.driver = {\n\t\t.name = \"acp_asoc_renoir\",\n\t},\n};\n\nmodule_platform_driver(renoir_driver);\n\nMODULE_DESCRIPTION(\"AMD ACP Renoir Driver\");\nMODULE_IMPORT_NS(SND_SOC_ACP_COMMON);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}