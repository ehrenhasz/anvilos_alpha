{
  "module_name": "acp-rembrandt.c",
  "hash_id": "0203c14cf9006e09332738364b6a9fe7677a64a70051a95d604a0303c511ed40",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-rembrandt.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n\n#include \"amd.h\"\n\n#define DRV_NAME \"acp_asoc_rembrandt\"\n\n#define MP1_C2PMSG_69 0x3B10A14\n#define MP1_C2PMSG_85 0x3B10A54\n#define MP1_C2PMSG_93 0x3B10A74\n#define HOST_BRIDGE_ID 0x14B5\n\nstatic struct acp_resource rsrc = {\n\t.offset = 0,\n\t.no_of_ctrls = 2,\n\t.irqp_used = 1,\n\t.soc_mclk = true,\n\t.irq_reg_offset = 0x1a00,\n\t.i2s_pin_cfg_offset = 0x1440,\n\t.i2s_mode = 0x0a,\n\t.scratch_reg_offset = 0x12800,\n\t.sram_pte_offset = 0x03802800,\n};\n\nstatic struct snd_soc_acpi_codecs amp_rt1019 = {\n\t.num_codecs = 1,\n\t.codecs = {\"10EC1019\"}\n};\n\nstatic struct snd_soc_acpi_codecs amp_max = {\n\t.num_codecs = 1,\n\t.codecs = {\"MX98360A\"}\n};\n\nstatic struct snd_soc_acpi_mach snd_soc_acpi_amd_rmb_acp_machines[] = {\n\t{\n\t\t.id = \"10508825\",\n\t\t.drv_name = \"rmb-nau8825-max\",\n\t\t.machine_quirk = snd_soc_acpi_codec_list,\n\t\t.quirk_data = &amp_max,\n\t},\n\t{\n\t\t.id = \"AMDI0007\",\n\t\t.drv_name = \"rembrandt-acp\",\n\t},\n\t{\n\t\t.id = \"RTL5682\",\n\t\t.drv_name = \"rmb-rt5682s-rt1019\",\n\t\t.machine_quirk = snd_soc_acpi_codec_list,\n\t\t.quirk_data = &amp_rt1019,\n\t},\n\t{},\n};\n\nstatic struct snd_soc_dai_driver acp_rmb_dai[] = {\n{\n\t.name = \"acp-i2s-sp\",\n\t.id = I2S_SP_INSTANCE,\n\t.playback = {\n\t\t.stream_name = \"I2S SP Playback\",\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S SP Capture\",\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &asoc_acp_cpu_dai_ops,\n},\n{\n\t.name = \"acp-i2s-bt\",\n\t.id = I2S_BT_INSTANCE,\n\t.playback = {\n\t\t.stream_name = \"I2S BT Playback\",\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S BT Capture\",\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &asoc_acp_cpu_dai_ops,\n},\n{\n\t.name = \"acp-i2s-hs\",\n\t.id = I2S_HS_INSTANCE,\n\t.playback = {\n\t\t.stream_name = \"I2S HS Playback\",\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S HS Capture\",\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &asoc_acp_cpu_dai_ops,\n},\n{\n\t.name = \"acp-pdm-dmic\",\n\t.id = DMIC_INSTANCE,\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &acp_dmic_dai_ops,\n},\n};\n\nstatic int acp6x_master_clock_generate(struct device *dev)\n{\n\tint data = 0;\n\tstruct pci_dev *smn_dev;\n\n\tsmn_dev = pci_get_device(PCI_VENDOR_ID_AMD, HOST_BRIDGE_ID, NULL);\n\tif (!smn_dev) {\n\t\tdev_err(dev, \"Failed to get host bridge device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsmn_write(smn_dev, MP1_C2PMSG_93, 0);\n\tsmn_write(smn_dev, MP1_C2PMSG_85, 0xC4);\n\tsmn_write(smn_dev, MP1_C2PMSG_69, 0x4);\n\tread_poll_timeout(smn_read, data, data, DELAY_US,\n\t\t\t  ACP_TIMEOUT, false, smn_dev, MP1_C2PMSG_93);\n\treturn 0;\n}\n\nstatic int rembrandt_audio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acp_chip_info *chip;\n\tstruct acp_dev_data *adata;\n\tstruct resource *res;\n\n\tchip = dev_get_platdata(&pdev->dev);\n\tif (!chip || !chip->base) {\n\t\tdev_err(&pdev->dev, \"ACP chip data is NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip->acp_rev != ACP6X_DEV) {\n\t\tdev_err(&pdev->dev, \"Un-supported ACP Revision %d\\n\", chip->acp_rev);\n\t\treturn -ENODEV;\n\t}\n\n\tadata = devm_kzalloc(dev, sizeof(struct acp_dev_data), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"acp_mem\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata->acp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!adata->acp_base)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"acp_dai_irq\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_IRQ FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata->i2s_irq = res->start;\n\tadata->dev = dev;\n\tadata->dai_driver = acp_rmb_dai;\n\tadata->num_dai = ARRAY_SIZE(acp_rmb_dai);\n\tadata->rsrc = &rsrc;\n\n\tadata->machines = snd_soc_acpi_amd_rmb_acp_machines;\n\tacp_machine_select(adata);\n\n\tdev_set_drvdata(dev, adata);\n\tacp6x_master_clock_generate(dev);\n\tacp_enable_interrupts(adata);\n\tacp_platform_register(dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic void rembrandt_audio_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\n\tacp_disable_interrupts(adata);\n\tacp_platform_unregister(dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused rmb_pcm_resume(struct device *dev)\n{\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_stream *stream;\n\tstruct snd_pcm_substream *substream;\n\tsnd_pcm_uframes_t buf_in_frames;\n\tu64 buf_size;\n\n\tacp6x_master_clock_generate(dev);\n\tspin_lock(&adata->acp_lock);\n\tlist_for_each_entry(stream, &adata->stream_list, list) {\n\t\tsubstream = stream->substream;\n\t\tif (substream && substream->runtime) {\n\t\t\tbuf_in_frames = (substream->runtime->buffer_size);\n\t\t\tbuf_size = frames_to_bytes(substream->runtime, buf_in_frames);\n\t\t\tconfig_pte_for_stream(adata, stream);\n\t\t\tconfig_acp_dma(adata, stream, buf_size);\n\t\t\tif (stream->dai_id)\n\t\t\t\trestore_acp_i2s_params(substream, adata, stream);\n\t\t\telse\n\t\t\t\trestore_acp_pdm_params(substream, adata);\n\t\t}\n\t}\n\tspin_unlock(&adata->acp_lock);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rmb_dma_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, rmb_pcm_resume)\n};\n\nstatic struct platform_driver rembrandt_driver = {\n\t.probe = rembrandt_audio_probe,\n\t.remove_new = rembrandt_audio_remove,\n\t.driver = {\n\t\t.name = \"acp_asoc_rembrandt\",\n\t\t.pm = &rmb_dma_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rembrandt_driver);\n\nMODULE_DESCRIPTION(\"AMD ACP Rembrandt Driver\");\nMODULE_IMPORT_NS(SND_SOC_ACP_COMMON);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}