{
  "module_name": "amd.h",
  "hash_id": "09f74ae7491abd7b26704509a6ea6fb2cfdeb0af1880efb6c1da96870f05fe07",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/amd.h",
  "human_readable_source": " \n \n\n#ifndef __AMD_ACP_H\n#define __AMD_ACP_H\n\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-dai.h>\n\n#include \"chip_offset_byte.h\"\n\n#define ACP3X_DEV\t\t\t3\n#define ACP6X_DEV\t\t\t6\n\n#define DMIC_INSTANCE\t\t\t0x00\n#define I2S_SP_INSTANCE\t\t\t0x01\n#define I2S_BT_INSTANCE\t\t\t0x02\n#define I2S_HS_INSTANCE\t\t\t0x03\n\n#define MEM_WINDOW_START\t\t0x4080000\n\n#define ACP_I2S_REG_START\t\t0x1242400\n#define ACP_I2S_REG_END\t\t\t0x1242810\n#define ACP3x_I2STDM_REG_START\t\t0x1242400\n#define ACP3x_I2STDM_REG_END\t\t0x1242410\n#define ACP3x_BT_TDM_REG_START\t\t0x1242800\n#define ACP3x_BT_TDM_REG_END\t\t0x1242810\n\n#define THRESHOLD(bit, base)\t((bit) + (base))\n#define I2S_RX_THRESHOLD(base)\tTHRESHOLD(7, base)\n#define I2S_TX_THRESHOLD(base)\tTHRESHOLD(8, base)\n#define BT_TX_THRESHOLD(base)\tTHRESHOLD(6, base)\n#define BT_RX_THRESHOLD(base)\tTHRESHOLD(5, base)\n#define HS_TX_THRESHOLD(base)\tTHRESHOLD(4, base)\n#define HS_RX_THRESHOLD(base)\tTHRESHOLD(3, base)\n\n#define ACP_SRAM_SP_PB_PTE_OFFSET\t0x0\n#define ACP_SRAM_SP_CP_PTE_OFFSET\t0x100\n#define ACP_SRAM_BT_PB_PTE_OFFSET\t0x200\n#define ACP_SRAM_BT_CP_PTE_OFFSET\t0x300\n#define ACP_SRAM_PDM_PTE_OFFSET\t\t0x400\n#define ACP_SRAM_HS_PB_PTE_OFFSET       0x500\n#define ACP_SRAM_HS_CP_PTE_OFFSET       0x600\n#define PAGE_SIZE_4K_ENABLE\t\t0x2\n\n#define I2S_SP_TX_MEM_WINDOW_START\t0x4000000\n#define I2S_SP_RX_MEM_WINDOW_START\t0x4020000\n#define I2S_BT_TX_MEM_WINDOW_START\t0x4040000\n#define I2S_BT_RX_MEM_WINDOW_START\t0x4060000\n#define I2S_HS_TX_MEM_WINDOW_START      0x40A0000\n#define I2S_HS_RX_MEM_WINDOW_START      0x40C0000\n\n#define SP_PB_FIFO_ADDR_OFFSET\t\t0x500\n#define SP_CAPT_FIFO_ADDR_OFFSET\t0x700\n#define BT_PB_FIFO_ADDR_OFFSET\t\t0x900\n#define BT_CAPT_FIFO_ADDR_OFFSET\t0xB00\n#define HS_PB_FIFO_ADDR_OFFSET\t\t0xD00\n#define HS_CAPT_FIFO_ADDR_OFFSET\t0xF00\n#define PLAYBACK_MIN_NUM_PERIODS\t2\n#define PLAYBACK_MAX_NUM_PERIODS\t8\n#define PLAYBACK_MAX_PERIOD_SIZE\t8192\n#define PLAYBACK_MIN_PERIOD_SIZE\t1024\n#define CAPTURE_MIN_NUM_PERIODS\t\t2\n#define CAPTURE_MAX_NUM_PERIODS\t\t8\n#define CAPTURE_MAX_PERIOD_SIZE\t\t8192\n#define CAPTURE_MIN_PERIOD_SIZE\t\t1024\n\n#define MAX_BUFFER\t\t\t65536\n#define MIN_BUFFER\t\t\tMAX_BUFFER\n#define FIFO_SIZE\t\t\t0x100\n#define DMA_SIZE\t\t\t0x40\n#define FRM_LEN\t\t\t\t0x100\n\n#define ACP3x_ITER_IRER_SAMP_LEN_MASK\t0x38\n\n#define ACP_MAX_STREAM\t\t\t8\n\n#define TDM_ENABLE\t1\n#define TDM_DISABLE\t0\n\n#define SLOT_WIDTH_8\t0x8\n#define SLOT_WIDTH_16\t0x10\n#define SLOT_WIDTH_24\t0x18\n#define SLOT_WIDTH_32\t0x20\n\n#define ACP6X_PGFSM_CONTROL                     0x1024\n#define ACP6X_PGFSM_STATUS                      0x1028\n\n#define ACP_SOFT_RST_DONE_MASK\t0x00010001\n\n#define ACP_PGFSM_CNTL_POWER_ON_MASK            0x01\n#define ACP_PGFSM_CNTL_POWER_OFF_MASK           0x00\n#define ACP_PGFSM_STATUS_MASK                   0x03\n#define ACP_POWERED_ON                          0x00\n#define ACP_POWER_ON_IN_PROGRESS                0x01\n#define ACP_POWERED_OFF                         0x02\n#define ACP_POWER_OFF_IN_PROGRESS               0x03\n\n#define ACP_ERROR_MASK                          0x20000000\n#define ACP_EXT_INTR_STAT_CLEAR_MASK            0xffffffff\n\n#define ACP_TIMEOUT\t\t500\n#define DELAY_US\t\t5\n#define ACP_SUSPEND_DELAY_MS   2000\n\n#define PDM_DMA_STAT            0x10\n#define PDM_DMA_INTR_MASK       0x10000\n#define PDM_DEC_64              0x2\n#define PDM_CLK_FREQ_MASK       0x07\n#define PDM_MISC_CTRL_MASK      0x10\n#define PDM_ENABLE              0x01\n#define PDM_DISABLE             0x00\n#define DMA_EN_MASK             0x02\n#define DELAY_US                5\n#define PDM_TIMEOUT             1000\n#define ACP_REGION2_OFFSET      0x02000000\n\nstruct acp_chip_info {\n\tchar *name;\t\t \n\tunsigned int acp_rev;\t \n\tvoid __iomem *base;\t \n\tstruct platform_device *chip_pdev;\n};\n\nstruct acp_stream {\n\tstruct list_head list;\n\tstruct snd_pcm_substream *substream;\n\tint irq_bit;\n\tint dai_id;\n\tint id;\n\tint dir;\n\tu64 bytescount;\n\tu32 reg_offset;\n\tu32 pte_offset;\n\tu32 fifo_offset;\n};\n\nstruct acp_resource {\n\tint offset;\n\tint no_of_ctrls;\n\tint irqp_used;\n\tbool soc_mclk;\n\tu32 irq_reg_offset;\n\tu32 i2s_pin_cfg_offset;\n\tint i2s_mode;\n\tu64 scratch_reg_offset;\n\tu64 sram_pte_offset;\n};\n\nstruct acp_dev_data {\n\tchar *name;\n\tstruct device *dev;\n\tvoid __iomem *acp_base;\n\tunsigned int i2s_irq;\n\n\tbool tdm_mode;\n\t \n\tstruct snd_soc_dai_driver *dai_driver;\n\tint num_dai;\n\n\tstruct list_head stream_list;\n\tspinlock_t acp_lock;\n\n\tstruct snd_soc_acpi_mach *machines;\n\tstruct platform_device *mach_dev;\n\n\tu32 bclk_div;\n\tu32 lrclk_div;\n\n\tstruct acp_resource *rsrc;\n\tu32 ch_mask;\n\tu32 tdm_tx_fmt[3];\n\tu32 tdm_rx_fmt[3];\n\tu32 xfer_tx_resolution[3];\n\tu32 xfer_rx_resolution[3];\n};\n\nunion acp_i2stdm_mstrclkgen {\n\tstruct {\n\t\tu32 i2stdm_master_mode : 1;\n\t\tu32 i2stdm_format_mode : 1;\n\t\tu32 i2stdm_lrclk_div_val : 9;\n\t\tu32 i2stdm_bclk_div_val : 11;\n\t\tu32:10;\n\t} bitfields, bits;\n\tu32  u32_all;\n};\n\nextern const struct snd_soc_dai_ops asoc_acp_cpu_dai_ops;\nextern const struct snd_soc_dai_ops acp_dmic_dai_ops;\n\nint acp_platform_register(struct device *dev);\nint acp_platform_unregister(struct device *dev);\n\nint acp_machine_select(struct acp_dev_data *adata);\n\nint smn_read(struct pci_dev *dev, u32 smn_addr);\nint smn_write(struct pci_dev *dev, u32 smn_addr, u32 data);\n\nint acp_init(struct acp_chip_info *chip);\nint acp_deinit(void __iomem *base);\nvoid acp_enable_interrupts(struct acp_dev_data *adata);\nvoid acp_disable_interrupts(struct acp_dev_data *adata);\n \nint snd_amd_acp_find_config(struct pci_dev *pci);\n\nvoid config_pte_for_stream(struct acp_dev_data *adata, struct acp_stream *stream);\nvoid config_acp_dma(struct acp_dev_data *adata, struct acp_stream *stream, int size);\nvoid restore_acp_pdm_params(struct snd_pcm_substream *substream,\n\t\t\t    struct acp_dev_data *adata);\n\nint restore_acp_i2s_params(struct snd_pcm_substream *substream,\n\t\t\t   struct acp_dev_data *adata, struct acp_stream *stream);\n\nstatic inline u64 acp_get_byte_count(struct acp_dev_data *adata, int dai_id, int direction)\n{\n\tu64 byte_count = 0, low = 0, high = 0;\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (dai_id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_BT_TX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_BT_TX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_I2S_TX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_I2S_TX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_HS_TX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_HS_TX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adata->dev, \"Invalid dai id %x\\n\", dai_id);\n\t\t\tgoto POINTER_RETURN_BYTES;\n\t\t}\n\t} else {\n\t\tswitch (dai_id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_BT_RX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_BT_RX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_I2S_RX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_I2S_RX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_HS_RX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_HS_RX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tcase DMIC_INSTANCE:\n\t\t\thigh = readl(adata->acp_base + ACP_WOV_RX_LINEARPOSITIONCNTR_HIGH);\n\t\t\tlow = readl(adata->acp_base + ACP_WOV_RX_LINEARPOSITIONCNTR_LOW);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(adata->dev, \"Invalid dai id %x\\n\", dai_id);\n\t\t\tgoto POINTER_RETURN_BYTES;\n\t\t}\n\t}\n\t \n\tbyte_count = (high << 32) | low;\n\nPOINTER_RETURN_BYTES:\n\treturn byte_count;\n}\n\nstatic inline void acp_set_i2s_clk(struct acp_dev_data *adata, int dai_id)\n{\n\tunion acp_i2stdm_mstrclkgen mclkgen;\n\tu32 master_reg;\n\n\tswitch (dai_id) {\n\tcase I2S_SP_INSTANCE:\n\t\tmaster_reg = ACP_I2STDM0_MSTRCLKGEN;\n\t\tbreak;\n\tcase I2S_BT_INSTANCE:\n\t\tmaster_reg = ACP_I2STDM1_MSTRCLKGEN;\n\t\tbreak;\n\tcase I2S_HS_INSTANCE:\n\t\tmaster_reg = ACP_I2STDM2_MSTRCLKGEN;\n\t\tbreak;\n\tdefault:\n\t\tmaster_reg = ACP_I2STDM0_MSTRCLKGEN;\n\t\tbreak;\n\t}\n\n\tmclkgen.bits.i2stdm_master_mode = 0x1;\n\tmclkgen.bits.i2stdm_format_mode = 0x00;\n\n\tmclkgen.bits.i2stdm_bclk_div_val = adata->bclk_div;\n\tmclkgen.bits.i2stdm_lrclk_div_val = adata->lrclk_div;\n\twritel(mclkgen.u32_all, adata->acp_base + master_reg);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}