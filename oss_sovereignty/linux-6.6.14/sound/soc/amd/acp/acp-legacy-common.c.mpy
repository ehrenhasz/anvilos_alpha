{
  "module_name": "acp-legacy-common.c",
  "hash_id": "c4fa702b8f5560a88cc9c4f551385e3ecd2d6a1cbdca314a6ef1a6293014bc5f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-legacy-common.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include \"amd.h\"\n#include <linux/pci.h>\n#include <linux/export.h>\n\nvoid acp_enable_interrupts(struct acp_dev_data *adata)\n{\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tu32 ext_intr_ctrl;\n\n\twritel(0x01, ACP_EXTERNAL_INTR_ENB(adata));\n\text_intr_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n\text_intr_ctrl |= ACP_ERROR_MASK;\n\twritel(ext_intr_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n}\nEXPORT_SYMBOL_NS_GPL(acp_enable_interrupts, SND_SOC_ACP_COMMON);\n\nvoid acp_disable_interrupts(struct acp_dev_data *adata)\n{\n\tstruct acp_resource *rsrc = adata->rsrc;\n\n\twritel(ACP_EXT_INTR_STAT_CLEAR_MASK, ACP_EXTERNAL_INTR_STAT(adata, rsrc->irqp_used));\n\twritel(0x00, ACP_EXTERNAL_INTR_ENB(adata));\n}\nEXPORT_SYMBOL_NS_GPL(acp_disable_interrupts, SND_SOC_ACP_COMMON);\n\nstatic void set_acp_pdm_ring_buffer(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct acp_stream *stream = runtime->private_data;\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\n\tu32 physical_addr, pdm_size, period_bytes;\n\n\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\tpdm_size = frames_to_bytes(runtime, runtime->buffer_size);\n\tphysical_addr = stream->reg_offset + MEM_WINDOW_START;\n\n\t \n\twritel(physical_addr, adata->acp_base + ACP_WOV_RX_RINGBUFADDR);\n\twritel(pdm_size, adata->acp_base + ACP_WOV_RX_RINGBUFSIZE);\n\twritel(period_bytes, adata->acp_base + ACP_WOV_RX_INTR_WATERMARK_SIZE);\n\twritel(0x01, adata->acp_base + ACPAXI2AXI_ATU_CTRL);\n}\n\nstatic void set_acp_pdm_clk(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tunsigned int pdm_ctrl;\n\n\t \n\twritel(PDM_CLK_FREQ_MASK, adata->acp_base + ACP_WOV_CLK_CTRL);\n\tpdm_ctrl = readl(adata->acp_base + ACP_WOV_MISC_CTRL);\n\tpdm_ctrl |= PDM_MISC_CTRL_MASK;\n\twritel(pdm_ctrl, adata->acp_base + ACP_WOV_MISC_CTRL);\n\tset_acp_pdm_ring_buffer(substream, dai);\n}\n\nvoid restore_acp_pdm_params(struct snd_pcm_substream *substream,\n\t\t\t    struct acp_dev_data *adata)\n{\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_pcm_runtime *soc_runtime;\n\tu32 ext_int_ctrl;\n\n\tsoc_runtime = asoc_substream_to_rtd(substream);\n\tdai = asoc_rtd_to_cpu(soc_runtime, 0);\n\t \n\twritel(adata->ch_mask, adata->acp_base + ACP_WOV_PDM_NO_OF_CHANNELS);\n\twritel(PDM_DEC_64, adata->acp_base + ACP_WOV_PDM_DECIMATION_FACTOR);\n\n\t \n\text_int_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, 0));\n\text_int_ctrl |= PDM_DMA_INTR_MASK;\n\twritel(ext_int_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, 0));\n\tset_acp_pdm_clk(substream, dai);\n}\nEXPORT_SYMBOL_NS_GPL(restore_acp_pdm_params, SND_SOC_ACP_COMMON);\n\nstatic int set_acp_i2s_dma_fifo(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tu32 reg_dma_size, reg_fifo_size, reg_fifo_addr;\n\tu32 phy_addr, acp_fifo_addr, ext_int_ctrl;\n\tunsigned int dir = substream->stream;\n\n\tswitch (dai->driver->id) {\n\tcase I2S_SP_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_I2S_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tSP_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_I2S_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_I2S_TX_FIFOSIZE;\n\t\t\tphy_addr = I2S_SP_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_I2S_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_I2S_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tSP_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_I2S_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_I2S_RX_FIFOSIZE;\n\t\t\tphy_addr = I2S_SP_RX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_I2S_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tcase I2S_BT_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_BT_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tBT_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_BT_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_BT_TX_FIFOSIZE;\n\t\t\tphy_addr = I2S_BT_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_BT_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_BT_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tBT_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_BT_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_BT_RX_FIFOSIZE;\n\t\t\tphy_addr = I2S_BT_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_BT_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tcase I2S_HS_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_HS_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tHS_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_HS_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_HS_TX_FIFOSIZE;\n\t\t\tphy_addr = I2S_HS_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_HS_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_HS_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tHS_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_HS_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_HS_RX_FIFOSIZE;\n\t\t\tphy_addr = I2S_HS_RX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_HS_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(DMA_SIZE, adata->acp_base + reg_dma_size);\n\twritel(acp_fifo_addr, adata->acp_base + reg_fifo_addr);\n\twritel(FIFO_SIZE, adata->acp_base + reg_fifo_size);\n\n\text_int_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n\text_int_ctrl |= BIT(I2S_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(BT_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(I2S_TX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(BT_TX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(HS_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(HS_TX_THRESHOLD(rsrc->offset));\n\n\twritel(ext_int_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n\treturn 0;\n}\n\nint restore_acp_i2s_params(struct snd_pcm_substream *substream,\n\t\t\t   struct acp_dev_data *adata,\n\t\t\t   struct acp_stream *stream)\n{\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_pcm_runtime *soc_runtime;\n\tu32 tdm_fmt, reg_val, fmt_reg, val;\n\n\tsoc_runtime = asoc_substream_to_rtd(substream);\n\tdai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\ttdm_fmt = adata->tdm_tx_fmt[stream->dai_id - 1];\n\t\tswitch (stream->dai_id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = ACP_BTTDM_ITER;\n\t\t\tfmt_reg = ACP_BTTDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\tfmt_reg = ACP_I2STDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\tfmt_reg = ACP_HSTDM_TXFRMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid dai id %x\\n\", stream->dai_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = adata->xfer_tx_resolution[stream->dai_id - 1] << 3;\n\t} else {\n\t\ttdm_fmt = adata->tdm_rx_fmt[stream->dai_id - 1];\n\t\tswitch (stream->dai_id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = ACP_BTTDM_IRER;\n\t\t\tfmt_reg = ACP_BTTDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\tfmt_reg = ACP_I2STDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\tfmt_reg = ACP_HSTDM_RXFRMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid dai id %x\\n\", stream->dai_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = adata->xfer_rx_resolution[stream->dai_id - 1] << 3;\n\t}\n\twritel(val, adata->acp_base + reg_val);\n\tif (adata->tdm_mode == TDM_ENABLE) {\n\t\twritel(tdm_fmt, adata->acp_base + fmt_reg);\n\t\tval = readl(adata->acp_base + reg_val);\n\t\twritel(val | 0x2, adata->acp_base + reg_val);\n\t}\n\treturn set_acp_i2s_dma_fifo(substream, dai);\n}\nEXPORT_SYMBOL_NS_GPL(restore_acp_i2s_params, SND_SOC_ACP_COMMON);\n\nstatic int acp_power_on(struct acp_chip_info *chip)\n{\n\tu32 val, acp_pgfsm_stat_reg, acp_pgfsm_ctrl_reg;\n\tvoid __iomem *base;\n\n\tbase = chip->base;\n\tswitch (chip->acp_rev) {\n\tcase ACP3X_DEV:\n\t\tacp_pgfsm_stat_reg = ACP_PGFSM_STATUS;\n\t\tacp_pgfsm_ctrl_reg = ACP_PGFSM_CONTROL;\n\t\tbreak;\n\tcase ACP6X_DEV:\n\t\tacp_pgfsm_stat_reg = ACP6X_PGFSM_STATUS;\n\t\tacp_pgfsm_ctrl_reg = ACP6X_PGFSM_CONTROL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(base + acp_pgfsm_stat_reg);\n\tif (val == ACP_POWERED_ON)\n\t\treturn 0;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) != ACP_POWER_ON_IN_PROGRESS)\n\t\twritel(ACP_PGFSM_CNTL_POWER_ON_MASK, base + acp_pgfsm_ctrl_reg);\n\n\treturn readl_poll_timeout(base + acp_pgfsm_stat_reg, val,\n\t\t\t\t  !val, DELAY_US, ACP_TIMEOUT);\n}\n\nstatic int acp_reset(void __iomem *base)\n{\n\tu32 val;\n\tint ret;\n\n\twritel(1, base + ACP_SOFT_RESET);\n\tret = readl_poll_timeout(base + ACP_SOFT_RESET, val, val & ACP_SOFT_RST_DONE_MASK,\n\t\t\t\t DELAY_US, ACP_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(0, base + ACP_SOFT_RESET);\n\treturn readl_poll_timeout(base + ACP_SOFT_RESET, val, !val, DELAY_US, ACP_TIMEOUT);\n}\n\nint acp_init(struct acp_chip_info *chip)\n{\n\tint ret;\n\n\t \n\tret = acp_power_on(chip);\n\tif (ret) {\n\t\tpr_err(\"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\twritel(0x01, chip->base + ACP_CONTROL);\n\n\t \n\tret = acp_reset(chip->base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_init, SND_SOC_ACP_COMMON);\n\nint acp_deinit(void __iomem *base)\n{\n\tint ret;\n\n\t \n\tret = acp_reset(base);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(0, base + ACP_CONTROL);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_deinit, SND_SOC_ACP_COMMON);\n\nint smn_write(struct pci_dev *dev, u32 smn_addr, u32 data)\n{\n\tpci_write_config_dword(dev, 0x60, smn_addr);\n\tpci_write_config_dword(dev, 0x64, data);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(smn_write, SND_SOC_ACP_COMMON);\n\nint smn_read(struct pci_dev *dev, u32 smn_addr)\n{\n\tu32 data;\n\n\tpci_write_config_dword(dev, 0x60, smn_addr);\n\tpci_read_config_dword(dev, 0x64, &data);\n\treturn data;\n}\nEXPORT_SYMBOL_NS_GPL(smn_read, SND_SOC_ACP_COMMON);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}