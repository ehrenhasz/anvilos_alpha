{
  "module_name": "acp-i2s.c",
  "hash_id": "2d38563cc4833578378c921cbe9010ccbf02cfecb0143eca97a9449378aaea22",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-i2s.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n\n#include \"amd.h\"\n\n#define DRV_NAME \"acp_i2s_playcap\"\n\nstatic int acp_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t   unsigned int fmt)\n{\n\tstruct acp_dev_data *adata = snd_soc_dai_get_drvdata(cpu_dai);\n\tint mode;\n\n\tmode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\tswitch (mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tadata->tdm_mode = TDM_DISABLE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tadata->tdm_mode = TDM_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int acp_i2s_set_tdm_slot(struct snd_soc_dai *dai, u32 tx_mask, u32 rx_mask,\n\t\t\t\tint slots, int slot_width)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = snd_soc_dai_get_drvdata(dai);\n\tstruct acp_stream *stream;\n\tint slot_len, no_of_slots;\n\n\tswitch (slot_width) {\n\tcase SLOT_WIDTH_8:\n\t\tslot_len = 8;\n\t\tbreak;\n\tcase SLOT_WIDTH_16:\n\t\tslot_len = 16;\n\t\tbreak;\n\tcase SLOT_WIDTH_24:\n\t\tslot_len = 24;\n\t\tbreak;\n\tcase SLOT_WIDTH_32:\n\t\tslot_len = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported bitdepth %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slots) {\n\tcase 1 ... 7:\n\t\tno_of_slots = slots;\n\t\tbreak;\n\tcase 8:\n\t\tno_of_slots = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported slots %d\\n\", slots);\n\t\treturn -EINVAL;\n\t}\n\n\tslots = no_of_slots;\n\n\tspin_lock_irq(&adata->acp_lock);\n\tlist_for_each_entry(stream, &adata->stream_list, list) {\n\t\tif (tx_mask && stream->dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tadata->tdm_tx_fmt[stream->dai_id - 1] =\n\t\t\t\t\tFRM_LEN | (slots << 15) | (slot_len << 18);\n\t\telse if (rx_mask && stream->dir == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tadata->tdm_rx_fmt[stream->dai_id - 1] =\n\t\t\t\t\tFRM_LEN | (slots << 15) | (slot_len << 18);\n\t}\n\tspin_unlock_irq(&adata->acp_lock);\n\treturn 0;\n}\n\nstatic int acp_i2s_hwparams(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata;\n\tstruct acp_resource *rsrc;\n\tu32 val;\n\tu32 xfer_resolution;\n\tu32 reg_val, fmt_reg, tdm_fmt;\n\tu32 lrclk_div_val, bclk_div_val;\n\n\tadata = snd_soc_dai_get_drvdata(dai);\n\trsrc = adata->rsrc;\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\txfer_resolution = 0x0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\txfer_resolution = 0x02;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\txfer_resolution = 0x04;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\txfer_resolution = 0x05;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (dai->driver->id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = ACP_BTTDM_ITER;\n\t\t\tfmt_reg = ACP_BTTDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\tfmt_reg = ACP_I2STDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\tfmt_reg = ACP_HSTDM_TXFRMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tadata->xfer_tx_resolution[dai->driver->id - 1] = xfer_resolution;\n\t} else {\n\t\tswitch (dai->driver->id) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = ACP_BTTDM_IRER;\n\t\t\tfmt_reg = ACP_BTTDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\tfmt_reg = ACP_I2STDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\tfmt_reg = ACP_HSTDM_RXFRMT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tadata->xfer_rx_resolution[dai->driver->id - 1] = xfer_resolution;\n\t}\n\n\tval = readl(adata->acp_base + reg_val);\n\tval &= ~ACP3x_ITER_IRER_SAMP_LEN_MASK;\n\tval = val | (xfer_resolution  << 3);\n\twritel(val, adata->acp_base + reg_val);\n\n\tif (adata->tdm_mode) {\n\t\tval = readl(adata->acp_base + reg_val);\n\t\twritel(val | BIT(1), adata->acp_base + reg_val);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ttdm_fmt = adata->tdm_tx_fmt[dai->driver->id - 1];\n\t\telse\n\t\t\ttdm_fmt = adata->tdm_rx_fmt[dai->driver->id - 1];\n\t\twritel(tdm_fmt, adata->acp_base + fmt_reg);\n\t}\n\n\tif (rsrc->soc_mclk) {\n\t\tswitch (params_format(params)) {\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tswitch (params_rate(params)) {\n\t\t\tcase 8000:\n\t\t\t\tbclk_div_val = 768;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\tbclk_div_val = 384;\n\t\t\t\tbreak;\n\t\t\tcase 24000:\n\t\t\t\tbclk_div_val = 256;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\tbclk_div_val = 192;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\tcase 48000:\n\t\t\t\tbclk_div_val = 128;\n\t\t\t\tbreak;\n\t\t\tcase 88200:\n\t\t\tcase 96000:\n\t\t\t\tbclk_div_val = 64;\n\t\t\t\tbreak;\n\t\t\tcase 192000:\n\t\t\t\tbclk_div_val = 32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlrclk_div_val = 32;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t\tswitch (params_rate(params)) {\n\t\t\tcase 8000:\n\t\t\t\tbclk_div_val = 384;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\tbclk_div_val = 192;\n\t\t\t\tbreak;\n\t\t\tcase 24000:\n\t\t\t\tbclk_div_val = 128;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\tbclk_div_val = 96;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\tcase 48000:\n\t\t\t\tbclk_div_val = 64;\n\t\t\t\tbreak;\n\t\t\tcase 88200:\n\t\t\tcase 96000:\n\t\t\t\tbclk_div_val = 32;\n\t\t\t\tbreak;\n\t\t\tcase 192000:\n\t\t\t\tbclk_div_val = 16;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlrclk_div_val = 64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tadata->lrclk_div = lrclk_div_val;\n\t\tadata->bclk_div = bclk_div_val;\n\t}\n\treturn 0;\n}\n\nstatic int acp_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tu32 val, period_bytes, reg_val, ier_val, water_val, buf_size, buf_reg;\n\n\tperiod_bytes = frames_to_bytes(substream->runtime, substream->runtime->period_size);\n\tbuf_size = frames_to_bytes(substream->runtime, substream->runtime->buffer_size);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tstream->bytescount = acp_get_byte_count(adata, stream->dai_id, substream->stream);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (dai->driver->id) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\twater_val = ACP_BT_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_BTTDM_ITER;\n\t\t\t\tier_val = ACP_BTTDM_IER;\n\t\t\t\tbuf_reg = ACP_BT_TX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\t\twater_val = ACP_I2S_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\t\tier_val = ACP_I2STDM_IER;\n\t\t\t\tbuf_reg = ACP_I2S_TX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\twater_val = ACP_HS_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\t\tier_val = ACP_HSTDM_IER;\n\t\t\t\tbuf_reg = ACP_HS_TX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dai->driver->id) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\twater_val = ACP_BT_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_BTTDM_IRER;\n\t\t\t\tier_val = ACP_BTTDM_IER;\n\t\t\t\tbuf_reg = ACP_BT_RX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\t\twater_val = ACP_I2S_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\t\tier_val = ACP_I2STDM_IER;\n\t\t\t\tbuf_reg = ACP_I2S_RX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\twater_val = ACP_HS_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\t\tier_val = ACP_HSTDM_IER;\n\t\t\t\tbuf_reg = ACP_HS_RX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twritel(period_bytes, adata->acp_base + water_val);\n\t\twritel(buf_size, adata->acp_base + buf_reg);\n\t\tval = readl(adata->acp_base + reg_val);\n\t\tval = val | BIT(0);\n\t\twritel(val, adata->acp_base + reg_val);\n\t\twritel(1, adata->acp_base + ier_val);\n\t\tif (rsrc->soc_mclk)\n\t\t\tacp_set_i2s_clk(adata, dai->driver->id);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (dai->driver->id) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\treg_val = ACP_BTTDM_ITER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch (dai->driver->id) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\treg_val = ACP_BTTDM_IRER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tval = readl(adata->acp_base + reg_val);\n\t\tval = val & ~BIT(0);\n\t\twritel(val, adata->acp_base + reg_val);\n\n\t\tif (!(readl(adata->acp_base + ACP_BTTDM_ITER) & BIT(0)) &&\n\t\t    !(readl(adata->acp_base + ACP_BTTDM_IRER) & BIT(0)))\n\t\t\twritel(0, adata->acp_base + ACP_BTTDM_IER);\n\t\tif (!(readl(adata->acp_base + ACP_I2STDM_ITER) & BIT(0)) &&\n\t\t    !(readl(adata->acp_base + ACP_I2STDM_IRER) & BIT(0)))\n\t\t\twritel(0, adata->acp_base + ACP_I2STDM_IER);\n\t\tif (!(readl(adata->acp_base + ACP_HSTDM_ITER) & BIT(0)) &&\n\t\t    !(readl(adata->acp_base + ACP_HSTDM_IRER) & BIT(0)))\n\t\t\twritel(0, adata->acp_base + ACP_HSTDM_IER);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int acp_i2s_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tu32 reg_dma_size = 0, reg_fifo_size = 0, reg_fifo_addr = 0;\n\tu32 phy_addr = 0, acp_fifo_addr = 0, ext_int_ctrl;\n\tunsigned int dir = substream->stream;\n\n\tswitch (dai->driver->id) {\n\tcase I2S_SP_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_I2S_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\t\tSP_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr =\tACP_I2S_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_I2S_TX_FIFOSIZE;\n\n\t\t\tphy_addr = I2S_SP_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_I2S_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_I2S_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\t\tSP_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_I2S_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_I2S_RX_FIFOSIZE;\n\t\t\tphy_addr = I2S_SP_RX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_I2S_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tcase I2S_BT_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_BT_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\t\tBT_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_BT_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_BT_TX_FIFOSIZE;\n\n\t\t\tphy_addr = I2S_BT_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_BT_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_BT_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\t\tBT_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_BT_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_BT_RX_FIFOSIZE;\n\n\t\t\tphy_addr = I2S_BT_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_BT_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tcase I2S_HS_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\treg_dma_size = ACP_HS_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\tHS_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_HS_TX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_HS_TX_FIFOSIZE;\n\n\t\t\tphy_addr = I2S_HS_TX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_HS_TX_RINGBUFADDR);\n\t\t} else {\n\t\t\treg_dma_size = ACP_HS_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = rsrc->sram_pte_offset +\n\t\t\t\t\tHS_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = ACP_HS_RX_FIFOADDR;\n\t\t\treg_fifo_size = ACP_HS_RX_FIFOSIZE;\n\n\t\t\tphy_addr = I2S_HS_RX_MEM_WINDOW_START + stream->reg_offset;\n\t\t\twritel(phy_addr, adata->acp_base + ACP_HS_RX_RINGBUFADDR);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(DMA_SIZE, adata->acp_base + reg_dma_size);\n\twritel(acp_fifo_addr, adata->acp_base + reg_fifo_addr);\n\twritel(FIFO_SIZE, adata->acp_base + reg_fifo_size);\n\n\text_int_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n\text_int_ctrl |= BIT(I2S_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(BT_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(I2S_TX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(BT_TX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(HS_RX_THRESHOLD(rsrc->offset)) |\n\t\t\tBIT(HS_TX_THRESHOLD(rsrc->offset));\n\n\twritel(ext_int_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, rsrc->irqp_used));\n\n\treturn 0;\n}\n\nstatic int acp_i2s_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tunsigned int dir = substream->stream;\n\tunsigned int irq_bit = 0;\n\n\tswitch (dai->driver->id) {\n\tcase I2S_SP_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tirq_bit = BIT(I2S_TX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_SP_PB_PTE_OFFSET;\n\t\t\tstream->fifo_offset = SP_PB_FIFO_ADDR_OFFSET;\n\t\t} else {\n\t\t\tirq_bit = BIT(I2S_RX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_SP_CP_PTE_OFFSET;\n\t\t\tstream->fifo_offset = SP_CAPT_FIFO_ADDR_OFFSET;\n\t\t}\n\t\tbreak;\n\tcase I2S_BT_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tirq_bit = BIT(BT_TX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_BT_PB_PTE_OFFSET;\n\t\t\tstream->fifo_offset = BT_PB_FIFO_ADDR_OFFSET;\n\t\t} else {\n\t\t\tirq_bit = BIT(BT_RX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_BT_CP_PTE_OFFSET;\n\t\t\tstream->fifo_offset = BT_CAPT_FIFO_ADDR_OFFSET;\n\t\t}\n\t\tbreak;\n\tcase I2S_HS_INSTANCE:\n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tirq_bit = BIT(HS_TX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_HS_PB_PTE_OFFSET;\n\t\t\tstream->fifo_offset = HS_PB_FIFO_ADDR_OFFSET;\n\t\t} else {\n\t\t\tirq_bit = BIT(HS_RX_THRESHOLD(rsrc->offset));\n\t\t\tstream->pte_offset = ACP_SRAM_HS_CP_PTE_OFFSET;\n\t\t\tstream->fifo_offset = HS_CAPT_FIFO_ADDR_OFFSET;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid dai id %x\\n\", dai->driver->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstream->id = dai->driver->id + dir;\n\tstream->dai_id = dai->driver->id;\n\tstream->irq_bit = irq_bit;\n\tstream->dir = substream->stream;\n\n\treturn 0;\n}\n\nstatic int acp_i2s_probe(struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tunsigned int val;\n\n\tif (!adata->acp_base) {\n\t\tdev_err(dev, \"I2S base is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(adata->acp_base + rsrc->i2s_pin_cfg_offset);\n\tif (val != rsrc->i2s_mode) {\n\t\tdev_err(dev, \"I2S Mode not supported val %x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct snd_soc_dai_ops asoc_acp_cpu_dai_ops = {\n\t.probe\t\t= acp_i2s_probe,\n\t.startup\t= acp_i2s_startup,\n\t.hw_params\t= acp_i2s_hwparams,\n\t.prepare\t= acp_i2s_prepare,\n\t.trigger\t= acp_i2s_trigger,\n\t.set_fmt\t= acp_i2s_set_fmt,\n\t.set_tdm_slot\t= acp_i2s_set_tdm_slot,\n};\nEXPORT_SYMBOL_NS_GPL(asoc_acp_cpu_dai_ops, SND_SOC_ACP_COMMON);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}