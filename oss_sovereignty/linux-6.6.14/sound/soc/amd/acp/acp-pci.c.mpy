{
  "module_name": "acp-pci.c",
  "hash_id": "4b2b58b45d54abffa526e6941d7c11017922c4b135e09d19215b9f9c63e7101e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-pci.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include \"amd.h\"\n#include \"../mach-config.h\"\n\n#define DRV_NAME \"acp_pci\"\n\n#define ACP3x_REG_START\t0x1240000\n#define ACP3x_REG_END\t0x125C000\n\nstatic struct platform_device *dmic_dev;\nstatic struct platform_device *pdev;\n\nstatic const struct resource acp_res[] = {\n\t{\n\t\t.start = 0,\n\t\t.end = ACP3x_REG_END - ACP3x_REG_START,\n\t\t.name = \"acp_mem\",\n\t\t.flags = IORESOURCE_MEM,\n\t},\n\t{\n\t\t.start = 0,\n\t\t.end = 0,\n\t\t.name = \"acp_dai_irq\",\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic int acp_pci_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstruct platform_device_info pdevinfo;\n\tstruct device *dev = &pci->dev;\n\tconst struct resource *res_acp;\n\tstruct acp_chip_info *chip;\n\tstruct resource *res;\n\tunsigned int flag, addr, num_res, i;\n\tint ret;\n\n\tflag = snd_amd_acp_find_config(pci);\n\tif (flag != FLAG_AMD_LEGACY)\n\t\treturn -ENODEV;\n\n\tchip = devm_kzalloc(&pci->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(pci))\n\t\treturn dev_err_probe(&pci->dev, -ENODEV,\n\t\t\t\t     \"pci_enable_device failed\\n\");\n\n\tret = pci_request_regions(pci, \"AMD ACP3x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto disable_pci;\n\t}\n\n\tpci_set_master(pci);\n\n\tres_acp = acp_res;\n\tnum_res = ARRAY_SIZE(acp_res);\n\n\tswitch (pci->revision) {\n\tcase 0x01:\n\t\tchip->name = \"acp_asoc_renoir\";\n\t\tchip->acp_rev = ACP3X_DEV;\n\t\tbreak;\n\tcase 0x6f:\n\t\tchip->name = \"acp_asoc_rembrandt\";\n\t\tchip->acp_rev = ACP6X_DEV;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported device revision:0x%x\\n\", pci->revision);\n\t\tret = -EINVAL;\n\t\tgoto release_regions;\n\t}\n\n\tdmic_dev = platform_device_register_data(dev, \"dmic-codec\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(dmic_dev)) {\n\t\tdev_err(dev, \"failed to create DMIC device\\n\");\n\t\tret = PTR_ERR(dmic_dev);\n\t\tgoto release_regions;\n\t}\n\n\taddr = pci_resource_start(pci, 0);\n\tchip->base = devm_ioremap(&pci->dev, addr, pci_resource_len(pci, 0));\n\tif (!chip->base) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_dmic_dev;\n\t}\n\n\tacp_init(chip);\n\tres = devm_kcalloc(&pci->dev, num_res, sizeof(struct resource), GFP_KERNEL);\n\tif (!res) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_dmic_dev;\n\t}\n\n\tfor (i = 0; i < num_res; i++, res_acp++) {\n\t\tres[i].name = res_acp->name;\n\t\tres[i].flags = res_acp->flags;\n\t\tres[i].start = addr + res_acp->start;\n\t\tres[i].end = addr + res_acp->end;\n\t\tif (res_acp->flags == IORESOURCE_IRQ) {\n\t\t\tres[i].start = pci->irq;\n\t\t\tres[i].end = res[i].start;\n\t\t}\n\t}\n\n\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\n\tpdevinfo.name = chip->name;\n\tpdevinfo.id = 0;\n\tpdevinfo.parent = &pci->dev;\n\tpdevinfo.num_res = num_res;\n\tpdevinfo.res = &res[0];\n\tpdevinfo.data = chip;\n\tpdevinfo.size_data = sizeof(*chip);\n\n\tpdev = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(pdev)) {\n\t\tdev_err(&pci->dev, \"cannot register %s device\\n\", pdevinfo.name);\n\t\tret = PTR_ERR(pdev);\n\t\tgoto unregister_dmic_dev;\n\t}\n\tchip->chip_pdev = pdev;\n\tdev_set_drvdata(&pci->dev, chip);\n\tpm_runtime_set_autosuspend_delay(&pci->dev, 2000);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\treturn ret;\n\nunregister_dmic_dev:\n\tplatform_device_unregister(dmic_dev);\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n};\n\nstatic int __maybe_unused snd_acp_suspend(struct device *dev)\n{\n\tstruct acp_chip_info *chip;\n\tint ret;\n\n\tchip = dev_get_drvdata(dev);\n\tret = acp_deinit(chip->base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp_resume(struct device *dev)\n{\n\tstruct acp_chip_info *chip;\n\tstruct acp_dev_data *adata;\n\tstruct device child;\n\tint ret;\n\n\tchip = dev_get_drvdata(dev);\n\tret = acp_init(chip);\n\tif (ret)\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\tchild = chip->chip_pdev->dev;\n\tadata = dev_get_drvdata(&child);\n\tif (adata)\n\t\tacp_enable_interrupts(adata);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops acp_pm_ops = {\n\tSET_RUNTIME_PM_OPS(snd_acp_suspend, snd_acp_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_acp_suspend, snd_acp_resume)\n};\n\nstatic void acp_pci_remove(struct pci_dev *pci)\n{\n\tstruct acp_chip_info *chip;\n\tint ret;\n\n\tchip = pci_get_drvdata(pci);\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tif (dmic_dev)\n\t\tplatform_device_unregister(dmic_dev);\n\tif (pdev)\n\t\tplatform_device_unregister(pdev);\n\tret = acp_deinit(chip->base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n}\n\n \nstatic const struct pci_device_id acp_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_PCI_DEV_ID)},\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, acp_pci_ids);\n\n \nstatic struct pci_driver snd_amd_acp_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = acp_pci_ids,\n\t.probe = acp_pci_probe,\n\t.remove = acp_pci_remove,\n\t.driver = {\n\t\t.pm = &acp_pm_ops,\n\t},\n};\nmodule_pci_driver(snd_amd_acp_pci_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_IMPORT_NS(SND_SOC_ACP_COMMON);\nMODULE_ALIAS(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}