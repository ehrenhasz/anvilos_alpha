{
  "module_name": "acp-platform.c",
  "hash_id": "7faef3bd6790870d32071acbc7ad4cfa9ba33610109b0a85cacc0f0765db4faa",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-platform.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n\n#include \"amd.h\"\n\n#define DRV_NAME \"acp_i2s_dma\"\n\nstatic const struct snd_pcm_hardware acp_pcm_hardware_playback = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |  SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t.rate_min = 8000,\n\t.rate_max = 96000,\n\t.buffer_bytes_max = PLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE,\n\t.period_bytes_min = PLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max = PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min = PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max = PLAYBACK_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp_pcm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nint acp_machine_select(struct acp_dev_data *adata)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tint size;\n\n\tsize = sizeof(*adata->machines);\n\tmach = snd_soc_acpi_find_machine(adata->machines);\n\tif (!mach) {\n\t\tdev_err(adata->dev, \"warning: No matching ASoC machine driver found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadata->mach_dev = platform_device_register_data(adata->dev, mach->drv_name,\n\t\t\t\t\t\t\tPLATFORM_DEVID_NONE, mach, size);\n\tif (IS_ERR(adata->mach_dev))\n\t\tdev_warn(adata->dev, \"Unable to register Machine device\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_machine_select, SND_SOC_ACP_COMMON);\n\nstatic irqreturn_t i2s_irq_handler(int irq, void *data)\n{\n\tstruct acp_dev_data *adata = data;\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tstruct acp_stream *stream;\n\tu16 i2s_flag = 0;\n\tu32 ext_intr_stat, ext_intr_stat1;\n\n\tif (!adata)\n\t\treturn IRQ_NONE;\n\n\tif (adata->rsrc->no_of_ctrls == 2)\n\t\text_intr_stat1 = readl(ACP_EXTERNAL_INTR_STAT(adata, (rsrc->irqp_used - 1)));\n\n\text_intr_stat = readl(ACP_EXTERNAL_INTR_STAT(adata, rsrc->irqp_used));\n\n\tspin_lock(&adata->acp_lock);\n\tlist_for_each_entry(stream, &adata->stream_list, list) {\n\t\tif (ext_intr_stat & stream->irq_bit) {\n\t\t\twritel(stream->irq_bit,\n\t\t\t       ACP_EXTERNAL_INTR_STAT(adata, rsrc->irqp_used));\n\t\t\tsnd_pcm_period_elapsed(stream->substream);\n\t\t\ti2s_flag = 1;\n\t\t}\n\t\tif (adata->rsrc->no_of_ctrls == 2) {\n\t\t\tif (ext_intr_stat1 & stream->irq_bit) {\n\t\t\t\twritel(stream->irq_bit, ACP_EXTERNAL_INTR_STAT(adata,\n\t\t\t\t       (rsrc->irqp_used - 1)));\n\t\t\t\tsnd_pcm_period_elapsed(stream->substream);\n\t\t\t\ti2s_flag = 1;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&adata->acp_lock);\n\tif (i2s_flag)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\nvoid config_pte_for_stream(struct acp_dev_data *adata, struct acp_stream *stream)\n{\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tu32 pte_reg, pte_size, reg_val;\n\n\t \n\tpte_reg = ACPAXI2AXI_ATU_BASE_ADDR_GRP_5;\n\tpte_size =  ACPAXI2AXI_ATU_PAGE_SIZE_GRP_5;\n\tstream->reg_offset = 0x02000000;\n\n\t \n\treg_val = rsrc->sram_pte_offset;\n\twritel(reg_val | BIT(31), adata->acp_base + pte_reg);\n\twritel(PAGE_SIZE_4K_ENABLE,  adata->acp_base + pte_size);\n\twritel(0x01, adata->acp_base + ACPAXI2AXI_ATU_CTRL);\n}\nEXPORT_SYMBOL_NS_GPL(config_pte_for_stream, SND_SOC_ACP_COMMON);\n\nvoid config_acp_dma(struct acp_dev_data *adata, struct acp_stream *stream, int size)\n{\n\tstruct snd_pcm_substream *substream = stream->substream;\n\tstruct acp_resource *rsrc = adata->rsrc;\n\tdma_addr_t addr = substream->dma_buffer.addr;\n\tint num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);\n\tu32 low, high, val;\n\tu16 page_idx;\n\n\tval = stream->pte_offset;\n\n\tfor (page_idx = 0; page_idx < num_pages; page_idx++) {\n\t\t \n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\t\twritel(low, adata->acp_base + rsrc->scratch_reg_offset + val);\n\t\thigh |= BIT(31);\n\t\twritel(high, adata->acp_base + rsrc->scratch_reg_offset + val + 4);\n\n\t\t \n\t\tval += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(config_acp_dma, SND_SOC_ACP_COMMON);\n\nstatic int acp_dma_open(struct snd_soc_component *component, struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_stream *stream;\n\tint ret;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tstream->substream = substream;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = acp_pcm_hardware_playback;\n\telse\n\t\truntime->hw = acp_pcm_hardware_capture;\n\n\tret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(stream);\n\t\treturn ret;\n\t}\n\truntime->private_data = stream;\n\n\twritel(1, ACP_EXTERNAL_INTR_ENB(adata));\n\n\tspin_lock_irq(&adata->acp_lock);\n\tlist_add_tail(&stream->list, &adata->stream_list);\n\tspin_unlock_irq(&adata->acp_lock);\n\n\treturn ret;\n}\n\nstatic int acp_dma_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct acp_dev_data *adata = snd_soc_component_get_drvdata(component);\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tu64 size = params_buffer_bytes(params);\n\n\t \n\tconfig_pte_for_stream(adata, stream);\n\tconfig_acp_dma(adata, stream, size);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t acp_dma_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct device *dev = component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tu32 pos, buffersize;\n\tu64 bytescount;\n\n\tbuffersize = frames_to_bytes(substream->runtime,\n\t\t\t\t     substream->runtime->buffer_size);\n\n\tbytescount = acp_get_byte_count(adata, stream->dai_id, substream->stream);\n\n\tif (bytescount > stream->bytescount)\n\t\tbytescount -= stream->bytescount;\n\n\tpos = do_div(bytescount, buffersize);\n\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic int acp_dma_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *parent = component->dev->parent;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       parent, MIN_BUFFER, MAX_BUFFER);\n\treturn 0;\n}\n\nstatic int acp_dma_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct device *dev = component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\n\t \n\tspin_lock_irq(&adata->acp_lock);\n\tlist_del(&stream->list);\n\tspin_unlock_irq(&adata->acp_lock);\n\tkfree(stream);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver acp_pcm_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.open\t\t\t= acp_dma_open,\n\t.close\t\t\t= acp_dma_close,\n\t.hw_params\t\t= acp_dma_hw_params,\n\t.pointer\t\t= acp_dma_pointer,\n\t.pcm_construct\t\t= acp_dma_new,\n\t.legacy_dai_naming\t= 1,\n};\n\nint acp_platform_register(struct device *dev)\n{\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tstruct snd_soc_dai_driver;\n\tunsigned int status;\n\n\tstatus = devm_request_irq(dev, adata->i2s_irq, i2s_irq_handler,\n\t\t\t\t  IRQF_SHARED, \"ACP_I2S_IRQ\", adata);\n\tif (status) {\n\t\tdev_err(dev, \"ACP I2S IRQ request failed\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = devm_snd_soc_register_component(dev, &acp_pcm_component,\n\t\t\t\t\t\t adata->dai_driver,\n\t\t\t\t\t\t adata->num_dai);\n\tif (status) {\n\t\tdev_err(dev, \"Fail to register acp i2s component\\n\");\n\t\treturn status;\n\t}\n\n\tINIT_LIST_HEAD(&adata->stream_list);\n\tspin_lock_init(&adata->acp_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_platform_register, SND_SOC_ACP_COMMON);\n\nint acp_platform_unregister(struct device *dev)\n{\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\n\tif (adata->mach_dev)\n\t\tplatform_device_unregister(adata->mach_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_platform_unregister, SND_SOC_ACP_COMMON);\n\nMODULE_DESCRIPTION(\"AMD ACP PCM Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}