{
  "module_name": "acp-pdm.c",
  "hash_id": "a4e959919b906a579ed68dd70b7d99d985c1cc52834978a539673f3efdca1695",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-pdm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"amd.h\"\n\n#define DRV_NAME \"acp-pdm\"\n\nstatic int acp_dmic_prepare(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tu32 physical_addr, size_dmic, period_bytes;\n\tunsigned int dmic_ctrl;\n\n\t \n\twritel(PDM_CLK_FREQ_MASK, adata->acp_base + ACP_WOV_CLK_CTRL);\n\tdmic_ctrl = readl(adata->acp_base + ACP_WOV_MISC_CTRL);\n\tdmic_ctrl |= PDM_MISC_CTRL_MASK;\n\twritel(dmic_ctrl, adata->acp_base + ACP_WOV_MISC_CTRL);\n\n\tperiod_bytes = frames_to_bytes(substream->runtime,\n\t\t\tsubstream->runtime->period_size);\n\tsize_dmic = frames_to_bytes(substream->runtime,\n\t\t\tsubstream->runtime->buffer_size);\n\n\tphysical_addr = stream->reg_offset + MEM_WINDOW_START;\n\n\t \n\twritel(physical_addr, adata->acp_base + ACP_WOV_RX_RINGBUFADDR);\n\twritel(size_dmic, adata->acp_base + ACP_WOV_RX_RINGBUFSIZE);\n\twritel(period_bytes, adata->acp_base + ACP_WOV_RX_INTR_WATERMARK_SIZE);\n\twritel(0x01, adata->acp_base + ACPAXI2AXI_ATU_CTRL);\n\n\treturn 0;\n}\n\nstatic int acp_dmic_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tunsigned int dma_enable;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdma_enable = readl(adata->acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\tif (!(dma_enable & DMA_EN_MASK)) {\n\t\t\twritel(PDM_ENABLE, adata->acp_base + ACP_WOV_PDM_ENABLE);\n\t\t\twritel(PDM_ENABLE, adata->acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\t}\n\n\t\tret = readl_poll_timeout_atomic(adata->acp_base + ACP_WOV_PDM_DMA_ENABLE,\n\t\t\t\t\t\tdma_enable, (dma_enable & DMA_EN_MASK),\n\t\t\t\t\t\tDELAY_US, PDM_TIMEOUT);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdma_enable = readl(adata->acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\tif ((dma_enable & DMA_EN_MASK)) {\n\t\t\twritel(PDM_DISABLE, adata->acp_base + ACP_WOV_PDM_ENABLE);\n\t\t\twritel(PDM_DISABLE, adata->acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\n\t\t}\n\n\t\tret = readl_poll_timeout_atomic(adata->acp_base + ACP_WOV_PDM_DMA_ENABLE,\n\t\t\t\t\t\tdma_enable, !(dma_enable & DMA_EN_MASK),\n\t\t\t\t\t\tDELAY_US, PDM_TIMEOUT);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int acp_dmic_hwparams(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hwparams, struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tunsigned int channels, ch_mask;\n\n\tchannels = params_channels(hwparams);\n\tswitch (channels) {\n\tcase 2:\n\t\tch_mask = 0;\n\t\tbreak;\n\tcase 4:\n\t\tch_mask = 1;\n\t\tbreak;\n\tcase 6:\n\t\tch_mask = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid channels %d\\n\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tadata->ch_mask = ch_mask;\n\tif (params_format(hwparams) != SNDRV_PCM_FORMAT_S32_LE) {\n\t\tdev_err(dai->dev, \"Invalid format:%d\\n\", params_format(hwparams));\n\t\treturn -EINVAL;\n\t}\n\n\twritel(ch_mask, adata->acp_base + ACP_WOV_PDM_NO_OF_CHANNELS);\n\twritel(PDM_DEC_64, adata->acp_base + ACP_WOV_PDM_DECIMATION_FACTOR);\n\n\treturn 0;\n}\n\nstatic int acp_dmic_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct acp_stream *stream = substream->runtime->private_data;\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tu32 ext_int_ctrl;\n\n\tstream->dai_id = DMIC_INSTANCE;\n\tstream->irq_bit = BIT(PDM_DMA_STAT);\n\tstream->pte_offset = ACP_SRAM_PDM_PTE_OFFSET;\n\tstream->reg_offset = ACP_REGION2_OFFSET;\n\n\t \n\text_int_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, 0));\n\text_int_ctrl |= PDM_DMA_INTR_MASK;\n\twritel(ext_int_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, 0));\n\n\treturn 0;\n}\n\nstatic void acp_dmic_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->component->dev;\n\tstruct acp_dev_data *adata = dev_get_drvdata(dev);\n\tu32 ext_int_ctrl;\n\n\t \n\text_int_ctrl = readl(ACP_EXTERNAL_INTR_CNTL(adata, 0));\n\text_int_ctrl &= ~PDM_DMA_INTR_MASK;\n\twritel(ext_int_ctrl, ACP_EXTERNAL_INTR_CNTL(adata, 0));\n}\n\nconst struct snd_soc_dai_ops acp_dmic_dai_ops = {\n\t.prepare\t= acp_dmic_prepare,\n\t.hw_params\t= acp_dmic_hwparams,\n\t.trigger\t= acp_dmic_dai_trigger,\n\t.startup\t= acp_dmic_dai_startup,\n\t.shutdown\t= acp_dmic_dai_shutdown,\n};\nEXPORT_SYMBOL_NS_GPL(acp_dmic_dai_ops, SND_SOC_ACP_COMMON);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}