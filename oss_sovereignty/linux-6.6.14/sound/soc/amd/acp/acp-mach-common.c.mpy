{
  "module_name": "acp-mach-common.c",
  "hash_id": "b65b912d4d90c94a918ef4fa8d22f48914e7154702cbcf35fe890b115cfd8140",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/acp/acp-mach-common.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n \n\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm_params.h>\n#include <sound/soc-dapm.h>\n#include <sound/soc.h>\n#include <linux/input.h>\n#include <linux/module.h>\n\n#include \"../../codecs/rt5682.h\"\n#include \"../../codecs/rt1019.h\"\n#include \"../../codecs/rt5682s.h\"\n#include \"../../codecs/nau8825.h\"\n#include \"../../codecs/nau8821.h\"\n#include \"acp-mach.h\"\n\n#define PCO_PLAT_CLK 48000000\n#define RT5682_PLL_FREQ (48000 * 512)\n#define DUAL_CHANNEL\t2\n#define FOUR_CHANNEL\t4\n#define NAU8821_CODEC_DAI\t\"nau8821-hifi\"\n#define NAU8821_BCLK\t\t1536000\n#define NAU8821_FREQ_OUT\t12288000\n#define MAX98388_CODEC_DAI\t\"max98388-aif1\"\n\n#define TDM_MODE_ENABLE 1\n\nconst struct dmi_system_id acp_quirk_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_FAMILY, \"Google_Skyrim\"),\n\t\t},\n\t\t.driver_data = (void *)TDM_MODE_ENABLE,\n\t},\n\t{}\n};\nEXPORT_SYMBOL_GPL(acp_quirk_table);\n\nstatic const unsigned int channels[] = {\n\tDUAL_CHANNEL,\n};\n\nstatic const unsigned int rates[] = {\n\t48000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list  = rates,\n\t.mask = 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_channels = {\n\t.count = ARRAY_SIZE(channels),\n\t.list = channels,\n\t.mask = 0,\n};\n\nstatic int acp_clk_enable(struct acp_card_drvdata *drvdata,\n\t\t\t  unsigned int srate, unsigned int bclk_ratio)\n{\n\tclk_set_rate(drvdata->wclk, srate);\n\tclk_set_rate(drvdata->bclk, srate * bclk_ratio);\n\n\treturn clk_prepare_enable(drvdata->wclk);\n}\n\n \nSND_SOC_DAILINK_DEF(rt5682,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-10EC5682:00\", \"rt5682-aif1\")));\n\nstatic struct snd_soc_jack rt5682_jack;\nstatic struct snd_soc_jack_pin rt5682_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic const struct snd_kcontrol_new rt5682_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget rt5682_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route rt5682_map[] = {\n\t{ \"Headphone Jack\", NULL, \"HPOL\" },\n\t{ \"Headphone Jack\", NULL, \"HPOR\" },\n\t{ \"IN1P\", NULL, \"Headset Mic\" },\n};\n\n \nstatic int acp_card_rt5682_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\tdev_info(rtd->dev, \"codec dai name = %s\\n\", codec_dai->name);\n\n\tif (drvdata->hs_codec_id != RT5682)\n\t\treturn -EINVAL;\n\n\tdrvdata->wclk = clk_get(component->dev, \"rt5682-dai-wclk\");\n\tdrvdata->bclk = clk_get(component->dev, \"rt5682-dai-bclk\");\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, rt5682_widgets,\n\t\t\t\t\tARRAY_SIZE(rt5682_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, rt5682_controls,\n\t\t\t\t\tARRAY_SIZE(rt5682_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_LINEOUT |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t &rt5682_jack,\n\t\t\t\t\t rt5682_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(rt5682_jack_pins));\n\tif (ret) {\n\t\tdev_err(card->dev, \"HP jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(rt5682_jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(rt5682_jack.jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(rt5682_jack.jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(rt5682_jack.jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tret = snd_soc_component_set_jack(component, &rt5682_jack, NULL);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack call-back failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, rt5682_map, ARRAY_SIZE(rt5682_map));\n}\n\nstatic int acp_card_hs_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\tunsigned int fmt;\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret =  snd_soc_dai_set_fmt(codec_dai, fmt);\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\truntime->hw.channels_max = DUAL_CHANNEL;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t      &constraints_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &constraints_rates);\n\n\treturn ret;\n}\n\nstatic void acp_card_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\n\tif (!drvdata->soc_mclk)\n\t\tclk_disable_unprepare(drvdata->wclk);\n}\n\nstatic int acp_card_rt5682_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\tunsigned int fmt, srate, ch, format;\n\n\tsrate = params_rate(params);\n\tch = params_channels(params);\n\tformat = params_physical_width(params);\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, fmt);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(rtd->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret =  snd_soc_dai_set_fmt(codec_dai, fmt);\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode) {\n\t\t \n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 8, 16);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(rtd->dev, \"set TDM slot err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 8, 16);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(rtd->dev, \"set TDM slot err:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_pll(codec_dai, RT5682_PLL2, RT5682_PLL2_S_MCLK,\n\t\t\t\t  PCO_PLAT_CLK, RT5682_PLL_FREQ);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set codec PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, RT5682_SCLK_S_PLL2,\n\t\t\t\t     RT5682_PLL_FREQ, SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set codec SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_bclk_ratio(codec_dai, ch * format);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set rt5682 tdm bclk ratio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->soc_mclk) {\n\t\tret = acp_clk_enable(drvdata, srate, ch * format);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->card->dev, \"Failed to enable HS clk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_rt5682_ops = {\n\t.startup = acp_card_hs_startup,\n\t.shutdown = acp_card_shutdown,\n\t.hw_params = acp_card_rt5682_hw_params,\n};\n\n \nSND_SOC_DAILINK_DEF(rt5682s,\n\t\t    DAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-RTL5682:00\", \"rt5682s-aif1\")));\n\nstatic struct snd_soc_jack rt5682s_jack;\nstatic struct snd_soc_jack_pin rt5682s_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic const struct snd_kcontrol_new rt5682s_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget rt5682s_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route rt5682s_map[] = {\n\t{ \"Headphone Jack\", NULL, \"HPOL\" },\n\t{ \"Headphone Jack\", NULL, \"HPOR\" },\n\t{ \"IN1P\", NULL, \"Headset Mic\" },\n};\n\nstatic int acp_card_rt5682s_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\tdev_info(rtd->dev, \"codec dai name = %s\\n\", codec_dai->name);\n\n\tif (drvdata->hs_codec_id != RT5682S)\n\t\treturn -EINVAL;\n\n\tif (!drvdata->soc_mclk) {\n\t\tdrvdata->wclk = clk_get(component->dev, \"rt5682-dai-wclk\");\n\t\tdrvdata->bclk = clk_get(component->dev, \"rt5682-dai-bclk\");\n\t}\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, rt5682s_widgets,\n\t\t\t\t\tARRAY_SIZE(rt5682s_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, rt5682s_controls,\n\t\t\t\t\tARRAY_SIZE(rt5682s_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_LINEOUT |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t &rt5682s_jack,\n\t\t\t\t\t rt5682s_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(rt5682s_jack_pins));\n\tif (ret) {\n\t\tdev_err(card->dev, \"HP jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(rt5682s_jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(rt5682s_jack.jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(rt5682s_jack.jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(rt5682s_jack.jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tret = snd_soc_component_set_jack(component, &rt5682s_jack, NULL);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack call-back failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, rt5682s_map, ARRAY_SIZE(rt5682s_map));\n}\n\nstatic int acp_card_rt5682s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\tunsigned int fmt, srate, ch, format;\n\n\tsrate = params_rate(params);\n\tch = params_channels(params);\n\tformat = params_physical_width(params);\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, fmt);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(rtd->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret =  snd_soc_dai_set_fmt(codec_dai, fmt);\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode) {\n\t\t \n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 8, 16);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(rtd->dev, \"set TDM slot err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 8, 16);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(rtd->dev, \"set TDM slot err:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_pll(codec_dai, RT5682S_PLL2, RT5682S_PLL_S_MCLK,\n\t\t\t\t  PCO_PLAT_CLK, RT5682_PLL_FREQ);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set codec PLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, RT5682S_SCLK_S_PLL2,\n\t\t\t\t     RT5682_PLL_FREQ, SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set codec SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_bclk_ratio(codec_dai, ch * format);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"Failed to set rt5682 tdm bclk ratio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk_set_rate(drvdata->wclk, srate);\n\tclk_set_rate(drvdata->bclk, srate * ch * format);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_rt5682s_ops = {\n\t.startup = acp_card_hs_startup,\n\t.hw_params = acp_card_rt5682s_hw_params,\n};\n\nstatic const unsigned int dmic_channels[] = {\n\tDUAL_CHANNEL, FOUR_CHANNEL,\n};\n\nstatic const struct snd_pcm_hw_constraint_list dmic_constraints_channels = {\n\t.count = ARRAY_SIZE(dmic_channels),\n\t.list = dmic_channels,\n\t.mask = 0,\n};\n\nstatic int acp_card_dmic_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &dmic_constraints_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &constraints_rates);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_dmic_ops = {\n\t.startup = acp_card_dmic_startup,\n};\n\n \nSND_SOC_DAILINK_DEF(rt1019,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-10EC1019:00\", \"rt1019-aif\"),\n\t\t\t  COMP_CODEC(\"i2c-10EC1019:01\", \"rt1019-aif\")));\n\nstatic const struct snd_kcontrol_new rt1019_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Left Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"Right Spk\"),\n};\n\nstatic const struct snd_soc_dapm_widget rt1019_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Left Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"Right Spk\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route rt1019_map_lr[] = {\n\t{ \"Left Spk\", NULL, \"Left SPO\" },\n\t{ \"Right Spk\", NULL, \"Right SPO\" },\n};\n\nstatic struct snd_soc_codec_conf rt1019_conf[] = {\n\t{\n\t\t .dlc = COMP_CODEC_CONF(\"i2c-10EC1019:01\"),\n\t\t .name_prefix = \"Left\",\n\t},\n\t{\n\t\t .dlc = COMP_CODEC_CONF(\"i2c-10EC1019:00\"),\n\t\t .name_prefix = \"Right\",\n\t},\n};\n\nstatic int acp_card_rt1019_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tint ret;\n\n\tif (drvdata->amp_codec_id != RT1019)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, rt1019_widgets,\n\t\t\t\t\tARRAY_SIZE(rt1019_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, rt1019_controls,\n\t\t\t\t\tARRAY_SIZE(rt1019_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, rt1019_map_lr,\n\t\t\t\t       ARRAY_SIZE(rt1019_map_lr));\n}\n\nstatic int acp_card_rt1019_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint i, ret = 0;\n\tunsigned int fmt, srate, ch, format;\n\n\tsrate = params_rate(params);\n\tch = params_channels(params);\n\tformat = params_physical_width(params);\n\n\tif (drvdata->amp_codec_id != RT1019)\n\t\treturn -EINVAL;\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, fmt);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(rtd->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode) {\n\t\t \n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0xC, 0, 8, 16);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(rtd->dev, \"set TDM slot err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tif (strcmp(codec_dai->name, \"rt1019-aif\"))\n\t\t\tcontinue;\n\n\t\tif (drvdata->tdm_mode)\n\t\t\tret = snd_soc_dai_set_pll(codec_dai, 0, RT1019_PLL_S_BCLK,\n\t\t\t\t\t\t  TDM_CHANNELS * format * srate, 256 * srate);\n\t\telse\n\t\t\tret = snd_soc_dai_set_pll(codec_dai, 0, RT1019_PLL_S_BCLK,\n\t\t\t\t\t\t  ch * format * srate, 256 * srate);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, RT1019_SCLK_S_PLL,\n\t\t\t\t\t     256 * srate, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (drvdata->tdm_mode) {\n\t\t\tret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_A\n\t\t\t\t\t\t\t| SND_SOC_DAIFMT_NB_NF);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!strcmp(codec_dai->component->name, \"i2c-10EC1019:00\")) {\n\t\t\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x4, 0x4, 8, 16);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!strcmp(codec_dai->component->name, \"i2c-10EC1019:01\")) {\n\t\t\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x8, 0x8, 8, 16);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!drvdata->soc_mclk) {\n\t\tret = acp_clk_enable(drvdata, srate, ch * format);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->card->dev, \"Failed to enable AMP clk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int acp_card_amp_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw.channels_max = DUAL_CHANNEL;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t      &constraints_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &constraints_rates);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_rt1019_ops = {\n\t.startup = acp_card_amp_startup,\n\t.shutdown = acp_card_shutdown,\n\t.hw_params = acp_card_rt1019_hw_params,\n};\n\n \nSND_SOC_DAILINK_DEF(max98360a,\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"MX98360A:00\", \"HiFi\")));\n\nstatic const struct snd_kcontrol_new max98360a_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Spk\"),\n};\n\nstatic const struct snd_soc_dapm_widget max98360a_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Spk\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route max98360a_map[] = {\n\t{\"Spk\", NULL, \"Speaker\"},\n};\n\nstatic int acp_card_maxim_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tint ret;\n\n\tif (drvdata->amp_codec_id != MAX98360A)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, max98360a_widgets,\n\t\t\t\t\tARRAY_SIZE(max98360a_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, max98360a_controls,\n\t\t\t\t\tARRAY_SIZE(max98360a_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, max98360a_map,\n\t\t\t\t       ARRAY_SIZE(max98360a_map));\n}\n\nstatic int acp_card_maxim_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tunsigned int fmt, srate, ch, format;\n\tint ret;\n\n\tsrate = params_rate(params);\n\tch = params_channels(params);\n\tformat = params_physical_width(params);\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, fmt);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(rtd->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode) {\n\t\t \n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0xC, 0, 8, 16);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(rtd->dev, \"set TDM slot err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!drvdata->soc_mclk) {\n\t\tret = acp_clk_enable(drvdata, srate, ch * format);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->card->dev, \"Failed to enable AMP clk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_maxim_ops = {\n\t.startup = acp_card_amp_startup,\n\t.shutdown = acp_card_shutdown,\n\t.hw_params = acp_card_maxim_hw_params,\n};\n\nSND_SOC_DAILINK_DEF(max98388,\n\t\t    DAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-ADS8388:00\", \"max98388-aif1\"),\n\t\t\t\t       COMP_CODEC(\"i2c-ADS8388:01\", \"max98388-aif1\")));\n\nstatic const struct snd_kcontrol_new max98388_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Left Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"Right Spk\"),\n};\n\nstatic const struct snd_soc_dapm_widget max98388_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Left Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"Right Spk\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route max98388_map[] = {\n\t{ \"Left Spk\", NULL, \"Left BE_OUT\" },\n\t{ \"Right Spk\", NULL, \"Right BE_OUT\" },\n};\n\nstatic struct snd_soc_codec_conf max98388_conf[] = {\n\t{\n\t\t.dlc = COMP_CODEC_CONF(\"i2c-ADS8388:00\"),\n\t\t.name_prefix = \"Left\",\n\t},\n\t{\n\t\t.dlc = COMP_CODEC_CONF(\"i2c-ADS8388:01\"),\n\t\t.name_prefix = \"Right\",\n\t},\n};\n\nstatic const unsigned int max98388_format[] = {16};\n\nstatic struct snd_pcm_hw_constraint_list constraints_sample_bits_max = {\n\t.list = max98388_format,\n\t.count = ARRAY_SIZE(max98388_format),\n};\n\nstatic int acp_card_max98388_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw.channels_max = DUAL_CHANNEL;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &constraints_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &constraints_rates);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\n\t\t\t\t   &constraints_sample_bits_max);\n\n\treturn 0;\n}\n\nstatic int acp_card_max98388_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tint ret;\n\n\tif (drvdata->amp_codec_id != MAX98388)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, max98388_widgets,\n\t\t\t\t\tARRAY_SIZE(max98388_widgets));\n\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\t \n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, max98388_controls,\n\t\t\t\t\tARRAY_SIZE(max98388_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, max98388_map,\n\t\t\t\t       ARRAY_SIZE(max98388_map));\n}\n\nstatic int acp_max98388_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct snd_soc_dai *codec_dai =\n\t\t\tsnd_soc_card_get_codec_dai(card,\n\t\t\t\t\t\t   MAX98388_CODEC_DAI);\n\tint ret;\n\n\tret = snd_soc_dai_set_fmt(codec_dai,\n\t\t\t\t  SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_I2S |\n\t\t\t\t  SND_SOC_DAIFMT_NB_NF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops acp_max98388_ops = {\n\t.startup = acp_card_max98388_startup,\n\t.hw_params = acp_max98388_hw_params,\n};\n\n \nSND_SOC_DAILINK_DEF(nau8825,\n\t\t    DAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-10508825:00\", \"nau8825-hifi\")));\n\nstatic struct snd_soc_jack nau8825_jack;\nstatic struct snd_soc_jack_pin nau8825_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic const struct snd_kcontrol_new nau8825_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget nau8825_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route nau8825_map[] = {\n\t{ \"Headphone Jack\", NULL, \"HPOL\" },\n\t{ \"Headphone Jack\", NULL, \"HPOR\" },\n};\n\nstatic int acp_card_nau8825_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\tdev_info(rtd->dev, \"codec dai name = %s\\n\", codec_dai->name);\n\n\tif (drvdata->hs_codec_id != NAU8825)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, nau8825_widgets,\n\t\t\t\t\tARRAY_SIZE(nau8825_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, nau8825_controls,\n\t\t\t\t\tARRAY_SIZE(nau8825_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_LINEOUT |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t &nau8825_jack,\n\t\t\t\t\t nau8825_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(nau8825_jack_pins));\n\tif (ret) {\n\t\tdev_err(card->dev, \"HP jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(nau8825_jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(nau8825_jack.jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(nau8825_jack.jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(nau8825_jack.jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tret = snd_soc_component_set_jack(component, &nau8825_jack, NULL);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack call-back failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, nau8825_map, ARRAY_SIZE(nau8825_map));\n}\n\nstatic int acp_nau8825_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\tunsigned int fmt;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, NAU8825_CLK_FLL_FS,\n\t\t\t\t     (48000 * 256), SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\tdev_err(rtd->dev, \"snd_soc_dai_set_sysclk err = %d\\n\", ret);\n\n\tret = snd_soc_dai_set_pll(codec_dai, 0, 0, params_rate(params),\n\t\t\t\t  params_rate(params) * 256);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"can't set FLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode)\n\t\tfmt = SND_SOC_DAIFMT_DSP_A;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, fmt);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(rtd->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret =  snd_soc_dai_set_fmt(codec_dai, fmt);\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->tdm_mode) {\n\t\t \n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x30, 0xC0, 8, 16);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(rtd->dev, \"set TDM slot err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x40, 0x30, 8, 16);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(rtd->dev, \"set TDM slot err:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int acp_nau8825_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw.channels_max = 2;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &constraints_channels);\n\n\truntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\n\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE, &constraints_rates);\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops acp_card_nau8825_ops = {\n\t.startup =  acp_nau8825_startup,\n\t.hw_params = acp_nau8825_hw_params,\n};\n\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct snd_soc_dai *codec_dai;\n\tint ret = 0;\n\n\tcodec_dai = snd_soc_card_get_codec_dai(card, NAU8821_CODEC_DAI);\n\tif (!codec_dai) {\n\t\tdev_err(card->dev, \"Codec dai not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, NAU8821_CLK_INTERNAL,\n\t\t\t\t\t     0, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tdev_err(card->dev, \"set sysclk err = %d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, NAU8821_CLK_FLL_BLK, 0,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret < 0)\n\t\t\tdev_err(codec_dai->dev, \"can't set FS clock %d\\n\", ret);\n\t\tret = snd_soc_dai_set_pll(codec_dai, 0, 0, NAU8821_BCLK,\n\t\t\t\t\t  NAU8821_FREQ_OUT);\n\t\tif (ret < 0)\n\t\t\tdev_err(codec_dai->dev, \"can't set FLL: %d\\n\", ret);\n\t}\n\treturn ret;\n}\n\nstatic struct snd_soc_jack nau8821_jack;\nstatic struct snd_soc_jack_pin nau8821_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic const struct snd_kcontrol_new nau8821_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget nau8821_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Int Mic\", NULL),\n\tSND_SOC_DAPM_SUPPLY(\"Platform Clock\", SND_SOC_NOPM, 0, 0,\n\t\t\t    platform_clock_control, SND_SOC_DAPM_PRE_PMU |\n\t\t\t    SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route nau8821_audio_route[] = {\n\t \n\t{ \"Headphone Jack\", NULL, \"HPOL\" },\n\t{ \"Headphone Jack\", NULL, \"HPOR\" },\n\t{ \"MICL\", NULL, \"Headset Mic\" },\n\t{ \"MICR\", NULL, \"Headset Mic\" },\n\t{ \"DMIC\", NULL, \"Int Mic\" },\n\t{ \"Headphone Jack\", NULL, \"Platform Clock\" },\n\t{ \"Headset Mic\", NULL, \"Platform Clock\" },\n\t{ \"Int Mic\", NULL, \"Platform Clock\" },\n};\n\nstatic const unsigned int nau8821_format[] = {16};\n\nstatic struct snd_pcm_hw_constraint_list constraints_sample_bits = {\n\t.list = nau8821_format,\n\t.count = ARRAY_SIZE(nau8821_format),\n};\n\nstatic int acp_8821_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\tdev_info(rtd->dev, \"codec dai name = %s\\n\", codec_dai->name);\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, nau8821_widgets,\n\t\t\t\t\tARRAY_SIZE(nau8821_widgets));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add widget dapm controls, ret %d\\n\", ret);\n\t\t \n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_card_controls(card, nau8821_controls,\n\t\t\t\t\tARRAY_SIZE(nau8821_controls));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"unable to add card controls, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_LINEOUT |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t &nau8821_jack,\n\t\t\t\t\t nau8821_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(nau8821_jack_pins));\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"Headset Jack creation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_jack_set_key(nau8821_jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(nau8821_jack.jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(nau8821_jack.jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(nau8821_jack.jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tnau8821_enable_jack_detect(component, &nau8821_jack);\n\n\treturn snd_soc_dapm_add_routes(&rtd->card->dapm, nau8821_audio_route,\n\t\t\t\t       ARRAY_SIZE(nau8821_audio_route));\n}\n\nstatic int acp_8821_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw.channels_max = DUAL_CHANNEL;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &constraints_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &constraints_rates);\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\n\t\t\t\t   &constraints_sample_bits);\n\treturn 0;\n}\n\nstatic int acp_nau8821_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\tunsigned int fmt;\n\n\tif (drvdata->soc_mclk)\n\t\tfmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBC_CFC;\n\telse\n\t\tfmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBP_CFP;\n\n\tret =  snd_soc_dai_set_fmt(codec_dai, fmt);\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"Failed to set dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, NAU8821_CLK_FLL_BLK, 0,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\tdev_err(card->dev, \"can't set FS clock %d\\n\", ret);\n\tret = snd_soc_dai_set_pll(codec_dai, 0, 0, snd_soc_params_to_bclk(params),\n\t\t\t\t  params_rate(params) * 256);\n\tif (ret < 0)\n\t\tdev_err(card->dev, \"can't set FLL: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops acp_8821_ops = {\n\t.startup = acp_8821_startup,\n\t.hw_params = acp_nau8821_hw_params,\n};\n\nSND_SOC_DAILINK_DEF(nau8821,\n\t\t    DAILINK_COMP_ARRAY(COMP_CODEC(\"i2c-NVTN2020:00\",\n\t\t\t\t\t\t  \"nau8821-hifi\")));\n\n \nSND_SOC_DAILINK_DEF(dmic_codec,\n\t\tDAILINK_COMP_ARRAY(COMP_CODEC(\"dmic-codec\", \"dmic-hifi\")));\n\n \nstatic struct snd_soc_dai_link_component platform_component[] = {\n\t{\n\t\t .name = \"acp_asoc_renoir.0\",\n\t}\n};\n\nstatic struct snd_soc_dai_link_component platform_rmb_component[] = {\n\t{\n\t\t.name = \"acp_asoc_rembrandt.0\",\n\t}\n};\n\nstatic struct snd_soc_dai_link_component sof_component[] = {\n\t{\n\t\t .name = \"0000:04:00.5\",\n\t}\n};\n\nSND_SOC_DAILINK_DEF(i2s_sp,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-i2s-sp\")));\nSND_SOC_DAILINK_DEF(i2s_hs,\n\t\t    DAILINK_COMP_ARRAY(COMP_CPU(\"acp-i2s-hs\")));\nSND_SOC_DAILINK_DEF(sof_sp,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-sof-sp\")));\nSND_SOC_DAILINK_DEF(sof_sp_virtual,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-sof-sp-virtual\")));\nSND_SOC_DAILINK_DEF(sof_hs,\n\t\t    DAILINK_COMP_ARRAY(COMP_CPU(\"acp-sof-hs\")));\nSND_SOC_DAILINK_DEF(sof_hs_virtual,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-sof-hs-virtual\")));\nSND_SOC_DAILINK_DEF(sof_dmic,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-sof-dmic\")));\nSND_SOC_DAILINK_DEF(pdm_dmic,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"acp-pdm-dmic\")));\n\nstatic int acp_rtk_set_bias_level(struct snd_soc_card *card,\n\t\t\t\t  struct snd_soc_dapm_context *dapm,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct snd_soc_component *component = dapm->component;\n\tstruct acp_card_drvdata *drvdata = card->drvdata;\n\tint ret = 0;\n\n\tif (!component)\n\t\treturn 0;\n\n\tif (strncmp(component->name, \"i2c-RTL5682\", 11) &&\n\t    strncmp(component->name, \"i2c-10EC1019\", 12))\n\t\treturn 0;\n\n\t \n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_dapm_get_bias_level(dapm) == SND_SOC_BIAS_OFF) {\n\n\t\t\t \n\t\t\tret = clk_prepare_enable(drvdata->bclk);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(component->dev, \"Failed to enable bclk %d\\n\", ret);\n\t\t} else {\n\t\t\t \n\t\t\tclk_disable_unprepare(drvdata->bclk);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint acp_sofdsp_dai_links_create(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *links;\n\tstruct device *dev = card->dev;\n\tstruct acp_card_drvdata *drv_data = card->drvdata;\n\tint i = 0, num_links = 0;\n\n\tif (drv_data->hs_cpu_id)\n\t\tnum_links++;\n\tif (drv_data->amp_cpu_id)\n\t\tnum_links++;\n\tif (drv_data->dmic_cpu_id)\n\t\tnum_links++;\n\n\tlinks = devm_kcalloc(dev, num_links, sizeof(struct snd_soc_dai_link), GFP_KERNEL);\n\tif (!links)\n\t\treturn -ENOMEM;\n\n\tif (drv_data->hs_cpu_id == I2S_SP) {\n\t\tlinks[i].name = \"acp-headset-codec\";\n\t\tlinks[i].id = HEADSET_BE_ID;\n\t\tlinks[i].cpus = sof_sp;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(sof_sp);\n\t\tlinks[i].platforms = sof_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(sof_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].dpcm_capture = 1;\n\t\tlinks[i].nonatomic = true;\n\t\tlinks[i].no_pcm = 1;\n\t\tif (!drv_data->hs_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682) {\n\t\t\tlinks[i].codecs = rt5682;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682);\n\t\t\tlinks[i].init = acp_card_rt5682_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682_ops;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682S) {\n\t\t\tlinks[i].codecs = rt5682s;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682s);\n\t\t\tlinks[i].init = acp_card_rt5682s_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682s_ops;\n\t\t}\n\t\tif (drv_data->hs_codec_id == NAU8821) {\n\t\t\tlinks[i].codecs = nau8821;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(nau8821);\n\t\t\tlinks[i].init = acp_8821_init;\n\t\t\tlinks[i].ops = &acp_8821_ops;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->hs_cpu_id == I2S_HS) {\n\t\tlinks[i].name = \"acp-headset-codec\";\n\t\tlinks[i].id = HEADSET_BE_ID;\n\t\tlinks[i].cpus = sof_hs;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(sof_hs);\n\t\tlinks[i].platforms = sof_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(sof_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].dpcm_capture = 1;\n\t\tlinks[i].nonatomic = true;\n\t\tlinks[i].no_pcm = 1;\n\t\tif (!drv_data->hs_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->hs_codec_id == NAU8825) {\n\t\t\tlinks[i].codecs = nau8825;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(nau8825);\n\t\t\tlinks[i].init = acp_card_nau8825_init;\n\t\t\tlinks[i].ops = &acp_card_nau8825_ops;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682S) {\n\t\t\tlinks[i].codecs = rt5682s;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682s);\n\t\t\tlinks[i].init = acp_card_rt5682s_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682s_ops;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->amp_cpu_id == I2S_SP) {\n\t\tlinks[i].name = \"acp-amp-codec\";\n\t\tlinks[i].id = AMP_BE_ID;\n\t\tlinks[i].cpus = sof_sp_virtual;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(sof_sp_virtual);\n\t\tlinks[i].platforms = sof_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(sof_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].nonatomic = true;\n\t\tlinks[i].no_pcm = 1;\n\t\tif (!drv_data->amp_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->amp_codec_id == RT1019) {\n\t\t\tlinks[i].codecs = rt1019;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt1019);\n\t\t\tlinks[i].ops = &acp_card_rt1019_ops;\n\t\t\tlinks[i].init = acp_card_rt1019_init;\n\t\t\tcard->codec_conf = rt1019_conf;\n\t\t\tcard->num_configs = ARRAY_SIZE(rt1019_conf);\n\t\t}\n\t\tif (drv_data->amp_codec_id == MAX98360A) {\n\t\t\tlinks[i].codecs = max98360a;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(max98360a);\n\t\t\tlinks[i].ops = &acp_card_maxim_ops;\n\t\t\tlinks[i].init = acp_card_maxim_init;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->amp_cpu_id == I2S_HS) {\n\t\tlinks[i].name = \"acp-amp-codec\";\n\t\tlinks[i].id = AMP_BE_ID;\n\t\tlinks[i].cpus = sof_hs_virtual;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(sof_hs_virtual);\n\t\tlinks[i].platforms = sof_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(sof_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].nonatomic = true;\n\t\tlinks[i].no_pcm = 1;\n\t\tif (!drv_data->amp_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->amp_codec_id == MAX98360A) {\n\t\t\tlinks[i].codecs = max98360a;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(max98360a);\n\t\t\tlinks[i].ops = &acp_card_maxim_ops;\n\t\t\tlinks[i].init = acp_card_maxim_init;\n\t\t}\n\t\tif (drv_data->amp_codec_id == MAX98388) {\n\t\t\tlinks[i].codecs = max98388;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(max98388);\n\t\t\tlinks[i].ops = &acp_max98388_ops;\n\t\t\tlinks[i].init = acp_card_max98388_init;\n\t\t\tcard->codec_conf = max98388_conf;\n\t\t\tcard->num_configs = ARRAY_SIZE(max98388_conf);\n\t\t}\n\t\tif (drv_data->amp_codec_id == RT1019) {\n\t\t\tlinks[i].codecs = rt1019;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt1019);\n\t\t\tlinks[i].ops = &acp_card_rt1019_ops;\n\t\t\tlinks[i].init = acp_card_rt1019_init;\n\t\t\tcard->codec_conf = rt1019_conf;\n\t\t\tcard->num_configs = ARRAY_SIZE(rt1019_conf);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->dmic_cpu_id == DMIC) {\n\t\tlinks[i].name = \"acp-dmic-codec\";\n\t\tlinks[i].id = DMIC_BE_ID;\n\t\tlinks[i].codecs = dmic_codec;\n\t\tlinks[i].num_codecs = ARRAY_SIZE(dmic_codec);\n\t\tlinks[i].cpus = sof_dmic;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(sof_dmic);\n\t\tlinks[i].platforms = sof_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(sof_component);\n\t\tlinks[i].dpcm_capture = 1;\n\t\tlinks[i].nonatomic = true;\n\t\tlinks[i].no_pcm = 1;\n\t}\n\n\tcard->dai_link = links;\n\tcard->num_links = num_links;\n\tcard->set_bias_level = acp_rtk_set_bias_level;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_sofdsp_dai_links_create, SND_SOC_AMD_MACH);\n\nint acp_legacy_dai_links_create(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *links;\n\tstruct device *dev = card->dev;\n\tstruct acp_card_drvdata *drv_data = card->drvdata;\n\tint i = 0, num_links = 0;\n\n\tif (drv_data->hs_cpu_id)\n\t\tnum_links++;\n\tif (drv_data->amp_cpu_id)\n\t\tnum_links++;\n\tif (drv_data->dmic_cpu_id)\n\t\tnum_links++;\n\n\tlinks = devm_kcalloc(dev, num_links, sizeof(struct snd_soc_dai_link), GFP_KERNEL);\n\tif (!links)\n\t\treturn -ENOMEM;\n\n\tif (drv_data->hs_cpu_id == I2S_SP) {\n\t\tlinks[i].name = \"acp-headset-codec\";\n\t\tlinks[i].id = HEADSET_BE_ID;\n\t\tlinks[i].cpus = i2s_sp;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(i2s_sp);\n\t\tlinks[i].platforms = platform_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].dpcm_capture = 1;\n\t\tif (!drv_data->hs_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682) {\n\t\t\tlinks[i].codecs = rt5682;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682);\n\t\t\tlinks[i].init = acp_card_rt5682_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682_ops;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682S) {\n\t\t\tlinks[i].codecs = rt5682s;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682s);\n\t\t\tlinks[i].init = acp_card_rt5682s_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682s_ops;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->hs_cpu_id == I2S_HS) {\n\t\tlinks[i].name = \"acp-headset-codec\";\n\t\tlinks[i].id = HEADSET_BE_ID;\n\t\tlinks[i].cpus = i2s_hs;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(i2s_hs);\n\t\tif (drv_data->platform == REMBRANDT) {\n\t\t\tlinks[i].platforms = platform_rmb_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_rmb_component);\n\t\t} else {\n\t\t\tlinks[i].platforms = platform_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_component);\n\t\t}\n\t\tlinks[i].dpcm_playback = 1;\n\t\tlinks[i].dpcm_capture = 1;\n\t\tif (!drv_data->hs_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->hs_codec_id == NAU8825) {\n\t\t\tlinks[i].codecs = nau8825;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(nau8825);\n\t\t\tlinks[i].init = acp_card_nau8825_init;\n\t\t\tlinks[i].ops = &acp_card_nau8825_ops;\n\t\t}\n\t\tif (drv_data->hs_codec_id == RT5682S) {\n\t\t\tlinks[i].codecs = rt5682s;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt5682s);\n\t\t\tlinks[i].init = acp_card_rt5682s_init;\n\t\t\tlinks[i].ops = &acp_card_rt5682s_ops;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->amp_cpu_id == I2S_SP) {\n\t\tlinks[i].name = \"acp-amp-codec\";\n\t\tlinks[i].id = AMP_BE_ID;\n\t\tlinks[i].cpus = i2s_sp;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(i2s_sp);\n\t\tlinks[i].platforms = platform_component;\n\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_component);\n\t\tlinks[i].dpcm_playback = 1;\n\t\tif (!drv_data->amp_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->amp_codec_id == RT1019) {\n\t\t\tlinks[i].codecs = rt1019;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt1019);\n\t\t\tlinks[i].ops = &acp_card_rt1019_ops;\n\t\t\tlinks[i].init = acp_card_rt1019_init;\n\t\t\tcard->codec_conf = rt1019_conf;\n\t\t\tcard->num_configs = ARRAY_SIZE(rt1019_conf);\n\t\t}\n\t\tif (drv_data->amp_codec_id == MAX98360A) {\n\t\t\tlinks[i].codecs = max98360a;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(max98360a);\n\t\t\tlinks[i].ops = &acp_card_maxim_ops;\n\t\t\tlinks[i].init = acp_card_maxim_init;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->amp_cpu_id == I2S_HS) {\n\t\tlinks[i].name = \"acp-amp-codec\";\n\t\tlinks[i].id = AMP_BE_ID;\n\t\tlinks[i].cpus = i2s_hs;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(i2s_hs);\n\t\tif (drv_data->platform == REMBRANDT) {\n\t\t\tlinks[i].platforms = platform_rmb_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_rmb_component);\n\t\t} else {\n\t\t\tlinks[i].platforms = platform_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_component);\n\t\t}\n\t\tlinks[i].dpcm_playback = 1;\n\t\tif (!drv_data->amp_codec_id) {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tif (drv_data->amp_codec_id == MAX98360A) {\n\t\t\tlinks[i].codecs = max98360a;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(max98360a);\n\t\t\tlinks[i].ops = &acp_card_maxim_ops;\n\t\t\tlinks[i].init = acp_card_maxim_init;\n\t\t}\n\t\tif (drv_data->amp_codec_id == RT1019) {\n\t\t\tlinks[i].codecs = rt1019;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(rt1019);\n\t\t\tlinks[i].ops = &acp_card_rt1019_ops;\n\t\t\tlinks[i].init = acp_card_rt1019_init;\n\t\t\tcard->codec_conf = rt1019_conf;\n\t\t\tcard->num_configs = ARRAY_SIZE(rt1019_conf);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (drv_data->dmic_cpu_id == DMIC) {\n\t\tlinks[i].name = \"acp-dmic-codec\";\n\t\tlinks[i].id = DMIC_BE_ID;\n\t\tif (drv_data->dmic_codec_id == DMIC) {\n\t\t\tlinks[i].codecs = dmic_codec;\n\t\t\tlinks[i].num_codecs = ARRAY_SIZE(dmic_codec);\n\t\t} else {\n\t\t\t \n\t\t\tlinks[i].codecs = &asoc_dummy_dlc;\n\t\t\tlinks[i].num_codecs = 1;\n\t\t}\n\t\tlinks[i].cpus = pdm_dmic;\n\t\tlinks[i].num_cpus = ARRAY_SIZE(pdm_dmic);\n\t\tif (drv_data->platform == REMBRANDT) {\n\t\t\tlinks[i].platforms = platform_rmb_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_rmb_component);\n\t\t} else {\n\t\t\tlinks[i].platforms = platform_component;\n\t\t\tlinks[i].num_platforms = ARRAY_SIZE(platform_component);\n\t\t}\n\t\tlinks[i].ops = &acp_card_dmic_ops;\n\t\tlinks[i].dpcm_capture = 1;\n\t}\n\n\tcard->dai_link = links;\n\tcard->num_links = num_links;\n\tcard->set_bias_level = acp_rtk_set_bias_level;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(acp_legacy_dai_links_create, SND_SOC_AMD_MACH);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}