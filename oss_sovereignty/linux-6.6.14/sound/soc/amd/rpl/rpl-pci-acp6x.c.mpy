{
  "module_name": "rpl-pci-acp6x.c",
  "hash_id": "66e7742a7a62798d0e9d0cb26bb2c7b1007cab7051e2fa59e977690f8f3d8a4e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/rpl/rpl-pci-acp6x.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"rpl_acp6x.h\"\n\nstruct rpl_dev_data {\n\tvoid __iomem *acp6x_base;\n};\n\nstatic int rpl_power_on(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tval = rpl_acp_readl(acp_base + ACP_PGFSM_STATUS);\n\n\tif (!val)\n\t\treturn val;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) != ACP_POWER_ON_IN_PROGRESS)\n\t\trpl_acp_writel(ACP_PGFSM_CNTL_POWER_ON_MASK, acp_base + ACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rpl_acp_readl(acp_base + ACP_PGFSM_STATUS);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int rpl_reset(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\trpl_acp_writel(1, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rpl_acp_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\trpl_acp_writel(0, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rpl_acp_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int rpl_init(void __iomem *acp_base)\n{\n\tint ret;\n\n\t \n\tret = rpl_power_on(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\trpl_acp_writel(0x01, acp_base + ACP_CONTROL);\n\t \n\tret = rpl_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\trpl_acp_writel(0x03, acp_base + ACP_CLKMUX_SEL);\n\treturn 0;\n}\n\nstatic int rpl_deinit(void __iomem *acp_base)\n{\n\tint ret;\n\n\t \n\tret = rpl_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\trpl_acp_writel(0x00, acp_base + ACP_CLKMUX_SEL);\n\trpl_acp_writel(0x00, acp_base + ACP_CONTROL);\n\treturn 0;\n}\n\nstatic int snd_rpl_probe(struct pci_dev *pci,\n\t\t\t const struct pci_device_id *pci_id)\n{\n\tstruct rpl_dev_data *adata;\n\tu32 addr;\n\tint ret;\n\n\t \n\tswitch (pci->revision) {\n\tcase 0x62:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&pci->dev, \"acp6x pci device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP6x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct rpl_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp6x_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t\t pci_resource_len(pci, 0));\n\tif (!adata->acp6x_base) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\tret = rpl_init(adata->acp6x_base);\n\tif (ret)\n\t\tgoto release_regions;\n\tpm_runtime_set_autosuspend_delay(&pci->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\n\treturn 0;\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_rpl_suspend(struct device *dev)\n{\n\tstruct rpl_dev_data *adata;\n\tint ret;\n\n\tadata = dev_get_drvdata(dev);\n\tret = rpl_deinit(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_rpl_resume(struct device *dev)\n{\n\tstruct rpl_dev_data *adata;\n\tint ret;\n\n\tadata = dev_get_drvdata(dev);\n\tret = rpl_init(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops rpl_pm = {\n\tSET_RUNTIME_PM_OPS(snd_rpl_suspend, snd_rpl_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_rpl_suspend, snd_rpl_resume)\n};\n\nstatic void snd_rpl_remove(struct pci_dev *pci)\n{\n\tstruct rpl_dev_data *adata;\n\tint ret;\n\n\tadata = pci_get_drvdata(pci);\n\tret = rpl_deinit(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_rpl_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_rpl_ids);\n\nstatic struct pci_driver rpl_acp6x_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_rpl_ids,\n\t.probe = snd_rpl_probe,\n\t.remove = snd_rpl_remove,\n\t.driver = {\n\t\t.pm = &rpl_pm,\n\t}\n};\n\nmodule_pci_driver(rpl_acp6x_driver);\n\nMODULE_DESCRIPTION(\"AMD ACP RPL PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}