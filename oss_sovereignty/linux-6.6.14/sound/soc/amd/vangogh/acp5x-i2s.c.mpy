{
  "module_name": "acp5x-i2s.c",
  "hash_id": "6ab79383049bcef5eb7b3cbf18e3ca1b82c0db66e3e20edc79f589c0a358de32",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/vangogh/acp5x-i2s.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n\n#include \"acp5x.h\"\n\n#define DRV_NAME \"acp5x_i2s_playcap\"\n\nstatic int acp5x_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t     unsigned int fmt)\n{\n\tstruct i2s_dev_data *adata;\n\tint mode;\n\n\tadata = snd_soc_dai_get_drvdata(cpu_dai);\n\tmode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\tswitch (mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tadata->tdm_mode = TDM_DISABLE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tadata->tdm_mode = TDM_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmode = fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tswitch (mode) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tadata->master_mode = I2S_MASTER_MODE_ENABLE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tadata->master_mode = I2S_MASTER_MODE_DISABLE;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int acp5x_i2s_set_tdm_slot(struct snd_soc_dai *cpu_dai,\n\t\t\t\t  u32 tx_mask, u32 rx_mask,\n\t\t\t\t  int slots, int slot_width)\n{\n\tstruct i2s_dev_data *adata;\n\tu32 frm_len;\n\tu16 slot_len;\n\n\tadata = snd_soc_dai_get_drvdata(cpu_dai);\n\n\t \n\tswitch (slot_width) {\n\tcase SLOT_WIDTH_8:\n\t\tslot_len = 8;\n\t\tbreak;\n\tcase SLOT_WIDTH_16:\n\t\tslot_len = 16;\n\t\tbreak;\n\tcase SLOT_WIDTH_24:\n\t\tslot_len = 24;\n\t\tbreak;\n\tcase SLOT_WIDTH_32:\n\t\tslot_len = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfrm_len = FRM_LEN | (slots << 15) | (slot_len << 18);\n\tadata->tdm_fmt = frm_len;\n\treturn 0;\n}\n\nstatic int acp5x_i2s_hwparams(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct i2s_stream_instance *rtd;\n\tstruct snd_soc_pcm_runtime *prtd;\n\tstruct snd_soc_card *card;\n\tstruct acp5x_platform_info *pinfo;\n\tstruct i2s_dev_data *adata;\n\n\tu32 val;\n\tu32 reg_val, frmt_reg;\n\tu32 lrclk_div_val, bclk_div_val;\n\n\tlrclk_div_val = 0;\n\tbclk_div_val = 0;\n\tprtd = asoc_substream_to_rtd(substream);\n\trtd = substream->runtime->private_data;\n\tcard = prtd->card;\n\tadata = snd_soc_dai_get_drvdata(dai);\n\tpinfo = snd_soc_card_get_drvdata(card);\n\tif (pinfo) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trtd->i2s_instance = pinfo->play_i2s_instance;\n\t\telse\n\t\t\trtd->i2s_instance = pinfo->cap_i2s_instance;\n\t}\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\trtd->xfer_resolution = 0x0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trtd->xfer_resolution = 0x02;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\trtd->xfer_resolution = 0x04;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\trtd->xfer_resolution = 0x05;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\tfrmt_reg = ACP_HSTDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\tfrmt_reg = ACP_I2STDM_TXFRMT;\n\t\t}\n\t} else {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_HS_INSTANCE:\n\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\tfrmt_reg = ACP_HSTDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\tfrmt_reg = ACP_I2STDM_RXFRMT;\n\t\t}\n\t}\n\tif (adata->tdm_mode) {\n\t\tval = acp_readl(rtd->acp5x_base + reg_val);\n\t\tacp_writel(val | 0x2, rtd->acp5x_base + reg_val);\n\t\tacp_writel(adata->tdm_fmt, rtd->acp5x_base + frmt_reg);\n\t}\n\tval = acp_readl(rtd->acp5x_base + reg_val);\n\tval &= ~ACP5x_ITER_IRER_SAMP_LEN_MASK;\n\tval = val | (rtd->xfer_resolution  << 3);\n\tacp_writel(val, rtd->acp5x_base + reg_val);\n\n\tif (adata->master_mode) {\n\t\tswitch (params_format(params)) {\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tswitch (params_rate(params)) {\n\t\t\tcase 8000:\n\t\t\t\tbclk_div_val = 768;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\tbclk_div_val = 384;\n\t\t\t\tbreak;\n\t\t\tcase 24000:\n\t\t\t\tbclk_div_val = 256;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\tbclk_div_val = 192;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\tcase 48000:\n\t\t\t\tbclk_div_val = 128;\n\t\t\t\tbreak;\n\t\t\tcase 88200:\n\t\t\tcase 96000:\n\t\t\t\tbclk_div_val = 64;\n\t\t\t\tbreak;\n\t\t\tcase 192000:\n\t\t\t\tbclk_div_val = 32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlrclk_div_val = 32;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t\tswitch (params_rate(params)) {\n\t\t\tcase 8000:\n\t\t\t\tbclk_div_val = 384;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\tbclk_div_val = 192;\n\t\t\t\tbreak;\n\t\t\tcase 24000:\n\t\t\t\tbclk_div_val = 128;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\tbclk_div_val = 96;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\tcase 48000:\n\t\t\t\tbclk_div_val = 64;\n\t\t\t\tbreak;\n\t\t\tcase 88200:\n\t\t\tcase 96000:\n\t\t\t\tbclk_div_val = 32;\n\t\t\t\tbreak;\n\t\t\tcase 192000:\n\t\t\t\tbclk_div_val = 16;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlrclk_div_val = 64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trtd->lrclk_div = lrclk_div_val;\n\t\trtd->bclk_div = bclk_div_val;\n\t}\n\treturn 0;\n}\n\nstatic int acp5x_i2s_trigger(struct snd_pcm_substream *substream,\n\t\t\t     int cmd, struct snd_soc_dai *dai)\n{\n\tstruct i2s_stream_instance *rtd;\n\tstruct i2s_dev_data *adata;\n\tu32 ret, val, period_bytes, reg_val, ier_val, water_val;\n\tu32 buf_size, buf_reg;\n\n\tadata = snd_soc_dai_get_drvdata(dai);\n\trtd = substream->runtime->private_data;\n\tperiod_bytes = frames_to_bytes(substream->runtime,\n\t\t\t\t       substream->runtime->period_size);\n\tbuf_size = frames_to_bytes(substream->runtime,\n\t\t\t\t   substream->runtime->buffer_size);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\trtd->bytescount = acp_get_byte_count(rtd,\n\t\t\t\t\t\t     substream->stream);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\twater_val =\n\t\t\t\t\tACP_HS_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\t\tier_val = ACP_HSTDM_IER;\n\t\t\t\tbuf_reg = ACP_HS_TX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\twater_val =\n\t\t\t\t\tACP_I2S_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\t\tier_val = ACP_I2STDM_IER;\n\t\t\t\tbuf_reg = ACP_I2S_TX_RINGBUFSIZE;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\twater_val =\n\t\t\t\t\tACP_HS_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\t\tier_val = ACP_HSTDM_IER;\n\t\t\t\tbuf_reg = ACP_HS_RX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\twater_val =\n\t\t\t\t\tACP_I2S_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\t\tier_val = ACP_I2STDM_IER;\n\t\t\t\tbuf_reg = ACP_I2S_RX_RINGBUFSIZE;\n\t\t\t}\n\t\t}\n\t\tacp_writel(period_bytes, rtd->acp5x_base + water_val);\n\t\tacp_writel(buf_size, rtd->acp5x_base + buf_reg);\n\t\tif (adata->master_mode)\n\t\t\tacp5x_set_i2s_clk(adata, rtd);\n\t\tval = acp_readl(rtd->acp5x_base + reg_val);\n\t\tval = val | BIT(0);\n\t\tacp_writel(val, rtd->acp5x_base + reg_val);\n\t\tacp_writel(1, rtd->acp5x_base + ier_val);\n\t\tret = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\treg_val = ACP_HSTDM_ITER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\treg_val = ACP_I2STDM_ITER;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_HS_INSTANCE:\n\t\t\t\treg_val = ACP_HSTDM_IRER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\treg_val = ACP_I2STDM_IRER;\n\t\t\t}\n\t\t}\n\t\tval = acp_readl(rtd->acp5x_base + reg_val);\n\t\tval = val & ~BIT(0);\n\t\tacp_writel(val, rtd->acp5x_base + reg_val);\n\n\t\tif (!(acp_readl(rtd->acp5x_base + ACP_HSTDM_ITER) & BIT(0)) &&\n\t\t    !(acp_readl(rtd->acp5x_base + ACP_HSTDM_IRER) & BIT(0)))\n\t\t\tacp_writel(0, rtd->acp5x_base + ACP_HSTDM_IER);\n\t\tif (!(acp_readl(rtd->acp5x_base + ACP_I2STDM_ITER) & BIT(0)) &&\n\t\t    !(acp_readl(rtd->acp5x_base + ACP_I2STDM_IRER) & BIT(0)))\n\t\t\tacp_writel(0, rtd->acp5x_base + ACP_I2STDM_IER);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops acp5x_i2s_dai_ops = {\n\t.hw_params = acp5x_i2s_hwparams,\n\t.trigger = acp5x_i2s_trigger,\n\t.set_fmt = acp5x_i2s_set_fmt,\n\t.set_tdm_slot = acp5x_i2s_set_tdm_slot,\n};\n\nstatic const struct snd_soc_component_driver acp5x_dai_component = {\n\t.name = \"acp5x-i2s\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic struct snd_soc_dai_driver acp5x_i2s_dai = {\n\t.playback = {\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.ops = &acp5x_i2s_dai_ops,\n};\n\nstatic int acp5x_dai_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct i2s_dev_data *adata;\n\tint ret;\n\n\tadata = devm_kzalloc(&pdev->dev, sizeof(struct i2s_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tadata->acp5x_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res));\n\tif (!adata->acp5x_base)\n\t\treturn -ENOMEM;\n\n\tadata->master_mode = I2S_MASTER_MODE_ENABLE;\n\tdev_set_drvdata(&pdev->dev, adata);\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &acp5x_dai_component,\n\t\t\t\t\t      &acp5x_i2s_dai, 1);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Fail to register acp i2s dai\\n\");\n\treturn ret;\n}\n\nstatic struct platform_driver acp5x_dai_driver = {\n\t.probe = acp5x_dai_probe,\n\t.driver = {\n\t\t.name = \"acp5x_i2s_playcap\",\n\t},\n};\n\nmodule_platform_driver(acp5x_dai_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP5.x CPU DAI Driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}