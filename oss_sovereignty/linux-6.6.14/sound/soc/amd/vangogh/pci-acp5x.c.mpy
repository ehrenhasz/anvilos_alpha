{
  "module_name": "pci-acp5x.c",
  "hash_id": "ba6b421d15be3196ae7ce0a6e848084f3bf78b78fa306fd4a193f225d2657bf8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/vangogh/pci-acp5x.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include \"acp5x.h\"\n\nstruct acp5x_dev_data {\n\tvoid __iomem *acp5x_base;\n\tbool acp5x_audio_mode;\n\tstruct resource *res;\n\tstruct platform_device *pdev[ACP5x_DEVS];\n};\n\nstatic int acp5x_power_on(void __iomem *acp5x_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tval = acp_readl(acp5x_base + ACP_PGFSM_STATUS);\n\n\tif (val == 0)\n\t\treturn val;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) !=\n\t\t\t\tACP_POWER_ON_IN_PROGRESS)\n\t\tacp_writel(ACP_PGFSM_CNTL_POWER_ON_MASK,\n\t\t\t   acp5x_base + ACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp_readl(acp5x_base + ACP_PGFSM_STATUS);\n\t\tif ((val & ACP_PGFSM_STATUS_MASK) == ACP_POWERED_ON)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int acp5x_reset(void __iomem *acp5x_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tacp_writel(1, acp5x_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp_readl(acp5x_base + ACP_SOFT_RESET);\n\t\tif (val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tacp_writel(0, acp5x_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp_readl(acp5x_base + ACP_SOFT_RESET);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic void acp5x_enable_interrupts(void __iomem *acp5x_base)\n{\n\tacp_writel(0x01, acp5x_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic void acp5x_disable_interrupts(void __iomem *acp5x_base)\n{\n\tacp_writel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp5x_base +\n\t\t   ACP_EXTERNAL_INTR_STAT);\n\tacp_writel(0x00, acp5x_base + ACP_EXTERNAL_INTR_CNTL);\n\tacp_writel(0x00, acp5x_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic int acp5x_init(void __iomem *acp5x_base)\n{\n\tint ret;\n\n\t \n\tret = acp5x_power_on(acp5x_base);\n\tif (ret) {\n\t\tpr_err(\"ACP5x power on failed\\n\");\n\t\treturn ret;\n\t}\n\tacp_writel(0x01, acp5x_base + ACP_CONTROL);\n\t \n\tret = acp5x_reset(acp5x_base);\n\tif (ret) {\n\t\tpr_err(\"ACP5x reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp_writel(0x03, acp5x_base + ACP_CLKMUX_SEL);\n\tacp5x_enable_interrupts(acp5x_base);\n\treturn 0;\n}\n\nstatic int acp5x_deinit(void __iomem *acp5x_base)\n{\n\tint ret;\n\n\tacp5x_disable_interrupts(acp5x_base);\n\t \n\tret = acp5x_reset(acp5x_base);\n\tif (ret) {\n\t\tpr_err(\"ACP5x reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp_writel(0x00, acp5x_base + ACP_CLKMUX_SEL);\n\tacp_writel(0x00, acp5x_base + ACP_CONTROL);\n\treturn 0;\n}\n\nstatic int snd_acp5x_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct acp5x_dev_data *adata;\n\tstruct platform_device_info pdevinfo[ACP5x_DEVS];\n\tunsigned int irqflags, flag;\n\tint ret, i;\n\tu32 addr, val;\n\n\t \n\tflag = snd_amd_acp_find_config(pci);\n\tif (flag)\n\t\treturn -ENODEV;\n\n\tirqflags = IRQF_SHARED;\n\tif (pci->revision != 0x50)\n\t\treturn -ENODEV;\n\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP5x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct acp5x_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp5x_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t\t pci_resource_len(pci, 0));\n\tif (!adata->acp5x_base) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\tret = acp5x_init(adata->acp5x_base);\n\tif (ret)\n\t\tgoto release_regions;\n\n\tval = acp_readl(adata->acp5x_base + ACP_PIN_CONFIG);\n\tswitch (val) {\n\tcase I2S_MODE:\n\t\tadata->res = devm_kzalloc(&pci->dev,\n\t\t\t\t\t  sizeof(struct resource) * ACP5x_RES,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!adata->res) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto de_init;\n\t\t}\n\n\t\tadata->res[0].name = \"acp5x_i2s_iomem\";\n\t\tadata->res[0].flags = IORESOURCE_MEM;\n\t\tadata->res[0].start = addr;\n\t\tadata->res[0].end = addr + (ACP5x_REG_END - ACP5x_REG_START);\n\n\t\tadata->res[1].name = \"acp5x_i2s_sp\";\n\t\tadata->res[1].flags = IORESOURCE_MEM;\n\t\tadata->res[1].start = addr + ACP5x_I2STDM_REG_START;\n\t\tadata->res[1].end = addr + ACP5x_I2STDM_REG_END;\n\n\t\tadata->res[2].name = \"acp5x_i2s_hs\";\n\t\tadata->res[2].flags = IORESOURCE_MEM;\n\t\tadata->res[2].start = addr + ACP5x_HS_TDM_REG_START;\n\t\tadata->res[2].end = addr + ACP5x_HS_TDM_REG_END;\n\n\t\tadata->res[3].name = \"acp5x_i2s_irq\";\n\t\tadata->res[3].flags = IORESOURCE_IRQ;\n\t\tadata->res[3].start = pci->irq;\n\t\tadata->res[3].end = adata->res[3].start;\n\n\t\tadata->acp5x_audio_mode = ACP5x_I2S_MODE;\n\n\t\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t\tpdevinfo[0].name = \"acp5x_i2s_dma\";\n\t\tpdevinfo[0].id = 0;\n\t\tpdevinfo[0].parent = &pci->dev;\n\t\tpdevinfo[0].num_res = 4;\n\t\tpdevinfo[0].res = &adata->res[0];\n\t\tpdevinfo[0].data = &irqflags;\n\t\tpdevinfo[0].size_data = sizeof(irqflags);\n\n\t\tpdevinfo[1].name = \"acp5x_i2s_playcap\";\n\t\tpdevinfo[1].id = 0;\n\t\tpdevinfo[1].parent = &pci->dev;\n\t\tpdevinfo[1].num_res = 1;\n\t\tpdevinfo[1].res = &adata->res[1];\n\n\t\tpdevinfo[2].name = \"acp5x_i2s_playcap\";\n\t\tpdevinfo[2].id = 1;\n\t\tpdevinfo[2].parent = &pci->dev;\n\t\tpdevinfo[2].num_res = 1;\n\t\tpdevinfo[2].res = &adata->res[2];\n\n\t\tpdevinfo[3].name = \"acp5x_mach\";\n\t\tpdevinfo[3].id = 0;\n\t\tpdevinfo[3].parent = &pci->dev;\n\t\tfor (i = 0; i < ACP5x_DEVS; i++) {\n\t\t\tadata->pdev[i] =\n\t\t\t\tplatform_device_register_full(&pdevinfo[i]);\n\t\t\tif (IS_ERR(adata->pdev[i])) {\n\t\t\t\tdev_err(&pci->dev, \"cannot register %s device\\n\",\n\t\t\t\t\tpdevinfo[i].name);\n\t\t\t\tret = PTR_ERR(adata->pdev[i]);\n\t\t\t\tgoto unregister_devs;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&pci->dev, \"ACP audio mode : %d\\n\", val);\n\t}\n\tpm_runtime_set_autosuspend_delay(&pci->dev, 2000);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\treturn 0;\n\nunregister_devs:\n\tfor (--i; i >= 0; i--)\n\t\tplatform_device_unregister(adata->pdev[i]);\nde_init:\n\tif (acp5x_deinit(adata->acp5x_base))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp5x_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct acp5x_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp5x_deinit(adata->acp5x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\telse\n\t\tdev_dbg(dev, \"ACP de-initialized\\n\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp5x_resume(struct device *dev)\n{\n\tint ret;\n\tstruct acp5x_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp5x_init(adata->acp5x_base);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp5x_pm = {\n\tSET_RUNTIME_PM_OPS(snd_acp5x_suspend,\n\t\t\t   snd_acp5x_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_acp5x_suspend, snd_acp5x_resume)\n};\n\nstatic void snd_acp5x_remove(struct pci_dev *pci)\n{\n\tstruct acp5x_dev_data *adata;\n\tint i, ret;\n\n\tadata = pci_get_drvdata(pci);\n\tif (adata->acp5x_audio_mode == ACP5x_I2S_MODE) {\n\t\tfor (i = 0; i < ACP5x_DEVS; i++)\n\t\t\tplatform_device_unregister(adata->pdev[i]);\n\t}\n\tret = acp5x_deinit(adata->acp5x_base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_acp5x_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_acp5x_ids);\n\nstatic struct pci_driver acp5x_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_acp5x_ids,\n\t.probe = snd_acp5x_probe,\n\t.remove = snd_acp5x_remove,\n\t.driver = {\n\t\t.pm = &acp5x_pm,\n\t}\n};\n\nmodule_pci_driver(acp5x_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD Vangogh ACP PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}