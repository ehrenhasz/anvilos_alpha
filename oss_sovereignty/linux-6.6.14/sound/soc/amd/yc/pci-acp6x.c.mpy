{
  "module_name": "pci-acp6x.c",
  "hash_id": "a79139faec719d811bbb756e567eef23731d69269d9be9887ea70ea426ab7060",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/yc/pci-acp6x.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n\n#include \"acp6x.h\"\n\nstruct acp6x_dev_data {\n\tvoid __iomem *acp6x_base;\n\tstruct resource *res;\n\tbool acp6x_audio_mode;\n\tstruct platform_device *pdev[ACP6x_DEVS];\n};\n\nstatic int acp6x_power_on(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tval = acp6x_readl(acp_base + ACP_PGFSM_STATUS);\n\n\tif (!val)\n\t\treturn val;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) != ACP_POWER_ON_IN_PROGRESS)\n\t\tacp6x_writel(ACP_PGFSM_CNTL_POWER_ON_MASK, acp_base + ACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp6x_readl(acp_base + ACP_PGFSM_STATUS);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int acp6x_reset(void __iomem *acp_base)\n{\n\tu32 val;\n\tint timeout;\n\n\tacp6x_writel(1, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp6x_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tacp6x_writel(0, acp_base + ACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = acp6x_readl(acp_base + ACP_SOFT_RESET);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic void acp6x_enable_interrupts(void __iomem *acp_base)\n{\n\tacp6x_writel(0x01, acp_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic void acp6x_disable_interrupts(void __iomem *acp_base)\n{\n\tacp6x_writel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp_base +\n\t\t     ACP_EXTERNAL_INTR_STAT);\n\tacp6x_writel(0x00, acp_base + ACP_EXTERNAL_INTR_CNTL);\n\tacp6x_writel(0x00, acp_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic int acp6x_init(void __iomem *acp_base)\n{\n\tint ret;\n\n\t \n\tret = acp6x_power_on(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\tacp6x_writel(0x01, acp_base + ACP_CONTROL);\n\t \n\tret = acp6x_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp6x_writel(0x03, acp_base + ACP_CLKMUX_SEL);\n\tacp6x_enable_interrupts(acp_base);\n\treturn 0;\n}\n\nstatic int acp6x_deinit(void __iomem *acp_base)\n{\n\tint ret;\n\n\tacp6x_disable_interrupts(acp_base);\n\t \n\tret = acp6x_reset(acp_base);\n\tif (ret) {\n\t\tpr_err(\"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp6x_writel(0x00, acp_base + ACP_CLKMUX_SEL);\n\tacp6x_writel(0x00, acp_base + ACP_CONTROL);\n\treturn 0;\n}\n\nstatic irqreturn_t acp6x_irq_handler(int irq, void *dev_id)\n{\n\tstruct acp6x_dev_data *adata;\n\tstruct pdm_dev_data *yc_pdm_data;\n\tu32 val;\n\n\tadata = dev_id;\n\tif (!adata)\n\t\treturn IRQ_NONE;\n\n\tval = acp6x_readl(adata->acp6x_base + ACP_EXTERNAL_INTR_STAT);\n\tif (val & BIT(PDM_DMA_STAT)) {\n\t\tyc_pdm_data = dev_get_drvdata(&adata->pdev[0]->dev);\n\t\tacp6x_writel(BIT(PDM_DMA_STAT), adata->acp6x_base + ACP_EXTERNAL_INTR_STAT);\n\t\tif (yc_pdm_data->capture_stream)\n\t\t\tsnd_pcm_period_elapsed(yc_pdm_data->capture_stream);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int snd_acp6x_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct acp6x_dev_data *adata;\n\tstruct platform_device_info pdevinfo[ACP6x_DEVS];\n\tint index = 0;\n\tint val = 0x00;\n\tu32 addr;\n\tunsigned int irqflags, flag;\n\tint ret;\n\n\tirqflags = IRQF_SHARED;\n\n\t \n\tflag = snd_amd_acp_find_config(pci);\n\tif (flag)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (pci->revision) {\n\tcase 0x60:\n\tcase 0x6f:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&pci->dev, \"acp6x pci device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP3x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct acp6x_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp6x_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t\t pci_resource_len(pci, 0));\n\tif (!adata->acp6x_base) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\tret = acp6x_init(adata->acp6x_base);\n\tif (ret)\n\t\tgoto release_regions;\n\tval = acp6x_readl(adata->acp6x_base + ACP_PIN_CONFIG);\n\tswitch (val) {\n\tcase ACP_CONFIG_0:\n\tcase ACP_CONFIG_1:\n\tcase ACP_CONFIG_2:\n\tcase ACP_CONFIG_3:\n\tcase ACP_CONFIG_9:\n\tcase ACP_CONFIG_15:\n\t\tdev_info(&pci->dev, \"Audio Mode %d\\n\", val);\n\t\tbreak;\n\tdefault:\n\t\tadata->res = devm_kzalloc(&pci->dev,\n\t\t\t\t\t  sizeof(struct resource),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!adata->res) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto de_init;\n\t\t}\n\n\t\tadata->res->name = \"acp_iomem\";\n\t\tadata->res->flags = IORESOURCE_MEM;\n\t\tadata->res->start = addr;\n\t\tadata->res->end = addr + (ACP6x_REG_END - ACP6x_REG_START);\n\n\t\tadata->acp6x_audio_mode = ACP6x_PDM_MODE;\n\n\t\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t\tpdevinfo[0].name = \"acp_yc_pdm_dma\";\n\t\tpdevinfo[0].id = 0;\n\t\tpdevinfo[0].parent = &pci->dev;\n\t\tpdevinfo[0].num_res = 1;\n\t\tpdevinfo[0].res = adata->res;\n\n\t\tpdevinfo[1].name = \"dmic-codec\";\n\t\tpdevinfo[1].id = 0;\n\t\tpdevinfo[1].parent = &pci->dev;\n\n\t\tpdevinfo[2].name = \"acp_yc_mach\";\n\t\tpdevinfo[2].id = 0;\n\t\tpdevinfo[2].parent = &pci->dev;\n\n\t\tfor (index = 0; index < ACP6x_DEVS; index++) {\n\t\t\tadata->pdev[index] =\n\t\t\t\tplatform_device_register_full(&pdevinfo[index]);\n\t\t\tif (IS_ERR(adata->pdev[index])) {\n\t\t\t\tdev_err(&pci->dev, \"cannot register %s device\\n\",\n\t\t\t\t\tpdevinfo[index].name);\n\t\t\t\tret = PTR_ERR(adata->pdev[index]);\n\t\t\t\tgoto unregister_devs;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tret = devm_request_irq(&pci->dev, pci->irq, acp6x_irq_handler,\n\t\t\t       irqflags, \"ACP_PCI_IRQ\", adata);\n\tif (ret) {\n\t\tdev_err(&pci->dev, \"ACP PCI IRQ request failed\\n\");\n\t\tgoto unregister_devs;\n\t}\n\tpm_runtime_set_autosuspend_delay(&pci->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\n\treturn 0;\nunregister_devs:\n\tfor (--index; index >= 0; index--)\n\t\tplatform_device_unregister(adata->pdev[index]);\nde_init:\n\tif (acp6x_deinit(adata->acp6x_base))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp6x_suspend(struct device *dev)\n{\n\tstruct acp6x_dev_data *adata;\n\tint ret;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp6x_deinit(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp6x_resume(struct device *dev)\n{\n\tstruct acp6x_dev_data *adata;\n\tint ret;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp6x_init(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops acp6x_pm = {\n\tSET_RUNTIME_PM_OPS(snd_acp6x_suspend, snd_acp6x_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_acp6x_suspend, snd_acp6x_resume)\n};\n\nstatic void snd_acp6x_remove(struct pci_dev *pci)\n{\n\tstruct acp6x_dev_data *adata;\n\tint ret, index;\n\n\tadata = pci_get_drvdata(pci);\n\tif (adata->acp6x_audio_mode == ACP6x_PDM_MODE) {\n\t\tfor (index = 0; index < ACP6x_DEVS; index++)\n\t\t\tplatform_device_unregister(adata->pdev[index]);\n\t}\n\tret = acp6x_deinit(adata->acp6x_base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_acp6x_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_acp6x_ids);\n\nstatic struct pci_driver yc_acp6x_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_acp6x_ids,\n\t.probe = snd_acp6x_probe,\n\t.remove = snd_acp6x_remove,\n\t.driver = {\n\t\t.pm = &acp6x_pm,\n\t}\n};\n\nmodule_pci_driver(yc_acp6x_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP Yellow Carp PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}