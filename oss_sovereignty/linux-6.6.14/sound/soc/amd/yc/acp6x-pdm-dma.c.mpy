{
  "module_name": "acp6x-pdm-dma.c",
  "hash_id": "511d7ccfc1478a3231ea05219b141d4a2792e1935ac470d053949b06790b239c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/yc/acp6x-pdm-dma.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/pm_runtime.h>\n\n#include \"acp6x.h\"\n\n#define DRV_NAME \"acp_yc_pdm_dma\"\n\nstatic int pdm_gain = 3;\nmodule_param(pdm_gain, int, 0644);\nMODULE_PARM_DESC(pdm_gain, \"Gain control (0-3)\");\n\nstatic const struct snd_pcm_hardware acp6x_pdm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic void acp6x_init_pdm_ring_buffer(u32 physical_addr, u32 buffer_size,\n\t\t\t\t       u32 watermark_size, void __iomem *acp_base)\n{\n\tacp6x_writel(physical_addr, acp_base + ACP_WOV_RX_RINGBUFADDR);\n\tacp6x_writel(buffer_size, acp_base + ACP_WOV_RX_RINGBUFSIZE);\n\tacp6x_writel(watermark_size, acp_base + ACP_WOV_RX_INTR_WATERMARK_SIZE);\n\tacp6x_writel(0x01, acp_base + ACPAXI2AXI_ATU_CTRL);\n}\n\nstatic void acp6x_enable_pdm_clock(void __iomem *acp_base)\n{\n\tu32 pdm_clk_enable, pdm_ctrl;\n\n\tpdm_clk_enable = ACP_PDM_CLK_FREQ_MASK;\n\tpdm_ctrl = 0x00;\n\n\tacp6x_writel(pdm_clk_enable, acp_base + ACP_WOV_CLK_CTRL);\n\tpdm_ctrl = acp6x_readl(acp_base + ACP_WOV_MISC_CTRL);\n\tpdm_ctrl &= ~ACP_WOV_GAIN_CONTROL;\n\tpdm_ctrl |= FIELD_PREP(ACP_WOV_GAIN_CONTROL, clamp(pdm_gain, 0, 3));\n\tacp6x_writel(pdm_ctrl, acp_base + ACP_WOV_MISC_CTRL);\n}\n\nstatic void acp6x_enable_pdm_interrupts(void __iomem *acp_base)\n{\n\tu32 ext_int_ctrl;\n\n\text_int_ctrl = acp6x_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);\n\text_int_ctrl |= PDM_DMA_INTR_MASK;\n\tacp6x_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);\n}\n\nstatic void acp6x_disable_pdm_interrupts(void __iomem *acp_base)\n{\n\tu32 ext_int_ctrl;\n\n\text_int_ctrl = acp6x_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);\n\text_int_ctrl &= ~PDM_DMA_INTR_MASK;\n\tacp6x_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);\n}\n\nstatic bool acp6x_check_pdm_dma_status(void __iomem *acp_base)\n{\n\tbool pdm_dma_status;\n\tu32 pdm_enable, pdm_dma_enable;\n\n\tpdm_dma_status = false;\n\tpdm_enable = acp6x_readl(acp_base + ACP_WOV_PDM_ENABLE);\n\tpdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\tif ((pdm_enable & ACP_PDM_ENABLE) && (pdm_dma_enable & ACP_PDM_DMA_EN_STATUS))\n\t\tpdm_dma_status = true;\n\n\treturn pdm_dma_status;\n}\n\nstatic int acp6x_start_pdm_dma(void __iomem *acp_base)\n{\n\tu32 pdm_enable;\n\tu32 pdm_dma_enable;\n\tint timeout;\n\n\tpdm_enable = 0x01;\n\tpdm_dma_enable  = 0x01;\n\n\tacp6x_enable_pdm_clock(acp_base);\n\tacp6x_writel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);\n\tacp6x_writel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\ttimeout = 0;\n\twhile (++timeout < ACP_COUNTER) {\n\t\tpdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\tif ((pdm_dma_enable & 0x02) == ACP_PDM_DMA_EN_STATUS)\n\t\t\treturn 0;\n\t\tudelay(DELAY_US);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int acp6x_stop_pdm_dma(void __iomem *acp_base)\n{\n\tu32 pdm_enable, pdm_dma_enable;\n\tint timeout;\n\n\tpdm_enable = 0x00;\n\tpdm_dma_enable  = 0x00;\n\n\tpdm_enable = acp6x_readl(acp_base + ACP_WOV_PDM_ENABLE);\n\tpdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\tif (pdm_dma_enable & 0x01) {\n\t\tpdm_dma_enable = 0x02;\n\t\tacp6x_writel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\ttimeout = 0;\n\t\twhile (++timeout < ACP_COUNTER) {\n\t\t\tpdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\t\tif ((pdm_dma_enable & 0x02) == 0x00)\n\t\t\t\tbreak;\n\t\t\tudelay(DELAY_US);\n\t\t}\n\t\tif (timeout == ACP_COUNTER)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\tif (pdm_enable == ACP_PDM_ENABLE) {\n\t\tpdm_enable = ACP_PDM_DISABLE;\n\t\tacp6x_writel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);\n\t}\n\tacp6x_writel(0x01, acp_base + ACP_WOV_PDM_FIFO_FLUSH);\n\treturn 0;\n}\n\nstatic void acp6x_config_dma(struct pdm_stream_instance *rtd, int direction)\n{\n\tu16 page_idx;\n\tu32 low, high, val;\n\tdma_addr_t addr;\n\n\taddr = rtd->dma_addr;\n\tval = PDM_PTE_OFFSET;\n\n\t \n\tacp6x_writel(ACP_SRAM_PTE_OFFSET | BIT(31), rtd->acp6x_base +\n\t\t     ACPAXI2AXI_ATU_BASE_ADDR_GRP_1);\n\tacp6x_writel(PAGE_SIZE_4K_ENABLE, rtd->acp6x_base +\n\t\t     ACPAXI2AXI_ATU_PAGE_SIZE_GRP_1);\n\tfor (page_idx = 0; page_idx < rtd->num_pages; page_idx++) {\n\t\t \n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\n\t\tacp6x_writel(low, rtd->acp6x_base + ACP_SCRATCH_REG_0 + val);\n\t\thigh |= BIT(31);\n\t\tacp6x_writel(high, rtd->acp6x_base + ACP_SCRATCH_REG_0 + val + 4);\n\t\tval += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n}\n\nstatic int acp6x_pdm_dma_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct pdm_dev_data *adata;\n\tstruct pdm_stream_instance *pdm_data;\n\tint ret;\n\n\truntime = substream->runtime;\n\tadata = dev_get_drvdata(component->dev);\n\tpdm_data = kzalloc(sizeof(*pdm_data), GFP_KERNEL);\n\tif (!pdm_data)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\truntime->hw = acp6x_pdm_hardware_capture;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(pdm_data);\n\t\treturn ret;\n\t}\n\n\tacp6x_enable_pdm_interrupts(adata->acp6x_base);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tadata->capture_stream = substream;\n\n\tpdm_data->acp6x_base = adata->acp6x_base;\n\truntime->private_data = pdm_data;\n\treturn ret;\n}\n\nstatic int acp6x_pdm_dma_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct pdm_stream_instance *rtd;\n\tsize_t size, period_bytes;\n\n\trtd = substream->runtime->private_data;\n\tif (!rtd)\n\t\treturn -EINVAL;\n\tsize = params_buffer_bytes(params);\n\tperiod_bytes = params_period_bytes(params);\n\trtd->dma_addr = substream->runtime->dma_addr;\n\trtd->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);\n\tacp6x_config_dma(rtd, substream->stream);\n\tacp6x_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, size,\n\t\t\t\t   period_bytes, rtd->acp6x_base);\n\treturn 0;\n}\n\nstatic u64 acp6x_pdm_get_byte_count(struct pdm_stream_instance *rtd,\n\t\t\t\t    int direction)\n{\n\tunion acp_pdm_dma_count byte_count;\n\n\tbyte_count.bcount.high =\n\t\t\tacp6x_readl(rtd->acp6x_base + ACP_WOV_RX_LINEARPOSITIONCNTR_HIGH);\n\tbyte_count.bcount.low =\n\t\t\tacp6x_readl(rtd->acp6x_base + ACP_WOV_RX_LINEARPOSITIONCNTR_LOW);\n\treturn byte_count.bytescount;\n}\n\nstatic snd_pcm_uframes_t acp6x_pdm_dma_pointer(struct snd_soc_component *comp,\n\t\t\t\t\t       struct snd_pcm_substream *stream)\n{\n\tstruct pdm_stream_instance *rtd;\n\tu32 pos, buffersize;\n\tu64 bytescount;\n\n\trtd = stream->runtime->private_data;\n\tbuffersize = frames_to_bytes(stream->runtime,\n\t\t\t\t     stream->runtime->buffer_size);\n\tbytescount = acp6x_pdm_get_byte_count(rtd, stream->stream);\n\tif (bytescount > rtd->bytescount)\n\t\tbytescount -= rtd->bytescount;\n\tpos = do_div(bytescount, buffersize);\n\treturn bytes_to_frames(stream->runtime, pos);\n}\n\nstatic int acp6x_pdm_dma_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *parent = component->dev->parent;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       parent, MIN_BUFFER, MAX_BUFFER);\n\treturn 0;\n}\n\nstatic int acp6x_pdm_dma_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct pdm_dev_data *adata = dev_get_drvdata(component->dev);\n\n\tacp6x_disable_pdm_interrupts(adata->acp6x_base);\n\tadata->capture_stream = NULL;\n\treturn 0;\n}\n\nstatic int acp6x_pdm_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t int cmd, struct snd_soc_dai *dai)\n{\n\tstruct pdm_stream_instance *rtd;\n\tint ret;\n\tbool pdm_status;\n\tunsigned int ch_mask;\n\n\trtd = substream->runtime->private_data;\n\tret = 0;\n\tswitch (substream->runtime->channels) {\n\tcase TWO_CH:\n\t\tch_mask = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tacp6x_writel(ch_mask, rtd->acp6x_base + ACP_WOV_PDM_NO_OF_CHANNELS);\n\t\tacp6x_writel(PDM_DECIMATION_FACTOR, rtd->acp6x_base +\n\t\t\t     ACP_WOV_PDM_DECIMATION_FACTOR);\n\t\trtd->bytescount = acp6x_pdm_get_byte_count(rtd, substream->stream);\n\t\tpdm_status = acp6x_check_pdm_dma_status(rtd->acp6x_base);\n\t\tif (!pdm_status)\n\t\t\tret = acp6x_start_pdm_dma(rtd->acp6x_base);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tpdm_status = acp6x_check_pdm_dma_status(rtd->acp6x_base);\n\t\tif (pdm_status)\n\t\t\tret = acp6x_stop_pdm_dma(rtd->acp6x_base);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops acp6x_pdm_dai_ops = {\n\t.trigger   = acp6x_pdm_dai_trigger,\n};\n\nstatic struct snd_soc_dai_driver acp6x_pdm_dai_driver = {\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 48000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &acp6x_pdm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver acp6x_pdm_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.open\t\t\t= acp6x_pdm_dma_open,\n\t.close\t\t\t= acp6x_pdm_dma_close,\n\t.hw_params\t\t= acp6x_pdm_dma_hw_params,\n\t.pointer\t\t= acp6x_pdm_dma_pointer,\n\t.pcm_construct\t\t= acp6x_pdm_dma_new,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int acp6x_pdm_audio_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct pdm_dev_data *adata;\n\tint status;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata = devm_kzalloc(&pdev->dev, sizeof(*adata), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tadata->acp6x_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!adata->acp6x_base)\n\t\treturn -ENOMEM;\n\n\tadata->capture_stream = NULL;\n\n\tdev_set_drvdata(&pdev->dev, adata);\n\tstatus = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t\t &acp6x_pdm_component,\n\t\t\t\t\t\t &acp6x_pdm_dai_driver, 1);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Fail to register acp pdm dai\\n\");\n\n\t\treturn -ENODEV;\n\t}\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic void acp6x_pdm_audio_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused acp6x_pdm_resume(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct pdm_stream_instance *rtd;\n\tu32 period_bytes, buffer_len;\n\n\tadata = dev_get_drvdata(dev);\n\tif (adata->capture_stream && adata->capture_stream->runtime) {\n\t\truntime = adata->capture_stream->runtime;\n\t\trtd = runtime->private_data;\n\t\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\t\tbuffer_len = frames_to_bytes(runtime, runtime->buffer_size);\n\t\tacp6x_config_dma(rtd, SNDRV_PCM_STREAM_CAPTURE);\n\t\tacp6x_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, buffer_len,\n\t\t\t\t\t   period_bytes, adata->acp6x_base);\n\t}\n\tacp6x_enable_pdm_interrupts(adata->acp6x_base);\n\treturn 0;\n}\n\nstatic int __maybe_unused acp6x_pdm_suspend(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tacp6x_disable_pdm_interrupts(adata->acp6x_base);\n\treturn 0;\n}\n\nstatic int __maybe_unused acp6x_pdm_runtime_resume(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tacp6x_enable_pdm_interrupts(adata->acp6x_base);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp6x_pdm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(acp6x_pdm_suspend, acp6x_pdm_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(acp6x_pdm_suspend, acp6x_pdm_resume)\n};\n\nstatic struct platform_driver acp6x_pdm_dma_driver = {\n\t.probe = acp6x_pdm_audio_probe,\n\t.remove_new = acp6x_pdm_audio_remove,\n\t.driver = {\n\t\t.name = \"acp_yc_pdm_dma\",\n\t\t.pm = &acp6x_pdm_pm_ops,\n\t},\n};\n\nmodule_platform_driver(acp6x_pdm_dma_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP6x YC PDM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}