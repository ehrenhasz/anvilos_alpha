{
  "module_name": "acp3x-pcm-dma.c",
  "hash_id": "f45423b56f3630836aa3dd78f3711b034f27c9a6e3228d7c587537b839ba4f77",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/raven/acp3x-pcm-dma.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"acp3x.h\"\n\n#define DRV_NAME \"acp3x_rv_i2s_dma\"\n\nstatic const struct snd_pcm_hardware acp3x_pcm_hardware_playback = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |  SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t.rate_min = 8000,\n\t.rate_max = 96000,\n\t.buffer_bytes_max = PLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE,\n\t.period_bytes_min = PLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max = PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min = PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max = PLAYBACK_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp3x_pcm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic irqreturn_t i2s_irq_handler(int irq, void *dev_id)\n{\n\tstruct i2s_dev_data *rv_i2s_data;\n\tu16 play_flag, cap_flag;\n\tu32 val;\n\n\trv_i2s_data = dev_id;\n\tif (!rv_i2s_data)\n\t\treturn IRQ_NONE;\n\n\tplay_flag = 0;\n\tcap_flag = 0;\n\tval = rv_readl(rv_i2s_data->acp3x_base + mmACP_EXTERNAL_INTR_STAT);\n\tif ((val & BIT(BT_TX_THRESHOLD)) && rv_i2s_data->play_stream) {\n\t\trv_writel(BIT(BT_TX_THRESHOLD), rv_i2s_data->acp3x_base +\n\t\t\t  mmACP_EXTERNAL_INTR_STAT);\n\t\tsnd_pcm_period_elapsed(rv_i2s_data->play_stream);\n\t\tplay_flag = 1;\n\t}\n\tif ((val & BIT(I2S_TX_THRESHOLD)) &&\n\t\t\t\trv_i2s_data->i2ssp_play_stream) {\n\t\trv_writel(BIT(I2S_TX_THRESHOLD),\n\t\t\trv_i2s_data->acp3x_base\t+ mmACP_EXTERNAL_INTR_STAT);\n\t\tsnd_pcm_period_elapsed(rv_i2s_data->i2ssp_play_stream);\n\t\tplay_flag = 1;\n\t}\n\n\tif ((val & BIT(BT_RX_THRESHOLD)) && rv_i2s_data->capture_stream) {\n\t\trv_writel(BIT(BT_RX_THRESHOLD), rv_i2s_data->acp3x_base +\n\t\t\t  mmACP_EXTERNAL_INTR_STAT);\n\t\tsnd_pcm_period_elapsed(rv_i2s_data->capture_stream);\n\t\tcap_flag = 1;\n\t}\n\tif ((val & BIT(I2S_RX_THRESHOLD)) &&\n\t\t\t\trv_i2s_data->i2ssp_capture_stream) {\n\t\trv_writel(BIT(I2S_RX_THRESHOLD),\n\t\t\t rv_i2s_data->acp3x_base + mmACP_EXTERNAL_INTR_STAT);\n\t\tsnd_pcm_period_elapsed(rv_i2s_data->i2ssp_capture_stream);\n\t\tcap_flag = 1;\n\t}\n\n\tif (play_flag | cap_flag)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic void config_acp3x_dma(struct i2s_stream_instance *rtd, int direction)\n{\n\tu16 page_idx;\n\tu32 low, high, val, acp_fifo_addr, reg_fifo_addr;\n\tu32 reg_dma_size, reg_fifo_size;\n\tdma_addr_t addr;\n\n\taddr = rtd->dma_addr;\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tval = ACP_SRAM_BT_PB_PTE_OFFSET;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tval = ACP_SRAM_SP_PB_PTE_OFFSET;\n\t\t}\n\t} else {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tval = ACP_SRAM_BT_CP_PTE_OFFSET;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tval = ACP_SRAM_SP_CP_PTE_OFFSET;\n\t\t}\n\t}\n\t \n\trv_writel(ACP_SRAM_PTE_OFFSET | BIT(31), rtd->acp3x_base +\n\t\t  mmACPAXI2AXI_ATU_BASE_ADDR_GRP_1);\n\trv_writel(PAGE_SIZE_4K_ENABLE, rtd->acp3x_base +\n\t\t  mmACPAXI2AXI_ATU_PAGE_SIZE_GRP_1);\n\n\tfor (page_idx = 0; page_idx < rtd->num_pages; page_idx++) {\n\t\t \n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\n\t\trv_writel(low, rtd->acp3x_base + mmACP_SCRATCH_REG_0 + val);\n\t\thigh |= BIT(31);\n\t\trv_writel(high, rtd->acp3x_base + mmACP_SCRATCH_REG_0 + val\n\t\t\t\t+ 4);\n\t\t \n\t\tval += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_dma_size = mmACP_BT_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = ACP_SRAM_PTE_OFFSET +\n\t\t\t\t\t\tBT_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = mmACP_BT_TX_FIFOADDR;\n\t\t\treg_fifo_size = mmACP_BT_TX_FIFOSIZE;\n\t\t\trv_writel(I2S_BT_TX_MEM_WINDOW_START,\n\t\t\t\trtd->acp3x_base + mmACP_BT_TX_RINGBUFADDR);\n\t\t\tbreak;\n\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_dma_size = mmACP_I2S_TX_DMA_SIZE;\n\t\t\tacp_fifo_addr = ACP_SRAM_PTE_OFFSET +\n\t\t\t\t\t\tSP_PB_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr =\tmmACP_I2S_TX_FIFOADDR;\n\t\t\treg_fifo_size = mmACP_I2S_TX_FIFOSIZE;\n\t\t\trv_writel(I2S_SP_TX_MEM_WINDOW_START,\n\t\t\t\trtd->acp3x_base + mmACP_I2S_TX_RINGBUFADDR);\n\t\t}\n\t} else {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_dma_size = mmACP_BT_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = ACP_SRAM_PTE_OFFSET +\n\t\t\t\t\t\tBT_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = mmACP_BT_RX_FIFOADDR;\n\t\t\treg_fifo_size = mmACP_BT_RX_FIFOSIZE;\n\t\t\trv_writel(I2S_BT_RX_MEM_WINDOW_START,\n\t\t\t\trtd->acp3x_base + mmACP_BT_RX_RINGBUFADDR);\n\t\t\tbreak;\n\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_dma_size = mmACP_I2S_RX_DMA_SIZE;\n\t\t\tacp_fifo_addr = ACP_SRAM_PTE_OFFSET +\n\t\t\t\t\t\tSP_CAPT_FIFO_ADDR_OFFSET;\n\t\t\treg_fifo_addr = mmACP_I2S_RX_FIFOADDR;\n\t\t\treg_fifo_size = mmACP_I2S_RX_FIFOSIZE;\n\t\t\trv_writel(I2S_SP_RX_MEM_WINDOW_START,\n\t\t\t\trtd->acp3x_base + mmACP_I2S_RX_RINGBUFADDR);\n\t\t}\n\t}\n\trv_writel(DMA_SIZE, rtd->acp3x_base + reg_dma_size);\n\trv_writel(acp_fifo_addr, rtd->acp3x_base + reg_fifo_addr);\n\trv_writel(FIFO_SIZE, rtd->acp3x_base + reg_fifo_size);\n\trv_writel(BIT(I2S_RX_THRESHOLD) | BIT(BT_RX_THRESHOLD)\n\t\t| BIT(I2S_TX_THRESHOLD) | BIT(BT_TX_THRESHOLD),\n\t\trtd->acp3x_base + mmACP_EXTERNAL_INTR_CNTL);\n}\n\nstatic int acp3x_dma_open(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_soc_pcm_runtime *prtd;\n\tstruct i2s_dev_data *adata;\n\tstruct i2s_stream_instance *i2s_data;\n\tint ret;\n\n\truntime = substream->runtime;\n\tprtd = asoc_substream_to_rtd(substream);\n\tcomponent = snd_soc_rtdcom_lookup(prtd, DRV_NAME);\n\tadata = dev_get_drvdata(component->dev);\n\ti2s_data = kzalloc(sizeof(*i2s_data), GFP_KERNEL);\n\tif (!i2s_data)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = acp3x_pcm_hardware_playback;\n\telse\n\t\truntime->hw = acp3x_pcm_hardware_capture;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(i2s_data);\n\t\treturn ret;\n\t}\n\n\ti2s_data->acp3x_base = adata->acp3x_base;\n\truntime->private_data = i2s_data;\n\treturn ret;\n}\n\n\nstatic int acp3x_dma_hw_params(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct i2s_stream_instance *rtd;\n\tstruct snd_soc_pcm_runtime *prtd;\n\tstruct snd_soc_card *card;\n\tstruct acp3x_platform_info *pinfo;\n\tstruct i2s_dev_data *adata;\n\tu64 size;\n\n\tprtd = asoc_substream_to_rtd(substream);\n\tcard = prtd->card;\n\tpinfo = snd_soc_card_get_drvdata(card);\n\tadata = dev_get_drvdata(component->dev);\n\trtd = substream->runtime->private_data;\n\tif (!rtd)\n\t\treturn -EINVAL;\n\n\tif (pinfo) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\trtd->i2s_instance = pinfo->play_i2s_instance;\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\tadata->play_stream = substream;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\tadata->i2ssp_play_stream = substream;\n\t\t\t}\n\t\t} else {\n\t\t\trtd->i2s_instance = pinfo->cap_i2s_instance;\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\tadata->capture_stream = substream;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\tadata->i2ssp_capture_stream = substream;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpr_err(\"pinfo failed\\n\");\n\t}\n\tsize = params_buffer_bytes(params);\n\trtd->dma_addr = substream->runtime->dma_addr;\n\trtd->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);\n\tconfig_acp3x_dma(rtd, substream->stream);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t acp3x_dma_pointer(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct i2s_stream_instance *rtd;\n\tu32 pos;\n\tu32 buffersize;\n\tu64 bytescount;\n\n\trtd = substream->runtime->private_data;\n\n\tbuffersize = frames_to_bytes(substream->runtime,\n\t\t\t\t     substream->runtime->buffer_size);\n\tbytescount = acp_get_byte_count(rtd, substream->stream);\n\tif (bytescount > rtd->bytescount)\n\t\tbytescount -= rtd->bytescount;\n\tpos = do_div(bytescount, buffersize);\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic int acp3x_dma_new(struct snd_soc_component *component,\n\t\t\t struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *parent = component->dev->parent;\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       parent, MIN_BUFFER, MAX_BUFFER);\n\treturn 0;\n}\n\nstatic int acp3x_dma_close(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *prtd;\n\tstruct i2s_dev_data *adata;\n\tstruct i2s_stream_instance *ins;\n\n\tprtd = asoc_substream_to_rtd(substream);\n\tcomponent = snd_soc_rtdcom_lookup(prtd, DRV_NAME);\n\tadata = dev_get_drvdata(component->dev);\n\tins = substream->runtime->private_data;\n\tif (!ins)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (ins->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tadata->play_stream = NULL;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tadata->i2ssp_play_stream = NULL;\n\t\t}\n\t} else {\n\t\tswitch (ins->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\tadata->capture_stream = NULL;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\tadata->i2ssp_capture_stream = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver acp3x_i2s_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= acp3x_dma_open,\n\t.close\t\t= acp3x_dma_close,\n\t.hw_params\t= acp3x_dma_hw_params,\n\t.pointer\t= acp3x_dma_pointer,\n\t.pcm_construct\t= acp3x_dma_new,\n};\n\nstatic int acp3x_audio_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct i2s_dev_data *adata;\n\tunsigned int irqflags;\n\tint status;\n\n\tif (!pdev->dev.platform_data) {\n\t\tdev_err(&pdev->dev, \"platform_data not retrieved\\n\");\n\t\treturn -ENODEV;\n\t}\n\tirqflags = *((unsigned int *)(pdev->dev.platform_data));\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata = devm_kzalloc(&pdev->dev, sizeof(*adata), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tadata->acp3x_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res));\n\tif (!adata->acp3x_base)\n\t\treturn -ENOMEM;\n\n\tstatus = platform_get_irq(pdev, 0);\n\tif (status < 0)\n\t\treturn status;\n\tadata->i2s_irq = status;\n\n\tdev_set_drvdata(&pdev->dev, adata);\n\tstatus = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t\t &acp3x_i2s_component,\n\t\t\t\t\t\t NULL, 0);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Fail to register acp i2s component\\n\");\n\t\treturn -ENODEV;\n\t}\n\tstatus = devm_request_irq(&pdev->dev, adata->i2s_irq, i2s_irq_handler,\n\t\t\t\t  irqflags, \"ACP3x_I2S_IRQ\", adata);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"ACP3x I2S IRQ request failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 2000);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic void acp3x_audio_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int acp3x_resume(struct device *dev)\n{\n\tstruct i2s_dev_data *adata;\n\tu32 val, reg_val, frmt_val;\n\n\treg_val = 0;\n\tfrmt_val = 0;\n\tadata = dev_get_drvdata(dev);\n\n\tif (adata->play_stream && adata->play_stream->runtime) {\n\t\tstruct i2s_stream_instance *rtd =\n\t\t\tadata->play_stream->runtime->private_data;\n\t\tconfig_acp3x_dma(rtd, SNDRV_PCM_STREAM_PLAYBACK);\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = mmACP_BTTDM_ITER;\n\t\t\tfrmt_val = mmACP_BTTDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = mmACP_I2STDM_ITER;\n\t\t\tfrmt_val = mmACP_I2STDM_TXFRMT;\n\t\t}\n\t\trv_writel((rtd->xfer_resolution  << 3),\n\t\t\t  rtd->acp3x_base + reg_val);\n\t}\n\tif (adata->capture_stream && adata->capture_stream->runtime) {\n\t\tstruct i2s_stream_instance *rtd =\n\t\t\tadata->capture_stream->runtime->private_data;\n\t\tconfig_acp3x_dma(rtd, SNDRV_PCM_STREAM_CAPTURE);\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = mmACP_BTTDM_IRER;\n\t\t\tfrmt_val = mmACP_BTTDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = mmACP_I2STDM_IRER;\n\t\t\tfrmt_val = mmACP_I2STDM_RXFRMT;\n\t\t}\n\t\trv_writel((rtd->xfer_resolution  << 3),\n\t\t\t  rtd->acp3x_base + reg_val);\n\t}\n\tif (adata->tdm_mode == TDM_ENABLE) {\n\t\trv_writel(adata->tdm_fmt, adata->acp3x_base + frmt_val);\n\t\tval = rv_readl(adata->acp3x_base + reg_val);\n\t\trv_writel(val | 0x2, adata->acp3x_base + reg_val);\n\t}\n\trv_writel(1, adata->acp3x_base + mmACP_EXTERNAL_INTR_ENB);\n\treturn 0;\n}\n\n\nstatic int acp3x_pcm_runtime_suspend(struct device *dev)\n{\n\tstruct i2s_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\n\trv_writel(0, adata->acp3x_base + mmACP_EXTERNAL_INTR_ENB);\n\n\treturn 0;\n}\n\nstatic int acp3x_pcm_runtime_resume(struct device *dev)\n{\n\tstruct i2s_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\n\trv_writel(1, adata->acp3x_base + mmACP_EXTERNAL_INTR_ENB);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp3x_pm_ops = {\n\t.runtime_suspend = acp3x_pcm_runtime_suspend,\n\t.runtime_resume = acp3x_pcm_runtime_resume,\n\t.resume = acp3x_resume,\n};\n\nstatic struct platform_driver acp3x_dma_driver = {\n\t.probe = acp3x_audio_probe,\n\t.remove_new = acp3x_audio_remove,\n\t.driver = {\n\t\t.name = \"acp3x_rv_i2s_dma\",\n\t\t.pm = &acp3x_pm_ops,\n\t},\n};\n\nmodule_platform_driver(acp3x_dma_driver);\n\nMODULE_AUTHOR(\"Vishnuvardhanrao.Ravulapati@amd.com\");\nMODULE_AUTHOR(\"Maruthi.Bayyavarapu@amd.com\");\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP 3.x PCM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\"DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}