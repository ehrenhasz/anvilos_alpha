{
  "module_name": "pci-acp3x.c",
  "hash_id": "d908cb8448b32b60ffbfcb08c271722256b120b1a41fe522c332c9bc77feb146",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/raven/pci-acp3x.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n\n#include \"acp3x.h\"\n\nstruct acp3x_dev_data {\n\tvoid __iomem *acp3x_base;\n\tbool acp3x_audio_mode;\n\tstruct resource *res;\n\tstruct platform_device *pdev[ACP3x_DEVS];\n\tu32 pme_en;\n};\n\nstatic int acp3x_power_on(struct acp3x_dev_data *adata)\n{\n\tvoid __iomem *acp3x_base = adata->acp3x_base;\n\tu32 val;\n\tint timeout;\n\n\tval = rv_readl(acp3x_base + mmACP_PGFSM_STATUS);\n\n\tif (val == 0)\n\t\treturn val;\n\n\tif (!((val & ACP_PGFSM_STATUS_MASK) ==\n\t\t\t\tACP_POWER_ON_IN_PROGRESS))\n\t\trv_writel(ACP_PGFSM_CNTL_POWER_ON_MASK,\n\t\t\tacp3x_base + mmACP_PGFSM_CONTROL);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rv_readl(acp3x_base + mmACP_PGFSM_STATUS);\n\t\tif (!val) {\n\t\t\t \n\t\t\trv_writel(adata->pme_en, acp3x_base + mmACP_PME_EN);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int acp3x_reset(void __iomem *acp3x_base)\n{\n\tu32 val;\n\tint timeout;\n\n\trv_writel(1, acp3x_base + mmACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rv_readl(acp3x_base + mmACP_SOFT_RESET);\n\t\tif (val & ACP3x_SOFT_RESET__SoftResetAudDone_MASK)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\trv_writel(0, acp3x_base + mmACP_SOFT_RESET);\n\ttimeout = 0;\n\twhile (++timeout < 500) {\n\t\tval = rv_readl(acp3x_base + mmACP_SOFT_RESET);\n\t\tif (!val)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic void acp3x_enable_interrupts(void __iomem *acp_base)\n{\n\trv_writel(0x01, acp_base + mmACP_EXTERNAL_INTR_ENB);\n}\n\nstatic void acp3x_disable_interrupts(void __iomem *acp_base)\n{\n\trv_writel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp_base +\n\t\t  mmACP_EXTERNAL_INTR_STAT);\n\trv_writel(0x00, acp_base + mmACP_EXTERNAL_INTR_CNTL);\n\trv_writel(0x00, acp_base + mmACP_EXTERNAL_INTR_ENB);\n}\n\nstatic int acp3x_init(struct acp3x_dev_data *adata)\n{\n\tvoid __iomem *acp3x_base = adata->acp3x_base;\n\tint ret;\n\n\t \n\tret = acp3x_power_on(adata);\n\tif (ret) {\n\t\tpr_err(\"ACP3x power on failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tret = acp3x_reset(acp3x_base);\n\tif (ret) {\n\t\tpr_err(\"ACP3x reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp3x_enable_interrupts(acp3x_base);\n\treturn 0;\n}\n\nstatic int acp3x_deinit(void __iomem *acp3x_base)\n{\n\tint ret;\n\n\tacp3x_disable_interrupts(acp3x_base);\n\t \n\tret = acp3x_reset(acp3x_base);\n\tif (ret) {\n\t\tpr_err(\"ACP3x reset failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int snd_acp3x_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct acp3x_dev_data *adata;\n\tstruct platform_device_info pdevinfo[ACP3x_DEVS];\n\tunsigned int irqflags;\n\tint ret, i;\n\tu32 addr, val;\n\n\t \n\tif (pci->revision != 0x00)\n\t\treturn -ENODEV;\n\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP3x audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct acp3x_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n\tirqflags = IRQF_SHARED;\n\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp3x_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t\tpci_resource_len(pci, 0));\n\tif (!adata->acp3x_base) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\t \n\tadata->pme_en = rv_readl(adata->acp3x_base + mmACP_PME_EN);\n\tret = acp3x_init(adata);\n\tif (ret)\n\t\tgoto release_regions;\n\n\tval = rv_readl(adata->acp3x_base + mmACP_I2S_PIN_CONFIG);\n\tswitch (val) {\n\tcase I2S_MODE:\n\t\tadata->res = devm_kzalloc(&pci->dev,\n\t\t\t\t\t  sizeof(struct resource) * 4,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!adata->res) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto de_init;\n\t\t}\n\n\t\tadata->res[0].name = \"acp3x_i2s_iomem\";\n\t\tadata->res[0].flags = IORESOURCE_MEM;\n\t\tadata->res[0].start = addr;\n\t\tadata->res[0].end = addr + (ACP3x_REG_END - ACP3x_REG_START);\n\n\t\tadata->res[1].name = \"acp3x_i2s_sp\";\n\t\tadata->res[1].flags = IORESOURCE_MEM;\n\t\tadata->res[1].start = addr + ACP3x_I2STDM_REG_START;\n\t\tadata->res[1].end = addr + ACP3x_I2STDM_REG_END;\n\n\t\tadata->res[2].name = \"acp3x_i2s_bt\";\n\t\tadata->res[2].flags = IORESOURCE_MEM;\n\t\tadata->res[2].start = addr + ACP3x_BT_TDM_REG_START;\n\t\tadata->res[2].end = addr + ACP3x_BT_TDM_REG_END;\n\n\t\tadata->res[3].name = \"acp3x_i2s_irq\";\n\t\tadata->res[3].flags = IORESOURCE_IRQ;\n\t\tadata->res[3].start = pci->irq;\n\t\tadata->res[3].end = adata->res[3].start;\n\n\t\tadata->acp3x_audio_mode = ACP3x_I2S_MODE;\n\n\t\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t\tpdevinfo[0].name = \"acp3x_rv_i2s_dma\";\n\t\tpdevinfo[0].id = 0;\n\t\tpdevinfo[0].parent = &pci->dev;\n\t\tpdevinfo[0].num_res = 4;\n\t\tpdevinfo[0].res = &adata->res[0];\n\t\tpdevinfo[0].data = &irqflags;\n\t\tpdevinfo[0].size_data = sizeof(irqflags);\n\n\t\tpdevinfo[1].name = \"acp3x_i2s_playcap\";\n\t\tpdevinfo[1].id = 0;\n\t\tpdevinfo[1].parent = &pci->dev;\n\t\tpdevinfo[1].num_res = 1;\n\t\tpdevinfo[1].res = &adata->res[1];\n\n\t\tpdevinfo[2].name = \"acp3x_i2s_playcap\";\n\t\tpdevinfo[2].id = 1;\n\t\tpdevinfo[2].parent = &pci->dev;\n\t\tpdevinfo[2].num_res = 1;\n\t\tpdevinfo[2].res = &adata->res[1];\n\n\t\tpdevinfo[3].name = \"acp3x_i2s_playcap\";\n\t\tpdevinfo[3].id = 2;\n\t\tpdevinfo[3].parent = &pci->dev;\n\t\tpdevinfo[3].num_res = 1;\n\t\tpdevinfo[3].res = &adata->res[2];\n\t\tfor (i = 0; i < ACP3x_DEVS; i++) {\n\t\t\tadata->pdev[i] =\n\t\t\t\tplatform_device_register_full(&pdevinfo[i]);\n\t\t\tif (IS_ERR(adata->pdev[i])) {\n\t\t\t\tdev_err(&pci->dev, \"cannot register %s device\\n\",\n\t\t\t\t\tpdevinfo[i].name);\n\t\t\t\tret = PTR_ERR(adata->pdev[i]);\n\t\t\t\tgoto unregister_devs;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&pci->dev, \"ACP audio mode : %d\\n\", val);\n\t\tbreak;\n\t}\n\tpm_runtime_set_autosuspend_delay(&pci->dev, 2000);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\treturn 0;\n\nunregister_devs:\n\tif (val == I2S_MODE)\n\t\tfor (i = 0; i < ACP3x_DEVS; i++)\n\t\t\tplatform_device_unregister(adata->pdev[i]);\nde_init:\n\tif (acp3x_deinit(adata->acp3x_base))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int snd_acp3x_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct acp3x_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp3x_deinit(adata->acp3x_base);\n\tif (ret)\n\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\telse\n\t\tdev_dbg(dev, \"ACP de-initialized\\n\");\n\n\treturn 0;\n}\n\nstatic int snd_acp3x_resume(struct device *dev)\n{\n\tint ret;\n\tstruct acp3x_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tret = acp3x_init(adata);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP init failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp3x_pm = {\n\t.runtime_suspend = snd_acp3x_suspend,\n\t.runtime_resume =  snd_acp3x_resume,\n\t.resume =\tsnd_acp3x_resume,\n};\n\nstatic void snd_acp3x_remove(struct pci_dev *pci)\n{\n\tstruct acp3x_dev_data *adata;\n\tint i, ret;\n\n\tadata = pci_get_drvdata(pci);\n\tif (adata->acp3x_audio_mode == ACP3x_I2S_MODE) {\n\t\tfor (i = 0; i < ACP3x_DEVS; i++)\n\t\t\tplatform_device_unregister(adata->pdev[i]);\n\t}\n\tret = acp3x_deinit(adata->acp3x_base);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_acp3x_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, 0x15e2),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_acp3x_ids);\n\nstatic struct pci_driver acp3x_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_acp3x_ids,\n\t.probe = snd_acp3x_probe,\n\t.remove = snd_acp3x_remove,\n\t.driver = {\n\t\t.pm = &acp3x_pm,\n\t}\n};\n\nmodule_pci_driver(acp3x_driver);\n\nMODULE_AUTHOR(\"Vishnuvardhanrao.Ravulapati@amd.com\");\nMODULE_AUTHOR(\"Maruthi.Bayyavarapu@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP3x PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}