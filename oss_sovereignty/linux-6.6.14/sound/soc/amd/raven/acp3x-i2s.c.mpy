{
  "module_name": "acp3x-i2s.c",
  "hash_id": "5920a4590fa27d5240f36e2047781c260a0b290f1f6a9a8171528d2c244a9bec",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/raven/acp3x-i2s.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/dma-mapping.h>\n\n#include \"acp3x.h\"\n\n#define DRV_NAME \"acp3x_i2s_playcap\"\n\nstatic int acp3x_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t\tunsigned int fmt)\n{\n\tstruct i2s_dev_data *adata;\n\tint mode;\n\n\tadata = snd_soc_dai_get_drvdata(cpu_dai);\n\tmode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\tswitch (mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tadata->tdm_mode = TDM_DISABLE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tadata->tdm_mode = TDM_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int acp3x_i2s_set_tdm_slot(struct snd_soc_dai *cpu_dai,\n\t\tu32 tx_mask, u32 rx_mask, int slots, int slot_width)\n{\n\tstruct i2s_dev_data *adata;\n\tu32 frm_len;\n\tu16 slot_len;\n\n\tadata = snd_soc_dai_get_drvdata(cpu_dai);\n\n\t \n\tswitch (slot_width) {\n\tcase SLOT_WIDTH_8:\n\t\tslot_len = 8;\n\t\tbreak;\n\tcase SLOT_WIDTH_16:\n\t\tslot_len = 16;\n\t\tbreak;\n\tcase SLOT_WIDTH_24:\n\t\tslot_len = 24;\n\t\tbreak;\n\tcase SLOT_WIDTH_32:\n\t\tslot_len = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfrm_len = FRM_LEN | (slots << 15) | (slot_len << 18);\n\tadata->tdm_fmt = frm_len;\n\treturn 0;\n}\n\nstatic int acp3x_i2s_hwparams(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct i2s_stream_instance *rtd;\n\tstruct snd_soc_pcm_runtime *prtd;\n\tstruct snd_soc_card *card;\n\tstruct acp3x_platform_info *pinfo;\n\tstruct i2s_dev_data *adata;\n\tu32 val;\n\tu32 reg_val, frmt_reg;\n\n\tprtd = asoc_substream_to_rtd(substream);\n\trtd = substream->runtime->private_data;\n\tcard = prtd->card;\n\tadata = snd_soc_dai_get_drvdata(dai);\n\tpinfo = snd_soc_card_get_drvdata(card);\n\tif (pinfo) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trtd->i2s_instance = pinfo->play_i2s_instance;\n\t\telse\n\t\t\trtd->i2s_instance = pinfo->cap_i2s_instance;\n\t}\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\trtd->xfer_resolution = 0x0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trtd->xfer_resolution = 0x02;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\trtd->xfer_resolution = 0x04;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\trtd->xfer_resolution = 0x05;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = mmACP_BTTDM_ITER;\n\t\t\tfrmt_reg = mmACP_BTTDM_TXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = mmACP_I2STDM_ITER;\n\t\t\tfrmt_reg = mmACP_I2STDM_TXFRMT;\n\t\t}\n\t} else {\n\t\tswitch (rtd->i2s_instance) {\n\t\tcase I2S_BT_INSTANCE:\n\t\t\treg_val = mmACP_BTTDM_IRER;\n\t\t\tfrmt_reg = mmACP_BTTDM_RXFRMT;\n\t\t\tbreak;\n\t\tcase I2S_SP_INSTANCE:\n\t\tdefault:\n\t\t\treg_val = mmACP_I2STDM_IRER;\n\t\t\tfrmt_reg = mmACP_I2STDM_RXFRMT;\n\t\t}\n\t}\n\tif (adata->tdm_mode) {\n\t\tval = rv_readl(rtd->acp3x_base + reg_val);\n\t\trv_writel(val | 0x2, rtd->acp3x_base + reg_val);\n\t\trv_writel(adata->tdm_fmt, rtd->acp3x_base + frmt_reg);\n\t}\n\tval = rv_readl(rtd->acp3x_base + reg_val);\n\tval &= ~ACP3x_ITER_IRER_SAMP_LEN_MASK;\n\tval = val | (rtd->xfer_resolution  << 3);\n\trv_writel(val, rtd->acp3x_base + reg_val);\n\treturn 0;\n}\n\nstatic int acp3x_i2s_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct i2s_stream_instance *rtd;\n\tu32 ret, val, period_bytes, reg_val, ier_val, water_val;\n\tu32 buf_size, buf_reg;\n\n\trtd = substream->runtime->private_data;\n\tperiod_bytes = frames_to_bytes(substream->runtime,\n\t\t\tsubstream->runtime->period_size);\n\tbuf_size = frames_to_bytes(substream->runtime,\n\t\t\tsubstream->runtime->buffer_size);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\trtd->bytescount = acp_get_byte_count(rtd,\n\t\t\t\t\t\tsubstream->stream);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\twater_val =\n\t\t\t\t\tmmACP_BT_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = mmACP_BTTDM_ITER;\n\t\t\t\tier_val = mmACP_BTTDM_IER;\n\t\t\t\tbuf_reg = mmACP_BT_TX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\twater_val =\n\t\t\t\t\tmmACP_I2S_TX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = mmACP_I2STDM_ITER;\n\t\t\t\tier_val = mmACP_I2STDM_IER;\n\t\t\t\tbuf_reg = mmACP_I2S_TX_RINGBUFSIZE;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\twater_val =\n\t\t\t\t\tmmACP_BT_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = mmACP_BTTDM_IRER;\n\t\t\t\tier_val = mmACP_BTTDM_IER;\n\t\t\t\tbuf_reg = mmACP_BT_RX_RINGBUFSIZE;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\twater_val =\n\t\t\t\t\tmmACP_I2S_RX_INTR_WATERMARK_SIZE;\n\t\t\t\treg_val = mmACP_I2STDM_IRER;\n\t\t\t\tier_val = mmACP_I2STDM_IER;\n\t\t\t\tbuf_reg = mmACP_I2S_RX_RINGBUFSIZE;\n\t\t\t}\n\t\t}\n\t\trv_writel(period_bytes, rtd->acp3x_base + water_val);\n\t\trv_writel(buf_size, rtd->acp3x_base + buf_reg);\n\t\tval = rv_readl(rtd->acp3x_base + reg_val);\n\t\tval = val | BIT(0);\n\t\trv_writel(val, rtd->acp3x_base + reg_val);\n\t\trv_writel(1, rtd->acp3x_base + ier_val);\n\t\tret = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\treg_val = mmACP_BTTDM_ITER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\treg_val = mmACP_I2STDM_ITER;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch (rtd->i2s_instance) {\n\t\t\tcase I2S_BT_INSTANCE:\n\t\t\t\treg_val = mmACP_BTTDM_IRER;\n\t\t\t\tbreak;\n\t\t\tcase I2S_SP_INSTANCE:\n\t\t\tdefault:\n\t\t\t\treg_val = mmACP_I2STDM_IRER;\n\t\t\t}\n\t\t}\n\t\tval = rv_readl(rtd->acp3x_base + reg_val);\n\t\tval = val & ~BIT(0);\n\t\trv_writel(val, rtd->acp3x_base + reg_val);\n\n\t\tif (!(rv_readl(rtd->acp3x_base + mmACP_BTTDM_ITER) & BIT(0)) &&\n\t\t     !(rv_readl(rtd->acp3x_base + mmACP_BTTDM_IRER) & BIT(0)))\n\t\t\trv_writel(0, rtd->acp3x_base + mmACP_BTTDM_IER);\n\t\tif (!(rv_readl(rtd->acp3x_base + mmACP_I2STDM_ITER) & BIT(0)) &&\n\t\t     !(rv_readl(rtd->acp3x_base + mmACP_I2STDM_IRER) & BIT(0)))\n\t\t\trv_writel(0, rtd->acp3x_base + mmACP_I2STDM_IER);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops acp3x_i2s_dai_ops = {\n\t.hw_params = acp3x_i2s_hwparams,\n\t.trigger = acp3x_i2s_trigger,\n\t.set_fmt = acp3x_i2s_set_fmt,\n\t.set_tdm_slot = acp3x_i2s_set_tdm_slot,\n};\n\nstatic const struct snd_soc_component_driver acp3x_dai_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic struct snd_soc_dai_driver acp3x_i2s_dai = {\n\t.playback = {\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t},\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8 |\n\t\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &acp3x_i2s_dai_ops,\n};\n\nstatic int acp3x_dai_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct i2s_dev_data *adata;\n\tint ret;\n\n\tadata = devm_kzalloc(&pdev->dev, sizeof(struct i2s_dev_data),\n\t\t\tGFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tadata->acp3x_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!adata->acp3x_base)\n\t\treturn -ENOMEM;\n\n\tadata->i2s_irq = res->start;\n\tdev_set_drvdata(&pdev->dev, adata);\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&acp3x_dai_component, &acp3x_i2s_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Fail to register acp i2s dai\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver acp3x_dai_driver = {\n\t.probe = acp3x_dai_probe,\n\t.driver = {\n\t\t.name = \"acp3x_i2s_playcap\",\n\t},\n};\n\nmodule_platform_driver(acp3x_dai_driver);\n\nMODULE_AUTHOR(\"Vishnuvardhanrao.Ravulapati@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP 3.x PCM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\"DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}