{
  "module_name": "ps-pdm-dma.c",
  "hash_id": "484428da70d57391f1dd05c462f117e7776ac41cd3c7749fe7c425e4cbf4d4ed",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/ps/ps-pdm-dma.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/pm_runtime.h>\n\n#include \"acp63.h\"\n\n#define DRV_NAME \"acp_ps_pdm_dma\"\n\nstatic int pdm_gain = 3;\nmodule_param(pdm_gain, int, 0644);\nMODULE_PARM_DESC(pdm_gain, \"Gain control (0-3)\");\n\nstatic const struct snd_pcm_hardware acp63_pdm_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic void acp63_init_pdm_ring_buffer(u32 physical_addr, u32 buffer_size,\n\t\t\t\t       u32 watermark_size, void __iomem *acp_base)\n{\n\twritel(physical_addr, acp_base + ACP_WOV_RX_RINGBUFADDR);\n\twritel(buffer_size, acp_base + ACP_WOV_RX_RINGBUFSIZE);\n\twritel(watermark_size, acp_base + ACP_WOV_RX_INTR_WATERMARK_SIZE);\n\twritel(0x01, acp_base + ACPAXI2AXI_ATU_CTRL);\n}\n\nstatic void acp63_enable_pdm_clock(void __iomem *acp_base)\n{\n\tu32 pdm_clk_enable, pdm_ctrl;\n\n\tpdm_clk_enable = ACP_PDM_CLK_FREQ_MASK;\n\tpdm_ctrl = 0x00;\n\n\twritel(pdm_clk_enable, acp_base + ACP_WOV_CLK_CTRL);\n\tpdm_ctrl = readl(acp_base + ACP_WOV_MISC_CTRL);\n\tpdm_ctrl &= ~ACP_WOV_GAIN_CONTROL;\n\tpdm_ctrl |= FIELD_PREP(ACP_WOV_GAIN_CONTROL, clamp(pdm_gain, 0, 3));\n\twritel(pdm_ctrl, acp_base + ACP_WOV_MISC_CTRL);\n}\n\nstatic void acp63_enable_pdm_interrupts(struct pdm_dev_data *adata)\n{\n\tu32 ext_int_ctrl;\n\n\tmutex_lock(adata->acp_lock);\n\text_int_ctrl = readl(adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);\n\text_int_ctrl |= PDM_DMA_INTR_MASK;\n\twritel(ext_int_ctrl, adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);\n\tmutex_unlock(adata->acp_lock);\n}\n\nstatic void acp63_disable_pdm_interrupts(struct pdm_dev_data *adata)\n{\n\tu32 ext_int_ctrl;\n\n\tmutex_lock(adata->acp_lock);\n\text_int_ctrl = readl(adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);\n\text_int_ctrl &= ~PDM_DMA_INTR_MASK;\n\twritel(ext_int_ctrl, adata->acp63_base + ACP_EXTERNAL_INTR_CNTL);\n\tmutex_unlock(adata->acp_lock);\n}\n\nstatic bool acp63_check_pdm_dma_status(void __iomem *acp_base)\n{\n\tbool pdm_dma_status;\n\tu32 pdm_enable, pdm_dma_enable;\n\n\tpdm_dma_status = false;\n\tpdm_enable = readl(acp_base + ACP_WOV_PDM_ENABLE);\n\tpdm_dma_enable = readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\tif ((pdm_enable & ACP_PDM_ENABLE) && (pdm_dma_enable & ACP_PDM_DMA_EN_STATUS))\n\t\tpdm_dma_status = true;\n\n\treturn pdm_dma_status;\n}\n\nstatic int acp63_start_pdm_dma(void __iomem *acp_base)\n{\n\tu32 pdm_enable;\n\tu32 pdm_dma_enable;\n\tint timeout;\n\n\tpdm_enable = 0x01;\n\tpdm_dma_enable  = 0x01;\n\n\tacp63_enable_pdm_clock(acp_base);\n\twritel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);\n\twritel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\ttimeout = 0;\n\twhile (++timeout < ACP_COUNTER) {\n\t\tpdm_dma_enable = readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\tif ((pdm_dma_enable & 0x02) == ACP_PDM_DMA_EN_STATUS)\n\t\t\treturn 0;\n\t\tudelay(DELAY_US);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int acp63_stop_pdm_dma(void __iomem *acp_base)\n{\n\tu32 pdm_enable, pdm_dma_enable;\n\tint timeout;\n\n\tpdm_enable = 0x00;\n\tpdm_dma_enable  = 0x00;\n\n\tpdm_enable = readl(acp_base + ACP_WOV_PDM_ENABLE);\n\tpdm_dma_enable = readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\tif (pdm_dma_enable & 0x01) {\n\t\tpdm_dma_enable = 0x02;\n\t\twritel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\ttimeout = 0;\n\t\twhile (++timeout < ACP_COUNTER) {\n\t\t\tpdm_dma_enable = readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);\n\t\t\tif ((pdm_dma_enable & 0x02) == 0x00)\n\t\t\t\tbreak;\n\t\t\tudelay(DELAY_US);\n\t\t}\n\t\tif (timeout == ACP_COUNTER)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\tif (pdm_enable == ACP_PDM_ENABLE) {\n\t\tpdm_enable = ACP_PDM_DISABLE;\n\t\twritel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);\n\t}\n\twritel(0x01, acp_base + ACP_WOV_PDM_FIFO_FLUSH);\n\treturn 0;\n}\n\nstatic void acp63_config_dma(struct pdm_stream_instance *rtd, int direction)\n{\n\tu16 page_idx;\n\tu32 low, high, val;\n\tdma_addr_t addr;\n\n\taddr = rtd->dma_addr;\n\tval = PDM_PTE_OFFSET;\n\n\t \n\twritel(ACP_SRAM_PTE_OFFSET | BIT(31), rtd->acp63_base + ACPAXI2AXI_ATU_BASE_ADDR_GRP_1);\n\twritel(PAGE_SIZE_4K_ENABLE, rtd->acp63_base + ACPAXI2AXI_ATU_PAGE_SIZE_GRP_1);\n\tfor (page_idx = 0; page_idx < rtd->num_pages; page_idx++) {\n\t\t \n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\n\t\twritel(low, rtd->acp63_base + ACP_SCRATCH_REG_0 + val);\n\t\thigh |= BIT(31);\n\t\twritel(high, rtd->acp63_base + ACP_SCRATCH_REG_0 + val + 4);\n\t\tval += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n}\n\nstatic int acp63_pdm_dma_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct pdm_dev_data *adata;\n\tstruct pdm_stream_instance *pdm_data;\n\tint ret;\n\n\truntime = substream->runtime;\n\tadata = dev_get_drvdata(component->dev);\n\tpdm_data = kzalloc(sizeof(*pdm_data), GFP_KERNEL);\n\tif (!pdm_data)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\truntime->hw = acp63_pdm_hardware_capture;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(pdm_data);\n\t\treturn ret;\n\t}\n\n\tacp63_enable_pdm_interrupts(adata);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tadata->capture_stream = substream;\n\n\tpdm_data->acp63_base = adata->acp63_base;\n\truntime->private_data = pdm_data;\n\treturn ret;\n}\n\nstatic int acp63_pdm_dma_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct pdm_stream_instance *rtd;\n\tsize_t size, period_bytes;\n\n\trtd = substream->runtime->private_data;\n\tif (!rtd)\n\t\treturn -EINVAL;\n\tsize = params_buffer_bytes(params);\n\tperiod_bytes = params_period_bytes(params);\n\trtd->dma_addr = substream->runtime->dma_addr;\n\trtd->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);\n\tacp63_config_dma(rtd, substream->stream);\n\tacp63_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, size,\n\t\t\t\t   period_bytes, rtd->acp63_base);\n\treturn 0;\n}\n\nstatic u64 acp63_pdm_get_byte_count(struct pdm_stream_instance *rtd,\n\t\t\t\t    int direction)\n{\n\tu32 high, low;\n\tu64 byte_count;\n\n\thigh = readl(rtd->acp63_base + ACP_WOV_RX_LINEARPOSITIONCNTR_HIGH);\n\tbyte_count = high;\n\tlow = readl(rtd->acp63_base + ACP_WOV_RX_LINEARPOSITIONCNTR_LOW);\n\tbyte_count = (byte_count << 32) | low;\n\treturn byte_count;\n}\n\nstatic snd_pcm_uframes_t acp63_pdm_dma_pointer(struct snd_soc_component *comp,\n\t\t\t\t\t       struct snd_pcm_substream *stream)\n{\n\tstruct pdm_stream_instance *rtd;\n\tu32 pos, buffersize;\n\tu64 bytescount;\n\n\trtd = stream->runtime->private_data;\n\tbuffersize = frames_to_bytes(stream->runtime,\n\t\t\t\t     stream->runtime->buffer_size);\n\tbytescount = acp63_pdm_get_byte_count(rtd, stream->stream);\n\tif (bytescount > rtd->bytescount)\n\t\tbytescount -= rtd->bytescount;\n\tpos = do_div(bytescount, buffersize);\n\treturn bytes_to_frames(stream->runtime, pos);\n}\n\nstatic int acp63_pdm_dma_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *parent = component->dev->parent;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       parent, MIN_BUFFER, MAX_BUFFER);\n\treturn 0;\n}\n\nstatic int acp63_pdm_dma_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct pdm_dev_data *adata = dev_get_drvdata(component->dev);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tacp63_disable_pdm_interrupts(adata);\n\tadata->capture_stream = NULL;\n\tkfree(runtime->private_data);\n\treturn 0;\n}\n\nstatic int acp63_pdm_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t int cmd, struct snd_soc_dai *dai)\n{\n\tstruct pdm_stream_instance *rtd;\n\tint ret;\n\tbool pdm_status;\n\tunsigned int ch_mask;\n\n\trtd = substream->runtime->private_data;\n\tret = 0;\n\tswitch (substream->runtime->channels) {\n\tcase TWO_CH:\n\t\tch_mask = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\twritel(ch_mask, rtd->acp63_base + ACP_WOV_PDM_NO_OF_CHANNELS);\n\t\twritel(PDM_DECIMATION_FACTOR, rtd->acp63_base + ACP_WOV_PDM_DECIMATION_FACTOR);\n\t\trtd->bytescount = acp63_pdm_get_byte_count(rtd, substream->stream);\n\t\tpdm_status = acp63_check_pdm_dma_status(rtd->acp63_base);\n\t\tif (!pdm_status)\n\t\t\tret = acp63_start_pdm_dma(rtd->acp63_base);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tpdm_status = acp63_check_pdm_dma_status(rtd->acp63_base);\n\t\tif (pdm_status)\n\t\t\tret = acp63_stop_pdm_dma(rtd->acp63_base);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops acp63_pdm_dai_ops = {\n\t.trigger   = acp63_pdm_dai_trigger,\n};\n\nstatic struct snd_soc_dai_driver acp63_pdm_dai_driver = {\n\t.name = \"acp_ps_pdm_dma.0\",\n\t.capture = {\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rate_min = 48000,\n\t\t.rate_max = 48000,\n\t},\n\t.ops = &acp63_pdm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver acp63_pdm_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= acp63_pdm_dma_open,\n\t.close\t\t= acp63_pdm_dma_close,\n\t.hw_params\t= acp63_pdm_dma_hw_params,\n\t.pointer\t= acp63_pdm_dma_pointer,\n\t.pcm_construct\t= acp63_pdm_dma_new,\n};\n\nstatic int acp63_pdm_audio_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct pdm_dev_data *adata;\n\tstruct acp63_dev_data *acp_data;\n\tstruct device *parent;\n\tint status;\n\n\tparent = pdev->dev.parent;\n\tacp_data = dev_get_drvdata(parent);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tadata = devm_kzalloc(&pdev->dev, sizeof(*adata), GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tadata->acp63_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!adata->acp63_base)\n\t\treturn -ENOMEM;\n\n\tadata->capture_stream = NULL;\n\tadata->acp_lock = &acp_data->acp_lock;\n\tdev_set_drvdata(&pdev->dev, adata);\n\tstatus = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t\t &acp63_pdm_component,\n\t\t\t\t\t\t &acp63_pdm_dai_driver, 1);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Fail to register acp pdm dai\\n\");\n\n\t\treturn -ENODEV;\n\t}\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic void acp63_pdm_audio_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused acp63_pdm_resume(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct pdm_stream_instance *rtd;\n\tu32 period_bytes, buffer_len;\n\n\tadata = dev_get_drvdata(dev);\n\tif (adata->capture_stream && adata->capture_stream->runtime) {\n\t\truntime = adata->capture_stream->runtime;\n\t\trtd = runtime->private_data;\n\t\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\t\tbuffer_len = frames_to_bytes(runtime, runtime->buffer_size);\n\t\tacp63_config_dma(rtd, SNDRV_PCM_STREAM_CAPTURE);\n\t\tacp63_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, buffer_len,\n\t\t\t\t\t   period_bytes, adata->acp63_base);\n\t}\n\tacp63_enable_pdm_interrupts(adata);\n\treturn 0;\n}\n\nstatic int __maybe_unused acp63_pdm_suspend(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tacp63_disable_pdm_interrupts(adata);\n\treturn 0;\n}\n\nstatic int __maybe_unused acp63_pdm_runtime_resume(struct device *dev)\n{\n\tstruct pdm_dev_data *adata;\n\n\tadata = dev_get_drvdata(dev);\n\tacp63_enable_pdm_interrupts(adata);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acp63_pdm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(acp63_pdm_suspend, acp63_pdm_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(acp63_pdm_suspend, acp63_pdm_resume)\n};\n\nstatic struct platform_driver acp63_pdm_dma_driver = {\n\t.probe = acp63_pdm_audio_probe,\n\t.remove_new = acp63_pdm_audio_remove,\n\t.driver = {\n\t\t.name = \"acp_ps_pdm_dma\",\n\t\t.pm = &acp63_pdm_pm_ops,\n\t},\n};\n\nmodule_platform_driver(acp63_pdm_dma_driver);\n\nMODULE_AUTHOR(\"Syed.SabaKareem@amd.com\");\nMODULE_DESCRIPTION(\"AMD PINK SARDINE PDM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}