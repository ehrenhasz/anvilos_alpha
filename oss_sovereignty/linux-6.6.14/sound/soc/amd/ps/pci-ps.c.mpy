{
  "module_name": "pci-ps.c",
  "hash_id": "84fbfddd7b925f53fbfb2ab9c81ad7ad6fb568c26ab80bb2b9425208face4a39",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/ps/pci-ps.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n#include <linux/iopoll.h>\n#include <linux/soundwire/sdw_amd.h>\n\n#include \"acp63.h\"\n\nstatic int acp63_power_on(void __iomem *acp_base)\n{\n\tu32 val;\n\n\tval = readl(acp_base + ACP_PGFSM_STATUS);\n\n\tif (!val)\n\t\treturn val;\n\n\tif ((val & ACP_PGFSM_STATUS_MASK) != ACP_POWER_ON_IN_PROGRESS)\n\t\twritel(ACP_PGFSM_CNTL_POWER_ON_MASK, acp_base + ACP_PGFSM_CONTROL);\n\n\treturn readl_poll_timeout(acp_base + ACP_PGFSM_STATUS, val, !val, DELAY_US, ACP_TIMEOUT);\n}\n\nstatic int acp63_reset(void __iomem *acp_base)\n{\n\tu32 val;\n\tint ret;\n\n\twritel(1, acp_base + ACP_SOFT_RESET);\n\n\tret = readl_poll_timeout(acp_base + ACP_SOFT_RESET, val,\n\t\t\t\t val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK,\n\t\t\t\t DELAY_US, ACP_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(0, acp_base + ACP_SOFT_RESET);\n\n\treturn readl_poll_timeout(acp_base + ACP_SOFT_RESET, val, !val, DELAY_US, ACP_TIMEOUT);\n}\n\nstatic void acp63_enable_interrupts(void __iomem *acp_base)\n{\n\twritel(1, acp_base + ACP_EXTERNAL_INTR_ENB);\n\twritel(ACP_ERROR_IRQ, acp_base + ACP_EXTERNAL_INTR_CNTL);\n}\n\nstatic void acp63_disable_interrupts(void __iomem *acp_base)\n{\n\twritel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp_base + ACP_EXTERNAL_INTR_STAT);\n\twritel(0, acp_base + ACP_EXTERNAL_INTR_CNTL);\n\twritel(0, acp_base + ACP_EXTERNAL_INTR_ENB);\n}\n\nstatic int acp63_init(void __iomem *acp_base, struct device *dev)\n{\n\tint ret;\n\n\tret = acp63_power_on(acp_base);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\twritel(0x01, acp_base + ACP_CONTROL);\n\tret = acp63_reset(acp_base);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\tacp63_enable_interrupts(acp_base);\n\treturn 0;\n}\n\nstatic int acp63_deinit(void __iomem *acp_base, struct device *dev)\n{\n\tint ret;\n\n\tacp63_disable_interrupts(acp_base);\n\tret = acp63_reset(acp_base);\n\tif (ret) {\n\t\tdev_err(dev, \"ACP reset failed\\n\");\n\t\treturn ret;\n\t}\n\twritel(0, acp_base + ACP_CONTROL);\n\treturn 0;\n}\n\nstatic irqreturn_t acp63_irq_thread(int irq, void *context)\n{\n\tstruct sdw_dma_dev_data *sdw_dma_data;\n\tstruct acp63_dev_data *adata = context;\n\tu32 stream_index;\n\tu16 pdev_index;\n\n\tpdev_index = adata->sdw_dma_dev_index;\n\tsdw_dma_data = dev_get_drvdata(&adata->pdev[pdev_index]->dev);\n\n\tfor (stream_index = 0; stream_index < ACP63_SDW0_DMA_MAX_STREAMS; stream_index++) {\n\t\tif (adata->sdw0_dma_intr_stat[stream_index]) {\n\t\t\tif (sdw_dma_data->sdw0_dma_stream[stream_index])\n\t\t\t\tsnd_pcm_period_elapsed(sdw_dma_data->sdw0_dma_stream[stream_index]);\n\t\t\tadata->sdw0_dma_intr_stat[stream_index] = 0;\n\t\t}\n\t}\n\tfor (stream_index = 0; stream_index < ACP63_SDW1_DMA_MAX_STREAMS; stream_index++) {\n\t\tif (adata->sdw1_dma_intr_stat[stream_index]) {\n\t\t\tif (sdw_dma_data->sdw1_dma_stream[stream_index])\n\t\t\t\tsnd_pcm_period_elapsed(sdw_dma_data->sdw1_dma_stream[stream_index]);\n\t\t\tadata->sdw1_dma_intr_stat[stream_index] = 0;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t acp63_irq_handler(int irq, void *dev_id)\n{\n\tstruct acp63_dev_data *adata;\n\tstruct pdm_dev_data *ps_pdm_data;\n\tstruct amd_sdw_manager *amd_manager;\n\tu32 ext_intr_stat, ext_intr_stat1;\n\tu32 stream_id = 0;\n\tu16 irq_flag = 0;\n\tu16 sdw_dma_irq_flag = 0;\n\tu16 pdev_index;\n\tu16 index;\n\n\tadata = dev_id;\n\tif (!adata)\n\t\treturn IRQ_NONE;\n\t \n\text_intr_stat = readl(adata->acp63_base + ACP_EXTERNAL_INTR_STAT);\n\tif (ext_intr_stat & ACP_SDW0_STAT) {\n\t\twritel(ACP_SDW0_STAT, adata->acp63_base + ACP_EXTERNAL_INTR_STAT);\n\t\tpdev_index = adata->sdw0_dev_index;\n\t\tamd_manager = dev_get_drvdata(&adata->pdev[pdev_index]->dev);\n\t\tif (amd_manager)\n\t\t\tschedule_work(&amd_manager->amd_sdw_irq_thread);\n\t\tirq_flag = 1;\n\t}\n\n\text_intr_stat1 = readl(adata->acp63_base + ACP_EXTERNAL_INTR_STAT1);\n\tif (ext_intr_stat1 & ACP_SDW1_STAT) {\n\t\twritel(ACP_SDW1_STAT, adata->acp63_base + ACP_EXTERNAL_INTR_STAT1);\n\t\tpdev_index = adata->sdw1_dev_index;\n\t\tamd_manager = dev_get_drvdata(&adata->pdev[pdev_index]->dev);\n\t\tif (amd_manager)\n\t\t\tschedule_work(&amd_manager->amd_sdw_irq_thread);\n\t\tirq_flag = 1;\n\t}\n\n\tif (ext_intr_stat & ACP_ERROR_IRQ) {\n\t\twritel(ACP_ERROR_IRQ, adata->acp63_base + ACP_EXTERNAL_INTR_STAT);\n\t\t \n\t\twritel(0, adata->acp63_base + ACP_SW0_I2S_ERROR_REASON);\n\t\twritel(0, adata->acp63_base + ACP_SW1_I2S_ERROR_REASON);\n\t\twritel(0, adata->acp63_base + ACP_ERROR_STATUS);\n\t\tirq_flag = 1;\n\t}\n\n\tif (ext_intr_stat & BIT(PDM_DMA_STAT)) {\n\t\tpdev_index = adata->pdm_dev_index;\n\t\tps_pdm_data = dev_get_drvdata(&adata->pdev[pdev_index]->dev);\n\t\twritel(BIT(PDM_DMA_STAT), adata->acp63_base + ACP_EXTERNAL_INTR_STAT);\n\t\tif (ps_pdm_data->capture_stream)\n\t\t\tsnd_pcm_period_elapsed(ps_pdm_data->capture_stream);\n\t\tirq_flag = 1;\n\t}\n\tif (ext_intr_stat & ACP_SDW_DMA_IRQ_MASK) {\n\t\tfor (index = ACP_AUDIO2_RX_THRESHOLD; index <= ACP_AUDIO0_TX_THRESHOLD; index++) {\n\t\t\tif (ext_intr_stat & BIT(index)) {\n\t\t\t\twritel(BIT(index), adata->acp63_base + ACP_EXTERNAL_INTR_STAT);\n\t\t\t\tswitch (index) {\n\t\t\t\tcase ACP_AUDIO0_TX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO0_TX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACP_AUDIO1_TX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO1_TX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACP_AUDIO2_TX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO2_TX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACP_AUDIO0_RX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO0_RX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACP_AUDIO1_RX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO1_RX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ACP_AUDIO2_RX_THRESHOLD:\n\t\t\t\t\tstream_id = ACP_SDW0_AUDIO2_RX;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tadata->sdw0_dma_intr_stat[stream_id] = 1;\n\t\t\t\tsdw_dma_irq_flag = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ext_intr_stat1 & ACP_P1_AUDIO1_RX_THRESHOLD) {\n\t\twritel(ACP_P1_AUDIO1_RX_THRESHOLD,\n\t\t       adata->acp63_base + ACP_EXTERNAL_INTR_STAT1);\n\t\tadata->sdw1_dma_intr_stat[ACP_SDW1_AUDIO1_RX] = 1;\n\t\tsdw_dma_irq_flag = 1;\n\t}\n\n\tif (ext_intr_stat1 & ACP_P1_AUDIO1_TX_THRESHOLD) {\n\t\twritel(ACP_P1_AUDIO1_TX_THRESHOLD,\n\t\t       adata->acp63_base + ACP_EXTERNAL_INTR_STAT1);\n\t\tadata->sdw1_dma_intr_stat[ACP_SDW1_AUDIO1_TX] = 1;\n\t\tsdw_dma_irq_flag = 1;\n\t}\n\n\tif (sdw_dma_irq_flag)\n\t\treturn IRQ_WAKE_THREAD;\n\n\tif (irq_flag)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic int sdw_amd_scan_controller(struct device *dev)\n{\n\tstruct acp63_dev_data *acp_data;\n\tstruct fwnode_handle *link;\n\tchar name[32];\n\tu32 sdw_manager_bitmap;\n\tu8 count = 0;\n\tu32 acp_sdw_power_mode = 0;\n\tint index;\n\tint ret;\n\n\tacp_data = dev_get_drvdata(dev);\n\t \n\tret = fwnode_property_read_u32_array((acp_data->sdw_fw_node), \"mipi-sdw-manager-list\",\n\t\t\t\t\t     &sdw_manager_bitmap, 1);\n\n\tif (ret) {\n\t\tdev_dbg(dev, \"Failed to read mipi-sdw-manager-list: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\tcount = hweight32(sdw_manager_bitmap);\n\t \n\tif (count > AMD_SDW_MAX_MANAGERS) {\n\t\tdev_err(dev, \"Manager count %d exceeds max %d\\n\", count, AMD_SDW_MAX_MANAGERS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!count) {\n\t\tdev_dbg(dev, \"No SoundWire Managers detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(dev, \"ACPI reports %d SoundWire Manager devices\\n\", count);\n\tacp_data->sdw_manager_count = count;\n\tfor (index = 0; index < count; index++) {\n\t\tsnprintf(name, sizeof(name), \"mipi-sdw-link-%d-subproperties\", index);\n\t\tlink = fwnode_get_named_child_node(acp_data->sdw_fw_node, name);\n\t\tif (!link) {\n\t\t\tdev_err(dev, \"Manager node %s not found\\n\", name);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(link, \"amd-sdw-power-mode\", &acp_sdw_power_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tif (acp_sdw_power_mode != AMD_SDW_POWER_OFF_MODE) {\n\t\t\tacp_data->acp_reset = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int get_acp63_device_config(u32 config, struct pci_dev *pci, struct acp63_dev_data *acp_data)\n{\n\tstruct acpi_device *dmic_dev;\n\tstruct acpi_device *sdw_dev;\n\tconst union acpi_object *obj;\n\tbool is_dmic_dev = false;\n\tbool is_sdw_dev = false;\n\tint ret;\n\n\tdmic_dev = acpi_find_child_device(ACPI_COMPANION(&pci->dev), ACP63_DMIC_ADDR, 0);\n\tif (dmic_dev) {\n\t\t \n\t\tif (!acpi_dev_get_property(dmic_dev, \"acp-audio-device-type\",\n\t\t\t\t\t   ACPI_TYPE_INTEGER, &obj) &&\n\t\t\t\t\t   obj->integer.value == ACP_DMIC_DEV)\n\t\t\tis_dmic_dev = true;\n\t}\n\n\tsdw_dev = acpi_find_child_device(ACPI_COMPANION(&pci->dev), ACP63_SDW_ADDR, 0);\n\tif (sdw_dev) {\n\t\tacp_data->sdw_fw_node = acpi_fwnode_handle(sdw_dev);\n\t\tret = sdw_amd_scan_controller(&pci->dev);\n\t\t \n\t\tif (!ret)\n\t\t\tis_sdw_dev = true;\n\t}\n\tif (!is_dmic_dev && !is_sdw_dev)\n\t\treturn -ENODEV;\n\tdev_dbg(&pci->dev, \"Audio Mode %d\\n\", config);\n\tswitch (config) {\n\tcase ACP_CONFIG_4:\n\tcase ACP_CONFIG_5:\n\tcase ACP_CONFIG_10:\n\tcase ACP_CONFIG_11:\n\t\tif (is_dmic_dev) {\n\t\t\tacp_data->pdev_config = ACP63_PDM_DEV_CONFIG;\n\t\t\tacp_data->pdev_count = ACP63_PDM_MODE_DEVS;\n\t\t}\n\t\tbreak;\n\tcase ACP_CONFIG_2:\n\tcase ACP_CONFIG_3:\n\t\tif (is_sdw_dev) {\n\t\t\tswitch (acp_data->sdw_manager_count) {\n\t\t\tcase 1:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_SDW1_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACP_CONFIG_6:\n\tcase ACP_CONFIG_7:\n\tcase ACP_CONFIG_12:\n\tcase ACP_CONFIG_8:\n\tcase ACP_CONFIG_13:\n\tcase ACP_CONFIG_14:\n\t\tif (is_dmic_dev && is_sdw_dev) {\n\t\t\tswitch (acp_data->sdw_manager_count) {\n\t\t\tcase 1:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_PDM_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_PDM_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_PDM_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_SDW1_PDM_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (is_dmic_dev) {\n\t\t\tacp_data->pdev_config = ACP63_PDM_DEV_CONFIG;\n\t\t\tacp_data->pdev_count = ACP63_PDM_MODE_DEVS;\n\t\t} else if (is_sdw_dev) {\n\t\t\tswitch (acp_data->sdw_manager_count) {\n\t\t\tcase 1:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tacp_data->pdev_config = ACP63_SDW_DEV_CONFIG;\n\t\t\t\tacp_data->pdev_count = ACP63_SDW0_SDW1_MODE_DEVS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void acp63_fill_platform_dev_info(struct platform_device_info *pdevinfo,\n\t\t\t\t\t struct device *parent,\n\t\t\t\t\t struct fwnode_handle *fw_node,\n\t\t\t\t\t char *name, unsigned int id,\n\t\t\t\t\t const struct resource *res,\n\t\t\t\t\t unsigned int num_res,\n\t\t\t\t\t const void *data,\n\t\t\t\t\t size_t size_data)\n{\n\tpdevinfo->name = name;\n\tpdevinfo->id = id;\n\tpdevinfo->parent = parent;\n\tpdevinfo->num_res = num_res;\n\tpdevinfo->res = res;\n\tpdevinfo->data = data;\n\tpdevinfo->size_data = size_data;\n\tpdevinfo->fwnode = fw_node;\n}\n\nstatic int create_acp63_platform_devs(struct pci_dev *pci, struct acp63_dev_data *adata, u32 addr)\n{\n\tstruct acp_sdw_pdata *sdw_pdata;\n\tstruct platform_device_info pdevinfo[ACP63_DEVS];\n\tstruct device *parent;\n\tint index;\n\tint ret;\n\n\tparent = &pci->dev;\n\tdev_dbg(&pci->dev,\n\t\t\"%s pdev_config:0x%x pdev_count:0x%x\\n\", __func__, adata->pdev_config,\n\t\tadata->pdev_count);\n\tif (adata->pdev_config) {\n\t\tadata->res = devm_kzalloc(&pci->dev, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!adata->res) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto de_init;\n\t\t}\n\t\tadata->res->flags = IORESOURCE_MEM;\n\t\tadata->res->start = addr;\n\t\tadata->res->end = addr + (ACP63_REG_END - ACP63_REG_START);\n\t\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t}\n\n\tswitch (adata->pdev_config) {\n\tcase ACP63_PDM_DEV_CONFIG:\n\t\tadata->pdm_dev_index  = 0;\n\t\tacp63_fill_platform_dev_info(&pdevinfo[0], parent, NULL, \"acp_ps_pdm_dma\",\n\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\tacp63_fill_platform_dev_info(&pdevinfo[1], parent, NULL, \"dmic-codec\",\n\t\t\t\t\t     0, NULL, 0, NULL, 0);\n\t\tacp63_fill_platform_dev_info(&pdevinfo[2], parent, NULL, \"acp_ps_mach\",\n\t\t\t\t\t     0, NULL, 0, NULL, 0);\n\t\tbreak;\n\tcase ACP63_SDW_DEV_CONFIG:\n\t\tif (adata->pdev_count == ACP63_SDW0_MODE_DEVS) {\n\t\t\tsdw_pdata = devm_kzalloc(&pci->dev, sizeof(struct acp_sdw_pdata),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!sdw_pdata) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto de_init;\n\t\t\t}\n\n\t\t\tsdw_pdata->instance = 0;\n\t\t\tsdw_pdata->acp_sdw_lock = &adata->acp_lock;\n\t\t\tadata->sdw0_dev_index = 0;\n\t\t\tadata->sdw_dma_dev_index = 1;\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[0], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 0, adata->res, 1,\n\t\t\t\t\t\t     sdw_pdata, sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[1], parent, NULL, \"amd_ps_sdw_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t} else if (adata->pdev_count == ACP63_SDW0_SDW1_MODE_DEVS) {\n\t\t\tsdw_pdata = devm_kzalloc(&pci->dev, sizeof(struct acp_sdw_pdata) * 2,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!sdw_pdata) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto de_init;\n\t\t\t}\n\n\t\t\tsdw_pdata[0].instance = 0;\n\t\t\tsdw_pdata[1].instance = 1;\n\t\t\tsdw_pdata[0].acp_sdw_lock = &adata->acp_lock;\n\t\t\tsdw_pdata[1].acp_sdw_lock = &adata->acp_lock;\n\t\t\tsdw_pdata->acp_sdw_lock = &adata->acp_lock;\n\t\t\tadata->sdw0_dev_index = 0;\n\t\t\tadata->sdw1_dev_index = 1;\n\t\t\tadata->sdw_dma_dev_index = 2;\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[0], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 0, adata->res, 1,\n\t\t\t\t\t\t     &sdw_pdata[0], sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[1], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 1, adata->res, 1,\n\t\t\t\t\t\t     &sdw_pdata[1], sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[2], parent, NULL, \"amd_ps_sdw_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase ACP63_SDW_PDM_DEV_CONFIG:\n\t\tif (adata->pdev_count == ACP63_SDW0_PDM_MODE_DEVS) {\n\t\t\tsdw_pdata = devm_kzalloc(&pci->dev, sizeof(struct acp_sdw_pdata),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!sdw_pdata) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto de_init;\n\t\t\t}\n\n\t\t\tsdw_pdata->instance = 0;\n\t\t\tsdw_pdata->acp_sdw_lock = &adata->acp_lock;\n\t\t\tadata->pdm_dev_index = 0;\n\t\t\tadata->sdw0_dev_index = 1;\n\t\t\tadata->sdw_dma_dev_index = 2;\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[0], parent, NULL, \"acp_ps_pdm_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[1], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 0, adata->res, 1,\n\t\t\t\t\t\t     sdw_pdata, sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[2], parent, NULL, \"amd_ps_sdw_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[3], parent, NULL, \"dmic-codec\",\n\t\t\t\t\t\t     0, NULL, 0, NULL, 0);\n\t\t} else if (adata->pdev_count == ACP63_SDW0_SDW1_PDM_MODE_DEVS) {\n\t\t\tsdw_pdata = devm_kzalloc(&pci->dev, sizeof(struct acp_sdw_pdata) * 2,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!sdw_pdata) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto de_init;\n\t\t\t}\n\t\t\tsdw_pdata[0].instance = 0;\n\t\t\tsdw_pdata[1].instance = 1;\n\t\t\tsdw_pdata[0].acp_sdw_lock = &adata->acp_lock;\n\t\t\tsdw_pdata[1].acp_sdw_lock = &adata->acp_lock;\n\t\t\tadata->pdm_dev_index = 0;\n\t\t\tadata->sdw0_dev_index = 1;\n\t\t\tadata->sdw1_dev_index = 2;\n\t\t\tadata->sdw_dma_dev_index = 3;\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[0], parent, NULL, \"acp_ps_pdm_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[1], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 0, adata->res, 1,\n\t\t\t\t\t\t     &sdw_pdata[0], sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[2], parent, adata->sdw_fw_node,\n\t\t\t\t\t\t     \"amd_sdw_manager\", 1, adata->res, 1,\n\t\t\t\t\t\t     &sdw_pdata[1], sizeof(struct acp_sdw_pdata));\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[3], parent, NULL, \"amd_ps_sdw_dma\",\n\t\t\t\t\t\t     0, adata->res, 1, NULL, 0);\n\t\t\tacp63_fill_platform_dev_info(&pdevinfo[4], parent, NULL, \"dmic-codec\",\n\t\t\t\t\t\t     0, NULL, 0, NULL, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&pci->dev, \"No PDM or SoundWire manager devices found\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (index = 0; index < adata->pdev_count; index++) {\n\t\tadata->pdev[index] = platform_device_register_full(&pdevinfo[index]);\n\t\tif (IS_ERR(adata->pdev[index])) {\n\t\t\tdev_err(&pci->dev,\n\t\t\t\t\"cannot register %s device\\n\", pdevinfo[index].name);\n\t\t\tret = PTR_ERR(adata->pdev[index]);\n\t\t\tgoto unregister_devs;\n\t\t}\n\t}\n\treturn 0;\nunregister_devs:\n\tfor (--index; index >= 0; index--)\n\t\tplatform_device_unregister(adata->pdev[index]);\nde_init:\n\tif (acp63_deinit(adata->acp63_base, &pci->dev))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\treturn ret;\n}\n\nstatic int snd_acp63_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct acp63_dev_data *adata;\n\tu32 addr;\n\tu32 irqflags, flag;\n\tint val;\n\tint ret;\n\n\tirqflags = IRQF_SHARED;\n\n\t \n\tflag = snd_amd_acp_find_config(pci);\n\tif (flag)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (pci->revision) {\n\tcase 0x63:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&pci->dev, \"acp63 pci device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (pci_enable_device(pci)) {\n\t\tdev_err(&pci->dev, \"pci_enable_device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pci_request_regions(pci, \"AMD ACP6.2 audio\");\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"pci_request_regions failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\tadata = devm_kzalloc(&pci->dev, sizeof(struct acp63_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\n\taddr = pci_resource_start(pci, 0);\n\tadata->acp63_base = devm_ioremap(&pci->dev, addr,\n\t\t\t\t\t pci_resource_len(pci, 0));\n\tif (!adata->acp63_base) {\n\t\tret = -ENOMEM;\n\t\tgoto release_regions;\n\t}\n\t \n\tadata->acp_reset = true;\n\tpci_set_master(pci);\n\tpci_set_drvdata(pci, adata);\n\tmutex_init(&adata->acp_lock);\n\tret = acp63_init(adata->acp63_base, &pci->dev);\n\tif (ret)\n\t\tgoto release_regions;\n\tret = devm_request_threaded_irq(&pci->dev, pci->irq, acp63_irq_handler,\n\t\t\t\t\tacp63_irq_thread, irqflags, \"ACP_PCI_IRQ\", adata);\n\tif (ret) {\n\t\tdev_err(&pci->dev, \"ACP PCI IRQ request failed\\n\");\n\t\tgoto de_init;\n\t}\n\tval = readl(adata->acp63_base + ACP_PIN_CONFIG);\n\tret = get_acp63_device_config(val, pci, adata);\n\t \n\tif (ret) {\n\t\tdev_dbg(&pci->dev, \"get acp device config failed:%d\\n\", ret);\n\t\tgoto skip_pdev_creation;\n\t}\n\tret = create_acp63_platform_devs(pci, adata, addr);\n\tif (ret < 0) {\n\t\tdev_err(&pci->dev, \"ACP platform devices creation failed\\n\");\n\t\tgoto de_init;\n\t}\nskip_pdev_creation:\n\tpm_runtime_set_autosuspend_delay(&pci->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pci->dev);\n\tpm_runtime_put_noidle(&pci->dev);\n\tpm_runtime_allow(&pci->dev);\n\treturn 0;\nde_init:\n\tif (acp63_deinit(adata->acp63_base, &pci->dev))\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\nrelease_regions:\n\tpci_release_regions(pci);\ndisable_pci:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp63_suspend(struct device *dev)\n{\n\tstruct acp63_dev_data *adata;\n\tint ret = 0;\n\n\tadata = dev_get_drvdata(dev);\n\tif (adata->acp_reset) {\n\t\tret = acp63_deinit(adata->acp63_base, dev);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"ACP de-init failed\\n\");\n\t}\n\treturn ret;\n}\n\nstatic int __maybe_unused snd_acp63_resume(struct device *dev)\n{\n\tstruct acp63_dev_data *adata;\n\tint ret = 0;\n\n\tadata = dev_get_drvdata(dev);\n\tif (adata->acp_reset) {\n\t\tret = acp63_init(adata->acp63_base, dev);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"ACP init failed\\n\");\n\t}\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops acp63_pm_ops = {\n\tSET_RUNTIME_PM_OPS(snd_acp63_suspend, snd_acp63_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_acp63_suspend, snd_acp63_resume)\n};\n\nstatic void snd_acp63_remove(struct pci_dev *pci)\n{\n\tstruct acp63_dev_data *adata;\n\tint ret, index;\n\n\tadata = pci_get_drvdata(pci);\n\tfor (index = 0; index < adata->pdev_count; index++)\n\t\tplatform_device_unregister(adata->pdev[index]);\n\tret = acp63_deinit(adata->acp63_base, &pci->dev);\n\tif (ret)\n\t\tdev_err(&pci->dev, \"ACP de-init failed\\n\");\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\tpci_release_regions(pci);\n\tpci_disable_device(pci);\n}\n\nstatic const struct pci_device_id snd_acp63_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),\n\t.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,\n\t.class_mask = 0xffffff },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_acp63_ids);\n\nstatic struct pci_driver ps_acp63_driver  = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_acp63_ids,\n\t.probe = snd_acp63_probe,\n\t.remove = snd_acp63_remove,\n\t.driver = {\n\t\t.pm = &acp63_pm_ops,\n\t}\n};\n\nmodule_pci_driver(ps_acp63_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_AUTHOR(\"Syed.SabaKareem@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP Pink Sardine PCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}