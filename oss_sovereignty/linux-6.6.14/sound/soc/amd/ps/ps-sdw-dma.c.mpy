{
  "module_name": "ps-sdw-dma.c",
  "hash_id": "f48a2723000af38079dc5a6cc9ef6ea2b4c7e81fa72373ac30e0b19124ecc36a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/amd/ps/ps-sdw-dma.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_amd.h>\n#include \"acp63.h\"\n\n#define DRV_NAME \"amd_ps_sdw_dma\"\n\nstatic struct sdw_dma_ring_buf_reg sdw0_dma_ring_buf_reg[ACP63_SDW0_DMA_MAX_STREAMS] = {\n\t{ACP_AUDIO0_TX_DMA_SIZE, ACP_AUDIO0_TX_FIFOADDR, ACP_AUDIO0_TX_FIFOSIZE,\n\t ACP_AUDIO0_TX_RINGBUFSIZE, ACP_AUDIO0_TX_RINGBUFADDR, ACP_AUDIO0_TX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO0_TX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO0_TX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_AUDIO1_TX_DMA_SIZE, ACP_AUDIO1_TX_FIFOADDR, ACP_AUDIO1_TX_FIFOSIZE,\n\t ACP_AUDIO1_TX_RINGBUFSIZE, ACP_AUDIO1_TX_RINGBUFADDR, ACP_AUDIO1_TX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO1_TX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO1_TX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_AUDIO2_TX_DMA_SIZE, ACP_AUDIO2_TX_FIFOADDR, ACP_AUDIO2_TX_FIFOSIZE,\n\t ACP_AUDIO2_TX_RINGBUFSIZE, ACP_AUDIO2_TX_RINGBUFADDR, ACP_AUDIO2_TX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO2_TX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO2_TX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_AUDIO0_RX_DMA_SIZE, ACP_AUDIO0_RX_FIFOADDR, ACP_AUDIO0_RX_FIFOSIZE,\n\t ACP_AUDIO0_RX_RINGBUFSIZE, ACP_AUDIO0_RX_RINGBUFADDR, ACP_AUDIO0_RX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO0_RX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO0_RX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_AUDIO1_RX_DMA_SIZE, ACP_AUDIO1_RX_FIFOADDR, ACP_AUDIO1_RX_FIFOSIZE,\n\t ACP_AUDIO1_RX_RINGBUFSIZE, ACP_AUDIO1_RX_RINGBUFADDR, ACP_AUDIO1_RX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO1_RX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO1_RX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_AUDIO2_RX_DMA_SIZE, ACP_AUDIO2_RX_FIFOADDR, ACP_AUDIO2_RX_FIFOSIZE,\n\t ACP_AUDIO2_RX_RINGBUFSIZE, ACP_AUDIO2_RX_RINGBUFADDR, ACP_AUDIO2_RX_INTR_WATERMARK_SIZE,\n\t ACP_AUDIO2_RX_LINEARPOSITIONCNTR_LOW, ACP_AUDIO2_RX_LINEARPOSITIONCNTR_HIGH}\n};\n\n \nstatic struct sdw_dma_ring_buf_reg sdw1_dma_ring_buf_reg[ACP63_SDW1_DMA_MAX_STREAMS] =  {\n\t{ACP_P1_AUDIO1_TX_DMA_SIZE, ACP_P1_AUDIO1_TX_FIFOADDR, ACP_P1_AUDIO1_TX_FIFOSIZE,\n\t ACP_P1_AUDIO1_TX_RINGBUFSIZE, ACP_P1_AUDIO1_TX_RINGBUFADDR,\n\t ACP_P1_AUDIO1_TX_INTR_WATERMARK_SIZE,\n\t ACP_P1_AUDIO1_TX_LINEARPOSITIONCNTR_LOW, ACP_P1_AUDIO1_TX_LINEARPOSITIONCNTR_HIGH},\n\t{ACP_P1_AUDIO1_RX_DMA_SIZE, ACP_P1_AUDIO1_RX_FIFOADDR, ACP_P1_AUDIO1_RX_FIFOSIZE,\n\t ACP_P1_AUDIO1_RX_RINGBUFSIZE, ACP_P1_AUDIO1_RX_RINGBUFADDR,\n\t ACP_P1_AUDIO1_RX_INTR_WATERMARK_SIZE,\n\t ACP_P1_AUDIO1_RX_LINEARPOSITIONCNTR_LOW, ACP_P1_AUDIO1_RX_LINEARPOSITIONCNTR_HIGH},\n};\n\nstatic u32 sdw0_dma_enable_reg[ACP63_SDW0_DMA_MAX_STREAMS] = {\n\tACP_SW0_AUDIO0_TX_EN,\n\tACP_SW0_AUDIO1_TX_EN,\n\tACP_SW0_AUDIO2_TX_EN,\n\tACP_SW0_AUDIO0_RX_EN,\n\tACP_SW0_AUDIO1_RX_EN,\n\tACP_SW0_AUDIO2_RX_EN,\n};\n\n \nstatic u32 sdw1_dma_enable_reg[ACP63_SDW1_DMA_MAX_STREAMS] = {\n\tACP_SW1_AUDIO1_TX_EN,\n\tACP_SW1_AUDIO1_RX_EN,\n};\n\nstatic const struct snd_pcm_hardware acp63_sdw_hardware_playback = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |  SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = SDW_PLAYBACK_MAX_NUM_PERIODS * SDW_PLAYBACK_MAX_PERIOD_SIZE,\n\t.period_bytes_min = SDW_PLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max = SDW_PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min = SDW_PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max = SDW_PLAYBACK_MAX_NUM_PERIODS,\n};\n\nstatic const struct snd_pcm_hardware acp63_sdw_hardware_capture = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |  SNDRV_PCM_FMTBIT_S8 |\n\t\t   SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.buffer_bytes_max = SDW_CAPTURE_MAX_NUM_PERIODS * SDW_CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min = SDW_CAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max = SDW_CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min = SDW_CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max = SDW_CAPTURE_MAX_NUM_PERIODS,\n};\n\nstatic void acp63_enable_disable_sdw_dma_interrupts(void __iomem *acp_base, bool enable)\n{\n\tu32 ext_intr_cntl, ext_intr_cntl1;\n\tu32 irq_mask = ACP_SDW_DMA_IRQ_MASK;\n\tu32 irq_mask1 = ACP_P1_SDW_DMA_IRQ_MASK;\n\n\tif (enable) {\n\t\text_intr_cntl = readl(acp_base + ACP_EXTERNAL_INTR_CNTL);\n\t\text_intr_cntl |= irq_mask;\n\t\twritel(ext_intr_cntl, acp_base + ACP_EXTERNAL_INTR_CNTL);\n\t\text_intr_cntl1 = readl(acp_base + ACP_EXTERNAL_INTR_CNTL1);\n\t\text_intr_cntl1 |= irq_mask1;\n\t\twritel(ext_intr_cntl1, acp_base + ACP_EXTERNAL_INTR_CNTL1);\n\t} else {\n\t\text_intr_cntl = readl(acp_base + ACP_EXTERNAL_INTR_CNTL);\n\t\text_intr_cntl &= ~irq_mask;\n\t\twritel(ext_intr_cntl, acp_base + ACP_EXTERNAL_INTR_CNTL);\n\t\text_intr_cntl1 = readl(acp_base + ACP_EXTERNAL_INTR_CNTL1);\n\t\text_intr_cntl1 &= ~irq_mask1;\n\t\twritel(ext_intr_cntl1, acp_base + ACP_EXTERNAL_INTR_CNTL1);\n\t}\n}\n\nstatic void acp63_config_dma(struct acp_sdw_dma_stream *stream, void __iomem *acp_base,\n\t\t\t     u32 stream_id)\n{\n\tu16 page_idx;\n\tu32 low, high, val;\n\tu32 sdw_dma_pte_offset;\n\tdma_addr_t addr;\n\n\taddr = stream->dma_addr;\n\tsdw_dma_pte_offset = SDW_PTE_OFFSET(stream->instance);\n\tval = sdw_dma_pte_offset + (stream_id * ACP_SDW_PTE_OFFSET);\n\n\t \n\twritel(ACP_SDW_SRAM_PTE_OFFSET | BIT(31), acp_base + ACPAXI2AXI_ATU_BASE_ADDR_GRP_2);\n\twritel(PAGE_SIZE_4K_ENABLE, acp_base + ACPAXI2AXI_ATU_PAGE_SIZE_GRP_2);\n\tfor (page_idx = 0; page_idx < stream->num_pages; page_idx++) {\n\t\t \n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\n\t\twritel(low, acp_base + ACP_SCRATCH_REG_0 + val);\n\t\thigh |= BIT(31);\n\t\twritel(high, acp_base + ACP_SCRATCH_REG_0 + val + 4);\n\t\tval += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n\twritel(0x1, acp_base + ACPAXI2AXI_ATU_CTRL);\n}\n\nstatic int acp63_configure_sdw_ringbuffer(void __iomem *acp_base, u32 stream_id, u32 size,\n\t\t\t\t\t  u32 manager_instance)\n{\n\tu32 reg_dma_size;\n\tu32 reg_fifo_addr;\n\tu32 reg_fifo_size;\n\tu32 reg_ring_buf_size;\n\tu32 reg_ring_buf_addr;\n\tu32 sdw_fifo_addr;\n\tu32 sdw_fifo_offset;\n\tu32 sdw_ring_buf_addr;\n\tu32 sdw_ring_buf_size;\n\tu32 sdw_mem_window_offset;\n\n\tswitch (manager_instance) {\n\tcase ACP_SDW0:\n\t\treg_dma_size = sdw0_dma_ring_buf_reg[stream_id].reg_dma_size;\n\t\treg_fifo_addr =\tsdw0_dma_ring_buf_reg[stream_id].reg_fifo_addr;\n\t\treg_fifo_size = sdw0_dma_ring_buf_reg[stream_id].reg_fifo_size;\n\t\treg_ring_buf_size = sdw0_dma_ring_buf_reg[stream_id].reg_ring_buf_size;\n\t\treg_ring_buf_addr = sdw0_dma_ring_buf_reg[stream_id].reg_ring_buf_addr;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\treg_dma_size = sdw1_dma_ring_buf_reg[stream_id].reg_dma_size;\n\t\treg_fifo_addr =\tsdw1_dma_ring_buf_reg[stream_id].reg_fifo_addr;\n\t\treg_fifo_size = sdw1_dma_ring_buf_reg[stream_id].reg_fifo_size;\n\t\treg_ring_buf_size = sdw1_dma_ring_buf_reg[stream_id].reg_ring_buf_size;\n\t\treg_ring_buf_addr = sdw1_dma_ring_buf_reg[stream_id].reg_ring_buf_addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsdw_fifo_offset = ACP_SDW_FIFO_OFFSET(manager_instance);\n\tsdw_mem_window_offset = SDW_MEM_WINDOW_START(manager_instance);\n\tsdw_fifo_addr = sdw_fifo_offset + (stream_id * SDW_FIFO_OFFSET);\n\tsdw_ring_buf_addr = sdw_mem_window_offset + (stream_id * ACP_SDW_RING_BUFF_ADDR_OFFSET);\n\tsdw_ring_buf_size = size;\n\twritel(sdw_ring_buf_size, acp_base + reg_ring_buf_size);\n\twritel(sdw_ring_buf_addr, acp_base + reg_ring_buf_addr);\n\twritel(sdw_fifo_addr, acp_base + reg_fifo_addr);\n\twritel(SDW_DMA_SIZE, acp_base + reg_dma_size);\n\twritel(SDW_FIFO_SIZE, acp_base + reg_fifo_size);\n\treturn 0;\n}\n\nstatic int acp63_sdw_dma_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct acp_sdw_dma_stream *stream;\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct amd_sdw_manager *amd_manager;\n\tstruct snd_soc_pcm_runtime *prtd = substream->private_data;\n\tint ret;\n\n\truntime = substream->runtime;\n\tcpu_dai = asoc_rtd_to_cpu(prtd, 0);\n\tamd_manager = snd_soc_dai_get_drvdata(cpu_dai);\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = acp63_sdw_hardware_playback;\n\telse\n\t\truntime->hw = acp63_sdw_hardware_capture;\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"set integer constraint failed\\n\");\n\t\tkfree(stream);\n\t\treturn ret;\n\t}\n\n\tstream->stream_id = cpu_dai->id;\n\tstream->instance = amd_manager->instance;\n\truntime->private_data = stream;\n\treturn ret;\n}\n\nstatic int acp63_sdw_dma_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct acp_sdw_dma_stream *stream;\n\tstruct sdw_dma_dev_data *sdw_data;\n\tu32 period_bytes;\n\tu32 water_mark_size_reg;\n\tu32 irq_mask, ext_intr_ctrl;\n\tu64 size;\n\tu32 stream_id;\n\tu32 acp_ext_intr_cntl_reg;\n\tint ret;\n\n\tsdw_data = dev_get_drvdata(component->dev);\n\tstream = substream->runtime->private_data;\n\tif (!stream)\n\t\treturn -EINVAL;\n\tstream_id = stream->stream_id;\n\tswitch (stream->instance) {\n\tcase ACP_SDW0:\n\t\tsdw_data->sdw0_dma_stream[stream_id] = substream;\n\t\twater_mark_size_reg = sdw0_dma_ring_buf_reg[stream_id].water_mark_size_reg;\n\t\tacp_ext_intr_cntl_reg = ACP_EXTERNAL_INTR_CNTL;\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tirq_mask = BIT(SDW0_DMA_TX_IRQ_MASK(stream_id));\n\t\telse\n\t\t\tirq_mask = BIT(SDW0_DMA_RX_IRQ_MASK(stream_id));\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tsdw_data->sdw1_dma_stream[stream_id] = substream;\n\t\tacp_ext_intr_cntl_reg = ACP_EXTERNAL_INTR_CNTL1;\n\t\twater_mark_size_reg = sdw1_dma_ring_buf_reg[stream_id].water_mark_size_reg;\n\t\tirq_mask = BIT(SDW1_DMA_IRQ_MASK(stream_id));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsize = params_buffer_bytes(params);\n\tperiod_bytes = params_period_bytes(params);\n\tstream->dma_addr = substream->runtime->dma_addr;\n\tstream->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);\n\tacp63_config_dma(stream, sdw_data->acp_base, stream_id);\n\tret = acp63_configure_sdw_ringbuffer(sdw_data->acp_base, stream_id, size,\n\t\t\t\t\t     stream->instance);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Invalid DMA channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\text_intr_ctrl = readl(sdw_data->acp_base + acp_ext_intr_cntl_reg);\n\text_intr_ctrl |= irq_mask;\n\twritel(ext_intr_ctrl, sdw_data->acp_base + acp_ext_intr_cntl_reg);\n\twritel(period_bytes, sdw_data->acp_base + water_mark_size_reg);\n\treturn 0;\n}\n\nstatic u64 acp63_sdw_get_byte_count(struct acp_sdw_dma_stream *stream, void __iomem *acp_base)\n{\n\tunion acp_sdw_dma_count byte_count;\n\tu32 pos_low_reg, pos_high_reg;\n\n\tbyte_count.bytescount = 0;\n\tswitch (stream->instance) {\n\tcase ACP_SDW0:\n\t\tpos_low_reg = sdw0_dma_ring_buf_reg[stream->stream_id].pos_low_reg;\n\t\tpos_high_reg = sdw0_dma_ring_buf_reg[stream->stream_id].pos_high_reg;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tpos_low_reg = sdw1_dma_ring_buf_reg[stream->stream_id].pos_low_reg;\n\t\tpos_high_reg = sdw1_dma_ring_buf_reg[stream->stream_id].pos_high_reg;\n\t\tbreak;\n\tdefault:\n\t\tgoto POINTER_RETURN_BYTES;\n\t}\n\tif (pos_low_reg) {\n\t\tbyte_count.bcount.high = readl(acp_base + pos_high_reg);\n\t\tbyte_count.bcount.low = readl(acp_base + pos_low_reg);\n\t}\nPOINTER_RETURN_BYTES:\n\treturn byte_count.bytescount;\n}\n\nstatic snd_pcm_uframes_t acp63_sdw_dma_pointer(struct snd_soc_component *comp,\n\t\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct sdw_dma_dev_data *sdw_data;\n\tstruct acp_sdw_dma_stream *stream;\n\tu32 pos, buffersize;\n\tu64 bytescount;\n\n\tsdw_data = dev_get_drvdata(comp->dev);\n\tstream = substream->runtime->private_data;\n\tbuffersize = frames_to_bytes(substream->runtime,\n\t\t\t\t     substream->runtime->buffer_size);\n\tbytescount = acp63_sdw_get_byte_count(stream, sdw_data->acp_base);\n\tif (bytescount > stream->bytescount)\n\t\tbytescount -= stream->bytescount;\n\tpos = do_div(bytescount, buffersize);\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic int acp63_sdw_dma_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *parent = component->dev->parent;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       parent, SDW_MIN_BUFFER, SDW_MAX_BUFFER);\n\treturn 0;\n}\n\nstatic int acp63_sdw_dma_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct sdw_dma_dev_data *sdw_data;\n\tstruct acp_sdw_dma_stream *stream;\n\n\tsdw_data = dev_get_drvdata(component->dev);\n\tstream = substream->runtime->private_data;\n\tif (!stream)\n\t\treturn -EINVAL;\n\tswitch (stream->instance) {\n\tcase ACP_SDW0:\n\t\tsdw_data->sdw0_dma_stream[stream->stream_id] = NULL;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tsdw_data->sdw1_dma_stream[stream->stream_id] = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tkfree(stream);\n\treturn 0;\n}\n\nstatic int acp63_sdw_dma_enable(struct snd_pcm_substream *substream,\n\t\t\t\tvoid __iomem *acp_base, bool sdw_dma_enable)\n{\n\tstruct acp_sdw_dma_stream *stream;\n\tu32 stream_id;\n\tu32 sdw_dma_en_reg;\n\tu32 sdw_dma_en_stat_reg;\n\tu32 sdw_dma_stat;\n\tu32 dma_enable;\n\n\tstream = substream->runtime->private_data;\n\tstream_id = stream->stream_id;\n\tswitch (stream->instance) {\n\tcase ACP_SDW0:\n\t\tsdw_dma_en_reg = sdw0_dma_enable_reg[stream_id];\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tsdw_dma_en_reg = sdw1_dma_enable_reg[stream_id];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsdw_dma_en_stat_reg = sdw_dma_en_reg + 4;\n\tdma_enable = sdw_dma_enable;\n\twritel(dma_enable, acp_base + sdw_dma_en_reg);\n\treturn readl_poll_timeout(acp_base + sdw_dma_en_stat_reg, sdw_dma_stat,\n\t\t\t\t  (sdw_dma_stat == dma_enable), ACP_DELAY_US, ACP_COUNTER);\n}\n\nstatic int acp63_sdw_dma_trigger(struct snd_soc_component *comp,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t int cmd)\n{\n\tstruct sdw_dma_dev_data *sdw_data;\n\tint ret;\n\n\tsdw_data = dev_get_drvdata(comp->dev);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tret = acp63_sdw_dma_enable(substream, sdw_data->acp_base, true);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = acp63_sdw_dma_enable(substream, sdw_data->acp_base, false);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tdev_err(comp->dev, \"trigger %d failed: %d\", cmd, ret);\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver acp63_sdw_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= acp63_sdw_dma_open,\n\t.close\t\t= acp63_sdw_dma_close,\n\t.hw_params\t= acp63_sdw_dma_hw_params,\n\t.trigger\t= acp63_sdw_dma_trigger,\n\t.pointer\t= acp63_sdw_dma_pointer,\n\t.pcm_construct\t= acp63_sdw_dma_new,\n};\n\nstatic int acp63_sdw_platform_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct sdw_dma_dev_data *sdw_data;\n\tstruct acp63_dev_data *acp_data;\n\tstruct device *parent;\n\tint status;\n\n\tparent = pdev->dev.parent;\n\tacp_data = dev_get_drvdata(parent);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"IORESOURCE_MEM FAILED\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsdw_data = devm_kzalloc(&pdev->dev, sizeof(*sdw_data), GFP_KERNEL);\n\tif (!sdw_data)\n\t\treturn -ENOMEM;\n\n\tsdw_data->acp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!sdw_data->acp_base)\n\t\treturn -ENOMEM;\n\n\tsdw_data->acp_lock = &acp_data->acp_lock;\n\tdev_set_drvdata(&pdev->dev, sdw_data);\n\tstatus = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t\t &acp63_sdw_component,\n\t\t\t\t\t\t NULL, 0);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Fail to register sdw dma component\\n\");\n\t\treturn status;\n\t}\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, ACP_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic void acp63_sdw_platform_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int acp_restore_sdw_dma_config(struct sdw_dma_dev_data *sdw_data)\n{\n\tstruct acp_sdw_dma_stream *stream;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tu32 period_bytes, buf_size, water_mark_size_reg;\n\tu32 stream_count;\n\tint index, instance, ret;\n\n\tfor (instance = 0; instance < AMD_SDW_MAX_MANAGERS; instance++) {\n\t\tif (instance == ACP_SDW0)\n\t\t\tstream_count = ACP63_SDW0_DMA_MAX_STREAMS;\n\t\telse\n\t\t\tstream_count = ACP63_SDW1_DMA_MAX_STREAMS;\n\n\t\tfor (index = 0; index < stream_count; index++) {\n\t\t\tif (instance == ACP_SDW0) {\n\t\t\t\tsubstream = sdw_data->sdw0_dma_stream[index];\n\t\t\t\twater_mark_size_reg =\n\t\t\t\t\t\tsdw0_dma_ring_buf_reg[index].water_mark_size_reg;\n\t\t\t} else {\n\t\t\t\tsubstream = sdw_data->sdw1_dma_stream[index];\n\t\t\t\twater_mark_size_reg =\n\t\t\t\t\t\tsdw1_dma_ring_buf_reg[index].water_mark_size_reg;\n\t\t\t}\n\n\t\t\tif (substream && substream->runtime) {\n\t\t\t\truntime = substream->runtime;\n\t\t\t\tstream = runtime->private_data;\n\t\t\t\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\t\t\t\tbuf_size = frames_to_bytes(runtime, runtime->buffer_size);\n\t\t\t\tacp63_config_dma(stream, sdw_data->acp_base, index);\n\t\t\t\tret = acp63_configure_sdw_ringbuffer(sdw_data->acp_base, index,\n\t\t\t\t\t\t\t\t     buf_size, instance);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\twritel(period_bytes, sdw_data->acp_base + water_mark_size_reg);\n\t\t\t}\n\t\t}\n\t}\n\tacp63_enable_disable_sdw_dma_interrupts(sdw_data->acp_base, true);\n\treturn 0;\n}\n\nstatic int __maybe_unused acp63_sdw_pcm_resume(struct device *dev)\n{\n\tstruct sdw_dma_dev_data *sdw_data;\n\n\tsdw_data = dev_get_drvdata(dev);\n\treturn acp_restore_sdw_dma_config(sdw_data);\n}\n\nstatic const struct dev_pm_ops acp63_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, acp63_sdw_pcm_resume)\n};\n\nstatic struct platform_driver acp63_sdw_dma_driver = {\n\t.probe = acp63_sdw_platform_probe,\n\t.remove_new = acp63_sdw_platform_remove,\n\t.driver = {\n\t\t.name = \"amd_ps_sdw_dma\",\n\t\t.pm = &acp63_pm_ops,\n\t},\n};\n\nmodule_platform_driver(acp63_sdw_dma_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD ACP6.3 PS SDW DMA Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}