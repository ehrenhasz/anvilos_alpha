{
  "module_name": "aries_wm8994.c",
  "hash_id": "c0af4ea1327e13f1c23f2de8fbc709f97e6452c7860968891accc8e300cdc0bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/aries_wm8994.c",
  "human_readable_source": "\n#include <linux/extcon.h>\n#include <linux/iio/consumer.h>\n#include <linux/input-event-codes.h>\n#include <linux/mfd/wm8994/registers.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n#include <sound/jack.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"i2s.h\"\n#include \"../codecs/wm8994.h\"\n\n#define ARIES_MCLK1_FREQ 24000000\n\nstruct aries_wm8994_variant {\n\tunsigned int modem_dai_fmt;\n\tbool has_fm_radio;\n};\n\nstruct aries_wm8994_data {\n\tstruct extcon_dev *usb_extcon;\n\tstruct regulator *reg_main_micbias;\n\tstruct regulator *reg_headset_micbias;\n\tstruct gpio_desc *gpio_headset_detect;\n\tstruct gpio_desc *gpio_headset_key;\n\tstruct gpio_desc *gpio_earpath_sel;\n\tstruct iio_channel *adc;\n\tconst struct aries_wm8994_variant *variant;\n};\n\n \nstatic struct snd_soc_jack aries_dock;\n\nstatic struct snd_soc_jack_pin dock_pins[] = {\n\t{\n\t\t.pin = \"LINE\",\n\t\t.mask = SND_JACK_LINEOUT,\n\t},\n};\n\nstatic int aries_extcon_notifier(struct notifier_block *this,\n\t\t\t\t unsigned long connected, void *_cmd)\n{\n\tif (connected)\n\t\tsnd_soc_jack_report(&aries_dock, SND_JACK_LINEOUT,\n\t\t\t\tSND_JACK_LINEOUT);\n\telse\n\t\tsnd_soc_jack_report(&aries_dock, 0, SND_JACK_LINEOUT);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block aries_extcon_notifier_block = {\n\t.notifier_call = aries_extcon_notifier,\n};\n\n \nstatic struct snd_soc_jack aries_headset;\n\nstatic struct snd_soc_jack_pin jack_pins[] = {\n\t{\n\t\t.pin = \"HP\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t}, {\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic struct snd_soc_jack_zone headset_zones[] = {\n\t{\n\t\t.min_mv = 0,\n\t\t.max_mv = 241,\n\t\t.jack_type = SND_JACK_HEADPHONE,\n\t}, {\n\t\t.min_mv = 242,\n\t\t.max_mv = 2980,\n\t\t.jack_type = SND_JACK_HEADSET,\n\t}, {\n\t\t.min_mv = 2981,\n\t\t.max_mv = UINT_MAX,\n\t\t.jack_type = SND_JACK_HEADPHONE,\n\t},\n};\n\nstatic irqreturn_t headset_det_irq_thread(int irq, void *data)\n{\n\tstruct aries_wm8994_data *priv = (struct aries_wm8994_data *) data;\n\tint ret = 0;\n\tint time_left_ms = 300;\n\tint adc;\n\n\twhile (time_left_ms > 0) {\n\t\tif (!gpiod_get_value(priv->gpio_headset_detect)) {\n\t\t\tsnd_soc_jack_report(&aries_headset, 0,\n\t\t\t\t\tSND_JACK_HEADSET);\n\t\t\tgpiod_set_value(priv->gpio_earpath_sel, 0);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tmsleep(20);\n\t\ttime_left_ms -= 20;\n\t}\n\n\t \n\tret = regulator_enable(priv->reg_headset_micbias);\n\tif (ret)\n\t\tpr_err(\"%s failed to enable micbias: %d\", __func__, ret);\n\n\tgpiod_set_value(priv->gpio_earpath_sel, 1);\n\n\tret = iio_read_channel_processed(priv->adc, &adc);\n\tif (ret < 0) {\n\t\t \n\t\tpr_err(\"%s failed to read ADC, assuming headphones\", __func__);\n\t\tsnd_soc_jack_report(&aries_headset, SND_JACK_HEADPHONE,\n\t\t\t\tSND_JACK_HEADSET);\n\t} else {\n\t\tsnd_soc_jack_report(&aries_headset,\n\t\t\t\tsnd_soc_jack_get_type(&aries_headset, adc),\n\t\t\t\tSND_JACK_HEADSET);\n\t}\n\n\tret = regulator_disable(priv->reg_headset_micbias);\n\tif (ret)\n\t\tpr_err(\"%s failed disable micbias: %d\", __func__, ret);\n\n\t \n\tif (!(aries_headset.status & SND_JACK_MICROPHONE))\n\t\tgpiod_set_value(priv->gpio_earpath_sel, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int headset_button_check(void *data)\n{\n\tstruct aries_wm8994_data *priv = (struct aries_wm8994_data *) data;\n\n\t \n\tif (gpiod_get_value_cansleep(priv->gpio_headset_key) &&\n\t\t\taries_headset.status & SND_JACK_MICROPHONE)\n\t\treturn SND_JACK_BTN_0;\n\n\treturn 0;\n}\n\nstatic struct snd_soc_jack_gpio headset_button_gpio[] = {\n\t{\n\t\t.name = \"Media Button\",\n\t\t.report = SND_JACK_BTN_0,\n\t\t.debounce_time  = 30,\n\t\t.jack_status_check = headset_button_check,\n\t},\n};\n\nstatic int aries_spk_cfg(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_component *component;\n\tint ret = 0;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);\n\tcomponent = asoc_rtd_to_codec(rtd, 0)->component;\n\n\t \n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\tWM8994_AIF1_DAC1_FILTERS_1,\n\t\t\t\tWM8994_AIF1DAC1_MONO, WM8994_AIF1DAC1_MONO);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\tWM8994_AIF1_DAC1_FILTERS_1,\n\t\t\t\tWM8994_AIF1DAC1_MONO, 0);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aries_main_bias(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct aries_wm8994_data *priv = snd_soc_card_get_drvdata(card);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = regulator_enable(priv->reg_main_micbias);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = regulator_disable(priv->reg_main_micbias);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aries_headset_bias(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct aries_wm8994_data *priv = snd_soc_card_get_drvdata(card);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = regulator_enable(priv->reg_headset_micbias);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = regulator_disable(priv->reg_headset_micbias);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new aries_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Modem In\"),\n\tSOC_DAPM_PIN_SWITCH(\"Modem Out\"),\n};\n\nstatic const struct snd_soc_dapm_widget aries_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"HP\", NULL),\n\n\tSND_SOC_DAPM_SPK(\"SPK\", aries_spk_cfg),\n\tSND_SOC_DAPM_SPK(\"RCV\", NULL),\n\n\tSND_SOC_DAPM_LINE(\"LINE\", NULL),\n\n\tSND_SOC_DAPM_MIC(\"Main Mic\", aries_main_bias),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", aries_headset_bias),\n\n\tSND_SOC_DAPM_MIC(\"Bluetooth Mic\", NULL),\n\tSND_SOC_DAPM_SPK(\"Bluetooth SPK\", NULL),\n\n\tSND_SOC_DAPM_LINE(\"Modem In\", NULL),\n\tSND_SOC_DAPM_LINE(\"Modem Out\", NULL),\n\n\t \n\tSND_SOC_DAPM_LINE(\"FM In\", NULL),\n};\n\nstatic int aries_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tunsigned int pll_out;\n\tint ret;\n\n\t \n\tif (params_width(params) == 24)\n\t\tpll_out = params_rate(params) * 384;\n\telse if (params_rate(params) == 8000 || params_rate(params) == 11025)\n\t\tpll_out = params_rate(params) * 512;\n\telse\n\t\tpll_out = params_rate(params) * 256;\n\n\tret = snd_soc_dai_set_pll(codec_dai, WM8994_FLL1, WM8994_FLL_SRC_MCLK1,\n\t\t\t\tARIES_MCLK1_FREQ, pll_out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, WM8994_SYSCLK_FLL1,\n\t\t\t\tpll_out, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int aries_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, WM8994_SYSCLK_MCLK1,\n\t\t\t\tARIES_MCLK1_FREQ, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dai_set_pll(codec_dai, WM8994_FLL1, WM8994_FLL_SRC_MCLK1,\n\t\t\t\tARIES_MCLK1_FREQ, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_ops aries_ops = {\n\t.hw_params = aries_hw_params,\n\t.hw_free = aries_hw_free,\n};\n\nstatic int aries_baseband_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tunsigned int pll_out;\n\tint ret;\n\n\tpll_out = 8000 * 512;\n\n\t \n\tret = snd_soc_dai_set_pll(codec_dai, WM8994_FLL2, WM8994_FLL_SRC_MCLK1,\n\t\t\tARIES_MCLK1_FREQ, pll_out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, WM8994_SYSCLK_FLL2,\n\t\t\tpll_out, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int aries_late_probe(struct snd_soc_card *card)\n{\n\tstruct aries_wm8994_data *priv = snd_soc_card_get_drvdata(card);\n\tint ret, irq;\n\n\tret = snd_soc_card_jack_new_pins(card, \"Dock\", SND_JACK_LINEOUT,\n\t\t\t&aries_dock, dock_pins, ARRAY_SIZE(dock_pins));\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_extcon_register_notifier(card->dev,\n\t\t\tpriv->usb_extcon, EXTCON_JACK_LINE_OUT,\n\t\t\t&aries_extcon_notifier_block);\n\tif (ret)\n\t\treturn ret;\n\n\tif (extcon_get_state(priv->usb_extcon,\n\t\t\tEXTCON_JACK_LINE_OUT) > 0)\n\t\tsnd_soc_jack_report(&aries_dock, SND_JACK_LINEOUT,\n\t\t\t\tSND_JACK_LINEOUT);\n\telse\n\t\tsnd_soc_jack_report(&aries_dock, 0, SND_JACK_LINEOUT);\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset\",\n\t\t\tSND_JACK_HEADSET | SND_JACK_BTN_0,\n\t\t\t&aries_headset,\n\t\t\tjack_pins, ARRAY_SIZE(jack_pins));\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_jack_add_zones(&aries_headset, ARRAY_SIZE(headset_zones),\n\t\t\theadset_zones);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = gpiod_to_irq(priv->gpio_headset_detect);\n\tif (irq < 0) {\n\t\tdev_err(card->dev, \"Failed to map headset detect gpio to irq\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_threaded_irq(card->dev, irq, NULL,\n\t\t\theadset_det_irq_thread,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\n\t\t\tIRQF_ONESHOT, \"headset_detect\", priv);\n\tif (ret) {\n\t\tdev_err(card->dev, \"Failed to request headset detect irq\");\n\t\treturn ret;\n\t}\n\n\theadset_button_gpio[0].data = priv;\n\theadset_button_gpio[0].desc = priv->gpio_headset_key;\n\n\tsnd_jack_set_key(aries_headset.jack, SND_JACK_BTN_0, KEY_MEDIA);\n\n\treturn snd_soc_jack_add_gpios(&aries_headset,\n\t\t\tARRAY_SIZE(headset_button_gpio), headset_button_gpio);\n}\n\nstatic const struct snd_soc_pcm_stream baseband_params = {\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rate_min = 8000,\n\t.rate_max = 8000,\n\t.channels_min = 1,\n\t.channels_max = 1,\n};\n\nstatic const struct snd_soc_pcm_stream bluetooth_params = {\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rate_min = 8000,\n\t.rate_max = 8000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n};\n\nstatic const struct snd_soc_dapm_widget aries_modem_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"Modem RX\"),\n\tSND_SOC_DAPM_OUTPUT(\"Modem TX\"),\n};\n\nstatic const struct snd_soc_dapm_route aries_modem_routes[] = {\n\t{ \"Modem Capture\", NULL, \"Modem RX\" },\n\t{ \"Modem TX\", NULL, \"Modem Playback\" },\n};\n\nstatic const struct snd_soc_component_driver aries_component = {\n\t.name\t\t\t= \"aries-audio\",\n\t.dapm_widgets\t\t= aries_modem_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aries_modem_widgets),\n\t.dapm_routes\t\t= aries_modem_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aries_modem_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver aries_ext_dai[] = {\n\t{\n\t\t.name = \"Voice call\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Modem Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 8000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Modem Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 8000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t},\n};\n\nSND_SOC_DAILINK_DEFS(aif1,\n\tDAILINK_COMP_ARRAY(COMP_CPU(SAMSUNG_I2S_DAI)),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(baseband,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"Voice call\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif2\")));\n\nSND_SOC_DAILINK_DEFS(bluetooth,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"bt-sco-pcm\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif3\")));\n\nstatic struct snd_soc_dai_link aries_dai[] = {\n\t{\n\t\t.name = \"WM8994 AIF1\",\n\t\t.stream_name = \"HiFi\",\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBM_CFM,\n\t\t.ops = &aries_ops,\n\t\tSND_SOC_DAILINK_REG(aif1),\n\t},\n\t{\n\t\t.name = \"WM8994 AIF2\",\n\t\t.stream_name = \"Baseband\",\n\t\t.init = &aries_baseband_init,\n\t\t.c2c_params = &baseband_params,\n\t\t.num_c2c_params = 1,\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(baseband),\n\t},\n\t{\n\t\t.name = \"WM8994 AIF3\",\n\t\t.stream_name = \"Bluetooth\",\n\t\t.c2c_params = &bluetooth_params,\n\t\t.num_c2c_params = 1,\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(bluetooth),\n\t},\n};\n\nstatic struct snd_soc_card aries_card = {\n\t.name = \"ARIES\",\n\t.owner = THIS_MODULE,\n\t.dai_link = aries_dai,\n\t.num_links = ARRAY_SIZE(aries_dai),\n\t.controls = aries_controls,\n\t.num_controls = ARRAY_SIZE(aries_controls),\n\t.dapm_widgets = aries_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(aries_dapm_widgets),\n\t.late_probe = aries_late_probe,\n};\n\nstatic const struct aries_wm8994_variant fascinate4g_variant = {\n\t.modem_dai_fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBS_CFS\n\t\t| SND_SOC_DAIFMT_IB_NF,\n\t.has_fm_radio = false,\n};\n\nstatic const struct aries_wm8994_variant aries_variant = {\n\t.modem_dai_fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBM_CFM\n\t\t| SND_SOC_DAIFMT_IB_NF,\n\t.has_fm_radio = true,\n};\n\nstatic const struct of_device_id samsung_wm8994_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,fascinate4g-wm8994\",\n\t\t.data = &fascinate4g_variant,\n\t},\n\t{\n\t\t.compatible = \"samsung,aries-wm8994\",\n\t\t.data = &aries_variant,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, samsung_wm8994_of_match);\n\nstatic int aries_audio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *cpu, *codec, *extcon_np;\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_card *card = &aries_card;\n\tstruct aries_wm8994_data *priv;\n\tstruct snd_soc_dai_link *dai_link;\n\tconst struct of_device_id *match;\n\tenum iio_chan_type channel_type;\n\tint ret, i;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tcard->dev = dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tmatch = of_match_node(samsung_wm8994_of_match, np);\n\tpriv->variant = match->data;\n\n\t \n\tif (!priv->variant->has_fm_radio)\n\t\tcard->num_dapm_widgets--;\n\n\tpriv->reg_main_micbias = devm_regulator_get(dev, \"main-micbias\");\n\tif (IS_ERR(priv->reg_main_micbias)) {\n\t\tdev_err(dev, \"Failed to get main micbias regulator\\n\");\n\t\treturn PTR_ERR(priv->reg_main_micbias);\n\t}\n\n\tpriv->reg_headset_micbias = devm_regulator_get(dev, \"headset-micbias\");\n\tif (IS_ERR(priv->reg_headset_micbias)) {\n\t\tdev_err(dev, \"Failed to get headset micbias regulator\\n\");\n\t\treturn PTR_ERR(priv->reg_headset_micbias);\n\t}\n\n\tpriv->gpio_earpath_sel = devm_gpiod_get(dev, \"earpath-sel\",\n\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpio_earpath_sel)) {\n\t\tdev_err(dev, \"Failed to get earpath selector gpio\");\n\t\treturn PTR_ERR(priv->gpio_earpath_sel);\n\t}\n\n\textcon_np = of_parse_phandle(np, \"extcon\", 0);\n\tpriv->usb_extcon = extcon_find_edev_by_node(extcon_np);\n\tof_node_put(extcon_np);\n\tif (IS_ERR(priv->usb_extcon))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->usb_extcon),\n\t\t\t\t     \"Failed to get extcon device\");\n\n\tpriv->adc = devm_iio_channel_get(dev, \"headset-detect\");\n\tif (IS_ERR(priv->adc))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->adc),\n\t\t\t\t     \"Failed to get ADC channel\");\n\n\tret = iio_get_channel_type(priv->adc, &channel_type);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to get ADC channel type\");\n\tif (channel_type != IIO_VOLTAGE)\n\t\treturn -EINVAL;\n\n\tpriv->gpio_headset_key = devm_gpiod_get(dev, \"headset-key\",\n\t\t\tGPIOD_IN);\n\tif (IS_ERR(priv->gpio_headset_key)) {\n\t\tdev_err(dev, \"Failed to get headset key gpio\");\n\t\treturn PTR_ERR(priv->gpio_headset_key);\n\t}\n\n\tpriv->gpio_headset_detect = devm_gpiod_get(dev,\n\t\t\t\"headset-detect\", GPIOD_IN);\n\tif (IS_ERR(priv->gpio_headset_detect)) {\n\t\tdev_err(dev, \"Failed to get headset detect gpio\");\n\t\treturn PTR_ERR(priv->gpio_headset_detect);\n\t}\n\n\t \n\tsnd_soc_of_parse_card_name(card, \"model\");\n\n\tret = snd_soc_of_parse_audio_routing(card, \"audio-routing\");\n\tif (ret < 0) {\n\t\t \n\t\tret = snd_soc_of_parse_audio_routing(card, \"samsung,audio-routing\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Audio routing invalid/unspecified\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\taries_dai[1].dai_fmt = priv->variant->modem_dai_fmt;\n\n\tcpu = of_get_child_by_name(dev->of_node, \"cpu\");\n\tif (!cpu)\n\t\treturn -EINVAL;\n\n\tcodec = of_get_child_by_name(dev->of_node, \"codec\");\n\tif (!codec) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tdai_link->codecs->of_node = of_parse_phandle(codec,\n\t\t\t\t\"sound-dai\", 0);\n\t\tif (!dai_link->codecs->of_node) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\taries_dai[0].cpus->of_node = of_parse_phandle(cpu,\n\t\t\t\"sound-dai\", 0);\n\tif (!aries_dai[0].cpus->of_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taries_dai[0].platforms->of_node = aries_dai[0].cpus->of_node;\n\n\t \n\taries_dai[2].cpus->of_node = of_parse_phandle(cpu,\n\t\t\t\"sound-dai\", 1);\n\tif (!aries_dai[2].cpus->of_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &aries_component,\n\t\t\t\taries_ext_dai, ARRAY_SIZE(aries_ext_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register component: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret)\n\t\tdev_err(dev, \"snd_soc_register_card() failed:%d\\n\", ret);\n\nout:\n\tof_node_put(cpu);\n\tof_node_put(codec);\n\n\treturn ret;\n}\n\nstatic struct platform_driver aries_audio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"aries-audio-wm8994\",\n\t\t.of_match_table = of_match_ptr(samsung_wm8994_of_match),\n\t\t.pm\t= &snd_soc_pm_ops,\n\t},\n\t.probe\t\t= aries_audio_probe,\n};\n\nmodule_platform_driver(aries_audio_driver);\n\nMODULE_DESCRIPTION(\"ALSA SoC ARIES WM8994\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:aries-audio-wm8994\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}