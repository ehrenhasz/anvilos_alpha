{
  "module_name": "pcm.c",
  "hash_id": "ee75ca6c57c06db3dafd5639123c7ddbc191edd36301e7a980dbd7bd1a17a90a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#include <linux/platform_data/asoc-s3c.h>\n\n#include \"dma.h\"\n#include \"pcm.h\"\n\n \n#define S3C_PCM_CTL\t\t0x00\n#define S3C_PCM_CLKCTL\t\t0x04\n#define S3C_PCM_TXFIFO\t\t0x08\n#define S3C_PCM_RXFIFO\t\t0x0C\n#define S3C_PCM_IRQCTL\t\t0x10\n#define S3C_PCM_IRQSTAT\t\t0x14\n#define S3C_PCM_FIFOSTAT\t0x18\n#define S3C_PCM_CLRINT\t\t0x20\n\n \n#define S3C_PCM_CTL_TXDIPSTICK_MASK\t0x3f\n#define S3C_PCM_CTL_TXDIPSTICK_SHIFT\t13\n#define S3C_PCM_CTL_RXDIPSTICK_MASK\t0x3f\n#define S3C_PCM_CTL_RXDIPSTICK_SHIFT\t7\n#define S3C_PCM_CTL_TXDMA_EN\t\t(0x1 << 6)\n#define S3C_PCM_CTL_RXDMA_EN\t\t(0x1 << 5)\n#define S3C_PCM_CTL_TXMSB_AFTER_FSYNC\t(0x1 << 4)\n#define S3C_PCM_CTL_RXMSB_AFTER_FSYNC\t(0x1 << 3)\n#define S3C_PCM_CTL_TXFIFO_EN\t\t(0x1 << 2)\n#define S3C_PCM_CTL_RXFIFO_EN\t\t(0x1 << 1)\n#define S3C_PCM_CTL_ENABLE\t\t(0x1 << 0)\n\n \n#define S3C_PCM_CLKCTL_SERCLK_EN\t(0x1 << 19)\n#define S3C_PCM_CLKCTL_SERCLKSEL_PCLK\t(0x1 << 18)\n#define S3C_PCM_CLKCTL_SCLKDIV_MASK\t0x1ff\n#define S3C_PCM_CLKCTL_SYNCDIV_MASK\t0x1ff\n#define S3C_PCM_CLKCTL_SCLKDIV_SHIFT\t9\n#define S3C_PCM_CLKCTL_SYNCDIV_SHIFT\t0\n\n \n#define S3C_PCM_TXFIFO_DVALID\t(0x1 << 16)\n#define S3C_PCM_TXFIFO_DATA_MSK\t(0xffff << 0)\n\n \n#define S3C_PCM_RXFIFO_DVALID\t(0x1 << 16)\n#define S3C_PCM_RXFIFO_DATA_MSK\t(0xffff << 0)\n\n \n#define S3C_PCM_IRQCTL_IRQEN\t\t(0x1 << 14)\n#define S3C_PCM_IRQCTL_WRDEN\t\t(0x1 << 12)\n#define S3C_PCM_IRQCTL_TXEMPTYEN\t(0x1 << 11)\n#define S3C_PCM_IRQCTL_TXALMSTEMPTYEN\t(0x1 << 10)\n#define S3C_PCM_IRQCTL_TXFULLEN\t\t(0x1 << 9)\n#define S3C_PCM_IRQCTL_TXALMSTFULLEN\t(0x1 << 8)\n#define S3C_PCM_IRQCTL_TXSTARVEN\t(0x1 << 7)\n#define S3C_PCM_IRQCTL_TXERROVRFLEN\t(0x1 << 6)\n#define S3C_PCM_IRQCTL_RXEMPTEN\t\t(0x1 << 5)\n#define S3C_PCM_IRQCTL_RXALMSTEMPTEN\t(0x1 << 4)\n#define S3C_PCM_IRQCTL_RXFULLEN\t\t(0x1 << 3)\n#define S3C_PCM_IRQCTL_RXALMSTFULLEN\t(0x1 << 2)\n#define S3C_PCM_IRQCTL_RXSTARVEN\t(0x1 << 1)\n#define S3C_PCM_IRQCTL_RXERROVRFLEN\t(0x1 << 0)\n\n \n#define S3C_PCM_IRQSTAT_IRQPND\t\t(0x1 << 13)\n#define S3C_PCM_IRQSTAT_WRD_XFER\t(0x1 << 12)\n#define S3C_PCM_IRQSTAT_TXEMPTY\t\t(0x1 << 11)\n#define S3C_PCM_IRQSTAT_TXALMSTEMPTY\t(0x1 << 10)\n#define S3C_PCM_IRQSTAT_TXFULL\t\t(0x1 << 9)\n#define S3C_PCM_IRQSTAT_TXALMSTFULL\t(0x1 << 8)\n#define S3C_PCM_IRQSTAT_TXSTARV\t\t(0x1 << 7)\n#define S3C_PCM_IRQSTAT_TXERROVRFL\t(0x1 << 6)\n#define S3C_PCM_IRQSTAT_RXEMPT\t\t(0x1 << 5)\n#define S3C_PCM_IRQSTAT_RXALMSTEMPT\t(0x1 << 4)\n#define S3C_PCM_IRQSTAT_RXFULL\t\t(0x1 << 3)\n#define S3C_PCM_IRQSTAT_RXALMSTFULL\t(0x1 << 2)\n#define S3C_PCM_IRQSTAT_RXSTARV\t\t(0x1 << 1)\n#define S3C_PCM_IRQSTAT_RXERROVRFL\t(0x1 << 0)\n\n \n#define S3C_PCM_FIFOSTAT_TXCNT_MSK\t\t(0x3f << 14)\n#define S3C_PCM_FIFOSTAT_TXFIFOEMPTY\t\t(0x1 << 13)\n#define S3C_PCM_FIFOSTAT_TXFIFOALMSTEMPTY\t(0x1 << 12)\n#define S3C_PCM_FIFOSTAT_TXFIFOFULL\t\t(0x1 << 11)\n#define S3C_PCM_FIFOSTAT_TXFIFOALMSTFULL\t(0x1 << 10)\n#define S3C_PCM_FIFOSTAT_RXCNT_MSK\t\t(0x3f << 4)\n#define S3C_PCM_FIFOSTAT_RXFIFOEMPTY\t\t(0x1 << 3)\n#define S3C_PCM_FIFOSTAT_RXFIFOALMSTEMPTY\t(0x1 << 2)\n#define S3C_PCM_FIFOSTAT_RXFIFOFULL\t\t(0x1 << 1)\n#define S3C_PCM_FIFOSTAT_RXFIFOALMSTFULL\t(0x1 << 0)\n\n \nstruct s3c_pcm_info {\n\tspinlock_t lock;\n\tstruct device\t*dev;\n\tvoid __iomem\t*regs;\n\n\tunsigned int sclk_per_fs;\n\n\t \n\tunsigned int idleclk;\n\n\tstruct clk\t*pclk;\n\tstruct clk\t*cclk;\n\n\tstruct snd_dmaengine_dai_dma_data *dma_playback;\n\tstruct snd_dmaengine_dai_dma_data *dma_capture;\n};\n\nstatic struct snd_dmaengine_dai_dma_data s3c_pcm_stereo_out[] = {\n\t[0] = {\n\t\t.addr_width\t= 4,\n\t},\n\t[1] = {\n\t\t.addr_width\t= 4,\n\t},\n};\n\nstatic struct snd_dmaengine_dai_dma_data s3c_pcm_stereo_in[] = {\n\t[0] = {\n\t\t.addr_width\t= 4,\n\t},\n\t[1] = {\n\t\t.addr_width\t= 4,\n\t},\n};\n\nstatic struct s3c_pcm_info s3c_pcm[2];\n\nstatic void s3c_pcm_snd_txctrl(struct s3c_pcm_info *pcm, int on)\n{\n\tvoid __iomem *regs = pcm->regs;\n\tu32 ctl, clkctl;\n\n\tclkctl = readl(regs + S3C_PCM_CLKCTL);\n\tctl = readl(regs + S3C_PCM_CTL);\n\tctl &= ~(S3C_PCM_CTL_TXDIPSTICK_MASK\n\t\t\t << S3C_PCM_CTL_TXDIPSTICK_SHIFT);\n\n\tif (on) {\n\t\tctl |= S3C_PCM_CTL_TXDMA_EN;\n\t\tctl |= S3C_PCM_CTL_TXFIFO_EN;\n\t\tctl |= S3C_PCM_CTL_ENABLE;\n\t\tctl |= (0x4<<S3C_PCM_CTL_TXDIPSTICK_SHIFT);\n\t\tclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\n\t} else {\n\t\tctl &= ~S3C_PCM_CTL_TXDMA_EN;\n\t\tctl &= ~S3C_PCM_CTL_TXFIFO_EN;\n\n\t\tif (!(ctl & S3C_PCM_CTL_RXFIFO_EN)) {\n\t\t\tctl &= ~S3C_PCM_CTL_ENABLE;\n\t\t\tif (!pcm->idleclk)\n\t\t\t\tclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\n\t\t}\n\t}\n\n\twritel(clkctl, regs + S3C_PCM_CLKCTL);\n\twritel(ctl, regs + S3C_PCM_CTL);\n}\n\nstatic void s3c_pcm_snd_rxctrl(struct s3c_pcm_info *pcm, int on)\n{\n\tvoid __iomem *regs = pcm->regs;\n\tu32 ctl, clkctl;\n\n\tctl = readl(regs + S3C_PCM_CTL);\n\tclkctl = readl(regs + S3C_PCM_CLKCTL);\n\tctl &= ~(S3C_PCM_CTL_RXDIPSTICK_MASK\n\t\t\t << S3C_PCM_CTL_RXDIPSTICK_SHIFT);\n\n\tif (on) {\n\t\tctl |= S3C_PCM_CTL_RXDMA_EN;\n\t\tctl |= S3C_PCM_CTL_RXFIFO_EN;\n\t\tctl |= S3C_PCM_CTL_ENABLE;\n\t\tctl |= (0x20<<S3C_PCM_CTL_RXDIPSTICK_SHIFT);\n\t\tclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\n\t} else {\n\t\tctl &= ~S3C_PCM_CTL_RXDMA_EN;\n\t\tctl &= ~S3C_PCM_CTL_RXFIFO_EN;\n\n\t\tif (!(ctl & S3C_PCM_CTL_TXFIFO_EN)) {\n\t\t\tctl &= ~S3C_PCM_CTL_ENABLE;\n\t\t\tif (!pcm->idleclk)\n\t\t\t\tclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\n\t\t}\n\t}\n\n\twritel(clkctl, regs + S3C_PCM_CLKCTL);\n\twritel(ctl, regs + S3C_PCM_CTL);\n}\n\nstatic int s3c_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned long flags;\n\n\tdev_dbg(pcm->dev, \"Entered %s\\n\", __func__);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&pcm->lock, flags);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\ts3c_pcm_snd_rxctrl(pcm, 1);\n\t\telse\n\t\t\ts3c_pcm_snd_txctrl(pcm, 1);\n\n\t\tspin_unlock_irqrestore(&pcm->lock, flags);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&pcm->lock, flags);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\ts3c_pcm_snd_rxctrl(pcm, 0);\n\t\telse\n\t\t\ts3c_pcm_snd_txctrl(pcm, 0);\n\n\t\tspin_unlock_irqrestore(&pcm->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *socdai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tvoid __iomem *regs = pcm->regs;\n\tstruct clk *clk;\n\tint sclk_div, sync_div;\n\tunsigned long flags;\n\tu32 clkctl;\n\n\tdev_dbg(pcm->dev, \"Entered %s\\n\", __func__);\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&pcm->lock, flags);\n\n\t \n\tclkctl = readl(regs + S3C_PCM_CLKCTL);\n\tif (clkctl & S3C_PCM_CLKCTL_SERCLKSEL_PCLK)\n\t\tclk = pcm->pclk;\n\telse\n\t\tclk = pcm->cclk;\n\n\t \n\tsclk_div = clk_get_rate(clk) / pcm->sclk_per_fs /\n\t\t\t\t\tparams_rate(params) / 2 - 1;\n\n\tclkctl &= ~(S3C_PCM_CLKCTL_SCLKDIV_MASK\n\t\t\t<< S3C_PCM_CLKCTL_SCLKDIV_SHIFT);\n\tclkctl |= ((sclk_div & S3C_PCM_CLKCTL_SCLKDIV_MASK)\n\t\t\t<< S3C_PCM_CLKCTL_SCLKDIV_SHIFT);\n\n\t \n\tsync_div = pcm->sclk_per_fs - 1;\n\n\tclkctl &= ~(S3C_PCM_CLKCTL_SYNCDIV_MASK\n\t\t\t\t<< S3C_PCM_CLKCTL_SYNCDIV_SHIFT);\n\tclkctl |= ((sync_div & S3C_PCM_CLKCTL_SYNCDIV_MASK)\n\t\t\t\t<< S3C_PCM_CLKCTL_SYNCDIV_SHIFT);\n\n\twritel(clkctl, regs + S3C_PCM_CLKCTL);\n\n\tspin_unlock_irqrestore(&pcm->lock, flags);\n\n\tdev_dbg(pcm->dev, \"PCMSOURCE_CLK-%lu SCLK=%ufs SCLK_DIV=%d SYNC_DIV=%d\\n\",\n\t\t\t\tclk_get_rate(clk), pcm->sclk_per_fs,\n\t\t\t\tsclk_div, sync_div);\n\n\treturn 0;\n}\n\nstatic int s3c_pcm_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\n\tvoid __iomem *regs = pcm->regs;\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 ctl;\n\n\tdev_dbg(pcm->dev, \"Entered %s\\n\", __func__);\n\n\tspin_lock_irqsave(&pcm->lock, flags);\n\n\tctl = readl(regs + S3C_PCM_CTL);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcm->dev, \"Unsupported clock inversion!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcm->dev, \"Unsupported master/slave format!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\n\tcase SND_SOC_DAIFMT_CONT:\n\t\tpcm->idleclk = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_GATED:\n\t\tpcm->idleclk = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcm->dev, \"Invalid Clock gating request!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctl |= S3C_PCM_CTL_TXMSB_AFTER_FSYNC;\n\t\tctl |= S3C_PCM_CTL_RXMSB_AFTER_FSYNC;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctl &= ~S3C_PCM_CTL_TXMSB_AFTER_FSYNC;\n\t\tctl &= ~S3C_PCM_CTL_RXMSB_AFTER_FSYNC;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcm->dev, \"Unsupported data format!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\twritel(ctl, regs + S3C_PCM_CTL);\n\nexit:\n\tspin_unlock_irqrestore(&pcm->lock, flags);\n\n\treturn ret;\n}\n\nstatic int s3c_pcm_set_clkdiv(struct snd_soc_dai *cpu_dai,\n\t\t\t\t\t\tint div_id, int div)\n{\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tswitch (div_id) {\n\tcase S3C_PCM_SCLK_PER_FS:\n\t\tpcm->sclk_per_fs = div;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c_pcm_set_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\n\tvoid __iomem *regs = pcm->regs;\n\tu32 clkctl = readl(regs + S3C_PCM_CLKCTL);\n\n\tswitch (clk_id) {\n\tcase S3C_PCM_CLKSRC_PCLK:\n\t\tclkctl |= S3C_PCM_CLKCTL_SERCLKSEL_PCLK;\n\t\tbreak;\n\n\tcase S3C_PCM_CLKSRC_MUX:\n\t\tclkctl &= ~S3C_PCM_CLKCTL_SERCLKSEL_PCLK;\n\n\t\tif (clk_get_rate(pcm->cclk) != freq)\n\t\t\tclk_set_rate(pcm->cclk, freq);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel(clkctl, regs + S3C_PCM_CLKCTL);\n\n\treturn 0;\n}\n\nstatic int s3c_pcm_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, pcm->dma_playback, pcm->dma_capture);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops s3c_pcm_dai_ops = {\n\t.probe\t\t= s3c_pcm_dai_probe,\n\t.set_sysclk\t= s3c_pcm_set_sysclk,\n\t.set_clkdiv\t= s3c_pcm_set_clkdiv,\n\t.trigger\t= s3c_pcm_trigger,\n\t.hw_params\t= s3c_pcm_hw_params,\n\t.set_fmt\t= s3c_pcm_set_fmt,\n};\n\n#define S3C_PCM_RATES  SNDRV_PCM_RATE_8000_96000\n\n#define S3C_PCM_DAI_DECLARE\t\t\t\\\n\t.symmetric_rate = 1,\t\t\t\t\t\\\n\t.ops = &s3c_pcm_dai_ops,\t\t\t\t\\\n\t.playback = {\t\t\t\t\t\t\\\n\t\t.channels_min\t= 2,\t\t\t\t\\\n\t\t.channels_max\t= 2,\t\t\t\t\\\n\t\t.rates\t\t= S3C_PCM_RATES,\t\t\\\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE,\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.capture = {\t\t\t\t\t\t\\\n\t\t.channels_min\t= 2,\t\t\t\t\\\n\t\t.channels_max\t= 2,\t\t\t\t\\\n\t\t.rates\t\t= S3C_PCM_RATES,\t\t\\\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE,\t\\\n\t}\n\nstatic struct snd_soc_dai_driver s3c_pcm_dai[] = {\n\t[0] = {\n\t\t.name\t= \"samsung-pcm.0\",\n\t\tS3C_PCM_DAI_DECLARE,\n\t},\n\t[1] = {\n\t\t.name\t= \"samsung-pcm.1\",\n\t\tS3C_PCM_DAI_DECLARE,\n\t},\n};\n\nstatic const struct snd_soc_component_driver s3c_pcm_component = {\n\t.name\t\t\t= \"s3c-pcm\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int s3c_pcm_dev_probe(struct platform_device *pdev)\n{\n\tstruct s3c_pcm_info *pcm;\n\tstruct resource *mem_res;\n\tstruct s3c_audio_pdata *pcm_pdata;\n\tdma_filter_fn filter;\n\tint ret;\n\n\t \n\tif ((pdev->id < 0) || pdev->id >= ARRAY_SIZE(s3c_pcm)) {\n\t\tdev_err(&pdev->dev, \"id %d out of range\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\n\tpcm_pdata = pdev->dev.platform_data;\n\n\tif (pcm_pdata && pcm_pdata->cfg_gpio && pcm_pdata->cfg_gpio(pdev)) {\n\t\tdev_err(&pdev->dev, \"Unable to configure gpio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcm = &s3c_pcm[pdev->id];\n\tpcm->dev = &pdev->dev;\n\n\tspin_lock_init(&pcm->lock);\n\n\t \n\tpcm->sclk_per_fs = 128;\n\n\tpcm->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);\n\tif (IS_ERR(pcm->regs))\n\t\treturn PTR_ERR(pcm->regs);\n\n\tpcm->cclk = devm_clk_get(&pdev->dev, \"audio-bus\");\n\tif (IS_ERR(pcm->cclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get audio-bus clock\\n\");\n\t\treturn PTR_ERR(pcm->cclk);\n\t}\n\tret = clk_prepare_enable(pcm->cclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_set_drvdata(&pdev->dev, pcm);\n\n\tpcm->pclk = devm_clk_get(&pdev->dev, \"pcm\");\n\tif (IS_ERR(pcm->pclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get pcm clock\\n\");\n\t\tret = PTR_ERR(pcm->pclk);\n\t\tgoto err_dis_cclk;\n\t}\n\tret = clk_prepare_enable(pcm->pclk);\n\tif (ret)\n\t\tgoto err_dis_cclk;\n\n\ts3c_pcm_stereo_in[pdev->id].addr = mem_res->start + S3C_PCM_RXFIFO;\n\ts3c_pcm_stereo_out[pdev->id].addr = mem_res->start + S3C_PCM_TXFIFO;\n\n\tfilter = NULL;\n\tif (pcm_pdata) {\n\t\ts3c_pcm_stereo_in[pdev->id].filter_data = pcm_pdata->dma_capture;\n\t\ts3c_pcm_stereo_out[pdev->id].filter_data = pcm_pdata->dma_playback;\n\t\tfilter = pcm_pdata->dma_filter;\n\t}\n\n\tpcm->dma_capture = &s3c_pcm_stereo_in[pdev->id];\n\tpcm->dma_playback = &s3c_pcm_stereo_out[pdev->id];\n\n\tret = samsung_asoc_dma_platform_register(&pdev->dev, filter,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get register DMA: %d\\n\", ret);\n\t\tgoto err_dis_pclk;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &s3c_pcm_component,\n\t\t\t\t\t &s3c_pcm_dai[pdev->id], 1);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"failed to get register DAI: %d\\n\", ret);\n\t\tgoto err_dis_pm;\n\t}\n\n\treturn 0;\n\nerr_dis_pm:\n\tpm_runtime_disable(&pdev->dev);\nerr_dis_pclk:\n\tclk_disable_unprepare(pcm->pclk);\nerr_dis_cclk:\n\tclk_disable_unprepare(pcm->cclk);\n\treturn ret;\n}\n\nstatic void s3c_pcm_dev_remove(struct platform_device *pdev)\n{\n\tstruct s3c_pcm_info *pcm = &s3c_pcm[pdev->id];\n\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(pcm->cclk);\n\tclk_disable_unprepare(pcm->pclk);\n}\n\nstatic struct platform_driver s3c_pcm_driver = {\n\t.probe  = s3c_pcm_dev_probe,\n\t.remove_new = s3c_pcm_dev_remove,\n\t.driver = {\n\t\t.name = \"samsung-pcm\",\n\t},\n};\n\nmodule_platform_driver(s3c_pcm_driver);\n\n \nMODULE_AUTHOR(\"Jaswinder Singh, <jassisinghbrar@gmail.com>\");\nMODULE_DESCRIPTION(\"S3C PCM Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:samsung-pcm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}