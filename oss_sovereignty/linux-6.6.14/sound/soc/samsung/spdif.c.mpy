{
  "module_name": "spdif.c",
  "hash_id": "eb859433f23c7abf71a3596074303fd9e63a660ee11e133874a057a2cf8a522f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/spdif.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#include <linux/platform_data/asoc-s3c.h>\n\n#include \"dma.h\"\n#include \"spdif.h\"\n\n \n#define CLKCON\t\t\t\t0x00\n#define CON\t\t\t\t0x04\n#define BSTAS\t\t\t\t0x08\n#define CSTAS\t\t\t\t0x0C\n#define DATA_OUTBUF\t\t\t0x10\n#define DCNT\t\t\t\t0x14\n#define BSTAS_S\t\t\t\t0x18\n#define DCNT_S\t\t\t\t0x1C\n\n#define CLKCTL_MASK\t\t\t0x7\n#define CLKCTL_MCLK_EXT\t\t\t(0x1 << 2)\n#define CLKCTL_PWR_ON\t\t\t(0x1 << 0)\n\n#define CON_MASK\t\t\t0x3ffffff\n#define CON_FIFO_TH_SHIFT\t\t19\n#define CON_FIFO_TH_MASK\t\t(0x7 << 19)\n#define CON_USERDATA_23RDBIT\t\t(0x1 << 12)\n\n#define CON_SW_RESET\t\t\t(0x1 << 5)\n\n#define CON_MCLKDIV_MASK\t\t(0x3 << 3)\n#define CON_MCLKDIV_256FS\t\t(0x0 << 3)\n#define CON_MCLKDIV_384FS\t\t(0x1 << 3)\n#define CON_MCLKDIV_512FS\t\t(0x2 << 3)\n\n#define CON_PCM_MASK\t\t\t(0x3 << 1)\n#define CON_PCM_16BIT\t\t\t(0x0 << 1)\n#define CON_PCM_20BIT\t\t\t(0x1 << 1)\n#define CON_PCM_24BIT\t\t\t(0x2 << 1)\n\n#define CON_PCM_DATA\t\t\t(0x1 << 0)\n\n#define CSTAS_MASK\t\t\t0x3fffffff\n#define CSTAS_SAMP_FREQ_MASK\t\t(0xF << 24)\n#define CSTAS_SAMP_FREQ_44\t\t(0x0 << 24)\n#define CSTAS_SAMP_FREQ_48\t\t(0x2 << 24)\n#define CSTAS_SAMP_FREQ_32\t\t(0x3 << 24)\n#define CSTAS_SAMP_FREQ_96\t\t(0xA << 24)\n\n#define CSTAS_CATEGORY_MASK\t\t(0xFF << 8)\n#define CSTAS_CATEGORY_CODE_CDP\t\t(0x01 << 8)\n\n#define CSTAS_NO_COPYRIGHT\t\t(0x1 << 2)\n\n \nstruct samsung_spdif_info {\n\tspinlock_t\tlock;\n\tstruct device\t*dev;\n\tvoid __iomem\t*regs;\n\tunsigned long\tclk_rate;\n\tstruct clk\t*pclk;\n\tstruct clk\t*sclk;\n\tu32\t\tsaved_clkcon;\n\tu32\t\tsaved_con;\n\tu32\t\tsaved_cstas;\n\tstruct snd_dmaengine_dai_dma_data *dma_playback;\n};\n\nstatic struct snd_dmaengine_dai_dma_data spdif_stereo_out;\nstatic struct samsung_spdif_info spdif_info;\n\nstatic inline struct samsung_spdif_info\n*component_to_info(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_get_drvdata(component);\n}\n\nstatic inline struct samsung_spdif_info *to_info(struct snd_soc_dai *cpu_dai)\n{\n\treturn snd_soc_dai_get_drvdata(cpu_dai);\n}\n\nstatic void spdif_snd_txctrl(struct samsung_spdif_info *spdif, int on)\n{\n\tvoid __iomem *regs = spdif->regs;\n\tu32 clkcon;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\n\tif (on)\n\t\twritel(clkcon | CLKCTL_PWR_ON, regs + CLKCON);\n\telse\n\t\twritel(clkcon & ~CLKCTL_PWR_ON, regs + CLKCON);\n}\n\nstatic int spdif_set_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct samsung_spdif_info *spdif = to_info(cpu_dai);\n\tu32 clkcon;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tclkcon = readl(spdif->regs + CLKCON);\n\n\tif (clk_id == SND_SOC_SPDIF_INT_MCLK)\n\t\tclkcon &= ~CLKCTL_MCLK_EXT;\n\telse\n\t\tclkcon |= CLKCTL_MCLK_EXT;\n\n\twritel(clkcon, spdif->regs + CLKCON);\n\n\tspdif->clk_rate = freq;\n\n\treturn 0;\n}\n\nstatic int spdif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct samsung_spdif_info *spdif = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned long flags;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&spdif->lock, flags);\n\t\tspdif_snd_txctrl(spdif, 1);\n\t\tspin_unlock_irqrestore(&spdif->lock, flags);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&spdif->lock, flags);\n\t\tspdif_snd_txctrl(spdif, 0);\n\t\tspin_unlock_irqrestore(&spdif->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int spdif_sysclk_ratios[] = {\n\t512, 384, 256,\n};\n\nstatic int spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *socdai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct samsung_spdif_info *spdif = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tvoid __iomem *regs = spdif->regs;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tu32 con, clkcon, cstas;\n\tunsigned long flags;\n\tint i, ratio;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_data = spdif->dma_playback;\n\telse {\n\t\tdev_err(spdif->dev, \"Capture is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_dai_set_dma_data(asoc_rtd_to_cpu(rtd, 0), substream, dma_data);\n\n\tspin_lock_irqsave(&spdif->lock, flags);\n\n\tcon = readl(regs + CON) & CON_MASK;\n\tcstas = readl(regs + CSTAS) & CSTAS_MASK;\n\tclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\n\n\tcon &= ~CON_FIFO_TH_MASK;\n\tcon |= (0x7 << CON_FIFO_TH_SHIFT);\n\tcon |= CON_USERDATA_23RDBIT;\n\tcon |= CON_PCM_DATA;\n\n\tcon &= ~CON_PCM_MASK;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tcon |= CON_PCM_16BIT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(spdif->dev, \"Unsupported data size.\\n\");\n\t\tgoto err;\n\t}\n\n\tratio = spdif->clk_rate / params_rate(params);\n\tfor (i = 0; i < ARRAY_SIZE(spdif_sysclk_ratios); i++)\n\t\tif (ratio == spdif_sysclk_ratios[i])\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(spdif_sysclk_ratios)) {\n\t\tdev_err(spdif->dev, \"Invalid clock ratio %ld/%d\\n\",\n\t\t\t\tspdif->clk_rate, params_rate(params));\n\t\tgoto err;\n\t}\n\n\tcon &= ~CON_MCLKDIV_MASK;\n\tswitch (ratio) {\n\tcase 256:\n\t\tcon |= CON_MCLKDIV_256FS;\n\t\tbreak;\n\tcase 384:\n\t\tcon |= CON_MCLKDIV_384FS;\n\t\tbreak;\n\tcase 512:\n\t\tcon |= CON_MCLKDIV_512FS;\n\t\tbreak;\n\t}\n\n\tcstas &= ~CSTAS_SAMP_FREQ_MASK;\n\tswitch (params_rate(params)) {\n\tcase 44100:\n\t\tcstas |= CSTAS_SAMP_FREQ_44;\n\t\tbreak;\n\tcase 48000:\n\t\tcstas |= CSTAS_SAMP_FREQ_48;\n\t\tbreak;\n\tcase 32000:\n\t\tcstas |= CSTAS_SAMP_FREQ_32;\n\t\tbreak;\n\tcase 96000:\n\t\tcstas |= CSTAS_SAMP_FREQ_96;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(spdif->dev, \"Invalid sampling rate %d\\n\",\n\t\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\n\tcstas &= ~CSTAS_CATEGORY_MASK;\n\tcstas |= CSTAS_CATEGORY_CODE_CDP;\n\tcstas |= CSTAS_NO_COPYRIGHT;\n\n\twritel(con, regs + CON);\n\twritel(cstas, regs + CSTAS);\n\twritel(clkcon, regs + CLKCON);\n\n\tspin_unlock_irqrestore(&spdif->lock, flags);\n\n\treturn 0;\nerr:\n\tspin_unlock_irqrestore(&spdif->lock, flags);\n\treturn -EINVAL;\n}\n\nstatic void spdif_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct samsung_spdif_info *spdif = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tvoid __iomem *regs = spdif->regs;\n\tu32 con, clkcon;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tcon = readl(regs + CON) & CON_MASK;\n\tclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\n\n\twritel(con | CON_SW_RESET, regs + CON);\n\tcpu_relax();\n\n\twritel(clkcon & ~CLKCTL_PWR_ON, regs + CLKCON);\n}\n\n#ifdef CONFIG_PM\nstatic int spdif_suspend(struct snd_soc_component *component)\n{\n\tstruct samsung_spdif_info *spdif = component_to_info(component);\n\tu32 con = spdif->saved_con;\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\tspdif->saved_clkcon = readl(spdif->regs\t+ CLKCON) & CLKCTL_MASK;\n\tspdif->saved_con = readl(spdif->regs + CON) & CON_MASK;\n\tspdif->saved_cstas = readl(spdif->regs + CSTAS) & CSTAS_MASK;\n\n\twritel(con | CON_SW_RESET, spdif->regs + CON);\n\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic int spdif_resume(struct snd_soc_component *component)\n{\n\tstruct samsung_spdif_info *spdif = component_to_info(component);\n\n\tdev_dbg(spdif->dev, \"Entered %s\\n\", __func__);\n\n\twritel(spdif->saved_clkcon, spdif->regs\t+ CLKCON);\n\twritel(spdif->saved_con, spdif->regs + CON);\n\twritel(spdif->saved_cstas, spdif->regs + CSTAS);\n\n\treturn 0;\n}\n#else\n#define spdif_suspend NULL\n#define spdif_resume NULL\n#endif\n\nstatic const struct snd_soc_dai_ops spdif_dai_ops = {\n\t.set_sysclk\t= spdif_set_sysclk,\n\t.trigger\t= spdif_trigger,\n\t.hw_params\t= spdif_hw_params,\n\t.shutdown\t= spdif_shutdown,\n};\n\nstatic struct snd_soc_dai_driver samsung_spdif_dai = {\n\t.name = \"samsung-spdif\",\n\t.playback = {\n\t\t.stream_name = \"S/PDIF Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = (SNDRV_PCM_RATE_32000 |\n\t\t\t\tSNDRV_PCM_RATE_44100 |\n\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\tSNDRV_PCM_RATE_96000),\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE, },\n\t.ops = &spdif_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver samsung_spdif_component = {\n\t.name\t\t\t= \"samsung-spdif\",\n\t.suspend\t\t= spdif_suspend,\n\t.resume\t\t\t= spdif_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int spdif_probe(struct platform_device *pdev)\n{\n\tstruct s3c_audio_pdata *spdif_pdata;\n\tstruct resource *mem_res;\n\tstruct samsung_spdif_info *spdif;\n\tdma_filter_fn filter;\n\tint ret;\n\n\tspdif_pdata = pdev->dev.platform_data;\n\n\tdev_dbg(&pdev->dev, \"Entered %s\\n\", __func__);\n\n\tmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem_res) {\n\t\tdev_err(&pdev->dev, \"Unable to get register resource.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (spdif_pdata && spdif_pdata->cfg_gpio\n\t\t\t&& spdif_pdata->cfg_gpio(pdev)) {\n\t\tdev_err(&pdev->dev, \"Unable to configure GPIO pins\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspdif = &spdif_info;\n\tspdif->dev = &pdev->dev;\n\n\tspin_lock_init(&spdif->lock);\n\n\tspdif->pclk = devm_clk_get(&pdev->dev, \"spdif\");\n\tif (IS_ERR(spdif->pclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get peri-clock\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err0;\n\t}\n\tret = clk_prepare_enable(spdif->pclk);\n\tif (ret)\n\t\tgoto err0;\n\n\tspdif->sclk = devm_clk_get(&pdev->dev, \"sclk_spdif\");\n\tif (IS_ERR(spdif->sclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get internal source clock\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err1;\n\t}\n\tret = clk_prepare_enable(spdif->sclk);\n\tif (ret)\n\t\tgoto err1;\n\n\t \n\tif (!request_mem_region(mem_res->start,\n\t\t\t\tresource_size(mem_res), \"samsung-spdif\")) {\n\t\tdev_err(&pdev->dev, \"Unable to request register region\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err2;\n\t}\n\n\tspdif->regs = ioremap(mem_res->start, 0x100);\n\tif (spdif->regs == NULL) {\n\t\tdev_err(&pdev->dev, \"Cannot ioremap registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err3;\n\t}\n\n\tspdif_stereo_out.addr_width = 2;\n\tspdif_stereo_out.addr = mem_res->start + DATA_OUTBUF;\n\tfilter = NULL;\n\tif (spdif_pdata) {\n\t\tspdif_stereo_out.filter_data = spdif_pdata->dma_playback;\n\t\tfilter = spdif_pdata->dma_filter;\n\t}\n\tspdif->dma_playback = &spdif_stereo_out;\n\n\tret = samsung_asoc_dma_platform_register(&pdev->dev, filter,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register DMA: %d\\n\", ret);\n\t\tgoto err4;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, spdif);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&samsung_spdif_component, &samsung_spdif_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"fail to register dai\\n\");\n\t\tgoto err4;\n\t}\n\n\treturn 0;\nerr4:\n\tiounmap(spdif->regs);\nerr3:\n\trelease_mem_region(mem_res->start, resource_size(mem_res));\nerr2:\n\tclk_disable_unprepare(spdif->sclk);\nerr1:\n\tclk_disable_unprepare(spdif->pclk);\nerr0:\n\treturn ret;\n}\n\nstatic void spdif_remove(struct platform_device *pdev)\n{\n\tstruct samsung_spdif_info *spdif = &spdif_info;\n\tstruct resource *mem_res;\n\n\tiounmap(spdif->regs);\n\n\tmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(mem_res->start, resource_size(mem_res));\n\n\tclk_disable_unprepare(spdif->sclk);\n\tclk_disable_unprepare(spdif->pclk);\n}\n\nstatic struct platform_driver samsung_spdif_driver = {\n\t.probe\t= spdif_probe,\n\t.remove_new = spdif_remove,\n\t.driver\t= {\n\t\t.name\t= \"samsung-spdif\",\n\t},\n};\n\nmodule_platform_driver(samsung_spdif_driver);\n\nMODULE_AUTHOR(\"Seungwhan Youn, <sw.youn@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S/PDIF Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:samsung-spdif\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}