{
  "module_name": "tm2_wm5110.c",
  "hash_id": "014dcaab853b52480788e7c7557cace9f5f06b64e725dd5a60ca1ddf160a0f59",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/tm2_wm5110.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"i2s.h\"\n#include \"../codecs/wm5110.h\"\n\n \n#define MCLK_RATE\t24000000U\n\n#define TM2_DAI_AIF1\t0\n#define TM2_DAI_AIF2\t1\n\nstruct tm2_machine_priv {\n\tstruct snd_soc_component *component;\n\tunsigned int sysclk_rate;\n\tstruct gpio_desc *gpio_mic_bias;\n};\n\nstatic int tm2_start_sysclk(struct snd_soc_card *card)\n{\n\tstruct tm2_machine_priv *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_component *component = priv->component;\n\tint ret;\n\n\tret = snd_soc_component_set_pll(component, WM5110_FLL1_REFCLK,\n\t\t\t\t    ARIZONA_FLL_SRC_MCLK1,\n\t\t\t\t    MCLK_RATE,\n\t\t\t\t    priv->sysclk_rate);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set FLL1 source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_pll(component, WM5110_FLL1,\n\t\t\t\t    ARIZONA_FLL_SRC_MCLK1,\n\t\t\t\t    MCLK_RATE,\n\t\t\t\t    priv->sysclk_rate);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to start FLL1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_sysclk(component, ARIZONA_CLK_SYSCLK,\n\t\t\t\t       ARIZONA_CLK_SRC_FLL1,\n\t\t\t\t       priv->sysclk_rate,\n\t\t\t\t       SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set SYSCLK source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tm2_stop_sysclk(struct snd_soc_card *card)\n{\n\tstruct tm2_machine_priv *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_component *component = priv->component;\n\tint ret;\n\n\tret = snd_soc_component_set_pll(component, WM5110_FLL1, 0, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to stop FLL1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_sysclk(component, ARIZONA_CLK_SYSCLK,\n\t\t\t\t       ARIZONA_CLK_SRC_FLL1, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to stop SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tm2_aif1_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\tstruct tm2_machine_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\n\tswitch (params_rate(params)) {\n\tcase 4000:\n\tcase 8000:\n\tcase 12000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\tcase 96000:\n\tcase 192000:\n\t\t \n\t\tpriv->sysclk_rate = 147456000U;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\tcase 176400:\n\t\t \n\t\tpriv->sysclk_rate = 135475200U;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Not supported sample rate: %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\treturn tm2_start_sysclk(rtd->card);\n}\n\nstatic const struct snd_soc_ops tm2_aif1_ops = {\n\t.hw_params = tm2_aif1_hw_params,\n};\n\nstatic int tm2_aif2_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\tunsigned int asyncclk_rate;\n\tint ret;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\tcase 12000:\n\tcase 16000:\n\t\t \n\t\tasyncclk_rate = 49152000U;\n\t\tbreak;\n\tcase 11025:\n\t\t \n\t\tasyncclk_rate = 45158400U;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Not supported sample rate: %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_set_pll(component, WM5110_FLL2_REFCLK,\n\t\t\t\t    ARIZONA_FLL_SRC_MCLK1,\n\t\t\t\t    MCLK_RATE,\n\t\t\t\t    asyncclk_rate);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set FLL2 source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_pll(component, WM5110_FLL2,\n\t\t\t\t    ARIZONA_FLL_SRC_MCLK1,\n\t\t\t\t    MCLK_RATE,\n\t\t\t\t    asyncclk_rate);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to start FLL2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_set_sysclk(component, ARIZONA_CLK_ASYNCCLK,\n\t\t\t\t       ARIZONA_CLK_SRC_FLL2,\n\t\t\t\t       asyncclk_rate,\n\t\t\t\t       SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set ASYNCCLK source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tm2_aif2_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\tint ret;\n\n\t \n\tret = snd_soc_component_set_pll(component, WM5110_FLL2, ARIZONA_FLL_SRC_MCLK1,\n\t\t\t\t    0, 0);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"Failed to stop FLL2: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops tm2_aif2_ops = {\n\t.hw_params = tm2_aif2_hw_params,\n\t.hw_free = tm2_aif2_hw_free,\n};\n\nstatic int tm2_hdmi_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tunsigned int bfs;\n\tint bitwidth, ret;\n\n\tbitwidth = snd_pcm_format_width(params_format(params));\n\tif (bitwidth < 0) {\n\t\tdev_err(rtd->card->dev, \"Invalid bit-width: %d\\n\", bitwidth);\n\t\treturn bitwidth;\n\t}\n\n\tswitch (bitwidth) {\n\tcase 48:\n\t\tbfs = 64;\n\t\tbreak;\n\tcase 16:\n\t\tbfs = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->card->dev, \"Unsupported bit-width: %d\\n\", bitwidth);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 48000:\n\tcase 96000:\n\tcase 192000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->card->dev, \"Unsupported sample rate: %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, SAMSUNG_I2S_OPCLK,\n\t\t\t\t\t0, SAMSUNG_I2S_OPCLK_PCLK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_clkdiv(cpu_dai, SAMSUNG_I2S_DIV_BCLK, bfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops tm2_hdmi_ops = {\n\t.hw_params = tm2_hdmi_hw_params,\n};\n\nstatic int tm2_mic_bias(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct tm2_machine_priv *priv = snd_soc_card_get_drvdata(card);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tgpiod_set_value_cansleep(priv->gpio_mic_bias,  1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tgpiod_set_value_cansleep(priv->gpio_mic_bias,  0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tm2_set_bias_level(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_dapm_context *dapm,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);\n\n\tif (dapm->dev != asoc_rtd_to_codec(rtd, 0)->dev)\n\t\treturn 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (card->dapm.bias_level == SND_SOC_BIAS_OFF)\n\t\t\ttm2_start_sysclk(card);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\ttm2_stop_sysclk(card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_aux_dev tm2_speaker_amp_dev;\n\nstatic int tm2_late_probe(struct snd_soc_card *card)\n{\n\tstruct tm2_machine_priv *priv = snd_soc_card_get_drvdata(card);\n\tunsigned int ch_map[] = { 0, 1 };\n\tstruct snd_soc_dai *amp_pdm_dai;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *aif1_dai;\n\tstruct snd_soc_dai *aif2_dai;\n\tint ret;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[TM2_DAI_AIF1]);\n\taif1_dai = asoc_rtd_to_codec(rtd, 0);\n\tpriv->component = asoc_rtd_to_codec(rtd, 0)->component;\n\n\tret = snd_soc_dai_set_sysclk(aif1_dai, ARIZONA_CLK_SYSCLK, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(aif1_dai->dev, \"Failed to set SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[TM2_DAI_AIF2]);\n\taif2_dai = asoc_rtd_to_codec(rtd, 0);\n\n\tret = snd_soc_dai_set_sysclk(aif2_dai, ARIZONA_CLK_ASYNCCLK, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(aif2_dai->dev, \"Failed to set ASYNCCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tamp_pdm_dai = snd_soc_find_dai(&tm2_speaker_amp_dev.dlc);\n\tif (!amp_pdm_dai)\n\t\treturn -ENODEV;\n\n\t \n\tret = snd_soc_dai_set_channel_map(amp_pdm_dai, ARRAY_SIZE(ch_map),\n\t\t\t\t\t  ch_map, 0, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_tdm_slot(amp_pdm_dai, 0x3, 0x0, 2, 16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new tm2_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"HP\"),\n\tSOC_DAPM_PIN_SWITCH(\"SPK\"),\n\tSOC_DAPM_PIN_SWITCH(\"RCV\"),\n\tSOC_DAPM_PIN_SWITCH(\"VPS\"),\n\tSOC_DAPM_PIN_SWITCH(\"HDMI\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"Main Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Sub Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Third Mic\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget tm2_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"HP\", NULL),\n\tSND_SOC_DAPM_SPK(\"SPK\", NULL),\n\tSND_SOC_DAPM_SPK(\"RCV\", NULL),\n\tSND_SOC_DAPM_LINE(\"VPS\", NULL),\n\tSND_SOC_DAPM_LINE(\"HDMI\", NULL),\n\n\tSND_SOC_DAPM_MIC(\"Main Mic\", tm2_mic_bias),\n\tSND_SOC_DAPM_MIC(\"Sub Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Third Mic\", NULL),\n\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_soc_component_driver tm2_component = {\n\t.name\t= \"tm2-audio\",\n};\n\nstatic struct snd_soc_dai_driver tm2_ext_dai[] = {\n\t{\n\t\t.name = \"Voice call\",\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 48000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\n\t\t\t\t\tSNDRV_PCM_RATE_48000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 48000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\n\t\t\t\t\tSNDRV_PCM_RATE_48000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t},\n\t{\n\t\t.name = \"Bluetooth\",\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t},\n};\n\nSND_SOC_DAILINK_DEFS(aif1,\n\tDAILINK_COMP_ARRAY(COMP_CPU(SAMSUNG_I2S_DAI)),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm5110-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(voice,\n\tDAILINK_COMP_ARRAY(COMP_CPU(SAMSUNG_I2S_DAI)),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm5110-aif2\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(bt,\n\tDAILINK_COMP_ARRAY(COMP_CPU(SAMSUNG_I2S_DAI)),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm5110-aif3\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(hdmi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tm2_dai_links[] = {\n\t{\n\t\t.name\t\t= \"WM5110 AIF1\",\n\t\t.stream_name\t= \"HiFi Primary\",\n\t\t.ops\t\t= &tm2_aif1_ops,\n\t\t.dai_fmt\t= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t  SND_SOC_DAIFMT_CBM_CFM,\n\t\tSND_SOC_DAILINK_REG(aif1),\n\t}, {\n\t\t.name\t\t= \"WM5110 Voice\",\n\t\t.stream_name\t= \"Voice call\",\n\t\t.ops\t\t= &tm2_aif2_ops,\n\t\t.dai_fmt\t= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t  SND_SOC_DAIFMT_CBM_CFM,\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(voice),\n\t}, {\n\t\t.name\t\t= \"WM5110 BT\",\n\t\t.stream_name\t= \"Bluetooth\",\n\t\t.dai_fmt\t= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t  SND_SOC_DAIFMT_CBM_CFM,\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(bt),\n\t}, {\n\t\t.name\t\t= \"HDMI\",\n\t\t.stream_name\t= \"i2s1\",\n\t\t.ops\t\t= &tm2_hdmi_ops,\n\t\t.dai_fmt\t= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t  SND_SOC_DAIFMT_CBS_CFS,\n\t\tSND_SOC_DAILINK_REG(hdmi),\n\t}\n};\n\nstatic struct snd_soc_card tm2_card = {\n\t.owner\t\t\t= THIS_MODULE,\n\n\t.dai_link\t\t= tm2_dai_links,\n\t.controls\t\t= tm2_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tm2_controls),\n\t.dapm_widgets\t\t= tm2_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tm2_dapm_widgets),\n\t.aux_dev\t\t= &tm2_speaker_amp_dev,\n\t.num_aux_devs\t\t= 1,\n\n\t.late_probe\t\t= tm2_late_probe,\n\t.set_bias_level\t\t= tm2_set_bias_level,\n};\n\nstatic int tm2_probe(struct platform_device *pdev)\n{\n\tstruct device_node *cpu_dai_node[2] = {};\n\tstruct device_node *codec_dai_node[2] = {};\n\tconst char *cells_name = NULL;\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_card *card = &tm2_card;\n\tstruct tm2_machine_priv *priv;\n\tstruct snd_soc_dai_link *dai_link;\n\tint num_codecs, ret, i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\tcard->dev = dev;\n\n\tpriv->gpio_mic_bias = devm_gpiod_get(dev, \"mic-bias\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpio_mic_bias)) {\n\t\tdev_err(dev, \"Failed to get mic bias gpio\\n\");\n\t\treturn PTR_ERR(priv->gpio_mic_bias);\n\t}\n\n\tret = snd_soc_of_parse_card_name(card, \"model\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Card name is not specified\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_of_parse_audio_routing(card, \"audio-routing\");\n\tif (ret < 0) {\n\t\t \n\t\tret = snd_soc_of_parse_audio_routing(card, \"samsung,audio-routing\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Audio routing is not specified or invalid\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcard->aux_dev[0].dlc.of_node = of_parse_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"audio-amplifier\", 0);\n\tif (!card->aux_dev[0].dlc.of_node) {\n\t\tdev_err(dev, \"audio-amplifier property invalid or missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_codecs = of_count_phandle_with_args(dev->of_node, \"audio-codec\",\n\t\t\t\t\t\t NULL);\n\n\t \n\tif (num_codecs > 1) {\n\t\tcard->num_links = ARRAY_SIZE(tm2_dai_links);\n\t\tcells_name = \"#sound-dai-cells\";\n\t} else {\n\t\tcard->num_links = ARRAY_SIZE(tm2_dai_links) - 1;\n\t}\n\n\tfor (i = 0; i < num_codecs; i++) {\n\t\tstruct of_phandle_args args;\n\n\t\tret = of_parse_phandle_with_args(dev->of_node, \"i2s-controller\",\n\t\t\t\t\t\t cells_name, i, &args);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"i2s-controller property parse error: %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto dai_node_put;\n\t\t}\n\t\tcpu_dai_node[i] = args.np;\n\n\t\tcodec_dai_node[i] = of_parse_phandle(dev->of_node,\n\t\t\t\t\t\t     \"audio-codec\", i);\n\t\tif (!codec_dai_node[i]) {\n\t\t\tdev_err(dev, \"audio-codec property parse error\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto dai_node_put;\n\t\t}\n\t}\n\n\t \n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tunsigned int dai_index = 0;  \n\n\t\tdai_link->cpus->name = NULL;\n\t\tdai_link->platforms->name = NULL;\n\n\t\tif (num_codecs > 1 && i == card->num_links - 1)\n\t\t\tdai_index = 1;  \n\n\t\tdai_link->codecs->of_node = codec_dai_node[dai_index];\n\t\tdai_link->cpus->of_node = cpu_dai_node[dai_index];\n\t\tdai_link->platforms->of_node = cpu_dai_node[dai_index];\n\t}\n\n\tif (num_codecs > 1) {\n\t\tstruct of_phandle_args args;\n\n\t\t \n\t\ti = card->num_links - 1;\n\n\t\tret = of_parse_phandle_with_fixed_args(dev->of_node,\n\t\t\t\t\t\t\"audio-codec\", 0, 1, &args);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"audio-codec property parse error\\n\");\n\t\t\tgoto dai_node_put;\n\t\t}\n\n\t\tret = snd_soc_get_dai_name(&args, &card->dai_link[i].codecs->dai_name);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to get codec_dai_name\\n\");\n\t\t\tgoto dai_node_put;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &tm2_component,\n\t\t\t\ttm2_ext_dai, ARRAY_SIZE(tm2_ext_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register component: %d\\n\", ret);\n\t\tgoto dai_node_put;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"Failed to register card\\n\");\n\t\tgoto dai_node_put;\n\t}\n\ndai_node_put:\n\tfor (i = 0; i < num_codecs; i++) {\n\t\tof_node_put(codec_dai_node[i]);\n\t\tof_node_put(cpu_dai_node[i]);\n\t}\n\n\tof_node_put(card->aux_dev[0].dlc.of_node);\n\n\treturn ret;\n}\n\nstatic int tm2_pm_prepare(struct device *dev)\n{\n\tstruct snd_soc_card *card = dev_get_drvdata(dev);\n\n\treturn tm2_stop_sysclk(card);\n}\n\nstatic void tm2_pm_complete(struct device *dev)\n{\n\tstruct snd_soc_card *card = dev_get_drvdata(dev);\n\n\ttm2_start_sysclk(card);\n}\n\nstatic const struct dev_pm_ops tm2_pm_ops = {\n\t.prepare\t= tm2_pm_prepare,\n\t.suspend\t= snd_soc_suspend,\n\t.resume\t\t= snd_soc_resume,\n\t.complete\t= tm2_pm_complete,\n\t.freeze\t\t= snd_soc_suspend,\n\t.thaw\t\t= snd_soc_resume,\n\t.poweroff\t= snd_soc_poweroff,\n\t.restore\t= snd_soc_resume,\n};\n\nstatic const struct of_device_id tm2_of_match[] = {\n\t{ .compatible = \"samsung,tm2-audio\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tm2_of_match);\n\nstatic struct platform_driver tm2_driver = {\n\t.driver = {\n\t\t.name\t\t= \"tm2-audio\",\n\t\t.pm\t\t= &tm2_pm_ops,\n\t\t.of_match_table\t= tm2_of_match,\n\t},\n\t.probe\t= tm2_probe,\n};\nmodule_platform_driver(tm2_driver);\n\nMODULE_AUTHOR(\"Inha Song <ideal.song@samsung.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC Exynos TM2 Audio Support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}