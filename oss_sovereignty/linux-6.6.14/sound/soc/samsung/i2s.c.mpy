{
  "module_name": "i2s.c",
  "hash_id": "1d6df007cb17e85626ee02bb089d5f4cdb5b9723251d55bce5cda31580897dfe",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/i2s.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <dt-bindings/sound/samsung-i2s.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#include <linux/platform_data/asoc-s3c.h>\n\n#include \"dma.h\"\n#include \"idma.h\"\n#include \"i2s.h\"\n#include \"i2s-regs.h\"\n\n#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)\n\n#define SAMSUNG_I2S_ID_PRIMARY\t\t1\n#define SAMSUNG_I2S_ID_SECONDARY\t2\n\nstruct samsung_i2s_variant_regs {\n\tunsigned int\tbfs_off;\n\tunsigned int\trfs_off;\n\tunsigned int\tsdf_off;\n\tunsigned int\ttxr_off;\n\tunsigned int\trclksrc_off;\n\tunsigned int\tmss_off;\n\tunsigned int\tcdclkcon_off;\n\tunsigned int\tlrp_off;\n\tunsigned int\tbfs_mask;\n\tunsigned int\trfs_mask;\n\tunsigned int\tftx0cnt_off;\n};\n\nstruct samsung_i2s_dai_data {\n\tu32 quirks;\n\tunsigned int pcm_rates;\n\tconst struct samsung_i2s_variant_regs *i2s_variant_regs;\n\tvoid (*fixup_early)(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *dai);\n\tvoid (*fixup_late)(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *dai);\n};\n\nstruct i2s_dai {\n\t \n\tstruct platform_device *pdev;\n\n\t \n\tunsigned frmclk;\n\t \n\tunsigned rfs, bfs;\n\t \n\tstruct i2s_dai *pri_dai;\n\t \n\tstruct i2s_dai *sec_dai;\n\n#define DAI_OPENED\t(1 << 0)  \n#define DAI_MANAGER\t(1 << 1)  \n\tunsigned mode;\n\n\t \n\tstruct snd_soc_dai_driver *drv;\n\n\t \n\tstruct snd_dmaengine_dai_dma_data dma_playback;\n\tstruct snd_dmaengine_dai_dma_data dma_capture;\n\tstruct snd_dmaengine_dai_dma_data idma_playback;\n\tdma_filter_fn filter;\n\n\tstruct samsung_i2s_priv *priv;\n};\n\nstruct samsung_i2s_priv {\n\tstruct platform_device *pdev;\n\tstruct platform_device *pdev_sec;\n\n\t \n\tspinlock_t pcm_lock;\n\n\t \n\tstruct i2s_dai *dai;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tint num_dais;\n\n\t \n\tstruct clk *clk;\n\n\t \n\tstruct clk *op_clk;\n\n\t \n\tunsigned long rclk_srcrate;\n\n\t \n\tu32 suspend_i2smod;\n\tu32 suspend_i2scon;\n\tu32 suspend_i2spsr;\n\n\tconst struct samsung_i2s_variant_regs *variant_regs;\n\tvoid (*fixup_early)(struct snd_pcm_substream *substream,\n\t\t\t\t\t\tstruct snd_soc_dai *dai);\n\tvoid (*fixup_late)(struct snd_pcm_substream *substream,\n\t\t\t\t\t\tstruct snd_soc_dai *dai);\n\tu32 quirks;\n\n\t \n\tstruct clk *clk_table[3];\n\tstruct clk_onecell_data clk_data;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tvoid __iomem *addr;\n\n\t \n\tbool slave_mode;\n};\n\n \nstatic inline bool is_secondary(struct i2s_dai *i2s)\n{\n\treturn i2s->drv->id == SAMSUNG_I2S_ID_SECONDARY;\n}\n\n \nstatic inline bool tx_active(struct i2s_dai *i2s)\n{\n\tu32 active;\n\n\tif (!i2s)\n\t\treturn false;\n\n\tactive = readl(i2s->priv->addr + I2SCON);\n\n\tif (is_secondary(i2s))\n\t\tactive &= CON_TXSDMA_ACTIVE;\n\telse\n\t\tactive &= CON_TXDMA_ACTIVE;\n\n\treturn active ? true : false;\n}\n\n \nstatic inline struct i2s_dai *get_other_dai(struct i2s_dai *i2s)\n{\n\treturn i2s->pri_dai ? : i2s->sec_dai;\n}\n\n \nstatic inline bool other_tx_active(struct i2s_dai *i2s)\n{\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\n\treturn tx_active(other);\n}\n\n \nstatic inline bool any_tx_active(struct i2s_dai *i2s)\n{\n\treturn tx_active(i2s) || other_tx_active(i2s);\n}\n\n \nstatic inline bool rx_active(struct i2s_dai *i2s)\n{\n\tu32 active;\n\n\tif (!i2s)\n\t\treturn false;\n\n\tactive = readl(i2s->priv->addr + I2SCON) & CON_RXDMA_ACTIVE;\n\n\treturn active ? true : false;\n}\n\n \nstatic inline bool other_rx_active(struct i2s_dai *i2s)\n{\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\n\treturn rx_active(other);\n}\n\n \nstatic inline bool any_rx_active(struct i2s_dai *i2s)\n{\n\treturn rx_active(i2s) || other_rx_active(i2s);\n}\n\n \nstatic inline bool other_active(struct i2s_dai *i2s)\n{\n\treturn other_rx_active(i2s) || other_tx_active(i2s);\n}\n\n \nstatic inline bool this_active(struct i2s_dai *i2s)\n{\n\treturn tx_active(i2s) || rx_active(i2s);\n}\n\n \nstatic inline bool any_active(struct i2s_dai *i2s)\n{\n\treturn this_active(i2s) || other_active(i2s);\n}\n\nstatic inline struct i2s_dai *to_info(struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\n\treturn &priv->dai[dai->id - 1];\n}\n\nstatic inline bool is_opened(struct i2s_dai *i2s)\n{\n\tif (i2s && (i2s->mode & DAI_OPENED))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic inline bool is_manager(struct i2s_dai *i2s)\n{\n\tif (is_opened(i2s) && (i2s->mode & DAI_MANAGER))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic inline unsigned get_rfs(struct i2s_dai *i2s)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tu32 rfs;\n\n\trfs = readl(priv->addr + I2SMOD) >> priv->variant_regs->rfs_off;\n\trfs &= priv->variant_regs->rfs_mask;\n\n\tswitch (rfs) {\n\tcase 7: return 192;\n\tcase 6: return 96;\n\tcase 5: return 128;\n\tcase 4: return 64;\n\tcase 3:\treturn 768;\n\tcase 2: return 384;\n\tcase 1:\treturn 512;\n\tdefault: return 256;\n\t}\n}\n\n \nstatic inline void set_rfs(struct i2s_dai *i2s, unsigned rfs)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tu32 mod = readl(priv->addr + I2SMOD);\n\tint rfs_shift = priv->variant_regs->rfs_off;\n\n\tmod &= ~(priv->variant_regs->rfs_mask << rfs_shift);\n\n\tswitch (rfs) {\n\tcase 192:\n\t\tmod |= (EXYNOS7_MOD_RCLK_192FS << rfs_shift);\n\t\tbreak;\n\tcase 96:\n\t\tmod |= (EXYNOS7_MOD_RCLK_96FS << rfs_shift);\n\t\tbreak;\n\tcase 128:\n\t\tmod |= (EXYNOS7_MOD_RCLK_128FS << rfs_shift);\n\t\tbreak;\n\tcase 64:\n\t\tmod |= (EXYNOS7_MOD_RCLK_64FS << rfs_shift);\n\t\tbreak;\n\tcase 768:\n\t\tmod |= (MOD_RCLK_768FS << rfs_shift);\n\t\tbreak;\n\tcase 512:\n\t\tmod |= (MOD_RCLK_512FS << rfs_shift);\n\t\tbreak;\n\tcase 384:\n\t\tmod |= (MOD_RCLK_384FS << rfs_shift);\n\t\tbreak;\n\tdefault:\n\t\tmod |= (MOD_RCLK_256FS << rfs_shift);\n\t\tbreak;\n\t}\n\n\twritel(mod, priv->addr + I2SMOD);\n}\n\n \nstatic inline unsigned get_bfs(struct i2s_dai *i2s)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tu32 bfs;\n\n\tbfs = readl(priv->addr + I2SMOD) >> priv->variant_regs->bfs_off;\n\tbfs &= priv->variant_regs->bfs_mask;\n\n\tswitch (bfs) {\n\tcase 8: return 256;\n\tcase 7: return 192;\n\tcase 6: return 128;\n\tcase 5: return 96;\n\tcase 4: return 64;\n\tcase 3: return 24;\n\tcase 2: return 16;\n\tcase 1:\treturn 48;\n\tdefault: return 32;\n\t}\n}\n\n \nstatic inline void set_bfs(struct i2s_dai *i2s, unsigned bfs)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tu32 mod = readl(priv->addr + I2SMOD);\n\tint tdm = priv->quirks & QUIRK_SUPPORTS_TDM;\n\tint bfs_shift = priv->variant_regs->bfs_off;\n\n\t \n\tif (!tdm && bfs > 48) {\n\t\tdev_err(&i2s->pdev->dev, \"Unsupported BCLK divider\\n\");\n\t\treturn;\n\t}\n\n\tmod &= ~(priv->variant_regs->bfs_mask << bfs_shift);\n\n\tswitch (bfs) {\n\tcase 48:\n\t\tmod |= (MOD_BCLK_48FS << bfs_shift);\n\t\tbreak;\n\tcase 32:\n\t\tmod |= (MOD_BCLK_32FS << bfs_shift);\n\t\tbreak;\n\tcase 24:\n\t\tmod |= (MOD_BCLK_24FS << bfs_shift);\n\t\tbreak;\n\tcase 16:\n\t\tmod |= (MOD_BCLK_16FS << bfs_shift);\n\t\tbreak;\n\tcase 64:\n\t\tmod |= (EXYNOS5420_MOD_BCLK_64FS << bfs_shift);\n\t\tbreak;\n\tcase 96:\n\t\tmod |= (EXYNOS5420_MOD_BCLK_96FS << bfs_shift);\n\t\tbreak;\n\tcase 128:\n\t\tmod |= (EXYNOS5420_MOD_BCLK_128FS << bfs_shift);\n\t\tbreak;\n\tcase 192:\n\t\tmod |= (EXYNOS5420_MOD_BCLK_192FS << bfs_shift);\n\t\tbreak;\n\tcase 256:\n\t\tmod |= (EXYNOS5420_MOD_BCLK_256FS << bfs_shift);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"Wrong BCLK Divider!\\n\");\n\t\treturn;\n\t}\n\n\twritel(mod, priv->addr + I2SMOD);\n}\n\n \nstatic inline int get_blc(struct i2s_dai *i2s)\n{\n\tint blc = readl(i2s->priv->addr + I2SMOD);\n\n\tblc = (blc >> 13) & 0x3;\n\n\tswitch (blc) {\n\tcase 2: return 24;\n\tcase 1:\treturn 8;\n\tdefault: return 16;\n\t}\n}\n\n \nstatic void i2s_txctrl(struct i2s_dai *i2s, int on)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tvoid __iomem *addr = priv->addr;\n\tint txr_off = priv->variant_regs->txr_off;\n\tu32 con = readl(addr + I2SCON);\n\tu32 mod = readl(addr + I2SMOD) & ~(3 << txr_off);\n\n\tif (on) {\n\t\tcon |= CON_ACTIVE;\n\t\tcon &= ~CON_TXCH_PAUSE;\n\n\t\tif (is_secondary(i2s)) {\n\t\t\tcon |= CON_TXSDMA_ACTIVE;\n\t\t\tcon &= ~CON_TXSDMA_PAUSE;\n\t\t} else {\n\t\t\tcon |= CON_TXDMA_ACTIVE;\n\t\t\tcon &= ~CON_TXDMA_PAUSE;\n\t\t}\n\n\t\tif (any_rx_active(i2s))\n\t\t\tmod |= 2 << txr_off;\n\t\telse\n\t\t\tmod |= 0 << txr_off;\n\t} else {\n\t\tif (is_secondary(i2s)) {\n\t\t\tcon |=  CON_TXSDMA_PAUSE;\n\t\t\tcon &= ~CON_TXSDMA_ACTIVE;\n\t\t} else {\n\t\t\tcon |=  CON_TXDMA_PAUSE;\n\t\t\tcon &= ~CON_TXDMA_ACTIVE;\n\t\t}\n\n\t\tif (other_tx_active(i2s)) {\n\t\t\twritel(con, addr + I2SCON);\n\t\t\treturn;\n\t\t}\n\n\t\tcon |=  CON_TXCH_PAUSE;\n\n\t\tif (any_rx_active(i2s))\n\t\t\tmod |= 1 << txr_off;\n\t\telse\n\t\t\tcon &= ~CON_ACTIVE;\n\t}\n\n\twritel(mod, addr + I2SMOD);\n\twritel(con, addr + I2SCON);\n}\n\n \nstatic void i2s_rxctrl(struct i2s_dai *i2s, int on)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tvoid __iomem *addr = priv->addr;\n\tint txr_off = priv->variant_regs->txr_off;\n\tu32 con = readl(addr + I2SCON);\n\tu32 mod = readl(addr + I2SMOD) & ~(3 << txr_off);\n\n\tif (on) {\n\t\tcon |= CON_RXDMA_ACTIVE | CON_ACTIVE;\n\t\tcon &= ~(CON_RXDMA_PAUSE | CON_RXCH_PAUSE);\n\n\t\tif (any_tx_active(i2s))\n\t\t\tmod |= 2 << txr_off;\n\t\telse\n\t\t\tmod |= 1 << txr_off;\n\t} else {\n\t\tcon |=  CON_RXDMA_PAUSE | CON_RXCH_PAUSE;\n\t\tcon &= ~CON_RXDMA_ACTIVE;\n\n\t\tif (any_tx_active(i2s))\n\t\t\tmod |= 0 << txr_off;\n\t\telse\n\t\t\tcon &= ~CON_ACTIVE;\n\t}\n\n\twritel(mod, addr + I2SMOD);\n\twritel(con, addr + I2SCON);\n}\n\n \nstatic inline void i2s_fifo(struct i2s_dai *i2s, u32 flush)\n{\n\tvoid __iomem *fic;\n\tu32 val;\n\n\tif (!i2s)\n\t\treturn;\n\n\tif (is_secondary(i2s))\n\t\tfic = i2s->priv->addr + I2SFICS;\n\telse\n\t\tfic = i2s->priv->addr + I2SFIC;\n\n\t \n\twritel(readl(fic) | flush, fic);\n\n\t \n\tval = msecs_to_loops(1) / 1000;  \n\twhile (--val)\n\t\tcpu_relax();\n\n\twritel(readl(fic) & ~flush, fic);\n}\n\nstatic int i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id, unsigned int rfs,\n\t\t\t  int dir)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\tconst struct samsung_i2s_variant_regs *i2s_regs = priv->variant_regs;\n\tunsigned int cdcon_mask = 1 << i2s_regs->cdclkcon_off;\n\tunsigned int rsrc_mask = 1 << i2s_regs->rclksrc_off;\n\tu32 mod, mask, val = 0;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tpm_runtime_get_sync(dai->dev);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmod = readl(priv->addr + I2SMOD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tswitch (clk_id) {\n\tcase SAMSUNG_I2S_OPCLK:\n\t\tmask = MOD_OPCLK_MASK;\n\t\tval = (dir << MOD_OPCLK_SHIFT) & MOD_OPCLK_MASK;\n\t\tbreak;\n\tcase SAMSUNG_I2S_CDCLK:\n\t\tmask = 1 << i2s_regs->cdclkcon_off;\n\t\t \n\t\tif (dir == SND_SOC_CLOCK_IN)\n\t\t\trfs = 0;\n\n\t\tif ((rfs && other && other->rfs && (other->rfs != rfs)) ||\n\t\t\t\t(any_active(i2s) &&\n\t\t\t\t(((dir == SND_SOC_CLOCK_IN)\n\t\t\t\t\t&& !(mod & cdcon_mask)) ||\n\t\t\t\t((dir == SND_SOC_CLOCK_OUT)\n\t\t\t\t\t&& (mod & cdcon_mask))))) {\n\t\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\t\"%s:%d Other DAI busy\\n\", __func__, __LINE__);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dir == SND_SOC_CLOCK_IN)\n\t\t\tval = 1 << i2s_regs->cdclkcon_off;\n\n\t\ti2s->rfs = rfs;\n\t\tbreak;\n\n\tcase SAMSUNG_I2S_RCLKSRC_0:  \n\tcase SAMSUNG_I2S_RCLKSRC_1:  \n\t\tmask = 1 << i2s_regs->rclksrc_off;\n\n\t\tif ((priv->quirks & QUIRK_NO_MUXPSR)\n\t\t\t\t|| (clk_id == SAMSUNG_I2S_RCLKSRC_0))\n\t\t\tclk_id = 0;\n\t\telse\n\t\t\tclk_id = 1;\n\n\t\tif (!any_active(i2s)) {\n\t\t\tif (priv->op_clk && !IS_ERR(priv->op_clk)) {\n\t\t\t\tif ((clk_id && !(mod & rsrc_mask)) ||\n\t\t\t\t\t(!clk_id && (mod & rsrc_mask))) {\n\t\t\t\t\tclk_disable_unprepare(priv->op_clk);\n\t\t\t\t\tclk_put(priv->op_clk);\n\t\t\t\t} else {\n\t\t\t\t\tpriv->rclk_srcrate =\n\t\t\t\t\t\tclk_get_rate(priv->op_clk);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (clk_id)\n\t\t\t\tpriv->op_clk = clk_get(&i2s->pdev->dev,\n\t\t\t\t\t\t\"i2s_opclk1\");\n\t\t\telse\n\t\t\t\tpriv->op_clk = clk_get(&i2s->pdev->dev,\n\t\t\t\t\t\t\"i2s_opclk0\");\n\n\t\t\tif (WARN_ON(IS_ERR(priv->op_clk))) {\n\t\t\t\tret = PTR_ERR(priv->op_clk);\n\t\t\t\tpriv->op_clk = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = clk_prepare_enable(priv->op_clk);\n\t\t\tif (ret) {\n\t\t\t\tclk_put(priv->op_clk);\n\t\t\t\tpriv->op_clk = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tpriv->rclk_srcrate = clk_get_rate(priv->op_clk);\n\n\t\t} else if ((!clk_id && (mod & rsrc_mask))\n\t\t\t\t|| (clk_id && !(mod & rsrc_mask))) {\n\t\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\t\"%s:%d Other DAI busy\\n\", __func__, __LINE__);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err;\n\t\t} else {\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\n\t\tif (clk_id == 1)\n\t\t\tval = 1 << i2s_regs->rclksrc_off;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"We don't serve that!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmod = readl(priv->addr + I2SMOD);\n\tmod = (mod & ~mask) | val;\n\twritel(mod, priv->addr + I2SMOD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\ndone:\n\tpm_runtime_put(dai->dev);\n\n\treturn 0;\nerr:\n\tpm_runtime_put(dai->dev);\n\treturn ret;\n}\n\nstatic int i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tint lrp_shift, sdf_shift, sdf_mask, lrp_rlow, mod_slave;\n\tu32 mod, tmp = 0;\n\tunsigned long flags;\n\n\tlrp_shift = priv->variant_regs->lrp_off;\n\tsdf_shift = priv->variant_regs->sdf_off;\n\tmod_slave = 1 << priv->variant_regs->mss_off;\n\n\tsdf_mask = MOD_SDF_MASK << sdf_shift;\n\tlrp_rlow = MOD_LR_RLOW << lrp_shift;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\ttmp |= lrp_rlow;\n\t\ttmp |= (MOD_SDF_MSB << sdf_shift);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ttmp |= lrp_rlow;\n\t\ttmp |= (MOD_SDF_LSB << sdf_shift);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\ttmp |= (MOD_SDF_IIS << sdf_shift);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"Format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tif (tmp & lrp_rlow)\n\t\t\ttmp &= ~lrp_rlow;\n\t\telse\n\t\t\ttmp |= lrp_rlow;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"Polarity not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\ttmp |= mod_slave;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tif (priv->rclk_srcrate == 0 && priv->clk_data.clks == NULL)\n\t\t\ti2s_set_sysclk(dai, SAMSUNG_I2S_RCLKSRC_0,\n\t\t\t\t\t\t\t0, SND_SOC_CLOCK_IN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"master/slave format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(dai->dev);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmod = readl(priv->addr + I2SMOD);\n\t \n\tif (any_active(i2s) &&\n\t\t((mod & (sdf_mask | lrp_rlow | mod_slave)) != tmp)) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tpm_runtime_put(dai->dev);\n\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\t\"%s:%d Other DAI busy\\n\", __func__, __LINE__);\n\t\treturn -EAGAIN;\n\t}\n\n\tmod &= ~(sdf_mask | lrp_rlow | mod_slave);\n\tmod |= tmp;\n\twritel(mod, priv->addr + I2SMOD);\n\tpriv->slave_mode = (mod & mod_slave);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tpm_runtime_put(dai->dev);\n\n\treturn 0;\n}\n\nstatic int i2s_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tu32 mod, mask = 0, val = 0;\n\tstruct clk *rclksrc;\n\tunsigned long flags;\n\n\tWARN_ON(!pm_runtime_active(dai->dev));\n\n\tif (!is_secondary(i2s))\n\t\tmask |= (MOD_DC2_EN | MOD_DC1_EN);\n\n\tswitch (params_channels(params)) {\n\tcase 6:\n\t\tval |= MOD_DC2_EN;\n\t\tfallthrough;\n\tcase 4:\n\t\tval |= MOD_DC1_EN;\n\t\tbreak;\n\tcase 2:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ti2s->dma_playback.addr_width = 4;\n\t\telse\n\t\t\ti2s->dma_capture.addr_width = 4;\n\t\tbreak;\n\tcase 1:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ti2s->dma_playback.addr_width = 2;\n\t\telse\n\t\t\ti2s->dma_capture.addr_width = 2;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"%d channels not supported\\n\",\n\t\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_secondary(i2s))\n\t\tmask |= MOD_BLCS_MASK;\n\telse\n\t\tmask |= MOD_BLCP_MASK;\n\n\tif (is_manager(i2s))\n\t\tmask |= MOD_BLC_MASK;\n\n\tswitch (params_width(params)) {\n\tcase 8:\n\t\tif (is_secondary(i2s))\n\t\t\tval |= MOD_BLCS_8BIT;\n\t\telse\n\t\t\tval |= MOD_BLCP_8BIT;\n\t\tif (is_manager(i2s))\n\t\t\tval |= MOD_BLC_8BIT;\n\t\tbreak;\n\tcase 16:\n\t\tif (is_secondary(i2s))\n\t\t\tval |= MOD_BLCS_16BIT;\n\t\telse\n\t\t\tval |= MOD_BLCP_16BIT;\n\t\tif (is_manager(i2s))\n\t\t\tval |= MOD_BLC_16BIT;\n\t\tbreak;\n\tcase 24:\n\t\tif (is_secondary(i2s))\n\t\t\tval |= MOD_BLCS_24BIT;\n\t\telse\n\t\t\tval |= MOD_BLCP_24BIT;\n\t\tif (is_manager(i2s))\n\t\t\tval |= MOD_BLC_24BIT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev, \"Format(%d) not supported\\n\",\n\t\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmod = readl(priv->addr + I2SMOD);\n\tmod = (mod & ~mask) | val;\n\twritel(mod, priv->addr + I2SMOD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tsnd_soc_dai_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);\n\n\ti2s->frmclk = params_rate(params);\n\n\trclksrc = priv->clk_table[CLK_I2S_RCLK_SRC];\n\tif (rclksrc && !IS_ERR(rclksrc))\n\t\tpriv->rclk_srcrate = clk_get_rate(rclksrc);\n\n\treturn 0;\n}\n\n \nstatic int i2s_startup(struct snd_pcm_substream *substream,\n\t  struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(dai->dev);\n\n\tspin_lock_irqsave(&priv->pcm_lock, flags);\n\n\ti2s->mode |= DAI_OPENED;\n\n\tif (is_manager(other))\n\t\ti2s->mode &= ~DAI_MANAGER;\n\telse\n\t\ti2s->mode |= DAI_MANAGER;\n\n\tif (!any_active(i2s) && (priv->quirks & QUIRK_NEED_RSTCLR))\n\t\twritel(CON_RSTCLR, i2s->priv->addr + I2SCON);\n\n\tspin_unlock_irqrestore(&priv->pcm_lock, flags);\n\n\treturn 0;\n}\n\nstatic void i2s_shutdown(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->pcm_lock, flags);\n\n\ti2s->mode &= ~DAI_OPENED;\n\ti2s->mode &= ~DAI_MANAGER;\n\n\tif (is_opened(other))\n\t\tother->mode |= DAI_MANAGER;\n\n\t \n\ti2s->rfs = 0;\n\ti2s->bfs = 0;\n\n\tspin_unlock_irqrestore(&priv->pcm_lock, flags);\n\n\tpm_runtime_put(dai->dev);\n}\n\nstatic int config_setup(struct i2s_dai *i2s)\n{\n\tstruct samsung_i2s_priv *priv = i2s->priv;\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\tunsigned rfs, bfs, blc;\n\tu32 psr;\n\n\tblc = get_blc(i2s);\n\n\tbfs = i2s->bfs;\n\n\tif (!bfs && other)\n\t\tbfs = other->bfs;\n\n\t \n\tif (!bfs)\n\t\tbfs = blc * 2;\n\n\trfs = i2s->rfs;\n\n\tif (!rfs && other)\n\t\trfs = other->rfs;\n\n\tif ((rfs == 256 || rfs == 512) && (blc == 24)) {\n\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\"%d-RFS not supported for 24-blc\\n\", rfs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rfs) {\n\t\tif (bfs == 16 || bfs == 32)\n\t\t\trfs = 256;\n\t\telse\n\t\t\trfs = 384;\n\t}\n\n\t \n\tif (any_active(i2s) && (get_rfs(i2s) != rfs || get_bfs(i2s) != bfs)) {\n\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\t\"%s:%d Other DAI busy\\n\", __func__, __LINE__);\n\t\treturn -EAGAIN;\n\t}\n\n\tset_bfs(i2s, bfs);\n\tset_rfs(i2s, rfs);\n\n\t \n\tif (priv->slave_mode)\n\t\treturn 0;\n\n\tif (!(priv->quirks & QUIRK_NO_MUXPSR)) {\n\t\tpsr = priv->rclk_srcrate / i2s->frmclk / rfs;\n\t\twritel(((psr - 1) << 8) | PSR_PSREN, priv->addr + I2SPSR);\n\t\tdev_dbg(&i2s->pdev->dev,\n\t\t\t\"RCLK_SRC=%luHz PSR=%u, RCLK=%dfs, BCLK=%dfs\\n\",\n\t\t\t\tpriv->rclk_srcrate, psr, rfs, bfs);\n\t}\n\n\treturn 0;\n}\n\nstatic int i2s_trigger(struct snd_pcm_substream *substream,\n\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tint capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct i2s_dai *i2s = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tpm_runtime_get_sync(dai->dev);\n\n\t\tif (priv->fixup_early)\n\t\t\tpriv->fixup_early(substream, dai);\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tif (config_setup(i2s)) {\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (priv->fixup_late)\n\t\t\tpriv->fixup_late(substream, dai);\n\n\t\tif (capture)\n\t\t\ti2s_rxctrl(i2s, 1);\n\t\telse\n\t\t\ti2s_txctrl(i2s, 1);\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tif (capture) {\n\t\t\ti2s_rxctrl(i2s, 0);\n\t\t\ti2s_fifo(i2s, FIC_RXFLUSH);\n\t\t} else {\n\t\t\ti2s_txctrl(i2s, 0);\n\t\t\ti2s_fifo(i2s, FIC_TXFLUSH);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tpm_runtime_put(dai->dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2s_set_clkdiv(struct snd_soc_dai *dai,\n\tint div_id, int div)\n{\n\tstruct i2s_dai *i2s = to_info(dai);\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\n\tswitch (div_id) {\n\tcase SAMSUNG_I2S_DIV_BCLK:\n\t\tpm_runtime_get_sync(dai->dev);\n\t\tif ((any_active(i2s) && div && (get_bfs(i2s) != div))\n\t\t\t|| (other && other->bfs && (other->bfs != div))) {\n\t\t\tpm_runtime_put(dai->dev);\n\t\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\t\"%s:%d Other DAI busy\\n\", __func__, __LINE__);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ti2s->bfs = div;\n\t\tpm_runtime_put(dai->dev);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2s->pdev->dev,\n\t\t\t\"Invalid clock divider(%d)\\n\", div_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t\ni2s_delay(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tu32 reg = readl(priv->addr + I2SFIC);\n\tsnd_pcm_sframes_t delay;\n\n\tWARN_ON(!pm_runtime_active(dai->dev));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tdelay = FIC_RXCOUNT(reg);\n\telse if (is_secondary(i2s))\n\t\tdelay = FICS_TXCOUNT(readl(priv->addr + I2SFICS));\n\telse\n\t\tdelay = (reg >> priv->variant_regs->ftx0cnt_off) & 0x7f;\n\n\treturn delay;\n}\n\n#ifdef CONFIG_PM\nstatic int i2s_suspend(struct snd_soc_component *component)\n{\n\treturn pm_runtime_force_suspend(component->dev);\n}\n\nstatic int i2s_resume(struct snd_soc_component *component)\n{\n\treturn pm_runtime_force_resume(component->dev);\n}\n#else\n#define i2s_suspend NULL\n#define i2s_resume  NULL\n#endif\n\nstatic int samsung_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(dai->dev);\n\n\tif (is_secondary(i2s)) {\n\t\t \n\t\tsnd_soc_dai_init_dma_data(dai, &i2s->dma_playback, NULL);\n\t} else {\n\t\tsnd_soc_dai_init_dma_data(dai, &i2s->dma_playback,\n\t\t\t\t\t  &i2s->dma_capture);\n\n\t\tif (priv->quirks & QUIRK_NEED_RSTCLR)\n\t\t\twritel(CON_RSTCLR, priv->addr + I2SCON);\n\n\t\tif (priv->quirks & QUIRK_SUPPORTS_IDMA)\n\t\t\tidma_reg_addr_init(priv->addr,\n\t\t\t\t\t   other->idma_playback.addr);\n\t}\n\n\t \n\ti2s->rfs = 0;\n\ti2s->bfs = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\ti2s_txctrl(i2s, 0);\n\ti2s_rxctrl(i2s, 0);\n\ti2s_fifo(i2s, FIC_TXFLUSH);\n\ti2s_fifo(other, FIC_TXFLUSH);\n\ti2s_fifo(i2s, FIC_RXFLUSH);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tif (!is_opened(other))\n\t\ti2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\n\t\t\t\t0, SND_SOC_CLOCK_IN);\n\tpm_runtime_put(dai->dev);\n\n\treturn 0;\n}\n\nstatic int samsung_i2s_dai_remove(struct snd_soc_dai *dai)\n{\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(dai);\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(dai->dev);\n\n\tif (!is_secondary(i2s)) {\n\t\tif (priv->quirks & QUIRK_NEED_RSTCLR) {\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\t\twritel(0, priv->addr + I2SCON);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t}\n\t}\n\n\tpm_runtime_put(dai->dev);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops samsung_i2s_dai_ops = {\n\t.probe = samsung_i2s_dai_probe,\n\t.remove = samsung_i2s_dai_remove,\n\t.trigger = i2s_trigger,\n\t.hw_params = i2s_hw_params,\n\t.set_fmt = i2s_set_fmt,\n\t.set_clkdiv = i2s_set_clkdiv,\n\t.set_sysclk = i2s_set_sysclk,\n\t.startup = i2s_startup,\n\t.shutdown = i2s_shutdown,\n\t.delay = i2s_delay,\n};\n\nstatic const struct snd_soc_dapm_widget samsung_i2s_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"Mixer DAI TX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Mixer DAI RX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Playback Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route samsung_i2s_dapm_routes[] = {\n\t{ \"Playback Mixer\", NULL, \"Primary Playback\" },\n\t{ \"Playback Mixer\", NULL, \"Secondary Playback\" },\n\n\t{ \"Mixer DAI TX\", NULL, \"Playback Mixer\" },\n\t{ \"Primary Capture\", NULL, \"Mixer DAI RX\" },\n};\n\nstatic const struct snd_soc_component_driver samsung_i2s_component = {\n\t.name = \"samsung-i2s\",\n\n\t.dapm_widgets = samsung_i2s_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(samsung_i2s_widgets),\n\n\t.dapm_routes = samsung_i2s_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(samsung_i2s_dapm_routes),\n\n\t.suspend = i2s_suspend,\n\t.resume = i2s_resume,\n\n\t.legacy_dai_naming = 1,\n};\n\n#define SAMSUNG_I2S_FMTS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic int i2s_alloc_dais(struct samsung_i2s_priv *priv,\n\t\t\t  const struct samsung_i2s_dai_data *i2s_dai_data,\n\t\t\t  int num_dais)\n{\n\tstatic const char *dai_names[] = { \"samsung-i2s\", \"samsung-i2s-sec\" };\n\tstatic const char *stream_names[] = { \"Primary Playback\",\n\t\t\t\t\t      \"Secondary Playback\" };\n\tstruct snd_soc_dai_driver *dai_drv;\n\tint i;\n\n\tpriv->dai = devm_kcalloc(&priv->pdev->dev, num_dais,\n\t\t\t\t     sizeof(struct i2s_dai), GFP_KERNEL);\n\tif (!priv->dai)\n\t\treturn -ENOMEM;\n\n\tpriv->dai_drv = devm_kcalloc(&priv->pdev->dev, num_dais,\n\t\t\t\t     sizeof(*dai_drv), GFP_KERNEL);\n\tif (!priv->dai_drv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_dais; i++) {\n\t\tdai_drv = &priv->dai_drv[i];\n\n\t\tdai_drv->symmetric_rate = 1;\n\t\tdai_drv->ops = &samsung_i2s_dai_ops;\n\n\t\tdai_drv->playback.channels_min = 1;\n\t\tdai_drv->playback.channels_max = 2;\n\t\tdai_drv->playback.rates = i2s_dai_data->pcm_rates;\n\t\tdai_drv->playback.formats = SAMSUNG_I2S_FMTS;\n\t\tdai_drv->playback.stream_name = stream_names[i];\n\n\t\tdai_drv->id = i + 1;\n\t\tdai_drv->name = dai_names[i];\n\n\t\tpriv->dai[i].drv = &priv->dai_drv[i];\n\t\tpriv->dai[i].pdev = priv->pdev;\n\t}\n\n\t \n\tdai_drv = &priv->dai_drv[SAMSUNG_I2S_ID_PRIMARY - 1];\n\n\tdai_drv->capture.channels_min = 1;\n\tdai_drv->capture.channels_max = 2;\n\tdai_drv->capture.rates = i2s_dai_data->pcm_rates;\n\tdai_drv->capture.formats = SAMSUNG_I2S_FMTS;\n\tdai_drv->capture.stream_name = \"Primary Capture\";\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int i2s_runtime_suspend(struct device *dev)\n{\n\tstruct samsung_i2s_priv *priv = dev_get_drvdata(dev);\n\n\tpriv->suspend_i2smod = readl(priv->addr + I2SMOD);\n\tpriv->suspend_i2scon = readl(priv->addr + I2SCON);\n\tpriv->suspend_i2spsr = readl(priv->addr + I2SPSR);\n\n\tclk_disable_unprepare(priv->op_clk);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int i2s_runtime_resume(struct device *dev)\n{\n\tstruct samsung_i2s_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->op_clk) {\n\t\tret = clk_prepare_enable(priv->op_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(priv->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\twritel(priv->suspend_i2scon, priv->addr + I2SCON);\n\twritel(priv->suspend_i2smod, priv->addr + I2SMOD);\n\twritel(priv->suspend_i2spsr, priv->addr + I2SPSR);\n\n\treturn 0;\n}\n#endif  \n\nstatic void i2s_unregister_clocks(struct samsung_i2s_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->clk_data.clk_num; i++) {\n\t\tif (!IS_ERR(priv->clk_table[i]))\n\t\t\tclk_unregister(priv->clk_table[i]);\n\t}\n}\n\nstatic void i2s_unregister_clock_provider(struct samsung_i2s_priv *priv)\n{\n\tof_clk_del_provider(priv->pdev->dev.of_node);\n\ti2s_unregister_clocks(priv);\n}\n\n\nstatic int i2s_register_clock_provider(struct samsung_i2s_priv *priv)\n{\n\n\tconst char * const i2s_clk_desc[] = { \"cdclk\", \"rclk_src\", \"prescaler\" };\n\tconst char *clk_name[2] = { \"i2s_opclk0\", \"i2s_opclk1\" };\n\tconst char *p_names[2] = { NULL };\n\tstruct device *dev = &priv->pdev->dev;\n\tconst struct samsung_i2s_variant_regs *reg_info = priv->variant_regs;\n\tconst char *i2s_clk_name[ARRAY_SIZE(i2s_clk_desc)];\n\tstruct clk *rclksrc;\n\tint ret, i;\n\n\t \n\tif (!of_property_present(dev->of_node, \"#clock-cells\"))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(p_names); i++) {\n\t\trclksrc = clk_get(dev, clk_name[i]);\n\t\tif (IS_ERR(rclksrc))\n\t\t\tcontinue;\n\t\tp_names[i] = __clk_get_name(rclksrc);\n\t\tclk_put(rclksrc);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(i2s_clk_desc); i++) {\n\t\ti2s_clk_name[i] = devm_kasprintf(dev, GFP_KERNEL, \"%s_%s\",\n\t\t\t\t\t\tdev_name(dev), i2s_clk_desc[i]);\n\t\tif (!i2s_clk_name[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!(priv->quirks & QUIRK_NO_MUXPSR)) {\n\t\t \n\t\tu32 val = readl(priv->addr + I2SPSR);\n\t\twritel(val | PSR_PSREN, priv->addr + I2SPSR);\n\n\t\tpriv->clk_table[CLK_I2S_RCLK_SRC] = clk_register_mux(dev,\n\t\t\t\ti2s_clk_name[CLK_I2S_RCLK_SRC], p_names,\n\t\t\t\tARRAY_SIZE(p_names),\n\t\t\t\tCLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT,\n\t\t\t\tpriv->addr + I2SMOD, reg_info->rclksrc_off,\n\t\t\t\t1, 0, &priv->lock);\n\n\t\tpriv->clk_table[CLK_I2S_RCLK_PSR] = clk_register_divider(dev,\n\t\t\t\ti2s_clk_name[CLK_I2S_RCLK_PSR],\n\t\t\t\ti2s_clk_name[CLK_I2S_RCLK_SRC],\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpriv->addr + I2SPSR, 8, 6, 0, &priv->lock);\n\n\t\tp_names[0] = i2s_clk_name[CLK_I2S_RCLK_PSR];\n\t\tpriv->clk_data.clk_num = 2;\n\t}\n\n\tpriv->clk_table[CLK_I2S_CDCLK] = clk_register_gate(dev,\n\t\t\t\ti2s_clk_name[CLK_I2S_CDCLK], p_names[0],\n\t\t\t\tCLK_SET_RATE_PARENT,\n\t\t\t\tpriv->addr + I2SMOD, reg_info->cdclkcon_off,\n\t\t\t\tCLK_GATE_SET_TO_DISABLE, &priv->lock);\n\n\tpriv->clk_data.clk_num += 1;\n\tpriv->clk_data.clks = priv->clk_table;\n\n\tret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,\n\t\t\t\t  &priv->clk_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to add clock provider: %d\\n\", ret);\n\t\ti2s_unregister_clocks(priv);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int i2s_create_secondary_device(struct samsung_i2s_priv *priv)\n{\n\tstruct platform_device *pdev_sec;\n\tconst char *devname;\n\tint ret;\n\n\tdevname = devm_kasprintf(&priv->pdev->dev, GFP_KERNEL, \"%s-sec\",\n\t\t\t\t dev_name(&priv->pdev->dev));\n\tif (!devname)\n\t\treturn -ENOMEM;\n\n\tpdev_sec = platform_device_alloc(devname, -1);\n\tif (!pdev_sec)\n\t\treturn -ENOMEM;\n\n\tpdev_sec->driver_override = kstrdup(\"samsung-i2s\", GFP_KERNEL);\n\tif (!pdev_sec->driver_override) {\n\t\tplatform_device_put(pdev_sec);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = platform_device_add(pdev_sec);\n\tif (ret < 0) {\n\t\tplatform_device_put(pdev_sec);\n\t\treturn ret;\n\t}\n\n\tret = device_attach(&pdev_sec->dev);\n\tif (ret <= 0) {\n\t\tplatform_device_unregister(priv->pdev_sec);\n\t\tdev_info(&pdev_sec->dev, \"device_attach() failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->pdev_sec = pdev_sec;\n\n\treturn 0;\n}\n\nstatic void i2s_delete_secondary_device(struct samsung_i2s_priv *priv)\n{\n\tplatform_device_unregister(priv->pdev_sec);\n\tpriv->pdev_sec = NULL;\n}\n\nstatic int samsung_i2s_probe(struct platform_device *pdev)\n{\n\tstruct i2s_dai *pri_dai, *sec_dai = NULL;\n\tstruct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;\n\tu32 regs_base, idma_addr = 0;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct samsung_i2s_dai_data *i2s_dai_data;\n\tconst struct platform_device_id *id;\n\tstruct samsung_i2s_priv *priv;\n\tstruct resource *res;\n\tint num_dais, ret;\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\ti2s_dai_data = of_device_get_match_data(&pdev->dev);\n\t} else {\n\t\tid = platform_get_device_id(pdev);\n\n\t\t \n\t\tif (!id)\n\t\t\treturn 0;\n\n\t\ti2s_dai_data = (struct samsung_i2s_dai_data *)id->driver_data;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (np) {\n\t\tpriv->quirks = i2s_dai_data->quirks;\n\t\tpriv->fixup_early = i2s_dai_data->fixup_early;\n\t\tpriv->fixup_late = i2s_dai_data->fixup_late;\n\t} else {\n\t\tif (!i2s_pdata) {\n\t\t\tdev_err(&pdev->dev, \"Missing platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->quirks = i2s_pdata->type.quirks;\n\t}\n\n\tnum_dais = (priv->quirks & QUIRK_SEC_DAI) ? 2 : 1;\n\tpriv->pdev = pdev;\n\tpriv->variant_regs = i2s_dai_data->i2s_variant_regs;\n\n\tret = i2s_alloc_dais(priv, i2s_dai_data, num_dais);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpri_dai = &priv->dai[SAMSUNG_I2S_ID_PRIMARY - 1];\n\n\tspin_lock_init(&priv->lock);\n\tspin_lock_init(&priv->pcm_lock);\n\n\tif (!np) {\n\t\tpri_dai->dma_playback.filter_data = i2s_pdata->dma_playback;\n\t\tpri_dai->dma_capture.filter_data = i2s_pdata->dma_capture;\n\t\tpri_dai->filter = i2s_pdata->dma_filter;\n\n\t\tidma_addr = i2s_pdata->type.idma_addr;\n\t} else {\n\t\tif (of_property_read_u32(np, \"samsung,idma-addr\",\n\t\t\t\t\t &idma_addr)) {\n\t\t\tif (priv->quirks & QUIRK_SUPPORTS_IDMA) {\n\t\t\t\tdev_info(&pdev->dev, \"idma address is not\"\\\n\t\t\t\t\t\t\"specified\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpriv->addr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->addr))\n\t\treturn PTR_ERR(priv->addr);\n\n\tregs_base = res->start;\n\n\tpriv->clk = devm_clk_get(&pdev->dev, \"iis\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get iis clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpri_dai->dma_playback.addr = regs_base + I2STXD;\n\tpri_dai->dma_capture.addr = regs_base + I2SRXD;\n\tpri_dai->dma_playback.chan_name = \"tx\";\n\tpri_dai->dma_capture.chan_name = \"rx\";\n\tpri_dai->dma_playback.addr_width = 4;\n\tpri_dai->dma_capture.addr_width = 4;\n\tpri_dai->priv = priv;\n\n\tif (priv->quirks & QUIRK_PRI_6CHAN)\n\t\tpri_dai->drv->playback.channels_max = 6;\n\n\tret = samsung_asoc_dma_platform_register(&pdev->dev, pri_dai->filter,\n\t\t\t\t\t\t \"tx\", \"rx\", NULL);\n\tif (ret < 0)\n\t\tgoto err_disable_clk;\n\n\tif (priv->quirks & QUIRK_SEC_DAI) {\n\t\tsec_dai = &priv->dai[SAMSUNG_I2S_ID_SECONDARY - 1];\n\n\t\tsec_dai->dma_playback.addr = regs_base + I2STXDS;\n\t\tsec_dai->dma_playback.chan_name = \"tx-sec\";\n\n\t\tif (!np) {\n\t\t\tsec_dai->dma_playback.filter_data = i2s_pdata->dma_play_sec;\n\t\t\tsec_dai->filter = i2s_pdata->dma_filter;\n\t\t}\n\n\t\tsec_dai->dma_playback.addr_width = 4;\n\t\tsec_dai->idma_playback.addr = idma_addr;\n\t\tsec_dai->pri_dai = pri_dai;\n\t\tsec_dai->priv = priv;\n\t\tpri_dai->sec_dai = sec_dai;\n\n\t\tret = i2s_create_secondary_device(priv);\n\t\tif (ret < 0)\n\t\t\tgoto err_disable_clk;\n\n\t\tret = samsung_asoc_dma_platform_register(&priv->pdev_sec->dev,\n\t\t\t\t\t\tsec_dai->filter, \"tx-sec\", NULL,\n\t\t\t\t\t\t&pdev->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_del_sec;\n\n\t}\n\n\tif (i2s_pdata && i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {\n\t\tdev_err(&pdev->dev, \"Unable to configure gpio\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_del_sec;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t&samsung_i2s_component,\n\t\t\t\t\tpriv->dai_drv, num_dais);\n\tif (ret < 0)\n\t\tgoto err_del_sec;\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = i2s_register_clock_provider(priv);\n\tif (ret < 0)\n\t\tgoto err_disable_pm;\n\n\tpriv->op_clk = clk_get_parent(priv->clk_table[CLK_I2S_RCLK_SRC]);\n\n\treturn 0;\n\nerr_disable_pm:\n\tpm_runtime_disable(&pdev->dev);\nerr_del_sec:\n\ti2s_delete_secondary_device(priv);\nerr_disable_clk:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic void samsung_i2s_remove(struct platform_device *pdev)\n{\n\tstruct samsung_i2s_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\t \n\tif (!priv)\n\t\treturn;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\ti2s_unregister_clock_provider(priv);\n\ti2s_delete_secondary_device(priv);\n\tclk_disable_unprepare(priv->clk);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n}\n\nstatic void fsd_i2s_fixup_early(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct i2s_dai *i2s = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\n\tif (!is_opened(other)) {\n\t\ti2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK, 0, SND_SOC_CLOCK_OUT);\n\t\ti2s_set_sysclk(dai, SAMSUNG_I2S_OPCLK, 0, MOD_OPCLK_PCLK);\n\t}\n}\n\nstatic void fsd_i2s_fixup_late(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct samsung_i2s_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct i2s_dai *i2s = to_info(asoc_rtd_to_cpu(rtd, 0));\n\tstruct i2s_dai *other = get_other_dai(i2s);\n\n\tif (!is_opened(other))\n\t\twritel(PSR_PSVAL(2) | PSR_PSREN, priv->addr + I2SPSR);\n}\n\nstatic const struct samsung_i2s_variant_regs i2sv3_regs = {\n\t.bfs_off = 1,\n\t.rfs_off = 3,\n\t.sdf_off = 5,\n\t.txr_off = 8,\n\t.rclksrc_off = 10,\n\t.mss_off = 11,\n\t.cdclkcon_off = 12,\n\t.lrp_off = 7,\n\t.bfs_mask = 0x3,\n\t.rfs_mask = 0x3,\n\t.ftx0cnt_off = 8,\n};\n\nstatic const struct samsung_i2s_variant_regs i2sv6_regs = {\n\t.bfs_off = 0,\n\t.rfs_off = 4,\n\t.sdf_off = 6,\n\t.txr_off = 8,\n\t.rclksrc_off = 10,\n\t.mss_off = 11,\n\t.cdclkcon_off = 12,\n\t.lrp_off = 15,\n\t.bfs_mask = 0xf,\n\t.rfs_mask = 0x3,\n\t.ftx0cnt_off = 8,\n};\n\nstatic const struct samsung_i2s_variant_regs i2sv7_regs = {\n\t.bfs_off = 0,\n\t.rfs_off = 4,\n\t.sdf_off = 7,\n\t.txr_off = 9,\n\t.rclksrc_off = 11,\n\t.mss_off = 12,\n\t.cdclkcon_off = 22,\n\t.lrp_off = 15,\n\t.bfs_mask = 0xf,\n\t.rfs_mask = 0x7,\n\t.ftx0cnt_off = 0,\n};\n\nstatic const struct samsung_i2s_variant_regs i2sv5_i2s1_regs = {\n\t.bfs_off = 0,\n\t.rfs_off = 3,\n\t.sdf_off = 6,\n\t.txr_off = 8,\n\t.rclksrc_off = 10,\n\t.mss_off = 11,\n\t.cdclkcon_off = 12,\n\t.lrp_off = 15,\n\t.bfs_mask = 0x7,\n\t.rfs_mask = 0x7,\n\t.ftx0cnt_off = 8,\n};\n\nstatic const struct samsung_i2s_dai_data i2sv3_dai_type = {\n\t.quirks = QUIRK_NO_MUXPSR,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_96000,\n\t.i2s_variant_regs = &i2sv3_regs,\n};\n\nstatic const struct samsung_i2s_dai_data i2sv5_dai_type __maybe_unused = {\n\t.quirks = QUIRK_PRI_6CHAN | QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR |\n\t\t\tQUIRK_SUPPORTS_IDMA,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_96000,\n\t.i2s_variant_regs = &i2sv3_regs,\n};\n\nstatic const struct samsung_i2s_dai_data i2sv6_dai_type __maybe_unused = {\n\t.quirks = QUIRK_PRI_6CHAN | QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR |\n\t\t\tQUIRK_SUPPORTS_TDM | QUIRK_SUPPORTS_IDMA,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_96000,\n\t.i2s_variant_regs = &i2sv6_regs,\n};\n\nstatic const struct samsung_i2s_dai_data i2sv7_dai_type __maybe_unused = {\n\t.quirks = QUIRK_PRI_6CHAN | QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR |\n\t\t\tQUIRK_SUPPORTS_TDM,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_192000,\n\t.i2s_variant_regs = &i2sv7_regs,\n};\n\nstatic const struct samsung_i2s_dai_data i2sv5_dai_type_i2s1 __maybe_unused = {\n\t.quirks = QUIRK_PRI_6CHAN | QUIRK_NEED_RSTCLR,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_96000,\n\t.i2s_variant_regs = &i2sv5_i2s1_regs,\n};\n\nstatic const struct samsung_i2s_dai_data fsd_dai_type __maybe_unused = {\n\t.quirks = QUIRK_SEC_DAI | QUIRK_NEED_RSTCLR | QUIRK_SUPPORTS_TDM,\n\t.pcm_rates = SNDRV_PCM_RATE_8000_192000,\n\t.i2s_variant_regs = &i2sv7_regs,\n\t.fixup_early = fsd_i2s_fixup_early,\n\t.fixup_late = fsd_i2s_fixup_late,\n};\n\nstatic const struct platform_device_id samsung_i2s_driver_ids[] = {\n\t{\n\t\t.name           = \"samsung-i2s\",\n\t\t.driver_data\t= (kernel_ulong_t)&i2sv3_dai_type,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, samsung_i2s_driver_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id exynos_i2s_match[] = {\n\t{\n\t\t.compatible = \"samsung,s3c6410-i2s\",\n\t\t.data = &i2sv3_dai_type,\n\t}, {\n\t\t.compatible = \"samsung,s5pv210-i2s\",\n\t\t.data = &i2sv5_dai_type,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-i2s\",\n\t\t.data = &i2sv6_dai_type,\n\t}, {\n\t\t.compatible = \"samsung,exynos7-i2s\",\n\t\t.data = &i2sv7_dai_type,\n\t}, {\n\t\t.compatible = \"samsung,exynos7-i2s1\",\n\t\t.data = &i2sv5_dai_type_i2s1,\n\t}, {\n\t\t.compatible = \"tesla,fsd-i2s\",\n\t\t.data = &fsd_dai_type,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_i2s_match);\n#endif\n\nstatic const struct dev_pm_ops samsung_i2s_pm = {\n\tSET_RUNTIME_PM_OPS(i2s_runtime_suspend,\n\t\t\t\ti2s_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver samsung_i2s_driver = {\n\t.probe  = samsung_i2s_probe,\n\t.remove_new = samsung_i2s_remove,\n\t.id_table = samsung_i2s_driver_ids,\n\t.driver = {\n\t\t.name = \"samsung-i2s\",\n\t\t.of_match_table = of_match_ptr(exynos_i2s_match),\n\t\t.pm = &samsung_i2s_pm,\n\t},\n};\n\nmodule_platform_driver(samsung_i2s_driver);\n\n \nMODULE_AUTHOR(\"Jaswinder Singh, <jassisinghbrar@gmail.com>\");\nMODULE_DESCRIPTION(\"Samsung I2S Interface\");\nMODULE_ALIAS(\"platform:samsung-i2s\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}