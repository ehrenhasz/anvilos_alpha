{
  "module_name": "midas_wm1811.c",
  "hash_id": "729456bd8da2b22e01be002e24aa4f341d3fb3c5a1eec076a5e3368b87a61f78",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/midas_wm1811.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mfd/wm8994/registers.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n#include <sound/jack.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n#include \"i2s.h\"\n#include \"../codecs/wm8994.h\"\n\n \n#define MCLK1_RATE 24000000U\n#define MCLK2_RATE 32768U\n#define DEFAULT_FLL1_RATE 11289600U\n\nstruct midas_priv {\n\tstruct regulator *reg_mic_bias;\n\tstruct regulator *reg_submic_bias;\n\tstruct gpio_desc *gpio_fm_sel;\n\tstruct gpio_desc *gpio_lineout_sel;\n\tunsigned int fll1_rate;\n\n\tstruct snd_soc_jack headset_jack;\n};\n\nstatic struct snd_soc_jack_pin headset_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int midas_start_fll1(struct snd_soc_pcm_runtime *rtd, unsigned int rate)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *aif1_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tif (!rate)\n\t\trate = priv->fll1_rate;\n\t \n\tif (!rate)\n\t\trate = DEFAULT_FLL1_RATE;\n\n\tif (rate != priv->fll1_rate && priv->fll1_rate) {\n\t\t \n\t\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t\t     MCLK2_RATE, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tdev_err(card->dev, \"Unable to switch to MCLK2: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1, WM8994_FLL_SRC_MCLK1,\n\t\t\t\t  MCLK1_RATE, rate);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"Failed to set FLL1 rate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpriv->fll1_rate = rate;\n\n\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_FLL1,\n\t\t\t\t     priv->fll1_rate, SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"Failed to set SYSCLK source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, SAMSUNG_I2S_OPCLK, 0,\n\t\t\t\t     SAMSUNG_I2S_OPCLK_PCLK);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"Failed to set OPCLK source: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int midas_stop_fll1(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *aif1_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\n\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t     MCLK2_RATE, SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"Unable to switch to MCLK2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1, 0, 0, 0);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"Unable to stop FLL1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->fll1_rate = 0;\n\n\treturn 0;\n}\n\nstatic int midas_aif1_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd\t= substream->private_data;\n\tunsigned int pll_out;\n\n\t \n\tif (params_rate(params) == 8000 || params_rate(params) == 11025)\n\t\tpll_out = params_rate(params) * 512;\n\telse\n\t\tpll_out = params_rate(params) * 256;\n\n\treturn midas_start_fll1(rtd, pll_out);\n}\n\nstatic const struct snd_soc_ops midas_aif1_ops = {\n\t.hw_params = midas_aif1_hw_params,\n};\n\n \nstatic int midas_ext_spkmode(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = snd_soc_component_update_bits(codec, WM8994_SPKOUT_MIXERS,\n\t\t\t\t  WM8994_SPKMIXR_TO_SPKOUTL_MASK,\n\t\t\t\t  WM8994_SPKMIXR_TO_SPKOUTL);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = snd_soc_component_update_bits(codec, WM8994_SPKOUT_MIXERS,\n\t\t\t\t  WM8994_SPKMIXR_TO_SPKOUTL_MASK,\n\t\t\t\t  0);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int midas_mic_bias(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn regulator_enable(priv->reg_mic_bias);\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn regulator_disable(priv->reg_mic_bias);\n\t}\n\n\treturn 0;\n}\n\nstatic int midas_submic_bias(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn regulator_enable(priv->reg_submic_bias);\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn regulator_disable(priv->reg_submic_bias);\n\t}\n\n\treturn 0;\n}\n\nstatic int midas_fm_set(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\n\tif (!priv->gpio_fm_sel)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tgpiod_set_value_cansleep(priv->gpio_fm_sel, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tgpiod_set_value_cansleep(priv->gpio_fm_sel, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int midas_line_set(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\n\tif (!priv->gpio_lineout_sel)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tgpiod_set_value_cansleep(priv->gpio_lineout_sel, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tgpiod_set_value_cansleep(priv->gpio_lineout_sel, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new midas_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"HP\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"SPK\"),\n\tSOC_DAPM_PIN_SWITCH(\"RCV\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"LINE\"),\n\tSOC_DAPM_PIN_SWITCH(\"HDMI\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"Main Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Sub Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\n\tSOC_DAPM_PIN_SWITCH(\"FM In\"),\n};\n\nstatic const struct snd_soc_dapm_widget midas_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"HP\", NULL),\n\n\tSND_SOC_DAPM_SPK(\"SPK\", midas_ext_spkmode),\n\tSND_SOC_DAPM_SPK(\"RCV\", NULL),\n\n\t \n\tSND_SOC_DAPM_LINE(\"LINE\", midas_line_set),\n\tSND_SOC_DAPM_LINE(\"HDMI\", NULL),\n\tSND_SOC_DAPM_LINE(\"FM In\", midas_fm_set),\n\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Main Mic\", midas_mic_bias),\n\tSND_SOC_DAPM_MIC(\"Sub Mic\", midas_submic_bias),\n};\n\nstatic int midas_set_bias_level(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_dapm_context *dapm,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct snd_soc_pcm_runtime *rtd = snd_soc_get_pcm_runtime(card,\n\t\t\t\t\t\t  &card->dai_link[0]);\n\tstruct snd_soc_dai *aif1_dai = asoc_rtd_to_codec(rtd, 0);\n\n\tif (dapm->dev != aif1_dai->dev)\n\t\treturn 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\treturn midas_stop_fll1(rtd);\n\tcase SND_SOC_BIAS_PREPARE:\n\t\treturn midas_start_fll1(rtd, 0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int midas_late_probe(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd = snd_soc_get_pcm_runtime(card,\n\t\t\t\t\t\t\t&card->dai_link[0]);\n\tstruct snd_soc_dai *aif1_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct midas_priv *priv = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\t \n\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2, MCLK2_RATE,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tdev_err(aif1_dai->dev, \"Failed to switch to MCLK2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_MECHANICAL |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2 |\n\t\t\t\t\t SND_JACK_BTN_3 | SND_JACK_BTN_4 | SND_JACK_BTN_5,\n\t\t\t\t\t &priv->headset_jack,\n\t\t\t\t\t headset_jack_pins,\n\t\t\t\t\t ARRAY_SIZE(headset_jack_pins));\n\tif (ret)\n\t\treturn ret;\n\n\twm8958_mic_detect(aif1_dai->component, &priv->headset_jack,\n\t\t\t  NULL, NULL, NULL, NULL);\n\treturn 0;\n}\n\nstatic struct snd_soc_dai_driver midas_ext_dai[] = {\n\t{\n\t\t.name = \"Voice call\",\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t},\n\t{\n\t\t.name = \"Bluetooth\",\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 16000,\n\t\t\t.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000),\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t},\n};\n\nstatic const struct snd_soc_component_driver midas_component = {\n\t.name\t= \"midas-audio\",\n};\n\nSND_SOC_DAILINK_DEFS(wm1811_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(wm1811_voice,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif2\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(wm1811_bt,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8994-aif3\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link midas_dai[] = {\n\t{\n\t\t.name = \"WM8994 AIF1\",\n\t\t.stream_name = \"HiFi Primary\",\n\t\t.ops = &midas_aif1_ops,\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBM_CFM,\n\t\tSND_SOC_DAILINK_REG(wm1811_hifi),\n\t}, {\n\t\t.name = \"WM1811 Voice\",\n\t\t.stream_name = \"Voice call\",\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(wm1811_voice),\n\t}, {\n\t\t.name = \"WM1811 BT\",\n\t\t.stream_name = \"Bluetooth\",\n\t\t.ignore_suspend = 1,\n\t\tSND_SOC_DAILINK_REG(wm1811_bt),\n\t},\n};\n\nstatic struct snd_soc_card midas_card = {\n\t.name = \"Midas WM1811\",\n\t.owner = THIS_MODULE,\n\n\t.dai_link = midas_dai,\n\t.num_links = ARRAY_SIZE(midas_dai),\n\t.controls = midas_controls,\n\t.num_controls = ARRAY_SIZE(midas_controls),\n\t.dapm_widgets = midas_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(midas_dapm_widgets),\n\n\t.set_bias_level = midas_set_bias_level,\n\t.late_probe = midas_late_probe,\n};\n\nstatic int midas_probe(struct platform_device *pdev)\n{\n\tstruct device_node *cpu_dai_node = NULL, *codec_dai_node = NULL;\n\tstruct device_node *cpu = NULL, *codec = NULL;\n\tstruct snd_soc_card *card = &midas_card;\n\tstruct device *dev = &pdev->dev;\n\tstatic struct snd_soc_dai_link *dai_link;\n\tstruct midas_priv *priv;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\tcard->dev = dev;\n\n\tpriv->reg_mic_bias = devm_regulator_get(dev, \"mic-bias\");\n\tif (IS_ERR(priv->reg_mic_bias)) {\n\t\tdev_err(dev, \"Failed to get mic bias regulator\\n\");\n\t\treturn PTR_ERR(priv->reg_mic_bias);\n\t}\n\n\tpriv->reg_submic_bias = devm_regulator_get(dev, \"submic-bias\");\n\tif (IS_ERR(priv->reg_submic_bias)) {\n\t\tdev_err(dev, \"Failed to get submic bias regulator\\n\");\n\t\treturn PTR_ERR(priv->reg_submic_bias);\n\t}\n\n\tpriv->gpio_fm_sel = devm_gpiod_get_optional(dev, \"fm-sel\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpio_fm_sel)) {\n\t\tdev_err(dev, \"Failed to get FM selection GPIO\\n\");\n\t\treturn PTR_ERR(priv->gpio_fm_sel);\n\t}\n\n\tpriv->gpio_lineout_sel = devm_gpiod_get_optional(dev, \"lineout-sel\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpio_lineout_sel)) {\n\t\tdev_err(dev, \"Failed to get line out selection GPIO\\n\");\n\t\treturn PTR_ERR(priv->gpio_lineout_sel);\n\t}\n\n\tret = snd_soc_of_parse_card_name(card, \"model\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Card name is not specified\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_of_parse_audio_routing(card, \"audio-routing\");\n\tif (ret < 0) {\n\t\t \n\t\tret = snd_soc_of_parse_audio_routing(card, \"samsung,audio-routing\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Audio routing invalid/unspecified\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcpu = of_get_child_by_name(dev->of_node, \"cpu\");\n\tif (!cpu)\n\t\treturn -EINVAL;\n\n\tcodec = of_get_child_by_name(dev->of_node, \"codec\");\n\tif (!codec) {\n\t\tof_node_put(cpu);\n\t\treturn -EINVAL;\n\t}\n\n\tcpu_dai_node = of_parse_phandle(cpu, \"sound-dai\", 0);\n\tof_node_put(cpu);\n\tif (!cpu_dai_node) {\n\t\tdev_err(dev, \"parsing cpu/sound-dai failed\\n\");\n\t\tof_node_put(codec);\n\t\treturn -EINVAL;\n\t}\n\n\tcodec_dai_node = of_parse_phandle(codec, \"sound-dai\", 0);\n\tof_node_put(codec);\n\tif (!codec_dai_node) {\n\t\tdev_err(dev, \"audio-codec property invalid/missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_cpu_dai_node;\n\t}\n\n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tdai_link->codecs->of_node = codec_dai_node;\n\t\tdai_link->cpus->of_node = cpu_dai_node;\n\t\tdai_link->platforms->of_node = cpu_dai_node;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &midas_component,\n\t\t\tmidas_ext_dai, ARRAY_SIZE(midas_ext_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register component: %d\\n\", ret);\n\t\tgoto put_codec_dai_node;\n\t}\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register card: %d\\n\", ret);\n\t\tgoto put_codec_dai_node;\n\t}\n\n\treturn 0;\n\nput_codec_dai_node:\n\tof_node_put(codec_dai_node);\nput_cpu_dai_node:\n\tof_node_put(cpu_dai_node);\n\treturn ret;\n}\n\nstatic const struct of_device_id midas_of_match[] = {\n\t{ .compatible = \"samsung,midas-audio\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, midas_of_match);\n\nstatic struct platform_driver midas_driver = {\n\t.driver = {\n\t\t.name = \"midas-audio\",\n\t\t.of_match_table = midas_of_match,\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = midas_probe,\n};\nmodule_platform_driver(midas_driver);\n\nMODULE_AUTHOR(\"Simon Shields <simon@lineageos.org>\");\nMODULE_DESCRIPTION(\"ASoC support for Midas\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}