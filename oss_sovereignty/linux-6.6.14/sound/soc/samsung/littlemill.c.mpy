{
  "module_name": "littlemill.c",
  "hash_id": "65dba378a7ec518c3c2f5692c0da5f91cbf262350ad72b2d17f98be36293215e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/littlemill.c",
  "human_readable_source": "\n\n\n\n\n\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/jack.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n\n#include \"../codecs/wm8994.h\"\n\nstatic int sample_rate = 44100;\n\nstatic int littlemill_set_bias_level(struct snd_soc_card *card,\n\t\t\t\t\t  struct snd_soc_dapm_context *dapm,\n\t\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *aif1_dai;\n\tint ret;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);\n\taif1_dai = asoc_rtd_to_codec(rtd, 0);\n\n\tif (dapm->dev != aif1_dai->dev)\n\t\treturn 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (dapm->bias_level == SND_SOC_BIAS_STANDBY) {\n\t\t\tret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1,\n\t\t\t\t\t\t  WM8994_FLL_SRC_MCLK2, 32768,\n\t\t\t\t\t\t  sample_rate * 512);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"Failed to start FLL: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = snd_soc_dai_set_sysclk(aif1_dai,\n\t\t\t\t\t\t     WM8994_SYSCLK_FLL1,\n\t\t\t\t\t\t     sample_rate * 512,\n\t\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"Failed to set SYSCLK: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int littlemill_set_bias_level_post(struct snd_soc_card *card,\n\t\t\t\t\t       struct snd_soc_dapm_context *dapm,\n\t\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *aif1_dai;\n\tint ret;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);\n\taif1_dai = asoc_rtd_to_codec(rtd, 0);\n\n\tif (dapm->dev != aif1_dai->dev)\n\t\treturn 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t\t     32768, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to switch away from FLL1: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1,\n\t\t\t\t\t  0, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to stop FLL1: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdapm->bias_level = level;\n\n\treturn 0;\n}\n\nstatic int littlemill_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret;\n\n\tsample_rate = params_rate(params);\n\n\tret = snd_soc_dai_set_pll(codec_dai, WM8994_FLL1,\n\t\t\t\t  WM8994_FLL_SRC_MCLK2, 32768,\n\t\t\t\t  sample_rate * 512);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to start FLL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai,\n\t\t\t\t     WM8994_SYSCLK_FLL1,\n\t\t\t\t     sample_rate * 512,\n\t\t\t\t     SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to set SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops littlemill_ops = {\n\t.hw_params = littlemill_hw_params,\n};\n\nstatic const struct snd_soc_pcm_stream baseband_params = {\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.rate_min = 8000,\n\t.rate_max = 8000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n};\n\nSND_SOC_DAILINK_DEFS(cpu,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"samsung-i2s.0\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"wm8994-codec\", \"wm8994-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"samsung-i2s.0\")));\n\nSND_SOC_DAILINK_DEFS(baseband,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"wm8994-aif2\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"wm1250-ev1.1-0027\",\n\t\t\t\t      \"wm1250-ev1\")));\n\nstatic struct snd_soc_dai_link littlemill_dai[] = {\n\t{\n\t\t.name = \"CPU\",\n\t\t.stream_name = \"CPU\",\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF\n\t\t\t\t| SND_SOC_DAIFMT_CBM_CFM,\n\t\t.ops = &littlemill_ops,\n\t\tSND_SOC_DAILINK_REG(cpu),\n\t},\n\t{\n\t\t.name = \"Baseband\",\n\t\t.stream_name = \"Baseband\",\n\t\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF\n\t\t\t\t| SND_SOC_DAIFMT_CBM_CFM,\n\t\t.ignore_suspend = 1,\n\t\t.c2c_params = &baseband_params,\n\t\t.num_c2c_params = 1,\n\t\tSND_SOC_DAILINK_REG(baseband),\n\t},\n};\n\nstatic int bbclk_ev(struct snd_soc_dapm_widget *w,\n\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_card *card = w->dapm->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *aif2_dai;\n\tint ret;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[1]);\n\taif2_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = snd_soc_dai_set_pll(aif2_dai, WM8994_FLL2,\n\t\t\t\t\t  WM8994_FLL_SRC_BCLK, 64 * 8000,\n\t\t\t\t\t  8000 * 256);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to start FLL: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_sysclk(aif2_dai, WM8994_SYSCLK_FLL2,\n\t\t\t\t\t     8000 * 256,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to set SYSCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = snd_soc_dai_set_sysclk(aif2_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t\t     32768, SND_SOC_CLOCK_IN);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to switch away from FLL2: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_pll(aif2_dai, WM8994_FLL2,\n\t\t\t\t\t  0, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to stop FLL2: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"WM1250 Input\"),\n\tSOC_DAPM_PIN_SWITCH(\"WM1250 Output\"),\n};\n\nstatic const struct snd_soc_dapm_widget widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_HP(\"Headset Mic\", NULL),\n\n\tSND_SOC_DAPM_MIC(\"AMIC\", NULL),\n\tSND_SOC_DAPM_MIC(\"DMIC\", NULL),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"Baseband Clock\", -1, SND_SOC_NOPM, 0, 0,\n\t\t\t      bbclk_ev,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route audio_paths[] = {\n\t{ \"Headphone\", NULL, \"HPOUT1L\" },\n\t{ \"Headphone\", NULL, \"HPOUT1R\" },\n\n\t{ \"AMIC\", NULL, \"MICBIAS1\" },    \n\t{ \"IN1LN\", NULL, \"AMIC\" },\n\n\t{ \"DMIC\", NULL, \"MICBIAS2\" },    \n\t{ \"DMIC1DAT\", NULL, \"DMIC\" },\n\t{ \"DMIC2DAT\", NULL, \"DMIC\" },\n\n\t{ \"AIF2CLK\", NULL, \"Baseband Clock\" },\n};\n\nstatic struct snd_soc_jack littlemill_headset;\nstatic struct snd_soc_jack_pin littlemill_headset_pins[] = {\n\t{\n\t\t.pin = \"Headphone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int littlemill_late_probe(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *aif1_dai;\n\tstruct snd_soc_dai *aif2_dai;\n\tint ret;\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[0]);\n\tcomponent = asoc_rtd_to_codec(rtd, 0)->component;\n\taif1_dai = asoc_rtd_to_codec(rtd, 0);\n\n\trtd = snd_soc_get_pcm_runtime(card, &card->dai_link[1]);\n\taif2_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t     32768, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dai_set_sysclk(aif2_dai, WM8994_SYSCLK_MCLK2,\n\t\t\t\t     32768, SND_SOC_CLOCK_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_card_jack_new_pins(card, \"Headset\",\n\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_MECHANICAL |\n\t\t\t\t\t SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t SND_JACK_BTN_2 | SND_JACK_BTN_3 |\n\t\t\t\t\t SND_JACK_BTN_4 | SND_JACK_BTN_5,\n\t\t\t\t\t &littlemill_headset,\n\t\t\t\t\t littlemill_headset_pins,\n\t\t\t\t\t ARRAY_SIZE(littlemill_headset_pins));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twm8958_mic_detect(component, &littlemill_headset, NULL, NULL, NULL, NULL);\n\n\t \n\twm8994_mic_detect(component, &littlemill_headset, 1);\n\n\treturn 0;\n}\n\nstatic struct snd_soc_card littlemill = {\n\t.name = \"Littlemill\",\n\t.owner = THIS_MODULE,\n\t.dai_link = littlemill_dai,\n\t.num_links = ARRAY_SIZE(littlemill_dai),\n\n\t.set_bias_level = littlemill_set_bias_level,\n\t.set_bias_level_post = littlemill_set_bias_level_post,\n\n\t.controls = controls,\n\t.num_controls = ARRAY_SIZE(controls),\n\t.dapm_widgets = widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(widgets),\n\t.dapm_routes = audio_paths,\n\t.num_dapm_routes = ARRAY_SIZE(audio_paths),\n\n\t.late_probe = littlemill_late_probe,\n};\n\nstatic int littlemill_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = &littlemill;\n\tint ret;\n\n\tcard->dev = &pdev->dev;\n\n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret)\n\t\tdev_err_probe(&pdev->dev, ret, \"snd_soc_register_card() failed\\n\");\n\n\treturn ret;\n}\n\nstatic struct platform_driver littlemill_driver = {\n\t.driver = {\n\t\t.name = \"littlemill\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = littlemill_probe,\n};\n\nmodule_platform_driver(littlemill_driver);\n\nMODULE_DESCRIPTION(\"Littlemill audio support\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:littlemill\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}