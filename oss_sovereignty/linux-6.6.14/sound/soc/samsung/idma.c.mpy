{
  "module_name": "idma.c",
  "hash_id": "8d729c587dd6cf8e57c6699cc8158c30f6f091f5693c760402c497a85551e518",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/samsung/idma.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"i2s.h\"\n#include \"idma.h\"\n#include \"i2s-regs.h\"\n\n#define ST_RUNNING\t\t(1<<0)\n#define ST_OPENED\t\t(1<<1)\n\nstatic const struct snd_pcm_hardware idma_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\t    SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t    SNDRV_PCM_INFO_MMAP |\n\t\t    SNDRV_PCM_INFO_MMAP_VALID |\n\t\t    SNDRV_PCM_INFO_PAUSE |\n\t\t    SNDRV_PCM_INFO_RESUME,\n\t.buffer_bytes_max = MAX_IDMA_BUFFER,\n\t.period_bytes_min = 128,\n\t.period_bytes_max = MAX_IDMA_PERIOD,\n\t.periods_min = 1,\n\t.periods_max = 2,\n};\n\nstruct idma_ctrl {\n\tspinlock_t\tlock;\n\tint\t\tstate;\n\tdma_addr_t\tstart;\n\tdma_addr_t\tpos;\n\tdma_addr_t\tend;\n\tdma_addr_t\tperiod;\n\tdma_addr_t\tperiodsz;\n\tvoid\t\t*token;\n\tvoid\t\t(*cb)(void *dt, int bytes_xfer);\n};\n\nstatic struct idma_info {\n\tspinlock_t\tlock;\n\tvoid\t\t __iomem  *regs;\n\tdma_addr_t\tlp_tx_addr;\n} idma;\n\nstatic int idma_irq;\n\nstatic void idma_getpos(dma_addr_t *src)\n{\n\t*src = idma.lp_tx_addr +\n\t\t(readl(idma.regs + I2STRNCNT) & 0xffffff) * 4;\n}\n\nstatic int idma_enqueue(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\tu32 val;\n\n\tspin_lock(&prtd->lock);\n\tprtd->token = (void *) substream;\n\tspin_unlock(&prtd->lock);\n\n\t \n\tval = idma.lp_tx_addr + prtd->periodsz;\n\twritel(val, idma.regs + I2SLVL0ADDR);\n\n\t \n\tval = idma.lp_tx_addr;\n\twritel(val, idma.regs + I2SSTR0);\n\n\t \n\tval = readl(idma.regs + I2SSIZE);\n\tval &= ~(I2SSIZE_TRNMSK << I2SSIZE_SHIFT);\n\tval |= (((runtime->dma_bytes >> 2) &\n\t\t\tI2SSIZE_TRNMSK) << I2SSIZE_SHIFT);\n\twritel(val, idma.regs + I2SSIZE);\n\n\tval = readl(idma.regs + I2SAHB);\n\tval |= AHB_INTENLVL0;\n\twritel(val, idma.regs + I2SAHB);\n\n\treturn 0;\n}\n\nstatic void idma_setcallbk(struct snd_pcm_substream *substream,\n\t\t\t\tvoid (*cb)(void *, int))\n{\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\n\tspin_lock(&prtd->lock);\n\tprtd->cb = cb;\n\tspin_unlock(&prtd->lock);\n}\n\nstatic void idma_control(int op)\n{\n\tu32 val = readl(idma.regs + I2SAHB);\n\n\tspin_lock(&idma.lock);\n\n\tswitch (op) {\n\tcase LPAM_DMA_START:\n\t\tval |= (AHB_INTENLVL0 | AHB_DMAEN);\n\t\tbreak;\n\tcase LPAM_DMA_STOP:\n\t\tval &= ~(AHB_INTENLVL0 | AHB_DMAEN);\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&idma.lock);\n\t\treturn;\n\t}\n\n\twritel(val, idma.regs + I2SAHB);\n\tspin_unlock(&idma.lock);\n}\n\nstatic void idma_done(void *id, int bytes_xfer)\n{\n\tstruct snd_pcm_substream *substream = id;\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\n\tif (prtd && (prtd->state & ST_RUNNING))\n\t\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int idma_hw_params(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\tu32 mod = readl(idma.regs + I2SMOD);\n\tu32 ahb = readl(idma.regs + I2SAHB);\n\n\tahb |= (AHB_DMARLD | AHB_INTMASK);\n\tmod |= MOD_TXS_IDMA;\n\twritel(ahb, idma.regs + I2SAHB);\n\twritel(mod, idma.regs + I2SMOD);\n\n\tsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\n\truntime->dma_bytes = params_buffer_bytes(params);\n\n\tprtd->start = prtd->pos = runtime->dma_addr;\n\tprtd->period = params_periods(params);\n\tprtd->periodsz = params_period_bytes(params);\n\tprtd->end = runtime->dma_addr + runtime->dma_bytes;\n\n\tidma_setcallbk(substream, idma_done);\n\n\treturn 0;\n}\n\nstatic int idma_hw_free(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\n\treturn 0;\n}\n\nstatic int idma_prepare(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\n\tprtd->pos = prtd->start;\n\n\t \n\tidma_control(LPAM_DMA_STOP);\n\tidma_enqueue(substream);\n\n\treturn 0;\n}\n\nstatic int idma_trigger(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct idma_ctrl *prtd = substream->runtime->private_data;\n\tint ret = 0;\n\n\tspin_lock(&prtd->lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tprtd->state |= ST_RUNNING;\n\t\tidma_control(LPAM_DMA_START);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tprtd->state &= ~ST_RUNNING;\n\t\tidma_control(LPAM_DMA_STOP);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&prtd->lock);\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t\nidma_pointer(struct snd_soc_component *component,\n\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct idma_ctrl *prtd = runtime->private_data;\n\tdma_addr_t src;\n\tunsigned long res;\n\n\tspin_lock(&prtd->lock);\n\n\tidma_getpos(&src);\n\tres = src - prtd->start;\n\n\tspin_unlock(&prtd->lock);\n\n\treturn bytes_to_frames(substream->runtime, res);\n}\n\nstatic int idma_mmap(struct snd_soc_component *component,\n\t\t     struct snd_pcm_substream *substream,\n\tstruct vm_area_struct *vma)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long size, offset;\n\n\t \n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tsize = vma->vm_end - vma->vm_start;\n\toffset = vma->vm_pgoff << PAGE_SHIFT;\n\treturn io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t(runtime->dma_addr + offset) >> PAGE_SHIFT,\n\t\t\tsize, vma->vm_page_prot);\n}\n\nstatic irqreturn_t iis_irq(int irqno, void *dev_id)\n{\n\tstruct idma_ctrl *prtd = (struct idma_ctrl *)dev_id;\n\tu32 iisahb, val, addr;\n\n\tiisahb  = readl(idma.regs + I2SAHB);\n\n\tval = (iisahb & AHB_LVL0INT) ? AHB_CLRLVL0INT : 0;\n\n\tif (val) {\n\t\tiisahb |= val;\n\t\twritel(iisahb, idma.regs + I2SAHB);\n\n\t\taddr = readl(idma.regs + I2SLVL0ADDR) - idma.lp_tx_addr;\n\t\taddr += prtd->periodsz;\n\t\taddr %= (u32)(prtd->end - prtd->start);\n\t\taddr += idma.lp_tx_addr;\n\n\t\twritel(addr, idma.regs + I2SLVL0ADDR);\n\n\t\tif (prtd->cb)\n\t\t\tprtd->cb(prtd->token, prtd->period);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int idma_open(struct snd_soc_component *component,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct idma_ctrl *prtd;\n\tint ret;\n\n\tsnd_soc_set_runtime_hwparams(substream, &idma_hardware);\n\n\tprtd = kzalloc(sizeof(struct idma_ctrl), GFP_KERNEL);\n\tif (prtd == NULL)\n\t\treturn -ENOMEM;\n\n\tret = request_irq(idma_irq, iis_irq, 0, \"i2s\", prtd);\n\tif (ret < 0) {\n\t\tpr_err(\"fail to claim i2s irq , ret = %d\\n\", ret);\n\t\tkfree(prtd);\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&prtd->lock);\n\n\truntime->private_data = prtd;\n\n\treturn 0;\n}\n\nstatic int idma_close(struct snd_soc_component *component,\n\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct idma_ctrl *prtd = runtime->private_data;\n\n\tfree_irq(idma_irq, prtd);\n\n\tif (!prtd)\n\t\tpr_err(\"idma_close called with prtd == NULL\\n\");\n\n\tkfree(prtd);\n\n\treturn 0;\n}\n\nstatic void idma_free(struct snd_soc_component *component,\n\t\t      struct snd_pcm *pcm)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_dma_buffer *buf;\n\n\tsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\tif (!substream)\n\t\treturn;\n\n\tbuf = &substream->dma_buffer;\n\tif (!buf->area)\n\t\treturn;\n\n\tiounmap((void __iomem *)buf->area);\n\n\tbuf->area = NULL;\n\tbuf->addr = 0;\n}\n\nstatic int preallocate_idma_buffer(struct snd_pcm *pcm, int stream)\n{\n\tstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\n\tstruct snd_dma_buffer *buf = &substream->dma_buffer;\n\n\tbuf->dev.dev = pcm->card->dev;\n\tbuf->private_data = NULL;\n\n\t \n\tbuf->dev.type = SNDRV_DMA_TYPE_CONTINUOUS;\n\tbuf->addr = idma.lp_tx_addr;\n\tbuf->bytes = idma_hardware.buffer_bytes_max;\n\tbuf->area = (unsigned char * __force)ioremap(buf->addr, buf->bytes);\n\tif (!buf->area)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int idma_new(struct snd_soc_component *component,\n\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\n\t\tret = preallocate_idma_buffer(pcm,\n\t\t\t\tSNDRV_PCM_STREAM_PLAYBACK);\n\t}\n\n\treturn ret;\n}\n\nvoid idma_reg_addr_init(void __iomem *regs, dma_addr_t addr)\n{\n\tspin_lock_init(&idma.lock);\n\tidma.regs = regs;\n\tidma.lp_tx_addr = addr;\n}\nEXPORT_SYMBOL_GPL(idma_reg_addr_init);\n\nstatic const struct snd_soc_component_driver asoc_idma_platform = {\n\t.open\t\t= idma_open,\n\t.close\t\t= idma_close,\n\t.trigger\t= idma_trigger,\n\t.pointer\t= idma_pointer,\n\t.mmap\t\t= idma_mmap,\n\t.hw_params\t= idma_hw_params,\n\t.hw_free\t= idma_hw_free,\n\t.prepare\t= idma_prepare,\n\t.pcm_construct\t= idma_new,\n\t.pcm_destruct\t= idma_free,\n};\n\nstatic int asoc_idma_platform_probe(struct platform_device *pdev)\n{\n\tidma_irq = platform_get_irq(pdev, 0);\n\tif (idma_irq < 0)\n\t\treturn idma_irq;\n\n\treturn devm_snd_soc_register_component(&pdev->dev, &asoc_idma_platform,\n\t\t\t\t\t       NULL, 0);\n}\n\nstatic struct platform_driver asoc_idma_driver = {\n\t.driver = {\n\t\t.name = \"samsung-idma\",\n\t},\n\n\t.probe = asoc_idma_platform_probe,\n};\n\nmodule_platform_driver(asoc_idma_driver);\n\nMODULE_AUTHOR(\"Jaswinder Singh, <jassisinghbrar@gmail.com>\");\nMODULE_DESCRIPTION(\"Samsung ASoC IDMA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}