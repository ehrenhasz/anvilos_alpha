{
  "module_name": "soc-devres.c",
  "hash_id": "b1fd7868276fe5adf062b7cd704fb3916aa1559a19961fa3f8e9d190c37a22e1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-devres.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\nstatic void devm_dai_release(struct device *dev, void *res)\n{\n\tsnd_soc_unregister_dai(*(struct snd_soc_dai **)res);\n}\n\n \nstruct snd_soc_dai *devm_snd_soc_register_dai(struct device *dev,\n\t\t\t\t\t      struct snd_soc_component *component,\n\t\t\t\t\t      struct snd_soc_dai_driver *dai_drv,\n\t\t\t\t\t      bool legacy_dai_naming)\n{\n\tstruct snd_soc_dai **ptr;\n\tstruct snd_soc_dai *dai;\n\n\tptr = devres_alloc(devm_dai_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\tdai = snd_soc_register_dai(component, dai_drv, legacy_dai_naming);\n\tif (dai) {\n\t\t*ptr = dai;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn dai;\n}\nEXPORT_SYMBOL_GPL(devm_snd_soc_register_dai);\n\nstatic void devm_component_release(struct device *dev, void *res)\n{\n\tconst struct snd_soc_component_driver **cmpnt_drv = res;\n\n\tsnd_soc_unregister_component_by_driver(dev, *cmpnt_drv);\n}\n\n \nint devm_snd_soc_register_component(struct device *dev,\n\t\t\t const struct snd_soc_component_driver *cmpnt_drv,\n\t\t\t struct snd_soc_dai_driver *dai_drv, int num_dai)\n{\n\tconst struct snd_soc_component_driver **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_component_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_register_component(dev, cmpnt_drv, dai_drv, num_dai);\n\tif (ret == 0) {\n\t\t*ptr = cmpnt_drv;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_snd_soc_register_component);\n\nstatic void devm_card_release(struct device *dev, void *res)\n{\n\tsnd_soc_unregister_card(*(struct snd_soc_card **)res);\n}\n\n \nint devm_snd_soc_register_card(struct device *dev, struct snd_soc_card *card)\n{\n\tstruct snd_soc_card **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_card_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_register_card(card);\n\tif (ret == 0) {\n\t\t*ptr = card;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_snd_soc_register_card);\n\n#ifdef CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM\n\nstatic void devm_dmaengine_pcm_release(struct device *dev, void *res)\n{\n\tsnd_dmaengine_pcm_unregister(*(struct device **)res);\n}\n\n \nint devm_snd_dmaengine_pcm_register(struct device *dev,\n\tconst struct snd_dmaengine_pcm_config *config, unsigned int flags)\n{\n\tstruct device **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_dmaengine_pcm_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = snd_dmaengine_pcm_register(dev, config, flags);\n\tif (ret == 0) {\n\t\t*ptr = dev;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_snd_dmaengine_pcm_register);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}