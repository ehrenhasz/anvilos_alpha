{
  "module_name": "kirkwood-dma.c",
  "hash_id": "4c35e447c9329aca3161be357b0fb5e5974fd6252474200d9ca77d495c2010f7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/kirkwood/kirkwood-dma.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/mbus.h>\n#include <sound/soc.h>\n#include \"kirkwood.h\"\n\nstatic struct kirkwood_dma_data *kirkwood_priv(struct snd_pcm_substream *subs)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = subs->private_data;\n\treturn snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(soc_runtime, 0));\n}\n\nstatic const struct snd_pcm_hardware kirkwood_dma_snd_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.buffer_bytes_max\t= KIRKWOOD_SND_MAX_BUFFER_BYTES,\n\t.period_bytes_min\t= KIRKWOOD_SND_MIN_PERIOD_BYTES,\n\t.period_bytes_max\t= KIRKWOOD_SND_MAX_PERIOD_BYTES,\n\t.periods_min\t\t= KIRKWOOD_SND_MIN_PERIODS,\n\t.periods_max\t\t= KIRKWOOD_SND_MAX_PERIODS,\n\t.fifo_size\t\t= 0,\n};\n\nstatic irqreturn_t kirkwood_dma_irq(int irq, void *dev_id)\n{\n\tstruct kirkwood_dma_data *priv = dev_id;\n\tunsigned long mask, status, cause;\n\n\tmask = readl(priv->io + KIRKWOOD_INT_MASK);\n\tstatus = readl(priv->io + KIRKWOOD_INT_CAUSE) & mask;\n\n\tcause = readl(priv->io + KIRKWOOD_ERR_CAUSE);\n\tif (unlikely(cause)) {\n\t\tprintk(KERN_WARNING \"%s: got err interrupt 0x%lx\\n\",\n\t\t\t\t__func__, cause);\n\t\twritel(cause, priv->io + KIRKWOOD_ERR_CAUSE);\n\t}\n\n\t \n\tif (status & ~(KIRKWOOD_INT_CAUSE_PLAY_BYTES | \\\n\t\t\tKIRKWOOD_INT_CAUSE_REC_BYTES)) {\n\t\tprintk(KERN_WARNING \"%s: unexpected interrupt %lx\\n\",\n\t\t\t__func__, status);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(status, priv->io + KIRKWOOD_INT_CAUSE);\n\n\tif (status & KIRKWOOD_INT_CAUSE_PLAY_BYTES)\n\t\tsnd_pcm_period_elapsed(priv->substream_play);\n\n\tif (status & KIRKWOOD_INT_CAUSE_REC_BYTES)\n\t\tsnd_pcm_period_elapsed(priv->substream_rec);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nkirkwood_dma_conf_mbus_windows(void __iomem *base, int win,\n\t\t\t       unsigned long dma,\n\t\t\t       const struct mbus_dram_target_info *dram)\n{\n\tint i;\n\n\t \n\twritel(0, base + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\n\twritel(0, base + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\n\n\t \n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = &dram->cs[i];\n\t\tif ((cs->base & 0xffff0000) < (dma & 0xffff0000)) {\n\t\t\twritel(cs->base & 0xffff0000,\n\t\t\t\tbase + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\n\t\t\twritel(((cs->size - 1) & 0xffff0000) |\n\t\t\t\t(cs->mbus_attr << 8) |\n\t\t\t\t(dram->mbus_dram_target_id << 4) | 1,\n\t\t\t\tbase + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\n\t\t}\n\t}\n}\n\nstatic int kirkwood_dma_open(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\n\n\tsnd_soc_set_runtime_hwparams(substream, &kirkwood_dma_snd_hw);\n\n\t \n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\tpriv->burst * 2,\n\t\t\tKIRKWOOD_AUDIO_BUF_MAX-1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\tpriv->burst);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t priv->burst);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!priv->substream_play && !priv->substream_rec) {\n\t\terr = request_irq(priv->irq, kirkwood_dma_irq, IRQF_SHARED,\n\t\t\t\t  \"kirkwood-i2s\", priv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\twritel((unsigned int)-1, priv->io + KIRKWOOD_ERR_MASK);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (priv->substream_play)\n\t\t\treturn -EBUSY;\n\t\tpriv->substream_play = substream;\n\t} else {\n\t\tif (priv->substream_rec)\n\t\t\treturn -EBUSY;\n\t\tpriv->substream_rec = substream;\n\t}\n\n\treturn 0;\n}\n\nstatic int kirkwood_dma_close(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\n\n\tif (!priv)\n\t\treturn 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tpriv->substream_play = NULL;\n\telse\n\t\tpriv->substream_rec = NULL;\n\n\tif (!priv->substream_play && !priv->substream_rec) {\n\t\twritel(0, priv->io + KIRKWOOD_ERR_MASK);\n\t\tfree_irq(priv->irq, priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int kirkwood_dma_hw_params(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\n\tconst struct mbus_dram_target_info *dram = mv_mbus_dram_info();\n\tunsigned long addr = substream->runtime->dma_addr;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tkirkwood_dma_conf_mbus_windows(priv->io,\n\t\t\tKIRKWOOD_PLAYBACK_WIN, addr, dram);\n\telse\n\t\tkirkwood_dma_conf_mbus_windows(priv->io,\n\t\t\tKIRKWOOD_RECORD_WIN, addr, dram);\n\treturn 0;\n}\n\nstatic int kirkwood_dma_prepare(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\n\tunsigned long size, count;\n\n\t \n\tsize = frames_to_bytes(runtime, runtime->buffer_size);\n\tsize = (size>>2)-1;\n\tcount = snd_pcm_lib_period_bytes(substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\twritel(count, priv->io + KIRKWOOD_PLAY_BYTE_INT_COUNT);\n\t\twritel(runtime->dma_addr, priv->io + KIRKWOOD_PLAY_BUF_ADDR);\n\t\twritel(size, priv->io + KIRKWOOD_PLAY_BUF_SIZE);\n\t} else {\n\t\twritel(count, priv->io + KIRKWOOD_REC_BYTE_INT_COUNT);\n\t\twritel(runtime->dma_addr, priv->io + KIRKWOOD_REC_BUF_ADDR);\n\t\twritel(size, priv->io + KIRKWOOD_REC_BUF_SIZE);\n\t}\n\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t kirkwood_dma_pointer(\n\tstruct snd_soc_component *component,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\n\tsnd_pcm_uframes_t count;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tcount = bytes_to_frames(substream->runtime,\n\t\t\treadl(priv->io + KIRKWOOD_PLAY_BYTE_COUNT));\n\telse\n\t\tcount = bytes_to_frames(substream->runtime,\n\t\t\treadl(priv->io + KIRKWOOD_REC_BYTE_COUNT));\n\n\treturn count;\n}\n\nstatic int kirkwood_dma_new(struct snd_soc_component *component,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tsize_t size = kirkwood_dma_snd_hw.buffer_bytes_max;\n\tstruct snd_card *card = rtd->card->snd_card;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, size, size);\n\n\treturn 0;\n}\n\nconst struct snd_soc_component_driver kirkwood_soc_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= kirkwood_dma_open,\n\t.close\t\t= kirkwood_dma_close,\n\t.hw_params\t= kirkwood_dma_hw_params,\n\t.prepare\t= kirkwood_dma_prepare,\n\t.pointer\t= kirkwood_dma_pointer,\n\t.pcm_construct\t= kirkwood_dma_new,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}