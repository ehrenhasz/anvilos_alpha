{
  "module_name": "siu_dai.c",
  "hash_id": "519562eabcd942ab63a22bdb8b5b516e82b46765abbeba3c3c147dea92e7f186",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/siu_dai.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <asm/clock.h>\n#include <asm/siu.h>\n\n#include <sound/control.h>\n#include <sound/soc.h>\n\n#include \"siu.h\"\n\n \n#if defined(CONFIG_CPU_SUBTYPE_SH7722)\n# define SIU_MAX_VOLUME\t\t0x1000\n#else\n# define SIU_MAX_VOLUME\t\t0x7fff\n#endif\n\n#define PRAM_SIZE\t0x2000\n#define XRAM_SIZE\t0x800\n#define YRAM_SIZE\t0x800\n\n#define XRAM_OFFSET\t0x4000\n#define YRAM_OFFSET\t0x6000\n#define REG_OFFSET\t0xc000\n\n#define PLAYBACK_ENABLED\t1\n#define CAPTURE_ENABLED\t\t2\n\n#define VOLUME_CAPTURE\t\t0\n#define VOLUME_PLAYBACK\t\t1\n#define DFLT_VOLUME_LEVEL\t0x08000800\n\n \nstruct format_flag {\n\tu32\ti2s;\n\tu32\tpcm;\n\tu32\tspdif;\n\tu32\tmask;\n};\n\nstruct port_flag {\n\tstruct format_flag\tplayback;\n\tstruct format_flag\tcapture;\n};\n\nstruct siu_info *siu_i2s_data;\n\nstatic struct port_flag siu_flags[SIU_PORT_NUM] = {\n\t[SIU_PORT_A] = {\n\t\t.playback = {\n\t\t\t.i2s\t= 0x50000000,\n\t\t\t.pcm\t= 0x40000000,\n\t\t\t.spdif\t= 0x80000000,\t \n\t\t\t.mask\t= 0xd0000000,\n\t\t},\n\t\t.capture = {\n\t\t\t.i2s\t= 0x05000000,\n\t\t\t.pcm\t= 0x04000000,\n\t\t\t.spdif\t= 0x08000000,\n\t\t\t.mask\t= 0x0d000000,\n\t\t},\n\t},\n\t[SIU_PORT_B] = {\n\t\t.playback = {\n\t\t\t.i2s\t= 0x00500000,\n\t\t\t.pcm\t= 0x00400000,\n\t\t\t.spdif\t= 0,\t\t \n\t\t\t.mask\t= 0x00500000,\n\t\t},\n\t\t.capture = {\n\t\t\t.i2s\t= 0x00050000,\n\t\t\t.pcm\t= 0x00040000,\n\t\t\t.spdif\t= 0,\t\t \n\t\t\t.mask\t= 0x00050000,\n\t\t},\n\t},\n};\n\nstatic void siu_dai_start(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\n\tdev_dbg(port_info->pcm->card->dev, \"%s\\n\", __func__);\n\n\t \n\tsiu_write32(base + SIU_SRCTL, 0);\n\n\t \n\tudelay(1);\n\n\tport_info->stfifo = 0;\n\tport_info->trdat = 0;\n\n\t \n\tsiu_write32(base + SIU_SRCTL, 0x301);\n\n\t \n\tsiu_write32(base + SIU_CKCTL, 0x40400000);\n\n\t \n\tsiu_write32(base + SIU_BRGASEL, 0);\n\tsiu_write32(base + SIU_BRRA, 0);\n\n\t \n\tsiu_write32(base + SIU_BRGBSEL, 1);\n\tsiu_write32(base + SIU_BRRB, 0);\n\n\tsiu_write32(base + SIU_IFCTL, 0x44440000);\n\n\t \n\tsiu_write32(base + SIU_SFORM, 0x0c0c0000);\n\n\t \n\tsiu_write32(base + SIU_SBDVCA, port_info->playback.volume);\n\tsiu_write32(base + SIU_SBDVCB, port_info->capture.volume);\n}\n\nstatic void siu_dai_stop(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\n\t \n\tsiu_write32(base + SIU_SRCTL, 0);\n}\n\nstatic void siu_dai_spbAselect(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct siu_firmware *fw = &info->fw;\n\tu32 *ydef = fw->yram0;\n\tu32 idx;\n\n\t \n\tif (!info->port_id)\n\t\tidx = 1;\t\t \n\telse\n\t\tidx = 2;\t\t \n\n\tydef[0] = (fw->spbpar[idx].ab1a << 16) |\n\t\t(fw->spbpar[idx].ab0a << 8) |\n\t\t(fw->spbpar[idx].dir << 7) | 3;\n\tydef[1] = fw->yram0[1];\t \n\tydef[2] = (16 / 2) << 24;\n\tydef[3] = fw->yram0[3];\t \n\tydef[4] = fw->yram0[4];\t \n\tydef[7] = fw->spbpar[idx].event;\n\tport_info->stfifo |= fw->spbpar[idx].stfifo;\n\tport_info->trdat |= fw->spbpar[idx].trdat;\n}\n\nstatic void siu_dai_spbBselect(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct siu_firmware *fw = &info->fw;\n\tu32 *ydef = fw->yram0;\n\tu32 idx;\n\n\t \n\tif (!info->port_id)\n\t\tidx = 7;\t\t \n\telse\n\t\tidx = 8;\t\t \n\n\tydef[5] = (fw->spbpar[idx].ab1a << 16) |\n\t\t(fw->spbpar[idx].ab0a << 8) | 1;\n\tydef[6] = fw->spbpar[idx].event;\n\tport_info->stfifo |= fw->spbpar[idx].stfifo;\n\tport_info->trdat |= fw->spbpar[idx].trdat;\n}\n\nstatic void siu_dai_open(struct siu_stream *siu_stream)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tu32 srctl, ifctl;\n\n\tsrctl = siu_read32(base + SIU_SRCTL);\n\tifctl = siu_read32(base + SIU_IFCTL);\n\n\tswitch (info->port_id) {\n\tcase SIU_PORT_A:\n\t\t \n\t\tsrctl |= 0x200;\n\t\tifctl &= ~0xc2;\n\t\tbreak;\n\tcase SIU_PORT_B:\n\t\t \n\t\tsrctl |= 0x100;\n\t\tifctl &= ~0x31;\n\t\tbreak;\n\t}\n\n\tsiu_write32(base + SIU_SRCTL, srctl);\n\t \n\tsiu_write32(base + SIU_IFCTL, ifctl);\n}\n\n \nstatic void siu_dai_pcmdatapack(struct siu_stream *siu_stream)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tu32 dpak;\n\n\tdpak = siu_read32(base + SIU_DPAK);\n\n\tswitch (info->port_id) {\n\tcase SIU_PORT_A:\n\t\tdpak &= ~0xc0000000;\n\t\tbreak;\n\tcase SIU_PORT_B:\n\t\tdpak &= ~0x00c00000;\n\t\tbreak;\n\t}\n\n\tsiu_write32(base + SIU_DPAK, dpak);\n}\n\nstatic int siu_dai_spbstart(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_firmware *fw = &info->fw;\n\tu32 *ydef = fw->yram0;\n\tint cnt;\n\tu32 __iomem *add;\n\tu32 *ptr;\n\n\t \n\tptr = fw->pram0;\n\tadd = info->pram;\n\tfor (cnt = 0; cnt < PRAM0_SIZE; cnt++, add++, ptr++)\n\t\tsiu_write32(add, *ptr);\n\n\tptr = fw->pram1;\n\tadd = info->pram + (0x0100 / sizeof(u32));\n\tfor (cnt = 0; cnt < PRAM1_SIZE; cnt++, add++, ptr++)\n\t\tsiu_write32(add, *ptr);\n\n\t \n\tadd = info->xram;\n\tfor (cnt = 0; cnt < XRAM0_SIZE + XRAM1_SIZE + XRAM2_SIZE; cnt++, add++)\n\t\tsiu_write32(add, 0);\n\n\t \n\tadd = info->yram;\n\tfor (cnt = 0; cnt < YRAM_DEF_SIZE; cnt++, add++)\n\t\tsiu_write32(add, ydef[cnt]);\n\n\t \n\tadd = info->yram + (0x0200 / sizeof(u32));\n\tfor (cnt = 0; cnt < YRAM_FIR_SIZE; cnt++, add++)\n\t\tsiu_write32(add, fw->yram_fir_coeff[cnt]);\n\n\t \n\tadd = info->yram + (0x0600 / sizeof(u32));\n\tfor (cnt = 0; cnt < YRAM_IIR_SIZE; cnt++, add++)\n\t\tsiu_write32(add, 0);\n\n\tsiu_write32(base + SIU_TRDAT, port_info->trdat);\n\tport_info->trdat = 0x0;\n\n\n\t \n\tsiu_write32(base + SIU_SBACTIV, 0);\n\t \n\tsiu_write32(base + SIU_SBCTL, 0xc0000000);\n\t \n\tcnt = 0x10000;\n\twhile (--cnt && siu_read32(base + SIU_SBCTL) != 0x80000000)\n\t\tcpu_relax();\n\n\tif (!cnt)\n\t\treturn -EBUSY;\n\n\t \n\tsiu_write32(base + SIU_SBPSET, 0x00400000);\n\t \n\tsiu_write32(base + SIU_SBACTIV, 0xc0000000);\n\n\treturn 0;\n}\n\nstatic void siu_dai_spbstop(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\n\tsiu_write32(base + SIU_SBACTIV, 0);\n\t \n\tsiu_write32(base + SIU_SBCTL, 0);\n\n\tport_info->stfifo = 0;\n}\n\n \n\n \nstatic const struct snd_pcm_hardware siu_dai_pcm_hw = {\n\t.info\t\t\t= SNDRV_PCM_INFO_INTERLEAVED,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16,\n\t.rates\t\t\t= SNDRV_PCM_RATE_8000_48000,\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 2,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= SIU_BUFFER_BYTES_MAX,\n\t.period_bytes_min\t= SIU_PERIOD_BYTES_MIN,\n\t.period_bytes_max\t= SIU_PERIOD_BYTES_MAX,\n\t.periods_min\t\t= SIU_PERIODS_MIN,\n\t.periods_max\t\t= SIU_PERIODS_MAX,\n};\n\nstatic int siu_dai_info_volume(struct snd_kcontrol *kctrl,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\n\n\tdev_dbg(port_info->pcm->card->dev, \"%s\\n\", __func__);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SIU_MAX_VOLUME;\n\n\treturn 0;\n}\n\nstatic int siu_dai_get_volume(struct snd_kcontrol *kctrl,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\n\tstruct device *dev = port_info->pcm->card->dev;\n\tu32 vol;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tswitch (kctrl->private_value) {\n\tcase VOLUME_PLAYBACK:\n\t\t \n\t\tvol = port_info->playback.volume;\n\t\tucontrol->value.integer.value[0] = vol & 0xffff;\n\t\tucontrol->value.integer.value[1] = vol >> 16 & 0xffff;\n\t\tbreak;\n\tcase VOLUME_CAPTURE:\n\t\t \n\t\tvol = port_info->capture.volume;\n\t\tucontrol->value.integer.value[0] = vol & 0xffff;\n\t\tucontrol->value.integer.value[1] = vol >> 16 & 0xffff;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s() invalid private_value=%ld\\n\",\n\t\t\t__func__, kctrl->private_value);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int siu_dai_put_volume(struct snd_kcontrol *kctrl,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\n\tstruct device *dev = port_info->pcm->card->dev;\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tu32 new_vol;\n\tu32 cur_vol;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tif (ucontrol->value.integer.value[0] < 0 ||\n\t    ucontrol->value.integer.value[0] > SIU_MAX_VOLUME ||\n\t    ucontrol->value.integer.value[1] < 0 ||\n\t    ucontrol->value.integer.value[1] > SIU_MAX_VOLUME)\n\t\treturn -EINVAL;\n\n\tnew_vol = ucontrol->value.integer.value[0] |\n\t\tucontrol->value.integer.value[1] << 16;\n\n\t \n\tswitch (kctrl->private_value) {\n\tcase VOLUME_PLAYBACK:\n\t\t \n\t\tcur_vol = port_info->playback.volume;\n\t\tsiu_write32(base + SIU_SBDVCA, new_vol);\n\t\tport_info->playback.volume = new_vol;\n\t\tbreak;\n\tcase VOLUME_CAPTURE:\n\t\t \n\t\tcur_vol = port_info->capture.volume;\n\t\tsiu_write32(base + SIU_SBDVCB, new_vol);\n\t\tport_info->capture.volume = new_vol;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s() invalid private_value=%ld\\n\",\n\t\t\t__func__, kctrl->private_value);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cur_vol != new_vol)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new playback_controls = {\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t\t= \"PCM Playback Volume\",\n\t.index\t\t= 0,\n\t.info\t\t= siu_dai_info_volume,\n\t.get\t\t= siu_dai_get_volume,\n\t.put\t\t= siu_dai_put_volume,\n\t.private_value\t= VOLUME_PLAYBACK,\n};\n\nstatic const struct snd_kcontrol_new capture_controls = {\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t\t= \"PCM Capture Volume\",\n\t.index\t\t= 0,\n\t.info\t\t= siu_dai_info_volume,\n\t.get\t\t= siu_dai_get_volume,\n\t.put\t\t= siu_dai_put_volume,\n\t.private_value\t= VOLUME_CAPTURE,\n};\n\nint siu_init_port(int port, struct siu_port **port_info, struct snd_card *card)\n{\n\tstruct device *dev = card->dev;\n\tstruct snd_kcontrol *kctrl;\n\tint ret;\n\n\t*port_info = kzalloc(sizeof(**port_info), GFP_KERNEL);\n\tif (!*port_info)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"%s: port #%d@%p\\n\", __func__, port, *port_info);\n\n\t(*port_info)->playback.volume = DFLT_VOLUME_LEVEL;\n\t(*port_info)->capture.volume = DFLT_VOLUME_LEVEL;\n\n\t \n\tkctrl = snd_ctl_new1(&playback_controls, *port_info);\n\tret = snd_ctl_add(card, kctrl);\n\tif (ret < 0)\n\t\tdev_err(dev,\n\t\t\t\"failed to add playback controls %p port=%d err=%d\\n\",\n\t\t\tkctrl, port, ret);\n\n\tkctrl = snd_ctl_new1(&capture_controls, *port_info);\n\tret = snd_ctl_add(card, kctrl);\n\tif (ret < 0)\n\t\tdev_err(dev,\n\t\t\t\"failed to add capture controls %p port=%d err=%d\\n\",\n\t\t\tkctrl, port, ret);\n\n\treturn 0;\n}\n\nvoid siu_free_port(struct siu_port *port_info)\n{\n\tkfree(port_info);\n}\n\nstatic int siu_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct siu_port\t*port_info = siu_port_info(substream);\n\tint ret;\n\n\tdev_dbg(substream->pcm->card->dev, \"%s: port=%d@%p\\n\", __func__,\n\t\tinfo->port_id, port_info);\n\n\tsnd_soc_set_runtime_hwparams(substream, &siu_dai_pcm_hw);\n\n\tret = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tsiu_dai_start(port_info);\n\n\treturn 0;\n}\n\nstatic void siu_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\n\tstruct siu_port\t*port_info = siu_port_info(substream);\n\n\tdev_dbg(substream->pcm->card->dev, \"%s: port=%d@%p\\n\", __func__,\n\t\tinfo->port_id, port_info);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_info->play_cap &= ~PLAYBACK_ENABLED;\n\telse\n\t\tport_info->play_cap &= ~CAPTURE_ENABLED;\n\n\t \n\tif (!port_info->play_cap) {\n\t\t \n\t\tif (WARN_ON(port_info->playback.rw_flg || port_info->capture.rw_flg))\n\t\t\treturn;\n\t\tsiu_dai_spbstop(port_info);\n\t\tsiu_dai_stop(port_info);\n\t}\n}\n\n \nstatic int siu_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct siu_port *port_info = siu_port_info(substream);\n\tstruct siu_stream *siu_stream;\n\tint self, ret;\n\n\tdev_dbg(substream->pcm->card->dev,\n\t\t\"%s: port %d, active streams %lx, %d channels\\n\",\n\t\t__func__, info->port_id, port_info->play_cap, rt->channels);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tself = PLAYBACK_ENABLED;\n\t\tsiu_stream = &port_info->playback;\n\t} else {\n\t\tself = CAPTURE_ENABLED;\n\t\tsiu_stream = &port_info->capture;\n\t}\n\n\t \n\tif (!port_info->play_cap) {\n\t\tsiu_stream->rw_flg = 0;\t \n\n\t\tsiu_dai_spbAselect(port_info);\n\t\tsiu_dai_spbBselect(port_info);\n\n\t\tsiu_dai_open(siu_stream);\n\n\t\tsiu_dai_pcmdatapack(siu_stream);\n\n\t\tret = siu_dai_spbstart(port_info);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tport_info->play_cap |= self;\n\nfail:\n\treturn ret;\n}\n\n \nstatic int siu_dai_set_fmt(struct snd_soc_dai *dai,\n\t\t\t   unsigned int fmt)\n{\n\tstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\n\tu32 __iomem *base = info->reg;\n\tu32 ifctl;\n\n\tdev_dbg(dai->dev, \"%s: fmt 0x%x on port %d\\n\",\n\t\t__func__, fmt, info->port_id);\n\n\tif (info->port_id < 0)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tifctl = siu_flags[info->port_id].playback.i2s |\n\t\t\tsiu_flags[info->port_id].capture.i2s;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tifctl = siu_flags[info->port_id].playback.pcm |\n\t\t\tsiu_flags[info->port_id].capture.pcm;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tifctl |= ~(siu_flags[info->port_id].playback.mask |\n\t\t   siu_flags[info->port_id].capture.mask) &\n\t\tsiu_read32(base + SIU_IFCTL);\n\tsiu_write32(base + SIU_IFCTL, ifctl);\n\n\treturn 0;\n}\n\nstatic int siu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t      unsigned int freq, int dir)\n{\n\tstruct clk *siu_clk, *parent_clk;\n\tchar *siu_name, *parent_name;\n\tint ret;\n\n\tif (dir != SND_SOC_CLOCK_IN)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dai->dev, \"%s: using clock %d\\n\", __func__, clk_id);\n\n\tswitch (clk_id) {\n\tcase SIU_CLKA_PLL:\n\t\tsiu_name = \"siua_clk\";\n\t\tparent_name = \"pll_clk\";\n\t\tbreak;\n\tcase SIU_CLKA_EXT:\n\t\tsiu_name = \"siua_clk\";\n\t\tparent_name = \"siumcka_clk\";\n\t\tbreak;\n\tcase SIU_CLKB_PLL:\n\t\tsiu_name = \"siub_clk\";\n\t\tparent_name = \"pll_clk\";\n\t\tbreak;\n\tcase SIU_CLKB_EXT:\n\t\tsiu_name = \"siub_clk\";\n\t\tparent_name = \"siumckb_clk\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsiu_clk = clk_get(dai->dev, siu_name);\n\tif (IS_ERR(siu_clk)) {\n\t\tdev_err(dai->dev, \"%s: cannot get a SIU clock: %ld\\n\", __func__,\n\t\t\tPTR_ERR(siu_clk));\n\t\treturn PTR_ERR(siu_clk);\n\t}\n\n\tparent_clk = clk_get(dai->dev, parent_name);\n\tif (IS_ERR(parent_clk)) {\n\t\tret = PTR_ERR(parent_clk);\n\t\tdev_err(dai->dev, \"cannot get a SIU clock parent: %d\\n\", ret);\n\t\tgoto epclkget;\n\t}\n\n\tret = clk_set_parent(siu_clk, parent_clk);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"cannot reparent the SIU clock: %d\\n\", ret);\n\t\tgoto eclksetp;\n\t}\n\n\tret = clk_set_rate(siu_clk, freq);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"cannot set SIU clock rate: %d\\n\", ret);\n\n\t \neclksetp:\n\tclk_put(parent_clk);\nepclkget:\n\tclk_put(siu_clk);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops siu_dai_ops = {\n\t.startup\t= siu_dai_startup,\n\t.shutdown\t= siu_dai_shutdown,\n\t.prepare\t= siu_dai_prepare,\n\t.set_sysclk\t= siu_dai_set_sysclk,\n\t.set_fmt\t= siu_dai_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver siu_i2s_dai = {\n\t.name\t= \"siu-i2s-dai\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t },\n\t.ops = &siu_dai_ops,\n};\n\nstatic int siu_probe(struct platform_device *pdev)\n{\n\tconst struct firmware *fw_entry;\n\tstruct resource *res, *region;\n\tstruct siu_info *info;\n\tint ret;\n\n\tinfo = devm_kmalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tsiu_i2s_data = info;\n\tinfo->dev = &pdev->dev;\n\n\tret = request_firmware(&fw_entry, \"siu_spb.bin\", &pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemcpy(&info->fw, fw_entry->data, fw_entry->size);\n\n\trelease_firmware(fw_entry);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tregion = devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res), pdev->name);\n\tif (!region) {\n\t\tdev_err(&pdev->dev, \"SIU region already claimed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tinfo->pram = devm_ioremap(&pdev->dev, res->start, PRAM_SIZE);\n\tif (!info->pram)\n\t\treturn -ENOMEM;\n\tinfo->xram = devm_ioremap(&pdev->dev, res->start + XRAM_OFFSET,\n\t\t\t\t  XRAM_SIZE);\n\tif (!info->xram)\n\t\treturn -ENOMEM;\n\tinfo->yram = devm_ioremap(&pdev->dev, res->start + YRAM_OFFSET,\n\t\t\t\t  YRAM_SIZE);\n\tif (!info->yram)\n\t\treturn -ENOMEM;\n\tinfo->reg = devm_ioremap(&pdev->dev, res->start + REG_OFFSET,\n\t\t\t    resource_size(res) - REG_OFFSET);\n\tif (!info->reg)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, info);\n\n\t \n\tret = devm_snd_soc_register_component(&pdev->dev, &siu_component,\n\t\t\t\t\t      &siu_i2s_dai, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void siu_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic struct platform_driver siu_driver = {\n\t.driver \t= {\n\t\t.name\t= \"siu-pcm-audio\",\n\t},\n\t.probe\t\t= siu_probe,\n\t.remove_new\t= siu_remove,\n};\n\nmodule_platform_driver(siu_driver);\n\nMODULE_AUTHOR(\"Carlos Munoz <carlos@kenati.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC SH7722 SIU driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"siu_spb.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}