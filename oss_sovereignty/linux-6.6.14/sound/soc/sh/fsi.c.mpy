{
  "module_name": "fsi.c",
  "hash_id": "0eb1a29430f58bfec669d2d137c2935fa90112403d43ae2732cbc4c033a1e7fa",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/fsi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/scatterlist.h>\n#include <linux/sh_dma.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <sound/sh_fsi.h>\n\n \n#define REG_DO_FMT\t0x0000\n#define REG_DOFF_CTL\t0x0004\n#define REG_DOFF_ST\t0x0008\n#define REG_DI_FMT\t0x000C\n#define REG_DIFF_CTL\t0x0010\n#define REG_DIFF_ST\t0x0014\n#define REG_CKG1\t0x0018\n#define REG_CKG2\t0x001C\n#define REG_DIDT\t0x0020\n#define REG_DODT\t0x0024\n#define REG_MUTE_ST\t0x0028\n#define REG_OUT_DMAC\t0x002C\n#define REG_OUT_SEL\t0x0030\n#define REG_IN_DMAC\t0x0038\n\n \n#define MST_CLK_RST\t0x0210\n#define MST_SOFT_RST\t0x0214\n#define MST_FIFO_SZ\t0x0218\n\n \n#define A_MST_CTLR\t0x0180\n#define B_MST_CTLR\t0x01A0\n#define CPU_INT_ST\t0x01F4\n#define CPU_IEMSK\t0x01F8\n#define CPU_IMSK\t0x01FC\n#define INT_ST\t\t0x0200\n#define IEMSK\t\t0x0204\n#define IMSK\t\t0x0208\n\n \n \n#define CR_BWS_MASK\t(0x3 << 20)  \n#define CR_BWS_24\t(0x0 << 20)  \n#define CR_BWS_16\t(0x1 << 20)  \n#define CR_BWS_20\t(0x2 << 20)  \n\n#define CR_DTMD_PCM\t\t(0x0 << 8)  \n#define CR_DTMD_SPDIF_PCM\t(0x1 << 8)  \n#define CR_DTMD_SPDIF_STREAM\t(0x2 << 8)  \n\n#define CR_MONO\t\t(0x0 << 4)\n#define CR_MONO_D\t(0x1 << 4)\n#define CR_PCM\t\t(0x2 << 4)\n#define CR_I2S\t\t(0x3 << 4)\n#define CR_TDM\t\t(0x4 << 4)\n#define CR_TDM_D\t(0x5 << 4)\n\n \n \n#define VDMD_MASK\t(0x3 << 4)\n#define VDMD_FRONT\t(0x0 << 4)  \n#define VDMD_BACK\t(0x1 << 4)  \n#define VDMD_STREAM\t(0x2 << 4)  \n\n#define DMA_ON\t\t(0x1 << 0)\n\n \n \n#define IRQ_HALF\t0x00100000\n#define FIFO_CLR\t0x00000001\n\n \n#define ERR_OVER\t0x00000010\n#define ERR_UNDER\t0x00000001\n#define ST_ERR\t\t(ERR_OVER | ERR_UNDER)\n\n \n#define ACKMD_MASK\t0x00007000\n#define BPFMD_MASK\t0x00000700\n#define DIMD\t\t(1 << 4)\n#define DOMD\t\t(1 << 0)\n\n \n#define BP\t(1 << 4)\t \n#define SE\t(1 << 0)\t \n\n \n#define CRB\t(1 << 4)\n#define CRA\t(1 << 0)\n\n \n#define BI_SHIFT\t12\n#define BO_SHIFT\t8\n#define AI_SHIFT\t4\n#define AO_SHIFT\t0\n#define AB_IO(param, shift)\t(param << shift)\n\n \n#define PBSR\t\t(1 << 12)  \n#define PASR\t\t(1 <<  8)  \n#define IR\t\t(1 <<  4)  \n#define FSISR\t\t(1 <<  0)  \n\n \n#define DMMD\t\t(1 << 4)  \n\t\t\t\t  \n\n \n#define FIFO_SZ_MASK\t0x7\n\n#define FSI_RATES SNDRV_PCM_RATE_8000_96000\n\n#define FSI_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)\n\n \n\n#define SHIFT_16DATA\t\t0\n#define SHIFT_24DATA\t\t4\n\n#define PACKAGE_24BITBUS_BACK\t\t0\n#define PACKAGE_24BITBUS_FRONT\t\t1\n#define PACKAGE_16BITBUS_STREAM\t\t2\n\n#define BUSOP_SET(s, a)\t((a) << SHIFT_ ## s ## DATA)\n#define BUSOP_GET(s, a)\t(((a) >> SHIFT_ ## s ## DATA) & 0xF)\n\n \n\n \n\n \n\n \n\n \n\nstruct fsi_stream_handler;\nstruct fsi_stream {\n\n\t \n\tstruct snd_pcm_substream *substream;\n\tint fifo_sample_capa;\t \n\tint buff_sample_capa;\t \n\tint buff_sample_pos;\t \n\tint period_samples;\t \n\tint period_pos;\t\t \n\tint sample_width;\t \n\tint uerr_num;\n\tint oerr_num;\n\n\t \n\tu32 bus_option;\n\n\t \n\tstruct fsi_stream_handler *handler;\n\tstruct fsi_priv\t\t*priv;\n\n\t \n\tstruct dma_chan\t\t*chan;\n\tint\t\t\tdma_id;\n};\n\nstruct fsi_clk {\n\t \n\tstruct clk *own;\n\tstruct clk *xck;\n\tstruct clk *ick;\n\tstruct clk *div;\n\tint (*set_rate)(struct device *dev,\n\t\t\tstruct fsi_priv *fsi);\n\n\tunsigned long rate;\n\tunsigned int count;\n};\n\nstruct fsi_priv {\n\tvoid __iomem *base;\n\tphys_addr_t phys;\n\tstruct fsi_master *master;\n\n\tstruct fsi_stream playback;\n\tstruct fsi_stream capture;\n\n\tstruct fsi_clk clock;\n\n\tu32 fmt;\n\n\tint chan_num:16;\n\tunsigned int clk_master:1;\n\tunsigned int clk_cpg:1;\n\tunsigned int spdif:1;\n\tunsigned int enable_stream:1;\n\tunsigned int bit_clk_inv:1;\n\tunsigned int lr_clk_inv:1;\n};\n\nstruct fsi_stream_handler {\n\tint (*init)(struct fsi_priv *fsi, struct fsi_stream *io);\n\tint (*quit)(struct fsi_priv *fsi, struct fsi_stream *io);\n\tint (*probe)(struct fsi_priv *fsi, struct fsi_stream *io, struct device *dev);\n\tint (*transfer)(struct fsi_priv *fsi, struct fsi_stream *io);\n\tint (*remove)(struct fsi_priv *fsi, struct fsi_stream *io);\n\tint (*start_stop)(struct fsi_priv *fsi, struct fsi_stream *io,\n\t\t\t   int enable);\n};\n#define fsi_stream_handler_call(io, func, args...)\t\\\n\t(!(io) ? -ENODEV :\t\t\t\t\\\n\t !((io)->handler->func) ? 0 :\t\t\t\\\n\t (io)->handler->func(args))\n\nstruct fsi_core {\n\tint ver;\n\n\tu32 int_st;\n\tu32 iemsk;\n\tu32 imsk;\n\tu32 a_mclk;\n\tu32 b_mclk;\n};\n\nstruct fsi_master {\n\tvoid __iomem *base;\n\tstruct fsi_priv fsia;\n\tstruct fsi_priv fsib;\n\tconst struct fsi_core *core;\n\tspinlock_t lock;\n};\n\nstatic inline int fsi_stream_is_play(struct fsi_priv *fsi,\n\t\t\t\t     struct fsi_stream *io)\n{\n\treturn &fsi->playback == io;\n}\n\n\n \n\nstatic void __fsi_reg_write(u32 __iomem *reg, u32 data)\n{\n\t \n\tdata &= 0x00ffffff;\n\n\t__raw_writel(data, reg);\n}\n\nstatic u32 __fsi_reg_read(u32 __iomem *reg)\n{\n\treturn __raw_readl(reg);\n}\n\nstatic void __fsi_reg_mask_set(u32 __iomem *reg, u32 mask, u32 data)\n{\n\tu32 val = __fsi_reg_read(reg);\n\n\tval &= ~mask;\n\tval |= data & mask;\n\n\t__fsi_reg_write(reg, val);\n}\n\n#define fsi_reg_write(p, r, d)\\\n\t__fsi_reg_write((p->base + REG_##r), d)\n\n#define fsi_reg_read(p, r)\\\n\t__fsi_reg_read((p->base + REG_##r))\n\n#define fsi_reg_mask_set(p, r, m, d)\\\n\t__fsi_reg_mask_set((p->base + REG_##r), m, d)\n\n#define fsi_master_read(p, r) _fsi_master_read(p, MST_##r)\n#define fsi_core_read(p, r)   _fsi_master_read(p, p->core->r)\nstatic u32 _fsi_master_read(struct fsi_master *master, u32 reg)\n{\n\tu32 ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->lock, flags);\n\tret = __fsi_reg_read(master->base + reg);\n\tspin_unlock_irqrestore(&master->lock, flags);\n\n\treturn ret;\n}\n\n#define fsi_master_mask_set(p, r, m, d) _fsi_master_mask_set(p, MST_##r, m, d)\n#define fsi_core_mask_set(p, r, m, d)  _fsi_master_mask_set(p, p->core->r, m, d)\nstatic void _fsi_master_mask_set(struct fsi_master *master,\n\t\t\t       u32 reg, u32 mask, u32 data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->lock, flags);\n\t__fsi_reg_mask_set(master->base + reg, mask, data);\n\tspin_unlock_irqrestore(&master->lock, flags);\n}\n\n \nstatic int fsi_version(struct fsi_master *master)\n{\n\treturn master->core->ver;\n}\n\nstatic struct fsi_master *fsi_get_master(struct fsi_priv *fsi)\n{\n\treturn fsi->master;\n}\n\nstatic int fsi_is_clk_master(struct fsi_priv *fsi)\n{\n\treturn fsi->clk_master;\n}\n\nstatic int fsi_is_port_a(struct fsi_priv *fsi)\n{\n\treturn fsi->master->base == fsi->base;\n}\n\nstatic int fsi_is_spdif(struct fsi_priv *fsi)\n{\n\treturn fsi->spdif;\n}\n\nstatic int fsi_is_enable_stream(struct fsi_priv *fsi)\n{\n\treturn fsi->enable_stream;\n}\n\nstatic int fsi_is_play(struct snd_pcm_substream *substream)\n{\n\treturn substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n}\n\nstatic struct snd_soc_dai *fsi_get_dai(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\treturn  asoc_rtd_to_cpu(rtd, 0);\n}\n\nstatic struct fsi_priv *fsi_get_priv_frm_dai(struct snd_soc_dai *dai)\n{\n\tstruct fsi_master *master = snd_soc_dai_get_drvdata(dai);\n\n\tif (dai->id == 0)\n\t\treturn &master->fsia;\n\telse\n\t\treturn &master->fsib;\n}\n\nstatic struct fsi_priv *fsi_get_priv(struct snd_pcm_substream *substream)\n{\n\treturn fsi_get_priv_frm_dai(fsi_get_dai(substream));\n}\n\nstatic u32 fsi_get_port_shift(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tint is_play = fsi_stream_is_play(fsi, io);\n\tint is_porta = fsi_is_port_a(fsi);\n\tu32 shift;\n\n\tif (is_porta)\n\t\tshift = is_play ? AO_SHIFT : AI_SHIFT;\n\telse\n\t\tshift = is_play ? BO_SHIFT : BI_SHIFT;\n\n\treturn shift;\n}\n\nstatic int fsi_frame2sample(struct fsi_priv *fsi, int frames)\n{\n\treturn frames * fsi->chan_num;\n}\n\nstatic int fsi_sample2frame(struct fsi_priv *fsi, int samples)\n{\n\treturn samples / fsi->chan_num;\n}\n\nstatic int fsi_get_current_fifo_samples(struct fsi_priv *fsi,\n\t\t\t\t\tstruct fsi_stream *io)\n{\n\tint is_play = fsi_stream_is_play(fsi, io);\n\tu32 status;\n\tint frames;\n\n\tstatus = is_play ?\n\t\tfsi_reg_read(fsi, DOFF_ST) :\n\t\tfsi_reg_read(fsi, DIFF_ST);\n\n\tframes = 0x1ff & (status >> 8);\n\n\treturn fsi_frame2sample(fsi, frames);\n}\n\nstatic void fsi_count_fifo_err(struct fsi_priv *fsi)\n{\n\tu32 ostatus = fsi_reg_read(fsi, DOFF_ST);\n\tu32 istatus = fsi_reg_read(fsi, DIFF_ST);\n\n\tif (ostatus & ERR_OVER)\n\t\tfsi->playback.oerr_num++;\n\n\tif (ostatus & ERR_UNDER)\n\t\tfsi->playback.uerr_num++;\n\n\tif (istatus & ERR_OVER)\n\t\tfsi->capture.oerr_num++;\n\n\tif (istatus & ERR_UNDER)\n\t\tfsi->capture.uerr_num++;\n\n\tfsi_reg_write(fsi, DOFF_ST, 0);\n\tfsi_reg_write(fsi, DIFF_ST, 0);\n}\n\n \nstatic inline struct fsi_stream *fsi_stream_get(struct fsi_priv *fsi,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\treturn fsi_is_play(substream) ? &fsi->playback : &fsi->capture;\n}\n\nstatic int fsi_stream_is_working(struct fsi_priv *fsi,\n\t\t\t\t struct fsi_stream *io)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&master->lock, flags);\n\tret = !!(io->substream && io->substream->runtime);\n\tspin_unlock_irqrestore(&master->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct fsi_priv *fsi_stream_to_priv(struct fsi_stream *io)\n{\n\treturn io->priv;\n}\n\nstatic void fsi_stream_init(struct fsi_priv *fsi,\n\t\t\t    struct fsi_stream *io,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->lock, flags);\n\tio->substream\t= substream;\n\tio->buff_sample_capa\t= fsi_frame2sample(fsi, runtime->buffer_size);\n\tio->buff_sample_pos\t= 0;\n\tio->period_samples\t= fsi_frame2sample(fsi, runtime->period_size);\n\tio->period_pos\t\t= 0;\n\tio->sample_width\t= samples_to_bytes(runtime, 1);\n\tio->bus_option\t\t= 0;\n\tio->oerr_num\t= -1;  \n\tio->uerr_num\t= -1;  \n\tfsi_stream_handler_call(io, init, fsi, io);\n\tspin_unlock_irqrestore(&master->lock, flags);\n}\n\nstatic void fsi_stream_quit(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->lock, flags);\n\n\tif (io->oerr_num > 0)\n\t\tdev_err(dai->dev, \"over_run = %d\\n\", io->oerr_num);\n\n\tif (io->uerr_num > 0)\n\t\tdev_err(dai->dev, \"under_run = %d\\n\", io->uerr_num);\n\n\tfsi_stream_handler_call(io, quit, fsi, io);\n\tio->substream\t= NULL;\n\tio->buff_sample_capa\t= 0;\n\tio->buff_sample_pos\t= 0;\n\tio->period_samples\t= 0;\n\tio->period_pos\t\t= 0;\n\tio->sample_width\t= 0;\n\tio->bus_option\t\t= 0;\n\tio->oerr_num\t= 0;\n\tio->uerr_num\t= 0;\n\tspin_unlock_irqrestore(&master->lock, flags);\n}\n\nstatic int fsi_stream_transfer(struct fsi_stream *io)\n{\n\tstruct fsi_priv *fsi = fsi_stream_to_priv(io);\n\tif (!fsi)\n\t\treturn -EIO;\n\n\treturn fsi_stream_handler_call(io, transfer, fsi, io);\n}\n\n#define fsi_stream_start(fsi, io)\\\n\tfsi_stream_handler_call(io, start_stop, fsi, io, 1)\n\n#define fsi_stream_stop(fsi, io)\\\n\tfsi_stream_handler_call(io, start_stop, fsi, io, 0)\n\nstatic int fsi_stream_probe(struct fsi_priv *fsi, struct device *dev)\n{\n\tstruct fsi_stream *io;\n\tint ret1, ret2;\n\n\tio = &fsi->playback;\n\tret1 = fsi_stream_handler_call(io, probe, fsi, io, dev);\n\n\tio = &fsi->capture;\n\tret2 = fsi_stream_handler_call(io, probe, fsi, io, dev);\n\n\tif (ret1 < 0)\n\t\treturn ret1;\n\tif (ret2 < 0)\n\t\treturn ret2;\n\n\treturn 0;\n}\n\nstatic int fsi_stream_remove(struct fsi_priv *fsi)\n{\n\tstruct fsi_stream *io;\n\tint ret1, ret2;\n\n\tio = &fsi->playback;\n\tret1 = fsi_stream_handler_call(io, remove, fsi, io);\n\n\tio = &fsi->capture;\n\tret2 = fsi_stream_handler_call(io, remove, fsi, io);\n\n\tif (ret1 < 0)\n\t\treturn ret1;\n\tif (ret2 < 0)\n\t\treturn ret2;\n\n\treturn 0;\n}\n\n \nstatic void fsi_format_bus_setup(struct fsi_priv *fsi, struct fsi_stream *io,\n\t\t\t\t u32 bus, struct device *dev)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tint is_play = fsi_stream_is_play(fsi, io);\n\tu32 fmt = fsi->fmt;\n\n\tif (fsi_version(master) >= 2) {\n\t\tu32 dma = 0;\n\n\t\t \n\t\tswitch (bus) {\n\t\tcase PACKAGE_24BITBUS_FRONT:\n\t\t\tfmt |= CR_BWS_24;\n\t\t\tdma |= VDMD_FRONT;\n\t\t\tdev_dbg(dev, \"24bit bus / package in front\\n\");\n\t\t\tbreak;\n\t\tcase PACKAGE_16BITBUS_STREAM:\n\t\t\tfmt |= CR_BWS_16;\n\t\t\tdma |= VDMD_STREAM;\n\t\t\tdev_dbg(dev, \"16bit bus / stream mode\\n\");\n\t\t\tbreak;\n\t\tcase PACKAGE_24BITBUS_BACK:\n\t\tdefault:\n\t\t\tfmt |= CR_BWS_24;\n\t\t\tdma |= VDMD_BACK;\n\t\t\tdev_dbg(dev, \"24bit bus / package in back\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_play)\n\t\t\tfsi_reg_write(fsi, OUT_DMAC,\tdma);\n\t\telse\n\t\t\tfsi_reg_write(fsi, IN_DMAC,\tdma);\n\t}\n\n\tif (is_play)\n\t\tfsi_reg_write(fsi, DO_FMT, fmt);\n\telse\n\t\tfsi_reg_write(fsi, DI_FMT, fmt);\n}\n\n \n\nstatic void fsi_irq_enable(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tu32 data = AB_IO(1, fsi_get_port_shift(fsi, io));\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\n\tfsi_core_mask_set(master, imsk,  data, data);\n\tfsi_core_mask_set(master, iemsk, data, data);\n}\n\nstatic void fsi_irq_disable(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tu32 data = AB_IO(1, fsi_get_port_shift(fsi, io));\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\n\tfsi_core_mask_set(master, imsk,  data, 0);\n\tfsi_core_mask_set(master, iemsk, data, 0);\n}\n\nstatic u32 fsi_irq_get_status(struct fsi_master *master)\n{\n\treturn fsi_core_read(master, int_st);\n}\n\nstatic void fsi_irq_clear_status(struct fsi_priv *fsi)\n{\n\tu32 data = 0;\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\n\tdata |= AB_IO(1, fsi_get_port_shift(fsi, &fsi->playback));\n\tdata |= AB_IO(1, fsi_get_port_shift(fsi, &fsi->capture));\n\n\t \n\tfsi_core_mask_set(master, int_st, data, 0);\n}\n\n \nstatic void fsi_spdif_clk_ctrl(struct fsi_priv *fsi, int enable)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tu32 mask, val;\n\n\tmask = BP | SE;\n\tval = enable ? mask : 0;\n\n\tfsi_is_port_a(fsi) ?\n\t\tfsi_core_mask_set(master, a_mclk, mask, val) :\n\t\tfsi_core_mask_set(master, b_mclk, mask, val);\n}\n\n \nstatic int fsi_clk_init(struct device *dev,\n\t\t\tstruct fsi_priv *fsi,\n\t\t\tint xck,\n\t\t\tint ick,\n\t\t\tint div,\n\t\t\tint (*set_rate)(struct device *dev,\n\t\t\t\t\tstruct fsi_priv *fsi))\n{\n\tstruct fsi_clk *clock = &fsi->clock;\n\tint is_porta = fsi_is_port_a(fsi);\n\n\tclock->xck\t= NULL;\n\tclock->ick\t= NULL;\n\tclock->div\t= NULL;\n\tclock->rate\t= 0;\n\tclock->count\t= 0;\n\tclock->set_rate\t= set_rate;\n\n\tclock->own = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clock->own))\n\t\treturn -EINVAL;\n\n\t \n\tif (xck) {\n\t\tclock->xck = devm_clk_get(dev, is_porta ? \"xcka\" : \"xckb\");\n\t\tif (IS_ERR(clock->xck)) {\n\t\t\tdev_err(dev, \"can't get xck clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (clock->xck == clock->own) {\n\t\t\tdev_err(dev, \"cpu doesn't support xck clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (ick) {\n\t\tclock->ick = devm_clk_get(dev,  is_porta ? \"icka\" : \"ickb\");\n\t\tif (IS_ERR(clock->ick)) {\n\t\t\tdev_err(dev, \"can't get ick clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (clock->ick == clock->own) {\n\t\t\tdev_err(dev, \"cpu doesn't support ick clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (div) {\n\t\tclock->div = devm_clk_get(dev,  is_porta ? \"diva\" : \"divb\");\n\t\tif (IS_ERR(clock->div)) {\n\t\t\tdev_err(dev, \"can't get div clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (clock->div == clock->own) {\n\t\t\tdev_err(dev, \"cpu doesn't support div clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define fsi_clk_invalid(fsi) fsi_clk_valid(fsi, 0)\nstatic void fsi_clk_valid(struct fsi_priv *fsi, unsigned long rate)\n{\n\tfsi->clock.rate = rate;\n}\n\nstatic int fsi_clk_is_valid(struct fsi_priv *fsi)\n{\n\treturn\tfsi->clock.set_rate &&\n\t\tfsi->clock.rate;\n}\n\nstatic int fsi_clk_enable(struct device *dev,\n\t\t\t  struct fsi_priv *fsi)\n{\n\tstruct fsi_clk *clock = &fsi->clock;\n\tint ret = -EINVAL;\n\n\tif (!fsi_clk_is_valid(fsi))\n\t\treturn ret;\n\n\tif (0 == clock->count) {\n\t\tret = clock->set_rate(dev, fsi);\n\t\tif (ret < 0) {\n\t\t\tfsi_clk_invalid(fsi);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_enable(clock->xck);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = clk_enable(clock->ick);\n\t\tif (ret)\n\t\t\tgoto disable_xck;\n\t\tret = clk_enable(clock->div);\n\t\tif (ret)\n\t\t\tgoto disable_ick;\n\n\t\tclock->count++;\n\t}\n\n\treturn ret;\n\ndisable_ick:\n\tclk_disable(clock->ick);\ndisable_xck:\n\tclk_disable(clock->xck);\nerr:\n\treturn ret;\n}\n\nstatic int fsi_clk_disable(struct device *dev,\n\t\t\t    struct fsi_priv *fsi)\n{\n\tstruct fsi_clk *clock = &fsi->clock;\n\n\tif (!fsi_clk_is_valid(fsi))\n\t\treturn -EINVAL;\n\n\tif (1 == clock->count--) {\n\t\tclk_disable(clock->xck);\n\t\tclk_disable(clock->ick);\n\t\tclk_disable(clock->div);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_clk_set_ackbpf(struct device *dev,\n\t\t\t      struct fsi_priv *fsi,\n\t\t\t      int ackmd, int bpfmd)\n{\n\tu32 data = 0;\n\n\t \n\tif (bpfmd > ackmd) {\n\t\tdev_err(dev, \"unsupported rate (%d/%d)\\n\", ackmd, bpfmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (ackmd) {\n\tcase 512:\n\t\tdata |= (0x0 << 12);\n\t\tbreak;\n\tcase 256:\n\t\tdata |= (0x1 << 12);\n\t\tbreak;\n\tcase 128:\n\t\tdata |= (0x2 << 12);\n\t\tbreak;\n\tcase 64:\n\t\tdata |= (0x3 << 12);\n\t\tbreak;\n\tcase 32:\n\t\tdata |= (0x4 << 12);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported ackmd (%d)\\n\", ackmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (bpfmd) {\n\tcase 32:\n\t\tdata |= (0x0 << 8);\n\t\tbreak;\n\tcase 64:\n\t\tdata |= (0x1 << 8);\n\t\tbreak;\n\tcase 128:\n\t\tdata |= (0x2 << 8);\n\t\tbreak;\n\tcase 256:\n\t\tdata |= (0x3 << 8);\n\t\tbreak;\n\tcase 512:\n\t\tdata |= (0x4 << 8);\n\t\tbreak;\n\tcase 16:\n\t\tdata |= (0x7 << 8);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported bpfmd (%d)\\n\", bpfmd);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"ACKMD/BPFMD = %d/%d\\n\", ackmd, bpfmd);\n\n\tfsi_reg_mask_set(fsi, CKG1, (ACKMD_MASK | BPFMD_MASK) , data);\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int fsi_clk_set_rate_external(struct device *dev,\n\t\t\t\t     struct fsi_priv *fsi)\n{\n\tstruct clk *xck = fsi->clock.xck;\n\tstruct clk *ick = fsi->clock.ick;\n\tunsigned long rate = fsi->clock.rate;\n\tunsigned long xrate;\n\tint ackmd, bpfmd;\n\tint ret = 0;\n\n\t \n\txrate = clk_get_rate(xck);\n\tif (xrate % rate) {\n\t\tdev_err(dev, \"unsupported clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk_set_parent(ick, xck);\n\tclk_set_rate(ick, xrate);\n\n\tbpfmd = fsi->chan_num * 32;\n\tackmd = xrate / rate;\n\n\tdev_dbg(dev, \"external/rate = %ld/%ld\\n\", xrate, rate);\n\n\tret = fsi_clk_set_ackbpf(dev, fsi, ackmd, bpfmd);\n\tif (ret < 0)\n\t\tdev_err(dev, \"%s failed\", __func__);\n\n\treturn ret;\n}\n\nstatic int fsi_clk_set_rate_cpg(struct device *dev,\n\t\t\t\tstruct fsi_priv *fsi)\n{\n\tstruct clk *ick = fsi->clock.ick;\n\tstruct clk *div = fsi->clock.div;\n\tunsigned long rate = fsi->clock.rate;\n\tunsigned long target = 0;  \n\tunsigned long actual, cout;\n\tunsigned long diff, min;\n\tunsigned long best_cout, best_act;\n\tint adj;\n\tint ackmd, bpfmd;\n\tint ret = -EINVAL;\n\n\tif (!(12288000 % rate))\n\t\ttarget = 12288000;\n\tif (!(11289600 % rate))\n\t\ttarget = 11289600;\n\tif (!target) {\n\t\tdev_err(dev, \"unsupported rate\\n\");\n\t\treturn ret;\n\t}\n\n\tbpfmd = fsi->chan_num * 32;\n\tackmd = target / rate;\n\tret = fsi_clk_set_ackbpf(dev, fsi, ackmd, bpfmd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s failed\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tmin = ~0;\n\tbest_cout = 0;\n\tbest_act = 0;\n\tfor (adj = 1; adj < 0xffff; adj++) {\n\n\t\tcout = target * adj;\n\t\tif (cout > 100000000)  \n\t\t\tbreak;\n\n\t\t \n\t\tcout\t= clk_round_rate(ick, cout);\n\t\tactual\t= cout / adj;\n\n\t\t \n\t\tdiff = abs(actual - target);\n\t\tif (diff < min) {\n\t\t\tmin\t\t= diff;\n\t\t\tbest_cout\t= cout;\n\t\t\tbest_act\t= actual;\n\t\t}\n\t}\n\n\tret = clk_set_rate(ick, best_cout);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"ick clock failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = clk_set_rate(div, clk_round_rate(div, best_act));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"div clock failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"ick/div = %ld/%ld\\n\",\n\t\tclk_get_rate(ick), clk_get_rate(div));\n\n\treturn ret;\n}\n\nstatic void fsi_pointer_update(struct fsi_stream *io, int size)\n{\n\tio->buff_sample_pos += size;\n\n\tif (io->buff_sample_pos >=\n\t    io->period_samples * (io->period_pos + 1)) {\n\t\tstruct snd_pcm_substream *substream = io->substream;\n\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t\tio->period_pos++;\n\n\t\tif (io->period_pos >= runtime->periods) {\n\t\t\tio->buff_sample_pos = 0;\n\t\t\tio->period_pos = 0;\n\t\t}\n\n\t\tsnd_pcm_period_elapsed(substream);\n\t}\n}\n\n \nstatic void fsi_pio_push16(struct fsi_priv *fsi, u8 *_buf, int samples)\n{\n\tint i;\n\n\tif (fsi_is_enable_stream(fsi)) {\n\t\t \n\t\tu32 *buf = (u32 *)_buf;\n\n\t\tfor (i = 0; i < samples / 2; i++)\n\t\t\tfsi_reg_write(fsi, DODT, buf[i]);\n\t} else {\n\t\t \n\t\tu16 *buf = (u16 *)_buf;\n\n\t\tfor (i = 0; i < samples; i++)\n\t\t\tfsi_reg_write(fsi, DODT, ((u32)*(buf + i) << 8));\n\t}\n}\n\nstatic void fsi_pio_pop16(struct fsi_priv *fsi, u8 *_buf, int samples)\n{\n\tu16 *buf = (u16 *)_buf;\n\tint i;\n\n\tfor (i = 0; i < samples; i++)\n\t\t*(buf + i) = (u16)(fsi_reg_read(fsi, DIDT) >> 8);\n}\n\nstatic void fsi_pio_push32(struct fsi_priv *fsi, u8 *_buf, int samples)\n{\n\tu32 *buf = (u32 *)_buf;\n\tint i;\n\n\tfor (i = 0; i < samples; i++)\n\t\tfsi_reg_write(fsi, DODT, *(buf + i));\n}\n\nstatic void fsi_pio_pop32(struct fsi_priv *fsi, u8 *_buf, int samples)\n{\n\tu32 *buf = (u32 *)_buf;\n\tint i;\n\n\tfor (i = 0; i < samples; i++)\n\t\t*(buf + i) = fsi_reg_read(fsi, DIDT);\n}\n\nstatic u8 *fsi_pio_get_area(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tstruct snd_pcm_runtime *runtime = io->substream->runtime;\n\n\treturn runtime->dma_area +\n\t\tsamples_to_bytes(runtime, io->buff_sample_pos);\n}\n\nstatic int fsi_pio_transfer(struct fsi_priv *fsi, struct fsi_stream *io,\n\t\tvoid (*run16)(struct fsi_priv *fsi, u8 *buf, int samples),\n\t\tvoid (*run32)(struct fsi_priv *fsi, u8 *buf, int samples),\n\t\tint samples)\n{\n\tu8 *buf;\n\n\tif (!fsi_stream_is_working(fsi, io))\n\t\treturn -EINVAL;\n\n\tbuf = fsi_pio_get_area(fsi, io);\n\n\tswitch (io->sample_width) {\n\tcase 2:\n\t\trun16(fsi, buf, samples);\n\t\tbreak;\n\tcase 4:\n\t\trun32(fsi, buf, samples);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfsi_pointer_update(io, samples);\n\n\treturn 0;\n}\n\nstatic int fsi_pio_pop(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tint sample_residues;\t \n\tint sample_space;\t \n\tint samples;\n\n\tsample_residues\t= fsi_get_current_fifo_samples(fsi, io);\n\tsample_space\t= io->buff_sample_capa - io->buff_sample_pos;\n\n\tsamples = min(sample_residues, sample_space);\n\n\treturn fsi_pio_transfer(fsi, io,\n\t\t\t\t  fsi_pio_pop16,\n\t\t\t\t  fsi_pio_pop32,\n\t\t\t\t  samples);\n}\n\nstatic int fsi_pio_push(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tint sample_residues;\t \n\tint sample_space;\t \n\tint samples;\n\n\tsample_residues\t= io->buff_sample_capa - io->buff_sample_pos;\n\tsample_space\t= io->fifo_sample_capa -\n\t\tfsi_get_current_fifo_samples(fsi, io);\n\n\tsamples = min(sample_residues, sample_space);\n\n\treturn fsi_pio_transfer(fsi, io,\n\t\t\t\t  fsi_pio_push16,\n\t\t\t\t  fsi_pio_push32,\n\t\t\t\t  samples);\n}\n\nstatic int fsi_pio_start_stop(struct fsi_priv *fsi, struct fsi_stream *io,\n\t\t\t       int enable)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tu32 clk  = fsi_is_port_a(fsi) ? CRA  : CRB;\n\n\tif (enable)\n\t\tfsi_irq_enable(fsi, io);\n\telse\n\t\tfsi_irq_disable(fsi, io);\n\n\tif (fsi_is_clk_master(fsi))\n\t\tfsi_master_mask_set(master, CLK_RST, clk, (enable) ? clk : 0);\n\n\treturn 0;\n}\n\nstatic int fsi_pio_push_init(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\t \n\tif (fsi_is_enable_stream(fsi))\n\t\tio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\n\t\t\t\t BUSOP_SET(16, PACKAGE_16BITBUS_STREAM);\n\telse\n\t\tio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\n\t\t\t\t BUSOP_SET(16, PACKAGE_24BITBUS_BACK);\n\treturn 0;\n}\n\nstatic int fsi_pio_pop_init(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\t \n\tio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\n\t\t\t BUSOP_SET(16, PACKAGE_24BITBUS_BACK);\n\treturn 0;\n}\n\nstatic struct fsi_stream_handler fsi_pio_push_handler = {\n\t.init\t\t= fsi_pio_push_init,\n\t.transfer\t= fsi_pio_push,\n\t.start_stop\t= fsi_pio_start_stop,\n};\n\nstatic struct fsi_stream_handler fsi_pio_pop_handler = {\n\t.init\t\t= fsi_pio_pop_init,\n\t.transfer\t= fsi_pio_pop,\n\t.start_stop\t= fsi_pio_start_stop,\n};\n\nstatic irqreturn_t fsi_interrupt(int irq, void *data)\n{\n\tstruct fsi_master *master = data;\n\tu32 int_st = fsi_irq_get_status(master);\n\n\t \n\tfsi_master_mask_set(master, SOFT_RST, IR, 0);\n\tfsi_master_mask_set(master, SOFT_RST, IR, IR);\n\n\tif (int_st & AB_IO(1, AO_SHIFT))\n\t\tfsi_stream_transfer(&master->fsia.playback);\n\tif (int_st & AB_IO(1, BO_SHIFT))\n\t\tfsi_stream_transfer(&master->fsib.playback);\n\tif (int_st & AB_IO(1, AI_SHIFT))\n\t\tfsi_stream_transfer(&master->fsia.capture);\n\tif (int_st & AB_IO(1, BI_SHIFT))\n\t\tfsi_stream_transfer(&master->fsib.capture);\n\n\tfsi_count_fifo_err(&master->fsia);\n\tfsi_count_fifo_err(&master->fsib);\n\n\tfsi_irq_clear_status(&master->fsia);\n\tfsi_irq_clear_status(&master->fsib);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int fsi_dma_init(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\t \n\tio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\n\t\t\t BUSOP_SET(16, PACKAGE_16BITBUS_STREAM);\n\n\treturn 0;\n}\n\nstatic void fsi_dma_complete(void *data)\n{\n\tstruct fsi_stream *io = (struct fsi_stream *)data;\n\tstruct fsi_priv *fsi = fsi_stream_to_priv(io);\n\n\tfsi_pointer_update(io, io->period_samples);\n\n\tfsi_count_fifo_err(fsi);\n}\n\nstatic int fsi_dma_transfer(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\n\tstruct snd_pcm_substream *substream = io->substream;\n\tstruct dma_async_tx_descriptor *desc;\n\tint is_play = fsi_stream_is_play(fsi, io);\n\tenum dma_transfer_direction dir;\n\tint ret = -EIO;\n\n\tif (is_play)\n\t\tdir = DMA_MEM_TO_DEV;\n\telse\n\t\tdir = DMA_DEV_TO_MEM;\n\n\tdesc = dmaengine_prep_dma_cyclic(io->chan,\n\t\t\t\t\t substream->runtime->dma_addr,\n\t\t\t\t\t snd_pcm_lib_buffer_bytes(substream),\n\t\t\t\t\t snd_pcm_lib_period_bytes(substream),\n\t\t\t\t\t dir,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(dai->dev, \"dmaengine_prep_dma_cyclic() fail\\n\");\n\t\tgoto fsi_dma_transfer_err;\n\t}\n\n\tdesc->callback\t\t= fsi_dma_complete;\n\tdesc->callback_param\t= io;\n\n\tif (dmaengine_submit(desc) < 0) {\n\t\tdev_err(dai->dev, \"tx_submit() fail\\n\");\n\t\tgoto fsi_dma_transfer_err;\n\t}\n\n\tdma_async_issue_pending(io->chan);\n\n\t \n\tif (!is_play) {\n\t\tif (ERR_OVER & fsi_reg_read(fsi, DIFF_ST)) {\n\t\t\tfsi_reg_mask_set(fsi, DIFF_CTL, FIFO_CLR, FIFO_CLR);\n\t\t\tfsi_reg_write(fsi, DIFF_ST, 0);\n\t\t}\n\t}\n\n\tret = 0;\n\nfsi_dma_transfer_err:\n\treturn ret;\n}\n\nstatic int fsi_dma_push_start_stop(struct fsi_priv *fsi, struct fsi_stream *io,\n\t\t\t\t int start)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tu32 clk  = fsi_is_port_a(fsi) ? CRA  : CRB;\n\tu32 enable = start ? DMA_ON : 0;\n\n\tfsi_reg_mask_set(fsi, OUT_DMAC, DMA_ON, enable);\n\n\tdmaengine_terminate_all(io->chan);\n\n\tif (fsi_is_clk_master(fsi))\n\t\tfsi_master_mask_set(master, CLK_RST, clk, (enable) ? clk : 0);\n\n\treturn 0;\n}\n\nstatic int fsi_dma_probe(struct fsi_priv *fsi, struct fsi_stream *io, struct device *dev)\n{\n\tint is_play = fsi_stream_is_play(fsi, io);\n\n#ifdef CONFIG_SUPERH\n\tdma_cap_mask_t mask;\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tio->chan = dma_request_channel(mask, shdma_chan_filter,\n\t\t\t\t       (void *)io->dma_id);\n#else\n\tio->chan = dma_request_slave_channel(dev, is_play ? \"tx\" : \"rx\");\n#endif\n\tif (io->chan) {\n\t\tstruct dma_slave_config cfg = {};\n\t\tint ret;\n\n\t\tif (is_play) {\n\t\t\tcfg.dst_addr\t\t= fsi->phys + REG_DODT;\n\t\t\tcfg.dst_addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tcfg.direction\t\t= DMA_MEM_TO_DEV;\n\t\t} else {\n\t\t\tcfg.src_addr\t\t= fsi->phys + REG_DIDT;\n\t\t\tcfg.src_addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tcfg.direction\t\t= DMA_DEV_TO_MEM;\n\t\t}\n\n\t\tret = dmaengine_slave_config(io->chan, &cfg);\n\t\tif (ret < 0) {\n\t\t\tdma_release_channel(io->chan);\n\t\t\tio->chan = NULL;\n\t\t}\n\t}\n\n\tif (!io->chan) {\n\n\t\t \n\t\tif (is_play)\n\t\t\tfsi->playback.handler\t= &fsi_pio_push_handler;\n\t\telse\n\t\t\tfsi->capture.handler\t= &fsi_pio_pop_handler;\n\n\t\tdev_info(dev, \"switch handler (dma => pio)\\n\");\n\n\t\t \n\t\treturn fsi_stream_probe(fsi, dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_dma_remove(struct fsi_priv *fsi, struct fsi_stream *io)\n{\n\tfsi_stream_stop(fsi, io);\n\n\tif (io->chan)\n\t\tdma_release_channel(io->chan);\n\n\tio->chan = NULL;\n\treturn 0;\n}\n\nstatic struct fsi_stream_handler fsi_dma_push_handler = {\n\t.init\t\t= fsi_dma_init,\n\t.probe\t\t= fsi_dma_probe,\n\t.transfer\t= fsi_dma_transfer,\n\t.remove\t\t= fsi_dma_remove,\n\t.start_stop\t= fsi_dma_push_start_stop,\n};\n\n \nstatic void fsi_fifo_init(struct fsi_priv *fsi,\n\t\t\t  struct fsi_stream *io,\n\t\t\t  struct device *dev)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\tint is_play = fsi_stream_is_play(fsi, io);\n\tu32 shift, i;\n\tint frame_capa;\n\n\t \n\tshift = fsi_master_read(master, FIFO_SZ);\n\tshift >>= fsi_get_port_shift(fsi, io);\n\tshift &= FIFO_SZ_MASK;\n\tframe_capa = 256 << shift;\n\tdev_dbg(dev, \"fifo = %d words\\n\", frame_capa);\n\n\t \n\tfor (i = 1; i < fsi->chan_num; i <<= 1)\n\t\tframe_capa >>= 1;\n\tdev_dbg(dev, \"%d channel %d store\\n\",\n\t\tfsi->chan_num, frame_capa);\n\n\tio->fifo_sample_capa = fsi_frame2sample(fsi, frame_capa);\n\n\t \n\tif (is_play) {\n\t\tfsi_reg_write(fsi,\tDOFF_CTL, IRQ_HALF);\n\t\tfsi_reg_mask_set(fsi,\tDOFF_CTL, FIFO_CLR, FIFO_CLR);\n\t} else {\n\t\tfsi_reg_write(fsi,\tDIFF_CTL, IRQ_HALF);\n\t\tfsi_reg_mask_set(fsi,\tDIFF_CTL, FIFO_CLR, FIFO_CLR);\n\t}\n}\n\nstatic int fsi_hw_startup(struct fsi_priv *fsi,\n\t\t\t  struct fsi_stream *io,\n\t\t\t  struct device *dev)\n{\n\tu32 data = 0;\n\n\t \n\tif (fsi_is_clk_master(fsi))\n\t\tdata = DIMD | DOMD;\n\n\tfsi_reg_mask_set(fsi, CKG1, (DIMD | DOMD), data);\n\n\t \n\tdata = 0;\n\tif (fsi->bit_clk_inv)\n\t\tdata |= (1 << 0);\n\tif (fsi->lr_clk_inv)\n\t\tdata |= (1 << 4);\n\tif (fsi_is_clk_master(fsi))\n\t\tdata <<= 8;\n\tfsi_reg_write(fsi, CKG2, data);\n\n\t \n\tif (fsi_is_spdif(fsi)) {\n\t\tfsi_spdif_clk_ctrl(fsi, 1);\n\t\tfsi_reg_mask_set(fsi, OUT_SEL, DMMD, DMMD);\n\t}\n\n\t \n\tdata = 0;\n\tswitch (io->sample_width) {\n\tcase 2:\n\t\tdata = BUSOP_GET(16, io->bus_option);\n\t\tbreak;\n\tcase 4:\n\t\tdata = BUSOP_GET(24, io->bus_option);\n\t\tbreak;\n\t}\n\tfsi_format_bus_setup(fsi, io, data, dev);\n\n\t \n\tfsi_irq_disable(fsi, io);\n\tfsi_irq_clear_status(fsi);\n\n\t \n\tfsi_fifo_init(fsi, io, dev);\n\n\t \n\tif (fsi_is_clk_master(fsi))\n\t\treturn fsi_clk_enable(dev, fsi);\n\n\treturn 0;\n}\n\nstatic int fsi_hw_shutdown(struct fsi_priv *fsi,\n\t\t\t    struct device *dev)\n{\n\t \n\tif (fsi_is_clk_master(fsi))\n\t\treturn fsi_clk_disable(dev, fsi);\n\n\treturn 0;\n}\n\nstatic int fsi_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv(substream);\n\n\tfsi_clk_invalid(fsi);\n\n\treturn 0;\n}\n\nstatic void fsi_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv(substream);\n\n\tfsi_clk_invalid(fsi);\n}\n\nstatic int fsi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv(substream);\n\tstruct fsi_stream *io = fsi_stream_get(fsi, substream);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tfsi_stream_init(fsi, io, substream);\n\t\tif (!ret)\n\t\t\tret = fsi_hw_startup(fsi, io, dai->dev);\n\t\tif (!ret)\n\t\t\tret = fsi_stream_start(fsi, io);\n\t\tif (!ret)\n\t\t\tret = fsi_stream_transfer(io);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (!ret)\n\t\t\tret = fsi_hw_shutdown(fsi, dai->dev);\n\t\tfsi_stream_stop(fsi, io);\n\t\tfsi_stream_quit(fsi, io);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fsi_set_fmt_dai(struct fsi_priv *fsi, unsigned int fmt)\n{\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfsi->fmt = CR_I2S;\n\t\tfsi->chan_num = 2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfsi->fmt = CR_PCM;\n\t\tfsi->chan_num = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_set_fmt_spdif(struct fsi_priv *fsi)\n{\n\tstruct fsi_master *master = fsi_get_master(fsi);\n\n\tif (fsi_version(master) < 2)\n\t\treturn -EINVAL;\n\n\tfsi->fmt = CR_DTMD_SPDIF_PCM | CR_PCM;\n\tfsi->chan_num = 2;\n\n\treturn 0;\n}\n\nstatic int fsi_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv_frm_dai(dai);\n\tint ret;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tfsi->clk_master = 1;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tfsi->bit_clk_inv = 0;\n\t\tfsi->lr_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tfsi->bit_clk_inv = 1;\n\t\tfsi->lr_clk_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tfsi->bit_clk_inv = 1;\n\t\tfsi->lr_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tdefault:\n\t\tfsi->bit_clk_inv = 0;\n\t\tfsi->lr_clk_inv = 0;\n\t\tbreak;\n\t}\n\n\tif (fsi_is_clk_master(fsi)) {\n\t\tif (fsi->clk_cpg)\n\t\t\tfsi_clk_init(dai->dev, fsi, 0, 1, 1,\n\t\t\t\t     fsi_clk_set_rate_cpg);\n\t\telse\n\t\t\tfsi_clk_init(dai->dev, fsi, 1, 1, 0,\n\t\t\t\t     fsi_clk_set_rate_external);\n\t}\n\n\t \n\tif (fsi_is_spdif(fsi))\n\t\tret = fsi_set_fmt_spdif(fsi);\n\telse\n\t\tret = fsi_set_fmt_dai(fsi, fmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\n\treturn ret;\n}\n\nstatic int fsi_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv(substream);\n\n\tif (fsi_is_clk_master(fsi))\n\t\tfsi_clk_valid(fsi, params_rate(params));\n\n\treturn 0;\n}\n\n \nstatic u64 fsi_dai_formats =\n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_IF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_IF;\n\nstatic const struct snd_soc_dai_ops fsi_dai_ops = {\n\t.startup\t= fsi_dai_startup,\n\t.shutdown\t= fsi_dai_shutdown,\n\t.trigger\t= fsi_dai_trigger,\n\t.set_fmt\t= fsi_dai_set_fmt,\n\t.hw_params\t= fsi_dai_hw_params,\n\t.auto_selectable_formats\t= &fsi_dai_formats,\n\t.num_auto_selectable_formats\t= 1,\n};\n\n \n\nstatic const struct snd_pcm_hardware fsi_pcm_hardware = {\n\t.info =\t\tSNDRV_PCM_INFO_INTERLEAVED\t|\n\t\t\tSNDRV_PCM_INFO_MMAP\t\t|\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.buffer_bytes_max\t= 64 * 1024,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 8192,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 32,\n\t.fifo_size\t\t= 256,\n};\n\nstatic int fsi_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret = 0;\n\n\tsnd_soc_set_runtime_hwparams(substream, &fsi_pcm_hardware);\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t fsi_pointer(struct snd_soc_component *component,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct fsi_priv *fsi = fsi_get_priv(substream);\n\tstruct fsi_stream *io = fsi_stream_get(fsi, substream);\n\n\treturn fsi_sample2frame(fsi, io->buff_sample_pos);\n}\n\n \n\n#define PREALLOC_BUFFER\t\t(32 * 1024)\n#define PREALLOC_BUFFER_MAX\t(32 * 1024)\n\nstatic int fsi_pcm_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(\n\t\trtd->pcm,\n\t\tSNDRV_DMA_TYPE_DEV,\n\t\trtd->card->snd_card->dev,\n\t\tPREALLOC_BUFFER, PREALLOC_BUFFER_MAX);\n\treturn 0;\n}\n\n \n\nstatic struct snd_soc_dai_driver fsi_soc_dai[] = {\n\t{\n\t\t.name\t\t\t= \"fsia-dai\",\n\t\t.playback = {\n\t\t\t.rates\t\t= FSI_RATES,\n\t\t\t.formats\t= FSI_FMTS,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.capture = {\n\t\t\t.rates\t\t= FSI_RATES,\n\t\t\t.formats\t= FSI_FMTS,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.ops = &fsi_dai_ops,\n\t},\n\t{\n\t\t.name\t\t\t= \"fsib-dai\",\n\t\t.playback = {\n\t\t\t.rates\t\t= FSI_RATES,\n\t\t\t.formats\t= FSI_FMTS,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.capture = {\n\t\t\t.rates\t\t= FSI_RATES,\n\t\t\t.formats\t= FSI_FMTS,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.ops = &fsi_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver fsi_soc_component = {\n\t.name\t\t= \"fsi\",\n\t.open\t\t= fsi_pcm_open,\n\t.pointer\t= fsi_pointer,\n\t.pcm_construct\t= fsi_pcm_new,\n};\n\n \nstatic void fsi_of_parse(char *name,\n\t\t\t struct device_node *np,\n\t\t\t struct sh_fsi_port_info *info,\n\t\t\t struct device *dev)\n{\n\tint i;\n\tchar prop[128];\n\tunsigned long flags = 0;\n\tstruct {\n\t\tchar *name;\n\t\tunsigned int val;\n\t} of_parse_property[] = {\n\t\t{ \"spdif-connection\",\t\tSH_FSI_FMT_SPDIF },\n\t\t{ \"stream-mode-support\",\tSH_FSI_ENABLE_STREAM_MODE },\n\t\t{ \"use-internal-clock\",\t\tSH_FSI_CLK_CPG },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(of_parse_property); i++) {\n\t\tsprintf(prop, \"%s,%s\", name, of_parse_property[i].name);\n\t\tif (of_property_present(np, prop))\n\t\t\tflags |= of_parse_property[i].val;\n\t}\n\tinfo->flags = flags;\n\n\tdev_dbg(dev, \"%s flags : %lx\\n\", name, info->flags);\n}\n\nstatic void fsi_port_info_init(struct fsi_priv *fsi,\n\t\t\t       struct sh_fsi_port_info *info)\n{\n\tif (info->flags & SH_FSI_FMT_SPDIF)\n\t\tfsi->spdif = 1;\n\n\tif (info->flags & SH_FSI_CLK_CPG)\n\t\tfsi->clk_cpg = 1;\n\n\tif (info->flags & SH_FSI_ENABLE_STREAM_MODE)\n\t\tfsi->enable_stream = 1;\n}\n\nstatic void fsi_handler_init(struct fsi_priv *fsi,\n\t\t\t     struct sh_fsi_port_info *info)\n{\n\tfsi->playback.handler\t= &fsi_pio_push_handler;  \n\tfsi->playback.priv\t= fsi;\n\tfsi->capture.handler\t= &fsi_pio_pop_handler;   \n\tfsi->capture.priv\t= fsi;\n\n\tif (info->tx_id) {\n\t\tfsi->playback.dma_id  = info->tx_id;\n\t\tfsi->playback.handler = &fsi_dma_push_handler;\n\t}\n}\n\nstatic const struct fsi_core fsi1_core = {\n\t.ver\t= 1,\n\n\t \n\t.int_st\t= INT_ST,\n\t.iemsk\t= IEMSK,\n\t.imsk\t= IMSK,\n};\n\nstatic const struct fsi_core fsi2_core = {\n\t.ver\t= 2,\n\n\t \n\t.int_st\t= CPU_INT_ST,\n\t.iemsk\t= CPU_IEMSK,\n\t.imsk\t= CPU_IMSK,\n\t.a_mclk\t= A_MST_CTLR,\n\t.b_mclk\t= B_MST_CTLR,\n};\n\nstatic const struct of_device_id fsi_of_match[] = {\n\t{ .compatible = \"renesas,sh_fsi\",\t.data = &fsi1_core},\n\t{ .compatible = \"renesas,sh_fsi2\",\t.data = &fsi2_core},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fsi_of_match);\n\nstatic const struct platform_device_id fsi_id_table[] = {\n\t{ \"sh_fsi\",\t(kernel_ulong_t)&fsi1_core },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, fsi_id_table);\n\nstatic int fsi_probe(struct platform_device *pdev)\n{\n\tstruct fsi_master *master;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sh_fsi_platform_info info;\n\tconst struct fsi_core *core;\n\tstruct fsi_priv *fsi;\n\tstruct resource *res;\n\tunsigned int irq;\n\tint ret;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tcore = NULL;\n\tif (np) {\n\t\tcore = of_device_get_match_data(&pdev->dev);\n\t\tfsi_of_parse(\"fsia\", np, &info.port_a, &pdev->dev);\n\t\tfsi_of_parse(\"fsib\", np, &info.port_b, &pdev->dev);\n\t} else {\n\t\tconst struct platform_device_id\t*id_entry = pdev->id_entry;\n\t\tif (id_entry)\n\t\t\tcore = (struct fsi_core *)id_entry->driver_data;\n\n\t\tif (pdev->dev.platform_data)\n\t\t\tmemcpy(&info, pdev->dev.platform_data, sizeof(info));\n\t}\n\n\tif (!core) {\n\t\tdev_err(&pdev->dev, \"unknown fsi device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (!res || (int)irq <= 0) {\n\t\tdev_err(&pdev->dev, \"Not enough FSI platform resources.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmaster = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!master->base) {\n\t\tdev_err(&pdev->dev, \"Unable to ioremap FSI registers.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmaster->core\t\t= core;\n\tspin_lock_init(&master->lock);\n\n\t \n\tfsi\t\t= &master->fsia;\n\tfsi->base\t= master->base;\n\tfsi->phys\t= res->start;\n\tfsi->master\t= master;\n\tfsi_port_info_init(fsi, &info.port_a);\n\tfsi_handler_init(fsi, &info.port_a);\n\tret = fsi_stream_probe(fsi, &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"FSIA stream probe failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfsi\t\t= &master->fsib;\n\tfsi->base\t= master->base + 0x40;\n\tfsi->phys\t= res->start + 0x40;\n\tfsi->master\t= master;\n\tfsi_port_info_init(fsi, &info.port_b);\n\tfsi_handler_init(fsi, &info.port_b);\n\tret = fsi_stream_probe(fsi, &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"FSIB stream probe failed\\n\");\n\t\tgoto exit_fsia;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tdev_set_drvdata(&pdev->dev, master);\n\n\tret = devm_request_irq(&pdev->dev, irq, &fsi_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), master);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request err\\n\");\n\t\tgoto exit_fsib;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &fsi_soc_component,\n\t\t\t\t    fsi_soc_dai, ARRAY_SIZE(fsi_soc_dai));\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot snd component register\\n\");\n\t\tgoto exit_fsib;\n\t}\n\n\treturn ret;\n\nexit_fsib:\n\tpm_runtime_disable(&pdev->dev);\n\tfsi_stream_remove(&master->fsib);\nexit_fsia:\n\tfsi_stream_remove(&master->fsia);\n\n\treturn ret;\n}\n\nstatic void fsi_remove(struct platform_device *pdev)\n{\n\tstruct fsi_master *master;\n\n\tmaster = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tfsi_stream_remove(&master->fsia);\n\tfsi_stream_remove(&master->fsib);\n}\n\nstatic void __fsi_suspend(struct fsi_priv *fsi,\n\t\t\t  struct fsi_stream *io,\n\t\t\t  struct device *dev)\n{\n\tif (!fsi_stream_is_working(fsi, io))\n\t\treturn;\n\n\tfsi_stream_stop(fsi, io);\n\tfsi_hw_shutdown(fsi, dev);\n}\n\nstatic void __fsi_resume(struct fsi_priv *fsi,\n\t\t\t struct fsi_stream *io,\n\t\t\t struct device *dev)\n{\n\tif (!fsi_stream_is_working(fsi, io))\n\t\treturn;\n\n\tfsi_hw_startup(fsi, io, dev);\n\tfsi_stream_start(fsi, io);\n}\n\nstatic int fsi_suspend(struct device *dev)\n{\n\tstruct fsi_master *master = dev_get_drvdata(dev);\n\tstruct fsi_priv *fsia = &master->fsia;\n\tstruct fsi_priv *fsib = &master->fsib;\n\n\t__fsi_suspend(fsia, &fsia->playback, dev);\n\t__fsi_suspend(fsia, &fsia->capture, dev);\n\n\t__fsi_suspend(fsib, &fsib->playback, dev);\n\t__fsi_suspend(fsib, &fsib->capture, dev);\n\n\treturn 0;\n}\n\nstatic int fsi_resume(struct device *dev)\n{\n\tstruct fsi_master *master = dev_get_drvdata(dev);\n\tstruct fsi_priv *fsia = &master->fsia;\n\tstruct fsi_priv *fsib = &master->fsib;\n\n\t__fsi_resume(fsia, &fsia->playback, dev);\n\t__fsi_resume(fsia, &fsia->capture, dev);\n\n\t__fsi_resume(fsib, &fsib->playback, dev);\n\t__fsi_resume(fsib, &fsib->capture, dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops fsi_pm_ops = {\n\t.suspend\t\t= fsi_suspend,\n\t.resume\t\t\t= fsi_resume,\n};\n\nstatic struct platform_driver fsi_driver = {\n\t.driver \t= {\n\t\t.name\t= \"fsi-pcm-audio\",\n\t\t.pm\t= &fsi_pm_ops,\n\t\t.of_match_table = fsi_of_match,\n\t},\n\t.probe\t\t= fsi_probe,\n\t.remove_new\t= fsi_remove,\n\t.id_table\t= fsi_id_table,\n};\n\nmodule_platform_driver(fsi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SuperH onchip FSI audio driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <morimoto.kuninori@renesas.com>\");\nMODULE_ALIAS(\"platform:fsi-pcm-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}