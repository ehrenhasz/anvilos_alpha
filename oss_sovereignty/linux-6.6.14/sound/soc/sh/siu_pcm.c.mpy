{
  "module_name": "siu_pcm.c",
  "hash_id": "e10f1f1b274d213c575995a7d3c7c4945e06c35690d596deec2881cd182a9698",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/siu_pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/siu.h>\n\n#include \"siu.h\"\n\n#define DRV_NAME \"siu-i2s\"\n#define GET_MAX_PERIODS(buf_bytes, period_bytes) \\\n\t\t\t\t((buf_bytes) / (period_bytes))\n#define PERIOD_OFFSET(buf_addr, period_num, period_bytes) \\\n\t\t\t\t((buf_addr) + ((period_num) * (period_bytes)))\n\n#define RWF_STM_RD\t\t0x01\t\t \n#define RWF_STM_WT\t\t0x02\t\t \n\nstruct siu_port *siu_ports[SIU_PORT_NUM];\n\n \nstatic int siu_pcm_stmwrite_stop(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_stream *siu_stream = &port_info->playback;\n\tu32 stfifo;\n\n\tif (!siu_stream->rw_flg)\n\t\treturn -EPERM;\n\n\t \n\tstfifo = siu_read32(base + SIU_STFIFO);\n\tsiu_write32(base + SIU_STFIFO, stfifo & ~0x0c180c18);\n\tpr_debug(\"%s: STFIFO %x -> %x\\n\", __func__,\n\t\t stfifo, stfifo & ~0x0c180c18);\n\n\t \n\tsiu_stream->rw_flg = 0;\n\n\treturn 0;\n}\n\nstatic int siu_pcm_stmwrite_start(struct siu_port *port_info)\n{\n\tstruct siu_stream *siu_stream = &port_info->playback;\n\n\tif (siu_stream->rw_flg)\n\t\treturn -EPERM;\n\n\t \n\tport_info->playback.cur_period = 0;\n\n\t \n\tsiu_stream->rw_flg = RWF_STM_WT;\n\n\t \n\tqueue_work(system_highpri_wq, &siu_stream->work);\n\n\treturn 0;\n}\n\nstatic void siu_dma_tx_complete(void *arg)\n{\n\tstruct siu_stream *siu_stream = arg;\n\n\tif (!siu_stream->rw_flg)\n\t\treturn;\n\n\t \n\tif (++siu_stream->cur_period >=\n\t    GET_MAX_PERIODS(siu_stream->buf_bytes,\n\t\t\t    siu_stream->period_bytes))\n\t\tsiu_stream->cur_period = 0;\n\n\tpr_debug(\"%s: done period #%d (%u/%u bytes), cookie %d\\n\",\n\t\t__func__, siu_stream->cur_period,\n\t\tsiu_stream->cur_period * siu_stream->period_bytes,\n\t\tsiu_stream->buf_bytes, siu_stream->cookie);\n\n\tqueue_work(system_highpri_wq, &siu_stream->work);\n\n\t \n\tsnd_pcm_period_elapsed(siu_stream->substream);\n}\n\nstatic int siu_pcm_wr_set(struct siu_port *port_info,\n\t\t\t  dma_addr_t buff, u32 size)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_stream *siu_stream = &port_info->playback;\n\tstruct snd_pcm_substream *substream = siu_stream->substream;\n\tstruct device *dev = substream->pcm->card->dev;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tstruct scatterlist sg;\n\tu32 stfifo;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, pfn_to_page(PFN_DOWN(buff)),\n\t\t    size, offset_in_page(buff));\n\tsg_dma_len(&sg) = size;\n\tsg_dma_address(&sg) = buff;\n\n\tdesc = dmaengine_prep_slave_sg(siu_stream->chan,\n\t\t&sg, 1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(dev, \"Failed to allocate a dma descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc->callback = siu_dma_tx_complete;\n\tdesc->callback_param = siu_stream;\n\tcookie = dmaengine_submit(desc);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Failed to submit a dma transfer\\n\");\n\t\treturn cookie;\n\t}\n\n\tsiu_stream->tx_desc = desc;\n\tsiu_stream->cookie = cookie;\n\n\tdma_async_issue_pending(siu_stream->chan);\n\n\t \n\tstfifo = siu_read32(base + SIU_STFIFO);\n\tsiu_write32(base + SIU_STFIFO, stfifo | (port_info->stfifo & 0x0c180c18));\n\tdev_dbg(dev, \"%s: STFIFO %x -> %x\\n\", __func__,\n\t\tstfifo, stfifo | (port_info->stfifo & 0x0c180c18));\n\n\treturn 0;\n}\n\nstatic int siu_pcm_rd_set(struct siu_port *port_info,\n\t\t\t  dma_addr_t buff, size_t size)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_stream *siu_stream = &port_info->capture;\n\tstruct snd_pcm_substream *substream = siu_stream->substream;\n\tstruct device *dev = substream->pcm->card->dev;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tstruct scatterlist sg;\n\tu32 stfifo;\n\n\tdev_dbg(dev, \"%s: %u@%llx\\n\", __func__, size, (unsigned long long)buff);\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, pfn_to_page(PFN_DOWN(buff)),\n\t\t    size, offset_in_page(buff));\n\tsg_dma_len(&sg) = size;\n\tsg_dma_address(&sg) = buff;\n\n\tdesc = dmaengine_prep_slave_sg(siu_stream->chan,\n\t\t&sg, 1, DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(dev, \"Failed to allocate dma descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc->callback = siu_dma_tx_complete;\n\tdesc->callback_param = siu_stream;\n\tcookie = dmaengine_submit(desc);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Failed to submit dma descriptor\\n\");\n\t\treturn cookie;\n\t}\n\n\tsiu_stream->tx_desc = desc;\n\tsiu_stream->cookie = cookie;\n\n\tdma_async_issue_pending(siu_stream->chan);\n\n\t \n\tstfifo = siu_read32(base + SIU_STFIFO);\n\tsiu_write32(base + SIU_STFIFO, siu_read32(base + SIU_STFIFO) |\n\t\t    (port_info->stfifo & 0x13071307));\n\tdev_dbg(dev, \"%s: STFIFO %x -> %x\\n\", __func__,\n\t\tstfifo, stfifo | (port_info->stfifo & 0x13071307));\n\n\treturn 0;\n}\n\nstatic void siu_io_work(struct work_struct *work)\n{\n\tstruct siu_stream *siu_stream = container_of(work, struct siu_stream,\n\t\t\t\t\t\t     work);\n\tstruct snd_pcm_substream *substream = siu_stream->substream;\n\tstruct device *dev = substream->pcm->card->dev;\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct siu_port *port_info = siu_port_info(substream);\n\n\tdev_dbg(dev, \"%s: flags %x\\n\", __func__, siu_stream->rw_flg);\n\n\tif (!siu_stream->rw_flg) {\n\t\tdev_dbg(dev, \"%s: stream inactive\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tdma_addr_t buff;\n\t\tsize_t count;\n\n\t\tbuff = (dma_addr_t)PERIOD_OFFSET(rt->dma_addr,\n\t\t\t\t\t\tsiu_stream->cur_period,\n\t\t\t\t\t\tsiu_stream->period_bytes);\n\t\tcount = siu_stream->period_bytes;\n\n\t\t \n\t\tsiu_pcm_rd_set(port_info, buff, count);\n\t} else {\n\t\tsiu_pcm_wr_set(port_info,\n\t\t\t       (dma_addr_t)PERIOD_OFFSET(rt->dma_addr,\n\t\t\t\t\t\tsiu_stream->cur_period,\n\t\t\t\t\t\tsiu_stream->period_bytes),\n\t\t\t       siu_stream->period_bytes);\n\t}\n}\n\n \nstatic int siu_pcm_stmread_start(struct siu_port *port_info)\n{\n\tstruct siu_stream *siu_stream = &port_info->capture;\n\n\tif (siu_stream->xfer_cnt > 0x1000000)\n\t\treturn -EINVAL;\n\tif (siu_stream->rw_flg)\n\t\treturn -EPERM;\n\n\t \n\tsiu_stream->cur_period = 0;\n\n\t \n\tsiu_stream->rw_flg = RWF_STM_RD;\n\n\tqueue_work(system_highpri_wq, &siu_stream->work);\n\n\treturn 0;\n}\n\nstatic int siu_pcm_stmread_stop(struct siu_port *port_info)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_stream *siu_stream = &port_info->capture;\n\tstruct device *dev = siu_stream->substream->pcm->card->dev;\n\tu32 stfifo;\n\n\tif (!siu_stream->rw_flg)\n\t\treturn -EPERM;\n\n\t \n\tstfifo = siu_read32(base + SIU_STFIFO);\n\tsiu_write32(base + SIU_STFIFO, stfifo & ~0x13071307);\n\tdev_dbg(dev, \"%s: STFIFO %x -> %x\\n\", __func__,\n\t\tstfifo, stfifo & ~0x13071307);\n\n\t \n\tsiu_stream->rw_flg = 0;\n\n\treturn 0;\n}\n\nstatic bool filter(struct dma_chan *chan, void *secondary)\n{\n\tstruct sh_dmae_slave *param = secondary;\n\n\tpr_debug(\"%s: secondary ID %d\\n\", __func__, param->shdma_slave.slave_id);\n\n\tchan->private = &param->shdma_slave;\n\treturn true;\n}\n\nstatic int siu_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *ss)\n{\n\t \n\tstruct siu_platform *pdata = component->dev->platform_data;\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct siu_port *port_info = siu_port_info(ss);\n\tstruct siu_stream *siu_stream;\n\tu32 port = info->port_id;\n\tstruct device *dev = ss->pcm->card->dev;\n\tdma_cap_mask_t mask;\n\tstruct sh_dmae_slave *param;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tdev_dbg(dev, \"%s, port=%d@%p\\n\", __func__, port, port_info);\n\n\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsiu_stream = &port_info->playback;\n\t\tparam = &siu_stream->param;\n\t\tparam->shdma_slave.slave_id = port ? pdata->dma_slave_tx_b :\n\t\t\tpdata->dma_slave_tx_a;\n\t} else {\n\t\tsiu_stream = &port_info->capture;\n\t\tparam = &siu_stream->param;\n\t\tparam->shdma_slave.slave_id = port ? pdata->dma_slave_rx_b :\n\t\t\tpdata->dma_slave_rx_a;\n\t}\n\n\t \n\tsiu_stream->chan = dma_request_channel(mask, filter, param);\n\tif (!siu_stream->chan) {\n\t\tdev_err(dev, \"DMA channel allocation failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsiu_stream->substream = ss;\n\n\treturn 0;\n}\n\nstatic int siu_pcm_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *ss)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct device *dev = ss->pcm->card->dev;\n\tstruct siu_port *port_info = siu_port_info(ss);\n\tstruct siu_stream *siu_stream;\n\n\tdev_dbg(dev, \"%s: port=%d\\n\", __func__, info->port_id);\n\n\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsiu_stream = &port_info->playback;\n\telse\n\t\tsiu_stream = &port_info->capture;\n\n\tdma_release_channel(siu_stream->chan);\n\tsiu_stream->chan = NULL;\n\n\tsiu_stream->substream = NULL;\n\n\treturn 0;\n}\n\nstatic int siu_pcm_prepare(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *ss)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct siu_port *port_info = siu_port_info(ss);\n\tstruct device *dev = ss->pcm->card->dev;\n\tstruct snd_pcm_runtime *rt;\n\tstruct siu_stream *siu_stream;\n\tsnd_pcm_sframes_t xfer_cnt;\n\n\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsiu_stream = &port_info->playback;\n\telse\n\t\tsiu_stream = &port_info->capture;\n\n\trt = siu_stream->substream->runtime;\n\n\tsiu_stream->buf_bytes = snd_pcm_lib_buffer_bytes(ss);\n\tsiu_stream->period_bytes = snd_pcm_lib_period_bytes(ss);\n\n\tdev_dbg(dev, \"%s: port=%d, %d channels, period=%u bytes\\n\", __func__,\n\t\tinfo->port_id, rt->channels, siu_stream->period_bytes);\n\n\t \n\tif (siu_stream->buf_bytes % siu_stream->period_bytes) {\n\t\tdev_err(dev, \"%s() - buffer=%d not multiple of period=%d\\n\",\n\t\t       __func__, siu_stream->buf_bytes,\n\t\t       siu_stream->period_bytes);\n\t\treturn -EINVAL;\n\t}\n\n\txfer_cnt = bytes_to_frames(rt, siu_stream->period_bytes);\n\tif (!xfer_cnt || xfer_cnt > 0x1000000)\n\t\treturn -EINVAL;\n\n\tsiu_stream->format = rt->format;\n\tsiu_stream->xfer_cnt = xfer_cnt;\n\n\tdev_dbg(dev, \"port=%d buf=%lx buf_bytes=%d period_bytes=%d \"\n\t\t\"format=%d channels=%d xfer_cnt=%d\\n\", info->port_id,\n\t\t(unsigned long)rt->dma_addr, siu_stream->buf_bytes,\n\t\tsiu_stream->period_bytes,\n\t\tsiu_stream->format, rt->channels, (int)xfer_cnt);\n\n\treturn 0;\n}\n\nstatic int siu_pcm_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *ss, int cmd)\n{\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct device *dev = ss->pcm->card->dev;\n\tstruct siu_port *port_info = siu_port_info(ss);\n\tint ret;\n\n\tdev_dbg(dev, \"%s: port=%d@%p, cmd=%d\\n\", __func__,\n\t\tinfo->port_id, port_info, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = siu_pcm_stmwrite_start(port_info);\n\t\telse\n\t\t\tret = siu_pcm_stmread_start(port_info);\n\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"%s: start failed on port=%d\\n\",\n\t\t\t\t __func__, info->port_id);\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsiu_pcm_stmwrite_stop(port_info);\n\t\telse\n\t\t\tsiu_pcm_stmread_stop(port_info);\n\t\tret = 0;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s() unsupported cmd=%d\\n\", __func__, cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic snd_pcm_uframes_t\nsiu_pcm_pointer_dma(struct snd_soc_component *component,\n\t\t    struct snd_pcm_substream *ss)\n{\n\tstruct device *dev = ss->pcm->card->dev;\n\tstruct siu_info *info = siu_i2s_data;\n\tu32 __iomem *base = info->reg;\n\tstruct siu_port *port_info = siu_port_info(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tsize_t ptr;\n\tstruct siu_stream *siu_stream;\n\n\tif (ss->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsiu_stream = &port_info->playback;\n\telse\n\t\tsiu_stream = &port_info->capture;\n\n\t \n\tptr = PERIOD_OFFSET(rt->dma_addr,\n\t\t\t    siu_stream->cur_period,\n\t\t\t    siu_stream->period_bytes) - rt->dma_addr;\n\n\tdev_dbg(dev,\n\t\t\"%s: port=%d, events %x, FSTS %x, xferred %u/%u, cookie %d\\n\",\n\t\t__func__, info->port_id, siu_read32(base + SIU_EVNTC),\n\t\tsiu_read32(base + SIU_SBFSTS), ptr, siu_stream->buf_bytes,\n\t\tsiu_stream->cookie);\n\n\tif (ptr >= siu_stream->buf_bytes)\n\t\tptr = 0;\n\n\treturn bytes_to_frames(ss->runtime, ptr);\n}\n\nstatic int siu_pcm_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\t \n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct siu_info *info = siu_i2s_data;\n\tstruct platform_device *pdev = to_platform_device(card->dev);\n\tint ret;\n\tint i;\n\n\t \n\tif (pdev->id < 0 || pdev->id >= SIU_PORT_NUM)\n\t\treturn -EINVAL;\n\n\tinfo->port_id = pdev->id;\n\n\t \n\tfor (i = pdev->id; i < pdev->id + 1; i++) {\n\t\tstruct siu_port **port_info = &siu_ports[i];\n\n\t\tret = siu_init_port(i, port_info, card);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\t\tSNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\tSIU_BUFFER_BYTES_MAX, SIU_BUFFER_BYTES_MAX);\n\n\t\t(*port_info)->pcm = pcm;\n\n\t\t \n\t\tINIT_WORK(&(*port_info)->playback.work, siu_io_work);\n\t\tINIT_WORK(&(*port_info)->capture.work, siu_io_work);\n\t}\n\n\tdev_info(card->dev, \"SuperH SIU driver initialized.\\n\");\n\treturn 0;\n}\n\nstatic void siu_pcm_free(struct snd_soc_component *component,\n\t\t\t struct snd_pcm *pcm)\n{\n\tstruct platform_device *pdev = to_platform_device(pcm->card->dev);\n\tstruct siu_port *port_info = siu_ports[pdev->id];\n\n\tcancel_work_sync(&port_info->capture.work);\n\tcancel_work_sync(&port_info->playback.work);\n\n\tsiu_free_port(port_info);\n\n\tdev_dbg(pcm->card->dev, \"%s\\n\", __func__);\n}\n\nconst struct snd_soc_component_driver siu_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.open\t\t\t= siu_pcm_open,\n\t.close\t\t\t= siu_pcm_close,\n\t.prepare\t\t= siu_pcm_prepare,\n\t.trigger\t\t= siu_pcm_trigger,\n\t.pointer\t\t= siu_pcm_pointer_dma,\n\t.pcm_construct\t\t= siu_pcm_new,\n\t.pcm_destruct\t\t= siu_pcm_free,\n\t.legacy_dai_naming\t= 1,\n};\nEXPORT_SYMBOL_GPL(siu_component);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}