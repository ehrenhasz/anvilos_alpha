{
  "module_name": "ssiu.c",
  "hash_id": "aad7b09c0d713c8cda609305d0c19bceb09dda042bd7655c0f72d2b537b143e1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/ssiu.c",
  "human_readable_source": "\n\n\n\n\n\n#include \"rsnd.h\"\n\n#define SSIU_NAME \"ssiu\"\n\nstruct rsnd_ssiu {\n\tstruct rsnd_mod mod;\n\tu32 busif_status[8];  \n\tunsigned int usrcnt;\n\tint id;\n\tint id_sub;\n};\n\n \n#define TDM_EXT\t\t(1 << 0)\n#define TDM_SPLIT\t(1 << 8)\n\n#define rsnd_ssiu_nr(priv) ((priv)->ssiu_nr)\n#define rsnd_mod_to_ssiu(_mod) container_of((_mod), struct rsnd_ssiu, mod)\n#define for_each_rsnd_ssiu(pos, priv, i)\t\t\t\t\\\n\tfor (i = 0;\t\t\t\t\t\t\t\\\n\t     (i < rsnd_ssiu_nr(priv)) &&\t\t\t\t\\\n\t\t     ((pos) = ((struct rsnd_ssiu *)(priv)->ssiu + i));\t\\\n\t     i++)\n\n \nstatic const int gen2_id[] = { 0, 4,  8, 12, 13, 14, 15, 16, 17, 18 };\nstatic const int gen3_id[] = { 0, 8, 16, 24, 32, 40, 41, 42, 43, 44 };\nstatic const int gen4_id[] = { 0 };\n\n \n#define rsnd_ssiu_busif_err_irq_enable(mod)  rsnd_ssiu_busif_err_irq_ctrl(mod, 1)\n#define rsnd_ssiu_busif_err_irq_disable(mod) rsnd_ssiu_busif_err_irq_ctrl(mod, 0)\nstatic void rsnd_ssiu_busif_err_irq_ctrl(struct rsnd_mod *mod, int enable)\n{\n\tint id = rsnd_mod_id(mod);\n\tint shift, offset;\n\tint i;\n\n\tswitch (id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tshift  = id;\n\t\toffset = 0;\n\t\tbreak;\n\tcase 9:\n\t\tshift  = 1;\n\t\toffset = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tenum rsnd_reg reg = SSI_SYS_INT_ENABLE((i * 2) + offset);\n\t\tu32 val = 0xf << (shift * 4);\n\t\tu32 sys_int_enable = rsnd_mod_read(mod, reg);\n\n\t\tif (enable)\n\t\t\tsys_int_enable |= val;\n\t\telse\n\t\t\tsys_int_enable &= ~val;\n\t\trsnd_mod_write(mod, reg, sys_int_enable);\n\t}\n}\n\nbool rsnd_ssiu_busif_err_status_clear(struct rsnd_mod *mod)\n{\n\tbool error = false;\n\tint id = rsnd_mod_id(mod);\n\tint shift, offset;\n\tint i;\n\n\tswitch (id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tshift  = id;\n\t\toffset = 0;\n\t\tbreak;\n\tcase 9:\n\t\tshift  = 1;\n\t\toffset = 1;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 reg = SSI_SYS_STATUS(i * 2) + offset;\n\t\tu32 status = rsnd_mod_read(mod, reg);\n\t\tu32 val = 0xf << (shift * 4);\n\n\t\tstatus &= val;\n\t\tif (status) {\n\t\t\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\t\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t\t\trsnd_print_irq_status(dev, \"%s err status : 0x%08x\\n\",\n\t\t\t\t\t      rsnd_mod_name(mod), status);\n\t\t\terror = true;\n\t\t}\n\t\trsnd_mod_write(mod, reg, val);\n\t}\nout:\n\treturn error;\n}\n\nstatic u32 *rsnd_ssiu_get_status(struct rsnd_mod *mod,\n\t\t\t\t struct rsnd_dai_stream *io,\n\t\t\t\t enum rsnd_mod_type type)\n{\n\tstruct rsnd_ssiu *ssiu = rsnd_mod_to_ssiu(mod);\n\tint busif = rsnd_mod_id_sub(mod);\n\n\treturn &ssiu->busif_status[busif];\n}\n\nstatic int rsnd_ssiu_init(struct rsnd_mod *mod,\n\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t  struct rsnd_priv *priv)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tu32 ssis = rsnd_ssi_multi_secondaries_runtime(io);\n\tint use_busif = rsnd_ssi_use_busif(io);\n\tint id = rsnd_mod_id(mod);\n\tint is_clk_master = rsnd_rdai_is_clk_master(rdai);\n\tu32 val1, val2;\n\n\t \n\trsnd_ssiu_busif_err_status_clear(mod);\n\n\t \n\tif (rsnd_is_gen4(priv))\n\t\tgoto ssi_mode_setting_end;\n\n\t \n\trsnd_mod_bset(mod, SSI_MODE0, (1 << id), !use_busif << id);\n\n\t \n\tval1 = rsnd_mod_read(mod, SSI_MODE1);\n\tval2 = rsnd_mod_read(mod, SSI_MODE2);\n\tif (rsnd_ssi_is_pin_sharing(io)) {\n\n\t\tssis |= (1 << id);\n\n\t} else if (ssis) {\n\t\t \n\n\t\t \n\t\tif (ssis & (1 << 4))\n\t\t\tval1 |= (1 << 20);\n\t\t \n\t\tif (ssis == 0x0006)\n\t\t\tval1 |= (1 << 4);\n\t\t \n\t\tif (ssis == 0x0206)\n\t\t\tval2 |= (1 << 4);\n\t}\n\n\t \n\tif (ssis & (1 << 1))\n\t\tval1 |= is_clk_master ? 0x2 : 0x1;\n\n\t \n\tif (ssis & (1 << 2))\n\t\tval1 |= is_clk_master ?\t0x2 << 2 :\n\t\t\t\t\t0x1 << 2;\n\t \n\tif (ssis & (1 << 4))\n\t\tval1 |= is_clk_master ? 0x2 << 16 :\n\t\t\t\t\t0x1 << 16;\n\t \n\tif (ssis & (1 << 9))\n\t\tval2 |= is_clk_master ? 0x2 : 0x1;\n\n\trsnd_mod_bset(mod, SSI_MODE1, 0x0013001f, val1);\n\trsnd_mod_bset(mod, SSI_MODE2, 0x00000017, val2);\n\nssi_mode_setting_end:\n\t \n\trsnd_ssiu_busif_err_irq_enable(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssiu_quit(struct rsnd_mod *mod,\n\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t  struct rsnd_priv *priv)\n{\n\t \n\trsnd_ssiu_busif_err_irq_disable(mod);\n\n\treturn 0;\n}\n\nstatic struct rsnd_mod_ops rsnd_ssiu_ops_gen1 = {\n\t.name\t\t= SSIU_NAME,\n\t.init\t\t= rsnd_ssiu_init,\n\t.quit\t\t= rsnd_ssiu_quit,\n\t.get_status\t= rsnd_ssiu_get_status,\n};\n\nstatic int rsnd_ssiu_init_gen2(struct rsnd_mod *mod,\n\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t       struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssiu *ssiu = rsnd_mod_to_ssiu(mod);\n\tu32 has_hdmi0 = rsnd_flags_has(io, RSND_STREAM_HDMI0);\n\tu32 has_hdmi1 = rsnd_flags_has(io, RSND_STREAM_HDMI1);\n\tint ret;\n\tu32 mode = 0;\n\n\tret = rsnd_ssiu_init(mod, io, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tssiu->usrcnt++;\n\n\t \n\tif (rsnd_runtime_is_tdm(io))\n\t\tmode = TDM_EXT;\n\telse if (rsnd_runtime_is_tdm_split(io))\n\t\tmode = TDM_SPLIT;\n\n\trsnd_mod_write(mod, SSI_MODE, mode);\n\n\tif (rsnd_ssi_use_busif(io)) {\n\t\tint id = rsnd_mod_id(mod);\n\t\tint busif = rsnd_mod_id_sub(mod);\n\t\tenum rsnd_reg adinr_reg, mode_reg, dalign_reg;\n\n\t\tif ((id == 9) && (busif >= 4)) {\n\t\t\tadinr_reg = SSI9_BUSIF_ADINR(busif);\n\t\t\tmode_reg = SSI9_BUSIF_MODE(busif);\n\t\t\tdalign_reg = SSI9_BUSIF_DALIGN(busif);\n\t\t} else {\n\t\t\tadinr_reg = SSI_BUSIF_ADINR(busif);\n\t\t\tmode_reg = SSI_BUSIF_MODE(busif);\n\t\t\tdalign_reg = SSI_BUSIF_DALIGN(busif);\n\t\t}\n\n\t\trsnd_mod_write(mod, adinr_reg,\n\t\t\t       rsnd_get_adinr_bit(mod, io) |\n\t\t\t       (rsnd_io_is_play(io) ?\n\t\t\t\trsnd_runtime_channel_after_ctu(io) :\n\t\t\t\trsnd_runtime_channel_original(io)));\n\t\trsnd_mod_write(mod, mode_reg,\n\t\t\t       rsnd_get_busif_shift(io, mod) | 1);\n\t\trsnd_mod_write(mod, dalign_reg,\n\t\t\t       rsnd_get_dalign(mod, io));\n\t}\n\n\tif (has_hdmi0 || has_hdmi1) {\n\t\tenum rsnd_mod_type rsnd_ssi_array[] = {\n\t\t\tRSND_MOD_SSIM1,\n\t\t\tRSND_MOD_SSIM2,\n\t\t\tRSND_MOD_SSIM3,\n\t\t};\n\t\tstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\n\t\tstruct rsnd_mod *pos;\n\t\tu32 val;\n\t\tint i;\n\n\t\ti = rsnd_mod_id(ssi_mod);\n\n\t\t \n\t\tval =\ti << 16 |\n\t\t\ti << 20 |\n\t\t\ti << 24 |\n\t\t\ti << 28 |\n\t\t\ti;\n\n\t\tfor_each_rsnd_mod_array(i, pos, io, rsnd_ssi_array) {\n\t\t\tint shift = (i * 4) + 20;\n\n\t\t\tval\t= (val & ~(0xF << shift)) |\n\t\t\t\trsnd_mod_id(pos) << shift;\n\t\t}\n\n\t\tif (has_hdmi0)\n\t\t\trsnd_mod_write(mod, HDMI0_SEL, val);\n\t\tif (has_hdmi1)\n\t\t\trsnd_mod_write(mod, HDMI1_SEL, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_ssiu_start_gen2(struct rsnd_mod *mod,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_priv *priv)\n{\n\tint busif = rsnd_mod_id_sub(mod);\n\n\tif (!rsnd_ssi_use_busif(io))\n\t\treturn 0;\n\n\trsnd_mod_bset(mod, SSI_CTRL, 1 << (busif * 4), 1 << (busif * 4));\n\n\tif (rsnd_ssi_multi_secondaries_runtime(io))\n\t\trsnd_mod_write(mod, SSI_CONTROL, 0x1);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssiu_stop_gen2(struct rsnd_mod *mod,\n\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t       struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssiu *ssiu = rsnd_mod_to_ssiu(mod);\n\tint busif = rsnd_mod_id_sub(mod);\n\n\tif (!rsnd_ssi_use_busif(io))\n\t\treturn 0;\n\n\trsnd_mod_bset(mod, SSI_CTRL, 1 << (busif * 4), 0);\n\n\tif (--ssiu->usrcnt)\n\t\treturn 0;\n\n\tif (rsnd_ssi_multi_secondaries_runtime(io))\n\t\trsnd_mod_write(mod, SSI_CONTROL, 0);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssiu_id(struct rsnd_mod *mod)\n{\n\tstruct rsnd_ssiu *ssiu = rsnd_mod_to_ssiu(mod);\n\n\t \n\treturn ssiu->id;\n}\n\nstatic int rsnd_ssiu_id_sub(struct rsnd_mod *mod)\n{\n\tstruct rsnd_ssiu *ssiu = rsnd_mod_to_ssiu(mod);\n\n\t \n\treturn ssiu->id_sub;\n}\n\nstatic struct dma_chan *rsnd_ssiu_dma_req(struct rsnd_dai_stream *io,\n\t\t\t\t\t  struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tint is_play = rsnd_io_is_play(io);\n\tchar *name;\n\n\t \n\n\tname = is_play ? \"rx\" : \"tx\";\n\n\treturn rsnd_dma_request_channel(rsnd_ssiu_of_node(priv),\n\t\t\t\t\tSSIU_NAME, mod, name);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_ssiu_debug_info(struct seq_file *m,\n\t\t\t\t struct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SSIU,\n\t\t\t\t  rsnd_mod_id(mod) * 0x80, 0x80);\n}\n#define DEBUG_INFO .debug_info = rsnd_ssiu_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_ssiu_ops_gen2 = {\n\t.name\t\t= SSIU_NAME,\n\t.dma_req\t= rsnd_ssiu_dma_req,\n\t.init\t\t= rsnd_ssiu_init_gen2,\n\t.quit\t\t= rsnd_ssiu_quit,\n\t.start\t\t= rsnd_ssiu_start_gen2,\n\t.stop\t\t= rsnd_ssiu_stop_gen2,\n\t.get_status\t= rsnd_ssiu_get_status,\n\tDEBUG_INFO\n};\n\nstatic struct rsnd_mod *rsnd_ssiu_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_ssiu_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get((struct rsnd_ssiu *)(priv->ssiu) + id);\n}\n\nstatic void rsnd_parse_connect_ssiu_compatible(struct rsnd_priv *priv,\n\t\t\t\t\t       struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\n\tstruct rsnd_ssiu *ssiu;\n\tint is_dma_mode;\n\tint i;\n\n\tif (!ssi_mod)\n\t\treturn;\n\n\tis_dma_mode = rsnd_ssi_is_dma_mode(ssi_mod);\n\n\t \n\tfor_each_rsnd_ssiu(ssiu, priv, i) {\n\t\tstruct rsnd_mod *mod = rsnd_mod_get(ssiu);\n\n\t\tif (is_dma_mode &&\n\t\t    (rsnd_mod_id(ssi_mod) == rsnd_mod_id(mod)) &&\n\t\t    (rsnd_mod_id_sub(mod) == 0)) {\n\t\t\trsnd_dai_connect(mod, io, mod->type);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid rsnd_parse_connect_ssiu(struct rsnd_dai *rdai,\n\t\t\t     struct device_node *playback,\n\t\t\t     struct device_node *capture)\n{\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *node = rsnd_ssiu_of_node(priv);\n\tstruct rsnd_dai_stream *io_p = &rdai->playback;\n\tstruct rsnd_dai_stream *io_c = &rdai->capture;\n\n\t \n\tif (node) {\n\t\tstruct device_node *np;\n\t\tint i = 0;\n\n\t\tfor_each_child_of_node(node, np) {\n\t\t\tstruct rsnd_mod *mod;\n\n\t\t\ti = rsnd_node_fixed_index(dev, np, SSIU_NAME, i);\n\t\t\tif (i < 0) {\n\t\t\t\tof_node_put(np);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmod = rsnd_ssiu_mod_get(priv, i);\n\n\t\t\tif (np == playback)\n\t\t\t\trsnd_dai_connect(mod, io_p, mod->type);\n\t\t\tif (np == capture)\n\t\t\t\trsnd_dai_connect(mod, io_c, mod->type);\n\t\t\ti++;\n\t\t}\n\n\t\tof_node_put(node);\n\t}\n\n\t \n\tif (!rsnd_io_to_mod_ssiu(io_p))\n\t\trsnd_parse_connect_ssiu_compatible(priv, io_p);\n\tif (!rsnd_io_to_mod_ssiu(io_c))\n\t\trsnd_parse_connect_ssiu_compatible(priv, io_c);\n}\n\nint rsnd_ssiu_probe(struct rsnd_priv *priv)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *node;\n\tstruct rsnd_ssiu *ssiu;\n\tstruct rsnd_mod_ops *ops;\n\tconst int *list = NULL;\n\tint i, nr;\n\n\t \n\tnode = rsnd_ssiu_of_node(priv);\n\tif (node)\n\t\tnr = rsnd_node_count(priv, node, SSIU_NAME);\n\telse\n\t\tnr = priv->ssi_nr;\n\n\tif (!nr)\n\t\treturn -EINVAL;\n\n\tssiu\t= devm_kcalloc(dev, nr, sizeof(*ssiu), GFP_KERNEL);\n\tif (!ssiu)\n\t\treturn -ENOMEM;\n\n\tpriv->ssiu\t= ssiu;\n\tpriv->ssiu_nr\t= nr;\n\n\tif (rsnd_is_gen1(priv))\n\t\tops = &rsnd_ssiu_ops_gen1;\n\telse\n\t\tops = &rsnd_ssiu_ops_gen2;\n\n\t \n\tnr = 0;\n\tif ((node) &&\n\t    (ops == &rsnd_ssiu_ops_gen2)) {\n\t\tops->id\t\t= rsnd_ssiu_id;\n\t\tops->id_sub\t= rsnd_ssiu_id_sub;\n\n\t\tif (rsnd_is_gen2(priv)) {\n\t\t\tlist\t= gen2_id;\n\t\t\tnr\t= ARRAY_SIZE(gen2_id);\n\t\t} else if (rsnd_is_gen3(priv)) {\n\t\t\tlist\t= gen3_id;\n\t\t\tnr\t= ARRAY_SIZE(gen3_id);\n\t\t} else if (rsnd_is_gen4(priv)) {\n\t\t\tlist\t= gen4_id;\n\t\t\tnr\t= ARRAY_SIZE(gen4_id);\n\t\t} else {\n\t\t\tdev_err(dev, \"unknown SSIU\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tfor_each_rsnd_ssiu(ssiu, priv, i) {\n\t\tint ret;\n\n\t\tif (node) {\n\t\t\tint j;\n\n\t\t\t \n\t\t\tfor (j = 0; j < nr; j++) {\n\t\t\t\tif (list[j] > i)\n\t\t\t\t\tbreak;\n\t\t\t\tssiu->id\t= j;\n\t\t\t\tssiu->id_sub\t= i - list[ssiu->id];\n\t\t\t}\n\t\t} else {\n\t\t\tssiu->id = i;\n\t\t}\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(ssiu),\n\t\t\t\t    ops, NULL, RSND_MOD_SSIU, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid rsnd_ssiu_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssiu *ssiu;\n\tint i;\n\n\tfor_each_rsnd_ssiu(ssiu, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(ssiu));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}