{
  "module_name": "ssi.c",
  "hash_id": "348969a49f8dfba66028422ab90825e12aee795a1e6fb100f41fc09595cb0ded",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/ssi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <sound/simple_card_utils.h>\n#include <linux/delay.h>\n#include \"rsnd.h\"\n#define RSND_SSI_NAME_SIZE 16\n\n \n#define\tFORCE\t\t(1u << 31)\t \n#define\tDMEN\t\t(1u << 28)\t \n#define\tUIEN\t\t(1u << 27)\t \n#define\tOIEN\t\t(1u << 26)\t \n#define\tIIEN\t\t(1u << 25)\t \n#define\tDIEN\t\t(1u << 24)\t \n#define\tCHNL_4\t\t(1u << 22)\t \n#define\tCHNL_6\t\t(2u << 22)\t \n#define\tCHNL_8\t\t(3u << 22)\t \n#define DWL_MASK\t(7u << 19)\t \n#define\tDWL_8\t\t(0u << 19)\t \n#define\tDWL_16\t\t(1u << 19)\t \n#define\tDWL_18\t\t(2u << 19)\t \n#define\tDWL_20\t\t(3u << 19)\t \n#define\tDWL_22\t\t(4u << 19)\t \n#define\tDWL_24\t\t(5u << 19)\t \n#define\tDWL_32\t\t(6u << 19)\t \n\n \n#define\tSWL_16\t\t(1 << 16)\t \n#define\tSWL_24\t\t(2 << 16)\t \n#define\tSWL_32\t\t(3 << 16)\t \n\n#define\tSCKD\t\t(1 << 15)\t \n#define\tSWSD\t\t(1 << 14)\t \n#define\tSCKP\t\t(1 << 13)\t \n#define\tSWSP\t\t(1 << 12)\t \n#define\tSDTA\t\t(1 << 10)\t \n#define\tPDTA\t\t(1 <<  9)\t \n#define\tDEL\t\t(1 <<  8)\t \n#define\tCKDV(v)\t\t(v <<  4)\t \n#define\tTRMD\t\t(1 <<  1)\t \n#define\tEN\t\t(1 <<  0)\t \n\n \n#define\tUIRQ\t\t(1 << 27)\t \n#define\tOIRQ\t\t(1 << 26)\t \n#define\tIIRQ\t\t(1 << 25)\t \n#define\tDIRQ\t\t(1 << 24)\t \n\n \n#define CONT\t\t(1 << 8)\t \n#define WS_MODE\t\t(1 << 0)\t \n\n#define SSI_NAME \"ssi\"\n\nstruct rsnd_ssi {\n\tstruct rsnd_mod mod;\n\n\tu32 flags;\n\tu32 cr_own;\n\tu32 cr_clk;\n\tu32 cr_mode;\n\tu32 cr_en;\n\tu32 wsr;\n\tint chan;\n\tint rate;\n\tint irq;\n\tunsigned int usrcnt;\n\n\t \n\tint byte_pos;\n\tint byte_per_period;\n\tint next_period_byte;\n};\n\n \n#define RSND_SSI_CLK_PIN_SHARE\t\t(1 << 0)\n#define RSND_SSI_NO_BUSIF\t\t(1 << 1)  \n#define RSND_SSI_PROBED\t\t\t(1 << 2)\n\n#define for_each_rsnd_ssi(pos, priv, i)\t\t\t\t\t\\\n\tfor (i = 0;\t\t\t\t\t\t\t\\\n\t     (i < rsnd_ssi_nr(priv)) &&\t\t\t\t\t\\\n\t\t((pos) = ((struct rsnd_ssi *)(priv)->ssi + i));\t\t\\\n\t     i++)\n\n#define rsnd_ssi_get(priv, id) ((struct rsnd_ssi *)(priv->ssi) + id)\n#define rsnd_ssi_nr(priv) ((priv)->ssi_nr)\n#define rsnd_mod_to_ssi(_mod) container_of((_mod), struct rsnd_ssi, mod)\n#define rsnd_ssi_is_parent(ssi, io) ((ssi) == rsnd_io_to_mod_ssip(io))\n#define rsnd_ssi_is_multi_secondary(mod, io)\t\t\t\t\\\n\t(rsnd_ssi_multi_secondaries(io) & (1 << rsnd_mod_id(mod)))\n#define rsnd_ssi_is_run_mods(mod, io) \\\n\t(rsnd_ssi_run_mods(io) & (1 << rsnd_mod_id(mod)))\n#define rsnd_ssi_can_output_clk(mod) (!__rsnd_ssi_is_pin_sharing(mod))\n\nint rsnd_ssi_use_busif(struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_mod *mod = rsnd_io_to_mod_ssi(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tint use_busif = 0;\n\n\tif (!rsnd_ssi_is_dma_mode(mod))\n\t\treturn 0;\n\n\tif (!(rsnd_flags_has(ssi, RSND_SSI_NO_BUSIF)))\n\t\tuse_busif = 1;\n\tif (rsnd_io_to_mod_src(io))\n\t\tuse_busif = 1;\n\n\treturn use_busif;\n}\n\nstatic void rsnd_ssi_status_clear(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, SSISR, 0);\n}\n\nstatic u32 rsnd_ssi_status_get(struct rsnd_mod *mod)\n{\n\treturn rsnd_mod_read(mod, SSISR);\n}\n\nstatic void rsnd_ssi_status_check(struct rsnd_mod *mod,\n\t\t\t\t  u32 bit)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tu32 status;\n\tint i;\n\n\tfor (i = 0; i < 1024; i++) {\n\t\tstatus = rsnd_ssi_status_get(mod);\n\t\tif (status & bit)\n\t\t\treturn;\n\n\t\tudelay(5);\n\t}\n\n\tdev_warn(dev, \"%s status check failed\\n\", rsnd_mod_name(mod));\n}\n\nstatic u32 rsnd_ssi_multi_secondaries(struct rsnd_dai_stream *io)\n{\n\tstatic const enum rsnd_mod_type types[] = {\n\t\tRSND_MOD_SSIM1,\n\t\tRSND_MOD_SSIM2,\n\t\tRSND_MOD_SSIM3,\n\t};\n\tint i, mask;\n\n\tmask = 0;\n\tfor (i = 0; i < ARRAY_SIZE(types); i++) {\n\t\tstruct rsnd_mod *mod = rsnd_io_to_mod(io, types[i]);\n\n\t\tif (!mod)\n\t\t\tcontinue;\n\n\t\tmask |= 1 << rsnd_mod_id(mod);\n\t}\n\n\treturn mask;\n}\n\nstatic u32 rsnd_ssi_run_mods(struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\n\tstruct rsnd_mod *ssi_parent_mod = rsnd_io_to_mod_ssip(io);\n\tu32 mods;\n\n\tmods = rsnd_ssi_multi_secondaries_runtime(io) |\n\t\t1 << rsnd_mod_id(ssi_mod);\n\n\tif (ssi_parent_mod)\n\t\tmods |= 1 << rsnd_mod_id(ssi_parent_mod);\n\n\treturn mods;\n}\n\nu32 rsnd_ssi_multi_secondaries_runtime(struct rsnd_dai_stream *io)\n{\n\tif (rsnd_runtime_is_multi_ssi(io))\n\t\treturn rsnd_ssi_multi_secondaries(io);\n\n\treturn 0;\n}\n\nstatic u32 rsnd_rdai_width_to_swl(struct rsnd_dai *rdai)\n{\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint width = rsnd_rdai_width_get(rdai);\n\n\tswitch (width) {\n\tcase 32: return SWL_32;\n\tcase 24: return SWL_24;\n\tcase 16: return SWL_16;\n\t}\n\n\tdev_err(dev, \"unsupported slot width value: %d\\n\", width);\n\treturn 0;\n}\n\nunsigned int rsnd_ssi_clk_query(struct rsnd_dai *rdai,\n\t\t       int param1, int param2, int *idx)\n{\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstatic const int ssi_clk_mul_table[] = {\n\t\t1, 2, 4, 8, 16, 6, 12,\n\t};\n\tint j, ret;\n\tunsigned int main_rate;\n\tint width = rsnd_rdai_width_get(rdai);\n\n\tfor (j = 0; j < ARRAY_SIZE(ssi_clk_mul_table); j++) {\n\n\t\t \n\t\tif (j == 0)\n\t\t\tcontinue;\n\n\t\tmain_rate = width * param1 * param2 * ssi_clk_mul_table[j];\n\n\t\tret = rsnd_adg_clk_query(priv, main_rate);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (idx)\n\t\t\t*idx = j;\n\n\t\treturn main_rate;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_master_clk_start(struct rsnd_mod *mod,\n\t\t\t\t     struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tint chan = rsnd_runtime_channel_for_ssi(io);\n\tint idx, ret;\n\tunsigned int main_rate;\n\tunsigned int rate = rsnd_io_is_play(io) ?\n\t\trsnd_src_get_out_rate(priv, io) :\n\t\trsnd_src_get_in_rate(priv, io);\n\n\tif (!rsnd_rdai_is_clk_master(rdai))\n\t\treturn 0;\n\n\tif (!rsnd_ssi_can_output_clk(mod))\n\t\treturn 0;\n\n\tif (rsnd_ssi_is_multi_secondary(mod, io))\n\t\treturn 0;\n\n\tif (rsnd_runtime_is_tdm_split(io))\n\t\tchan = rsnd_io_converted_chan(io);\n\n\tchan = rsnd_channel_normalization(chan);\n\n\tif (ssi->usrcnt > 0) {\n\t\tif (ssi->rate != rate) {\n\t\t\tdev_err(dev, \"SSI parent/child should use same rate\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ssi->chan != chan) {\n\t\t\tdev_err(dev, \"SSI parent/child should use same chan\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tmain_rate = rsnd_ssi_clk_query(rdai, rate, chan, &idx);\n\tif (!main_rate)\n\t\tgoto rate_err;\n\n\tret = rsnd_adg_ssi_clk_try_start(mod, main_rate);\n\tif (ret < 0)\n\t\tgoto rate_err;\n\n\t \n\tssi->cr_clk = FORCE | rsnd_rdai_width_to_swl(rdai) |\n\t\t\tSCKD | SWSD | CKDV(idx);\n\tssi->wsr = CONT;\n\tssi->rate = rate;\n\tssi->chan = chan;\n\n\tdev_dbg(dev, \"%s outputs %d chan %u Hz\\n\",\n\t\trsnd_mod_name(mod), chan, rate);\n\n\treturn 0;\n\nrate_err:\n\tdev_err(dev, \"unsupported clock rate\\n\");\n\treturn ret;\n}\n\nstatic void rsnd_ssi_master_clk_stop(struct rsnd_mod *mod,\n\t\t\t\t     struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\n\tif (!rsnd_rdai_is_clk_master(rdai))\n\t\treturn;\n\n\tif (!rsnd_ssi_can_output_clk(mod))\n\t\treturn;\n\n\tif (ssi->usrcnt > 1)\n\t\treturn;\n\n\tssi->cr_clk\t= 0;\n\tssi->rate\t= 0;\n\tssi->chan\t= 0;\n\n\trsnd_adg_ssi_clk_stop(mod);\n}\n\nstatic void rsnd_ssi_config_init(struct rsnd_mod *mod,\n\t\t\t\tstruct rsnd_dai_stream *io)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tu32 cr_own\t= ssi->cr_own;\n\tu32 cr_mode\t= ssi->cr_mode;\n\tu32 wsr\t\t= ssi->wsr;\n\tint width;\n\tint is_tdm, is_tdm_split;\n\n\tis_tdm\t\t= rsnd_runtime_is_tdm(io);\n\tis_tdm_split\t= rsnd_runtime_is_tdm_split(io);\n\n\tif (is_tdm)\n\t\tdev_dbg(dev, \"TDM mode\\n\");\n\tif (is_tdm_split)\n\t\tdev_dbg(dev, \"TDM Split mode\\n\");\n\n\tcr_own |= FORCE | rsnd_rdai_width_to_swl(rdai);\n\n\tif (rdai->bit_clk_inv)\n\t\tcr_own |= SCKP;\n\tif (rdai->frm_clk_inv && !is_tdm)\n\t\tcr_own |= SWSP;\n\tif (rdai->data_alignment)\n\t\tcr_own |= SDTA;\n\tif (rdai->sys_delay)\n\t\tcr_own |= DEL;\n\n\t \n\tif (is_tdm || is_tdm_split) {\n\t\twsr\t|= WS_MODE;\n\t\tcr_own\t|= CHNL_8;\n\t}\n\n\t \n\tif (rsnd_ssi_is_parent(mod, io))\n\t\tgoto init_end;\n\n\tif (rsnd_io_is_play(io))\n\t\tcr_own |= TRMD;\n\n\tcr_own &= ~DWL_MASK;\n\twidth = snd_pcm_format_width(runtime->format);\n\tif (is_tdm_split) {\n\t\t \n\t\twidth = 32;\n\t}\n\n\tswitch (width) {\n\tcase 8:\n\t\tcr_own |= DWL_8;\n\t\tbreak;\n\tcase 16:\n\t\tcr_own |= DWL_16;\n\t\tbreak;\n\tcase 24:\n\t\tcr_own |= DWL_24;\n\t\tbreak;\n\tcase 32:\n\t\tcr_own |= DWL_32;\n\t\tbreak;\n\t}\n\n\tif (rsnd_ssi_is_dma_mode(mod)) {\n\t\tcr_mode = UIEN | OIEN |\t \n\t\t\t  DMEN;\t\t \n\t} else {\n\t\tcr_mode = DIEN;\t\t \n\t}\n\ninit_end:\n\tssi->cr_own\t= cr_own;\n\tssi->cr_mode\t= cr_mode;\n\tssi->wsr\t= wsr;\n}\n\nstatic void rsnd_ssi_register_setup(struct rsnd_mod *mod)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\n\trsnd_mod_write(mod, SSIWSR,\tssi->wsr);\n\trsnd_mod_write(mod, SSICR,\tssi->cr_own\t|\n\t\t\t\t\tssi->cr_clk\t|\n\t\t\t\t\tssi->cr_mode\t|\n\t\t\t\t\tssi->cr_en);\n}\n\n \nstatic int rsnd_ssi_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tint ret;\n\n\tif (!rsnd_ssi_is_run_mods(mod, io))\n\t\treturn 0;\n\n\tret = rsnd_ssi_master_clk_start(mod, io);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tssi->usrcnt++;\n\n\tret = rsnd_mod_power_on(mod);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trsnd_ssi_config_init(mod, io);\n\n\trsnd_ssi_register_setup(mod);\n\n\t \n\trsnd_ssi_status_clear(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_quit(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tif (!rsnd_ssi_is_run_mods(mod, io))\n\t\treturn 0;\n\n\tif (!ssi->usrcnt) {\n\t\tdev_err(dev, \"%s usrcnt error\\n\", rsnd_mod_name(mod));\n\t\treturn -EIO;\n\t}\n\n\trsnd_ssi_master_clk_stop(mod, io);\n\n\trsnd_mod_power_off(mod);\n\n\tssi->usrcnt--;\n\n\tif (!ssi->usrcnt) {\n\t\tssi->cr_own\t= 0;\n\t\tssi->cr_mode\t= 0;\n\t\tssi->wsr\t= 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_hw_params(struct rsnd_mod *mod,\n\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tunsigned int fmt_width = snd_pcm_format_width(params_format(params));\n\n\tif (fmt_width > rdai->chan_width) {\n\t\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t\tdev_err(dev, \"invalid combination of slot-width and format-data-width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_start(struct rsnd_mod *mod,\n\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t  struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\n\tif (!rsnd_ssi_is_run_mods(mod, io))\n\t\treturn 0;\n\n\t \n\tif (rsnd_ssi_multi_secondaries_runtime(io))\n\t\treturn 0;\n\n\t \n\tif (rsnd_ssi_is_parent(mod, io))\n\t\treturn 0;\n\n\tssi->cr_en = EN;\n\n\trsnd_mod_write(mod, SSICR,\tssi->cr_own\t|\n\t\t\t\t\tssi->cr_clk\t|\n\t\t\t\t\tssi->cr_mode\t|\n\t\t\t\t\tssi->cr_en);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_stop(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tu32 cr;\n\n\tif (!rsnd_ssi_is_run_mods(mod, io))\n\t\treturn 0;\n\n\tif (rsnd_ssi_is_parent(mod, io))\n\t\treturn 0;\n\n\tcr  =\tssi->cr_own\t|\n\t\tssi->cr_clk;\n\n\t \n\tif (rsnd_io_is_play(io)) {\n\t\trsnd_mod_write(mod, SSICR, cr | ssi->cr_en);\n\t\trsnd_ssi_status_check(mod, DIRQ);\n\t}\n\n\t \n\tif (rsnd_ssi_multi_secondaries_runtime(io))\n\t\treturn 0;\n\n\t \n\trsnd_mod_write(mod, SSICR, cr);\t \n\trsnd_ssi_status_check(mod, IIRQ);\n\n\tssi->cr_en = 0;\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_irq(struct rsnd_mod *mod,\n\t\t\tstruct rsnd_dai_stream *io,\n\t\t\tstruct rsnd_priv *priv,\n\t\t\tint enable)\n{\n\tu32 val = 0;\n\tint is_tdm, is_tdm_split;\n\tint id = rsnd_mod_id(mod);\n\n\tis_tdm\t\t= rsnd_runtime_is_tdm(io);\n\tis_tdm_split\t= rsnd_runtime_is_tdm_split(io);\n\n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\tif (rsnd_ssi_is_parent(mod, io))\n\t\treturn 0;\n\n\tif (!rsnd_ssi_is_run_mods(mod, io))\n\t\treturn 0;\n\n\tif (enable)\n\t\tval = rsnd_ssi_is_dma_mode(mod) ? 0x0e000000 : 0x0f000000;\n\n\tif (is_tdm || is_tdm_split) {\n\t\tswitch (id) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 9:\n\t\t\tval |= 0x0000ff00;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trsnd_mod_write(mod, SSI_INT_ENABLE, val);\n\n\treturn 0;\n}\n\nstatic bool rsnd_ssi_pio_interrupt(struct rsnd_mod *mod,\n\t\t\t\t   struct rsnd_dai_stream *io);\nstatic void __rsnd_ssi_interrupt(struct rsnd_mod *mod,\n\t\t\t\t struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint is_dma = rsnd_ssi_is_dma_mode(mod);\n\tu32 status;\n\tbool elapsed = false;\n\tbool stop = false;\n\n\tspin_lock(&priv->lock);\n\n\t \n\tif (!rsnd_io_is_working(io))\n\t\tgoto rsnd_ssi_interrupt_out;\n\n\tstatus = rsnd_ssi_status_get(mod);\n\n\t \n\tif (!is_dma && (status & DIRQ))\n\t\telapsed = rsnd_ssi_pio_interrupt(mod, io);\n\n\t \n\tif (is_dma && (status & (UIRQ | OIRQ))) {\n\t\trsnd_print_irq_status(dev, \"%s err status : 0x%08x\\n\",\n\t\t\t\t      rsnd_mod_name(mod), status);\n\n\t\tstop = true;\n\t}\n\n\tstop |= rsnd_ssiu_busif_err_status_clear(mod);\n\n\trsnd_ssi_status_clear(mod);\nrsnd_ssi_interrupt_out:\n\tspin_unlock(&priv->lock);\n\n\tif (elapsed)\n\t\trsnd_dai_period_elapsed(io);\n\n\tif (stop)\n\t\tsnd_pcm_stop_xrun(io->substream);\n\n}\n\nstatic irqreturn_t rsnd_ssi_interrupt(int irq, void *data)\n{\n\tstruct rsnd_mod *mod = data;\n\n\trsnd_mod_interrupt(mod, __rsnd_ssi_interrupt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 *rsnd_ssi_get_status(struct rsnd_mod *mod,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tenum rsnd_mod_type type)\n{\n\t \n\tif (type == RSND_MOD_SSIP)\n\t\treturn &io->parent_ssi_status;\n\n\treturn rsnd_mod_get_status(mod, io, type);\n}\n\n \nstatic void rsnd_ssi_parent_attach(struct rsnd_mod *mod,\n\t\t\t\t   struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\n\tif (!__rsnd_ssi_is_pin_sharing(mod))\n\t\treturn;\n\n\tif (!rsnd_rdai_is_clk_master(rdai))\n\t\treturn;\n\n\tif (rsnd_ssi_is_multi_secondary(mod, io))\n\t\treturn;\n\n\tswitch (rsnd_mod_id(mod)) {\n\tcase 1:\n\tcase 2:\n\tcase 9:\n\t\trsnd_dai_connect(rsnd_ssi_mod_get(priv, 0), io, RSND_MOD_SSIP);\n\t\tbreak;\n\tcase 4:\n\t\trsnd_dai_connect(rsnd_ssi_mod_get(priv, 3), io, RSND_MOD_SSIP);\n\t\tbreak;\n\tcase 8:\n\t\trsnd_dai_connect(rsnd_ssi_mod_get(priv, 7), io, RSND_MOD_SSIP);\n\t\tbreak;\n\t}\n}\n\nstatic int rsnd_ssi_pcm_new(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\t \n\trsnd_ssi_parent_attach(mod, io);\n\n\treturn 0;\n}\n\nstatic int rsnd_ssi_common_probe(struct rsnd_mod *mod,\n\t\t\t\t struct rsnd_dai_stream *io,\n\t\t\t\t struct rsnd_priv *priv)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tint ret = 0;\n\n\t \n\tif (rsnd_ssi_is_multi_secondary(mod, io))\n\t\treturn 0;\n\n\t \n\n\t \n\tif (!rsnd_flags_has(ssi, RSND_SSI_PROBED)) {\n\t\tret = request_irq(ssi->irq,\n\t\t\t\t  rsnd_ssi_interrupt,\n\t\t\t\t  IRQF_SHARED,\n\t\t\t\t  dev_name(dev), mod);\n\n\t\trsnd_flags_set(ssi, RSND_SSI_PROBED);\n\t}\n\n\treturn ret;\n}\n\nstatic int rsnd_ssi_common_remove(struct rsnd_mod *mod,\n\t\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t\t  struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tstruct rsnd_mod *pure_ssi_mod = rsnd_io_to_mod_ssi(io);\n\n\t \n\tif (pure_ssi_mod != mod)\n\t\treturn 0;\n\n\t \n\tif (rsnd_flags_has(ssi, RSND_SSI_PROBED)) {\n\t\tfree_irq(ssi->irq, mod);\n\n\t\trsnd_flags_del(ssi, RSND_SSI_PROBED);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool rsnd_ssi_pio_interrupt(struct rsnd_mod *mod,\n\t\t\t\t   struct rsnd_dai_stream *io)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tu32 *buf = (u32 *)(runtime->dma_area + ssi->byte_pos);\n\tint shift = 0;\n\tint byte_pos;\n\tbool elapsed = false;\n\n\tif (snd_pcm_format_width(runtime->format) == 24)\n\t\tshift = 8;\n\n\t \n\tif (rsnd_io_is_play(io))\n\t\trsnd_mod_write(mod, SSITDR, (*buf) << shift);\n\telse\n\t\t*buf = (rsnd_mod_read(mod, SSIRDR) >> shift);\n\n\tbyte_pos = ssi->byte_pos + sizeof(*buf);\n\n\tif (byte_pos >= ssi->next_period_byte) {\n\t\tint period_pos = byte_pos / ssi->byte_per_period;\n\n\t\tif (period_pos >= runtime->periods) {\n\t\t\tbyte_pos = 0;\n\t\t\tperiod_pos = 0;\n\t\t}\n\n\t\tssi->next_period_byte = (period_pos + 1) * ssi->byte_per_period;\n\n\t\telapsed = true;\n\t}\n\n\tWRITE_ONCE(ssi->byte_pos, byte_pos);\n\n\treturn elapsed;\n}\n\nstatic int rsnd_ssi_pio_init(struct rsnd_mod *mod,\n\t\t\t     struct rsnd_dai_stream *io,\n\t\t\t     struct rsnd_priv *priv)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\n\tif (!rsnd_ssi_is_parent(mod, io)) {\n\t\tssi->byte_pos\t\t= 0;\n\t\tssi->byte_per_period\t= runtime->period_size *\n\t\t\t\t\t  runtime->channels *\n\t\t\t\t\t  samples_to_bytes(runtime, 1);\n\t\tssi->next_period_byte\t= ssi->byte_per_period;\n\t}\n\n\treturn rsnd_ssi_init(mod, io, priv);\n}\n\nstatic int rsnd_ssi_pio_pointer(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    snd_pcm_uframes_t *pointer)\n{\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\n\t*pointer = bytes_to_frames(runtime, READ_ONCE(ssi->byte_pos));\n\n\treturn 0;\n}\n\nstatic struct rsnd_mod_ops rsnd_ssi_pio_ops = {\n\t.name\t\t= SSI_NAME,\n\t.probe\t\t= rsnd_ssi_common_probe,\n\t.remove\t\t= rsnd_ssi_common_remove,\n\t.init\t\t= rsnd_ssi_pio_init,\n\t.quit\t\t= rsnd_ssi_quit,\n\t.start\t\t= rsnd_ssi_start,\n\t.stop\t\t= rsnd_ssi_stop,\n\t.irq\t\t= rsnd_ssi_irq,\n\t.pointer\t= rsnd_ssi_pio_pointer,\n\t.pcm_new\t= rsnd_ssi_pcm_new,\n\t.hw_params\t= rsnd_ssi_hw_params,\n\t.get_status\t= rsnd_ssi_get_status,\n};\n\nstatic int rsnd_ssi_dma_probe(struct rsnd_mod *mod,\n\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t      struct rsnd_priv *priv)\n{\n\tint ret;\n\n\t \n\tif (rsnd_ssi_is_multi_secondary(mod, io))\n\t\treturn 0;\n\n\tret = rsnd_ssi_common_probe(mod, io, priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rsnd_dma_attach(io, mod, &io->dma);\n\n\treturn ret;\n}\n\nstatic int rsnd_ssi_fallback(struct rsnd_mod *mod,\n\t\t\t     struct rsnd_dai_stream *io,\n\t\t\t     struct rsnd_priv *priv)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t \n\tmod->ops = &rsnd_ssi_pio_ops;\n\n\tdev_info(dev, \"%s fallback to PIO mode\\n\", rsnd_mod_name(mod));\n\n\treturn 0;\n}\n\nstatic struct dma_chan *rsnd_ssi_dma_req(struct rsnd_dai_stream *io,\n\t\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tint is_play = rsnd_io_is_play(io);\n\tchar *name;\n\n\t \n\n\tif (rsnd_ssi_use_busif(io))\n\t\tname = is_play ? \"rxu\" : \"txu\";\n\telse\n\t\tname = is_play ? \"rx\" : \"tx\";\n\n\treturn rsnd_dma_request_channel(rsnd_ssi_of_node(priv),\n\t\t\t\t\tSSI_NAME, mod, name);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_ssi_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\n\n\tseq_printf(m, \"clock:           %s\\n\",\t\trsnd_rdai_is_clk_master(rdai) ?\n\t\t\t\t\t\t\t\t\"provider\" : \"consumer\");\n\tseq_printf(m, \"bit_clk_inv:     %d\\n\",\t\trdai->bit_clk_inv);\n\tseq_printf(m, \"frm_clk_inv:     %d\\n\",\t\trdai->frm_clk_inv);\n\tseq_printf(m, \"pin share:       %d\\n\",\t\t__rsnd_ssi_is_pin_sharing(mod));\n\tseq_printf(m, \"can out clk:     %d\\n\",\t\trsnd_ssi_can_output_clk(mod));\n\tseq_printf(m, \"multi secondary: %d\\n\",\t\trsnd_ssi_is_multi_secondary(mod, io));\n\tseq_printf(m, \"tdm:             %d, %d\\n\",\trsnd_runtime_is_tdm(io),\n\t\t\t\t\t\t\trsnd_runtime_is_tdm_split(io));\n\tseq_printf(m, \"chan:            %d\\n\",\t\tssi->chan);\n\tseq_printf(m, \"user:            %d\\n\",\t\tssi->usrcnt);\n\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SSI,\n\t\t\t\t  rsnd_mod_id(mod) * 0x40, 0x40);\n}\n#define DEBUG_INFO .debug_info = rsnd_ssi_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_ssi_dma_ops = {\n\t.name\t\t= SSI_NAME,\n\t.dma_req\t= rsnd_ssi_dma_req,\n\t.probe\t\t= rsnd_ssi_dma_probe,\n\t.remove\t\t= rsnd_ssi_common_remove,\n\t.init\t\t= rsnd_ssi_init,\n\t.quit\t\t= rsnd_ssi_quit,\n\t.start\t\t= rsnd_ssi_start,\n\t.stop\t\t= rsnd_ssi_stop,\n\t.irq\t\t= rsnd_ssi_irq,\n\t.pcm_new\t= rsnd_ssi_pcm_new,\n\t.fallback\t= rsnd_ssi_fallback,\n\t.hw_params\t= rsnd_ssi_hw_params,\n\t.get_status\t= rsnd_ssi_get_status,\n\tDEBUG_INFO\n};\n\nint rsnd_ssi_is_dma_mode(struct rsnd_mod *mod)\n{\n\treturn mod->ops == &rsnd_ssi_dma_ops;\n}\n\n \nstatic void rsnd_ssi_connect(struct rsnd_mod *mod,\n\t\t\t     struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tstatic const enum rsnd_mod_type types[] = {\n\t\tRSND_MOD_SSI,\n\t\tRSND_MOD_SSIM1,\n\t\tRSND_MOD_SSIM2,\n\t\tRSND_MOD_SSIM3,\n\t};\n\tenum rsnd_mod_type type;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(types); i++) {\n\t\ttype = types[i];\n\t\tif (!rsnd_io_to_mod(io, type)) {\n\t\t\trsnd_dai_connect(mod, io, type);\n\t\t\trsnd_rdai_channels_set(rdai, (i + 1) * 2);\n\t\t\trsnd_rdai_ssi_lane_set(rdai, (i + 1));\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid rsnd_parse_connect_ssi(struct rsnd_dai *rdai,\n\t\t\t    struct device_node *playback,\n\t\t\t    struct device_node *capture)\n{\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tint i;\n\n\tnode = rsnd_ssi_of_node(priv);\n\tif (!node)\n\t\treturn;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tstruct rsnd_mod *mod;\n\n\t\ti = rsnd_node_fixed_index(dev, np, SSI_NAME, i);\n\t\tif (i < 0) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tmod = rsnd_ssi_mod_get(priv, i);\n\n\t\tif (np == playback)\n\t\t\trsnd_ssi_connect(mod, &rdai->playback);\n\t\tif (np == capture)\n\t\t\trsnd_ssi_connect(mod, &rdai->capture);\n\t\ti++;\n\t}\n\n\tof_node_put(node);\n}\n\nstruct rsnd_mod *rsnd_ssi_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_ssi_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get(rsnd_ssi_get(priv, id));\n}\n\nint __rsnd_ssi_is_pin_sharing(struct rsnd_mod *mod)\n{\n\tif (!mod)\n\t\treturn 0;\n\n\treturn !!(rsnd_flags_has(rsnd_mod_to_ssi(mod), RSND_SSI_CLK_PIN_SHARE));\n}\n\nint rsnd_ssi_probe(struct rsnd_priv *priv)\n{\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_mod_ops *ops;\n\tstruct clk *clk;\n\tstruct rsnd_ssi *ssi;\n\tchar name[RSND_SSI_NAME_SIZE];\n\tint i, nr, ret;\n\n\tnode = rsnd_ssi_of_node(priv);\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tnr = rsnd_node_count(priv, node, SSI_NAME);\n\tif (!nr) {\n\t\tret = -EINVAL;\n\t\tgoto rsnd_ssi_probe_done;\n\t}\n\n\tssi\t= devm_kcalloc(dev, nr, sizeof(*ssi), GFP_KERNEL);\n\tif (!ssi) {\n\t\tret = -ENOMEM;\n\t\tgoto rsnd_ssi_probe_done;\n\t}\n\n\tpriv->ssi\t= ssi;\n\tpriv->ssi_nr\t= nr;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tif (!of_device_is_available(np))\n\t\t\tgoto skip;\n\n\t\ti = rsnd_node_fixed_index(dev, np, SSI_NAME, i);\n\t\tif (i < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ssi_probe_done;\n\t\t}\n\n\t\tssi = rsnd_ssi_get(priv, i);\n\n\t\tsnprintf(name, RSND_SSI_NAME_SIZE, \"%s.%d\",\n\t\t\t SSI_NAME, i);\n\n\t\tclk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ssi_probe_done;\n\t\t}\n\n\t\tif (of_property_read_bool(np, \"shared-pin\"))\n\t\t\trsnd_flags_set(ssi, RSND_SSI_CLK_PIN_SHARE);\n\n\t\tif (of_property_read_bool(np, \"no-busif\"))\n\t\t\trsnd_flags_set(ssi, RSND_SSI_NO_BUSIF);\n\n\t\tssi->irq = irq_of_parse_and_map(np, 0);\n\t\tif (!ssi->irq) {\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ssi_probe_done;\n\t\t}\n\n\t\tif (of_property_read_bool(np, \"pio-transfer\"))\n\t\t\tops = &rsnd_ssi_pio_ops;\n\t\telse\n\t\t\tops = &rsnd_ssi_dma_ops;\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(ssi), ops, clk,\n\t\t\t\t    RSND_MOD_SSI, i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ssi_probe_done;\n\t\t}\nskip:\n\t\ti++;\n\t}\n\n\tret = 0;\n\nrsnd_ssi_probe_done:\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nvoid rsnd_ssi_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_ssi *ssi;\n\tint i;\n\n\tfor_each_rsnd_ssi(ssi, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(ssi));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}