{
  "module_name": "cmd.c",
  "hash_id": "7419809ea2128407b5130b99954e45558d665523b35cfd6e32b62d7c2330f987",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/cmd.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include \"rsnd.h\"\n\nstruct rsnd_cmd {\n\tstruct rsnd_mod mod;\n};\n\n#define CMD_NAME \"cmd\"\n\n#define rsnd_cmd_nr(priv) ((priv)->cmd_nr)\n#define for_each_rsnd_cmd(pos, priv, i)\t\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < rsnd_cmd_nr(priv)) &&\t\t\t\t\\\n\t\t     ((pos) = (struct rsnd_cmd *)(priv)->cmd + i);\t\\\n\t     i++)\n\nstatic int rsnd_cmd_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);\n\tstruct rsnd_mod *mix = rsnd_io_to_mod_mix(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tu32 data;\n\tstatic const u32 path[] = {\n\t\t[1] = 1 << 0,\n\t\t[5] = 1 << 8,\n\t\t[6] = 1 << 12,\n\t\t[9] = 1 << 15,\n\t};\n\n\tif (!mix && !dvc)\n\t\treturn 0;\n\n\tif (ARRAY_SIZE(path) < rsnd_mod_id(mod) + 1)\n\t\treturn -ENXIO;\n\n\tif (mix) {\n\t\tstruct rsnd_dai *rdai;\n\t\tint i;\n\n\t\t \n\t\tdata = 0;\n\t\tfor_each_rsnd_dai(rdai, priv, i) {\n\t\t\tstruct rsnd_dai_stream *tio = &rdai->playback;\n\t\t\tstruct rsnd_mod *src = rsnd_io_to_mod_src(tio);\n\n\t\t\tif (mix == rsnd_io_to_mod_mix(tio))\n\t\t\t\tdata |= path[rsnd_mod_id(src)];\n\n\t\t\ttio = &rdai->capture;\n\t\t\tsrc = rsnd_io_to_mod_src(tio);\n\t\t\tif (mix == rsnd_io_to_mod_mix(tio))\n\t\t\t\tdata |= path[rsnd_mod_id(src)];\n\t\t}\n\n\t} else {\n\t\tstruct rsnd_mod *src = rsnd_io_to_mod_src(io);\n\n\t\tstatic const u8 cmd_case[] = {\n\t\t\t[0] = 0x3,\n\t\t\t[1] = 0x3,\n\t\t\t[2] = 0x4,\n\t\t\t[3] = 0x1,\n\t\t\t[4] = 0x2,\n\t\t\t[5] = 0x4,\n\t\t\t[6] = 0x1,\n\t\t\t[9] = 0x2,\n\t\t};\n\n\t\tif (unlikely(!src))\n\t\t\treturn -EIO;\n\n\t\tdata = path[rsnd_mod_id(src)] |\n\t\t\tcmd_case[rsnd_mod_id(src)] << 16;\n\t}\n\n\tdev_dbg(dev, \"ctu/mix path = 0x%08x\\n\", data);\n\n\trsnd_mod_write(mod, CMD_ROUTE_SLCT, data);\n\trsnd_mod_write(mod, CMD_BUSIF_MODE, rsnd_get_busif_shift(io, mod) | 1);\n\trsnd_mod_write(mod, CMD_BUSIF_DALIGN, rsnd_get_dalign(mod, io));\n\n\trsnd_adg_set_cmd_timsel_gen2(mod, io);\n\n\treturn 0;\n}\n\nstatic int rsnd_cmd_start(struct rsnd_mod *mod,\n\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t  struct rsnd_priv *priv)\n{\n\trsnd_mod_write(mod, CMD_CTRL, 0x10);\n\n\treturn 0;\n}\n\nstatic int rsnd_cmd_stop(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\trsnd_mod_write(mod, CMD_CTRL, 0);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_cmd_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0x180 + rsnd_mod_id_raw(mod) * 0x20, 0x30);\n}\n#define DEBUG_INFO .debug_info = rsnd_cmd_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_cmd_ops = {\n\t.name\t\t= CMD_NAME,\n\t.init\t\t= rsnd_cmd_init,\n\t.start\t\t= rsnd_cmd_start,\n\t.stop\t\t= rsnd_cmd_stop,\n\t.get_status\t= rsnd_mod_get_status,\n\tDEBUG_INFO\n};\n\nstatic struct rsnd_mod *rsnd_cmd_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_cmd_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get((struct rsnd_cmd *)(priv->cmd) + id);\n}\nint rsnd_cmd_attach(struct rsnd_dai_stream *io, int id)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct rsnd_mod *mod = rsnd_cmd_mod_get(priv, id);\n\n\treturn rsnd_dai_connect(mod, io, mod->type);\n}\n\nint rsnd_cmd_probe(struct rsnd_priv *priv)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_cmd *cmd;\n\tint i, nr;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\t \n\tnr = priv->dvc_nr;\n\tif (!nr)\n\t\treturn 0;\n\n\tcmd = devm_kcalloc(dev, nr, sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tpriv->cmd_nr\t= nr;\n\tpriv->cmd\t= cmd;\n\n\tfor_each_rsnd_cmd(cmd, priv, i) {\n\t\tint ret = rsnd_mod_init(priv, rsnd_mod_get(cmd),\n\t\t\t\t\t&rsnd_cmd_ops, NULL,\n\t\t\t\t\tRSND_MOD_CMD, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid rsnd_cmd_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_cmd *cmd;\n\tint i;\n\n\tfor_each_rsnd_cmd(cmd, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(cmd));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}