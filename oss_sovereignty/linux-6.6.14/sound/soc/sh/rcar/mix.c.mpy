{
  "module_name": "mix.c",
  "hash_id": "9c254ebbc96d6372c760743c287a578181aa015d6179f9e30cb1478481d57bd9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/mix.c",
  "human_readable_source": "\n\n\n\n\n\n \n\n#include \"rsnd.h\"\n\n#define MIX_NAME_SIZE\t16\n#define MIX_NAME \"mix\"\n\nstruct rsnd_mix {\n\tstruct rsnd_mod mod;\n\tstruct rsnd_kctrl_cfg_s volumeA;  \n\tstruct rsnd_kctrl_cfg_s volumeB;  \n\tstruct rsnd_kctrl_cfg_s volumeC;  \n\tstruct rsnd_kctrl_cfg_s volumeD;  \n\tstruct rsnd_kctrl_cfg_s ren;\t \n\tstruct rsnd_kctrl_cfg_s rup;\t \n\tstruct rsnd_kctrl_cfg_s rdw;\t \n\tu32 flags;\n};\n\n#define ONCE_KCTRL_INITIALIZED\t\t(1 << 0)\n#define HAS_VOLA\t\t\t(1 << 1)\n#define HAS_VOLB\t\t\t(1 << 2)\n#define HAS_VOLC\t\t\t(1 << 3)\n#define HAS_VOLD\t\t\t(1 << 4)\n\n#define VOL_MAX\t\t\t\t0x3ff\n\n#define rsnd_mod_to_mix(_mod)\t\\\n\tcontainer_of((_mod), struct rsnd_mix, mod)\n\n#define rsnd_mix_get(priv, id) ((struct rsnd_mix *)(priv->mix) + id)\n#define rsnd_mix_nr(priv) ((priv)->mix_nr)\n#define for_each_rsnd_mix(pos, priv, i)\t\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < rsnd_mix_nr(priv)) &&\t\t\t\t\\\n\t\t     ((pos) = (struct rsnd_mix *)(priv)->mix + i);\t\\\n\t     i++)\n\nstatic void rsnd_mix_activation(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, MIX_SWRSR, 0);\n\trsnd_mod_write(mod, MIX_SWRSR, 1);\n}\n\nstatic void rsnd_mix_halt(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, MIX_MIXIR, 1);\n\trsnd_mod_write(mod, MIX_SWRSR, 0);\n}\n\n#define rsnd_mix_get_vol(mix, X) \\\n\trsnd_flags_has(mix, HAS_VOL##X) ? \\\n\t\t(VOL_MAX - rsnd_kctrl_vals(mix->volume##X)) : 0\nstatic void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,\n\t\t\t\t      struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_mix *mix = rsnd_mod_to_mix(mod);\n\tu32 volA = rsnd_mix_get_vol(mix, A);\n\tu32 volB = rsnd_mix_get_vol(mix, B);\n\tu32 volC = rsnd_mix_get_vol(mix, C);\n\tu32 volD = rsnd_mix_get_vol(mix, D);\n\n\tdev_dbg(dev, \"MIX A/B/C/D = %02x/%02x/%02x/%02x\\n\",\n\t\tvolA, volB, volC, volD);\n\n\trsnd_mod_write(mod, MIX_MDBAR, volA);\n\trsnd_mod_write(mod, MIX_MDBBR, volB);\n\trsnd_mod_write(mod, MIX_MDBCR, volC);\n\trsnd_mod_write(mod, MIX_MDBDR, volD);\n}\n\nstatic void rsnd_mix_volume_init(struct rsnd_dai_stream *io,\n\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_mix *mix = rsnd_mod_to_mix(mod);\n\n\trsnd_mod_write(mod, MIX_MIXIR, 1);\n\n\t \n\trsnd_mod_write(mod, MIX_ADINR, rsnd_runtime_channel_after_ctu(io));\n\n\t \n\trsnd_mod_write(mod, MIX_MIXMR, rsnd_kctrl_vals(mix->ren));\n\trsnd_mod_write(mod, MIX_MVPDR, rsnd_kctrl_vals(mix->rup) << 8 |\n\t\t\t\t       rsnd_kctrl_vals(mix->rdw));\n\n\t \n\trsnd_mix_volume_parameter(io, mod);\n\n\trsnd_mod_write(mod, MIX_MIXIR, 0);\n}\n\nstatic void rsnd_mix_volume_update(struct rsnd_dai_stream *io,\n\t\t\t\t  struct rsnd_mod *mod)\n{\n\t \n\trsnd_mod_write(mod, MIX_MDBER, 0);\n\n\t \n\trsnd_mix_volume_parameter(io, mod);\n\n\t \n\trsnd_mod_write(mod, MIX_MDBER, 1);\n}\n\nstatic int rsnd_mix_probe_(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\treturn rsnd_cmd_attach(io, rsnd_mod_id(mod));\n}\n\nstatic int rsnd_mix_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tint ret;\n\n\tret = rsnd_mod_power_on(mod);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trsnd_mix_activation(mod);\n\n\trsnd_mix_volume_init(io, mod);\n\n\trsnd_mix_volume_update(io, mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_mix_quit(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\trsnd_mix_halt(mod);\n\n\trsnd_mod_power_off(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_mix_pcm_new(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_mix *mix = rsnd_mod_to_mix(mod);\n\tstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\n\tstruct rsnd_kctrl_cfg_s *volume;\n\tint ret;\n\n\tswitch (rsnd_mod_id(src_mod)) {\n\tcase 3:\n\tcase 6:\t \n\t\tvolume = &mix->volumeA;\n\t\trsnd_flags_set(mix, HAS_VOLA);\n\t\tbreak;\n\tcase 4:\n\tcase 9:\t \n\t\tvolume = &mix->volumeB;\n\t\trsnd_flags_set(mix, HAS_VOLB);\n\t\tbreak;\n\tcase 0:\n\tcase 1:\t \n\t\tvolume = &mix->volumeC;\n\t\trsnd_flags_set(mix, HAS_VOLC);\n\t\tbreak;\n\tcase 2:\n\tcase 5:\t \n\t\tvolume = &mix->volumeD;\n\t\trsnd_flags_set(mix, HAS_VOLD);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown SRC is connected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = rsnd_kctrl_new_s(mod, io, rtd,\n\t\t\t       \"MIX Playback Volume\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_mix_volume_update,\n\t\t\t       volume, VOL_MAX);\n\tif (ret < 0)\n\t\treturn ret;\n\trsnd_kctrl_vals(*volume) = VOL_MAX;\n\n\tif (rsnd_flags_has(mix, ONCE_KCTRL_INITIALIZED))\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_s(mod, io, rtd,\n\t\t\t       \"MIX Ramp Switch\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_mix_volume_update,\n\t\t\t       &mix->ren, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsnd_kctrl_new_e(mod, io, rtd,\n\t\t\t       \"MIX Ramp Up Rate\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_mix_volume_update,\n\t\t\t       &mix->rup,\n\t\t\t       volume_ramp_rate,\n\t\t\t       VOLUME_RAMP_MAX_MIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsnd_kctrl_new_e(mod, io, rtd,\n\t\t\t       \"MIX Ramp Down Rate\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_mix_volume_update,\n\t\t\t       &mix->rdw,\n\t\t\t       volume_ramp_rate,\n\t\t\t       VOLUME_RAMP_MAX_MIX);\n\n\trsnd_flags_set(mix, ONCE_KCTRL_INITIALIZED);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_mix_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0xd00 + rsnd_mod_id(mod) * 0x40, 0x30);\n}\n#define DEBUG_INFO .debug_info = rsnd_mix_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_mix_ops = {\n\t.name\t\t= MIX_NAME,\n\t.probe\t\t= rsnd_mix_probe_,\n\t.init\t\t= rsnd_mix_init,\n\t.quit\t\t= rsnd_mix_quit,\n\t.pcm_new\t= rsnd_mix_pcm_new,\n\t.get_status\t= rsnd_mod_get_status,\n\tDEBUG_INFO\n};\n\nstruct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_mix_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get(rsnd_mix_get(priv, id));\n}\n\nint rsnd_mix_probe(struct rsnd_priv *priv)\n{\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_mix *mix;\n\tstruct clk *clk;\n\tchar name[MIX_NAME_SIZE];\n\tint i, nr, ret;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\tnode = rsnd_mix_of_node(priv);\n\tif (!node)\n\t\treturn 0;  \n\n\tnr = of_get_child_count(node);\n\tif (!nr) {\n\t\tret = -EINVAL;\n\t\tgoto rsnd_mix_probe_done;\n\t}\n\n\tmix\t= devm_kcalloc(dev, nr, sizeof(*mix), GFP_KERNEL);\n\tif (!mix) {\n\t\tret = -ENOMEM;\n\t\tgoto rsnd_mix_probe_done;\n\t}\n\n\tpriv->mix_nr\t= nr;\n\tpriv->mix\t= mix;\n\n\ti = 0;\n\tret = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tmix = rsnd_mix_get(priv, i);\n\n\t\tsnprintf(name, MIX_NAME_SIZE, \"%s.%d\",\n\t\t\t MIX_NAME, i);\n\n\t\tclk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_mix_probe_done;\n\t\t}\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,\n\t\t\t\t    clk, RSND_MOD_MIX, i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_mix_probe_done;\n\t\t}\n\n\t\ti++;\n\t}\n\nrsnd_mix_probe_done:\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nvoid rsnd_mix_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_mix *mix;\n\tint i;\n\n\tfor_each_rsnd_mix(mix, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(mix));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}