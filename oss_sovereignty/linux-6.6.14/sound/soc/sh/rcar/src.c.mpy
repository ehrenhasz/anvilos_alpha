{
  "module_name": "src.c",
  "hash_id": "1d2d3ae66106b27c2165e4f843db8462f530cb94cdf63542be08647c5eee909e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/src.c",
  "human_readable_source": "\n\n\n\n\n\n\n \n\n \n\n#include \"rsnd.h\"\n\n#define SRC_NAME \"src\"\n\n \n#define OUF_SRC(id)\t((1 << (id + 16)) | (1 << id))\n\nstruct rsnd_src {\n\tstruct rsnd_mod mod;\n\tstruct rsnd_mod *dma;\n\tstruct rsnd_kctrl_cfg_s sen;   \n\tstruct rsnd_kctrl_cfg_s sync;  \n\tint irq;\n};\n\n#define RSND_SRC_NAME_SIZE 16\n\n#define rsnd_src_get(priv, id) ((struct rsnd_src *)(priv->src) + id)\n#define rsnd_src_nr(priv) ((priv)->src_nr)\n#define rsnd_src_sync_is_enabled(mod) (rsnd_mod_to_src(mod)->sen.val)\n\n#define rsnd_mod_to_src(_mod)\t\t\t\t\\\n\tcontainer_of((_mod), struct rsnd_src, mod)\n\n#define for_each_rsnd_src(pos, priv, i)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\\\n\t     ((i) < rsnd_src_nr(priv)) &&\t\t\t\\\n\t     ((pos) = (struct rsnd_src *)(priv)->src + i);\t\\\n\t     i++)\n\n\n \n\nstatic void rsnd_src_activation(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, SRC_SWRSR, 0);\n\trsnd_mod_write(mod, SRC_SWRSR, 1);\n}\n\nstatic void rsnd_src_halt(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, SRC_SRCIR, 1);\n\trsnd_mod_write(mod, SRC_SWRSR, 0);\n}\n\nstatic struct dma_chan *rsnd_src_dma_req(struct rsnd_dai_stream *io,\n\t\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tint is_play = rsnd_io_is_play(io);\n\n\treturn rsnd_dma_request_channel(rsnd_src_of_node(priv),\n\t\t\t\t\tSRC_NAME, mod,\n\t\t\t\t\tis_play ? \"rx\" : \"tx\");\n}\n\nstatic u32 rsnd_src_convert_rate(struct rsnd_dai_stream *io,\n\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\tu32 convert_rate;\n\n\tif (!runtime)\n\t\treturn 0;\n\n\tif (!rsnd_src_sync_is_enabled(mod))\n\t\treturn rsnd_io_converted_rate(io);\n\n\tconvert_rate = src->sync.val;\n\n\tif (!convert_rate)\n\t\tconvert_rate = rsnd_io_converted_rate(io);\n\n\tif (!convert_rate)\n\t\tconvert_rate = runtime->rate;\n\n\treturn convert_rate;\n}\n\nunsigned int rsnd_src_get_rate(struct rsnd_priv *priv,\n\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t       int is_in)\n{\n\tstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tunsigned int rate = 0;\n\tint is_play = rsnd_io_is_play(io);\n\n\t \n\n\tif (is_play == is_in)\n\t\treturn runtime->rate;\n\n\t \n\tif (src_mod)\n\t\trate = rsnd_src_convert_rate(io, src_mod);\n\n\tif (!rate)\n\t\trate = runtime->rate;\n\n\treturn rate;\n}\n\nstatic const u32 bsdsr_table_pattern1[] = {\n\t0x01800000,  \n\t0x01000000,  \n\t0x00c00000,  \n\t0x00800000,  \n\t0x00600000,  \n\t0x00400000,  \n};\n\nstatic const u32 bsdsr_table_pattern2[] = {\n\t0x02400000,  \n\t0x01800000,  \n\t0x01200000,  \n\t0x00c00000,  \n\t0x00900000,  \n\t0x00600000,  \n};\n\nstatic const u32 bsisr_table[] = {\n\t0x00100060,  \n\t0x00100040,  \n\t0x00100030,  \n\t0x00100020,  \n\t0x00100020,  \n\t0x00100020,  \n};\n\nstatic const u32 chan288888[] = {\n\t0x00000006,  \n\t0x000001fe,  \n\t0x000001fe,  \n\t0x000001fe,  \n\t0x000001fe,  \n\t0x000001fe,  \n};\n\nstatic const u32 chan244888[] = {\n\t0x00000006,  \n\t0x0000001e,  \n\t0x0000001e,  \n\t0x000001fe,  \n\t0x000001fe,  \n\t0x000001fe,  \n};\n\nstatic const u32 chan222222[] = {\n\t0x00000006,  \n\t0x00000006,  \n\t0x00000006,  \n\t0x00000006,  \n\t0x00000006,  \n\t0x00000006,  \n};\n\nstatic void rsnd_src_set_convert_rate(struct rsnd_dai_stream *io,\n\t\t\t\t      struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tint is_play = rsnd_io_is_play(io);\n\tint use_src = 0;\n\tu32 fin, fout;\n\tu32 ifscr, fsrate, adinr;\n\tu32 cr, route;\n\tu32 i_busif, o_busif, tmp;\n\tconst u32 *bsdsr_table;\n\tconst u32 *chptn;\n\tuint ratio;\n\tint chan;\n\tint idx;\n\n\tif (!runtime)\n\t\treturn;\n\n\tfin  = rsnd_src_get_in_rate(priv, io);\n\tfout = rsnd_src_get_out_rate(priv, io);\n\n\tchan = rsnd_runtime_channel_original(io);\n\n\t \n\tif (fin == fout)\n\t\tratio = 0;\n\telse if (fin > fout)\n\t\tratio = 100 * fin / fout;\n\telse\n\t\tratio = 100 * fout / fin;\n\n\tif (ratio > 600) {\n\t\tdev_err(dev, \"FSO/FSI ratio error\\n\");\n\t\treturn;\n\t}\n\n\tuse_src = (fin != fout) | rsnd_src_sync_is_enabled(mod);\n\n\t \n\tadinr = rsnd_get_adinr_bit(mod, io) | chan;\n\n\t \n\tifscr = 0;\n\tfsrate = 0;\n\tif (use_src) {\n\t\tu64 n;\n\n\t\tifscr = 1;\n\t\tn = (u64)0x0400000 * fin;\n\t\tdo_div(n, fout);\n\t\tfsrate = n;\n\t}\n\n\t \n\tcr\t= 0x00011110;\n\troute\t= 0x0;\n\tif (use_src) {\n\t\troute\t= 0x1;\n\n\t\tif (rsnd_src_sync_is_enabled(mod)) {\n\t\t\tcr |= 0x1;\n\t\t\troute |= rsnd_io_is_play(io) ?\n\t\t\t\t(0x1 << 24) : (0x1 << 25);\n\t\t}\n\t}\n\n\t \n\tswitch (rsnd_mod_id(mod)) {\n\tcase 0:\n\t\tchptn\t\t= chan288888;\n\t\tbsdsr_table\t= bsdsr_table_pattern1;\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\tcase 4:\n\t\tchptn\t\t= chan244888;\n\t\tbsdsr_table\t= bsdsr_table_pattern1;\n\t\tbreak;\n\tcase 2:\n\tcase 9:\n\t\tchptn\t\t= chan222222;\n\t\tbsdsr_table\t= bsdsr_table_pattern1;\n\t\tbreak;\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\tcase 8:\n\t\tchptn\t\t= chan222222;\n\t\tbsdsr_table\t= bsdsr_table_pattern2;\n\t\tbreak;\n\tdefault:\n\t\tgoto convert_rate_err;\n\t}\n\n\t \n\tif (rsnd_is_e3(priv))\n\t\tswitch (rsnd_mod_id(mod)) {\n\t\tcase 0:\n\t\tcase 4:\n\t\t\tchptn\t= chan222222;\n\t\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(chan222222); idx++)\n\t\tif (chptn[idx] & (1 << chan))\n\t\t\tbreak;\n\n\tif (chan > 8 ||\n\t    idx >= ARRAY_SIZE(chan222222))\n\t\tgoto convert_rate_err;\n\n\t \n\ttmp = rsnd_get_busif_shift(io, mod);\n\ti_busif = ( is_play ? tmp : 0) | 1;\n\to_busif = (!is_play ? tmp : 0) | 1;\n\n\trsnd_mod_write(mod, SRC_ROUTE_MODE0, route);\n\n\trsnd_mod_write(mod, SRC_SRCIR, 1);\t \n\trsnd_mod_write(mod, SRC_ADINR, adinr);\n\trsnd_mod_write(mod, SRC_IFSCR, ifscr);\n\trsnd_mod_write(mod, SRC_IFSVR, fsrate);\n\trsnd_mod_write(mod, SRC_SRCCR, cr);\n\trsnd_mod_write(mod, SRC_BSDSR, bsdsr_table[idx]);\n\trsnd_mod_write(mod, SRC_BSISR, bsisr_table[idx]);\n\trsnd_mod_write(mod, SRC_SRCIR, 0);\t \n\n\trsnd_mod_write(mod, SRC_I_BUSIF_MODE, i_busif);\n\trsnd_mod_write(mod, SRC_O_BUSIF_MODE, o_busif);\n\n\trsnd_mod_write(mod, SRC_BUSIF_DALIGN, rsnd_get_dalign(mod, io));\n\n\trsnd_adg_set_src_timesel_gen2(mod, io, fin, fout);\n\n\treturn;\n\nconvert_rate_err:\n\tdev_err(dev, \"unknown BSDSR/BSDIR settings\\n\");\n}\n\nstatic int rsnd_src_irq(struct rsnd_mod *mod,\n\t\t\tstruct rsnd_dai_stream *io,\n\t\t\tstruct rsnd_priv *priv,\n\t\t\tint enable)\n{\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\tu32 sys_int_val, int_val, sys_int_mask;\n\tint irq = src->irq;\n\tint id = rsnd_mod_id(mod);\n\n\tsys_int_val =\n\tsys_int_mask = OUF_SRC(id);\n\tint_val = 0x3300;\n\n\t \n\tif ((irq <= 0) || !enable) {\n\t\tsys_int_val = 0;\n\t\tint_val = 0;\n\t}\n\n\t \n\tif (rsnd_src_sync_is_enabled(mod))\n\t\tsys_int_val = sys_int_val & 0xffff;\n\n\trsnd_mod_write(mod, SRC_INT_ENABLE0, int_val);\n\trsnd_mod_bset(mod, SCU_SYS_INT_EN0, sys_int_mask, sys_int_val);\n\trsnd_mod_bset(mod, SCU_SYS_INT_EN1, sys_int_mask, sys_int_val);\n\n\treturn 0;\n}\n\nstatic void rsnd_src_status_clear(struct rsnd_mod *mod)\n{\n\tu32 val = OUF_SRC(rsnd_mod_id(mod));\n\n\trsnd_mod_write(mod, SCU_SYS_STATUS0, val);\n\trsnd_mod_write(mod, SCU_SYS_STATUS1, val);\n}\n\nstatic bool rsnd_src_error_occurred(struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tu32 val0, val1;\n\tu32 status0, status1;\n\tbool ret = false;\n\n\tval0 = val1 = OUF_SRC(rsnd_mod_id(mod));\n\n\t \n\tif (rsnd_src_sync_is_enabled(mod))\n\t\tval0 = val0 & 0xffff;\n\n\tstatus0 = rsnd_mod_read(mod, SCU_SYS_STATUS0);\n\tstatus1 = rsnd_mod_read(mod, SCU_SYS_STATUS1);\n\tif ((status0 & val0) || (status1 & val1)) {\n\t\trsnd_print_irq_status(dev, \"%s err status : 0x%08x, 0x%08x\\n\",\n\t\t\t\t      rsnd_mod_name(mod), status0, status1);\n\n\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int rsnd_src_start(struct rsnd_mod *mod,\n\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t  struct rsnd_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = (rsnd_io_to_mod_dvc(io) && !rsnd_src_sync_is_enabled(mod)) ?\n\t\t0x01 : 0x11;\n\n\trsnd_mod_write(mod, SRC_CTRL, val);\n\n\treturn 0;\n}\n\nstatic int rsnd_src_stop(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\trsnd_mod_write(mod, SRC_CTRL, 0);\n\n\treturn 0;\n}\n\nstatic int rsnd_src_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\tint ret;\n\n\t \n\tsrc->sync.val = 0;\n\n\tret = rsnd_mod_power_on(mod);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trsnd_src_activation(mod);\n\n\trsnd_src_set_convert_rate(io, mod);\n\n\trsnd_src_status_clear(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_src_quit(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\n\trsnd_src_halt(mod);\n\n\trsnd_mod_power_off(mod);\n\n\t \n\tsrc->sync.val = 0;\n\n\treturn 0;\n}\n\nstatic void __rsnd_src_interrupt(struct rsnd_mod *mod,\n\t\t\t\t struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tbool stop = false;\n\n\tspin_lock(&priv->lock);\n\n\t \n\tif (!rsnd_io_is_working(io))\n\t\tgoto rsnd_src_interrupt_out;\n\n\tif (rsnd_src_error_occurred(mod))\n\t\tstop = true;\n\n\trsnd_src_status_clear(mod);\nrsnd_src_interrupt_out:\n\n\tspin_unlock(&priv->lock);\n\n\tif (stop)\n\t\tsnd_pcm_stop_xrun(io->substream);\n}\n\nstatic irqreturn_t rsnd_src_interrupt(int irq, void *data)\n{\n\tstruct rsnd_mod *mod = data;\n\n\trsnd_mod_interrupt(mod, __rsnd_src_interrupt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rsnd_src_probe_(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint irq = src->irq;\n\tint ret;\n\n\tif (irq > 0) {\n\t\t \n\t\tret = devm_request_irq(dev, irq,\n\t\t\t\t       rsnd_src_interrupt,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       dev_name(dev), mod);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rsnd_dma_attach(io, mod, &src->dma);\n\n\treturn ret;\n}\n\nstatic int rsnd_src_pcm_new(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct rsnd_src *src = rsnd_mod_to_src(mod);\n\tint ret;\n\n\t \n\n\t \n\tif (rsnd_io_to_mod_cmd(io) && !rsnd_io_is_play(io))\n\t\treturn 0;\n\n\t \n\tret = rsnd_kctrl_new_s(mod, io, rtd,\n\t\t\t       rsnd_io_is_play(io) ?\n\t\t\t       \"SRC Out Rate Switch\" :\n\t\t\t       \"SRC In Rate Switch\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_src_set_convert_rate,\n\t\t\t       &src->sen, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsnd_kctrl_new_s(mod, io, rtd,\n\t\t\t       rsnd_io_is_play(io) ?\n\t\t\t       \"SRC Out Rate\" :\n\t\t\t       \"SRC In Rate\",\n\t\t\t       rsnd_kctrl_accept_runtime,\n\t\t\t       rsnd_src_set_convert_rate,\n\t\t\t       &src->sync, 192000);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_src_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  rsnd_mod_id(mod) * 0x20, 0x20);\n\tseq_puts(m, \"\\n\");\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0x1c0, 0x20);\n\tseq_puts(m, \"\\n\");\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0x200 + rsnd_mod_id(mod) * 0x40, 0x40);\n}\n#define DEBUG_INFO .debug_info = rsnd_src_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_src_ops = {\n\t.name\t\t= SRC_NAME,\n\t.dma_req\t= rsnd_src_dma_req,\n\t.probe\t\t= rsnd_src_probe_,\n\t.init\t\t= rsnd_src_init,\n\t.quit\t\t= rsnd_src_quit,\n\t.start\t\t= rsnd_src_start,\n\t.stop\t\t= rsnd_src_stop,\n\t.irq\t\t= rsnd_src_irq,\n\t.pcm_new\t= rsnd_src_pcm_new,\n\t.get_status\t= rsnd_mod_get_status,\n\tDEBUG_INFO\n};\n\nstruct rsnd_mod *rsnd_src_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_src_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get(rsnd_src_get(priv, id));\n}\n\nint rsnd_src_probe(struct rsnd_priv *priv)\n{\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_src *src;\n\tstruct clk *clk;\n\tchar name[RSND_SRC_NAME_SIZE];\n\tint i, nr, ret;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\tnode = rsnd_src_of_node(priv);\n\tif (!node)\n\t\treturn 0;  \n\n\tnr = rsnd_node_count(priv, node, SRC_NAME);\n\tif (!nr) {\n\t\tret = -EINVAL;\n\t\tgoto rsnd_src_probe_done;\n\t}\n\n\tsrc\t= devm_kcalloc(dev, nr, sizeof(*src), GFP_KERNEL);\n\tif (!src) {\n\t\tret = -ENOMEM;\n\t\tgoto rsnd_src_probe_done;\n\t}\n\n\tpriv->src_nr\t= nr;\n\tpriv->src\t= src;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tif (!of_device_is_available(np))\n\t\t\tgoto skip;\n\n\t\ti = rsnd_node_fixed_index(dev, np, SRC_NAME, i);\n\t\tif (i < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_src_probe_done;\n\t\t}\n\n\t\tsrc = rsnd_src_get(priv, i);\n\n\t\tsnprintf(name, RSND_SRC_NAME_SIZE, \"%s.%d\",\n\t\t\t SRC_NAME, i);\n\n\t\tsrc->irq = irq_of_parse_and_map(np, 0);\n\t\tif (!src->irq) {\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_src_probe_done;\n\t\t}\n\n\t\tclk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_src_probe_done;\n\t\t}\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(src),\n\t\t\t\t    &rsnd_src_ops, clk, RSND_MOD_SRC, i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_src_probe_done;\n\t\t}\n\nskip:\n\t\ti++;\n\t}\n\n\tret = 0;\n\nrsnd_src_probe_done:\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nvoid rsnd_src_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_src *src;\n\tint i;\n\n\tfor_each_rsnd_src(src, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(src));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}