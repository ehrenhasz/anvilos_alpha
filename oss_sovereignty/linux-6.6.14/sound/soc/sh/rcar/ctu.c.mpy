{
  "module_name": "ctu.c",
  "hash_id": "78cf6de04fef317af9c727c30b120ebc068f795ac70c2523a71956bd3fb747fa",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/ctu.c",
  "human_readable_source": "\n\n\n\n\n\n#include \"rsnd.h\"\n\n#define CTU_NAME_SIZE\t16\n#define CTU_NAME \"ctu\"\n\n \n\nstruct rsnd_ctu {\n\tstruct rsnd_mod mod;\n\tstruct rsnd_kctrl_cfg_m pass;\n\tstruct rsnd_kctrl_cfg_m sv[4];\n\tstruct rsnd_kctrl_cfg_s reset;\n\tint channels;\n\tu32 flags;\n};\n\n#define KCTRL_INITIALIZED\t(1 << 0)\n\n#define rsnd_ctu_nr(priv) ((priv)->ctu_nr)\n#define for_each_rsnd_ctu(pos, priv, i)\t\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\t\\\n\t     ((i) < rsnd_ctu_nr(priv)) &&\t\t\t\t\\\n\t\t     ((pos) = (struct rsnd_ctu *)(priv)->ctu + i);\t\\\n\t     i++)\n\n#define rsnd_mod_to_ctu(_mod)\t\\\n\tcontainer_of((_mod), struct rsnd_ctu, mod)\n\n#define rsnd_ctu_get(priv, id) ((struct rsnd_ctu *)(priv->ctu) + id)\n\nstatic void rsnd_ctu_activation(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, CTU_SWRSR, 0);\n\trsnd_mod_write(mod, CTU_SWRSR, 1);\n}\n\nstatic void rsnd_ctu_halt(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, CTU_CTUIR, 1);\n\trsnd_mod_write(mod, CTU_SWRSR, 0);\n}\n\nstatic int rsnd_ctu_probe_(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\treturn rsnd_cmd_attach(io, rsnd_mod_id(mod));\n}\n\nstatic void rsnd_ctu_value_init(struct rsnd_dai_stream *io,\n\t\t\t       struct rsnd_mod *mod)\n{\n\tstruct rsnd_ctu *ctu = rsnd_mod_to_ctu(mod);\n\tu32 cpmdr = 0;\n\tu32 scmdr = 0;\n\tint i, j;\n\n\tfor (i = 0; i < RSND_MAX_CHANNELS; i++) {\n\t\tu32 val = rsnd_kctrl_valm(ctu->pass, i);\n\n\t\tcpmdr |= val << (28 - (i * 4));\n\n\t\tif ((val > 0x8) && (scmdr < (val - 0x8)))\n\t\t\tscmdr = val - 0x8;\n\t}\n\n\trsnd_mod_write(mod, CTU_CTUIR, 1);\n\n\trsnd_mod_write(mod, CTU_ADINR, rsnd_runtime_channel_original(io));\n\n\trsnd_mod_write(mod, CTU_CPMDR, cpmdr);\n\n\trsnd_mod_write(mod, CTU_SCMDR, scmdr);\n\n\tfor (i = 0; i < 4; i++) {\n\n\t\tif (i >= scmdr)\n\t\t\tbreak;\n\n\t\tfor (j = 0; j < RSND_MAX_CHANNELS; j++)\n\t\t\trsnd_mod_write(mod, CTU_SVxxR(i, j), rsnd_kctrl_valm(ctu->sv[i], j));\n\t}\n\n\trsnd_mod_write(mod, CTU_CTUIR, 0);\n}\n\nstatic void rsnd_ctu_value_reset(struct rsnd_dai_stream *io,\n\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_ctu *ctu = rsnd_mod_to_ctu(mod);\n\tint i;\n\n\tif (!rsnd_kctrl_vals(ctu->reset))\n\t\treturn;\n\n\tfor (i = 0; i < RSND_MAX_CHANNELS; i++) {\n\t\trsnd_kctrl_valm(ctu->pass, i) = 0;\n\t\trsnd_kctrl_valm(ctu->sv[0],  i) = 0;\n\t\trsnd_kctrl_valm(ctu->sv[1],  i) = 0;\n\t\trsnd_kctrl_valm(ctu->sv[2],  i) = 0;\n\t\trsnd_kctrl_valm(ctu->sv[3],  i) = 0;\n\t}\n\trsnd_kctrl_vals(ctu->reset) = 0;\n}\n\nstatic int rsnd_ctu_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tint ret;\n\n\tret = rsnd_mod_power_on(mod);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trsnd_ctu_activation(mod);\n\n\trsnd_ctu_value_init(io, mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_ctu_quit(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\trsnd_ctu_halt(mod);\n\n\trsnd_mod_power_off(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_ctu_pcm_new(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct rsnd_ctu *ctu = rsnd_mod_to_ctu(mod);\n\tint ret;\n\n\tif (rsnd_flags_has(ctu, KCTRL_INITIALIZED))\n\t\treturn 0;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd, \"CTU Pass\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       NULL,\n\t\t\t       &ctu->pass, RSND_MAX_CHANNELS,\n\t\t\t       0xC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd, \"CTU SV0\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       NULL,\n\t\t\t       &ctu->sv[0], RSND_MAX_CHANNELS,\n\t\t\t       0x00FFFFFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd, \"CTU SV1\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       NULL,\n\t\t\t       &ctu->sv[1], RSND_MAX_CHANNELS,\n\t\t\t       0x00FFFFFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd, \"CTU SV2\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       NULL,\n\t\t\t       &ctu->sv[2], RSND_MAX_CHANNELS,\n\t\t\t       0x00FFFFFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd, \"CTU SV3\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       NULL,\n\t\t\t       &ctu->sv[3], RSND_MAX_CHANNELS,\n\t\t\t       0x00FFFFFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_s(mod, io, rtd, \"CTU Reset\",\n\t\t\t       rsnd_kctrl_accept_anytime,\n\t\t\t       rsnd_ctu_value_reset,\n\t\t\t       &ctu->reset, 1);\n\n\trsnd_flags_set(ctu, KCTRL_INITIALIZED);\n\n\treturn ret;\n}\n\nstatic int rsnd_ctu_id(struct rsnd_mod *mod)\n{\n\t \n\treturn mod->id / 4;\n}\n\nstatic int rsnd_ctu_id_sub(struct rsnd_mod *mod)\n{\n\t \n\treturn mod->id % 4;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_ctu_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0x500 + rsnd_mod_id_raw(mod) * 0x100, 0x100);\n}\n#define DEBUG_INFO .debug_info = rsnd_ctu_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_ctu_ops = {\n\t.name\t\t= CTU_NAME,\n\t.probe\t\t= rsnd_ctu_probe_,\n\t.init\t\t= rsnd_ctu_init,\n\t.quit\t\t= rsnd_ctu_quit,\n\t.pcm_new\t= rsnd_ctu_pcm_new,\n\t.get_status\t= rsnd_mod_get_status,\n\t.id\t\t= rsnd_ctu_id,\n\t.id_sub\t\t= rsnd_ctu_id_sub,\n\t.id_cmd\t\t= rsnd_mod_id_raw,\n\tDEBUG_INFO\n};\n\nstruct rsnd_mod *rsnd_ctu_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_ctu_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get(rsnd_ctu_get(priv, id));\n}\n\nint rsnd_ctu_probe(struct rsnd_priv *priv)\n{\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_ctu *ctu;\n\tstruct clk *clk;\n\tchar name[CTU_NAME_SIZE];\n\tint i, nr, ret;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\tnode = rsnd_ctu_of_node(priv);\n\tif (!node)\n\t\treturn 0;  \n\n\tnr = of_get_child_count(node);\n\tif (!nr) {\n\t\tret = -EINVAL;\n\t\tgoto rsnd_ctu_probe_done;\n\t}\n\n\tctu = devm_kcalloc(dev, nr, sizeof(*ctu), GFP_KERNEL);\n\tif (!ctu) {\n\t\tret = -ENOMEM;\n\t\tgoto rsnd_ctu_probe_done;\n\t}\n\n\tpriv->ctu_nr\t= nr;\n\tpriv->ctu\t= ctu;\n\n\ti = 0;\n\tret = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tctu = rsnd_ctu_get(priv, i);\n\n\t\t \n\t\tsnprintf(name, CTU_NAME_SIZE, \"%s.%d\",\n\t\t\t CTU_NAME, i / 4);\n\n\t\tclk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ctu_probe_done;\n\t\t}\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(ctu), &rsnd_ctu_ops,\n\t\t\t\t    clk, RSND_MOD_CTU, i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_ctu_probe_done;\n\t\t}\n\n\t\ti++;\n\t}\n\n\nrsnd_ctu_probe_done:\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nvoid rsnd_ctu_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_ctu *ctu;\n\tint i;\n\n\tfor_each_rsnd_ctu(ctu, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(ctu));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}