{
  "module_name": "core.c",
  "hash_id": "26764487ad294696f981804db6c8396c2292f7cc9517729fdfe63470eebcc9ca",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n \n\n#include <linux/pm_runtime.h>\n#include \"rsnd.h\"\n\n#define RSND_RATES SNDRV_PCM_RATE_8000_192000\n#define RSND_FMTS (SNDRV_PCM_FMTBIT_S8 |\\\n\t\t   SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t   SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct of_device_id rsnd_of_match[] = {\n\t{ .compatible = \"renesas,rcar_sound-gen1\", .data = (void *)RSND_GEN1 },\n\t{ .compatible = \"renesas,rcar_sound-gen2\", .data = (void *)RSND_GEN2 },\n\t{ .compatible = \"renesas,rcar_sound-gen3\", .data = (void *)RSND_GEN3 },\n\t{ .compatible = \"renesas,rcar_sound-gen4\", .data = (void *)RSND_GEN4 },\n\t \n\t{ .compatible = \"renesas,rcar_sound-r8a77990\", .data = (void *)(RSND_GEN3 | RSND_SOC_E) },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rsnd_of_match);\n\n \nvoid rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)\n{\n\tif (mod->type != type) {\n\t\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t\tdev_warn(dev, \"%s is not your expected module\\n\",\n\t\t\t rsnd_mod_name(mod));\n\t}\n}\n\nstruct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,\n\t\t\t\t  struct rsnd_mod *mod)\n{\n\tif (!mod || !mod->ops || !mod->ops->dma_req)\n\t\treturn NULL;\n\n\treturn mod->ops->dma_req(io, mod);\n}\n\n#define MOD_NAME_NUM   5\n#define MOD_NAME_SIZE 16\nchar *rsnd_mod_name(struct rsnd_mod *mod)\n{\n\tstatic char names[MOD_NAME_NUM][MOD_NAME_SIZE];\n\tstatic int num;\n\tchar *name = names[num];\n\n\tnum++;\n\tif (num >= MOD_NAME_NUM)\n\t\tnum = 0;\n\n\t \n\tif ((mod)->ops->id_sub) {\n\t\tsnprintf(name, MOD_NAME_SIZE, \"%s[%d%d]\",\n\t\t\t mod->ops->name,\n\t\t\t rsnd_mod_id(mod),\n\t\t\t rsnd_mod_id_sub(mod));\n\t} else {\n\t\tsnprintf(name, MOD_NAME_SIZE, \"%s[%d]\",\n\t\t\t mod->ops->name,\n\t\t\t rsnd_mod_id(mod));\n\t}\n\n\treturn name;\n}\n\nu32 *rsnd_mod_get_status(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t enum rsnd_mod_type type)\n{\n\treturn &mod->status;\n}\n\nint rsnd_mod_id_raw(struct rsnd_mod *mod)\n{\n\treturn mod->id;\n}\n\nint rsnd_mod_id(struct rsnd_mod *mod)\n{\n\tif ((mod)->ops->id)\n\t\treturn (mod)->ops->id(mod);\n\n\treturn rsnd_mod_id_raw(mod);\n}\n\nint rsnd_mod_id_sub(struct rsnd_mod *mod)\n{\n\tif ((mod)->ops->id_sub)\n\t\treturn (mod)->ops->id_sub(mod);\n\n\treturn 0;\n}\n\nint rsnd_mod_init(struct rsnd_priv *priv,\n\t\t  struct rsnd_mod *mod,\n\t\t  struct rsnd_mod_ops *ops,\n\t\t  struct clk *clk,\n\t\t  enum rsnd_mod_type type,\n\t\t  int id)\n{\n\tint ret = clk_prepare(clk);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmod->id\t\t= id;\n\tmod->ops\t= ops;\n\tmod->type\t= type;\n\tmod->clk\t= clk;\n\tmod->priv\t= priv;\n\n\treturn 0;\n}\n\nvoid rsnd_mod_quit(struct rsnd_mod *mod)\n{\n\tclk_unprepare(mod->clk);\n\tmod->clk = NULL;\n}\n\nvoid rsnd_mod_interrupt(struct rsnd_mod *mod,\n\t\t\tvoid (*callback)(struct rsnd_mod *mod,\n\t\t\t\t\t struct rsnd_dai_stream *io))\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct rsnd_dai *rdai;\n\tint i;\n\n\tfor_each_rsnd_dai(rdai, priv, i) {\n\t\tstruct rsnd_dai_stream *io = &rdai->playback;\n\n\t\tif (mod == io->mod[mod->type])\n\t\t\tcallback(mod, io);\n\n\t\tio = &rdai->capture;\n\t\tif (mod == io->mod[mod->type])\n\t\t\tcallback(mod, io);\n\t}\n}\n\nint rsnd_io_is_working(struct rsnd_dai_stream *io)\n{\n\t \n\tif (io->substream)\n\t\treturn snd_pcm_running(io->substream);\n\n\treturn 0;\n}\n\nint rsnd_runtime_channel_original_with_params(struct rsnd_dai_stream *io,\n\t\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\n\t \n\tif (params)\n\t\treturn params_channels(params);\n\telse if (runtime)\n\t\treturn runtime->channels;\n\treturn 0;\n}\n\nint rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,\n\t\t\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tint chan = rsnd_runtime_channel_original_with_params(io, params);\n\tstruct rsnd_mod *ctu_mod = rsnd_io_to_mod_ctu(io);\n\n\tif (ctu_mod) {\n\t\tu32 converted_chan = rsnd_io_converted_chan(io);\n\n\t\t \n\t\tif (rsnd_runtime_is_tdm_split(io)) {\n\t\t\tstruct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));\n\n\t\t\tdev_err(dev, \"CTU and TDM Split should be used\\n\");\n\t\t}\n\n\t\tif (converted_chan)\n\t\t\treturn converted_chan;\n\t}\n\n\treturn chan;\n}\n\nint rsnd_channel_normalization(int chan)\n{\n\tif (WARN_ON((chan > 8) || (chan < 0)))\n\t\treturn 0;\n\n\t \n\tif (chan == 6)\n\t\tchan = 8;\n\n\treturn chan;\n}\n\nint rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,\n\t\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tint chan = rsnd_io_is_play(io) ?\n\t\trsnd_runtime_channel_after_ctu_with_params(io, params) :\n\t\trsnd_runtime_channel_original_with_params(io, params);\n\n\t \n\tif (rsnd_runtime_is_multi_ssi(io))\n\t\tchan /= rsnd_rdai_ssi_lane_get(rdai);\n\n\treturn rsnd_channel_normalization(chan);\n}\n\nint rsnd_runtime_is_multi_ssi(struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tint lane = rsnd_rdai_ssi_lane_get(rdai);\n\tint chan = rsnd_io_is_play(io) ?\n\t\trsnd_runtime_channel_after_ctu(io) :\n\t\trsnd_runtime_channel_original(io);\n\n\treturn (chan > 2) && (lane > 1);\n}\n\nint rsnd_runtime_is_tdm(struct rsnd_dai_stream *io)\n{\n\treturn rsnd_runtime_channel_for_ssi(io) >= 6;\n}\n\nint rsnd_runtime_is_tdm_split(struct rsnd_dai_stream *io)\n{\n\treturn !!rsnd_flags_has(io, RSND_STREAM_TDM_SPLIT);\n}\n\n \nu32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tswitch (snd_pcm_format_width(runtime->format)) {\n\tcase 8:\n\t\treturn 16 << 16;\n\tcase 16:\n\t\treturn 8 << 16;\n\tcase 24:\n\t\treturn 0 << 16;\n\t}\n\n\tdev_warn(dev, \"not supported sample bits\\n\");\n\n\treturn 0;\n}\n\n \nu32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)\n{\n\tstatic const u32 dalign_values[8] = {\n\t\t0x76543210, 0x00000032, 0x00007654, 0x00000076,\n\t\t0xfedcba98, 0x000000ba, 0x0000fedc, 0x000000fe,\n\t};\n\tint id = 0;\n\tstruct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);\n\tstruct rsnd_mod *target;\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tu32 dalign;\n\n\t \n\tif (rsnd_io_is_play(io)) {\n\t\tstruct rsnd_mod *src = rsnd_io_to_mod_src(io);\n\n\t\ttarget = src ? src : ssiu;\n\t} else {\n\t\tstruct rsnd_mod *cmd = rsnd_io_to_mod_cmd(io);\n\n\t\ttarget = cmd ? cmd : ssiu;\n\t}\n\n\tif (mod == ssiu)\n\t\tid = rsnd_mod_id_sub(mod);\n\n\tdalign = dalign_values[id];\n\n\tif (mod == target && snd_pcm_format_width(runtime->format) == 16) {\n\t\t \n\t\tdalign = (dalign & 0xf0f0f0f0) >> 4 |\n\t\t\t (dalign & 0x0f0f0f0f) << 4;\n\t}\n\n\treturn dalign;\n}\n\nu32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)\n{\n\tstatic const enum rsnd_mod_type playback_mods[] = {\n\t\tRSND_MOD_SRC,\n\t\tRSND_MOD_CMD,\n\t\tRSND_MOD_SSIU,\n\t};\n\tstatic const enum rsnd_mod_type capture_mods[] = {\n\t\tRSND_MOD_CMD,\n\t\tRSND_MOD_SRC,\n\t\tRSND_MOD_SSIU,\n\t};\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_mod *tmod = NULL;\n\tconst enum rsnd_mod_type *mods =\n\t\trsnd_io_is_play(io) ?\n\t\tplayback_mods : capture_mods;\n\tint i;\n\n\t \n\tif (snd_pcm_format_width(runtime->format) != 24)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(playback_mods); i++) {\n\t\ttmod = rsnd_io_to_mod(io, mods[i]);\n\t\tif (tmod)\n\t\t\tbreak;\n\t}\n\n\tif (tmod != mod)\n\t\treturn 0;\n\n\tif (rsnd_io_is_play(io))\n\t\treturn  (0 << 20) |  \n\t\t\t(8 << 16);   \n\telse\n\t\treturn  (1 << 20) |  \n\t\t\t(8 << 16);   \n}\n\n \nstruct rsnd_mod *rsnd_mod_next(int *iterator,\n\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t       enum rsnd_mod_type *array,\n\t\t\t       int array_size)\n{\n\tint max = array ? array_size : RSND_MOD_MAX;\n\n\tfor (; *iterator < max; (*iterator)++) {\n\t\tenum rsnd_mod_type type = (array) ? array[*iterator] : *iterator;\n\t\tstruct rsnd_mod *mod = rsnd_io_to_mod(io, type);\n\n\t\tif (mod)\n\t\t\treturn mod;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum rsnd_mod_type rsnd_mod_sequence[][RSND_MOD_MAX] = {\n\t{\n\t\t \n\t\tRSND_MOD_AUDMAPP,\n\t\tRSND_MOD_AUDMA,\n\t\tRSND_MOD_DVC,\n\t\tRSND_MOD_MIX,\n\t\tRSND_MOD_CTU,\n\t\tRSND_MOD_CMD,\n\t\tRSND_MOD_SRC,\n\t\tRSND_MOD_SSIU,\n\t\tRSND_MOD_SSIM3,\n\t\tRSND_MOD_SSIM2,\n\t\tRSND_MOD_SSIM1,\n\t\tRSND_MOD_SSIP,\n\t\tRSND_MOD_SSI,\n\t}, {\n\t\t \n\t\tRSND_MOD_AUDMAPP,\n\t\tRSND_MOD_AUDMA,\n\t\tRSND_MOD_SSIM3,\n\t\tRSND_MOD_SSIM2,\n\t\tRSND_MOD_SSIM1,\n\t\tRSND_MOD_SSIP,\n\t\tRSND_MOD_SSI,\n\t\tRSND_MOD_SSIU,\n\t\tRSND_MOD_DVC,\n\t\tRSND_MOD_MIX,\n\t\tRSND_MOD_CTU,\n\t\tRSND_MOD_CMD,\n\t\tRSND_MOD_SRC,\n\t},\n};\n\nstatic int rsnd_status_update(struct rsnd_dai_stream *io,\n\t\t\t      struct rsnd_mod *mod, enum rsnd_mod_type type,\n\t\t\t      int shift, int add, int timing)\n{\n\tu32 *status\t= mod->ops->get_status(mod, io, type);\n\tu32 mask\t= 0xF << shift;\n\tu8 val\t\t= (*status >> shift) & 0xF;\n\tu8 next_val\t= (val + add) & 0xF;\n\tint func_call\t= (val == timing);\n\n\t \n\tif (add == 0 || shift == 28)\n\t\treturn 1;\n\n\tif (next_val == 0xF)  \n\t\tfunc_call = -1;\n\telse\n\t\t*status = (*status & ~mask) + (next_val << shift);\n\n\treturn func_call;\n}\n\n#define rsnd_dai_call(fn, io, param...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));\t\\\n\tstruct rsnd_mod *mod;\t\t\t\t\t\t\\\n\tint is_play = rsnd_io_is_play(io);\t\t\t\t\\\n\tint ret = 0, i;\t\t\t\t\t\t\t\\\n\tenum rsnd_mod_type *types = rsnd_mod_sequence[is_play];\t\t\\\n\tfor_each_rsnd_mod_arrays(i, mod, io, types, RSND_MOD_MAX) {\t\\\n\t\tint tmp = 0;\t\t\t\t\t\t\\\n\t\tint func_call = rsnd_status_update(io, mod, types[i],\t\\\n\t\t\t\t\t\t__rsnd_mod_shift_##fn,\t\\\n\t\t\t\t\t\t__rsnd_mod_add_##fn,\t\\\n\t\t\t\t\t\t__rsnd_mod_call_##fn);\t\\\n\t\tif (func_call > 0 && (mod)->ops->fn)\t\t\t\\\n\t\t\ttmp = (mod)->ops->fn(mod, io, param);\t\t\\\n\t\tif (unlikely(func_call < 0) ||\t\t\t\t\\\n\t\t    unlikely(tmp && (tmp != -EPROBE_DEFER)))\t\t\\\n\t\t\tdev_err(dev, \"%s : %s error (%d, %d)\\n\",\t\\\n\t\t\t\trsnd_mod_name(mod), #fn, tmp, func_call);\\\n\t\tret |= tmp;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\nint rsnd_dai_connect(struct rsnd_mod *mod,\n\t\t     struct rsnd_dai_stream *io,\n\t\t     enum rsnd_mod_type type)\n{\n\tstruct rsnd_priv *priv;\n\tstruct device *dev;\n\n\tif (!mod)\n\t\treturn -EIO;\n\n\tif (io->mod[type] == mod)\n\t\treturn 0;\n\n\tif (io->mod[type])\n\t\treturn -EINVAL;\n\n\tpriv = rsnd_mod_to_priv(mod);\n\tdev = rsnd_priv_to_dev(priv);\n\n\tio->mod[type] = mod;\n\n\tdev_dbg(dev, \"%s is connected to io (%s)\\n\",\n\t\trsnd_mod_name(mod),\n\t\trsnd_io_is_play(io) ? \"Playback\" : \"Capture\");\n\n\treturn 0;\n}\n\nstatic void rsnd_dai_disconnect(struct rsnd_mod *mod,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tenum rsnd_mod_type type)\n{\n\tio->mod[type] = NULL;\n}\n\nint rsnd_rdai_channels_ctrl(struct rsnd_dai *rdai,\n\t\t\t    int max_channels)\n{\n\tif (max_channels > 0)\n\t\trdai->max_channels = max_channels;\n\n\treturn rdai->max_channels;\n}\n\nint rsnd_rdai_ssi_lane_ctrl(struct rsnd_dai *rdai,\n\t\t\t    int ssi_lane)\n{\n\tif (ssi_lane > 0)\n\t\trdai->ssi_lane = ssi_lane;\n\n\treturn rdai->ssi_lane;\n}\n\nint rsnd_rdai_width_ctrl(struct rsnd_dai *rdai, int width)\n{\n\tif (width > 0)\n\t\trdai->chan_width = width;\n\n\treturn rdai->chan_width;\n}\n\nstruct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)\n{\n\tif ((id < 0) || (id >= rsnd_rdai_nr(priv)))\n\t\treturn NULL;\n\n\treturn priv->rdai + id;\n}\n\nstatic struct snd_soc_dai_driver\n*rsnd_daidrv_get(struct rsnd_priv *priv, int id)\n{\n\tif ((id < 0) || (id >= rsnd_rdai_nr(priv)))\n\t\treturn NULL;\n\n\treturn priv->daidrv + id;\n}\n\n#define rsnd_dai_to_priv(dai) snd_soc_dai_get_drvdata(dai)\nstatic struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)\n{\n\tstruct rsnd_priv *priv = rsnd_dai_to_priv(dai);\n\n\treturn rsnd_rdai_get(priv, dai->id);\n}\n\n \nvoid rsnd_dai_period_elapsed(struct rsnd_dai_stream *io)\n{\n\tstruct snd_pcm_substream *substream = io->substream;\n\n\t \n\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic void rsnd_dai_stream_init(struct rsnd_dai_stream *io,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tio->substream\t\t= substream;\n}\n\nstatic void rsnd_dai_stream_quit(struct rsnd_dai_stream *io)\n{\n\tio->substream\t\t= NULL;\n}\n\nstatic\nstruct snd_soc_dai *rsnd_substream_to_dai(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\treturn  asoc_rtd_to_cpu(rtd, 0);\n}\n\nstatic\nstruct rsnd_dai_stream *rsnd_rdai_to_io(struct rsnd_dai *rdai,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn &rdai->playback;\n\telse\n\t\treturn &rdai->capture;\n}\n\nstatic int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct rsnd_priv *priv = rsnd_dai_to_priv(dai);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tret = rsnd_dai_call(init, io, priv);\n\t\tif (ret < 0)\n\t\t\tgoto dai_trigger_end;\n\n\t\tret = rsnd_dai_call(start, io, priv);\n\t\tif (ret < 0)\n\t\t\tgoto dai_trigger_end;\n\n\t\tret = rsnd_dai_call(irq, io, priv, 1);\n\t\tif (ret < 0)\n\t\t\tgoto dai_trigger_end;\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tret = rsnd_dai_call(irq, io, priv, 0);\n\n\t\tret |= rsnd_dai_call(stop, io, priv);\n\n\t\tret |= rsnd_dai_call(quit, io, priv);\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\ndai_trigger_end:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\trdai->clk_master = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\trdai->clk_master = 1;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trdai->bit_clk_inv = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\trdai->sys_delay = 0;\n\t\trdai->data_alignment = 0;\n\t\trdai->frm_clk_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\trdai->sys_delay = 1;\n\t\trdai->data_alignment = 0;\n\t\trdai->frm_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\trdai->sys_delay = 1;\n\t\trdai->data_alignment = 1;\n\t\trdai->frm_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\trdai->sys_delay = 0;\n\t\trdai->data_alignment = 0;\n\t\trdai->frm_clk_inv = 1;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\trdai->frm_clk_inv = !rdai->frm_clk_inv;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\trdai->bit_clk_inv = !rdai->bit_clk_inv;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\trdai->bit_clk_inv = !rdai->bit_clk_inv;\n\t\trdai->frm_clk_inv = !rdai->frm_clk_inv;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t     u32 tx_mask, u32 rx_mask,\n\t\t\t\t     int slots, int slot_width)\n{\n\tstruct rsnd_priv *priv = rsnd_dai_to_priv(dai);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tswitch (slot_width) {\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t \n\t\tif (slot_width)\n\t\t\tdev_warn(dev, \"unsupported TDM slot width (%d), force to use default 32\\n\",\n\t\t\t\t slot_width);\n\t\tslot_width = 32;\n\t}\n\n\tswitch (slots) {\n\tcase 2:\n\t\t \n\tcase 6:\n\tcase 8:\n\t\t \n\t\trsnd_rdai_channels_set(rdai, slots);\n\t\trsnd_rdai_ssi_lane_set(rdai, 1);\n\t\trsnd_rdai_width_set(rdai, slot_width);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported TDM slots (%d)\\n\", slots);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int rsnd_soc_hw_channels_list[] = {\n\t2, 6, 8,\n};\n\nstatic unsigned int rsnd_soc_hw_rate_list[] = {\n\t  8000,\n\t 11025,\n\t 16000,\n\t 22050,\n\t 32000,\n\t 44100,\n\t 48000,\n\t 64000,\n\t 88200,\n\t 96000,\n\t176400,\n\t192000,\n};\n\nstatic int rsnd_soc_hw_rule(struct rsnd_dai *rdai,\n\t\t\t    unsigned int *list, int list_num,\n\t\t\t    struct snd_interval *baseline, struct snd_interval *iv,\n\t\t\t    struct rsnd_dai_stream *io, char *unit)\n{\n\tstruct snd_interval p;\n\tunsigned int rate;\n\tint i;\n\n\tsnd_interval_any(&p);\n\tp.min = UINT_MAX;\n\tp.max = 0;\n\n\tfor (i = 0; i < list_num; i++) {\n\n\t\tif (!snd_interval_test(iv, list[i]))\n\t\t\tcontinue;\n\n\t\trate = rsnd_ssi_clk_query(rdai,\n\t\t\t\t\t  baseline->min, list[i], NULL);\n\t\tif (rate > 0) {\n\t\t\tp.min = min(p.min, list[i]);\n\t\t\tp.max = max(p.max, list[i]);\n\t\t}\n\n\t\trate = rsnd_ssi_clk_query(rdai,\n\t\t\t\t\t  baseline->max, list[i], NULL);\n\t\tif (rate > 0) {\n\t\t\tp.min = min(p.min, list[i]);\n\t\t\tp.max = max(p.max, list[i]);\n\t\t}\n\t}\n\n\t \n\tif (!rsnd_flags_has(io, RSND_HW_RULE_ERR) && (p.min > p.max)) {\n\t\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t\tdev_warn(dev, \"It can't handle %d %s <-> %d %s\\n\",\n\t\t\t baseline->min, unit, baseline->max, unit);\n\t\trsnd_flags_set(io, RSND_HW_RULE_ERR);\n\t}\n\n\treturn snd_interval_refine(iv, &p);\n}\n\nstatic int rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval ic;\n\tstruct rsnd_dai_stream *io = rule->private;\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\n\t \n\tic = *ic_;\n\tic.min =\n\tic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);\n\n\treturn rsnd_soc_hw_rule(rdai, rsnd_soc_hw_rate_list,\n\t\t\t\tARRAY_SIZE(rsnd_soc_hw_rate_list),\n\t\t\t\t&ic, ir, io, \"ch\");\n}\n\nstatic int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval ic;\n\tstruct rsnd_dai_stream *io = rule->private;\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\n\t \n\tic = *ic_;\n\tic.min =\n\tic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);\n\n\treturn rsnd_soc_hw_rule(rdai, rsnd_soc_hw_channels_list,\n\t\t\t\tARRAY_SIZE(rsnd_soc_hw_channels_list),\n\t\t\t\tir, &ic, io, \"Hz\");\n}\n\nstatic const struct snd_pcm_hardware rsnd_pcm_hardware = {\n\t.info =\t\tSNDRV_PCM_INFO_INTERLEAVED\t|\n\t\t\tSNDRV_PCM_INFO_MMAP\t\t|\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.buffer_bytes_max\t= 64 * 1024,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 8192,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 32,\n\t.fifo_size\t\t= 256,\n};\n\nstatic int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\tstruct snd_pcm_hw_constraint_list *constraint = &rdai->constraint;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int max_channels = rsnd_rdai_channels_get(rdai);\n\tint i;\n\n\trsnd_flags_del(io, RSND_HW_RULE_ERR);\n\n\trsnd_dai_stream_init(io, substream);\n\n\t \n\tconstraint->list\t= rsnd_soc_hw_channels_list;\n\tconstraint->count\t= 0;\n\tconstraint->mask\t= 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(rsnd_soc_hw_channels_list); i++) {\n\t\tif (rsnd_soc_hw_channels_list[i] > max_channels)\n\t\t\tbreak;\n\t\tconstraint->count = i + 1;\n\t}\n\n\tsnd_soc_set_runtime_hwparams(substream, &rsnd_pcm_hardware);\n\n\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, constraint);\n\n\tsnd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t      SNDRV_PCM_HW_PARAM_PERIODS);\n\n\t \n\tif (rsnd_rdai_is_clk_master(rdai)) {\n\t\tint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\n\t\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t    rsnd_soc_hw_rule_rate,\n\t\t\t\t    is_play ? &rdai->playback : &rdai->capture,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\t\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t    rsnd_soc_hw_rule_channels,\n\t\t\t\t    is_play ? &rdai->playback : &rdai->capture,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE, -1);\n\t}\n\n\treturn 0;\n}\n\nstatic void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\n\t \n\trsnd_dai_call(cleanup, io, priv);\n\n\trsnd_dai_stream_quit(io);\n}\n\nstatic int rsnd_soc_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct rsnd_priv *priv = rsnd_dai_to_priv(dai);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\n\treturn rsnd_dai_call(prepare, io, priv);\n}\n\nstatic u64 rsnd_soc_dai_formats[] = {\n\t \n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_RIGHT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_IF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_IF,\n\t \n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B,\n};\n\nstatic void rsnd_parse_tdm_split_mode(struct rsnd_priv *priv,\n\t\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t\t      struct device_node *dai_np)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *ssiu_np = rsnd_ssiu_of_node(priv);\n\tstruct device_node *np;\n\tint is_play = rsnd_io_is_play(io);\n\tint i;\n\n\tif (!ssiu_np)\n\t\treturn;\n\n\t \n\tfor (i = 0;; i++) {\n\t\tstruct device_node *node = is_play ?\n\t\t\tof_parse_phandle(dai_np, \"playback\", i) :\n\t\t\tof_parse_phandle(dai_np, \"capture\",  i);\n\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tfor_each_child_of_node(ssiu_np, np) {\n\t\t\tif (np == node) {\n\t\t\t\trsnd_flags_set(io, RSND_STREAM_TDM_SPLIT);\n\t\t\t\tdev_dbg(dev, \"%s is part of TDM Split\\n\", io->name);\n\t\t\t}\n\t\t}\n\n\t\tof_node_put(node);\n\t}\n\n\tof_node_put(ssiu_np);\n}\n\nstatic void rsnd_parse_connect_simple(struct rsnd_priv *priv,\n\t\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t\t      struct device_node *dai_np)\n{\n\tif (!rsnd_io_to_mod_ssi(io))\n\t\treturn;\n\n\trsnd_parse_tdm_split_mode(priv, io, dai_np);\n}\n\nstatic void rsnd_parse_connect_graph(struct rsnd_priv *priv,\n\t\t\t\t     struct rsnd_dai_stream *io,\n\t\t\t\t     struct device_node *endpoint)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *remote_node;\n\n\tif (!rsnd_io_to_mod_ssi(io))\n\t\treturn;\n\n\tremote_node = of_graph_get_remote_port_parent(endpoint);\n\n\t \n\tif (strstr(remote_node->full_name, \"hdmi@fead0000\")) {\n\t\trsnd_flags_set(io, RSND_STREAM_HDMI0);\n\t\tdev_dbg(dev, \"%s connected to HDMI0\\n\", io->name);\n\t}\n\n\t \n\tif (strstr(remote_node->full_name, \"hdmi@feae0000\")) {\n\t\trsnd_flags_set(io, RSND_STREAM_HDMI1);\n\t\tdev_dbg(dev, \"%s connected to HDMI1\\n\", io->name);\n\t}\n\n\trsnd_parse_tdm_split_mode(priv, io, endpoint);\n\n\tof_node_put(remote_node);\n}\n\nvoid rsnd_parse_connect_common(struct rsnd_dai *rdai, char *name,\n\t\tstruct rsnd_mod* (*mod_get)(struct rsnd_priv *priv, int id),\n\t\tstruct device_node *node,\n\t\tstruct device_node *playback,\n\t\tstruct device_node *capture)\n{\n\tstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np;\n\tint i;\n\n\tif (!node)\n\t\treturn;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tstruct rsnd_mod *mod;\n\n\t\ti = rsnd_node_fixed_index(dev, np, name, i);\n\t\tif (i < 0) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tmod = mod_get(priv, i);\n\n\t\tif (np == playback)\n\t\t\trsnd_dai_connect(mod, &rdai->playback, mod->type);\n\t\tif (np == capture)\n\t\t\trsnd_dai_connect(mod, &rdai->capture, mod->type);\n\t\ti++;\n\t}\n\n\tof_node_put(node);\n}\n\nint rsnd_node_fixed_index(struct device *dev, struct device_node *node, char *name, int idx)\n{\n\tchar node_name[16];\n\n\t \n\tfor (; idx < 64; idx++) {\n\t\tsnprintf(node_name, sizeof(node_name), \"%s-%d\", name, idx);\n\n\t\tif (strncmp(node_name, of_node_full_name(node), sizeof(node_name)) == 0)\n\t\t\treturn idx;\n\t}\n\n\tdev_err(dev, \"strange node numbering (%s)\",\n\t\tof_node_full_name(node));\n\treturn -EINVAL;\n}\n\nint rsnd_node_count(struct rsnd_priv *priv, struct device_node *node, char *name)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np;\n\tint i;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\ti = rsnd_node_fixed_index(dev, np, name, i);\n\t\tif (i < 0) {\n\t\t\tof_node_put(np);\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\nstatic int rsnd_dai_of_node(struct rsnd_priv *priv, int *is_graph)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *ports, *node;\n\tint nr = 0;\n\tint i = 0;\n\n\t*is_graph = 0;\n\n\t \n\n\t \n\tnode = of_get_child_by_name(np, RSND_NODE_DAI);\n\tif (!node)\n\t\tgoto audio_graph;\n\n\tof_node_put(node);\n\n\tfor_each_child_of_node(np, node) {\n\t\tif (!of_node_name_eq(node, RSND_NODE_DAI))\n\t\t\tcontinue;\n\n\t\tpriv->component_dais[i] = of_get_child_count(node);\n\t\tnr += priv->component_dais[i];\n\t\ti++;\n\t\tif (i >= RSND_MAX_COMPONENT) {\n\t\t\tdev_info(dev, \"reach to max component\\n\");\n\t\t\tof_node_put(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr;\n\naudio_graph:\n\t \n\tfor_each_child_of_node(np, ports) {\n\t\tif (!of_node_name_eq(ports, \"ports\") &&\n\t\t    !of_node_name_eq(ports, \"port\"))\n\t\t\tcontinue;\n\t\tpriv->component_dais[i] = of_graph_get_endpoint_count(ports);\n\t\tnr += priv->component_dais[i];\n\t\ti++;\n\t\tif (i >= RSND_MAX_COMPONENT) {\n\t\t\tdev_info(dev, \"reach to max component\\n\");\n\t\t\tof_node_put(node);\n\t\t\tof_node_put(ports);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*is_graph = 1;\n\n\treturn nr;\n}\n\n\n#define PREALLOC_BUFFER\t\t(32 * 1024)\n#define PREALLOC_BUFFER_MAX\t(32 * 1024)\n\nstatic int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t\t  int stream)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct snd_pcm_substream *substream;\n\n\t \n\tif (io->dmac_dev)\n\t\tdev = io->dmac_dev;\n\n\tfor (substream = rtd->pcm->streams[stream].substream;\n\t     substream;\n\t     substream = substream->next) {\n\t\tsnd_pcm_set_managed_buffer(substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   dev,\n\t\t\t\t\t   PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_soc_dai_pcm_new(struct snd_soc_pcm_runtime *rtd, struct snd_soc_dai *dai)\n{\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tint ret;\n\n\tret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsnd_preallocate_pages(rtd, &rdai->playback,\n\t\t\t\t     SNDRV_PCM_STREAM_PLAYBACK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsnd_preallocate_pages(rtd, &rdai->capture,\n\t\t\t\t     SNDRV_PCM_STREAM_CAPTURE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rsnd_soc_dai_ops = {\n\t.pcm_new\t\t\t= rsnd_soc_dai_pcm_new,\n\t.startup\t\t\t= rsnd_soc_dai_startup,\n\t.shutdown\t\t\t= rsnd_soc_dai_shutdown,\n\t.trigger\t\t\t= rsnd_soc_dai_trigger,\n\t.set_fmt\t\t\t= rsnd_soc_dai_set_fmt,\n\t.set_tdm_slot\t\t\t= rsnd_soc_set_dai_tdm_slot,\n\t.prepare\t\t\t= rsnd_soc_dai_prepare,\n\t.auto_selectable_formats\t= rsnd_soc_dai_formats,\n\t.num_auto_selectable_formats\t= ARRAY_SIZE(rsnd_soc_dai_formats),\n};\n\nstatic void __rsnd_dai_probe(struct rsnd_priv *priv,\n\t\t\t     struct device_node *dai_np,\n\t\t\t     struct device_node *node_np,\n\t\t\t     uint32_t node_arg,\n\t\t\t     int dai_i)\n{\n\tstruct rsnd_dai_stream *io_playback;\n\tstruct rsnd_dai_stream *io_capture;\n\tstruct snd_soc_dai_driver *drv;\n\tstruct rsnd_dai *rdai;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint playback_exist = 0, capture_exist = 0;\n\tint io_i;\n\n\trdai\t\t= rsnd_rdai_get(priv, dai_i);\n\tdrv\t\t= rsnd_daidrv_get(priv, dai_i);\n\tio_playback\t= &rdai->playback;\n\tio_capture\t= &rdai->capture;\n\n\tsnprintf(rdai->name, RSND_DAI_NAME_SIZE, \"rsnd-dai.%d\", dai_i);\n\n\t \n\trdai->dai_args.np\t\t= node_np;\n\trdai->dai_args.args_count\t= 1;\n\trdai->dai_args.args[0]\t\t= node_arg;\n\n\trdai->priv\t= priv;\n\tdrv->name\t= rdai->name;\n\tdrv->ops\t= &rsnd_soc_dai_ops;\n\tdrv->id\t\t= dai_i;\n\tdrv->dai_args\t= &rdai->dai_args;\n\n\tio_playback->rdai\t\t= rdai;\n\tio_capture->rdai\t\t= rdai;\n\trsnd_rdai_channels_set(rdai, 2);  \n\trsnd_rdai_ssi_lane_set(rdai, 1);  \n\trsnd_rdai_width_set(rdai, 32);    \n\n\tfor (io_i = 0;; io_i++) {\n\t\tstruct device_node *playback = of_parse_phandle(dai_np, \"playback\", io_i);\n\t\tstruct device_node *capture  = of_parse_phandle(dai_np, \"capture\", io_i);\n\n\t\tif (!playback && !capture)\n\t\t\tbreak;\n\n\t\tif (io_i == 0) {\n\t\t\t \n\t\t\tif (playback)\n\t\t\t\tplayback_exist = 1;\n\t\t\tif (capture)\n\t\t\t\tcapture_exist = 1;\n\t\t}\n\n\t\trsnd_parse_connect_ssi(rdai, playback, capture);\n\t\trsnd_parse_connect_ssiu(rdai, playback, capture);\n\t\trsnd_parse_connect_src(rdai, playback, capture);\n\t\trsnd_parse_connect_ctu(rdai, playback, capture);\n\t\trsnd_parse_connect_mix(rdai, playback, capture);\n\t\trsnd_parse_connect_dvc(rdai, playback, capture);\n\n\t\tof_node_put(playback);\n\t\tof_node_put(capture);\n\t}\n\n\tif (playback_exist) {\n\t\tsnprintf(io_playback->name, RSND_DAI_NAME_SIZE, \"DAI%d Playback\", dai_i);\n\t\tdrv->playback.rates\t\t= RSND_RATES;\n\t\tdrv->playback.formats\t\t= RSND_FMTS;\n\t\tdrv->playback.channels_min\t= 2;\n\t\tdrv->playback.channels_max\t= 8;\n\t\tdrv->playback.stream_name\t= io_playback->name;\n\t}\n\tif (capture_exist) {\n\t\tsnprintf(io_capture->name, RSND_DAI_NAME_SIZE, \"DAI%d Capture\", dai_i);\n\t\tdrv->capture.rates\t\t= RSND_RATES;\n\t\tdrv->capture.formats\t\t= RSND_FMTS;\n\t\tdrv->capture.channels_min\t= 2;\n\t\tdrv->capture.channels_max\t= 8;\n\t\tdrv->capture.stream_name\t= io_capture->name;\n\t}\n\n\tif (rsnd_ssi_is_pin_sharing(io_capture) ||\n\t    rsnd_ssi_is_pin_sharing(io_playback)) {\n\t\t \n\t\tdrv->symmetric_rate = 1;\n\t}\n\n\tdev_dbg(dev, \"%s (%s/%s)\\n\", rdai->name,\n\t\trsnd_io_to_mod_ssi(io_playback) ? \"play\"    : \" -- \",\n\t\trsnd_io_to_mod_ssi(io_capture) ? \"capture\" : \"  --   \");\n}\n\nstatic int rsnd_dai_probe(struct rsnd_priv *priv)\n{\n\tstruct snd_soc_dai_driver *rdrv;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\tstruct rsnd_dai *rdai;\n\tint nr = 0;\n\tint is_graph;\n\tint dai_i;\n\n\tnr = rsnd_dai_of_node(priv, &is_graph);\n\tif (!nr)\n\t\treturn -EINVAL;\n\n\trdrv = devm_kcalloc(dev, nr, sizeof(*rdrv), GFP_KERNEL);\n\trdai = devm_kcalloc(dev, nr, sizeof(*rdai), GFP_KERNEL);\n\tif (!rdrv || !rdai)\n\t\treturn -ENOMEM;\n\n\tpriv->rdai_nr\t= nr;\n\tpriv->daidrv\t= rdrv;\n\tpriv->rdai\t= rdai;\n\n\t \n\tdai_i = 0;\n\tif (is_graph) {\n\t\tstruct device_node *ports;\n\t\tstruct device_node *dai_np;\n\n\t\tfor_each_child_of_node(np, ports) {\n\t\t\tif (!of_node_name_eq(ports, \"ports\") &&\n\t\t\t    !of_node_name_eq(ports, \"port\"))\n\t\t\t\tcontinue;\n\t\t\tfor_each_endpoint_of_node(ports, dai_np) {\n\t\t\t\t__rsnd_dai_probe(priv, dai_np, dai_np, 0, dai_i);\n\t\t\t\tif (rsnd_is_gen3(priv) || rsnd_is_gen4(priv)) {\n\t\t\t\t\trdai = rsnd_rdai_get(priv, dai_i);\n\n\t\t\t\t\trsnd_parse_connect_graph(priv, &rdai->playback, dai_np);\n\t\t\t\t\trsnd_parse_connect_graph(priv, &rdai->capture,  dai_np);\n\t\t\t\t}\n\t\t\t\tdai_i++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct device_node *node;\n\t\tstruct device_node *dai_np;\n\n\t\tfor_each_child_of_node(np, node) {\n\t\t\tif (!of_node_name_eq(node, RSND_NODE_DAI))\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_child_of_node(node, dai_np) {\n\t\t\t\t__rsnd_dai_probe(priv, dai_np, np, dai_i, dai_i);\n\t\t\t\tif (rsnd_is_gen3(priv) || rsnd_is_gen4(priv)) {\n\t\t\t\t\trdai = rsnd_rdai_get(priv, dai_i);\n\n\t\t\t\t\trsnd_parse_connect_simple(priv, &rdai->playback, dai_np);\n\t\t\t\t\trsnd_parse_connect_simple(priv, &rdai->capture,  dai_np);\n\t\t\t\t}\n\t\t\t\tdai_i++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rsnd_hw_update(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_soc_dai *dai = rsnd_substream_to_dai(substream);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (hw_params)\n\t\tret = rsnd_dai_call(hw_params, io, substream, hw_params);\n\telse\n\t\tret = rsnd_dai_call(hw_free, io, substream);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic int rsnd_hw_params(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_soc_dai *dai = rsnd_substream_to_dai(substream);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\n\t \n\tio->converted_rate = 0;\n\tio->converted_chan = 0;\n\tif (fe->dai_link->dynamic) {\n\t\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\t\tstruct snd_soc_dpcm *dpcm;\n\t\tint stream = substream->stream;\n\n\t\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\t\tstruct snd_pcm_hw_params *be_params = &be->dpcm[stream].hw_params;\n\n\t\t\tif (params_channels(hw_params) != params_channels(be_params))\n\t\t\t\tio->converted_chan = params_channels(be_params);\n\t\t\tif (params_rate(hw_params) != params_rate(be_params))\n\t\t\t\tio->converted_rate = params_rate(be_params);\n\t\t}\n\t\tif (io->converted_chan)\n\t\t\tdev_dbg(dev, \"convert channels = %d\\n\", io->converted_chan);\n\t\tif (io->converted_rate) {\n\t\t\t \n\t\t\tint k_up = 6;\n\t\t\tint k_down = 6;\n\t\t\tint channel;\n\t\t\tstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\n\n\t\t\tdev_dbg(dev, \"convert rate     = %d\\n\", io->converted_rate);\n\n\t\t\tchannel = io->converted_chan ? io->converted_chan :\n\t\t\t\t  params_channels(hw_params);\n\n\t\t\tswitch (rsnd_mod_id(src_mod)) {\n\t\t\t \n\t\t\tcase 1:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\tif (channel > 4) {\n\t\t\t\t\tk_down = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase 0:\n\t\t\t\tif (channel > 2)\n\t\t\t\t\tk_down = 4;\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tdefault:\n\t\t\t\tif (channel > 2)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (params_rate(hw_params) > io->converted_rate * k_down) {\n\t\t\t\thw_param_interval(hw_params, SNDRV_PCM_HW_PARAM_RATE)->min =\n\t\t\t\t\tio->converted_rate * k_down;\n\t\t\t\thw_param_interval(hw_params, SNDRV_PCM_HW_PARAM_RATE)->max =\n\t\t\t\t\tio->converted_rate * k_down;\n\t\t\t\thw_params->cmask |= SNDRV_PCM_HW_PARAM_RATE;\n\t\t\t} else if (params_rate(hw_params) * k_up < io->converted_rate) {\n\t\t\t\thw_param_interval(hw_params, SNDRV_PCM_HW_PARAM_RATE)->min =\n\t\t\t\t\tDIV_ROUND_UP(io->converted_rate, k_up);\n\t\t\t\thw_param_interval(hw_params, SNDRV_PCM_HW_PARAM_RATE)->max =\n\t\t\t\t\tDIV_ROUND_UP(io->converted_rate, k_up);\n\t\t\t\thw_params->cmask |= SNDRV_PCM_HW_PARAM_RATE;\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t}\n\n\treturn rsnd_hw_update(substream, hw_params);\n}\n\nstatic int rsnd_hw_free(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\treturn rsnd_hw_update(substream, NULL);\n}\n\nstatic snd_pcm_uframes_t rsnd_pointer(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_dai *dai = rsnd_substream_to_dai(substream);\n\tstruct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);\n\tstruct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);\n\tsnd_pcm_uframes_t pointer = 0;\n\n\trsnd_dai_call(pointer, io, &pointer);\n\n\treturn pointer;\n}\n\n \nstatic int rsnd_kctrl_info(struct snd_kcontrol *kctrl,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);\n\n\tif (cfg->texts) {\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\t\tuinfo->count = cfg->size;\n\t\tuinfo->value.enumerated.items = cfg->max;\n\t\tif (uinfo->value.enumerated.item >= cfg->max)\n\t\t\tuinfo->value.enumerated.item = cfg->max - 1;\n\t\tstrscpy(uinfo->value.enumerated.name,\n\t\t\tcfg->texts[uinfo->value.enumerated.item],\n\t\t\tsizeof(uinfo->value.enumerated.name));\n\t} else {\n\t\tuinfo->count = cfg->size;\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = cfg->max;\n\t\tuinfo->type = (cfg->max == 1) ?\n\t\t\tSNDRV_CTL_ELEM_TYPE_BOOLEAN :\n\t\t\tSNDRV_CTL_ELEM_TYPE_INTEGER;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_kctrl_get(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *uc)\n{\n\tstruct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);\n\tint i;\n\n\tfor (i = 0; i < cfg->size; i++)\n\t\tif (cfg->texts)\n\t\t\tuc->value.enumerated.item[i] = cfg->val[i];\n\t\telse\n\t\t\tuc->value.integer.value[i] = cfg->val[i];\n\n\treturn 0;\n}\n\nstatic int rsnd_kctrl_put(struct snd_kcontrol *kctrl,\n\t\t\t  struct snd_ctl_elem_value *uc)\n{\n\tstruct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);\n\tint i, change = 0;\n\n\tif (!cfg->accept(cfg->io))\n\t\treturn 0;\n\n\tfor (i = 0; i < cfg->size; i++) {\n\t\tif (cfg->texts) {\n\t\t\tchange |= (uc->value.enumerated.item[i] != cfg->val[i]);\n\t\t\tcfg->val[i] = uc->value.enumerated.item[i];\n\t\t} else {\n\t\t\tchange |= (uc->value.integer.value[i] != cfg->val[i]);\n\t\t\tcfg->val[i] = uc->value.integer.value[i];\n\t\t}\n\t}\n\n\tif (change && cfg->update)\n\t\tcfg->update(cfg->io, cfg->mod);\n\n\treturn change;\n}\n\nint rsnd_kctrl_accept_anytime(struct rsnd_dai_stream *io)\n{\n\treturn 1;\n}\n\nint rsnd_kctrl_accept_runtime(struct rsnd_dai_stream *io)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tif (!runtime) {\n\t\tdev_warn(dev, \"Can't update kctrl when idle\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstruct rsnd_kctrl_cfg *rsnd_kctrl_init_m(struct rsnd_kctrl_cfg_m *cfg)\n{\n\tcfg->cfg.val = cfg->val;\n\n\treturn &cfg->cfg;\n}\n\nstruct rsnd_kctrl_cfg *rsnd_kctrl_init_s(struct rsnd_kctrl_cfg_s *cfg)\n{\n\tcfg->cfg.val = &cfg->val;\n\n\treturn &cfg->cfg;\n}\n\nconst char * const volume_ramp_rate[] = {\n\t\"128 dB/1 step\",\t  \n\t\"64 dB/1 step\",\t\t  \n\t\"32 dB/1 step\",\t\t  \n\t\"16 dB/1 step\",\t\t  \n\t\"8 dB/1 step\",\t\t  \n\t\"4 dB/1 step\",\t\t  \n\t\"2 dB/1 step\",\t\t  \n\t\"1 dB/1 step\",\t\t  \n\t\"0.5 dB/1 step\",\t  \n\t\"0.25 dB/1 step\",\t  \n\t\"0.125 dB/1 step\",\t  \n\t\"0.125 dB/2 steps\",\t  \n\t\"0.125 dB/4 steps\",\t  \n\t\"0.125 dB/8 steps\",\t  \n\t\"0.125 dB/16 steps\",\t  \n\t\"0.125 dB/32 steps\",\t  \n\t\"0.125 dB/64 steps\",\t  \n\t\"0.125 dB/128 steps\",\t  \n\t\"0.125 dB/256 steps\",\t  \n\t\"0.125 dB/512 steps\",\t  \n\t\"0.125 dB/1024 steps\",\t  \n\t\"0.125 dB/2048 steps\",\t  \n\t\"0.125 dB/4096 steps\",\t  \n\t\"0.125 dB/8192 steps\",\t  \n};\n\nint rsnd_kctrl_new(struct rsnd_mod *mod,\n\t\t   struct rsnd_dai_stream *io,\n\t\t   struct snd_soc_pcm_runtime *rtd,\n\t\t   const unsigned char *name,\n\t\t   int (*accept)(struct rsnd_dai_stream *io),\n\t\t   void (*update)(struct rsnd_dai_stream *io,\n\t\t\t\t  struct rsnd_mod *mod),\n\t\t   struct rsnd_kctrl_cfg *cfg,\n\t\t   const char * const *texts,\n\t\t   int size,\n\t\t   u32 max)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_kcontrol *kctrl;\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name\t\t= name,\n\t\t.info\t\t= rsnd_kctrl_info,\n\t\t.index\t\t= rtd->num,\n\t\t.get\t\t= rsnd_kctrl_get,\n\t\t.put\t\t= rsnd_kctrl_put,\n\t};\n\tint ret;\n\n\t \n\tlist_for_each_entry(kctrl, &card->controls, list) {\n\t\tstruct rsnd_kctrl_cfg *c = kctrl->private_data;\n\n\t\tif (c == cfg)\n\t\t\treturn 0;\n\t}\n\n\tif (size > RSND_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tkctrl = snd_ctl_new1(&knew, cfg);\n\tif (!kctrl)\n\t\treturn -ENOMEM;\n\n\tret = snd_ctl_add(card, kctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfg->texts\t= texts;\n\tcfg->max\t= max;\n\tcfg->size\t= size;\n\tcfg->accept\t= accept;\n\tcfg->update\t= update;\n\tcfg->card\t= card;\n\tcfg->kctrl\t= kctrl;\n\tcfg->io\t\t= io;\n\tcfg->mod\t= mod;\n\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_component_driver rsnd_soc_component = {\n\t.name\t\t\t= \"rsnd\",\n\t.probe\t\t\t= rsnd_debugfs_probe,\n\t.hw_params\t\t= rsnd_hw_params,\n\t.hw_free\t\t= rsnd_hw_free,\n\t.pointer\t\t= rsnd_pointer,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,\n\t\t\t\t       struct rsnd_dai_stream *io)\n{\n\tint ret;\n\n\tret = rsnd_dai_call(probe, io, priv);\n\tif (ret == -EAGAIN) {\n\t\tstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\n\t\tstruct rsnd_mod *mod;\n\t\tint i;\n\n\t\t \n\n\t\t \n\t\trsnd_dai_call(remove, io, priv);\n\n\t\t \n\t\tfor_each_rsnd_mod(i, mod, io)\n\t\t\trsnd_dai_disconnect(mod, io, i);\n\t\trsnd_dai_connect(ssi_mod, io, RSND_MOD_SSI);\n\n\t\t \n\t\trsnd_dai_call(fallback, io, priv);\n\n\t\t \n\t\tret = rsnd_dai_call(probe, io, priv);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int rsnd_probe(struct platform_device *pdev)\n{\n\tstruct rsnd_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct rsnd_dai *rdai;\n\tint (*probe_func[])(struct rsnd_priv *priv) = {\n\t\trsnd_gen_probe,\n\t\trsnd_dma_probe,\n\t\trsnd_ssi_probe,\n\t\trsnd_ssiu_probe,\n\t\trsnd_src_probe,\n\t\trsnd_ctu_probe,\n\t\trsnd_mix_probe,\n\t\trsnd_dvc_probe,\n\t\trsnd_cmd_probe,\n\t\trsnd_adg_probe,\n\t\trsnd_dai_probe,\n\t};\n\tint ret, i;\n\tint ci;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tpriv->pdev\t= pdev;\n\tpriv->flags\t= (unsigned long)of_device_get_match_data(dev);\n\tspin_lock_init(&priv->lock);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(probe_func); i++) {\n\t\tret = probe_func[i](priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_rsnd_dai(rdai, priv, i) {\n\t\tret = rsnd_rdai_continuance_probe(priv, &rdai->playback);\n\t\tif (ret)\n\t\t\tgoto exit_snd_probe;\n\n\t\tret = rsnd_rdai_continuance_probe(priv, &rdai->capture);\n\t\tif (ret)\n\t\t\tgoto exit_snd_probe;\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\n\t \n\tci = 0;\n\tfor (i = 0; priv->component_dais[i] > 0; i++) {\n\t\tint nr = priv->component_dais[i];\n\n\t\tret = devm_snd_soc_register_component(dev, &rsnd_soc_component,\n\t\t\t\t\t\t      priv->daidrv + ci, nr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"cannot snd component register\\n\");\n\t\t\tgoto exit_snd_probe;\n\t\t}\n\n\t\tci += nr;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tdev_info(dev, \"probed\\n\");\n\treturn ret;\n\nexit_snd_probe:\n\tfor_each_rsnd_dai(rdai, priv, i) {\n\t\trsnd_dai_call(remove, &rdai->playback, priv);\n\t\trsnd_dai_call(remove, &rdai->capture, priv);\n\t}\n\n\t \n\trsnd_adg_remove(priv);\n\n\treturn ret;\n}\n\nstatic void rsnd_remove(struct platform_device *pdev)\n{\n\tstruct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);\n\tstruct rsnd_dai *rdai;\n\tvoid (*remove_func[])(struct rsnd_priv *priv) = {\n\t\trsnd_ssi_remove,\n\t\trsnd_ssiu_remove,\n\t\trsnd_src_remove,\n\t\trsnd_ctu_remove,\n\t\trsnd_mix_remove,\n\t\trsnd_dvc_remove,\n\t\trsnd_cmd_remove,\n\t\trsnd_adg_remove,\n\t};\n\tint i;\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tfor_each_rsnd_dai(rdai, priv, i) {\n\t\tint ret;\n\n\t\tret = rsnd_dai_call(remove, &rdai->playback, priv);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"Failed to remove playback dai #%d\\n\", i);\n\n\t\tret = rsnd_dai_call(remove, &rdai->capture, priv);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"Failed to remove capture dai #%d\\n\", i);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(remove_func); i++)\n\t\tremove_func[i](priv);\n}\n\nstatic int __maybe_unused rsnd_suspend(struct device *dev)\n{\n\tstruct rsnd_priv *priv = dev_get_drvdata(dev);\n\n\trsnd_adg_clk_disable(priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rsnd_resume(struct device *dev)\n{\n\tstruct rsnd_priv *priv = dev_get_drvdata(dev);\n\n\trsnd_adg_clk_enable(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rsnd_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rsnd_suspend, rsnd_resume)\n};\n\nstatic struct platform_driver rsnd_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rcar_sound\",\n\t\t.pm\t= &rsnd_pm_ops,\n\t\t.of_match_table = rsnd_of_match,\n\t},\n\t.probe\t\t= rsnd_probe,\n\t.remove_new\t= rsnd_remove,\n};\nmodule_platform_driver(rsnd_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car audio driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_ALIAS(\"platform:rcar-pcm-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}