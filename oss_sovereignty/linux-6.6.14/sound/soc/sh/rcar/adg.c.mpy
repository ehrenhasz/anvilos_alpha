{
  "module_name": "adg.c",
  "hash_id": "d5e43a1ff907d1d60bff750daa5036df9ffde81d74ccfa566ecefc2b745278e9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/adg.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include \"rsnd.h\"\n\n#define CLKA\t0\n#define CLKB\t1\n#define CLKC\t2\n#define CLKI\t3\n#define CLKINMAX 4\n\n#define CLKOUT\t0\n#define CLKOUT1\t1\n#define CLKOUT2\t2\n#define CLKOUT3\t3\n#define CLKOUTMAX 4\n\n#define BRRx_MASK(x) (0x3FF & x)\n\nstatic struct rsnd_mod_ops adg_ops = {\n\t.name = \"adg\",\n};\n\n#define ADG_HZ_441\t0\n#define ADG_HZ_48\t1\n#define ADG_HZ_SIZE\t2\n\nstruct rsnd_adg {\n\tstruct clk *clkin[CLKINMAX];\n\tstruct clk *clkout[CLKOUTMAX];\n\tstruct clk *null_clk;\n\tstruct clk_onecell_data onecell;\n\tstruct rsnd_mod mod;\n\tint clkin_rate[CLKINMAX];\n\tint clkin_size;\n\tint clkout_size;\n\tu32 ckr;\n\tu32 brga;\n\tu32 brgb;\n\n\tint brg_rate[ADG_HZ_SIZE];  \n};\n\n#define for_each_rsnd_clkin(pos, adg, i)\t\\\n\tfor (i = 0;\t\t\t\t\\\n\t     (i < adg->clkin_size) &&\t\t\\\n\t     ((pos) = adg->clkin[i]);\t\t\\\n\t     i++)\n#define for_each_rsnd_clkout(pos, adg, i)\t\\\n\tfor (i = 0;\t\t\t\t\\\n\t     (i < adg->clkout_size) &&\t\t\\\n\t     ((pos) = adg->clkout[i]);\t\\\n\t     i++)\n#define rsnd_priv_to_adg(priv) ((struct rsnd_adg *)(priv)->adg)\n\nstatic const char * const clkin_name_gen4[] = {\n\t[CLKA]\t= \"clkin\",\n};\n\nstatic const char * const clkin_name_gen2[] = {\n\t[CLKA]\t= \"clk_a\",\n\t[CLKB]\t= \"clk_b\",\n\t[CLKC]\t= \"clk_c\",\n\t[CLKI]\t= \"clk_i\",\n};\n\nstatic const char * const clkout_name_gen2[] = {\n\t[CLKOUT]  = \"audio_clkout\",\n\t[CLKOUT1] = \"audio_clkout1\",\n\t[CLKOUT2] = \"audio_clkout2\",\n\t[CLKOUT3] = \"audio_clkout3\",\n};\n\nstatic u32 rsnd_adg_calculate_brgx(unsigned long div)\n{\n\tint i;\n\n\tif (!div)\n\t\treturn 0;\n\n\tfor (i = 3; i >= 0; i--) {\n\t\tint ratio = 2 << (i * 2);\n\t\tif (0 == (div % ratio))\n\t\t\treturn (u32)((i << 8) | ((div / ratio) - 1));\n\t}\n\n\treturn ~0;\n}\n\nstatic u32 rsnd_adg_ssi_ws_timing_gen2(struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\n\tint id = rsnd_mod_id(ssi_mod);\n\tint ws = id;\n\n\tif (rsnd_ssi_is_pin_sharing(io)) {\n\t\tswitch (id) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 9:\n\t\t\tws = 0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tws = 3;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tws = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (0x6 + ws) << 8;\n}\n\nstatic void __rsnd_adg_get_timesel_ratio(struct rsnd_priv *priv,\n\t\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t\t       unsigned int target_rate,\n\t\t\t\t       unsigned int *target_val,\n\t\t\t\t       unsigned int *target_en)\n{\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint sel;\n\tunsigned int val, en;\n\tunsigned int min, diff;\n\tunsigned int sel_rate[] = {\n\t\tadg->clkin_rate[CLKA],\t \n\t\tadg->clkin_rate[CLKB],\t \n\t\tadg->clkin_rate[CLKC],\t \n\t\tadg->brg_rate[ADG_HZ_441],\t \n\t\tadg->brg_rate[ADG_HZ_48],\t \n\t};\n\n\tmin = ~0;\n\tval = 0;\n\ten = 0;\n\tfor (sel = 0; sel < ARRAY_SIZE(sel_rate); sel++) {\n\t\tint idx = 0;\n\t\tint step = 2;\n\t\tint div;\n\n\t\tif (!sel_rate[sel])\n\t\t\tcontinue;\n\n\t\tfor (div = 2; div <= 98304; div += step) {\n\t\t\tdiff = abs(target_rate - sel_rate[sel] / div);\n\t\t\tif (min > diff) {\n\t\t\t\tval = (sel << 8) | idx;\n\t\t\t\tmin = diff;\n\t\t\t\ten = 1 << (sel + 1);  \n\t\t\t}\n\n\t\t\t \n\t\t\tif ((idx > 2) && (idx % 2))\n\t\t\t\tstep *= 2;\n\t\t\tif (idx == 0x1c) {\n\t\t\t\tdiv += step;\n\t\t\t\tstep *= 2;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (min == ~0) {\n\t\tdev_err(dev, \"no Input clock\\n\");\n\t\treturn;\n\t}\n\n\t*target_val = val;\n\tif (target_en)\n\t\t*target_en = en;\n}\n\nstatic void rsnd_adg_get_timesel_ratio(struct rsnd_priv *priv,\n\t\t\t\t       struct rsnd_dai_stream *io,\n\t\t\t\t       unsigned int in_rate,\n\t\t\t\t       unsigned int out_rate,\n\t\t\t\t       u32 *in, u32 *out, u32 *en)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tunsigned int target_rate;\n\tu32 *target_val;\n\tu32 _in;\n\tu32 _out;\n\tu32 _en;\n\n\t \n\t_in =\n\t_out = rsnd_adg_ssi_ws_timing_gen2(io);\n\n\ttarget_rate = 0;\n\ttarget_val = NULL;\n\t_en = 0;\n\tif (runtime->rate != in_rate) {\n\t\ttarget_rate = out_rate;\n\t\ttarget_val  = &_out;\n\t} else if (runtime->rate != out_rate) {\n\t\ttarget_rate = in_rate;\n\t\ttarget_val  = &_in;\n\t}\n\n\tif (target_rate)\n\t\t__rsnd_adg_get_timesel_ratio(priv, io,\n\t\t\t\t\t     target_rate,\n\t\t\t\t\t     target_val, &_en);\n\n\tif (in)\n\t\t*in = _in;\n\tif (out)\n\t\t*out = _out;\n\tif (en)\n\t\t*en = _en;\n}\n\nint rsnd_adg_set_cmd_timsel_gen2(struct rsnd_mod *cmd_mod,\n\t\t\t\t struct rsnd_dai_stream *io)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(cmd_mod);\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tint id = rsnd_mod_id(cmd_mod);\n\tint shift = (id % 2) ? 16 : 0;\n\tu32 mask, val;\n\n\trsnd_adg_get_timesel_ratio(priv, io,\n\t\t\t\t   rsnd_src_get_in_rate(priv, io),\n\t\t\t\t   rsnd_src_get_out_rate(priv, io),\n\t\t\t\t   NULL, &val, NULL);\n\n\tval  = val\t<< shift;\n\tmask = 0x0f1f\t<< shift;\n\n\trsnd_mod_bset(adg_mod, CMDOUT_TIMSEL, mask, val);\n\n\treturn 0;\n}\n\nint rsnd_adg_set_src_timesel_gen2(struct rsnd_mod *src_mod,\n\t\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t\t  unsigned int in_rate,\n\t\t\t\t  unsigned int out_rate)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(src_mod);\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tu32 in, out;\n\tu32 mask, en;\n\tint id = rsnd_mod_id(src_mod);\n\tint shift = (id % 2) ? 16 : 0;\n\n\trsnd_mod_confirm_src(src_mod);\n\n\trsnd_adg_get_timesel_ratio(priv, io,\n\t\t\t\t   in_rate, out_rate,\n\t\t\t\t   &in, &out, &en);\n\n\tin   = in\t<< shift;\n\tout  = out\t<< shift;\n\tmask = 0x0f1f\t<< shift;\n\n\trsnd_mod_bset(adg_mod, SRCIN_TIMSEL(id / 2),  mask, in);\n\trsnd_mod_bset(adg_mod, SRCOUT_TIMSEL(id / 2), mask, out);\n\n\tif (en)\n\t\trsnd_mod_bset(adg_mod, DIV_EN, en, en);\n\n\treturn 0;\n}\n\nstatic void rsnd_adg_set_ssi_clk(struct rsnd_mod *ssi_mod, u32 val)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(ssi_mod);\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint id = rsnd_mod_id(ssi_mod);\n\tint shift = (id % 4) * 8;\n\tu32 mask = 0xFF << shift;\n\n\trsnd_mod_confirm_ssi(ssi_mod);\n\n\tval = val << shift;\n\n\t \n\tif (id == 8)\n\t\treturn;\n\n\trsnd_mod_bset(adg_mod, AUDIO_CLK_SEL(id / 4), mask, val);\n\n\tdev_dbg(dev, \"AUDIO_CLK_SEL is 0x%x\\n\", val);\n}\n\nint rsnd_adg_clk_query(struct rsnd_priv *priv, unsigned int rate)\n{\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct clk *clk;\n\tint i;\n\tint sel_table[] = {\n\t\t[CLKA] = 0x1,\n\t\t[CLKB] = 0x2,\n\t\t[CLKC] = 0x3,\n\t\t[CLKI] = 0x0,\n\t};\n\n\t \n\tfor_each_rsnd_clkin(clk, adg, i)\n\t\tif (rate == adg->clkin_rate[i])\n\t\t\treturn sel_table[i];\n\n\t \n\tif (rate == adg->brg_rate[ADG_HZ_441])\n\t\treturn 0x10;\n\n\tif (rate == adg->brg_rate[ADG_HZ_48])\n\t\treturn 0x20;\n\n\treturn -EIO;\n}\n\nint rsnd_adg_ssi_clk_stop(struct rsnd_mod *ssi_mod)\n{\n\trsnd_adg_set_ssi_clk(ssi_mod, 0);\n\n\treturn 0;\n}\n\nint rsnd_adg_ssi_clk_try_start(struct rsnd_mod *ssi_mod, unsigned int rate)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(ssi_mod);\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tint data;\n\tu32 ckr = 0;\n\n\tdata = rsnd_adg_clk_query(priv, rate);\n\tif (data < 0)\n\t\treturn data;\n\n\trsnd_adg_set_ssi_clk(ssi_mod, data);\n\n\tif (0 == (rate % 8000))\n\t\tckr = 0x80000000;  \n\n\trsnd_mod_bset(adg_mod, BRGCKR, 0x80770000, adg->ckr | ckr);\n\n\tdev_dbg(dev, \"CLKOUT is based on BRG%c (= %dHz)\\n\",\n\t\t(ckr) ? 'B' : 'A',\n\t\t(ckr) ?\tadg->brg_rate[ADG_HZ_48] :\n\t\t\tadg->brg_rate[ADG_HZ_441]);\n\n\treturn 0;\n}\n\nvoid rsnd_adg_clk_control(struct rsnd_priv *priv, int enable)\n{\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\n\tstruct clk *clk;\n\tint i;\n\n\tif (enable) {\n\t\trsnd_mod_bset(adg_mod, BRGCKR, 0x80770000, adg->ckr);\n\t\trsnd_mod_write(adg_mod, BRRA,  adg->brga);\n\t\trsnd_mod_write(adg_mod, BRRB,  adg->brgb);\n\t}\n\n\tfor_each_rsnd_clkin(clk, adg, i) {\n\t\tif (enable) {\n\t\t\tclk_prepare_enable(clk);\n\n\t\t\t \n\t\t\tadg->clkin_rate[i] = clk_get_rate(clk);\n\t\t} else {\n\t\t\tclk_disable_unprepare(clk);\n\t\t}\n\t}\n}\n\nstatic struct clk *rsnd_adg_create_null_clk(struct rsnd_priv *priv,\n\t\t\t\t\t    const char * const name,\n\t\t\t\t\t    const char *parent)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct clk *clk;\n\n\tclk = clk_register_fixed_rate(dev, name, parent, 0, 0);\n\tif (IS_ERR_OR_NULL(clk)) {\n\t\tdev_err(dev, \"create null clk error\\n\");\n\t\treturn ERR_CAST(clk);\n\t}\n\n\treturn clk;\n}\n\nstatic struct clk *rsnd_adg_null_clk_get(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg = priv->adg;\n\n\tif (!adg->null_clk) {\n\t\tstatic const char * const name = \"rsnd_adg_null\";\n\n\t\tadg->null_clk = rsnd_adg_create_null_clk(priv, name, NULL);\n\t}\n\n\treturn adg->null_clk;\n}\n\nstatic void rsnd_adg_null_clk_clean(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg = priv->adg;\n\n\tif (adg->null_clk)\n\t\tclk_unregister_fixed_rate(adg->null_clk);\n}\n\nstatic int rsnd_adg_get_clkin(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg = priv->adg;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct clk *clk;\n\tconst char * const *clkin_name;\n\tint clkin_size;\n\tint i;\n\n\tclkin_name = clkin_name_gen2;\n\tclkin_size = ARRAY_SIZE(clkin_name_gen2);\n\tif (rsnd_is_gen4(priv)) {\n\t\tclkin_name = clkin_name_gen4;\n\t\tclkin_size = ARRAY_SIZE(clkin_name_gen4);\n\t}\n\n\tfor (i = 0; i < clkin_size; i++) {\n\t\tclk = devm_clk_get(dev, clkin_name[i]);\n\n\t\tif (IS_ERR_OR_NULL(clk))\n\t\t\tclk = rsnd_adg_null_clk_get(priv);\n\t\tif (IS_ERR_OR_NULL(clk))\n\t\t\tgoto err;\n\n\t\tadg->clkin[i] = clk;\n\t}\n\n\tadg->clkin_size = clkin_size;\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"adg clock IN get failed\\n\");\n\n\trsnd_adg_null_clk_clean(priv);\n\n\treturn -EIO;\n}\n\nstatic void rsnd_adg_unregister_clkout(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg = priv->adg;\n\tstruct clk *clk;\n\tint i;\n\n\tfor_each_rsnd_clkout(clk, adg, i)\n\t\tclk_unregister_fixed_rate(clk);\n}\n\nstatic int rsnd_adg_get_clkout(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg = priv->adg;\n\tstruct clk *clk;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\tstruct property *prop;\n\tu32 ckr, brgx, brga, brgb;\n\tu32 req_rate[ADG_HZ_SIZE] = {};\n\tuint32_t count = 0;\n\tunsigned long req_Hz[ADG_HZ_SIZE];\n\tint clkout_size;\n\tint i, req_size;\n\tint approximate = 0;\n\tconst char *parent_clk_name = NULL;\n\tconst char * const *clkout_name;\n\tint brg_table[] = {\n\t\t[CLKA] = 0x0,\n\t\t[CLKB] = 0x1,\n\t\t[CLKC] = 0x4,\n\t\t[CLKI] = 0x2,\n\t};\n\n\tckr = 0;\n\tbrga = 0xff;  \n\tbrgb = 0xff;  \n\n\t \n\tprop = of_find_property(np, \"clock-frequency\", NULL);\n\tif (!prop)\n\t\tgoto rsnd_adg_get_clkout_end;\n\n\treq_size = prop->length / sizeof(u32);\n\tif (req_size > ADG_HZ_SIZE) {\n\t\tdev_err(dev, \"too many clock-frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32_array(np, \"clock-frequency\", req_rate, req_size);\n\treq_Hz[ADG_HZ_48]  = 0;\n\treq_Hz[ADG_HZ_441] = 0;\n\tfor (i = 0; i < req_size; i++) {\n\t\tif (0 == (req_rate[i] % 44100))\n\t\t\treq_Hz[ADG_HZ_441] = req_rate[i];\n\t\tif (0 == (req_rate[i] % 48000))\n\t\t\treq_Hz[ADG_HZ_48] = req_rate[i];\n\t}\n\n\t \n\n\t \n\tfor_each_rsnd_clkin(clk, adg, i) {\n\t\tu32 rate, div;\n\n\t\trate = clk_get_rate(clk);\n\n\t\tif (0 == rate)  \n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (i == CLKI)\n\t\t\t \n\t\t\trate = (clk_get_rate(clk) / req_Hz[ADG_HZ_441]) * req_Hz[ADG_HZ_441];\n\t\tif (!adg->brg_rate[ADG_HZ_441] && req_Hz[ADG_HZ_441] && (0 == rate % 44100)) {\n\t\t\tdiv = rate / req_Hz[ADG_HZ_441];\n\t\t\tbrgx = rsnd_adg_calculate_brgx(div);\n\t\t\tif (BRRx_MASK(brgx) == brgx) {\n\t\t\t\tbrga = brgx;\n\t\t\t\tadg->brg_rate[ADG_HZ_441] = rate / div;\n\t\t\t\tckr |= brg_table[i] << 20;\n\t\t\t\tif (req_Hz[ADG_HZ_441])\n\t\t\t\t\tparent_clk_name = __clk_get_name(clk);\n\t\t\t\tif (i == CLKI)\n\t\t\t\t\tapproximate = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (i == CLKI)\n\t\t\t \n\t\t\trate = (clk_get_rate(clk) / req_Hz[ADG_HZ_48]) * req_Hz[ADG_HZ_48];\n\t\tif (!adg->brg_rate[ADG_HZ_48] && req_Hz[ADG_HZ_48] && (0 == rate % 48000)) {\n\t\t\tdiv = rate / req_Hz[ADG_HZ_48];\n\t\t\tbrgx = rsnd_adg_calculate_brgx(div);\n\t\t\tif (BRRx_MASK(brgx) == brgx) {\n\t\t\t\tbrgb = brgx;\n\t\t\t\tadg->brg_rate[ADG_HZ_48] = rate / div;\n\t\t\t\tckr |= brg_table[i] << 16;\n\t\t\t\tif (req_Hz[ADG_HZ_48])\n\t\t\t\t\tparent_clk_name = __clk_get_name(clk);\n\t\t\t\tif (i == CLKI)\n\t\t\t\t\tapproximate = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(adg->brg_rate[ADG_HZ_48]  && req_Hz[ADG_HZ_48]) &&\n\t    !(adg->brg_rate[ADG_HZ_441] && req_Hz[ADG_HZ_441]))\n\t\tgoto rsnd_adg_get_clkout_end;\n\n\tif (approximate)\n\t\tdev_info(dev, \"It uses CLK_I as approximate rate\");\n\n\tclkout_name = clkout_name_gen2;\n\tclkout_size = ARRAY_SIZE(clkout_name_gen2);\n\tif (rsnd_is_gen4(priv))\n\t\tclkout_size = 1;  \n\n\t \n\n\tof_property_read_u32(np, \"#clock-cells\", &count);\n\t \n\tif (!count) {\n\t\tclk = clk_register_fixed_rate(dev, clkout_name[CLKOUT],\n\t\t\t\t\t      parent_clk_name, 0, req_rate[0]);\n\t\tif (IS_ERR_OR_NULL(clk))\n\t\t\tgoto err;\n\n\t\tadg->clkout[CLKOUT] = clk;\n\t\tadg->clkout_size = 1;\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\t}\n\t \n\telse {\n\t\tfor (i = 0; i < clkout_size; i++) {\n\t\t\tclk = clk_register_fixed_rate(dev, clkout_name[i],\n\t\t\t\t\t\t      parent_clk_name, 0,\n\t\t\t\t\t\t      req_rate[0]);\n\t\t\tif (IS_ERR_OR_NULL(clk))\n\t\t\t\tgoto err;\n\n\t\t\tadg->clkout[i] = clk;\n\t\t}\n\t\tadg->onecell.clks\t= adg->clkout;\n\t\tadg->onecell.clk_num\t= clkout_size;\n\t\tadg->clkout_size\t= clkout_size;\n\t\tof_clk_add_provider(np, of_clk_src_onecell_get,\n\t\t\t\t    &adg->onecell);\n\t}\n\nrsnd_adg_get_clkout_end:\n\tadg->ckr = ckr;\n\tadg->brga = brga;\n\tadg->brgb = brgb;\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"adg clock OUT get failed\\n\");\n\n\trsnd_adg_unregister_clkout(priv);\n\n\treturn -EIO;\n}\n\n#if defined(DEBUG) || defined(CONFIG_DEBUG_FS)\n__printf(3, 4)\nstatic void dbg_msg(struct device *dev, struct seq_file *m,\n\t\t\t\t   const char *fmt, ...)\n{\n\tchar msg[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(msg, sizeof(msg), fmt, args);\n\tva_end(args);\n\n\tif (m)\n\t\tseq_puts(m, msg);\n\telse\n\t\tdev_dbg(dev, \"%s\", msg);\n}\n\nvoid rsnd_adg_clk_dbg_info(struct rsnd_priv *priv, struct seq_file *m)\n{\n\tstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct clk *clk;\n\tint i;\n\n\tfor_each_rsnd_clkin(clk, adg, i)\n\t\tdbg_msg(dev, m, \"%-18s : %pa : %ld\\n\",\n\t\t\t__clk_get_name(clk), clk, clk_get_rate(clk));\n\n\tdbg_msg(dev, m, \"BRGCKR = 0x%08x, BRRA/BRRB = 0x%x/0x%x\\n\",\n\t\tadg->ckr, adg->brga, adg->brgb);\n\tdbg_msg(dev, m, \"BRGA (for 44100 base) = %d\\n\", adg->brg_rate[ADG_HZ_441]);\n\tdbg_msg(dev, m, \"BRGB (for 48000 base) = %d\\n\", adg->brg_rate[ADG_HZ_48]);\n\n\t \n\tfor_each_rsnd_clkout(clk, adg, i)\n\t\tdbg_msg(dev, m, \"%-18s : %pa : %ld\\n\",\n\t\t\t__clk_get_name(clk), clk, clk_get_rate(clk));\n}\n#else\n#define rsnd_adg_clk_dbg_info(priv, m)\n#endif\n\nint rsnd_adg_probe(struct rsnd_priv *priv)\n{\n\tstruct rsnd_adg *adg;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint ret;\n\n\tadg = devm_kzalloc(dev, sizeof(*adg), GFP_KERNEL);\n\tif (!adg)\n\t\treturn -ENOMEM;\n\n\tret = rsnd_mod_init(priv, &adg->mod, &adg_ops,\n\t\t      NULL, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->adg = adg;\n\n\tret = rsnd_adg_get_clkin(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsnd_adg_get_clkout(priv);\n\tif (ret)\n\t\treturn ret;\n\n\trsnd_adg_clk_enable(priv);\n\trsnd_adg_clk_dbg_info(priv, NULL);\n\n\treturn 0;\n}\n\nvoid rsnd_adg_remove(struct rsnd_priv *priv)\n{\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct device_node *np = dev->of_node;\n\n\trsnd_adg_unregister_clkout(priv);\n\n\tof_clk_del_provider(np);\n\n\trsnd_adg_clk_disable(priv);\n\n\t \n\trsnd_adg_null_clk_clean(priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}