{
  "module_name": "dma.c",
  "hash_id": "5a495dbe9c59c004fa9749d0bdb7279af2fc2c27886f7f2eb11100b24fc8c841",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/of_dma.h>\n#include \"rsnd.h\"\n\n \n#define PDMASAR\t\t0x00\n#define PDMADAR\t\t0x04\n#define PDMACHCR\t0x0c\n\n \n#define PDMACHCR_DE\t\t(1 << 0)\n\n\nstruct rsnd_dmaen {\n\tstruct dma_chan\t\t*chan;\n\tdma_cookie_t\t\tcookie;\n\tunsigned int\t\tdma_len;\n};\n\nstruct rsnd_dmapp {\n\tint\t\t\tdmapp_id;\n\tu32\t\t\tchcr;\n};\n\nstruct rsnd_dma {\n\tstruct rsnd_mod\t\tmod;\n\tstruct rsnd_mod\t\t*mod_from;\n\tstruct rsnd_mod\t\t*mod_to;\n\tdma_addr_t\t\tsrc_addr;\n\tdma_addr_t\t\tdst_addr;\n\tunion {\n\t\tstruct rsnd_dmaen en;\n\t\tstruct rsnd_dmapp pp;\n\t} dma;\n};\n\nstruct rsnd_dma_ctrl {\n\tvoid __iomem *ppbase;\n\tphys_addr_t ppres;\n\tint dmaen_num;\n\tint dmapp_num;\n};\n\n#define rsnd_priv_to_dmac(p)\t((struct rsnd_dma_ctrl *)(p)->dma)\n#define rsnd_mod_to_dma(_mod) container_of((_mod), struct rsnd_dma, mod)\n#define rsnd_dma_to_dmaen(dma)\t(&(dma)->dma.en)\n#define rsnd_dma_to_dmapp(dma)\t(&(dma)->dma.pp)\n\n \nstatic struct rsnd_mod_ops mem_ops = {\n\t.name = \"mem\",\n};\n\nstatic struct rsnd_mod mem = {\n};\n\n \nstatic void __rsnd_dmaen_complete(struct rsnd_mod *mod,\n\t\t\t\t  struct rsnd_dai_stream *io)\n{\n\tif (rsnd_io_is_working(io))\n\t\trsnd_dai_period_elapsed(io);\n}\n\nstatic void rsnd_dmaen_complete(void *data)\n{\n\tstruct rsnd_mod *mod = data;\n\n\trsnd_mod_interrupt(mod, __rsnd_dmaen_complete);\n}\n\nstatic struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,\n\t\t\t\t\t\t   struct rsnd_mod *mod_from,\n\t\t\t\t\t\t   struct rsnd_mod *mod_to)\n{\n\tif ((!mod_from && !mod_to) ||\n\t    (mod_from && mod_to))\n\t\treturn NULL;\n\n\tif (mod_from)\n\t\treturn rsnd_mod_dma_req(io, mod_from);\n\telse\n\t\treturn rsnd_mod_dma_req(io, mod_to);\n}\n\nstatic int rsnd_dmaen_stop(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);\n\n\tif (dmaen->chan)\n\t\tdmaengine_terminate_async(dmaen->chan);\n\n\treturn 0;\n}\n\nstatic int rsnd_dmaen_cleanup(struct rsnd_mod *mod,\n\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t      struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);\n\n\t \n\tif (dmaen->chan)\n\t\tdma_release_channel(dmaen->chan);\n\n\tdmaen->chan = NULL;\n\n\treturn 0;\n}\n\nstatic int rsnd_dmaen_prepare(struct rsnd_mod *mod,\n\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t      struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t \n\tif (dmaen->chan)\n\t\treturn 0;\n\n\t \n\tdmaen->chan = rsnd_dmaen_request_channel(io,\n\t\t\t\t\t\t dma->mod_from,\n\t\t\t\t\t\t dma->mod_to);\n\tif (IS_ERR_OR_NULL(dmaen->chan)) {\n\t\tdmaen->chan = NULL;\n\t\tdev_err(dev, \"can't get dma channel\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsnd_dmaen_start(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);\n\tstruct snd_pcm_substream *substream = io->substream;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_slave_config cfg = {};\n\tenum dma_slave_buswidth buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tint is_play = rsnd_io_is_play(io);\n\tint ret;\n\n\t \n\tif (rsnd_runtime_channel_original(io) == 1) {\n\t\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\t\tint bits = snd_pcm_format_physical_width(runtime->format);\n\n\t\tswitch (bits) {\n\t\tcase 8:\n\t\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid format width %d\\n\", bits);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcfg.direction\t= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\n\tcfg.src_addr\t= dma->src_addr;\n\tcfg.dst_addr\t= dma->dst_addr;\n\tcfg.src_addr_width = buswidth;\n\tcfg.dst_addr_width = buswidth;\n\n\tdev_dbg(dev, \"%s %pad -> %pad\\n\",\n\t\trsnd_mod_name(mod),\n\t\t&cfg.src_addr, &cfg.dst_addr);\n\n\tret = dmaengine_slave_config(dmaen->chan, &cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdesc = dmaengine_prep_dma_cyclic(dmaen->chan,\n\t\t\t\t\t substream->runtime->dma_addr,\n\t\t\t\t\t snd_pcm_lib_buffer_bytes(substream),\n\t\t\t\t\t snd_pcm_lib_period_bytes(substream),\n\t\t\t\t\t is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!desc) {\n\t\tdev_err(dev, \"dmaengine_prep_slave_sg() fail\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdesc->callback\t\t= rsnd_dmaen_complete;\n\tdesc->callback_param\t= rsnd_mod_get(dma);\n\n\tdmaen->dma_len\t\t= snd_pcm_lib_buffer_bytes(substream);\n\n\tdmaen->cookie = dmaengine_submit(desc);\n\tif (dmaen->cookie < 0) {\n\t\tdev_err(dev, \"dmaengine_submit() fail\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma_async_issue_pending(dmaen->chan);\n\n\treturn 0;\n}\n\nstruct dma_chan *rsnd_dma_request_channel(struct device_node *of_node, char *name,\n\t\t\t\t\t  struct rsnd_mod *mod, char *x)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct dma_chan *chan = NULL;\n\tstruct device_node *np;\n\tint i = 0;\n\n\tfor_each_child_of_node(of_node, np) {\n\t\ti = rsnd_node_fixed_index(dev, np, name, i);\n\t\tif (i < 0) {\n\t\t\tchan = NULL;\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == rsnd_mod_id_raw(mod) && (!chan))\n\t\t\tchan = of_dma_request_slave_channel(np, x);\n\t\ti++;\n\t}\n\n\t \n\tof_node_put(of_node);\n\n\treturn chan;\n}\n\nstatic int rsnd_dmaen_attach(struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_dma *dma,\n\t\t\t   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tstruct dma_chan *chan;\n\n\t \n\tchan = rsnd_dmaen_request_channel(io, mod_from, mod_to);\n\tif (IS_ERR_OR_NULL(chan)) {\n\t\t \n\t\tif (PTR_ERR(chan) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(chan);\n\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tio->dmac_dev = chan->device->dev;\n\n\tdma_release_channel(chan);\n\n\tdmac->dmaen_num++;\n\n\treturn 0;\n}\n\nstatic int rsnd_dmaen_pointer(struct rsnd_mod *mod,\n\t\t\t      struct rsnd_dai_stream *io,\n\t\t\t      snd_pcm_uframes_t *pointer)\n{\n\tstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tunsigned int pos = 0;\n\n\tstatus = dmaengine_tx_status(dmaen->chan, dmaen->cookie, &state);\n\tif (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {\n\t\tif (state.residue > 0 && state.residue <= dmaen->dma_len)\n\t\t\tpos = dmaen->dma_len - state.residue;\n\t}\n\t*pointer = bytes_to_frames(runtime, pos);\n\n\treturn 0;\n}\n\nstatic struct rsnd_mod_ops rsnd_dmaen_ops = {\n\t.name\t\t= \"audmac\",\n\t.prepare\t= rsnd_dmaen_prepare,\n\t.cleanup\t= rsnd_dmaen_cleanup,\n\t.start\t\t= rsnd_dmaen_start,\n\t.stop\t\t= rsnd_dmaen_stop,\n\t.pointer\t= rsnd_dmaen_pointer,\n\t.get_status\t= rsnd_mod_get_status,\n};\n\n \nstatic const u8 gen2_id_table_ssiu[] = {\n\t \n\t0x00, 0x01, 0x02, 0x03, 0x39, 0x3a, 0x3b, 0x3c,\n\t \n\t0x04, 0x05, 0x06, 0x07, 0x3d, 0x3e, 0x3f, 0x40,\n\t \n\t0x08, 0x09, 0x0a, 0x0b, 0x41, 0x42, 0x43, 0x44,\n\t \n\t0x0c, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n\t \n\t0x0d, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,\n\t \n\t0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x12, 0x13, 0x14, 0x15, 0x53, 0x54, 0x55, 0x56,\n};\nstatic const u8 gen2_id_table_scu[] = {\n\t0x2d,  \n\t0x2e,  \n\t0x2f,  \n\t0x30,  \n\t0x31,  \n\t0x32,  \n\t0x33,  \n\t0x34,  \n\t0x35,  \n\t0x36,  \n};\nstatic const u8 gen2_id_table_cmd[] = {\n\t0x37,  \n\t0x38,  \n};\n\nstatic u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,\n\t\t\t     struct rsnd_mod *mod)\n{\n\tstruct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);\n\tstruct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);\n\tstruct rsnd_mod *src = rsnd_io_to_mod_src(io);\n\tstruct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);\n\tconst u8 *entry = NULL;\n\tint id = 255;\n\tint size = 0;\n\n\tif ((mod == ssi) ||\n\t    (mod == ssiu)) {\n\t\tint busif = rsnd_mod_id_sub(ssiu);\n\n\t\tentry = gen2_id_table_ssiu;\n\t\tsize = ARRAY_SIZE(gen2_id_table_ssiu);\n\t\tid = (rsnd_mod_id(mod) * 8) + busif;\n\t} else if (mod == src) {\n\t\tentry = gen2_id_table_scu;\n\t\tsize = ARRAY_SIZE(gen2_id_table_scu);\n\t\tid = rsnd_mod_id(mod);\n\t} else if (mod == dvc) {\n\t\tentry = gen2_id_table_cmd;\n\t\tsize = ARRAY_SIZE(gen2_id_table_cmd);\n\t\tid = rsnd_mod_id(mod);\n\t}\n\n\tif ((!entry) || (size <= id)) {\n\t\tstruct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));\n\n\t\tdev_err(dev, \"unknown connection (%s)\\n\", rsnd_mod_name(mod));\n\n\t\t \n\t\treturn 0x00;  \n\t}\n\n\treturn entry[id];\n}\n\nstatic u32 rsnd_dmapp_get_chcr(struct rsnd_dai_stream *io,\n\t\t\t       struct rsnd_mod *mod_from,\n\t\t\t       struct rsnd_mod *mod_to)\n{\n\treturn\t(rsnd_dmapp_get_id(io, mod_from) << 24) +\n\t\t(rsnd_dmapp_get_id(io, mod_to) << 16);\n}\n\n#define rsnd_dmapp_addr(dmac, dma, reg) \\\n\t(dmac->ppbase + 0x20 + reg + \\\n\t (0x10 * rsnd_dma_to_dmapp(dma)->dmapp_id))\nstatic void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)\n{\n\tstruct rsnd_mod *mod = rsnd_mod_get(dma);\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tdev_dbg(dev, \"w 0x%px : %08x\\n\", rsnd_dmapp_addr(dmac, dma, reg), data);\n\n\tiowrite32(data, rsnd_dmapp_addr(dmac, dma, reg));\n}\n\nstatic u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)\n{\n\tstruct rsnd_mod *mod = rsnd_mod_get(dma);\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\n\treturn ioread32(rsnd_dmapp_addr(dmac, dma, reg));\n}\n\nstatic void rsnd_dmapp_bset(struct rsnd_dma *dma, u32 data, u32 mask, u32 reg)\n{\n\tstruct rsnd_mod *mod = rsnd_mod_get(dma);\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tvoid __iomem *addr = rsnd_dmapp_addr(dmac, dma, reg);\n\tu32 val = ioread32(addr);\n\n\tval &= ~mask;\n\tval |= (data & mask);\n\n\tiowrite32(val, addr);\n}\n\nstatic int rsnd_dmapp_stop(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tint i;\n\n\trsnd_dmapp_bset(dma, 0,  PDMACHCR_DE, PDMACHCR);\n\n\tfor (i = 0; i < 1024; i++) {\n\t\tif (0 == (rsnd_dmapp_read(dma, PDMACHCR) & PDMACHCR_DE))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int rsnd_dmapp_start(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct rsnd_priv *priv)\n{\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);\n\n\trsnd_dmapp_write(dma, dma->src_addr,\tPDMASAR);\n\trsnd_dmapp_write(dma, dma->dst_addr,\tPDMADAR);\n\trsnd_dmapp_write(dma, dmapp->chcr,\tPDMACHCR);\n\n\treturn 0;\n}\n\nstatic int rsnd_dmapp_attach(struct rsnd_dai_stream *io,\n\t\t\t     struct rsnd_dma *dma,\n\t\t\t     struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)\n{\n\tstruct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\tdmapp->dmapp_id = dmac->dmapp_num;\n\tdmapp->chcr = rsnd_dmapp_get_chcr(io, mod_from, mod_to) | PDMACHCR_DE;\n\n\tdmac->dmapp_num++;\n\n\tdev_dbg(dev, \"id/src/dst/chcr = %d/%pad/%pad/%08x\\n\",\n\t\tdmapp->dmapp_id, &dma->src_addr, &dma->dst_addr, dmapp->chcr);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_dmapp_debug_info(struct seq_file *m,\n\t\t\t\t  struct rsnd_dai_stream *io,\n\t\t\t\t  struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tstruct rsnd_dma *dma = rsnd_mod_to_dma(mod);\n\tstruct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);\n\n\trsnd_debugfs_reg_show(m, dmac->ppres, dmac->ppbase,\n\t\t\t      0x20 + 0x10 * dmapp->dmapp_id, 0x10);\n}\n#define DEBUG_INFO .debug_info = rsnd_dmapp_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_dmapp_ops = {\n\t.name\t\t= \"audmac-pp\",\n\t.start\t\t= rsnd_dmapp_start,\n\t.stop\t\t= rsnd_dmapp_stop,\n\t.quit\t\t= rsnd_dmapp_stop,\n\t.get_status\t= rsnd_mod_get_status,\n\tDEBUG_INFO\n};\n\n \n\n \n#define RDMA_SSI_I_N(addr, i)\t(addr ##_reg - 0x00300000 + (0x40 * i) + 0x8)\n#define RDMA_SSI_O_N(addr, i)\t(addr ##_reg - 0x00300000 + (0x40 * i) + 0xc)\n\n#define RDMA_SSIU_I_N(addr, i, j) (addr ##_reg - 0x00441000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400) - (0x4000 * ((i) / 9) * ((j) / 4)))\n#define RDMA_SSIU_O_N(addr, i, j) RDMA_SSIU_I_N(addr, i, j)\n\n#define RDMA_SSIU_I_P(addr, i, j) (addr ##_reg - 0x00141000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400) - (0x4000 * ((i) / 9) * ((j) / 4)))\n#define RDMA_SSIU_O_P(addr, i, j) RDMA_SSIU_I_P(addr, i, j)\n\n#define RDMA_SRC_I_N(addr, i)\t(addr ##_reg - 0x00500000 + (0x400 * i))\n#define RDMA_SRC_O_N(addr, i)\t(addr ##_reg - 0x004fc000 + (0x400 * i))\n\n#define RDMA_SRC_I_P(addr, i)\t(addr ##_reg - 0x00200000 + (0x400 * i))\n#define RDMA_SRC_O_P(addr, i)\t(addr ##_reg - 0x001fc000 + (0x400 * i))\n\n#define RDMA_CMD_O_N(addr, i)\t(addr ##_reg - 0x004f8000 + (0x400 * i))\n#define RDMA_CMD_O_P(addr, i)\t(addr ##_reg - 0x001f8000 + (0x400 * i))\n\nstatic dma_addr_t\nrsnd_gen2_dma_addr(struct rsnd_dai_stream *io,\n\t\t   struct rsnd_mod *mod,\n\t\t   int is_play, int is_from)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tphys_addr_t ssi_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SSI);\n\tphys_addr_t src_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SCU);\n\tint is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod) ||\n\t\t     !!(rsnd_io_to_mod_ssiu(io) == mod);\n\tint use_src = !!rsnd_io_to_mod_src(io);\n\tint use_cmd = !!rsnd_io_to_mod_dvc(io) ||\n\t\t      !!rsnd_io_to_mod_mix(io) ||\n\t\t      !!rsnd_io_to_mod_ctu(io);\n\tint id = rsnd_mod_id(mod);\n\tint busif = rsnd_mod_id_sub(rsnd_io_to_mod_ssiu(io));\n\tstruct dma_addr {\n\t\tdma_addr_t out_addr;\n\t\tdma_addr_t in_addr;\n\t} dma_addrs[3][2][3] = {\n\t\t \n\t\t \n\t\t{{{ 0,\t\t\t\t0 },\n\t\t  { RDMA_SRC_O_N(src, id),\tRDMA_SRC_I_P(src, id) },\n\t\t  { RDMA_CMD_O_N(src, id),\tRDMA_SRC_I_P(src, id) } },\n\t\t  \n\t\t {{ 0,\t\t\t\t0, },\n\t\t  { RDMA_SRC_O_P(src, id),\tRDMA_SRC_I_N(src, id) },\n\t\t  { RDMA_CMD_O_P(src, id),\tRDMA_SRC_I_N(src, id) } }\n\t\t},\n\t\t \n\t\t \n\t\t{{{ RDMA_SSI_O_N(ssi, id),\t\t0 },\n\t\t  { RDMA_SSIU_O_P(ssi, id, busif),\t0 },\n\t\t  { RDMA_SSIU_O_P(ssi, id, busif),\t0 } },\n\t\t  \n\t\t {{ 0,\t\t\tRDMA_SSI_I_N(ssi, id) },\n\t\t  { 0,\t\t\tRDMA_SSIU_I_P(ssi, id, busif) },\n\t\t  { 0,\t\t\tRDMA_SSIU_I_P(ssi, id, busif) } }\n\t\t},\n\t\t \n\t\t \n\t\t{{{ RDMA_SSIU_O_N(ssi, id, busif),\t0 },\n\t\t  { RDMA_SSIU_O_P(ssi, id, busif),\t0 },\n\t\t  { RDMA_SSIU_O_P(ssi, id, busif),\t0 } },\n\t\t  \n\t\t {{ 0,\t\t\tRDMA_SSIU_I_N(ssi, id, busif) },\n\t\t  { 0,\t\t\tRDMA_SSIU_I_P(ssi, id, busif) },\n\t\t  { 0,\t\t\tRDMA_SSIU_I_P(ssi, id, busif) } } },\n\t};\n\n\t \n\tif ((id == 9) && (busif >= 4))\n\t\tdev_err(dev, \"This driver doesn't support SSI%d-%d, so far\",\n\t\t\tid, busif);\n\n\t \n\tif (use_cmd && !use_src)\n\t\tdev_err(dev, \"DVC is selected without SRC\\n\");\n\n\t \n\tif (is_ssi && rsnd_ssi_use_busif(io))\n\t\tis_ssi++;\n\n\treturn (is_from) ?\n\t\tdma_addrs[is_ssi][is_play][use_src + use_cmd].out_addr :\n\t\tdma_addrs[is_ssi][is_play][use_src + use_cmd].in_addr;\n}\n\n \n#define RDMA_SSI_SDMC(addr, i)\t(addr + (0x8000 * i))\nstatic dma_addr_t\nrsnd_gen4_dma_addr(struct rsnd_dai_stream *io, struct rsnd_mod *mod,\n\t\t   int is_play, int is_from)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tphys_addr_t addr = rsnd_gen_get_phy_addr(priv, RSND_GEN4_SDMC);\n\tint id = rsnd_mod_id(mod);\n\tint busif = rsnd_mod_id_sub(mod);\n\n\t \n\tif (id != 0) {\n\t\tstruct device *dev = rsnd_priv_to_dev(priv);\n\n\t\tdev_err(dev, \"This driver doesn't support non SSI0\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn RDMA_SSI_SDMC(addr, busif);\n}\n\nstatic dma_addr_t rsnd_dma_addr(struct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod,\n\t\t\t\tint is_play, int is_from)\n{\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\n\tif (!mod)\n\t\treturn 0;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\telse if (rsnd_is_gen4(priv))\n\t\treturn rsnd_gen4_dma_addr(io, mod, is_play, is_from);\n\telse\n\t\treturn rsnd_gen2_dma_addr(io, mod, is_play, is_from);\n}\n\n#define MOD_MAX (RSND_MOD_MAX + 1)  \nstatic void rsnd_dma_of_path(struct rsnd_mod *this,\n\t\t\t     struct rsnd_dai_stream *io,\n\t\t\t     int is_play,\n\t\t\t     struct rsnd_mod **mod_from,\n\t\t\t     struct rsnd_mod **mod_to)\n{\n\tstruct rsnd_mod *ssi;\n\tstruct rsnd_mod *src = rsnd_io_to_mod_src(io);\n\tstruct rsnd_mod *ctu = rsnd_io_to_mod_ctu(io);\n\tstruct rsnd_mod *mix = rsnd_io_to_mod_mix(io);\n\tstruct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);\n\tstruct rsnd_mod *mod[MOD_MAX];\n\tstruct rsnd_mod *mod_start, *mod_end;\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(this);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tint nr, i, idx;\n\n\t \n\tif (rsnd_ssiu_of_node(priv)) {\n\t\tstruct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);\n\n\t\t \n\t\tssi = ssiu;\n\t\tif (this == rsnd_io_to_mod_ssi(io))\n\t\t\tthis = ssiu;\n\t} else {\n\t\t \n\t\tssi = rsnd_io_to_mod_ssi(io);\n\t}\n\n\tif (!ssi)\n\t\treturn;\n\n\tnr = 0;\n\tfor (i = 0; i < MOD_MAX; i++) {\n\t\tmod[i] = NULL;\n\t\tnr += !!rsnd_io_to_mod(io, i);\n\t}\n\n\t \n\tmod_start\t= (is_play) ? NULL : ssi;\n\tmod_end\t\t= (is_play) ? ssi  : NULL;\n\n\tidx = 0;\n\tmod[idx++] = mod_start;\n\tfor (i = 1; i < nr; i++) {\n\t\tif (src) {\n\t\t\tmod[idx++] = src;\n\t\t\tsrc = NULL;\n\t\t} else if (ctu) {\n\t\t\tmod[idx++] = ctu;\n\t\t\tctu = NULL;\n\t\t} else if (mix) {\n\t\t\tmod[idx++] = mix;\n\t\t\tmix = NULL;\n\t\t} else if (dvc) {\n\t\t\tmod[idx++] = dvc;\n\t\t\tdvc = NULL;\n\t\t}\n\t}\n\tmod[idx] = mod_end;\n\n\t \n\tif ((this == ssi) == (is_play)) {\n\t\t*mod_from\t= mod[idx - 1];\n\t\t*mod_to\t\t= mod[idx];\n\t} else {\n\t\t*mod_from\t= mod[0];\n\t\t*mod_to\t\t= mod[1];\n\t}\n\n\tdev_dbg(dev, \"module connection (this is %s)\\n\", rsnd_mod_name(this));\n\tfor (i = 0; i <= idx; i++) {\n\t\tdev_dbg(dev, \"  %s%s\\n\",\n\t\t\trsnd_mod_name(mod[i] ? mod[i] : &mem),\n\t\t\t(mod[i] == *mod_from) ? \" from\" :\n\t\t\t(mod[i] == *mod_to)   ? \" to\" : \"\");\n\t}\n}\n\nstatic int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,\n\t\t\t  struct rsnd_mod **dma_mod)\n{\n\tstruct rsnd_mod *mod_from = NULL;\n\tstruct rsnd_mod *mod_to = NULL;\n\tstruct rsnd_priv *priv = rsnd_io_to_priv(io);\n\tstruct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_dma *dma;\n\tstruct rsnd_mod_ops *ops;\n\tenum rsnd_mod_type type;\n\tint (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma,\n\t\t      struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);\n\tint is_play = rsnd_io_is_play(io);\n\tint ret, dma_id;\n\n\t \n\tif (!dmac)\n\t\treturn -EAGAIN;\n\n\trsnd_dma_of_path(mod, io, is_play, &mod_from, &mod_to);\n\n\t \n\tif (mod_from && mod_to) {\n\t\tops\t= &rsnd_dmapp_ops;\n\t\tattach\t= rsnd_dmapp_attach;\n\t\tdma_id\t= dmac->dmapp_num;\n\t\ttype\t= RSND_MOD_AUDMAPP;\n\t} else {\n\t\tops\t= &rsnd_dmaen_ops;\n\t\tattach\t= rsnd_dmaen_attach;\n\t\tdma_id\t= dmac->dmaen_num;\n\t\ttype\t= RSND_MOD_AUDMA;\n\t}\n\n\t \n\tif (rsnd_is_gen1(priv)) {\n\t\tops\t= &rsnd_dmaen_ops;\n\t\tattach\t= rsnd_dmaen_attach;\n\t\tdma_id\t= dmac->dmaen_num;\n\t\ttype\t= RSND_MOD_AUDMA;\n\t}\n\n\tdma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn -ENOMEM;\n\n\t*dma_mod = rsnd_mod_get(dma);\n\n\tret = rsnd_mod_init(priv, *dma_mod, ops, NULL,\n\t\t\t    type, dma_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"%s %s -> %s\\n\",\n\t\trsnd_mod_name(*dma_mod),\n\t\trsnd_mod_name(mod_from ? mod_from : &mem),\n\t\trsnd_mod_name(mod_to   ? mod_to   : &mem));\n\n\tret = attach(io, dma, mod_from, mod_to);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);\n\tdma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);\n\tdma->mod_from = mod_from;\n\tdma->mod_to   = mod_to;\n\n\treturn 0;\n}\n\nint rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,\n\t\t    struct rsnd_mod **dma_mod)\n{\n\tif (!(*dma_mod)) {\n\t\tint ret = rsnd_dma_alloc(io, mod, dma_mod);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn rsnd_dai_connect(*dma_mod, io, (*dma_mod)->type);\n}\n\nint rsnd_dma_probe(struct rsnd_priv *priv)\n{\n\tstruct platform_device *pdev = rsnd_priv_to_pdev(priv);\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_dma_ctrl *dmac;\n\tstruct resource *res;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\t \n\tdmac = devm_kzalloc(dev, sizeof(*dmac), GFP_KERNEL);\n\tif (!dmac) {\n\t\tdev_err(dev, \"dma allocate failed\\n\");\n\t\treturn 0;  \n\t}\n\n\t \n\tif (rsnd_is_gen4(priv))\n\t\tgoto audmapp_end;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"audmapp\");\n\tif (!res) {\n\t\tdev_err(dev, \"lack of audmapp in DT\\n\");\n\t\treturn 0;  \n\t}\n\n\tdmac->dmapp_num = 0;\n\tdmac->ppres  = res->start;\n\tdmac->ppbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(dmac->ppbase))\n\t\treturn PTR_ERR(dmac->ppbase);\naudmapp_end:\n\tpriv->dma = dmac;\n\n\t \n\treturn rsnd_mod_init(NULL, &mem, &mem_ops, NULL, 0, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}