{
  "module_name": "dvc.c",
  "hash_id": "33bba059f010afbc2358f1a8018e7d61273de020ddda92fe18896577cf6850fc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rcar/dvc.c",
  "human_readable_source": "\n\n\n\n\n\n\n \n\n#include \"rsnd.h\"\n\n#define RSND_DVC_NAME_SIZE\t16\n\n#define DVC_NAME \"dvc\"\n\nstruct rsnd_dvc {\n\tstruct rsnd_mod mod;\n\tstruct rsnd_kctrl_cfg_m volume;\n\tstruct rsnd_kctrl_cfg_m mute;\n\tstruct rsnd_kctrl_cfg_s ren;\t \n\tstruct rsnd_kctrl_cfg_s rup;\t \n\tstruct rsnd_kctrl_cfg_s rdown;\t \n};\n\n#define rsnd_dvc_get(priv, id) ((struct rsnd_dvc *)(priv->dvc) + id)\n#define rsnd_dvc_nr(priv) ((priv)->dvc_nr)\n\n#define rsnd_mod_to_dvc(_mod)\t\\\n\tcontainer_of((_mod), struct rsnd_dvc, mod)\n\n#define for_each_rsnd_dvc(pos, priv, i)\t\t\t\t\\\n\tfor ((i) = 0;\t\t\t\t\t\t\\\n\t     ((i) < rsnd_dvc_nr(priv)) &&\t\t\t\\\n\t     ((pos) = (struct rsnd_dvc *)(priv)->dvc + i);\t\\\n\t     i++)\n\nstatic void rsnd_dvc_activation(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, DVC_SWRSR, 0);\n\trsnd_mod_write(mod, DVC_SWRSR, 1);\n}\n\nstatic void rsnd_dvc_halt(struct rsnd_mod *mod)\n{\n\trsnd_mod_write(mod, DVC_DVUIR, 1);\n\trsnd_mod_write(mod, DVC_SWRSR, 0);\n}\n\n#define rsnd_dvc_get_vrpdr(dvc) (rsnd_kctrl_vals(dvc->rup) << 8 | \\\n\t\t\t\t rsnd_kctrl_vals(dvc->rdown))\n#define rsnd_dvc_get_vrdbr(dvc) (0x3ff - (rsnd_kctrl_valm(dvc->volume, 0) >> 13))\n\nstatic void rsnd_dvc_volume_parameter(struct rsnd_dai_stream *io,\n\t\t\t\t\t      struct rsnd_mod *mod)\n{\n\tstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\n\tu32 val[RSND_MAX_CHANNELS];\n\tint i;\n\n\t \n\tif (rsnd_kctrl_vals(dvc->ren))\n\t\tfor (i = 0; i < RSND_MAX_CHANNELS; i++)\n\t\t\tval[i] = rsnd_kctrl_max(dvc->volume);\n\telse\n\t\tfor (i = 0; i < RSND_MAX_CHANNELS; i++)\n\t\t\tval[i] = rsnd_kctrl_valm(dvc->volume, i);\n\n\t \n\tfor (i = 0; i < RSND_MAX_CHANNELS; i++)\n\t\trsnd_mod_write(mod, DVC_VOLxR(i), val[i]);\n}\n\nstatic void rsnd_dvc_volume_init(struct rsnd_dai_stream *io,\n\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\n\tu32 adinr = 0;\n\tu32 dvucr = 0;\n\tu32 vrctr = 0;\n\tu32 vrpdr = 0;\n\tu32 vrdbr = 0;\n\n\tadinr = rsnd_get_adinr_bit(mod, io) |\n\t\trsnd_runtime_channel_after_ctu(io);\n\n\t \n\tdvucr |= 0x101;\n\n\t \n\tif (rsnd_kctrl_vals(dvc->ren)) {\n\t\tdvucr |= 0x10;\n\n\t\t \n\t\tvrctr = 0xff;\n\t\tvrpdr = rsnd_dvc_get_vrpdr(dvc);\n\t\tvrdbr = rsnd_dvc_get_vrdbr(dvc);\n\t}\n\n\t \n\trsnd_mod_write(mod, DVC_DVUIR, 1);\n\n\t \n\trsnd_mod_write(mod, DVC_ADINR, adinr);\n\trsnd_mod_write(mod, DVC_DVUCR, dvucr);\n\n\t \n\trsnd_mod_write(mod, DVC_VRCTR, vrctr);\n\trsnd_mod_write(mod, DVC_VRPDR, vrpdr);\n\trsnd_mod_write(mod, DVC_VRDBR, vrdbr);\n\n\t \n\trsnd_dvc_volume_parameter(io, mod);\n\n\t \n\trsnd_mod_write(mod, DVC_DVUIR, 0);\n}\n\nstatic void rsnd_dvc_volume_update(struct rsnd_dai_stream *io,\n\t\t\t\t   struct rsnd_mod *mod)\n{\n\tstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\n\tu32 zcmcr = 0;\n\tu32 vrpdr = 0;\n\tu32 vrdbr = 0;\n\tint i;\n\n\tfor (i = 0; i < rsnd_kctrl_size(dvc->mute); i++)\n\t\tzcmcr |= (!!rsnd_kctrl_valm(dvc->mute, i)) << i;\n\n\tif (rsnd_kctrl_vals(dvc->ren)) {\n\t\tvrpdr = rsnd_dvc_get_vrpdr(dvc);\n\t\tvrdbr = rsnd_dvc_get_vrdbr(dvc);\n\t}\n\n\t \n\trsnd_mod_write(mod, DVC_DVUER, 0);\n\n\t \n\trsnd_mod_write(mod, DVC_ZCMCR, zcmcr);\n\n\t \n\trsnd_mod_write(mod, DVC_VRPDR, vrpdr);\n\trsnd_mod_write(mod, DVC_VRDBR, vrdbr);\n\t \n\n\t \n\trsnd_dvc_volume_parameter(io, mod);\n\n\t \n\trsnd_mod_write(mod, DVC_DVUER, 1);\n}\n\nstatic int rsnd_dvc_probe_(struct rsnd_mod *mod,\n\t\t\t   struct rsnd_dai_stream *io,\n\t\t\t   struct rsnd_priv *priv)\n{\n\treturn rsnd_cmd_attach(io, rsnd_mod_id(mod));\n}\n\nstatic int rsnd_dvc_init(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\tint ret;\n\n\tret = rsnd_mod_power_on(mod);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trsnd_dvc_activation(mod);\n\n\trsnd_dvc_volume_init(io, mod);\n\n\trsnd_dvc_volume_update(io, mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_dvc_quit(struct rsnd_mod *mod,\n\t\t\t struct rsnd_dai_stream *io,\n\t\t\t struct rsnd_priv *priv)\n{\n\trsnd_dvc_halt(mod);\n\n\trsnd_mod_power_off(mod);\n\n\treturn 0;\n}\n\nstatic int rsnd_dvc_pcm_new(struct rsnd_mod *mod,\n\t\t\t    struct rsnd_dai_stream *io,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\n\tstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\n\tint is_play = rsnd_io_is_play(io);\n\tint channels = rsnd_rdai_channels_get(rdai);\n\tint ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd,\n\t\t\tis_play ?\n\t\t\t\"DVC Out Playback Volume\" : \"DVC In Capture Volume\",\n\t\t\trsnd_kctrl_accept_anytime,\n\t\t\trsnd_dvc_volume_update,\n\t\t\t&dvc->volume, channels,\n\t\t\t0x00800000 - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_m(mod, io, rtd,\n\t\t\tis_play ?\n\t\t\t\"DVC Out Mute Switch\" : \"DVC In Mute Switch\",\n\t\t\trsnd_kctrl_accept_anytime,\n\t\t\trsnd_dvc_volume_update,\n\t\t\t&dvc->mute, channels,\n\t\t\t1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rsnd_kctrl_new_s(mod, io, rtd,\n\t\t\tis_play ?\n\t\t\t\"DVC Out Ramp Switch\" : \"DVC In Ramp Switch\",\n\t\t\trsnd_kctrl_accept_anytime,\n\t\t\trsnd_dvc_volume_update,\n\t\t\t&dvc->ren, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsnd_kctrl_new_e(mod, io, rtd,\n\t\t\tis_play ?\n\t\t\t\"DVC Out Ramp Up Rate\" : \"DVC In Ramp Up Rate\",\n\t\t\trsnd_kctrl_accept_anytime,\n\t\t\trsnd_dvc_volume_update,\n\t\t\t&dvc->rup,\n\t\t\tvolume_ramp_rate,\n\t\t\tVOLUME_RAMP_MAX_DVC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsnd_kctrl_new_e(mod, io, rtd,\n\t\t\tis_play ?\n\t\t\t\"DVC Out Ramp Down Rate\" : \"DVC In Ramp Down Rate\",\n\t\t\trsnd_kctrl_accept_anytime,\n\t\t\trsnd_dvc_volume_update,\n\t\t\t&dvc->rdown,\n\t\t\tvolume_ramp_rate,\n\t\t\tVOLUME_RAMP_MAX_DVC);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct dma_chan *rsnd_dvc_dma_req(struct rsnd_dai_stream *io,\n\t\t\t\t\t struct rsnd_mod *mod)\n{\n\tstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\n\n\treturn rsnd_dma_request_channel(rsnd_dvc_of_node(priv),\n\t\t\t\t\tDVC_NAME, mod, \"tx\");\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void rsnd_dvc_debug_info(struct seq_file *m,\n\t\t\t\tstruct rsnd_dai_stream *io,\n\t\t\t\tstruct rsnd_mod *mod)\n{\n\trsnd_debugfs_mod_reg_show(m, mod, RSND_GEN2_SCU,\n\t\t\t\t  0xe00 + rsnd_mod_id(mod) * 0x100, 0x60);\n}\n#define DEBUG_INFO .debug_info = rsnd_dvc_debug_info\n#else\n#define DEBUG_INFO\n#endif\n\nstatic struct rsnd_mod_ops rsnd_dvc_ops = {\n\t.name\t\t= DVC_NAME,\n\t.dma_req\t= rsnd_dvc_dma_req,\n\t.probe\t\t= rsnd_dvc_probe_,\n\t.init\t\t= rsnd_dvc_init,\n\t.quit\t\t= rsnd_dvc_quit,\n\t.pcm_new\t= rsnd_dvc_pcm_new,\n\t.get_status\t= rsnd_mod_get_status,\n\tDEBUG_INFO\n};\n\nstruct rsnd_mod *rsnd_dvc_mod_get(struct rsnd_priv *priv, int id)\n{\n\tif (WARN_ON(id < 0 || id >= rsnd_dvc_nr(priv)))\n\t\tid = 0;\n\n\treturn rsnd_mod_get(rsnd_dvc_get(priv, id));\n}\n\nint rsnd_dvc_probe(struct rsnd_priv *priv)\n{\n\tstruct device_node *node;\n\tstruct device_node *np;\n\tstruct device *dev = rsnd_priv_to_dev(priv);\n\tstruct rsnd_dvc *dvc;\n\tstruct clk *clk;\n\tchar name[RSND_DVC_NAME_SIZE];\n\tint i, nr, ret;\n\n\t \n\tif (rsnd_is_gen1(priv))\n\t\treturn 0;\n\n\tnode = rsnd_dvc_of_node(priv);\n\tif (!node)\n\t\treturn 0;  \n\n\tnr = of_get_child_count(node);\n\tif (!nr) {\n\t\tret = -EINVAL;\n\t\tgoto rsnd_dvc_probe_done;\n\t}\n\n\tdvc\t= devm_kcalloc(dev, nr, sizeof(*dvc), GFP_KERNEL);\n\tif (!dvc) {\n\t\tret = -ENOMEM;\n\t\tgoto rsnd_dvc_probe_done;\n\t}\n\n\tpriv->dvc_nr\t= nr;\n\tpriv->dvc\t= dvc;\n\n\ti = 0;\n\tret = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tdvc = rsnd_dvc_get(priv, i);\n\n\t\tsnprintf(name, RSND_DVC_NAME_SIZE, \"%s.%d\",\n\t\t\t DVC_NAME, i);\n\n\t\tclk = devm_clk_get(dev, name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_dvc_probe_done;\n\t\t}\n\n\t\tret = rsnd_mod_init(priv, rsnd_mod_get(dvc), &rsnd_dvc_ops,\n\t\t\t\t    clk, RSND_MOD_DVC, i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto rsnd_dvc_probe_done;\n\t\t}\n\n\t\ti++;\n\t}\n\nrsnd_dvc_probe_done:\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nvoid rsnd_dvc_remove(struct rsnd_priv *priv)\n{\n\tstruct rsnd_dvc *dvc;\n\tint i;\n\n\tfor_each_rsnd_dvc(dvc, priv, i) {\n\t\trsnd_mod_quit(rsnd_mod_get(dvc));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}