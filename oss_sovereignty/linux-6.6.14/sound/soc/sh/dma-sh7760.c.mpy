{
  "module_name": "dma-sh7760.c",
  "hash_id": "dd2ee511419af60bdd2d96760d3fa0dca6876c3a18a151d9789bf0ae4312bbda",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/dma-sh7760.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <asm/dmabrg.h>\n\n\n \n#define BRGATXSAR\t0x00\n#define BRGARXDAR\t0x04\n#define BRGATXTCR\t0x08\n#define BRGARXTCR\t0x0C\n#define BRGACR\t\t0x10\n#define BRGATXTCNT\t0x14\n#define BRGARXTCNT\t0x18\n\n#define ACR_RAR\t\t(1 << 18)\n#define ACR_RDS\t\t(1 << 17)\n#define ACR_RDE\t\t(1 << 16)\n#define ACR_TAR\t\t(1 << 2)\n#define ACR_TDS\t\t(1 << 1)\n#define ACR_TDE\t\t(1 << 0)\n\n \n#define ACR_RAM_NONE\t(0 << 24)\n#define ACR_RAM_4BYTE\t(1 << 24)\n#define ACR_RAM_2WORD\t(2 << 24)\n#define ACR_TAM_NONE\t(0 << 8)\n#define ACR_TAM_4BYTE\t(1 << 8)\n#define ACR_TAM_2WORD\t(2 << 8)\n\n\nstruct camelot_pcm {\n\tunsigned long mmio;   \n\tunsigned int txid;     \n\n\tstruct snd_pcm_substream *tx_ss;\n\tunsigned long tx_period_size;\n\tunsigned int  tx_period;\n\n\tstruct snd_pcm_substream *rx_ss;\n\tunsigned long rx_period_size;\n\tunsigned int  rx_period;\n\n} cam_pcm_data[2] = {\n\t{\n\t\t.mmio\t=\t0xFE3C0040,\n\t\t.txid\t=\tDMABRGIRQ_A0TXF,\n\t},\n\t{\n\t\t.mmio\t=\t0xFE3C0060,\n\t\t.txid\t=\tDMABRGIRQ_A1TXF,\n\t},\n};\n\n#define BRGREG(x)\t(*(unsigned long *)(cam->mmio + (x)))\n\n \n#define DMABRG_PERIOD_MIN\t\t16 * 1024\n#define DMABRG_PERIOD_MAX\t\t0x03fffffc\n#define DMABRG_PREALLOC_BUFFER\t\t32 * 1024\n#define DMABRG_PREALLOC_BUFFER_MAX\t32 * 1024\n\nstatic const struct snd_pcm_hardware camelot_pcm_hardware = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH),\n\t.buffer_bytes_max =\tDMABRG_PERIOD_MAX,\n\t.period_bytes_min =\tDMABRG_PERIOD_MIN,\n\t.period_bytes_max =\tDMABRG_PERIOD_MAX / 2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t128,\n};\n\nstatic void camelot_txdma(void *data)\n{\n\tstruct camelot_pcm *cam = data;\n\tcam->tx_period ^= 1;\n\tsnd_pcm_period_elapsed(cam->tx_ss);\n}\n\nstatic void camelot_rxdma(void *data)\n{\n\tstruct camelot_pcm *cam = data;\n\tcam->rx_period ^= 1;\n\tsnd_pcm_period_elapsed(cam->rx_ss);\n}\n\nstatic int camelot_pcm_open(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\n\tint ret, dmairq;\n\n\tsnd_soc_set_runtime_hwparams(substream, &camelot_pcm_hardware);\n\n\t \n\tdmairq = (recv) ? cam->txid + 2 : cam->txid;\n\tif (recv) {\n\t\tcam->rx_ss = substream;\n\t\tret = dmabrg_request_irq(dmairq, camelot_rxdma, cam);\n\t\tif (unlikely(ret)) {\n\t\t\tpr_debug(\"audio unit %d irqs already taken!\\n\",\n\t\t\t     asoc_rtd_to_cpu(rtd, 0)->id);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t(void)dmabrg_request_irq(dmairq + 1,camelot_rxdma, cam);\n\t} else {\n\t\tcam->tx_ss = substream;\n\t\tret = dmabrg_request_irq(dmairq, camelot_txdma, cam);\n\t\tif (unlikely(ret)) {\n\t\t\tpr_debug(\"audio unit %d irqs already taken!\\n\",\n\t\t\t     asoc_rtd_to_cpu(rtd, 0)->id);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t(void)dmabrg_request_irq(dmairq + 1, camelot_txdma, cam);\n\t}\n\treturn 0;\n}\n\nstatic int camelot_pcm_close(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\n\tint dmairq;\n\n\tdmairq = (recv) ? cam->txid + 2 : cam->txid;\n\n\tif (recv)\n\t\tcam->rx_ss = NULL;\n\telse\n\t\tcam->tx_ss = NULL;\n\n\tdmabrg_free_irq(dmairq + 1);\n\tdmabrg_free_irq(dmairq);\n\n\treturn 0;\n}\n\nstatic int camelot_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\n\n\tif (recv) {\n\t\tcam->rx_period_size = params_period_bytes(hw_params);\n\t\tcam->rx_period = 0;\n\t} else {\n\t\tcam->tx_period_size = params_period_bytes(hw_params);\n\t\tcam->tx_period = 0;\n\t}\n\treturn 0;\n}\n\nstatic int camelot_prepare(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\n\tpr_debug(\"PCM data: addr 0x%08lx len %d\\n\",\n\t\t (u32)runtime->dma_addr, runtime->dma_bytes);\n \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tBRGREG(BRGATXSAR) = (unsigned long)runtime->dma_area;\n\t\tBRGREG(BRGATXTCR) = runtime->dma_bytes;\n\t} else {\n\t\tBRGREG(BRGARXDAR) = (unsigned long)runtime->dma_area;\n\t\tBRGREG(BRGARXTCR) = runtime->dma_bytes;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void dmabrg_play_dma_start(struct camelot_pcm *cam)\n{\n\tunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\n\t \n\tBRGREG(BRGACR) = acr | ACR_TDE | ACR_TAR | ACR_TAM_2WORD;\n}\n\nstatic inline void dmabrg_play_dma_stop(struct camelot_pcm *cam)\n{\n\tunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\n\t \n\tBRGREG(BRGACR) = acr | ACR_TDS;\n}\n\nstatic inline void dmabrg_rec_dma_start(struct camelot_pcm *cam)\n{\n\tunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\n\t \n\tBRGREG(BRGACR) = acr | ACR_RDE | ACR_RAR | ACR_RAM_2WORD;\n}\n\nstatic inline void dmabrg_rec_dma_stop(struct camelot_pcm *cam)\n{\n\tunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\n\t \n\tBRGREG(BRGACR) = acr | ACR_RDS;\n}\n\nstatic int camelot_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (recv)\n\t\t\tdmabrg_rec_dma_start(cam);\n\t\telse\n\t\t\tdmabrg_play_dma_start(cam);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (recv)\n\t\t\tdmabrg_rec_dma_stop(cam);\n\t\telse\n\t\t\tdmabrg_play_dma_stop(cam);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t camelot_pos(struct snd_soc_component *component,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct camelot_pcm *cam = &cam_pcm_data[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\n\tunsigned long pos;\n\n\t \n\tif (recv)\n\t\tpos = cam->rx_period ? cam->rx_period_size : 0;\n\telse\n\t\tpos = cam->tx_period ? cam->tx_period_size : 0;\n\n\treturn bytes_to_frames(runtime, pos);\n}\n\nstatic int camelot_pcm_new(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\tSNDRV_DMA_TYPE_CONTINUOUS,\n\t\tNULL,\n\t\tDMABRG_PREALLOC_BUFFER,\tDMABRG_PREALLOC_BUFFER_MAX);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver sh7760_soc_component = {\n\t.open\t\t= camelot_pcm_open,\n\t.close\t\t= camelot_pcm_close,\n\t.hw_params\t= camelot_hw_params,\n\t.prepare\t= camelot_prepare,\n\t.trigger\t= camelot_trigger,\n\t.pointer\t= camelot_pos,\n\t.pcm_construct\t= camelot_pcm_new,\n};\n\nstatic int sh7760_soc_platform_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev, &sh7760_soc_component,\n\t\t\t\t\t       NULL, 0);\n}\n\nstatic struct platform_driver sh7760_pcm_driver = {\n\t.driver = {\n\t\t\t.name = \"sh7760-pcm-audio\",\n\t},\n\n\t.probe = sh7760_soc_platform_probe,\n};\n\nmodule_platform_driver(sh7760_pcm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SH7760 Audio DMA (DMABRG) driver\");\nMODULE_AUTHOR(\"Manuel Lauss <mano@roarinelk.homelinux.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}