{
  "module_name": "ssi.c",
  "hash_id": "01f9e9d239207ffa17208ad7b9d63fc2e2e95c09fb08a2d40fd5a7c35da1c498",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/ssi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <asm/io.h>\n\n#define SSICR\t0x00\n#define SSISR\t0x04\n\n#define CR_DMAEN\t(1 << 28)\n#define CR_CHNL_SHIFT\t22\n#define CR_CHNL_MASK\t(3 << CR_CHNL_SHIFT)\n#define CR_DWL_SHIFT\t19\n#define CR_DWL_MASK\t(7 << CR_DWL_SHIFT)\n#define CR_SWL_SHIFT\t16\n#define CR_SWL_MASK\t(7 << CR_SWL_SHIFT)\n#define CR_SCK_MASTER\t(1 << 15)\t \n#define CR_SWS_MASTER\t(1 << 14)\t \n#define CR_SCKP\t\t(1 << 13)\t \n#define CR_SWSP\t\t(1 << 12)\t \n#define CR_SPDP\t\t(1 << 11)\n#define CR_SDTA\t\t(1 << 10)\t \n#define CR_PDTA\t\t(1 << 9)\t \n#define CR_DEL\t\t(1 << 8)\t \n#define CR_BREN\t\t(1 << 7)\t \n#define CR_CKDIV_SHIFT\t4\n#define CR_CKDIV_MASK\t(7 << CR_CKDIV_SHIFT)\t \n#define CR_MUTE\t\t(1 << 3)\t \n#define CR_CPEN\t\t(1 << 2)\t \n#define CR_TRMD\t\t(1 << 1)\t \n#define CR_EN\t\t(1 << 0)\t \n\n#define SSIREG(reg)\t(*(unsigned long *)(ssi->mmio + (reg)))\n\nstruct ssi_priv {\n\tunsigned long mmio;\n\tunsigned long sysclk;\n\tint inuse;\n} ssi_cpu_data[] = {\n#if defined(CONFIG_CPU_SUBTYPE_SH7760)\n\t{\n\t\t.mmio\t= 0xFE680000,\n\t},\n\t{\n\t\t.mmio\t= 0xFE690000,\n\t},\n#elif defined(CONFIG_CPU_SUBTYPE_SH7780)\n\t{\n\t\t.mmio\t= 0xFFE70000,\n\t},\n#else\n#error \"Unsupported SuperH SoC\"\n#endif\n};\n\n \nstatic int ssi_startup(struct snd_pcm_substream *substream,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\tif (ssi->inuse) {\n\t\tpr_debug(\"ssi: already in use!\\n\");\n\t\treturn -EBUSY;\n\t} else\n\t\tssi->inuse = 1;\n\treturn 0;\n}\n\nstatic void ssi_shutdown(struct snd_pcm_substream *substream,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\n\tssi->inuse = 0;\n}\n\nstatic int ssi_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tSSIREG(SSICR) |= CR_DMAEN | CR_EN;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tSSIREG(SSICR) &= ~(CR_DMAEN | CR_EN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ssi_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\tunsigned long ssicr = SSIREG(SSICR);\n\tunsigned int bits, channels, swl, recv, i;\n\n\tchannels = params_channels(params);\n\tbits = params->msbits;\n\trecv = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 0 : 1;\n\n\tpr_debug(\"ssi_hw_params() enter\\nssicr was    %08lx\\n\", ssicr);\n\tpr_debug(\"bits: %u channels: %u\\n\", bits, channels);\n\n\tssicr &= ~(CR_TRMD | CR_CHNL_MASK | CR_DWL_MASK | CR_PDTA |\n\t\t   CR_SWL_MASK);\n\n\t \n\tif (!recv)\n\t\tssicr |= CR_TRMD;\t \n\n\t \n\tif ((channels < 2) || (channels > 8) || (channels & 1)) {\n\t\tpr_debug(\"ssi: invalid number of channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\tssicr |= ((channels >> 1) - 1) << CR_CHNL_SHIFT;\n\n\t \n\ti = 0;\n\tswitch (bits) {\n\tcase 32: ++i;\n\tcase 24: ++i;\n\tcase 22: ++i;\n\tcase 20: ++i;\n\tcase 18: ++i;\n\tcase 16: ++i;\n\t\t ssicr |= i << CR_DWL_SHIFT;\n\tcase 8:\t break;\n\tdefault:\n\t\tpr_debug(\"ssi: invalid sample width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((bits > 16) && (bits <= 24)) {\n\t\tbits = 24;\t \n\t\t   \n\t}\n\ti = 0;\n\tswl = (bits * channels) / 2;\n\tswitch (swl) {\n\tcase 256: ++i;\n\tcase 128: ++i;\n\tcase 64:  ++i;\n\tcase 48:  ++i;\n\tcase 32:  ++i;\n\tcase 16:  ++i;\n\t\t  ssicr |= i << CR_SWL_SHIFT;\n\tcase 8:   break;\n\tdefault:\n\t\tpr_debug(\"ssi: invalid system word length computed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tSSIREG(SSICR) = ssicr;\n\n\tpr_debug(\"ssi_hw_params() leave\\nssicr is now %08lx\\n\", ssicr);\n\treturn 0;\n}\n\nstatic int ssi_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\n\t\t\t  unsigned int freq, int dir)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[cpu_dai->id];\n\n\tssi->sysclk = freq;\n\n\treturn 0;\n}\n\n \nstatic int ssi_set_clkdiv(struct snd_soc_dai *dai, int did, int div)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\tunsigned long ssicr;\n\tint i;\n\n\ti = 0;\n\tssicr = SSIREG(SSICR) & ~CR_CKDIV_MASK;\n\tswitch (div) {\n\tcase 16: ++i;\n\tcase 8:  ++i;\n\tcase 4:  ++i;\n\tcase 2:  ++i;\n\t\t SSIREG(SSICR) = ssicr | (i << CR_CKDIV_SHIFT);\n\tcase 1:  break;\n\tdefault:\n\t\tpr_debug(\"ssi: invalid sck divider %d\\n\", div);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ssi_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\n\tunsigned long ssicr = SSIREG(SSICR);\n\n\tpr_debug(\"ssi_set_fmt()\\nssicr was    0x%08lx\\n\", ssicr);\n\n\tssicr &= ~(CR_DEL | CR_PDTA | CR_BREN | CR_SWSP | CR_SCKP |\n\t\t   CR_SWS_MASTER | CR_SCK_MASTER);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tssicr |= CR_DEL | CR_PDTA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tssicr |= CR_DEL;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ssi: unsupported format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\n\tcase SND_SOC_DAIFMT_CONT:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_GATED:\n\t\tssicr |= CR_BREN;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tssicr |= CR_SCKP;\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tssicr |= CR_SCKP | CR_SWSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tssicr |= CR_SWSP;\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ssi: invalid inversion\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\tssicr |= CR_SCK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tssicr |= CR_SWS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tssicr |= CR_SWS_MASTER | CR_SCK_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ssi: invalid master/secondary configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tSSIREG(SSICR) = ssicr;\n\tpr_debug(\"ssi_set_fmt() leave\\nssicr is now 0x%08lx\\n\", ssicr);\n\n\treturn 0;\n}\n\n \n#define SSI_RATES\t\\\n\tSNDRV_PCM_RATE_8000_192000\n\n \n#define SSI_FMTS\t\\\n\t(SNDRV_PCM_FMTBIT_S8      | SNDRV_PCM_FMTBIT_U8      |\t\\\n\t SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_U16_LE  |\t\\\n\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_U20_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_U24_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S32_LE  | SNDRV_PCM_FMTBIT_U32_LE)\n\nstatic const struct snd_soc_dai_ops ssi_dai_ops = {\n\t.startup\t= ssi_startup,\n\t.shutdown\t= ssi_shutdown,\n\t.trigger\t= ssi_trigger,\n\t.hw_params\t= ssi_hw_params,\n\t.set_sysclk\t= ssi_set_sysclk,\n\t.set_clkdiv\t= ssi_set_clkdiv,\n\t.set_fmt\t= ssi_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver sh4_ssi_dai[] = {\n{\n\t.name\t\t\t= \"ssi-dai.0\",\n\t.playback = {\n\t\t.rates\t\t= SSI_RATES,\n\t\t.formats\t= SSI_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\n\t},\n\t.capture = {\n\t\t.rates\t\t= SSI_RATES,\n\t\t.formats\t= SSI_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\n\t},\n\t.ops = &ssi_dai_ops,\n},\n#ifdef CONFIG_CPU_SUBTYPE_SH7760\n{\n\t.name\t\t\t= \"ssi-dai.1\",\n\t.playback = {\n\t\t.rates\t\t= SSI_RATES,\n\t\t.formats\t= SSI_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\n\t},\n\t.capture = {\n\t\t.rates\t\t= SSI_RATES,\n\t\t.formats\t= SSI_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\n\t},\n\t.ops = &ssi_dai_ops,\n},\n#endif\n};\n\nstatic const struct snd_soc_component_driver sh4_ssi_component = {\n\t.name\t\t\t= \"sh4-ssi\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int sh4_soc_dai_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev, &sh4_ssi_component,\n\t\t\t\t\t       sh4_ssi_dai,\n\t\t\t\t\t       ARRAY_SIZE(sh4_ssi_dai));\n}\n\nstatic struct platform_driver sh4_ssi_driver = {\n\t.driver = {\n\t\t\t.name = \"sh4-ssi-dai\",\n\t},\n\n\t.probe = sh4_soc_dai_probe,\n};\n\nmodule_platform_driver(sh4_ssi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SuperH onchip SSI (I2S) audio driver\");\nMODULE_AUTHOR(\"Manuel Lauss <mano@roarinelk.homelinux.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}