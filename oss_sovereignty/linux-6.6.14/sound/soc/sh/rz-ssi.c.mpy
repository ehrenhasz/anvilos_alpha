{
  "module_name": "rz-ssi.c",
  "hash_id": "8f21095abab20f54ffc13da756c2004d376c8a95d202cc9e68fba4c97d070b2e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sh/rz-ssi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n\n \n#define SSICR\t\t\t0x000\n#define SSISR\t\t\t0x004\n#define SSIFCR\t\t\t0x010\n#define SSIFSR\t\t\t0x014\n#define SSIFTDR\t\t\t0x018\n#define SSIFRDR\t\t\t0x01c\n#define SSIOFR\t\t\t0x020\n#define SSISCR\t\t\t0x024\n\n \n#define SSICR_DWL(x)\t\t(((x) & 0x7) << 19)\n#define SSICR_SWL(x)\t\t(((x) & 0x7) << 16)\n\n#define SSICR_CKS\t\tBIT(30)\n#define SSICR_TUIEN\t\tBIT(29)\n#define SSICR_TOIEN\t\tBIT(28)\n#define SSICR_RUIEN\t\tBIT(27)\n#define SSICR_ROIEN\t\tBIT(26)\n#define SSICR_MST\t\tBIT(14)\n#define SSICR_BCKP\t\tBIT(13)\n#define SSICR_LRCKP\t\tBIT(12)\n#define SSICR_CKDV(x)\t\t(((x) & 0xf) << 4)\n#define SSICR_TEN\t\tBIT(1)\n#define SSICR_REN\t\tBIT(0)\n\n#define SSISR_TUIRQ\t\tBIT(29)\n#define SSISR_TOIRQ\t\tBIT(28)\n#define SSISR_RUIRQ\t\tBIT(27)\n#define SSISR_ROIRQ\t\tBIT(26)\n#define SSISR_IIRQ\t\tBIT(25)\n\n#define SSIFCR_AUCKE\t\tBIT(31)\n#define SSIFCR_SSIRST\t\tBIT(16)\n#define SSIFCR_TIE\t\tBIT(3)\n#define SSIFCR_RIE\t\tBIT(2)\n#define SSIFCR_TFRST\t\tBIT(1)\n#define SSIFCR_RFRST\t\tBIT(0)\n\n#define SSIFSR_TDC_MASK\t\t0x3f\n#define SSIFSR_TDC_SHIFT\t24\n#define SSIFSR_RDC_MASK\t\t0x3f\n#define SSIFSR_RDC_SHIFT\t8\n\n#define SSIFSR_TDE\t\tBIT(16)\n#define SSIFSR_RDF\t\tBIT(0)\n\n#define SSIOFR_LRCONT\t\tBIT(8)\n\n#define SSISCR_TDES(x)\t\t(((x) & 0x1f) << 8)\n#define SSISCR_RDFS(x)\t\t(((x) & 0x1f) << 0)\n\n \n#define PREALLOC_BUFFER\t\t(SZ_32K)\n#define PREALLOC_BUFFER_MAX\t(SZ_32K)\n\n#define SSI_RATES\t\tSNDRV_PCM_RATE_8000_48000  \n#define SSI_FMTS\t\tSNDRV_PCM_FMTBIT_S16_LE\n#define SSI_CHAN_MIN\t\t2\n#define SSI_CHAN_MAX\t\t2\n#define SSI_FIFO_DEPTH\t\t32\n\nstruct rz_ssi_priv;\n\nstruct rz_ssi_stream {\n\tstruct rz_ssi_priv *priv;\n\tstruct snd_pcm_substream *substream;\n\tint fifo_sample_size;\t \n\tint dma_buffer_pos;\t \n\tint period_counter;\t \n\tint sample_width;\n\tint buffer_pos;\t\t \n\tint running;\t\t \n\n\tint uerr_num;\n\tint oerr_num;\n\n\tstruct dma_chan *dma_ch;\n\n\tint (*transfer)(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm);\n};\n\nstruct rz_ssi_priv {\n\tvoid __iomem *base;\n\tstruct platform_device *pdev;\n\tstruct reset_control *rstc;\n\tstruct device *dev;\n\tstruct clk *sfr_clk;\n\tstruct clk *clk;\n\n\tphys_addr_t phys;\n\tint irq_int;\n\tint irq_tx;\n\tint irq_rx;\n\tint irq_rt;\n\n\tspinlock_t lock;\n\n\t \n\tstruct rz_ssi_stream playback;\n\tstruct rz_ssi_stream capture;\n\n\t \n\tunsigned long audio_mck;\n\tunsigned long audio_clk_1;\n\tunsigned long audio_clk_2;\n\n\tbool lrckp_fsync_fall;\t \n\tbool bckp_rise;\t \n\tbool dma_rt;\n};\n\nstatic void rz_ssi_dma_complete(void *data);\n\nstatic void rz_ssi_reg_writel(struct rz_ssi_priv *priv, uint reg, u32 data)\n{\n\twritel(data, (priv->base + reg));\n}\n\nstatic u32 rz_ssi_reg_readl(struct rz_ssi_priv *priv, uint reg)\n{\n\treturn readl(priv->base + reg);\n}\n\nstatic void rz_ssi_reg_mask_setl(struct rz_ssi_priv *priv, uint reg,\n\t\t\t\t u32 bclr, u32 bset)\n{\n\tu32 val;\n\n\tval = readl(priv->base + reg);\n\tval = (val & ~bclr) | bset;\n\twritel(val, (priv->base + reg));\n}\n\nstatic inline struct snd_soc_dai *\nrz_ssi_get_dai(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\treturn asoc_rtd_to_cpu(rtd, 0);\n}\n\nstatic inline bool rz_ssi_stream_is_play(struct rz_ssi_priv *ssi,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\treturn substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n}\n\nstatic inline struct rz_ssi_stream *\nrz_ssi_stream_get(struct rz_ssi_priv *ssi, struct snd_pcm_substream *substream)\n{\n\tstruct rz_ssi_stream *stream = &ssi->playback;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\tstream = &ssi->capture;\n\n\treturn stream;\n}\n\nstatic inline bool rz_ssi_is_dma_enabled(struct rz_ssi_priv *ssi)\n{\n\treturn (ssi->playback.dma_ch && (ssi->dma_rt || ssi->capture.dma_ch));\n}\n\nstatic void rz_ssi_set_substream(struct rz_ssi_stream *strm,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct rz_ssi_priv *ssi = strm->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ssi->lock, flags);\n\tstrm->substream = substream;\n\tspin_unlock_irqrestore(&ssi->lock, flags);\n}\n\nstatic bool rz_ssi_stream_is_valid(struct rz_ssi_priv *ssi,\n\t\t\t\t   struct rz_ssi_stream *strm)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&ssi->lock, flags);\n\tret = strm->substream && strm->substream->runtime;\n\tspin_unlock_irqrestore(&ssi->lock, flags);\n\n\treturn ret;\n}\n\nstatic void rz_ssi_stream_init(struct rz_ssi_stream *strm,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\trz_ssi_set_substream(strm, substream);\n\tstrm->sample_width = samples_to_bytes(runtime, 1);\n\tstrm->dma_buffer_pos = 0;\n\tstrm->period_counter = 0;\n\tstrm->buffer_pos = 0;\n\n\tstrm->oerr_num = 0;\n\tstrm->uerr_num = 0;\n\tstrm->running = 0;\n\n\t \n\tstrm->fifo_sample_size = SSI_FIFO_DEPTH;\n}\n\nstatic void rz_ssi_stream_quit(struct rz_ssi_priv *ssi,\n\t\t\t       struct rz_ssi_stream *strm)\n{\n\tstruct snd_soc_dai *dai = rz_ssi_get_dai(strm->substream);\n\n\trz_ssi_set_substream(strm, NULL);\n\n\tif (strm->oerr_num > 0)\n\t\tdev_info(dai->dev, \"overrun = %d\\n\", strm->oerr_num);\n\n\tif (strm->uerr_num > 0)\n\t\tdev_info(dai->dev, \"underrun = %d\\n\", strm->uerr_num);\n}\n\nstatic int rz_ssi_clk_setup(struct rz_ssi_priv *ssi, unsigned int rate,\n\t\t\t    unsigned int channels)\n{\n\tstatic s8 ckdv[16] = { 1,  2,  4,  8, 16, 32, 64, 128,\n\t\t\t       6, 12, 24, 48, 96, -1, -1, -1 };\n\tunsigned int channel_bits = 32;\t \n\tunsigned long bclk_rate = rate * channels * channel_bits;\n\tunsigned int div;\n\tunsigned int i;\n\tu32 ssicr = 0;\n\tu32 clk_ckdv;\n\n\t \n\trz_ssi_reg_writel(ssi, SSIFCR, 0);\n\n\t \n\trz_ssi_reg_writel(ssi, SSIOFR, SSIOFR_LRCONT);\n\tif (ssi->audio_clk_1 && ssi->audio_clk_2) {\n\t\tif (ssi->audio_clk_1 % bclk_rate)\n\t\t\tssi->audio_mck = ssi->audio_clk_2;\n\t\telse\n\t\t\tssi->audio_mck = ssi->audio_clk_1;\n\t}\n\n\t \n\tssicr |= SSICR_MST;\n\tif (ssi->audio_mck == ssi->audio_clk_1)\n\t\tssicr |= SSICR_CKS;\n\tif (ssi->bckp_rise)\n\t\tssicr |= SSICR_BCKP;\n\tif (ssi->lrckp_fsync_fall)\n\t\tssicr |= SSICR_LRCKP;\n\n\t \n\tclk_ckdv = 0;\n\tdiv = ssi->audio_mck / bclk_rate;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ckdv); i++) {\n\t\tif (ckdv[i] == div) {\n\t\t\tclk_ckdv = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(ckdv)) {\n\t\tdev_err(ssi->dev, \"Rate not divisible by audio clock source\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tssicr |= SSICR_CKDV(clk_ckdv);\n\tssicr |= SSICR_DWL(1) | SSICR_SWL(3);\n\trz_ssi_reg_writel(ssi, SSICR, ssicr);\n\trz_ssi_reg_writel(ssi, SSIFCR,\n\t\t\t  (SSIFCR_AUCKE | SSIFCR_TFRST | SSIFCR_RFRST));\n\n\treturn 0;\n}\n\nstatic int rz_ssi_start(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)\n{\n\tbool is_play = rz_ssi_stream_is_play(ssi, strm->substream);\n\tu32 ssicr, ssifcr;\n\n\tssicr = rz_ssi_reg_readl(ssi, SSICR);\n\tssifcr = rz_ssi_reg_readl(ssi, SSIFCR) & ~0xF;\n\n\t \n\tif (rz_ssi_is_dma_enabled(ssi))\n\t\trz_ssi_reg_writel(ssi, SSISCR, 0);\n\telse\n\t\trz_ssi_reg_writel(ssi, SSISCR,\n\t\t\t\t  SSISCR_TDES(strm->fifo_sample_size / 2 - 1) |\n\t\t\t\t  SSISCR_RDFS(0));\n\n\t \n\tif (is_play) {\n\t\tssicr |= SSICR_TUIEN | SSICR_TOIEN;\n\t\tssifcr |= SSIFCR_TIE | SSIFCR_RFRST;\n\t} else {\n\t\tssicr |= SSICR_RUIEN | SSICR_ROIEN;\n\t\tssifcr |= SSIFCR_RIE | SSIFCR_TFRST;\n\t}\n\n\trz_ssi_reg_writel(ssi, SSICR, ssicr);\n\trz_ssi_reg_writel(ssi, SSIFCR, ssifcr);\n\n\t \n\trz_ssi_reg_mask_setl(ssi, SSISR,\n\t\t\t     (SSISR_TOIRQ | SSISR_TUIRQ | SSISR_ROIRQ |\n\t\t\t      SSISR_RUIRQ), 0);\n\n\tstrm->running = 1;\n\tssicr |= is_play ? SSICR_TEN : SSICR_REN;\n\trz_ssi_reg_writel(ssi, SSICR, ssicr);\n\n\treturn 0;\n}\n\nstatic int rz_ssi_stop(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)\n{\n\tint timeout;\n\n\tstrm->running = 0;\n\n\t \n\trz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TEN | SSICR_REN, 0);\n\n\t \n\tif (rz_ssi_is_dma_enabled(ssi))\n\t\tdmaengine_terminate_async(strm->dma_ch);\n\n\t \n\trz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TUIEN | SSICR_TOIEN |\n\t\t\t     SSICR_RUIEN | SSICR_ROIEN, 0);\n\trz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_TIE | SSIFCR_RIE, 0);\n\n\t \n\trz_ssi_reg_mask_setl(ssi, SSISR,\n\t\t\t     (SSISR_TOIRQ | SSISR_TUIRQ | SSISR_ROIRQ |\n\t\t\t      SSISR_RUIRQ), 0);\n\n\t \n\ttimeout = 100;\n\twhile (--timeout) {\n\t\tif (rz_ssi_reg_readl(ssi, SSISR) & SSISR_IIRQ)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (!timeout)\n\t\tdev_info(ssi->dev, \"timeout waiting for SSI idle\\n\");\n\n\t \n\trz_ssi_reg_mask_setl(ssi, SSIFCR, 0,\n\t\t\t     SSIFCR_TFRST | SSIFCR_RFRST);\n\n\treturn 0;\n}\n\nstatic void rz_ssi_pointer_update(struct rz_ssi_stream *strm, int frames)\n{\n\tstruct snd_pcm_substream *substream = strm->substream;\n\tstruct snd_pcm_runtime *runtime;\n\tint current_period;\n\n\tif (!strm->running || !substream || !substream->runtime)\n\t\treturn;\n\n\truntime = substream->runtime;\n\tstrm->buffer_pos += frames;\n\tWARN_ON(strm->buffer_pos > runtime->buffer_size);\n\n\t \n\tif (strm->buffer_pos == runtime->buffer_size)\n\t\tstrm->buffer_pos = 0;\n\n\tcurrent_period = strm->buffer_pos / runtime->period_size;\n\tif (strm->period_counter != current_period) {\n\t\tsnd_pcm_period_elapsed(strm->substream);\n\t\tstrm->period_counter = current_period;\n\t}\n}\n\nstatic int rz_ssi_pio_recv(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)\n{\n\tstruct snd_pcm_substream *substream = strm->substream;\n\tstruct snd_pcm_runtime *runtime;\n\tu16 *buf;\n\tint fifo_samples;\n\tint frames_left;\n\tint samples;\n\tint i;\n\n\tif (!rz_ssi_stream_is_valid(ssi, strm))\n\t\treturn -EINVAL;\n\n\truntime = substream->runtime;\n\n\tdo {\n\t\t \n\t\tframes_left = runtime->period_size -\n\t\t\t      (strm->buffer_pos % runtime->period_size);\n\t\tif (!frames_left)\n\t\t\tframes_left = runtime->period_size;\n\n\t\t \n\t\tfifo_samples = (rz_ssi_reg_readl(ssi, SSIFSR) >>\n\t\t\t\tSSIFSR_RDC_SHIFT) & SSIFSR_RDC_MASK;\n\n\t\t \n\t\tsamples = 0;\n\t\twhile (frames_left && (fifo_samples >= runtime->channels)) {\n\t\t\tsamples += runtime->channels;\n\t\t\tfifo_samples -= runtime->channels;\n\t\t\tframes_left--;\n\t\t}\n\n\t\t \n\t\tif (!samples)\n\t\t\tbreak;\n\n\t\t \n\t\tbuf = (u16 *)runtime->dma_area;\n\t\tbuf += strm->buffer_pos * runtime->channels;\n\n\t\t \n\t\tfor (i = 0; i < samples; i++)\n\t\t\t*buf++ = (u16)(rz_ssi_reg_readl(ssi, SSIFRDR) >> 16);\n\n\t\trz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);\n\t\trz_ssi_pointer_update(strm, samples / runtime->channels);\n\t} while (!frames_left && fifo_samples >= runtime->channels);\n\n\treturn 0;\n}\n\nstatic int rz_ssi_pio_send(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)\n{\n\tstruct snd_pcm_substream *substream = strm->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint sample_space;\n\tint samples = 0;\n\tint frames_left;\n\tint i;\n\tu32 ssifsr;\n\tu16 *buf;\n\n\tif (!rz_ssi_stream_is_valid(ssi, strm))\n\t\treturn -EINVAL;\n\n\t \n\tframes_left = runtime->period_size - (strm->buffer_pos %\n\t\t\t\t\t      runtime->period_size);\n\tif (frames_left == 0)\n\t\tframes_left = runtime->period_size;\n\n\tsample_space = strm->fifo_sample_size;\n\tssifsr = rz_ssi_reg_readl(ssi, SSIFSR);\n\tsample_space -= (ssifsr >> SSIFSR_TDC_SHIFT) & SSIFSR_TDC_MASK;\n\n\t \n\twhile (frames_left && (sample_space >= runtime->channels)) {\n\t\tsamples += runtime->channels;\n\t\tsample_space -= runtime->channels;\n\t\tframes_left--;\n\t}\n\n\t \n\tif (samples == 0)\n\t\treturn 0;\n\n\t \n\tbuf = (u16 *)(runtime->dma_area);\n\tbuf += strm->buffer_pos * runtime->channels;\n\n\t \n\tfor (i = 0; i < samples; i++)\n\t\trz_ssi_reg_writel(ssi, SSIFTDR, ((u32)(*buf++) << 16));\n\n\trz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_TDE, 0);\n\trz_ssi_pointer_update(strm, samples / runtime->channels);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rz_ssi_interrupt(int irq, void *data)\n{\n\tstruct rz_ssi_stream *strm = NULL;\n\tstruct rz_ssi_priv *ssi = data;\n\tu32 ssisr = rz_ssi_reg_readl(ssi, SSISR);\n\n\tif (ssi->playback.substream)\n\t\tstrm = &ssi->playback;\n\telse if (ssi->capture.substream)\n\t\tstrm = &ssi->capture;\n\telse\n\t\treturn IRQ_HANDLED;  \n\n\tif (irq == ssi->irq_int) {  \n\t\tif (ssisr & SSISR_TUIRQ)\n\t\t\tstrm->uerr_num++;\n\t\tif (ssisr & SSISR_TOIRQ)\n\t\t\tstrm->oerr_num++;\n\t\tif (ssisr & SSISR_RUIRQ)\n\t\t\tstrm->uerr_num++;\n\t\tif (ssisr & SSISR_ROIRQ)\n\t\t\tstrm->oerr_num++;\n\n\t\tif (ssisr & (SSISR_TUIRQ | SSISR_TOIRQ | SSISR_RUIRQ |\n\t\t\t     SSISR_ROIRQ)) {\n\t\t\t \n\t\t\t \n\t\t\trz_ssi_stop(ssi, strm);\n\n\t\t\t \n\t\t\trz_ssi_reg_mask_setl(ssi, SSISR, SSISR_TOIRQ |\n\t\t\t\t\t     SSISR_TUIRQ | SSISR_ROIRQ |\n\t\t\t\t\t     SSISR_RUIRQ, 0);\n\n\t\t\t \n\t\t\tstrm->transfer(ssi, strm);\n\n\t\t\t \n\t\t\trz_ssi_start(ssi, strm);\n\t\t}\n\t}\n\n\tif (!strm->running)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (irq == ssi->irq_tx)\n\t\tstrm->transfer(ssi, &ssi->playback);\n\n\t \n\tif (irq == ssi->irq_rx) {\n\t\tstrm->transfer(ssi, &ssi->capture);\n\t\trz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);\n\t}\n\n\tif (irq == ssi->irq_rt) {\n\t\tstruct snd_pcm_substream *substream = strm->substream;\n\n\t\tif (rz_ssi_stream_is_play(ssi, substream)) {\n\t\t\tstrm->transfer(ssi, &ssi->playback);\n\t\t} else {\n\t\t\tstrm->transfer(ssi, &ssi->capture);\n\t\t\trz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rz_ssi_dma_slave_config(struct rz_ssi_priv *ssi,\n\t\t\t\t   struct dma_chan *dma_ch, bool is_play)\n{\n\tstruct dma_slave_config cfg;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.direction = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\n\tcfg.dst_addr = ssi->phys + SSIFTDR;\n\tcfg.src_addr = ssi->phys + SSIFRDR;\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\n\treturn dmaengine_slave_config(dma_ch, &cfg);\n}\n\nstatic int rz_ssi_dma_transfer(struct rz_ssi_priv *ssi,\n\t\t\t       struct rz_ssi_stream *strm)\n{\n\tstruct snd_pcm_substream *substream = strm->substream;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct snd_pcm_runtime *runtime;\n\tenum dma_transfer_direction dir;\n\tu32 dma_paddr, dma_size;\n\tint amount;\n\n\tif (!rz_ssi_stream_is_valid(ssi, strm))\n\t\treturn -EINVAL;\n\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_DRAINING)\n\t\t \n\t\treturn 0;\n\n\tdir = rz_ssi_stream_is_play(ssi, substream) ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\n\n\t \n\tamount = runtime->period_size;\n\n\t \n\tdma_paddr = runtime->dma_addr + frames_to_bytes(runtime,\n\t\t\t\t\t\t\tstrm->dma_buffer_pos);\n\tdma_size = frames_to_bytes(runtime, amount);\n\tdesc = dmaengine_prep_slave_single(strm->dma_ch, dma_paddr, dma_size,\n\t\t\t\t\t   dir,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(ssi->dev, \"dmaengine_prep_slave_single() fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc->callback = rz_ssi_dma_complete;\n\tdesc->callback_param = strm;\n\n\tif (dmaengine_submit(desc) < 0) {\n\t\tdev_err(ssi->dev, \"dmaengine_submit() fail\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tstrm->dma_buffer_pos += amount;\n\tif (strm->dma_buffer_pos >= runtime->buffer_size)\n\t\tstrm->dma_buffer_pos = 0;\n\n\t \n\tdma_async_issue_pending(strm->dma_ch);\n\n\treturn 0;\n}\n\nstatic void rz_ssi_dma_complete(void *data)\n{\n\tstruct rz_ssi_stream *strm = (struct rz_ssi_stream *)data;\n\n\tif (!strm->running || !strm->substream || !strm->substream->runtime)\n\t\treturn;\n\n\t \n\trz_ssi_pointer_update(strm, strm->substream->runtime->period_size);\n\n\t \n\trz_ssi_dma_transfer(strm->priv, strm);\n}\n\nstatic void rz_ssi_release_dma_channels(struct rz_ssi_priv *ssi)\n{\n\tif (ssi->playback.dma_ch) {\n\t\tdma_release_channel(ssi->playback.dma_ch);\n\t\tssi->playback.dma_ch = NULL;\n\t\tif (ssi->dma_rt)\n\t\t\tssi->dma_rt = false;\n\t}\n\n\tif (ssi->capture.dma_ch) {\n\t\tdma_release_channel(ssi->capture.dma_ch);\n\t\tssi->capture.dma_ch = NULL;\n\t}\n}\n\nstatic int rz_ssi_dma_request(struct rz_ssi_priv *ssi, struct device *dev)\n{\n\tssi->playback.dma_ch = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(ssi->playback.dma_ch))\n\t\tssi->playback.dma_ch = NULL;\n\n\tssi->capture.dma_ch = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(ssi->capture.dma_ch))\n\t\tssi->capture.dma_ch = NULL;\n\n\tif (!ssi->playback.dma_ch && !ssi->capture.dma_ch) {\n\t\tssi->playback.dma_ch = dma_request_chan(dev, \"rt\");\n\t\tif (IS_ERR(ssi->playback.dma_ch)) {\n\t\t\tssi->playback.dma_ch = NULL;\n\t\t\tgoto no_dma;\n\t\t}\n\n\t\tssi->dma_rt = true;\n\t}\n\n\tif (!rz_ssi_is_dma_enabled(ssi))\n\t\tgoto no_dma;\n\n\tif (ssi->playback.dma_ch &&\n\t    (rz_ssi_dma_slave_config(ssi, ssi->playback.dma_ch, true) < 0))\n\t\tgoto no_dma;\n\n\tif (ssi->capture.dma_ch &&\n\t    (rz_ssi_dma_slave_config(ssi, ssi->capture.dma_ch, false) < 0))\n\t\tgoto no_dma;\n\n\treturn 0;\n\nno_dma:\n\trz_ssi_release_dma_channels(ssi);\n\n\treturn -ENODEV;\n}\n\nstatic int rz_ssi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct rz_ssi_priv *ssi = snd_soc_dai_get_drvdata(dai);\n\tstruct rz_ssi_stream *strm = rz_ssi_stream_get(ssi, substream);\n\tint ret = 0, i, num_transfer = 1;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\trz_ssi_reg_mask_setl(ssi, SSIFCR, 0, SSIFCR_SSIRST);\n\t\trz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_SSIRST, 0);\n\t\tudelay(5);\n\n\t\trz_ssi_stream_init(strm, substream);\n\n\t\tif (ssi->dma_rt) {\n\t\t\tbool is_playback;\n\n\t\t\tis_playback = rz_ssi_stream_is_play(ssi, substream);\n\t\t\tret = rz_ssi_dma_slave_config(ssi, ssi->playback.dma_ch,\n\t\t\t\t\t\t      is_playback);\n\t\t\t \n\t\t\tif (ret < 0) {\n\t\t\t\tssi->playback.transfer = rz_ssi_pio_send;\n\t\t\t\tssi->capture.transfer = rz_ssi_pio_recv;\n\t\t\t\trz_ssi_release_dma_channels(ssi);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rz_ssi_is_dma_enabled(ssi))\n\t\t\tnum_transfer = 4;\n\n\t\tfor (i = 0; i < num_transfer; i++) {\n\t\t\tret = strm->transfer(ssi, strm);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tret = rz_ssi_start(ssi, strm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trz_ssi_stop(ssi, strm);\n\t\trz_ssi_stream_quit(ssi, strm);\n\t\tbreak;\n\t}\n\ndone:\n\treturn ret;\n}\n\nstatic int rz_ssi_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct rz_ssi_priv *ssi = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ssi->dev, \"Codec should be clk and frame consumer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tssi->bckp_rise = false;\n\t\tssi->lrckp_fsync_fall = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tssi->bckp_rise = false;\n\t\tssi->lrckp_fsync_fall = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tssi->bckp_rise = true;\n\t\tssi->lrckp_fsync_fall = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tssi->bckp_rise = true;\n\t\tssi->lrckp_fsync_fall = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ssi->dev, \"Only I2S mode is supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rz_ssi_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct rz_ssi_priv *ssi = snd_soc_dai_get_drvdata(dai);\n\tunsigned int sample_bits = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\n\tunsigned int channels = params_channels(params);\n\n\tif (sample_bits != 16) {\n\t\tdev_err(ssi->dev, \"Unsupported sample width: %d\\n\",\n\t\t\tsample_bits);\n\t\treturn -EINVAL;\n\t}\n\n\tif (channels != 2) {\n\t\tdev_err(ssi->dev, \"Number of channels not matched: %d\\n\",\n\t\t\tchannels);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rz_ssi_clk_setup(ssi, params_rate(params),\n\t\t\t\tparams_channels(params));\n}\n\nstatic const struct snd_soc_dai_ops rz_ssi_dai_ops = {\n\t.trigger\t= rz_ssi_dai_trigger,\n\t.set_fmt\t= rz_ssi_dai_set_fmt,\n\t.hw_params\t= rz_ssi_dai_hw_params,\n};\n\nstatic const struct snd_pcm_hardware rz_ssi_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_INTERLEAVED\t|\n\t\t\t\t  SNDRV_PCM_INFO_MMAP\t\t|\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID,\n\t.buffer_bytes_max\t= PREALLOC_BUFFER,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 8192,\n\t.channels_min\t\t= SSI_CHAN_MIN,\n\t.channels_max\t\t= SSI_CHAN_MAX,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 32,\n\t.fifo_size\t\t= 32 * 2,\n};\n\nstatic int rz_ssi_pcm_open(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tsnd_soc_set_runtime_hwparams(substream, &rz_ssi_pcm_hardware);\n\n\treturn snd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n}\n\nstatic snd_pcm_uframes_t rz_ssi_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_dai *dai = rz_ssi_get_dai(substream);\n\tstruct rz_ssi_priv *ssi = snd_soc_dai_get_drvdata(dai);\n\tstruct rz_ssi_stream *strm = rz_ssi_stream_get(ssi, substream);\n\n\treturn strm->buffer_pos;\n}\n\nstatic int rz_ssi_pcm_new(struct snd_soc_component *component,\n\t\t\t  struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       rtd->card->snd_card->dev,\n\t\t\t\t       PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);\n\treturn 0;\n}\n\nstatic struct snd_soc_dai_driver rz_ssi_soc_dai[] = {\n\t{\n\t\t.name\t\t\t= \"rz-ssi-dai\",\n\t\t.playback = {\n\t\t\t.rates\t\t= SSI_RATES,\n\t\t\t.formats\t= SSI_FMTS,\n\t\t\t.channels_min\t= SSI_CHAN_MIN,\n\t\t\t.channels_max\t= SSI_CHAN_MAX,\n\t\t},\n\t\t.capture = {\n\t\t\t.rates\t\t= SSI_RATES,\n\t\t\t.formats\t= SSI_FMTS,\n\t\t\t.channels_min\t= SSI_CHAN_MIN,\n\t\t\t.channels_max\t= SSI_CHAN_MAX,\n\t\t},\n\t\t.ops = &rz_ssi_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver rz_ssi_soc_component = {\n\t.name\t\t\t= \"rz-ssi\",\n\t.open\t\t\t= rz_ssi_pcm_open,\n\t.pointer\t\t= rz_ssi_pcm_pointer,\n\t.pcm_construct\t\t= rz_ssi_pcm_new,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int rz_ssi_probe(struct platform_device *pdev)\n{\n\tstruct rz_ssi_priv *ssi;\n\tstruct clk *audio_clk;\n\tstruct resource *res;\n\tint ret;\n\n\tssi = devm_kzalloc(&pdev->dev, sizeof(*ssi), GFP_KERNEL);\n\tif (!ssi)\n\t\treturn -ENOMEM;\n\n\tssi->pdev = pdev;\n\tssi->dev = &pdev->dev;\n\tssi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ssi->base))\n\t\treturn PTR_ERR(ssi->base);\n\n\tssi->phys = res->start;\n\tssi->clk = devm_clk_get(&pdev->dev, \"ssi\");\n\tif (IS_ERR(ssi->clk))\n\t\treturn PTR_ERR(ssi->clk);\n\n\tssi->sfr_clk = devm_clk_get(&pdev->dev, \"ssi_sfr\");\n\tif (IS_ERR(ssi->sfr_clk))\n\t\treturn PTR_ERR(ssi->sfr_clk);\n\n\taudio_clk = devm_clk_get(&pdev->dev, \"audio_clk1\");\n\tif (IS_ERR(audio_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(audio_clk),\n\t\t\t\t     \"no audio clk1\");\n\n\tssi->audio_clk_1 = clk_get_rate(audio_clk);\n\taudio_clk = devm_clk_get(&pdev->dev, \"audio_clk2\");\n\tif (IS_ERR(audio_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(audio_clk),\n\t\t\t\t     \"no audio clk2\");\n\n\tssi->audio_clk_2 = clk_get_rate(audio_clk);\n\tif (!(ssi->audio_clk_1 || ssi->audio_clk_2))\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"no audio clk1 or audio clk2\");\n\n\tssi->audio_mck = ssi->audio_clk_1 ? ssi->audio_clk_1 : ssi->audio_clk_2;\n\n\t \n\tret = rz_ssi_dma_request(ssi, &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_warn(&pdev->dev, \"DMA not available, using PIO\\n\");\n\t\tssi->playback.transfer = rz_ssi_pio_send;\n\t\tssi->capture.transfer = rz_ssi_pio_recv;\n\t} else {\n\t\tdev_info(&pdev->dev, \"DMA enabled\");\n\t\tssi->playback.transfer = rz_ssi_dma_transfer;\n\t\tssi->capture.transfer = rz_ssi_dma_transfer;\n\t}\n\n\tssi->playback.priv = ssi;\n\tssi->capture.priv = ssi;\n\n\tspin_lock_init(&ssi->lock);\n\tdev_set_drvdata(&pdev->dev, ssi);\n\n\t \n\tssi->irq_int = platform_get_irq_byname(pdev, \"int_req\");\n\tif (ssi->irq_int < 0) {\n\t\trz_ssi_release_dma_channels(ssi);\n\t\treturn ssi->irq_int;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, ssi->irq_int, &rz_ssi_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), ssi);\n\tif (ret < 0) {\n\t\trz_ssi_release_dma_channels(ssi);\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"irq request error (int_req)\\n\");\n\t}\n\n\tif (!rz_ssi_is_dma_enabled(ssi)) {\n\t\t \n\t\tssi->irq_tx = platform_get_irq_byname(pdev, \"dma_tx\");\n\t\tssi->irq_rx = platform_get_irq_byname(pdev, \"dma_rx\");\n\t\tif (ssi->irq_tx == -ENXIO && ssi->irq_rx == -ENXIO) {\n\t\t\tssi->irq_rt = platform_get_irq_byname(pdev, \"dma_rt\");\n\t\t\tif (ssi->irq_rt < 0)\n\t\t\t\treturn ssi->irq_rt;\n\n\t\t\tret = devm_request_irq(&pdev->dev, ssi->irq_rt,\n\t\t\t\t\t       &rz_ssi_interrupt, 0,\n\t\t\t\t\t       dev_name(&pdev->dev), ssi);\n\t\t\tif (ret < 0)\n\t\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t\t\"irq request error (dma_tx)\\n\");\n\t\t} else {\n\t\t\tif (ssi->irq_tx < 0)\n\t\t\t\treturn ssi->irq_tx;\n\n\t\t\tif (ssi->irq_rx < 0)\n\t\t\t\treturn ssi->irq_rx;\n\n\t\t\tret = devm_request_irq(&pdev->dev, ssi->irq_tx,\n\t\t\t\t\t       &rz_ssi_interrupt, 0,\n\t\t\t\t\t       dev_name(&pdev->dev), ssi);\n\t\t\tif (ret < 0)\n\t\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t\t\"irq request error (dma_tx)\\n\");\n\n\t\t\tret = devm_request_irq(&pdev->dev, ssi->irq_rx,\n\t\t\t\t\t       &rz_ssi_interrupt, 0,\n\t\t\t\t\t       dev_name(&pdev->dev), ssi);\n\t\t\tif (ret < 0)\n\t\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t\t\"irq request error (dma_rx)\\n\");\n\t\t}\n\t}\n\n\tssi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(ssi->rstc)) {\n\t\tret = PTR_ERR(ssi->rstc);\n\t\tgoto err_reset;\n\t}\n\n\treset_control_deassert(ssi->rstc);\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pm_runtime_resume_and_get failed\\n\");\n\t\tgoto err_pm;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &rz_ssi_soc_component,\n\t\t\t\t\t      rz_ssi_soc_dai,\n\t\t\t\t\t      ARRAY_SIZE(rz_ssi_soc_dai));\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register snd component\\n\");\n\t\tgoto err_snd_soc;\n\t}\n\n\treturn 0;\n\nerr_snd_soc:\n\tpm_runtime_put(ssi->dev);\nerr_pm:\n\tpm_runtime_disable(ssi->dev);\n\treset_control_assert(ssi->rstc);\nerr_reset:\n\trz_ssi_release_dma_channels(ssi);\n\n\treturn ret;\n}\n\nstatic void rz_ssi_remove(struct platform_device *pdev)\n{\n\tstruct rz_ssi_priv *ssi = dev_get_drvdata(&pdev->dev);\n\n\trz_ssi_release_dma_channels(ssi);\n\n\tpm_runtime_put(ssi->dev);\n\tpm_runtime_disable(ssi->dev);\n\treset_control_assert(ssi->rstc);\n}\n\nstatic const struct of_device_id rz_ssi_of_match[] = {\n\t{ .compatible = \"renesas,rz-ssi\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rz_ssi_of_match);\n\nstatic struct platform_driver rz_ssi_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rz-ssi-pcm-audio\",\n\t\t.of_match_table = rz_ssi_of_match,\n\t},\n\t.probe\t\t= rz_ssi_probe,\n\t.remove_new\t= rz_ssi_remove,\n};\n\nmodule_platform_driver(rz_ssi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L ASoC Serial Sound Interface Driver\");\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}