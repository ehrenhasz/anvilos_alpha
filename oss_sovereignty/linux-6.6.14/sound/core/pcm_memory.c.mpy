{
  "module_name": "pcm_memory.c",
  "hash_id": "d65db15f042e5a681b0ba2f4fb8b58042fb1a0fd01ade740feffd50b43c8b372",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_memory.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/moduleparam.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include \"pcm_local.h\"\n\nstatic int preallocate_dma = 1;\nmodule_param(preallocate_dma, int, 0444);\nMODULE_PARM_DESC(preallocate_dma, \"Preallocate DMA memory when the PCM devices are initialized.\");\n\nstatic int maximum_substreams = 4;\nmodule_param(maximum_substreams, int, 0444);\nMODULE_PARM_DESC(maximum_substreams, \"Maximum substreams with preallocated DMA memory.\");\n\nstatic const size_t snd_minimum_buffer = 16384;\n\nstatic unsigned long max_alloc_per_card = 32UL * 1024UL * 1024UL;\nmodule_param(max_alloc_per_card, ulong, 0644);\nMODULE_PARM_DESC(max_alloc_per_card, \"Max total allocation bytes per card.\");\n\nstatic void __update_allocated_size(struct snd_card *card, ssize_t bytes)\n{\n\tcard->total_pcm_alloc_bytes += bytes;\n}\n\nstatic void update_allocated_size(struct snd_card *card, ssize_t bytes)\n{\n\tmutex_lock(&card->memory_mutex);\n\t__update_allocated_size(card, bytes);\n\tmutex_unlock(&card->memory_mutex);\n}\n\nstatic void decrease_allocated_size(struct snd_card *card, size_t bytes)\n{\n\tmutex_lock(&card->memory_mutex);\n\tWARN_ON(card->total_pcm_alloc_bytes < bytes);\n\t__update_allocated_size(card, -(ssize_t)bytes);\n\tmutex_unlock(&card->memory_mutex);\n}\n\nstatic int do_alloc_pages(struct snd_card *card, int type, struct device *dev,\n\t\t\t  int str, size_t size, struct snd_dma_buffer *dmab)\n{\n\tenum dma_data_direction dir;\n\tint err;\n\n\t \n\tmutex_lock(&card->memory_mutex);\n\tif (max_alloc_per_card &&\n\t    card->total_pcm_alloc_bytes + size > max_alloc_per_card) {\n\t\tmutex_unlock(&card->memory_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t__update_allocated_size(card, size);\n\tmutex_unlock(&card->memory_mutex);\n\n\tif (str == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = DMA_TO_DEVICE;\n\telse\n\t\tdir = DMA_FROM_DEVICE;\n\terr = snd_dma_alloc_dir_pages(type, dev, dir, size, dmab);\n\tif (!err) {\n\t\t \n\t\tif (dmab->bytes != size)\n\t\t\tupdate_allocated_size(card, dmab->bytes - size);\n\t} else {\n\t\t \n\t\tdecrease_allocated_size(card, size);\n\t}\n\treturn err;\n}\n\nstatic void do_free_pages(struct snd_card *card, struct snd_dma_buffer *dmab)\n{\n\tif (!dmab->area)\n\t\treturn;\n\tdecrease_allocated_size(card, dmab->bytes);\n\tsnd_dma_free_pages(dmab);\n\tdmab->area = NULL;\n}\n\n \nstatic int preallocate_pcm_pages(struct snd_pcm_substream *substream,\n\t\t\t\t size_t size, bool no_fallback)\n{\n\tstruct snd_dma_buffer *dmab = &substream->dma_buffer;\n\tstruct snd_card *card = substream->pcm->card;\n\tsize_t orig_size = size;\n\tint err;\n\n\tdo {\n\t\terr = do_alloc_pages(card, dmab->dev.type, dmab->dev.dev,\n\t\t\t\t     substream->stream, size, dmab);\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tif (no_fallback)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t} while (size >= snd_minimum_buffer);\n\tdmab->bytes = 0;  \n\tpr_warn(\"ALSA pcmC%dD%d%c,%d:%s: cannot preallocate for size %zu\\n\",\n\t\tsubstream->pcm->card->number, substream->pcm->device,\n\t\tsubstream->stream ? 'c' : 'p', substream->number,\n\t\tsubstream->pcm->name, orig_size);\n\treturn -ENOMEM;\n}\n\n \nvoid snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream)\n{\n\tdo_free_pages(substream->pcm->card, &substream->dma_buffer);\n}\n\n \nvoid snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm)\n{\n\tstruct snd_pcm_substream *substream;\n\tint stream;\n\n\tfor_each_pcm_substream(pcm, stream, substream)\n\t\tsnd_pcm_lib_preallocate_free(substream);\n}\nEXPORT_SYMBOL(snd_pcm_lib_preallocate_free_for_all);\n\n#ifdef CONFIG_SND_VERBOSE_PROCFS\n \nstatic void snd_pcm_lib_preallocate_proc_read(struct snd_info_entry *entry,\n\t\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tsnd_iprintf(buffer, \"%lu\\n\", (unsigned long) substream->dma_buffer.bytes / 1024);\n}\n\n \nstatic void snd_pcm_lib_preallocate_max_proc_read(struct snd_info_entry *entry,\n\t\t\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tsnd_iprintf(buffer, \"%lu\\n\", (unsigned long) substream->dma_max / 1024);\n}\n\n \nstatic void snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,\n\t\t\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tstruct snd_card *card = substream->pcm->card;\n\tchar line[64], str[64];\n\tsize_t size;\n\tstruct snd_dma_buffer new_dmab;\n\n\tmutex_lock(&substream->pcm->open_mutex);\n\tif (substream->runtime) {\n\t\tbuffer->error = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tsnd_info_get_str(str, line, sizeof(str));\n\t\tsize = simple_strtoul(str, NULL, 10) * 1024;\n\t\tif ((size != 0 && size < 8192) || size > substream->dma_max) {\n\t\t\tbuffer->error = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (substream->dma_buffer.bytes == size)\n\t\t\tgoto unlock;\n\t\tmemset(&new_dmab, 0, sizeof(new_dmab));\n\t\tnew_dmab.dev = substream->dma_buffer.dev;\n\t\tif (size > 0) {\n\t\t\tif (do_alloc_pages(card,\n\t\t\t\t\t   substream->dma_buffer.dev.type,\n\t\t\t\t\t   substream->dma_buffer.dev.dev,\n\t\t\t\t\t   substream->stream,\n\t\t\t\t\t   size, &new_dmab) < 0) {\n\t\t\t\tbuffer->error = -ENOMEM;\n\t\t\t\tpr_debug(\"ALSA pcmC%dD%d%c,%d:%s: cannot preallocate for size %zu\\n\",\n\t\t\t\t\t substream->pcm->card->number, substream->pcm->device,\n\t\t\t\t\t substream->stream ? 'c' : 'p', substream->number,\n\t\t\t\t\t substream->pcm->name, size);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tsubstream->buffer_bytes_max = size;\n\t\t} else {\n\t\t\tsubstream->buffer_bytes_max = UINT_MAX;\n\t\t}\n\t\tif (substream->dma_buffer.area)\n\t\t\tdo_free_pages(card, &substream->dma_buffer);\n\t\tsubstream->dma_buffer = new_dmab;\n\t} else {\n\t\tbuffer->error = -EINVAL;\n\t}\n unlock:\n\tmutex_unlock(&substream->pcm->open_mutex);\n}\n\nstatic inline void preallocate_info_init(struct snd_pcm_substream *substream)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(substream->pcm->card, \"prealloc\",\n\t\t\t\t\t   substream->proc_root);\n\tif (entry) {\n\t\tsnd_info_set_text_ops(entry, substream,\n\t\t\t\t      snd_pcm_lib_preallocate_proc_read);\n\t\tentry->c.text.write = snd_pcm_lib_preallocate_proc_write;\n\t\tentry->mode |= 0200;\n\t}\n\tentry = snd_info_create_card_entry(substream->pcm->card, \"prealloc_max\",\n\t\t\t\t\t   substream->proc_root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, substream,\n\t\t\t\t      snd_pcm_lib_preallocate_max_proc_read);\n}\n\n#else  \nstatic inline void preallocate_info_init(struct snd_pcm_substream *substream)\n{\n}\n#endif  \n\n \nstatic int preallocate_pages(struct snd_pcm_substream *substream,\n\t\t\t      int type, struct device *data,\n\t\t\t      size_t size, size_t max, bool managed)\n{\n\tint err;\n\n\tif (snd_BUG_ON(substream->dma_buffer.dev.type))\n\t\treturn -EINVAL;\n\n\tsubstream->dma_buffer.dev.type = type;\n\tsubstream->dma_buffer.dev.dev = data;\n\n\tif (size > 0) {\n\t\tif (!max) {\n\t\t\t \n\t\t\terr = preallocate_pcm_pages(substream, size, true);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else if (preallocate_dma &&\n\t\t\t   substream->number < maximum_substreams) {\n\t\t\terr = preallocate_pcm_pages(substream, size, false);\n\t\t\tif (err < 0 && err != -ENOMEM)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (substream->dma_buffer.bytes > 0)\n\t\tsubstream->buffer_bytes_max = substream->dma_buffer.bytes;\n\tsubstream->dma_max = max;\n\tif (max > 0)\n\t\tpreallocate_info_init(substream);\n\tif (managed)\n\t\tsubstream->managed_buffer_alloc = 1;\n\treturn 0;\n}\n\nstatic int preallocate_pages_for_all(struct snd_pcm *pcm, int type,\n\t\t\t\t      void *data, size_t size, size_t max,\n\t\t\t\t      bool managed)\n{\n\tstruct snd_pcm_substream *substream;\n\tint stream, err;\n\n\tfor_each_pcm_substream(pcm, stream, substream) {\n\t\terr = preallocate_pages(substream, type, data, size, max, managed);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nvoid snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,\n\t\t\t\t  int type, struct device *data,\n\t\t\t\t  size_t size, size_t max)\n{\n\tpreallocate_pages(substream, type, data, size, max, false);\n}\nEXPORT_SYMBOL(snd_pcm_lib_preallocate_pages);\n\n \nvoid snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,\n\t\t\t\t\t  int type, void *data,\n\t\t\t\t\t  size_t size, size_t max)\n{\n\tpreallocate_pages_for_all(pcm, type, data, size, max, false);\n}\nEXPORT_SYMBOL(snd_pcm_lib_preallocate_pages_for_all);\n\n \nint snd_pcm_set_managed_buffer(struct snd_pcm_substream *substream, int type,\n\t\t\t\tstruct device *data, size_t size, size_t max)\n{\n\treturn preallocate_pages(substream, type, data, size, max, true);\n}\nEXPORT_SYMBOL(snd_pcm_set_managed_buffer);\n\n \nint snd_pcm_set_managed_buffer_all(struct snd_pcm *pcm, int type,\n\t\t\t\t   struct device *data,\n\t\t\t\t   size_t size, size_t max)\n{\n\treturn preallocate_pages_for_all(pcm, type, data, size, max, true);\n}\nEXPORT_SYMBOL(snd_pcm_set_managed_buffer_all);\n\n \nint snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size)\n{\n\tstruct snd_card *card;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_dma_buffer *dmab = NULL;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(substream->dma_buffer.dev.type ==\n\t\t       SNDRV_DMA_TYPE_UNKNOWN))\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\tcard = substream->pcm->card;\n\n\tif (runtime->dma_buffer_p) {\n\t\t \n\t\tif (runtime->dma_buffer_p->bytes >= size) {\n\t\t\truntime->dma_bytes = size;\n\t\t\treturn 0;\t \n\t\t}\n\t\tsnd_pcm_lib_free_pages(substream);\n\t}\n\tif (substream->dma_buffer.area != NULL &&\n\t    substream->dma_buffer.bytes >= size) {\n\t\tdmab = &substream->dma_buffer;  \n\t} else {\n\t\t \n\t\tif (substream->dma_buffer.area && !substream->dma_max)\n\t\t\treturn -ENOMEM;\n\t\tdmab = kzalloc(sizeof(*dmab), GFP_KERNEL);\n\t\tif (! dmab)\n\t\t\treturn -ENOMEM;\n\t\tdmab->dev = substream->dma_buffer.dev;\n\t\tif (do_alloc_pages(card,\n\t\t\t\t   substream->dma_buffer.dev.type,\n\t\t\t\t   substream->dma_buffer.dev.dev,\n\t\t\t\t   substream->stream,\n\t\t\t\t   size, dmab) < 0) {\n\t\t\tkfree(dmab);\n\t\t\tpr_debug(\"ALSA pcmC%dD%d%c,%d:%s: cannot preallocate for size %zu\\n\",\n\t\t\t\t substream->pcm->card->number, substream->pcm->device,\n\t\t\t\t substream->stream ? 'c' : 'p', substream->number,\n\t\t\t\t substream->pcm->name, size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tsnd_pcm_set_runtime_buffer(substream, dmab);\n\truntime->dma_bytes = size;\n\treturn 1;\t\t\t \n}\nEXPORT_SYMBOL(snd_pcm_lib_malloc_pages);\n\n \nint snd_pcm_lib_free_pages(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\tif (runtime->dma_area == NULL)\n\t\treturn 0;\n\tif (runtime->dma_buffer_p != &substream->dma_buffer) {\n\t\tstruct snd_card *card = substream->pcm->card;\n\n\t\t \n\t\tdo_free_pages(card, runtime->dma_buffer_p);\n\t\tkfree(runtime->dma_buffer_p);\n\t}\n\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_lib_free_pages);\n\nint _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,\n\t\t\t\t      size_t size, gfp_t gfp_flags)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\tif (runtime->dma_area) {\n\t\tif (runtime->dma_bytes >= size)\n\t\t\treturn 0;  \n\t\tvfree(runtime->dma_area);\n\t}\n\truntime->dma_area = __vmalloc(size, gfp_flags);\n\tif (!runtime->dma_area)\n\t\treturn -ENOMEM;\n\truntime->dma_bytes = size;\n\treturn 1;\n}\nEXPORT_SYMBOL(_snd_pcm_lib_alloc_vmalloc_buffer);\n\n \nint snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\tvfree(runtime->dma_area);\n\truntime->dma_area = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_lib_free_vmalloc_buffer);\n\n \nstruct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,\n\t\t\t\t\t  unsigned long offset)\n{\n\treturn vmalloc_to_page(substream->runtime->dma_area + offset);\n}\nEXPORT_SYMBOL(snd_pcm_lib_get_vmalloc_page);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}