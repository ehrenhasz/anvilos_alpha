{
  "module_name": "seq_ump_convert.c",
  "hash_id": "54ab7467fc46748c65dc70296a353a1b36904fe1c1d7fb789af7b7ac7ee65187",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_ump_convert.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/ump.h>\n#include <sound/ump_msg.h>\n#include \"seq_ump_convert.h\"\n\n \nstatic u8 downscale_32_to_7bit(u32 src)\n{\n\treturn src >> 25;\n}\n\nstatic u16 downscale_32_to_14bit(u32 src)\n{\n\treturn src >> 18;\n}\n\nstatic u8 downscale_16_to_7bit(u16 src)\n{\n\treturn src >> 9;\n}\n\nstatic u16 upscale_7_to_16bit(u8 src)\n{\n\tu16 val, repeat;\n\n\tval = (u16)src << 9;\n\tif (src <= 0x40)\n\t\treturn val;\n\trepeat = src & 0x3f;\n\treturn val | (repeat << 3) | (repeat >> 3);\n}\n\nstatic u32 upscale_7_to_32bit(u8 src)\n{\n\tu32 val, repeat;\n\n\tval = src << 25;\n\tif (src <= 0x40)\n\t\treturn val;\n\trepeat = src & 0x3f;\n\treturn val | (repeat << 19) | (repeat << 13) |\n\t\t(repeat << 7) | (repeat << 1) | (repeat >> 5);\n}\n\nstatic u32 upscale_14_to_32bit(u16 src)\n{\n\tu32 val, repeat;\n\n\tval = src << 18;\n\tif (src <= 0x2000)\n\t\treturn val;\n\trepeat = src & 0x1fff;\n\treturn val | (repeat << 5) | (repeat >> 8);\n}\n\nstatic unsigned char get_ump_group(struct snd_seq_client_port *port)\n{\n\treturn port->ump_group ? (port->ump_group - 1) : 0;\n}\n\n \n#define make_raw_ump(port, type) \\\n\tump_compose(type, get_ump_group(port), 0, 0)\n\n \n\n \n\n \nstatic void ump_midi1_to_note_ev(const union snd_ump_midi1_msg *val,\n\t\t\t\t struct snd_seq_event *ev)\n{\n\tev->data.note.channel = val->note.channel;\n\tev->data.note.note = val->note.note;\n\tev->data.note.velocity = val->note.velocity;\n}\n\n \nstatic void ump_midi1_to_ctrl_ev(const union snd_ump_midi1_msg *val,\n\t\t\t\t struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->caf.channel;\n\tev->data.control.value = val->caf.data;\n}\n\n \nstatic void ump_midi1_to_pitchbend_ev(const union snd_ump_midi1_msg *val,\n\t\t\t\t      struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->pb.channel;\n\tev->data.control.value = (val->pb.data_msb << 7) | val->pb.data_lsb;\n\tev->data.control.value -= 8192;\n}\n\n \nstatic void ump_midi1_to_cc_ev(const union snd_ump_midi1_msg *val,\n\t\t\t       struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->cc.channel;\n\tev->data.control.param = val->cc.index;\n\tev->data.control.value = val->cc.data;\n}\n\n \nstruct seq_ump_midi1_to_ev {\n\tint seq_type;\n\tvoid (*encode)(const union snd_ump_midi1_msg *val, struct snd_seq_event *ev);\n};\n\n \nstatic struct seq_ump_midi1_to_ev midi1_msg_encoders[] = {\n\t{SNDRV_SEQ_EVENT_NOTEOFF,\tump_midi1_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_NOTEON,\tump_midi1_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_KEYPRESS,\tump_midi1_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_CONTROLLER,\tump_midi1_to_cc_ev},\t \n\t{SNDRV_SEQ_EVENT_PGMCHANGE,\tump_midi1_to_ctrl_ev},\t \n\t{SNDRV_SEQ_EVENT_CHANPRESS,\tump_midi1_to_ctrl_ev},\t \n\t{SNDRV_SEQ_EVENT_PITCHBEND,\tump_midi1_to_pitchbend_ev},  \n};\n\nstatic int cvt_ump_midi1_to_event(const union snd_ump_midi1_msg *val,\n\t\t\t\t  struct snd_seq_event *ev)\n{\n\tunsigned char status = val->note.status;\n\n\tif (status < 0x8 || status > 0xe)\n\t\treturn 0;  \n\tstatus -= 8;\n\tev->type = midi1_msg_encoders[status].seq_type;\n\tev->flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tmidi1_msg_encoders[status].encode(val, ev);\n\treturn 1;\n}\n\n \n\n \nstatic void ump_system_to_one_param_ev(const union snd_ump_midi1_msg *val,\n\t\t\t\t       struct snd_seq_event *ev)\n{\n\tev->data.control.value = val->system.parm1;\n}\n\n \nstatic void ump_system_to_songpos_ev(const union snd_ump_midi1_msg *val,\n\t\t\t\t     struct snd_seq_event *ev)\n{\n\tev->data.control.value = (val->system.parm1 << 7) | val->system.parm2;\n}\n\n \nstatic struct seq_ump_midi1_to_ev system_msg_encoders[] = {\n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t  \n\t{SNDRV_SEQ_EVENT_QFRAME,\tump_system_to_one_param_ev},  \n\t{SNDRV_SEQ_EVENT_SONGPOS,\tump_system_to_songpos_ev},  \n\t{SNDRV_SEQ_EVENT_SONGSEL,\tump_system_to_one_param_ev},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_TUNE_REQUEST,\tNULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_CLOCK,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_START,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_CONTINUE,\tNULL},  \n\t{SNDRV_SEQ_EVENT_STOP,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},  \n\t{SNDRV_SEQ_EVENT_SENSING,\tNULL},  \n\t{SNDRV_SEQ_EVENT_RESET,\t\tNULL},  \n};\n\nstatic int cvt_ump_system_to_event(const union snd_ump_midi1_msg *val,\n\t\t\t\t   struct snd_seq_event *ev)\n{\n\tunsigned char status = val->system.status;\n\n\tif ((status & 0xf0) != UMP_MIDI1_MSG_REALTIME)\n\t\treturn 0;  \n\tstatus &= 0x0f;\n\tev->type = system_msg_encoders[status].seq_type;\n\tev->flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\treturn 0;\n\tif (system_msg_encoders[status].encode)\n\t\tsystem_msg_encoders[status].encode(val, ev);\n\treturn 1;\n}\n\n \n\n \nstatic int ump_midi2_to_note_ev(const union snd_ump_midi2_msg *val,\n\t\t\t\tstruct snd_seq_event *ev)\n{\n\tev->data.note.channel = val->note.channel;\n\tev->data.note.note = val->note.note;\n\tev->data.note.velocity = downscale_16_to_7bit(val->note.velocity);\n\t \n\tif (ev->type == SNDRV_SEQ_EVENT_NOTEON &&\n\t    !ev->data.note.velocity)\n\t\tev->data.note.velocity = 1;\n\treturn 1;\n}\n\n \nstatic int ump_midi2_to_pitchbend_ev(const union snd_ump_midi2_msg *val,\n\t\t\t\t     struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->pb.channel;\n\tev->data.control.value = downscale_32_to_14bit(val->pb.data);\n\tev->data.control.value -= 8192;\n\treturn 1;\n}\n\n \nstatic int ump_midi2_to_cc_ev(const union snd_ump_midi2_msg *val,\n\t\t\t      struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->cc.channel;\n\tev->data.control.param = val->cc.index;\n\tev->data.control.value = downscale_32_to_7bit(val->cc.data);\n\treturn 1;\n}\n\n \nstatic int ump_midi2_to_pgm_ev(const union snd_ump_midi2_msg *val,\n\t\t\t       struct snd_seq_event *ev)\n{\n\tint size = 1;\n\n\tev->data.control.channel = val->pg.channel;\n\tif (val->pg.bank_valid) {\n\t\tev->type = SNDRV_SEQ_EVENT_CONTROL14;\n\t\tev->data.control.param = UMP_CC_BANK_SELECT;\n\t\tev->data.control.value = (val->pg.bank_msb << 7) | val->pg.bank_lsb;\n\t\tev[1] = ev[0];\n\t\tev++;\n\t\tev->type = SNDRV_SEQ_EVENT_PGMCHANGE;\n\t\tsize = 2;\n\t}\n\tev->data.control.value = val->pg.program;\n\treturn size;\n}\n\n \nstatic int ump_midi2_to_ctrl_ev(const union snd_ump_midi2_msg *val,\n\t\t\t\tstruct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->caf.channel;\n\tev->data.control.value = downscale_32_to_7bit(val->caf.data);\n\treturn 1;\n}\n\n \nstatic int ump_midi2_to_rpn_ev(const union snd_ump_midi2_msg *val,\n\t\t\t       struct snd_seq_event *ev)\n{\n\tev->data.control.channel = val->rpn.channel;\n\tev->data.control.param = (val->rpn.bank << 7) | val->rpn.index;\n\tev->data.control.value = downscale_32_to_14bit(val->rpn.data);\n\treturn 1;\n}\n\n \nstruct seq_ump_midi2_to_ev {\n\tint seq_type;\n\tint (*encode)(const union snd_ump_midi2_msg *val, struct snd_seq_event *ev);\n};\n\n \nstatic struct seq_ump_midi2_to_ev midi2_msg_encoders[] = {\n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_REGPARAM,\tump_midi2_to_rpn_ev},\t \n\t{SNDRV_SEQ_EVENT_NONREGPARAM,\tump_midi2_to_rpn_ev},\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n\t{SNDRV_SEQ_EVENT_NOTEOFF,\tump_midi2_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_NOTEON,\tump_midi2_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_KEYPRESS,\tump_midi2_to_note_ev},\t \n\t{SNDRV_SEQ_EVENT_CONTROLLER,\tump_midi2_to_cc_ev},\t \n\t{SNDRV_SEQ_EVENT_PGMCHANGE,\tump_midi2_to_pgm_ev},\t \n\t{SNDRV_SEQ_EVENT_CHANPRESS,\tump_midi2_to_ctrl_ev},\t \n\t{SNDRV_SEQ_EVENT_PITCHBEND,\tump_midi2_to_pitchbend_ev},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\tNULL},\t\t\t \n};\n\nstatic int cvt_ump_midi2_to_event(const union snd_ump_midi2_msg *val,\n\t\t\t\t  struct snd_seq_event *ev)\n{\n\tunsigned char status = val->note.status;\n\n\tev->type = midi2_msg_encoders[status].seq_type;\n\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\treturn 0;  \n\tev->flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\treturn midi2_msg_encoders[status].encode(val, ev);\n}\n\n \nstatic int cvt_ump_sysex7_to_event(const u32 *data, unsigned char *buf,\n\t\t\t\t   struct snd_seq_event *ev)\n{\n\tunsigned char status;\n\tunsigned char bytes;\n\tu32 val;\n\tint size = 0;\n\n\tval = data[0];\n\tstatus = ump_sysex_message_status(val);\n\tbytes = ump_sysex_message_length(val);\n\tif (bytes > 6)\n\t\treturn 0;  \n\n\tif (status == UMP_SYSEX_STATUS_SINGLE ||\n\t    status == UMP_SYSEX_STATUS_START) {\n\t\tbuf[0] = UMP_MIDI1_MSG_SYSEX_START;\n\t\tsize = 1;\n\t}\n\n\tif (bytes > 0)\n\t\tbuf[size++] = (val >> 8) & 0x7f;\n\tif (bytes > 1)\n\t\tbuf[size++] = val & 0x7f;\n\tval = data[1];\n\tif (bytes > 2)\n\t\tbuf[size++] = (val >> 24) & 0x7f;\n\tif (bytes > 3)\n\t\tbuf[size++] = (val >> 16) & 0x7f;\n\tif (bytes > 4)\n\t\tbuf[size++] = (val >> 8) & 0x7f;\n\tif (bytes > 5)\n\t\tbuf[size++] = val & 0x7f;\n\n\tif (status == UMP_SYSEX_STATUS_SINGLE ||\n\t    status == UMP_SYSEX_STATUS_END)\n\t\tbuf[size++] = UMP_MIDI1_MSG_SYSEX_END;\n\n\tev->type = SNDRV_SEQ_EVENT_SYSEX;\n\tev->flags = SNDRV_SEQ_EVENT_LENGTH_VARIABLE;\n\tev->data.ext.len = size;\n\tev->data.ext.ptr = buf;\n\treturn 1;\n}\n\n \nstatic int cvt_ump_midi1_to_midi2(struct snd_seq_client *dest,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  struct snd_seq_event *__event,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_ump_event *event = (struct snd_seq_ump_event *)__event;\n\tstruct snd_seq_ump_event ev_cvt;\n\tconst union snd_ump_midi1_msg *midi1 = (const union snd_ump_midi1_msg *)event->ump;\n\tunion snd_ump_midi2_msg *midi2 = (union snd_ump_midi2_msg *)ev_cvt.ump;\n\n\tev_cvt = *event;\n\tmemset(&ev_cvt.ump, 0, sizeof(ev_cvt.ump));\n\n\tmidi2->note.type = UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE;\n\tmidi2->note.group = midi1->note.group;\n\tmidi2->note.status = midi1->note.status;\n\tmidi2->note.channel = midi1->note.channel;\n\tswitch (midi1->note.status) {\n\tcase UMP_MSG_STATUS_NOTE_ON:\n\tcase UMP_MSG_STATUS_NOTE_OFF:\n\t\tmidi2->note.note = midi1->note.note;\n\t\tmidi2->note.velocity = upscale_7_to_16bit(midi1->note.velocity);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_POLY_PRESSURE:\n\t\tmidi2->paf.note = midi1->paf.note;\n\t\tmidi2->paf.data = upscale_7_to_32bit(midi1->paf.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CC:\n\t\tmidi2->cc.index = midi1->cc.index;\n\t\tmidi2->cc.data = upscale_7_to_32bit(midi1->cc.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PROGRAM:\n\t\tmidi2->pg.program = midi1->pg.program;\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CHANNEL_PRESSURE:\n\t\tmidi2->caf.data = upscale_7_to_32bit(midi1->caf.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PITCH_BEND:\n\t\tmidi2->pb.data = upscale_14_to_32bit((midi1->pb.data_msb << 7) |\n\t\t\t\t\t\t     midi1->pb.data_lsb);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t      (struct snd_seq_event *)&ev_cvt,\n\t\t\t\t\t      atomic, hop);\n}\n\n \nstatic int cvt_ump_midi2_to_midi1(struct snd_seq_client *dest,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  struct snd_seq_event *__event,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_ump_event *event = (struct snd_seq_ump_event *)__event;\n\tstruct snd_seq_ump_event ev_cvt;\n\tunion snd_ump_midi1_msg *midi1 = (union snd_ump_midi1_msg *)ev_cvt.ump;\n\tconst union snd_ump_midi2_msg *midi2 = (const union snd_ump_midi2_msg *)event->ump;\n\tu16 v;\n\n\tev_cvt = *event;\n\tmemset(&ev_cvt.ump, 0, sizeof(ev_cvt.ump));\n\n\tmidi1->note.type = UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE;\n\tmidi1->note.group = midi2->note.group;\n\tmidi1->note.status = midi2->note.status;\n\tmidi1->note.channel = midi2->note.channel;\n\tswitch (midi2->note.status << 4) {\n\tcase UMP_MSG_STATUS_NOTE_ON:\n\tcase UMP_MSG_STATUS_NOTE_OFF:\n\t\tmidi1->note.note = midi2->note.note;\n\t\tmidi1->note.velocity = downscale_16_to_7bit(midi2->note.velocity);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_POLY_PRESSURE:\n\t\tmidi1->paf.note = midi2->paf.note;\n\t\tmidi1->paf.data = downscale_32_to_7bit(midi2->paf.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CC:\n\t\tmidi1->cc.index = midi2->cc.index;\n\t\tmidi1->cc.data = downscale_32_to_7bit(midi2->cc.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PROGRAM:\n\t\tmidi1->pg.program = midi2->pg.program;\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CHANNEL_PRESSURE:\n\t\tmidi1->caf.data = downscale_32_to_7bit(midi2->caf.data);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PITCH_BEND:\n\t\tv = downscale_32_to_14bit(midi2->pb.data);\n\t\tmidi1->pb.data_msb = v >> 7;\n\t\tmidi1->pb.data_lsb = v & 0x7f;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t      (struct snd_seq_event *)&ev_cvt,\n\t\t\t\t\t      atomic, hop);\n}\n\n \nstatic int cvt_ump_to_any(struct snd_seq_client *dest,\n\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t  struct snd_seq_event *event,\n\t\t\t  unsigned char type,\n\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_event ev_cvt[2];  \n\tstruct snd_seq_ump_event *ump_ev = (struct snd_seq_ump_event *)event;\n\t \n\tunsigned char *sysex_buf = (unsigned char *)(ev_cvt + 1);\n\tunsigned char flags = event->flags & ~SNDRV_SEQ_EVENT_UMP;\n\tint i, len, err;\n\n\tev_cvt[0] = ev_cvt[1] = *event;\n\tev_cvt[0].flags = flags;\n\tev_cvt[1].flags = flags;\n\tswitch (type) {\n\tcase UMP_MSG_TYPE_SYSTEM:\n\t\tlen = cvt_ump_system_to_event((union snd_ump_midi1_msg *)ump_ev->ump,\n\t\t\t\t\t      ev_cvt);\n\t\tbreak;\n\tcase UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE:\n\t\tlen = cvt_ump_midi1_to_event((union snd_ump_midi1_msg *)ump_ev->ump,\n\t\t\t\t\t     ev_cvt);\n\t\tbreak;\n\tcase UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE:\n\t\tlen = cvt_ump_midi2_to_event((union snd_ump_midi2_msg *)ump_ev->ump,\n\t\t\t\t\t     ev_cvt);\n\t\tbreak;\n\tcase UMP_MSG_TYPE_DATA:\n\t\tlen = cvt_ump_sysex7_to_event(ump_ev->ump, sysex_buf, ev_cvt);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\terr = __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t     &ev_cvt[i], atomic, hop);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int deliver_with_group_convert(struct snd_seq_client *dest,\n\t\t\t\t      struct snd_seq_client_port *dest_port,\n\t\t\t\t      struct snd_seq_ump_event *ump_ev,\n\t\t\t\t      int atomic, int hop)\n{\n\tstruct snd_seq_ump_event ev = *ump_ev;\n\n\t \n\tev.ump[0] &= ~(0xfU << 24);\n\t \n\tev.ump[0] |= ((dest_port->ump_group - 1) << 24);\n\n\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t      (struct snd_seq_event *)&ev,\n\t\t\t\t\t      atomic, hop);\n}\n\n \nstatic bool ump_event_filtered(struct snd_seq_client *dest,\n\t\t\t       const struct snd_seq_ump_event *ev)\n{\n\tunsigned char group;\n\n\tgroup = ump_message_group(ev->ump[0]);\n\tif (ump_is_groupless_msg(ump_message_type(ev->ump[0])))\n\t\treturn dest->group_filter & (1U << 0);\n\t \n\treturn dest->group_filter & (1U << (group + 1));\n}\n\n \nint snd_seq_deliver_from_ump(struct snd_seq_client *source,\n\t\t\t     struct snd_seq_client *dest,\n\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t     struct snd_seq_event *event,\n\t\t\t     int atomic, int hop)\n{\n\tstruct snd_seq_ump_event *ump_ev = (struct snd_seq_ump_event *)event;\n\tunsigned char type;\n\n\tif (snd_seq_ev_is_variable(event))\n\t\treturn 0;  \n\tif (ump_event_filtered(dest, ump_ev))\n\t\treturn 0;  \n\ttype = ump_message_type(ump_ev->ump[0]);\n\n\tif (snd_seq_client_is_ump(dest)) {\n\t\tif (snd_seq_client_is_midi2(dest) &&\n\t\t    type == UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE)\n\t\t\treturn cvt_ump_midi1_to_midi2(dest, dest_port,\n\t\t\t\t\t\t      event, atomic, hop);\n\t\telse if (!snd_seq_client_is_midi2(dest) &&\n\t\t\t type == UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE)\n\t\t\treturn cvt_ump_midi2_to_midi1(dest, dest_port,\n\t\t\t\t\t\t      event, atomic, hop);\n\t\t \n\t\tif (dest_port->ump_group &&\n\t\t    !ump_is_groupless_msg(type) &&\n\t\t    ump_message_group(*ump_ev->ump) + 1 != dest_port->ump_group)\n\t\t\treturn deliver_with_group_convert(dest, dest_port,\n\t\t\t\t\t\t\t  ump_ev, atomic, hop);\n\t\t \n\t\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t      event, atomic, hop);\n\t}\n\n\treturn cvt_ump_to_any(dest, dest_port, event, type, atomic, hop);\n}\n\n \n\n \n\n \nstatic int note_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\tstruct snd_seq_client_port *dest_port,\n\t\t\t\tunion snd_ump_midi1_msg *data,\n\t\t\t\tunsigned char status)\n{\n\tif (!event->data.note.velocity)\n\t\tstatus = UMP_MSG_STATUS_NOTE_OFF;\n\tdata->note.status = status;\n\tdata->note.channel = event->data.note.channel & 0x0f;\n\tdata->note.velocity = event->data.note.velocity & 0x7f;\n\tdata->note.note = event->data.note.note & 0x7f;\n\treturn 1;\n}\n\n \nstatic int cc_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t      struct snd_seq_client_port *dest_port,\n\t\t\t      union snd_ump_midi1_msg *data,\n\t\t\t      unsigned char status)\n{\n\tdata->cc.status = status;\n\tdata->cc.channel = event->data.control.channel & 0x0f;\n\tdata->cc.index = event->data.control.param;\n\tdata->cc.data = event->data.control.value;\n\treturn 1;\n}\n\n \nstatic int ctrl_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\tstruct snd_seq_client_port *dest_port,\n\t\t\t\tunion snd_ump_midi1_msg *data,\n\t\t\t\tunsigned char status)\n{\n\tdata->caf.status = status;\n\tdata->caf.channel = event->data.control.channel & 0x0f;\n\tdata->caf.data = event->data.control.value & 0x7f;\n\treturn 1;\n}\n\n \nstatic int pitchbend_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi1_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\tint val = event->data.control.value + 8192;\n\n\tval = clamp(val, 0, 0x3fff);\n\tdata->pb.status = status;\n\tdata->pb.channel = event->data.control.channel & 0x0f;\n\tdata->pb.data_msb = (val >> 7) & 0x7f;\n\tdata->pb.data_lsb = val & 0x7f;\n\treturn 1;\n}\n\n \nstatic int ctrl14_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  union snd_ump_midi1_msg *data,\n\t\t\t\t  unsigned char status)\n{\n\tdata->cc.status = UMP_MSG_STATUS_CC;\n\tdata->cc.channel = event->data.control.channel & 0x0f;\n\tdata->cc.index = event->data.control.param & 0x7f;\n\tif (event->data.control.param < 0x20) {\n\t\tdata->cc.data = (event->data.control.value >> 7) & 0x7f;\n\t\tdata[1] = data[0];\n\t\tdata[1].cc.index = event->data.control.param | 0x20;\n\t\tdata[1].cc.data = event->data.control.value & 0x7f;\n\t\treturn 2;\n\t}\n\n\tdata->cc.data = event->data.control.value & 0x7f;\n\treturn 1;\n}\n\n \nstatic int rpn_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t       struct snd_seq_client_port *dest_port,\n\t\t\t       union snd_ump_midi1_msg *data,\n\t\t\t       unsigned char status)\n{\n\tbool is_rpn = (status == UMP_MSG_STATUS_RPN);\n\n\tdata->cc.status = UMP_MSG_STATUS_CC;\n\tdata->cc.channel = event->data.control.channel & 0x0f;\n\tdata[1] = data[2] = data[3] = data[0];\n\n\tdata[0].cc.index = is_rpn ? UMP_CC_RPN_MSB : UMP_CC_NRPN_MSB;\n\tdata[0].cc.data = (event->data.control.param >> 7) & 0x7f;\n\tdata[1].cc.index = is_rpn ? UMP_CC_RPN_LSB : UMP_CC_NRPN_LSB;\n\tdata[1].cc.data = event->data.control.param & 0x7f;\n\tdata[2].cc.index = UMP_CC_DATA;\n\tdata[2].cc.data = (event->data.control.value >> 7) & 0x7f;\n\tdata[3].cc.index = UMP_CC_DATA_LSB;\n\tdata[3].cc.data = event->data.control.value & 0x7f;\n\treturn 4;\n}\n\n \nstatic int system_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  union snd_ump_midi1_msg *data,\n\t\t\t\t  unsigned char status)\n{\n\tdata->system.status = status;\n\treturn 1;\n}\n\n \nstatic int system_1p_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi1_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\tdata->system.status = status;\n\tdata->system.parm1 = event->data.control.value & 0x7f;\n\treturn 1;\n}\n\n \nstatic int system_2p_ev_to_ump_midi1(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi1_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\tdata->system.status = status;\n\tdata->system.parm1 = (event->data.control.value >> 7) & 0x7f;\n\tdata->system.parm2 = event->data.control.value & 0x7f;\n\treturn 1;\n}\n\n \n\n \nstatic int note_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\tstruct snd_seq_client_port *dest_port,\n\t\t\t\tunion snd_ump_midi2_msg *data,\n\t\t\t\tunsigned char status)\n{\n\tif (!event->data.note.velocity)\n\t\tstatus = UMP_MSG_STATUS_NOTE_OFF;\n\tdata->note.status = status;\n\tdata->note.channel = event->data.note.channel & 0x0f;\n\tdata->note.note = event->data.note.note & 0x7f;\n\tdata->note.velocity = upscale_7_to_16bit(event->data.note.velocity & 0x7f);\n\treturn 1;\n}\n\n \nstatic int paf_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t       struct snd_seq_client_port *dest_port,\n\t\t\t       union snd_ump_midi2_msg *data,\n\t\t\t       unsigned char status)\n{\n\tdata->paf.status = status;\n\tdata->paf.channel = event->data.note.channel & 0x0f;\n\tdata->paf.note = event->data.note.note & 0x7f;\n\tdata->paf.data = upscale_7_to_32bit(event->data.note.velocity & 0x7f);\n\treturn 1;\n}\n\n \nstatic void fill_rpn(struct snd_seq_ump_midi2_bank *cc,\n\t\t     union snd_ump_midi2_msg *data)\n{\n\tif (cc->rpn_set) {\n\t\tdata->rpn.status = UMP_MSG_STATUS_RPN;\n\t\tdata->rpn.bank = cc->cc_rpn_msb;\n\t\tdata->rpn.index = cc->cc_rpn_lsb;\n\t\tcc->rpn_set = 0;\n\t\tcc->cc_rpn_msb = cc->cc_rpn_lsb = 0;\n\t} else {\n\t\tdata->rpn.status = UMP_MSG_STATUS_NRPN;\n\t\tdata->rpn.bank = cc->cc_nrpn_msb;\n\t\tdata->rpn.index = cc->cc_nrpn_lsb;\n\t\tcc->nrpn_set = 0;\n\t\tcc->cc_nrpn_msb = cc->cc_nrpn_lsb = 0;\n\t}\n\tdata->rpn.data = upscale_14_to_32bit((cc->cc_data_msb << 7) |\n\t\t\t\t\t     cc->cc_data_lsb);\n\tcc->cc_data_msb = cc->cc_data_lsb = 0;\n}\n\n \nstatic int cc_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t      struct snd_seq_client_port *dest_port,\n\t\t\t      union snd_ump_midi2_msg *data,\n\t\t\t      unsigned char status)\n{\n\tunsigned char channel = event->data.control.channel & 0x0f;\n\tunsigned char index = event->data.control.param & 0x7f;\n\tunsigned char val = event->data.control.value & 0x7f;\n\tstruct snd_seq_ump_midi2_bank *cc = &dest_port->midi2_bank[channel];\n\n\t \n\tswitch (index) {\n\tcase UMP_CC_RPN_MSB:\n\t\tcc->rpn_set = 1;\n\t\tcc->cc_rpn_msb = val;\n\t\treturn 0; \n\tcase UMP_CC_RPN_LSB:\n\t\tcc->rpn_set = 1;\n\t\tcc->cc_rpn_lsb = val;\n\t\treturn 0; \n\tcase UMP_CC_NRPN_MSB:\n\t\tcc->nrpn_set = 1;\n\t\tcc->cc_nrpn_msb = val;\n\t\treturn 0; \n\tcase UMP_CC_NRPN_LSB:\n\t\tcc->nrpn_set = 1;\n\t\tcc->cc_nrpn_lsb = val;\n\t\treturn 0; \n\tcase UMP_CC_DATA:\n\t\tcc->cc_data_msb = val;\n\t\treturn 0; \n\tcase UMP_CC_BANK_SELECT:\n\t\tcc->bank_set = 1;\n\t\tcc->cc_bank_msb = val;\n\t\treturn 0; \n\tcase UMP_CC_BANK_SELECT_LSB:\n\t\tcc->bank_set = 1;\n\t\tcc->cc_bank_lsb = val;\n\t\treturn 0; \n\tcase UMP_CC_DATA_LSB:\n\t\tcc->cc_data_lsb = val;\n\t\tif (!(cc->rpn_set || cc->nrpn_set))\n\t\t\treturn 0; \n\t\tfill_rpn(cc, data);\n\t\treturn 1;\n\t}\n\n\tdata->cc.status = status;\n\tdata->cc.channel = channel;\n\tdata->cc.index = index;\n\tdata->cc.data = upscale_7_to_32bit(event->data.control.value & 0x7f);\n\treturn 1;\n}\n\n \nstatic int ctrl_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\tstruct snd_seq_client_port *dest_port,\n\t\t\t\tunion snd_ump_midi2_msg *data,\n\t\t\t\tunsigned char status)\n{\n\tdata->caf.status = status;\n\tdata->caf.channel = event->data.control.channel & 0x0f;\n\tdata->caf.data = upscale_7_to_32bit(event->data.control.value & 0x7f);\n\treturn 1;\n}\n\n \nstatic int pgm_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t       struct snd_seq_client_port *dest_port,\n\t\t\t       union snd_ump_midi2_msg *data,\n\t\t\t       unsigned char status)\n{\n\tunsigned char channel = event->data.control.channel & 0x0f;\n\tstruct snd_seq_ump_midi2_bank *cc = &dest_port->midi2_bank[channel];\n\n\tdata->pg.status = status;\n\tdata->pg.channel = channel;\n\tdata->pg.program = event->data.control.value & 0x7f;\n\tif (cc->bank_set) {\n\t\tdata->pg.bank_valid = 1;\n\t\tdata->pg.bank_msb = cc->cc_bank_msb;\n\t\tdata->pg.bank_lsb = cc->cc_bank_lsb;\n\t\tcc->bank_set = 0;\n\t\tcc->cc_bank_msb = cc->cc_bank_lsb = 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int pitchbend_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi2_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\tint val = event->data.control.value + 8192;\n\n\tval = clamp(val, 0, 0x3fff);\n\tdata->pb.status = status;\n\tdata->pb.channel = event->data.control.channel & 0x0f;\n\tdata->pb.data = upscale_14_to_32bit(val);\n\treturn 1;\n}\n\n \nstatic int ctrl14_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  union snd_ump_midi2_msg *data,\n\t\t\t\t  unsigned char status)\n{\n\tunsigned char channel = event->data.control.channel & 0x0f;\n\tunsigned char index = event->data.control.param & 0x7f;\n\tstruct snd_seq_ump_midi2_bank *cc = &dest_port->midi2_bank[channel];\n\tunsigned char msb, lsb;\n\n\tmsb = (event->data.control.value >> 7) & 0x7f;\n\tlsb = event->data.control.value & 0x7f;\n\t \n\tswitch (index) {\n\tcase UMP_CC_BANK_SELECT:\n\t\tcc->cc_bank_msb = msb;\n\t\tfallthrough;\n\tcase UMP_CC_BANK_SELECT_LSB:\n\t\tcc->bank_set = 1;\n\t\tcc->cc_bank_lsb = lsb;\n\t\treturn 0; \n\tcase UMP_CC_RPN_MSB:\n\t\tcc->cc_rpn_msb = msb;\n\t\tfallthrough;\n\tcase UMP_CC_RPN_LSB:\n\t\tcc->rpn_set = 1;\n\t\tcc->cc_rpn_lsb = lsb;\n\t\treturn 0; \n\tcase UMP_CC_NRPN_MSB:\n\t\tcc->cc_nrpn_msb = msb;\n\t\tfallthrough;\n\tcase UMP_CC_NRPN_LSB:\n\t\tcc->nrpn_set = 1;\n\t\tcc->cc_nrpn_lsb = lsb;\n\t\treturn 0; \n\tcase UMP_CC_DATA:\n\t\tcc->cc_data_msb = msb;\n\t\tfallthrough;\n\tcase UMP_CC_DATA_LSB:\n\t\tcc->cc_data_lsb = lsb;\n\t\tif (!(cc->rpn_set || cc->nrpn_set))\n\t\t\treturn 0; \n\t\tfill_rpn(cc, data);\n\t\treturn 1;\n\t}\n\n\tdata->cc.status = UMP_MSG_STATUS_CC;\n\tdata->cc.channel = channel;\n\tdata->cc.index = index;\n\tif (event->data.control.param < 0x20) {\n\t\tdata->cc.data = upscale_7_to_32bit(msb);\n\t\tdata[1] = data[0];\n\t\tdata[1].cc.index = event->data.control.param | 0x20;\n\t\tdata[1].cc.data = upscale_7_to_32bit(lsb);\n\t\treturn 2;\n\t}\n\n\tdata->cc.data = upscale_7_to_32bit(lsb);\n\treturn 1;\n}\n\n \nstatic int rpn_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t       struct snd_seq_client_port *dest_port,\n\t\t\t       union snd_ump_midi2_msg *data,\n\t\t\t       unsigned char status)\n{\n\tdata->rpn.status = status;\n\tdata->rpn.channel = event->data.control.channel;\n\tdata->rpn.bank = (event->data.control.param >> 7) & 0x7f;\n\tdata->rpn.index = event->data.control.param & 0x7f;\n\tdata->rpn.data = upscale_14_to_32bit(event->data.control.value & 0x3fff);\n\treturn 1;\n}\n\n \nstatic int system_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\t  struct snd_seq_client_port *dest_port,\n\t\t\t\t  union snd_ump_midi2_msg *data,\n\t\t\t\t  unsigned char status)\n{\n\treturn system_ev_to_ump_midi1(event, dest_port,\n\t\t\t\t      (union snd_ump_midi1_msg *)data,\n\t\t\t\t      status);\n}\n\n \nstatic int system_1p_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi2_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\treturn system_1p_ev_to_ump_midi1(event, dest_port,\n\t\t\t\t\t (union snd_ump_midi1_msg *)data,\n\t\t\t\t\t status);\n}\n\n \nstatic int system_2p_ev_to_ump_midi2(const struct snd_seq_event *event,\n\t\t\t\t     struct snd_seq_client_port *dest_port,\n\t\t\t\t     union snd_ump_midi2_msg *data,\n\t\t\t\t     unsigned char status)\n{\n\treturn system_1p_ev_to_ump_midi1(event, dest_port,\n\t\t\t\t\t (union snd_ump_midi1_msg *)data,\n\t\t\t\t\t status);\n}\n\nstruct seq_ev_to_ump {\n\tint seq_type;\n\tunsigned char status;\n\tint (*midi1_encode)(const struct snd_seq_event *event,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    union snd_ump_midi1_msg *data,\n\t\t\t    unsigned char status);\n\tint (*midi2_encode)(const struct snd_seq_event *event,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    union snd_ump_midi2_msg *data,\n\t\t\t    unsigned char status);\n};\n\nstatic const struct seq_ev_to_ump seq_ev_ump_encoders[] = {\n\t{ SNDRV_SEQ_EVENT_NOTEON, UMP_MSG_STATUS_NOTE_ON,\n\t  note_ev_to_ump_midi1, note_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_NOTEOFF, UMP_MSG_STATUS_NOTE_OFF,\n\t  note_ev_to_ump_midi1, note_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_KEYPRESS, UMP_MSG_STATUS_POLY_PRESSURE,\n\t  note_ev_to_ump_midi1, paf_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_CONTROLLER, UMP_MSG_STATUS_CC,\n\t  cc_ev_to_ump_midi1, cc_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_PGMCHANGE, UMP_MSG_STATUS_PROGRAM,\n\t  ctrl_ev_to_ump_midi1, pgm_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_CHANPRESS, UMP_MSG_STATUS_CHANNEL_PRESSURE,\n\t  ctrl_ev_to_ump_midi1, ctrl_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_PITCHBEND, UMP_MSG_STATUS_PITCH_BEND,\n\t  pitchbend_ev_to_ump_midi1, pitchbend_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_CONTROL14, 0,\n\t  ctrl14_ev_to_ump_midi1, ctrl14_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_NONREGPARAM, UMP_MSG_STATUS_NRPN,\n\t  rpn_ev_to_ump_midi1, rpn_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_REGPARAM, UMP_MSG_STATUS_RPN,\n\t  rpn_ev_to_ump_midi1, rpn_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_QFRAME, UMP_SYSTEM_STATUS_MIDI_TIME_CODE,\n\t  system_1p_ev_to_ump_midi1, system_1p_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_SONGPOS, UMP_SYSTEM_STATUS_SONG_POSITION,\n\t  system_2p_ev_to_ump_midi1, system_2p_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_SONGSEL, UMP_SYSTEM_STATUS_SONG_SELECT,\n\t  system_1p_ev_to_ump_midi1, system_1p_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_TUNE_REQUEST, UMP_SYSTEM_STATUS_TUNE_REQUEST,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_CLOCK, UMP_SYSTEM_STATUS_TIMING_CLOCK,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_START, UMP_SYSTEM_STATUS_START,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_CONTINUE, UMP_SYSTEM_STATUS_CONTINUE,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_STOP, UMP_SYSTEM_STATUS_STOP,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n\t{ SNDRV_SEQ_EVENT_SENSING, UMP_SYSTEM_STATUS_ACTIVE_SENSING,\n\t  system_ev_to_ump_midi1, system_ev_to_ump_midi2 },\n};\n\nstatic const struct seq_ev_to_ump *find_ump_encoder(int type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(seq_ev_ump_encoders); i++)\n\t\tif (seq_ev_ump_encoders[i].seq_type == type)\n\t\t\treturn &seq_ev_ump_encoders[i];\n\n\treturn NULL;\n}\n\nstatic void setup_ump_event(struct snd_seq_ump_event *dest,\n\t\t\t    const struct snd_seq_event *src)\n{\n\tmemcpy(dest, src, sizeof(*src));\n\tdest->type = 0;\n\tdest->flags |= SNDRV_SEQ_EVENT_UMP;\n\tdest->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\n\tmemset(dest->ump, 0, sizeof(dest->ump));\n}\n\n \nstatic int cvt_to_ump_midi1(struct snd_seq_client *dest,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_event *event,\n\t\t\t    int atomic, int hop)\n{\n\tconst struct seq_ev_to_ump *encoder;\n\tstruct snd_seq_ump_event ev_cvt;\n\tunion snd_ump_midi1_msg data[4];\n\tint i, n, err;\n\n\tencoder = find_ump_encoder(event->type);\n\tif (!encoder)\n\t\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t      event, atomic, hop);\n\n\tdata->raw = make_raw_ump(dest_port, UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE);\n\tn = encoder->midi1_encode(event, dest_port, data, encoder->status);\n\tif (!n)\n\t\treturn 0;\n\n\tsetup_ump_event(&ev_cvt, event);\n\tfor (i = 0; i < n; i++) {\n\t\tev_cvt.ump[0] = data[i].raw;\n\t\terr = __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t     (struct snd_seq_event *)&ev_cvt,\n\t\t\t\t\t\t     atomic, hop);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cvt_to_ump_midi2(struct snd_seq_client *dest,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_event *event,\n\t\t\t    int atomic, int hop)\n{\n\tconst struct seq_ev_to_ump *encoder;\n\tstruct snd_seq_ump_event ev_cvt;\n\tunion snd_ump_midi2_msg data[2];\n\tint i, n, err;\n\n\tencoder = find_ump_encoder(event->type);\n\tif (!encoder)\n\t\treturn __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t      event, atomic, hop);\n\n\tdata->raw[0] = make_raw_ump(dest_port, UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE);\n\tdata->raw[1] = 0;\n\tn = encoder->midi2_encode(event, dest_port, data, encoder->status);\n\tif (!n)\n\t\treturn 0;\n\n\tsetup_ump_event(&ev_cvt, event);\n\tfor (i = 0; i < n; i++) {\n\t\tmemcpy(ev_cvt.ump, &data[i], sizeof(data[i]));\n\t\terr = __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t     (struct snd_seq_event *)&ev_cvt,\n\t\t\t\t\t\t     atomic, hop);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fill_sysex7_ump(struct snd_seq_client_port *dest_port,\n\t\t\t    u32 *val, u8 status, u8 *buf, int len)\n{\n\tmemset(val, 0, 8);\n\tmemcpy((u8 *)val + 2, buf, len);\n#ifdef __LITTLE_ENDIAN\n\tswab32_array(val, 2);\n#endif\n\tval[0] |= ump_compose(UMP_MSG_TYPE_DATA, get_ump_group(dest_port),\n\t\t\t      status, len);\n}\n\n \nstatic int cvt_sysex_to_ump(struct snd_seq_client *dest,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_event *event,\n\t\t\t    int atomic, int hop)\n{\n\tstruct snd_seq_ump_event ev_cvt;\n\tunsigned char status;\n\tu8 buf[6], *xbuf;\n\tint offset = 0;\n\tint len, err;\n\n\tif (!snd_seq_ev_is_variable(event))\n\t\treturn 0;\n\n\tsetup_ump_event(&ev_cvt, event);\n\tfor (;;) {\n\t\tlen = snd_seq_expand_var_event_at(event, sizeof(buf), buf, offset);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (WARN_ON(len > 6))\n\t\t\tbreak;\n\t\toffset += len;\n\t\txbuf = buf;\n\t\tif (*xbuf == UMP_MIDI1_MSG_SYSEX_START) {\n\t\t\tstatus = UMP_SYSEX_STATUS_START;\n\t\t\txbuf++;\n\t\t\tlen--;\n\t\t\tif (len > 0 && xbuf[len - 1] == UMP_MIDI1_MSG_SYSEX_END) {\n\t\t\t\tstatus = UMP_SYSEX_STATUS_SINGLE;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t} else {\n\t\t\tif (xbuf[len - 1] == UMP_MIDI1_MSG_SYSEX_END) {\n\t\t\t\tstatus = UMP_SYSEX_STATUS_END;\n\t\t\t\tlen--;\n\t\t\t} else {\n\t\t\t\tstatus = UMP_SYSEX_STATUS_CONTINUE;\n\t\t\t}\n\t\t}\n\t\tfill_sysex7_ump(dest_port, ev_cvt.ump, status, xbuf, len);\n\t\terr = __snd_seq_deliver_single_event(dest, dest_port,\n\t\t\t\t\t\t     (struct snd_seq_event *)&ev_cvt,\n\t\t\t\t\t\t     atomic, hop);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nint snd_seq_deliver_to_ump(struct snd_seq_client *source,\n\t\t\t   struct snd_seq_client *dest,\n\t\t\t   struct snd_seq_client_port *dest_port,\n\t\t\t   struct snd_seq_event *event,\n\t\t\t   int atomic, int hop)\n{\n\tif (dest->group_filter & (1U << dest_port->ump_group))\n\t\treturn 0;  \n\tif (event->type == SNDRV_SEQ_EVENT_SYSEX)\n\t\treturn cvt_sysex_to_ump(dest, dest_port, event, atomic, hop);\n\telse if (snd_seq_client_is_midi2(dest))\n\t\treturn cvt_to_ump_midi2(dest, dest_port, event, atomic, hop);\n\telse\n\t\treturn cvt_to_ump_midi1(dest, dest_port, event, atomic, hop);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}