{
  "module_name": "seq_prioq.c",
  "hash_id": "a2f95626465e58f6d89fd8ecbf58e076136d84078f9c32426922abc454755ec4",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_prioq.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include \"seq_timer.h\"\n#include \"seq_prioq.h\"\n\n\n \n\n\n\n \nstruct snd_seq_prioq *snd_seq_prioq_new(void)\n{\n\tstruct snd_seq_prioq *f;\n\n\tf = kzalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\t\n\tspin_lock_init(&f->lock);\n\tf->head = NULL;\n\tf->tail = NULL;\n\tf->cells = 0;\n\t\n\treturn f;\n}\n\n \nvoid snd_seq_prioq_delete(struct snd_seq_prioq **fifo)\n{\n\tstruct snd_seq_prioq *f = *fifo;\n\t*fifo = NULL;\n\n\tif (f == NULL) {\n\t\tpr_debug(\"ALSA: seq: snd_seq_prioq_delete() called with NULL prioq\\n\");\n\t\treturn;\n\t}\n\n\t \n\t \n\t\n\tif (f->cells > 0) {\n\t\t \n\t\twhile (f->cells > 0)\n\t\t\tsnd_seq_cell_free(snd_seq_prioq_cell_out(f, NULL));\n\t}\n\t\n\tkfree(f);\n}\n\n\n\n\n \n \nstatic inline int compare_timestamp(struct snd_seq_event *a,\n\t\t\t\t    struct snd_seq_event *b)\n{\n\tif ((a->flags & SNDRV_SEQ_TIME_STAMP_MASK) == SNDRV_SEQ_TIME_STAMP_TICK) {\n\t\t \n\t\treturn (snd_seq_compare_tick_time(&a->time.tick, &b->time.tick));\n\t} else {\n\t\t \n\t\treturn (snd_seq_compare_real_time(&a->time.time, &b->time.time));\n\t}\n}\n\n \n \nstatic inline int compare_timestamp_rel(struct snd_seq_event *a,\n\t\t\t\t\tstruct snd_seq_event *b)\n{\n\tif ((a->flags & SNDRV_SEQ_TIME_STAMP_MASK) == SNDRV_SEQ_TIME_STAMP_TICK) {\n\t\t \n\t\tif (a->time.tick > b->time.tick)\n\t\t\treturn 1;\n\t\telse if (a->time.tick == b->time.tick)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -1;\n\t} else {\n\t\t \n\t\tif (a->time.time.tv_sec > b->time.time.tv_sec)\n\t\t\treturn 1;\n\t\telse if (a->time.time.tv_sec == b->time.time.tv_sec) {\n\t\t\tif (a->time.time.tv_nsec > b->time.time.tv_nsec)\n\t\t\t\treturn 1;\n\t\t\telse if (a->time.time.tv_nsec == b->time.time.tv_nsec)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t} else\n\t\t\treturn -1;\n\t}\n}\n\n \nint snd_seq_prioq_cell_in(struct snd_seq_prioq * f,\n\t\t\t  struct snd_seq_event_cell * cell)\n{\n\tstruct snd_seq_event_cell *cur, *prev;\n\tunsigned long flags;\n\tint count;\n\tint prior;\n\n\tif (snd_BUG_ON(!f || !cell))\n\t\treturn -EINVAL;\n\t\n\t \n\tprior = (cell->event.flags & SNDRV_SEQ_PRIORITY_MASK);\n\n\tspin_lock_irqsave(&f->lock, flags);\n\n\t \n\tif (f->tail && !prior) {\n\t\tif (compare_timestamp(&cell->event, &f->tail->event)) {\n\t\t\t \n\t\t\tf->tail->next = cell;\n\t\t\tf->tail = cell;\n\t\t\tcell->next = NULL;\n\t\t\tf->cells++;\n\t\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\n\tprev = NULL;\t\t \n\tcur = f->head;\t\t \n\n\tcount = 10000;  \n\twhile (cur != NULL) {\n\t\t \n\t\tint rel = compare_timestamp_rel(&cell->event, &cur->event);\n\t\tif (rel < 0)\n\t\t\t \n\t\t\tbreak;\n\t\telse if (rel == 0 && prior)\n\t\t\t \n\t\t\tbreak;\n\t\t \n\t\t \n\t\tprev = cur;\n\t\tcur = cur->next;\n\t\tif (! --count) {\n\t\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t\t\tpr_err(\"ALSA: seq: cannot find a pointer.. infinite loop?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (prev != NULL)\n\t\tprev->next = cell;\n\tcell->next = cur;\n\n\tif (f->head == cur)  \n\t\tf->head = cell;\n\tif (cur == NULL)  \n\t\tf->tail = cell;\n\tf->cells++;\n\tspin_unlock_irqrestore(&f->lock, flags);\n\treturn 0;\n}\n\n \nstatic int event_is_ready(struct snd_seq_event *ev, void *current_time)\n{\n\tif ((ev->flags & SNDRV_SEQ_TIME_STAMP_MASK) == SNDRV_SEQ_TIME_STAMP_TICK)\n\t\treturn snd_seq_compare_tick_time(current_time, &ev->time.tick);\n\telse\n\t\treturn snd_seq_compare_real_time(current_time, &ev->time.time);\n}\n\n \nstruct snd_seq_event_cell *snd_seq_prioq_cell_out(struct snd_seq_prioq *f,\n\t\t\t\t\t\t  void *current_time)\n{\n\tstruct snd_seq_event_cell *cell;\n\tunsigned long flags;\n\n\tif (f == NULL) {\n\t\tpr_debug(\"ALSA: seq: snd_seq_prioq_cell_in() called with NULL prioq\\n\");\n\t\treturn NULL;\n\t}\n\tspin_lock_irqsave(&f->lock, flags);\n\n\tcell = f->head;\n\tif (cell && current_time && !event_is_ready(&cell->event, current_time))\n\t\tcell = NULL;\n\tif (cell) {\n\t\tf->head = cell->next;\n\n\t\t \n\t\tif (f->tail == cell)\n\t\t\tf->tail = NULL;\n\n\t\tcell->next = NULL;\n\t\tf->cells--;\n\t}\n\n\tspin_unlock_irqrestore(&f->lock, flags);\n\treturn cell;\n}\n\n \nint snd_seq_prioq_avail(struct snd_seq_prioq * f)\n{\n\tif (f == NULL) {\n\t\tpr_debug(\"ALSA: seq: snd_seq_prioq_cell_in() called with NULL prioq\\n\");\n\t\treturn 0;\n\t}\n\treturn f->cells;\n}\n\nstatic inline int prioq_match(struct snd_seq_event_cell *cell,\n\t\t\t      int client, int timestamp)\n{\n\tif (cell->event.source.client == client ||\n\t    cell->event.dest.client == client)\n\t\treturn 1;\n\tif (!timestamp)\n\t\treturn 0;\n\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\tif (cell->event.time.tick)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\tif (cell->event.time.time.tv_sec ||\n\t\t    cell->event.time.time.tv_nsec)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nvoid snd_seq_prioq_leave(struct snd_seq_prioq * f, int client, int timestamp)\n{\n\tregister struct snd_seq_event_cell *cell, *next;\n\tunsigned long flags;\n\tstruct snd_seq_event_cell *prev = NULL;\n\tstruct snd_seq_event_cell *freefirst = NULL, *freeprev = NULL, *freenext;\n\n\t \n\tspin_lock_irqsave(&f->lock, flags);\n\tcell = f->head;\n\twhile (cell) {\n\t\tnext = cell->next;\n\t\tif (prioq_match(cell, client, timestamp)) {\n\t\t\t \n\t\t\tif (cell == f->head) {\n\t\t\t\tf->head = cell->next;\n\t\t\t} else {\n\t\t\t\tprev->next = cell->next;\n\t\t\t}\n\t\t\tif (cell == f->tail)\n\t\t\t\tf->tail = cell->next;\n\t\t\tf->cells--;\n\t\t\t \n\t\t\tcell->next = NULL;\n\t\t\tif (freefirst == NULL) {\n\t\t\t\tfreefirst = cell;\n\t\t\t} else {\n\t\t\t\tfreeprev->next = cell;\n\t\t\t}\n\t\t\tfreeprev = cell;\n\t\t} else {\n#if 0\n\t\t\tpr_debug(\"ALSA: seq: type = %i, source = %i, dest = %i, \"\n\t\t\t       \"client = %i\\n\",\n\t\t\t\tcell->event.type,\n\t\t\t\tcell->event.source.client,\n\t\t\t\tcell->event.dest.client,\n\t\t\t\tclient);\n#endif\n\t\t\tprev = cell;\n\t\t}\n\t\tcell = next;\t\t\n\t}\n\tspin_unlock_irqrestore(&f->lock, flags);\t\n\n\t \n\twhile (freefirst) {\n\t\tfreenext = freefirst->next;\n\t\tsnd_seq_cell_free(freefirst);\n\t\tfreefirst = freenext;\n\t}\n}\n\nstatic int prioq_remove_match(struct snd_seq_remove_events *info,\n\t\t\t      struct snd_seq_event *ev)\n{\n\tint res;\n\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) {\n\t\tif (ev->dest.client != info->dest.client ||\n\t\t\t\tev->dest.port != info->dest.port)\n\t\t\treturn 0;\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_DEST_CHANNEL) {\n\t\tif (! snd_seq_ev_is_channel_type(ev))\n\t\t\treturn 0;\n\t\t \n\t\tif (ev->data.note.channel != info->channel)\n\t\t\treturn 0;\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_AFTER) {\n\t\tif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_TICK)\n\t\t\tres = snd_seq_compare_tick_time(&ev->time.tick, &info->time.tick);\n\t\telse\n\t\t\tres = snd_seq_compare_real_time(&ev->time.time, &info->time.time);\n\t\tif (!res)\n\t\t\treturn 0;\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_BEFORE) {\n\t\tif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_TICK)\n\t\t\tres = snd_seq_compare_tick_time(&ev->time.tick, &info->time.tick);\n\t\telse\n\t\t\tres = snd_seq_compare_real_time(&ev->time.time, &info->time.time);\n\t\tif (res)\n\t\t\treturn 0;\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_EVENT_TYPE) {\n\t\tif (ev->type != info->type)\n\t\t\treturn 0;\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_IGNORE_OFF) {\n\t\t \n\t\tswitch (ev->type) {\n\t\tcase SNDRV_SEQ_EVENT_NOTEOFF:\n\t\t \n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_TAG_MATCH) {\n\t\tif (info->tag != ev->tag)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nvoid snd_seq_prioq_remove_events(struct snd_seq_prioq * f, int client,\n\t\t\t\t struct snd_seq_remove_events *info)\n{\n\tstruct snd_seq_event_cell *cell, *next;\n\tunsigned long flags;\n\tstruct snd_seq_event_cell *prev = NULL;\n\tstruct snd_seq_event_cell *freefirst = NULL, *freeprev = NULL, *freenext;\n\n\t \n\tspin_lock_irqsave(&f->lock, flags);\n\tcell = f->head;\n\n\twhile (cell) {\n\t\tnext = cell->next;\n\t\tif (cell->event.source.client == client &&\n\t\t\tprioq_remove_match(info, &cell->event)) {\n\n\t\t\t \n\t\t\tif (cell == f->head) {\n\t\t\t\tf->head = cell->next;\n\t\t\t} else {\n\t\t\t\tprev->next = cell->next;\n\t\t\t}\n\n\t\t\tif (cell == f->tail)\n\t\t\t\tf->tail = cell->next;\n\t\t\tf->cells--;\n\n\t\t\t \n\t\t\tcell->next = NULL;\n\t\t\tif (freefirst == NULL) {\n\t\t\t\tfreefirst = cell;\n\t\t\t} else {\n\t\t\t\tfreeprev->next = cell;\n\t\t\t}\n\n\t\t\tfreeprev = cell;\n\t\t} else {\n\t\t\tprev = cell;\n\t\t}\n\t\tcell = next;\t\t\n\t}\n\tspin_unlock_irqrestore(&f->lock, flags);\t\n\n\t \n\twhile (freefirst) {\n\t\tfreenext = freefirst->next;\n\t\tsnd_seq_cell_free(freefirst);\n\t\tfreefirst = freenext;\n\t}\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}