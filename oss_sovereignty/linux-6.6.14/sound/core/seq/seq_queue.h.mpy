{
  "module_name": "seq_queue.h",
  "hash_id": "2a5a36e019f7981b73c4b8d0c481233ba71d2efd130925d6ad75e9cad080ddf9",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_queue.h",
  "human_readable_source": " \n \n#ifndef __SND_SEQ_QUEUE_H\n#define __SND_SEQ_QUEUE_H\n\n#include \"seq_memory.h\"\n#include \"seq_prioq.h\"\n#include \"seq_timer.h\"\n#include \"seq_lock.h\"\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n\n#define SEQ_QUEUE_NO_OWNER (-1)\n\nstruct snd_seq_queue {\n\tint queue;\t\t \n\n\tchar name[64];\t\t \n\n\tstruct snd_seq_prioq\t*tickq;\t\t \n\tstruct snd_seq_prioq\t*timeq;\t\t \t\n\t\n\tstruct snd_seq_timer *timer;\t \n\tint\towner;\t\t \n\tbool\tlocked;\t\t \n\tbool\tklocked;\t \n\tbool\tcheck_again;\t \n\tbool\tcheck_blocked;\t \n\n\tunsigned int flags;\t\t \n\tunsigned int info_flags;\t \n\n\tspinlock_t owner_lock;\n\tspinlock_t check_lock;\n\n\t \n\tDECLARE_BITMAP(clients_bitmap, SNDRV_SEQ_MAX_CLIENTS);\n\tunsigned int clients;\t \n\tstruct mutex timer_mutex;\n\n\tsnd_use_lock_t use_lock;\n};\n\n\n \nint snd_seq_queue_get_cur_queues(void);\n\n  \nvoid snd_seq_queues_delete(void);\n\n\n \nstruct snd_seq_queue *snd_seq_queue_alloc(int client, int locked, unsigned int flags);\n\n \nint snd_seq_queue_delete(int client, int queueid);\n\n \nvoid snd_seq_queue_client_leave(int client);\n\n \nint snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop);\n\n \nvoid snd_seq_queue_client_leave_cells(int client);\nvoid snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info);\n\n \nstruct snd_seq_queue *queueptr(int queueid);\n \n#define queuefree(q) snd_use_lock_free(&(q)->use_lock)\n\n \nstruct snd_seq_queue *snd_seq_queue_find_name(char *name);\n\n \nvoid snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop);\n\n \nint snd_seq_queue_check_access(int queueid, int client);\nint snd_seq_queue_timer_set_tempo(int queueid, int client, struct snd_seq_queue_tempo *info);\nint snd_seq_queue_set_owner(int queueid, int client, int locked);\nint snd_seq_queue_set_locked(int queueid, int client, int locked);\nint snd_seq_queue_timer_open(int queueid);\nint snd_seq_queue_timer_close(int queueid);\nint snd_seq_queue_use(int queueid, int client, int use);\nint snd_seq_queue_is_used(int queueid, int client);\n\nint snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}