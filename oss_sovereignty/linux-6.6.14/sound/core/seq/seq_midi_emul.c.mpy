{
  "module_name": "seq_midi_emul.c",
  "hash_id": "08ab9d282fe6b6019f601691795c4f44f97c1f56d214481e69f1de3baaa4adea",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_midi_emul.c",
  "human_readable_source": "\n \n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/seq_kernel.h>\n#include <sound/seq_midi_emul.h>\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n\nMODULE_AUTHOR(\"Takashi Iwai / Steve Ratcliffe\");\nMODULE_DESCRIPTION(\"Advanced Linux Sound Architecture sequencer MIDI emulation.\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic void note_off(const struct snd_midi_op *ops, void *drv,\n\t\t     struct snd_midi_channel *chan,\n\t\t     int note, int vel);\nstatic void do_control(const struct snd_midi_op *ops, void *private,\n\t\t       struct snd_midi_channel_set *chset,\n\t\t       struct snd_midi_channel *chan,\n\t\t       int control, int value);\nstatic void rpn(const struct snd_midi_op *ops, void *drv,\n\t\tstruct snd_midi_channel *chan,\n\t\tstruct snd_midi_channel_set *chset);\nstatic void nrpn(const struct snd_midi_op *ops, void *drv,\n\t\t struct snd_midi_channel *chan,\n\t\t struct snd_midi_channel_set *chset);\nstatic void sysex(const struct snd_midi_op *ops, void *private,\n\t\t  unsigned char *sysex,\n\t\t  int len, struct snd_midi_channel_set *chset);\nstatic void all_sounds_off(const struct snd_midi_op *ops, void *private,\n\t\t\t   struct snd_midi_channel *chan);\nstatic void all_notes_off(const struct snd_midi_op *ops, void *private,\n\t\t\t  struct snd_midi_channel *chan);\nstatic void snd_midi_reset_controllers(struct snd_midi_channel *chan);\nstatic void reset_all_channels(struct snd_midi_channel_set *chset);\n\n\n \nvoid\nsnd_midi_process_event(const struct snd_midi_op *ops,\n\t\t       struct snd_seq_event *ev,\n\t\t       struct snd_midi_channel_set *chanset)\n{\n\tstruct snd_midi_channel *chan;\n\tvoid *drv;\n\tint dest_channel = 0;\n\n\tif (ev == NULL || chanset == NULL) {\n\t\tpr_debug(\"ALSA: seq_midi_emul: ev or chanbase NULL (snd_midi_process_event)\\n\");\n\t\treturn;\n\t}\n\tif (chanset->channels == NULL)\n\t\treturn;\n\n\tif (snd_seq_ev_is_channel_type(ev)) {\n\t\tdest_channel = ev->data.note.channel;\n\t\tif (dest_channel >= chanset->max_channels) {\n\t\t\tpr_debug(\"ALSA: seq_midi_emul: dest channel is %d, max is %d\\n\",\n\t\t\t\t   dest_channel, chanset->max_channels);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tchan = chanset->channels + dest_channel;\n\tdrv  = chanset->private_data;\n\n\t \n\tif (ev->type == SNDRV_SEQ_EVENT_NOTE)\n\t\treturn;\n\n\t \n\tif (ev->type == SNDRV_SEQ_EVENT_NOTEON && ev->data.note.velocity == 0)\n\t\tev->type = SNDRV_SEQ_EVENT_NOTEOFF;\n\n\t \n\tif (ev->type == SNDRV_SEQ_EVENT_NOTEON ||\n\t    ev->type == SNDRV_SEQ_EVENT_NOTEOFF ||\n\t    ev->type == SNDRV_SEQ_EVENT_KEYPRESS) {\n\t\tif (ev->data.note.note >= 128)\n\t\t\treturn;\n\t}\n\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_NOTEON:\n\t\tif (chan->note[ev->data.note.note] & SNDRV_MIDI_NOTE_ON) {\n\t\t\tif (ops->note_off)\n\t\t\t\tops->note_off(drv, ev->data.note.note, 0, chan);\n\t\t}\n\t\tchan->note[ev->data.note.note] = SNDRV_MIDI_NOTE_ON;\n\t\tif (ops->note_on)\n\t\t\tops->note_on(drv, ev->data.note.note, ev->data.note.velocity, chan);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_NOTEOFF:\n\t\tif (! (chan->note[ev->data.note.note] & SNDRV_MIDI_NOTE_ON))\n\t\t\tbreak;\n\t\tif (ops->note_off)\n\t\t\tnote_off(ops, drv, chan, ev->data.note.note, ev->data.note.velocity);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_KEYPRESS:\n\t\tif (ops->key_press)\n\t\t\tops->key_press(drv, ev->data.note.note, ev->data.note.velocity, chan);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_CONTROLLER:\n\t\tdo_control(ops, drv, chanset, chan,\n\t\t\t   ev->data.control.param, ev->data.control.value);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_PGMCHANGE:\n\t\tchan->midi_program = ev->data.control.value;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_PITCHBEND:\n\t\tchan->midi_pitchbend = ev->data.control.value;\n\t\tif (ops->control)\n\t\t\tops->control(drv, MIDI_CTL_PITCHBEND, chan);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_CHANPRESS:\n\t\tchan->midi_pressure = ev->data.control.value;\n\t\tif (ops->control)\n\t\t\tops->control(drv, MIDI_CTL_CHAN_PRESSURE, chan);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_CONTROL14:\n\t\t \n\t\tif (ev->data.control.param < 32) {\n\t\t\t \n\t\t\tchan->control[ev->data.control.param + 32] =\n\t\t\t\tev->data.control.value & 0x7f;\n\t\t\tdo_control(ops, drv, chanset, chan,\n\t\t\t\t   ev->data.control.param,\n\t\t\t\t   ((ev->data.control.value>>7) & 0x7f));\n\t\t} else\n\t\t\tdo_control(ops, drv, chanset, chan,\n\t\t\t\t   ev->data.control.param,\n\t\t\t\t   ev->data.control.value);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_NONREGPARAM:\n\t\t \n\t\tchan->param_type = SNDRV_MIDI_PARAM_TYPE_NONREGISTERED;\n\t\tchan->control[MIDI_CTL_MSB_DATA_ENTRY]\n\t\t\t= (ev->data.control.value >> 7) & 0x7f;\n\t\tchan->control[MIDI_CTL_LSB_DATA_ENTRY]\n\t\t\t= ev->data.control.value & 0x7f;\n\t\tchan->control[MIDI_CTL_NONREG_PARM_NUM_MSB]\n\t\t\t= (ev->data.control.param >> 7) & 0x7f;\n\t\tchan->control[MIDI_CTL_NONREG_PARM_NUM_LSB]\n\t\t\t= ev->data.control.param & 0x7f;\n\t\tnrpn(ops, drv, chan, chanset);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_REGPARAM:\n\t\t \n\t\tchan->param_type = SNDRV_MIDI_PARAM_TYPE_REGISTERED;\n\t\tchan->control[MIDI_CTL_MSB_DATA_ENTRY]\n\t\t\t= (ev->data.control.value >> 7) & 0x7f;\n\t\tchan->control[MIDI_CTL_LSB_DATA_ENTRY]\n\t\t\t= ev->data.control.value & 0x7f;\n\t\tchan->control[MIDI_CTL_REGIST_PARM_NUM_MSB]\n\t\t\t= (ev->data.control.param >> 7) & 0x7f;\n\t\tchan->control[MIDI_CTL_REGIST_PARM_NUM_LSB]\n\t\t\t= ev->data.control.param & 0x7f;\n\t\trpn(ops, drv, chan, chanset);\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_SYSEX:\n\t\tif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE) {\n\t\t\tunsigned char sysexbuf[64];\n\t\t\tint len;\n\t\t\tlen = snd_seq_expand_var_event(ev, sizeof(sysexbuf), sysexbuf, 1, 0);\n\t\t\tif (len > 0)\n\t\t\t\tsysex(ops, drv, sysexbuf, len, chanset);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_SONGPOS:\n\tcase SNDRV_SEQ_EVENT_SONGSEL:\n\tcase SNDRV_SEQ_EVENT_CLOCK:\n\tcase SNDRV_SEQ_EVENT_START:\n\tcase SNDRV_SEQ_EVENT_CONTINUE:\n\tcase SNDRV_SEQ_EVENT_STOP:\n\tcase SNDRV_SEQ_EVENT_QFRAME:\n\tcase SNDRV_SEQ_EVENT_TEMPO:\n\tcase SNDRV_SEQ_EVENT_TIMESIGN:\n\tcase SNDRV_SEQ_EVENT_KEYSIGN:\n\t\tgoto not_yet;\n\tcase SNDRV_SEQ_EVENT_SENSING:\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_CLIENT_START:\n\tcase SNDRV_SEQ_EVENT_CLIENT_EXIT:\n\tcase SNDRV_SEQ_EVENT_CLIENT_CHANGE:\n\tcase SNDRV_SEQ_EVENT_PORT_START:\n\tcase SNDRV_SEQ_EVENT_PORT_EXIT:\n\tcase SNDRV_SEQ_EVENT_PORT_CHANGE:\n\tcase SNDRV_SEQ_EVENT_ECHO:\n\tnot_yet:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(snd_midi_process_event);\n\n\n \nstatic void\nnote_off(const struct snd_midi_op *ops, void *drv,\n\t struct snd_midi_channel *chan,\n\t int note, int vel)\n{\n\tif (chan->gm_hold) {\n\t\t \n\t\tchan->note[note] |= SNDRV_MIDI_NOTE_RELEASED;\n\t} else if (chan->note[note] & SNDRV_MIDI_NOTE_SOSTENUTO) {\n\t\t \n\t\tchan->note[note] |= SNDRV_MIDI_NOTE_RELEASED;\n\t} else {\n\t\tchan->note[note] = 0;\n\t\tif (ops->note_off)\n\t\t\tops->note_off(drv, note, vel, chan);\n\t}\n}\n\n \nstatic void\ndo_control(const struct snd_midi_op *ops, void *drv,\n\t   struct snd_midi_channel_set *chset,\n\t   struct snd_midi_channel *chan, int control, int value)\n{\n\tint  i;\n\n\tif (control >= ARRAY_SIZE(chan->control))\n\t\treturn;\n\n\t \n\tif ((control >=64 && control <=69) || (control >= 80 && control <= 83)) {\n\t\t \n\t\tvalue = (value >= 64)? 127: 0;\n\t}\n\tchan->control[control] = value;\n\n\tswitch (control) {\n\tcase MIDI_CTL_SUSTAIN:\n\t\tif (value == 0) {\n\t\t\t \n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tif (chan->note[i] & SNDRV_MIDI_NOTE_RELEASED) {\n\t\t\t\t\tchan->note[i] = SNDRV_MIDI_NOTE_OFF;\n\t\t\t\t\tif (ops->note_off)\n\t\t\t\t\t\tops->note_off(drv, i, 0, chan);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MIDI_CTL_PORTAMENTO:\n\t\tbreak;\n\tcase MIDI_CTL_SOSTENUTO:\n\t\tif (value) {\n\t\t\t \n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tif (chan->note[i] & SNDRV_MIDI_NOTE_ON)\n\t\t\t\t\tchan->note[i] |= SNDRV_MIDI_NOTE_SOSTENUTO;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tif (chan->note[i] & SNDRV_MIDI_NOTE_SOSTENUTO) {\n\t\t\t\t\tchan->note[i] &= ~SNDRV_MIDI_NOTE_SOSTENUTO;\n\t\t\t\t\tif (chan->note[i] & SNDRV_MIDI_NOTE_RELEASED) {\n\t\t\t\t\t\tchan->note[i] = SNDRV_MIDI_NOTE_OFF;\n\t\t\t\t\t\tif (ops->note_off)\n\t\t\t\t\t\t\tops->note_off(drv, i, 0, chan);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MIDI_CTL_MSB_DATA_ENTRY:\n\t\tchan->control[MIDI_CTL_LSB_DATA_ENTRY] = 0;\n\t\tfallthrough;\n\tcase MIDI_CTL_LSB_DATA_ENTRY:\n\t\tif (chan->param_type == SNDRV_MIDI_PARAM_TYPE_REGISTERED)\n\t\t\trpn(ops, drv, chan, chset);\n\t\telse\n\t\t\tnrpn(ops, drv, chan, chset);\n\t\tbreak;\n\tcase MIDI_CTL_REGIST_PARM_NUM_LSB:\n\tcase MIDI_CTL_REGIST_PARM_NUM_MSB:\n\t\tchan->param_type = SNDRV_MIDI_PARAM_TYPE_REGISTERED;\n\t\tbreak;\n\tcase MIDI_CTL_NONREG_PARM_NUM_LSB:\n\tcase MIDI_CTL_NONREG_PARM_NUM_MSB:\n\t\tchan->param_type = SNDRV_MIDI_PARAM_TYPE_NONREGISTERED;\n\t\tbreak;\n\n\tcase MIDI_CTL_ALL_SOUNDS_OFF:\n\t\tall_sounds_off(ops, drv, chan);\n\t\tbreak;\n\n\tcase MIDI_CTL_ALL_NOTES_OFF:\n\t\tall_notes_off(ops, drv, chan);\n\t\tbreak;\n\n\tcase MIDI_CTL_MSB_BANK:\n\t\tif (chset->midi_mode == SNDRV_MIDI_MODE_XG) {\n\t\t\tif (value == 127)\n\t\t\t\tchan->drum_channel = 1;\n\t\t\telse\n\t\t\t\tchan->drum_channel = 0;\n\t\t}\n\t\tbreak;\n\tcase MIDI_CTL_LSB_BANK:\n\t\tbreak;\n\n\tcase MIDI_CTL_RESET_CONTROLLERS:\n\t\tsnd_midi_reset_controllers(chan);\n\t\tbreak;\n\n\tcase MIDI_CTL_SOFT_PEDAL:\n\tcase MIDI_CTL_LEGATO_FOOTSWITCH:\n\tcase MIDI_CTL_HOLD2:\n\tcase MIDI_CTL_SC1_SOUND_VARIATION:\n\tcase MIDI_CTL_SC2_TIMBRE:\n\tcase MIDI_CTL_SC3_RELEASE_TIME:\n\tcase MIDI_CTL_SC4_ATTACK_TIME:\n\tcase MIDI_CTL_SC5_BRIGHTNESS:\n\tcase MIDI_CTL_E1_REVERB_DEPTH:\n\tcase MIDI_CTL_E2_TREMOLO_DEPTH:\n\tcase MIDI_CTL_E3_CHORUS_DEPTH:\n\tcase MIDI_CTL_E4_DETUNE_DEPTH:\n\tcase MIDI_CTL_E5_PHASER_DEPTH:\n\t\tgoto notyet;\n\tnotyet:\n\tdefault:\n\t\tif (ops->control)\n\t\t\tops->control(drv, control, chan);\n\t\tbreak;\n\t}\n}\n\n\n \nvoid\nsnd_midi_channel_set_clear(struct snd_midi_channel_set *chset)\n{\n\tint i;\n\n\tchset->midi_mode = SNDRV_MIDI_MODE_GM;\n\tchset->gs_master_volume = 127;\n\n\tfor (i = 0; i < chset->max_channels; i++) {\n\t\tstruct snd_midi_channel *chan = chset->channels + i;\n\t\tmemset(chan->note, 0, sizeof(chan->note));\n\n\t\tchan->midi_aftertouch = 0;\n\t\tchan->midi_pressure = 0;\n\t\tchan->midi_program = 0;\n\t\tchan->midi_pitchbend = 0;\n\t\tsnd_midi_reset_controllers(chan);\n\t\tchan->gm_rpn_pitch_bend_range = 256;  \n\t\tchan->gm_rpn_fine_tuning = 0;\n\t\tchan->gm_rpn_coarse_tuning = 0;\n\n\t\tif (i == 9)\n\t\t\tchan->drum_channel = 1;\n\t\telse\n\t\t\tchan->drum_channel = 0;\n\t}\n}\nEXPORT_SYMBOL(snd_midi_channel_set_clear);\n\n \nstatic void\nrpn(const struct snd_midi_op *ops, void *drv, struct snd_midi_channel *chan,\n    struct snd_midi_channel_set *chset)\n{\n\tint type;\n\tint val;\n\n\tif (chset->midi_mode != SNDRV_MIDI_MODE_NONE) {\n\t\ttype = (chan->control[MIDI_CTL_REGIST_PARM_NUM_MSB] << 8) |\n\t\t\tchan->control[MIDI_CTL_REGIST_PARM_NUM_LSB];\n\t\tval = (chan->control[MIDI_CTL_MSB_DATA_ENTRY] << 7) |\n\t\t\tchan->control[MIDI_CTL_LSB_DATA_ENTRY];\n\n\t\tswitch (type) {\n\t\tcase 0x0000:  \n\t\t\t \n\t\t\tchan->gm_rpn_pitch_bend_range = val;\n\t\t\tbreak;\n\t\t\t\t\t\n\t\tcase 0x0001:  \n\t\t\t \n\t\t\tchan->gm_rpn_fine_tuning = val - 8192;\n\t\t\tbreak;\n\n\t\tcase 0x0002:  \n\t\t\t \n\t\t\tchan->gm_rpn_coarse_tuning = val - 8192;\n\t\t\tbreak;\n\n\t\tcase 0x7F7F:  \n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\t \n}\n\n \nstatic void\nnrpn(const struct snd_midi_op *ops, void *drv, struct snd_midi_channel *chan,\n     struct snd_midi_channel_set *chset)\n{\n\t \n\tif (ops->nrpn)\n\t\tops->nrpn(drv, chan, chset);\n}\n\n\n \nstatic int\nget_channel(unsigned char cmd)\n{\n\tint p = cmd & 0x0f;\n\tif (p == 0)\n\t\tp = 9;\n\telse if (p < 10)\n\t\tp--;\n\treturn p;\n}\n\n\n \nstatic void\nsysex(const struct snd_midi_op *ops, void *private, unsigned char *buf, int len,\n      struct snd_midi_channel_set *chset)\n{\n\t \n\tstatic const unsigned char gm_on_macro[] = {\n\t\t0x7e,0x7f,0x09,0x01,\n\t};\n\t \n\tstatic const unsigned char xg_on_macro[] = {\n\t\t0x43,0x10,0x4c,0x00,0x00,0x7e,0x00,\n\t};\n\t \n\tstatic const unsigned char gs_pfx_macro[] = {\n\t\t0x41,0x10,0x42,0x12,0x40, \n\t};\n\n\tint parsed = SNDRV_MIDI_SYSEX_NOT_PARSED;\n\n\tif (len <= 0 || buf[0] != 0xf0)\n\t\treturn;\n\t \n\tbuf++;\n\tlen--;\n\n\t \n\tif (len >= (int)sizeof(gm_on_macro) &&\n\t    memcmp(buf, gm_on_macro, sizeof(gm_on_macro)) == 0) {\n\t\tif (chset->midi_mode != SNDRV_MIDI_MODE_GS &&\n\t\t    chset->midi_mode != SNDRV_MIDI_MODE_XG) {\n\t\t\tchset->midi_mode = SNDRV_MIDI_MODE_GM;\n\t\t\treset_all_channels(chset);\n\t\t\tparsed = SNDRV_MIDI_SYSEX_GM_ON;\n\t\t}\n\t}\n\n\t \n\telse if (len >= 8 &&\n\t\t memcmp(buf, gs_pfx_macro, sizeof(gs_pfx_macro)) == 0) {\n\t\tif (chset->midi_mode != SNDRV_MIDI_MODE_GS &&\n\t\t    chset->midi_mode != SNDRV_MIDI_MODE_XG)\n\t\t\tchset->midi_mode = SNDRV_MIDI_MODE_GS;\n\n\t\tif (buf[5] == 0x00 && buf[6] == 0x7f && buf[7] == 0x00) {\n\t\t\t \n\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_RESET;\n\t\t\treset_all_channels(chset);\n\t\t}\n\n\t\telse if ((buf[5] & 0xf0) == 0x10 && buf[6] == 0x15) {\n\t\t\t \n\t\t\tint p = get_channel(buf[5]);\n\t\t\tif (p < chset->max_channels) {\n\t\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_DRUM_CHANNEL;\n\t\t\t\tif (buf[7])\n\t\t\t\t\tchset->channels[p].drum_channel = 1;\n\t\t\t\telse\n\t\t\t\t\tchset->channels[p].drum_channel = 0;\n\t\t\t}\n\n\t\t} else if ((buf[5] & 0xf0) == 0x10 && buf[6] == 0x21) {\n\t\t\t \n\t\t\tint p = get_channel(buf[5]);\n\t\t\tif (p < chset->max_channels &&\n\t\t\t    ! chset->channels[p].drum_channel) {\n\t\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_DRUM_CHANNEL;\n\t\t\t\tchset->channels[p].midi_program = buf[7];\n\t\t\t}\n\n\t\t} else if (buf[5] == 0x01 && buf[6] == 0x30) {\n\t\t\t \n\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_REVERB_MODE;\n\t\t\tchset->gs_reverb_mode = buf[7];\n\n\t\t} else if (buf[5] == 0x01 && buf[6] == 0x38) {\n\t\t\t \n\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_CHORUS_MODE;\n\t\t\tchset->gs_chorus_mode = buf[7];\n\n\t\t} else if (buf[5] == 0x00 && buf[6] == 0x04) {\n\t\t\t \n\t\t\tparsed = SNDRV_MIDI_SYSEX_GS_MASTER_VOLUME;\n\t\t\tchset->gs_master_volume = buf[7];\n\n\t\t}\n\t}\n\n\t \n\telse if (len >= (int)sizeof(xg_on_macro) &&\n\t\t memcmp(buf, xg_on_macro, sizeof(xg_on_macro)) == 0) {\n\t\tint i;\n\t\tchset->midi_mode = SNDRV_MIDI_MODE_XG;\n\t\tparsed = SNDRV_MIDI_SYSEX_XG_ON;\n\t\t \n\t\tfor (i = 0; i < chset->max_channels; i++) {\n\t\t\tif (chset->channels[i].drum_channel)\n\t\t\t\tchset->channels[i].control[MIDI_CTL_MSB_BANK] = 127;\n\t\t\telse\n\t\t\t\tchset->channels[i].control[MIDI_CTL_MSB_BANK] = 0;\n\t\t}\n\t}\n\n\tif (ops->sysex)\n\t\tops->sysex(private, buf - 1, len + 1, parsed, chset);\n}\n\n \nstatic void\nall_sounds_off(const struct snd_midi_op *ops, void *drv,\n\t       struct snd_midi_channel *chan)\n{\n\tint n;\n\n\tif (! ops->note_terminate)\n\t\treturn;\n\tfor (n = 0; n < 128; n++) {\n\t\tif (chan->note[n]) {\n\t\t\tops->note_terminate(drv, n, chan);\n\t\t\tchan->note[n] = 0;\n\t\t}\n\t}\n}\n\n \nstatic void\nall_notes_off(const struct snd_midi_op *ops, void *drv,\n\t      struct snd_midi_channel *chan)\n{\n\tint n;\n\n\tif (! ops->note_off)\n\t\treturn;\n\tfor (n = 0; n < 128; n++) {\n\t\tif (chan->note[n] == SNDRV_MIDI_NOTE_ON)\n\t\t\tnote_off(ops, drv, chan, n, 0);\n\t}\n}\n\n \nstatic void snd_midi_channel_init(struct snd_midi_channel *p, int n)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tmemset(p, 0, sizeof(struct snd_midi_channel));\n\tp->private = NULL;\n\tp->number = n;\n\n\tsnd_midi_reset_controllers(p);\n\tp->gm_rpn_pitch_bend_range = 256;  \n\tp->gm_rpn_fine_tuning = 0;\n\tp->gm_rpn_coarse_tuning = 0;\n\n\tif (n == 9)\n\t\tp->drum_channel = 1;\t \n}\n\n \nstatic struct snd_midi_channel *snd_midi_channel_init_set(int n)\n{\n\tstruct snd_midi_channel *chan;\n\tint  i;\n\n\tchan = kmalloc_array(n, sizeof(struct snd_midi_channel), GFP_KERNEL);\n\tif (chan) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tsnd_midi_channel_init(chan+i, i);\n\t}\n\n\treturn chan;\n}\n\n \nstatic void\nreset_all_channels(struct snd_midi_channel_set *chset)\n{\n\tint ch;\n\tfor (ch = 0; ch < chset->max_channels; ch++) {\n\t\tstruct snd_midi_channel *chan = chset->channels + ch;\n\t\tsnd_midi_reset_controllers(chan);\n\t\tchan->gm_rpn_pitch_bend_range = 256;  \n\t\tchan->gm_rpn_fine_tuning = 0;\n\t\tchan->gm_rpn_coarse_tuning = 0;\n\n\t\tif (ch == 9)\n\t\t\tchan->drum_channel = 1;\n\t\telse\n\t\t\tchan->drum_channel = 0;\n\t}\n}\n\n\n \nstruct snd_midi_channel_set *snd_midi_channel_alloc_set(int n)\n{\n\tstruct snd_midi_channel_set *chset;\n\n\tchset = kmalloc(sizeof(*chset), GFP_KERNEL);\n\tif (chset) {\n\t\tchset->channels = snd_midi_channel_init_set(n);\n\t\tchset->private_data = NULL;\n\t\tchset->max_channels = n;\n\t}\n\treturn chset;\n}\nEXPORT_SYMBOL(snd_midi_channel_alloc_set);\n\n \nstatic void snd_midi_reset_controllers(struct snd_midi_channel *chan)\n{\n\tmemset(chan->control, 0, sizeof(chan->control));\n\tchan->gm_volume = 127;\n\tchan->gm_expression = 127;\n\tchan->gm_pan = 64;\n}\n\n\n \nvoid snd_midi_channel_free_set(struct snd_midi_channel_set *chset)\n{\n\tif (chset == NULL)\n\t\treturn;\n\tkfree(chset->channels);\n\tkfree(chset);\n}\nEXPORT_SYMBOL(snd_midi_channel_free_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}