{
  "module_name": "seq_clientmgr.c",
  "hash_id": "219d1985c96dfd79e451e4121146ec86ada96aab80b3abc0184b4bb4f902b102",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_clientmgr.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <linux/kmod.h>\n\n#include <sound/seq_kernel.h>\n#include <sound/ump.h>\n#include \"seq_clientmgr.h\"\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n#include \"seq_system.h\"\n#include \"seq_ump_convert.h\"\n#include <sound/seq_device.h>\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n\n \n\n \n\n \n#define SNDRV_SEQ_GLOBAL_CLIENTS\t16\n \n#define SNDRV_SEQ_CLIENTS_PER_CARD\t4\n \n#define SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN\t128\n\n#define SNDRV_SEQ_LFLG_INPUT\t0x0001\n#define SNDRV_SEQ_LFLG_OUTPUT\t0x0002\n#define SNDRV_SEQ_LFLG_OPEN\t(SNDRV_SEQ_LFLG_INPUT|SNDRV_SEQ_LFLG_OUTPUT)\n\nstatic DEFINE_SPINLOCK(clients_lock);\nstatic DEFINE_MUTEX(register_mutex);\n\n \nstatic char clienttablock[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_client *clienttab[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_usage client_usage;\n\n \nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop);\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop);\n\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\nstatic void free_ump_info(struct snd_seq_client *client);\n#endif\n\n \nstatic inline unsigned short snd_seq_file_flags(struct file *file)\n{\n        switch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n        case FMODE_WRITE:\n                return SNDRV_SEQ_LFLG_OUTPUT;\n        case FMODE_READ:\n                return SNDRV_SEQ_LFLG_INPUT;\n        default:\n                return SNDRV_SEQ_LFLG_OPEN;\n        }\n}\n\nstatic inline int snd_seq_write_pool_allocated(struct snd_seq_client *client)\n{\n\treturn snd_seq_total_cells(client->pool) > 0;\n}\n\n \nstatic struct snd_seq_client *clientptr(int clientid)\n{\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\treturn clienttab[clientid];\n}\n\nstruct snd_seq_client *snd_seq_client_use_ptr(int clientid)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client *client;\n\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclient = clientptr(clientid);\n\tif (client)\n\t\tgoto __lock;\n\tif (clienttablock[clientid]) {\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n#ifdef CONFIG_MODULES\n\tif (!in_interrupt()) {\n\t\tstatic DECLARE_BITMAP(client_requested, SNDRV_SEQ_GLOBAL_CLIENTS);\n\t\tstatic DECLARE_BITMAP(card_requested, SNDRV_CARDS);\n\n\t\tif (clientid < SNDRV_SEQ_GLOBAL_CLIENTS) {\n\t\t\tint idx;\n\t\t\t\n\t\t\tif (!test_and_set_bit(clientid, client_requested)) {\n\t\t\t\tfor (idx = 0; idx < 15; idx++) {\n\t\t\t\t\tif (seq_client_load[idx] < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (seq_client_load[idx] == clientid) {\n\t\t\t\t\t\trequest_module(\"snd-seq-client-%i\",\n\t\t\t\t\t\t\t       clientid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (clientid < SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN) {\n\t\t\tint card = (clientid - SNDRV_SEQ_GLOBAL_CLIENTS) /\n\t\t\t\tSNDRV_SEQ_CLIENTS_PER_CARD;\n\t\t\tif (card < snd_ecards_limit) {\n\t\t\t\tif (!test_and_set_bit(card, card_requested))\n\t\t\t\t\tsnd_request_card(card);\n\t\t\t\tsnd_seq_device_load_drivers();\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&clients_lock, flags);\n\t\tclient = clientptr(clientid);\n\t\tif (client)\n\t\t\tgoto __lock;\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t}\n#endif\n\treturn NULL;\n\n      __lock:\n\tsnd_use_lock_use(&client->use_lock);\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\treturn client;\n}\n\n \nbool snd_seq_client_ioctl_lock(int clientid)\n{\n\tstruct snd_seq_client *client;\n\n\tclient = snd_seq_client_use_ptr(clientid);\n\tif (!client)\n\t\treturn false;\n\tmutex_lock(&client->ioctl_mutex);\n\t \n\treturn true;\n}\nEXPORT_SYMBOL_GPL(snd_seq_client_ioctl_lock);\n\n \nvoid snd_seq_client_ioctl_unlock(int clientid)\n{\n\tstruct snd_seq_client *client;\n\n\tclient = snd_seq_client_use_ptr(clientid);\n\tif (WARN_ON(!client))\n\t\treturn;\n\tmutex_unlock(&client->ioctl_mutex);\n\t \n\tsnd_seq_client_unlock(client);\n\tsnd_seq_client_unlock(client);\n}\nEXPORT_SYMBOL_GPL(snd_seq_client_ioctl_unlock);\n\nstatic void usage_alloc(struct snd_seq_usage *res, int num)\n{\n\tres->cur += num;\n\tif (res->cur > res->peak)\n\t\tres->peak = res->cur;\n}\n\nstatic void usage_free(struct snd_seq_usage *res, int num)\n{\n\tres->cur -= num;\n}\n\n \nint __init client_init_data(void)\n{\n\t \n\tmemset(&clienttablock, 0, sizeof(clienttablock));\n\tmemset(&clienttab, 0, sizeof(clienttab));\n\treturn 0;\n}\n\n\nstatic struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\n{\n\tint c;\n\tstruct snd_seq_client *client;\n\n\t \n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn NULL;\n\tclient->pool = snd_seq_pool_new(poolsize);\n\tif (client->pool == NULL) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\tclient->type = NO_CLIENT;\n\tsnd_use_lock_init(&client->use_lock);\n\trwlock_init(&client->ports_lock);\n\tmutex_init(&client->ports_mutex);\n\tINIT_LIST_HEAD(&client->ports_list_head);\n\tmutex_init(&client->ioctl_mutex);\n\tclient->ump_endpoint_port = -1;\n\n\t \n\tspin_lock_irq(&clients_lock);\n\tif (client_index < 0) {\n\t\tfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\n\t\t     c < SNDRV_SEQ_MAX_CLIENTS;\n\t\t     c++) {\n\t\t\tif (clienttab[c] || clienttablock[c])\n\t\t\t\tcontinue;\n\t\t\tclienttab[client->number = c] = client;\n\t\t\tspin_unlock_irq(&clients_lock);\n\t\t\treturn client;\n\t\t}\n\t} else {\n\t\tif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\n\t\t\tclienttab[client->number = client_index] = client;\n\t\t\tspin_unlock_irq(&clients_lock);\n\t\t\treturn client;\n\t\t}\n\t}\n\tspin_unlock_irq(&clients_lock);\n\tsnd_seq_pool_delete(&client->pool);\n\tkfree(client);\n\treturn NULL;\t \n}\n\n\nstatic int seq_free_client1(struct snd_seq_client *client)\n{\n\tif (!client)\n\t\treturn 0;\n\tspin_lock_irq(&clients_lock);\n\tclienttablock[client->number] = 1;\n\tclienttab[client->number] = NULL;\n\tspin_unlock_irq(&clients_lock);\n\tsnd_seq_delete_all_ports(client);\n\tsnd_seq_queue_client_leave(client->number);\n\tsnd_use_lock_sync(&client->use_lock);\n\tif (client->pool)\n\t\tsnd_seq_pool_delete(&client->pool);\n\tspin_lock_irq(&clients_lock);\n\tclienttablock[client->number] = 0;\n\tspin_unlock_irq(&clients_lock);\n\treturn 0;\n}\n\n\nstatic void seq_free_client(struct snd_seq_client * client)\n{\n\tmutex_lock(&register_mutex);\n\tswitch (client->type) {\n\tcase NO_CLIENT:\n\t\tpr_warn(\"ALSA: seq: Trying to free unused client %d\\n\",\n\t\t\tclient->number);\n\t\tbreak;\n\tcase USER_CLIENT:\n\tcase KERNEL_CLIENT:\n\t\tseq_free_client1(client);\n\t\tusage_free(&client_usage, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"ALSA: seq: Trying to free client %d with undefined type = %d\\n\",\n\t\t\t   client->number, client->type);\n\t}\n\tmutex_unlock(&register_mutex);\n\n\tsnd_seq_system_client_ev_client_exit(client->number);\n}\n\n\n\n \n\n \nstatic int snd_seq_open(struct inode *inode, struct file *file)\n{\n\tint c, mode;\t\t\t \n\tstruct snd_seq_client *client;\n\tstruct snd_seq_user_client *user;\n\tint err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&register_mutex);\n\tclient = seq_create_client1(-1, SNDRV_SEQ_DEFAULT_EVENTS);\n\tif (!client) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENOMEM;\t \n\t}\n\n\tmode = snd_seq_file_flags(file);\n\tif (mode & SNDRV_SEQ_LFLG_INPUT)\n\t\tclient->accept_input = 1;\n\tif (mode & SNDRV_SEQ_LFLG_OUTPUT)\n\t\tclient->accept_output = 1;\n\n\tuser = &client->data.user;\n\tuser->fifo = NULL;\n\tuser->fifo_pool_size = 0;\n\n\tif (mode & SNDRV_SEQ_LFLG_INPUT) {\n\t\tuser->fifo_pool_size = SNDRV_SEQ_DEFAULT_CLIENT_EVENTS;\n\t\tuser->fifo = snd_seq_fifo_new(user->fifo_pool_size);\n\t\tif (user->fifo == NULL) {\n\t\t\tseq_free_client1(client);\n\t\t\tkfree(client);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tusage_alloc(&client_usage, 1);\n\tclient->type = USER_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\tc = client->number;\n\tfile->private_data = client;\n\n\t \n\tuser->file = file;\n\tsprintf(client->name, \"Client-%d\", c);\n\tclient->data.user.owner = get_pid(task_pid(current));\n\n\t \n\tsnd_seq_system_client_ev_client_start(c);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\n\tif (client) {\n\t\tseq_free_client(client);\n\t\tif (client->data.user.fifo)\n\t\t\tsnd_seq_fifo_delete(&client->data.user.fifo);\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n\t\tfree_ump_info(client);\n#endif\n\t\tput_pid(client->data.user.owner);\n\t\tkfree(client);\n\t}\n\n\treturn 0;\n}\n\nstatic bool event_is_compatible(const struct snd_seq_client *client,\n\t\t\t\tconst struct snd_seq_event *ev)\n{\n\tif (snd_seq_ev_is_ump(ev) && !client->midi_version)\n\t\treturn false;\n\tif (snd_seq_ev_is_ump(ev) && snd_seq_ev_is_variable(ev))\n\t\treturn false;\n\treturn true;\n}\n\n \n \nstatic ssize_t snd_seq_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tstruct snd_seq_fifo *fifo;\n\tsize_t aligned_size;\n\tint err;\n\tlong result = 0;\n\tstruct snd_seq_event_cell *cell;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\t \n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tif (!client->accept_input)\n\t\treturn -ENXIO;\n\tfifo = client->data.user.fifo;\n\tif (!fifo)\n\t\treturn -ENXIO;\n\n\tif (atomic_read(&fifo->overflow) > 0) {\n\t\t \n\t\tsnd_seq_fifo_clear(fifo);\n\t\t \n\t\treturn -ENOSPC;\n\t}\n\n\tcell = NULL;\n\terr = 0;\n\tsnd_seq_fifo_lock(fifo);\n\n\tif (IS_ENABLED(CONFIG_SND_SEQ_UMP) && client->midi_version > 0)\n\t\taligned_size = sizeof(struct snd_seq_ump_event);\n\telse\n\t\taligned_size = sizeof(struct snd_seq_event);\n\n\t \n\twhile (count >= aligned_size) {\n\t\tint nonblock;\n\n\t\tnonblock = (file->f_flags & O_NONBLOCK) || result > 0;\n\t\terr = snd_seq_fifo_cell_out(fifo, &cell, nonblock);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!event_is_compatible(client, &cell->event)) {\n\t\t\tsnd_seq_cell_free(cell);\n\t\t\tcell = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (snd_seq_ev_is_variable(&cell->event)) {\n\t\t\tstruct snd_seq_ump_event tmpev;\n\n\t\t\tmemcpy(&tmpev, &cell->event, aligned_size);\n\t\t\ttmpev.data.ext.len &= ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif (copy_to_user(buf, &tmpev, aligned_size)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= aligned_size;\n\t\t\tbuf += aligned_size;\n\t\t\terr = snd_seq_expand_var_event(&cell->event, count,\n\t\t\t\t\t\t       (char __force *)buf, 0,\n\t\t\t\t\t\t       aligned_size);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tresult += err;\n\t\t\tcount -= err;\n\t\t\tbuf += err;\n\t\t} else {\n\t\t\tif (copy_to_user(buf, &cell->event, aligned_size)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= aligned_size;\n\t\t\tbuf += aligned_size;\n\t\t}\n\t\tsnd_seq_cell_free(cell);\n\t\tcell = NULL;  \n\t\tresult += aligned_size;\n\t}\n\n\tif (err < 0) {\n\t\tif (cell)\n\t\t\tsnd_seq_fifo_cell_putback(fifo, cell);\n\t\tif (err == -EAGAIN && result > 0)\n\t\t\terr = 0;\n\t}\n\tsnd_seq_fifo_unlock(fifo);\n\n\treturn (err < 0) ? err : result;\n}\n\n\n \nstatic int check_port_perm(struct snd_seq_client_port *port, unsigned int flags)\n{\n\tif ((port->capability & flags) != flags)\n\t\treturn 0;\n\treturn flags;\n}\n\n \nstatic struct snd_seq_client *get_event_dest_client(struct snd_seq_event *event,\n\t\t\t\t\t\t    int filter)\n{\n\tstruct snd_seq_client *dest;\n\n\tdest = snd_seq_client_use_ptr(event->dest.client);\n\tif (dest == NULL)\n\t\treturn NULL;\n\tif (! dest->accept_input)\n\t\tgoto __not_avail;\n\tif ((dest->filter & SNDRV_SEQ_FILTER_USE_EVENT) &&\n\t    ! test_bit(event->type, dest->event_filter))\n\t\tgoto __not_avail;\n\tif (filter && !(dest->filter & filter))\n\t\tgoto __not_avail;\n\n\treturn dest;  \n__not_avail:\n\tsnd_seq_client_unlock(dest);\n\treturn NULL;\n}\n\n\n \nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop)\n{\n\tstruct snd_seq_event bounce_ev;\n\tint result;\n\n\tif (client == NULL ||\n\t    ! (client->filter & SNDRV_SEQ_FILTER_BOUNCE) ||\n\t    ! client->accept_input)\n\t\treturn 0;  \n\n\t \n\tmemset(&bounce_ev, 0, sizeof(bounce_ev));\n\tbounce_ev.type = SNDRV_SEQ_EVENT_KERNEL_ERROR;\n\tbounce_ev.flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tbounce_ev.queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tbounce_ev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tbounce_ev.source.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\n\tbounce_ev.dest.client = client->number;\n\tbounce_ev.dest.port = event->source.port;\n\tbounce_ev.data.quote.origin = event->dest;\n\tbounce_ev.data.quote.event = event;\n\tbounce_ev.data.quote.value = -err;  \n\tresult = snd_seq_deliver_single_event(NULL, &bounce_ev, 0, atomic, hop + 1);\n\tif (result < 0) {\n\t\tclient->event_lost++;\n\t\treturn result;\n\t}\n\n\treturn result;\n}\n\n\n \nstatic int update_timestamp_of_queue(struct snd_seq_event *event,\n\t\t\t\t     int queue, int real_time)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(queue);\n\tif (! q)\n\t\treturn 0;\n\tevent->queue = queue;\n\tevent->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;\n\tif (real_time) {\n\t\tevent->time.time = snd_seq_timer_get_cur_time(q->timer, true);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_REAL;\n\t} else {\n\t\tevent->time.tick = snd_seq_timer_get_cur_tick(q->timer);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_TICK;\n\t}\n\tqueuefree(q);\n\treturn 1;\n}\n\n \nint __snd_seq_deliver_single_event(struct snd_seq_client *dest,\n\t\t\t\t   struct snd_seq_client_port *dest_port,\n\t\t\t\t   struct snd_seq_event *event,\n\t\t\t\t   int atomic, int hop)\n{\n\tswitch (dest->type) {\n\tcase USER_CLIENT:\n\t\tif (!dest->data.user.fifo)\n\t\t\treturn 0;\n\t\treturn snd_seq_fifo_event_in(dest->data.user.fifo, event);\n\tcase KERNEL_CLIENT:\n\t\tif (!dest_port->event_input)\n\t\t\treturn 0;\n\t\treturn dest_port->event_input(event,\n\t\t\t\t\t      snd_seq_ev_is_direct(event),\n\t\t\t\t\t      dest_port->private_data,\n\t\t\t\t\t      atomic, hop);\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop)\n{\n\tstruct snd_seq_client *dest = NULL;\n\tstruct snd_seq_client_port *dest_port = NULL;\n\tint result = -ENOENT;\n\tint direct;\n\n\tdirect = snd_seq_ev_is_direct(event);\n\n\tdest = get_event_dest_client(event, filter);\n\tif (dest == NULL)\n\t\tgoto __skip;\n\tdest_port = snd_seq_port_use_ptr(dest, event->dest.port);\n\tif (dest_port == NULL)\n\t\tgoto __skip;\n\n\t \n\tif (! check_port_perm(dest_port, SNDRV_SEQ_PORT_CAP_WRITE)) {\n\t\tresult = -EPERM;\n\t\tgoto __skip;\n\t}\n\t\t\n\tif (dest_port->timestamping)\n\t\tupdate_timestamp_of_queue(event, dest_port->time_queue,\n\t\t\t\t\t  dest_port->time_real);\n\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n\tif (!(dest->filter & SNDRV_SEQ_FILTER_NO_CONVERT)) {\n\t\tif (snd_seq_ev_is_ump(event)) {\n\t\t\tresult = snd_seq_deliver_from_ump(client, dest, dest_port,\n\t\t\t\t\t\t\t  event, atomic, hop);\n\t\t\tgoto __skip;\n\t\t} else if (snd_seq_client_is_ump(dest)) {\n\t\t\tresult = snd_seq_deliver_to_ump(client, dest, dest_port,\n\t\t\t\t\t\t\tevent, atomic, hop);\n\t\t\tgoto __skip;\n\t\t}\n\t}\n#endif  \n\n\tresult = __snd_seq_deliver_single_event(dest, dest_port, event,\n\t\t\t\t\t\tatomic, hop);\n\n  __skip:\n\tif (dest_port)\n\t\tsnd_seq_port_unlock(dest_port);\n\tif (dest)\n\t\tsnd_seq_client_unlock(dest);\n\n\tif (result < 0 && !direct) {\n\t\tresult = bounce_error_event(client, event, result, atomic, hop);\n\t}\n\treturn result;\n}\n\n\n \nstatic int __deliver_to_subscribers(struct snd_seq_client *client,\n\t\t\t\t    struct snd_seq_event *event,\n\t\t\t\t    struct snd_seq_client_port *src_port,\n\t\t\t\t    int atomic, int hop)\n{\n\tstruct snd_seq_subscribers *subs;\n\tint err, result = 0, num_ev = 0;\n\tunion __snd_seq_event event_saved;\n\tsize_t saved_size;\n\tstruct snd_seq_port_subs_info *grp;\n\n\t \n\tsaved_size = snd_seq_event_packet_size(event);\n\tmemcpy(&event_saved, event, saved_size);\n\tgrp = &src_port->c_src;\n\t\n\t \n\tif (atomic)\n\t\tread_lock(&grp->list_lock);\n\telse\n\t\tdown_read_nested(&grp->list_mutex, hop);\n\tlist_for_each_entry(subs, &grp->list_head, src_list) {\n\t\t \n\t\tif (atomic_read(&subs->ref_count) != 2)\n\t\t\tcontinue;\n\t\tevent->dest = subs->info.dest;\n\t\tif (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\t \n\t\t\tupdate_timestamp_of_queue(event, subs->info.queue,\n\t\t\t\t\t\t  subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL);\n\t\terr = snd_seq_deliver_single_event(client, event,\n\t\t\t\t\t\t   0, atomic, hop);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev++;\n\t\t \n\t\tmemcpy(event, &event_saved, saved_size);\n\t}\n\tif (atomic)\n\t\tread_unlock(&grp->list_lock);\n\telse\n\t\tup_read(&grp->list_mutex);\n\tmemcpy(event, &event_saved, saved_size);\n\treturn (result < 0) ? result : num_ev;\n}\n\nstatic int deliver_to_subscribers(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_event *event,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_client_port *src_port;\n\tint ret = 0, ret2;\n\n\tsrc_port = snd_seq_port_use_ptr(client, event->source.port);\n\tif (src_port) {\n\t\tret = __deliver_to_subscribers(client, event, src_port, atomic, hop);\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\tif (client->ump_endpoint_port < 0 ||\n\t    event->source.port == client->ump_endpoint_port)\n\t\treturn ret;\n\n\tsrc_port = snd_seq_port_use_ptr(client, client->ump_endpoint_port);\n\tif (!src_port)\n\t\treturn ret;\n\tret2 = __deliver_to_subscribers(client, event, src_port, atomic, hop);\n\tsnd_seq_port_unlock(src_port);\n\treturn ret2 < 0 ? ret2 : ret;\n}\n\n \nstatic int snd_seq_deliver_event(struct snd_seq_client *client, struct snd_seq_event *event,\n\t\t\t\t int atomic, int hop)\n{\n\tint result;\n\n\thop++;\n\tif (hop >= SNDRV_SEQ_MAX_HOPS) {\n\t\tpr_debug(\"ALSA: seq: too long delivery path (%d:%d->%d:%d)\\n\",\n\t\t\t   event->source.client, event->source.port,\n\t\t\t   event->dest.client, event->dest.port);\n\t\treturn -EMLINK;\n\t}\n\n\tif (snd_seq_ev_is_variable(event) &&\n\t    snd_BUG_ON(atomic && (event->data.ext.len & SNDRV_SEQ_EXT_USRPTR)))\n\t\treturn -EINVAL;\n\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS ||\n\t    event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS)\n\t\tresult = deliver_to_subscribers(client, event, atomic, hop);\n\telse\n\t\tresult = snd_seq_deliver_single_event(client, event, 0, atomic, hop);\n\n\treturn result;\n}\n\n \nint snd_seq_dispatch_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tstruct snd_seq_client *client;\n\tint result;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\n\tclient = snd_seq_client_use_ptr(cell->event.source.client);\n\tif (client == NULL) {\n\t\tsnd_seq_cell_free(cell);  \n\t\treturn -EINVAL;\n\t}\n\n\tif (!snd_seq_ev_is_ump(&cell->event) &&\n\t    cell->event.type == SNDRV_SEQ_EVENT_NOTE) {\n\t\t \n\t\tstruct snd_seq_event tmpev, *ev;\n\n\t\t \n\t\ttmpev = cell->event;\n\t\ttmpev.type = SNDRV_SEQ_EVENT_NOTEON;\n\t\tresult = snd_seq_deliver_event(client, &tmpev, atomic, hop);\n\n\t\t \n\n\t\tev = &cell->event;\n\t\tev->type = SNDRV_SEQ_EVENT_NOTEOFF;\n\t\tev->flags |= SNDRV_SEQ_PRIORITY_HIGH;\n\n\t\t \n\t\tswitch (ev->flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tcell->event.time.tick += ev->data.note.duration;\n\t\t\tbreak;\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\t \n\t\t\tev->time.time.tv_nsec += 1000000 * (ev->data.note.duration % 1000);\n\t\t\tev->time.time.tv_sec += ev->data.note.duration / 1000 +\n\t\t\t\t\t\tev->time.time.tv_nsec / 1000000000;\n\t\t\tev->time.time.tv_nsec %= 1000000000;\n\t\t\tbreak;\n\t\t}\n\t\tev->data.note.velocity = ev->data.note.off_velocity;\n\n\t\t \n\t\tif (snd_seq_enqueue_event(cell, atomic, hop) < 0)\n\t\t\tsnd_seq_cell_free(cell);  \n\n\t} else {\n\t\t \n\n\t\tresult = snd_seq_deliver_event(client, &cell->event, atomic, hop);\n\t\tsnd_seq_cell_free(cell);\n\t}\n\n\tsnd_seq_client_unlock(client);\n\treturn result;\n}\n\n\n \nstatic int snd_seq_client_enqueue_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tstruct file *file, int blocking,\n\t\t\t\t\tint atomic, int hop,\n\t\t\t\t\tstruct mutex *mutexp)\n{\n\tstruct snd_seq_event_cell *cell;\n\tint err;\n\n\t \n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t} else if (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\t \n\t\tstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\n\t\tif (src_port == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\t \n\tif (snd_seq_ev_is_direct(event)) {\n\t\tif (!snd_seq_ev_is_ump(event) &&\n\t\t    event->type == SNDRV_SEQ_EVENT_NOTE)\n\t\t\treturn -EINVAL;  \n\t\treturn snd_seq_deliver_event(client, event, atomic, hop);\n\t}\n\n\t \n\tif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\n\t\treturn -EINVAL;   \n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn -ENXIO;  \n\n\t \n\terr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic,\n\t\t\t\tfile, mutexp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_seq_enqueue_event(cell, atomic, hop);\n\tif (err < 0) {\n\t\tsnd_seq_cell_free(cell);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int check_event_type_and_length(struct snd_seq_event *ev)\n{\n\tswitch (snd_seq_ev_length_type(ev)) {\n\tcase SNDRV_SEQ_EVENT_LENGTH_FIXED:\n\t\tif (snd_seq_ev_is_variable_type(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARIABLE:\n\t\tif (! snd_seq_ev_is_variable_type(ev) ||\n\t\t    (ev->data.ext.len & ~SNDRV_SEQ_EXT_MASK) >= SNDRV_SEQ_MAX_EVENT_LEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARUSR:\n\t\tif (! snd_seq_ev_is_direct(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n \n \nstatic ssize_t snd_seq_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tint written = 0, len;\n\tint err, handled;\n\tunion __snd_seq_event __event;\n\tstruct snd_seq_event *ev = &__event.legacy;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\n\t\treturn -ENXIO;\n\n\t \n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\t\t\n\tif (!client->accept_output || client->pool == NULL)\n\t\treturn -ENXIO;\n\n repeat:\n\thandled = 0;\n\t  \n\tmutex_lock(&client->ioctl_mutex);\n\tif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\n\t\terr = snd_seq_pool_init(client->pool);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = -EINVAL;\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\t \n\t\tlen = sizeof(struct snd_seq_event);\n\t\tif (copy_from_user(ev, buf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (snd_seq_ev_is_ump(ev)) {\n\t\t\tif (count < sizeof(struct snd_seq_ump_event))\n\t\t\t\tbreak;\n\t\t\tif (copy_from_user((char *)ev + len, buf + len,\n\t\t\t\t\t   sizeof(struct snd_seq_ump_event) - len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = sizeof(struct snd_seq_ump_event);\n\t\t}\n\n\t\tev->source.client = client->number;\t \n\t\t \n\t\tif (check_event_type_and_length(ev)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!event_is_compatible(client, ev)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!snd_seq_ev_is_ump(ev)) {\n\t\t\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\t\t\tgoto __skip_event;\n\t\t\telse if (snd_seq_ev_is_reserved(ev)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (snd_seq_ev_is_variable(ev)) {\n\t\t\tint extlen = ev->data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif ((size_t)(extlen + len) > count) {\n\t\t\t\t \n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tev->data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\n\t\t\tev->data.ext.ptr = (char __force *)buf + len;\n\t\t\tlen += extlen;  \n\t\t} else {\n#ifdef CONFIG_COMPAT\n\t\t\tif (client->convert32 && snd_seq_ev_is_varusr(ev))\n\t\t\t\tev->data.ext.ptr =\n\t\t\t\t\t(void __force *)compat_ptr(ev->data.raw32.d[1]);\n#endif\n\t\t}\n\n\t\t \n\t\terr = snd_seq_client_enqueue_event(client, ev, file,\n\t\t\t\t\t\t   !(file->f_flags & O_NONBLOCK),\n\t\t\t\t\t\t   0, 0, &client->ioctl_mutex);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\thandled++;\n\n\t__skip_event:\n\t\t \n\t\tcount -= len;\n\t\tbuf += len;\n\t\twritten += len;\n\n\t\t \n\t\tif (++handled >= 200) {\n\t\t\tmutex_unlock(&client->ioctl_mutex);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n out:\n\tmutex_unlock(&client->ioctl_mutex);\n\treturn written ? written : err;\n}\n\n\n \nstatic __poll_t snd_seq_poll(struct file *file, poll_table * wait)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\t__poll_t mask = 0;\n\n\t \n\tif (snd_BUG_ON(!client))\n\t\treturn EPOLLERR;\n\n\tif ((snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT) &&\n\t    client->data.user.fifo) {\n\n\t\t \n\t\tif (snd_seq_fifo_poll_wait(client->data.user.fifo, file, wait))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\tif (snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT) {\n\n\t\t \n\t\tif (!snd_seq_write_pool_allocated(client) ||\n\t\t    snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\n\treturn mask;\n}\n\n\n \n\nstatic int snd_seq_ioctl_pversion(struct snd_seq_client *client, void *arg)\n{\n\tint *pversion = arg;\n\n\t*pversion = SNDRV_SEQ_VERSION;\n\treturn 0;\n}\n\nstatic int snd_seq_ioctl_user_pversion(struct snd_seq_client *client, void *arg)\n{\n\tclient->user_pversion = *(unsigned int *)arg;\n\treturn 0;\n}\n\nstatic int snd_seq_ioctl_client_id(struct snd_seq_client *client, void *arg)\n{\n\tint *client_id = arg;\n\n\t*client_id = client->number;\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_system_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_system_info *info = arg;\n\n\tmemset(info, 0, sizeof(*info));\n\t \n\tinfo->queues = SNDRV_SEQ_MAX_QUEUES;\n\tinfo->clients = SNDRV_SEQ_MAX_CLIENTS;\n\tinfo->ports = SNDRV_SEQ_MAX_PORTS;\n\tinfo->channels = 256;\t \n\tinfo->cur_clients = client_usage.cur;\n\tinfo->cur_queues = snd_seq_queue_get_cur_queues();\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)\n{\n\tstruct snd_seq_running_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\t \n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t \n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (!info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info->cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info->cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n\n \nstatic void get_client_info(struct snd_seq_client *cptr,\n\t\t\t    struct snd_seq_client_info *info)\n{\n\tinfo->client = cptr->number;\n\n\t \n\tinfo->type = cptr->type;\n\tstrcpy(info->name, cptr->name);\n\tinfo->filter = cptr->filter;\n\tinfo->event_lost = cptr->event_lost;\n\tmemcpy(info->event_filter, cptr->event_filter, 32);\n\tinfo->group_filter = cptr->group_filter;\n\tinfo->num_ports = cptr->num_ports;\n\n\tif (cptr->type == USER_CLIENT)\n\t\tinfo->pid = pid_vnr(cptr->data.user.owner);\n\telse\n\t\tinfo->pid = -1;\n\n\tif (cptr->type == KERNEL_CLIENT)\n\t\tinfo->card = cptr->data.kernel.card ? cptr->data.kernel.card->number : -1;\n\telse\n\t\tinfo->card = -1;\n\n\tinfo->midi_version = cptr->midi_version;\n\tmemset(info->reserved, 0, sizeof(info->reserved));\n}\n\nstatic int snd_seq_ioctl_get_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\tstruct snd_seq_client *cptr;\n\n\t \n\tcptr = snd_seq_client_use_ptr(client_info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t \n\n\tget_client_info(cptr, client_info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_set_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\n\t \n\tif (client->number != client_info->client)\n\t\treturn -EPERM;\n\t \n\tif (client->type != client_info->type)\n\t\treturn -EINVAL;\n\n\t \n\tif (client->user_pversion >= SNDRV_PROTOCOL_VERSION(1, 0, 3) &&\n\t    client_info->midi_version > SNDRV_SEQ_CLIENT_UMP_MIDI_2_0)\n\t\treturn -EINVAL;\n\n\t \n\tif (client_info->name[0])\n\t\tstrscpy(client->name, client_info->name, sizeof(client->name));\n\n\tclient->filter = client_info->filter;\n\tclient->event_lost = client_info->event_lost;\n\tif (client->user_pversion >= SNDRV_PROTOCOL_VERSION(1, 0, 3))\n\t\tclient->midi_version = client_info->midi_version;\n\tmemcpy(client->event_filter, client_info->event_filter, 32);\n\tclient->group_filter = client_info->group_filter;\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tint port_idx, err;\n\n\t \n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tif (client->type == USER_CLIENT && info->kernel)\n\t\treturn -EINVAL;\n\tif ((info->capability & SNDRV_SEQ_PORT_CAP_UMP_ENDPOINT) &&\n\t    client->ump_endpoint_port >= 0)\n\t\treturn -EBUSY;\n\n\tif (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT)\n\t\tport_idx = info->addr.port;\n\telse\n\t\tport_idx = -1;\n\tif (port_idx >= SNDRV_SEQ_ADDRESS_UNKNOWN)\n\t\treturn -EINVAL;\n\terr = snd_seq_create_port(client, port_idx, &port);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (client->type == KERNEL_CLIENT) {\n\t\tcallback = info->kernel;\n\t\tif (callback) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n\n\tsnd_seq_set_port_info(port, info);\n\tif (info->capability & SNDRV_SEQ_PORT_CAP_UMP_ENDPOINT)\n\t\tclient->ump_endpoint_port = port->addr.port;\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\tsnd_seq_port_unlock(port);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_delete_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tint err;\n\n\t \n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\terr = snd_seq_delete_port(client, info->addr.port);\n\tif (err >= 0) {\n\t\tif (client->ump_endpoint_port == info->addr.port)\n\t\t\tclient->ump_endpoint_port = -1;\n\t\tsnd_seq_system_client_ev_port_exit(client->number, info->addr.port);\n\t}\n\treturn err;\n}\n\n\n \nstatic int snd_seq_ioctl_get_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\tport = snd_seq_port_use_ptr(cptr, info->addr.port);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\t\t\t \n\t}\n\n\t \n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_set_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\n\tif (info->addr.client != client->number)  \n\t\treturn -EPERM;\n\tport = snd_seq_port_use_ptr(client, info->addr.port);\n\tif (port) {\n\t\tsnd_seq_set_port_info(port, info);\n\t\tsnd_seq_port_unlock(port);\n\t}\n\treturn 0;\n}\n\n\n \n#define PERM_RD\t\t(SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ)\n#define PERM_WR\t\t(SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_SUBS_WRITE)\n\nstatic int check_subscription_permission(struct snd_seq_client *client,\n\t\t\t\t\t struct snd_seq_client_port *sport,\n\t\t\t\t\t struct snd_seq_client_port *dport,\n\t\t\t\t\t struct snd_seq_port_subscribe *subs)\n{\n\tif (client->number != subs->sender.client &&\n\t    client->number != subs->dest.client) {\n\t\t \n\t\tif (check_port_perm(sport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t\tif (check_port_perm(dport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\t \n\tif (client->number != subs->sender.client) {\n\t\tif (! check_port_perm(sport, PERM_RD))\n\t\t\treturn -EPERM;\n\t}\n\t \n\tif (client->number != subs->dest.client) {\n\t\tif (! check_port_perm(dport, PERM_WR))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\n \nint snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info,\n\t\t\t\t       int evtype)\n{\n\tstruct snd_seq_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = evtype;\n\tevent.data.connect.dest = info->dest;\n\tevent.data.connect.sender = info->sender;\n\n\treturn snd_seq_system_notify(client, port, &event);   \n}\n\n\n \nstatic int snd_seq_ioctl_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -EINVAL;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\treceiver = snd_seq_client_use_ptr(subs->dest.client);\n\tif (!receiver)\n\t\tgoto __end;\n\tsender = snd_seq_client_use_ptr(subs->sender.client);\n\tif (!sender)\n\t\tgoto __end;\n\tsport = snd_seq_port_use_ptr(sender, subs->sender.port);\n\tif (!sport)\n\t\tgoto __end;\n\tdport = snd_seq_port_use_ptr(receiver, subs->dest.port);\n\tif (!dport)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\t \n\tresult = snd_seq_port_connect(client, sender, sport, receiver, dport, subs);\n\tif (! result)  \n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n \nstatic int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\treceiver = snd_seq_client_use_ptr(subs->dest.client);\n\tif (!receiver)\n\t\tgoto __end;\n\tsender = snd_seq_client_use_ptr(subs->sender.client);\n\tif (!sender)\n\t\tgoto __end;\n\tsport = snd_seq_port_use_ptr(sender, subs->sender.port);\n\tif (!sport)\n\t\tgoto __end;\n\tdport = snd_seq_port_use_ptr(receiver, subs->dest.port);\n\tif (!dport)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\tresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, subs);\n\tif (! result)  \n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n \nstatic int snd_seq_ioctl_create_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_alloc(client->number, info->locked, info->flags);\n\tif (IS_ERR(q))\n\t\treturn PTR_ERR(q);\n\n\tinfo->queue = q->queue;\n\tinfo->locked = q->locked;\n\tinfo->owner = q->owner;\n\n\t \n\tif (!info->name[0])\n\t\tsnprintf(info->name, sizeof(info->name), \"Queue-%d\", q->queue);\n\tstrscpy(q->name, info->name, sizeof(q->name));\n\tsnd_use_lock_free(&q->use_lock);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_delete_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\n\treturn snd_seq_queue_delete(client->number, info->queue);\n}\n\n \nstatic int snd_seq_ioctl_get_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(info->queue);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tstrscpy(info->name, q->name, sizeof(info->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_set_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tif (info->owner != client->number)\n\t\treturn -EINVAL;\n\n\t \n\tif (snd_seq_queue_check_access(info->queue, client->number)) {\n\t\tif (snd_seq_queue_set_owner(info->queue, client->number, info->locked) < 0)\n\t\t\treturn -EPERM;\n\t\tif (info->locked)\n\t\t\tsnd_seq_queue_use(info->queue, client->number, 1);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\tq = queueptr(info->queue);\n\tif (! q)\n\t\treturn -EINVAL;\n\tif (q->owner != client->number) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\tstrscpy(q->name, info->name, sizeof(q->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_get_named_queue(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_find_name(info->name);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_get_queue_status(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_status *status = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(status->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(status, 0, sizeof(*status));\n\tstatus->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\tstatus->events = queue->tickq->cells + queue->timeq->cells;\n\n\tstatus->time = snd_seq_timer_get_cur_time(tmr, true);\n\tstatus->tick = snd_seq_timer_get_cur_tick(tmr);\n\n\tstatus->running = tmr->running;\n\n\tstatus->flags = queue->flags;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_get_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(tempo->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(tempo, 0, sizeof(*tempo));\n\ttempo->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\n\ttempo->tempo = tmr->tempo;\n\ttempo->ppq = tmr->ppq;\n\ttempo->skew_value = tmr->skew;\n\ttempo->skew_base = tmr->skew_base;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n \nint snd_seq_set_queue_tempo(int client, struct snd_seq_queue_tempo *tempo)\n{\n\tif (!snd_seq_queue_check_access(tempo->queue, client))\n\t\treturn -EPERM;\n\treturn snd_seq_queue_timer_set_tempo(tempo->queue, client, tempo);\n}\nEXPORT_SYMBOL(snd_seq_set_queue_tempo);\n\nstatic int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tint result;\n\n\tresult = snd_seq_set_queue_tempo(client->number, tempo);\n\treturn result < 0 ? result : 0;\n}\n\n\n \nstatic int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(timer->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&queue->timer_mutex);\n\ttmr = queue->timer;\n\tmemset(timer, 0, sizeof(*timer));\n\ttimer->queue = queue->queue;\n\n\ttimer->type = tmr->type;\n\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\ttimer->u.alsa.id = tmr->alsa_id;\n\t\ttimer->u.alsa.resolution = tmr->preferred_resolution;\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\t\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tint result = 0;\n\n\tif (timer->type != SNDRV_SEQ_TIMER_ALSA)\n\t\treturn -EINVAL;\n\n\tif (snd_seq_queue_check_access(timer->queue, client->number)) {\n\t\tstruct snd_seq_queue *q;\n\t\tstruct snd_seq_timer *tmr;\n\n\t\tq = queueptr(timer->queue);\n\t\tif (q == NULL)\n\t\t\treturn -ENXIO;\n\t\tmutex_lock(&q->timer_mutex);\n\t\ttmr = q->timer;\n\t\tsnd_seq_queue_timer_close(timer->queue);\n\t\ttmr->type = timer->type;\n\t\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\t\ttmr->alsa_id = timer->u.alsa.id;\n\t\t\ttmr->preferred_resolution = timer->u.alsa.resolution;\n\t\t}\n\t\tresult = snd_seq_queue_timer_open(timer->queue);\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\treturn result;\n}\n\n\n \nstatic int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint used;\n\n\tused = snd_seq_queue_is_used(info->queue, client->number);\n\tif (used < 0)\n\t\treturn -EINVAL;\n\tinfo->used = used;\n\tinfo->client = client->number;\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_set_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint err;\n\n\tif (info->used >= 0) {\n\t\terr = snd_seq_queue_use(info->queue, client->number, info->used);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_seq_ioctl_get_queue_client(client, arg);\n}\n\n\n \nstatic int snd_seq_ioctl_get_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tstruct snd_seq_client *cptr;\n\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->client = cptr->number;\n\tinfo->output_pool = cptr->pool->size;\n\tinfo->output_room = cptr->pool->room;\n\tinfo->output_free = info->output_pool;\n\tinfo->output_free = snd_seq_unused_cells(cptr->pool);\n\tif (cptr->type == USER_CLIENT) {\n\t\tinfo->input_pool = cptr->data.user.fifo_pool_size;\n\t\tinfo->input_free = info->input_pool;\n\t\tinfo->input_free = snd_seq_fifo_unused_cells(cptr->data.user.fifo);\n\t} else {\n\t\tinfo->input_pool = 0;\n\t\tinfo->input_free = 0;\n\t}\n\tsnd_seq_client_unlock(cptr);\n\t\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tint rc;\n\n\tif (client->number != info->client)\n\t\treturn -EINVAL;  \n\n\tif (info->output_pool >= 1 && info->output_pool <= SNDRV_SEQ_MAX_EVENTS &&\n\t    (! snd_seq_write_pool_allocated(client) ||\n\t     info->output_pool != client->pool->size)) {\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\t \n\t\t\tif (atomic_read(&client->pool->counter))\n\t\t\t\treturn -EBUSY;\n\t\t\t \n\t\t\tsnd_seq_pool_mark_closing(client->pool);\n\t\t\tsnd_seq_pool_done(client->pool);\n\t\t}\n\t\tclient->pool->size = info->output_pool;\n\t\trc = snd_seq_pool_init(client->pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\tif (client->type == USER_CLIENT && client->data.user.fifo != NULL &&\n\t    info->input_pool >= 1 &&\n\t    info->input_pool <= SNDRV_SEQ_MAX_CLIENT_EVENTS &&\n\t    info->input_pool != client->data.user.fifo_pool_size) {\n\t\t \n\t\trc = snd_seq_fifo_resize(client->data.user.fifo, info->input_pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tclient->data.user.fifo_pool_size = info->input_pool;\n\t}\n\tif (info->output_room >= 1 &&\n\t    info->output_room <= client->pool->size) {\n\t\tclient->pool->room  = info->output_room;\n\t}\n\n\treturn snd_seq_ioctl_get_client_pool(client, arg);\n}\n\n\n \nstatic int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_seq_remove_events *info = arg;\n\n\t \n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\t \n\t\tif (client->type == USER_CLIENT && client->data.user.fifo)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, info);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_seq_ioctl_get_subscription(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result;\n\tstruct snd_seq_client *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL;\n\n\tresult = -EINVAL;\n\tsender = snd_seq_client_use_ptr(subs->sender.client);\n\tif (!sender)\n\t\tgoto __end;\n\tsport = snd_seq_port_use_ptr(sender, subs->sender.port);\n\tif (!sport)\n\t\tgoto __end;\n\tresult = snd_seq_port_get_subscription(&sport->c_src, &subs->dest,\n\t\t\t\t\t       subs);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\n\treturn result;\n}\n\n\n \nstatic int snd_seq_ioctl_query_subs(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_query_subs *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *cptr = NULL;\n\tstruct snd_seq_client_port *port = NULL;\n\tstruct snd_seq_port_subs_info *group;\n\tstruct list_head *p;\n\tint i;\n\n\tcptr = snd_seq_client_use_ptr(subs->root.client);\n\tif (!cptr)\n\t\tgoto __end;\n\tport = snd_seq_port_use_ptr(cptr, subs->root.port);\n\tif (!port)\n\t\tgoto __end;\n\n\tswitch (subs->type) {\n\tcase SNDRV_SEQ_QUERY_SUBS_READ:\n\t\tgroup = &port->c_src;\n\t\tbreak;\n\tcase SNDRV_SEQ_QUERY_SUBS_WRITE:\n\t\tgroup = &port->c_dest;\n\t\tbreak;\n\tdefault:\n\t\tgoto __end;\n\t}\n\n\tdown_read(&group->list_mutex);\n\t \n\tsubs->num_subs = group->count;\n\ti = 0;\n\tresult = -ENOENT;\n\tlist_for_each(p, &group->list_head) {\n\t\tif (i++ == subs->index) {\n\t\t\t \n\t\t\tstruct snd_seq_subscribers *s;\n\t\t\tif (subs->type == SNDRV_SEQ_QUERY_SUBS_READ) {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\t\t\tsubs->addr = s->info.dest;\n\t\t\t} else {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\t\t\tsubs->addr = s->info.sender;\n\t\t\t}\n\t\t\tsubs->flags = s->info.flags;\n\t\t\tsubs->queue = s->info.queue;\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&group->list_mutex);\n\n      __end:\n   \tif (port)\n\t\tsnd_seq_port_unlock(port);\n\tif (cptr)\n\t\tsnd_seq_client_unlock(cptr);\n\n\treturn result;\n}\n\n\n \nstatic int snd_seq_ioctl_query_next_client(struct snd_seq_client *client,\n\t\t\t\t\t   void *arg)\n{\n\tstruct snd_seq_client_info *info = arg;\n\tstruct snd_seq_client *cptr = NULL;\n\n\t \n\tif (info->client < INT_MAX)\n\t\tinfo->client++;\n\tif (info->client < 0)\n\t\tinfo->client = 0;\n\tfor (; info->client < SNDRV_SEQ_MAX_CLIENTS; info->client++) {\n\t\tcptr = snd_seq_client_use_ptr(info->client);\n\t\tif (cptr)\n\t\t\tbreak;  \n\t}\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\n\tget_client_info(cptr, info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n \nstatic int snd_seq_ioctl_query_next_port(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port = NULL;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\t \n\tinfo->addr.port++;\n\tport = snd_seq_port_query_nearest(cptr, info);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tinfo->addr = port->addr;\n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n#define NUM_UMP_INFOS (SNDRV_UMP_MAX_BLOCKS + 1)\n\nstatic void free_ump_info(struct snd_seq_client *client)\n{\n\tint i;\n\n\tif (!client->ump_info)\n\t\treturn;\n\tfor (i = 0; i < NUM_UMP_INFOS; i++)\n\t\tkfree(client->ump_info[i]);\n\tkfree(client->ump_info);\n\tclient->ump_info = NULL;\n}\n\nstatic void terminate_ump_info_strings(void *p, int type)\n{\n\tif (type == SNDRV_SEQ_CLIENT_UMP_INFO_ENDPOINT) {\n\t\tstruct snd_ump_endpoint_info *ep = p;\n\t\tep->name[sizeof(ep->name) - 1] = 0;\n\t} else {\n\t\tstruct snd_ump_block_info *bp = p;\n\t\tbp->name[sizeof(bp->name) - 1] = 0;\n\t}\n}\n\n#ifdef CONFIG_SND_PROC_FS\nstatic void dump_ump_info(struct snd_info_buffer *buffer,\n\t\t\t  struct snd_seq_client *client)\n{\n\tstruct snd_ump_endpoint_info *ep;\n\tstruct snd_ump_block_info *bp;\n\tint i;\n\n\tif (!client->ump_info)\n\t\treturn;\n\tep = client->ump_info[SNDRV_SEQ_CLIENT_UMP_INFO_ENDPOINT];\n\tif (ep && *ep->name)\n\t\tsnd_iprintf(buffer, \"  UMP Endpoint: \\\"%s\\\"\\n\", ep->name);\n\tfor (i = 0; i < SNDRV_UMP_MAX_BLOCKS; i++) {\n\t\tbp = client->ump_info[i + 1];\n\t\tif (bp && *bp->name) {\n\t\t\tsnd_iprintf(buffer, \"  UMP Block %d: \\\"%s\\\" [%s]\\n\",\n\t\t\t\t    i, bp->name,\n\t\t\t\t    bp->active ? \"Active\" : \"Inactive\");\n\t\t\tsnd_iprintf(buffer, \"    Groups: %d-%d\\n\",\n\t\t\t\t    bp->first_group + 1,\n\t\t\t\t    bp->first_group + bp->num_groups);\n\t\t}\n\t}\n}\n#endif\n\n \nstatic int snd_seq_ioctl_client_ump_info(struct snd_seq_client *caller,\n\t\t\t\t\t unsigned int cmd,\n\t\t\t\t\t unsigned long arg)\n{\n\tstruct snd_seq_client_ump_info __user *argp =\n\t\t(struct snd_seq_client_ump_info __user *)arg;\n\tstruct snd_seq_client *cptr;\n\tint client, type, err = 0;\n\tsize_t size;\n\tvoid *p;\n\n\tif (get_user(client, &argp->client) || get_user(type, &argp->type))\n\t\treturn -EFAULT;\n\tif (cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_UMP_INFO &&\n\t    caller->number != client)\n\t\treturn -EPERM;\n\tif (type < 0 || type >= NUM_UMP_INFOS)\n\t\treturn -EINVAL;\n\tif (type == SNDRV_SEQ_CLIENT_UMP_INFO_ENDPOINT)\n\t\tsize = sizeof(struct snd_ump_endpoint_info);\n\telse\n\t\tsize = sizeof(struct snd_ump_block_info);\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (!cptr)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&cptr->ioctl_mutex);\n\tif (!cptr->midi_version) {\n\t\terr = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tif (cmd == SNDRV_SEQ_IOCTL_GET_CLIENT_UMP_INFO) {\n\t\tif (!cptr->ump_info)\n\t\t\tp = NULL;\n\t\telse\n\t\t\tp = cptr->ump_info[type];\n\t\tif (!p) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\tif (copy_to_user(argp->info, p, size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (cptr->type != USER_CLIENT) {\n\t\t\terr = -EBADFD;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!cptr->ump_info) {\n\t\t\tcptr->ump_info = kcalloc(NUM_UMP_INFOS,\n\t\t\t\t\t\t sizeof(void *), GFP_KERNEL);\n\t\t\tif (!cptr->ump_info) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tp = memdup_user(argp->info, size);\n\t\tif (IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tgoto error;\n\t\t}\n\t\tkfree(cptr->ump_info[type]);\n\t\tterminate_ump_info_strings(p, type);\n\t\tcptr->ump_info[type] = p;\n\t}\n\n error:\n\tmutex_unlock(&cptr->ioctl_mutex);\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n#endif\n\n \n\nstatic const struct ioctl_handler {\n\tunsigned int cmd;\n\tint (*func)(struct snd_seq_client *client, void *arg);\n} ioctl_handlers[] = {\n\t{ SNDRV_SEQ_IOCTL_PVERSION, snd_seq_ioctl_pversion },\n\t{ SNDRV_SEQ_IOCTL_USER_PVERSION, snd_seq_ioctl_user_pversion },\n\t{ SNDRV_SEQ_IOCTL_CLIENT_ID, snd_seq_ioctl_client_id },\n\t{ SNDRV_SEQ_IOCTL_SYSTEM_INFO, snd_seq_ioctl_system_info },\n\t{ SNDRV_SEQ_IOCTL_RUNNING_MODE, snd_seq_ioctl_running_mode },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_INFO, snd_seq_ioctl_get_client_info },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, snd_seq_ioctl_set_client_info },\n\t{ SNDRV_SEQ_IOCTL_CREATE_PORT, snd_seq_ioctl_create_port },\n\t{ SNDRV_SEQ_IOCTL_DELETE_PORT, snd_seq_ioctl_delete_port },\n\t{ SNDRV_SEQ_IOCTL_GET_PORT_INFO, snd_seq_ioctl_get_port_info },\n\t{ SNDRV_SEQ_IOCTL_SET_PORT_INFO, snd_seq_ioctl_set_port_info },\n\t{ SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, snd_seq_ioctl_subscribe_port },\n\t{ SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, snd_seq_ioctl_unsubscribe_port },\n\t{ SNDRV_SEQ_IOCTL_CREATE_QUEUE, snd_seq_ioctl_create_queue },\n\t{ SNDRV_SEQ_IOCTL_DELETE_QUEUE, snd_seq_ioctl_delete_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_INFO, snd_seq_ioctl_get_queue_info },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_INFO, snd_seq_ioctl_set_queue_info },\n\t{ SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE, snd_seq_ioctl_get_named_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS, snd_seq_ioctl_get_queue_status },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO, snd_seq_ioctl_get_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO, snd_seq_ioctl_set_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER, snd_seq_ioctl_get_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER, snd_seq_ioctl_set_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT, snd_seq_ioctl_get_queue_client },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT, snd_seq_ioctl_set_queue_client },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, snd_seq_ioctl_get_client_pool },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, snd_seq_ioctl_set_client_pool },\n\t{ SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION, snd_seq_ioctl_get_subscription },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, snd_seq_ioctl_query_next_client },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, snd_seq_ioctl_query_next_port },\n\t{ SNDRV_SEQ_IOCTL_REMOVE_EVENTS, snd_seq_ioctl_remove_events },\n\t{ SNDRV_SEQ_IOCTL_QUERY_SUBS, snd_seq_ioctl_query_subs },\n\t{ 0, NULL },\n};\n\nstatic long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\t \n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n\t \n\tswitch (cmd) {\n\tcase SNDRV_SEQ_IOCTL_GET_CLIENT_UMP_INFO:\n\tcase SNDRV_SEQ_IOCTL_SET_CLIENT_UMP_INFO:\n\t\treturn snd_seq_ioctl_client_ump_info(client, cmd, arg);\n\t}\n#endif\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\t \n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&client->ioctl_mutex);\n\terr = handler->func(client, &buf);\n\tmutex_unlock(&client->ioctl_mutex);\n\tif (err >= 0) {\n\t\t \n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"seq_compat.c\"\n#else\n#define snd_seq_ioctl_compat\tNULL\n#endif\n\n \n\n\n \nint snd_seq_create_kernel_client(struct snd_card *card, int client_index,\n\t\t\t\t const char *name_fmt, ...)\n{\n\tstruct snd_seq_client *client;\n\tva_list args;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tif (card && client_index >= SNDRV_SEQ_CLIENTS_PER_CARD)\n\t\treturn -EINVAL;\n\tif (card == NULL && client_index >= SNDRV_SEQ_GLOBAL_CLIENTS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\n\tif (card) {\n\t\tclient_index += SNDRV_SEQ_GLOBAL_CLIENTS\n\t\t\t+ card->number * SNDRV_SEQ_CLIENTS_PER_CARD;\n\t\tif (client_index >= SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN)\n\t\t\tclient_index = -1;\n\t}\n\n\t \n\tclient = seq_create_client1(client_index, 0);\n\tif (client == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\t \n\t}\n\tusage_alloc(&client_usage, 1);\n\n\tclient->accept_input = 1;\n\tclient->accept_output = 1;\n\tclient->data.kernel.card = card;\n\tclient->user_pversion = SNDRV_SEQ_VERSION;\n\t\t\n\tva_start(args, name_fmt);\n\tvsnprintf(client->name, sizeof(client->name), name_fmt, args);\n\tva_end(args);\n\n\tclient->type = KERNEL_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\t \n\tsnd_seq_system_client_ev_client_start(client->number);\n\t\n\t \n\treturn client->number;\n}\nEXPORT_SYMBOL(snd_seq_create_kernel_client);\n\n \nint snd_seq_delete_kernel_client(int client)\n{\n\tstruct snd_seq_client *ptr;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tptr = clientptr(client);\n\tif (ptr == NULL)\n\t\treturn -EINVAL;\n\n\tseq_free_client(ptr);\n\tkfree(ptr);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_delete_kernel_client);\n\n \nint snd_seq_kernel_client_enqueue(int client, struct snd_seq_event *ev,\n\t\t\t\t  struct file *file, bool blocking)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\tif (!snd_seq_ev_is_ump(ev)) {\n\t\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\t\treturn 0;  \n\t\tif (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\n\t\t\treturn -EINVAL;  \n\t}\n\n\t \n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\t\n\tif (!cptr->accept_output) {\n\t\tresult = -EPERM;\n\t} else {  \n\t\tmutex_lock(&cptr->ioctl_mutex);\n\t\tresult = snd_seq_client_enqueue_event(cptr, ev, file, blocking,\n\t\t\t\t\t\t      false, 0,\n\t\t\t\t\t\t      &cptr->ioctl_mutex);\n\t\tmutex_unlock(&cptr->ioctl_mutex);\n\t}\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_enqueue);\n\n \nint snd_seq_kernel_client_dispatch(int client, struct snd_seq_event * ev,\n\t\t\t\t   int atomic, int hop)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\t \n\tev->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\n\tif (!cptr->accept_output)\n\t\tresult = -EPERM;\n\telse\n\t\tresult = snd_seq_deliver_event(cptr, ev, atomic, hop);\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_dispatch);\n\n \nint snd_seq_kernel_client_ctl(int clientid, unsigned int cmd, void *arg)\n{\n\tconst struct ioctl_handler *handler;\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\treturn handler->func(client, arg);\n\t}\n\n\tpr_debug(\"ALSA: seq unknown ioctl() 0x%x (type='%c', number=0x%02x)\\n\",\n\t\t cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));\n\treturn -ENOTTY;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_ctl);\n\n \nint snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait)\n{\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn 1;\n\tif (snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_write_poll);\n\n \nstruct snd_seq_client *snd_seq_kernel_client_get(int id)\n{\n\treturn snd_seq_client_use_ptr(id);\n}\nEXPORT_SYMBOL_GPL(snd_seq_kernel_client_get);\n\n \nvoid snd_seq_kernel_client_put(struct snd_seq_client *cptr)\n{\n\tif (cptr)\n\t\tsnd_seq_client_unlock(cptr);\n}\nEXPORT_SYMBOL_GPL(snd_seq_kernel_client_put);\n\n \n\n#ifdef CONFIG_SND_PROC_FS\n \nstatic void snd_seq_info_dump_subscribers(struct snd_info_buffer *buffer,\n\t\t\t\t\t  struct snd_seq_port_subs_info *group,\n\t\t\t\t\t  int is_src, char *msg)\n{\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint count = 0;\n\n\tdown_read(&group->list_mutex);\n\tif (list_empty(&group->list_head)) {\n\t\tup_read(&group->list_mutex);\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, msg);\n\tlist_for_each(p, &group->list_head) {\n\t\tif (is_src)\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\telse\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\tif (count++)\n\t\t\tsnd_iprintf(buffer, \", \");\n\t\tsnd_iprintf(buffer, \"%d:%d\",\n\t\t\t    is_src ? s->info.dest.client : s->info.sender.client,\n\t\t\t    is_src ? s->info.dest.port : s->info.sender.port);\n\t\tif (s->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\tsnd_iprintf(buffer, \"[%c:%d]\", ((s->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL) ? 'r' : 't'), s->info.queue);\n\t\tif (group->exclusive)\n\t\t\tsnd_iprintf(buffer, \"[ex]\");\n\t}\n\tup_read(&group->list_mutex);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\n#define FLAG_PERM_RD(perm) ((perm) & SNDRV_SEQ_PORT_CAP_READ ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_READ ? 'R' : 'r') : '-')\n#define FLAG_PERM_WR(perm) ((perm) & SNDRV_SEQ_PORT_CAP_WRITE ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_WRITE ? 'W' : 'w') : '-')\n#define FLAG_PERM_EX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_NO_EXPORT ? '-' : 'e')\n\n#define FLAG_PERM_DUPLEX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_DUPLEX ? 'X' : '-')\n\nstatic const char *port_direction_name(unsigned char dir)\n{\n\tstatic const char *names[4] = {\n\t\t\"-\", \"In\", \"Out\", \"In/Out\"\n\t};\n\n\tif (dir > SNDRV_SEQ_PORT_DIR_BIDIRECTION)\n\t\treturn \"Invalid\";\n\treturn names[dir];\n}\n\nstatic void snd_seq_info_dump_ports(struct snd_info_buffer *buffer,\n\t\t\t\t    struct snd_seq_client *client)\n{\n\tstruct snd_seq_client_port *p;\n\n\tmutex_lock(&client->ports_mutex);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->capability & SNDRV_SEQ_PORT_CAP_INACTIVE)\n\t\t\tcontinue;\n\t\tsnd_iprintf(buffer, \"  Port %3d : \\\"%s\\\" (%c%c%c%c) [%s]\\n\",\n\t\t\t    p->addr.port, p->name,\n\t\t\t    FLAG_PERM_RD(p->capability),\n\t\t\t    FLAG_PERM_WR(p->capability),\n\t\t\t    FLAG_PERM_EX(p->capability),\n\t\t\t    FLAG_PERM_DUPLEX(p->capability),\n\t\t\t    port_direction_name(p->direction));\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_src, 1, \"    Connecting To: \");\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_dest, 0, \"    Connected From: \");\n\t}\n\tmutex_unlock(&client->ports_mutex);\n}\n\nstatic const char *midi_version_string(unsigned int version)\n{\n\tswitch (version) {\n\tcase SNDRV_SEQ_CLIENT_LEGACY_MIDI:\n\t\treturn \"Legacy\";\n\tcase SNDRV_SEQ_CLIENT_UMP_MIDI_1_0:\n\t\treturn \"UMP MIDI1\";\n\tcase SNDRV_SEQ_CLIENT_UMP_MIDI_2_0:\n\t\treturn \"UMP MIDI2\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n \nvoid snd_seq_info_clients_read(struct snd_info_entry *entry, \n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint c;\n\tstruct snd_seq_client *client;\n\n\tsnd_iprintf(buffer, \"Client info\\n\");\n\tsnd_iprintf(buffer, \"  cur  clients : %d\\n\", client_usage.cur);\n\tsnd_iprintf(buffer, \"  peak clients : %d\\n\", client_usage.peak);\n\tsnd_iprintf(buffer, \"  max  clients : %d\\n\", SNDRV_SEQ_MAX_CLIENTS);\n\tsnd_iprintf(buffer, \"\\n\");\n\n\t \n\tfor (c = 0; c < SNDRV_SEQ_MAX_CLIENTS; c++) {\n\t\tclient = snd_seq_client_use_ptr(c);\n\t\tif (client == NULL)\n\t\t\tcontinue;\n\t\tif (client->type == NO_CLIENT) {\n\t\t\tsnd_seq_client_unlock(client);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"Client %3d : \\\"%s\\\" [%s %s]\\n\",\n\t\t\t    c, client->name,\n\t\t\t    client->type == USER_CLIENT ? \"User\" : \"Kernel\",\n\t\t\t    midi_version_string(client->midi_version));\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n\t\tdump_ump_info(buffer, client);\n#endif\n\t\tsnd_seq_info_dump_ports(buffer, client);\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\tsnd_iprintf(buffer, \"  Output pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->pool, \"    \");\n\t\t}\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo &&\n\t\t    client->data.user.fifo->pool) {\n\t\t\tsnd_iprintf(buffer, \"  Input pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->data.user.fifo->pool, \"    \");\n\t\t}\n\t\tsnd_seq_client_unlock(client);\n\t}\n}\n#endif  \n\n \n\n\n \n\nstatic const struct file_operations snd_seq_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_seq_read,\n\t.write =\tsnd_seq_write,\n\t.open =\t\tsnd_seq_open,\n\t.release =\tsnd_seq_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_seq_poll,\n\t.unlocked_ioctl =\tsnd_seq_ioctl,\n\t.compat_ioctl =\tsnd_seq_ioctl_compat,\n};\n\nstatic struct device *seq_dev;\n\n \nint __init snd_sequencer_device_init(void)\n{\n\tint err;\n\n\terr = snd_device_alloc(&seq_dev, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_name(seq_dev, \"seq\");\n\n\tmutex_lock(&register_mutex);\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0,\n\t\t\t\t  &snd_seq_f_ops, NULL, seq_dev);\n\tmutex_unlock(&register_mutex);\n\tif (err < 0) {\n\t\tput_device(seq_dev);\n\t\treturn err;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n \nvoid snd_sequencer_device_done(void)\n{\n\tsnd_unregister_device(seq_dev);\n\tput_device(seq_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}