{
  "module_name": "seq_system.c",
  "hash_id": "4cbe79a6c241af850518de81f62944e6010d28b5a94a2c26f3ca9e37a9506c77",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_system.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include \"seq_system.h\"\n#include \"seq_timer.h\"\n#include \"seq_queue.h\"\n\n \n\n \n\n\n \nstatic int sysclient = -1;\n\n \nstatic int announce_port = -1;\n\n\n\n \nstatic int setheader(struct snd_seq_event * ev, int client, int port)\n{\n\tif (announce_port < 0)\n\t\treturn -ENODEV;\n\n\tmemset(ev, 0, sizeof(struct snd_seq_event));\n\n\tev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\n\tev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\n\tev->source.client = sysclient;\n\tev->source.port = announce_port;\n\tev->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\n\t \n\t \n\tev->data.addr.client = client;\n\tev->data.addr.port = port;\n\n\treturn 0;\n}\n\n\n \nvoid snd_seq_system_broadcast(int client, int port, int type)\n{\n\tstruct snd_seq_event ev;\n\t\n\tif (setheader(&ev, client, port) < 0)\n\t\treturn;\n\tev.type = type;\n\tsnd_seq_kernel_client_dispatch(sysclient, &ev, 0, 0);\n}\nEXPORT_SYMBOL_GPL(snd_seq_system_broadcast);\n\n \nint snd_seq_system_notify(int client, int port, struct snd_seq_event *ev)\n{\n\tev->flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tev->source.client = sysclient;\n\tev->source.port = announce_port;\n\tev->dest.client = client;\n\tev->dest.port = port;\n\treturn snd_seq_kernel_client_dispatch(sysclient, ev, 0, 0);\n}\n\n \nstatic int event_input_timer(struct snd_seq_event * ev, int direct, void *private_data, int atomic, int hop)\n{\n\treturn snd_seq_control_queue(ev, atomic, hop);\n}\n\n \nint __init snd_seq_system_client_init(void)\n{\n\tstruct snd_seq_port_callback pcallbacks;\n\tstruct snd_seq_port_info *port;\n\tint err;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\tpcallbacks.owner = THIS_MODULE;\n\tpcallbacks.event_input = event_input_timer;\n\n\t \n\tsysclient = snd_seq_create_kernel_client(NULL, 0, \"System\");\n\tif (sysclient < 0) {\n\t\tkfree(port);\n\t\treturn sysclient;\n\t}\n\n\t \n\tstrcpy(port->name, \"Timer\");\n\tport->capability = SNDRV_SEQ_PORT_CAP_WRITE;  \n\tport->capability |= SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ;  \n\tport->kernel = &pcallbacks;\n\tport->type = 0;\n\tport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\n\tport->addr.client = sysclient;\n\tport->addr.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\n\terr = snd_seq_kernel_client_ctl(sysclient, SNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\tport);\n\tif (err < 0)\n\t\tgoto error_port;\n\n\t \n\tstrcpy(port->name, \"Announce\");\n\tport->capability = SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ;  \n\tport->kernel = NULL;\n\tport->type = 0;\n\tport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\n\tport->addr.client = sysclient;\n\tport->addr.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\n\terr = snd_seq_kernel_client_ctl(sysclient, SNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\tport);\n\tif (err < 0)\n\t\tgoto error_port;\n\tannounce_port = port->addr.port;\n\n\tkfree(port);\n\treturn 0;\n\n error_port:\n\tsnd_seq_system_client_done();\n\tkfree(port);\n\treturn err;\n}\n\n\n \nvoid snd_seq_system_client_done(void)\n{\n\tint oldsysclient = sysclient;\n\n\tif (oldsysclient >= 0) {\n\t\tsysclient = -1;\n\t\tannounce_port = -1;\n\t\tsnd_seq_delete_kernel_client(oldsysclient);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}