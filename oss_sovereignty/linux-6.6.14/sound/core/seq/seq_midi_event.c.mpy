{
  "module_name": "seq_midi_event.c",
  "hash_id": "577966ccd22f7755899e2915c05473012ade76324312e61a0fb2094c8685f2bd",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_midi_event.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/seq_kernel.h>\n#include <sound/seq_midi_event.h>\n#include <sound/asoundef.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"MIDI byte <-> sequencer event coder\");\nMODULE_LICENSE(\"GPL\");\n\n \n \n#define ST_INVALID\t7\n#define ST_SPECIAL\t8\n#define ST_SYSEX\tST_SPECIAL\n \n\n\n \nstatic void note_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void one_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void pitchbend_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void two_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void one_param_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void songpos_event(struct snd_midi_event *dev, struct snd_seq_event *ev);\nstatic void note_decode(struct snd_seq_event *ev, unsigned char *buf);\nstatic void one_param_decode(struct snd_seq_event *ev, unsigned char *buf);\nstatic void pitchbend_decode(struct snd_seq_event *ev, unsigned char *buf);\nstatic void two_param_decode(struct snd_seq_event *ev, unsigned char *buf);\nstatic void songpos_decode(struct snd_seq_event *ev, unsigned char *buf);\n\n \nstatic struct status_event_list {\n\tint event;\n\tint qlen;\n\tvoid (*encode)(struct snd_midi_event *dev, struct snd_seq_event *ev);\n\tvoid (*decode)(struct snd_seq_event *ev, unsigned char *buf);\n} status_event[] = {\n\t \n\t{SNDRV_SEQ_EVENT_NOTEOFF,\t 2, note_event, note_decode},\n\t{SNDRV_SEQ_EVENT_NOTEON,\t 2, note_event, note_decode},\n\t{SNDRV_SEQ_EVENT_KEYPRESS,\t 2, note_event, note_decode},\n\t{SNDRV_SEQ_EVENT_CONTROLLER,\t 2, two_param_ctrl_event, two_param_decode},\n\t{SNDRV_SEQ_EVENT_PGMCHANGE,\t 1, one_param_ctrl_event, one_param_decode},\n\t{SNDRV_SEQ_EVENT_CHANPRESS,\t 1, one_param_ctrl_event, one_param_decode},\n\t{SNDRV_SEQ_EVENT_PITCHBEND,\t 2, pitchbend_ctrl_event, pitchbend_decode},\n\t \n\t{SNDRV_SEQ_EVENT_NONE,\t\t-1, NULL, NULL},\n\t \n\t{SNDRV_SEQ_EVENT_SYSEX,\t\t 1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_QFRAME,\t 1, one_param_event, one_param_decode},  \n\t{SNDRV_SEQ_EVENT_SONGPOS,\t 2, songpos_event, songpos_decode},  \n\t{SNDRV_SEQ_EVENT_SONGSEL,\t 1, one_param_event, one_param_decode},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\t-1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\t-1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_TUNE_REQUEST,\t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\t-1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_CLOCK,\t\t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_NONE,\t\t-1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_START,\t\t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_CONTINUE,\t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_STOP, \t\t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_NONE, \t\t-1, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_SENSING, \t 0, NULL, NULL},  \n\t{SNDRV_SEQ_EVENT_RESET, \t 0, NULL, NULL},  \n};\n\nstatic int extra_decode_ctrl14(struct snd_midi_event *dev, unsigned char *buf, int len,\n\t\t\t       struct snd_seq_event *ev);\nstatic int extra_decode_xrpn(struct snd_midi_event *dev, unsigned char *buf, int count,\n\t\t\t     struct snd_seq_event *ev);\n\nstatic struct extra_event_list {\n\tint event;\n\tint (*decode)(struct snd_midi_event *dev, unsigned char *buf, int len,\n\t\t      struct snd_seq_event *ev);\n} extra_event[] = {\n\t{SNDRV_SEQ_EVENT_CONTROL14, extra_decode_ctrl14},\n\t{SNDRV_SEQ_EVENT_NONREGPARAM, extra_decode_xrpn},\n\t{SNDRV_SEQ_EVENT_REGPARAM, extra_decode_xrpn},\n};\n\n \n\nint snd_midi_event_new(int bufsize, struct snd_midi_event **rdev)\n{\n\tstruct snd_midi_event *dev;\n\n\t*rdev = NULL;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\tif (bufsize > 0) {\n\t\tdev->buf = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (dev->buf == NULL) {\n\t\t\tkfree(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tdev->bufsize = bufsize;\n\tdev->lastcmd = 0xff;\n\tdev->type = ST_INVALID;\n\tspin_lock_init(&dev->lock);\n\t*rdev = dev;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_midi_event_new);\n\nvoid snd_midi_event_free(struct snd_midi_event *dev)\n{\n\tif (dev != NULL) {\n\t\tkfree(dev->buf);\n\t\tkfree(dev);\n\t}\n}\nEXPORT_SYMBOL(snd_midi_event_free);\n\n \nstatic inline void reset_encode(struct snd_midi_event *dev)\n{\n\tdev->read = 0;\n\tdev->qlen = 0;\n\tdev->type = ST_INVALID;\n}\n\nvoid snd_midi_event_reset_encode(struct snd_midi_event *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\treset_encode(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\nEXPORT_SYMBOL(snd_midi_event_reset_encode);\n\nvoid snd_midi_event_reset_decode(struct snd_midi_event *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->lastcmd = 0xff;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\nEXPORT_SYMBOL(snd_midi_event_reset_decode);\n\nvoid snd_midi_event_no_status(struct snd_midi_event *dev, int on)\n{\n\tdev->nostat = on ? 1 : 0;\n}\nEXPORT_SYMBOL(snd_midi_event_no_status);\n\n \nbool snd_midi_event_encode_byte(struct snd_midi_event *dev, unsigned char c,\n\t\t\t\tstruct snd_seq_event *ev)\n{\n\tbool rc = false;\n\tunsigned long flags;\n\n\tif (c >= MIDI_CMD_COMMON_CLOCK) {\n\t\t \n\t\tev->type = status_event[ST_SPECIAL + c - 0xf0].event;\n\t\tev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\n\t\tev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\t\treturn ev->type != SNDRV_SEQ_EVENT_NONE;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif ((c & 0x80) &&\n\t    (c != MIDI_CMD_COMMON_SYSEX_END || dev->type != ST_SYSEX)) {\n\t\t \n\t\tdev->buf[0] = c;\n\t\tif ((c & 0xf0) == 0xf0)  \n\t\t\tdev->type = (c & 0x0f) + ST_SPECIAL;\n\t\telse\n\t\t\tdev->type = (c >> 4) & 0x07;\n\t\tdev->read = 1;\n\t\tdev->qlen = status_event[dev->type].qlen;\n\t} else {\n\t\tif (dev->qlen > 0) {\n\t\t\t \n\t\t\tdev->buf[dev->read++] = c;\n\t\t\tif (dev->type != ST_SYSEX)\n\t\t\t\tdev->qlen--;\n\t\t} else {\n\t\t\t \n\t\t\tdev->buf[1] = c;\n\t\t\tdev->qlen = status_event[dev->type].qlen - 1;\n\t\t\tdev->read = 2;\n\t\t}\n\t}\n\tif (dev->qlen == 0) {\n\t\tev->type = status_event[dev->type].event;\n\t\tev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\n\t\tev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\t\tif (status_event[dev->type].encode)  \n\t\t\tstatus_event[dev->type].encode(dev, ev);\n\t\tif (dev->type >= ST_SPECIAL)\n\t\t\tdev->type = ST_INVALID;\n\t\trc = true;\n\t} else \tif (dev->type == ST_SYSEX) {\n\t\tif (c == MIDI_CMD_COMMON_SYSEX_END ||\n\t\t    dev->read >= dev->bufsize) {\n\t\t\tev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\n\t\t\tev->flags |= SNDRV_SEQ_EVENT_LENGTH_VARIABLE;\n\t\t\tev->type = SNDRV_SEQ_EVENT_SYSEX;\n\t\t\tev->data.ext.len = dev->read;\n\t\t\tev->data.ext.ptr = dev->buf;\n\t\t\tif (c != MIDI_CMD_COMMON_SYSEX_END)\n\t\t\t\tdev->read = 0;  \n\t\t\telse\n\t\t\t\treset_encode(dev);  \n\t\t\trc = true;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL(snd_midi_event_encode_byte);\n\n \nstatic void note_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.note.channel = dev->buf[0] & 0x0f;\n\tev->data.note.note = dev->buf[1];\n\tev->data.note.velocity = dev->buf[2];\n}\n\n \nstatic void one_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.control.channel = dev->buf[0] & 0x0f;\n\tev->data.control.value = dev->buf[1];\n}\n\n \nstatic void pitchbend_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.control.channel = dev->buf[0] & 0x0f;\n\tev->data.control.value = (int)dev->buf[2] * 128 + (int)dev->buf[1] - 8192;\n}\n\n \nstatic void two_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.control.channel = dev->buf[0] & 0x0f;\n\tev->data.control.param = dev->buf[1];\n\tev->data.control.value = dev->buf[2];\n}\n\n \nstatic void one_param_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.control.value = dev->buf[1];\n}\n\n \nstatic void songpos_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\n{\n\tev->data.control.value = (int)dev->buf[2] * 128 + (int)dev->buf[1];\n}\n\n \nlong snd_midi_event_decode(struct snd_midi_event *dev, unsigned char *buf, long count,\n\t\t\t   struct snd_seq_event *ev)\n{\n\tunsigned int cmd, type;\n\n\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\treturn -ENOENT;\n\n\tfor (type = 0; type < ARRAY_SIZE(status_event); type++) {\n\t\tif (ev->type == status_event[type].event)\n\t\t\tgoto __found;\n\t}\n\tfor (type = 0; type < ARRAY_SIZE(extra_event); type++) {\n\t\tif (ev->type == extra_event[type].event)\n\t\t\treturn extra_event[type].decode(dev, buf, count, ev);\n\t}\n\treturn -ENOENT;\n\n      __found:\n\tif (type >= ST_SPECIAL)\n\t\tcmd = 0xf0 + (type - ST_SPECIAL);\n\telse\n\t\t \n\t\tcmd = 0x80 | (type << 4) | (ev->data.note.channel & 0x0f);\n\n\n\tif (cmd == MIDI_CMD_COMMON_SYSEX) {\n\t\tsnd_midi_event_reset_decode(dev);\n\t\treturn snd_seq_expand_var_event(ev, count, buf, 1, 0);\n\t} else {\n\t\tint qlen;\n\t\tunsigned char xbuf[4];\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tif ((cmd & 0xf0) == 0xf0 || dev->lastcmd != cmd || dev->nostat) {\n\t\t\tdev->lastcmd = cmd;\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\txbuf[0] = cmd;\n\t\t\tif (status_event[type].decode)\n\t\t\t\tstatus_event[type].decode(ev, xbuf + 1);\n\t\t\tqlen = status_event[type].qlen + 1;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tif (status_event[type].decode)\n\t\t\t\tstatus_event[type].decode(ev, xbuf + 0);\n\t\t\tqlen = status_event[type].qlen;\n\t\t}\n\t\tif (count < qlen)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, xbuf, qlen);\n\t\treturn qlen;\n\t}\n}\nEXPORT_SYMBOL(snd_midi_event_decode);\n\n\n \nstatic void note_decode(struct snd_seq_event *ev, unsigned char *buf)\n{\n\tbuf[0] = ev->data.note.note & 0x7f;\n\tbuf[1] = ev->data.note.velocity & 0x7f;\n}\n\n \nstatic void one_param_decode(struct snd_seq_event *ev, unsigned char *buf)\n{\n\tbuf[0] = ev->data.control.value & 0x7f;\n}\n\n \nstatic void pitchbend_decode(struct snd_seq_event *ev, unsigned char *buf)\n{\n\tint value = ev->data.control.value + 8192;\n\tbuf[0] = value & 0x7f;\n\tbuf[1] = (value >> 7) & 0x7f;\n}\n\n \nstatic void two_param_decode(struct snd_seq_event *ev, unsigned char *buf)\n{\n\tbuf[0] = ev->data.control.param & 0x7f;\n\tbuf[1] = ev->data.control.value & 0x7f;\n}\n\n \nstatic void songpos_decode(struct snd_seq_event *ev, unsigned char *buf)\n{\n\tbuf[0] = ev->data.control.value & 0x7f;\n\tbuf[1] = (ev->data.control.value >> 7) & 0x7f;\n}\n\n \nstatic int extra_decode_ctrl14(struct snd_midi_event *dev, unsigned char *buf,\n\t\t\t       int count, struct snd_seq_event *ev)\n{\n\tunsigned char cmd;\n\tint idx = 0;\n\n\tcmd = MIDI_CMD_CONTROL|(ev->data.control.channel & 0x0f);\n\tif (ev->data.control.param < 0x20) {\n\t\tif (count < 4)\n\t\t\treturn -ENOMEM;\n\t\tif (dev->nostat && count < 6)\n\t\t\treturn -ENOMEM;\n\t\tif (cmd != dev->lastcmd || dev->nostat) {\n\t\t\tif (count < 5)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbuf[idx++] = dev->lastcmd = cmd;\n\t\t}\n\t\tbuf[idx++] = ev->data.control.param;\n\t\tbuf[idx++] = (ev->data.control.value >> 7) & 0x7f;\n\t\tif (dev->nostat)\n\t\t\tbuf[idx++] = cmd;\n\t\tbuf[idx++] = ev->data.control.param + 0x20;\n\t\tbuf[idx++] = ev->data.control.value & 0x7f;\n\t} else {\n\t\tif (count < 2)\n\t\t\treturn -ENOMEM;\n\t\tif (cmd != dev->lastcmd || dev->nostat) {\n\t\t\tif (count < 3)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbuf[idx++] = dev->lastcmd = cmd;\n\t\t}\n\t\tbuf[idx++] = ev->data.control.param & 0x7f;\n\t\tbuf[idx++] = ev->data.control.value & 0x7f;\n\t}\n\treturn idx;\n}\n\n \nstatic int extra_decode_xrpn(struct snd_midi_event *dev, unsigned char *buf,\n\t\t\t     int count, struct snd_seq_event *ev)\n{\n\tunsigned char cmd;\n\tconst char *cbytes;\n\tstatic const char cbytes_nrpn[4] = { MIDI_CTL_NONREG_PARM_NUM_MSB,\n\t\t\t\t       MIDI_CTL_NONREG_PARM_NUM_LSB,\n\t\t\t\t       MIDI_CTL_MSB_DATA_ENTRY,\n\t\t\t\t       MIDI_CTL_LSB_DATA_ENTRY };\n\tstatic const char cbytes_rpn[4] =  { MIDI_CTL_REGIST_PARM_NUM_MSB,\n\t\t\t\t       MIDI_CTL_REGIST_PARM_NUM_LSB,\n\t\t\t\t       MIDI_CTL_MSB_DATA_ENTRY,\n\t\t\t\t       MIDI_CTL_LSB_DATA_ENTRY };\n\tunsigned char bytes[4];\n\tint idx = 0, i;\n\n\tif (count < 8)\n\t\treturn -ENOMEM;\n\tif (dev->nostat && count < 12)\n\t\treturn -ENOMEM;\n\tcmd = MIDI_CMD_CONTROL|(ev->data.control.channel & 0x0f);\n\tbytes[0] = (ev->data.control.param & 0x3f80) >> 7;\n\tbytes[1] = ev->data.control.param & 0x007f;\n\tbytes[2] = (ev->data.control.value & 0x3f80) >> 7;\n\tbytes[3] = ev->data.control.value & 0x007f;\n\tif (cmd != dev->lastcmd && !dev->nostat) {\n\t\tif (count < 9)\n\t\t\treturn -ENOMEM;\n\t\tbuf[idx++] = dev->lastcmd = cmd;\n\t}\n\tcbytes = ev->type == SNDRV_SEQ_EVENT_NONREGPARAM ? cbytes_nrpn : cbytes_rpn;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (dev->nostat)\n\t\t\tbuf[idx++] = dev->lastcmd = cmd;\n\t\tbuf[idx++] = cbytes[i];\n\t\tbuf[idx++] = bytes[i];\n\t}\n\treturn idx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}