{
  "module_name": "seq_ump_client.c",
  "hash_id": "02e582437120ebadfec4e1c5f08034c1125eff8e9b89866903d06c5995d3e31f",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_ump_client.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <asm/byteorder.h>\n#include <sound/core.h>\n#include <sound/ump.h>\n#include <sound/seq_kernel.h>\n#include <sound/seq_device.h>\n#include \"seq_clientmgr.h\"\n#include \"seq_system.h\"\n\nstruct seq_ump_client;\nstruct seq_ump_group;\n\nenum {\n\tSTR_IN = SNDRV_RAWMIDI_STREAM_INPUT,\n\tSTR_OUT = SNDRV_RAWMIDI_STREAM_OUTPUT\n};\n\n \nstruct seq_ump_group {\n\tint group;\t\t\t \n\tunsigned int dir_bits;\t\t \n\tbool active;\t\t\t \n\tchar name[64];\t\t\t \n};\n\n \nstruct seq_ump_input_buffer {\n\tunsigned char len;\t\t \n\tunsigned char pending;\t\t \n\tunsigned char type;\t\t \n\tunsigned char group;\t\t \n\tu32 buf[4];\t\t\t \n};\n\n \nstruct seq_ump_client {\n\tstruct snd_ump_endpoint *ump;\t \n\tint seq_client;\t\t\t \n\tint opened[2];\t\t\t \n\tstruct snd_rawmidi_file out_rfile;  \n\tstruct seq_ump_input_buffer input;  \n\tstruct seq_ump_group groups[SNDRV_UMP_MAX_GROUPS];  \n\tvoid *ump_info[SNDRV_UMP_MAX_BLOCKS + 1];  \n\tstruct work_struct group_notify_work;  \n};\n\n \nstatic unsigned char ump_packet_words[0x10] = {\n\t1, 1, 1, 2, 2, 4, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4\n};\n\n \nstatic unsigned char ump_group_to_seq_port(unsigned char group)\n{\n\treturn group + 1;\n}\n\n \nstatic void seq_ump_input_receive(struct snd_ump_endpoint *ump,\n\t\t\t\t  const u32 *val, int words)\n{\n\tstruct seq_ump_client *client = ump->seq_client;\n\tstruct snd_seq_ump_event ev = {};\n\n\tif (!client->opened[STR_IN])\n\t\treturn;\n\n\tif (ump_is_groupless_msg(ump_message_type(*val)))\n\t\tev.source.port = 0;  \n\telse\n\t\tev.source.port = ump_group_to_seq_port(ump_message_group(*val));\n\tev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\tev.flags = SNDRV_SEQ_EVENT_UMP;\n\tmemcpy(ev.ump, val, words << 2);\n\tsnd_seq_kernel_client_dispatch(client->seq_client,\n\t\t\t\t       (struct snd_seq_event *)&ev,\n\t\t\t\t       true, 0);\n}\n\n \nstatic int seq_ump_process_event(struct snd_seq_event *ev, int direct,\n\t\t\t\t void *private_data, int atomic, int hop)\n{\n\tstruct seq_ump_client *client = private_data;\n\tstruct snd_rawmidi_substream *substream;\n\tstruct snd_seq_ump_event *ump_ev;\n\tunsigned char type;\n\tint len;\n\n\tsubstream = client->out_rfile.output;\n\tif (!substream)\n\t\treturn -ENODEV;\n\tif (!snd_seq_ev_is_ump(ev))\n\t\treturn 0;  \n\tump_ev = (struct snd_seq_ump_event *)ev;\n\ttype = ump_message_type(ump_ev->ump[0]);\n\tlen = ump_packet_words[type];\n\tif (len > 4)\n\t\treturn 0; \n\tsnd_rawmidi_kernel_write(substream, ev->data.raw8.d, len << 2);\n\treturn 0;\n}\n\n \nstatic int seq_ump_client_open(struct seq_ump_client *client, int dir)\n{\n\tstruct snd_ump_endpoint *ump = client->ump;\n\tint err = 0;\n\n\tmutex_lock(&ump->open_mutex);\n\tif (dir == STR_OUT && !client->opened[dir]) {\n\t\terr = snd_rawmidi_kernel_open(&ump->core, 0,\n\t\t\t\t\t      SNDRV_RAWMIDI_LFLG_OUTPUT |\n\t\t\t\t\t      SNDRV_RAWMIDI_LFLG_APPEND,\n\t\t\t\t\t      &client->out_rfile);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tclient->opened[dir]++;\n unlock:\n\tmutex_unlock(&ump->open_mutex);\n\treturn err;\n}\n\n \nstatic int seq_ump_client_close(struct seq_ump_client *client, int dir)\n{\n\tstruct snd_ump_endpoint *ump = client->ump;\n\n\tmutex_lock(&ump->open_mutex);\n\tif (!--client->opened[dir])\n\t\tif (dir == STR_OUT)\n\t\t\tsnd_rawmidi_kernel_release(&client->out_rfile);\n\tmutex_unlock(&ump->open_mutex);\n\treturn 0;\n}\n\n \nstatic int seq_ump_subscribe(void *pdata, struct snd_seq_port_subscribe *info)\n{\n\tstruct seq_ump_client *client = pdata;\n\n\treturn seq_ump_client_open(client, STR_IN);\n}\n\nstatic int seq_ump_unsubscribe(void *pdata, struct snd_seq_port_subscribe *info)\n{\n\tstruct seq_ump_client *client = pdata;\n\n\treturn seq_ump_client_close(client, STR_IN);\n}\n\nstatic int seq_ump_use(void *pdata, struct snd_seq_port_subscribe *info)\n{\n\tstruct seq_ump_client *client = pdata;\n\n\treturn seq_ump_client_open(client, STR_OUT);\n}\n\nstatic int seq_ump_unuse(void *pdata, struct snd_seq_port_subscribe *info)\n{\n\tstruct seq_ump_client *client = pdata;\n\n\treturn seq_ump_client_close(client, STR_OUT);\n}\n\n \nstatic void fill_port_info(struct snd_seq_port_info *port,\n\t\t\t   struct seq_ump_client *client,\n\t\t\t   struct seq_ump_group *group)\n{\n\tunsigned int rawmidi_info = client->ump->core.info_flags;\n\n\tport->addr.client = client->seq_client;\n\tport->addr.port = ump_group_to_seq_port(group->group);\n\tport->capability = 0;\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_OUTPUT)\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_WRITE |\n\t\t\tSNDRV_SEQ_PORT_CAP_SYNC_WRITE |\n\t\t\tSNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_INPUT)\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_READ |\n\t\t\tSNDRV_SEQ_PORT_CAP_SYNC_READ |\n\t\t\tSNDRV_SEQ_PORT_CAP_SUBS_READ;\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_DUPLEX)\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\n\tif (group->dir_bits & (1 << STR_IN))\n\t\tport->direction |= SNDRV_SEQ_PORT_DIR_INPUT;\n\tif (group->dir_bits & (1 << STR_OUT))\n\t\tport->direction |= SNDRV_SEQ_PORT_DIR_OUTPUT;\n\tport->ump_group = group->group + 1;\n\tif (!group->active)\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_INACTIVE;\n\tport->type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_UMP |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\tSNDRV_SEQ_PORT_TYPE_PORT;\n\tport->midi_channels = 16;\n\tif (*group->name)\n\t\tsnprintf(port->name, sizeof(port->name), \"Group %d (%.53s)\",\n\t\t\t group->group + 1, group->name);\n\telse\n\t\tsprintf(port->name, \"Group %d\", group->group + 1);\n}\n\n \nstatic int seq_ump_group_init(struct seq_ump_client *client, int group_index)\n{\n\tstruct seq_ump_group *group = &client->groups[group_index];\n\tstruct snd_seq_port_info *port;\n\tstruct snd_seq_port_callback pcallbacks;\n\tint err;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tfill_port_info(port, client, group);\n\tport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\n\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\tpcallbacks.owner = THIS_MODULE;\n\tpcallbacks.private_data = client;\n\tpcallbacks.subscribe = seq_ump_subscribe;\n\tpcallbacks.unsubscribe = seq_ump_unsubscribe;\n\tpcallbacks.use = seq_ump_use;\n\tpcallbacks.unuse = seq_ump_unuse;\n\tpcallbacks.event_input = seq_ump_process_event;\n\tport->kernel = &pcallbacks;\n\terr = snd_seq_kernel_client_ctl(client->seq_client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\tport);\n error:\n\tkfree(port);\n\treturn err;\n}\n\n \nstatic void update_port_infos(struct seq_ump_client *client)\n{\n\tstruct snd_seq_port_info *old, *new;\n\tint i, err;\n\n\told = kzalloc(sizeof(*old), GFP_KERNEL);\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!old || !new)\n\t\tgoto error;\n\n\tfor (i = 0; i < SNDRV_UMP_MAX_GROUPS; i++) {\n\t\told->addr.client = client->seq_client;\n\t\told->addr.port = i;\n\t\terr = snd_seq_kernel_client_ctl(client->seq_client,\n\t\t\t\t\t\tSNDRV_SEQ_IOCTL_GET_PORT_INFO,\n\t\t\t\t\t\told);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tfill_port_info(new, client, &client->groups[i]);\n\t\tif (old->capability == new->capability &&\n\t\t    !strcmp(old->name, new->name))\n\t\t\tcontinue;\n\t\terr = snd_seq_kernel_client_ctl(client->seq_client,\n\t\t\t\t\t\tSNDRV_SEQ_IOCTL_SET_PORT_INFO,\n\t\t\t\t\t\tnew);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\t \n\t\tsnd_seq_system_client_ev_port_change(client->seq_client, i);\n\t}\n error:\n\tkfree(new);\n\tkfree(old);\n}\n\n \nstatic void update_group_attrs(struct seq_ump_client *client)\n{\n\tstruct snd_ump_block *fb;\n\tstruct seq_ump_group *group;\n\tint i;\n\n\tfor (i = 0; i < SNDRV_UMP_MAX_GROUPS; i++) {\n\t\tgroup = &client->groups[i];\n\t\t*group->name = 0;\n\t\tgroup->dir_bits = 0;\n\t\tgroup->active = 0;\n\t\tgroup->group = i;\n\t}\n\n\tlist_for_each_entry(fb, &client->ump->block_list, list) {\n\t\tif (fb->info.first_group + fb->info.num_groups > SNDRV_UMP_MAX_GROUPS)\n\t\t\tbreak;\n\t\tgroup = &client->groups[fb->info.first_group];\n\t\tfor (i = 0; i < fb->info.num_groups; i++, group++) {\n\t\t\tif (fb->info.active)\n\t\t\t\tgroup->active = 1;\n\t\t\tswitch (fb->info.direction) {\n\t\t\tcase SNDRV_UMP_DIR_INPUT:\n\t\t\t\tgroup->dir_bits |= (1 << STR_IN);\n\t\t\t\tbreak;\n\t\t\tcase SNDRV_UMP_DIR_OUTPUT:\n\t\t\t\tgroup->dir_bits |= (1 << STR_OUT);\n\t\t\t\tbreak;\n\t\t\tcase SNDRV_UMP_DIR_BIDIRECTION:\n\t\t\t\tgroup->dir_bits |= (1 << STR_OUT) | (1 << STR_IN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*fb->info.name)\n\t\t\t\tcontinue;\n\t\t\tif (!*group->name) {\n\t\t\t\t \n\t\t\t\tstrscpy(group->name, fb->info.name,\n\t\t\t\t\tsizeof(group->name));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstrlcat(group->name, \", \", sizeof(group->name));\n\t\t\t\tstrlcat(group->name, fb->info.name,\n\t\t\t\t\tsizeof(group->name));\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int create_ump_endpoint_port(struct seq_ump_client *client)\n{\n\tstruct snd_seq_port_info *port;\n\tstruct snd_seq_port_callback pcallbacks;\n\tunsigned int rawmidi_info = client->ump->core.info_flags;\n\tint err;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->addr.client = client->seq_client;\n\tport->addr.port = 0;  \n\tport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\n\tport->capability = SNDRV_SEQ_PORT_CAP_UMP_ENDPOINT;\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_INPUT) {\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_READ |\n\t\t\tSNDRV_SEQ_PORT_CAP_SYNC_READ |\n\t\t\tSNDRV_SEQ_PORT_CAP_SUBS_READ;\n\t\tport->direction |= SNDRV_SEQ_PORT_DIR_INPUT;\n\t}\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_OUTPUT) {\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_WRITE |\n\t\t\tSNDRV_SEQ_PORT_CAP_SYNC_WRITE |\n\t\t\tSNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\t\tport->direction |= SNDRV_SEQ_PORT_DIR_OUTPUT;\n\t}\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_DUPLEX)\n\t\tport->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\n\tport->ump_group = 0;  \n\tport->type = SNDRV_SEQ_PORT_TYPE_MIDI_UMP |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\tSNDRV_SEQ_PORT_TYPE_PORT;\n\tport->midi_channels = 16;\n\tstrcpy(port->name, \"MIDI 2.0\");\n\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\tpcallbacks.owner = THIS_MODULE;\n\tpcallbacks.private_data = client;\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_INPUT) {\n\t\tpcallbacks.subscribe = seq_ump_subscribe;\n\t\tpcallbacks.unsubscribe = seq_ump_unsubscribe;\n\t}\n\tif (rawmidi_info & SNDRV_RAWMIDI_INFO_OUTPUT) {\n\t\tpcallbacks.use = seq_ump_use;\n\t\tpcallbacks.unuse = seq_ump_unuse;\n\t\tpcallbacks.event_input = seq_ump_process_event;\n\t}\n\tport->kernel = &pcallbacks;\n\terr = snd_seq_kernel_client_ctl(client->seq_client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\tport);\n\tkfree(port);\n\treturn err;\n}\n\n \nstatic void seq_ump_client_free(struct seq_ump_client *client)\n{\n\tcancel_work_sync(&client->group_notify_work);\n\n\tif (client->seq_client >= 0)\n\t\tsnd_seq_delete_kernel_client(client->seq_client);\n\n\tclient->ump->seq_ops = NULL;\n\tclient->ump->seq_client = NULL;\n\n\tkfree(client);\n}\n\n \nstatic void setup_client_midi_version(struct seq_ump_client *client)\n{\n\tstruct snd_seq_client *cptr;\n\n\tcptr = snd_seq_kernel_client_get(client->seq_client);\n\tif (!cptr)\n\t\treturn;\n\tif (client->ump->info.protocol & SNDRV_UMP_EP_INFO_PROTO_MIDI2)\n\t\tcptr->midi_version = SNDRV_SEQ_CLIENT_UMP_MIDI_2_0;\n\telse\n\t\tcptr->midi_version = SNDRV_SEQ_CLIENT_UMP_MIDI_1_0;\n\tsnd_seq_kernel_client_put(cptr);\n}\n\n \nstatic void setup_client_group_filter(struct seq_ump_client *client)\n{\n\tstruct snd_seq_client *cptr;\n\tunsigned int filter;\n\tint p;\n\n\tcptr = snd_seq_kernel_client_get(client->seq_client);\n\tif (!cptr)\n\t\treturn;\n\tfilter = ~(1U << 0);  \n\tfor (p = 0; p < SNDRV_UMP_MAX_GROUPS; p++) {\n\t\tif (client->groups[p].active)\n\t\t\tfilter &= ~(1U << (p + 1));\n\t}\n\tcptr->group_filter = filter;\n\tsnd_seq_kernel_client_put(cptr);\n}\n\n \nstatic void handle_group_notify(struct work_struct *work)\n{\n\tstruct seq_ump_client *client =\n\t\tcontainer_of(work, struct seq_ump_client, group_notify_work);\n\n\tupdate_group_attrs(client);\n\tupdate_port_infos(client);\n\tsetup_client_group_filter(client);\n}\n\n \nstatic int seq_ump_notify_fb_change(struct snd_ump_endpoint *ump,\n\t\t\t\t    struct snd_ump_block *fb)\n{\n\tstruct seq_ump_client *client = ump->seq_client;\n\n\tif (!client)\n\t\treturn -ENODEV;\n\tschedule_work(&client->group_notify_work);\n\treturn 0;\n}\n\n \nstatic int seq_ump_switch_protocol(struct snd_ump_endpoint *ump)\n{\n\tif (!ump->seq_client)\n\t\treturn -ENODEV;\n\tsetup_client_midi_version(ump->seq_client);\n\treturn 0;\n}\n\nstatic const struct snd_seq_ump_ops seq_ump_ops = {\n\t.input_receive = seq_ump_input_receive,\n\t.notify_fb_change = seq_ump_notify_fb_change,\n\t.switch_protocol = seq_ump_switch_protocol,\n};\n\n \nstatic int snd_seq_ump_probe(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_ump_endpoint *ump = dev->private_data;\n\tstruct snd_card *card = dev->card;\n\tstruct seq_ump_client *client;\n\tstruct snd_ump_block *fb;\n\tstruct snd_seq_client *cptr;\n\tint p, err;\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&client->group_notify_work, handle_group_notify);\n\tclient->ump = ump;\n\n\tclient->seq_client =\n\t\tsnd_seq_create_kernel_client(card, ump->core.device,\n\t\t\t\t\t     ump->core.name);\n\tif (client->seq_client < 0) {\n\t\terr = client->seq_client;\n\t\tgoto error;\n\t}\n\n\tclient->ump_info[0] = &ump->info;\n\tlist_for_each_entry(fb, &ump->block_list, list)\n\t\tclient->ump_info[fb->info.block_id + 1] = &fb->info;\n\n\tsetup_client_midi_version(client);\n\tupdate_group_attrs(client);\n\n\tfor (p = 0; p < SNDRV_UMP_MAX_GROUPS; p++) {\n\t\terr = seq_ump_group_init(client, p);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tsetup_client_group_filter(client);\n\n\terr = create_ump_endpoint_port(client);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcptr = snd_seq_kernel_client_get(client->seq_client);\n\tif (!cptr) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tcptr->ump_info = client->ump_info;\n\tsnd_seq_kernel_client_put(cptr);\n\n\tump->seq_client = client;\n\tump->seq_ops = &seq_ump_ops;\n\treturn 0;\n\n error:\n\tseq_ump_client_free(client);\n\treturn err;\n}\n\n \nstatic int snd_seq_ump_remove(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_ump_endpoint *ump = dev->private_data;\n\n\tif (ump->seq_client)\n\t\tseq_ump_client_free(ump->seq_client);\n\treturn 0;\n}\n\nstatic struct snd_seq_driver seq_ump_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.probe = snd_seq_ump_probe,\n\t\t.remove = snd_seq_ump_remove,\n\t},\n\t.id = SNDRV_SEQ_DEV_ID_UMP,\n\t.argsize = 0,\n};\n\nmodule_snd_seq_driver(seq_ump_driver);\n\nMODULE_DESCRIPTION(\"ALSA sequencer client for UMP rawmidi\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}