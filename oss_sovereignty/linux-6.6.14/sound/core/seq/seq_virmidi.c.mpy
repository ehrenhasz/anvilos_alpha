{
  "module_name": "seq_virmidi.c",
  "hash_id": "e86852fa3cd184217adf6dd916ae276baa2189b035d3eedff7d5caf00404b495",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_virmidi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/rawmidi.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/minors.h>\n#include <sound/seq_kernel.h>\n#include <sound/seq_midi_event.h>\n#include <sound/seq_virmidi.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"Virtual Raw MIDI client on Sequencer\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic void snd_virmidi_init_event(struct snd_virmidi *vmidi,\n\t\t\t\t   struct snd_seq_event *ev)\n{\n\tmemset(ev, 0, sizeof(*ev));\n\tev->source.port = vmidi->port;\n\tswitch (vmidi->seq_mode) {\n\tcase SNDRV_VIRMIDI_SEQ_DISPATCH:\n\t\tev->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tbreak;\n\tcase SNDRV_VIRMIDI_SEQ_ATTACH:\n\t\t \n\t\tev->dest.client = vmidi->client;\n\t\tev->dest.port = vmidi->port;\n\t\tbreak;\n\t}\n\tev->type = SNDRV_SEQ_EVENT_NONE;\n}\n\n \nstatic int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,\n\t\t\t\t\t struct snd_seq_event *ev,\n\t\t\t\t\t bool atomic)\n{\n\tstruct snd_virmidi *vmidi;\n\tunsigned char msg[4];\n\tint len;\n\n\tif (atomic)\n\t\tread_lock(&rdev->filelist_lock);\n\telse\n\t\tdown_read(&rdev->filelist_sem);\n\tlist_for_each_entry(vmidi, &rdev->filelist, list) {\n\t\tif (!READ_ONCE(vmidi->trigger))\n\t\t\tcontinue;\n\t\tif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\n\t\t\tif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)\n\t\t\t\tcontinue;\n\t\t\tsnd_seq_dump_var_event(ev, (snd_seq_dump_func_t)snd_rawmidi_receive, vmidi->substream);\n\t\t\tsnd_midi_event_reset_decode(vmidi->parser);\n\t\t} else {\n\t\t\tlen = snd_midi_event_decode(vmidi->parser, msg, sizeof(msg), ev);\n\t\t\tif (len > 0)\n\t\t\t\tsnd_rawmidi_receive(vmidi->substream, msg, len);\n\t\t}\n\t}\n\tif (atomic)\n\t\tread_unlock(&rdev->filelist_lock);\n\telse\n\t\tup_read(&rdev->filelist_sem);\n\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,\n\t\t\t\t   void *private_data, int atomic, int hop)\n{\n\tstruct snd_virmidi_dev *rdev;\n\n\trdev = private_data;\n\tif (!(rdev->flags & SNDRV_VIRMIDI_USE))\n\t\treturn 0;  \n\treturn snd_virmidi_dev_receive_event(rdev, ev, atomic);\n}\n\n \nstatic void snd_virmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct snd_virmidi *vmidi = substream->runtime->private_data;\n\n\tWRITE_ONCE(vmidi->trigger, !!up);\n}\n\n \nstatic void snd_vmidi_output_work(struct work_struct *work)\n{\n\tstruct snd_virmidi *vmidi;\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned char input;\n\tint ret;\n\n\tvmidi = container_of(work, struct snd_virmidi, output_work);\n\tsubstream = vmidi->substream;\n\n\t \n\tif (vmidi->seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH &&\n\t    !(vmidi->rdev->flags & SNDRV_VIRMIDI_SUBSCRIBE)) {\n\t\tsnd_rawmidi_proceed(substream);\n\t\treturn;\n\t}\n\n\twhile (READ_ONCE(vmidi->trigger)) {\n\t\tif (snd_rawmidi_transmit(substream, &input, 1) != 1)\n\t\t\tbreak;\n\t\tif (!snd_midi_event_encode_byte(vmidi->parser, input,\n\t\t\t\t\t\t&vmidi->event))\n\t\t\tcontinue;\n\t\tif (vmidi->event.type != SNDRV_SEQ_EVENT_NONE) {\n\t\t\tret = snd_seq_kernel_client_dispatch(vmidi->client,\n\t\t\t\t\t\t\t     &vmidi->event,\n\t\t\t\t\t\t\t     false, 0);\n\t\t\tvmidi->event.type = SNDRV_SEQ_EVENT_NONE;\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tcond_resched();\n\t}\n}\n\n \nstatic void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct snd_virmidi *vmidi = substream->runtime->private_data;\n\n\tWRITE_ONCE(vmidi->trigger, !!up);\n\tif (up)\n\t\tqueue_work(system_highpri_wq, &vmidi->output_work);\n}\n\n \nstatic int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tstruct snd_virmidi *vmidi;\n\n\tvmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);\n\tif (vmidi == NULL)\n\t\treturn -ENOMEM;\n\tvmidi->substream = substream;\n\tif (snd_midi_event_new(0, &vmidi->parser) < 0) {\n\t\tkfree(vmidi);\n\t\treturn -ENOMEM;\n\t}\n\tvmidi->seq_mode = rdev->seq_mode;\n\tvmidi->client = rdev->client;\n\tvmidi->port = rdev->port;\t\n\truntime->private_data = vmidi;\n\tdown_write(&rdev->filelist_sem);\n\twrite_lock_irq(&rdev->filelist_lock);\n\tlist_add_tail(&vmidi->list, &rdev->filelist);\n\twrite_unlock_irq(&rdev->filelist_lock);\n\tup_write(&rdev->filelist_sem);\n\tvmidi->rdev = rdev;\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tstruct snd_virmidi *vmidi;\n\n\tvmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);\n\tif (vmidi == NULL)\n\t\treturn -ENOMEM;\n\tvmidi->substream = substream;\n\tif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &vmidi->parser) < 0) {\n\t\tkfree(vmidi);\n\t\treturn -ENOMEM;\n\t}\n\tvmidi->seq_mode = rdev->seq_mode;\n\tvmidi->client = rdev->client;\n\tvmidi->port = rdev->port;\n\tsnd_virmidi_init_event(vmidi, &vmidi->event);\n\tvmidi->rdev = rdev;\n\tINIT_WORK(&vmidi->output_work, snd_vmidi_output_work);\n\truntime->private_data = vmidi;\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\n\tstruct snd_virmidi *vmidi = substream->runtime->private_data;\n\n\tdown_write(&rdev->filelist_sem);\n\twrite_lock_irq(&rdev->filelist_lock);\n\tlist_del(&vmidi->list);\n\twrite_unlock_irq(&rdev->filelist_lock);\n\tup_write(&rdev->filelist_sem);\n\tsnd_midi_event_free(vmidi->parser);\n\tsubstream->runtime->private_data = NULL;\n\tkfree(vmidi);\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_virmidi *vmidi = substream->runtime->private_data;\n\n\tWRITE_ONCE(vmidi->trigger, false);  \n\tcancel_work_sync(&vmidi->output_work);\n\tsnd_midi_event_free(vmidi->parser);\n\tsubstream->runtime->private_data = NULL;\n\tkfree(vmidi);\n\treturn 0;\n}\n\n \nstatic void snd_virmidi_output_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_virmidi *vmidi = substream->runtime->private_data;\n\n\tflush_work(&vmidi->output_work);\n}\n\n \nstatic int snd_virmidi_subscribe(void *private_data,\n\t\t\t\t struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_virmidi_dev *rdev;\n\n\trdev = private_data;\n\tif (!try_module_get(rdev->card->module))\n\t\treturn -EFAULT;\n\trdev->flags |= SNDRV_VIRMIDI_SUBSCRIBE;\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_unsubscribe(void *private_data,\n\t\t\t\t   struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_virmidi_dev *rdev;\n\n\trdev = private_data;\n\trdev->flags &= ~SNDRV_VIRMIDI_SUBSCRIBE;\n\tmodule_put(rdev->card->module);\n\treturn 0;\n}\n\n\n \nstatic int snd_virmidi_use(void *private_data,\n\t\t\t   struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_virmidi_dev *rdev;\n\n\trdev = private_data;\n\tif (!try_module_get(rdev->card->module))\n\t\treturn -EFAULT;\n\trdev->flags |= SNDRV_VIRMIDI_USE;\n\treturn 0;\n}\n\n \nstatic int snd_virmidi_unuse(void *private_data,\n\t\t\t     struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_virmidi_dev *rdev;\n\n\trdev = private_data;\n\trdev->flags &= ~SNDRV_VIRMIDI_USE;\n\tmodule_put(rdev->card->module);\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_rawmidi_ops snd_virmidi_input_ops = {\n\t.open = snd_virmidi_input_open,\n\t.close = snd_virmidi_input_close,\n\t.trigger = snd_virmidi_input_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_virmidi_output_ops = {\n\t.open = snd_virmidi_output_open,\n\t.close = snd_virmidi_output_close,\n\t.trigger = snd_virmidi_output_trigger,\n\t.drain = snd_virmidi_output_drain,\n};\n\n \nstatic int snd_virmidi_dev_attach_seq(struct snd_virmidi_dev *rdev)\n{\n\tint client;\n\tstruct snd_seq_port_callback pcallbacks;\n\tstruct snd_seq_port_info *pinfo;\n\tint err;\n\n\tif (rdev->client >= 0)\n\t\treturn 0;\n\n\tpinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);\n\tif (!pinfo) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\tclient = snd_seq_create_kernel_client(rdev->card, rdev->device,\n\t\t\t\t\t      \"%s %d-%d\", rdev->rmidi->name,\n\t\t\t\t\t      rdev->card->number,\n\t\t\t\t\t      rdev->device);\n\tif (client < 0) {\n\t\terr = client;\n\t\tgoto __error;\n\t}\n\trdev->client = client;\n\n\t \n\tpinfo->addr.client = client;\n\tsprintf(pinfo->name, \"VirMIDI %d-%d\", rdev->card->number, rdev->device);\n\t \n\tpinfo->capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SYNC_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\tpinfo->capability |= SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SYNC_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\n\tpinfo->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\n\tpinfo->direction = SNDRV_SEQ_PORT_DIR_BIDIRECTION;\n\tpinfo->type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\n\t\t| SNDRV_SEQ_PORT_TYPE_SOFTWARE\n\t\t| SNDRV_SEQ_PORT_TYPE_PORT;\n\tpinfo->midi_channels = 16;\n\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\tpcallbacks.owner = THIS_MODULE;\n\tpcallbacks.private_data = rdev;\n\tpcallbacks.subscribe = snd_virmidi_subscribe;\n\tpcallbacks.unsubscribe = snd_virmidi_unsubscribe;\n\tpcallbacks.use = snd_virmidi_use;\n\tpcallbacks.unuse = snd_virmidi_unuse;\n\tpcallbacks.event_input = snd_virmidi_event_input;\n\tpinfo->kernel = &pcallbacks;\n\terr = snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_CREATE_PORT, pinfo);\n\tif (err < 0) {\n\t\tsnd_seq_delete_kernel_client(client);\n\t\trdev->client = -1;\n\t\tgoto __error;\n\t}\n\n\trdev->port = pinfo->addr.port;\n\terr = 0;  \n\n __error:\n\tkfree(pinfo);\n\treturn err;\n}\n\n\n \nstatic void snd_virmidi_dev_detach_seq(struct snd_virmidi_dev *rdev)\n{\n\tif (rdev->client >= 0) {\n\t\tsnd_seq_delete_kernel_client(rdev->client);\n\t\trdev->client = -1;\n\t}\n}\n\n \nstatic int snd_virmidi_dev_register(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_virmidi_dev *rdev = rmidi->private_data;\n\tint err;\n\n\tswitch (rdev->seq_mode) {\n\tcase SNDRV_VIRMIDI_SEQ_DISPATCH:\n\t\terr = snd_virmidi_dev_attach_seq(rdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SNDRV_VIRMIDI_SEQ_ATTACH:\n\t\tif (rdev->client == 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ALSA: seq_virmidi: seq_mode is not set: %d\\n\", rdev->seq_mode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_virmidi_dev_unregister(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_virmidi_dev *rdev = rmidi->private_data;\n\n\tif (rdev->seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH)\n\t\tsnd_virmidi_dev_detach_seq(rdev);\n\treturn 0;\n}\n\n \nstatic const struct snd_rawmidi_global_ops snd_virmidi_global_ops = {\n\t.dev_register = snd_virmidi_dev_register,\n\t.dev_unregister = snd_virmidi_dev_unregister,\n};\n\n \nstatic void snd_virmidi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_virmidi_dev *rdev = rmidi->private_data;\n\tkfree(rdev);\n}\n\n \n \nint snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmidi)\n{\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_virmidi_dev *rdev;\n\tint err;\n\t\n\t*rrmidi = NULL;\n\terr = snd_rawmidi_new(card, \"VirMidi\", device,\n\t\t\t      16,\t \n\t\t\t      16,\t \n\t\t\t      &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, rmidi->id);\n\trdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\n\tif (rdev == NULL) {\n\t\tsnd_device_free(card, rmidi);\n\t\treturn -ENOMEM;\n\t}\n\trdev->card = card;\n\trdev->rmidi = rmidi;\n\trdev->device = device;\n\trdev->client = -1;\n\tinit_rwsem(&rdev->filelist_sem);\n\trwlock_init(&rdev->filelist_lock);\n\tINIT_LIST_HEAD(&rdev->filelist);\n\trdev->seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;\n\trmidi->private_data = rdev;\n\trmidi->private_free = snd_virmidi_free;\n\trmidi->ops = &snd_virmidi_global_ops;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_virmidi_input_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_virmidi_output_ops);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\t*rrmidi = rmidi;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_virmidi_new);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}