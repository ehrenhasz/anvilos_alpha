{
  "module_name": "seq_clientmgr.h",
  "hash_id": "b0536b41c2745ca288942eb65a6d93b9cecd9c52608e4f7d34a510e17cf72482",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_clientmgr.h",
  "human_readable_source": " \n \n#ifndef __SND_SEQ_CLIENTMGR_H\n#define __SND_SEQ_CLIENTMGR_H\n\n#include <sound/seq_kernel.h>\n#include <linux/bitops.h>\n#include \"seq_fifo.h\"\n#include \"seq_ports.h\"\n#include \"seq_lock.h\"\n\n \n\nstruct snd_seq_user_client {\n\tstruct file *file;\t \n\t \n\tstruct pid *owner;\n\t\n\t \n\tstruct snd_seq_fifo *fifo;\t \n\tint fifo_pool_size;\n};\n\nstruct snd_seq_kernel_client {\n\t \n\tstruct snd_card *card;\n};\n\n\nstruct snd_seq_client {\n\tsnd_seq_client_type_t type;\n\tunsigned int accept_input: 1,\n\t\taccept_output: 1;\n\tunsigned int midi_version;\n\tunsigned int user_pversion;\n\tchar name[64];\t\t \n\tint number;\t\t \n\tunsigned int filter;\t \n\tDECLARE_BITMAP(event_filter, 256);\n\tunsigned short group_filter;\n\tsnd_use_lock_t use_lock;\n\tint event_lost;\n\t \n\tint num_ports;\t\t \n\tstruct list_head ports_list_head;\n\trwlock_t ports_lock;\n\tstruct mutex ports_mutex;\n\tstruct mutex ioctl_mutex;\n\tint convert32;\t\t \n\tint ump_endpoint_port;\n\n\t \n\tstruct snd_seq_pool *pool;\t\t \n\n\tunion {\n\t\tstruct snd_seq_user_client user;\n\t\tstruct snd_seq_kernel_client kernel;\n\t} data;\n\n\t \n\tvoid **ump_info;\n};\n\n \nstruct snd_seq_usage {\n\tint cur;\n\tint peak;\n};\n\n\nint client_init_data(void);\nint snd_sequencer_device_init(void);\nvoid snd_sequencer_device_done(void);\n\n \nstruct snd_seq_client *snd_seq_client_use_ptr(int clientid);\n\n \n#define snd_seq_client_unlock(client) snd_use_lock_free(&(client)->use_lock)\n\n \nint snd_seq_dispatch_event(struct snd_seq_event_cell *cell, int atomic, int hop);\n\nint snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait);\nint snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info, int evtype);\n\nint __snd_seq_deliver_single_event(struct snd_seq_client *dest,\n\t\t\t\t   struct snd_seq_client_port *dest_port,\n\t\t\t\t   struct snd_seq_event *event,\n\t\t\t\t   int atomic, int hop);\n\n \nbool snd_seq_client_ioctl_lock(int clientid);\nvoid snd_seq_client_ioctl_unlock(int clientid);\n\nextern int seq_client_load[15];\n\n \nstruct snd_seq_client *snd_seq_kernel_client_get(int client);\nvoid snd_seq_kernel_client_put(struct snd_seq_client *cptr);\n\nstatic inline bool snd_seq_client_is_ump(struct snd_seq_client *c)\n{\n\treturn c->midi_version != SNDRV_SEQ_CLIENT_LEGACY_MIDI;\n}\n\nstatic inline bool snd_seq_client_is_midi2(struct snd_seq_client *c)\n{\n\treturn c->midi_version == SNDRV_SEQ_CLIENT_UMP_MIDI_2_0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}