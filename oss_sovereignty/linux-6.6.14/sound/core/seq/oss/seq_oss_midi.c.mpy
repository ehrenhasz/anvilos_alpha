{
  "module_name": "seq_oss_midi.c",
  "hash_id": "ac1cda9a470dc6e14a7a69c5ec689b2bafb7ac00946967ef03adb25676987c47",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_midi.c",
  "human_readable_source": "\n \n\n#include <sound/asoundef.h>\n#include \"seq_oss_midi.h\"\n#include \"seq_oss_readq.h\"\n#include \"seq_oss_timer.h\"\n#include \"seq_oss_event.h\"\n#include <sound/seq_midi_event.h>\n#include \"../seq_lock.h\"\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n\n\n \n#define SNDRV_SEQ_OSS_MAX_MIDI_NAME\t30\n\n \nstruct seq_oss_midi {\n\tint seq_device;\t\t \n\tint client;\t\t \n\tint port;\t\t \n\tunsigned int flags;\t \n\tint opened;\t\t \n\tunsigned char name[SNDRV_SEQ_OSS_MAX_MIDI_NAME];\n\tstruct snd_midi_event *coder;\t \n\tstruct seq_oss_devinfo *devinfo;\t \n\tsnd_use_lock_t use_lock;\n\tstruct mutex open_mutex;\n};\n\n\n \nstatic int max_midi_devs;\nstatic struct seq_oss_midi *midi_devs[SNDRV_SEQ_OSS_MAX_MIDI_DEVS];\n\nstatic DEFINE_SPINLOCK(register_lock);\n\n \nstatic struct seq_oss_midi *get_mdev(int dev);\nstatic struct seq_oss_midi *get_mididev(struct seq_oss_devinfo *dp, int dev);\nstatic int send_synth_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, int dev);\nstatic int send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq_oss_midi *mdev);\n\n \nint\nsnd_seq_oss_midi_lookup_ports(int client)\n{\n\tstruct snd_seq_client_info *clinfo;\n\tstruct snd_seq_port_info *pinfo;\n\n\tclinfo = kzalloc(sizeof(*clinfo), GFP_KERNEL);\n\tpinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);\n\tif (! clinfo || ! pinfo) {\n\t\tkfree(clinfo);\n\t\tkfree(pinfo);\n\t\treturn -ENOMEM;\n\t}\n\tclinfo->client = -1;\n\twhile (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, clinfo) == 0) {\n\t\tif (clinfo->client == client)\n\t\t\tcontinue;  \n\t\tpinfo->addr.client = clinfo->client;\n\t\tpinfo->addr.port = -1;\n\t\twhile (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, pinfo) == 0)\n\t\t\tsnd_seq_oss_midi_check_new_port(pinfo);\n\t}\n\tkfree(clinfo);\n\tkfree(pinfo);\n\treturn 0;\n}\n\n\n \nstatic struct seq_oss_midi *\nget_mdev(int dev)\n{\n\tstruct seq_oss_midi *mdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\tmdev = midi_devs[dev];\n\tif (mdev)\n\t\tsnd_use_lock_use(&mdev->use_lock);\n\tspin_unlock_irqrestore(&register_lock, flags);\n\treturn mdev;\n}\n\n \nstatic struct seq_oss_midi *\nfind_slot(int client, int port)\n{\n\tint i;\n\tstruct seq_oss_midi *mdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (i = 0; i < max_midi_devs; i++) {\n\t\tmdev = midi_devs[i];\n\t\tif (mdev && mdev->client == client && mdev->port == port) {\n\t\t\t \n\t\t\tsnd_use_lock_use(&mdev->use_lock);\n\t\t\tspin_unlock_irqrestore(&register_lock, flags);\n\t\t\treturn mdev;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&register_lock, flags);\n\treturn NULL;\n}\n\n\n#define PERM_WRITE (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_SUBS_WRITE)\n#define PERM_READ (SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ)\n \nint\nsnd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)\n{\n\tint i;\n\tstruct seq_oss_midi *mdev;\n\tunsigned long flags;\n\n\t \n\tif (! (pinfo->type & SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC))\n\t\treturn 0;\n\t \n\tif ((pinfo->capability & PERM_WRITE) != PERM_WRITE &&\n\t    (pinfo->capability & PERM_READ) != PERM_READ)\n\t\treturn 0;\n\n\t \n\tmdev = find_slot(pinfo->addr.client, pinfo->addr.port);\n\tif (mdev) {\n\t\t \n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\t \n\tmdev->client = pinfo->addr.client;\n\tmdev->port = pinfo->addr.port;\n\tmdev->flags = pinfo->capability;\n\tmdev->opened = 0;\n\tsnd_use_lock_init(&mdev->use_lock);\n\tmutex_init(&mdev->open_mutex);\n\n\t \n\tstrscpy(mdev->name, pinfo->name, sizeof(mdev->name));\n\n\t \n\tif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &mdev->coder) < 0) {\n\t\tpr_err(\"ALSA: seq_oss: can't malloc midi coder\\n\");\n\t\tkfree(mdev);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tsnd_midi_event_no_status(mdev->coder, 1);\n\n\t \n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (i = 0; i < max_midi_devs; i++) {\n\t\tif (midi_devs[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= max_midi_devs) {\n\t\tif (max_midi_devs >= SNDRV_SEQ_OSS_MAX_MIDI_DEVS) {\n\t\t\tspin_unlock_irqrestore(&register_lock, flags);\n\t\t\tsnd_midi_event_free(mdev->coder);\n\t\t\tkfree(mdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmax_midi_devs++;\n\t}\n\tmdev->seq_device = i;\n\tmidi_devs[mdev->seq_device] = mdev;\n\tspin_unlock_irqrestore(&register_lock, flags);\n\n\treturn 0;\n}\n\n \nint\nsnd_seq_oss_midi_check_exit_port(int client, int port)\n{\n\tstruct seq_oss_midi *mdev;\n\tunsigned long flags;\n\tint index;\n\n\tmdev = find_slot(client, port);\n\tif (mdev) {\n\t\tspin_lock_irqsave(&register_lock, flags);\n\t\tmidi_devs[mdev->seq_device] = NULL;\n\t\tspin_unlock_irqrestore(&register_lock, flags);\n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t\tsnd_use_lock_sync(&mdev->use_lock);\n\t\tsnd_midi_event_free(mdev->coder);\n\t\tkfree(mdev);\n\t}\n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (index = max_midi_devs - 1; index >= 0; index--) {\n\t\tif (midi_devs[index])\n\t\t\tbreak;\n\t}\n\tmax_midi_devs = index + 1;\n\tspin_unlock_irqrestore(&register_lock, flags);\n\treturn 0;\n}\n\n\n \nvoid\nsnd_seq_oss_midi_clear_all(void)\n{\n\tint i;\n\tstruct seq_oss_midi *mdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (i = 0; i < max_midi_devs; i++) {\n\t\tmdev = midi_devs[i];\n\t\tif (mdev) {\n\t\t\tsnd_midi_event_free(mdev->coder);\n\t\t\tkfree(mdev);\n\t\t\tmidi_devs[i] = NULL;\n\t\t}\n\t}\n\tmax_midi_devs = 0;\n\tspin_unlock_irqrestore(&register_lock, flags);\n}\n\n\n \nvoid\nsnd_seq_oss_midi_setup(struct seq_oss_devinfo *dp)\n{\n\tspin_lock_irq(&register_lock);\n\tdp->max_mididev = max_midi_devs;\n\tspin_unlock_irq(&register_lock);\n}\n\n \nvoid\nsnd_seq_oss_midi_cleanup(struct seq_oss_devinfo *dp)\n{\n\tint i;\n\tfor (i = 0; i < dp->max_mididev; i++)\n\t\tsnd_seq_oss_midi_close(dp, i);\n\tdp->max_mididev = 0;\n}\n\n\n \nvoid\nsnd_seq_oss_midi_open_all(struct seq_oss_devinfo *dp, int file_mode)\n{\n\tint i;\n\tfor (i = 0; i < dp->max_mididev; i++)\n\t\tsnd_seq_oss_midi_open(dp, i, file_mode);\n}\n\n\n \nstatic struct seq_oss_midi *\nget_mididev(struct seq_oss_devinfo *dp, int dev)\n{\n\tif (dev < 0 || dev >= dp->max_mididev)\n\t\treturn NULL;\n\tdev = array_index_nospec(dev, dp->max_mididev);\n\treturn get_mdev(dev);\n}\n\n\n \nint\nsnd_seq_oss_midi_open(struct seq_oss_devinfo *dp, int dev, int fmode)\n{\n\tint perm;\n\tstruct seq_oss_midi *mdev;\n\tstruct snd_seq_port_subscribe subs;\n\tint err;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&mdev->open_mutex);\n\t \n\tif (mdev->opened && mdev->devinfo != dp) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tperm = 0;\n\tif (is_write_mode(fmode))\n\t\tperm |= PERM_WRITE;\n\tif (is_read_mode(fmode))\n\t\tperm |= PERM_READ;\n\tperm &= mdev->flags;\n\tif (perm == 0) {\n\t\terr = -ENXIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif ((mdev->opened & perm) == perm) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\tperm &= ~mdev->opened;\n\n\tmemset(&subs, 0, sizeof(subs));\n\n\tif (perm & PERM_WRITE) {\n\t\tsubs.sender = dp->addr;\n\t\tsubs.dest.client = mdev->client;\n\t\tsubs.dest.port = mdev->port;\n\t\tif (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)\n\t\t\tmdev->opened |= PERM_WRITE;\n\t}\n\tif (perm & PERM_READ) {\n\t\tsubs.sender.client = mdev->client;\n\t\tsubs.sender.port = mdev->port;\n\t\tsubs.dest = dp->addr;\n\t\tsubs.flags = SNDRV_SEQ_PORT_SUBS_TIMESTAMP;\n\t\tsubs.queue = dp->queue;\t\t \n\t\tif (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)\n\t\t\tmdev->opened |= PERM_READ;\n\t}\n\n\tif (! mdev->opened) {\n\t\terr = -ENXIO;\n\t\tgoto unlock;\n\t}\n\n\tmdev->devinfo = dp;\n\terr = 0;\n\n unlock:\n\tmutex_unlock(&mdev->open_mutex);\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn err;\n}\n\n \nint\nsnd_seq_oss_midi_close(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_midi *mdev;\n\tstruct snd_seq_port_subscribe subs;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\tmutex_lock(&mdev->open_mutex);\n\tif (!mdev->opened || mdev->devinfo != dp)\n\t\tgoto unlock;\n\n\tmemset(&subs, 0, sizeof(subs));\n\tif (mdev->opened & PERM_WRITE) {\n\t\tsubs.sender = dp->addr;\n\t\tsubs.dest.client = mdev->client;\n\t\tsubs.dest.port = mdev->port;\n\t\tsnd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);\n\t}\n\tif (mdev->opened & PERM_READ) {\n\t\tsubs.sender.client = mdev->client;\n\t\tsubs.sender.port = mdev->port;\n\t\tsubs.dest = dp->addr;\n\t\tsnd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);\n\t}\n\n\tmdev->opened = 0;\n\tmdev->devinfo = NULL;\n\n unlock:\n\tmutex_unlock(&mdev->open_mutex);\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn 0;\n}\n\n \nint\nsnd_seq_oss_midi_filemode(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_midi *mdev;\n\tint mode;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\tmode = 0;\n\tif (mdev->opened & PERM_WRITE)\n\t\tmode |= SNDRV_SEQ_OSS_FILE_WRITE;\n\tif (mdev->opened & PERM_READ)\n\t\tmode |= SNDRV_SEQ_OSS_FILE_READ;\n\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn mode;\n}\n\n \nvoid\nsnd_seq_oss_midi_reset(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_midi *mdev;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn;\n\tif (! mdev->opened) {\n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t\treturn;\n\t}\n\n\tif (mdev->opened & PERM_WRITE) {\n\t\tstruct snd_seq_event ev;\n\t\tint c;\n\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.dest.client = mdev->client;\n\t\tev.dest.port = mdev->port;\n\t\tev.queue = dp->queue;\n\t\tev.source.port = dp->port;\n\t\tif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH) {\n\t\t\tev.type = SNDRV_SEQ_EVENT_SENSING;\n\t\t\tsnd_seq_oss_dispatch(dp, &ev, 0, 0);\n\t\t}\n\t\tfor (c = 0; c < 16; c++) {\n\t\t\tev.type = SNDRV_SEQ_EVENT_CONTROLLER;\n\t\t\tev.data.control.channel = c;\n\t\t\tev.data.control.param = MIDI_CTL_ALL_NOTES_OFF;\n\t\t\tsnd_seq_oss_dispatch(dp, &ev, 0, 0);\n\t\t\tif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\n\t\t\t\tev.data.control.param =\n\t\t\t\t\tMIDI_CTL_RESET_CONTROLLERS;\n\t\t\t\tsnd_seq_oss_dispatch(dp, &ev, 0, 0);\n\t\t\t\tev.type = SNDRV_SEQ_EVENT_PITCHBEND;\n\t\t\t\tev.data.control.value = 0;\n\t\t\t\tsnd_seq_oss_dispatch(dp, &ev, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tsnd_use_lock_free(&mdev->use_lock);\n}\n\n\n \nvoid\nsnd_seq_oss_midi_get_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_addr *addr)\n{\n\tstruct seq_oss_midi *mdev;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn;\n\taddr->client = mdev->client;\n\taddr->port = mdev->port;\n\tsnd_use_lock_free(&mdev->use_lock);\n}\n\n\n \nint\nsnd_seq_oss_midi_input(struct snd_seq_event *ev, int direct, void *private_data)\n{\n\tstruct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private_data;\n\tstruct seq_oss_midi *mdev;\n\tint rc;\n\n\tif (dp->readq == NULL)\n\t\treturn 0;\n\tmdev = find_slot(ev->source.client, ev->source.port);\n\tif (!mdev)\n\t\treturn 0;\n\tif (! (mdev->opened & PERM_READ)) {\n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t\treturn 0;\n\t}\n\n\tif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\trc = send_synth_event(dp, ev, mdev->seq_device);\n\telse\n\t\trc = send_midi_event(dp, ev, mdev);\n\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn rc;\n}\n\n \nstatic int\nsend_synth_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, int dev)\n{\n\tunion evrec ossev;\n\n\tmemset(&ossev, 0, sizeof(ossev));\n\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_NOTEON:\n\t\tossev.v.cmd = MIDI_NOTEON; break;\n\tcase SNDRV_SEQ_EVENT_NOTEOFF:\n\t\tossev.v.cmd = MIDI_NOTEOFF; break;\n\tcase SNDRV_SEQ_EVENT_KEYPRESS:\n\t\tossev.v.cmd = MIDI_KEY_PRESSURE; break;\n\tcase SNDRV_SEQ_EVENT_CONTROLLER:\n\t\tossev.l.cmd = MIDI_CTL_CHANGE; break;\n\tcase SNDRV_SEQ_EVENT_PGMCHANGE:\n\t\tossev.l.cmd = MIDI_PGM_CHANGE; break;\n\tcase SNDRV_SEQ_EVENT_CHANPRESS:\n\t\tossev.l.cmd = MIDI_CHN_PRESSURE; break;\n\tcase SNDRV_SEQ_EVENT_PITCHBEND:\n\t\tossev.l.cmd = MIDI_PITCH_BEND; break;\n\tdefault:\n\t\treturn 0;  \n\t}\n\n\tossev.v.dev = dev;\n\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_NOTEON:\n\tcase SNDRV_SEQ_EVENT_NOTEOFF:\n\tcase SNDRV_SEQ_EVENT_KEYPRESS:\n\t\tossev.v.code = EV_CHN_VOICE;\n\t\tossev.v.note = ev->data.note.note;\n\t\tossev.v.parm = ev->data.note.velocity;\n\t\tossev.v.chn = ev->data.note.channel;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_CONTROLLER:\n\tcase SNDRV_SEQ_EVENT_PGMCHANGE:\n\tcase SNDRV_SEQ_EVENT_CHANPRESS:\n\t\tossev.l.code = EV_CHN_COMMON;\n\t\tossev.l.p1 = ev->data.control.param;\n\t\tossev.l.val = ev->data.control.value;\n\t\tossev.l.chn = ev->data.control.channel;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_PITCHBEND:\n\t\tossev.l.code = EV_CHN_COMMON;\n\t\tossev.l.val = ev->data.control.value + 8192;\n\t\tossev.l.chn = ev->data.control.channel;\n\t\tbreak;\n\t}\n\t\n\tsnd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);\n\tsnd_seq_oss_readq_put_event(dp->readq, &ossev);\n\n\treturn 0;\n}\n\n \nstatic int\nsend_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq_oss_midi *mdev)\n{\n\tchar msg[32];\n\tint len;\n\t\n\tsnd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);\n\tif (!dp->timer->running)\n\t\tlen = snd_seq_oss_timer_start(dp->timer);\n\tif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\n\t\tsnd_seq_oss_readq_sysex(dp->readq, mdev->seq_device, ev);\n\t\tsnd_midi_event_reset_decode(mdev->coder);\n\t} else {\n\t\tlen = snd_midi_event_decode(mdev->coder, msg, sizeof(msg), ev);\n\t\tif (len > 0)\n\t\t\tsnd_seq_oss_readq_puts(dp->readq, mdev->seq_device, msg, len);\n\t}\n\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_midi_putc(struct seq_oss_devinfo *dp, int dev, unsigned char c, struct snd_seq_event *ev)\n{\n\tstruct seq_oss_midi *mdev;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\tif (snd_midi_event_encode_byte(mdev->coder, c, ev)) {\n\t\tsnd_seq_oss_fill_addr(dp, ev, mdev->client, mdev->port);\n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t\treturn 0;\n\t}\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn -EINVAL;\n}\n\n \nint\nsnd_seq_oss_midi_make_info(struct seq_oss_devinfo *dp, int dev, struct midi_info *inf)\n{\n\tstruct seq_oss_midi *mdev;\n\n\tmdev = get_mididev(dp, dev);\n\tif (!mdev)\n\t\treturn -ENXIO;\n\tinf->device = dev;\n\tinf->dev_type = 0;  \n\tinf->capabilities = 0;  \n\tstrscpy(inf->name, mdev->name, sizeof(inf->name));\n\tsnd_use_lock_free(&mdev->use_lock);\n\treturn 0;\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\n \nstatic char *\ncapmode_str(int val)\n{\n\tval &= PERM_READ|PERM_WRITE;\n\tif (val == (PERM_READ|PERM_WRITE))\n\t\treturn \"read/write\";\n\telse if (val == PERM_READ)\n\t\treturn \"read\";\n\telse if (val == PERM_WRITE)\n\t\treturn \"write\";\n\telse\n\t\treturn \"none\";\n}\n\nvoid\nsnd_seq_oss_midi_info_read(struct snd_info_buffer *buf)\n{\n\tint i;\n\tstruct seq_oss_midi *mdev;\n\n\tsnd_iprintf(buf, \"\\nNumber of MIDI devices: %d\\n\", max_midi_devs);\n\tfor (i = 0; i < max_midi_devs; i++) {\n\t\tsnd_iprintf(buf, \"\\nmidi %d: \", i);\n\t\tmdev = get_mdev(i);\n\t\tif (mdev == NULL) {\n\t\t\tsnd_iprintf(buf, \"*empty*\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tsnd_iprintf(buf, \"[%s] ALSA port %d:%d\\n\", mdev->name,\n\t\t\t    mdev->client, mdev->port);\n\t\tsnd_iprintf(buf, \"  capability %s / opened %s\\n\",\n\t\t\t    capmode_str(mdev->flags),\n\t\t\t    capmode_str(mdev->opened));\n\t\tsnd_use_lock_free(&mdev->use_lock);\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}