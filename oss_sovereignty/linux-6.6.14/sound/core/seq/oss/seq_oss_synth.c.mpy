{
  "module_name": "seq_oss_synth.c",
  "hash_id": "c526ebebbe013c00ca8e052bfcb925b39751a4b25980ab0daeb948eb914731c4",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_synth.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_synth.h\"\n#include \"seq_oss_midi.h\"\n#include \"../seq_lock.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n\n \n#define SNDRV_SEQ_OSS_MAX_SYNTH_NAME\t30\n#define MAX_SYSEX_BUFLEN\t\t128\n\n\n \n\n \nstruct seq_oss_synth_sysex {\n\tint len;\n\tint skip;\n\tunsigned char buf[MAX_SYSEX_BUFLEN];\n};\n\n \nstruct seq_oss_synth {\n\tint seq_device;\n\n\t \n\tint synth_type;\n\tint synth_subtype;\n\tint nr_voices;\n\n\tchar name[SNDRV_SEQ_OSS_MAX_SYNTH_NAME];\n\tstruct snd_seq_oss_callback oper;\n\n\tint opened;\n\n\tvoid *private_data;\n\tsnd_use_lock_t use_lock;\n};\n\n\n \nstatic int max_synth_devs;\nstatic struct seq_oss_synth *synth_devs[SNDRV_SEQ_OSS_MAX_SYNTH_DEVS];\nstatic struct seq_oss_synth midi_synth_dev = {\n\t.seq_device = -1,\n\t.synth_type = SYNTH_TYPE_MIDI,\n\t.synth_subtype = 0,\n\t.nr_voices = 16,\n\t.name = \"MIDI\",\n};\n\nstatic DEFINE_SPINLOCK(register_lock);\n\n \nstatic struct seq_oss_synth *get_synthdev(struct seq_oss_devinfo *dp, int dev);\nstatic void reset_channels(struct seq_oss_synthinfo *info);\n\n \nvoid __init\nsnd_seq_oss_synth_init(void)\n{\n\tsnd_use_lock_init(&midi_synth_dev.use_lock);\n}\n\n \nint\nsnd_seq_oss_synth_probe(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tint i;\n\tstruct seq_oss_synth *rec;\n\tstruct snd_seq_oss_reg *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\tunsigned long flags;\n\n\trec = kzalloc(sizeof(*rec), GFP_KERNEL);\n\tif (!rec)\n\t\treturn -ENOMEM;\n\trec->seq_device = -1;\n\trec->synth_type = reg->type;\n\trec->synth_subtype = reg->subtype;\n\trec->nr_voices = reg->nvoices;\n\trec->oper = reg->oper;\n\trec->private_data = reg->private_data;\n\trec->opened = 0;\n\tsnd_use_lock_init(&rec->use_lock);\n\n\t \n\tstrscpy(rec->name, dev->name, sizeof(rec->name));\n\n\t \n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (i = 0; i < max_synth_devs; i++) {\n\t\tif (synth_devs[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= max_synth_devs) {\n\t\tif (max_synth_devs >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS) {\n\t\t\tspin_unlock_irqrestore(&register_lock, flags);\n\t\t\tpr_err(\"ALSA: seq_oss: no more synth slot\\n\");\n\t\t\tkfree(rec);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmax_synth_devs++;\n\t}\n\trec->seq_device = i;\n\tsynth_devs[i] = rec;\n\tspin_unlock_irqrestore(&register_lock, flags);\n\tdev->driver_data = rec;\n#ifdef SNDRV_OSS_INFO_DEV_SYNTH\n\tif (i < SNDRV_CARDS)\n\t\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_SYNTH, i, rec->name);\n#endif\n\treturn 0;\n}\n\n\nint\nsnd_seq_oss_synth_remove(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tint index;\n\tstruct seq_oss_synth *rec = dev->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\tfor (index = 0; index < max_synth_devs; index++) {\n\t\tif (synth_devs[index] == rec)\n\t\t\tbreak;\n\t}\n\tif (index >= max_synth_devs) {\n\t\tspin_unlock_irqrestore(&register_lock, flags);\n\t\tpr_err(\"ALSA: seq_oss: can't unregister synth\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsynth_devs[index] = NULL;\n\tif (index == max_synth_devs - 1) {\n\t\tfor (index--; index >= 0; index--) {\n\t\t\tif (synth_devs[index])\n\t\t\t\tbreak;\n\t\t}\n\t\tmax_synth_devs = index + 1;\n\t}\n\tspin_unlock_irqrestore(&register_lock, flags);\n#ifdef SNDRV_OSS_INFO_DEV_SYNTH\n\tif (rec->seq_device < SNDRV_CARDS)\n\t\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_SYNTH, rec->seq_device);\n#endif\n\n\tsnd_use_lock_sync(&rec->use_lock);\n\tkfree(rec);\n\n\treturn 0;\n}\n\n\n \nstatic struct seq_oss_synth *\nget_sdev(int dev)\n{\n\tstruct seq_oss_synth *rec;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\trec = synth_devs[dev];\n\tif (rec)\n\t\tsnd_use_lock_use(&rec->use_lock);\n\tspin_unlock_irqrestore(&register_lock, flags);\n\treturn rec;\n}\n\n\n \n\nvoid\nsnd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)\n{\n\tint i;\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info;\n\n\tdp->max_synthdev = max_synth_devs;\n\tdp->synth_opened = 0;\n\tmemset(dp->synths, 0, sizeof(dp->synths));\n\tfor (i = 0; i < dp->max_synthdev; i++) {\n\t\trec = get_sdev(i);\n\t\tif (rec == NULL)\n\t\t\tcontinue;\n\t\tif (rec->oper.open == NULL || rec->oper.close == NULL) {\n\t\t\tsnd_use_lock_free(&rec->use_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinfo = &dp->synths[i];\n\t\tinfo->arg.app_index = dp->port;\n\t\tinfo->arg.file_mode = dp->file_mode;\n\t\tinfo->arg.seq_mode = dp->seq_mode;\n\t\tif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH)\n\t\t\tinfo->arg.event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;\n\t\telse\n\t\t\tinfo->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;\n\t\tinfo->opened = 0;\n\t\tif (!try_module_get(rec->oper.owner)) {\n\t\t\tsnd_use_lock_free(&rec->use_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (rec->oper.open(&info->arg, rec->private_data) < 0) {\n\t\t\tmodule_put(rec->oper.owner);\n\t\t\tsnd_use_lock_free(&rec->use_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinfo->nr_voices = rec->nr_voices;\n\t\tif (info->nr_voices > 0) {\n\t\t\tinfo->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);\n\t\t\tif (!info->ch) {\n\t\t\t\trec->oper.close(&info->arg);\n\t\t\t\tmodule_put(rec->oper.owner);\n\t\t\t\tsnd_use_lock_free(&rec->use_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treset_channels(info);\n\t\t}\n\t\tinfo->opened++;\n\t\trec->opened++;\n\t\tdp->synth_opened++;\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n}\n\n\n \n\nvoid\nsnd_seq_oss_synth_setup_midi(struct seq_oss_devinfo *dp)\n{\n\tint i;\n\n\tif (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)\n\t\treturn;\n\n\tfor (i = 0; i < dp->max_mididev; i++) {\n\t\tstruct seq_oss_synthinfo *info;\n\t\tinfo = &dp->synths[dp->max_synthdev];\n\t\tif (snd_seq_oss_midi_open(dp, i, dp->file_mode) < 0)\n\t\t\tcontinue;\n\t\tinfo->arg.app_index = dp->port;\n\t\tinfo->arg.file_mode = dp->file_mode;\n\t\tinfo->arg.seq_mode = dp->seq_mode;\n\t\tinfo->arg.private_data = info;\n\t\tinfo->is_midi = 1;\n\t\tinfo->midi_mapped = i;\n\t\tinfo->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;\n\t\tsnd_seq_oss_midi_get_addr(dp, i, &info->arg.addr);\n\t\tinfo->opened = 1;\n\t\tmidi_synth_dev.opened++;\n\t\tdp->max_synthdev++;\n\t\tif (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)\n\t\t\tbreak;\n\t}\n}\n\n\n \n\nvoid\nsnd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)\n{\n\tint i;\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info;\n\n\tif (snd_BUG_ON(dp->max_synthdev > SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))\n\t\treturn;\n\tfor (i = 0; i < dp->max_synthdev; i++) {\n\t\tinfo = &dp->synths[i];\n\t\tif (! info->opened)\n\t\t\tcontinue;\n\t\tif (info->is_midi) {\n\t\t\tif (midi_synth_dev.opened > 0) {\n\t\t\t\tsnd_seq_oss_midi_close(dp, info->midi_mapped);\n\t\t\t\tmidi_synth_dev.opened--;\n\t\t\t}\n\t\t} else {\n\t\t\trec = get_sdev(i);\n\t\t\tif (rec == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (rec->opened > 0) {\n\t\t\t\trec->oper.close(&info->arg);\n\t\t\t\tmodule_put(rec->oper.owner);\n\t\t\t\trec->opened = 0;\n\t\t\t}\n\t\t\tsnd_use_lock_free(&rec->use_lock);\n\t\t}\n\t\tkfree(info->sysex);\n\t\tinfo->sysex = NULL;\n\t\tkfree(info->ch);\n\t\tinfo->ch = NULL;\n\t}\n\tdp->synth_opened = 0;\n\tdp->max_synthdev = 0;\n}\n\nstatic struct seq_oss_synthinfo *\nget_synthinfo_nospec(struct seq_oss_devinfo *dp, int dev)\n{\n\tif (dev < 0 || dev >= dp->max_synthdev)\n\t\treturn NULL;\n\tdev = array_index_nospec(dev, SNDRV_SEQ_OSS_MAX_SYNTH_DEVS);\n\treturn &dp->synths[dev];\n}\n\n \nstatic struct seq_oss_synth *\nget_synthdev(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info = get_synthinfo_nospec(dp, dev);\n\n\tif (!info)\n\t\treturn NULL;\n\tif (!info->opened)\n\t\treturn NULL;\n\tif (info->is_midi) {\n\t\trec = &midi_synth_dev;\n\t\tsnd_use_lock_use(&rec->use_lock);\n\t} else {\n\t\trec = get_sdev(dev);\n\t\tif (!rec)\n\t\t\treturn NULL;\n\t}\n\tif (! rec->opened) {\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t\treturn NULL;\n\t}\n\treturn rec;\n}\n\n\n \nstatic void\nreset_channels(struct seq_oss_synthinfo *info)\n{\n\tint i;\n\tif (info->ch == NULL || ! info->nr_voices)\n\t\treturn;\n\tfor (i = 0; i < info->nr_voices; i++) {\n\t\tinfo->ch[i].note = -1;\n\t\tinfo->ch[i].vel = 0;\n\t}\n}\n\n\n \nvoid\nsnd_seq_oss_synth_reset(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info;\n\n\tinfo = get_synthinfo_nospec(dp, dev);\n\tif (!info || !info->opened)\n\t\treturn;\n\tif (info->sysex)\n\t\tinfo->sysex->len = 0;  \n\treset_channels(info);\n\tif (info->is_midi) {\n\t\tif (midi_synth_dev.opened <= 0)\n\t\t\treturn;\n\t\tsnd_seq_oss_midi_reset(dp, info->midi_mapped);\n\t\t \n\t\tsnd_seq_oss_midi_close(dp, dev);\n\t\tif (snd_seq_oss_midi_open(dp, info->midi_mapped,\n\t\t\t\t\t  dp->file_mode) < 0) {\n\t\t\tmidi_synth_dev.opened--;\n\t\t\tinfo->opened = 0;\n\t\t\tkfree(info->sysex);\n\t\t\tinfo->sysex = NULL;\n\t\t\tkfree(info->ch);\n\t\t\tinfo->ch = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\trec = get_sdev(dev);\n\tif (rec == NULL)\n\t\treturn;\n\tif (rec->oper.reset) {\n\t\trec->oper.reset(&info->arg);\n\t} else {\n\t\tstruct snd_seq_event ev;\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tsnd_seq_oss_fill_addr(dp, &ev, info->arg.addr.client,\n\t\t\t\t      info->arg.addr.port);\n\t\tev.type = SNDRV_SEQ_EVENT_RESET;\n\t\tsnd_seq_oss_dispatch(dp, &ev, 0, 0);\n\t}\n\tsnd_use_lock_free(&rec->use_lock);\n}\n\n\n \nint\nsnd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,\n\t\t\t    const char __user *buf, int p, int c)\n{\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info;\n\tint rc;\n\n\tinfo = get_synthinfo_nospec(dp, dev);\n\tif (!info)\n\t\treturn -ENXIO;\n\n\tif (info->is_midi)\n\t\treturn 0;\n\trec = get_synthdev(dp, dev);\n\tif (!rec)\n\t\treturn -ENXIO;\n\n\tif (rec->oper.load_patch == NULL)\n\t\trc = -ENXIO;\n\telse\n\t\trc = rec->oper.load_patch(&info->arg, fmt, buf, p, c);\n\tsnd_use_lock_free(&rec->use_lock);\n\treturn rc;\n}\n\n \nstruct seq_oss_synthinfo *\nsnd_seq_oss_synth_info(struct seq_oss_devinfo *dp, int dev)\n{\n\tstruct seq_oss_synth *rec;\n\n\trec = get_synthdev(dp, dev);\n\tif (rec) {\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t\treturn get_synthinfo_nospec(dp, dev);\n\t}\n\treturn NULL;\n}\n\n\n \nint\nsnd_seq_oss_synth_sysex(struct seq_oss_devinfo *dp, int dev, unsigned char *buf, struct snd_seq_event *ev)\n{\n\tint i, send;\n\tunsigned char *dest;\n\tstruct seq_oss_synth_sysex *sysex;\n\tstruct seq_oss_synthinfo *info;\n\n\tinfo = snd_seq_oss_synth_info(dp, dev);\n\tif (!info)\n\t\treturn -ENXIO;\n\n\tsysex = info->sysex;\n\tif (sysex == NULL) {\n\t\tsysex = kzalloc(sizeof(*sysex), GFP_KERNEL);\n\t\tif (sysex == NULL)\n\t\t\treturn -ENOMEM;\n\t\tinfo->sysex = sysex;\n\t}\n\n\tsend = 0;\n\tdest = sysex->buf + sysex->len;\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tsend = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdest[i] = buf[i];\n\t\tsysex->len++;\n\t\tif (sysex->len >= MAX_SYSEX_BUFLEN) {\n\t\t\tsysex->len = 0;\n\t\t\tsysex->skip = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sysex->len && send) {\n\t\tif (sysex->skip) {\n\t\t\tsysex->skip = 0;\n\t\t\tsysex->len = 0;\n\t\t\treturn -EINVAL;  \n\t\t}\n\t\t \n\t\tev->flags = SNDRV_SEQ_EVENT_LENGTH_VARIABLE;\n\t\tif (snd_seq_oss_synth_addr(dp, dev, ev))\n\t\t\treturn -EINVAL;\n\t\tev->data.ext.len = sysex->len;\n\t\tev->data.ext.ptr = sysex->buf;\n\t\tsysex->len = 0;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;  \n}\n\n \nint\nsnd_seq_oss_synth_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_event *ev)\n{\n\tstruct seq_oss_synthinfo *info = snd_seq_oss_synth_info(dp, dev);\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tsnd_seq_oss_fill_addr(dp, ev, info->arg.addr.client,\n\t\t\t      info->arg.addr.port);\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_synth_ioctl(struct seq_oss_devinfo *dp, int dev, unsigned int cmd, unsigned long addr)\n{\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info;\n\tint rc;\n\n\tinfo = get_synthinfo_nospec(dp, dev);\n\tif (!info || info->is_midi)\n\t\treturn -ENXIO;\n\trec = get_synthdev(dp, dev);\n\tif (!rec)\n\t\treturn -ENXIO;\n\tif (rec->oper.ioctl == NULL)\n\t\trc = -ENXIO;\n\telse\n\t\trc = rec->oper.ioctl(&info->arg, cmd, addr);\n\tsnd_use_lock_free(&rec->use_lock);\n\treturn rc;\n}\n\n\n \nint\nsnd_seq_oss_synth_raw_event(struct seq_oss_devinfo *dp, int dev, unsigned char *data, struct snd_seq_event *ev)\n{\n\tstruct seq_oss_synthinfo *info;\n\n\tinfo = snd_seq_oss_synth_info(dp, dev);\n\tif (!info || info->is_midi)\n\t\treturn -ENXIO;\n\tev->type = SNDRV_SEQ_EVENT_OSS;\n\tmemcpy(ev->data.raw8.d, data, 8);\n\treturn snd_seq_oss_synth_addr(dp, dev, ev);\n}\n\n\n \nint\nsnd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tstruct seq_oss_synthinfo *info = get_synthinfo_nospec(dp, dev);\n\n\tif (!info)\n\t\treturn -ENXIO;\n\n\tif (info->is_midi) {\n\t\tstruct midi_info minf;\n\t\tif (snd_seq_oss_midi_make_info(dp, info->midi_mapped, &minf))\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrscpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\trec = get_synthdev(dp, dev);\n\t\tif (!rec)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrscpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\n \nvoid\nsnd_seq_oss_synth_info_read(struct snd_info_buffer *buf)\n{\n\tint i;\n\tstruct seq_oss_synth *rec;\n\n\tsnd_iprintf(buf, \"\\nNumber of synth devices: %d\\n\", max_synth_devs);\n\tfor (i = 0; i < max_synth_devs; i++) {\n\t\tsnd_iprintf(buf, \"\\nsynth %d: \", i);\n\t\trec = get_sdev(i);\n\t\tif (rec == NULL) {\n\t\t\tsnd_iprintf(buf, \"*empty*\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tsnd_iprintf(buf, \"[%s]\\n\", rec->name);\n\t\tsnd_iprintf(buf, \"  type 0x%x : subtype 0x%x : voices %d\\n\",\n\t\t\t    rec->synth_type, rec->synth_subtype,\n\t\t\t    rec->nr_voices);\n\t\tsnd_iprintf(buf, \"  capabilities : ioctl %s / load_patch %s\\n\",\n\t\t\t    enabled_str((long)rec->oper.ioctl),\n\t\t\t    enabled_str((long)rec->oper.load_patch));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}