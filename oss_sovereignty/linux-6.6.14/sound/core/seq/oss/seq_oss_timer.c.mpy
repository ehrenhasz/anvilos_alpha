{
  "module_name": "seq_oss_timer.c",
  "hash_id": "79ace7a18cd556c0a834a2d42be0f982217ddcf4bc045d5be26a0077553fe87f",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_timer.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_timer.h\"\n#include \"seq_oss_event.h\"\n#include <sound/seq_oss_legacy.h>\n#include <linux/slab.h>\n\n \n#define MIN_OSS_TEMPO\t\t8\n#define MAX_OSS_TEMPO\t\t360\n#define MIN_OSS_TIMEBASE\t1\n#define MAX_OSS_TIMEBASE\t1000\n\n \nstatic void calc_alsa_tempo(struct seq_oss_timer *timer);\nstatic int send_timer_event(struct seq_oss_devinfo *dp, int type, int value);\n\n\n \nstruct seq_oss_timer *\nsnd_seq_oss_timer_new(struct seq_oss_devinfo *dp)\n{\n\tstruct seq_oss_timer *rec;\n\n\trec = kzalloc(sizeof(*rec), GFP_KERNEL);\n\tif (rec == NULL)\n\t\treturn NULL;\n\n\trec->dp = dp;\n\trec->cur_tick = 0;\n\trec->realtime = 0;\n\trec->running = 0;\n\trec->oss_tempo = 60;\n\trec->oss_timebase = 100;\n\tcalc_alsa_tempo(rec);\n\n\treturn rec;\n}\n\n\n \nvoid\nsnd_seq_oss_timer_delete(struct seq_oss_timer *rec)\n{\n\tif (rec) {\n\t\tsnd_seq_oss_timer_stop(rec);\n\t\tkfree(rec);\n\t}\n}\n\n\n \nint\nsnd_seq_oss_process_timer_event(struct seq_oss_timer *rec, union evrec *ev)\n{\n\tabstime_t parm = ev->t.time;\n\n\tif (ev->t.code == EV_TIMING) {\n\t\tswitch (ev->t.cmd) {\n\t\tcase TMR_WAIT_REL:\n\t\t\tparm += rec->cur_tick;\n\t\t\trec->realtime = 0;\n\t\t\tfallthrough;\n\t\tcase TMR_WAIT_ABS:\n\t\t\tif (parm == 0) {\n\t\t\t\trec->realtime = 1;\n\t\t\t} else if (parm >= rec->cur_tick) {\n\t\t\t\trec->realtime = 0;\n\t\t\t\trec->cur_tick = parm;\n\t\t\t}\n\t\t\treturn 1;\t \n\t\t\t\n\t\tcase TMR_START:\n\t\t\tsnd_seq_oss_timer_start(rec);\n\t\t\treturn 1;\n\n\t\t}\n\t} else if (ev->s.code == SEQ_WAIT) {\n\t\t \n\t\tparm = (ev->echo >> 8) & 0xffffff;\n\t\tif (parm > rec->cur_tick) {\n\t\t\t \n\t\t\trec->cur_tick = parm;\n\t\t\trec->realtime = 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void\ncalc_alsa_tempo(struct seq_oss_timer *timer)\n{\n\ttimer->tempo = (60 * 1000000) / timer->oss_tempo;\n\ttimer->ppq = timer->oss_timebase;\n}\n\n\n \nstatic int\nsend_timer_event(struct seq_oss_devinfo *dp, int type, int value)\n{\n\tstruct snd_seq_event ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = type;\n\tev.source.client = dp->cseq;\n\tev.source.port = 0;\n\tev.dest.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tev.dest.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\n\tev.queue = dp->queue;\n\tev.data.queue.queue = dp->queue;\n\tev.data.queue.param.value = value;\n\treturn snd_seq_kernel_client_dispatch(dp->cseq, &ev, 1, 0);\n}\n\n \nint\nsnd_seq_oss_timer_start(struct seq_oss_timer *timer)\n{\n\tstruct seq_oss_devinfo *dp = timer->dp;\n\tstruct snd_seq_queue_tempo tmprec;\n\n\tif (timer->running)\n\t\tsnd_seq_oss_timer_stop(timer);\n\n\tmemset(&tmprec, 0, sizeof(tmprec));\n\ttmprec.queue = dp->queue;\n\ttmprec.ppq = timer->ppq;\n\ttmprec.tempo = timer->tempo;\n\tsnd_seq_set_queue_tempo(dp->cseq, &tmprec);\n\n\tsend_timer_event(dp, SNDRV_SEQ_EVENT_START, 0);\n\ttimer->running = 1;\n\ttimer->cur_tick = 0;\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_timer_stop(struct seq_oss_timer *timer)\n{\n\tif (! timer->running)\n\t\treturn 0;\n\tsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_STOP, 0);\n\ttimer->running = 0;\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_timer_continue(struct seq_oss_timer *timer)\n{\n\tif (timer->running)\n\t\treturn 0;\n\tsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_CONTINUE, 0);\n\ttimer->running = 1;\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_timer_tempo(struct seq_oss_timer *timer, int value)\n{\n\tif (value < MIN_OSS_TEMPO)\n\t\tvalue = MIN_OSS_TEMPO;\n\telse if (value > MAX_OSS_TEMPO)\n\t\tvalue = MAX_OSS_TEMPO;\n\ttimer->oss_tempo = value;\n\tcalc_alsa_tempo(timer);\n\tif (timer->running)\n\t\tsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_TEMPO, timer->tempo);\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_timer_ioctl(struct seq_oss_timer *timer, unsigned int cmd, int __user *arg)\n{\n\tint value;\n\n\tif (cmd == SNDCTL_SEQ_CTRLRATE) {\n\t\t \n\t\tif (get_user(value, arg))\n\t\t\treturn -EFAULT;\n\t\tif (value)\n\t\t\treturn -EINVAL;\n\t\tvalue = ((timer->oss_tempo * timer->oss_timebase) + 30) / 60;\n\t\treturn put_user(value, arg) ? -EFAULT : 0;\n\t}\n\n\tif (timer->dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase SNDCTL_TMR_START:\n\t\treturn snd_seq_oss_timer_start(timer);\n\tcase SNDCTL_TMR_STOP:\n\t\treturn snd_seq_oss_timer_stop(timer);\n\tcase SNDCTL_TMR_CONTINUE:\n\t\treturn snd_seq_oss_timer_continue(timer);\n\tcase SNDCTL_TMR_TEMPO:\n\t\tif (get_user(value, arg))\n\t\t\treturn -EFAULT;\n\t\treturn snd_seq_oss_timer_tempo(timer, value);\n\tcase SNDCTL_TMR_TIMEBASE:\n\t\tif (get_user(value, arg))\n\t\t\treturn -EFAULT;\n\t\tif (value < MIN_OSS_TIMEBASE)\n\t\t\tvalue = MIN_OSS_TIMEBASE;\n\t\telse if (value > MAX_OSS_TIMEBASE)\n\t\t\tvalue = MAX_OSS_TIMEBASE;\n\t\ttimer->oss_timebase = value;\n\t\tcalc_alsa_tempo(timer);\n\t\treturn 0;\n\n\tcase SNDCTL_TMR_METRONOME:\n\tcase SNDCTL_TMR_SELECT:\n\tcase SNDCTL_TMR_SOURCE:\n\t\t \n\t\treturn 0;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}