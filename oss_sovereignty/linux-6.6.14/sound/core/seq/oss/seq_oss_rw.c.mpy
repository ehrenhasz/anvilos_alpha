{
  "module_name": "seq_oss_rw.c",
  "hash_id": "5dbf185916b17e8cbbae8a029449eaa80cf98c6d1d0ee2b619281ab1f1830c0a",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_rw.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_device.h\"\n#include \"seq_oss_readq.h\"\n#include \"seq_oss_writeq.h\"\n#include \"seq_oss_synth.h\"\n#include <sound/seq_oss_legacy.h>\n#include \"seq_oss_event.h\"\n#include \"seq_oss_timer.h\"\n#include \"../seq_clientmgr.h\"\n\n\n \nstatic int insert_queue(struct seq_oss_devinfo *dp, union evrec *rec, struct file *opt);\n\n\n \n\nint\nsnd_seq_oss_read(struct seq_oss_devinfo *dp, char __user *buf, int count)\n{\n\tstruct seq_oss_readq *readq = dp->readq;\n\tint result = 0, err = 0;\n\tint ev_len;\n\tunion evrec rec;\n\tunsigned long flags;\n\n\tif (readq == NULL || ! is_read_mode(dp->file_mode))\n\t\treturn -ENXIO;\n\n\twhile (count >= SHORT_EVENT_SIZE) {\n\t\tsnd_seq_oss_readq_lock(readq, flags);\n\t\terr = snd_seq_oss_readq_pick(readq, &rec);\n\t\tif (err == -EAGAIN &&\n\t\t    !is_nonblock_mode(dp->file_mode) && result == 0) {\n\t\t\tsnd_seq_oss_readq_unlock(readq, flags);\n\t\t\tsnd_seq_oss_readq_wait(readq);\n\t\t\tsnd_seq_oss_readq_lock(readq, flags);\n\t\t\tif (signal_pending(current))\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\telse\n\t\t\t\terr = snd_seq_oss_readq_pick(readq, &rec);\n\t\t}\n\t\tif (err < 0) {\n\t\t\tsnd_seq_oss_readq_unlock(readq, flags);\n\t\t\tbreak;\n\t\t}\n\t\tev_len = ev_length(&rec);\n\t\tif (ev_len < count) {\n\t\t\tsnd_seq_oss_readq_unlock(readq, flags);\n\t\t\tbreak;\n\t\t}\n\t\tsnd_seq_oss_readq_free(readq);\n\t\tsnd_seq_oss_readq_unlock(readq, flags);\n\t\tif (copy_to_user(buf, &rec, ev_len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tresult += ev_len;\n\t\tbuf += ev_len;\n\t\tcount -= ev_len;\n\t}\n\treturn result > 0 ? result : err;\n}\n\n\n \n\nint\nsnd_seq_oss_write(struct seq_oss_devinfo *dp, const char __user *buf, int count, struct file *opt)\n{\n\tint result = 0, err = 0;\n\tint ev_size, fmt;\n\tunion evrec rec;\n\n\tif (! is_write_mode(dp->file_mode) || dp->writeq == NULL)\n\t\treturn -ENXIO;\n\n\twhile (count >= SHORT_EVENT_SIZE) {\n\t\tif (copy_from_user(&rec, buf, SHORT_EVENT_SIZE)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (rec.s.code == SEQ_FULLSIZE) {\n\t\t\t \n\t\t\tif (result > 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfmt = (*(unsigned short *)rec.c) & 0xffff;\n\t\t\t \n\t\t\treturn snd_seq_oss_synth_load_patch(dp, rec.s.dev,\n\t\t\t\t\t\t\t    fmt, buf, 0, count);\n\t\t}\n\t\tif (ev_is_long(&rec)) {\n\t\t\t \n\t\t\tif (rec.s.code == SEQ_EXTENDED &&\n\t\t\t    dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tev_size = LONG_EVENT_SIZE;\n\t\t\tif (count < ev_size)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (copy_from_user(rec.c + SHORT_EVENT_SIZE,\n\t\t\t\t\t   buf + SHORT_EVENT_SIZE,\n\t\t\t\t\t   LONG_EVENT_SIZE - SHORT_EVENT_SIZE)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tev_size = SHORT_EVENT_SIZE;\n\t\t}\n\n\t\t \n\t\terr = insert_queue(dp, &rec, opt);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tresult += ev_size;\n\t\tbuf += ev_size;\n\t\tcount -= ev_size;\n\t}\n\treturn result > 0 ? result : err;\n}\n\n\n \nstatic int\ninsert_queue(struct seq_oss_devinfo *dp, union evrec *rec, struct file *opt)\n{\n\tint rc = 0;\n\tstruct snd_seq_event event;\n\n\t \n\tif (snd_seq_oss_process_timer_event(dp->timer, rec))\n\t\treturn 0;  \n\n\t \n\tmemset(&event, 0, sizeof(event));\n\t \n\tevent.type = SNDRV_SEQ_EVENT_NOTEOFF;\n\tsnd_seq_oss_fill_addr(dp, &event, dp->addr.client, dp->addr.port);\n\n\tif (snd_seq_oss_process_event(dp, rec, &event))\n\t\treturn 0;  \n\n\tevent.time.tick = snd_seq_oss_timer_cur_tick(dp->timer);\n\tif (dp->timer->realtime || !dp->timer->running)\n\t\tsnd_seq_oss_dispatch(dp, &event, 0, 0);\n\telse\n\t\trc = snd_seq_kernel_client_enqueue(dp->cseq, &event, opt,\n\t\t\t\t\t\t   !is_nonblock_mode(dp->file_mode));\n\treturn rc;\n}\n\t\t\n\n \n  \n__poll_t\nsnd_seq_oss_poll(struct seq_oss_devinfo *dp, struct file *file, poll_table * wait)\n{\n\t__poll_t mask = 0;\n\n\t \n\tif (dp->readq && is_read_mode(dp->file_mode)) {\n\t\tif (snd_seq_oss_readq_poll(dp->readq, file, wait))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\t \n\tif (dp->writeq && is_write_mode(dp->file_mode)) {\n\t\tif (snd_seq_kernel_client_write_poll(dp->cseq, file, wait))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\treturn mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}