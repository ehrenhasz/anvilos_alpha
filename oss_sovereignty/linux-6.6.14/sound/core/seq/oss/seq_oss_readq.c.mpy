{
  "module_name": "seq_oss_readq.c",
  "hash_id": "71e13ce90cfa8c72317c39cae2fcc6396296006e1bc5252e2bc1b2777ea5cb3e",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_readq.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_readq.h\"\n#include \"seq_oss_event.h\"\n#include <sound/seq_oss_legacy.h>\n#include \"../seq_lock.h\"\n#include <linux/wait.h>\n#include <linux/slab.h>\n\n \n\n#define SNDRV_SEQ_OSS_MAX_TIMEOUT\t(HZ * 3600)\n\n\n \n\n\n \nstruct seq_oss_readq *\nsnd_seq_oss_readq_new(struct seq_oss_devinfo *dp, int maxlen)\n{\n\tstruct seq_oss_readq *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tq->q = kcalloc(maxlen, sizeof(union evrec), GFP_KERNEL);\n\tif (!q->q) {\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tq->maxlen = maxlen;\n\tq->qlen = 0;\n\tq->head = q->tail = 0;\n\tinit_waitqueue_head(&q->midi_sleep);\n\tspin_lock_init(&q->lock);\n\tq->pre_event_timeout = SNDRV_SEQ_OSS_MAX_TIMEOUT;\n\tq->input_time = (unsigned long)-1;\n\n\treturn q;\n}\n\n \nvoid\nsnd_seq_oss_readq_delete(struct seq_oss_readq *q)\n{\n\tif (q) {\n\t\tkfree(q->q);\n\t\tkfree(q);\n\t}\n}\n\n \nvoid\nsnd_seq_oss_readq_clear(struct seq_oss_readq *q)\n{\n\tif (q->qlen) {\n\t\tq->qlen = 0;\n\t\tq->head = q->tail = 0;\n\t}\n\t \n\twake_up(&q->midi_sleep);\n\tq->input_time = (unsigned long)-1;\n}\n\n \nint\nsnd_seq_oss_readq_puts(struct seq_oss_readq *q, int dev, unsigned char *data, int len)\n{\n\tunion evrec rec;\n\tint result;\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.c[0] = SEQ_MIDIPUTC;\n\trec.c[2] = dev;\n\n\twhile (len-- > 0) {\n\t\trec.c[1] = *data++;\n\t\tresult = snd_seq_oss_readq_put_event(q, &rec);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t}\n\treturn 0;\n}\n\n \nstruct readq_sysex_ctx {\n\tstruct seq_oss_readq *readq;\n\tint dev;\n};\n\nstatic int readq_dump_sysex(void *ptr, void *buf, int count)\n{\n\tstruct readq_sysex_ctx *ctx = ptr;\n\n\treturn snd_seq_oss_readq_puts(ctx->readq, ctx->dev, buf, count);\n}\n\nint snd_seq_oss_readq_sysex(struct seq_oss_readq *q, int dev,\n\t\t\t    struct snd_seq_event *ev)\n{\n\tstruct readq_sysex_ctx ctx = {\n\t\t.readq = q,\n\t\t.dev = dev\n\t};\n\n\tif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)\n\t\treturn 0;\n\treturn snd_seq_dump_var_event(ev, readq_dump_sysex, &ctx);\n}\n\n \nint\nsnd_seq_oss_readq_put_event(struct seq_oss_readq *q, union evrec *ev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\tif (q->qlen >= q->maxlen - 1) {\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&q->q[q->tail], ev, sizeof(*ev));\n\tq->tail = (q->tail + 1) % q->maxlen;\n\tq->qlen++;\n\n\t \n\twake_up(&q->midi_sleep);\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_readq_pick(struct seq_oss_readq *q, union evrec *rec)\n{\n\tif (q->qlen == 0)\n\t\treturn -EAGAIN;\n\tmemcpy(rec, &q->q[q->head], sizeof(*rec));\n\treturn 0;\n}\n\n \nvoid\nsnd_seq_oss_readq_wait(struct seq_oss_readq *q)\n{\n\twait_event_interruptible_timeout(q->midi_sleep,\n\t\t\t\t\t (q->qlen > 0 || q->head == q->tail),\n\t\t\t\t\t q->pre_event_timeout);\n}\n\n \nvoid\nsnd_seq_oss_readq_free(struct seq_oss_readq *q)\n{\n\tif (q->qlen > 0) {\n\t\tq->head = (q->head + 1) % q->maxlen;\n\t\tq->qlen--;\n\t}\n}\n\n \nunsigned int\nsnd_seq_oss_readq_poll(struct seq_oss_readq *q, struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &q->midi_sleep, wait);\n\treturn q->qlen;\n}\n\n \nint\nsnd_seq_oss_readq_put_timestamp(struct seq_oss_readq *q, unsigned long curt, int seq_mode)\n{\n\tif (curt != q->input_time) {\n\t\tunion evrec rec;\n\t\tmemset(&rec, 0, sizeof(rec));\n\t\tswitch (seq_mode) {\n\t\tcase SNDRV_SEQ_OSS_MODE_SYNTH:\n\t\t\trec.echo = (curt << 8) | SEQ_WAIT;\n\t\t\tsnd_seq_oss_readq_put_event(q, &rec);\n\t\t\tbreak;\n\t\tcase SNDRV_SEQ_OSS_MODE_MUSIC:\n\t\t\trec.t.code = EV_TIMING;\n\t\t\trec.t.cmd = TMR_WAIT_ABS;\n\t\t\trec.t.time = curt;\n\t\t\tsnd_seq_oss_readq_put_event(q, &rec);\n\t\t\tbreak;\n\t\t}\n\t\tq->input_time = curt;\n\t}\n\treturn 0;\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\n \nvoid\nsnd_seq_oss_readq_info_read(struct seq_oss_readq *q, struct snd_info_buffer *buf)\n{\n\tsnd_iprintf(buf, \"  read queue [%s] length = %d : tick = %ld\\n\",\n\t\t    (waitqueue_active(&q->midi_sleep) ? \"sleeping\":\"running\"),\n\t\t    q->qlen, q->input_time);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}