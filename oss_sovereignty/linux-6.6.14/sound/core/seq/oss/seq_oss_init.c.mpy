{
  "module_name": "seq_oss_init.c",
  "hash_id": "f7e76c9f66a22ca4f725b49fdfa4dc76e6a06bdf1ffb103fa7ccdd9c526d4ebe",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_init.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_device.h\"\n#include \"seq_oss_synth.h\"\n#include \"seq_oss_midi.h\"\n#include \"seq_oss_writeq.h\"\n#include \"seq_oss_readq.h\"\n#include \"seq_oss_timer.h\"\n#include \"seq_oss_event.h\"\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n \nstatic int maxqlen = SNDRV_SEQ_OSS_MAX_QLEN;\nmodule_param(maxqlen, int, 0444);\nMODULE_PARM_DESC(maxqlen, \"maximum queue length\");\n\nstatic int system_client = -1;  \nstatic int system_port = -1;\n\nstatic int num_clients;\nstatic struct seq_oss_devinfo *client_table[SNDRV_SEQ_OSS_MAX_CLIENTS];\n\n\n \nstatic int receive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic, int hop);\nstatic int translate_mode(struct file *file);\nstatic int create_port(struct seq_oss_devinfo *dp);\nstatic int delete_port(struct seq_oss_devinfo *dp);\nstatic int alloc_seq_queue(struct seq_oss_devinfo *dp);\nstatic int delete_seq_queue(int queue);\nstatic void free_devinfo(void *private);\n\n#define call_ctl(type,rec) snd_seq_kernel_client_ctl(system_client, type, rec)\n\n\n \nstatic void async_call_lookup_ports(struct work_struct *work)\n{\n\tsnd_seq_oss_midi_lookup_ports(system_client);\n}\n\nstatic DECLARE_WORK(async_lookup_work, async_call_lookup_ports);\n\n \nint __init\nsnd_seq_oss_create_client(void)\n{\n\tint rc;\n\tstruct snd_seq_port_info *port;\n\tstruct snd_seq_port_callback port_callback;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\trc = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\t \n\trc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS,\n\t\t\t\t\t  \"OSS sequencer\");\n\tif (rc < 0)\n\t\tgoto __error;\n\n\tsystem_client = rc;\n\n\t \n\tstrcpy(port->name, \"Receiver\");\n\tport->addr.client = system_client;\n\tport->capability = SNDRV_SEQ_PORT_CAP_WRITE;  \n\tport->type = 0;\n\n\tmemset(&port_callback, 0, sizeof(port_callback));\n\t \n\tport_callback.event_input = receive_announce;\n\tport->kernel = &port_callback;\n\t\n\tif (call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, port) >= 0) {\n\t\tstruct snd_seq_port_subscribe subs;\n\n\t\tsystem_port = port->addr.port;\n\t\tmemset(&subs, 0, sizeof(subs));\n\t\tsubs.sender.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\t\tsubs.sender.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\n\t\tsubs.dest.client = system_client;\n\t\tsubs.dest.port = system_port;\n\t\tcall_ctl(SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs);\n\t}\n\trc = 0;\n\n\t \n\tschedule_work(&async_lookup_work);\n\n __error:\n\tkfree(port);\n\treturn rc;\n}\n\n\n \nstatic int\nreceive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic, int hop)\n{\n\tstruct snd_seq_port_info pinfo;\n\n\tif (atomic)\n\t\treturn 0;  \n\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_PORT_START:\n\tcase SNDRV_SEQ_EVENT_PORT_CHANGE:\n\t\tif (ev->data.addr.client == system_client)\n\t\t\tbreak;  \n\t\tmemset(&pinfo, 0, sizeof(pinfo));\n\t\tpinfo.addr = ev->data.addr;\n\t\tif (call_ctl(SNDRV_SEQ_IOCTL_GET_PORT_INFO, &pinfo) >= 0)\n\t\t\tsnd_seq_oss_midi_check_new_port(&pinfo);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_PORT_EXIT:\n\t\tif (ev->data.addr.client == system_client)\n\t\t\tbreak;  \n\t\tsnd_seq_oss_midi_check_exit_port(ev->data.addr.client,\n\t\t\t\t\t\tev->data.addr.port);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_delete_client(void)\n{\n\tcancel_work_sync(&async_lookup_work);\n\tif (system_client >= 0)\n\t\tsnd_seq_delete_kernel_client(system_client);\n\n\tsnd_seq_oss_midi_clear_all();\n\n\treturn 0;\n}\n\n\n \nint\nsnd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq_oss: too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t \n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t \n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t \n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tpr_err(\"ALSA: seq_oss: can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t \n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t \n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t \n\t \n\n\tdp->seq_mode = level;\n\n\t \n\tdp->file_mode = translate_mode(file);\n\n\t \n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t \n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t \n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tpr_err(\"ALSA: seq_oss: can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t \n\tfile->private_data = dp;\n\n\t \n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_seq_queue(dp->queue);\n\tdelete_port(dp);\n\n\treturn rc;\n}\n\n \nstatic int\ntranslate_mode(struct file *file)\n{\n\tint file_mode = 0;\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tfile_mode |= SNDRV_SEQ_OSS_FILE_WRITE;\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY)\n\t\tfile_mode |= SNDRV_SEQ_OSS_FILE_READ;\n\tif (file->f_flags & O_NONBLOCK)\n\t\tfile_mode |= SNDRV_SEQ_OSS_FILE_NONBLOCK;\n\treturn file_mode;\n}\n\n\n \nstatic int\ncreate_port(struct seq_oss_devinfo *dp)\n{\n\tint rc;\n\tstruct snd_seq_port_info port;\n\tstruct snd_seq_port_callback callback;\n\n\tmemset(&port, 0, sizeof(port));\n\tport.addr.client = dp->cseq;\n\tsprintf(port.name, \"Sequencer-%d\", dp->index);\n\tport.capability = SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_WRITE;  \n\tport.type = SNDRV_SEQ_PORT_TYPE_SPECIFIC;\n\tport.midi_channels = 128;\n\tport.synth_voices = 128;\n\n\tmemset(&callback, 0, sizeof(callback));\n\tcallback.owner = THIS_MODULE;\n\tcallback.private_data = dp;\n\tcallback.event_input = snd_seq_oss_event_input;\n\tcallback.private_free = free_devinfo;\n\tport.kernel = &callback;\n\n\trc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, &port);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdp->port = port.addr.port;\n\n\treturn 0;\n}\n\n \nstatic int\ndelete_port(struct seq_oss_devinfo *dp)\n{\n\tif (dp->port < 0) {\n\t\tkfree(dp);\n\t\treturn 0;\n\t}\n\n\treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n}\n\n \nstatic int\nalloc_seq_queue(struct seq_oss_devinfo *dp)\n{\n\tstruct snd_seq_queue_info qinfo;\n\tint rc;\n\n\tmemset(&qinfo, 0, sizeof(qinfo));\n\tqinfo.owner = system_client;\n\tqinfo.locked = 1;\n\tstrcpy(qinfo.name, \"OSS Sequencer Emulation\");\n\trc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_QUEUE, &qinfo);\n\tif (rc < 0)\n\t\treturn rc;\n\tdp->queue = qinfo.queue;\n\treturn 0;\n}\n\n \nstatic int\ndelete_seq_queue(int queue)\n{\n\tstruct snd_seq_queue_info qinfo;\n\tint rc;\n\n\tif (queue < 0)\n\t\treturn 0;\n\tmemset(&qinfo, 0, sizeof(qinfo));\n\tqinfo.queue = queue;\n\trc = call_ctl(SNDRV_SEQ_IOCTL_DELETE_QUEUE, &qinfo);\n\tif (rc < 0)\n\t\tpr_err(\"ALSA: seq_oss: unable to delete queue %d (%d)\\n\", queue, rc);\n\treturn rc;\n}\n\n\n \nstatic void\nfree_devinfo(void *private)\n{\n\tstruct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private;\n\n\tsnd_seq_oss_timer_delete(dp->timer);\n\t\t\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\n\tsnd_seq_oss_readq_delete(dp->readq);\n\t\n\tkfree(dp);\n}\n\n\n \nvoid\nsnd_seq_oss_release(struct seq_oss_devinfo *dp)\n{\n\tint queue;\n\n\tclient_table[dp->index] = NULL;\n\tnum_clients--;\n\n\tsnd_seq_oss_reset(dp);\n\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\n\t \n\tqueue = dp->queue;\n\tif (dp->port >= 0)\n\t\tdelete_port(dp);\n\tdelete_seq_queue(queue);\n}\n\n\n \nvoid\nsnd_seq_oss_reset(struct seq_oss_devinfo *dp)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < dp->max_synthdev; i++)\n\t\tsnd_seq_oss_synth_reset(dp, i);\n\n\t \n\tif (dp->seq_mode != SNDRV_SEQ_OSS_MODE_MUSIC) {\n\t\tfor (i = 0; i < dp->max_mididev; i++)\n\t\t\tsnd_seq_oss_midi_reset(dp, i);\n\t}\n\n\t \n\tif (dp->readq)\n\t\tsnd_seq_oss_readq_clear(dp->readq);\n\tif (dp->writeq)\n\t\tsnd_seq_oss_writeq_clear(dp->writeq);\n\n\t \n\tsnd_seq_oss_timer_stop(dp->timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n \nchar *\nenabled_str(int bool)\n{\n\treturn bool ? \"enabled\" : \"disabled\";\n}\n\nstatic const char *\nfilemode_str(int val)\n{\n\tstatic const char * const str[] = {\n\t\t\"none\", \"read\", \"write\", \"read/write\",\n\t};\n\treturn str[val & SNDRV_SEQ_OSS_FILE_ACMODE];\n}\n\n\n \nvoid\nsnd_seq_oss_system_info_read(struct snd_info_buffer *buf)\n{\n\tint i;\n\tstruct seq_oss_devinfo *dp;\n\n\tsnd_iprintf(buf, \"ALSA client number %d\\n\", system_client);\n\tsnd_iprintf(buf, \"ALSA receiver port %d\\n\", system_port);\n\n\tsnd_iprintf(buf, \"\\nNumber of applications: %d\\n\", num_clients);\n\tfor (i = 0; i < num_clients; i++) {\n\t\tsnd_iprintf(buf, \"\\nApplication %d: \", i);\n\t\tdp = client_table[i];\n\t\tif (!dp) {\n\t\t\tsnd_iprintf(buf, \"*empty*\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tsnd_iprintf(buf, \"port %d : queue %d\\n\", dp->port, dp->queue);\n\t\tsnd_iprintf(buf, \"  sequencer mode = %s : file open mode = %s\\n\",\n\t\t\t    (dp->seq_mode ? \"music\" : \"synth\"),\n\t\t\t    filemode_str(dp->file_mode));\n\t\tif (dp->seq_mode)\n\t\t\tsnd_iprintf(buf, \"  timer tempo = %d, timebase = %d\\n\",\n\t\t\t\t    dp->timer->oss_tempo, dp->timer->oss_timebase);\n\t\tsnd_iprintf(buf, \"  max queue length %d\\n\", maxqlen);\n\t\tif (is_read_mode(dp->file_mode) && dp->readq)\n\t\t\tsnd_seq_oss_readq_info_read(dp->readq, buf);\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}