{
  "module_name": "seq_oss_writeq.c",
  "hash_id": "a3765a894a7809b3c1fde10d1a36813458b83bc84decefafad2d7dabc5063ab8",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss_writeq.c",
  "human_readable_source": "\n \n\n#include \"seq_oss_writeq.h\"\n#include \"seq_oss_event.h\"\n#include \"seq_oss_timer.h\"\n#include <sound/seq_oss_legacy.h>\n#include \"../seq_lock.h\"\n#include \"../seq_clientmgr.h\"\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n\n \nstruct seq_oss_writeq *\nsnd_seq_oss_writeq_new(struct seq_oss_devinfo *dp, int maxlen)\n{\n\tstruct seq_oss_writeq *q;\n\tstruct snd_seq_client_pool pool;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\tq->dp = dp;\n\tq->maxlen = maxlen;\n\tspin_lock_init(&q->sync_lock);\n\tq->sync_event_put = 0;\n\tq->sync_time = 0;\n\tinit_waitqueue_head(&q->sync_sleep);\n\n\tmemset(&pool, 0, sizeof(pool));\n\tpool.client = dp->cseq;\n\tpool.output_pool = maxlen;\n\tpool.output_room = maxlen / 2;\n\n\tsnd_seq_oss_control(dp, SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, &pool);\n\n\treturn q;\n}\n\n \nvoid\nsnd_seq_oss_writeq_delete(struct seq_oss_writeq *q)\n{\n\tif (q) {\n\t\tsnd_seq_oss_writeq_clear(q);\t \n\t\tkfree(q);\n\t}\n}\n\n\n \nvoid\nsnd_seq_oss_writeq_clear(struct seq_oss_writeq *q)\n{\n\tstruct snd_seq_remove_events reset;\n\n\tmemset(&reset, 0, sizeof(reset));\n\treset.remove_mode = SNDRV_SEQ_REMOVE_OUTPUT;  \n\tsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_REMOVE_EVENTS, &reset);\n\n\t \n\tsnd_seq_oss_writeq_wakeup(q, 0);\n}\n\n \nint\nsnd_seq_oss_writeq_sync(struct seq_oss_writeq *q)\n{\n\tstruct seq_oss_devinfo *dp = q->dp;\n\tabstime_t time;\n\n\ttime = snd_seq_oss_timer_cur_tick(dp->timer);\n\tif (q->sync_time >= time)\n\t\treturn 0;  \n\n\tif (! q->sync_event_put) {\n\t\tstruct snd_seq_event ev;\n\t\tunion evrec *rec;\n\n\t\t \n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.flags = 0;\n\t\tev.type = SNDRV_SEQ_EVENT_ECHO;\n\t\tev.time.tick = time;\n\t\t \n\t\tsnd_seq_oss_fill_addr(dp, &ev, dp->addr.client, dp->addr.port);\n\t\trec = (union evrec *)&ev.data;\n\t\trec->t.code = SEQ_SYNCTIMER;\n\t\trec->t.time = time;\n\t\tq->sync_event_put = 1;\n\t\tsnd_seq_kernel_client_enqueue(dp->cseq, &ev, NULL, true);\n\t}\n\n\twait_event_interruptible_timeout(q->sync_sleep, ! q->sync_event_put, HZ);\n\tif (signal_pending(current))\n\t\t \n\t\tq->sync_event_put = 0;\n\tif (! q->sync_event_put || q->sync_time >= time)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nvoid\nsnd_seq_oss_writeq_wakeup(struct seq_oss_writeq *q, abstime_t time)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->sync_lock, flags);\n\tq->sync_time = time;\n\tq->sync_event_put = 0;\n\twake_up(&q->sync_sleep);\n\tspin_unlock_irqrestore(&q->sync_lock, flags);\n}\n\n\n \nint\nsnd_seq_oss_writeq_get_free_size(struct seq_oss_writeq *q)\n{\n\tstruct snd_seq_client_pool pool;\n\tpool.client = q->dp->cseq;\n\tsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, &pool);\n\treturn pool.output_free;\n}\n\n\n \nvoid\nsnd_seq_oss_writeq_set_output(struct seq_oss_writeq *q, int val)\n{\n\tstruct snd_seq_client_pool pool;\n\tpool.client = q->dp->cseq;\n\tsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, &pool);\n\tpool.output_room = val;\n\tsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, &pool);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}