{
  "module_name": "seq_oss.c",
  "hash_id": "6f39b0ef82af55d8fe9eb5e3498a9ed10be62c8331633b58b19fa6cae05cb188",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/oss/seq_oss.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include \"seq_oss_device.h\"\n#include \"seq_oss_synth.h\"\n\n \nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"OSS-compatible sequencer module\");\nMODULE_LICENSE(\"GPL\");\n \nMODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_SEQUENCER);\nMODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MUSIC);\n\n\n \nstatic int register_device(void);\nstatic void unregister_device(void);\n#ifdef CONFIG_SND_PROC_FS\nstatic int register_proc(void);\nstatic void unregister_proc(void);\n#else\nstatic inline int register_proc(void) { return 0; }\nstatic inline void unregister_proc(void) {}\n#endif\n\nstatic int odev_open(struct inode *inode, struct file *file);\nstatic int odev_release(struct inode *inode, struct file *file);\nstatic ssize_t odev_read(struct file *file, char __user *buf, size_t count, loff_t *offset);\nstatic ssize_t odev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset);\nstatic long odev_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nstatic __poll_t odev_poll(struct file *file, poll_table * wait);\n\n\n \n\nstatic struct snd_seq_driver seq_oss_synth_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.probe = snd_seq_oss_synth_probe,\n\t\t.remove = snd_seq_oss_synth_remove,\n\t},\n\t.id = SNDRV_SEQ_DEV_ID_OSS,\n\t.argsize = sizeof(struct snd_seq_oss_reg),\n};\n\nstatic int __init alsa_seq_oss_init(void)\n{\n\tint rc;\n\n\trc = register_device();\n\tif (rc < 0)\n\t\tgoto error;\n\trc = register_proc();\n\tif (rc < 0) {\n\t\tunregister_device();\n\t\tgoto error;\n\t}\n\trc = snd_seq_oss_create_client();\n\tif (rc < 0) {\n\t\tunregister_proc();\n\t\tunregister_device();\n\t\tgoto error;\n\t}\n\n\trc = snd_seq_driver_register(&seq_oss_synth_driver);\n\tif (rc < 0) {\n\t\tsnd_seq_oss_delete_client();\n\t\tunregister_proc();\n\t\tunregister_device();\n\t\tgoto error;\n\t}\n\n\t \n\tsnd_seq_oss_synth_init();\n\n error:\n\treturn rc;\n}\n\nstatic void __exit alsa_seq_oss_exit(void)\n{\n\tsnd_seq_driver_unregister(&seq_oss_synth_driver);\n\tsnd_seq_oss_delete_client();\n\tunregister_proc();\n\tunregister_device();\n}\n\nmodule_init(alsa_seq_oss_init)\nmodule_exit(alsa_seq_oss_exit)\n\n \n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int\nodev_open(struct inode *inode, struct file *file)\n{\n\tint level, rc;\n\n\tif (iminor(inode) == SNDRV_MINOR_OSS_MUSIC)\n\t\tlevel = SNDRV_SEQ_OSS_MODE_MUSIC;\n\telse\n\t\tlevel = SNDRV_SEQ_OSS_MODE_SYNTH;\n\n\tmutex_lock(&register_mutex);\n\trc = snd_seq_oss_open(file, level);\n\tmutex_unlock(&register_mutex);\n\n\treturn rc;\n}\n\nstatic int\nodev_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = file->private_data;\n\tif (!dp)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tsnd_seq_oss_release(dp);\n\tmutex_unlock(&register_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t\nodev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct seq_oss_devinfo *dp;\n\tdp = file->private_data;\n\tif (snd_BUG_ON(!dp))\n\t\treturn -ENXIO;\n\treturn snd_seq_oss_read(dp, buf, count);\n}\n\n\nstatic ssize_t\nodev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct seq_oss_devinfo *dp;\n\tdp = file->private_data;\n\tif (snd_BUG_ON(!dp))\n\t\treturn -ENXIO;\n\treturn snd_seq_oss_write(dp, buf, count, file);\n}\n\nstatic long\nodev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct seq_oss_devinfo *dp;\n\tlong rc;\n\n\tdp = file->private_data;\n\tif (snd_BUG_ON(!dp))\n\t\treturn -ENXIO;\n\n\tif (cmd != SNDCTL_SEQ_SYNC &&\n\t    mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\trc = snd_seq_oss_ioctl(dp, cmd, arg);\n\tif (cmd != SNDCTL_SEQ_SYNC)\n\t\tmutex_unlock(&register_mutex);\n\treturn rc;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long odev_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\treturn odev_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define odev_ioctl_compat\tNULL\n#endif\n\nstatic __poll_t\nodev_poll(struct file *file, poll_table * wait)\n{\n\tstruct seq_oss_devinfo *dp;\n\tdp = file->private_data;\n\tif (snd_BUG_ON(!dp))\n\t\treturn EPOLLERR;\n\treturn snd_seq_oss_poll(dp, file, wait);\n}\n\n \n\nstatic const struct file_operations seq_oss_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\todev_read,\n\t.write =\todev_write,\n\t.open =\t\todev_open,\n\t.release =\todev_release,\n\t.poll =\t\todev_poll,\n\t.unlocked_ioctl =\todev_ioctl,\n\t.compat_ioctl =\todev_ioctl_compat,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic int __init\nregister_device(void)\n{\n\tint rc;\n\n\tmutex_lock(&register_mutex);\n\trc = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER,\n\t\t\t\t     NULL, 0,\n\t\t\t\t     &seq_oss_f_ops, NULL);\n\tif (rc < 0) {\n\t\tpr_err(\"ALSA: seq_oss: can't register device seq\\n\");\n\t\tmutex_unlock(&register_mutex);\n\t\treturn rc;\n\t}\n\trc = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MUSIC,\n\t\t\t\t     NULL, 0,\n\t\t\t\t     &seq_oss_f_ops, NULL);\n\tif (rc < 0) {\n\t\tpr_err(\"ALSA: seq_oss: can't register device music\\n\");\n\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER, NULL, 0);\n\t\tmutex_unlock(&register_mutex);\n\t\treturn rc;\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic void\nunregister_device(void)\n{\n\tmutex_lock(&register_mutex);\n\tif (snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MUSIC, NULL, 0) < 0)\t\t\n\t\tpr_err(\"ALSA: seq_oss: error unregister device music\\n\");\n\tif (snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER, NULL, 0) < 0)\n\t\tpr_err(\"ALSA: seq_oss: error unregister device seq\\n\");\n\tmutex_unlock(&register_mutex);\n}\n\n \n\n#ifdef CONFIG_SND_PROC_FS\n\nstatic struct snd_info_entry *info_entry;\n\nstatic void\ninfo_read(struct snd_info_entry *entry, struct snd_info_buffer *buf)\n{\n\tmutex_lock(&register_mutex);\n\tsnd_iprintf(buf, \"OSS sequencer emulation version %s\\n\", SNDRV_SEQ_OSS_VERSION_STR);\n\tsnd_seq_oss_system_info_read(buf);\n\tsnd_seq_oss_synth_info_read(buf);\n\tsnd_seq_oss_midi_info_read(buf);\n\tmutex_unlock(&register_mutex);\n}\n\n\nstatic int __init\nregister_proc(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, SNDRV_SEQ_OSS_PROCNAME, snd_seq_root);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\tentry->private_data = NULL;\n\tentry->c.text.read = info_read;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\treturn -ENOMEM;\n\t}\n\tinfo_entry = entry;\n\treturn 0;\n}\n\nstatic void\nunregister_proc(void)\n{\n\tsnd_info_free_entry(info_entry);\n\tinfo_entry = NULL;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}