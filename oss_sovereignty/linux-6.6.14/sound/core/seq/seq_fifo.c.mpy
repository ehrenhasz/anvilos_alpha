{
  "module_name": "seq_fifo.c",
  "hash_id": "38c305e33673d1690ba0a57b3a32a1e0ea47da52d3dbac6a3aa7f0300a0f9d44",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_fifo.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include \"seq_fifo.h\"\n#include \"seq_lock.h\"\n\n\n \n\n \nstruct snd_seq_fifo *snd_seq_fifo_new(int poolsize)\n{\n\tstruct snd_seq_fifo *f;\n\n\tf = kzalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\n\tf->pool = snd_seq_pool_new(poolsize);\n\tif (f->pool == NULL) {\n\t\tkfree(f);\n\t\treturn NULL;\n\t}\n\tif (snd_seq_pool_init(f->pool) < 0) {\n\t\tsnd_seq_pool_delete(&f->pool);\n\t\tkfree(f);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&f->lock);\n\tsnd_use_lock_init(&f->use_lock);\n\tinit_waitqueue_head(&f->input_sleep);\n\tatomic_set(&f->overflow, 0);\n\n\tf->head = NULL;\n\tf->tail = NULL;\n\tf->cells = 0;\n\t\n\treturn f;\n}\n\nvoid snd_seq_fifo_delete(struct snd_seq_fifo **fifo)\n{\n\tstruct snd_seq_fifo *f;\n\n\tif (snd_BUG_ON(!fifo))\n\t\treturn;\n\tf = *fifo;\n\tif (snd_BUG_ON(!f))\n\t\treturn;\n\t*fifo = NULL;\n\n\tif (f->pool)\n\t\tsnd_seq_pool_mark_closing(f->pool);\n\n\tsnd_seq_fifo_clear(f);\n\n\t \n\tif (waitqueue_active(&f->input_sleep))\n\t\twake_up(&f->input_sleep);\n\n\t \n\t \n\n\tif (f->pool) {\n\t\tsnd_seq_pool_done(f->pool);\n\t\tsnd_seq_pool_delete(&f->pool);\n\t}\n\t\n\tkfree(f);\n}\n\nstatic struct snd_seq_event_cell *fifo_cell_out(struct snd_seq_fifo *f);\n\n \nvoid snd_seq_fifo_clear(struct snd_seq_fifo *f)\n{\n\tstruct snd_seq_event_cell *cell;\n\n\t \n\tatomic_set(&f->overflow, 0);\n\n\tsnd_use_lock_sync(&f->use_lock);\n\tspin_lock_irq(&f->lock);\n\t \n\twhile ((cell = fifo_cell_out(f)) != NULL) {\n\t\tsnd_seq_cell_free(cell);\n\t}\n\tspin_unlock_irq(&f->lock);\n}\n\n\n \nint snd_seq_fifo_event_in(struct snd_seq_fifo *f,\n\t\t\t  struct snd_seq_event *event)\n{\n\tstruct snd_seq_event_cell *cell;\n\tunsigned long flags;\n\tint err;\n\n\tif (snd_BUG_ON(!f))\n\t\treturn -EINVAL;\n\n\tsnd_use_lock_use(&f->use_lock);\n\terr = snd_seq_event_dup(f->pool, event, &cell, 1, NULL, NULL);  \n\tif (err < 0) {\n\t\tif ((err == -ENOMEM) || (err == -EAGAIN))\n\t\t\tatomic_inc(&f->overflow);\n\t\tsnd_use_lock_free(&f->use_lock);\n\t\treturn err;\n\t}\n\t\t\n\t \n\tspin_lock_irqsave(&f->lock, flags);\n\tif (f->tail != NULL)\n\t\tf->tail->next = cell;\n\tf->tail = cell;\n\tif (f->head == NULL)\n\t\tf->head = cell;\n\tcell->next = NULL;\n\tf->cells++;\n\tspin_unlock_irqrestore(&f->lock, flags);\n\n\t \n\tif (waitqueue_active(&f->input_sleep))\n\t\twake_up(&f->input_sleep);\n\n\tsnd_use_lock_free(&f->use_lock);\n\n\treturn 0;  \n\n}\n\n \nstatic struct snd_seq_event_cell *fifo_cell_out(struct snd_seq_fifo *f)\n{\n\tstruct snd_seq_event_cell *cell;\n\n\tcell = f->head;\n\tif (cell) {\n\t\tf->head = cell->next;\n\n\t\t \n\t\tif (f->tail == cell)\n\t\t\tf->tail = NULL;\n\n\t\tcell->next = NULL;\n\t\tf->cells--;\n\t}\n\n\treturn cell;\n}\n\n \nint snd_seq_fifo_cell_out(struct snd_seq_fifo *f,\n\t\t\t  struct snd_seq_event_cell **cellp, int nonblock)\n{\n\tstruct snd_seq_event_cell *cell;\n\tunsigned long flags;\n\twait_queue_entry_t wait;\n\n\tif (snd_BUG_ON(!f))\n\t\treturn -EINVAL;\n\n\t*cellp = NULL;\n\tinit_waitqueue_entry(&wait, current);\n\tspin_lock_irqsave(&f->lock, flags);\n\twhile ((cell = fifo_cell_out(f)) == NULL) {\n\t\tif (nonblock) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&f->input_sleep, &wait);\n\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&f->lock, flags);\n\t\tremove_wait_queue(&f->input_sleep, &wait);\n\t\tif (signal_pending(current)) {\n\t\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&f->lock, flags);\n\t*cellp = cell;\n\n\treturn 0;\n}\n\n\nvoid snd_seq_fifo_cell_putback(struct snd_seq_fifo *f,\n\t\t\t       struct snd_seq_event_cell *cell)\n{\n\tunsigned long flags;\n\n\tif (cell) {\n\t\tspin_lock_irqsave(&f->lock, flags);\n\t\tcell->next = f->head;\n\t\tf->head = cell;\n\t\tif (!f->tail)\n\t\t\tf->tail = cell;\n\t\tf->cells++;\n\t\tspin_unlock_irqrestore(&f->lock, flags);\n\t}\n}\n\n\n \nint snd_seq_fifo_poll_wait(struct snd_seq_fifo *f, struct file *file,\n\t\t\t   poll_table *wait)\n{\n\tpoll_wait(file, &f->input_sleep, wait);\n\treturn (f->cells > 0);\n}\n\n \nint snd_seq_fifo_resize(struct snd_seq_fifo *f, int poolsize)\n{\n\tstruct snd_seq_pool *newpool, *oldpool;\n\tstruct snd_seq_event_cell *cell, *next, *oldhead;\n\n\tif (snd_BUG_ON(!f || !f->pool))\n\t\treturn -EINVAL;\n\n\t \n\tnewpool = snd_seq_pool_new(poolsize);\n\tif (newpool == NULL)\n\t\treturn -ENOMEM;\n\tif (snd_seq_pool_init(newpool) < 0) {\n\t\tsnd_seq_pool_delete(&newpool);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irq(&f->lock);\n\t \n\toldpool = f->pool;\n\toldhead = f->head;\n\t \n\tf->pool = newpool;\n\tf->head = NULL;\n\tf->tail = NULL;\n\tf->cells = 0;\n\t \n\tspin_unlock_irq(&f->lock);\n\n\t \n\tsnd_seq_pool_mark_closing(oldpool);\n\tsnd_use_lock_sync(&f->use_lock);\n\n\t \n\tfor (cell = oldhead; cell; cell = next) {\n\t\tnext = cell->next;\n\t\tsnd_seq_cell_free(cell);\n\t}\n\tsnd_seq_pool_delete(&oldpool);\n\n\treturn 0;\n}\n\n \nint snd_seq_fifo_unused_cells(struct snd_seq_fifo *f)\n{\n\tunsigned long flags;\n\tint cells;\n\n\tif (!f)\n\t\treturn 0;\n\n\tsnd_use_lock_use(&f->use_lock);\n\tspin_lock_irqsave(&f->lock, flags);\n\tcells = snd_seq_unused_cells(f->pool);\n\tspin_unlock_irqrestore(&f->lock, flags);\n\tsnd_use_lock_free(&f->use_lock);\n\treturn cells;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}