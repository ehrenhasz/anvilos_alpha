{
  "module_name": "seq_timer.c",
  "hash_id": "391b50bdc345684b5f24fda3ebb1d2d82f343def67aa61fabb574955a0e47457",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_timer.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <linux/slab.h>\n#include \"seq_timer.h\"\n#include \"seq_queue.h\"\n#include \"seq_info.h\"\n\n \n#define MIN_FREQUENCY\t\t10\n#define MAX_FREQUENCY\t\t6250\n#define DEFAULT_FREQUENCY\t1000\n\n#define SKEW_BASE\t0x10000\t \n\nstatic void snd_seq_timer_set_tick_resolution(struct snd_seq_timer *tmr)\n{\n\tif (tmr->tempo < 1000000)\n\t\ttmr->tick.resolution = (tmr->tempo * 1000) / tmr->ppq;\n\telse {\n\t\t \n\t\tunsigned int s;\n\t\ts = tmr->tempo % tmr->ppq;\n\t\ts = (s * 1000) / tmr->ppq;\n\t\ttmr->tick.resolution = (tmr->tempo / tmr->ppq) * 1000;\n\t\ttmr->tick.resolution += s;\n\t}\n\tif (tmr->tick.resolution <= 0)\n\t\ttmr->tick.resolution = 1;\n\tsnd_seq_timer_update_tick(&tmr->tick, 0);\n}\n\n \nstruct snd_seq_timer *snd_seq_timer_new(void)\n{\n\tstruct snd_seq_timer *tmr;\n\t\n\ttmr = kzalloc(sizeof(*tmr), GFP_KERNEL);\n\tif (!tmr)\n\t\treturn NULL;\n\tspin_lock_init(&tmr->lock);\n\n\t \n\tsnd_seq_timer_defaults(tmr);\n\t\n\t \n\tsnd_seq_timer_reset(tmr);\n\t\n\treturn tmr;\n}\n\n \nvoid snd_seq_timer_delete(struct snd_seq_timer **tmr)\n{\n\tstruct snd_seq_timer *t = *tmr;\n\t*tmr = NULL;\n\n\tif (t == NULL) {\n\t\tpr_debug(\"ALSA: seq: snd_seq_timer_delete() called with NULL timer\\n\");\n\t\treturn;\n\t}\n\tt->running = 0;\n\n\t \n\tsnd_seq_timer_stop(t);\n\tsnd_seq_timer_reset(t);\n\n\tkfree(t);\n}\n\nvoid snd_seq_timer_defaults(struct snd_seq_timer * tmr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\t \n\ttmr->ppq = 96;\t\t \n\ttmr->tempo = 500000;\t \n\tsnd_seq_timer_set_tick_resolution(tmr);\n\ttmr->running = 0;\n\n\ttmr->type = SNDRV_SEQ_TIMER_ALSA;\n\ttmr->alsa_id.dev_class = seq_default_timer_class;\n\ttmr->alsa_id.dev_sclass = seq_default_timer_sclass;\n\ttmr->alsa_id.card = seq_default_timer_card;\n\ttmr->alsa_id.device = seq_default_timer_device;\n\ttmr->alsa_id.subdevice = seq_default_timer_subdevice;\n\ttmr->preferred_resolution = seq_default_timer_resolution;\n\n\ttmr->skew = tmr->skew_base = SKEW_BASE;\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n}\n\nstatic void seq_timer_reset(struct snd_seq_timer *tmr)\n{\n\t \n\ttmr->cur_time.tv_sec = 0;\n\ttmr->cur_time.tv_nsec = 0;\n\n\ttmr->tick.cur_tick = 0;\n\ttmr->tick.fraction = 0;\n}\n\nvoid snd_seq_timer_reset(struct snd_seq_timer *tmr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tseq_timer_reset(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n}\n\n\n \nstatic void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t    unsigned long resolution,\n\t\t\t\t    unsigned long ticks)\n{\n\tunsigned long flags;\n\tstruct snd_seq_queue *q = timeri->callback_data;\n\tstruct snd_seq_timer *tmr;\n\n\tif (q == NULL)\n\t\treturn;\n\ttmr = q->timer;\n\tif (tmr == NULL)\n\t\treturn;\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tif (!tmr->running) {\n\t\tspin_unlock_irqrestore(&tmr->lock, flags);\n\t\treturn;\n\t}\n\n\tresolution *= ticks;\n\tif (tmr->skew != tmr->skew_base) {\n\t\t \n\t\tresolution = (resolution >> 16) * tmr->skew +\n\t\t\t(((resolution & 0xffff) * tmr->skew) >> 16);\n\t}\n\n\t \n\tsnd_seq_inc_time_nsec(&tmr->cur_time, resolution);\n\n\t \n\tsnd_seq_timer_update_tick(&tmr->tick, resolution);\n\n\t \n\tktime_get_ts64(&tmr->last_update);\n\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\n\t \n\tsnd_seq_check_queue(q, 1, 0);\n}\n\n \nint snd_seq_timer_set_tempo(struct snd_seq_timer * tmr, int tempo)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\tif (tempo <= 0)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tif ((unsigned int)tempo != tmr->tempo) {\n\t\ttmr->tempo = tempo;\n\t\tsnd_seq_timer_set_tick_resolution(tmr);\n\t}\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn 0;\n}\n\n \nint snd_seq_timer_set_tempo_ppq(struct snd_seq_timer *tmr, int tempo, int ppq)\n{\n\tint changed;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\tif (tempo <= 0 || ppq <= 0)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tif (tmr->running && (ppq != tmr->ppq)) {\n\t\t \n\t\t \n\t\tspin_unlock_irqrestore(&tmr->lock, flags);\n\t\tpr_debug(\"ALSA: seq: cannot change ppq of a running timer\\n\");\n\t\treturn -EBUSY;\n\t}\n\tchanged = (tempo != tmr->tempo) || (ppq != tmr->ppq);\n\ttmr->tempo = tempo;\n\ttmr->ppq = ppq;\n\tif (changed)\n\t\tsnd_seq_timer_set_tick_resolution(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn 0;\n}\n\n \nint snd_seq_timer_set_position_tick(struct snd_seq_timer *tmr,\n\t\t\t\t    snd_seq_tick_time_t position)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\ttmr->tick.cur_tick = position;\n\ttmr->tick.fraction = 0;\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn 0;\n}\n\n \nint snd_seq_timer_set_position_time(struct snd_seq_timer *tmr,\n\t\t\t\t    snd_seq_real_time_t position)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\n\tsnd_seq_sanity_real_time(&position);\n\tspin_lock_irqsave(&tmr->lock, flags);\n\ttmr->cur_time = position;\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn 0;\n}\n\n \nint snd_seq_timer_set_skew(struct snd_seq_timer *tmr, unsigned int skew,\n\t\t\t   unsigned int base)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\n\t \n\tif (base != SKEW_BASE) {\n\t\tpr_debug(\"ALSA: seq: invalid skew base 0x%x\\n\", base);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(&tmr->lock, flags);\n\ttmr->skew = skew;\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn 0;\n}\n\nint snd_seq_timer_open(struct snd_seq_queue *q)\n{\n\tstruct snd_timer_instance *t;\n\tstruct snd_seq_timer *tmr;\n\tchar str[32];\n\tint err;\n\n\ttmr = q->timer;\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\tif (tmr->timeri)\n\t\treturn -EBUSY;\n\tsprintf(str, \"sequencer queue %i\", q->queue);\n\tif (tmr->type != SNDRV_SEQ_TIMER_ALSA)\t \n\t\treturn -EINVAL;\n\tif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttmr->alsa_id.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\n\tt = snd_timer_instance_new(str);\n\tif (!t)\n\t\treturn -ENOMEM;\n\tt->callback = snd_seq_timer_interrupt;\n\tt->callback_data = q;\n\tt->flags |= SNDRV_TIMER_IFLG_AUTO;\n\terr = snd_timer_open(t, &tmr->alsa_id, q->queue);\n\tif (err < 0 && tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE) {\n\t\tif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_GLOBAL ||\n\t\t    tmr->alsa_id.device != SNDRV_TIMER_GLOBAL_SYSTEM) {\n\t\t\tstruct snd_timer_id tid;\n\t\t\tmemset(&tid, 0, sizeof(tid));\n\t\t\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\t\t\ttid.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\n\t\t\ttid.card = -1;\n\t\t\ttid.device = SNDRV_TIMER_GLOBAL_SYSTEM;\n\t\t\terr = snd_timer_open(t, &tid, q->queue);\n\t\t}\n\t}\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: seq fatal error: cannot create timer (%i)\\n\", err);\n\t\tsnd_timer_instance_free(t);\n\t\treturn err;\n\t}\n\tspin_lock_irq(&tmr->lock);\n\tif (tmr->timeri)\n\t\terr = -EBUSY;\n\telse\n\t\ttmr->timeri = t;\n\tspin_unlock_irq(&tmr->lock);\n\tif (err < 0) {\n\t\tsnd_timer_close(t);\n\t\tsnd_timer_instance_free(t);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint snd_seq_timer_close(struct snd_seq_queue *q)\n{\n\tstruct snd_seq_timer *tmr;\n\tstruct snd_timer_instance *t;\n\t\n\ttmr = q->timer;\n\tif (snd_BUG_ON(!tmr))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&tmr->lock);\n\tt = tmr->timeri;\n\ttmr->timeri = NULL;\n\tspin_unlock_irq(&tmr->lock);\n\tif (t) {\n\t\tsnd_timer_close(t);\n\t\tsnd_timer_instance_free(t);\n\t}\n\treturn 0;\n}\n\nstatic int seq_timer_stop(struct snd_seq_timer *tmr)\n{\n\tif (! tmr->timeri)\n\t\treturn -EINVAL;\n\tif (!tmr->running)\n\t\treturn 0;\n\ttmr->running = 0;\n\tsnd_timer_pause(tmr->timeri);\n\treturn 0;\n}\n\nint snd_seq_timer_stop(struct snd_seq_timer *tmr)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\terr = seq_timer_stop(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn err;\n}\n\nstatic int initialize_timer(struct snd_seq_timer *tmr)\n{\n\tstruct snd_timer *t;\n\tunsigned long freq;\n\n\tt = tmr->timeri->timer;\n\tif (!t)\n\t\treturn -EINVAL;\n\n\tfreq = tmr->preferred_resolution;\n\tif (!freq)\n\t\tfreq = DEFAULT_FREQUENCY;\n\telse if (freq < MIN_FREQUENCY)\n\t\tfreq = MIN_FREQUENCY;\n\telse if (freq > MAX_FREQUENCY)\n\t\tfreq = MAX_FREQUENCY;\n\n\ttmr->ticks = 1;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {\n\t\tunsigned long r = snd_timer_resolution(tmr->timeri);\n\t\tif (r) {\n\t\t\ttmr->ticks = (unsigned int)(1000000000uL / (r * freq));\n\t\t\tif (! tmr->ticks)\n\t\t\t\ttmr->ticks = 1;\n\t\t}\n\t}\n\ttmr->initialized = 1;\n\treturn 0;\n}\n\nstatic int seq_timer_start(struct snd_seq_timer *tmr)\n{\n\tif (! tmr->timeri)\n\t\treturn -EINVAL;\n\tif (tmr->running)\n\t\tseq_timer_stop(tmr);\n\tseq_timer_reset(tmr);\n\tif (initialize_timer(tmr) < 0)\n\t\treturn -EINVAL;\n\tsnd_timer_start(tmr->timeri, tmr->ticks);\n\ttmr->running = 1;\n\tktime_get_ts64(&tmr->last_update);\n\treturn 0;\n}\n\nint snd_seq_timer_start(struct snd_seq_timer *tmr)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\terr = seq_timer_start(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn err;\n}\n\nstatic int seq_timer_continue(struct snd_seq_timer *tmr)\n{\n\tif (! tmr->timeri)\n\t\treturn -EINVAL;\n\tif (tmr->running)\n\t\treturn -EBUSY;\n\tif (! tmr->initialized) {\n\t\tseq_timer_reset(tmr);\n\t\tif (initialize_timer(tmr) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\tsnd_timer_start(tmr->timeri, tmr->ticks);\n\ttmr->running = 1;\n\tktime_get_ts64(&tmr->last_update);\n\treturn 0;\n}\n\nint snd_seq_timer_continue(struct snd_seq_timer *tmr)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\terr = seq_timer_continue(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn err;\n}\n\n \nsnd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr,\n\t\t\t\t\t       bool adjust_ktime)\n{\n\tsnd_seq_real_time_t cur_time;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tcur_time = tmr->cur_time;\n\tif (adjust_ktime && tmr->running) {\n\t\tstruct timespec64 tm;\n\n\t\tktime_get_ts64(&tm);\n\t\ttm = timespec64_sub(tm, tmr->last_update);\n\t\tcur_time.tv_nsec += tm.tv_nsec;\n\t\tcur_time.tv_sec += tm.tv_sec;\n\t\tsnd_seq_sanity_real_time(&cur_time);\n\t}\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn cur_time;\t\n}\n\n \nsnd_seq_tick_time_t snd_seq_timer_get_cur_tick(struct snd_seq_timer *tmr)\n{\n\tsnd_seq_tick_time_t cur_tick;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tmr->lock, flags);\n\tcur_tick = tmr->tick.cur_tick;\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\treturn cur_tick;\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\n \nvoid snd_seq_info_timer_read(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tint idx;\n\tstruct snd_seq_queue *q;\n\tstruct snd_seq_timer *tmr;\n\tstruct snd_timer_instance *ti;\n\tunsigned long resolution;\n\t\n\tfor (idx = 0; idx < SNDRV_SEQ_MAX_QUEUES; idx++) {\n\t\tq = queueptr(idx);\n\t\tif (q == NULL)\n\t\t\tcontinue;\n\t\tmutex_lock(&q->timer_mutex);\n\t\ttmr = q->timer;\n\t\tif (!tmr)\n\t\t\tgoto unlock;\n\t\tti = tmr->timeri;\n\t\tif (!ti)\n\t\t\tgoto unlock;\n\t\tsnd_iprintf(buffer, \"Timer for queue %i : %s\\n\", q->queue, ti->timer->name);\n\t\tresolution = snd_timer_resolution(ti) * tmr->ticks;\n\t\tsnd_iprintf(buffer, \"  Period time : %lu.%09lu\\n\", resolution / 1000000000, resolution % 1000000000);\n\t\tsnd_iprintf(buffer, \"  Skew : %u / %u\\n\", tmr->skew, tmr->skew_base);\nunlock:\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n \t}\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}