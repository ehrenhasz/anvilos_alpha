{
  "module_name": "seq_midi.c",
  "hash_id": "41a49c3a180c26d83341275aa6f254d8ac42be8efd7a127d8d08efab6afe9112",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_midi.c",
  "human_readable_source": "\n \n \n \n\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/rawmidi.h>\n#include <sound/seq_kernel.h>\n#include <sound/seq_device.h>\n#include <sound/seq_midi_event.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Frank van de Pol <fvdpol@coil.demon.nl>, Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Advanced Linux Sound Architecture sequencer MIDI synth.\");\nMODULE_LICENSE(\"GPL\");\nstatic int output_buffer_size = PAGE_SIZE;\nmodule_param(output_buffer_size, int, 0644);\nMODULE_PARM_DESC(output_buffer_size, \"Output buffer size in bytes.\");\nstatic int input_buffer_size = PAGE_SIZE;\nmodule_param(input_buffer_size, int, 0644);\nMODULE_PARM_DESC(input_buffer_size, \"Input buffer size in bytes.\");\n\n \nstruct seq_midisynth {\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tint device;\n\tint subdevice;\n\tstruct snd_rawmidi_file input_rfile;\n\tstruct snd_rawmidi_file output_rfile;\n\tint seq_client;\n\tint seq_port;\n\tstruct snd_midi_event *parser;\n};\n\nstruct seq_midisynth_client {\n\tint seq_client;\n\tint num_ports;\n\tint ports_per_device[SNDRV_RAWMIDI_DEVICES];\n \tstruct seq_midisynth *ports[SNDRV_RAWMIDI_DEVICES];\n};\n\nstatic struct seq_midisynth_client *synths[SNDRV_CARDS];\nstatic DEFINE_MUTEX(register_mutex);\n\n \nstatic void snd_midi_input_event(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_rawmidi_runtime *runtime;\n\tstruct seq_midisynth *msynth;\n\tstruct snd_seq_event ev;\n\tchar buf[16], *pbuf;\n\tlong res;\n\n\tif (substream == NULL)\n\t\treturn;\n\truntime = substream->runtime;\n\tmsynth = runtime->private_data;\n\tif (msynth == NULL)\n\t\treturn;\n\tmemset(&ev, 0, sizeof(ev));\n\twhile (runtime->avail > 0) {\n\t\tres = snd_rawmidi_kernel_read(substream, buf, sizeof(buf));\n\t\tif (res <= 0)\n\t\t\tcontinue;\n\t\tif (msynth->parser == NULL)\n\t\t\tcontinue;\n\t\tpbuf = buf;\n\t\twhile (res-- > 0) {\n\t\t\tif (!snd_midi_event_encode_byte(msynth->parser,\n\t\t\t\t\t\t\t*pbuf++, &ev))\n\t\t\t\tcontinue;\n\t\t\tev.source.port = msynth->seq_port;\n\t\t\tev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\t\tsnd_seq_kernel_client_dispatch(msynth->seq_client, &ev, 1, 0);\n\t\t\t \n\t\t\tmemset(&ev, 0, sizeof(ev));\n\t\t}\n\t}\n}\n\nstatic int dump_midi(struct snd_rawmidi_substream *substream, const char *buf, int count)\n{\n\tstruct snd_rawmidi_runtime *runtime;\n\tint tmp;\n\n\tif (snd_BUG_ON(!substream || !buf))\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\ttmp = runtime->avail;\n\tif (tmp < count) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"ALSA: seq_midi: MIDI output buffer overrun\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (snd_rawmidi_kernel_write(substream, buf, count) < count)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int event_process_midi(struct snd_seq_event *ev, int direct,\n\t\t\t      void *private_data, int atomic, int hop)\n{\n\tstruct seq_midisynth *msynth = private_data;\n\tunsigned char msg[10];\t \n\tstruct snd_rawmidi_substream *substream;\n\tint len;\n\n\tif (snd_BUG_ON(!msynth))\n\t\treturn -EINVAL;\n\tsubstream = msynth->output_rfile.output;\n\tif (substream == NULL)\n\t\treturn -ENODEV;\n\tif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\t \n\t\tif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE) {\n\t\t\t \n\t\t\tpr_debug(\"ALSA: seq_midi: invalid sysex event flags = 0x%x\\n\", ev->flags);\n\t\t\treturn 0;\n\t\t}\n\t\tsnd_seq_dump_var_event(ev, (snd_seq_dump_func_t)dump_midi, substream);\n\t\tsnd_midi_event_reset_decode(msynth->parser);\n\t} else {\n\t\tif (msynth->parser == NULL)\n\t\t\treturn -EIO;\n\t\tlen = snd_midi_event_decode(msynth->parser, msg, sizeof(msg), ev);\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (dump_midi(substream, msg, len) < 0)\n\t\t\tsnd_midi_event_reset_decode(msynth->parser);\n\t}\n\treturn 0;\n}\n\n\nstatic int snd_seq_midisynth_new(struct seq_midisynth *msynth,\n\t\t\t\t struct snd_card *card,\n\t\t\t\t int device,\n\t\t\t\t int subdevice)\n{\n\tif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &msynth->parser) < 0)\n\t\treturn -ENOMEM;\n\tmsynth->card = card;\n\tmsynth->device = device;\n\tmsynth->subdevice = subdevice;\n\treturn 0;\n}\n\n \nstatic int midisynth_subscribe(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tint err;\n\tstruct seq_midisynth *msynth = private_data;\n\tstruct snd_rawmidi_runtime *runtime;\n\tstruct snd_rawmidi_params params;\n\n\t \n\terr = snd_rawmidi_kernel_open(msynth->rmidi, msynth->subdevice,\n\t\t\t\t      SNDRV_RAWMIDI_LFLG_INPUT,\n\t\t\t\t      &msynth->input_rfile);\n\tif (err < 0) {\n\t\tpr_debug(\"ALSA: seq_midi: midi input open failed!!!\\n\");\n\t\treturn err;\n\t}\n\truntime = msynth->input_rfile.input->runtime;\n\tmemset(&params, 0, sizeof(params));\n\tparams.avail_min = 1;\n\tparams.buffer_size = input_buffer_size;\n\terr = snd_rawmidi_input_params(msynth->input_rfile.input, &params);\n\tif (err < 0) {\n\t\tsnd_rawmidi_kernel_release(&msynth->input_rfile);\n\t\treturn err;\n\t}\n\tsnd_midi_event_reset_encode(msynth->parser);\n\truntime->event = snd_midi_input_event;\n\truntime->private_data = msynth;\n\tsnd_rawmidi_kernel_read(msynth->input_rfile.input, NULL, 0);\n\treturn 0;\n}\n\n \nstatic int midisynth_unsubscribe(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tint err;\n\tstruct seq_midisynth *msynth = private_data;\n\n\tif (snd_BUG_ON(!msynth->input_rfile.input))\n\t\treturn -EINVAL;\n\terr = snd_rawmidi_kernel_release(&msynth->input_rfile);\n\treturn err;\n}\n\n \nstatic int midisynth_use(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tint err;\n\tstruct seq_midisynth *msynth = private_data;\n\tstruct snd_rawmidi_params params;\n\n\t \n\terr = snd_rawmidi_kernel_open(msynth->rmidi, msynth->subdevice,\n\t\t\t\t      SNDRV_RAWMIDI_LFLG_OUTPUT,\n\t\t\t\t      &msynth->output_rfile);\n\tif (err < 0) {\n\t\tpr_debug(\"ALSA: seq_midi: midi output open failed!!!\\n\");\n\t\treturn err;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tparams.avail_min = 1;\n\tparams.buffer_size = output_buffer_size;\n\tparams.no_active_sensing = 1;\n\terr = snd_rawmidi_output_params(msynth->output_rfile.output, &params);\n\tif (err < 0) {\n\t\tsnd_rawmidi_kernel_release(&msynth->output_rfile);\n\t\treturn err;\n\t}\n\tsnd_midi_event_reset_decode(msynth->parser);\n\treturn 0;\n}\n\n \nstatic int midisynth_unuse(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tstruct seq_midisynth *msynth = private_data;\n\n\tif (snd_BUG_ON(!msynth->output_rfile.output))\n\t\treturn -EINVAL;\n\tsnd_rawmidi_drain_output(msynth->output_rfile.output);\n\treturn snd_rawmidi_kernel_release(&msynth->output_rfile);\n}\n\n \nstatic void snd_seq_midisynth_delete(struct seq_midisynth *msynth)\n{\n\tif (msynth == NULL)\n\t\treturn;\n\n\tif (msynth->seq_client > 0) {\n\t\t \n\t\tsnd_seq_event_port_detach(msynth->seq_client, msynth->seq_port);\n\t}\n\n\tsnd_midi_event_free(msynth->parser);\n}\n\n \nstatic int\nsnd_seq_midisynth_probe(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct seq_midisynth_client *client;\n\tstruct seq_midisynth *msynth, *ms;\n\tstruct snd_seq_port_info *port;\n\tstruct snd_rawmidi_info *info;\n\tstruct snd_rawmidi *rmidi = dev->private_data;\n\tint newclient = 0;\n\tunsigned int p, ports;\n\tstruct snd_seq_port_callback pcallbacks;\n\tstruct snd_card *card = dev->card;\n\tint device = dev->device;\n\tunsigned int input_count = 0, output_count = 0;\n\n\tif (snd_BUG_ON(!card || device < 0 || device >= SNDRV_RAWMIDI_DEVICES))\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->device = device;\n\tinfo->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\n\tinfo->subdevice = 0;\n\tif (snd_rawmidi_info_select(card, info) >= 0)\n\t\toutput_count = info->subdevices_count;\n\tinfo->stream = SNDRV_RAWMIDI_STREAM_INPUT;\n\tif (snd_rawmidi_info_select(card, info) >= 0) {\n\t\tinput_count = info->subdevices_count;\n\t}\n\tports = output_count;\n\tif (ports < input_count)\n\t\tports = input_count;\n\tif (ports == 0) {\n\t\tkfree(info);\n\t\treturn -ENODEV;\n\t}\n\tif (ports > (256 / SNDRV_RAWMIDI_DEVICES))\n\t\tports = 256 / SNDRV_RAWMIDI_DEVICES;\n\n\tmutex_lock(&register_mutex);\n\tclient = synths[card->number];\n\tif (client == NULL) {\n\t\tnewclient = 1;\n\t\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\t\tif (client == NULL) {\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tkfree(info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tclient->seq_client =\n\t\t\tsnd_seq_create_kernel_client(\n\t\t\t\tcard, 0, \"%s\", card->shortname[0] ?\n\t\t\t\t(const char *)card->shortname : \"External MIDI\");\n\t\tif (client->seq_client < 0) {\n\t\t\tkfree(client);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tkfree(info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmsynth = kcalloc(ports, sizeof(struct seq_midisynth), GFP_KERNEL);\n\tport = kmalloc(sizeof(*port), GFP_KERNEL);\n\tif (msynth == NULL || port == NULL)\n\t\tgoto __nomem;\n\n\tfor (p = 0; p < ports; p++) {\n\t\tms = &msynth[p];\n\t\tms->rmidi = rmidi;\n\n\t\tif (snd_seq_midisynth_new(ms, card, device, p) < 0)\n\t\t\tgoto __nomem;\n\n\t\t \n\t\tmemset(port, 0, sizeof(*port));\n\t\tport->addr.client = client->seq_client;\n\t\tport->addr.port = device * (256 / SNDRV_RAWMIDI_DEVICES) + p;\n\t\tport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->device = device;\n\t\tif (p < output_count)\n\t\t\tinfo->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\n\t\telse\n\t\t\tinfo->stream = SNDRV_RAWMIDI_STREAM_INPUT;\n\t\tinfo->subdevice = p;\n\t\tif (snd_rawmidi_info_select(card, info) >= 0)\n\t\t\tstrcpy(port->name, info->subname);\n\t\tif (! port->name[0]) {\n\t\t\tif (info->name[0]) {\n\t\t\t\tif (ports > 1)\n\t\t\t\t\tscnprintf(port->name, sizeof(port->name), \"%s-%u\", info->name, p);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(port->name, sizeof(port->name), \"%s\", info->name);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ports > 1)\n\t\t\t\t\tsprintf(port->name, \"MIDI %d-%d-%u\", card->number, device, p);\n\t\t\t\telse\n\t\t\t\t\tsprintf(port->name, \"MIDI %d-%d\", card->number, device);\n\t\t\t}\n\t\t}\n\t\tif ((info->flags & SNDRV_RAWMIDI_INFO_OUTPUT) && p < output_count)\n\t\t\tport->capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SYNC_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\t\tif ((info->flags & SNDRV_RAWMIDI_INFO_INPUT) && p < input_count)\n\t\t\tport->capability |= SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SYNC_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\n\t\tif ((port->capability & (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_READ)) == (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_READ) &&\n\t\t    info->flags & SNDRV_RAWMIDI_INFO_DUPLEX)\n\t\t\tport->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\n\t\tif (port->capability & SNDRV_SEQ_PORT_CAP_READ)\n\t\t\tport->direction |= SNDRV_SEQ_PORT_DIR_INPUT;\n\t\tif (port->capability & SNDRV_SEQ_PORT_CAP_WRITE)\n\t\t\tport->direction |= SNDRV_SEQ_PORT_DIR_OUTPUT;\n\t\tport->type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\n\t\t\t| SNDRV_SEQ_PORT_TYPE_HARDWARE\n\t\t\t| SNDRV_SEQ_PORT_TYPE_PORT;\n\t\tport->midi_channels = 16;\n\t\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\t\tpcallbacks.owner = THIS_MODULE;\n\t\tpcallbacks.private_data = ms;\n\t\tpcallbacks.subscribe = midisynth_subscribe;\n\t\tpcallbacks.unsubscribe = midisynth_unsubscribe;\n\t\tpcallbacks.use = midisynth_use;\n\t\tpcallbacks.unuse = midisynth_unuse;\n\t\tpcallbacks.event_input = event_process_midi;\n\t\tport->kernel = &pcallbacks;\n\t\tif (rmidi->ops && rmidi->ops->get_port_info)\n\t\t\trmidi->ops->get_port_info(rmidi, p, port);\n\t\tif (snd_seq_kernel_client_ctl(client->seq_client, SNDRV_SEQ_IOCTL_CREATE_PORT, port)<0)\n\t\t\tgoto __nomem;\n\t\tms->seq_client = client->seq_client;\n\t\tms->seq_port = port->addr.port;\n\t}\n\tclient->ports_per_device[device] = ports;\n\tclient->ports[device] = msynth;\n\tclient->num_ports++;\n\tif (newclient)\n\t\tsynths[card->number] = client;\n\tmutex_unlock(&register_mutex);\n\tkfree(info);\n\tkfree(port);\n\treturn 0;\t \n\n      __nomem:\n\tif (msynth != NULL) {\n\t      \tfor (p = 0; p < ports; p++)\n\t      \t\tsnd_seq_midisynth_delete(&msynth[p]);\n\t\tkfree(msynth);\n\t}\n\tif (newclient) {\n\t\tsnd_seq_delete_kernel_client(client->seq_client);\n\t\tkfree(client);\n\t}\n\tkfree(info);\n\tkfree(port);\n\tmutex_unlock(&register_mutex);\n\treturn -ENOMEM;\n}\n\n \nstatic int\nsnd_seq_midisynth_remove(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct seq_midisynth_client *client;\n\tstruct seq_midisynth *msynth;\n\tstruct snd_card *card = dev->card;\n\tint device = dev->device, p, ports;\n\t\n\tmutex_lock(&register_mutex);\n\tclient = synths[card->number];\n\tif (client == NULL || client->ports[device] == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENODEV;\n\t}\n\tports = client->ports_per_device[device];\n\tclient->ports_per_device[device] = 0;\n\tmsynth = client->ports[device];\n\tclient->ports[device] = NULL;\n\tfor (p = 0; p < ports; p++)\n\t\tsnd_seq_midisynth_delete(&msynth[p]);\n\tkfree(msynth);\n\tclient->num_ports--;\n\tif (client->num_ports <= 0) {\n\t\tsnd_seq_delete_kernel_client(client->seq_client);\n\t\tsynths[card->number] = NULL;\n\t\tkfree(client);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic struct snd_seq_driver seq_midisynth_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.probe = snd_seq_midisynth_probe,\n\t\t.remove = snd_seq_midisynth_remove,\n\t},\n\t.id = SNDRV_SEQ_DEV_ID_MIDISYNTH,\n\t.argsize = 0,\n};\n\nmodule_snd_seq_driver(seq_midisynth_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}