{
  "module_name": "seq_dummy.c",
  "hash_id": "3fddf5b8fa68f29b7910274856c2e8c62fe5a451bd49f613f1bf1874454f4e57",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_dummy.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include \"seq_clientmgr.h\"\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n\n \n\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA sequencer MIDI-through client\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"snd-seq-client-\" __stringify(SNDRV_SEQ_CLIENT_DUMMY));\n\nstatic int ports = 1;\nstatic bool duplex;\n\nmodule_param(ports, int, 0444);\nMODULE_PARM_DESC(ports, \"number of ports to be created\");\nmodule_param(duplex, bool, 0444);\nMODULE_PARM_DESC(duplex, \"create DUPLEX ports\");\n\nstruct snd_seq_dummy_port {\n\tint client;\n\tint port;\n\tint duplex;\n\tint connect;\n};\n\nstatic int my_client = -1;\n\n \nstatic int\ndummy_input(struct snd_seq_event *ev, int direct, void *private_data,\n\t    int atomic, int hop)\n{\n\tstruct snd_seq_dummy_port *p;\n\tstruct snd_seq_event tmpev;\n\n\tp = private_data;\n\tif (ev->source.client == SNDRV_SEQ_CLIENT_SYSTEM ||\n\t    ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\n\t\treturn 0;  \n\ttmpev = *ev;\n\tif (p->duplex)\n\t\ttmpev.source.port = p->connect;\n\telse\n\t\ttmpev.source.port = p->port;\n\ttmpev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\treturn snd_seq_kernel_client_dispatch(p->client, &tmpev, atomic, hop);\n}\n\n \nstatic void\ndummy_free(void *private_data)\n{\n\tkfree(private_data);\n}\n\n \nstatic struct snd_seq_dummy_port __init *\ncreate_port(int idx, int type)\n{\n\tstruct snd_seq_port_info pinfo;\n\tstruct snd_seq_port_callback pcb;\n\tstruct snd_seq_dummy_port *rec;\n\n\trec = kzalloc(sizeof(*rec), GFP_KERNEL);\n\tif (!rec)\n\t\treturn NULL;\n\n\trec->client = my_client;\n\trec->duplex = duplex;\n\trec->connect = 0;\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\tpinfo.addr.client = my_client;\n\tif (duplex)\n\t\tsprintf(pinfo.name, \"Midi Through Port-%d:%c\", idx,\n\t\t\t(type ? 'B' : 'A'));\n\telse\n\t\tsprintf(pinfo.name, \"Midi Through Port-%d\", idx);\n\tpinfo.capability = SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\n\tpinfo.capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\tif (duplex)\n\t\tpinfo.capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\n\tpinfo.direction = SNDRV_SEQ_PORT_DIR_BIDIRECTION;\n\tpinfo.type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\n\t\t| SNDRV_SEQ_PORT_TYPE_SOFTWARE\n\t\t| SNDRV_SEQ_PORT_TYPE_PORT;\n\tmemset(&pcb, 0, sizeof(pcb));\n\tpcb.owner = THIS_MODULE;\n\tpcb.event_input = dummy_input;\n\tpcb.private_free = dummy_free;\n\tpcb.private_data = rec;\n\tpinfo.kernel = &pcb;\n\tif (snd_seq_kernel_client_ctl(my_client, SNDRV_SEQ_IOCTL_CREATE_PORT, &pinfo) < 0) {\n\t\tkfree(rec);\n\t\treturn NULL;\n\t}\n\trec->port = pinfo.addr.port;\n\treturn rec;\n}\n\n \nstatic int __init\nregister_client(void)\n{\n\tstruct snd_seq_dummy_port *rec1, *rec2;\n\tstruct snd_seq_client *client;\n\tint i;\n\n\tif (ports < 1) {\n\t\tpr_err(\"ALSA: seq_dummy: invalid number of ports %d\\n\", ports);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmy_client = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_DUMMY,\n\t\t\t\t\t\t \"Midi Through\");\n\tif (my_client < 0)\n\t\treturn my_client;\n\n\t \n\tclient = snd_seq_kernel_client_get(my_client);\n\tif (!client)\n\t\treturn -EINVAL;\n\tclient->filter = SNDRV_SEQ_FILTER_NO_CONVERT;\n\tsnd_seq_kernel_client_put(client);\n\n\t \n\tfor (i = 0; i < ports; i++) {\n\t\trec1 = create_port(i, 0);\n\t\tif (rec1 == NULL) {\n\t\t\tsnd_seq_delete_kernel_client(my_client);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (duplex) {\n\t\t\trec2 = create_port(i, 1);\n\t\t\tif (rec2 == NULL) {\n\t\t\t\tsnd_seq_delete_kernel_client(my_client);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trec1->connect = rec2->port;\n\t\t\trec2->connect = rec1->port;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __exit\ndelete_client(void)\n{\n\tif (my_client >= 0)\n\t\tsnd_seq_delete_kernel_client(my_client);\n}\n\n \n\nstatic int __init alsa_seq_dummy_init(void)\n{\n\treturn register_client();\n}\n\nstatic void __exit alsa_seq_dummy_exit(void)\n{\n\tdelete_client();\n}\n\nmodule_init(alsa_seq_dummy_init)\nmodule_exit(alsa_seq_dummy_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}