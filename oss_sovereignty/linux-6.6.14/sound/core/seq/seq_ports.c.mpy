{
  "module_name": "seq_ports.c",
  "hash_id": "d0b82435358cc14d89bc5893a795b28b368af77ba5092161eb214e9568683262",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_ports.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"seq_system.h\"\n#include \"seq_ports.h\"\n#include \"seq_clientmgr.h\"\n\n \n\n\n \n\n \nstruct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client,\n\t\t\t\t\t\t int num)\n{\n\tstruct snd_seq_client_port *port;\n\n\tif (client == NULL)\n\t\treturn NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif (port->addr.port == num) {\n\t\t\tif (port->closing)\n\t\t\t\tbreak;  \n\t\t\tsnd_use_lock_use(&port->use_lock);\n\t\t\tread_unlock(&client->ports_lock);\n\t\t\treturn port;\n\t\t}\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn NULL;\t\t \n}\n\n\n \nstruct snd_seq_client_port *snd_seq_port_query_nearest(struct snd_seq_client *client,\n\t\t\t\t\t\t       struct snd_seq_port_info *pinfo)\n{\n\tint num;\n\tstruct snd_seq_client_port *port, *found;\n\tbool check_inactive = (pinfo->capability & SNDRV_SEQ_PORT_CAP_INACTIVE);\n\n\tnum = pinfo->addr.port;\n\tfound = NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif ((port->capability & SNDRV_SEQ_PORT_CAP_INACTIVE) &&\n\t\t    !check_inactive)\n\t\t\tcontinue;  \n\t\tif (port->addr.port < num)\n\t\t\tcontinue;\n\t\tif (port->addr.port == num) {\n\t\t\tfound = port;\n\t\t\tbreak;\n\t\t}\n\t\tif (found == NULL || port->addr.port < found->addr.port)\n\t\t\tfound = port;\n\t}\n\tif (found) {\n\t\tif (found->closing)\n\t\t\tfound = NULL;\n\t\telse\n\t\t\tsnd_use_lock_use(&found->use_lock);\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn found;\n}\n\n\n \nstatic void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n{\n\tINIT_LIST_HEAD(&grp->list_head);\n\tgrp->count = 0;\n\tgrp->exclusive = 0;\n\trwlock_init(&grp->list_lock);\n\tinit_rwsem(&grp->list_mutex);\n\tgrp->open = NULL;\n\tgrp->close = NULL;\n}\n\n\n \nint snd_seq_create_port(struct snd_seq_client *client, int port,\n\t\t\tstruct snd_seq_client_port **port_ret)\n{\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num;\n\t\n\t*port_ret = NULL;\n\n\t \n\tif (snd_BUG_ON(!client))\n\t\treturn -EINVAL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn -ENOMEM;\t \n\t \n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tsnd_use_lock_use(&new_port->use_lock);\n\n\tnum = max(port, 0);\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irq(&client->ports_lock);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port == port) {\n\t\t\tkfree(new_port);\n\t\t\tnum = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0)  \n\t\t\tnum = p->addr.port + 1;\n\t}\n\t \n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t \n\tsprintf(new_port->name, \"port-%d\", num);\n\t*port_ret = new_port;\n unlock:\n\twrite_unlock_irq(&client->ports_lock);\n\tmutex_unlock(&client->ports_mutex);\n\n\treturn num;\n}\n\n \nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info, int send_ack);\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info, int send_ack);\n\n\nstatic struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,\n\t\t\t\t\t\t   struct snd_seq_client **cp)\n{\n\tstruct snd_seq_client_port *p;\n\t*cp = snd_seq_client_use_ptr(addr->client);\n\tif (*cp) {\n\t\tp = snd_seq_port_use_ptr(*cp, addr->port);\n\t\tif (! p) {\n\t\t\tsnd_seq_client_unlock(*cp);\n\t\t\t*cp = NULL;\n\t\t}\n\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack);\n\nstatic inline struct snd_seq_subscribers *\nget_subscriber(struct list_head *p, bool is_src)\n{\n\tif (is_src)\n\t\treturn list_entry(p, struct snd_seq_subscribers, src_list);\n\telse\n\t\treturn list_entry(p, struct snd_seq_subscribers, dest_list);\n}\n\n \nstatic void clear_subscriber_list(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_client_port *port,\n\t\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t\t  int is_src)\n{\n\tstruct list_head *p, *n;\n\n\tlist_for_each_safe(p, n, &grp->list_head) {\n\t\tstruct snd_seq_subscribers *subs;\n\t\tstruct snd_seq_client *c;\n\t\tstruct snd_seq_client_port *aport;\n\n\t\tsubs = get_subscriber(p, is_src);\n\t\tif (is_src)\n\t\t\taport = get_client_port(&subs->info.dest, &c);\n\t\telse\n\t\t\taport = get_client_port(&subs->info.sender, &c);\n\t\tdelete_and_unsubscribe_port(client, port, subs, is_src, false);\n\n\t\tif (!aport) {\n\t\t\t \n\t\t\tif (atomic_dec_and_test(&subs->ref_count))\n\t\t\t\tkfree(subs);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdelete_and_unsubscribe_port(c, aport, subs, !is_src, true);\n\t\tkfree(subs);\n\t\tsnd_seq_port_unlock(aport);\n\t\tsnd_seq_client_unlock(c);\n\t}\n}\n\n \nstatic int port_delete(struct snd_seq_client *client,\n\t\t       struct snd_seq_client_port *port)\n{\n\t \n\tport->closing = 1;\n\tsnd_use_lock_sync(&port->use_lock); \n\n\t \n\tclear_subscriber_list(client, port, &port->c_src, true);\n\tclear_subscriber_list(client, port, &port->c_dest, false);\n\n\tif (port->private_free)\n\t\tport->private_free(port->private_data);\n\n\tsnd_BUG_ON(port->c_src.count != 0);\n\tsnd_BUG_ON(port->c_dest.count != 0);\n\n\tkfree(port);\n\treturn 0;\n}\n\n\n \nint snd_seq_delete_port(struct snd_seq_client *client, int port)\n{\n\tstruct snd_seq_client_port *found = NULL, *p;\n\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irq(&client->ports_lock);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port == port) {\n\t\t\t \n\t\t\tlist_del(&p->list);\n\t\t\tclient->num_ports--;\n\t\t\tfound = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock_irq(&client->ports_lock);\n\tmutex_unlock(&client->ports_mutex);\n\tif (found)\n\t\treturn port_delete(client, found);\n\telse\n\t\treturn -ENOENT;\n}\n\n \nint snd_seq_delete_all_ports(struct snd_seq_client *client)\n{\n\tstruct list_head deleted_list;\n\tstruct snd_seq_client_port *port, *tmp;\n\t\n\t \n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irq(&client->ports_lock);\n\tif (! list_empty(&client->ports_list_head)) {\n\t\tlist_add(&deleted_list, &client->ports_list_head);\n\t\tlist_del_init(&client->ports_list_head);\n\t} else {\n\t\tINIT_LIST_HEAD(&deleted_list);\n\t}\n\tclient->num_ports = 0;\n\twrite_unlock_irq(&client->ports_lock);\n\n\t \n\tlist_for_each_entry_safe(port, tmp, &deleted_list, list) {\n\t\tlist_del(&port->list);\n\t\tsnd_seq_system_client_ev_port_exit(port->addr.client, port->addr.port);\n\t\tport_delete(client, port);\n\t}\n\tmutex_unlock(&client->ports_mutex);\n\treturn 0;\n}\n\n \nint snd_seq_set_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t \n\tif (info->name[0])\n\t\tstrscpy(port->name, info->name, sizeof(port->name));\n\t\n\t \n\tport->capability = info->capability;\n\t\n\t \n\tport->type = info->type;\n\n\t \n\tport->midi_channels = info->midi_channels;\n\tport->midi_voices = info->midi_voices;\n\tport->synth_voices = info->synth_voices;\n\n\t \n\tport->timestamping = (info->flags & SNDRV_SEQ_PORT_FLG_TIMESTAMP) ? 1 : 0;\n\tport->time_real = (info->flags & SNDRV_SEQ_PORT_FLG_TIME_REAL) ? 1 : 0;\n\tport->time_queue = info->time_queue;\n\n\t \n\tport->direction = info->direction;\n\tport->ump_group = info->ump_group;\n\tif (port->ump_group > SNDRV_UMP_MAX_GROUPS)\n\t\tport->ump_group = 0;\n\n\t \n\tif (!port->direction) {\n\t\tif (info->capability & SNDRV_SEQ_PORT_CAP_READ)\n\t\t\tport->direction |= SNDRV_SEQ_PORT_DIR_INPUT;\n\t\tif (info->capability & SNDRV_SEQ_PORT_CAP_WRITE)\n\t\t\tport->direction |= SNDRV_SEQ_PORT_DIR_OUTPUT;\n\t}\n\n\treturn 0;\n}\n\n \nint snd_seq_get_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t \n\tstrscpy(info->name, port->name, sizeof(info->name));\n\t\n\t \n\tinfo->capability = port->capability;\n\n\t \n\tinfo->type = port->type;\n\n\t \n\tinfo->midi_channels = port->midi_channels;\n\tinfo->midi_voices = port->midi_voices;\n\tinfo->synth_voices = port->synth_voices;\n\n\t \n\tinfo->read_use = port->c_src.count;\n\tinfo->write_use = port->c_dest.count;\n\t\n\t \n\tinfo->flags = 0;\n\tif (port->timestamping) {\n\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIMESTAMP;\n\t\tif (port->time_real)\n\t\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIME_REAL;\n\t\tinfo->time_queue = port->time_queue;\n\t}\n\n\t \n\tinfo->direction = port->direction;\n\tinfo->ump_group = port->ump_group;\n\n\treturn 0;\n}\n\n\n\n \n\nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info,\n\t\t\t  int send_ack)\n{\n\tint err = 0;\n\n\tif (!try_module_get(port->owner))\n\t\treturn -EFAULT;\n\tgrp->count++;\n\tif (grp->open && grp->count == 1) {\n\t\terr = grp->open(port->private_data, info);\n\t\tif (err < 0) {\n\t\t\tmodule_put(port->owner);\n\t\t\tgrp->count--;\n\t\t}\n\t}\n\tif (err >= 0 && send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n\n\treturn err;\n}\n\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info,\n\t\t\t    int send_ack)\n{\n\tint err = 0;\n\n\tif (! grp->count)\n\t\treturn -EINVAL;\n\tgrp->count--;\n\tif (grp->close && grp->count == 0)\n\t\terr = grp->close(port->private_data, info);\n\tif (send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n\tmodule_put(port->owner);\n\treturn err;\n}\n\n\n\n \nstatic inline int addr_match(struct snd_seq_addr *r, struct snd_seq_addr *s)\n{\n\treturn (r->client == s->client) && (r->port == s->port);\n}\n\n \n \nstatic int match_subs_info(struct snd_seq_port_subscribe *r,\n\t\t\t   struct snd_seq_port_subscribe *s)\n{\n\tif (addr_match(&r->sender, &s->sender) &&\n\t    addr_match(&r->dest, &s->dest)) {\n\t\tif (r->flags && r->flags == s->flags)\n\t\t\treturn r->queue == s->queue;\n\t\telse if (! r->flags)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_and_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t    struct snd_seq_client_port *port,\n\t\t\t\t    struct snd_seq_subscribers *subs,\n\t\t\t\t    bool is_src, bool exclusive, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint err;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\terr = -EBUSY;\n\tdown_write(&grp->list_mutex);\n\tif (exclusive) {\n\t\tif (!list_empty(&grp->list_head))\n\t\t\tgoto __error;\n\t} else {\n\t\tif (grp->exclusive)\n\t\t\tgoto __error;\n\t\t \n\t\tlist_for_each(p, &grp->list_head) {\n\t\t\ts = get_subscriber(p, is_src);\n\t\t\tif (match_subs_info(&subs->info, &s->info))\n\t\t\t\tgoto __error;\n\t\t}\n\t}\n\n\terr = subscribe_port(client, port, grp, &subs->info, ack);\n\tif (err < 0) {\n\t\tgrp->exclusive = 0;\n\t\tgoto __error;\n\t}\n\n\t \n\twrite_lock_irq(&grp->list_lock);\n\tif (is_src)\n\t\tlist_add_tail(&subs->src_list, &grp->list_head);\n\telse\n\t\tlist_add_tail(&subs->dest_list, &grp->list_head);\n\tgrp->exclusive = exclusive;\n\tatomic_inc(&subs->ref_count);\n\twrite_unlock_irq(&grp->list_lock);\n\terr = 0;\n\n __error:\n\tup_write(&grp->list_mutex);\n\treturn err;\n}\n\n \nstatic void __delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  struct snd_seq_client_port *port,\n\t\t\t\t\t  struct snd_seq_subscribers *subs,\n\t\t\t\t\t  bool is_src, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *list;\n\tbool empty;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\tlist = is_src ? &subs->src_list : &subs->dest_list;\n\twrite_lock_irq(&grp->list_lock);\n\tempty = list_empty(list);\n\tif (!empty)\n\t\tlist_del_init(list);\n\tgrp->exclusive = 0;\n\twrite_unlock_irq(&grp->list_lock);\n\n\tif (!empty)\n\t\tunsubscribe_port(client, port, grp, &subs->info, ack);\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\tdown_write(&grp->list_mutex);\n\t__delete_and_unsubscribe_port(client, port, subs, is_src, ack);\n\tup_write(&grp->list_mutex);\n}\n\n \nint snd_seq_port_connect(struct snd_seq_client *connector,\n\t\t\t struct snd_seq_client *src_client,\n\t\t\t struct snd_seq_client_port *src_port,\n\t\t\t struct snd_seq_client *dest_client,\n\t\t\t struct snd_seq_client_port *dest_port,\n\t\t\t struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_subscribers *subs;\n\tbool exclusive;\n\tint err;\n\n\tsubs = kzalloc(sizeof(*subs), GFP_KERNEL);\n\tif (!subs)\n\t\treturn -ENOMEM;\n\n\tsubs->info = *info;\n\tatomic_set(&subs->ref_count, 0);\n\tINIT_LIST_HEAD(&subs->src_list);\n\tINIT_LIST_HEAD(&subs->dest_list);\n\n\texclusive = !!(info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);\n\n\terr = check_and_subscribe_port(src_client, src_port, subs, true,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != src_client->number);\n\tif (err < 0)\n\t\tgoto error;\n\terr = check_and_subscribe_port(dest_client, dest_port, subs, false,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != dest_client->number);\n\tif (err < 0)\n\t\tgoto error_dest;\n\n\treturn 0;\n\n error_dest:\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n error:\n\tkfree(subs);\n\treturn err;\n}\n\n \nint snd_seq_port_disconnect(struct snd_seq_client *connector,\n\t\t\t    struct snd_seq_client *src_client,\n\t\t\t    struct snd_seq_client_port *src_port,\n\t\t\t    struct snd_seq_client *dest_client,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_port_subs_info *dest = &dest_port->c_dest;\n\tstruct snd_seq_subscribers *subs;\n\tint err = -ENOENT;\n\n\t \n\tdown_write(&dest->list_mutex);\n\t \n\tlist_for_each_entry(subs, &dest->list_head, dest_list) {\n\t\tif (match_subs_info(info, &subs->info)) {\n\t\t\t__delete_and_unsubscribe_port(dest_client, dest_port,\n\t\t\t\t\t\t      subs, false,\n\t\t\t\t\t\t      connector->number != dest_client->number);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&dest->list_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n\tkfree(subs);\n\treturn 0;\n}\n\n\n \nint snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,\n\t\t\t\t  struct snd_seq_addr *dest_addr,\n\t\t\t\t  struct snd_seq_port_subscribe *subs)\n{\n\tstruct snd_seq_subscribers *s;\n\tint err = -ENOENT;\n\n\tdown_read(&src_grp->list_mutex);\n\tlist_for_each_entry(s, &src_grp->list_head, src_list) {\n\t\tif (addr_match(dest_addr, &s->info.dest)) {\n\t\t\t*subs = s->info;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&src_grp->list_mutex);\n\treturn err;\n}\n\n \n \nint snd_seq_event_port_attach(int client,\n\t\t\t      struct snd_seq_port_callback *pcbp,\n\t\t\t      int cap, int type, int midi_channels,\n\t\t\t      int midi_voices, char *portname)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  ret;\n\n\t \n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tstrscpy(portinfo.name, portname ? portname : \"Unnamed port\",\n\t\tsizeof(portinfo.name));\n\n\tportinfo.capability = cap;\n\tportinfo.type = type;\n\tportinfo.kernel = pcbp;\n\tportinfo.midi_channels = midi_channels;\n\tportinfo.midi_voices = midi_voices;\n\n\t \n\tret = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\t&portinfo);\n\n\tif (ret >= 0)\n\t\tret = portinfo.addr.port;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_seq_event_port_attach);\n\n \n \nint snd_seq_event_port_detach(int client, int port)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  err;\n\n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tportinfo.addr.port   = port;\n\terr = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_DELETE_PORT,\n\t\t\t\t\t&portinfo);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_seq_event_port_detach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}