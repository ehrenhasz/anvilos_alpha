{
  "module_name": "seq_queue.c",
  "hash_id": "b6e94d8dde85ef0533c10add21f4f3232bf7940fa87fb077f508d82afd77381a",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_queue.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_clientmgr.h\"\n#include \"seq_fifo.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n\n \nstatic struct snd_seq_queue *queue_list[SNDRV_SEQ_MAX_QUEUES];\nstatic DEFINE_SPINLOCK(queue_list_lock);\n \nstatic int num_queues;\n\nint snd_seq_queue_get_cur_queues(void)\n{\n\treturn num_queues;\n}\n\n \n\n \nstatic int queue_list_add(struct snd_seq_queue *q)\n{\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (! queue_list[i]) {\n\t\t\tqueue_list[i] = q;\n\t\t\tq->queue = i;\n\t\t\tnum_queues++;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn i;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn -1;\n}\n\nstatic struct snd_seq_queue *queue_list_remove(int id, int client)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[id];\n\tif (q) {\n\t\tspin_lock(&q->owner_lock);\n\t\tif (q->owner == client) {\n\t\t\t \n\t\t\tq->klocked = 1;\n\t\t\tspin_unlock(&q->owner_lock);\n\t\t\tqueue_list[id] = NULL;\n\t\t\tnum_queues--;\n\t\t\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\t\t\treturn q;\n\t\t}\n\t\tspin_unlock(&q->owner_lock);\n\t}\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn NULL;\n}\n\n \n\n \nstatic struct snd_seq_queue *queue_new(int owner, int locked)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tspin_lock_init(&q->owner_lock);\n\tspin_lock_init(&q->check_lock);\n\tmutex_init(&q->timer_mutex);\n\tsnd_use_lock_init(&q->use_lock);\n\tq->queue = -1;\n\n\tq->tickq = snd_seq_prioq_new();\n\tq->timeq = snd_seq_prioq_new();\n\tq->timer = snd_seq_timer_new();\n\tif (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {\n\t\tsnd_seq_prioq_delete(&q->tickq);\n\t\tsnd_seq_prioq_delete(&q->timeq);\n\t\tsnd_seq_timer_delete(&q->timer);\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tq->owner = owner;\n\tq->locked = locked;\n\tq->klocked = 0;\n\n\treturn q;\n}\n\n \nstatic void queue_delete(struct snd_seq_queue *q)\n{\n\t \n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\t \n\tsnd_use_lock_sync(&q->use_lock);\n\t \n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\n\tkfree(q);\n}\n\n\n \n\n \nvoid snd_seq_queues_delete(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tif (queue_list[i])\n\t\t\tqueue_delete(queue_list[i]);\n\t}\n}\n\nstatic void queue_use(struct snd_seq_queue *queue, int client, int use);\n\n \nstruct snd_seq_queue *snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queue_new(client, locked);\n\tif (q == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tq->info_flags = info_flags;\n\tqueue_use(q, client, 1);\n\tsnd_use_lock_use(&q->use_lock);\n\tif (queue_list_add(q) < 0) {\n\t\tsnd_use_lock_free(&q->use_lock);\n\t\tqueue_delete(q);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\treturn q;\n}\n\n \nint snd_seq_queue_delete(int client, int queueid)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn -EINVAL;\n\tq = queue_list_remove(queueid, client);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tqueue_delete(q);\n\n\treturn 0;\n}\n\n\n \nstruct snd_seq_queue *queueptr(int queueid)\n{\n\tstruct snd_seq_queue *q;\n\tunsigned long flags;\n\n\tif (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&queue_list_lock, flags);\n\tq = queue_list[queueid];\n\tif (q)\n\t\tsnd_use_lock_use(&q->use_lock);\n\tspin_unlock_irqrestore(&queue_list_lock, flags);\n\treturn q;\n}\n\n \nstruct snd_seq_queue *snd_seq_queue_find_name(char *name)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queueptr(i);\n\t\tif (q) {\n\t\t\tif (strncmp(q->name, name, sizeof(q->name)) == 0)\n\t\t\t\treturn q;\n\t\t\tqueuefree(q);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\n \n\n#define MAX_CELL_PROCESSES_IN_QUEUE\t1000\n\nvoid snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)\n{\n\tunsigned long flags;\n\tstruct snd_seq_event_cell *cell;\n\tsnd_seq_tick_time_t cur_tick;\n\tsnd_seq_real_time_t cur_time;\n\tint processed = 0;\n\n\tif (q == NULL)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_blocked) {\n\t\tq->check_again = 1;\n\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\treturn;\t\t \n\t}\n\tq->check_blocked = 1;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n\n      __again:\n\t \n\tcur_tick = snd_seq_timer_get_cur_tick(q->timer);\n\tfor (;;) {\n\t\tcell = snd_seq_prioq_cell_out(q->tickq, &cur_tick);\n\t\tif (!cell)\n\t\t\tbreak;\n\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\tif (++processed >= MAX_CELL_PROCESSES_IN_QUEUE)\n\t\t\tgoto out;  \n\t}\n\n\t \n\tcur_time = snd_seq_timer_get_cur_time(q->timer, false);\n\tfor (;;) {\n\t\tcell = snd_seq_prioq_cell_out(q->timeq, &cur_time);\n\t\tif (!cell)\n\t\t\tbreak;\n\t\tsnd_seq_dispatch_event(cell, atomic, hop);\n\t\tif (++processed >= MAX_CELL_PROCESSES_IN_QUEUE)\n\t\t\tgoto out;  \n\t}\n\n out:\n\t \n\tspin_lock_irqsave(&q->check_lock, flags);\n\tif (q->check_again) {\n\t\tq->check_again = 0;\n\t\tif (processed < MAX_CELL_PROCESSES_IN_QUEUE) {\n\t\t\tspin_unlock_irqrestore(&q->check_lock, flags);\n\t\t\tgoto __again;\n\t\t}\n\t}\n\tq->check_blocked = 0;\n\tspin_unlock_irqrestore(&q->check_lock, flags);\n}\n\n\n \nint snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tint dest, err;\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\tdest = cell->event.queue;\t \n\tq = queueptr(dest);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\t \n\tif ((cell->event.flags & SNDRV_SEQ_TIME_MODE_MASK) == SNDRV_SEQ_TIME_MODE_REL) {\n\t\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tcell->event.time.tick += q->timer->tick.cur_tick;\n\t\t\tbreak;\n\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\tsnd_seq_inc_real_time(&cell->event.time.time,\n\t\t\t\t\t      &q->timer->cur_time);\n\t\t\tbreak;\n\t\t}\n\t\tcell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;\n\t\tcell->event.flags |= SNDRV_SEQ_TIME_MODE_ABS;\n\t}\n\t \n\tswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\terr = snd_seq_prioq_cell_in(q->tickq, cell);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\tdefault:\n\t\terr = snd_seq_prioq_cell_in(q->timeq, cell);\n\t\tbreak;\n\t}\n\n\tif (err < 0) {\n\t\tqueuefree(q);  \n\t\treturn err;\n\t}\n\n\t \n\tsnd_seq_check_queue(q, atomic, hop);\n\n\tqueuefree(q);  \n\n\treturn 0;\n}\n\n\n \n\nstatic inline int check_access(struct snd_seq_queue *q, int client)\n{\n\treturn (q->owner == client) || (!q->locked && !q->klocked);\n}\n\n \nstatic int queue_access_lock(struct snd_seq_queue *q, int client)\n{\n\tunsigned long flags;\n\tint access_ok;\n\t\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tif (access_ok)\n\t\tq->klocked = 1;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\treturn access_ok;\n}\n\n \nstatic inline void queue_access_unlock(struct snd_seq_queue *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\tq->klocked = 0;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n}\n\n \nint snd_seq_queue_check_access(int queueid, int client)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint access_ok;\n\tunsigned long flags;\n\n\tif (! q)\n\t\treturn 0;\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\taccess_ok = check_access(q, client);\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\tqueuefree(q);\n\treturn access_ok;\n}\n\n \n\n \nint snd_seq_queue_set_owner(int queueid, int client, int locked)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tunsigned long flags;\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tspin_lock_irqsave(&q->owner_lock, flags);\n\tq->locked = locked ? 1 : 0;\n\tq->owner = client;\n\tspin_unlock_irqrestore(&q->owner_lock, flags);\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n\n \n\n \nint snd_seq_queue_timer_open(int queueid)\n{\n\tint result = 0;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\ttmr = queue->timer;\n\tresult = snd_seq_timer_open(queue);\n\tif (result < 0) {\n\t\tsnd_seq_timer_defaults(tmr);\n\t\tresult = snd_seq_timer_open(queue);\n\t}\n\tqueuefree(queue);\n\treturn result;\n}\n\n \nint snd_seq_queue_timer_close(int queueid)\n{\n\tstruct snd_seq_queue *queue;\n\tint result = 0;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tsnd_seq_timer_close(queue);\n\tqueuefree(queue);\n\treturn result;\n}\n\n \nint snd_seq_queue_timer_set_tempo(int queueid, int client,\n\t\t\t\t  struct snd_seq_queue_tempo *info)\n{\n\tstruct snd_seq_queue *q = queueptr(queueid);\n\tint result;\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tif (! queue_access_lock(q, client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tresult = snd_seq_timer_set_tempo_ppq(q->timer, info->tempo, info->ppq);\n\tif (result >= 0 && info->skew_base > 0)\n\t\tresult = snd_seq_timer_set_skew(q->timer, info->skew_value,\n\t\t\t\t\t\tinfo->skew_base);\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn result;\n}\n\n \nstatic void queue_use(struct snd_seq_queue *queue, int client, int use)\n{\n\tif (use) {\n\t\tif (!test_and_set_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients++;\n\t} else {\n\t\tif (test_and_clear_bit(client, queue->clients_bitmap))\n\t\t\tqueue->clients--;\n\t}\n\tif (queue->clients) {\n\t\tif (use && queue->clients == 1)\n\t\t\tsnd_seq_timer_defaults(queue->timer);\n\t\tsnd_seq_timer_open(queue);\n\t} else {\n\t\tsnd_seq_timer_close(queue);\n\t}\n}\n\n \nint snd_seq_queue_use(int queueid, int client, int use)\n{\n\tstruct snd_seq_queue *queue;\n\n\tqueue = queueptr(queueid);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmutex_lock(&queue->timer_mutex);\n\tqueue_use(queue, client, use);\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\treturn 0;\n}\n\n \nint snd_seq_queue_is_used(int queueid, int client)\n{\n\tstruct snd_seq_queue *q;\n\tint result;\n\n\tq = queueptr(queueid);\n\tif (q == NULL)\n\t\treturn -EINVAL;  \n\tresult = test_bit(client, q->clients_bitmap) ? 1 : 0;\n\tqueuefree(q);\n\treturn result;\n}\n\n\n \n\n \nvoid snd_seq_queue_client_leave(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\t \n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queue_list_remove(i, client);\n\t\tif (q)\n\t\t\tqueue_delete(q);\n\t}\n\n\t \n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queueptr(i);\n\t\tif (!q)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap)) {\n\t\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\t\tsnd_seq_queue_use(q->queue, client, 0);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n\n\n \n\n \nvoid snd_seq_queue_client_leave_cells(int client)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queueptr(i);\n\t\tif (!q)\n\t\t\tcontinue;\n\t\tsnd_seq_prioq_leave(q->tickq, client, 0);\n\t\tsnd_seq_prioq_leave(q->timeq, client, 0);\n\t\tqueuefree(q);\n\t}\n}\n\n \nvoid snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info)\n{\n\tint i;\n\tstruct snd_seq_queue *q;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queueptr(i);\n\t\tif (!q)\n\t\t\tcontinue;\n\t\tif (test_bit(client, q->clients_bitmap) &&\n\t\t    (! (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) ||\n\t\t     q->queue == info->queue)) {\n\t\t\tsnd_seq_prioq_remove_events(q->tickq, client, info);\n\t\t\tsnd_seq_prioq_remove_events(q->timeq, client, info);\n\t\t}\n\t\tqueuefree(q);\n\t}\n}\n\n \n\n \nstatic void queue_broadcast_event(struct snd_seq_queue *q, struct snd_seq_event *ev,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_event sev;\n\n\tsev = *ev;\n\t\n\tsev.flags = SNDRV_SEQ_TIME_STAMP_TICK|SNDRV_SEQ_TIME_MODE_ABS;\n\tsev.time.tick = q->timer->tick.cur_tick;\n\tsev.queue = q->queue;\n\tsev.data.queue.queue = q->queue;\n\n\t \n\tsev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tsev.source.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\n\tsev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\tsnd_seq_kernel_client_dispatch(SNDRV_SEQ_CLIENT_SYSTEM, &sev, atomic, hop);\n}\n\n \nstatic void snd_seq_queue_process_event(struct snd_seq_queue *q,\n\t\t\t\t\tstruct snd_seq_event *ev,\n\t\t\t\t\tint atomic, int hop)\n{\n\tswitch (ev->type) {\n\tcase SNDRV_SEQ_EVENT_START:\n\t\tsnd_seq_prioq_leave(q->tickq, ev->source.client, 1);\n\t\tsnd_seq_prioq_leave(q->timeq, ev->source.client, 1);\n\t\tif (! snd_seq_timer_start(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_CONTINUE:\n\t\tif (! snd_seq_timer_continue(q->timer))\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_STOP:\n\t\tsnd_seq_timer_stop(q->timer);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_TEMPO:\n\t\tsnd_seq_timer_set_tempo(q->timer, ev->data.queue.param.value);\n\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TICK:\n\t\tif (snd_seq_timer_set_position_tick(q->timer, ev->data.queue.param.time.tick) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_SEQ_EVENT_SETPOS_TIME:\n\t\tif (snd_seq_timer_set_position_time(q->timer, ev->data.queue.param.time.time) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_QUEUE_SKEW:\n\t\tif (snd_seq_timer_set_skew(q->timer,\n\t\t\t\t\t   ev->data.queue.param.skew.value,\n\t\t\t\t\t   ev->data.queue.param.skew.base) == 0) {\n\t\t\tqueue_broadcast_event(q, ev, atomic, hop);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\n \nint snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)\n{\n\tstruct snd_seq_queue *q;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\tq = queueptr(ev->data.queue.queue);\n\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tif (! queue_access_lock(q, ev->source.client)) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\n\tsnd_seq_queue_process_event(q, ev, atomic, hop);\n\n\tqueue_access_unlock(q);\n\tqueuefree(q);\n\treturn 0;\n}\n\n\n \n\n#ifdef CONFIG_SND_PROC_FS\n \nvoid snd_seq_info_queues_read(struct snd_info_entry *entry, \n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint i, bpm;\n\tstruct snd_seq_queue *q;\n\tstruct snd_seq_timer *tmr;\n\tbool locked;\n\tint owner;\n\n\tfor (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {\n\t\tq = queueptr(i);\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\ttmr = q->timer;\n\t\tif (tmr->tempo)\n\t\t\tbpm = 60000000 / tmr->tempo;\n\t\telse\n\t\t\tbpm = 0;\n\n\t\tspin_lock_irq(&q->owner_lock);\n\t\tlocked = q->locked;\n\t\towner = q->owner;\n\t\tspin_unlock_irq(&q->owner_lock);\n\n\t\tsnd_iprintf(buffer, \"queue %d: [%s]\\n\", q->queue, q->name);\n\t\tsnd_iprintf(buffer, \"owned by client    : %d\\n\", owner);\n\t\tsnd_iprintf(buffer, \"lock status        : %s\\n\", locked ? \"Locked\" : \"Free\");\n\t\tsnd_iprintf(buffer, \"queued time events : %d\\n\", snd_seq_prioq_avail(q->timeq));\n\t\tsnd_iprintf(buffer, \"queued tick events : %d\\n\", snd_seq_prioq_avail(q->tickq));\n\t\tsnd_iprintf(buffer, \"timer state        : %s\\n\", tmr->running ? \"Running\" : \"Stopped\");\n\t\tsnd_iprintf(buffer, \"timer PPQ          : %d\\n\", tmr->ppq);\n\t\tsnd_iprintf(buffer, \"current tempo      : %d\\n\", tmr->tempo);\n\t\tsnd_iprintf(buffer, \"current BPM        : %d\\n\", bpm);\n\t\tsnd_iprintf(buffer, \"current time       : %d.%09d s\\n\", tmr->cur_time.tv_sec, tmr->cur_time.tv_nsec);\n\t\tsnd_iprintf(buffer, \"current tick       : %d\\n\", tmr->tick.cur_tick);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tqueuefree(q);\n\t}\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}