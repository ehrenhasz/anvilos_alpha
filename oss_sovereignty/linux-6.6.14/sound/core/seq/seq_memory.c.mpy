{
  "module_name": "seq_memory.c",
  "hash_id": "4a2e817beb61b4395511a188f26ac5ecfecc43dc3dc4298565e03fdd098c667a",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq/seq_memory.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <sound/core.h>\n\n#include <sound/seq_kernel.h>\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_info.h\"\n#include \"seq_lock.h\"\n\nstatic inline int snd_seq_pool_available(struct snd_seq_pool *pool)\n{\n\treturn pool->total_elements - atomic_read(&pool->counter);\n}\n\nstatic inline int snd_seq_output_ok(struct snd_seq_pool *pool)\n{\n\treturn snd_seq_pool_available(pool) >= pool->room;\n}\n\n \n\n \n\nstatic int get_var_len(const struct snd_seq_event *event)\n{\n\tif ((event->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)\n\t\treturn -EINVAL;\n\n\treturn event->data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n}\n\nstatic int dump_var_event(const struct snd_seq_event *event,\n\t\t\t  snd_seq_dump_func_t func, void *private_data,\n\t\t\t  int offset, int maxlen)\n{\n\tint len, err;\n\tstruct snd_seq_event_cell *cell;\n\n\tlen = get_var_len(event);\n\tif (len <= 0)\n\t\treturn len;\n\tif (len <= offset)\n\t\treturn 0;\n\tif (maxlen && len > offset + maxlen)\n\t\tlen = offset + maxlen;\n\n\tif (event->data.ext.len & SNDRV_SEQ_EXT_USRPTR) {\n\t\tchar buf[32];\n\t\tchar __user *curptr = (char __force __user *)event->data.ext.ptr;\n\t\tcurptr += offset;\n\t\tlen -= offset;\n\t\twhile (len > 0) {\n\t\t\tint size = sizeof(buf);\n\t\t\tif (len < size)\n\t\t\t\tsize = len;\n\t\t\tif (copy_from_user(buf, curptr, size))\n\t\t\t\treturn -EFAULT;\n\t\t\terr = func(private_data, buf, size);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tcurptr += size;\n\t\t\tlen -= size;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!(event->data.ext.len & SNDRV_SEQ_EXT_CHAINED))\n\t\treturn func(private_data, event->data.ext.ptr + offset,\n\t\t\t    len - offset);\n\n\tcell = (struct snd_seq_event_cell *)event->data.ext.ptr;\n\tfor (; len > 0 && cell; cell = cell->next) {\n\t\tint size = sizeof(struct snd_seq_event);\n\t\tchar *curptr = (char *)&cell->event;\n\n\t\tif (offset >= size) {\n\t\t\toffset -= size;\n\t\t\tlen -= size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < size)\n\t\t\tsize = len;\n\t\terr = func(private_data, curptr + offset, size - offset);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\toffset = 0;\n\t\tlen -= size;\n\t}\n\treturn 0;\n}\n\nint snd_seq_dump_var_event(const struct snd_seq_event *event,\n\t\t\t   snd_seq_dump_func_t func, void *private_data)\n{\n\treturn dump_var_event(event, func, private_data, 0, 0);\n}\nEXPORT_SYMBOL(snd_seq_dump_var_event);\n\n\n \n\nstatic int seq_copy_in_kernel(void *ptr, void *src, int size)\n{\n\tchar **bufptr = ptr;\n\n\tmemcpy(*bufptr, src, size);\n\t*bufptr += size;\n\treturn 0;\n}\n\nstatic int seq_copy_in_user(void *ptr, void *src, int size)\n{\n\tchar __user **bufptr = ptr;\n\n\tif (copy_to_user(*bufptr, src, size))\n\t\treturn -EFAULT;\n\t*bufptr += size;\n\treturn 0;\n}\n\nstatic int expand_var_event(const struct snd_seq_event *event,\n\t\t\t    int offset, int size, char *buf, bool in_kernel)\n{\n\tif (event->data.ext.len & SNDRV_SEQ_EXT_USRPTR) {\n\t\tif (! in_kernel)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(buf,\n\t\t\t\t   (char __force __user *)event->data.ext.ptr + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn dump_var_event(event,\n\t\t\t     in_kernel ? seq_copy_in_kernel : seq_copy_in_user,\n\t\t\t     &buf, offset, size);\n}\n\nint snd_seq_expand_var_event(const struct snd_seq_event *event, int count, char *buf,\n\t\t\t     int in_kernel, int size_aligned)\n{\n\tint len, newlen, err;\n\n\tlen = get_var_len(event);\n\tif (len < 0)\n\t\treturn len;\n\tnewlen = len;\n\tif (size_aligned > 0)\n\t\tnewlen = roundup(len, size_aligned);\n\tif (count < newlen)\n\t\treturn -EAGAIN;\n\terr = expand_var_event(event, 0, len, buf, in_kernel);\n\tif (err < 0)\n\t\treturn err;\n\tif (len != newlen) {\n\t\tif (in_kernel)\n\t\t\tmemset(buf + len, 0, newlen - len);\n\t\telse if (clear_user((__force void __user *)buf + len,\n\t\t\t\t    newlen - len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn newlen;\n}\nEXPORT_SYMBOL(snd_seq_expand_var_event);\n\nint snd_seq_expand_var_event_at(const struct snd_seq_event *event, int count,\n\t\t\t\tchar *buf, int offset)\n{\n\tint len, err;\n\n\tlen = get_var_len(event);\n\tif (len < 0)\n\t\treturn len;\n\tif (len <= offset)\n\t\treturn 0;\n\tlen -= offset;\n\tif (len > count)\n\t\tlen = count;\n\terr = expand_var_event(event, offset, count, buf, true);\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(snd_seq_expand_var_event_at);\n\n \n\nstatic inline void free_cell(struct snd_seq_pool *pool,\n\t\t\t     struct snd_seq_event_cell *cell)\n{\n\tcell->next = pool->free;\n\tpool->free = cell;\n\tatomic_dec(&pool->counter);\n}\n\nvoid snd_seq_cell_free(struct snd_seq_event_cell * cell)\n{\n\tunsigned long flags;\n\tstruct snd_seq_pool *pool;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn;\n\tpool = cell->pool;\n\tif (snd_BUG_ON(!pool))\n\t\treturn;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tfree_cell(pool, cell);\n\tif (snd_seq_ev_is_variable(&cell->event)) {\n\t\tif (cell->event.data.ext.len & SNDRV_SEQ_EXT_CHAINED) {\n\t\t\tstruct snd_seq_event_cell *curp, *nextptr;\n\t\t\tcurp = cell->event.data.ext.ptr;\n\t\t\tfor (; curp; curp = nextptr) {\n\t\t\t\tnextptr = curp->next;\n\t\t\t\tcurp->next = pool->free;\n\t\t\t\tfree_cell(pool, curp);\n\t\t\t}\n\t\t}\n\t}\n\tif (waitqueue_active(&pool->output_sleep)) {\n\t\t \n\t\tif (snd_seq_output_ok(pool))\n\t\t\twake_up(&pool->output_sleep);\n\t}\n\tspin_unlock_irqrestore(&pool->lock, flags);\n}\n\n\n \nstatic int snd_seq_cell_alloc(struct snd_seq_pool *pool,\n\t\t\t      struct snd_seq_event_cell **cellp,\n\t\t\t      int nonblock, struct file *file,\n\t\t\t      struct mutex *mutexp)\n{\n\tstruct snd_seq_event_cell *cell;\n\tunsigned long flags;\n\tint err = -EAGAIN;\n\twait_queue_entry_t wait;\n\n\tif (pool == NULL)\n\t\treturn -EINVAL;\n\n\t*cellp = NULL;\n\n\tinit_waitqueue_entry(&wait, current);\n\tspin_lock_irqsave(&pool->lock, flags);\n\tif (pool->ptr == NULL) {\t \n\t\tpr_debug(\"ALSA: seq: pool is not initialized\\n\");\n\t\terr = -EINVAL;\n\t\tgoto __error;\n\t}\n\twhile (pool->free == NULL && ! nonblock && ! pool->closing) {\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&pool->output_sleep, &wait);\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\tif (mutexp)\n\t\t\tmutex_unlock(mutexp);\n\t\tschedule();\n\t\tif (mutexp)\n\t\t\tmutex_lock(mutexp);\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tremove_wait_queue(&pool->output_sleep, &wait);\n\t\t \n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tif (pool->closing) {  \n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\tcell = pool->free;\n\tif (cell) {\n\t\tint used;\n\t\tpool->free = cell->next;\n\t\tatomic_inc(&pool->counter);\n\t\tused = atomic_read(&pool->counter);\n\t\tif (pool->max_used < used)\n\t\t\tpool->max_used = used;\n\t\tpool->event_alloc_success++;\n\t\t \n\t\tcell->next = NULL;\n\t\terr = 0;\n\t} else\n\t\tpool->event_alloc_failures++;\n\t*cellp = cell;\n\n__error:\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\treturn err;\n}\n\n\n \nint snd_seq_event_dup(struct snd_seq_pool *pool, struct snd_seq_event *event,\n\t\t      struct snd_seq_event_cell **cellp, int nonblock,\n\t\t      struct file *file, struct mutex *mutexp)\n{\n\tint ncells, err;\n\tunsigned int extlen;\n\tstruct snd_seq_event_cell *cell;\n\tint size;\n\n\t*cellp = NULL;\n\n\tncells = 0;\n\textlen = 0;\n\tif (snd_seq_ev_is_variable(event)) {\n\t\textlen = event->data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\tncells = DIV_ROUND_UP(extlen, sizeof(struct snd_seq_event));\n\t}\n\tif (ncells >= pool->total_elements)\n\t\treturn -ENOMEM;\n\n\terr = snd_seq_cell_alloc(pool, &cell, nonblock, file, mutexp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsize = snd_seq_event_packet_size(event);\n\tmemcpy(&cell->ump, event, size);\n#if IS_ENABLED(CONFIG_SND_SEQ_UMP)\n\tif (size < sizeof(cell->event))\n\t\tcell->ump.raw.extra = 0;\n#endif\n\n\t \n\tif (snd_seq_ev_is_variable(event)) {\n\t\tint len = extlen;\n\t\tint is_chained = event->data.ext.len & SNDRV_SEQ_EXT_CHAINED;\n\t\tint is_usrptr = event->data.ext.len & SNDRV_SEQ_EXT_USRPTR;\n\t\tstruct snd_seq_event_cell *src, *tmp, *tail;\n\t\tchar *buf;\n\n\t\tcell->event.data.ext.len = extlen | SNDRV_SEQ_EXT_CHAINED;\n\t\tcell->event.data.ext.ptr = NULL;\n\n\t\tsrc = (struct snd_seq_event_cell *)event->data.ext.ptr;\n\t\tbuf = (char *)event->data.ext.ptr;\n\t\ttail = NULL;\n\n\t\twhile (ncells-- > 0) {\n\t\t\tsize = sizeof(struct snd_seq_event);\n\t\t\tif (len < size)\n\t\t\t\tsize = len;\n\t\t\terr = snd_seq_cell_alloc(pool, &tmp, nonblock, file,\n\t\t\t\t\t\t mutexp);\n\t\t\tif (err < 0)\n\t\t\t\tgoto __error;\n\t\t\tif (cell->event.data.ext.ptr == NULL)\n\t\t\t\tcell->event.data.ext.ptr = tmp;\n\t\t\tif (tail)\n\t\t\t\ttail->next = tmp;\n\t\t\ttail = tmp;\n\t\t\t \n\t\t\tif (is_chained && src) {\n\t\t\t\ttmp->event = src->event;\n\t\t\t\tsrc = src->next;\n\t\t\t} else if (is_usrptr) {\n\t\t\t\tif (copy_from_user(&tmp->event, (char __force __user *)buf, size)) {\n\t\t\t\t\terr = -EFAULT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemcpy(&tmp->event, buf, size);\n\t\t\t}\n\t\t\tbuf += size;\n\t\t\tlen -= size;\n\t\t}\n\t}\n\n\t*cellp = cell;\n\treturn 0;\n\n__error:\n\tsnd_seq_cell_free(cell);\n\treturn err;\n}\n  \n\n \nint snd_seq_pool_poll_wait(struct snd_seq_pool *pool, struct file *file,\n\t\t\t   poll_table *wait)\n{\n\tpoll_wait(file, &pool->output_sleep, wait);\n\treturn snd_seq_output_ok(pool);\n}\n\n\n \nint snd_seq_pool_init(struct snd_seq_pool *pool)\n{\n\tint cell;\n\tstruct snd_seq_event_cell *cellptr;\n\n\tif (snd_BUG_ON(!pool))\n\t\treturn -EINVAL;\n\n\tcellptr = kvmalloc_array(sizeof(struct snd_seq_event_cell), pool->size,\n\t\t\t\t GFP_KERNEL);\n\tif (!cellptr)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_irq(&pool->lock);\n\tif (pool->ptr) {\n\t\tspin_unlock_irq(&pool->lock);\n\t\tkvfree(cellptr);\n\t\treturn 0;\n\t}\n\n\tpool->ptr = cellptr;\n\tpool->free = NULL;\n\n\tfor (cell = 0; cell < pool->size; cell++) {\n\t\tcellptr = pool->ptr + cell;\n\t\tcellptr->pool = pool;\n\t\tcellptr->next = pool->free;\n\t\tpool->free = cellptr;\n\t}\n\tpool->room = (pool->size + 1) / 2;\n\n\t \n\tpool->max_used = 0;\n\tpool->total_elements = pool->size;\n\tspin_unlock_irq(&pool->lock);\n\treturn 0;\n}\n\n \nvoid snd_seq_pool_mark_closing(struct snd_seq_pool *pool)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!pool))\n\t\treturn;\n\tspin_lock_irqsave(&pool->lock, flags);\n\tpool->closing = 1;\n\tspin_unlock_irqrestore(&pool->lock, flags);\n}\n\n \nint snd_seq_pool_done(struct snd_seq_pool *pool)\n{\n\tstruct snd_seq_event_cell *ptr;\n\n\tif (snd_BUG_ON(!pool))\n\t\treturn -EINVAL;\n\n\t \n\tif (waitqueue_active(&pool->output_sleep))\n\t\twake_up(&pool->output_sleep);\n\n\twhile (atomic_read(&pool->counter) > 0)\n\t\tschedule_timeout_uninterruptible(1);\n\t\n\t \n\tspin_lock_irq(&pool->lock);\n\tptr = pool->ptr;\n\tpool->ptr = NULL;\n\tpool->free = NULL;\n\tpool->total_elements = 0;\n\tspin_unlock_irq(&pool->lock);\n\n\tkvfree(ptr);\n\n\tspin_lock_irq(&pool->lock);\n\tpool->closing = 0;\n\tspin_unlock_irq(&pool->lock);\n\n\treturn 0;\n}\n\n\n \nstruct snd_seq_pool *snd_seq_pool_new(int poolsize)\n{\n\tstruct snd_seq_pool *pool;\n\n\t \n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tspin_lock_init(&pool->lock);\n\tpool->ptr = NULL;\n\tpool->free = NULL;\n\tpool->total_elements = 0;\n\tatomic_set(&pool->counter, 0);\n\tpool->closing = 0;\n\tinit_waitqueue_head(&pool->output_sleep);\n\t\n\tpool->size = poolsize;\n\n\t \n\tpool->max_used = 0;\n\treturn pool;\n}\n\n \nint snd_seq_pool_delete(struct snd_seq_pool **ppool)\n{\n\tstruct snd_seq_pool *pool = *ppool;\n\n\t*ppool = NULL;\n\tif (pool == NULL)\n\t\treturn 0;\n\tsnd_seq_pool_mark_closing(pool);\n\tsnd_seq_pool_done(pool);\n\tkfree(pool);\n\treturn 0;\n}\n\n \nvoid snd_seq_info_pool(struct snd_info_buffer *buffer,\n\t\t       struct snd_seq_pool *pool, char *space)\n{\n\tif (pool == NULL)\n\t\treturn;\n\tsnd_iprintf(buffer, \"%sPool size          : %d\\n\", space, pool->total_elements);\n\tsnd_iprintf(buffer, \"%sCells in use       : %d\\n\", space, atomic_read(&pool->counter));\n\tsnd_iprintf(buffer, \"%sPeak cells in use  : %d\\n\", space, pool->max_used);\n\tsnd_iprintf(buffer, \"%sAlloc success      : %d\\n\", space, pool->event_alloc_success);\n\tsnd_iprintf(buffer, \"%sAlloc failures     : %d\\n\", space, pool->event_alloc_failures);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}