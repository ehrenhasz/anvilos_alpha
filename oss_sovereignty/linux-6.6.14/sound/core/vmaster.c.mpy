{
  "module_name": "vmaster.c",
  "hash_id": "1d37c69cbd07444cca08bc3ac1fea9b78c01b0e0f0717fa18a4ce46d51e7e435",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/vmaster.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n\n \nstruct link_ctl_info {\n\tsnd_ctl_elem_type_t type;  \n\tint count;\t\t \n\tint min_val, max_val;\t \n};\n\n \nstruct link_master {\n\tstruct list_head followers;\n\tstruct link_ctl_info info;\n\tint val;\t\t \n\tunsigned int tlv[4];\n\tvoid (*hook)(void *private_data, int);\n\tvoid *hook_private_data;\n};\n\n \n\nstruct link_follower {\n\tstruct list_head list;\n\tstruct link_master *master;\n\tstruct link_ctl_info info;\n\tint vals[2];\t\t \n\tunsigned int flags;\n\tstruct snd_kcontrol *kctl;  \n\tstruct snd_kcontrol follower;  \n};\n\nstatic int follower_update(struct link_follower *follower)\n{\n\tstruct snd_ctl_elem_value *uctl;\n\tint err, ch;\n\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (!uctl)\n\t\treturn -ENOMEM;\n\tuctl->id = follower->follower.id;\n\terr = follower->follower.get(&follower->follower, uctl);\n\tif (err < 0)\n\t\tgoto error;\n\tfor (ch = 0; ch < follower->info.count; ch++)\n\t\tfollower->vals[ch] = uctl->value.integer.value[ch];\n error:\n\tkfree(uctl);\n\treturn err < 0 ? err : 0;\n}\n\n \nstatic int follower_init(struct link_follower *follower)\n{\n\tstruct snd_ctl_elem_info *uinfo;\n\tint err;\n\n\tif (follower->info.count) {\n\t\t \n\t\tif (follower->flags & SND_CTL_FOLLOWER_NEED_UPDATE)\n\t\t\treturn follower_update(follower);\n\t\treturn 0;\n\t}\n\n\tuinfo = kmalloc(sizeof(*uinfo), GFP_KERNEL);\n\tif (!uinfo)\n\t\treturn -ENOMEM;\n\tuinfo->id = follower->follower.id;\n\terr = follower->follower.info(&follower->follower, uinfo);\n\tif (err < 0) {\n\t\tkfree(uinfo);\n\t\treturn err;\n\t}\n\tfollower->info.type = uinfo->type;\n\tfollower->info.count = uinfo->count;\n\tif (follower->info.count > 2  ||\n\t    (follower->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER &&\n\t     follower->info.type != SNDRV_CTL_ELEM_TYPE_BOOLEAN)) {\n\t\tpr_err(\"ALSA: vmaster: invalid follower element\\n\");\n\t\tkfree(uinfo);\n\t\treturn -EINVAL;\n\t}\n\tfollower->info.min_val = uinfo->value.integer.min;\n\tfollower->info.max_val = uinfo->value.integer.max;\n\tkfree(uinfo);\n\n\treturn follower_update(follower);\n}\n\n \nstatic int master_init(struct link_master *master)\n{\n\tstruct link_follower *follower;\n\n\tif (master->info.count)\n\t\treturn 0;  \n\n\tlist_for_each_entry(follower, &master->followers, list) {\n\t\tint err = follower_init(follower);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmaster->info = follower->info;\n\t\tmaster->info.count = 1;  \n\t\t \n\t\tmaster->val = master->info.max_val;\n\t\tif (master->hook)\n\t\t\tmaster->hook(master->hook_private_data, master->val);\n\t\treturn 1;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int follower_get_val(struct link_follower *follower,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tint err, ch;\n\n\terr = follower_init(follower);\n\tif (err < 0)\n\t\treturn err;\n\tfor (ch = 0; ch < follower->info.count; ch++)\n\t\tucontrol->value.integer.value[ch] = follower->vals[ch];\n\treturn 0;\n}\n\nstatic int follower_put_val(struct link_follower *follower,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tint err, ch, vol;\n\n\terr = master_init(follower->master);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (follower->info.type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\t\tfor (ch = 0; ch < follower->info.count; ch++)\n\t\t\tucontrol->value.integer.value[ch] &=\n\t\t\t\t!!follower->master->val;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tfor (ch = 0; ch < follower->info.count; ch++) {\n\t\t\t \n\t\t\tvol = ucontrol->value.integer.value[ch];\n\t\t\tvol += follower->master->val - follower->master->info.max_val;\n\t\t\tif (vol < follower->info.min_val)\n\t\t\t\tvol = follower->info.min_val;\n\t\t\telse if (vol > follower->info.max_val)\n\t\t\t\tvol = follower->info.max_val;\n\t\t\tucontrol->value.integer.value[ch] = vol;\n\t\t}\n\t\tbreak;\n\t}\n\treturn follower->follower.put(&follower->follower, ucontrol);\n}\n\n \nstatic int follower_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct link_follower *follower = snd_kcontrol_chip(kcontrol);\n\treturn follower->follower.info(&follower->follower, uinfo);\n}\n\nstatic int follower_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct link_follower *follower = snd_kcontrol_chip(kcontrol);\n\treturn follower_get_val(follower, ucontrol);\n}\n\nstatic int follower_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct link_follower *follower = snd_kcontrol_chip(kcontrol);\n\tint err, ch, changed = 0;\n\n\terr = follower_init(follower);\n\tif (err < 0)\n\t\treturn err;\n\tfor (ch = 0; ch < follower->info.count; ch++) {\n\t\tif (follower->vals[ch] != ucontrol->value.integer.value[ch]) {\n\t\t\tchanged = 1;\n\t\t\tfollower->vals[ch] = ucontrol->value.integer.value[ch];\n\t\t}\n\t}\n\tif (!changed)\n\t\treturn 0;\n\terr = follower_put_val(follower, ucontrol);\n\tif (err < 0)\n\t\treturn err;\n\treturn 1;\n}\n\nstatic int follower_tlv_cmd(struct snd_kcontrol *kcontrol,\n\t\t\t    int op_flag, unsigned int size,\n\t\t\t    unsigned int __user *tlv)\n{\n\tstruct link_follower *follower = snd_kcontrol_chip(kcontrol);\n\t \n\treturn follower->follower.tlv.c(&follower->follower, op_flag, size, tlv);\n}\n\nstatic void follower_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct link_follower *follower = snd_kcontrol_chip(kcontrol);\n\tif (follower->follower.private_free)\n\t\tfollower->follower.private_free(&follower->follower);\n\tif (follower->master)\n\t\tlist_del(&follower->list);\n\tkfree(follower);\n}\n\n \nint _snd_ctl_add_follower(struct snd_kcontrol *master,\n\t\t\t  struct snd_kcontrol *follower,\n\t\t\t  unsigned int flags)\n{\n\tstruct link_master *master_link = snd_kcontrol_chip(master);\n\tstruct link_follower *srec;\n\n\tsrec = kzalloc(struct_size(srec, follower.vd, follower->count),\n\t\t       GFP_KERNEL);\n\tif (!srec)\n\t\treturn -ENOMEM;\n\tsrec->kctl = follower;\n\tsrec->follower = *follower;\n\tmemcpy(srec->follower.vd, follower->vd, follower->count * sizeof(*follower->vd));\n\tsrec->master = master_link;\n\tsrec->flags = flags;\n\n\t \n\tfollower->info = follower_info;\n\tfollower->get = follower_get;\n\tfollower->put = follower_put;\n\tif (follower->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK)\n\t\tfollower->tlv.c = follower_tlv_cmd;\n\tfollower->private_data = srec;\n\tfollower->private_free = follower_free;\n\n\tlist_add_tail(&srec->list, &master_link->followers);\n\treturn 0;\n}\nEXPORT_SYMBOL(_snd_ctl_add_follower);\n\n \nint snd_ctl_add_followers(struct snd_card *card, struct snd_kcontrol *master,\n\t\t\t  const char * const *list)\n{\n\tstruct snd_kcontrol *follower;\n\tint err;\n\n\tfor (; *list; list++) {\n\t\tfollower = snd_ctl_find_id_mixer(card, *list);\n\t\tif (follower) {\n\t\t\terr = snd_ctl_add_follower(master, follower);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_add_followers);\n\n \nstatic int master_info(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct link_master *master = snd_kcontrol_chip(kcontrol);\n\tint ret;\n\n\tret = master_init(master);\n\tif (ret < 0)\n\t\treturn ret;\n\tuinfo->type = master->info.type;\n\tuinfo->count = master->info.count;\n\tuinfo->value.integer.min = master->info.min_val;\n\tuinfo->value.integer.max = master->info.max_val;\n\treturn 0;\n}\n\nstatic int master_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct link_master *master = snd_kcontrol_chip(kcontrol);\n\tint err = master_init(master);\n\tif (err < 0)\n\t\treturn err;\n\tucontrol->value.integer.value[0] = master->val;\n\treturn 0;\n}\n\nstatic int sync_followers(struct link_master *master, int old_val, int new_val)\n{\n\tstruct link_follower *follower;\n\tstruct snd_ctl_elem_value *uval;\n\n\tuval = kmalloc(sizeof(*uval), GFP_KERNEL);\n\tif (!uval)\n\t\treturn -ENOMEM;\n\tlist_for_each_entry(follower, &master->followers, list) {\n\t\tmaster->val = old_val;\n\t\tuval->id = follower->follower.id;\n\t\tfollower_get_val(follower, uval);\n\t\tmaster->val = new_val;\n\t\tfollower_put_val(follower, uval);\n\t}\n\tkfree(uval);\n\treturn 0;\n}\n\nstatic int master_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct link_master *master = snd_kcontrol_chip(kcontrol);\n\tint err, new_val, old_val;\n\tbool first_init;\n\n\terr = master_init(master);\n\tif (err < 0)\n\t\treturn err;\n\tfirst_init = err;\n\told_val = master->val;\n\tnew_val = ucontrol->value.integer.value[0];\n\tif (new_val == old_val)\n\t\treturn 0;\n\n\terr = sync_followers(master, old_val, new_val);\n\tif (err < 0)\n\t\treturn err;\n\tif (master->hook && !first_init)\n\t\tmaster->hook(master->hook_private_data, master->val);\n\treturn 1;\n}\n\nstatic void master_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct link_master *master = snd_kcontrol_chip(kcontrol);\n\tstruct link_follower *follower, *n;\n\n\t \n\tlist_for_each_entry_safe(follower, n, &master->followers, list) {\n\t\tstruct snd_kcontrol *sctl = follower->kctl;\n\t\tstruct list_head olist = sctl->list;\n\t\tmemcpy(sctl, &follower->follower, sizeof(*sctl));\n\t\tmemcpy(sctl->vd, follower->follower.vd,\n\t\t       sctl->count * sizeof(*sctl->vd));\n\t\tsctl->list = olist;  \n\t\tkfree(follower);\n\t}\n\tkfree(master);\n}\n\n\n \nstruct snd_kcontrol *snd_ctl_make_virtual_master(char *name,\n\t\t\t\t\t\t const unsigned int *tlv)\n{\n\tstruct link_master *master;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_new knew;\n\n\tmemset(&knew, 0, sizeof(knew));\n\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tknew.name = name;\n\tknew.info = master_info;\n\n\tmaster = kzalloc(sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&master->followers);\n\n\tkctl = snd_ctl_new1(&knew, master);\n\tif (!kctl) {\n\t\tkfree(master);\n\t\treturn NULL;\n\t}\n\t \n\tkctl->info = master_info;\n\tkctl->get = master_get;\n\tkctl->put = master_put;\n\tkctl->private_free = master_free;\n\n\t \n\tif (tlv) {\n\t\tunsigned int type = tlv[SNDRV_CTL_TLVO_TYPE];\n\t\tif (type == SNDRV_CTL_TLVT_DB_SCALE ||\n\t\t    type == SNDRV_CTL_TLVT_DB_MINMAX ||\n\t\t    type == SNDRV_CTL_TLVT_DB_MINMAX_MUTE) {\n\t\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\t\tmemcpy(master->tlv, tlv, sizeof(master->tlv));\n\t\t\tkctl->tlv.p = master->tlv;\n\t\t}\n\t}\n\n\treturn kctl;\n}\nEXPORT_SYMBOL(snd_ctl_make_virtual_master);\n\n \nint snd_ctl_add_vmaster_hook(struct snd_kcontrol *kcontrol,\n\t\t\t     void (*hook)(void *private_data, int),\n\t\t\t     void *private_data)\n{\n\tstruct link_master *master = snd_kcontrol_chip(kcontrol);\n\tmaster->hook = hook;\n\tmaster->hook_private_data = private_data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_add_vmaster_hook);\n\n \nvoid snd_ctl_sync_vmaster(struct snd_kcontrol *kcontrol, bool hook_only)\n{\n\tstruct link_master *master;\n\tbool first_init = false;\n\n\tif (!kcontrol)\n\t\treturn;\n\tmaster = snd_kcontrol_chip(kcontrol);\n\tif (!hook_only) {\n\t\tint err = master_init(master);\n\t\tif (err < 0)\n\t\t\treturn;\n\t\tfirst_init = err;\n\t\terr = sync_followers(master, master->val, master->val);\n\t\tif (err < 0)\n\t\t\treturn;\n\t}\n\n\tif (master->hook && !first_init)\n\t\tmaster->hook(master->hook_private_data, master->val);\n}\nEXPORT_SYMBOL_GPL(snd_ctl_sync_vmaster);\n\n \nint snd_ctl_apply_vmaster_followers(struct snd_kcontrol *kctl,\n\t\t\t\t    int (*func)(struct snd_kcontrol *vfollower,\n\t\t\t\t\t\tstruct snd_kcontrol *follower,\n\t\t\t\t\t\tvoid *arg),\n\t\t\t\t    void *arg)\n{\n\tstruct link_master *master;\n\tstruct link_follower *follower;\n\tint err;\n\n\tmaster = snd_kcontrol_chip(kctl);\n\terr = master_init(master);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(follower, &master->followers, list) {\n\t\terr = func(follower->kctl, &follower->follower, arg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_apply_vmaster_followers);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}