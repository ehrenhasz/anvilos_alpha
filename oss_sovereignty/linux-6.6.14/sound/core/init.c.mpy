{
  "module_name": "init.c",
  "hash_id": "5e405fb0249772fe82b194dabf022ca53a5435969d1b9cee41089155b96537f6",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/init.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/pm.h>\n#include <linux/debugfs.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\n \nstruct snd_monitor_file {\n\tstruct file *file;\n\tconst struct file_operations *disconnected_f_op;\n\tstruct list_head shutdown_list;\t \n\tstruct list_head list;\t \n};\n\nstatic DEFINE_SPINLOCK(shutdown_lock);\nstatic LIST_HEAD(shutdown_files);\n\nstatic const struct file_operations snd_shutdown_f_ops;\n\n \nstatic DECLARE_BITMAP(snd_cards_lock, SNDRV_CARDS);\nstatic struct snd_card *snd_cards[SNDRV_CARDS];\n\nstatic DEFINE_MUTEX(snd_card_mutex);\n\nstatic char *slots[SNDRV_CARDS];\nmodule_param_array(slots, charp, NULL, 0444);\nMODULE_PARM_DESC(slots, \"Module names assigned to the slots.\");\n\n \nstatic int module_slot_match(struct module *module, int idx)\n{\n\tint match = 1;\n#ifdef MODULE\n\tconst char *s1, *s2;\n\n\tif (!module || !*module->name || !slots[idx])\n\t\treturn 0;\n\n\ts1 = module->name;\n\ts2 = slots[idx];\n\tif (*s2 == '!') {\n\t\tmatch = 0;  \n\t\ts2++;\n\t}\n\t \n\tfor (;;) {\n\t\tchar c1 = *s1++;\n\t\tchar c2 = *s2++;\n\t\tif (c1 == '-')\n\t\t\tc1 = '_';\n\t\tif (c2 == '-')\n\t\t\tc2 = '_';\n\t\tif (c1 != c2)\n\t\t\treturn !match;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n#endif  \n\treturn match;\n}\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\nint (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);\nEXPORT_SYMBOL(snd_mixer_oss_notify_callback);\n#endif\n\nstatic int check_empty_slot(struct module *module, int slot)\n{\n\treturn !slots[slot] || !*slots[slot];\n}\n\n \nstatic int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),\n\t\t\t\t struct module *module)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < SNDRV_CARDS; slot++) {\n\t\tif (slot < 32 && !(mask & (1U << slot)))\n\t\t\tcontinue;\n\t\tif (!test_bit(slot, snd_cards_lock)) {\n\t\t\tif (check(module, slot))\n\t\t\t\treturn slot;  \n\t\t}\n\t}\n\treturn mask;  \n}\n\n \nstatic void default_release_alloc(struct device *dev)\n{\n\tkfree(dev);\n}\n\n \nint snd_device_alloc(struct device **dev_p, struct snd_card *card)\n{\n\tstruct device *dev;\n\n\t*dev_p = NULL;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdevice_initialize(dev);\n\tif (card)\n\t\tdev->parent = &card->card_dev;\n\tdev->class = &sound_class;\n\tdev->release = default_release_alloc;\n\t*dev_p = dev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_device_alloc);\n\nstatic int snd_card_init(struct snd_card *card, struct device *parent,\n\t\t\t int idx, const char *xid, struct module *module,\n\t\t\t size_t extra_size);\nstatic int snd_card_do_free(struct snd_card *card);\nstatic const struct attribute_group card_dev_attr_group;\n\nstatic void release_card_device(struct device *dev)\n{\n\tsnd_card_do_free(dev_to_snd_card(dev));\n}\n\n \nint snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\terr = snd_card_init(card, parent, idx, xid, module, extra_size);\n\tif (err < 0)\n\t\treturn err;  \n\n\t*card_ret = card;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_new);\n\nstatic void __snd_card_release(struct device *dev, void *data)\n{\n\tsnd_card_free(data);\n}\n\n \nint snd_devm_card_new(struct device *parent, int idx, const char *xid,\n\t\t      struct module *module, size_t extra_size,\n\t\t      struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\t*card_ret = NULL;\n\tcard = devres_alloc(__snd_card_release, sizeof(*card) + extra_size,\n\t\t\t    GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tcard->managed = true;\n\terr = snd_card_init(card, parent, idx, xid, module, extra_size);\n\tif (err < 0) {\n\t\tdevres_free(card);  \n\t\treturn err;\n\t}\n\n\tdevres_add(parent, card);\n\t*card_ret = card;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_devm_card_new);\n\n \nint snd_card_free_on_error(struct device *dev, int ret)\n{\n\tstruct snd_card *card;\n\n\tif (!ret)\n\t\treturn 0;\n\tcard = devres_find(dev, __snd_card_release, NULL, NULL);\n\tif (card)\n\t\tsnd_card_free(card);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_card_free_on_error);\n\nstatic int snd_card_init(struct snd_card *card, struct device *parent,\n\t\t\t int idx, const char *xid, struct module *module,\n\t\t\t size_t extra_size)\n{\n\tint err;\n\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrscpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0)  \n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0)  \n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t \n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tif (!card->managed)\n\t\t\tkfree(card);  \n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t \n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1;  \n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n#ifdef MODULE\n\tWARN_ON(!module);\n\tcard->module = module;\n#endif\n\tINIT_LIST_HEAD(&card->devices);\n\tinit_rwsem(&card->controls_rwsem);\n\trwlock_init(&card->ctl_files_rwlock);\n\tINIT_LIST_HEAD(&card->controls);\n\tINIT_LIST_HEAD(&card->ctl_files);\n#ifdef CONFIG_SND_CTL_FAST_LOOKUP\n\txa_init(&card->ctl_numids);\n\txa_init(&card->ctl_hash);\n#endif\n\tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n\tmutex_init(&card->memory_mutex);\n#ifdef CONFIG_PM\n\tinit_waitqueue_head(&card->power_sleep);\n\tinit_waitqueue_head(&card->power_ref_sleep);\n\tatomic_set(&card->power_ref, 0);\n#endif\n\tinit_waitqueue_head(&card->remove_sleep);\n\tcard->sync_irq = -1;\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = &sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card->dev_groups;\n\tcard->dev_groups[0] = &card_dev_attr_group;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tsnprintf(card->irq_descr, sizeof(card->irq_descr), \"%s:%s\",\n\t\t dev_driver_string(card->dev), dev_name(&card->card_dev));\n\n\t \n\t \n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\n#ifdef CONFIG_SND_DEBUG\n\tcard->debugfs_root = debugfs_create_dir(dev_name(&card->card_dev),\n\t\t\t\t\t\tsound_debugfs_root);\n#endif\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}\n\n \nstruct snd_card *snd_card_ref(int idx)\n{\n\tstruct snd_card *card;\n\n\tmutex_lock(&snd_card_mutex);\n\tcard = snd_cards[idx];\n\tif (card)\n\t\tget_device(&card->card_dev);\n\tmutex_unlock(&snd_card_mutex);\n\treturn card;\n}\nEXPORT_SYMBOL_GPL(snd_card_ref);\n\n \nint snd_card_locked(int card)\n{\n\tint locked;\n\n\tmutex_lock(&snd_card_mutex);\n\tlocked = test_bit(card, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\treturn locked;\n}\n\nstatic loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic ssize_t snd_disconnect_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *offset)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}\n\nstatic __poll_t snd_disconnect_poll(struct file * file, poll_table * wait)\n{\n\treturn EPOLLERR | EPOLLNVAL;\n}\n\nstatic long snd_disconnect_ioctl(struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENODEV;\n}\n\nstatic int snd_disconnect_fasync(int fd, struct file *file, int on)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct file_operations snd_shutdown_f_ops =\n{\n\t.owner = \tTHIS_MODULE,\n\t.llseek =\tsnd_disconnect_llseek,\n\t.read = \tsnd_disconnect_read,\n\t.write =\tsnd_disconnect_write,\n\t.release =\tsnd_disconnect_release,\n\t.poll =\t\tsnd_disconnect_poll,\n\t.unlocked_ioctl = snd_disconnect_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = snd_disconnect_ioctl,\n#endif\n\t.mmap =\t\tsnd_disconnect_mmap,\n\t.fasync =\tsnd_disconnect_fasync\n};\n\n \nvoid snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tif (!card)\n\t\treturn;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn;\n\t}\n\tcard->shutdown = 1;\n\n\t \n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t \n\t\t \n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t \n\t \n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t \n\tsnd_device_disconnect_all(card);\n\n\tif (card->sync_irq > 0)\n\t\tsynchronize_irq(card->sync_irq);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n\n\t \n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n\tsnd_power_sync_ref(card);\n#endif\n}\nEXPORT_SYMBOL(snd_card_disconnect);\n\n \nvoid snd_card_disconnect_sync(struct snd_card *card)\n{\n\tsnd_card_disconnect(card);\n\n\tspin_lock_irq(&card->files_lock);\n\twait_event_lock_irq(card->remove_sleep,\n\t\t\t    list_empty(&card->files_list),\n\t\t\t    card->files_lock);\n\tspin_unlock_irq(&card->files_lock);\n}\nEXPORT_SYMBOL_GPL(snd_card_disconnect_sync);\n\nstatic int snd_card_do_free(struct snd_card *card)\n{\n\tcard->releasing = true;\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);\n#endif\n\tsnd_device_free_all(card);\n\tif (card->private_free)\n\t\tcard->private_free(card);\n\tif (snd_info_card_free(card) < 0) {\n\t\tdev_warn(card->dev, \"unable to free card info\\n\");\n\t\t \n\t}\n#ifdef CONFIG_SND_DEBUG\n\tdebugfs_remove(card->debugfs_root);\n\tcard->debugfs_root = NULL;\n#endif\n\tif (card->release_completion)\n\t\tcomplete(card->release_completion);\n\tif (!card->managed)\n\t\tkfree(card);\n\treturn 0;\n}\n\n \nvoid snd_card_free_when_closed(struct snd_card *card)\n{\n\tif (!card)\n\t\treturn;\n\n\tsnd_card_disconnect(card);\n\tput_device(&card->card_dev);\n\treturn;\n}\nEXPORT_SYMBOL(snd_card_free_when_closed);\n\n \nvoid snd_card_free(struct snd_card *card)\n{\n\tDECLARE_COMPLETION_ONSTACK(released);\n\n\t \n\tif (card->releasing)\n\t\treturn;\n\n\tcard->release_completion = &released;\n\tsnd_card_free_when_closed(card);\n\n\t \n\twait_for_completion(&released);\n}\nEXPORT_SYMBOL(snd_card_free);\n\n \nstatic const char *retrieve_id_from_card_name(const char *name)\n{\n\tconst char *spos = name;\n\n\twhile (*name) {\n\t\tif (isspace(*name) && isalnum(name[1]))\n\t\t\tspos = name + 1;\n\t\tname++;\n\t}\n\treturn spos;\n}\n\n \nstatic bool card_id_ok(struct snd_card *card, const char *id)\n{\n\tint i;\n\tif (!snd_info_check_reserved_words(id))\n\t\treturn false;\n\tfor (i = 0; i < snd_ecards_limit; i++) {\n\t\tif (snd_cards[i] && snd_cards[i] != card &&\n\t\t    !strcmp(snd_cards[i]->id, id))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void copy_valid_id_string(struct snd_card *card, const char *src,\n\t\t\t\t const char *nid)\n{\n\tchar *id = card->id;\n\n\twhile (*nid && !isalnum(*nid))\n\t\tnid++;\n\tif (isdigit(*nid))\n\t\t*id++ = isalpha(*src) ? *src : 'D';\n\twhile (*nid && (size_t)(id - card->id) < sizeof(card->id) - 1) {\n\t\tif (isalnum(*nid))\n\t\t\t*id++ = *nid;\n\t\tnid++;\n\t}\n\t*id = 0;\n}\n\n \nstatic void snd_card_set_id_no_lock(struct snd_card *card, const char *src,\n\t\t\t\t    const char *nid)\n{\n\tint len, loops;\n\tbool is_default = false;\n\tchar *id;\n\t\n\tcopy_valid_id_string(card, src, nid);\n\tid = card->id;\n\n again:\n\t \n\tif (!*id || !strncmp(id, \"card\", 4)) {\n\t\tstrcpy(id, \"Default\");\n\t\tis_default = true;\n\t}\n\n\tlen = strlen(id);\n\tfor (loops = 0; loops < SNDRV_CARDS; loops++) {\n\t\tchar *spos;\n\t\tchar sfxstr[5];  \n\t\tint sfxlen;\n\n\t\tif (card_id_ok(card, id))\n\t\t\treturn;  \n\n\t\t \n\t\tsprintf(sfxstr, \"_%X\", loops + 1);\n\t\tsfxlen = strlen(sfxstr);\n\t\tif (len + sfxlen >= sizeof(card->id))\n\t\t\tspos = id + sizeof(card->id) - sfxlen - 1;\n\t\telse\n\t\t\tspos = id + len;\n\t\tstrcpy(spos, sfxstr);\n\t}\n\t \n\tif (!is_default) {\n\t\t*id = 0;\n\t\tgoto again;\n\t}\n\t \n\tdev_err(card->dev, \"unable to set card id (%s)\\n\", id);\n\tif (card->proc_root->name)\n\t\tstrscpy(card->id, card->proc_root->name, sizeof(card->id));\n}\n\n \nvoid snd_card_set_id(struct snd_card *card, const char *nid)\n{\n\t \n\tif (card->id[0] != '\\0')\n\t\treturn;\n\tmutex_lock(&snd_card_mutex);\n\tsnd_card_set_id_no_lock(card, nid, nid);\n\tmutex_unlock(&snd_card_mutex);\n}\nEXPORT_SYMBOL(snd_card_set_id);\n\nstatic ssize_t id_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn sysfs_emit(buf, \"%s\\n\", card->id);\n}\n\nstatic ssize_t id_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\tchar buf1[sizeof(card->id)];\n\tsize_t copy = count > sizeof(card->id) - 1 ?\n\t\t\t\t\tsizeof(card->id) - 1 : count;\n\tsize_t idx;\n\tint c;\n\n\tfor (idx = 0; idx < copy; idx++) {\n\t\tc = buf[idx];\n\t\tif (!isalnum(c) && c != '_' && c != '-')\n\t\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf1, buf, copy);\n\tbuf1[copy] = '\\0';\n\tmutex_lock(&snd_card_mutex);\n\tif (!card_id_ok(NULL, buf1)) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn -EEXIST;\n\t}\n\tstrcpy(card->id, buf1);\n\tsnd_info_card_id_change(card);\n\tmutex_unlock(&snd_card_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(id);\n\nstatic ssize_t number_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct snd_card *card = container_of(dev, struct snd_card, card_dev);\n\treturn sysfs_emit(buf, \"%i\\n\", card->number);\n}\n\nstatic DEVICE_ATTR_RO(number);\n\nstatic struct attribute *card_dev_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_number.attr,\n\tNULL\n};\n\nstatic const struct attribute_group card_dev_attr_group = {\n\t.attrs\t= card_dev_attrs,\n};\n\n \nint snd_card_add_dev_attr(struct snd_card *card,\n\t\t\t  const struct attribute_group *group)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(card->dev_groups) - 1; i++) {\n\t\tif (!card->dev_groups[i]) {\n\t\t\tcard->dev_groups[i] = group;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(card->dev, \"Too many groups assigned\\n\");\n\treturn -ENOSPC;\n}\nEXPORT_SYMBOL_GPL(snd_card_add_dev_attr);\n\nstatic void trigger_card_free(void *data)\n{\n\tsnd_card_free(data);\n}\n\n \nint snd_card_register(struct snd_card *card)\n{\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t} else {\n\t\tif (card->managed)\n\t\t\tdevm_remove_action(card->dev, trigger_card_free, card);\n\t}\n\n\tif (card->managed) {\n\t\terr = devm_add_action(card->dev, trigger_card_free, card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_device_register_all(card);\n\tif (err < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\t \n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn snd_info_card_register(card);  \n\t}\n\tif (*card->id) {\n\t\t \n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\t \n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\terr = snd_info_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_register);\n\n#ifdef CONFIG_SND_PROC_FS\nstatic void snd_card_info_read(struct snd_info_entry *entry,\n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tcard = snd_cards[idx];\n\t\tif (card) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%2i [%-15s]: %s - %s\\n\",\n\t\t\t\t\tidx,\n\t\t\t\t\tcard->id,\n\t\t\t\t\tcard->driver,\n\t\t\t\t\tcard->shortname);\n\t\t\tsnd_iprintf(buffer, \"                      %s\\n\",\n\t\t\t\t\tcard->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count)\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n}\n\n#ifdef CONFIG_SND_OSSEMUL\nvoid snd_card_info_read_oss(struct snd_info_buffer *buffer)\n{\n\tint idx, count;\n\tstruct snd_card *card;\n\n\tfor (idx = count = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tcard = snd_cards[idx];\n\t\tif (card) {\n\t\t\tcount++;\n\t\t\tsnd_iprintf(buffer, \"%s\\n\", card->longname);\n\t\t}\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n\tif (!count) {\n\t\tsnd_iprintf(buffer, \"--- no soundcards ---\\n\");\n\t}\n}\n\n#endif\n\n#ifdef MODULE\nstatic void snd_card_module_info_read(struct snd_info_entry *entry,\n\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tint idx;\n\tstruct snd_card *card;\n\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tmutex_lock(&snd_card_mutex);\n\t\tcard = snd_cards[idx];\n\t\tif (card)\n\t\t\tsnd_iprintf(buffer, \"%2i %s\\n\",\n\t\t\t\t    idx, card->module->name);\n\t\tmutex_unlock(&snd_card_mutex);\n\t}\n}\n#endif\n\nint __init snd_card_info_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"cards\", NULL);\n\tif (! entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_card_info_read;\n\tif (snd_info_register(entry) < 0)\n\t\treturn -ENOMEM;  \n\n#ifdef MODULE\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"modules\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_card_module_info_read;\n\tif (snd_info_register(entry) < 0)\n\t\treturn -ENOMEM;  \n#endif\n\n\treturn 0;\n}\n#endif  \n\n \n  \nint snd_component_add(struct snd_card *card, const char *component)\n{\n\tchar *ptr;\n\tint len = strlen(component);\n\n\tptr = strstr(card->components, component);\n\tif (ptr != NULL) {\n\t\tif (ptr[len] == '\\0' || ptr[len] == ' ')\t \n\t\t\treturn 1;\n\t}\n\tif (strlen(card->components) + 1 + len + 1 > sizeof(card->components)) {\n\t\tsnd_BUG();\n\t\treturn -ENOMEM;\n\t}\n\tif (card->components[0] != '\\0')\n\t\tstrcat(card->components, \" \");\n\tstrcat(card->components, component);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_component_add);\n\n \nint snd_card_file_add(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tmfile = kmalloc(sizeof(*mfile), GFP_KERNEL);\n\tif (mfile == NULL)\n\t\treturn -ENOMEM;\n\tmfile->file = file;\n\tmfile->disconnected_f_op = NULL;\n\tINIT_LIST_HEAD(&mfile->shutdown_list);\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\tkfree(mfile);\n\t\treturn -ENODEV;\n\t}\n\tlist_add(&mfile->list, &card->files_list);\n\tget_device(&card->card_dev);\n\tspin_unlock(&card->files_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_file_add);\n\n \nint snd_card_file_remove(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile, *found = NULL;\n\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tif (mfile->file == file) {\n\t\t\tlist_del(&mfile->list);\n\t\t\tspin_lock(&shutdown_lock);\n\t\t\tlist_del(&mfile->shutdown_list);\n\t\t\tspin_unlock(&shutdown_lock);\n\t\t\tif (mfile->disconnected_f_op)\n\t\t\t\tfops_put(mfile->disconnected_f_op);\n\t\t\tfound = mfile;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&card->files_list))\n\t\twake_up_all(&card->remove_sleep);\n\tspin_unlock(&card->files_lock);\n\tif (!found) {\n\t\tdev_err(card->dev, \"card file remove problem (%p)\\n\", file);\n\t\treturn -ENOENT;\n\t}\n\tkfree(found);\n\tput_device(&card->card_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_card_file_remove);\n\n#ifdef CONFIG_PM\n \nint snd_power_ref_and_wait(struct snd_card *card)\n{\n\tsnd_power_ref(card);\n\tif (snd_power_get_state(card) == SNDRV_CTL_POWER_D0)\n\t\treturn 0;\n\twait_event_cmd(card->power_sleep,\n\t\t       card->shutdown ||\n\t\t       snd_power_get_state(card) == SNDRV_CTL_POWER_D0,\n\t\t       snd_power_unref(card), snd_power_ref(card));\n\treturn card->shutdown ? -ENODEV : 0;\n}\nEXPORT_SYMBOL_GPL(snd_power_ref_and_wait);\n\n \nint snd_power_wait(struct snd_card *card)\n{\n\tint ret;\n\n\tret = snd_power_ref_and_wait(card);\n\tsnd_power_unref(card);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_power_wait);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}