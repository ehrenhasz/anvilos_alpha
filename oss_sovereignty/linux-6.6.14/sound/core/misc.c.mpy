{
  "module_name": "misc.c",
  "hash_id": "ef3d2b466c92ca1dcd83c4dc89e86333160adb57030ca0952883be98a8b47f1e",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/misc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/fs.h>\n#include <sound/core.h>\n\n#ifdef CONFIG_SND_DEBUG\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n#define DEFAULT_DEBUG_LEVEL\t2\n#else\n#define DEFAULT_DEBUG_LEVEL\t1\n#endif\n\nstatic int debug = DEFAULT_DEBUG_LEVEL;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0 = disable)\");\n\n#endif  \n\nvoid release_and_free_resource(struct resource *res)\n{\n\tif (res) {\n\t\trelease_resource(res);\n\t\tkfree(res);\n\t}\n}\nEXPORT_SYMBOL(release_and_free_resource);\n\n#ifdef CONFIG_SND_VERBOSE_PRINTK\n \nstatic const char *sanity_file_name(const char *path)\n{\n\tif (*path == '/')\n\t\treturn strrchr(path, '/') + 1;\n\telse\n\t\treturn path;\n}\n#endif\n\n#if defined(CONFIG_SND_DEBUG) || defined(CONFIG_SND_VERBOSE_PRINTK)\nvoid __snd_printk(unsigned int level, const char *path, int line,\n\t\t  const char *format, ...)\n{\n\tva_list args;\n#ifdef CONFIG_SND_VERBOSE_PRINTK\n\tint kern_level;\n\tstruct va_format vaf;\n\tchar verbose_fmt[] = KERN_DEFAULT \"ALSA %s:%d %pV\";\n\tbool level_found = false;\n#endif\n\n#ifdef CONFIG_SND_DEBUG\n\tif (debug < level)\n\t\treturn;\n#endif\n\n\tva_start(args, format);\n#ifdef CONFIG_SND_VERBOSE_PRINTK\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\twhile ((kern_level = printk_get_level(vaf.fmt)) != 0) {\n\t\tconst char *end_of_header = printk_skip_level(vaf.fmt);\n\n\t\t \n\t\tif (kern_level >= '0' && kern_level <= '7') {\n\t\t\tmemcpy(verbose_fmt, vaf.fmt, end_of_header - vaf.fmt);\n\t\t\tlevel_found = true;\n\t\t}\n\n\t\tvaf.fmt = end_of_header;\n\t}\n\n\tif (!level_found && level)\n\t\tmemcpy(verbose_fmt, KERN_DEBUG, sizeof(KERN_DEBUG) - 1);\n\n\tprintk(verbose_fmt, sanity_file_name(path), line, &vaf);\n#else\n\tvprintk(format, args);\n#endif\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(__snd_printk);\n#endif\n\n#ifdef CONFIG_PCI\n#include <linux/pci.h>\n \nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup_id(u16 vendor, u16 device,\n\t\t\tconst struct snd_pci_quirk *list)\n{\n\tconst struct snd_pci_quirk *q;\n\n\tfor (q = list; q->subvendor || q->subdevice; q++) {\n\t\tif (q->subvendor != vendor)\n\t\t\tcontinue;\n\t\tif (!q->subdevice ||\n\t\t    (device & q->subdevice_mask) == q->subdevice)\n\t\t\treturn q;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(snd_pci_quirk_lookup_id);\n\n \nconst struct snd_pci_quirk *\nsnd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list)\n{\n\tif (!pci)\n\t\treturn NULL;\n\treturn snd_pci_quirk_lookup_id(pci->subsystem_vendor,\n\t\t\t\t       pci->subsystem_device,\n\t\t\t\t       list);\n}\nEXPORT_SYMBOL(snd_pci_quirk_lookup);\n#endif\n\n \nstruct snd_fasync {\n\tstruct fasync_struct *fasync;\n\tint signal;\n\tint poll;\n\tint on;\n\tstruct list_head list;\n};\n\nstatic DEFINE_SPINLOCK(snd_fasync_lock);\nstatic LIST_HEAD(snd_fasync_list);\n\nstatic void snd_fasync_work_fn(struct work_struct *work)\n{\n\tstruct snd_fasync *fasync;\n\n\tspin_lock_irq(&snd_fasync_lock);\n\twhile (!list_empty(&snd_fasync_list)) {\n\t\tfasync = list_first_entry(&snd_fasync_list, struct snd_fasync, list);\n\t\tlist_del_init(&fasync->list);\n\t\tspin_unlock_irq(&snd_fasync_lock);\n\t\tif (fasync->on)\n\t\t\tkill_fasync(&fasync->fasync, fasync->signal, fasync->poll);\n\t\tspin_lock_irq(&snd_fasync_lock);\n\t}\n\tspin_unlock_irq(&snd_fasync_lock);\n}\n\nstatic DECLARE_WORK(snd_fasync_work, snd_fasync_work_fn);\n\nint snd_fasync_helper(int fd, struct file *file, int on,\n\t\t      struct snd_fasync **fasyncp)\n{\n\tstruct snd_fasync *fasync = NULL;\n\n\tif (on) {\n\t\tfasync = kzalloc(sizeof(*fasync), GFP_KERNEL);\n\t\tif (!fasync)\n\t\t\treturn -ENOMEM;\n\t\tINIT_LIST_HEAD(&fasync->list);\n\t}\n\n\tspin_lock_irq(&snd_fasync_lock);\n\tif (*fasyncp) {\n\t\tkfree(fasync);\n\t\tfasync = *fasyncp;\n\t} else {\n\t\tif (!fasync) {\n\t\t\tspin_unlock_irq(&snd_fasync_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t*fasyncp = fasync;\n\t}\n\tfasync->on = on;\n\tspin_unlock_irq(&snd_fasync_lock);\n\treturn fasync_helper(fd, file, on, &fasync->fasync);\n}\nEXPORT_SYMBOL_GPL(snd_fasync_helper);\n\nvoid snd_kill_fasync(struct snd_fasync *fasync, int signal, int poll)\n{\n\tunsigned long flags;\n\n\tif (!fasync || !fasync->on)\n\t\treturn;\n\tspin_lock_irqsave(&snd_fasync_lock, flags);\n\tfasync->signal = signal;\n\tfasync->poll = poll;\n\tlist_move(&fasync->list, &snd_fasync_list);\n\tschedule_work(&snd_fasync_work);\n\tspin_unlock_irqrestore(&snd_fasync_lock, flags);\n}\nEXPORT_SYMBOL_GPL(snd_kill_fasync);\n\nvoid snd_fasync_free(struct snd_fasync *fasync)\n{\n\tif (!fasync)\n\t\treturn;\n\tfasync->on = 0;\n\tflush_work(&snd_fasync_work);\n\tkfree(fasync);\n}\nEXPORT_SYMBOL_GPL(snd_fasync_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}