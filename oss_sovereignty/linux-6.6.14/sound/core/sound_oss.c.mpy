{
  "module_name": "sound_oss.c",
  "hash_id": "9bb6572be36cade43645d6f9aaf8fdc45c6eea63fbee9546867b9601b18cfad5",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/sound_oss.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <linux/sound.h>\n#include <linux/mutex.h>\n\n#define SNDRV_OSS_MINORS 256\n\nstatic struct snd_minor *snd_oss_minors[SNDRV_OSS_MINORS];\nstatic DEFINE_MUTEX(sound_oss_mutex);\n\n \nvoid *snd_lookup_oss_minor_data(unsigned int minor, int type)\n{\n\tstruct snd_minor *mreg;\n\tvoid *private_data;\n\n\tif (minor >= ARRAY_SIZE(snd_oss_minors))\n\t\treturn NULL;\n\tmutex_lock(&sound_oss_mutex);\n\tmreg = snd_oss_minors[minor];\n\tif (mreg && mreg->type == type) {\n\t\tprivate_data = mreg->private_data;\n\t\tif (private_data && mreg->card_ptr)\n\t\t\tget_device(&mreg->card_ptr->card_dev);\n\t} else\n\t\tprivate_data = NULL;\n\tmutex_unlock(&sound_oss_mutex);\n\treturn private_data;\n}\nEXPORT_SYMBOL(snd_lookup_oss_minor_data);\n\nstatic int snd_oss_kernel_minor(int type, struct snd_card *card, int dev)\n{\n\tint minor;\n\n\tswitch (type) {\n\tcase SNDRV_OSS_DEVICE_TYPE_MIXER:\n\t\tif (snd_BUG_ON(!card || dev < 0 || dev > 1))\n\t\t\treturn -EINVAL;\n\t\tminor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_MIXER1 : SNDRV_MINOR_OSS_MIXER));\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_SEQUENCER:\n\t\tminor = SNDRV_MINOR_OSS_SEQUENCER;\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_MUSIC:\n\t\tminor = SNDRV_MINOR_OSS_MUSIC;\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_PCM:\n\t\tif (snd_BUG_ON(!card || dev < 0 || dev > 1))\n\t\t\treturn -EINVAL;\n\t\tminor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_PCM1 : SNDRV_MINOR_OSS_PCM));\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_MIDI:\n\t\tif (snd_BUG_ON(!card || dev < 0 || dev > 1))\n\t\t\treturn -EINVAL;\n\t\tminor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_MIDI1 : SNDRV_MINOR_OSS_MIDI));\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_DMFM:\n\t\tminor = SNDRV_MINOR_OSS(card->number, SNDRV_MINOR_OSS_DMFM);\n\t\tbreak;\n\tcase SNDRV_OSS_DEVICE_TYPE_SNDSTAT:\n\t\tminor = SNDRV_MINOR_OSS_SNDSTAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (minor < 0 || minor >= SNDRV_OSS_MINORS)\n\t\treturn -EINVAL;\n\treturn minor;\n}\n\nint snd_register_oss_device(int type, struct snd_card *card, int dev,\n\t\t\t    const struct file_operations *f_ops, void *private_data)\n{\n\tint minor = snd_oss_kernel_minor(type, card, dev);\n\tint minor_unit;\n\tstruct snd_minor *preg;\n\tint cidx = SNDRV_MINOR_OSS_CARD(minor);\n\tint track2 = -1;\n\tint register1 = -1, register2 = -1;\n\tstruct device *carddev = snd_card_get_device_link(card);\n\n\tif (card && card->number >= SNDRV_MINOR_OSS_DEVICES)\n\t\treturn 0;  \n\tif (minor < 0)\n\t\treturn minor;\n\tpreg = kmalloc(sizeof(struct snd_minor), GFP_KERNEL);\n\tif (preg == NULL)\n\t\treturn -ENOMEM;\n\tpreg->type = type;\n\tpreg->card = card ? card->number : -1;\n\tpreg->device = dev;\n\tpreg->f_ops = f_ops;\n\tpreg->private_data = private_data;\n\tpreg->card_ptr = card;\n\tmutex_lock(&sound_oss_mutex);\n\tsnd_oss_minors[minor] = preg;\n\tminor_unit = SNDRV_MINOR_OSS_DEVICE(minor);\n\tswitch (minor_unit) {\n\tcase SNDRV_MINOR_OSS_PCM:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_AUDIO);\n\t\tbreak;\n\tcase SNDRV_MINOR_OSS_MIDI:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_DMMIDI);\n\t\tbreak;\n\tcase SNDRV_MINOR_OSS_MIDI1:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_DMMIDI1);\n\t\tbreak;\n\t}\n\tregister1 = register_sound_special_device(f_ops, minor, carddev);\n\tif (register1 != minor)\n\t\tgoto __end;\n\tif (track2 >= 0) {\n\t\tregister2 = register_sound_special_device(f_ops, track2,\n\t\t\t\t\t\t\t  carddev);\n\t\tif (register2 != track2)\n\t\t\tgoto __end;\n\t\tsnd_oss_minors[track2] = preg;\n\t}\n\tmutex_unlock(&sound_oss_mutex);\n\treturn 0;\n\n      __end:\n      \tif (register2 >= 0)\n      \t\tunregister_sound_special(register2);\n      \tif (register1 >= 0)\n      \t\tunregister_sound_special(register1);\n\tsnd_oss_minors[minor] = NULL;\n\tmutex_unlock(&sound_oss_mutex);\n\tkfree(preg);\n      \treturn -EBUSY;\n}\nEXPORT_SYMBOL(snd_register_oss_device);\n\nint snd_unregister_oss_device(int type, struct snd_card *card, int dev)\n{\n\tint minor = snd_oss_kernel_minor(type, card, dev);\n\tint cidx = SNDRV_MINOR_OSS_CARD(minor);\n\tint track2 = -1;\n\tstruct snd_minor *mptr;\n\n\tif (card && card->number >= SNDRV_MINOR_OSS_DEVICES)\n\t\treturn 0;\n\tif (minor < 0)\n\t\treturn minor;\n\tmutex_lock(&sound_oss_mutex);\n\tmptr = snd_oss_minors[minor];\n\tif (mptr == NULL) {\n\t\tmutex_unlock(&sound_oss_mutex);\n\t\treturn -ENOENT;\n\t}\n\tswitch (SNDRV_MINOR_OSS_DEVICE(minor)) {\n\tcase SNDRV_MINOR_OSS_PCM:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_AUDIO);\n\t\tbreak;\n\tcase SNDRV_MINOR_OSS_MIDI:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_DMMIDI);\n\t\tbreak;\n\tcase SNDRV_MINOR_OSS_MIDI1:\n\t\ttrack2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_DMMIDI1);\n\t\tbreak;\n\t}\n\tif (track2 >= 0)\n\t\tsnd_oss_minors[track2] = NULL;\n\tsnd_oss_minors[minor] = NULL;\n\tmutex_unlock(&sound_oss_mutex);\n\n\t \n\tunregister_sound_special(minor);\n\tif (track2 >= 0)\n\t\tunregister_sound_special(track2);\n\n\tkfree(mptr);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_unregister_oss_device);\n\n \n\n#ifdef CONFIG_SND_PROC_FS\nstatic const char *snd_oss_device_type_name(int type)\n{\n\tswitch (type) {\n\tcase SNDRV_OSS_DEVICE_TYPE_MIXER:\n\t\treturn \"mixer\";\n\tcase SNDRV_OSS_DEVICE_TYPE_SEQUENCER:\n\tcase SNDRV_OSS_DEVICE_TYPE_MUSIC:\n\t\treturn \"sequencer\";\n\tcase SNDRV_OSS_DEVICE_TYPE_PCM:\n\t\treturn \"digital audio\";\n\tcase SNDRV_OSS_DEVICE_TYPE_MIDI:\n\t\treturn \"raw midi\";\n\tcase SNDRV_OSS_DEVICE_TYPE_DMFM:\n\t\treturn \"hardware dependent\";\n\tdefault:\n\t\treturn \"?\";\n\t}\n}\n\nstatic void snd_minor_info_oss_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tint minor;\n\tstruct snd_minor *mptr;\n\n\tmutex_lock(&sound_oss_mutex);\n\tfor (minor = 0; minor < SNDRV_OSS_MINORS; ++minor) {\n\t\tmptr = snd_oss_minors[minor];\n\t\tif (!mptr)\n\t\t\tcontinue;\n\t\tif (mptr->card >= 0)\n\t\t\tsnd_iprintf(buffer, \"%3i: [%i-%2i]: %s\\n\", minor,\n\t\t\t\t    mptr->card, mptr->device,\n\t\t\t\t    snd_oss_device_type_name(mptr->type));\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"%3i:       : %s\\n\", minor,\n\t\t\t\t    snd_oss_device_type_name(mptr->type));\n\t}\n\tmutex_unlock(&sound_oss_mutex);\n}\n\n\nint __init snd_minor_info_oss_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"devices\", snd_oss_root);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_minor_info_oss_read;\n\treturn snd_info_register(entry);  \n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}