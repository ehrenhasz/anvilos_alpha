{
  "module_name": "pcm_lib.c",
  "hash_id": "da2bc95bc3938eb8891a43afbb85f40a678920ce5728a53dec4a2c7d2530b992",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_lib.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/timer.h>\n\n#include \"pcm_local.h\"\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define CREATE_TRACE_POINTS\n#include \"pcm_trace.h\"\n#else\n#define trace_hwptr(substream, pos, in_interrupt)\n#define trace_xrun(substream)\n#define trace_hw_ptr_error(substream, reason)\n#define trace_applptr(substream, prev, curr)\n#endif\n\nstatic int fill_silence_frames(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_uframes_t off, snd_pcm_uframes_t frames);\n\n\nstatic inline void update_silence_vars(struct snd_pcm_runtime *runtime,\n\t\t\t\t       snd_pcm_uframes_t ptr,\n\t\t\t\t       snd_pcm_uframes_t new_ptr)\n{\n\tsnd_pcm_sframes_t delta;\n\n\tdelta = new_ptr - ptr;\n\tif (delta == 0)\n\t\treturn;\n\tif (delta < 0)\n\t\tdelta += runtime->boundary;\n\tif ((snd_pcm_uframes_t)delta < runtime->silence_filled)\n\t\truntime->silence_filled -= delta;\n\telse\n\t\truntime->silence_filled = 0;\n\truntime->silence_start = new_ptr;\n}\n\n \nvoid snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t frames, ofs, transfer;\n\tint err;\n\n\tif (runtime->silence_size < runtime->boundary) {\n\t\tsnd_pcm_sframes_t noise_dist;\n\t\tsnd_pcm_uframes_t appl_ptr = READ_ONCE(runtime->control->appl_ptr);\n\t\tupdate_silence_vars(runtime, runtime->silence_start, appl_ptr);\n\t\t \n\t\tif (new_hw_ptr == ULONG_MAX)\n\t\t\tnew_hw_ptr = runtime->status->hw_ptr;\n\t\t \n\t\tnoise_dist = appl_ptr - new_hw_ptr;\n\t\tif (noise_dist < 0)\n\t\t\tnoise_dist += runtime->boundary;\n\t\t \n\t\tnoise_dist += runtime->silence_filled;\n\t\tif (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)\n\t\t\treturn;\n\t\tframes = runtime->silence_threshold - noise_dist;\n\t\tif (frames > runtime->silence_size)\n\t\t\tframes = runtime->silence_size;\n\t} else {\n\t\t \n\t\tsnd_pcm_uframes_t hw_ptr = runtime->status->hw_ptr;\n\t\tif (new_hw_ptr == ULONG_MAX) {\n\t\t\t \n\t\t\tsnd_pcm_sframes_t avail = runtime->control->appl_ptr - hw_ptr;\n\t\t\tif (avail < 0)\n\t\t\t\tavail += runtime->boundary;\n\t\t\t \n\t\t\truntime->silence_filled = avail > runtime->buffer_size ? 0 : avail;\n\t\t\truntime->silence_start = hw_ptr;\n\t\t} else {\n\t\t\t \n\t\t\tupdate_silence_vars(runtime, hw_ptr, new_hw_ptr);\n\t\t}\n\t\t \n\t\tframes = runtime->buffer_size - runtime->silence_filled;\n\t}\n\tif (snd_BUG_ON(frames > runtime->buffer_size))\n\t\treturn;\n\tif (frames == 0)\n\t\treturn;\n\tofs = (runtime->silence_start + runtime->silence_filled) % runtime->buffer_size;\n\tdo {\n\t\ttransfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;\n\t\terr = fill_silence_frames(substream, ofs, transfer);\n\t\tsnd_BUG_ON(err < 0);\n\t\truntime->silence_filled += transfer;\n\t\tframes -= transfer;\n\t\tofs = 0;\n\t} while (frames > 0);\n\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n}\n\n#ifdef CONFIG_SND_DEBUG\nvoid snd_pcm_debug_name(struct snd_pcm_substream *substream,\n\t\t\t   char *name, size_t len)\n{\n\tsnprintf(name, len, \"pcmC%dD%d%c:%d\",\n\t\t substream->pcm->card->number,\n\t\t substream->pcm->device,\n\t\t substream->stream ? 'c' : 'p',\n\t\t substream->number);\n}\nEXPORT_SYMBOL(snd_pcm_debug_name);\n#endif\n\n#define XRUN_DEBUG_BASIC\t(1<<0)\n#define XRUN_DEBUG_STACK\t(1<<1)\t \n#define XRUN_DEBUG_JIFFIESCHECK\t(1<<2)\t \n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\n#define xrun_debug(substream, mask) \\\n\t\t\t((substream)->pstr->xrun_debug & (mask))\n#else\n#define xrun_debug(substream, mask)\t0\n#endif\n\n#define dump_stack_on_xrun(substream) do {\t\t\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_STACK))\t\\\n\t\t\tdump_stack();\t\t\t\t\\\n\t} while (0)\n\n \nvoid __snd_pcm_xrun(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\ttrace_xrun(substream);\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\tstruct timespec64 tstamp;\n\n\t\tsnd_pcm_gettime(runtime, &tstamp);\n\t\truntime->status->tstamp.tv_sec = tstamp.tv_sec;\n\t\truntime->status->tstamp.tv_nsec = tstamp.tv_nsec;\n\t}\n\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\n\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\n\t\tchar name[16];\n\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\tpcm_warn(substream->pcm, \"XRUN: %s\\n\", name);\n\t\tdump_stack_on_xrun(substream);\n\t}\n}\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define hw_ptr_error(substream, in_interrupt, reason, fmt, args...)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttrace_hw_ptr_error(substream, reason);\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\t\t\\\n\t\t\tpr_err_ratelimited(\"ALSA: PCM: [%c] \" reason \": \" fmt, \\\n\t\t\t\t\t   (in_interrupt) ? 'Q' : 'P', ##args);\t\\\n\t\t\tdump_stack_on_xrun(substream);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#else  \n\n#define hw_ptr_error(substream, fmt, args...) do { } while (0)\n\n#endif\n\nint snd_pcm_update_state(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_uframes_t avail;\n\n\tavail = snd_pcm_avail(substream);\n\tif (avail > runtime->avail_max)\n\t\truntime->avail_max = avail;\n\tif (runtime->state == SNDRV_PCM_STATE_DRAINING) {\n\t\tif (avail >= runtime->buffer_size) {\n\t\t\tsnd_pcm_drain_done(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t} else {\n\t\tif (avail >= runtime->stop_threshold) {\n\t\t\t__snd_pcm_xrun(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tif (runtime->twake) {\n\t\tif (avail >= runtime->twake)\n\t\t\twake_up(&runtime->tsleep);\n\t} else if (avail >= runtime->control->avail_min)\n\t\twake_up(&runtime->sleep);\n\treturn 0;\n}\n\nstatic void update_audio_tstamp(struct snd_pcm_substream *substream,\n\t\t\t\tstruct timespec64 *curr_tstamp,\n\t\t\t\tstruct timespec64 *audio_tstamp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu64 audio_frames, audio_nsecs;\n\tstruct timespec64 driver_tstamp;\n\n\tif (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)\n\t\treturn;\n\n\tif (!(substream->ops->get_time_info) ||\n\t\t(runtime->audio_tstamp_report.actual_type ==\n\t\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\n\t\t \n\n\t\taudio_frames = runtime->hw_ptr_wrap + runtime->status->hw_ptr;\n\n\t\tif (runtime->audio_tstamp_config.report_delay) {\n\t\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\taudio_frames -=  runtime->delay;\n\t\t\telse\n\t\t\t\taudio_frames +=  runtime->delay;\n\t\t}\n\t\taudio_nsecs = div_u64(audio_frames * 1000000000LL,\n\t\t\t\truntime->rate);\n\t\t*audio_tstamp = ns_to_timespec64(audio_nsecs);\n\t}\n\n\tif (runtime->status->audio_tstamp.tv_sec != audio_tstamp->tv_sec ||\n\t    runtime->status->audio_tstamp.tv_nsec != audio_tstamp->tv_nsec) {\n\t\truntime->status->audio_tstamp.tv_sec = audio_tstamp->tv_sec;\n\t\truntime->status->audio_tstamp.tv_nsec = audio_tstamp->tv_nsec;\n\t\truntime->status->tstamp.tv_sec = curr_tstamp->tv_sec;\n\t\truntime->status->tstamp.tv_nsec = curr_tstamp->tv_nsec;\n\t}\n\n\n\t \n\tsnd_pcm_gettime(substream->runtime, &driver_tstamp);\n\truntime->driver_tstamp = driver_tstamp;\n}\n\nstatic int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,\n\t\t\t\t  unsigned int in_interrupt)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t pos;\n\tsnd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;\n\tsnd_pcm_sframes_t hdelta, delta;\n\tunsigned long jdelta;\n\tunsigned long curr_jiffies;\n\tstruct timespec64 curr_tstamp;\n\tstruct timespec64 audio_tstamp;\n\tint crossed_boundary = 0;\n\n\told_hw_ptr = runtime->status->hw_ptr;\n\n\t \n\tpos = substream->ops->pointer(substream);\n\tcurr_jiffies = jiffies;\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\tif ((substream->ops->get_time_info) &&\n\t\t\t(runtime->audio_tstamp_config.type_requested != SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\t\t\tsubstream->ops->get_time_info(substream, &curr_tstamp,\n\t\t\t\t\t\t&audio_tstamp,\n\t\t\t\t\t\t&runtime->audio_tstamp_config,\n\t\t\t\t\t\t&runtime->audio_tstamp_report);\n\n\t\t\t \n\t\t\tif (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)\n\t\t\t\tsnd_pcm_gettime(runtime, &curr_tstamp);\n\t\t} else\n\t\t\tsnd_pcm_gettime(runtime, &curr_tstamp);\n\t}\n\n\tif (pos == SNDRV_PCM_POS_XRUN) {\n\t\t__snd_pcm_xrun(substream);\n\t\treturn -EPIPE;\n\t}\n\tif (pos >= runtime->buffer_size) {\n\t\tif (printk_ratelimit()) {\n\t\t\tchar name[16];\n\t\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\t\tpcm_err(substream->pcm,\n\t\t\t\t\"invalid position: %s, pos = %ld, buffer size = %ld, period size = %ld\\n\",\n\t\t\t\tname, pos, runtime->buffer_size,\n\t\t\t\truntime->period_size);\n\t\t}\n\t\tpos = 0;\n\t}\n\tpos -= pos % runtime->min_align;\n\ttrace_hwptr(substream, pos, in_interrupt);\n\thw_base = runtime->hw_ptr_base;\n\tnew_hw_ptr = hw_base + pos;\n\tif (in_interrupt) {\n\t\t \n\t\t \n\t\tdelta = runtime->hw_ptr_interrupt + runtime->period_size;\n\t\tif (delta > new_hw_ptr) {\n\t\t\t \n\t\t\thdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\t\tif (hdelta > runtime->hw_ptr_buffer_jiffies/2 + 1) {\n\t\t\t\thw_base += runtime->buffer_size;\n\t\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\t\thw_base = 0;\n\t\t\t\t\tcrossed_boundary++;\n\t\t\t\t}\n\t\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\t\tgoto __delta;\n\t\t\t}\n\t\t}\n\t}\n\t \n\t \n\tif (new_hw_ptr < old_hw_ptr) {\n\t\thw_base += runtime->buffer_size;\n\t\tif (hw_base >= runtime->boundary) {\n\t\t\thw_base = 0;\n\t\t\tcrossed_boundary++;\n\t\t}\n\t\tnew_hw_ptr = hw_base + pos;\n\t}\n      __delta:\n\tdelta = new_hw_ptr - old_hw_ptr;\n\tif (delta < 0)\n\t\tdelta += runtime->boundary;\n\n\tif (runtime->no_period_wakeup) {\n\t\tsnd_pcm_sframes_t xrun_threshold;\n\t\t \n\t\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\tif (jdelta < runtime->hw_ptr_buffer_jiffies / 2)\n\t\t\tgoto no_delta_check;\n\t\thdelta = jdelta - delta * HZ / runtime->rate;\n\t\txrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;\n\t\twhile (hdelta > xrun_threshold) {\n\t\t\tdelta += runtime->buffer_size;\n\t\t\thw_base += runtime->buffer_size;\n\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\thw_base = 0;\n\t\t\t\tcrossed_boundary++;\n\t\t\t}\n\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\thdelta -= runtime->hw_ptr_buffer_jiffies;\n\t\t}\n\t\tgoto no_delta_check;\n\t}\n\n\t \n\tif (delta >= runtime->buffer_size + runtime->period_size) {\n\t\thw_ptr_error(substream, in_interrupt, \"Unexpected hw_ptr\",\n\t\t\t     \"(stream=%i, pos=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)pos,\n\t\t\t     (long)new_hw_ptr, (long)old_hw_ptr);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))\n\t\tgoto no_jiffies_check;\n\n\t \n\tif (runtime->hw.info & SNDRV_PCM_INFO_BATCH)\n\t\tgoto no_jiffies_check;\n\thdelta = delta;\n\tif (hdelta < runtime->delay)\n\t\tgoto no_jiffies_check;\n\thdelta -= runtime->delay;\n\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\tif (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {\n\t\tdelta = jdelta /\n\t\t\t(((runtime->period_size * HZ) / runtime->rate)\n\t\t\t\t\t\t\t\t+ HZ/100);\n\t\t \n\t\tnew_hw_ptr = old_hw_ptr;\n\t\thw_base = delta;\n\t\t \n\t\t \n\t\twhile (delta > 0) {\n\t\t\tnew_hw_ptr += runtime->period_size;\n\t\t\tif (new_hw_ptr >= runtime->boundary) {\n\t\t\t\tnew_hw_ptr -= runtime->boundary;\n\t\t\t\tcrossed_boundary--;\n\t\t\t}\n\t\t\tdelta--;\n\t\t}\n\t\t \n\t\thw_ptr_error(substream, in_interrupt, \"hw_ptr skipping\",\n\t\t\t     \"(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\\n\",\n\t\t\t     (long)pos, (long)hdelta,\n\t\t\t     (long)runtime->period_size, jdelta,\n\t\t\t     ((hdelta * HZ) / runtime->rate), hw_base,\n\t\t\t     (unsigned long)old_hw_ptr,\n\t\t\t     (unsigned long)new_hw_ptr);\n\t\t \n\t\tdelta = 0;\n\t\thw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);\n\t}\n no_jiffies_check:\n\tif (delta > runtime->period_size + runtime->period_size / 2) {\n\t\thw_ptr_error(substream, in_interrupt,\n\t\t\t     \"Lost interrupts?\",\n\t\t\t     \"(stream=%i, delta=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)delta,\n\t\t\t     (long)new_hw_ptr,\n\t\t\t     (long)old_hw_ptr);\n\t}\n\n no_delta_check:\n\tif (runtime->status->hw_ptr == new_hw_ptr) {\n\t\truntime->hw_ptr_jiffies = curr_jiffies;\n\t\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\t\treturn 0;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    runtime->silence_size > 0)\n\t\tsnd_pcm_playback_silence(substream, new_hw_ptr);\n\n\tif (in_interrupt) {\n\t\tdelta = new_hw_ptr - runtime->hw_ptr_interrupt;\n\t\tif (delta < 0)\n\t\t\tdelta += runtime->boundary;\n\t\tdelta -= (snd_pcm_uframes_t)delta % runtime->period_size;\n\t\truntime->hw_ptr_interrupt += delta;\n\t\tif (runtime->hw_ptr_interrupt >= runtime->boundary)\n\t\t\truntime->hw_ptr_interrupt -= runtime->boundary;\n\t}\n\truntime->hw_ptr_base = hw_base;\n\truntime->status->hw_ptr = new_hw_ptr;\n\truntime->hw_ptr_jiffies = curr_jiffies;\n\tif (crossed_boundary) {\n\t\tsnd_BUG_ON(crossed_boundary != 1);\n\t\truntime->hw_ptr_wrap += runtime->boundary;\n\t}\n\n\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\n\treturn snd_pcm_update_state(substream, runtime);\n}\n\n \nint snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_update_hw_ptr0(substream, 0);\n}\n\n \nvoid snd_pcm_set_ops(struct snd_pcm *pcm, int direction,\n\t\t     const struct snd_pcm_ops *ops)\n{\n\tstruct snd_pcm_str *stream = &pcm->streams[direction];\n\tstruct snd_pcm_substream *substream;\n\t\n\tfor (substream = stream->substream; substream != NULL; substream = substream->next)\n\t\tsubstream->ops = ops;\n}\nEXPORT_SYMBOL(snd_pcm_set_ops);\n\n \nvoid snd_pcm_set_sync(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\truntime->sync.id32[0] = substream->pcm->card->number;\n\truntime->sync.id32[1] = -1;\n\truntime->sync.id32[2] = -1;\n\truntime->sync.id32[3] = -1;\n}\nEXPORT_SYMBOL(snd_pcm_set_sync);\n\n \n\nstatic inline unsigned int div32(unsigned int a, unsigned int b, \n\t\t\t\t unsigned int *r)\n{\n\tif (b == 0) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\t*r = a % b;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_down(unsigned int a, unsigned int b)\n{\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_up(unsigned int a, unsigned int b)\n{\n\tunsigned int r;\n\tunsigned int q;\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\tq = div32(a, b, &r);\n\tif (r)\n\t\t++q;\n\treturn q;\n}\n\nstatic inline unsigned int mul(unsigned int a, unsigned int b)\n{\n\tif (a == 0)\n\t\treturn 0;\n\tif (div_down(UINT_MAX, a) < b)\n\t\treturn UINT_MAX;\n\treturn a * b;\n}\n\nstatic inline unsigned int muldiv32(unsigned int a, unsigned int b,\n\t\t\t\t    unsigned int c, unsigned int *r)\n{\n\tu_int64_t n = (u_int64_t) a * b;\n\tif (c == 0) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\tn = div_u64_rem(n, c, r);\n\tif (n >= UINT_MAX) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\treturn n;\n}\n\n \nint snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)\n{\n\tint changed = 0;\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (i->min < v->min) {\n\t\ti->min = v->min;\n\t\ti->openmin = v->openmin;\n\t\tchanged = 1;\n\t} else if (i->min == v->min && !i->openmin && v->openmin) {\n\t\ti->openmin = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->max > v->max) {\n\t\ti->max = v->max;\n\t\ti->openmax = v->openmax;\n\t\tchanged = 1;\n\t} else if (i->max == v->max && !i->openmax && v->openmax) {\n\t\ti->openmax = 1;\n\t\tchanged = 1;\n\t}\n\tif (!i->integer && v->integer) {\n\t\ti->integer = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmin) {\n\t\t\ti->min++;\n\t\t\ti->openmin = 0;\n\t\t}\n\t\tif (i->openmax) {\n\t\t\ti->max--;\n\t\t\ti->openmax = 0;\n\t\t}\n\t} else if (!i->openmin && !i->openmax && i->min == i->max)\n\t\ti->integer = 1;\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\nEXPORT_SYMBOL(snd_interval_refine);\n\nstatic int snd_interval_refine_first(struct snd_interval *i)\n{\n\tconst unsigned int last_max = i->max;\n\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->max = i->min;\n\tif (i->openmin)\n\t\ti->max++;\n\t \n\ti->openmax = (i->openmax && i->max >= last_max);\n\treturn 1;\n}\n\nstatic int snd_interval_refine_last(struct snd_interval *i)\n{\n\tconst unsigned int last_min = i->min;\n\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->min = i->max;\n\tif (i->openmax)\n\t\ti->min--;\n\t \n\ti->openmin = (i->openmin && i->min <= last_min);\n\treturn 1;\n}\n\nvoid snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = mul(a->min, b->min);\n\tc->openmin = (a->openmin || b->openmin);\n\tc->max = mul(a->max,  b->max);\n\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = (a->integer && b->integer);\n}\n\n \nvoid snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = div32(a->min, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = div32(a->max, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n \nvoid snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,\n\t\t      unsigned int k, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, b->min, k, &r);\n\tc->openmin = (r || a->openmin || b->openmin);\n\tc->max = muldiv32(a->max, b->max, k, &r);\n\tif (r) {\n\t\tc->max++;\n\t\tc->openmax = 1;\n\t} else\n\t\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = 0;\n}\n\n \nvoid snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,\n\t\t      const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, k, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = muldiv32(a->max, k, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n \n\n\n \nint snd_interval_ratnum(struct snd_interval *i,\n\t\t\tunsigned int rats_count, const struct snd_ratnum *rats,\n\t\t\tunsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_den;\n\tint best_diff;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\tunsigned int result_num, result_den;\n\tint result_diff;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tif (q == 0)\n\t\t\tq = 1;\n\t\tden = div_up(num, q);\n\t\tif (den < rats[k].den_min)\n\t\t\tcontinue;\n\t\tif (den > rats[k].den_max)\n\t\t\tden = rats[k].den_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden -= r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tresult_num = best_num;\n\tresult_diff = best_diff;\n\tresult_den = best_den;\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tif (q == 0) {\n\t\t\ti->empty = 1;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tden = div_down(num, q);\n\t\tif (den > rats[k].den_max)\n\t\t\tcontinue;\n\t\tif (den < rats[k].den_min)\n\t\t\tden = rats[k].den_min;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden += rats[k].den_step - r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (best_diff * result_den < result_diff * best_den) {\n\t\t\tresult_num = best_num;\n\t\t\tresult_den = best_den;\n\t\t}\n\t\tif (nump)\n\t\t\t*nump = result_num;\n\t\tif (denp)\n\t\t\t*denp = result_den;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(snd_interval_ratnum);\n\n \nstatic int snd_interval_ratden(struct snd_interval *i,\n\t\t\t       unsigned int rats_count,\n\t\t\t       const struct snd_ratden *rats,\n\t\t\t       unsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_diff, best_den;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num > rats[k].num_max)\n\t\t\tcontinue;\n\t\tif (num < rats[k].num_min)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum += rats[k].num_step - r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num < rats[k].num_min)\n\t\t\tcontinue;\n\t\tif (num > rats[k].num_max)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum -= r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (nump)\n\t\t\t*nump = best_num;\n\t\tif (denp)\n\t\t\t*denp = best_den;\n\t}\n\treturn err;\n}\n\n \nint snd_interval_list(struct snd_interval *i, unsigned int count,\n\t\t      const unsigned int *list, unsigned int mask)\n{\n        unsigned int k;\n\tstruct snd_interval list_range;\n\n\tif (!count) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&list_range);\n\tlist_range.min = UINT_MAX;\n\tlist_range.max = 0;\n        for (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tif (!snd_interval_test(i, list[k]))\n\t\t\tcontinue;\n\t\tlist_range.min = min(list_range.min, list[k]);\n\t\tlist_range.max = max(list_range.max, list[k]);\n        }\n\treturn snd_interval_refine(i, &list_range);\n}\nEXPORT_SYMBOL(snd_interval_list);\n\n \nint snd_interval_ranges(struct snd_interval *i, unsigned int count,\n\t\t\tconst struct snd_interval *ranges, unsigned int mask)\n{\n\tunsigned int k;\n\tstruct snd_interval range_union;\n\tstruct snd_interval range;\n\n\tif (!count) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&range_union);\n\trange_union.min = UINT_MAX;\n\trange_union.max = 0;\n\tfor (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tsnd_interval_copy(&range, &ranges[k]);\n\t\tif (snd_interval_refine(&range, i) < 0)\n\t\t\tcontinue;\n\t\tif (snd_interval_empty(&range))\n\t\t\tcontinue;\n\n\t\tif (range.min < range_union.min) {\n\t\t\trange_union.min = range.min;\n\t\t\trange_union.openmin = 1;\n\t\t}\n\t\tif (range.min == range_union.min && !range.openmin)\n\t\t\trange_union.openmin = 0;\n\t\tif (range.max > range_union.max) {\n\t\t\trange_union.max = range.max;\n\t\t\trange_union.openmax = 1;\n\t\t}\n\t\tif (range.max == range_union.max && !range.openmax)\n\t\t\trange_union.openmax = 0;\n\t}\n\treturn snd_interval_refine(i, &range_union);\n}\nEXPORT_SYMBOL(snd_interval_ranges);\n\nstatic int snd_interval_step(struct snd_interval *i, unsigned int step)\n{\n\tunsigned int n;\n\tint changed = 0;\n\tn = i->min % step;\n\tif (n != 0 || i->openmin) {\n\t\ti->min += step - n;\n\t\ti->openmin = 0;\n\t\tchanged = 1;\n\t}\n\tn = i->max % step;\n\tif (n != 0 || i->openmax) {\n\t\ti->max -= n;\n\t\ti->openmax = 0;\n\t\tchanged = 1;\n\t}\n\tif (snd_interval_checkempty(i)) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\n \n\n \nint snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,\n\t\t\tint var,\n\t\t\tsnd_pcm_hw_rule_func_t func, void *private,\n\t\t\tint dep, ...)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_pcm_hw_rule *c;\n\tunsigned int k;\n\tva_list args;\n\tva_start(args, dep);\n\tif (constrs->rules_num >= constrs->rules_all) {\n\t\tstruct snd_pcm_hw_rule *new;\n\t\tunsigned int new_rules = constrs->rules_all + 16;\n\t\tnew = krealloc_array(constrs->rules, new_rules,\n\t\t\t\t     sizeof(*c), GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tva_end(args);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tconstrs->rules = new;\n\t\tconstrs->rules_all = new_rules;\n\t}\n\tc = &constrs->rules[constrs->rules_num];\n\tc->cond = cond;\n\tc->func = func;\n\tc->var = var;\n\tc->private = private;\n\tk = 0;\n\twhile (1) {\n\t\tif (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {\n\t\t\tva_end(args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tc->deps[k++] = dep;\n\t\tif (dep < 0)\n\t\t\tbreak;\n\t\tdep = va_arg(args, int);\n\t}\n\tconstrs->rules_num++;\n\tva_end(args);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_hw_rule_add);\n\n \nint snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t       u_int32_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\t*maskp->bits &= mask;\n\tmemset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8);  \n\tif (*maskp->bits == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nint snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t u_int64_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\tmaskp->bits[0] &= (u_int32_t)mask;\n\tmaskp->bits[1] &= (u_int32_t)(mask >> 32);\n\tmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8);  \n\tif (! maskp->bits[0] && ! maskp->bits[1])\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_mask64);\n\n \nint snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\treturn snd_interval_setinteger(constrs_interval(constrs, var));\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_integer);\n\n \nint snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t unsigned int min, unsigned int max)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_interval t;\n\tt.min = min;\n\tt.max = max;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 0;\n\treturn snd_interval_refine(constrs_interval(constrs, var), &t);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);\n\nstatic int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_list *list = rule->private;\n\treturn snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);\n}\t\t\n\n\n \nint snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       const struct snd_pcm_hw_constraint_list *l)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_list, (void *)l,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_list);\n\nstatic int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_ranges *r = rule->private;\n\treturn snd_interval_ranges(hw_param_interval(params, rule->var),\n\t\t\t\t   r->count, r->ranges, r->mask);\n}\n\n\n \nint snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,\n\t\t\t\t unsigned int cond,\n\t\t\t\t snd_pcm_hw_param_t var,\n\t\t\t\t const struct snd_pcm_hw_constraint_ranges *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ranges, (void *)r,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ranges);\n\nstatic int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratnums *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err;\n\terr = snd_interval_ratnum(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n \nint snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratnums *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratnums, (void *)r,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);\n\nstatic int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratdens *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err = snd_interval_ratden(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n \nint snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratdens *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratdens, (void *)r,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);\n\nstatic int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int l = (unsigned long) rule->private;\n\tint width = l & 0xffff;\n\tunsigned int msbits = l >> 16;\n\tconst struct snd_interval *i =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\n\n\tif (!snd_interval_single(i))\n\t\treturn 0;\n\n\tif ((snd_interval_value(i) == width) ||\n\t    (width == 0 && snd_interval_value(i) > msbits))\n\t\tparams->msbits = min_not_zero(params->msbits, msbits);\n\n\treturn 0;\n}\n\n \nint snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, \n\t\t\t\t unsigned int cond,\n\t\t\t\t unsigned int width,\n\t\t\t\t unsigned int msbits)\n{\n\tunsigned long l = (msbits << 16) | width;\n\treturn snd_pcm_hw_rule_add(runtime, cond, -1,\n\t\t\t\t    snd_pcm_hw_rule_msbits,\n\t\t\t\t    (void*) l,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);\n\nstatic int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tunsigned long step = (unsigned long) rule->private;\n\treturn snd_interval_step(hw_param_interval(params, rule->var), step);\n}\n\n \nint snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       unsigned long step)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_step, (void *) step,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_step);\n\nstatic int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tstatic const unsigned int pow2_sizes[] = {\n\t\t1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,\n\t\t1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,\n\t\t1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,\n\t\t1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30\n\t};\n\treturn snd_interval_list(hw_param_interval(params, rule->var),\n\t\t\t\t ARRAY_SIZE(pow2_sizes), pow2_sizes, 0);\n}\t\t\n\n \nint snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_pow2, NULL,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);\n\nstatic int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int base_rate = (unsigned int)(uintptr_t)rule->private;\n\tstruct snd_interval *rate;\n\n\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\treturn snd_interval_list(rate, 1, &base_rate, 0);\n}\n\n \nint snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int base_rate)\n{\n\treturn snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   snd_pcm_hw_rule_noresample_func,\n\t\t\t\t   (void *)(uintptr_t)base_rate,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_rule_noresample);\n\nstatic void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_any(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tif (hw_is_interval(var)) {\n\t\tsnd_interval_any(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tsnd_BUG();\n}\n\nvoid _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)\n{\n\tunsigned int k;\n\tmemset(params, 0, sizeof(*params));\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tparams->info = ~0U;\n}\nEXPORT_SYMBOL(_snd_pcm_hw_params_any);\n\n \nint snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,\n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tif (hw_is_mask(var)) {\n\t\tconst struct snd_mask *mask = hw_param_mask_c(params, var);\n\t\tif (!snd_mask_single(mask))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = 0;\n\t\treturn snd_mask_value(mask);\n\t}\n\tif (hw_is_interval(var)) {\n\t\tconst struct snd_interval *i = hw_param_interval_c(params, var);\n\t\tif (!snd_interval_single(i))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = i->openmin;\n\t\treturn snd_interval_value(i);\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(snd_pcm_hw_param_value);\n\nvoid _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_none(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else if (hw_is_interval(var)) {\n\t\tsnd_interval_none(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else {\n\t\tsnd_BUG();\n\t}\n}\nEXPORT_SYMBOL(_snd_pcm_hw_param_setempty);\n\nstatic int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,\n\t\t\t\t   snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_first(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_first(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n \nint snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, \n\t\t\t   struct snd_pcm_hw_params *params, \n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_first(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\nEXPORT_SYMBOL(snd_pcm_hw_param_first);\n\nstatic int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_last(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_last(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n \nint snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, \n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_last(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\nEXPORT_SYMBOL(snd_pcm_hw_param_last);\n\nstatic int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,\n\t\t\t\t   void *arg)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (snd_pcm_running(substream) &&\n\t    snd_pcm_update_hw_ptr(substream) >= 0)\n\t\truntime->status->hw_ptr %= runtime->buffer_size;\n\telse {\n\t\truntime->status->hw_ptr = 0;\n\t\truntime->hw_ptr_wrap = 0;\n\t}\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_pcm_channel_info *info = arg;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint width;\n\tif (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {\n\t\tinfo->offset = -1;\n\t\treturn 0;\n\t}\n\twidth = snd_pcm_format_physical_width(runtime->format);\n\tif (width < 0)\n\t\treturn width;\n\tinfo->offset = 0;\n\tswitch (runtime->access) {\n\tcase SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_INTERLEAVED:\n\t\tinfo->first = info->channel * width;\n\t\tinfo->step = runtime->channels * width;\n\t\tbreak;\n\tcase SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:\n\t{\n\t\tsize_t size = runtime->dma_bytes / runtime->channels;\n\t\tinfo->first = info->channel * size * 8;\n\t\tinfo->step = width;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_pcm_hw_params *params = arg;\n\tsnd_pcm_format_t format;\n\tint channels;\n\tssize_t frame_size;\n\n\tparams->fifo_size = substream->runtime->hw.fifo_size;\n\tif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {\n\t\tformat = params_format(params);\n\t\tchannels = params_channels(params);\n\t\tframe_size = snd_pcm_format_size(format, channels);\n\t\tif (frame_size > 0)\n\t\t\tparams->fifo_size /= frame_size;\n\t}\n\treturn 0;\n}\n\n \nint snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_pcm_lib_ioctl_reset(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_pcm_lib_ioctl_channel_info(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_FIFO_SIZE:\n\t\treturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\n\t}\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL(snd_pcm_lib_ioctl);\n\n \nvoid snd_pcm_period_elapsed_under_stream_lock(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_kill_fasync(runtime->fasync, SIGIO, POLL_IN);\n}\nEXPORT_SYMBOL(snd_pcm_period_elapsed_under_stream_lock);\n\n \nvoid snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!substream))\n\t\treturn;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tsnd_pcm_period_elapsed_under_stream_lock(substream);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n}\nEXPORT_SYMBOL(snd_pcm_period_elapsed);\n\n \nstatic int wait_for_avail(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_uframes_t *availp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\twait_queue_entry_t wait;\n\tint err = 0;\n\tsnd_pcm_uframes_t avail = 0;\n\tlong wait_time, tout;\n\n\tinit_waitqueue_entry(&wait, current);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&runtime->tsleep, &wait);\n\n\tif (runtime->no_period_wakeup)\n\t\twait_time = MAX_SCHEDULE_TIMEOUT;\n\telse {\n\t\t \n\t\tif (substream->wait_time) {\n\t\t\twait_time = substream->wait_time;\n\t\t} else {\n\t\t\twait_time = 100;\n\n\t\t\tif (runtime->rate) {\n\t\t\t\tlong t = runtime->buffer_size * 1100 / runtime->rate;\n\t\t\t\twait_time = max(t, wait_time);\n\t\t\t}\n\t\t}\n\t\twait_time = msecs_to_jiffies(wait_time);\n\t}\n\n\tfor (;;) {\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tavail = snd_pcm_avail(substream);\n\t\tif (avail >= runtime->twake)\n\t\t\tbreak;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\n\t\ttout = schedule_timeout(wait_time);\n\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tswitch (runtime->state) {\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t\tif (is_playback)\n\t\t\t\terr = -EPIPE;\n\t\t\telse \n\t\t\t\tavail = 0;  \n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_OPEN:\n\t\tcase SNDRV_PCM_STATE_SETUP:\n\t\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\t\terr = -EBADFD;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_PAUSED:\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tout) {\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"%s timeout (DMA or IRQ trouble?)\\n\",\n\t\t\t\tis_playback ? \"playback write\" : \"capture read\");\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n _endloop:\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&runtime->tsleep, &wait);\n\t*availp = avail;\n\treturn err;\n}\n\t\ntypedef int (*pcm_transfer_f)(struct snd_pcm_substream *substream,\n\t\t\t      int channel, unsigned long hwoff,\n\t\t\t      struct iov_iter *iter, unsigned long bytes);\n\ntypedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *,\n\t\t\t  snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f,\n\t\t\t  bool);\n\n \nstatic void *get_dma_ptr(struct snd_pcm_runtime *runtime,\n\t\t\t   int channel, unsigned long hwoff)\n{\n\treturn runtime->dma_area + hwoff +\n\t\tchannel * (runtime->dma_bytes / runtime->channels);\n}\n\n \nstatic int default_write_copy(struct snd_pcm_substream *substream,\n\t\t\t      int channel, unsigned long hwoff,\n\t\t\t      struct iov_iter *iter, unsigned long bytes)\n{\n\tif (copy_from_iter(get_dma_ptr(substream->runtime, channel, hwoff),\n\t\t\t   bytes, iter) != bytes)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int fill_silence(struct snd_pcm_substream *substream, int channel,\n\t\t\tunsigned long hwoff, struct iov_iter *iter,\n\t\t\tunsigned long bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn 0;\n\tif (substream->ops->fill_silence)\n\t\treturn substream->ops->fill_silence(substream, channel,\n\t\t\t\t\t\t    hwoff, bytes);\n\n\tsnd_pcm_format_set_silence(runtime->format,\n\t\t\t\t   get_dma_ptr(runtime, channel, hwoff),\n\t\t\t\t   bytes_to_samples(runtime, bytes));\n\treturn 0;\n}\n\n \nstatic int default_read_copy(struct snd_pcm_substream *substream,\n\t\t\t     int channel, unsigned long hwoff,\n\t\t\t     struct iov_iter *iter, unsigned long bytes)\n{\n\tif (copy_to_iter(get_dma_ptr(substream->runtime, channel, hwoff),\n\t\t\t bytes, iter) != bytes)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int do_transfer(struct snd_pcm_substream *substream, int c,\n\t\t       unsigned long hwoff, void *data, unsigned long bytes,\n\t\t       pcm_transfer_f transfer, bool in_kernel)\n{\n\tstruct iov_iter iter;\n\tint err, type;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\ttype = ITER_SOURCE;\n\telse\n\t\ttype = ITER_DEST;\n\n\tif (in_kernel) {\n\t\tstruct kvec kvec = { data, bytes };\n\n\t\tiov_iter_kvec(&iter, type, &kvec, 1, bytes);\n\t\treturn transfer(substream, c, hwoff, &iter, bytes);\n\t}\n\n\terr = import_ubuf(type, (__force void __user *)data, bytes, &iter);\n\tif (err)\n\t\treturn err;\n\treturn transfer(substream, c, hwoff, &iter, bytes);\n}\n\n \nstatic int interleaved_copy(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_uframes_t hwoff, void *data,\n\t\t\t    snd_pcm_uframes_t off,\n\t\t\t    snd_pcm_uframes_t frames,\n\t\t\t    pcm_transfer_f transfer,\n\t\t\t    bool in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t \n\thwoff = frames_to_bytes(runtime, hwoff);\n\toff = frames_to_bytes(runtime, off);\n\tframes = frames_to_bytes(runtime, frames);\n\n\treturn do_transfer(substream, 0, hwoff, data + off, frames, transfer,\n\t\t\t   in_kernel);\n}\n\n \nstatic int noninterleaved_copy(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_uframes_t hwoff, void *data,\n\t\t\t       snd_pcm_uframes_t off,\n\t\t\t       snd_pcm_uframes_t frames,\n\t\t\t       pcm_transfer_f transfer,\n\t\t\t       bool in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint channels = runtime->channels;\n\tvoid **bufs = data;\n\tint c, err;\n\n\t \n\toff = samples_to_bytes(runtime, off);\n\tframes = samples_to_bytes(runtime, frames);\n\thwoff = samples_to_bytes(runtime, hwoff);\n\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\tif (!data || !*bufs)\n\t\t\terr = fill_silence(substream, c, hwoff, NULL, frames);\n\t\telse\n\t\t\terr = do_transfer(substream, c, hwoff, *bufs + off,\n\t\t\t\t\t  frames, transfer, in_kernel);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int fill_silence_frames(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_uframes_t off, snd_pcm_uframes_t frames)\n{\n\tif (substream->runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\n\t    substream->runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED)\n\t\treturn interleaved_copy(substream, off, NULL, 0, frames,\n\t\t\t\t\tfill_silence, true);\n\telse\n\t\treturn noninterleaved_copy(substream, off, NULL, 0, frames,\n\t\t\t\t\t   fill_silence, true);\n}\n\n \nstatic int pcm_sanity_check(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))\n\t\treturn -EINVAL;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\treturn 0;\n}\n\nstatic int pcm_accessible_state(struct snd_pcm_runtime *runtime)\n{\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\treturn 0;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\treturn -EPIPE;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\treturn -ESTRPIPE;\n\tdefault:\n\t\treturn -EBADFD;\n\t}\n}\n\n \nint pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,\n\t\t\t   snd_pcm_uframes_t appl_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t old_appl_ptr = runtime->control->appl_ptr;\n\tsnd_pcm_sframes_t diff;\n\tint ret;\n\n\tif (old_appl_ptr == appl_ptr)\n\t\treturn 0;\n\n\tif (appl_ptr >= runtime->boundary)\n\t\treturn -EINVAL;\n\t \n\tif (substream->runtime->info & SNDRV_PCM_INFO_NO_REWINDS) {\n\t\tdiff = appl_ptr - old_appl_ptr;\n\t\tif (diff >= 0) {\n\t\t\tif (diff > runtime->buffer_size)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (runtime->boundary + diff > runtime->buffer_size)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\truntime->control->appl_ptr = appl_ptr;\n\tif (substream->ops->ack) {\n\t\tret = substream->ops->ack(substream);\n\t\tif (ret < 0) {\n\t\t\truntime->control->appl_ptr = old_appl_ptr;\n\t\t\tif (ret == -EPIPE)\n\t\t\t\t__snd_pcm_xrun(substream);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttrace_applptr(substream, old_appl_ptr, appl_ptr);\n\n\treturn 0;\n}\n\n \nsnd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,\n\t\t\t\t     void *data, bool interleaved,\n\t\t\t\t     snd_pcm_uframes_t size, bool in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t xfer = 0;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_uframes_t avail;\n\tpcm_copy_f writer;\n\tpcm_transfer_f transfer;\n\tbool nonblock;\n\tbool is_playback;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\n\tis_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tif (interleaved) {\n\t\tif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&\n\t\t    runtime->channels > 1)\n\t\t\treturn -EINVAL;\n\t\twriter = interleaved_copy;\n\t} else {\n\t\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\t\treturn -EINVAL;\n\t\twriter = noninterleaved_copy;\n\t}\n\n\tif (!data) {\n\t\tif (is_playback)\n\t\t\ttransfer = fill_silence;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (substream->ops->copy)\n\t\t\ttransfer = substream->ops->copy;\n\t\telse\n\t\t\ttransfer = is_playback ?\n\t\t\t\tdefault_write_copy : default_read_copy;\n\t}\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\n\tsnd_pcm_stream_lock_irq(substream);\n\terr = pcm_accessible_state(runtime);\n\tif (err < 0)\n\t\tgoto _end_unlock;\n\n\truntime->twake = runtime->control->avail_min ? : 1;\n\tif (runtime->state == SNDRV_PCM_STATE_RUNNING)\n\t\tsnd_pcm_update_hw_ptr(substream);\n\n\t \n\tif (!is_playback &&\n\t    runtime->state == SNDRV_PCM_STATE_PREPARED &&\n\t    size >= runtime->start_threshold) {\n\t\terr = snd_pcm_start(substream);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t}\n\n\tavail = snd_pcm_avail(substream);\n\n\twhile (size > 0) {\n\t\tsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\n\t\tsnd_pcm_uframes_t cont;\n\t\tif (!avail) {\n\t\t\tif (!is_playback &&\n\t\t\t    runtime->state == SNDRV_PCM_STATE_DRAINING) {\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\truntime->twake = min_t(snd_pcm_uframes_t, size,\n\t\t\t\t\truntime->control->avail_min ? : 1);\n\t\t\terr = wait_for_avail(substream, &avail);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t\tif (!avail)\n\t\t\t\tcontinue;  \n\t\t}\n\t\tframes = size > avail ? avail : size;\n\t\tappl_ptr = READ_ONCE(runtime->control->appl_ptr);\n\t\tappl_ofs = appl_ptr % runtime->buffer_size;\n\t\tcont = runtime->buffer_size - appl_ofs;\n\t\tif (frames > cont)\n\t\t\tframes = cont;\n\t\tif (snd_BUG_ON(!frames)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end_unlock;\n\t\t}\n\t\tif (!atomic_inc_unless_negative(&runtime->buffer_accessing)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto _end_unlock;\n\t\t}\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\tif (!is_playback)\n\t\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_CPU);\n\t\terr = writer(substream, appl_ofs, data, offset, frames,\n\t\t\t     transfer, in_kernel);\n\t\tif (is_playback)\n\t\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tatomic_dec(&runtime->buffer_accessing);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\terr = pcm_accessible_state(runtime);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\tappl_ptr += frames;\n\t\tif (appl_ptr >= runtime->boundary)\n\t\t\tappl_ptr -= runtime->boundary;\n\t\terr = pcm_lib_apply_appl_ptr(substream, appl_ptr);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\n\t\toffset += frames;\n\t\tsize -= frames;\n\t\txfer += frames;\n\t\tavail -= frames;\n\t\tif (is_playback &&\n\t\t    runtime->state == SNDRV_PCM_STATE_PREPARED &&\n\t\t    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {\n\t\t\terr = snd_pcm_start(substream);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t}\n _end_unlock:\n\truntime->twake = 0;\n\tif (xfer > 0 && err >= 0)\n\t\tsnd_pcm_update_state(substream, runtime);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\n}\nEXPORT_SYMBOL(__snd_pcm_lib_xfer);\n\n \n\n \nconst struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);\n\n \nconst struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_alt_chmaps);\n\nstatic bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)\n{\n\tif (ch > info->max_channels)\n\t\treturn false;\n\treturn !info->channel_mask || (info->channel_mask & (1U << ch));\n}\n\nstatic int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = info->max_channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\n \nstatic int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_pcm_substream *substream;\n\tconst struct snd_pcm_chmap_elem *map;\n\n\tif (!info->chmap)\n\t\treturn -EINVAL;\n\tsubstream = snd_pcm_chmap_substream(info, idx);\n\tif (!substream)\n\t\treturn -ENODEV;\n\tmemset(ucontrol->value.integer.value, 0,\n\t       sizeof(long) * info->max_channels);\n\tif (!substream->runtime)\n\t\treturn 0;  \n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint i;\n\t\tif (map->channels == substream->runtime->channels &&\n\t\t    valid_chmap_channels(info, map->channels)) {\n\t\t\tfor (i = 0; i < map->channels; i++)\n\t\t\t\tucontrol->value.integer.value[i] = map->map[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t     unsigned int size, unsigned int __user *tlv)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_pcm_chmap_elem *map;\n\tunsigned int __user *dst;\n\tint c, count = 0;\n\n\tif (!info->chmap)\n\t\treturn -EINVAL;\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint chs_bytes = map->channels * 4;\n\t\tif (!valid_chmap_channels(info, map->channels))\n\t\t\tcontinue;\n\t\tif (size < 8)\n\t\t\treturn -ENOMEM;\n\t\tif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\n\t\t    put_user(chs_bytes, dst + 1))\n\t\t\treturn -EFAULT;\n\t\tdst += 2;\n\t\tsize -= 8;\n\t\tcount += 8;\n\t\tif (size < chs_bytes)\n\t\t\treturn -ENOMEM;\n\t\tsize -= chs_bytes;\n\t\tcount += chs_bytes;\n\t\tfor (c = 0; c < map->channels; c++) {\n\t\t\tif (put_user(map->map[c], dst))\n\t\t\t\treturn -EFAULT;\n\t\t\tdst++;\n\t\t}\n\t}\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tinfo->pcm->streams[info->stream].chmap_kctl = NULL;\n\tkfree(info);\n}\n\n \nint snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,\n\t\t\t   const struct snd_pcm_chmap_elem *chmap,\n\t\t\t   int max_channels,\n\t\t\t   unsigned long private_value,\n\t\t\t   struct snd_pcm_chmap **info_ret)\n{\n\tstruct snd_pcm_chmap *info;\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\n\t\t.info = pcm_chmap_ctl_info,\n\t\t.get = pcm_chmap_ctl_get,\n\t\t.tlv.c = pcm_chmap_ctl_tlv,\n\t};\n\tint err;\n\n\tif (WARN_ON(pcm->streams[stream].chmap_kctl))\n\t\treturn -EBUSY;\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm = pcm;\n\tinfo->stream = stream;\n\tinfo->chmap = chmap;\n\tinfo->max_channels = max_channels;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tknew.name = \"Playback Channel Map\";\n\telse\n\t\tknew.name = \"Capture Channel Map\";\n\tknew.device = pcm->device;\n\tknew.count = pcm->streams[stream].substream_count;\n\tknew.private_value = private_value;\n\tinfo->kctl = snd_ctl_new1(&knew, info);\n\tif (!info->kctl) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->kctl->private_free = pcm_chmap_ctl_private_free;\n\terr = snd_ctl_add(pcm->card, info->kctl);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->streams[stream].chmap_kctl = info->kctl;\n\tif (info_ret)\n\t\t*info_ret = info;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_add_chmap_ctls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}