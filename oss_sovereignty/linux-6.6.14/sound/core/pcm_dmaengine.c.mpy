{
  "module_name": "pcm_dmaengine.c",
  "hash_id": "bea8abdd3f1e9628fd8a848eec02e738c43bbd111bd06b5cecccc399213af8f7",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_dmaengine.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/dmaengine.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <sound/dmaengine_pcm.h>\n\nstruct dmaengine_pcm_runtime_data {\n\tstruct dma_chan *dma_chan;\n\tdma_cookie_t cookie;\n\n\tunsigned int pos;\n};\n\nstatic inline struct dmaengine_pcm_runtime_data *substream_to_prtd(\n\tconst struct snd_pcm_substream *substream)\n{\n\treturn substream->runtime->private_data;\n}\n\nstruct dma_chan *snd_dmaengine_pcm_get_chan(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\n\treturn prtd->dma_chan;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_get_chan);\n\n \nint snd_hwparams_to_dma_slave_config(const struct snd_pcm_substream *substream,\n\tconst struct snd_pcm_hw_params *params,\n\tstruct dma_slave_config *slave_config)\n{\n\tenum dma_slave_buswidth buswidth;\n\tint bits;\n\n\tbits = params_physical_width(params);\n\tif (bits < 8 || bits > 64)\n\t\treturn -EINVAL;\n\telse if (bits == 8)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\telse if (bits == 16)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse if (bits == 24)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_3_BYTES;\n\telse if (bits <= 32)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\telse\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_8_BYTES;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tslave_config->direction = DMA_MEM_TO_DEV;\n\t\tslave_config->dst_addr_width = buswidth;\n\t} else {\n\t\tslave_config->direction = DMA_DEV_TO_MEM;\n\t\tslave_config->src_addr_width = buswidth;\n\t}\n\n\tslave_config->device_fc = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hwparams_to_dma_slave_config);\n\n \nvoid snd_dmaengine_pcm_set_config_from_dai_data(\n\tconst struct snd_pcm_substream *substream,\n\tconst struct snd_dmaengine_dai_dma_data *dma_data,\n\tstruct dma_slave_config *slave_config)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tslave_config->dst_addr = dma_data->addr;\n\t\tslave_config->dst_maxburst = dma_data->maxburst;\n\t\tif (dma_data->flags & SND_DMAENGINE_PCM_DAI_FLAG_PACK)\n\t\t\tslave_config->dst_addr_width =\n\t\t\t\tDMA_SLAVE_BUSWIDTH_UNDEFINED;\n\t\tif (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tslave_config->dst_addr_width = dma_data->addr_width;\n\t} else {\n\t\tslave_config->src_addr = dma_data->addr;\n\t\tslave_config->src_maxburst = dma_data->maxburst;\n\t\tif (dma_data->flags & SND_DMAENGINE_PCM_DAI_FLAG_PACK)\n\t\t\tslave_config->src_addr_width =\n\t\t\t\tDMA_SLAVE_BUSWIDTH_UNDEFINED;\n\t\tif (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tslave_config->src_addr_width = dma_data->addr_width;\n\t}\n\n\tslave_config->peripheral_config = dma_data->peripheral_config;\n\tslave_config->peripheral_size = dma_data->peripheral_size;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_set_config_from_dai_data);\n\nstatic void dmaengine_pcm_dma_complete(void *arg)\n{\n\tunsigned int new_pos;\n\tstruct snd_pcm_substream *substream = arg;\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\n\tnew_pos = prtd->pos + snd_pcm_lib_period_bytes(substream);\n\tif (new_pos >= snd_pcm_lib_buffer_bytes(substream))\n\t\tnew_pos = 0;\n\tprtd->pos = new_pos;\n\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\tstruct dma_chan *chan = prtd->dma_chan;\n\tstruct dma_async_tx_descriptor *desc;\n\tenum dma_transfer_direction direction;\n\tunsigned long flags = DMA_CTRL_ACK;\n\n\tdirection = snd_pcm_substream_to_dma_direction(substream);\n\n\tif (!substream->runtime->no_period_wakeup)\n\t\tflags |= DMA_PREP_INTERRUPT;\n\n\tprtd->pos = 0;\n\tdesc = dmaengine_prep_dma_cyclic(chan,\n\t\tsubstream->runtime->dma_addr,\n\t\tsnd_pcm_lib_buffer_bytes(substream),\n\t\tsnd_pcm_lib_period_bytes(substream), direction, flags);\n\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tdesc->callback = dmaengine_pcm_dma_complete;\n\tdesc->callback_param = substream;\n\tprtd->cookie = dmaengine_submit(desc);\n\n\treturn 0;\n}\n\n \nint snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tret = dmaengine_pcm_prepare_and_submit(substream);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdma_async_issue_pending(prtd->dma_chan);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdmaengine_resume(prtd->dma_chan);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (runtime->info & SNDRV_PCM_INFO_PAUSE)\n\t\t\tdmaengine_pause(prtd->dma_chan);\n\t\telse\n\t\t\tdmaengine_terminate_async(prtd->dma_chan);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdmaengine_pause(prtd->dma_chan);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdmaengine_terminate_async(prtd->dma_chan);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_trigger);\n\n \nsnd_pcm_uframes_t snd_dmaengine_pcm_pointer_no_residue(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\treturn bytes_to_frames(substream->runtime, prtd->pos);\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_pointer_no_residue);\n\n \nsnd_pcm_uframes_t snd_dmaengine_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tunsigned int buf_size;\n\tunsigned int pos = 0;\n\n\tstatus = dmaengine_tx_status(prtd->dma_chan, prtd->cookie, &state);\n\tif (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {\n\t\tbuf_size = snd_pcm_lib_buffer_bytes(substream);\n\t\tif (state.residue > 0 && state.residue <= buf_size)\n\t\t\tpos = buf_size - state.residue;\n\n\t\truntime->delay = bytes_to_frames(runtime,\n\t\t\t\t\t\t state.in_flight_bytes);\n\t}\n\n\treturn bytes_to_frames(runtime, pos);\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_pointer);\n\n \nstruct dma_chan *snd_dmaengine_pcm_request_channel(dma_filter_fn filter_fn,\n\tvoid *filter_data)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tdma_cap_set(DMA_CYCLIC, mask);\n\n\treturn dma_request_channel(mask, filter_fn, filter_data);\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_request_channel);\n\n \nint snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,\n\tstruct dma_chan *chan)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd;\n\tint ret;\n\n\tif (!chan)\n\t\treturn -ENXIO;\n\n\tret = snd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (!prtd)\n\t\treturn -ENOMEM;\n\n\tprtd->dma_chan = chan;\n\n\tsubstream->runtime->private_data = prtd;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_open);\n\n \nint snd_dmaengine_pcm_open_request_chan(struct snd_pcm_substream *substream,\n\tdma_filter_fn filter_fn, void *filter_data)\n{\n\treturn snd_dmaengine_pcm_open(substream,\n\t\t    snd_dmaengine_pcm_request_channel(filter_fn, filter_data));\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_open_request_chan);\n\n \nint snd_dmaengine_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\n\tdmaengine_synchronize(prtd->dma_chan);\n\tkfree(prtd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_close);\n\n \nint snd_dmaengine_pcm_close_release_chan(struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);\n\n\tdmaengine_synchronize(prtd->dma_chan);\n\tdma_release_channel(prtd->dma_chan);\n\tkfree(prtd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_close_release_chan);\n\n \nint snd_dmaengine_pcm_refine_runtime_hwparams(\n\tstruct snd_pcm_substream *substream,\n\tstruct snd_dmaengine_dai_dma_data *dma_data,\n\tstruct snd_pcm_hardware *hw,\n\tstruct dma_chan *chan)\n{\n\tstruct dma_slave_caps dma_caps;\n\tu32 addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tsnd_pcm_format_t i;\n\tint ret = 0;\n\n\tif (!hw || !chan || !dma_data)\n\t\treturn -EINVAL;\n\n\tret = dma_get_slave_caps(chan, &dma_caps);\n\tif (ret == 0) {\n\t\tif (dma_caps.cmd_pause && dma_caps.cmd_resume)\n\t\t\thw->info |= SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME;\n\t\tif (dma_caps.residue_granularity <= DMA_RESIDUE_GRANULARITY_SEGMENT)\n\t\t\thw->info |= SNDRV_PCM_INFO_BATCH;\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\taddr_widths = dma_caps.dst_addr_widths;\n\t\telse\n\t\t\taddr_widths = dma_caps.src_addr_widths;\n\t}\n\n\t \n\tif (!(dma_data->flags & SND_DMAENGINE_PCM_DAI_FLAG_PACK))\n\t\t \n\t\tpcm_for_each_format(i) {\n\t\t\tint bits = snd_pcm_format_physical_width(i);\n\n\t\t\t \n\t\t\tswitch (bits) {\n\t\t\tcase 8:\n\t\t\tcase 16:\n\t\t\tcase 24:\n\t\t\tcase 32:\n\t\t\tcase 64:\n\t\t\t\tif (addr_widths & (1 << (bits / 8)))\n\t\t\t\t\thw->formats |= pcm_format_to_bits(i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_refine_runtime_hwparams);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}