{
  "module_name": "pcm.c",
  "hash_id": "cdeea961a384bf2820047e9ce7e036fc9b2aa000ae68dc5fac6eaaa77e45cc37",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/nospec.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/pcm.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\n#include \"pcm_local.h\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Abramo Bagnara <abramo@alsa-project.org>\");\nMODULE_DESCRIPTION(\"Midlevel PCM code for ALSA.\");\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(snd_pcm_devices);\nstatic DEFINE_MUTEX(register_mutex);\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\nstatic LIST_HEAD(snd_pcm_notify_list);\n#endif\n\nstatic int snd_pcm_free(struct snd_pcm *pcm);\nstatic int snd_pcm_dev_free(struct snd_device *device);\nstatic int snd_pcm_dev_register(struct snd_device *device);\nstatic int snd_pcm_dev_disconnect(struct snd_device *device);\n\nstatic struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)\n{\n\tstruct snd_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &snd_pcm_devices, list) {\n\t\tif (pcm->card == card && pcm->device == device)\n\t\t\treturn pcm;\n\t}\n\treturn NULL;\n}\n\nstatic int snd_pcm_next(struct snd_card *card, int device)\n{\n\tstruct snd_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &snd_pcm_devices, list) {\n\t\tif (pcm->card == card && pcm->device > device)\n\t\t\treturn pcm->device;\n\t\telse if (pcm->card->number > card->number)\n\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\nstatic int snd_pcm_add(struct snd_pcm *newpcm)\n{\n\tstruct snd_pcm *pcm;\n\n\tif (newpcm->internal)\n\t\treturn 0;\n\n\tlist_for_each_entry(pcm, &snd_pcm_devices, list) {\n\t\tif (pcm->card == newpcm->card && pcm->device == newpcm->device)\n\t\t\treturn -EBUSY;\n\t\tif (pcm->card->number > newpcm->card->number ||\n\t\t\t\t(pcm->card == newpcm->card &&\n\t\t\t\tpcm->device > newpcm->device)) {\n\t\t\tlist_add(&newpcm->list, pcm->list.prev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tlist_add_tail(&newpcm->list, &snd_pcm_devices);\n\treturn 0;\n}\n\nstatic int snd_pcm_control_ioctl(struct snd_card *card,\n\t\t\t\t struct snd_ctl_file *control,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE:\n\t\t{\n\t\t\tint device;\n\n\t\t\tif (get_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tdevice = snd_pcm_next(card, device);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tif (put_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_INFO:\n\t\t{\n\t\t\tstruct snd_pcm_info __user *info;\n\t\t\tunsigned int device, subdevice;\n\t\t\tint stream;\n\t\t\tstruct snd_pcm *pcm;\n\t\t\tstruct snd_pcm_str *pstr;\n\t\t\tstruct snd_pcm_substream *substream;\n\t\t\tint err;\n\n\t\t\tinfo = (struct snd_pcm_info __user *)arg;\n\t\t\tif (get_user(device, &info->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(stream, &info->stream))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (stream < 0 || stream > 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tstream = array_index_nospec(stream, 2);\n\t\t\tif (get_user(subdevice, &info->subdevice))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tpcm = snd_pcm_get(card, device);\n\t\t\tif (pcm == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tpstr = &pcm->streams[stream];\n\t\t\tif (pstr->substream_count == 0) {\n\t\t\t\terr = -ENOENT;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (subdevice >= pstr->substream_count) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tfor (substream = pstr->substream; substream;\n\t\t\t     substream = substream->next)\n\t\t\t\tif (substream->number == (int)subdevice)\n\t\t\t\t\tbreak;\n\t\t\tif (substream == NULL) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tmutex_lock(&pcm->open_mutex);\n\t\t\terr = snd_pcm_info_user(substream, info);\n\t\t\tmutex_unlock(&pcm->open_mutex);\n\t\t_error:\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn err;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:\n\t\t{\n\t\t\tint val;\n\t\t\t\n\t\t\tif (get_user(val, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tcontrol->preferred_subdevice[SND_CTL_SUBDEV_PCM] = val;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n#define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v\n\nstatic const char * const snd_pcm_format_names[] = {\n\tFORMAT(S8),\n\tFORMAT(U8),\n\tFORMAT(S16_LE),\n\tFORMAT(S16_BE),\n\tFORMAT(U16_LE),\n\tFORMAT(U16_BE),\n\tFORMAT(S24_LE),\n\tFORMAT(S24_BE),\n\tFORMAT(U24_LE),\n\tFORMAT(U24_BE),\n\tFORMAT(S32_LE),\n\tFORMAT(S32_BE),\n\tFORMAT(U32_LE),\n\tFORMAT(U32_BE),\n\tFORMAT(FLOAT_LE),\n\tFORMAT(FLOAT_BE),\n\tFORMAT(FLOAT64_LE),\n\tFORMAT(FLOAT64_BE),\n\tFORMAT(IEC958_SUBFRAME_LE),\n\tFORMAT(IEC958_SUBFRAME_BE),\n\tFORMAT(MU_LAW),\n\tFORMAT(A_LAW),\n\tFORMAT(IMA_ADPCM),\n\tFORMAT(MPEG),\n\tFORMAT(GSM),\n\tFORMAT(SPECIAL),\n\tFORMAT(S24_3LE),\n\tFORMAT(S24_3BE),\n\tFORMAT(U24_3LE),\n\tFORMAT(U24_3BE),\n\tFORMAT(S20_3LE),\n\tFORMAT(S20_3BE),\n\tFORMAT(U20_3LE),\n\tFORMAT(U20_3BE),\n\tFORMAT(S18_3LE),\n\tFORMAT(S18_3BE),\n\tFORMAT(U18_3LE),\n\tFORMAT(U18_3BE),\n\tFORMAT(G723_24),\n\tFORMAT(G723_24_1B),\n\tFORMAT(G723_40),\n\tFORMAT(G723_40_1B),\n\tFORMAT(DSD_U8),\n\tFORMAT(DSD_U16_LE),\n\tFORMAT(DSD_U32_LE),\n\tFORMAT(DSD_U16_BE),\n\tFORMAT(DSD_U32_BE),\n};\n\n \nconst char *snd_pcm_format_name(snd_pcm_format_t format)\n{\n\tif ((__force unsigned int)format >= ARRAY_SIZE(snd_pcm_format_names))\n\t\treturn \"Unknown\";\n\treturn snd_pcm_format_names[(__force unsigned int)format];\n}\nEXPORT_SYMBOL_GPL(snd_pcm_format_name);\n\n#ifdef CONFIG_SND_VERBOSE_PROCFS\n\n#define STATE(v) [SNDRV_PCM_STATE_##v] = #v\n#define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v\n#define READY(v) [SNDRV_PCM_READY_##v] = #v\n#define XRUN(v) [SNDRV_PCM_XRUN_##v] = #v\n#define SILENCE(v) [SNDRV_PCM_SILENCE_##v] = #v\n#define TSTAMP(v) [SNDRV_PCM_TSTAMP_##v] = #v\n#define ACCESS(v) [SNDRV_PCM_ACCESS_##v] = #v\n#define START(v) [SNDRV_PCM_START_##v] = #v\n#define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v \n\nstatic const char * const snd_pcm_stream_names[] = {\n\tSTREAM(PLAYBACK),\n\tSTREAM(CAPTURE),\n};\n\nstatic const char * const snd_pcm_state_names[] = {\n\tSTATE(OPEN),\n\tSTATE(SETUP),\n\tSTATE(PREPARED),\n\tSTATE(RUNNING),\n\tSTATE(XRUN),\n\tSTATE(DRAINING),\n\tSTATE(PAUSED),\n\tSTATE(SUSPENDED),\n\tSTATE(DISCONNECTED),\n};\n\nstatic const char * const snd_pcm_access_names[] = {\n\tACCESS(MMAP_INTERLEAVED), \n\tACCESS(MMAP_NONINTERLEAVED),\n\tACCESS(MMAP_COMPLEX),\n\tACCESS(RW_INTERLEAVED),\n\tACCESS(RW_NONINTERLEAVED),\n};\n\nstatic const char * const snd_pcm_subformat_names[] = {\n\tSUBFORMAT(STD), \n};\n\nstatic const char * const snd_pcm_tstamp_mode_names[] = {\n\tTSTAMP(NONE),\n\tTSTAMP(ENABLE),\n};\n\nstatic const char *snd_pcm_stream_name(int stream)\n{\n\treturn snd_pcm_stream_names[stream];\n}\n\nstatic const char *snd_pcm_access_name(snd_pcm_access_t access)\n{\n\treturn snd_pcm_access_names[(__force int)access];\n}\n\nstatic const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)\n{\n\treturn snd_pcm_subformat_names[(__force int)subformat];\n}\n\nstatic const char *snd_pcm_tstamp_mode_name(int mode)\n{\n\treturn snd_pcm_tstamp_mode_names[mode];\n}\n\nstatic const char *snd_pcm_state_name(snd_pcm_state_t state)\n{\n\treturn snd_pcm_state_names[(__force int)state];\n}\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n#include <linux/soundcard.h>\n\nstatic const char *snd_pcm_oss_format_name(int format)\n{\n\tswitch (format) {\n\tcase AFMT_MU_LAW:\n\t\treturn \"MU_LAW\";\n\tcase AFMT_A_LAW:\n\t\treturn \"A_LAW\";\n\tcase AFMT_IMA_ADPCM:\n\t\treturn \"IMA_ADPCM\";\n\tcase AFMT_U8:\n\t\treturn \"U8\";\n\tcase AFMT_S16_LE:\n\t\treturn \"S16_LE\";\n\tcase AFMT_S16_BE:\n\t\treturn \"S16_BE\";\n\tcase AFMT_S8:\n\t\treturn \"S8\";\n\tcase AFMT_U16_LE:\n\t\treturn \"U16_LE\";\n\tcase AFMT_U16_BE:\n\t\treturn \"U16_BE\";\n\tcase AFMT_MPEG:\n\t\treturn \"MPEG\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\nstatic void snd_pcm_proc_info_read(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_info *info;\n\tint err;\n\n\tif (! substream)\n\t\treturn;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn;\n\n\terr = snd_pcm_info(substream, info);\n\tif (err < 0) {\n\t\tsnd_iprintf(buffer, \"error %d\\n\", err);\n\t\tkfree(info);\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, \"card: %d\\n\", info->card);\n\tsnd_iprintf(buffer, \"device: %d\\n\", info->device);\n\tsnd_iprintf(buffer, \"subdevice: %d\\n\", info->subdevice);\n\tsnd_iprintf(buffer, \"stream: %s\\n\", snd_pcm_stream_name(info->stream));\n\tsnd_iprintf(buffer, \"id: %s\\n\", info->id);\n\tsnd_iprintf(buffer, \"name: %s\\n\", info->name);\n\tsnd_iprintf(buffer, \"subname: %s\\n\", info->subname);\n\tsnd_iprintf(buffer, \"class: %d\\n\", info->dev_class);\n\tsnd_iprintf(buffer, \"subclass: %d\\n\", info->dev_subclass);\n\tsnd_iprintf(buffer, \"subdevices_count: %d\\n\", info->subdevices_count);\n\tsnd_iprintf(buffer, \"subdevices_avail: %d\\n\", info->subdevices_avail);\n\tkfree(info);\n}\n\nstatic void snd_pcm_stream_proc_info_read(struct snd_info_entry *entry,\n\t\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tsnd_pcm_proc_info_read(((struct snd_pcm_str *)entry->private_data)->substream,\n\t\t\t       buffer);\n}\n\nstatic void snd_pcm_substream_proc_info_read(struct snd_info_entry *entry,\n\t\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tsnd_pcm_proc_info_read(entry->private_data, buffer);\n}\n\nstatic void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,\n\t\t\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tstruct snd_pcm_runtime *runtime;\n\n\tmutex_lock(&substream->pcm->open_mutex);\n\truntime = substream->runtime;\n\tif (!runtime) {\n\t\tsnd_iprintf(buffer, \"closed\\n\");\n\t\tgoto unlock;\n\t}\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tsnd_iprintf(buffer, \"no setup\\n\");\n\t\tgoto unlock;\n\t}\n\tsnd_iprintf(buffer, \"access: %s\\n\", snd_pcm_access_name(runtime->access));\n\tsnd_iprintf(buffer, \"format: %s\\n\", snd_pcm_format_name(runtime->format));\n\tsnd_iprintf(buffer, \"subformat: %s\\n\", snd_pcm_subformat_name(runtime->subformat));\n\tsnd_iprintf(buffer, \"channels: %u\\n\", runtime->channels);\t\n\tsnd_iprintf(buffer, \"rate: %u (%u/%u)\\n\", runtime->rate, runtime->rate_num, runtime->rate_den);\t\n\tsnd_iprintf(buffer, \"period_size: %lu\\n\", runtime->period_size);\t\n\tsnd_iprintf(buffer, \"buffer_size: %lu\\n\", runtime->buffer_size);\t\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\tif (substream->oss.oss) {\n\t\tsnd_iprintf(buffer, \"OSS format: %s\\n\", snd_pcm_oss_format_name(runtime->oss.format));\n\t\tsnd_iprintf(buffer, \"OSS channels: %u\\n\", runtime->oss.channels);\t\n\t\tsnd_iprintf(buffer, \"OSS rate: %u\\n\", runtime->oss.rate);\n\t\tsnd_iprintf(buffer, \"OSS period bytes: %lu\\n\", (unsigned long)runtime->oss.period_bytes);\n\t\tsnd_iprintf(buffer, \"OSS periods: %u\\n\", runtime->oss.periods);\n\t\tsnd_iprintf(buffer, \"OSS period frames: %lu\\n\", (unsigned long)runtime->oss.period_frames);\n\t}\n#endif\n unlock:\n\tmutex_unlock(&substream->pcm->open_mutex);\n}\n\nstatic void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,\n\t\t\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tstruct snd_pcm_runtime *runtime;\n\n\tmutex_lock(&substream->pcm->open_mutex);\n\truntime = substream->runtime;\n\tif (!runtime) {\n\t\tsnd_iprintf(buffer, \"closed\\n\");\n\t\tgoto unlock;\n\t}\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tsnd_iprintf(buffer, \"no setup\\n\");\n\t\tgoto unlock;\n\t}\n\tsnd_iprintf(buffer, \"tstamp_mode: %s\\n\", snd_pcm_tstamp_mode_name(runtime->tstamp_mode));\n\tsnd_iprintf(buffer, \"period_step: %u\\n\", runtime->period_step);\n\tsnd_iprintf(buffer, \"avail_min: %lu\\n\", runtime->control->avail_min);\n\tsnd_iprintf(buffer, \"start_threshold: %lu\\n\", runtime->start_threshold);\n\tsnd_iprintf(buffer, \"stop_threshold: %lu\\n\", runtime->stop_threshold);\n\tsnd_iprintf(buffer, \"silence_threshold: %lu\\n\", runtime->silence_threshold);\n\tsnd_iprintf(buffer, \"silence_size: %lu\\n\", runtime->silence_size);\n\tsnd_iprintf(buffer, \"boundary: %lu\\n\", runtime->boundary);\n unlock:\n\tmutex_unlock(&substream->pcm->open_mutex);\n}\n\nstatic void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,\n\t\t\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_pcm_status64 status;\n\tint err;\n\n\tmutex_lock(&substream->pcm->open_mutex);\n\truntime = substream->runtime;\n\tif (!runtime) {\n\t\tsnd_iprintf(buffer, \"closed\\n\");\n\t\tgoto unlock;\n\t}\n\tmemset(&status, 0, sizeof(status));\n\terr = snd_pcm_status64(substream, &status);\n\tif (err < 0) {\n\t\tsnd_iprintf(buffer, \"error %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\tsnd_iprintf(buffer, \"state: %s\\n\", snd_pcm_state_name(status.state));\n\tsnd_iprintf(buffer, \"owner_pid   : %d\\n\", pid_vnr(substream->pid));\n\tsnd_iprintf(buffer, \"trigger_time: %lld.%09lld\\n\",\n\t\tstatus.trigger_tstamp_sec, status.trigger_tstamp_nsec);\n\tsnd_iprintf(buffer, \"tstamp      : %lld.%09lld\\n\",\n\t\tstatus.tstamp_sec, status.tstamp_nsec);\n\tsnd_iprintf(buffer, \"delay       : %ld\\n\", status.delay);\n\tsnd_iprintf(buffer, \"avail       : %ld\\n\", status.avail);\n\tsnd_iprintf(buffer, \"avail_max   : %ld\\n\", status.avail_max);\n\tsnd_iprintf(buffer, \"-----\\n\");\n\tsnd_iprintf(buffer, \"hw_ptr      : %ld\\n\", runtime->status->hw_ptr);\n\tsnd_iprintf(buffer, \"appl_ptr    : %ld\\n\", runtime->control->appl_ptr);\n unlock:\n\tmutex_unlock(&substream->pcm->open_mutex);\n}\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\nstatic void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_substream *substream = entry->private_data;\n\n\tsnd_pcm_stop_xrun(substream);\n}\n\nstatic void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_str *pstr = entry->private_data;\n\tsnd_iprintf(buffer, \"%d\\n\", pstr->xrun_debug);\n}\n\nstatic void snd_pcm_xrun_debug_write(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_str *pstr = entry->private_data;\n\tchar line[64];\n\tif (!snd_info_get_line(buffer, line, sizeof(line)))\n\t\tpstr->xrun_debug = simple_strtoul(line, NULL, 10);\n}\n#endif\n\nstatic int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)\n{\n\tstruct snd_pcm *pcm = pstr->pcm;\n\tstruct snd_info_entry *entry;\n\tchar name[16];\n\n\tsprintf(name, \"pcm%i%c\", pcm->device, \n\t\tpstr->stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');\n\tentry = snd_info_create_card_entry(pcm->card, name,\n\t\t\t\t\t   pcm->card->proc_root);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->mode = S_IFDIR | 0555;\n\tpstr->proc_root = entry;\n\tentry = snd_info_create_card_entry(pcm->card, \"info\", pstr->proc_root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, pstr, snd_pcm_stream_proc_info_read);\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\tentry = snd_info_create_card_entry(pcm->card, \"xrun_debug\",\n\t\t\t\t\t   pstr->proc_root);\n\tif (entry) {\n\t\tsnd_info_set_text_ops(entry, pstr, snd_pcm_xrun_debug_read);\n\t\tentry->c.text.write = snd_pcm_xrun_debug_write;\n\t\tentry->mode |= 0200;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)\n{\n\tsnd_info_free_entry(pstr->proc_root);\n\tpstr->proc_root = NULL;\n\treturn 0;\n}\n\nstatic struct snd_info_entry *\ncreate_substream_info_entry(struct snd_pcm_substream *substream,\n\t\t\t    const char *name,\n\t\t\t    void (*read)(struct snd_info_entry *,\n\t\t\t\t\t struct snd_info_buffer *))\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(substream->pcm->card, name,\n\t\t\t\t\t   substream->proc_root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, substream, read);\n\treturn entry;\n}\n\nstatic int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)\n{\n\tstruct snd_info_entry *entry;\n\tstruct snd_card *card;\n\tchar name[16];\n\n\tcard = substream->pcm->card;\n\n\tsprintf(name, \"sub%i\", substream->number);\n\tentry = snd_info_create_card_entry(card, name,\n\t\t\t\t\t   substream->pstr->proc_root);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->mode = S_IFDIR | 0555;\n\tsubstream->proc_root = entry;\n\n\tcreate_substream_info_entry(substream, \"info\",\n\t\t\t\t    snd_pcm_substream_proc_info_read);\n\tcreate_substream_info_entry(substream, \"hw_params\",\n\t\t\t\t    snd_pcm_substream_proc_hw_params_read);\n\tcreate_substream_info_entry(substream, \"sw_params\",\n\t\t\t\t    snd_pcm_substream_proc_sw_params_read);\n\tcreate_substream_info_entry(substream, \"status\",\n\t\t\t\t    snd_pcm_substream_proc_status_read);\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\tentry = create_substream_info_entry(substream, \"xrun_injection\", NULL);\n\tif (entry) {\n\t\tentry->c.text.write = snd_pcm_xrun_injection_write;\n\t\tentry->mode = S_IFREG | 0200;\n\t}\n#endif  \n\n\treturn 0;\n}\n\n#else  \nstatic inline int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr) { return 0; }\nstatic inline int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr) { return 0; }\nstatic inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream) { return 0; }\n#endif  \n\nstatic const struct attribute_group *pcm_dev_attr_groups[];\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic int do_pcm_suspend(struct device *dev)\n{\n\tstruct snd_pcm_str *pstr = dev_get_drvdata(dev);\n\n\tif (!pstr->pcm->no_device_suspend)\n\t\tsnd_pcm_suspend_all(pstr->pcm);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops pcm_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(do_pcm_suspend, NULL)\n};\n\n \nstatic const struct device_type pcm_dev_type = {\n\t.name = \"pcm\",\n\t.pm = &pcm_dev_pm_ops,\n};\n\n \nint snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)\n{\n\tint idx, err;\n\tstruct snd_pcm_str *pstr = &pcm->streams[stream];\n\tstruct snd_pcm_substream *substream, *prev;\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\tmutex_init(&pstr->oss.setup_mutex);\n#endif\n\tpstr->stream = stream;\n\tpstr->pcm = pcm;\n\tpstr->substream_count = substream_count;\n\tif (!substream_count)\n\t\treturn 0;\n\n\terr = snd_device_alloc(&pstr->dev, pcm->card);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_name(pstr->dev, \"pcmC%iD%i%c\", pcm->card->number, pcm->device,\n\t\t     stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');\n\tpstr->dev->groups = pcm_dev_attr_groups;\n\tpstr->dev->type = &pcm_dev_type;\n\tdev_set_drvdata(pstr->dev, pstr);\n\n\tif (!pcm->internal) {\n\t\terr = snd_pcm_stream_proc_init(pstr);\n\t\tif (err < 0) {\n\t\t\tpcm_err(pcm, \"Error in snd_pcm_stream_proc_init\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\tprev = NULL;\n\tfor (idx = 0, prev = NULL; idx < substream_count; idx++) {\n\t\tsubstream = kzalloc(sizeof(*substream), GFP_KERNEL);\n\t\tif (!substream)\n\t\t\treturn -ENOMEM;\n\t\tsubstream->pcm = pcm;\n\t\tsubstream->pstr = pstr;\n\t\tsubstream->number = idx;\n\t\tsubstream->stream = stream;\n\t\tsprintf(substream->name, \"subdevice #%i\", idx);\n\t\tsubstream->buffer_bytes_max = UINT_MAX;\n\t\tif (prev == NULL)\n\t\t\tpstr->substream = substream;\n\t\telse\n\t\t\tprev->next = substream;\n\n\t\tif (!pcm->internal) {\n\t\t\terr = snd_pcm_substream_proc_init(substream);\n\t\t\tif (err < 0) {\n\t\t\t\tpcm_err(pcm,\n\t\t\t\t\t\"Error in snd_pcm_stream_proc_init\\n\");\n\t\t\t\tif (prev == NULL)\n\t\t\t\t\tpstr->substream = NULL;\n\t\t\t\telse\n\t\t\t\t\tprev->next = NULL;\n\t\t\t\tkfree(substream);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tsubstream->group = &substream->self_group;\n\t\tsnd_pcm_group_init(&substream->self_group);\n\t\tlist_add_tail(&substream->link_list, &substream->self_group.substreams);\n\t\tatomic_set(&substream->mmap_count, 0);\n\t\tprev = substream;\n\t}\n\treturn 0;\n}\t\t\t\t\nEXPORT_SYMBOL(snd_pcm_new_stream);\n\nstatic int _snd_pcm_new(struct snd_card *card, const char *id, int device,\n\t\tint playback_count, int capture_count, bool internal,\n\t\tstruct snd_pcm **rpcm)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_pcm_dev_free,\n\t\t.dev_register =\tsnd_pcm_dev_register,\n\t\t.dev_disconnect = snd_pcm_dev_disconnect,\n\t};\n\tstatic const struct snd_device_ops internal_ops = {\n\t\t.dev_free = snd_pcm_dev_free,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tif (rpcm)\n\t\t*rpcm = NULL;\n\tpcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\tpcm->card = card;\n\tpcm->device = device;\n\tpcm->internal = internal;\n\tmutex_init(&pcm->open_mutex);\n\tinit_waitqueue_head(&pcm->open_wait);\n\tINIT_LIST_HEAD(&pcm->list);\n\tif (id)\n\t\tstrscpy(pcm->id, id, sizeof(pcm->id));\n\n\terr = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t playback_count);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\terr = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\terr = snd_device_new(card, SNDRV_DEV_PCM, pcm,\n\t\t\t     internal ? &internal_ops : &ops);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\tif (rpcm)\n\t\t*rpcm = pcm;\n\treturn 0;\n\nfree_pcm:\n\tsnd_pcm_free(pcm);\n\treturn err;\n}\n\n \nint snd_pcm_new(struct snd_card *card, const char *id, int device,\n\t\tint playback_count, int capture_count, struct snd_pcm **rpcm)\n{\n\treturn _snd_pcm_new(card, id, device, playback_count, capture_count,\n\t\t\tfalse, rpcm);\n}\nEXPORT_SYMBOL(snd_pcm_new);\n\n \nint snd_pcm_new_internal(struct snd_card *card, const char *id, int device,\n\tint playback_count, int capture_count,\n\tstruct snd_pcm **rpcm)\n{\n\treturn _snd_pcm_new(card, id, device, playback_count, capture_count,\n\t\t\ttrue, rpcm);\n}\nEXPORT_SYMBOL(snd_pcm_new_internal);\n\nstatic void free_chmap(struct snd_pcm_str *pstr)\n{\n\tif (pstr->chmap_kctl) {\n\t\tstruct snd_card *card = pstr->pcm->card;\n\n\t\tsnd_ctl_remove(card, pstr->chmap_kctl);\n\t\tpstr->chmap_kctl = NULL;\n\t}\n}\n\nstatic void snd_pcm_free_stream(struct snd_pcm_str * pstr)\n{\n\tstruct snd_pcm_substream *substream, *substream_next;\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\tstruct snd_pcm_oss_setup *setup, *setupn;\n#endif\n\n\t \n\tsnd_pcm_stream_proc_done(pstr);\n\n\tsubstream = pstr->substream;\n\twhile (substream) {\n\t\tsubstream_next = substream->next;\n\t\tsnd_pcm_timer_done(substream);\n\t\tkfree(substream);\n\t\tsubstream = substream_next;\n\t}\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n\tfor (setup = pstr->oss.setup_list; setup; setup = setupn) {\n\t\tsetupn = setup->next;\n\t\tkfree(setup->task_name);\n\t\tkfree(setup);\n\t}\n#endif\n\tfree_chmap(pstr);\n\tif (pstr->substream_count)\n\t\tput_device(pstr->dev);\n}\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n#define pcm_call_notify(pcm, call)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct snd_pcm_notify *_notify;\t\t\t\t\\\n\t\tlist_for_each_entry(_notify, &snd_pcm_notify_list, list) \\\n\t\t\t_notify->call(pcm);\t\t\t\t\\\n\t} while (0)\n#else\n#define pcm_call_notify(pcm, call) do {} while (0)\n#endif\n\nstatic int snd_pcm_free(struct snd_pcm *pcm)\n{\n\tif (!pcm)\n\t\treturn 0;\n\tif (!pcm->internal)\n\t\tpcm_call_notify(pcm, n_unregister);\n\tif (pcm->private_free)\n\t\tpcm->private_free(pcm);\n\tsnd_pcm_lib_preallocate_free_for_all(pcm);\n\tsnd_pcm_free_stream(&pcm->streams[SNDRV_PCM_STREAM_PLAYBACK]);\n\tsnd_pcm_free_stream(&pcm->streams[SNDRV_PCM_STREAM_CAPTURE]);\n\tkfree(pcm);\n\treturn 0;\n}\n\nstatic int snd_pcm_dev_free(struct snd_device *device)\n{\n\tstruct snd_pcm *pcm = device->device_data;\n\treturn snd_pcm_free(pcm);\n}\n\nint snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,\n\t\t\t     struct file *file,\n\t\t\t     struct snd_pcm_substream **rsubstream)\n{\n\tstruct snd_pcm_str * pstr;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_card *card;\n\tint prefer_subdevice;\n\tsize_t size;\n\n\tif (snd_BUG_ON(!pcm || !rsubstream))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(stream != SNDRV_PCM_STREAM_PLAYBACK &&\n\t\t       stream != SNDRV_PCM_STREAM_CAPTURE))\n\t\treturn -EINVAL;\n\t*rsubstream = NULL;\n\tpstr = &pcm->streams[stream];\n\tif (pstr->substream == NULL || pstr->substream_count == 0)\n\t\treturn -ENODEV;\n\n\tcard = pcm->card;\n\tprefer_subdevice = snd_ctl_get_preferred_subdevice(card, SND_CTL_SUBDEV_PCM);\n\n\tif (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {\n\t\tint opposite = !stream;\n\n\t\tfor (substream = pcm->streams[opposite].substream; substream;\n\t\t     substream = substream->next) {\n\t\t\tif (SUBSTREAM_BUSY(substream))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (file->f_flags & O_APPEND) {\n\t\tif (prefer_subdevice < 0) {\n\t\t\tif (pstr->substream_count > 1)\n\t\t\t\treturn -EINVAL;  \n\t\t\tsubstream = pstr->substream;\n\t\t} else {\n\t\t\tfor (substream = pstr->substream; substream;\n\t\t\t     substream = substream->next)\n\t\t\t\tif (substream->number == prefer_subdevice)\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (! substream)\n\t\t\treturn -ENODEV;\n\t\tif (! SUBSTREAM_BUSY(substream))\n\t\t\treturn -EBADFD;\n\t\tsubstream->ref_count++;\n\t\t*rsubstream = substream;\n\t\treturn 0;\n\t}\n\n\tfor (substream = pstr->substream; substream; substream = substream->next) {\n\t\tif (!SUBSTREAM_BUSY(substream) &&\n\t\t    (prefer_subdevice == -1 ||\n\t\t     substream->number == prefer_subdevice))\n\t\t\tbreak;\n\t}\n\tif (substream == NULL)\n\t\treturn -EAGAIN;\n\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (runtime == NULL)\n\t\treturn -ENOMEM;\n\n\tsize = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status));\n\truntime->status = alloc_pages_exact(size, GFP_KERNEL);\n\tif (runtime->status == NULL) {\n\t\tkfree(runtime);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(runtime->status, 0, size);\n\n\tsize = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control));\n\truntime->control = alloc_pages_exact(size, GFP_KERNEL);\n\tif (runtime->control == NULL) {\n\t\tfree_pages_exact(runtime->status,\n\t\t\t       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));\n\t\tkfree(runtime);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(runtime->control, 0, size);\n\n\tinit_waitqueue_head(&runtime->sleep);\n\tinit_waitqueue_head(&runtime->tsleep);\n\n\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_OPEN);\n\tmutex_init(&runtime->buffer_mutex);\n\tatomic_set(&runtime->buffer_accessing, 0);\n\n\tsubstream->runtime = runtime;\n\tsubstream->private_data = pcm->private_data;\n\tsubstream->ref_count = 1;\n\tsubstream->f_flags = file->f_flags;\n\tsubstream->pid = get_pid(task_pid(current));\n\tpstr->substream_opened++;\n\t*rsubstream = substream;\n\treturn 0;\n}\n\nvoid snd_pcm_detach_substream(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tif (runtime->private_free != NULL)\n\t\truntime->private_free(runtime);\n\tfree_pages_exact(runtime->status,\n\t\t       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));\n\tfree_pages_exact(runtime->control,\n\t\t       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));\n\tkfree(runtime->hw_constraints.rules);\n\t \n\tif (substream->timer) {\n\t\tspin_lock_irq(&substream->timer->lock);\n\t\tsubstream->runtime = NULL;\n\t\tspin_unlock_irq(&substream->timer->lock);\n\t} else {\n\t\tsubstream->runtime = NULL;\n\t}\n\tmutex_destroy(&runtime->buffer_mutex);\n\tsnd_fasync_free(runtime->fasync);\n\tkfree(runtime);\n\tput_pid(substream->pid);\n\tsubstream->pid = NULL;\n\tsubstream->pstr->substream_opened--;\n}\n\nstatic ssize_t pcm_class_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct snd_pcm_str *pstr = dev_get_drvdata(dev);\n\tstruct snd_pcm *pcm = pstr->pcm;\n\tconst char *str;\n\tstatic const char *strs[SNDRV_PCM_CLASS_LAST + 1] = {\n\t\t[SNDRV_PCM_CLASS_GENERIC] = \"generic\",\n\t\t[SNDRV_PCM_CLASS_MULTI] = \"multi\",\n\t\t[SNDRV_PCM_CLASS_MODEM] = \"modem\",\n\t\t[SNDRV_PCM_CLASS_DIGITIZER] = \"digitizer\",\n\t};\n\n\tif (pcm->dev_class > SNDRV_PCM_CLASS_LAST)\n\t\tstr = \"none\";\n\telse\n\t\tstr = strs[pcm->dev_class];\n\treturn sysfs_emit(buf, \"%s\\n\", str);\n}\n\nstatic DEVICE_ATTR_RO(pcm_class);\nstatic struct attribute *pcm_dev_attrs[] = {\n\t&dev_attr_pcm_class.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pcm_dev_attr_group = {\n\t.attrs\t= pcm_dev_attrs,\n};\n\nstatic const struct attribute_group *pcm_dev_attr_groups[] = {\n\t&pcm_dev_attr_group,\n\tNULL\n};\n\nstatic int snd_pcm_dev_register(struct snd_device *device)\n{\n\tint cidx, err;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm *pcm;\n\n\tif (snd_BUG_ON(!device || !device->device_data))\n\t\treturn -ENXIO;\n\tpcm = device->device_data;\n\n\tmutex_lock(&register_mutex);\n\terr = snd_pcm_add(pcm);\n\tif (err)\n\t\tgoto unlock;\n\tfor (cidx = 0; cidx < 2; cidx++) {\n\t\tint devtype = -1;\n\t\tif (pcm->streams[cidx].substream == NULL)\n\t\t\tcontinue;\n\t\tswitch (cidx) {\n\t\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\t\tdevtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\t\tdevtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\terr = snd_register_device(devtype, pcm->card, pcm->device,\n\t\t\t\t\t  &snd_pcm_f_ops[cidx], pcm,\n\t\t\t\t\t  pcm->streams[cidx].dev);\n\t\tif (err < 0) {\n\t\t\tlist_del_init(&pcm->list);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tfor (substream = pcm->streams[cidx].substream; substream; substream = substream->next)\n\t\t\tsnd_pcm_timer_init(substream);\n\t}\n\n\tpcm_call_notify(pcm, n_register);\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_pcm_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_pcm *pcm = device->device_data;\n\tstruct snd_pcm_substream *substream;\n\tint cidx;\n\n\tmutex_lock(&register_mutex);\n\tmutex_lock(&pcm->open_mutex);\n\twake_up(&pcm->open_wait);\n\tlist_del_init(&pcm->list);\n\n\tfor_each_pcm_substream(pcm, cidx, substream) {\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tif (substream->runtime) {\n\t\t\tif (snd_pcm_running(substream))\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);\n\t\t\t \n\t\t\t__snd_pcm_set_state(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_STATE_DISCONNECTED);\n\t\t\twake_up(&substream->runtime->sleep);\n\t\t\twake_up(&substream->runtime->tsleep);\n\t\t}\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t}\n\n\tfor_each_pcm_substream(pcm, cidx, substream)\n\t\tsnd_pcm_sync_stop(substream, false);\n\n\tpcm_call_notify(pcm, n_disconnect);\n\tfor (cidx = 0; cidx < 2; cidx++) {\n\t\tif (pcm->streams[cidx].dev)\n\t\t\tsnd_unregister_device(pcm->streams[cidx].dev);\n\t\tfree_chmap(&pcm->streams[cidx]);\n\t}\n\tmutex_unlock(&pcm->open_mutex);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n \nint snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)\n{\n\tstruct snd_pcm *pcm;\n\n\tif (snd_BUG_ON(!notify ||\n\t\t       !notify->n_register ||\n\t\t       !notify->n_unregister ||\n\t\t       !notify->n_disconnect))\n\t\treturn -EINVAL;\n\tmutex_lock(&register_mutex);\n\tif (nfree) {\n\t\tlist_del(&notify->list);\n\t\tlist_for_each_entry(pcm, &snd_pcm_devices, list)\n\t\t\tnotify->n_unregister(pcm);\n\t} else {\n\t\tlist_add_tail(&notify->list, &snd_pcm_notify_list);\n\t\tlist_for_each_entry(pcm, &snd_pcm_devices, list)\n\t\t\tnotify->n_register(pcm);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_notify);\n#endif  \n\n#ifdef CONFIG_SND_PROC_FS\n \n\nstatic void snd_pcm_proc_read(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm *pcm;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(pcm, &snd_pcm_devices, list) {\n\t\tsnd_iprintf(buffer, \"%02i-%02i: %s : %s\",\n\t\t\t    pcm->card->number, pcm->device, pcm->id, pcm->name);\n\t\tif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)\n\t\t\tsnd_iprintf(buffer, \" : playback %i\",\n\t\t\t\t    pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count);\n\t\tif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)\n\t\t\tsnd_iprintf(buffer, \" : capture %i\",\n\t\t\t\t    pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_pcm_proc_entry;\n\nstatic void snd_pcm_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"pcm\", NULL);\n\tif (entry) {\n\t\tsnd_info_set_text_ops(entry, NULL, snd_pcm_proc_read);\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_pcm_proc_entry = entry;\n}\n\nstatic void snd_pcm_proc_done(void)\n{\n\tsnd_info_free_entry(snd_pcm_proc_entry);\n}\n\n#else  \n#define snd_pcm_proc_init()\n#define snd_pcm_proc_done()\n#endif  \n\n\n \n\nstatic int __init alsa_pcm_init(void)\n{\n\tsnd_ctl_register_ioctl(snd_pcm_control_ioctl);\n\tsnd_ctl_register_ioctl_compat(snd_pcm_control_ioctl);\n\tsnd_pcm_proc_init();\n\treturn 0;\n}\n\nstatic void __exit alsa_pcm_exit(void)\n{\n\tsnd_ctl_unregister_ioctl(snd_pcm_control_ioctl);\n\tsnd_ctl_unregister_ioctl_compat(snd_pcm_control_ioctl);\n\tsnd_pcm_proc_done();\n}\n\nmodule_init(alsa_pcm_init)\nmodule_exit(alsa_pcm_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}