{
  "module_name": "control_compat.c",
  "hash_id": "3576a6c49159f0829640d5ca40de352228007d037c4accf80bff9e7148c26562",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/control_compat.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/compat.h>\n#include <linux/slab.h>\n\nstruct snd_ctl_elem_list32 {\n\tu32 offset;\n\tu32 space;\n\tu32 used;\n\tu32 count;\n\tu32 pids;\n\tunsigned char reserved[50];\n}  ;\n\nstatic int snd_ctl_elem_list_compat(struct snd_card *card,\n\t\t\t\t    struct snd_ctl_elem_list32 __user *data32)\n{\n\tstruct snd_ctl_elem_list data = {};\n\tcompat_caddr_t ptr;\n\tint err;\n\n\t \n\tif (copy_from_user(&data, data32, 4 * sizeof(u32)))\n\t\treturn -EFAULT;\n\t \n\tif (get_user(ptr, &data32->pids))\n\t\treturn -EFAULT;\n\tdata.pids = compat_ptr(ptr);\n\terr = snd_ctl_elem_list(card, &data);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (copy_to_user(data32, &data, 4 * sizeof(u32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nstruct snd_ctl_elem_info32 {\n\tstruct snd_ctl_elem_id id;  \n\ts32 type;\n\tu32 access;\n\tu32 count;\n\ts32 owner;\n\tunion {\n\t\tstruct {\n\t\t\ts32 min;\n\t\t\ts32 max;\n\t\t\ts32 step;\n\t\t} integer;\n\t\tstruct {\n\t\t\tu64 min;\n\t\t\tu64 max;\n\t\t\tu64 step;\n\t\t} integer64;\n\t\tstruct {\n\t\t\tu32 items;\n\t\t\tu32 item;\n\t\t\tchar name[64];\n\t\t\tu64 names_ptr;\n\t\t\tu32 names_length;\n\t\t} enumerated;\n\t\tunsigned char reserved[128];\n\t} value;\n\tunsigned char reserved[64];\n} __attribute__((packed));\n\nstatic int snd_ctl_elem_info_compat(struct snd_ctl_file *ctl,\n\t\t\t\t    struct snd_ctl_elem_info32 __user *data32)\n{\n\tstruct snd_ctl_elem_info *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (! data)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\t \n\tif (copy_from_user(&data->id, &data32->id, sizeof(data->id)))\n\t\tgoto error;\n\t \n\tif (get_user(data->value.enumerated.item, &data32->value.enumerated.item))\n\t\tgoto error;\n\n\terr = snd_ctl_elem_info(ctl, data);\n\tif (err < 0)\n\t\tgoto error;\n\t \n\terr = -EFAULT;\n\t \n\tif (copy_to_user(&data32->id, &data->id, sizeof(data->id)) ||\n\t    copy_to_user(&data32->type, &data->type, 3 * sizeof(u32)))\n\t\tgoto error;\n\tif (put_user(data->owner, &data32->owner))\n\t\tgoto error;\n\tswitch (data->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tif (put_user(data->value.integer.min, &data32->value.integer.min) ||\n\t\t    put_user(data->value.integer.max, &data32->value.integer.max) ||\n\t\t    put_user(data->value.integer.step, &data32->value.integer.step))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tif (copy_to_user(&data32->value.integer64,\n\t\t\t\t &data->value.integer64,\n\t\t\t\t sizeof(data->value.integer64)))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tif (copy_to_user(&data32->value.enumerated,\n\t\t\t\t &data->value.enumerated,\n\t\t\t\t sizeof(data->value.enumerated)))\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\terr = 0;\n error:\n\tkfree(data);\n\treturn err;\n}\n\n \nstruct snd_ctl_elem_value32 {\n\tstruct snd_ctl_elem_id id;\n\tunsigned int indirect;\t \n        union {\n\t\ts32 integer[128];\n\t\tunsigned char data[512];\n#ifndef CONFIG_X86_64\n\t\ts64 integer64[64];\n#endif\n        } value;\n        unsigned char reserved[128];\n};\n\n#ifdef CONFIG_X86_X32_ABI\n \nstruct snd_ctl_elem_value_x32 {\n\tstruct snd_ctl_elem_id id;\n\tunsigned int indirect;\t \n\tunion {\n\t\ts32 integer[128];\n\t\tunsigned char data[512];\n\t\ts64 integer64[64];\n\t} value;\n\tunsigned char reserved[128];\n};\n#endif  \n\n \nstatic int get_ctl_type(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint *countp)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_info *info;\n\tint err;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id_locked(card, id);\n\tif (! kctl) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->id = *id;\n\terr = snd_power_ref_and_wait(card);\n\tif (!err)\n\t\terr = kctl->info(kctl, info);\n\tsnd_power_unref(card);\n\tup_read(&card->controls_rwsem);\n\tif (err >= 0) {\n\t\terr = info->type;\n\t\t*countp = info->count;\n\t}\n\tkfree(info);\n\treturn err;\n}\n\nstatic int get_elem_size(snd_ctl_elem_type_t type, int count)\n{\n\tswitch (type) {\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\treturn sizeof(s64) * count;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\treturn sizeof(int) * count;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\treturn 512;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\treturn sizeof(struct snd_aes_iec958);\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic int copy_ctl_value_from_user(struct snd_card *card,\n\t\t\t\t    struct snd_ctl_elem_value *data,\n\t\t\t\t    void __user *userdata,\n\t\t\t\t    void __user *valuep,\n\t\t\t\t    int *typep, int *countp)\n{\n\tstruct snd_ctl_elem_value32 __user *data32 = userdata;\n\tint i, type, size;\n\tint count;\n\tunsigned int indirect;\n\n\tif (copy_from_user(&data->id, &data32->id, sizeof(data->id)))\n\t\treturn -EFAULT;\n\tif (get_user(indirect, &data32->indirect))\n\t\treturn -EFAULT;\n\tif (indirect)\n\t\treturn -EINVAL;\n\ttype = get_ctl_type(card, &data->id, &count);\n\tif (type < 0)\n\t\treturn type;\n\n\tif (type == (__force int)SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\n\t    type == (__force int)SNDRV_CTL_ELEM_TYPE_INTEGER) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ts32 __user *intp = valuep;\n\t\t\tint val;\n\t\t\tif (get_user(val, &intp[i]))\n\t\t\t\treturn -EFAULT;\n\t\t\tdata->value.integer.value[i] = val;\n\t\t}\n\t} else {\n\t\tsize = get_elem_size((__force snd_ctl_elem_type_t)type, count);\n\t\tif (size < 0) {\n\t\t\tdev_err(card->dev, \"snd_ioctl32_ctl_elem_value: unknown type %d\\n\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(data->value.bytes.data, valuep, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\t*typep = type;\n\t*countp = count;\n\treturn 0;\n}\n\n \nstatic int copy_ctl_value_to_user(void __user *userdata,\n\t\t\t\t  void __user *valuep,\n\t\t\t\t  struct snd_ctl_elem_value *data,\n\t\t\t\t  int type, int count)\n{\n\tstruct snd_ctl_elem_value32 __user *data32 = userdata;\n\tint i, size;\n\n\tif (type == (__force int)SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\n\t    type == (__force int)SNDRV_CTL_ELEM_TYPE_INTEGER) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ts32 __user *intp = valuep;\n\t\t\tint val;\n\t\t\tval = data->value.integer.value[i];\n\t\t\tif (put_user(val, &intp[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tsize = get_elem_size((__force snd_ctl_elem_type_t)type, count);\n\t\tif (copy_to_user(valuep, data->value.bytes.data, size))\n\t\t\treturn -EFAULT;\n\t}\n\tif (copy_to_user(&data32->id, &data->id, sizeof(data32->id)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ctl_elem_read_user(struct snd_card *card,\n\t\t\t      void __user *userdata, void __user *valuep)\n{\n\tstruct snd_ctl_elem_value *data;\n\tint err, type, count;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\terr = copy_ctl_value_from_user(card, data, userdata, valuep,\n\t\t\t\t       &type, &count);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_ctl_elem_read(card, data);\n\tif (err < 0)\n\t\tgoto error;\n\terr = copy_ctl_value_to_user(userdata, valuep, data, type, count);\n error:\n\tkfree(data);\n\treturn err;\n}\n\nstatic int ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t       void __user *userdata, void __user *valuep)\n{\n\tstruct snd_ctl_elem_value *data;\n\tstruct snd_card *card = file->card;\n\tint err, type, count;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\terr = copy_ctl_value_from_user(card, data, userdata, valuep,\n\t\t\t\t       &type, &count);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_ctl_elem_write(card, file, data);\n\tif (err < 0)\n\t\tgoto error;\n\terr = copy_ctl_value_to_user(userdata, valuep, data, type, count);\n error:\n\tkfree(data);\n\treturn err;\n}\n\nstatic int snd_ctl_elem_read_user_compat(struct snd_card *card,\n\t\t\t\t\t struct snd_ctl_elem_value32 __user *data32)\n{\n\treturn ctl_elem_read_user(card, data32, &data32->value);\n}\n\nstatic int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,\n\t\t\t\t\t  struct snd_ctl_elem_value32 __user *data32)\n{\n\treturn ctl_elem_write_user(file, data32, &data32->value);\n}\n\n#ifdef CONFIG_X86_X32_ABI\nstatic int snd_ctl_elem_read_user_x32(struct snd_card *card,\n\t\t\t\t      struct snd_ctl_elem_value_x32 __user *data32)\n{\n\treturn ctl_elem_read_user(card, data32, &data32->value);\n}\n\nstatic int snd_ctl_elem_write_user_x32(struct snd_ctl_file *file,\n\t\t\t\t       struct snd_ctl_elem_value_x32 __user *data32)\n{\n\treturn ctl_elem_write_user(file, data32, &data32->value);\n}\n#endif  \n\n \nstatic int snd_ctl_elem_add_compat(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_info32 __user *data32,\n\t\t\t\t   int replace)\n{\n\tstruct snd_ctl_elem_info *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (! data)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\t  \\\n\tif (copy_from_user(&data->id, &data32->id, sizeof(data->id)) ||\n\t    copy_from_user(&data->type, &data32->type, 3 * sizeof(u32)))\n\t\tgoto error;\n\tif (get_user(data->owner, &data32->owner))\n\t\tgoto error;\n\tswitch (data->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tif (get_user(data->value.integer.min, &data32->value.integer.min) ||\n\t\t    get_user(data->value.integer.max, &data32->value.integer.max) ||\n\t\t    get_user(data->value.integer.step, &data32->value.integer.step))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tif (copy_from_user(&data->value.integer64,\n\t\t\t\t   &data32->value.integer64,\n\t\t\t\t   sizeof(data->value.integer64)))\n\t\t\tgoto error;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tif (copy_from_user(&data->value.enumerated,\n\t\t\t\t   &data32->value.enumerated,\n\t\t\t\t   sizeof(data->value.enumerated)))\n\t\t\tgoto error;\n\t\tdata->value.enumerated.names_ptr =\n\t\t\t(uintptr_t)compat_ptr(data->value.enumerated.names_ptr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\terr = snd_ctl_elem_add(file, data, replace);\n error:\n\tkfree(data);\n\treturn err;\n}  \n\nenum {\n\tSNDRV_CTL_IOCTL_ELEM_LIST32 = _IOWR('U', 0x10, struct snd_ctl_elem_list32),\n\tSNDRV_CTL_IOCTL_ELEM_INFO32 = _IOWR('U', 0x11, struct snd_ctl_elem_info32),\n\tSNDRV_CTL_IOCTL_ELEM_READ32 = _IOWR('U', 0x12, struct snd_ctl_elem_value32),\n\tSNDRV_CTL_IOCTL_ELEM_WRITE32 = _IOWR('U', 0x13, struct snd_ctl_elem_value32),\n\tSNDRV_CTL_IOCTL_ELEM_ADD32 = _IOWR('U', 0x17, struct snd_ctl_elem_info32),\n\tSNDRV_CTL_IOCTL_ELEM_REPLACE32 = _IOWR('U', 0x18, struct snd_ctl_elem_info32),\n#ifdef CONFIG_X86_X32_ABI\n\tSNDRV_CTL_IOCTL_ELEM_READ_X32 = _IOWR('U', 0x12, struct snd_ctl_elem_value_x32),\n\tSNDRV_CTL_IOCTL_ELEM_WRITE_X32 = _IOWR('U', 0x13, struct snd_ctl_elem_value_x32),\n#endif  \n};\n\nstatic inline long snd_ctl_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = compat_ptr(arg);\n\tint err;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\tcase SNDRV_CTL_IOCTL_POWER:\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\treturn snd_ctl_ioctl(file, cmd, (unsigned long)argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST32:\n\t\treturn snd_ctl_elem_list_compat(ctl->card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO32:\n\t\treturn snd_ctl_elem_info_compat(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ32:\n\t\treturn snd_ctl_elem_read_user_compat(ctl->card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE32:\n\t\treturn snd_ctl_elem_write_user_compat(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD32:\n\t\treturn snd_ctl_elem_add_compat(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE32:\n\t\treturn snd_ctl_elem_add_compat(ctl, argp, 1);\n#ifdef CONFIG_X86_X32_ABI\n\tcase SNDRV_CTL_IOCTL_ELEM_READ_X32:\n\t\treturn snd_ctl_elem_read_user_x32(ctl->card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE_X32:\n\t\treturn snd_ctl_elem_write_user_x32(ctl, argp);\n#endif  \n\t}\n\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_compat_ioctls, list) {\n\t\tif (p->fioctl) {\n\t\t\terr = p->fioctl(ctl->card, ctl, cmd, arg);\n\t\t\tif (err != -ENOIOCTLCMD) {\n\t\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\treturn -ENOIOCTLCMD;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}