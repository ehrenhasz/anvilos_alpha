{
  "module_name": "memalloc.c",
  "hash_id": "24be8ba9aca539f2a23254302f9c9995b1156c6efec43be76b4646a587341fcf",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/memalloc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma-map-ops.h>\n#include <linux/genalloc.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#ifdef CONFIG_X86\n#include <asm/set_memory.h>\n#endif\n#include <sound/memalloc.h>\n#include \"memalloc_local.h\"\n\n#define DEFAULT_GFP \\\n\t(GFP_KERNEL | \\\n\t __GFP_RETRY_MAYFAIL |   \\\n\t __GFP_NOWARN)    \n\nstatic const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab);\n\n#ifdef CONFIG_SND_DMA_SGBUF\nstatic void *snd_dma_sg_fallback_alloc(struct snd_dma_buffer *dmab, size_t size);\n#endif\n\nstatic void *__snd_dma_alloc_pages(struct snd_dma_buffer *dmab, size_t size)\n{\n\tconst struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);\n\n\tif (WARN_ON_ONCE(!ops || !ops->alloc))\n\t\treturn NULL;\n\treturn ops->alloc(dmab, size);\n}\n\n \nint snd_dma_alloc_dir_pages(int type, struct device *device,\n\t\t\t    enum dma_data_direction dir, size_t size,\n\t\t\t    struct snd_dma_buffer *dmab)\n{\n\tif (WARN_ON(!size))\n\t\treturn -ENXIO;\n\tif (WARN_ON(!dmab))\n\t\treturn -ENXIO;\n\n\tsize = PAGE_ALIGN(size);\n\tdmab->dev.type = type;\n\tdmab->dev.dev = device;\n\tdmab->dev.dir = dir;\n\tdmab->bytes = 0;\n\tdmab->addr = 0;\n\tdmab->private_data = NULL;\n\tdmab->area = __snd_dma_alloc_pages(dmab, size);\n\tif (!dmab->area)\n\t\treturn -ENOMEM;\n\tdmab->bytes = size;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_dma_alloc_dir_pages);\n\n \nint snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,\n\t\t\t\t struct snd_dma_buffer *dmab)\n{\n\tint err;\n\n\twhile ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tif (size <= PAGE_SIZE)\n\t\t\treturn -ENOMEM;\n\t\tsize >>= 1;\n\t\tsize = PAGE_SIZE << get_order(size);\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_dma_alloc_pages_fallback);\n\n \nvoid snd_dma_free_pages(struct snd_dma_buffer *dmab)\n{\n\tconst struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);\n\n\tif (ops && ops->free)\n\t\tops->free(dmab);\n}\nEXPORT_SYMBOL(snd_dma_free_pages);\n\n \nstatic void __snd_release_pages(struct device *dev, void *res)\n{\n\tsnd_dma_free_pages(res);\n}\n\n \nstruct snd_dma_buffer *\nsnd_devm_alloc_dir_pages(struct device *dev, int type,\n\t\t\t enum dma_data_direction dir, size_t size)\n{\n\tstruct snd_dma_buffer *dmab;\n\tint err;\n\n\tif (WARN_ON(type == SNDRV_DMA_TYPE_CONTINUOUS ||\n\t\t    type == SNDRV_DMA_TYPE_VMALLOC))\n\t\treturn NULL;\n\n\tdmab = devres_alloc(__snd_release_pages, sizeof(*dmab), GFP_KERNEL);\n\tif (!dmab)\n\t\treturn NULL;\n\n\terr = snd_dma_alloc_dir_pages(type, dev, dir, size, dmab);\n\tif (err < 0) {\n\t\tdevres_free(dmab);\n\t\treturn NULL;\n\t}\n\n\tdevres_add(dev, dmab);\n\treturn dmab;\n}\nEXPORT_SYMBOL_GPL(snd_devm_alloc_dir_pages);\n\n \nint snd_dma_buffer_mmap(struct snd_dma_buffer *dmab,\n\t\t\tstruct vm_area_struct *area)\n{\n\tconst struct snd_malloc_ops *ops;\n\n\tif (!dmab)\n\t\treturn -ENOENT;\n\tops = snd_dma_get_ops(dmab);\n\tif (ops && ops->mmap)\n\t\treturn ops->mmap(dmab, area);\n\telse\n\t\treturn -ENOENT;\n}\nEXPORT_SYMBOL(snd_dma_buffer_mmap);\n\n#ifdef CONFIG_HAS_DMA\n \nvoid snd_dma_buffer_sync(struct snd_dma_buffer *dmab,\n\t\t\t enum snd_dma_sync_mode mode)\n{\n\tconst struct snd_malloc_ops *ops;\n\n\tif (!dmab || !dmab->dev.need_sync)\n\t\treturn;\n\tops = snd_dma_get_ops(dmab);\n\tif (ops && ops->sync)\n\t\tops->sync(dmab, mode);\n}\nEXPORT_SYMBOL_GPL(snd_dma_buffer_sync);\n#endif  \n\n \ndma_addr_t snd_sgbuf_get_addr(struct snd_dma_buffer *dmab, size_t offset)\n{\n\tconst struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);\n\n\tif (ops && ops->get_addr)\n\t\treturn ops->get_addr(dmab, offset);\n\telse\n\t\treturn dmab->addr + offset;\n}\nEXPORT_SYMBOL(snd_sgbuf_get_addr);\n\n \nstruct page *snd_sgbuf_get_page(struct snd_dma_buffer *dmab, size_t offset)\n{\n\tconst struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);\n\n\tif (ops && ops->get_page)\n\t\treturn ops->get_page(dmab, offset);\n\telse\n\t\treturn virt_to_page(dmab->area + offset);\n}\nEXPORT_SYMBOL(snd_sgbuf_get_page);\n\n \nunsigned int snd_sgbuf_get_chunk_size(struct snd_dma_buffer *dmab,\n\t\t\t\t      unsigned int ofs, unsigned int size)\n{\n\tconst struct snd_malloc_ops *ops = snd_dma_get_ops(dmab);\n\n\tif (ops && ops->get_chunk_size)\n\t\treturn ops->get_chunk_size(dmab, ofs, size);\n\telse\n\t\treturn size;\n}\nEXPORT_SYMBOL(snd_sgbuf_get_chunk_size);\n\n \nstatic void *do_alloc_pages(struct device *dev, size_t size, dma_addr_t *addr,\n\t\t\t    bool wc)\n{\n\tvoid *p;\n\tgfp_t gfp = GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN;\n\n again:\n\tp = alloc_pages_exact(size, gfp);\n\tif (!p)\n\t\treturn NULL;\n\t*addr = page_to_phys(virt_to_page(p));\n\tif (!dev)\n\t\treturn p;\n\tif ((*addr + size - 1) & ~dev->coherent_dma_mask) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && !(gfp & GFP_DMA32)) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n#ifdef CONFIG_X86\n\tif (wc)\n\t\tset_memory_wc((unsigned long)(p), size >> PAGE_SHIFT);\n#endif\n\treturn p;\n}\n\nstatic void do_free_pages(void *p, size_t size, bool wc)\n{\n#ifdef CONFIG_X86\n\tif (wc)\n\t\tset_memory_wb((unsigned long)(p), size >> PAGE_SHIFT);\n#endif\n\tfree_pages_exact(p, size);\n}\n\n\nstatic void *snd_dma_continuous_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\treturn do_alloc_pages(dmab->dev.dev, size, &dmab->addr, false);\n}\n\nstatic void snd_dma_continuous_free(struct snd_dma_buffer *dmab)\n{\n\tdo_free_pages(dmab->area, dmab->bytes, false);\n}\n\nstatic int snd_dma_continuous_mmap(struct snd_dma_buffer *dmab,\n\t\t\t\t   struct vm_area_struct *area)\n{\n\treturn remap_pfn_range(area, area->vm_start,\n\t\t\t       dmab->addr >> PAGE_SHIFT,\n\t\t\t       area->vm_end - area->vm_start,\n\t\t\t       area->vm_page_prot);\n}\n\nstatic const struct snd_malloc_ops snd_dma_continuous_ops = {\n\t.alloc = snd_dma_continuous_alloc,\n\t.free = snd_dma_continuous_free,\n\t.mmap = snd_dma_continuous_mmap,\n};\n\n \nstatic void *snd_dma_vmalloc_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\treturn vmalloc(size);\n}\n\nstatic void snd_dma_vmalloc_free(struct snd_dma_buffer *dmab)\n{\n\tvfree(dmab->area);\n}\n\nstatic int snd_dma_vmalloc_mmap(struct snd_dma_buffer *dmab,\n\t\t\t\tstruct vm_area_struct *area)\n{\n\treturn remap_vmalloc_range(area, dmab->area, 0);\n}\n\n#define get_vmalloc_page_addr(dmab, offset) \\\n\tpage_to_phys(vmalloc_to_page((dmab)->area + (offset)))\n\nstatic dma_addr_t snd_dma_vmalloc_get_addr(struct snd_dma_buffer *dmab,\n\t\t\t\t\t   size_t offset)\n{\n\treturn get_vmalloc_page_addr(dmab, offset) + offset % PAGE_SIZE;\n}\n\nstatic struct page *snd_dma_vmalloc_get_page(struct snd_dma_buffer *dmab,\n\t\t\t\t\t     size_t offset)\n{\n\treturn vmalloc_to_page(dmab->area + offset);\n}\n\nstatic unsigned int\nsnd_dma_vmalloc_get_chunk_size(struct snd_dma_buffer *dmab,\n\t\t\t       unsigned int ofs, unsigned int size)\n{\n\tunsigned int start, end;\n\tunsigned long addr;\n\n\tstart = ALIGN_DOWN(ofs, PAGE_SIZE);\n\tend = ofs + size - 1;  \n\t \n\taddr = get_vmalloc_page_addr(dmab, start);\n\tfor (;;) {\n\t\tstart += PAGE_SIZE;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\taddr += PAGE_SIZE;\n\t\tif (get_vmalloc_page_addr(dmab, start) != addr)\n\t\t\treturn start - ofs;\n\t}\n\t \n\treturn size;\n}\n\nstatic const struct snd_malloc_ops snd_dma_vmalloc_ops = {\n\t.alloc = snd_dma_vmalloc_alloc,\n\t.free = snd_dma_vmalloc_free,\n\t.mmap = snd_dma_vmalloc_mmap,\n\t.get_addr = snd_dma_vmalloc_get_addr,\n\t.get_page = snd_dma_vmalloc_get_page,\n\t.get_chunk_size = snd_dma_vmalloc_get_chunk_size,\n};\n\n#ifdef CONFIG_HAS_DMA\n \n#ifdef CONFIG_GENERIC_ALLOCATOR\nstatic void *snd_dma_iram_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\tstruct device *dev = dmab->dev.dev;\n\tstruct gen_pool *pool;\n\tvoid *p;\n\n\tif (dev->of_node) {\n\t\tpool = of_gen_pool_get(dev->of_node, \"iram\", 0);\n\t\t \n\t\tdmab->private_data = pool;\n\n\t\tp = gen_pool_dma_alloc_align(pool, size, &dmab->addr, PAGE_SIZE);\n\t\tif (p)\n\t\t\treturn p;\n\t}\n\n\t \n\tdmab->dev.type = SNDRV_DMA_TYPE_DEV;\n\treturn __snd_dma_alloc_pages(dmab, size);\n}\n\nstatic void snd_dma_iram_free(struct snd_dma_buffer *dmab)\n{\n\tstruct gen_pool *pool = dmab->private_data;\n\n\tif (pool && dmab->area)\n\t\tgen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);\n}\n\nstatic int snd_dma_iram_mmap(struct snd_dma_buffer *dmab,\n\t\t\t     struct vm_area_struct *area)\n{\n\tarea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\n\treturn remap_pfn_range(area, area->vm_start,\n\t\t\t       dmab->addr >> PAGE_SHIFT,\n\t\t\t       area->vm_end - area->vm_start,\n\t\t\t       area->vm_page_prot);\n}\n\nstatic const struct snd_malloc_ops snd_dma_iram_ops = {\n\t.alloc = snd_dma_iram_alloc,\n\t.free = snd_dma_iram_free,\n\t.mmap = snd_dma_iram_mmap,\n};\n#endif  \n\n \nstatic void *snd_dma_dev_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\treturn dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);\n}\n\nstatic void snd_dma_dev_free(struct snd_dma_buffer *dmab)\n{\n\tdma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);\n}\n\nstatic int snd_dma_dev_mmap(struct snd_dma_buffer *dmab,\n\t\t\t    struct vm_area_struct *area)\n{\n\treturn dma_mmap_coherent(dmab->dev.dev, area,\n\t\t\t\t dmab->area, dmab->addr, dmab->bytes);\n}\n\nstatic const struct snd_malloc_ops snd_dma_dev_ops = {\n\t.alloc = snd_dma_dev_alloc,\n\t.free = snd_dma_dev_free,\n\t.mmap = snd_dma_dev_mmap,\n};\n\n \n \n#ifdef CONFIG_SND_DMA_SGBUF\nstatic void *snd_dma_wc_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\treturn do_alloc_pages(dmab->dev.dev, size, &dmab->addr, true);\n}\n\nstatic void snd_dma_wc_free(struct snd_dma_buffer *dmab)\n{\n\tdo_free_pages(dmab->area, dmab->bytes, true);\n}\n\nstatic int snd_dma_wc_mmap(struct snd_dma_buffer *dmab,\n\t\t\t   struct vm_area_struct *area)\n{\n\tarea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\n\treturn snd_dma_continuous_mmap(dmab, area);\n}\n#else\nstatic void *snd_dma_wc_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\treturn dma_alloc_wc(dmab->dev.dev, size, &dmab->addr, DEFAULT_GFP);\n}\n\nstatic void snd_dma_wc_free(struct snd_dma_buffer *dmab)\n{\n\tdma_free_wc(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);\n}\n\nstatic int snd_dma_wc_mmap(struct snd_dma_buffer *dmab,\n\t\t\t   struct vm_area_struct *area)\n{\n\treturn dma_mmap_wc(dmab->dev.dev, area,\n\t\t\t   dmab->area, dmab->addr, dmab->bytes);\n}\n#endif  \n\nstatic const struct snd_malloc_ops snd_dma_wc_ops = {\n\t.alloc = snd_dma_wc_alloc,\n\t.free = snd_dma_wc_free,\n\t.mmap = snd_dma_wc_mmap,\n};\n\n \nstatic void *snd_dma_noncontig_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\tstruct sg_table *sgt;\n\tvoid *p;\n\n#ifdef CONFIG_SND_DMA_SGBUF\n\tif (cpu_feature_enabled(X86_FEATURE_XENPV))\n\t\treturn snd_dma_sg_fallback_alloc(dmab, size);\n#endif\n\tsgt = dma_alloc_noncontiguous(dmab->dev.dev, size, dmab->dev.dir,\n\t\t\t\t      DEFAULT_GFP, 0);\n#ifdef CONFIG_SND_DMA_SGBUF\n\tif (!sgt && !get_dma_ops(dmab->dev.dev))\n\t\treturn snd_dma_sg_fallback_alloc(dmab, size);\n#endif\n\tif (!sgt)\n\t\treturn NULL;\n\n\tdmab->dev.need_sync = dma_need_sync(dmab->dev.dev,\n\t\t\t\t\t    sg_dma_address(sgt->sgl));\n\tp = dma_vmap_noncontiguous(dmab->dev.dev, size, sgt);\n\tif (p) {\n\t\tdmab->private_data = sgt;\n\t\t \n\t\tdmab->addr = snd_sgbuf_get_addr(dmab, 0);\n\t} else {\n\t\tdma_free_noncontiguous(dmab->dev.dev, size, sgt, dmab->dev.dir);\n\t}\n\treturn p;\n}\n\nstatic void snd_dma_noncontig_free(struct snd_dma_buffer *dmab)\n{\n\tdma_vunmap_noncontiguous(dmab->dev.dev, dmab->area);\n\tdma_free_noncontiguous(dmab->dev.dev, dmab->bytes, dmab->private_data,\n\t\t\t       dmab->dev.dir);\n}\n\nstatic int snd_dma_noncontig_mmap(struct snd_dma_buffer *dmab,\n\t\t\t\t  struct vm_area_struct *area)\n{\n\treturn dma_mmap_noncontiguous(dmab->dev.dev, area,\n\t\t\t\t      dmab->bytes, dmab->private_data);\n}\n\nstatic void snd_dma_noncontig_sync(struct snd_dma_buffer *dmab,\n\t\t\t\t   enum snd_dma_sync_mode mode)\n{\n\tif (mode == SNDRV_DMA_SYNC_CPU) {\n\t\tif (dmab->dev.dir == DMA_TO_DEVICE)\n\t\t\treturn;\n\t\tinvalidate_kernel_vmap_range(dmab->area, dmab->bytes);\n\t\tdma_sync_sgtable_for_cpu(dmab->dev.dev, dmab->private_data,\n\t\t\t\t\t dmab->dev.dir);\n\t} else {\n\t\tif (dmab->dev.dir == DMA_FROM_DEVICE)\n\t\t\treturn;\n\t\tflush_kernel_vmap_range(dmab->area, dmab->bytes);\n\t\tdma_sync_sgtable_for_device(dmab->dev.dev, dmab->private_data,\n\t\t\t\t\t    dmab->dev.dir);\n\t}\n}\n\nstatic inline void snd_dma_noncontig_iter_set(struct snd_dma_buffer *dmab,\n\t\t\t\t\t      struct sg_page_iter *piter,\n\t\t\t\t\t      size_t offset)\n{\n\tstruct sg_table *sgt = dmab->private_data;\n\n\t__sg_page_iter_start(piter, sgt->sgl, sgt->orig_nents,\n\t\t\t     offset >> PAGE_SHIFT);\n}\n\nstatic dma_addr_t snd_dma_noncontig_get_addr(struct snd_dma_buffer *dmab,\n\t\t\t\t\t     size_t offset)\n{\n\tstruct sg_dma_page_iter iter;\n\n\tsnd_dma_noncontig_iter_set(dmab, &iter.base, offset);\n\t__sg_page_iter_dma_next(&iter);\n\treturn sg_page_iter_dma_address(&iter) + offset % PAGE_SIZE;\n}\n\nstatic struct page *snd_dma_noncontig_get_page(struct snd_dma_buffer *dmab,\n\t\t\t\t\t       size_t offset)\n{\n\tstruct sg_page_iter iter;\n\n\tsnd_dma_noncontig_iter_set(dmab, &iter, offset);\n\t__sg_page_iter_next(&iter);\n\treturn sg_page_iter_page(&iter);\n}\n\nstatic unsigned int\nsnd_dma_noncontig_get_chunk_size(struct snd_dma_buffer *dmab,\n\t\t\t\t unsigned int ofs, unsigned int size)\n{\n\tstruct sg_dma_page_iter iter;\n\tunsigned int start, end;\n\tunsigned long addr;\n\n\tstart = ALIGN_DOWN(ofs, PAGE_SIZE);\n\tend = ofs + size - 1;  \n\tsnd_dma_noncontig_iter_set(dmab, &iter.base, start);\n\tif (!__sg_page_iter_dma_next(&iter))\n\t\treturn 0;\n\t \n\taddr = sg_page_iter_dma_address(&iter);\n\tfor (;;) {\n\t\tstart += PAGE_SIZE;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\taddr += PAGE_SIZE;\n\t\tif (!__sg_page_iter_dma_next(&iter) ||\n\t\t    sg_page_iter_dma_address(&iter) != addr)\n\t\t\treturn start - ofs;\n\t}\n\t \n\treturn size;\n}\n\nstatic const struct snd_malloc_ops snd_dma_noncontig_ops = {\n\t.alloc = snd_dma_noncontig_alloc,\n\t.free = snd_dma_noncontig_free,\n\t.mmap = snd_dma_noncontig_mmap,\n\t.sync = snd_dma_noncontig_sync,\n\t.get_addr = snd_dma_noncontig_get_addr,\n\t.get_page = snd_dma_noncontig_get_page,\n\t.get_chunk_size = snd_dma_noncontig_get_chunk_size,\n};\n\n \n#ifdef CONFIG_SND_DMA_SGBUF\n#define sg_wc_address(it) ((unsigned long)page_address(sg_page_iter_page(it)))\n\nstatic void *snd_dma_sg_wc_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\tvoid *p = snd_dma_noncontig_alloc(dmab, size);\n\tstruct sg_table *sgt = dmab->private_data;\n\tstruct sg_page_iter iter;\n\n\tif (!p)\n\t\treturn NULL;\n\tif (dmab->dev.type != SNDRV_DMA_TYPE_DEV_WC_SG)\n\t\treturn p;\n\tfor_each_sgtable_page(sgt, &iter, 0)\n\t\tset_memory_wc(sg_wc_address(&iter), 1);\n\treturn p;\n}\n\nstatic void snd_dma_sg_wc_free(struct snd_dma_buffer *dmab)\n{\n\tstruct sg_table *sgt = dmab->private_data;\n\tstruct sg_page_iter iter;\n\n\tfor_each_sgtable_page(sgt, &iter, 0)\n\t\tset_memory_wb(sg_wc_address(&iter), 1);\n\tsnd_dma_noncontig_free(dmab);\n}\n\nstatic int snd_dma_sg_wc_mmap(struct snd_dma_buffer *dmab,\n\t\t\t      struct vm_area_struct *area)\n{\n\tarea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\n\treturn dma_mmap_noncontiguous(dmab->dev.dev, area,\n\t\t\t\t      dmab->bytes, dmab->private_data);\n}\n\nstatic const struct snd_malloc_ops snd_dma_sg_wc_ops = {\n\t.alloc = snd_dma_sg_wc_alloc,\n\t.free = snd_dma_sg_wc_free,\n\t.mmap = snd_dma_sg_wc_mmap,\n\t.sync = snd_dma_noncontig_sync,\n\t.get_addr = snd_dma_noncontig_get_addr,\n\t.get_page = snd_dma_noncontig_get_page,\n\t.get_chunk_size = snd_dma_noncontig_get_chunk_size,\n};\n\n \nstruct snd_dma_sg_fallback {\n\tbool use_dma_alloc_coherent;\n\tsize_t count;\n\tstruct page **pages;\n\t \n\tdma_addr_t *addrs;\n};\n\nstatic void __snd_dma_sg_fallback_free(struct snd_dma_buffer *dmab,\n\t\t\t\t       struct snd_dma_sg_fallback *sgbuf)\n{\n\tsize_t i, size;\n\n\tif (sgbuf->pages && sgbuf->addrs) {\n\t\ti = 0;\n\t\twhile (i < sgbuf->count) {\n\t\t\tif (!sgbuf->pages[i] || !sgbuf->addrs[i])\n\t\t\t\tbreak;\n\t\t\tsize = sgbuf->addrs[i] & ~PAGE_MASK;\n\t\t\tif (WARN_ON(!size))\n\t\t\t\tbreak;\n\t\t\tif (sgbuf->use_dma_alloc_coherent)\n\t\t\t\tdma_free_coherent(dmab->dev.dev, size << PAGE_SHIFT,\n\t\t\t\t\t\t  page_address(sgbuf->pages[i]),\n\t\t\t\t\t\t  sgbuf->addrs[i] & PAGE_MASK);\n\t\t\telse\n\t\t\t\tdo_free_pages(page_address(sgbuf->pages[i]),\n\t\t\t\t\t      size << PAGE_SHIFT, false);\n\t\t\ti += size;\n\t\t}\n\t}\n\tkvfree(sgbuf->pages);\n\tkvfree(sgbuf->addrs);\n\tkfree(sgbuf);\n}\n\nstatic void *snd_dma_sg_fallback_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\tstruct snd_dma_sg_fallback *sgbuf;\n\tstruct page **pagep, *curp;\n\tsize_t chunk, npages;\n\tdma_addr_t *addrp;\n\tdma_addr_t addr;\n\tvoid *p;\n\n\t \n\tif (dmab->dev.type == SNDRV_DMA_TYPE_DEV_SG)\n\t\tdmab->dev.type = SNDRV_DMA_TYPE_DEV_SG_FALLBACK;\n\telse if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC_SG)\n\t\tdmab->dev.type = SNDRV_DMA_TYPE_DEV_WC_SG_FALLBACK;\n\n\tsgbuf = kzalloc(sizeof(*sgbuf), GFP_KERNEL);\n\tif (!sgbuf)\n\t\treturn NULL;\n\tsgbuf->use_dma_alloc_coherent = cpu_feature_enabled(X86_FEATURE_XENPV);\n\tsize = PAGE_ALIGN(size);\n\tsgbuf->count = size >> PAGE_SHIFT;\n\tsgbuf->pages = kvcalloc(sgbuf->count, sizeof(*sgbuf->pages), GFP_KERNEL);\n\tsgbuf->addrs = kvcalloc(sgbuf->count, sizeof(*sgbuf->addrs), GFP_KERNEL);\n\tif (!sgbuf->pages || !sgbuf->addrs)\n\t\tgoto error;\n\n\tpagep = sgbuf->pages;\n\taddrp = sgbuf->addrs;\n\tchunk = (PAGE_SIZE - 1) << PAGE_SHIFT;  \n\twhile (size > 0) {\n\t\tchunk = min(size, chunk);\n\t\tif (sgbuf->use_dma_alloc_coherent)\n\t\t\tp = dma_alloc_coherent(dmab->dev.dev, chunk, &addr, DEFAULT_GFP);\n\t\telse\n\t\t\tp = do_alloc_pages(dmab->dev.dev, chunk, &addr, false);\n\t\tif (!p) {\n\t\t\tif (chunk <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tchunk >>= 1;\n\t\t\tchunk = PAGE_SIZE << get_order(chunk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize -= chunk;\n\t\t \n\t\tnpages = chunk >> PAGE_SHIFT;\n\t\t*addrp = npages;  \n\t\tcurp = virt_to_page(p);\n\t\twhile (npages--) {\n\t\t\t*pagep++ = curp++;\n\t\t\t*addrp++ |= addr;\n\t\t\taddr += PAGE_SIZE;\n\t\t}\n\t}\n\n\tp = vmap(sgbuf->pages, sgbuf->count, VM_MAP, PAGE_KERNEL);\n\tif (!p)\n\t\tgoto error;\n\n\tif (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC_SG_FALLBACK)\n\t\tset_pages_array_wc(sgbuf->pages, sgbuf->count);\n\n\tdmab->private_data = sgbuf;\n\t \n\tdmab->addr = sgbuf->addrs[0] & PAGE_MASK;\n\treturn p;\n\n error:\n\t__snd_dma_sg_fallback_free(dmab, sgbuf);\n\treturn NULL;\n}\n\nstatic void snd_dma_sg_fallback_free(struct snd_dma_buffer *dmab)\n{\n\tstruct snd_dma_sg_fallback *sgbuf = dmab->private_data;\n\n\tif (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC_SG_FALLBACK)\n\t\tset_pages_array_wb(sgbuf->pages, sgbuf->count);\n\tvunmap(dmab->area);\n\t__snd_dma_sg_fallback_free(dmab, dmab->private_data);\n}\n\nstatic dma_addr_t snd_dma_sg_fallback_get_addr(struct snd_dma_buffer *dmab,\n\t\t\t\t\t       size_t offset)\n{\n\tstruct snd_dma_sg_fallback *sgbuf = dmab->private_data;\n\tsize_t index = offset >> PAGE_SHIFT;\n\n\treturn (sgbuf->addrs[index] & PAGE_MASK) | (offset & ~PAGE_MASK);\n}\n\nstatic int snd_dma_sg_fallback_mmap(struct snd_dma_buffer *dmab,\n\t\t\t\t    struct vm_area_struct *area)\n{\n\tstruct snd_dma_sg_fallback *sgbuf = dmab->private_data;\n\n\tif (dmab->dev.type == SNDRV_DMA_TYPE_DEV_WC_SG_FALLBACK)\n\t\tarea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\n\treturn vm_map_pages(area, sgbuf->pages, sgbuf->count);\n}\n\nstatic const struct snd_malloc_ops snd_dma_sg_fallback_ops = {\n\t.alloc = snd_dma_sg_fallback_alloc,\n\t.free = snd_dma_sg_fallback_free,\n\t.mmap = snd_dma_sg_fallback_mmap,\n\t.get_addr = snd_dma_sg_fallback_get_addr,\n\t \n\t.get_page = snd_dma_vmalloc_get_page,\n\t.get_chunk_size = snd_dma_vmalloc_get_chunk_size,\n};\n#endif  \n\n \nstatic void *snd_dma_noncoherent_alloc(struct snd_dma_buffer *dmab, size_t size)\n{\n\tvoid *p;\n\n\tp = dma_alloc_noncoherent(dmab->dev.dev, size, &dmab->addr,\n\t\t\t\t  dmab->dev.dir, DEFAULT_GFP);\n\tif (p)\n\t\tdmab->dev.need_sync = dma_need_sync(dmab->dev.dev, dmab->addr);\n\treturn p;\n}\n\nstatic void snd_dma_noncoherent_free(struct snd_dma_buffer *dmab)\n{\n\tdma_free_noncoherent(dmab->dev.dev, dmab->bytes, dmab->area,\n\t\t\t     dmab->addr, dmab->dev.dir);\n}\n\nstatic int snd_dma_noncoherent_mmap(struct snd_dma_buffer *dmab,\n\t\t\t\t    struct vm_area_struct *area)\n{\n\tarea->vm_page_prot = vm_get_page_prot(area->vm_flags);\n\treturn dma_mmap_pages(dmab->dev.dev, area,\n\t\t\t      area->vm_end - area->vm_start,\n\t\t\t      virt_to_page(dmab->area));\n}\n\nstatic void snd_dma_noncoherent_sync(struct snd_dma_buffer *dmab,\n\t\t\t\t     enum snd_dma_sync_mode mode)\n{\n\tif (mode == SNDRV_DMA_SYNC_CPU) {\n\t\tif (dmab->dev.dir != DMA_TO_DEVICE)\n\t\t\tdma_sync_single_for_cpu(dmab->dev.dev, dmab->addr,\n\t\t\t\t\t\tdmab->bytes, dmab->dev.dir);\n\t} else {\n\t\tif (dmab->dev.dir != DMA_FROM_DEVICE)\n\t\t\tdma_sync_single_for_device(dmab->dev.dev, dmab->addr,\n\t\t\t\t\t\t   dmab->bytes, dmab->dev.dir);\n\t}\n}\n\nstatic const struct snd_malloc_ops snd_dma_noncoherent_ops = {\n\t.alloc = snd_dma_noncoherent_alloc,\n\t.free = snd_dma_noncoherent_free,\n\t.mmap = snd_dma_noncoherent_mmap,\n\t.sync = snd_dma_noncoherent_sync,\n};\n\n#endif  \n\n \nstatic const struct snd_malloc_ops *snd_dma_ops[] = {\n\t[SNDRV_DMA_TYPE_CONTINUOUS] = &snd_dma_continuous_ops,\n\t[SNDRV_DMA_TYPE_VMALLOC] = &snd_dma_vmalloc_ops,\n#ifdef CONFIG_HAS_DMA\n\t[SNDRV_DMA_TYPE_DEV] = &snd_dma_dev_ops,\n\t[SNDRV_DMA_TYPE_DEV_WC] = &snd_dma_wc_ops,\n\t[SNDRV_DMA_TYPE_NONCONTIG] = &snd_dma_noncontig_ops,\n\t[SNDRV_DMA_TYPE_NONCOHERENT] = &snd_dma_noncoherent_ops,\n#ifdef CONFIG_SND_DMA_SGBUF\n\t[SNDRV_DMA_TYPE_DEV_WC_SG] = &snd_dma_sg_wc_ops,\n#endif\n#ifdef CONFIG_GENERIC_ALLOCATOR\n\t[SNDRV_DMA_TYPE_DEV_IRAM] = &snd_dma_iram_ops,\n#endif  \n#ifdef CONFIG_SND_DMA_SGBUF\n\t[SNDRV_DMA_TYPE_DEV_SG_FALLBACK] = &snd_dma_sg_fallback_ops,\n\t[SNDRV_DMA_TYPE_DEV_WC_SG_FALLBACK] = &snd_dma_sg_fallback_ops,\n#endif\n#endif  \n};\n\nstatic const struct snd_malloc_ops *snd_dma_get_ops(struct snd_dma_buffer *dmab)\n{\n\tif (WARN_ON_ONCE(!dmab))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(dmab->dev.type <= SNDRV_DMA_TYPE_UNKNOWN ||\n\t\t\t dmab->dev.type >= ARRAY_SIZE(snd_dma_ops)))\n\t\treturn NULL;\n\treturn snd_dma_ops[dmab->dev.type];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}