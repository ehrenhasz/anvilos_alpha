{
  "module_name": "pcm_compat.c",
  "hash_id": "57e85024689589c79d5873080ecf089ca3a0a61527c1f15b852e463bf0332905",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_compat.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/compat.h>\n#include <linux/slab.h>\n\nstatic int snd_pcm_ioctl_delay_compat(struct snd_pcm_substream *substream,\n\t\t\t\t      s32 __user *src)\n{\n\tsnd_pcm_sframes_t delay;\n\tint err;\n\n\terr = snd_pcm_delay(substream, &delay);\n\tif (err)\n\t\treturn err;\n\tif (put_user(delay, src))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_pcm_ioctl_rewind_compat(struct snd_pcm_substream *substream,\n\t\t\t\t       u32 __user *src)\n{\n\tsnd_pcm_uframes_t frames;\n\tint err;\n\n\tif (get_user(frames, src))\n\t\treturn -EFAULT;\n\terr = snd_pcm_rewind(substream, frames);\n\tif (put_user(err, src))\n\t\treturn -EFAULT;\n\treturn err < 0 ? err : 0;\n}\n\nstatic int snd_pcm_ioctl_forward_compat(struct snd_pcm_substream *substream,\n\t\t\t\t       u32 __user *src)\n{\n\tsnd_pcm_uframes_t frames;\n\tint err;\n\n\tif (get_user(frames, src))\n\t\treturn -EFAULT;\n\terr = snd_pcm_forward(substream, frames);\n\tif (put_user(err, src))\n\t\treturn -EFAULT;\n\treturn err < 0 ? err : 0;\n}\n\nstruct snd_pcm_hw_params32 {\n\tu32 flags;\n\tstruct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];  \n\tstruct snd_mask mres[5];\t \n\tstruct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];\n\tstruct snd_interval ires[9];\t \n\tu32 rmask;\n\tu32 cmask;\n\tu32 info;\n\tu32 msbits;\n\tu32 rate_num;\n\tu32 rate_den;\n\tu32 fifo_size;\n\tunsigned char reserved[64];\n};\n\nstruct snd_pcm_sw_params32 {\n\ts32 tstamp_mode;\n\tu32 period_step;\n\tu32 sleep_min;\n\tu32 avail_min;\n\tu32 xfer_align;\n\tu32 start_threshold;\n\tu32 stop_threshold;\n\tu32 silence_threshold;\n\tu32 silence_size;\n\tu32 boundary;\n\tu32 proto;\n\tu32 tstamp_type;\n\tunsigned char reserved[56];\n};\n\nstatic int snd_pcm_ioctl_sw_params_compat(struct snd_pcm_substream *substream,\n\t\t\t\t\t  struct snd_pcm_sw_params32 __user *src)\n{\n\tstruct snd_pcm_sw_params params;\n\tsnd_pcm_uframes_t boundary;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\tif (get_user(params.tstamp_mode, &src->tstamp_mode) ||\n\t    get_user(params.period_step, &src->period_step) ||\n\t    get_user(params.sleep_min, &src->sleep_min) ||\n\t    get_user(params.avail_min, &src->avail_min) ||\n\t    get_user(params.xfer_align, &src->xfer_align) ||\n\t    get_user(params.start_threshold, &src->start_threshold) ||\n\t    get_user(params.stop_threshold, &src->stop_threshold) ||\n\t    get_user(params.silence_threshold, &src->silence_threshold) ||\n\t    get_user(params.silence_size, &src->silence_size) ||\n\t    get_user(params.tstamp_type, &src->tstamp_type) ||\n\t    get_user(params.proto, &src->proto))\n\t\treturn -EFAULT;\n\t \n\tboundary = recalculate_boundary(substream->runtime);\n\tif (boundary && params.silence_size >= boundary)\n\t\tparams.silence_size = substream->runtime->boundary;\n\terr = snd_pcm_sw_params(substream, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (boundary && put_user(boundary, &src->boundary))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstruct snd_pcm_channel_info32 {\n\tu32 channel;\n\tu32 offset;\n\tu32 first;\n\tu32 step;\n};\n\nstatic int snd_pcm_ioctl_channel_info_compat(struct snd_pcm_substream *substream,\n\t\t\t\t\t     struct snd_pcm_channel_info32 __user *src)\n{\n\tstruct snd_pcm_channel_info info;\n\tint err;\n\n\tif (get_user(info.channel, &src->channel) ||\n\t    get_user(info.offset, &src->offset) ||\n\t    get_user(info.first, &src->first) ||\n\t    get_user(info.step, &src->step))\n\t\treturn -EFAULT;\n\terr = snd_pcm_channel_info(substream, &info);\n\tif (err < 0)\n\t\treturn err;\n\tif (put_user(info.channel, &src->channel) ||\n\t    put_user(info.offset, &src->offset) ||\n\t    put_user(info.first, &src->first) ||\n\t    put_user(info.step, &src->step))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\n#ifdef CONFIG_X86_X32_ABI\n \nstatic int snd_pcm_channel_info_user(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_channel_info __user *src);\n#define snd_pcm_ioctl_channel_info_x32(s, p)\t\\\n\tsnd_pcm_channel_info_user(s, p)\n#endif  \n\nstruct compat_snd_pcm_status64 {\n\tsnd_pcm_state_t state;\n\tu8 rsvd[4];  \n\ts64 trigger_tstamp_sec;\n\ts64 trigger_tstamp_nsec;\n\ts64 tstamp_sec;\n\ts64 tstamp_nsec;\n\tu32 appl_ptr;\n\tu32 hw_ptr;\n\ts32 delay;\n\tu32 avail;\n\tu32 avail_max;\n\tu32 overrange;\n\tsnd_pcm_state_t suspended_state;\n\tu32 audio_tstamp_data;\n\ts64 audio_tstamp_sec;\n\ts64 audio_tstamp_nsec;\n\ts64 driver_tstamp_sec;\n\ts64 driver_tstamp_nsec;\n\tu32 audio_tstamp_accuracy;\n\tunsigned char reserved[52-4*sizeof(s64)];\n} __packed;\n\nstatic int snd_pcm_status_user_compat64(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct compat_snd_pcm_status64 __user *src,\n\t\t\t\t\tbool ext)\n{\n\tstruct snd_pcm_status64 status;\n\tstruct compat_snd_pcm_status64 compat_status64;\n\tint err;\n\n\tmemset(&status, 0, sizeof(status));\n\tmemset(&compat_status64, 0, sizeof(compat_status64));\n\t \n\tif (ext && get_user(status.audio_tstamp_data,\n\t\t\t\t(u32 __user *)(&src->audio_tstamp_data)))\n\t\treturn -EFAULT;\n\terr = snd_pcm_status64(substream, &status);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (clear_user(src, sizeof(*src)))\n\t\treturn -EFAULT;\n\n\tcompat_status64 = (struct compat_snd_pcm_status64) {\n\t\t.state = status.state,\n\t\t.trigger_tstamp_sec = status.trigger_tstamp_sec,\n\t\t.trigger_tstamp_nsec = status.trigger_tstamp_nsec,\n\t\t.tstamp_sec = status.tstamp_sec,\n\t\t.tstamp_nsec = status.tstamp_nsec,\n\t\t.appl_ptr = status.appl_ptr,\n\t\t.hw_ptr = status.hw_ptr,\n\t\t.delay = status.delay,\n\t\t.avail = status.avail,\n\t\t.avail_max = status.avail_max,\n\t\t.overrange = status.overrange,\n\t\t.suspended_state = status.suspended_state,\n\t\t.audio_tstamp_data = status.audio_tstamp_data,\n\t\t.audio_tstamp_sec = status.audio_tstamp_sec,\n\t\t.audio_tstamp_nsec = status.audio_tstamp_nsec,\n\t\t.driver_tstamp_sec = status.audio_tstamp_sec,\n\t\t.driver_tstamp_nsec = status.audio_tstamp_nsec,\n\t\t.audio_tstamp_accuracy = status.audio_tstamp_accuracy,\n\t};\n\n\tif (copy_to_user(src, &compat_status64, sizeof(compat_status64)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\n \nstatic int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,\n\t\t\t\t\t  int refine, \n\t\t\t\t\t  struct snd_pcm_hw_params32 __user *data32)\n{\n\tstruct snd_pcm_hw_params *data;\n\tstruct snd_pcm_runtime *runtime;\n\tint err;\n\n\truntime = substream->runtime;\n\tif (!runtime)\n\t\treturn -ENOTTY;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tif (copy_from_user(data, data32, sizeof(*data32))) {\n\t\terr = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tif (refine) {\n\t\terr = snd_pcm_hw_refine(substream, data);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\terr = fixup_unreferenced_params(substream, data);\n\t} else {\n\t\terr = snd_pcm_hw_params(substream, data);\n\t}\n\tif (err < 0)\n\t\tgoto error;\n\tif (copy_to_user(data32, data, sizeof(*data32)) ||\n\t    put_user(data->fifo_size, &data32->fifo_size)) {\n\t\terr = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tif (! refine) {\n\t\tunsigned int new_boundary = recalculate_boundary(runtime);\n\t\tif (new_boundary)\n\t\t\truntime->boundary = new_boundary;\n\t}\n error:\n\tkfree(data);\n\treturn err;\n}\n\n\n \nstruct snd_xferi32 {\n\ts32 result;\n\tu32 buf;\n\tu32 frames;\n};\n\nstatic int snd_pcm_ioctl_xferi_compat(struct snd_pcm_substream *substream,\n\t\t\t\t      int dir, struct snd_xferi32 __user *data32)\n{\n\tcompat_caddr_t buf;\n\tu32 frames;\n\tint err;\n\n\tif (! substream->runtime)\n\t\treturn -ENOTTY;\n\tif (substream->stream != dir)\n\t\treturn -EINVAL;\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tif (get_user(buf, &data32->buf) ||\n\t    get_user(frames, &data32->frames))\n\t\treturn -EFAULT;\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\terr = snd_pcm_lib_write(substream, compat_ptr(buf), frames);\n\telse\n\t\terr = snd_pcm_lib_read(substream, compat_ptr(buf), frames);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (put_user(err, &data32->result))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\n \nstruct snd_xfern32 {\n\ts32 result;\n\tu32 bufs;   \n\tu32 frames;\n};\n\n \nstatic int snd_pcm_ioctl_xfern_compat(struct snd_pcm_substream *substream,\n\t\t\t\t      int dir, struct snd_xfern32 __user *data32)\n{\n\tcompat_caddr_t buf;\n\tcompat_caddr_t __user *bufptr;\n\tu32 frames;\n\tvoid __user **bufs;\n\tint err, ch, i;\n\n\tif (! substream->runtime)\n\t\treturn -ENOTTY;\n\tif (substream->stream != dir)\n\t\treturn -EINVAL;\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tch = substream->runtime->channels;\n\tif (ch > 128)\n\t\treturn -EINVAL;\n\tif (get_user(buf, &data32->bufs) ||\n\t    get_user(frames, &data32->frames))\n\t\treturn -EFAULT;\n\tbufptr = compat_ptr(buf);\n\tbufs = kmalloc_array(ch, sizeof(void __user *), GFP_KERNEL);\n\tif (bufs == NULL)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < ch; i++) {\n\t\tu32 ptr;\n\t\tif (get_user(ptr, bufptr)) {\n\t\t\tkfree(bufs);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbufs[i] = compat_ptr(ptr);\n\t\tbufptr++;\n\t}\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\terr = snd_pcm_lib_writev(substream, bufs, frames);\n\telse\n\t\terr = snd_pcm_lib_readv(substream, bufs, frames);\n\tif (err >= 0) {\n\t\tif (put_user(err, &data32->result))\n\t\t\terr = -EFAULT;\n\t}\n\tkfree(bufs);\n\treturn err;\n}\n\n#ifdef CONFIG_X86_X32_ABI\n \nstruct snd_pcm_mmap_status_x32 {\n\tsnd_pcm_state_t state;\n\ts32 pad1;\n\tu32 hw_ptr;\n\tu32 pad2;  \n\ts64 tstamp_sec;\n\ts64 tstamp_nsec;\n\tsnd_pcm_state_t suspended_state;\n\ts32 pad3;\n\ts64 audio_tstamp_sec;\n\ts64 audio_tstamp_nsec;\n} __packed;\n\nstruct snd_pcm_mmap_control_x32 {\n\tu32 appl_ptr;\n\tu32 avail_min;\n};\n\nstruct snd_pcm_sync_ptr_x32 {\n\tu32 flags;\n\tu32 rsvd;  \n\tunion {\n\t\tstruct snd_pcm_mmap_status_x32 status;\n\t\tunsigned char reserved[64];\n\t} s;\n\tunion {\n\t\tstruct snd_pcm_mmap_control_x32 control;\n\t\tunsigned char reserved[64];\n\t} c;\n} __packed;\n\nstatic int snd_pcm_ioctl_sync_ptr_x32(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_sync_ptr_x32 __user *src)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tvolatile struct snd_pcm_mmap_status *status;\n\tvolatile struct snd_pcm_mmap_control *control;\n\tu32 sflags;\n\tstruct snd_pcm_mmap_control scontrol;\n\tstruct snd_pcm_mmap_status sstatus;\n\tsnd_pcm_uframes_t boundary;\n\tint err;\n\n\tif (snd_BUG_ON(!runtime))\n\t\treturn -EINVAL;\n\n\tif (get_user(sflags, &src->flags) ||\n\t    get_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\n\t    get_user(scontrol.avail_min, &src->c.control.avail_min))\n\t\treturn -EFAULT;\n\tif (sflags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\n\t\terr = snd_pcm_hwsync(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tstatus = runtime->status;\n\tcontrol = runtime->control;\n\tboundary = recalculate_boundary(runtime);\n\tif (!boundary)\n\t\tboundary = 0x7fffffff;\n\tsnd_pcm_stream_lock_irq(substream);\n\t \n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))\n\t\tcontrol->appl_ptr = scontrol.appl_ptr;\n\telse\n\t\tscontrol.appl_ptr = control->appl_ptr % boundary;\n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\n\t\tcontrol->avail_min = scontrol.avail_min;\n\telse\n\t\tscontrol.avail_min = control->avail_min;\n\tsstatus.state = status->state;\n\tsstatus.hw_ptr = status->hw_ptr % boundary;\n\tsstatus.tstamp = status->tstamp;\n\tsstatus.suspended_state = status->suspended_state;\n\tsstatus.audio_tstamp = status->audio_tstamp;\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\tif (put_user(sstatus.state, &src->s.status.state) ||\n\t    put_user(sstatus.hw_ptr, &src->s.status.hw_ptr) ||\n\t    put_user(sstatus.tstamp.tv_sec, &src->s.status.tstamp_sec) ||\n\t    put_user(sstatus.tstamp.tv_nsec, &src->s.status.tstamp_nsec) ||\n\t    put_user(sstatus.suspended_state, &src->s.status.suspended_state) ||\n\t    put_user(sstatus.audio_tstamp.tv_sec, &src->s.status.audio_tstamp_sec) ||\n\t    put_user(sstatus.audio_tstamp.tv_nsec, &src->s.status.audio_tstamp_nsec) ||\n\t    put_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\n\t    put_user(scontrol.avail_min, &src->c.control.avail_min))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif  \n\n#ifdef __BIG_ENDIAN\ntypedef char __pad_before_u32[4];\ntypedef char __pad_after_u32[0];\n#else\ntypedef char __pad_before_u32[0];\ntypedef char __pad_after_u32[4];\n#endif\n\n \nstruct __snd_pcm_mmap_control64_buggy {\n\t__pad_before_u32 __pad1;\n\t__u32 appl_ptr;\n\t__pad_before_u32 __pad2;\t \n\t__pad_before_u32 __pad3;\n\t__u32 avail_min;\n\t__pad_after_uframe __pad4;\n};\n\nstatic int snd_pcm_ioctl_sync_ptr_buggy(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_sync_ptr __user *_sync_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_sync_ptr sync_ptr;\n\tstruct __snd_pcm_mmap_control64_buggy *sync_cp;\n\tvolatile struct snd_pcm_mmap_status *status;\n\tvolatile struct snd_pcm_mmap_control *control;\n\tint err;\n\n\tmemset(&sync_ptr, 0, sizeof(sync_ptr));\n\tsync_cp = (struct __snd_pcm_mmap_control64_buggy *)&sync_ptr.c.control;\n\tif (get_user(sync_ptr.flags, (unsigned __user *)&(_sync_ptr->flags)))\n\t\treturn -EFAULT;\n\tif (copy_from_user(sync_cp, &(_sync_ptr->c.control), sizeof(*sync_cp)))\n\t\treturn -EFAULT;\n\tstatus = runtime->status;\n\tcontrol = runtime->control;\n\tif (sync_ptr.flags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\n\t\terr = snd_pcm_hwsync(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL)) {\n\t\terr = pcm_lib_apply_appl_ptr(substream, sync_cp->appl_ptr);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tsync_cp->appl_ptr = control->appl_ptr;\n\t}\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\n\t\tcontrol->avail_min = sync_cp->avail_min;\n\telse\n\t\tsync_cp->avail_min = control->avail_min;\n\tsync_ptr.s.status.state = status->state;\n\tsync_ptr.s.status.hw_ptr = status->hw_ptr;\n\tsync_ptr.s.status.tstamp = status->tstamp;\n\tsync_ptr.s.status.suspended_state = status->suspended_state;\n\tsync_ptr.s.status.audio_tstamp = status->audio_tstamp;\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL))\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\tif (copy_to_user(_sync_ptr, &sync_ptr, sizeof(sync_ptr)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nenum {\n\tSNDRV_PCM_IOCTL_HW_REFINE32 = _IOWR('A', 0x10, struct snd_pcm_hw_params32),\n\tSNDRV_PCM_IOCTL_HW_PARAMS32 = _IOWR('A', 0x11, struct snd_pcm_hw_params32),\n\tSNDRV_PCM_IOCTL_SW_PARAMS32 = _IOWR('A', 0x13, struct snd_pcm_sw_params32),\n\tSNDRV_PCM_IOCTL_STATUS_COMPAT32 = _IOR('A', 0x20, struct snd_pcm_status32),\n\tSNDRV_PCM_IOCTL_STATUS_EXT_COMPAT32 = _IOWR('A', 0x24, struct snd_pcm_status32),\n\tSNDRV_PCM_IOCTL_DELAY32 = _IOR('A', 0x21, s32),\n\tSNDRV_PCM_IOCTL_CHANNEL_INFO32 = _IOR('A', 0x32, struct snd_pcm_channel_info32),\n\tSNDRV_PCM_IOCTL_REWIND32 = _IOW('A', 0x46, u32),\n\tSNDRV_PCM_IOCTL_FORWARD32 = _IOW('A', 0x49, u32),\n\tSNDRV_PCM_IOCTL_WRITEI_FRAMES32 = _IOW('A', 0x50, struct snd_xferi32),\n\tSNDRV_PCM_IOCTL_READI_FRAMES32 = _IOR('A', 0x51, struct snd_xferi32),\n\tSNDRV_PCM_IOCTL_WRITEN_FRAMES32 = _IOW('A', 0x52, struct snd_xfern32),\n\tSNDRV_PCM_IOCTL_READN_FRAMES32 = _IOR('A', 0x53, struct snd_xfern32),\n\tSNDRV_PCM_IOCTL_STATUS_COMPAT64 = _IOR('A', 0x20, struct compat_snd_pcm_status64),\n\tSNDRV_PCM_IOCTL_STATUS_EXT_COMPAT64 = _IOWR('A', 0x24, struct compat_snd_pcm_status64),\n#ifdef CONFIG_X86_X32_ABI\n\tSNDRV_PCM_IOCTL_CHANNEL_INFO_X32 = _IOR('A', 0x32, struct snd_pcm_channel_info),\n\tSNDRV_PCM_IOCTL_SYNC_PTR_X32 = _IOWR('A', 0x23, struct snd_pcm_sync_ptr_x32),\n#endif  \n};\n\nstatic long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tvoid __user *argp = compat_ptr(arg);\n\n\tpcm_file = file->private_data;\n\tif (! pcm_file)\n\t\treturn -ENOTTY;\n\tsubstream = pcm_file->substream;\n\tif (! substream)\n\t\treturn -ENOTTY;\n\n\t \n\tpcm_file->no_compat_mmap = 1;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL_PVERSION:\n\tcase SNDRV_PCM_IOCTL_INFO:\n\tcase SNDRV_PCM_IOCTL_TSTAMP:\n\tcase SNDRV_PCM_IOCTL_TTSTAMP:\n\tcase SNDRV_PCM_IOCTL_USER_PVERSION:\n\tcase SNDRV_PCM_IOCTL_HWSYNC:\n\tcase SNDRV_PCM_IOCTL_PREPARE:\n\tcase SNDRV_PCM_IOCTL_RESET:\n\tcase SNDRV_PCM_IOCTL_START:\n\tcase SNDRV_PCM_IOCTL_DROP:\n\tcase SNDRV_PCM_IOCTL_DRAIN:\n\tcase SNDRV_PCM_IOCTL_PAUSE:\n\tcase SNDRV_PCM_IOCTL_HW_FREE:\n\tcase SNDRV_PCM_IOCTL_RESUME:\n\tcase SNDRV_PCM_IOCTL_XRUN:\n\tcase SNDRV_PCM_IOCTL_LINK:\n\tcase SNDRV_PCM_IOCTL_UNLINK:\n\tcase __SNDRV_PCM_IOCTL_SYNC_PTR32:\n\t\treturn snd_pcm_common_ioctl(file, substream, cmd, argp);\n\tcase __SNDRV_PCM_IOCTL_SYNC_PTR64:\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall())\n\t\t\treturn snd_pcm_ioctl_sync_ptr_x32(substream, argp);\n#endif  \n\t\treturn snd_pcm_ioctl_sync_ptr_buggy(substream, argp);\n\tcase SNDRV_PCM_IOCTL_HW_REFINE32:\n\t\treturn snd_pcm_ioctl_hw_params_compat(substream, 1, argp);\n\tcase SNDRV_PCM_IOCTL_HW_PARAMS32:\n\t\treturn snd_pcm_ioctl_hw_params_compat(substream, 0, argp);\n\tcase SNDRV_PCM_IOCTL_SW_PARAMS32:\n\t\treturn snd_pcm_ioctl_sw_params_compat(substream, argp);\n\tcase SNDRV_PCM_IOCTL_STATUS_COMPAT32:\n\t\treturn snd_pcm_status_user32(substream, argp, false);\n\tcase SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT32:\n\t\treturn snd_pcm_status_user32(substream, argp, true);\n\tcase SNDRV_PCM_IOCTL_CHANNEL_INFO32:\n\t\treturn snd_pcm_ioctl_channel_info_compat(substream, argp);\n\tcase SNDRV_PCM_IOCTL_WRITEI_FRAMES32:\n\t\treturn snd_pcm_ioctl_xferi_compat(substream, SNDRV_PCM_STREAM_PLAYBACK, argp);\n\tcase SNDRV_PCM_IOCTL_READI_FRAMES32:\n\t\treturn snd_pcm_ioctl_xferi_compat(substream, SNDRV_PCM_STREAM_CAPTURE, argp);\n\tcase SNDRV_PCM_IOCTL_WRITEN_FRAMES32:\n\t\treturn snd_pcm_ioctl_xfern_compat(substream, SNDRV_PCM_STREAM_PLAYBACK, argp);\n\tcase SNDRV_PCM_IOCTL_READN_FRAMES32:\n\t\treturn snd_pcm_ioctl_xfern_compat(substream, SNDRV_PCM_STREAM_CAPTURE, argp);\n\tcase SNDRV_PCM_IOCTL_DELAY32:\n\t\treturn snd_pcm_ioctl_delay_compat(substream, argp);\n\tcase SNDRV_PCM_IOCTL_REWIND32:\n\t\treturn snd_pcm_ioctl_rewind_compat(substream, argp);\n\tcase SNDRV_PCM_IOCTL_FORWARD32:\n\t\treturn snd_pcm_ioctl_forward_compat(substream, argp);\n\tcase SNDRV_PCM_IOCTL_STATUS_COMPAT64:\n\t\treturn snd_pcm_status_user_compat64(substream, argp, false);\n\tcase SNDRV_PCM_IOCTL_STATUS_EXT_COMPAT64:\n\t\treturn snd_pcm_status_user_compat64(substream, argp, true);\n#ifdef CONFIG_X86_X32_ABI\n\tcase SNDRV_PCM_IOCTL_CHANNEL_INFO_X32:\n\t\treturn snd_pcm_ioctl_channel_info_x32(substream, argp);\n#endif  \n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}