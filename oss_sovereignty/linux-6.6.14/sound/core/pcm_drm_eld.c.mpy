{
  "module_name": "pcm_drm_eld.c",
  "hash_id": "5e12a50ecb2224762498b631711d48b7d1acfe49c702aa056682cb46aa925f4b",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_drm_eld.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/export.h>\n#include <linux/hdmi.h>\n#include <drm/drm_edid.h>\n#include <sound/pcm.h>\n#include <sound/pcm_drm_eld.h>\n\n#define SAD0_CHANNELS_MASK\tGENMASK(2, 0)  \n#define SAD0_FORMAT_MASK\tGENMASK(6, 3)  \n\n#define SAD1_RATE_MASK\t\tGENMASK(6, 0)  \n#define SAD1_RATE_32000_MASK\tBIT(0)\n#define SAD1_RATE_44100_MASK\tBIT(1)\n#define SAD1_RATE_48000_MASK\tBIT(2)\n#define SAD1_RATE_88200_MASK\tBIT(3)\n#define SAD1_RATE_96000_MASK\tBIT(4)\n#define SAD1_RATE_176400_MASK\tBIT(5)\n#define SAD1_RATE_192000_MASK\tBIT(6)\n\nstatic const unsigned int eld_rates[] = {\n\t32000,\n\t44100,\n\t48000,\n\t88200,\n\t96000,\n\t176400,\n\t192000,\n};\n\nstatic unsigned int map_rate_families(const u8 *sad,\n\t\t\t\t      unsigned int mask_32000,\n\t\t\t\t      unsigned int mask_44100,\n\t\t\t\t      unsigned int mask_48000)\n{\n\tunsigned int rate_mask = 0;\n\n\tif (sad[1] & SAD1_RATE_32000_MASK)\n\t\trate_mask |= mask_32000;\n\tif (sad[1] & (SAD1_RATE_44100_MASK | SAD1_RATE_88200_MASK | SAD1_RATE_176400_MASK))\n\t\trate_mask |= mask_44100;\n\tif (sad[1] & (SAD1_RATE_48000_MASK | SAD1_RATE_96000_MASK | SAD1_RATE_192000_MASK))\n\t\trate_mask |= mask_48000;\n\treturn rate_mask;\n}\n\nstatic unsigned int sad_rate_mask(const u8 *sad)\n{\n\tswitch (FIELD_GET(SAD0_FORMAT_MASK, sad[0])) {\n\tcase HDMI_AUDIO_CODING_TYPE_PCM:\n\t\treturn sad[1] & SAD1_RATE_MASK;\n\tcase HDMI_AUDIO_CODING_TYPE_AC3:\n\tcase HDMI_AUDIO_CODING_TYPE_DTS:\n\t\treturn map_rate_families(sad,\n\t\t\t\t\t SAD1_RATE_32000_MASK,\n\t\t\t\t\t SAD1_RATE_44100_MASK,\n\t\t\t\t\t SAD1_RATE_48000_MASK);\n\tcase HDMI_AUDIO_CODING_TYPE_EAC3:\n\tcase HDMI_AUDIO_CODING_TYPE_DTS_HD:\n\tcase HDMI_AUDIO_CODING_TYPE_MLP:\n\t\treturn map_rate_families(sad,\n\t\t\t\t\t 0,\n\t\t\t\t\t SAD1_RATE_176400_MASK,\n\t\t\t\t\t SAD1_RATE_192000_MASK);\n\tdefault:\n\t\t \n\t\treturn sad[1] & SAD1_RATE_MASK;\n\t}\n}\n\nstatic unsigned int sad_max_channels(const u8 *sad)\n{\n\tswitch (FIELD_GET(SAD0_FORMAT_MASK, sad[0])) {\n\tcase HDMI_AUDIO_CODING_TYPE_PCM:\n\t\treturn 1 + FIELD_GET(SAD0_CHANNELS_MASK, sad[0]);\n\tcase HDMI_AUDIO_CODING_TYPE_AC3:\n\tcase HDMI_AUDIO_CODING_TYPE_DTS:\n\tcase HDMI_AUDIO_CODING_TYPE_EAC3:\n\t\treturn 2;\n\tcase HDMI_AUDIO_CODING_TYPE_DTS_HD:\n\tcase HDMI_AUDIO_CODING_TYPE_MLP:\n\t\treturn 8;\n\tdefault:\n\t\t \n\t\treturn 1 + FIELD_GET(SAD0_CHANNELS_MASK, sad[0]);\n\t}\n}\n\nstatic int eld_limit_rates(struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *r = hw_param_interval(params, rule->var);\n\tconst struct snd_interval *c;\n\tunsigned int rate_mask = 7, i;\n\tconst u8 *sad, *eld = rule->private;\n\n\tsad = drm_eld_sad(eld);\n\tif (sad) {\n\t\tc = hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\n\t\tfor (i = drm_eld_sad_count(eld); i > 0; i--, sad += 3) {\n\t\t\tunsigned max_channels = sad_max_channels(sad);\n\n\t\t\t \n\t\t\tif (c->min <= max_channels)\n\t\t\t\trate_mask |= sad_rate_mask(sad);\n\t\t}\n\t}\n\n\treturn snd_interval_list(r, ARRAY_SIZE(eld_rates), eld_rates,\n\t\t\t\t rate_mask);\n}\n\nstatic int eld_limit_channels(struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params, rule->var);\n\tconst struct snd_interval *r;\n\tstruct snd_interval t = { .min = 1, .max = 2, .integer = 1, };\n\tunsigned int i;\n\tconst u8 *sad, *eld = rule->private;\n\n\tsad = drm_eld_sad(eld);\n\tif (sad) {\n\t\tunsigned int rate_mask = 0;\n\n\t\t \n\t\tr = hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\tfor (i = 0; i < ARRAY_SIZE(eld_rates); i++)\n\t\t\tif (r->min <= eld_rates[i] && r->max >= eld_rates[i])\n\t\t\t\trate_mask |= BIT(i);\n\n\t\tfor (i = drm_eld_sad_count(eld); i > 0; i--, sad += 3)\n\t\t\tif (rate_mask & sad_rate_mask(sad))\n\t\t\t\tt.max = max(t.max, sad_max_channels(sad));\n\t}\n\n\treturn snd_interval_refine(c, &t);\n}\n\nint snd_pcm_hw_constraint_eld(struct snd_pcm_runtime *runtime, void *eld)\n{\n\tint ret;\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  eld_limit_rates, eld,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  eld_limit_channels, eld,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_hw_constraint_eld);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}