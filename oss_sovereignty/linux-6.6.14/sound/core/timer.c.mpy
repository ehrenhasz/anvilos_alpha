{
  "module_name": "timer.c",
  "hash_id": "abd8dcf98f246f9ba6aa019cfceafe3f8e6c54aee9f362057f7158ac19908eb9",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/timer.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n\n \n#define SNDRV_TIMER_IFLG_PAUSED\t\t0x00010000\n#define SNDRV_TIMER_IFLG_DEAD\t\t0x00020000\n\n#if IS_ENABLED(CONFIG_SND_HRTIMER)\n#define DEFAULT_TIMER_LIMIT 4\n#else\n#define DEFAULT_TIMER_LIMIT 1\n#endif\n\nstatic int timer_limit = DEFAULT_TIMER_LIMIT;\nstatic int timer_tstamp_monotonic = 1;\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA timer interface\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(timer_limit, int, 0444);\nMODULE_PARM_DESC(timer_limit, \"Maximum global timers in system.\");\nmodule_param(timer_tstamp_monotonic, int, 0444);\nMODULE_PARM_DESC(timer_tstamp_monotonic, \"Use posix monotonic clock source for timestamps (default).\");\n\nMODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);\nMODULE_ALIAS(\"devname:snd/timer\");\n\nenum timer_tread_format {\n\tTREAD_FORMAT_NONE = 0,\n\tTREAD_FORMAT_TIME64,\n\tTREAD_FORMAT_TIME32,\n};\n\nstruct snd_timer_tread32 {\n\tint event;\n\ts32 tstamp_sec;\n\ts32 tstamp_nsec;\n\tunsigned int val;\n};\n\nstruct snd_timer_tread64 {\n\tint event;\n\tu8 pad1[4];\n\ts64 tstamp_sec;\n\ts64 tstamp_nsec;\n\tunsigned int val;\n\tu8 pad2[4];\n};\n\nstruct snd_timer_user {\n\tstruct snd_timer_instance *timeri;\n\tint tread;\t\t \n\tunsigned long ticks;\n\tunsigned long overrun;\n\tint qhead;\n\tint qtail;\n\tint qused;\n\tint queue_size;\n\tbool disconnected;\n\tstruct snd_timer_read *queue;\n\tstruct snd_timer_tread64 *tqueue;\n\tspinlock_t qlock;\n\tunsigned long last_resolution;\n\tunsigned int filter;\n\tstruct timespec64 tstamp;\t\t \n\twait_queue_head_t qchange_sleep;\n\tstruct snd_fasync *fasync;\n\tstruct mutex ioctl_lock;\n};\n\nstruct snd_timer_status32 {\n\ts32 tstamp_sec;\t\t\t \n\ts32 tstamp_nsec;\n\tunsigned int resolution;\t \n\tunsigned int lost;\t\t \n\tunsigned int overrun;\t\t \n\tunsigned int queue;\t\t \n\tunsigned char reserved[64];\t \n};\n\n#define SNDRV_TIMER_IOCTL_STATUS32\t_IOR('T', 0x14, struct snd_timer_status32)\n\nstruct snd_timer_status64 {\n\ts64 tstamp_sec;\t\t\t \n\ts64 tstamp_nsec;\n\tunsigned int resolution;\t \n\tunsigned int lost;\t\t \n\tunsigned int overrun;\t\t \n\tunsigned int queue;\t\t \n\tunsigned char reserved[64];\t \n};\n\n#define SNDRV_TIMER_IOCTL_STATUS64\t_IOR('T', 0x14, struct snd_timer_status64)\n\n \nstatic LIST_HEAD(snd_timer_list);\n\n \nstatic LIST_HEAD(snd_timer_slave_list);\n\n \nstatic DEFINE_SPINLOCK(slave_active_lock);\n\n#define MAX_SLAVE_INSTANCES\t1000\nstatic int num_slaves;\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_timer_free(struct snd_timer *timer);\nstatic int snd_timer_dev_free(struct snd_device *device);\nstatic int snd_timer_dev_register(struct snd_device *device);\nstatic int snd_timer_dev_disconnect(struct snd_device *device);\n\nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);\n\n \nstruct snd_timer_instance *snd_timer_instance_new(const char *owner)\n{\n\tstruct snd_timer_instance *timeri;\n\n\ttimeri = kzalloc(sizeof(*timeri), GFP_KERNEL);\n\tif (timeri == NULL)\n\t\treturn NULL;\n\ttimeri->owner = kstrdup(owner, GFP_KERNEL);\n\tif (! timeri->owner) {\n\t\tkfree(timeri);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&timeri->open_list);\n\tINIT_LIST_HEAD(&timeri->active_list);\n\tINIT_LIST_HEAD(&timeri->ack_list);\n\tINIT_LIST_HEAD(&timeri->slave_list_head);\n\tINIT_LIST_HEAD(&timeri->slave_active_head);\n\n\treturn timeri;\n}\nEXPORT_SYMBOL(snd_timer_instance_new);\n\nvoid snd_timer_instance_free(struct snd_timer_instance *timeri)\n{\n\tif (timeri) {\n\t\tif (timeri->private_free)\n\t\t\ttimeri->private_free(timeri);\n\t\tkfree(timeri->owner);\n\t\tkfree(timeri);\n\t}\n}\nEXPORT_SYMBOL(snd_timer_instance_free);\n\n \nstatic struct snd_timer *snd_timer_find(struct snd_timer_id *tid)\n{\n\tstruct snd_timer *timer;\n\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->tmr_class != tid->dev_class)\n\t\t\tcontinue;\n\t\tif ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||\n\t\t     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&\n\t\t    (timer->card == NULL ||\n\t\t     timer->card->number != tid->card))\n\t\t\tcontinue;\n\t\tif (timer->tmr_device != tid->device)\n\t\t\tcontinue;\n\t\tif (timer->tmr_subdevice != tid->subdevice)\n\t\t\tcontinue;\n\t\treturn timer;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic void snd_timer_request(struct snd_timer_id *tid)\n{\n\tswitch (tid->dev_class) {\n\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\tif (tid->device < timer_limit)\n\t\t\trequest_module(\"snd-timer-%i\", tid->device);\n\t\tbreak;\n\tcase SNDRV_TIMER_CLASS_CARD:\n\tcase SNDRV_TIMER_CLASS_PCM:\n\t\tif (tid->card < snd_ecards_limit)\n\t\t\trequest_module(\"snd-card-%i\", tid->card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#endif\n\n \nstatic int check_matching_master_slave(struct snd_timer_instance *master,\n\t\t\t\t       struct snd_timer_instance *slave)\n{\n\tif (slave->slave_class != master->slave_class ||\n\t    slave->slave_id != master->slave_id)\n\t\treturn 0;\n\tif (master->timer->num_instances >= master->timer->max_instances)\n\t\treturn -EBUSY;\n\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\tmaster->timer->num_instances++;\n\tspin_lock_irq(&slave_active_lock);\n\tspin_lock(&master->timer->lock);\n\tslave->master = master;\n\tslave->timer = master->timer;\n\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\tlist_add_tail(&slave->active_list, &master->slave_active_head);\n\tspin_unlock(&master->timer->lock);\n\tspin_unlock_irq(&slave_active_lock);\n\treturn 1;\n}\n\n \nstatic int snd_timer_check_slave(struct snd_timer_instance *slave)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *master;\n\tint err = 0;\n\n\t \n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tlist_for_each_entry(master, &timer->open_list_head, open_list) {\n\t\t\terr = check_matching_master_slave(master, slave);\n\t\t\tif (err != 0)  \n\t\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\treturn err < 0 ? err : 0;\n}\n\n \nstatic int snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\tint err = 0;\n\n\t \n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\terr = check_matching_master_slave(master, slave);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err < 0 ? err : 0;\n}\n\nstatic void snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t   struct device **card_devp_to_put);\n\n \nint snd_timer_open(struct snd_timer_instance *timeri,\n\t\t   struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t \n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (num_slaves >= MAX_SLAVE_INSTANCES) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\tnum_slaves++;\n\t\terr = snd_timer_check_slave(timeri);\n\t\tgoto list_added;\n\t}\n\n\t \n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\tstruct snd_timer_instance *t =\n\t\t\tlist_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (!try_module_get(timer->module)) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\t \n\tif (timer->card) {\n\t\tget_device(&timer->card->card_dev);\n\t\tcard_dev_to_put = &timer->card->card_dev;\n\t}\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\ttimeri->timer = timer;\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\nlist_added:\n\tif (err < 0)\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t \n\tif (err < 0 && card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_timer_open);\n\n \nstatic void snd_timer_close_locked(struct snd_timer_instance *timeri,\n\t\t\t\t   struct device **card_devp_to_put)\n{\n\tstruct snd_timer *timer = timeri->timer;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (timer) {\n\t\tspin_lock_irq(&timer->lock);\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_DEAD;\n\t\tspin_unlock_irq(&timer->lock);\n\t}\n\n\tif (!list_empty(&timeri->open_list)) {\n\t\tlist_del_init(&timeri->open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\tnum_slaves--;\n\t}\n\n\t \n\tsnd_timer_stop(timeri);\n\n\tif (timer) {\n\t\ttimer->num_instances--;\n\t\t \n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\n\t\t \n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\ttimeri->timer = NULL;\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\ttimer->num_instances--;\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\n\t\t \n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\ttimer = NULL;\n\t}\n\n\tif (timer) {\n\t\tif (list_empty(&timer->open_list_head) && timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t \n\t\tif (timer->card)\n\t\t\t*card_devp_to_put = &timer->card->card_dev;\n\t\tmodule_put(timer->module);\n\t}\n}\n\n \nvoid snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct device *card_dev_to_put = NULL;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn;\n\n\tmutex_lock(&register_mutex);\n\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\tmutex_unlock(&register_mutex);\n\t \n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n}\nEXPORT_SYMBOL(snd_timer_close);\n\nstatic unsigned long snd_timer_hw_resolution(struct snd_timer *timer)\n{\n\tif (timer->hw.c_resolution)\n\t\treturn timer->hw.c_resolution(timer);\n\telse\n\t\treturn timer->hw.resolution;\n}\n\nunsigned long snd_timer_resolution(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer * timer;\n\tunsigned long ret = 0;\n\tunsigned long flags;\n\n\tif (timeri == NULL)\n\t\treturn 0;\n\ttimer = timeri->timer;\n\tif (timer) {\n\t\tspin_lock_irqsave(&timer->lock, flags);\n\t\tret = snd_timer_hw_resolution(timer);\n\t\tspin_unlock_irqrestore(&timer->lock, flags);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_timer_resolution);\n\nstatic void snd_timer_notify1(struct snd_timer_instance *ti, int event)\n{\n\tstruct snd_timer *timer = ti->timer;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ts;\n\tstruct timespec64 tstamp;\n\n\tif (timer_tstamp_monotonic)\n\t\tktime_get_ts64(&tstamp);\n\telse\n\t\tktime_get_real_ts64(&tstamp);\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||\n\t\t       event > SNDRV_TIMER_EVENT_PAUSE))\n\t\treturn;\n\tif (timer &&\n\t    (event == SNDRV_TIMER_EVENT_START ||\n\t     event == SNDRV_TIMER_EVENT_CONTINUE))\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tif (ti->ccallback)\n\t\tti->ccallback(ti, event, &tstamp, resolution);\n\tif (ti->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn;\n\tif (timer == NULL)\n\t\treturn;\n\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\treturn;\n\tevent += 10;  \n\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\tif (ts->ccallback)\n\t\t\tts->ccallback(ts, event, &tstamp, resolution);\n}\n\n \nstatic int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\tresult = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1;  \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n \nstatic int snd_timer_start_slave(struct snd_timer_instance *timeri,\n\t\t\t\t bool start)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\terr = 1;  \n unlock:\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn err;\n}\n\n \nstatic int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tif (stop)\n\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_PAUSED;\n\telse\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_PAUSED;\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}\n\n \nstatic int snd_timer_stop_slave(struct snd_timer_instance *timeri, bool stop)\n{\n\tunsigned long flags;\n\tbool running;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\trunning = timeri->flags & SNDRV_TIMER_IFLG_RUNNING;\n\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_del_init(&timeri->ack_list);\n\t\tlist_del_init(&timeri->active_list);\n\t\tif (running)\n\t\t\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t\t\t  SNDRV_TIMER_EVENT_PAUSE);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn running ? 0 : -EBUSY;\n}\n\n \nint snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)\n{\n\tif (timeri == NULL || ticks < 1)\n\t\treturn -EINVAL;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, true);\n\telse\n\t\treturn snd_timer_start1(timeri, true, ticks);\n}\nEXPORT_SYMBOL(snd_timer_start);\n\n \nint snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, true);\n\telse\n\t\treturn snd_timer_stop1(timeri, true);\n}\nEXPORT_SYMBOL(snd_timer_stop);\n\n \nint snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\t \n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn -EINVAL;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, false);\n\telse\n\t\treturn snd_timer_start1(timeri, false, 0);\n}\nEXPORT_SYMBOL(snd_timer_continue);\n\n \nint snd_timer_pause(struct snd_timer_instance * timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, false);\n\telse\n\t\treturn snd_timer_stop1(timeri, false);\n}\nEXPORT_SYMBOL(snd_timer_pause);\n\n \nstatic void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long ticks = ~0UL;\n\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_START) {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_START;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\t\ttimer->running++;\n\t\t}\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {\n\t\t\tif (ticks > ti->cticks)\n\t\t\t\tticks = ti->cticks;\n\t\t}\n\t}\n\tif (ticks == ~0UL) {\n\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\treturn;\n\t}\n\tif (ticks > timer->hw.ticks)\n\t\tticks = timer->hw.ticks;\n\tif (ticks_left != ticks)\n\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\ttimer->sticks = ticks;\n}\n\n \nstatic void snd_timer_process_callbacks(struct snd_timer *timer,\n\t\t\t\t\tstruct list_head *head)\n{\n\tstruct snd_timer_instance *ti;\n\tunsigned long resolution, ticks;\n\n\twhile (!list_empty(head)) {\n\t\tti = list_first_entry(head, struct snd_timer_instance,\n\t\t\t\t      ack_list);\n\n\t\t \n\t\tlist_del_init(&ti->ack_list);\n\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_DEAD)) {\n\t\t\tticks = ti->pticks;\n\t\t\tti->pticks = 0;\n\t\t\tresolution = ti->resolution;\n\t\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\t\tspin_unlock(&timer->lock);\n\t\t\tif (ti->callback)\n\t\t\t\tti->callback(ti, resolution, ticks);\n\t\t\tspin_lock(&timer->lock);\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t\t}\n\t}\n}\n\n \nstatic void snd_timer_clear_callbacks(struct snd_timer *timer,\n\t\t\t\t      struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\twhile (!list_empty(head))\n\t\tlist_del_init(head->next);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n \nstatic void snd_timer_work(struct work_struct *work)\n{\n\tstruct snd_timer *timer = container_of(work, struct snd_timer, task_work);\n\tunsigned long flags;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->sack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\tsnd_timer_process_callbacks(timer, &timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\n\n \nvoid snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution;\n\tstruct list_head *ack_list_head;\n\tunsigned long flags;\n\tbool use_work = false;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tif (timer->card && timer->card->shutdown) {\n\t\tsnd_timer_clear_callbacks(timer, &timer->ack_list_head);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t \n\tresolution = snd_timer_hw_resolution(timer);\n\n\t \n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_DEAD)\n\t\t\tcontinue;\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks)  \n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n\t\t} else {\n\t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\t--timer->running;\n\t\t\tlist_del_init(&ti->active_list);\n\t\t}\n\t\tif ((timer->hw.flags & SNDRV_TIMER_HW_WORK) ||\n\t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t \n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t \n\tsnd_timer_process_callbacks(timer, &timer->ack_list_head);\n\n\t \n\tuse_work = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_work)\n\t\tqueue_work(system_highpri_wq, &timer->task_work);\n}\nEXPORT_SYMBOL(snd_timer_interrupt);\n\n \n\nint snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,\n\t\t  struct snd_timer **rtimer)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_timer_dev_free,\n\t\t.dev_register = snd_timer_dev_register,\n\t\t.dev_disconnect = snd_timer_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!tid))\n\t\treturn -EINVAL;\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_CARD ||\n\t    tid->dev_class == SNDRV_TIMER_CLASS_PCM) {\n\t\tif (WARN_ON(!card))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rtimer)\n\t\t*rtimer = NULL;\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\ttimer->tmr_class = tid->dev_class;\n\ttimer->card = card;\n\ttimer->tmr_device = tid->device;\n\ttimer->tmr_subdevice = tid->subdevice;\n\tif (id)\n\t\tstrscpy(timer->id, id, sizeof(timer->id));\n\ttimer->sticks = 1;\n\tINIT_LIST_HEAD(&timer->device_list);\n\tINIT_LIST_HEAD(&timer->open_list_head);\n\tINIT_LIST_HEAD(&timer->active_list_head);\n\tINIT_LIST_HEAD(&timer->ack_list_head);\n\tINIT_LIST_HEAD(&timer->sack_list_head);\n\tspin_lock_init(&timer->lock);\n\tINIT_WORK(&timer->task_work, snd_timer_work);\n\ttimer->max_instances = 1000;  \n\tif (card != NULL) {\n\t\ttimer->module = card->module;\n\t\terr = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_free(timer);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (rtimer)\n\t\t*rtimer = timer;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_timer_new);\n\nstatic int snd_timer_free(struct snd_timer *timer)\n{\n\tif (!timer)\n\t\treturn 0;\n\n\tmutex_lock(&register_mutex);\n\tif (! list_empty(&timer->open_list_head)) {\n\t\tstruct list_head *p, *n;\n\t\tstruct snd_timer_instance *ti;\n\t\tpr_warn(\"ALSA: timer %p is busy?\\n\", timer);\n\t\tlist_for_each_safe(p, n, &timer->open_list_head) {\n\t\t\tlist_del_init(p);\n\t\t\tti = list_entry(p, struct snd_timer_instance, open_list);\n\t\t\tti->timer = NULL;\n\t\t}\n\t}\n\tlist_del(&timer->device_list);\n\tmutex_unlock(&register_mutex);\n\n\tif (timer->private_free)\n\t\ttimer->private_free(timer);\n\tkfree(timer);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n\nstatic int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t \n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tstruct snd_timer_instance *ti;\n\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\t \n\tlist_for_each_entry(ti, &timer->open_list_head, open_list) {\n\t\tif (ti->disconnect)\n\t\t\tti->disconnect(ti);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nvoid snd_timer_notify(struct snd_timer *timer, int event, struct timespec64 *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME)\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}\nEXPORT_SYMBOL(snd_timer_notify);\n\n \nint snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}\nEXPORT_SYMBOL(snd_timer_global_new);\n\nint snd_timer_global_free(struct snd_timer *timer)\n{\n\treturn snd_timer_free(timer);\n}\nEXPORT_SYMBOL(snd_timer_global_free);\n\nint snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}\nEXPORT_SYMBOL(snd_timer_global_register);\n\n \n\nstruct snd_timer_system_private {\n\tstruct timer_list tlist;\n\tstruct snd_timer *snd_timer;\n\tunsigned long last_expires;\n\tunsigned long last_jiffies;\n\tunsigned long correction;\n};\n\nstatic void snd_timer_s_function(struct timer_list *t)\n{\n\tstruct snd_timer_system_private *priv = from_timer(priv, t,\n\t\t\t\t\t\t\t\ttlist);\n\tstruct snd_timer *timer = priv->snd_timer;\n\tunsigned long jiff = jiffies;\n\tif (time_after(jiff, priv->last_expires))\n\t\tpriv->correction += (long)jiff - (long)priv->last_expires;\n\tsnd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);\n}\n\nstatic int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = njiff;\n\tmod_timer(&priv->tlist, njiff);\n\treturn 0;\n}\n\nstatic int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}\n\nstatic int snd_timer_s_close(struct snd_timer *timer)\n{\n\tstruct snd_timer_system_private *priv;\n\n\tpriv = (struct snd_timer_system_private *)timer->private_data;\n\tdel_timer_sync(&priv->tlist);\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_timer_system =\n{\n\t.flags =\tSNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_WORK,\n\t.resolution =\t1000000000L / HZ,\n\t.ticks =\t10000000L,\n\t.close =\tsnd_timer_s_close,\n\t.start =\tsnd_timer_s_start,\n\t.stop =\t\tsnd_timer_s_stop\n};\n\nstatic void snd_timer_free_system(struct snd_timer *timer)\n{\n\tkfree(timer->private_data);\n}\n\nstatic int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->snd_timer = timer;\n\ttimer_setup(&priv->tlist, snd_timer_s_function, 0);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n \n\nstatic void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tunsigned long resolution;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tspin_lock_irq(&timer->lock);\n\t\tresolution = snd_timer_hw_resolution(timer);\n\t\tspin_unlock_irq(&timer->lock);\n\t\tif (resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    resolution / 1000,\n\t\t\t\t    resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    (ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t  SNDRV_TIMER_IFLG_RUNNING))\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_timer_proc_entry;\n\nstatic void __init snd_timer_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"timers\", NULL);\n\tif (entry != NULL) {\n\t\tentry->c.text.read = snd_timer_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_timer_proc_entry = entry;\n}\n\nstatic void __exit snd_timer_proc_done(void)\n{\n\tsnd_info_free_entry(snd_timer_proc_entry);\n}\n#else  \n#define snd_timer_proc_init()\n#define snd_timer_proc_done()\n#endif\n\n \n\nstatic void snd_timer_user_interrupt(struct snd_timer_instance *timeri,\n\t\t\t\t     unsigned long resolution,\n\t\t\t\t     unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_read *r;\n\tint prev;\n\n\tspin_lock(&tu->qlock);\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->queue[prev];\n\t\tif (r->resolution == resolution) {\n\t\t\tr->ticks += ticks;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tr = &tu->queue[tu->qtail++];\n\t\ttu->qtail %= tu->queue_size;\n\t\tr->resolution = resolution;\n\t\tr->ticks = ticks;\n\t\ttu->qused++;\n\t}\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tsnd_kill_fasync(tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,\n\t\t\t\t\t    struct snd_timer_tread64 *tread)\n{\n\tif (tu->qused >= tu->queue_size) {\n\t\ttu->overrun++;\n\t} else {\n\t\tmemcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));\n\t\ttu->qtail %= tu->queue_size;\n\t\ttu->qused++;\n\t}\n}\n\nstatic void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec64 *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread64 r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp_sec = tstamp->tv_sec;\n\tr1.tstamp_nsec = tstamp->tv_nsec;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tsnd_kill_fasync(tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_disconnect(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\n\ttu->disconnected = true;\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread64 *r, r1;\n\tstruct timespec64 tstamp;\n\tint prev, append = 0;\n\n\tmemset(&r1, 0, sizeof(r1));\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts64(&tstamp);\n\t\telse\n\t\t\tktime_get_real_ts64(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp_sec = tstamp.tv_sec;\n\t\tr1.tstamp_nsec = tstamp.tv_nsec;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp_sec = tstamp.tv_sec;\n\t\t\tr->tstamp_nsec = tstamp.tv_nsec;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp_sec = tstamp.tv_sec;\n\tr1.tstamp_nsec = tstamp.tv_nsec;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tsnd_kill_fasync(tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n\nstatic int realloc_user_queue(struct snd_timer_user *tu, int size)\n{\n\tstruct snd_timer_read *queue = NULL;\n\tstruct snd_timer_tread64 *tqueue = NULL;\n\n\tif (tu->tread) {\n\t\ttqueue = kcalloc(size, sizeof(*tqueue), GFP_KERNEL);\n\t\tif (!tqueue)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tqueue = kcalloc(size, sizeof(*queue), GFP_KERNEL);\n\t\tif (!queue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irq(&tu->qlock);\n\tkfree(tu->queue);\n\tkfree(tu->tqueue);\n\ttu->queue_size = size;\n\ttu->queue = queue;\n\ttu->tqueue = tqueue;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn 0;\n}\n\nstatic int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\tif (realloc_user_queue(tu, 128) < 0) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n\nstatic int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri) {\n\t\t\tsnd_timer_close(tu->timeri);\n\t\t\tsnd_timer_instance_free(tu->timeri);\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tsnd_fasync_free(tu->fasync);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n\nstatic void snd_timer_user_zero_id(struct snd_timer_id *id)\n{\n\tid->dev_class = SNDRV_TIMER_CLASS_NONE;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = -1;\n\tid->device = -1;\n\tid->subdevice = -1;\n}\n\nstatic void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)\n{\n\tid->dev_class = timer->tmr_class;\n\tid->dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\tid->card = timer->card ? timer->card->number : -1;\n\tid->device = timer->tmr_device;\n\tid->subdevice = timer->tmr_subdevice;\n}\n\nstatic int snd_timer_user_next_device(struct snd_timer_id __user *_tid)\n{\n\tstruct snd_timer_id id;\n\tstruct snd_timer *timer;\n\tstruct list_head *p;\n\n\tif (copy_from_user(&id, _tid, sizeof(id)))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\tif (id.dev_class < 0) {\t\t \n\t\tif (list_empty(&snd_timer_list))\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\telse {\n\t\t\ttimer = list_entry(snd_timer_list.next,\n\t\t\t\t\t   struct snd_timer, device_list);\n\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t}\n\t} else {\n\t\tswitch (id.dev_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tid.device = id.device < 0 ? 0 : id.device + 1;\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device >= id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tif (id.card < 0) {\n\t\t\t\tid.card = 0;\n\t\t\t} else {\n\t\t\t\tif (id.device < 0) {\n\t\t\t\t\tid.device = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (id.subdevice < 0)\n\t\t\t\t\t\tid.subdevice = 0;\n\t\t\t\t\telse if (id.subdevice < INT_MAX)\n\t\t\t\t\t\tid.subdevice++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_for_each(p, &snd_timer_list) {\n\t\t\t\ttimer = list_entry(p, struct snd_timer, device_list);\n\t\t\t\tif (timer->tmr_class > id.dev_class) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_class < id.dev_class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->card->number > id.card) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->card->number < id.card)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_device > id.device) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_device < id.device)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (timer->tmr_subdevice > id.subdevice) {\n\t\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timer->tmr_subdevice < id.subdevice)\n\t\t\t\t\tcontinue;\n\t\t\t\tsnd_timer_user_copy_id(&id, timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &snd_timer_list)\n\t\t\t\tsnd_timer_user_zero_id(&id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_timer_user_zero_id(&id);\n\t\t}\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (copy_to_user(_tid, &id, sizeof(*_tid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_ginfo(struct file *file,\n\t\t\t\tstruct snd_timer_ginfo __user *_ginfo)\n{\n\tstruct snd_timer_ginfo *ginfo;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tginfo = memdup_user(_ginfo, sizeof(*ginfo));\n\tif (IS_ERR(ginfo))\n\t\treturn PTR_ERR(ginfo);\n\n\ttid = ginfo->tid;\n\tmemset(ginfo, 0, sizeof(*ginfo));\n\tginfo->tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tginfo->card = t->card ? t->card->number : -1;\n\t\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tginfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\t\tstrscpy(ginfo->id, t->id, sizeof(ginfo->id));\n\t\tstrscpy(ginfo->name, t->name, sizeof(ginfo->name));\n\t\tspin_lock_irq(&t->lock);\n\t\tginfo->resolution = snd_timer_hw_resolution(t);\n\t\tspin_unlock_irq(&t->lock);\n\t\tif (t->hw.resolution_min > 0) {\n\t\t\tginfo->resolution_min = t->hw.resolution_min;\n\t\t\tginfo->resolution_max = t->hw.resolution_max;\n\t\t}\n\t\tlist_for_each(p, &t->open_list_head) {\n\t\t\tginfo->clients++;\n\t\t}\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))\n\t\terr = -EFAULT;\n\tkfree(ginfo);\n\treturn err;\n}\n\nstatic int timer_set_gparams(struct snd_timer_gparams *gparams)\n{\n\tstruct snd_timer *t;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&gparams->tid);\n\tif (!t) {\n\t\terr = -ENODEV;\n\t\tgoto _error;\n\t}\n\tif (!list_empty(&t->open_list_head)) {\n\t\terr = -EBUSY;\n\t\tgoto _error;\n\t}\n\tif (!t->hw.set_period) {\n\t\terr = -ENOSYS;\n\t\tgoto _error;\n\t}\n\terr = t->hw.set_period(t, gparams->period_num, gparams->period_den);\n_error:\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_timer_user_gparams(struct file *file,\n\t\t\t\t  struct snd_timer_gparams __user *_gparams)\n{\n\tstruct snd_timer_gparams gparams;\n\n\tif (copy_from_user(&gparams, _gparams, sizeof(gparams)))\n\t\treturn -EFAULT;\n\treturn timer_set_gparams(&gparams);\n}\n\nstatic int snd_timer_user_gstatus(struct file *file,\n\t\t\t\t  struct snd_timer_gstatus __user *_gstatus)\n{\n\tstruct snd_timer_gstatus gstatus;\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\tif (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))\n\t\treturn -EFAULT;\n\ttid = gstatus.tid;\n\tmemset(&gstatus, 0, sizeof(gstatus));\n\tgstatus.tid = tid;\n\tmutex_lock(&register_mutex);\n\tt = snd_timer_find(&tid);\n\tif (t != NULL) {\n\t\tspin_lock_irq(&t->lock);\n\t\tgstatus.resolution = snd_timer_hw_resolution(t);\n\t\tif (t->hw.precise_resolution) {\n\t\t\tt->hw.precise_resolution(t, &gstatus.resolution_num,\n\t\t\t\t\t\t &gstatus.resolution_den);\n\t\t} else {\n\t\t\tgstatus.resolution_num = gstatus.resolution;\n\t\t\tgstatus.resolution_den = 1000000000uL;\n\t\t}\n\t\tspin_unlock_irq(&t->lock);\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&register_mutex);\n\tif (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\tsnd_timer_instance_free(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\ttu->timeri = snd_timer_instance_new(str);\n\tif (!tu->timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto __err;\n\t}\n\n\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\ttu->timeri->callback_data = (void *)tu;\n\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\n\terr = snd_timer_open(tu->timeri, &tselect.id, current->pid);\n\tif (err < 0) {\n\t\tsnd_timer_instance_free(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\n      __err:\n\treturn err;\n}\n\nstatic int snd_timer_user_info(struct file *file,\n\t\t\t       struct snd_timer_info __user *_info)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_info *info;\n\tstruct snd_timer *t;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tinfo->card = t->card ? t->card->number : -1;\n\tif (t->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\tinfo->flags |= SNDRV_TIMER_FLG_SLAVE;\n\tstrscpy(info->id, t->id, sizeof(info->id));\n\tstrscpy(info->name, t->name, sizeof(info->name));\n\tspin_lock_irq(&t->lock);\n\tinfo->resolution = snd_timer_hw_resolution(t);\n\tspin_unlock_irq(&t->lock);\n\tif (copy_to_user(_info, info, sizeof(*_info)))\n\t\terr = -EFAULT;\n\tkfree(info);\n\treturn err;\n}\n\nstatic int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {\n\t\tu64 resolution;\n\n\t\tif (params.ticks < 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\n\t\t \n\t\tresolution = snd_timer_resolution(tu->timeri);\n\t\tresolution *= params.ticks;\n\t\tif (resolution < 1000000) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto _end;\n\t\t}\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\terr = realloc_user_queue(tu, params.queue_size);\n\t\tif (err < 0)\n\t\t\tgoto _end;\n\t}\n\tspin_lock_irq(&tu->qlock);\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread64 tread;\n\t\t\tmemset(&tread, 0, sizeof(tread));\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp_sec = 0;\n\t\t\ttread.tstamp_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\tspin_unlock_irq(&tu->qlock);\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic int snd_timer_user_status32(struct file *file,\n\t\t\t\t   struct snd_timer_status32 __user *_status)\n {\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status32 status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp_sec = tu->tstamp.tv_sec;\n\tstatus.tstamp_nsec = tu->tstamp.tv_nsec;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_status64(struct file *file,\n\t\t\t\t   struct snd_timer_status64 __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status64 status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp_sec = tu->tstamp.tv_sec;\n\tstatus.tstamp_nsec = tu->tstamp.tv_nsec;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_timer_user_start(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tsnd_timer_stop(tu->timeri);\n\ttu->timeri->lost = 0;\n\ttu->last_resolution = 0;\n\terr = snd_timer_start(tu->timeri, tu->ticks);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_stop(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_stop(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\t \n\tif (!(tu->timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn snd_timer_user_start(file);\n\ttu->timeri->lost = 0;\n\terr = snd_timer_continue(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_pause(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\terr = snd_timer_pause(tu->timeri);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_timer_user_tread(void __user *argp, struct snd_timer_user *tu,\n\t\t\t\tunsigned int cmd, bool compat)\n{\n\tint __user *p = argp;\n\tint xarg, old_tread;\n\n\tif (tu->timeri)\t \n\t\treturn -EBUSY;\n\tif (get_user(xarg, p))\n\t\treturn -EFAULT;\n\n\told_tread = tu->tread;\n\n\tif (!xarg)\n\t\ttu->tread = TREAD_FORMAT_NONE;\n\telse if (cmd == SNDRV_TIMER_IOCTL_TREAD64 ||\n\t\t (IS_ENABLED(CONFIG_64BIT) && !compat))\n\t\ttu->tread = TREAD_FORMAT_TIME64;\n\telse\n\t\ttu->tread = TREAD_FORMAT_TIME32;\n\n\tif (tu->tread != old_tread &&\n\t    realloc_user_queue(tu, tu->queue_size) < 0) {\n\t\ttu->tread = old_tread;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nenum {\n\tSNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),\n\tSNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),\n\tSNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),\n\tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n};\n\nstatic long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg, bool compat)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD_OLD:\n\tcase SNDRV_TIMER_IOCTL_TREAD64:\n\t\treturn snd_timer_user_tread(argp, tu, cmd, compat);\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS32:\n\t\treturn snd_timer_user_status32(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS64:\n\t\treturn snd_timer_user_status64(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg, false);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}\n\nstatic int snd_timer_user_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\treturn snd_fasync_helper(fd, file, on, &tu->fasync);\n}\n\nstatic ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_tread64 *tread;\n\tstruct snd_timer_tread32 tread32;\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tswitch (tu->tread) {\n\tcase TREAD_FORMAT_TIME64:\n\t\tunit = sizeof(struct snd_timer_tread64);\n\t\tbreak;\n\tcase TREAD_FORMAT_TIME32:\n\t\tunit = sizeof(struct snd_timer_tread32);\n\t\tbreak;\n\tcase TREAD_FORMAT_NONE:\n\t\tunit = sizeof(struct snd_timer_read);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Corrupt snd_timer_user\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&tu->ioctl_lock);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tmutex_unlock(&tu->ioctl_lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&tu->ioctl_lock);\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\n\t\ttread = &tu->tqueue[qhead];\n\n\t\tswitch (tu->tread) {\n\t\tcase TREAD_FORMAT_TIME64:\n\t\t\tif (copy_to_user(buffer, tread,\n\t\t\t\t\t sizeof(struct snd_timer_tread64)))\n\t\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\tcase TREAD_FORMAT_TIME32:\n\t\t\tmemset(&tread32, 0, sizeof(tread32));\n\t\t\ttread32 = (struct snd_timer_tread32) {\n\t\t\t\t.event = tread->event,\n\t\t\t\t.tstamp_sec = tread->tstamp_sec,\n\t\t\t\t.tstamp_nsec = tread->tstamp_nsec,\n\t\t\t\t.val = tread->val,\n\t\t\t};\n\n\t\t\tif (copy_to_user(buffer, &tread32, sizeof(tread32)))\n\t\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\tcase TREAD_FORMAT_NONE:\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn result > 0 ? result : err;\n}\n\nstatic __poll_t snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        __poll_t mask;\n        struct snd_timer_user *tu;\n\n        tu = file->private_data;\n\n        poll_wait(file, &tu->qchange_sleep, wait);\n\n\tmask = 0;\n\tspin_lock_irq(&tu->qlock);\n\tif (tu->qused)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (tu->disconnected)\n\t\tmask |= EPOLLERR;\n\tspin_unlock_irq(&tu->qlock);\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"timer_compat.c\"\n#else\n#define snd_timer_user_ioctl_compat\tNULL\n#endif\n\nstatic const struct file_operations snd_timer_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_timer_user_read,\n\t.open =\t\tsnd_timer_user_open,\n\t.release =\tsnd_timer_user_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_timer_user_poll,\n\t.unlocked_ioctl =\tsnd_timer_user_ioctl,\n\t.compat_ioctl =\tsnd_timer_user_ioctl_compat,\n\t.fasync = \tsnd_timer_user_fasync,\n};\n\n \nstatic void snd_timer_free_all(void)\n{\n\tstruct snd_timer *timer, *n;\n\n\tlist_for_each_entry_safe(timer, n, &snd_timer_list, device_list)\n\t\tsnd_timer_free(timer);\n}\n\nstatic struct device *timer_dev;\n\n \n\nstatic int __init alsa_timer_init(void)\n{\n\tint err;\n\n\terr = snd_device_alloc(&timer_dev, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_name(timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tgoto put_timer;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tgoto put_timer;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n\nput_timer:\n\tput_device(timer_dev);\n\treturn err;\n}\n\nstatic void __exit alsa_timer_exit(void)\n{\n\tsnd_unregister_device(timer_dev);\n\tsnd_timer_free_all();\n\tput_device(timer_dev);\n\tsnd_timer_proc_done();\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);\n#endif\n}\n\nmodule_init(alsa_timer_init)\nmodule_exit(alsa_timer_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}