{
  "module_name": "rate.c",
  "hash_id": "a0ed90417336914410f0b06479f421ef707b391eb3d4c5a05045593b716fb3f7",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/rate.c",
  "human_readable_source": " \n  \n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"pcm_plugin.h\"\n\n#define SHIFT\t11\n#define BITS\t(1<<SHIFT)\n#define R_MASK\t(BITS-1)\n\n \n\nstruct rate_channel {\n\tsigned short last_S1;\n\tsigned short last_S2;\n};\n \ntypedef void (*rate_f)(struct snd_pcm_plugin *plugin,\n\t\t       const struct snd_pcm_plugin_channel *src_channels,\n\t\t       struct snd_pcm_plugin_channel *dst_channels,\n\t\t       int src_frames, int dst_frames);\n\nstruct rate_priv {\n\tunsigned int pitch;\n\tunsigned int pos;\n\trate_f func;\n\tsnd_pcm_sframes_t old_src_frames, old_dst_frames;\n\tstruct rate_channel channels[];\n};\n\nstatic void rate_init(struct snd_pcm_plugin *plugin)\n{\n\tunsigned int channel;\n\tstruct rate_priv *data = (struct rate_priv *)plugin->extra_data;\n\tdata->pos = 0;\n\tfor (channel = 0; channel < plugin->src_format.channels; channel++) {\n\t\tdata->channels[channel].last_S1 = 0;\n\t\tdata->channels[channel].last_S2 = 0;\n\t}\n}\n\nstatic void resample_expand(struct snd_pcm_plugin *plugin,\n\t\t\t    const struct snd_pcm_plugin_channel *src_channels,\n\t\t\t    struct snd_pcm_plugin_channel *dst_channels,\n\t\t\t    int src_frames, int dst_frames)\n{\n\tunsigned int pos = 0;\n\tsigned int val;\n\tsigned short S1, S2;\n\tsigned short *src, *dst;\n\tunsigned int channel;\n\tint src_step, dst_step;\n\tint src_frames1, dst_frames1;\n\tstruct rate_priv *data = (struct rate_priv *)plugin->extra_data;\n\tstruct rate_channel *rchannels = data->channels;\n\t\n\tfor (channel = 0; channel < plugin->src_format.channels; channel++) {\n\t\tpos = data->pos;\n\t\tS1 = rchannels->last_S1;\n\t\tS2 = rchannels->last_S2;\n\t\tif (!src_channels[channel].enabled) {\n\t\t\tif (dst_channels[channel].wanted)\n\t\t\t\tsnd_pcm_area_silence(&dst_channels[channel].area, 0, dst_frames, plugin->dst_format.format);\n\t\t\tdst_channels[channel].enabled = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdst_channels[channel].enabled = 1;\n\t\tsrc = (signed short *)src_channels[channel].area.addr +\n\t\t\tsrc_channels[channel].area.first / 8 / 2;\n\t\tdst = (signed short *)dst_channels[channel].area.addr +\n\t\t\tdst_channels[channel].area.first / 8 / 2;\n\t\tsrc_step = src_channels[channel].area.step / 8 / 2;\n\t\tdst_step = dst_channels[channel].area.step / 8 / 2;\n\t\tsrc_frames1 = src_frames;\n\t\tdst_frames1 = dst_frames;\n\t\twhile (dst_frames1-- > 0) {\n\t\t\tif (pos & ~R_MASK) {\n\t\t\t\tpos &= R_MASK;\n\t\t\t\tS1 = S2;\n\t\t\t\tif (src_frames1-- > 0) {\n\t\t\t\t\tS2 = *src;\n\t\t\t\t\tsrc += src_step;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = S1 + ((S2 - S1) * (signed int)pos) / BITS;\n\t\t\tif (val < -32768)\n\t\t\t\tval = -32768;\n\t\t\telse if (val > 32767)\n\t\t\t\tval = 32767;\n\t\t\t*dst = val;\n\t\t\tdst += dst_step;\n\t\t\tpos += data->pitch;\n\t\t}\n\t\trchannels->last_S1 = S1;\n\t\trchannels->last_S2 = S2;\n\t\trchannels++;\n\t}\n\tdata->pos = pos;\n}\n\nstatic void resample_shrink(struct snd_pcm_plugin *plugin,\n\t\t\t    const struct snd_pcm_plugin_channel *src_channels,\n\t\t\t    struct snd_pcm_plugin_channel *dst_channels,\n\t\t\t    int src_frames, int dst_frames)\n{\n\tunsigned int pos = 0;\n\tsigned int val;\n\tsigned short S1, S2;\n\tsigned short *src, *dst;\n\tunsigned int channel;\n\tint src_step, dst_step;\n\tint src_frames1, dst_frames1;\n\tstruct rate_priv *data = (struct rate_priv *)plugin->extra_data;\n\tstruct rate_channel *rchannels = data->channels;\n\n\tfor (channel = 0; channel < plugin->src_format.channels; ++channel) {\n\t\tpos = data->pos;\n\t\tS1 = rchannels->last_S1;\n\t\tS2 = rchannels->last_S2;\n\t\tif (!src_channels[channel].enabled) {\n\t\t\tif (dst_channels[channel].wanted)\n\t\t\t\tsnd_pcm_area_silence(&dst_channels[channel].area, 0, dst_frames, plugin->dst_format.format);\n\t\t\tdst_channels[channel].enabled = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdst_channels[channel].enabled = 1;\n\t\tsrc = (signed short *)src_channels[channel].area.addr +\n\t\t\tsrc_channels[channel].area.first / 8 / 2;\n\t\tdst = (signed short *)dst_channels[channel].area.addr +\n\t\t\tdst_channels[channel].area.first / 8 / 2;\n\t\tsrc_step = src_channels[channel].area.step / 8 / 2;\n\t\tdst_step = dst_channels[channel].area.step / 8 / 2;\n\t\tsrc_frames1 = src_frames;\n\t\tdst_frames1 = dst_frames;\n\t\twhile (dst_frames1 > 0) {\n\t\t\tS1 = S2;\n\t\t\tif (src_frames1-- > 0) {\n\t\t\t\tS2 = *src;\n\t\t\t\tsrc += src_step;\n\t\t\t}\n\t\t\tif (pos & ~R_MASK) {\n\t\t\t\tpos &= R_MASK;\n\t\t\t\tval = S1 + ((S2 - S1) * (signed int)pos) / BITS;\n\t\t\t\tif (val < -32768)\n\t\t\t\t\tval = -32768;\n\t\t\t\telse if (val > 32767)\n\t\t\t\t\tval = 32767;\n\t\t\t\t*dst = val;\n\t\t\t\tdst += dst_step;\n\t\t\t\tdst_frames1--;\n\t\t\t}\n\t\t\tpos += data->pitch;\n\t\t}\n\t\trchannels->last_S1 = S1;\n\t\trchannels->last_S2 = S2;\n\t\trchannels++;\n\t}\n\tdata->pos = pos;\n}\n\nstatic snd_pcm_sframes_t rate_src_frames(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)\n{\n\tstruct rate_priv *data;\n\tsnd_pcm_sframes_t res;\n\n\tif (snd_BUG_ON(!plugin))\n\t\treturn -ENXIO;\n\tif (frames == 0)\n\t\treturn 0;\n\tdata = (struct rate_priv *)plugin->extra_data;\n\tif (plugin->src_format.rate < plugin->dst_format.rate) {\n\t\tres = (((frames * data->pitch) + (BITS/2)) >> SHIFT);\n\t} else {\n\t\tres = DIV_ROUND_CLOSEST(frames << SHIFT, data->pitch);\n\t}\n\tif (data->old_src_frames > 0) {\n\t\tsnd_pcm_sframes_t frames1 = frames, res1 = data->old_dst_frames;\n\t\twhile (data->old_src_frames < frames1) {\n\t\t\tframes1 >>= 1;\n\t\t\tres1 <<= 1;\n\t\t}\n\t\twhile (data->old_src_frames > frames1) {\n\t\t\tframes1 <<= 1;\n\t\t\tres1 >>= 1;\n\t\t}\n\t\tif (data->old_src_frames == frames1)\n\t\t\treturn res1;\n\t}\n\tdata->old_src_frames = frames;\n\tdata->old_dst_frames = res;\n\treturn res;\n}\n\nstatic snd_pcm_sframes_t rate_dst_frames(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)\n{\n\tstruct rate_priv *data;\n\tsnd_pcm_sframes_t res;\n\n\tif (snd_BUG_ON(!plugin))\n\t\treturn -ENXIO;\n\tif (frames == 0)\n\t\treturn 0;\n\tdata = (struct rate_priv *)plugin->extra_data;\n\tif (plugin->src_format.rate < plugin->dst_format.rate) {\n\t\tres = DIV_ROUND_CLOSEST(frames << SHIFT, data->pitch);\n\t} else {\n\t\tres = (((frames * data->pitch) + (BITS/2)) >> SHIFT);\n\t}\n\tif (data->old_dst_frames > 0) {\n\t\tsnd_pcm_sframes_t frames1 = frames, res1 = data->old_src_frames;\n\t\twhile (data->old_dst_frames < frames1) {\n\t\t\tframes1 >>= 1;\n\t\t\tres1 <<= 1;\n\t\t}\n\t\twhile (data->old_dst_frames > frames1) {\n\t\t\tframes1 <<= 1;\n\t\t\tres1 >>= 1;\n\t\t}\n\t\tif (data->old_dst_frames == frames1)\n\t\t\treturn res1;\n\t}\n\tdata->old_dst_frames = frames;\n\tdata->old_src_frames = res;\n\treturn res;\n}\n\nstatic snd_pcm_sframes_t rate_transfer(struct snd_pcm_plugin *plugin,\n\t\t\t     const struct snd_pcm_plugin_channel *src_channels,\n\t\t\t     struct snd_pcm_plugin_channel *dst_channels,\n\t\t\t     snd_pcm_uframes_t frames)\n{\n\tsnd_pcm_uframes_t dst_frames;\n\tstruct rate_priv *data;\n\n\tif (snd_BUG_ON(!plugin || !src_channels || !dst_channels))\n\t\treturn -ENXIO;\n\tif (frames == 0)\n\t\treturn 0;\n#ifdef CONFIG_SND_DEBUG\n\t{\n\t\tunsigned int channel;\n\t\tfor (channel = 0; channel < plugin->src_format.channels; channel++) {\n\t\t\tif (snd_BUG_ON(src_channels[channel].area.first % 8 ||\n\t\t\t\t       src_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (snd_BUG_ON(dst_channels[channel].area.first % 8 ||\n\t\t\t\t       dst_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n#endif\n\n\tdst_frames = rate_dst_frames(plugin, frames);\n\tif (dst_frames > dst_channels[0].frames)\n\t\tdst_frames = dst_channels[0].frames;\n\tdata = (struct rate_priv *)plugin->extra_data;\n\tdata->func(plugin, src_channels, dst_channels, frames, dst_frames);\n\treturn dst_frames;\n}\n\nstatic int rate_action(struct snd_pcm_plugin *plugin,\n\t\t       enum snd_pcm_plugin_action action,\n\t\t       unsigned long udata)\n{\n\tif (snd_BUG_ON(!plugin))\n\t\treturn -ENXIO;\n\tswitch (action) {\n\tcase INIT:\n\tcase PREPARE:\n\t\trate_init(plugin);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\t \n}\n\nint snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,\n\t\t\t      struct snd_pcm_plugin_format *src_format,\n\t\t\t      struct snd_pcm_plugin_format *dst_format,\n\t\t\t      struct snd_pcm_plugin **r_plugin)\n{\n\tint err;\n\tstruct rate_priv *data;\n\tstruct snd_pcm_plugin *plugin;\n\n\tif (snd_BUG_ON(!r_plugin))\n\t\treturn -ENXIO;\n\t*r_plugin = NULL;\n\n\tif (snd_BUG_ON(src_format->channels != dst_format->channels))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(src_format->channels <= 0))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(src_format->format != SNDRV_PCM_FORMAT_S16))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(dst_format->format != SNDRV_PCM_FORMAT_S16))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(src_format->rate == dst_format->rate))\n\t\treturn -ENXIO;\n\n\terr = snd_pcm_plugin_build(plug, \"rate conversion\",\n\t\t\t\t   src_format, dst_format,\n\t\t\t\t   struct_size(data, channels,\n\t\t\t\t\t       src_format->channels),\n\t\t\t\t   &plugin);\n\tif (err < 0)\n\t\treturn err;\n\tdata = (struct rate_priv *)plugin->extra_data;\n\tif (src_format->rate < dst_format->rate) {\n\t\tdata->pitch = ((src_format->rate << SHIFT) + (dst_format->rate >> 1)) / dst_format->rate;\n\t\tdata->func = resample_expand;\n\t} else {\n\t\tdata->pitch = ((dst_format->rate << SHIFT) + (src_format->rate >> 1)) / src_format->rate;\n\t\tdata->func = resample_shrink;\n\t}\n\tdata->pos = 0;\n\trate_init(plugin);\n\tdata->old_src_frames = data->old_dst_frames = 0;\n\tplugin->transfer = rate_transfer;\n\tplugin->src_frames = rate_src_frames;\n\tplugin->dst_frames = rate_dst_frames;\n\tplugin->action = rate_action;\n\t*r_plugin = plugin;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}