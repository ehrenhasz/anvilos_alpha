{
  "module_name": "pcm_plugin.c",
  "hash_id": "f51e2d6c2af4b99cca5d46383cbaa0ea75de8c3acc78a47a04383aeb2e48f9bd",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/pcm_plugin.c",
  "human_readable_source": " \n  \n#if 0\n#define PLUGIN_DEBUG\n#endif\n\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"pcm_plugin.h\"\n\n#define snd_pcm_plug_first(plug) ((plug)->runtime->oss.plugin_first)\n#define snd_pcm_plug_last(plug) ((plug)->runtime->oss.plugin_last)\n\n \nstatic int rate_match(unsigned int src_rate, unsigned int dst_rate)\n{\n\tunsigned int low = (src_rate * 95) / 100;\n\tunsigned int high = (src_rate * 105) / 100;\n\treturn dst_rate >= low && dst_rate <= high;\n}\n\nstatic int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_plugin_format *format;\n\tssize_t width;\n\tsize_t size;\n\tunsigned int channel;\n\tstruct snd_pcm_plugin_channel *c;\n\n\tif (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tformat = &plugin->src_format;\n\t} else {\n\t\tformat = &plugin->dst_format;\n\t}\n\twidth = snd_pcm_format_physical_width(format->format);\n\tif (width < 0)\n\t\treturn width;\n\tsize = array3_size(frames, format->channels, width);\n\t \n\tif (size > 1024 * 1024)\n\t\treturn -ENOMEM;\n\tif (snd_BUG_ON(size % 8))\n\t\treturn -ENXIO;\n\tsize /= 8;\n\tif (plugin->buf_frames < frames) {\n\t\tkvfree(plugin->buf);\n\t\tplugin->buf = kvzalloc(size, GFP_KERNEL);\n\t\tplugin->buf_frames = frames;\n\t}\n\tif (!plugin->buf) {\n\t\tplugin->buf_frames = 0;\n\t\treturn -ENOMEM;\n\t}\n\tc = plugin->buf_channels;\n\tif (plugin->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) {\n\t\tfor (channel = 0; channel < format->channels; channel++, c++) {\n\t\t\tc->frames = frames;\n\t\t\tc->enabled = 1;\n\t\t\tc->wanted = 0;\n\t\t\tc->area.addr = plugin->buf;\n\t\t\tc->area.first = channel * width;\n\t\t\tc->area.step = format->channels * width;\n\t\t}\n\t} else if (plugin->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {\n\t\tif (snd_BUG_ON(size % format->channels))\n\t\t\treturn -EINVAL;\n\t\tsize /= format->channels;\n\t\tfor (channel = 0; channel < format->channels; channel++, c++) {\n\t\t\tc->frames = frames;\n\t\t\tc->enabled = 1;\n\t\t\tc->wanted = 0;\n\t\t\tc->area.addr = plugin->buf + (channel * size);\n\t\t\tc->area.first = 0;\n\t\t\tc->area.step = width;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)\n{\n\tint err;\n\tif (snd_BUG_ON(!snd_pcm_plug_first(plug)))\n\t\treturn -ENXIO;\n\tif (snd_pcm_plug_stream(plug) == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tstruct snd_pcm_plugin *plugin = snd_pcm_plug_first(plug);\n\t\twhile (plugin->next) {\n\t\t\tif (plugin->dst_frames)\n\t\t\t\tframes = plugin->dst_frames(plugin, frames);\n\t\t\tif ((snd_pcm_sframes_t)frames <= 0)\n\t\t\t\treturn -ENXIO;\n\t\t\tplugin = plugin->next;\n\t\t\terr = snd_pcm_plugin_alloc(plugin, frames);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tstruct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);\n\t\twhile (plugin->prev) {\n\t\t\tif (plugin->src_frames)\n\t\t\t\tframes = plugin->src_frames(plugin, frames);\n\t\t\tif ((snd_pcm_sframes_t)frames <= 0)\n\t\t\t\treturn -ENXIO;\n\t\t\tplugin = plugin->prev;\n\t\t\terr = snd_pcm_plugin_alloc(plugin, frames);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nsnd_pcm_sframes_t snd_pcm_plugin_client_channels(struct snd_pcm_plugin *plugin,\n\t\t\t\t       snd_pcm_uframes_t frames,\n\t\t\t\t       struct snd_pcm_plugin_channel **channels)\n{\n\t*channels = plugin->buf_channels;\n\treturn frames;\n}\n\nint snd_pcm_plugin_build(struct snd_pcm_substream *plug,\n\t\t\t const char *name,\n\t\t\t struct snd_pcm_plugin_format *src_format,\n\t\t\t struct snd_pcm_plugin_format *dst_format,\n\t\t\t size_t extra,\n\t\t\t struct snd_pcm_plugin **ret)\n{\n\tstruct snd_pcm_plugin *plugin;\n\tunsigned int channels;\n\t\n\tif (snd_BUG_ON(!plug))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!src_format || !dst_format))\n\t\treturn -ENXIO;\n\tplugin = kzalloc(sizeof(*plugin) + extra, GFP_KERNEL);\n\tif (plugin == NULL)\n\t\treturn -ENOMEM;\n\tplugin->name = name;\n\tplugin->plug = plug;\n\tplugin->stream = snd_pcm_plug_stream(plug);\n\tplugin->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;\n\tplugin->src_format = *src_format;\n\tplugin->src_width = snd_pcm_format_physical_width(src_format->format);\n\tsnd_BUG_ON(plugin->src_width <= 0);\n\tplugin->dst_format = *dst_format;\n\tplugin->dst_width = snd_pcm_format_physical_width(dst_format->format);\n\tsnd_BUG_ON(plugin->dst_width <= 0);\n\tif (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tchannels = src_format->channels;\n\telse\n\t\tchannels = dst_format->channels;\n\tplugin->buf_channels = kcalloc(channels, sizeof(*plugin->buf_channels), GFP_KERNEL);\n\tif (plugin->buf_channels == NULL) {\n\t\tsnd_pcm_plugin_free(plugin);\n\t\treturn -ENOMEM;\n\t}\n\tplugin->client_channels = snd_pcm_plugin_client_channels;\n\t*ret = plugin;\n\treturn 0;\n}\n\nint snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)\n{\n\tif (! plugin)\n\t\treturn 0;\n\tif (plugin->private_free)\n\t\tplugin->private_free(plugin);\n\tkfree(plugin->buf_channels);\n\tkvfree(plugin->buf);\n\tkfree(plugin);\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,\n\t\t\t\t\t snd_pcm_sframes_t frames,\n\t\t\t\t\t bool check_size)\n{\n\tstruct snd_pcm_plugin *plugin, *plugin_next;\n\n\tplugin = snd_pcm_plug_first(plug);\n\twhile (plugin && frames > 0) {\n\t\tplugin_next = plugin->next;\n\t\tif (check_size && plugin->buf_frames &&\n\t\t    frames > plugin->buf_frames)\n\t\t\tframes = plugin->buf_frames;\n\t\tif (plugin->dst_frames) {\n\t\t\tframes = plugin->dst_frames(plugin, frames);\n\t\t\tif (frames < 0)\n\t\t\t\treturn frames;\n\t\t}\n\t\tplugin = plugin_next;\n\t}\n\treturn frames;\n}\n\nstatic snd_pcm_sframes_t calc_src_frames(struct snd_pcm_substream *plug,\n\t\t\t\t\t snd_pcm_sframes_t frames,\n\t\t\t\t\t bool check_size)\n{\n\tstruct snd_pcm_plugin *plugin, *plugin_prev;\n\n\tplugin = snd_pcm_plug_last(plug);\n\twhile (plugin && frames > 0) {\n\t\tplugin_prev = plugin->prev;\n\t\tif (plugin->src_frames) {\n\t\t\tframes = plugin->src_frames(plugin, frames);\n\t\t\tif (frames < 0)\n\t\t\t\treturn frames;\n\t\t}\n\t\tif (check_size && plugin->buf_frames &&\n\t\t    frames > plugin->buf_frames)\n\t\t\tframes = plugin->buf_frames;\n\t\tplugin = plugin_prev;\n\t}\n\treturn frames;\n}\n\nsnd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t drv_frames)\n{\n\tif (snd_BUG_ON(!plug))\n\t\treturn -ENXIO;\n\tswitch (snd_pcm_plug_stream(plug)) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\treturn calc_src_frames(plug, drv_frames, false);\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\treturn calc_dst_frames(plug, drv_frames, false);\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n}\n\nsnd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t clt_frames)\n{\n\tif (snd_BUG_ON(!plug))\n\t\treturn -ENXIO;\n\tswitch (snd_pcm_plug_stream(plug)) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\treturn calc_dst_frames(plug, clt_frames, false);\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\treturn calc_src_frames(plug, clt_frames, false);\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int snd_pcm_plug_formats(const struct snd_mask *mask,\n\t\t\t\tsnd_pcm_format_t format)\n{\n\tstruct snd_mask formats = *mask;\n\tu64 linfmts = (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |\n\t\t       SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t       SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t       SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t       SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE |\n\t\t       SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t       SNDRV_PCM_FMTBIT_U24_3BE | SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t       SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);\n\tsnd_mask_set(&formats, (__force int)SNDRV_PCM_FORMAT_MU_LAW);\n\t\n\tif (formats.bits[0] & lower_32_bits(linfmts))\n\t\tformats.bits[0] |= lower_32_bits(linfmts);\n\tif (formats.bits[1] & upper_32_bits(linfmts))\n\t\tformats.bits[1] |= upper_32_bits(linfmts);\n\treturn snd_mask_test(&formats, (__force int)format);\n}\n\nstatic const snd_pcm_format_t preferred_formats[] = {\n\tSNDRV_PCM_FORMAT_S16_LE,\n\tSNDRV_PCM_FORMAT_S16_BE,\n\tSNDRV_PCM_FORMAT_U16_LE,\n\tSNDRV_PCM_FORMAT_U16_BE,\n\tSNDRV_PCM_FORMAT_S24_3LE,\n\tSNDRV_PCM_FORMAT_S24_3BE,\n\tSNDRV_PCM_FORMAT_U24_3LE,\n\tSNDRV_PCM_FORMAT_U24_3BE,\n\tSNDRV_PCM_FORMAT_S24_LE,\n\tSNDRV_PCM_FORMAT_S24_BE,\n\tSNDRV_PCM_FORMAT_U24_LE,\n\tSNDRV_PCM_FORMAT_U24_BE,\n\tSNDRV_PCM_FORMAT_S32_LE,\n\tSNDRV_PCM_FORMAT_S32_BE,\n\tSNDRV_PCM_FORMAT_U32_LE,\n\tSNDRV_PCM_FORMAT_U32_BE,\n\tSNDRV_PCM_FORMAT_S8,\n\tSNDRV_PCM_FORMAT_U8\n};\n\nsnd_pcm_format_t snd_pcm_plug_slave_format(snd_pcm_format_t format,\n\t\t\t\t\t   const struct snd_mask *format_mask)\n{\n\tint i;\n\n\tif (snd_mask_test(format_mask, (__force int)format))\n\t\treturn format;\n\tif (!snd_pcm_plug_formats(format_mask, format))\n\t\treturn (__force snd_pcm_format_t)-EINVAL;\n\tif (snd_pcm_format_linear(format)) {\n\t\tunsigned int width = snd_pcm_format_width(format);\n\t\tint unsignd = snd_pcm_format_unsigned(format) > 0;\n\t\tint big = snd_pcm_format_big_endian(format) > 0;\n\t\tunsigned int badness, best = -1;\n\t\tsnd_pcm_format_t best_format = (__force snd_pcm_format_t)-1;\n\t\tfor (i = 0; i < ARRAY_SIZE(preferred_formats); i++) {\n\t\t\tsnd_pcm_format_t f = preferred_formats[i];\n\t\t\tunsigned int w;\n\t\t\tif (!snd_mask_test(format_mask, (__force int)f))\n\t\t\t\tcontinue;\n\t\t\tw = snd_pcm_format_width(f);\n\t\t\tif (w >= width)\n\t\t\t\tbadness = w - width;\n\t\t\telse\n\t\t\t\tbadness = width - w + 32;\n\t\t\tbadness += snd_pcm_format_unsigned(f) != unsignd;\n\t\t\tbadness += snd_pcm_format_big_endian(f) != big;\n\t\t\tif (badness < best) {\n\t\t\t\tbest_format = f;\n\t\t\t\tbest = badness;\n\t\t\t}\n\t\t}\n\t\tif ((__force int)best_format >= 0)\n\t\t\treturn best_format;\n\t\telse\n\t\t\treturn (__force snd_pcm_format_t)-EINVAL;\n\t} else {\n\t\tswitch (format) {\n\t\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(preferred_formats); ++i) {\n\t\t\t\tsnd_pcm_format_t format1 = preferred_formats[i];\n\t\t\t\tif (snd_mask_test(format_mask, (__force int)format1))\n\t\t\t\t\treturn format1;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn (__force snd_pcm_format_t)-EINVAL;\n\t\t}\n\t}\n}\n\nint snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_params *slave_params)\n{\n\tstruct snd_pcm_plugin_format tmpformat;\n\tstruct snd_pcm_plugin_format dstformat;\n\tstruct snd_pcm_plugin_format srcformat;\n\tsnd_pcm_access_t src_access, dst_access;\n\tstruct snd_pcm_plugin *plugin = NULL;\n\tint err;\n\tint stream = snd_pcm_plug_stream(plug);\n\tint slave_interleaved = (params_channels(slave_params) == 1 ||\n\t\t\t\t params_access(slave_params) == SNDRV_PCM_ACCESS_RW_INTERLEAVED);\n\n\tswitch (stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tdstformat.format = params_format(slave_params);\n\t\tdstformat.rate = params_rate(slave_params);\n\t\tdstformat.channels = params_channels(slave_params);\n\t\tsrcformat.format = params_format(params);\n\t\tsrcformat.rate = params_rate(params);\n\t\tsrcformat.channels = params_channels(params);\n\t\tsrc_access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;\n\t\tdst_access = (slave_interleaved ? SNDRV_PCM_ACCESS_RW_INTERLEAVED :\n\t\t\t\t\t\t  SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tdstformat.format = params_format(params);\n\t\tdstformat.rate = params_rate(params);\n\t\tdstformat.channels = params_channels(params);\n\t\tsrcformat.format = params_format(slave_params);\n\t\tsrcformat.rate = params_rate(slave_params);\n\t\tsrcformat.channels = params_channels(slave_params);\n\t\tsrc_access = (slave_interleaved ? SNDRV_PCM_ACCESS_RW_INTERLEAVED :\n\t\t\t\t\t\t  SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);\n\t\tdst_access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\ttmpformat = srcformat;\n\t\t\n\tpdprintf(\"srcformat: format=%i, rate=%i, channels=%i\\n\", \n\t\t srcformat.format,\n\t\t srcformat.rate,\n\t\t srcformat.channels);\n\tpdprintf(\"dstformat: format=%i, rate=%i, channels=%i\\n\", \n\t\t dstformat.format,\n\t\t dstformat.rate,\n\t\t dstformat.channels);\n\n\t \n\tif (! rate_match(srcformat.rate, dstformat.rate) &&\n\t    ! snd_pcm_format_linear(srcformat.format)) {\n\t\tif (srcformat.format != SNDRV_PCM_FORMAT_MU_LAW)\n\t\t\treturn -EINVAL;\n\t\ttmpformat.format = SNDRV_PCM_FORMAT_S16;\n\t\terr = snd_pcm_plugin_build_mulaw(plug,\n\t\t\t\t\t\t &srcformat, &tmpformat,\n\t\t\t\t\t\t &plugin);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t\tsrcformat = tmpformat;\n\t\tsrc_access = dst_access;\n\t}\n\n\t \n\tif (srcformat.channels > dstformat.channels) {\n\t\ttmpformat.channels = dstformat.channels;\n\t\terr = snd_pcm_plugin_build_route(plug, &srcformat, &tmpformat, &plugin);\n\t\tpdprintf(\"channels reduction: src=%i, dst=%i returns %i\\n\", srcformat.channels, tmpformat.channels, err);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t\tsrcformat = tmpformat;\n\t\tsrc_access = dst_access;\n\t}\n\n\t \n\tif (!rate_match(srcformat.rate, dstformat.rate)) {\n\t\tif (srcformat.format != SNDRV_PCM_FORMAT_S16) {\n\t\t\t \n\t\t\ttmpformat.format = SNDRV_PCM_FORMAT_S16;\n\t\t\terr = snd_pcm_plugin_build_linear(plug,\n\t\t\t\t\t\t\t  &srcformat, &tmpformat,\n\t\t\t\t\t\t\t  &plugin);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = snd_pcm_plugin_append(plugin);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tsrcformat = tmpformat;\n\t\t\tsrc_access = dst_access;\n\t\t}\n\t\ttmpformat.rate = dstformat.rate;\n        \terr = snd_pcm_plugin_build_rate(plug,\n        \t\t\t\t\t&srcformat, &tmpformat,\n\t\t\t\t\t\t&plugin);\n\t\tpdprintf(\"rate down resampling: src=%i, dst=%i returns %i\\n\", srcformat.rate, tmpformat.rate, err);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t\tsrcformat = tmpformat;\n\t\tsrc_access = dst_access;\n        }\n\n\t \n\tif (srcformat.format != dstformat.format) {\n\t\ttmpformat.format = dstformat.format;\n\t\tif (srcformat.format == SNDRV_PCM_FORMAT_MU_LAW ||\n\t\t    tmpformat.format == SNDRV_PCM_FORMAT_MU_LAW) {\n\t\t\terr = snd_pcm_plugin_build_mulaw(plug,\n\t\t\t\t\t\t\t &srcformat, &tmpformat,\n\t\t\t\t\t\t\t &plugin);\n\t\t}\n\t\telse if (snd_pcm_format_linear(srcformat.format) &&\n\t\t\t snd_pcm_format_linear(tmpformat.format)) {\n\t\t\terr = snd_pcm_plugin_build_linear(plug,\n\t\t\t\t\t\t\t  &srcformat, &tmpformat,\n\t\t\t\t\t\t\t  &plugin);\n\t\t}\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tpdprintf(\"format change: src=%i, dst=%i returns %i\\n\", srcformat.format, tmpformat.format, err);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t\tsrcformat = tmpformat;\n\t\tsrc_access = dst_access;\n\t}\n\n\t \n\tif (srcformat.channels < dstformat.channels) {\n\t\ttmpformat.channels = dstformat.channels;\n\t\terr = snd_pcm_plugin_build_route(plug, &srcformat, &tmpformat, &plugin);\n\t\tpdprintf(\"channels extension: src=%i, dst=%i returns %i\\n\", srcformat.channels, tmpformat.channels, err);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t\tsrcformat = tmpformat;\n\t\tsrc_access = dst_access;\n\t}\n\n\t \n\tif (src_access != dst_access) {\n\t\terr = snd_pcm_plugin_build_copy(plug,\n\t\t\t\t\t\t&srcformat,\n\t\t\t\t\t\t&tmpformat,\n\t\t\t\t\t\t&plugin);\n\t\tpdprintf(\"interleave change (copy: returns %i)\\n\", err);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_plugin_append(plugin);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_plugin_free(plugin);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nsnd_pcm_sframes_t snd_pcm_plug_client_channels_buf(struct snd_pcm_substream *plug,\n\t\t\t\t\t char *buf,\n\t\t\t\t\t snd_pcm_uframes_t count,\n\t\t\t\t\t struct snd_pcm_plugin_channel **channels)\n{\n\tstruct snd_pcm_plugin *plugin;\n\tstruct snd_pcm_plugin_channel *v;\n\tstruct snd_pcm_plugin_format *format;\n\tint width, nchannels, channel;\n\tint stream = snd_pcm_plug_stream(plug);\n\n\tif (snd_BUG_ON(!buf))\n\t\treturn -ENXIO;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tplugin = snd_pcm_plug_first(plug);\n\t\tformat = &plugin->src_format;\n\t} else {\n\t\tplugin = snd_pcm_plug_last(plug);\n\t\tformat = &plugin->dst_format;\n\t}\n\tv = plugin->buf_channels;\n\t*channels = v;\n\twidth = snd_pcm_format_physical_width(format->format);\n\tif (width < 0)\n\t\treturn width;\n\tnchannels = format->channels;\n\tif (snd_BUG_ON(plugin->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&\n\t\t       format->channels > 1))\n\t\treturn -ENXIO;\n\tfor (channel = 0; channel < nchannels; channel++, v++) {\n\t\tv->frames = count;\n\t\tv->enabled = 1;\n\t\tv->wanted = (stream == SNDRV_PCM_STREAM_CAPTURE);\n\t\tv->area.addr = buf;\n\t\tv->area.first = channel * width;\n\t\tv->area.step = nchannels * width;\n\t}\n\treturn count;\n}\n\nsnd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *src_channels, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_plugin *plugin, *next;\n\tstruct snd_pcm_plugin_channel *dst_channels;\n\tint err;\n\tsnd_pcm_sframes_t frames = size;\n\n\tplugin = snd_pcm_plug_first(plug);\n\twhile (plugin) {\n\t\tif (frames <= 0)\n\t\t\treturn frames;\n\t\tnext = plugin->next;\n\t\tif (next) {\n\t\t\tsnd_pcm_sframes_t frames1 = frames;\n\t\t\tif (plugin->dst_frames) {\n\t\t\t\tframes1 = plugin->dst_frames(plugin, frames);\n\t\t\t\tif (frames1 <= 0)\n\t\t\t\t\treturn frames1;\n\t\t\t}\n\t\t\terr = next->client_channels(next, frames1, &dst_channels);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err != frames1) {\n\t\t\t\tframes = err;\n\t\t\t\tif (plugin->src_frames) {\n\t\t\t\t\tframes = plugin->src_frames(plugin, frames1);\n\t\t\t\t\tif (frames <= 0)\n\t\t\t\t\t\treturn frames;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tdst_channels = NULL;\n\t\tpdprintf(\"write plugin: %s, %li\\n\", plugin->name, frames);\n\t\tframes = plugin->transfer(plugin, src_channels, dst_channels, frames);\n\t\tif (frames < 0)\n\t\t\treturn frames;\n\t\tsrc_channels = dst_channels;\n\t\tplugin = next;\n\t}\n\treturn calc_src_frames(plug, frames, true);\n}\n\nsnd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *dst_channels_final, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_plugin *plugin, *next;\n\tstruct snd_pcm_plugin_channel *src_channels, *dst_channels;\n\tsnd_pcm_sframes_t frames = size;\n\tint err;\n\n\tframes = calc_src_frames(plug, frames, true);\n\tif (frames < 0)\n\t\treturn frames;\n\n\tsrc_channels = NULL;\n\tplugin = snd_pcm_plug_first(plug);\n\twhile (plugin && frames > 0) {\n\t\tnext = plugin->next;\n\t\tif (next) {\n\t\t\terr = plugin->client_channels(plugin, frames, &dst_channels);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tframes = err;\n\t\t} else {\n\t\t\tdst_channels = dst_channels_final;\n\t\t}\n\t\tpdprintf(\"read plugin: %s, %li\\n\", plugin->name, frames);\n\t\tframes = plugin->transfer(plugin, src_channels, dst_channels, frames);\n\t\tif (frames < 0)\n\t\t\treturn frames;\n\t\tplugin = next;\n\t\tsrc_channels = dst_channels;\n\t}\n\treturn frames;\n}\n\nint snd_pcm_area_silence(const struct snd_pcm_channel_area *dst_area, size_t dst_offset,\n\t\t\t size_t samples, snd_pcm_format_t format)\n{\n\t \n\tunsigned char *dst;\n\tunsigned int dst_step;\n\tint width;\n\tconst unsigned char *silence;\n\tif (!dst_area->addr)\n\t\treturn 0;\n\tdst = dst_area->addr + (dst_area->first + dst_area->step * dst_offset) / 8;\n\twidth = snd_pcm_format_physical_width(format);\n\tif (width <= 0)\n\t\treturn -EINVAL;\n\tif (dst_area->step == (unsigned int) width && width >= 8)\n\t\treturn snd_pcm_format_set_silence(format, dst, samples);\n\tsilence = snd_pcm_format_silence_64(format);\n\tif (! silence)\n\t\treturn -EINVAL;\n\tdst_step = dst_area->step / 8;\n\tif (width == 4) {\n\t\t \n\t\tint dstbit = dst_area->first % 8;\n\t\tint dstbit_step = dst_area->step % 8;\n\t\twhile (samples-- > 0) {\n\t\t\tif (dstbit)\n\t\t\t\t*dst &= 0xf0;\n\t\t\telse\n\t\t\t\t*dst &= 0x0f;\n\t\t\tdst += dst_step;\n\t\t\tdstbit += dstbit_step;\n\t\t\tif (dstbit == 8) {\n\t\t\t\tdst++;\n\t\t\t\tdstbit = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twidth /= 8;\n\t\twhile (samples-- > 0) {\n\t\t\tmemcpy(dst, silence, width);\n\t\t\tdst += dst_step;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint snd_pcm_area_copy(const struct snd_pcm_channel_area *src_area, size_t src_offset,\n\t\t      const struct snd_pcm_channel_area *dst_area, size_t dst_offset,\n\t\t      size_t samples, snd_pcm_format_t format)\n{\n\t \n\tchar *src, *dst;\n\tint width;\n\tint src_step, dst_step;\n\tsrc = src_area->addr + (src_area->first + src_area->step * src_offset) / 8;\n\tif (!src_area->addr)\n\t\treturn snd_pcm_area_silence(dst_area, dst_offset, samples, format);\n\tdst = dst_area->addr + (dst_area->first + dst_area->step * dst_offset) / 8;\n\tif (!dst_area->addr)\n\t\treturn 0;\n\twidth = snd_pcm_format_physical_width(format);\n\tif (width <= 0)\n\t\treturn -EINVAL;\n\tif (src_area->step == (unsigned int) width &&\n\t    dst_area->step == (unsigned int) width && width >= 8) {\n\t\tsize_t bytes = samples * width / 8;\n\t\tmemcpy(dst, src, bytes);\n\t\treturn 0;\n\t}\n\tsrc_step = src_area->step / 8;\n\tdst_step = dst_area->step / 8;\n\tif (width == 4) {\n\t\t \n\t\tint srcbit = src_area->first % 8;\n\t\tint srcbit_step = src_area->step % 8;\n\t\tint dstbit = dst_area->first % 8;\n\t\tint dstbit_step = dst_area->step % 8;\n\t\twhile (samples-- > 0) {\n\t\t\tunsigned char srcval;\n\t\t\tif (srcbit)\n\t\t\t\tsrcval = *src & 0x0f;\n\t\t\telse\n\t\t\t\tsrcval = (*src & 0xf0) >> 4;\n\t\t\tif (dstbit)\n\t\t\t\t*dst = (*dst & 0xf0) | srcval;\n\t\t\telse\n\t\t\t\t*dst = (*dst & 0x0f) | (srcval << 4);\n\t\t\tsrc += src_step;\n\t\t\tsrcbit += srcbit_step;\n\t\t\tif (srcbit == 8) {\n\t\t\t\tsrc++;\n\t\t\t\tsrcbit = 0;\n\t\t\t}\n\t\t\tdst += dst_step;\n\t\t\tdstbit += dstbit_step;\n\t\t\tif (dstbit == 8) {\n\t\t\t\tdst++;\n\t\t\t\tdstbit = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twidth /= 8;\n\t\twhile (samples-- > 0) {\n\t\t\tmemcpy(dst, src, width);\n\t\t\tsrc += src_step;\n\t\t\tdst += dst_step;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}