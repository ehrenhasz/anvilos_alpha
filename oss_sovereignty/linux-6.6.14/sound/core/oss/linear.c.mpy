{
  "module_name": "linear.c",
  "hash_id": "5257308242b9271d6b63a298af513477dae500c0a3fa8c59d069a0ba31a2b115",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/linear.c",
  "human_readable_source": " \n\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"pcm_plugin.h\"\n\n \n \nstruct linear_priv {\n\tint cvt_endian;\t\t \n\tunsigned int src_ofs;\t \n\tunsigned int dst_ofs;\t \n\tunsigned int copy_ofs;\t \n\tunsigned int dst_bytes;\t\t \n\tunsigned int copy_bytes;\t \n\tunsigned int flip;  \n};\n\nstatic inline void do_convert(struct linear_priv *data,\n\t\t\t      unsigned char *dst, unsigned char *src)\n{\n\tunsigned int tmp = 0;\n\tunsigned char *p = (unsigned char *)&tmp;\n\n\tmemcpy(p + data->copy_ofs, src + data->src_ofs, data->copy_bytes);\n\tif (data->cvt_endian)\n\t\ttmp = swab32(tmp);\n\ttmp ^= data->flip;\n\tmemcpy(dst, p + data->dst_ofs, data->dst_bytes);\n}\n\nstatic void convert(struct snd_pcm_plugin *plugin,\n\t\t    const struct snd_pcm_plugin_channel *src_channels,\n\t\t    struct snd_pcm_plugin_channel *dst_channels,\n\t\t    snd_pcm_uframes_t frames)\n{\n\tstruct linear_priv *data = (struct linear_priv *)plugin->extra_data;\n\tint channel;\n\tint nchannels = plugin->src_format.channels;\n\tfor (channel = 0; channel < nchannels; ++channel) {\n\t\tchar *src;\n\t\tchar *dst;\n\t\tint src_step, dst_step;\n\t\tsnd_pcm_uframes_t frames1;\n\t\tif (!src_channels[channel].enabled) {\n\t\t\tif (dst_channels[channel].wanted)\n\t\t\t\tsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\n\t\t\tdst_channels[channel].enabled = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdst_channels[channel].enabled = 1;\n\t\tsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\n\t\tdst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\n\t\tsrc_step = src_channels[channel].area.step / 8;\n\t\tdst_step = dst_channels[channel].area.step / 8;\n\t\tframes1 = frames;\n\t\twhile (frames1-- > 0) {\n\t\t\tdo_convert(data, dst, src);\n\t\t\tsrc += src_step;\n\t\t\tdst += dst_step;\n\t\t}\n\t}\n}\n\nstatic snd_pcm_sframes_t linear_transfer(struct snd_pcm_plugin *plugin,\n\t\t\t       const struct snd_pcm_plugin_channel *src_channels,\n\t\t\t       struct snd_pcm_plugin_channel *dst_channels,\n\t\t\t       snd_pcm_uframes_t frames)\n{\n\tif (snd_BUG_ON(!plugin || !src_channels || !dst_channels))\n\t\treturn -ENXIO;\n\tif (frames == 0)\n\t\treturn 0;\n#ifdef CONFIG_SND_DEBUG\n\t{\n\t\tunsigned int channel;\n\t\tfor (channel = 0; channel < plugin->src_format.channels; channel++) {\n\t\t\tif (snd_BUG_ON(src_channels[channel].area.first % 8 ||\n\t\t\t\t       src_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (snd_BUG_ON(dst_channels[channel].area.first % 8 ||\n\t\t\t\t       dst_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n#endif\n\tif (frames > dst_channels[0].frames)\n\t\tframes = dst_channels[0].frames;\n\tconvert(plugin, src_channels, dst_channels, frames);\n\treturn frames;\n}\n\nstatic void init_data(struct linear_priv *data,\n\t\t      snd_pcm_format_t src_format, snd_pcm_format_t dst_format)\n{\n\tint src_le, dst_le, src_bytes, dst_bytes;\n\n\tsrc_bytes = snd_pcm_format_width(src_format) / 8;\n\tdst_bytes = snd_pcm_format_width(dst_format) / 8;\n\tsrc_le = snd_pcm_format_little_endian(src_format) > 0;\n\tdst_le = snd_pcm_format_little_endian(dst_format) > 0;\n\n\tdata->dst_bytes = dst_bytes;\n\tdata->cvt_endian = src_le != dst_le;\n\tdata->copy_bytes = src_bytes < dst_bytes ? src_bytes : dst_bytes;\n\tif (src_le) {\n\t\tdata->copy_ofs = 4 - data->copy_bytes;\n\t\tdata->src_ofs = src_bytes - data->copy_bytes;\n\t} else\n\t\tdata->src_ofs = snd_pcm_format_physical_width(src_format) / 8 -\n\t\t\tsrc_bytes;\n\tif (dst_le)\n\t\tdata->dst_ofs = 4 - data->dst_bytes;\n\telse\n\t\tdata->dst_ofs = snd_pcm_format_physical_width(dst_format) / 8 -\n\t\t\tdst_bytes;\n\tif (snd_pcm_format_signed(src_format) !=\n\t    snd_pcm_format_signed(dst_format)) {\n\t\tif (dst_le)\n\t\t\tdata->flip = (__force u32)cpu_to_le32(0x80000000);\n\t\telse\n\t\t\tdata->flip = (__force u32)cpu_to_be32(0x80000000);\n\t}\n}\n\nint snd_pcm_plugin_build_linear(struct snd_pcm_substream *plug,\n\t\t\t\tstruct snd_pcm_plugin_format *src_format,\n\t\t\t\tstruct snd_pcm_plugin_format *dst_format,\n\t\t\t\tstruct snd_pcm_plugin **r_plugin)\n{\n\tint err;\n\tstruct linear_priv *data;\n\tstruct snd_pcm_plugin *plugin;\n\n\tif (snd_BUG_ON(!r_plugin))\n\t\treturn -ENXIO;\n\t*r_plugin = NULL;\n\n\tif (snd_BUG_ON(src_format->rate != dst_format->rate))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(src_format->channels != dst_format->channels))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!snd_pcm_format_linear(src_format->format) ||\n\t\t       !snd_pcm_format_linear(dst_format->format)))\n\t\treturn -ENXIO;\n\n\terr = snd_pcm_plugin_build(plug, \"linear format conversion\",\n\t\t\t\t   src_format, dst_format,\n\t\t\t\t   sizeof(struct linear_priv), &plugin);\n\tif (err < 0)\n\t\treturn err;\n\tdata = (struct linear_priv *)plugin->extra_data;\n\tinit_data(data, src_format->format, dst_format->format);\n\tplugin->transfer = linear_transfer;\n\t*r_plugin = plugin;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}