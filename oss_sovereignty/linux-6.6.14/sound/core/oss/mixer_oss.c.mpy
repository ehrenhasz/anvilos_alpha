{
  "module_name": "mixer_oss.c",
  "hash_id": "705be2104e3e75f8d78fbcbae54546336a0cce89fb8046c3fd198acaf4d81769",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/mixer_oss.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/mixer_oss.h>\n#include <linux/soundcard.h>\n\n#define OSS_ALSAEMULVER         _SIOR ('M', 249, int)\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Mixer OSS emulation for ALSA.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MIXER);\n\nstatic int snd_mixer_oss_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_card *card;\n\tstruct snd_mixer_oss_file *fmixer;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_oss_minor_data(iminor(inode),\n\t\t\t\t\t SNDRV_OSS_DEVICE_TYPE_MIXER);\n\tif (card == NULL)\n\t\treturn -ENODEV;\n\tif (card->mixer_oss == NULL) {\n\t\tsnd_card_unref(card);\n\t\treturn -ENODEV;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\tsnd_card_unref(card);\n\t\treturn err;\n\t}\n\tfmixer = kzalloc(sizeof(*fmixer), GFP_KERNEL);\n\tif (fmixer == NULL) {\n\t\tsnd_card_file_remove(card, file);\n\t\tsnd_card_unref(card);\n\t\treturn -ENOMEM;\n\t}\n\tfmixer->card = card;\n\tfmixer->mixer = card->mixer_oss;\n\tfile->private_data = fmixer;\n\tif (!try_module_get(card->module)) {\n\t\tkfree(fmixer);\n\t\tsnd_card_file_remove(card, file);\n\t\tsnd_card_unref(card);\n\t\treturn -EFAULT;\n\t}\n\tsnd_card_unref(card);\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_mixer_oss_file *fmixer;\n\n\tif (file->private_data) {\n\t\tfmixer = file->private_data;\n\t\tmodule_put(fmixer->card->module);\n\t\tsnd_card_file_remove(fmixer->card, file);\n\t\tkfree(fmixer);\n\t}\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_info(struct snd_mixer_oss_file *fmixer,\n\t\t\t      mixer_info __user *_info)\n{\n\tstruct snd_card *card = fmixer->card;\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct mixer_info info;\n\t\n\tmemset(&info, 0, sizeof(info));\n\tstrscpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));\n\tstrscpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));\n\tinfo.modify_counter = card->mixer_oss_change_count;\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_info_obsolete(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t       _old_mixer_info __user *_info)\n{\n\tstruct snd_card *card = fmixer->card;\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\t_old_mixer_info info;\n\t\n\tmemset(&info, 0, sizeof(info));\n\tstrscpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));\n\tstrscpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_caps(struct snd_mixer_oss_file *fmixer)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tint result = 0;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tif (mixer->get_recsrc && mixer->put_recsrc)\n\t\tresult |= SOUND_CAP_EXCL_INPUT;\n\treturn result;\n}\n\nstatic int snd_mixer_oss_devmask(struct snd_mixer_oss_file *fmixer)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_mixer_oss_slot *pslot;\n\tint result = 0, chn;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tfor (chn = 0; chn < 31; chn++) {\n\t\tpslot = &mixer->slots[chn];\n\t\tif (pslot->put_volume || pslot->put_recsrc)\n\t\t\tresult |= 1 << chn;\n\t}\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_stereodevs(struct snd_mixer_oss_file *fmixer)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_mixer_oss_slot *pslot;\n\tint result = 0, chn;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tfor (chn = 0; chn < 31; chn++) {\n\t\tpslot = &mixer->slots[chn];\n\t\tif (pslot->put_volume && pslot->stereo)\n\t\t\tresult |= 1 << chn;\n\t}\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_recmask(struct snd_mixer_oss_file *fmixer)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tint result = 0;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tif (mixer->put_recsrc && mixer->get_recsrc) {\t \n\t\tresult = mixer->mask_recsrc;\n\t} else {\n\t\tstruct snd_mixer_oss_slot *pslot;\n\t\tint chn;\n\t\tfor (chn = 0; chn < 31; chn++) {\n\t\t\tpslot = &mixer->slots[chn];\n\t\t\tif (pslot->put_recsrc)\n\t\t\t\tresult |= 1 << chn;\n\t\t}\n\t}\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_get_recsrc(struct snd_mixer_oss_file *fmixer)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tint result = 0;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tif (mixer->put_recsrc && mixer->get_recsrc) {\t \n\t\tunsigned int index;\n\t\tresult = mixer->get_recsrc(fmixer, &index);\n\t\tif (result < 0)\n\t\t\tgoto unlock;\n\t\tresult = 1 << index;\n\t} else {\n\t\tstruct snd_mixer_oss_slot *pslot;\n\t\tint chn;\n\t\tfor (chn = 0; chn < 31; chn++) {\n\t\t\tpslot = &mixer->slots[chn];\n\t\t\tif (pslot->get_recsrc) {\n\t\t\t\tint active = 0;\n\t\t\t\tpslot->get_recsrc(fmixer, pslot, &active);\n\t\t\t\tif (active)\n\t\t\t\t\tresult |= 1 << chn;\n\t\t\t}\n\t\t}\n\t}\n\tmixer->oss_recsrc = result;\n unlock:\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_set_recsrc(struct snd_mixer_oss_file *fmixer, int recsrc)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_mixer_oss_slot *pslot;\n\tint chn, active;\n\tunsigned int index;\n\tint result = 0;\n\n\tif (mixer == NULL)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tif (mixer->get_recsrc && mixer->put_recsrc) {\t \n\t\tif (recsrc & ~mixer->oss_recsrc)\n\t\t\trecsrc &= ~mixer->oss_recsrc;\n\t\tmixer->put_recsrc(fmixer, ffz(~recsrc));\n\t\tmixer->get_recsrc(fmixer, &index);\n\t\tresult = 1 << index;\n\t}\n\tfor (chn = 0; chn < 31; chn++) {\n\t\tpslot = &mixer->slots[chn];\n\t\tif (pslot->put_recsrc) {\n\t\t\tactive = (recsrc & (1 << chn)) ? 1 : 0;\n\t\t\tpslot->put_recsrc(fmixer, pslot, active);\n\t\t}\n\t}\n\tif (! result) {\n\t\tfor (chn = 0; chn < 31; chn++) {\n\t\t\tpslot = &mixer->slots[chn];\n\t\t\tif (pslot->get_recsrc) {\n\t\t\t\tactive = 0;\n\t\t\t\tpslot->get_recsrc(fmixer, pslot, &active);\n\t\t\t\tif (active)\n\t\t\t\t\tresult |= 1 << chn;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_get_volume(struct snd_mixer_oss_file *fmixer, int slot)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_mixer_oss_slot *pslot;\n\tint result = 0, left, right;\n\n\tif (mixer == NULL || slot > 30)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tpslot = &mixer->slots[slot];\n\tleft = pslot->volume[0];\n\tright = pslot->volume[1];\n\tif (pslot->get_volume)\n\t\tresult = pslot->get_volume(fmixer, pslot, &left, &right);\n\tif (!pslot->stereo)\n\t\tright = left;\n\tif (snd_BUG_ON(left < 0 || left > 100)) {\n\t\tresult = -EIO;\n\t\tgoto unlock;\n\t}\n\tif (snd_BUG_ON(right < 0 || right > 100)) {\n\t\tresult = -EIO;\n\t\tgoto unlock;\n\t}\n\tif (result >= 0) {\n\t\tpslot->volume[0] = left;\n\t\tpslot->volume[1] = right;\n\t \tresult = (left & 0xff) | ((right & 0xff) << 8);\n\t}\n unlock:\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_set_volume(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t    int slot, int volume)\n{\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_mixer_oss_slot *pslot;\n\tint result = 0, left = volume & 0xff, right = (volume >> 8) & 0xff;\n\n\tif (mixer == NULL || slot > 30)\n\t\treturn -EIO;\n\tmutex_lock(&mixer->reg_mutex);\n\tpslot = &mixer->slots[slot];\n\tif (left > 100)\n\t\tleft = 100;\n\tif (right > 100)\n\t\tright = 100;\n\tif (!pslot->stereo)\n\t\tright = left;\n\tif (pslot->put_volume)\n\t\tresult = pslot->put_volume(fmixer, pslot, left, right);\n\tif (result < 0)\n\t\tgoto unlock;\n\tpslot->volume[0] = left;\n\tpslot->volume[1] = right;\n\tresult = (left & 0xff) | ((right & 0xff) << 8);\n unlock:\n\tmutex_unlock(&mixer->reg_mutex);\n\treturn result;\n}\n\nstatic int snd_mixer_oss_ioctl1(struct snd_mixer_oss_file *fmixer, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint tmp;\n\n\tif (snd_BUG_ON(!fmixer))\n\t\treturn -ENXIO;\n\tif (((cmd >> 8) & 0xff) == 'M') {\n\t\tswitch (cmd) {\n\t\tcase SOUND_MIXER_INFO:\n\t\t\treturn snd_mixer_oss_info(fmixer, argp);\n\t\tcase SOUND_OLD_MIXER_INFO:\n \t\t\treturn snd_mixer_oss_info_obsolete(fmixer, argp);\n\t\tcase SOUND_MIXER_WRITE_RECSRC:\n\t\t\tif (get_user(tmp, p))\n\t\t\t\treturn -EFAULT;\n\t\t\ttmp = snd_mixer_oss_set_recsrc(fmixer, tmp);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\tcase OSS_GETVERSION:\n\t\t\treturn put_user(SNDRV_OSS_VERSION, p);\n\t\tcase OSS_ALSAEMULVER:\n\t\t\treturn put_user(1, p);\n\t\tcase SOUND_MIXER_READ_DEVMASK:\n\t\t\ttmp = snd_mixer_oss_devmask(fmixer);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\tcase SOUND_MIXER_READ_STEREODEVS:\n\t\t\ttmp = snd_mixer_oss_stereodevs(fmixer);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\tcase SOUND_MIXER_READ_RECMASK:\n\t\t\ttmp = snd_mixer_oss_recmask(fmixer);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\tcase SOUND_MIXER_READ_CAPS:\n\t\t\ttmp = snd_mixer_oss_caps(fmixer);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\tcase SOUND_MIXER_READ_RECSRC:\n\t\t\ttmp = snd_mixer_oss_get_recsrc(fmixer);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn tmp;\n\t\t\treturn put_user(tmp, p);\n\t\t}\n\t}\n\tif (cmd & SIOC_IN) {\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n\t\ttmp = snd_mixer_oss_set_volume(fmixer, cmd & 0xff, tmp);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\treturn put_user(tmp, p);\n\t} else if (cmd & SIOC_OUT) {\n\t\ttmp = snd_mixer_oss_get_volume(fmixer, cmd & 0xff);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\treturn put_user(tmp, p);\n\t}\n\treturn -ENXIO;\n}\n\nstatic long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn snd_mixer_oss_ioctl1(file->private_data, cmd, arg);\n}\n\nint snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_mixer_oss_file fmixer;\n\t\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tif (card->mixer_oss == NULL)\n\t\treturn -ENXIO;\n\tmemset(&fmixer, 0, sizeof(fmixer));\n\tfmixer.card = card;\n\tfmixer.mixer = card->mixer_oss;\n\treturn snd_mixer_oss_ioctl1(&fmixer, cmd, arg);\n}\nEXPORT_SYMBOL(snd_mixer_oss_ioctl_card);\n\n#ifdef CONFIG_COMPAT\n \nstatic long snd_mixer_oss_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t       unsigned long arg)\n{\n\treturn snd_mixer_oss_ioctl1(file->private_data, cmd,\n\t\t\t\t    (unsigned long)compat_ptr(arg));\n}\n#else\n#define snd_mixer_oss_ioctl_compat\tNULL\n#endif\n\n \n\nstatic const struct file_operations snd_mixer_oss_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tsnd_mixer_oss_open,\n\t.release =\tsnd_mixer_oss_release,\n\t.llseek =\tno_llseek,\n\t.unlocked_ioctl =\tsnd_mixer_oss_ioctl,\n\t.compat_ioctl =\tsnd_mixer_oss_ioctl_compat,\n};\n\n \n\nstatic long snd_mixer_oss_conv(long val, long omin, long omax, long nmin, long nmax)\n{\n\tlong orange = omax - omin, nrange = nmax - nmin;\n\t\n\tif (orange == 0)\n\t\treturn 0;\n\treturn DIV_ROUND_CLOSEST(nrange * (val - omin), orange) + nmin;\n}\n\n \nstatic long snd_mixer_oss_conv1(long val, long min, long max, int *old)\n{\n\tif (val == snd_mixer_oss_conv(*old, 0, 100, min, max))\n\t\treturn *old;\n\treturn snd_mixer_oss_conv(val, min, max, 0, 100);\n}\n\n \nstatic long snd_mixer_oss_conv2(long val, long min, long max)\n{\n\treturn snd_mixer_oss_conv(val, 0, 100, min, max);\n}\n\n#if 0\nstatic void snd_mixer_oss_recsrce_set(struct snd_card *card, int slot)\n{\n\tstruct snd_mixer_oss *mixer = card->mixer_oss;\n\tif (mixer)\n\t\tmixer->mask_recsrc |= 1 << slot;\n}\n\nstatic int snd_mixer_oss_recsrce_get(struct snd_card *card, int slot)\n{\n\tstruct snd_mixer_oss *mixer = card->mixer_oss;\n\tif (mixer && (mixer->mask_recsrc & (1 << slot)))\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\n#define SNDRV_MIXER_OSS_SIGNATURE\t\t0x65999250\n\n#define SNDRV_MIXER_OSS_ITEM_GLOBAL\t0\n#define SNDRV_MIXER_OSS_ITEM_GSWITCH\t1\n#define SNDRV_MIXER_OSS_ITEM_GROUTE\t2\n#define SNDRV_MIXER_OSS_ITEM_GVOLUME\t3\n#define SNDRV_MIXER_OSS_ITEM_PSWITCH\t4\n#define SNDRV_MIXER_OSS_ITEM_PROUTE\t5\n#define SNDRV_MIXER_OSS_ITEM_PVOLUME\t6\n#define SNDRV_MIXER_OSS_ITEM_CSWITCH\t7\n#define SNDRV_MIXER_OSS_ITEM_CROUTE\t8\n#define SNDRV_MIXER_OSS_ITEM_CVOLUME\t9\n#define SNDRV_MIXER_OSS_ITEM_CAPTURE\t10\n\n#define SNDRV_MIXER_OSS_ITEM_COUNT\t11\n\n#define SNDRV_MIXER_OSS_PRESENT_GLOBAL\t(1<<0)\n#define SNDRV_MIXER_OSS_PRESENT_GSWITCH\t(1<<1)\n#define SNDRV_MIXER_OSS_PRESENT_GROUTE\t(1<<2)\n#define SNDRV_MIXER_OSS_PRESENT_GVOLUME\t(1<<3)\n#define SNDRV_MIXER_OSS_PRESENT_PSWITCH\t(1<<4)\n#define SNDRV_MIXER_OSS_PRESENT_PROUTE\t(1<<5)\n#define SNDRV_MIXER_OSS_PRESENT_PVOLUME\t(1<<6)\n#define SNDRV_MIXER_OSS_PRESENT_CSWITCH\t(1<<7)\n#define SNDRV_MIXER_OSS_PRESENT_CROUTE\t(1<<8)\n#define SNDRV_MIXER_OSS_PRESENT_CVOLUME\t(1<<9)\n#define SNDRV_MIXER_OSS_PRESENT_CAPTURE\t(1<<10)\n\nstruct slot {\n\tunsigned int signature;\n\tunsigned int present;\n\tunsigned int channels;\n\tunsigned int numid[SNDRV_MIXER_OSS_ITEM_COUNT];\n\tunsigned int capture_item;\n\tconst struct snd_mixer_oss_assign_table *assigned;\n\tunsigned int allocated: 1;\n};\n\n#define ID_UNKNOWN\t((unsigned int)-1)\n\nstatic struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, const char *name, int index)\n{\n\tstruct snd_card *card = mixer->card;\n\tstruct snd_ctl_elem_id id;\n\t\n\tmemset(&id, 0, sizeof(id));\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrscpy(id.name, name, sizeof(id.name));\n\tid.index = index;\n\treturn snd_ctl_find_id_locked(card, &id);\n}\n\nstatic void snd_mixer_oss_get_volume1_vol(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t  struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t  unsigned int numid,\n\t\t\t\t\t  int *left, int *right)\n{\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = fmixer->card;\n\n\tif (numid == ID_UNKNOWN)\n\t\treturn;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid_locked(card, numid);\n\tif (!kctl) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn;\n\t}\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL)\n\t\tgoto __unalloc;\n\tif (kctl->info(kctl, uinfo))\n\t\tgoto __unalloc;\n\tif (kctl->get(kctl, uctl))\n\t\tgoto __unalloc;\n\tif (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&\n\t    uinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)\n\t\tgoto __unalloc;\n\t*left = snd_mixer_oss_conv1(uctl->value.integer.value[0], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[0]);\n\tif (uinfo->count > 1)\n\t\t*right = snd_mixer_oss_conv1(uctl->value.integer.value[1], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[1]);\n      __unalloc:\n\tup_read(&card->controls_rwsem);\n      \tkfree(uctl);\n      \tkfree(uinfo);\n}\n\nstatic void snd_mixer_oss_get_volume1_sw(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t unsigned int numid,\n\t\t\t\t\t int *left, int *right,\n\t\t\t\t\t int route)\n{\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = fmixer->card;\n\n\tif (numid == ID_UNKNOWN)\n\t\treturn;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid_locked(card, numid);\n\tif (!kctl) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn;\n\t}\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL)\n\t\tgoto __unalloc;\n\tif (kctl->info(kctl, uinfo))\n\t\tgoto __unalloc;\n\tif (kctl->get(kctl, uctl))\n\t\tgoto __unalloc;\n\tif (!uctl->value.integer.value[0]) {\n\t\t*left = 0;\n\t\tif (uinfo->count == 1)\n\t\t\t*right = 0;\n\t}\n\tif (uinfo->count > 1 && !uctl->value.integer.value[route ? 3 : 1])\n\t\t*right = 0;\n      __unalloc:\n\tup_read(&card->controls_rwsem);\n      \tkfree(uctl);\n\tkfree(uinfo);\n}\n\nstatic int snd_mixer_oss_get_volume1(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t     struct snd_mixer_oss_slot *pslot,\n\t\t\t\t     int *left, int *right)\n{\n\tstruct slot *slot = pslot->private_data;\n\t\n\t*left = *right = 100;\n\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {\n\t\tsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {\n\t\tsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {\n\t\tsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);\n\t}\n\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {\n\t\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {\n\t\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {\n\t\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {\n\t\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\n\t}\n\treturn 0;\n}\n\nstatic void snd_mixer_oss_put_volume1_vol(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t  struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t  unsigned int numid,\n\t\t\t\t\t  int left, int right)\n{\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = fmixer->card;\n\tint res;\n\n\tif (numid == ID_UNKNOWN)\n\t\treturn;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid_locked(card, numid);\n\tif (!kctl) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn;\n\t}\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL)\n\t\tgoto __unalloc;\n\tif (kctl->info(kctl, uinfo))\n\t\tgoto __unalloc;\n\tif (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&\n\t    uinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)\n\t\tgoto __unalloc;\n\tuctl->value.integer.value[0] = snd_mixer_oss_conv2(left, uinfo->value.integer.min, uinfo->value.integer.max);\n\tif (uinfo->count > 1)\n\t\tuctl->value.integer.value[1] = snd_mixer_oss_conv2(right, uinfo->value.integer.min, uinfo->value.integer.max);\n\tres = kctl->put(kctl, uctl);\n\tif (res < 0)\n\t\tgoto __unalloc;\n\tif (res > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\n      __unalloc:\n\tup_read(&card->controls_rwsem);\n      \tkfree(uctl);\n\tkfree(uinfo);\n}\n\nstatic void snd_mixer_oss_put_volume1_sw(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t unsigned int numid,\n\t\t\t\t\t int left, int right,\n\t\t\t\t\t int route)\n{\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = fmixer->card;\n\tint res;\n\n\tif (numid == ID_UNKNOWN)\n\t\treturn;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid_locked(card, numid);\n\tif (!kctl) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn;\n\t}\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL)\n\t\tgoto __unalloc;\n\tif (kctl->info(kctl, uinfo))\n\t\tgoto __unalloc;\n\tif (uinfo->count > 1) {\n\t\tuctl->value.integer.value[0] = left > 0 ? 1 : 0;\n\t\tuctl->value.integer.value[route ? 3 : 1] = right > 0 ? 1 : 0;\n\t\tif (route) {\n\t\t\tuctl->value.integer.value[1] =\n\t\t\tuctl->value.integer.value[2] = 0;\n\t\t}\n\t} else {\n\t\tuctl->value.integer.value[0] = (left > 0 || right > 0) ? 1 : 0;\n\t}\n\tres = kctl->put(kctl, uctl);\n\tif (res < 0)\n\t\tgoto __unalloc;\n\tif (res > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\n      __unalloc:\n\tup_read(&card->controls_rwsem);\n      \tkfree(uctl);\n\tkfree(uinfo);\n}\n\nstatic int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t     struct snd_mixer_oss_slot *pslot,\n\t\t\t\t     int left, int right)\n{\n\tstruct slot *slot = pslot->private_data;\n\t\n\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {\n\t\tsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME)\n\t\t\tsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME) {\n\t\tsnd_mixer_oss_put_volume1_vol(fmixer, pslot,\n\t\t\tslot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {\n\t\tsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);\n\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {\n\t\tsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);\n\t}\n\tif (left || right) {\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE)\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\n\t} else {\n\t\tif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\n\t\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);\n\t\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\n\t\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\n\t\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);\n\t\t} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {\n\t\t\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_get_recsrc1_sw(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\tstruct snd_mixer_oss_slot *pslot,\n\t\t\t\t\tint *active)\n{\n\tstruct slot *slot = pslot->private_data;\n\tint left, right;\n\t\n\tleft = right = 1;\n\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], &left, &right, 0);\n\t*active = (left || right) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_get_recsrc1_route(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t   struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t   int *active)\n{\n\tstruct slot *slot = pslot->private_data;\n\tint left, right;\n\t\n\tleft = right = 1;\n\tsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], &left, &right, 1);\n\t*active = (left || right) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_put_recsrc1_sw(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\tstruct snd_mixer_oss_slot *pslot,\n\t\t\t\t\tint active)\n{\n\tstruct slot *slot = pslot->private_data;\n\t\n\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], active, active, 0);\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_put_recsrc1_route(struct snd_mixer_oss_file *fmixer,\n\t\t\t\t\t   struct snd_mixer_oss_slot *pslot,\n\t\t\t\t\t   int active)\n{\n\tstruct slot *slot = pslot->private_data;\n\t\n\tsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], active, active, 1);\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int *active_index)\n{\n\tstruct snd_card *card = fmixer->card;\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_mixer_oss_slot *pslot;\n\tstruct slot *slot;\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tint err, idx;\n\t\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __free_only;\n\t}\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_mixer_oss_test_id(mixer, \"Capture Source\", 0);\n\tif (! kctl) {\n\t\terr = -ENOENT;\n\t\tgoto __unlock;\n\t}\n\terr = kctl->info(kctl, uinfo);\n\tif (err < 0)\n\t\tgoto __unlock;\n\terr = kctl->get(kctl, uctl);\n\tif (err < 0)\n\t\tgoto __unlock;\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tif (!(mixer->mask_recsrc & (1 << idx)))\n\t\t\tcontinue;\n\t\tpslot = &mixer->slots[idx];\n\t\tslot = pslot->private_data;\n\t\tif (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)\n\t\t\tcontinue;\n\t\tif (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))\n\t\t\tcontinue;\n\t\tif (slot->capture_item == uctl->value.enumerated.item[0]) {\n\t\t\t*active_index = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = 0;\n      __unlock:\n     \tup_read(&card->controls_rwsem);\n      __free_only:\n      \tkfree(uctl);\n      \tkfree(uinfo);\n      \treturn err;\n}\n\nstatic int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int active_index)\n{\n\tstruct snd_card *card = fmixer->card;\n\tstruct snd_mixer_oss *mixer = fmixer->mixer;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_mixer_oss_slot *pslot;\n\tstruct slot *slot = NULL;\n\tstruct snd_ctl_elem_info *uinfo;\n\tstruct snd_ctl_elem_value *uctl;\n\tint err;\n\tunsigned int idx;\n\n\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (uinfo == NULL || uctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __free_only;\n\t}\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_mixer_oss_test_id(mixer, \"Capture Source\", 0);\n\tif (! kctl) {\n\t\terr = -ENOENT;\n\t\tgoto __unlock;\n\t}\n\terr = kctl->info(kctl, uinfo);\n\tif (err < 0)\n\t\tgoto __unlock;\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tif (!(mixer->mask_recsrc & (1 << idx)))\n\t\t\tcontinue;\n\t\tpslot = &mixer->slots[idx];\n\t\tslot = pslot->private_data;\n\t\tif (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)\n\t\t\tcontinue;\n\t\tif (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))\n\t\t\tcontinue;\n\t\tif (idx == active_index)\n\t\t\tbreak;\n\t\tslot = NULL;\n\t}\n\tif (! slot)\n\t\tgoto __unlock;\n\tfor (idx = 0; idx < uinfo->count; idx++)\n\t\tuctl->value.enumerated.item[idx] = slot->capture_item;\n\terr = kctl->put(kctl, uctl);\n\tif (err > 0)\n\t\tsnd_ctl_notify(fmixer->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\n\terr = 0;\n      __unlock:\n\tup_read(&card->controls_rwsem);\n      __free_only:\n\tkfree(uctl);\n\tkfree(uinfo);\n\treturn err;\n}\n\nstruct snd_mixer_oss_assign_table {\n\tint oss_id;\n\tconst char *name;\n\tint index;\n};\n\nstatic int snd_mixer_oss_build_test(struct snd_mixer_oss *mixer, struct slot *slot, const char *name, int index, int item)\n{\n\tstruct snd_ctl_elem_info *info;\n\tstruct snd_kcontrol *kcontrol;\n\tstruct snd_card *card = mixer->card;\n\tint err;\n\n\tdown_read(&card->controls_rwsem);\n\tkcontrol = snd_mixer_oss_test_id(mixer, name, index);\n\tif (kcontrol == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn 0;\n\t}\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOMEM;\n\t}\n\terr = kcontrol->info(kcontrol, info);\n\tif (err < 0) {\n\t\tup_read(&card->controls_rwsem);\n\t\tkfree(info);\n\t\treturn err;\n\t}\n\tslot->numid[item] = kcontrol->id.numid;\n\tup_read(&card->controls_rwsem);\n\tif (info->count > slot->channels)\n\t\tslot->channels = info->count;\n\tslot->present |= 1 << item;\n\tkfree(info);\n\treturn 0;\n}\n\nstatic void snd_mixer_oss_slot_free(struct snd_mixer_oss_slot *chn)\n{\n\tstruct slot *p = chn->private_data;\n\tif (p) {\n\t\tif (p->allocated && p->assigned) {\n\t\t\tkfree_const(p->assigned->name);\n\t\t\tkfree_const(p->assigned);\n\t\t}\n\t\tkfree(p);\n\t}\n}\n\nstatic void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)\n{\n\tint idx = rslot->number;  \n\tif (rslot->private_free)\n\t\trslot->private_free(rslot);\n\tmemset(rslot, 0, sizeof(*rslot));\n\trslot->number = idx;\n}\n\n \nstatic int snd_mixer_oss_build_test_all(struct snd_mixer_oss *mixer,\n\t\t\t\t\tconst struct snd_mixer_oss_assign_table *ptr,\n\t\t\t\t\tstruct slot *slot)\n{\n\tchar str[64];\n\tint err;\n\n\terr = snd_mixer_oss_build_test(mixer, slot, ptr->name, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_GLOBAL);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Switch\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_GSWITCH);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Route\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_GROUTE);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Volume\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_GVOLUME);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Playback Switch\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_PSWITCH);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Playback Route\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_PROUTE);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Playback Volume\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_PVOLUME);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Capture Switch\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_CSWITCH);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Capture Route\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_CROUTE);\n\tif (err)\n\t\treturn err;\n\tsprintf(str, \"%s Capture Volume\", ptr->name);\n\terr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\n\t\t\t\t       SNDRV_MIXER_OSS_ITEM_CVOLUME);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer,\n\t\t\t\t     const struct snd_mixer_oss_assign_table *ptr,\n\t\t\t\t     int ptr_allocated, int replace_old)\n{\n\tstruct slot slot;\n\tstruct slot *pslot;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_mixer_oss_slot *rslot;\n\tchar str[64];\t\n\t\n\t \n\tif (mixer->slots[ptr->oss_id].get_volume && ! replace_old)\n\t\treturn 0;\n\n\tmemset(&slot, 0, sizeof(slot));\n\tmemset(slot.numid, 0xff, sizeof(slot.numid));  \n\tif (snd_mixer_oss_build_test_all(mixer, ptr, &slot))\n\t\treturn 0;\n\tdown_read(&mixer->card->controls_rwsem);\n\tkctl = NULL;\n\tif (!ptr->index)\n\t\tkctl = snd_mixer_oss_test_id(mixer, \"Capture Source\", 0);\n\tif (kctl) {\n\t\tstruct snd_ctl_elem_info *uinfo;\n\n\t\tuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\n\t\tif (! uinfo) {\n\t\t\tup_read(&mixer->card->controls_rwsem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t\t\n\t\tif (kctl->info(kctl, uinfo)) {\n\t\t\tup_read(&mixer->card->controls_rwsem);\n\t\t\tkfree(uinfo);\n\t\t\treturn 0;\n\t\t}\n\t\tstrcpy(str, ptr->name);\n\t\tif (!strcmp(str, \"Master\"))\n\t\t\tstrcpy(str, \"Mix\");\n\t\tif (!strcmp(str, \"Master Mono\"))\n\t\t\tstrcpy(str, \"Mix Mono\");\n\t\tslot.capture_item = 0;\n\t\tif (!strcmp(uinfo->value.enumerated.name, str)) {\n\t\t\tslot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;\n\t\t} else {\n\t\t\tfor (slot.capture_item = 1; slot.capture_item < uinfo->value.enumerated.items; slot.capture_item++) {\n\t\t\t\tuinfo->value.enumerated.item = slot.capture_item;\n\t\t\t\tif (kctl->info(kctl, uinfo)) {\n\t\t\t\t\tup_read(&mixer->card->controls_rwsem);\n\t\t\t\t\tkfree(uinfo);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(uinfo->value.enumerated.name, str)) {\n\t\t\t\t\tslot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tkfree(uinfo);\n\t}\n\tup_read(&mixer->card->controls_rwsem);\n\tif (slot.present != 0) {\n\t\tpslot = kmalloc(sizeof(slot), GFP_KERNEL);\n\t\tif (! pslot)\n\t\t\treturn -ENOMEM;\n\t\t*pslot = slot;\n\t\tpslot->signature = SNDRV_MIXER_OSS_SIGNATURE;\n\t\tpslot->assigned = ptr;\n\t\tpslot->allocated = ptr_allocated;\n\t\trslot = &mixer->slots[ptr->oss_id];\n\t\tmixer_slot_clear(rslot);\n\t\trslot->stereo = slot.channels > 1 ? 1 : 0;\n\t\trslot->get_volume = snd_mixer_oss_get_volume1;\n\t\trslot->put_volume = snd_mixer_oss_put_volume1;\n\t\t \n\t\tif (slot.present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {\n\t\t\trslot->get_recsrc = snd_mixer_oss_get_recsrc1_sw;\n\t\t\trslot->put_recsrc = snd_mixer_oss_put_recsrc1_sw;\n\t\t} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {\n\t\t\trslot->get_recsrc = snd_mixer_oss_get_recsrc1_route;\n\t\t\trslot->put_recsrc = snd_mixer_oss_put_recsrc1_route;\n\t\t} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CAPTURE) {\n\t\t\tmixer->mask_recsrc |= 1 << ptr->oss_id;\n\t\t}\n\t\trslot->private_data = pslot;\n\t\trslot->private_free = snd_mixer_oss_slot_free;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_PROC_FS\n \n#define MIXER_VOL(name) [SOUND_MIXER_##name] = #name\nstatic const char * const oss_mixer_names[SNDRV_OSS_MAX_MIXERS] = {\n\tMIXER_VOL(VOLUME),\n\tMIXER_VOL(BASS),\n\tMIXER_VOL(TREBLE),\n\tMIXER_VOL(SYNTH),\n\tMIXER_VOL(PCM),\n\tMIXER_VOL(SPEAKER),\n\tMIXER_VOL(LINE),\n\tMIXER_VOL(MIC),\n\tMIXER_VOL(CD),\n\tMIXER_VOL(IMIX),\n\tMIXER_VOL(ALTPCM),\n\tMIXER_VOL(RECLEV),\n\tMIXER_VOL(IGAIN),\n\tMIXER_VOL(OGAIN),\n\tMIXER_VOL(LINE1),\n\tMIXER_VOL(LINE2),\n\tMIXER_VOL(LINE3),\n\tMIXER_VOL(DIGITAL1),\n\tMIXER_VOL(DIGITAL2),\n\tMIXER_VOL(DIGITAL3),\n\tMIXER_VOL(PHONEIN),\n\tMIXER_VOL(PHONEOUT),\n\tMIXER_VOL(VIDEO),\n\tMIXER_VOL(RADIO),\n\tMIXER_VOL(MONITOR),\n};\n\t\n \n\nstatic void snd_mixer_oss_proc_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_mixer_oss *mixer = entry->private_data;\n\tint i;\n\n\tmutex_lock(&mixer->reg_mutex);\n\tfor (i = 0; i < SNDRV_OSS_MAX_MIXERS; i++) {\n\t\tstruct slot *p;\n\n\t\tif (! oss_mixer_names[i])\n\t\t\tcontinue;\n\t\tp = (struct slot *)mixer->slots[i].private_data;\n\t\tsnd_iprintf(buffer, \"%s \", oss_mixer_names[i]);\n\t\tif (p && p->assigned)\n\t\t\tsnd_iprintf(buffer, \"\\\"%s\\\" %d\\n\",\n\t\t\t\t    p->assigned->name,\n\t\t\t\t    p->assigned->index);\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"\\\"\\\" 0\\n\");\n\t}\n\tmutex_unlock(&mixer->reg_mutex);\n}\n\nstatic void snd_mixer_oss_proc_write(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_mixer_oss *mixer = entry->private_data;\n\tchar line[128], str[32], idxstr[16];\n\tconst char *cptr;\n\tunsigned int idx;\n\tint ch;\n\tstruct snd_mixer_oss_assign_table *tbl;\n\tstruct slot *slot;\n\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tcptr = snd_info_get_str(str, line, sizeof(str));\n\t\tfor (ch = 0; ch < SNDRV_OSS_MAX_MIXERS; ch++)\n\t\t\tif (oss_mixer_names[ch] && strcmp(oss_mixer_names[ch], str) == 0)\n\t\t\t\tbreak;\n\t\tif (ch >= SNDRV_OSS_MAX_MIXERS) {\n\t\t\tpr_err(\"ALSA: mixer_oss: invalid OSS volume '%s'\\n\",\n\t\t\t       str);\n\t\t\tcontinue;\n\t\t}\n\t\tcptr = snd_info_get_str(str, cptr, sizeof(str));\n\t\tif (! *str) {\n\t\t\t \n\t\t\tmutex_lock(&mixer->reg_mutex);\n\t\t\tmixer_slot_clear(&mixer->slots[ch]);\n\t\t\tmutex_unlock(&mixer->reg_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tsnd_info_get_str(idxstr, cptr, sizeof(idxstr));\n\t\tidx = simple_strtoul(idxstr, NULL, 10);\n\t\tif (idx >= 0x4000) {  \n\t\t\tpr_err(\"ALSA: mixer_oss: invalid index %d\\n\", idx);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&mixer->reg_mutex);\n\t\tslot = (struct slot *)mixer->slots[ch].private_data;\n\t\tif (slot && slot->assigned &&\n\t\t    slot->assigned->index == idx && ! strcmp(slot->assigned->name, str))\n\t\t\t \n\t\t\tgoto __unlock;\n\t\ttbl = kmalloc(sizeof(*tbl), GFP_KERNEL);\n\t\tif (!tbl)\n\t\t\tgoto __unlock;\n\t\ttbl->oss_id = ch;\n\t\ttbl->name = kstrdup(str, GFP_KERNEL);\n\t\tif (! tbl->name) {\n\t\t\tkfree(tbl);\n\t\t\tgoto __unlock;\n\t\t}\n\t\ttbl->index = idx;\n\t\tif (snd_mixer_oss_build_input(mixer, tbl, 1, 1) <= 0) {\n\t\t\tkfree(tbl->name);\n\t\t\tkfree(tbl);\n\t\t}\n\t__unlock:\n\t\tmutex_unlock(&mixer->reg_mutex);\n\t}\n}\n\nstatic void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(mixer->card, \"oss_mixer\",\n\t\t\t\t\t   mixer->card->proc_root);\n\tif (! entry)\n\t\treturn;\n\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\tentry->mode = S_IFREG | 0644;\n\tentry->c.text.read = snd_mixer_oss_proc_read;\n\tentry->c.text.write = snd_mixer_oss_proc_write;\n\tentry->private_data = mixer;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\tentry = NULL;\n\t}\n\tmixer->proc_entry = entry;\n}\n\nstatic void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)\n{\n\tsnd_info_free_entry(mixer->proc_entry);\n\tmixer->proc_entry = NULL;\n}\n#else  \n#define snd_mixer_oss_proc_init(mix)\n#define snd_mixer_oss_proc_done(mix)\n#endif  \n\nstatic void snd_mixer_oss_build(struct snd_mixer_oss *mixer)\n{\n\tstatic const struct snd_mixer_oss_assign_table table[] = {\n\t\t{ SOUND_MIXER_VOLUME, \t\"Master\",\t\t0 },\n\t\t{ SOUND_MIXER_VOLUME, \t\"Front\",\t\t0 },  \n\t\t{ SOUND_MIXER_BASS,\t\"Tone Control - Bass\",\t0 },\n\t\t{ SOUND_MIXER_TREBLE,\t\"Tone Control - Treble\", 0 },\n\t\t{ SOUND_MIXER_SYNTH,\t\"Synth\",\t\t0 },\n\t\t{ SOUND_MIXER_SYNTH,\t\"FM\",\t\t\t0 },  \n\t\t{ SOUND_MIXER_SYNTH,\t\"Music\",\t\t0 },  \n\t\t{ SOUND_MIXER_PCM,\t\"PCM\",\t\t\t0 },\n\t\t{ SOUND_MIXER_SPEAKER,\t\"Beep\", \t\t0 },\n\t\t{ SOUND_MIXER_SPEAKER,\t\"PC Speaker\", \t\t0 },  \n\t\t{ SOUND_MIXER_SPEAKER,\t\"Speaker\", \t\t0 },  \n\t\t{ SOUND_MIXER_LINE,\t\"Line\", \t\t0 },\n\t\t{ SOUND_MIXER_MIC,\t\"Mic\", \t\t\t0 },\n\t\t{ SOUND_MIXER_CD,\t\"CD\", \t\t\t0 },\n\t\t{ SOUND_MIXER_IMIX,\t\"Monitor Mix\", \t\t0 },\n\t\t{ SOUND_MIXER_ALTPCM,\t\"PCM\",\t\t\t1 },\n\t\t{ SOUND_MIXER_ALTPCM,\t\"Headphone\",\t\t0 },  \n\t\t{ SOUND_MIXER_ALTPCM,\t\"Wave\",\t\t\t0 },  \n\t\t{ SOUND_MIXER_RECLEV,\t\"-- nothing --\",\t0 },\n\t\t{ SOUND_MIXER_IGAIN,\t\"Capture\",\t\t0 },\n\t\t{ SOUND_MIXER_OGAIN,\t\"Playback\",\t\t0 },\n\t\t{ SOUND_MIXER_LINE1,\t\"Aux\",\t\t\t0 },\n\t\t{ SOUND_MIXER_LINE2,\t\"Aux\",\t\t\t1 },\n\t\t{ SOUND_MIXER_LINE3,\t\"Aux\",\t\t\t2 },\n\t\t{ SOUND_MIXER_DIGITAL1,\t\"Digital\",\t\t0 },\n\t\t{ SOUND_MIXER_DIGITAL1,\t\"IEC958\",\t\t0 },  \n\t\t{ SOUND_MIXER_DIGITAL1,\t\"IEC958 Optical\",\t0 },  \n\t\t{ SOUND_MIXER_DIGITAL1,\t\"IEC958 Coaxial\",\t0 },  \n\t\t{ SOUND_MIXER_DIGITAL2,\t\"Digital\",\t\t1 },\n\t\t{ SOUND_MIXER_DIGITAL3,\t\"Digital\",\t\t2 },\n\t\t{ SOUND_MIXER_PHONEIN,\t\"Phone\",\t\t0 },\n\t\t{ SOUND_MIXER_PHONEOUT,\t\"Master Mono\",\t\t0 },\n\t\t{ SOUND_MIXER_PHONEOUT,\t\"Speaker\",\t\t0 },  \n\t\t{ SOUND_MIXER_PHONEOUT,\t\"Mono\",\t\t\t0 },  \n\t\t{ SOUND_MIXER_PHONEOUT,\t\"Phone\",\t\t0 },  \n\t\t{ SOUND_MIXER_VIDEO,\t\"Video\",\t\t0 },\n\t\t{ SOUND_MIXER_RADIO,\t\"Radio\",\t\t0 },\n\t\t{ SOUND_MIXER_MONITOR,\t\"Monitor\",\t\t0 }\n\t};\n\tunsigned int idx;\n\t\n\tfor (idx = 0; idx < ARRAY_SIZE(table); idx++)\n\t\tsnd_mixer_oss_build_input(mixer, &table[idx], 0, 0);\n\tif (mixer->mask_recsrc) {\n\t\tmixer->get_recsrc = snd_mixer_oss_get_recsrc2;\n\t\tmixer->put_recsrc = snd_mixer_oss_put_recsrc2;\n\t}\n}\n\n \n\nstatic int snd_mixer_oss_free1(void *private)\n{\n\tstruct snd_mixer_oss *mixer = private;\n\tstruct snd_card *card;\n\tint idx;\n \n\tif (!mixer)\n\t\treturn 0;\n\tcard = mixer->card;\n\tif (snd_BUG_ON(mixer != card->mixer_oss))\n\t\treturn -ENXIO;\n\tcard->mixer_oss = NULL;\n\tfor (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++) {\n\t\tstruct snd_mixer_oss_slot *chn = &mixer->slots[idx];\n\t\tif (chn->private_free)\n\t\t\tchn->private_free(chn);\n\t}\n\tkfree(mixer);\n\treturn 0;\n}\n\nstatic int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)\n{\n\tstruct snd_mixer_oss *mixer;\n\n\tif (cmd == SND_MIXER_OSS_NOTIFY_REGISTER) {\n\t\tint idx, err;\n\n\t\tmixer = kcalloc(2, sizeof(*mixer), GFP_KERNEL);\n\t\tif (mixer == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmutex_init(&mixer->reg_mutex);\n\t\terr = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,\n\t\t\t\t\t      card, 0,\n\t\t\t\t\t      &snd_mixer_oss_f_ops, card);\n\t\tif (err < 0) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"unable to register OSS mixer device %i:%i\\n\",\n\t\t\t\tcard->number, 0);\n\t\t\tkfree(mixer);\n\t\t\treturn err;\n\t\t}\n\t\tmixer->oss_dev_alloc = 1;\n\t\tmixer->card = card;\n\t\tif (*card->mixername)\n\t\t\tstrscpy(mixer->name, card->mixername, sizeof(mixer->name));\n\t\telse\n\t\t\tsnprintf(mixer->name, sizeof(mixer->name),\n\t\t\t\t \"mixer%i\", card->number);\n#ifdef SNDRV_OSS_INFO_DEV_MIXERS\n\t\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_MIXERS,\n\t\t\t\t      card->number,\n\t\t\t\t      mixer->name);\n#endif\n\t\tfor (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++)\n\t\t\tmixer->slots[idx].number = idx;\n\t\tcard->mixer_oss = mixer;\n\t\tsnd_mixer_oss_build(mixer);\n\t\tsnd_mixer_oss_proc_init(mixer);\n\t} else {\n\t\tmixer = card->mixer_oss;\n\t\tif (mixer == NULL)\n\t\t\treturn 0;\n\t\tif (mixer->oss_dev_alloc) {\n#ifdef SNDRV_OSS_INFO_DEV_MIXERS\n\t\t\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);\n#endif\n\t\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);\n\t\t\tmixer->oss_dev_alloc = 0;\n\t\t}\n\t\tif (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT)\n\t\t\treturn 0;\n\t\tsnd_mixer_oss_proc_done(mixer);\n\t\treturn snd_mixer_oss_free1(mixer);\n\t}\n\treturn 0;\n}\n\nstatic int __init alsa_mixer_oss_init(void)\n{\n\tstruct snd_card *card;\n\tint idx;\n\t\n\tsnd_mixer_oss_notify_callback = snd_mixer_oss_notify_handler;\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tcard = snd_card_ref(idx);\n\t\tif (card) {\n\t\t\tsnd_mixer_oss_notify_handler(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n\t\t\tsnd_card_unref(card);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_mixer_oss_exit(void)\n{\n\tstruct snd_card *card;\n\tint idx;\n\n\tsnd_mixer_oss_notify_callback = NULL;\n\tfor (idx = 0; idx < SNDRV_CARDS; idx++) {\n\t\tcard = snd_card_ref(idx);\n\t\tif (card) {\n\t\t\tsnd_mixer_oss_notify_handler(card, SND_MIXER_OSS_NOTIFY_FREE);\n\t\t\tsnd_card_unref(card);\n\t\t}\n\t}\n}\n\nmodule_init(alsa_mixer_oss_init)\nmodule_exit(alsa_mixer_oss_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}