{
  "module_name": "pcm_oss.c",
  "hash_id": "d68957f758b1fe673c9ae15d17b13d8f1b5676c888e0039a81ea2815f0202ad5",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/pcm_oss.c",
  "human_readable_source": "\n \n\n#if 0\n#define PLUGIN_DEBUG\n#endif\n#if 0\n#define OSS_DEBUG\n#endif\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/string.h>\n#include <linux/compat.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"pcm_plugin.h\"\n#include <sound/info.h>\n#include <linux/soundcard.h>\n#include <sound/initval.h>\n#include <sound/mixer_oss.h>\n\n#define OSS_ALSAEMULVER\t\t_SIOR ('M', 249, int)\n\nstatic int dsp_map[SNDRV_CARDS];\nstatic int adsp_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};\nstatic bool nonblock_open = 1;\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Abramo Bagnara <abramo@alsa-project.org>\");\nMODULE_DESCRIPTION(\"PCM OSS emulation for ALSA.\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(dsp_map, int, NULL, 0444);\nMODULE_PARM_DESC(dsp_map, \"PCM device number assigned to 1st OSS device.\");\nmodule_param_array(adsp_map, int, NULL, 0444);\nMODULE_PARM_DESC(adsp_map, \"PCM device number assigned to 2nd OSS device.\");\nmodule_param(nonblock_open, bool, 0644);\nMODULE_PARM_DESC(nonblock_open, \"Don't block opening busy PCM devices.\");\nMODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_PCM);\nMODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_PCM1);\n\nstatic int snd_pcm_oss_get_rate(struct snd_pcm_oss_file *pcm_oss_file);\nstatic int snd_pcm_oss_get_channels(struct snd_pcm_oss_file *pcm_oss_file);\nstatic int snd_pcm_oss_get_format(struct snd_pcm_oss_file *pcm_oss_file);\n\n \nstatic int snd_interval_refine_min(struct snd_interval *i, unsigned int min, int openmin)\n{\n\tint changed = 0;\n\tif (i->min < min) {\n\t\ti->min = min;\n\t\ti->openmin = openmin;\n\t\tchanged = 1;\n\t} else if (i->min == min && !i->openmin && openmin) {\n\t\ti->openmin = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmin) {\n\t\t\ti->min++;\n\t\t\ti->openmin = 0;\n\t\t}\n\t}\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\nstatic int snd_interval_refine_max(struct snd_interval *i, unsigned int max, int openmax)\n{\n\tint changed = 0;\n\tif (i->max > max) {\n\t\ti->max = max;\n\t\ti->openmax = openmax;\n\t\tchanged = 1;\n\t} else if (i->max == max && !i->openmax && openmax) {\n\t\ti->openmax = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmax) {\n\t\t\ti->max--;\n\t\t\ti->openmax = 0;\n\t\t}\n\t}\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\n{\n\tstruct snd_interval t;\n\tt.empty = 0;\n\tt.min = t.max = val;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(i, &t);\n}\n\n \nstatic unsigned int\nsnd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,\n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tif (hw_is_mask(var)) {\n\t\tif (dir)\n\t\t\t*dir = 0;\n\t\treturn snd_mask_min(hw_param_mask_c(params, var));\n\t}\n\tif (hw_is_interval(var)) {\n\t\tconst struct snd_interval *i = hw_param_interval_c(params, var);\n\t\tif (dir)\n\t\t\t*dir = i->openmin;\n\t\treturn snd_interval_min(i);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int\nsnd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,\n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tif (hw_is_mask(var)) {\n\t\tif (dir)\n\t\t\t*dir = 0;\n\t\treturn snd_mask_max(hw_param_mask_c(params, var));\n\t}\n\tif (hw_is_interval(var)) {\n\t\tconst struct snd_interval *i = hw_param_interval_c(params, var);\n\t\tif (dir)\n\t\t\t*dir = - (int) i->openmax;\n\t\treturn snd_interval_max(i);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int _snd_pcm_hw_param_mask(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_mask *val)\n{\n\tint changed;\n\tchanged = snd_mask_refine(hw_param_mask(params, var), val);\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\nstatic int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var,\n\t\t\t\t const struct snd_mask *val)\n{\n\tint changed = _snd_pcm_hw_param_mask(params, var, val);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\t int dir)\n{\n\tint changed;\n\tint open = 0;\n\tif (dir) {\n\t\tif (dir > 0) {\n\t\t\topen = 1;\n\t\t} else if (dir < 0) {\n\t\t\tif (val > 0) {\n\t\t\t\topen = 1;\n\t\t\t\tval--;\n\t\t\t}\n\t\t}\n\t}\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_min(hw_param_mask(params, var),\n\t\t\t\t\t      val + !!open);\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_min(hw_param_interval(params, var),\n\t\t\t\t\t\t  val, open);\n\telse\n\t\treturn -EINVAL;\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n \nstatic int snd_pcm_hw_param_min(struct snd_pcm_substream *pcm,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\tint *dir)\n{\n\tint changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value_min(params, var, dir);\n}\n\nstatic int _snd_pcm_hw_param_max(struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\t int dir)\n{\n\tint changed;\n\tint open = 0;\n\tif (dir) {\n\t\tif (dir < 0) {\n\t\t\topen = 1;\n\t\t} else if (dir > 0) {\n\t\t\topen = 1;\n\t\t\tval++;\n\t\t}\n\t}\n\tif (hw_is_mask(var)) {\n\t\tif (val == 0 && open) {\n\t\t\tsnd_mask_none(hw_param_mask(params, var));\n\t\t\tchanged = -EINVAL;\n\t\t} else\n\t\t\tchanged = snd_mask_refine_max(hw_param_mask(params, var),\n\t\t\t\t\t\t      val - !!open);\n\t} else if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_max(hw_param_interval(params, var),\n\t\t\t\t\t\t  val, open);\n\telse\n\t\treturn -EINVAL;\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n \nstatic int snd_pcm_hw_param_max(struct snd_pcm_substream *pcm,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\tint *dir)\n{\n\tint changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value_max(params, var, dir);\n}\n\nstatic int boundary_sub(int a, int adir,\n\t\t\tint b, int bdir,\n\t\t\tint *c, int *cdir)\n{\n\tadir = adir < 0 ? -1 : (adir > 0 ? 1 : 0);\n\tbdir = bdir < 0 ? -1 : (bdir > 0 ? 1 : 0);\n\t*c = a - b;\n\t*cdir = adir - bdir;\n\tif (*cdir == -2) {\n\t\t(*c)--;\n\t} else if (*cdir == 2) {\n\t\t(*c)++;\n\t}\n\treturn 0;\n}\n\nstatic int boundary_lt(unsigned int a, int adir,\n\t\t       unsigned int b, int bdir)\n{\n\tif (adir < 0) {\n\t\ta--;\n\t\tadir = 1;\n\t} else if (adir > 0)\n\t\tadir = 1;\n\tif (bdir < 0) {\n\t\tb--;\n\t\tbdir = 1;\n\t} else if (bdir > 0)\n\t\tbdir = 1;\n\treturn a < b || (a == b && adir < bdir);\n}\n\n \nstatic int boundary_nearer(int min, int mindir,\n\t\t\t   int best, int bestdir,\n\t\t\t   int max, int maxdir)\n{\n\tint dmin, dmindir;\n\tint dmax, dmaxdir;\n\tboundary_sub(best, bestdir, min, mindir, &dmin, &dmindir);\n\tboundary_sub(max, maxdir, best, bestdir, &dmax, &dmaxdir);\n\treturn boundary_lt(dmin, dmindir, dmax, dmaxdir);\n}\n\n \nstatic int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var, unsigned int best,\n\t\t\t\t int *dir)\n{\n\tstruct snd_pcm_hw_params *save = NULL;\n\tint v;\n\tunsigned int saved_min;\n\tint last = 0;\n\tint min, max;\n\tint mindir, maxdir;\n\tint valdir = dir ? *dir : 0;\n\t \n\tif (best > INT_MAX)\n\t\tbest = INT_MAX;\n\tmin = max = best;\n\tmindir = maxdir = valdir;\n\tif (maxdir > 0)\n\t\tmaxdir = 0;\n\telse if (maxdir == 0)\n\t\tmaxdir = -1;\n\telse {\n\t\tmaxdir = 1;\n\t\tmax--;\n\t}\n\tsave = kmalloc(sizeof(*save), GFP_KERNEL);\n\tif (save == NULL)\n\t\treturn -ENOMEM;\n\t*save = *params;\n\tsaved_min = min;\n\tmin = snd_pcm_hw_param_min(pcm, params, var, min, &mindir);\n\tif (min >= 0) {\n\t\tstruct snd_pcm_hw_params *params1;\n\t\tif (max < 0)\n\t\t\tgoto _end;\n\t\tif ((unsigned int)min == saved_min && mindir == valdir)\n\t\t\tgoto _end;\n\t\tparams1 = kmalloc(sizeof(*params1), GFP_KERNEL);\n\t\tif (params1 == NULL) {\n\t\t\tkfree(save);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*params1 = *save;\n\t\tmax = snd_pcm_hw_param_max(pcm, params1, var, max, &maxdir);\n\t\tif (max < 0) {\n\t\t\tkfree(params1);\n\t\t\tgoto _end;\n\t\t}\n\t\tif (boundary_nearer(max, maxdir, best, valdir, min, mindir)) {\n\t\t\t*params = *params1;\n\t\t\tlast = 1;\n\t\t}\n\t\tkfree(params1);\n\t} else {\n\t\t*params = *save;\n\t\tmax = snd_pcm_hw_param_max(pcm, params, var, max, &maxdir);\n\t\tif (max < 0) {\n\t\t\tkfree(save);\n\t\t\treturn max;\n\t\t}\n\t\tlast = 1;\n\t}\n _end:\n \tkfree(save);\n\tif (last)\n\t\tv = snd_pcm_hw_param_last(pcm, params, var, dir);\n\telse\n\t\tv = snd_pcm_hw_param_first(pcm, params, var, dir);\n\treturn v;\n}\n\nstatic int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\t int dir)\n{\n\tint changed;\n\tif (hw_is_mask(var)) {\n\t\tstruct snd_mask *m = hw_param_mask(params, var);\n\t\tif (val == 0 && dir < 0) {\n\t\t\tchanged = -EINVAL;\n\t\t\tsnd_mask_none(m);\n\t\t} else {\n\t\t\tif (dir > 0)\n\t\t\t\tval++;\n\t\t\telse if (dir < 0)\n\t\t\t\tval--;\n\t\t\tchanged = snd_mask_refine_set(hw_param_mask(params, var), val);\n\t\t}\n\t} else if (hw_is_interval(var)) {\n\t\tstruct snd_interval *i = hw_param_interval(params, var);\n\t\tif (val == 0 && dir < 0) {\n\t\t\tchanged = -EINVAL;\n\t\t\tsnd_interval_none(i);\n\t\t} else if (dir == 0)\n\t\t\tchanged = snd_interval_refine_set(i, val);\n\t\telse {\n\t\t\tstruct snd_interval t;\n\t\t\tt.openmin = 1;\n\t\t\tt.openmax = 1;\n\t\t\tt.empty = 0;\n\t\t\tt.integer = 0;\n\t\t\tif (dir < 0) {\n\t\t\t\tt.min = val - 1;\n\t\t\t\tt.max = val;\n\t\t\t} else {\n\t\t\t\tt.min = val;\n\t\t\t\tt.max = val+1;\n\t\t\t}\n\t\t\tchanged = snd_interval_refine(i, &t);\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n \nstatic int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\tint dir)\n{\n\tint changed = _snd_pcm_hw_param_set(params, var, val, dir);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, NULL);\n}\n\nstatic int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,\n\t\t\t\t\tsnd_pcm_hw_param_t var)\n{\n\tint changed;\n\tchanged = snd_interval_setinteger(hw_param_interval(params, var));\n\tif (changed > 0) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\t\n \n\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\nstatic int snd_pcm_oss_plugin_clear(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_plugin *plugin, *next;\n\t\n\tplugin = runtime->oss.plugin_first;\n\twhile (plugin) {\n\t\tnext = plugin->next;\n\t\tsnd_pcm_plugin_free(plugin);\n\t\tplugin = next;\n\t}\n\truntime->oss.plugin_first = runtime->oss.plugin_last = NULL;\n\treturn 0;\n}\n\nstatic int snd_pcm_plugin_insert(struct snd_pcm_plugin *plugin)\n{\n\tstruct snd_pcm_runtime *runtime = plugin->plug->runtime;\n\tplugin->next = runtime->oss.plugin_first;\n\tplugin->prev = NULL;\n\tif (runtime->oss.plugin_first) {\n\t\truntime->oss.plugin_first->prev = plugin;\n\t\truntime->oss.plugin_first = plugin;\n\t} else {\n\t\truntime->oss.plugin_last =\n\t\truntime->oss.plugin_first = plugin;\n\t}\n\treturn 0;\n}\n\nint snd_pcm_plugin_append(struct snd_pcm_plugin *plugin)\n{\n\tstruct snd_pcm_runtime *runtime = plugin->plug->runtime;\n\tplugin->next = NULL;\n\tplugin->prev = runtime->oss.plugin_last;\n\tif (runtime->oss.plugin_last) {\n\t\truntime->oss.plugin_last->next = plugin;\n\t\truntime->oss.plugin_last = plugin;\n\t} else {\n\t\truntime->oss.plugin_last =\n\t\truntime->oss.plugin_first = plugin;\n\t}\n\treturn 0;\n}\n#endif  \n\nstatic long snd_pcm_oss_bytes(struct snd_pcm_substream *substream, long frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tlong buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tlong bytes = frames_to_bytes(runtime, frames);\n\tif (buffer_size == runtime->oss.buffer_bytes)\n\t\treturn bytes;\n#if BITS_PER_LONG >= 64\n\treturn runtime->oss.buffer_bytes * bytes / buffer_size;\n#else\n\t{\n\t\tu64 bsize = (u64)runtime->oss.buffer_bytes * (u64)bytes;\n\t\treturn div_u64(bsize, buffer_size);\n\t}\n#endif\n}\n\nstatic long snd_pcm_alsa_frames(struct snd_pcm_substream *substream, long bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tlong buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tif (buffer_size == runtime->oss.buffer_bytes)\n\t\treturn bytes_to_frames(runtime, bytes);\n\treturn bytes_to_frames(runtime, (buffer_size * bytes) / runtime->oss.buffer_bytes);\n}\n\nstatic inline\nsnd_pcm_uframes_t get_hw_ptr_period(struct snd_pcm_runtime *runtime)\n{\n\treturn runtime->hw_ptr_interrupt;\n}\n\n \n \n#define AFMT_S32_LE      0x00001000\n#define AFMT_S32_BE      0x00002000\n#define AFMT_S24_LE      0x00008000\n#define AFMT_S24_BE      0x00010000\n#define AFMT_S24_PACKED  0x00040000\n\n \n#define AFMT_FLOAT       0x00004000\n#define AFMT_SPDIF_RAW   0x00020000\n\n \n#define AFMT_AC3         0x00000400\n#define AFMT_VORBIS      0x00000800\n\nstatic snd_pcm_format_t snd_pcm_oss_format_from(int format)\n{\n\tswitch (format) {\n\tcase AFMT_MU_LAW:\treturn SNDRV_PCM_FORMAT_MU_LAW;\n\tcase AFMT_A_LAW:\treturn SNDRV_PCM_FORMAT_A_LAW;\n\tcase AFMT_IMA_ADPCM:\treturn SNDRV_PCM_FORMAT_IMA_ADPCM;\n\tcase AFMT_U8:\t\treturn SNDRV_PCM_FORMAT_U8;\n\tcase AFMT_S16_LE:\treturn SNDRV_PCM_FORMAT_S16_LE;\n\tcase AFMT_S16_BE:\treturn SNDRV_PCM_FORMAT_S16_BE;\n\tcase AFMT_S8:\t\treturn SNDRV_PCM_FORMAT_S8;\n\tcase AFMT_U16_LE:\treturn SNDRV_PCM_FORMAT_U16_LE;\n\tcase AFMT_U16_BE:\treturn SNDRV_PCM_FORMAT_U16_BE;\n\tcase AFMT_MPEG:\t\treturn SNDRV_PCM_FORMAT_MPEG;\n\tcase AFMT_S32_LE:\treturn SNDRV_PCM_FORMAT_S32_LE;\n\tcase AFMT_S32_BE:\treturn SNDRV_PCM_FORMAT_S32_BE;\n\tcase AFMT_S24_LE:\treturn SNDRV_PCM_FORMAT_S24_LE;\n\tcase AFMT_S24_BE:\treturn SNDRV_PCM_FORMAT_S24_BE;\n\tcase AFMT_S24_PACKED:\treturn SNDRV_PCM_FORMAT_S24_3LE;\n\tcase AFMT_FLOAT:\treturn SNDRV_PCM_FORMAT_FLOAT;\n\tcase AFMT_SPDIF_RAW:\treturn SNDRV_PCM_FORMAT_IEC958_SUBFRAME;\n\tdefault:\t\treturn SNDRV_PCM_FORMAT_U8;\n\t}\n}\n\nstatic int snd_pcm_oss_format_to(snd_pcm_format_t format)\n{\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\treturn AFMT_MU_LAW;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\treturn AFMT_A_LAW;\n\tcase SNDRV_PCM_FORMAT_IMA_ADPCM:\treturn AFMT_IMA_ADPCM;\n\tcase SNDRV_PCM_FORMAT_U8:\t\treturn AFMT_U8;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\treturn AFMT_S16_LE;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\treturn AFMT_S16_BE;\n\tcase SNDRV_PCM_FORMAT_S8:\t\treturn AFMT_S8;\n\tcase SNDRV_PCM_FORMAT_U16_LE:\treturn AFMT_U16_LE;\n\tcase SNDRV_PCM_FORMAT_U16_BE:\treturn AFMT_U16_BE;\n\tcase SNDRV_PCM_FORMAT_MPEG:\t\treturn AFMT_MPEG;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\treturn AFMT_S32_LE;\n\tcase SNDRV_PCM_FORMAT_S32_BE:\treturn AFMT_S32_BE;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\treturn AFMT_S24_LE;\n\tcase SNDRV_PCM_FORMAT_S24_BE:\treturn AFMT_S24_BE;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\treturn AFMT_S24_PACKED;\n\tcase SNDRV_PCM_FORMAT_FLOAT:\treturn AFMT_FLOAT;\n\tcase SNDRV_PCM_FORMAT_IEC958_SUBFRAME: return AFMT_SPDIF_RAW;\n\tdefault:\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int snd_pcm_oss_period_size(struct snd_pcm_substream *substream, \n\t\t\t\t   struct snd_pcm_hw_params *oss_params,\n\t\t\t\t   struct snd_pcm_hw_params *slave_params)\n{\n\tssize_t s;\n\tssize_t oss_buffer_size;\n\tssize_t oss_period_size, oss_periods;\n\tssize_t min_period_size, max_period_size;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsize_t oss_frame_size;\n\n\toss_frame_size = snd_pcm_format_physical_width(params_format(oss_params)) *\n\t\t\t params_channels(oss_params) / 8;\n\n\toss_buffer_size = snd_pcm_hw_param_value_max(slave_params,\n\t\t\t\t\t\t     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t\t     NULL);\n\tif (oss_buffer_size <= 0)\n\t\treturn -EINVAL;\n\toss_buffer_size = snd_pcm_plug_client_size(substream,\n\t\t\t\t\t\t   oss_buffer_size * oss_frame_size);\n\tif (oss_buffer_size <= 0)\n\t\treturn -EINVAL;\n\toss_buffer_size = rounddown_pow_of_two(oss_buffer_size);\n\tif (atomic_read(&substream->mmap_count)) {\n\t\tif (oss_buffer_size > runtime->oss.mmap_bytes)\n\t\t\toss_buffer_size = runtime->oss.mmap_bytes;\n\t}\n\n\tif (substream->oss.setup.period_size > 16)\n\t\toss_period_size = substream->oss.setup.period_size;\n\telse if (runtime->oss.fragshift) {\n\t\toss_period_size = 1 << runtime->oss.fragshift;\n\t\tif (oss_period_size > oss_buffer_size / 2)\n\t\t\toss_period_size = oss_buffer_size / 2;\n\t} else {\n\t\tint sd;\n\t\tsize_t bytes_per_sec = params_rate(oss_params) * snd_pcm_format_physical_width(params_format(oss_params)) * params_channels(oss_params) / 8;\n\n\t\toss_period_size = oss_buffer_size;\n\t\tdo {\n\t\t\toss_period_size /= 2;\n\t\t} while (oss_period_size > bytes_per_sec);\n\t\tif (runtime->oss.subdivision == 0) {\n\t\t\tsd = 4;\n\t\t\tif (oss_period_size / sd > 4096)\n\t\t\t\tsd *= 2;\n\t\t\tif (oss_period_size / sd < 4096)\n\t\t\t\tsd = 1;\n\t\t} else\n\t\t\tsd = runtime->oss.subdivision;\n\t\toss_period_size /= sd;\n\t\tif (oss_period_size < 16)\n\t\t\toss_period_size = 16;\n\t}\n\n\tmin_period_size = snd_pcm_plug_client_size(substream,\n\t\t\t\t\t\t   snd_pcm_hw_param_value_min(slave_params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, NULL));\n\tif (min_period_size > 0) {\n\t\tmin_period_size *= oss_frame_size;\n\t\tmin_period_size = roundup_pow_of_two(min_period_size);\n\t\tif (oss_period_size < min_period_size)\n\t\t\toss_period_size = min_period_size;\n\t}\n\n\tmax_period_size = snd_pcm_plug_client_size(substream,\n\t\t\t\t\t\t   snd_pcm_hw_param_value_max(slave_params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, NULL));\n\tif (max_period_size > 0) {\n\t\tmax_period_size *= oss_frame_size;\n\t\tmax_period_size = rounddown_pow_of_two(max_period_size);\n\t\tif (oss_period_size > max_period_size)\n\t\t\toss_period_size = max_period_size;\n\t}\n\n\toss_periods = oss_buffer_size / oss_period_size;\n\n\tif (substream->oss.setup.periods > 1)\n\t\toss_periods = substream->oss.setup.periods;\n\n\ts = snd_pcm_hw_param_value_max(slave_params, SNDRV_PCM_HW_PARAM_PERIODS, NULL);\n\tif (s > 0 && runtime->oss.maxfrags && s > runtime->oss.maxfrags)\n\t\ts = runtime->oss.maxfrags;\n\tif (oss_periods > s)\n\t\toss_periods = s;\n\n\ts = snd_pcm_hw_param_value_min(slave_params, SNDRV_PCM_HW_PARAM_PERIODS, NULL);\n\tif (s < 2)\n\t\ts = 2;\n\tif (oss_periods < s)\n\t\toss_periods = s;\n\n\twhile (oss_period_size * oss_periods > oss_buffer_size)\n\t\toss_period_size /= 2;\n\n\tif (oss_period_size < 16)\n\t\treturn -EINVAL;\n\n\t \n\tif (oss_period_size > 1024 * 1024)\n\t\treturn -ENOMEM;\n\n\truntime->oss.period_bytes = oss_period_size;\n\truntime->oss.period_frames = 1;\n\truntime->oss.periods = oss_periods;\n\treturn 0;\n}\n\nstatic int choose_rate(struct snd_pcm_substream *substream,\n\t\t       struct snd_pcm_hw_params *params, unsigned int best_rate)\n{\n\tconst struct snd_interval *it;\n\tstruct snd_pcm_hw_params *save;\n\tunsigned int rate, prev;\n\n\tsave = kmalloc(sizeof(*save), GFP_KERNEL);\n\tif (save == NULL)\n\t\treturn -ENOMEM;\n\t*save = *params;\n\tit = hw_param_interval_c(save, SNDRV_PCM_HW_PARAM_RATE);\n\n\t \n\trate = best_rate;\n\tfor (;;) {\n\t\tif (it->max < rate || (it->max == rate && it->openmax))\n\t\t\tbreak;\n\t\tif (it->min < rate || (it->min == rate && !it->openmin)) {\n\t\t\tint ret;\n\t\t\tret = snd_pcm_hw_param_set(substream, params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t   rate, 0);\n\t\t\tif (ret == (int)rate) {\n\t\t\t\tkfree(save);\n\t\t\t\treturn rate;\n\t\t\t}\n\t\t\t*params = *save;\n\t\t}\n\t\tprev = rate;\n\t\trate += best_rate;\n\t\tif (rate <= prev)\n\t\t\tbreak;\n\t}\n\n\t \n\tkfree(save);\n\treturn snd_pcm_hw_param_near(substream, params, SNDRV_PCM_HW_PARAM_RATE, best_rate, NULL);\n}\n\n \nstatic int lock_params(struct snd_pcm_runtime *runtime)\n{\n\tif (mutex_lock_interruptible(&runtime->oss.params_lock))\n\t\treturn -ERESTARTSYS;\n\tif (atomic_read(&runtime->oss.rw_ref)) {\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_params(struct snd_pcm_runtime *runtime)\n{\n\tmutex_unlock(&runtime->oss.params_lock);\n}\n\nstatic void snd_pcm_oss_release_buffers(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tkvfree(runtime->oss.buffer);\n\truntime->oss.buffer = NULL;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tsnd_pcm_oss_plugin_clear(substream);\n#endif\n}\n\n \nstatic int snd_pcm_oss_change_params_locked(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hw_params *params, *sparams;\n\tstruct snd_pcm_sw_params *sw_params;\n\tssize_t oss_buffer_size, oss_period_size;\n\tsize_t oss_frame_size;\n\tint err;\n\tint direct;\n\tsnd_pcm_format_t format, sformat;\n\tint n;\n\tconst struct snd_mask *sformat_mask;\n\tstruct snd_mask mask;\n\n\tif (!runtime->oss.params)\n\t\treturn 0;\n\tsw_params = kzalloc(sizeof(*sw_params), GFP_KERNEL);\n\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\tsparams = kmalloc(sizeof(*sparams), GFP_KERNEL);\n\tif (!sw_params || !params || !sparams) {\n\t\terr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tif (atomic_read(&substream->mmap_count))\n\t\tdirect = 1;\n\telse\n\t\tdirect = substream->oss.setup.direct;\n\n\t_snd_pcm_hw_params_any(sparams);\n\t_snd_pcm_hw_param_setinteger(sparams, SNDRV_PCM_HW_PARAM_PERIODS);\n\t_snd_pcm_hw_param_min(sparams, SNDRV_PCM_HW_PARAM_PERIODS, 2, 0);\n\tsnd_mask_none(&mask);\n\tif (atomic_read(&substream->mmap_count))\n\t\tsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);\n\telse {\n\t\tsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_RW_INTERLEAVED);\n\t\tif (!direct)\n\t\t\tsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);\n\t}\n\terr = snd_pcm_hw_param_mask(substream, sparams, SNDRV_PCM_HW_PARAM_ACCESS, &mask);\n\tif (err < 0) {\n\t\tpcm_dbg(substream->pcm, \"No usable accesses\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\terr = choose_rate(substream, sparams, runtime->oss.rate);\n\tif (err < 0)\n\t\tgoto failure;\n\terr = snd_pcm_hw_param_near(substream, sparams,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t    runtime->oss.channels, NULL);\n\tif (err < 0)\n\t\tgoto failure;\n\n\tformat = snd_pcm_oss_format_from(runtime->oss.format);\n\n\tsformat_mask = hw_param_mask_c(sparams, SNDRV_PCM_HW_PARAM_FORMAT);\n\tif (direct)\n\t\tsformat = format;\n\telse\n\t\tsformat = snd_pcm_plug_slave_format(format, sformat_mask);\n\n\tif ((__force int)sformat < 0 ||\n\t    !snd_mask_test_format(sformat_mask, sformat)) {\n\t\tpcm_for_each_format(sformat) {\n\t\t\tif (snd_mask_test_format(sformat_mask, sformat) &&\n\t\t\t    snd_pcm_oss_format_to(sformat) >= 0)\n\t\t\t\tgoto format_found;\n\t\t}\n\t\tpcm_dbg(substream->pcm, \"Cannot find a format!!!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n format_found:\n\terr = _snd_pcm_hw_param_set(sparams, SNDRV_PCM_HW_PARAM_FORMAT, (__force int)sformat, 0);\n\tif (err < 0)\n\t\tgoto failure;\n\n\tif (direct) {\n\t\tmemcpy(params, sparams, sizeof(*params));\n\t} else {\n\t\t_snd_pcm_hw_params_any(params);\n\t\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,\n\t\t\t\t      (__force int)SNDRV_PCM_ACCESS_RW_INTERLEAVED, 0);\n\t\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t      (__force int)snd_pcm_oss_format_from(runtime->oss.format), 0);\n\t\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t      runtime->oss.channels, 0);\n\t\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      runtime->oss.rate, 0);\n\t\tpdprintf(\"client: access = %i, format = %i, channels = %i, rate = %i\\n\",\n\t\t\t params_access(params), params_format(params),\n\t\t\t params_channels(params), params_rate(params));\n\t}\n\tpdprintf(\"slave: access = %i, format = %i, channels = %i, rate = %i\\n\",\n\t\t params_access(sparams), params_format(sparams),\n\t\t params_channels(sparams), params_rate(sparams));\n\n\toss_frame_size = snd_pcm_format_physical_width(params_format(params)) *\n\t\t\t params_channels(params) / 8;\n\n\terr = snd_pcm_oss_period_size(substream, params, sparams);\n\tif (err < 0)\n\t\tgoto failure;\n\n\tn = snd_pcm_plug_slave_size(substream, runtime->oss.period_bytes / oss_frame_size);\n\terr = snd_pcm_hw_param_near(substream, sparams, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, n, NULL);\n\tif (err < 0)\n\t\tgoto failure;\n\n\terr = snd_pcm_hw_param_near(substream, sparams, SNDRV_PCM_HW_PARAM_PERIODS,\n\t\t\t\t     runtime->oss.periods, NULL);\n\tif (err < 0)\n\t\tgoto failure;\n\n\tsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\n\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_HW_PARAMS, sparams);\n\tif (err < 0) {\n\t\tpcm_dbg(substream->pcm, \"HW_PARAMS failed: %i\\n\", err);\n\t\tgoto failure;\n\t}\n\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tsnd_pcm_oss_plugin_clear(substream);\n\tif (!direct) {\n\t\t \n\t\terr = snd_pcm_plug_format_plugins(substream, params, sparams);\n\t\tif (err < 0) {\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"snd_pcm_plug_format_plugins failed: %i\\n\", err);\n\t\t\tgoto failure;\n\t\t}\n\t\tif (runtime->oss.plugin_first) {\n\t\t\tstruct snd_pcm_plugin *plugin;\n\t\t\terr = snd_pcm_plugin_build_io(substream, sparams, &plugin);\n\t\t\tif (err < 0) {\n\t\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\t\"snd_pcm_plugin_build_io failed: %i\\n\", err);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t\terr = snd_pcm_plugin_append(plugin);\n\t\t\t} else {\n\t\t\t\terr = snd_pcm_plugin_insert(plugin);\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto failure;\n\t\t}\n\t}\n#endif\n\n\tif (runtime->oss.trigger) {\n\t\tsw_params->start_threshold = 1;\n\t} else {\n\t\tsw_params->start_threshold = runtime->boundary;\n\t}\n\tif (atomic_read(&substream->mmap_count) ||\n\t    substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tsw_params->stop_threshold = runtime->boundary;\n\telse\n\t\tsw_params->stop_threshold = runtime->buffer_size;\n\tsw_params->tstamp_mode = SNDRV_PCM_TSTAMP_NONE;\n\tsw_params->period_step = 1;\n\tsw_params->avail_min = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t1 : runtime->period_size;\n\tif (atomic_read(&substream->mmap_count) ||\n\t    substream->oss.setup.nosilence) {\n\t\tsw_params->silence_threshold = 0;\n\t\tsw_params->silence_size = 0;\n\t} else {\n\t\tsnd_pcm_uframes_t frames;\n\t\tframes = runtime->period_size + 16;\n\t\tif (frames > runtime->buffer_size)\n\t\t\tframes = runtime->buffer_size;\n\t\tsw_params->silence_threshold = frames;\n\t\tsw_params->silence_size = frames;\n\t}\n\n\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_SW_PARAMS, sw_params);\n\tif (err < 0) {\n\t\tpcm_dbg(substream->pcm, \"SW_PARAMS failed: %i\\n\", err);\n\t\tgoto failure;\n\t}\n\n\truntime->oss.periods = params_periods(sparams);\n\toss_period_size = snd_pcm_plug_client_size(substream, params_period_size(sparams));\n\tif (oss_period_size < 0) {\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first) {\n\t\terr = snd_pcm_plug_alloc(substream, oss_period_size);\n\t\tif (err < 0)\n\t\t\tgoto failure;\n\t}\n#endif\n\toss_period_size = array_size(oss_period_size, oss_frame_size);\n\toss_buffer_size = array_size(oss_period_size, runtime->oss.periods);\n\tif (oss_buffer_size <= 0) {\n\t\terr = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\truntime->oss.period_bytes = oss_period_size;\n\truntime->oss.buffer_bytes = oss_buffer_size;\n\n\tpdprintf(\"oss: period bytes = %i, buffer bytes = %i\\n\",\n\t\t runtime->oss.period_bytes,\n\t\t runtime->oss.buffer_bytes);\n\tpdprintf(\"slave: period_size = %i, buffer_size = %i\\n\",\n\t\t params_period_size(sparams),\n\t\t params_buffer_size(sparams));\n\n\truntime->oss.format = snd_pcm_oss_format_to(params_format(params));\n\truntime->oss.channels = params_channels(params);\n\truntime->oss.rate = params_rate(params);\n\n\tkvfree(runtime->oss.buffer);\n\truntime->oss.buffer = kvzalloc(runtime->oss.period_bytes, GFP_KERNEL);\n\tif (!runtime->oss.buffer) {\n\t\terr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\truntime->oss.params = 0;\n\truntime->oss.prepare = 1;\n\truntime->oss.buffer_used = 0;\n\tif (runtime->dma_area)\n\t\tsnd_pcm_format_set_silence(runtime->format, runtime->dma_area, bytes_to_samples(runtime, runtime->dma_bytes));\n\n\truntime->oss.period_frames = snd_pcm_alsa_frames(substream, oss_period_size);\n\n\terr = 0;\nfailure:\n\tif (err)\n\t\tsnd_pcm_oss_release_buffers(substream);\n\tkfree(sw_params);\n\tkfree(params);\n\tkfree(sparams);\n\treturn err;\n}\n\n \nstatic int snd_pcm_oss_change_params(struct snd_pcm_substream *substream,\n\t\t\t\t     bool trylock)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tif (trylock) {\n\t\tif (!(mutex_trylock(&runtime->oss.params_lock)))\n\t\t\treturn -EAGAIN;\n\t} else if (mutex_lock_interruptible(&runtime->oss.params_lock))\n\t\treturn -ERESTARTSYS;\n\n\terr = snd_pcm_oss_change_params_locked(substream);\n\tmutex_unlock(&runtime->oss.params_lock);\n\treturn err;\n}\n\nstatic int snd_pcm_oss_get_active_substream(struct snd_pcm_oss_file *pcm_oss_file, struct snd_pcm_substream **r_substream)\n{\n\tint idx, err;\n\tstruct snd_pcm_substream *asubstream = NULL, *substream;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubstream = pcm_oss_file->streams[idx];\n\t\tif (substream == NULL)\n\t\t\tcontinue;\n\t\tif (asubstream == NULL)\n\t\t\tasubstream = substream;\n\t\tif (substream->runtime->oss.params) {\n\t\t\terr = snd_pcm_oss_change_params(substream, false);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (!asubstream)\n\t\treturn -EIO;\n\tif (r_substream)\n\t\t*r_substream = asubstream;\n\treturn 0;\n}\n\n \n \nstatic int snd_pcm_oss_prepare(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_PREPARE, NULL);\n\tif (err < 0) {\n\t\tpcm_dbg(substream->pcm,\n\t\t\t\"snd_pcm_oss_prepare: SNDRV_PCM_IOCTL_PREPARE failed\\n\");\n\t\treturn err;\n\t}\n\truntime->oss.prepare = 0;\n\truntime->oss.prev_hw_ptr_period = 0;\n\truntime->oss.period_ptr = 0;\n\truntime->oss.buffer_used = 0;\n\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint err;\n\n\truntime = substream->runtime;\n\tif (runtime->oss.params) {\n\t\terr = snd_pcm_oss_change_params(substream, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (runtime->oss.prepare) {\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = snd_pcm_oss_prepare(substream);\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_pcm_oss_make_ready_locked(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint err;\n\n\truntime = substream->runtime;\n\tif (runtime->oss.params) {\n\t\terr = snd_pcm_oss_change_params_locked(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (runtime->oss.prepare) {\n\t\terr = snd_pcm_oss_prepare(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_capture_position_fixup(struct snd_pcm_substream *substream, snd_pcm_sframes_t *delay)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_uframes_t frames;\n\tint err = 0;\n\n\twhile (1) {\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, delay);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\truntime = substream->runtime;\n\t\tif (*delay <= (snd_pcm_sframes_t)runtime->buffer_size)\n\t\t\tbreak;\n\t\t \n\t\t \n\t\tframes = (*delay - runtime->buffer_size) + runtime->period_size - 1;\n\t\tframes /= runtime->period_size;\n\t\tframes *= runtime->period_size;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_FORWARD, &frames);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nsnd_pcm_sframes_t snd_pcm_oss_write3(struct snd_pcm_substream *substream, const char *ptr, snd_pcm_uframes_t frames, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret;\n\twhile (1) {\n\t\tif (runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\t    runtime->state == SNDRV_PCM_STATE_SUSPENDED) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"pcm_oss: write: recovering from %s\\n\",\n\t\t\t\truntime->state == SNDRV_PCM_STATE_XRUN ?\n\t\t\t\t\"XRUN\" : \"SUSPEND\");\n#endif\n\t\t\tret = snd_pcm_oss_prepare(substream);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tret = __snd_pcm_lib_xfer(substream, (void *)ptr, true,\n\t\t\t\t\t frames, in_kernel);\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\tif (ret != -EPIPE && ret != -ESTRPIPE)\n\t\t\tbreak;\n\t\t \n\t\t \n\t\tif (runtime->state == SNDRV_PCM_STATE_PREPARED)\n\t\t\treturn -EAGAIN;\n\t}\n\treturn ret;\n}\n\nsnd_pcm_sframes_t snd_pcm_oss_read3(struct snd_pcm_substream *substream, char *ptr, snd_pcm_uframes_t frames, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t delay;\n\tint ret;\n\twhile (1) {\n\t\tif (runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\t    runtime->state == SNDRV_PCM_STATE_SUSPENDED) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"pcm_oss: read: recovering from %s\\n\",\n\t\t\t\truntime->state == SNDRV_PCM_STATE_XRUN ?\n\t\t\t\t\"XRUN\" : \"SUSPEND\");\n#endif\n\t\t\tret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\t\tret = snd_pcm_oss_prepare(substream);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = snd_pcm_oss_capture_position_fixup(substream, &delay);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tret = __snd_pcm_lib_xfer(substream, (void *)ptr, true,\n\t\t\t\t\t frames, in_kernel);\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\tif (ret == -EPIPE) {\n\t\t\tif (runtime->state == SNDRV_PCM_STATE_DRAINING) {\n\t\t\t\tret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != -ESTRPIPE)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\nsnd_pcm_sframes_t snd_pcm_oss_writev3(struct snd_pcm_substream *substream, void **bufs, snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret;\n\twhile (1) {\n\t\tif (runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\t    runtime->state == SNDRV_PCM_STATE_SUSPENDED) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"pcm_oss: writev: recovering from %s\\n\",\n\t\t\t\truntime->state == SNDRV_PCM_STATE_XRUN ?\n\t\t\t\t\"XRUN\" : \"SUSPEND\");\n#endif\n\t\t\tret = snd_pcm_oss_prepare(substream);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = snd_pcm_kernel_writev(substream, bufs, frames);\n\t\tif (ret != -EPIPE && ret != -ESTRPIPE)\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\tif (runtime->state == SNDRV_PCM_STATE_PREPARED)\n\t\t\treturn -EAGAIN;\n\t}\n\treturn ret;\n}\n\t\nsnd_pcm_sframes_t snd_pcm_oss_readv3(struct snd_pcm_substream *substream, void **bufs, snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret;\n\twhile (1) {\n\t\tif (runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\t    runtime->state == SNDRV_PCM_STATE_SUSPENDED) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"pcm_oss: readv: recovering from %s\\n\",\n\t\t\t\truntime->state == SNDRV_PCM_STATE_XRUN ?\n\t\t\t\t\"XRUN\" : \"SUSPEND\");\n#endif\n\t\t\tret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\t\tret = snd_pcm_oss_prepare(substream);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = snd_pcm_kernel_readv(substream, bufs, frames);\n\t\tif (ret != -EPIPE && ret != -ESTRPIPE)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n#endif  \n\nstatic ssize_t snd_pcm_oss_write2(struct snd_pcm_substream *substream, const char *buf, size_t bytes, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t frames, frames1;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first) {\n\t\tstruct snd_pcm_plugin_channel *channels;\n\t\tsize_t oss_frame_bytes = (runtime->oss.plugin_first->src_width * runtime->oss.plugin_first->src_format.channels) / 8;\n\t\tif (!in_kernel) {\n\t\t\tif (copy_from_user(runtime->oss.buffer, (const char __force __user *)buf, bytes))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = runtime->oss.buffer;\n\t\t}\n\t\tframes = bytes / oss_frame_bytes;\n\t\tframes1 = snd_pcm_plug_client_channels_buf(substream, (char *)buf, frames, &channels);\n\t\tif (frames1 < 0)\n\t\t\treturn frames1;\n\t\tframes1 = snd_pcm_plug_write_transfer(substream, channels, frames1);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames1 * oss_frame_bytes;\n\t} else\n#endif\n\t{\n\t\tframes = bytes_to_frames(runtime, bytes);\n\t\tframes1 = snd_pcm_oss_write3(substream, buf, frames, in_kernel);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames_to_bytes(runtime, frames1);\n\t}\n\treturn bytes;\n}\n\nstatic ssize_t snd_pcm_oss_write1(struct snd_pcm_substream *substream, const char __user *buf, size_t bytes)\n{\n\tsize_t xfer = 0;\n\tssize_t tmp = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (atomic_read(&substream->mmap_count))\n\t\treturn -ENXIO;\n\n\tatomic_inc(&runtime->oss.rw_ref);\n\twhile (bytes > 0) {\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n\t\t\ttmp = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\ttmp = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (tmp < 0)\n\t\t\tgoto err;\n\t\tif (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {\n\t\t\ttmp = bytes;\n\t\t\tif (tmp + runtime->oss.buffer_used > runtime->oss.period_bytes)\n\t\t\t\ttmp = runtime->oss.period_bytes - runtime->oss.buffer_used;\n\t\t\tif (tmp > 0) {\n\t\t\t\tif (copy_from_user(runtime->oss.buffer + runtime->oss.buffer_used, buf, tmp)) {\n\t\t\t\t\ttmp = -EFAULT;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\truntime->oss.buffer_used += tmp;\n\t\t\tbuf += tmp;\n\t\t\tbytes -= tmp;\n\t\t\txfer += tmp;\n\t\t\tif (substream->oss.setup.partialfrag ||\n\t\t\t    runtime->oss.buffer_used == runtime->oss.period_bytes) {\n\t\t\t\ttmp = snd_pcm_oss_write2(substream, runtime->oss.buffer + runtime->oss.period_ptr, \n\t\t\t\t\t\t\t runtime->oss.buffer_used - runtime->oss.period_ptr, 1);\n\t\t\t\tif (tmp <= 0)\n\t\t\t\t\tgoto err;\n\t\t\t\truntime->oss.bytes += tmp;\n\t\t\t\truntime->oss.period_ptr += tmp;\n\t\t\t\truntime->oss.period_ptr %= runtime->oss.period_bytes;\n\t\t\t\tif (runtime->oss.period_ptr == 0 ||\n\t\t\t\t    runtime->oss.period_ptr == runtime->oss.buffer_used)\n\t\t\t\t\truntime->oss.buffer_used = 0;\n\t\t\t\telse if ((substream->f_flags & O_NONBLOCK) != 0) {\n\t\t\t\t\ttmp = -EAGAIN;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = snd_pcm_oss_write2(substream,\n\t\t\t\t\t\t (const char __force *)buf,\n\t\t\t\t\t\t runtime->oss.period_bytes, 0);\n\t\t\tif (tmp <= 0)\n\t\t\t\tgoto err;\n\t\t\truntime->oss.bytes += tmp;\n\t\t\tbuf += tmp;\n\t\t\tbytes -= tmp;\n\t\t\txfer += tmp;\n\t\t\tif ((substream->f_flags & O_NONBLOCK) != 0 &&\n\t\t\t    tmp != runtime->oss.period_bytes)\n\t\t\t\ttmp = -EAGAIN;\n\t\t}\n err:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tif (tmp < 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\ttmp = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\ttmp = 0;\n\t}\n\tatomic_dec(&runtime->oss.rw_ref);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;\n}\n\nstatic ssize_t snd_pcm_oss_read2(struct snd_pcm_substream *substream, char *buf, size_t bytes, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t frames, frames1;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tchar __user *final_dst = (char __force __user *)buf;\n\tif (runtime->oss.plugin_first) {\n\t\tstruct snd_pcm_plugin_channel *channels;\n\t\tsize_t oss_frame_bytes = (runtime->oss.plugin_last->dst_width * runtime->oss.plugin_last->dst_format.channels) / 8;\n\t\tif (!in_kernel)\n\t\t\tbuf = runtime->oss.buffer;\n\t\tframes = bytes / oss_frame_bytes;\n\t\tframes1 = snd_pcm_plug_client_channels_buf(substream, buf, frames, &channels);\n\t\tif (frames1 < 0)\n\t\t\treturn frames1;\n\t\tframes1 = snd_pcm_plug_read_transfer(substream, channels, frames1);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames1 * oss_frame_bytes;\n\t\tif (!in_kernel && copy_to_user(final_dst, buf, bytes))\n\t\t\treturn -EFAULT;\n\t} else\n#endif\n\t{\n\t\tframes = bytes_to_frames(runtime, bytes);\n\t\tframes1 = snd_pcm_oss_read3(substream, buf, frames, in_kernel);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames_to_bytes(runtime, frames1);\n\t}\n\treturn bytes;\n}\n\nstatic ssize_t snd_pcm_oss_read1(struct snd_pcm_substream *substream, char __user *buf, size_t bytes)\n{\n\tsize_t xfer = 0;\n\tssize_t tmp = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (atomic_read(&substream->mmap_count))\n\t\treturn -ENXIO;\n\n\tatomic_inc(&runtime->oss.rw_ref);\n\twhile (bytes > 0) {\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n\t\t\ttmp = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\ttmp = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (tmp < 0)\n\t\t\tgoto err;\n\t\tif (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {\n\t\t\tif (runtime->oss.buffer_used == 0) {\n\t\t\t\ttmp = snd_pcm_oss_read2(substream, runtime->oss.buffer, runtime->oss.period_bytes, 1);\n\t\t\t\tif (tmp <= 0)\n\t\t\t\t\tgoto err;\n\t\t\t\truntime->oss.bytes += tmp;\n\t\t\t\truntime->oss.period_ptr = tmp;\n\t\t\t\truntime->oss.buffer_used = tmp;\n\t\t\t}\n\t\t\ttmp = bytes;\n\t\t\tif ((size_t) tmp > runtime->oss.buffer_used)\n\t\t\t\ttmp = runtime->oss.buffer_used;\n\t\t\tif (copy_to_user(buf, runtime->oss.buffer + (runtime->oss.period_ptr - runtime->oss.buffer_used), tmp)) {\n\t\t\t\ttmp = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbuf += tmp;\n\t\t\tbytes -= tmp;\n\t\t\txfer += tmp;\n\t\t\truntime->oss.buffer_used -= tmp;\n\t\t} else {\n\t\t\ttmp = snd_pcm_oss_read2(substream, (char __force *)buf,\n\t\t\t\t\t\truntime->oss.period_bytes, 0);\n\t\t\tif (tmp <= 0)\n\t\t\t\tgoto err;\n\t\t\truntime->oss.bytes += tmp;\n\t\t\tbuf += tmp;\n\t\t\tbytes -= tmp;\n\t\t\txfer += tmp;\n\t\t}\n err:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tif (tmp < 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\ttmp = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\ttmp = 0;\n\t}\n\tatomic_dec(&runtime->oss.rw_ref);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;\n}\n\nstatic int snd_pcm_oss_reset(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) { \n\t\tsubstream = pcm_oss_file->streams[i];\n\t\tif (!substream)\n\t\t\tcontinue;\n\t\truntime = substream->runtime;\n\t\tsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.prepare = 1;\n\t\truntime->oss.buffer_used = 0;\n\t\truntime->oss.prev_hw_ptr_period = 0;\n\t\truntime->oss.period_ptr = 0;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_post(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream != NULL) {\n\t\terr = snd_pcm_oss_make_ready(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_START, NULL);\n\t}\n\t \n\t \n\treturn 0;\n}\n\nstatic int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tssize_t result = 0;\n\tsnd_pcm_state_t state;\n\tlong res;\n\twait_queue_entry_t wait;\n\n\truntime = substream->runtime;\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&runtime->sleep, &wait);\n#ifdef OSS_DEBUG\n\tpcm_dbg(substream->pcm, \"sync1: size = %li\\n\", size);\n#endif\n\twhile (1) {\n\t\tresult = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);\n\t\tif (result > 0) {\n\t\t\truntime->oss.buffer_used = 0;\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (result != 0 && result != -EAGAIN)\n\t\t\tbreak;\n\t\tresult = 0;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tstate = runtime->state;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\tif (state != SNDRV_PCM_STATE_RUNNING) {\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tres = schedule_timeout(10 * HZ);\n\t\tif (signal_pending(current)) {\n\t\t\tresult = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (res == 0) {\n\t\t\tpcm_err(substream->pcm,\n\t\t\t\t\"OSS sync error - DMA timeout\\n\");\n\t\t\tresult = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&runtime->sleep, &wait);\n\treturn result;\n}\n\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tint err = 0;\n\tunsigned int saved_f_flags;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_format_t format;\n\tunsigned long width;\n\tsize_t size;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream != NULL) {\n\t\truntime = substream->runtime;\n\t\tif (atomic_read(&substream->mmap_count))\n\t\t\tgoto __direct;\n\t\tatomic_inc(&runtime->oss.rw_ref);\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n\t\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\terr = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tformat = snd_pcm_oss_format_from(runtime->oss.format);\n\t\twidth = snd_pcm_format_physical_width(format);\n\t\tif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n#endif\n\t\t\tsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer + runtime->oss.buffer_used,\n\t\t\t\t\t\t   size);\n\t\t\terr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t} else if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n#endif\n\t\t\tsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer,\n\t\t\t\t\t\t   size * 8 / width);\n\t\t\terr = snd_pcm_oss_sync1(substream, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t \n\t\tsize = runtime->control->appl_ptr % runtime->period_size;\n\t\tif (size > 0) {\n\t\t\tsize = runtime->period_size - size;\n\t\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n\t\t\t\tsnd_pcm_lib_write(substream, NULL, size);\n\t\t\telse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\t\t\tsnd_pcm_lib_writev(substream, NULL, size);\n\t\t}\nunlock:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t      __direct:\n\t\tsaved_f_flags = substream->f_flags;\n\t\tsubstream->f_flags &= ~O_NONBLOCK;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n\t\tsubstream->f_flags = saved_f_flags;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (substream != NULL) {\n\t\terr = snd_pcm_oss_make_ready(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime = substream->runtime;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.buffer_used = 0;\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_set_rate(struct snd_pcm_oss_file *pcm_oss_file, int rate)\n{\n\tint idx;\n\n\tfor (idx = 1; idx >= 0; --idx) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\tstruct snd_pcm_runtime *runtime;\n\t\tint err;\n\n\t\tif (substream == NULL)\n\t\t\tcontinue;\n\t\truntime = substream->runtime;\n\t\tif (rate < 1000)\n\t\t\trate = 1000;\n\t\telse if (rate > 192000)\n\t\t\trate = 192000;\n\t\terr = lock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (runtime->oss.rate != rate) {\n\t\t\truntime->oss.params = 1;\n\t\t\truntime->oss.rate = rate;\n\t\t}\n\t\tunlock_params(runtime);\n\t}\n\treturn snd_pcm_oss_get_rate(pcm_oss_file);\n}\n\nstatic int snd_pcm_oss_get_rate(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\t\n\terr = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn substream->runtime->oss.rate;\n}\n\nstatic int snd_pcm_oss_set_channels(struct snd_pcm_oss_file *pcm_oss_file, unsigned int channels)\n{\n\tint idx;\n\tif (channels < 1)\n\t\tchannels = 1;\n\tif (channels > 128)\n\t\treturn -EINVAL;\n\tfor (idx = 1; idx >= 0; --idx) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\tstruct snd_pcm_runtime *runtime;\n\t\tint err;\n\n\t\tif (substream == NULL)\n\t\t\tcontinue;\n\t\truntime = substream->runtime;\n\t\terr = lock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (runtime->oss.channels != channels) {\n\t\t\truntime->oss.params = 1;\n\t\t\truntime->oss.channels = channels;\n\t\t}\n\t\tunlock_params(runtime);\n\t}\n\treturn snd_pcm_oss_get_channels(pcm_oss_file);\n}\n\nstatic int snd_pcm_oss_get_channels(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\t\n\terr = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn substream->runtime->oss.channels;\n}\n\nstatic int snd_pcm_oss_get_block_size(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\t\n\terr = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn substream->runtime->oss.period_bytes;\n}\n\nstatic int snd_pcm_oss_get_formats(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\tint direct;\n\tstruct snd_pcm_hw_params *params;\n\tunsigned int formats = 0;\n\tconst struct snd_mask *format_mask;\n\tint fmt;\n\n\terr = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\tif (atomic_read(&substream->mmap_count))\n\t\tdirect = 1;\n\telse\n\t\tdirect = substream->oss.setup.direct;\n\tif (!direct)\n\t\treturn AFMT_MU_LAW | AFMT_U8 |\n\t\t       AFMT_S16_LE | AFMT_S16_BE |\n\t\t       AFMT_S8 | AFMT_U16_LE |\n\t\t       AFMT_U16_BE |\n\t\t\tAFMT_S32_LE | AFMT_S32_BE |\n\t\t\tAFMT_S24_LE | AFMT_S24_BE |\n\t\t\tAFMT_S24_PACKED;\n\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\t_snd_pcm_hw_params_any(params);\n\terr = snd_pcm_hw_refine(substream, params);\n\tif (err < 0)\n\t\tgoto error;\n\tformat_mask = hw_param_mask_c(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tfor (fmt = 0; fmt < 32; ++fmt) {\n\t\tif (snd_mask_test(format_mask, fmt)) {\n\t\t\tint f = snd_pcm_oss_format_to((__force snd_pcm_format_t)fmt);\n\t\t\tif (f >= 0)\n\t\t\t\tformats |= f;\n\t\t}\n\t}\n\n error:\n\tkfree(params);\n\treturn err < 0 ? err : formats;\n}\n\nstatic int snd_pcm_oss_set_format(struct snd_pcm_oss_file *pcm_oss_file, int format)\n{\n\tint formats, idx;\n\tint err;\n\t\n\tif (format != AFMT_QUERY) {\n\t\tformats = snd_pcm_oss_get_formats(pcm_oss_file);\n\t\tif (formats < 0)\n\t\t\treturn formats;\n\t\tif (!(formats & format))\n\t\t\tformat = AFMT_U8;\n\t\tfor (idx = 1; idx >= 0; --idx) {\n\t\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\t\tstruct snd_pcm_runtime *runtime;\n\t\t\tif (substream == NULL)\n\t\t\t\tcontinue;\n\t\t\truntime = substream->runtime;\n\t\t\terr = lock_params(runtime);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (runtime->oss.format != format) {\n\t\t\t\truntime->oss.params = 1;\n\t\t\t\truntime->oss.format = format;\n\t\t\t}\n\t\t\tunlock_params(runtime);\n\t\t}\n\t}\n\treturn snd_pcm_oss_get_format(pcm_oss_file);\n}\n\nstatic int snd_pcm_oss_get_format(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\t\n\terr = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn substream->runtime->oss.format;\n}\n\nstatic int snd_pcm_oss_set_subdivide1(struct snd_pcm_substream *substream, int subdivide)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\truntime = substream->runtime;\n\tif (subdivide == 0) {\n\t\tsubdivide = runtime->oss.subdivision;\n\t\tif (subdivide == 0)\n\t\t\tsubdivide = 1;\n\t\treturn subdivide;\n\t}\n\tif (runtime->oss.subdivision || runtime->oss.fragshift)\n\t\treturn -EINVAL;\n\tif (subdivide != 1 && subdivide != 2 && subdivide != 4 &&\n\t    subdivide != 8 && subdivide != 16)\n\t\treturn -EINVAL;\n\truntime->oss.subdivision = subdivide;\n\truntime->oss.params = 1;\n\treturn subdivide;\n}\n\nstatic int snd_pcm_oss_set_subdivide(struct snd_pcm_oss_file *pcm_oss_file, int subdivide)\n{\n\tint err = -EINVAL, idx;\n\n\tfor (idx = 1; idx >= 0; --idx) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\tstruct snd_pcm_runtime *runtime;\n\n\t\tif (substream == NULL)\n\t\t\tcontinue;\n\t\truntime = substream->runtime;\n\t\terr = lock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_oss_set_subdivide1(substream, subdivide);\n\t\tunlock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic int snd_pcm_oss_set_fragment1(struct snd_pcm_substream *substream, unsigned int val)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint fragshift;\n\n\truntime = substream->runtime;\n\tif (runtime->oss.subdivision || runtime->oss.fragshift)\n\t\treturn -EINVAL;\n\tfragshift = val & 0xffff;\n\tif (fragshift >= 25)  \n\t\treturn -EINVAL;\n\truntime->oss.fragshift = fragshift;\n\truntime->oss.maxfrags = (val >> 16) & 0xffff;\n\tif (runtime->oss.fragshift < 4)\t\t \n\t\truntime->oss.fragshift = 4;\n\tif (runtime->oss.maxfrags < 2)\n\t\truntime->oss.maxfrags = 2;\n\truntime->oss.params = 1;\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_set_fragment(struct snd_pcm_oss_file *pcm_oss_file, unsigned int val)\n{\n\tint err = -EINVAL, idx;\n\n\tfor (idx = 1; idx >= 0; --idx) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\tstruct snd_pcm_runtime *runtime;\n\n\t\tif (substream == NULL)\n\t\t\tcontinue;\n\t\truntime = substream->runtime;\n\t\terr = lock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_oss_set_fragment1(substream, val);\n\t\tunlock_params(runtime);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic int snd_pcm_oss_nonblock(struct file * file)\n{\n\tspin_lock(&file->f_lock);\n\tfile->f_flags |= O_NONBLOCK;\n\tspin_unlock(&file->f_lock);\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_get_caps1(struct snd_pcm_substream *substream, int res)\n{\n\n\tif (substream == NULL) {\n\t\tres &= ~DSP_CAP_DUPLEX;\n\t\treturn res;\n\t}\n#ifdef DSP_CAP_MULTI\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tif (substream->pstr->substream_count > 1)\n\t\t\tres |= DSP_CAP_MULTI;\n#endif\n\t \n\t \n#if defined(DSP_CAP_REALTIME) && 0\n\t{\n\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\tif (runtime->info & (SNDRV_PCM_INFO_BLOCK_TRANSFER|SNDRV_PCM_INFO_BATCH))\n\t\t\tres &= ~DSP_CAP_REALTIME;\n\t}\n#endif\n\treturn res;\n}\n\nstatic int snd_pcm_oss_get_caps(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tint result, idx;\n\t\n\tresult = DSP_CAP_TRIGGER | DSP_CAP_MMAP\t| DSP_CAP_DUPLEX | DSP_CAP_REALTIME;\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\n\t\tresult = snd_pcm_oss_get_caps1(substream, result);\n\t}\n\tresult |= 0x0001;\t \n\treturn result;\n}\n\nstatic void snd_pcm_oss_simulate_fill(struct snd_pcm_substream *substream,\n\t\t\t\t      snd_pcm_uframes_t hw_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t appl_ptr;\n\tappl_ptr = hw_ptr + runtime->buffer_size;\n\tappl_ptr %= runtime->boundary;\n\truntime->control->appl_ptr = appl_ptr;\n}\n\nstatic int snd_pcm_oss_set_trigger(struct snd_pcm_oss_file *pcm_oss_file, int trigger)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\n\tint err, cmd;\n\n#ifdef OSS_DEBUG\n\tpr_debug(\"pcm_oss: trigger = 0x%x\\n\", trigger);\n#endif\n\t\n\tpsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tcsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\n\tif (psubstream) {\n\t\terr = snd_pcm_oss_make_ready(psubstream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (csubstream) {\n\t\terr = snd_pcm_oss_make_ready(csubstream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n      \tif (psubstream) {\n      \t\truntime = psubstream->runtime;\n\t\tcmd = 0;\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock))\n\t\t\treturn -ERESTARTSYS;\n\t\tif (trigger & PCM_ENABLE_OUTPUT) {\n\t\t\tif (runtime->oss.trigger)\n\t\t\t\tgoto _skip1;\n\t\t\tif (atomic_read(&psubstream->mmap_count))\n\t\t\t\tsnd_pcm_oss_simulate_fill(psubstream,\n\t\t\t\t\t\tget_hw_ptr_period(runtime));\n\t\t\truntime->oss.trigger = 1;\n\t\t\truntime->start_threshold = 1;\n\t\t\tcmd = SNDRV_PCM_IOCTL_START;\n\t\t} else {\n\t\t\tif (!runtime->oss.trigger)\n\t\t\t\tgoto _skip1;\n\t\t\truntime->oss.trigger = 0;\n\t\t\truntime->start_threshold = runtime->boundary;\n\t\t\tcmd = SNDRV_PCM_IOCTL_DROP;\n\t\t\truntime->oss.prepare = 1;\n\t\t}\n _skip1:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tif (cmd) {\n\t\t\terr = snd_pcm_kernel_ioctl(psubstream, cmd, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (csubstream) {\n      \t\truntime = csubstream->runtime;\n\t\tcmd = 0;\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock))\n\t\t\treturn -ERESTARTSYS;\n\t\tif (trigger & PCM_ENABLE_INPUT) {\n\t\t\tif (runtime->oss.trigger)\n\t\t\t\tgoto _skip2;\n\t\t\truntime->oss.trigger = 1;\n\t\t\truntime->start_threshold = 1;\n\t\t\tcmd = SNDRV_PCM_IOCTL_START;\n\t\t} else {\n\t\t\tif (!runtime->oss.trigger)\n\t\t\t\tgoto _skip2;\n\t\t\truntime->oss.trigger = 0;\n\t\t\truntime->start_threshold = runtime->boundary;\n\t\t\tcmd = SNDRV_PCM_IOCTL_DROP;\n\t\t\truntime->oss.prepare = 1;\n\t\t}\n _skip2:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tif (cmd) {\n\t\t\terr = snd_pcm_kernel_ioctl(csubstream, cmd, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_get_trigger(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\n\tint result = 0;\n\n\tpsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tcsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (psubstream && psubstream->runtime && psubstream->runtime->oss.trigger)\n\t\tresult |= PCM_ENABLE_OUTPUT;\n\tif (csubstream && csubstream->runtime && csubstream->runtime->oss.trigger)\n\t\tresult |= PCM_ENABLE_INPUT;\n\treturn result;\n}\n\nstatic int snd_pcm_oss_get_odelay(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t delay;\n\tint err;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream == NULL)\n\t\treturn -EINVAL;\n\terr = snd_pcm_oss_make_ready(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->oss.params || runtime->oss.prepare)\n\t\treturn 0;\n\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &delay);\n\tif (err == -EPIPE)\n\t\tdelay = 0;\t \n\telse if (err < 0)\n\t\treturn err;\n\treturn snd_pcm_oss_bytes(substream, delay);\n}\n\nstatic int snd_pcm_oss_get_ptr(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct count_info __user * _info)\n{\t\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t delay;\n\tint fixup;\n\tstruct count_info info;\n\tint err;\n\n\tif (_info == NULL)\n\t\treturn -EFAULT;\n\tsubstream = pcm_oss_file->streams[stream];\n\tif (substream == NULL)\n\t\treturn -EINVAL;\n\terr = snd_pcm_oss_make_ready(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->oss.params || runtime->oss.prepare) {\n\t\tmemset(&info, 0, sizeof(info));\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &delay);\n\t\tif (err == -EPIPE || err == -ESTRPIPE || (! err && delay < 0)) {\n\t\t\terr = 0;\n\t\t\tdelay = 0;\n\t\t\tfixup = 0;\n\t\t} else {\n\t\t\tfixup = runtime->oss.buffer_used;\n\t\t}\n\t} else {\n\t\terr = snd_pcm_oss_capture_position_fixup(substream, &delay);\n\t\tfixup = -runtime->oss.buffer_used;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\tinfo.ptr = snd_pcm_oss_bytes(substream, runtime->status->hw_ptr % runtime->buffer_size);\n\tif (atomic_read(&substream->mmap_count)) {\n\t\tsnd_pcm_sframes_t n;\n\t\tdelay = get_hw_ptr_period(runtime);\n\t\tn = delay - runtime->oss.prev_hw_ptr_period;\n\t\tif (n < 0)\n\t\t\tn += runtime->boundary;\n\t\tinfo.blocks = n / runtime->period_size;\n\t\truntime->oss.prev_hw_ptr_period = delay;\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsnd_pcm_oss_simulate_fill(substream, delay);\n\t\tinfo.bytes = snd_pcm_oss_bytes(substream, runtime->status->hw_ptr) & INT_MAX;\n\t} else {\n\t\tdelay = snd_pcm_oss_bytes(substream, delay);\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tif (substream->oss.setup.buggyptr)\n\t\t\t\tinfo.blocks = (runtime->oss.buffer_bytes - delay - fixup) / runtime->oss.period_bytes;\n\t\t\telse\n\t\t\t\tinfo.blocks = (delay + fixup) / runtime->oss.period_bytes;\n\t\t\tinfo.bytes = (runtime->oss.bytes - delay) & INT_MAX;\n\t\t} else {\n\t\t\tdelay += fixup;\n\t\t\tinfo.blocks = delay / runtime->oss.period_bytes;\n\t\t\tinfo.bytes = (runtime->oss.bytes + delay) & INT_MAX;\n\t\t}\n\t}\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_get_space(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct audio_buf_info __user *_info)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t avail;\n\tint fixup;\n\tstruct audio_buf_info info;\n\tint err;\n\n\tif (_info == NULL)\n\t\treturn -EFAULT;\n\tsubstream = pcm_oss_file->streams[stream];\n\tif (substream == NULL)\n\t\treturn -EINVAL;\n\truntime = substream->runtime;\n\n\tif (runtime->oss.params) {\n\t\terr = snd_pcm_oss_change_params(substream, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tinfo.fragsize = runtime->oss.period_bytes;\n\tinfo.fragstotal = runtime->periods;\n\tif (runtime->oss.prepare) {\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tinfo.bytes = runtime->oss.period_bytes * runtime->oss.periods;\n\t\t\tinfo.fragments = runtime->oss.periods;\n\t\t} else {\n\t\t\tinfo.bytes = 0;\n\t\t\tinfo.fragments = 0;\n\t\t}\n\t} else {\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &avail);\n\t\t\tif (err == -EPIPE || err == -ESTRPIPE || (! err && avail < 0)) {\n\t\t\t\tavail = runtime->buffer_size;\n\t\t\t\terr = 0;\n\t\t\t\tfixup = 0;\n\t\t\t} else {\n\t\t\t\tavail = runtime->buffer_size - avail;\n\t\t\t\tfixup = -runtime->oss.buffer_used;\n\t\t\t}\n\t\t} else {\n\t\t\terr = snd_pcm_oss_capture_position_fixup(substream, &avail);\n\t\t\tfixup = runtime->oss.buffer_used;\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tinfo.bytes = snd_pcm_oss_bytes(substream, avail) + fixup;\n\t\tinfo.fragments = info.bytes / runtime->oss.period_bytes;\n\t}\n\n#ifdef OSS_DEBUG\n\tpcm_dbg(substream->pcm,\n\t\t\"pcm_oss: space: bytes = %i, fragments = %i, fragstotal = %i, fragsize = %i\\n\",\n\t\tinfo.bytes, info.fragments, info.fragstotal, info.fragsize);\n#endif\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_get_mapbuf(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct buffmem_desc __user * _info)\n{\n\t\n\t\n\treturn -EINVAL;\n}\n\nstatic const char *strip_task_path(const char *path)\n{\n\tconst char *ptr, *ptrl = NULL;\n\tfor (ptr = path; *ptr; ptr++) {\n\t\tif (*ptr == '/')\n\t\t\tptrl = ptr + 1;\n\t}\n\treturn ptrl;\n}\n\nstatic void snd_pcm_oss_look_for_setup(struct snd_pcm *pcm, int stream,\n\t\t\t\t      const char *task_name,\n\t\t\t\t      struct snd_pcm_oss_setup *rsetup)\n{\n\tstruct snd_pcm_oss_setup *setup;\n\n\tmutex_lock(&pcm->streams[stream].oss.setup_mutex);\n\tdo {\n\t\tfor (setup = pcm->streams[stream].oss.setup_list; setup;\n\t\t     setup = setup->next) {\n\t\t\tif (!strcmp(setup->task_name, task_name))\n\t\t\t\tgoto out;\n\t\t}\n\t} while ((task_name = strip_task_path(task_name)) != NULL);\n out:\n\tif (setup)\n\t\t*rsetup = *setup;\n\tmutex_unlock(&pcm->streams[stream].oss.setup_mutex);\n}\n\nstatic void snd_pcm_oss_release_substream(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_oss_release_buffers(substream);\n\tsubstream->oss.oss = 0;\n}\n\nstatic void snd_pcm_oss_init_substream(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_oss_setup *setup,\n\t\t\t\t       int minor)\n{\n\tstruct snd_pcm_runtime *runtime;\n\n\tsubstream->oss.oss = 1;\n\tsubstream->oss.setup = *setup;\n\tif (setup->nonblock)\n\t\tsubstream->f_flags |= O_NONBLOCK;\n\telse if (setup->block)\n\t\tsubstream->f_flags &= ~O_NONBLOCK;\n\truntime = substream->runtime;\n\truntime->oss.params = 1;\n\truntime->oss.trigger = 1;\n\truntime->oss.rate = 8000;\n\tmutex_init(&runtime->oss.params_lock);\n\tswitch (SNDRV_MINOR_OSS_DEVICE(minor)) {\n\tcase SNDRV_MINOR_OSS_PCM_8:\n\t\truntime->oss.format = AFMT_U8;\n\t\tbreak;\n\tcase SNDRV_MINOR_OSS_PCM_16:\n\t\truntime->oss.format = AFMT_S16_LE;\n\t\tbreak;\n\tdefault:\n\t\truntime->oss.format = AFMT_MU_LAW;\n\t}\n\truntime->oss.channels = 1;\n\truntime->oss.fragshift = 0;\n\truntime->oss.maxfrags = 0;\n\truntime->oss.subdivision = 0;\n\tsubstream->pcm_release = snd_pcm_oss_release_substream;\n\tatomic_set(&runtime->oss.rw_ref, 0);\n}\n\nstatic int snd_pcm_oss_release_file(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tint cidx;\n\tif (!pcm_oss_file)\n\t\treturn 0;\n\tfor (cidx = 0; cidx < 2; ++cidx) {\n\t\tstruct snd_pcm_substream *substream = pcm_oss_file->streams[cidx];\n\t\tif (substream)\n\t\t\tsnd_pcm_release_substream(substream);\n\t}\n\tkfree(pcm_oss_file);\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_open_file(struct file *file,\n\t\t\t\t struct snd_pcm *pcm,\n\t\t\t\t struct snd_pcm_oss_file **rpcm_oss_file,\n\t\t\t\t int minor,\n\t\t\t\t struct snd_pcm_oss_setup *setup)\n{\n\tint idx, err;\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tstruct snd_pcm_substream *substream;\n\tfmode_t f_mode = file->f_mode;\n\n\tif (rpcm_oss_file)\n\t\t*rpcm_oss_file = NULL;\n\n\tpcm_oss_file = kzalloc(sizeof(*pcm_oss_file), GFP_KERNEL);\n\tif (pcm_oss_file == NULL)\n\t\treturn -ENOMEM;\n\n\tif ((f_mode & (FMODE_WRITE|FMODE_READ)) == (FMODE_WRITE|FMODE_READ) &&\n\t    (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX))\n\t\tf_mode = FMODE_WRITE;\n\n\tfile->f_flags &= ~O_APPEND;\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tif (setup[idx].disable)\n\t\t\tcontinue;\n\t\tif (! pcm->streams[idx].substream_count)\n\t\t\tcontinue;  \n\t\tif (idx == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tif (! (f_mode & FMODE_WRITE))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (! (f_mode & FMODE_READ))\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = snd_pcm_open_substream(pcm, idx, file, &substream);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_oss_release_file(pcm_oss_file);\n\t\t\treturn err;\n\t\t}\n\n\t\tpcm_oss_file->streams[idx] = substream;\n\t\tsnd_pcm_oss_init_substream(substream, &setup[idx], minor);\n\t}\n\t\n\tif (!pcm_oss_file->streams[0] && !pcm_oss_file->streams[1]) {\n\t\tsnd_pcm_oss_release_file(pcm_oss_file);\n\t\treturn -EINVAL;\n\t}\n\n\tfile->private_data = pcm_oss_file;\n\tif (rpcm_oss_file)\n\t\t*rpcm_oss_file = pcm_oss_file;\n\treturn 0;\n}\n\n\nstatic int snd_task_name(struct task_struct *task, char *name, size_t size)\n{\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!task || !name || size < 2))\n\t\treturn -EINVAL;\n\tfor (idx = 0; idx < sizeof(task->comm) && idx + 1 < size; idx++)\n\t\tname[idx] = task->comm[idx];\n\tname[idx] = '\\0';\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tchar task_name[32];\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tstruct snd_pcm_oss_setup setup[2];\n\tint nonblock;\n\twait_queue_entry_t wait;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm = snd_lookup_oss_minor_data(iminor(inode),\n\t\t\t\t\tSNDRV_OSS_DEVICE_TYPE_PCM);\n\tif (pcm == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(pcm->card, file);\n\tif (err < 0)\n\t\tgoto __error1;\n\tif (!try_module_get(pcm->card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tif (snd_task_name(current, task_name, sizeof(task_name)) < 0) {\n\t\terr = -EFAULT;\n\t\tgoto __error;\n\t}\n\tmemset(setup, 0, sizeof(setup));\n\tif (file->f_mode & FMODE_WRITE)\n\t\tsnd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t   task_name, &setup[0]);\n\tif (file->f_mode & FMODE_READ)\n\t\tsnd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t   task_name, &setup[1]);\n\n\tnonblock = !!(file->f_flags & O_NONBLOCK);\n\tif (!nonblock)\n\t\tnonblock = nonblock_open;\n\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&pcm->open_wait, &wait);\n\tmutex_lock(&pcm->open_mutex);\n\twhile (1) {\n\t\terr = snd_pcm_oss_open_file(file, pcm, &pcm_oss_file,\n\t\t\t\t\t    iminor(inode), setup);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif (err == -EAGAIN) {\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tmutex_unlock(&pcm->open_mutex);\n\t\tschedule();\n\t\tmutex_lock(&pcm->open_mutex);\n\t\tif (pcm->card->shutdown) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&pcm->open_wait, &wait);\n\tmutex_unlock(&pcm->open_mutex);\n\tif (err < 0)\n\t\tgoto __error;\n\tsnd_card_unref(pcm->card);\n\treturn err;\n\n      __error:\n     \tmodule_put(pcm->card->module);\n      __error2:\n      \tsnd_card_file_remove(pcm->card, file);\n      __error1:\n\tif (pcm)\n\t\tsnd_card_unref(pcm->card);\n\treturn err;\n}\n\nstatic int snd_pcm_oss_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\n\tpcm_oss_file = file->private_data;\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream == NULL)\n\t\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (snd_BUG_ON(!substream))\n\t\treturn -ENXIO;\n\tpcm = substream->pcm;\n\tif (!pcm->card->shutdown)\n\t\tsnd_pcm_oss_sync(pcm_oss_file);\n\tmutex_lock(&pcm->open_mutex);\n\tsnd_pcm_oss_release_file(pcm_oss_file);\n\tmutex_unlock(&pcm->open_mutex);\n\twake_up(&pcm->open_wait);\n\tmodule_put(pcm->card->module);\n\tsnd_card_file_remove(pcm->card, file);\n\treturn 0;\n}\n\nstatic long snd_pcm_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tint __user *p = (int __user *)arg;\n\tint res;\n\n\tpcm_oss_file = file->private_data;\n\tif (cmd == OSS_GETVERSION)\n\t\treturn put_user(SNDRV_OSS_VERSION, p);\n\tif (cmd == OSS_ALSAEMULVER)\n\t\treturn put_user(1, p);\n#if IS_REACHABLE(CONFIG_SND_MIXER_OSS)\n\tif (((cmd >> 8) & 0xff) == 'M')\t{\t \n\t\tstruct snd_pcm_substream *substream;\n\t\tint idx;\n\t\tfor (idx = 0; idx < 2; ++idx) {\n\t\t\tsubstream = pcm_oss_file->streams[idx];\n\t\t\tif (substream != NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (snd_BUG_ON(idx >= 2))\n\t\t\treturn -ENXIO;\n\t\treturn snd_mixer_oss_ioctl_card(substream->pcm->card, cmd, arg);\n\t}\n#endif\n\tif (((cmd >> 8) & 0xff) != 'P')\n\t\treturn -EINVAL;\n#ifdef OSS_DEBUG\n\tpr_debug(\"pcm_oss: ioctl = 0x%x\\n\", cmd);\n#endif\n\tswitch (cmd) {\n\tcase SNDCTL_DSP_RESET:\n\t\treturn snd_pcm_oss_reset(pcm_oss_file);\n\tcase SNDCTL_DSP_SYNC:\n\t\treturn snd_pcm_oss_sync(pcm_oss_file);\n\tcase SNDCTL_DSP_SPEED:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\tres = snd_pcm_oss_set_rate(pcm_oss_file, res);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SOUND_PCM_READ_RATE:\n\t\tres = snd_pcm_oss_get_rate(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_STEREO:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\tres = res > 0 ? 2 : 1;\n\t\tres = snd_pcm_oss_set_channels(pcm_oss_file, res);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(--res, p);\n\tcase SNDCTL_DSP_GETBLKSIZE:\n\t\tres = snd_pcm_oss_get_block_size(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_SETFMT:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\tres = snd_pcm_oss_set_format(pcm_oss_file, res);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SOUND_PCM_READ_BITS:\n\t\tres = snd_pcm_oss_get_format(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_CHANNELS:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\tres = snd_pcm_oss_set_channels(pcm_oss_file, res);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SOUND_PCM_READ_CHANNELS:\n\t\tres = snd_pcm_oss_get_channels(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SOUND_PCM_WRITE_FILTER:\n\tcase SOUND_PCM_READ_FILTER:\n\t\treturn -EIO;\n\tcase SNDCTL_DSP_POST:\n\t\treturn snd_pcm_oss_post(pcm_oss_file);\n\tcase SNDCTL_DSP_SUBDIVIDE:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\tres = snd_pcm_oss_set_subdivide(pcm_oss_file, res);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_SETFRAGMENT:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\treturn snd_pcm_oss_set_fragment(pcm_oss_file, res);\n\tcase SNDCTL_DSP_GETFMTS:\n\t\tres = snd_pcm_oss_get_formats(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_GETOSPACE:\n\tcase SNDCTL_DSP_GETISPACE:\n\t\treturn snd_pcm_oss_get_space(pcm_oss_file,\n\t\t\tcmd == SNDCTL_DSP_GETISPACE ?\n\t\t\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t(struct audio_buf_info __user *) arg);\n\tcase SNDCTL_DSP_NONBLOCK:\n\t\treturn snd_pcm_oss_nonblock(file);\n\tcase SNDCTL_DSP_GETCAPS:\n\t\tres = snd_pcm_oss_get_caps(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_GETTRIGGER:\n\t\tres = snd_pcm_oss_get_trigger(pcm_oss_file);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_SETTRIGGER:\n\t\tif (get_user(res, p))\n\t\t\treturn -EFAULT;\n\t\treturn snd_pcm_oss_set_trigger(pcm_oss_file, res);\n\tcase SNDCTL_DSP_GETIPTR:\n\tcase SNDCTL_DSP_GETOPTR:\n\t\treturn snd_pcm_oss_get_ptr(pcm_oss_file,\n\t\t\tcmd == SNDCTL_DSP_GETIPTR ?\n\t\t\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t(struct count_info __user *) arg);\n\tcase SNDCTL_DSP_MAPINBUF:\n\tcase SNDCTL_DSP_MAPOUTBUF:\n\t\treturn snd_pcm_oss_get_mapbuf(pcm_oss_file,\n\t\t\tcmd == SNDCTL_DSP_MAPINBUF ?\n\t\t\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t(struct buffmem_desc __user *) arg);\n\tcase SNDCTL_DSP_SETSYNCRO:\n\t\t \n\t\treturn 0;\n\tcase SNDCTL_DSP_SETDUPLEX:\n\t\tif (snd_pcm_oss_get_caps(pcm_oss_file) & DSP_CAP_DUPLEX)\n\t\t\treturn 0;\n\t\treturn -EIO;\n\tcase SNDCTL_DSP_GETODELAY:\n\t\tres = snd_pcm_oss_get_odelay(pcm_oss_file);\n\t\tif (res < 0) {\n\t\t\t \n\t\t\tput_user(0, p);\n\t\t\treturn res;\n\t\t}\n\t\treturn put_user(res, p);\n\tcase SNDCTL_DSP_PROFILE:\n\t\treturn 0;\t \n\tdefault:\n\t\tpr_debug(\"pcm_oss: unknown command = 0x%x\\n\", cmd);\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_COMPAT\n \nstatic long snd_pcm_oss_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t     unsigned long arg)\n{\n\t \n\treturn snd_pcm_oss_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define snd_pcm_oss_ioctl_compat\tNULL\n#endif\n\nstatic ssize_t snd_pcm_oss_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tstruct snd_pcm_substream *substream;\n\n\tpcm_oss_file = file->private_data;\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (substream == NULL)\n\t\treturn -ENXIO;\n\tsubstream->f_flags = file->f_flags & O_NONBLOCK;\n#ifndef OSS_DEBUG\n\treturn snd_pcm_oss_read1(substream, buf, count);\n#else\n\t{\n\t\tssize_t res = snd_pcm_oss_read1(substream, buf, count);\n\t\tpcm_dbg(substream->pcm,\n\t\t\t\"pcm_oss: read %li bytes (returned %li bytes)\\n\",\n\t\t\t(long)count, (long)res);\n\t\treturn res;\n\t}\n#endif\n}\n\nstatic ssize_t snd_pcm_oss_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tstruct snd_pcm_substream *substream;\n\tlong result;\n\n\tpcm_oss_file = file->private_data;\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream == NULL)\n\t\treturn -ENXIO;\n\tsubstream->f_flags = file->f_flags & O_NONBLOCK;\n\tresult = snd_pcm_oss_write1(substream, buf, count);\n#ifdef OSS_DEBUG\n\tpcm_dbg(substream->pcm, \"pcm_oss: write %li bytes (wrote %li bytes)\\n\",\n\t       (long)count, (long)result);\n#endif\n\treturn result;\n}\n\nstatic int snd_pcm_oss_playback_ready(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (atomic_read(&substream->mmap_count))\n\t\treturn runtime->oss.prev_hw_ptr_period !=\n\t\t\t\t\t\tget_hw_ptr_period(runtime);\n\telse\n\t\treturn snd_pcm_playback_avail(runtime) >=\n\t\t\t\t\t\truntime->oss.period_frames;\n}\n\nstatic int snd_pcm_oss_capture_ready(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (atomic_read(&substream->mmap_count))\n\t\treturn runtime->oss.prev_hw_ptr_period !=\n\t\t\t\t\t\tget_hw_ptr_period(runtime);\n\telse\n\t\treturn snd_pcm_capture_avail(runtime) >=\n\t\t\t\t\t\truntime->oss.period_frames;\n}\n\nstatic __poll_t snd_pcm_oss_poll(struct file *file, poll_table * wait)\n{\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\t__poll_t mask;\n\tstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\n\t\n\tpcm_oss_file = file->private_data;\n\n\tpsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tcsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\n\tmask = 0;\n\tif (psubstream != NULL) {\n\t\tstruct snd_pcm_runtime *runtime = psubstream->runtime;\n\t\tpoll_wait(file, &runtime->sleep, wait);\n\t\tsnd_pcm_stream_lock_irq(psubstream);\n\t\tif (runtime->state != SNDRV_PCM_STATE_DRAINING &&\n\t\t    (runtime->state != SNDRV_PCM_STATE_RUNNING ||\n\t\t     snd_pcm_oss_playback_ready(psubstream)))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\tsnd_pcm_stream_unlock_irq(psubstream);\n\t}\n\tif (csubstream != NULL) {\n\t\tstruct snd_pcm_runtime *runtime = csubstream->runtime;\n\t\tsnd_pcm_state_t ostate;\n\t\tpoll_wait(file, &runtime->sleep, wait);\n\t\tsnd_pcm_stream_lock_irq(csubstream);\n\t\tostate = runtime->state;\n\t\tif (ostate != SNDRV_PCM_STATE_RUNNING ||\n\t\t    snd_pcm_oss_capture_ready(csubstream))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\tsnd_pcm_stream_unlock_irq(csubstream);\n\t\tif (ostate != SNDRV_PCM_STATE_RUNNING && runtime->oss.trigger) {\n\t\t\tstruct snd_pcm_oss_file ofile;\n\t\t\tmemset(&ofile, 0, sizeof(ofile));\n\t\t\tofile.streams[SNDRV_PCM_STREAM_CAPTURE] = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\t\t\truntime->oss.trigger = 0;\n\t\t\tsnd_pcm_oss_set_trigger(&ofile, PCM_ENABLE_INPUT);\n\t\t}\n\t}\n\n\treturn mask;\n}\n\nstatic int snd_pcm_oss_mmap(struct file *file, struct vm_area_struct *area)\n{\n\tstruct snd_pcm_oss_file *pcm_oss_file;\n\tstruct snd_pcm_substream *substream = NULL;\n\tstruct snd_pcm_runtime *runtime;\n\tint err;\n\n#ifdef OSS_DEBUG\n\tpr_debug(\"pcm_oss: mmap begin\\n\");\n#endif\n\tpcm_oss_file = file->private_data;\n\tswitch ((area->vm_flags & (VM_READ | VM_WRITE))) {\n\tcase VM_READ | VM_WRITE:\n\t\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tif (substream)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase VM_READ:\n\t\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\t\tbreak;\n\tcase VM_WRITE:\n\t\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tvm_flags_set(area, VM_READ);\n\tif (substream == NULL)\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (!(runtime->info & SNDRV_PCM_INFO_MMAP_VALID))\n\t\treturn -EIO;\n\tif (runtime->info & SNDRV_PCM_INFO_INTERLEAVED)\n\t\truntime->access = SNDRV_PCM_ACCESS_MMAP_INTERLEAVED;\n\telse\n\t\treturn -EIO;\n\t\n\tif (runtime->oss.params) {\n\t\t \n\t\terr = snd_pcm_oss_change_params(substream, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first != NULL)\n\t\treturn -EIO;\n#endif\n\n\tif (area->vm_pgoff != 0)\n\t\treturn -EINVAL;\n\n\terr = snd_pcm_mmap_data(substream, file, area);\n\tif (err < 0)\n\t\treturn err;\n\truntime->oss.mmap_bytes = area->vm_end - area->vm_start;\n\truntime->silence_threshold = 0;\n\truntime->silence_size = 0;\n#ifdef OSS_DEBUG\n\tpr_debug(\"pcm_oss: mmap ok, bytes = 0x%x\\n\",\n\t       runtime->oss.mmap_bytes);\n#endif\n\t \n\truntime->stop_threshold = runtime->boundary;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_VERBOSE_PROCFS\n \n\nstatic void snd_pcm_oss_proc_read(struct snd_info_entry *entry,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_str *pstr = entry->private_data;\n\tstruct snd_pcm_oss_setup *setup = pstr->oss.setup_list;\n\tmutex_lock(&pstr->oss.setup_mutex);\n\twhile (setup) {\n\t\tsnd_iprintf(buffer, \"%s %u %u%s%s%s%s%s%s\\n\",\n\t\t\t    setup->task_name,\n\t\t\t    setup->periods,\n\t\t\t    setup->period_size,\n\t\t\t    setup->disable ? \" disable\" : \"\",\n\t\t\t    setup->direct ? \" direct\" : \"\",\n\t\t\t    setup->block ? \" block\" : \"\",\n\t\t\t    setup->nonblock ? \" non-block\" : \"\",\n\t\t\t    setup->partialfrag ? \" partial-frag\" : \"\",\n\t\t\t    setup->nosilence ? \" no-silence\" : \"\");\n\t\tsetup = setup->next;\n\t}\n\tmutex_unlock(&pstr->oss.setup_mutex);\n}\n\nstatic void snd_pcm_oss_proc_free_setup_list(struct snd_pcm_str * pstr)\n{\n\tstruct snd_pcm_oss_setup *setup, *setupn;\n\n\tfor (setup = pstr->oss.setup_list, pstr->oss.setup_list = NULL;\n\t     setup; setup = setupn) {\n\t\tsetupn = setup->next;\n\t\tkfree(setup->task_name);\n\t\tkfree(setup);\n\t}\n\tpstr->oss.setup_list = NULL;\n}\n\nstatic void snd_pcm_oss_proc_write(struct snd_info_entry *entry,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcm_str *pstr = entry->private_data;\n\tchar line[128], str[32], task_name[32];\n\tconst char *ptr;\n\tint idx1;\n\tstruct snd_pcm_oss_setup *setup, *setup1, template;\n\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tmutex_lock(&pstr->oss.setup_mutex);\n\t\tmemset(&template, 0, sizeof(template));\n\t\tptr = snd_info_get_str(task_name, line, sizeof(task_name));\n\t\tif (!strcmp(task_name, \"clear\") || !strcmp(task_name, \"erase\")) {\n\t\t\tsnd_pcm_oss_proc_free_setup_list(pstr);\n\t\t\tmutex_unlock(&pstr->oss.setup_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (setup = pstr->oss.setup_list; setup; setup = setup->next) {\n\t\t\tif (!strcmp(setup->task_name, task_name)) {\n\t\t\t\ttemplate = *setup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tptr = snd_info_get_str(str, ptr, sizeof(str));\n\t\ttemplate.periods = simple_strtoul(str, NULL, 10);\n\t\tptr = snd_info_get_str(str, ptr, sizeof(str));\n\t\ttemplate.period_size = simple_strtoul(str, NULL, 10);\n\t\tfor (idx1 = 31; idx1 >= 0; idx1--)\n\t\t\tif (template.period_size & (1 << idx1))\n\t\t\t\tbreak;\n\t\tfor (idx1--; idx1 >= 0; idx1--)\n\t\t\ttemplate.period_size &= ~(1 << idx1);\n\t\tdo {\n\t\t\tptr = snd_info_get_str(str, ptr, sizeof(str));\n\t\t\tif (!strcmp(str, \"disable\")) {\n\t\t\t\ttemplate.disable = 1;\n\t\t\t} else if (!strcmp(str, \"direct\")) {\n\t\t\t\ttemplate.direct = 1;\n\t\t\t} else if (!strcmp(str, \"block\")) {\n\t\t\t\ttemplate.block = 1;\n\t\t\t} else if (!strcmp(str, \"non-block\")) {\n\t\t\t\ttemplate.nonblock = 1;\n\t\t\t} else if (!strcmp(str, \"partial-frag\")) {\n\t\t\t\ttemplate.partialfrag = 1;\n\t\t\t} else if (!strcmp(str, \"no-silence\")) {\n\t\t\t\ttemplate.nosilence = 1;\n\t\t\t} else if (!strcmp(str, \"buggy-ptr\")) {\n\t\t\t\ttemplate.buggyptr = 1;\n\t\t\t}\n\t\t} while (*str);\n\t\tif (setup == NULL) {\n\t\t\tsetup = kmalloc(sizeof(*setup), GFP_KERNEL);\n\t\t\tif (! setup) {\n\t\t\t\tbuffer->error = -ENOMEM;\n\t\t\t\tmutex_unlock(&pstr->oss.setup_mutex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pstr->oss.setup_list == NULL)\n\t\t\t\tpstr->oss.setup_list = setup;\n\t\t\telse {\n\t\t\t\tfor (setup1 = pstr->oss.setup_list;\n\t\t\t\t     setup1->next; setup1 = setup1->next);\n\t\t\t\tsetup1->next = setup;\n\t\t\t}\n\t\t\ttemplate.task_name = kstrdup(task_name, GFP_KERNEL);\n\t\t\tif (! template.task_name) {\n\t\t\t\tkfree(setup);\n\t\t\t\tbuffer->error = -ENOMEM;\n\t\t\t\tmutex_unlock(&pstr->oss.setup_mutex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t*setup = template;\n\t\tmutex_unlock(&pstr->oss.setup_mutex);\n\t}\n}\n\nstatic void snd_pcm_oss_proc_init(struct snd_pcm *pcm)\n{\n\tint stream;\n\tfor (stream = 0; stream < 2; ++stream) {\n\t\tstruct snd_info_entry *entry;\n\t\tstruct snd_pcm_str *pstr = &pcm->streams[stream];\n\t\tif (pstr->substream_count == 0)\n\t\t\tcontinue;\n\t\tentry = snd_info_create_card_entry(pcm->card, \"oss\", pstr->proc_root);\n\t\tif (entry) {\n\t\t\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\t\t\tentry->mode = S_IFREG | 0644;\n\t\t\tentry->c.text.read = snd_pcm_oss_proc_read;\n\t\t\tentry->c.text.write = snd_pcm_oss_proc_write;\n\t\t\tentry->private_data = pstr;\n\t\t\tif (snd_info_register(entry) < 0) {\n\t\t\t\tsnd_info_free_entry(entry);\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t\tpstr->oss.proc_entry = entry;\n\t}\n}\n\nstatic void snd_pcm_oss_proc_done(struct snd_pcm *pcm)\n{\n\tint stream;\n\tfor (stream = 0; stream < 2; ++stream) {\n\t\tstruct snd_pcm_str *pstr = &pcm->streams[stream];\n\t\tsnd_info_free_entry(pstr->oss.proc_entry);\n\t\tpstr->oss.proc_entry = NULL;\n\t\tsnd_pcm_oss_proc_free_setup_list(pstr);\n\t}\n}\n#else  \nstatic inline void snd_pcm_oss_proc_init(struct snd_pcm *pcm)\n{\n}\nstatic inline void snd_pcm_oss_proc_done(struct snd_pcm *pcm)\n{\n}\n#endif  \n\n \n\nstatic const struct file_operations snd_pcm_oss_f_reg =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_pcm_oss_read,\n\t.write =\tsnd_pcm_oss_write,\n\t.open =\t\tsnd_pcm_oss_open,\n\t.release =\tsnd_pcm_oss_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_pcm_oss_poll,\n\t.unlocked_ioctl =\tsnd_pcm_oss_ioctl,\n\t.compat_ioctl =\tsnd_pcm_oss_ioctl_compat,\n\t.mmap =\t\tsnd_pcm_oss_mmap,\n};\n\nstatic void register_oss_dsp(struct snd_pcm *pcm, int index)\n{\n\tif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\n\t\t\t\t    pcm->card, index, &snd_pcm_oss_f_reg,\n\t\t\t\t    pcm) < 0) {\n\t\tpcm_err(pcm, \"unable to register OSS PCM device %i:%i\\n\",\n\t\t\t   pcm->card->number, pcm->device);\n\t}\n}\n\nstatic int snd_pcm_oss_register_minor(struct snd_pcm *pcm)\n{\n\tpcm->oss.reg = 0;\n\tif (dsp_map[pcm->card->number] == (int)pcm->device) {\n\t\tchar name[128];\n\t\tint duplex;\n\t\tregister_oss_dsp(pcm, 0);\n\t\tduplex = (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count > 0 && \n\t\t\t      pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count && \n\t\t\t      !(pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX));\n\t\tsprintf(name, \"%s%s\", pcm->name, duplex ? \" (DUPLEX)\" : \"\");\n#ifdef SNDRV_OSS_INFO_DEV_AUDIO\n\t\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_AUDIO,\n\t\t\t\t      pcm->card->number,\n\t\t\t\t      name);\n#endif\n\t\tpcm->oss.reg++;\n\t\tpcm->oss.reg_mask |= 1;\n\t}\n\tif (adsp_map[pcm->card->number] == (int)pcm->device) {\n\t\tregister_oss_dsp(pcm, 1);\n\t\tpcm->oss.reg++;\n\t\tpcm->oss.reg_mask |= 2;\n\t}\n\n\tif (pcm->oss.reg)\n\t\tsnd_pcm_oss_proc_init(pcm);\n\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_disconnect_minor(struct snd_pcm *pcm)\n{\n\tif (pcm->oss.reg) {\n\t\tif (pcm->oss.reg_mask & 1) {\n\t\t\tpcm->oss.reg_mask &= ~1;\n\t\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\n\t\t\t\t\t\t  pcm->card, 0);\n\t\t}\n\t\tif (pcm->oss.reg_mask & 2) {\n\t\t\tpcm->oss.reg_mask &= ~2;\n\t\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\n\t\t\t\t\t\t  pcm->card, 1);\n\t\t}\n\t\tif (dsp_map[pcm->card->number] == (int)pcm->device) {\n#ifdef SNDRV_OSS_INFO_DEV_AUDIO\n\t\t\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_AUDIO, pcm->card->number);\n#endif\n\t\t}\n\t\tpcm->oss.reg = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_oss_unregister_minor(struct snd_pcm *pcm)\n{\n\tsnd_pcm_oss_disconnect_minor(pcm);\n\tsnd_pcm_oss_proc_done(pcm);\n\treturn 0;\n}\n\nstatic struct snd_pcm_notify snd_pcm_oss_notify =\n{\n\t.n_register =\tsnd_pcm_oss_register_minor,\n\t.n_disconnect = snd_pcm_oss_disconnect_minor,\n\t.n_unregister =\tsnd_pcm_oss_unregister_minor,\n};\n\nstatic int __init alsa_pcm_oss_init(void)\n{\n\tint i;\n\tint err;\n\n\t \n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (dsp_map[i] < 0 || dsp_map[i] >= SNDRV_PCM_DEVICES) {\n\t\t\tpr_err(\"ALSA: pcm_oss: invalid dsp_map[%d] = %d\\n\",\n\t\t\t\t   i, dsp_map[i]);\n\t\t\tdsp_map[i] = 0;\n\t\t}\n\t\tif (adsp_map[i] < 0 || adsp_map[i] >= SNDRV_PCM_DEVICES) {\n\t\t\tpr_err(\"ALSA: pcm_oss: invalid adsp_map[%d] = %d\\n\",\n\t\t\t\t   i, adsp_map[i]);\n\t\t\tadsp_map[i] = 1;\n\t\t}\n\t}\n\terr = snd_pcm_notify(&snd_pcm_oss_notify, 0);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void __exit alsa_pcm_oss_exit(void)\n{\n\tsnd_pcm_notify(&snd_pcm_oss_notify, 1);\n}\n\nmodule_init(alsa_pcm_oss_init)\nmodule_exit(alsa_pcm_oss_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}