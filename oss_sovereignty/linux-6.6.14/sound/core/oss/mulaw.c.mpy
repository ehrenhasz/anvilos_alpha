{
  "module_name": "mulaw.c",
  "hash_id": "1b4a90f77e22f59aa35d0f03dd50b89ff6a4b540b1316fe03176a21ca875ede6",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/oss/mulaw.c",
  "human_readable_source": " \n  \n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"pcm_plugin.h\"\n\n#define\tSIGN_BIT\t(0x80)\t\t \n#define\tQUANT_MASK\t(0xf)\t\t \n#define\tNSEGS\t\t(8)\t\t \n#define\tSEG_SHIFT\t(4)\t\t \n#define\tSEG_MASK\t(0x70)\t\t \n\nstatic inline int val_seg(int val)\n{\n\tint r = 0;\n\tval >>= 7;\n\tif (val & 0xf0) {\n\t\tval >>= 4;\n\t\tr += 4;\n\t}\n\tif (val & 0x0c) {\n\t\tval >>= 2;\n\t\tr += 2;\n\t}\n\tif (val & 0x02)\n\t\tr += 1;\n\treturn r;\n}\n\n#define\tBIAS\t\t(0x84)\t\t \n\n \nstatic unsigned char linear2ulaw(int pcm_val)\t \n{\n\tint mask;\n\tint seg;\n\tunsigned char uval;\n\n\t \n\tif (pcm_val < 0) {\n\t\tpcm_val = BIAS - pcm_val;\n\t\tmask = 0x7F;\n\t} else {\n\t\tpcm_val += BIAS;\n\t\tmask = 0xFF;\n\t}\n\tif (pcm_val > 0x7FFF)\n\t\tpcm_val = 0x7FFF;\n\n\t \n\tseg = val_seg(pcm_val);\n\n\t \n\tuval = (seg << 4) | ((pcm_val >> (seg + 3)) & 0xF);\n\treturn uval ^ mask;\n}\n\n \nstatic int ulaw2linear(unsigned char u_val)\n{\n\tint t;\n\n\t \n\tu_val = ~u_val;\n\n\t \n\tt = ((u_val & QUANT_MASK) << 3) + BIAS;\n\tt <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;\n\n\treturn ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));\n}\n\n \n\ntypedef void (*mulaw_f)(struct snd_pcm_plugin *plugin,\n\t\t\tconst struct snd_pcm_plugin_channel *src_channels,\n\t\t\tstruct snd_pcm_plugin_channel *dst_channels,\n\t\t\tsnd_pcm_uframes_t frames);\n\nstruct mulaw_priv {\n\tmulaw_f func;\n\tint cvt_endian;\t\t\t \n\tunsigned int native_ofs;\t \n\tunsigned int copy_ofs;\t\t \n\tunsigned int native_bytes;\t \n\tunsigned int copy_bytes;\t \n\tu16 flip;  \n};\n\nstatic inline void cvt_s16_to_native(struct mulaw_priv *data,\n\t\t\t\t     unsigned char *dst, u16 sample)\n{\n\tsample ^= data->flip;\n\tif (data->cvt_endian)\n\t\tsample = swab16(sample);\n\tif (data->native_bytes > data->copy_bytes)\n\t\tmemset(dst, 0, data->native_bytes);\n\tmemcpy(dst + data->native_ofs, (char *)&sample + data->copy_ofs,\n\t       data->copy_bytes);\n}\n\nstatic void mulaw_decode(struct snd_pcm_plugin *plugin,\n\t\t\tconst struct snd_pcm_plugin_channel *src_channels,\n\t\t\tstruct snd_pcm_plugin_channel *dst_channels,\n\t\t\tsnd_pcm_uframes_t frames)\n{\n\tstruct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;\n\tint channel;\n\tint nchannels = plugin->src_format.channels;\n\tfor (channel = 0; channel < nchannels; ++channel) {\n\t\tchar *src;\n\t\tchar *dst;\n\t\tint src_step, dst_step;\n\t\tsnd_pcm_uframes_t frames1;\n\t\tif (!src_channels[channel].enabled) {\n\t\t\tif (dst_channels[channel].wanted)\n\t\t\t\tsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\n\t\t\tdst_channels[channel].enabled = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdst_channels[channel].enabled = 1;\n\t\tsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\n\t\tdst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\n\t\tsrc_step = src_channels[channel].area.step / 8;\n\t\tdst_step = dst_channels[channel].area.step / 8;\n\t\tframes1 = frames;\n\t\twhile (frames1-- > 0) {\n\t\t\tsigned short sample = ulaw2linear(*src);\n\t\t\tcvt_s16_to_native(data, dst, sample);\n\t\t\tsrc += src_step;\n\t\t\tdst += dst_step;\n\t\t}\n\t}\n}\n\nstatic inline signed short cvt_native_to_s16(struct mulaw_priv *data,\n\t\t\t\t\t     unsigned char *src)\n{\n\tu16 sample = 0;\n\tmemcpy((char *)&sample + data->copy_ofs, src + data->native_ofs,\n\t       data->copy_bytes);\n\tif (data->cvt_endian)\n\t\tsample = swab16(sample);\n\tsample ^= data->flip;\n\treturn (signed short)sample;\n}\n\nstatic void mulaw_encode(struct snd_pcm_plugin *plugin,\n\t\t\tconst struct snd_pcm_plugin_channel *src_channels,\n\t\t\tstruct snd_pcm_plugin_channel *dst_channels,\n\t\t\tsnd_pcm_uframes_t frames)\n{\n\tstruct mulaw_priv *data = (struct mulaw_priv *)plugin->extra_data;\n\tint channel;\n\tint nchannels = plugin->src_format.channels;\n\tfor (channel = 0; channel < nchannels; ++channel) {\n\t\tchar *src;\n\t\tchar *dst;\n\t\tint src_step, dst_step;\n\t\tsnd_pcm_uframes_t frames1;\n\t\tif (!src_channels[channel].enabled) {\n\t\t\tif (dst_channels[channel].wanted)\n\t\t\t\tsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\n\t\t\tdst_channels[channel].enabled = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdst_channels[channel].enabled = 1;\n\t\tsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\n\t\tdst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\n\t\tsrc_step = src_channels[channel].area.step / 8;\n\t\tdst_step = dst_channels[channel].area.step / 8;\n\t\tframes1 = frames;\n\t\twhile (frames1-- > 0) {\n\t\t\tsigned short sample = cvt_native_to_s16(data, src);\n\t\t\t*dst = linear2ulaw(sample);\n\t\t\tsrc += src_step;\n\t\t\tdst += dst_step;\n\t\t}\n\t}\n}\n\nstatic snd_pcm_sframes_t mulaw_transfer(struct snd_pcm_plugin *plugin,\n\t\t\t      const struct snd_pcm_plugin_channel *src_channels,\n\t\t\t      struct snd_pcm_plugin_channel *dst_channels,\n\t\t\t      snd_pcm_uframes_t frames)\n{\n\tstruct mulaw_priv *data;\n\n\tif (snd_BUG_ON(!plugin || !src_channels || !dst_channels))\n\t\treturn -ENXIO;\n\tif (frames == 0)\n\t\treturn 0;\n#ifdef CONFIG_SND_DEBUG\n\t{\n\t\tunsigned int channel;\n\t\tfor (channel = 0; channel < plugin->src_format.channels; channel++) {\n\t\t\tif (snd_BUG_ON(src_channels[channel].area.first % 8 ||\n\t\t\t\t       src_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (snd_BUG_ON(dst_channels[channel].area.first % 8 ||\n\t\t\t\t       dst_channels[channel].area.step % 8))\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n#endif\n\tif (frames > dst_channels[0].frames)\n\t\tframes = dst_channels[0].frames;\n\tdata = (struct mulaw_priv *)plugin->extra_data;\n\tdata->func(plugin, src_channels, dst_channels, frames);\n\treturn frames;\n}\n\nstatic void init_data(struct mulaw_priv *data, snd_pcm_format_t format)\n{\n#ifdef SNDRV_LITTLE_ENDIAN\n\tdata->cvt_endian = snd_pcm_format_big_endian(format) > 0;\n#else\n\tdata->cvt_endian = snd_pcm_format_little_endian(format) > 0;\n#endif\n\tif (!snd_pcm_format_signed(format))\n\t\tdata->flip = 0x8000;\n\tdata->native_bytes = snd_pcm_format_physical_width(format) / 8;\n\tdata->copy_bytes = data->native_bytes < 2 ? 1 : 2;\n\tif (snd_pcm_format_little_endian(format)) {\n\t\tdata->native_ofs = data->native_bytes - data->copy_bytes;\n\t\tdata->copy_ofs = 2 - data->copy_bytes;\n\t} else {\n\t\t \n\t\tdata->native_ofs = data->native_bytes -\n\t\t\tsnd_pcm_format_width(format) / 8;\n\t}\n}\n\nint snd_pcm_plugin_build_mulaw(struct snd_pcm_substream *plug,\n\t\t\t       struct snd_pcm_plugin_format *src_format,\n\t\t\t       struct snd_pcm_plugin_format *dst_format,\n\t\t\t       struct snd_pcm_plugin **r_plugin)\n{\n\tint err;\n\tstruct mulaw_priv *data;\n\tstruct snd_pcm_plugin *plugin;\n\tstruct snd_pcm_plugin_format *format;\n\tmulaw_f func;\n\n\tif (snd_BUG_ON(!r_plugin))\n\t\treturn -ENXIO;\n\t*r_plugin = NULL;\n\n\tif (snd_BUG_ON(src_format->rate != dst_format->rate))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(src_format->channels != dst_format->channels))\n\t\treturn -ENXIO;\n\n\tif (dst_format->format == SNDRV_PCM_FORMAT_MU_LAW) {\n\t\tformat = src_format;\n\t\tfunc = mulaw_encode;\n\t}\n\telse if (src_format->format == SNDRV_PCM_FORMAT_MU_LAW) {\n\t\tformat = dst_format;\n\t\tfunc = mulaw_decode;\n\t}\n\telse {\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\tif (!snd_pcm_format_linear(format->format))\n\t\treturn -EINVAL;\n\n\terr = snd_pcm_plugin_build(plug, \"Mu-Law<->linear conversion\",\n\t\t\t\t   src_format, dst_format,\n\t\t\t\t   sizeof(struct mulaw_priv), &plugin);\n\tif (err < 0)\n\t\treturn err;\n\tdata = (struct mulaw_priv *)plugin->extra_data;\n\tdata->func = func;\n\tinit_data(data, format->format);\n\tplugin->transfer = mulaw_transfer;\n\t*r_plugin = plugin;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}