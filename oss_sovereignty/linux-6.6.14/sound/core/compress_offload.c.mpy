{
  "module_name": "compress_offload.c",
  "hash_id": "5f0893b8e80348a5c52ea4e847a657d4bde22b4c63d08742a997b551ef2dda05",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/compress_offload.c",
  "human_readable_source": "\n \n#define FORMAT(fmt) \"%s: %d: \" fmt, __func__, __LINE__\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" FORMAT(fmt)\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/math64.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/info.h>\n#include <sound/compress_params.h>\n#include <sound/compress_offload.h>\n#include <sound/compress_driver.h>\n\n \n#if _IOC_SIZEBITS < 14\n#define COMPR_CODEC_CAPS_OVERFLOW\n#endif\n\n \n\nstruct snd_compr_file {\n\tunsigned long caps;\n\tstruct snd_compr_stream stream;\n};\n\nstatic void error_delayed_work(struct work_struct *work);\n\n \nstatic int snd_compr_open(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr *compr;\n\tstruct snd_compr_file *data;\n\tstruct snd_compr_runtime *runtime;\n\tenum snd_compr_direction dirn;\n\tint maj = imajor(inode);\n\tint ret;\n\n\tif ((f->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tdirn = SND_COMPRESS_PLAYBACK;\n\telse if ((f->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tdirn = SND_COMPRESS_CAPTURE;\n\telse\n\t\treturn -EINVAL;\n\n\tif (maj == snd_major)\n\t\tcompr = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t\tSNDRV_DEVICE_TYPE_COMPRESS);\n\telse\n\t\treturn -EBADFD;\n\n\tif (compr == NULL) {\n\t\tpr_err(\"no device data!!!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dirn != compr->direction) {\n\t\tpr_err(\"this device doesn't support this direction\\n\");\n\t\tsnd_card_unref(compr->card);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&data->stream.error_work, error_delayed_work);\n\n\tdata->stream.ops = compr->ops;\n\tdata->stream.direction = dirn;\n\tdata->stream.private_data = compr->private_data;\n\tdata->stream.device = compr;\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (!runtime) {\n\t\tkfree(data);\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\truntime->state = SNDRV_PCM_STATE_OPEN;\n\tinit_waitqueue_head(&runtime->sleep);\n\tdata->stream.runtime = runtime;\n\tf->private_data = (void *)data;\n\tmutex_lock(&compr->lock);\n\tret = compr->ops->open(&data->stream);\n\tmutex_unlock(&compr->lock);\n\tif (ret) {\n\t\tkfree(runtime);\n\t\tkfree(data);\n\t}\n\tsnd_card_unref(compr->card);\n\treturn ret;\n}\n\nstatic int snd_compr_free(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_runtime *runtime = data->stream.runtime;\n\n\tcancel_delayed_work_sync(&data->stream.error_work);\n\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_DRAINING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tdata->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->stream.ops->free(&data->stream);\n\tif (!data->stream.runtime->dma_buffer_p)\n\t\tkfree(data->stream.runtime->buffer);\n\tkfree(data->stream.runtime);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic int snd_compr_update_tstamp(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_tstamp *tstamp)\n{\n\tif (!stream->ops->pointer)\n\t\treturn -ENOTSUPP;\n\tstream->ops->pointer(stream, tstamp);\n\tpr_debug(\"dsp consumed till %d total %d bytes\\n\",\n\t\ttstamp->byte_offset, tstamp->copied_total);\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tstream->runtime->total_bytes_transferred = tstamp->copied_total;\n\telse\n\t\tstream->runtime->total_bytes_available = tstamp->copied_total;\n\treturn 0;\n}\n\nstatic size_t snd_compr_calc_avail(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_avail *avail)\n{\n\tmemset(avail, 0, sizeof(*avail));\n\tsnd_compr_update_tstamp(stream, &avail->tstamp);\n\t \n\n\tif (stream->runtime->total_bytes_available == 0 &&\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->direction == SND_COMPRESS_PLAYBACK) {\n\t\tpr_debug(\"detected init and someone forgot to do a write\\n\");\n\t\treturn stream->runtime->buffer_size;\n\t}\n\tpr_debug(\"app wrote %lld, DSP consumed %lld\\n\",\n\t\t\tstream->runtime->total_bytes_available,\n\t\t\tstream->runtime->total_bytes_transferred);\n\tif (stream->runtime->total_bytes_available ==\n\t\t\t\tstream->runtime->total_bytes_transferred) {\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK) {\n\t\t\tpr_debug(\"both pointers are same, returning full avail\\n\");\n\t\t\treturn stream->runtime->buffer_size;\n\t\t} else {\n\t\t\tpr_debug(\"both pointers are same, returning no avail\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tavail->avail = stream->runtime->total_bytes_available -\n\t\t\tstream->runtime->total_bytes_transferred;\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tavail->avail = stream->runtime->buffer_size - avail->avail;\n\n\tpr_debug(\"ret avail as %lld\\n\", avail->avail);\n\treturn avail->avail;\n}\n\nstatic inline size_t snd_compr_get_avail(struct snd_compr_stream *stream)\n{\n\tstruct snd_compr_avail avail;\n\n\treturn snd_compr_calc_avail(stream, &avail);\n}\n\nstatic int\nsnd_compr_ioctl_avail(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_avail ioctl_avail;\n\tsize_t avail;\n\n\tavail = snd_compr_calc_avail(stream, &ioctl_avail);\n\tioctl_avail.avail = avail;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\t\treturn -EBADFD;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\treturn -EPIPE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (copy_to_user((__u64 __user *)arg,\n\t\t\t\t&ioctl_avail, sizeof(ioctl_avail)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_compr_write_data(struct snd_compr_stream *stream,\n\t       const char __user *buf, size_t count)\n{\n\tvoid *dstn;\n\tsize_t copy;\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\t \n\tu64 app_pointer = div64_u64(runtime->total_bytes_available,\n\t\t\t\t    runtime->buffer_size);\n\tapp_pointer = runtime->total_bytes_available -\n\t\t      (app_pointer * runtime->buffer_size);\n\n\tdstn = runtime->buffer + app_pointer;\n\tpr_debug(\"copying %ld at %lld\\n\",\n\t\t\t(unsigned long)count, app_pointer);\n\tif (count < runtime->buffer_size - app_pointer) {\n\t\tif (copy_from_user(dstn, buf, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tcopy = runtime->buffer_size - app_pointer;\n\t\tif (copy_from_user(dstn, buf, copy))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(runtime->buffer, buf + copy, count - copy))\n\t\t\treturn -EFAULT;\n\t}\n\t \n\tif (stream->ops->ack)\n\t\tstream->ops->ack(stream, count);\n\treturn count;\n}\n\nstatic ssize_t snd_compr_write(struct file *f, const char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\t \n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&stream->device->lock);\n\t\treturn -EBADFD;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t \n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tchar __user* cbuf = (char __user*)buf;\n\t\tretval = stream->ops->copy(stream, cbuf, avail);\n\t} else {\n\t\tretval = snd_compr_write_data(stream, buf, avail);\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_available += retval;\n\n\t \n\tif (stream->runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t\tpr_debug(\"stream prepared, Houston we are good to go\\n\");\n\t}\n\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\n\nstatic ssize_t snd_compr_read(struct file *f, char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\n\t \n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\tretval = -EBADFD;\n\t\tgoto out;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\tretval = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t \n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tretval = stream->ops->copy(stream, buf, avail);\n\t} else {\n\t\tretval = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_transferred += retval;\n\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int snd_compr_mmap(struct file *f, struct vm_area_struct *vma)\n{\n\treturn -ENXIO;\n}\n\nstatic __poll_t snd_compr_get_poll(struct snd_compr_stream *stream)\n{\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\telse\n\t\treturn EPOLLIN | EPOLLRDNORM;\n}\n\nstatic __poll_t snd_compr_poll(struct file *f, poll_table *wait)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\t__poll_t retval = 0;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn EPOLLERR;\n\n\tstream = &data->stream;\n\n\tmutex_lock(&stream->device->lock);\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\tretval = snd_compr_get_poll(stream) | EPOLLERR;\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpoll_wait(f, &stream->runtime->sleep, wait);\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail is %ld\\n\", (unsigned long)avail);\n\t \n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t \n\t\tretval = snd_compr_get_poll(stream);\n\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tif (avail >= stream->runtime->fragment_size)\n\t\t\tretval = snd_compr_get_poll(stream);\n\t\tbreak;\n\tdefault:\n\t\tretval = snd_compr_get_poll(stream) | EPOLLERR;\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_caps caps;\n\n\tif (!stream->ops->get_caps)\n\t\treturn -ENXIO;\n\n\tmemset(&caps, 0, sizeof(caps));\n\tretval = stream->ops->get_caps(stream, &caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\n\t\tretval = -EFAULT;\nout:\n\treturn retval;\n}\n\n#ifndef COMPR_CODEC_CAPS_OVERFLOW\nstatic int\nsnd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_codec_caps *caps;\n\n\tif (!stream->ops->get_codec_caps)\n\t\treturn -ENXIO;\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\tretval = stream->ops->get_codec_caps(stream, caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, caps, sizeof(*caps)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(caps);\n\treturn retval;\n}\n#endif  \n\nint snd_compr_malloc_pages(struct snd_compr_stream *stream, size_t size)\n{\n\tstruct snd_dma_buffer *dmab;\n\tint ret;\n\n\tif (snd_BUG_ON(!(stream) || !(stream)->runtime))\n\t\treturn -EINVAL;\n\tdmab = kzalloc(sizeof(*dmab), GFP_KERNEL);\n\tif (!dmab)\n\t\treturn -ENOMEM;\n\tdmab->dev = stream->dma_buffer.dev;\n\tret = snd_dma_alloc_pages(dmab->dev.type, dmab->dev.dev, size, dmab);\n\tif (ret < 0) {\n\t\tkfree(dmab);\n\t\treturn ret;\n\t}\n\n\tsnd_compr_set_runtime_buffer(stream, dmab);\n\tstream->runtime->dma_bytes = size;\n\treturn 1;\n}\nEXPORT_SYMBOL(snd_compr_malloc_pages);\n\nint snd_compr_free_pages(struct snd_compr_stream *stream)\n{\n\tstruct snd_compr_runtime *runtime;\n\n\tif (snd_BUG_ON(!(stream) || !(stream)->runtime))\n\t\treturn -EINVAL;\n\truntime = stream->runtime;\n\tif (runtime->dma_area == NULL)\n\t\treturn 0;\n\tif (runtime->dma_buffer_p != &stream->dma_buffer) {\n\t\t \n\t\tsnd_dma_free_pages(runtime->dma_buffer_p);\n\t\tkfree(runtime->dma_buffer_p);\n\t}\n\n\tsnd_compr_set_runtime_buffer(stream, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_compr_free_pages);\n\n \nstatic int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer = NULL;\n\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t\t \n\t} else {\n\t\tif (stream->runtime->dma_buffer_p) {\n\n\t\t\tif (buffer_size > stream->runtime->dma_buffer_p->bytes)\n\t\t\t\tdev_err(stream->device->dev,\n\t\t\t\t\t\t\"Not enough DMA buffer\");\n\t\t\telse\n\t\t\t\tbuffer = stream->runtime->dma_buffer_p->area;\n\n\t\t} else {\n\t\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\t}\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}\n\nstatic int snd_compress_check_input(struct snd_compr_params *params)\n{\n\t \n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > U32_MAX / params->buffer.fragment_size ||\n\t    params->buffer.fragments == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_params *params;\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_OPEN || stream->next_track) {\n\t\t \n\t\tparams = memdup_user((void __user *)arg, sizeof(*params));\n\t\tif (IS_ERR(params))\n\t\t\treturn PTR_ERR(params);\n\n\t\tretval = snd_compress_check_input(params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tretval = snd_compr_allocate_buffer(stream, params);\n\t\tif (retval) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval = stream->ops->set_params(stream, params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tif (stream->next_track)\n\t\t\tgoto out;\n\n\t\tstream->metadata_set = false;\n\t\tstream->next_track = false;\n\n\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t} else {\n\t\treturn -EPERM;\n\t}\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_codec *params;\n\tint retval;\n\n\tif (!stream->ops->get_params)\n\t\treturn -EBADFD;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\tretval = stream->ops->get_params(stream, params);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((char __user *)arg, params, sizeof(*params)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->get_metadata)\n\t\treturn -ENXIO;\n\n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->get_metadata(stream, &metadata);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tif (copy_to_user((void __user *)arg, &metadata, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->set_metadata)\n\t\treturn -ENXIO;\n\t \n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->set_metadata(stream, &metadata);\n\tstream->metadata_set = true;\n\n\treturn retval;\n}\n\nstatic inline int\nsnd_compr_tstamp(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_tstamp tstamp = {0};\n\tint ret;\n\n\tret = snd_compr_update_tstamp(stream, &tstamp);\n\tif (ret == 0)\n\t\tret = copy_to_user((struct snd_compr_tstamp __user *)arg,\n\t\t\t&tstamp, sizeof(tstamp)) ? -EFAULT : 0;\n\treturn ret;\n}\n\nstatic int snd_compr_pause(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\t\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\n\t\tif (!retval)\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_PAUSED;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\tif (!stream->device->use_pause_in_draining)\n\t\t\treturn -EPERM;\n\t\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\n\t\tif (!retval)\n\t\t\tstream->pause_in_draining = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\treturn retval;\n}\n\nstatic int snd_compr_resume(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n\t\tif (!retval)\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\tif (!stream->pause_in_draining)\n\t\t\treturn -EPERM;\n\t\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n\t\tif (!retval)\n\t\t\tstream->pause_in_draining = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\treturn retval;\n}\n\nstatic int snd_compr_start(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_SETUP:\n\t\tif (stream->direction != SND_COMPRESS_CAPTURE)\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_START);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\treturn retval;\n}\n\nstatic int snd_compr_stop(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\treturn -EPERM;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);\n\tif (!retval) {\n\t\t \n\t\tstream->partial_drain = false;\n\t\tstream->metadata_set = false;\n\t\tstream->pause_in_draining = false;\n\t\tsnd_compr_drain_notify(stream);\n\t\tstream->runtime->total_bytes_available = 0;\n\t\tstream->runtime->total_bytes_transferred = 0;\n\t}\n\treturn retval;\n}\n\nstatic void error_delayed_work(struct work_struct *work)\n{\n\tstruct snd_compr_stream *stream;\n\n\tstream = container_of(work, struct snd_compr_stream, error_work.work);\n\n\tmutex_lock(&stream->device->lock);\n\n\tstream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);\n\twake_up(&stream->runtime->sleep);\n\n\tmutex_unlock(&stream->device->lock);\n}\n\n \nint snd_compr_stop_error(struct snd_compr_stream *stream,\n\t\t\t snd_pcm_state_t state)\n{\n\tif (stream->runtime->state == state)\n\t\treturn 0;\n\n\tstream->runtime->state = state;\n\n\tpr_debug(\"Changing state to: %d\\n\", state);\n\n\tqueue_delayed_work(system_power_efficient_wq, &stream->error_work, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_compr_stop_error);\n\nstatic int snd_compress_wait_for_drain(struct snd_compr_stream *stream)\n{\n\tint ret;\n\n\t \n\tstream->runtime->state = SNDRV_PCM_STATE_DRAINING;\n\tmutex_unlock(&stream->device->lock);\n\n\t \n\n\tret = wait_event_interruptible(stream->runtime->sleep,\n\t\t\t(stream->runtime->state != SNDRV_PCM_STATE_DRAINING));\n\tif (ret == -ERESTARTSYS)\n\t\tpr_debug(\"wait aborted by a signal\\n\");\n\telse if (ret)\n\t\tpr_debug(\"wait for drain failed with %d\\n\", ret);\n\n\n\twake_up(&stream->runtime->sleep);\n\tmutex_lock(&stream->device->lock);\n\n\treturn ret;\n}\n\nstatic int snd_compr_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\treturn -EPERM;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\treturn -EPIPE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"SND_COMPR_TRIGGER_DRAIN failed %d\\n\", retval);\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic int snd_compr_next_track(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\t \n\tif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\t \n\tif (stream->direction == SND_COMPRESS_CAPTURE)\n\t\treturn -EPERM;\n\n\t \n\tif (stream->metadata_set == false)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_NEXT_TRACK);\n\tif (retval != 0)\n\t\treturn retval;\n\tstream->metadata_set = false;\n\tstream->next_track = true;\n\treturn 0;\n}\n\nstatic int snd_compr_partial_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\treturn -EPERM;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\treturn -EPIPE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (stream->direction == SND_COMPRESS_CAPTURE)\n\t\treturn -EPERM;\n\n\t \n\tif (stream->next_track == false)\n\t\treturn -EPERM;\n\n\tstream->partial_drain = true;\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"Partial drain returned failure\\n\");\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\tstream->next_track = false;\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tint retval = -ENOTTY;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\n\tmutex_lock(&stream->device->lock);\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(SNDRV_COMPRESS_IOCTL_VERSION):\n\t\tretval = put_user(SNDRV_COMPRESS_VERSION,\n\t\t\t\t(int __user *)arg) ? -EFAULT : 0;\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CAPS):\n\t\tretval = snd_compr_get_caps(stream, arg);\n\t\tbreak;\n#ifndef COMPR_CODEC_CAPS_OVERFLOW\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):\n\t\tretval = snd_compr_get_codec_caps(stream, arg);\n\t\tbreak;\n#endif\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):\n\t\tretval = snd_compr_set_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_PARAMS):\n\t\tretval = snd_compr_get_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_METADATA):\n\t\tretval = snd_compr_set_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_METADATA):\n\t\tretval = snd_compr_get_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_TSTAMP):\n\t\tretval = snd_compr_tstamp(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_AVAIL):\n\t\tretval = snd_compr_ioctl_avail(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PAUSE):\n\t\tretval = snd_compr_pause(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_RESUME):\n\t\tretval = snd_compr_resume(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_START):\n\t\tretval = snd_compr_start(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_STOP):\n\t\tretval = snd_compr_stop(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_DRAIN):\n\t\tretval = snd_compr_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PARTIAL_DRAIN):\n\t\tretval = snd_compr_partial_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_NEXT_TRACK):\n\t\tretval = snd_compr_next_track(stream);\n\t\tbreak;\n\n\t}\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\n \n#ifdef CONFIG_COMPAT\nstatic long snd_compr_ioctl_compat(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\treturn snd_compr_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations snd_compr_file_ops = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.open =\t\tsnd_compr_open,\n\t\t.release =\tsnd_compr_free,\n\t\t.write =\tsnd_compr_write,\n\t\t.read =\t\tsnd_compr_read,\n\t\t.unlocked_ioctl = snd_compr_ioctl,\n#ifdef CONFIG_COMPAT\n\t\t.compat_ioctl = snd_compr_ioctl_compat,\n#endif\n\t\t.mmap =\t\tsnd_compr_mmap,\n\t\t.poll =\t\tsnd_compr_poll,\n};\n\nstatic int snd_compress_dev_register(struct snd_device *device)\n{\n\tint ret;\n\tstruct snd_compr *compr;\n\n\tif (snd_BUG_ON(!device || !device->device_data))\n\t\treturn -EBADFD;\n\tcompr = device->device_data;\n\n\tpr_debug(\"reg device %s, direction %d\\n\", compr->name,\n\t\t\tcompr->direction);\n\t \n\tret = snd_register_device(SNDRV_DEVICE_TYPE_COMPRESS,\n\t\t\t\t  compr->card, compr->device,\n\t\t\t\t  &snd_compr_file_ops, compr, compr->dev);\n\tif (ret < 0) {\n\t\tpr_err(\"snd_register_device failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n\n}\n\nstatic int snd_compress_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_compr *compr;\n\n\tcompr = device->device_data;\n\tsnd_unregister_device(compr->dev);\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_VERBOSE_PROCFS\nstatic void snd_compress_proc_info_read(struct snd_info_entry *entry,\n\t\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_compr *compr = (struct snd_compr *)entry->private_data;\n\n\tsnd_iprintf(buffer, \"card: %d\\n\", compr->card->number);\n\tsnd_iprintf(buffer, \"device: %d\\n\", compr->device);\n\tsnd_iprintf(buffer, \"stream: %s\\n\",\n\t\t\tcompr->direction == SND_COMPRESS_PLAYBACK\n\t\t\t\t? \"PLAYBACK\" : \"CAPTURE\");\n\tsnd_iprintf(buffer, \"id: %s\\n\", compr->id);\n}\n\nstatic int snd_compress_proc_init(struct snd_compr *compr)\n{\n\tstruct snd_info_entry *entry;\n\tchar name[16];\n\n\tsprintf(name, \"compr%i\", compr->device);\n\tentry = snd_info_create_card_entry(compr->card, name,\n\t\t\t\t\t   compr->card->proc_root);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->mode = S_IFDIR | 0555;\n\tcompr->proc_root = entry;\n\n\tentry = snd_info_create_card_entry(compr->card, \"info\",\n\t\t\t\t\t   compr->proc_root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, compr,\n\t\t\t\t      snd_compress_proc_info_read);\n\tcompr->proc_info_entry = entry;\n\n\treturn 0;\n}\n\nstatic void snd_compress_proc_done(struct snd_compr *compr)\n{\n\tsnd_info_free_entry(compr->proc_info_entry);\n\tcompr->proc_info_entry = NULL;\n\tsnd_info_free_entry(compr->proc_root);\n\tcompr->proc_root = NULL;\n}\n\nstatic inline void snd_compress_set_id(struct snd_compr *compr, const char *id)\n{\n\tstrscpy(compr->id, id, sizeof(compr->id));\n}\n#else\nstatic inline int snd_compress_proc_init(struct snd_compr *compr)\n{\n\treturn 0;\n}\n\nstatic inline void snd_compress_proc_done(struct snd_compr *compr)\n{\n}\n\nstatic inline void snd_compress_set_id(struct snd_compr *compr, const char *id)\n{\n}\n#endif\n\nstatic int snd_compress_dev_free(struct snd_device *device)\n{\n\tstruct snd_compr *compr;\n\n\tcompr = device->device_data;\n\tsnd_compress_proc_done(compr);\n\tput_device(compr->dev);\n\treturn 0;\n}\n\n \nint snd_compress_new(struct snd_card *card, int device,\n\t\t\tint dirn, const char *id, struct snd_compr *compr)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_compress_dev_free,\n\t\t.dev_register = snd_compress_dev_register,\n\t\t.dev_disconnect = snd_compress_dev_disconnect,\n\t};\n\tint ret;\n\n\tcompr->card = card;\n\tcompr->device = device;\n\tcompr->direction = dirn;\n\tmutex_init(&compr->lock);\n\n\tsnd_compress_set_id(compr, id);\n\n\tret = snd_device_alloc(&compr->dev, card);\n\tif (ret)\n\t\treturn ret;\n\tdev_set_name(compr->dev, \"comprC%iD%i\", card->number, device);\n\n\tret = snd_device_new(card, SNDRV_DEV_COMPRESS, compr, &ops);\n\tif (ret == 0)\n\t\tsnd_compress_proc_init(compr);\n\telse\n\t\tput_device(compr->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_compress_new);\n\nMODULE_DESCRIPTION(\"ALSA Compressed offload framework\");\nMODULE_AUTHOR(\"Vinod Koul <vinod.koul@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}