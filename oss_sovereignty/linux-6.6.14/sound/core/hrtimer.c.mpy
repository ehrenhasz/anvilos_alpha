{
  "module_name": "hrtimer.c",
  "hash_id": "4037674624d7138addf3ddfb205c84798dcafae9d9f03aa85276f83392b2cfff",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/hrtimer.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/hrtimer.h>\n#include <sound/core.h>\n#include <sound/timer.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA hrtimer backend\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS(\"snd-timer-\" __stringify(SNDRV_TIMER_GLOBAL_HRTIMER));\n\n#define NANO_SEC\t1000000000UL\t \nstatic unsigned int resolution;\n\nstruct snd_hrtimer {\n\tstruct snd_timer *timer;\n\tstruct hrtimer hrt;\n\tbool in_callback;\n};\n\nstatic enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)\n{\n\tstruct snd_hrtimer *stime = container_of(hrt, struct snd_hrtimer, hrt);\n\tstruct snd_timer *t = stime->timer;\n\tktime_t delta;\n\tunsigned long ticks;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\tspin_lock(&t->lock);\n\tif (!t->running)\n\t\tgoto out;  \n\tstime->in_callback = true;\n\tticks = t->sticks;\n\tspin_unlock(&t->lock);\n\n\t \n\tdelta = ktime_sub(hrt->base->get_time(), hrtimer_get_expires(hrt));\n\tif (delta > 0)\n\t\tticks += ktime_divns(delta, ticks * resolution);\n\n\tsnd_timer_interrupt(stime->timer, ticks);\n\n\tspin_lock(&t->lock);\n\tif (t->running) {\n\t\thrtimer_add_expires_ns(hrt, t->sticks * resolution);\n\t\tret = HRTIMER_RESTART;\n\t}\n\n\tstime->in_callback = false;\n out:\n\tspin_unlock(&t->lock);\n\treturn ret;\n}\n\nstatic int snd_hrtimer_open(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime;\n\n\tstime = kzalloc(sizeof(*stime), GFP_KERNEL);\n\tif (!stime)\n\t\treturn -ENOMEM;\n\thrtimer_init(&stime->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tstime->timer = t;\n\tstime->hrt.function = snd_hrtimer_callback;\n\tt->private_data = stime;\n\treturn 0;\n}\n\nstatic int snd_hrtimer_close(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\n\tif (stime) {\n\t\tspin_lock_irq(&t->lock);\n\t\tt->running = 0;  \n\t\tstime->in_callback = 1;  \n\t\tspin_unlock_irq(&t->lock);\n\n\t\thrtimer_cancel(&stime->hrt);\n\t\tkfree(stime);\n\t\tt->private_data = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\n\tif (stime->in_callback)\n\t\treturn 0;\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\treturn 0;\n}\n\nstatic int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\n\tif (stime->in_callback)\n\t\treturn 0;\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware hrtimer_hw __initconst = {\n\t.flags =\tSNDRV_TIMER_HW_AUTO | SNDRV_TIMER_HW_WORK,\n\t.open =\t\tsnd_hrtimer_open,\n\t.close =\tsnd_hrtimer_close,\n\t.start =\tsnd_hrtimer_start,\n\t.stop =\t\tsnd_hrtimer_stop,\n};\n\n \n\nstatic struct snd_timer *mytimer;\n\nstatic int __init snd_hrtimer_init(void)\n{\n\tstruct snd_timer *timer;\n\tint err;\n\n\tresolution = hrtimer_resolution;\n\n\t \n\terr = snd_timer_global_new(\"hrtimer\", SNDRV_TIMER_GLOBAL_HRTIMER,\n\t\t\t\t   &timer);\n\tif (err < 0)\n\t\treturn err;\n\n\ttimer->module = THIS_MODULE;\n\tstrcpy(timer->name, \"HR timer\");\n\ttimer->hw = hrtimer_hw;\n\ttimer->hw.resolution = resolution;\n\ttimer->hw.ticks = NANO_SEC / resolution;\n\ttimer->max_instances = 100;  \n\n\terr = snd_timer_global_register(timer);\n\tif (err < 0) {\n\t\tsnd_timer_global_free(timer);\n\t\treturn err;\n\t}\n\tmytimer = timer;  \n\n\treturn 0;\n}\n\nstatic void __exit snd_hrtimer_exit(void)\n{\n\tif (mytimer) {\n\t\tsnd_timer_global_free(mytimer);\n\t\tmytimer = NULL;\n\t}\n}\n\nmodule_init(snd_hrtimer_init);\nmodule_exit(snd_hrtimer_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}