{
  "module_name": "sound.c",
  "hash_id": "c1df9dc9f9a912340f071bc06c2bde7e83e935b3f98f371b715584dcb3ba1f6e",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/sound.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n#include <linux/mutex.h>\n\nstatic int major = CONFIG_SND_MAJOR;\nint snd_major;\nEXPORT_SYMBOL(snd_major);\n\nstatic int cards_limit = 1;\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Advanced Linux Sound Architecture driver for soundcards.\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(major, int, 0444);\nMODULE_PARM_DESC(major, \"Major # for sound driver.\");\nmodule_param(cards_limit, int, 0444);\nMODULE_PARM_DESC(cards_limit, \"Count of auto-loadable soundcards.\");\nMODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);\n\n \nint snd_ecards_limit;\nEXPORT_SYMBOL(snd_ecards_limit);\n\n#ifdef CONFIG_SND_DEBUG\nstruct dentry *sound_debugfs_root;\nEXPORT_SYMBOL_GPL(sound_debugfs_root);\n#endif\n\nstatic struct snd_minor *snd_minors[SNDRV_OS_MINORS];\nstatic DEFINE_MUTEX(sound_mutex);\n\n#ifdef CONFIG_MODULES\n\n \nvoid snd_request_card(int card)\n{\n\tif (snd_card_locked(card))\n\t\treturn;\n\tif (card < 0 || card >= cards_limit)\n\t\treturn;\n\trequest_module(\"snd-card-%i\", card);\n}\nEXPORT_SYMBOL(snd_request_card);\n\nstatic void snd_request_other(int minor)\n{\n\tchar *str;\n\n\tswitch (minor) {\n\tcase SNDRV_MINOR_SEQUENCER:\tstr = \"snd-seq\";\tbreak;\n\tcase SNDRV_MINOR_TIMER:\t\tstr = \"snd-timer\";\tbreak;\n\tdefault:\t\t\treturn;\n\t}\n\trequest_module(str);\n}\n\n#endif\t \n\n \nvoid *snd_lookup_minor_data(unsigned int minor, int type)\n{\n\tstruct snd_minor *mreg;\n\tvoid *private_data;\n\n\tif (minor >= ARRAY_SIZE(snd_minors))\n\t\treturn NULL;\n\tmutex_lock(&sound_mutex);\n\tmreg = snd_minors[minor];\n\tif (mreg && mreg->type == type) {\n\t\tprivate_data = mreg->private_data;\n\t\tif (private_data && mreg->card_ptr)\n\t\t\tget_device(&mreg->card_ptr->card_dev);\n\t} else\n\t\tprivate_data = NULL;\n\tmutex_unlock(&sound_mutex);\n\treturn private_data;\n}\nEXPORT_SYMBOL(snd_lookup_minor_data);\n\n#ifdef CONFIG_MODULES\nstatic struct snd_minor *autoload_device(unsigned int minor)\n{\n\tint dev;\n\tmutex_unlock(&sound_mutex);  \n\tdev = SNDRV_MINOR_DEVICE(minor);\n\tif (dev == SNDRV_MINOR_CONTROL) {\n\t\t \n\t\tint card = SNDRV_MINOR_CARD(minor);\n\t\tstruct snd_card *ref = snd_card_ref(card);\n\t\tif (!ref)\n\t\t\tsnd_request_card(card);\n\t\telse\n\t\t\tsnd_card_unref(ref);\n\t} else if (dev == SNDRV_MINOR_GLOBAL) {\n\t\t \n\t\tsnd_request_other(minor);\n\t}\n\tmutex_lock(&sound_mutex);  \n\treturn snd_minors[minor];\n}\n#else  \n#define autoload_device(minor)\tNULL\n#endif  \n\nstatic int snd_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct snd_minor *mptr = NULL;\n\tconst struct file_operations *new_fops;\n\tint err = 0;\n\n\tif (minor >= ARRAY_SIZE(snd_minors))\n\t\treturn -ENODEV;\n\tmutex_lock(&sound_mutex);\n\tmptr = snd_minors[minor];\n\tif (mptr == NULL) {\n\t\tmptr = autoload_device(minor);\n\t\tif (!mptr) {\n\t\t\tmutex_unlock(&sound_mutex);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tnew_fops = fops_get(mptr->f_ops);\n\tmutex_unlock(&sound_mutex);\n\tif (!new_fops)\n\t\treturn -ENODEV;\n\treplace_fops(file, new_fops);\n\n\tif (file->f_op->open)\n\t\terr = file->f_op->open(inode, file);\n\treturn err;\n}\n\nstatic const struct file_operations snd_fops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tsnd_open,\n\t.llseek =\tnoop_llseek,\n};\n\n#ifdef CONFIG_SND_DYNAMIC_MINORS\nstatic int snd_find_free_minor(int type, struct snd_card *card, int dev)\n{\n\tint minor;\n\n\t \n\tif (type == SNDRV_DEVICE_TYPE_SEQUENCER)\n\t\treturn SNDRV_MINOR_SEQUENCER;\n\tif (type == SNDRV_DEVICE_TYPE_TIMER)\n\t\treturn SNDRV_MINOR_TIMER;\n\n\tfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {\n\t\t \n\t\tif (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL)\n\t\t\tcontinue;\n\t\tif (minor == SNDRV_MINOR_SEQUENCER ||\n\t\t    minor == SNDRV_MINOR_TIMER)\n\t\t\tcontinue;\n\t\tif (!snd_minors[minor])\n\t\t\treturn minor;\n\t}\n\treturn -EBUSY;\n}\n#else\nstatic int snd_find_free_minor(int type, struct snd_card *card, int dev)\n{\n\tint minor;\n\n\tswitch (type) {\n\tcase SNDRV_DEVICE_TYPE_SEQUENCER:\n\tcase SNDRV_DEVICE_TYPE_TIMER:\n\t\tminor = type;\n\t\tbreak;\n\tcase SNDRV_DEVICE_TYPE_CONTROL:\n\t\tif (snd_BUG_ON(!card))\n\t\t\treturn -EINVAL;\n\t\tminor = SNDRV_MINOR(card->number, type);\n\t\tbreak;\n\tcase SNDRV_DEVICE_TYPE_HWDEP:\n\tcase SNDRV_DEVICE_TYPE_RAWMIDI:\n\tcase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\n\tcase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\n\tcase SNDRV_DEVICE_TYPE_COMPRESS:\n\t\tif (snd_BUG_ON(!card))\n\t\t\treturn -EINVAL;\n\t\tminor = SNDRV_MINOR(card->number, type + dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (snd_BUG_ON(minor < 0 || minor >= SNDRV_OS_MINORS))\n\t\treturn -EINVAL;\n\tif (snd_minors[minor])\n\t\treturn -EBUSY;\n\treturn minor;\n}\n#endif\n\n \nint snd_register_device(int type, struct snd_card *card, int dev,\n\t\t\tconst struct file_operations *f_ops,\n\t\t\tvoid *private_data, struct device *device)\n{\n\tint minor;\n\tint err = 0;\n\tstruct snd_minor *preg;\n\n\tif (snd_BUG_ON(!device))\n\t\treturn -EINVAL;\n\n\tpreg = kmalloc(sizeof *preg, GFP_KERNEL);\n\tif (preg == NULL)\n\t\treturn -ENOMEM;\n\tpreg->type = type;\n\tpreg->card = card ? card->number : -1;\n\tpreg->device = dev;\n\tpreg->f_ops = f_ops;\n\tpreg->private_data = private_data;\n\tpreg->card_ptr = card;\n\tmutex_lock(&sound_mutex);\n\tminor = snd_find_free_minor(type, card, dev);\n\tif (minor < 0) {\n\t\terr = minor;\n\t\tgoto error;\n\t}\n\n\tpreg->dev = device;\n\tdevice->devt = MKDEV(major, minor);\n\terr = device_add(device);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_minors[minor] = preg;\n error:\n\tmutex_unlock(&sound_mutex);\n\tif (err < 0)\n\t\tkfree(preg);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_register_device);\n\n \nint snd_unregister_device(struct device *dev)\n{\n\tint minor;\n\tstruct snd_minor *preg;\n\n\tmutex_lock(&sound_mutex);\n\tfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {\n\t\tpreg = snd_minors[minor];\n\t\tif (preg && preg->dev == dev) {\n\t\t\tsnd_minors[minor] = NULL;\n\t\t\tdevice_del(dev);\n\t\t\tkfree(preg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&sound_mutex);\n\tif (minor >= ARRAY_SIZE(snd_minors))\n\t\treturn -ENOENT;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_unregister_device);\n\n#ifdef CONFIG_SND_PROC_FS\n \nstatic const char *snd_device_type_name(int type)\n{\n\tswitch (type) {\n\tcase SNDRV_DEVICE_TYPE_CONTROL:\n\t\treturn \"control\";\n\tcase SNDRV_DEVICE_TYPE_HWDEP:\n\t\treturn \"hardware dependent\";\n\tcase SNDRV_DEVICE_TYPE_RAWMIDI:\n\t\treturn \"raw midi\";\n\tcase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\n\t\treturn \"digital audio playback\";\n\tcase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\n\t\treturn \"digital audio capture\";\n\tcase SNDRV_DEVICE_TYPE_SEQUENCER:\n\t\treturn \"sequencer\";\n\tcase SNDRV_DEVICE_TYPE_TIMER:\n\t\treturn \"timer\";\n\tcase SNDRV_DEVICE_TYPE_COMPRESS:\n\t\treturn \"compress\";\n\tdefault:\n\t\treturn \"?\";\n\t}\n}\n\nstatic void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tint minor;\n\tstruct snd_minor *mptr;\n\n\tmutex_lock(&sound_mutex);\n\tfor (minor = 0; minor < SNDRV_OS_MINORS; ++minor) {\n\t\tmptr = snd_minors[minor];\n\t\tif (!mptr)\n\t\t\tcontinue;\n\t\tif (mptr->card >= 0) {\n\t\t\tif (mptr->device >= 0)\n\t\t\t\tsnd_iprintf(buffer, \"%3i: [%2i-%2i]: %s\\n\",\n\t\t\t\t\t    minor, mptr->card, mptr->device,\n\t\t\t\t\t    snd_device_type_name(mptr->type));\n\t\t\telse\n\t\t\t\tsnd_iprintf(buffer, \"%3i: [%2i]   : %s\\n\",\n\t\t\t\t\t    minor, mptr->card,\n\t\t\t\t\t    snd_device_type_name(mptr->type));\n\t\t} else\n\t\t\tsnd_iprintf(buffer, \"%3i:        : %s\\n\", minor,\n\t\t\t\t    snd_device_type_name(mptr->type));\n\t}\n\tmutex_unlock(&sound_mutex);\n}\n\nint __init snd_minor_info_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"devices\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_minor_info_read;\n\treturn snd_info_register(entry);  \n}\n#endif  \n\n \n\nstatic int __init alsa_sound_init(void)\n{\n\tsnd_major = major;\n\tsnd_ecards_limit = cards_limit;\n\tif (register_chrdev(major, \"alsa\", &snd_fops)) {\n\t\tpr_err(\"ALSA core: unable to register native major device number %d\\n\", major);\n\t\treturn -EIO;\n\t}\n\tif (snd_info_init() < 0) {\n\t\tunregister_chrdev(major, \"alsa\");\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_SND_DEBUG\n\tsound_debugfs_root = debugfs_create_dir(\"sound\", NULL);\n#endif\n#ifndef MODULE\n\tpr_info(\"Advanced Linux Sound Architecture Driver Initialized.\\n\");\n#endif\n\treturn 0;\n}\n\nstatic void __exit alsa_sound_exit(void)\n{\n#ifdef CONFIG_SND_DEBUG\n\tdebugfs_remove(sound_debugfs_root);\n#endif\n\tsnd_info_done();\n\tunregister_chrdev(major, \"alsa\");\n}\n\nsubsys_initcall(alsa_sound_init);\nmodule_exit(alsa_sound_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}