{
  "module_name": "info.c",
  "hash_id": "b06cd714a5d05d9a57735e571af0f6b6ce7069638ff4e20d282ab3d5ea785d92",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/info.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <linux/utsname.h>\n#include <linux/proc_fs.h>\n#include <linux/mutex.h>\n\nint snd_info_check_reserved_words(const char *str)\n{\n\tstatic const char * const reserved[] =\n\t{\n\t\t\"version\",\n\t\t\"meminfo\",\n\t\t\"memdebug\",\n\t\t\"detect\",\n\t\t\"devices\",\n\t\t\"oss\",\n\t\t\"cards\",\n\t\t\"timers\",\n\t\t\"synth\",\n\t\t\"pcm\",\n\t\t\"seq\",\n\t\tNULL\n\t};\n\tconst char * const *xstr = reserved;\n\n\twhile (*xstr) {\n\t\tif (!strcmp(*xstr, str))\n\t\t\treturn 0;\n\t\txstr++;\n\t}\n\tif (!strncmp(str, \"card\", 4))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic DEFINE_MUTEX(info_mutex);\n\nstruct snd_info_private_data {\n\tstruct snd_info_buffer *rbuffer;\n\tstruct snd_info_buffer *wbuffer;\n\tstruct snd_info_entry *entry;\n\tvoid *file_private_data;\n};\n\nstatic int snd_info_version_init(void);\nstatic void snd_info_clear_entries(struct snd_info_entry *entry);\n\n \n\nstatic struct snd_info_entry *snd_proc_root;\nstruct snd_info_entry *snd_seq_root;\nEXPORT_SYMBOL(snd_seq_root);\n\n#ifdef CONFIG_SND_OSSEMUL\nstruct snd_info_entry *snd_oss_root;\n#endif\n\nstatic int alloc_info_private(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_private_data **ret)\n{\n\tstruct snd_info_private_data *data;\n\n\tif (!entry || !entry->p)\n\t\treturn -ENODEV;\n\tif (!try_module_get(entry->module))\n\t\treturn -EFAULT;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tmodule_put(entry->module);\n\t\treturn -ENOMEM;\n\t}\n\tdata->entry = entry;\n\t*ret = data;\n\treturn 0;\n}\n\nstatic bool valid_pos(loff_t pos, size_t count)\n{\n\tif (pos < 0 || (long) pos != pos || (ssize_t) count < 0)\n\t\treturn false;\n\tif ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct snd_info_private_data *data;\n\tstruct snd_info_entry *entry;\n\tloff_t ret = -EINVAL, size;\n\n\tdata = file->private_data;\n\tentry = data->entry;\n\tmutex_lock(&entry->access);\n\tif (entry->c.ops->llseek) {\n\t\tret = entry->c.ops->llseek(entry,\n\t\t\t\t\t   data->file_private_data,\n\t\t\t\t\t   file, offset, orig);\n\t\tgoto out;\n\t}\n\n\tsize = entry->size;\n\tswitch (orig) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tif (!size)\n\t\t\tgoto out;\n\t\toffset += size;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\tif (offset < 0)\n\t\tgoto out;\n\tif (size && offset > size)\n\t\toffset = size;\n\tfile->f_pos = offset;\n\tret = offset;\n out:\n\tmutex_unlock(&entry->access);\n\treturn ret;\n}\n\nstatic ssize_t snd_info_entry_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t * offset)\n{\n\tstruct snd_info_private_data *data = file->private_data;\n\tstruct snd_info_entry *entry = data->entry;\n\tsize_t size;\n\tloff_t pos;\n\n\tpos = *offset;\n\tif (!valid_pos(pos, count))\n\t\treturn -EIO;\n\tif (pos >= entry->size)\n\t\treturn 0;\n\tsize = entry->size - pos;\n\tsize = min(count, size);\n\tsize = entry->c.ops->read(entry, data->file_private_data,\n\t\t\t\t  file, buffer, size, pos);\n\tif ((ssize_t) size > 0)\n\t\t*offset = pos + size;\n\treturn size;\n}\n\nstatic ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_info_private_data *data = file->private_data;\n\tstruct snd_info_entry *entry = data->entry;\n\tssize_t size = 0;\n\tloff_t pos;\n\n\tpos = *offset;\n\tif (!valid_pos(pos, count))\n\t\treturn -EIO;\n\tif (count > 0) {\n\t\tsize_t maxsize = entry->size - pos;\n\t\tcount = min(count, maxsize);\n\t\tsize = entry->c.ops->write(entry, data->file_private_data,\n\t\t\t\t\t   file, buffer, count, pos);\n\t}\n\tif (size > 0)\n\t\t*offset = pos + size;\n\treturn size;\n}\n\nstatic __poll_t snd_info_entry_poll(struct file *file, poll_table *wait)\n{\n\tstruct snd_info_private_data *data = file->private_data;\n\tstruct snd_info_entry *entry = data->entry;\n\t__poll_t mask = 0;\n\n\tif (entry->c.ops->poll)\n\t\treturn entry->c.ops->poll(entry,\n\t\t\t\t\t  data->file_private_data,\n\t\t\t\t\t  file, wait);\n\tif (entry->c.ops->read)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (entry->c.ops->write)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic long snd_info_entry_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct snd_info_private_data *data = file->private_data;\n\tstruct snd_info_entry *entry = data->entry;\n\n\tif (!entry->c.ops->ioctl)\n\t\treturn -ENOTTY;\n\treturn entry->c.ops->ioctl(entry, data->file_private_data,\n\t\t\t\t   file, cmd, arg);\n}\n\nstatic int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct snd_info_private_data *data;\n\tstruct snd_info_entry *entry;\n\n\tdata = file->private_data;\n\tif (data == NULL)\n\t\treturn 0;\n\tentry = data->entry;\n\tif (!entry->c.ops->mmap)\n\t\treturn -ENXIO;\n\treturn entry->c.ops->mmap(entry, data->file_private_data,\n\t\t\t\t  inode, file, vma);\n}\n\nstatic int snd_info_entry_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_info_entry *entry = pde_data(inode);\n\tstruct snd_info_private_data *data;\n\tint mode, err;\n\n\tmutex_lock(&info_mutex);\n\terr = alloc_info_private(entry, &data);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tmode = file->f_flags & O_ACCMODE;\n\tif (((mode == O_RDONLY || mode == O_RDWR) && !entry->c.ops->read) ||\n\t    ((mode == O_WRONLY || mode == O_RDWR) && !entry->c.ops->write)) {\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (entry->c.ops->open) {\n\t\terr = entry->c.ops->open(entry, mode, &data->file_private_data);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tfile->private_data = data;\n\tmutex_unlock(&info_mutex);\n\treturn 0;\n\n error:\n\tkfree(data);\n\tmodule_put(entry->module);\n unlock:\n\tmutex_unlock(&info_mutex);\n\treturn err;\n}\n\nstatic int snd_info_entry_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_info_private_data *data = file->private_data;\n\tstruct snd_info_entry *entry = data->entry;\n\n\tif (entry->c.ops->release)\n\t\tentry->c.ops->release(entry, file->f_flags & O_ACCMODE,\n\t\t\t\t      data->file_private_data);\n\tmodule_put(entry->module);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic const struct proc_ops snd_info_entry_operations =\n{\n\t.proc_lseek\t= snd_info_entry_llseek,\n\t.proc_read\t= snd_info_entry_read,\n\t.proc_write\t= snd_info_entry_write,\n\t.proc_poll\t= snd_info_entry_poll,\n\t.proc_ioctl\t= snd_info_entry_ioctl,\n\t.proc_mmap\t= snd_info_entry_mmap,\n\t.proc_open\t= snd_info_entry_open,\n\t.proc_release\t= snd_info_entry_release,\n};\n\n \nstatic ssize_t snd_info_text_entry_write(struct file *file,\n\t\t\t\t\t const char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *offset)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct snd_info_private_data *data = m->private;\n\tstruct snd_info_entry *entry = data->entry;\n\tstruct snd_info_buffer *buf;\n\tloff_t pos;\n\tsize_t next;\n\tint err = 0;\n\n\tif (!entry->c.text.write)\n\t\treturn -EIO;\n\tpos = *offset;\n\tif (!valid_pos(pos, count))\n\t\treturn -EIO;\n\tnext = pos + count;\n\t \n\tif (next > 16 * 1024)\n\t\treturn -EIO;\n\tmutex_lock(&entry->access);\n\tbuf = data->wbuffer;\n\tif (!buf) {\n\t\tdata->wbuffer = buf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (next > buf->len) {\n\t\tchar *nbuf = kvzalloc(PAGE_ALIGN(next), GFP_KERNEL);\n\t\tif (!nbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tkvfree(buf->buffer);\n\t\tbuf->buffer = nbuf;\n\t\tbuf->len = PAGE_ALIGN(next);\n\t}\n\tif (copy_from_user(buf->buffer + pos, buffer, count)) {\n\t\terr = -EFAULT;\n\t\tgoto error;\n\t}\n\tbuf->size = next;\n error:\n\tmutex_unlock(&entry->access);\n\tif (err < 0)\n\t\treturn err;\n\t*offset = next;\n\treturn count;\n}\n\nstatic int snd_info_seq_show(struct seq_file *seq, void *p)\n{\n\tstruct snd_info_private_data *data = seq->private;\n\tstruct snd_info_entry *entry = data->entry;\n\n\tif (!entry->c.text.read) {\n\t\treturn -EIO;\n\t} else {\n\t\tdata->rbuffer->buffer = (char *)seq;  \n\t\tentry->c.text.read(entry, data->rbuffer);\n\t}\n\treturn 0;\n}\n\nstatic int snd_info_text_entry_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_info_entry *entry = pde_data(inode);\n\tstruct snd_info_private_data *data;\n\tint err;\n\n\tmutex_lock(&info_mutex);\n\terr = alloc_info_private(entry, &data);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tdata->rbuffer = kzalloc(sizeof(*data->rbuffer), GFP_KERNEL);\n\tif (!data->rbuffer) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tif (entry->size)\n\t\terr = single_open_size(file, snd_info_seq_show, data,\n\t\t\t\t       entry->size);\n\telse\n\t\terr = single_open(file, snd_info_seq_show, data);\n\tif (err < 0)\n\t\tgoto error;\n\tmutex_unlock(&info_mutex);\n\treturn 0;\n\n error:\n\tkfree(data->rbuffer);\n\tkfree(data);\n\tmodule_put(entry->module);\n unlock:\n\tmutex_unlock(&info_mutex);\n\treturn err;\n}\n\nstatic int snd_info_text_entry_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct snd_info_private_data *data = m->private;\n\tstruct snd_info_entry *entry = data->entry;\n\n\tif (data->wbuffer && entry->c.text.write)\n\t\tentry->c.text.write(entry, data->wbuffer);\n\n\tsingle_release(inode, file);\n\tkfree(data->rbuffer);\n\tif (data->wbuffer) {\n\t\tkvfree(data->wbuffer->buffer);\n\t\tkfree(data->wbuffer);\n\t}\n\n\tmodule_put(entry->module);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic const struct proc_ops snd_info_text_entry_ops =\n{\n\t.proc_open\t= snd_info_text_entry_open,\n\t.proc_release\t= snd_info_text_entry_release,\n\t.proc_write\t= snd_info_text_entry_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_read\t= seq_read,\n};\n\nstatic struct snd_info_entry *create_subdir(struct module *mod,\n\t\t\t\t\t    const char *name)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(mod, name, NULL);\n\tif (!entry)\n\t\treturn NULL;\n\tentry->mode = S_IFDIR | 0555;\n\tif (snd_info_register(entry) < 0) {\n\t\tsnd_info_free_entry(entry);\n\t\treturn NULL;\n\t}\n\treturn entry;\n}\n\nstatic struct snd_info_entry *\nsnd_info_create_entry(const char *name, struct snd_info_entry *parent,\n\t\t      struct module *module);\n\nint __init snd_info_init(void)\n{\n\tsnd_proc_root = snd_info_create_entry(\"asound\", NULL, THIS_MODULE);\n\tif (!snd_proc_root)\n\t\treturn -ENOMEM;\n\tsnd_proc_root->mode = S_IFDIR | 0555;\n\tsnd_proc_root->p = proc_mkdir(\"asound\", NULL);\n\tif (!snd_proc_root->p)\n\t\tgoto error;\n#ifdef CONFIG_SND_OSSEMUL\n\tsnd_oss_root = create_subdir(THIS_MODULE, \"oss\");\n\tif (!snd_oss_root)\n\t\tgoto error;\n#endif\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tsnd_seq_root = create_subdir(THIS_MODULE, \"seq\");\n\tif (!snd_seq_root)\n\t\tgoto error;\n#endif\n\tif (snd_info_version_init() < 0 ||\n\t    snd_minor_info_init() < 0 ||\n\t    snd_minor_info_oss_init() < 0 ||\n\t    snd_card_info_init() < 0 ||\n\t    snd_info_minor_register() < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tsnd_info_free_entry(snd_proc_root);\n\treturn -ENOMEM;\n}\n\nint __exit snd_info_done(void)\n{\n\tsnd_info_free_entry(snd_proc_root);\n\treturn 0;\n}\n\nstatic void snd_card_id_read(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_card *card = entry->private_data;\n\n\tsnd_iprintf(buffer, \"%s\\n\", card->id);\n}\n\n \nint snd_info_card_create(struct snd_card *card)\n{\n\tchar str[8];\n\tstruct snd_info_entry *entry;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\n\tsprintf(str, \"card%i\", card->number);\n\tentry = create_subdir(card->module, str);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tcard->proc_root = entry;\n\n\treturn snd_card_ro_proc_new(card, \"id\", card, snd_card_id_read);\n}\n\n \nint snd_info_card_register(struct snd_card *card)\n{\n\tstruct proc_dir_entry *p;\n\tint err;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\n\terr = snd_info_register(card->proc_root);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!strcmp(card->id, card->proc_root->name))\n\t\treturn 0;\n\n\tif (card->proc_root_link)\n\t\treturn 0;\n\tp = proc_symlink(card->id, snd_proc_root->p, card->proc_root->name);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tcard->proc_root_link = p;\n\treturn 0;\n}\n\n \nvoid snd_info_card_id_change(struct snd_card *card)\n{\n\tmutex_lock(&info_mutex);\n\tif (card->proc_root_link) {\n\t\tproc_remove(card->proc_root_link);\n\t\tcard->proc_root_link = NULL;\n\t}\n\tif (strcmp(card->id, card->proc_root->name))\n\t\tcard->proc_root_link = proc_symlink(card->id,\n\t\t\t\t\t\t    snd_proc_root->p,\n\t\t\t\t\t\t    card->proc_root->name);\n\tmutex_unlock(&info_mutex);\n}\n\n \nvoid snd_info_card_disconnect(struct snd_card *card)\n{\n\tif (!card)\n\t\treturn;\n\n\tproc_remove(card->proc_root_link);\n\tif (card->proc_root)\n\t\tproc_remove(card->proc_root->p);\n\n\tmutex_lock(&info_mutex);\n\tif (card->proc_root)\n\t\tsnd_info_clear_entries(card->proc_root);\n\tcard->proc_root_link = NULL;\n\tcard->proc_root = NULL;\n\tmutex_unlock(&info_mutex);\n}\n\n \nint snd_info_card_free(struct snd_card *card)\n{\n\tif (!card)\n\t\treturn 0;\n\tsnd_info_free_entry(card->proc_root);\n\tcard->proc_root = NULL;\n\treturn 0;\n}\n\n\n \nint snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)\n{\n\tint c;\n\n\tif (snd_BUG_ON(!buffer))\n\t\treturn 1;\n\tif (!buffer->buffer)\n\t\treturn 1;\n\tif (len <= 0 || buffer->stop || buffer->error)\n\t\treturn 1;\n\twhile (!buffer->stop) {\n\t\tc = buffer->buffer[buffer->curr++];\n\t\tif (buffer->curr >= buffer->size)\n\t\t\tbuffer->stop = 1;\n\t\tif (c == '\\n')\n\t\t\tbreak;\n\t\tif (len > 1) {\n\t\t\tlen--;\n\t\t\t*line++ = c;\n\t\t}\n\t}\n\t*line = '\\0';\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_info_get_line);\n\n \nconst char *snd_info_get_str(char *dest, const char *src, int len)\n{\n\tint c;\n\n\twhile (*src == ' ' || *src == '\\t')\n\t\tsrc++;\n\tif (*src == '\"' || *src == '\\'') {\n\t\tc = *src++;\n\t\twhile (--len > 0 && *src && *src != c) {\n\t\t\t*dest++ = *src++;\n\t\t}\n\t\tif (*src == c)\n\t\t\tsrc++;\n\t} else {\n\t\twhile (--len > 0 && *src && *src != ' ' && *src != '\\t') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\t}\n\t*dest = 0;\n\twhile (*src == ' ' || *src == '\\t')\n\t\tsrc++;\n\treturn src;\n}\nEXPORT_SYMBOL(snd_info_get_str);\n\n \nstatic struct snd_info_entry *\nsnd_info_create_entry(const char *name, struct snd_info_entry *parent,\n\t\t      struct module *module)\n{\n\tstruct snd_info_entry *entry;\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\tentry->name = kstrdup(name, GFP_KERNEL);\n\tif (entry->name == NULL) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->mode = S_IFREG | 0444;\n\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\tmutex_init(&entry->access);\n\tINIT_LIST_HEAD(&entry->children);\n\tINIT_LIST_HEAD(&entry->list);\n\tentry->parent = parent;\n\tentry->module = module;\n\tif (parent) {\n\t\tmutex_lock(&parent->access);\n\t\tlist_add_tail(&entry->list, &parent->children);\n\t\tmutex_unlock(&parent->access);\n\t}\n\treturn entry;\n}\n\n \nstruct snd_info_entry *snd_info_create_module_entry(struct module * module,\n\t\t\t\t\t       const char *name,\n\t\t\t\t\t       struct snd_info_entry *parent)\n{\n\tif (!parent)\n\t\tparent = snd_proc_root;\n\treturn snd_info_create_entry(name, parent, module);\n}\nEXPORT_SYMBOL(snd_info_create_module_entry);\n\n \nstruct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     struct snd_info_entry * parent)\n{\n\tif (!parent)\n\t\tparent = card->proc_root;\n\treturn snd_info_create_entry(name, parent, card->module);\n}\nEXPORT_SYMBOL(snd_info_create_card_entry);\n\nstatic void snd_info_clear_entries(struct snd_info_entry *entry)\n{\n\tstruct snd_info_entry *p;\n\n\tif (!entry->p)\n\t\treturn;\n\tlist_for_each_entry(p, &entry->children, list)\n\t\tsnd_info_clear_entries(p);\n\tentry->p = NULL;\n}\n\n \nvoid snd_info_free_entry(struct snd_info_entry * entry)\n{\n\tstruct snd_info_entry *p, *n;\n\n\tif (!entry)\n\t\treturn;\n\tif (entry->p) {\n\t\tproc_remove(entry->p);\n\t\tmutex_lock(&info_mutex);\n\t\tsnd_info_clear_entries(entry);\n\t\tmutex_unlock(&info_mutex);\n\t}\n\n\t \n\tlist_for_each_entry_safe(p, n, &entry->children, list)\n\t\tsnd_info_free_entry(p);\n\n\tp = entry->parent;\n\tif (p) {\n\t\tmutex_lock(&p->access);\n\t\tlist_del(&entry->list);\n\t\tmutex_unlock(&p->access);\n\t}\n\tkfree(entry->name);\n\tif (entry->private_free)\n\t\tentry->private_free(entry);\n\tkfree(entry);\n}\nEXPORT_SYMBOL(snd_info_free_entry);\n\nstatic int __snd_info_register(struct snd_info_entry *entry)\n{\n\tstruct proc_dir_entry *root, *p = NULL;\n\n\tif (snd_BUG_ON(!entry))\n\t\treturn -ENXIO;\n\troot = entry->parent == NULL ? snd_proc_root->p : entry->parent->p;\n\tmutex_lock(&info_mutex);\n\tif (entry->p || !root)\n\t\tgoto unlock;\n\tif (S_ISDIR(entry->mode)) {\n\t\tp = proc_mkdir_mode(entry->name, entry->mode, root);\n\t\tif (!p) {\n\t\t\tmutex_unlock(&info_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tconst struct proc_ops *ops;\n\t\tif (entry->content == SNDRV_INFO_CONTENT_DATA)\n\t\t\tops = &snd_info_entry_operations;\n\t\telse\n\t\t\tops = &snd_info_text_entry_ops;\n\t\tp = proc_create_data(entry->name, entry->mode, root,\n\t\t\t\t     ops, entry);\n\t\tif (!p) {\n\t\t\tmutex_unlock(&info_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tproc_set_size(p, entry->size);\n\t}\n\tentry->p = p;\n unlock:\n\tmutex_unlock(&info_mutex);\n\treturn 0;\n}\n\n \nint snd_info_register(struct snd_info_entry *entry)\n{\n\tstruct snd_info_entry *p;\n\tint err;\n\n\tif (!entry->p) {\n\t\terr = __snd_info_register(entry);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tlist_for_each_entry(p, &entry->children, list) {\n\t\terr = snd_info_register(p);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_info_register);\n\n \nint snd_card_rw_proc_new(struct snd_card *card, const char *name,\n\t\t\t void *private_data,\n\t\t\t void (*read)(struct snd_info_entry *,\n\t\t\t\t      struct snd_info_buffer *),\n\t\t\t void (*write)(struct snd_info_entry *entry,\n\t\t\t\t       struct snd_info_buffer *buffer))\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(card, name, card->proc_root);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tsnd_info_set_text_ops(entry, private_data, read);\n\tif (write) {\n\t\tentry->mode |= 0200;\n\t\tentry->c.text.write = write;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_card_rw_proc_new);\n\n \n\nstatic void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tsnd_iprintf(buffer,\n\t\t    \"Advanced Linux Sound Architecture Driver Version k%s.\\n\",\n\t\t    init_utsname()->release);\n}\n\nstatic int __init snd_info_version_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"version\", NULL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tentry->c.text.read = snd_info_version_read;\n\treturn snd_info_register(entry);  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}