{
  "module_name": "pcm_timer.c",
  "hash_id": "24ec45bfccf6c3ecedae1e3a1357c215ef8e6303b22215b5422d12c22e20849b",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_timer.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/gcd.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/timer.h>\n\n#include \"pcm_local.h\"\n\n \n\nvoid snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream)\n{\n\tunsigned long rate, mult, fsize, l, post;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tmult = 1000000000;\n\trate = runtime->rate;\n\tif (snd_BUG_ON(!rate))\n\t\treturn;\n\tl = gcd(mult, rate);\n\tmult /= l;\n\trate /= l;\n\tfsize = runtime->period_size;\n\tif (snd_BUG_ON(!fsize))\n\t\treturn;\n\tl = gcd(rate, fsize);\n\trate /= l;\n\tfsize /= l;\n\tpost = 1;\n\twhile ((mult * fsize) / fsize != mult) {\n\t\tmult /= 2;\n\t\tpost *= 2;\n\t}\n\tif (rate == 0) {\n\t\tpcm_err(substream->pcm,\n\t\t\t\"pcm timer resolution out of range (rate = %u, period_size = %lu)\\n\",\n\t\t\truntime->rate, runtime->period_size);\n\t\truntime->timer_resolution = -1;\n\t\treturn;\n\t}\n\truntime->timer_resolution = (mult * fsize / rate) * post;\n}\n\nstatic unsigned long snd_pcm_timer_resolution(struct snd_timer * timer)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tsubstream = timer->private_data;\n\treturn substream->runtime ? substream->runtime->timer_resolution : 0;\n}\n\nstatic int snd_pcm_timer_start(struct snd_timer * timer)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tsubstream = snd_timer_chip(timer);\n\tsubstream->timer_running = 1;\n\treturn 0;\n}\n\nstatic int snd_pcm_timer_stop(struct snd_timer * timer)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tsubstream = snd_timer_chip(timer);\n\tsubstream->timer_running = 0;\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_pcm_timer =\n{\n\t.flags =\tSNDRV_TIMER_HW_AUTO | SNDRV_TIMER_HW_SLAVE,\n\t.resolution =\t0,\n\t.ticks =\t1,\n\t.c_resolution =\tsnd_pcm_timer_resolution,\n\t.start =\tsnd_pcm_timer_start,\n\t.stop =\t\tsnd_pcm_timer_stop,\n};\n\n \n\nstatic void snd_pcm_timer_free(struct snd_timer *timer)\n{\n\tstruct snd_pcm_substream *substream = timer->private_data;\n\tsubstream->timer = NULL;\n}\n\nvoid snd_pcm_timer_init(struct snd_pcm_substream *substream)\n{\n\tstruct snd_timer_id tid;\n\tstruct snd_timer *timer;\n\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.dev_class = SNDRV_TIMER_CLASS_PCM;\n\ttid.card = substream->pcm->card->number;\n\ttid.device = substream->pcm->device;\n\ttid.subdevice = (substream->number << 1) | (substream->stream & 1);\n\tif (snd_timer_new(substream->pcm->card, \"PCM\", &tid, &timer) < 0)\n\t\treturn;\n\tsprintf(timer->name, \"PCM %s %i-%i-%i\",\n\t\t\tsubstream->stream == SNDRV_PCM_STREAM_CAPTURE ?\n\t\t\t\t\"capture\" : \"playback\",\n\t\t\ttid.card, tid.device, tid.subdevice);\n\ttimer->hw = snd_pcm_timer;\n\tif (snd_device_register(timer->card, timer) < 0) {\n\t\tsnd_device_free(timer->card, timer);\n\t\treturn;\n\t}\n\ttimer->private_data = substream;\n\ttimer->private_free = snd_pcm_timer_free;\n\tsubstream->timer = timer;\n}\n\nvoid snd_pcm_timer_done(struct snd_pcm_substream *substream)\n{\n\tif (substream->timer) {\n\t\tsnd_device_free(substream->pcm->card, substream->timer);\n\t\tsubstream->timer = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}