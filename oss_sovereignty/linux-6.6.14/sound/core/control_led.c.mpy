{
  "module_name": "control_led.c",
  "hash_id": "9d579dd79741bff36c0ee8534aedcb53e7d5e4c83847dbdc825357d3d2e926fc",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/control_led.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/leds.h>\n#include <sound/core.h>\n#include <sound/control.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ALSA control interface to LED trigger code.\");\nMODULE_LICENSE(\"GPL\");\n\n#define MAX_LED (((SNDRV_CTL_ELEM_ACCESS_MIC_LED - SNDRV_CTL_ELEM_ACCESS_SPK_LED) \\\n\t\t\t>> SNDRV_CTL_ELEM_ACCESS_LED_SHIFT) + 1)\n\n#define to_led_card_dev(_dev) \\\n\tcontainer_of(_dev, struct snd_ctl_led_card, dev)\n\nenum snd_ctl_led_mode {\n\t MODE_FOLLOW_MUTE = 0,\n\t MODE_FOLLOW_ROUTE,\n\t MODE_OFF,\n\t MODE_ON,\n};\n\nstruct snd_ctl_led_card {\n\tstruct device dev;\n\tint number;\n\tstruct snd_ctl_led *led;\n};\n\nstruct snd_ctl_led {\n\tstruct device dev;\n\tstruct list_head controls;\n\tconst char *name;\n\tunsigned int group;\n\tenum led_audio trigger_type;\n\tenum snd_ctl_led_mode mode;\n\tstruct snd_ctl_led_card *cards[SNDRV_CARDS];\n};\n\nstruct snd_ctl_led_ctl {\n\tstruct list_head list;\n\tstruct snd_card *card;\n\tunsigned int access;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int index_offset;\n};\n\nstatic DEFINE_MUTEX(snd_ctl_led_mutex);\nstatic bool snd_ctl_led_card_valid[SNDRV_CARDS];\nstatic struct snd_ctl_led snd_ctl_leds[MAX_LED] = {\n\t{\n\t\t.name = \"speaker\",\n\t\t.group = (SNDRV_CTL_ELEM_ACCESS_SPK_LED >> SNDRV_CTL_ELEM_ACCESS_LED_SHIFT) - 1,\n\t\t.trigger_type = LED_AUDIO_MUTE,\n\t\t.mode = MODE_FOLLOW_MUTE,\n\t},\n\t{\n\t\t.name = \"mic\",\n\t\t.group = (SNDRV_CTL_ELEM_ACCESS_MIC_LED >> SNDRV_CTL_ELEM_ACCESS_LED_SHIFT) - 1,\n\t\t.trigger_type = LED_AUDIO_MICMUTE,\n\t\t.mode = MODE_FOLLOW_MUTE,\n\t},\n};\n\nstatic void snd_ctl_led_sysfs_add(struct snd_card *card);\nstatic void snd_ctl_led_sysfs_remove(struct snd_card *card);\n\n#define UPDATE_ROUTE(route, cb) \\\n\tdo { \\\n\t\tint route2 = (cb); \\\n\t\tif (route2 >= 0) \\\n\t\t\troute = route < 0 ? route2 : (route | route2); \\\n\t} while (0)\n\nstatic inline unsigned int access_to_group(unsigned int access)\n{\n\treturn ((access & SNDRV_CTL_ELEM_ACCESS_LED_MASK) >>\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_LED_SHIFT) - 1;\n}\n\nstatic inline unsigned int group_to_access(unsigned int group)\n{\n\treturn (group + 1) << SNDRV_CTL_ELEM_ACCESS_LED_SHIFT;\n}\n\nstatic struct snd_ctl_led *snd_ctl_led_get_by_access(unsigned int access)\n{\n\tunsigned int group = access_to_group(access);\n\tif (group >= MAX_LED)\n\t\treturn NULL;\n\treturn &snd_ctl_leds[group];\n}\n\n \nstatic int snd_ctl_led_get(struct snd_ctl_led_ctl *lctl)\n{\n\tstatic struct snd_ctl_elem_info info;\n\tstatic struct snd_ctl_elem_value value;\n\tstruct snd_kcontrol *kctl = lctl->kctl;\n\tunsigned int i;\n\tint result;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = kctl->id;\n\tinfo.id.index += lctl->index_offset;\n\tinfo.id.numid += lctl->index_offset;\n\tresult = kctl->info(kctl, &info);\n\tif (result < 0)\n\t\treturn -1;\n\tmemset(&value, 0, sizeof(value));\n\tvalue.id = info.id;\n\tresult = kctl->get(kctl, &value);\n\tif (result < 0)\n\t\treturn -1;\n\tif (info.type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\n\t    info.type == SNDRV_CTL_ELEM_TYPE_INTEGER) {\n\t\tfor (i = 0; i < info.count; i++)\n\t\t\tif (value.value.integer.value[i] != info.value.integer.min)\n\t\t\t\treturn 1;\n\t} else if (info.type == SNDRV_CTL_ELEM_TYPE_INTEGER64) {\n\t\tfor (i = 0; i < info.count; i++)\n\t\t\tif (value.value.integer64.value[i] != info.value.integer64.min)\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void snd_ctl_led_set_state(struct snd_card *card, unsigned int access,\n\t\t\t\t  struct snd_kcontrol *kctl, unsigned int ioff)\n{\n\tstruct snd_ctl_led *led;\n\tstruct snd_ctl_led_ctl *lctl;\n\tint route;\n\tbool found;\n\n\tled = snd_ctl_led_get_by_access(access);\n\tif (!led)\n\t\treturn;\n\troute = -1;\n\tfound = false;\n\tmutex_lock(&snd_ctl_led_mutex);\n\t \n\tif (card && !snd_ctl_led_card_valid[card->number]) {\n\t\tmutex_unlock(&snd_ctl_led_mutex);\n\t\treturn;\n\t}\n\tlist_for_each_entry(lctl, &led->controls, list) {\n\t\tif (lctl->kctl == kctl && lctl->index_offset == ioff)\n\t\t\tfound = true;\n\t\tUPDATE_ROUTE(route, snd_ctl_led_get(lctl));\n\t}\n\tif (!found && kctl && card) {\n\t\tlctl = kzalloc(sizeof(*lctl), GFP_KERNEL);\n\t\tif (lctl) {\n\t\t\tlctl->card = card;\n\t\t\tlctl->access = access;\n\t\t\tlctl->kctl = kctl;\n\t\t\tlctl->index_offset = ioff;\n\t\t\tlist_add(&lctl->list, &led->controls);\n\t\t\tUPDATE_ROUTE(route, snd_ctl_led_get(lctl));\n\t\t}\n\t}\n\tmutex_unlock(&snd_ctl_led_mutex);\n\tswitch (led->mode) {\n\tcase MODE_OFF:\t\troute = 1; break;\n\tcase MODE_ON:\t\troute = 0; break;\n\tcase MODE_FOLLOW_ROUTE:\tif (route >= 0) route ^= 1; break;\n\tcase MODE_FOLLOW_MUTE:\t  break;\n\t}\n\tif (route >= 0)\n\t\tledtrig_audio_set(led->trigger_type, route ? LED_OFF : LED_ON);\n}\n\nstatic struct snd_ctl_led_ctl *snd_ctl_led_find(struct snd_kcontrol *kctl, unsigned int ioff)\n{\n\tstruct list_head *controls;\n\tstruct snd_ctl_led_ctl *lctl;\n\tunsigned int group;\n\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tcontrols = &snd_ctl_leds[group].controls;\n\t\tlist_for_each_entry(lctl, controls, list)\n\t\t\tif (lctl->kctl == kctl && lctl->index_offset == ioff)\n\t\t\t\treturn lctl;\n\t}\n\treturn NULL;\n}\n\nstatic unsigned int snd_ctl_led_remove(struct snd_kcontrol *kctl, unsigned int ioff,\n\t\t\t\t       unsigned int access)\n{\n\tstruct snd_ctl_led_ctl *lctl;\n\tunsigned int ret = 0;\n\n\tmutex_lock(&snd_ctl_led_mutex);\n\tlctl = snd_ctl_led_find(kctl, ioff);\n\tif (lctl && (access == 0 || access != lctl->access)) {\n\t\tret = lctl->access;\n\t\tlist_del(&lctl->list);\n\t\tkfree(lctl);\n\t}\n\tmutex_unlock(&snd_ctl_led_mutex);\n\treturn ret;\n}\n\nstatic void snd_ctl_led_notify(struct snd_card *card, unsigned int mask,\n\t\t\t       struct snd_kcontrol *kctl, unsigned int ioff)\n{\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int access, access2;\n\n\tif (mask == SNDRV_CTL_EVENT_MASK_REMOVE) {\n\t\taccess = snd_ctl_led_remove(kctl, ioff, 0);\n\t\tif (access)\n\t\t\tsnd_ctl_led_set_state(card, access, NULL, 0);\n\t} else if (mask & SNDRV_CTL_EVENT_MASK_INFO) {\n\t\tvd = &kctl->vd[ioff];\n\t\taccess = vd->access & SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\taccess2 = snd_ctl_led_remove(kctl, ioff, access);\n\t\tif (access2)\n\t\t\tsnd_ctl_led_set_state(card, access2, NULL, 0);\n\t\tif (access)\n\t\t\tsnd_ctl_led_set_state(card, access, kctl, ioff);\n\t} else if ((mask & (SNDRV_CTL_EVENT_MASK_ADD |\n\t\t\t    SNDRV_CTL_EVENT_MASK_VALUE)) != 0) {\n\t\tvd = &kctl->vd[ioff];\n\t\taccess = vd->access & SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\tif (access)\n\t\t\tsnd_ctl_led_set_state(card, access, kctl, ioff);\n\t}\n}\n\nstatic int snd_ctl_led_set_id(int card_number, struct snd_ctl_elem_id *id,\n\t\t\t      unsigned int group, bool set)\n{\n\tstruct snd_card *card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int ioff, access, new_access;\n\tint err = 0;\n\n\tcard = snd_card_ref(card_number);\n\tif (card) {\n\t\tdown_write(&card->controls_rwsem);\n\t\tkctl = snd_ctl_find_id_locked(card, id);\n\t\tif (kctl) {\n\t\t\tioff = snd_ctl_get_ioff(kctl, id);\n\t\t\tvd = &kctl->vd[ioff];\n\t\t\taccess = vd->access & SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\t\tif (access != 0 && access != group_to_access(group)) {\n\t\t\t\terr = -EXDEV;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tnew_access = vd->access & ~SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\t\tif (set)\n\t\t\t\tnew_access |= group_to_access(group);\n\t\t\tif (new_access != vd->access) {\n\t\t\t\tvd->access = new_access;\n\t\t\t\tsnd_ctl_led_notify(card, SNDRV_CTL_EVENT_MASK_INFO, kctl, ioff);\n\t\t\t}\n\t\t} else {\n\t\t\terr = -ENOENT;\n\t\t}\nunlock:\n\t\tup_write(&card->controls_rwsem);\n\t\tsnd_card_unref(card);\n\t} else {\n\t\terr = -ENXIO;\n\t}\n\treturn err;\n}\n\nstatic void snd_ctl_led_refresh(void)\n{\n\tunsigned int group;\n\n\tfor (group = 0; group < MAX_LED; group++)\n\t\tsnd_ctl_led_set_state(NULL, group_to_access(group), NULL, 0);\n}\n\nstatic void snd_ctl_led_ctl_destroy(struct snd_ctl_led_ctl *lctl)\n{\n\tlist_del(&lctl->list);\n\tkfree(lctl);\n}\n\nstatic void snd_ctl_led_clean(struct snd_card *card)\n{\n\tunsigned int group;\n\tstruct snd_ctl_led *led;\n\tstruct snd_ctl_led_ctl *lctl;\n\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tled = &snd_ctl_leds[group];\nrepeat:\n\t\tlist_for_each_entry(lctl, &led->controls, list)\n\t\t\tif (!card || lctl->card == card) {\n\t\t\t\tsnd_ctl_led_ctl_destroy(lctl);\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t}\n}\n\nstatic int snd_ctl_led_reset(int card_number, unsigned int group)\n{\n\tstruct snd_card *card;\n\tstruct snd_ctl_led *led;\n\tstruct snd_ctl_led_ctl *lctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tbool change = false;\n\n\tcard = snd_card_ref(card_number);\n\tif (!card)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&snd_ctl_led_mutex);\n\tif (!snd_ctl_led_card_valid[card_number]) {\n\t\tmutex_unlock(&snd_ctl_led_mutex);\n\t\tsnd_card_unref(card);\n\t\treturn -ENXIO;\n\t}\n\tled = &snd_ctl_leds[group];\nrepeat:\n\tlist_for_each_entry(lctl, &led->controls, list)\n\t\tif (lctl->card == card) {\n\t\t\tvd = &lctl->kctl->vd[lctl->index_offset];\n\t\t\tvd->access &= ~group_to_access(group);\n\t\t\tsnd_ctl_led_ctl_destroy(lctl);\n\t\t\tchange = true;\n\t\t\tgoto repeat;\n\t\t}\n\tmutex_unlock(&snd_ctl_led_mutex);\n\tif (change)\n\t\tsnd_ctl_led_set_state(NULL, group_to_access(group), NULL, 0);\n\tsnd_card_unref(card);\n\treturn 0;\n}\n\nstatic void snd_ctl_led_register(struct snd_card *card)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int ioff;\n\n\tif (snd_BUG_ON(card->number < 0 ||\n\t\t       card->number >= ARRAY_SIZE(snd_ctl_led_card_valid)))\n\t\treturn;\n\tmutex_lock(&snd_ctl_led_mutex);\n\tsnd_ctl_led_card_valid[card->number] = true;\n\tmutex_unlock(&snd_ctl_led_mutex);\n\t \n\tlist_for_each_entry(kctl, &card->controls, list)\n\t\tfor (ioff = 0; ioff < kctl->count; ioff++)\n\t\t\tsnd_ctl_led_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, kctl, ioff);\n\tsnd_ctl_led_refresh();\n\tsnd_ctl_led_sysfs_add(card);\n}\n\nstatic void snd_ctl_led_disconnect(struct snd_card *card)\n{\n\tsnd_ctl_led_sysfs_remove(card);\n\tmutex_lock(&snd_ctl_led_mutex);\n\tsnd_ctl_led_card_valid[card->number] = false;\n\tsnd_ctl_led_clean(card);\n\tmutex_unlock(&snd_ctl_led_mutex);\n\tsnd_ctl_led_refresh();\n}\n\nstatic void snd_ctl_led_card_release(struct device *dev)\n{\n\tstruct snd_ctl_led_card *led_card = to_led_card_dev(dev);\n\n\tkfree(led_card);\n}\n\nstatic void snd_ctl_led_release(struct device *dev)\n{\n}\n\nstatic void snd_ctl_led_dev_release(struct device *dev)\n{\n}\n\n \n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct snd_ctl_led *led = container_of(dev, struct snd_ctl_led, dev);\n\tconst char *str = NULL;\n\n\tswitch (led->mode) {\n\tcase MODE_FOLLOW_MUTE:\tstr = \"follow-mute\"; break;\n\tcase MODE_FOLLOW_ROUTE:\tstr = \"follow-route\"; break;\n\tcase MODE_ON:\t\tstr = \"on\"; break;\n\tcase MODE_OFF:\t\tstr = \"off\"; break;\n\t}\n\treturn sysfs_emit(buf, \"%s\\n\", str);\n}\n\nstatic ssize_t mode_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct snd_ctl_led *led = container_of(dev, struct snd_ctl_led, dev);\n\tchar _buf[16];\n\tsize_t l = min(count, sizeof(_buf) - 1);\n\tenum snd_ctl_led_mode mode;\n\n\tmemcpy(_buf, buf, l);\n\t_buf[l] = '\\0';\n\tif (strstr(_buf, \"mute\"))\n\t\tmode = MODE_FOLLOW_MUTE;\n\telse if (strstr(_buf, \"route\"))\n\t\tmode = MODE_FOLLOW_ROUTE;\n\telse if (strncmp(_buf, \"off\", 3) == 0 || strncmp(_buf, \"0\", 1) == 0)\n\t\tmode = MODE_OFF;\n\telse if (strncmp(_buf, \"on\", 2) == 0 || strncmp(_buf, \"1\", 1) == 0)\n\t\tmode = MODE_ON;\n\telse\n\t\treturn count;\n\n\tmutex_lock(&snd_ctl_led_mutex);\n\tled->mode = mode;\n\tmutex_unlock(&snd_ctl_led_mutex);\n\n\tsnd_ctl_led_set_state(NULL, group_to_access(led->group), NULL, 0);\n\treturn count;\n}\n\nstatic ssize_t brightness_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct snd_ctl_led *led = container_of(dev, struct snd_ctl_led, dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", ledtrig_audio_get(led->trigger_type));\n}\n\nstatic DEVICE_ATTR_RW(mode);\nstatic DEVICE_ATTR_RO(brightness);\n\nstatic struct attribute *snd_ctl_led_dev_attrs[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_brightness.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group snd_ctl_led_dev_attr_group = {\n\t.attrs = snd_ctl_led_dev_attrs,\n};\n\nstatic const struct attribute_group *snd_ctl_led_dev_attr_groups[] = {\n\t&snd_ctl_led_dev_attr_group,\n\tNULL,\n};\n\nstatic char *find_eos(char *s)\n{\n\twhile (*s && *s != ',')\n\t\ts++;\n\tif (*s)\n\t\ts++;\n\treturn s;\n}\n\nstatic char *parse_uint(char *s, unsigned int *val)\n{\n\tunsigned long long res;\n\tif (kstrtoull(s, 10, &res))\n\t\tres = 0;\n\t*val = res;\n\treturn find_eos(s);\n}\n\nstatic char *parse_string(char *s, char *val, size_t val_size)\n{\n\tif (*s == '\"' || *s == '\\'') {\n\t\tchar c = *s;\n\t\ts++;\n\t\twhile (*s && *s != c) {\n\t\t\tif (val_size > 1) {\n\t\t\t\t*val++ = *s;\n\t\t\t\tval_size--;\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t} else {\n\t\twhile (*s && *s != ',') {\n\t\t\tif (val_size > 1) {\n\t\t\t\t*val++ = *s;\n\t\t\t\tval_size--;\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t}\n\t*val = '\\0';\n\tif (*s)\n\t\ts++;\n\treturn s;\n}\n\nstatic char *parse_iface(char *s, snd_ctl_elem_iface_t *val)\n{\n\tif (!strncasecmp(s, \"card\", 4))\n\t\t*val = SNDRV_CTL_ELEM_IFACE_CARD;\n\telse if (!strncasecmp(s, \"mixer\", 5))\n\t\t*val = SNDRV_CTL_ELEM_IFACE_MIXER;\n\treturn find_eos(s);\n}\n\n \nstatic ssize_t set_led_id(struct snd_ctl_led_card *led_card, const char *buf, size_t count,\n\t\t\t  bool attach)\n{\n\tchar buf2[256], *s, *os;\n\tstruct snd_ctl_elem_id id;\n\tint err;\n\n\tif (strscpy(buf2, buf, sizeof(buf2)) < 0)\n\t\treturn -E2BIG;\n\tmemset(&id, 0, sizeof(id));\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\ts = buf2;\n\twhile (*s) {\n\t\tos = s;\n\t\tif (!strncasecmp(s, \"numid=\", 6)) {\n\t\t\ts = parse_uint(s + 6, &id.numid);\n\t\t} else if (!strncasecmp(s, \"iface=\", 6)) {\n\t\t\ts = parse_iface(s + 6, &id.iface);\n\t\t} else if (!strncasecmp(s, \"device=\", 7)) {\n\t\t\ts = parse_uint(s + 7, &id.device);\n\t\t} else if (!strncasecmp(s, \"subdevice=\", 10)) {\n\t\t\ts = parse_uint(s + 10, &id.subdevice);\n\t\t} else if (!strncasecmp(s, \"name=\", 5)) {\n\t\t\ts = parse_string(s + 5, id.name, sizeof(id.name));\n\t\t} else if (!strncasecmp(s, \"index=\", 6)) {\n\t\t\ts = parse_uint(s + 6, &id.index);\n\t\t} else if (s == buf2) {\n\t\t\twhile (*s) {\n\t\t\t\tif (*s < '0' || *s > '9')\n\t\t\t\t\tbreak;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif (*s == '\\0')\n\t\t\t\tparse_uint(buf2, &id.numid);\n\t\t\telse {\n\t\t\t\tfor (; *s >= ' '; s++);\n\t\t\t\t*s = '\\0';\n\t\t\t\tstrscpy(id.name, buf2, sizeof(id.name));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (*s == ',')\n\t\t\ts++;\n\t\tif (s == os)\n\t\t\tbreak;\n\t}\n\n\terr = snd_ctl_led_set_id(led_card->number, &id, led_card->led->group, attach);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t attach_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct snd_ctl_led_card *led_card = container_of(dev, struct snd_ctl_led_card, dev);\n\treturn set_led_id(led_card, buf, count, true);\n}\n\nstatic ssize_t detach_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct snd_ctl_led_card *led_card = container_of(dev, struct snd_ctl_led_card, dev);\n\treturn set_led_id(led_card, buf, count, false);\n}\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct snd_ctl_led_card *led_card = container_of(dev, struct snd_ctl_led_card, dev);\n\tint err;\n\n\tif (count > 0 && buf[0] == '1') {\n\t\terr = snd_ctl_led_reset(led_card->number, led_card->led->group);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn count;\n}\n\nstatic ssize_t list_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct snd_ctl_led_card *led_card = container_of(dev, struct snd_ctl_led_card, dev);\n\tstruct snd_card *card;\n\tstruct snd_ctl_led_ctl *lctl;\n\tsize_t l = 0;\n\n\tcard = snd_card_ref(led_card->number);\n\tif (!card)\n\t\treturn -ENXIO;\n\tdown_read(&card->controls_rwsem);\n\tmutex_lock(&snd_ctl_led_mutex);\n\tif (snd_ctl_led_card_valid[led_card->number]) {\n\t\tlist_for_each_entry(lctl, &led_card->led->controls, list) {\n\t\t\tif (lctl->card != card)\n\t\t\t\tcontinue;\n\t\t\tif (l)\n\t\t\t\tl += sysfs_emit_at(buf, l, \" \");\n\t\t\tl += sysfs_emit_at(buf, l, \"%u\",\n\t\t\t\t\t   lctl->kctl->id.numid + lctl->index_offset);\n\t\t}\n\t}\n\tmutex_unlock(&snd_ctl_led_mutex);\n\tup_read(&card->controls_rwsem);\n\tsnd_card_unref(card);\n\treturn l;\n}\n\nstatic DEVICE_ATTR_WO(attach);\nstatic DEVICE_ATTR_WO(detach);\nstatic DEVICE_ATTR_WO(reset);\nstatic DEVICE_ATTR_RO(list);\n\nstatic struct attribute *snd_ctl_led_card_attrs[] = {\n\t&dev_attr_attach.attr,\n\t&dev_attr_detach.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_list.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group snd_ctl_led_card_attr_group = {\n\t.attrs = snd_ctl_led_card_attrs,\n};\n\nstatic const struct attribute_group *snd_ctl_led_card_attr_groups[] = {\n\t&snd_ctl_led_card_attr_group,\n\tNULL,\n};\n\nstatic struct device snd_ctl_led_dev;\n\nstatic void snd_ctl_led_sysfs_add(struct snd_card *card)\n{\n\tunsigned int group;\n\tstruct snd_ctl_led_card *led_card;\n\tstruct snd_ctl_led *led;\n\tchar link_name[32];\n\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tled = &snd_ctl_leds[group];\n\t\tled_card = kzalloc(sizeof(*led_card), GFP_KERNEL);\n\t\tif (!led_card)\n\t\t\tgoto cerr2;\n\t\tled_card->number = card->number;\n\t\tled_card->led = led;\n\t\tdevice_initialize(&led_card->dev);\n\t\tled_card->dev.release = snd_ctl_led_card_release;\n\t\tif (dev_set_name(&led_card->dev, \"card%d\", card->number) < 0)\n\t\t\tgoto cerr;\n\t\tled_card->dev.parent = &led->dev;\n\t\tled_card->dev.groups = snd_ctl_led_card_attr_groups;\n\t\tif (device_add(&led_card->dev))\n\t\t\tgoto cerr;\n\t\tled->cards[card->number] = led_card;\n\t\tsnprintf(link_name, sizeof(link_name), \"led-%s\", led->name);\n\t\tWARN(sysfs_create_link(&card->ctl_dev->kobj, &led_card->dev.kobj, link_name),\n\t\t\t\"can't create symlink to controlC%i device\\n\", card->number);\n\t\tWARN(sysfs_create_link(&led_card->dev.kobj, &card->card_dev.kobj, \"card\"),\n\t\t\t\"can't create symlink to card%i\\n\", card->number);\n\n\t\tcontinue;\ncerr:\n\t\tput_device(&led_card->dev);\ncerr2:\n\t\tprintk(KERN_ERR \"snd_ctl_led: unable to add card%d\", card->number);\n\t}\n}\n\nstatic void snd_ctl_led_sysfs_remove(struct snd_card *card)\n{\n\tunsigned int group;\n\tstruct snd_ctl_led_card *led_card;\n\tstruct snd_ctl_led *led;\n\tchar link_name[32];\n\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tled = &snd_ctl_leds[group];\n\t\tled_card = led->cards[card->number];\n\t\tif (!led_card)\n\t\t\tcontinue;\n\t\tsnprintf(link_name, sizeof(link_name), \"led-%s\", led->name);\n\t\tsysfs_remove_link(&card->ctl_dev->kobj, link_name);\n\t\tsysfs_remove_link(&led_card->dev.kobj, \"card\");\n\t\tdevice_unregister(&led_card->dev);\n\t\tled->cards[card->number] = NULL;\n\t}\n}\n\n \nstatic struct snd_ctl_layer_ops snd_ctl_led_lops = {\n\t.module_name = SND_CTL_LAYER_MODULE_LED,\n\t.lregister = snd_ctl_led_register,\n\t.ldisconnect = snd_ctl_led_disconnect,\n\t.lnotify = snd_ctl_led_notify,\n};\n\nstatic int __init snd_ctl_led_init(void)\n{\n\tstruct snd_ctl_led *led;\n\tunsigned int group;\n\n\tdevice_initialize(&snd_ctl_led_dev);\n\tsnd_ctl_led_dev.class = &sound_class;\n\tsnd_ctl_led_dev.release = snd_ctl_led_dev_release;\n\tdev_set_name(&snd_ctl_led_dev, \"ctl-led\");\n\tif (device_add(&snd_ctl_led_dev)) {\n\t\tput_device(&snd_ctl_led_dev);\n\t\treturn -ENOMEM;\n\t}\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tled = &snd_ctl_leds[group];\n\t\tINIT_LIST_HEAD(&led->controls);\n\t\tdevice_initialize(&led->dev);\n\t\tled->dev.parent = &snd_ctl_led_dev;\n\t\tled->dev.release = snd_ctl_led_release;\n\t\tled->dev.groups = snd_ctl_led_dev_attr_groups;\n\t\tdev_set_name(&led->dev, led->name);\n\t\tif (device_add(&led->dev)) {\n\t\t\tput_device(&led->dev);\n\t\t\tfor (; group > 0; group--) {\n\t\t\t\tled = &snd_ctl_leds[group - 1];\n\t\t\t\tdevice_unregister(&led->dev);\n\t\t\t}\n\t\t\tdevice_unregister(&snd_ctl_led_dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tsnd_ctl_register_layer(&snd_ctl_led_lops);\n\treturn 0;\n}\n\nstatic void __exit snd_ctl_led_exit(void)\n{\n\tstruct snd_ctl_led *led;\n\tstruct snd_card *card;\n\tunsigned int group, card_number;\n\n\tsnd_ctl_disconnect_layer(&snd_ctl_led_lops);\n\tfor (card_number = 0; card_number < SNDRV_CARDS; card_number++) {\n\t\tif (!snd_ctl_led_card_valid[card_number])\n\t\t\tcontinue;\n\t\tcard = snd_card_ref(card_number);\n\t\tif (card) {\n\t\t\tsnd_ctl_led_sysfs_remove(card);\n\t\t\tsnd_card_unref(card);\n\t\t}\n\t}\n\tfor (group = 0; group < MAX_LED; group++) {\n\t\tled = &snd_ctl_leds[group];\n\t\tdevice_unregister(&led->dev);\n\t}\n\tdevice_unregister(&snd_ctl_led_dev);\n\tsnd_ctl_led_clean(NULL);\n}\n\nmodule_init(snd_ctl_led_init)\nmodule_exit(snd_ctl_led_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}