{
  "module_name": "pcm_native.c",
  "hash_id": "27d9a1c5e4e0f80c01a7fcb7d6c93370bf4e4ad540c270ff95156a0a5c467b56",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/pcm_native.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/pm_qos.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/timer.h>\n#include <sound/minors.h>\n#include <linux/uio.h>\n#include <linux/delay.h>\n\n#include \"pcm_local.h\"\n\n#ifdef CONFIG_SND_DEBUG\n#define CREATE_TRACE_POINTS\n#include \"pcm_param_trace.h\"\n#else\n#define trace_hw_mask_param_enabled()\t\t0\n#define trace_hw_interval_param_enabled()\t0\n#define trace_hw_mask_param(substream, type, index, prev, curr)\n#define trace_hw_interval_param(substream, type, index, prev, curr)\n#endif\n\n \n\nstruct snd_pcm_hw_params_old {\n\tunsigned int flags;\n\tunsigned int masks[SNDRV_PCM_HW_PARAM_SUBFORMAT -\n\t\t\t   SNDRV_PCM_HW_PARAM_ACCESS + 1];\n\tstruct snd_interval intervals[SNDRV_PCM_HW_PARAM_TICK_TIME -\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS + 1];\n\tunsigned int rmask;\n\tunsigned int cmask;\n\tunsigned int info;\n\tunsigned int msbits;\n\tunsigned int rate_num;\n\tunsigned int rate_den;\n\tsnd_pcm_uframes_t fifo_size;\n\tunsigned char reserved[64];\n};\n\n#ifdef CONFIG_SND_SUPPORT_OLD_API\n#define SNDRV_PCM_IOCTL_HW_REFINE_OLD _IOWR('A', 0x10, struct snd_pcm_hw_params_old)\n#define SNDRV_PCM_IOCTL_HW_PARAMS_OLD _IOWR('A', 0x11, struct snd_pcm_hw_params_old)\n\nstatic int snd_pcm_hw_refine_old_user(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params_old __user * _oparams);\nstatic int snd_pcm_hw_params_old_user(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params_old __user * _oparams);\n#endif\nstatic int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream);\n\n \n\nstatic DECLARE_RWSEM(snd_pcm_link_rwsem);\n\nvoid snd_pcm_group_init(struct snd_pcm_group *group)\n{\n\tspin_lock_init(&group->lock);\n\tmutex_init(&group->mutex);\n\tINIT_LIST_HEAD(&group->substreams);\n\trefcount_set(&group->refs, 1);\n}\n\n \n#define DEFINE_PCM_GROUP_LOCK(action, mutex_action) \\\nstatic void snd_pcm_group_ ## action(struct snd_pcm_group *group, bool nonatomic) \\\n{ \\\n\tif (nonatomic) \\\n\t\tmutex_ ## mutex_action(&group->mutex); \\\n\telse \\\n\t\tspin_ ## action(&group->lock); \\\n}\n\nDEFINE_PCM_GROUP_LOCK(lock, lock);\nDEFINE_PCM_GROUP_LOCK(unlock, unlock);\nDEFINE_PCM_GROUP_LOCK(lock_irq, lock);\nDEFINE_PCM_GROUP_LOCK(unlock_irq, unlock);\n\n \nvoid snd_pcm_stream_lock(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_group_lock(&substream->self_group, substream->pcm->nonatomic);\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stream_lock);\n\n \nvoid snd_pcm_stream_unlock(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_group_unlock(&substream->self_group, substream->pcm->nonatomic);\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stream_unlock);\n\n \nvoid snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_group_lock_irq(&substream->self_group,\n\t\t\t       substream->pcm->nonatomic);\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stream_lock_irq);\n\nstatic void snd_pcm_stream_lock_nested(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_group *group = &substream->self_group;\n\n\tif (substream->pcm->nonatomic)\n\t\tmutex_lock_nested(&group->mutex, SINGLE_DEPTH_NESTING);\n\telse\n\t\tspin_lock_nested(&group->lock, SINGLE_DEPTH_NESTING);\n}\n\n \nvoid snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_group_unlock_irq(&substream->self_group,\n\t\t\t\t substream->pcm->nonatomic);\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stream_unlock_irq);\n\nunsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags = 0;\n\tif (substream->pcm->nonatomic)\n\t\tmutex_lock(&substream->self_group.mutex);\n\telse\n\t\tspin_lock_irqsave(&substream->self_group.lock, flags);\n\treturn flags;\n}\nEXPORT_SYMBOL_GPL(_snd_pcm_stream_lock_irqsave);\n\nunsigned long _snd_pcm_stream_lock_irqsave_nested(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags = 0;\n\tif (substream->pcm->nonatomic)\n\t\tmutex_lock_nested(&substream->self_group.mutex,\n\t\t\t\t  SINGLE_DEPTH_NESTING);\n\telse\n\t\tspin_lock_irqsave_nested(&substream->self_group.lock, flags,\n\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\treturn flags;\n}\nEXPORT_SYMBOL_GPL(_snd_pcm_stream_lock_irqsave_nested);\n\n \nvoid snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned long flags)\n{\n\tif (substream->pcm->nonatomic)\n\t\tmutex_unlock(&substream->self_group.mutex);\n\telse\n\t\tspin_unlock_irqrestore(&substream->self_group.lock, flags);\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stream_unlock_irqrestore);\n\n \nstatic int snd_pcm_ops_ioctl(struct snd_pcm_substream *substream,\n\t\t\t     unsigned cmd, void *arg)\n{\n\tif (substream->ops->ioctl)\n\t\treturn substream->ops->ioctl(substream, cmd, arg);\n\telse\n\t\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nint snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info)\n{\n\tstruct snd_pcm *pcm = substream->pcm;\n\tstruct snd_pcm_str *pstr = substream->pstr;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->card = pcm->card->number;\n\tinfo->device = pcm->device;\n\tinfo->stream = substream->stream;\n\tinfo->subdevice = substream->number;\n\tstrscpy(info->id, pcm->id, sizeof(info->id));\n\tstrscpy(info->name, pcm->name, sizeof(info->name));\n\tinfo->dev_class = pcm->dev_class;\n\tinfo->dev_subclass = pcm->dev_subclass;\n\tinfo->subdevices_count = pstr->substream_count;\n\tinfo->subdevices_avail = pstr->substream_count - pstr->substream_opened;\n\tstrscpy(info->subname, substream->name, sizeof(info->subname));\n\n\treturn 0;\n}\n\nint snd_pcm_info_user(struct snd_pcm_substream *substream,\n\t\t      struct snd_pcm_info __user * _info)\n{\n\tstruct snd_pcm_info *info;\n\tint err;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\terr = snd_pcm_info(substream, info);\n\tif (err >= 0) {\n\t\tif (copy_to_user(_info, info, sizeof(*info)))\n\t\t\terr = -EFAULT;\n\t}\n\tkfree(info);\n\treturn err;\n}\n\n \n#define PARAM_MASK_BIT(b)\t(1U << (__force int)(b))\n\nstatic bool hw_support_mmap(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dma_buffer *dmabuf;\n\n\tif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_MMAP))\n\t\treturn false;\n\n\tif (substream->ops->mmap || substream->ops->page)\n\t\treturn true;\n\n\tdmabuf = snd_pcm_get_dma_buf(substream);\n\tif (!dmabuf)\n\t\tdmabuf = &substream->dma_buffer;\n\tswitch (dmabuf->dev.type) {\n\tcase SNDRV_DMA_TYPE_UNKNOWN:\n\t\t \n\t\treturn true;\n\tcase SNDRV_DMA_TYPE_CONTINUOUS:\n\tcase SNDRV_DMA_TYPE_VMALLOC:\n\t\treturn true;\n\tdefault:\n\t\treturn dma_can_mmap(dmabuf->dev.dev);\n\t}\n}\n\nstatic int constrain_mask_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_hw_constraints *constrs =\n\t\t\t\t\t&substream->runtime->hw_constraints;\n\tstruct snd_mask *m;\n\tunsigned int k;\n\tstruct snd_mask old_mask __maybe_unused;\n\tint changed;\n\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++) {\n\t\tm = hw_param_mask(params, k);\n\t\tif (snd_mask_empty(m))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(params->rmask & PARAM_MASK_BIT(k)))\n\t\t\tcontinue;\n\n\t\tif (trace_hw_mask_param_enabled())\n\t\t\told_mask = *m;\n\n\t\tchanged = snd_mask_refine(m, constrs_mask(constrs, k));\n\t\tif (changed < 0)\n\t\t\treturn changed;\n\t\tif (changed == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\ttrace_hw_mask_param(substream, k, 0, &old_mask, m);\n\t\tparams->cmask |= PARAM_MASK_BIT(k);\n\t}\n\n\treturn 0;\n}\n\nstatic int constrain_interval_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_hw_constraints *constrs =\n\t\t\t\t\t&substream->runtime->hw_constraints;\n\tstruct snd_interval *i;\n\tunsigned int k;\n\tstruct snd_interval old_interval __maybe_unused;\n\tint changed;\n\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++) {\n\t\ti = hw_param_interval(params, k);\n\t\tif (snd_interval_empty(i))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(params->rmask & PARAM_MASK_BIT(k)))\n\t\t\tcontinue;\n\n\t\tif (trace_hw_interval_param_enabled())\n\t\t\told_interval = *i;\n\n\t\tchanged = snd_interval_refine(i, constrs_interval(constrs, k));\n\t\tif (changed < 0)\n\t\t\treturn changed;\n\t\tif (changed == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\ttrace_hw_interval_param(substream, k, 0, &old_interval, i);\n\t\tparams->cmask |= PARAM_MASK_BIT(k);\n\t}\n\n\treturn 0;\n}\n\nstatic int constrain_params_by_rules(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_hw_constraints *constrs =\n\t\t\t\t\t&substream->runtime->hw_constraints;\n\tunsigned int k;\n\tunsigned int *rstamps;\n\tunsigned int vstamps[SNDRV_PCM_HW_PARAM_LAST_INTERVAL + 1];\n\tunsigned int stamp;\n\tstruct snd_pcm_hw_rule *r;\n\tunsigned int d;\n\tstruct snd_mask old_mask __maybe_unused;\n\tstruct snd_interval old_interval __maybe_unused;\n\tbool again;\n\tint changed, err = 0;\n\n\t \n\trstamps = kcalloc(constrs->rules_num, sizeof(unsigned int), GFP_KERNEL);\n\tif (!rstamps)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (k = 0; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\n\t\tvstamps[k] = (params->rmask & PARAM_MASK_BIT(k)) ? 1 : 0;\n\n\t \n\tstamp = 2;\nretry:\n\t \n\tagain = false;\n\tfor (k = 0; k < constrs->rules_num; k++) {\n\t\tr = &constrs->rules[k];\n\n\t\t \n\t\tif (r->cond && !(r->cond & params->flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (d = 0; r->deps[d] >= 0; d++) {\n\t\t\tif (vstamps[r->deps[d]] > rstamps[k])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r->deps[d] < 0)\n\t\t\tcontinue;\n\n\t\tif (trace_hw_mask_param_enabled()) {\n\t\t\tif (hw_is_mask(r->var))\n\t\t\t\told_mask = *hw_param_mask(params, r->var);\n\t\t}\n\t\tif (trace_hw_interval_param_enabled()) {\n\t\t\tif (hw_is_interval(r->var))\n\t\t\t\told_interval = *hw_param_interval(params, r->var);\n\t\t}\n\n\t\tchanged = r->func(params, r);\n\t\tif (changed < 0) {\n\t\t\terr = changed;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (changed && r->var >= 0) {\n\t\t\tif (hw_is_mask(r->var)) {\n\t\t\t\ttrace_hw_mask_param(substream, r->var,\n\t\t\t\t\tk + 1, &old_mask,\n\t\t\t\t\thw_param_mask(params, r->var));\n\t\t\t}\n\t\t\tif (hw_is_interval(r->var)) {\n\t\t\t\ttrace_hw_interval_param(substream, r->var,\n\t\t\t\t\tk + 1, &old_interval,\n\t\t\t\t\thw_param_interval(params, r->var));\n\t\t\t}\n\n\t\t\tparams->cmask |= PARAM_MASK_BIT(r->var);\n\t\t\tvstamps[r->var] = stamp;\n\t\t\tagain = true;\n\t\t}\n\n\t\trstamps[k] = stamp++;\n\t}\n\n\t \n\tif (again)\n\t\tgoto retry;\n\n out:\n\tkfree(rstamps);\n\treturn err;\n}\n\nstatic int fixup_unreferenced_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tconst struct snd_interval *i;\n\tconst struct snd_mask *m;\n\tint err;\n\n\tif (!params->msbits) {\n\t\ti = hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\n\t\tif (snd_interval_single(i))\n\t\t\tparams->msbits = snd_interval_value(i);\n\t}\n\n\tif (!params->rate_den) {\n\t\ti = hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\tif (snd_interval_single(i)) {\n\t\t\tparams->rate_num = snd_interval_value(i);\n\t\t\tparams->rate_den = 1;\n\t\t}\n\t}\n\n\tif (!params->fifo_size) {\n\t\tm = hw_param_mask_c(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\t\ti = hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\t\tif (snd_mask_single(m) && snd_interval_single(i)) {\n\t\t\terr = snd_pcm_ops_ioctl(substream,\n\t\t\t\t\t\tSNDRV_PCM_IOCTL1_FIFO_SIZE,\n\t\t\t\t\t\tparams);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!params->info) {\n\t\tparams->info = substream->runtime->hw.info;\n\t\tparams->info &= ~(SNDRV_PCM_INFO_FIFO_IN_FRAMES |\n\t\t\t\t  SNDRV_PCM_INFO_DRAIN_TRIGGER);\n\t\tif (!hw_support_mmap(substream))\n\t\t\tparams->info &= ~(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID);\n\t}\n\n\treturn 0;\n}\n\nint snd_pcm_hw_refine(struct snd_pcm_substream *substream,\n\t\t      struct snd_pcm_hw_params *params)\n{\n\tint err;\n\n\tparams->info = 0;\n\tparams->fifo_size = 0;\n\tif (params->rmask & PARAM_MASK_BIT(SNDRV_PCM_HW_PARAM_SAMPLE_BITS))\n\t\tparams->msbits = 0;\n\tif (params->rmask & PARAM_MASK_BIT(SNDRV_PCM_HW_PARAM_RATE)) {\n\t\tparams->rate_num = 0;\n\t\tparams->rate_den = 0;\n\t}\n\n\terr = constrain_mask_params(substream, params);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = constrain_interval_params(substream, params);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = constrain_params_by_rules(substream, params);\n\tif (err < 0)\n\t\treturn err;\n\n\tparams->rmask = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_hw_refine);\n\nstatic int snd_pcm_hw_refine_user(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params __user * _params)\n{\n\tstruct snd_pcm_hw_params *params;\n\tint err;\n\n\tparams = memdup_user(_params, sizeof(*params));\n\tif (IS_ERR(params))\n\t\treturn PTR_ERR(params);\n\n\terr = snd_pcm_hw_refine(substream, params);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = fixup_unreferenced_params(substream, params);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (copy_to_user(_params, params, sizeof(*params)))\n\t\terr = -EFAULT;\nend:\n\tkfree(params);\n\treturn err;\n}\n\nstatic int period_to_usecs(struct snd_pcm_runtime *runtime)\n{\n\tint usecs;\n\n\tif (! runtime->rate)\n\t\treturn -1;  \n\n\t \n\tusecs = (750000 / runtime->rate) * runtime->period_size;\n\tusecs += ((750000 % runtime->rate) * runtime->period_size) /\n\t\truntime->rate;\n\n\treturn usecs;\n}\n\nstatic void snd_pcm_set_state(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_state_t state)\n{\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (substream->runtime->state != SNDRV_PCM_STATE_DISCONNECTED)\n\t\t__snd_pcm_set_state(substream->runtime, state);\n\tsnd_pcm_stream_unlock_irq(substream);\n}\n\nstatic inline void snd_pcm_timer_notify(struct snd_pcm_substream *substream,\n\t\t\t\t\tint event)\n{\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer)\n\t\tsnd_timer_notify(substream->timer, event,\n\t\t\t\t\t&substream->runtime->trigger_tstamp);\n#endif\n}\n\nvoid snd_pcm_sync_stop(struct snd_pcm_substream *substream, bool sync_irq)\n{\n\tif (substream->runtime && substream->runtime->stop_operating) {\n\t\tsubstream->runtime->stop_operating = false;\n\t\tif (substream->ops && substream->ops->sync_stop)\n\t\t\tsubstream->ops->sync_stop(substream);\n\t\telse if (sync_irq && substream->pcm->card->sync_irq > 0)\n\t\t\tsynchronize_irq(substream->pcm->card->sync_irq);\n\t}\n}\n\n \nstatic int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstatic const int vars[] = {\n\t\tSNDRV_PCM_HW_PARAM_ACCESS,\n\t\tSNDRV_PCM_HW_PARAM_FORMAT,\n\t\tSNDRV_PCM_HW_PARAM_SUBFORMAT,\n\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\tSNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\tSNDRV_PCM_HW_PARAM_TICK_TIME,\n\t\t-1\n\t};\n\tconst int *v;\n\tstruct snd_mask old_mask __maybe_unused;\n\tstruct snd_interval old_interval __maybe_unused;\n\tint changed;\n\n\tfor (v = vars; *v != -1; v++) {\n\t\t \n\t\tif (trace_hw_mask_param_enabled()) {\n\t\t\tif (hw_is_mask(*v))\n\t\t\t\told_mask = *hw_param_mask(params, *v);\n\t\t}\n\t\tif (trace_hw_interval_param_enabled()) {\n\t\t\tif (hw_is_interval(*v))\n\t\t\t\told_interval = *hw_param_interval(params, *v);\n\t\t}\n\t\tif (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)\n\t\t\tchanged = snd_pcm_hw_param_first(pcm, params, *v, NULL);\n\t\telse\n\t\t\tchanged = snd_pcm_hw_param_last(pcm, params, *v, NULL);\n\t\tif (changed < 0)\n\t\t\treturn changed;\n\t\tif (changed == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (hw_is_mask(*v)) {\n\t\t\ttrace_hw_mask_param(pcm, *v, 0, &old_mask,\n\t\t\t\t\t    hw_param_mask(params, *v));\n\t\t}\n\t\tif (hw_is_interval(*v)) {\n\t\t\ttrace_hw_interval_param(pcm, *v, 0, &old_interval,\n\t\t\t\t\t\thw_param_interval(params, *v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_pcm_buffer_access_lock(struct snd_pcm_runtime *runtime)\n{\n\tif (!atomic_dec_unless_positive(&runtime->buffer_accessing))\n\t\treturn -EBUSY;\n\tmutex_lock(&runtime->buffer_mutex);\n\treturn 0;  \n}\n\n \nstatic void snd_pcm_buffer_access_unlock(struct snd_pcm_runtime *runtime)\n{\n\tmutex_unlock(&runtime->buffer_mutex);\n\tatomic_inc(&runtime->buffer_accessing);\n}\n\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\n#define is_oss_stream(substream)\t((substream)->oss.oss)\n#else\n#define is_oss_stream(substream)\tfalse\n#endif\n\nstatic int snd_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint err, usecs;\n\tunsigned int bits;\n\tsnd_pcm_uframes_t frames;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\terr = snd_pcm_buffer_access_lock(runtime);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tif (!is_oss_stream(substream) &&\n\t\t    atomic_read(&substream->mmap_count))\n\t\t\terr = -EBADFD;\n\t\tbreak;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tbreak;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (err)\n\t\tgoto unlock;\n\n\tsnd_pcm_sync_stop(substream, true);\n\n\tparams->rmask = ~0U;\n\terr = snd_pcm_hw_refine(substream, params);\n\tif (err < 0)\n\t\tgoto _error;\n\n\terr = snd_pcm_hw_params_choose(substream, params);\n\tif (err < 0)\n\t\tgoto _error;\n\n\terr = fixup_unreferenced_params(substream, params);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tif (substream->managed_buffer_alloc) {\n\t\terr = snd_pcm_lib_malloc_pages(substream,\n\t\t\t\t\t       params_buffer_bytes(params));\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\truntime->buffer_changed = err > 0;\n\t}\n\n\tif (substream->ops->hw_params != NULL) {\n\t\terr = substream->ops->hw_params(substream, params);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t}\n\n\truntime->access = params_access(params);\n\truntime->format = params_format(params);\n\truntime->subformat = params_subformat(params);\n\truntime->channels = params_channels(params);\n\truntime->rate = params_rate(params);\n\truntime->period_size = params_period_size(params);\n\truntime->periods = params_periods(params);\n\truntime->buffer_size = params_buffer_size(params);\n\truntime->info = params->info;\n\truntime->rate_num = params->rate_num;\n\truntime->rate_den = params->rate_den;\n\truntime->no_period_wakeup =\n\t\t\t(params->info & SNDRV_PCM_INFO_NO_PERIOD_WAKEUP) &&\n\t\t\t(params->flags & SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP);\n\n\tbits = snd_pcm_format_physical_width(runtime->format);\n\truntime->sample_bits = bits;\n\tbits *= runtime->channels;\n\truntime->frame_bits = bits;\n\tframes = 1;\n\twhile (bits % 8 != 0) {\n\t\tbits *= 2;\n\t\tframes *= 2;\n\t}\n\truntime->byte_align = bits / 8;\n\truntime->min_align = frames;\n\n\t \n\truntime->tstamp_mode = SNDRV_PCM_TSTAMP_NONE;\n\truntime->period_step = 1;\n\truntime->control->avail_min = runtime->period_size;\n\truntime->start_threshold = 1;\n\truntime->stop_threshold = runtime->buffer_size;\n\truntime->silence_threshold = 0;\n\truntime->silence_size = 0;\n\truntime->boundary = runtime->buffer_size;\n\twhile (runtime->boundary * 2 <= LONG_MAX - runtime->buffer_size)\n\t\truntime->boundary *= 2;\n\n\t \n\tif (runtime->dma_area && !substream->ops->copy) {\n\t\tsize_t size = runtime->dma_bytes;\n\n\t\tif (runtime->info & SNDRV_PCM_INFO_MMAP)\n\t\t\tsize = PAGE_ALIGN(size);\n\t\tmemset(runtime->dma_area, 0, size);\n\t}\n\n\tsnd_pcm_timer_resolution_change(substream);\n\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_SETUP);\n\n\tif (cpu_latency_qos_request_active(&substream->latency_pm_qos_req))\n\t\tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n\tusecs = period_to_usecs(runtime);\n\tif (usecs >= 0)\n\t\tcpu_latency_qos_add_request(&substream->latency_pm_qos_req,\n\t\t\t\t\t    usecs);\n\terr = 0;\n _error:\n\tif (err) {\n\t\t \n\t\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\n\t\tif (substream->ops->hw_free != NULL)\n\t\t\tsubstream->ops->hw_free(substream);\n\t\tif (substream->managed_buffer_alloc)\n\t\t\tsnd_pcm_lib_free_pages(substream);\n\t}\n unlock:\n\tsnd_pcm_buffer_access_unlock(runtime);\n\treturn err;\n}\n\nstatic int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params __user * _params)\n{\n\tstruct snd_pcm_hw_params *params;\n\tint err;\n\n\tparams = memdup_user(_params, sizeof(*params));\n\tif (IS_ERR(params))\n\t\treturn PTR_ERR(params);\n\n\terr = snd_pcm_hw_params(substream, params);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (copy_to_user(_params, params, sizeof(*params)))\n\t\terr = -EFAULT;\nend:\n\tkfree(params);\n\treturn err;\n}\n\nstatic int do_hw_free(struct snd_pcm_substream *substream)\n{\n\tint result = 0;\n\n\tsnd_pcm_sync_stop(substream, true);\n\tif (substream->ops->hw_free)\n\t\tresult = substream->ops->hw_free(substream);\n\tif (substream->managed_buffer_alloc)\n\t\tsnd_pcm_lib_free_pages(substream);\n\treturn result;\n}\n\nstatic int snd_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint result = 0;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tresult = snd_pcm_buffer_access_lock(runtime);\n\tif (result < 0)\n\t\treturn result;\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tif (atomic_read(&substream->mmap_count))\n\t\t\tresult = -EBADFD;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EBADFD;\n\t\tbreak;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (result)\n\t\tgoto unlock;\n\tresult = do_hw_free(substream);\n\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\n\tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n unlock:\n\tsnd_pcm_buffer_access_unlock(runtime);\n\treturn result;\n}\n\nstatic int snd_pcm_sw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_sw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint err;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\treturn -EBADFD;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\n\tif (params->tstamp_mode < 0 ||\n\t    params->tstamp_mode > SNDRV_PCM_TSTAMP_LAST)\n\t\treturn -EINVAL;\n\tif (params->proto >= SNDRV_PROTOCOL_VERSION(2, 0, 12) &&\n\t    params->tstamp_type > SNDRV_PCM_TSTAMP_TYPE_LAST)\n\t\treturn -EINVAL;\n\tif (params->avail_min == 0)\n\t\treturn -EINVAL;\n\tif (params->silence_size >= runtime->boundary) {\n\t\tif (params->silence_threshold != 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (params->silence_size > params->silence_threshold)\n\t\t\treturn -EINVAL;\n\t\tif (params->silence_threshold > runtime->buffer_size)\n\t\t\treturn -EINVAL;\n\t}\n\terr = 0;\n\tsnd_pcm_stream_lock_irq(substream);\n\truntime->tstamp_mode = params->tstamp_mode;\n\tif (params->proto >= SNDRV_PROTOCOL_VERSION(2, 0, 12))\n\t\truntime->tstamp_type = params->tstamp_type;\n\truntime->period_step = params->period_step;\n\truntime->control->avail_min = params->avail_min;\n\truntime->start_threshold = params->start_threshold;\n\truntime->stop_threshold = params->stop_threshold;\n\truntime->silence_threshold = params->silence_threshold;\n\truntime->silence_size = params->silence_size;\n        params->boundary = runtime->boundary;\n\tif (snd_pcm_running(substream)) {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t\t    runtime->silence_size > 0)\n\t\t\tsnd_pcm_playback_silence(substream, ULONG_MAX);\n\t\terr = snd_pcm_update_state(substream, runtime);\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn err;\n}\n\nstatic int snd_pcm_sw_params_user(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_sw_params __user * _params)\n{\n\tstruct snd_pcm_sw_params params;\n\tint err;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\terr = snd_pcm_sw_params(substream, &params);\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}\n\nstatic inline snd_pcm_uframes_t\nsnd_pcm_calc_delay(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_uframes_t delay;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdelay = snd_pcm_playback_hw_avail(substream->runtime);\n\telse\n\t\tdelay = snd_pcm_capture_avail(substream->runtime);\n\treturn delay + substream->runtime->delay;\n}\n\nint snd_pcm_status64(struct snd_pcm_substream *substream,\n\t\t     struct snd_pcm_status64 *status)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\n\tsnd_pcm_unpack_audio_tstamp_config(status->audio_tstamp_data,\n\t\t\t\t\t&runtime->audio_tstamp_config);\n\n\t \n\tif (runtime->audio_tstamp_config.type_requested ==\n\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT) {\n\t\tif (runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK)\n\t\t\truntime->audio_tstamp_config.type_requested =\n\t\t\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK;\n\t\telse\n\t\t\truntime->audio_tstamp_config.type_requested =\n\t\t\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT;\n\t\truntime->audio_tstamp_report.valid = 0;\n\t} else\n\t\truntime->audio_tstamp_report.valid = 1;\n\n\tstatus->state = runtime->state;\n\tstatus->suspended_state = runtime->suspended_state;\n\tif (status->state == SNDRV_PCM_STATE_OPEN)\n\t\tgoto _end;\n\tstatus->trigger_tstamp_sec = runtime->trigger_tstamp.tv_sec;\n\tstatus->trigger_tstamp_nsec = runtime->trigger_tstamp.tv_nsec;\n\tif (snd_pcm_running(substream)) {\n\t\tsnd_pcm_update_hw_ptr(substream);\n\t\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\t\tstatus->tstamp_sec = runtime->status->tstamp.tv_sec;\n\t\t\tstatus->tstamp_nsec =\n\t\t\t\truntime->status->tstamp.tv_nsec;\n\t\t\tstatus->driver_tstamp_sec =\n\t\t\t\truntime->driver_tstamp.tv_sec;\n\t\t\tstatus->driver_tstamp_nsec =\n\t\t\t\truntime->driver_tstamp.tv_nsec;\n\t\t\tstatus->audio_tstamp_sec =\n\t\t\t\truntime->status->audio_tstamp.tv_sec;\n\t\t\tstatus->audio_tstamp_nsec =\n\t\t\t\truntime->status->audio_tstamp.tv_nsec;\n\t\t\tif (runtime->audio_tstamp_report.valid == 1)\n\t\t\t\t \n\t\t\t\tsnd_pcm_pack_audio_tstamp_report(&status->audio_tstamp_data,\n\t\t\t\t\t\t\t\t&status->audio_tstamp_accuracy,\n\t\t\t\t\t\t\t\t&runtime->audio_tstamp_report);\n\n\t\t\tgoto _tstamp_end;\n\t\t}\n\t} else {\n\t\t \n\t\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\t\tstruct timespec64 tstamp;\n\n\t\t\tsnd_pcm_gettime(runtime, &tstamp);\n\t\t\tstatus->tstamp_sec = tstamp.tv_sec;\n\t\t\tstatus->tstamp_nsec = tstamp.tv_nsec;\n\t\t}\n\t}\n _tstamp_end:\n\tstatus->appl_ptr = runtime->control->appl_ptr;\n\tstatus->hw_ptr = runtime->status->hw_ptr;\n\tstatus->avail = snd_pcm_avail(substream);\n\tstatus->delay = snd_pcm_running(substream) ?\n\t\tsnd_pcm_calc_delay(substream) : 0;\n\tstatus->avail_max = runtime->avail_max;\n\tstatus->overrange = runtime->overrange;\n\truntime->avail_max = 0;\n\truntime->overrange = 0;\n _end:\n \tsnd_pcm_stream_unlock_irq(substream);\n\treturn 0;\n}\n\nstatic int snd_pcm_status_user64(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_status64 __user * _status,\n\t\t\t\t bool ext)\n{\n\tstruct snd_pcm_status64 status;\n\tint res;\n\n\tmemset(&status, 0, sizeof(status));\n\t \n\tif (ext && get_user(status.audio_tstamp_data,\n\t\t\t\t(u32 __user *)(&_status->audio_tstamp_data)))\n\t\treturn -EFAULT;\n\tres = snd_pcm_status64(substream, &status);\n\tif (res < 0)\n\t\treturn res;\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_pcm_status_user32(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_status32 __user * _status,\n\t\t\t\t bool ext)\n{\n\tstruct snd_pcm_status64 status64;\n\tstruct snd_pcm_status32 status32;\n\tint res;\n\n\tmemset(&status64, 0, sizeof(status64));\n\tmemset(&status32, 0, sizeof(status32));\n\t \n\tif (ext && get_user(status64.audio_tstamp_data,\n\t\t\t    (u32 __user *)(&_status->audio_tstamp_data)))\n\t\treturn -EFAULT;\n\tres = snd_pcm_status64(substream, &status64);\n\tif (res < 0)\n\t\treturn res;\n\n\tstatus32 = (struct snd_pcm_status32) {\n\t\t.state = status64.state,\n\t\t.trigger_tstamp_sec = status64.trigger_tstamp_sec,\n\t\t.trigger_tstamp_nsec = status64.trigger_tstamp_nsec,\n\t\t.tstamp_sec = status64.tstamp_sec,\n\t\t.tstamp_nsec = status64.tstamp_nsec,\n\t\t.appl_ptr = status64.appl_ptr,\n\t\t.hw_ptr = status64.hw_ptr,\n\t\t.delay = status64.delay,\n\t\t.avail = status64.avail,\n\t\t.avail_max = status64.avail_max,\n\t\t.overrange = status64.overrange,\n\t\t.suspended_state = status64.suspended_state,\n\t\t.audio_tstamp_data = status64.audio_tstamp_data,\n\t\t.audio_tstamp_sec = status64.audio_tstamp_sec,\n\t\t.audio_tstamp_nsec = status64.audio_tstamp_nsec,\n\t\t.driver_tstamp_sec = status64.audio_tstamp_sec,\n\t\t.driver_tstamp_nsec = status64.audio_tstamp_nsec,\n\t\t.audio_tstamp_accuracy = status64.audio_tstamp_accuracy,\n\t};\n\n\tif (copy_to_user(_status, &status32, sizeof(status32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_pcm_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_channel_info * info)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int channel;\n\t\n\tchannel = info->channel;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\treturn -EBADFD;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (channel >= runtime->channels)\n\t\treturn -EINVAL;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->channel = channel;\n\treturn snd_pcm_ops_ioctl(substream, SNDRV_PCM_IOCTL1_CHANNEL_INFO, info);\n}\n\nstatic int snd_pcm_channel_info_user(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_channel_info __user * _info)\n{\n\tstruct snd_pcm_channel_info info;\n\tint res;\n\t\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tres = snd_pcm_channel_info(substream, &info);\n\tif (res < 0)\n\t\treturn res;\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void snd_pcm_trigger_tstamp(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->trigger_master == NULL)\n\t\treturn;\n\tif (runtime->trigger_master == substream) {\n\t\tif (!runtime->trigger_tstamp_latched)\n\t\t\tsnd_pcm_gettime(runtime, &runtime->trigger_tstamp);\n\t} else {\n\t\tsnd_pcm_trigger_tstamp(runtime->trigger_master);\n\t\truntime->trigger_tstamp = runtime->trigger_master->runtime->trigger_tstamp;\n\t}\n\truntime->trigger_master = NULL;\n}\n\n#define ACTION_ARG_IGNORE\t(__force snd_pcm_state_t)0\n\nstruct action_ops {\n\tint (*pre_action)(struct snd_pcm_substream *substream,\n\t\t\t  snd_pcm_state_t state);\n\tint (*do_action)(struct snd_pcm_substream *substream,\n\t\t\t snd_pcm_state_t state);\n\tvoid (*undo_action)(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state);\n\tvoid (*post_action)(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state);\n};\n\n \nstatic int snd_pcm_action_group(const struct action_ops *ops,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tsnd_pcm_state_t state,\n\t\t\t\tbool stream_lock)\n{\n\tstruct snd_pcm_substream *s = NULL;\n\tstruct snd_pcm_substream *s1;\n\tint res = 0, depth = 1;\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s != substream) {\n\t\t\tif (!stream_lock)\n\t\t\t\tmutex_lock_nested(&s->runtime->buffer_mutex, depth);\n\t\t\telse if (s->pcm->nonatomic)\n\t\t\t\tmutex_lock_nested(&s->self_group.mutex, depth);\n\t\t\telse\n\t\t\t\tspin_lock_nested(&s->self_group.lock, depth);\n\t\t\tdepth++;\n\t\t}\n\t\tres = ops->pre_action(s, state);\n\t\tif (res < 0)\n\t\t\tgoto _unlock;\n\t}\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tres = ops->do_action(s, state);\n\t\tif (res < 0) {\n\t\t\tif (ops->undo_action) {\n\t\t\t\tsnd_pcm_group_for_each_entry(s1, substream) {\n\t\t\t\t\tif (s1 == s)  \n\t\t\t\t\t\tbreak;\n\t\t\t\t\tops->undo_action(s1, state);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = NULL;  \n\t\t\tgoto _unlock;\n\t\t}\n\t}\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tops->post_action(s, state);\n\t}\n _unlock:\n\t \n\tsnd_pcm_group_for_each_entry(s1, substream) {\n\t\tif (s1 != substream) {\n\t\t\tif (!stream_lock)\n\t\t\t\tmutex_unlock(&s1->runtime->buffer_mutex);\n\t\t\telse if (s1->pcm->nonatomic)\n\t\t\t\tmutex_unlock(&s1->self_group.mutex);\n\t\t\telse\n\t\t\t\tspin_unlock(&s1->self_group.lock);\n\t\t}\n\t\tif (s1 == s)\t \n\t\t\tbreak;\n\t}\n\treturn res;\n}\n\n \nstatic int snd_pcm_action_single(const struct action_ops *ops,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_state_t state)\n{\n\tint res;\n\t\n\tres = ops->pre_action(substream, state);\n\tif (res < 0)\n\t\treturn res;\n\tres = ops->do_action(substream, state);\n\tif (res == 0)\n\t\tops->post_action(substream, state);\n\telse if (ops->undo_action)\n\t\tops->undo_action(substream, state);\n\treturn res;\n}\n\nstatic void snd_pcm_group_assign(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_group *new_group)\n{\n\tsubstream->group = new_group;\n\tlist_move(&substream->link_list, &new_group->substreams);\n}\n\n \nstatic void snd_pcm_group_unref(struct snd_pcm_group *group,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tbool do_free;\n\n\tif (!group)\n\t\treturn;\n\tdo_free = refcount_dec_and_test(&group->refs);\n\tsnd_pcm_group_unlock(group, substream->pcm->nonatomic);\n\tif (do_free)\n\t\tkfree(group);\n}\n\n \nstatic struct snd_pcm_group *\nsnd_pcm_stream_group_ref(struct snd_pcm_substream *substream)\n{\n\tbool nonatomic = substream->pcm->nonatomic;\n\tstruct snd_pcm_group *group;\n\tbool trylock;\n\n\tfor (;;) {\n\t\tif (!snd_pcm_stream_linked(substream))\n\t\t\treturn NULL;\n\t\tgroup = substream->group;\n\t\t \n\t\trefcount_inc(&group->refs);\n\n\t\ttrylock = nonatomic ? mutex_trylock(&group->mutex) :\n\t\t\tspin_trylock(&group->lock);\n\t\tif (trylock)\n\t\t\tbreak;  \n\n\t\t \n\t\tsnd_pcm_stream_unlock(substream);\n\t\tsnd_pcm_group_lock(group, nonatomic);\n\t\tsnd_pcm_stream_lock(substream);\n\n\t\t \n\t\tif (substream->group == group)\n\t\t\tbreak;  \n\t\t \n\t\tsnd_pcm_group_unref(group, substream);\n\t}\n\treturn group;\n}\n\n \nstatic int snd_pcm_action(const struct action_ops *ops,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  snd_pcm_state_t state)\n{\n\tstruct snd_pcm_group *group;\n\tint res;\n\n\tgroup = snd_pcm_stream_group_ref(substream);\n\tif (group)\n\t\tres = snd_pcm_action_group(ops, substream, state, true);\n\telse\n\t\tres = snd_pcm_action_single(ops, substream, state);\n\tsnd_pcm_group_unref(group, substream);\n\treturn res;\n}\n\n \nstatic int snd_pcm_action_lock_irq(const struct action_ops *ops,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   snd_pcm_state_t state)\n{\n\tint res;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tres = snd_pcm_action(ops, substream, state);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn res;\n}\n\n \nstatic int snd_pcm_action_nonatomic(const struct action_ops *ops,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    snd_pcm_state_t state)\n{\n\tint res;\n\n\t \n\tdown_read(&snd_pcm_link_rwsem);\n\tres = snd_pcm_buffer_access_lock(substream->runtime);\n\tif (res < 0)\n\t\tgoto unlock;\n\tif (snd_pcm_stream_linked(substream))\n\t\tres = snd_pcm_action_group(ops, substream, state, false);\n\telse\n\t\tres = snd_pcm_action_single(ops, substream, state);\n\tsnd_pcm_buffer_access_unlock(substream->runtime);\n unlock:\n\tup_read(&snd_pcm_link_rwsem);\n\treturn res;\n}\n\n \nstatic int snd_pcm_pre_start(struct snd_pcm_substream *substream,\n\t\t\t     snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->state != SNDRV_PCM_STATE_PREPARED)\n\t\treturn -EBADFD;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    !snd_pcm_playback_data(substream))\n\t\treturn -EPIPE;\n\truntime->trigger_tstamp_latched = false;\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_start(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state)\n{\n\tint err;\n\n\tif (substream->runtime->trigger_master != substream)\n\t\treturn 0;\n\terr = substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);\n\t \n\tif (err == -EPIPE)\n\t\t__snd_pcm_set_state(substream->runtime, SNDRV_PCM_STATE_XRUN);\n\treturn err;\n}\n\nstatic void snd_pcm_undo_start(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream) {\n\t\tsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);\n\t\tsubstream->runtime->stop_operating = true;\n\t}\n}\n\nstatic void snd_pcm_post_start(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_trigger_tstamp(substream);\n\truntime->hw_ptr_jiffies = jiffies;\n\truntime->hw_ptr_buffer_jiffies = (runtime->buffer_size * HZ) / \n\t\t\t\t\t\t\t    runtime->rate;\n\t__snd_pcm_set_state(runtime, state);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    runtime->silence_size > 0)\n\t\tsnd_pcm_playback_silence(substream, ULONG_MAX);\n\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MSTART);\n}\n\nstatic const struct action_ops snd_pcm_action_start = {\n\t.pre_action = snd_pcm_pre_start,\n\t.do_action = snd_pcm_do_start,\n\t.undo_action = snd_pcm_undo_start,\n\t.post_action = snd_pcm_post_start\n};\n\n \nint snd_pcm_start(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_action(&snd_pcm_action_start, substream,\n\t\t\t      SNDRV_PCM_STATE_RUNNING);\n}\n\n \nstatic int snd_pcm_start_lock_irq(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_action_lock_irq(&snd_pcm_action_start, substream,\n\t\t\t\t       SNDRV_PCM_STATE_RUNNING);\n}\n\n \nstatic int snd_pcm_pre_stop(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_stop(struct snd_pcm_substream *substream,\n\t\t\t   snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream &&\n\t    snd_pcm_running(substream)) {\n\t\tsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);\n\t\tsubstream->runtime->stop_operating = true;\n\t}\n\treturn 0;  \n}\n\nstatic void snd_pcm_post_stop(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->state != state) {\n\t\tsnd_pcm_trigger_tstamp(substream);\n\t\t__snd_pcm_set_state(runtime, state);\n\t\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MSTOP);\n\t}\n\twake_up(&runtime->sleep);\n\twake_up(&runtime->tsleep);\n}\n\nstatic const struct action_ops snd_pcm_action_stop = {\n\t.pre_action = snd_pcm_pre_stop,\n\t.do_action = snd_pcm_do_stop,\n\t.post_action = snd_pcm_post_stop\n};\n\n \nint snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t state)\n{\n\treturn snd_pcm_action(&snd_pcm_action_stop, substream, state);\n}\nEXPORT_SYMBOL(snd_pcm_stop);\n\n \nint snd_pcm_drain_done(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_action_single(&snd_pcm_action_stop, substream,\n\t\t\t\t     SNDRV_PCM_STATE_SETUP);\n}\n\n \nint snd_pcm_stop_xrun(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (substream->runtime && snd_pcm_running(substream))\n\t\t__snd_pcm_xrun(substream);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_stop_xrun);\n\n \n#define pause_pushed(state)\t(__force bool)(state)\n\nstatic int snd_pcm_pre_pause(struct snd_pcm_substream *substream,\n\t\t\t     snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (!(runtime->info & SNDRV_PCM_INFO_PAUSE))\n\t\treturn -ENOSYS;\n\tif (pause_pushed(state)) {\n\t\tif (runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\t\treturn -EBADFD;\n\t} else if (runtime->state != SNDRV_PCM_STATE_PAUSED)\n\t\treturn -EBADFD;\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_pause(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master != substream)\n\t\treturn 0;\n\t \n\tsubstream->runtime->hw_ptr_jiffies = jiffies - HZ * 1000;\n\treturn substream->ops->trigger(substream,\n\t\t\t\t       pause_pushed(state) ?\n\t\t\t\t       SNDRV_PCM_TRIGGER_PAUSE_PUSH :\n\t\t\t\t       SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n}\n\nstatic void snd_pcm_undo_pause(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream)\n\t\tsubstream->ops->trigger(substream,\n\t\t\t\t\tpause_pushed(state) ?\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_RELEASE :\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_PUSH);\n}\n\nstatic void snd_pcm_post_pause(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_trigger_tstamp(substream);\n\tif (pause_pushed(state)) {\n\t\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_PAUSED);\n\t\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MPAUSE);\n\t\twake_up(&runtime->sleep);\n\t\twake_up(&runtime->tsleep);\n\t} else {\n\t\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_RUNNING);\n\t\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MCONTINUE);\n\t}\n}\n\nstatic const struct action_ops snd_pcm_action_pause = {\n\t.pre_action = snd_pcm_pre_pause,\n\t.do_action = snd_pcm_do_pause,\n\t.undo_action = snd_pcm_undo_pause,\n\t.post_action = snd_pcm_post_pause\n};\n\n \nstatic int snd_pcm_pause(struct snd_pcm_substream *substream, bool push)\n{\n\treturn snd_pcm_action(&snd_pcm_action_pause, substream,\n\t\t\t      (__force snd_pcm_state_t)push);\n}\n\nstatic int snd_pcm_pause_lock_irq(struct snd_pcm_substream *substream,\n\t\t\t\t  bool push)\n{\n\treturn snd_pcm_action_lock_irq(&snd_pcm_action_pause, substream,\n\t\t\t\t       (__force snd_pcm_state_t)push);\n}\n\n#ifdef CONFIG_PM\n \n\nstatic int snd_pcm_pre_suspend(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\treturn -EBUSY;\n\t \n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\treturn -EBUSY;\n\t}\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_suspend(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->trigger_master != substream)\n\t\treturn 0;\n\tif (! snd_pcm_running(substream))\n\t\treturn 0;\n\tsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_SUSPEND);\n\truntime->stop_operating = true;\n\treturn 0;  \n}\n\nstatic void snd_pcm_post_suspend(struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_trigger_tstamp(substream);\n\truntime->suspended_state = runtime->state;\n\truntime->status->suspended_state = runtime->suspended_state;\n\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_SUSPENDED);\n\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MSUSPEND);\n\twake_up(&runtime->sleep);\n\twake_up(&runtime->tsleep);\n}\n\nstatic const struct action_ops snd_pcm_action_suspend = {\n\t.pre_action = snd_pcm_pre_suspend,\n\t.do_action = snd_pcm_do_suspend,\n\t.post_action = snd_pcm_post_suspend\n};\n\n \nstatic int snd_pcm_suspend(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tunsigned long flags;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\terr = snd_pcm_action(&snd_pcm_action_suspend, substream,\n\t\t\t     ACTION_ARG_IGNORE);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\treturn err;\n}\n\n \nint snd_pcm_suspend_all(struct snd_pcm *pcm)\n{\n\tstruct snd_pcm_substream *substream;\n\tint stream, err = 0;\n\n\tif (! pcm)\n\t\treturn 0;\n\n\tfor_each_pcm_substream(pcm, stream, substream) {\n\t\t \n\t\tif (!substream->runtime)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!substream->ops)\n\t\t\tcontinue;\n\n\t\terr = snd_pcm_suspend(substream);\n\t\tif (err < 0 && err != -EBUSY)\n\t\t\treturn err;\n\t}\n\n\tfor_each_pcm_substream(pcm, stream, substream)\n\t\tsnd_pcm_sync_stop(substream, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_suspend_all);\n\n \n\nstatic int snd_pcm_pre_resume(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (!(runtime->info & SNDRV_PCM_INFO_RESUME))\n\t\treturn -ENOSYS;\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_resume(struct snd_pcm_substream *substream,\n\t\t\t     snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->trigger_master != substream)\n\t\treturn 0;\n\t \n\tif (runtime->suspended_state != SNDRV_PCM_STATE_RUNNING &&\n\t    (runtime->suspended_state != SNDRV_PCM_STATE_DRAINING ||\n\t     substream->stream != SNDRV_PCM_STREAM_PLAYBACK))\n\t\treturn 0;\n\treturn substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_RESUME);\n}\n\nstatic void snd_pcm_undo_resume(struct snd_pcm_substream *substream,\n\t\t\t\tsnd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream &&\n\t    snd_pcm_running(substream))\n\t\tsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_SUSPEND);\n}\n\nstatic void snd_pcm_post_resume(struct snd_pcm_substream *substream,\n\t\t\t\tsnd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_trigger_tstamp(substream);\n\t__snd_pcm_set_state(runtime, runtime->suspended_state);\n\tsnd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MRESUME);\n}\n\nstatic const struct action_ops snd_pcm_action_resume = {\n\t.pre_action = snd_pcm_pre_resume,\n\t.do_action = snd_pcm_do_resume,\n\t.undo_action = snd_pcm_undo_resume,\n\t.post_action = snd_pcm_post_resume\n};\n\nstatic int snd_pcm_resume(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_action_lock_irq(&snd_pcm_action_resume, substream,\n\t\t\t\t       ACTION_ARG_IGNORE);\n}\n\n#else\n\nstatic int snd_pcm_resume(struct snd_pcm_substream *substream)\n{\n\treturn -ENOSYS;\n}\n\n#endif  \n\n \nstatic int snd_pcm_xrun(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint result;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\tresult = 0;\t \n\t\tbreak;\n\tcase SNDRV_PCM_STATE_RUNNING:\n\t\t__snd_pcm_xrun(substream);\n\t\tresult = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EBADFD;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn result;\n}\n\n \n \nstatic int snd_pcm_pre_reset(struct snd_pcm_substream *substream,\n\t\t\t     snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EBADFD;\n\t}\n}\n\nstatic int snd_pcm_do_reset(struct snd_pcm_substream *substream,\n\t\t\t    snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err = snd_pcm_ops_ioctl(substream, SNDRV_PCM_IOCTL1_RESET, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_stream_lock_irq(substream);\n\truntime->hw_ptr_base = 0;\n\truntime->hw_ptr_interrupt = runtime->status->hw_ptr -\n\t\truntime->status->hw_ptr % runtime->period_size;\n\truntime->silence_start = runtime->status->hw_ptr;\n\truntime->silence_filled = 0;\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn 0;\n}\n\nstatic void snd_pcm_post_reset(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_stream_lock_irq(substream);\n\truntime->control->appl_ptr = runtime->status->hw_ptr;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    runtime->silence_size > 0)\n\t\tsnd_pcm_playback_silence(substream, ULONG_MAX);\n\tsnd_pcm_stream_unlock_irq(substream);\n}\n\nstatic const struct action_ops snd_pcm_action_reset = {\n\t.pre_action = snd_pcm_pre_reset,\n\t.do_action = snd_pcm_do_reset,\n\t.post_action = snd_pcm_post_reset\n};\n\nstatic int snd_pcm_reset(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_action_nonatomic(&snd_pcm_action_reset, substream,\n\t\t\t\t\tACTION_ARG_IGNORE);\n}\n\n \n \nstatic int snd_pcm_pre_prepare(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint f_flags = (__force int)state;\n\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\tif (snd_pcm_running(substream))\n\t\treturn -EBUSY;\n\tsubstream->f_flags = f_flags;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_prepare(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_state_t state)\n{\n\tint err;\n\tsnd_pcm_sync_stop(substream, true);\n\terr = substream->ops->prepare(substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn snd_pcm_do_reset(substream, state);\n}\n\nstatic void snd_pcm_post_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\truntime->control->appl_ptr = runtime->status->hw_ptr;\n\tsnd_pcm_set_state(substream, SNDRV_PCM_STATE_PREPARED);\n}\n\nstatic const struct action_ops snd_pcm_action_prepare = {\n\t.pre_action = snd_pcm_pre_prepare,\n\t.do_action = snd_pcm_do_prepare,\n\t.post_action = snd_pcm_post_prepare\n};\n\n \nstatic int snd_pcm_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct file *file)\n{\n\tint f_flags;\n\n\tif (file)\n\t\tf_flags = file->f_flags;\n\telse\n\t\tf_flags = substream->f_flags;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (substream->runtime->state) {\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tsnd_pcm_pause(substream, false);\n\t\tfallthrough;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t\tbreak;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\n\treturn snd_pcm_action_nonatomic(&snd_pcm_action_prepare,\n\t\t\t\t\tsubstream,\n\t\t\t\t\t(__force snd_pcm_state_t)f_flags);\n}\n\n \n\n \nstatic int snd_pcm_pre_drain_init(struct snd_pcm_substream *substream,\n\t\t\t\t  snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\treturn -EBADFD;\n\t}\n\truntime->trigger_master = substream;\n\treturn 0;\n}\n\nstatic int snd_pcm_do_drain_init(struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_state_t state)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (runtime->state) {\n\t\tcase SNDRV_PCM_STATE_PREPARED:\n\t\t\t \n\t\t\tif (! snd_pcm_playback_empty(substream)) {\n\t\t\t\tsnd_pcm_do_start(substream, SNDRV_PCM_STATE_DRAINING);\n\t\t\t\tsnd_pcm_post_start(substream, SNDRV_PCM_STATE_DRAINING);\n\t\t\t} else {\n\t\t\t\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_SETUP);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_STATE_RUNNING:\n\t\t\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_DRAINING);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\t__snd_pcm_set_state(runtime, SNDRV_PCM_STATE_SETUP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tif (runtime->state == SNDRV_PCM_STATE_RUNNING) {\n\t\t\tsnd_pcm_state_t new_state;\n\n\t\t\tnew_state = snd_pcm_capture_avail(runtime) > 0 ?\n\t\t\t\tSNDRV_PCM_STATE_DRAINING : SNDRV_PCM_STATE_SETUP;\n\t\t\tsnd_pcm_do_stop(substream, new_state);\n\t\t\tsnd_pcm_post_stop(substream, new_state);\n\t\t}\n\t}\n\n\tif (runtime->state == SNDRV_PCM_STATE_DRAINING &&\n\t    runtime->trigger_master == substream &&\n\t    (runtime->hw.info & SNDRV_PCM_INFO_DRAIN_TRIGGER))\n\t\treturn substream->ops->trigger(substream,\n\t\t\t\t\t       SNDRV_PCM_TRIGGER_DRAIN);\n\n\treturn 0;\n}\n\nstatic void snd_pcm_post_drain_init(struct snd_pcm_substream *substream,\n\t\t\t\t    snd_pcm_state_t state)\n{\n}\n\nstatic const struct action_ops snd_pcm_action_drain_init = {\n\t.pre_action = snd_pcm_pre_drain_init,\n\t.do_action = snd_pcm_do_drain_init,\n\t.post_action = snd_pcm_post_drain_init\n};\n\n \nstatic int snd_pcm_drain(struct snd_pcm_substream *substream,\n\t\t\t struct file *file)\n{\n\tstruct snd_card *card;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_pcm_substream *s;\n\tstruct snd_pcm_group *group;\n\twait_queue_entry_t wait;\n\tint result = 0;\n\tint nonblock = 0;\n\n\tcard = substream->pcm->card;\n\truntime = substream->runtime;\n\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tif (file) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tnonblock = 1;\n\t} else if (substream->f_flags & O_NONBLOCK)\n\t\tnonblock = 1;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\t \n\tif (runtime->state == SNDRV_PCM_STATE_PAUSED)\n\t\tsnd_pcm_pause(substream, false);\n\n\t \n\tresult = snd_pcm_action(&snd_pcm_action_drain_init, substream,\n\t\t\t\tACTION_ARG_IGNORE);\n\tif (result < 0)\n\t\tgoto unlock;\n\t \n\tif (nonblock) {\n\t\tresult = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tfor (;;) {\n\t\tlong tout;\n\t\tstruct snd_pcm_runtime *to_check;\n\t\tif (signal_pending(current)) {\n\t\t\tresult = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tto_check = NULL;\n\t\tgroup = snd_pcm_stream_group_ref(substream);\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tcontinue;\n\t\t\truntime = s->runtime;\n\t\t\tif (runtime->state == SNDRV_PCM_STATE_DRAINING) {\n\t\t\t\tto_check = runtime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnd_pcm_group_unref(group, substream);\n\t\tif (!to_check)\n\t\t\tbreak;  \n\t\tinit_waitqueue_entry(&wait, current);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&to_check->sleep, &wait);\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\tif (runtime->no_period_wakeup)\n\t\t\ttout = MAX_SCHEDULE_TIMEOUT;\n\t\telse {\n\t\t\ttout = 100;\n\t\t\tif (runtime->rate) {\n\t\t\t\tlong t = runtime->buffer_size * 1100 / runtime->rate;\n\t\t\t\ttout = max(t, tout);\n\t\t\t}\n\t\t\ttout = msecs_to_jiffies(tout);\n\t\t}\n\t\ttout = schedule_timeout(tout);\n\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tgroup = snd_pcm_stream_group_ref(substream);\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s->runtime == to_check) {\n\t\t\t\tremove_wait_queue(&to_check->sleep, &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnd_pcm_group_unref(group, substream);\n\n\t\tif (card->shutdown) {\n\t\t\tresult = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (tout == 0) {\n\t\t\tif (substream->runtime->state == SNDRV_PCM_STATE_SUSPENDED)\n\t\t\t\tresult = -ESTRPIPE;\n\t\t\telse {\n\t\t\t\tdev_dbg(substream->pcm->card->dev,\n\t\t\t\t\t\"playback drain timeout (DMA or IRQ trouble?)\\n\");\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t\t\t\tresult = -EIO;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n unlock:\n\tsnd_pcm_stream_unlock_irq(substream);\n\n\treturn result;\n}\n\n \nstatic int snd_pcm_drop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint result = 0;\n\t\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\t \n\tif (runtime->state == SNDRV_PCM_STATE_PAUSED)\n\t\tsnd_pcm_pause(substream, false);\n\n\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t \n\tsnd_pcm_stream_unlock_irq(substream);\n\n\treturn result;\n}\n\n\nstatic bool is_pcm_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct snd_pcm *pcm;\n\tunsigned int minor;\n\n\tif (!S_ISCHR(inode->i_mode) || imajor(inode) != snd_major)\n\t\treturn false;\n\tminor = iminor(inode);\n\tpcm = snd_lookup_minor_data(minor, SNDRV_DEVICE_TYPE_PCM_PLAYBACK);\n\tif (!pcm)\n\t\tpcm = snd_lookup_minor_data(minor, SNDRV_DEVICE_TYPE_PCM_CAPTURE);\n\tif (!pcm)\n\t\treturn false;\n\tsnd_card_unref(pcm->card);\n\treturn true;\n}\n\n \nstatic int snd_pcm_link(struct snd_pcm_substream *substream, int fd)\n{\n\tint res = 0;\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream1;\n\tstruct snd_pcm_group *group, *target_group;\n\tbool nonatomic = substream->pcm->nonatomic;\n\tstruct fd f = fdget(fd);\n\n\tif (!f.file)\n\t\treturn -EBADFD;\n\tif (!is_pcm_file(f.file)) {\n\t\tres = -EBADFD;\n\t\tgoto _badf;\n\t}\n\tpcm_file = f.file->private_data;\n\tsubstream1 = pcm_file->substream;\n\n\tif (substream == substream1) {\n\t\tres = -EINVAL;\n\t\tgoto _badf;\n\t}\n\n\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\tif (!group) {\n\t\tres = -ENOMEM;\n\t\tgoto _nolock;\n\t}\n\tsnd_pcm_group_init(group);\n\n\tdown_write(&snd_pcm_link_rwsem);\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    substream->runtime->state != substream1->runtime->state ||\n\t    substream->pcm->nonatomic != substream1->pcm->nonatomic) {\n\t\tres = -EBADFD;\n\t\tgoto _end;\n\t}\n\tif (snd_pcm_stream_linked(substream1)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tsnd_pcm_group_assign(substream, group);\n\t\tgroup = NULL;  \n\t}\n\ttarget_group = substream->group;\n\tsnd_pcm_stream_unlock_irq(substream);\n\n\tsnd_pcm_group_lock_irq(target_group, nonatomic);\n\tsnd_pcm_stream_lock_nested(substream1);\n\tsnd_pcm_group_assign(substream1, target_group);\n\trefcount_inc(&target_group->refs);\n\tsnd_pcm_stream_unlock(substream1);\n\tsnd_pcm_group_unlock_irq(target_group, nonatomic);\n _end:\n\tup_write(&snd_pcm_link_rwsem);\n _nolock:\n\tkfree(group);\n _badf:\n\tfdput(f);\n\treturn res;\n}\n\nstatic void relink_to_local(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_stream_lock_nested(substream);\n\tsnd_pcm_group_assign(substream, &substream->self_group);\n\tsnd_pcm_stream_unlock(substream);\n}\n\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_group *group;\n\tbool nonatomic = substream->pcm->nonatomic;\n\tbool do_free = false;\n\tint res = 0;\n\n\tdown_write(&snd_pcm_link_rwsem);\n\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\n\tgroup = substream->group;\n\tsnd_pcm_group_lock_irq(group, nonatomic);\n\n\trelink_to_local(substream);\n\trefcount_dec(&group->refs);\n\n\t \n\tif (list_is_singular(&group->substreams)) {\n\t\trelink_to_local(list_first_entry(&group->substreams,\n\t\t\t\t\t\t struct snd_pcm_substream,\n\t\t\t\t\t\t link_list));\n\t\tdo_free = refcount_dec_and_test(&group->refs);\n\t}\n\n\tsnd_pcm_group_unlock_irq(group, nonatomic);\n\tif (do_free)\n\t\tkfree(group);\n\n       _end:\n\tup_write(&snd_pcm_link_rwsem);\n\treturn res;\n}\n\n \nstatic int snd_pcm_hw_rule_mul(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tsnd_interval_mul(hw_param_interval_c(params, rule->deps[0]),\n\t\t     hw_param_interval_c(params, rule->deps[1]), &t);\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int snd_pcm_hw_rule_div(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tsnd_interval_div(hw_param_interval_c(params, rule->deps[0]),\n\t\t     hw_param_interval_c(params, rule->deps[1]), &t);\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int snd_pcm_hw_rule_muldivk(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tsnd_interval_muldivk(hw_param_interval_c(params, rule->deps[0]),\n\t\t\t hw_param_interval_c(params, rule->deps[1]),\n\t\t\t (unsigned long) rule->private, &t);\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int snd_pcm_hw_rule_mulkdiv(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tsnd_interval_mulkdiv(hw_param_interval_c(params, rule->deps[0]),\n\t\t\t (unsigned long) rule->private,\n\t\t\t hw_param_interval_c(params, rule->deps[1]), &t);\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int snd_pcm_hw_rule_format(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tsnd_pcm_format_t k;\n\tconst struct snd_interval *i =\n\t\t\t\thw_param_interval_c(params, rule->deps[0]);\n\tstruct snd_mask m;\n\tstruct snd_mask *mask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tsnd_mask_any(&m);\n\tpcm_for_each_format(k) {\n\t\tint bits;\n\t\tif (!snd_mask_test_format(mask, k))\n\t\t\tcontinue;\n\t\tbits = snd_pcm_format_physical_width(k);\n\t\tif (bits <= 0)\n\t\t\tcontinue;  \n\t\tif ((unsigned)bits < i->min || (unsigned)bits > i->max)\n\t\t\tsnd_mask_reset(&m, (__force unsigned)k);\n\t}\n\treturn snd_mask_refine(mask, &m);\n}\n\nstatic int snd_pcm_hw_rule_sample_bits(struct snd_pcm_hw_params *params,\n\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tsnd_pcm_format_t k;\n\n\tt.min = UINT_MAX;\n\tt.max = 0;\n\tt.openmin = 0;\n\tt.openmax = 0;\n\tpcm_for_each_format(k) {\n\t\tint bits;\n\t\tif (!snd_mask_test_format(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT), k))\n\t\t\tcontinue;\n\t\tbits = snd_pcm_format_physical_width(k);\n\t\tif (bits <= 0)\n\t\t\tcontinue;  \n\t\tif (t.min > (unsigned)bits)\n\t\t\tt.min = bits;\n\t\tif (t.max < (unsigned)bits)\n\t\t\tt.max = bits;\n\t}\n\tt.integer = 1;\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\n#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12\n#error \"Change this table\"\n#endif\n\nstatic const unsigned int rates[] = {\n\t5512, 8000, 11025, 16000, 22050, 32000, 44100,\n\t48000, 64000, 88200, 96000, 176400, 192000, 352800, 384000\n};\n\nconst struct snd_pcm_hw_constraint_list snd_pcm_known_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n};\n\nstatic int snd_pcm_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hardware *hw = rule->private;\n\treturn snd_interval_list(hw_param_interval(params, rule->var),\n\t\t\t\t snd_pcm_known_rates.count,\n\t\t\t\t snd_pcm_known_rates.list, hw->rates);\n}\t\t\n\nstatic int snd_pcm_hw_rule_buffer_bytes_max(struct snd_pcm_hw_params *params,\n\t\t\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval t;\n\tstruct snd_pcm_substream *substream = rule->private;\n\tt.min = 0;\n\tt.max = substream->buffer_bytes_max;\n\tt.openmin = 0;\n\tt.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\t\t\n\nstatic int snd_pcm_hw_constraints_init(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tint k, err;\n\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++) {\n\t\tsnd_mask_any(constrs_mask(constrs, k));\n\t}\n\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++) {\n\t\tsnd_interval_any(constrs_interval(constrs, k));\n\t}\n\n\tsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_CHANNELS));\n\tsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_BUFFER_SIZE));\n\tsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_BUFFER_BYTES));\n\tsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_SAMPLE_BITS));\n\tsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_FRAME_BITS));\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t   snd_pcm_hw_rule_format, NULL,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, \n\t\t\t\t  snd_pcm_hw_rule_sample_bits, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, \n\t\t\t\t  SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, \n\t\t\t\t  snd_pcm_hw_rule_div, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FRAME_BITS, SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS, \n\t\t\t\t  snd_pcm_hw_rule_mul, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_SAMPLE_BITS, SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_BYTES, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, \n\t\t\t\t  snd_pcm_hw_rule_div, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FRAME_BITS, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_PERIOD_TIME, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_BUFFER_TIME, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIODS, \n\t\t\t\t  snd_pcm_hw_rule_div, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_div, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_muldivk, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_TIME, SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_mul, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, \n\t\t\t\t  snd_pcm_hw_rule_muldivk, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_TIME, SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, \n\t\t\t\t  snd_pcm_hw_rule_muldivk, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, \n\t\t\t\t  snd_pcm_hw_rule_muldivk, (void*) 8,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_TIME, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_TIME, \n\t\t\t\t  snd_pcm_hw_rule_mulkdiv, (void*) 1000000,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tint err;\n\tunsigned int mask = 0;\n\n        if (hw->info & SNDRV_PCM_INFO_INTERLEAVED)\n\t\tmask |= PARAM_MASK_BIT(SNDRV_PCM_ACCESS_RW_INTERLEAVED);\n        if (hw->info & SNDRV_PCM_INFO_NONINTERLEAVED)\n\t\tmask |= PARAM_MASK_BIT(SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);\n\tif (hw_support_mmap(substream)) {\n\t\tif (hw->info & SNDRV_PCM_INFO_INTERLEAVED)\n\t\t\tmask |= PARAM_MASK_BIT(SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);\n\t\tif (hw->info & SNDRV_PCM_INFO_NONINTERLEAVED)\n\t\t\tmask |= PARAM_MASK_BIT(SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED);\n\t\tif (hw->info & SNDRV_PCM_INFO_COMPLEX)\n\t\t\tmask |= PARAM_MASK_BIT(SNDRV_PCM_ACCESS_MMAP_COMPLEX);\n\t}\n\terr = snd_pcm_hw_constraint_mask(runtime, SNDRV_PCM_HW_PARAM_ACCESS, mask);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_mask64(runtime, SNDRV_PCM_HW_PARAM_FORMAT, hw->formats);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_mask(runtime, SNDRV_PCM_HW_PARAM_SUBFORMAT,\n\t\t\t\t\t PARAM_MASK_BIT(SNDRV_PCM_SUBFORMAT_STD));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   hw->channels_min, hw->channels_max);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   hw->rate_min, hw->rate_max);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t   hw->period_bytes_min, hw->period_bytes_max);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIODS,\n\t\t\t\t\t   hw->periods_min, hw->periods_max);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t   hw->period_bytes_min, hw->buffer_bytes_max);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, \n\t\t\t\t  snd_pcm_hw_rule_buffer_bytes_max, substream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_BYTES, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (runtime->dma_bytes) {\n\t\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, runtime->dma_bytes);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!(hw->rates & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))) {\n\t\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, \n\t\t\t\t\t  snd_pcm_hw_rule_rate, hw,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\n\treturn 0;\n}\n\nstatic void pcm_release_private(struct snd_pcm_substream *substream)\n{\n\tif (snd_pcm_stream_linked(substream))\n\t\tsnd_pcm_unlink(substream);\n}\n\nvoid snd_pcm_release_substream(struct snd_pcm_substream *substream)\n{\n\tsubstream->ref_count--;\n\tif (substream->ref_count > 0)\n\t\treturn;\n\n\tsnd_pcm_drop(substream);\n\tif (substream->hw_opened) {\n\t\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t\tdo_hw_free(substream);\n\t\tsubstream->ops->close(substream);\n\t\tsubstream->hw_opened = 0;\n\t}\n\tif (cpu_latency_qos_request_active(&substream->latency_pm_qos_req))\n\t\tcpu_latency_qos_remove_request(&substream->latency_pm_qos_req);\n\tif (substream->pcm_release) {\n\t\tsubstream->pcm_release(substream);\n\t\tsubstream->pcm_release = NULL;\n\t}\n\tsnd_pcm_detach_substream(substream);\n}\nEXPORT_SYMBOL(snd_pcm_release_substream);\n\nint snd_pcm_open_substream(struct snd_pcm *pcm, int stream,\n\t\t\t   struct file *file,\n\t\t\t   struct snd_pcm_substream **rsubstream)\n{\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\n\terr = snd_pcm_attach_substream(pcm, stream, file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\tif (substream->ref_count > 1) {\n\t\t*rsubstream = substream;\n\t\treturn 0;\n\t}\n\n\terr = snd_pcm_hw_constraints_init(substream);\n\tif (err < 0) {\n\t\tpcm_dbg(pcm, \"snd_pcm_hw_constraints_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\terr = substream->ops->open(substream);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsubstream->hw_opened = 1;\n\n\terr = snd_pcm_hw_constraints_complete(substream);\n\tif (err < 0) {\n\t\tpcm_dbg(pcm, \"snd_pcm_hw_constraints_complete failed\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (substream->managed_buffer_alloc &&\n\t    substream->dma_buffer.dev.need_sync)\n\t\tsubstream->runtime->hw.info |= SNDRV_PCM_INFO_EXPLICIT_SYNC;\n\n\t*rsubstream = substream;\n\treturn 0;\n\n error:\n\tsnd_pcm_release_substream(substream);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_pcm_open_substream);\n\nstatic int snd_pcm_open_file(struct file *file,\n\t\t\t     struct snd_pcm *pcm,\n\t\t\t     int stream)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\n\terr = snd_pcm_open_substream(pcm, stream, file, &substream);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm_file = kzalloc(sizeof(*pcm_file), GFP_KERNEL);\n\tif (pcm_file == NULL) {\n\t\tsnd_pcm_release_substream(substream);\n\t\treturn -ENOMEM;\n\t}\n\tpcm_file->substream = substream;\n\tif (substream->ref_count == 1)\n\t\tsubstream->pcm_release = pcm_release_private;\n\tfile->private_data = pcm_file;\n\n\treturn 0;\n}\n\nstatic int snd_pcm_playback_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_pcm *pcm;\n\tint err = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\tpcm = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t    SNDRV_DEVICE_TYPE_PCM_PLAYBACK);\n\terr = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);\n\tif (pcm)\n\t\tsnd_card_unref(pcm->card);\n\treturn err;\n}\n\nstatic int snd_pcm_capture_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_pcm *pcm;\n\tint err = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\tpcm = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t    SNDRV_DEVICE_TYPE_PCM_CAPTURE);\n\terr = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_CAPTURE);\n\tif (pcm)\n\t\tsnd_card_unref(pcm->card);\n\treturn err;\n}\n\nstatic int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream)\n{\n\tint err;\n\twait_queue_entry_t wait;\n\n\tif (pcm == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(pcm->card, file);\n\tif (err < 0)\n\t\tgoto __error1;\n\tif (!try_module_get(pcm->card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&pcm->open_wait, &wait);\n\tmutex_lock(&pcm->open_mutex);\n\twhile (1) {\n\t\terr = snd_pcm_open_file(file, pcm, stream);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif (err == -EAGAIN) {\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tmutex_unlock(&pcm->open_mutex);\n\t\tschedule();\n\t\tmutex_lock(&pcm->open_mutex);\n\t\tif (pcm->card->shutdown) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&pcm->open_wait, &wait);\n\tmutex_unlock(&pcm->open_mutex);\n\tif (err < 0)\n\t\tgoto __error;\n\treturn err;\n\n      __error:\n\tmodule_put(pcm->card->module);\n      __error2:\n      \tsnd_card_file_remove(pcm->card, file);\n      __error1:\n      \treturn err;\n}\n\nstatic int snd_pcm_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_file *pcm_file;\n\n\tpcm_file = file->private_data;\n\tsubstream = pcm_file->substream;\n\tif (snd_BUG_ON(!substream))\n\t\treturn -ENXIO;\n\tpcm = substream->pcm;\n\n\t \n\tsnd_power_wait(pcm->card);\n\n\tmutex_lock(&pcm->open_mutex);\n\tsnd_pcm_release_substream(substream);\n\tkfree(pcm_file);\n\tmutex_unlock(&pcm->open_mutex);\n\twake_up(&pcm->open_wait);\n\tmodule_put(pcm->card->module);\n\tsnd_card_file_remove(pcm->card, file);\n\treturn 0;\n}\n\n \nstatic int do_pcm_hwsync(struct snd_pcm_substream *substream)\n{\n\tswitch (substream->runtime->state) {\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\treturn -EBADFD;\n\t\tfallthrough;\n\tcase SNDRV_PCM_STATE_RUNNING:\n\t\treturn snd_pcm_update_hw_ptr(substream);\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\treturn 0;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\treturn -ESTRPIPE;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\treturn -EPIPE;\n\tdefault:\n\t\treturn -EBADFD;\n\t}\n}\n\n \nstatic snd_pcm_sframes_t forward_appl_ptr(struct snd_pcm_substream *substream,\n\t\t\t\t\t  snd_pcm_uframes_t frames,\n\t\t\t\t\t   snd_pcm_sframes_t avail)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t appl_ptr;\n\tint ret;\n\n\tif (avail <= 0)\n\t\treturn 0;\n\tif (frames > (snd_pcm_uframes_t)avail)\n\t\tframes = avail;\n\tappl_ptr = runtime->control->appl_ptr + frames;\n\tif (appl_ptr >= (snd_pcm_sframes_t)runtime->boundary)\n\t\tappl_ptr -= runtime->boundary;\n\tret = pcm_lib_apply_appl_ptr(substream, appl_ptr);\n\treturn ret < 0 ? ret : frames;\n}\n\n \nstatic snd_pcm_sframes_t rewind_appl_ptr(struct snd_pcm_substream *substream,\n\t\t\t\t\t snd_pcm_uframes_t frames,\n\t\t\t\t\t snd_pcm_sframes_t avail)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t appl_ptr;\n\tint ret;\n\n\tif (avail <= 0)\n\t\treturn 0;\n\tif (frames > (snd_pcm_uframes_t)avail)\n\t\tframes = avail;\n\tappl_ptr = runtime->control->appl_ptr - frames;\n\tif (appl_ptr < 0)\n\t\tappl_ptr += runtime->boundary;\n\tret = pcm_lib_apply_appl_ptr(substream, appl_ptr);\n\t \n\treturn ret < 0 ? 0 : frames;\n}\n\nstatic snd_pcm_sframes_t snd_pcm_rewind(struct snd_pcm_substream *substream,\n\t\t\t\t\tsnd_pcm_uframes_t frames)\n{\n\tsnd_pcm_sframes_t ret;\n\n\tif (frames == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tret = do_pcm_hwsync(substream);\n\tif (!ret)\n\t\tret = rewind_appl_ptr(substream, frames,\n\t\t\t\t      snd_pcm_hw_avail(substream));\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (ret >= 0)\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\treturn ret;\n}\n\nstatic snd_pcm_sframes_t snd_pcm_forward(struct snd_pcm_substream *substream,\n\t\t\t\t\t snd_pcm_uframes_t frames)\n{\n\tsnd_pcm_sframes_t ret;\n\n\tif (frames == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tret = do_pcm_hwsync(substream);\n\tif (!ret)\n\t\tret = forward_appl_ptr(substream, frames,\n\t\t\t\t       snd_pcm_avail(substream));\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (ret >= 0)\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\treturn ret;\n}\n\nstatic int snd_pcm_delay(struct snd_pcm_substream *substream,\n\t\t\t snd_pcm_sframes_t *delay)\n{\n\tint err;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\terr = do_pcm_hwsync(substream);\n\tif (delay && !err)\n\t\t*delay = snd_pcm_calc_delay(substream);\n\tsnd_pcm_stream_unlock_irq(substream);\n\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_CPU);\n\n\treturn err;\n}\n\t\t\nstatic inline int snd_pcm_hwsync(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_delay(substream, NULL);\n}\n\nstatic int snd_pcm_sync_ptr(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_sync_ptr __user *_sync_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_sync_ptr sync_ptr;\n\tvolatile struct snd_pcm_mmap_status *status;\n\tvolatile struct snd_pcm_mmap_control *control;\n\tint err;\n\n\tmemset(&sync_ptr, 0, sizeof(sync_ptr));\n\tif (get_user(sync_ptr.flags, (unsigned __user *)&(_sync_ptr->flags)))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&sync_ptr.c.control, &(_sync_ptr->c.control), sizeof(struct snd_pcm_mmap_control)))\n\t\treturn -EFAULT;\t\n\tstatus = runtime->status;\n\tcontrol = runtime->control;\n\tif (sync_ptr.flags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\n\t\terr = snd_pcm_hwsync(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_pcm_stream_lock_irq(substream);\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL)) {\n\t\terr = pcm_lib_apply_appl_ptr(substream,\n\t\t\t\t\t     sync_ptr.c.control.appl_ptr);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tsync_ptr.c.control.appl_ptr = control->appl_ptr;\n\t}\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\n\t\tcontrol->avail_min = sync_ptr.c.control.avail_min;\n\telse\n\t\tsync_ptr.c.control.avail_min = control->avail_min;\n\tsync_ptr.s.status.state = status->state;\n\tsync_ptr.s.status.hw_ptr = status->hw_ptr;\n\tsync_ptr.s.status.tstamp = status->tstamp;\n\tsync_ptr.s.status.suspended_state = status->suspended_state;\n\tsync_ptr.s.status.audio_tstamp = status->audio_tstamp;\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL))\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\tif (copy_to_user(_sync_ptr, &sync_ptr, sizeof(sync_ptr)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct snd_pcm_mmap_status32 {\n\tsnd_pcm_state_t state;\n\ts32 pad1;\n\tu32 hw_ptr;\n\ts32 tstamp_sec;\n\ts32 tstamp_nsec;\n\tsnd_pcm_state_t suspended_state;\n\ts32 audio_tstamp_sec;\n\ts32 audio_tstamp_nsec;\n} __attribute__((packed));\n\nstruct snd_pcm_mmap_control32 {\n\tu32 appl_ptr;\n\tu32 avail_min;\n};\n\nstruct snd_pcm_sync_ptr32 {\n\tu32 flags;\n\tunion {\n\t\tstruct snd_pcm_mmap_status32 status;\n\t\tunsigned char reserved[64];\n\t} s;\n\tunion {\n\t\tstruct snd_pcm_mmap_control32 control;\n\t\tunsigned char reserved[64];\n\t} c;\n} __attribute__((packed));\n\n \nstatic snd_pcm_uframes_t recalculate_boundary(struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_uframes_t boundary;\n\n\tif (! runtime->buffer_size)\n\t\treturn 0;\n\tboundary = runtime->buffer_size;\n\twhile (boundary * 2 <= 0x7fffffffUL - runtime->buffer_size)\n\t\tboundary *= 2;\n\treturn boundary;\n}\n\nstatic int snd_pcm_ioctl_sync_ptr_compat(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_sync_ptr32 __user *src)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tvolatile struct snd_pcm_mmap_status *status;\n\tvolatile struct snd_pcm_mmap_control *control;\n\tu32 sflags;\n\tstruct snd_pcm_mmap_control scontrol;\n\tstruct snd_pcm_mmap_status sstatus;\n\tsnd_pcm_uframes_t boundary;\n\tint err;\n\n\tif (snd_BUG_ON(!runtime))\n\t\treturn -EINVAL;\n\n\tif (get_user(sflags, &src->flags) ||\n\t    get_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\n\t    get_user(scontrol.avail_min, &src->c.control.avail_min))\n\t\treturn -EFAULT;\n\tif (sflags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\n\t\terr = snd_pcm_hwsync(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tstatus = runtime->status;\n\tcontrol = runtime->control;\n\tboundary = recalculate_boundary(runtime);\n\tif (! boundary)\n\t\tboundary = 0x7fffffff;\n\tsnd_pcm_stream_lock_irq(substream);\n\t \n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_APPL)) {\n\t\terr = pcm_lib_apply_appl_ptr(substream,\n\t\t\t\tscontrol.appl_ptr);\n\t\tif (err < 0) {\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tscontrol.appl_ptr = control->appl_ptr % boundary;\n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\n\t\tcontrol->avail_min = scontrol.avail_min;\n\telse\n\t\tscontrol.avail_min = control->avail_min;\n\tsstatus.state = status->state;\n\tsstatus.hw_ptr = status->hw_ptr % boundary;\n\tsstatus.tstamp = status->tstamp;\n\tsstatus.suspended_state = status->suspended_state;\n\tsstatus.audio_tstamp = status->audio_tstamp;\n\tsnd_pcm_stream_unlock_irq(substream);\n\tif (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))\n\t\tsnd_pcm_dma_buffer_sync(substream, SNDRV_DMA_SYNC_DEVICE);\n\tif (put_user(sstatus.state, &src->s.status.state) ||\n\t    put_user(sstatus.hw_ptr, &src->s.status.hw_ptr) ||\n\t    put_user(sstatus.tstamp.tv_sec, &src->s.status.tstamp_sec) ||\n\t    put_user(sstatus.tstamp.tv_nsec, &src->s.status.tstamp_nsec) ||\n\t    put_user(sstatus.suspended_state, &src->s.status.suspended_state) ||\n\t    put_user(sstatus.audio_tstamp.tv_sec, &src->s.status.audio_tstamp_sec) ||\n\t    put_user(sstatus.audio_tstamp.tv_nsec, &src->s.status.audio_tstamp_nsec) ||\n\t    put_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\n\t    put_user(scontrol.avail_min, &src->c.control.avail_min))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#define __SNDRV_PCM_IOCTL_SYNC_PTR32 _IOWR('A', 0x23, struct snd_pcm_sync_ptr32)\n\nstatic int snd_pcm_tstamp(struct snd_pcm_substream *substream, int __user *_arg)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint arg;\n\t\n\tif (get_user(arg, _arg))\n\t\treturn -EFAULT;\n\tif (arg < 0 || arg > SNDRV_PCM_TSTAMP_TYPE_LAST)\n\t\treturn -EINVAL;\n\truntime->tstamp_type = arg;\n\treturn 0;\n}\n\nstatic int snd_pcm_xferi_frames_ioctl(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_xferi __user *_xferi)\n{\n\tstruct snd_xferi xferi;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t result;\n\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\tif (put_user(0, &_xferi->result))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&xferi, _xferi, sizeof(xferi)))\n\t\treturn -EFAULT;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tresult = snd_pcm_lib_write(substream, xferi.buf, xferi.frames);\n\telse\n\t\tresult = snd_pcm_lib_read(substream, xferi.buf, xferi.frames);\n\tif (put_user(result, &_xferi->result))\n\t\treturn -EFAULT;\n\treturn result < 0 ? result : 0;\n}\n\nstatic int snd_pcm_xfern_frames_ioctl(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_xfern __user *_xfern)\n{\n\tstruct snd_xfern xfern;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tvoid *bufs;\n\tsnd_pcm_sframes_t result;\n\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\tif (runtime->channels > 128)\n\t\treturn -EINVAL;\n\tif (put_user(0, &_xfern->result))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&xfern, _xfern, sizeof(xfern)))\n\t\treturn -EFAULT;\n\n\tbufs = memdup_user(xfern.bufs, sizeof(void *) * runtime->channels);\n\tif (IS_ERR(bufs))\n\t\treturn PTR_ERR(bufs);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tresult = snd_pcm_lib_writev(substream, bufs, xfern.frames);\n\telse\n\t\tresult = snd_pcm_lib_readv(substream, bufs, xfern.frames);\n\tkfree(bufs);\n\tif (put_user(result, &_xfern->result))\n\t\treturn -EFAULT;\n\treturn result < 0 ? result : 0;\n}\n\nstatic int snd_pcm_rewind_ioctl(struct snd_pcm_substream *substream,\n\t\t\t\tsnd_pcm_uframes_t __user *_frames)\n{\n\tsnd_pcm_uframes_t frames;\n\tsnd_pcm_sframes_t result;\n\n\tif (get_user(frames, _frames))\n\t\treturn -EFAULT;\n\tif (put_user(0, _frames))\n\t\treturn -EFAULT;\n\tresult = snd_pcm_rewind(substream, frames);\n\tif (put_user(result, _frames))\n\t\treturn -EFAULT;\n\treturn result < 0 ? result : 0;\n}\n\nstatic int snd_pcm_forward_ioctl(struct snd_pcm_substream *substream,\n\t\t\t\t snd_pcm_uframes_t __user *_frames)\n{\n\tsnd_pcm_uframes_t frames;\n\tsnd_pcm_sframes_t result;\n\n\tif (get_user(frames, _frames))\n\t\treturn -EFAULT;\n\tif (put_user(0, _frames))\n\t\treturn -EFAULT;\n\tresult = snd_pcm_forward(substream, frames);\n\tif (put_user(result, _frames))\n\t\treturn -EFAULT;\n\treturn result < 0 ? result : 0;\n}\n\nstatic int snd_pcm_common_ioctl(struct file *file,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t unsigned int cmd, void __user *arg)\n{\n\tstruct snd_pcm_file *pcm_file = file->private_data;\n\tint res;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\n\tres = snd_power_wait(substream->pcm->card);\n\tif (res < 0)\n\t\treturn res;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_PCM_VERSION, (int __user *)arg) ? -EFAULT : 0;\n\tcase SNDRV_PCM_IOCTL_INFO:\n\t\treturn snd_pcm_info_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_TSTAMP:\t \n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL_TTSTAMP:\n\t\treturn snd_pcm_tstamp(substream, arg);\n\tcase SNDRV_PCM_IOCTL_USER_PVERSION:\n\t\tif (get_user(pcm_file->user_pversion,\n\t\t\t     (unsigned int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL_HW_REFINE:\n\t\treturn snd_pcm_hw_refine_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_HW_PARAMS:\n\t\treturn snd_pcm_hw_params_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_HW_FREE:\n\t\treturn snd_pcm_hw_free(substream);\n\tcase SNDRV_PCM_IOCTL_SW_PARAMS:\n\t\treturn snd_pcm_sw_params_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_STATUS32:\n\t\treturn snd_pcm_status_user32(substream, arg, false);\n\tcase SNDRV_PCM_IOCTL_STATUS_EXT32:\n\t\treturn snd_pcm_status_user32(substream, arg, true);\n\tcase SNDRV_PCM_IOCTL_STATUS64:\n\t\treturn snd_pcm_status_user64(substream, arg, false);\n\tcase SNDRV_PCM_IOCTL_STATUS_EXT64:\n\t\treturn snd_pcm_status_user64(substream, arg, true);\n\tcase SNDRV_PCM_IOCTL_CHANNEL_INFO:\n\t\treturn snd_pcm_channel_info_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_PREPARE:\n\t\treturn snd_pcm_prepare(substream, file);\n\tcase SNDRV_PCM_IOCTL_RESET:\n\t\treturn snd_pcm_reset(substream);\n\tcase SNDRV_PCM_IOCTL_START:\n\t\treturn snd_pcm_start_lock_irq(substream);\n\tcase SNDRV_PCM_IOCTL_LINK:\n\t\treturn snd_pcm_link(substream, (int)(unsigned long) arg);\n\tcase SNDRV_PCM_IOCTL_UNLINK:\n\t\treturn snd_pcm_unlink(substream);\n\tcase SNDRV_PCM_IOCTL_RESUME:\n\t\treturn snd_pcm_resume(substream);\n\tcase SNDRV_PCM_IOCTL_XRUN:\n\t\treturn snd_pcm_xrun(substream);\n\tcase SNDRV_PCM_IOCTL_HWSYNC:\n\t\treturn snd_pcm_hwsync(substream);\n\tcase SNDRV_PCM_IOCTL_DELAY:\n\t{\n\t\tsnd_pcm_sframes_t delay = 0;\n\t\tsnd_pcm_sframes_t __user *res = arg;\n\t\tint err;\n\n\t\terr = snd_pcm_delay(substream, &delay);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (put_user(delay, res))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase __SNDRV_PCM_IOCTL_SYNC_PTR32:\n\t\treturn snd_pcm_ioctl_sync_ptr_compat(substream, arg);\n\tcase __SNDRV_PCM_IOCTL_SYNC_PTR64:\n\t\treturn snd_pcm_sync_ptr(substream, arg);\n#ifdef CONFIG_SND_SUPPORT_OLD_API\n\tcase SNDRV_PCM_IOCTL_HW_REFINE_OLD:\n\t\treturn snd_pcm_hw_refine_old_user(substream, arg);\n\tcase SNDRV_PCM_IOCTL_HW_PARAMS_OLD:\n\t\treturn snd_pcm_hw_params_old_user(substream, arg);\n#endif\n\tcase SNDRV_PCM_IOCTL_DRAIN:\n\t\treturn snd_pcm_drain(substream, file);\n\tcase SNDRV_PCM_IOCTL_DROP:\n\t\treturn snd_pcm_drop(substream);\n\tcase SNDRV_PCM_IOCTL_PAUSE:\n\t\treturn snd_pcm_pause_lock_irq(substream, (unsigned long)arg);\n\tcase SNDRV_PCM_IOCTL_WRITEI_FRAMES:\n\tcase SNDRV_PCM_IOCTL_READI_FRAMES:\n\t\treturn snd_pcm_xferi_frames_ioctl(substream, arg);\n\tcase SNDRV_PCM_IOCTL_WRITEN_FRAMES:\n\tcase SNDRV_PCM_IOCTL_READN_FRAMES:\n\t\treturn snd_pcm_xfern_frames_ioctl(substream, arg);\n\tcase SNDRV_PCM_IOCTL_REWIND:\n\t\treturn snd_pcm_rewind_ioctl(substream, arg);\n\tcase SNDRV_PCM_IOCTL_FORWARD:\n\t\treturn snd_pcm_forward_ioctl(substream, arg);\n\t}\n\tpcm_dbg(substream->pcm, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic long snd_pcm_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_pcm_file *pcm_file;\n\n\tpcm_file = file->private_data;\n\n\tif (((cmd >> 8) & 0xff) != 'A')\n\t\treturn -ENOTTY;\n\n\treturn snd_pcm_common_ioctl(file, pcm_file->substream, cmd,\n\t\t\t\t     (void __user *)arg);\n}\n\n \nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,\n\t\t\t unsigned int cmd, void *arg)\n{\n\tsnd_pcm_uframes_t *frames = arg;\n\tsnd_pcm_sframes_t result;\n\t\n\tif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL_FORWARD:\n\t{\n\t\t \n\t\tif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tresult = snd_pcm_forward(substream, *frames);\n\t\treturn result < 0 ? result : 0;\n\t}\n\tcase SNDRV_PCM_IOCTL_HW_PARAMS:\n\t\treturn snd_pcm_hw_params(substream, arg);\n\tcase SNDRV_PCM_IOCTL_SW_PARAMS:\n\t\treturn snd_pcm_sw_params(substream, arg);\n\tcase SNDRV_PCM_IOCTL_PREPARE:\n\t\treturn snd_pcm_prepare(substream, NULL);\n\tcase SNDRV_PCM_IOCTL_START:\n\t\treturn snd_pcm_start_lock_irq(substream);\n\tcase SNDRV_PCM_IOCTL_DRAIN:\n\t\treturn snd_pcm_drain(substream, NULL);\n\tcase SNDRV_PCM_IOCTL_DROP:\n\t\treturn snd_pcm_drop(substream);\n\tcase SNDRV_PCM_IOCTL_DELAY:\n\t\treturn snd_pcm_delay(substream, frames);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(snd_pcm_kernel_ioctl);\n\nstatic ssize_t snd_pcm_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t * offset)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t result;\n\n\tpcm_file = file->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\tif (!frame_aligned(runtime, count))\n\t\treturn -EINVAL;\n\tcount = bytes_to_frames(runtime, count);\n\tresult = snd_pcm_lib_read(substream, buf, count);\n\tif (result > 0)\n\t\tresult = frames_to_bytes(runtime, result);\n\treturn result;\n}\n\nstatic ssize_t snd_pcm_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t * offset)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t result;\n\n\tpcm_file = file->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\tif (!frame_aligned(runtime, count))\n\t\treturn -EINVAL;\n\tcount = bytes_to_frames(runtime, count);\n\tresult = snd_pcm_lib_write(substream, buf, count);\n\tif (result > 0)\n\t\tresult = frames_to_bytes(runtime, result);\n\treturn result;\n}\n\nstatic ssize_t snd_pcm_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t result;\n\tunsigned long i;\n\tvoid __user **bufs;\n\tsnd_pcm_uframes_t frames;\n\tconst struct iovec *iov = iter_iov(to);\n\n\tpcm_file = iocb->ki_filp->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\tif (!to->user_backed)\n\t\treturn -EINVAL;\n\tif (to->nr_segs > 1024 || to->nr_segs != runtime->channels)\n\t\treturn -EINVAL;\n\tif (!frame_aligned(runtime, iov->iov_len))\n\t\treturn -EINVAL;\n\tframes = bytes_to_samples(runtime, iov->iov_len);\n\tbufs = kmalloc_array(to->nr_segs, sizeof(void *), GFP_KERNEL);\n\tif (bufs == NULL)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < to->nr_segs; ++i) {\n\t\tbufs[i] = iov->iov_base;\n\t\tiov++;\n\t}\n\tresult = snd_pcm_lib_readv(substream, bufs, frames);\n\tif (result > 0)\n\t\tresult = frames_to_bytes(runtime, result);\n\tkfree(bufs);\n\treturn result;\n}\n\nstatic ssize_t snd_pcm_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t result;\n\tunsigned long i;\n\tvoid __user **bufs;\n\tsnd_pcm_uframes_t frames;\n\tconst struct iovec *iov = iter_iov(from);\n\n\tpcm_file = iocb->ki_filp->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN ||\n\t    runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\tif (!from->user_backed)\n\t\treturn -EINVAL;\n\tif (from->nr_segs > 128 || from->nr_segs != runtime->channels ||\n\t    !frame_aligned(runtime, iov->iov_len))\n\t\treturn -EINVAL;\n\tframes = bytes_to_samples(runtime, iov->iov_len);\n\tbufs = kmalloc_array(from->nr_segs, sizeof(void *), GFP_KERNEL);\n\tif (bufs == NULL)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < from->nr_segs; ++i) {\n\t\tbufs[i] = iov->iov_base;\n\t\tiov++;\n\t}\n\tresult = snd_pcm_lib_writev(substream, bufs, frames);\n\tif (result > 0)\n\t\tresult = frames_to_bytes(runtime, result);\n\tkfree(bufs);\n\treturn result;\n}\n\nstatic __poll_t snd_pcm_poll(struct file *file, poll_table *wait)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\t__poll_t mask, ok;\n\tsnd_pcm_uframes_t avail;\n\n\tpcm_file = file->private_data;\n\n\tsubstream = pcm_file->substream;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tok = EPOLLOUT | EPOLLWRNORM;\n\telse\n\t\tok = EPOLLIN | EPOLLRDNORM;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn ok | EPOLLERR;\n\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn ok | EPOLLERR;\n\n\tpoll_wait(file, &runtime->sleep, wait);\n\n\tmask = 0;\n\tsnd_pcm_stream_lock_irq(substream);\n\tavail = snd_pcm_avail(substream);\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tif (avail >= runtime->control->avail_min)\n\t\t\tmask = ok;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tmask = ok;\n\t\t\tif (!avail)\n\t\t\t\tmask |= EPOLLERR;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmask = ok | EPOLLERR;\n\t\tbreak;\n\t}\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn mask;\n}\n\n \n\n \n#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)\n \nstatic vm_fault_t snd_pcm_mmap_status_fault(struct vm_fault *vmf)\n{\n\tstruct snd_pcm_substream *substream = vmf->vma->vm_private_data;\n\tstruct snd_pcm_runtime *runtime;\n\t\n\tif (substream == NULL)\n\t\treturn VM_FAULT_SIGBUS;\n\truntime = substream->runtime;\n\tvmf->page = virt_to_page(runtime->status);\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct snd_pcm_vm_ops_status =\n{\n\t.fault =\tsnd_pcm_mmap_status_fault,\n};\n\nstatic int snd_pcm_mmap_status(struct snd_pcm_substream *substream, struct file *file,\n\t\t\t       struct vm_area_struct *area)\n{\n\tlong size;\n\tif (!(area->vm_flags & VM_READ))\n\t\treturn -EINVAL;\n\tsize = area->vm_end - area->vm_start;\n\tif (size != PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)))\n\t\treturn -EINVAL;\n\tarea->vm_ops = &snd_pcm_vm_ops_status;\n\tarea->vm_private_data = substream;\n\tvm_flags_mod(area, VM_DONTEXPAND | VM_DONTDUMP,\n\t\t     VM_WRITE | VM_MAYWRITE);\n\n\treturn 0;\n}\n\n \nstatic vm_fault_t snd_pcm_mmap_control_fault(struct vm_fault *vmf)\n{\n\tstruct snd_pcm_substream *substream = vmf->vma->vm_private_data;\n\tstruct snd_pcm_runtime *runtime;\n\t\n\tif (substream == NULL)\n\t\treturn VM_FAULT_SIGBUS;\n\truntime = substream->runtime;\n\tvmf->page = virt_to_page(runtime->control);\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct snd_pcm_vm_ops_control =\n{\n\t.fault =\tsnd_pcm_mmap_control_fault,\n};\n\nstatic int snd_pcm_mmap_control(struct snd_pcm_substream *substream, struct file *file,\n\t\t\t\tstruct vm_area_struct *area)\n{\n\tlong size;\n\tif (!(area->vm_flags & VM_READ))\n\t\treturn -EINVAL;\n\tsize = area->vm_end - area->vm_start;\n\tif (size != PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)))\n\t\treturn -EINVAL;\n\tarea->vm_ops = &snd_pcm_vm_ops_control;\n\tarea->vm_private_data = substream;\n\tvm_flags_set(area, VM_DONTEXPAND | VM_DONTDUMP);\n\treturn 0;\n}\n\nstatic bool pcm_status_mmap_allowed(struct snd_pcm_file *pcm_file)\n{\n\t \n\tif (pcm_file->substream->runtime->hw.info & SNDRV_PCM_INFO_EXPLICIT_SYNC)\n\t\treturn false;\n\t \n\tif (pcm_file->user_pversion < SNDRV_PROTOCOL_VERSION(2, 0, 14) &&\n\t    (pcm_file->substream->runtime->hw.info & SNDRV_PCM_INFO_SYNC_APPLPTR))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool pcm_control_mmap_allowed(struct snd_pcm_file *pcm_file)\n{\n\tif (pcm_file->no_compat_mmap)\n\t\treturn false;\n\t \n\tif (pcm_file->substream->runtime->hw.info & SNDRV_PCM_INFO_EXPLICIT_SYNC)\n\t\treturn false;\n\t \n\tif (pcm_file->substream->runtime->hw.info & SNDRV_PCM_INFO_SYNC_APPLPTR)\n\t\treturn false;\n\treturn true;\n}\n\n#else  \n \n#define pcm_status_mmap_allowed(pcm_file)\tfalse\n#define pcm_control_mmap_allowed(pcm_file)\tfalse\n\nstatic int snd_pcm_mmap_status(struct snd_pcm_substream *substream, struct file *file,\n\t\t\t       struct vm_area_struct *area)\n{\n\treturn -ENXIO;\n}\nstatic int snd_pcm_mmap_control(struct snd_pcm_substream *substream, struct file *file,\n\t\t\t\tstruct vm_area_struct *area)\n{\n\treturn -ENXIO;\n}\n#endif  \n\n \nstatic vm_fault_t snd_pcm_mmap_data_fault(struct vm_fault *vmf)\n{\n\tstruct snd_pcm_substream *substream = vmf->vma->vm_private_data;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long offset;\n\tstruct page * page;\n\tsize_t dma_bytes;\n\t\n\tif (substream == NULL)\n\t\treturn VM_FAULT_SIGBUS;\n\truntime = substream->runtime;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tdma_bytes = PAGE_ALIGN(runtime->dma_bytes);\n\tif (offset > dma_bytes - PAGE_SIZE)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (substream->ops->page)\n\t\tpage = substream->ops->page(substream, offset);\n\telse if (!snd_pcm_get_dma_buf(substream))\n\t\tpage = virt_to_page(runtime->dma_area + offset);\n\telse\n\t\tpage = snd_sgbuf_get_page(snd_pcm_get_dma_buf(substream), offset);\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct snd_pcm_vm_ops_data = {\n\t.open =\t\tsnd_pcm_mmap_data_open,\n\t.close =\tsnd_pcm_mmap_data_close,\n};\n\nstatic const struct vm_operations_struct snd_pcm_vm_ops_data_fault = {\n\t.open =\t\tsnd_pcm_mmap_data_open,\n\t.close =\tsnd_pcm_mmap_data_close,\n\t.fault =\tsnd_pcm_mmap_data_fault,\n};\n\n \n\n \nint snd_pcm_lib_default_mmap(struct snd_pcm_substream *substream,\n\t\t\t     struct vm_area_struct *area)\n{\n\tvm_flags_set(area, VM_DONTEXPAND | VM_DONTDUMP);\n\tif (!substream->ops->page &&\n\t    !snd_dma_buffer_mmap(snd_pcm_get_dma_buf(substream), area))\n\t\treturn 0;\n\t \n\tarea->vm_ops = &snd_pcm_vm_ops_data_fault;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_lib_default_mmap);\n\n \n#if SNDRV_PCM_INFO_MMAP_IOMEM\n \nint snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream,\n\t\t\t   struct vm_area_struct *area)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tarea->vm_page_prot = pgprot_noncached(area->vm_page_prot);\n\treturn vm_iomap_memory(area, runtime->dma_addr, runtime->dma_bytes);\n}\nEXPORT_SYMBOL(snd_pcm_lib_mmap_iomem);\n#endif  \n\n \nint snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file,\n\t\t      struct vm_area_struct *area)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tlong size;\n\tunsigned long offset;\n\tsize_t dma_bytes;\n\tint err;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (!(area->vm_flags & (VM_WRITE|VM_READ)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(area->vm_flags & VM_READ))\n\t\t\treturn -EINVAL;\n\t}\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\tif (!(runtime->info & SNDRV_PCM_INFO_MMAP))\n\t\treturn -ENXIO;\n\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\n\t    runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\tsize = area->vm_end - area->vm_start;\n\toffset = area->vm_pgoff << PAGE_SHIFT;\n\tdma_bytes = PAGE_ALIGN(runtime->dma_bytes);\n\tif ((size_t)size > dma_bytes)\n\t\treturn -EINVAL;\n\tif (offset > dma_bytes - size)\n\t\treturn -EINVAL;\n\n\tarea->vm_ops = &snd_pcm_vm_ops_data;\n\tarea->vm_private_data = substream;\n\tif (substream->ops->mmap)\n\t\terr = substream->ops->mmap(substream, area);\n\telse\n\t\terr = snd_pcm_lib_default_mmap(substream, area);\n\tif (!err)\n\t\tatomic_inc(&substream->mmap_count);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_pcm_mmap_data);\n\nstatic int snd_pcm_mmap(struct file *file, struct vm_area_struct *area)\n{\n\tstruct snd_pcm_file * pcm_file;\n\tstruct snd_pcm_substream *substream;\t\n\tunsigned long offset;\n\t\n\tpcm_file = file->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\tif (substream->runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\n\toffset = area->vm_pgoff << PAGE_SHIFT;\n\tswitch (offset) {\n\tcase SNDRV_PCM_MMAP_OFFSET_STATUS_OLD:\n\t\tif (pcm_file->no_compat_mmap || !IS_ENABLED(CONFIG_64BIT))\n\t\t\treturn -ENXIO;\n\t\tfallthrough;\n\tcase SNDRV_PCM_MMAP_OFFSET_STATUS_NEW:\n\t\tif (!pcm_status_mmap_allowed(pcm_file))\n\t\t\treturn -ENXIO;\n\t\treturn snd_pcm_mmap_status(substream, file, area);\n\tcase SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD:\n\t\tif (pcm_file->no_compat_mmap || !IS_ENABLED(CONFIG_64BIT))\n\t\t\treturn -ENXIO;\n\t\tfallthrough;\n\tcase SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW:\n\t\tif (!pcm_control_mmap_allowed(pcm_file))\n\t\t\treturn -ENXIO;\n\t\treturn snd_pcm_mmap_control(substream, file, area);\n\tdefault:\n\t\treturn snd_pcm_mmap_data(substream, file, area);\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_pcm_file * pcm_file;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\n\tpcm_file = file->private_data;\n\tsubstream = pcm_file->substream;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (runtime->state == SNDRV_PCM_STATE_DISCONNECTED)\n\t\treturn -EBADFD;\n\treturn snd_fasync_helper(fd, file, on, &runtime->fasync);\n}\n\n \n#ifdef CONFIG_COMPAT\n#include \"pcm_compat.c\"\n#else\n#define snd_pcm_ioctl_compat\tNULL\n#endif\n\n \n\n#ifdef CONFIG_SND_SUPPORT_OLD_API\n#define __OLD_TO_NEW_MASK(x) ((x&7)|((x&0x07fffff8)<<5))\n#define __NEW_TO_OLD_MASK(x) ((x&7)|((x&0xffffff00)>>5))\n\nstatic void snd_pcm_hw_convert_from_old_params(struct snd_pcm_hw_params *params,\n\t\t\t\t\t       struct snd_pcm_hw_params_old *oparams)\n{\n\tunsigned int i;\n\n\tmemset(params, 0, sizeof(*params));\n\tparams->flags = oparams->flags;\n\tfor (i = 0; i < ARRAY_SIZE(oparams->masks); i++)\n\t\tparams->masks[i].bits[0] = oparams->masks[i];\n\tmemcpy(params->intervals, oparams->intervals, sizeof(oparams->intervals));\n\tparams->rmask = __OLD_TO_NEW_MASK(oparams->rmask);\n\tparams->cmask = __OLD_TO_NEW_MASK(oparams->cmask);\n\tparams->info = oparams->info;\n\tparams->msbits = oparams->msbits;\n\tparams->rate_num = oparams->rate_num;\n\tparams->rate_den = oparams->rate_den;\n\tparams->fifo_size = oparams->fifo_size;\n}\n\nstatic void snd_pcm_hw_convert_to_old_params(struct snd_pcm_hw_params_old *oparams,\n\t\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tunsigned int i;\n\n\tmemset(oparams, 0, sizeof(*oparams));\n\toparams->flags = params->flags;\n\tfor (i = 0; i < ARRAY_SIZE(oparams->masks); i++)\n\t\toparams->masks[i] = params->masks[i].bits[0];\n\tmemcpy(oparams->intervals, params->intervals, sizeof(oparams->intervals));\n\toparams->rmask = __NEW_TO_OLD_MASK(params->rmask);\n\toparams->cmask = __NEW_TO_OLD_MASK(params->cmask);\n\toparams->info = params->info;\n\toparams->msbits = params->msbits;\n\toparams->rate_num = params->rate_num;\n\toparams->rate_den = params->rate_den;\n\toparams->fifo_size = params->fifo_size;\n}\n\nstatic int snd_pcm_hw_refine_old_user(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params_old __user * _oparams)\n{\n\tstruct snd_pcm_hw_params *params;\n\tstruct snd_pcm_hw_params_old *oparams = NULL;\n\tint err;\n\n\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\toparams = memdup_user(_oparams, sizeof(*oparams));\n\tif (IS_ERR(oparams)) {\n\t\terr = PTR_ERR(oparams);\n\t\tgoto out;\n\t}\n\tsnd_pcm_hw_convert_from_old_params(params, oparams);\n\terr = snd_pcm_hw_refine(substream, params);\n\tif (err < 0)\n\t\tgoto out_old;\n\n\terr = fixup_unreferenced_params(substream, params);\n\tif (err < 0)\n\t\tgoto out_old;\n\n\tsnd_pcm_hw_convert_to_old_params(oparams, params);\n\tif (copy_to_user(_oparams, oparams, sizeof(*oparams)))\n\t\terr = -EFAULT;\nout_old:\n\tkfree(oparams);\nout:\n\tkfree(params);\n\treturn err;\n}\n\nstatic int snd_pcm_hw_params_old_user(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params_old __user * _oparams)\n{\n\tstruct snd_pcm_hw_params *params;\n\tstruct snd_pcm_hw_params_old *oparams = NULL;\n\tint err;\n\n\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\toparams = memdup_user(_oparams, sizeof(*oparams));\n\tif (IS_ERR(oparams)) {\n\t\terr = PTR_ERR(oparams);\n\t\tgoto out;\n\t}\n\n\tsnd_pcm_hw_convert_from_old_params(params, oparams);\n\terr = snd_pcm_hw_params(substream, params);\n\tif (err < 0)\n\t\tgoto out_old;\n\n\tsnd_pcm_hw_convert_to_old_params(oparams, params);\n\tif (copy_to_user(_oparams, oparams, sizeof(*oparams)))\n\t\terr = -EFAULT;\nout_old:\n\tkfree(oparams);\nout:\n\tkfree(params);\n\treturn err;\n}\n#endif  \n\n#ifndef CONFIG_MMU\nstatic unsigned long snd_pcm_get_unmapped_area(struct file *file,\n\t\t\t\t\t       unsigned long addr,\n\t\t\t\t\t       unsigned long len,\n\t\t\t\t\t       unsigned long pgoff,\n\t\t\t\t\t       unsigned long flags)\n{\n\tstruct snd_pcm_file *pcm_file = file->private_data;\n\tstruct snd_pcm_substream *substream = pcm_file->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long offset = pgoff << PAGE_SHIFT;\n\n\tswitch (offset) {\n\tcase SNDRV_PCM_MMAP_OFFSET_STATUS_NEW:\n\t\treturn (unsigned long)runtime->status;\n\tcase SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW:\n\t\treturn (unsigned long)runtime->control;\n\tdefault:\n\t\treturn (unsigned long)runtime->dma_area + offset;\n\t}\n}\n#else\n# define snd_pcm_get_unmapped_area NULL\n#endif\n\n \n\nconst struct file_operations snd_pcm_f_ops[2] = {\n\t{\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.write =\t\tsnd_pcm_write,\n\t\t.write_iter =\t\tsnd_pcm_writev,\n\t\t.open =\t\t\tsnd_pcm_playback_open,\n\t\t.release =\t\tsnd_pcm_release,\n\t\t.llseek =\t\tno_llseek,\n\t\t.poll =\t\t\tsnd_pcm_poll,\n\t\t.unlocked_ioctl =\tsnd_pcm_ioctl,\n\t\t.compat_ioctl = \tsnd_pcm_ioctl_compat,\n\t\t.mmap =\t\t\tsnd_pcm_mmap,\n\t\t.fasync =\t\tsnd_pcm_fasync,\n\t\t.get_unmapped_area =\tsnd_pcm_get_unmapped_area,\n\t},\n\t{\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.read =\t\t\tsnd_pcm_read,\n\t\t.read_iter =\t\tsnd_pcm_readv,\n\t\t.open =\t\t\tsnd_pcm_capture_open,\n\t\t.release =\t\tsnd_pcm_release,\n\t\t.llseek =\t\tno_llseek,\n\t\t.poll =\t\t\tsnd_pcm_poll,\n\t\t.unlocked_ioctl =\tsnd_pcm_ioctl,\n\t\t.compat_ioctl = \tsnd_pcm_ioctl_compat,\n\t\t.mmap =\t\t\tsnd_pcm_mmap,\n\t\t.fasync =\t\tsnd_pcm_fasync,\n\t\t.get_unmapped_area =\tsnd_pcm_get_unmapped_area,\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}