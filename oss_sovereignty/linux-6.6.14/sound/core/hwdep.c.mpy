{
  "module_name": "hwdep.c",
  "hash_id": "46e03c1e45b6fba593110819bf2d76e806c8f11ccc366dfdc206bff5922cd91f",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/hwdep.c",
  "human_readable_source": "\n \n\n#include <linux/major.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/minors.h>\n#include <sound/hwdep.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Hardware dependent layer\");\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(snd_hwdep_devices);\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic int snd_hwdep_dev_free(struct snd_device *device);\nstatic int snd_hwdep_dev_register(struct snd_device *device);\nstatic int snd_hwdep_dev_disconnect(struct snd_device *device);\n\n\nstatic struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)\n{\n\tstruct snd_hwdep *hwdep;\n\n\tlist_for_each_entry(hwdep, &snd_hwdep_devices, list)\n\t\tif (hwdep->card == card && hwdep->device == device)\n\t\t\treturn hwdep;\n\treturn NULL;\n}\n\nstatic loff_t snd_hwdep_llseek(struct file * file, loff_t offset, int orig)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tif (hw->ops.llseek)\n\t\treturn hw->ops.llseek(hw, file, offset, orig);\n\treturn -ENXIO;\n}\n\nstatic ssize_t snd_hwdep_read(struct file * file, char __user *buf,\n\t\t\t      size_t count, loff_t *offset)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tif (hw->ops.read)\n\t\treturn hw->ops.read(hw, buf, count, offset);\n\treturn -ENXIO;\t\n}\n\nstatic ssize_t snd_hwdep_write(struct file * file, const char __user *buf,\n\t\t\t       size_t count, loff_t *offset)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tif (hw->ops.write)\n\t\treturn hw->ops.write(hw, buf, count, offset);\n\treturn -ENXIO;\t\n}\n\nstatic int snd_hwdep_open(struct inode *inode, struct file * file)\n{\n\tint major = imajor(inode);\n\tstruct snd_hwdep *hw;\n\tint err;\n\twait_queue_entry_t wait;\n\n\tif (major == snd_major) {\n\t\thw = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t\t   SNDRV_DEVICE_TYPE_HWDEP);\n#ifdef CONFIG_SND_OSSEMUL\n\t} else if (major == SOUND_MAJOR) {\n\t\thw = snd_lookup_oss_minor_data(iminor(inode),\n\t\t\t\t\t       SNDRV_OSS_DEVICE_TYPE_DMFM);\n#endif\n\t} else\n\t\treturn -ENXIO;\n\tif (hw == NULL)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(hw->card->module)) {\n\t\tsnd_card_unref(hw->card);\n\t\treturn -EFAULT;\n\t}\n\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&hw->open_wait, &wait);\n\tmutex_lock(&hw->open_mutex);\n\twhile (1) {\n\t\tif (hw->exclusive && hw->used > 0) {\n\t\t\terr = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (!hw->ops.open) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\terr = hw->ops.open(hw, file);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif (err == -EAGAIN) {\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tmutex_unlock(&hw->open_mutex);\n\t\tschedule();\n\t\tmutex_lock(&hw->open_mutex);\n\t\tif (hw->card->shutdown) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&hw->open_wait, &wait);\n\tif (err >= 0) {\n\t\terr = snd_card_file_add(hw->card, file);\n\t\tif (err >= 0) {\n\t\t\tfile->private_data = hw;\n\t\t\thw->used++;\n\t\t} else {\n\t\t\tif (hw->ops.release)\n\t\t\t\thw->ops.release(hw, file);\n\t\t}\n\t}\n\tmutex_unlock(&hw->open_mutex);\n\tif (err < 0)\n\t\tmodule_put(hw->card->module);\n\tsnd_card_unref(hw->card);\n\treturn err;\n}\n\nstatic int snd_hwdep_release(struct inode *inode, struct file * file)\n{\n\tint err = 0;\n\tstruct snd_hwdep *hw = file->private_data;\n\tstruct module *mod = hw->card->module;\n\n\tmutex_lock(&hw->open_mutex);\n\tif (hw->ops.release)\n\t\terr = hw->ops.release(hw, file);\n\tif (hw->used > 0)\n\t\thw->used--;\n\tmutex_unlock(&hw->open_mutex);\n\twake_up(&hw->open_wait);\n\n\tsnd_card_file_remove(hw->card, file);\n\tmodule_put(mod);\n\treturn err;\n}\n\nstatic __poll_t snd_hwdep_poll(struct file * file, poll_table * wait)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tif (hw->ops.poll)\n\t\treturn hw->ops.poll(hw, file, wait);\n\treturn 0;\n}\n\nstatic int snd_hwdep_info(struct snd_hwdep *hw,\n\t\t\t  struct snd_hwdep_info __user *_info)\n{\n\tstruct snd_hwdep_info info;\n\t\n\tmemset(&info, 0, sizeof(info));\n\tinfo.card = hw->card->number;\n\tstrscpy(info.id, hw->id, sizeof(info.id));\n\tstrscpy(info.name, hw->name, sizeof(info.name));\n\tinfo.iface = hw->iface;\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_hwdep_dsp_status(struct snd_hwdep *hw,\n\t\t\t\tstruct snd_hwdep_dsp_status __user *_info)\n{\n\tstruct snd_hwdep_dsp_status info;\n\tint err;\n\t\n\tif (! hw->ops.dsp_status)\n\t\treturn -ENXIO;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dsp_loaded = hw->dsp_loaded;\n\terr = hw->ops.dsp_status(hw, &info);\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_hwdep_dsp_load(struct snd_hwdep *hw,\n\t\t\t      struct snd_hwdep_dsp_image *info)\n{\n\tint err;\n\t\n\tif (! hw->ops.dsp_load)\n\t\treturn -ENXIO;\n\tif (info->index >= 32)\n\t\treturn -EINVAL;\n\t \n\tif (hw->dsp_loaded & (1u << info->index))\n\t\treturn -EBUSY;\n\terr = hw->ops.dsp_load(hw, info);\n\tif (err < 0)\n\t\treturn err;\n\thw->dsp_loaded |= (1u << info->index);\n\treturn 0;\n}\n\nstatic int snd_hwdep_dsp_load_user(struct snd_hwdep *hw,\n\t\t\t\t   struct snd_hwdep_dsp_image __user *_info)\n{\n\tstruct snd_hwdep_dsp_image info = {};\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn snd_hwdep_dsp_load(hw, &info);\n}\n\n\nstatic long snd_hwdep_ioctl(struct file * file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase SNDRV_HWDEP_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_HWDEP_VERSION, (int __user *)argp);\n\tcase SNDRV_HWDEP_IOCTL_INFO:\n\t\treturn snd_hwdep_info(hw, argp);\n\tcase SNDRV_HWDEP_IOCTL_DSP_STATUS:\n\t\treturn snd_hwdep_dsp_status(hw, argp);\n\tcase SNDRV_HWDEP_IOCTL_DSP_LOAD:\n\t\treturn snd_hwdep_dsp_load_user(hw, argp);\n\t}\n\tif (hw->ops.ioctl)\n\t\treturn hw->ops.ioctl(hw, file, cmd, arg);\n\treturn -ENOTTY;\n}\n\nstatic int snd_hwdep_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct snd_hwdep *hw = file->private_data;\n\tif (hw->ops.mmap)\n\t\treturn hw->ops.mmap(hw, file, vma);\n\treturn -ENXIO;\n}\n\nstatic int snd_hwdep_control_ioctl(struct snd_card *card,\n\t\t\t\t   struct snd_ctl_file * control,\n\t\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE:\n\t\t{\n\t\t\tint device;\n\n\t\t\tif (get_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\n\t\t\tif (device < 0)\n\t\t\t\tdevice = 0;\n\t\t\telse if (device < SNDRV_MINOR_HWDEPS)\n\t\t\t\tdevice++;\n\t\t\telse\n\t\t\t\tdevice = SNDRV_MINOR_HWDEPS;\n\n\t\t\twhile (device < SNDRV_MINOR_HWDEPS) {\n\t\t\t\tif (snd_hwdep_search(card, device))\n\t\t\t\t\tbreak;\n\t\t\t\tdevice++;\n\t\t\t}\n\t\t\tif (device >= SNDRV_MINOR_HWDEPS)\n\t\t\t\tdevice = -1;\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\tif (put_user(device, (int __user *)arg))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase SNDRV_CTL_IOCTL_HWDEP_INFO:\n\t\t{\n\t\t\tstruct snd_hwdep_info __user *info = (struct snd_hwdep_info __user *)arg;\n\t\t\tint device, err;\n\t\t\tstruct snd_hwdep *hwdep;\n\n\t\t\tif (get_user(device, &info->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&register_mutex);\n\t\t\thwdep = snd_hwdep_search(card, device);\n\t\t\tif (hwdep)\n\t\t\t\terr = snd_hwdep_info(hwdep, info);\n\t\t\telse\n\t\t\t\terr = -ENXIO;\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"hwdep_compat.c\"\n#else\n#define snd_hwdep_ioctl_compat\tNULL\n#endif\n\n \n\nstatic const struct file_operations snd_hwdep_f_ops =\n{\n\t.owner = \tTHIS_MODULE,\n\t.llseek =\tsnd_hwdep_llseek,\n\t.read = \tsnd_hwdep_read,\n\t.write =\tsnd_hwdep_write,\n\t.open =\t\tsnd_hwdep_open,\n\t.release =\tsnd_hwdep_release,\n\t.poll =\t\tsnd_hwdep_poll,\n\t.unlocked_ioctl =\tsnd_hwdep_ioctl,\n\t.compat_ioctl =\tsnd_hwdep_ioctl_compat,\n\t.mmap =\t\tsnd_hwdep_mmap,\n};\n\nstatic void snd_hwdep_free(struct snd_hwdep *hwdep)\n{\n\tif (!hwdep)\n\t\treturn;\n\tif (hwdep->private_free)\n\t\thwdep->private_free(hwdep);\n\tput_device(hwdep->dev);\n\tkfree(hwdep);\n}\n\n \nint snd_hwdep_new(struct snd_card *card, char *id, int device,\n\t\t  struct snd_hwdep **rhwdep)\n{\n\tstruct snd_hwdep *hwdep;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_hwdep_dev_free,\n\t\t.dev_register = snd_hwdep_dev_register,\n\t\t.dev_disconnect = snd_hwdep_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tif (rhwdep)\n\t\t*rhwdep = NULL;\n\thwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);\n\tif (!hwdep)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&hwdep->open_wait);\n\tmutex_init(&hwdep->open_mutex);\n\thwdep->card = card;\n\thwdep->device = device;\n\tif (id)\n\t\tstrscpy(hwdep->id, id, sizeof(hwdep->id));\n\n\terr = snd_device_alloc(&hwdep->dev, card);\n\tif (err < 0) {\n\t\tsnd_hwdep_free(hwdep);\n\t\treturn err;\n\t}\n\n\tdev_set_name(hwdep->dev, \"hwC%iD%i\", card->number, device);\n#ifdef CONFIG_SND_OSSEMUL\n\thwdep->oss_type = -1;\n#endif\n\n\terr = snd_device_new(card, SNDRV_DEV_HWDEP, hwdep, &ops);\n\tif (err < 0) {\n\t\tsnd_hwdep_free(hwdep);\n\t\treturn err;\n\t}\n\n\tif (rhwdep)\n\t\t*rhwdep = hwdep;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_hwdep_new);\n\nstatic int snd_hwdep_dev_free(struct snd_device *device)\n{\n\tsnd_hwdep_free(device->device_data);\n\treturn 0;\n}\n\nstatic int snd_hwdep_dev_register(struct snd_device *device)\n{\n\tstruct snd_hwdep *hwdep = device->device_data;\n\tstruct snd_card *card = hwdep->card;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (snd_hwdep_search(card, hwdep->device)) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&hwdep->list, &snd_hwdep_devices);\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,\n\t\t\t\t  hwdep->card, hwdep->device,\n\t\t\t\t  &snd_hwdep_f_ops, hwdep, hwdep->dev);\n\tif (err < 0) {\n\t\tdev_err(hwdep->dev, \"unable to register\\n\");\n\t\tlist_del(&hwdep->list);\n\t\tmutex_unlock(&register_mutex);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_SND_OSSEMUL\n\thwdep->ossreg = 0;\n\tif (hwdep->oss_type >= 0) {\n\t\tif (hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM &&\n\t\t    hwdep->device)\n\t\t\tdev_warn(hwdep->dev,\n\t\t\t\t \"only hwdep device 0 can be registered as OSS direct FM device!\\n\");\n\t\telse if (snd_register_oss_device(hwdep->oss_type,\n\t\t\t\t\t\t card, hwdep->device,\n\t\t\t\t\t\t &snd_hwdep_f_ops, hwdep) < 0)\n\t\t\tdev_warn(hwdep->dev,\n\t\t\t\t \"unable to register OSS compatibility device\\n\");\n\t\telse\n\t\t\thwdep->ossreg = 1;\n\t}\n#endif\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\nstatic int snd_hwdep_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_hwdep *hwdep = device->device_data;\n\n\tif (snd_BUG_ON(!hwdep))\n\t\treturn -ENXIO;\n\tmutex_lock(&register_mutex);\n\tif (snd_hwdep_search(hwdep->card, hwdep->device) != hwdep) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&hwdep->open_mutex);\n\twake_up(&hwdep->open_wait);\n#ifdef CONFIG_SND_OSSEMUL\n\tif (hwdep->ossreg)\n\t\tsnd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);\n#endif\n\tsnd_unregister_device(hwdep->dev);\n\tlist_del_init(&hwdep->list);\n\tmutex_unlock(&hwdep->open_mutex);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_PROC_FS\n \n\nstatic void snd_hwdep_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_hwdep *hwdep;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(hwdep, &snd_hwdep_devices, list)\n\t\tsnd_iprintf(buffer, \"%02i-%02i: %s\\n\",\n\t\t\t    hwdep->card->number, hwdep->device, hwdep->name);\n\tmutex_unlock(&register_mutex);\n}\n\nstatic struct snd_info_entry *snd_hwdep_proc_entry;\n\nstatic void __init snd_hwdep_proc_init(void)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_module_entry(THIS_MODULE, \"hwdep\", NULL);\n\tif (entry) {\n\t\tentry->c.text.read = snd_hwdep_proc_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tsnd_hwdep_proc_entry = entry;\n}\n\nstatic void __exit snd_hwdep_proc_done(void)\n{\n\tsnd_info_free_entry(snd_hwdep_proc_entry);\n}\n#else  \n#define snd_hwdep_proc_init()\n#define snd_hwdep_proc_done()\n#endif  \n\n\n \n\nstatic int __init alsa_hwdep_init(void)\n{\n\tsnd_hwdep_proc_init();\n\tsnd_ctl_register_ioctl(snd_hwdep_control_ioctl);\n\tsnd_ctl_register_ioctl_compat(snd_hwdep_control_ioctl);\n\treturn 0;\n}\n\nstatic void __exit alsa_hwdep_exit(void)\n{\n\tsnd_ctl_unregister_ioctl(snd_hwdep_control_ioctl);\n\tsnd_ctl_unregister_ioctl_compat(snd_hwdep_control_ioctl);\n\tsnd_hwdep_proc_done();\n}\n\nmodule_init(alsa_hwdep_init)\nmodule_exit(alsa_hwdep_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}