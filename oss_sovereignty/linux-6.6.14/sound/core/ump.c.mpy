{
  "module_name": "ump.c",
  "hash_id": "f787b9df801494ca748ae69785a54cc675608519451dd0dc344b038b1725dcf2",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/ump.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <sound/core.h>\n#include <sound/rawmidi.h>\n#include <sound/ump.h>\n#include <sound/ump_convert.h>\n\n#define ump_err(ump, fmt, args...)\tdev_err((ump)->core.dev, fmt, ##args)\n#define ump_warn(ump, fmt, args...)\tdev_warn((ump)->core.dev, fmt, ##args)\n#define ump_info(ump, fmt, args...)\tdev_info((ump)->core.dev, fmt, ##args)\n#define ump_dbg(ump, fmt, args...)\tdev_dbg((ump)->core.dev, fmt, ##args)\n\nstatic int snd_ump_dev_register(struct snd_rawmidi *rmidi);\nstatic int snd_ump_dev_unregister(struct snd_rawmidi *rmidi);\nstatic long snd_ump_ioctl(struct snd_rawmidi *rmidi, unsigned int cmd,\n\t\t\t  void __user *argp);\nstatic void snd_ump_proc_read(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_buffer *buffer);\nstatic int snd_ump_rawmidi_open(struct snd_rawmidi_substream *substream);\nstatic int snd_ump_rawmidi_close(struct snd_rawmidi_substream *substream);\nstatic void snd_ump_rawmidi_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t    int up);\nstatic void snd_ump_rawmidi_drain(struct snd_rawmidi_substream *substream);\n\nstatic void ump_handle_stream_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const u32 *buf, int size);\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\nstatic int process_legacy_output(struct snd_ump_endpoint *ump,\n\t\t\t\t u32 *buffer, int count);\nstatic void process_legacy_input(struct snd_ump_endpoint *ump, const u32 *src,\n\t\t\t\t int words);\n#else\nstatic inline int process_legacy_output(struct snd_ump_endpoint *ump,\n\t\t\t\t\tu32 *buffer, int count)\n{\n\treturn 0;\n}\nstatic inline void process_legacy_input(struct snd_ump_endpoint *ump,\n\t\t\t\t\tconst u32 *src, int words)\n{\n}\n#endif\n\nstatic const struct snd_rawmidi_global_ops snd_ump_rawmidi_ops = {\n\t.dev_register = snd_ump_dev_register,\n\t.dev_unregister = snd_ump_dev_unregister,\n\t.ioctl = snd_ump_ioctl,\n\t.proc_read = snd_ump_proc_read,\n};\n\nstatic const struct snd_rawmidi_ops snd_ump_rawmidi_input_ops = {\n\t.open = snd_ump_rawmidi_open,\n\t.close = snd_ump_rawmidi_close,\n\t.trigger = snd_ump_rawmidi_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_ump_rawmidi_output_ops = {\n\t.open = snd_ump_rawmidi_open,\n\t.close = snd_ump_rawmidi_close,\n\t.trigger = snd_ump_rawmidi_trigger,\n\t.drain = snd_ump_rawmidi_drain,\n};\n\nstatic void snd_ump_endpoint_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(rmidi);\n\tstruct snd_ump_block *fb;\n\n\twhile (!list_empty(&ump->block_list)) {\n\t\tfb = list_first_entry(&ump->block_list, struct snd_ump_block,\n\t\t\t\t      list);\n\t\tlist_del(&fb->list);\n\t\tif (fb->private_free)\n\t\t\tfb->private_free(fb);\n\t\tkfree(fb);\n\t}\n\n\tif (ump->private_free)\n\t\tump->private_free(ump);\n\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\n\tkfree(ump->out_cvts);\n#endif\n}\n\n \nint snd_ump_endpoint_new(struct snd_card *card, char *id, int device,\n\t\t\t int output, int input,\n\t\t\t struct snd_ump_endpoint **ump_ret)\n{\n\tunsigned int info_flags = SNDRV_RAWMIDI_INFO_UMP;\n\tstruct snd_ump_endpoint *ump;\n\tint err;\n\n\tif (input)\n\t\tinfo_flags |= SNDRV_RAWMIDI_INFO_INPUT;\n\tif (output)\n\t\tinfo_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;\n\tif (input && output)\n\t\tinfo_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;\n\n\tump = kzalloc(sizeof(*ump), GFP_KERNEL);\n\tif (!ump)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&ump->block_list);\n\tmutex_init(&ump->open_mutex);\n\tinit_waitqueue_head(&ump->stream_wait);\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\n\tspin_lock_init(&ump->legacy_locks[0]);\n\tspin_lock_init(&ump->legacy_locks[1]);\n#endif\n\terr = snd_rawmidi_init(&ump->core, card, id, device,\n\t\t\t       output, input, info_flags);\n\tif (err < 0) {\n\t\tsnd_rawmidi_free(&ump->core);\n\t\treturn err;\n\t}\n\n\tump->info.card = card->number;\n\tump->info.device = device;\n\n\tump->core.private_free = snd_ump_endpoint_free;\n\tump->core.ops = &snd_ump_rawmidi_ops;\n\tif (input)\n\t\tsnd_rawmidi_set_ops(&ump->core, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t    &snd_ump_rawmidi_input_ops);\n\tif (output)\n\t\tsnd_rawmidi_set_ops(&ump->core, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t    &snd_ump_rawmidi_output_ops);\n\n\tump_dbg(ump, \"Created a UMP EP #%d (%s)\\n\", device, id);\n\t*ump_ret = ump;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ump_endpoint_new);\n\n \n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\nstatic void snd_ump_dev_seq_free(struct snd_seq_device *device)\n{\n\tstruct snd_ump_endpoint *ump = device->private_data;\n\n\tump->seq_dev = NULL;\n}\n#endif\n\nstatic int snd_ump_dev_register(struct snd_rawmidi *rmidi)\n{\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(rmidi);\n\tint err;\n\n\terr = snd_seq_device_new(ump->core.card, ump->core.device,\n\t\t\t\t SNDRV_SEQ_DEV_ID_UMP, 0, &ump->seq_dev);\n\tif (err < 0)\n\t\treturn err;\n\tump->seq_dev->private_data = ump;\n\tump->seq_dev->private_free = snd_ump_dev_seq_free;\n\tsnd_device_register(ump->core.card, ump->seq_dev);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ump_dev_unregister(struct snd_rawmidi *rmidi)\n{\n\treturn 0;\n}\n\nstatic struct snd_ump_block *\nsnd_ump_get_block(struct snd_ump_endpoint *ump, unsigned char id)\n{\n\tstruct snd_ump_block *fb;\n\n\tlist_for_each_entry(fb, &ump->block_list, list) {\n\t\tif (fb->info.block_id == id)\n\t\t\treturn fb;\n\t}\n\treturn NULL;\n}\n\n \nstatic int snd_ump_rawmidi_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(substream->rmidi);\n\tint dir = substream->stream;\n\tint err;\n\n\tif (ump->substreams[dir])\n\t\treturn -EBUSY;\n\terr = ump->ops->open(ump, dir);\n\tif (err < 0)\n\t\treturn err;\n\tump->substreams[dir] = substream;\n\treturn 0;\n}\n\nstatic int snd_ump_rawmidi_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(substream->rmidi);\n\tint dir = substream->stream;\n\n\tump->substreams[dir] = NULL;\n\tump->ops->close(ump, dir);\n\treturn 0;\n}\n\nstatic void snd_ump_rawmidi_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t    int up)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(substream->rmidi);\n\tint dir = substream->stream;\n\n\tump->ops->trigger(ump, dir, up);\n}\n\nstatic void snd_ump_rawmidi_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(substream->rmidi);\n\n\tif (ump->ops->drain)\n\t\tump->ops->drain(ump, SNDRV_RAWMIDI_STREAM_OUTPUT);\n}\n\n \nstatic unsigned char ump_packet_words[0x10] = {\n\t1, 1, 1, 2, 2, 4, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4\n};\n\n \nint snd_ump_receive_ump_val(struct snd_ump_endpoint *ump, u32 val)\n{\n\tint words;\n\n\tif (!ump->input_pending)\n\t\tump->input_pending = ump_packet_words[ump_message_type(val)];\n\n\tump->input_buf[ump->input_buf_head++] = val;\n\tump->input_pending--;\n\tif (!ump->input_pending) {\n\t\twords = ump->input_buf_head;\n\t\tump->input_buf_head = 0;\n\t\treturn words;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ump_receive_ump_val);\n\n \nint snd_ump_receive(struct snd_ump_endpoint *ump, const u32 *buffer, int count)\n{\n\tstruct snd_rawmidi_substream *substream;\n\tconst u32 *p = buffer;\n\tint n, words = count >> 2;\n\n\twhile (words--) {\n\t\tn = snd_ump_receive_ump_val(ump, *p++);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tump_handle_stream_msg(ump, ump->input_buf, n);\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\t\tif (ump->seq_ops)\n\t\t\tump->seq_ops->input_receive(ump, ump->input_buf, n);\n#endif\n\t\tprocess_legacy_input(ump, ump->input_buf, n);\n\t}\n\n\tsubstream = ump->substreams[SNDRV_RAWMIDI_STREAM_INPUT];\n\tif (!substream)\n\t\treturn 0;\n\treturn snd_rawmidi_receive(substream, (const char *)buffer, count);\n}\nEXPORT_SYMBOL_GPL(snd_ump_receive);\n\n \nint snd_ump_transmit(struct snd_ump_endpoint *ump, u32 *buffer, int count)\n{\n\tstruct snd_rawmidi_substream *substream =\n\t\tump->substreams[SNDRV_RAWMIDI_STREAM_OUTPUT];\n\tint err;\n\n\tif (!substream)\n\t\treturn -ENODEV;\n\terr = snd_rawmidi_transmit(substream, (char *)buffer, count);\n\t \n\tif (err)\n\t\treturn err;\n\treturn process_legacy_output(ump, buffer, count);\n}\nEXPORT_SYMBOL_GPL(snd_ump_transmit);\n\n \nint snd_ump_block_new(struct snd_ump_endpoint *ump, unsigned int blk,\n\t\t      unsigned int direction, unsigned int first_group,\n\t\t      unsigned int num_groups, struct snd_ump_block **blk_ret)\n{\n\tstruct snd_ump_block *fb, *p;\n\n\tif (blk < 0 || blk >= SNDRV_UMP_MAX_BLOCKS)\n\t\treturn -EINVAL;\n\n\tif (snd_ump_get_block(ump, blk))\n\t\treturn -EBUSY;\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (!fb)\n\t\treturn -ENOMEM;\n\n\tfb->ump = ump;\n\tfb->info.card = ump->info.card;\n\tfb->info.device = ump->info.device;\n\tfb->info.block_id = blk;\n\tif (blk >= ump->info.num_blocks)\n\t\tump->info.num_blocks = blk + 1;\n\tfb->info.direction = direction;\n\tfb->info.active = 1;\n\tfb->info.first_group = first_group;\n\tfb->info.num_groups = num_groups;\n\t \n\tsnprintf(fb->info.name, sizeof(fb->info.name), \"Group %d-%d\",\n\t\t first_group + 1, first_group + num_groups);\n\n\t \n\tlist_for_each_entry(p, &ump->block_list, list) {\n\t\tif (p->info.block_id > blk) {\n\t\t\tlist_add_tail(&fb->list, &p->list);\n\t\t\tgoto added;\n\t\t}\n\t}\n\tlist_add_tail(&fb->list, &ump->block_list);\n\n added:\n\tump_dbg(ump, \"Created a UMP Block #%d (%s)\\n\", blk, fb->info.name);\n\t*blk_ret = fb;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ump_block_new);\n\nstatic int snd_ump_ioctl_block(struct snd_ump_endpoint *ump,\n\t\t\t       struct snd_ump_block_info __user *argp)\n{\n\tstruct snd_ump_block *fb;\n\tunsigned char id;\n\n\tif (get_user(id, &argp->block_id))\n\t\treturn -EFAULT;\n\tfb = snd_ump_get_block(ump, id);\n\tif (!fb)\n\t\treturn -ENOENT;\n\tif (copy_to_user(argp, &fb->info, sizeof(fb->info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic long snd_ump_ioctl(struct snd_rawmidi *rmidi, unsigned int cmd,\n\t\t\t  void __user *argp)\n{\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(rmidi);\n\n\tswitch (cmd) {\n\tcase SNDRV_UMP_IOCTL_ENDPOINT_INFO:\n\t\tif (copy_to_user(argp, &ump->info, sizeof(ump->info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase SNDRV_UMP_IOCTL_BLOCK_INFO:\n\t\treturn snd_ump_ioctl_block(ump, argp);\n\tdefault:\n\t\tump_dbg(ump, \"rawmidi: unknown command = 0x%x\\n\", cmd);\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const char *ump_direction_string(int dir)\n{\n\tswitch (dir) {\n\tcase SNDRV_UMP_DIR_INPUT:\n\t\treturn \"input\";\n\tcase SNDRV_UMP_DIR_OUTPUT:\n\t\treturn \"output\";\n\tcase SNDRV_UMP_DIR_BIDIRECTION:\n\t\treturn \"bidirection\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *ump_ui_hint_string(int dir)\n{\n\tswitch (dir) {\n\tcase  SNDRV_UMP_BLOCK_UI_HINT_RECEIVER:\n\t\treturn \"receiver\";\n\tcase SNDRV_UMP_BLOCK_UI_HINT_SENDER:\n\t\treturn \"sender\";\n\tcase SNDRV_UMP_BLOCK_UI_HINT_BOTH:\n\t\treturn \"both\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic void snd_ump_proc_read(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_rawmidi *rmidi = entry->private_data;\n\tstruct snd_ump_endpoint *ump = rawmidi_to_ump(rmidi);\n\tstruct snd_ump_block *fb;\n\n\tsnd_iprintf(buffer, \"EP Name: %s\\n\", ump->info.name);\n\tsnd_iprintf(buffer, \"EP Product ID: %s\\n\", ump->info.product_id);\n\tsnd_iprintf(buffer, \"UMP Version: 0x%04x\\n\", ump->info.version);\n\tsnd_iprintf(buffer, \"Protocol Caps: 0x%08x\\n\", ump->info.protocol_caps);\n\tsnd_iprintf(buffer, \"Protocol: 0x%08x\\n\", ump->info.protocol);\n\tif (ump->info.version) {\n\t\tsnd_iprintf(buffer, \"Manufacturer ID: 0x%08x\\n\",\n\t\t\t    ump->info.manufacturer_id);\n\t\tsnd_iprintf(buffer, \"Family ID: 0x%04x\\n\", ump->info.family_id);\n\t\tsnd_iprintf(buffer, \"Model ID: 0x%04x\\n\", ump->info.model_id);\n\t\tsnd_iprintf(buffer, \"SW Revision: 0x%02x%02x%02x%02x\\n\",\n\t\t\t    ump->info.sw_revision[0],\n\t\t\t    ump->info.sw_revision[1],\n\t\t\t    ump->info.sw_revision[2],\n\t\t\t    ump->info.sw_revision[3]);\n\t}\n\tsnd_iprintf(buffer, \"Static Blocks: %s\\n\",\n\t\t    (ump->info.flags & SNDRV_UMP_EP_INFO_STATIC_BLOCKS) ? \"Yes\" : \"No\");\n\tsnd_iprintf(buffer, \"Num Blocks: %d\\n\\n\", ump->info.num_blocks);\n\n\tlist_for_each_entry(fb, &ump->block_list, list) {\n\t\tsnd_iprintf(buffer, \"Block %d (%s)\\n\", fb->info.block_id,\n\t\t\t    fb->info.name);\n\t\tsnd_iprintf(buffer, \"  Direction: %s\\n\",\n\t\t\t    ump_direction_string(fb->info.direction));\n\t\tsnd_iprintf(buffer, \"  Active: %s\\n\",\n\t\t\t    fb->info.active ? \"Yes\" : \"No\");\n\t\tsnd_iprintf(buffer, \"  Groups: %d-%d\\n\",\n\t\t\t    fb->info.first_group + 1,\n\t\t\t    fb->info.first_group + fb->info.num_groups);\n\t\tsnd_iprintf(buffer, \"  Is MIDI1: %s%s\\n\",\n\t\t\t    (fb->info.flags & SNDRV_UMP_BLOCK_IS_MIDI1) ? \"Yes\" : \"No\",\n\t\t\t    (fb->info.flags & SNDRV_UMP_BLOCK_IS_LOWSPEED) ? \" (Low Speed)\" : \"\");\n\t\tif (ump->info.version) {\n\t\t\tsnd_iprintf(buffer, \"  MIDI-CI Version: %d\\n\",\n\t\t\t\t    fb->info.midi_ci_version);\n\t\t\tsnd_iprintf(buffer, \"  Sysex8 Streams: %d\\n\",\n\t\t\t\t    fb->info.sysex8_streams);\n\t\t\tsnd_iprintf(buffer, \"  UI Hint: %s\\n\",\n\t\t\t\t    ump_ui_hint_string(fb->info.ui_hint));\n\t\t}\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n}\n\n \n\n \nstatic int ump_request_open(struct snd_ump_endpoint *ump)\n{\n\treturn snd_rawmidi_kernel_open(&ump->core, 0,\n\t\t\t\t       SNDRV_RAWMIDI_LFLG_OUTPUT,\n\t\t\t\t       &ump->stream_rfile);\n}\n\nstatic void ump_request_close(struct snd_ump_endpoint *ump)\n{\n\tsnd_rawmidi_kernel_release(&ump->stream_rfile);\n}\n\n \nstatic int ump_req_msg(struct snd_ump_endpoint *ump, u32 req1, u32 req2,\n\t\t       u32 reply)\n{\n\tu32 buf[4];\n\n\tump_dbg(ump, \"%s: request %08x %08x, wait-for %08x\\n\",\n\t\t__func__, req1, req2, reply);\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = req1;\n\tbuf[1] = req2;\n\tump->stream_finished = 0;\n\tump->stream_wait_for = reply;\n\tsnd_rawmidi_kernel_write(ump->stream_rfile.output,\n\t\t\t\t (unsigned char *)&buf, 16);\n\twait_event_timeout(ump->stream_wait, ump->stream_finished,\n\t\t\t   msecs_to_jiffies(500));\n\tif (!READ_ONCE(ump->stream_finished)) {\n\t\tump_dbg(ump, \"%s: request timed out\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\tump->stream_finished = 0;\n\tump_dbg(ump, \"%s: reply: %08x %08x %08x %08x\\n\",\n\t\t__func__, buf[0], buf[1], buf[2], buf[3]);\n\treturn 0;\n}\n\n \nstatic int ump_append_string(struct snd_ump_endpoint *ump, char *dest,\n\t\t\t     int maxsize, const u32 *buf, int offset)\n{\n\tunsigned char format;\n\tint c;\n\n\tformat = ump_stream_message_format(buf[0]);\n\tif (format == UMP_STREAM_MSG_FORMAT_SINGLE ||\n\t    format == UMP_STREAM_MSG_FORMAT_START) {\n\t\tc = 0;\n\t} else {\n\t\tc = strlen(dest);\n\t\tif (c >= maxsize - 1)\n\t\t\treturn 1;\n\t}\n\n\tfor (; offset < 16; offset++) {\n\t\tdest[c] = buf[offset / 4] >> (3 - (offset % 4)) * 8;\n\t\tif (!dest[c])\n\t\t\tbreak;\n\t\tif (++c >= maxsize - 1)\n\t\t\tbreak;\n\t}\n\tdest[c] = 0;\n\treturn (format == UMP_STREAM_MSG_FORMAT_SINGLE ||\n\t\tformat == UMP_STREAM_MSG_FORMAT_END);\n}\n\n \nstatic int ump_handle_ep_info_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const union snd_ump_stream_msg *buf)\n{\n\tump->info.version = (buf->ep_info.ump_version_major << 8) |\n\t\tbuf->ep_info.ump_version_minor;\n\tump->info.num_blocks = buf->ep_info.num_function_blocks;\n\tif (ump->info.num_blocks > SNDRV_UMP_MAX_BLOCKS) {\n\t\tump_info(ump, \"Invalid function blocks %d, fallback to 1\\n\",\n\t\t\t ump->info.num_blocks);\n\t\tump->info.num_blocks = 1;\n\t}\n\n\tif (buf->ep_info.static_function_block)\n\t\tump->info.flags |= SNDRV_UMP_EP_INFO_STATIC_BLOCKS;\n\n\tump->info.protocol_caps = (buf->ep_info.protocol << 8) |\n\t\tbuf->ep_info.jrts;\n\n\tump_dbg(ump, \"EP info: version=%x, num_blocks=%x, proto_caps=%x\\n\",\n\t\tump->info.version, ump->info.num_blocks, ump->info.protocol_caps);\n\treturn 1;  \n}\n\n \nstatic int ump_handle_device_info_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t      const union snd_ump_stream_msg *buf)\n{\n\tump->info.manufacturer_id = buf->device_info.manufacture_id & 0x7f7f7f;\n\tump->info.family_id = (buf->device_info.family_msb << 8) |\n\t\tbuf->device_info.family_lsb;\n\tump->info.model_id = (buf->device_info.model_msb << 8) |\n\t\tbuf->device_info.model_lsb;\n\tump->info.sw_revision[0] = (buf->device_info.sw_revision >> 24) & 0x7f;\n\tump->info.sw_revision[1] = (buf->device_info.sw_revision >> 16) & 0x7f;\n\tump->info.sw_revision[2] = (buf->device_info.sw_revision >> 8) & 0x7f;\n\tump->info.sw_revision[3] = buf->device_info.sw_revision & 0x7f;\n\tump_dbg(ump, \"EP devinfo: manid=%08x, family=%04x, model=%04x, sw=%02x%02x%02x%02x\\n\",\n\t\tump->info.manufacturer_id,\n\t\tump->info.family_id,\n\t\tump->info.model_id,\n\t\tump->info.sw_revision[0],\n\t\tump->info.sw_revision[1],\n\t\tump->info.sw_revision[2],\n\t\tump->info.sw_revision[3]);\n\treturn 1;  \n}\n\n \nstatic int ump_handle_ep_name_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const union snd_ump_stream_msg *buf)\n{\n\treturn ump_append_string(ump, ump->info.name, sizeof(ump->info.name),\n\t\t\t\t buf->raw, 2);\n}\n\n \nstatic int ump_handle_product_id_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t     const union snd_ump_stream_msg *buf)\n{\n\treturn ump_append_string(ump, ump->info.product_id,\n\t\t\t\t sizeof(ump->info.product_id),\n\t\t\t\t buf->raw, 2);\n}\n\n \nstatic void seq_notify_protocol(struct snd_ump_endpoint *ump)\n{\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tif (ump->seq_ops && ump->seq_ops->switch_protocol)\n\t\tump->seq_ops->switch_protocol(ump);\n#endif  \n}\n\n \nint snd_ump_switch_protocol(struct snd_ump_endpoint *ump, unsigned int protocol)\n{\n\tprotocol &= ump->info.protocol_caps;\n\tif (protocol == ump->info.protocol)\n\t\treturn 0;\n\n\tump->info.protocol = protocol;\n\tump_dbg(ump, \"New protocol = %x (caps = %x)\\n\",\n\t\tprotocol, ump->info.protocol_caps);\n\tseq_notify_protocol(ump);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(snd_ump_switch_protocol);\n\n \nstatic int ump_handle_stream_cfg_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t     const union snd_ump_stream_msg *buf)\n{\n\tunsigned int protocol =\n\t\t(buf->stream_cfg.protocol << 8) | buf->stream_cfg.jrts;\n\n\tsnd_ump_switch_protocol(ump, protocol);\n\treturn 1;  \n}\n\n \nstatic void fill_fb_info(struct snd_ump_endpoint *ump,\n\t\t\t struct snd_ump_block_info *info,\n\t\t\t const union snd_ump_stream_msg *buf)\n{\n\tinfo->direction = buf->fb_info.direction;\n\tinfo->ui_hint = buf->fb_info.ui_hint;\n\tinfo->first_group = buf->fb_info.first_group;\n\tinfo->num_groups = buf->fb_info.num_groups;\n\tinfo->flags = buf->fb_info.midi_10;\n\tinfo->active = buf->fb_info.active;\n\tinfo->midi_ci_version = buf->fb_info.midi_ci_version;\n\tinfo->sysex8_streams = buf->fb_info.sysex8_streams;\n\n\tump_dbg(ump, \"FB %d: dir=%d, active=%d, first_gp=%d, num_gp=%d, midici=%d, sysex8=%d, flags=0x%x\\n\",\n\t\tinfo->block_id, info->direction, info->active,\n\t\tinfo->first_group, info->num_groups, info->midi_ci_version,\n\t\tinfo->sysex8_streams, info->flags);\n}\n\n \nstatic bool is_fb_info_updated(struct snd_ump_endpoint *ump,\n\t\t\t       struct snd_ump_block *fb,\n\t\t\t       const union snd_ump_stream_msg *buf)\n{\n\tchar tmpbuf[offsetof(struct snd_ump_block_info, name)];\n\n\tif (ump->info.flags & SNDRV_UMP_EP_INFO_STATIC_BLOCKS) {\n\t\tump_info(ump, \"Skipping static FB info update (blk#%d)\\n\",\n\t\t\t fb->info.block_id);\n\t\treturn 0;\n\t}\n\n\tmemcpy(tmpbuf, &fb->info, sizeof(tmpbuf));\n\tfill_fb_info(ump, (struct snd_ump_block_info *)tmpbuf, buf);\n\treturn memcmp(&fb->info, tmpbuf, sizeof(tmpbuf)) != 0;\n}\n\n \nstatic void seq_notify_fb_change(struct snd_ump_endpoint *ump,\n\t\t\t\t struct snd_ump_block *fb)\n{\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tif (ump->seq_ops && ump->seq_ops->notify_fb_change)\n\t\tump->seq_ops->notify_fb_change(ump, fb);\n#endif\n}\n\n \nstatic int ump_handle_fb_info_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const union snd_ump_stream_msg *buf)\n{\n\tunsigned char blk;\n\tstruct snd_ump_block *fb;\n\n\tblk = buf->fb_info.function_block_id;\n\tfb = snd_ump_get_block(ump, blk);\n\n\t \n\tif (!fb && ump->parsed) {\n\t\tump_info(ump, \"Function Block Info Update for non-existing block %d\\n\",\n\t\t\t blk);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (ump->parsed && !is_fb_info_updated(ump, fb, buf))\n\t\treturn 1;  \n\n\tif (fb) {\n\t\tfill_fb_info(ump, &fb->info, buf);\n\t\tif (ump->parsed)\n\t\t\tseq_notify_fb_change(ump, fb);\n\t}\n\n\treturn 1;  \n}\n\n \nstatic int ump_handle_fb_name_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const union snd_ump_stream_msg *buf)\n{\n\tunsigned char blk;\n\tstruct snd_ump_block *fb;\n\tint ret;\n\n\tblk = buf->fb_name.function_block_id;\n\tfb = snd_ump_get_block(ump, blk);\n\tif (!fb)\n\t\treturn -ENODEV;\n\n\tret = ump_append_string(ump, fb->info.name, sizeof(fb->info.name),\n\t\t\t\tbuf->raw, 3);\n\t \n\tif (ret > 0 && ump->parsed)\n\t\tseq_notify_fb_change(ump, fb);\n\treturn ret;\n}\n\nstatic int create_block_from_fb_info(struct snd_ump_endpoint *ump, int blk)\n{\n\tstruct snd_ump_block *fb;\n\tunsigned char direction, first_group, num_groups;\n\tconst union snd_ump_stream_msg *buf =\n\t\t(const union snd_ump_stream_msg *)ump->input_buf;\n\tu32 msg;\n\tint err;\n\n\t \n\tmsg = ump_stream_compose(UMP_STREAM_MSG_STATUS_FB_DISCOVERY, 0) |\n\t\t(blk << 8) | UMP_STREAM_MSG_REQUEST_FB_INFO;\n\terr = ump_req_msg(ump, msg, 0, UMP_STREAM_MSG_STATUS_FB_INFO);\n\tif (err < 0) {\n\t\tump_dbg(ump, \"Unable to get FB info for block %d\\n\", blk);\n\t\treturn err;\n\t}\n\n\t \n\tif (buf->fb_info.status != UMP_STREAM_MSG_STATUS_FB_INFO) {\n\t\tump_dbg(ump, \"Inconsistent input: 0x%x\\n\", *buf->raw);\n\t\treturn -EINVAL;\n\t}\n\n\tdirection = buf->fb_info.direction;\n\tfirst_group = buf->fb_info.first_group;\n\tnum_groups = buf->fb_info.num_groups;\n\n\terr = snd_ump_block_new(ump, blk, direction, first_group, num_groups,\n\t\t\t\t&fb);\n\tif (err < 0)\n\t\treturn err;\n\n\tfill_fb_info(ump, &fb->info, buf);\n\n\tmsg = ump_stream_compose(UMP_STREAM_MSG_STATUS_FB_DISCOVERY, 0) |\n\t\t(blk << 8) | UMP_STREAM_MSG_REQUEST_FB_NAME;\n\terr = ump_req_msg(ump, msg, 0, UMP_STREAM_MSG_STATUS_FB_NAME);\n\tif (err)\n\t\tump_dbg(ump, \"Unable to get UMP FB name string #%d\\n\", blk);\n\n\treturn 0;\n}\n\n \nstatic void ump_handle_stream_msg(struct snd_ump_endpoint *ump,\n\t\t\t\t  const u32 *buf, int size)\n{\n\tconst union snd_ump_stream_msg *msg;\n\tunsigned int status;\n\tint ret;\n\n\t \n\tif (ump->no_process_stream)\n\t\treturn;\n\n\tBUILD_BUG_ON(sizeof(*msg) != 16);\n\tump_dbg(ump, \"Stream msg: %08x %08x %08x %08x\\n\",\n\t\tbuf[0], buf[1], buf[2], buf[3]);\n\n\tif (size != 4 || ump_message_type(*buf) != UMP_MSG_TYPE_STREAM)\n\t\treturn;\n\n\tmsg = (const union snd_ump_stream_msg *)buf;\n\tstatus = ump_stream_message_status(*buf);\n\tswitch (status) {\n\tcase UMP_STREAM_MSG_STATUS_EP_INFO:\n\t\tret = ump_handle_ep_info_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_DEVICE_INFO:\n\t\tret = ump_handle_device_info_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_EP_NAME:\n\t\tret = ump_handle_ep_name_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_PRODUCT_ID:\n\t\tret = ump_handle_product_id_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_STREAM_CFG:\n\t\tret = ump_handle_stream_cfg_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_FB_INFO:\n\t\tret = ump_handle_fb_info_msg(ump, msg);\n\t\tbreak;\n\tcase UMP_STREAM_MSG_STATUS_FB_NAME:\n\t\tret = ump_handle_fb_name_msg(ump, msg);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (ret > 0 && ump->stream_wait_for == status) {\n\t\tWRITE_ONCE(ump->stream_finished, 1);\n\t\twake_up(&ump->stream_wait);\n\t}\n}\n\n \nint snd_ump_parse_endpoint(struct snd_ump_endpoint *ump)\n{\n\tint blk, err;\n\tu32 msg;\n\n\tif (!(ump->core.info_flags & SNDRV_RAWMIDI_INFO_DUPLEX))\n\t\treturn -ENODEV;\n\n\terr = ump_request_open(ump);\n\tif (err < 0) {\n\t\tump_dbg(ump, \"Unable to open rawmidi device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmsg = ump_stream_compose(UMP_STREAM_MSG_STATUS_EP_DISCOVERY, 0) |\n\t\t0x0101;  \n\terr = ump_req_msg(ump, msg, UMP_STREAM_MSG_REQUEST_EP_INFO,\n\t\t\t  UMP_STREAM_MSG_STATUS_EP_INFO);\n\tif (err < 0) {\n\t\tump_dbg(ump, \"Unable to get UMP EP info\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\terr = ump_req_msg(ump, msg, UMP_STREAM_MSG_REQUEST_DEVICE_INFO,\n\t\t\t  UMP_STREAM_MSG_STATUS_DEVICE_INFO);\n\tif (err < 0)\n\t\tump_dbg(ump, \"Unable to get UMP EP device info\\n\");\n\n\t \n\terr = ump_req_msg(ump, msg, UMP_STREAM_MSG_REQUEST_EP_NAME,\n\t\t\t  UMP_STREAM_MSG_STATUS_EP_NAME);\n\tif (err < 0)\n\t\tump_dbg(ump, \"Unable to get UMP EP name string\\n\");\n\n\t \n\terr = ump_req_msg(ump, msg, UMP_STREAM_MSG_REQUEST_PRODUCT_ID,\n\t\t\t  UMP_STREAM_MSG_STATUS_PRODUCT_ID);\n\tif (err < 0)\n\t\tump_dbg(ump, \"Unable to get UMP EP product ID string\\n\");\n\n\t \n\terr = ump_req_msg(ump, msg, UMP_STREAM_MSG_REQUEST_STREAM_CFG,\n\t\t\t  UMP_STREAM_MSG_STATUS_STREAM_CFG);\n\tif (err < 0)\n\t\tump_dbg(ump, \"Unable to get UMP EP stream config\\n\");\n\n\t \n\tfor (blk = 0; blk < ump->info.num_blocks; blk++) {\n\t\terr = create_block_from_fb_info(ump, blk);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t}\n\n error:\n\tump->parsed = true;\n\tump_request_close(ump);\n\tif (err == -ETIMEDOUT)\n\t\terr = -ENODEV;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_ump_parse_endpoint);\n\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\n \nstatic int snd_ump_legacy_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = substream->rmidi->private_data;\n\tint dir = substream->stream;\n\tint group = ump->legacy_mapping[substream->number];\n\tint err;\n\n\tmutex_lock(&ump->open_mutex);\n\tif (ump->legacy_substreams[dir][group]) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (dir == SNDRV_RAWMIDI_STREAM_OUTPUT) {\n\t\tif (!ump->legacy_out_opens) {\n\t\t\terr = snd_rawmidi_kernel_open(&ump->core, 0,\n\t\t\t\t\t\t      SNDRV_RAWMIDI_LFLG_OUTPUT |\n\t\t\t\t\t\t      SNDRV_RAWMIDI_LFLG_APPEND,\n\t\t\t\t\t\t      &ump->legacy_out_rfile);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tump->legacy_out_opens++;\n\t\tsnd_ump_convert_reset(&ump->out_cvts[group]);\n\t}\n\tspin_lock_irq(&ump->legacy_locks[dir]);\n\tump->legacy_substreams[dir][group] = substream;\n\tspin_unlock_irq(&ump->legacy_locks[dir]);\n unlock:\n\tmutex_unlock(&ump->open_mutex);\n\treturn 0;\n}\n\nstatic int snd_ump_legacy_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = substream->rmidi->private_data;\n\tint dir = substream->stream;\n\tint group = ump->legacy_mapping[substream->number];\n\n\tmutex_lock(&ump->open_mutex);\n\tspin_lock_irq(&ump->legacy_locks[dir]);\n\tump->legacy_substreams[dir][group] = NULL;\n\tspin_unlock_irq(&ump->legacy_locks[dir]);\n\tif (dir == SNDRV_RAWMIDI_STREAM_OUTPUT) {\n\t\tif (!--ump->legacy_out_opens)\n\t\t\tsnd_rawmidi_kernel_release(&ump->legacy_out_rfile);\n\t}\n\tmutex_unlock(&ump->open_mutex);\n\treturn 0;\n}\n\nstatic void snd_ump_legacy_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t   int up)\n{\n\tstruct snd_ump_endpoint *ump = substream->rmidi->private_data;\n\tint dir = substream->stream;\n\n\tump->ops->trigger(ump, dir, up);\n}\n\nstatic void snd_ump_legacy_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_ump_endpoint *ump = substream->rmidi->private_data;\n\n\tif (ump->ops->drain)\n\t\tump->ops->drain(ump, SNDRV_RAWMIDI_STREAM_OUTPUT);\n}\n\nstatic int snd_ump_legacy_dev_register(struct snd_rawmidi *rmidi)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_ops snd_ump_legacy_input_ops = {\n\t.open = snd_ump_legacy_open,\n\t.close = snd_ump_legacy_close,\n\t.trigger = snd_ump_legacy_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_ump_legacy_output_ops = {\n\t.open = snd_ump_legacy_open,\n\t.close = snd_ump_legacy_close,\n\t.trigger = snd_ump_legacy_trigger,\n\t.drain = snd_ump_legacy_drain,\n};\n\nstatic const struct snd_rawmidi_global_ops snd_ump_legacy_ops = {\n\t.dev_register = snd_ump_legacy_dev_register,\n};\n\nstatic int process_legacy_output(struct snd_ump_endpoint *ump,\n\t\t\t\t u32 *buffer, int count)\n{\n\tstruct snd_rawmidi_substream *substream;\n\tstruct ump_cvt_to_ump *ctx;\n\tconst int dir = SNDRV_RAWMIDI_STREAM_OUTPUT;\n\tunsigned char c;\n\tint group, size = 0;\n\tunsigned long flags;\n\n\tif (!ump->out_cvts || !ump->legacy_out_opens)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ump->legacy_locks[dir], flags);\n\tfor (group = 0; group < SNDRV_UMP_MAX_GROUPS; group++) {\n\t\tsubstream = ump->legacy_substreams[dir][group];\n\t\tif (!substream)\n\t\t\tcontinue;\n\t\tctx = &ump->out_cvts[group];\n\t\twhile (!ctx->ump_bytes &&\n\t\t       snd_rawmidi_transmit(substream, &c, 1) > 0)\n\t\t\tsnd_ump_convert_to_ump(ctx, group, ump->info.protocol, c);\n\t\tif (ctx->ump_bytes && ctx->ump_bytes <= count) {\n\t\t\tsize = ctx->ump_bytes;\n\t\t\tmemcpy(buffer, ctx->ump, size);\n\t\t\tctx->ump_bytes = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ump->legacy_locks[dir], flags);\n\treturn size;\n}\n\nstatic void process_legacy_input(struct snd_ump_endpoint *ump, const u32 *src,\n\t\t\t\t int words)\n{\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned char buf[16];\n\tunsigned char group;\n\tunsigned long flags;\n\tconst int dir = SNDRV_RAWMIDI_STREAM_INPUT;\n\tint size;\n\n\tsize = snd_ump_convert_from_ump(src, buf, &group);\n\tif (size <= 0)\n\t\treturn;\n\tspin_lock_irqsave(&ump->legacy_locks[dir], flags);\n\tsubstream = ump->legacy_substreams[dir][group];\n\tif (substream)\n\t\tsnd_rawmidi_receive(substream, buf, size);\n\tspin_unlock_irqrestore(&ump->legacy_locks[dir], flags);\n}\n\n \nstatic int fill_legacy_mapping(struct snd_ump_endpoint *ump)\n{\n\tstruct snd_ump_block *fb;\n\tunsigned int group_maps = 0;\n\tint i, num;\n\n\tif (ump->info.flags & SNDRV_UMP_EP_INFO_STATIC_BLOCKS) {\n\t\tlist_for_each_entry(fb, &ump->block_list, list) {\n\t\t\tfor (i = 0; i < fb->info.num_groups; i++)\n\t\t\t\tgroup_maps |= 1U << (fb->info.first_group + i);\n\t\t}\n\t\tif (!group_maps)\n\t\t\tump_info(ump, \"No UMP Group is found in FB\\n\");\n\t}\n\n\t \n\tif (!group_maps)\n\t\tgroup_maps = (1U << SNDRV_UMP_MAX_GROUPS) - 1;\n\n\tnum = 0;\n\tfor (i = 0; i < SNDRV_UMP_MAX_GROUPS; i++)\n\t\tif (group_maps & (1U << i))\n\t\t\tump->legacy_mapping[num++] = i;\n\n\treturn num;\n}\n\nstatic void fill_substream_names(struct snd_ump_endpoint *ump,\n\t\t\t\t struct snd_rawmidi *rmidi, int dir)\n{\n\tstruct snd_rawmidi_substream *s;\n\n\tlist_for_each_entry(s, &rmidi->streams[dir].substreams, list)\n\t\tsnprintf(s->name, sizeof(s->name), \"Group %d (%.16s)\",\n\t\t\t ump->legacy_mapping[s->number] + 1, ump->info.name);\n}\n\nint snd_ump_attach_legacy_rawmidi(struct snd_ump_endpoint *ump,\n\t\t\t\t  char *id, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tbool input, output;\n\tint err, num;\n\n\tump->out_cvts = kcalloc(SNDRV_UMP_MAX_GROUPS,\n\t\t\t\tsizeof(*ump->out_cvts), GFP_KERNEL);\n\tif (!ump->out_cvts)\n\t\treturn -ENOMEM;\n\n\tnum = fill_legacy_mapping(ump);\n\n\tinput = ump->core.info_flags & SNDRV_RAWMIDI_INFO_INPUT;\n\toutput = ump->core.info_flags & SNDRV_RAWMIDI_INFO_OUTPUT;\n\terr = snd_rawmidi_new(ump->core.card, id, device,\n\t\t\t      output ? num : 0, input ? num : 0,\n\t\t\t      &rmidi);\n\tif (err < 0) {\n\t\tkfree(ump->out_cvts);\n\t\treturn err;\n\t}\n\n\tif (input)\n\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t    &snd_ump_legacy_input_ops);\n\tif (output)\n\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t    &snd_ump_legacy_output_ops);\n\tsnprintf(rmidi->name, sizeof(rmidi->name), \"%.68s (MIDI 1.0)\",\n\t\t ump->info.name);\n\trmidi->info_flags = ump->core.info_flags & ~SNDRV_RAWMIDI_INFO_UMP;\n\trmidi->ops = &snd_ump_legacy_ops;\n\trmidi->private_data = ump;\n\tump->legacy_rmidi = rmidi;\n\tif (input)\n\t\tfill_substream_names(ump, rmidi, SNDRV_RAWMIDI_STREAM_INPUT);\n\tif (output)\n\t\tfill_substream_names(ump, rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT);\n\n\tump_dbg(ump, \"Created a legacy rawmidi #%d (%s)\\n\", device, id);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ump_attach_legacy_rawmidi);\n#endif  \n\nMODULE_DESCRIPTION(\"Universal MIDI Packet (UMP) Core Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}