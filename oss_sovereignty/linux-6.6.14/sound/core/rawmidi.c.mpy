{
  "module_name": "rawmidi.c",
  "hash_id": "ec9e4f1ffa901a307c16f272cfd3588fbd0cbc04423ed655d1f2e7eb1b2d29ce",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/rawmidi.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <linux/major.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/nospec.h>\n#include <sound/rawmidi.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/minors.h>\n#include <sound/initval.h>\n#include <sound/ump.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Midlevel RawMidi code for ALSA.\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_SND_OSSEMUL\nstatic int midi_map[SNDRV_CARDS];\nstatic int amidi_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};\nmodule_param_array(midi_map, int, NULL, 0444);\nMODULE_PARM_DESC(midi_map, \"Raw MIDI device number assigned to 1st OSS device.\");\nmodule_param_array(amidi_map, int, NULL, 0444);\nMODULE_PARM_DESC(amidi_map, \"Raw MIDI device number assigned to 2nd OSS device.\");\n#endif  \n\nstatic int snd_rawmidi_dev_free(struct snd_device *device);\nstatic int snd_rawmidi_dev_register(struct snd_device *device);\nstatic int snd_rawmidi_dev_disconnect(struct snd_device *device);\n\nstatic LIST_HEAD(snd_rawmidi_devices);\nstatic DEFINE_MUTEX(register_mutex);\n\n#define rmidi_err(rmidi, fmt, args...) \\\n\tdev_err((rmidi)->dev, fmt, ##args)\n#define rmidi_warn(rmidi, fmt, args...) \\\n\tdev_warn((rmidi)->dev, fmt, ##args)\n#define rmidi_dbg(rmidi, fmt, args...) \\\n\tdev_dbg((rmidi)->dev, fmt, ##args)\n\nstruct snd_rawmidi_status32 {\n\ts32 stream;\n\ts32 tstamp_sec;\t\t\t \n\ts32 tstamp_nsec;\n\tu32 avail;\t\t\t \n\tu32 xruns;\t\t\t \n\tunsigned char reserved[16];\t \n};\n\n#define SNDRV_RAWMIDI_IOCTL_STATUS32\t_IOWR('W', 0x20, struct snd_rawmidi_status32)\n\nstruct snd_rawmidi_status64 {\n\tint stream;\n\tu8 rsvd[4];\t\t\t \n\ts64 tstamp_sec;\t\t\t \n\ts64 tstamp_nsec;\n\tsize_t avail;\t\t\t \n\tsize_t xruns;\t\t\t \n\tunsigned char reserved[16];\t \n};\n\n#define SNDRV_RAWMIDI_IOCTL_STATUS64\t_IOWR('W', 0x20, struct snd_rawmidi_status64)\n\n#define rawmidi_is_ump(rmidi) \\\n\t(IS_ENABLED(CONFIG_SND_UMP) && ((rmidi)->info_flags & SNDRV_RAWMIDI_INFO_UMP))\n\nstatic struct snd_rawmidi *snd_rawmidi_search(struct snd_card *card, int device)\n{\n\tstruct snd_rawmidi *rawmidi;\n\n\tlist_for_each_entry(rawmidi, &snd_rawmidi_devices, list)\n\t\tif (rawmidi->card == card && rawmidi->device == device)\n\t\t\treturn rawmidi;\n\treturn NULL;\n}\n\nstatic inline unsigned short snd_rawmidi_file_flags(struct file *file)\n{\n\tswitch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_WRITE:\n\t\treturn SNDRV_RAWMIDI_LFLG_OUTPUT;\n\tcase FMODE_READ:\n\t\treturn SNDRV_RAWMIDI_LFLG_INPUT;\n\tdefault:\n\t\treturn SNDRV_RAWMIDI_LFLG_OPEN;\n\t}\n}\n\nstatic inline bool __snd_rawmidi_ready(struct snd_rawmidi_runtime *runtime)\n{\n\treturn runtime->avail >= runtime->avail_min;\n}\n\nstatic bool snd_rawmidi_ready(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tbool ready;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tready = __snd_rawmidi_ready(substream->runtime);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn ready;\n}\n\nstatic inline int snd_rawmidi_ready_append(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t   size_t count)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\treturn runtime->avail >= runtime->avail_min &&\n\t       (!substream->append || runtime->avail >= count);\n}\n\nstatic void snd_rawmidi_input_event_work(struct work_struct *work)\n{\n\tstruct snd_rawmidi_runtime *runtime =\n\t\tcontainer_of(work, struct snd_rawmidi_runtime, event_work);\n\n\tif (runtime->event)\n\t\truntime->event(runtime->substream);\n}\n\n \nstatic inline void snd_rawmidi_buffer_ref(struct snd_rawmidi_runtime *runtime)\n{\n\truntime->buffer_ref++;\n}\n\nstatic inline void snd_rawmidi_buffer_unref(struct snd_rawmidi_runtime *runtime)\n{\n\truntime->buffer_ref--;\n}\n\nstatic void snd_rawmidi_buffer_ref_sync(struct snd_rawmidi_substream *substream)\n{\n\tint loop = HZ;\n\n\tspin_lock_irq(&substream->lock);\n\twhile (substream->runtime->buffer_ref) {\n\t\tspin_unlock_irq(&substream->lock);\n\t\tif (!--loop) {\n\t\t\trmidi_err(substream->rmidi, \"Buffer ref sync timeout\\n\");\n\t\t\treturn;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock_irq(&substream->lock);\n\t}\n\tspin_unlock_irq(&substream->lock);\n}\n\nstatic int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_rawmidi_runtime *runtime;\n\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (!runtime)\n\t\treturn -ENOMEM;\n\truntime->substream = substream;\n\tinit_waitqueue_head(&runtime->sleep);\n\tINIT_WORK(&runtime->event_work, snd_rawmidi_input_event_work);\n\truntime->event = NULL;\n\truntime->buffer_size = PAGE_SIZE;\n\truntime->avail_min = 1;\n\tif (substream->stream == SNDRV_RAWMIDI_STREAM_INPUT)\n\t\truntime->avail = 0;\n\telse\n\t\truntime->avail = runtime->buffer_size;\n\truntime->buffer = kvzalloc(runtime->buffer_size, GFP_KERNEL);\n\tif (!runtime->buffer) {\n\t\tkfree(runtime);\n\t\treturn -ENOMEM;\n\t}\n\truntime->appl_ptr = runtime->hw_ptr = 0;\n\tsubstream->runtime = runtime;\n\tif (rawmidi_is_ump(substream->rmidi))\n\t\truntime->align = 3;\n\treturn 0;\n}\n\n \nstatic inline int get_align(struct snd_rawmidi_runtime *runtime)\n{\n\tif (IS_ENABLED(CONFIG_SND_UMP))\n\t\treturn runtime->align;\n\telse\n\t\treturn 0;\n}\n\n \n#define get_aligned_size(runtime, size) ((size) & ~get_align(runtime))\n\nstatic int snd_rawmidi_runtime_free(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tkvfree(runtime->buffer);\n\tkfree(runtime);\n\tsubstream->runtime = NULL;\n\treturn 0;\n}\n\nstatic inline void snd_rawmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tif (!substream->opened)\n\t\treturn;\n\tsubstream->ops->trigger(substream, up);\n}\n\nstatic void snd_rawmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tif (!substream->opened)\n\t\treturn;\n\tsubstream->ops->trigger(substream, up);\n\tif (!up)\n\t\tcancel_work_sync(&substream->runtime->event_work);\n}\n\nstatic void __reset_runtime_ptrs(struct snd_rawmidi_runtime *runtime,\n\t\t\t\t bool is_input)\n{\n\truntime->drain = 0;\n\truntime->appl_ptr = runtime->hw_ptr = 0;\n\truntime->avail = is_input ? 0 : runtime->buffer_size;\n}\n\nstatic void reset_runtime_ptrs(struct snd_rawmidi_substream *substream,\n\t\t\t       bool is_input)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (substream->opened && substream->runtime)\n\t\t__reset_runtime_ptrs(substream->runtime, is_input);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n}\n\nint snd_rawmidi_drop_output(struct snd_rawmidi_substream *substream)\n{\n\tsnd_rawmidi_output_trigger(substream, 0);\n\treset_runtime_ptrs(substream, false);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_rawmidi_drop_output);\n\nint snd_rawmidi_drain_output(struct snd_rawmidi_substream *substream)\n{\n\tint err = 0;\n\tlong timeout;\n\tstruct snd_rawmidi_runtime *runtime;\n\n\tspin_lock_irq(&substream->lock);\n\truntime = substream->runtime;\n\tif (!substream->opened || !runtime || !runtime->buffer) {\n\t\terr = -EINVAL;\n\t} else {\n\t\tsnd_rawmidi_buffer_ref(runtime);\n\t\truntime->drain = 1;\n\t}\n\tspin_unlock_irq(&substream->lock);\n\tif (err < 0)\n\t\treturn err;\n\n\ttimeout = wait_event_interruptible_timeout(runtime->sleep,\n\t\t\t\t(runtime->avail >= runtime->buffer_size),\n\t\t\t\t10*HZ);\n\n\tspin_lock_irq(&substream->lock);\n\tif (signal_pending(current))\n\t\terr = -ERESTARTSYS;\n\tif (runtime->avail < runtime->buffer_size && !timeout) {\n\t\trmidi_warn(substream->rmidi,\n\t\t\t   \"rawmidi drain error (avail = %li, buffer_size = %li)\\n\",\n\t\t\t   (long)runtime->avail, (long)runtime->buffer_size);\n\t\terr = -EIO;\n\t}\n\truntime->drain = 0;\n\tspin_unlock_irq(&substream->lock);\n\n\tif (err != -ERESTARTSYS) {\n\t\t \n\t\tif (substream->ops->drain)\n\t\t\tsubstream->ops->drain(substream);\n\t\telse\n\t\t\tmsleep(50);\n\t\tsnd_rawmidi_drop_output(substream);\n\t}\n\n\tspin_lock_irq(&substream->lock);\n\tsnd_rawmidi_buffer_unref(runtime);\n\tspin_unlock_irq(&substream->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_rawmidi_drain_output);\n\nint snd_rawmidi_drain_input(struct snd_rawmidi_substream *substream)\n{\n\tsnd_rawmidi_input_trigger(substream, 0);\n\treset_runtime_ptrs(substream, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_rawmidi_drain_input);\n\n \nstatic int assign_substream(struct snd_rawmidi *rmidi, int subdevice,\n\t\t\t    int stream, int mode,\n\t\t\t    struct snd_rawmidi_substream **sub_ret)\n{\n\tstruct snd_rawmidi_substream *substream;\n\tstruct snd_rawmidi_str *s = &rmidi->streams[stream];\n\tstatic const unsigned int info_flags[2] = {\n\t\t[SNDRV_RAWMIDI_STREAM_OUTPUT] = SNDRV_RAWMIDI_INFO_OUTPUT,\n\t\t[SNDRV_RAWMIDI_STREAM_INPUT] = SNDRV_RAWMIDI_INFO_INPUT,\n\t};\n\n\tif (!(rmidi->info_flags & info_flags[stream]))\n\t\treturn -ENXIO;\n\tif (subdevice >= 0 && subdevice >= s->substream_count)\n\t\treturn -ENODEV;\n\n\tlist_for_each_entry(substream, &s->substreams, list) {\n\t\tif (substream->opened) {\n\t\t\tif (stream == SNDRV_RAWMIDI_STREAM_INPUT ||\n\t\t\t    !(mode & SNDRV_RAWMIDI_LFLG_APPEND) ||\n\t\t\t    !substream->append)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (subdevice < 0 || subdevice == substream->number) {\n\t\t\t*sub_ret = substream;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EAGAIN;\n}\n\n \nstatic int open_substream(struct snd_rawmidi *rmidi,\n\t\t\t  struct snd_rawmidi_substream *substream,\n\t\t\t  int mode)\n{\n\tint err;\n\n\tif (substream->use_count == 0) {\n\t\terr = snd_rawmidi_runtime_create(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = substream->ops->open(substream);\n\t\tif (err < 0) {\n\t\t\tsnd_rawmidi_runtime_free(substream);\n\t\t\treturn err;\n\t\t}\n\t\tspin_lock_irq(&substream->lock);\n\t\tsubstream->opened = 1;\n\t\tsubstream->active_sensing = 0;\n\t\tif (mode & SNDRV_RAWMIDI_LFLG_APPEND)\n\t\t\tsubstream->append = 1;\n\t\tsubstream->pid = get_pid(task_pid(current));\n\t\trmidi->streams[substream->stream].substream_opened++;\n\t\tspin_unlock_irq(&substream->lock);\n\t}\n\tsubstream->use_count++;\n\treturn 0;\n}\n\nstatic void close_substream(struct snd_rawmidi *rmidi,\n\t\t\t    struct snd_rawmidi_substream *substream,\n\t\t\t    int cleanup);\n\nstatic int rawmidi_open_priv(struct snd_rawmidi *rmidi, int subdevice, int mode,\n\t\t\t     struct snd_rawmidi_file *rfile)\n{\n\tstruct snd_rawmidi_substream *sinput = NULL, *soutput = NULL;\n\tint err;\n\n\trfile->input = rfile->output = NULL;\n\tif (mode & SNDRV_RAWMIDI_LFLG_INPUT) {\n\t\terr = assign_substream(rmidi, subdevice,\n\t\t\t\t       SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t       mode, &sinput);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (mode & SNDRV_RAWMIDI_LFLG_OUTPUT) {\n\t\terr = assign_substream(rmidi, subdevice,\n\t\t\t\t       SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t       mode, &soutput);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (sinput) {\n\t\terr = open_substream(rmidi, sinput, mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (soutput) {\n\t\terr = open_substream(rmidi, soutput, mode);\n\t\tif (err < 0) {\n\t\t\tif (sinput)\n\t\t\t\tclose_substream(rmidi, sinput, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\trfile->rmidi = rmidi;\n\trfile->input = sinput;\n\trfile->output = soutput;\n\treturn 0;\n}\n\n \nint snd_rawmidi_kernel_open(struct snd_rawmidi *rmidi, int subdevice,\n\t\t\t    int mode, struct snd_rawmidi_file *rfile)\n{\n\tint err;\n\n\tif (snd_BUG_ON(!rfile))\n\t\treturn -EINVAL;\n\tif (!try_module_get(rmidi->card->module))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&rmidi->open_mutex);\n\terr = rawmidi_open_priv(rmidi, subdevice, mode, rfile);\n\tmutex_unlock(&rmidi->open_mutex);\n\tif (err < 0)\n\t\tmodule_put(rmidi->card->module);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_rawmidi_kernel_open);\n\nstatic int snd_rawmidi_open(struct inode *inode, struct file *file)\n{\n\tint maj = imajor(inode);\n\tstruct snd_card *card;\n\tint subdevice;\n\tunsigned short fflags;\n\tint err;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_file *rawmidi_file = NULL;\n\twait_queue_entry_t wait;\n\n\tif ((file->f_flags & O_APPEND) && !(file->f_flags & O_NONBLOCK))\n\t\treturn -EINVAL;\t\t \n\n\terr = stream_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (maj == snd_major) {\n\t\trmidi = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t\t      SNDRV_DEVICE_TYPE_RAWMIDI);\n#ifdef CONFIG_SND_OSSEMUL\n\t} else if (maj == SOUND_MAJOR) {\n\t\trmidi = snd_lookup_oss_minor_data(iminor(inode),\n\t\t\t\t\t\t  SNDRV_OSS_DEVICE_TYPE_MIDI);\n#endif\n\t} else\n\t\treturn -ENXIO;\n\n\tif (rmidi == NULL)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(rmidi->card->module)) {\n\t\tsnd_card_unref(rmidi->card);\n\t\treturn -ENXIO;\n\t}\n\n\tmutex_lock(&rmidi->open_mutex);\n\tcard = rmidi->card;\n\terr = snd_card_file_add(card, file);\n\tif (err < 0)\n\t\tgoto __error_card;\n\tfflags = snd_rawmidi_file_flags(file);\n\tif ((file->f_flags & O_APPEND) || maj == SOUND_MAJOR)  \n\t\tfflags |= SNDRV_RAWMIDI_LFLG_APPEND;\n\trawmidi_file = kmalloc(sizeof(*rawmidi_file), GFP_KERNEL);\n\tif (rawmidi_file == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\trawmidi_file->user_pversion = 0;\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&rmidi->open_wait, &wait);\n\twhile (1) {\n\t\tsubdevice = snd_ctl_get_preferred_subdevice(card, SND_CTL_SUBDEV_RAWMIDI);\n\t\terr = rawmidi_open_priv(rmidi, subdevice, fflags, rawmidi_file);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t\tif (err == -EAGAIN) {\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tmutex_unlock(&rmidi->open_mutex);\n\t\tschedule();\n\t\tmutex_lock(&rmidi->open_mutex);\n\t\tif (rmidi->card->shutdown) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_wait_queue(&rmidi->open_wait, &wait);\n\tif (err < 0) {\n\t\tkfree(rawmidi_file);\n\t\tgoto __error;\n\t}\n#ifdef CONFIG_SND_OSSEMUL\n\tif (rawmidi_file->input && rawmidi_file->input->runtime)\n\t\trawmidi_file->input->runtime->oss = (maj == SOUND_MAJOR);\n\tif (rawmidi_file->output && rawmidi_file->output->runtime)\n\t\trawmidi_file->output->runtime->oss = (maj == SOUND_MAJOR);\n#endif\n\tfile->private_data = rawmidi_file;\n\tmutex_unlock(&rmidi->open_mutex);\n\tsnd_card_unref(rmidi->card);\n\treturn 0;\n\n __error:\n\tsnd_card_file_remove(card, file);\n __error_card:\n\tmutex_unlock(&rmidi->open_mutex);\n\tmodule_put(rmidi->card->module);\n\tsnd_card_unref(rmidi->card);\n\treturn err;\n}\n\nstatic void close_substream(struct snd_rawmidi *rmidi,\n\t\t\t    struct snd_rawmidi_substream *substream,\n\t\t\t    int cleanup)\n{\n\tif (--substream->use_count)\n\t\treturn;\n\n\tif (cleanup) {\n\t\tif (substream->stream == SNDRV_RAWMIDI_STREAM_INPUT)\n\t\t\tsnd_rawmidi_input_trigger(substream, 0);\n\t\telse {\n\t\t\tif (substream->active_sensing) {\n\t\t\t\tunsigned char buf = 0xfe;\n\t\t\t\t \n\t\t\t\tsnd_rawmidi_kernel_write(substream, &buf, 1);\n\t\t\t}\n\t\t\tif (snd_rawmidi_drain_output(substream) == -ERESTARTSYS)\n\t\t\t\tsnd_rawmidi_output_trigger(substream, 0);\n\t\t}\n\t\tsnd_rawmidi_buffer_ref_sync(substream);\n\t}\n\tspin_lock_irq(&substream->lock);\n\tsubstream->opened = 0;\n\tsubstream->append = 0;\n\tspin_unlock_irq(&substream->lock);\n\tsubstream->ops->close(substream);\n\tif (substream->runtime->private_free)\n\t\tsubstream->runtime->private_free(substream);\n\tsnd_rawmidi_runtime_free(substream);\n\tput_pid(substream->pid);\n\tsubstream->pid = NULL;\n\trmidi->streams[substream->stream].substream_opened--;\n}\n\nstatic void rawmidi_release_priv(struct snd_rawmidi_file *rfile)\n{\n\tstruct snd_rawmidi *rmidi;\n\n\trmidi = rfile->rmidi;\n\tmutex_lock(&rmidi->open_mutex);\n\tif (rfile->input) {\n\t\tclose_substream(rmidi, rfile->input, 1);\n\t\trfile->input = NULL;\n\t}\n\tif (rfile->output) {\n\t\tclose_substream(rmidi, rfile->output, 1);\n\t\trfile->output = NULL;\n\t}\n\trfile->rmidi = NULL;\n\tmutex_unlock(&rmidi->open_mutex);\n\twake_up(&rmidi->open_wait);\n}\n\n \nint snd_rawmidi_kernel_release(struct snd_rawmidi_file *rfile)\n{\n\tstruct snd_rawmidi *rmidi;\n\n\tif (snd_BUG_ON(!rfile))\n\t\treturn -ENXIO;\n\n\trmidi = rfile->rmidi;\n\trawmidi_release_priv(rfile);\n\tmodule_put(rmidi->card->module);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_rawmidi_kernel_release);\n\nstatic int snd_rawmidi_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_rawmidi_file *rfile;\n\tstruct snd_rawmidi *rmidi;\n\tstruct module *module;\n\n\trfile = file->private_data;\n\trmidi = rfile->rmidi;\n\trawmidi_release_priv(rfile);\n\tkfree(rfile);\n\tmodule = rmidi->card->module;\n\tsnd_card_file_remove(rmidi->card, file);\n\tmodule_put(module);\n\treturn 0;\n}\n\nstatic int snd_rawmidi_info(struct snd_rawmidi_substream *substream,\n\t\t\t    struct snd_rawmidi_info *info)\n{\n\tstruct snd_rawmidi *rmidi;\n\n\tif (substream == NULL)\n\t\treturn -ENODEV;\n\trmidi = substream->rmidi;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->card = rmidi->card->number;\n\tinfo->device = rmidi->device;\n\tinfo->subdevice = substream->number;\n\tinfo->stream = substream->stream;\n\tinfo->flags = rmidi->info_flags;\n\tstrcpy(info->id, rmidi->id);\n\tstrcpy(info->name, rmidi->name);\n\tstrcpy(info->subname, substream->name);\n\tinfo->subdevices_count = substream->pstr->substream_count;\n\tinfo->subdevices_avail = (substream->pstr->substream_count -\n\t\t\t\t  substream->pstr->substream_opened);\n\treturn 0;\n}\n\nstatic int snd_rawmidi_info_user(struct snd_rawmidi_substream *substream,\n\t\t\t\t struct snd_rawmidi_info __user *_info)\n{\n\tstruct snd_rawmidi_info info;\n\tint err;\n\n\terr = snd_rawmidi_info(substream, &info);\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(_info, &info, sizeof(struct snd_rawmidi_info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int __snd_rawmidi_info_select(struct snd_card *card,\n\t\t\t\t     struct snd_rawmidi_info *info)\n{\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_str *pstr;\n\tstruct snd_rawmidi_substream *substream;\n\n\trmidi = snd_rawmidi_search(card, info->device);\n\tif (!rmidi)\n\t\treturn -ENXIO;\n\tif (info->stream < 0 || info->stream > 1)\n\t\treturn -EINVAL;\n\tinfo->stream = array_index_nospec(info->stream, 2);\n\tpstr = &rmidi->streams[info->stream];\n\tif (pstr->substream_count == 0)\n\t\treturn -ENOENT;\n\tif (info->subdevice >= pstr->substream_count)\n\t\treturn -ENXIO;\n\tlist_for_each_entry(substream, &pstr->substreams, list) {\n\t\tif ((unsigned int)substream->number == info->subdevice)\n\t\t\treturn snd_rawmidi_info(substream, info);\n\t}\n\treturn -ENXIO;\n}\n\nint snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)\n{\n\tint ret;\n\n\tmutex_lock(&register_mutex);\n\tret = __snd_rawmidi_info_select(card, info);\n\tmutex_unlock(&register_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_rawmidi_info_select);\n\nstatic int snd_rawmidi_info_select_user(struct snd_card *card,\n\t\t\t\t\tstruct snd_rawmidi_info __user *_info)\n{\n\tint err;\n\tstruct snd_rawmidi_info info;\n\n\tif (get_user(info.device, &_info->device))\n\t\treturn -EFAULT;\n\tif (get_user(info.stream, &_info->stream))\n\t\treturn -EFAULT;\n\tif (get_user(info.subdevice, &_info->subdevice))\n\t\treturn -EFAULT;\n\terr = snd_rawmidi_info_select(card, &info);\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(_info, &info, sizeof(struct snd_rawmidi_info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int resize_runtime_buffer(struct snd_rawmidi_substream *substream,\n\t\t\t\t struct snd_rawmidi_params *params,\n\t\t\t\t bool is_input)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tchar *newbuf, *oldbuf;\n\tunsigned int framing = params->mode & SNDRV_RAWMIDI_MODE_FRAMING_MASK;\n\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L)\n\t\treturn -EINVAL;\n\tif (framing == SNDRV_RAWMIDI_MODE_FRAMING_TSTAMP && (params->buffer_size & 0x1f) != 0)\n\t\treturn -EINVAL;\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size)\n\t\treturn -EINVAL;\n\tif (params->buffer_size & get_align(runtime))\n\t\treturn -EINVAL;\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = kvzalloc(params->buffer_size, GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(&substream->lock);\n\t\tif (runtime->buffer_ref) {\n\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\tkvfree(newbuf);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\toldbuf = runtime->buffer;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t\t__reset_runtime_ptrs(runtime, is_input);\n\t\tspin_unlock_irq(&substream->lock);\n\t\tkvfree(oldbuf);\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}\n\nint snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params *params)\n{\n\tint err;\n\n\tsnd_rawmidi_drain_output(substream);\n\tmutex_lock(&substream->rmidi->open_mutex);\n\tif (substream->append && substream->use_count > 1)\n\t\terr = -EBUSY;\n\telse\n\t\terr = resize_runtime_buffer(substream, params, false);\n\n\tif (!err)\n\t\tsubstream->active_sensing = !params->no_active_sensing;\n\tmutex_unlock(&substream->rmidi->open_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_rawmidi_output_params);\n\nint snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params *params)\n{\n\tunsigned int framing = params->mode & SNDRV_RAWMIDI_MODE_FRAMING_MASK;\n\tunsigned int clock_type = params->mode & SNDRV_RAWMIDI_MODE_CLOCK_MASK;\n\tint err;\n\n\tsnd_rawmidi_drain_input(substream);\n\tmutex_lock(&substream->rmidi->open_mutex);\n\tif (framing == SNDRV_RAWMIDI_MODE_FRAMING_NONE && clock_type != SNDRV_RAWMIDI_MODE_CLOCK_NONE)\n\t\terr = -EINVAL;\n\telse if (clock_type > SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC_RAW)\n\t\terr = -EINVAL;\n\telse if (framing > SNDRV_RAWMIDI_MODE_FRAMING_TSTAMP)\n\t\terr = -EINVAL;\n\telse\n\t\terr = resize_runtime_buffer(substream, params, true);\n\n\tif (!err) {\n\t\tsubstream->framing = framing;\n\t\tsubstream->clock_type = clock_type;\n\t}\n\tmutex_unlock(&substream->rmidi->open_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_rawmidi_input_params);\n\nstatic int snd_rawmidi_output_status(struct snd_rawmidi_substream *substream,\n\t\t\t\t     struct snd_rawmidi_status64 *status)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tmemset(status, 0, sizeof(*status));\n\tstatus->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\n\tspin_lock_irq(&substream->lock);\n\tstatus->avail = runtime->avail;\n\tspin_unlock_irq(&substream->lock);\n\treturn 0;\n}\n\nstatic int snd_rawmidi_input_status(struct snd_rawmidi_substream *substream,\n\t\t\t\t    struct snd_rawmidi_status64 *status)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tmemset(status, 0, sizeof(*status));\n\tstatus->stream = SNDRV_RAWMIDI_STREAM_INPUT;\n\tspin_lock_irq(&substream->lock);\n\tstatus->avail = runtime->avail;\n\tstatus->xruns = runtime->xruns;\n\truntime->xruns = 0;\n\tspin_unlock_irq(&substream->lock);\n\treturn 0;\n}\n\nstatic int snd_rawmidi_ioctl_status32(struct snd_rawmidi_file *rfile,\n\t\t\t\t      struct snd_rawmidi_status32 __user *argp)\n{\n\tint err = 0;\n\tstruct snd_rawmidi_status32 __user *status = argp;\n\tstruct snd_rawmidi_status32 status32;\n\tstruct snd_rawmidi_status64 status64;\n\n\tif (copy_from_user(&status32, argp,\n\t\t\t   sizeof(struct snd_rawmidi_status32)))\n\t\treturn -EFAULT;\n\n\tswitch (status32.stream) {\n\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\tif (rfile->output == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = snd_rawmidi_output_status(rfile->output, &status64);\n\t\tbreak;\n\tcase SNDRV_RAWMIDI_STREAM_INPUT:\n\t\tif (rfile->input == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = snd_rawmidi_input_status(rfile->input, &status64);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tstatus32 = (struct snd_rawmidi_status32) {\n\t\t.stream = status64.stream,\n\t\t.tstamp_sec = status64.tstamp_sec,\n\t\t.tstamp_nsec = status64.tstamp_nsec,\n\t\t.avail = status64.avail,\n\t\t.xruns = status64.xruns,\n\t};\n\n\tif (copy_to_user(status, &status32, sizeof(*status)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int snd_rawmidi_ioctl_status64(struct snd_rawmidi_file *rfile,\n\t\t\t\t      struct snd_rawmidi_status64 __user *argp)\n{\n\tint err = 0;\n\tstruct snd_rawmidi_status64 status;\n\n\tif (copy_from_user(&status, argp, sizeof(struct snd_rawmidi_status64)))\n\t\treturn -EFAULT;\n\n\tswitch (status.stream) {\n\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\tif (rfile->output == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = snd_rawmidi_output_status(rfile->output, &status);\n\t\tbreak;\n\tcase SNDRV_RAWMIDI_STREAM_INPUT:\n\t\tif (rfile->input == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = snd_rawmidi_input_status(rfile->input, &status);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\tif (copy_to_user(argp, &status,\n\t\t\t sizeof(struct snd_rawmidi_status64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long snd_rawmidi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_rawmidi_file *rfile;\n\tstruct snd_rawmidi *rmidi;\n\tvoid __user *argp = (void __user *)arg;\n\n\trfile = file->private_data;\n\tif (((cmd >> 8) & 0xff) != 'W')\n\t\treturn -ENOTTY;\n\tswitch (cmd) {\n\tcase SNDRV_RAWMIDI_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_RAWMIDI_VERSION, (int __user *)argp) ? -EFAULT : 0;\n\tcase SNDRV_RAWMIDI_IOCTL_INFO:\n\t{\n\t\tint stream;\n\t\tstruct snd_rawmidi_info __user *info = argp;\n\n\t\tif (get_user(stream, &info->stream))\n\t\t\treturn -EFAULT;\n\t\tswitch (stream) {\n\t\tcase SNDRV_RAWMIDI_STREAM_INPUT:\n\t\t\treturn snd_rawmidi_info_user(rfile->input, info);\n\t\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\t\treturn snd_rawmidi_info_user(rfile->output, info);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase SNDRV_RAWMIDI_IOCTL_USER_PVERSION:\n\t\tif (get_user(rfile->user_pversion, (unsigned int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SNDRV_RAWMIDI_IOCTL_PARAMS:\n\t{\n\t\tstruct snd_rawmidi_params params;\n\n\t\tif (copy_from_user(&params, argp, sizeof(struct snd_rawmidi_params)))\n\t\t\treturn -EFAULT;\n\t\tif (rfile->user_pversion < SNDRV_PROTOCOL_VERSION(2, 0, 2)) {\n\t\t\tparams.mode = 0;\n\t\t\tmemset(params.reserved, 0, sizeof(params.reserved));\n\t\t}\n\t\tswitch (params.stream) {\n\t\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\t\tif (rfile->output == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn snd_rawmidi_output_params(rfile->output, &params);\n\t\tcase SNDRV_RAWMIDI_STREAM_INPUT:\n\t\t\tif (rfile->input == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn snd_rawmidi_input_params(rfile->input, &params);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase SNDRV_RAWMIDI_IOCTL_STATUS32:\n\t\treturn snd_rawmidi_ioctl_status32(rfile, argp);\n\tcase SNDRV_RAWMIDI_IOCTL_STATUS64:\n\t\treturn snd_rawmidi_ioctl_status64(rfile, argp);\n\tcase SNDRV_RAWMIDI_IOCTL_DROP:\n\t{\n\t\tint val;\n\n\t\tif (get_user(val, (int __user *) argp))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\t\tif (rfile->output == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn snd_rawmidi_drop_output(rfile->output);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcase SNDRV_RAWMIDI_IOCTL_DRAIN:\n\t{\n\t\tint val;\n\n\t\tif (get_user(val, (int __user *) argp))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase SNDRV_RAWMIDI_STREAM_OUTPUT:\n\t\t\tif (rfile->output == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn snd_rawmidi_drain_output(rfile->output);\n\t\tcase SNDRV_RAWMIDI_STREAM_INPUT:\n\t\t\tif (rfile->input == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn snd_rawmidi_drain_input(rfile->input);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tdefault:\n\t\trmidi = rfile->rmidi;\n\t\tif (rmidi->ops && rmidi->ops->ioctl)\n\t\t\treturn rmidi->ops->ioctl(rmidi, cmd, argp);\n\t\trmidi_dbg(rmidi, \"rawmidi: unknown command = 0x%x\\n\", cmd);\n\t}\n\treturn -ENOTTY;\n}\n\n \nstatic int snd_rawmidi_next_device(struct snd_card *card, int __user *argp,\n\t\t\t\t   bool find_ump)\n\n{\n\tstruct snd_rawmidi *rmidi;\n\tint device;\n\tbool is_ump;\n\n\tif (get_user(device, argp))\n\t\treturn -EFAULT;\n\tif (device >= SNDRV_RAWMIDI_DEVICES)  \n\t\tdevice = SNDRV_RAWMIDI_DEVICES - 1;\n\tmutex_lock(&register_mutex);\n\tdevice = device < 0 ? 0 : device + 1;\n\tfor (; device < SNDRV_RAWMIDI_DEVICES; device++) {\n\t\trmidi = snd_rawmidi_search(card, device);\n\t\tif (!rmidi)\n\t\t\tcontinue;\n\t\tis_ump = rawmidi_is_ump(rmidi);\n\t\tif (find_ump == is_ump)\n\t\t\tbreak;\n\t}\n\tif (device == SNDRV_RAWMIDI_DEVICES)\n\t\tdevice = -1;\n\tmutex_unlock(&register_mutex);\n\tif (put_user(device, argp))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_UMP)\n \nstatic int snd_rawmidi_call_ump_ioctl(struct snd_card *card, int cmd,\n\t\t\t\t      void __user *argp)\n{\n\tstruct snd_ump_endpoint_info __user *info = argp;\n\tstruct snd_rawmidi *rmidi;\n\tint device, ret;\n\n\tif (get_user(device, &info->device))\n\t\treturn -EFAULT;\n\tmutex_lock(&register_mutex);\n\trmidi = snd_rawmidi_search(card, device);\n\tif (rmidi && rmidi->ops && rmidi->ops->ioctl)\n\t\tret = rmidi->ops->ioctl(rmidi, cmd, argp);\n\telse\n\t\tret = -ENXIO;\n\tmutex_unlock(&register_mutex);\n\treturn ret;\n}\n#endif\n\nstatic int snd_rawmidi_control_ioctl(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_file *control,\n\t\t\t\t     unsigned int cmd,\n\t\t\t\t     unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE:\n\t\treturn snd_rawmidi_next_device(card, argp, false);\n#if IS_ENABLED(CONFIG_SND_UMP)\n\tcase SNDRV_CTL_IOCTL_UMP_NEXT_DEVICE:\n\t\treturn snd_rawmidi_next_device(card, argp, true);\n\tcase SNDRV_CTL_IOCTL_UMP_ENDPOINT_INFO:\n\t\treturn snd_rawmidi_call_ump_ioctl(card, SNDRV_UMP_IOCTL_ENDPOINT_INFO, argp);\n\tcase SNDRV_CTL_IOCTL_UMP_BLOCK_INFO:\n\t\treturn snd_rawmidi_call_ump_ioctl(card, SNDRV_UMP_IOCTL_BLOCK_INFO, argp);\n#endif\n\tcase SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE:\n\t{\n\t\tint val;\n\n\t\tif (get_user(val, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tcontrol->preferred_subdevice[SND_CTL_SUBDEV_RAWMIDI] = val;\n\t\treturn 0;\n\t}\n\tcase SNDRV_CTL_IOCTL_RAWMIDI_INFO:\n\t\treturn snd_rawmidi_info_select_user(card, argp);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic int receive_with_tstamp_framing(struct snd_rawmidi_substream *substream,\n\t\t\tconst unsigned char *buffer, int src_count, const struct timespec64 *tstamp)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tstruct snd_rawmidi_framing_tstamp *dest_ptr;\n\tstruct snd_rawmidi_framing_tstamp frame = { .tv_sec = tstamp->tv_sec, .tv_nsec = tstamp->tv_nsec };\n\tint orig_count = src_count;\n\tint frame_size = sizeof(struct snd_rawmidi_framing_tstamp);\n\tint align = get_align(runtime);\n\n\tBUILD_BUG_ON(frame_size != 0x20);\n\tif (snd_BUG_ON((runtime->hw_ptr & 0x1f) != 0))\n\t\treturn -EINVAL;\n\n\twhile (src_count > align) {\n\t\tif ((int)(runtime->buffer_size - runtime->avail) < frame_size) {\n\t\t\truntime->xruns += src_count;\n\t\t\tbreak;\n\t\t}\n\t\tif (src_count >= SNDRV_RAWMIDI_FRAMING_DATA_LENGTH)\n\t\t\tframe.length = SNDRV_RAWMIDI_FRAMING_DATA_LENGTH;\n\t\telse {\n\t\t\tframe.length = get_aligned_size(runtime, src_count);\n\t\t\tif (!frame.length)\n\t\t\t\tbreak;\n\t\t\tmemset(frame.data, 0, SNDRV_RAWMIDI_FRAMING_DATA_LENGTH);\n\t\t}\n\t\tmemcpy(frame.data, buffer, frame.length);\n\t\tbuffer += frame.length;\n\t\tsrc_count -= frame.length;\n\t\tdest_ptr = (struct snd_rawmidi_framing_tstamp *) (runtime->buffer + runtime->hw_ptr);\n\t\t*dest_ptr = frame;\n\t\truntime->avail += frame_size;\n\t\truntime->hw_ptr += frame_size;\n\t\truntime->hw_ptr %= runtime->buffer_size;\n\t}\n\treturn orig_count - src_count;\n}\n\nstatic struct timespec64 get_framing_tstamp(struct snd_rawmidi_substream *substream)\n{\n\tstruct timespec64 ts64 = {0, 0};\n\n\tswitch (substream->clock_type) {\n\tcase SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC_RAW:\n\t\tktime_get_raw_ts64(&ts64);\n\t\tbreak;\n\tcase SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC:\n\t\tktime_get_ts64(&ts64);\n\t\tbreak;\n\tcase SNDRV_RAWMIDI_MODE_CLOCK_REALTIME:\n\t\tktime_get_real_ts64(&ts64);\n\t\tbreak;\n\t}\n\treturn ts64;\n}\n\n \nint snd_rawmidi_receive(struct snd_rawmidi_substream *substream,\n\t\t\tconst unsigned char *buffer, int count)\n{\n\tunsigned long flags;\n\tstruct timespec64 ts64 = get_framing_tstamp(substream);\n\tint result = 0, count1;\n\tstruct snd_rawmidi_runtime *runtime;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (!substream->opened) {\n\t\tresult = -EBADFD;\n\t\tgoto unlock;\n\t}\n\truntime = substream->runtime;\n\tif (!runtime || !runtime->buffer) {\n\t\trmidi_dbg(substream->rmidi,\n\t\t\t  \"snd_rawmidi_receive: input is not active!!!\\n\");\n\t\tresult = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tcount = get_aligned_size(runtime, count);\n\tif (!count)\n\t\tgoto unlock;\n\n\tif (substream->framing == SNDRV_RAWMIDI_MODE_FRAMING_TSTAMP) {\n\t\tresult = receive_with_tstamp_framing(substream, buffer, count, &ts64);\n\t} else if (count == 1) {\t \n\t\tsubstream->bytes++;\n\t\tif (runtime->avail < runtime->buffer_size) {\n\t\t\truntime->buffer[runtime->hw_ptr++] = buffer[0];\n\t\t\truntime->hw_ptr %= runtime->buffer_size;\n\t\t\truntime->avail++;\n\t\t\tresult++;\n\t\t} else {\n\t\t\truntime->xruns++;\n\t\t}\n\t} else {\n\t\tsubstream->bytes += count;\n\t\tcount1 = runtime->buffer_size - runtime->hw_ptr;\n\t\tif (count1 > count)\n\t\t\tcount1 = count;\n\t\tif (count1 > (int)(runtime->buffer_size - runtime->avail))\n\t\t\tcount1 = runtime->buffer_size - runtime->avail;\n\t\tcount1 = get_aligned_size(runtime, count1);\n\t\tif (!count1)\n\t\t\tgoto unlock;\n\t\tmemcpy(runtime->buffer + runtime->hw_ptr, buffer, count1);\n\t\truntime->hw_ptr += count1;\n\t\truntime->hw_ptr %= runtime->buffer_size;\n\t\truntime->avail += count1;\n\t\tcount -= count1;\n\t\tresult += count1;\n\t\tif (count > 0) {\n\t\t\tbuffer += count1;\n\t\t\tcount1 = count;\n\t\t\tif (count1 > (int)(runtime->buffer_size - runtime->avail)) {\n\t\t\t\tcount1 = runtime->buffer_size - runtime->avail;\n\t\t\t\truntime->xruns += count - count1;\n\t\t\t}\n\t\t\tif (count1 > 0) {\n\t\t\t\tmemcpy(runtime->buffer, buffer, count1);\n\t\t\t\truntime->hw_ptr = count1;\n\t\t\t\truntime->avail += count1;\n\t\t\t\tresult += count1;\n\t\t\t}\n\t\t}\n\t}\n\tif (result > 0) {\n\t\tif (runtime->event)\n\t\t\tschedule_work(&runtime->event_work);\n\t\telse if (__snd_rawmidi_ready(runtime))\n\t\t\twake_up(&runtime->sleep);\n\t}\n unlock:\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_rawmidi_receive);\n\nstatic long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n\t\t\t\t     unsigned char __user *userbuf,\n\t\t\t\t     unsigned char *kernelbuf, long count)\n{\n\tunsigned long flags;\n\tlong result = 0, count1;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tunsigned long appl_ptr;\n\tint err = 0;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tsnd_rawmidi_buffer_ref(runtime);\n\twhile (count > 0 && runtime->avail) {\n\t\tcount1 = runtime->buffer_size - runtime->appl_ptr;\n\t\tif (count1 > count)\n\t\t\tcount1 = count;\n\t\tif (count1 > (int)runtime->avail)\n\t\t\tcount1 = runtime->avail;\n\n\t\t \n\t\tappl_ptr = runtime->appl_ptr;\n\t\truntime->appl_ptr += count1;\n\t\truntime->appl_ptr %= runtime->buffer_size;\n\t\truntime->avail -= count1;\n\n\t\tif (kernelbuf)\n\t\t\tmemcpy(kernelbuf + result, runtime->buffer + appl_ptr, count1);\n\t\tif (userbuf) {\n\t\t\tspin_unlock_irqrestore(&substream->lock, flags);\n\t\t\tif (copy_to_user(userbuf + result,\n\t\t\t\t\t runtime->buffer + appl_ptr, count1))\n\t\t\t\terr = -EFAULT;\n\t\t\tspin_lock_irqsave(&substream->lock, flags);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tresult += count1;\n\t\tcount -= count1;\n\t}\n out:\n\tsnd_rawmidi_buffer_unref(runtime);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result > 0 ? result : err;\n}\n\nlong snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,\n\t\t\t     unsigned char *buf, long count)\n{\n\tsnd_rawmidi_input_trigger(substream, 1);\n\treturn snd_rawmidi_kernel_read1(substream, NULL , buf, count);\n}\nEXPORT_SYMBOL(snd_rawmidi_kernel_read);\n\nstatic ssize_t snd_rawmidi_read(struct file *file, char __user *buf, size_t count,\n\t\t\t\tloff_t *offset)\n{\n\tlong result;\n\tint count1;\n\tstruct snd_rawmidi_file *rfile;\n\tstruct snd_rawmidi_substream *substream;\n\tstruct snd_rawmidi_runtime *runtime;\n\n\trfile = file->private_data;\n\tsubstream = rfile->input;\n\tif (substream == NULL)\n\t\treturn -EIO;\n\truntime = substream->runtime;\n\tsnd_rawmidi_input_trigger(substream, 1);\n\tresult = 0;\n\twhile (count > 0) {\n\t\tspin_lock_irq(&substream->lock);\n\t\twhile (!__snd_rawmidi_ready(runtime)) {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\treturn result > 0 ? result : -EAGAIN;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&runtime->sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&runtime->sleep, &wait);\n\t\t\tif (rfile->rmidi->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn result > 0 ? result : -ERESTARTSYS;\n\t\t\tspin_lock_irq(&substream->lock);\n\t\t\tif (!runtime->avail) {\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\treturn result > 0 ? result : -EIO;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&substream->lock);\n\t\tcount1 = snd_rawmidi_kernel_read1(substream,\n\t\t\t\t\t\t  (unsigned char __user *)buf,\n\t\t\t\t\t\t  NULL ,\n\t\t\t\t\t\t  count);\n\t\tif (count1 < 0)\n\t\t\treturn result > 0 ? result : count1;\n\t\tresult += count1;\n\t\tbuf += count1;\n\t\tcount -= count1;\n\t}\n\treturn result;\n}\n\n \nint snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_rawmidi_runtime *runtime;\n\tint result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\truntime = substream->runtime;\n\tif (!substream->opened || !runtime || !runtime->buffer) {\n\t\trmidi_dbg(substream->rmidi,\n\t\t\t  \"snd_rawmidi_transmit_empty: output is not active!!!\\n\");\n\t\tresult = 1;\n\t} else {\n\t\tresult = runtime->avail >= runtime->buffer_size;\n\t}\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_rawmidi_transmit_empty);\n\n \nstatic int __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,\n\t\t\t\t       unsigned char *buffer, int count)\n{\n\tint result, count1;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tif (runtime->buffer == NULL) {\n\t\trmidi_dbg(substream->rmidi,\n\t\t\t  \"snd_rawmidi_transmit_peek: output is not active!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tresult = 0;\n\tif (runtime->avail >= runtime->buffer_size) {\n\t\t \n\t\tgoto __skip;\n\t}\n\tif (count == 1) {\t \n\t\t*buffer = runtime->buffer[runtime->hw_ptr];\n\t\tresult++;\n\t} else {\n\t\tcount1 = runtime->buffer_size - runtime->hw_ptr;\n\t\tif (count1 > count)\n\t\t\tcount1 = count;\n\t\tif (count1 > (int)(runtime->buffer_size - runtime->avail))\n\t\t\tcount1 = runtime->buffer_size - runtime->avail;\n\t\tcount1 = get_aligned_size(runtime, count1);\n\t\tif (!count1)\n\t\t\tgoto __skip;\n\t\tmemcpy(buffer, runtime->buffer + runtime->hw_ptr, count1);\n\t\tcount -= count1;\n\t\tresult += count1;\n\t\tif (count > 0) {\n\t\t\tif (count > (int)(runtime->buffer_size - runtime->avail - count1))\n\t\t\t\tcount = runtime->buffer_size - runtime->avail - count1;\n\t\t\tcount = get_aligned_size(runtime, count);\n\t\t\tif (!count)\n\t\t\t\tgoto __skip;\n\t\t\tmemcpy(buffer + count1, runtime->buffer, count);\n\t\t\tresult += count;\n\t\t}\n\t}\n      __skip:\n\treturn result;\n}\n\n \nint snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,\n\t\t\t      unsigned char *buffer, int count)\n{\n\tint result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (!substream->opened || !substream->runtime)\n\t\tresult = -EBADFD;\n\telse\n\t\tresult = __snd_rawmidi_transmit_peek(substream, buffer, count);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_rawmidi_transmit_peek);\n\n \nstatic int __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int count)\n{\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tif (runtime->buffer == NULL) {\n\t\trmidi_dbg(substream->rmidi,\n\t\t\t  \"snd_rawmidi_transmit_ack: output is not active!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsnd_BUG_ON(runtime->avail + count > runtime->buffer_size);\n\tcount = get_aligned_size(runtime, count);\n\truntime->hw_ptr += count;\n\truntime->hw_ptr %= runtime->buffer_size;\n\truntime->avail += count;\n\tsubstream->bytes += count;\n\tif (count > 0) {\n\t\tif (runtime->drain || __snd_rawmidi_ready(runtime))\n\t\t\twake_up(&runtime->sleep);\n\t}\n\treturn count;\n}\n\n \nint snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)\n{\n\tint result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (!substream->opened || !substream->runtime)\n\t\tresult = -EBADFD;\n\telse\n\t\tresult = __snd_rawmidi_transmit_ack(substream, count);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_rawmidi_transmit_ack);\n\n \nint snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,\n\t\t\t unsigned char *buffer, int count)\n{\n\tint result;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (!substream->opened)\n\t\tresult = -EBADFD;\n\telse {\n\t\tcount = __snd_rawmidi_transmit_peek(substream, buffer, count);\n\t\tif (count <= 0)\n\t\t\tresult = count;\n\t\telse\n\t\t\tresult = __snd_rawmidi_transmit_ack(substream, count);\n\t}\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_rawmidi_transmit);\n\n \nint snd_rawmidi_proceed(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_rawmidi_runtime *runtime;\n\tunsigned long flags;\n\tint count = 0;\n\n\tspin_lock_irqsave(&substream->lock, flags);\n\truntime = substream->runtime;\n\tif (substream->opened && runtime &&\n\t    runtime->avail < runtime->buffer_size) {\n\t\tcount = runtime->buffer_size - runtime->avail;\n\t\t__snd_rawmidi_transmit_ack(substream, count);\n\t}\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\treturn count;\n}\nEXPORT_SYMBOL(snd_rawmidi_proceed);\n\nstatic long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n\t\t\t\t      const unsigned char __user *userbuf,\n\t\t\t\t      const unsigned char *kernelbuf,\n\t\t\t\t      long count)\n{\n\tunsigned long flags;\n\tlong count1, result;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tunsigned long appl_ptr;\n\n\tif (!kernelbuf && !userbuf)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!runtime->buffer))\n\t\treturn -EINVAL;\n\n\tresult = 0;\n\tspin_lock_irqsave(&substream->lock, flags);\n\tif (substream->append) {\n\t\tif ((long)runtime->avail < count) {\n\t\t\tspin_unlock_irqrestore(&substream->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tsnd_rawmidi_buffer_ref(runtime);\n\twhile (count > 0 && runtime->avail > 0) {\n\t\tcount1 = runtime->buffer_size - runtime->appl_ptr;\n\t\tif (count1 > count)\n\t\t\tcount1 = count;\n\t\tif (count1 > (long)runtime->avail)\n\t\t\tcount1 = runtime->avail;\n\n\t\t \n\t\tappl_ptr = runtime->appl_ptr;\n\t\truntime->appl_ptr += count1;\n\t\truntime->appl_ptr %= runtime->buffer_size;\n\t\truntime->avail -= count1;\n\n\t\tif (kernelbuf)\n\t\t\tmemcpy(runtime->buffer + appl_ptr,\n\t\t\t       kernelbuf + result, count1);\n\t\telse if (userbuf) {\n\t\t\tspin_unlock_irqrestore(&substream->lock, flags);\n\t\t\tif (copy_from_user(runtime->buffer + appl_ptr,\n\t\t\t\t\t   userbuf + result, count1)) {\n\t\t\t\tspin_lock_irqsave(&substream->lock, flags);\n\t\t\t\tresult = result > 0 ? result : -EFAULT;\n\t\t\t\tgoto __end;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&substream->lock, flags);\n\t\t}\n\t\tresult += count1;\n\t\tcount -= count1;\n\t}\n      __end:\n\tcount1 = runtime->avail < runtime->buffer_size;\n\tsnd_rawmidi_buffer_unref(runtime);\n\tspin_unlock_irqrestore(&substream->lock, flags);\n\tif (count1)\n\t\tsnd_rawmidi_output_trigger(substream, 1);\n\treturn result;\n}\n\nlong snd_rawmidi_kernel_write(struct snd_rawmidi_substream *substream,\n\t\t\t      const unsigned char *buf, long count)\n{\n\treturn snd_rawmidi_kernel_write1(substream, NULL, buf, count);\n}\nEXPORT_SYMBOL(snd_rawmidi_kernel_write);\n\nstatic ssize_t snd_rawmidi_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *offset)\n{\n\tlong result, timeout;\n\tint count1;\n\tstruct snd_rawmidi_file *rfile;\n\tstruct snd_rawmidi_runtime *runtime;\n\tstruct snd_rawmidi_substream *substream;\n\n\trfile = file->private_data;\n\tsubstream = rfile->output;\n\truntime = substream->runtime;\n\t \n\tif (substream->append && count > runtime->buffer_size)\n\t\treturn -EIO;\n\tresult = 0;\n\twhile (count > 0) {\n\t\tspin_lock_irq(&substream->lock);\n\t\twhile (!snd_rawmidi_ready_append(substream, count)) {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\treturn result > 0 ? result : -EAGAIN;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&runtime->sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\ttimeout = schedule_timeout(30 * HZ);\n\t\t\tremove_wait_queue(&runtime->sleep, &wait);\n\t\t\tif (rfile->rmidi->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn result > 0 ? result : -ERESTARTSYS;\n\t\t\tspin_lock_irq(&substream->lock);\n\t\t\tif (!runtime->avail && !timeout) {\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\treturn result > 0 ? result : -EIO;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&substream->lock);\n\t\tcount1 = snd_rawmidi_kernel_write1(substream, buf, NULL, count);\n\t\tif (count1 < 0)\n\t\t\treturn result > 0 ? result : count1;\n\t\tresult += count1;\n\t\tbuf += count1;\n\t\tif ((size_t)count1 < count && (file->f_flags & O_NONBLOCK))\n\t\t\tbreak;\n\t\tcount -= count1;\n\t}\n\tif (file->f_flags & O_DSYNC) {\n\t\tspin_lock_irq(&substream->lock);\n\t\twhile (runtime->avail != runtime->buffer_size) {\n\t\t\twait_queue_entry_t wait;\n\t\t\tunsigned int last_avail = runtime->avail;\n\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&runtime->sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\ttimeout = schedule_timeout(30 * HZ);\n\t\t\tremove_wait_queue(&runtime->sleep, &wait);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn result > 0 ? result : -ERESTARTSYS;\n\t\t\tif (runtime->avail == last_avail && !timeout)\n\t\t\t\treturn result > 0 ? result : -EIO;\n\t\t\tspin_lock_irq(&substream->lock);\n\t\t}\n\t\tspin_unlock_irq(&substream->lock);\n\t}\n\treturn result;\n}\n\nstatic __poll_t snd_rawmidi_poll(struct file *file, poll_table *wait)\n{\n\tstruct snd_rawmidi_file *rfile;\n\tstruct snd_rawmidi_runtime *runtime;\n\t__poll_t mask;\n\n\trfile = file->private_data;\n\tif (rfile->input != NULL) {\n\t\truntime = rfile->input->runtime;\n\t\tsnd_rawmidi_input_trigger(rfile->input, 1);\n\t\tpoll_wait(file, &runtime->sleep, wait);\n\t}\n\tif (rfile->output != NULL) {\n\t\truntime = rfile->output->runtime;\n\t\tpoll_wait(file, &runtime->sleep, wait);\n\t}\n\tmask = 0;\n\tif (rfile->input != NULL) {\n\t\tif (snd_rawmidi_ready(rfile->input))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\tif (rfile->output != NULL) {\n\t\tif (snd_rawmidi_ready(rfile->output))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\treturn mask;\n}\n\n \n#ifdef CONFIG_COMPAT\n#include \"rawmidi_compat.c\"\n#else\n#define snd_rawmidi_ioctl_compat\tNULL\n#endif\n\n \n\nstatic void snd_rawmidi_proc_info_read(struct snd_info_entry *entry,\n\t\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *substream;\n\tstruct snd_rawmidi_runtime *runtime;\n\tunsigned long buffer_size, avail, xruns;\n\tunsigned int clock_type;\n\tstatic const char *clock_names[4] = { \"none\", \"realtime\", \"monotonic\", \"monotonic raw\" };\n\n\trmidi = entry->private_data;\n\tsnd_iprintf(buffer, \"%s\\n\\n\", rmidi->name);\n\tif (IS_ENABLED(CONFIG_SND_UMP))\n\t\tsnd_iprintf(buffer, \"Type: %s\\n\",\n\t\t\t    rawmidi_is_ump(rmidi) ? \"UMP\" : \"Legacy\");\n\tif (rmidi->ops && rmidi->ops->proc_read)\n\t\trmidi->ops->proc_read(entry, buffer);\n\tmutex_lock(&rmidi->open_mutex);\n\tif (rmidi->info_flags & SNDRV_RAWMIDI_INFO_OUTPUT) {\n\t\tlist_for_each_entry(substream,\n\t\t\t\t    &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,\n\t\t\t\t    list) {\n\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"Output %d\\n\"\n\t\t\t\t    \"  Tx bytes     : %lu\\n\",\n\t\t\t\t    substream->number,\n\t\t\t\t    (unsigned long) substream->bytes);\n\t\t\tif (substream->opened) {\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"  Owner PID    : %d\\n\",\n\t\t\t\t    pid_vnr(substream->pid));\n\t\t\t\truntime = substream->runtime;\n\t\t\t\tspin_lock_irq(&substream->lock);\n\t\t\t\tbuffer_size = runtime->buffer_size;\n\t\t\t\tavail = runtime->avail;\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"  Mode         : %s\\n\"\n\t\t\t\t    \"  Buffer size  : %lu\\n\"\n\t\t\t\t    \"  Avail        : %lu\\n\",\n\t\t\t\t    runtime->oss ? \"OSS compatible\" : \"native\",\n\t\t\t\t    buffer_size, avail);\n\t\t\t}\n\t\t}\n\t}\n\tif (rmidi->info_flags & SNDRV_RAWMIDI_INFO_INPUT) {\n\t\tlist_for_each_entry(substream,\n\t\t\t\t    &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,\n\t\t\t\t    list) {\n\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"Input %d\\n\"\n\t\t\t\t    \"  Rx bytes     : %lu\\n\",\n\t\t\t\t    substream->number,\n\t\t\t\t    (unsigned long) substream->bytes);\n\t\t\tif (substream->opened) {\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t    \"  Owner PID    : %d\\n\",\n\t\t\t\t\t    pid_vnr(substream->pid));\n\t\t\t\truntime = substream->runtime;\n\t\t\t\tspin_lock_irq(&substream->lock);\n\t\t\t\tbuffer_size = runtime->buffer_size;\n\t\t\t\tavail = runtime->avail;\n\t\t\t\txruns = runtime->xruns;\n\t\t\t\tspin_unlock_irq(&substream->lock);\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t    \"  Buffer size  : %lu\\n\"\n\t\t\t\t\t    \"  Avail        : %lu\\n\"\n\t\t\t\t\t    \"  Overruns     : %lu\\n\",\n\t\t\t\t\t    buffer_size, avail, xruns);\n\t\t\t\tif (substream->framing == SNDRV_RAWMIDI_MODE_FRAMING_TSTAMP) {\n\t\t\t\t\tclock_type = substream->clock_type >> SNDRV_RAWMIDI_MODE_CLOCK_SHIFT;\n\t\t\t\t\tif (!snd_BUG_ON(clock_type >= ARRAY_SIZE(clock_names)))\n\t\t\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t\t\t    \"  Framing      : tstamp\\n\"\n\t\t\t\t\t\t\t    \"  Clock type   : %s\\n\",\n\t\t\t\t\t\t\t    clock_names[clock_type]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&rmidi->open_mutex);\n}\n\n \n\nstatic const struct file_operations snd_rawmidi_f_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_rawmidi_read,\n\t.write =\tsnd_rawmidi_write,\n\t.open =\t\tsnd_rawmidi_open,\n\t.release =\tsnd_rawmidi_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_rawmidi_poll,\n\t.unlocked_ioctl =\tsnd_rawmidi_ioctl,\n\t.compat_ioctl =\tsnd_rawmidi_ioctl_compat,\n};\n\nstatic int snd_rawmidi_alloc_substreams(struct snd_rawmidi *rmidi,\n\t\t\t\t\tstruct snd_rawmidi_str *stream,\n\t\t\t\t\tint direction,\n\t\t\t\t\tint count)\n{\n\tstruct snd_rawmidi_substream *substream;\n\tint idx;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\tsubstream = kzalloc(sizeof(*substream), GFP_KERNEL);\n\t\tif (!substream)\n\t\t\treturn -ENOMEM;\n\t\tsubstream->stream = direction;\n\t\tsubstream->number = idx;\n\t\tsubstream->rmidi = rmidi;\n\t\tsubstream->pstr = stream;\n\t\tspin_lock_init(&substream->lock);\n\t\tlist_add_tail(&substream->list, &stream->substreams);\n\t\tstream->substream_count++;\n\t}\n\treturn 0;\n}\n\n \nint snd_rawmidi_init(struct snd_rawmidi *rmidi,\n\t\t     struct snd_card *card, char *id, int device,\n\t\t     int output_count, int input_count,\n\t\t     unsigned int info_flags)\n{\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_rawmidi_dev_free,\n\t\t.dev_register = snd_rawmidi_dev_register,\n\t\t.dev_disconnect = snd_rawmidi_dev_disconnect,\n\t};\n\n\trmidi->card = card;\n\trmidi->device = device;\n\tmutex_init(&rmidi->open_mutex);\n\tinit_waitqueue_head(&rmidi->open_wait);\n\tINIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams);\n\tINIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams);\n\trmidi->info_flags = info_flags;\n\n\tif (id != NULL)\n\t\tstrscpy(rmidi->id, id, sizeof(rmidi->id));\n\n\terr = snd_device_alloc(&rmidi->dev, card);\n\tif (err < 0)\n\t\treturn err;\n\tif (rawmidi_is_ump(rmidi))\n\t\tdev_set_name(rmidi->dev, \"umpC%iD%i\", card->number, device);\n\telse\n\t\tdev_set_name(rmidi->dev, \"midiC%iD%i\", card->number, device);\n\n\terr = snd_rawmidi_alloc_substreams(rmidi,\n\t\t\t\t\t   &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT],\n\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t   input_count);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_rawmidi_alloc_substreams(rmidi,\n\t\t\t\t\t   &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT],\n\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t   output_count);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_device_new(card, SNDRV_DEV_RAWMIDI, rmidi, &ops);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_rawmidi_init);\n\n \nint snd_rawmidi_new(struct snd_card *card, char *id, int device,\n\t\t    int output_count, int input_count,\n\t\t    struct snd_rawmidi **rrawmidi)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\tif (rrawmidi)\n\t\t*rrawmidi = NULL;\n\trmidi = kzalloc(sizeof(*rmidi), GFP_KERNEL);\n\tif (!rmidi)\n\t\treturn -ENOMEM;\n\terr = snd_rawmidi_init(rmidi, card, id, device,\n\t\t\t       output_count, input_count, 0);\n\tif (err < 0) {\n\t\tsnd_rawmidi_free(rmidi);\n\t\treturn err;\n\t}\n\tif (rrawmidi)\n\t\t*rrawmidi = rmidi;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_rawmidi_new);\n\nstatic void snd_rawmidi_free_substreams(struct snd_rawmidi_str *stream)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\twhile (!list_empty(&stream->substreams)) {\n\t\tsubstream = list_entry(stream->substreams.next, struct snd_rawmidi_substream, list);\n\t\tlist_del(&substream->list);\n\t\tkfree(substream);\n\t}\n}\n\n \nint snd_rawmidi_free(struct snd_rawmidi *rmidi)\n{\n\tif (!rmidi)\n\t\treturn 0;\n\n\tsnd_info_free_entry(rmidi->proc_entry);\n\trmidi->proc_entry = NULL;\n\tif (rmidi->ops && rmidi->ops->dev_unregister)\n\t\trmidi->ops->dev_unregister(rmidi);\n\n\tsnd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);\n\tsnd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);\n\tif (rmidi->private_free)\n\t\trmidi->private_free(rmidi);\n\tput_device(rmidi->dev);\n\tkfree(rmidi);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_rawmidi_free);\n\nstatic int snd_rawmidi_dev_free(struct snd_device *device)\n{\n\tstruct snd_rawmidi *rmidi = device->device_data;\n\n\treturn snd_rawmidi_free(rmidi);\n}\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\nstatic void snd_rawmidi_dev_seq_free(struct snd_seq_device *device)\n{\n\tstruct snd_rawmidi *rmidi = device->private_data;\n\n\trmidi->seq_dev = NULL;\n}\n#endif\n\nstatic int snd_rawmidi_dev_register(struct snd_device *device)\n{\n\tint err;\n\tstruct snd_info_entry *entry;\n\tchar name[16];\n\tstruct snd_rawmidi *rmidi = device->device_data;\n\n\tif (rmidi->device >= SNDRV_RAWMIDI_DEVICES)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tmutex_lock(&register_mutex);\n\tif (snd_rawmidi_search(rmidi->card, rmidi->device))\n\t\terr = -EBUSY;\n\telse\n\t\tlist_add_tail(&rmidi->list, &snd_rawmidi_devices);\n\tmutex_unlock(&register_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_RAWMIDI,\n\t\t\t\t  rmidi->card, rmidi->device,\n\t\t\t\t  &snd_rawmidi_f_ops, rmidi, rmidi->dev);\n\tif (err < 0) {\n\t\trmidi_err(rmidi, \"unable to register\\n\");\n\t\tgoto error;\n\t}\n\tif (rmidi->ops && rmidi->ops->dev_register) {\n\t\terr = rmidi->ops->dev_register(rmidi);\n\t\tif (err < 0)\n\t\t\tgoto error_unregister;\n\t}\n#ifdef CONFIG_SND_OSSEMUL\n\trmidi->ossreg = 0;\n\tif (!rawmidi_is_ump(rmidi) &&\n\t    (int)rmidi->device == midi_map[rmidi->card->number]) {\n\t\tif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI,\n\t\t\t\t\t    rmidi->card, 0, &snd_rawmidi_f_ops,\n\t\t\t\t\t    rmidi) < 0) {\n\t\t\trmidi_err(rmidi,\n\t\t\t\t  \"unable to register OSS rawmidi device %i:%i\\n\",\n\t\t\t\t  rmidi->card->number, 0);\n\t\t} else {\n\t\t\trmidi->ossreg++;\n#ifdef SNDRV_OSS_INFO_DEV_MIDI\n\t\t\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number, rmidi->name);\n#endif\n\t\t}\n\t}\n\tif (!rawmidi_is_ump(rmidi) &&\n\t    (int)rmidi->device == amidi_map[rmidi->card->number]) {\n\t\tif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI,\n\t\t\t\t\t    rmidi->card, 1, &snd_rawmidi_f_ops,\n\t\t\t\t\t    rmidi) < 0) {\n\t\t\trmidi_err(rmidi,\n\t\t\t\t  \"unable to register OSS rawmidi device %i:%i\\n\",\n\t\t\t\t  rmidi->card->number, 1);\n\t\t} else {\n\t\t\trmidi->ossreg++;\n\t\t}\n\t}\n#endif  \n\tsprintf(name, \"midi%d\", rmidi->device);\n\tentry = snd_info_create_card_entry(rmidi->card, name, rmidi->card->proc_root);\n\tif (entry) {\n\t\tentry->private_data = rmidi;\n\t\tentry->c.text.read = snd_rawmidi_proc_info_read;\n\t\tif (snd_info_register(entry) < 0) {\n\t\t\tsnd_info_free_entry(entry);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\trmidi->proc_entry = entry;\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\t \n\tif (!rmidi->ops || !rmidi->ops->dev_register) {\n\t\tif (snd_seq_device_new(rmidi->card, rmidi->device, SNDRV_SEQ_DEV_ID_MIDISYNTH, 0, &rmidi->seq_dev) >= 0) {\n\t\t\trmidi->seq_dev->private_data = rmidi;\n\t\t\trmidi->seq_dev->private_free = snd_rawmidi_dev_seq_free;\n\t\t\tsprintf(rmidi->seq_dev->name, \"MIDI %d-%d\", rmidi->card->number, rmidi->device);\n\t\t\tsnd_device_register(rmidi->card, rmidi->seq_dev);\n\t\t}\n\t}\n#endif\n\treturn 0;\n\n error_unregister:\n\tsnd_unregister_device(rmidi->dev);\n error:\n\tmutex_lock(&register_mutex);\n\tlist_del(&rmidi->list);\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\nstatic int snd_rawmidi_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_rawmidi *rmidi = device->device_data;\n\tint dir;\n\n\tmutex_lock(&register_mutex);\n\tmutex_lock(&rmidi->open_mutex);\n\twake_up(&rmidi->open_wait);\n\tlist_del_init(&rmidi->list);\n\tfor (dir = 0; dir < 2; dir++) {\n\t\tstruct snd_rawmidi_substream *s;\n\n\t\tlist_for_each_entry(s, &rmidi->streams[dir].substreams, list) {\n\t\t\tif (s->runtime)\n\t\t\t\twake_up(&s->runtime->sleep);\n\t\t}\n\t}\n\n#ifdef CONFIG_SND_OSSEMUL\n\tif (rmidi->ossreg) {\n\t\tif ((int)rmidi->device == midi_map[rmidi->card->number]) {\n\t\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI, rmidi->card, 0);\n#ifdef SNDRV_OSS_INFO_DEV_MIDI\n\t\t\tsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number);\n#endif\n\t\t}\n\t\tif ((int)rmidi->device == amidi_map[rmidi->card->number])\n\t\t\tsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIDI, rmidi->card, 1);\n\t\trmidi->ossreg = 0;\n\t}\n#endif  \n\tsnd_unregister_device(rmidi->dev);\n\tmutex_unlock(&rmidi->open_mutex);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\n \nvoid snd_rawmidi_set_ops(struct snd_rawmidi *rmidi, int stream,\n\t\t\t const struct snd_rawmidi_ops *ops)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\tlist_for_each_entry(substream, &rmidi->streams[stream].substreams, list)\n\t\tsubstream->ops = ops;\n}\nEXPORT_SYMBOL(snd_rawmidi_set_ops);\n\n \n\nstatic int __init alsa_rawmidi_init(void)\n{\n\n\tsnd_ctl_register_ioctl(snd_rawmidi_control_ioctl);\n\tsnd_ctl_register_ioctl_compat(snd_rawmidi_control_ioctl);\n#ifdef CONFIG_SND_OSSEMUL\n\t{ int i;\n\t \n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (midi_map[i] < 0 || midi_map[i] >= SNDRV_RAWMIDI_DEVICES) {\n\t\t\tpr_err(\"ALSA: rawmidi: invalid midi_map[%d] = %d\\n\",\n\t\t\t       i, midi_map[i]);\n\t\t\tmidi_map[i] = 0;\n\t\t}\n\t\tif (amidi_map[i] < 0 || amidi_map[i] >= SNDRV_RAWMIDI_DEVICES) {\n\t\t\tpr_err(\"ALSA: rawmidi: invalid amidi_map[%d] = %d\\n\",\n\t\t\t       i, amidi_map[i]);\n\t\t\tamidi_map[i] = 1;\n\t\t}\n\t}\n\t}\n#endif  \n\treturn 0;\n}\n\nstatic void __exit alsa_rawmidi_exit(void)\n{\n\tsnd_ctl_unregister_ioctl(snd_rawmidi_control_ioctl);\n\tsnd_ctl_unregister_ioctl_compat(snd_rawmidi_control_ioctl);\n}\n\nmodule_init(alsa_rawmidi_init)\nmodule_exit(alsa_rawmidi_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}