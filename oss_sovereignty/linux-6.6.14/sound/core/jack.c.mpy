{
  "module_name": "jack.c",
  "hash_id": "0f18fcc38a51d4bc2821a5ae4cb858da8335bf337ab8ea401dcaa1289990d111",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/jack.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n#include <sound/jack.h>\n#include <sound/core.h>\n#include <sound/control.h>\n\nstruct snd_jack_kctl {\n\tstruct snd_kcontrol *kctl;\n\tstruct list_head list;   \n\tunsigned int mask_bits;  \n\tstruct snd_jack *jack;   \n\tbool sw_inject_enable;   \n#ifdef CONFIG_SND_JACK_INJECTION_DEBUG\n\tstruct dentry *jack_debugfs_root;  \n#endif\n};\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\nstatic const int jack_switch_types[SND_JACK_SWITCH_TYPES] = {\n\tSW_HEADPHONE_INSERT,\n\tSW_MICROPHONE_INSERT,\n\tSW_LINEOUT_INSERT,\n\tSW_JACK_PHYSICAL_INSERT,\n\tSW_VIDEOOUT_INSERT,\n\tSW_LINEIN_INSERT,\n};\n#endif  \n\nstatic int snd_jack_dev_disconnect(struct snd_device *device)\n{\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tstruct snd_jack *jack = device->device_data;\n\n\tmutex_lock(&jack->input_dev_lock);\n\tif (!jack->input_dev) {\n\t\tmutex_unlock(&jack->input_dev_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (jack->registered)\n\t\tinput_unregister_device(jack->input_dev);\n\telse\n\t\tinput_free_device(jack->input_dev);\n\tjack->input_dev = NULL;\n\tmutex_unlock(&jack->input_dev_lock);\n#endif  \n\treturn 0;\n}\n\nstatic int snd_jack_dev_free(struct snd_device *device)\n{\n\tstruct snd_jack *jack = device->device_data;\n\tstruct snd_card *card = device->card;\n\tstruct snd_jack_kctl *jack_kctl, *tmp_jack_kctl;\n\n\tlist_for_each_entry_safe(jack_kctl, tmp_jack_kctl, &jack->kctl_list, list) {\n\t\tlist_del_init(&jack_kctl->list);\n\t\tsnd_ctl_remove(card, jack_kctl->kctl);\n\t}\n\n\tif (jack->private_free)\n\t\tjack->private_free(jack);\n\n\tsnd_jack_dev_disconnect(device);\n\n\tkfree(jack->id);\n\tkfree(jack);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\nstatic int snd_jack_dev_register(struct snd_device *device)\n{\n\tstruct snd_jack *jack = device->device_data;\n\tstruct snd_card *card = device->card;\n\tint err, i;\n\n\tsnprintf(jack->name, sizeof(jack->name), \"%s %s\",\n\t\t card->shortname, jack->id);\n\n\tmutex_lock(&jack->input_dev_lock);\n\tif (!jack->input_dev) {\n\t\tmutex_unlock(&jack->input_dev_lock);\n\t\treturn 0;\n\t}\n\n\tjack->input_dev->name = jack->name;\n\n\t \n\tif (!jack->input_dev->dev.parent)\n\t\tjack->input_dev->dev.parent = snd_card_get_device_link(card);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(jack->key); i++) {\n\t\tint testbit = SND_JACK_BTN_0 >> i;\n\n\t\tif (!(jack->type & testbit))\n\t\t\tcontinue;\n\n\t\tif (!jack->key[i])\n\t\t\tjack->key[i] = BTN_0 + i;\n\n\t\tinput_set_capability(jack->input_dev, EV_KEY, jack->key[i]);\n\t}\n\n\terr = input_register_device(jack->input_dev);\n\tif (err == 0)\n\t\tjack->registered = 1;\n\n\tmutex_unlock(&jack->input_dev_lock);\n\treturn err;\n}\n#endif  \n\n#ifdef CONFIG_SND_JACK_INJECTION_DEBUG\nstatic void snd_jack_inject_report(struct snd_jack_kctl *jack_kctl, int status)\n{\n\tstruct snd_jack *jack;\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tint i;\n#endif\n\tif (!jack_kctl)\n\t\treturn;\n\n\tjack = jack_kctl->jack;\n\n\tif (jack_kctl->sw_inject_enable)\n\t\tsnd_kctl_jack_report(jack->card, jack_kctl->kctl,\n\t\t\t\t     status & jack_kctl->mask_bits);\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tif (!jack->input_dev)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(jack->key); i++) {\n\t\tint testbit = ((SND_JACK_BTN_0 >> i) & jack_kctl->mask_bits);\n\n\t\tif (jack->type & testbit)\n\t\t\tinput_report_key(jack->input_dev, jack->key[i],\n\t\t\t\t\t status & testbit);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(jack_switch_types); i++) {\n\t\tint testbit = ((1 << i) & jack_kctl->mask_bits);\n\n\t\tif (jack->type & testbit)\n\t\t\tinput_report_switch(jack->input_dev,\n\t\t\t\t\t    jack_switch_types[i],\n\t\t\t\t\t    status & testbit);\n\t}\n\n\tinput_sync(jack->input_dev);\n#endif  \n}\n\nstatic ssize_t sw_inject_enable_read(struct file *file,\n\t\t\t\t     char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tint len, ret;\n\tchar buf[128];\n\n\tlen = scnprintf(buf, sizeof(buf), \"%s: %s\\t\\t%s: %i\\n\", \"Jack\", jack_kctl->kctl->id.name,\n\t\t\t\"Inject Enabled\", jack_kctl->sw_inject_enable);\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\n\n\treturn ret;\n}\n\nstatic ssize_t sw_inject_enable_write(struct file *file,\n\t\t\t\t      const char __user *from, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tint ret, err;\n\tunsigned long enable;\n\tchar buf[8] = { 0 };\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, from, count);\n\terr = kstrtoul(buf, 0, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (jack_kctl->sw_inject_enable == (!!enable))\n\t\treturn ret;\n\n\tjack_kctl->sw_inject_enable = !!enable;\n\n\tif (!jack_kctl->sw_inject_enable)\n\t\tsnd_jack_report(jack_kctl->jack, jack_kctl->jack->hw_status_cache);\n\n\treturn ret;\n}\n\nstatic ssize_t jackin_inject_write(struct file *file,\n\t\t\t\t   const char __user *from, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tint ret, err;\n\tunsigned long enable;\n\tchar buf[8] = { 0 };\n\n\tif (!jack_kctl->sw_inject_enable)\n\t\treturn -EINVAL;\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, from, count);\n\terr = kstrtoul(buf, 0, &enable);\n\tif (err)\n\t\treturn err;\n\n\tsnd_jack_inject_report(jack_kctl, !!enable ? jack_kctl->mask_bits : 0);\n\n\treturn ret;\n}\n\nstatic ssize_t jack_kctl_id_read(struct file *file,\n\t\t\t\t char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tchar buf[64];\n\tint len, ret;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%s\\n\", jack_kctl->kctl->id.name);\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\n\n\treturn ret;\n}\n\n \nstatic const char * const jack_events_name[] = {\n\t\"HEADPHONE(0x0001)\", \"MICROPHONE(0x0002)\", \"LINEOUT(0x0004)\",\n\t\"MECHANICAL(0x0008)\", \"VIDEOOUT(0x0010)\", \"LINEIN(0x0020)\",\n\t\"\", \"\", \"\", \"BTN_5(0x0200)\", \"BTN_4(0x0400)\", \"BTN_3(0x0800)\",\n\t\"BTN_2(0x1000)\", \"BTN_1(0x2000)\", \"BTN_0(0x4000)\", \"\",\n};\n\n \nstatic int parse_mask_bits(unsigned int mask_bits, char *buf, size_t buf_size)\n{\n\tint i;\n\n\tscnprintf(buf, buf_size, \"0x%04x\", mask_bits);\n\n\tfor (i = 0; i < ARRAY_SIZE(jack_events_name); i++)\n\t\tif (mask_bits & (1 << i)) {\n\t\t\tstrlcat(buf, \" \", buf_size);\n\t\t\tstrlcat(buf, jack_events_name[i], buf_size);\n\t\t}\n\tstrlcat(buf, \"\\n\", buf_size);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t jack_kctl_mask_bits_read(struct file *file,\n\t\t\t\t\tchar __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tchar buf[256];\n\tint len, ret;\n\n\tlen = parse_mask_bits(jack_kctl->mask_bits, buf, sizeof(buf));\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\n\n\treturn ret;\n}\n\nstatic ssize_t jack_kctl_status_read(struct file *file,\n\t\t\t\t     char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tchar buf[16];\n\tint len, ret;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%s\\n\", jack_kctl->kctl->private_value ?\n\t\t\t\"Plugged\" : \"Unplugged\");\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\nstatic ssize_t jack_type_read(struct file *file,\n\t\t\t      char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_jack_kctl *jack_kctl = file->private_data;\n\tchar buf[256];\n\tint len, ret;\n\n\tlen = parse_mask_bits(jack_kctl->jack->type, buf, sizeof(buf));\n\tret = simple_read_from_buffer(to, count, ppos, buf, len);\n\n\treturn ret;\n}\n\nstatic const struct file_operations jack_type_fops = {\n\t.open = simple_open,\n\t.read = jack_type_read,\n\t.llseek = default_llseek,\n};\n#endif\n\nstatic const struct file_operations sw_inject_enable_fops = {\n\t.open = simple_open,\n\t.read = sw_inject_enable_read,\n\t.write = sw_inject_enable_write,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations jackin_inject_fops = {\n\t.open = simple_open,\n\t.write = jackin_inject_write,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations jack_kctl_id_fops = {\n\t.open = simple_open,\n\t.read = jack_kctl_id_read,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations jack_kctl_mask_bits_fops = {\n\t.open = simple_open,\n\t.read = jack_kctl_mask_bits_read,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations jack_kctl_status_fops = {\n\t.open = simple_open,\n\t.read = jack_kctl_status_read,\n\t.llseek = default_llseek,\n};\n\nstatic int snd_jack_debugfs_add_inject_node(struct snd_jack *jack,\n\t\t\t\t\t    struct snd_jack_kctl *jack_kctl)\n{\n\tchar *tname;\n\tint i;\n\n\t \n\tif (strstr(jack_kctl->kctl->id.name, \"Phantom\"))\n\t\treturn 0;\n\n\ttname = kstrdup(jack_kctl->kctl->id.name, GFP_KERNEL);\n\tif (!tname)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; tname[i]; i++)\n\t\tif (!isalnum(tname[i]))\n\t\t\ttname[i] = '_';\n\n\tjack_kctl->jack_debugfs_root = debugfs_create_dir(tname, jack->card->debugfs_root);\n\tkfree(tname);\n\n\tdebugfs_create_file(\"sw_inject_enable\", 0644, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &sw_inject_enable_fops);\n\n\tdebugfs_create_file(\"jackin_inject\", 0200, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &jackin_inject_fops);\n\n\tdebugfs_create_file(\"kctl_id\", 0444, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &jack_kctl_id_fops);\n\n\tdebugfs_create_file(\"mask_bits\", 0444, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &jack_kctl_mask_bits_fops);\n\n\tdebugfs_create_file(\"status\", 0444, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &jack_kctl_status_fops);\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tdebugfs_create_file(\"type\", 0444, jack_kctl->jack_debugfs_root, jack_kctl,\n\t\t\t    &jack_type_fops);\n#endif\n\treturn 0;\n}\n\nstatic void snd_jack_debugfs_clear_inject_node(struct snd_jack_kctl *jack_kctl)\n{\n\tdebugfs_remove(jack_kctl->jack_debugfs_root);\n\tjack_kctl->jack_debugfs_root = NULL;\n}\n#else  \nstatic int snd_jack_debugfs_add_inject_node(struct snd_jack *jack,\n\t\t\t\t\t    struct snd_jack_kctl *jack_kctl)\n{\n\treturn 0;\n}\n\nstatic void snd_jack_debugfs_clear_inject_node(struct snd_jack_kctl *jack_kctl)\n{\n}\n#endif  \n\nstatic void snd_jack_kctl_private_free(struct snd_kcontrol *kctl)\n{\n\tstruct snd_jack_kctl *jack_kctl;\n\n\tjack_kctl = kctl->private_data;\n\tif (jack_kctl) {\n\t\tsnd_jack_debugfs_clear_inject_node(jack_kctl);\n\t\tlist_del(&jack_kctl->list);\n\t\tkfree(jack_kctl);\n\t}\n}\n\nstatic void snd_jack_kctl_add(struct snd_jack *jack, struct snd_jack_kctl *jack_kctl)\n{\n\tjack_kctl->jack = jack;\n\tlist_add_tail(&jack_kctl->list, &jack->kctl_list);\n\tsnd_jack_debugfs_add_inject_node(jack, jack_kctl);\n}\n\nstatic struct snd_jack_kctl * snd_jack_kctl_new(struct snd_card *card, const char *name, unsigned int mask)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_jack_kctl *jack_kctl;\n\tint err;\n\n\tkctl = snd_kctl_jack_new(name, card);\n\tif (!kctl)\n\t\treturn NULL;\n\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tjack_kctl = kzalloc(sizeof(*jack_kctl), GFP_KERNEL);\n\n\tif (!jack_kctl)\n\t\tgoto error;\n\n\tjack_kctl->kctl = kctl;\n\tjack_kctl->mask_bits = mask;\n\n\tkctl->private_data = jack_kctl;\n\tkctl->private_free = snd_jack_kctl_private_free;\n\n\treturn jack_kctl;\nerror:\n\tsnd_ctl_free_one(kctl);\n\treturn NULL;\n}\n\n \nint snd_jack_add_new_kctl(struct snd_jack *jack, const char * name, int mask)\n{\n\tstruct snd_jack_kctl *jack_kctl;\n\n\tjack_kctl = snd_jack_kctl_new(jack->card, name, mask);\n\tif (!jack_kctl)\n\t\treturn -ENOMEM;\n\n\tsnd_jack_kctl_add(jack, jack_kctl);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_jack_add_new_kctl);\n\n \nint snd_jack_new(struct snd_card *card, const char *id, int type,\n\t\t struct snd_jack **jjack, bool initial_kctl, bool phantom_jack)\n{\n\tstruct snd_jack *jack;\n\tstruct snd_jack_kctl *jack_kctl = NULL;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_jack_dev_free,\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\t\t.dev_register = snd_jack_dev_register,\n\t\t.dev_disconnect = snd_jack_dev_disconnect,\n#endif  \n\t};\n\n\tif (initial_kctl) {\n\t\tjack_kctl = snd_jack_kctl_new(card, id, type);\n\t\tif (!jack_kctl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tjack = kzalloc(sizeof(struct snd_jack), GFP_KERNEL);\n\tif (jack == NULL)\n\t\treturn -ENOMEM;\n\n\tjack->id = kstrdup(id, GFP_KERNEL);\n\tif (jack->id == NULL) {\n\t\tkfree(jack);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tmutex_init(&jack->input_dev_lock);\n\n\t \n\tif (!phantom_jack) {\n\t\tint i;\n\n\t\tjack->input_dev = input_allocate_device();\n\t\tif (jack->input_dev == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_input;\n\t\t}\n\n\t\tjack->input_dev->phys = \"ALSA\";\n\n\t\tjack->type = type;\n\n\t\tfor (i = 0; i < SND_JACK_SWITCH_TYPES; i++)\n\t\t\tif (type & (1 << i))\n\t\t\t\tinput_set_capability(jack->input_dev, EV_SW,\n\t\t\t\t\t\t     jack_switch_types[i]);\n\n\t}\n#endif  \n\n\terr = snd_device_new(card, SNDRV_DEV_JACK, jack, &ops);\n\tif (err < 0)\n\t\tgoto fail_input;\n\n\tjack->card = card;\n\tINIT_LIST_HEAD(&jack->kctl_list);\n\n\tif (initial_kctl)\n\t\tsnd_jack_kctl_add(jack, jack_kctl);\n\n\t*jjack = jack;\n\n\treturn 0;\n\nfail_input:\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tinput_free_device(jack->input_dev);\n#endif\n\tkfree(jack->id);\n\tkfree(jack);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_jack_new);\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n \nvoid snd_jack_set_parent(struct snd_jack *jack, struct device *parent)\n{\n\tWARN_ON(jack->registered);\n\tmutex_lock(&jack->input_dev_lock);\n\tif (!jack->input_dev) {\n\t\tmutex_unlock(&jack->input_dev_lock);\n\t\treturn;\n\t}\n\n\tjack->input_dev->dev.parent = parent;\n\tmutex_unlock(&jack->input_dev_lock);\n}\nEXPORT_SYMBOL(snd_jack_set_parent);\n\n \nint snd_jack_set_key(struct snd_jack *jack, enum snd_jack_types type,\n\t\t     int keytype)\n{\n\tint key = fls(SND_JACK_BTN_0) - fls(type);\n\n\tWARN_ON(jack->registered);\n\n\tif (!keytype || key >= ARRAY_SIZE(jack->key))\n\t\treturn -EINVAL;\n\n\tjack->type |= type;\n\tjack->key[key] = keytype;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_jack_set_key);\n#endif  \n\n \nvoid snd_jack_report(struct snd_jack *jack, int status)\n{\n\tstruct snd_jack_kctl *jack_kctl;\n\tunsigned int mask_bits = 0;\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tstruct input_dev *idev;\n\tint i;\n#endif\n\n\tif (!jack)\n\t\treturn;\n\n\tjack->hw_status_cache = status;\n\n\tlist_for_each_entry(jack_kctl, &jack->kctl_list, list)\n\t\tif (jack_kctl->sw_inject_enable)\n\t\t\tmask_bits |= jack_kctl->mask_bits;\n\t\telse\n\t\t\tsnd_kctl_jack_report(jack->card, jack_kctl->kctl,\n\t\t\t\t\t     status & jack_kctl->mask_bits);\n\n#ifdef CONFIG_SND_JACK_INPUT_DEV\n\tidev = input_get_device(jack->input_dev);\n\tif (!idev)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(jack->key); i++) {\n\t\tint testbit = ((SND_JACK_BTN_0 >> i) & ~mask_bits);\n\n\t\tif (jack->type & testbit)\n\t\t\tinput_report_key(idev, jack->key[i],\n\t\t\t\t\t status & testbit);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(jack_switch_types); i++) {\n\t\tint testbit = ((1 << i) & ~mask_bits);\n\n\t\tif (jack->type & testbit)\n\t\t\tinput_report_switch(idev,\n\t\t\t\t\t    jack_switch_types[i],\n\t\t\t\t\t    status & testbit);\n\t}\n\n\tinput_sync(idev);\n\tinput_put_device(idev);\n#endif  \n}\nEXPORT_SYMBOL(snd_jack_report);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}