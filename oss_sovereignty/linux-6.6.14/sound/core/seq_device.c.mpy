{
  "module_name": "seq_device.c",
  "hash_id": "c4811a7817f7f748a0111a4410bc8112371e3886afc0f40ce00e10f737cc76fe",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/seq_device.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/seq_device.h>\n#include <sound/seq_kernel.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA sequencer device management\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int snd_seq_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_seq_driver *sdrv = to_seq_drv(drv);\n\n\treturn strcmp(sdrv->id, sdev->id) == 0 &&\n\t\tsdrv->argsize == sdev->argsize;\n}\n\nstatic struct bus_type snd_seq_bus_type = {\n\t.name = \"snd_seq\",\n\t.match = snd_seq_bus_match,\n};\n\n \n#ifdef CONFIG_SND_PROC_FS\nstatic struct snd_info_entry *info_entry;\n\nstatic int print_dev_info(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_info_buffer *buffer = data;\n\n\tsnd_iprintf(buffer, \"snd-%s,%s,%d\\n\", sdev->id,\n\t\t    dev->driver ? \"loaded\" : \"empty\",\n\t\t    dev->driver ? 1 : 0);\n\treturn 0;\n}\n\nstatic void snd_seq_device_info(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tbus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);\n}\n#endif\n\n \n\n#ifdef CONFIG_MODULES\n \nstatic atomic_t snd_seq_in_init = ATOMIC_INIT(1);  \n\nstatic int request_seq_drv(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (!dev->driver)\n\t\trequest_module(\"snd-%s\", sdev->id);\n\treturn 0;\n}\n\nstatic void autoload_drivers(struct work_struct *work)\n{\n\t \n\tif (atomic_inc_return(&snd_seq_in_init) == 1)\n\t\tbus_for_each_dev(&snd_seq_bus_type, NULL, NULL,\n\t\t\t\t request_seq_drv);\n\tatomic_dec(&snd_seq_in_init);\n}\n\nstatic DECLARE_WORK(autoload_work, autoload_drivers);\n\nstatic void queue_autoload_drivers(void)\n{\n\tschedule_work(&autoload_work);\n}\n\nvoid snd_seq_autoload_init(void)\n{\n\tatomic_dec(&snd_seq_in_init);\n#ifdef CONFIG_SND_SEQUENCER_MODULE\n\t \n\tqueue_autoload_drivers();\n#endif\n}\nEXPORT_SYMBOL(snd_seq_autoload_init);\n\nvoid snd_seq_autoload_exit(void)\n{\n\tatomic_inc(&snd_seq_in_init);\n}\nEXPORT_SYMBOL(snd_seq_autoload_exit);\n\nvoid snd_seq_device_load_drivers(void)\n{\n\tqueue_autoload_drivers();\n\tflush_work(&autoload_work);\n}\nEXPORT_SYMBOL(snd_seq_device_load_drivers);\n\nstatic inline void cancel_autoload_drivers(void)\n{\n\tcancel_work_sync(&autoload_work);\n}\n#else\nstatic inline void queue_autoload_drivers(void)\n{\n}\n\nstatic inline void cancel_autoload_drivers(void)\n{\n}\n#endif\n\n \nstatic int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tif (dev->private_free)\n\t\tdev->private_free(dev);\n\tput_device(&dev->dev);\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_register(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tint err;\n\n\terr = device_add(&dev->dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (!dev->dev.driver)\n\t\tqueue_autoload_drivers();\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tdevice_del(&dev->dev);\n\treturn 0;\n}\n\nstatic void snd_seq_dev_release(struct device *dev)\n{\n\tkfree(to_seq_dev(dev));\n}\n\n \nint snd_seq_device_new(struct snd_card *card, int device, const char *id,\n\t\t       int argsize, struct snd_seq_device **result)\n{\n\tstruct snd_seq_device *dev;\n\tint err;\n\tstatic const struct snd_device_ops dops = {\n\t\t.dev_free = snd_seq_device_dev_free,\n\t\t.dev_register = snd_seq_device_dev_register,\n\t\t.dev_disconnect = snd_seq_device_dev_disconnect,\n\t};\n\n\tif (result)\n\t\t*result = NULL;\n\n\tif (snd_BUG_ON(!id))\n\t\treturn -EINVAL;\n\n\tdev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->card = card;\n\tdev->device = device;\n\tdev->id = id;\n\tdev->argsize = argsize;\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.parent = &card->card_dev;\n\tdev->dev.bus = &snd_seq_bus_type;\n\tdev->dev.release = snd_seq_dev_release;\n\tdev_set_name(&dev->dev, \"%s-%d-%d\", dev->id, card->number, device);\n\n\t \n\terr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\n\tif (err < 0) {\n\t\tput_device(&dev->dev);\n\t\treturn err;\n\t}\n\t\n\tif (result)\n\t\t*result = dev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_device_new);\n\n \nint __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)\n{\n\tif (WARN_ON(!drv->driver.name || !drv->id))\n\t\treturn -EINVAL;\n\tdrv->driver.bus = &snd_seq_bus_type;\n\tdrv->driver.owner = mod;\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__snd_seq_driver_register);\n\nvoid snd_seq_driver_unregister(struct snd_seq_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(snd_seq_driver_unregister);\n\n \n\nstatic int __init seq_dev_proc_init(void)\n{\n#ifdef CONFIG_SND_PROC_FS\n\tinfo_entry = snd_info_create_module_entry(THIS_MODULE, \"drivers\",\n\t\t\t\t\t\t  snd_seq_root);\n\tif (info_entry == NULL)\n\t\treturn -ENOMEM;\n\tinfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\n\tinfo_entry->c.text.read = snd_seq_device_info;\n\tif (snd_info_register(info_entry) < 0) {\n\t\tsnd_info_free_entry(info_entry);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __init alsa_seq_device_init(void)\n{\n\tint err;\n\n\terr = bus_register(&snd_seq_bus_type);\n\tif (err < 0)\n\t\treturn err;\n\terr = seq_dev_proc_init();\n\tif (err < 0)\n\t\tbus_unregister(&snd_seq_bus_type);\n\treturn err;\n}\n\nstatic void __exit alsa_seq_device_exit(void)\n{\n#ifdef CONFIG_MODULES\n\tcancel_work_sync(&autoload_work);\n#endif\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_info_free_entry(info_entry);\n#endif\n\tbus_unregister(&snd_seq_bus_type);\n}\n\nsubsys_initcall(alsa_seq_device_init)\nmodule_exit(alsa_seq_device_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}