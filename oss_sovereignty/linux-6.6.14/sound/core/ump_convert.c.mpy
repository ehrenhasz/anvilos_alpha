{
  "module_name": "ump_convert.c",
  "hash_id": "731b379bc44cad8350e124dd1faefd5fb8f587e61e5e869cecea638e984f28d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/core/ump_convert.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/asound.h>\n#include <sound/ump.h>\n#include <sound/ump_convert.h>\n\n \nstatic u8 downscale_32_to_7bit(u32 src)\n{\n\treturn src >> 25;\n}\n\nstatic u16 downscale_32_to_14bit(u32 src)\n{\n\treturn src >> 18;\n}\n\nstatic u8 downscale_16_to_7bit(u16 src)\n{\n\treturn src >> 9;\n}\n\nstatic u16 upscale_7_to_16bit(u8 src)\n{\n\tu16 val, repeat;\n\n\tval = (u16)src << 9;\n\tif (src <= 0x40)\n\t\treturn val;\n\trepeat = src & 0x3f;\n\treturn val | (repeat << 3) | (repeat >> 3);\n}\n\nstatic u32 upscale_7_to_32bit(u8 src)\n{\n\tu32 val, repeat;\n\n\tval = src << 25;\n\tif (src <= 0x40)\n\t\treturn val;\n\trepeat = src & 0x3f;\n\treturn val | (repeat << 19) | (repeat << 13) |\n\t\t(repeat << 7) | (repeat << 1) | (repeat >> 5);\n}\n\nstatic u32 upscale_14_to_32bit(u16 src)\n{\n\tu32 val, repeat;\n\n\tval = src << 18;\n\tif (src <= 0x2000)\n\t\treturn val;\n\trepeat = src & 0x1fff;\n\treturn val | (repeat << 5) | (repeat >> 8);\n}\n\n \n \nstatic int cvt_ump_system_to_legacy(u32 data, unsigned char *buf)\n{\n\tbuf[0] = ump_message_status_channel(data);\n\tswitch (ump_message_status_code(data)) {\n\tcase UMP_SYSTEM_STATUS_MIDI_TIME_CODE:\n\tcase UMP_SYSTEM_STATUS_SONG_SELECT:\n\t\tbuf[1] = (data >> 8) & 0x7f;\n\t\treturn 2;\n\tcase UMP_SYSTEM_STATUS_SONG_POSITION:\n\t\tbuf[1] = (data >> 8) & 0x7f;\n\t\tbuf[2] = data & 0x7f;\n\t\treturn 3;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nstatic int cvt_ump_midi1_to_legacy(u32 data, unsigned char *buf)\n{\n\tbuf[0] = ump_message_status_channel(data);\n\tbuf[1] = (data >> 8) & 0xff;\n\tswitch (ump_message_status_code(data)) {\n\tcase UMP_MSG_STATUS_PROGRAM:\n\tcase UMP_MSG_STATUS_CHANNEL_PRESSURE:\n\t\treturn 2;\n\tdefault:\n\t\tbuf[2] = data & 0xff;\n\t\treturn 3;\n\t}\n}\n\n \nstatic int cvt_ump_midi2_to_legacy(const union snd_ump_midi2_msg *midi2,\n\t\t\t\t   unsigned char *buf)\n{\n\tunsigned char status = midi2->note.status;\n\tunsigned char channel = midi2->note.channel;\n\tu16 v;\n\n\tbuf[0] = (status << 4) | channel;\n\tswitch (status) {\n\tcase UMP_MSG_STATUS_NOTE_OFF:\n\tcase UMP_MSG_STATUS_NOTE_ON:\n\t\tbuf[1] = midi2->note.note;\n\t\tbuf[2] = downscale_16_to_7bit(midi2->note.velocity);\n\t\tif (status == UMP_MSG_STATUS_NOTE_ON && !buf[2])\n\t\t\tbuf[2] = 1;\n\t\treturn 3;\n\tcase UMP_MSG_STATUS_POLY_PRESSURE:\n\t\tbuf[1] = midi2->paf.note;\n\t\tbuf[2] = downscale_32_to_7bit(midi2->paf.data);\n\t\treturn 3;\n\tcase UMP_MSG_STATUS_CC:\n\t\tbuf[1] = midi2->cc.index;\n\t\tbuf[2] = downscale_32_to_7bit(midi2->cc.data);\n\t\treturn 3;\n\tcase UMP_MSG_STATUS_CHANNEL_PRESSURE:\n\t\tbuf[1] = downscale_32_to_7bit(midi2->caf.data);\n\t\treturn 2;\n\tcase UMP_MSG_STATUS_PROGRAM:\n\t\tif (midi2->pg.bank_valid) {\n\t\t\tbuf[0] = channel | (UMP_MSG_STATUS_CC << 4);\n\t\t\tbuf[1] = UMP_CC_BANK_SELECT;\n\t\t\tbuf[2] = midi2->pg.bank_msb;\n\t\t\tbuf[3] = channel | (UMP_MSG_STATUS_CC << 4);\n\t\t\tbuf[4] = UMP_CC_BANK_SELECT_LSB;\n\t\t\tbuf[5] = midi2->pg.bank_lsb;\n\t\t\tbuf[6] = channel | (UMP_MSG_STATUS_PROGRAM << 4);\n\t\t\tbuf[7] = midi2->pg.program;\n\t\t\treturn 8;\n\t\t}\n\t\tbuf[1] = midi2->pg.program;\n\t\treturn 2;\n\tcase UMP_MSG_STATUS_PITCH_BEND:\n\t\tv = downscale_32_to_14bit(midi2->pb.data);\n\t\tbuf[1] = v & 0x7f;\n\t\tbuf[2] = v >> 7;\n\t\treturn 3;\n\tcase UMP_MSG_STATUS_RPN:\n\tcase UMP_MSG_STATUS_NRPN:\n\t\tbuf[0] = channel | (UMP_MSG_STATUS_CC << 4);\n\t\tbuf[1] = status == UMP_MSG_STATUS_RPN ? UMP_CC_RPN_MSB : UMP_CC_NRPN_MSB;\n\t\tbuf[2] = midi2->rpn.bank;\n\t\tbuf[3] = buf[0];\n\t\tbuf[4] = status == UMP_MSG_STATUS_RPN ? UMP_CC_RPN_LSB : UMP_CC_NRPN_LSB;\n\t\tbuf[5] = midi2->rpn.index;\n\t\tbuf[6] = buf[0];\n\t\tbuf[7] = UMP_CC_DATA;\n\t\tv = downscale_32_to_14bit(midi2->rpn.data);\n\t\tbuf[8] = v >> 7;\n\t\tbuf[9] = buf[0];\n\t\tbuf[10] = UMP_CC_DATA_LSB;\n\t\tbuf[11] = v & 0x7f;\n\t\treturn 12;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int cvt_ump_sysex7_to_legacy(const u32 *data, unsigned char *buf)\n{\n\tunsigned char status;\n\tunsigned char bytes;\n\tint size, offset;\n\n\tstatus = ump_sysex_message_status(*data);\n\tif (status > UMP_SYSEX_STATUS_END)\n\t\treturn 0; \n\tbytes = ump_sysex_message_length(*data);\n\tif (bytes > 6)\n\t\treturn 0; \n\n\tsize = 0;\n\tif (status == UMP_SYSEX_STATUS_SINGLE ||\n\t    status == UMP_SYSEX_STATUS_START) {\n\t\tbuf[0] = UMP_MIDI1_MSG_SYSEX_START;\n\t\tsize = 1;\n\t}\n\n\toffset = 8;\n\tfor (; bytes; bytes--, size++) {\n\t\tbuf[size] = (*data >> offset) & 0x7f;\n\t\tif (!offset) {\n\t\t\toffset = 24;\n\t\t\tdata++;\n\t\t} else {\n\t\t\toffset -= 8;\n\t\t}\n\t}\n\n\tif (status == UMP_SYSEX_STATUS_SINGLE ||\n\t    status == UMP_SYSEX_STATUS_END)\n\t\tbuf[size++] = UMP_MIDI1_MSG_SYSEX_END;\n\n\treturn size;\n}\n\n \nint snd_ump_convert_from_ump(const u32 *data,\n\t\t\t     unsigned char *buf,\n\t\t\t     unsigned char *group_ret)\n{\n\t*group_ret = ump_message_group(*data);\n\n\tswitch (ump_message_type(*data)) {\n\tcase UMP_MSG_TYPE_SYSTEM:\n\t\treturn cvt_ump_system_to_legacy(*data, buf);\n\tcase UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE:\n\t\treturn cvt_ump_midi1_to_legacy(*data, buf);\n\tcase UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE:\n\t\treturn cvt_ump_midi2_to_legacy((const union snd_ump_midi2_msg *)data,\n\t\t\t\t\t       buf);\n\tcase UMP_MSG_TYPE_DATA:\n\t\treturn cvt_ump_sysex7_to_legacy(data, buf);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ump_convert_from_ump);\n\n \n \nstatic int cvt_legacy_sysex_to_ump(struct ump_cvt_to_ump *cvt,\n\t\t\t\t   unsigned char group, u32 *data, bool finish)\n{\n\tunsigned char status;\n\tbool start = cvt->in_sysex == 1;\n\tint i, offset;\n\n\tif (start && finish)\n\t\tstatus = UMP_SYSEX_STATUS_SINGLE;\n\telse if (start)\n\t\tstatus = UMP_SYSEX_STATUS_START;\n\telse if (finish)\n\t\tstatus = UMP_SYSEX_STATUS_END;\n\telse\n\t\tstatus = UMP_SYSEX_STATUS_CONTINUE;\n\t*data = ump_compose(UMP_MSG_TYPE_DATA, group, status, cvt->len);\n\toffset = 8;\n\tfor (i = 0; i < cvt->len; i++) {\n\t\t*data |= cvt->buf[i] << offset;\n\t\tif (!offset) {\n\t\t\toffset = 24;\n\t\t\tdata++;\n\t\t} else\n\t\t\toffset -= 8;\n\t}\n\tcvt->len = 0;\n\tif (finish)\n\t\tcvt->in_sysex = 0;\n\telse\n\t\tcvt->in_sysex++;\n\treturn 8;\n}\n\n \nstatic int cvt_legacy_system_to_ump(struct ump_cvt_to_ump *cvt,\n\t\t\t\t    unsigned char group, u32 *data)\n{\n\tdata[0] = ump_compose(UMP_MSG_TYPE_SYSTEM, group, 0, cvt->buf[0]);\n\tif (cvt->cmd_bytes > 1)\n\t\tdata[0] |= cvt->buf[1] << 8;\n\tif (cvt->cmd_bytes > 2)\n\t\tdata[0] |= cvt->buf[2];\n\treturn 4;\n}\n\nstatic void fill_rpn(struct ump_cvt_to_ump_bank *cc,\n\t\t     union snd_ump_midi2_msg *midi2)\n{\n\tif (cc->rpn_set) {\n\t\tmidi2->rpn.status = UMP_MSG_STATUS_RPN;\n\t\tmidi2->rpn.bank = cc->cc_rpn_msb;\n\t\tmidi2->rpn.index = cc->cc_rpn_lsb;\n\t\tcc->rpn_set = 0;\n\t\tcc->cc_rpn_msb = cc->cc_rpn_lsb = 0;\n\t} else {\n\t\tmidi2->rpn.status = UMP_MSG_STATUS_NRPN;\n\t\tmidi2->rpn.bank = cc->cc_nrpn_msb;\n\t\tmidi2->rpn.index = cc->cc_nrpn_lsb;\n\t\tcc->nrpn_set = 0;\n\t\tcc->cc_nrpn_msb = cc->cc_nrpn_lsb = 0;\n\t}\n\tmidi2->rpn.data = upscale_14_to_32bit((cc->cc_data_msb << 7) |\n\t\t\t\t\t      cc->cc_data_lsb);\n\tcc->cc_data_msb = cc->cc_data_lsb = 0;\n}\n\n \nstatic int cvt_legacy_cmd_to_ump(struct ump_cvt_to_ump *cvt,\n\t\t\t\t unsigned char group,\n\t\t\t\t unsigned int protocol,\n\t\t\t\t u32 *data, unsigned char bytes)\n{\n\tconst unsigned char *buf = cvt->buf;\n\tstruct ump_cvt_to_ump_bank *cc;\n\tunion snd_ump_midi2_msg *midi2 = (union snd_ump_midi2_msg *)data;\n\tunsigned char status, channel;\n\n\tBUILD_BUG_ON(sizeof(union snd_ump_midi1_msg) != 4);\n\tBUILD_BUG_ON(sizeof(union snd_ump_midi2_msg) != 8);\n\n\t \n\tif (protocol & SNDRV_UMP_EP_INFO_PROTO_MIDI1) {\n\t\tdata[0] = ump_compose(UMP_MSG_TYPE_MIDI1_CHANNEL_VOICE,\n\t\t\t\t      group, 0, buf[0]);\n\t\tdata[0] |= buf[1] << 8;\n\t\tif (bytes > 2)\n\t\t\tdata[0] |= buf[2];\n\t\treturn 4;\n\t}\n\n\tstatus = *buf >> 4;\n\tchannel = *buf & 0x0f;\n\tcc = &cvt->bank[channel];\n\n\t \n\tif (status == UMP_MSG_STATUS_NOTE_ON && !buf[2])\n\t\tstatus = UMP_MSG_STATUS_NOTE_OFF;\n\n\t \n\tdata[0] = ump_compose(UMP_MSG_TYPE_MIDI2_CHANNEL_VOICE,\n\t\t\t      group, status, channel);\n\tdata[1] = 0;\n\n\tswitch (status) {\n\tcase UMP_MSG_STATUS_NOTE_ON:\n\tcase UMP_MSG_STATUS_NOTE_OFF:\n\t\tmidi2->note.note = buf[1];\n\t\tmidi2->note.velocity = upscale_7_to_16bit(buf[2]);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_POLY_PRESSURE:\n\t\tmidi2->paf.note = buf[1];\n\t\tmidi2->paf.data = upscale_7_to_32bit(buf[2]);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CC:\n\t\tswitch (buf[1]) {\n\t\tcase UMP_CC_RPN_MSB:\n\t\t\tcc->rpn_set = 1;\n\t\t\tcc->cc_rpn_msb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_RPN_LSB:\n\t\t\tcc->rpn_set = 1;\n\t\t\tcc->cc_rpn_lsb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_NRPN_MSB:\n\t\t\tcc->nrpn_set = 1;\n\t\t\tcc->cc_nrpn_msb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_NRPN_LSB:\n\t\t\tcc->nrpn_set = 1;\n\t\t\tcc->cc_nrpn_lsb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_DATA:\n\t\t\tcc->cc_data_msb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_BANK_SELECT:\n\t\t\tcc->bank_set = 1;\n\t\t\tcc->cc_bank_msb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_BANK_SELECT_LSB:\n\t\t\tcc->bank_set = 1;\n\t\t\tcc->cc_bank_lsb = buf[2];\n\t\t\treturn 0; \n\t\tcase UMP_CC_DATA_LSB:\n\t\t\tcc->cc_data_lsb = buf[2];\n\t\t\tif (cc->rpn_set || cc->nrpn_set)\n\t\t\t\tfill_rpn(cc, midi2);\n\t\t\telse\n\t\t\t\treturn 0; \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmidi2->cc.index = buf[1];\n\t\t\tmidi2->cc.data = upscale_7_to_32bit(buf[2]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PROGRAM:\n\t\tmidi2->pg.program = buf[1];\n\t\tif (cc->bank_set) {\n\t\t\tmidi2->pg.bank_valid = 1;\n\t\t\tmidi2->pg.bank_msb = cc->cc_bank_msb;\n\t\t\tmidi2->pg.bank_lsb = cc->cc_bank_lsb;\n\t\t\tcc->bank_set = 0;\n\t\t\tcc->cc_bank_msb = cc->cc_bank_lsb = 0;\n\t\t}\n\t\tbreak;\n\tcase UMP_MSG_STATUS_CHANNEL_PRESSURE:\n\t\tmidi2->caf.data = upscale_7_to_32bit(buf[1]);\n\t\tbreak;\n\tcase UMP_MSG_STATUS_PITCH_BEND:\n\t\tmidi2->pb.data = upscale_14_to_32bit(buf[1] | (buf[2] << 7));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 8;\n}\n\nstatic int do_convert_to_ump(struct ump_cvt_to_ump *cvt, unsigned char group,\n\t\t\t     unsigned int protocol, unsigned char c, u32 *data)\n{\n\t \n\tstatic unsigned char cmd_bytes[8] = {\n\t\t3, 3, 3, 3, 2, 2, 3, 0\n\t};\n\t \n\tstatic unsigned char system_bytes[16] = {\n\t\t0, 2, 3, 2, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1\n\t};\n\tunsigned char bytes;\n\n\tif (c == UMP_MIDI1_MSG_SYSEX_START) {\n\t\tcvt->in_sysex = 1;\n\t\tcvt->len = 0;\n\t\treturn 0;\n\t}\n\tif (c == UMP_MIDI1_MSG_SYSEX_END) {\n\t\tif (!cvt->in_sysex)\n\t\t\treturn 0;  \n\t\treturn cvt_legacy_sysex_to_ump(cvt, group, data, true);\n\t}\n\n\tif ((c & 0xf0) == UMP_MIDI1_MSG_REALTIME) {\n\t\tbytes = system_bytes[c & 0x0f];\n\t\tif (!bytes)\n\t\t\treturn 0;  \n\t\tif (bytes == 1) {\n\t\t\tdata[0] = ump_compose(UMP_MSG_TYPE_SYSTEM, group, 0, c);\n\t\t\treturn 4;\n\t\t}\n\t\tcvt->buf[0] = c;\n\t\tcvt->len = 1;\n\t\tcvt->cmd_bytes = bytes;\n\t\tcvt->in_sysex = 0;  \n\t\treturn 0;\n\t}\n\n\tif (c & 0x80) {\n\t\tbytes = cmd_bytes[(c >> 4) & 7];\n\t\tcvt->buf[0] = c;\n\t\tcvt->len = 1;\n\t\tcvt->cmd_bytes = bytes;\n\t\tcvt->in_sysex = 0;  \n\t\treturn 0;\n\t}\n\n\tif (cvt->in_sysex) {\n\t\tcvt->buf[cvt->len++] = c;\n\t\tif (cvt->len == 6)\n\t\t\treturn cvt_legacy_sysex_to_ump(cvt, group, data, false);\n\t\treturn 0;\n\t}\n\n\tif (!cvt->len)\n\t\treturn 0;\n\n\tcvt->buf[cvt->len++] = c;\n\tif (cvt->len < cvt->cmd_bytes)\n\t\treturn 0;\n\tcvt->len = 1;\n\tif ((cvt->buf[0] & 0xf0) == UMP_MIDI1_MSG_REALTIME)\n\t\treturn cvt_legacy_system_to_ump(cvt, group, data);\n\treturn cvt_legacy_cmd_to_ump(cvt, group, protocol, data, cvt->cmd_bytes);\n}\n\n \nvoid snd_ump_convert_to_ump(struct ump_cvt_to_ump *cvt, unsigned char group,\n\t\t\t    unsigned int protocol, unsigned char c)\n{\n\tcvt->ump_bytes = do_convert_to_ump(cvt, group, protocol, c, cvt->ump);\n}\nEXPORT_SYMBOL_GPL(snd_ump_convert_to_ump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}