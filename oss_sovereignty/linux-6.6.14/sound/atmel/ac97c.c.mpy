{
  "module_name": "ac97c.c",
  "hash_id": "7ab6550e0816d98b5c92a173a7e17ec95b1be4eefb3f9869b2508313da13b5b7",
  "original_prompt": "Ingested from linux-6.6.14/sound/atmel/ac97c.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/bitmap.h>\n#include <linux/device.h>\n#include <linux/atmel_pdc.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/ac97_codec.h>\n#include <sound/memalloc.h>\n\n#include \"ac97c.h\"\n\n \nstatic DEFINE_MUTEX(opened_mutex);\n\nstruct atmel_ac97c {\n\tstruct clk\t\t\t*pclk;\n\tstruct platform_device\t\t*pdev;\n\n\tstruct snd_pcm_substream\t*playback_substream;\n\tstruct snd_pcm_substream\t*capture_substream;\n\tstruct snd_card\t\t\t*card;\n\tstruct snd_pcm\t\t\t*pcm;\n\tstruct snd_ac97\t\t\t*ac97;\n\tstruct snd_ac97_bus\t\t*ac97_bus;\n\n\tu64\t\t\t\tcur_format;\n\tunsigned int\t\t\tcur_rate;\n\tint\t\t\t\tplayback_period, capture_period;\n\t \n\tspinlock_t\t\t\tlock;\n\tvoid __iomem\t\t\t*regs;\n\tint\t\t\t\tirq;\n\tint\t\t\t\topened;\n\tstruct gpio_desc\t\t*reset_pin;\n};\n\n#define get_chip(card) ((struct atmel_ac97c *)(card)->private_data)\n\n#define ac97c_writel(chip, reg, val)\t\t\t\\\n\t__raw_writel((val), (chip)->regs + AC97C_##reg)\n#define ac97c_readl(chip, reg)\t\t\t\t\\\n\t__raw_readl((chip)->regs + AC97C_##reg)\n\nstatic const struct snd_pcm_hardware atmel_ac97c_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP\n\t\t\t\t  | SNDRV_PCM_INFO_MMAP_VALID\n\t\t\t\t  | SNDRV_PCM_INFO_INTERLEAVED\n\t\t\t\t  | SNDRV_PCM_INFO_BLOCK_TRANSFER\n\t\t\t\t  | SNDRV_PCM_INFO_JOINT_DUPLEX\n\t\t\t\t  | SNDRV_PCM_INFO_RESUME\n\t\t\t\t  | SNDRV_PCM_INFO_PAUSE),\n\t.formats\t\t= (SNDRV_PCM_FMTBIT_S16_BE\n\t\t\t\t  | SNDRV_PCM_FMTBIT_S16_LE),\n\t.rates\t\t\t= (SNDRV_PCM_RATE_CONTINUOUS),\n\t.rate_min\t\t= 4000,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 2 * 2 * 64 * 2048,\n\t.period_bytes_min\t= 4096,\n\t.period_bytes_max\t= 4096,\n\t.periods_min\t\t= 6,\n\t.periods_max\t\t= 64,\n};\n\nstatic int atmel_ac97c_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tmutex_lock(&opened_mutex);\n\tchip->opened++;\n\truntime->hw = atmel_ac97c_hw;\n\tif (chip->cur_rate) {\n\t\truntime->hw.rate_min = chip->cur_rate;\n\t\truntime->hw.rate_max = chip->cur_rate;\n\t}\n\tif (chip->cur_format)\n\t\truntime->hw.formats = pcm_format_to_bits(chip->cur_format);\n\tmutex_unlock(&opened_mutex);\n\tchip->playback_substream = substream;\n\treturn 0;\n}\n\nstatic int atmel_ac97c_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tmutex_lock(&opened_mutex);\n\tchip->opened++;\n\truntime->hw = atmel_ac97c_hw;\n\tif (chip->cur_rate) {\n\t\truntime->hw.rate_min = chip->cur_rate;\n\t\truntime->hw.rate_max = chip->cur_rate;\n\t}\n\tif (chip->cur_format)\n\t\truntime->hw.formats = pcm_format_to_bits(chip->cur_format);\n\tmutex_unlock(&opened_mutex);\n\tchip->capture_substream = substream;\n\treturn 0;\n}\n\nstatic int atmel_ac97c_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\n\tmutex_lock(&opened_mutex);\n\tchip->opened--;\n\tif (!chip->opened) {\n\t\tchip->cur_rate = 0;\n\t\tchip->cur_format = 0;\n\t}\n\tmutex_unlock(&opened_mutex);\n\n\tchip->playback_substream = NULL;\n\n\treturn 0;\n}\n\nstatic int atmel_ac97c_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\n\tmutex_lock(&opened_mutex);\n\tchip->opened--;\n\tif (!chip->opened) {\n\t\tchip->cur_rate = 0;\n\t\tchip->cur_format = 0;\n\t}\n\tmutex_unlock(&opened_mutex);\n\n\tchip->capture_substream = NULL;\n\n\treturn 0;\n}\n\nstatic int atmel_ac97c_playback_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\n\t \n\tmutex_lock(&opened_mutex);\n\tchip->cur_rate = params_rate(hw_params);\n\tchip->cur_format = params_format(hw_params);\n\tmutex_unlock(&opened_mutex);\n\n\treturn 0;\n}\n\nstatic int atmel_ac97c_capture_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\n\t \n\tmutex_lock(&opened_mutex);\n\tchip->cur_rate = params_rate(hw_params);\n\tchip->cur_format = params_format(hw_params);\n\tmutex_unlock(&opened_mutex);\n\n\treturn 0;\n}\n\nstatic int atmel_ac97c_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint block_size = frames_to_bytes(runtime, runtime->period_size);\n\tunsigned long word = ac97c_readl(chip, OCA);\n\tint retval;\n\n\tchip->playback_period = 0;\n\tword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\n\n\t \n\tswitch (runtime->channels) {\n\tcase 1:\n\t\tword |= AC97C_CH_ASSIGN(PCM_LEFT, A);\n\t\tbreak;\n\tcase 2:\n\t\tword |= AC97C_CH_ASSIGN(PCM_LEFT, A)\n\t\t\t| AC97C_CH_ASSIGN(PCM_RIGHT, A);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tac97c_writel(chip, OCA, word);\n\n\t \n\tword = ac97c_readl(chip, CAMR);\n\tif (chip->opened <= 1)\n\t\tword = AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\n\telse\n\t\tword |= AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\n\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tword &= ~(AC97C_CMR_CEM_LITTLE);\n\t\tbreak;\n\tdefault:\n\t\tword = ac97c_readl(chip, OCA);\n\t\tword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\n\t\tac97c_writel(chip, OCA, word);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tword |= AC97C_CSR_UNRUN;\n\n\tac97c_writel(chip, CAMR, word);\n\n\t \n\tword = ac97c_readl(chip, IMR);\n\tword |= AC97C_SR_CAEVT;\n\tac97c_writel(chip, IER, word);\n\n\t \n\tif (runtime->rate != 48000) {\n\t\tword = ac97c_readl(chip, MR);\n\t\tword |= AC97C_MR_VRA;\n\t\tac97c_writel(chip, MR, word);\n\t} else {\n\t\tword = ac97c_readl(chip, MR);\n\t\tword &= ~(AC97C_MR_VRA);\n\t\tac97c_writel(chip, MR, word);\n\t}\n\n\tretval = snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,\n\t\t\truntime->rate);\n\tif (retval)\n\t\tdev_dbg(&chip->pdev->dev, \"could not set rate %d Hz\\n\",\n\t\t\t\truntime->rate);\n\n\t \n\twritel(runtime->dma_addr, chip->regs + ATMEL_PDC_TPR);\n\twritel(block_size / 2, chip->regs + ATMEL_PDC_TCR);\n\twritel(runtime->dma_addr + block_size, chip->regs + ATMEL_PDC_TNPR);\n\twritel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);\n\n\treturn retval;\n}\n\nstatic int atmel_ac97c_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint block_size = frames_to_bytes(runtime, runtime->period_size);\n\tunsigned long word = ac97c_readl(chip, ICA);\n\tint retval;\n\n\tchip->capture_period = 0;\n\tword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\n\n\t \n\tswitch (runtime->channels) {\n\tcase 1:\n\t\tword |= AC97C_CH_ASSIGN(PCM_LEFT, A);\n\t\tbreak;\n\tcase 2:\n\t\tword |= AC97C_CH_ASSIGN(PCM_LEFT, A)\n\t\t\t| AC97C_CH_ASSIGN(PCM_RIGHT, A);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tac97c_writel(chip, ICA, word);\n\n\t \n\tword = ac97c_readl(chip, CAMR);\n\tif (chip->opened <= 1)\n\t\tword = AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\n\telse\n\t\tword |= AC97C_CMR_DMAEN | AC97C_CMR_SIZE_16;\n\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tword &= ~(AC97C_CMR_CEM_LITTLE);\n\t\tbreak;\n\tdefault:\n\t\tword = ac97c_readl(chip, ICA);\n\t\tword &= ~(AC97C_CH_MASK(PCM_LEFT) | AC97C_CH_MASK(PCM_RIGHT));\n\t\tac97c_writel(chip, ICA, word);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tword |= AC97C_CSR_OVRUN;\n\n\tac97c_writel(chip, CAMR, word);\n\n\t \n\tword = ac97c_readl(chip, IMR);\n\tword |= AC97C_SR_CAEVT;\n\tac97c_writel(chip, IER, word);\n\n\t \n\tif (runtime->rate != 48000) {\n\t\tword = ac97c_readl(chip, MR);\n\t\tword |= AC97C_MR_VRA;\n\t\tac97c_writel(chip, MR, word);\n\t} else {\n\t\tword = ac97c_readl(chip, MR);\n\t\tword &= ~(AC97C_MR_VRA);\n\t\tac97c_writel(chip, MR, word);\n\t}\n\n\tretval = snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE,\n\t\t\truntime->rate);\n\tif (retval)\n\t\tdev_dbg(&chip->pdev->dev, \"could not set rate %d Hz\\n\",\n\t\t\t\truntime->rate);\n\n\t \n\twritel(runtime->dma_addr, chip->regs + ATMEL_PDC_RPR);\n\twritel(block_size / 2, chip->regs + ATMEL_PDC_RCR);\n\twritel(runtime->dma_addr + block_size, chip->regs + ATMEL_PDC_RNPR);\n\twritel(block_size / 2, chip->regs + ATMEL_PDC_RNCR);\n\n\treturn retval;\n}\n\nstatic int\natmel_ac97c_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tunsigned long camr, ptcr = 0;\n\n\tcamr = ac97c_readl(chip, CAMR);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tptcr = ATMEL_PDC_TXTEN;\n\t\tcamr |= AC97C_CMR_CENA | AC97C_CSR_ENDTX;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tptcr |= ATMEL_PDC_TXTDIS;\n\t\tif (chip->opened <= 1)\n\t\t\tcamr &= ~AC97C_CMR_CENA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tac97c_writel(chip, CAMR, camr);\n\twritel(ptcr, chip->regs + ATMEL_PDC_PTCR);\n\treturn 0;\n}\n\nstatic int\natmel_ac97c_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct atmel_ac97c *chip = snd_pcm_substream_chip(substream);\n\tunsigned long camr, ptcr = 0;\n\n\tcamr = ac97c_readl(chip, CAMR);\n\tptcr = readl(chip->regs + ATMEL_PDC_PTSR);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tptcr = ATMEL_PDC_RXTEN;\n\t\tcamr |= AC97C_CMR_CENA | AC97C_CSR_ENDRX;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tptcr |= ATMEL_PDC_RXTDIS;\n\t\tif (chip->opened <= 1)\n\t\t\tcamr &= ~AC97C_CMR_CENA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tac97c_writel(chip, CAMR, camr);\n\twritel(ptcr, chip->regs + ATMEL_PDC_PTCR);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\natmel_ac97c_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c\t*chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime\t*runtime = substream->runtime;\n\tsnd_pcm_uframes_t\tframes;\n\tunsigned long\t\tbytes;\n\n\tbytes = readl(chip->regs + ATMEL_PDC_TPR);\n\tbytes -= runtime->dma_addr;\n\n\tframes = bytes_to_frames(runtime, bytes);\n\tif (frames >= runtime->buffer_size)\n\t\tframes -= runtime->buffer_size;\n\treturn frames;\n}\n\nstatic snd_pcm_uframes_t\natmel_ac97c_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct atmel_ac97c\t*chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime\t*runtime = substream->runtime;\n\tsnd_pcm_uframes_t\tframes;\n\tunsigned long\t\tbytes;\n\n\tbytes = readl(chip->regs + ATMEL_PDC_RPR);\n\tbytes -= runtime->dma_addr;\n\n\tframes = bytes_to_frames(runtime, bytes);\n\tif (frames >= runtime->buffer_size)\n\t\tframes -= runtime->buffer_size;\n\treturn frames;\n}\n\nstatic const struct snd_pcm_ops atmel_ac97_playback_ops = {\n\t.open\t\t= atmel_ac97c_playback_open,\n\t.close\t\t= atmel_ac97c_playback_close,\n\t.hw_params\t= atmel_ac97c_playback_hw_params,\n\t.prepare\t= atmel_ac97c_playback_prepare,\n\t.trigger\t= atmel_ac97c_playback_trigger,\n\t.pointer\t= atmel_ac97c_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops atmel_ac97_capture_ops = {\n\t.open\t\t= atmel_ac97c_capture_open,\n\t.close\t\t= atmel_ac97c_capture_close,\n\t.hw_params\t= atmel_ac97c_capture_hw_params,\n\t.prepare\t= atmel_ac97c_capture_prepare,\n\t.trigger\t= atmel_ac97c_capture_trigger,\n\t.pointer\t= atmel_ac97c_capture_pointer,\n};\n\nstatic irqreturn_t atmel_ac97c_interrupt(int irq, void *dev)\n{\n\tstruct atmel_ac97c\t*chip  = (struct atmel_ac97c *)dev;\n\tirqreturn_t\t\tretval = IRQ_NONE;\n\tu32\t\t\tsr     = ac97c_readl(chip, SR);\n\tu32\t\t\tcasr   = ac97c_readl(chip, CASR);\n\tu32\t\t\tcosr   = ac97c_readl(chip, COSR);\n\tu32\t\t\tcamr   = ac97c_readl(chip, CAMR);\n\n\tif (sr & AC97C_SR_CAEVT) {\n\t\tstruct snd_pcm_runtime *runtime;\n\t\tint offset, next_period, block_size;\n\t\tdev_dbg(&chip->pdev->dev, \"channel A event%s%s%s%s%s%s\\n\",\n\t\t\t(casr & AC97C_CSR_OVRUN)   ? \" OVRUN\"   : \"\",\n\t\t\t(casr & AC97C_CSR_RXRDY)   ? \" RXRDY\"   : \"\",\n\t\t\t(casr & AC97C_CSR_UNRUN)   ? \" UNRUN\"   : \"\",\n\t\t\t(casr & AC97C_CSR_TXEMPTY) ? \" TXEMPTY\" : \"\",\n\t\t\t(casr & AC97C_CSR_TXRDY)   ? \" TXRDY\"   : \"\",\n\t\t\t!casr                      ? \" NONE\"    : \"\");\n\t\tif ((casr & camr) & AC97C_CSR_ENDTX) {\n\t\t\truntime = chip->playback_substream->runtime;\n\t\t\tblock_size = frames_to_bytes(runtime, runtime->period_size);\n\t\t\tchip->playback_period++;\n\n\t\t\tif (chip->playback_period == runtime->periods)\n\t\t\t\tchip->playback_period = 0;\n\t\t\tnext_period = chip->playback_period + 1;\n\t\t\tif (next_period == runtime->periods)\n\t\t\t\tnext_period = 0;\n\n\t\t\toffset = block_size * next_period;\n\n\t\t\twritel(runtime->dma_addr + offset, chip->regs + ATMEL_PDC_TNPR);\n\t\t\twritel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);\n\n\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t}\n\t\tif ((casr & camr) & AC97C_CSR_ENDRX) {\n\t\t\truntime = chip->capture_substream->runtime;\n\t\t\tblock_size = frames_to_bytes(runtime, runtime->period_size);\n\t\t\tchip->capture_period++;\n\n\t\t\tif (chip->capture_period == runtime->periods)\n\t\t\t\tchip->capture_period = 0;\n\t\t\tnext_period = chip->capture_period + 1;\n\t\t\tif (next_period == runtime->periods)\n\t\t\t\tnext_period = 0;\n\n\t\t\toffset = block_size * next_period;\n\n\t\t\twritel(runtime->dma_addr + offset, chip->regs + ATMEL_PDC_RNPR);\n\t\t\twritel(block_size / 2, chip->regs + ATMEL_PDC_RNCR);\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t}\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif (sr & AC97C_SR_COEVT) {\n\t\tdev_info(&chip->pdev->dev, \"codec channel event%s%s%s%s%s\\n\",\n\t\t\t (cosr & AC97C_CSR_OVRUN)   ? \" OVRUN\"   : \"\",\n\t\t\t (cosr & AC97C_CSR_RXRDY)   ? \" RXRDY\"   : \"\",\n\t\t\t (cosr & AC97C_CSR_TXEMPTY) ? \" TXEMPTY\" : \"\",\n\t\t\t (cosr & AC97C_CSR_TXRDY)   ? \" TXRDY\"   : \"\",\n\t\t\t !cosr                      ? \" NONE\"    : \"\");\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif (retval == IRQ_NONE) {\n\t\tdev_err(&chip->pdev->dev, \"spurious interrupt sr 0x%08x \"\n\t\t\t\t\"casr 0x%08x cosr 0x%08x\\n\", sr, casr, cosr);\n\t}\n\n\treturn retval;\n}\n\nstatic const struct ac97_pcm at91_ac97_pcm_defs[] = {\n\t \n\t{\n\t\t.exclusive = 1,\n\t\t.r = { {\n\t\t\t.slots = ((1 << AC97_SLOT_PCM_LEFT)\n\t\t\t\t  | (1 << AC97_SLOT_PCM_RIGHT)),\n\t\t} },\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = { {\n\t\t\t.slots = ((1 << AC97_SLOT_PCM_LEFT)\n\t\t\t\t\t| (1 << AC97_SLOT_PCM_RIGHT)),\n\t\t} }\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = { {\n\t\t\t.slots = (1<<AC97_SLOT_MIC),\n\t\t} }\n\t},\n};\n\nstatic int atmel_ac97c_pcm_new(struct atmel_ac97c *chip)\n{\n\tstruct snd_pcm\t\t*pcm;\n\tstruct snd_pcm_hardware\thw = atmel_ac97c_hw;\n\tint\t\t\tretval;\n\n\tretval = snd_ac97_pcm_assign(chip->ac97_bus,\n\t\t\t\t     ARRAY_SIZE(at91_ac97_pcm_defs),\n\t\t\t\t     at91_ac97_pcm_defs);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\n\tif (retval)\n\t\treturn retval;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &atmel_ac97_capture_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &atmel_ac97_playback_ops);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t&chip->pdev->dev, hw.periods_min * hw.period_bytes_min,\n\t\t\thw.buffer_bytes_max);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n\nstatic int atmel_ac97c_mixer_new(struct atmel_ac97c *chip)\n{\n\tstruct snd_ac97_template template;\n\tmemset(&template, 0, sizeof(template));\n\ttemplate.private_data = chip;\n\treturn snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);\n}\n\nstatic void atmel_ac97c_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\tunsigned short val)\n{\n\tstruct atmel_ac97c *chip = get_chip(ac97);\n\tunsigned long word;\n\tint timeout = 40;\n\n\tword = (reg & 0x7f) << 16 | val;\n\n\tdo {\n\t\tif (ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) {\n\t\t\tac97c_writel(chip, COTHR, word);\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t} while (--timeout);\n\n\tdev_dbg(&chip->pdev->dev, \"codec write timeout\\n\");\n}\n\nstatic unsigned short atmel_ac97c_read(struct snd_ac97 *ac97,\n\t\tunsigned short reg)\n{\n\tstruct atmel_ac97c *chip = get_chip(ac97);\n\tunsigned long word;\n\tint timeout = 40;\n\tint write = 10;\n\n\tword = (0x80 | (reg & 0x7f)) << 16;\n\n\tif ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0)\n\t\tac97c_readl(chip, CORHR);\n\nretry_write:\n\ttimeout = 40;\n\n\tdo {\n\t\tif ((ac97c_readl(chip, COSR) & AC97C_CSR_TXRDY) != 0) {\n\t\t\tac97c_writel(chip, COTHR, word);\n\t\t\tgoto read_reg;\n\t\t}\n\t\tudelay(10);\n\t} while (--timeout);\n\n\tif (!--write)\n\t\tgoto timed_out;\n\tgoto retry_write;\n\nread_reg:\n\tdo {\n\t\tif ((ac97c_readl(chip, COSR) & AC97C_CSR_RXRDY) != 0) {\n\t\t\tunsigned short val = ac97c_readl(chip, CORHR);\n\t\t\treturn val;\n\t\t}\n\t\tudelay(10);\n\t} while (--timeout);\n\n\tif (!--write)\n\t\tgoto timed_out;\n\tgoto retry_write;\n\ntimed_out:\n\tdev_dbg(&chip->pdev->dev, \"codec read timeout\\n\");\n\treturn 0xffff;\n}\n\nstatic void atmel_ac97c_reset(struct atmel_ac97c *chip)\n{\n\tac97c_writel(chip, MR,   0);\n\tac97c_writel(chip, MR,   AC97C_MR_ENA);\n\tac97c_writel(chip, CAMR, 0);\n\tac97c_writel(chip, COMR, 0);\n\n\tif (!IS_ERR(chip->reset_pin)) {\n\t\tgpiod_set_value(chip->reset_pin, 0);\n\t\t \n\t\tudelay(2);\n\t\tgpiod_set_value(chip->reset_pin, 1);\n\t} else {\n\t\tac97c_writel(chip, MR, AC97C_MR_WRST | AC97C_MR_ENA);\n\t\tudelay(2);\n\t\tac97c_writel(chip, MR, AC97C_MR_ENA);\n\t}\n}\n\nstatic const struct of_device_id atmel_ac97c_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9263-ac97c\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, atmel_ac97c_dt_ids);\n\nstatic int atmel_ac97c_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct snd_card\t\t\t*card;\n\tstruct atmel_ac97c\t\t*chip;\n\tstruct resource\t\t\t*regs;\n\tstruct clk\t\t\t*pclk;\n\tstatic const struct snd_ac97_bus_ops\tops = {\n\t\t.write\t= atmel_ac97c_write,\n\t\t.read\t= atmel_ac97c_read,\n\t};\n\tint\t\t\t\tretval;\n\tint\t\t\t\tirq;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_dbg(&pdev->dev, \"no memory resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"could not get irq: %d\\n\", irq);\n\t\treturn irq;\n\t}\n\n\tpclk = clk_get(&pdev->dev, \"ac97_clk\");\n\tif (IS_ERR(pclk)) {\n\t\tdev_dbg(&pdev->dev, \"no peripheral clock\\n\");\n\t\treturn PTR_ERR(pclk);\n\t}\n\tretval = clk_prepare_enable(pclk);\n\tif (retval)\n\t\tgoto err_prepare_enable;\n\n\tretval = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1,\n\t\t\t      SNDRV_DEFAULT_STR1, THIS_MODULE,\n\t\t\t      sizeof(struct atmel_ac97c), &card);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"could not create sound card device\\n\");\n\t\tgoto err_snd_card_new;\n\t}\n\n\tchip = get_chip(card);\n\n\tretval = request_irq(irq, atmel_ac97c_interrupt, 0, \"AC97C\", chip);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"unable to request irq %d\\n\", irq);\n\t\tgoto err_request_irq;\n\t}\n\tchip->irq = irq;\n\n\tspin_lock_init(&chip->lock);\n\n\tstrcpy(card->driver, \"Atmel AC97C\");\n\tstrcpy(card->shortname, \"Atmel AC97C\");\n\tsprintf(card->longname, \"Atmel AC97 controller\");\n\n\tchip->card = card;\n\tchip->pclk = pclk;\n\tchip->pdev = pdev;\n\tchip->regs = ioremap(regs->start, resource_size(regs));\n\n\tif (!chip->regs) {\n\t\tdev_dbg(&pdev->dev, \"could not remap register memory\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\n\tchip->reset_pin = devm_gpiod_get_index(dev, \"ac97\", 2, GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->reset_pin))\n\t\tdev_dbg(dev, \"reset pin not available\\n\");\n\n\tatmel_ac97c_reset(chip);\n\n\t \n\tac97c_writel(chip, COMR, AC97C_CSR_OVRUN);\n\tac97c_writel(chip, IER, ac97c_readl(chip, IMR) | AC97C_SR_COEVT);\n\n\tretval = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"could not register on ac97 bus\\n\");\n\t\tgoto err_ac97_bus;\n\t}\n\n\tretval = atmel_ac97c_mixer_new(chip);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"could not register ac97 mixer\\n\");\n\t\tgoto err_ac97_bus;\n\t}\n\n\tretval = atmel_ac97c_pcm_new(chip);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"could not register ac97 pcm device\\n\");\n\t\tgoto err_ac97_bus;\n\t}\n\n\tretval = snd_card_register(card);\n\tif (retval) {\n\t\tdev_dbg(&pdev->dev, \"could not register sound card\\n\");\n\t\tgoto err_ac97_bus;\n\t}\n\n\tplatform_set_drvdata(pdev, card);\n\n\tdev_info(&pdev->dev, \"Atmel AC97 controller at 0x%p, irq = %d\\n\",\n\t\t\tchip->regs, irq);\n\n\treturn 0;\n\nerr_ac97_bus:\n\tiounmap(chip->regs);\nerr_ioremap:\n\tfree_irq(irq, chip);\nerr_request_irq:\n\tsnd_card_free(card);\nerr_snd_card_new:\n\tclk_disable_unprepare(pclk);\nerr_prepare_enable:\n\tclk_put(pclk);\n\treturn retval;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atmel_ac97c_suspend(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct atmel_ac97c *chip = card->private_data;\n\n\tclk_disable_unprepare(chip->pclk);\n\treturn 0;\n}\n\nstatic int atmel_ac97c_resume(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct atmel_ac97c *chip = card->private_data;\n\tint ret = clk_prepare_enable(chip->pclk);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(atmel_ac97c_pm, atmel_ac97c_suspend, atmel_ac97c_resume);\n#define ATMEL_AC97C_PM_OPS\t&atmel_ac97c_pm\n#else\n#define ATMEL_AC97C_PM_OPS\tNULL\n#endif\n\nstatic void atmel_ac97c_remove(struct platform_device *pdev)\n{\n\tstruct snd_card *card = platform_get_drvdata(pdev);\n\tstruct atmel_ac97c *chip = get_chip(card);\n\n\tac97c_writel(chip, CAMR, 0);\n\tac97c_writel(chip, COMR, 0);\n\tac97c_writel(chip, MR,   0);\n\n\tclk_disable_unprepare(chip->pclk);\n\tclk_put(chip->pclk);\n\tiounmap(chip->regs);\n\tfree_irq(chip->irq, chip);\n\n\tsnd_card_free(card);\n}\n\nstatic struct platform_driver atmel_ac97c_driver = {\n\t.probe\t\t= atmel_ac97c_probe,\n\t.remove_new\t= atmel_ac97c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_ac97c\",\n\t\t.pm\t= ATMEL_AC97C_PM_OPS,\n\t\t.of_match_table = atmel_ac97c_dt_ids,\n\t},\n};\nmodule_platform_driver(atmel_ac97c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for Atmel AC97 controller\");\nMODULE_AUTHOR(\"Hans-Christian Egtvedt <egtvedt@samfundet.no>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}