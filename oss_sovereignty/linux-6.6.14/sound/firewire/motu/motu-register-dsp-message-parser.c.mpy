{
  "module_name": "motu-register-dsp-message-parser.c",
  "hash_id": "d81a8b3125323cee4d9e08f70b63d7279131d21787f18254642c5a16c8085917",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-register-dsp-message-parser.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"motu.h\"\n\n#define MSG_FLAG_POS                    4\n#define MSG_FLAG_TYPE_MASK              0xf8\n#define MSG_FLAG_MIDI_MASK              0x01\n#define MSG_FLAG_MODEL_SPECIFIC_MASK    0x06\n#define   MSG_FLAG_8PRE                 0x00\n#define   MSG_FLAG_ULTRALITE            0x04\n#define   MSG_FLAG_TRAVELER             0x04\n#define   MSG_FLAG_828MK2               0x04\n#define   MSG_FLAG_896HD                0x04\n#define   MSG_FLAG_4PRE                 0x05 \n#define   MSG_FLAG_AUDIOEXPRESS         0x05 \n#define MSG_FLAG_TYPE_SHIFT             3\n#define MSG_VALUE_POS                   5\n#define MSG_MIDI_BYTE_POS\t\t6\n#define MSG_METER_IDX_POS               7\n\n\n\n#define MSG_METER_IDX_POS_4PRE_AE\t6\n#define MSG_MIDI_BYTE_POS_4PRE_AE\t7\n#define MSG_FLAG_MIDI_POS_4PRE_AE\t8\n\nenum register_dsp_msg_type {\n\t\n\tINVALID = 0x00,\n\tMIXER_SELECT = 0x01,\n\tMIXER_SRC_GAIN = 0x02,\n\tMIXER_SRC_PAN = 0x03,\n\tMIXER_SRC_FLAG = 0x04,\n\tMIXER_OUTPUT_PAIRED_VOLUME = 0x05,\n\tMIXER_OUTPUT_PAIRED_FLAG = 0x06,\n\tMAIN_OUTPUT_PAIRED_VOLUME = 0x07,\n\tHP_OUTPUT_PAIRED_VOLUME = 0x08,\n\tHP_OUTPUT_PAIRED_ASSIGNMENT = 0x09,\n\t\n\tUNKNOWN_0 = 0x0a,\n\t\n\tUNKNOWN_2 = 0x0c,\n\t\n\tLINE_INPUT_BOOST = 0x0d,\n\t\n\tLINE_INPUT_NOMINAL_LEVEL = 0x0e,\n\t\n\tINPUT_GAIN_AND_INVERT = 0x15,\n\t\n\tINPUT_FLAG = 0x16,\n\t\n\tMIXER_SRC_PAIRED_BALANCE = 0x17,\n\t\n\tMIXER_SRC_PAIRED_WIDTH = 0x18,\n\t\n\t\n\t\n\t\n\tMETER = 0x1f,\n};\n\n#define EVENT_QUEUE_SIZE\t16\n\nstruct msg_parser {\n\tspinlock_t lock;\n\tstruct snd_firewire_motu_register_dsp_meter meter;\n\tbool meter_pos_quirk;\n\n\tstruct snd_firewire_motu_register_dsp_parameter param;\n\tu8 prev_mixer_src_type;\n\tu8 mixer_ch;\n\tu8 mixer_src_ch;\n\n\tu8 input_ch;\n\tu8 prev_msg_type;\n\n\tu32 event_queue[EVENT_QUEUE_SIZE];\n\tunsigned int push_pos;\n\tunsigned int pull_pos;\n};\n\nint snd_motu_register_dsp_message_parser_new(struct snd_motu *motu)\n{\n\tstruct msg_parser *parser;\n\tparser = devm_kzalloc(&motu->card->card_dev, sizeof(*parser), GFP_KERNEL);\n\tif (!parser)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&parser->lock);\n\tif (motu->spec == &snd_motu_spec_4pre || motu->spec == &snd_motu_spec_audio_express)\n\t\tparser->meter_pos_quirk = true;\n\tmotu->message_parser = parser;\n\treturn 0;\n}\n\nint snd_motu_register_dsp_message_parser_init(struct snd_motu *motu)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\n\tparser->prev_mixer_src_type = INVALID;\n\tparser->mixer_ch = 0xff;\n\tparser->mixer_src_ch = 0xff;\n\tparser->prev_msg_type = INVALID;\n\n\treturn 0;\n}\n\n\nstatic void queue_event(struct snd_motu *motu, u8 msg_type, u8 identifier0, u8 identifier1, u8 val)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\tunsigned int pos = parser->push_pos;\n\tu32 entry;\n\n\tif (!motu->hwdep || motu->hwdep->used == 0)\n\t\treturn;\n\n\tentry = (msg_type << 24) | (identifier0 << 16) | (identifier1 << 8) | val;\n\tparser->event_queue[pos] = entry;\n\n\t++pos;\n\tif (pos >= EVENT_QUEUE_SIZE)\n\t\tpos = 0;\n\tparser->push_pos = pos;\n}\n\nvoid snd_motu_register_dsp_message_parser_parse(const struct amdtp_stream *s,\n\t\t\t\t\t\tconst struct pkt_desc *desc, unsigned int count)\n{\n\tstruct snd_motu *motu = container_of(s, struct snd_motu, tx_stream);\n\tunsigned int data_block_quadlets = s->data_block_quadlets;\n\tstruct msg_parser *parser = motu->message_parser;\n\tbool meter_pos_quirk = parser->meter_pos_quirk;\n\tunsigned int pos = parser->push_pos;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&parser->lock, flags);\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buffer = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\t\tint j;\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\n\t\tfor (j = 0; j < data_blocks; ++j) {\n\t\t\tu8 *b = (u8 *)buffer;\n\t\t\tu8 msg_type = (b[MSG_FLAG_POS] & MSG_FLAG_TYPE_MASK) >> MSG_FLAG_TYPE_SHIFT;\n\t\t\tu8 val = b[MSG_VALUE_POS];\n\n\t\t\tbuffer += data_block_quadlets;\n\n\t\t\tswitch (msg_type) {\n\t\t\tcase MIXER_SELECT:\n\t\t\t{\n\t\t\t\tu8 mixer_ch = val / 0x20;\n\t\t\t\tif (mixer_ch < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_MIXER_COUNT) {\n\t\t\t\t\tparser->mixer_src_ch = 0;\n\t\t\t\t\tparser->mixer_ch = mixer_ch;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MIXER_SRC_GAIN:\n\t\t\tcase MIXER_SRC_PAN:\n\t\t\tcase MIXER_SRC_FLAG:\n\t\t\tcase MIXER_SRC_PAIRED_BALANCE:\n\t\t\tcase MIXER_SRC_PAIRED_WIDTH:\n\t\t\t{\n\t\t\t\tstruct snd_firewire_motu_register_dsp_parameter *param = &parser->param;\n\t\t\t\tu8 mixer_ch = parser->mixer_ch;\n\t\t\t\tu8 mixer_src_ch = parser->mixer_src_ch;\n\n\t\t\t\tif (msg_type != parser->prev_mixer_src_type)\n\t\t\t\t\tmixer_src_ch = 0;\n\t\t\t\telse\n\t\t\t\t\t++mixer_src_ch;\n\t\t\t\tparser->prev_mixer_src_type = msg_type;\n\n\t\t\t\tif (mixer_ch < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_MIXER_COUNT &&\n\t\t\t\t    mixer_src_ch < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_MIXER_SRC_COUNT) {\n\t\t\t\t\tu8 mixer_ch = parser->mixer_ch;\n\n\t\t\t\t\tswitch (msg_type) {\n\t\t\t\t\tcase MIXER_SRC_GAIN:\n\t\t\t\t\t\tif (param->mixer.source[mixer_ch].gain[mixer_src_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, mixer_src_ch, val);\n\t\t\t\t\t\t\tparam->mixer.source[mixer_ch].gain[mixer_src_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_SRC_PAN:\n\t\t\t\t\t\tif (param->mixer.source[mixer_ch].pan[mixer_src_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, mixer_src_ch, val);\n\t\t\t\t\t\t\tparam->mixer.source[mixer_ch].pan[mixer_src_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_SRC_FLAG:\n\t\t\t\t\t\tif (param->mixer.source[mixer_ch].flag[mixer_src_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, mixer_src_ch, val);\n\t\t\t\t\t\t\tparam->mixer.source[mixer_ch].flag[mixer_src_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_SRC_PAIRED_BALANCE:\n\t\t\t\t\t\tif (param->mixer.source[mixer_ch].paired_balance[mixer_src_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, mixer_src_ch, val);\n\t\t\t\t\t\t\tparam->mixer.source[mixer_ch].paired_balance[mixer_src_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_SRC_PAIRED_WIDTH:\n\t\t\t\t\t\tif (param->mixer.source[mixer_ch].paired_width[mixer_src_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, mixer_src_ch, val);\n\t\t\t\t\t\t\tparam->mixer.source[mixer_ch].paired_width[mixer_src_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tparser->mixer_src_ch = mixer_src_ch;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MIXER_OUTPUT_PAIRED_VOLUME:\n\t\t\tcase MIXER_OUTPUT_PAIRED_FLAG:\n\t\t\t{\n\t\t\t\tstruct snd_firewire_motu_register_dsp_parameter *param = &parser->param;\n\t\t\t\tu8 mixer_ch = parser->mixer_ch;\n\n\t\t\t\tif (mixer_ch < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_MIXER_COUNT) {\n\t\t\t\t\tswitch (msg_type) {\n\t\t\t\t\tcase MIXER_OUTPUT_PAIRED_VOLUME:\n\t\t\t\t\t\tif (param->mixer.output.paired_volume[mixer_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, 0, val);\n\t\t\t\t\t\t\tparam->mixer.output.paired_volume[mixer_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MIXER_OUTPUT_PAIRED_FLAG:\n\t\t\t\t\t\tif (param->mixer.output.paired_flag[mixer_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, mixer_ch, 0, val);\n\t\t\t\t\t\t\tparam->mixer.output.paired_flag[mixer_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MAIN_OUTPUT_PAIRED_VOLUME:\n\t\t\t\tif (parser->param.output.main_paired_volume != val) {\n\t\t\t\t\tqueue_event(motu, msg_type, 0, 0, val);\n\t\t\t\t\tparser->param.output.main_paired_volume = val;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HP_OUTPUT_PAIRED_VOLUME:\n\t\t\t\tif (parser->param.output.hp_paired_volume != val) {\n\t\t\t\t\tqueue_event(motu, msg_type, 0, 0, val);\n\t\t\t\t\tparser->param.output.hp_paired_volume = val;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HP_OUTPUT_PAIRED_ASSIGNMENT:\n\t\t\t\tif (parser->param.output.hp_paired_assignment != val) {\n\t\t\t\t\tqueue_event(motu, msg_type, 0, 0, val);\n\t\t\t\t\tparser->param.output.hp_paired_assignment = val;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LINE_INPUT_BOOST:\n\t\t\t\tif (parser->param.line_input.boost_flag != val) {\n\t\t\t\t\tqueue_event(motu, msg_type, 0, 0, val);\n\t\t\t\t\tparser->param.line_input.boost_flag = val;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LINE_INPUT_NOMINAL_LEVEL:\n\t\t\t\tif (parser->param.line_input.nominal_level_flag != val) {\n\t\t\t\t\tqueue_event(motu, msg_type, 0, 0, val);\n\t\t\t\t\tparser->param.line_input.nominal_level_flag = val;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INPUT_GAIN_AND_INVERT:\n\t\t\tcase INPUT_FLAG:\n\t\t\t{\n\t\t\t\tstruct snd_firewire_motu_register_dsp_parameter *param = &parser->param;\n\t\t\t\tu8 input_ch = parser->input_ch;\n\n\t\t\t\tif (parser->prev_msg_type != msg_type)\n\t\t\t\t\tinput_ch = 0;\n\t\t\t\telse\n\t\t\t\t\t++input_ch;\n\n\t\t\t\tif (input_ch < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_INPUT_COUNT) {\n\t\t\t\t\tswitch (msg_type) {\n\t\t\t\t\tcase INPUT_GAIN_AND_INVERT:\n\t\t\t\t\t\tif (param->input.gain_and_invert[input_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, input_ch, 0, val);\n\t\t\t\t\t\t\tparam->input.gain_and_invert[input_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase INPUT_FLAG:\n\t\t\t\t\t\tif (param->input.flag[input_ch] != val) {\n\t\t\t\t\t\t\tqueue_event(motu, msg_type, input_ch, 0, val);\n\t\t\t\t\t\t\tparam->input.flag[input_ch] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tparser->input_ch = input_ch;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UNKNOWN_0:\n\t\t\tcase UNKNOWN_2:\n\t\t\t\tbreak;\n\t\t\tcase METER:\n\t\t\t{\n\t\t\t\tu8 pos;\n\n\t\t\t\tif (!meter_pos_quirk)\n\t\t\t\t\tpos = b[MSG_METER_IDX_POS];\n\t\t\t\telse\n\t\t\t\t\tpos = b[MSG_METER_IDX_POS_4PRE_AE];\n\n\t\t\t\tif (pos < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_METER_INPUT_COUNT) {\n\t\t\t\t\tparser->meter.data[pos] = val;\n\t\t\t\t} else if (pos >= 0x80) {\n\t\t\t\t\tpos -= (0x80 - SNDRV_FIREWIRE_MOTU_REGISTER_DSP_METER_INPUT_COUNT);\n\n\t\t\t\t\tif (pos < SNDRV_FIREWIRE_MOTU_REGISTER_DSP_METER_COUNT)\n\t\t\t\t\t\tparser->meter.data[pos] = val;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfallthrough;\n\t\t\t}\n\t\t\tcase INVALID:\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tparser->prev_msg_type = msg_type;\n\t\t}\n\t}\n\n\tif (pos != parser->push_pos)\n\t\twake_up(&motu->hwdep_wait);\n\n\tspin_unlock_irqrestore(&parser->lock, flags);\n}\n\nvoid snd_motu_register_dsp_message_parser_copy_meter(struct snd_motu *motu,\n\t\t\t\t\t\tstruct snd_firewire_motu_register_dsp_meter *meter)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&parser->lock, flags);\n\tmemcpy(meter, &parser->meter, sizeof(*meter));\n\tspin_unlock_irqrestore(&parser->lock, flags);\n}\n\nvoid snd_motu_register_dsp_message_parser_copy_parameter(struct snd_motu *motu,\n\t\t\t\t\tstruct snd_firewire_motu_register_dsp_parameter *param)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&parser->lock, flags);\n\tmemcpy(param, &parser->param, sizeof(*param));\n\tspin_unlock_irqrestore(&parser->lock, flags);\n}\n\nunsigned int snd_motu_register_dsp_message_parser_count_event(struct snd_motu *motu)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\n\tif (parser->pull_pos > parser->push_pos)\n\t\treturn EVENT_QUEUE_SIZE - parser->pull_pos + parser->push_pos;\n\telse\n\t\treturn parser->push_pos - parser->pull_pos;\n}\n\nbool snd_motu_register_dsp_message_parser_copy_event(struct snd_motu *motu, u32 *event)\n{\n\tstruct msg_parser *parser = motu->message_parser;\n\tunsigned int pos = parser->pull_pos;\n\tunsigned long flags;\n\n\tif (pos == parser->push_pos)\n\t\treturn false;\n\n\tspin_lock_irqsave(&parser->lock, flags);\n\n\t*event = parser->event_queue[pos];\n\n\t++pos;\n\tif (pos >= EVENT_QUEUE_SIZE)\n\t\tpos = 0;\n\tparser->pull_pos = pos;\n\n\tspin_unlock_irqrestore(&parser->lock, flags);\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}