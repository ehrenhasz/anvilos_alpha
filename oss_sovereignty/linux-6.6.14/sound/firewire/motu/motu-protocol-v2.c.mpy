{
  "module_name": "motu-protocol-v2.c",
  "hash_id": "aa539fdfb47889c8416dd96e8f2ce30bf8860ca730d2a5ca7974dac598ac06d8",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-protocol-v2.c",
  "human_readable_source": "\n \n\n#include \"motu.h\"\n\n#define V2_CLOCK_STATUS_OFFSET\t\t\t0x0b14\n#define  V2_CLOCK_RATE_MASK\t\t\t0x00000038\n#define  V2_CLOCK_RATE_SHIFT\t\t\t3\n#define  V2_CLOCK_SRC_MASK\t\t\t0x00000007\n#define  V2_CLOCK_SRC_SHIFT\t\t\t0\n#define   V2_CLOCK_SRC_AESEBU_ON_XLR\t\t0x07\t\n#define   V2_CLOCK_SRC_ADAT_ON_DSUB\t\t0x05\n#define   V2_CLOCK_SRC_WORD_ON_BNC\t\t0x04\n#define   V2_CLOCK_SRC_SPH\t\t\t0x03\n#define   V2_CLOCK_SRC_SPDIF\t\t\t0x02\t\n#define   V2_CLOCK_SRC_ADAT_ON_OPT\t\t0x01\n#define   V2_CLOCK_SRC_INTERNAL\t\t\t0x00\n#define  V2_CLOCK_FETCH_ENABLE\t\t\t0x02000000\n#define  V2_CLOCK_MODEL_SPECIFIC\t\t0x04000000\n\n#define V2_IN_OUT_CONF_OFFSET\t\t\t0x0c04\n#define  V2_OPT_OUT_IFACE_MASK\t\t\t0x00000c00\n#define  V2_OPT_OUT_IFACE_SHIFT\t\t\t10\n#define  V2_OPT_IN_IFACE_MASK\t\t\t0x00000300\n#define  V2_OPT_IN_IFACE_SHIFT\t\t\t8\n#define  V2_OPT_IFACE_MODE_NONE\t\t\t0\n#define  V2_OPT_IFACE_MODE_ADAT\t\t\t1\n#define  V2_OPT_IFACE_MODE_SPDIF\t\t2\n\nstatic int get_clock_rate(u32 data, unsigned int *rate)\n{\n\tunsigned int index = (data & V2_CLOCK_RATE_MASK) >> V2_CLOCK_RATE_SHIFT;\n\tif (index >= ARRAY_SIZE(snd_motu_clock_rates))\n\t\treturn -EIO;\n\n\t*rate = snd_motu_clock_rates[index];\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v2_get_clock_rate(struct snd_motu *motu,\n\t\t\t\t\tunsigned int *rate)\n{\n\t__be32 reg;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn get_clock_rate(be32_to_cpu(reg), rate);\n}\n\nint snd_motu_protocol_v2_set_clock_rate(struct snd_motu *motu,\n\t\t\t\t\tunsigned int rate)\n{\n\t__be32 reg;\n\tu32 data;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {\n\t\tif (snd_motu_clock_rates[i] == rate)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(snd_motu_clock_rates))\n\t\treturn -EINVAL;\n\n\terr = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tdata &= ~V2_CLOCK_RATE_MASK;\n\tdata |= i << V2_CLOCK_RATE_SHIFT;\n\n\treg = cpu_to_be32(data);\n\treturn snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\t  sizeof(reg));\n}\n\nstatic int get_clock_source(struct snd_motu *motu, u32 data,\n\t\t\t    enum snd_motu_clock_source *src)\n{\n\tswitch (data & V2_CLOCK_SRC_MASK) {\n\tcase V2_CLOCK_SRC_INTERNAL:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;\n\t\tbreak;\n\tcase V2_CLOCK_SRC_ADAT_ON_OPT:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT;\n\t\tbreak;\n\tcase V2_CLOCK_SRC_SPDIF:\n\t{\n\t\tbool support_iec60958_on_opt = (motu->spec == &snd_motu_spec_828mk2 ||\n\t\t\t\t\t\tmotu->spec == &snd_motu_spec_traveler);\n\n\t\tif (motu->spec == &snd_motu_spec_896hd) {\n\t\t\t*src = SND_MOTU_CLOCK_SOURCE_AESEBU_ON_XLR;\n\t\t} else if (!support_iec60958_on_opt) {\n\t\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;\n\t\t} else {\n\t\t\t__be32 reg;\n\n\t\t\t\n\t\t\tint err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,\n\t\t\t\t\t\t\t    sizeof(reg));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tif (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) ==\n\t\t\t    V2_OPT_IFACE_MODE_SPDIF)\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT;\n\t\t\telse\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;\n\t\t}\n\t\tbreak;\n\t}\n\tcase V2_CLOCK_SRC_SPH:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_SPH;\n\t\tbreak;\n\tcase V2_CLOCK_SRC_WORD_ON_BNC:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;\n\t\tbreak;\n\tcase V2_CLOCK_SRC_ADAT_ON_DSUB:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_DSUB;\n\t\tbreak;\n\tcase V2_CLOCK_SRC_AESEBU_ON_XLR:\n\t\t\n\t\t*src = SND_MOTU_CLOCK_SOURCE_AESEBU_ON_XLR;\n\t\tbreak;\n\tdefault:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,\n\t\t\t\t\t  enum snd_motu_clock_source *src)\n{\n\t__be32 reg;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn get_clock_source(motu, be32_to_cpu(reg), src);\n}\n\n\nstatic int switch_fetching_mode_cyclone(struct snd_motu *motu, u32 *data,\n\t\t\t\t\tbool enable)\n{\n\t*data |= V2_CLOCK_MODEL_SPECIFIC;\n\n\treturn 0;\n}\n\n\nstatic int switch_fetching_mode_spartan(struct snd_motu *motu, u32 *data,\n\t\t\t\t\tbool enable)\n{\n\tunsigned int rate;\n\tenum snd_motu_clock_source src;\n\tint err;\n\n\terr = get_clock_source(motu, *data, &src);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_clock_rate(*data, &rate);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)\n\t\t*data |= V2_CLOCK_MODEL_SPECIFIC;\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,\n\t\t\t\t\t      bool enable)\n{\n\tif (motu->spec == &snd_motu_spec_828mk2) {\n\t\t\n\t\treturn 0;\n\t} else if (motu->spec == &snd_motu_spec_896hd) {\n\t\t\n\t\treturn 0;\n\t} else {\n\t\t__be32 reg;\n\t\tu32 data;\n\t\tint err;\n\n\t\terr = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,\n\t\t\t\t\t\t&reg, sizeof(reg));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata = be32_to_cpu(reg);\n\n\t\tdata &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);\n\t\tif (enable)\n\t\t\tdata |= V2_CLOCK_FETCH_ENABLE;\n\n\t\tif (motu->spec == &snd_motu_spec_traveler)\n\t\t\terr = switch_fetching_mode_cyclone(motu, &data, enable);\n\t\telse\n\t\t\terr = switch_fetching_mode_spartan(motu, &data, enable);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\treg = cpu_to_be32(data);\n\t\treturn snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,\n\t\t\t\t\t\t  &reg, sizeof(reg));\n\t}\n}\n\nint snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)\n{\n\tbool has_two_opt_ifaces = (motu->spec == &snd_motu_spec_8pre);\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\tmotu->tx_packet_formats.pcm_byte_offset = 10;\n\tmotu->rx_packet_formats.pcm_byte_offset = 10;\n\n\tmotu->tx_packet_formats.msg_chunks = 2;\n\tmotu->rx_packet_formats.msg_chunks = 2;\n\n\terr = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tmemcpy(motu->tx_packet_formats.pcm_chunks,\n\t       motu->spec->tx_fixed_pcm_chunks,\n\t       sizeof(motu->tx_packet_formats.pcm_chunks));\n\tmemcpy(motu->rx_packet_formats.pcm_chunks,\n\t       motu->spec->rx_fixed_pcm_chunks,\n\t       sizeof(motu->rx_packet_formats.pcm_chunks));\n\n\tif (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) == V2_OPT_IFACE_MODE_ADAT) {\n\t\tmotu->tx_packet_formats.pcm_chunks[0] += 8;\n\n\t\tif (!has_two_opt_ifaces)\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 4;\n\t\telse\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 8;\n\t}\n\n\tif (((data & V2_OPT_OUT_IFACE_MASK) >> V2_OPT_OUT_IFACE_SHIFT) == V2_OPT_IFACE_MODE_ADAT) {\n\t\tmotu->rx_packet_formats.pcm_chunks[0] += 8;\n\n\t\tif (!has_two_opt_ifaces)\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 4;\n\t\telse\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 8;\n\t}\n\n\treturn 0;\n}\n\nconst struct snd_motu_spec snd_motu_spec_828mk2 = {\n\t.name = \"828mk2\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V2,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {14, 14, 0},\n\t.rx_fixed_pcm_chunks = {14, 14, 0},\n};\n\nconst struct snd_motu_spec snd_motu_spec_896hd = {\n\t.name = \"896HD\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V2,\n\t.flags = SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {14, 14, 8},\n\t.rx_fixed_pcm_chunks = {14, 14, 8},\n};\n\nconst struct snd_motu_spec snd_motu_spec_traveler = {\n\t.name = \"Traveler\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V2,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {14, 14, 8},\n\t.rx_fixed_pcm_chunks = {14, 14, 8},\n};\n\nconst struct snd_motu_spec snd_motu_spec_ultralite = {\n\t.name = \"UltraLite\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V2,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {14, 14, 0},\n\t.rx_fixed_pcm_chunks = {14, 14, 0},\n};\n\nconst struct snd_motu_spec snd_motu_spec_8pre = {\n\t.name = \"8pre\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V2,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_REGISTER_DSP,\n\t\n\t.tx_fixed_pcm_chunks = {10, 10, 0},\n\t.rx_fixed_pcm_chunks = {6, 6, 0},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}