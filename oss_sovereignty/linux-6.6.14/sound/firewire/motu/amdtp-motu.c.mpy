{
  "module_name": "amdtp-motu.c",
  "hash_id": "4760e4abe35d436a352a049c5ec0d57e393177b4f81b330d42dd749130a8d290",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/amdtp-motu.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include \"motu.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"amdtp-motu-trace.h\"\n\n#define CIP_FMT_MOTU\t\t0x02\n#define CIP_FMT_MOTU_TX_V3\t0x22\n#define MOTU_FDF_AM824\t\t0x22\n\n#define TICKS_PER_CYCLE\t\t3072\n#define CYCLES_PER_SECOND\t8000\n#define TICKS_PER_SECOND\t(TICKS_PER_CYCLE * CYCLES_PER_SECOND)\n\n#define CIP_SPH_CYCLE_SHIFT\t12\n#define CIP_SPH_CYCLE_MASK\t0x01fff000\n#define CIP_SPH_OFFSET_MASK\t0x00000fff\n\n \n#define MIDI_BYTES_PER_SECOND\t3093\n\nstruct amdtp_motu {\n\tunsigned int pcm_chunks;\n\tunsigned int pcm_byte_offset;\n\n\tstruct snd_rawmidi_substream *midi;\n\tunsigned int midi_ports;\n\tunsigned int midi_flag_offset;\n\tunsigned int midi_byte_offset;\n\n\tint midi_db_count;\n\tunsigned int midi_db_interval;\n\n\tstruct amdtp_motu_cache *cache;\n};\n\nint amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,\n\t\t\t      unsigned int midi_ports,\n\t\t\t      struct snd_motu_packet_format *formats)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tunsigned int pcm_chunks, data_chunks, data_block_quadlets;\n\tunsigned int mode;\n\tint i, err;\n\n\tif (amdtp_stream_running(s))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {\n\t\tif (snd_motu_clock_rates[i] == rate) {\n\t\t\tmode = i >> 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(snd_motu_clock_rates))\n\t\treturn -EINVAL;\n\n\t\n\t\n\t\n\tpcm_chunks = formats->pcm_chunks[mode];\n\tdata_chunks = formats->msg_chunks + pcm_chunks;\n\tdata_block_quadlets = 1 + DIV_ROUND_UP(data_chunks * 3, 4);\n\n\terr = amdtp_stream_set_parameters(s, rate, data_block_quadlets, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tp->pcm_chunks = pcm_chunks;\n\tp->pcm_byte_offset = formats->pcm_byte_offset;\n\n\tp->midi_ports = midi_ports;\n\tp->midi_flag_offset = formats->midi_flag_offset;\n\tp->midi_byte_offset = formats->midi_byte_offset;\n\n\tp->midi_db_count = 0;\n\tp->midi_db_interval = rate / MIDI_BYTES_PER_SECOND;\n\n\treturn 0;\n}\n\nstatic void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t __be32 *buffer, unsigned int data_blocks,\n\t\t\t unsigned int pcm_frames)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tunsigned int channels = p->pcm_chunks;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tu8 *byte;\n\tu32 *dst;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tdst = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tbyte = (u8 *)buffer + p->pcm_byte_offset;\n\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t*dst = (byte[0] << 24) |\n\t\t\t       (byte[1] << 16) |\n\t\t\t       (byte[2] << 8);\n\t\t\tbyte += 3;\n\t\t\tdst++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tdst = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t  __be32 *buffer, unsigned int data_blocks,\n\t\t\t  unsigned int pcm_frames)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tunsigned int channels = p->pcm_chunks;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tu8 *byte;\n\tconst u32 *src;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tsrc = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tbyte = (u8 *)buffer + p->pcm_byte_offset;\n\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\tbyte[0] = (*src >> 24) & 0xff;\n\t\t\tbyte[1] = (*src >> 16) & 0xff;\n\t\t\tbyte[2] = (*src >>  8) & 0xff;\n\t\t\tbyte += 3;\n\t\t\tsrc++;\n\t\t}\n\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tsrc = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t      unsigned int data_blocks)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tunsigned int channels, i, c;\n\tu8 *byte;\n\n\tchannels = p->pcm_chunks;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tbyte = (u8 *)buffer + p->pcm_byte_offset;\n\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\tbyte[0] = 0;\n\t\t\tbyte[1] = 0;\n\t\t\tbyte[2] = 0;\n\t\t\tbyte += 3;\n\t\t}\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nint amdtp_motu_add_pcm_hw_constraints(struct amdtp_stream *s,\n\t\t\t\t      struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\t \n\terr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn amdtp_stream_add_pcm_hw_constraints(s, runtime);\n}\n\nvoid amdtp_motu_midi_trigger(struct amdtp_stream *s, unsigned int port,\n\t\t\t     struct snd_rawmidi_substream *midi)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\n\tif (port < p->midi_ports)\n\t\tWRITE_ONCE(p->midi, midi);\n}\n\nstatic void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t\tunsigned int data_blocks)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tstruct snd_rawmidi_substream *midi = READ_ONCE(p->midi);\n\tu8 *b;\n\tint i;\n\n\tfor (i = 0; i < data_blocks; i++) {\n\t\tb = (u8 *)buffer;\n\n\t\tif (midi && p->midi_db_count == 0 &&\n\t\t    snd_rawmidi_transmit(midi, b + p->midi_byte_offset, 1) == 1) {\n\t\t\tb[p->midi_flag_offset] = 0x01;\n\t\t} else {\n\t\t\tb[p->midi_byte_offset] = 0x00;\n\t\t\tb[p->midi_flag_offset] = 0x00;\n\t\t}\n\n\t\tbuffer += s->data_block_quadlets;\n\n\t\tif (--p->midi_db_count < 0)\n\t\t\tp->midi_db_count = p->midi_db_interval;\n\t}\n}\n\nstatic void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t       unsigned int data_blocks)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tstruct snd_rawmidi_substream *midi;\n\tu8 *b;\n\tint i;\n\n\tfor (i = 0; i < data_blocks; i++) {\n\t\tb = (u8 *)buffer;\n\t\tmidi = READ_ONCE(p->midi);\n\n\t\tif (midi && (b[p->midi_flag_offset] & 0x01))\n\t\t\tsnd_rawmidi_receive(midi, b + p->midi_byte_offset, 1);\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\n \nstatic void __maybe_unused copy_sph(u32 *frames, __be32 *buffer,\n\t\t\t\t    unsigned int data_blocks,\n\t\t\t\t    unsigned int data_block_quadlets)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\t*frames = be32_to_cpu(*buffer);\n\t\tbuffer += data_block_quadlets;\n\t\tframes++;\n\t}\n}\n\n \nstatic void __maybe_unused copy_message(u64 *frames, __be32 *buffer,\n\t\t\t\t\tunsigned int data_blocks,\n\t\t\t\t\tunsigned int data_block_quadlets)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < data_blocks; ++i) {\n\t\t*frames = be32_to_cpu(buffer[1]);\n\t\t*frames <<= 16;\n\t\t*frames |= be32_to_cpu(buffer[2]) >> 16;\n\t\t++frames;\n\t\tbuffer += data_block_quadlets;\n\t}\n}\n\nstatic void probe_tracepoints_events(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t     unsigned int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\ttrace_data_block_sph(s, data_blocks, buf);\n\t\ttrace_data_block_message(s, data_blocks, buf);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nstatic void cache_event_offsets(struct amdtp_motu_cache *cache, const __be32 *buf,\n\t\t\t\tunsigned int data_blocks, unsigned int data_block_quadlets)\n{\n\tunsigned int *event_offsets = cache->event_offsets;\n\tconst unsigned int cache_size = cache->size;\n\tunsigned int cache_tail = cache->tail;\n\tunsigned int base_tick = cache->tx_cycle_count * TICKS_PER_CYCLE;\n\tint i;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tu32 sph = be32_to_cpu(*buf);\n\t\tunsigned int tick;\n\n\t\ttick = ((sph & CIP_SPH_CYCLE_MASK) >> CIP_SPH_CYCLE_SHIFT) * TICKS_PER_CYCLE +\n\t\t       (sph & CIP_SPH_OFFSET_MASK);\n\n\t\tif (tick < base_tick)\n\t\t\ttick += TICKS_PER_SECOND;\n\t\tevent_offsets[cache_tail] = tick - base_tick;\n\n\t\tcache_tail = (cache_tail + 1) % cache_size;\n\t\tbuf += data_block_quadlets;\n\t}\n\n\tcache->tail = cache_tail;\n\tcache->tx_cycle_count = (cache->tx_cycle_count + 1) % CYCLES_PER_SECOND;\n}\n\nstatic void process_ir_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tstruct snd_motu *motu = container_of(s, struct snd_motu, tx_stream);\n\tstruct amdtp_motu *p = s->protocol;\n\tconst struct pkt_desc *cursor = desc;\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tif (p->cache->tx_cycle_count == UINT_MAX)\n\t\tp->cache->tx_cycle_count = (s->domain->processing_cycle.tx_start % CYCLES_PER_SECOND);\n\n\t\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tcache_event_offsets(p->cache, buf, data_blocks, s->data_block_quadlets);\n\n\t\tif (pcm) {\n\t\t\tread_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t}\n\n\t\tif (p->midi_ports)\n\t\t\tread_midi_messages(s, buf, data_blocks);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n\n\tdesc = cursor;\n\tif (motu->spec->flags & SND_MOTU_SPEC_REGISTER_DSP)\n\t\tsnd_motu_register_dsp_message_parser_parse(s, desc, count);\n\telse if (motu->spec->flags & SND_MOTU_SPEC_COMMAND_DSP)\n\t\tsnd_motu_command_dsp_message_parser_parse(s, desc, count);\n\n\t\n\tif (trace_data_block_sph_enabled() ||\n\t    trace_data_block_message_enabled())\n\t\tprobe_tracepoints_events(s, desc, count);\n}\n\nstatic void write_sph(struct amdtp_motu_cache *cache, __be32 *buffer, unsigned int data_blocks,\n\t\t      unsigned int data_block_quadlets)\n{\n\tunsigned int *event_offsets = cache->event_offsets;\n\tconst unsigned int cache_size = cache->size;\n\tunsigned int cache_head = cache->head;\n\tunsigned int base_tick = cache->rx_cycle_count * TICKS_PER_CYCLE;\n\tint i;\n\n\tfor (i = 0; i < data_blocks; i++) {\n\t\tunsigned int tick = (base_tick + event_offsets[cache_head]) % TICKS_PER_SECOND;\n\t\tu32 sph = ((tick / TICKS_PER_CYCLE) << CIP_SPH_CYCLE_SHIFT) | (tick % TICKS_PER_CYCLE);\n\t\t*buffer = cpu_to_be32(sph);\n\n\t\tcache_head = (cache_head + 1) % cache_size;\n\t\tbuffer += data_block_quadlets;\n\t}\n\n\tcache->head = cache_head;\n\tcache->rx_cycle_count = (cache->rx_cycle_count + 1) % CYCLES_PER_SECOND;\n}\n\nstatic void process_it_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tstruct amdtp_motu *p = s->protocol;\n\tconst struct pkt_desc *cursor = desc;\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tif (p->cache->rx_cycle_count == UINT_MAX)\n\t\tp->cache->rx_cycle_count = (s->domain->processing_cycle.rx_start % CYCLES_PER_SECOND);\n\n\t\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\twrite_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t} else {\n\t\t\twrite_pcm_silence(s, buf, data_blocks);\n\t\t}\n\n\t\tif (p->midi_ports)\n\t\t\twrite_midi_messages(s, buf, data_blocks);\n\n\t\twrite_sph(p->cache, buf, data_blocks, s->data_block_quadlets);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n\n\tdesc = cursor;\n\n\t\n\tif (trace_data_block_sph_enabled() ||\n\t    trace_data_block_message_enabled())\n\t\tprobe_tracepoints_events(s, desc, count);\n}\n\nint amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,\n\t\t    enum amdtp_stream_direction dir,\n\t\t    const struct snd_motu_spec *spec, struct amdtp_motu_cache *cache)\n{\n\tamdtp_stream_process_ctx_payloads_t process_ctx_payloads;\n\tint fmt = CIP_FMT_MOTU;\n\tunsigned int flags = CIP_BLOCKING | CIP_UNAWARE_SYT;\n\tstruct amdtp_motu *p;\n\tint err;\n\n\tif (dir == AMDTP_IN_STREAM) {\n\t\tprocess_ctx_payloads = process_ir_ctx_payloads;\n\n\t\t \n\t\tif (spec->protocol_version == SND_MOTU_PROTOCOL_V3) {\n\t\t\tflags |= CIP_WRONG_DBS |\n\t\t\t\t CIP_SKIP_DBC_ZERO_CHECK |\n\t\t\t\t CIP_HEADER_WITHOUT_EOH;\n\t\t\tfmt = CIP_FMT_MOTU_TX_V3;\n\t\t}\n\n\t\tif (spec == &snd_motu_spec_8pre ||\n\t\t    spec == &snd_motu_spec_ultralite) {\n\t\t\t\n\t\t\tflags |= CIP_WRONG_DBS |\n\t\t\t\t CIP_SKIP_DBC_ZERO_CHECK;\n\t\t}\n\t} else {\n\t\tprocess_ctx_payloads = process_it_ctx_payloads;\n\t\tflags |= CIP_DBC_IS_END_EVENT;\n\t}\n\n\terr = amdtp_stream_init(s, unit, dir, flags, fmt, process_ctx_payloads,\n\t\t\t\tsizeof(struct amdtp_motu));\n\tif (err < 0)\n\t\treturn err;\n\n\ts->sph = 1;\n\n\tif (dir == AMDTP_OUT_STREAM) {\n\t\t\n\t\ts->ctx_data.rx.fdf = MOTU_FDF_AM824;\n\t}\n\n\tp = s->protocol;\n\tp->cache = cache;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}