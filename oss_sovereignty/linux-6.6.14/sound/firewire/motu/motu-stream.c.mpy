{
  "module_name": "motu-stream.c",
  "hash_id": "2c495facebcc49aee39ed405dec86d941de4785add816515f46c13359bb55e58",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-stream.c",
  "human_readable_source": "\n \n\n#include \"motu.h\"\n\n#define\tREADY_TIMEOUT_MS\t200\n\n#define ISOC_COMM_CONTROL_OFFSET\t\t0x0b00\n#define  ISOC_COMM_CONTROL_MASK\t\t\t0xffff0000\n#define  CHANGE_RX_ISOC_COMM_STATE\t\t0x80000000\n#define  RX_ISOC_COMM_IS_ACTIVATED\t\t0x40000000\n#define  RX_ISOC_COMM_CHANNEL_MASK\t\t0x3f000000\n#define  RX_ISOC_COMM_CHANNEL_SHIFT\t\t24\n#define  CHANGE_TX_ISOC_COMM_STATE\t\t0x00800000\n#define  TX_ISOC_COMM_IS_ACTIVATED\t\t0x00400000\n#define  TX_ISOC_COMM_CHANNEL_MASK\t\t0x003f0000\n#define  TX_ISOC_COMM_CHANNEL_SHIFT\t\t16\n\n#define PACKET_FORMAT_OFFSET\t\t\t0x0b10\n#define  TX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS\t0x00000080\n#define  RX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS\t0x00000040\n#define  TX_PACKET_TRANSMISSION_SPEED_MASK\t0x0000000f\n\nstatic int keep_resources(struct snd_motu *motu, unsigned int rate,\n\t\t\t  struct amdtp_stream *stream)\n{\n\tstruct fw_iso_resources *resources;\n\tstruct snd_motu_packet_format *packet_format;\n\tunsigned int midi_ports = 0;\n\tint err;\n\n\tif (stream == &motu->rx_stream) {\n\t\tresources = &motu->rx_resources;\n\t\tpacket_format = &motu->rx_packet_formats;\n\n\t\tif ((motu->spec->flags & SND_MOTU_SPEC_RX_MIDI_2ND_Q) ||\n\t\t    (motu->spec->flags & SND_MOTU_SPEC_RX_MIDI_3RD_Q))\n\t\t\tmidi_ports = 1;\n\t} else {\n\t\tresources = &motu->tx_resources;\n\t\tpacket_format = &motu->tx_packet_formats;\n\n\t\tif ((motu->spec->flags & SND_MOTU_SPEC_TX_MIDI_2ND_Q) ||\n\t\t    (motu->spec->flags & SND_MOTU_SPEC_TX_MIDI_3RD_Q))\n\t\t\tmidi_ports = 1;\n\t}\n\n\terr = amdtp_motu_set_parameters(stream, rate, midi_ports,\n\t\t\t\t\tpacket_format);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn fw_iso_resources_allocate(resources,\n\t\t\t\tamdtp_stream_get_max_payload(stream),\n\t\t\t\tfw_parent_device(motu->unit)->max_speed);\n}\n\nstatic int begin_session(struct snd_motu *motu)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\t\n\terr = snd_motu_transaction_read(motu, ISOC_COMM_CONTROL_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg) & ~ISOC_COMM_CONTROL_MASK;\n\n\tdata |= CHANGE_RX_ISOC_COMM_STATE | RX_ISOC_COMM_IS_ACTIVATED |\n\t\t(motu->rx_resources.channel << RX_ISOC_COMM_CHANNEL_SHIFT) |\n\t\tCHANGE_TX_ISOC_COMM_STATE | TX_ISOC_COMM_IS_ACTIVATED |\n\t\t(motu->tx_resources.channel << TX_ISOC_COMM_CHANNEL_SHIFT);\n\n\treg = cpu_to_be32(data);\n\treturn snd_motu_transaction_write(motu, ISOC_COMM_CONTROL_OFFSET, &reg,\n\t\t\t\t\t  sizeof(reg));\n}\n\nstatic void finish_session(struct snd_motu *motu)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_motu_protocol_switch_fetching_mode(motu, false);\n\tif (err < 0)\n\t\treturn;\n\n\terr = snd_motu_transaction_read(motu, ISOC_COMM_CONTROL_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn;\n\tdata = be32_to_cpu(reg);\n\n\tdata &= ~(RX_ISOC_COMM_IS_ACTIVATED | TX_ISOC_COMM_IS_ACTIVATED);\n\tdata |= CHANGE_RX_ISOC_COMM_STATE | CHANGE_TX_ISOC_COMM_STATE;\n\n\treg = cpu_to_be32(data);\n\tsnd_motu_transaction_write(motu, ISOC_COMM_CONTROL_OFFSET, &reg,\n\t\t\t\t   sizeof(reg));\n}\n\nint snd_motu_stream_cache_packet_formats(struct snd_motu *motu)\n{\n\tint err;\n\n\terr = snd_motu_protocol_cache_packet_formats(motu);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (motu->spec->flags & SND_MOTU_SPEC_TX_MIDI_2ND_Q) {\n\t\tmotu->tx_packet_formats.midi_flag_offset = 4;\n\t\tmotu->tx_packet_formats.midi_byte_offset = 6;\n\t} else if (motu->spec->flags & SND_MOTU_SPEC_TX_MIDI_3RD_Q) {\n\t\tmotu->tx_packet_formats.midi_flag_offset = 8;\n\t\tmotu->tx_packet_formats.midi_byte_offset = 7;\n\t}\n\n\tif (motu->spec->flags & SND_MOTU_SPEC_RX_MIDI_2ND_Q) {\n\t\tmotu->rx_packet_formats.midi_flag_offset = 4;\n\t\tmotu->rx_packet_formats.midi_byte_offset = 6;\n\t} else if (motu->spec->flags & SND_MOTU_SPEC_RX_MIDI_3RD_Q) {\n\t\tmotu->rx_packet_formats.midi_flag_offset = 8;\n\t\tmotu->rx_packet_formats.midi_byte_offset = 7;\n\t}\n\n\treturn 0;\n}\n\nint snd_motu_stream_reserve_duplex(struct snd_motu *motu, unsigned int rate,\n\t\t\t\t   unsigned int frames_per_period,\n\t\t\t\t   unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\terr = snd_motu_protocol_get_clock_rate(motu, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0)\n\t\trate = curr_rate;\n\n\tif (motu->substreams_counter == 0 || curr_rate != rate) {\n\t\tamdtp_domain_stop(&motu->domain);\n\t\tfinish_session(motu);\n\n\t\tfw_iso_resources_free(&motu->tx_resources);\n\t\tfw_iso_resources_free(&motu->rx_resources);\n\n\t\tkfree(motu->cache.event_offsets);\n\t\tmotu->cache.event_offsets = NULL;\n\n\t\terr = snd_motu_protocol_set_clock_rate(motu, rate);\n\t\tif (err < 0) {\n\t\t\tdev_err(&motu->unit->device,\n\t\t\t\t\"fail to set sampling rate: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = snd_motu_stream_cache_packet_formats(motu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(motu, rate, &motu->tx_stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(motu, rate, &motu->rx_stream);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&motu->tx_resources);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&motu->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&motu->tx_resources);\n\t\t\tfw_iso_resources_free(&motu->rx_resources);\n\t\t\treturn err;\n\t\t}\n\n\t\tmotu->cache.size = motu->tx_stream.syt_interval * frames_per_buffer;\n\t\tmotu->cache.event_offsets = kcalloc(motu->cache.size, sizeof(*motu->cache.event_offsets),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!motu->cache.event_offsets) {\n\t\t\tfw_iso_resources_free(&motu->tx_resources);\n\t\t\tfw_iso_resources_free(&motu->rx_resources);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ensure_packet_formats(struct snd_motu *motu)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, PACKET_FORMAT_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tdata &= ~(TX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS |\n\t\t  RX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS|\n\t\t  TX_PACKET_TRANSMISSION_SPEED_MASK);\n\tif (motu->spec->tx_fixed_pcm_chunks[0] == motu->tx_packet_formats.pcm_chunks[0])\n\t\tdata |= TX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS;\n\tif (motu->spec->rx_fixed_pcm_chunks[0] == motu->rx_packet_formats.pcm_chunks[0])\n\t\tdata |= RX_PACKET_EXCLUDE_DIFFERED_DATA_CHUNKS;\n\tdata |= fw_parent_device(motu->unit)->max_speed;\n\n\treg = cpu_to_be32(data);\n\treturn snd_motu_transaction_write(motu, PACKET_FORMAT_OFFSET, &reg,\n\t\t\t\t\t  sizeof(reg));\n}\n\nint snd_motu_stream_start_duplex(struct snd_motu *motu)\n{\n\tunsigned int generation = motu->rx_resources.generation;\n\tint err = 0;\n\n\tif (motu->substreams_counter == 0)\n\t\treturn 0;\n\n\tif (amdtp_streaming_error(&motu->rx_stream) ||\n\t    amdtp_streaming_error(&motu->tx_stream)) {\n\t\tamdtp_domain_stop(&motu->domain);\n\t\tfinish_session(motu);\n\t}\n\n\tif (generation != fw_parent_device(motu->unit)->card->generation) {\n\t\terr = fw_iso_resources_update(&motu->rx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = fw_iso_resources_update(&motu->tx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!amdtp_stream_running(&motu->rx_stream)) {\n\t\tint spd = fw_parent_device(motu->unit)->max_speed;\n\n\t\terr = ensure_packet_formats(motu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (motu->spec->flags & SND_MOTU_SPEC_REGISTER_DSP) {\n\t\t\terr = snd_motu_register_dsp_message_parser_init(motu);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else if (motu->spec->flags & SND_MOTU_SPEC_COMMAND_DSP) {\n\t\t\terr = snd_motu_command_dsp_message_parser_init(motu, motu->tx_stream.sfc);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = begin_session(motu);\n\t\tif (err < 0) {\n\t\t\tdev_err(&motu->unit->device,\n\t\t\t\t\"fail to start isochronous comm: %d\\n\", err);\n\t\t\tgoto stop_streams;\n\t\t}\n\n\t\terr = amdtp_domain_add_stream(&motu->domain, &motu->tx_stream,\n\t\t\t\t\t      motu->tx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto stop_streams;\n\n\t\terr = amdtp_domain_add_stream(&motu->domain, &motu->rx_stream,\n\t\t\t\t\t      motu->rx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto stop_streams;\n\n\t\tmotu->cache.tail = 0;\n\t\tmotu->cache.tx_cycle_count = UINT_MAX;\n\t\tmotu->cache.head = 0;\n\t\tmotu->cache.rx_cycle_count = UINT_MAX;\n\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&motu->domain, 0, true, false);\n\t\tif (err < 0)\n\t\t\tgoto stop_streams;\n\n\t\tif (!amdtp_domain_wait_ready(&motu->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto stop_streams;\n\t\t}\n\n\t\terr = snd_motu_protocol_switch_fetching_mode(motu, true);\n\t\tif (err < 0) {\n\t\t\tdev_err(&motu->unit->device,\n\t\t\t\t\"fail to enable frame fetching: %d\\n\", err);\n\t\t\tgoto stop_streams;\n\t\t}\n\t}\n\n\treturn 0;\n\nstop_streams:\n\tamdtp_domain_stop(&motu->domain);\n\tfinish_session(motu);\n\treturn err;\n}\n\nvoid snd_motu_stream_stop_duplex(struct snd_motu *motu)\n{\n\tif (motu->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&motu->domain);\n\t\tfinish_session(motu);\n\n\t\tfw_iso_resources_free(&motu->tx_resources);\n\t\tfw_iso_resources_free(&motu->rx_resources);\n\n\t\tkfree(motu->cache.event_offsets);\n\t\tmotu->cache.event_offsets = NULL;\n\t}\n}\n\nstatic int init_stream(struct snd_motu *motu, struct amdtp_stream *s)\n{\n\tstruct fw_iso_resources *resources;\n\tenum amdtp_stream_direction dir;\n\tint err;\n\n\tif (s == &motu->tx_stream) {\n\t\tresources = &motu->tx_resources;\n\t\tdir = AMDTP_IN_STREAM;\n\t} else {\n\t\tresources = &motu->rx_resources;\n\t\tdir = AMDTP_OUT_STREAM;\n\t}\n\n\terr = fw_iso_resources_init(resources, motu->unit);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_motu_init(s, motu->unit, dir, motu->spec, &motu->cache);\n\tif (err < 0)\n\t\tfw_iso_resources_destroy(resources);\n\n\treturn err;\n}\n\nstatic void destroy_stream(struct snd_motu *motu, struct amdtp_stream *s)\n{\n\tamdtp_stream_destroy(s);\n\n\tif (s == &motu->tx_stream)\n\t\tfw_iso_resources_destroy(&motu->tx_resources);\n\telse\n\t\tfw_iso_resources_destroy(&motu->rx_resources);\n}\n\nint snd_motu_stream_init_duplex(struct snd_motu *motu)\n{\n\tint err;\n\n\terr = init_stream(motu, &motu->tx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(motu, &motu->rx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(motu, &motu->tx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&motu->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(motu, &motu->tx_stream);\n\t\tdestroy_stream(motu, &motu->rx_stream);\n\t}\n\n\treturn err;\n}\n\n\n\nvoid snd_motu_stream_destroy_duplex(struct snd_motu *motu)\n{\n\tamdtp_domain_destroy(&motu->domain);\n\n\tdestroy_stream(motu, &motu->rx_stream);\n\tdestroy_stream(motu, &motu->tx_stream);\n\n\tmotu->substreams_counter = 0;\n}\n\nstatic void motu_lock_changed(struct snd_motu *motu)\n{\n\tmotu->dev_lock_changed = true;\n\twake_up(&motu->hwdep_wait);\n}\n\nint snd_motu_stream_lock_try(struct snd_motu *motu)\n{\n\tint err;\n\n\tspin_lock_irq(&motu->lock);\n\n\tif (motu->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (motu->dev_lock_count++ == 0)\n\t\tmotu_lock_changed(motu);\n\terr = 0;\nout:\n\tspin_unlock_irq(&motu->lock);\n\treturn err;\n}\n\nvoid snd_motu_stream_lock_release(struct snd_motu *motu)\n{\n\tspin_lock_irq(&motu->lock);\n\n\tif (WARN_ON(motu->dev_lock_count <= 0))\n\t\tgoto out;\n\n\tif (--motu->dev_lock_count == 0)\n\t\tmotu_lock_changed(motu);\nout:\n\tspin_unlock_irq(&motu->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}