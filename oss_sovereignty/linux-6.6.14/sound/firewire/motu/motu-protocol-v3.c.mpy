{
  "module_name": "motu-protocol-v3.c",
  "hash_id": "5778f837b817cb053927cb0600ad1932731cdcea6fb482d4d1870f1e90e3fe42",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-protocol-v3.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"motu.h\"\n\n#define V3_CLOCK_STATUS_OFFSET\t\t0x0b14\n#define  V3_FETCH_PCM_FRAMES\t\t0x02000000\n#define  V3_CLOCK_RATE_MASK\t\t0x0000ff00\n#define  V3_CLOCK_RATE_SHIFT\t\t8\n#define  V3_CLOCK_SOURCE_MASK\t\t0x000000ff\n#define   V3_CLOCK_SRC_INTERNAL\t\t0x00\n#define   V3_CLOCK_SRC_WORD_ON_BNC\t0x01\n#define   V3_CLOCK_SRC_SPH\t\t0x02\n#define   V3_CLOCK_SRC_AESEBU_ON_XLR\t0x08\n#define   V3_CLOCK_SRC_SPDIF_ON_COAX\t0x10\n#define   V3_CLOCK_SRC_OPT_IFACE_A\t0x18\n#define   V3_CLOCK_SRC_OPT_IFACE_B\t0x19\n\n#define V3_OPT_IFACE_MODE_OFFSET\t0x0c94\n#define  V3_ENABLE_OPT_IN_IFACE_A\t0x00000001\n#define  V3_ENABLE_OPT_IN_IFACE_B\t0x00000002\n#define  V3_ENABLE_OPT_OUT_IFACE_A\t0x00000100\n#define  V3_ENABLE_OPT_OUT_IFACE_B\t0x00000200\n#define  V3_NO_ADAT_OPT_IN_IFACE_A\t0x00010000\n#define  V3_NO_ADAT_OPT_IN_IFACE_B\t0x00100000\n#define  V3_NO_ADAT_OPT_OUT_IFACE_A\t0x00040000\n#define  V3_NO_ADAT_OPT_OUT_IFACE_B\t0x00400000\n\n#define V3_MSG_FLAG_CLK_CHANGED\t\t0x00000002\n#define V3_CLK_WAIT_MSEC\t\t4000\n\nint snd_motu_protocol_v3_get_clock_rate(struct snd_motu *motu,\n\t\t\t\t\tunsigned int *rate)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tdata = (data & V3_CLOCK_RATE_MASK) >> V3_CLOCK_RATE_SHIFT;\n\tif (data >= ARRAY_SIZE(snd_motu_clock_rates))\n\t\treturn -EIO;\n\n\t*rate = snd_motu_clock_rates[data];\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v3_set_clock_rate(struct snd_motu *motu,\n\t\t\t\t\tunsigned int rate)\n{\n\t__be32 reg;\n\tu32 data;\n\tbool need_to_wait;\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {\n\t\tif (snd_motu_clock_rates[i] == rate)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(snd_motu_clock_rates))\n\t\treturn -EINVAL;\n\n\terr = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tdata &= ~(V3_CLOCK_RATE_MASK | V3_FETCH_PCM_FRAMES);\n\tdata |= i << V3_CLOCK_RATE_SHIFT;\n\n\tneed_to_wait = data != be32_to_cpu(reg);\n\n\treg = cpu_to_be32(data);\n\terr = snd_motu_transaction_write(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\t sizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (need_to_wait) {\n\t\tint result;\n\n\t\tmotu->msg = 0;\n\t\tresult = wait_event_interruptible_timeout(motu->hwdep_wait,\n\t\t\t\t\tmotu->msg & V3_MSG_FLAG_CLK_CHANGED,\n\t\t\t\t\tmsecs_to_jiffies(V3_CLK_WAIT_MSEC));\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (result == 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v3_get_clock_source(struct snd_motu *motu,\n\t\t\t\t\t  enum snd_motu_clock_source *src)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg) & V3_CLOCK_SOURCE_MASK;\n\n\tswitch (data) {\n\tcase V3_CLOCK_SRC_INTERNAL:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;\n\t\tbreak;\n\tcase V3_CLOCK_SRC_WORD_ON_BNC:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;\n\t\tbreak;\n\tcase V3_CLOCK_SRC_SPH:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_SPH;\n\t\tbreak;\n\tcase V3_CLOCK_SRC_AESEBU_ON_XLR:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_AESEBU_ON_XLR;\n\t\tbreak;\n\tcase V3_CLOCK_SRC_SPDIF_ON_COAX:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;\n\t\tbreak;\n\tcase V3_CLOCK_SRC_OPT_IFACE_A:\n\tcase V3_CLOCK_SRC_OPT_IFACE_B:\n\t{\n\t\t__be32 reg;\n\t\tu32 options;\n\n\t\terr = snd_motu_transaction_read(motu,\n\t\t\t\tV3_OPT_IFACE_MODE_OFFSET, &reg, sizeof(reg));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\toptions = be32_to_cpu(reg);\n\n\t\tif (data == V3_CLOCK_SRC_OPT_IFACE_A) {\n\t\t\tif (options & V3_NO_ADAT_OPT_IN_IFACE_A)\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_A;\n\t\t\telse\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_A;\n\t\t} else {\n\t\t\tif (options & V3_NO_ADAT_OPT_IN_IFACE_B)\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_B;\n\t\t\telse\n\t\t\t\t*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_B;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\t*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v3_switch_fetching_mode(struct snd_motu *motu,\n\t\t\t\t\t      bool enable)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn 0;\n\tdata = be32_to_cpu(reg);\n\n\tif (enable)\n\t\tdata |= V3_FETCH_PCM_FRAMES;\n\telse\n\t\tdata &= ~V3_FETCH_PCM_FRAMES;\n\n\treg = cpu_to_be32(data);\n\treturn snd_motu_transaction_write(motu, V3_CLOCK_STATUS_OFFSET, &reg,\n\t\t\t\t\t  sizeof(reg));\n}\n\nstatic int detect_packet_formats_with_opt_ifaces(struct snd_motu *motu, u32 data)\n{\n\tif (data & V3_ENABLE_OPT_IN_IFACE_A) {\n\t\tif (data & V3_NO_ADAT_OPT_IN_IFACE_A) {\n\t\t\tmotu->tx_packet_formats.pcm_chunks[0] += 4;\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 4;\n\t\t} else {\n\t\t\tmotu->tx_packet_formats.pcm_chunks[0] += 8;\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 4;\n\t\t}\n\t}\n\n\tif (data & V3_ENABLE_OPT_IN_IFACE_B) {\n\t\tif (data & V3_NO_ADAT_OPT_IN_IFACE_B) {\n\t\t\tmotu->tx_packet_formats.pcm_chunks[0] += 4;\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 4;\n\t\t} else {\n\t\t\tmotu->tx_packet_formats.pcm_chunks[0] += 8;\n\t\t\tmotu->tx_packet_formats.pcm_chunks[1] += 4;\n\t\t}\n\t}\n\n\tif (data & V3_ENABLE_OPT_OUT_IFACE_A) {\n\t\tif (data & V3_NO_ADAT_OPT_OUT_IFACE_A) {\n\t\t\tmotu->rx_packet_formats.pcm_chunks[0] += 4;\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 4;\n\t\t} else {\n\t\t\tmotu->rx_packet_formats.pcm_chunks[0] += 8;\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 4;\n\t\t}\n\t}\n\n\tif (data & V3_ENABLE_OPT_OUT_IFACE_B) {\n\t\tif (data & V3_NO_ADAT_OPT_OUT_IFACE_B) {\n\t\t\tmotu->rx_packet_formats.pcm_chunks[0] += 4;\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 4;\n\t\t} else {\n\t\t\tmotu->rx_packet_formats.pcm_chunks[0] += 8;\n\t\t\tmotu->rx_packet_formats.pcm_chunks[1] += 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)\n{\n\t__be32 reg;\n\tu32 data;\n\tint err;\n\n\tmotu->tx_packet_formats.pcm_byte_offset = 10;\n\tmotu->rx_packet_formats.pcm_byte_offset = 10;\n\n\tmotu->tx_packet_formats.msg_chunks = 2;\n\tmotu->rx_packet_formats.msg_chunks = 2;\n\n\terr = snd_motu_transaction_read(motu, V3_OPT_IFACE_MODE_OFFSET, &reg,\n\t\t\t\t\tsizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\tdata = be32_to_cpu(reg);\n\n\tmemcpy(motu->tx_packet_formats.pcm_chunks,\n\t       motu->spec->tx_fixed_pcm_chunks,\n\t       sizeof(motu->tx_packet_formats.pcm_chunks));\n\tmemcpy(motu->rx_packet_formats.pcm_chunks,\n\t       motu->spec->rx_fixed_pcm_chunks,\n\t       sizeof(motu->rx_packet_formats.pcm_chunks));\n\n\tif (motu->spec == &snd_motu_spec_828mk3_fw ||\n\t    motu->spec == &snd_motu_spec_828mk3_hybrid ||\n\t    motu->spec == &snd_motu_spec_traveler_mk3 ||\n\t    motu->spec == &snd_motu_spec_track16)\n\t\treturn detect_packet_formats_with_opt_ifaces(motu, data);\n\telse\n\t\treturn 0;\n}\n\nconst struct snd_motu_spec snd_motu_spec_828mk3_fw = {\n\t.name = \"828mk3\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_COMMAND_DSP,\n\t.tx_fixed_pcm_chunks = {18, 18, 14},\n\t.rx_fixed_pcm_chunks = {14, 14, 10},\n};\n\nconst struct snd_motu_spec snd_motu_spec_828mk3_hybrid = {\n\t.name = \"828mk3\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_COMMAND_DSP,\n\t.tx_fixed_pcm_chunks = {18, 18, 14},\n\t.rx_fixed_pcm_chunks = {14, 14, 14},\t\n};\n\nconst struct snd_motu_spec snd_motu_spec_traveler_mk3 = {\n\t.name = \"TravelerMk3\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_COMMAND_DSP,\n\t.tx_fixed_pcm_chunks = {18, 14, 10},\n\t.rx_fixed_pcm_chunks = {14, 14, 10},\n};\n\nconst struct snd_motu_spec snd_motu_spec_ultralite_mk3 = {\n\t.name = \"UltraLiteMk3\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_COMMAND_DSP,\n\t.tx_fixed_pcm_chunks = {18, 14, 10},\n\t.rx_fixed_pcm_chunks = {14, 14, 14},\n};\n\nconst struct snd_motu_spec snd_motu_spec_audio_express = {\n\t.name = \"AudioExpress\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {10, 10, 0},\n\t.rx_fixed_pcm_chunks = {10, 10, 0},\n};\n\nconst struct snd_motu_spec snd_motu_spec_track16 = {\n\t.name = \"Track16\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_TX_MIDI_3RD_Q |\n\t\t SND_MOTU_SPEC_COMMAND_DSP,\n\t.tx_fixed_pcm_chunks = {14, 14, 14},\n\t.rx_fixed_pcm_chunks = {6, 6, 6},\n};\n\nconst struct snd_motu_spec snd_motu_spec_4pre = {\n\t.name = \"4pre\",\n\t.protocol_version = SND_MOTU_PROTOCOL_V3,\n\t.flags = SND_MOTU_SPEC_REGISTER_DSP,\n\t.tx_fixed_pcm_chunks = {10, 10, 0},\n\t.rx_fixed_pcm_chunks = {10, 10, 0},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}