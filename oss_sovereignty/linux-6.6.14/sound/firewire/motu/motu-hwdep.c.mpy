{
  "module_name": "motu-hwdep.c",
  "hash_id": "55358438a0234ee6829f1f9cc998089f022a1c853c410c77f724ea8aa2b8f639",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-hwdep.c",
  "human_readable_source": "\n \n\n \n\n#include \"motu.h\"\n\nstatic bool has_dsp_event(struct snd_motu *motu)\n{\n\tif (motu->spec->flags & SND_MOTU_SPEC_REGISTER_DSP)\n\t\treturn (snd_motu_register_dsp_message_parser_count_event(motu) > 0);\n\telse\n\t\treturn false;\n}\n\nstatic long hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,\n\t\t       loff_t *offset)\n{\n\tstruct snd_motu *motu = hwdep->private_data;\n\tDEFINE_WAIT(wait);\n\tunion snd_firewire_event event;\n\n\tspin_lock_irq(&motu->lock);\n\n\twhile (!motu->dev_lock_changed && motu->msg == 0 && !has_dsp_event(motu)) {\n\t\tprepare_to_wait(&motu->hwdep_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irq(&motu->lock);\n\t\tschedule();\n\t\tfinish_wait(&motu->hwdep_wait, &wait);\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tspin_lock_irq(&motu->lock);\n\t}\n\n\tmemset(&event, 0, sizeof(event));\n\tif (motu->dev_lock_changed) {\n\t\tevent.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS;\n\t\tevent.lock_status.status = (motu->dev_lock_count > 0);\n\t\tmotu->dev_lock_changed = false;\n\t\tspin_unlock_irq(&motu->lock);\n\n\t\tcount = min_t(long, count, sizeof(event));\n\t\tif (copy_to_user(buf, &event, count))\n\t\t\treturn -EFAULT;\n\t} else if (motu->msg > 0) {\n\t\tevent.motu_notification.type = SNDRV_FIREWIRE_EVENT_MOTU_NOTIFICATION;\n\t\tevent.motu_notification.message = motu->msg;\n\t\tmotu->msg = 0;\n\t\tspin_unlock_irq(&motu->lock);\n\n\t\tcount = min_t(long, count, sizeof(event));\n\t\tif (copy_to_user(buf, &event, count))\n\t\t\treturn -EFAULT;\n\t} else if (has_dsp_event(motu)) {\n\t\tsize_t consumed = 0;\n\t\tu32 __user *ptr;\n\t\tu32 ev;\n\n\t\tspin_unlock_irq(&motu->lock);\n\n\t\t\n\t\tconsumed += sizeof(event.motu_register_dsp_change);\n\n\t\twhile (consumed < count &&\n\t\t       snd_motu_register_dsp_message_parser_copy_event(motu, &ev)) {\n\t\t\tptr = (u32 __user *)(buf + consumed);\n\t\t\tif (put_user(ev, ptr))\n\t\t\t\treturn -EFAULT;\n\t\t\tconsumed += sizeof(ev);\n\t\t}\n\n\t\tevent.motu_register_dsp_change.type = SNDRV_FIREWIRE_EVENT_MOTU_REGISTER_DSP_CHANGE;\n\t\tevent.motu_register_dsp_change.count =\n\t\t\t(consumed - sizeof(event.motu_register_dsp_change)) / 4;\n\t\tif (copy_to_user(buf, &event, sizeof(event.motu_register_dsp_change)))\n\t\t\treturn -EFAULT;\n\n\t\tcount = consumed;\n\t} else {\n\t\tspin_unlock_irq(&motu->lock);\n\n\t\tcount = 0;\n\t}\n\n\treturn count;\n}\n\nstatic __poll_t hwdep_poll(struct snd_hwdep *hwdep, struct file *file,\n\t\t\t       poll_table *wait)\n{\n\tstruct snd_motu *motu = hwdep->private_data;\n\t__poll_t events;\n\n\tpoll_wait(file, &motu->hwdep_wait, wait);\n\n\tspin_lock_irq(&motu->lock);\n\tif (motu->dev_lock_changed || motu->msg || has_dsp_event(motu))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\telse\n\t\tevents = 0;\n\tspin_unlock_irq(&motu->lock);\n\n\treturn events | EPOLLOUT;\n}\n\nstatic int hwdep_get_info(struct snd_motu *motu, void __user *arg)\n{\n\tstruct fw_device *dev = fw_parent_device(motu->unit);\n\tstruct snd_firewire_get_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = SNDRV_FIREWIRE_TYPE_MOTU;\n\tinfo.card = dev->card->index;\n\t*(__be32 *)&info.guid[0] = cpu_to_be32(dev->config_rom[3]);\n\t*(__be32 *)&info.guid[4] = cpu_to_be32(dev->config_rom[4]);\n\tstrscpy(info.device_name, dev_name(&dev->device),\n\t\tsizeof(info.device_name));\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int hwdep_lock(struct snd_motu *motu)\n{\n\tint err;\n\n\tspin_lock_irq(&motu->lock);\n\n\tif (motu->dev_lock_count == 0) {\n\t\tmotu->dev_lock_count = -1;\n\t\terr = 0;\n\t} else {\n\t\terr = -EBUSY;\n\t}\n\n\tspin_unlock_irq(&motu->lock);\n\n\treturn err;\n}\n\nstatic int hwdep_unlock(struct snd_motu *motu)\n{\n\tint err;\n\n\tspin_lock_irq(&motu->lock);\n\n\tif (motu->dev_lock_count == -1) {\n\t\tmotu->dev_lock_count = 0;\n\t\terr = 0;\n\t} else {\n\t\terr = -EBADFD;\n\t}\n\n\tspin_unlock_irq(&motu->lock);\n\n\treturn err;\n}\n\nstatic int hwdep_release(struct snd_hwdep *hwdep, struct file *file)\n{\n\tstruct snd_motu *motu = hwdep->private_data;\n\n\tspin_lock_irq(&motu->lock);\n\tif (motu->dev_lock_count == -1)\n\t\tmotu->dev_lock_count = 0;\n\tspin_unlock_irq(&motu->lock);\n\n\treturn 0;\n}\n\nstatic int hwdep_ioctl(struct snd_hwdep *hwdep, struct file *file,\n\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_motu *motu = hwdep->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_FIREWIRE_IOCTL_GET_INFO:\n\t\treturn hwdep_get_info(motu, (void __user *)arg);\n\tcase SNDRV_FIREWIRE_IOCTL_LOCK:\n\t\treturn hwdep_lock(motu);\n\tcase SNDRV_FIREWIRE_IOCTL_UNLOCK:\n\t\treturn hwdep_unlock(motu);\n\tcase SNDRV_FIREWIRE_IOCTL_MOTU_REGISTER_DSP_METER:\n\t{\n\t\tstruct snd_firewire_motu_register_dsp_meter *meter;\n\t\tint err;\n\n\t\tif (!(motu->spec->flags & SND_MOTU_SPEC_REGISTER_DSP))\n\t\t\treturn -ENXIO;\n\n\t\tmeter = kzalloc(sizeof(*meter), GFP_KERNEL);\n\t\tif (!meter)\n\t\t\treturn -ENOMEM;\n\n\t\tsnd_motu_register_dsp_message_parser_copy_meter(motu, meter);\n\n\t\terr = copy_to_user((void __user *)arg, meter, sizeof(*meter));\n\t\tkfree(meter);\n\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase SNDRV_FIREWIRE_IOCTL_MOTU_COMMAND_DSP_METER:\n\t{\n\t\tstruct snd_firewire_motu_command_dsp_meter *meter;\n\t\tint err;\n\n\t\tif (!(motu->spec->flags & SND_MOTU_SPEC_COMMAND_DSP))\n\t\t\treturn -ENXIO;\n\n\t\tmeter = kzalloc(sizeof(*meter), GFP_KERNEL);\n\t\tif (!meter)\n\t\t\treturn -ENOMEM;\n\n\t\tsnd_motu_command_dsp_message_parser_copy_meter(motu, meter);\n\n\t\terr = copy_to_user((void __user *)arg, meter, sizeof(*meter));\n\t\tkfree(meter);\n\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase SNDRV_FIREWIRE_IOCTL_MOTU_REGISTER_DSP_PARAMETER:\n\t{\n\t\tstruct snd_firewire_motu_register_dsp_parameter *param;\n\t\tint err;\n\n\t\tif (!(motu->spec->flags & SND_MOTU_SPEC_REGISTER_DSP))\n\t\t\treturn -ENXIO;\n\n\t\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\t\tif (!param)\n\t\t\treturn -ENOMEM;\n\n\t\tsnd_motu_register_dsp_message_parser_copy_parameter(motu, param);\n\n\t\terr = copy_to_user((void __user *)arg, param, sizeof(*param));\n\t\tkfree(param);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int hwdep_compat_ioctl(struct snd_hwdep *hwdep, struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\treturn hwdep_ioctl(hwdep, file, cmd,\n\t\t\t   (unsigned long)compat_ptr(arg));\n}\n#else\n#define hwdep_compat_ioctl NULL\n#endif\n\nint snd_motu_create_hwdep_device(struct snd_motu *motu)\n{\n\tstatic const struct snd_hwdep_ops ops = {\n\t\t.read\t\t= hwdep_read,\n\t\t.release\t= hwdep_release,\n\t\t.poll\t\t= hwdep_poll,\n\t\t.ioctl\t\t= hwdep_ioctl,\n\t\t.ioctl_compat\t= hwdep_compat_ioctl,\n\t};\n\tstruct snd_hwdep *hwdep;\n\tint err;\n\n\terr = snd_hwdep_new(motu->card, motu->card->driver, 0, &hwdep);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(hwdep->name, \"MOTU\");\n\thwdep->iface = SNDRV_HWDEP_IFACE_FW_MOTU;\n\thwdep->ops = ops;\n\thwdep->private_data = motu;\n\thwdep->exclusive = true;\n\n\tmotu->hwdep = hwdep;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}