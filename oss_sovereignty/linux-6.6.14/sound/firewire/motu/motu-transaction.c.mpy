{
  "module_name": "motu-transaction.c",
  "hash_id": "124ea16d6bdc8d06d82e7d4fff2a499b4e9b096a2c66ec142b47d90795c0a599",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/motu/motu-transaction.c",
  "human_readable_source": "\n \n\n\n#include \"motu.h\"\n\n#define SND_MOTU_ADDR_BASE\t0xfffff0000000ULL\n#define ASYNC_ADDR_HI  0x0b04\n#define ASYNC_ADDR_LO  0x0b08\n\nint snd_motu_transaction_read(struct snd_motu *motu, u32 offset, __be32 *reg,\n\t\t\t      size_t size)\n{\n\tint tcode;\n\n\tif (size % sizeof(__be32) > 0 || size <= 0)\n\t\treturn -EINVAL;\n\tif (size == sizeof(__be32))\n\t\ttcode = TCODE_READ_QUADLET_REQUEST;\n\telse\n\t\ttcode = TCODE_READ_BLOCK_REQUEST;\n\n\treturn snd_fw_transaction(motu->unit, tcode,\n\t\t\t\t  SND_MOTU_ADDR_BASE + offset, reg, size, 0);\n}\n\nint snd_motu_transaction_write(struct snd_motu *motu, u32 offset, __be32 *reg,\n\t\t\t       size_t size)\n{\n\tint tcode;\n\n\tif (size % sizeof(__be32) > 0 || size <= 0)\n\t\treturn -EINVAL;\n\tif (size == sizeof(__be32))\n\t\ttcode = TCODE_WRITE_QUADLET_REQUEST;\n\telse\n\t\ttcode = TCODE_WRITE_BLOCK_REQUEST;\n\n\treturn snd_fw_transaction(motu->unit, tcode,\n\t\t\t\t  SND_MOTU_ADDR_BASE + offset, reg, size, 0);\n}\n\nstatic void handle_message(struct fw_card *card, struct fw_request *request,\n\t\t\t   int tcode, int destination, int source,\n\t\t\t   int generation, unsigned long long offset,\n\t\t\t   void *data, size_t length, void *callback_data)\n{\n\tstruct snd_motu *motu = callback_data;\n\t__be32 *buf = (__be32 *)data;\n\tunsigned long flags;\n\n\tif (tcode != TCODE_WRITE_QUADLET_REQUEST) {\n\t\tfw_send_response(card, request, RCODE_COMPLETE);\n\t\treturn;\n\t}\n\n\tif (offset != motu->async_handler.offset || length != 4) {\n\t\tfw_send_response(card, request, RCODE_ADDRESS_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&motu->lock, flags);\n\tmotu->msg = be32_to_cpu(*buf);\n\tspin_unlock_irqrestore(&motu->lock, flags);\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n\n\twake_up(&motu->hwdep_wait);\n}\n\nint snd_motu_transaction_reregister(struct snd_motu *motu)\n{\n\tstruct fw_device *device = fw_parent_device(motu->unit);\n\t__be32 data;\n\tint err;\n\n\tif (motu->async_handler.callback_data == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tdata = cpu_to_be32((device->card->node_id << 16) |\n\t\t\t   (motu->async_handler.offset >> 32));\n\terr = snd_motu_transaction_write(motu, ASYNC_ADDR_HI, &data,\n\t\t\t\t\t sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = cpu_to_be32(motu->async_handler.offset);\n\treturn snd_motu_transaction_write(motu, ASYNC_ADDR_LO, &data,\n\t\t\t\t\t  sizeof(data));\n}\n\nint snd_motu_transaction_register(struct snd_motu *motu)\n{\n\tstatic const struct fw_address_region resp_register_region = {\n\t\t.start\t= 0xffffe0000000ull,\n\t\t.end\t= 0xffffe000ffffull,\n\t};\n\tint err;\n\n\t \n\tmotu->async_handler.length = 4;\n\tmotu->async_handler.address_callback = handle_message;\n\tmotu->async_handler.callback_data = motu;\n\n\terr = fw_core_add_address_handler(&motu->async_handler,\n\t\t\t\t\t  &resp_register_region);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_motu_transaction_reregister(motu);\n\tif (err < 0) {\n\t\tfw_core_remove_address_handler(&motu->async_handler);\n\t\tmotu->async_handler.address_callback = NULL;\n\t}\n\n\treturn err;\n}\n\nvoid snd_motu_transaction_unregister(struct snd_motu *motu)\n{\n\t__be32 data;\n\n\tif (motu->async_handler.address_callback != NULL)\n\t\tfw_core_remove_address_handler(&motu->async_handler);\n\tmotu->async_handler.address_callback = NULL;\n\n\t \n\tdata = cpu_to_be32(0x00000000);\n\tsnd_motu_transaction_write(motu, ASYNC_ADDR_HI, &data, sizeof(data));\n\tsnd_motu_transaction_write(motu, ASYNC_ADDR_LO, &data, sizeof(data));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}