{
  "module_name": "isight.c",
  "hash_id": "d76963d77f9a3a3b720f70c87b745854ffa3ae2f5aaf8949de68f7dfca289a5c",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/isight.c",
  "human_readable_source": "\n \n\n#include <asm/byteorder.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n#include \"lib.h\"\n#include \"iso-resources.h\"\n#include \"packets-buffer.h\"\n\n#define OUI_APPLE\t\t0x000a27\n#define MODEL_APPLE_ISIGHT\t0x000008\n#define SW_ISIGHT_AUDIO\t\t0x000010\n\n#define REG_AUDIO_ENABLE\t0x000\n#define  AUDIO_ENABLE\t\t0x80000000\n#define REG_DEF_AUDIO_GAIN\t0x204\n#define REG_GAIN_RAW_START\t0x210\n#define REG_GAIN_RAW_END\t0x214\n#define REG_GAIN_DB_START\t0x218\n#define REG_GAIN_DB_END\t\t0x21c\n#define REG_SAMPLE_RATE_INQUIRY\t0x280\n#define REG_ISO_TX_CONFIG\t0x300\n#define  SPEED_SHIFT\t\t16\n#define REG_SAMPLE_RATE\t\t0x400\n#define  RATE_48000\t\t0x80000000\n#define REG_GAIN\t\t0x500\n#define REG_MUTE\t\t0x504\n\n#define MAX_FRAMES_PER_PACKET\t475\n\n#define QUEUE_LENGTH\t\t20\n\nstruct isight {\n\tstruct snd_card *card;\n\tstruct fw_unit *unit;\n\tstruct fw_device *device;\n\tu64 audio_base;\n\tstruct snd_pcm_substream *pcm;\n\tstruct mutex mutex;\n\tstruct iso_packets_buffer buffer;\n\tstruct fw_iso_resources resources;\n\tstruct fw_iso_context *context;\n\tbool pcm_active;\n\tbool pcm_running;\n\tbool first_packet;\n\tint packet_index;\n\tu32 total_samples;\n\tunsigned int buffer_pointer;\n\tunsigned int period_counter;\n\ts32 gain_min, gain_max;\n\tunsigned int gain_tlv[4];\n};\n\nstruct audio_payload {\n\t__be32 sample_count;\n\t__be32 signature;\n\t__be32 sample_total;\n\t__be32 reserved;\n\t__be16 samples[2 * MAX_FRAMES_PER_PACKET];\n};\n\nMODULE_DESCRIPTION(\"iSight audio driver\");\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct fw_iso_packet audio_packet = {\n\t.payload_length = sizeof(struct audio_payload),\n\t.interrupt = 1,\n\t.header_length = 4,\n};\n\nstatic void isight_update_pointers(struct isight *isight, unsigned int count)\n{\n\tstruct snd_pcm_runtime *runtime = isight->pcm->runtime;\n\tunsigned int ptr;\n\n\tsmp_wmb();  \n\n\tptr = isight->buffer_pointer;\n\tptr += count;\n\tif (ptr >= runtime->buffer_size)\n\t\tptr -= runtime->buffer_size;\n\tWRITE_ONCE(isight->buffer_pointer, ptr);\n\n\tisight->period_counter += count;\n\tif (isight->period_counter >= runtime->period_size) {\n\t\tisight->period_counter -= runtime->period_size;\n\t\tsnd_pcm_period_elapsed(isight->pcm);\n\t}\n}\n\nstatic void isight_samples(struct isight *isight,\n\t\t\t   const __be16 *samples, unsigned int count)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int count1;\n\n\tif (!READ_ONCE(isight->pcm_running))\n\t\treturn;\n\n\truntime = isight->pcm->runtime;\n\tif (isight->buffer_pointer + count <= runtime->buffer_size) {\n\t\tmemcpy(runtime->dma_area + isight->buffer_pointer * 4,\n\t\t       samples, count * 4);\n\t} else {\n\t\tcount1 = runtime->buffer_size - isight->buffer_pointer;\n\t\tmemcpy(runtime->dma_area + isight->buffer_pointer * 4,\n\t\t       samples, count1 * 4);\n\t\tsamples += count1 * 2;\n\t\tmemcpy(runtime->dma_area, samples, (count - count1) * 4);\n\t}\n\n\tisight_update_pointers(isight, count);\n}\n\nstatic void isight_pcm_abort(struct isight *isight)\n{\n\tif (READ_ONCE(isight->pcm_active))\n\t\tsnd_pcm_stop_xrun(isight->pcm);\n}\n\nstatic void isight_dropped_samples(struct isight *isight, unsigned int total)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tu32 dropped;\n\tunsigned int count1;\n\n\tif (!READ_ONCE(isight->pcm_running))\n\t\treturn;\n\n\truntime = isight->pcm->runtime;\n\tdropped = total - isight->total_samples;\n\tif (dropped < runtime->buffer_size) {\n\t\tif (isight->buffer_pointer + dropped <= runtime->buffer_size) {\n\t\t\tmemset(runtime->dma_area + isight->buffer_pointer * 4,\n\t\t\t       0, dropped * 4);\n\t\t} else {\n\t\t\tcount1 = runtime->buffer_size - isight->buffer_pointer;\n\t\t\tmemset(runtime->dma_area + isight->buffer_pointer * 4,\n\t\t\t       0, count1 * 4);\n\t\t\tmemset(runtime->dma_area, 0, (dropped - count1) * 4);\n\t\t}\n\t\tisight_update_pointers(isight, dropped);\n\t} else {\n\t\tisight_pcm_abort(isight);\n\t}\n}\n\nstatic void isight_packet(struct fw_iso_context *context, u32 cycle,\n\t\t\t  size_t header_length, void *header, void *data)\n{\n\tstruct isight *isight = data;\n\tconst struct audio_payload *payload;\n\tunsigned int index, length, count, total;\n\tint err;\n\n\tif (isight->packet_index < 0)\n\t\treturn;\n\tindex = isight->packet_index;\n\tpayload = isight->buffer.packets[index].buffer;\n\tlength = be32_to_cpup(header) >> 16;\n\n\tif (likely(length >= 16 &&\n\t\t   payload->signature == cpu_to_be32(0x73676874 ))) {\n\t\tcount = be32_to_cpu(payload->sample_count);\n\t\tif (likely(count <= (length - 16) / 4)) {\n\t\t\ttotal = be32_to_cpu(payload->sample_total);\n\t\t\tif (unlikely(total != isight->total_samples)) {\n\t\t\t\tif (!isight->first_packet)\n\t\t\t\t\tisight_dropped_samples(isight, total);\n\t\t\t\tisight->first_packet = false;\n\t\t\t\tisight->total_samples = total;\n\t\t\t}\n\n\t\t\tisight_samples(isight, payload->samples, count);\n\t\t\tisight->total_samples += count;\n\t\t}\n\t}\n\n\terr = fw_iso_context_queue(isight->context, &audio_packet,\n\t\t\t\t   &isight->buffer.iso_buffer,\n\t\t\t\t   isight->buffer.packets[index].offset);\n\tif (err < 0) {\n\t\tdev_err(&isight->unit->device, \"queueing error: %d\\n\", err);\n\t\tisight_pcm_abort(isight);\n\t\tisight->packet_index = -1;\n\t\treturn;\n\t}\n\tfw_iso_context_queue_flush(isight->context);\n\n\tif (++index >= QUEUE_LENGTH)\n\t\tindex = 0;\n\tisight->packet_index = index;\n}\n\nstatic int isight_connect(struct isight *isight)\n{\n\tint ch, err;\n\t__be32 value;\n\nretry_after_bus_reset:\n\tch = fw_iso_resources_allocate(&isight->resources,\n\t\t\t\t       sizeof(struct audio_payload),\n\t\t\t\t       isight->device->max_speed);\n\tif (ch < 0) {\n\t\terr = ch;\n\t\tgoto error;\n\t}\n\n\tvalue = cpu_to_be32(ch | (isight->device->max_speed << SPEED_SHIFT));\n\terr = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t isight->audio_base + REG_ISO_TX_CONFIG,\n\t\t\t\t &value, 4, FW_FIXED_GENERATION |\n\t\t\t\t isight->resources.generation);\n\tif (err == -EAGAIN) {\n\t\tfw_iso_resources_free(&isight->resources);\n\t\tgoto retry_after_bus_reset;\n\t} else if (err < 0) {\n\t\tgoto err_resources;\n\t}\n\n\treturn 0;\n\nerr_resources:\n\tfw_iso_resources_free(&isight->resources);\nerror:\n\treturn err;\n}\n\nstatic int isight_open(struct snd_pcm_substream *substream)\n{\n\tstatic const struct snd_pcm_hardware hardware = {\n\t\t.info = SNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_BATCH |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_BE,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.rate_min = 48000,\n\t\t.rate_max = 48000,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.buffer_bytes_max = 4 * 1024 * 1024,\n\t\t.period_bytes_min = MAX_FRAMES_PER_PACKET * 4,\n\t\t.period_bytes_max = 1024 * 1024,\n\t\t.periods_min = 2,\n\t\t.periods_max = UINT_MAX,\n\t};\n\tstruct isight *isight = substream->private_data;\n\n\tsubstream->runtime->hw = hardware;\n\n\treturn iso_packets_buffer_init(&isight->buffer, isight->unit,\n\t\t\t\t       QUEUE_LENGTH,\n\t\t\t\t       sizeof(struct audio_payload),\n\t\t\t\t       DMA_FROM_DEVICE);\n}\n\nstatic int isight_close(struct snd_pcm_substream *substream)\n{\n\tstruct isight *isight = substream->private_data;\n\n\tiso_packets_buffer_destroy(&isight->buffer, isight->unit);\n\n\treturn 0;\n}\n\nstatic int isight_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct isight *isight = substream->private_data;\n\n\tWRITE_ONCE(isight->pcm_active, true);\n\n\treturn 0;\n}\n\nstatic int reg_read(struct isight *isight, int offset, __be32 *value)\n{\n\treturn snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t  isight->audio_base + offset, value, 4, 0);\n}\n\nstatic int reg_write(struct isight *isight, int offset, __be32 value)\n{\n\treturn snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  isight->audio_base + offset, &value, 4, 0);\n}\n\nstatic void isight_stop_streaming(struct isight *isight)\n{\n\t__be32 value;\n\n\tif (!isight->context)\n\t\treturn;\n\n\tfw_iso_context_stop(isight->context);\n\tfw_iso_context_destroy(isight->context);\n\tisight->context = NULL;\n\tfw_iso_resources_free(&isight->resources);\n\tvalue = 0;\n\tsnd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   isight->audio_base + REG_AUDIO_ENABLE,\n\t\t\t   &value, 4, FW_QUIET);\n}\n\nstatic int isight_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct isight *isight = substream->private_data;\n\n\tWRITE_ONCE(isight->pcm_active, false);\n\n\tmutex_lock(&isight->mutex);\n\tisight_stop_streaming(isight);\n\tmutex_unlock(&isight->mutex);\n\n\treturn 0;\n}\n\nstatic int isight_start_streaming(struct isight *isight)\n{\n\tunsigned int i;\n\tint err;\n\n\tif (isight->context) {\n\t\tif (isight->packet_index < 0)\n\t\t\tisight_stop_streaming(isight);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\terr = reg_write(isight, REG_SAMPLE_RATE, cpu_to_be32(RATE_48000));\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = isight_connect(isight);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = reg_write(isight, REG_AUDIO_ENABLE, cpu_to_be32(AUDIO_ENABLE));\n\tif (err < 0)\n\t\tgoto err_resources;\n\n\tisight->context = fw_iso_context_create(isight->device->card,\n\t\t\t\t\t\tFW_ISO_CONTEXT_RECEIVE,\n\t\t\t\t\t\tisight->resources.channel,\n\t\t\t\t\t\tisight->device->max_speed,\n\t\t\t\t\t\t4, isight_packet, isight);\n\tif (IS_ERR(isight->context)) {\n\t\terr = PTR_ERR(isight->context);\n\t\tisight->context = NULL;\n\t\tgoto err_resources;\n\t}\n\n\tfor (i = 0; i < QUEUE_LENGTH; ++i) {\n\t\terr = fw_iso_context_queue(isight->context, &audio_packet,\n\t\t\t\t\t   &isight->buffer.iso_buffer,\n\t\t\t\t\t   isight->buffer.packets[i].offset);\n\t\tif (err < 0)\n\t\t\tgoto err_context;\n\t}\n\n\tisight->first_packet = true;\n\tisight->packet_index = 0;\n\n\terr = fw_iso_context_start(isight->context, -1, 0,\n\t\t\t\t   FW_ISO_CONTEXT_MATCH_ALL_TAGS );\n\tif (err < 0)\n\t\tgoto err_context;\n\n\treturn 0;\n\nerr_context:\n\tfw_iso_context_destroy(isight->context);\n\tisight->context = NULL;\nerr_resources:\n\tfw_iso_resources_free(&isight->resources);\n\treg_write(isight, REG_AUDIO_ENABLE, 0);\nerror:\n\treturn err;\n}\n\nstatic int isight_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct isight *isight = substream->private_data;\n\tint err;\n\n\tisight->buffer_pointer = 0;\n\tisight->period_counter = 0;\n\n\tmutex_lock(&isight->mutex);\n\terr = isight_start_streaming(isight);\n\tmutex_unlock(&isight->mutex);\n\n\treturn err;\n}\n\nstatic int isight_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct isight *isight = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tWRITE_ONCE(isight->pcm_running, true);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tWRITE_ONCE(isight->pcm_running, false);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct isight *isight = substream->private_data;\n\n\treturn READ_ONCE(isight->buffer_pointer);\n}\n\nstatic int isight_create_pcm(struct isight *isight)\n{\n\tstatic const struct snd_pcm_ops ops = {\n\t\t.open      = isight_open,\n\t\t.close     = isight_close,\n\t\t.hw_params = isight_hw_params,\n\t\t.hw_free   = isight_hw_free,\n\t\t.prepare   = isight_prepare,\n\t\t.trigger   = isight_trigger,\n\t\t.pointer   = isight_pointer,\n\t};\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(isight->card, \"iSight\", 0, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = isight;\n\tstrcpy(pcm->name, \"iSight\");\n\tisight->pcm = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\tisight->pcm->ops = &ops;\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\treturn 0;\n}\n\nstatic int isight_gain_info(struct snd_kcontrol *ctl,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstruct isight *isight = ctl->private_data;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 1;\n\tinfo->value.integer.min = isight->gain_min;\n\tinfo->value.integer.max = isight->gain_max;\n\n\treturn 0;\n}\n\nstatic int isight_gain_get(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct isight *isight = ctl->private_data;\n\t__be32 gain;\n\tint err;\n\n\terr = reg_read(isight, REG_GAIN, &gain);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue->value.integer.value[0] = (s32)be32_to_cpu(gain);\n\n\treturn 0;\n}\n\nstatic int isight_gain_put(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct isight *isight = ctl->private_data;\n\n\tif (value->value.integer.value[0] < isight->gain_min ||\n\t    value->value.integer.value[0] > isight->gain_max)\n\t\treturn -EINVAL;\n\n\treturn reg_write(isight, REG_GAIN,\n\t\t\t cpu_to_be32(value->value.integer.value[0]));\n}\n\nstatic int isight_mute_get(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct isight *isight = ctl->private_data;\n\t__be32 mute;\n\tint err;\n\n\terr = reg_read(isight, REG_MUTE, &mute);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue->value.integer.value[0] = !mute;\n\n\treturn 0;\n}\n\nstatic int isight_mute_put(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct isight *isight = ctl->private_data;\n\n\treturn reg_write(isight, REG_MUTE,\n\t\t\t (__force __be32)!value->value.integer.value[0]);\n}\n\nstatic int isight_create_mixer(struct isight *isight)\n{\n\tstatic const struct snd_kcontrol_new gain_control = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Capture Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = isight_gain_info,\n\t\t.get = isight_gain_get,\n\t\t.put = isight_gain_put,\n\t};\n\tstatic const struct snd_kcontrol_new mute_control = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Capture Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = isight_mute_get,\n\t\t.put = isight_mute_put,\n\t};\n\t__be32 value;\n\tstruct snd_kcontrol *ctl;\n\tint err;\n\n\terr = reg_read(isight, REG_GAIN_RAW_START, &value);\n\tif (err < 0)\n\t\treturn err;\n\tisight->gain_min = be32_to_cpu(value);\n\n\terr = reg_read(isight, REG_GAIN_RAW_END, &value);\n\tif (err < 0)\n\t\treturn err;\n\tisight->gain_max = be32_to_cpu(value);\n\n\tisight->gain_tlv[SNDRV_CTL_TLVO_TYPE] = SNDRV_CTL_TLVT_DB_MINMAX;\n\tisight->gain_tlv[SNDRV_CTL_TLVO_LEN] = 2 * sizeof(unsigned int);\n\n\terr = reg_read(isight, REG_GAIN_DB_START, &value);\n\tif (err < 0)\n\t\treturn err;\n\tisight->gain_tlv[SNDRV_CTL_TLVO_DB_MINMAX_MIN] =\n\t\t\t\t\t\t(s32)be32_to_cpu(value) * 100;\n\n\terr = reg_read(isight, REG_GAIN_DB_END, &value);\n\tif (err < 0)\n\t\treturn err;\n\tisight->gain_tlv[SNDRV_CTL_TLVO_DB_MINMAX_MAX] =\n\t\t\t\t\t\t(s32)be32_to_cpu(value) * 100;\n\n\tctl = snd_ctl_new1(&gain_control, isight);\n\tif (ctl)\n\t\tctl->tlv.p = isight->gain_tlv;\n\terr = snd_ctl_add(isight->card, ctl);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(isight->card, snd_ctl_new1(&mute_control, isight));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void isight_card_free(struct snd_card *card)\n{\n\tstruct isight *isight = card->private_data;\n\n\tfw_iso_resources_destroy(&isight->resources);\n}\n\nstatic u64 get_unit_base(struct fw_unit *unit)\n{\n\tstruct fw_csr_iterator i;\n\tint key, value;\n\n\tfw_csr_iterator_init(&i, unit->directory);\n\twhile (fw_csr_iterator_next(&i, &key, &value))\n\t\tif (key == CSR_OFFSET)\n\t\t\treturn CSR_REGISTER_BASE + value * 4;\n\treturn 0;\n}\n\nstatic int isight_probe(struct fw_unit *unit,\n\t\t\tconst struct ieee1394_device_id *id)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(unit);\n\tstruct snd_card *card;\n\tstruct isight *isight;\n\tint err;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,\n\t\t\t   sizeof(*isight), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tisight = card->private_data;\n\tisight->card = card;\n\tmutex_init(&isight->mutex);\n\tisight->unit = fw_unit_get(unit);\n\tisight->device = fw_dev;\n\tisight->audio_base = get_unit_base(unit);\n\tif (!isight->audio_base) {\n\t\tdev_err(&unit->device, \"audio unit base not found\\n\");\n\t\terr = -ENXIO;\n\t\tgoto error;\n\t}\n\tfw_iso_resources_init(&isight->resources, unit);\n\n\tcard->private_free = isight_card_free;\n\n\tstrcpy(card->driver, \"iSight\");\n\tstrcpy(card->shortname, \"Apple iSight\");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"Apple iSight (GUID %08x%08x) at %s, S%d\",\n\t\t fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t dev_name(&unit->device), 100 << fw_dev->max_speed);\n\tstrcpy(card->mixername, \"iSight\");\n\n\terr = isight_create_pcm(isight);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = isight_create_mixer(isight);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdev_set_drvdata(&unit->device, isight);\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\n\tmutex_destroy(&isight->mutex);\n\tfw_unit_put(isight->unit);\n\n\treturn err;\n}\n\nstatic void isight_bus_reset(struct fw_unit *unit)\n{\n\tstruct isight *isight = dev_get_drvdata(&unit->device);\n\n\tif (fw_iso_resources_update(&isight->resources) < 0) {\n\t\tisight_pcm_abort(isight);\n\n\t\tmutex_lock(&isight->mutex);\n\t\tisight_stop_streaming(isight);\n\t\tmutex_unlock(&isight->mutex);\n\t}\n}\n\nstatic void isight_remove(struct fw_unit *unit)\n{\n\tstruct isight *isight = dev_get_drvdata(&unit->device);\n\n\tisight_pcm_abort(isight);\n\n\tsnd_card_disconnect(isight->card);\n\n\tmutex_lock(&isight->mutex);\n\tisight_stop_streaming(isight);\n\tmutex_unlock(&isight->mutex);\n\n\t\n\tsnd_card_free(isight->card);\n\n\tmutex_destroy(&isight->mutex);\n\tfw_unit_put(isight->unit);\n}\n\nstatic const struct ieee1394_device_id isight_id_table[] = {\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = OUI_APPLE,\n\t\t.version      = SW_ISIGHT_AUDIO,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(ieee1394, isight_id_table);\n\nstatic struct fw_driver isight_driver = {\n\t.driver   = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.bus\t= &fw_bus_type,\n\t},\n\t.probe    = isight_probe,\n\t.update   = isight_bus_reset,\n\t.remove   = isight_remove,\n\t.id_table = isight_id_table,\n};\n\nstatic int __init alsa_isight_init(void)\n{\n\treturn driver_register(&isight_driver.driver);\n}\n\nstatic void __exit alsa_isight_exit(void)\n{\n\tdriver_unregister(&isight_driver.driver);\n}\n\nmodule_init(alsa_isight_init);\nmodule_exit(alsa_isight_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}