{
  "module_name": "bebob_maudio.c",
  "hash_id": "711c918868b66f4a192c56fd6b7421a3d3089fc7b7125dfe493827d4ebddfa39",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/bebob/bebob_maudio.c",
  "human_readable_source": "\n \n\n#include \"./bebob.h\"\n#include <sound/control.h>\n\n \n\n \n#define INFO_OFFSET_SW_DATE\t0x20\n\n \n#define MAUDIO_BOOTLOADER_CUE1\t0x00000001\n \n#define MAUDIO_BOOTLOADER_CUE2\t0x01110000\n \n#define MAUDIO_BOOTLOADER_CUE3\t0x00000000\n\n#define MAUDIO_SPECIFIC_ADDRESS\t0xffc700000000ULL\n\n#define METER_OFFSET\t\t0x00600000\n\n \n#define METER_SIZE_SPECIAL\t84\t \n#define METER_SIZE_FW410\t76\t \n#define METER_SIZE_AUDIOPHILE\t60\t \n#define METER_SIZE_SOLO\t\t52\t \n#define METER_SIZE_OZONIC\t48\n#define METER_SIZE_NRV10\t80\n\n \n#define ANA_IN\t\t\"Analog In\"\n#define ANA_OUT\t\t\"Analog Out\"\n#define DIG_IN\t\t\"Digital In\"\n#define SPDIF_IN\t\"S/PDIF In\"\n#define ADAT_IN\t\t\"ADAT In\"\n#define DIG_OUT\t\t\"Digital Out\"\n#define SPDIF_OUT\t\"S/PDIF Out\"\n#define ADAT_OUT\t\"ADAT Out\"\n#define STRM_IN\t\t\"Stream In\"\n#define AUX_OUT\t\t\"Aux Out\"\n#define HP_OUT\t\t\"HP Out\"\n \n#define UNKNOWN_METER\t\"Unknown\"\n\nstruct special_params {\n\tbool is1814;\n\tunsigned int clk_src;\n\tunsigned int dig_in_fmt;\n\tunsigned int dig_out_fmt;\n\tunsigned int clk_lock;\n\tstruct snd_ctl_elem_id *ctl_id_sync;\n};\n\n \nint snd_bebob_maudio_load_firmware(struct fw_unit *unit)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tint err, rcode;\n\tu64 date;\n\t__le32 *cues;\n\n\t \n\terr = snd_bebob_read_block(unit, INFO_OFFSET_SW_DATE,\n\t\t\t\t   &date, sizeof(u64));\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (date < 0x3230303730343031LL) {\n\t\tdev_err(&unit->device,\n\t\t\t\"Use firmware version 5058 or later\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tcues = kmalloc_array(3, sizeof(*cues), GFP_KERNEL);\n\tif (!cues)\n\t\treturn -ENOMEM;\n\n\tcues[0] = cpu_to_le32(MAUDIO_BOOTLOADER_CUE1);\n\tcues[1] = cpu_to_le32(MAUDIO_BOOTLOADER_CUE2);\n\tcues[2] = cpu_to_le32(MAUDIO_BOOTLOADER_CUE3);\n\n\trcode = fw_run_transaction(device->card, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\t\t   device->node_id, device->generation,\n\t\t\t\t   device->max_speed, BEBOB_ADDR_REG_REQ,\n\t\t\t\t   cues, 3 * sizeof(*cues));\n\tkfree(cues);\n\tif (rcode != RCODE_COMPLETE) {\n\t\tdev_err(&unit->device,\n\t\t\t\"Failed to send a cue to load firmware\\n\");\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstatic inline int\nget_meter(struct snd_bebob *bebob, void *buf, unsigned int size)\n{\n\treturn snd_fw_transaction(bebob->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t  MAUDIO_SPECIFIC_ADDRESS + METER_OFFSET,\n\t\t\t\t  buf, size, 0);\n}\n\nstatic int\ncheck_clk_sync(struct snd_bebob *bebob, unsigned int size, bool *sync)\n{\n\tint err;\n\tu8 *buf;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\terr = get_meter(bebob, buf, size);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\t*sync = (buf[size - 2] != 0xff);\nend:\n\tkfree(buf);\n\treturn err;\n}\n\n \nstatic int\navc_maudio_set_special_clk(struct snd_bebob *bebob, unsigned int clk_src,\n\t\t\t   unsigned int dig_in_fmt, unsigned int dig_out_fmt,\n\t\t\t   unsigned int clk_lock)\n{\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tint err;\n\tu8 *buf;\n\n\tif (amdtp_stream_running(&bebob->rx_stream) ||\n\t    amdtp_stream_running(&bebob->tx_stream))\n\t\treturn -EBUSY;\n\n\tbuf = kmalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0]  = 0x00;\t\t \n\tbuf[1]  = 0xff;\t\t \n\tbuf[2]  = 0x00;\t\t \n\tbuf[3]  = 0x04;\t\t \n\tbuf[4]  = 0x00;\t\t \n\tbuf[5]  = 0x04;\t\t \n\tbuf[6]  = 0xff & clk_src;\t \n\tbuf[7]  = 0xff & dig_in_fmt;\t \n\tbuf[8]  = 0xff & dig_out_fmt;\t \n\tbuf[9]  = 0xff & clk_lock;\t \n\tbuf[10] = 0x00;\t\t \n\tbuf[11] = 0x00;\t\t \n\n\terr = fcp_avc_transaction(bebob->unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) |\n\t\t\t\t  BIT(5) | BIT(6) | BIT(7) | BIT(8) |\n\t\t\t\t  BIT(9));\n\tif ((err > 0) && (err < 10))\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\tif (err < 0)\n\t\tgoto end;\n\n\tparams->clk_src\t\t= buf[6];\n\tparams->dig_in_fmt\t= buf[7];\n\tparams->dig_out_fmt\t= buf[8];\n\tparams->clk_lock\t= buf[9];\n\n\tif (params->ctl_id_sync)\n\t\tsnd_ctl_notify(bebob->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       params->ctl_id_sync);\n\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\nstatic void\nspecial_stream_formation_set(struct snd_bebob *bebob)\n{\n\tstatic const unsigned int ch_table[2][2][3] = {\n\t\t \n\t\t{ {  6,  6,  4 },\t \n\t\t  { 12,  8,  4 } },\t \n\t\t \n\t\t{ { 10, 10,  2 },\t \n\t\t  { 16, 12,  2 } }\t \n\t};\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tunsigned int i, max;\n\n\tmax = SND_BEBOB_STRM_FMT_ENTRIES - 1;\n\tif (!params->is1814)\n\t\tmax -= 2;\n\n\tfor (i = 0; i < max; i++) {\n\t\tbebob->tx_stream_formations[i + 1].pcm =\n\t\t\tch_table[AMDTP_IN_STREAM][params->dig_in_fmt][i / 2];\n\t\tbebob->tx_stream_formations[i + 1].midi = 1;\n\n\t\tbebob->rx_stream_formations[i + 1].pcm =\n\t\t\tch_table[AMDTP_OUT_STREAM][params->dig_out_fmt][i / 2];\n\t\tbebob->rx_stream_formations[i + 1].midi = 1;\n\t}\n}\n\nstatic int add_special_controls(struct snd_bebob *bebob);\nint\nsnd_bebob_maudio_special_discover(struct snd_bebob *bebob, bool is1814)\n{\n\tstruct special_params *params;\n\tint err;\n\n\tparams = devm_kzalloc(&bebob->card->card_dev,\n\t\t\t      sizeof(struct special_params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&bebob->mutex);\n\n\tbebob->maudio_special_quirk = (void *)params;\n\tparams->is1814 = is1814;\n\n\t \n\tbebob->rx_stream.context = ERR_PTR(-1);\n\tbebob->tx_stream.context = ERR_PTR(-1);\n\terr = avc_maudio_set_special_clk(bebob, 0x03, 0x00, 0x00, 0x00);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to initialize clock params: %d\\n\", err);\n\t\tgoto end;\n\t}\n\n\terr = add_special_controls(bebob);\n\tif (err < 0)\n\t\tgoto end;\n\n\tspecial_stream_formation_set(bebob);\n\n\tif (params->is1814) {\n\t\tbebob->midi_input_ports = 1;\n\t\tbebob->midi_output_ports = 1;\n\t} else {\n\t\tbebob->midi_input_ports = 2;\n\t\tbebob->midi_output_ports = 2;\n\t}\nend:\n\tmutex_unlock(&bebob->mutex);\n\treturn err;\n}\n\n \nstatic int special_get_rate(struct snd_bebob *bebob, unsigned int *rate)\n{\n\tint err, trials;\n\n\ttrials = 0;\n\tdo {\n\t\terr = avc_general_get_sig_fmt(bebob->unit, rate,\n\t\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\n\t} while (err == -EAGAIN && ++trials < 3);\n\n\treturn err;\n}\nstatic int special_set_rate(struct snd_bebob *bebob, unsigned int rate)\n{\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tint err;\n\n\terr = avc_general_set_sig_fmt(bebob->unit, rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_OUT, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tmsleep(100);\n\n\terr = avc_general_set_sig_fmt(bebob->unit, rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (params->ctl_id_sync)\n\t\tsnd_ctl_notify(bebob->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       params->ctl_id_sync);\nend:\n\treturn err;\n}\n\n \nstatic const enum snd_bebob_clock_type special_clk_types[] = {\n\tSND_BEBOB_CLOCK_TYPE_INTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_INTERNAL,\n};\nstatic int special_clk_get(struct snd_bebob *bebob, unsigned int *id)\n{\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\t*id = params->clk_src;\n\treturn 0;\n}\nstatic int special_clk_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\tstruct snd_ctl_elem_info *einf)\n{\n\tstatic const char *const special_clk_labels[] = {\n\t\t\"Internal with Digital Mute\",\n\t\t\"Digital\",\n\t\t\"Word Clock\",\n\t\t\"Internal\"\n\t};\n\treturn snd_ctl_enum_info(einf, 1, ARRAY_SIZE(special_clk_types),\n\t\t\t\t special_clk_labels);\n}\nstatic int special_clk_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t       struct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tuval->value.enumerated.item[0] = params->clk_src;\n\treturn 0;\n}\nstatic int special_clk_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t       struct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tint err, id;\n\n\tid = uval->value.enumerated.item[0];\n\tif (id >= ARRAY_SIZE(special_clk_types))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bebob->mutex);\n\n\terr = avc_maudio_set_special_clk(bebob, id,\n\t\t\t\t\t params->dig_in_fmt,\n\t\t\t\t\t params->dig_out_fmt,\n\t\t\t\t\t params->clk_lock);\n\tmutex_unlock(&bebob->mutex);\n\n\tif (err >= 0)\n\t\terr = 1;\n\n\treturn err;\n}\nstatic const struct snd_kcontrol_new special_clk_ctl = {\n\t.name\t= \"Clock Source\",\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access\t= SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info\t= special_clk_ctl_info,\n\t.get\t= special_clk_ctl_get,\n\t.put\t= special_clk_ctl_put\n};\n\n \nstatic int special_sync_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_info *einf)\n{\n\teinf->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\teinf->count = 1;\n\teinf->value.integer.min = 0;\n\teinf->value.integer.max = 1;\n\n\treturn 0;\n}\nstatic int special_sync_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\tstruct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tint err;\n\tbool synced = 0;\n\n\terr = check_clk_sync(bebob, METER_SIZE_SPECIAL, &synced);\n\tif (err >= 0)\n\t\tuval->value.integer.value[0] = synced;\n\n\treturn 0;\n}\nstatic const struct snd_kcontrol_new special_sync_ctl = {\n\t.name\t= \"Sync Status\",\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access\t= SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info\t= special_sync_ctl_info,\n\t.get\t= special_sync_ctl_get,\n};\n\n \nstatic const char *const special_dig_in_iface_labels[] = {\n\t\"S/PDIF Optical\", \"S/PDIF Coaxial\", \"ADAT Optical\"\n};\nstatic int special_dig_in_iface_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_info *einf)\n{\n\treturn snd_ctl_enum_info(einf, 1,\n\t\t\t\t ARRAY_SIZE(special_dig_in_iface_labels),\n\t\t\t\t special_dig_in_iface_labels);\n}\nstatic int special_dig_in_iface_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tunsigned int dig_in_iface;\n\tint err, val;\n\n\tmutex_lock(&bebob->mutex);\n\n\terr = avc_audio_get_selector(bebob->unit, 0x00, 0x04,\n\t\t\t\t     &dig_in_iface);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to get digital input interface: %d\\n\", err);\n\t\tgoto end;\n\t}\n\n\t \n\tval = (params->dig_in_fmt << 1) | (dig_in_iface & 0x01);\n\n\t \n\tif (val > 2)\n\t\tval = 2;\n\n\tuval->value.enumerated.item[0] = val;\nend:\n\tmutex_unlock(&bebob->mutex);\n\treturn err;\n}\nstatic int special_dig_in_iface_ctl_set(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tunsigned int id, dig_in_fmt, dig_in_iface;\n\tint err;\n\n\tid = uval->value.enumerated.item[0];\n\tif (id >= ARRAY_SIZE(special_dig_in_iface_labels))\n\t\treturn -EINVAL;\n\n\t \n\tdig_in_fmt = (id >> 1) & 0x01;\n\tdig_in_iface = id & 0x01;\n\n\tmutex_lock(&bebob->mutex);\n\n\terr = avc_maudio_set_special_clk(bebob,\n\t\t\t\t\t params->clk_src,\n\t\t\t\t\t dig_in_fmt,\n\t\t\t\t\t params->dig_out_fmt,\n\t\t\t\t\t params->clk_lock);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif (params->dig_in_fmt > 0) {\n\t\terr = 1;\n\t\tgoto end;\n\t}\n\n\t \n\terr = avc_audio_set_selector(bebob->unit, 0x00, 0x04, dig_in_iface);\n\tif (err < 0)\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to set digital input interface: %d\\n\", err);\n\terr = 1;\nend:\n\tspecial_stream_formation_set(bebob);\n\tmutex_unlock(&bebob->mutex);\n\treturn err;\n}\nstatic const struct snd_kcontrol_new special_dig_in_iface_ctl = {\n\t.name\t= \"Digital Input Interface\",\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access\t= SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info\t= special_dig_in_iface_ctl_info,\n\t.get\t= special_dig_in_iface_ctl_get,\n\t.put\t= special_dig_in_iface_ctl_set\n};\n\n \nstatic const char *const special_dig_out_iface_labels[] = {\n\t\"S/PDIF Optical and Coaxial\", \"ADAT Optical\"\n};\nstatic int special_dig_out_iface_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t  struct snd_ctl_elem_info *einf)\n{\n\treturn snd_ctl_enum_info(einf, 1,\n\t\t\t\t ARRAY_SIZE(special_dig_out_iface_labels),\n\t\t\t\t special_dig_out_iface_labels);\n}\nstatic int special_dig_out_iface_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tmutex_lock(&bebob->mutex);\n\tuval->value.enumerated.item[0] = params->dig_out_fmt;\n\tmutex_unlock(&bebob->mutex);\n\treturn 0;\n}\nstatic int special_dig_out_iface_ctl_set(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_value *uval)\n{\n\tstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tunsigned int id;\n\tint err;\n\n\tid = uval->value.enumerated.item[0];\n\tif (id >= ARRAY_SIZE(special_dig_out_iface_labels))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bebob->mutex);\n\n\terr = avc_maudio_set_special_clk(bebob,\n\t\t\t\t\t params->clk_src,\n\t\t\t\t\t params->dig_in_fmt,\n\t\t\t\t\t id, params->clk_lock);\n\tif (err >= 0) {\n\t\tspecial_stream_formation_set(bebob);\n\t\terr = 1;\n\t}\n\n\tmutex_unlock(&bebob->mutex);\n\treturn err;\n}\nstatic const struct snd_kcontrol_new special_dig_out_iface_ctl = {\n\t.name\t= \"Digital Output Interface\",\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access\t= SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info\t= special_dig_out_iface_ctl_info,\n\t.get\t= special_dig_out_iface_ctl_get,\n\t.put\t= special_dig_out_iface_ctl_set\n};\n\nstatic int add_special_controls(struct snd_bebob *bebob)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct special_params *params = bebob->maudio_special_quirk;\n\tint err;\n\n\tkctl = snd_ctl_new1(&special_clk_ctl, bebob);\n\terr = snd_ctl_add(bebob->card, kctl);\n\tif (err < 0)\n\t\tgoto end;\n\n\tkctl = snd_ctl_new1(&special_sync_ctl, bebob);\n\terr = snd_ctl_add(bebob->card, kctl);\n\tif (err < 0)\n\t\tgoto end;\n\tparams->ctl_id_sync = &kctl->id;\n\n\tkctl = snd_ctl_new1(&special_dig_in_iface_ctl, bebob);\n\terr = snd_ctl_add(bebob->card, kctl);\n\tif (err < 0)\n\t\tgoto end;\n\n\tkctl = snd_ctl_new1(&special_dig_out_iface_ctl, bebob);\n\terr = snd_ctl_add(bebob->card, kctl);\nend:\n\treturn err;\n}\n\n \nstatic const char *const special_meter_labels[] = {\n\tANA_IN, ANA_IN, ANA_IN, ANA_IN,\n\tSPDIF_IN,\n\tADAT_IN, ADAT_IN, ADAT_IN, ADAT_IN,\n\tANA_OUT, ANA_OUT,\n\tSPDIF_OUT,\n\tADAT_OUT, ADAT_OUT, ADAT_OUT, ADAT_OUT,\n\tHP_OUT, HP_OUT,\n\tAUX_OUT\n};\nstatic int\nspecial_meter_get(struct snd_bebob *bebob, u32 *target, unsigned int size)\n{\n\t__be16 *buf;\n\tunsigned int i, c, channels;\n\tint err;\n\n\tchannels = ARRAY_SIZE(special_meter_labels) * 2;\n\tif (size < channels * sizeof(u32))\n\t\treturn -EINVAL;\n\n\t \n\tbuf = kmalloc(METER_SIZE_SPECIAL - 4, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\terr = get_meter(bebob, (void *)buf, METER_SIZE_SPECIAL - 4);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\ti = 0;\n\tfor (c = 2; c < channels + 2; c++)\n\t\ttarget[i++] = be16_to_cpu(buf[c]) << 16;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\n \nstatic const char *const fw410_meter_labels[] = {\n\tANA_IN, DIG_IN,\n\tANA_OUT, ANA_OUT, ANA_OUT, ANA_OUT, DIG_OUT,\n\tHP_OUT\n};\nstatic const char *const audiophile_meter_labels[] = {\n\tANA_IN, DIG_IN,\n\tANA_OUT, ANA_OUT, DIG_OUT,\n\tHP_OUT, AUX_OUT,\n};\nstatic const char *const solo_meter_labels[] = {\n\tANA_IN, DIG_IN,\n\tSTRM_IN, STRM_IN,\n\tANA_OUT, DIG_OUT\n};\n\n \nstatic const char *const ozonic_meter_labels[] = {\n\tANA_IN, ANA_IN,\n\tSTRM_IN, STRM_IN,\n\tANA_OUT, ANA_OUT\n};\n \nstatic const char *const nrv10_meter_labels[] = {\n\tANA_IN, ANA_IN, ANA_IN, ANA_IN,\n\tDIG_IN,\n\tANA_OUT, ANA_OUT, ANA_OUT, ANA_OUT,\n\tDIG_IN\n};\nstatic int\nnormal_meter_get(struct snd_bebob *bebob, u32 *buf, unsigned int size)\n{\n\tconst struct snd_bebob_meter_spec *spec = bebob->spec->meter;\n\tunsigned int c, channels;\n\tint err;\n\n\tchannels = spec->num * 2;\n\tif (size < channels * sizeof(u32))\n\t\treturn -EINVAL;\n\n\terr = get_meter(bebob, (void *)buf, size);\n\tif (err < 0)\n\t\tgoto end;\n\n\tfor (c = 0; c < channels; c++)\n\t\tbe32_to_cpus(&buf[c]);\n\n\t \n\tif (spec->labels == solo_meter_labels) {\n\t\tswap(buf[4], buf[6]);\n\t\tswap(buf[5], buf[7]);\n\t}\nend:\n\treturn err;\n}\n\n \nstatic const struct snd_bebob_rate_spec special_rate_spec = {\n\t.get\t= &special_get_rate,\n\t.set\t= &special_set_rate,\n};\nstatic const struct snd_bebob_clock_spec special_clk_spec = {\n\t.num\t= ARRAY_SIZE(special_clk_types),\n\t.types\t= special_clk_types,\n\t.get\t= &special_clk_get,\n};\nstatic const struct snd_bebob_meter_spec special_meter_spec = {\n\t.num\t= ARRAY_SIZE(special_meter_labels),\n\t.labels\t= special_meter_labels,\n\t.get\t= &special_meter_get\n};\nconst struct snd_bebob_spec maudio_special_spec = {\n\t.clock\t= &special_clk_spec,\n\t.rate\t= &special_rate_spec,\n\t.meter\t= &special_meter_spec\n};\n\n \nstatic const struct snd_bebob_rate_spec usual_rate_spec = {\n\t.get\t= &snd_bebob_stream_get_rate,\n\t.set\t= &snd_bebob_stream_set_rate,\n};\nstatic const struct snd_bebob_meter_spec fw410_meter_spec = {\n\t.num\t= ARRAY_SIZE(fw410_meter_labels),\n\t.labels\t= fw410_meter_labels,\n\t.get\t= &normal_meter_get\n};\nconst struct snd_bebob_spec maudio_fw410_spec = {\n\t.clock\t= NULL,\n\t.rate\t= &usual_rate_spec,\n\t.meter\t= &fw410_meter_spec\n};\n\n \nstatic const struct snd_bebob_meter_spec audiophile_meter_spec = {\n\t.num\t= ARRAY_SIZE(audiophile_meter_labels),\n\t.labels\t= audiophile_meter_labels,\n\t.get\t= &normal_meter_get\n};\nconst struct snd_bebob_spec maudio_audiophile_spec = {\n\t.clock\t= NULL,\n\t.rate\t= &usual_rate_spec,\n\t.meter\t= &audiophile_meter_spec\n};\n\n \nstatic const struct snd_bebob_meter_spec solo_meter_spec = {\n\t.num\t= ARRAY_SIZE(solo_meter_labels),\n\t.labels\t= solo_meter_labels,\n\t.get\t= &normal_meter_get\n};\nconst struct snd_bebob_spec maudio_solo_spec = {\n\t.clock\t= NULL,\n\t.rate\t= &usual_rate_spec,\n\t.meter\t= &solo_meter_spec\n};\n\n \nstatic const struct snd_bebob_meter_spec ozonic_meter_spec = {\n\t.num\t= ARRAY_SIZE(ozonic_meter_labels),\n\t.labels\t= ozonic_meter_labels,\n\t.get\t= &normal_meter_get\n};\nconst struct snd_bebob_spec maudio_ozonic_spec = {\n\t.clock\t= NULL,\n\t.rate\t= &usual_rate_spec,\n\t.meter\t= &ozonic_meter_spec\n};\n\n \nstatic const struct snd_bebob_meter_spec nrv10_meter_spec = {\n\t.num\t= ARRAY_SIZE(nrv10_meter_labels),\n\t.labels\t= nrv10_meter_labels,\n\t.get\t= &normal_meter_get\n};\nconst struct snd_bebob_spec maudio_nrv10_spec = {\n\t.clock\t= NULL,\n\t.rate\t= &usual_rate_spec,\n\t.meter\t= &nrv10_meter_spec\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}