{
  "module_name": "bebob_stream.c",
  "hash_id": "e959e3dea51d7ac1a0e7ac6a3271b71afdd1cd6d2687b38f35ea98ea9c77484a",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/bebob/bebob_stream.c",
  "human_readable_source": "\n \n\n#include \"./bebob.h\"\n\n#define READY_TIMEOUT_MS\t4000\n\n \n\n \n#define FORMAT_MAXIMUM_LENGTH 128\n\nconst unsigned int snd_bebob_rate_table[SND_BEBOB_STRM_FMT_ENTRIES] = {\n\t[0] = 32000,\n\t[1] = 44100,\n\t[2] = 48000,\n\t[3] = 88200,\n\t[4] = 96000,\n\t[5] = 176400,\n\t[6] = 192000,\n};\n\n \nstatic const unsigned int bridgeco_freq_table[] = {\n\t[0] = 0x02,\n\t[1] = 0x03,\n\t[2] = 0x04,\n\t[3] = 0x0a,\n\t[4] = 0x05,\n\t[5] = 0x06,\n\t[6] = 0x07,\n};\n\nstatic int\nget_formation_index(unsigned int rate, unsigned int *index)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_bebob_rate_table); i++) {\n\t\tif (snd_bebob_rate_table[i] == rate) {\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nint\nsnd_bebob_stream_get_rate(struct snd_bebob *bebob, unsigned int *curr_rate)\n{\n\tunsigned int tx_rate, rx_rate, trials;\n\tint err;\n\n\ttrials = 0;\n\tdo {\n\t\terr = avc_general_get_sig_fmt(bebob->unit, &tx_rate,\n\t\t\t\t\t      AVC_GENERAL_PLUG_DIR_OUT, 0);\n\t} while (err == -EAGAIN && ++trials < 3);\n\tif (err < 0)\n\t\tgoto end;\n\n\ttrials = 0;\n\tdo {\n\t\terr = avc_general_get_sig_fmt(bebob->unit, &rx_rate,\n\t\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\n\t} while (err == -EAGAIN && ++trials < 3);\n\tif (err < 0)\n\t\tgoto end;\n\n\t*curr_rate = rx_rate;\n\tif (rx_rate == tx_rate)\n\t\tgoto end;\n\n\t \n\terr = avc_general_set_sig_fmt(bebob->unit, rx_rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\nend:\n\treturn err;\n}\n\nint\nsnd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)\n{\n\tint err;\n\n\terr = avc_general_set_sig_fmt(bebob->unit, rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_OUT, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = avc_general_set_sig_fmt(bebob->unit, rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tmsleep(300);\nend:\n\treturn err;\n}\n\nint snd_bebob_stream_get_clock_src(struct snd_bebob *bebob,\n\t\t\t\t   enum snd_bebob_clock_type *src)\n{\n\tconst struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;\n\tu8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];\n\tunsigned int id;\n\tenum avc_bridgeco_plug_type type;\n\tint err = 0;\n\n\t \n\tif (clk_spec) {\n\t\terr = clk_spec->get(bebob, &id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"fail to get clock source: %d\\n\", err);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (id >= clk_spec->num) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"clock source %d out of range 0..%d\\n\",\n\t\t\t\tid, clk_spec->num - 1);\n\t\t\terr = -EIO;\n\t\t\tgoto end;\n\t\t}\n\n\t\t*src = clk_spec->types[id];\n\t\tgoto end;\n\t}\n\n\t \n\tif (bebob->sync_input_plug < 0) {\n\t\t*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;\n\t\tgoto end;\n\t}\n\n\t \n\tavc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,\n\t\t\t\t   bebob->sync_input_plug);\n\terr = avc_bridgeco_get_plug_input(bebob->unit, addr, input);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to get an input for MSU in plug %d: %d\\n\",\n\t\t\tbebob->sync_input_plug, err);\n\t\tgoto end;\n\t}\n\n\t \n\tif (input[0] == 0xff) {\n\t\t*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;\n\t\tgoto end;\n\t}\n\n\t \n\tif (input[0] == AVC_BRIDGECO_PLUG_DIR_OUT) {\n\t\t \n\t\tif (input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT &&\n\t\t    input[2] == 0x0c) {\n\t\t\t*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;\n\t\t\tgoto end;\n\t\t}\n\t \n\t} else if (input[1] == AVC_BRIDGECO_PLUG_MODE_UNIT) {\n\t\tif (input[2] == AVC_BRIDGECO_PLUG_UNIT_ISOC) {\n\t\t\tif (input[3] == 0x00) {\n\t\t\t\t \n\t\t\t\t*src = SND_BEBOB_CLOCK_TYPE_SYT;\n\t\t\t\tgoto end;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if (input[2] == AVC_BRIDGECO_PLUG_UNIT_EXT) {\n\t\t\t \n\t\t\tavc_bridgeco_fill_unit_addr(addr,\n\t\t\t\t\t\t    AVC_BRIDGECO_PLUG_DIR_IN,\n\t\t\t\t\t\t    AVC_BRIDGECO_PLUG_UNIT_EXT,\n\t\t\t\t\t\t    input[3]);\n\t\t\terr = avc_bridgeco_get_plug_type(bebob->unit, addr,\n\t\t\t\t\t\t\t &type);\n\t\t\tif (err < 0)\n\t\t\t\tgoto end;\n\n\t\t\tif (type == AVC_BRIDGECO_PLUG_TYPE_DIG) {\n\t\t\t\t \n\t\t\t\t*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;\n\t\t\t\tgoto end;\n\t\t\t} else if (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {\n\t\t\t\t \n\t\t\t\t*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;\n\t\t\t\tgoto end;\n\t\t\t} else if (type == AVC_BRIDGECO_PLUG_TYPE_ADDITION) {\n\t\t\t\t \n\t\t\t\t*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\terr = -EIO;\nend:\n\treturn err;\n}\n\nstatic int map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)\n{\n\tunsigned int sec, sections, ch, channels;\n\tunsigned int pcm, midi, location;\n\tunsigned int stm_pos, sec_loc, pos;\n\tu8 *buf, addr[AVC_BRIDGECO_ADDR_BYTES], type;\n\tenum avc_bridgeco_plug_dir dir;\n\tint err;\n\n\t \n\tbuf = kzalloc(256, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (s == &bebob->tx_stream)\n\t\tdir = AVC_BRIDGECO_PLUG_DIR_OUT;\n\telse\n\t\tdir = AVC_BRIDGECO_PLUG_DIR_IN;\n\n\tavc_bridgeco_fill_unit_addr(addr, dir, AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\n\terr = avc_bridgeco_get_plug_ch_pos(bebob->unit, addr, buf, 256);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to get channel position for isoc %s plug 0: %d\\n\",\n\t\t\t(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? \"in\" : \"out\",\n\t\t\terr);\n\t\tgoto end;\n\t}\n\tpos = 0;\n\n\t \n\tpcm = 0;\n\tmidi = 0;\n\n\t \n\tsections = buf[pos++];\n\n\tfor (sec = 0; sec < sections; sec++) {\n\t\t \n\t\tavc_bridgeco_fill_unit_addr(addr, dir,\n\t\t\t\t\t    AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\n\t\terr = avc_bridgeco_get_plug_section_type(bebob->unit, addr,\n\t\t\t\t\t\t\t sec, &type);\n\t\tif (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to get section type for isoc %s plug 0: %d\\n\",\n\t\t\t\t(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? \"in\" :\n\t\t\t\t\t\t\t\t    \"out\",\n\t\t\t\terr);\n\t\t\tgoto end;\n\t\t}\n\t\t \n\t\tif (type == 0xff) {\n\t\t\terr = -ENOSYS;\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\tchannels = buf[pos++];\n\n\t\tfor (ch = 0; ch < channels; ch++) {\n\t\t\t \n\t\t\tstm_pos = buf[pos++] - 1;\n\t\t\t \n\t\t\tsec_loc = buf[pos++] - 1;\n\n\t\t\t \n\t\t\tif (sec_loc >= channels)\n\t\t\t\tsec_loc = ch;\n\n\t\t\tswitch (type) {\n\t\t\t \n\t\t\tcase 0x0a:\n\t\t\t\t \n\t\t\t\tif ((midi > 0) && (stm_pos != midi)) {\n\t\t\t\t\terr = -ENOSYS;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tamdtp_am824_set_midi_position(s, stm_pos);\n\t\t\t\tmidi = stm_pos;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x01:\t \n\t\t\tcase 0x02:\t \n\t\t\tcase 0x03:\t \n\t\t\tcase 0x04:\t \n\t\t\tcase 0x05:\t \n\t\t\tcase 0x06:\t \n\t\t\tcase 0x07:\t \n\t\t\t \n\t\t\tcase 0x08:\t \n\t\t\tcase 0x09:\t \n\t\t\tdefault:\n\t\t\t\tlocation = pcm + sec_loc;\n\t\t\t\tif (location >= AM824_MAX_CHANNELS_FOR_PCM) {\n\t\t\t\t\terr = -ENOSYS;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tamdtp_am824_set_pcm_position(s, location,\n\t\t\t\t\t\t\t     stm_pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (type != 0x0a)\n\t\t\tpcm += channels;\n\t\telse\n\t\t\tmidi += channels;\n\t}\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int\ncheck_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)\n{\n\tstruct cmp_connection *conn;\n\tbool used;\n\tint err;\n\n\tif (s == &bebob->tx_stream)\n\t\tconn = &bebob->out_conn;\n\telse\n\t\tconn = &bebob->in_conn;\n\n\terr = cmp_connection_check_used(conn, &used);\n\tif ((err >= 0) && used && !amdtp_stream_running(s)) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"Connection established by others: %cPCR[%d]\\n\",\n\t\t\t(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\n\t\t\tconn->pcr_index);\n\t\terr = -EBUSY;\n\t}\n\n\treturn err;\n}\n\nstatic void break_both_connections(struct snd_bebob *bebob)\n{\n\tcmp_connection_break(&bebob->in_conn);\n\tcmp_connection_break(&bebob->out_conn);\n}\n\nstatic int start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\tint err = 0;\n\n\tif (stream == &bebob->rx_stream)\n\t\tconn = &bebob->in_conn;\n\telse\n\t\tconn = &bebob->out_conn;\n\n\t \n\tif (bebob->maudio_special_quirk == NULL) {\n\t\terr = map_data_channels(bebob, stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = cmp_connection_establish(conn);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn amdtp_domain_add_stream(&bebob->domain, stream,\n\t\t\t\t       conn->resources.channel, conn->speed);\n}\n\nstatic int init_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)\n{\n\tunsigned int flags = CIP_BLOCKING;\n\tenum amdtp_stream_direction dir_stream;\n\tstruct cmp_connection *conn;\n\tenum cmp_direction dir_conn;\n\tint err;\n\n\tif (stream == &bebob->tx_stream) {\n\t\tdir_stream = AMDTP_IN_STREAM;\n\t\tconn = &bebob->out_conn;\n\t\tdir_conn = CMP_OUTPUT;\n\t} else {\n\t\tdir_stream = AMDTP_OUT_STREAM;\n\t\tconn = &bebob->in_conn;\n\t\tdir_conn = CMP_INPUT;\n\t}\n\n\tif (stream == &bebob->tx_stream) {\n\t\tif (bebob->quirks & SND_BEBOB_QUIRK_WRONG_DBC)\n\t\t\tflags |= CIP_EMPTY_HAS_WRONG_DBC;\n\t}\n\n\terr = cmp_connection_init(conn, bebob->unit, dir_conn, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_am824_init(stream, bebob->unit, dir_stream, flags);\n\tif (err < 0) {\n\t\tcmp_connection_destroy(conn);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void destroy_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)\n{\n\tamdtp_stream_destroy(stream);\n\n\tif (stream == &bebob->tx_stream)\n\t\tcmp_connection_destroy(&bebob->out_conn);\n\telse\n\t\tcmp_connection_destroy(&bebob->in_conn);\n}\n\nint snd_bebob_stream_init_duplex(struct snd_bebob *bebob)\n{\n\tint err;\n\n\terr = init_stream(bebob, &bebob->tx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(bebob, &bebob->rx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(bebob, &bebob->tx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&bebob->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(bebob, &bebob->tx_stream);\n\t\tdestroy_stream(bebob, &bebob->rx_stream);\n\t}\n\n\treturn err;\n}\n\nstatic int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,\n\t\t\t  unsigned int rate, unsigned int index)\n{\n\tunsigned int pcm_channels;\n\tunsigned int midi_ports;\n\tstruct cmp_connection *conn;\n\tint err;\n\n\tif (stream == &bebob->tx_stream) {\n\t\tpcm_channels = bebob->tx_stream_formations[index].pcm;\n\t\tmidi_ports = bebob->midi_input_ports;\n\t\tconn = &bebob->out_conn;\n\t} else {\n\t\tpcm_channels = bebob->rx_stream_formations[index].pcm;\n\t\tmidi_ports = bebob->midi_output_ports;\n\t\tconn = &bebob->in_conn;\n\t}\n\n\terr = amdtp_am824_set_parameters(stream, rate, pcm_channels, midi_ports, false);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));\n}\n\nint snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate,\n\t\t\t\t    unsigned int frames_per_period,\n\t\t\t\t    unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\t \n\t \n\terr = check_connection_used_by_others(bebob, &bebob->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bebob->spec->rate->get(bebob, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0)\n\t\trate = curr_rate;\n\tif (curr_rate != rate) {\n\t\tamdtp_domain_stop(&bebob->domain);\n\t\tbreak_both_connections(bebob);\n\n\t\tcmp_connection_release(&bebob->out_conn);\n\t\tcmp_connection_release(&bebob->in_conn);\n\t}\n\n\tif (bebob->substreams_counter == 0 || curr_rate != rate) {\n\t\tunsigned int index;\n\n\t\t \n\t\t \n\t\t \n\t\t\n\t\t\n\t\terr = bebob->spec->rate->set(bebob, rate);\n\t\tif (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"fail to set sampling rate: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = get_formation_index(rate, &index);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(bebob, &bebob->tx_stream, rate, index);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(bebob, &bebob->rx_stream, rate, index);\n\t\tif (err < 0) {\n\t\t\tcmp_connection_release(&bebob->out_conn);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&bebob->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tcmp_connection_release(&bebob->out_conn);\n\t\t\tcmp_connection_release(&bebob->in_conn);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_bebob_stream_start_duplex(struct snd_bebob *bebob)\n{\n\tint err;\n\n\t\n\tif (bebob->substreams_counter == 0)\n\t\treturn -EIO;\n\n\t\n\tif (amdtp_streaming_error(&bebob->rx_stream) ||\n\t    amdtp_streaming_error(&bebob->tx_stream)) {\n\t\tamdtp_domain_stop(&bebob->domain);\n\t\tbreak_both_connections(bebob);\n\t}\n\n\tif (!amdtp_stream_running(&bebob->rx_stream)) {\n\t\tenum snd_bebob_clock_type src;\n\t\tunsigned int curr_rate;\n\t\tunsigned int tx_init_skip_cycles;\n\n\t\tif (bebob->maudio_special_quirk) {\n\t\t\terr = bebob->spec->rate->get(bebob, &curr_rate);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = snd_bebob_stream_get_clock_src(bebob, &src);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = start_stream(bebob, &bebob->rx_stream);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = start_stream(bebob, &bebob->tx_stream);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!(bebob->quirks & SND_BEBOB_QUIRK_INITIAL_DISCONTINUOUS_DBC))\n\t\t\ttx_init_skip_cycles = 0;\n\t\telse\n\t\t\ttx_init_skip_cycles = 16000;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&bebob->domain, tx_init_skip_cycles, true, false);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\t\n\t\t\n\t\t\n\t\tif (bebob->maudio_special_quirk) {\n\t\t\terr = bebob->spec->rate->set(bebob, curr_rate);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\t\"fail to ensure sampling rate: %d\\n\",\n\t\t\t\t\terr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\tif (!amdtp_domain_wait_ready(&bebob->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&bebob->domain);\n\tbreak_both_connections(bebob);\n\treturn err;\n}\n\nvoid snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)\n{\n\tif (bebob->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&bebob->domain);\n\t\tbreak_both_connections(bebob);\n\n\t\tcmp_connection_release(&bebob->out_conn);\n\t\tcmp_connection_release(&bebob->in_conn);\n\t}\n}\n\n \nvoid snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)\n{\n\tamdtp_domain_destroy(&bebob->domain);\n\n\tdestroy_stream(bebob, &bebob->tx_stream);\n\tdestroy_stream(bebob, &bebob->rx_stream);\n}\n\n \nstatic int\nparse_stream_formation(u8 *buf, unsigned int len,\n\t\t       struct snd_bebob_stream_formation *formation)\n{\n\tunsigned int i, e, channels, format;\n\n\t \n\tif ((buf[0] != 0x90) || (buf[1] != 0x40))\n\t\treturn -ENOSYS;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bridgeco_freq_table); i++) {\n\t\tif (buf[2] == bridgeco_freq_table[i])\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(bridgeco_freq_table))\n\t\treturn -ENOSYS;\n\n\t \n\tmemset(&formation[i], 0, sizeof(struct snd_bebob_stream_formation));\n\n\tfor (e = 0; e < buf[4]; e++) {\n\t\tchannels = buf[5 + e * 2];\n\t\tformat = buf[6 + e * 2];\n\n\t\tswitch (format) {\n\t\t \n\t\tcase 0x00:\n\t\t \n\t\tcase 0x06:\t \n\t\t\tformation[i].pcm += channels;\n\t\t\tbreak;\n\t\t \n\t\tcase 0x0d:\n\t\t\tformation[i].midi += channels;\n\t\t\tbreak;\n\t\t \n\t\tcase 0x01:\n\t\tcase 0x02:\n\t\tcase 0x03:\n\t\tcase 0x04:\n\t\tcase 0x05:\n\t\t \n\t\tcase 0x07:\t \n\t\tcase 0x0c:\t \n\t\t \n\t\tcase 0x08:\t \n\t\tcase 0x09:\t \n\t\tcase 0x0a:\t \n\t\tcase 0x0b:\t \n\t\t \n\t\tcase 0x40:\n\t\t \n\t\tcase 0xff:\n\t\tdefault:\n\t\t\treturn -ENOSYS;\t \n\t\t}\n\t}\n\n\tif (formation[i].pcm  > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    formation[i].midi > AM824_MAX_CHANNELS_FOR_MIDI)\n\t\treturn -ENOSYS;\n\n\treturn 0;\n}\n\nstatic int fill_stream_formations(struct snd_bebob *bebob, u8 addr[AVC_BRIDGECO_ADDR_BYTES],\n\t\t\t\t  enum avc_bridgeco_plug_dir plug_dir, unsigned int plug_id,\n\t\t\t\t  struct snd_bebob_stream_formation *formations)\n{\n\tenum avc_bridgeco_plug_type plug_type;\n\tu8 *buf;\n\tunsigned int len, eid;\n\tint err;\n\n\tavc_bridgeco_fill_unit_addr(addr, plug_dir, AVC_BRIDGECO_PLUG_UNIT_ISOC, plug_id);\n\n\terr = avc_bridgeco_get_plug_type(bebob->unit, addr, &plug_type);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"Fail to get type for isoc %d plug 0: %d\\n\", plug_dir, err);\n\t\treturn err;\n\t} else if (plug_type != AVC_BRIDGECO_PLUG_TYPE_ISOC)\n\t\treturn -ENXIO;\n\n\tbuf = kmalloc(FORMAT_MAXIMUM_LENGTH, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (eid = 0; eid < SND_BEBOB_STRM_FMT_ENTRIES; ++eid) {\n\t\tavc_bridgeco_fill_unit_addr(addr, plug_dir, AVC_BRIDGECO_PLUG_UNIT_ISOC, plug_id);\n\n\t\tlen = FORMAT_MAXIMUM_LENGTH;\n\t\terr = avc_bridgeco_get_plug_strm_fmt(bebob->unit, addr, buf, &len, eid);\n\t\t \n\t\tif (err == -EINVAL && eid > 0) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t} else if (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"fail to get stream format %d for isoc %d plug %d:%d\\n\",\n\t\t\t\teid, plug_dir, plug_id, err);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = parse_stream_formation(buf, len, formations);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int detect_midi_ports(struct snd_bebob *bebob,\n\t\t\t     const struct snd_bebob_stream_formation *formats,\n\t\t\t     u8 addr[AVC_BRIDGECO_ADDR_BYTES], enum avc_bridgeco_plug_dir plug_dir,\n\t\t\t     unsigned int plug_count, unsigned int *midi_ports)\n{\n\tint i;\n\tint err = 0;\n\n\t*midi_ports = 0;\n\n\t \n\tfor (i = 0; i < SND_BEBOB_STRM_FMT_ENTRIES; ++i) {\n\t\tif (formats[i].midi > 0)\n\t\t\tbreak;\n\t}\n\tif (i >= SND_BEBOB_STRM_FMT_ENTRIES)\n\t\treturn 0;\n\n\tfor (i = 0; i < plug_count; ++i) {\n\t\tenum avc_bridgeco_plug_type plug_type;\n\t\tunsigned int ch_count;\n\n\t\tavc_bridgeco_fill_unit_addr(addr, plug_dir, AVC_BRIDGECO_PLUG_UNIT_EXT, i);\n\n\t\terr = avc_bridgeco_get_plug_type(bebob->unit, addr, &plug_type);\n\t\tif (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"fail to get type for external %d plug %d: %d\\n\",\n\t\t\t\tplug_dir, i, err);\n\t\t\tbreak;\n\t\t} else if (plug_type != AVC_BRIDGECO_PLUG_TYPE_MIDI) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = avc_bridgeco_get_plug_ch_count(bebob->unit, addr, &ch_count);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t \n\t\t \n\t\t \n\t\tif (ch_count == 0)\n\t\t\tch_count = 1;\n\t\t*midi_ports += ch_count;\n\t}\n\n\treturn err;\n}\n\nstatic int\nseek_msu_sync_input_plug(struct snd_bebob *bebob)\n{\n\tu8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];\n\tunsigned int i;\n\tenum avc_bridgeco_plug_type type;\n\tint err;\n\n\t \n\terr = avc_general_get_plug_info(bebob->unit, 0x0c, 0x00, 0x00, plugs);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\t\"fail to get info for MSU in/out plugs: %d\\n\",\n\t\t\terr);\n\t\tgoto end;\n\t}\n\n\t \n\tbebob->sync_input_plug = -1;\n\tfor (i = 0; i < plugs[0]; i++) {\n\t\tavc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN, i);\n\t\terr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\n\t\tif (err < 0) {\n\t\t\tdev_err(&bebob->unit->device,\n\t\t\t\t\"fail to get type for MSU in plug %d: %d\\n\",\n\t\t\t\ti, err);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {\n\t\t\tbebob->sync_input_plug = i;\n\t\t\tbreak;\n\t\t}\n\t}\nend:\n\treturn err;\n}\n\nint snd_bebob_stream_discover(struct snd_bebob *bebob)\n{\n\tconst struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;\n\tu8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];\n\tint err;\n\n\t \n\terr = avc_general_get_plug_info(bebob->unit, 0x1f, 0x07, 0x00, plugs);\n\tif (err < 0) {\n\t\tdev_err(&bebob->unit->device,\n\t\t\"fail to get info for isoc/external in/out plugs: %d\\n\",\n\t\t\terr);\n\t\tgoto end;\n\t}\n\n\t \n\tif ((plugs[0] == 0) || (plugs[1] == 0)) {\n\t\terr = -ENOSYS;\n\t\tgoto end;\n\t}\n\n\terr = fill_stream_formations(bebob, addr, AVC_BRIDGECO_PLUG_DIR_IN, 0,\n\t\t\t\t     bebob->rx_stream_formations);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = fill_stream_formations(bebob, addr, AVC_BRIDGECO_PLUG_DIR_OUT, 0,\n\t\t\t\t     bebob->tx_stream_formations);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = detect_midi_ports(bebob, bebob->tx_stream_formations, addr, AVC_BRIDGECO_PLUG_DIR_IN,\n\t\t\t\tplugs[2], &bebob->midi_input_ports);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = detect_midi_ports(bebob, bebob->rx_stream_formations, addr, AVC_BRIDGECO_PLUG_DIR_OUT,\n\t\t\t\tplugs[3], &bebob->midi_output_ports);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif (!clk_spec)\n\t\terr = seek_msu_sync_input_plug(bebob);\nend:\n\treturn err;\n}\n\nvoid snd_bebob_stream_lock_changed(struct snd_bebob *bebob)\n{\n\tbebob->dev_lock_changed = true;\n\twake_up(&bebob->hwdep_wait);\n}\n\nint snd_bebob_stream_lock_try(struct snd_bebob *bebob)\n{\n\tint err;\n\n\tspin_lock_irq(&bebob->lock);\n\n\t \n\tif (bebob->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (bebob->dev_lock_count++ == 0)\n\t\tsnd_bebob_stream_lock_changed(bebob);\n\terr = 0;\nend:\n\tspin_unlock_irq(&bebob->lock);\n\treturn err;\n}\n\nvoid snd_bebob_stream_lock_release(struct snd_bebob *bebob)\n{\n\tspin_lock_irq(&bebob->lock);\n\n\tif (WARN_ON(bebob->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--bebob->dev_lock_count == 0)\n\t\tsnd_bebob_stream_lock_changed(bebob);\nend:\n\tspin_unlock_irq(&bebob->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}