{
  "module_name": "bebob.c",
  "hash_id": "55770ac410c86589fba6850c9926d26424f9f2d318c5124c2e0647112acd804e",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/bebob/bebob.c",
  "human_readable_source": "\n \n\n \n\n#include \"bebob.h\"\n\nMODULE_DESCRIPTION(\"BridgeCo BeBoB driver\");\nMODULE_AUTHOR(\"Takashi Sakamoto <o-takashi@sakamocchi.jp>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS]\t= SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS]\t= SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS]\t= SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"card index\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"enable BeBoB sound card\");\n\nstatic DEFINE_MUTEX(devices_mutex);\nstatic DECLARE_BITMAP(devices_used, SNDRV_CARDS);\n\n \n#define INFO_OFFSET_BEBOB_VERSION\t0x08\n#define INFO_OFFSET_GUID\t\t0x10\n#define INFO_OFFSET_HW_MODEL_ID\t\t0x18\n#define INFO_OFFSET_HW_MODEL_REVISION\t0x1c\n\n#define VEN_EDIROL\t0x000040ab\n#define VEN_PRESONUS\t0x00000a92\n#define VEN_BRIDGECO\t0x000007f5\n#define VEN_MACKIE\t0x00000ff2\n#define VEN_STANTON\t0x00001260\n#define VEN_TASCAM\t0x0000022e\n#define VEN_BEHRINGER\t0x00001564\n#define VEN_APOGEE\t0x000003db\n#define VEN_ESI\t\t0x00000f1b\n#define VEN_CME\t\t0x0000000a\n#define VEN_PHONIC\t0x00001496\n#define VEN_LYNX\t0x000019e5\n#define VEN_ICON\t0x00001a9e\n#define VEN_PRISMSOUND\t0x00001198\n#define VEN_TERRATEC\t0x00000aac\n#define VEN_YAMAHA\t0x0000a0de\n#define VEN_FOCUSRITE\t0x0000130e\n#define VEN_MAUDIO\t0x00000d6c\n#define VEN_DIGIDESIGN\t0x00a07e\n#define OUI_SHOUYO\t0x002327\n\n#define MODEL_FOCUSRITE_SAFFIRE_BOTH\t0x00000000\n#define MODEL_MAUDIO_AUDIOPHILE_BOTH\t0x00010060\n#define MODEL_MAUDIO_FW1814\t\t0x00010071\n#define MODEL_MAUDIO_PROJECTMIX\t\t0x00010091\n#define MODEL_MAUDIO_PROFIRELIGHTBRIDGE\t0x000100a1\n\nstatic int\nname_device(struct snd_bebob *bebob)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(bebob->unit);\n\tchar vendor[24] = {0};\n\tchar model[32] = {0};\n\tu32 hw_id;\n\tu32 data[2] = {0};\n\tu32 revision;\n\tint err;\n\n\t \n\terr = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,\n\t\t\t    vendor, sizeof(vendor));\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\terr = fw_csr_string(bebob->unit->directory, CSR_MODEL,\n\t\t\t    model, sizeof(model));\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\terr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_ID,\n\t\t\t\t  &hw_id);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\terr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_REVISION,\n\t\t\t\t  &revision);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\terr = snd_bebob_read_block(bebob->unit, INFO_OFFSET_GUID,\n\t\t\t\t   data, sizeof(data));\n\tif (err < 0)\n\t\tgoto end;\n\n\tstrcpy(bebob->card->driver, \"BeBoB\");\n\tstrcpy(bebob->card->shortname, model);\n\tstrcpy(bebob->card->mixername, model);\n\tsnprintf(bebob->card->longname, sizeof(bebob->card->longname),\n\t\t \"%s %s (id:%d, rev:%d), GUID %08x%08x at %s, S%d\",\n\t\t vendor, model, hw_id, revision,\n\t\t data[0], data[1], dev_name(&bebob->unit->device),\n\t\t 100 << fw_dev->max_speed);\nend:\n\treturn err;\n}\n\nstatic void\nbebob_card_free(struct snd_card *card)\n{\n\tstruct snd_bebob *bebob = card->private_data;\n\n\tmutex_lock(&devices_mutex);\n\tclear_bit(bebob->card_index, devices_used);\n\tmutex_unlock(&devices_mutex);\n\n\tsnd_bebob_stream_destroy_duplex(bebob);\n\n\tmutex_destroy(&bebob->mutex);\n\tfw_unit_put(bebob->unit);\n}\n\nstatic const struct snd_bebob_spec *\nget_saffire_spec(struct fw_unit *unit)\n{\n\tchar name[24] = {0};\n\n\tif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\n\t\treturn NULL;\n\n\tif (strcmp(name, \"SaffireLE\") == 0)\n\t\treturn &saffire_le_spec;\n\telse\n\t\treturn &saffire_spec;\n}\n\nstatic bool\ncheck_audiophile_booted(struct fw_unit *unit)\n{\n\tchar name[28] = {0};\n\n\tif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\n\t\treturn false;\n\n\treturn strncmp(name, \"FW Audiophile Bootloader\", 24) != 0;\n}\n\nstatic int detect_quirks(struct snd_bebob *bebob, const struct ieee1394_device_id *entry)\n{\n\tif (entry->vendor_id == VEN_MAUDIO) {\n\t\tswitch (entry->model_id) {\n\t\tcase MODEL_MAUDIO_PROFIRELIGHTBRIDGE:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tbebob->quirks |= SND_BEBOB_QUIRK_INITIAL_DISCONTINUOUS_DBC;\n\t\t\tbreak;\n\t\tcase MODEL_MAUDIO_FW1814:\n\t\tcase MODEL_MAUDIO_PROJECTMIX:\n\t\t\t\n\t\t\t\n\t\t\tbebob->quirks |= SND_BEBOB_QUIRK_WRONG_DBC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bebob_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tunsigned int card_index;\n\tstruct snd_card *card;\n\tstruct snd_bebob *bebob;\n\tconst struct snd_bebob_spec *spec;\n\tint err;\n\n\tif (entry->vendor_id == VEN_FOCUSRITE &&\n\t    entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH)\n\t\tspec = get_saffire_spec(unit);\n\telse if (entry->vendor_id == VEN_MAUDIO &&\n\t\t entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH &&\n\t\t !check_audiophile_booted(unit))\n\t\tspec = NULL;\n\telse\n\t\tspec = (const struct snd_bebob_spec *)entry->driver_data;\n\n\tif (spec == NULL) {\n\t\t\n\t\tif (entry->vendor_id == VEN_MAUDIO || entry->vendor_id == VEN_BRIDGECO)\n\t\t\treturn snd_bebob_maudio_load_firmware(unit);\n\t\telse\n\t\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&devices_mutex);\n\tfor (card_index = 0; card_index < SNDRV_CARDS; card_index++) {\n\t\tif (!test_bit(card_index, devices_used) && enable[card_index])\n\t\t\tbreak;\n\t}\n\tif (card_index >= SNDRV_CARDS) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&unit->device, index[card_index], id[card_index], THIS_MODULE,\n\t\t\t   sizeof(*bebob), &card);\n\tif (err < 0) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\tcard->private_free = bebob_card_free;\n\tset_bit(card_index, devices_used);\n\tmutex_unlock(&devices_mutex);\n\n\tbebob = card->private_data;\n\tbebob->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, bebob);\n\tbebob->card = card;\n\tbebob->card_index = card_index;\n\n\tbebob->spec = spec;\n\tmutex_init(&bebob->mutex);\n\tspin_lock_init(&bebob->lock);\n\tinit_waitqueue_head(&bebob->hwdep_wait);\n\n\terr = name_device(bebob);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = detect_quirks(bebob, entry);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (bebob->spec == &maudio_special_spec) {\n\t\tif (entry->model_id == MODEL_MAUDIO_FW1814)\n\t\t\terr = snd_bebob_maudio_special_discover(bebob, true);\n\t\telse\n\t\t\terr = snd_bebob_maudio_special_discover(bebob, false);\n\t} else {\n\t\terr = snd_bebob_stream_discover(bebob);\n\t}\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_bebob_stream_init_duplex(bebob);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_bebob_proc_init(bebob);\n\n\tif (bebob->midi_input_ports > 0 || bebob->midi_output_ports > 0) {\n\t\terr = snd_bebob_create_midi_devices(bebob);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\terr = snd_bebob_create_pcm_devices(bebob);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_bebob_create_hwdep_device(bebob);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (entry->vendor_id == VEN_MAUDIO &&\n\t    (entry->model_id == MODEL_MAUDIO_FW1814 || entry->model_id == MODEL_MAUDIO_PROJECTMIX)) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfw_schedule_bus_reset(fw_parent_device(bebob->unit)->card, false, true);\n\t}\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n \nstatic void\nbebob_update(struct fw_unit *unit)\n{\n\tstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\n\n\tif (bebob == NULL)\n\t\treturn;\n\n\tfcp_bus_reset(bebob->unit);\n}\n\nstatic void bebob_remove(struct fw_unit *unit)\n{\n\tstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\n\n\tif (bebob == NULL)\n\t\treturn;\n\n\t\n\tsnd_card_free(bebob->card);\n}\n\nstatic const struct snd_bebob_rate_spec normal_rate_spec = {\n\t.get\t= &snd_bebob_stream_get_rate,\n\t.set\t= &snd_bebob_stream_set_rate\n};\nstatic const struct snd_bebob_spec spec_normal = {\n\t.clock\t= NULL,\n\t.rate\t= &normal_rate_spec,\n\t.meter\t= NULL\n};\n\n#define SPECIFIER_1394TA\t0x00a02d\n\n\n\n\n#define SND_BEBOB_DEV_ENTRY(vendor, model, data) \\\n{ \\\n\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | \\\n\t\t\t  IEEE1394_MATCH_MODEL_ID | \\\n\t\t\t  IEEE1394_MATCH_SPECIFIER_ID, \\\n\t.vendor_id\t= vendor, \\\n\t.model_id\t= model, \\\n\t.specifier_id\t= SPECIFIER_1394TA, \\\n\t.driver_data\t= (kernel_ulong_t)data \\\n}\n\nstatic const struct ieee1394_device_id bebob_id_table[] = {\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010049, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010048, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010000, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010066, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010001, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010048, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010049, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010065, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010067, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_STANTON, 0x00000001, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_TASCAM, 0x00010067, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001204, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001604, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00000006, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x001616, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x000610, &spec_normal),\n\t \n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x01eeee, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_ESI, 0x00010064, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_CME, 0x00030000, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00050000, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00060000, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00070000, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00080000, &spec_normal),\n\t\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00000000, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_LYNX, 0x00000001, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_ICON, 0x00000001, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x00010048, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x0000ada8, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000003, &phase88_rack_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000004, &yamaha_terratec_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000007, &yamaha_terratec_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000005, &spec_normal),\n\t\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000002, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000b, &yamaha_terratec_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000c, &yamaha_terratec_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000003, &saffirepro_26_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x000006, &saffirepro_10_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, MODEL_FOCUSRITE_SAFFIRE_BOTH,\n\t\t\t    &saffire_spec),\n\t\n\tSND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010058, NULL),\n\tSND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010046, &maudio_fw410_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, MODEL_MAUDIO_AUDIOPHILE_BOTH,\n\t\t\t    &maudio_audiophile_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, 0x00010062, &maudio_solo_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, 0x0000000a, &maudio_ozonic_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, 0x00010081, &maudio_nrv10_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, MODEL_MAUDIO_PROFIRELIGHTBRIDGE, &spec_normal),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, 0x00010070, NULL),\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, MODEL_MAUDIO_FW1814,\n\t\t\t    &maudio_special_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_MAUDIO, MODEL_MAUDIO_PROJECTMIX,\n\t\t\t    &maudio_special_spec),\n\t \n\tSND_BEBOB_DEV_ENTRY(VEN_DIGIDESIGN, 0x0000a9, &spec_normal),\n\t\n\tSND_BEBOB_DEV_ENTRY(OUI_SHOUYO, 0x020002, &spec_normal),\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t{}\n};\nMODULE_DEVICE_TABLE(ieee1394, bebob_id_table);\n\nstatic struct fw_driver bebob_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.bus\t= &fw_bus_type,\n\t},\n\t.probe    = bebob_probe,\n\t.update\t  = bebob_update,\n\t.remove   = bebob_remove,\n\t.id_table = bebob_id_table,\n};\n\nstatic int __init\nsnd_bebob_init(void)\n{\n\treturn driver_register(&bebob_driver.driver);\n}\n\nstatic void __exit\nsnd_bebob_exit(void)\n{\n\tdriver_unregister(&bebob_driver.driver);\n}\n\nmodule_init(snd_bebob_init);\nmodule_exit(snd_bebob_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}