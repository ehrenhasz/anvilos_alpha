{
  "module_name": "bebob_command.c",
  "hash_id": "103e5323f882785d37afbfcc62988928f6a9151040d5865ecfe126d789147c1a",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/bebob/bebob_command.c",
  "human_readable_source": "\n \n\n#include \"./bebob.h\"\n\nint avc_audio_set_selector(struct fw_unit *unit, unsigned int subunit_id,\n\t\t\t   unsigned int fb_id, unsigned int num)\n{\n\tu8 *buf;\n\tint err;\n\n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0]  = 0x00;\t\t \n\tbuf[1]  = 0x08 | (0x07 & subunit_id);\t \n\tbuf[2]  = 0xb8;\t\t \n\tbuf[3]  = 0x80;\t\t \n\tbuf[4]  = 0xff & fb_id;\t \n\tbuf[5]  = 0x10;\t\t \n\tbuf[6]  = 0x02;\t\t \n\tbuf[7]  = 0xff & num;\t \n\tbuf[8]  = 0x01;\t\t \n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(8));\n\tif (err < 0)\n\t\t;\n\telse if (err < 9)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\n\tkfree(buf);\n\treturn err;\n}\n\nint avc_audio_get_selector(struct fw_unit *unit, unsigned int subunit_id,\n\t\t\t   unsigned int fb_id, unsigned int *num)\n{\n\tu8 *buf;\n\tint err;\n\n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0]  = 0x01;\t\t \n\tbuf[1]  = 0x08 | (0x07 & subunit_id);\t \n\tbuf[2]  = 0xb8;\t\t \n\tbuf[3]  = 0x80;\t\t \n\tbuf[4]  = 0xff & fb_id;\t \n\tbuf[5]  = 0x10;\t\t \n\tbuf[6]  = 0x02;\t\t \n\tbuf[7]  = 0xff;\t\t \n\tbuf[8]  = 0x01;\t\t \n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(8));\n\tif (err < 0)\n\t\t;\n\telse if (err < 9)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t*num = buf[7];\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic inline void\navc_bridgeco_fill_extension_addr(u8 *buf, u8 *addr)\n{\n\tbuf[1] = addr[0];\n\tmemcpy(buf + 4, addr + 1, 5);\n}\n\nstatic inline void\navc_bridgeco_fill_plug_info_extension_command(u8 *buf, u8 *addr,\n\t\t\t\t\t      unsigned int itype)\n{\n\tbuf[0] = 0x01;\t \n\tbuf[2] = 0x02;\t \n\tbuf[3] = 0xc0;\t \n\tavc_bridgeco_fill_extension_addr(buf, addr);\n\tbuf[9] = itype;\t \n}\n\nint avc_bridgeco_get_plug_type(struct fw_unit *unit,\n\t\t\t       u8 addr[AVC_BRIDGECO_ADDR_BYTES],\n\t\t\t       enum avc_bridgeco_plug_type *type)\n{\n\tu8 *buf;\n\tint err;\n\n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tavc_bridgeco_fill_plug_info_extension_command(buf, addr, 0x00);\n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(9));\n\tif (err < 0)\n\t\t;\n\telse if (err < 11)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t*type = buf[10];\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nint avc_bridgeco_get_plug_ch_count(struct fw_unit *unit, u8 addr[AVC_BRIDGECO_ADDR_BYTES],\n\t\t\t\t   unsigned int *ch_count)\n{\n\tu8 *buf;\n\tint err;\n\n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t\n\tavc_bridgeco_fill_plug_info_extension_command(buf, addr, 0x02);\n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(9));\n\tif (err < 0)\n\t\t;\n\telse if (err < 11)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08) \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a) \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b) \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t*ch_count = buf[10];\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nint avc_bridgeco_get_plug_ch_pos(struct fw_unit *unit,\n\t\t\t\t u8 addr[AVC_BRIDGECO_ADDR_BYTES],\n\t\t\t\t u8 *buf, unsigned int len)\n{\n\tint err;\n\n\t \n\tavc_bridgeco_fill_plug_info_extension_command(buf, addr, 0x03);\n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 256,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) |\n\t\t\t\t  BIT(5) | BIT(6) | BIT(7) | BIT(9));\n\tif (err < 0)\n\t\t;\n\telse if (err < 11)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tmemmove(buf, buf + 10, err - 10);\n\terr = 0;\nend:\n\treturn err;\n}\n\nint avc_bridgeco_get_plug_section_type(struct fw_unit *unit,\n\t\t\t\t       u8 addr[AVC_BRIDGECO_ADDR_BYTES],\n\t\t\t\t       unsigned int id, u8 *type)\n{\n\tu8 *buf;\n\tint err;\n\n\t \n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tavc_bridgeco_fill_plug_info_extension_command(buf, addr, 0x07);\n\tbuf[10] = 0xff & ++id;\t \n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(9) | BIT(10));\n\tif (err < 0)\n\t\t;\n\telse if (err < 12)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t*type = buf[11];\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nint avc_bridgeco_get_plug_input(struct fw_unit *unit,\n\t\t\t\tu8 addr[AVC_BRIDGECO_ADDR_BYTES], u8 input[7])\n{\n\tint err;\n\tu8 *buf;\n\n\tbuf = kzalloc(18, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tavc_bridgeco_fill_plug_info_extension_command(buf, addr, 0x05);\n\n\terr = fcp_avc_transaction(unit, buf, 16, buf, 16,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7));\n\tif (err < 0)\n\t\t;\n\telse if (err < 16)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\tmemcpy(input, buf + 10, 5);\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nint avc_bridgeco_get_plug_strm_fmt(struct fw_unit *unit,\n\t\t\t\t   u8 addr[AVC_BRIDGECO_ADDR_BYTES], u8 *buf,\n\t\t\t\t   unsigned int *len, unsigned int eid)\n{\n\tint err;\n\n\t \n\tif ((buf == NULL) || (*len < 12)) {\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tbuf[0] = 0x01;\t \n\tbuf[2] = 0x2f;\t \n\tbuf[3] = 0xc1;\t \n\tavc_bridgeco_fill_extension_addr(buf, addr);\n\tbuf[10] = 0xff & eid;\t \n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, *len,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(10));\n\tif (err < 0)\n\t\t;\n\telse if (err < 12)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)         \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)         \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)         \n\t\terr = -EAGAIN;\n\telse if (buf[10] != eid)\n\t\terr = -EIO;\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tmemmove(buf, buf + 11, err - 11);\n\t*len = err - 11;\n\terr = 0;\nend:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}