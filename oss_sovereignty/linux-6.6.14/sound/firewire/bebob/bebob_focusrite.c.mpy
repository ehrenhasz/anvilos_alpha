{
  "module_name": "bebob_focusrite.c",
  "hash_id": "51d1a160d4d953347489c70b2d52dff5f69a96e430ca923098cebe9214d445f4",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/bebob/bebob_focusrite.c",
  "human_readable_source": "\n \n\n#include \"./bebob.h\"\n\n#define ANA_IN\t\"Analog In\"\n#define DIG_IN\t\"Digital In\"\n#define ANA_OUT\t\"Analog Out\"\n#define DIG_OUT\t\"Digital Out\"\n#define STM_IN\t\"Stream In\"\n\n#define SAFFIRE_ADDRESS_BASE\t\t\t0x000100000000ULL\n\n#define SAFFIRE_OFFSET_CLOCK_SOURCE\t\t0x00f8\n#define SAFFIREPRO_OFFSET_CLOCK_SOURCE\t\t0x0174\n\n \n#define SAFFIRE_OFFSET_CLOCK_SYNC_EXT\t\t0x013c\n#define SAFFIRE_LE_OFFSET_CLOCK_SYNC_EXT\t0x0432\n#define SAFFIREPRO_OFFSET_CLOCK_SYNC_EXT\t0x0164\n\n#define SAFFIRE_CLOCK_SOURCE_INTERNAL\t\t0\n#define SAFFIRE_CLOCK_SOURCE_SPDIF\t\t1\n\n \n#define SAFFIREPRO_CLOCK_SOURCE_SELECT_MASK\t0x000000ff\n#define SAFFIREPRO_CLOCK_SOURCE_DETECT_MASK\t0x0000ff00\n#define SAFFIREPRO_CLOCK_SOURCE_INTERNAL\t0\n#define SAFFIREPRO_CLOCK_SOURCE_SKIP\t\t1  \n#define SAFFIREPRO_CLOCK_SOURCE_SPDIF\t\t2\n#define SAFFIREPRO_CLOCK_SOURCE_ADAT1\t\t3  \n#define SAFFIREPRO_CLOCK_SOURCE_ADAT2\t\t4  \n#define SAFFIREPRO_CLOCK_SOURCE_WORDCLOCK\t5\n#define SAFFIREPRO_CLOCK_SOURCE_COUNT\t\t6\n\n \n#define SAFFIREPRO_ENABLE_DIG_IFACES\t\t0x01a4\n\n \n#define SAFFIREPRO_RATE_NOREBOOT\t\t0x01cc\n \nstatic const unsigned int rates[] = {\n\t[0] = 0,\n\t[1] = 44100,\n\t[2] = 48000,\n\t[3] = 88200,\n\t[4] = 96000,\n\t[5] = 176400,\n\t[6] = 192000\n};\n\n \n#define SAFFIRE_OFFSET_METER\t\t\t0x0100\n#define SAFFIRE_LE_OFFSET_METER\t\t\t0x0168\n\nstatic inline int\nsaffire_read_block(struct snd_bebob *bebob, u64 offset,\n\t\t   u32 *buf, unsigned int size)\n{\n\tunsigned int i;\n\tint err;\n\t__be32 *tmp = (__be32 *)buf;\n\n\terr =  snd_fw_transaction(bebob->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t  SAFFIRE_ADDRESS_BASE + offset,\n\t\t\t\t  tmp, size, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\tfor (i = 0; i < size / sizeof(u32); i++)\n\t\tbuf[i] = be32_to_cpu(tmp[i]);\nend:\n\treturn err;\n}\n\nstatic inline int\nsaffire_read_quad(struct snd_bebob *bebob, u64 offset, u32 *value)\n{\n\tint err;\n\t__be32 tmp;\n\n\terr = snd_fw_transaction(bebob->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t SAFFIRE_ADDRESS_BASE + offset,\n\t\t\t\t &tmp, sizeof(__be32), 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\t*value = be32_to_cpu(tmp);\nend:\n\treturn err;\n}\n\nstatic inline int\nsaffire_write_quad(struct snd_bebob *bebob, u64 offset, u32 value)\n{\n\t__be32 data = cpu_to_be32(value);\n\n\treturn snd_fw_transaction(bebob->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  SAFFIRE_ADDRESS_BASE + offset,\n\t\t\t\t  &data, sizeof(__be32), 0);\n}\n\nstatic const enum snd_bebob_clock_type saffirepro_10_clk_src_types[] = {\n\tSND_BEBOB_CLOCK_TYPE_INTERNAL,\n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n};\nstatic const enum snd_bebob_clock_type saffirepro_26_clk_src_types[] = {\n\tSND_BEBOB_CLOCK_TYPE_INTERNAL,\n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\t \n};\n \nstatic const signed char saffirepro_clk_maps[][SAFFIREPRO_CLOCK_SOURCE_COUNT] = {\n\t \n\t[0] = {\n\t\t[SAFFIREPRO_CLOCK_SOURCE_INTERNAL]  =  0,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_SKIP]      = -1,  \n\t\t[SAFFIREPRO_CLOCK_SOURCE_SPDIF]     =  1,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_ADAT1]     = -1,  \n\t\t[SAFFIREPRO_CLOCK_SOURCE_ADAT2]     = -1,  \n\t\t[SAFFIREPRO_CLOCK_SOURCE_WORDCLOCK] =  2,\n\t},\n\t \n\t[1] = {\n\t\t[SAFFIREPRO_CLOCK_SOURCE_INTERNAL]  =  0,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_SKIP]      = -1,  \n\t\t[SAFFIREPRO_CLOCK_SOURCE_SPDIF]     =  1,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_ADAT1]     =  2,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_ADAT2]     =  3,\n\t\t[SAFFIREPRO_CLOCK_SOURCE_WORDCLOCK] =  4,\n\t}\n};\n\nstatic int\nsaffirepro_both_clk_freq_get(struct snd_bebob *bebob, unsigned int *rate)\n{\n\tu32 id;\n\tint err;\n\n\terr = saffire_read_quad(bebob, SAFFIREPRO_RATE_NOREBOOT, &id);\n\tif (err < 0)\n\t\tgoto end;\n\tif (id >= ARRAY_SIZE(rates))\n\t\terr = -EIO;\n\telse\n\t\t*rate = rates[id];\nend:\n\treturn err;\n}\nstatic int\nsaffirepro_both_clk_freq_set(struct snd_bebob *bebob, unsigned int rate)\n{\n\tu32 id;\n\n\tfor (id = 0; id < ARRAY_SIZE(rates); id++) {\n\t\tif (rates[id] == rate)\n\t\t\tbreak;\n\t}\n\tif (id == ARRAY_SIZE(rates))\n\t\treturn -EINVAL;\n\n\treturn saffire_write_quad(bebob, SAFFIREPRO_RATE_NOREBOOT, id);\n}\n\n \nstatic int\nsaffirepro_both_clk_src_get(struct snd_bebob *bebob, unsigned int *id)\n{\n\tint err;\n\tu32 value;        \n\tconst signed char *map;\n\n\terr = saffire_read_quad(bebob, SAFFIREPRO_OFFSET_CLOCK_SOURCE, &value);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif (bebob->spec->clock->types == saffirepro_10_clk_src_types)\n\t\tmap = saffirepro_clk_maps[0];\n\telse\n\t\tmap = saffirepro_clk_maps[1];\n\n\t \n\tvalue &= SAFFIREPRO_CLOCK_SOURCE_SELECT_MASK;\n\tif (value >= SAFFIREPRO_CLOCK_SOURCE_COUNT || map[value] < 0) {\n\t\terr = -EIO;\n\t\tgoto end;\n\t}\n\n\t*id = (unsigned int)map[value];\nend:\n\treturn err;\n}\n\nconst struct snd_bebob_spec saffire_le_spec;\nstatic const enum snd_bebob_clock_type saffire_both_clk_src_types[] = {\n\tSND_BEBOB_CLOCK_TYPE_INTERNAL,\n\tSND_BEBOB_CLOCK_TYPE_EXTERNAL,\n};\nstatic int\nsaffire_both_clk_src_get(struct snd_bebob *bebob, unsigned int *id)\n{\n\tint err;\n\tu32 value;\n\n\terr = saffire_read_quad(bebob, SAFFIRE_OFFSET_CLOCK_SOURCE, &value);\n\tif (err >= 0)\n\t\t*id = 0xff & value;\n\n\treturn err;\n};\nstatic const char *const saffire_le_meter_labels[] = {\n\tANA_IN, ANA_IN, DIG_IN,\n\tANA_OUT, ANA_OUT, ANA_OUT, ANA_OUT,\n\tSTM_IN, STM_IN\n};\nstatic const char *const saffire_meter_labels[] = {\n\tANA_IN, ANA_IN,\n\tSTM_IN, STM_IN, STM_IN, STM_IN, STM_IN,\n};\nstatic int\nsaffire_meter_get(struct snd_bebob *bebob, u32 *buf, unsigned int size)\n{\n\tconst struct snd_bebob_meter_spec *spec = bebob->spec->meter;\n\tunsigned int channels;\n\tu64 offset;\n\tint err;\n\n\tif (spec->labels == saffire_le_meter_labels)\n\t\toffset = SAFFIRE_LE_OFFSET_METER;\n\telse\n\t\toffset = SAFFIRE_OFFSET_METER;\n\n\tchannels = spec->num * 2;\n\tif (size < channels * sizeof(u32))\n\t\treturn -EIO;\n\n\terr = saffire_read_block(bebob, offset, buf, size);\n\tif (err >= 0 && spec->labels == saffire_le_meter_labels) {\n\t\tswap(buf[1], buf[3]);\n\t\tswap(buf[2], buf[3]);\n\t\tswap(buf[3], buf[4]);\n\n\t\tswap(buf[7], buf[10]);\n\t\tswap(buf[8], buf[10]);\n\t\tswap(buf[9], buf[11]);\n\t\tswap(buf[11], buf[12]);\n\n\t\tswap(buf[15], buf[16]);\n\t}\n\n\treturn err;\n}\n\nstatic const struct snd_bebob_rate_spec saffirepro_both_rate_spec = {\n\t.get\t= &saffirepro_both_clk_freq_get,\n\t.set\t= &saffirepro_both_clk_freq_set,\n};\n \nstatic const struct snd_bebob_clock_spec saffirepro_26_clk_spec = {\n\t.num\t= ARRAY_SIZE(saffirepro_26_clk_src_types),\n\t.types\t= saffirepro_26_clk_src_types,\n\t.get\t= &saffirepro_both_clk_src_get,\n};\nconst struct snd_bebob_spec saffirepro_26_spec = {\n\t.clock\t= &saffirepro_26_clk_spec,\n\t.rate\t= &saffirepro_both_rate_spec,\n\t.meter\t= NULL\n};\n \nstatic const struct snd_bebob_clock_spec saffirepro_10_clk_spec = {\n\t.num\t= ARRAY_SIZE(saffirepro_10_clk_src_types),\n\t.types\t= saffirepro_10_clk_src_types,\n\t.get\t= &saffirepro_both_clk_src_get,\n};\nconst struct snd_bebob_spec saffirepro_10_spec = {\n\t.clock\t= &saffirepro_10_clk_spec,\n\t.rate\t= &saffirepro_both_rate_spec,\n\t.meter\t= NULL\n};\n\nstatic const struct snd_bebob_rate_spec saffire_both_rate_spec = {\n\t.get\t= &snd_bebob_stream_get_rate,\n\t.set\t= &snd_bebob_stream_set_rate,\n};\nstatic const struct snd_bebob_clock_spec saffire_both_clk_spec = {\n\t.num\t= ARRAY_SIZE(saffire_both_clk_src_types),\n\t.types\t= saffire_both_clk_src_types,\n\t.get\t= &saffire_both_clk_src_get,\n};\n \nstatic const struct snd_bebob_meter_spec saffire_le_meter_spec = {\n\t.num\t= ARRAY_SIZE(saffire_le_meter_labels),\n\t.labels\t= saffire_le_meter_labels,\n\t.get\t= &saffire_meter_get,\n};\nconst struct snd_bebob_spec saffire_le_spec = {\n\t.clock\t= &saffire_both_clk_spec,\n\t.rate\t= &saffire_both_rate_spec,\n\t.meter\t= &saffire_le_meter_spec\n};\n \nstatic const struct snd_bebob_meter_spec saffire_meter_spec = {\n\t.num\t= ARRAY_SIZE(saffire_meter_labels),\n\t.labels\t= saffire_meter_labels,\n\t.get\t= &saffire_meter_get,\n};\nconst struct snd_bebob_spec saffire_spec = {\n\t.clock\t= &saffire_both_clk_spec,\n\t.rate\t= &saffire_both_rate_spec,\n\t.meter\t= &saffire_meter_spec\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}