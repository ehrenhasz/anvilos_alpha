{
  "module_name": "cmp.c",
  "hash_id": "93d67d98ae8184632f8f421ccce13d0c92ff697a6134aebf1b129906812143c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/cmp.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include \"lib.h\"\n#include \"iso-resources.h\"\n#include \"cmp.h\"\n\n \n#define MPR_SPEED_MASK\t\t0xc0000000\n#define MPR_SPEED_SHIFT\t\t30\n#define MPR_XSPEED_MASK\t\t0x00000060\n#define MPR_XSPEED_SHIFT\t5\n#define MPR_PLUGS_MASK\t\t0x0000001f\n\n \n#define PCR_ONLINE\t\t0x80000000\n#define PCR_BCAST_CONN\t\t0x40000000\n#define PCR_P2P_CONN_MASK\t0x3f000000\n#define PCR_P2P_CONN_SHIFT\t24\n#define PCR_CHANNEL_MASK\t0x003f0000\n#define PCR_CHANNEL_SHIFT\t16\n\n \n#define OPCR_XSPEED_MASK\t0x00C00000\n#define OPCR_XSPEED_SHIFT\t22\n#define OPCR_SPEED_MASK\t\t0x0000C000\n#define OPCR_SPEED_SHIFT\t14\n#define OPCR_OVERHEAD_ID_MASK\t0x00003C00\n#define OPCR_OVERHEAD_ID_SHIFT\t10\n\nenum bus_reset_handling {\n\tABORT_ON_BUS_RESET,\n\tSUCCEED_ON_BUS_RESET,\n};\n\nstatic __printf(2, 3)\nvoid cmp_error(struct cmp_connection *c, const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tdev_err(&c->resources.unit->device, \"%cPCR%u: %pV\",\n\t\t(c->direction == CMP_INPUT) ? 'i' : 'o',\n\t\tc->pcr_index, &(struct va_format){ fmt, &va });\n\tva_end(va);\n}\n\nstatic u64 mpr_address(struct cmp_connection *c)\n{\n\tif (c->direction == CMP_INPUT)\n\t\treturn CSR_REGISTER_BASE + CSR_IMPR;\n\telse\n\t\treturn CSR_REGISTER_BASE + CSR_OMPR;\n}\n\nstatic u64 pcr_address(struct cmp_connection *c)\n{\n\tif (c->direction == CMP_INPUT)\n\t\treturn CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index);\n\telse\n\t\treturn CSR_REGISTER_BASE + CSR_OPCR(c->pcr_index);\n}\n\nstatic int pcr_modify(struct cmp_connection *c,\n\t\t      __be32 (*modify)(struct cmp_connection *c, __be32 old),\n\t\t      int (*check)(struct cmp_connection *c, __be32 pcr),\n\t\t      enum bus_reset_handling bus_reset_handling)\n{\n\t__be32 old_arg, buffer[2];\n\tint err;\n\n\tbuffer[0] = c->last_pcr_value;\n\tfor (;;) {\n\t\told_arg = buffer[0];\n\t\tbuffer[1] = modify(c, buffer[0]);\n\n\t\terr = snd_fw_transaction(\n\t\t\t\tc->resources.unit, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t\tpcr_address(c), buffer, 8,\n\t\t\t\tFW_FIXED_GENERATION | c->resources.generation);\n\n\t\tif (err < 0) {\n\t\t\tif (err == -EAGAIN &&\n\t\t\t    bus_reset_handling == SUCCEED_ON_BUS_RESET)\n\t\t\t\terr = 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (buffer[0] == old_arg)  \n\t\t\tbreak;\n\n\t\tif (check) {\n\t\t\terr = check(c, buffer[0]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tc->last_pcr_value = buffer[1];\n\n\treturn 0;\n}\n\n\n \nint cmp_connection_init(struct cmp_connection *c,\n\t\t\tstruct fw_unit *unit,\n\t\t\tenum cmp_direction direction,\n\t\t\tunsigned int pcr_index)\n{\n\t__be32 mpr_be;\n\tu32 mpr;\n\tint err;\n\n\tc->direction = direction;\n\terr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t mpr_address(c), &mpr_be, 4, 0);\n\tif (err < 0)\n\t\treturn err;\n\tmpr = be32_to_cpu(mpr_be);\n\n\tif (pcr_index >= (mpr & MPR_PLUGS_MASK))\n\t\treturn -EINVAL;\n\n\terr = fw_iso_resources_init(&c->resources, unit);\n\tif (err < 0)\n\t\treturn err;\n\n\tc->connected = false;\n\tmutex_init(&c->mutex);\n\tc->last_pcr_value = cpu_to_be32(0x80000000);\n\tc->pcr_index = pcr_index;\n\tc->max_speed = (mpr & MPR_SPEED_MASK) >> MPR_SPEED_SHIFT;\n\tif (c->max_speed == SCODE_BETA)\n\t\tc->max_speed += (mpr & MPR_XSPEED_MASK) >> MPR_XSPEED_SHIFT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cmp_connection_init);\n\n \nint cmp_connection_check_used(struct cmp_connection *c, bool *used)\n{\n\t__be32 pcr;\n\tint err;\n\n\terr = snd_fw_transaction(\n\t\t\tc->resources.unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\tpcr_address(c), &pcr, 4, 0);\n\tif (err >= 0)\n\t\t*used = !!(pcr & cpu_to_be32(PCR_BCAST_CONN |\n\t\t\t\t\t     PCR_P2P_CONN_MASK));\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmp_connection_check_used);\n\n \nvoid cmp_connection_destroy(struct cmp_connection *c)\n{\n\tWARN_ON(c->connected);\n\tmutex_destroy(&c->mutex);\n\tfw_iso_resources_destroy(&c->resources);\n}\nEXPORT_SYMBOL(cmp_connection_destroy);\n\nint cmp_connection_reserve(struct cmp_connection *c,\n\t\t\t   unsigned int max_payload_bytes)\n{\n\tint err;\n\n\tmutex_lock(&c->mutex);\n\n\tif (WARN_ON(c->resources.allocated)) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc->speed = min(c->max_speed,\n\t\t       fw_parent_device(c->resources.unit)->max_speed);\n\n\terr = fw_iso_resources_allocate(&c->resources, max_payload_bytes,\n\t\t\t\t\tc->speed);\nend:\n\tmutex_unlock(&c->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmp_connection_reserve);\n\nvoid cmp_connection_release(struct cmp_connection *c)\n{\n\tmutex_lock(&c->mutex);\n\tfw_iso_resources_free(&c->resources);\n\tmutex_unlock(&c->mutex);\n}\nEXPORT_SYMBOL(cmp_connection_release);\n\nstatic __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)\n{\n\tipcr &= ~cpu_to_be32(PCR_BCAST_CONN |\n\t\t\t     PCR_P2P_CONN_MASK |\n\t\t\t     PCR_CHANNEL_MASK);\n\tipcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);\n\tipcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);\n\n\treturn ipcr;\n}\n\nstatic int get_overhead_id(struct cmp_connection *c)\n{\n\tint id;\n\n\t \n\tfor (id = 1; id < 16; id++) {\n\t\tif (c->resources.bandwidth_overhead < (id << 5))\n\t\t\tbreak;\n\t}\n\tif (id == 16)\n\t\tid = 0;\n\n\treturn id;\n}\n\nstatic __be32 opcr_set_modify(struct cmp_connection *c, __be32 opcr)\n{\n\tunsigned int spd, xspd;\n\n\t \n\tif (c->speed > SCODE_400) {\n\t\tspd  = SCODE_800;\n\t\txspd = c->speed - SCODE_800;\n\t} else {\n\t\tspd = c->speed;\n\t\txspd = 0;\n\t}\n\n\topcr &= ~cpu_to_be32(PCR_BCAST_CONN |\n\t\t\t     PCR_P2P_CONN_MASK |\n\t\t\t     OPCR_XSPEED_MASK |\n\t\t\t     PCR_CHANNEL_MASK |\n\t\t\t     OPCR_SPEED_MASK |\n\t\t\t     OPCR_OVERHEAD_ID_MASK);\n\topcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);\n\topcr |= cpu_to_be32(xspd << OPCR_XSPEED_SHIFT);\n\topcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);\n\topcr |= cpu_to_be32(spd << OPCR_SPEED_SHIFT);\n\topcr |= cpu_to_be32(get_overhead_id(c) << OPCR_OVERHEAD_ID_SHIFT);\n\n\treturn opcr;\n}\n\nstatic int pcr_set_check(struct cmp_connection *c, __be32 pcr)\n{\n\tif (pcr & cpu_to_be32(PCR_BCAST_CONN |\n\t\t\t      PCR_P2P_CONN_MASK)) {\n\t\tcmp_error(c, \"plug is already in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (!(pcr & cpu_to_be32(PCR_ONLINE))) {\n\t\tcmp_error(c, \"plug is not on-line\\n\");\n\t\treturn -ECONNREFUSED;\n\t}\n\n\treturn 0;\n}\n\n \nint cmp_connection_establish(struct cmp_connection *c)\n{\n\tint err;\n\n\tmutex_lock(&c->mutex);\n\n\tif (WARN_ON(c->connected)) {\n\t\tmutex_unlock(&c->mutex);\n\t\treturn -EISCONN;\n\t}\n\nretry_after_bus_reset:\n\tif (c->direction == CMP_OUTPUT)\n\t\terr = pcr_modify(c, opcr_set_modify, pcr_set_check,\n\t\t\t\t ABORT_ON_BUS_RESET);\n\telse\n\t\terr = pcr_modify(c, ipcr_set_modify, pcr_set_check,\n\t\t\t\t ABORT_ON_BUS_RESET);\n\n\tif (err == -EAGAIN) {\n\t\terr = fw_iso_resources_update(&c->resources);\n\t\tif (err >= 0)\n\t\t\tgoto retry_after_bus_reset;\n\t}\n\tif (err >= 0)\n\t\tc->connected = true;\n\n\tmutex_unlock(&c->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmp_connection_establish);\n\n \nint cmp_connection_update(struct cmp_connection *c)\n{\n\tint err;\n\n\tmutex_lock(&c->mutex);\n\n\tif (!c->connected) {\n\t\tmutex_unlock(&c->mutex);\n\t\treturn 0;\n\t}\n\n\terr = fw_iso_resources_update(&c->resources);\n\tif (err < 0)\n\t\tgoto err_unconnect;\n\n\tif (c->direction == CMP_OUTPUT)\n\t\terr = pcr_modify(c, opcr_set_modify, pcr_set_check,\n\t\t\t\t SUCCEED_ON_BUS_RESET);\n\telse\n\t\terr = pcr_modify(c, ipcr_set_modify, pcr_set_check,\n\t\t\t\t SUCCEED_ON_BUS_RESET);\n\n\tif (err < 0)\n\t\tgoto err_unconnect;\n\n\tmutex_unlock(&c->mutex);\n\n\treturn 0;\n\nerr_unconnect:\n\tc->connected = false;\n\tmutex_unlock(&c->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmp_connection_update);\n\nstatic __be32 pcr_break_modify(struct cmp_connection *c, __be32 pcr)\n{\n\treturn pcr & ~cpu_to_be32(PCR_BCAST_CONN | PCR_P2P_CONN_MASK);\n}\n\n \nvoid cmp_connection_break(struct cmp_connection *c)\n{\n\tint err;\n\n\tmutex_lock(&c->mutex);\n\n\tif (!c->connected) {\n\t\tmutex_unlock(&c->mutex);\n\t\treturn;\n\t}\n\n\terr = pcr_modify(c, pcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);\n\tif (err < 0)\n\t\tcmp_error(c, \"plug is still connected\\n\");\n\n\tc->connected = false;\n\n\tmutex_unlock(&c->mutex);\n}\nEXPORT_SYMBOL(cmp_connection_break);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}