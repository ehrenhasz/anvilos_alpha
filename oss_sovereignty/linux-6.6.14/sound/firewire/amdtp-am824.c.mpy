{
  "module_name": "amdtp-am824.c",
  "hash_id": "1f55536c125289ca392fbd103464b682de62c357689f47b7299ba12d3d0cf716",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/amdtp-am824.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"amdtp-am824.h\"\n\n#define CIP_FMT_AM\t\t0x10\n\n \n#define AMDTP_FDF_AM824\t\t0x00\n\n \n#define MIDI_BYTES_PER_SECOND\t3093\n\n \n#define MAX_MIDI_RX_BLOCKS\t8\n\nstruct amdtp_am824 {\n\tstruct snd_rawmidi_substream *midi[AM824_MAX_CHANNELS_FOR_MIDI * 8];\n\tint midi_fifo_limit;\n\tint midi_fifo_used[AM824_MAX_CHANNELS_FOR_MIDI * 8];\n\tunsigned int pcm_channels;\n\tunsigned int midi_ports;\n\n\tu8 pcm_positions[AM824_MAX_CHANNELS_FOR_PCM];\n\tu8 midi_position;\n};\n\n \nint amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,\n\t\t\t       unsigned int pcm_channels,\n\t\t\t       unsigned int midi_ports,\n\t\t\t       bool double_pcm_frames)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int midi_channels;\n\tunsigned int pcm_frame_multiplier;\n\tint i, err;\n\n\tif (amdtp_stream_running(s))\n\t\treturn -EINVAL;\n\n\tif (pcm_channels > AM824_MAX_CHANNELS_FOR_PCM)\n\t\treturn -EINVAL;\n\n\tmidi_channels = DIV_ROUND_UP(midi_ports, 8);\n\tif (midi_channels > AM824_MAX_CHANNELS_FOR_MIDI)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(amdtp_stream_running(s)) ||\n\t    WARN_ON(pcm_channels > AM824_MAX_CHANNELS_FOR_PCM) ||\n\t    WARN_ON(midi_channels > AM824_MAX_CHANNELS_FOR_MIDI))\n\t\treturn -EINVAL;\n\n\t \n\tif (double_pcm_frames)\n\t\tpcm_frame_multiplier = 2;\n\telse\n\t\tpcm_frame_multiplier = 1;\n\n\terr = amdtp_stream_set_parameters(s, rate, pcm_channels + midi_channels,\n\t\t\t\t\t  pcm_frame_multiplier);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (s->direction == AMDTP_OUT_STREAM)\n\t\ts->ctx_data.rx.fdf = AMDTP_FDF_AM824 | s->sfc;\n\n\tp->pcm_channels = pcm_channels;\n\tp->midi_ports = midi_ports;\n\n\t \n\tfor (i = 0; i < pcm_channels; i++)\n\t\tp->pcm_positions[i] = i;\n\tp->midi_position = p->pcm_channels;\n\n\t \n\tp->midi_fifo_limit = rate - MIDI_BYTES_PER_SECOND * s->syt_interval + 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_set_parameters);\n\n \nvoid amdtp_am824_set_pcm_position(struct amdtp_stream *s, unsigned int index,\n\t\t\t\t unsigned int position)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\n\tif (index < p->pcm_channels)\n\t\tp->pcm_positions[index] = position;\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_position);\n\n \nvoid amdtp_am824_set_midi_position(struct amdtp_stream *s,\n\t\t\t\t   unsigned int position)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\n\tp->midi_position = position;\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_set_midi_position);\n\nstatic void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t  __be32 *buffer, unsigned int frames,\n\t\t\t  unsigned int pcm_frames)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tconst u32 *src;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tsrc = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\tbuffer[p->pcm_positions[c]] =\n\t\t\t\t\tcpu_to_be32((*src >> 8) | 0x40000000);\n\t\t\tsrc++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tsrc = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t __be32 *buffer, unsigned int frames,\n\t\t\t unsigned int pcm_frames)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tu32 *dst;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tdst  = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t*dst = be32_to_cpu(buffer[p->pcm_positions[c]]) << 8;\n\t\t\tdst++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tdst = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void write_pcm_silence(struct amdtp_stream *s,\n\t\t\t      __be32 *buffer, unsigned int frames)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int i, c, channels = p->pcm_channels;\n\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c)\n\t\t\tbuffer[p->pcm_positions[c]] = cpu_to_be32(0x40000000);\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\n \nint amdtp_am824_add_pcm_hw_constraints(struct amdtp_stream *s,\n\t\t\t\t       struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\terr = amdtp_stream_add_pcm_hw_constraints(s, runtime);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_add_pcm_hw_constraints);\n\n \nvoid amdtp_am824_midi_trigger(struct amdtp_stream *s, unsigned int port,\n\t\t\t      struct snd_rawmidi_substream *midi)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\n\tif (port < p->midi_ports)\n\t\tWRITE_ONCE(p->midi[port], midi);\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);\n\n \nstatic bool midi_ratelimit_per_packet(struct amdtp_stream *s, unsigned int port)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tint used;\n\n\tused = p->midi_fifo_used[port];\n\tif (used == 0)  \n\t\treturn true;\n\n\tused -= MIDI_BYTES_PER_SECOND * s->syt_interval;\n\tused = max(used, 0);\n\tp->midi_fifo_used[port] = used;\n\n\treturn used < p->midi_fifo_limit;\n}\n\nstatic void midi_rate_use_one_byte(struct amdtp_stream *s, unsigned int port)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\n\tp->midi_fifo_used[port] += amdtp_rate_table[s->sfc];\n}\n\nstatic void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\t\tunsigned int frames, unsigned int data_block_counter)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int f, port;\n\tu8 *b;\n\n\tfor (f = 0; f < frames; f++) {\n\t\tb = (u8 *)&buffer[p->midi_position];\n\n\t\tport = (data_block_counter + f) % 8;\n\t\tif (f < MAX_MIDI_RX_BLOCKS &&\n\t\t    midi_ratelimit_per_packet(s, port) &&\n\t\t    p->midi[port] != NULL &&\n\t\t    snd_rawmidi_transmit(p->midi[port], &b[1], 1) == 1) {\n\t\t\tmidi_rate_use_one_byte(s, port);\n\t\t\tb[0] = 0x81;\n\t\t} else {\n\t\t\tb[0] = 0x80;\n\t\t\tb[1] = 0;\n\t\t}\n\t\tb[2] = 0;\n\t\tb[3] = 0;\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nstatic void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\t\tunsigned int frames, unsigned int data_block_counter)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tint len;\n\tu8 *b;\n\tint f;\n\n\tfor (f = 0; f < frames; f++) {\n\t\tunsigned int port = f;\n\n\t\tif (!(s->flags & CIP_UNALIGHED_DBC))\n\t\t\tport += data_block_counter;\n\t\tport %= 8;\n\t\tb = (u8 *)&buffer[p->midi_position];\n\n\t\tlen = b[0] - 0x80;\n\t\tif ((1 <= len) &&  (len <= 3) && (p->midi[port]))\n\t\t\tsnd_rawmidi_receive(p->midi[port], b + 1, len);\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nstatic void process_it_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\twrite_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks * s->pcm_frame_multiplier;\n\t\t} else {\n\t\t\twrite_pcm_silence(s, buf, data_blocks);\n\t\t}\n\n\t\tif (p->midi_ports) {\n\t\t\twrite_midi_messages(s, buf, data_blocks,\n\t\t\t\t\t    desc->data_block_counter);\n\t\t}\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nstatic void process_ir_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tstruct amdtp_am824 *p = s->protocol;\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\tread_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks * s->pcm_frame_multiplier;\n\t\t}\n\n\t\tif (p->midi_ports) {\n\t\t\tread_midi_messages(s, buf, data_blocks,\n\t\t\t\t\t   desc->data_block_counter);\n\t\t}\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\n \nint amdtp_am824_init(struct amdtp_stream *s, struct fw_unit *unit,\n\t\t     enum amdtp_stream_direction dir, unsigned int flags)\n{\n\tamdtp_stream_process_ctx_payloads_t process_ctx_payloads;\n\n\tif (dir == AMDTP_IN_STREAM)\n\t\tprocess_ctx_payloads = process_ir_ctx_payloads;\n\telse\n\t\tprocess_ctx_payloads = process_it_ctx_payloads;\n\n\treturn amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM,\n\t\t\tprocess_ctx_payloads, sizeof(struct amdtp_am824));\n}\nEXPORT_SYMBOL_GPL(amdtp_am824_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}