{
  "module_name": "amdtp-stream.c",
  "hash_id": "7ed65f718b56c74434c073d3d42b1cae6386ee64ecfa968ba1ea317fc10af722",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/amdtp-stream.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"amdtp-stream.h\"\n\n#define TICKS_PER_CYCLE\t\t3072\n#define CYCLES_PER_SECOND\t8000\n#define TICKS_PER_SECOND\t(TICKS_PER_CYCLE * CYCLES_PER_SECOND)\n\n#define OHCI_SECOND_MODULUS\t\t8\n\n \n#define CREATE_TRACE_POINTS\n#include \"amdtp-stream-trace.h\"\n\n#define TRANSFER_DELAY_TICKS\t0x2e00  \n\n \n#define ISO_DATA_LENGTH_SHIFT\t16\n#define TAG_NO_CIP_HEADER\t0\n#define TAG_CIP\t\t\t1\n\n\n#define CIP_HEADER_QUADLETS\t2\n#define CIP_EOH_SHIFT\t\t31\n#define CIP_EOH\t\t\t(1u << CIP_EOH_SHIFT)\n#define CIP_EOH_MASK\t\t0x80000000\n#define CIP_SID_SHIFT\t\t24\n#define CIP_SID_MASK\t\t0x3f000000\n#define CIP_DBS_MASK\t\t0x00ff0000\n#define CIP_DBS_SHIFT\t\t16\n#define CIP_SPH_MASK\t\t0x00000400\n#define CIP_SPH_SHIFT\t\t10\n#define CIP_DBC_MASK\t\t0x000000ff\n#define CIP_FMT_SHIFT\t\t24\n#define CIP_FMT_MASK\t\t0x3f000000\n#define CIP_FDF_MASK\t\t0x00ff0000\n#define CIP_FDF_SHIFT\t\t16\n#define CIP_FDF_NO_DATA\t\t0xff\n#define CIP_SYT_MASK\t\t0x0000ffff\n#define CIP_SYT_NO_INFO\t\t0xffff\n#define CIP_SYT_CYCLE_MODULUS\t16\n#define CIP_NO_DATA\t\t((CIP_FDF_NO_DATA << CIP_FDF_SHIFT) | CIP_SYT_NO_INFO)\n\n#define CIP_HEADER_SIZE\t\t(sizeof(__be32) * CIP_HEADER_QUADLETS)\n\n \n#define CIP_FMT_AM\t\t0x10\n#define AMDTP_FDF_NO_DATA\t0xff\n\n\n#define IR_CTX_HEADER_DEFAULT_QUADLETS\t2\n\n#define IR_CTX_HEADER_SIZE_NO_CIP\t(sizeof(__be32) * IR_CTX_HEADER_DEFAULT_QUADLETS)\n\n#define IR_CTX_HEADER_SIZE_CIP\t\t(IR_CTX_HEADER_SIZE_NO_CIP + CIP_HEADER_SIZE)\n#define HEADER_TSTAMP_MASK\t0x0000ffff\n\n#define IT_PKT_HEADER_SIZE_CIP\t\tCIP_HEADER_SIZE\n#define IT_PKT_HEADER_SIZE_NO_CIP\t0 \n\n\n\n\n#define IR_JUMBO_PAYLOAD_MAX_SKIP_CYCLES\t5\n\n \nint amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,\n\t\t      enum amdtp_stream_direction dir, unsigned int flags,\n\t\t      unsigned int fmt,\n\t\t      amdtp_stream_process_ctx_payloads_t process_ctx_payloads,\n\t\t      unsigned int protocol_size)\n{\n\tif (process_ctx_payloads == NULL)\n\t\treturn -EINVAL;\n\n\ts->protocol = kzalloc(protocol_size, GFP_KERNEL);\n\tif (!s->protocol)\n\t\treturn -ENOMEM;\n\n\ts->unit = unit;\n\ts->direction = dir;\n\ts->flags = flags;\n\ts->context = ERR_PTR(-1);\n\tmutex_init(&s->mutex);\n\ts->packet_index = 0;\n\n\tinit_waitqueue_head(&s->ready_wait);\n\n\ts->fmt = fmt;\n\ts->process_ctx_payloads = process_ctx_payloads;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(amdtp_stream_init);\n\n \nvoid amdtp_stream_destroy(struct amdtp_stream *s)\n{\n\t \n\tif (s->protocol == NULL)\n\t\treturn;\n\n\tWARN_ON(amdtp_stream_running(s));\n\tkfree(s->protocol);\n\tmutex_destroy(&s->mutex);\n}\nEXPORT_SYMBOL(amdtp_stream_destroy);\n\nconst unsigned int amdtp_syt_intervals[CIP_SFC_COUNT] = {\n\t[CIP_SFC_32000]  =  8,\n\t[CIP_SFC_44100]  =  8,\n\t[CIP_SFC_48000]  =  8,\n\t[CIP_SFC_88200]  = 16,\n\t[CIP_SFC_96000]  = 16,\n\t[CIP_SFC_176400] = 32,\n\t[CIP_SFC_192000] = 32,\n};\nEXPORT_SYMBOL(amdtp_syt_intervals);\n\nconst unsigned int amdtp_rate_table[CIP_SFC_COUNT] = {\n\t[CIP_SFC_32000]  =  32000,\n\t[CIP_SFC_44100]  =  44100,\n\t[CIP_SFC_48000]  =  48000,\n\t[CIP_SFC_88200]  =  88200,\n\t[CIP_SFC_96000]  =  96000,\n\t[CIP_SFC_176400] = 176400,\n\t[CIP_SFC_192000] = 192000,\n};\nEXPORT_SYMBOL(amdtp_rate_table);\n\nstatic int apply_constraint_to_size(struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *s = hw_param_interval(params, rule->var);\n\tconst struct snd_interval *r =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval t = {0};\n\tunsigned int step = 0;\n\tint i;\n\n\tfor (i = 0; i < CIP_SFC_COUNT; ++i) {\n\t\tif (snd_interval_test(r, amdtp_rate_table[i]))\n\t\t\tstep = max(step, amdtp_syt_intervals[i]);\n\t}\n\n\tt.min = roundup(s->min, step);\n\tt.max = rounddown(s->max, step);\n\tt.integer = 1;\n\n\treturn snd_interval_refine(s, &t);\n}\n\n \nint amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,\n\t\t\t\t\tstruct snd_pcm_runtime *runtime)\n{\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tunsigned int ctx_header_size;\n\tunsigned int maximum_usec_per_period;\n\tint err;\n\n\thw->info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t   SNDRV_PCM_INFO_JOINT_DUPLEX |\n\t\t   SNDRV_PCM_INFO_MMAP |\n\t\t   SNDRV_PCM_INFO_MMAP_VALID |\n\t\t   SNDRV_PCM_INFO_NO_PERIOD_WAKEUP;\n\n\thw->periods_min = 2;\n\thw->periods_max = UINT_MAX;\n\n\t \n\thw->period_bytes_min = 4 * hw->channels_max;\n\n\t \n\thw->period_bytes_max = hw->period_bytes_min * 2048;\n\thw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif (!(s->flags & CIP_NO_HEADER))\n\t\tctx_header_size = IR_CTX_HEADER_SIZE_CIP;\n\telse\n\t\tctx_header_size = IR_CTX_HEADER_SIZE_NO_CIP;\n\tmaximum_usec_per_period = USEC_PER_SEC * PAGE_SIZE /\n\t\t\t\t  CYCLES_PER_SECOND / ctx_header_size;\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   250, maximum_usec_per_period);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif (!(s->flags & CIP_BLOCKING))\n\t\tgoto end;\n\n\t \n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t  apply_constraint_to_size, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\tgoto end;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t  apply_constraint_to_size, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\tgoto end;\nend:\n\treturn err;\n}\nEXPORT_SYMBOL(amdtp_stream_add_pcm_hw_constraints);\n\n \nint amdtp_stream_set_parameters(struct amdtp_stream *s, unsigned int rate,\n\t\t\t\tunsigned int data_block_quadlets, unsigned int pcm_frame_multiplier)\n{\n\tunsigned int sfc;\n\n\tfor (sfc = 0; sfc < ARRAY_SIZE(amdtp_rate_table); ++sfc) {\n\t\tif (amdtp_rate_table[sfc] == rate)\n\t\t\tbreak;\n\t}\n\tif (sfc == ARRAY_SIZE(amdtp_rate_table))\n\t\treturn -EINVAL;\n\n\ts->sfc = sfc;\n\ts->data_block_quadlets = data_block_quadlets;\n\ts->syt_interval = amdtp_syt_intervals[sfc];\n\n\t \n\ts->transfer_delay = TRANSFER_DELAY_TICKS - TICKS_PER_CYCLE;\n\n\t \n\tif (s->flags & CIP_BLOCKING)\n\t\ts->transfer_delay += TICKS_PER_SECOND * s->syt_interval / rate;\n\n\ts->pcm_frame_multiplier = pcm_frame_multiplier;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(amdtp_stream_set_parameters);\n\n \nstatic int amdtp_stream_get_max_ctx_payload_size(struct amdtp_stream *s)\n{\n\tunsigned int multiplier;\n\n\tif (s->flags & CIP_JUMBO_PAYLOAD)\n\t\tmultiplier = IR_JUMBO_PAYLOAD_MAX_SKIP_CYCLES;\n\telse\n\t\tmultiplier = 1;\n\n\treturn s->syt_interval * s->data_block_quadlets * sizeof(__be32) * multiplier;\n}\n\n \nunsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s)\n{\n\tunsigned int cip_header_size;\n\n\tif (!(s->flags & CIP_NO_HEADER))\n\t\tcip_header_size = CIP_HEADER_SIZE;\n\telse\n\t\tcip_header_size = 0;\n\n\treturn cip_header_size + amdtp_stream_get_max_ctx_payload_size(s);\n}\nEXPORT_SYMBOL(amdtp_stream_get_max_payload);\n\n \nvoid amdtp_stream_pcm_prepare(struct amdtp_stream *s)\n{\n\ts->pcm_buffer_pointer = 0;\n\ts->pcm_period_pointer = 0;\n}\nEXPORT_SYMBOL(amdtp_stream_pcm_prepare);\n\n#define prev_packet_desc(s, desc) \\\n\tlist_prev_entry_circular(desc, &s->packet_descs_list, link)\n\nstatic void pool_blocking_data_blocks(struct amdtp_stream *s, struct seq_desc *descs,\n\t\t\t\t      unsigned int size, unsigned int pos, unsigned int count)\n{\n\tconst unsigned int syt_interval = s->syt_interval;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct seq_desc *desc = descs + pos;\n\n\t\tif (desc->syt_offset != CIP_SYT_NO_INFO)\n\t\t\tdesc->data_blocks = syt_interval;\n\t\telse\n\t\t\tdesc->data_blocks = 0;\n\n\t\tpos = (pos + 1) % size;\n\t}\n}\n\nstatic void pool_ideal_nonblocking_data_blocks(struct amdtp_stream *s, struct seq_desc *descs,\n\t\t\t\t\t       unsigned int size, unsigned int pos,\n\t\t\t\t\t       unsigned int count)\n{\n\tconst enum cip_sfc sfc = s->sfc;\n\tunsigned int state = s->ctx_data.rx.data_block_state;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct seq_desc *desc = descs + pos;\n\n\t\tif (!cip_sfc_is_base_44100(sfc)) {\n\t\t\t\n\t\t\tdesc->data_blocks = state;\n\t\t} else {\n\t\t\tunsigned int phase = state;\n\n\t\t \n\t\t\tif (sfc == CIP_SFC_44100)\n\t\t\t\t \n\t\t\t\tdesc->data_blocks = 5 + ((phase & 1) ^ (phase == 0 || phase >= 40));\n\t\t\telse\n\t\t\t\t \n\t\t\t\tdesc->data_blocks = 11 * (sfc >> 1) + (phase == 0);\n\t\t\tif (++phase >= (80 >> (sfc >> 1)))\n\t\t\t\tphase = 0;\n\t\t\tstate = phase;\n\t\t}\n\n\t\tpos = (pos + 1) % size;\n\t}\n\n\ts->ctx_data.rx.data_block_state = state;\n}\n\nstatic unsigned int calculate_syt_offset(unsigned int *last_syt_offset,\n\t\t\tunsigned int *syt_offset_state, enum cip_sfc sfc)\n{\n\tunsigned int syt_offset;\n\n\tif (*last_syt_offset < TICKS_PER_CYCLE) {\n\t\tif (!cip_sfc_is_base_44100(sfc))\n\t\t\tsyt_offset = *last_syt_offset + *syt_offset_state;\n\t\telse {\n\t\t \n\t\t\tunsigned int phase = *syt_offset_state;\n\t\t\tunsigned int index = phase % 13;\n\n\t\t\tsyt_offset = *last_syt_offset;\n\t\t\tsyt_offset += 1386 + ((index && !(index & 3)) ||\n\t\t\t\t\t      phase == 146);\n\t\t\tif (++phase >= 147)\n\t\t\t\tphase = 0;\n\t\t\t*syt_offset_state = phase;\n\t\t}\n\t} else\n\t\tsyt_offset = *last_syt_offset - TICKS_PER_CYCLE;\n\t*last_syt_offset = syt_offset;\n\n\tif (syt_offset >= TICKS_PER_CYCLE)\n\t\tsyt_offset = CIP_SYT_NO_INFO;\n\n\treturn syt_offset;\n}\n\nstatic void pool_ideal_syt_offsets(struct amdtp_stream *s, struct seq_desc *descs,\n\t\t\t\t   unsigned int size, unsigned int pos, unsigned int count)\n{\n\tconst enum cip_sfc sfc = s->sfc;\n\tunsigned int last = s->ctx_data.rx.last_syt_offset;\n\tunsigned int state = s->ctx_data.rx.syt_offset_state;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct seq_desc *desc = descs + pos;\n\n\t\tdesc->syt_offset = calculate_syt_offset(&last, &state, sfc);\n\n\t\tpos = (pos + 1) % size;\n\t}\n\n\ts->ctx_data.rx.last_syt_offset = last;\n\ts->ctx_data.rx.syt_offset_state = state;\n}\n\nstatic unsigned int compute_syt_offset(unsigned int syt, unsigned int cycle,\n\t\t\t\t       unsigned int transfer_delay)\n{\n\tunsigned int cycle_lo = (cycle % CYCLES_PER_SECOND) & 0x0f;\n\tunsigned int syt_cycle_lo = (syt & 0xf000) >> 12;\n\tunsigned int syt_offset;\n\n\t\n\tif (syt_cycle_lo < cycle_lo)\n\t\tsyt_cycle_lo += CIP_SYT_CYCLE_MODULUS;\n\tsyt_cycle_lo -= cycle_lo;\n\n\t\n\t\n\tsyt_offset = syt_cycle_lo * TICKS_PER_CYCLE + (syt & 0x0fff);\n\tif (syt_offset < transfer_delay)\n\t\tsyt_offset += CIP_SYT_CYCLE_MODULUS * TICKS_PER_CYCLE;\n\n\treturn syt_offset - transfer_delay;\n}\n\n\n\n\n\nstatic unsigned int calculate_cached_cycle_count(struct amdtp_stream *s, unsigned int head)\n{\n\tconst unsigned int cache_size = s->ctx_data.tx.cache.size;\n\tunsigned int cycles = s->ctx_data.tx.cache.pos;\n\n\tif (cycles < head)\n\t\tcycles += cache_size;\n\tcycles -= head;\n\n\treturn cycles;\n}\n\nstatic void cache_seq(struct amdtp_stream *s, const struct pkt_desc *src, unsigned int desc_count)\n{\n\tconst unsigned int transfer_delay = s->transfer_delay;\n\tconst unsigned int cache_size = s->ctx_data.tx.cache.size;\n\tstruct seq_desc *cache = s->ctx_data.tx.cache.descs;\n\tunsigned int cache_pos = s->ctx_data.tx.cache.pos;\n\tbool aware_syt = !(s->flags & CIP_UNAWARE_SYT);\n\tint i;\n\n\tfor (i = 0; i < desc_count; ++i) {\n\t\tstruct seq_desc *dst = cache + cache_pos;\n\n\t\tif (aware_syt && src->syt != CIP_SYT_NO_INFO)\n\t\t\tdst->syt_offset = compute_syt_offset(src->syt, src->cycle, transfer_delay);\n\t\telse\n\t\t\tdst->syt_offset = CIP_SYT_NO_INFO;\n\t\tdst->data_blocks = src->data_blocks;\n\n\t\tcache_pos = (cache_pos + 1) % cache_size;\n\t\tsrc = amdtp_stream_next_packet_desc(s, src);\n\t}\n\n\ts->ctx_data.tx.cache.pos = cache_pos;\n}\n\nstatic void pool_ideal_seq_descs(struct amdtp_stream *s, struct seq_desc *descs, unsigned int size,\n\t\t\t\t unsigned int pos, unsigned int count)\n{\n\tpool_ideal_syt_offsets(s, descs, size, pos, count);\n\n\tif (s->flags & CIP_BLOCKING)\n\t\tpool_blocking_data_blocks(s, descs, size, pos, count);\n\telse\n\t\tpool_ideal_nonblocking_data_blocks(s, descs, size, pos, count);\n}\n\nstatic void pool_replayed_seq(struct amdtp_stream *s, struct seq_desc *descs, unsigned int size,\n\t\t\t      unsigned int pos, unsigned int count)\n{\n\tstruct amdtp_stream *target = s->ctx_data.rx.replay_target;\n\tconst struct seq_desc *cache = target->ctx_data.tx.cache.descs;\n\tconst unsigned int cache_size = target->ctx_data.tx.cache.size;\n\tunsigned int cache_pos = s->ctx_data.rx.cache_pos;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tdescs[pos] = cache[cache_pos];\n\t\tcache_pos = (cache_pos + 1) % cache_size;\n\t\tpos = (pos + 1) % size;\n\t}\n\n\ts->ctx_data.rx.cache_pos = cache_pos;\n}\n\nstatic void pool_seq_descs(struct amdtp_stream *s, struct seq_desc *descs, unsigned int size,\n\t\t\t   unsigned int pos, unsigned int count)\n{\n\tstruct amdtp_domain *d = s->domain;\n\tvoid (*pool_seq_descs)(struct amdtp_stream *s, struct seq_desc *descs, unsigned int size,\n\t\t\t       unsigned int pos, unsigned int count);\n\n\tif (!d->replay.enable || !s->ctx_data.rx.replay_target) {\n\t\tpool_seq_descs = pool_ideal_seq_descs;\n\t} else {\n\t\tif (!d->replay.on_the_fly) {\n\t\t\tpool_seq_descs = pool_replayed_seq;\n\t\t} else {\n\t\t\tstruct amdtp_stream *tx = s->ctx_data.rx.replay_target;\n\t\t\tconst unsigned int cache_size = tx->ctx_data.tx.cache.size;\n\t\t\tconst unsigned int cache_pos = s->ctx_data.rx.cache_pos;\n\t\t\tunsigned int cached_cycles = calculate_cached_cycle_count(tx, cache_pos);\n\n\t\t\tif (cached_cycles > count && cached_cycles > cache_size / 2)\n\t\t\t\tpool_seq_descs = pool_replayed_seq;\n\t\t\telse\n\t\t\t\tpool_seq_descs = pool_ideal_seq_descs;\n\t\t}\n\t}\n\n\tpool_seq_descs(s, descs, size, pos, count);\n}\n\nstatic void update_pcm_pointers(struct amdtp_stream *s,\n\t\t\t\tstruct snd_pcm_substream *pcm,\n\t\t\t\tunsigned int frames)\n{\n\tunsigned int ptr;\n\n\tptr = s->pcm_buffer_pointer + frames;\n\tif (ptr >= pcm->runtime->buffer_size)\n\t\tptr -= pcm->runtime->buffer_size;\n\tWRITE_ONCE(s->pcm_buffer_pointer, ptr);\n\n\ts->pcm_period_pointer += frames;\n\tif (s->pcm_period_pointer >= pcm->runtime->period_size) {\n\t\ts->pcm_period_pointer -= pcm->runtime->period_size;\n\n\t\t\n\t\t\n\t\t\n\t\tif (!pcm->runtime->no_period_wakeup) {\n\t\t\tif (in_softirq()) {\n\t\t\t\t\n\t\t\t\tsnd_pcm_period_elapsed(pcm);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tsnd_pcm_period_elapsed_under_stream_lock(pcm);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int queue_packet(struct amdtp_stream *s, struct fw_iso_packet *params,\n\t\t\tbool sched_irq)\n{\n\tint err;\n\n\tparams->interrupt = sched_irq;\n\tparams->tag = s->tag;\n\tparams->sy = 0;\n\n\terr = fw_iso_context_queue(s->context, params, &s->buffer.iso_buffer,\n\t\t\t\t   s->buffer.packets[s->packet_index].offset);\n\tif (err < 0) {\n\t\tdev_err(&s->unit->device, \"queueing error: %d\\n\", err);\n\t\tgoto end;\n\t}\n\n\tif (++s->packet_index >= s->queue_size)\n\t\ts->packet_index = 0;\nend:\n\treturn err;\n}\n\nstatic inline int queue_out_packet(struct amdtp_stream *s,\n\t\t\t\t   struct fw_iso_packet *params, bool sched_irq)\n{\n\tparams->skip =\n\t\t!!(params->header_length == 0 && params->payload_length == 0);\n\treturn queue_packet(s, params, sched_irq);\n}\n\nstatic inline int queue_in_packet(struct amdtp_stream *s,\n\t\t\t\t  struct fw_iso_packet *params)\n{\n\t\n\tparams->header_length = s->ctx_data.tx.ctx_header_size;\n\tparams->payload_length = s->ctx_data.tx.max_ctx_payload_length;\n\tparams->skip = false;\n\treturn queue_packet(s, params, false);\n}\n\nstatic void generate_cip_header(struct amdtp_stream *s, __be32 cip_header[2],\n\t\t\tunsigned int data_block_counter, unsigned int syt)\n{\n\tcip_header[0] = cpu_to_be32(READ_ONCE(s->source_node_id_field) |\n\t\t\t\t(s->data_block_quadlets << CIP_DBS_SHIFT) |\n\t\t\t\t((s->sph << CIP_SPH_SHIFT) & CIP_SPH_MASK) |\n\t\t\t\tdata_block_counter);\n\tcip_header[1] = cpu_to_be32(CIP_EOH |\n\t\t\t((s->fmt << CIP_FMT_SHIFT) & CIP_FMT_MASK) |\n\t\t\t((s->ctx_data.rx.fdf << CIP_FDF_SHIFT) & CIP_FDF_MASK) |\n\t\t\t(syt & CIP_SYT_MASK));\n}\n\nstatic void build_it_pkt_header(struct amdtp_stream *s, unsigned int cycle,\n\t\t\t\tstruct fw_iso_packet *params, unsigned int header_length,\n\t\t\t\tunsigned int data_blocks,\n\t\t\t\tunsigned int data_block_counter,\n\t\t\t\tunsigned int syt, unsigned int index, u32 curr_cycle_time)\n{\n\tunsigned int payload_length;\n\t__be32 *cip_header;\n\n\tpayload_length = data_blocks * sizeof(__be32) * s->data_block_quadlets;\n\tparams->payload_length = payload_length;\n\n\tif (header_length > 0) {\n\t\tcip_header = (__be32 *)params->header;\n\t\tgenerate_cip_header(s, cip_header, data_block_counter, syt);\n\t\tparams->header_length = header_length;\n\t} else {\n\t\tcip_header = NULL;\n\t}\n\n\ttrace_amdtp_packet(s, cycle, cip_header, payload_length + header_length, data_blocks,\n\t\t\t   data_block_counter, s->packet_index, index, curr_cycle_time);\n}\n\nstatic int check_cip_header(struct amdtp_stream *s, const __be32 *buf,\n\t\t\t    unsigned int payload_length,\n\t\t\t    unsigned int *data_blocks,\n\t\t\t    unsigned int *data_block_counter, unsigned int *syt)\n{\n\tu32 cip_header[2];\n\tunsigned int sph;\n\tunsigned int fmt;\n\tunsigned int fdf;\n\tunsigned int dbc;\n\tbool lost;\n\n\tcip_header[0] = be32_to_cpu(buf[0]);\n\tcip_header[1] = be32_to_cpu(buf[1]);\n\n\t \n\tif ((((cip_header[0] & CIP_EOH_MASK) == CIP_EOH) ||\n\t     ((cip_header[1] & CIP_EOH_MASK) != CIP_EOH)) &&\n\t    (!(s->flags & CIP_HEADER_WITHOUT_EOH))) {\n\t\tdev_info_ratelimited(&s->unit->device,\n\t\t\t\t\"Invalid CIP header for AMDTP: %08X:%08X\\n\",\n\t\t\t\tcip_header[0], cip_header[1]);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tsph = (cip_header[0] & CIP_SPH_MASK) >> CIP_SPH_SHIFT;\n\tfmt = (cip_header[1] & CIP_FMT_MASK) >> CIP_FMT_SHIFT;\n\tif (sph != s->sph || fmt != s->fmt) {\n\t\tdev_info_ratelimited(&s->unit->device,\n\t\t\t\t     \"Detect unexpected protocol: %08x %08x\\n\",\n\t\t\t\t     cip_header[0], cip_header[1]);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tfdf = (cip_header[1] & CIP_FDF_MASK) >> CIP_FDF_SHIFT;\n\tif (payload_length == 0 || (fmt == CIP_FMT_AM && fdf == AMDTP_FDF_NO_DATA)) {\n\t\t*data_blocks = 0;\n\t} else {\n\t\tunsigned int data_block_quadlets =\n\t\t\t\t(cip_header[0] & CIP_DBS_MASK) >> CIP_DBS_SHIFT;\n\t\t \n\t\tif (data_block_quadlets == 0) {\n\t\t\tdev_err(&s->unit->device,\n\t\t\t\t\"Detect invalid value in dbs field: %08X\\n\",\n\t\t\t\tcip_header[0]);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tif (s->flags & CIP_WRONG_DBS)\n\t\t\tdata_block_quadlets = s->data_block_quadlets;\n\n\t\t*data_blocks = payload_length / sizeof(__be32) / data_block_quadlets;\n\t}\n\n\t \n\tdbc = cip_header[0] & CIP_DBC_MASK;\n\tif (*data_blocks == 0 && (s->flags & CIP_EMPTY_HAS_WRONG_DBC) &&\n\t    *data_block_counter != UINT_MAX)\n\t\tdbc = *data_block_counter;\n\n\tif ((dbc == 0x00 && (s->flags & CIP_SKIP_DBC_ZERO_CHECK)) ||\n\t    *data_block_counter == UINT_MAX) {\n\t\tlost = false;\n\t} else if (!(s->flags & CIP_DBC_IS_END_EVENT)) {\n\t\tlost = dbc != *data_block_counter;\n\t} else {\n\t\tunsigned int dbc_interval;\n\n\t\tif (*data_blocks > 0 && s->ctx_data.tx.dbc_interval > 0)\n\t\t\tdbc_interval = s->ctx_data.tx.dbc_interval;\n\t\telse\n\t\t\tdbc_interval = *data_blocks;\n\n\t\tlost = dbc != ((*data_block_counter + dbc_interval) & 0xff);\n\t}\n\n\tif (lost) {\n\t\tdev_err(&s->unit->device,\n\t\t\t\"Detect discontinuity of CIP: %02X %02X\\n\",\n\t\t\t*data_block_counter, dbc);\n\t\treturn -EIO;\n\t}\n\n\t*data_block_counter = dbc;\n\n\tif (!(s->flags & CIP_UNAWARE_SYT))\n\t\t*syt = cip_header[1] & CIP_SYT_MASK;\n\n\treturn 0;\n}\n\nstatic int parse_ir_ctx_header(struct amdtp_stream *s, unsigned int cycle,\n\t\t\t       const __be32 *ctx_header,\n\t\t\t       unsigned int *data_blocks,\n\t\t\t       unsigned int *data_block_counter,\n\t\t\t       unsigned int *syt, unsigned int packet_index, unsigned int index,\n\t\t\t       u32 curr_cycle_time)\n{\n\tunsigned int payload_length;\n\tconst __be32 *cip_header;\n\tunsigned int cip_header_size;\n\n\tpayload_length = be32_to_cpu(ctx_header[0]) >> ISO_DATA_LENGTH_SHIFT;\n\n\tif (!(s->flags & CIP_NO_HEADER))\n\t\tcip_header_size = CIP_HEADER_SIZE;\n\telse\n\t\tcip_header_size = 0;\n\n\tif (payload_length > cip_header_size + s->ctx_data.tx.max_ctx_payload_length) {\n\t\tdev_err(&s->unit->device,\n\t\t\t\"Detect jumbo payload: %04x %04x\\n\",\n\t\t\tpayload_length, cip_header_size + s->ctx_data.tx.max_ctx_payload_length);\n\t\treturn -EIO;\n\t}\n\n\tif (cip_header_size > 0) {\n\t\tif (payload_length >= cip_header_size) {\n\t\t\tint err;\n\n\t\t\tcip_header = ctx_header + IR_CTX_HEADER_DEFAULT_QUADLETS;\n\t\t\terr = check_cip_header(s, cip_header, payload_length - cip_header_size,\n\t\t\t\t\t       data_blocks, data_block_counter, syt);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t\n\t\t\tcip_header = NULL;\n\t\t\t*data_blocks = 0;\n\t\t\t*syt = 0;\n\t\t}\n\t} else {\n\t\tcip_header = NULL;\n\t\t*data_blocks = payload_length / sizeof(__be32) / s->data_block_quadlets;\n\t\t*syt = 0;\n\n\t\tif (*data_block_counter == UINT_MAX)\n\t\t\t*data_block_counter = 0;\n\t}\n\n\ttrace_amdtp_packet(s, cycle, cip_header, payload_length, *data_blocks,\n\t\t\t   *data_block_counter, packet_index, index, curr_cycle_time);\n\n\treturn 0;\n}\n\n\n\n\nstatic inline u32 compute_ohci_iso_ctx_cycle_count(u32 tstamp)\n{\n\treturn (((tstamp >> 13) & 0x07) * CYCLES_PER_SECOND) + (tstamp & 0x1fff);\n}\n\nstatic inline u32 compute_ohci_cycle_count(__be32 ctx_header_tstamp)\n{\n\tu32 tstamp = be32_to_cpu(ctx_header_tstamp) & HEADER_TSTAMP_MASK;\n\treturn compute_ohci_iso_ctx_cycle_count(tstamp);\n}\n\nstatic inline u32 increment_ohci_cycle_count(u32 cycle, unsigned int addend)\n{\n\tcycle += addend;\n\tif (cycle >= OHCI_SECOND_MODULUS * CYCLES_PER_SECOND)\n\t\tcycle -= OHCI_SECOND_MODULUS * CYCLES_PER_SECOND;\n\treturn cycle;\n}\n\nstatic inline u32 decrement_ohci_cycle_count(u32 minuend, u32 subtrahend)\n{\n\tif (minuend < subtrahend)\n\t\tminuend += OHCI_SECOND_MODULUS * CYCLES_PER_SECOND;\n\n\treturn minuend - subtrahend;\n}\n\nstatic int compare_ohci_cycle_count(u32 lval, u32 rval)\n{\n\tif (lval == rval)\n\t\treturn 0;\n\telse if (lval < rval && rval - lval < OHCI_SECOND_MODULUS * CYCLES_PER_SECOND / 2)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\n\n\n\n\nstatic inline u32 compute_ohci_it_cycle(const __be32 ctx_header_tstamp,\n\t\t\t\t\tunsigned int queue_size)\n{\n\tu32 cycle = compute_ohci_cycle_count(ctx_header_tstamp);\n\treturn increment_ohci_cycle_count(cycle, queue_size);\n}\n\nstatic int generate_tx_packet_descs(struct amdtp_stream *s, struct pkt_desc *desc,\n\t\t\t\t    const __be32 *ctx_header, unsigned int packet_count,\n\t\t\t\t    unsigned int *desc_count)\n{\n\tunsigned int next_cycle = s->next_cycle;\n\tunsigned int dbc = s->data_block_counter;\n\tunsigned int packet_index = s->packet_index;\n\tunsigned int queue_size = s->queue_size;\n\tu32 curr_cycle_time = 0;\n\tint i;\n\tint err;\n\n\tif (trace_amdtp_packet_enabled())\n\t\t(void)fw_card_read_cycle_time(fw_parent_device(s->unit)->card, &curr_cycle_time);\n\n\t*desc_count = 0;\n\tfor (i = 0; i < packet_count; ++i) {\n\t\tunsigned int cycle;\n\t\tbool lost;\n\t\tunsigned int data_blocks;\n\t\tunsigned int syt;\n\n\t\tcycle = compute_ohci_cycle_count(ctx_header[1]);\n\t\tlost = (next_cycle != cycle);\n\t\tif (lost) {\n\t\t\tif (s->flags & CIP_NO_HEADER) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tunsigned int prev_cycle = next_cycle;\n\n\t\t\t\tnext_cycle = increment_ohci_cycle_count(next_cycle, 1);\n\t\t\t\tlost = (next_cycle != cycle);\n\t\t\t\tif (!lost) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tdesc->cycle = prev_cycle;\n\t\t\t\t\tdesc->syt = 0;\n\t\t\t\t\tdesc->data_blocks = 0;\n\t\t\t\t\tdesc->data_block_counter = dbc;\n\t\t\t\t\tdesc->ctx_payload = NULL;\n\t\t\t\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t\t\t\t\t++(*desc_count);\n\t\t\t\t}\n\t\t\t} else if (s->flags & CIP_JUMBO_PAYLOAD) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tunsigned int safe_cycle = increment_ohci_cycle_count(next_cycle,\n\t\t\t\t\t\t\t\tIR_JUMBO_PAYLOAD_MAX_SKIP_CYCLES);\n\t\t\t\tlost = (compare_ohci_cycle_count(safe_cycle, cycle) > 0);\n\t\t\t}\n\t\t\tif (lost) {\n\t\t\t\tdev_err(&s->unit->device, \"Detect discontinuity of cycle: %d %d\\n\",\n\t\t\t\t\tnext_cycle, cycle);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\terr = parse_ir_ctx_header(s, cycle, ctx_header, &data_blocks, &dbc, &syt,\n\t\t\t\t\t  packet_index, i, curr_cycle_time);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdesc->cycle = cycle;\n\t\tdesc->syt = syt;\n\t\tdesc->data_blocks = data_blocks;\n\t\tdesc->data_block_counter = dbc;\n\t\tdesc->ctx_payload = s->buffer.packets[packet_index].buffer;\n\n\t\tif (!(s->flags & CIP_DBC_IS_END_EVENT))\n\t\t\tdbc = (dbc + desc->data_blocks) & 0xff;\n\n\t\tnext_cycle = increment_ohci_cycle_count(next_cycle, 1);\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t\t++(*desc_count);\n\t\tctx_header += s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);\n\t\tpacket_index = (packet_index + 1) % queue_size;\n\t}\n\n\ts->next_cycle = next_cycle;\n\ts->data_block_counter = dbc;\n\n\treturn 0;\n}\n\nstatic unsigned int compute_syt(unsigned int syt_offset, unsigned int cycle,\n\t\t\t\tunsigned int transfer_delay)\n{\n\tunsigned int syt;\n\n\tsyt_offset += transfer_delay;\n\tsyt = ((cycle + syt_offset / TICKS_PER_CYCLE) << 12) |\n\t      (syt_offset % TICKS_PER_CYCLE);\n\treturn syt & CIP_SYT_MASK;\n}\n\nstatic void generate_rx_packet_descs(struct amdtp_stream *s, struct pkt_desc *desc,\n\t\t\t\t     const __be32 *ctx_header, unsigned int packet_count)\n{\n\tstruct seq_desc *seq_descs = s->ctx_data.rx.seq.descs;\n\tunsigned int seq_size = s->ctx_data.rx.seq.size;\n\tunsigned int seq_pos = s->ctx_data.rx.seq.pos;\n\tunsigned int dbc = s->data_block_counter;\n\tbool aware_syt = !(s->flags & CIP_UNAWARE_SYT);\n\tint i;\n\n\tpool_seq_descs(s, seq_descs, seq_size, seq_pos, packet_count);\n\n\tfor (i = 0; i < packet_count; ++i) {\n\t\tunsigned int index = (s->packet_index + i) % s->queue_size;\n\t\tconst struct seq_desc *seq = seq_descs + seq_pos;\n\n\t\tdesc->cycle = compute_ohci_it_cycle(*ctx_header, s->queue_size);\n\n\t\tif (aware_syt && seq->syt_offset != CIP_SYT_NO_INFO)\n\t\t\tdesc->syt = compute_syt(seq->syt_offset, desc->cycle, s->transfer_delay);\n\t\telse\n\t\t\tdesc->syt = CIP_SYT_NO_INFO;\n\n\t\tdesc->data_blocks = seq->data_blocks;\n\n\t\tif (s->flags & CIP_DBC_IS_END_EVENT)\n\t\t\tdbc = (dbc + desc->data_blocks) & 0xff;\n\n\t\tdesc->data_block_counter = dbc;\n\n\t\tif (!(s->flags & CIP_DBC_IS_END_EVENT))\n\t\t\tdbc = (dbc + desc->data_blocks) & 0xff;\n\n\t\tdesc->ctx_payload = s->buffer.packets[index].buffer;\n\n\t\tseq_pos = (seq_pos + 1) % seq_size;\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\n\t\t++ctx_header;\n\t}\n\n\ts->data_block_counter = dbc;\n\ts->ctx_data.rx.seq.pos = seq_pos;\n}\n\nstatic inline void cancel_stream(struct amdtp_stream *s)\n{\n\ts->packet_index = -1;\n\tif (in_softirq())\n\t\tamdtp_stream_pcm_abort(s);\n\tWRITE_ONCE(s->pcm_buffer_pointer, SNDRV_PCM_POS_XRUN);\n}\n\nstatic snd_pcm_sframes_t compute_pcm_extra_delay(struct amdtp_stream *s,\n\t\t\t\t\t\t const struct pkt_desc *desc, unsigned int count)\n{\n\tunsigned int data_block_count = 0;\n\tu32 latest_cycle;\n\tu32 cycle_time;\n\tu32 curr_cycle;\n\tu32 cycle_gap;\n\tint i, err;\n\n\tif (count == 0)\n\t\tgoto end;\n\n\t\n\tfor (i = 0; i < count - 1; ++i)\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\tlatest_cycle = desc->cycle;\n\n\terr = fw_card_read_cycle_time(fw_parent_device(s->unit)->card, &cycle_time);\n\tif (err < 0)\n\t\tgoto end;\n\n\t\n\t\n\tcurr_cycle = compute_ohci_iso_ctx_cycle_count((cycle_time >> 12) & 0x0000ffff);\n\n\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\n\t\t\n\t\tif (compare_ohci_cycle_count(latest_cycle, curr_cycle) > 0)\n\t\t\tgoto end;\n\t\tcycle_gap = decrement_ohci_cycle_count(curr_cycle, latest_cycle);\n\n\t\t\n\t\t\n\t\t\n\t\tfor (i = 0; i < cycle_gap; ++i) {\n\t\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t\t\tdata_block_count += desc->data_blocks;\n\t\t}\n\t} else {\n\t\t\n\t\t\n\t\tif (compare_ohci_cycle_count(latest_cycle, curr_cycle) < 0)\n\t\t\tgoto end;\n\t\tcycle_gap = decrement_ohci_cycle_count(latest_cycle, curr_cycle);\n\n\t\t\n\t\tfor (i = 0; i < cycle_gap; ++i) {\n\t\t\tdata_block_count += desc->data_blocks;\n\t\t\tdesc = prev_packet_desc(s, desc);\n\t\t}\n\t}\nend:\n\treturn data_block_count * s->pcm_frame_multiplier;\n}\n\nstatic void process_ctx_payloads(struct amdtp_stream *s,\n\t\t\t\t const struct pkt_desc *desc,\n\t\t\t\t unsigned int count)\n{\n\tstruct snd_pcm_substream *pcm;\n\tint i;\n\n\tpcm = READ_ONCE(s->pcm);\n\ts->process_ctx_payloads(s, desc, count, pcm);\n\n\tif (pcm) {\n\t\tunsigned int data_block_count = 0;\n\n\t\tpcm->runtime->delay = compute_pcm_extra_delay(s, desc, count);\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tdata_block_count += desc->data_blocks;\n\t\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t\t}\n\n\t\tupdate_pcm_pointers(s, pcm, data_block_count * s->pcm_frame_multiplier);\n\t}\n}\n\nstatic void process_rx_packets(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t       void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tconst struct amdtp_domain *d = s->domain;\n\tconst __be32 *ctx_header = header;\n\tconst unsigned int events_per_period = d->events_per_period;\n\tunsigned int event_count = s->ctx_data.rx.event_count;\n\tstruct pkt_desc *desc = s->packet_descs_cursor;\n\tunsigned int pkt_header_length;\n\tunsigned int packets;\n\tu32 curr_cycle_time;\n\tbool need_hw_irq;\n\tint i;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\t\n\tpackets = header_length / sizeof(*ctx_header);\n\n\tgenerate_rx_packet_descs(s, desc, ctx_header, packets);\n\n\tprocess_ctx_payloads(s, desc, packets);\n\n\tif (!(s->flags & CIP_NO_HEADER))\n\t\tpkt_header_length = IT_PKT_HEADER_SIZE_CIP;\n\telse\n\t\tpkt_header_length = 0;\n\n\tif (s == d->irq_target) {\n\t\t\n\t\t\n\t\t\n\t\tstruct snd_pcm_substream *pcm = READ_ONCE(s->pcm);\n\t\tneed_hw_irq = !pcm || !pcm->runtime->no_period_wakeup;\n\t} else {\n\t\tneed_hw_irq = false;\n\t}\n\n\tif (trace_amdtp_packet_enabled())\n\t\t(void)fw_card_read_cycle_time(fw_parent_device(s->unit)->card, &curr_cycle_time);\n\n\tfor (i = 0; i < packets; ++i) {\n\t\tstruct {\n\t\t\tstruct fw_iso_packet params;\n\t\t\t__be32 header[CIP_HEADER_QUADLETS];\n\t\t} template = { {0}, {0} };\n\t\tbool sched_irq = false;\n\n\t\tbuild_it_pkt_header(s, desc->cycle, &template.params, pkt_header_length,\n\t\t\t\t    desc->data_blocks, desc->data_block_counter,\n\t\t\t\t    desc->syt, i, curr_cycle_time);\n\n\t\tif (s == s->domain->irq_target) {\n\t\t\tevent_count += desc->data_blocks;\n\t\t\tif (event_count >= events_per_period) {\n\t\t\t\tevent_count -= events_per_period;\n\t\t\t\tsched_irq = need_hw_irq;\n\t\t\t}\n\t\t}\n\n\t\tif (queue_out_packet(s, &template.params, sched_irq) < 0) {\n\t\t\tcancel_stream(s);\n\t\t\treturn;\n\t\t}\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n\n\ts->ctx_data.rx.event_count = event_count;\n\ts->packet_descs_cursor = desc;\n}\n\nstatic void skip_rx_packets(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t    void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\tconst __be32 *ctx_header = header;\n\tunsigned int packets;\n\tunsigned int cycle;\n\tint i;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\tpackets = header_length / sizeof(*ctx_header);\n\n\tcycle = compute_ohci_it_cycle(ctx_header[packets - 1], s->queue_size);\n\ts->next_cycle = increment_ohci_cycle_count(cycle, 1);\n\n\tfor (i = 0; i < packets; ++i) {\n\t\tstruct fw_iso_packet params = {\n\t\t\t.header_length = 0,\n\t\t\t.payload_length = 0,\n\t\t};\n\t\tbool sched_irq = (s == d->irq_target && i == packets - 1);\n\n\t\tif (queue_out_packet(s, &params, sched_irq) < 0) {\n\t\t\tcancel_stream(s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void irq_target_callback(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t\tvoid *header, void *private_data);\n\nstatic void process_rx_packets_intermediately(struct fw_iso_context *context, u32 tstamp,\n\t\t\t\t\tsize_t header_length, void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\t__be32 *ctx_header = header;\n\tconst unsigned int queue_size = s->queue_size;\n\tunsigned int packets;\n\tunsigned int offset;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\tpackets = header_length / sizeof(*ctx_header);\n\n\toffset = 0;\n\twhile (offset < packets) {\n\t\tunsigned int cycle = compute_ohci_it_cycle(ctx_header[offset], queue_size);\n\n\t\tif (compare_ohci_cycle_count(cycle, d->processing_cycle.rx_start) >= 0)\n\t\t\tbreak;\n\n\t\t++offset;\n\t}\n\n\tif (offset > 0) {\n\t\tunsigned int length = sizeof(*ctx_header) * offset;\n\n\t\tskip_rx_packets(context, tstamp, length, ctx_header, private_data);\n\t\tif (amdtp_streaming_error(s))\n\t\t\treturn;\n\n\t\tctx_header += offset;\n\t\theader_length -= length;\n\t}\n\n\tif (offset < packets) {\n\t\ts->ready_processing = true;\n\t\twake_up(&s->ready_wait);\n\n\t\tif (d->replay.enable)\n\t\t\ts->ctx_data.rx.cache_pos = 0;\n\n\t\tprocess_rx_packets(context, tstamp, header_length, ctx_header, private_data);\n\t\tif (amdtp_streaming_error(s))\n\t\t\treturn;\n\n\t\tif (s == d->irq_target)\n\t\t\ts->context->callback.sc = irq_target_callback;\n\t\telse\n\t\t\ts->context->callback.sc = process_rx_packets;\n\t}\n}\n\nstatic void process_tx_packets(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t       void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\t__be32 *ctx_header = header;\n\tstruct pkt_desc *desc = s->packet_descs_cursor;\n\tunsigned int packet_count;\n\tunsigned int desc_count;\n\tint i;\n\tint err;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\t\n\tpacket_count = header_length / s->ctx_data.tx.ctx_header_size;\n\n\tdesc_count = 0;\n\terr = generate_tx_packet_descs(s, desc, ctx_header, packet_count, &desc_count);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN) {\n\t\t\tcancel_stream(s);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tstruct amdtp_domain *d = s->domain;\n\n\t\tprocess_ctx_payloads(s, desc, desc_count);\n\n\t\tif (d->replay.enable)\n\t\t\tcache_seq(s, desc, desc_count);\n\n\t\tfor (i = 0; i < desc_count; ++i)\n\t\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t\ts->packet_descs_cursor = desc;\n\t}\n\n\tfor (i = 0; i < packet_count; ++i) {\n\t\tstruct fw_iso_packet params = {0};\n\n\t\tif (queue_in_packet(s, &params) < 0) {\n\t\t\tcancel_stream(s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void drop_tx_packets(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t    void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tconst __be32 *ctx_header = header;\n\tunsigned int packets;\n\tunsigned int cycle;\n\tint i;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\tpackets = header_length / s->ctx_data.tx.ctx_header_size;\n\n\tctx_header += (packets - 1) * s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);\n\tcycle = compute_ohci_cycle_count(ctx_header[1]);\n\ts->next_cycle = increment_ohci_cycle_count(cycle, 1);\n\n\tfor (i = 0; i < packets; ++i) {\n\t\tstruct fw_iso_packet params = {0};\n\n\t\tif (queue_in_packet(s, &params) < 0) {\n\t\t\tcancel_stream(s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void process_tx_packets_intermediately(struct fw_iso_context *context, u32 tstamp,\n\t\t\t\t\tsize_t header_length, void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\t__be32 *ctx_header;\n\tunsigned int packets;\n\tunsigned int offset;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\tpackets = header_length / s->ctx_data.tx.ctx_header_size;\n\n\toffset = 0;\n\tctx_header = header;\n\twhile (offset < packets) {\n\t\tunsigned int cycle = compute_ohci_cycle_count(ctx_header[1]);\n\n\t\tif (compare_ohci_cycle_count(cycle, d->processing_cycle.tx_start) >= 0)\n\t\t\tbreak;\n\n\t\tctx_header += s->ctx_data.tx.ctx_header_size / sizeof(__be32);\n\t\t++offset;\n\t}\n\n\tctx_header = header;\n\n\tif (offset > 0) {\n\t\tsize_t length = s->ctx_data.tx.ctx_header_size * offset;\n\n\t\tdrop_tx_packets(context, tstamp, length, ctx_header, s);\n\t\tif (amdtp_streaming_error(s))\n\t\t\treturn;\n\n\t\tctx_header += length / sizeof(*ctx_header);\n\t\theader_length -= length;\n\t}\n\n\tif (offset < packets) {\n\t\ts->ready_processing = true;\n\t\twake_up(&s->ready_wait);\n\n\t\tprocess_tx_packets(context, tstamp, header_length, ctx_header, s);\n\t\tif (amdtp_streaming_error(s))\n\t\t\treturn;\n\n\t\tcontext->callback.sc = process_tx_packets;\n\t}\n}\n\nstatic void drop_tx_packets_initially(struct fw_iso_context *context, u32 tstamp,\n\t\t\t\t      size_t header_length, void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\t__be32 *ctx_header;\n\tunsigned int count;\n\tunsigned int events;\n\tint i;\n\n\tif (s->packet_index < 0)\n\t\treturn;\n\n\tcount = header_length / s->ctx_data.tx.ctx_header_size;\n\n\t\n\tevents = 0;\n\tctx_header = header;\n\tfor (i = 0; i < count; ++i) {\n\t\tunsigned int payload_quads =\n\t\t\t(be32_to_cpu(*ctx_header) >> ISO_DATA_LENGTH_SHIFT) / sizeof(__be32);\n\t\tunsigned int data_blocks;\n\n\t\tif (s->flags & CIP_NO_HEADER) {\n\t\t\tdata_blocks = payload_quads / s->data_block_quadlets;\n\t\t} else {\n\t\t\t__be32 *cip_headers = ctx_header + IR_CTX_HEADER_DEFAULT_QUADLETS;\n\n\t\t\tif (payload_quads < CIP_HEADER_QUADLETS) {\n\t\t\t\tdata_blocks = 0;\n\t\t\t} else {\n\t\t\t\tpayload_quads -= CIP_HEADER_QUADLETS;\n\n\t\t\t\tif (s->flags & CIP_UNAWARE_SYT) {\n\t\t\t\t\tdata_blocks = payload_quads / s->data_block_quadlets;\n\t\t\t\t} else {\n\t\t\t\t\tu32 cip1 = be32_to_cpu(cip_headers[1]);\n\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif ((cip1 & CIP_NO_DATA) == CIP_NO_DATA)\n\t\t\t\t\t\tdata_blocks = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tdata_blocks = payload_quads / s->data_block_quadlets;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tevents += data_blocks;\n\n\t\tctx_header += s->ctx_data.tx.ctx_header_size / sizeof(__be32);\n\t}\n\n\tdrop_tx_packets(context, tstamp, header_length, header, s);\n\n\tif (events > 0)\n\t\ts->ctx_data.tx.event_starts = true;\n\n\t\n\t{\n\t\tunsigned int stream_count = 0;\n\t\tunsigned int event_starts_count = 0;\n\t\tunsigned int cycle = UINT_MAX;\n\n\t\tlist_for_each_entry(s, &d->streams, list) {\n\t\t\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\t\t++stream_count;\n\t\t\t\tif (s->ctx_data.tx.event_starts)\n\t\t\t\t\t++event_starts_count;\n\t\t\t}\n\t\t}\n\n\t\tif (stream_count == event_starts_count) {\n\t\t\tunsigned int next_cycle;\n\n\t\t\tlist_for_each_entry(s, &d->streams, list) {\n\t\t\t\tif (s->direction != AMDTP_IN_STREAM)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnext_cycle = increment_ohci_cycle_count(s->next_cycle,\n\t\t\t\t\t\t\t\td->processing_cycle.tx_init_skip);\n\t\t\t\tif (cycle == UINT_MAX ||\n\t\t\t\t    compare_ohci_cycle_count(next_cycle, cycle) > 0)\n\t\t\t\t\tcycle = next_cycle;\n\n\t\t\t\ts->context->callback.sc = process_tx_packets_intermediately;\n\t\t\t}\n\n\t\t\td->processing_cycle.tx_start = cycle;\n\t\t}\n\t}\n}\n\nstatic void process_ctxs_in_domain(struct amdtp_domain *d)\n{\n\tstruct amdtp_stream *s;\n\n\tlist_for_each_entry(s, &d->streams, list) {\n\t\tif (s != d->irq_target && amdtp_stream_running(s))\n\t\t\tfw_iso_context_flush_completions(s->context);\n\n\t\tif (amdtp_streaming_error(s))\n\t\t\tgoto error;\n\t}\n\n\treturn;\nerror:\n\tif (amdtp_stream_running(d->irq_target))\n\t\tcancel_stream(d->irq_target);\n\n\tlist_for_each_entry(s, &d->streams, list) {\n\t\tif (amdtp_stream_running(s))\n\t\t\tcancel_stream(s);\n\t}\n}\n\nstatic void irq_target_callback(struct fw_iso_context *context, u32 tstamp, size_t header_length,\n\t\t\t\tvoid *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\n\tprocess_rx_packets(context, tstamp, header_length, header, private_data);\n\tprocess_ctxs_in_domain(d);\n}\n\nstatic void irq_target_callback_intermediately(struct fw_iso_context *context, u32 tstamp,\n\t\t\t\t\tsize_t header_length, void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\n\tprocess_rx_packets_intermediately(context, tstamp, header_length, header, private_data);\n\tprocess_ctxs_in_domain(d);\n}\n\nstatic void irq_target_callback_skip(struct fw_iso_context *context, u32 tstamp,\n\t\t\t\t     size_t header_length, void *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\tbool ready_to_start;\n\n\tskip_rx_packets(context, tstamp, header_length, header, private_data);\n\tprocess_ctxs_in_domain(d);\n\n\tif (d->replay.enable && !d->replay.on_the_fly) {\n\t\tunsigned int rx_count = 0;\n\t\tunsigned int rx_ready_count = 0;\n\t\tstruct amdtp_stream *rx;\n\n\t\tlist_for_each_entry(rx, &d->streams, list) {\n\t\t\tstruct amdtp_stream *tx;\n\t\t\tunsigned int cached_cycles;\n\n\t\t\tif (rx->direction != AMDTP_OUT_STREAM)\n\t\t\t\tcontinue;\n\t\t\t++rx_count;\n\n\t\t\ttx = rx->ctx_data.rx.replay_target;\n\t\t\tcached_cycles = calculate_cached_cycle_count(tx, 0);\n\t\t\tif (cached_cycles > tx->ctx_data.tx.cache.size / 2)\n\t\t\t\t++rx_ready_count;\n\t\t}\n\n\t\tready_to_start = (rx_count == rx_ready_count);\n\t} else {\n\t\tready_to_start = true;\n\t}\n\n\t\n\t\n\tif (ready_to_start) {\n\t\tunsigned int cycle = s->next_cycle;\n\t\tlist_for_each_entry(s, &d->streams, list) {\n\t\t\tif (s->direction != AMDTP_OUT_STREAM)\n\t\t\t\tcontinue;\n\n\t\t\tif (compare_ohci_cycle_count(s->next_cycle, cycle) > 0)\n\t\t\t\tcycle = s->next_cycle;\n\n\t\t\tif (s == d->irq_target)\n\t\t\t\ts->context->callback.sc = irq_target_callback_intermediately;\n\t\t\telse\n\t\t\t\ts->context->callback.sc = process_rx_packets_intermediately;\n\t\t}\n\n\t\td->processing_cycle.rx_start = cycle;\n\t}\n}\n\n\n\nstatic void amdtp_stream_first_callback(struct fw_iso_context *context,\n\t\t\t\t\tu32 tstamp, size_t header_length,\n\t\t\t\t\tvoid *header, void *private_data)\n{\n\tstruct amdtp_stream *s = private_data;\n\tstruct amdtp_domain *d = s->domain;\n\n\tif (s->direction == AMDTP_IN_STREAM) {\n\t\tcontext->callback.sc = drop_tx_packets_initially;\n\t} else {\n\t\tif (s == d->irq_target)\n\t\t\tcontext->callback.sc = irq_target_callback_skip;\n\t\telse\n\t\t\tcontext->callback.sc = skip_rx_packets;\n\t}\n\n\tcontext->callback.sc(context, tstamp, header_length, header, s);\n}\n\n \nstatic int amdtp_stream_start(struct amdtp_stream *s, int channel, int speed,\n\t\t\t      unsigned int queue_size, unsigned int idle_irq_interval)\n{\n\tbool is_irq_target = (s == s->domain->irq_target);\n\tunsigned int ctx_header_size;\n\tunsigned int max_ctx_payload_size;\n\tenum dma_data_direction dir;\n\tstruct pkt_desc *descs;\n\tint i, type, tag, err;\n\n\tmutex_lock(&s->mutex);\n\n\tif (WARN_ON(amdtp_stream_running(s) ||\n\t\t    (s->data_block_quadlets < 1))) {\n\t\terr = -EBADFD;\n\t\tgoto err_unlock;\n\t}\n\n\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\n\t\tif (is_irq_target) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\ts->data_block_counter = UINT_MAX;\n\t} else {\n\t\ts->data_block_counter = 0;\n\t}\n\n\t\n\tif (s->direction == AMDTP_IN_STREAM) {\n\t\tdir = DMA_FROM_DEVICE;\n\t\ttype = FW_ISO_CONTEXT_RECEIVE;\n\t\tif (!(s->flags & CIP_NO_HEADER))\n\t\t\tctx_header_size = IR_CTX_HEADER_SIZE_CIP;\n\t\telse\n\t\t\tctx_header_size = IR_CTX_HEADER_SIZE_NO_CIP;\n\t} else {\n\t\tdir = DMA_TO_DEVICE;\n\t\ttype = FW_ISO_CONTEXT_TRANSMIT;\n\t\tctx_header_size = 0;\t\n\t}\n\tmax_ctx_payload_size = amdtp_stream_get_max_ctx_payload_size(s);\n\n\terr = iso_packets_buffer_init(&s->buffer, s->unit, queue_size, max_ctx_payload_size, dir);\n\tif (err < 0)\n\t\tgoto err_unlock;\n\ts->queue_size = queue_size;\n\n\ts->context = fw_iso_context_create(fw_parent_device(s->unit)->card,\n\t\t\t\t\t  type, channel, speed, ctx_header_size,\n\t\t\t\t\t  amdtp_stream_first_callback, s);\n\tif (IS_ERR(s->context)) {\n\t\terr = PTR_ERR(s->context);\n\t\tif (err == -EBUSY)\n\t\t\tdev_err(&s->unit->device,\n\t\t\t\t\"no free stream on this controller\\n\");\n\t\tgoto err_buffer;\n\t}\n\n\tamdtp_stream_update(s);\n\n\tif (s->direction == AMDTP_IN_STREAM) {\n\t\ts->ctx_data.tx.max_ctx_payload_length = max_ctx_payload_size;\n\t\ts->ctx_data.tx.ctx_header_size = ctx_header_size;\n\t\ts->ctx_data.tx.event_starts = false;\n\n\t\tif (s->domain->replay.enable) {\n\t\t\t\n\t\t\t\n\t\t\ts->ctx_data.tx.cache.size = max_t(unsigned int, s->syt_interval * 2,\n\t\t\t\t\t\t\t  queue_size * 3 / 2);\n\t\t\ts->ctx_data.tx.cache.pos = 0;\n\t\t\ts->ctx_data.tx.cache.descs = kcalloc(s->ctx_data.tx.cache.size,\n\t\t\t\t\t\tsizeof(*s->ctx_data.tx.cache.descs), GFP_KERNEL);\n\t\t\tif (!s->ctx_data.tx.cache.descs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_context;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstatic const struct {\n\t\t\tunsigned int data_block;\n\t\t\tunsigned int syt_offset;\n\t\t} *entry, initial_state[] = {\n\t\t\t[CIP_SFC_32000]  = {  4, 3072 },\n\t\t\t[CIP_SFC_48000]  = {  6, 1024 },\n\t\t\t[CIP_SFC_96000]  = { 12, 1024 },\n\t\t\t[CIP_SFC_192000] = { 24, 1024 },\n\t\t\t[CIP_SFC_44100]  = {  0,   67 },\n\t\t\t[CIP_SFC_88200]  = {  0,   67 },\n\t\t\t[CIP_SFC_176400] = {  0,   67 },\n\t\t};\n\n\t\ts->ctx_data.rx.seq.descs = kcalloc(queue_size, sizeof(*s->ctx_data.rx.seq.descs), GFP_KERNEL);\n\t\tif (!s->ctx_data.rx.seq.descs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_context;\n\t\t}\n\t\ts->ctx_data.rx.seq.size = queue_size;\n\t\ts->ctx_data.rx.seq.pos = 0;\n\n\t\tentry = &initial_state[s->sfc];\n\t\ts->ctx_data.rx.data_block_state = entry->data_block;\n\t\ts->ctx_data.rx.syt_offset_state = entry->syt_offset;\n\t\ts->ctx_data.rx.last_syt_offset = TICKS_PER_CYCLE;\n\n\t\ts->ctx_data.rx.event_count = 0;\n\t}\n\n\tif (s->flags & CIP_NO_HEADER)\n\t\ts->tag = TAG_NO_CIP_HEADER;\n\telse\n\t\ts->tag = TAG_CIP;\n\n\t\n\t\n\t\n\t\n\tdescs = kcalloc(s->queue_size + 8, sizeof(*descs), GFP_KERNEL);\n\tif (!descs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_context;\n\t}\n\ts->packet_descs = descs;\n\n\tINIT_LIST_HEAD(&s->packet_descs_list);\n\tfor (i = 0; i < s->queue_size; ++i) {\n\t\tINIT_LIST_HEAD(&descs->link);\n\t\tlist_add_tail(&descs->link, &s->packet_descs_list);\n\t\t++descs;\n\t}\n\ts->packet_descs_cursor = list_first_entry(&s->packet_descs_list, struct pkt_desc, link);\n\n\ts->packet_index = 0;\n\tdo {\n\t\tstruct fw_iso_packet params;\n\n\t\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\terr = queue_in_packet(s, &params);\n\t\t} else {\n\t\t\tbool sched_irq = false;\n\n\t\t\tparams.header_length = 0;\n\t\t\tparams.payload_length = 0;\n\n\t\t\tif (is_irq_target) {\n\t\t\t\tsched_irq = !((s->packet_index + 1) %\n\t\t\t\t\t      idle_irq_interval);\n\t\t\t}\n\n\t\t\terr = queue_out_packet(s, &params, sched_irq);\n\t\t}\n\t\tif (err < 0)\n\t\t\tgoto err_pkt_descs;\n\t} while (s->packet_index > 0);\n\n\t \n\ttag = FW_ISO_CONTEXT_MATCH_TAG1;\n\tif ((s->flags & CIP_EMPTY_WITH_TAG0) || (s->flags & CIP_NO_HEADER))\n\t\ttag |= FW_ISO_CONTEXT_MATCH_TAG0;\n\n\ts->ready_processing = false;\n\terr = fw_iso_context_start(s->context, -1, 0, tag);\n\tif (err < 0)\n\t\tgoto err_pkt_descs;\n\n\tmutex_unlock(&s->mutex);\n\n\treturn 0;\nerr_pkt_descs:\n\tkfree(s->packet_descs);\n\ts->packet_descs = NULL;\nerr_context:\n\tif (s->direction == AMDTP_OUT_STREAM) {\n\t\tkfree(s->ctx_data.rx.seq.descs);\n\t} else {\n\t\tif (s->domain->replay.enable)\n\t\t\tkfree(s->ctx_data.tx.cache.descs);\n\t}\n\tfw_iso_context_destroy(s->context);\n\ts->context = ERR_PTR(-1);\nerr_buffer:\n\tiso_packets_buffer_destroy(&s->buffer, s->unit);\nerr_unlock:\n\tmutex_unlock(&s->mutex);\n\n\treturn err;\n}\n\n \nunsigned long amdtp_domain_stream_pcm_pointer(struct amdtp_domain *d,\n\t\t\t\t\t      struct amdtp_stream *s)\n{\n\tstruct amdtp_stream *irq_target = d->irq_target;\n\n\t\n\tif (irq_target && amdtp_stream_running(irq_target)) {\n\t\t\n\t\t\n\t\tif (!in_softirq())\n\t\t\tfw_iso_context_flush_completions(irq_target->context);\n\t}\n\n\treturn READ_ONCE(s->pcm_buffer_pointer);\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_stream_pcm_pointer);\n\n \nint amdtp_domain_stream_pcm_ack(struct amdtp_domain *d, struct amdtp_stream *s)\n{\n\tstruct amdtp_stream *irq_target = d->irq_target;\n\n\t\n\t\n\tif (irq_target && amdtp_stream_running(irq_target))\n\t\tfw_iso_context_flush_completions(irq_target->context);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_stream_pcm_ack);\n\n \nvoid amdtp_stream_update(struct amdtp_stream *s)\n{\n\t \n\tWRITE_ONCE(s->source_node_id_field,\n                   (fw_parent_device(s->unit)->card->node_id << CIP_SID_SHIFT) & CIP_SID_MASK);\n}\nEXPORT_SYMBOL(amdtp_stream_update);\n\n \nstatic void amdtp_stream_stop(struct amdtp_stream *s)\n{\n\tmutex_lock(&s->mutex);\n\n\tif (!amdtp_stream_running(s)) {\n\t\tmutex_unlock(&s->mutex);\n\t\treturn;\n\t}\n\n\tfw_iso_context_stop(s->context);\n\tfw_iso_context_destroy(s->context);\n\ts->context = ERR_PTR(-1);\n\tiso_packets_buffer_destroy(&s->buffer, s->unit);\n\tkfree(s->packet_descs);\n\ts->packet_descs = NULL;\n\n\tif (s->direction == AMDTP_OUT_STREAM) {\n\t\tkfree(s->ctx_data.rx.seq.descs);\n\t} else {\n\t\tif (s->domain->replay.enable)\n\t\t\tkfree(s->ctx_data.tx.cache.descs);\n\t}\n\n\tmutex_unlock(&s->mutex);\n}\n\n \nvoid amdtp_stream_pcm_abort(struct amdtp_stream *s)\n{\n\tstruct snd_pcm_substream *pcm;\n\n\tpcm = READ_ONCE(s->pcm);\n\tif (pcm)\n\t\tsnd_pcm_stop_xrun(pcm);\n}\nEXPORT_SYMBOL(amdtp_stream_pcm_abort);\n\n \nint amdtp_domain_init(struct amdtp_domain *d)\n{\n\tINIT_LIST_HEAD(&d->streams);\n\n\td->events_per_period = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_init);\n\n \nvoid amdtp_domain_destroy(struct amdtp_domain *d)\n{\n\t\n\treturn;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_destroy);\n\n \nint amdtp_domain_add_stream(struct amdtp_domain *d, struct amdtp_stream *s,\n\t\t\t    int channel, int speed)\n{\n\tstruct amdtp_stream *tmp;\n\n\tlist_for_each_entry(tmp, &d->streams, list) {\n\t\tif (s == tmp)\n\t\t\treturn -EBUSY;\n\t}\n\n\tlist_add(&s->list, &d->streams);\n\n\ts->channel = channel;\n\ts->speed = speed;\n\ts->domain = d;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_add_stream);\n\n\n\nstatic int make_association(struct amdtp_domain *d)\n{\n\tunsigned int dst_index = 0;\n\tstruct amdtp_stream *rx;\n\n\t\n\tlist_for_each_entry(rx, &d->streams, list) {\n\t\tif (rx->direction == AMDTP_OUT_STREAM) {\n\t\t\tunsigned int src_index = 0;\n\t\t\tstruct amdtp_stream *tx = NULL;\n\t\t\tstruct amdtp_stream *s;\n\n\t\t\tlist_for_each_entry(s, &d->streams, list) {\n\t\t\t\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\t\t\tif (dst_index == src_index) {\n\t\t\t\t\t\ttx = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t++src_index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tx) {\n\t\t\t\t\n\t\t\t\tlist_for_each_entry(s, &d->streams, list) {\n\t\t\t\t\tif (s->direction == AMDTP_IN_STREAM) {\n\t\t\t\t\t\ttx = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!tx)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trx->ctx_data.rx.replay_target = tx;\n\n\t\t\t++dst_index;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint amdtp_domain_start(struct amdtp_domain *d, unsigned int tx_init_skip_cycles, bool replay_seq,\n\t\t       bool replay_on_the_fly)\n{\n\tunsigned int events_per_buffer = d->events_per_buffer;\n\tunsigned int events_per_period = d->events_per_period;\n\tunsigned int queue_size;\n\tstruct amdtp_stream *s;\n\tbool found = false;\n\tint err;\n\n\tif (replay_seq) {\n\t\terr = make_association(d);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\td->replay.enable = replay_seq;\n\td->replay.on_the_fly = replay_on_the_fly;\n\n\t\n\tlist_for_each_entry(s, &d->streams, list) {\n\t\tif (s->direction == AMDTP_OUT_STREAM) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENXIO;\n\td->irq_target = s;\n\n\td->processing_cycle.tx_init_skip = tx_init_skip_cycles;\n\n\t\n\t\n\t\n\tif (events_per_period == 0)\n\t\tevents_per_period = amdtp_rate_table[d->irq_target->sfc] / 100;\n\tif (events_per_buffer == 0)\n\t\tevents_per_buffer = events_per_period * 3;\n\n\tqueue_size = DIV_ROUND_UP(CYCLES_PER_SECOND * events_per_buffer,\n\t\t\t\t  amdtp_rate_table[d->irq_target->sfc]);\n\n\tlist_for_each_entry(s, &d->streams, list) {\n\t\tunsigned int idle_irq_interval = 0;\n\n\t\tif (s->direction == AMDTP_OUT_STREAM && s == d->irq_target) {\n\t\t\tidle_irq_interval = DIV_ROUND_UP(CYCLES_PER_SECOND * events_per_period,\n\t\t\t\t\t\t\t amdtp_rate_table[d->irq_target->sfc]);\n\t\t}\n\n\t\t\n\t\terr = amdtp_stream_start(s, s->channel, s->speed, queue_size, idle_irq_interval);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tlist_for_each_entry(s, &d->streams, list)\n\t\tamdtp_stream_stop(s);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_start);\n\n \nvoid amdtp_domain_stop(struct amdtp_domain *d)\n{\n\tstruct amdtp_stream *s, *next;\n\n\tif (d->irq_target)\n\t\tamdtp_stream_stop(d->irq_target);\n\n\tlist_for_each_entry_safe(s, next, &d->streams, list) {\n\t\tlist_del(&s->list);\n\n\t\tif (s != d->irq_target)\n\t\t\tamdtp_stream_stop(s);\n\t}\n\n\td->events_per_period = 0;\n\td->irq_target = NULL;\n}\nEXPORT_SYMBOL_GPL(amdtp_domain_stop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}