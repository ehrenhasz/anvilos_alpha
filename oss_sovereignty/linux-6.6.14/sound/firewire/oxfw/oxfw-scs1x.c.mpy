{
  "module_name": "oxfw-scs1x.c",
  "hash_id": "1db4cb5ed11ae350b77b2f49f7ce40c689f4dce9ae0c1352ee7f105a99cf3e39",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw-scs1x.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n\n#define HSS1394_ADDRESS\t\t\t0xc007dedadadaULL\n#define HSS1394_MAX_PACKET_SIZE\t\t64\n#define HSS1394_TAG_USER_DATA\t\t0x00\n#define HSS1394_TAG_CHANGE_ADDRESS\t0xf1\n\nstruct fw_scs1x {\n\tstruct fw_address_handler hss_handler;\n\tu8 input_escape_count;\n\tstruct snd_rawmidi_substream *input;\n\n\t \n\tstruct snd_rawmidi_substream *output;\n\tbool output_idle;\n\tu8 output_status;\n\tu8 output_bytes;\n\tbool output_escaped;\n\tbool output_escape_high_nibble;\n\tstruct work_struct work;\n\twait_queue_head_t idle_wait;\n\tu8 buffer[HSS1394_MAX_PACKET_SIZE];\n\tbool transaction_running;\n\tstruct fw_transaction transaction;\n\tunsigned int transaction_bytes;\n\tbool error;\n\tstruct fw_device *fw_dev;\n};\n\nstatic const u8 sysex_escape_prefix[] = {\n\t0xf0,\t\t\t \n\t0x00, 0x01, 0x60,\t \n\t0x48, 0x53, 0x53,\t \n};\n\nstatic void midi_input_escaped_byte(struct snd_rawmidi_substream *stream,\n\t\t\t\t    u8 byte)\n{\n\tu8 nibbles[2];\n\n\tnibbles[0] = byte >> 4;\n\tnibbles[1] = byte & 0x0f;\n\tsnd_rawmidi_receive(stream, nibbles, 2);\n}\n\nstatic void midi_input_byte(struct fw_scs1x *scs,\n\t\t\t    struct snd_rawmidi_substream *stream, u8 byte)\n{\n\tconst u8 eox = 0xf7;\n\n\tif (scs->input_escape_count > 0) {\n\t\tmidi_input_escaped_byte(stream, byte);\n\t\tscs->input_escape_count--;\n\t\tif (scs->input_escape_count == 0)\n\t\t\tsnd_rawmidi_receive(stream, &eox, sizeof(eox));\n\t} else if (byte == 0xf9) {\n\t\tsnd_rawmidi_receive(stream, sysex_escape_prefix,\n\t\t\t\t    ARRAY_SIZE(sysex_escape_prefix));\n\t\tmidi_input_escaped_byte(stream, 0x00);\n\t\tmidi_input_escaped_byte(stream, 0xf9);\n\t\tscs->input_escape_count = 3;\n\t} else {\n\t\tsnd_rawmidi_receive(stream, &byte, 1);\n\t}\n}\n\nstatic void midi_input_packet(struct fw_scs1x *scs,\n\t\t\t      struct snd_rawmidi_substream *stream,\n\t\t\t      const u8 *data, unsigned int bytes)\n{\n\tunsigned int i;\n\tconst u8 eox = 0xf7;\n\n\tif (data[0] == HSS1394_TAG_USER_DATA) {\n\t\tfor (i = 1; i < bytes; ++i)\n\t\t\tmidi_input_byte(scs, stream, data[i]);\n\t} else {\n\t\tsnd_rawmidi_receive(stream, sysex_escape_prefix,\n\t\t\t\t    ARRAY_SIZE(sysex_escape_prefix));\n\t\tfor (i = 0; i < bytes; ++i)\n\t\t\tmidi_input_escaped_byte(stream, data[i]);\n\t\tsnd_rawmidi_receive(stream, &eox, sizeof(eox));\n\t}\n}\n\nstatic void handle_hss(struct fw_card *card, struct fw_request *request,\n\t\t       int tcode, int destination, int source, int generation,\n\t\t       unsigned long long offset, void *data, size_t length,\n\t\t       void *callback_data)\n{\n\tstruct fw_scs1x *scs = callback_data;\n\tstruct snd_rawmidi_substream *stream;\n\tint rcode;\n\n\tif (offset != scs->hss_handler.offset) {\n\t\trcode = RCODE_ADDRESS_ERROR;\n\t\tgoto end;\n\t}\n\tif (tcode != TCODE_WRITE_QUADLET_REQUEST &&\n\t    tcode != TCODE_WRITE_BLOCK_REQUEST) {\n\t\trcode = RCODE_TYPE_ERROR;\n\t\tgoto end;\n\t}\n\n\tif (length >= 1) {\n\t\tstream = READ_ONCE(scs->input);\n\t\tif (stream)\n\t\t\tmidi_input_packet(scs, stream, data, length);\n\t}\n\n\trcode = RCODE_COMPLETE;\nend:\n\tfw_send_response(card, request, rcode);\n}\n\nstatic void scs_write_callback(struct fw_card *card, int rcode,\n\t\t\t       void *data, size_t length, void *callback_data)\n{\n\tstruct fw_scs1x *scs = callback_data;\n\n\tif (!rcode_is_permanent_error(rcode)) {\n\t\t \n\t\tif (rcode == RCODE_COMPLETE)\n\t\t\tscs->transaction_bytes = 0;\n\t} else {\n\t\tscs->error = true;\n\t}\n\n\tscs->transaction_running = false;\n\tschedule_work(&scs->work);\n}\n\nstatic bool is_valid_running_status(u8 status)\n{\n\treturn status >= 0x80 && status <= 0xef;\n}\n\nstatic bool is_one_byte_cmd(u8 status)\n{\n\treturn status == 0xf6 ||\n\t       status >= 0xf8;\n}\n\nstatic bool is_two_bytes_cmd(u8 status)\n{\n\treturn (status >= 0xc0 && status <= 0xdf) ||\n\t       status == 0xf1 ||\n\t       status == 0xf3;\n}\n\nstatic bool is_three_bytes_cmd(u8 status)\n{\n\treturn (status >= 0x80 && status <= 0xbf) ||\n\t       (status >= 0xe0 && status <= 0xef) ||\n\t       status == 0xf2;\n}\n\nstatic bool is_invalid_cmd(u8 status)\n{\n\treturn status == 0xf4 ||\n\t       status == 0xf5 ||\n\t       status == 0xf9 ||\n\t       status == 0xfd;\n}\n\nstatic void scs_output_work(struct work_struct *work)\n{\n\tstruct fw_scs1x *scs = container_of(work, struct fw_scs1x, work);\n\tstruct snd_rawmidi_substream *stream;\n\tunsigned int i;\n\tu8 byte;\n\tint generation;\n\n\tif (scs->transaction_running)\n\t\treturn;\n\n\tstream = READ_ONCE(scs->output);\n\tif (!stream || scs->error) {\n\t\tscs->output_idle = true;\n\t\twake_up(&scs->idle_wait);\n\t\treturn;\n\t}\n\n\tif (scs->transaction_bytes > 0)\n\t\tgoto retry;\n\n\ti = scs->output_bytes;\n\tfor (;;) {\n\t\tif (snd_rawmidi_transmit(stream, &byte, 1) != 1) {\n\t\t\tscs->output_bytes = i;\n\t\t\tscs->output_idle = true;\n\t\t\twake_up(&scs->idle_wait);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (scs->output_escaped && byte < 0x80) {\n\t\t\tif (scs->output_escape_high_nibble) {\n\t\t\t\tif (i < HSS1394_MAX_PACKET_SIZE) {\n\t\t\t\t\tscs->buffer[i] = byte << 4;\n\t\t\t\t\tscs->output_escape_high_nibble = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscs->buffer[i++] |= byte & 0x0f;\n\t\t\t\tscs->output_escape_high_nibble = true;\n\t\t\t}\n\t\t} else if (byte < 0x80) {\n\t\t\tif (i == 1) {\n\t\t\t\tif (!is_valid_running_status(\n\t\t\t\t\t\t\tscs->output_status))\n\t\t\t\t\tcontinue;\n\t\t\t\tscs->buffer[0] = HSS1394_TAG_USER_DATA;\n\t\t\t\tscs->buffer[i++] = scs->output_status;\n\t\t\t}\n\t\t\tscs->buffer[i++] = byte;\n\t\t\tif ((i == 3 && is_two_bytes_cmd(scs->output_status)) ||\n\t\t\t    (i == 4 && is_three_bytes_cmd(scs->output_status)))\n\t\t\t\tbreak;\n\t\t\tif (i == 1 + ARRAY_SIZE(sysex_escape_prefix) &&\n\t\t\t    !memcmp(scs->buffer + 1, sysex_escape_prefix,\n\t\t\t\t    ARRAY_SIZE(sysex_escape_prefix))) {\n\t\t\t\tscs->output_escaped = true;\n\t\t\t\tscs->output_escape_high_nibble = true;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tif (i >= HSS1394_MAX_PACKET_SIZE)\n\t\t\t\ti = 1;\n\t\t} else if (byte == 0xf7) {\n\t\t\tif (scs->output_escaped) {\n\t\t\t\tif (i >= 1 && scs->output_escape_high_nibble &&\n\t\t\t\t    scs->buffer[0] !=\n\t\t\t\t\t\tHSS1394_TAG_CHANGE_ADDRESS)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (i > 1 && scs->output_status == 0xf0) {\n\t\t\t\t\tscs->buffer[i++] = 0xf7;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = 1;\n\t\t\tscs->output_escaped = false;\n\t\t} else if (!is_invalid_cmd(byte) && byte < 0xf8) {\n\t\t\ti = 1;\n\t\t\tscs->buffer[0] = HSS1394_TAG_USER_DATA;\n\t\t\tscs->buffer[i++] = byte;\n\t\t\tscs->output_status = byte;\n\t\t\tscs->output_escaped = false;\n\t\t\tif (is_one_byte_cmd(byte))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscs->output_bytes = 1;\n\tscs->output_escaped = false;\n\n\tscs->transaction_bytes = i;\nretry:\n\tscs->transaction_running = true;\n\tgeneration = scs->fw_dev->generation;\n\tsmp_rmb();  \n\tfw_send_request(scs->fw_dev->card, &scs->transaction,\n\t\t\tTCODE_WRITE_BLOCK_REQUEST, scs->fw_dev->node_id,\n\t\t\tgeneration, scs->fw_dev->max_speed, HSS1394_ADDRESS,\n\t\t\tscs->buffer, scs->transaction_bytes,\n\t\t\tscs_write_callback, scs);\n}\n\nstatic int midi_capture_open(struct snd_rawmidi_substream *stream)\n{\n\treturn 0;\n}\n\nstatic int midi_capture_close(struct snd_rawmidi_substream *stream)\n{\n\treturn 0;\n}\n\nstatic void midi_capture_trigger(struct snd_rawmidi_substream *stream, int up)\n{\n\tstruct fw_scs1x *scs = stream->rmidi->private_data;\n\n\tif (up) {\n\t\tscs->input_escape_count = 0;\n\t\tWRITE_ONCE(scs->input, stream);\n\t} else {\n\t\tWRITE_ONCE(scs->input, NULL);\n\t}\n}\n\nstatic int midi_playback_open(struct snd_rawmidi_substream *stream)\n{\n\treturn 0;\n}\n\nstatic int midi_playback_close(struct snd_rawmidi_substream *stream)\n{\n\treturn 0;\n}\n\nstatic void midi_playback_trigger(struct snd_rawmidi_substream *stream, int up)\n{\n\tstruct fw_scs1x *scs = stream->rmidi->private_data;\n\n\tif (up) {\n\t\tscs->output_status = 0;\n\t\tscs->output_bytes = 1;\n\t\tscs->output_escaped = false;\n\t\tscs->output_idle = false;\n\t\tscs->transaction_bytes = 0;\n\t\tscs->error = false;\n\n\t\tWRITE_ONCE(scs->output, stream);\n\t\tschedule_work(&scs->work);\n\t} else {\n\t\tWRITE_ONCE(scs->output, NULL);\n\t}\n}\nstatic void midi_playback_drain(struct snd_rawmidi_substream *stream)\n{\n\tstruct fw_scs1x *scs = stream->rmidi->private_data;\n\n\twait_event(scs->idle_wait, scs->output_idle);\n}\n\nstatic int register_address(struct snd_oxfw *oxfw)\n{\n\tstruct fw_scs1x *scs = oxfw->spec;\n\t__be64 data;\n\n\tdata = cpu_to_be64(((u64)HSS1394_TAG_CHANGE_ADDRESS << 56) |\n\t\t\t    scs->hss_handler.offset);\n\treturn snd_fw_transaction(oxfw->unit, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\t\t  HSS1394_ADDRESS, &data, sizeof(data), 0);\n}\n\nstatic void remove_scs1x(struct snd_rawmidi *rmidi)\n{\n\tstruct fw_scs1x *scs = rmidi->private_data;\n\n\tfw_core_remove_address_handler(&scs->hss_handler);\n}\n\nvoid snd_oxfw_scs1x_update(struct snd_oxfw *oxfw)\n{\n\tregister_address(oxfw);\n}\n\nint snd_oxfw_scs1x_add(struct snd_oxfw *oxfw)\n{\n\tstatic const struct snd_rawmidi_ops midi_capture_ops = {\n\t\t.open    = midi_capture_open,\n\t\t.close   = midi_capture_close,\n\t\t.trigger = midi_capture_trigger,\n\t};\n\tstatic const struct snd_rawmidi_ops midi_playback_ops = {\n\t\t.open    = midi_playback_open,\n\t\t.close   = midi_playback_close,\n\t\t.trigger = midi_playback_trigger,\n\t\t.drain   = midi_playback_drain,\n\t};\n\tstruct snd_rawmidi *rmidi;\n\tstruct fw_scs1x *scs;\n\tint err;\n\n\tscs = devm_kzalloc(&oxfw->card->card_dev, sizeof(struct fw_scs1x),\n\t\t\t   GFP_KERNEL);\n\tif (!scs)\n\t\treturn -ENOMEM;\n\tscs->fw_dev = fw_parent_device(oxfw->unit);\n\toxfw->spec = scs;\n\n\t \n\tscs->hss_handler.length = HSS1394_MAX_PACKET_SIZE;\n\tscs->hss_handler.address_callback = handle_hss;\n\tscs->hss_handler.callback_data = scs;\n\terr = fw_core_add_address_handler(&scs->hss_handler,\n\t\t\t\t\t  &fw_high_memory_region);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = register_address(oxfw);\n\tif (err < 0)\n\t\tgoto err_allocated;\n\n\t \n\terr = snd_rawmidi_new(oxfw->card, \"SCS.1x\", 0, 1, 1, &rmidi);\n\tif (err < 0)\n\t\tgoto err_allocated;\n\trmidi->private_data = scs;\n\trmidi->private_free = remove_scs1x;\n\n\tsnprintf(rmidi->name, sizeof(rmidi->name),\n\t\t \"%s MIDI\", oxfw->card->shortname);\n\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &midi_capture_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &midi_playback_ops);\n\n\tINIT_WORK(&scs->work, scs_output_work);\n\tinit_waitqueue_head(&scs->idle_wait);\n\tscs->output_idle = true;\n\n\treturn 0;\nerr_allocated:\n\tfw_core_remove_address_handler(&scs->hss_handler);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}