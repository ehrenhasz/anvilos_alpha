{
  "module_name": "oxfw.c",
  "hash_id": "2056b2fb3cce8c809f982b42319a0bd5203036cbef9ea942c6a127e7d9a97058",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n\n#define OXFORD_FIRMWARE_ID_ADDRESS\t(CSR_REGISTER_BASE + 0x50000)\n \n\n#define OXFORD_HARDWARE_ID_ADDRESS\t(CSR_REGISTER_BASE + 0x90020)\n#define OXFORD_HARDWARE_ID_OXFW970\t0x39443841\n#define OXFORD_HARDWARE_ID_OXFW971\t0x39373100\n\n#define VENDOR_LOUD\t\t0x000ff2\n#define VENDOR_GRIFFIN\t\t0x001292\n#define VENDOR_BEHRINGER\t0x001564\n#define VENDOR_LACIE\t\t0x00d04b\n#define VENDOR_TASCAM\t\t0x00022e\n#define OUI_STANTON\t\t0x001260\n#define OUI_APOGEE\t\t0x0003db\n\n#define MODEL_SATELLITE\t\t0x00200f\n#define MODEL_SCS1M\t\t0x001000\n#define MODEL_DUET_FW\t\t0x01dddd\n#define MODEL_ONYX_1640I\t0x001640\n\n#define SPECIFIER_1394TA\t0x00a02d\n#define VERSION_AVC\t\t0x010001\n\nMODULE_DESCRIPTION(\"Oxford Semiconductor FW970/971 driver\");\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"snd-firewire-speakers\");\nMODULE_ALIAS(\"snd-scs1x\");\n\nstruct compat_info {\n\tconst char *driver_name;\n\tconst char *vendor_name;\n\tconst char *model_name;\n};\n\nstatic bool detect_loud_models(struct fw_unit *unit)\n{\n\tstatic const char *const models[] = {\n\t\t\"Onyxi\",\n\t\t\"Onyx-i\",\n\t\t\"Onyx 1640i\",\n\t\t\"d.Pro\",\n\t\t\"U.420\"};\n\tchar model[32];\n\tint err;\n\n\terr = fw_csr_string(unit->directory, CSR_MODEL,\n\t\t\t    model, sizeof(model));\n\tif (err < 0)\n\t\treturn false;\n\n\treturn match_string(models, ARRAY_SIZE(models), model) >= 0;\n}\n\nstatic int name_card(struct snd_oxfw *oxfw, const struct ieee1394_device_id *entry)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(oxfw->unit);\n\tconst struct compat_info *info;\n\tchar vendor[24];\n\tchar model[32];\n\tconst char *d, *v, *m;\n\tu32 firmware;\n\tint err;\n\n\t \n\terr = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,\n\t\t\t    vendor, sizeof(vendor));\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\terr = fw_csr_string(oxfw->unit->directory, CSR_MODEL,\n\t\t\t    model, sizeof(model));\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = snd_fw_transaction(oxfw->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t OXFORD_FIRMWARE_ID_ADDRESS, &firmware, 4, 0);\n\tif (err < 0)\n\t\tgoto end;\n\tbe32_to_cpus(&firmware);\n\n\tif (firmware >> 20 == 0x970)\n\t\toxfw->quirks |= SND_OXFW_QUIRK_JUMBO_PAYLOAD;\n\n\t \n\tif (entry->vendor_id == VENDOR_GRIFFIN || entry->vendor_id == VENDOR_LACIE) {\n\t\tinfo = (const struct compat_info *)entry->driver_data;\n\t\td = info->driver_name;\n\t\tv = info->vendor_name;\n\t\tm = info->model_name;\n\t} else {\n\t\td = \"OXFW\";\n\t\tv = vendor;\n\t\tm = model;\n\t}\n\n\tstrcpy(oxfw->card->driver, d);\n\tstrcpy(oxfw->card->mixername, m);\n\tstrcpy(oxfw->card->shortname, m);\n\n\tscnprintf(oxfw->card->longname, sizeof(oxfw->card->longname),\n\t\t  \"%s %s (OXFW%x %04x), GUID %08x%08x at %s, S%d\",\n\t\t  v, m, firmware >> 20, firmware & 0xffff,\n\t\t  fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t  dev_name(&oxfw->unit->device), 100 << fw_dev->max_speed);\nend:\n\treturn err;\n}\n\nstatic void oxfw_card_free(struct snd_card *card)\n{\n\tstruct snd_oxfw *oxfw = card->private_data;\n\n\tif (oxfw->has_output || oxfw->has_input)\n\t\tsnd_oxfw_stream_destroy_duplex(oxfw);\n\n\tmutex_destroy(&oxfw->mutex);\n\tfw_unit_put(oxfw->unit);\n}\n\nstatic int detect_quirks(struct snd_oxfw *oxfw, const struct ieee1394_device_id *entry)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(oxfw->unit);\n\tstruct fw_csr_iterator it;\n\tint key, val;\n\tint vendor, model;\n\n\t \n\tif (entry->vendor_id == VENDOR_GRIFFIN)\n\t\treturn snd_oxfw_add_spkr(oxfw, false);\n\tif (entry->vendor_id == VENDOR_LACIE)\n\t\treturn snd_oxfw_add_spkr(oxfw, true);\n\n\t \n\tif (entry->vendor_id == OUI_STANTON) {\n\t\toxfw->quirks |= SND_OXFW_QUIRK_SCS_TRANSACTION;\n\t\tif (entry->model_id == MODEL_SCS1M)\n\t\t\toxfw->quirks |= SND_OXFW_QUIRK_BLOCKING_TRANSMISSION;\n\n\t\t\n\t\toxfw->midi_input_ports = 0;\n\t\toxfw->midi_output_ports = 0;\n\n\t\treturn snd_oxfw_scs1x_add(oxfw);\n\t}\n\n\tif (entry->vendor_id == OUI_APOGEE && entry->model_id == MODEL_DUET_FW) {\n\t\toxfw->quirks |= SND_OXFW_QUIRK_BLOCKING_TRANSMISSION |\n\t\t\t\tSND_OXFW_QUIRK_IGNORE_NO_INFO_PACKET;\n\t}\n\n\t \n\tif (entry->vendor_id == VENDOR_TASCAM) {\n\t\toxfw->midi_input_ports++;\n\t\toxfw->midi_output_ports++;\n\t\treturn 0;\n\t}\n\n\t \n\tvendor = model = 0;\n\tfw_csr_iterator_init(&it, fw_dev->config_rom + 5);\n\twhile (fw_csr_iterator_next(&it, &key, &val)) {\n\t\tif (key == CSR_VENDOR)\n\t\t\tvendor = val;\n\t\telse if (key == CSR_MODEL)\n\t\t\tmodel = val;\n\t}\n\n\tif (vendor == VENDOR_LOUD) {\n\t\t\n\t\t\n\t\toxfw->quirks |= SND_OXFW_QUIRK_WRONG_DBS;\n\n\t\t\n\t\tif (!(oxfw->quirks & SND_OXFW_QUIRK_JUMBO_PAYLOAD))\n\t\t\toxfw->quirks |= SND_OXFW_QUIRK_BLOCKING_TRANSMISSION;\n\n\t\tif (model == MODEL_ONYX_1640I) {\n\t\t\t\n\t\t\t\n\t\t\toxfw->quirks |= SND_OXFW_QUIRK_IGNORE_NO_INFO_PACKET |\n\t\t\t\t\tSND_OXFW_QUIRK_VOLUNTARY_RECOVERY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int oxfw_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tstruct snd_card *card;\n\tstruct snd_oxfw *oxfw;\n\tint err;\n\n\tif (entry->vendor_id == VENDOR_LOUD && entry->model_id == 0 && !detect_loud_models(unit))\n\t\treturn -ENODEV;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE, sizeof(*oxfw), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = oxfw_card_free;\n\n\toxfw = card->private_data;\n\toxfw->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, oxfw);\n\toxfw->card = card;\n\n\tmutex_init(&oxfw->mutex);\n\tspin_lock_init(&oxfw->lock);\n\tinit_waitqueue_head(&oxfw->hwdep_wait);\n\n\terr = name_card(oxfw, entry);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_oxfw_stream_discover(oxfw);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = detect_quirks(oxfw, entry);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (oxfw->has_output || oxfw->has_input) {\n\t\terr = snd_oxfw_stream_init_duplex(oxfw);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = snd_oxfw_create_pcm(oxfw);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tsnd_oxfw_proc_init(oxfw);\n\n\t\terr = snd_oxfw_create_midi(oxfw);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = snd_oxfw_create_hwdep(oxfw);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void oxfw_bus_reset(struct fw_unit *unit)\n{\n\tstruct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);\n\n\tfcp_bus_reset(oxfw->unit);\n\n\tif (oxfw->has_output || oxfw->has_input) {\n\t\tmutex_lock(&oxfw->mutex);\n\t\tsnd_oxfw_stream_update_duplex(oxfw);\n\t\tmutex_unlock(&oxfw->mutex);\n\t}\n\n\tif (oxfw->quirks & SND_OXFW_QUIRK_SCS_TRANSACTION)\n\t\tsnd_oxfw_scs1x_update(oxfw);\n}\n\nstatic void oxfw_remove(struct fw_unit *unit)\n{\n\tstruct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(oxfw->card);\n}\n\nstatic const struct compat_info griffin_firewave = {\n\t.driver_name = \"FireWave\",\n\t.vendor_name = \"Griffin\",\n\t.model_name = \"FireWave\",\n};\n\nstatic const struct compat_info lacie_speakers = {\n\t.driver_name = \"FWSpeakers\",\n\t.vendor_name = \"LaCie\",\n\t.model_name = \"FireWire Speakers\",\n};\n\n#define OXFW_DEV_ENTRY(vendor, model, data) \\\n{ \\\n\t.match_flags  = IEEE1394_MATCH_VENDOR_ID | \\\n\t\t\tIEEE1394_MATCH_MODEL_ID | \\\n\t\t\tIEEE1394_MATCH_SPECIFIER_ID | \\\n\t\t\tIEEE1394_MATCH_VERSION, \\\n\t.vendor_id    = vendor, \\\n\t.model_id     = model, \\\n\t.specifier_id = SPECIFIER_1394TA, \\\n\t.version      = VERSION_AVC, \\\n\t.driver_data  = (kernel_ulong_t)data, \\\n}\n\nstatic const struct ieee1394_device_id oxfw_id_table[] = {\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tOXFW_DEV_ENTRY(VENDOR_GRIFFIN, 0x00f970, &griffin_firewave),\n\tOXFW_DEV_ENTRY(VENDOR_LACIE, 0x00f970, &lacie_speakers),\n\t\n\tOXFW_DEV_ENTRY(VENDOR_BEHRINGER, 0x00fc22, NULL),\n\t\n\tOXFW_DEV_ENTRY(VENDOR_LOUD, 0x000460, NULL),\n\t\n\t\n\tOXFW_DEV_ENTRY(VENDOR_LOUD, MODEL_SATELLITE, NULL),\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION,\n\t\t.vendor_id\t= VENDOR_LOUD,\n\t\t.model_id\t= 0,\n\t\t.specifier_id\t= SPECIFIER_1394TA,\n\t\t.version\t= VERSION_AVC,\n\t},\n\t\n\tOXFW_DEV_ENTRY(VENDOR_TASCAM, 0x800007, NULL),\n\t\n\tOXFW_DEV_ENTRY(OUI_STANTON, MODEL_SCS1M, NULL),\n\t\n\tOXFW_DEV_ENTRY(OUI_STANTON, 0x002000, NULL),\n\t\n\tOXFW_DEV_ENTRY(OUI_APOGEE, MODEL_DUET_FW, NULL),\n\t{ }\n};\nMODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);\n\nstatic struct fw_driver oxfw_driver = {\n\t.driver   = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.bus\t= &fw_bus_type,\n\t},\n\t.probe    = oxfw_probe,\n\t.update   = oxfw_bus_reset,\n\t.remove   = oxfw_remove,\n\t.id_table = oxfw_id_table,\n};\n\nstatic int __init snd_oxfw_init(void)\n{\n\treturn driver_register(&oxfw_driver.driver);\n}\n\nstatic void __exit snd_oxfw_exit(void)\n{\n\tdriver_unregister(&oxfw_driver.driver);\n}\n\nmodule_init(snd_oxfw_init);\nmodule_exit(snd_oxfw_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}