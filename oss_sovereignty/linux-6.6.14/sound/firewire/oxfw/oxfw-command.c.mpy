{
  "module_name": "oxfw-command.c",
  "hash_id": "3d054225a58fa28bf6610b9063cf19e6bd4367b006957d2427584b323dc7af36",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw-command.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n\nint avc_stream_set_format(struct fw_unit *unit, enum avc_general_plug_dir dir,\n\t\t\t  unsigned int pid, u8 *format, unsigned int len)\n{\n\tu8 *buf;\n\tint err;\n\n\tbuf = kmalloc(len + 10, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 0x00;\t\t \n\tbuf[1] = 0xff;\t\t \n\tbuf[2] = 0xbf;\t\t \n\tbuf[3] = 0xc0;\t\t \n\tbuf[4] = dir;\t\t \n\tbuf[5] = 0x00;\t\t \n\tbuf[6] = 0x00;\t\t \n\tbuf[7] = 0xff & pid;\t \n\tbuf[8] = 0xff;\t\t \n\tbuf[9] = 0xff;\t\t \n\tmemcpy(buf + 10, format, len);\n\n\t \n\terr = fcp_avc_transaction(unit, buf, len + 10, buf, len + 10,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7) | BIT(8));\n\tif (err < 0)\n\t\t;\n\telse if (err < len + 10)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENXIO;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\n\tkfree(buf);\n\n\treturn err;\n}\n\nint avc_stream_get_format(struct fw_unit *unit,\n\t\t\t  enum avc_general_plug_dir dir, unsigned int pid,\n\t\t\t  u8 *buf, unsigned int *len, unsigned int eid)\n{\n\tunsigned int subfunc;\n\tint err;\n\n\tif (eid == 0xff)\n\t\tsubfunc = 0xc0;\t \n\telse\n\t\tsubfunc = 0xc1;\t \n\n\tbuf[0] = 0x01;\t\t \n\tbuf[1] = 0xff;\t\t \n\tbuf[2] = 0xbf;\t\t \n\tbuf[3] = subfunc;\t \n\tbuf[4] = dir;\t\t \n\tbuf[5] = 0x00;\t\t \n\tbuf[6] = 0x00;\t\t \n\tbuf[7] = 0xff & pid;\t \n\tbuf[8] = 0xff;\t\t \n\tbuf[9] = 0xff;\t\t \n\tbuf[10] = 0xff & eid;\t \n\tbuf[11] = 0xff;\t\t \n\n\t \n\terr = fcp_avc_transaction(unit, buf, 12, buf, *len,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |\n\t\t\t\t  BIT(6) | BIT(7));\n\tif (err < 0)\n\t\t;\n\telse if (err < 12)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)\t \n\t\terr = -ENXIO;\n\telse if (buf[0] == 0x0a)\t \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)\t \n\t\terr = -EAGAIN;\n\t \n\telse if ((subfunc == 0xc1) && (buf[10] != eid))\n\t\terr = -EIO;\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif (subfunc == 0xc0) {\n\t\tmemmove(buf, buf + 10, err - 10);\n\t\t*len = err - 10;\n\t} else {\n\t\tmemmove(buf, buf + 11, err - 11);\n\t\t*len = err - 11;\n\t}\n\n\terr = 0;\nend:\n\treturn err;\n}\n\nint avc_general_inquiry_sig_fmt(struct fw_unit *unit, unsigned int rate,\n\t\t\t\tenum avc_general_plug_dir dir,\n\t\t\t\tunsigned short pid)\n{\n\tunsigned int sfc;\n\tu8 *buf;\n\tint err;\n\n\tfor (sfc = 0; sfc < CIP_SFC_COUNT; sfc++) {\n\t\tif (amdtp_rate_table[sfc] == rate)\n\t\t\tbreak;\n\t}\n\tif (sfc == CIP_SFC_COUNT)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(8, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 0x02;\t\t \n\tbuf[1] = 0xff;\t\t \n\tif (dir == AVC_GENERAL_PLUG_DIR_IN)\n\t\tbuf[2] = 0x19;\t \n\telse\n\t\tbuf[2] = 0x18;\t \n\tbuf[3] = 0xff & pid;\t \n\tbuf[4] = 0x90;\t\t \n\tbuf[5] = 0x07 & sfc;\t \n\tbuf[6] = 0xff;\t\t \n\tbuf[7] = 0xff;\t\t \n\n\t \n\terr = fcp_avc_transaction(unit, buf, 8, buf, 8,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));\n\tif (err < 0)\n\t\t;\n\telse if (err < 8)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)\t \n\t\terr = -ENXIO;\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}