{
  "module_name": "oxfw-stream.c",
  "hash_id": "b69fcb56e40d8f96e65e7c7ac8ec84502af166ed95bc8a9212cce66dd663b8ea",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw-stream.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n#include <linux/delay.h>\n\n#define AVC_GENERIC_FRAME_MAXIMUM_BYTES\t512\n#define READY_TIMEOUT_MS\t600\n\n \nstatic const unsigned int oxfw_rate_table[] = {\n\t[0] = 32000,\n\t[1] = 44100,\n\t[2] = 48000,\n\t[3] = 88200,\n\t[4] = 96000,\n\t[5] = 192000,\n};\n\n \nstatic const unsigned int avc_stream_rate_table[] = {\n\t[0] = 0x02,\n\t[1] = 0x03,\n\t[2] = 0x04,\n\t[3] = 0x0a,\n\t[4] = 0x05,\n\t[5] = 0x07,\n};\n\nstatic int set_rate(struct snd_oxfw *oxfw, unsigned int rate)\n{\n\tint err;\n\n\terr = avc_general_set_sig_fmt(oxfw->unit, rate,\n\t\t\t\t      AVC_GENERAL_PLUG_DIR_IN, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (oxfw->has_output)\n\t\terr = avc_general_set_sig_fmt(oxfw->unit, rate,\n\t\t\t\t\t      AVC_GENERAL_PLUG_DIR_OUT, 0);\nend:\n\treturn err;\n}\n\nstatic int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,\n\t\t\t     unsigned int rate, unsigned int pcm_channels)\n{\n\tu8 **formats;\n\tstruct snd_oxfw_stream_formation formation;\n\tenum avc_general_plug_dir dir;\n\tunsigned int len;\n\tint i, err;\n\n\tif (s == &oxfw->tx_stream) {\n\t\tformats = oxfw->tx_stream_formats;\n\t\tdir = AVC_GENERAL_PLUG_DIR_OUT;\n\t} else {\n\t\tformats = oxfw->rx_stream_formats;\n\t\tdir = AVC_GENERAL_PLUG_DIR_IN;\n\t}\n\n\t \n\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\terr = snd_oxfw_stream_parse_format(formats[i], &formation);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif ((formation.rate == rate) && (formation.pcm == pcm_channels))\n\t\t\tbreak;\n\t}\n\tif (i == SND_OXFW_STREAM_FORMAT_ENTRIES)\n\t\treturn -EINVAL;\n\n\t \n\tif (oxfw->assumed)\n\t\treturn set_rate(oxfw, rate);\n\n\t \n\tlen = 5 + formats[i][4] * 2;\n\n\terr = avc_stream_set_format(oxfw->unit, dir, 0, formats[i], len);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\tint err;\n\n\tif (stream == &oxfw->rx_stream)\n\t\tconn = &oxfw->in_conn;\n\telse\n\t\tconn = &oxfw->out_conn;\n\n\terr = cmp_connection_establish(conn);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_domain_add_stream(&oxfw->domain, stream,\n\t\t\t\t      conn->resources.channel, conn->speed);\n\tif (err < 0) {\n\t\tcmp_connection_break(conn);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_connection_used_by_others(struct snd_oxfw *oxfw,\n\t\t\t\t\t   struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\tbool used;\n\tint err;\n\n\tif (stream == &oxfw->tx_stream)\n\t\tconn = &oxfw->out_conn;\n\telse\n\t\tconn = &oxfw->in_conn;\n\n\terr = cmp_connection_check_used(conn, &used);\n\tif ((err >= 0) && used && !amdtp_stream_running(stream)) {\n\t\tdev_err(&oxfw->unit->device,\n\t\t\t\"Connection established by others: %cPCR[%d]\\n\",\n\t\t\t(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\n\t\t\tconn->pcr_index);\n\t\terr = -EBUSY;\n\t}\n\n\treturn err;\n}\n\nstatic int init_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\tenum cmp_direction c_dir;\n\tenum amdtp_stream_direction s_dir;\n\tunsigned int flags = 0;\n\tint err;\n\n\tif (!(oxfw->quirks & SND_OXFW_QUIRK_BLOCKING_TRANSMISSION))\n\t\tflags |= CIP_NONBLOCKING;\n\telse\n\t\tflags |= CIP_BLOCKING;\n\n\t\n\t\n\t\n\t\n\tif (!(oxfw->quirks & SND_OXFW_QUIRK_IGNORE_NO_INFO_PACKET))\n\t\tflags |= CIP_UNAWARE_SYT;\n\n\tif (stream == &oxfw->tx_stream) {\n\t\tconn = &oxfw->out_conn;\n\t\tc_dir = CMP_OUTPUT;\n\t\ts_dir = AMDTP_IN_STREAM;\n\n\t\tif (oxfw->quirks & SND_OXFW_QUIRK_JUMBO_PAYLOAD)\n\t\t\tflags |= CIP_JUMBO_PAYLOAD;\n\t\tif (oxfw->quirks & SND_OXFW_QUIRK_WRONG_DBS)\n\t\t\tflags |= CIP_WRONG_DBS;\n\t} else {\n\t\tconn = &oxfw->in_conn;\n\t\tc_dir = CMP_INPUT;\n\t\ts_dir = AMDTP_OUT_STREAM;\n\t}\n\n\terr = cmp_connection_init(conn, oxfw->unit, c_dir, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_am824_init(stream, oxfw->unit, s_dir, flags);\n\tif (err < 0) {\n\t\tcmp_connection_destroy(conn);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)\n{\n\tenum avc_general_plug_dir dir;\n\tu8 **formats;\n\tstruct snd_oxfw_stream_formation formation;\n\tstruct cmp_connection *conn;\n\tint i;\n\tint err;\n\n\tif (stream == &oxfw->rx_stream) {\n\t\tdir = AVC_GENERAL_PLUG_DIR_IN;\n\t\tformats = oxfw->rx_stream_formats;\n\t\tconn = &oxfw->in_conn;\n\t} else {\n\t\tdir = AVC_GENERAL_PLUG_DIR_OUT;\n\t\tformats = oxfw->tx_stream_formats;\n\t\tconn = &oxfw->out_conn;\n\t}\n\n\terr = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\tstruct snd_oxfw_stream_formation fmt;\n\n\t\tif (formats[i] == NULL)\n\t\t\tbreak;\n\n\t\terr = snd_oxfw_stream_parse_format(formats[i], &fmt);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (fmt.rate == formation.rate && fmt.pcm == formation.pcm &&\n\t\t    fmt.midi == formation.midi)\n\t\t\tbreak;\n\t}\n\tif (i == SND_OXFW_STREAM_FORMAT_ENTRIES)\n\t\treturn -EINVAL;\n\n\t\n\tif (formation.pcm == 0)\n\t\treturn -EINVAL;\n\n\terr = amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,\n\t\t\t\t\t formation.midi * 8, false);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));\n}\n\nint snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,\n\t\t\t\t   struct amdtp_stream *stream,\n\t\t\t\t   unsigned int rate, unsigned int pcm_channels,\n\t\t\t\t   unsigned int frames_per_period,\n\t\t\t\t   unsigned int frames_per_buffer)\n{\n\tstruct snd_oxfw_stream_formation formation;\n\tenum avc_general_plug_dir dir;\n\tint err;\n\n\t\n\t\n\terr = check_connection_used_by_others(oxfw, &oxfw->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\tif (oxfw->has_output) {\n\t\terr = check_connection_used_by_others(oxfw, &oxfw->tx_stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (stream == &oxfw->tx_stream)\n\t\tdir = AVC_GENERAL_PLUG_DIR_OUT;\n\telse\n\t\tdir = AVC_GENERAL_PLUG_DIR_IN;\n\n\terr = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0) {\n\t\trate = formation.rate;\n\t\tpcm_channels = formation.pcm;\n\t}\n\tif (formation.rate != rate || formation.pcm != pcm_channels) {\n\t\tamdtp_domain_stop(&oxfw->domain);\n\n\t\tcmp_connection_break(&oxfw->in_conn);\n\t\tcmp_connection_release(&oxfw->in_conn);\n\n\t\tif (oxfw->has_output) {\n\t\t\tcmp_connection_break(&oxfw->out_conn);\n\t\t\tcmp_connection_release(&oxfw->out_conn);\n\t\t}\n\t}\n\n\tif (oxfw->substreams_count == 0 ||\n\t    formation.rate != rate || formation.pcm != pcm_channels) {\n\t\terr = set_stream_format(oxfw, stream, rate, pcm_channels);\n\t\tif (err < 0) {\n\t\t\tdev_err(&oxfw->unit->device,\n\t\t\t\t\"fail to set stream format: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = keep_resources(oxfw, &oxfw->rx_stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (oxfw->has_output) {\n\t\t\terr = keep_resources(oxfw, &oxfw->tx_stream);\n\t\t\tif (err < 0) {\n\t\t\t\tcmp_connection_release(&oxfw->in_conn);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&oxfw->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tcmp_connection_release(&oxfw->in_conn);\n\t\t\tif (oxfw->has_output)\n\t\t\t\tcmp_connection_release(&oxfw->out_conn);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw)\n{\n\tint err;\n\n\tif (oxfw->substreams_count == 0)\n\t\treturn -EIO;\n\n\tif (amdtp_streaming_error(&oxfw->rx_stream) ||\n\t    amdtp_streaming_error(&oxfw->tx_stream)) {\n\t\tamdtp_domain_stop(&oxfw->domain);\n\n\t\tcmp_connection_break(&oxfw->in_conn);\n\t\tif (oxfw->has_output)\n\t\t\tcmp_connection_break(&oxfw->out_conn);\n\t}\n\n\tif (!amdtp_stream_running(&oxfw->rx_stream)) {\n\t\tunsigned int tx_init_skip_cycles = 0;\n\t\tbool replay_seq = false;\n\n\t\terr = start_stream(oxfw, &oxfw->rx_stream);\n\t\tif (err < 0) {\n\t\t\tdev_err(&oxfw->unit->device,\n\t\t\t\t\"fail to prepare rx stream: %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (oxfw->has_output &&\n\t\t    !amdtp_stream_running(&oxfw->tx_stream)) {\n\t\t\terr = start_stream(oxfw, &oxfw->tx_stream);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&oxfw->unit->device,\n\t\t\t\t\t\"fail to prepare tx stream: %d\\n\", err);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (oxfw->quirks & SND_OXFW_QUIRK_JUMBO_PAYLOAD) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\ttx_init_skip_cycles = 400;\n\t\t\t} else if (oxfw->quirks & SND_OXFW_QUIRK_VOLUNTARY_RECOVERY) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\ttx_init_skip_cycles = 4000;\n\t\t\t} else {\n\t\t\t\treplay_seq = true;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&oxfw->domain, tx_init_skip_cycles, replay_seq, false);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&oxfw->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&oxfw->domain);\n\n\tcmp_connection_break(&oxfw->in_conn);\n\tif (oxfw->has_output)\n\t\tcmp_connection_break(&oxfw->out_conn);\n\n\treturn err;\n}\n\nvoid snd_oxfw_stream_stop_duplex(struct snd_oxfw *oxfw)\n{\n\tif (oxfw->substreams_count == 0) {\n\t\tamdtp_domain_stop(&oxfw->domain);\n\n\t\tcmp_connection_break(&oxfw->in_conn);\n\t\tcmp_connection_release(&oxfw->in_conn);\n\n\t\tif (oxfw->has_output) {\n\t\t\tcmp_connection_break(&oxfw->out_conn);\n\t\t\tcmp_connection_release(&oxfw->out_conn);\n\t\t}\n\t}\n}\n\nstatic void destroy_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\n\tif (stream == &oxfw->tx_stream)\n\t\tconn = &oxfw->out_conn;\n\telse\n\t\tconn = &oxfw->in_conn;\n\n\tamdtp_stream_destroy(stream);\n\tcmp_connection_destroy(conn);\n}\n\nint snd_oxfw_stream_init_duplex(struct snd_oxfw *oxfw)\n{\n\tint err;\n\n\terr = init_stream(oxfw, &oxfw->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (oxfw->has_output) {\n\t\terr = init_stream(oxfw, &oxfw->tx_stream);\n\t\tif (err < 0) {\n\t\t\tdestroy_stream(oxfw, &oxfw->rx_stream);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = amdtp_domain_init(&oxfw->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(oxfw, &oxfw->rx_stream);\n\t\tif (oxfw->has_output)\n\t\t\tdestroy_stream(oxfw, &oxfw->tx_stream);\n\t}\n\n\treturn err;\n}\n\n\n\nvoid snd_oxfw_stream_destroy_duplex(struct snd_oxfw *oxfw)\n{\n\tamdtp_domain_destroy(&oxfw->domain);\n\n\tdestroy_stream(oxfw, &oxfw->rx_stream);\n\n\tif (oxfw->has_output)\n\t\tdestroy_stream(oxfw, &oxfw->tx_stream);\n}\n\nvoid snd_oxfw_stream_update_duplex(struct snd_oxfw *oxfw)\n{\n\tamdtp_domain_stop(&oxfw->domain);\n\n\tcmp_connection_break(&oxfw->in_conn);\n\n\tamdtp_stream_pcm_abort(&oxfw->rx_stream);\n\n\tif (oxfw->has_output) {\n\t\tcmp_connection_break(&oxfw->out_conn);\n\n\t\tamdtp_stream_pcm_abort(&oxfw->tx_stream);\n\t}\n}\n\nint snd_oxfw_stream_get_current_formation(struct snd_oxfw *oxfw,\n\t\t\t\tenum avc_general_plug_dir dir,\n\t\t\t\tstruct snd_oxfw_stream_formation *formation)\n{\n\tu8 *format;\n\tunsigned int len;\n\tint err;\n\n\tlen = AVC_GENERIC_FRAME_MAXIMUM_BYTES;\n\tformat = kmalloc(len, GFP_KERNEL);\n\tif (format == NULL)\n\t\treturn -ENOMEM;\n\n\terr = avc_stream_get_format_single(oxfw->unit, dir, 0, format, &len);\n\tif (err < 0)\n\t\tgoto end;\n\tif (len < 3) {\n\t\terr = -EIO;\n\t\tgoto end;\n\t}\n\n\terr = snd_oxfw_stream_parse_format(format, formation);\nend:\n\tkfree(format);\n\treturn err;\n}\n\n \nint snd_oxfw_stream_parse_format(u8 *format,\n\t\t\t\t struct snd_oxfw_stream_formation *formation)\n{\n\tunsigned int i, e, channels, type;\n\n\tmemset(formation, 0, sizeof(struct snd_oxfw_stream_formation));\n\n\t \n\tif ((format[0] != 0x90) || (format[1] != 0x40))\n\t\treturn -ENXIO;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(avc_stream_rate_table); i++) {\n\t\tif (format[2] == avc_stream_rate_table[i])\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(avc_stream_rate_table))\n\t\treturn -ENXIO;\n\n\tformation->rate = oxfw_rate_table[i];\n\n\tfor (e = 0; e < format[4]; e++) {\n\t\tchannels = format[5 + e * 2];\n\t\ttype = format[6 + e * 2];\n\n\t\tswitch (type) {\n\t\t \n\t\tcase 0x00:\n\t\t \n\t\tcase 0x06:\n\t\t\tformation->pcm += channels;\n\t\t\tbreak;\n\t\t \n\t\tcase 0x0d:\n\t\t\tformation->midi = channels;\n\t\t\tbreak;\n\t\t \n\t\tcase 0x01:\n\t\tcase 0x02:\n\t\tcase 0x03:\n\t\tcase 0x04:\n\t\tcase 0x05:\n\t\t \n\t\tcase 0x07:\t \n\t\tcase 0x0c:\t \n\t\t \n\t\tcase 0x08:\t \n\t\tcase 0x09:\t \n\t\tcase 0x0a:\t \n\t\tcase 0x0b:\t \n\t\t \n\t\tcase 0x0e:\n\t\t \n\t\tcase 0x0f:\n\t\t \n\t\tcase 0x10:\n\t\t \n\t\tcase 0x40:\n\t\t \n\t\tcase 0xff:\n\t\tdefault:\n\t\t\treturn -ENXIO;\t \n\t\t}\n\t}\n\n\tif (formation->pcm  > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    formation->midi > AM824_MAX_CHANNELS_FOR_MIDI)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int\nassume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,\n\t\t      unsigned int pid, u8 *buf, unsigned int *len,\n\t\t      u8 **formats)\n{\n\tstruct snd_oxfw_stream_formation formation;\n\tunsigned int i, eid;\n\tint err;\n\n\t \n\terr = avc_stream_get_format_single(oxfw->unit, dir, pid, buf, len);\n\tif (err < 0) {\n\t\tdev_err(&oxfw->unit->device,\n\t\t\"fail to get current stream format for isoc %s plug %d:%d\\n\",\n\t\t\t(dir == AVC_GENERAL_PLUG_DIR_IN) ? \"in\" : \"out\",\n\t\t\tpid, err);\n\t\tgoto end;\n\t}\n\n\t \n\teid = 0;\n\terr = snd_oxfw_stream_parse_format(buf, &formation);\n\tif (err < 0)\n\t\tgoto end;\n\n\tformats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, *len,\n\t\t\t\t    GFP_KERNEL);\n\tif (!formats[eid]) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(oxfw_rate_table); i++) {\n\t\tif (formation.rate == oxfw_rate_table[i])\n\t\t\tcontinue;\n\n\t\terr = avc_general_inquiry_sig_fmt(oxfw->unit,\n\t\t\t\t\t\t  oxfw_rate_table[i],\n\t\t\t\t\t\t  dir, pid);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\teid++;\n\t\tformats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, *len,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (formats[eid] == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto end;\n\t\t}\n\t\tformats[eid][2] = avc_stream_rate_table[i];\n\t}\n\n\terr = 0;\n\toxfw->assumed = true;\nend:\n\treturn err;\n}\n\nstatic int fill_stream_formats(struct snd_oxfw *oxfw,\n\t\t\t       enum avc_general_plug_dir dir,\n\t\t\t       unsigned short pid)\n{\n\tu8 *buf, **formats;\n\tunsigned int len, eid = 0;\n\tstruct snd_oxfw_stream_formation dummy;\n\tint err;\n\n\tbuf = kmalloc(AVC_GENERIC_FRAME_MAXIMUM_BYTES, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (dir == AVC_GENERAL_PLUG_DIR_OUT)\n\t\tformats = oxfw->tx_stream_formats;\n\telse\n\t\tformats = oxfw->rx_stream_formats;\n\n\t \n\tlen = AVC_GENERIC_FRAME_MAXIMUM_BYTES;\n\terr = avc_stream_get_format_list(oxfw->unit, dir, 0, buf, &len, 0);\n\tif (err == -ENXIO) {\n\t\t \n\t\tlen = AVC_GENERIC_FRAME_MAXIMUM_BYTES;\n\t\terr = assume_stream_formats(oxfw, dir, pid, buf, &len,\n\t\t\t\t\t    formats);\n\t\tgoto end;\n\t} else if (err < 0) {\n\t\tdev_err(&oxfw->unit->device,\n\t\t\t\"fail to get stream format %d for isoc %s plug %d:%d\\n\",\n\t\t\teid, (dir == AVC_GENERAL_PLUG_DIR_IN) ? \"in\" : \"out\",\n\t\t\tpid, err);\n\t\tgoto end;\n\t}\n\n\t \n\twhile (eid < SND_OXFW_STREAM_FORMAT_ENTRIES) {\n\t\t \n\t\tif (len < 3) {\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = snd_oxfw_stream_parse_format(buf, &dummy);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tformats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, len,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!formats[eid]) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlen = AVC_GENERIC_FRAME_MAXIMUM_BYTES;\n\t\terr = avc_stream_get_format_list(oxfw->unit, dir, 0,\n\t\t\t\t\t\t buf, &len, ++eid);\n\t\t \n\t\tif (err == -EINVAL) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t} else if (err < 0) {\n\t\t\tdev_err(&oxfw->unit->device,\n\t\t\t\"fail to get stream format %d for isoc %s plug %d:%d\\n\",\n\t\t\t\teid, (dir == AVC_GENERAL_PLUG_DIR_IN) ? \"in\" :\n\t\t\t\t\t\t\t\t\t\"out\",\n\t\t\t\tpid, err);\n\t\t\tbreak;\n\t\t}\n\t}\nend:\n\tkfree(buf);\n\treturn err;\n}\n\nint snd_oxfw_stream_discover(struct snd_oxfw *oxfw)\n{\n\tu8 plugs[AVC_PLUG_INFO_BUF_BYTES];\n\tstruct snd_oxfw_stream_formation formation;\n\tu8 *format;\n\tunsigned int i;\n\tint err;\n\n\t \n\terr = avc_general_get_plug_info(oxfw->unit, 0x1f, 0x07, 0x00, plugs);\n\tif (err < 0) {\n\t\tdev_err(&oxfw->unit->device,\n\t\t\"fail to get info for isoc/external in/out plugs: %d\\n\",\n\t\t\terr);\n\t\tgoto end;\n\t} else if ((plugs[0] == 0) && (plugs[1] == 0)) {\n\t\terr = -ENXIO;\n\t\tgoto end;\n\t}\n\n\t \n\tif (plugs[1] > 0) {\n\t\terr = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_OUT, 0);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENXIO)\n\t\t\t\treturn err;\n\n\t\t\t\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\t\t\tformat = oxfw->tx_stream_formats[i];\n\t\t\t\tif (format == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = snd_oxfw_stream_parse_format(format,\n\t\t\t\t\t\t\t\t   &formation);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (formation.midi > 0)\n\t\t\t\t\toxfw->midi_input_ports = 1;\n\t\t\t}\n\n\t\t\toxfw->has_output = true;\n\t\t}\n\t}\n\n\t \n\tif (plugs[0] > 0) {\n\t\terr = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_IN, 0);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENXIO)\n\t\t\t\treturn err;\n\n\t\t\t\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\t\t\tformat = oxfw->rx_stream_formats[i];\n\t\t\t\tif (format == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\terr = snd_oxfw_stream_parse_format(format,\n\t\t\t\t\t\t\t\t   &formation);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (formation.midi > 0)\n\t\t\t\t\toxfw->midi_output_ports = 1;\n\t\t\t}\n\n\t\t\toxfw->has_input = true;\n\t\t}\n\t}\nend:\n\treturn err;\n}\n\nvoid snd_oxfw_stream_lock_changed(struct snd_oxfw *oxfw)\n{\n\toxfw->dev_lock_changed = true;\n\twake_up(&oxfw->hwdep_wait);\n}\n\nint snd_oxfw_stream_lock_try(struct snd_oxfw *oxfw)\n{\n\tint err;\n\n\tspin_lock_irq(&oxfw->lock);\n\n\t \n\tif (oxfw->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (oxfw->dev_lock_count++ == 0)\n\t\tsnd_oxfw_stream_lock_changed(oxfw);\n\terr = 0;\nend:\n\tspin_unlock_irq(&oxfw->lock);\n\treturn err;\n}\n\nvoid snd_oxfw_stream_lock_release(struct snd_oxfw *oxfw)\n{\n\tspin_lock_irq(&oxfw->lock);\n\n\tif (WARN_ON(oxfw->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--oxfw->dev_lock_count == 0)\n\t\tsnd_oxfw_stream_lock_changed(oxfw);\nend:\n\tspin_unlock_irq(&oxfw->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}