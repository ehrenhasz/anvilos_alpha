{
  "module_name": "oxfw-pcm.c",
  "hash_id": "487a5a33d2d74c2adbfbbf13376ade1372c6fc8899c6969a929dc425816e4560",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw-pcm.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n\nstatic int hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tu8 **formats = rule->private;\n\tstruct snd_interval *r =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tconst struct snd_interval *c =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval t = {\n\t\t.min = UINT_MAX, .max = 0, .integer = 1\n\t};\n\tstruct snd_oxfw_stream_formation formation;\n\tint i, err;\n\n\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\tif (formats[i] == NULL)\n\t\t\tcontinue;\n\n\t\terr = snd_oxfw_stream_parse_format(formats[i], &formation);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t\tif (!snd_interval_test(c, formation.pcm))\n\t\t\tcontinue;\n\n\t\tt.min = min(t.min, formation.rate);\n\t\tt.max = max(t.max, formation.rate);\n\n\t}\n\treturn snd_interval_refine(r, &t);\n}\n\nstatic int hw_rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tu8 **formats = rule->private;\n\tstruct snd_interval *c =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tconst struct snd_interval *r =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_oxfw_stream_formation formation;\n\tint i, j, err;\n\tunsigned int count, list[SND_OXFW_STREAM_FORMAT_ENTRIES] = {0};\n\n\tcount = 0;\n\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\tif (formats[i] == NULL)\n\t\t\tbreak;\n\n\t\terr = snd_oxfw_stream_parse_format(formats[i], &formation);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t\tif (!snd_interval_test(r, formation.rate))\n\t\t\tcontinue;\n\t\tif (list[count] == formation.pcm)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(list); j++) {\n\t\t\tif (list[j] == formation.pcm)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == ARRAY_SIZE(list)) {\n\t\t\tlist[count] = formation.pcm;\n\t\t\tif (++count == ARRAY_SIZE(list))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn snd_interval_list(c, count, list, 0);\n}\n\nstatic void limit_channels_and_rates(struct snd_pcm_hardware *hw, u8 **formats)\n{\n\tstruct snd_oxfw_stream_formation formation;\n\tint i, err;\n\n\thw->channels_min = UINT_MAX;\n\thw->channels_max = 0;\n\n\thw->rate_min = UINT_MAX;\n\thw->rate_max = 0;\n\thw->rates = 0;\n\n\tfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\n\t\tif (formats[i] == NULL)\n\t\t\tbreak;\n\n\t\terr = snd_oxfw_stream_parse_format(formats[i], &formation);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\thw->channels_min = min(hw->channels_min, formation.pcm);\n\t\thw->channels_max = max(hw->channels_max, formation.pcm);\n\n\t\thw->rate_min = min(hw->rate_min, formation.rate);\n\t\thw->rate_max = max(hw->rate_max, formation.rate);\n\t\thw->rates |= snd_pcm_rate_to_rate_bit(formation.rate);\n\t}\n}\n\nstatic int init_hw_params(struct snd_oxfw *oxfw,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu8 **formats;\n\tstruct amdtp_stream *stream;\n\tint err;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\truntime->hw.formats = AM824_IN_PCM_FORMAT_BITS;\n\t\tstream = &oxfw->tx_stream;\n\t\tformats = oxfw->tx_stream_formats;\n\t} else {\n\t\truntime->hw.formats = AM824_OUT_PCM_FORMAT_BITS;\n\t\tstream = &oxfw->rx_stream;\n\t\tformats = oxfw->rx_stream_formats;\n\t}\n\n\tlimit_channels_and_rates(&runtime->hw, formats);\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_channels, formats,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  hw_rule_rate, formats,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = amdtp_am824_add_pcm_hw_constraints(stream, runtime);\nend:\n\treturn err;\n}\n\nstatic int limit_to_current_params(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tstruct snd_oxfw_stream_formation formation;\n\tenum avc_general_plug_dir dir;\n\tint err;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tdir = AVC_GENERAL_PLUG_DIR_OUT;\n\telse\n\t\tdir = AVC_GENERAL_PLUG_DIR_IN;\n\n\terr = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);\n\tif (err < 0)\n\t\tgoto end;\n\n\tsubstream->runtime->hw.channels_min = formation.pcm;\n\tsubstream->runtime->hw.channels_max = formation.pcm;\n\tsubstream->runtime->hw.rate_min = formation.rate;\n\tsubstream->runtime->hw.rate_max = formation.rate;\nend:\n\treturn err;\n}\n\nstatic int pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tstruct amdtp_domain *d = &oxfw->domain;\n\tint err;\n\n\terr = snd_oxfw_stream_lock_try(oxfw);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_hw_params(oxfw, substream);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\tmutex_lock(&oxfw->mutex);\n\n\t\n\t\n\t\n\tif (oxfw->substreams_count > 0 && d->events_per_period > 0) {\n\t\tunsigned int frames_per_period = d->events_per_period;\n\t\tunsigned int frames_per_buffer = d->events_per_buffer;\n\n\t\terr = limit_to_current_params(substream);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&oxfw->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\n\t\tif (frames_per_period > 0) {\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\tframes_per_period, frames_per_period);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&oxfw->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\tframes_per_buffer, frames_per_buffer);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&oxfw->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&oxfw->mutex);\n\n\tsnd_pcm_set_sync(substream);\n\n\treturn 0;\nerr_locked:\n\tsnd_oxfw_stream_lock_release(oxfw);\n\treturn err;\n}\n\nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\n\tsnd_oxfw_stream_lock_release(oxfw);\n\treturn 0;\n}\n\nstatic int pcm_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tint err = 0;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tunsigned int rate = params_rate(hw_params);\n\t\tunsigned int channels = params_channels(hw_params);\n\t\tunsigned int frames_per_period = params_period_size(hw_params);\n\t\tunsigned int frames_per_buffer = params_buffer_size(hw_params);\n\n\t\tmutex_lock(&oxfw->mutex);\n\t\terr = snd_oxfw_stream_reserve_duplex(oxfw, &oxfw->tx_stream,\n\t\t\t\t\trate, channels, frames_per_period,\n\t\t\t\t\tframes_per_buffer);\n\t\tif (err >= 0)\n\t\t\t++oxfw->substreams_count;\n\t\tmutex_unlock(&oxfw->mutex);\n\t}\n\n\treturn err;\n}\nstatic int pcm_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tint err = 0;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tunsigned int rate = params_rate(hw_params);\n\t\tunsigned int channels = params_channels(hw_params);\n\t\tunsigned int frames_per_period = params_period_size(hw_params);\n\t\tunsigned int frames_per_buffer = params_buffer_size(hw_params);\n\n\t\tmutex_lock(&oxfw->mutex);\n\t\terr = snd_oxfw_stream_reserve_duplex(oxfw, &oxfw->rx_stream,\n\t\t\t\t\trate, channels, frames_per_period,\n\t\t\t\t\tframes_per_buffer);\n\t\tif (err >= 0)\n\t\t\t++oxfw->substreams_count;\n\t\tmutex_unlock(&oxfw->mutex);\n\t}\n\n\treturn err;\n}\n\nstatic int pcm_capture_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\n\tmutex_lock(&oxfw->mutex);\n\n\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t--oxfw->substreams_count;\n\n\tsnd_oxfw_stream_stop_duplex(oxfw);\n\n\tmutex_unlock(&oxfw->mutex);\n\n\treturn 0;\n}\nstatic int pcm_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\n\tmutex_lock(&oxfw->mutex);\n\n\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t--oxfw->substreams_count;\n\n\tsnd_oxfw_stream_stop_duplex(oxfw);\n\n\tmutex_unlock(&oxfw->mutex);\n\n\treturn 0;\n}\n\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tint err;\n\n\tmutex_lock(&oxfw->mutex);\n\terr = snd_oxfw_stream_start_duplex(oxfw);\n\tmutex_unlock(&oxfw->mutex);\n\tif (err < 0)\n\t\tgoto end;\n\n\tamdtp_stream_pcm_prepare(&oxfw->tx_stream);\nend:\n\treturn err;\n}\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tint err;\n\n\tmutex_lock(&oxfw->mutex);\n\terr = snd_oxfw_stream_start_duplex(oxfw);\n\tmutex_unlock(&oxfw->mutex);\n\tif (err < 0)\n\t\tgoto end;\n\n\tamdtp_stream_pcm_prepare(&oxfw->rx_stream);\nend:\n\treturn err;\n}\n\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tstruct snd_pcm_substream *pcm;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tpcm = substream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tpcm = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tamdtp_stream_pcm_trigger(&oxfw->tx_stream, pcm);\n\treturn 0;\n}\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\tstruct snd_pcm_substream *pcm;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tpcm = substream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tpcm = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tamdtp_stream_pcm_trigger(&oxfw->rx_stream, pcm);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstm)\n{\n\tstruct snd_oxfw *oxfw = sbstm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&oxfw->domain, &oxfw->tx_stream);\n}\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstm)\n{\n\tstruct snd_oxfw *oxfw = sbstm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&oxfw->domain, &oxfw->rx_stream);\n}\n\nstatic int pcm_capture_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&oxfw->domain, &oxfw->tx_stream);\n}\n\nstatic int pcm_playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_oxfw *oxfw = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&oxfw->domain, &oxfw->rx_stream);\n}\n\nint snd_oxfw_create_pcm(struct snd_oxfw *oxfw)\n{\n\tstatic const struct snd_pcm_ops capture_ops = {\n\t\t.open      = pcm_open,\n\t\t.close     = pcm_close,\n\t\t.hw_params = pcm_capture_hw_params,\n\t\t.hw_free   = pcm_capture_hw_free,\n\t\t.prepare   = pcm_capture_prepare,\n\t\t.trigger   = pcm_capture_trigger,\n\t\t.pointer   = pcm_capture_pointer,\n\t\t.ack       = pcm_capture_ack,\n\t};\n\tstatic const struct snd_pcm_ops playback_ops = {\n\t\t.open      = pcm_open,\n\t\t.close     = pcm_close,\n\t\t.hw_params = pcm_playback_hw_params,\n\t\t.hw_free   = pcm_playback_hw_free,\n\t\t.prepare   = pcm_playback_prepare,\n\t\t.trigger   = pcm_playback_trigger,\n\t\t.pointer   = pcm_playback_pointer,\n\t\t.ack       = pcm_playback_ack,\n\t};\n\tstruct snd_pcm *pcm;\n\tunsigned int cap = 0;\n\tint err;\n\n\tif (oxfw->has_output)\n\t\tcap = 1;\n\n\terr = snd_pcm_new(oxfw->card, oxfw->card->driver, 0, 1, cap, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = oxfw;\n\tstrcpy(pcm->name, oxfw->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\n\tif (cap > 0)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}