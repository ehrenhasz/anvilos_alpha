{
  "module_name": "oxfw-spkr.c",
  "hash_id": "5c0b9bc58447428d439dec76da0cf313d4b2a68310032960dd455eb6718b7aa3",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/oxfw/oxfw-spkr.c",
  "human_readable_source": "\n \n\n#include \"oxfw.h\"\n\nstruct fw_spkr {\n\tbool mute;\n\ts16 volume[6];\n\ts16 volume_min;\n\ts16 volume_max;\n\n\tunsigned int mixer_channels;\n\tu8 mute_fb_id;\n\tu8 volume_fb_id;\n};\n\nenum control_action { CTL_READ, CTL_WRITE };\nenum control_attribute {\n\tCTL_MIN\t\t= 0x02,\n\tCTL_MAX\t\t= 0x03,\n\tCTL_CURRENT\t= 0x10,\n};\n\nstatic int avc_audio_feature_mute(struct fw_unit *unit, u8 fb_id, bool *value,\n\t\t\t\t  enum control_action action)\n{\n\tu8 *buf;\n\tu8 response_ok;\n\tint err;\n\n\tbuf = kmalloc(11, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (action == CTL_READ) {\n\t\tbuf[0] = 0x01;\t\t \n\t\tresponse_ok = 0x0c;\t \n\t} else {\n\t\tbuf[0] = 0x00;\t\t \n\t\tresponse_ok = 0x09;\t \n\t}\n\tbuf[1] = 0x08;\t\t\t \n\tbuf[2] = 0xb8;\t\t\t \n\tbuf[3] = 0x81;\t\t\t \n\tbuf[4] = fb_id;\t\t\t \n\tbuf[5] = 0x10;\t\t\t \n\tbuf[6] = 0x02;\t\t\t \n\tbuf[7] = 0x00;\t\t\t \n\tbuf[8] = 0x01;\t\t\t \n\tbuf[9] = 0x01;\t\t\t \n\tif (action == CTL_READ)\n\t\tbuf[10] = 0xff;\n\telse\n\t\tbuf[10] = *value ? 0x70 : 0x60;\n\n\terr = fcp_avc_transaction(unit, buf, 11, buf, 11, 0x3fe);\n\tif (err < 0)\n\t\tgoto error;\n\tif (err < 11) {\n\t\tdev_err(&unit->device, \"short FCP response\\n\");\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\tif (buf[0] != response_ok) {\n\t\tdev_err(&unit->device, \"mute command failed\\n\");\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\tif (action == CTL_READ)\n\t\t*value = buf[10] == 0x70;\n\n\terr = 0;\n\nerror:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int avc_audio_feature_volume(struct fw_unit *unit, u8 fb_id, s16 *value,\n\t\t\t\t    unsigned int channel,\n\t\t\t\t    enum control_attribute attribute,\n\t\t\t\t    enum control_action action)\n{\n\tu8 *buf;\n\tu8 response_ok;\n\tint err;\n\n\tbuf = kmalloc(12, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (action == CTL_READ) {\n\t\tbuf[0] = 0x01;\t\t \n\t\tresponse_ok = 0x0c;\t \n\t} else {\n\t\tbuf[0] = 0x00;\t\t \n\t\tresponse_ok = 0x09;\t \n\t}\n\tbuf[1] = 0x08;\t\t\t \n\tbuf[2] = 0xb8;\t\t\t \n\tbuf[3] = 0x81;\t\t\t \n\tbuf[4] = fb_id;\t\t\t \n\tbuf[5] = attribute;\t\t \n\tbuf[6] = 0x02;\t\t\t \n\tbuf[7] = channel;\t\t \n\tbuf[8] = 0x02;\t\t\t \n\tbuf[9] = 0x02;\t\t\t \n\tif (action == CTL_READ) {\n\t\tbuf[10] = 0xff;\n\t\tbuf[11] = 0xff;\n\t} else {\n\t\tbuf[10] = *value >> 8;\n\t\tbuf[11] = *value;\n\t}\n\n\terr = fcp_avc_transaction(unit, buf, 12, buf, 12, 0x3fe);\n\tif (err < 0)\n\t\tgoto error;\n\tif (err < 12) {\n\t\tdev_err(&unit->device, \"short FCP response\\n\");\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\tif (buf[0] != response_ok) {\n\t\tdev_err(&unit->device, \"volume command failed\\n\");\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\tif (action == CTL_READ)\n\t\t*value = (buf[10] << 8) | buf[11];\n\n\terr = 0;\n\nerror:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int spkr_mute_get(struct snd_kcontrol *control,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct snd_oxfw *oxfw = control->private_data;\n\tstruct fw_spkr *spkr = oxfw->spec;\n\n\tvalue->value.integer.value[0] = !spkr->mute;\n\n\treturn 0;\n}\n\nstatic int spkr_mute_put(struct snd_kcontrol *control,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct snd_oxfw *oxfw = control->private_data;\n\tstruct fw_spkr *spkr = oxfw->spec;\n\tbool mute;\n\tint err;\n\n\tmute = !value->value.integer.value[0];\n\n\tif (mute == spkr->mute)\n\t\treturn 0;\n\n\terr = avc_audio_feature_mute(oxfw->unit, spkr->mute_fb_id, &mute,\n\t\t\t\t     CTL_WRITE);\n\tif (err < 0)\n\t\treturn err;\n\tspkr->mute = mute;\n\n\treturn 1;\n}\n\nstatic int spkr_volume_info(struct snd_kcontrol *control,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstruct snd_oxfw *oxfw = control->private_data;\n\tstruct fw_spkr *spkr = oxfw->spec;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = spkr->mixer_channels;\n\tinfo->value.integer.min = spkr->volume_min;\n\tinfo->value.integer.max = spkr->volume_max;\n\n\treturn 0;\n}\n\nstatic const u8 channel_map[6] = { 0, 1, 4, 5, 2, 3 };\n\nstatic int spkr_volume_get(struct snd_kcontrol *control,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_oxfw *oxfw = control->private_data;\n\tstruct fw_spkr *spkr = oxfw->spec;\n\tunsigned int i;\n\n\tfor (i = 0; i < spkr->mixer_channels; ++i)\n\t\tvalue->value.integer.value[channel_map[i]] = spkr->volume[i];\n\n\treturn 0;\n}\n\nstatic int spkr_volume_put(struct snd_kcontrol *control,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_oxfw *oxfw = control->private_data;\n\tstruct fw_spkr *spkr = oxfw->spec;\n\tunsigned int i, changed_channels;\n\tbool equal_values = true;\n\ts16 volume;\n\tint err;\n\n\tfor (i = 0; i < spkr->mixer_channels; ++i) {\n\t\tif (value->value.integer.value[i] < spkr->volume_min ||\n\t\t    value->value.integer.value[i] > spkr->volume_max)\n\t\t\treturn -EINVAL;\n\t\tif (value->value.integer.value[i] !=\n\t\t    value->value.integer.value[0])\n\t\t\tequal_values = false;\n\t}\n\n\tchanged_channels = 0;\n\tfor (i = 0; i < spkr->mixer_channels; ++i)\n\t\tif (value->value.integer.value[channel_map[i]] !=\n\t\t\t\t\t\t\tspkr->volume[i])\n\t\t\tchanged_channels |= 1 << (i + 1);\n\n\tif (equal_values && changed_channels != 0)\n\t\tchanged_channels = 1 << 0;\n\n\tfor (i = 0; i <= spkr->mixer_channels; ++i) {\n\t\tvolume = value->value.integer.value[channel_map[i ? i - 1 : 0]];\n\t\tif (changed_channels & (1 << i)) {\n\t\t\terr = avc_audio_feature_volume(oxfw->unit,\n\t\t\t\t\t\t  spkr->volume_fb_id, &volume,\n\t\t\t\t\t\t  i, CTL_CURRENT, CTL_WRITE);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (i > 0)\n\t\t\tspkr->volume[i - 1] = volume;\n\t}\n\n\treturn changed_channels != 0;\n}\n\nint snd_oxfw_add_spkr(struct snd_oxfw *oxfw, bool is_lacie)\n{\n\tstatic const struct snd_kcontrol_new controls[] = {\n\t\t{\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.name = \"PCM Playback Switch\",\n\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t.get = spkr_mute_get,\n\t\t\t.put = spkr_mute_put,\n\t\t},\n\t\t{\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.name = \"PCM Playback Volume\",\n\t\t\t.info = spkr_volume_info,\n\t\t\t.get = spkr_volume_get,\n\t\t\t.put = spkr_volume_put,\n\t\t},\n\t};\n\tstruct fw_spkr *spkr;\n\tunsigned int i, first_ch;\n\tint err;\n\n\tspkr = devm_kzalloc(&oxfw->card->card_dev, sizeof(struct fw_spkr),\n\t\t\t    GFP_KERNEL);\n\tif (!spkr)\n\t\treturn -ENOMEM;\n\toxfw->spec = spkr;\n\n\tif (is_lacie) {\n\t\tspkr->mixer_channels = 1;\n\t\tspkr->mute_fb_id = 0x01;\n\t\tspkr->volume_fb_id = 0x01;\n\t} else {\n\t\tspkr->mixer_channels = 6;\n\t\tspkr->mute_fb_id = 0x01;\n\t\tspkr->volume_fb_id = 0x02;\n\t}\n\n\terr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\n\t\t\t\t       &spkr->volume_min, 0, CTL_MIN, CTL_READ);\n\tif (err < 0)\n\t\treturn err;\n\terr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\n\t\t\t\t       &spkr->volume_max, 0, CTL_MAX, CTL_READ);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = avc_audio_feature_mute(oxfw->unit, spkr->mute_fb_id, &spkr->mute,\n\t\t\t\t     CTL_READ);\n\tif (err < 0)\n\t\treturn err;\n\n\tfirst_ch = spkr->mixer_channels == 1 ? 0 : 1;\n\tfor (i = 0; i < spkr->mixer_channels; ++i) {\n\t\terr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\n\t\t\t\t\t       &spkr->volume[i], first_ch + i,\n\t\t\t\t\t       CTL_CURRENT, CTL_READ);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(controls); ++i) {\n\t\terr = snd_ctl_add(oxfw->card,\n\t\t\t\t  snd_ctl_new1(&controls[i], oxfw));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}