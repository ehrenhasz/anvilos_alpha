{
  "module_name": "dice-stream.c",
  "hash_id": "eeb296b5fbed073535485728a203d30bafa6b13b258f21450d405b2d5f8c44b0",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-stream.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\n#define\tREADY_TIMEOUT_MS\t200\n#define NOTIFICATION_TIMEOUT_MS\t100\n\nstruct reg_params {\n\tunsigned int count;\n\tunsigned int size;\n};\n\nconst unsigned int snd_dice_rates[SND_DICE_RATES_COUNT] = {\n\t \n\t[0] =  32000,\n\t[1] =  44100,\n\t[2] =  48000,\n\t \n\t[3] =  88200,\n\t[4] =  96000,\n\t \n\t[5] = 176400,\n\t[6] = 192000,\n};\n\nint snd_dice_stream_get_rate_mode(struct snd_dice *dice, unsigned int rate,\n\t\t\t\t  enum snd_dice_rate_mode *mode)\n{\n\t \n\tstatic const enum snd_dice_rate_mode modes[] = {\n\t\t[0] = SND_DICE_RATE_MODE_LOW,\n\t\t[1] = SND_DICE_RATE_MODE_LOW,\n\t\t[2] = SND_DICE_RATE_MODE_LOW,\n\t\t[3] = SND_DICE_RATE_MODE_MIDDLE,\n\t\t[4] = SND_DICE_RATE_MODE_MIDDLE,\n\t\t[5] = SND_DICE_RATE_MODE_HIGH,\n\t\t[6] = SND_DICE_RATE_MODE_HIGH,\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); i++) {\n\t\tif (!(dice->clock_caps & BIT(i)))\n\t\t\tcontinue;\n\t\tif (snd_dice_rates[i] != rate)\n\t\t\tcontinue;\n\n\t\t*mode = modes[i];\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int select_clock(struct snd_dice *dice, unsigned int rate)\n{\n\t__be32 reg, new;\n\tu32 data;\n\tint i;\n\tint err;\n\n\terr = snd_dice_transaction_read_global(dice, GLOBAL_CLOCK_SELECT,\n\t\t\t\t\t       &reg, sizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = be32_to_cpu(reg);\n\n\tdata &= ~CLOCK_RATE_MASK;\n\tfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\n\t\tif (snd_dice_rates[i] == rate)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(snd_dice_rates))\n\t\treturn -EINVAL;\n\tdata |= i << CLOCK_RATE_SHIFT;\n\n\tif (completion_done(&dice->clock_accepted))\n\t\treinit_completion(&dice->clock_accepted);\n\n\tnew = cpu_to_be32(data);\n\terr = snd_dice_transaction_write_global(dice, GLOBAL_CLOCK_SELECT,\n\t\t\t\t\t\t&new, sizeof(new));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (wait_for_completion_timeout(&dice->clock_accepted,\n\t\t\tmsecs_to_jiffies(NOTIFICATION_TIMEOUT_MS)) == 0) {\n\t\tif (reg != new)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_register_params(struct snd_dice *dice,\n\t\t\t       struct reg_params *tx_params,\n\t\t\t       struct reg_params *rx_params)\n{\n\t__be32 reg[2];\n\tint err;\n\n\terr = snd_dice_transaction_read_tx(dice, TX_NUMBER, reg, sizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\ttx_params->count =\n\t\t\tmin_t(unsigned int, be32_to_cpu(reg[0]), MAX_STREAMS);\n\ttx_params->size = be32_to_cpu(reg[1]) * 4;\n\n\terr = snd_dice_transaction_read_rx(dice, RX_NUMBER, reg, sizeof(reg));\n\tif (err < 0)\n\t\treturn err;\n\trx_params->count =\n\t\t\tmin_t(unsigned int, be32_to_cpu(reg[0]), MAX_STREAMS);\n\trx_params->size = be32_to_cpu(reg[1]) * 4;\n\n\treturn 0;\n}\n\nstatic void release_resources(struct snd_dice *dice)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\tfw_iso_resources_free(&dice->tx_resources[i]);\n\t\tfw_iso_resources_free(&dice->rx_resources[i]);\n\t}\n}\n\nstatic void stop_streams(struct snd_dice *dice, enum amdtp_stream_direction dir,\n\t\t\t struct reg_params *params)\n{\n\t__be32 reg;\n\tunsigned int i;\n\n\tfor (i = 0; i < params->count; i++) {\n\t\treg = cpu_to_be32((u32)-1);\n\t\tif (dir == AMDTP_IN_STREAM) {\n\t\t\tsnd_dice_transaction_write_tx(dice,\n\t\t\t\t\tparams->size * i + TX_ISOCHRONOUS,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t} else {\n\t\t\tsnd_dice_transaction_write_rx(dice,\n\t\t\t\t\tparams->size * i + RX_ISOCHRONOUS,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t}\n\t}\n}\n\nstatic int keep_resources(struct snd_dice *dice, struct amdtp_stream *stream,\n\t\t\t  struct fw_iso_resources *resources, unsigned int rate,\n\t\t\t  unsigned int pcm_chs, unsigned int midi_ports)\n{\n\tbool double_pcm_frames;\n\tunsigned int i;\n\tint err;\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tdouble_pcm_frames = (rate > 96000 && !dice->disable_double_pcm_frames);\n\tif (double_pcm_frames) {\n\t\trate /= 2;\n\t\tpcm_chs *= 2;\n\t}\n\n\terr = amdtp_am824_set_parameters(stream, rate, pcm_chs, midi_ports,\n\t\t\t\t\t double_pcm_frames);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (double_pcm_frames) {\n\t\tpcm_chs /= 2;\n\n\t\tfor (i = 0; i < pcm_chs; i++) {\n\t\t\tamdtp_am824_set_pcm_position(stream, i, i * 2);\n\t\t\tamdtp_am824_set_pcm_position(stream, i + pcm_chs,\n\t\t\t\t\t\t     i * 2 + 1);\n\t\t}\n\t}\n\n\treturn fw_iso_resources_allocate(resources,\n\t\t\t\tamdtp_stream_get_max_payload(stream),\n\t\t\t\tfw_parent_device(dice->unit)->max_speed);\n}\n\nstatic int keep_dual_resources(struct snd_dice *dice, unsigned int rate,\n\t\t\t       enum amdtp_stream_direction dir,\n\t\t\t       struct reg_params *params)\n{\n\tenum snd_dice_rate_mode mode;\n\tint i;\n\tint err;\n\n\terr = snd_dice_stream_get_rate_mode(dice, rate, &mode);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < params->count; ++i) {\n\t\t__be32 reg[2];\n\t\tstruct amdtp_stream *stream;\n\t\tstruct fw_iso_resources *resources;\n\t\tunsigned int pcm_cache;\n\t\tunsigned int pcm_chs;\n\t\tunsigned int midi_ports;\n\n\t\tif (dir == AMDTP_IN_STREAM) {\n\t\t\tstream = &dice->tx_stream[i];\n\t\t\tresources = &dice->tx_resources[i];\n\n\t\t\tpcm_cache = dice->tx_pcm_chs[i][mode];\n\t\t\terr = snd_dice_transaction_read_tx(dice,\n\t\t\t\t\tparams->size * i + TX_NUMBER_AUDIO,\n\t\t\t\t\treg, sizeof(reg));\n\t\t} else {\n\t\t\tstream = &dice->rx_stream[i];\n\t\t\tresources = &dice->rx_resources[i];\n\n\t\t\tpcm_cache = dice->rx_pcm_chs[i][mode];\n\t\t\terr = snd_dice_transaction_read_rx(dice,\n\t\t\t\t\tparams->size * i + RX_NUMBER_AUDIO,\n\t\t\t\t\treg, sizeof(reg));\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpcm_chs = be32_to_cpu(reg[0]);\n\t\tmidi_ports = be32_to_cpu(reg[1]);\n\n\t\t\n\t\tif (pcm_chs != pcm_cache) {\n\t\t\tdev_info(&dice->unit->device,\n\t\t\t\t \"cache mismatch: pcm: %u:%u, midi: %u\\n\",\n\t\t\t\t pcm_chs, pcm_cache, midi_ports);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\terr = keep_resources(dice, stream, resources, rate, pcm_chs,\n\t\t\t\t     midi_ports);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void finish_session(struct snd_dice *dice, struct reg_params *tx_params,\n\t\t\t   struct reg_params *rx_params)\n{\n\tstop_streams(dice, AMDTP_IN_STREAM, tx_params);\n\tstop_streams(dice, AMDTP_OUT_STREAM, rx_params);\n\n\tsnd_dice_transaction_clear_enable(dice);\n}\n\nint snd_dice_stream_reserve_duplex(struct snd_dice *dice, unsigned int rate,\n\t\t\t\t   unsigned int events_per_period,\n\t\t\t\t   unsigned int events_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\t\n\terr = snd_dice_transaction_get_rate(dice, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0)\n\t\trate = curr_rate;\n\n\tif (dice->substreams_counter == 0 || curr_rate != rate) {\n\t\tstruct reg_params tx_params, rx_params;\n\n\t\tamdtp_domain_stop(&dice->domain);\n\n\t\terr = get_register_params(dice, &tx_params, &rx_params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tfinish_session(dice, &tx_params, &rx_params);\n\n\t\trelease_resources(dice);\n\n\t\t\n\t\t\n\t\t\n\t\terr = select_clock(dice, rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t\n\t\t\n\t\terr = get_register_params(dice, &tx_params, &rx_params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_dual_resources(dice, rate, AMDTP_IN_STREAM,\n\t\t\t\t\t  &tx_params);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = keep_dual_resources(dice, rate, AMDTP_OUT_STREAM,\n\t\t\t\t\t  &rx_params);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_set_events_per_period(&dice->domain,\n\t\t\t\t\tevents_per_period, events_per_buffer);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\trelease_resources(dice);\n\treturn err;\n}\n\nstatic int start_streams(struct snd_dice *dice, enum amdtp_stream_direction dir,\n\t\t\t unsigned int rate, struct reg_params *params)\n{\n\tunsigned int max_speed = fw_parent_device(dice->unit)->max_speed;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < params->count; i++) {\n\t\tstruct amdtp_stream *stream;\n\t\tstruct fw_iso_resources *resources;\n\t\t__be32 reg;\n\n\t\tif (dir == AMDTP_IN_STREAM) {\n\t\t\tstream = dice->tx_stream + i;\n\t\t\tresources = dice->tx_resources + i;\n\t\t} else {\n\t\t\tstream = dice->rx_stream + i;\n\t\t\tresources = dice->rx_resources + i;\n\t\t}\n\n\t\treg = cpu_to_be32(resources->channel);\n\t\tif (dir == AMDTP_IN_STREAM) {\n\t\t\terr = snd_dice_transaction_write_tx(dice,\n\t\t\t\t\tparams->size * i + TX_ISOCHRONOUS,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t} else {\n\t\t\terr = snd_dice_transaction_write_rx(dice,\n\t\t\t\t\tparams->size * i + RX_ISOCHRONOUS,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (dir == AMDTP_IN_STREAM) {\n\t\t\treg = cpu_to_be32(max_speed);\n\t\t\terr = snd_dice_transaction_write_tx(dice,\n\t\t\t\t\tparams->size * i + TX_SPEED,\n\t\t\t\t\t&reg, sizeof(reg));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_add_stream(&dice->domain, stream,\n\t\t\t\t\t      resources->channel, max_speed);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nint snd_dice_stream_start_duplex(struct snd_dice *dice)\n{\n\tunsigned int generation = dice->rx_resources[0].generation;\n\tstruct reg_params tx_params, rx_params;\n\tunsigned int i;\n\tunsigned int rate;\n\tenum snd_dice_rate_mode mode;\n\tint err;\n\n\tif (dice->substreams_counter == 0)\n\t\treturn -EIO;\n\n\terr = get_register_params(dice, &tx_params, &rx_params);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\tif (amdtp_streaming_error(&dice->tx_stream[i]) ||\n\t\t    amdtp_streaming_error(&dice->rx_stream[i])) {\n\t\t\tamdtp_domain_stop(&dice->domain);\n\t\t\tfinish_session(dice, &tx_params, &rx_params);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (generation != fw_parent_device(dice->unit)->card->generation) {\n\t\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\t\tif (i < tx_params.count)\n\t\t\t\tfw_iso_resources_update(dice->tx_resources + i);\n\t\t\tif (i < rx_params.count)\n\t\t\t\tfw_iso_resources_update(dice->rx_resources + i);\n\t\t}\n\t}\n\n\t \n\terr = snd_dice_transaction_get_rate(dice, &rate);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_dice_stream_get_rate_mode(dice, rate, &mode);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\tif (dice->tx_pcm_chs[i][mode] > 0 &&\n\t\t    !amdtp_stream_running(&dice->tx_stream[i]))\n\t\t\tbreak;\n\t\tif (dice->rx_pcm_chs[i][mode] > 0 &&\n\t\t    !amdtp_stream_running(&dice->rx_stream[i]))\n\t\t\tbreak;\n\t}\n\tif (i < MAX_STREAMS) {\n\t\t \n\t\terr = start_streams(dice, AMDTP_IN_STREAM, rate, &tx_params);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = start_streams(dice, AMDTP_OUT_STREAM, rate, &rx_params);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = snd_dice_transaction_set_enable(dice);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dice->unit->device,\n\t\t\t\t\"fail to enable interface\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\terr = amdtp_domain_start(&dice->domain, 0, true, false);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&dice->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&dice->domain);\n\tfinish_session(dice, &tx_params, &rx_params);\n\treturn err;\n}\n\n \nvoid snd_dice_stream_stop_duplex(struct snd_dice *dice)\n{\n\tstruct reg_params tx_params, rx_params;\n\n\tif (dice->substreams_counter == 0) {\n\t\tif (get_register_params(dice, &tx_params, &rx_params) >= 0)\n\t\t\tfinish_session(dice, &tx_params, &rx_params);\n\n\t\tamdtp_domain_stop(&dice->domain);\n\t\trelease_resources(dice);\n\t}\n}\n\nstatic int init_stream(struct snd_dice *dice, enum amdtp_stream_direction dir,\n\t\t       unsigned int index)\n{\n\tstruct amdtp_stream *stream;\n\tstruct fw_iso_resources *resources;\n\tint err;\n\n\tif (dir == AMDTP_IN_STREAM) {\n\t\tstream = &dice->tx_stream[index];\n\t\tresources = &dice->tx_resources[index];\n\t} else {\n\t\tstream = &dice->rx_stream[index];\n\t\tresources = &dice->rx_resources[index];\n\t}\n\n\terr = fw_iso_resources_init(resources, dice->unit);\n\tif (err < 0)\n\t\tgoto end;\n\tresources->channels_mask = 0x00000000ffffffffuLL;\n\n\terr = amdtp_am824_init(stream, dice->unit, dir, CIP_BLOCKING);\n\tif (err < 0) {\n\t\tamdtp_stream_destroy(stream);\n\t\tfw_iso_resources_destroy(resources);\n\t}\nend:\n\treturn err;\n}\n\n \nstatic void destroy_stream(struct snd_dice *dice,\n\t\t\t   enum amdtp_stream_direction dir,\n\t\t\t   unsigned int index)\n{\n\tstruct amdtp_stream *stream;\n\tstruct fw_iso_resources *resources;\n\n\tif (dir == AMDTP_IN_STREAM) {\n\t\tstream = &dice->tx_stream[index];\n\t\tresources = &dice->tx_resources[index];\n\t} else {\n\t\tstream = &dice->rx_stream[index];\n\t\tresources = &dice->rx_resources[index];\n\t}\n\n\tamdtp_stream_destroy(stream);\n\tfw_iso_resources_destroy(resources);\n}\n\nint snd_dice_stream_init_duplex(struct snd_dice *dice)\n{\n\tint i, err;\n\n\tfor (i = 0; i < MAX_STREAMS; i++) {\n\t\terr = init_stream(dice, AMDTP_IN_STREAM, i);\n\t\tif (err < 0) {\n\t\t\tfor (; i >= 0; i--)\n\t\t\t\tdestroy_stream(dice, AMDTP_IN_STREAM, i);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_STREAMS; i++) {\n\t\terr = init_stream(dice, AMDTP_OUT_STREAM, i);\n\t\tif (err < 0) {\n\t\t\tfor (; i >= 0; i--)\n\t\t\t\tdestroy_stream(dice, AMDTP_OUT_STREAM, i);\n\t\t\tfor (i = 0; i < MAX_STREAMS; i++)\n\t\t\t\tdestroy_stream(dice, AMDTP_IN_STREAM, i);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\terr = amdtp_domain_init(&dice->domain);\n\tif (err < 0) {\n\t\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\t\tdestroy_stream(dice, AMDTP_OUT_STREAM, i);\n\t\t\tdestroy_stream(dice, AMDTP_IN_STREAM, i);\n\t\t}\n\t}\nend:\n\treturn err;\n}\n\nvoid snd_dice_stream_destroy_duplex(struct snd_dice *dice)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX_STREAMS; i++) {\n\t\tdestroy_stream(dice, AMDTP_IN_STREAM, i);\n\t\tdestroy_stream(dice, AMDTP_OUT_STREAM, i);\n\t}\n\n\tamdtp_domain_destroy(&dice->domain);\n}\n\nvoid snd_dice_stream_update_duplex(struct snd_dice *dice)\n{\n\tstruct reg_params tx_params, rx_params;\n\n\t \n\tdice->global_enabled = false;\n\n\tif (get_register_params(dice, &tx_params, &rx_params) == 0) {\n\t\tamdtp_domain_stop(&dice->domain);\n\n\t\tstop_streams(dice, AMDTP_IN_STREAM, &tx_params);\n\t\tstop_streams(dice, AMDTP_OUT_STREAM, &rx_params);\n\t}\n}\n\nint snd_dice_stream_detect_current_formats(struct snd_dice *dice)\n{\n\tunsigned int rate;\n\tenum snd_dice_rate_mode mode;\n\t__be32 reg[2];\n\tstruct reg_params tx_params, rx_params;\n\tint i;\n\tint err;\n\n\t \n\terr = snd_dice_detect_extension_formats(dice);\n\tif (err >= 0)\n\t\treturn err;\n\n\t \n\terr = snd_dice_transaction_get_rate(dice, &rate);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_dice_stream_get_rate_mode(dice, rate, &mode);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = select_clock(dice, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_register_params(dice, &tx_params, &rx_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < tx_params.count; ++i) {\n\t\terr = snd_dice_transaction_read_tx(dice,\n\t\t\t\ttx_params.size * i + TX_NUMBER_AUDIO,\n\t\t\t\treg, sizeof(reg));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdice->tx_pcm_chs[i][mode] = be32_to_cpu(reg[0]);\n\t\tdice->tx_midi_ports[i] = max_t(unsigned int,\n\t\t\t\tbe32_to_cpu(reg[1]), dice->tx_midi_ports[i]);\n\t}\n\tfor (i = 0; i < rx_params.count; ++i) {\n\t\terr = snd_dice_transaction_read_rx(dice,\n\t\t\t\trx_params.size * i + RX_NUMBER_AUDIO,\n\t\t\t\treg, sizeof(reg));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdice->rx_pcm_chs[i][mode] = be32_to_cpu(reg[0]);\n\t\tdice->rx_midi_ports[i] = max_t(unsigned int,\n\t\t\t\tbe32_to_cpu(reg[1]), dice->rx_midi_ports[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void dice_lock_changed(struct snd_dice *dice)\n{\n\tdice->dev_lock_changed = true;\n\twake_up(&dice->hwdep_wait);\n}\n\nint snd_dice_stream_lock_try(struct snd_dice *dice)\n{\n\tint err;\n\n\tspin_lock_irq(&dice->lock);\n\n\tif (dice->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (dice->dev_lock_count++ == 0)\n\t\tdice_lock_changed(dice);\n\terr = 0;\nout:\n\tspin_unlock_irq(&dice->lock);\n\treturn err;\n}\n\nvoid snd_dice_stream_lock_release(struct snd_dice *dice)\n{\n\tspin_lock_irq(&dice->lock);\n\n\tif (WARN_ON(dice->dev_lock_count <= 0))\n\t\tgoto out;\n\n\tif (--dice->dev_lock_count == 0)\n\t\tdice_lock_changed(dice);\nout:\n\tspin_unlock_irq(&dice->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}