{
  "module_name": "dice-proc.c",
  "hash_id": "8de0c43f97ce26bfb906c653e8390de5d289790d43fdadaa1da433c512d41c12",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-proc.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\nstatic int dice_proc_read_mem(struct snd_dice *dice, void *buffer,\n\t\t\t      unsigned int offset_q, unsigned int quadlets)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t DICE_PRIVATE_SPACE + 4 * offset_q,\n\t\t\t\t buffer, 4 * quadlets, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < quadlets; ++i)\n\t\tbe32_to_cpus(&((u32 *)buffer)[i]);\n\n\treturn 0;\n}\n\nstatic const char *str_from_array(const char *const strs[], unsigned int count,\n\t\t\t\t  unsigned int i)\n{\n\tif (i < count)\n\t\treturn strs[i];\n\n\treturn \"(unknown)\";\n}\n\nstatic void dice_proc_fixup_string(char *s, unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i += 4)\n\t\tcpu_to_le32s((u32 *)(s + i));\n\n\tfor (i = 0; i < size - 2; ++i) {\n\t\tif (s[i] == '\\0')\n\t\t\treturn;\n\t\tif (s[i] == '\\\\' && s[i + 1] == '\\\\') {\n\t\t\ts[i + 2] = '\\0';\n\t\t\treturn;\n\t\t}\n\t}\n\ts[size - 1] = '\\0';\n}\n\nstatic void dice_proc_read(struct snd_info_entry *entry,\n\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstatic const char *const section_names[5] = {\n\t\t\"global\", \"tx\", \"rx\", \"ext_sync\", \"unused2\"\n\t};\n\tstatic const char *const clock_sources[] = {\n\t\t\"aes1\", \"aes2\", \"aes3\", \"aes4\", \"aes\", \"adat\", \"tdif\",\n\t\t\"wc\", \"arx1\", \"arx2\", \"arx3\", \"arx4\", \"internal\"\n\t};\n\tstatic const char *const rates[] = {\n\t\t\"32000\", \"44100\", \"48000\", \"88200\", \"96000\", \"176400\", \"192000\",\n\t\t\"any low\", \"any mid\", \"any high\", \"none\"\n\t};\n\tstruct snd_dice *dice = entry->private_data;\n\tu32 sections[ARRAY_SIZE(section_names) * 2];\n\tstruct {\n\t\tu32 number;\n\t\tu32 size;\n\t} tx_rx_header;\n\tunion {\n\t\tstruct {\n\t\t\tu32 owner_hi, owner_lo;\n\t\t\tu32 notification;\n\t\t\tchar nick_name[NICK_NAME_SIZE];\n\t\t\tu32 clock_select;\n\t\t\tu32 enable;\n\t\t\tu32 status;\n\t\t\tu32 extended_status;\n\t\t\tu32 sample_rate;\n\t\t\tu32 version;\n\t\t\tu32 clock_caps;\n\t\t\tchar clock_source_names[CLOCK_SOURCE_NAMES_SIZE];\n\t\t} global;\n\t\tstruct {\n\t\t\tu32 iso;\n\t\t\tu32 number_audio;\n\t\t\tu32 number_midi;\n\t\t\tu32 speed;\n\t\t\tchar names[TX_NAMES_SIZE];\n\t\t\tu32 ac3_caps;\n\t\t\tu32 ac3_enable;\n\t\t} tx;\n\t\tstruct {\n\t\t\tu32 iso;\n\t\t\tu32 seq_start;\n\t\t\tu32 number_audio;\n\t\t\tu32 number_midi;\n\t\t\tchar names[RX_NAMES_SIZE];\n\t\t\tu32 ac3_caps;\n\t\t\tu32 ac3_enable;\n\t\t} rx;\n\t\tstruct {\n\t\t\tu32 clock_source;\n\t\t\tu32 locked;\n\t\t\tu32 rate;\n\t\t\tu32 adat_user_data;\n\t\t} ext_sync;\n\t} buf;\n\tunsigned int quadlets, stream, i;\n\n\tif (dice_proc_read_mem(dice, sections, 0, ARRAY_SIZE(sections)) < 0)\n\t\treturn;\n\tsnd_iprintf(buffer, \"sections:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(section_names); ++i)\n\t\tsnd_iprintf(buffer, \"  %s: offset %u, size %u\\n\",\n\t\t\t    section_names[i],\n\t\t\t    sections[i * 2], sections[i * 2 + 1]);\n\n\tquadlets = min_t(u32, sections[1], sizeof(buf.global) / 4);\n\tif (dice_proc_read_mem(dice, &buf.global, sections[0], quadlets) < 0)\n\t\treturn;\n\tsnd_iprintf(buffer, \"global:\\n\");\n\tsnd_iprintf(buffer, \"  owner: %04x:%04x%08x\\n\",\n\t\t    buf.global.owner_hi >> 16,\n\t\t    buf.global.owner_hi & 0xffff, buf.global.owner_lo);\n\tsnd_iprintf(buffer, \"  notification: %08x\\n\", buf.global.notification);\n\tdice_proc_fixup_string(buf.global.nick_name, NICK_NAME_SIZE);\n\tsnd_iprintf(buffer, \"  nick name: %s\\n\", buf.global.nick_name);\n\tsnd_iprintf(buffer, \"  clock select: %s %s\\n\",\n\t\t    str_from_array(clock_sources, ARRAY_SIZE(clock_sources),\n\t\t\t\t   buf.global.clock_select & CLOCK_SOURCE_MASK),\n\t\t    str_from_array(rates, ARRAY_SIZE(rates),\n\t\t\t\t   (buf.global.clock_select & CLOCK_RATE_MASK)\n\t\t\t\t   >> CLOCK_RATE_SHIFT));\n\tsnd_iprintf(buffer, \"  enable: %u\\n\", buf.global.enable);\n\tsnd_iprintf(buffer, \"  status: %slocked %s\\n\",\n\t\t    buf.global.status & STATUS_SOURCE_LOCKED ? \"\" : \"un\",\n\t\t    str_from_array(rates, ARRAY_SIZE(rates),\n\t\t\t\t   (buf.global.status &\n\t\t\t\t    STATUS_NOMINAL_RATE_MASK)\n\t\t\t\t   >> CLOCK_RATE_SHIFT));\n\tsnd_iprintf(buffer, \"  ext status: %08x\\n\", buf.global.extended_status);\n\tsnd_iprintf(buffer, \"  sample rate: %u\\n\", buf.global.sample_rate);\n\tif (quadlets >= 90) {\n\t\tsnd_iprintf(buffer, \"  version: %u.%u.%u.%u\\n\",\n\t\t\t    (buf.global.version >> 24) & 0xff,\n\t\t\t    (buf.global.version >> 16) & 0xff,\n\t\t\t    (buf.global.version >>  8) & 0xff,\n\t\t\t    (buf.global.version >>  0) & 0xff);\n\t\tsnd_iprintf(buffer, \"  clock caps:\");\n\t\tfor (i = 0; i <= 6; ++i)\n\t\t\tif (buf.global.clock_caps & (1 << i))\n\t\t\t\tsnd_iprintf(buffer, \" %s\", rates[i]);\n\t\tfor (i = 0; i <= 12; ++i)\n\t\t\tif (buf.global.clock_caps & (1 << (16 + i)))\n\t\t\t\tsnd_iprintf(buffer, \" %s\", clock_sources[i]);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tdice_proc_fixup_string(buf.global.clock_source_names,\n\t\t\t\t       CLOCK_SOURCE_NAMES_SIZE);\n\t\tsnd_iprintf(buffer, \"  clock source names: %s\\n\",\n\t\t\t    buf.global.clock_source_names);\n\t}\n\n\tif (dice_proc_read_mem(dice, &tx_rx_header, sections[2], 2) < 0)\n\t\treturn;\n\tquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.tx) / 4);\n\tfor (stream = 0; stream < tx_rx_header.number; ++stream) {\n\t\tif (dice_proc_read_mem(dice, &buf.tx, sections[2] + 2 +\n\t\t\t\t       stream * tx_rx_header.size,\n\t\t\t\t       quadlets) < 0)\n\t\t\tbreak;\n\t\tsnd_iprintf(buffer, \"tx %u:\\n\", stream);\n\t\tsnd_iprintf(buffer, \"  iso channel: %d\\n\", (int)buf.tx.iso);\n\t\tsnd_iprintf(buffer, \"  audio channels: %u\\n\",\n\t\t\t    buf.tx.number_audio);\n\t\tsnd_iprintf(buffer, \"  midi ports: %u\\n\", buf.tx.number_midi);\n\t\tsnd_iprintf(buffer, \"  speed: S%u\\n\", 100u << buf.tx.speed);\n\t\tif (quadlets >= 68) {\n\t\t\tdice_proc_fixup_string(buf.tx.names, TX_NAMES_SIZE);\n\t\t\tsnd_iprintf(buffer, \"  names: %s\\n\", buf.tx.names);\n\t\t}\n\t\tif (quadlets >= 70) {\n\t\t\tsnd_iprintf(buffer, \"  ac3 caps: %08x\\n\",\n\t\t\t\t    buf.tx.ac3_caps);\n\t\t\tsnd_iprintf(buffer, \"  ac3 enable: %08x\\n\",\n\t\t\t\t    buf.tx.ac3_enable);\n\t\t}\n\t}\n\n\tif (dice_proc_read_mem(dice, &tx_rx_header, sections[4], 2) < 0)\n\t\treturn;\n\tquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.rx) / 4);\n\tfor (stream = 0; stream < tx_rx_header.number; ++stream) {\n\t\tif (dice_proc_read_mem(dice, &buf.rx, sections[4] + 2 +\n\t\t\t\t       stream * tx_rx_header.size,\n\t\t\t\t       quadlets) < 0)\n\t\t\tbreak;\n\t\tsnd_iprintf(buffer, \"rx %u:\\n\", stream);\n\t\tsnd_iprintf(buffer, \"  iso channel: %d\\n\", (int)buf.rx.iso);\n\t\tsnd_iprintf(buffer, \"  sequence start: %u\\n\", buf.rx.seq_start);\n\t\tsnd_iprintf(buffer, \"  audio channels: %u\\n\",\n\t\t\t    buf.rx.number_audio);\n\t\tsnd_iprintf(buffer, \"  midi ports: %u\\n\", buf.rx.number_midi);\n\t\tif (quadlets >= 68) {\n\t\t\tdice_proc_fixup_string(buf.rx.names, RX_NAMES_SIZE);\n\t\t\tsnd_iprintf(buffer, \"  names: %s\\n\", buf.rx.names);\n\t\t}\n\t\tif (quadlets >= 70) {\n\t\t\tsnd_iprintf(buffer, \"  ac3 caps: %08x\\n\",\n\t\t\t\t    buf.rx.ac3_caps);\n\t\t\tsnd_iprintf(buffer, \"  ac3 enable: %08x\\n\",\n\t\t\t\t    buf.rx.ac3_enable);\n\t\t}\n\t}\n\n\tquadlets = min_t(u32, sections[7], sizeof(buf.ext_sync) / 4);\n\tif (quadlets >= 4) {\n\t\tif (dice_proc_read_mem(dice, &buf.ext_sync,\n\t\t\t\t       sections[6], 4) < 0)\n\t\t\treturn;\n\t\tsnd_iprintf(buffer, \"ext status:\\n\");\n\t\tsnd_iprintf(buffer, \"  clock source: %s\\n\",\n\t\t\t    str_from_array(clock_sources,\n\t\t\t\t\t   ARRAY_SIZE(clock_sources),\n\t\t\t\t\t   buf.ext_sync.clock_source));\n\t\tsnd_iprintf(buffer, \"  locked: %u\\n\", buf.ext_sync.locked);\n\t\tsnd_iprintf(buffer, \"  rate: %s\\n\",\n\t\t\t    str_from_array(rates, ARRAY_SIZE(rates),\n\t\t\t\t\t   buf.ext_sync.rate));\n\t\tsnd_iprintf(buffer, \"  adat user data: \");\n\t\tif (buf.ext_sync.adat_user_data & ADAT_USER_DATA_NO_DATA)\n\t\t\tsnd_iprintf(buffer, \"-\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"%x\\n\",\n\t\t\t\t    buf.ext_sync.adat_user_data);\n\t}\n}\n\nstatic void dice_proc_read_formation(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstatic const char *const rate_labels[] = {\n\t\t[SND_DICE_RATE_MODE_LOW]\t= \"low\",\n\t\t[SND_DICE_RATE_MODE_MIDDLE]\t= \"middle\",\n\t\t[SND_DICE_RATE_MODE_HIGH]\t= \"high\",\n\t};\n\tstruct snd_dice *dice = entry->private_data;\n\tint i, j;\n\n\tsnd_iprintf(buffer, \"Output stream from unit:\\n\");\n\tfor (i = 0; i < SND_DICE_RATE_MODE_COUNT; ++i)\n\t\tsnd_iprintf(buffer, \"\\t%s\", rate_labels[i]);\n\tsnd_iprintf(buffer, \"\\tMIDI\\n\");\n\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\tsnd_iprintf(buffer, \"Tx %u:\", i);\n\t\tfor (j = 0; j < SND_DICE_RATE_MODE_COUNT; ++j)\n\t\t\tsnd_iprintf(buffer, \"\\t%u\", dice->tx_pcm_chs[i][j]);\n\t\tsnd_iprintf(buffer, \"\\t%u\\n\", dice->tx_midi_ports[i]);\n\t}\n\n\tsnd_iprintf(buffer, \"Input stream to unit:\\n\");\n\tfor (i = 0; i < SND_DICE_RATE_MODE_COUNT; ++i)\n\t\tsnd_iprintf(buffer, \"\\t%s\", rate_labels[i]);\n\tsnd_iprintf(buffer, \"\\n\");\n\tfor (i = 0; i < MAX_STREAMS; ++i) {\n\t\tsnd_iprintf(buffer, \"Rx %u:\", i);\n\t\tfor (j = 0; j < SND_DICE_RATE_MODE_COUNT; ++j)\n\t\t\tsnd_iprintf(buffer, \"\\t%u\", dice->rx_pcm_chs[i][j]);\n\t\tsnd_iprintf(buffer, \"\\t%u\\n\", dice->rx_midi_ports[i]);\n\t}\n}\n\nstatic void add_node(struct snd_dice *dice, struct snd_info_entry *root,\n\t\t     const char *name,\n\t\t     void (*op)(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer))\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(dice->card, name, root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, dice, op);\n}\n\nvoid snd_dice_create_proc(struct snd_dice *dice)\n{\n\tstruct snd_info_entry *root;\n\n\t \n\troot = snd_info_create_card_entry(dice->card, \"firewire\",\n\t\t\t\t\t  dice->card->proc_root);\n\tif (!root)\n\t\treturn;\n\troot->mode = S_IFDIR | 0555;\n\n\tadd_node(dice, root, \"dice\", dice_proc_read);\n\tadd_node(dice, root, \"formation\", dice_proc_read_formation);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}