{
  "module_name": "dice-pcm.c",
  "hash_id": "928227b8d2accd5127ea5e10764ca4aae9460d21eab95dcaf656fe9162932ec4",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-pcm.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\nstatic int dice_rate_constraint(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_substream *substream = rule->private;\n\tstruct snd_dice *dice = substream->private_data;\n\tunsigned int index = substream->pcm->device;\n\n\tconst struct snd_interval *c =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval rates = {\n\t\t.min = UINT_MAX, .max = 0, .integer = 1\n\t};\n\tunsigned int *pcm_channels;\n\tenum snd_dice_rate_mode mode;\n\tunsigned int i, rate;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tpcm_channels = dice->tx_pcm_chs[index];\n\telse\n\t\tpcm_channels = dice->rx_pcm_chs[index];\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\n\t\trate = snd_dice_rates[i];\n\t\tif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\n\t\t\tcontinue;\n\n\t\tif (!snd_interval_test(c, pcm_channels[mode]))\n\t\t\tcontinue;\n\n\t\trates.min = min(rates.min, rate);\n\t\trates.max = max(rates.max, rate);\n\t}\n\n\treturn snd_interval_refine(r, &rates);\n}\n\nstatic int dice_channels_constraint(struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_substream *substream = rule->private;\n\tstruct snd_dice *dice = substream->private_data;\n\tunsigned int index = substream->pcm->device;\n\n\tconst struct snd_interval *r =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *c =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval channels = {\n\t\t.min = UINT_MAX, .max = 0, .integer = 1\n\t};\n\tunsigned int *pcm_channels;\n\tenum snd_dice_rate_mode mode;\n\tunsigned int i, rate;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tpcm_channels = dice->tx_pcm_chs[index];\n\telse\n\t\tpcm_channels = dice->rx_pcm_chs[index];\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\n\t\trate = snd_dice_rates[i];\n\t\tif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\n\t\t\tcontinue;\n\n\t\tif (!snd_interval_test(r, rate))\n\t\t\tcontinue;\n\n\t\tchannels.min = min(channels.min, pcm_channels[mode]);\n\t\tchannels.max = max(channels.max, pcm_channels[mode]);\n\t}\n\n\treturn snd_interval_refine(c, &channels);\n}\n\nstatic int limit_channels_and_rates(struct snd_dice *dice,\n\t\t\t\t    struct snd_pcm_runtime *runtime,\n\t\t\t\t    enum amdtp_stream_direction dir,\n\t\t\t\t    unsigned int index)\n{\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tunsigned int *pcm_channels;\n\tunsigned int i;\n\n\tif (dir == AMDTP_IN_STREAM)\n\t\tpcm_channels = dice->tx_pcm_chs[index];\n\telse\n\t\tpcm_channels = dice->rx_pcm_chs[index];\n\n\thw->channels_min = UINT_MAX;\n\thw->channels_max = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\n\t\tenum snd_dice_rate_mode mode;\n\t\tunsigned int rate, channels;\n\n\t\trate = snd_dice_rates[i];\n\t\tif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\n\t\t\tcontinue;\n\t\thw->rates |= snd_pcm_rate_to_rate_bit(rate);\n\n\t\tchannels = pcm_channels[mode];\n\t\tif (channels == 0)\n\t\t\tcontinue;\n\t\thw->channels_min = min(hw->channels_min, channels);\n\t\thw->channels_max = max(hw->channels_max, channels);\n\t}\n\n\tsnd_pcm_limit_hw_rates(runtime);\n\n\treturn 0;\n}\n\nstatic int init_hw_info(struct snd_dice *dice,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tunsigned int index = substream->pcm->device;\n\tenum amdtp_stream_direction dir;\n\tstruct amdtp_stream *stream;\n\tint err;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\thw->formats = AM824_IN_PCM_FORMAT_BITS;\n\t\tdir = AMDTP_IN_STREAM;\n\t\tstream = &dice->tx_stream[index];\n\t} else {\n\t\thw->formats = AM824_OUT_PCM_FORMAT_BITS;\n\t\tdir = AMDTP_OUT_STREAM;\n\t\tstream = &dice->rx_stream[index];\n\t}\n\n\terr = limit_channels_and_rates(dice, substream->runtime, dir,\n\t\t\t\t       index);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  dice_rate_constraint, substream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  dice_channels_constraint, substream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn amdtp_am824_add_pcm_hw_constraints(stream, runtime);\n}\n\nstatic int pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_domain *d = &dice->domain;\n\tunsigned int source;\n\tbool internal;\n\tint err;\n\n\terr = snd_dice_stream_lock_try(dice);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_hw_info(dice, substream);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\terr = snd_dice_transaction_get_clock_source(dice, &source);\n\tif (err < 0)\n\t\tgoto err_locked;\n\tswitch (source) {\n\tcase CLOCK_SOURCE_AES1:\n\tcase CLOCK_SOURCE_AES2:\n\tcase CLOCK_SOURCE_AES3:\n\tcase CLOCK_SOURCE_AES4:\n\tcase CLOCK_SOURCE_AES_ANY:\n\tcase CLOCK_SOURCE_ADAT:\n\tcase CLOCK_SOURCE_TDIF:\n\tcase CLOCK_SOURCE_WC:\n\t\tinternal = false;\n\t\tbreak;\n\tdefault:\n\t\tinternal = true;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&dice->mutex);\n\n\t\n\t\n\t\n\tif (!internal ||\n\t    (dice->substreams_counter > 0 && d->events_per_period > 0)) {\n\t\tunsigned int frames_per_period = d->events_per_period;\n\t\tunsigned int frames_per_buffer = d->events_per_buffer;\n\t\tunsigned int rate;\n\n\t\terr = snd_dice_transaction_get_rate(dice, &rate);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&dice->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\n\t\tsubstream->runtime->hw.rate_min = rate;\n\t\tsubstream->runtime->hw.rate_max = rate;\n\n\t\tif (frames_per_period > 0) {\n\t\t\t\n\t\t\tif (rate > 96000 && !dice->disable_double_pcm_frames) {\n\t\t\t\tframes_per_period *= 2;\n\t\t\t\tframes_per_buffer *= 2;\n\t\t\t}\n\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\tframes_per_period, frames_per_period);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&dice->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\tframes_per_buffer, frames_per_buffer);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&dice->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&dice->mutex);\n\n\tsnd_pcm_set_sync(substream);\n\n\treturn 0;\nerr_locked:\n\tsnd_dice_stream_lock_release(dice);\n\treturn err;\n}\n\nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\n\tsnd_dice_stream_lock_release(dice);\n\n\treturn 0;\n}\n\nstatic int pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tint err = 0;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tunsigned int rate = params_rate(hw_params);\n\t\tunsigned int events_per_period = params_period_size(hw_params);\n\t\tunsigned int events_per_buffer = params_buffer_size(hw_params);\n\n\t\tmutex_lock(&dice->mutex);\n\t\t\n\t\tif (rate > 96000 && !dice->disable_double_pcm_frames) {\n\t\t\tevents_per_period /= 2;\n\t\t\tevents_per_buffer /= 2;\n\t\t}\n\t\terr = snd_dice_stream_reserve_duplex(dice, rate,\n\t\t\t\t\tevents_per_period, events_per_buffer);\n\t\tif (err >= 0)\n\t\t\t++dice->substreams_counter;\n\t\tmutex_unlock(&dice->mutex);\n\t}\n\n\treturn err;\n}\n\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\n\tmutex_lock(&dice->mutex);\n\n\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t--dice->substreams_counter;\n\n\tsnd_dice_stream_stop_duplex(dice);\n\n\tmutex_unlock(&dice->mutex);\n\n\treturn 0;\n}\n\nstatic int capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\n\tint err;\n\n\tmutex_lock(&dice->mutex);\n\terr = snd_dice_stream_start_duplex(dice);\n\tmutex_unlock(&dice->mutex);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(stream);\n\n\treturn 0;\n}\nstatic int playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\n\tint err;\n\n\tmutex_lock(&dice->mutex);\n\terr = snd_dice_stream_start_duplex(dice);\n\tmutex_unlock(&dice->mutex);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(stream);\n\n\treturn err;\n}\n\nstatic int capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nstatic int playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\n\n\treturn amdtp_domain_stream_pcm_pointer(&dice->domain, stream);\n}\nstatic snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\n\n\treturn amdtp_domain_stream_pcm_pointer(&dice->domain, stream);\n}\n\nstatic int capture_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\n\n\treturn amdtp_domain_stream_pcm_ack(&dice->domain, stream);\n}\n\nstatic int playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dice *dice = substream->private_data;\n\tstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\n\n\treturn amdtp_domain_stream_pcm_ack(&dice->domain, stream);\n}\n\nint snd_dice_create_pcm(struct snd_dice *dice)\n{\n\tstatic const struct snd_pcm_ops capture_ops = {\n\t\t.open      = pcm_open,\n\t\t.close     = pcm_close,\n\t\t.hw_params = pcm_hw_params,\n\t\t.hw_free   = pcm_hw_free,\n\t\t.prepare   = capture_prepare,\n\t\t.trigger   = capture_trigger,\n\t\t.pointer   = capture_pointer,\n\t\t.ack       = capture_ack,\n\t};\n\tstatic const struct snd_pcm_ops playback_ops = {\n\t\t.open      = pcm_open,\n\t\t.close     = pcm_close,\n\t\t.hw_params = pcm_hw_params,\n\t\t.hw_free   = pcm_hw_free,\n\t\t.prepare   = playback_prepare,\n\t\t.trigger   = playback_trigger,\n\t\t.pointer   = playback_pointer,\n\t\t.ack       = playback_ack,\n\t};\n\tstruct snd_pcm *pcm;\n\tunsigned int capture, playback;\n\tint i, j;\n\tint err;\n\n\tfor (i = 0; i < MAX_STREAMS; i++) {\n\t\tcapture = playback = 0;\n\t\tfor (j = 0; j < SND_DICE_RATE_MODE_COUNT; ++j) {\n\t\t\tif (dice->tx_pcm_chs[i][j] > 0)\n\t\t\t\tcapture = 1;\n\t\t\tif (dice->rx_pcm_chs[i][j] > 0)\n\t\t\t\tplayback = 1;\n\t\t}\n\n\t\terr = snd_pcm_new(dice->card, \"DICE\", i, playback, capture,\n\t\t\t\t  &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpcm->private_data = dice;\n\t\tstrcpy(pcm->name, dice->card->shortname);\n\n\t\tif (capture > 0)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&capture_ops);\n\n\t\tif (playback > 0)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t&playback_ops);\n\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t\t       NULL, 0, 0);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}