{
  "module_name": "dice-weiss.c",
  "hash_id": "8ba932bf351385e55213e972403887108fe54208f8b1ed0e5df621aa37879f36",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-weiss.c",
  "human_readable_source": "\n\n\n\n\n#include \"dice.h\"\n\nstruct dice_weiss_spec {\n\tunsigned int tx_pcm_chs[MAX_STREAMS][SND_DICE_RATE_MODE_COUNT];\n\tunsigned int rx_pcm_chs[MAX_STREAMS][SND_DICE_RATE_MODE_COUNT];\n};\n\n\nstatic const struct dice_weiss_spec dac202 = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec man301 = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec int202 = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec int203 = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec adc2 = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec dac2_minerva = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec vesta = {\n\t.tx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{2, 2, 2}, {0, 0, 0} },\n};\n\n\nstatic const struct dice_weiss_spec afi1 = {\n\t.tx_pcm_chs = {{24, 16, 8}, {0, 0, 0} },\n\t.rx_pcm_chs = {{24, 16, 8}, {0, 0, 0} },\n};\n\nint snd_dice_detect_weiss_formats(struct snd_dice *dice)\n{\n\tstatic const struct {\n\t\tu32 model_id;\n\t\tconst struct dice_weiss_spec *spec;\n\t} *entry, entries[] = {\n\t\t{0x000007, &dac202},\n\t\t{0x000008, &dac202}, \n\t\t{0x000006, &int202},\n\t\t{0x00000a, &int203},\n\t\t{0x00000b, &man301},\n\t\t{0x000001, &adc2},\n\t\t{0x000003, &dac2_minerva},\n\t\t{0x000002, &vesta},\n\t\t{0x000004, &afi1},\n\t};\n\tstruct fw_csr_iterator it;\n\tint key, val, model_id;\n\tint i;\n\n\tmodel_id = 0;\n\tfw_csr_iterator_init(&it, dice->unit->directory);\n\twhile (fw_csr_iterator_next(&it, &key, &val)) {\n\t\tif (key == CSR_MODEL) {\n\t\t\tmodel_id = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(entries); ++i) {\n\t\tentry = entries + i;\n\t\tif (entry->model_id == model_id)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(entries))\n\t\treturn -ENODEV;\n\n\tmemcpy(dice->tx_pcm_chs, entry->spec->tx_pcm_chs,\n\t       MAX_STREAMS * SND_DICE_RATE_MODE_COUNT * sizeof(unsigned int));\n\tmemcpy(dice->rx_pcm_chs, entry->spec->rx_pcm_chs,\n\t       MAX_STREAMS * SND_DICE_RATE_MODE_COUNT * sizeof(unsigned int));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}