{
  "module_name": "dice.c",
  "hash_id": "d8a5842d7add21fb35d9bf0e811f1ddc6fe87df113427e21930b729d1fcac712",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\nMODULE_DESCRIPTION(\"DICE driver\");\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_LICENSE(\"GPL\");\n\n#define OUI_WEISS\t\t0x001c6a\n#define OUI_LOUD\t\t0x000ff2\n#define OUI_FOCUSRITE\t\t0x00130e\n#define OUI_TCELECTRONIC\t0x000166\n#define OUI_ALESIS\t\t0x000595\n#define OUI_MAUDIO\t\t0x000d6c\n#define OUI_MYTEK\t\t0x001ee8\n#define OUI_SSL\t\t\t0x0050c2\t\n#define OUI_PRESONUS\t\t0x000a92\n#define OUI_HARMAN\t\t0x000fd7\n#define OUI_AVID\t\t0x00a07e\n\n#define DICE_CATEGORY_ID\t0x04\n#define WEISS_CATEGORY_ID\t0x00\n#define LOUD_CATEGORY_ID\t0x10\n#define HARMAN_CATEGORY_ID\t0x20\n\n#define MODEL_ALESIS_IO_BOTH\t0x000001\n\nstatic int check_dice_category(struct fw_unit *unit)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct fw_csr_iterator it;\n\tint key, val, vendor = -1, model = -1;\n\tunsigned int category;\n\n\t \n\tfw_csr_iterator_init(&it, unit->directory);\n\twhile (fw_csr_iterator_next(&it, &key, &val)) {\n\t\tswitch (key) {\n\t\tcase CSR_SPECIFIER_ID:\n\t\t\tvendor = val;\n\t\t\tbreak;\n\t\tcase CSR_MODEL:\n\t\t\tmodel = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (vendor == OUI_WEISS)\n\t\tcategory = WEISS_CATEGORY_ID;\n\telse if (vendor == OUI_LOUD)\n\t\tcategory = LOUD_CATEGORY_ID;\n\telse if (vendor == OUI_HARMAN)\n\t\tcategory = HARMAN_CATEGORY_ID;\n\telse\n\t\tcategory = DICE_CATEGORY_ID;\n\tif (device->config_rom[3] != ((vendor << 8) | category) ||\n\t    device->config_rom[4] >> 22 != model)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int check_clock_caps(struct snd_dice *dice)\n{\n\t__be32 value;\n\tint err;\n\n\t \n\tif (dice->clock_caps > 0) {\n\t\terr = snd_dice_transaction_read_global(dice,\n\t\t\t\t\t\tGLOBAL_CLOCK_CAPABILITIES,\n\t\t\t\t\t\t&value, 4);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdice->clock_caps = be32_to_cpu(value);\n\t} else {\n\t\t \n\t\tdice->clock_caps = CLOCK_CAP_RATE_44100 |\n\t\t\t\t   CLOCK_CAP_RATE_48000 |\n\t\t\t\t   CLOCK_CAP_SOURCE_ARX1 |\n\t\t\t\t   CLOCK_CAP_SOURCE_INTERNAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dice_card_strings(struct snd_dice *dice)\n{\n\tstruct snd_card *card = dice->card;\n\tstruct fw_device *dev = fw_parent_device(dice->unit);\n\tchar vendor[32], model[32];\n\tunsigned int i;\n\tint err;\n\n\tstrcpy(card->driver, \"DICE\");\n\n\tstrcpy(card->shortname, \"DICE\");\n\tBUILD_BUG_ON(NICK_NAME_SIZE < sizeof(card->shortname));\n\terr = snd_dice_transaction_read_global(dice, GLOBAL_NICK_NAME,\n\t\t\t\t\t       card->shortname,\n\t\t\t\t\t       sizeof(card->shortname));\n\tif (err >= 0) {\n\t\t \n\t\tBUILD_BUG_ON(sizeof(card->shortname) % 4 != 0);\n\t\tfor (i = 0; i < sizeof(card->shortname); i += 4)\n\t\t\tswab32s((u32 *)&card->shortname[i]);\n\t\tcard->shortname[sizeof(card->shortname) - 1] = '\\0';\n\t}\n\n\tstrcpy(vendor, \"?\");\n\tfw_csr_string(dev->config_rom + 5, CSR_VENDOR, vendor, sizeof(vendor));\n\tstrcpy(model, \"?\");\n\tfw_csr_string(dice->unit->directory, CSR_MODEL, model, sizeof(model));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s %s (serial %u) at %s, S%d\",\n\t\t vendor, model, dev->config_rom[4] & 0x3fffff,\n\t\t dev_name(&dice->unit->device), 100 << dev->max_speed);\n\n\tstrcpy(card->mixername, \"DICE\");\n}\n\nstatic void dice_card_free(struct snd_card *card)\n{\n\tstruct snd_dice *dice = card->private_data;\n\n\tsnd_dice_stream_destroy_duplex(dice);\n\tsnd_dice_transaction_destroy(dice);\n\n\tmutex_destroy(&dice->mutex);\n\tfw_unit_put(dice->unit);\n}\n\nstatic int dice_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tstruct snd_card *card;\n\tstruct snd_dice *dice;\n\tsnd_dice_detect_formats_t detect_formats;\n\tint err;\n\n\tif (!entry->driver_data && entry->vendor_id != OUI_SSL) {\n\t\terr = check_dice_category(unit);\n\t\tif (err < 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE, sizeof(*dice), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = dice_card_free;\n\n\tdice = card->private_data;\n\tdice->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, dice);\n\tdice->card = card;\n\n\tif (!entry->driver_data)\n\t\tdetect_formats = snd_dice_stream_detect_current_formats;\n\telse\n\t\tdetect_formats = (snd_dice_detect_formats_t)entry->driver_data;\n\n\t\n\t\n\t\n\t\n\t\n\tif (entry->vendor_id == OUI_MAUDIO || entry->vendor_id == OUI_AVID)\n\t\tdice->disable_double_pcm_frames = true;\n\n\tspin_lock_init(&dice->lock);\n\tmutex_init(&dice->mutex);\n\tinit_completion(&dice->clock_accepted);\n\tinit_waitqueue_head(&dice->hwdep_wait);\n\n\terr = snd_dice_transaction_init(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = check_clock_caps(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdice_card_strings(dice);\n\n\terr = detect_formats(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dice_stream_init_duplex(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_dice_create_proc(dice);\n\n\terr = snd_dice_create_pcm(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dice_create_midi(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dice_create_hwdep(dice);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void dice_remove(struct fw_unit *unit)\n{\n\tstruct snd_dice *dice = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(dice->card);\n}\n\nstatic void dice_bus_reset(struct fw_unit *unit)\n{\n\tstruct snd_dice *dice = dev_get_drvdata(&unit->device);\n\n\t \n\tsnd_dice_transaction_reinit(dice);\n\n\tmutex_lock(&dice->mutex);\n\tsnd_dice_stream_update_duplex(dice);\n\tmutex_unlock(&dice->mutex);\n}\n\n#define DICE_INTERFACE\t0x000001\n\n#define DICE_DEV_ENTRY_TYPICAL(vendor, model, data) \\\n\t{ \\\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | \\\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID | \\\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID | \\\n\t\t\t\t  IEEE1394_MATCH_VERSION, \\\n\t\t.vendor_id\t= (vendor), \\\n\t\t.model_id\t= (model), \\\n\t\t.specifier_id\t= (vendor), \\\n\t\t.version\t= DICE_INTERFACE, \\\n\t\t.driver_data = (kernel_ulong_t)(data), \\\n\t}\n\nstatic const struct ieee1394_device_id dice_id_table[] = {\n\t\n\tDICE_DEV_ENTRY_TYPICAL(OUI_AVID, 0x000004, snd_dice_detect_extension_formats),\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_MAUDIO,\n\t\t.model_id\t= 0x000010,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_extension_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_MAUDIO,\n\t\t.model_id\t= 0x000011,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_extension_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000020,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000021,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000022,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000023,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000024,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000027,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_TCELECTRONIC,\n\t\t.model_id\t= 0x000030,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_tcelectronic_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_ALESIS,\n\t\t.model_id\t= MODEL_ALESIS_IO_BOTH,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_alesis_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_ALESIS,\n\t\t.model_id\t= 0x000002,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_alesis_mastercontrol_formats,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_MYTEK,\n\t\t.model_id\t= 0x000002,\n\t\t.driver_data = (kernel_ulong_t)snd_dice_detect_mytek_formats,\n\t},\n\t\n\t\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_SSL,\n\t\t.model_id\t= 0x000070,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_PRESONUS,\n\t\t.model_id\t= 0x000008,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_presonus_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_HARMAN,\n\t\t.model_id\t= 0x000001,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_harman_formats,\n\t},\n\t\n\t\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_FOCUSRITE,\n\t\t.model_id\t= 0x0000de,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_focusrite_pro40_tcd3070_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000007,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000008,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x00000b,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000006,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x00000a,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000001,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000003,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000002,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_WEISS,\n\t\t.model_id\t= 0x000004,\n\t\t.driver_data\t= (kernel_ulong_t)snd_dice_detect_weiss_formats,\n\t},\n\t{\n\t\t.match_flags = IEEE1394_MATCH_VERSION,\n\t\t.version     = DICE_INTERFACE,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(ieee1394, dice_id_table);\n\nstatic struct fw_driver dice_driver = {\n\t.driver   = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.bus\t= &fw_bus_type,\n\t},\n\t.probe    = dice_probe,\n\t.update   = dice_bus_reset,\n\t.remove   = dice_remove,\n\t.id_table = dice_id_table,\n};\n\nstatic int __init alsa_dice_init(void)\n{\n\treturn driver_register(&dice_driver.driver);\n}\n\nstatic void __exit alsa_dice_exit(void)\n{\n\tdriver_unregister(&dice_driver.driver);\n}\n\nmodule_init(alsa_dice_init);\nmodule_exit(alsa_dice_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}