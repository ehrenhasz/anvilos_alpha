{
  "module_name": "dice-transaction.c",
  "hash_id": "578bf2b3efafe31897605c1a003d5d400a8a4c4e667a988f8ea74a88aa7fe89d",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-transaction.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\nstatic u64 get_subaddr(struct snd_dice *dice, enum snd_dice_addr_type type,\n\t\t       u64 offset)\n{\n\tswitch (type) {\n\tcase SND_DICE_ADDR_TYPE_TX:\n\t\toffset += dice->tx_offset;\n\t\tbreak;\n\tcase SND_DICE_ADDR_TYPE_RX:\n\t\toffset += dice->rx_offset;\n\t\tbreak;\n\tcase SND_DICE_ADDR_TYPE_SYNC:\n\t\toffset += dice->sync_offset;\n\t\tbreak;\n\tcase SND_DICE_ADDR_TYPE_RSRV:\n\t\toffset += dice->rsrv_offset;\n\t\tbreak;\n\tcase SND_DICE_ADDR_TYPE_GLOBAL:\n\tdefault:\n\t\toffset += dice->global_offset;\n\t\tbreak;\n\t}\n\toffset += DICE_PRIVATE_SPACE;\n\treturn offset;\n}\n\nint snd_dice_transaction_write(struct snd_dice *dice,\n\t\t\t       enum snd_dice_addr_type type,\n\t\t\t       unsigned int offset, void *buf, unsigned int len)\n{\n\treturn snd_fw_transaction(dice->unit,\n\t\t\t\t  (len == 4) ? TCODE_WRITE_QUADLET_REQUEST :\n\t\t\t\t\t       TCODE_WRITE_BLOCK_REQUEST,\n\t\t\t\t  get_subaddr(dice, type, offset), buf, len, 0);\n}\n\nint snd_dice_transaction_read(struct snd_dice *dice,\n\t\t\t      enum snd_dice_addr_type type, unsigned int offset,\n\t\t\t      void *buf, unsigned int len)\n{\n\treturn snd_fw_transaction(dice->unit,\n\t\t\t\t  (len == 4) ? TCODE_READ_QUADLET_REQUEST :\n\t\t\t\t\t       TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t  get_subaddr(dice, type, offset), buf, len, 0);\n}\n\nstatic unsigned int get_clock_info(struct snd_dice *dice, __be32 *info)\n{\n\treturn snd_dice_transaction_read_global(dice, GLOBAL_CLOCK_SELECT,\n\t\t\t\t\t\tinfo, 4);\n}\n\nint snd_dice_transaction_get_clock_source(struct snd_dice *dice,\n\t\t\t\t\t  unsigned int *source)\n{\n\t__be32 info;\n\tint err;\n\n\terr = get_clock_info(dice, &info);\n\tif (err >= 0)\n\t\t*source = be32_to_cpu(info) & CLOCK_SOURCE_MASK;\n\n\treturn err;\n}\n\nint snd_dice_transaction_get_rate(struct snd_dice *dice, unsigned int *rate)\n{\n\t__be32 info;\n\tunsigned int index;\n\tint err;\n\n\terr = get_clock_info(dice, &info);\n\tif (err < 0)\n\t\tgoto end;\n\n\tindex = (be32_to_cpu(info) & CLOCK_RATE_MASK) >> CLOCK_RATE_SHIFT;\n\tif (index >= SND_DICE_RATES_COUNT) {\n\t\terr = -ENOSYS;\n\t\tgoto end;\n\t}\n\n\t*rate = snd_dice_rates[index];\nend:\n\treturn err;\n}\n\nint snd_dice_transaction_set_enable(struct snd_dice *dice)\n{\n\t__be32 value;\n\tint err = 0;\n\n\tif (dice->global_enabled)\n\t\tgoto end;\n\n\tvalue = cpu_to_be32(1);\n\terr = snd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t get_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\n\t\t\t\t\t     GLOBAL_ENABLE),\n\t\t\t\t &value, 4,\n\t\t\t\t FW_FIXED_GENERATION | dice->owner_generation);\n\tif (err < 0)\n\t\tgoto end;\n\n\tdice->global_enabled = true;\nend:\n\treturn err;\n}\n\nvoid snd_dice_transaction_clear_enable(struct snd_dice *dice)\n{\n\t__be32 value;\n\n\tvalue = 0;\n\tsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   get_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\n\t\t\t\t       GLOBAL_ENABLE),\n\t\t\t   &value, 4, FW_QUIET |\n\t\t\t   FW_FIXED_GENERATION | dice->owner_generation);\n\n\tdice->global_enabled = false;\n}\n\nstatic void dice_notification(struct fw_card *card, struct fw_request *request,\n\t\t\t      int tcode, int destination, int source,\n\t\t\t      int generation, unsigned long long offset,\n\t\t\t      void *data, size_t length, void *callback_data)\n{\n\tstruct snd_dice *dice = callback_data;\n\tu32 bits;\n\tunsigned long flags;\n\n\tif (tcode != TCODE_WRITE_QUADLET_REQUEST) {\n\t\tfw_send_response(card, request, RCODE_TYPE_ERROR);\n\t\treturn;\n\t}\n\tif ((offset & 3) != 0) {\n\t\tfw_send_response(card, request, RCODE_ADDRESS_ERROR);\n\t\treturn;\n\t}\n\n\tbits = be32_to_cpup(data);\n\n\tspin_lock_irqsave(&dice->lock, flags);\n\tdice->notification_bits |= bits;\n\tspin_unlock_irqrestore(&dice->lock, flags);\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n\n\tif (bits & NOTIFY_CLOCK_ACCEPTED)\n\t\tcomplete(&dice->clock_accepted);\n\twake_up(&dice->hwdep_wait);\n}\n\nstatic int register_notification_address(struct snd_dice *dice, bool retry)\n{\n\tstruct fw_device *device = fw_parent_device(dice->unit);\n\t__be64 *buffer;\n\tunsigned int retries;\n\tint err;\n\n\tretries = (retry) ? 3 : 0;\n\n\tbuffer = kmalloc(2 * 8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tbuffer[0] = cpu_to_be64(OWNER_NO_OWNER);\n\t\tbuffer[1] = cpu_to_be64(\n\t\t\t((u64)device->card->node_id << OWNER_NODE_SHIFT) |\n\t\t\tdice->notification_handler.offset);\n\n\t\tdice->owner_generation = device->generation;\n\t\tsmp_rmb();  \n\t\terr = snd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t\t\t get_subaddr(dice,\n\t\t\t\t\t\t     SND_DICE_ADDR_TYPE_GLOBAL,\n\t\t\t\t\t\t     GLOBAL_OWNER),\n\t\t\t\t\t buffer, 2 * 8,\n\t\t\t\t\t FW_FIXED_GENERATION |\n\t\t\t\t\t\t\tdice->owner_generation);\n\t\tif (err == 0) {\n\t\t\t \n\t\t\tif (buffer[0] == cpu_to_be64(OWNER_NO_OWNER))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (buffer[0] == buffer[1])\n\t\t\t\tbreak;\n\n\t\t\tdev_err(&dice->unit->device,\n\t\t\t\t\"device is already in use\\n\");\n\t\t\terr = -EBUSY;\n\t\t}\n\t\tif (err != -EAGAIN || retries-- > 0)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t}\n\n\tkfree(buffer);\n\n\tif (err < 0)\n\t\tdice->owner_generation = -1;\n\n\treturn err;\n}\n\nstatic void unregister_notification_address(struct snd_dice *dice)\n{\n\tstruct fw_device *device = fw_parent_device(dice->unit);\n\t__be64 *buffer;\n\n\tbuffer = kmalloc(2 * 8, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[0] = cpu_to_be64(\n\t\t((u64)device->card->node_id << OWNER_NODE_SHIFT) |\n\t\tdice->notification_handler.offset);\n\tbuffer[1] = cpu_to_be64(OWNER_NO_OWNER);\n\tsnd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t   get_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\n\t\t\t\t       GLOBAL_OWNER),\n\t\t\t   buffer, 2 * 8, FW_QUIET |\n\t\t\t   FW_FIXED_GENERATION | dice->owner_generation);\n\n\tkfree(buffer);\n\n\tdice->owner_generation = -1;\n}\n\nvoid snd_dice_transaction_destroy(struct snd_dice *dice)\n{\n\tstruct fw_address_handler *handler = &dice->notification_handler;\n\n\tif (handler->callback_data == NULL)\n\t\treturn;\n\n\tunregister_notification_address(dice);\n\n\tfw_core_remove_address_handler(handler);\n\thandler->callback_data = NULL;\n}\n\nint snd_dice_transaction_reinit(struct snd_dice *dice)\n{\n\tstruct fw_address_handler *handler = &dice->notification_handler;\n\n\tif (handler->callback_data == NULL)\n\t\treturn -EINVAL;\n\n\treturn register_notification_address(dice, false);\n}\n\nstatic int get_subaddrs(struct snd_dice *dice)\n{\n\tstatic const int min_values[10] = {\n\t\t10, 0x60 / 4,\n\t\t10, 0x18 / 4,\n\t\t10, 0x18 / 4,\n\t\t0, 0,\n\t\t0, 0,\n\t};\n\t__be32 *pointers;\n\t__be32 version;\n\tu32 data;\n\tunsigned int i;\n\tint err;\n\n\tpointers = kmalloc_array(ARRAY_SIZE(min_values), sizeof(__be32),\n\t\t\t\t GFP_KERNEL);\n\tif (pointers == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\terr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t DICE_PRIVATE_SPACE, pointers,\n\t\t\t\t sizeof(__be32) * ARRAY_SIZE(min_values), 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\tfor (i = 0; i < ARRAY_SIZE(min_values); ++i) {\n\t\tdata = be32_to_cpu(pointers[i]);\n\t\tif (data < min_values[i] || data >= 0x40000) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (be32_to_cpu(pointers[1]) > 0x18) {\n\t\t \n\t\terr = snd_fw_transaction(dice->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\tDICE_PRIVATE_SPACE +\n\t\t\t\tbe32_to_cpu(pointers[0]) * 4 + GLOBAL_VERSION,\n\t\t\t\t&version, sizeof(version), 0);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\n\t\tif ((version & cpu_to_be32(0xff000000)) !=\n\t\t\t\t\t\tcpu_to_be32(0x01000000)) {\n\t\t\tdev_err(&dice->unit->device,\n\t\t\t\t\"unknown DICE version: 0x%08x\\n\",\n\t\t\t\tbe32_to_cpu(version));\n\t\t\terr = -ENODEV;\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\tdice->clock_caps = 1;\n\t}\n\n\tdice->global_offset = be32_to_cpu(pointers[0]) * 4;\n\tdice->tx_offset = be32_to_cpu(pointers[2]) * 4;\n\tdice->rx_offset = be32_to_cpu(pointers[4]) * 4;\n\n\t \n\tif (pointers[7])\n\t\tdice->sync_offset = be32_to_cpu(pointers[6]) * 4;\n\tif (pointers[9])\n\t\tdice->rsrv_offset = be32_to_cpu(pointers[8]) * 4;\nend:\n\tkfree(pointers);\n\treturn err;\n}\n\nint snd_dice_transaction_init(struct snd_dice *dice)\n{\n\tstruct fw_address_handler *handler = &dice->notification_handler;\n\tint err;\n\n\terr = get_subaddrs(dice);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\thandler->length = 4;\n\thandler->address_callback = dice_notification;\n\thandler->callback_data = dice;\n\terr = fw_core_add_address_handler(handler, &fw_high_memory_region);\n\tif (err < 0) {\n\t\thandler->callback_data = NULL;\n\t\treturn err;\n\t}\n\n\t \n\terr = register_notification_address(dice, true);\n\tif (err < 0) {\n\t\tfw_core_remove_address_handler(handler);\n\t\thandler->callback_data = NULL;\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}