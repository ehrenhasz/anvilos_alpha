{
  "module_name": "dice-tcelectronic.c",
  "hash_id": "2412db289d6c40ca44eb66f2dfaa9c95f0e1bdc4927d743b86689a050b9041cd",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/dice/dice-tcelectronic.c",
  "human_readable_source": "\n \n\n#include \"dice.h\"\n\nstruct dice_tc_spec {\n\tunsigned int tx_pcm_chs[MAX_STREAMS][SND_DICE_RATE_MODE_COUNT];\n\tunsigned int rx_pcm_chs[MAX_STREAMS][SND_DICE_RATE_MODE_COUNT];\n\tbool has_midi;\n};\n\nstatic const struct dice_tc_spec desktop_konnekt6 = {\n\t.tx_pcm_chs = {{6, 6, 2}, {0, 0, 0} },\n\t.rx_pcm_chs = {{6, 6, 4}, {0, 0, 0} },\n\t.has_midi = false,\n};\n\nstatic const struct dice_tc_spec impact_twin = {\n\t.tx_pcm_chs = {{14, 10, 6}, {0, 0, 0} },\n\t.rx_pcm_chs = {{14, 10, 6}, {0, 0, 0} },\n\t.has_midi = true,\n};\n\nstatic const struct dice_tc_spec konnekt_8 = {\n\t.tx_pcm_chs = {{4, 4, 3}, {0, 0, 0} },\n\t.rx_pcm_chs = {{4, 4, 3}, {0, 0, 0} },\n\t.has_midi = true,\n};\n\nstatic const struct dice_tc_spec konnekt_24d = {\n\t.tx_pcm_chs = {{16, 16, 6}, {0, 0, 0} },\n\t.rx_pcm_chs = {{16, 16, 6}, {0, 0, 0} },\n\t.has_midi = true,\n};\n\nstatic const struct dice_tc_spec konnekt_live = {\n\t.tx_pcm_chs = {{16, 16, 6}, {0, 0, 0} },\n\t.rx_pcm_chs = {{16, 16, 6}, {0, 0, 0} },\n\t.has_midi = true,\n};\n\nstatic const struct dice_tc_spec studio_konnekt_48 = {\n\t.tx_pcm_chs = {{16, 16, 8}, {16, 16, 7} },\n\t.rx_pcm_chs = {{16, 16, 8}, {14, 14, 7} },\n\t.has_midi = true,\n};\n\nstatic const struct dice_tc_spec digital_konnekt_x32 = {\n\t.tx_pcm_chs = {{16, 16, 4}, {0, 0, 0} },\n\t.rx_pcm_chs = {{16, 16, 4}, {0, 0, 0} },\n\t.has_midi = false,\n};\n\nint snd_dice_detect_tcelectronic_formats(struct snd_dice *dice)\n{\n\tstatic const struct {\n\t\tu32 model_id;\n\t\tconst struct dice_tc_spec *spec;\n\t} *entry, entries[] = {\n\t\t{0x00000020, &konnekt_24d},\n\t\t{0x00000021, &konnekt_8},\n\t\t{0x00000022, &studio_konnekt_48},\n\t\t{0x00000023, &konnekt_live},\n\t\t{0x00000024, &desktop_konnekt6},\n\t\t{0x00000027, &impact_twin},\n\t\t{0x00000030, &digital_konnekt_x32},\n\t};\n\tstruct fw_csr_iterator it;\n\tint key, val, model_id;\n\tint i;\n\n\tmodel_id = 0;\n\tfw_csr_iterator_init(&it, dice->unit->directory);\n\twhile (fw_csr_iterator_next(&it, &key, &val)) {\n\t\tif (key == CSR_MODEL) {\n\t\t\tmodel_id = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(entries); ++i) {\n\t\tentry = entries + i;\n\t\tif (entry->model_id == model_id)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(entries))\n\t\treturn -ENODEV;\n\n\tmemcpy(dice->tx_pcm_chs, entry->spec->tx_pcm_chs,\n\t       MAX_STREAMS * SND_DICE_RATE_MODE_COUNT * sizeof(unsigned int));\n\tmemcpy(dice->rx_pcm_chs, entry->spec->rx_pcm_chs,\n\t       MAX_STREAMS * SND_DICE_RATE_MODE_COUNT * sizeof(unsigned int));\n\n\tif (entry->spec->has_midi) {\n\t\tdice->tx_midi_ports[0] = 1;\n\t\tdice->rx_midi_ports[0] = 1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}