{
  "module_name": "fireworks_transaction.c",
  "hash_id": "45cff7d48fe307efd9235bbdb8e37819440c09528d1c4365a17827e64e113f50",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_transaction.c",
  "human_readable_source": "\n \n\n \n#include \"./fireworks.h\"\n\n#define MEMORY_SPACE_EFW_COMMAND\t0xecc000000000ULL\n#define MEMORY_SPACE_EFW_RESPONSE\t0xecc080000000ULL\n\n#define ERROR_RETRIES 3\n#define ERROR_DELAY_MS 5\n#define EFC_TIMEOUT_MS 125\n\nstatic DEFINE_SPINLOCK(instances_lock);\nstatic struct snd_efw *instances[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;\n\nstatic DEFINE_SPINLOCK(transaction_queues_lock);\nstatic LIST_HEAD(transaction_queues);\n\nenum transaction_queue_state {\n\tSTATE_PENDING,\n\tSTATE_BUS_RESET,\n\tSTATE_COMPLETE\n};\n\nstruct transaction_queue {\n\tstruct list_head list;\n\tstruct fw_unit *unit;\n\tvoid *buf;\n\tunsigned int size;\n\tu32 seqnum;\n\tenum transaction_queue_state state;\n\twait_queue_head_t wait;\n};\n\nint snd_efw_transaction_cmd(struct fw_unit *unit,\n\t\t\t    const void *cmd, unsigned int size)\n{\n\treturn snd_fw_transaction(unit, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\t\t  MEMORY_SPACE_EFW_COMMAND,\n\t\t\t\t  (void *)cmd, size, 0);\n}\n\nint snd_efw_transaction_run(struct fw_unit *unit,\n\t\t\t    const void *cmd, unsigned int cmd_size,\n\t\t\t    void *resp, unsigned int resp_size)\n{\n\tstruct transaction_queue t;\n\tunsigned int tries;\n\tint ret;\n\n\tt.unit = unit;\n\tt.buf = resp;\n\tt.size = resp_size;\n\tt.seqnum = be32_to_cpu(((struct snd_efw_transaction *)cmd)->seqnum) + 1;\n\tt.state = STATE_PENDING;\n\tinit_waitqueue_head(&t.wait);\n\n\tspin_lock_irq(&transaction_queues_lock);\n\tlist_add_tail(&t.list, &transaction_queues);\n\tspin_unlock_irq(&transaction_queues_lock);\n\n\ttries = 0;\n\tdo {\n\t\tret = snd_efw_transaction_cmd(t.unit, (void *)cmd, cmd_size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\twait_event_timeout(t.wait, t.state != STATE_PENDING,\n\t\t\t\t   msecs_to_jiffies(EFC_TIMEOUT_MS));\n\n\t\tif (t.state == STATE_COMPLETE) {\n\t\t\tret = t.size;\n\t\t\tbreak;\n\t\t} else if (t.state == STATE_BUS_RESET) {\n\t\t\tmsleep(ERROR_DELAY_MS);\n\t\t} else if (++tries >= ERROR_RETRIES) {\n\t\t\tdev_err(&t.unit->device, \"EFW transaction timed out\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tspin_lock_irq(&transaction_queues_lock);\n\tlist_del(&t.list);\n\tspin_unlock_irq(&transaction_queues_lock);\n\n\treturn ret;\n}\n\nstatic void\ncopy_resp_to_buf(struct snd_efw *efw, void *data, size_t length, int *rcode)\n{\n\tsize_t capacity, till_end;\n\tstruct snd_efw_transaction *t;\n\n\tt = (struct snd_efw_transaction *)data;\n\tlength = min_t(size_t, be32_to_cpu(t->length) * sizeof(u32), length);\n\n\tspin_lock(&efw->lock);\n\n\tif (efw->push_ptr < efw->pull_ptr)\n\t\tcapacity = (unsigned int)(efw->pull_ptr - efw->push_ptr);\n\telse\n\t\tcapacity = snd_efw_resp_buf_size -\n\t\t\t   (unsigned int)(efw->push_ptr - efw->pull_ptr);\n\n\t \n\tif (capacity < length) {\n\t\t*rcode = RCODE_CONFLICT_ERROR;\n\t\tgoto end;\n\t}\n\n\t \n\twhile (length > 0) {\n\t\ttill_end = snd_efw_resp_buf_size -\n\t\t\t   (unsigned int)(efw->push_ptr - efw->resp_buf);\n\t\ttill_end = min_t(unsigned int, length, till_end);\n\n\t\tmemcpy(efw->push_ptr, data, till_end);\n\n\t\tefw->push_ptr += till_end;\n\t\tif (efw->push_ptr >= efw->resp_buf + snd_efw_resp_buf_size)\n\t\t\tefw->push_ptr -= snd_efw_resp_buf_size;\n\n\t\tlength -= till_end;\n\t\tdata += till_end;\n\t}\n\n\t \n\twake_up(&efw->hwdep_wait);\n\n\t*rcode = RCODE_COMPLETE;\nend:\n\tspin_unlock_irq(&efw->lock);\n}\n\nstatic void\nhandle_resp_for_user(struct fw_card *card, int generation, int source,\n\t\t     void *data, size_t length, int *rcode)\n{\n\tstruct fw_device *device;\n\tstruct snd_efw *efw;\n\tunsigned int i;\n\n\tspin_lock_irq(&instances_lock);\n\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tefw = instances[i];\n\t\tif (efw == NULL)\n\t\t\tcontinue;\n\t\tdevice = fw_parent_device(efw->unit);\n\t\tif ((device->card != card) ||\n\t\t    (device->generation != generation))\n\t\t\tcontinue;\n\t\tsmp_rmb();\t \n\t\tif (device->node_id != source)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\tif (i == SNDRV_CARDS)\n\t\tgoto end;\n\n\tcopy_resp_to_buf(efw, data, length, rcode);\nend:\n\tspin_unlock(&instances_lock);\n}\n\nstatic void\nhandle_resp_for_kernel(struct fw_card *card, int generation, int source,\n\t\t       void *data, size_t length, int *rcode, u32 seqnum)\n{\n\tstruct fw_device *device;\n\tstruct transaction_queue *t;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&transaction_queues_lock, flags);\n\tlist_for_each_entry(t, &transaction_queues, list) {\n\t\tdevice = fw_parent_device(t->unit);\n\t\tif ((device->card != card) ||\n\t\t    (device->generation != generation))\n\t\t\tcontinue;\n\t\tsmp_rmb();\t \n\t\tif (device->node_id != source)\n\t\t\tcontinue;\n\n\t\tif ((t->state == STATE_PENDING) && (t->seqnum == seqnum)) {\n\t\t\tt->state = STATE_COMPLETE;\n\t\t\tt->size = min_t(unsigned int, length, t->size);\n\t\t\tmemcpy(t->buf, data, t->size);\n\t\t\twake_up(&t->wait);\n\t\t\t*rcode = RCODE_COMPLETE;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&transaction_queues_lock, flags);\n}\n\nstatic void\nefw_response(struct fw_card *card, struct fw_request *request,\n\t     int tcode, int destination, int source,\n\t     int generation, unsigned long long offset,\n\t     void *data, size_t length, void *callback_data)\n{\n\tint rcode, dummy;\n\tu32 seqnum;\n\n\trcode = RCODE_TYPE_ERROR;\n\tif (length < sizeof(struct snd_efw_transaction)) {\n\t\trcode = RCODE_DATA_ERROR;\n\t\tgoto end;\n\t} else if (offset != MEMORY_SPACE_EFW_RESPONSE) {\n\t\trcode = RCODE_ADDRESS_ERROR;\n\t\tgoto end;\n\t}\n\n\tseqnum = be32_to_cpu(((struct snd_efw_transaction *)data)->seqnum);\n\tif (seqnum > SND_EFW_TRANSACTION_USER_SEQNUM_MAX + 1) {\n\t\thandle_resp_for_kernel(card, generation, source,\n\t\t\t\t       data, length, &rcode, seqnum);\n\t\tif (snd_efw_resp_buf_debug)\n\t\t\thandle_resp_for_user(card, generation, source,\n\t\t\t\t\t     data, length, &dummy);\n\t} else {\n\t\thandle_resp_for_user(card, generation, source,\n\t\t\t\t     data, length, &rcode);\n\t}\nend:\n\tfw_send_response(card, request, rcode);\n}\n\nvoid snd_efw_transaction_add_instance(struct snd_efw *efw)\n{\n\tunsigned int i;\n\n\tspin_lock_irq(&instances_lock);\n\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (instances[i] != NULL)\n\t\t\tcontinue;\n\t\tinstances[i] = efw;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&instances_lock);\n}\n\nvoid snd_efw_transaction_remove_instance(struct snd_efw *efw)\n{\n\tunsigned int i;\n\n\tspin_lock_irq(&instances_lock);\n\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (instances[i] != efw)\n\t\t\tcontinue;\n\t\tinstances[i] = NULL;\n\t}\n\n\tspin_unlock_irq(&instances_lock);\n}\n\nvoid snd_efw_transaction_bus_reset(struct fw_unit *unit)\n{\n\tstruct transaction_queue *t;\n\n\tspin_lock_irq(&transaction_queues_lock);\n\tlist_for_each_entry(t, &transaction_queues, list) {\n\t\tif ((t->unit == unit) &&\n\t\t    (t->state == STATE_PENDING)) {\n\t\t\tt->state = STATE_BUS_RESET;\n\t\t\twake_up(&t->wait);\n\t\t}\n\t}\n\tspin_unlock_irq(&transaction_queues_lock);\n}\n\nstatic struct fw_address_handler resp_register_handler = {\n\t.length = SND_EFW_RESPONSE_MAXIMUM_BYTES,\n\t.address_callback = efw_response\n};\n\nint snd_efw_transaction_register(void)\n{\n\tstatic const struct fw_address_region resp_register_region = {\n\t\t.start\t= MEMORY_SPACE_EFW_RESPONSE,\n\t\t.end\t= MEMORY_SPACE_EFW_RESPONSE +\n\t\t\t  SND_EFW_RESPONSE_MAXIMUM_BYTES\n\t};\n\treturn fw_core_add_address_handler(&resp_register_handler,\n\t\t\t\t\t   &resp_register_region);\n}\n\nvoid snd_efw_transaction_unregister(void)\n{\n\tWARN_ON(!list_empty(&transaction_queues));\n\tfw_core_remove_address_handler(&resp_register_handler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}