{
  "module_name": "fireworks.c",
  "hash_id": "54dbaf1581e95da156d21aa21daad7b14e6a2ad0d20eca403cbc72f0e5ce480b",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks.c",
  "human_readable_source": "\n \n\n \n\n#include \"fireworks.h\"\n\nMODULE_DESCRIPTION(\"Echo Fireworks driver\");\nMODULE_AUTHOR(\"Takashi Sakamoto <o-takashi@sakamocchi.jp>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS]\t= SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS]\t= SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS]\t= SNDRV_DEFAULT_ENABLE_PNP;\nunsigned int snd_efw_resp_buf_size\t= 1024;\nbool snd_efw_resp_buf_debug\t\t= false;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"card index\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"enable Fireworks sound card\");\nmodule_param_named(resp_buf_size, snd_efw_resp_buf_size, uint, 0444);\nMODULE_PARM_DESC(resp_buf_size,\n\t\t \"response buffer size (max 4096, default 1024)\");\nmodule_param_named(resp_buf_debug, snd_efw_resp_buf_debug, bool, 0444);\nMODULE_PARM_DESC(resp_buf_debug, \"store all responses to buffer\");\n\nstatic DEFINE_MUTEX(devices_mutex);\nstatic DECLARE_BITMAP(devices_used, SNDRV_CARDS);\n\n#define VENDOR_LOUD\t\t\t0x000ff2\n#define  MODEL_MACKIE_400F\t\t0x00400f\n#define  MODEL_MACKIE_1200F\t\t0x01200f\n\n#define VENDOR_ECHO\t\t\t0x001486\n#define  MODEL_ECHO_AUDIOFIRE_12\t0x00af12\n#define  MODEL_ECHO_AUDIOFIRE_12HD\t0x0af12d\n#define  MODEL_ECHO_AUDIOFIRE_12_APPLE\t0x0af12a\n \n#define  MODEL_ECHO_AUDIOFIRE_8\t\t0x000af8\n#define  MODEL_ECHO_AUDIOFIRE_2\t\t0x000af2\n#define  MODEL_ECHO_AUDIOFIRE_4\t\t0x000af4\n \n#define  MODEL_ECHO_AUDIOFIRE_9\t\t0x000af9\n \n#define  MODEL_ECHO_FIREWORKS_8\t\t0x0000f8\n#define  MODEL_ECHO_FIREWORKS_HDMI\t0x00afd1\n\n#define VENDOR_GIBSON\t\t\t0x00075b\n \n#define  MODEL_GIBSON_RIP\t\t0x00afb2\n \n#define  MODEL_GIBSON_GOLDTOP\t\t0x00afb9\n\n \n#define FLAG_RESP_ADDR_CHANGABLE\t0\n\nstatic int\nget_hardware_info(struct snd_efw *efw)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(efw->unit);\n\tstruct snd_efw_hwinfo *hwinfo;\n\tchar version[12] = {0};\n\tint err;\n\n\thwinfo = kzalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);\n\tif (hwinfo == NULL)\n\t\treturn -ENOMEM;\n\n\terr = snd_efw_command_get_hwinfo(efw, hwinfo);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tsnprintf(version, sizeof(version), \"%u.%u\",\n\t\t (hwinfo->arm_version >> 24) & 0xff,\n\t\t (hwinfo->arm_version >> 16) & 0xff);\n\tefw->firmware_version = hwinfo->arm_version;\n\n\tstrcpy(efw->card->driver, \"Fireworks\");\n\tstrcpy(efw->card->shortname, hwinfo->model_name);\n\tstrcpy(efw->card->mixername, hwinfo->model_name);\n\tscnprintf(efw->card->longname, sizeof(efw->card->longname),\n\t\t  \"%s %s v%s, GUID %08x%08x at %s, S%d\",\n\t\t  hwinfo->vendor_name, hwinfo->model_name, version,\n\t\t  hwinfo->guid_hi, hwinfo->guid_lo,\n\t\t  dev_name(&efw->unit->device), 100 << fw_dev->max_speed);\n\n\tif (hwinfo->flags & BIT(FLAG_RESP_ADDR_CHANGABLE))\n\t\tefw->resp_addr_changable = true;\n\n\tefw->supported_sampling_rate = 0;\n\tif ((hwinfo->min_sample_rate <= 22050)\n\t && (22050 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_22050;\n\tif ((hwinfo->min_sample_rate <= 32000)\n\t && (32000 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_32000;\n\tif ((hwinfo->min_sample_rate <= 44100)\n\t && (44100 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_44100;\n\tif ((hwinfo->min_sample_rate <= 48000)\n\t && (48000 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_48000;\n\tif ((hwinfo->min_sample_rate <= 88200)\n\t && (88200 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_88200;\n\tif ((hwinfo->min_sample_rate <= 96000)\n\t && (96000 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_96000;\n\tif ((hwinfo->min_sample_rate <= 176400)\n\t && (176400 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_176400;\n\tif ((hwinfo->min_sample_rate <= 192000)\n\t && (192000 <= hwinfo->max_sample_rate))\n\t\tefw->supported_sampling_rate |= SNDRV_PCM_RATE_192000;\n\n\t \n\tif (hwinfo->midi_out_ports > SND_EFW_MAX_MIDI_OUT_PORTS ||\n\t    hwinfo->midi_in_ports > SND_EFW_MAX_MIDI_IN_PORTS) {\n\t\terr = -EIO;\n\t\tgoto end;\n\t}\n\tefw->midi_out_ports = hwinfo->midi_out_ports;\n\tefw->midi_in_ports = hwinfo->midi_in_ports;\n\n\tif (hwinfo->amdtp_tx_pcm_channels    > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    hwinfo->amdtp_tx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    hwinfo->amdtp_tx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    hwinfo->amdtp_rx_pcm_channels    > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    hwinfo->amdtp_rx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||\n\t    hwinfo->amdtp_rx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM) {\n\t\terr = -ENOSYS;\n\t\tgoto end;\n\t}\n\tefw->pcm_capture_channels[0] = hwinfo->amdtp_tx_pcm_channels;\n\tefw->pcm_capture_channels[1] = hwinfo->amdtp_tx_pcm_channels_2x;\n\tefw->pcm_capture_channels[2] = hwinfo->amdtp_tx_pcm_channels_4x;\n\tefw->pcm_playback_channels[0] = hwinfo->amdtp_rx_pcm_channels;\n\tefw->pcm_playback_channels[1] = hwinfo->amdtp_rx_pcm_channels_2x;\n\tefw->pcm_playback_channels[2] = hwinfo->amdtp_rx_pcm_channels_4x;\n\n\t \n\tif (hwinfo->phys_in_grp_count  > HWINFO_MAX_CAPS_GROUPS ||\n\t    hwinfo->phys_out_grp_count > HWINFO_MAX_CAPS_GROUPS) {\n\t\terr = -EIO;\n\t\tgoto end;\n\t}\n\tefw->phys_in = hwinfo->phys_in;\n\tefw->phys_out = hwinfo->phys_out;\n\tefw->phys_in_grp_count = hwinfo->phys_in_grp_count;\n\tefw->phys_out_grp_count = hwinfo->phys_out_grp_count;\n\tmemcpy(&efw->phys_in_grps, hwinfo->phys_in_grps,\n\t       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_in_grp_count);\n\tmemcpy(&efw->phys_out_grps, hwinfo->phys_out_grps,\n\t       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_out_grp_count);\n\n\t \n\tif (hwinfo->type == MODEL_ECHO_AUDIOFIRE_9)\n\t\tefw->is_af9 = true;\n\t \n\tif (hwinfo->type == MODEL_ECHO_AUDIOFIRE_2 ||\n\t    hwinfo->type == MODEL_ECHO_AUDIOFIRE_4 ||\n\t    hwinfo->type == MODEL_ECHO_AUDIOFIRE_9 ||\n\t    hwinfo->type == MODEL_GIBSON_RIP ||\n\t    hwinfo->type == MODEL_GIBSON_GOLDTOP)\n\t\tefw->is_fireworks3 = true;\nend:\n\tkfree(hwinfo);\n\treturn err;\n}\n\nstatic void\nefw_card_free(struct snd_card *card)\n{\n\tstruct snd_efw *efw = card->private_data;\n\n\tmutex_lock(&devices_mutex);\n\tclear_bit(efw->card_index, devices_used);\n\tmutex_unlock(&devices_mutex);\n\n\tsnd_efw_stream_destroy_duplex(efw);\n\tsnd_efw_transaction_remove_instance(efw);\n\n\tmutex_destroy(&efw->mutex);\n\tfw_unit_put(efw->unit);\n}\n\nstatic int efw_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tunsigned int card_index;\n\tstruct snd_card *card;\n\tstruct snd_efw *efw;\n\tint err;\n\n\t\n\tmutex_lock(&devices_mutex);\n\tfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index) {\n\t\tif (!test_bit(card_index, devices_used) && enable[card_index])\n\t\t\tbreak;\n\t}\n\tif (card_index >= SNDRV_CARDS) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&unit->device, index[card_index], id[card_index], THIS_MODULE,\n\t\t\t   sizeof(*efw), &card);\n\tif (err < 0) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\tcard->private_free = efw_card_free;\n\tset_bit(card_index, devices_used);\n\tmutex_unlock(&devices_mutex);\n\n\tefw = card->private_data;\n\tefw->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, efw);\n\tefw->card = card;\n\tefw->card_index = card_index;\n\n\tmutex_init(&efw->mutex);\n\tspin_lock_init(&efw->lock);\n\tinit_waitqueue_head(&efw->hwdep_wait);\n\n\t\n\tsnd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size, SND_EFW_RESPONSE_MAXIMUM_BYTES, 4096U);\n\tefw->resp_buf = devm_kzalloc(&card->card_dev, snd_efw_resp_buf_size, GFP_KERNEL);\n\tif (!efw->resp_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tefw->pull_ptr = efw->push_ptr = efw->resp_buf;\n\tsnd_efw_transaction_add_instance(efw);\n\n\terr = get_hardware_info(efw);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_efw_stream_init_duplex(efw);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_efw_proc_init(efw);\n\n\tif (efw->midi_out_ports || efw->midi_in_ports) {\n\t\terr = snd_efw_create_midi_devices(efw);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\terr = snd_efw_create_pcm_devices(efw);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_efw_create_hwdep_device(efw);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void efw_update(struct fw_unit *unit)\n{\n\tstruct snd_efw *efw = dev_get_drvdata(&unit->device);\n\n\tsnd_efw_transaction_bus_reset(efw->unit);\n\n\tmutex_lock(&efw->mutex);\n\tsnd_efw_stream_update_duplex(efw);\n\tmutex_unlock(&efw->mutex);\n}\n\nstatic void efw_remove(struct fw_unit *unit)\n{\n\tstruct snd_efw *efw = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(efw->card);\n}\n\n#define SPECIFIER_1394TA\t0x00a02d\n#define VERSION_EFW\t\t0x010000\n\n#define SND_EFW_DEV_ENTRY(vendor, model) \\\n{ \\\n\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID | \\\n\t\t\t  IEEE1394_MATCH_MODEL_ID | \\\n\t\t\t  IEEE1394_MATCH_SPECIFIER_ID | \\\n\t\t\t  IEEE1394_MATCH_VERSION, \\\n\t.vendor_id\t= vendor,\\\n\t.model_id\t= model, \\\n\t.specifier_id\t= SPECIFIER_1394TA, \\\n\t.version\t= VERSION_EFW, \\\n}\n\nstatic const struct ieee1394_device_id efw_id_table[] = {\n\tSND_EFW_DEV_ENTRY(VENDOR_LOUD, MODEL_MACKIE_400F),\n\tSND_EFW_DEV_ENTRY(VENDOR_LOUD, MODEL_MACKIE_1200F),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_8),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12HD),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12_APPLE),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_2),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_4),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_9),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_FIREWORKS_8),\n\tSND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_FIREWORKS_HDMI),\n\tSND_EFW_DEV_ENTRY(VENDOR_GIBSON, MODEL_GIBSON_RIP),\n\tSND_EFW_DEV_ENTRY(VENDOR_GIBSON, MODEL_GIBSON_GOLDTOP),\n\t{}\n};\nMODULE_DEVICE_TABLE(ieee1394, efw_id_table);\n\nstatic struct fw_driver efw_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = KBUILD_MODNAME,\n\t\t.bus = &fw_bus_type,\n\t},\n\t.probe    = efw_probe,\n\t.update   = efw_update,\n\t.remove   = efw_remove,\n\t.id_table = efw_id_table,\n};\n\nstatic int __init snd_efw_init(void)\n{\n\tint err;\n\n\terr = snd_efw_transaction_register();\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = driver_register(&efw_driver.driver);\n\tif (err < 0)\n\t\tsnd_efw_transaction_unregister();\n\nend:\n\treturn err;\n}\n\nstatic void __exit snd_efw_exit(void)\n{\n\tsnd_efw_transaction_unregister();\n\tdriver_unregister(&efw_driver.driver);\n}\n\nmodule_init(snd_efw_init);\nmodule_exit(snd_efw_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}