{
  "module_name": "fireworks_hwdep.c",
  "hash_id": "03de577a30f99421bcb1623c4c6a81babf75785fe3d20c4df3a96328eee4b12e",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_hwdep.c",
  "human_readable_source": "\n \n\n \n\n#include \"fireworks.h\"\n\nstatic long\nhwdep_read_resp_buf(struct snd_efw *efw, char __user *buf, long remained,\n\t\t    loff_t *offset)\n{\n\tunsigned int length, till_end, type;\n\tstruct snd_efw_transaction *t;\n\tu8 *pull_ptr;\n\tlong count = 0;\n\n\tif (remained < sizeof(type) + sizeof(struct snd_efw_transaction))\n\t\treturn -ENOSPC;\n\n\t \n\ttype = SNDRV_FIREWIRE_EVENT_EFW_RESPONSE;\n\tif (copy_to_user(buf, &type, sizeof(type)))\n\t\treturn -EFAULT;\n\tcount += sizeof(type);\n\tremained -= sizeof(type);\n\tbuf += sizeof(type);\n\n\t \n\tspin_lock_irq(&efw->lock);\n\n\t \n\tpull_ptr = efw->pull_ptr;\n\n\twhile (efw->push_ptr != pull_ptr) {\n\t\tt = (struct snd_efw_transaction *)(pull_ptr);\n\t\tlength = be32_to_cpu(t->length) * sizeof(__be32);\n\n\t\t \n\t\tif (remained < length)\n\t\t\tbreak;\n\n\t\t \n\t\twhile (length > 0) {\n\t\t\ttill_end = snd_efw_resp_buf_size -\n\t\t\t\t(unsigned int)(pull_ptr - efw->resp_buf);\n\t\t\ttill_end = min_t(unsigned int, length, till_end);\n\n\t\t\tspin_unlock_irq(&efw->lock);\n\n\t\t\tif (copy_to_user(buf, pull_ptr, till_end))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tspin_lock_irq(&efw->lock);\n\n\t\t\tpull_ptr += till_end;\n\t\t\tif (pull_ptr >= efw->resp_buf + snd_efw_resp_buf_size)\n\t\t\t\tpull_ptr -= snd_efw_resp_buf_size;\n\n\t\t\tlength -= till_end;\n\t\t\tbuf += till_end;\n\t\t\tcount += till_end;\n\t\t\tremained -= till_end;\n\t\t}\n\t}\n\n\t \n\tefw->pull_ptr = pull_ptr;\n\n\tspin_unlock_irq(&efw->lock);\n\n\treturn count;\n}\n\nstatic long\nhwdep_read_locked(struct snd_efw *efw, char __user *buf, long count,\n\t\t  loff_t *offset)\n{\n\tunion snd_firewire_event event = {\n\t\t.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS,\n\t};\n\n\tspin_lock_irq(&efw->lock);\n\n\tevent.lock_status.status = (efw->dev_lock_count > 0);\n\tefw->dev_lock_changed = false;\n\n\tspin_unlock_irq(&efw->lock);\n\n\tcount = min_t(long, count, sizeof(event.lock_status));\n\n\tif (copy_to_user(buf, &event, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic long\nhwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,\n\t   loff_t *offset)\n{\n\tstruct snd_efw *efw = hwdep->private_data;\n\tDEFINE_WAIT(wait);\n\tbool dev_lock_changed;\n\tbool queued;\n\n\tspin_lock_irq(&efw->lock);\n\n\tdev_lock_changed = efw->dev_lock_changed;\n\tqueued = efw->push_ptr != efw->pull_ptr;\n\n\twhile (!dev_lock_changed && !queued) {\n\t\tprepare_to_wait(&efw->hwdep_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irq(&efw->lock);\n\t\tschedule();\n\t\tfinish_wait(&efw->hwdep_wait, &wait);\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tspin_lock_irq(&efw->lock);\n\t\tdev_lock_changed = efw->dev_lock_changed;\n\t\tqueued = efw->push_ptr != efw->pull_ptr;\n\t}\n\n\tspin_unlock_irq(&efw->lock);\n\n\tif (dev_lock_changed)\n\t\tcount = hwdep_read_locked(efw, buf, count, offset);\n\telse if (queued)\n\t\tcount = hwdep_read_resp_buf(efw, buf, count, offset);\n\n\treturn count;\n}\n\nstatic long\nhwdep_write(struct snd_hwdep *hwdep, const char __user *data, long count,\n\t    loff_t *offset)\n{\n\tstruct snd_efw *efw = hwdep->private_data;\n\tu32 seqnum;\n\tu8 *buf;\n\n\tif (count < sizeof(struct snd_efw_transaction) ||\n\t    SND_EFW_RESPONSE_MAXIMUM_BYTES < count)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user(data, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\tseqnum = be32_to_cpu(((struct snd_efw_transaction *)buf)->seqnum);\n\tif (seqnum > SND_EFW_TRANSACTION_USER_SEQNUM_MAX) {\n\t\tcount = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tif (snd_efw_transaction_cmd(efw->unit, buf, count) < 0)\n\t\tcount = -EIO;\nend:\n\tkfree(buf);\n\treturn count;\n}\n\nstatic __poll_t\nhwdep_poll(struct snd_hwdep *hwdep, struct file *file, poll_table *wait)\n{\n\tstruct snd_efw *efw = hwdep->private_data;\n\t__poll_t events;\n\n\tpoll_wait(file, &efw->hwdep_wait, wait);\n\n\tspin_lock_irq(&efw->lock);\n\tif (efw->dev_lock_changed || efw->pull_ptr != efw->push_ptr)\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\telse\n\t\tevents = 0;\n\tspin_unlock_irq(&efw->lock);\n\n\treturn events | EPOLLOUT;\n}\n\nstatic int\nhwdep_get_info(struct snd_efw *efw, void __user *arg)\n{\n\tstruct fw_device *dev = fw_parent_device(efw->unit);\n\tstruct snd_firewire_get_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = SNDRV_FIREWIRE_TYPE_FIREWORKS;\n\tinfo.card = dev->card->index;\n\t*(__be32 *)&info.guid[0] = cpu_to_be32(dev->config_rom[3]);\n\t*(__be32 *)&info.guid[4] = cpu_to_be32(dev->config_rom[4]);\n\tstrscpy(info.device_name, dev_name(&dev->device),\n\t\tsizeof(info.device_name));\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int\nhwdep_lock(struct snd_efw *efw)\n{\n\tint err;\n\n\tspin_lock_irq(&efw->lock);\n\n\tif (efw->dev_lock_count == 0) {\n\t\tefw->dev_lock_count = -1;\n\t\terr = 0;\n\t} else {\n\t\terr = -EBUSY;\n\t}\n\n\tspin_unlock_irq(&efw->lock);\n\n\treturn err;\n}\n\nstatic int\nhwdep_unlock(struct snd_efw *efw)\n{\n\tint err;\n\n\tspin_lock_irq(&efw->lock);\n\n\tif (efw->dev_lock_count == -1) {\n\t\tefw->dev_lock_count = 0;\n\t\terr = 0;\n\t} else {\n\t\terr = -EBADFD;\n\t}\n\n\tspin_unlock_irq(&efw->lock);\n\n\treturn err;\n}\n\nstatic int\nhwdep_release(struct snd_hwdep *hwdep, struct file *file)\n{\n\tstruct snd_efw *efw = hwdep->private_data;\n\n\tspin_lock_irq(&efw->lock);\n\tif (efw->dev_lock_count == -1)\n\t\tefw->dev_lock_count = 0;\n\tspin_unlock_irq(&efw->lock);\n\n\treturn 0;\n}\n\nstatic int\nhwdep_ioctl(struct snd_hwdep *hwdep, struct file *file,\n\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_efw *efw = hwdep->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_FIREWIRE_IOCTL_GET_INFO:\n\t\treturn hwdep_get_info(efw, (void __user *)arg);\n\tcase SNDRV_FIREWIRE_IOCTL_LOCK:\n\t\treturn hwdep_lock(efw);\n\tcase SNDRV_FIREWIRE_IOCTL_UNLOCK:\n\t\treturn hwdep_unlock(efw);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int\nhwdep_compat_ioctl(struct snd_hwdep *hwdep, struct file *file,\n\t\t   unsigned int cmd, unsigned long arg)\n{\n\treturn hwdep_ioctl(hwdep, file, cmd,\n\t\t\t   (unsigned long)compat_ptr(arg));\n}\n#else\n#define hwdep_compat_ioctl NULL\n#endif\n\nint snd_efw_create_hwdep_device(struct snd_efw *efw)\n{\n\tstatic const struct snd_hwdep_ops ops = {\n\t\t.read\t\t= hwdep_read,\n\t\t.write\t\t= hwdep_write,\n\t\t.release\t= hwdep_release,\n\t\t.poll\t\t= hwdep_poll,\n\t\t.ioctl\t\t= hwdep_ioctl,\n\t\t.ioctl_compat\t= hwdep_compat_ioctl,\n\t};\n\tstruct snd_hwdep *hwdep;\n\tint err;\n\n\terr = snd_hwdep_new(efw->card, \"Fireworks\", 0, &hwdep);\n\tif (err < 0)\n\t\tgoto end;\n\tstrcpy(hwdep->name, \"Fireworks\");\n\thwdep->iface = SNDRV_HWDEP_IFACE_FW_FIREWORKS;\n\thwdep->ops = ops;\n\thwdep->private_data = efw;\n\thwdep->exclusive = true;\nend:\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}