{
  "module_name": "fireworks_proc.c",
  "hash_id": "31c87c006255bb70ccbb74d707cd51feed5dfd796d2aa7b2c4a072c02341fd82",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_proc.c",
  "human_readable_source": "\n \n\n#include \"./fireworks.h\"\n\nstatic inline const char*\nget_phys_name(struct snd_efw_phys_grp *grp, bool input)\n{\n\tstatic const char *const ch_type[] = {\n\t\t\"Analog\", \"S/PDIF\", \"ADAT\", \"S/PDIF or ADAT\", \"Mirroring\",\n\t\t\"Headphones\", \"I2S\", \"Guitar\", \"Pirzo Guitar\", \"Guitar String\",\n\t};\n\n\tif (grp->type < ARRAY_SIZE(ch_type))\n\t\treturn ch_type[grp->type];\n\telse if (input)\n\t\treturn \"Input\";\n\telse\n\t\treturn \"Output\";\n}\n\nstatic void\nproc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_efw *efw = entry->private_data;\n\tunsigned short i;\n\tstruct snd_efw_hwinfo *hwinfo;\n\n\thwinfo = kmalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);\n\tif (hwinfo == NULL)\n\t\treturn;\n\n\tif (snd_efw_command_get_hwinfo(efw, hwinfo) < 0)\n\t\tgoto end;\n\n\tsnd_iprintf(buffer, \"guid_hi: 0x%X\\n\", hwinfo->guid_hi);\n\tsnd_iprintf(buffer, \"guid_lo: 0x%X\\n\", hwinfo->guid_lo);\n\tsnd_iprintf(buffer, \"type: 0x%X\\n\", hwinfo->type);\n\tsnd_iprintf(buffer, \"version: 0x%X\\n\", hwinfo->version);\n\tsnd_iprintf(buffer, \"vendor_name: %s\\n\", hwinfo->vendor_name);\n\tsnd_iprintf(buffer, \"model_name: %s\\n\", hwinfo->model_name);\n\n\tsnd_iprintf(buffer, \"dsp_version: 0x%X\\n\", hwinfo->dsp_version);\n\tsnd_iprintf(buffer, \"arm_version: 0x%X\\n\", hwinfo->arm_version);\n\tsnd_iprintf(buffer, \"fpga_version: 0x%X\\n\", hwinfo->fpga_version);\n\n\tsnd_iprintf(buffer, \"flags: 0x%X\\n\", hwinfo->flags);\n\n\tsnd_iprintf(buffer, \"max_sample_rate: 0x%X\\n\", hwinfo->max_sample_rate);\n\tsnd_iprintf(buffer, \"min_sample_rate: 0x%X\\n\", hwinfo->min_sample_rate);\n\tsnd_iprintf(buffer, \"supported_clock: 0x%X\\n\",\n\t\t    hwinfo->supported_clocks);\n\n\tsnd_iprintf(buffer, \"phys out: 0x%X\\n\", hwinfo->phys_out);\n\tsnd_iprintf(buffer, \"phys in: 0x%X\\n\", hwinfo->phys_in);\n\n\tsnd_iprintf(buffer, \"phys in grps: 0x%X\\n\",\n\t\t    hwinfo->phys_in_grp_count);\n\tfor (i = 0; i < hwinfo->phys_in_grp_count; i++) {\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"phys in grp[%d]: type 0x%X, count 0x%X\\n\",\n\t\t\t    i, hwinfo->phys_out_grps[i].type,\n\t\t\t    hwinfo->phys_out_grps[i].count);\n\t}\n\n\tsnd_iprintf(buffer, \"phys out grps: 0x%X\\n\",\n\t\t    hwinfo->phys_out_grp_count);\n\tfor (i = 0; i < hwinfo->phys_out_grp_count; i++) {\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"phys out grps[%d]: type 0x%X, count 0x%X\\n\",\n\t\t\t    i, hwinfo->phys_out_grps[i].type,\n\t\t\t    hwinfo->phys_out_grps[i].count);\n\t}\n\n\tsnd_iprintf(buffer, \"amdtp rx pcm channels 1x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_rx_pcm_channels);\n\tsnd_iprintf(buffer, \"amdtp tx pcm channels 1x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_tx_pcm_channels);\n\tsnd_iprintf(buffer, \"amdtp rx pcm channels 2x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_rx_pcm_channels_2x);\n\tsnd_iprintf(buffer, \"amdtp tx pcm channels 2x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_tx_pcm_channels_2x);\n\tsnd_iprintf(buffer, \"amdtp rx pcm channels 4x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_rx_pcm_channels_4x);\n\tsnd_iprintf(buffer, \"amdtp tx pcm channels 4x: 0x%X\\n\",\n\t\t    hwinfo->amdtp_tx_pcm_channels_4x);\n\n\tsnd_iprintf(buffer, \"midi out ports: 0x%X\\n\", hwinfo->midi_out_ports);\n\tsnd_iprintf(buffer, \"midi in ports: 0x%X\\n\", hwinfo->midi_in_ports);\n\n\tsnd_iprintf(buffer, \"mixer playback channels: 0x%X\\n\",\n\t\t    hwinfo->mixer_playback_channels);\n\tsnd_iprintf(buffer, \"mixer capture channels: 0x%X\\n\",\n\t\t    hwinfo->mixer_capture_channels);\nend:\n\tkfree(hwinfo);\n}\n\nstatic void\nproc_read_clock(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_efw *efw = entry->private_data;\n\tenum snd_efw_clock_source clock_source;\n\tunsigned int sampling_rate;\n\n\tif (snd_efw_command_get_clock_source(efw, &clock_source) < 0)\n\t\treturn;\n\n\tif (snd_efw_command_get_sampling_rate(efw, &sampling_rate) < 0)\n\t\treturn;\n\n\tsnd_iprintf(buffer, \"Clock Source: %d\\n\", clock_source);\n\tsnd_iprintf(buffer, \"Sampling Rate: %d\\n\", sampling_rate);\n}\n\n \nstatic void\nproc_read_phys_meters(struct snd_info_entry *entry,\n\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_efw *efw = entry->private_data;\n\tstruct snd_efw_phys_meters *meters;\n\tunsigned int g, c, m, max, size;\n\tconst char *name;\n\tu32 *linear;\n\tint err;\n\n\tsize = sizeof(struct snd_efw_phys_meters) +\n\t       (efw->phys_in + efw->phys_out) * sizeof(u32);\n\tmeters = kzalloc(size, GFP_KERNEL);\n\tif (meters == NULL)\n\t\treturn;\n\n\terr = snd_efw_command_get_phys_meters(efw, meters, size);\n\tif (err < 0)\n\t\tgoto end;\n\n\tsnd_iprintf(buffer, \"Physical Meters:\\n\");\n\n\tm = 0;\n\tmax = min(efw->phys_out, meters->out_meters);\n\tlinear = meters->values;\n\tsnd_iprintf(buffer, \" %d Outputs:\\n\", max);\n\tfor (g = 0; g < efw->phys_out_grp_count; g++) {\n\t\tname = get_phys_name(&efw->phys_out_grps[g], false);\n\t\tfor (c = 0; c < efw->phys_out_grps[g].count; c++) {\n\t\t\tif (m < max)\n\t\t\t\tsnd_iprintf(buffer, \"\\t%s [%d]: %d\\n\",\n\t\t\t\t\t    name, c, linear[m++]);\n\t\t}\n\t}\n\n\tm = 0;\n\tmax = min(efw->phys_in, meters->in_meters);\n\tlinear = meters->values + meters->out_meters;\n\tsnd_iprintf(buffer, \" %d Inputs:\\n\", max);\n\tfor (g = 0; g < efw->phys_in_grp_count; g++) {\n\t\tname = get_phys_name(&efw->phys_in_grps[g], true);\n\t\tfor (c = 0; c < efw->phys_in_grps[g].count; c++)\n\t\t\tif (m < max)\n\t\t\t\tsnd_iprintf(buffer, \"\\t%s [%d]: %d\\n\",\n\t\t\t\t\t    name, c, linear[m++]);\n\t}\nend:\n\tkfree(meters);\n}\n\nstatic void\nproc_read_queues_state(struct snd_info_entry *entry,\n\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_efw *efw = entry->private_data;\n\tunsigned int consumed;\n\n\tif (efw->pull_ptr > efw->push_ptr)\n\t\tconsumed = snd_efw_resp_buf_size -\n\t\t\t   (unsigned int)(efw->pull_ptr - efw->push_ptr);\n\telse\n\t\tconsumed = (unsigned int)(efw->push_ptr - efw->pull_ptr);\n\n\tsnd_iprintf(buffer, \"%d/%d\\n\",\n\t\t    consumed, snd_efw_resp_buf_size);\n}\n\nstatic void\nadd_node(struct snd_efw *efw, struct snd_info_entry *root, const char *name,\n\t void (*op)(struct snd_info_entry *e, struct snd_info_buffer *b))\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(efw->card, name, root);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, efw, op);\n}\n\nvoid snd_efw_proc_init(struct snd_efw *efw)\n{\n\tstruct snd_info_entry *root;\n\n\t \n\troot = snd_info_create_card_entry(efw->card, \"firewire\",\n\t\t\t\t\t  efw->card->proc_root);\n\tif (root == NULL)\n\t\treturn;\n\troot->mode = S_IFDIR | 0555;\n\n\tadd_node(efw, root, \"clock\", proc_read_clock);\n\tadd_node(efw, root, \"firmware\", proc_read_hwinfo);\n\tadd_node(efw, root, \"meters\", proc_read_phys_meters);\n\tadd_node(efw, root, \"queues\", proc_read_queues_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}