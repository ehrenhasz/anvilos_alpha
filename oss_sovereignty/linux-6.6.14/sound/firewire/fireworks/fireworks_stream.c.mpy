{
  "module_name": "fireworks_stream.c",
  "hash_id": "5e668164b2cebf9e75557c687d3f814d25d348d57c8ae24672d1cc3d0ae7109b",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_stream.c",
  "human_readable_source": "\n \n#include \"./fireworks.h\"\n\n#define READY_TIMEOUT_MS\t1000\n\nstatic int init_stream(struct snd_efw *efw, struct amdtp_stream *stream)\n{\n\tstruct cmp_connection *conn;\n\tenum cmp_direction c_dir;\n\tenum amdtp_stream_direction s_dir;\n\tint err;\n\n\tif (stream == &efw->tx_stream) {\n\t\tconn = &efw->out_conn;\n\t\tc_dir = CMP_OUTPUT;\n\t\ts_dir = AMDTP_IN_STREAM;\n\t} else {\n\t\tconn = &efw->in_conn;\n\t\tc_dir = CMP_INPUT;\n\t\ts_dir = AMDTP_OUT_STREAM;\n\t}\n\n\terr = cmp_connection_init(conn, efw->unit, c_dir, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_am824_init(stream, efw->unit, s_dir, CIP_BLOCKING | CIP_UNAWARE_SYT);\n\tif (err < 0) {\n\t\tamdtp_stream_destroy(stream);\n\t\tcmp_connection_destroy(conn);\n\t\treturn err;\n\t}\n\n\tif (stream == &efw->tx_stream) {\n\t\t\n\t\tefw->tx_stream.flags |= CIP_EMPTY_WITH_TAG0;\n\t\t\n\t\tefw->tx_stream.flags |= CIP_DBC_IS_END_EVENT;\n\t\t\n\t\tefw->tx_stream.flags |= CIP_SKIP_DBC_ZERO_CHECK;\n\t\t\n\t\t\n\t\tif (efw->is_fireworks3 &&\n\t\t    (efw->firmware_version == 0x5070000 ||\n\t\t     efw->firmware_version == 0x5070300 ||\n\t\t     efw->firmware_version == 0x5080000))\n\t\t\tefw->tx_stream.flags |= CIP_UNALIGHED_DBC;\n\t\t\n\t\t\n\t\tif (efw->is_af9 || efw->firmware_version == 0x4060000)\n\t\t\tefw->tx_stream.flags |= CIP_WRONG_DBS;\n\t\t\n\t\tif (efw->firmware_version == 0x5050000)\n\t\t\tefw->tx_stream.ctx_data.tx.dbc_interval = 8;\n\t}\n\n\treturn err;\n}\n\nstatic int start_stream(struct snd_efw *efw, struct amdtp_stream *stream,\n\t\t\tunsigned int rate)\n{\n\tstruct cmp_connection *conn;\n\tint err;\n\n\tif (stream == &efw->tx_stream)\n\t\tconn = &efw->out_conn;\n\telse\n\t\tconn = &efw->in_conn;\n\n\t\n\terr = cmp_connection_establish(conn);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\terr = amdtp_domain_add_stream(&efw->domain, stream,\n\t\t\t\t      conn->resources.channel, conn->speed);\n\tif (err < 0) {\n\t\tcmp_connection_break(conn);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n\nstatic void destroy_stream(struct snd_efw *efw, struct amdtp_stream *stream)\n{\n\tamdtp_stream_destroy(stream);\n\n\tif (stream == &efw->tx_stream)\n\t\tcmp_connection_destroy(&efw->out_conn);\n\telse\n\t\tcmp_connection_destroy(&efw->in_conn);\n}\n\nstatic int\ncheck_connection_used_by_others(struct snd_efw *efw, struct amdtp_stream *s)\n{\n\tstruct cmp_connection *conn;\n\tbool used;\n\tint err;\n\n\tif (s == &efw->tx_stream)\n\t\tconn = &efw->out_conn;\n\telse\n\t\tconn = &efw->in_conn;\n\n\terr = cmp_connection_check_used(conn, &used);\n\tif ((err >= 0) && used && !amdtp_stream_running(s)) {\n\t\tdev_err(&efw->unit->device,\n\t\t\t\"Connection established by others: %cPCR[%d]\\n\",\n\t\t\t(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\n\t\t\tconn->pcr_index);\n\t\terr = -EBUSY;\n\t}\n\n\treturn err;\n}\n\nint snd_efw_stream_init_duplex(struct snd_efw *efw)\n{\n\tint err;\n\n\terr = init_stream(efw, &efw->tx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(efw, &efw->rx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(efw, &efw->tx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&efw->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(efw, &efw->tx_stream);\n\t\tdestroy_stream(efw, &efw->rx_stream);\n\t\treturn err;\n\t}\n\n\t\n\terr = snd_efw_command_set_tx_mode(efw, SND_EFW_TRANSPORT_MODE_IEC61883);\n\tif (err < 0) {\n\t\tdestroy_stream(efw, &efw->tx_stream);\n\t\tdestroy_stream(efw, &efw->rx_stream);\n\t}\n\n\treturn err;\n}\n\nstatic int keep_resources(struct snd_efw *efw, struct amdtp_stream *stream,\n\t\t\t  unsigned int rate, unsigned int mode)\n{\n\tunsigned int pcm_channels;\n\tunsigned int midi_ports;\n\tstruct cmp_connection *conn;\n\tint err;\n\n\tif (stream == &efw->tx_stream) {\n\t\tpcm_channels = efw->pcm_capture_channels[mode];\n\t\tmidi_ports = efw->midi_out_ports;\n\t\tconn = &efw->out_conn;\n\t} else {\n\t\tpcm_channels = efw->pcm_playback_channels[mode];\n\t\tmidi_ports = efw->midi_in_ports;\n\t\tconn = &efw->in_conn;\n\t}\n\n\terr = amdtp_am824_set_parameters(stream, rate, pcm_channels,\n\t\t\t\t\t midi_ports, false);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));\n}\n\nint snd_efw_stream_reserve_duplex(struct snd_efw *efw, unsigned int rate,\n\t\t\t\t  unsigned int frames_per_period,\n\t\t\t\t  unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\t\n\t\n\terr = check_connection_used_by_others(efw, &efw->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\terr = snd_efw_command_get_sampling_rate(efw, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0)\n\t\trate = curr_rate;\n\tif (rate != curr_rate) {\n\t\tamdtp_domain_stop(&efw->domain);\n\n\t\tcmp_connection_break(&efw->out_conn);\n\t\tcmp_connection_break(&efw->in_conn);\n\n\t\tcmp_connection_release(&efw->out_conn);\n\t\tcmp_connection_release(&efw->in_conn);\n\t}\n\n\tif (efw->substreams_counter == 0 || rate != curr_rate) {\n\t\tunsigned int mode;\n\n\t\terr = snd_efw_command_set_sampling_rate(efw, rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_efw_get_multiplier_mode(rate, &mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(efw, &efw->tx_stream, rate, mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(efw, &efw->rx_stream, rate, mode);\n\t\tif (err < 0) {\n\t\t\tcmp_connection_release(&efw->in_conn);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&efw->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tcmp_connection_release(&efw->in_conn);\n\t\t\tcmp_connection_release(&efw->out_conn);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_efw_stream_start_duplex(struct snd_efw *efw)\n{\n\tunsigned int rate;\n\tint err = 0;\n\n\t\n\tif (efw->substreams_counter == 0)\n\t\treturn -EIO;\n\n\tif (amdtp_streaming_error(&efw->rx_stream) ||\n\t    amdtp_streaming_error(&efw->tx_stream)) {\n\t\tamdtp_domain_stop(&efw->domain);\n\t\tcmp_connection_break(&efw->out_conn);\n\t\tcmp_connection_break(&efw->in_conn);\n\t}\n\n\terr = snd_efw_command_get_sampling_rate(efw, &rate);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!amdtp_stream_running(&efw->rx_stream)) {\n\t\tunsigned int tx_init_skip_cycles;\n\n\t\t\n\t\t\n\t\tif (efw->is_fireworks3 && !efw->is_af9)\n\t\t\ttx_init_skip_cycles = 6000;\n\t\telse\n\t\t\ttx_init_skip_cycles = 0;\n\n\t\terr = start_stream(efw, &efw->rx_stream, rate);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = start_stream(efw, &efw->tx_stream, rate);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&efw->domain, tx_init_skip_cycles, true, false);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&efw->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&efw->domain);\n\n\tcmp_connection_break(&efw->out_conn);\n\tcmp_connection_break(&efw->in_conn);\n\n\treturn err;\n}\n\nvoid snd_efw_stream_stop_duplex(struct snd_efw *efw)\n{\n\tif (efw->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&efw->domain);\n\n\t\tcmp_connection_break(&efw->out_conn);\n\t\tcmp_connection_break(&efw->in_conn);\n\n\t\tcmp_connection_release(&efw->out_conn);\n\t\tcmp_connection_release(&efw->in_conn);\n\t}\n}\n\nvoid snd_efw_stream_update_duplex(struct snd_efw *efw)\n{\n\tamdtp_domain_stop(&efw->domain);\n\n\tcmp_connection_break(&efw->out_conn);\n\tcmp_connection_break(&efw->in_conn);\n\n\tamdtp_stream_pcm_abort(&efw->rx_stream);\n\tamdtp_stream_pcm_abort(&efw->tx_stream);\n}\n\nvoid snd_efw_stream_destroy_duplex(struct snd_efw *efw)\n{\n\tamdtp_domain_destroy(&efw->domain);\n\n\tdestroy_stream(efw, &efw->rx_stream);\n\tdestroy_stream(efw, &efw->tx_stream);\n}\n\nvoid snd_efw_stream_lock_changed(struct snd_efw *efw)\n{\n\tefw->dev_lock_changed = true;\n\twake_up(&efw->hwdep_wait);\n}\n\nint snd_efw_stream_lock_try(struct snd_efw *efw)\n{\n\tint err;\n\n\tspin_lock_irq(&efw->lock);\n\n\t \n\tif (efw->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (efw->dev_lock_count++ == 0)\n\t\tsnd_efw_stream_lock_changed(efw);\n\terr = 0;\nend:\n\tspin_unlock_irq(&efw->lock);\n\treturn err;\n}\n\nvoid snd_efw_stream_lock_release(struct snd_efw *efw)\n{\n\tspin_lock_irq(&efw->lock);\n\n\tif (WARN_ON(efw->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--efw->dev_lock_count == 0)\n\t\tsnd_efw_stream_lock_changed(efw);\nend:\n\tspin_unlock_irq(&efw->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}