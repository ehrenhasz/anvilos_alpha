{
  "module_name": "fireworks_pcm.c",
  "hash_id": "f91b734250cce1681a6c53d0a325d17fed94ef5f58e39b5f7b9fd469a39300f3",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_pcm.c",
  "human_readable_source": "\n \n#include \"./fireworks.h\"\n\n \nstatic const unsigned int freq_table[] = {\n\t \n\t[0] = 32000,\n\t[1] = 44100,\n\t[2] = 48000,\n\t \n\t[3] = 88200,\n\t[4] = 96000,\n\t \n\t[5] = 176400,\n\t[6] = 192000,\n};\n\nstatic inline unsigned int\nget_multiplier_mode_with_index(unsigned int index)\n{\n\treturn ((int)index - 1) / 2;\n}\n\nint snd_efw_get_multiplier_mode(unsigned int sampling_rate, unsigned int *mode)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\n\t\tif (freq_table[i] == sampling_rate) {\n\t\t\t*mode = get_multiplier_mode_with_index(i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nhw_rule_rate(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int *pcm_channels = rule->private;\n\tstruct snd_interval *r =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tconst struct snd_interval *c =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval t = {\n\t\t.min = UINT_MAX, .max = 0, .integer = 1\n\t};\n\tunsigned int i, mode;\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\n\t\tmode = get_multiplier_mode_with_index(i);\n\t\tif (!snd_interval_test(c, pcm_channels[mode]))\n\t\t\tcontinue;\n\n\t\tt.min = min(t.min, freq_table[i]);\n\t\tt.max = max(t.max, freq_table[i]);\n\t}\n\n\treturn snd_interval_refine(r, &t);\n}\n\nstatic int\nhw_rule_channels(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int *pcm_channels = rule->private;\n\tstruct snd_interval *c =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tconst struct snd_interval *r =\n\t\thw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval t = {\n\t\t.min = UINT_MAX, .max = 0, .integer = 1\n\t};\n\tunsigned int i, mode;\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\n\t\tmode = get_multiplier_mode_with_index(i);\n\t\tif (!snd_interval_test(r, freq_table[i]))\n\t\t\tcontinue;\n\n\t\tt.min = min(t.min, pcm_channels[mode]);\n\t\tt.max = max(t.max, pcm_channels[mode]);\n\t}\n\n\treturn snd_interval_refine(c, &t);\n}\n\nstatic void\nlimit_channels(struct snd_pcm_hardware *hw, unsigned int *pcm_channels)\n{\n\tunsigned int i, mode;\n\n\thw->channels_min = UINT_MAX;\n\thw->channels_max = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\n\t\tmode = get_multiplier_mode_with_index(i);\n\t\tif (pcm_channels[mode] == 0)\n\t\t\tcontinue;\n\n\t\thw->channels_min = min(hw->channels_min, pcm_channels[mode]);\n\t\thw->channels_max = max(hw->channels_max, pcm_channels[mode]);\n\t}\n}\n\nstatic int\npcm_init_hw_params(struct snd_efw *efw,\n\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct amdtp_stream *s;\n\tunsigned int *pcm_channels;\n\tint err;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\truntime->hw.formats = AM824_IN_PCM_FORMAT_BITS;\n\t\ts = &efw->tx_stream;\n\t\tpcm_channels = efw->pcm_capture_channels;\n\t} else {\n\t\truntime->hw.formats = AM824_OUT_PCM_FORMAT_BITS;\n\t\ts = &efw->rx_stream;\n\t\tpcm_channels = efw->pcm_playback_channels;\n\t}\n\n\t \n\truntime->hw.rates = efw->supported_sampling_rate;\n\tsnd_pcm_limit_hw_rates(runtime);\n\n\tlimit_channels(&runtime->hw, pcm_channels);\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_channels, pcm_channels,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  hw_rule_rate, pcm_channels,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = amdtp_am824_add_pcm_hw_constraints(s, runtime);\nend:\n\treturn err;\n}\n\nstatic int pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\tstruct amdtp_domain *d = &efw->domain;\n\tenum snd_efw_clock_source clock_source;\n\tint err;\n\n\terr = snd_efw_stream_lock_try(efw);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pcm_init_hw_params(efw, substream);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\terr = snd_efw_command_get_clock_source(efw, &clock_source);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\tmutex_lock(&efw->mutex);\n\n\t\n\t\n\t\n\tif ((clock_source != SND_EFW_CLOCK_SOURCE_INTERNAL) ||\n\t    (efw->substreams_counter > 0 && d->events_per_period > 0)) {\n\t\tunsigned int frames_per_period = d->events_per_period;\n\t\tunsigned int frames_per_buffer = d->events_per_buffer;\n\t\tunsigned int sampling_rate;\n\n\t\terr = snd_efw_command_get_sampling_rate(efw, &sampling_rate);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&efw->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\t\tsubstream->runtime->hw.rate_min = sampling_rate;\n\t\tsubstream->runtime->hw.rate_max = sampling_rate;\n\n\t\tif (frames_per_period > 0) {\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\tframes_per_period, frames_per_period);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&efw->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\n\t\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\tframes_per_buffer, frames_per_buffer);\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&efw->mutex);\n\t\t\t\tgoto err_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&efw->mutex);\n\n\tsnd_pcm_set_sync(substream);\n\n\treturn 0;\nerr_locked:\n\tsnd_efw_stream_lock_release(efw);\n\treturn err;\n}\n\nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\tsnd_efw_stream_lock_release(efw);\n\treturn 0;\n}\n\nstatic int pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\tint err = 0;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tunsigned int rate = params_rate(hw_params);\n\t\tunsigned int frames_per_period = params_period_size(hw_params);\n\t\tunsigned int frames_per_buffer = params_buffer_size(hw_params);\n\n\t\tmutex_lock(&efw->mutex);\n\t\terr = snd_efw_stream_reserve_duplex(efw, rate,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err >= 0)\n\t\t\t++efw->substreams_counter;\n\t\tmutex_unlock(&efw->mutex);\n\t}\n\n\treturn err;\n}\n\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\n\tmutex_lock(&efw->mutex);\n\n\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t--efw->substreams_counter;\n\n\tsnd_efw_stream_stop_duplex(efw);\n\n\tmutex_unlock(&efw->mutex);\n\n\treturn 0;\n}\n\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\tint err;\n\n\terr = snd_efw_stream_start_duplex(efw);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(&efw->tx_stream);\n\n\treturn err;\n}\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\tint err;\n\n\terr = snd_efw_stream_start_duplex(efw);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(&efw->rx_stream);\n\n\treturn err;\n}\n\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(&efw->tx_stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(&efw->tx_stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(&efw->rx_stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(&efw->rx_stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstrm)\n{\n\tstruct snd_efw *efw = sbstrm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&efw->domain, &efw->tx_stream);\n}\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstrm)\n{\n\tstruct snd_efw *efw = sbstrm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&efw->domain, &efw->rx_stream);\n}\n\nstatic int pcm_capture_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&efw->domain, &efw->tx_stream);\n}\n\nstatic int pcm_playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_efw *efw = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&efw->domain, &efw->rx_stream);\n}\n\nint snd_efw_create_pcm_devices(struct snd_efw *efw)\n{\n\tstatic const struct snd_pcm_ops capture_ops = {\n\t\t.open\t\t= pcm_open,\n\t\t.close\t\t= pcm_close,\n\t\t.hw_params\t= pcm_hw_params,\n\t\t.hw_free\t= pcm_hw_free,\n\t\t.prepare\t= pcm_capture_prepare,\n\t\t.trigger\t= pcm_capture_trigger,\n\t\t.pointer\t= pcm_capture_pointer,\n\t\t.ack\t\t= pcm_capture_ack,\n\t};\n\tstatic const struct snd_pcm_ops playback_ops = {\n\t\t.open\t\t= pcm_open,\n\t\t.close\t\t= pcm_close,\n\t\t.hw_params\t= pcm_hw_params,\n\t\t.hw_free\t= pcm_hw_free,\n\t\t.prepare\t= pcm_playback_prepare,\n\t\t.trigger\t= pcm_playback_trigger,\n\t\t.pointer\t= pcm_playback_pointer,\n\t\t.ack\t\t= pcm_playback_ack,\n\t};\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(efw->card, efw->card->driver, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\tgoto end;\n\n\tpcm->private_data = efw;\n\tsnprintf(pcm->name, sizeof(pcm->name), \"%s PCM\", efw->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\nend:\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}