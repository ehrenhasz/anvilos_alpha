{
  "module_name": "fireworks_command.c",
  "hash_id": "47ab86ad63d618fc1273e97df353373b5cc2bd0810d008adbdcc384c11e45ba6",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireworks/fireworks_command.c",
  "human_readable_source": "\n \n\n#include \"./fireworks.h\"\n\n \n\n#define KERNEL_SEQNUM_MIN\t(SND_EFW_TRANSACTION_USER_SEQNUM_MAX + 2)\n#define KERNEL_SEQNUM_MAX\t((u32)~0)\n\n \nstruct efc_clock {\n\tu32 source;\n\tu32 sampling_rate;\n\tu32 index;\n};\n\n \nenum efc_category {\n\tEFC_CAT_HWINFO\t\t= 0,\n\tEFC_CAT_TRANSPORT\t= 2,\n\tEFC_CAT_HWCTL\t\t= 3,\n};\n\n \nenum efc_cmd_hwinfo {\n\tEFC_CMD_HWINFO_GET_CAPS\t\t= 0,\n\tEFC_CMD_HWINFO_GET_POLLED\t= 1,\n\tEFC_CMD_HWINFO_SET_RESP_ADDR\t= 2\n};\n\nenum efc_cmd_transport {\n\tEFC_CMD_TRANSPORT_SET_TX_MODE\t= 0\n};\n\n \nenum efc_cmd_hwctl {\n\tEFC_CMD_HWCTL_SET_CLOCK\t\t= 0,\n\tEFC_CMD_HWCTL_GET_CLOCK\t\t= 1,\n\tEFC_CMD_HWCTL_IDENTIFY\t\t= 5\n};\n\n \nenum efr_status {\n\tEFR_STATUS_OK\t\t\t= 0,\n\tEFR_STATUS_BAD\t\t\t= 1,\n\tEFR_STATUS_BAD_COMMAND\t\t= 2,\n\tEFR_STATUS_COMM_ERR\t\t= 3,\n\tEFR_STATUS_BAD_QUAD_COUNT\t= 4,\n\tEFR_STATUS_UNSUPPORTED\t\t= 5,\n\tEFR_STATUS_1394_TIMEOUT\t\t= 6,\n\tEFR_STATUS_DSP_TIMEOUT\t\t= 7,\n\tEFR_STATUS_BAD_RATE\t\t= 8,\n\tEFR_STATUS_BAD_CLOCK\t\t= 9,\n\tEFR_STATUS_BAD_CHANNEL\t\t= 10,\n\tEFR_STATUS_BAD_PAN\t\t= 11,\n\tEFR_STATUS_FLASH_BUSY\t\t= 12,\n\tEFR_STATUS_BAD_MIRROR\t\t= 13,\n\tEFR_STATUS_BAD_LED\t\t= 14,\n\tEFR_STATUS_BAD_PARAMETER\t= 15,\n\tEFR_STATUS_INCOMPLETE\t\t= 0x80000000\n};\n\nstatic const char *const efr_status_names[] = {\n\t[EFR_STATUS_OK]\t\t\t= \"OK\",\n\t[EFR_STATUS_BAD]\t\t= \"bad\",\n\t[EFR_STATUS_BAD_COMMAND]\t= \"bad command\",\n\t[EFR_STATUS_COMM_ERR]\t\t= \"comm err\",\n\t[EFR_STATUS_BAD_QUAD_COUNT]\t= \"bad quad count\",\n\t[EFR_STATUS_UNSUPPORTED]\t= \"unsupported\",\n\t[EFR_STATUS_1394_TIMEOUT]\t= \"1394 timeout\",\n\t[EFR_STATUS_DSP_TIMEOUT]\t= \"DSP timeout\",\n\t[EFR_STATUS_BAD_RATE]\t\t= \"bad rate\",\n\t[EFR_STATUS_BAD_CLOCK]\t\t= \"bad clock\",\n\t[EFR_STATUS_BAD_CHANNEL]\t= \"bad channel\",\n\t[EFR_STATUS_BAD_PAN]\t\t= \"bad pan\",\n\t[EFR_STATUS_FLASH_BUSY]\t\t= \"flash busy\",\n\t[EFR_STATUS_BAD_MIRROR]\t\t= \"bad mirror\",\n\t[EFR_STATUS_BAD_LED]\t\t= \"bad LED\",\n\t[EFR_STATUS_BAD_PARAMETER]\t= \"bad parameter\",\n\t[EFR_STATUS_BAD_PARAMETER + 1]\t= \"incomplete\"\n};\n\nstatic int\nefw_transaction(struct snd_efw *efw, unsigned int category,\n\t\tunsigned int command,\n\t\tconst __be32 *params, unsigned int param_bytes,\n\t\tconst __be32 *resp, unsigned int resp_bytes)\n{\n\tstruct snd_efw_transaction *header;\n\t__be32 *buf;\n\tu32 seqnum;\n\tunsigned int buf_bytes, cmd_bytes;\n\tint err;\n\n\t \n\tbuf_bytes = sizeof(struct snd_efw_transaction) +\n\t\t    max(param_bytes, resp_bytes);\n\n\t \n\tbuf = kzalloc(buf_bytes, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock(&efw->lock);\n\tif ((efw->seqnum < KERNEL_SEQNUM_MIN) ||\n\t    (efw->seqnum >= KERNEL_SEQNUM_MAX - 2))\n\t\tefw->seqnum = KERNEL_SEQNUM_MIN;\n\telse\n\t\tefw->seqnum += 2;\n\tseqnum = efw->seqnum;\n\tspin_unlock(&efw->lock);\n\n\t \n\tcmd_bytes = sizeof(struct snd_efw_transaction) + param_bytes;\n\theader = (struct snd_efw_transaction *)buf;\n\theader->length\t = cpu_to_be32(cmd_bytes / sizeof(__be32));\n\theader->version\t = cpu_to_be32(1);\n\theader->seqnum\t = cpu_to_be32(seqnum);\n\theader->category = cpu_to_be32(category);\n\theader->command\t = cpu_to_be32(command);\n\theader->status\t = 0;\n\n\t \n\tmemcpy(header->params, params, param_bytes);\n\n\terr = snd_efw_transaction_run(efw->unit, buf, cmd_bytes,\n\t\t\t\t      buf, buf_bytes);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif ((be32_to_cpu(header->version) < 1) ||\n\t    (be32_to_cpu(header->category) != category) ||\n\t    (be32_to_cpu(header->command) != command) ||\n\t    (be32_to_cpu(header->status) != EFR_STATUS_OK)) {\n\t\tdev_err(&efw->unit->device, \"EFW command failed [%u/%u]: %s\\n\",\n\t\t\tbe32_to_cpu(header->category),\n\t\t\tbe32_to_cpu(header->command),\n\t\t\tefr_status_names[be32_to_cpu(header->status)]);\n\t\terr = -EIO;\n\t\tgoto end;\n\t}\n\n\tif (resp == NULL)\n\t\tgoto end;\n\n\t \n\tmemset((void *)resp, 0, resp_bytes);\n\tresp_bytes = min_t(unsigned int, resp_bytes,\n\t\t\t   be32_to_cpu(header->length) * sizeof(__be32) -\n\t\t\t\tsizeof(struct snd_efw_transaction));\n\tmemcpy((void *)resp, &buf[6], resp_bytes);\nend:\n\tkfree(buf);\n\treturn err;\n}\n\n \nint snd_efw_command_set_resp_addr(struct snd_efw *efw,\n\t\t\t\t  u16 addr_high, u32 addr_low)\n{\n\t__be32 addr[2];\n\n\taddr[0] = cpu_to_be32(addr_high);\n\taddr[1] = cpu_to_be32(addr_low);\n\n\tif (!efw->resp_addr_changable)\n\t\treturn -ENOSYS;\n\n\treturn efw_transaction(efw, EFC_CAT_HWCTL,\n\t\t\t       EFC_CMD_HWINFO_SET_RESP_ADDR,\n\t\t\t       addr, sizeof(addr), NULL, 0);\n}\n\n \nint snd_efw_command_set_tx_mode(struct snd_efw *efw,\n\t\t\t\tenum snd_efw_transport_mode mode)\n{\n\t__be32 param = cpu_to_be32(mode);\n\treturn efw_transaction(efw, EFC_CAT_TRANSPORT,\n\t\t\t       EFC_CMD_TRANSPORT_SET_TX_MODE,\n\t\t\t       &param, sizeof(param), NULL, 0);\n}\n\nint snd_efw_command_get_hwinfo(struct snd_efw *efw,\n\t\t\t       struct snd_efw_hwinfo *hwinfo)\n{\n\tint err;\n\n\terr  = efw_transaction(efw, EFC_CAT_HWINFO,\n\t\t\t       EFC_CMD_HWINFO_GET_CAPS,\n\t\t\t       NULL, 0, (__be32 *)hwinfo, sizeof(*hwinfo));\n\tif (err < 0)\n\t\tgoto end;\n\n\tbe32_to_cpus(&hwinfo->flags);\n\tbe32_to_cpus(&hwinfo->guid_hi);\n\tbe32_to_cpus(&hwinfo->guid_lo);\n\tbe32_to_cpus(&hwinfo->type);\n\tbe32_to_cpus(&hwinfo->version);\n\tbe32_to_cpus(&hwinfo->supported_clocks);\n\tbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels);\n\tbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels);\n\tbe32_to_cpus(&hwinfo->phys_out);\n\tbe32_to_cpus(&hwinfo->phys_in);\n\tbe32_to_cpus(&hwinfo->phys_out_grp_count);\n\tbe32_to_cpus(&hwinfo->phys_in_grp_count);\n\tbe32_to_cpus(&hwinfo->midi_out_ports);\n\tbe32_to_cpus(&hwinfo->midi_in_ports);\n\tbe32_to_cpus(&hwinfo->max_sample_rate);\n\tbe32_to_cpus(&hwinfo->min_sample_rate);\n\tbe32_to_cpus(&hwinfo->dsp_version);\n\tbe32_to_cpus(&hwinfo->arm_version);\n\tbe32_to_cpus(&hwinfo->mixer_playback_channels);\n\tbe32_to_cpus(&hwinfo->mixer_capture_channels);\n\tbe32_to_cpus(&hwinfo->fpga_version);\n\tbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels_2x);\n\tbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels_2x);\n\tbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels_4x);\n\tbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels_4x);\n\n\t \n\thwinfo->vendor_name[HWINFO_NAME_SIZE_BYTES - 1] = '\\0';\n\thwinfo->model_name[HWINFO_NAME_SIZE_BYTES  - 1] = '\\0';\nend:\n\treturn err;\n}\n\nint snd_efw_command_get_phys_meters(struct snd_efw *efw,\n\t\t\t\t    struct snd_efw_phys_meters *meters,\n\t\t\t\t    unsigned int len)\n{\n\tu32 *buf = (u32 *)meters;\n\tunsigned int i;\n\tint err;\n\n\terr = efw_transaction(efw, EFC_CAT_HWINFO,\n\t\t\t      EFC_CMD_HWINFO_GET_POLLED,\n\t\t\t      NULL, 0, (__be32 *)meters, len);\n\tif (err >= 0)\n\t\tfor (i = 0; i < len / sizeof(u32); i++)\n\t\t\tbe32_to_cpus(&buf[i]);\n\n\treturn err;\n}\n\nstatic int\ncommand_get_clock(struct snd_efw *efw, struct efc_clock *clock)\n{\n\tint err;\n\n\terr = efw_transaction(efw, EFC_CAT_HWCTL,\n\t\t\t      EFC_CMD_HWCTL_GET_CLOCK,\n\t\t\t      NULL, 0,\n\t\t\t      (__be32 *)clock, sizeof(struct efc_clock));\n\tif (err >= 0) {\n\t\tbe32_to_cpus(&clock->source);\n\t\tbe32_to_cpus(&clock->sampling_rate);\n\t\tbe32_to_cpus(&clock->index);\n\t}\n\n\treturn err;\n}\n\n \nstatic int\ncommand_set_clock(struct snd_efw *efw,\n\t\t  unsigned int source, unsigned int rate)\n{\n\tstruct efc_clock clock = {0};\n\tint err;\n\n\t \n\tif ((source == UINT_MAX) && (rate == UINT_MAX)) {\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t \n\terr = command_get_clock(efw, &clock);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tif ((clock.source == source) && (clock.sampling_rate == rate))\n\t\tgoto end;\n\n\t \n\tif ((source != UINT_MAX) && (clock.source != source))\n\t\tclock.source = source;\n\tif ((rate != UINT_MAX) && (clock.sampling_rate != rate))\n\t\tclock.sampling_rate = rate;\n\tclock.index = 0;\n\n\tcpu_to_be32s(&clock.source);\n\tcpu_to_be32s(&clock.sampling_rate);\n\tcpu_to_be32s(&clock.index);\n\n\terr = efw_transaction(efw, EFC_CAT_HWCTL,\n\t\t\t      EFC_CMD_HWCTL_SET_CLOCK,\n\t\t\t      (__be32 *)&clock, sizeof(struct efc_clock),\n\t\t\t      NULL, 0);\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tmsleep(150);\nend:\n\treturn err;\n}\n\nint snd_efw_command_get_clock_source(struct snd_efw *efw,\n\t\t\t\t     enum snd_efw_clock_source *source)\n{\n\tint err;\n\tstruct efc_clock clock = {0};\n\n\terr = command_get_clock(efw, &clock);\n\tif (err >= 0)\n\t\t*source = clock.source;\n\n\treturn err;\n}\n\nint snd_efw_command_get_sampling_rate(struct snd_efw *efw, unsigned int *rate)\n{\n\tint err;\n\tstruct efc_clock clock = {0};\n\n\terr = command_get_clock(efw, &clock);\n\tif (err >= 0)\n\t\t*rate = clock.sampling_rate;\n\n\treturn err;\n}\n\nint snd_efw_command_set_sampling_rate(struct snd_efw *efw, unsigned int rate)\n{\n\treturn command_set_clock(efw, UINT_MAX, rate);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}