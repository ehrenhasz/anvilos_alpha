{
  "module_name": "digi00x-stream.c",
  "hash_id": "0cb41e97dde5a74826e7d6fb491a3ab888ecf1e0858427610da5b1b93fcd104c",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/digi00x/digi00x-stream.c",
  "human_readable_source": "\n \n\n#include \"digi00x.h\"\n\n#define READY_TIMEOUT_MS\t200\n\nconst unsigned int snd_dg00x_stream_rates[SND_DG00X_RATE_COUNT] = {\n\t[SND_DG00X_RATE_44100] = 44100,\n\t[SND_DG00X_RATE_48000] = 48000,\n\t[SND_DG00X_RATE_88200] = 88200,\n\t[SND_DG00X_RATE_96000] = 96000,\n};\n\n \nconst unsigned int\nsnd_dg00x_stream_pcm_channels[SND_DG00X_RATE_COUNT] = {\n\t \n\t[SND_DG00X_RATE_44100] = (8 + 8 + 2),\n\t[SND_DG00X_RATE_48000] = (8 + 8 + 2),\n\t \n\t[SND_DG00X_RATE_88200] = (8 + 2),\n\t[SND_DG00X_RATE_96000] = (8 + 2),\n};\n\nint snd_dg00x_stream_get_local_rate(struct snd_dg00x *dg00x, unsigned int *rate)\n{\n\tu32 data;\n\t__be32 reg;\n\tint err;\n\n\terr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_LOCAL_RATE,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = be32_to_cpu(reg) & 0x0f;\n\tif (data < ARRAY_SIZE(snd_dg00x_stream_rates))\n\t\t*rate = snd_dg00x_stream_rates[data];\n\telse\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint snd_dg00x_stream_set_local_rate(struct snd_dg00x *dg00x, unsigned int rate)\n{\n\t__be32 reg;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_dg00x_stream_rates); i++) {\n\t\tif (rate == snd_dg00x_stream_rates[i])\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(snd_dg00x_stream_rates))\n\t\treturn -EINVAL;\n\n\treg = cpu_to_be32(i);\n\treturn snd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  DG00X_ADDR_BASE + DG00X_OFFSET_LOCAL_RATE,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nint snd_dg00x_stream_get_clock(struct snd_dg00x *dg00x,\n\t\t\t       enum snd_dg00x_clock *clock)\n{\n\t__be32 reg;\n\tint err;\n\n\terr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_CLOCK_SOURCE,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t*clock = be32_to_cpu(reg) & 0x0f;\n\tif (*clock >= SND_DG00X_CLOCK_COUNT)\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nint snd_dg00x_stream_check_external_clock(struct snd_dg00x *dg00x, bool *detect)\n{\n\t__be32 reg;\n\tint err;\n\n\terr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_DETECT_EXTERNAL,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err >= 0)\n\t\t*detect = be32_to_cpu(reg) > 0;\n\n\treturn err;\n}\n\nint snd_dg00x_stream_get_external_rate(struct snd_dg00x *dg00x,\n\t\t\t\t       unsigned int *rate)\n{\n\tu32 data;\n\t__be32 reg;\n\tint err;\n\n\terr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_EXTERNAL_RATE,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = be32_to_cpu(reg) & 0x0f;\n\tif (data < ARRAY_SIZE(snd_dg00x_stream_rates))\n\t\t*rate = snd_dg00x_stream_rates[data];\n\t \n\telse\n\t\terr = -EBUSY;\n\n\treturn err;\n}\n\nstatic void finish_session(struct snd_dg00x *dg00x)\n{\n\t__be32 data;\n\n\tdata = cpu_to_be32(0x00000003);\n\tsnd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   DG00X_ADDR_BASE + DG00X_OFFSET_STREAMING_SET,\n\t\t\t   &data, sizeof(data), 0);\n\n\t\n\tdata = 0;\n\tsnd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   DG00X_ADDR_BASE + DG00X_OFFSET_ISOC_CHANNELS,\n\t\t\t   &data, sizeof(data), 0);\n\n\t\n\t\n\tmsleep(50);\n}\n\nstatic int begin_session(struct snd_dg00x *dg00x)\n{\n\t__be32 data;\n\tu32 curr;\n\tint err;\n\n\t\n\tdata = cpu_to_be32((dg00x->tx_resources.channel << 16) |\n\t\t\t   dg00x->rx_resources.channel);\n\terr = snd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_ISOC_CHANNELS,\n\t\t\t\t &data, sizeof(data), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t DG00X_ADDR_BASE + DG00X_OFFSET_STREAMING_STATE,\n\t\t\t\t &data, sizeof(data), 0);\n\tif (err < 0)\n\t\treturn err;\n\tcurr = be32_to_cpu(data);\n\n\tif (curr == 0)\n\t\tcurr = 2;\n\n\tcurr--;\n\twhile (curr > 0) {\n\t\tdata = cpu_to_be32(curr);\n\t\terr = snd_fw_transaction(dg00x->unit,\n\t\t\t\t\t TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t\t DG00X_ADDR_BASE +\n\t\t\t\t\t DG00X_OFFSET_STREAMING_SET,\n\t\t\t\t\t &data, sizeof(data), 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tcurr--;\n\t}\n\n\treturn err;\n}\n\nstatic int keep_resources(struct snd_dg00x *dg00x, struct amdtp_stream *stream,\n\t\t\t  unsigned int rate)\n{\n\tstruct fw_iso_resources *resources;\n\tint i;\n\tint err;\n\n\t\n\tfor (i = 0; i < SND_DG00X_RATE_COUNT; i++) {\n\t\tif (snd_dg00x_stream_rates[i] == rate)\n\t\t\tbreak;\n\t}\n\tif (i == SND_DG00X_RATE_COUNT)\n\t\treturn -EINVAL;\n\n\tif (stream == &dg00x->tx_stream)\n\t\tresources = &dg00x->tx_resources;\n\telse\n\t\tresources = &dg00x->rx_resources;\n\n\terr = amdtp_dot_set_parameters(stream, rate,\n\t\t\t\t       snd_dg00x_stream_pcm_channels[i]);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn fw_iso_resources_allocate(resources,\n\t\t\t\tamdtp_stream_get_max_payload(stream),\n\t\t\t\tfw_parent_device(dg00x->unit)->max_speed);\n}\n\nstatic int init_stream(struct snd_dg00x *dg00x, struct amdtp_stream *s)\n{\n\tstruct fw_iso_resources *resources;\n\tenum amdtp_stream_direction dir;\n\tint err;\n\n\tif (s == &dg00x->tx_stream) {\n\t\tresources = &dg00x->tx_resources;\n\t\tdir = AMDTP_IN_STREAM;\n\t} else {\n\t\tresources = &dg00x->rx_resources;\n\t\tdir = AMDTP_OUT_STREAM;\n\t}\n\n\terr = fw_iso_resources_init(resources, dg00x->unit);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_dot_init(s, dg00x->unit, dir);\n\tif (err < 0)\n\t\tfw_iso_resources_destroy(resources);\n\n\treturn err;\n}\n\nstatic void destroy_stream(struct snd_dg00x *dg00x, struct amdtp_stream *s)\n{\n\tamdtp_stream_destroy(s);\n\n\tif (s == &dg00x->tx_stream)\n\t\tfw_iso_resources_destroy(&dg00x->tx_resources);\n\telse\n\t\tfw_iso_resources_destroy(&dg00x->rx_resources);\n}\n\nint snd_dg00x_stream_init_duplex(struct snd_dg00x *dg00x)\n{\n\tint err;\n\n\terr = init_stream(dg00x, &dg00x->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(dg00x, &dg00x->tx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(dg00x, &dg00x->rx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&dg00x->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(dg00x, &dg00x->rx_stream);\n\t\tdestroy_stream(dg00x, &dg00x->tx_stream);\n\t}\n\n\treturn err;\n}\n\n \nvoid snd_dg00x_stream_destroy_duplex(struct snd_dg00x *dg00x)\n{\n\tamdtp_domain_destroy(&dg00x->domain);\n\n\tdestroy_stream(dg00x, &dg00x->rx_stream);\n\tdestroy_stream(dg00x, &dg00x->tx_stream);\n}\n\nint snd_dg00x_stream_reserve_duplex(struct snd_dg00x *dg00x, unsigned int rate,\n\t\t\t\t    unsigned int frames_per_period,\n\t\t\t\t    unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\terr = snd_dg00x_stream_get_local_rate(dg00x, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (rate == 0)\n\t\trate = curr_rate;\n\n\tif (dg00x->substreams_counter == 0 || curr_rate != rate) {\n\t\tamdtp_domain_stop(&dg00x->domain);\n\n\t\tfinish_session(dg00x);\n\n\t\tfw_iso_resources_free(&dg00x->tx_resources);\n\t\tfw_iso_resources_free(&dg00x->rx_resources);\n\n\t\terr = snd_dg00x_stream_set_local_rate(dg00x, rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(dg00x, &dg00x->rx_stream, rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(dg00x, &dg00x->tx_stream, rate);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&dg00x->rx_resources);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&dg00x->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&dg00x->rx_resources);\n\t\t\tfw_iso_resources_free(&dg00x->tx_resources);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_dg00x_stream_start_duplex(struct snd_dg00x *dg00x)\n{\n\tunsigned int generation = dg00x->rx_resources.generation;\n\tint err = 0;\n\n\tif (dg00x->substreams_counter == 0)\n\t\treturn 0;\n\n\tif (amdtp_streaming_error(&dg00x->tx_stream) ||\n\t    amdtp_streaming_error(&dg00x->rx_stream)) {\n\t\tamdtp_domain_stop(&dg00x->domain);\n\t\tfinish_session(dg00x);\n\t}\n\n\tif (generation != fw_parent_device(dg00x->unit)->card->generation) {\n\t\terr = fw_iso_resources_update(&dg00x->tx_resources);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = fw_iso_resources_update(&dg00x->rx_resources);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (!amdtp_stream_running(&dg00x->rx_stream)) {\n\t\tint spd = fw_parent_device(dg00x->unit)->max_speed;\n\n\t\terr = begin_session(dg00x);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&dg00x->domain, &dg00x->rx_stream,\n\t\t\t\t\t      dg00x->rx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&dg00x->domain, &dg00x->tx_stream,\n\t\t\t\t\t      dg00x->tx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&dg00x->domain, 0, true, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&dg00x->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&dg00x->domain);\n\tfinish_session(dg00x);\n\n\treturn err;\n}\n\nvoid snd_dg00x_stream_stop_duplex(struct snd_dg00x *dg00x)\n{\n\tif (dg00x->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&dg00x->domain);\n\t\tfinish_session(dg00x);\n\n\t\tfw_iso_resources_free(&dg00x->tx_resources);\n\t\tfw_iso_resources_free(&dg00x->rx_resources);\n\t}\n}\n\nvoid snd_dg00x_stream_update_duplex(struct snd_dg00x *dg00x)\n{\n\tfw_iso_resources_update(&dg00x->tx_resources);\n\tfw_iso_resources_update(&dg00x->rx_resources);\n\n\tamdtp_stream_update(&dg00x->tx_stream);\n\tamdtp_stream_update(&dg00x->rx_stream);\n}\n\nvoid snd_dg00x_stream_lock_changed(struct snd_dg00x *dg00x)\n{\n\tdg00x->dev_lock_changed = true;\n\twake_up(&dg00x->hwdep_wait);\n}\n\nint snd_dg00x_stream_lock_try(struct snd_dg00x *dg00x)\n{\n\tint err;\n\n\tspin_lock_irq(&dg00x->lock);\n\n\t \n\tif (dg00x->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (dg00x->dev_lock_count++ == 0)\n\t\tsnd_dg00x_stream_lock_changed(dg00x);\n\terr = 0;\nend:\n\tspin_unlock_irq(&dg00x->lock);\n\treturn err;\n}\n\nvoid snd_dg00x_stream_lock_release(struct snd_dg00x *dg00x)\n{\n\tspin_lock_irq(&dg00x->lock);\n\n\tif (WARN_ON(dg00x->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--dg00x->dev_lock_count == 0)\n\t\tsnd_dg00x_stream_lock_changed(dg00x);\nend:\n\tspin_unlock_irq(&dg00x->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}