{
  "module_name": "amdtp-dot.c",
  "hash_id": "4ea07ec805059f65cec02c4a761d8e90bce488935172db09dd67024e8c3857f0",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/digi00x/amdtp-dot.c",
  "human_readable_source": "\n \n\n#include <sound/pcm.h>\n#include \"digi00x.h\"\n\n#define CIP_FMT_AM\t\t0x10\n\n \n#define AMDTP_FDF_AM824\t\t0x00\n\n \n#define MIDI_BYTES_PER_SECOND\t3093\n\n \n#define MAX_MIDI_RX_BLOCKS\t8\n\n \n#define MAX_MIDI_PORTS\t\t3\n\n \nstruct dot_state {\n\tu8 carry;\n\tu8 idx;\n\tunsigned int off;\n};\n\nstruct amdtp_dot {\n\tunsigned int pcm_channels;\n\tstruct dot_state state;\n\n\tstruct snd_rawmidi_substream *midi[MAX_MIDI_PORTS];\n\tint midi_fifo_used[MAX_MIDI_PORTS];\n\tint midi_fifo_limit;\n};\n\n \n#define BYTE_PER_SAMPLE (4)\n#define MAGIC_DOT_BYTE (2)\n#define MAGIC_BYTE_OFF(x) (((x) * BYTE_PER_SAMPLE) + MAGIC_DOT_BYTE)\nstatic u8 dot_scrt(const u8 idx, const unsigned int off)\n{\n\t \n\tstatic const u8 len[16] = {0, 1, 3, 5, 7, 9, 11, 13, 14,\n\t\t\t\t   12, 10, 8, 6, 4, 2, 0};\n\n\t \n\tstatic const u8 nib[15] = {0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4,\n\t\t\t\t   0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf};\n\n\t \n\tstatic const u8 hir[15] = {0x0, 0x6, 0xf, 0x8, 0x7, 0x5, 0x3, 0x4,\n\t\t\t\t   0xc, 0xd, 0xe, 0x1, 0x2, 0xb, 0xa};\n\n\t \n\tstatic const u8 hio[16] = {0, 11, 12, 6, 7, 5, 1, 4,\n\t\t\t\t   3, 0x00, 14, 13, 8, 9, 10, 2};\n\n\tconst u8 ln = idx & 0xf;\n\tconst u8 hn = (idx >> 4) & 0xf;\n\tconst u8 hr = (hn == 0x9) ? 0x9 : hir[(hio[hn] + off) % 15];\n\n\tif (len[ln] < off)\n\t\treturn 0x00;\n\n\treturn ((nib[14 + off - len[ln]]) | (hr << 4));\n}\n\nstatic void dot_encode_step(struct dot_state *state, __be32 *const buffer)\n{\n\tu8 * const data = (u8 *) buffer;\n\n\tif (data[MAGIC_DOT_BYTE] != 0x00) {\n\t\tstate->off = 0;\n\t\tstate->idx = data[MAGIC_DOT_BYTE] ^ state->carry;\n\t}\n\tdata[MAGIC_DOT_BYTE] ^= state->carry;\n\tstate->carry = dot_scrt(state->idx, ++(state->off));\n}\n\nint amdtp_dot_set_parameters(struct amdtp_stream *s, unsigned int rate,\n\t\t\t     unsigned int pcm_channels)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tint err;\n\n\tif (amdtp_stream_running(s))\n\t\treturn -EBUSY;\n\n\t \n\terr = amdtp_stream_set_parameters(s, rate, pcm_channels + 1, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ts->ctx_data.rx.fdf = AMDTP_FDF_AM824 | s->sfc;\n\n\tp->pcm_channels = pcm_channels;\n\n\t \n\tp->midi_fifo_limit = rate - MIDI_BYTES_PER_SECOND * s->syt_interval + 1;\n\n\treturn 0;\n}\n\nstatic void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t  __be32 *buffer, unsigned int frames,\n\t\t\t  unsigned int pcm_frames)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tconst u32 *src;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tsrc = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tbuffer++;\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\tbuffer[c] = cpu_to_be32((*src >> 8) | 0x40000000);\n\t\t\tdot_encode_step(&p->state, &buffer[c]);\n\t\t\tsrc++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tsrc = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t __be32 *buffer, unsigned int frames,\n\t\t\t unsigned int pcm_frames)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tu32 *dst;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tdst  = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tbuffer++;\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t*dst = be32_to_cpu(buffer[c]) << 8;\n\t\t\tdst++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tdst = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t      unsigned int data_blocks)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tunsigned int channels, i, c;\n\n\tchannels = p->pcm_channels;\n\n\tbuffer++;\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tfor (c = 0; c < channels; ++c)\n\t\t\tbuffer[c] = cpu_to_be32(0x40000000);\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nstatic bool midi_ratelimit_per_packet(struct amdtp_stream *s, unsigned int port)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tint used;\n\n\tused = p->midi_fifo_used[port];\n\tif (used == 0)\n\t\treturn true;\n\n\tused -= MIDI_BYTES_PER_SECOND * s->syt_interval;\n\tused = max(used, 0);\n\tp->midi_fifo_used[port] = used;\n\n\treturn used < p->midi_fifo_limit;\n}\n\nstatic inline void midi_use_bytes(struct amdtp_stream *s,\n\t\t\t\t  unsigned int port, unsigned int count)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\n\tp->midi_fifo_used[port] += amdtp_rate_table[s->sfc] * count;\n}\n\nstatic void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\tunsigned int data_blocks, unsigned int data_block_counter)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tunsigned int f, port;\n\tint len;\n\tu8 *b;\n\n\tfor (f = 0; f < data_blocks; f++) {\n\t\tport = (data_block_counter + f) % 8;\n\t\tb = (u8 *)&buffer[0];\n\n\t\tlen = 0;\n\t\tif (port < MAX_MIDI_PORTS &&\n\t\t    midi_ratelimit_per_packet(s, port) &&\n\t\t    p->midi[port] != NULL)\n\t\t\tlen = snd_rawmidi_transmit(p->midi[port], b + 1, 2);\n\n\t\tif (len > 0) {\n\t\t\t \n\t\t\tif (port == 2)\n\t\t\t\tb[3] = 0xe0;\n\t\t\telse if (port == 1)\n\t\t\t\tb[3] = 0x20;\n\t\t\telse\n\t\t\t\tb[3] = 0x00;\n\t\t\tb[3] |= len;\n\t\t\tmidi_use_bytes(s, port, len);\n\t\t} else {\n\t\t\tb[1] = 0;\n\t\t\tb[2] = 0;\n\t\t\tb[3] = 0;\n\t\t}\n\t\tb[0] = 0x80;\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nstatic void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t       unsigned int data_blocks)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\tunsigned int f, port, len;\n\tu8 *b;\n\n\tfor (f = 0; f < data_blocks; f++) {\n\t\tb = (u8 *)&buffer[0];\n\n\t\tlen = b[3] & 0x0f;\n\t\tif (len > 0) {\n\t\t\t \n\t\t\tif (b[3] >> 4 > 0)\n\t\t\t\tport = 2;\n\t\t\telse\n\t\t\t\tport = 0;\n\n\t\t\tif (port < MAX_MIDI_PORTS && p->midi[port])\n\t\t\t\tsnd_rawmidi_receive(p->midi[port], b + 1, len);\n\t\t}\n\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nint amdtp_dot_add_pcm_hw_constraints(struct amdtp_stream *s,\n\t\t\t\t     struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\t \n\terr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn amdtp_stream_add_pcm_hw_constraints(s, runtime);\n}\n\nvoid amdtp_dot_midi_trigger(struct amdtp_stream *s, unsigned int port,\n\t\t\t  struct snd_rawmidi_substream *midi)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\n\tif (port < MAX_MIDI_PORTS)\n\t\tWRITE_ONCE(p->midi[port], midi);\n}\n\nstatic void process_ir_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\tread_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t}\n\n\t\tread_midi_messages(s, buf, data_blocks);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nstatic void process_it_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\twrite_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t} else {\n\t\t\twrite_pcm_silence(s, buf, data_blocks);\n\t\t}\n\n\t\twrite_midi_messages(s, buf, data_blocks,\n\t\t\t\t    desc->data_block_counter);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nint amdtp_dot_init(struct amdtp_stream *s, struct fw_unit *unit,\n\t\t enum amdtp_stream_direction dir)\n{\n\tamdtp_stream_process_ctx_payloads_t process_ctx_payloads;\n\tunsigned int flags = CIP_NONBLOCKING | CIP_UNAWARE_SYT;\n\n\t\n\tif (dir == AMDTP_IN_STREAM)\n\t\tprocess_ctx_payloads = process_ir_ctx_payloads;\n\telse\n\t\tprocess_ctx_payloads = process_it_ctx_payloads;\n\n\treturn amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM,\n\t\t\t\tprocess_ctx_payloads, sizeof(struct amdtp_dot));\n}\n\nvoid amdtp_dot_reset(struct amdtp_stream *s)\n{\n\tstruct amdtp_dot *p = s->protocol;\n\n\tp->state.carry = 0x00;\n\tp->state.idx = 0x00;\n\tp->state.off = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}