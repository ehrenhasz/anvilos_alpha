{
  "module_name": "digi00x.c",
  "hash_id": "cb3a9618f6b67aada999209ec23ee2df1b1c393c3636c13cdf1975ddf38d7065",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/digi00x/digi00x.c",
  "human_readable_source": "\n \n\n#include \"digi00x.h\"\n\nMODULE_DESCRIPTION(\"Digidesign Digi 002/003 family Driver\");\nMODULE_AUTHOR(\"Takashi Sakamoto <o-takashi@sakamocchi.jp>\");\nMODULE_LICENSE(\"GPL\");\n\n#define VENDOR_DIGIDESIGN\t0x00a07e\n#define MODEL_CONSOLE\t\t0x000001\n#define MODEL_RACK\t\t0x000002\n#define SPEC_VERSION\t\t0x000001\n\nstatic int name_card(struct snd_dg00x *dg00x)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(dg00x->unit);\n\tchar name[32] = {0};\n\tchar *model;\n\tint err;\n\n\terr = fw_csr_string(dg00x->unit->directory, CSR_MODEL, name,\n\t\t\t    sizeof(name));\n\tif (err < 0)\n\t\treturn err;\n\n\tmodel = skip_spaces(name);\n\n\tstrcpy(dg00x->card->driver, \"Digi00x\");\n\tstrcpy(dg00x->card->shortname, model);\n\tstrcpy(dg00x->card->mixername, model);\n\tsnprintf(dg00x->card->longname, sizeof(dg00x->card->longname),\n\t\t \"Digidesign %s, GUID %08x%08x at %s, S%d\", model,\n\t\t fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t dev_name(&dg00x->unit->device), 100 << fw_dev->max_speed);\n\n\treturn 0;\n}\n\nstatic void dg00x_card_free(struct snd_card *card)\n{\n\tstruct snd_dg00x *dg00x = card->private_data;\n\n\tsnd_dg00x_stream_destroy_duplex(dg00x);\n\tsnd_dg00x_transaction_unregister(dg00x);\n\n\tmutex_destroy(&dg00x->mutex);\n\tfw_unit_put(dg00x->unit);\n}\n\nstatic int snd_dg00x_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tstruct snd_card *card;\n\tstruct snd_dg00x *dg00x;\n\tint err;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE, sizeof(*dg00x), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = dg00x_card_free;\n\n\tdg00x = card->private_data;\n\tdg00x->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, dg00x);\n\tdg00x->card = card;\n\n\tmutex_init(&dg00x->mutex);\n\tspin_lock_init(&dg00x->lock);\n\tinit_waitqueue_head(&dg00x->hwdep_wait);\n\n\tdg00x->is_console = entry->model_id == MODEL_CONSOLE;\n\n\terr = name_card(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dg00x_stream_init_duplex(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_dg00x_proc_init(dg00x);\n\n\terr = snd_dg00x_create_pcm_devices(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dg00x_create_midi_devices(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dg00x_create_hwdep_device(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_dg00x_transaction_register(dg00x);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_dg00x_update(struct fw_unit *unit)\n{\n\tstruct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);\n\n\tsnd_dg00x_transaction_reregister(dg00x);\n\n\tmutex_lock(&dg00x->mutex);\n\tsnd_dg00x_stream_update_duplex(dg00x);\n\tmutex_unlock(&dg00x->mutex);\n}\n\nstatic void snd_dg00x_remove(struct fw_unit *unit)\n{\n\tstruct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(dg00x->card);\n}\n\nstatic const struct ieee1394_device_id snd_dg00x_id_table[] = {\n\t \n\t{\n\t\t.match_flags = IEEE1394_MATCH_VENDOR_ID |\n\t\t\t       IEEE1394_MATCH_VERSION |\n\t\t\t       IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id = VENDOR_DIGIDESIGN,\n\t\t.version = SPEC_VERSION,\n\t\t.model_id = MODEL_CONSOLE,\n\t},\n\t{\n\t\t.match_flags = IEEE1394_MATCH_VENDOR_ID |\n\t\t\t       IEEE1394_MATCH_VERSION |\n\t\t\t       IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id = VENDOR_DIGIDESIGN,\n\t\t.version = SPEC_VERSION,\n\t\t.model_id = MODEL_RACK,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(ieee1394, snd_dg00x_id_table);\n\nstatic struct fw_driver dg00x_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = KBUILD_MODNAME,\n\t\t.bus = &fw_bus_type,\n\t},\n\t.probe    = snd_dg00x_probe,\n\t.update   = snd_dg00x_update,\n\t.remove   = snd_dg00x_remove,\n\t.id_table = snd_dg00x_id_table,\n};\n\nstatic int __init snd_dg00x_init(void)\n{\n\treturn driver_register(&dg00x_driver.driver);\n}\n\nstatic void __exit snd_dg00x_exit(void)\n{\n\tdriver_unregister(&dg00x_driver.driver);\n}\n\nmodule_init(snd_dg00x_init);\nmodule_exit(snd_dg00x_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}