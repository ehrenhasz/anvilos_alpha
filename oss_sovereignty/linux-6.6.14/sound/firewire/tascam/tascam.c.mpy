{
  "module_name": "tascam.c",
  "hash_id": "bf244ddca1c87859db6248424a05b897971f3330b44ce6f1dca908716e5f2a72",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/tascam/tascam.c",
  "human_readable_source": "\n \n\n#include \"tascam.h\"\n\nMODULE_DESCRIPTION(\"TASCAM FireWire series Driver\");\nMODULE_AUTHOR(\"Takashi Sakamoto <o-takashi@sakamocchi.jp>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct snd_tscm_spec model_specs[] = {\n\t{\n\t\t.name = \"FW-1884\",\n\t\t.has_adat = true,\n\t\t.has_spdif = true,\n\t\t.pcm_capture_analog_channels = 8,\n\t\t.pcm_playback_analog_channels = 8,\n\t\t.midi_capture_ports = 4,\n\t\t.midi_playback_ports = 4,\n\t},\n\t{\n\t\t.name = \"FW-1082\",\n\t\t.has_adat = false,\n\t\t.has_spdif = true,\n\t\t.pcm_capture_analog_channels = 8,\n\t\t.pcm_playback_analog_channels = 2,\n\t\t.midi_capture_ports = 2,\n\t\t.midi_playback_ports = 2,\n\t},\n\t{\n\t\t.name = \"FW-1804\",\n\t\t.has_adat = true,\n\t\t.has_spdif = true,\n\t\t.pcm_capture_analog_channels = 8,\n\t\t.pcm_playback_analog_channels = 2,\n\t\t.midi_capture_ports = 2,\n\t\t.midi_playback_ports = 4,\n\t},\n};\n\nstatic int identify_model(struct snd_tscm *tscm)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(tscm->unit);\n\tconst u32 *config_rom = fw_dev->config_rom;\n\tchar model[9];\n\tunsigned int i;\n\tu8 c;\n\n\tif (fw_dev->config_rom_length < 30) {\n\t\tdev_err(&tscm->unit->device,\n\t\t\t\"Configuration ROM is too short.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tc = config_rom[28 + i / 4] >> (24 - 8 * (i % 4));\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tmodel[i] = c;\n\t}\n\tmodel[i] = '\\0';\n\n\tfor (i = 0; i < ARRAY_SIZE(model_specs); i++) {\n\t\tif (strcmp(model, model_specs[i].name) == 0) {\n\t\t\ttscm->spec = &model_specs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tscm->spec == NULL)\n\t\treturn -ENODEV;\n\n\tstrcpy(tscm->card->driver, \"FW-TASCAM\");\n\tstrcpy(tscm->card->shortname, model);\n\tstrcpy(tscm->card->mixername, model);\n\tsnprintf(tscm->card->longname, sizeof(tscm->card->longname),\n\t\t \"TASCAM %s, GUID %08x%08x at %s, S%d\", model,\n\t\t fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t dev_name(&tscm->unit->device), 100 << fw_dev->max_speed);\n\n\treturn 0;\n}\n\nstatic void tscm_card_free(struct snd_card *card)\n{\n\tstruct snd_tscm *tscm = card->private_data;\n\n\tsnd_tscm_transaction_unregister(tscm);\n\tsnd_tscm_stream_destroy_duplex(tscm);\n\n\tmutex_destroy(&tscm->mutex);\n\tfw_unit_put(tscm->unit);\n}\n\nstatic int snd_tscm_probe(struct fw_unit *unit,\n\t\t\t   const struct ieee1394_device_id *entry)\n{\n\tstruct snd_card *card;\n\tstruct snd_tscm *tscm;\n\tint err;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE, sizeof(*tscm), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = tscm_card_free;\n\n\ttscm = card->private_data;\n\ttscm->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, tscm);\n\ttscm->card = card;\n\n\tmutex_init(&tscm->mutex);\n\tspin_lock_init(&tscm->lock);\n\tinit_waitqueue_head(&tscm->hwdep_wait);\n\n\terr = identify_model(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_tscm_transaction_register(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_tscm_stream_init_duplex(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_tscm_proc_init(tscm);\n\n\terr = snd_tscm_create_pcm_devices(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_tscm_create_midi_devices(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_tscm_create_hwdep_device(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_tscm_update(struct fw_unit *unit)\n{\n\tstruct snd_tscm *tscm = dev_get_drvdata(&unit->device);\n\n\tsnd_tscm_transaction_reregister(tscm);\n\n\tmutex_lock(&tscm->mutex);\n\tsnd_tscm_stream_update_duplex(tscm);\n\tmutex_unlock(&tscm->mutex);\n}\n\nstatic void snd_tscm_remove(struct fw_unit *unit)\n{\n\tstruct snd_tscm *tscm = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(tscm->card);\n}\n\nstatic const struct ieee1394_device_id snd_tscm_id_table[] = {\n\t\n\t{\n\t\t.match_flags = IEEE1394_MATCH_VENDOR_ID |\n\t\t\t       IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t       IEEE1394_MATCH_VERSION,\n\t\t.vendor_id = 0x00022e,\n\t\t.specifier_id = 0x00022e,\n\t\t.version = 0x800000,\n\t},\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t{\n\t\t.match_flags = IEEE1394_MATCH_VENDOR_ID |\n\t\t\t       IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t       IEEE1394_MATCH_VERSION,\n\t\t.vendor_id = 0x00022e,\n\t\t.specifier_id = 0x00022e,\n\t\t.version = 0x800003,\n\t},\n\t\n\t{\n\t\t.match_flags = IEEE1394_MATCH_VENDOR_ID |\n\t\t\t       IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t       IEEE1394_MATCH_VERSION,\n\t\t.vendor_id = 0x00022e,\n\t\t.specifier_id = 0x00022e,\n\t\t.version = 0x800004,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(ieee1394, snd_tscm_id_table);\n\nstatic struct fw_driver tscm_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = KBUILD_MODNAME,\n\t\t.bus = &fw_bus_type,\n\t},\n\t.probe    = snd_tscm_probe,\n\t.update   = snd_tscm_update,\n\t.remove   = snd_tscm_remove,\n\t.id_table = snd_tscm_id_table,\n};\n\nstatic int __init snd_tscm_init(void)\n{\n\treturn driver_register(&tscm_driver.driver);\n}\n\nstatic void __exit snd_tscm_exit(void)\n{\n\tdriver_unregister(&tscm_driver.driver);\n}\n\nmodule_init(snd_tscm_init);\nmodule_exit(snd_tscm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}