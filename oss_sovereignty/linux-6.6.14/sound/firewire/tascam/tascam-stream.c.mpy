{
  "module_name": "tascam-stream.c",
  "hash_id": "efd0710b15d61fb4193746ef0e2375337493a46cffc68c582c43d687c9c03e46",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/tascam/tascam-stream.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"tascam.h\"\n\n#define CLOCK_STATUS_MASK      0xffff0000\n#define CLOCK_CONFIG_MASK      0x0000ffff\n\n#define READY_TIMEOUT_MS\t4000\n\nstatic int get_clock(struct snd_tscm *tscm, u32 *data)\n{\n\tint trial = 0;\n\t__be32 reg;\n\tint err;\n\n\twhile (trial++ < 5) {\n\t\terr = snd_fw_transaction(tscm->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\tTSCM_ADDR_BASE + TSCM_OFFSET_CLOCK_STATUS,\n\t\t\t\t&reg, sizeof(reg), 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*data = be32_to_cpu(reg);\n\t\tif (*data & CLOCK_STATUS_MASK)\n\t\t\tbreak;\n\n\t\t\n\t\tmsleep(50);\n\t}\n\n\t\n\tif (trial >= 5)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int set_clock(struct snd_tscm *tscm, unsigned int rate,\n\t\t     enum snd_tscm_clock clock)\n{\n\tu32 data;\n\t__be32 reg;\n\tint err;\n\n\terr = get_clock(tscm, &data);\n\tif (err < 0)\n\t\treturn err;\n\tdata &= CLOCK_CONFIG_MASK;\n\n\tif (rate > 0) {\n\t\tdata &= 0x000000ff;\n\t\t \n\t\tif ((rate % 44100) == 0) {\n\t\t\tdata |= 0x00000100;\n\t\t\t \n\t\t\tif (rate / 44100 == 2)\n\t\t\t\tdata |= 0x00008000;\n\t\t} else if ((rate % 48000) == 0) {\n\t\t\tdata |= 0x00000200;\n\t\t\t \n\t\t\tif (rate / 48000 == 2)\n\t\t\t\tdata |= 0x00008000;\n\t\t} else {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (clock != INT_MAX) {\n\t\tdata &= 0x0000ff00;\n\t\tdata |= clock + 1;\n\t}\n\n\treg = cpu_to_be32(data);\n\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_CLOCK_STATUS,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (data & 0x00008000)\n\t\treg = cpu_to_be32(0x0000001a);\n\telse\n\t\treg = cpu_to_be32(0x0000000d);\n\n\treturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  TSCM_ADDR_BASE + TSCM_OFFSET_MULTIPLEX_MODE,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nint snd_tscm_stream_get_rate(struct snd_tscm *tscm, unsigned int *rate)\n{\n\tu32 data;\n\tint err;\n\n\terr = get_clock(tscm, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = (data & 0xff000000) >> 24;\n\n\t \n\tif ((data & 0x0f) == 0x01)\n\t\t*rate = 44100;\n\telse if ((data & 0x0f) == 0x02)\n\t\t*rate = 48000;\n\telse\n\t\treturn -EAGAIN;\n\n\t \n\tif ((data & 0xf0) == 0x80)\n\t\t*rate *= 2;\n\telse if ((data & 0xf0) != 0x00)\n\t\treturn -EAGAIN;\n\n\treturn err;\n}\n\nint snd_tscm_stream_get_clock(struct snd_tscm *tscm, enum snd_tscm_clock *clock)\n{\n\tu32 data;\n\tint err;\n\n\terr = get_clock(tscm, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\t*clock = ((data & 0x00ff0000) >> 16) - 1;\n\tif (*clock < 0 || *clock > SND_TSCM_CLOCK_ADAT)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int enable_data_channels(struct snd_tscm *tscm)\n{\n\t__be32 reg;\n\tu32 data;\n\tunsigned int i;\n\tint err;\n\n\tdata = 0;\n\tfor (i = 0; i < tscm->spec->pcm_capture_analog_channels; ++i)\n\t\tdata |= BIT(i);\n\tif (tscm->spec->has_adat)\n\t\tdata |= 0x0000ff00;\n\tif (tscm->spec->has_spdif)\n\t\tdata |= 0x00030000;\n\n\treg = cpu_to_be32(data);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_TX_PCM_CHANNELS,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = 0;\n\tfor (i = 0; i < tscm->spec->pcm_playback_analog_channels; ++i)\n\t\tdata |= BIT(i);\n\tif (tscm->spec->has_adat)\n\t\tdata |= 0x0000ff00;\n\tif (tscm->spec->has_spdif)\n\t\tdata |= 0x00030000;\n\n\treg = cpu_to_be32(data);\n\treturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  TSCM_ADDR_BASE + TSCM_OFFSET_RX_PCM_CHANNELS,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nstatic int set_stream_formats(struct snd_tscm *tscm, unsigned int rate)\n{\n\t__be32 reg;\n\tint err;\n\n\t\n\treg = cpu_to_be32(0x00200000);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_SET_OPTION,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn enable_data_channels(tscm);\n}\n\nstatic void finish_session(struct snd_tscm *tscm)\n{\n\t__be32 reg;\n\n\treg = 0;\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_START_STREAMING,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\treg = 0;\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_ON,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\t\n\treg = cpu_to_be32(0x00000000);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_CH,\n\t\t\t   &reg, sizeof(reg), 0);\n\treg = cpu_to_be32(0x00000000);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_UNKNOWN,\n\t\t\t   &reg, sizeof(reg), 0);\n\treg = cpu_to_be32(0x00000000);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_CH,\n\t\t\t   &reg, sizeof(reg), 0);\n}\n\nstatic int begin_session(struct snd_tscm *tscm)\n{\n\t__be32 reg;\n\tint err;\n\n\t\n\treg = cpu_to_be32(tscm->tx_resources.channel);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_CH,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\treg = cpu_to_be32(0x00000002);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_UNKNOWN,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\treg = cpu_to_be32(tscm->rx_resources.channel);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_CH,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treg = cpu_to_be32(0x00000001);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_START_STREAMING,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treg = cpu_to_be32(0x00000001);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_ON,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\treg = cpu_to_be32(0x00002000);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_SET_OPTION,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\treg = cpu_to_be32(0x00000001);\n\treturn snd_fw_transaction(tscm->unit,\n\t\t\t\t  TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  TSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_ON,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nstatic int keep_resources(struct snd_tscm *tscm, unsigned int rate,\n\t\t\t  struct amdtp_stream *stream)\n{\n\tstruct fw_iso_resources *resources;\n\tint err;\n\n\tif (stream == &tscm->tx_stream)\n\t\tresources = &tscm->tx_resources;\n\telse\n\t\tresources = &tscm->rx_resources;\n\n\terr = amdtp_tscm_set_parameters(stream, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn fw_iso_resources_allocate(resources,\n\t\t\t\tamdtp_stream_get_max_payload(stream),\n\t\t\t\tfw_parent_device(tscm->unit)->max_speed);\n}\n\nstatic int init_stream(struct snd_tscm *tscm, struct amdtp_stream *s)\n{\n\tstruct fw_iso_resources *resources;\n\tenum amdtp_stream_direction dir;\n\tunsigned int pcm_channels;\n\tint err;\n\n\tif (s == &tscm->tx_stream) {\n\t\tresources = &tscm->tx_resources;\n\t\tdir = AMDTP_IN_STREAM;\n\t\tpcm_channels = tscm->spec->pcm_capture_analog_channels;\n\t} else {\n\t\tresources = &tscm->rx_resources;\n\t\tdir = AMDTP_OUT_STREAM;\n\t\tpcm_channels = tscm->spec->pcm_playback_analog_channels;\n\t}\n\n\tif (tscm->spec->has_adat)\n\t\tpcm_channels += 8;\n\tif (tscm->spec->has_spdif)\n\t\tpcm_channels += 2;\n\n\terr = fw_iso_resources_init(resources, tscm->unit);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_tscm_init(s, tscm->unit, dir, pcm_channels);\n\tif (err < 0)\n\t\tfw_iso_resources_free(resources);\n\n\treturn err;\n}\n\nstatic void destroy_stream(struct snd_tscm *tscm, struct amdtp_stream *s)\n{\n\tamdtp_stream_destroy(s);\n\n\tif (s == &tscm->tx_stream)\n\t\tfw_iso_resources_destroy(&tscm->tx_resources);\n\telse\n\t\tfw_iso_resources_destroy(&tscm->rx_resources);\n}\n\nint snd_tscm_stream_init_duplex(struct snd_tscm *tscm)\n{\n\tint err;\n\n\terr = init_stream(tscm, &tscm->tx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(tscm, &tscm->rx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(tscm, &tscm->tx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&tscm->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(tscm, &tscm->tx_stream);\n\t\tdestroy_stream(tscm, &tscm->rx_stream);\n\t}\n\n\treturn err;\n}\n\n\nvoid snd_tscm_stream_update_duplex(struct snd_tscm *tscm)\n{\n\tamdtp_domain_stop(&tscm->domain);\n\n\tamdtp_stream_pcm_abort(&tscm->tx_stream);\n\tamdtp_stream_pcm_abort(&tscm->rx_stream);\n}\n\n\n\nvoid snd_tscm_stream_destroy_duplex(struct snd_tscm *tscm)\n{\n\tamdtp_domain_destroy(&tscm->domain);\n\n\tdestroy_stream(tscm, &tscm->rx_stream);\n\tdestroy_stream(tscm, &tscm->tx_stream);\n}\n\nint snd_tscm_stream_reserve_duplex(struct snd_tscm *tscm, unsigned int rate,\n\t\t\t\t   unsigned int frames_per_period,\n\t\t\t\t   unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tint err;\n\n\terr = snd_tscm_stream_get_rate(tscm, &curr_rate);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tscm->substreams_counter == 0 || rate != curr_rate) {\n\t\tamdtp_domain_stop(&tscm->domain);\n\n\t\tfinish_session(tscm);\n\n\t\tfw_iso_resources_free(&tscm->tx_resources);\n\t\tfw_iso_resources_free(&tscm->rx_resources);\n\n\t\terr = set_clock(tscm, rate, INT_MAX);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(tscm, rate, &tscm->tx_stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = keep_resources(tscm, rate, &tscm->rx_stream);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&tscm->tx_resources);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = amdtp_domain_set_events_per_period(&tscm->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&tscm->tx_resources);\n\t\t\tfw_iso_resources_free(&tscm->rx_resources);\n\t\t\treturn err;\n\t\t}\n\n\t\ttscm->need_long_tx_init_skip = (rate != curr_rate);\n\t}\n\n\treturn 0;\n}\n\nint snd_tscm_stream_start_duplex(struct snd_tscm *tscm, unsigned int rate)\n{\n\tunsigned int generation = tscm->rx_resources.generation;\n\tint err;\n\n\tif (tscm->substreams_counter == 0)\n\t\treturn 0;\n\n\tif (amdtp_streaming_error(&tscm->rx_stream) ||\n\t    amdtp_streaming_error(&tscm->tx_stream)) {\n\t\tamdtp_domain_stop(&tscm->domain);\n\t\tfinish_session(tscm);\n\t}\n\n\tif (generation != fw_parent_device(tscm->unit)->card->generation) {\n\t\terr = fw_iso_resources_update(&tscm->tx_resources);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = fw_iso_resources_update(&tscm->rx_resources);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (!amdtp_stream_running(&tscm->rx_stream)) {\n\t\tint spd = fw_parent_device(tscm->unit)->max_speed;\n\t\tunsigned int tx_init_skip_cycles;\n\n\t\terr = set_stream_formats(tscm, rate);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = begin_session(tscm);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&tscm->domain, &tscm->rx_stream,\n\t\t\t\t\t      tscm->rx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&tscm->domain, &tscm->tx_stream,\n\t\t\t\t\t      tscm->tx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (tscm->need_long_tx_init_skip)\n\t\t\ttx_init_skip_cycles = 16000;\n\t\telse\n\t\t\ttx_init_skip_cycles = 0;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&tscm->domain, tx_init_skip_cycles, true, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&tscm->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&tscm->domain);\n\tfinish_session(tscm);\n\n\treturn err;\n}\n\nvoid snd_tscm_stream_stop_duplex(struct snd_tscm *tscm)\n{\n\tif (tscm->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&tscm->domain);\n\t\tfinish_session(tscm);\n\n\t\tfw_iso_resources_free(&tscm->tx_resources);\n\t\tfw_iso_resources_free(&tscm->rx_resources);\n\n\t\ttscm->need_long_tx_init_skip = false;\n\t}\n}\n\nvoid snd_tscm_stream_lock_changed(struct snd_tscm *tscm)\n{\n\ttscm->dev_lock_changed = true;\n\twake_up(&tscm->hwdep_wait);\n}\n\nint snd_tscm_stream_lock_try(struct snd_tscm *tscm)\n{\n\tint err;\n\n\tspin_lock_irq(&tscm->lock);\n\n\t \n\tif (tscm->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (tscm->dev_lock_count++ == 0)\n\t\tsnd_tscm_stream_lock_changed(tscm);\n\terr = 0;\nend:\n\tspin_unlock_irq(&tscm->lock);\n\treturn err;\n}\n\nvoid snd_tscm_stream_lock_release(struct snd_tscm *tscm)\n{\n\tspin_lock_irq(&tscm->lock);\n\n\tif (WARN_ON(tscm->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--tscm->dev_lock_count == 0)\n\t\tsnd_tscm_stream_lock_changed(tscm);\nend:\n\tspin_unlock_irq(&tscm->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}