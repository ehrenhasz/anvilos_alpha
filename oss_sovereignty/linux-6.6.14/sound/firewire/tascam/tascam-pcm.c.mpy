{
  "module_name": "tascam-pcm.c",
  "hash_id": "2d1d8722cb42628ebe66c3f8854eb244a275605fc4224f9547d0ab7b2973d710",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/tascam/tascam-pcm.c",
  "human_readable_source": "\n \n\n#include \"tascam.h\"\n\nstatic int pcm_init_hw_params(struct snd_tscm *tscm,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tstruct amdtp_stream *stream;\n\tunsigned int pcm_channels;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S32;\n\t\tstream = &tscm->tx_stream;\n\t\tpcm_channels = tscm->spec->pcm_capture_analog_channels;\n\t} else {\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S32;\n\t\tstream = &tscm->rx_stream;\n\t\tpcm_channels = tscm->spec->pcm_playback_analog_channels;\n\t}\n\n\tif (tscm->spec->has_adat)\n\t\tpcm_channels += 8;\n\tif (tscm->spec->has_spdif)\n\t\tpcm_channels += 2;\n\truntime->hw.channels_min = runtime->hw.channels_max = pcm_channels;\n\n\thw->rates = SNDRV_PCM_RATE_44100 |\n\t\t    SNDRV_PCM_RATE_48000 |\n\t\t    SNDRV_PCM_RATE_88200 |\n\t\t    SNDRV_PCM_RATE_96000;\n\tsnd_pcm_limit_hw_rates(runtime);\n\n\treturn amdtp_tscm_add_pcm_hw_constraints(stream, runtime);\n}\n\nstatic int pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\tstruct amdtp_domain *d = &tscm->domain;\n\tenum snd_tscm_clock clock;\n\tint err;\n\n\terr = snd_tscm_stream_lock_try(tscm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pcm_init_hw_params(tscm, substream);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\terr = snd_tscm_stream_get_clock(tscm, &clock);\n\tif (err < 0)\n\t\tgoto err_locked;\n\n\tmutex_lock(&tscm->mutex);\n\n\t\n\t\n\t\n\tif (clock != SND_TSCM_CLOCK_INTERNAL || tscm->substreams_counter > 0) {\n\t\tunsigned int frames_per_period = d->events_per_period;\n\t\tunsigned int frames_per_buffer = d->events_per_buffer;\n\t\tunsigned int rate;\n\n\t\terr = snd_tscm_stream_get_rate(tscm, &rate);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&tscm->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\t\tsubstream->runtime->hw.rate_min = rate;\n\t\tsubstream->runtime->hw.rate_max = rate;\n\n\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\tframes_per_period, frames_per_period);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&tscm->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\n\t\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\tframes_per_buffer, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&tscm->mutex);\n\t\t\tgoto err_locked;\n\t\t}\n\t}\n\n\tmutex_unlock(&tscm->mutex);\n\n\tsnd_pcm_set_sync(substream);\n\n\treturn 0;\nerr_locked:\n\tsnd_tscm_stream_lock_release(tscm);\n\treturn err;\n}\n\nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\tsnd_tscm_stream_lock_release(tscm);\n\n\treturn 0;\n}\n\nstatic int pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\tint err = 0;\n\n\tif (substream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tunsigned int rate = params_rate(hw_params);\n\t\tunsigned int frames_per_period = params_period_size(hw_params);\n\t\tunsigned int frames_per_buffer = params_buffer_size(hw_params);\n\n\t\tmutex_lock(&tscm->mutex);\n\t\terr = snd_tscm_stream_reserve_duplex(tscm, rate,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err >= 0)\n\t\t\t++tscm->substreams_counter;\n\t\tmutex_unlock(&tscm->mutex);\n\t}\n\n\treturn err;\n}\n\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\tmutex_lock(&tscm->mutex);\n\n\tif (substream->runtime->state != SNDRV_PCM_STATE_OPEN)\n\t\t--tscm->substreams_counter;\n\n\tsnd_tscm_stream_stop_duplex(tscm);\n\n\tmutex_unlock(&tscm->mutex);\n\n\treturn 0;\n}\n\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tmutex_lock(&tscm->mutex);\n\n\terr = snd_tscm_stream_start_duplex(tscm, runtime->rate);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(&tscm->tx_stream);\n\n\tmutex_unlock(&tscm->mutex);\n\n\treturn err;\n}\n\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tmutex_lock(&tscm->mutex);\n\n\terr = snd_tscm_stream_start_duplex(tscm, runtime->rate);\n\tif (err >= 0)\n\t\tamdtp_stream_pcm_prepare(&tscm->rx_stream);\n\n\tmutex_unlock(&tscm->mutex);\n\n\treturn err;\n}\n\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(&tscm->tx_stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(&tscm->tx_stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tamdtp_stream_pcm_trigger(&tscm->rx_stream, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tamdtp_stream_pcm_trigger(&tscm->rx_stream, NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstrm)\n{\n\tstruct snd_tscm *tscm = sbstrm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&tscm->domain, &tscm->tx_stream);\n}\n\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstrm)\n{\n\tstruct snd_tscm *tscm = sbstrm->private_data;\n\n\treturn amdtp_domain_stream_pcm_pointer(&tscm->domain, &tscm->rx_stream);\n}\n\nstatic int pcm_capture_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&tscm->domain, &tscm->tx_stream);\n}\n\nstatic int pcm_playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_tscm *tscm = substream->private_data;\n\n\treturn amdtp_domain_stream_pcm_ack(&tscm->domain, &tscm->rx_stream);\n}\n\nint snd_tscm_create_pcm_devices(struct snd_tscm *tscm)\n{\n\tstatic const struct snd_pcm_ops capture_ops = {\n\t\t.open\t\t= pcm_open,\n\t\t.close\t\t= pcm_close,\n\t\t.hw_params\t= pcm_hw_params,\n\t\t.hw_free\t= pcm_hw_free,\n\t\t.prepare\t= pcm_capture_prepare,\n\t\t.trigger\t= pcm_capture_trigger,\n\t\t.pointer\t= pcm_capture_pointer,\n\t\t.ack\t\t= pcm_capture_ack,\n\t};\n\tstatic const struct snd_pcm_ops playback_ops = {\n\t\t.open\t\t= pcm_open,\n\t\t.close\t\t= pcm_close,\n\t\t.hw_params\t= pcm_hw_params,\n\t\t.hw_free\t= pcm_hw_free,\n\t\t.prepare\t= pcm_playback_prepare,\n\t\t.trigger\t= pcm_playback_trigger,\n\t\t.pointer\t= pcm_playback_pointer,\n\t\t.ack\t\t= pcm_playback_ack,\n\t};\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(tscm->card, tscm->card->driver, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = tscm;\n\tsnprintf(pcm->name, sizeof(pcm->name),\n\t\t \"%s PCM\", tscm->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}