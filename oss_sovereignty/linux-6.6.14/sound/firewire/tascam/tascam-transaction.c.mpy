{
  "module_name": "tascam-transaction.c",
  "hash_id": "f32afda77b97f1e1741dd5f0b1b66b29a63f45ad9f5b7eba6f4a9ecb3c09d6f4",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/tascam/tascam-transaction.c",
  "human_readable_source": "\n \n\n#include \"tascam.h\"\n\n \nstatic inline int calculate_message_bytes(u8 status)\n{\n\tswitch (status) {\n\tcase 0xf6:\t \n\tcase 0xf8:\t \n\tcase 0xfa:\t \n\tcase 0xfb:\t \n\tcase 0xfc:\t \n\tcase 0xfe:\t \n\tcase 0xff:\t \n\t\treturn 1;\n\tcase 0xf1:\t \n\tcase 0xf3:\t \n\t\treturn 2;\n\tcase 0xf2:\t \n\t\treturn 3;\n\tcase 0xf0:\t \n\t\treturn 0;\n\tcase 0xf7:\t \n\t\tbreak;\n\tcase 0xf4:\t \n\tcase 0xf5:\t \n\tcase 0xf9:\t \n\tcase 0xfd:\t \n\t\tbreak;\n\tdefault:\n\t\tswitch (status & 0xf0) {\n\t\tcase 0x80:\t \n\t\tcase 0x90:\t \n\t\tcase 0xa0:\t \n\t\tcase 0xb0:\t \n\t\tcase 0xe0:\t \n\t\t\treturn 3;\n\t\tcase 0xc0:\t \n\t\tcase 0xd0:\t \n\t\t\treturn 2;\n\t\tdefault:\n\t\tbreak;\n\t\t}\n\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fill_message(struct snd_fw_async_midi_port *port,\n\t\t\tstruct snd_rawmidi_substream *substream)\n{\n\tint i, len, consume;\n\tu8 *label, *msg;\n\tu8 status;\n\n\t \n\tlabel = port->buf;\n\tmsg = port->buf + 1;\n\n\tconsume = snd_rawmidi_transmit_peek(substream, msg, 3);\n\tif (consume == 0)\n\t\treturn 0;\n\n\t \n\tif (port->on_sysex) {\n\t\t \n\t\tfor (i = 0; i < consume; ++i) {\n\t\t\tif (msg[i] == 0xf7) {\n\t\t\t\tport->on_sysex = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!port->on_sysex) {\n\t\t\tconsume = i + 1;\n\t\t\t*label = (substream->number << 4) | 0x07;\n\t\t \n\t\t} else if (consume == 3) {\n\t\t\t*label = (substream->number << 4) | 0x04;\n\t\t \n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = consume;\n\t} else {\n\t\t \n\t\tif (msg[0] == 0xf0) {\n\t\t\t \n\t\t\tport->on_sysex = true;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tif ((msg[0] & 0x80) != 0x80)\n\t\t\t\tstatus = port->running_status;\n\t\t\telse\n\t\t\t\tstatus = msg[0];\n\n\t\t\t \n\t\t\tlen = calculate_message_bytes(status);\n\t\t\tif (len <= 0)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif ((msg[0] & 0x80) != 0x80) {\n\t\t\t\t \n\t\t\t\tif (consume < len - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tconsume = len - 1;\n\n\t\t\t\tmsg[2] = msg[1];\n\t\t\t\tmsg[1] = msg[0];\n\t\t\t\tmsg[0] = port->running_status;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (consume < len)\n\t\t\t\t\treturn 0;\n\t\t\t\tconsume = len;\n\n\t\t\t\tport->running_status = msg[0];\n\t\t\t}\n\t\t}\n\n\t\t*label = (substream->number << 4) | (msg[0] >> 4);\n\t}\n\n\tif (len > 0 && len < 3)\n\t\tmemset(msg + len, 0, 3 - len);\n\n\treturn consume;\n}\n\nstatic void async_midi_port_callback(struct fw_card *card, int rcode,\n\t\t\t\t     void *data, size_t length,\n\t\t\t\t     void *callback_data)\n{\n\tstruct snd_fw_async_midi_port *port = callback_data;\n\tstruct snd_rawmidi_substream *substream = READ_ONCE(port->substream);\n\n\t \n\tif (substream == NULL)\n\t\treturn;\n\n\tif (rcode == RCODE_COMPLETE)\n\t\tsnd_rawmidi_transmit_ack(substream, port->consume_bytes);\n\telse if (!rcode_is_permanent_error(rcode))\n\t\t \n\t\tport->next_ktime = 0;\n\telse\n\t\t \n\t\tport->error = true;\n\n\tport->idling = true;\n\n\tif (!snd_rawmidi_transmit_empty(substream))\n\t\tschedule_work(&port->work);\n}\n\nstatic void midi_port_work(struct work_struct *work)\n{\n\tstruct snd_fw_async_midi_port *port =\n\t\t\tcontainer_of(work, struct snd_fw_async_midi_port, work);\n\tstruct snd_rawmidi_substream *substream = READ_ONCE(port->substream);\n\tint generation;\n\n\t \n\tif (!port->idling || port->error)\n\t\treturn;\n\n\t \n\tif (substream == NULL || snd_rawmidi_transmit_empty(substream))\n\t\treturn;\n\n\t \n\tif (ktime_after(port->next_ktime, ktime_get())) {\n\t\tschedule_work(&port->work);\n\t\treturn;\n\t}\n\n\t \n\tmemset(port->buf, 0, 4);\n\tport->consume_bytes = fill_message(port, substream);\n\tif (port->consume_bytes <= 0) {\n\t\t \n\t\tif (port->consume_bytes == 0) {\n\t\t\tport->next_ktime = 0;\n\t\t\tschedule_work(&port->work);\n\t\t} else {\n\t\t\t \n\t\t\tport->error = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tport->next_ktime = ktime_add_ns(ktime_get(),\n\t\t\tport->consume_bytes * 8 * (NSEC_PER_SEC / 31250));\n\n\t \n\tport->idling = false;\n\n\t \n\tgeneration = port->parent->generation;\n\tsmp_rmb();\n\n\tfw_send_request(port->parent->card, &port->transaction,\n\t\t\tTCODE_WRITE_QUADLET_REQUEST,\n\t\t\tport->parent->node_id, generation,\n\t\t\tport->parent->max_speed,\n\t\t\tTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,\n\t\t\tport->buf, 4, async_midi_port_callback,\n\t\t\tport);\n}\n\nvoid snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port)\n{\n\tport->idling = true;\n\tport->error = false;\n\tport->running_status = 0;\n\tport->on_sysex = false;\n}\n\nstatic void handle_midi_tx(struct fw_card *card, struct fw_request *request,\n\t\t\t   int tcode, int destination, int source,\n\t\t\t   int generation, unsigned long long offset,\n\t\t\t   void *data, size_t length, void *callback_data)\n{\n\tstruct snd_tscm *tscm = callback_data;\n\tu32 *buf = (u32 *)data;\n\tunsigned int messages;\n\tunsigned int i;\n\tunsigned int port;\n\tstruct snd_rawmidi_substream *substream;\n\tu8 *b;\n\tint bytes;\n\n\tif (offset != tscm->async_handler.offset)\n\t\tgoto end;\n\n\tmessages = length / 8;\n\tfor (i = 0; i < messages; i++) {\n\t\tb = (u8 *)(buf + i * 2);\n\n\t\tport = b[0] >> 4;\n\t\t \n\t\tif (port >= tscm->spec->midi_capture_ports)\n\t\t\tgoto end;\n\n\t\t \n\t\tbytes = calculate_message_bytes(b[1]);\n\t\t \n\t\tif (bytes <= 0) {\n\t\t\t \n\t\t\tfor (bytes = 1; bytes < 4; bytes++) {\n\t\t\t\tif (b[bytes] == 0xf7)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bytes == 4)\n\t\t\t\tbytes = 3;\n\t\t}\n\n\t\tsubstream = READ_ONCE(tscm->tx_midi_substreams[port]);\n\t\tif (substream != NULL)\n\t\t\tsnd_rawmidi_receive(substream, b + 1, bytes);\n\t}\nend:\n\tfw_send_response(card, request, RCODE_COMPLETE);\n}\n\nint snd_tscm_transaction_register(struct snd_tscm *tscm)\n{\n\tstatic const struct fw_address_region resp_register_region = {\n\t\t.start\t= 0xffffe0000000ull,\n\t\t.end\t= 0xffffe000ffffull,\n\t};\n\tunsigned int i;\n\tint err;\n\n\t \n\ttscm->async_handler.length = 8 * 8;\n\ttscm->async_handler.address_callback = handle_midi_tx;\n\ttscm->async_handler.callback_data = tscm;\n\n\terr = fw_core_add_address_handler(&tscm->async_handler,\n\t\t\t\t\t  &resp_register_region);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_tscm_transaction_reregister(tscm);\n\tif (err < 0)\n\t\tgoto error;\n\n\tfor (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {\n\t\ttscm->out_ports[i].parent = fw_parent_device(tscm->unit);\n\t\ttscm->out_ports[i].next_ktime = 0;\n\t\tINIT_WORK(&tscm->out_ports[i].work, midi_port_work);\n\t}\n\n\treturn err;\nerror:\n\tfw_core_remove_address_handler(&tscm->async_handler);\n\ttscm->async_handler.callback_data = NULL;\n\treturn err;\n}\n\n \nint snd_tscm_transaction_reregister(struct snd_tscm *tscm)\n{\n\tstruct fw_device *device = fw_parent_device(tscm->unit);\n\t__be32 reg;\n\tint err;\n\n\t \n\treg = cpu_to_be32((device->card->node_id << 16) |\n\t\t\t  (tscm->async_handler.offset >> 32));\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treg = cpu_to_be32(tscm->async_handler.offset);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\n\t\t\t\t &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treg = cpu_to_be32(0x00000001);\n\terr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\n\t\t\t\t  &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treg = cpu_to_be32(0x0001008e);\n\treturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  TSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nvoid snd_tscm_transaction_unregister(struct snd_tscm *tscm)\n{\n\t__be32 reg;\n\n\tif (tscm->async_handler.callback_data == NULL)\n\t\treturn;\n\n\t \n\treg = cpu_to_be32(0x0000008e);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\t \n\treg = cpu_to_be32(0x00000000);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\t \n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\n\t\t\t   &reg, sizeof(reg), 0);\n\tsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\tfw_core_remove_address_handler(&tscm->async_handler);\n\ttscm->async_handler.callback_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}