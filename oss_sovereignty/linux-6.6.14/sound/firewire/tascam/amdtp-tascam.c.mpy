{
  "module_name": "amdtp-tascam.c",
  "hash_id": "1d9f9f4a28fd9e09e37db0da27f21c3157f0c419c716977c7a7a2c47bdbfc64a",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/tascam/amdtp-tascam.c",
  "human_readable_source": "\n \n\n#include <sound/pcm.h>\n#include \"tascam.h\"\n\n#define AMDTP_FMT_TSCM_TX\t0x1e\n#define AMDTP_FMT_TSCM_RX\t0x3e\n\nstruct amdtp_tscm {\n\tunsigned int pcm_channels;\n};\n\nint amdtp_tscm_set_parameters(struct amdtp_stream *s, unsigned int rate)\n{\n\tstruct amdtp_tscm *p = s->protocol;\n\tunsigned int data_channels;\n\n\tif (amdtp_stream_running(s))\n\t\treturn -EBUSY;\n\n\tdata_channels = p->pcm_channels;\n\n\t \n\tif (s->direction == AMDTP_IN_STREAM)\n\t\tdata_channels += 2;\n\n\treturn amdtp_stream_set_parameters(s, rate, data_channels, 1);\n}\n\nstatic void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t  __be32 *buffer, unsigned int frames,\n\t\t\t  unsigned int pcm_frames)\n{\n\tstruct amdtp_tscm *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tconst u32 *src;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tsrc = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\tbuffer[c] = cpu_to_be32(*src);\n\t\t\tsrc++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tsrc = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,\n\t\t\t __be32 *buffer, unsigned int frames,\n\t\t\t unsigned int pcm_frames)\n{\n\tstruct amdtp_tscm *p = s->protocol;\n\tunsigned int channels = p->pcm_channels;\n\tstruct snd_pcm_runtime *runtime = pcm->runtime;\n\tunsigned int pcm_buffer_pointer;\n\tint remaining_frames;\n\tu32 *dst;\n\tint i, c;\n\n\tpcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;\n\tpcm_buffer_pointer %= runtime->buffer_size;\n\n\tdst  = (void *)runtime->dma_area +\n\t\t\t\tframes_to_bytes(runtime, pcm_buffer_pointer);\n\tremaining_frames = runtime->buffer_size - pcm_buffer_pointer;\n\n\t \n\tbuffer += 1;\n\n\tfor (i = 0; i < frames; ++i) {\n\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t*dst = be32_to_cpu(buffer[c]);\n\t\t\tdst++;\n\t\t}\n\t\tbuffer += s->data_block_quadlets;\n\t\tif (--remaining_frames == 0)\n\t\t\tdst = (void *)runtime->dma_area;\n\t}\n}\n\nstatic void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,\n\t\t\t      unsigned int data_blocks)\n{\n\tstruct amdtp_tscm *p = s->protocol;\n\tunsigned int channels, i, c;\n\n\tchannels = p->pcm_channels;\n\n\tfor (i = 0; i < data_blocks; ++i) {\n\t\tfor (c = 0; c < channels; ++c)\n\t\t\tbuffer[c] = 0x00000000;\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nint amdtp_tscm_add_pcm_hw_constraints(struct amdtp_stream *s,\n\t\t\t\t      struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\t \n\terr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn amdtp_stream_add_pcm_hw_constraints(s, runtime);\n}\n\nstatic void read_status_messages(struct amdtp_stream *s,\n\t\t\t\t __be32 *buffer, unsigned int data_blocks)\n{\n\tstruct snd_tscm *tscm = container_of(s, struct snd_tscm, tx_stream);\n\tbool used = READ_ONCE(tscm->hwdep->used);\n\tint i;\n\n\tfor (i = 0; i < data_blocks; i++) {\n\t\tunsigned int index;\n\t\t__be32 before;\n\t\t__be32 after;\n\n\t\tindex = be32_to_cpu(buffer[0]) % SNDRV_FIREWIRE_TASCAM_STATE_COUNT;\n\t\tbefore = tscm->state[index];\n\t\tafter = buffer[s->data_block_quadlets - 1];\n\n\t\tif (used && index > 4 && index < 16) {\n\t\t\t__be32 mask;\n\n\t\t\tif (index == 5)\n\t\t\t\tmask = cpu_to_be32(~0x0000ffff);\n\t\t\telse if (index == 6)\n\t\t\t\tmask = cpu_to_be32(~0x0000ffff);\n\t\t\telse if (index == 8)\n\t\t\t\tmask = cpu_to_be32(~0x000f0f00);\n\t\t\telse\n\t\t\t\tmask = cpu_to_be32(~0x00000000);\n\n\t\t\tif ((before ^ after) & mask) {\n\t\t\t\tstruct snd_firewire_tascam_change *entry =\n\t\t\t\t\t\t&tscm->queue[tscm->push_pos];\n\t\t\t\tunsigned long flag;\n\n\t\t\t\tspin_lock_irqsave(&tscm->lock, flag);\n\t\t\t\tentry->index = index;\n\t\t\t\tentry->before = before;\n\t\t\t\tentry->after = after;\n\t\t\t\tif (++tscm->push_pos >= SND_TSCM_QUEUE_COUNT)\n\t\t\t\t\ttscm->push_pos = 0;\n\t\t\t\tspin_unlock_irqrestore(&tscm->lock, flag);\n\n\t\t\t\twake_up(&tscm->hwdep_wait);\n\t\t\t}\n\t\t}\n\n\t\ttscm->state[index] = after;\n\t\tbuffer += s->data_block_quadlets;\n\t}\n}\n\nstatic void process_ir_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\tread_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t}\n\n\t\tread_status_messages(s, buf, data_blocks);\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nstatic void process_it_ctx_payloads(struct amdtp_stream *s, const struct pkt_desc *desc,\n\t\t\t\t    unsigned int count, struct snd_pcm_substream *pcm)\n{\n\tunsigned int pcm_frames = 0;\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\t__be32 *buf = desc->ctx_payload;\n\t\tunsigned int data_blocks = desc->data_blocks;\n\n\t\tif (pcm) {\n\t\t\twrite_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);\n\t\t\tpcm_frames += data_blocks;\n\t\t} else {\n\t\t\twrite_pcm_silence(s, buf, data_blocks);\n\t\t}\n\n\t\tdesc = amdtp_stream_next_packet_desc(s, desc);\n\t}\n}\n\nint amdtp_tscm_init(struct amdtp_stream *s, struct fw_unit *unit,\n\t\t    enum amdtp_stream_direction dir, unsigned int pcm_channels)\n{\n\tamdtp_stream_process_ctx_payloads_t process_ctx_payloads;\n\tunsigned int flags = CIP_NONBLOCKING | CIP_SKIP_DBC_ZERO_CHECK | CIP_UNAWARE_SYT;\n\tstruct amdtp_tscm *p;\n\tunsigned int fmt;\n\tint err;\n\n\tif (dir == AMDTP_IN_STREAM) {\n\t\tfmt = AMDTP_FMT_TSCM_TX;\n\t\tprocess_ctx_payloads = process_ir_ctx_payloads;\n\t} else {\n\t\tfmt = AMDTP_FMT_TSCM_RX;\n\t\tprocess_ctx_payloads = process_it_ctx_payloads;\n\t}\n\n\terr = amdtp_stream_init(s, unit, dir, flags, fmt,\n\t\t\tprocess_ctx_payloads, sizeof(struct amdtp_tscm));\n\tif (err < 0)\n\t\treturn 0;\n\n\tif (dir == AMDTP_OUT_STREAM) {\n\t\t\n\t\ts->ctx_data.rx.fdf = 0x00;\n\t}\n\n\t \n\tp = s->protocol;\n\tp->pcm_channels = pcm_channels;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}