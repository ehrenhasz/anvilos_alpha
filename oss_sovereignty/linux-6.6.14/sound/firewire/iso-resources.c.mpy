{
  "module_name": "iso-resources.c",
  "hash_id": "3dc3248b60ab1181b1d7388eb2f0e61aee5bc2a122b28473784ca0f00e001ed9",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/iso-resources.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/export.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include \"iso-resources.h\"\n\n \nint fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)\n{\n\tr->channels_mask = ~0uLL;\n\tr->unit = unit;\n\tmutex_init(&r->mutex);\n\tr->allocated = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fw_iso_resources_init);\n\n \nvoid fw_iso_resources_destroy(struct fw_iso_resources *r)\n{\n\tWARN_ON(r->allocated);\n\tmutex_destroy(&r->mutex);\n}\nEXPORT_SYMBOL(fw_iso_resources_destroy);\n\nstatic unsigned int packet_bandwidth(unsigned int max_payload_bytes, int speed)\n{\n\tunsigned int bytes, s400_bytes;\n\n\t \n\tbytes = 3 * 4 + ALIGN(max_payload_bytes, 4);\n\n\t \n\tif (speed <= SCODE_400)\n\t\ts400_bytes = bytes * (1 << (SCODE_400 - speed));\n\telse\n\t\ts400_bytes = DIV_ROUND_UP(bytes, 1 << (speed - SCODE_400));\n\n\treturn s400_bytes;\n}\n\nstatic int current_bandwidth_overhead(struct fw_card *card)\n{\n\t \n\treturn card->gap_count < 63 ? card->gap_count * 97 / 10 + 89 : 512;\n}\n\nstatic int wait_isoch_resource_delay_after_bus_reset(struct fw_card *card)\n{\n\tfor (;;) {\n\t\ts64 delay = (card->reset_jiffies + HZ) - get_jiffies_64();\n\t\tif (delay <= 0)\n\t\t\treturn 0;\n\t\tif (schedule_timeout_interruptible(delay) > 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n}\n\n \nint fw_iso_resources_allocate(struct fw_iso_resources *r,\n\t\t\t      unsigned int max_payload_bytes, int speed)\n{\n\tstruct fw_card *card = fw_parent_device(r->unit)->card;\n\tint bandwidth, channel, err;\n\n\tif (WARN_ON(r->allocated))\n\t\treturn -EBADFD;\n\n\tr->bandwidth = packet_bandwidth(max_payload_bytes, speed);\n\nretry_after_bus_reset:\n\tspin_lock_irq(&card->lock);\n\tr->generation = card->generation;\n\tr->bandwidth_overhead = current_bandwidth_overhead(card);\n\tspin_unlock_irq(&card->lock);\n\n\terr = wait_isoch_resource_delay_after_bus_reset(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&r->mutex);\n\n\tbandwidth = r->bandwidth + r->bandwidth_overhead;\n\tfw_iso_resource_manage(card, r->generation, r->channels_mask,\n\t\t\t       &channel, &bandwidth, true);\n\tif (channel == -EAGAIN) {\n\t\tmutex_unlock(&r->mutex);\n\t\tgoto retry_after_bus_reset;\n\t}\n\tif (channel >= 0) {\n\t\tr->channel = channel;\n\t\tr->allocated = true;\n\t} else {\n\t\tif (channel == -EBUSY)\n\t\t\tdev_err(&r->unit->device,\n\t\t\t\t\"isochronous resources exhausted\\n\");\n\t\telse\n\t\t\tdev_err(&r->unit->device,\n\t\t\t\t\"isochronous resource allocation failed\\n\");\n\t}\n\n\tmutex_unlock(&r->mutex);\n\n\treturn channel;\n}\nEXPORT_SYMBOL(fw_iso_resources_allocate);\n\n \nint fw_iso_resources_update(struct fw_iso_resources *r)\n{\n\tstruct fw_card *card = fw_parent_device(r->unit)->card;\n\tint bandwidth, channel;\n\n\tmutex_lock(&r->mutex);\n\n\tif (!r->allocated) {\n\t\tmutex_unlock(&r->mutex);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&card->lock);\n\tr->generation = card->generation;\n\tr->bandwidth_overhead = current_bandwidth_overhead(card);\n\tspin_unlock_irq(&card->lock);\n\n\tbandwidth = r->bandwidth + r->bandwidth_overhead;\n\n\tfw_iso_resource_manage(card, r->generation, 1uLL << r->channel,\n\t\t\t       &channel, &bandwidth, true);\n\t \n\tif (channel < 0 && channel != -EAGAIN) {\n\t\tr->allocated = false;\n\t\tif (channel == -EBUSY)\n\t\t\tdev_err(&r->unit->device,\n\t\t\t\t\"isochronous resources exhausted\\n\");\n\t\telse\n\t\t\tdev_err(&r->unit->device,\n\t\t\t\t\"isochronous resource allocation failed\\n\");\n\t}\n\n\tmutex_unlock(&r->mutex);\n\n\treturn channel;\n}\nEXPORT_SYMBOL(fw_iso_resources_update);\n\n \nvoid fw_iso_resources_free(struct fw_iso_resources *r)\n{\n\tstruct fw_card *card;\n\tint bandwidth, channel;\n\n\t \n\tif (r->unit == NULL)\n\t\treturn;\n\tcard = fw_parent_device(r->unit)->card;\n\n\tmutex_lock(&r->mutex);\n\n\tif (r->allocated) {\n\t\tbandwidth = r->bandwidth + r->bandwidth_overhead;\n\t\tfw_iso_resource_manage(card, r->generation, 1uLL << r->channel,\n\t\t\t\t       &channel, &bandwidth, false);\n\t\tif (channel < 0)\n\t\t\tdev_err(&r->unit->device,\n\t\t\t\t\"isochronous resource deallocation failed\\n\");\n\n\t\tr->allocated = false;\n\t}\n\n\tmutex_unlock(&r->mutex);\n}\nEXPORT_SYMBOL(fw_iso_resources_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}