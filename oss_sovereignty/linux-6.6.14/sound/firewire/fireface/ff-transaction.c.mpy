{
  "module_name": "ff-transaction.c",
  "hash_id": "6cef48e69c6cc0d48264b44cfc802516f43b8d1bf745f97ca926cee695333978",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireface/ff-transaction.c",
  "human_readable_source": "\n \n\n#include \"ff.h\"\n\nstatic void finish_transmit_midi_msg(struct snd_ff *ff, unsigned int port,\n\t\t\t\t     int rcode)\n{\n\tstruct snd_rawmidi_substream *substream =\n\t\t\t\tREAD_ONCE(ff->rx_midi_substreams[port]);\n\n\tif (rcode_is_permanent_error(rcode)) {\n\t\tff->rx_midi_error[port] = true;\n\t\treturn;\n\t}\n\n\tif (rcode != RCODE_COMPLETE) {\n\t\t \n\t\tff->next_ktime[port] = 0;\n\t\tschedule_work(&ff->rx_midi_work[port]);\n\t\treturn;\n\t}\n\n\tsnd_rawmidi_transmit_ack(substream, ff->rx_bytes[port]);\n\tff->rx_bytes[port] = 0;\n\n\tif (!snd_rawmidi_transmit_empty(substream))\n\t\tschedule_work(&ff->rx_midi_work[port]);\n}\n\nstatic void finish_transmit_midi0_msg(struct fw_card *card, int rcode,\n\t\t\t\t      void *data, size_t length,\n\t\t\t\t      void *callback_data)\n{\n\tstruct snd_ff *ff =\n\t\tcontainer_of(callback_data, struct snd_ff, transactions[0]);\n\tfinish_transmit_midi_msg(ff, 0, rcode);\n}\n\nstatic void finish_transmit_midi1_msg(struct fw_card *card, int rcode,\n\t\t\t\t      void *data, size_t length,\n\t\t\t\t      void *callback_data)\n{\n\tstruct snd_ff *ff =\n\t\tcontainer_of(callback_data, struct snd_ff, transactions[1]);\n\tfinish_transmit_midi_msg(ff, 1, rcode);\n}\n\nstatic void transmit_midi_msg(struct snd_ff *ff, unsigned int port)\n{\n\tstruct snd_rawmidi_substream *substream =\n\t\t\tREAD_ONCE(ff->rx_midi_substreams[port]);\n\tint quad_count;\n\n\tstruct fw_device *fw_dev = fw_parent_device(ff->unit);\n\tunsigned long long addr;\n\tint generation;\n\tfw_transaction_callback_t callback;\n\tint tcode;\n\n\tif (substream == NULL || snd_rawmidi_transmit_empty(substream))\n\t\treturn;\n\n\tif (ff->rx_bytes[port] > 0 || ff->rx_midi_error[port])\n\t\treturn;\n\n\t \n\tif (ktime_after(ff->next_ktime[port], ktime_get())) {\n\t\tschedule_work(&ff->rx_midi_work[port]);\n\t\treturn;\n\t}\n\n\tquad_count = ff->spec->protocol->fill_midi_msg(ff, substream, port);\n\tif (quad_count <= 0)\n\t\treturn;\n\n\tif (port == 0) {\n\t\taddr = ff->spec->midi_rx_addrs[0];\n\t\tcallback = finish_transmit_midi0_msg;\n\t} else {\n\t\taddr = ff->spec->midi_rx_addrs[1];\n\t\tcallback = finish_transmit_midi1_msg;\n\t}\n\n\t \n\tff->next_ktime[port] = ktime_add_ns(ktime_get(),\n\t\t\tff->rx_bytes[port] * 8 * (NSEC_PER_SEC / 31250));\n\n\tif (quad_count == 1)\n\t\ttcode = TCODE_WRITE_QUADLET_REQUEST;\n\telse\n\t\ttcode = TCODE_WRITE_BLOCK_REQUEST;\n\n\t \n\tgeneration = fw_dev->generation;\n\tsmp_rmb();\n\tfw_send_request(fw_dev->card, &ff->transactions[port], tcode,\n\t\t\tfw_dev->node_id, generation, fw_dev->max_speed,\n\t\t\taddr, &ff->msg_buf[port], quad_count * 4,\n\t\t\tcallback, &ff->transactions[port]);\n}\n\nstatic void transmit_midi0_msg(struct work_struct *work)\n{\n\tstruct snd_ff *ff = container_of(work, struct snd_ff, rx_midi_work[0]);\n\n\ttransmit_midi_msg(ff, 0);\n}\n\nstatic void transmit_midi1_msg(struct work_struct *work)\n{\n\tstruct snd_ff *ff = container_of(work, struct snd_ff, rx_midi_work[1]);\n\n\ttransmit_midi_msg(ff, 1);\n}\n\nstatic void handle_msg(struct fw_card *card, struct fw_request *request, int tcode,\n\t\t       int destination, int source, int generation, unsigned long long offset,\n\t\t       void *data, size_t length, void *callback_data)\n{\n\tstruct snd_ff *ff = callback_data;\n\t__le32 *buf = data;\n\tu32 tstamp = fw_request_get_timestamp(request);\n\tunsigned long flag;\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n\n\toffset -= ff->async_handler.offset;\n\n\tspin_lock_irqsave(&ff->lock, flag);\n\tff->spec->protocol->handle_msg(ff, (unsigned int)offset, buf, length, tstamp);\n\tspin_unlock_irqrestore(&ff->lock, flag);\n}\n\nstatic int allocate_own_address(struct snd_ff *ff, int i)\n{\n\tstruct fw_address_region midi_msg_region;\n\tint err;\n\n\tff->async_handler.length = ff->spec->midi_addr_range;\n\tff->async_handler.address_callback = handle_msg;\n\tff->async_handler.callback_data = ff;\n\n\tmidi_msg_region.start = 0x000100000000ull * i;\n\tmidi_msg_region.end = midi_msg_region.start + ff->async_handler.length;\n\n\terr = fw_core_add_address_handler(&ff->async_handler, &midi_msg_region);\n\tif (err >= 0) {\n\t\t \n\t\tif (ff->async_handler.offset & 0x0000ffffffff) {\n\t\t\tfw_core_remove_address_handler(&ff->async_handler);\n\t\t\terr = -EAGAIN;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n\n\n\n\n\n\n\nint snd_ff_transaction_reregister(struct snd_ff *ff)\n{\n\tstruct fw_card *fw_card = fw_parent_device(ff->unit)->card;\n\tu32 addr;\n\t__le32 reg;\n\n\t \n\taddr = (fw_card->node_id << 16) | (ff->async_handler.offset >> 32);\n\treg = cpu_to_le32(addr);\n\treturn snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  ff->spec->midi_high_addr,\n\t\t\t\t  &reg, sizeof(reg), 0);\n}\n\nint snd_ff_transaction_register(struct snd_ff *ff)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < 0xffff; i++) {\n\t\terr = allocate_own_address(ff, i);\n\t\tif (err != -EBUSY && err != -EAGAIN)\n\t\t\tbreak;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ff_transaction_reregister(ff);\n\tif (err < 0)\n\t\treturn err;\n\n\tINIT_WORK(&ff->rx_midi_work[0], transmit_midi0_msg);\n\tINIT_WORK(&ff->rx_midi_work[1], transmit_midi1_msg);\n\n\treturn 0;\n}\n\nvoid snd_ff_transaction_unregister(struct snd_ff *ff)\n{\n\t__le32 reg;\n\n\tif (ff->async_handler.callback_data == NULL)\n\t\treturn;\n\tff->async_handler.callback_data = NULL;\n\n\t \n\treg = cpu_to_le32(0x00000000);\n\tsnd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   ff->spec->midi_high_addr,\n\t\t\t   &reg, sizeof(reg), 0);\n\n\tfw_core_remove_address_handler(&ff->async_handler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}