{
  "module_name": "ff-stream.c",
  "hash_id": "51450b3878fc0aff28e70c8b848b26914cd69a3a68469e2a9613a870bd665a4a",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireface/ff-stream.c",
  "human_readable_source": "\n \n\n#include \"ff.h\"\n\n#define READY_TIMEOUT_MS\t200\n\nint snd_ff_stream_get_multiplier_mode(enum cip_sfc sfc,\n\t\t\t\t      enum snd_ff_stream_mode *mode)\n{\n\tstatic const enum snd_ff_stream_mode modes[] = {\n\t\t[CIP_SFC_32000] = SND_FF_STREAM_MODE_LOW,\n\t\t[CIP_SFC_44100] = SND_FF_STREAM_MODE_LOW,\n\t\t[CIP_SFC_48000] = SND_FF_STREAM_MODE_LOW,\n\t\t[CIP_SFC_88200] = SND_FF_STREAM_MODE_MID,\n\t\t[CIP_SFC_96000] = SND_FF_STREAM_MODE_MID,\n\t\t[CIP_SFC_176400] = SND_FF_STREAM_MODE_HIGH,\n\t\t[CIP_SFC_192000] = SND_FF_STREAM_MODE_HIGH,\n\t};\n\n\tif (sfc >= CIP_SFC_COUNT)\n\t\treturn -EINVAL;\n\n\t*mode = modes[sfc];\n\n\treturn 0;\n}\n\nstatic inline void finish_session(struct snd_ff *ff)\n{\n\tff->spec->protocol->finish_session(ff);\n\tff->spec->protocol->switch_fetching_mode(ff, false);\n}\n\nstatic int init_stream(struct snd_ff *ff, struct amdtp_stream *s)\n{\n\tstruct fw_iso_resources *resources;\n\tenum amdtp_stream_direction dir;\n\tint err;\n\n\tif (s == &ff->tx_stream) {\n\t\tresources = &ff->tx_resources;\n\t\tdir = AMDTP_IN_STREAM;\n\t} else {\n\t\tresources = &ff->rx_resources;\n\t\tdir = AMDTP_OUT_STREAM;\n\t}\n\n\terr = fw_iso_resources_init(resources, ff->unit);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = amdtp_ff_init(s, ff->unit, dir);\n\tif (err < 0)\n\t\tfw_iso_resources_destroy(resources);\n\n\treturn err;\n}\n\nstatic void destroy_stream(struct snd_ff *ff, struct amdtp_stream *s)\n{\n\tamdtp_stream_destroy(s);\n\n\tif (s == &ff->tx_stream)\n\t\tfw_iso_resources_destroy(&ff->tx_resources);\n\telse\n\t\tfw_iso_resources_destroy(&ff->rx_resources);\n}\n\nint snd_ff_stream_init_duplex(struct snd_ff *ff)\n{\n\tint err;\n\n\terr = init_stream(ff, &ff->rx_stream);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = init_stream(ff, &ff->tx_stream);\n\tif (err < 0) {\n\t\tdestroy_stream(ff, &ff->rx_stream);\n\t\treturn err;\n\t}\n\n\terr = amdtp_domain_init(&ff->domain);\n\tif (err < 0) {\n\t\tdestroy_stream(ff, &ff->rx_stream);\n\t\tdestroy_stream(ff, &ff->tx_stream);\n\t}\n\n\treturn err;\n}\n\n \nvoid snd_ff_stream_destroy_duplex(struct snd_ff *ff)\n{\n\tamdtp_domain_destroy(&ff->domain);\n\n\tdestroy_stream(ff, &ff->rx_stream);\n\tdestroy_stream(ff, &ff->tx_stream);\n}\n\nint snd_ff_stream_reserve_duplex(struct snd_ff *ff, unsigned int rate,\n\t\t\t\t unsigned int frames_per_period,\n\t\t\t\t unsigned int frames_per_buffer)\n{\n\tunsigned int curr_rate;\n\tenum snd_ff_clock_src src;\n\tint err;\n\n\terr = ff->spec->protocol->get_clock(ff, &curr_rate, &src);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ff->substreams_counter == 0 || curr_rate != rate) {\n\t\tenum snd_ff_stream_mode mode;\n\t\tint i;\n\n\t\tamdtp_domain_stop(&ff->domain);\n\t\tfinish_session(ff);\n\n\t\tfw_iso_resources_free(&ff->tx_resources);\n\t\tfw_iso_resources_free(&ff->rx_resources);\n\n\t\tfor (i = 0; i < CIP_SFC_COUNT; ++i) {\n\t\t\tif (amdtp_rate_table[i] == rate)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= CIP_SFC_COUNT)\n\t\t\treturn -EINVAL;\n\n\t\terr = snd_ff_stream_get_multiplier_mode(i, &mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = amdtp_ff_set_parameters(&ff->tx_stream, rate,\n\t\t\t\t\tff->spec->pcm_capture_channels[mode]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = amdtp_ff_set_parameters(&ff->rx_stream, rate,\n\t\t\t\t\tff->spec->pcm_playback_channels[mode]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = ff->spec->protocol->allocate_resources(ff, rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = amdtp_domain_set_events_per_period(&ff->domain,\n\t\t\t\t\tframes_per_period, frames_per_buffer);\n\t\tif (err < 0) {\n\t\t\tfw_iso_resources_free(&ff->tx_resources);\n\t\t\tfw_iso_resources_free(&ff->rx_resources);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_ff_stream_start_duplex(struct snd_ff *ff, unsigned int rate)\n{\n\tint err;\n\n\tif (ff->substreams_counter == 0)\n\t\treturn 0;\n\n\tif (amdtp_streaming_error(&ff->tx_stream) ||\n\t    amdtp_streaming_error(&ff->rx_stream)) {\n\t\tamdtp_domain_stop(&ff->domain);\n\t\tfinish_session(ff);\n\t}\n\n\t \n\tif (!amdtp_stream_running(&ff->rx_stream)) {\n\t\tint spd = fw_parent_device(ff->unit)->max_speed;\n\n\t\terr = ff->spec->protocol->begin_session(ff, rate);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&ff->domain, &ff->rx_stream,\n\t\t\t\t\t      ff->rx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\terr = amdtp_domain_add_stream(&ff->domain, &ff->tx_stream,\n\t\t\t\t\t      ff->tx_resources.channel, spd);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\terr = amdtp_domain_start(&ff->domain, 0, true, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\n\t\tif (!amdtp_domain_wait_ready(&ff->domain, READY_TIMEOUT_MS)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = ff->spec->protocol->switch_fetching_mode(ff, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tamdtp_domain_stop(&ff->domain);\n\tfinish_session(ff);\n\n\treturn err;\n}\n\nvoid snd_ff_stream_stop_duplex(struct snd_ff *ff)\n{\n\tif (ff->substreams_counter == 0) {\n\t\tamdtp_domain_stop(&ff->domain);\n\t\tfinish_session(ff);\n\n\t\tfw_iso_resources_free(&ff->tx_resources);\n\t\tfw_iso_resources_free(&ff->rx_resources);\n\t}\n}\n\nvoid snd_ff_stream_update_duplex(struct snd_ff *ff)\n{\n\tamdtp_domain_stop(&ff->domain);\n\n\t\n\tamdtp_stream_pcm_abort(&ff->tx_stream);\n\tamdtp_stream_pcm_abort(&ff->rx_stream);\n}\n\nvoid snd_ff_stream_lock_changed(struct snd_ff *ff)\n{\n\tff->dev_lock_changed = true;\n\twake_up(&ff->hwdep_wait);\n}\n\nint snd_ff_stream_lock_try(struct snd_ff *ff)\n{\n\tint err;\n\n\tspin_lock_irq(&ff->lock);\n\n\t \n\tif (ff->dev_lock_count < 0) {\n\t\terr = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (ff->dev_lock_count++ == 0)\n\t\tsnd_ff_stream_lock_changed(ff);\n\terr = 0;\nend:\n\tspin_unlock_irq(&ff->lock);\n\treturn err;\n}\n\nvoid snd_ff_stream_lock_release(struct snd_ff *ff)\n{\n\tspin_lock_irq(&ff->lock);\n\n\tif (WARN_ON(ff->dev_lock_count <= 0))\n\t\tgoto end;\n\tif (--ff->dev_lock_count == 0)\n\t\tsnd_ff_stream_lock_changed(ff);\nend:\n\tspin_unlock_irq(&ff->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}