{
  "module_name": "ff.c",
  "hash_id": "d4c2d4fe152a1339a877fbd2dd1248e609932462c060dc77763d1c48062b19f7",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireface/ff.c",
  "human_readable_source": "\n \n\n#include \"ff.h\"\n\n#define OUI_RME\t0x000a35\n\nMODULE_DESCRIPTION(\"RME Fireface series Driver\");\nMODULE_AUTHOR(\"Takashi Sakamoto <o-takashi@sakamocchi.jp>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void name_card(struct snd_ff *ff)\n{\n\tstruct fw_device *fw_dev = fw_parent_device(ff->unit);\n\tstatic const char *const names[] = {\n\t\t[SND_FF_UNIT_VERSION_FF800]\t= \"Fireface800\",\n\t\t[SND_FF_UNIT_VERSION_FF400]\t= \"Fireface400\",\n\t\t[SND_FF_UNIT_VERSION_UFX]\t= \"FirefaceUFX\",\n\t\t[SND_FF_UNIT_VERSION_UCX]\t= \"FirefaceUCX\",\n\t\t[SND_FF_UNIT_VERSION_802]\t= \"Fireface802\",\n\t};\n\tconst char *name;\n\n\tname = names[ff->unit_version];\n\n\tstrcpy(ff->card->driver, \"Fireface\");\n\tstrcpy(ff->card->shortname, name);\n\tstrcpy(ff->card->mixername, name);\n\tsnprintf(ff->card->longname, sizeof(ff->card->longname),\n\t\t \"RME %s, GUID %08x%08x at %s, S%d\", name,\n\t\t fw_dev->config_rom[3], fw_dev->config_rom[4],\n\t\t dev_name(&ff->unit->device), 100 << fw_dev->max_speed);\n}\n\nstatic void ff_card_free(struct snd_card *card)\n{\n\tstruct snd_ff *ff = card->private_data;\n\n\tsnd_ff_stream_destroy_duplex(ff);\n\tsnd_ff_transaction_unregister(ff);\n\n\tkfree(ff->msg_parser);\n\n\tmutex_destroy(&ff->mutex);\n\tfw_unit_put(ff->unit);\n}\n\nstatic int snd_ff_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\n{\n\tstruct snd_card *card;\n\tstruct snd_ff *ff;\n\tint err;\n\n\terr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE, sizeof(*ff), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = ff_card_free;\n\n\tff = card->private_data;\n\tff->unit = fw_unit_get(unit);\n\tdev_set_drvdata(&unit->device, ff);\n\tff->card = card;\n\n\tmutex_init(&ff->mutex);\n\tspin_lock_init(&ff->lock);\n\tinit_waitqueue_head(&ff->hwdep_wait);\n\n\tff->unit_version = entry->version;\n\tff->spec = (const struct snd_ff_spec *)entry->driver_data;\n\n\terr = snd_ff_transaction_register(ff);\n\tif (err < 0)\n\t\tgoto error;\n\n\tname_card(ff);\n\n\terr = snd_ff_stream_init_duplex(ff);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_ff_proc_init(ff);\n\n\terr = snd_ff_create_midi_devices(ff);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_ff_create_pcm_devices(ff);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_ff_create_hwdep_devices(ff);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (ff->spec->protocol->msg_parser_size > 0) {\n\t\tff->msg_parser = kzalloc(ff->spec->protocol->msg_parser_size, GFP_KERNEL);\n\t\tif (!ff->msg_parser) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_ff_update(struct fw_unit *unit)\n{\n\tstruct snd_ff *ff = dev_get_drvdata(&unit->device);\n\n\tsnd_ff_transaction_reregister(ff);\n\n\tsnd_ff_stream_update_duplex(ff);\n}\n\nstatic void snd_ff_remove(struct fw_unit *unit)\n{\n\tstruct snd_ff *ff = dev_get_drvdata(&unit->device);\n\n\t\n\tsnd_card_free(ff->card);\n}\n\nstatic const struct snd_ff_spec spec_ff800 = {\n\t.pcm_capture_channels = {28, 20, 12},\n\t.pcm_playback_channels = {28, 20, 12},\n\t.midi_in_ports = 1,\n\t.midi_out_ports = 1,\n\t.protocol = &snd_ff_protocol_ff800,\n\t.midi_high_addr = 0x000200000320ull,\n\t.midi_addr_range = 12,\n\t.midi_rx_addrs = {0x000080180000ull, 0},\n};\n\nstatic const struct snd_ff_spec spec_ff400 = {\n\t.pcm_capture_channels = {18, 14, 10},\n\t.pcm_playback_channels = {18, 14, 10},\n\t.midi_in_ports = 2,\n\t.midi_out_ports = 2,\n\t.protocol = &snd_ff_protocol_ff400,\n\t.midi_high_addr = 0x0000801003f4ull,\n\t.midi_addr_range = SND_FF_MAXIMIM_MIDI_QUADS * 4,\n\t.midi_rx_addrs = {0x000080180000ull, 0x000080190000ull},\n};\n\nstatic const struct snd_ff_spec spec_ucx = {\n\t.pcm_capture_channels = {18, 14, 12},\n\t.pcm_playback_channels = {18, 14, 12},\n\t.midi_in_ports = 2,\n\t.midi_out_ports = 2,\n\t.protocol = &snd_ff_protocol_latter,\n\t.midi_high_addr = 0xffff00000034ull,\n\t.midi_addr_range = 0x80,\n\t.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},\n};\n\nstatic const struct snd_ff_spec spec_ufx_802 = {\n\t.pcm_capture_channels = {30, 22, 14},\n\t.pcm_playback_channels = {30, 22, 14},\n\t.midi_in_ports = 1,\n\t.midi_out_ports = 1,\n\t.protocol = &snd_ff_protocol_latter,\n\t.midi_high_addr = 0xffff00000034ull,\n\t.midi_addr_range = 0x80,\n\t.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},\n};\n\nstatic const struct ieee1394_device_id snd_ff_id_table[] = {\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_RME,\n\t\t.specifier_id\t= OUI_RME,\n\t\t.version\t= SND_FF_UNIT_VERSION_FF800,\n\t\t.model_id\t= 0x101800,\n\t\t.driver_data\t= (kernel_ulong_t)&spec_ff800,\n\t},\n\t \n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_RME,\n\t\t.specifier_id\t= OUI_RME,\n\t\t.version\t= SND_FF_UNIT_VERSION_FF400,\n\t\t.model_id\t= 0x101800,\n\t\t.driver_data\t= (kernel_ulong_t)&spec_ff400,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_RME,\n\t\t.specifier_id\t= OUI_RME,\n\t\t.version\t= SND_FF_UNIT_VERSION_UFX,\n\t\t.model_id\t= 0x101800,\n\t\t.driver_data\t= (kernel_ulong_t)&spec_ufx_802,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_RME,\n\t\t.specifier_id\t= OUI_RME,\n\t\t.version\t= SND_FF_UNIT_VERSION_UCX,\n\t\t.model_id\t= 0x101800,\n\t\t.driver_data\t= (kernel_ulong_t)&spec_ucx,\n\t},\n\t\n\t{\n\t\t.match_flags\t= IEEE1394_MATCH_VENDOR_ID |\n\t\t\t\t  IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\t  IEEE1394_MATCH_VERSION |\n\t\t\t\t  IEEE1394_MATCH_MODEL_ID,\n\t\t.vendor_id\t= OUI_RME,\n\t\t.specifier_id\t= OUI_RME,\n\t\t.version\t= SND_FF_UNIT_VERSION_802,\n\t\t.model_id\t= 0x101800,\n\t\t.driver_data\t= (kernel_ulong_t)&spec_ufx_802,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);\n\nstatic struct fw_driver ff_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.bus\t= &fw_bus_type,\n\t},\n\t.probe    = snd_ff_probe,\n\t.update   = snd_ff_update,\n\t.remove   = snd_ff_remove,\n\t.id_table = snd_ff_id_table,\n};\n\nstatic int __init snd_ff_init(void)\n{\n\treturn driver_register(&ff_driver.driver);\n}\n\nstatic void __exit snd_ff_exit(void)\n{\n\tdriver_unregister(&ff_driver.driver);\n}\n\nmodule_init(snd_ff_init);\nmodule_exit(snd_ff_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}