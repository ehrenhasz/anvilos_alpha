{
  "module_name": "ff-protocol-former.c",
  "hash_id": "926bb4918506b945b7d48186b40e300233f1b06419236ed05c202e0c6d22e568",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireface/ff-protocol-former.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n\n#include \"ff.h\"\n\n#define FORMER_REG_SYNC_STATUS\t\t0x0000801c0000ull\n \n#define FORMER_REG_FETCH_PCM_FRAMES\t0x0000801c0000ull\n#define FORMER_REG_CLOCK_CONFIG\t\t0x0000801c0004ull\n\nstatic int parse_clock_bits(u32 data, unsigned int *rate,\n\t\t\t    enum snd_ff_clock_src *src)\n{\n\tstatic const struct {\n\t\tunsigned int rate;\n\t\tu32 mask;\n\t} *rate_entry, rate_entries[] = {\n\t\t{  32000, 0x00000002, },\n\t\t{  44100, 0x00000000, },\n\t\t{  48000, 0x00000006, },\n\t\t{  64000, 0x0000000a, },\n\t\t{  88200, 0x00000008, },\n\t\t{  96000, 0x0000000e, },\n\t\t{ 128000, 0x00000012, },\n\t\t{ 176400, 0x00000010, },\n\t\t{ 192000, 0x00000016, },\n\t};\n\tstatic const struct {\n\t\tenum snd_ff_clock_src src;\n\t\tu32 mask;\n\t} *clk_entry, clk_entries[] = {\n\t\t{ SND_FF_CLOCK_SRC_ADAT1,\t0x00000000, },\n\t\t{ SND_FF_CLOCK_SRC_ADAT2,\t0x00000400, },\n\t\t{ SND_FF_CLOCK_SRC_SPDIF,\t0x00000c00, },\n\t\t{ SND_FF_CLOCK_SRC_WORD,\t0x00001000, },\n\t\t{ SND_FF_CLOCK_SRC_LTC,\t\t0x00001800, },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rate_entries); ++i) {\n\t\trate_entry = rate_entries + i;\n\t\tif ((data & 0x0000001e) == rate_entry->mask) {\n\t\t\t*rate = rate_entry->rate;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(rate_entries))\n\t\treturn -EIO;\n\n\tif (data & 0x00000001) {\n\t\t*src = SND_FF_CLOCK_SRC_INTERNAL;\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(clk_entries); ++i) {\n\t\t\tclk_entry = clk_entries + i;\n\t\t\tif ((data & 0x00001c00) == clk_entry->mask) {\n\t\t\t\t*src = clk_entry->src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(clk_entries))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int former_get_clock(struct snd_ff *ff, unsigned int *rate,\n\t\t\t    enum snd_ff_clock_src *src)\n{\n\t__le32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t FORMER_REG_CLOCK_CONFIG, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\tdata = le32_to_cpu(reg);\n\n\treturn parse_clock_bits(data, rate, src);\n}\n\nstatic int former_switch_fetching_mode(struct snd_ff *ff, bool enable)\n{\n\tunsigned int count;\n\t__le32 *reg;\n\tint i;\n\tint err;\n\n\tcount = 0;\n\tfor (i = 0; i < SND_FF_STREAM_MODE_COUNT; ++i)\n\t\tcount = max(count, ff->spec->pcm_playback_channels[i]);\n\n\treg = kcalloc(count, sizeof(__le32), GFP_KERNEL);\n\tif (!reg)\n\t\treturn -ENOMEM;\n\n\tif (!enable) {\n\t\t \n\t\tfor (i = 0; i < count; ++i)\n\t\t\treg[i] = cpu_to_le32(0x00000001);\n\t}\n\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\t\t FORMER_REG_FETCH_PCM_FRAMES, reg,\n\t\t\t\t sizeof(__le32) * count, 0);\n\tkfree(reg);\n\treturn err;\n}\n\nstatic void dump_clock_config(struct snd_ff *ff, struct snd_info_buffer *buffer)\n{\n\t__le32 reg;\n\tu32 data;\n\tunsigned int rate;\n\tenum snd_ff_clock_src src;\n\tconst char *label;\n\tint err;\n\n\terr = snd_fw_transaction(ff->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t FORMER_REG_CLOCK_CONFIG, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn;\n\tdata = le32_to_cpu(reg);\n\n\tsnd_iprintf(buffer, \"Output S/PDIF format: %s (Emphasis: %s)\\n\",\n\t\t    (data & 0x00000020) ? \"Professional\" : \"Consumer\",\n\t\t    (data & 0x00000040) ? \"on\" : \"off\");\n\n\tsnd_iprintf(buffer, \"Optical output interface format: %s\\n\",\n\t\t    (data & 0x00000100) ? \"S/PDIF\" : \"ADAT\");\n\n\tsnd_iprintf(buffer, \"Word output single speed: %s\\n\",\n\t\t    (data & 0x00002000) ? \"on\" : \"off\");\n\n\tsnd_iprintf(buffer, \"S/PDIF input interface: %s\\n\",\n\t\t    (data & 0x00000200) ? \"Optical\" : \"Coaxial\");\n\n\terr = parse_clock_bits(data, &rate, &src);\n\tif (err < 0)\n\t\treturn;\n\tlabel = snd_ff_proc_get_clk_label(src);\n\tif (!label)\n\t\treturn;\n\n\tsnd_iprintf(buffer, \"Clock configuration: %d %s\\n\", rate, label);\n}\n\nstatic void dump_sync_status(struct snd_ff *ff, struct snd_info_buffer *buffer)\n{\n\tstatic const struct {\n\t\tchar *const label;\n\t\tu32 locked_mask;\n\t\tu32 synced_mask;\n\t} *clk_entry, clk_entries[] = {\n\t\t{ \"WDClk\",\t0x40000000, 0x20000000, },\n\t\t{ \"S/PDIF\",\t0x00080000, 0x00040000, },\n\t\t{ \"ADAT1\",\t0x00000400, 0x00001000, },\n\t\t{ \"ADAT2\",\t0x00000800, 0x00002000, },\n\t};\n\tstatic const struct {\n\t\tchar *const label;\n\t\tu32 mask;\n\t} *referred_entry, referred_entries[] = {\n\t\t{ \"ADAT1\",\t0x00000000, },\n\t\t{ \"ADAT2\",\t0x00400000, },\n\t\t{ \"S/PDIF\",\t0x00c00000, },\n\t\t{ \"WDclk\",\t0x01000000, },\n\t\t{ \"TCO\",\t0x01400000, },\n\t};\n\tstatic const struct {\n\t\tunsigned int rate;\n\t\tu32 mask;\n\t} *rate_entry, rate_entries[] = {\n\t\t{ 32000,\t0x02000000, },\n\t\t{ 44100,\t0x04000000, },\n\t\t{ 48000,\t0x06000000, },\n\t\t{ 64000,\t0x08000000, },\n\t\t{ 88200,\t0x0a000000, },\n\t\t{ 96000,\t0x0c000000, },\n\t\t{ 128000,\t0x0e000000, },\n\t\t{ 176400,\t0x10000000, },\n\t\t{ 192000,\t0x12000000, },\n\t};\n\t__le32 reg[2];\n\tu32 data[2];\n\tint i;\n\tint err;\n\n\terr = snd_fw_transaction(ff->unit, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\t FORMER_REG_SYNC_STATUS, reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn;\n\tdata[0] = le32_to_cpu(reg[0]);\n\tdata[1] = le32_to_cpu(reg[1]);\n\n\tsnd_iprintf(buffer, \"External source detection:\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_entries); ++i) {\n\t\tconst char *state;\n\n\t\tclk_entry = clk_entries + i;\n\t\tif (data[0] & clk_entry->locked_mask) {\n\t\t\tif (data[0] & clk_entry->synced_mask)\n\t\t\t\tstate = \"sync\";\n\t\t\telse\n\t\t\t\tstate = \"lock\";\n\t\t} else {\n\t\t\tstate = \"none\";\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"%s: %s\\n\", clk_entry->label, state);\n\t}\n\n\tsnd_iprintf(buffer, \"Referred clock:\\n\");\n\n\tif (data[1] & 0x00000001) {\n\t\tsnd_iprintf(buffer, \"Internal\\n\");\n\t} else {\n\t\tunsigned int rate;\n\t\tconst char *label;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(referred_entries); ++i) {\n\t\t\treferred_entry = referred_entries + i;\n\t\t\tif ((data[0] & 0x1e0000) == referred_entry->mask) {\n\t\t\t\tlabel = referred_entry->label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(referred_entries))\n\t\t\tlabel = \"none\";\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rate_entries); ++i) {\n\t\t\trate_entry = rate_entries + i;\n\t\t\tif ((data[0] & 0x1e000000) == rate_entry->mask) {\n\t\t\t\trate = rate_entry->rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(rate_entries))\n\t\t\trate = 0;\n\n\t\tsnd_iprintf(buffer, \"%s %d\\n\", label, rate);\n\t}\n}\n\nstatic void former_dump_status(struct snd_ff *ff,\n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tdump_clock_config(ff, buffer);\n\tdump_sync_status(ff, buffer);\n}\n\nstatic int former_fill_midi_msg(struct snd_ff *ff,\n\t\t\t\tstruct snd_rawmidi_substream *substream,\n\t\t\t\tunsigned int port)\n{\n\tu8 *buf = (u8 *)ff->msg_buf[port];\n\tint len;\n\tint i;\n\n\tlen = snd_rawmidi_transmit_peek(substream, buf,\n\t\t\t\t\tSND_FF_MAXIMIM_MIDI_QUADS);\n\tif (len <= 0)\n\t\treturn len;\n\n\t\n\tfor (i = len - 1; i >= 0; --i)\n\t\tff->msg_buf[port][i] = cpu_to_le32(buf[i]);\n\tff->rx_bytes[port] = len;\n\n\treturn len;\n}\n\n#define FF800_STF\t\t0x0000fc88f000\n#define FF800_RX_PACKET_FORMAT\t0x0000fc88f004\n#define FF800_ALLOC_TX_STREAM\t0x0000fc88f008\n#define FF800_ISOC_COMM_START\t0x0000fc88f00c\n#define   FF800_TX_S800_FLAG\t0x00000800\n#define FF800_ISOC_COMM_STOP\t0x0000fc88f010\n\n#define FF800_TX_PACKET_ISOC_CH\t0x0000801c0008\n\nstatic int allocate_tx_resources(struct snd_ff *ff)\n{\n\t__le32 reg;\n\tunsigned int count;\n\tunsigned int tx_isoc_channel;\n\tint err;\n\n\treg = cpu_to_le32(ff->tx_stream.data_block_quadlets);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF800_ALLOC_TX_STREAM, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tcount = 0;\n\twhile (count++ < 10) {\n\t\tu32 data;\n\t\terr = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\tFF800_TX_PACKET_ISOC_CH, &reg, sizeof(reg), 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = le32_to_cpu(reg);\n\t\tif (data != 0xffffffff) {\n\t\t\ttx_isoc_channel = data;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(50);\n\t}\n\tif (count >= 10)\n\t\treturn -ETIMEDOUT;\n\n\t\n\t\n\t\n\tff->tx_resources.channel = tx_isoc_channel;\n\n\treturn 0;\n}\n\nstatic int ff800_allocate_resources(struct snd_ff *ff, unsigned int rate)\n{\n\tu32 data;\n\t__le32 reg;\n\tint err;\n\n\treg = cpu_to_le32(rate);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF800_STF, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\t\n\t\n\tmsleep(100);\n\n\t\n\terr = fw_iso_resources_allocate(&ff->rx_resources,\n\t\t\t\tamdtp_stream_get_max_payload(&ff->rx_stream),\n\t\t\t\tfw_parent_device(ff->unit)->max_speed);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\t\n\t\n\tdata = ff->rx_stream.data_block_quadlets << 3;\n\tdata = (data << 8) | ff->rx_resources.channel;\n\treg = cpu_to_le32(data);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF800_RX_PACKET_FORMAT, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn allocate_tx_resources(ff);\n}\n\nstatic int ff800_begin_session(struct snd_ff *ff, unsigned int rate)\n{\n\tunsigned int generation = ff->rx_resources.generation;\n\t__le32 reg;\n\n\tif (generation != fw_parent_device(ff->unit)->card->generation) {\n\t\tint err = fw_iso_resources_update(&ff->rx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treg = cpu_to_le32(0x80000000);\n\treg |= cpu_to_le32(ff->tx_stream.data_block_quadlets);\n\tif (fw_parent_device(ff->unit)->max_speed == SCODE_800)\n\t\treg |= cpu_to_le32(FF800_TX_S800_FLAG);\n\treturn snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF800_ISOC_COMM_START, &reg, sizeof(reg), 0);\n}\n\nstatic void ff800_finish_session(struct snd_ff *ff)\n{\n\t__le32 reg;\n\n\treg = cpu_to_le32(0x80000000);\n\tsnd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   FF800_ISOC_COMM_STOP, &reg, sizeof(reg), 0);\n}\n\n\n\n\n\nstatic void ff800_handle_midi_msg(struct snd_ff *ff, unsigned int offset, const __le32 *buf,\n\t\t\t\t  size_t length, u32 tstamp)\n{\n\tint i;\n\n\tfor (i = 0; i < length / 4; i++) {\n\t\tu8 byte = le32_to_cpu(buf[i]) & 0xff;\n\t\tstruct snd_rawmidi_substream *substream;\n\n\t\tsubstream = READ_ONCE(ff->tx_midi_substreams[0]);\n\t\tif (substream)\n\t\t\tsnd_rawmidi_receive(substream, &byte, 1);\n\t}\n}\n\nconst struct snd_ff_protocol snd_ff_protocol_ff800 = {\n\t.handle_msg\t\t= ff800_handle_midi_msg,\n\t.fill_midi_msg\t\t= former_fill_midi_msg,\n\t.get_clock\t\t= former_get_clock,\n\t.switch_fetching_mode\t= former_switch_fetching_mode,\n\t.allocate_resources\t= ff800_allocate_resources,\n\t.begin_session\t\t= ff800_begin_session,\n\t.finish_session\t\t= ff800_finish_session,\n\t.dump_status\t\t= former_dump_status,\n};\n\n#define FF400_STF\t\t0x000080100500ull\n#define FF400_RX_PACKET_FORMAT\t0x000080100504ull\n#define FF400_ISOC_COMM_START\t0x000080100508ull\n#define FF400_TX_PACKET_FORMAT\t0x00008010050cull\n#define FF400_ISOC_COMM_STOP\t0x000080100510ull\n\n\n\nstatic int ff400_allocate_resources(struct snd_ff *ff, unsigned int rate)\n{\n\t__le32 reg;\n\tenum snd_ff_stream_mode mode;\n\tint i;\n\tint err;\n\n\t\n\tfor (i = 0; i < CIP_SFC_COUNT; i++) {\n\t\tif (amdtp_rate_table[i] == rate)\n\t\t\tbreak;\n\t}\n\tif (i >= CIP_SFC_COUNT)\n\t\treturn -EINVAL;\n\n\t\n\treg = cpu_to_le32(rate);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF400_STF, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsleep(100);\n\n\terr = snd_ff_stream_get_multiplier_mode(i, &mode);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tff->tx_resources.channels_mask = 0x00000000000000ffuLL;\n\terr = fw_iso_resources_allocate(&ff->tx_resources,\n\t\t\tamdtp_stream_get_max_payload(&ff->tx_stream),\n\t\t\tfw_parent_device(ff->unit)->max_speed);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tff->rx_resources.channels_mask = 0x00000000000000ffuLL;\n\terr = fw_iso_resources_allocate(&ff->rx_resources,\n\t\t\tamdtp_stream_get_max_payload(&ff->rx_stream),\n\t\t\tfw_parent_device(ff->unit)->max_speed);\n\tif (err < 0)\n\t\tfw_iso_resources_free(&ff->tx_resources);\n\n\treturn err;\n}\n\nstatic int ff400_begin_session(struct snd_ff *ff, unsigned int rate)\n{\n\tunsigned int generation = ff->rx_resources.generation;\n\t__le32 reg;\n\tint err;\n\n\tif (generation != fw_parent_device(ff->unit)->card->generation) {\n\t\terr = fw_iso_resources_update(&ff->tx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = fw_iso_resources_update(&ff->rx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t\n\t\n\treg = cpu_to_le32(((ff->rx_stream.data_block_quadlets << 3) << 8) |\n\t\t\t  ff->rx_resources.channel);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF400_RX_PACKET_FORMAT, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\t\n\t\n\treg = cpu_to_le32((0x80 << 24) |\n\t\t\t  (ff->tx_resources.channel << 5) |\n\t\t\t  (ff->tx_stream.data_block_quadlets));\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF400_TX_PACKET_FORMAT, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\treg = cpu_to_le32(0x00000001);\n\treturn snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t FF400_ISOC_COMM_START, &reg, sizeof(reg), 0);\n}\n\nstatic void ff400_finish_session(struct snd_ff *ff)\n{\n\t__le32 reg;\n\n\treg = cpu_to_le32(0x80000000);\n\tsnd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   FF400_ISOC_COMM_STOP, &reg, sizeof(reg), 0);\n}\n\nstatic void parse_midi_msg(struct snd_ff *ff, u32 quad, unsigned int port)\n{\n\tstruct snd_rawmidi_substream *substream = READ_ONCE(ff->tx_midi_substreams[port]);\n\n\tif (substream != NULL) {\n\t\tu8 byte = (quad >> (16 * port)) & 0x000000ff;\n\n\t\tsnd_rawmidi_receive(substream, &byte, 1);\n\t}\n}\n\n#define FF400_QUEUE_SIZE\t32\n\nstruct ff400_msg_parser {\n\tstruct {\n\t\tu32 msg;\n\t\tu32 tstamp;\n\t} msgs[FF400_QUEUE_SIZE];\n\tsize_t push_pos;\n\tsize_t pull_pos;\n};\n\nstatic bool ff400_has_msg(struct snd_ff *ff)\n{\n\tstruct ff400_msg_parser *parser = ff->msg_parser;\n\n\treturn (parser->push_pos != parser->pull_pos);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define FF400_MSG_FLAG_IS_SIGNAL_LEVEL\t\t0x04000000\n#define  FF400_MSG_FLAG_IS_RIGHT_CHANNEL\t0x08000000\n#define  FF400_MSG_FLAG_IS_STEREO_PAIRED\t0x02000000\n#define  FF400_MSG_MASK_STEREO_PAIR\t\t0xf0000000\n#define  FF400_MSG_MASK_SIGNAL_LEVEL\t\t0x00fffc00\n#define FF400_MSG_FLAG_IS_MIDI_PORT_0\t\t0x00000100\n#define  FF400_MSG_MASK_MIDI_PORT_0\t\t0x000000ff\n#define FF400_MSG_FLAG_IS_MIDI_PORT_1\t\t0x01000000\n#define  FF400_MSG_MASK_MIDI_PORT_1\t\t0x00ff0000\n\nstatic void ff400_handle_msg(struct snd_ff *ff, unsigned int offset, const __le32 *buf,\n\t\t\t     size_t length, u32 tstamp)\n{\n\tbool need_hwdep_wake_up = false;\n\tint i;\n\n\tfor (i = 0; i < length / 4; i++) {\n\t\tu32 quad = le32_to_cpu(buf[i]);\n\n\t\tif (quad & FF400_MSG_FLAG_IS_SIGNAL_LEVEL) {\n\t\t\tstruct ff400_msg_parser *parser = ff->msg_parser;\n\n\t\t\tparser->msgs[parser->push_pos].msg = quad;\n\t\t\tparser->msgs[parser->push_pos].tstamp = tstamp;\n\t\t\t++parser->push_pos;\n\t\t\tif (parser->push_pos >= FF400_QUEUE_SIZE)\n\t\t\t\tparser->push_pos = 0;\n\n\t\t\tneed_hwdep_wake_up = true;\n\t\t} else if (quad & FF400_MSG_FLAG_IS_MIDI_PORT_0) {\n\t\t\tparse_midi_msg(ff, quad, 0);\n\t\t} else if (quad & FF400_MSG_FLAG_IS_MIDI_PORT_1) {\n\t\t\tparse_midi_msg(ff, quad, 1);\n\t\t}\n\t}\n\n\tif (need_hwdep_wake_up)\n\t\twake_up(&ff->hwdep_wait);\n}\n\nstatic long ff400_copy_msg_to_user(struct snd_ff *ff, char __user *buf, long count)\n{\n\tstruct snd_firewire_event_ff400_message ev = {\n\t\t.type = SNDRV_FIREWIRE_EVENT_FF400_MESSAGE,\n\t\t.message_count = 0,\n\t};\n\tstruct ff400_msg_parser *parser = ff->msg_parser;\n\tlong consumed = 0;\n\tlong ret = 0;\n\n\tif (count < sizeof(ev) || parser->pull_pos == parser->push_pos)\n\t\treturn 0;\n\n\tcount -= sizeof(ev);\n\tconsumed += sizeof(ev);\n\n\twhile (count >= sizeof(*parser->msgs) && parser->pull_pos != parser->push_pos) {\n\t\tspin_unlock_irq(&ff->lock);\n\t\tif (copy_to_user(buf + consumed, parser->msgs + parser->pull_pos,\n\t\t\t\t sizeof(*parser->msgs)))\n\t\t\tret = -EFAULT;\n\t\tspin_lock_irq(&ff->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t++parser->pull_pos;\n\t\tif (parser->pull_pos >= FF400_QUEUE_SIZE)\n\t\t\tparser->pull_pos = 0;\n\t\t++ev.message_count;\n\t\tcount -= sizeof(*parser->msgs);\n\t\tconsumed += sizeof(*parser->msgs);\n\t}\n\n\tspin_unlock_irq(&ff->lock);\n\tif (copy_to_user(buf, &ev, sizeof(ev)))\n\t\tret = -EFAULT;\n\tspin_lock_irq(&ff->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn consumed;\n}\n\nconst struct snd_ff_protocol snd_ff_protocol_ff400 = {\n\t.msg_parser_size\t= sizeof(struct ff400_msg_parser),\n\t.has_msg\t\t= ff400_has_msg,\n\t.copy_msg_to_user\t= ff400_copy_msg_to_user,\n\t.handle_msg\t\t= ff400_handle_msg,\n\t.fill_midi_msg\t\t= former_fill_midi_msg,\n\t.get_clock\t\t= former_get_clock,\n\t.switch_fetching_mode\t= former_switch_fetching_mode,\n\t.allocate_resources\t= ff400_allocate_resources,\n\t.begin_session\t\t= ff400_begin_session,\n\t.finish_session\t\t= ff400_finish_session,\n\t.dump_status\t\t= former_dump_status,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}