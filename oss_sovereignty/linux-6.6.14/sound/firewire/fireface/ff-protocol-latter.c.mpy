{
  "module_name": "ff-protocol-latter.c",
  "hash_id": "9686cd87cce40ddcdbbb82605dc3e31a2e1594cb6ac340ab8a3e4a731594f6e5",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fireface/ff-protocol-latter.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n\n#include \"ff.h\"\n\n#define LATTER_STF\t\t0xffff00000004ULL\n#define LATTER_ISOC_CHANNELS\t0xffff00000008ULL\n#define LATTER_ISOC_START\t0xffff0000000cULL\n#define LATTER_FETCH_MODE\t0xffff00000010ULL\n#define LATTER_SYNC_STATUS\t0x0000801c0000ULL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic int parse_clock_bits(u32 data, unsigned int *rate,\n\t\t\t    enum snd_ff_clock_src *src,\n\t\t\t    enum snd_ff_unit_version unit_version)\n{\n\tstatic const struct {\n\t\tunsigned int rate;\n\t\tu32 flag;\n\t} *rate_entry, rate_entries[] = {\n\t\t{ 32000,\t0x00, },\n\t\t{ 44100,\t0x01, },\n\t\t{ 48000,\t0x02, },\n\t\t{ 64000,\t0x04, },\n\t\t{ 88200,\t0x05, },\n\t\t{ 96000,\t0x06, },\n\t\t{ 128000,\t0x08, },\n\t\t{ 176400,\t0x09, },\n\t\t{ 192000,\t0x0a, },\n\t};\n\tstatic const struct {\n\t\tenum snd_ff_clock_src src;\n\t\tu32 flag;\n\t} *clk_entry, *clk_entries, ucx_clk_entries[] = {\n\t\t{ SND_FF_CLOCK_SRC_SPDIF,\t0x00000200, },\n\t\t{ SND_FF_CLOCK_SRC_ADAT1,\t0x00000400, },\n\t\t{ SND_FF_CLOCK_SRC_WORD,\t0x00000600, },\n\t\t{ SND_FF_CLOCK_SRC_INTERNAL,\t0x00000e00, },\n\t}, ufx_ff802_clk_entries[] = {\n\t\t{ SND_FF_CLOCK_SRC_WORD,\t0x00000200, },\n\t\t{ SND_FF_CLOCK_SRC_SPDIF,\t0x00000400, },\n\t\t{ SND_FF_CLOCK_SRC_ADAT1,\t0x00000600, },\n\t\t{ SND_FF_CLOCK_SRC_ADAT2,\t0x00000800, },\n\t\t{ SND_FF_CLOCK_SRC_INTERNAL,\t0x00000e00, },\n\t};\n\tu32 rate_bits;\n\tunsigned int clk_entry_count;\n\tint i;\n\n\tif (unit_version == SND_FF_UNIT_VERSION_UCX) {\n\t\trate_bits = (data & 0x0f000000) >> 24;\n\t\tclk_entries = ucx_clk_entries;\n\t\tclk_entry_count = ARRAY_SIZE(ucx_clk_entries);\n\t} else {\n\t\trate_bits = (data & 0xf0000000) >> 28;\n\t\tclk_entries = ufx_ff802_clk_entries;\n\t\tclk_entry_count = ARRAY_SIZE(ufx_ff802_clk_entries);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rate_entries); ++i) {\n\t\trate_entry = rate_entries + i;\n\t\tif (rate_bits == rate_entry->flag) {\n\t\t\t*rate = rate_entry->rate;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(rate_entries))\n\t\treturn -EIO;\n\n\tfor (i = 0; i < clk_entry_count; ++i) {\n\t\tclk_entry = clk_entries + i;\n\t\tif ((data & 0x000e00) == clk_entry->flag) {\n\t\t\t*src = clk_entry->src;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == clk_entry_count)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int latter_get_clock(struct snd_ff *ff, unsigned int *rate,\n\t\t\t   enum snd_ff_clock_src *src)\n{\n\t__le32 reg;\n\tu32 data;\n\tint err;\n\n\terr = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t LATTER_SYNC_STATUS, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\tdata = le32_to_cpu(reg);\n\n\treturn parse_clock_bits(data, rate, src, ff->unit_version);\n}\n\nstatic int latter_switch_fetching_mode(struct snd_ff *ff, bool enable)\n{\n\tu32 data;\n\t__le32 reg;\n\n\tif (enable)\n\t\tdata = 0x00000000;\n\telse\n\t\tdata = 0xffffffff;\n\treg = cpu_to_le32(data);\n\n\treturn snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  LATTER_FETCH_MODE, &reg, sizeof(reg), 0);\n}\n\nstatic int latter_allocate_resources(struct snd_ff *ff, unsigned int rate)\n{\n\tenum snd_ff_stream_mode mode;\n\tunsigned int code;\n\t__le32 reg;\n\tunsigned int count;\n\tint i;\n\tint err;\n\n\t\n\tif (rate % 48000 == 0)\n\t\tcode = 0x04;\n\telse if (rate % 44100 == 0)\n\t\tcode = 0x02;\n\telse if (rate % 32000 == 0)\n\t\tcode = 0x00;\n\telse\n\t\treturn -EINVAL;\n\n\tif (rate >= 64000 && rate < 128000)\n\t\tcode |= 0x08;\n\telse if (rate >= 128000)\n\t\tcode |= 0x10;\n\n\treg = cpu_to_le32(code);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t LATTER_STF, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tcount = 0;\n\twhile (count++ < 10) {\n\t\tunsigned int curr_rate;\n\t\tenum snd_ff_clock_src src;\n\n\t\terr = latter_get_clock(ff, &curr_rate, &src);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (curr_rate == rate)\n\t\t\tbreak;\n\t}\n\tif (count > 10)\n\t\treturn -ETIMEDOUT;\n\n\tfor (i = 0; i < ARRAY_SIZE(amdtp_rate_table); ++i) {\n\t\tif (rate == amdtp_rate_table[i])\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(amdtp_rate_table))\n\t\treturn -EINVAL;\n\n\terr = snd_ff_stream_get_multiplier_mode(i, &mode);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tff->tx_resources.channels_mask = 0x00000000000000ffuLL;\n\terr = fw_iso_resources_allocate(&ff->tx_resources,\n\t\t\tamdtp_stream_get_max_payload(&ff->tx_stream),\n\t\t\tfw_parent_device(ff->unit)->max_speed);\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\tff->rx_resources.channels_mask = 0x00000000000000ffuLL;\n\terr = fw_iso_resources_allocate(&ff->rx_resources,\n\t\t\tamdtp_stream_get_max_payload(&ff->rx_stream),\n\t\t\tfw_parent_device(ff->unit)->max_speed);\n\tif (err < 0)\n\t\tfw_iso_resources_free(&ff->tx_resources);\n\n\treturn err;\n}\n\nstatic int latter_begin_session(struct snd_ff *ff, unsigned int rate)\n{\n\tunsigned int generation = ff->rx_resources.generation;\n\tunsigned int flag;\n\tu32 data;\n\t__le32 reg;\n\tint err;\n\n\tif (ff->unit_version == SND_FF_UNIT_VERSION_UCX) {\n\t\t\n\t\t\n\t\tif (rate >= 32000 && rate <= 48000)\n\t\t\tflag = 0x92;\n\t\telse if (rate >= 64000 && rate <= 96000)\n\t\t\tflag = 0x8e;\n\t\telse if (rate >= 128000 && rate <= 192000)\n\t\t\tflag = 0x8c;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t\n\t\t\n\t\t\n\t\tif (rate >= 32000 && rate <= 48000)\n\t\t\tflag = 0x9e;\n\t\telse if (rate >= 64000 && rate <= 96000)\n\t\t\tflag = 0x96;\n\t\telse if (rate >= 128000 && rate <= 192000)\n\t\t\tflag = 0x8e;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (generation != fw_parent_device(ff->unit)->card->generation) {\n\t\terr = fw_iso_resources_update(&ff->tx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = fw_iso_resources_update(&ff->rx_resources);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdata = (ff->tx_resources.channel << 8) | ff->rx_resources.channel;\n\treg = cpu_to_le32(data);\n\terr = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t LATTER_ISOC_CHANNELS, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treg = cpu_to_le32(flag);\n\treturn snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\t  LATTER_ISOC_START, &reg, sizeof(reg), 0);\n}\n\nstatic void latter_finish_session(struct snd_ff *ff)\n{\n\t__le32 reg;\n\n\treg = cpu_to_le32(0x00000000);\n\tsnd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   LATTER_ISOC_START, &reg, sizeof(reg), 0);\n}\n\nstatic void latter_dump_status(struct snd_ff *ff, struct snd_info_buffer *buffer)\n{\n\tstatic const struct {\n\t\tchar *const label;\n\t\tu32 locked_mask;\n\t\tu32 synced_mask;\n\t} *clk_entry, *clk_entries, ucx_clk_entries[] = {\n\t\t{ \"S/PDIF\",\t0x00000001, 0x00000010, },\n\t\t{ \"ADAT\",\t0x00000002, 0x00000020, },\n\t\t{ \"WDClk\",\t0x00000004, 0x00000040, },\n\t}, ufx_ff802_clk_entries[] = {\n\t\t{ \"WDClk\",\t0x00000001, 0x00000010, },\n\t\t{ \"AES/EBU\",\t0x00000002, 0x00000020, },\n\t\t{ \"ADAT-A\",\t0x00000004, 0x00000040, },\n\t\t{ \"ADAT-B\",\t0x00000008, 0x00000080, },\n\t};\n\t__le32 reg;\n\tu32 data;\n\tunsigned int rate;\n\tenum snd_ff_clock_src src;\n\tconst char *label;\n\tunsigned int clk_entry_count;\n\tint i;\n\tint err;\n\n\terr = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\t LATTER_SYNC_STATUS, &reg, sizeof(reg), 0);\n\tif (err < 0)\n\t\treturn;\n\tdata = le32_to_cpu(reg);\n\n\tsnd_iprintf(buffer, \"External source detection:\\n\");\n\n\tif (ff->unit_version == SND_FF_UNIT_VERSION_UCX) {\n\t\tclk_entries = ucx_clk_entries;\n\t\tclk_entry_count = ARRAY_SIZE(ucx_clk_entries);\n\t} else {\n\t\tclk_entries = ufx_ff802_clk_entries;\n\t\tclk_entry_count = ARRAY_SIZE(ufx_ff802_clk_entries);\n\t}\n\n\tfor (i = 0; i < clk_entry_count; ++i) {\n\t\tclk_entry = clk_entries + i;\n\t\tsnd_iprintf(buffer, \"%s: \", clk_entry->label);\n\t\tif (data & clk_entry->locked_mask) {\n\t\t\tif (data & clk_entry->synced_mask)\n\t\t\t\tsnd_iprintf(buffer, \"sync\\n\");\n\t\t\telse\n\t\t\t\tsnd_iprintf(buffer, \"lock\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"none\\n\");\n\t\t}\n\t}\n\n\terr = parse_clock_bits(data, &rate, &src, ff->unit_version);\n\tif (err < 0)\n\t\treturn;\n\tlabel = snd_ff_proc_get_clk_label(src);\n\tif (!label)\n\t\treturn;\n\n\tsnd_iprintf(buffer, \"Referred clock: %s %d\\n\", label, rate);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic void latter_handle_midi_msg(struct snd_ff *ff, unsigned int offset, const __le32 *buf,\n\t\t\t\t   size_t length, u32 tstamp)\n{\n\tu32 data = le32_to_cpu(*buf);\n\tunsigned int index = (data & 0x000000f0) >> 4;\n\tu8 byte[3];\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned int len;\n\n\tif (index >= ff->spec->midi_in_ports)\n\t\treturn;\n\n\tswitch (data & 0x0000000f) {\n\tcase 0x00000008:\n\tcase 0x00000009:\n\tcase 0x0000000a:\n\tcase 0x0000000b:\n\tcase 0x0000000e:\n\t\tlen = 3;\n\t\tbreak;\n\tcase 0x0000000c:\n\tcase 0x0000000d:\n\t\tlen = 2;\n\t\tbreak;\n\tdefault:\n\t\tlen = data & 0x00000003;\n\t\tif (len == 0)\n\t\t\tlen = 3;\n\t\tbreak;\n\t}\n\n\tbyte[0] = (data & 0x0000ff00) >> 8;\n\tbyte[1] = (data & 0x00ff0000) >> 16;\n\tbyte[2] = (data & 0xff000000) >> 24;\n\n\tsubstream = READ_ONCE(ff->tx_midi_substreams[index]);\n\tif (substream)\n\t\tsnd_rawmidi_receive(substream, byte, len);\n}\n\n \nstatic inline int calculate_message_bytes(u8 status)\n{\n\tswitch (status) {\n\tcase 0xf6:\t \n\tcase 0xf8:\t \n\tcase 0xfa:\t \n\tcase 0xfb:\t \n\tcase 0xfc:\t \n\tcase 0xfe:\t \n\tcase 0xff:\t \n\t\treturn 1;\n\tcase 0xf1:\t \n\tcase 0xf3:\t \n\t\treturn 2;\n\tcase 0xf2:\t \n\t\treturn 3;\n\tcase 0xf0:\t \n\t\treturn 0;\n\tcase 0xf7:\t \n\t\tbreak;\n\tcase 0xf4:\t \n\tcase 0xf5:\t \n\tcase 0xf9:\t \n\tcase 0xfd:\t \n\t\tbreak;\n\tdefault:\n\t\tswitch (status & 0xf0) {\n\t\tcase 0x80:\t \n\t\tcase 0x90:\t \n\t\tcase 0xa0:\t \n\t\tcase 0xb0:\t \n\t\tcase 0xe0:\t \n\t\t\treturn 3;\n\t\tcase 0xc0:\t \n\t\tcase 0xd0:\t \n\t\t\treturn 2;\n\t\tdefault:\n\t\tbreak;\n\t\t}\n\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int latter_fill_midi_msg(struct snd_ff *ff,\n\t\t\t\tstruct snd_rawmidi_substream *substream,\n\t\t\t\tunsigned int port)\n{\n\tu32 data = {0};\n\tu8 *buf = (u8 *)&data;\n\tint consumed;\n\n\tbuf[0] = port << 4;\n\tconsumed = snd_rawmidi_transmit_peek(substream, buf + 1, 3);\n\tif (consumed <= 0)\n\t\treturn consumed;\n\n\tif (!ff->on_sysex[port]) {\n\t\tif (buf[1] != 0xf0) {\n\t\t\tif (consumed < calculate_message_bytes(buf[1]))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\t\n\t\t\tff->on_sysex[port] = true;\n\t\t}\n\n\t\tbuf[0] |= consumed;\n\t} else {\n\t\tif (buf[1] != 0xf7) {\n\t\t\tif (buf[2] == 0xf7 || buf[3] == 0xf7) {\n\t\t\t\t\n\t\t\t\tconsumed -= 1;\n\t\t\t}\n\n\t\t\tbuf[0] |= consumed;\n\t\t} else {\n\t\t\t\n\t\t\tff->on_sysex[port] = false;\n\t\t\tconsumed = 1;\n\t\t\tbuf[0] |= 0x0f;\n\t\t}\n\t}\n\n\tff->msg_buf[port][0] = cpu_to_le32(data);\n\tff->rx_bytes[port] = consumed;\n\n\treturn 1;\n}\n\nconst struct snd_ff_protocol snd_ff_protocol_latter = {\n\t.handle_msg\t\t= latter_handle_midi_msg,\n\t.fill_midi_msg\t\t= latter_fill_midi_msg,\n\t.get_clock\t\t= latter_get_clock,\n\t.switch_fetching_mode\t= latter_switch_fetching_mode,\n\t.allocate_resources\t= latter_allocate_resources,\n\t.begin_session\t\t= latter_begin_session,\n\t.finish_session\t\t= latter_finish_session,\n\t.dump_status\t\t= latter_dump_status,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}