{
  "module_name": "fcp.c",
  "hash_id": "c7faf5e93b7da19aa4c7f787ffdc631a89f1f3c3defd74522f57da31207e0b3b",
  "original_prompt": "Ingested from linux-6.6.14/sound/firewire/fcp.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include \"fcp.h\"\n#include \"lib.h\"\n#include \"amdtp-stream.h\"\n\n#define CTS_AVC 0x00\n\n#define ERROR_RETRIES\t3\n#define ERROR_DELAY_MS\t5\n#define FCP_TIMEOUT_MS\t125\n\nint avc_general_set_sig_fmt(struct fw_unit *unit, unsigned int rate,\n\t\t\t    enum avc_general_plug_dir dir,\n\t\t\t    unsigned short pid)\n{\n\tunsigned int sfc;\n\tu8 *buf;\n\tbool flag;\n\tint err;\n\n\tflag = false;\n\tfor (sfc = 0; sfc < CIP_SFC_COUNT; sfc++) {\n\t\tif (amdtp_rate_table[sfc] == rate) {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!flag)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(8, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 0x00;\t\t \n\tbuf[1] = 0xff;\t\t \n\tif (dir == AVC_GENERAL_PLUG_DIR_IN)\n\t\tbuf[2] = 0x19;\t \n\telse\n\t\tbuf[2] = 0x18;\t \n\tbuf[3] = 0xff & pid;\t \n\tbuf[4] = 0x90;\t\t \n\tbuf[5] = 0x07 & sfc;\t \n\tbuf[6] = 0xff;\t\t \n\tbuf[7] = 0xff;\t\t \n\n\t \n\terr = fcp_avc_transaction(unit, buf, 8, buf, 8,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));\n\tif (err < 0)\n\t\t;\n\telse if (err < 8)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\tif (err < 0)\n\t\tgoto end;\n\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\nEXPORT_SYMBOL(avc_general_set_sig_fmt);\n\nint avc_general_get_sig_fmt(struct fw_unit *unit, unsigned int *rate,\n\t\t\t    enum avc_general_plug_dir dir,\n\t\t\t    unsigned short pid)\n{\n\tunsigned int sfc;\n\tu8 *buf;\n\tint err;\n\n\tbuf = kzalloc(8, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 0x01;\t\t \n\tbuf[1] = 0xff;\t\t \n\tif (dir == AVC_GENERAL_PLUG_DIR_IN)\n\t\tbuf[2] = 0x19;\t \n\telse\n\t\tbuf[2] = 0x18;\t \n\tbuf[3] = 0xff & pid;\t \n\tbuf[4] = 0x90;\t\t \n\tbuf[5] = 0xff;\t\t \n\tbuf[6] = 0xff;\t\t \n\tbuf[7] = 0xff;\t\t \n\n\t \n\terr = fcp_avc_transaction(unit, buf, 8, buf, 8,\n\t\t\t\t  BIT(1) | BIT(2) | BIT(3) | BIT(4));\n\tif (err < 0)\n\t\t;\n\telse if (err < 8)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\t \n\tsfc = 0x07 & buf[5];\n\tif (sfc >= CIP_SFC_COUNT) {\n\t\terr = -EAGAIN;\t \n\t\tgoto end;\n\t}\n\n\t*rate = amdtp_rate_table[sfc];\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\nEXPORT_SYMBOL(avc_general_get_sig_fmt);\n\nint avc_general_get_plug_info(struct fw_unit *unit, unsigned int subunit_type,\n\t\t\t      unsigned int subunit_id, unsigned int subfunction,\n\t\t\t      u8 info[AVC_PLUG_INFO_BUF_BYTES])\n{\n\tu8 *buf;\n\tint err;\n\n\t \n\tif ((subunit_type == 0x1E) || (subunit_id == 5))\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(8, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 0x01;\t \n\t \n\tbuf[1] = ((subunit_type & 0x1f) << 3) | (subunit_id & 0x7);\n\tbuf[2] = 0x02;\t \n\tbuf[3] = 0xff & subfunction;\n\n\terr = fcp_avc_transaction(unit, buf, 8, buf, 8, BIT(1) | BIT(2));\n\tif (err < 0)\n\t\t;\n\telse if (err < 8)\n\t\terr = -EIO;\n\telse if (buf[0] == 0x08)  \n\t\terr = -ENOSYS;\n\telse if (buf[0] == 0x0a)  \n\t\terr = -EINVAL;\n\telse if (buf[0] == 0x0b)  \n\t\terr = -EAGAIN;\n\tif (err < 0)\n\t\tgoto end;\n\n\tinfo[0] = buf[4];\n\tinfo[1] = buf[5];\n\tinfo[2] = buf[6];\n\tinfo[3] = buf[7];\n\n\terr = 0;\nend:\n\tkfree(buf);\n\treturn err;\n}\nEXPORT_SYMBOL(avc_general_get_plug_info);\n\nstatic DEFINE_SPINLOCK(transactions_lock);\nstatic LIST_HEAD(transactions);\n\nenum fcp_state {\n\tSTATE_PENDING,\n\tSTATE_BUS_RESET,\n\tSTATE_COMPLETE,\n\tSTATE_DEFERRED,\n};\n\nstruct fcp_transaction {\n\tstruct list_head list;\n\tstruct fw_unit *unit;\n\tvoid *response_buffer;\n\tunsigned int response_size;\n\tunsigned int response_match_bytes;\n\tenum fcp_state state;\n\twait_queue_head_t wait;\n\tbool deferrable;\n};\n\n \nint fcp_avc_transaction(struct fw_unit *unit,\n\t\t\tconst void *command, unsigned int command_size,\n\t\t\tvoid *response, unsigned int response_size,\n\t\t\tunsigned int response_match_bytes)\n{\n\tstruct fcp_transaction t;\n\tint tcode, ret, tries = 0;\n\n\tt.unit = unit;\n\tt.response_buffer = response;\n\tt.response_size = response_size;\n\tt.response_match_bytes = response_match_bytes;\n\tt.state = STATE_PENDING;\n\tinit_waitqueue_head(&t.wait);\n\tt.deferrable = (*(const u8 *)command == 0x00 || *(const u8 *)command == 0x03);\n\n\tspin_lock_irq(&transactions_lock);\n\tlist_add_tail(&t.list, &transactions);\n\tspin_unlock_irq(&transactions_lock);\n\n\tfor (;;) {\n\t\ttcode = command_size == 4 ? TCODE_WRITE_QUADLET_REQUEST\n\t\t\t\t\t  : TCODE_WRITE_BLOCK_REQUEST;\n\t\tret = snd_fw_transaction(t.unit, tcode,\n\t\t\t\t\t CSR_REGISTER_BASE + CSR_FCP_COMMAND,\n\t\t\t\t\t (void *)command, command_size, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\ndeferred:\n\t\twait_event_timeout(t.wait, t.state != STATE_PENDING,\n\t\t\t\t   msecs_to_jiffies(FCP_TIMEOUT_MS));\n\n\t\tif (t.state == STATE_DEFERRED) {\n\t\t\t \n\t\t\tt.state = STATE_PENDING;\n\t\t\tgoto deferred;\n\t\t} else if (t.state == STATE_COMPLETE) {\n\t\t\tret = t.response_size;\n\t\t\tbreak;\n\t\t} else if (t.state == STATE_BUS_RESET) {\n\t\t\tmsleep(ERROR_DELAY_MS);\n\t\t} else if (++tries >= ERROR_RETRIES) {\n\t\t\tdev_err(&t.unit->device, \"FCP command timed out\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_lock_irq(&transactions_lock);\n\tlist_del(&t.list);\n\tspin_unlock_irq(&transactions_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fcp_avc_transaction);\n\n \nvoid fcp_bus_reset(struct fw_unit *unit)\n{\n\tstruct fcp_transaction *t;\n\n\tspin_lock_irq(&transactions_lock);\n\tlist_for_each_entry(t, &transactions, list) {\n\t\tif (t->unit == unit &&\n\t\t    (t->state == STATE_PENDING ||\n\t\t     t->state == STATE_DEFERRED)) {\n\t\t\tt->state = STATE_BUS_RESET;\n\t\t\twake_up(&t->wait);\n\t\t}\n\t}\n\tspin_unlock_irq(&transactions_lock);\n}\nEXPORT_SYMBOL(fcp_bus_reset);\n\n \nstatic bool is_matching_response(struct fcp_transaction *transaction,\n\t\t\t\t const void *response, size_t length)\n{\n\tconst u8 *p1, *p2;\n\tunsigned int mask, i;\n\n\tp1 = response;\n\tp2 = transaction->response_buffer;\n\tmask = transaction->response_match_bytes;\n\n\tfor (i = 0; ; ++i) {\n\t\tif ((mask & 1) && p1[i] != p2[i])\n\t\t\treturn false;\n\t\tmask >>= 1;\n\t\tif (!mask)\n\t\t\treturn true;\n\t\tif (--length == 0)\n\t\t\treturn false;\n\t}\n}\n\nstatic void fcp_response(struct fw_card *card, struct fw_request *request,\n\t\t\t int tcode, int destination, int source,\n\t\t\t int generation, unsigned long long offset,\n\t\t\t void *data, size_t length, void *callback_data)\n{\n\tstruct fcp_transaction *t;\n\tunsigned long flags;\n\n\tif (length < 1 || (*(const u8 *)data & 0xf0) != CTS_AVC)\n\t\treturn;\n\n\tspin_lock_irqsave(&transactions_lock, flags);\n\tlist_for_each_entry(t, &transactions, list) {\n\t\tstruct fw_device *device = fw_parent_device(t->unit);\n\t\tif (device->card != card ||\n\t\t    device->generation != generation)\n\t\t\tcontinue;\n\t\tsmp_rmb();  \n\t\tif (device->node_id != source)\n\t\t\tcontinue;\n\n\t\tif (t->state == STATE_PENDING &&\n\t\t    is_matching_response(t, data, length)) {\n\t\t\tif (t->deferrable && *(const u8 *)data == 0x0f) {\n\t\t\t\tt->state = STATE_DEFERRED;\n\t\t\t} else {\n\t\t\t\tt->state = STATE_COMPLETE;\n\t\t\t\tt->response_size = min_t(unsigned int, length,\n\t\t\t\t\t\t\t t->response_size);\n\t\t\t\tmemcpy(t->response_buffer, data,\n\t\t\t\t       t->response_size);\n\t\t\t}\n\t\t\twake_up(&t->wait);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&transactions_lock, flags);\n}\n\nstatic struct fw_address_handler response_register_handler = {\n\t.length = 0x200,\n\t.address_callback = fcp_response,\n};\n\nstatic int __init fcp_module_init(void)\n{\n\tstatic const struct fw_address_region response_register_region = {\n\t\t.start = CSR_REGISTER_BASE + CSR_FCP_RESPONSE,\n\t\t.end = CSR_REGISTER_BASE + CSR_FCP_END,\n\t};\n\n\tfw_core_add_address_handler(&response_register_handler,\n\t\t\t\t    &response_register_region);\n\n\treturn 0;\n}\n\nstatic void __exit fcp_module_exit(void)\n{\n\tWARN_ON(!list_empty(&transactions));\n\tfw_core_remove_address_handler(&response_register_handler);\n}\n\nmodule_init(fcp_module_init);\nmodule_exit(fcp_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}