{
  "module_name": "wss_lib.c",
  "hash_id": "260cc47fae0a4594f880626c3208fe6e0d3cb619f93dd9ed1624287d1261cff9",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/wss/wss_lib.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for control of CS4231(A)/CS4232/InterWave & compatible chips\");\nMODULE_LICENSE(\"GPL\");\n\n#if 0\n#define SNDRV_DEBUG_MCE\n#endif\n\n \n\nstatic const unsigned char freq_bits[14] = {\n\t \t0x00 | CS4231_XTAL2,\n\t \t0x0E | CS4231_XTAL2,\n\t \t0x00 | CS4231_XTAL1,\n\t \t0x0E | CS4231_XTAL1,\n\t \t0x02 | CS4231_XTAL2,\n\t \t0x02 | CS4231_XTAL1,\n\t \t0x04 | CS4231_XTAL2,\n\t \t0x06 | CS4231_XTAL2,\n\t \t0x04 | CS4231_XTAL1,\n\t \t0x06 | CS4231_XTAL1,\n\t \t0x0C | CS4231_XTAL2,\n\t \t0x08 | CS4231_XTAL2,\n\t \t0x0A | CS4231_XTAL2,\n\t \t0x0C | CS4231_XTAL1\n};\n\nstatic const unsigned int rates[14] = {\n\t5510, 6620, 8000, 9600, 11025, 16000, 18900, 22050,\n\t27042, 32000, 33075, 37800, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic int snd_wss_xrate(struct snd_pcm_runtime *runtime)\n{\n\treturn snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &hw_constraints_rates);\n}\n\nstatic const unsigned char snd_wss_original_image[32] =\n{\n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0xbf,\t\t\t \n\t0xbf,\t\t\t \n\t0x20,\t\t\t \n\tCS4231_AUTOCALIB,\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\tCS4231_MODE2,\t\t \n\t0xfc,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x80,\t\t\t \n\t0x01,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0xcf,\t\t\t \n\t0x00,\t\t\t \n\t0x20,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n};\n\nstatic const unsigned char snd_opti93x_original_image[32] =\n{\n\t0x00,\t\t \n\t0x00,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x80,\t\t \n\t0x80,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x0a,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x88,\t\t \n\t0x80,\t\t \n\t0x80,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00\t\t \n};\n\n \n\nstatic inline void wss_outb(struct snd_wss *chip, u8 offset, u8 val)\n{\n\toutb(val, chip->port + offset);\n}\n\nstatic inline u8 wss_inb(struct snd_wss *chip, u8 offset)\n{\n\treturn inb(chip->port + offset);\n}\n\nstatic void snd_wss_wait(struct snd_wss *chip)\n{\n\tint timeout;\n\n\tfor (timeout = 250;\n\t     timeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\n\t     timeout--)\n\t\tudelay(100);\n}\n\nstatic void snd_wss_dout(struct snd_wss *chip, unsigned char reg,\n\t\t\t unsigned char value)\n{\n\tint timeout;\n\n\tfor (timeout = 250;\n\t     timeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\n\t     timeout--)\n\t\tudelay(10);\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\n\twss_outb(chip, CS4231P(REG), value);\n\tmb();\n}\n\nvoid snd_wss_out(struct snd_wss *chip, unsigned char reg, unsigned char value)\n{\n\tsnd_wss_wait(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\n\t\tsnd_printk(KERN_DEBUG \"out: auto calibration time out \"\n\t\t\t   \"- reg = 0x%x, value = 0x%x\\n\", reg, value);\n#endif\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\n\twss_outb(chip, CS4231P(REG), value);\n\tchip->image[reg] = value;\n\tmb();\n\tsnd_printdd(\"codec out - reg 0x%x = 0x%x\\n\",\n\t\t\tchip->mce_bit | reg, value);\n}\nEXPORT_SYMBOL(snd_wss_out);\n\nunsigned char snd_wss_in(struct snd_wss *chip, unsigned char reg)\n{\n\tsnd_wss_wait(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\n\t\tsnd_printk(KERN_DEBUG \"in: auto calibration time out \"\n\t\t\t   \"- reg = 0x%x\\n\", reg);\n#endif\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\n\tmb();\n\treturn wss_inb(chip, CS4231P(REG));\n}\nEXPORT_SYMBOL(snd_wss_in);\n\nvoid snd_cs4236_ext_out(struct snd_wss *chip, unsigned char reg,\n\t\t\tunsigned char val)\n{\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);\n\twss_outb(chip, CS4231P(REG),\n\t\t reg | (chip->image[CS4236_EXT_REG] & 0x01));\n\twss_outb(chip, CS4231P(REG), val);\n\tchip->eimage[CS4236_REG(reg)] = val;\n#if 0\n\tprintk(KERN_DEBUG \"ext out : reg = 0x%x, val = 0x%x\\n\", reg, val);\n#endif\n}\nEXPORT_SYMBOL(snd_cs4236_ext_out);\n\nunsigned char snd_cs4236_ext_in(struct snd_wss *chip, unsigned char reg)\n{\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);\n\twss_outb(chip, CS4231P(REG),\n\t\t reg | (chip->image[CS4236_EXT_REG] & 0x01));\n#if 1\n\treturn wss_inb(chip, CS4231P(REG));\n#else\n\t{\n\t\tunsigned char res;\n\t\tres = wss_inb(chip, CS4231P(REG));\n\t\tprintk(KERN_DEBUG \"ext in : reg = 0x%x, val = 0x%x\\n\",\n\t\t       reg, res);\n\t\treturn res;\n\t}\n#endif\n}\nEXPORT_SYMBOL(snd_cs4236_ext_in);\n\n#if 0\n\nstatic void snd_wss_debug(struct snd_wss *chip)\n{\n\tprintk(KERN_DEBUG\n\t\t\"CS4231 REGS:      INDEX = 0x%02x  \"\n\t\t\"                 STATUS = 0x%02x\\n\",\n\t\t\t\t\twss_inb(chip, CS4231P(REGSEL)),\n\t\t\t\t\twss_inb(chip, CS4231P(STATUS)));\n\tprintk(KERN_DEBUG\n\t\t\"  0x00: left input      = 0x%02x  \"\n\t\t\"  0x10: alt 1 (CFIG 2)  = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x00),\n\t\t\t\t\tsnd_wss_in(chip, 0x10));\n\tprintk(KERN_DEBUG\n\t\t\"  0x01: right input     = 0x%02x  \"\n\t\t\"  0x11: alt 2 (CFIG 3)  = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x01),\n\t\t\t\t\tsnd_wss_in(chip, 0x11));\n\tprintk(KERN_DEBUG\n\t\t\"  0x02: GF1 left input  = 0x%02x  \"\n\t\t\"  0x12: left line in    = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x02),\n\t\t\t\t\tsnd_wss_in(chip, 0x12));\n\tprintk(KERN_DEBUG\n\t\t\"  0x03: GF1 right input = 0x%02x  \"\n\t\t\"  0x13: right line in   = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x03),\n\t\t\t\t\tsnd_wss_in(chip, 0x13));\n\tprintk(KERN_DEBUG\n\t\t\"  0x04: CD left input   = 0x%02x  \"\n\t\t\"  0x14: timer low       = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x04),\n\t\t\t\t\tsnd_wss_in(chip, 0x14));\n\tprintk(KERN_DEBUG\n\t\t\"  0x05: CD right input  = 0x%02x  \"\n\t\t\"  0x15: timer high      = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x05),\n\t\t\t\t\tsnd_wss_in(chip, 0x15));\n\tprintk(KERN_DEBUG\n\t\t\"  0x06: left output     = 0x%02x  \"\n\t\t\"  0x16: left MIC (PnP)  = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x06),\n\t\t\t\t\tsnd_wss_in(chip, 0x16));\n\tprintk(KERN_DEBUG\n\t\t\"  0x07: right output    = 0x%02x  \"\n\t\t\"  0x17: right MIC (PnP) = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x07),\n\t\t\t\t\tsnd_wss_in(chip, 0x17));\n\tprintk(KERN_DEBUG\n\t\t\"  0x08: playback format = 0x%02x  \"\n\t\t\"  0x18: IRQ status      = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x08),\n\t\t\t\t\tsnd_wss_in(chip, 0x18));\n\tprintk(KERN_DEBUG\n\t\t\"  0x09: iface (CFIG 1)  = 0x%02x  \"\n\t\t\"  0x19: left line out   = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x09),\n\t\t\t\t\tsnd_wss_in(chip, 0x19));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0a: pin control     = 0x%02x  \"\n\t\t\"  0x1a: mono control    = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0a),\n\t\t\t\t\tsnd_wss_in(chip, 0x1a));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0b: init & status   = 0x%02x  \"\n\t\t\"  0x1b: right line out  = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0b),\n\t\t\t\t\tsnd_wss_in(chip, 0x1b));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0c: revision & mode = 0x%02x  \"\n\t\t\"  0x1c: record format   = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0c),\n\t\t\t\t\tsnd_wss_in(chip, 0x1c));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0d: loopback        = 0x%02x  \"\n\t\t\"  0x1d: var freq (PnP)  = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0d),\n\t\t\t\t\tsnd_wss_in(chip, 0x1d));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0e: ply upr count   = 0x%02x  \"\n\t\t\"  0x1e: ply lwr count   = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0e),\n\t\t\t\t\tsnd_wss_in(chip, 0x1e));\n\tprintk(KERN_DEBUG\n\t\t\"  0x0f: rec upr count   = 0x%02x  \"\n\t\t\"  0x1f: rec lwr count   = 0x%02x\\n\",\n\t\t\t\t\tsnd_wss_in(chip, 0x0f),\n\t\t\t\t\tsnd_wss_in(chip, 0x1f));\n}\n\n#endif\n\n \n\nstatic void snd_wss_busy_wait(struct snd_wss *chip)\n{\n\tint timeout;\n\n\t \n\tfor (timeout = 5; timeout > 0; timeout--)\n\t\twss_inb(chip, CS4231P(REGSEL));\n\t \n\tfor (timeout = 25000;\n\t     timeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\n\t     timeout--)\n\t\tudelay(10);\n}\n\nvoid snd_wss_mce_up(struct snd_wss *chip)\n{\n\tunsigned long flags;\n\tint timeout;\n\n\tsnd_wss_wait(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\n\t\tsnd_printk(KERN_DEBUG\n\t\t\t   \"mce_up - auto calibration time out (0)\\n\");\n#endif\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->mce_bit |= CS4231_MCE;\n\ttimeout = wss_inb(chip, CS4231P(REGSEL));\n\tif (timeout == 0x80)\n\t\tsnd_printk(KERN_DEBUG \"mce_up [0x%lx]: \"\n\t\t\t   \"serious init problem - codec still busy\\n\",\n\t\t\t   chip->port);\n\tif (!(timeout & CS4231_MCE))\n\t\twss_outb(chip, CS4231P(REGSEL),\n\t\t\t chip->mce_bit | (timeout & 0x1f));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\nEXPORT_SYMBOL(snd_wss_mce_up);\n\nvoid snd_wss_mce_down(struct snd_wss *chip)\n{\n\tunsigned long flags;\n\tunsigned long end_time;\n\tint timeout;\n\tint hw_mask = WSS_HW_CS4231_MASK | WSS_HW_CS4232_MASK | WSS_HW_AD1848;\n\n\tsnd_wss_busy_wait(chip);\n\n#ifdef CONFIG_SND_DEBUG\n\tif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\n\t\tsnd_printk(KERN_DEBUG \"mce_down [0x%lx] - \"\n\t\t\t   \"auto calibration time out (0)\\n\",\n\t\t\t   (long)CS4231P(REGSEL));\n#endif\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->mce_bit &= ~CS4231_MCE;\n\ttimeout = wss_inb(chip, CS4231P(REGSEL));\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (timeout == 0x80)\n\t\tsnd_printk(KERN_DEBUG \"mce_down [0x%lx]: \"\n\t\t\t   \"serious init problem - codec still busy\\n\",\n\t\t\t   chip->port);\n\tif ((timeout & CS4231_MCE) == 0 || !(chip->hardware & hw_mask))\n\t\treturn;\n\n\t \n\tmsleep(1);\n\n\tsnd_printdd(\"(1) jiffies = %lu\\n\", jiffies);\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(250);\n\twhile (snd_wss_in(chip, CS4231_TEST_INIT) &\n\t\tCS4231_CALIB_IN_PROGRESS) {\n\n\t\tif (time_after(jiffies, end_time)) {\n\t\t\tsnd_printk(KERN_ERR \"mce_down - \"\n\t\t\t\t\t\"auto calibration time out (2)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tsnd_printdd(\"(2) jiffies = %lu\\n\", jiffies);\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(100);\n\twhile (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT) {\n\t\tif (time_after(jiffies, end_time)) {\n\t\t\tsnd_printk(KERN_ERR \"mce_down - auto calibration time out (3)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tsnd_printdd(\"(3) jiffies = %lu\\n\", jiffies);\n\tsnd_printd(\"mce_down - exit = 0x%x\\n\", wss_inb(chip, CS4231P(REGSEL)));\n}\nEXPORT_SYMBOL(snd_wss_mce_down);\n\nstatic unsigned int snd_wss_get_count(unsigned char format, unsigned int size)\n{\n\tswitch (format & 0xe0) {\n\tcase CS4231_LINEAR_16:\n\tcase CS4231_LINEAR_16_BIG:\n\t\tsize >>= 1;\n\t\tbreak;\n\tcase CS4231_ADPCM_16:\n\t\treturn size >> 2;\n\t}\n\tif (format & CS4231_STEREO)\n\t\tsize >>= 1;\n\treturn size;\n}\n\nstatic int snd_wss_trigger(struct snd_pcm_substream *substream,\n\t\t\t   int cmd)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\tunsigned int what;\n\tstruct snd_pcm_substream *s;\n\tint do_start;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tdo_start = 1; break;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdo_start = 0; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhat = 0;\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s == chip->playback_substream) {\n\t\t\twhat |= CS4231_PLAYBACK_ENABLE;\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t} else if (s == chip->capture_substream) {\n\t\t\twhat |= CS4231_RECORD_ENABLE;\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t}\n\t}\n\tspin_lock(&chip->reg_lock);\n\tif (do_start) {\n\t\tchip->image[CS4231_IFACE_CTRL] |= what;\n\t\tif (chip->trigger)\n\t\t\tchip->trigger(chip, what, 1);\n\t} else {\n\t\tchip->image[CS4231_IFACE_CTRL] &= ~what;\n\t\tif (chip->trigger)\n\t\t\tchip->trigger(chip, what, 0);\n\t}\n\tsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\n\tspin_unlock(&chip->reg_lock);\n#if 0\n\tsnd_wss_debug(chip);\n#endif\n\treturn result;\n}\n\n \n\nstatic unsigned char snd_wss_get_rate(unsigned int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rates); i++)\n\t\tif (rate == rates[i])\n\t\t\treturn freq_bits[i];\n\t\n\treturn freq_bits[ARRAY_SIZE(rates) - 1];\n}\n\nstatic unsigned char snd_wss_get_format(struct snd_wss *chip,\n\t\t\t\t\tsnd_pcm_format_t format,\n\t\t\t\t\tint channels)\n{\n\tunsigned char rformat;\n\n\trformat = CS4231_LINEAR_8;\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\trformat = CS4231_ULAW_8; break;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\trformat = CS4231_ALAW_8; break;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\trformat = CS4231_LINEAR_16; break;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\trformat = CS4231_LINEAR_16_BIG; break;\n\tcase SNDRV_PCM_FORMAT_IMA_ADPCM:\trformat = CS4231_ADPCM_16; break;\n\t}\n\tif (channels > 1)\n\t\trformat |= CS4231_STEREO;\n#if 0\n\tsnd_printk(KERN_DEBUG \"get_format: 0x%x (mode=0x%x)\\n\", format, mode);\n#endif\n\treturn rformat;\n}\n\nstatic void snd_wss_calibrate_mute(struct snd_wss *chip, int mute)\n{\n\tunsigned long flags;\n\n\tmute = mute ? 0x80 : 0;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->calibrate_mute == mute) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn;\n\t}\n\tif (!mute) {\n\t\tsnd_wss_dout(chip, CS4231_LEFT_INPUT,\n\t\t\t     chip->image[CS4231_LEFT_INPUT]);\n\t\tsnd_wss_dout(chip, CS4231_RIGHT_INPUT,\n\t\t\t     chip->image[CS4231_RIGHT_INPUT]);\n\t\tsnd_wss_dout(chip, CS4231_LOOPBACK,\n\t\t\t     chip->image[CS4231_LOOPBACK]);\n\t} else {\n\t\tsnd_wss_dout(chip, CS4231_LEFT_INPUT,\n\t\t\t     0);\n\t\tsnd_wss_dout(chip, CS4231_RIGHT_INPUT,\n\t\t\t     0);\n\t\tsnd_wss_dout(chip, CS4231_LOOPBACK,\n\t\t\t     0xfd);\n\t}\n\n\tsnd_wss_dout(chip, CS4231_AUX1_LEFT_INPUT,\n\t\t     mute | chip->image[CS4231_AUX1_LEFT_INPUT]);\n\tsnd_wss_dout(chip, CS4231_AUX1_RIGHT_INPUT,\n\t\t     mute | chip->image[CS4231_AUX1_RIGHT_INPUT]);\n\tsnd_wss_dout(chip, CS4231_AUX2_LEFT_INPUT,\n\t\t     mute | chip->image[CS4231_AUX2_LEFT_INPUT]);\n\tsnd_wss_dout(chip, CS4231_AUX2_RIGHT_INPUT,\n\t\t     mute | chip->image[CS4231_AUX2_RIGHT_INPUT]);\n\tsnd_wss_dout(chip, CS4231_LEFT_OUTPUT,\n\t\t     mute | chip->image[CS4231_LEFT_OUTPUT]);\n\tsnd_wss_dout(chip, CS4231_RIGHT_OUTPUT,\n\t\t     mute | chip->image[CS4231_RIGHT_OUTPUT]);\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\n\t\tsnd_wss_dout(chip, CS4231_LEFT_LINE_IN,\n\t\t\t     mute | chip->image[CS4231_LEFT_LINE_IN]);\n\t\tsnd_wss_dout(chip, CS4231_RIGHT_LINE_IN,\n\t\t\t     mute | chip->image[CS4231_RIGHT_LINE_IN]);\n\t\tsnd_wss_dout(chip, CS4231_MONO_CTRL,\n\t\t\t     mute ? 0xc0 : chip->image[CS4231_MONO_CTRL]);\n\t}\n\tif (chip->hardware == WSS_HW_INTERWAVE) {\n\t\tsnd_wss_dout(chip, CS4231_LEFT_MIC_INPUT,\n\t\t\t     mute | chip->image[CS4231_LEFT_MIC_INPUT]);\n\t\tsnd_wss_dout(chip, CS4231_RIGHT_MIC_INPUT,\n\t\t\t     mute | chip->image[CS4231_RIGHT_MIC_INPUT]);\n\t\tsnd_wss_dout(chip, CS4231_LINE_LEFT_OUTPUT,\n\t\t\t     mute | chip->image[CS4231_LINE_LEFT_OUTPUT]);\n\t\tsnd_wss_dout(chip, CS4231_LINE_RIGHT_OUTPUT,\n\t\t\t     mute | chip->image[CS4231_LINE_RIGHT_OUTPUT]);\n\t}\n\tchip->calibrate_mute = mute;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_wss_playback_format(struct snd_wss *chip,\n\t\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t\t       unsigned char pdfr)\n{\n\tunsigned long flags;\n\tint full_calib = 1;\n\n\tmutex_lock(&chip->mce_mutex);\n\tif (chip->hardware == WSS_HW_CS4231A ||\n\t    (chip->hardware & WSS_HW_CS4232_MASK)) {\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tif ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (pdfr & 0x0f)) {\t \n\t\t\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t\t    chip->image[CS4231_ALT_FEATURE_1] | 0x10);\n\t\t\tchip->image[CS4231_PLAYBK_FORMAT] = pdfr;\n\t\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t\t\t    chip->image[CS4231_PLAYBK_FORMAT]);\n\t\t\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t\t    chip->image[CS4231_ALT_FEATURE_1] &= ~0x10);\n\t\t\tudelay(100);  \n\t\t\tfull_calib = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t} else if (chip->hardware == WSS_HW_AD1845) {\n\t\tunsigned rate = params_rate(params);\n\n\t\t \n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, (pdfr & 0xf0));\n\t\tsnd_wss_out(chip, AD1845_UPR_FREQ_SEL, (rate >> 8) & 0xff);\n\t\tsnd_wss_out(chip, AD1845_LWR_FREQ_SEL, rate & 0xff);\n\t\tfull_calib = 0;\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t}\n\tif (full_calib) {\n\t\tsnd_wss_mce_up(chip);\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tif (chip->hardware != WSS_HW_INTERWAVE && !chip->single_dma) {\n\t\t\tif (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE)\n\t\t\t\tpdfr = (pdfr & 0xf0) |\n\t\t\t\t       (chip->image[CS4231_REC_FORMAT] & 0x0f);\n\t\t} else {\n\t\t\tchip->image[CS4231_PLAYBK_FORMAT] = pdfr;\n\t\t}\n\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, pdfr);\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\tif (chip->hardware == WSS_HW_OPL3SA2)\n\t\t\tudelay(100);\t \n\t\tsnd_wss_mce_down(chip);\n\t}\n\tmutex_unlock(&chip->mce_mutex);\n}\n\nstatic void snd_wss_capture_format(struct snd_wss *chip,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   unsigned char cdfr)\n{\n\tunsigned long flags;\n\tint full_calib = 1;\n\n\tmutex_lock(&chip->mce_mutex);\n\tif (chip->hardware == WSS_HW_CS4231A ||\n\t    (chip->hardware & WSS_HW_CS4232_MASK)) {\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tif ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (cdfr & 0x0f) ||\t \n\t\t    (chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {\n\t\t\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t\tchip->image[CS4231_ALT_FEATURE_1] | 0x20);\n\t\t\tsnd_wss_out(chip, CS4231_REC_FORMAT,\n\t\t\t\tchip->image[CS4231_REC_FORMAT] = cdfr);\n\t\t\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t\tchip->image[CS4231_ALT_FEATURE_1] &= ~0x20);\n\t\t\tfull_calib = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t} else if (chip->hardware == WSS_HW_AD1845) {\n\t\tunsigned rate = params_rate(params);\n\n\t\t \n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tsnd_wss_out(chip, CS4231_REC_FORMAT, (cdfr & 0xf0));\n\t\tsnd_wss_out(chip, AD1845_UPR_FREQ_SEL, (rate >> 8) & 0xff);\n\t\tsnd_wss_out(chip, AD1845_LWR_FREQ_SEL, rate & 0xff);\n\t\tfull_calib = 0;\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t}\n\tif (full_calib) {\n\t\tsnd_wss_mce_up(chip);\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tif (chip->hardware != WSS_HW_INTERWAVE &&\n\t\t    !(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {\n\t\t\tif (chip->single_dma)\n\t\t\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, cdfr);\n\t\t\telse\n\t\t\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t\t\t   (chip->image[CS4231_PLAYBK_FORMAT] & 0xf0) |\n\t\t\t\t   (cdfr & 0x0f));\n\t\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\t\tsnd_wss_mce_down(chip);\n\t\t\tsnd_wss_mce_up(chip);\n\t\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\t}\n\t\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, cdfr);\n\t\telse\n\t\t\tsnd_wss_out(chip, CS4231_REC_FORMAT, cdfr);\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\tsnd_wss_mce_down(chip);\n\t}\n\tmutex_unlock(&chip->mce_mutex);\n}\n\n \n\nstatic unsigned long snd_wss_timer_resolution(struct snd_timer *timer)\n{\n\tstruct snd_wss *chip = snd_timer_chip(timer);\n\tif (chip->hardware & WSS_HW_CS4236B_MASK)\n\t\treturn 14467;\n\telse\n\t\treturn chip->image[CS4231_PLAYBK_FORMAT] & 1 ? 9969 : 9920;\n}\n\nstatic int snd_wss_timer_start(struct snd_timer *timer)\n{\n\tunsigned long flags;\n\tunsigned int ticks;\n\tstruct snd_wss *chip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tticks = timer->sticks;\n\tif ((chip->image[CS4231_ALT_FEATURE_1] & CS4231_TIMER_ENABLE) == 0 ||\n\t    (unsigned char)(ticks >> 8) != chip->image[CS4231_TIMER_HIGH] ||\n\t    (unsigned char)ticks != chip->image[CS4231_TIMER_LOW]) {\n\t\tchip->image[CS4231_TIMER_HIGH] = (unsigned char) (ticks >> 8);\n\t\tsnd_wss_out(chip, CS4231_TIMER_HIGH,\n\t\t\t    chip->image[CS4231_TIMER_HIGH]);\n\t\tchip->image[CS4231_TIMER_LOW] = (unsigned char) ticks;\n\t\tsnd_wss_out(chip, CS4231_TIMER_LOW,\n\t\t\t    chip->image[CS4231_TIMER_LOW]);\n\t\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t    chip->image[CS4231_ALT_FEATURE_1] |\n\t\t\t    CS4231_TIMER_ENABLE);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_wss_timer_stop(struct snd_timer *timer)\n{\n\tunsigned long flags;\n\tstruct snd_wss *chip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->image[CS4231_ALT_FEATURE_1] &= ~CS4231_TIMER_ENABLE;\n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t    chip->image[CS4231_ALT_FEATURE_1]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic void snd_wss_init(struct snd_wss *chip)\n{\n\tunsigned long flags;\n\n\tsnd_wss_calibrate_mute(chip, 1);\n\tsnd_wss_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printk(KERN_DEBUG \"init: (1)\\n\");\n#endif\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |\n\t\t\t\t\t    CS4231_PLAYBACK_PIO |\n\t\t\t\t\t    CS4231_RECORD_ENABLE |\n\t\t\t\t\t    CS4231_RECORD_PIO |\n\t\t\t\t\t    CS4231_CALIB_MODE);\n\tchip->image[CS4231_IFACE_CTRL] |= CS4231_AUTOCALIB;\n\tsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printk(KERN_DEBUG \"init: (2)\\n\");\n#endif\n\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->image[CS4231_IFACE_CTRL] &= ~CS4231_AUTOCALIB;\n\tsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\n\tsnd_wss_out(chip,\n\t\t    CS4231_ALT_FEATURE_1, chip->image[CS4231_ALT_FEATURE_1]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printk(KERN_DEBUG \"init: (3) - afei = 0x%x\\n\",\n\t\t   chip->image[CS4231_ALT_FEATURE_1]);\n#endif\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_2,\n\t\t    chip->image[CS4231_ALT_FEATURE_2]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t    chip->image[CS4231_PLAYBK_FORMAT]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printk(KERN_DEBUG \"init: (4)\\n\");\n#endif\n\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK))\n\t\tsnd_wss_out(chip, CS4231_REC_FORMAT,\n\t\t\t    chip->image[CS4231_REC_FORMAT]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n\tsnd_wss_calibrate_mute(chip, 0);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printk(KERN_DEBUG \"init: (5)\\n\");\n#endif\n}\n\nstatic int snd_wss_open(struct snd_wss *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->open_mutex);\n\tif ((chip->mode & mode) ||\n\t    ((chip->mode & WSS_MODE_OPEN) && chip->single_dma)) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn -EAGAIN;\n\t}\n\tif (chip->mode & WSS_MODE_OPEN) {\n\t\tchip->mode |= mode;\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn 0;\n\t}\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS,\n\t\t\t    CS4231_PLAYBACK_IRQ |\n\t\t\t    CS4231_RECORD_IRQ |\n\t\t\t    CS4231_TIMER_IRQ);\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\n\t}\n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\tchip->image[CS4231_PIN_CTRL] |= CS4231_IRQ_ENABLE;\n\tsnd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS,\n\t\t\t    CS4231_PLAYBACK_IRQ |\n\t\t\t    CS4231_RECORD_IRQ |\n\t\t\t    CS4231_TIMER_IRQ);\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tchip->mode = mode;\n\tmutex_unlock(&chip->open_mutex);\n\treturn 0;\n}\n\nstatic void snd_wss_close(struct snd_wss *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->open_mutex);\n\tchip->mode &= ~mode;\n\tif (chip->mode & WSS_MODE_OPEN) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn;\n\t}\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK))\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\tchip->image[CS4231_PIN_CTRL] &= ~CS4231_IRQ_ENABLE;\n\tsnd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);\n\n\t \n\n\tif (chip->image[CS4231_IFACE_CTRL] & (CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\n\t\t\t\t\t       CS4231_RECORD_ENABLE | CS4231_RECORD_PIO)) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\tsnd_wss_mce_up(chip);\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\n\t\t\t\t\t\t     CS4231_RECORD_ENABLE | CS4231_RECORD_PIO);\n\t\tsnd_wss_out(chip, CS4231_IFACE_CTRL,\n\t\t\t    chip->image[CS4231_IFACE_CTRL]);\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\tsnd_wss_mce_down(chip);\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t}\n\n\t \n\tif (!(chip->hardware & WSS_HW_AD1848_MASK))\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\twss_outb(chip, CS4231P(STATUS), 0);\t \n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tchip->mode = 0;\n\tmutex_unlock(&chip->open_mutex);\n}\n\n \n\nstatic int snd_wss_timer_open(struct snd_timer *timer)\n{\n\tstruct snd_wss *chip = snd_timer_chip(timer);\n\tsnd_wss_open(chip, WSS_MODE_TIMER);\n\treturn 0;\n}\n\nstatic int snd_wss_timer_close(struct snd_timer *timer)\n{\n\tstruct snd_wss *chip = snd_timer_chip(timer);\n\tsnd_wss_close(chip, WSS_MODE_TIMER);\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_wss_timer_table =\n{\n\t.flags =\tSNDRV_TIMER_HW_AUTO,\n\t.resolution =\t9945,\n\t.ticks =\t65535,\n\t.open =\t\tsnd_wss_timer_open,\n\t.close =\tsnd_wss_timer_close,\n\t.c_resolution = snd_wss_timer_resolution,\n\t.start =\tsnd_wss_timer_start,\n\t.stop =\t\tsnd_wss_timer_stop,\n};\n\n \n\nstatic int snd_wss_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tunsigned char new_pdfr;\n\n\tnew_pdfr = snd_wss_get_format(chip, params_format(hw_params),\n\t\t\t\tparams_channels(hw_params)) |\n\t\t\t\tsnd_wss_get_rate(params_rate(hw_params));\n\tchip->set_playback_format(chip, hw_params, new_pdfr);\n\treturn 0;\n}\n\nstatic int snd_wss_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->p_dma_size = size;\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO);\n\tsnd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\n\tcount = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT], count) - 1;\n\tsnd_wss_out(chip, CS4231_PLY_LWR_CNT, (unsigned char) count);\n\tsnd_wss_out(chip, CS4231_PLY_UPR_CNT, (unsigned char) (count >> 8));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n#if 0\n\tsnd_wss_debug(chip);\n#endif\n\treturn 0;\n}\n\nstatic int snd_wss_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tunsigned char new_cdfr;\n\n\tnew_cdfr = snd_wss_get_format(chip, params_format(hw_params),\n\t\t\t   params_channels(hw_params)) |\n\t\t\t   snd_wss_get_rate(params_rate(hw_params));\n\tchip->set_capture_format(chip, hw_params, new_cdfr);\n\treturn 0;\n}\n\nstatic int snd_wss_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->c_dma_size = size;\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_RECORD_ENABLE | CS4231_RECORD_PIO);\n\tsnd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\tcount = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT],\n\t\t\t\t\t  count);\n\telse\n\t\tcount = snd_wss_get_count(chip->image[CS4231_REC_FORMAT],\n\t\t\t\t\t  count);\n\tcount--;\n\tif (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {\n\t\tsnd_wss_out(chip, CS4231_PLY_LWR_CNT, (unsigned char) count);\n\t\tsnd_wss_out(chip, CS4231_PLY_UPR_CNT,\n\t\t\t    (unsigned char) (count >> 8));\n\t} else {\n\t\tsnd_wss_out(chip, CS4231_REC_LWR_CNT, (unsigned char) count);\n\t\tsnd_wss_out(chip, CS4231_REC_UPR_CNT,\n\t\t\t    (unsigned char) (count >> 8));\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nvoid snd_wss_overrange(struct snd_wss *chip)\n{\n\tunsigned long flags;\n\tunsigned char res;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tres = snd_wss_in(chip, CS4231_TEST_INIT);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (res & (0x08 | 0x02))\t \n\t\tchip->capture_substream->runtime->overrange++;\n}\nEXPORT_SYMBOL(snd_wss_overrange);\n\nirqreturn_t snd_wss_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_wss *chip = dev_id;\n\tunsigned char status;\n\n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\t \n\t\tstatus = CS4231_PLAYBACK_IRQ;\n\telse\n\t\tstatus = snd_wss_in(chip, CS4231_IRQ_STATUS);\n\tif (status & CS4231_TIMER_IRQ) {\n\t\tif (chip->timer)\n\t\t\tsnd_timer_interrupt(chip->timer, chip->timer->sticks);\n\t}\n\tif (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {\n\t\tif (status & CS4231_PLAYBACK_IRQ) {\n\t\t\tif (chip->mode & WSS_MODE_PLAY) {\n\t\t\t\tif (chip->playback_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t\t}\n\t\t\tif (chip->mode & WSS_MODE_RECORD) {\n\t\t\t\tif (chip->capture_substream) {\n\t\t\t\t\tsnd_wss_overrange(chip);\n\t\t\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (status & CS4231_PLAYBACK_IRQ) {\n\t\t\tif (chip->playback_substream)\n\t\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t}\n\t\tif (status & CS4231_RECORD_IRQ) {\n\t\t\tif (chip->capture_substream) {\n\t\t\t\tsnd_wss_overrange(chip);\n\t\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&chip->reg_lock);\n\tstatus = ~CS4231_ALL_IRQS | ~status;\n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\twss_outb(chip, CS4231P(STATUS), 0);\n\telse\n\t\tsnd_wss_out(chip, CS4231_IRQ_STATUS, status);\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(snd_wss_interrupt);\n\nstatic snd_pcm_uframes_t snd_wss_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE))\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_wss_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE))\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n \n\nstatic int snd_ad1848_probe(struct snd_wss *chip)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\tunsigned long flags;\n\tunsigned char r;\n\tunsigned short hardware = 0;\n\tint err = 0;\n\tint i;\n\n\twhile (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ENODEV;\n\t\tcond_resched();\n\t}\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\t \n\tsnd_wss_dout(chip, CS4231_MISC_INFO, 0);\n\n\tsnd_wss_dout(chip, CS4231_RIGHT_INPUT, 0x45);  \n\tr = snd_wss_in(chip, CS4231_RIGHT_INPUT);\n\tif (r != 0x45) {\n\t\t \n\t\tif ((r & ~CS4231_ENABLE_MIC_GAIN) != 0x45) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\thardware = WSS_HW_AD1847;\n\t} else {\n\t\tsnd_wss_dout(chip, CS4231_LEFT_INPUT,  0xaa);\n\t\tr = snd_wss_in(chip, CS4231_LEFT_INPUT);\n\t\t \n\t\tif ((r | CS4231_ENABLE_MIC_GAIN) != 0xaa) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\twss_inb(chip, CS4231P(STATUS));\n\twss_outb(chip, CS4231P(STATUS), 0);\n\tmb();\n\n\tif ((chip->hardware & WSS_HW_TYPE_MASK) != WSS_HW_DETECT)\n\t\tgoto out;\n\n\tif (hardware) {\n\t\tchip->hardware = hardware;\n\t\tgoto out;\n\t}\n\n\tr = snd_wss_in(chip, CS4231_MISC_INFO);\n\n\t \n\tsnd_wss_dout(chip, CS4231_MISC_INFO, CS4231_MODE2);\n\tfor (i = 0; i < 16; i++) {\n\t\tif (snd_wss_in(chip, i) != snd_wss_in(chip, 16 + i)) {\n\t\t\t \n\t\t\tif ((r & 0xf) != 0xa)\n\t\t\t\tgoto out_mode;\n\t\t\t \n\t\t\tsnd_wss_dout(chip, CS4231_VERSION, 0);\n\t\t\tr = snd_wss_in(chip, CS4231_VERSION) & 0xe7;\n\t\t\tif (!r)\n\t\t\t\tchip->hardware = WSS_HW_CMI8330;\n\t\t\tgoto out_mode;\n\t\t}\n\t}\n\tif (r & 0x80)\n\t\tchip->hardware = WSS_HW_CS4248;\n\telse\n\t\tchip->hardware = WSS_HW_AD1848;\nout_mode:\n\tsnd_wss_dout(chip, CS4231_MISC_INFO, 0);\nout:\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn err;\n}\n\nstatic int snd_wss_probe(struct snd_wss *chip)\n{\n\tunsigned long flags;\n\tint i, id, rev, regnum;\n\tunsigned char *ptr;\n\tunsigned int hw;\n\n\tid = snd_ad1848_probe(chip);\n\tif (id < 0)\n\t\treturn id;\n\n\thw = chip->hardware;\n\tif ((hw & WSS_HW_TYPE_MASK) == WSS_HW_DETECT) {\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tmb();\n\t\t\tif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\n\t\t\t\tmsleep(2);\n\t\t\telse {\n\t\t\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\t\t\tsnd_wss_out(chip, CS4231_MISC_INFO,\n\t\t\t\t\t    CS4231_MODE2);\n\t\t\t\tid = snd_wss_in(chip, CS4231_MISC_INFO) & 0x0f;\n\t\t\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\t\t\tif (id == 0x0a)\n\t\t\t\t\tbreak;\t \n\t\t\t}\n\t\t}\n\t\tsnd_printdd(\"wss: port = 0x%lx, id = 0x%x\\n\", chip->port, id);\n\t\tif (id != 0x0a)\n\t\t\treturn -ENODEV;\t \n\n\t\trev = snd_wss_in(chip, CS4231_VERSION) & 0xe7;\n\t\tsnd_printdd(\"CS4231: VERSION (I25) = 0x%x\\n\", rev);\n\t\tif (rev == 0x80) {\n\t\t\tunsigned char tmp = snd_wss_in(chip, 23);\n\t\t\tsnd_wss_out(chip, 23, ~tmp);\n\t\t\tif (snd_wss_in(chip, 23) != tmp)\n\t\t\t\tchip->hardware = WSS_HW_AD1845;\n\t\t\telse\n\t\t\t\tchip->hardware = WSS_HW_CS4231;\n\t\t} else if (rev == 0xa0) {\n\t\t\tchip->hardware = WSS_HW_CS4231A;\n\t\t} else if (rev == 0xa2) {\n\t\t\tchip->hardware = WSS_HW_CS4232;\n\t\t} else if (rev == 0xb2) {\n\t\t\tchip->hardware = WSS_HW_CS4232A;\n\t\t} else if (rev == 0x83) {\n\t\t\tchip->hardware = WSS_HW_CS4236;\n\t\t} else if (rev == 0x03) {\n\t\t\tchip->hardware = WSS_HW_CS4236B;\n\t\t} else {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"unknown CS chip with version 0x%x\\n\", rev);\n\t\t\treturn -ENODEV;\t\t \n\t\t}\n\t}\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\twss_inb(chip, CS4231P(STATUS));\t \n\twss_outb(chip, CS4231P(STATUS), 0);\n\tmb();\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tif (!(chip->hardware & WSS_HW_AD1848_MASK))\n\t\tchip->image[CS4231_MISC_INFO] = CS4231_MODE2;\n\tswitch (chip->hardware) {\n\tcase WSS_HW_INTERWAVE:\n\t\tchip->image[CS4231_MISC_INFO] = CS4231_IW_MODE3;\n\t\tbreak;\n\tcase WSS_HW_CS4235:\n\tcase WSS_HW_CS4236B:\n\tcase WSS_HW_CS4237B:\n\tcase WSS_HW_CS4238B:\n\tcase WSS_HW_CS4239:\n\t\tif (hw == WSS_HW_DETECT3)\n\t\t\tchip->image[CS4231_MISC_INFO] = CS4231_4236_MODE3;\n\t\telse\n\t\t\tchip->hardware = WSS_HW_CS4236;\n\t\tbreak;\n\t}\n\n\tchip->image[CS4231_IFACE_CTRL] =\n\t    (chip->image[CS4231_IFACE_CTRL] & ~CS4231_SINGLE_DMA) |\n\t    (chip->single_dma ? CS4231_SINGLE_DMA : 0);\n\tif (chip->hardware != WSS_HW_OPTI93X) {\n\t\tchip->image[CS4231_ALT_FEATURE_1] = 0x80;\n\t\tchip->image[CS4231_ALT_FEATURE_2] =\n\t\t\tchip->hardware == WSS_HW_INTERWAVE ? 0xc2 : 0x01;\n\t}\n\t \n\tif (chip->hardware == WSS_HW_AD1845)\n\t\tchip->image[AD1845_PWR_DOWN] = 8;\n\n\tptr = (unsigned char *) &chip->image;\n\tregnum = (chip->hardware & WSS_HW_AD1848_MASK) ? 16 : 32;\n\tsnd_wss_mce_down(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tfor (i = 0; i < regnum; i++)\t \n\t\tsnd_wss_out(chip, i, *ptr++);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_up(chip);\n\tsnd_wss_mce_down(chip);\n\n\tmdelay(2);\n\n\t \n\tif ((hw & WSS_HW_TYPE_MASK) == WSS_HW_DETECT) {\n\t\tif (chip->hardware == WSS_HW_CS4236B) {\n\t\t\trev = snd_cs4236_ext_in(chip, CS4236_VERSION);\n\t\t\tsnd_cs4236_ext_out(chip, CS4236_VERSION, 0xff);\n\t\t\tid = snd_cs4236_ext_in(chip, CS4236_VERSION);\n\t\t\tsnd_cs4236_ext_out(chip, CS4236_VERSION, rev);\n\t\t\tsnd_printdd(\"CS4231: ext version; rev = 0x%x, id = 0x%x\\n\", rev, id);\n\t\t\tif ((id & 0x1f) == 0x1d) {\t \n\t\t\t\tchip->hardware = WSS_HW_CS4235;\n\t\t\t\tswitch (id >> 5) {\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t\t\"unknown CS4235 chip \"\n\t\t\t\t\t\t\"(enhanced version = 0x%x)\\n\",\n\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t} else if ((id & 0x1f) == 0x0b) {\t \n\t\t\t\tswitch (id >> 5) {\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\tcase 7:\n\t\t\t\t\tchip->hardware = WSS_HW_CS4236B;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t\t\"unknown CS4236 chip \"\n\t\t\t\t\t\t\"(enhanced version = 0x%x)\\n\",\n\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t} else if ((id & 0x1f) == 0x08) {\t \n\t\t\t\tchip->hardware = WSS_HW_CS4237B;\n\t\t\t\tswitch (id >> 5) {\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\tcase 7:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t\t\"unknown CS4237B chip \"\n\t\t\t\t\t\t\"(enhanced version = 0x%x)\\n\",\n\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t} else if ((id & 0x1f) == 0x09) {\t \n\t\t\t\tchip->hardware = WSS_HW_CS4238B;\n\t\t\t\tswitch (id >> 5) {\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\tcase 7:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t\t\"unknown CS4238B chip \"\n\t\t\t\t\t\t\"(enhanced version = 0x%x)\\n\",\n\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t} else if ((id & 0x1f) == 0x1e) {\t \n\t\t\t\tchip->hardware = WSS_HW_CS4239;\n\t\t\t\tswitch (id >> 5) {\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\tcase 6:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t\t\"unknown CS4239 chip \"\n\t\t\t\t\t\t\"(enhanced version = 0x%x)\\n\",\n\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t   \"unknown CS4236/CS423xB chip \"\n\t\t\t\t\t   \"(enhanced version = 0x%x)\\n\", id);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\t\t \n}\n\n \n\nstatic const struct snd_pcm_hardware snd_wss_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5510,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_wss_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5510,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic int snd_wss_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->hw = snd_wss_playback;\n\n\t \n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\truntime->hw.formats &= ~(SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t\t SNDRV_PCM_FMTBIT_S16_BE);\n\n\t \n\tif (chip->hardware == WSS_HW_INTERWAVE && chip->dma1 > 3)\n\t\truntime->hw.formats &= ~SNDRV_PCM_FMTBIT_MU_LAW;\n\n\t \n\tif (chip->hardware == WSS_HW_CS4235 ||\n\t    chip->hardware == WSS_HW_CS4239)\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE;\n\n\tsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);\n\n\tif (chip->claim_dma) {\n\t\terr = chip->claim_dma(chip, chip->dma_private_data, chip->dma1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_wss_open(chip, WSS_MODE_PLAY);\n\tif (err < 0) {\n\t\tif (chip->release_dma)\n\t\t\tchip->release_dma(chip, chip->dma_private_data, chip->dma1);\n\t\treturn err;\n\t}\n\tchip->playback_substream = substream;\n\tsnd_pcm_set_sync(substream);\n\tchip->rate_constraint(runtime);\n\treturn 0;\n}\n\nstatic int snd_wss_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->hw = snd_wss_capture;\n\n\t \n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\truntime->hw.formats &= ~(SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t\t SNDRV_PCM_FMTBIT_S16_BE);\n\n\t \n\tif (chip->hardware == WSS_HW_CS4235 ||\n\t    chip->hardware == WSS_HW_CS4239 ||\n\t    chip->hardware == WSS_HW_OPTI93X)\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t      SNDRV_PCM_FMTBIT_S16_LE;\n\n\tsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);\n\n\tif (chip->claim_dma) {\n\t\terr = chip->claim_dma(chip, chip->dma_private_data, chip->dma2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_wss_open(chip, WSS_MODE_RECORD);\n\tif (err < 0) {\n\t\tif (chip->release_dma)\n\t\t\tchip->release_dma(chip, chip->dma_private_data, chip->dma2);\n\t\treturn err;\n\t}\n\tchip->capture_substream = substream;\n\tsnd_pcm_set_sync(substream);\n\tchip->rate_constraint(runtime);\n\treturn 0;\n}\n\nstatic int snd_wss_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\tsnd_wss_close(chip, WSS_MODE_PLAY);\n\treturn 0;\n}\n\nstatic int snd_wss_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_wss *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\tsnd_wss_close(chip, WSS_MODE_RECORD);\n\treturn 0;\n}\n\nstatic void snd_wss_thinkpad_twiddle(struct snd_wss *chip, int on)\n{\n\tint tmp;\n\n\tif (!chip->thinkpad_flag)\n\t\treturn;\n\n\toutb(0x1c, AD1848_THINKPAD_CTL_PORT1);\n\ttmp = inb(AD1848_THINKPAD_CTL_PORT2);\n\n\tif (on)\n\t\t \n\t\ttmp |= AD1848_THINKPAD_CS4248_ENABLE_BIT;\n\telse\n\t\t \n\t\ttmp &= ~AD1848_THINKPAD_CS4248_ENABLE_BIT;\n\n\toutb(tmp, AD1848_THINKPAD_CTL_PORT2);\n}\n\n#ifdef CONFIG_PM\n\n \nstatic void snd_wss_suspend(struct snd_wss *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tfor (reg = 0; reg < 32; reg++)\n\t\tchip->image[reg] = snd_wss_in(chip, reg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (chip->thinkpad_flag)\n\t\tsnd_wss_thinkpad_twiddle(chip, 0);\n}\n\n \nstatic void snd_wss_resume(struct snd_wss *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\t \n\n\tif (chip->thinkpad_flag)\n\t\tsnd_wss_thinkpad_twiddle(chip, 1);\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tfor (reg = 0; reg < 32; reg++) {\n\t\tswitch (reg) {\n\t\tcase CS4231_VERSION:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_wss_out(chip, reg, chip->image[reg]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (chip->hardware == WSS_HW_OPL3SA2)\n\t\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t\t    chip->image[CS4231_PLAYBK_FORMAT]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n#if 1\n\tsnd_wss_mce_down(chip);\n#else\n\t \n\tsnd_wss_busy_wait(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->mce_bit &= ~CS4231_MCE;\n\ttimeout = wss_inb(chip, CS4231P(REGSEL));\n\twss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (timeout == 0x80)\n\t\tsnd_printk(KERN_ERR \"down [0x%lx]: serious init problem \"\n\t\t\t   \"- codec still busy\\n\", chip->port);\n\tif ((timeout & CS4231_MCE) == 0 ||\n\t    !(chip->hardware & (WSS_HW_CS4231_MASK | WSS_HW_CS4232_MASK))) {\n\t\treturn;\n\t}\n\tsnd_wss_busy_wait(chip);\n#endif\n}\n#endif  \n\nconst char *snd_wss_chip_id(struct snd_wss *chip)\n{\n\tswitch (chip->hardware) {\n\tcase WSS_HW_CS4231:\n\t\treturn \"CS4231\";\n\tcase WSS_HW_CS4231A:\n\t\treturn \"CS4231A\";\n\tcase WSS_HW_CS4232:\n\t\treturn \"CS4232\";\n\tcase WSS_HW_CS4232A:\n\t\treturn \"CS4232A\";\n\tcase WSS_HW_CS4235:\n\t\treturn \"CS4235\";\n\tcase WSS_HW_CS4236:\n\t\treturn \"CS4236\";\n\tcase WSS_HW_CS4236B:\n\t\treturn \"CS4236B\";\n\tcase WSS_HW_CS4237B:\n\t\treturn \"CS4237B\";\n\tcase WSS_HW_CS4238B:\n\t\treturn \"CS4238B\";\n\tcase WSS_HW_CS4239:\n\t\treturn \"CS4239\";\n\tcase WSS_HW_INTERWAVE:\n\t\treturn \"AMD InterWave\";\n\tcase WSS_HW_OPL3SA2:\n\t\treturn chip->card->shortname;\n\tcase WSS_HW_AD1845:\n\t\treturn \"AD1845\";\n\tcase WSS_HW_OPTI93X:\n\t\treturn \"OPTi 93x\";\n\tcase WSS_HW_AD1847:\n\t\treturn \"AD1847\";\n\tcase WSS_HW_AD1848:\n\t\treturn \"AD1848\";\n\tcase WSS_HW_CS4248:\n\t\treturn \"CS4248\";\n\tcase WSS_HW_CMI8330:\n\t\treturn \"CMI8330/C3D\";\n\tdefault:\n\t\treturn \"???\";\n\t}\n}\nEXPORT_SYMBOL(snd_wss_chip_id);\n\nstatic int snd_wss_new(struct snd_card *card,\n\t\t\t  unsigned short hardware,\n\t\t\t  unsigned short hwshare,\n\t\t\t  struct snd_wss **rchip)\n{\n\tstruct snd_wss *chip;\n\n\t*rchip = NULL;\n\tchip = devm_kzalloc(card->dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tchip->hardware = hardware;\n\tchip->hwshare = hwshare;\n\n\tspin_lock_init(&chip->reg_lock);\n\tmutex_init(&chip->mce_mutex);\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->rate_constraint = snd_wss_xrate;\n\tchip->set_playback_format = snd_wss_playback_format;\n\tchip->set_capture_format = snd_wss_capture_format;\n\tif (chip->hardware == WSS_HW_OPTI93X)\n\t\tmemcpy(&chip->image, &snd_opti93x_original_image,\n\t\t       sizeof(snd_opti93x_original_image));\n\telse\n\t\tmemcpy(&chip->image, &snd_wss_original_image,\n\t\t       sizeof(snd_wss_original_image));\n\tif (chip->hardware & WSS_HW_AD1848_MASK) {\n\t\tchip->image[CS4231_PIN_CTRL] = 0;\n\t\tchip->image[CS4231_TEST_INIT] = 0;\n\t}\n\n\t*rchip = chip;\n\treturn 0;\n}\n\nint snd_wss_create(struct snd_card *card,\n\t\t      unsigned long port,\n\t\t      unsigned long cport,\n\t\t      int irq, int dma1, int dma2,\n\t\t      unsigned short hardware,\n\t\t      unsigned short hwshare,\n\t\t      struct snd_wss **rchip)\n{\n\tstruct snd_wss *chip;\n\tint err;\n\n\terr = snd_wss_new(card, hardware, hwshare, &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->irq = -1;\n\tchip->dma1 = -1;\n\tchip->dma2 = -1;\n\n\tchip->res_port = devm_request_region(card->dev, port, 4, \"WSS\");\n\tif (!chip->res_port) {\n\t\tsnd_printk(KERN_ERR \"wss: can't grab port 0x%lx\\n\", port);\n\t\treturn -EBUSY;\n\t}\n\tchip->port = port;\n\tif ((long)cport >= 0) {\n\t\tchip->res_cport = devm_request_region(card->dev, cport, 8,\n\t\t\t\t\t\t      \"CS4232 Control\");\n\t\tif (!chip->res_cport) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t\"wss: can't grab control port 0x%lx\\n\", cport);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tchip->cport = cport;\n\tif (!(hwshare & WSS_HWSHARE_IRQ))\n\t\tif (devm_request_irq(card->dev, irq, snd_wss_interrupt, 0,\n\t\t\t\t     \"WSS\", (void *) chip)) {\n\t\t\tsnd_printk(KERN_ERR \"wss: can't grab IRQ %d\\n\", irq);\n\t\t\treturn -EBUSY;\n\t\t}\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\tif (!(hwshare & WSS_HWSHARE_DMA1) &&\n\t    snd_devm_request_dma(card->dev, dma1, \"WSS - 1\")) {\n\t\tsnd_printk(KERN_ERR \"wss: can't grab DMA1 %d\\n\", dma1);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma1 = dma1;\n\tif (!(hwshare & WSS_HWSHARE_DMA2) && dma1 != dma2 && dma2 >= 0 &&\n\t    snd_devm_request_dma(card->dev, dma2, \"WSS - 2\")) {\n\t\tsnd_printk(KERN_ERR \"wss: can't grab DMA2 %d\\n\", dma2);\n\t\treturn -EBUSY;\n\t}\n\tif (dma1 == dma2 || dma2 < 0) {\n\t\tchip->single_dma = 1;\n\t\tchip->dma2 = chip->dma1;\n\t} else\n\t\tchip->dma2 = dma2;\n\n\tif (hardware == WSS_HW_THINKPAD) {\n\t\tchip->thinkpad_flag = 1;\n\t\tchip->hardware = WSS_HW_DETECT;  \n\t\tsnd_wss_thinkpad_twiddle(chip, 1);\n\t}\n\n\t \n\tif (snd_wss_probe(chip) < 0)\n\t\treturn -ENODEV;\n\tsnd_wss_init(chip);\n\n#if 0\n\tif (chip->hardware & WSS_HW_CS4232_MASK) {\n\t\tif (chip->res_cport == NULL)\n\t\t\tsnd_printk(KERN_ERR \"CS4232 control port features are \"\n\t\t\t\t   \"not accessible\\n\");\n\t}\n#endif\n\n#ifdef CONFIG_PM\n\t \n\tchip->suspend = snd_wss_suspend;\n\tchip->resume = snd_wss_resume;\n#endif\n\n\t*rchip = chip;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_create);\n\nstatic const struct snd_pcm_ops snd_wss_playback_ops = {\n\t.open =\t\tsnd_wss_playback_open,\n\t.close =\tsnd_wss_playback_close,\n\t.hw_params =\tsnd_wss_playback_hw_params,\n\t.prepare =\tsnd_wss_playback_prepare,\n\t.trigger =\tsnd_wss_trigger,\n\t.pointer =\tsnd_wss_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_wss_capture_ops = {\n\t.open =\t\tsnd_wss_capture_open,\n\t.close =\tsnd_wss_capture_close,\n\t.hw_params =\tsnd_wss_capture_hw_params,\n\t.prepare =\tsnd_wss_capture_prepare,\n\t.trigger =\tsnd_wss_trigger,\n\t.pointer =\tsnd_wss_capture_pointer,\n};\n\nint snd_wss_pcm(struct snd_wss *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"WSS\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_wss_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_wss_capture_ops);\n\n\t \n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tif (chip->single_dma)\n\t\tpcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\n\tif (chip->hardware != WSS_HW_INTERWAVE)\n\t\tpcm->info_flags |= SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tstrcpy(pcm->name, snd_wss_chip_id(chip));\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, chip->card->dev,\n\t\t\t\t       64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\n\n\tchip->pcm = pcm;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_pcm);\n\nstatic void snd_wss_timer_free(struct snd_timer *timer)\n{\n\tstruct snd_wss *chip = timer->private_data;\n\tchip->timer = NULL;\n}\n\nint snd_wss_timer(struct snd_wss *chip, int device)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\t \n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = chip->card->number;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\terr = snd_timer_new(chip->card, \"CS4231\", &tid, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, snd_wss_chip_id(chip));\n\ttimer->private_data = chip;\n\ttimer->private_free = snd_wss_timer_free;\n\ttimer->hw = snd_wss_timer_table;\n\tchip->timer = timer;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_timer);\n\n \n\nstatic int snd_wss_info_mux(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"Line\", \"Aux\", \"Mic\", \"Mix\"\n\t};\n\tstatic const char * const opl3sa_texts[4] = {\n\t\t\"Line\", \"CD\", \"Mic\", \"Mix\"\n\t};\n\tstatic const char * const gusmax_texts[4] = {\n\t\t\"Line\", \"Synth\", \"Mic\", \"Mix\"\n\t};\n\tconst char * const *ptexts = texts;\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\n\tif (snd_BUG_ON(!chip->card))\n\t\treturn -EINVAL;\n\tif (!strcmp(chip->card->driver, \"GUS MAX\"))\n\t\tptexts = gusmax_texts;\n\tswitch (chip->hardware) {\n\tcase WSS_HW_INTERWAVE:\n\t\tptexts = gusmax_texts;\n\t\tbreak;\n\tcase WSS_HW_OPTI93X:\n\tcase WSS_HW_OPL3SA2:\n\t\tptexts = opl3sa_texts;\n\t\tbreak;\n\t}\n\treturn snd_ctl_enum_info(uinfo, 2, 4, ptexts);\n}\n\nstatic int snd_wss_get_mux(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.enumerated.item[0] = (chip->image[CS4231_LEFT_INPUT] & CS4231_MIXS_ALL) >> 6;\n\tucontrol->value.enumerated.item[1] = (chip->image[CS4231_RIGHT_INPUT] & CS4231_MIXS_ALL) >> 6;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_wss_put_mux(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned short left, right;\n\tint change;\n\n\tif (ucontrol->value.enumerated.item[0] > 3 ||\n\t    ucontrol->value.enumerated.item[1] > 3)\n\t\treturn -EINVAL;\n\tleft = ucontrol->value.enumerated.item[0] << 6;\n\tright = ucontrol->value.enumerated.item[1] << 6;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tleft = (chip->image[CS4231_LEFT_INPUT] & ~CS4231_MIXS_ALL) | left;\n\tright = (chip->image[CS4231_RIGHT_INPUT] & ~CS4231_MIXS_ALL) | right;\n\tchange = left != chip->image[CS4231_LEFT_INPUT] ||\n\t\t right != chip->image[CS4231_RIGHT_INPUT];\n\tsnd_wss_out(chip, CS4231_LEFT_INPUT, left);\n\tsnd_wss_out(chip, CS4231_RIGHT_INPUT, right);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nint snd_wss_info_single(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_info_single);\n\nint snd_wss_get_single(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_get_single);\n\nint snd_wss_put_single(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = (chip->image[reg] & ~(mask << shift)) | val;\n\tchange = val != chip->image[reg];\n\tsnd_wss_out(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\nEXPORT_SYMBOL(snd_wss_put_single);\n\nint snd_wss_info_double(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_info_double);\n\nint snd_wss_get_double(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (chip->image[right_reg] >> shift_right) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_get_double);\n\nint snd_wss_put_double(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2;\n\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (left_reg != right_reg) {\n\t\tval1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;\n\t\tval2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;\n\t\tchange = val1 != chip->image[left_reg] ||\n\t\t\t val2 != chip->image[right_reg];\n\t\tsnd_wss_out(chip, left_reg, val1);\n\t\tsnd_wss_out(chip, right_reg, val2);\n\t} else {\n\t\tmask = (mask << shift_left) | (mask << shift_right);\n\t\tval1 = (chip->image[left_reg] & ~mask) | val1 | val2;\n\t\tchange = val1 != chip->image[left_reg];\n\t\tsnd_wss_out(chip, left_reg, val1);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\nEXPORT_SYMBOL(snd_wss_put_double);\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);\n\nstatic const struct snd_kcontrol_new snd_wss_controls[] = {\nWSS_DOUBLE(\"PCM Playback Switch\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"PCM Playback Volume\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 63, 1,\n\t\tdb_scale_6bit),\nWSS_DOUBLE(\"Aux Playback Switch\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Aux Playback Volume\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_DOUBLE(\"Aux Playback Switch\", 1,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Aux Playback Volume\", 1,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_DOUBLE_TLV(\"Capture Volume\", 0, CS4231_LEFT_INPUT, CS4231_RIGHT_INPUT,\n\t\t0, 0, 15, 0, db_scale_rec_gain),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_wss_info_mux,\n\t.get = snd_wss_get_mux,\n\t.put = snd_wss_put_mux,\n},\nWSS_DOUBLE(\"Mic Boost (+20dB)\", 0,\n\t\tCS4231_LEFT_INPUT, CS4231_RIGHT_INPUT, 5, 5, 1, 0),\nWSS_SINGLE(\"Loopback Capture Switch\", 0,\n\t\tCS4231_LOOPBACK, 0, 1, 0),\nWSS_SINGLE_TLV(\"Loopback Capture Volume\", 0, CS4231_LOOPBACK, 2, 63, 1,\n\t\tdb_scale_6bit),\nWSS_DOUBLE(\"Line Playback Switch\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Line Playback Volume\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_SINGLE(\"Beep Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, 7, 1, 1),\nWSS_SINGLE_TLV(\"Beep Playback Volume\", 0,\n\t\tCS4231_MONO_CTRL, 0, 15, 1,\n\t\tdb_scale_4bit),\nWSS_SINGLE(\"Mono Output Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, 6, 1, 1),\nWSS_SINGLE(\"Beep Bypass Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, 5, 1, 0),\n};\n\nint snd_wss_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card;\n\tunsigned int idx;\n\tint err;\n\tint count = ARRAY_SIZE(snd_wss_controls);\n\n\tif (snd_BUG_ON(!chip || !chip->pcm))\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, chip->pcm->name);\n\n\t \n\tif (chip->hardware & WSS_HW_AD1848_MASK)\n\t\tcount = 11;\n\t \n\telse if (chip->hardware == WSS_HW_OPTI93X)\n\t\tcount = 9;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_wss_controls[idx],\n\t\t\t\t\t     chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_wss_mixer);\n\nconst struct snd_pcm_ops *snd_wss_get_pcm_ops(int direction)\n{\n\treturn direction == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t&snd_wss_playback_ops : &snd_wss_capture_ops;\n}\nEXPORT_SYMBOL(snd_wss_get_pcm_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}