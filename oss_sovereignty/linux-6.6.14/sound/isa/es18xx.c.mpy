{
  "module_name": "es18xx.c",
  "hash_id": "a637615594ecdafcc4433edebf655c4ff54b5143f74f5a47640ad0cef49b17e7",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/es18xx.c",
  "human_readable_source": "\n \n \n\n \n\n \n\n \n \n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/isapnp.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\n#define PFX \"es18xx: \"\n\nstruct snd_es18xx {\n\tunsigned long port;\t\t \n\tunsigned long ctrl_port;\t \n\tint irq;\t\t\t \n\tint dma1;\t\t\t \n\tint dma2;\t\t\t \n\tunsigned short version;\t\t \n\tint caps;\t\t\t \n\tunsigned short audio2_vol;\t \n\n\tunsigned short active;\t\t \n\tunsigned int dma1_shift;\n\tunsigned int dma2_shift;\n\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *playback_a_substream;\n\tstruct snd_pcm_substream *capture_a_substream;\n\tstruct snd_pcm_substream *playback_b_substream;\n\n\tstruct snd_rawmidi *rmidi;\n\n\tstruct snd_kcontrol *hw_volume;\n\tstruct snd_kcontrol *hw_switch;\n\tstruct snd_kcontrol *master_volume;\n\tstruct snd_kcontrol *master_switch;\n\n\tspinlock_t reg_lock;\n\tspinlock_t mixer_lock;\n#ifdef CONFIG_PM\n\tunsigned char pm_reg;\n#endif\n#ifdef CONFIG_PNP\n\tstruct pnp_dev *dev;\n\tstruct pnp_dev *devc;\n#endif\n};\n\n#define AUDIO1_IRQ\t0x01\n#define AUDIO2_IRQ\t0x02\n#define HWV_IRQ\t\t0x04\n#define MPU_IRQ\t\t0x08\n\n#define ES18XX_PCM2\t0x0001\t \n#define ES18XX_SPATIALIZER 0x0002\t \n#define ES18XX_RECMIX\t0x0004\t \n#define ES18XX_DUPLEX_MONO 0x0008\t \n#define ES18XX_DUPLEX_SAME 0x0010\t \n#define ES18XX_NEW_RATE\t0x0020\t \n#define ES18XX_AUXB\t0x0040\t \n#define ES18XX_HWV\t0x0080\t \n#define ES18XX_MONO\t0x0100\t \n#define ES18XX_I2S\t0x0200\t \n#define ES18XX_MUTEREC\t0x0400\t \n#define ES18XX_CONTROL\t0x0800\t \n#define ES18XX_GPO_2BIT\t0x1000\t \n\n \n#define ES18XX_PM\t0x07\n#define ES18XX_PM_GPO0\t0x01\n#define ES18XX_PM_GPO1\t0x02\n#define ES18XX_PM_PDR\t0x04\n#define ES18XX_PM_ANA\t0x08\n#define ES18XX_PM_FM\t0x020\n#define ES18XX_PM_SUS\t0x080\n\n \n\n#define DAC1 0x01\n#define ADC1 0x02\n#define DAC2 0x04\n#define MILLISECOND 10000\n\nstatic int snd_es18xx_dsp_command(struct snd_es18xx *chip, unsigned char val)\n{\n        int i;\n\n        for(i = MILLISECOND; i; i--)\n                if ((inb(chip->port + 0x0C) & 0x80) == 0) {\n                        outb(val, chip->port + 0x0C);\n                        return 0;\n                }\n\tsnd_printk(KERN_ERR \"dsp_command: timeout (0x%x)\\n\", val);\n        return -EINVAL;\n}\n\nstatic int snd_es18xx_dsp_get_byte(struct snd_es18xx *chip)\n{\n        int i;\n\n        for(i = MILLISECOND/10; i; i--)\n                if (inb(chip->port + 0x0C) & 0x40)\n                        return inb(chip->port + 0x0A);\n\tsnd_printk(KERN_ERR \"dsp_get_byte failed: 0x%lx = 0x%x!!!\\n\",\n\t\t   chip->port + 0x0A, inb(chip->port + 0x0A));\n        return -ENODEV;\n}\n\n#undef REG_DEBUG\n\nstatic int snd_es18xx_write(struct snd_es18xx *chip,\n\t\t\t    unsigned char reg, unsigned char data)\n{\n\tunsigned long flags;\n\tint ret;\n\t\n        spin_lock_irqsave(&chip->reg_lock, flags);\n\tret = snd_es18xx_dsp_command(chip, reg);\n\tif (ret < 0)\n\t\tgoto end;\n        ret = snd_es18xx_dsp_command(chip, data);\n end:\n        spin_unlock_irqrestore(&chip->reg_lock, flags);\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Reg %02x set to %02x\\n\", reg, data);\n#endif\n\treturn ret;\n}\n\nstatic int snd_es18xx_read(struct snd_es18xx *chip, unsigned char reg)\n{\n\tunsigned long flags;\n\tint ret, data;\n        spin_lock_irqsave(&chip->reg_lock, flags);\n\tret = snd_es18xx_dsp_command(chip, 0xC0);\n\tif (ret < 0)\n\t\tgoto end;\n        ret = snd_es18xx_dsp_command(chip, reg);\n\tif (ret < 0)\n\t\tgoto end;\n\tdata = snd_es18xx_dsp_get_byte(chip);\n\tret = data;\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Reg %02x now is %02x (%d)\\n\", reg, data, ret);\n#endif\n end:\n        spin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn ret;\n}\n\n \nstatic int snd_es18xx_bits(struct snd_es18xx *chip, unsigned char reg,\n\t\t\t   unsigned char mask, unsigned char val)\n{\n        int ret;\n\tunsigned char old, new, oval;\n\tunsigned long flags;\n        spin_lock_irqsave(&chip->reg_lock, flags);\n        ret = snd_es18xx_dsp_command(chip, 0xC0);\n\tif (ret < 0)\n\t\tgoto end;\n        ret = snd_es18xx_dsp_command(chip, reg);\n\tif (ret < 0)\n\t\tgoto end;\n\tret = snd_es18xx_dsp_get_byte(chip);\n\tif (ret < 0) {\n\t\tgoto end;\n\t}\n\told = ret;\n\toval = old & mask;\n\tif (val != oval) {\n\t\tret = snd_es18xx_dsp_command(chip, reg);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tnew = (old & ~mask) | (val & mask);\n\t\tret = snd_es18xx_dsp_command(chip, new);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n#ifdef REG_DEBUG\n\t\tsnd_printk(KERN_DEBUG \"Reg %02x was %02x, set to %02x (%d)\\n\",\n\t\t\t   reg, old, new, ret);\n#endif\n\t}\n\tret = oval;\n end:\n        spin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn ret;\n}\n\nstatic inline void snd_es18xx_mixer_write(struct snd_es18xx *chip,\n\t\t\t    unsigned char reg, unsigned char data)\n{\n\tunsigned long flags;\n        spin_lock_irqsave(&chip->mixer_lock, flags);\n        outb(reg, chip->port + 0x04);\n        outb(data, chip->port + 0x05);\n        spin_unlock_irqrestore(&chip->mixer_lock, flags);\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Mixer reg %02x set to %02x\\n\", reg, data);\n#endif\n}\n\nstatic inline int snd_es18xx_mixer_read(struct snd_es18xx *chip, unsigned char reg)\n{\n\tunsigned long flags;\n\tint data;\n        spin_lock_irqsave(&chip->mixer_lock, flags);\n        outb(reg, chip->port + 0x04);\n\tdata = inb(chip->port + 0x05);\n        spin_unlock_irqrestore(&chip->mixer_lock, flags);\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Mixer reg %02x now is %02x\\n\", reg, data);\n#endif\n        return data;\n}\n\n \nstatic inline int snd_es18xx_mixer_bits(struct snd_es18xx *chip, unsigned char reg,\n\t\t\t\t\tunsigned char mask, unsigned char val)\n{\n\tunsigned char old, new, oval;\n\tunsigned long flags;\n        spin_lock_irqsave(&chip->mixer_lock, flags);\n        outb(reg, chip->port + 0x04);\n\told = inb(chip->port + 0x05);\n\toval = old & mask;\n\tif (val != oval) {\n\t\tnew = (old & ~mask) | (val & mask);\n\t\toutb(new, chip->port + 0x05);\n#ifdef REG_DEBUG\n\t\tsnd_printk(KERN_DEBUG \"Mixer reg %02x was %02x, set to %02x\\n\",\n\t\t\t   reg, old, new);\n#endif\n\t}\n        spin_unlock_irqrestore(&chip->mixer_lock, flags);\n\treturn oval;\n}\n\nstatic inline int snd_es18xx_mixer_writable(struct snd_es18xx *chip, unsigned char reg,\n\t\t\t\t\t    unsigned char mask)\n{\n\tint old, expected, new;\n\tunsigned long flags;\n        spin_lock_irqsave(&chip->mixer_lock, flags);\n        outb(reg, chip->port + 0x04);\n\told = inb(chip->port + 0x05);\n\texpected = old ^ mask;\n\toutb(expected, chip->port + 0x05);\n\tnew = inb(chip->port + 0x05);\n        spin_unlock_irqrestore(&chip->mixer_lock, flags);\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Mixer reg %02x was %02x, set to %02x, now is %02x\\n\",\n\t\t   reg, old, expected, new);\n#endif\n\treturn expected == new;\n}\n\n\nstatic int snd_es18xx_reset(struct snd_es18xx *chip)\n{\n\tint i;\n        outb(0x03, chip->port + 0x06);\n        inb(chip->port + 0x06);\n        outb(0x00, chip->port + 0x06);\n        for(i = 0; i < MILLISECOND && !(inb(chip->port + 0x0E) & 0x80); i++);\n        if (inb(chip->port + 0x0A) != 0xAA)\n                return -1;\n\treturn 0;\n}\n\nstatic int snd_es18xx_reset_fifo(struct snd_es18xx *chip)\n{\n        outb(0x02, chip->port + 0x06);\n        inb(chip->port + 0x06);\n        outb(0x00, chip->port + 0x06);\n\treturn 0;\n}\n\nstatic const struct snd_ratnum new_clocks[2] = {\n\t{\n\t\t.num = 793800,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t},\n\t{\n\t\t.num = 768000,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t}\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums new_hw_constraints_clocks = {\n\t.nrats = 2,\n\t.rats = new_clocks,\n};\n\nstatic const struct snd_ratnum old_clocks[2] = {\n\t{\n\t\t.num = 795444,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t},\n\t{\n\t\t.num = 397722,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t}\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums old_hw_constraints_clocks  = {\n\t.nrats = 2,\n\t.rats = old_clocks,\n};\n\n\nstatic void snd_es18xx_rate_set(struct snd_es18xx *chip, \n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tint mode)\n{\n\tunsigned int bits, div0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (chip->caps & ES18XX_NEW_RATE) {\n\t\tif (runtime->rate_num == new_clocks[0].num)\n\t\t\tbits = 128 - runtime->rate_den;\n\t\telse\n\t\t\tbits = 256 - runtime->rate_den;\n\t} else {\n\t\tif (runtime->rate_num == old_clocks[0].num)\n\t\t\tbits = 256 - runtime->rate_den;\n\t\telse\n\t\t\tbits = 128 - runtime->rate_den;\n\t}\n\n\t \n\tdiv0 = 256 - 7160000*20/(8*82*runtime->rate);\n\t\t\n\tif ((chip->caps & ES18XX_PCM2) && mode == DAC2) {\n\t\tsnd_es18xx_mixer_write(chip, 0x70, bits);\n\t\t \n\t\tsnd_es18xx_write(chip, 0xA2, div0);\n\t\tsnd_es18xx_mixer_write(chip, 0x72, div0);\n\t} else {\n\t\tsnd_es18xx_write(chip, 0xA1, bits);\n\t\tsnd_es18xx_write(chip, 0xA2, div0);\n\t}\n}\n\nstatic int snd_es18xx_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tint shift;\n\n\tshift = 0;\n\tif (params_channels(hw_params) == 2)\n\t\tshift++;\n\tif (snd_pcm_format_width(params_format(hw_params)) == 16)\n\t\tshift++;\n\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\n\t\tif ((chip->caps & ES18XX_DUPLEX_MONO) &&\n\t\t    (chip->capture_a_substream) &&\n\t\t    params_channels(hw_params) != 1) {\n\t\t\t_snd_pcm_hw_param_setempty(hw_params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tchip->dma2_shift = shift;\n\t} else {\n\t\tchip->dma1_shift = shift;\n\t}\n\treturn 0;\n}\n\nstatic int snd_es18xx_playback1_prepare(struct snd_es18xx *chip,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n        snd_es18xx_rate_set(chip, substream, DAC2);\n\n         \n        count = 0x10000 - count;\n        snd_es18xx_mixer_write(chip, 0x74, count & 0xff);\n        snd_es18xx_mixer_write(chip, 0x76, count >> 8);\n\n\t \n        snd_es18xx_mixer_bits(chip, 0x7A, 0x07,\n\t\t\t      ((runtime->channels == 1) ? 0x00 : 0x02) |\n\t\t\t      (snd_pcm_format_width(runtime->format) == 16 ? 0x01 : 0x00) |\n\t\t\t      (snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x04));\n\n         \n        snd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_playback1_trigger(struct snd_es18xx *chip,\n\t\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (chip->active & DAC2)\n\t\t\treturn 0;\n\t\tchip->active |= DAC2;\n                 \n\t\tif (chip->dma2 >= 4)\n\t\t\tsnd_es18xx_mixer_write(chip, 0x78, 0xb3);\n\t\telse\n\t\t\tsnd_es18xx_mixer_write(chip, 0x78, 0x93);\n#ifdef AVOID_POPS\n\t\t \n\t\tmdelay(100);\n\t\tif (chip->caps & ES18XX_PCM2)\n\t\t\t \n\t\t\tsnd_es18xx_mixer_write(chip, 0x7C, chip->audio2_vol);\n\t\telse\n\t\t\t \n\t\t\tsnd_es18xx_dsp_command(chip, 0xD1);\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (!(chip->active & DAC2))\n\t\t\treturn 0;\n\t\tchip->active &= ~DAC2;\n                 \n                snd_es18xx_mixer_write(chip, 0x78, 0x00);\n#ifdef AVOID_POPS\n\t\tmdelay(25);\n\t\tif (chip->caps & ES18XX_PCM2)\n\t\t\t \n\t\t\tsnd_es18xx_mixer_write(chip, 0x7C, 0);\n\t\telse\n\t\t\t \n\t\t\tsnd_es18xx_dsp_command(chip, 0xD3);\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tint shift;\n\n\tshift = 0;\n\tif ((chip->caps & ES18XX_DUPLEX_MONO) &&\n\t    chip->playback_a_substream &&\n\t    params_channels(hw_params) != 1) {\n\t\t_snd_pcm_hw_param_setempty(hw_params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\t\treturn -EBUSY;\n\t}\n\tif (params_channels(hw_params) == 2)\n\t\tshift++;\n\tif (snd_pcm_format_width(params_format(hw_params)) == 16)\n\t\tshift++;\n\tchip->dma1_shift = shift;\n\treturn 0;\n}\n\nstatic int snd_es18xx_capture_prepare(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tsnd_es18xx_reset_fifo(chip);\n\n         \n        snd_es18xx_bits(chip, 0xA8, 0x03, runtime->channels == 1 ? 0x02 : 0x01);\n\n        snd_es18xx_rate_set(chip, substream, ADC1);\n\n         \n\tcount = 0x10000 - count;\n\tsnd_es18xx_write(chip, 0xA4, count & 0xff);\n\tsnd_es18xx_write(chip, 0xA5, count >> 8);\n\n#ifdef AVOID_POPS\n\tmdelay(100);\n#endif\n\n         \n        snd_es18xx_write(chip, 0xB7, \n                         snd_pcm_format_unsigned(runtime->format) ? 0x51 : 0x71);\n        snd_es18xx_write(chip, 0xB7, 0x90 |\n                         ((runtime->channels == 1) ? 0x40 : 0x08) |\n                         (snd_pcm_format_width(runtime->format) == 16 ? 0x04 : 0x00) |\n                         (snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x20));\n\n         \n        snd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (chip->active & ADC1)\n\t\t\treturn 0;\n\t\tchip->active |= ADC1;\n                 \n                snd_es18xx_write(chip, 0xB8, 0x0f);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (!(chip->active & ADC1))\n\t\t\treturn 0;\n\t\tchip->active &= ~ADC1;\n                 \n                snd_es18xx_write(chip, 0xB8, 0x00);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_playback2_prepare(struct snd_es18xx *chip,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tsnd_es18xx_reset_fifo(chip);\n\n         \n        snd_es18xx_bits(chip, 0xA8, 0x03, runtime->channels == 1 ? 0x02 : 0x01);\n\n        snd_es18xx_rate_set(chip, substream, DAC1);\n\n         \n\tcount = 0x10000 - count;\n\tsnd_es18xx_write(chip, 0xA4, count & 0xff);\n\tsnd_es18xx_write(chip, 0xA5, count >> 8);\n\n         \n        snd_es18xx_write(chip, 0xB6,\n                         snd_pcm_format_unsigned(runtime->format) ? 0x80 : 0x00);\n        snd_es18xx_write(chip, 0xB7, \n                         snd_pcm_format_unsigned(runtime->format) ? 0x51 : 0x71);\n        snd_es18xx_write(chip, 0xB7, 0x90 |\n                         (runtime->channels == 1 ? 0x40 : 0x08) |\n                         (snd_pcm_format_width(runtime->format) == 16 ? 0x04 : 0x00) |\n                         (snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x20));\n\n         \n        snd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_playback2_trigger(struct snd_es18xx *chip,\n\t\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (chip->active & DAC1)\n\t\t\treturn 0;\n\t\tchip->active |= DAC1;\n                 \n                snd_es18xx_write(chip, 0xB8, 0x05);\n#ifdef AVOID_POPS\n\t\t \n\t\tmdelay(100);\n                 \n                snd_es18xx_dsp_command(chip, 0xD1);\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (!(chip->active & DAC1))\n\t\t\treturn 0;\n\t\tchip->active &= ~DAC1;\n                 \n                snd_es18xx_write(chip, 0xB8, 0x00);\n#ifdef AVOID_POPS\n\t\t \n\t\tmdelay(25);\n                 \n                snd_es18xx_dsp_command(chip, 0xD3);\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_playback_prepare(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\n\t\treturn snd_es18xx_playback1_prepare(chip, substream);\n\telse\n\t\treturn snd_es18xx_playback2_prepare(chip, substream);\n}\n\nstatic int snd_es18xx_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\n\t\treturn snd_es18xx_playback1_trigger(chip, substream, cmd);\n\telse\n\t\treturn snd_es18xx_playback2_trigger(chip, substream, cmd);\n}\n\nstatic irqreturn_t snd_es18xx_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_card *card = dev_id;\n\tstruct snd_es18xx *chip = card->private_data;\n\tunsigned char status;\n\n\tif (chip->caps & ES18XX_CONTROL) {\n\t\t \n\t\tstatus = inb(chip->ctrl_port + 6);\n\t} else {\n\t\t \n\t\tstatus = snd_es18xx_mixer_read(chip, 0x7f) >> 4;\n\t}\n#if 0\n\telse {\n\t\tstatus = 0;\n\t\tif (inb(chip->port + 0x0C) & 0x01)\n\t\t\tstatus |= AUDIO1_IRQ;\n\t\tif (snd_es18xx_mixer_read(chip, 0x7A) & 0x80)\n\t\t\tstatus |= AUDIO2_IRQ;\n\t\tif ((chip->caps & ES18XX_HWV) &&\n\t\t    snd_es18xx_mixer_read(chip, 0x64) & 0x10)\n\t\t\tstatus |= HWV_IRQ;\n\t}\n#endif\n\n\t \n        if (status & AUDIO2_IRQ) {\n                if (chip->active & DAC2)\n                \tsnd_pcm_period_elapsed(chip->playback_a_substream);\n\t\t \n                snd_es18xx_mixer_bits(chip, 0x7A, 0x80, 0x00);\n        }\n        if (status & AUDIO1_IRQ) {\n                 \n                if (chip->active & ADC1)\n                \tsnd_pcm_period_elapsed(chip->capture_a_substream);\n                 \n                else if (chip->active & DAC1)\n                \tsnd_pcm_period_elapsed(chip->playback_b_substream);\n\t\t \n\t\tinb(chip->port + 0x0E);\n        }\n\n\t \n\tif ((status & MPU_IRQ) && chip->rmidi)\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\n\t \n\tif (status & HWV_IRQ) {\n\t\tint split = 0;\n\t\tif (chip->caps & ES18XX_HWV) {\n\t\t\tsplit = snd_es18xx_mixer_read(chip, 0x64) & 0x80;\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->hw_switch->id);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->hw_volume->id);\n\t\t}\n\t\tif (!split) {\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->master_switch->id);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->master_volume->id);\n\t\t}\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x66, 0x00);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic snd_pcm_uframes_t snd_es18xx_playback_pointer(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tint pos;\n\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\n\t\tif (!(chip->active & DAC2))\n\t\t\treturn 0;\n\t\tpos = snd_dma_pointer(chip->dma2, size);\n\t\treturn pos >> chip->dma2_shift;\n\t} else {\n\t\tif (!(chip->active & DAC1))\n\t\t\treturn 0;\n\t\tpos = snd_dma_pointer(chip->dma1, size);\n\t\treturn pos >> chip->dma1_shift;\n\t}\n}\n\nstatic snd_pcm_uframes_t snd_es18xx_capture_pointer(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tint pos;\n\n        if (!(chip->active & ADC1))\n                return 0;\n\tpos = snd_dma_pointer(chip->dma1, size);\n\treturn pos >> chip->dma1_shift;\n}\n\nstatic const struct snd_pcm_hardware snd_es18xx_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 | \n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_es18xx_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 | \n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_es18xx_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\n\t\tif ((chip->caps & ES18XX_DUPLEX_MONO) &&\n\t\t    chip->capture_a_substream && \n\t\t    chip->capture_a_substream->runtime->channels != 1)\n\t\t\treturn -EAGAIN;\n\t\tchip->playback_a_substream = substream;\n\t} else if (substream->number <= 1) {\n\t\tif (chip->capture_a_substream)\n\t\t\treturn -EAGAIN;\n\t\tchip->playback_b_substream = substream;\n\t} else {\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\tsubstream->runtime->hw = snd_es18xx_playback;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      (chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);\n        return 0;\n}\n\nstatic int snd_es18xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\n        if (chip->playback_b_substream)\n                return -EAGAIN;\n\tif ((chip->caps & ES18XX_DUPLEX_MONO) &&\n\t    chip->playback_a_substream &&\n\t    chip->playback_a_substream->runtime->channels != 1)\n\t\treturn -EAGAIN;\n        chip->capture_a_substream = substream;\n\tsubstream->runtime->hw = snd_es18xx_capture;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      (chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);\n        return 0;\n}\n\nstatic int snd_es18xx_playback_close(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\n\tif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\n\t\tchip->playback_a_substream = NULL;\n\telse\n\t\tchip->playback_b_substream = NULL;\n\t\n\treturn 0;\n}\n\nstatic int snd_es18xx_capture_close(struct snd_pcm_substream *substream)\n{\n        struct snd_es18xx *chip = snd_pcm_substream_chip(substream);\n\n        chip->capture_a_substream = NULL;\n        return 0;\n}\n\n \n\n \n\nstatic int snd_es18xx_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts5Source[5] = {\n\t\t\"Mic\", \"CD\", \"Line\", \"Master\", \"Mix\"\n\t};\n\tstatic const char * const texts8Source[8] = {\n\t\t\"Mic\", \"Mic Master\", \"CD\", \"AOUT\",\n\t\t\"Mic1\", \"Mix\", \"Line\", \"Master\"\n\t};\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\n\tswitch (chip->version) {\n\tcase 0x1868:\n\tcase 0x1878:\n\t\treturn snd_ctl_enum_info(uinfo, 1, 4, texts5Source);\n\tcase 0x1887:\n\tcase 0x1888:\n\t\treturn snd_ctl_enum_info(uinfo, 1, 5, texts5Source);\n\tcase 0x1869:  \n\tcase 0x1879:\n\t\treturn snd_ctl_enum_info(uinfo, 1, 8, texts8Source);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int snd_es18xx_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstatic const unsigned char invMap4Source[8] = {0, 0, 1, 1, 0, 0, 2, 3};\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tint muxSource = snd_es18xx_mixer_read(chip, 0x1c) & 0x07;\n\tif (!(chip->version == 0x1869 || chip->version == 0x1879)) {\n\t\tmuxSource = invMap4Source[muxSource];\n\t\tif (muxSource==3 && \n\t\t    (chip->version == 0x1887 || chip->version == 0x1888) &&\n\t\t    (snd_es18xx_mixer_read(chip, 0x7a) & 0x08)\n\t\t) \n\t\t\tmuxSource = 4;\n\t}\n\tucontrol->value.enumerated.item[0] = muxSource;\n\treturn 0;\n}\n\nstatic int snd_es18xx_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstatic const unsigned char map4Source[4] = {0, 2, 6, 7};\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char val = ucontrol->value.enumerated.item[0];\n\tunsigned char retVal = 0;\n\n\tswitch (chip->version) {\n  \n\tcase 0x1887:\n\tcase 0x1888:\n\t\tif (val > 4)\n\t\t\treturn -EINVAL;\n\t\tif (val == 4) {\n\t\t\tretVal = snd_es18xx_mixer_bits(chip, 0x7a, 0x08, 0x08) != 0x08;\n\t\t\tval = 3;\n\t\t} else\n\t\t\tretVal = snd_es18xx_mixer_bits(chip, 0x7a, 0x08, 0x00) != 0x00;\n\t\tfallthrough;\n  \n\tcase 0x1868:\n\tcase 0x1878:\n\t\tif (val > 3)\n\t\t\treturn -EINVAL;\n\t\tval = map4Source[val];\n\t\tbreak;\n  \n\tcase 0x1869:\n\tcase 0x1879:\n\t\tif (val > 7)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn (snd_es18xx_mixer_bits(chip, 0x1c, 0x07, val) != val) || retVal;\n}\n\n#define snd_es18xx_info_spatializer_enable\tsnd_ctl_boolean_mono_info\n\nstatic int snd_es18xx_get_spatializer_enable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char val = snd_es18xx_mixer_read(chip, 0x50);\n\tucontrol->value.integer.value[0] = !!(val & 8);\n\treturn 0;\n}\n\nstatic int snd_es18xx_put_spatializer_enable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char oval, nval;\n\tint change;\n\tnval = ucontrol->value.integer.value[0] ? 0x0c : 0x04;\n\toval = snd_es18xx_mixer_read(chip, 0x50) & 0x0c;\n\tchange = nval != oval;\n\tif (change) {\n\t\tsnd_es18xx_mixer_write(chip, 0x50, nval & ~0x04);\n\t\tsnd_es18xx_mixer_write(chip, 0x50, nval);\n\t}\n\treturn change;\n}\n\nstatic int snd_es18xx_info_hw_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 63;\n\treturn 0;\n}\n\nstatic int snd_es18xx_get_hw_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = snd_es18xx_mixer_read(chip, 0x61) & 0x3f;\n\tucontrol->value.integer.value[1] = snd_es18xx_mixer_read(chip, 0x63) & 0x3f;\n\treturn 0;\n}\n\n#define snd_es18xx_info_hw_switch\tsnd_ctl_boolean_stereo_info\n\nstatic int snd_es18xx_get_hw_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = !(snd_es18xx_mixer_read(chip, 0x61) & 0x40);\n\tucontrol->value.integer.value[1] = !(snd_es18xx_mixer_read(chip, 0x63) & 0x40);\n\treturn 0;\n}\n\nstatic void snd_es18xx_hwv_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tchip->master_volume = NULL;\n\tchip->master_switch = NULL;\n\tchip->hw_volume = NULL;\n\tchip->hw_switch = NULL;\n}\n\nstatic int snd_es18xx_reg_bits(struct snd_es18xx *chip, unsigned char reg,\n\t\t\t       unsigned char mask, unsigned char val)\n{\n\tif (reg < 0xa0)\n\t\treturn snd_es18xx_mixer_bits(chip, reg, mask, val);\n\telse\n\t\treturn snd_es18xx_bits(chip, reg, mask, val);\n}\n\nstatic int snd_es18xx_reg_read(struct snd_es18xx *chip, unsigned char reg)\n{\n\tif (reg < 0xa0)\n\t\treturn snd_es18xx_mixer_read(chip, reg);\n\telse\n\t\treturn snd_es18xx_read(chip, reg);\n}\n\n#define ES18XX_SINGLE(xname, xindex, reg, shift, mask, flags) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es18xx_info_single, \\\n  .get = snd_es18xx_get_single, .put = snd_es18xx_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (flags << 24) }\n\n#define ES18XX_FL_INVERT\t(1 << 0)\n#define ES18XX_FL_PMPORT\t(1 << 1)\n\nstatic int snd_es18xx_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es18xx_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & ES18XX_FL_INVERT;\n\tint pm_port = (kcontrol->private_value >> 24) & ES18XX_FL_PMPORT;\n\tint val;\n\n\tif (pm_port)\n\t\tval = inb(chip->port + ES18XX_PM);\n\telse\n\t\tval = snd_es18xx_reg_read(chip, reg);\n\tucontrol->value.integer.value[0] = (val >> shift) & mask;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_es18xx_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & ES18XX_FL_INVERT;\n\tint pm_port = (kcontrol->private_value >> 24) & ES18XX_FL_PMPORT;\n\tunsigned char val;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tmask <<= shift;\n\tval <<= shift;\n\tif (pm_port) {\n\t\tunsigned char cur = inb(chip->port + ES18XX_PM);\n\n\t\tif ((cur & mask) == val)\n\t\t\treturn 0;\n\t\toutb((cur & ~mask) | val, chip->port + ES18XX_PM);\n\t\treturn 1;\n\t}\n\n\treturn snd_es18xx_reg_bits(chip, reg, mask, val) != val;\n}\n\n#define ES18XX_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es18xx_info_double, \\\n  .get = snd_es18xx_get_double, .put = snd_es18xx_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\nstatic int snd_es18xx_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es18xx_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tunsigned char left, right;\n\t\n\tleft = snd_es18xx_reg_read(chip, left_reg);\n\tif (left_reg != right_reg)\n\t\tright = snd_es18xx_reg_read(chip, right_reg);\n\telse\n\t\tright = left;\n\tucontrol->value.integer.value[0] = (left >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (right >> shift_right) & mask;\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_es18xx_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned char val1, val2, mask1, mask2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tmask1 = mask << shift_left;\n\tmask2 = mask << shift_right;\n\tif (left_reg != right_reg) {\n\t\tchange = 0;\n\t\tif (snd_es18xx_reg_bits(chip, left_reg, mask1, val1) != val1)\n\t\t\tchange = 1;\n\t\tif (snd_es18xx_reg_bits(chip, right_reg, mask2, val2) != val2)\n\t\t\tchange = 1;\n\t} else {\n\t\tchange = (snd_es18xx_reg_bits(chip, left_reg, mask1 | mask2, \n\t\t\t\t\t      val1 | val2) != (val1 | val2));\n\t}\n\treturn change;\n}\n\n \nstatic const struct snd_kcontrol_new snd_es18xx_base_controls[] = {\nES18XX_DOUBLE(\"Master Playback Volume\", 0, 0x60, 0x62, 0, 0, 63, 0),\nES18XX_DOUBLE(\"Master Playback Switch\", 0, 0x60, 0x62, 6, 6, 1, 1),\nES18XX_DOUBLE(\"Line Playback Volume\", 0, 0x3e, 0x3e, 4, 0, 15, 0),\nES18XX_DOUBLE(\"CD Playback Volume\", 0, 0x38, 0x38, 4, 0, 15, 0),\nES18XX_DOUBLE(\"FM Playback Volume\", 0, 0x36, 0x36, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Mic Playback Volume\", 0, 0x1a, 0x1a, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Aux Playback Volume\", 0, 0x3a, 0x3a, 4, 0, 15, 0),\nES18XX_SINGLE(\"Record Monitor\", 0, 0xa8, 3, 1, 0),\nES18XX_DOUBLE(\"Capture Volume\", 0, 0xb4, 0xb4, 4, 0, 15, 0),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_es18xx_info_mux,\n\t.get = snd_es18xx_get_mux,\n\t.put = snd_es18xx_put_mux,\n}\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_recmix_controls[] = {\nES18XX_DOUBLE(\"PCM Capture Volume\", 0, 0x69, 0x69, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Mic Capture Volume\", 0, 0x68, 0x68, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Line Capture Volume\", 0, 0x6e, 0x6e, 4, 0, 15, 0),\nES18XX_DOUBLE(\"FM Capture Volume\", 0, 0x6b, 0x6b, 4, 0, 15, 0),\nES18XX_DOUBLE(\"CD Capture Volume\", 0, 0x6a, 0x6a, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Aux Capture Volume\", 0, 0x6c, 0x6c, 4, 0, 15, 0)\n};\n\n \nstatic const struct snd_kcontrol_new snd_es18xx_opt_speaker =\n\tES18XX_SINGLE(\"Beep Playback Volume\", 0, 0x3c, 0, 7, 0);\n\nstatic const struct snd_kcontrol_new snd_es18xx_opt_1869[] = {\nES18XX_SINGLE(\"Capture Switch\", 0, 0x1c, 4, 1, ES18XX_FL_INVERT),\nES18XX_SINGLE(\"Video Playback Switch\", 0, 0x7f, 0, 1, 0),\nES18XX_DOUBLE(\"Mono Playback Volume\", 0, 0x6d, 0x6d, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Mono Capture Volume\", 0, 0x6f, 0x6f, 4, 0, 15, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_opt_1878 =\n\tES18XX_DOUBLE(\"Video Playback Volume\", 0, 0x68, 0x68, 4, 0, 15, 0);\n\nstatic const struct snd_kcontrol_new snd_es18xx_opt_1879[] = {\nES18XX_SINGLE(\"Video Playback Switch\", 0, 0x71, 6, 1, 0),\nES18XX_DOUBLE(\"Video Playback Volume\", 0, 0x6d, 0x6d, 4, 0, 15, 0),\nES18XX_DOUBLE(\"Video Capture Volume\", 0, 0x6f, 0x6f, 4, 0, 15, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_pcm1_controls[] = {\nES18XX_DOUBLE(\"PCM Playback Volume\", 0, 0x14, 0x14, 4, 0, 15, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_pcm2_controls[] = {\nES18XX_DOUBLE(\"PCM Playback Volume\", 0, 0x7c, 0x7c, 4, 0, 15, 0),\nES18XX_DOUBLE(\"PCM Playback Volume\", 1, 0x14, 0x14, 4, 0, 15, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_spatializer_controls[] = {\nES18XX_SINGLE(\"3D Control - Level\", 0, 0x52, 0, 63, 0),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"3D Control - Switch\",\n\t.info = snd_es18xx_info_spatializer_enable,\n\t.get = snd_es18xx_get_spatializer_enable,\n\t.put = snd_es18xx_put_spatializer_enable,\n}\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_micpre1_control =\nES18XX_SINGLE(\"Mic Boost (+26dB)\", 0, 0xa9, 2, 1, 0);\n\nstatic const struct snd_kcontrol_new snd_es18xx_micpre2_control =\nES18XX_SINGLE(\"Mic Boost (+26dB)\", 0, 0x7d, 3, 1, 0);\n\nstatic const struct snd_kcontrol_new snd_es18xx_hw_volume_controls[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Hardware Master Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_es18xx_info_hw_volume,\n\t.get = snd_es18xx_get_hw_volume,\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Hardware Master Playback Switch\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_es18xx_info_hw_switch,\n\t.get = snd_es18xx_get_hw_switch,\n},\nES18XX_SINGLE(\"Hardware Master Volume Split\", 0, 0x64, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_es18xx_opt_gpo_2bit[] = {\nES18XX_SINGLE(\"GPO0 Switch\", 0, ES18XX_PM, 0, 1, ES18XX_FL_PMPORT),\nES18XX_SINGLE(\"GPO1 Switch\", 0, ES18XX_PM, 1, 1, ES18XX_FL_PMPORT),\n};\n\nstatic int snd_es18xx_config_read(struct snd_es18xx *chip, unsigned char reg)\n{\n\toutb(reg, chip->ctrl_port);\n\treturn inb(chip->ctrl_port + 1);\n}\n\nstatic void snd_es18xx_config_write(struct snd_es18xx *chip,\n\t\t\t\t    unsigned char reg, unsigned char data)\n{\n\t \n\toutb(reg, chip->ctrl_port);\n\toutb(data, chip->ctrl_port + 1);\n#ifdef REG_DEBUG\n\tsnd_printk(KERN_DEBUG \"Config reg %02x set to %02x\\n\", reg, data);\n#endif\n}\n\nstatic int snd_es18xx_initialize(struct snd_es18xx *chip,\n\t\t\t\t unsigned long mpu_port,\n\t\t\t\t unsigned long fm_port)\n{\n\tint mask = 0;\n\n         \n        snd_es18xx_dsp_command(chip, 0xC6);\n\t \n\tsnd_es18xx_mixer_write(chip, 0x00, 0x00);\n\n         \n        snd_es18xx_write(chip, 0xB9, 2);\n\tif (chip->caps & ES18XX_CONTROL) {\n\t\t \n\t\tsnd_es18xx_config_write(chip, 0x27, chip->irq);\n\t\tif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\n\t\t\t \n\t\t\tsnd_es18xx_config_write(chip, 0x62, fm_port >> 8);\n\t\t\tsnd_es18xx_config_write(chip, 0x63, fm_port & 0xff);\n\t\t}\n\t\tif (mpu_port > 0 && mpu_port != SNDRV_AUTO_PORT) {\n\t\t\t \n\t\t\tsnd_es18xx_config_write(chip, 0x64, mpu_port >> 8);\n\t\t\tsnd_es18xx_config_write(chip, 0x65, mpu_port & 0xff);\n\t\t\t \n\t\t\tsnd_es18xx_config_write(chip, 0x28, chip->irq);\n\t\t}\n\t\t \n\t\tsnd_es18xx_config_write(chip, 0x70, chip->irq);\n\t\t \n\t\tsnd_es18xx_config_write(chip, 0x72, chip->irq);\n\t\t \n\t\tsnd_es18xx_config_write(chip, 0x74, chip->dma1);\n\t\t \n\t\tsnd_es18xx_config_write(chip, 0x75, chip->dma2);\n\n\t\t \n\t\tsnd_es18xx_write(chip, 0xB1, 0x50);\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x7A, 0x40);\n\t\t \n\t\tsnd_es18xx_write(chip, 0xB2, 0x50);\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x64, 0x42);\n\t\t \n\t\tsnd_es18xx_mixer_bits(chip, 0x48, 0x10, 0x10);\n\t}\n\telse {\n\t\tint irqmask, dma1mask, dma2mask;\n\t\tswitch (chip->irq) {\n\t\tcase 2:\n\t\tcase 9:\n\t\t\tirqmask = 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tirqmask = 1;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tirqmask = 2;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tirqmask = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_ERR \"invalid irq %d\\n\", chip->irq);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tswitch (chip->dma1) {\n\t\tcase 0:\n\t\t\tdma1mask = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdma1mask = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdma1mask = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_ERR \"invalid dma1 %d\\n\", chip->dma1);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tswitch (chip->dma2) {\n\t\tcase 0:\n\t\t\tdma2mask = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdma2mask = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdma2mask = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdma2mask = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_ERR \"invalid dma2 %d\\n\", chip->dma2);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tsnd_es18xx_write(chip, 0xB1, 0x50 | (irqmask << 2));\n\t\t \n\t\tsnd_es18xx_write(chip, 0xB2, 0x50 | (dma1mask << 2));\n\t\t \n\t\tsnd_es18xx_mixer_bits(chip, 0x7d, 0x07, 0x04 | dma2mask);\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x7A, 0x68);\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x64, 0x06);\n\t\tif (mpu_port > 0 && mpu_port != SNDRV_AUTO_PORT) {\n\t\t\t \n\t\t\tsnd_es18xx_mixer_write(chip, 0x40,\n\t\t\t\t\t       0x43 | (mpu_port & 0xf0) >> 1);\n\t\t}\n\t\tsnd_es18xx_mixer_write(chip, 0x7f, ((irqmask + 1) << 1) | 0x01);\n\t}\n\tif (chip->caps & ES18XX_NEW_RATE) {\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x71, 0x32);\n\t}\n\tif (!(chip->caps & ES18XX_PCM2)) {\n\t\t \n\t\tsnd_es18xx_write(chip, 0xB7, 0x80);\n\t}\n\tif (chip->caps & ES18XX_SPATIALIZER) {\n\t\t \n\t\tsnd_es18xx_mixer_write(chip, 0x54, 0x8f);\n\t\tsnd_es18xx_mixer_write(chip, 0x56, 0x95);\n\t\tsnd_es18xx_mixer_write(chip, 0x58, 0x94);\n\t\tsnd_es18xx_mixer_write(chip, 0x5a, 0x80);\n\t}\n\t \n\tswitch (chip->version) {\n\tcase 0x1879:\n\t\t\n\t\t\n\t\t\n\t\t \n\tcase 0x1878:\n\t\tsnd_es18xx_config_write(chip, 0x29, snd_es18xx_config_read(chip, 0x29) | 0x40);\n\t\tbreak;\n\t}\n\t \n\tif (chip->caps & ES18XX_MUTEREC)\n\t\tmask = 0x10;\n\tif (chip->caps & ES18XX_RECMIX)\n\t\tsnd_es18xx_mixer_write(chip, 0x1c, 0x05 | mask);\n\telse {\n\t\tsnd_es18xx_mixer_write(chip, 0x1c, 0x00 | mask);\n\t\tsnd_es18xx_write(chip, 0xb4, 0x00);\n\t}\n#ifndef AVOID_POPS\n\t \n\tsnd_es18xx_dsp_command(chip, 0xD1);\n#endif\n\n        return 0;\n}\n\nstatic int snd_es18xx_identify(struct snd_card *card, struct snd_es18xx *chip)\n{\n\tint hi,lo;\n\n\t \n\tif (snd_es18xx_reset(chip) < 0) {\n\t\tsnd_printk(KERN_ERR \"reset at 0x%lx failed!!!\\n\", chip->port);\n\t\treturn -ENODEV;\n\t}\n\n\tsnd_es18xx_dsp_command(chip, 0xe7);\n\thi = snd_es18xx_dsp_get_byte(chip);\n\tif (hi < 0) {\n\t\treturn hi;\n\t}\n\tlo = snd_es18xx_dsp_get_byte(chip);\n\tif ((lo & 0xf0) != 0x80) {\n\t\treturn -ENODEV;\n\t}\n\tif (hi == 0x48) {\n\t\tchip->version = 0x488;\n\t\treturn 0;\n\t}\n\tif (hi != 0x68) {\n\t\treturn -ENODEV;\n\t}\n\tif ((lo & 0x0f) < 8) {\n\t\tchip->version = 0x688;\n\t\treturn 0;\n\t}\n\t\t\t\n        outb(0x40, chip->port + 0x04);\n\tudelay(10);\n\thi = inb(chip->port + 0x05);\n\tudelay(10);\n\tlo = inb(chip->port + 0x05);\n\tif (hi != lo) {\n\t\tchip->version = hi << 8 | lo;\n\t\tchip->ctrl_port = inb(chip->port + 0x05) << 8;\n\t\tudelay(10);\n\t\tchip->ctrl_port += inb(chip->port + 0x05);\n\n\t\tif (!devm_request_region(card->dev, chip->ctrl_port, 8,\n\t\t\t\t\t \"ES18xx - CTRL\")) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable go grab port 0x%lx\\n\", chip->ctrl_port);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (snd_es18xx_mixer_writable(chip, 0x64, 0x04)) {\n\t\t \n\t\tif (snd_es18xx_mixer_writable(chip, 0x70, 0x7f)) {\n\t\t\t \n\t\t\tif (snd_es18xx_mixer_writable(chip, 0x64, 0x20)) {\n\t\t\t\tchip->version = 0x1887;\n\t\t\t} else {\n\t\t\t\tchip->version = 0x1888;\n\t\t\t}\n\t\t} else {\n\t\t\tchip->version = 0x1788;\n\t\t}\n\t}\n\telse\n\t\tchip->version = 0x1688;\n\treturn 0;\n}\n\nstatic int snd_es18xx_probe(struct snd_card *card,\n\t\t\t    struct snd_es18xx *chip,\n\t\t\t    unsigned long mpu_port,\n\t\t\t    unsigned long fm_port)\n{\n\tif (snd_es18xx_identify(card, chip) < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"[0x%lx] ESS chip not found\\n\", chip->port);\n                return -ENODEV;\n\t}\n\n\tswitch (chip->version) {\n\tcase 0x1868:\n\t\tchip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_CONTROL | ES18XX_GPO_2BIT;\n\t\tbreak;\n\tcase 0x1869:\n\t\tchip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_MONO | ES18XX_MUTEREC | ES18XX_CONTROL | ES18XX_HWV | ES18XX_GPO_2BIT;\n\t\tbreak;\n\tcase 0x1878:\n\t\tchip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_I2S | ES18XX_CONTROL;\n\t\tbreak;\n\tcase 0x1879:\n\t\tchip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_I2S | ES18XX_CONTROL | ES18XX_HWV;\n\t\tbreak;\n\tcase 0x1887:\n\tcase 0x1888:\n\t\tchip->caps = ES18XX_PCM2 | ES18XX_RECMIX | ES18XX_AUXB | ES18XX_DUPLEX_SAME | ES18XX_GPO_2BIT;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"[0x%lx] unsupported chip ES%x\\n\",\n                           chip->port, chip->version);\n                return -ENODEV;\n        }\n\n        snd_printd(\"[0x%lx] ESS%x chip found\\n\", chip->port, chip->version);\n\n\tif (chip->dma1 == chip->dma2)\n\t\tchip->caps &= ~(ES18XX_PCM2 | ES18XX_DUPLEX_SAME);\n\n\treturn snd_es18xx_initialize(chip, mpu_port, fm_port);\n}\n\nstatic const struct snd_pcm_ops snd_es18xx_playback_ops = {\n\t.open =\t\tsnd_es18xx_playback_open,\n\t.close =\tsnd_es18xx_playback_close,\n\t.hw_params =\tsnd_es18xx_playback_hw_params,\n\t.prepare =\tsnd_es18xx_playback_prepare,\n\t.trigger =\tsnd_es18xx_playback_trigger,\n\t.pointer =\tsnd_es18xx_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_es18xx_capture_ops = {\n\t.open =\t\tsnd_es18xx_capture_open,\n\t.close =\tsnd_es18xx_capture_close,\n\t.hw_params =\tsnd_es18xx_capture_hw_params,\n\t.prepare =\tsnd_es18xx_capture_prepare,\n\t.trigger =\tsnd_es18xx_capture_trigger,\n\t.pointer =\tsnd_es18xx_capture_pointer,\n};\n\nstatic int snd_es18xx_pcm(struct snd_card *card, int device)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n        struct snd_pcm *pcm;\n\tchar str[16];\n\tint err;\n\n\tsprintf(str, \"ES%x\", chip->version);\n\tif (chip->caps & ES18XX_PCM2)\n\t\terr = snd_pcm_new(card, str, device, 2, 1, &pcm);\n\telse\n\t\terr = snd_pcm_new(card, str, device, 1, 1, &pcm);\n        if (err < 0)\n                return err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es18xx_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es18xx_capture_ops);\n\n\t \n        pcm->private_data = chip;\n        pcm->info_flags = 0;\n\tif (chip->caps & ES18XX_DUPLEX_SAME)\n\t\tpcm->info_flags |= SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tif (! (chip->caps & ES18XX_PCM2))\n\t\tpcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\n\tsprintf(pcm->name, \"ESS AudioDrive ES%x\", chip->version);\n        chip->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t       64*1024,\n\t\t\t\t       chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM\nstatic int snd_es18xx_suspend(struct snd_card *card, pm_message_t state)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\t \n\tchip->pm_reg = (unsigned char)snd_es18xx_read(chip, ES18XX_PM);\n\tchip->pm_reg |= (ES18XX_PM_FM | ES18XX_PM_SUS);\n\tsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg);\n\tsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_SUS);\n\n\treturn 0;\n}\n\nstatic int snd_es18xx_resume(struct snd_card *card)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n\n\t \n\tsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_FM);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif  \n\nstatic int snd_es18xx_new_device(struct snd_card *card,\n\t\t\t\t unsigned long port,\n\t\t\t\t unsigned long mpu_port,\n\t\t\t\t unsigned long fm_port,\n\t\t\t\t int irq, int dma1, int dma2)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n\n\tspin_lock_init(&chip->reg_lock);\n \tspin_lock_init(&chip->mixer_lock);\n        chip->port = port;\n        chip->irq = -1;\n        chip->dma1 = -1;\n        chip->dma2 = -1;\n        chip->audio2_vol = 0x00;\n\tchip->active = 0;\n\n\tif (!devm_request_region(card->dev, port, 16, \"ES18xx\")) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grap ports 0x%lx-0x%lx\\n\", port, port + 16 - 1);\n\t\treturn -EBUSY;\n\t}\n\n\tif (devm_request_irq(card->dev, irq, snd_es18xx_interrupt, 0, \"ES18xx\",\n\t\t\t     (void *) card)) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grap IRQ %d\\n\", irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\n\tif (snd_devm_request_dma(card->dev, dma1, \"ES18xx DMA 1\")) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grap DMA1 %d\\n\", dma1);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma1 = dma1;\n\n\tif (dma2 != dma1 &&\n\t    snd_devm_request_dma(card->dev, dma2, \"ES18xx DMA 2\")) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grap DMA2 %d\\n\", dma2);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma2 = dma2;\n\n\tif (snd_es18xx_probe(card, chip, mpu_port, fm_port) < 0)\n\t\treturn -ENODEV;\n        return 0;\n}\n\nstatic int snd_es18xx_mixer(struct snd_card *card)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n\tint err;\n\tunsigned int idx;\n\n\tstrcpy(card->mixername, chip->pcm->name);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_base_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(&snd_es18xx_base_controls[idx], chip);\n\t\tif (chip->caps & ES18XX_HWV) {\n\t\t\tswitch (idx) {\n\t\t\tcase 0:\n\t\t\t\tchip->master_volume = kctl;\n\t\t\t\tkctl->private_free = snd_es18xx_hwv_free;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tchip->master_switch = kctl;\n\t\t\t\tkctl->private_free = snd_es18xx_hwv_free;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->caps & ES18XX_PCM2) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_pcm2_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_pcm2_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} \n\t} else {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_pcm1_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_pcm1_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (chip->caps & ES18XX_RECMIX) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_recmix_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_recmix_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tswitch (chip->version) {\n\tdefault:\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_micpre1_control, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase 0x1869:\n\tcase 0x1879:\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_micpre2_control, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tif (chip->caps & ES18XX_SPATIALIZER) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_spatializer_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_spatializer_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (chip->caps & ES18XX_HWV) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_hw_volume_controls); idx++) {\n\t\t\tstruct snd_kcontrol *kctl;\n\t\t\tkctl = snd_ctl_new1(&snd_es18xx_hw_volume_controls[idx], chip);\n\t\t\tif (idx == 0)\n\t\t\t\tchip->hw_volume = kctl;\n\t\t\telse\n\t\t\t\tchip->hw_switch = kctl;\n\t\t\tkctl->private_free = snd_es18xx_hwv_free;\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\t\n\t\t}\n\t}\n\t \n\tif (chip->version != 0x1868) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_opt_speaker,\n\t\t\t\t\t\t     chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->version == 0x1869) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_opt_1869); idx++) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\t  snd_ctl_new1(&snd_es18xx_opt_1869[idx],\n\t\t\t\t\t\t       chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else if (chip->version == 0x1878) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_opt_1878,\n\t\t\t\t\t\t     chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (chip->version == 0x1879) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_opt_1879); idx++) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\t  snd_ctl_new1(&snd_es18xx_opt_1879[idx],\n\t\t\t\t\t\t       chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (chip->caps & ES18XX_GPO_2BIT) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_opt_gpo_2bit); idx++) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\t  snd_ctl_new1(&snd_es18xx_opt_gpo_2bit[idx],\n\t\t\t\t\t\t       chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n       \n\n \n\nMODULE_AUTHOR(\"Christian Fischbach <fishbach@pool.informatik.rwth-aachen.de>, Abramo Bagnara <abramo@alsa-project.org>\");\nMODULE_DESCRIPTION(\"ESS ES18xx AudioDrive\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;  \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;\n#endif\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \n#ifndef CONFIG_PNP\nstatic long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};\n#else\nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n#endif\nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ES18xx soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ES18xx soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ES18xx soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"PnP detection for specified soundcard.\");\n#endif\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for ES18xx driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for ES18xx driver.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for ES18xx driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for ES18xx driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA 1 # for ES18xx driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA 2 # for ES18xx driver.\");\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\nstatic int pnpc_registered;\n\nstatic const struct pnp_device_id snd_audiodrive_pnpbiosids[] = {\n\t{ .id = \"ESS1869\" },\n\t{ .id = \"ESS1879\" },\n\t{ .id = \"\" }\t\t \n};\n\nMODULE_DEVICE_TABLE(pnp, snd_audiodrive_pnpbiosids);\n\n \nstatic int snd_audiodrive_pnp_init_main(int dev, struct pnp_dev *pdev)\n{\n\tif (pnp_activate_dev(pdev) < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"PnP configure failure (out of resources?)\\n\");\n\t\treturn -EBUSY;\n\t}\n\t \n\t \n\tif (pnp_device_is_isapnp(pdev)) {\n\t\tisapnp_cfg_begin(isapnp_card_number(pdev), isapnp_csn_number(pdev));\n\t\tisapnp_write_byte(0x27, pnp_irq(pdev, 0));\t \n\t\tif (mpu_port[dev] != SNDRV_AUTO_PORT)\n\t\t\tisapnp_write_byte(0x28, pnp_irq(pdev, 0));  \n\t\tisapnp_write_byte(0x72, pnp_irq(pdev, 0));\t \n\t\tisapnp_cfg_end();\n\t}\n\tport[dev] = pnp_port_start(pdev, 0);\n\tfm_port[dev] = pnp_port_start(pdev, 1);\n\tmpu_port[dev] = pnp_port_start(pdev, 2);\n\tdma1[dev] = pnp_dma(pdev, 0);\n\tdma2[dev] = pnp_dma(pdev, 1);\n\tirq[dev] = pnp_irq(pdev, 0);\n\tsnd_printdd(\"PnP ES18xx: port=0x%lx, fm port=0x%lx, mpu port=0x%lx\\n\", port[dev], fm_port[dev], mpu_port[dev]);\n\tsnd_printdd(\"PnP ES18xx: dma1=%i, dma2=%i, irq=%i\\n\", dma1[dev], dma2[dev], irq[dev]);\n\treturn 0;\n}\n\nstatic int snd_audiodrive_pnp(int dev, struct snd_es18xx *chip,\n\t\t\t      struct pnp_dev *pdev)\n{\n\tchip->dev = pdev;\n\tif (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic const struct pnp_card_device_id snd_audiodrive_pnpids[] = {\n\t \n\t{ .id = \"ESS1868\", .devs = { { \"ESS1868\" }, { \"ESS0000\" } } },\n\t \n\t{ .id = \"ESS1868\", .devs = { { \"ESS8601\" }, { \"ESS8600\" } } },\n\t \n\t{ .id = \"ESS1868\", .devs = { { \"ESS8611\" }, { \"ESS8610\" } } },\n\t \n\t{ .id = \"ESS0003\", .devs = { { \"ESS1869\" }, { \"ESS0006\" } } },\n\t \n\t{ .id = \"ESS1869\", .devs = { { \"ESS1869\" }, { \"ESS0006\" } } },\n\t \n\t{ .id = \"ESS1878\", .devs = { { \"ESS1878\" }, { \"ESS0004\" } } },\n\t \n\t{ .id = \"ESS1879\", .devs = { { \"ESS1879\" }, { \"ESS0009\" } } },\n\t \n\t{ .id = \"\" }  \n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_audiodrive_pnpids);\n\nstatic int snd_audiodrive_pnpc(int dev, struct snd_es18xx *chip,\n\t\t\t       struct pnp_card_link *card,\n\t\t\t       const struct pnp_card_device_id *id)\n{\n\tchip->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (chip->dev == NULL)\n\t\treturn -EBUSY;\n\n\tchip->devc = pnp_request_card_device(card, id->devs[1].id, NULL);\n\tif (chip->devc == NULL)\n\t\treturn -EBUSY;\n\n\t \n\tif (pnp_activate_dev(chip->devc) < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"PnP control configure failure (out of resources?)\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tsnd_printdd(\"pnp: port=0x%llx\\n\",\n\t\t\t(unsigned long long)pnp_port_start(chip->devc, 0));\n\tif (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PNP\n#define is_isapnp_selected(dev)\t\tisapnp[dev]\n#else\n#define is_isapnp_selected(dev)\t\t0\n#endif\n\nstatic int snd_es18xx_card_new(struct device *pdev, int dev,\n\t\t\t       struct snd_card **cardp)\n{\n\treturn snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\t sizeof(struct snd_es18xx), cardp);\n}\n\nstatic int snd_audiodrive_probe(struct snd_card *card, int dev)\n{\n\tstruct snd_es18xx *chip = card->private_data;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\terr = snd_es18xx_new_device(card,\n\t\t\t\t    port[dev], mpu_port[dev], fm_port[dev],\n\t\t\t\t    irq[dev], dma1[dev], dma2[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(card->driver, \"ES%x\", chip->version);\n\t\n\tsprintf(card->shortname, \"ESS AudioDrive ES%x\", chip->version);\n\tif (dma1[dev] != dma2[dev])\n\t\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma1 %d, dma2 %d\",\n\t\t\tcard->shortname,\n\t\t\tchip->port,\n\t\t\tirq[dev], dma1[dev], dma2[dev]);\n\telse\n\t\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma %d\",\n\t\t\tcard->shortname,\n\t\t\tchip->port,\n\t\t\tirq[dev], dma1[dev]);\n\n\terr = snd_es18xx_pcm(card, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_es18xx_mixer(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\n\t\tif (snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\n\t\t\t\t    OPL3_HW_OPL3, 0, &opl3) < 0) {\n\t\t\tsnd_printk(KERN_WARNING PFX\n\t\t\t\t   \"opl3 not detected at 0x%lx\\n\",\n\t\t\t\t   fm_port[dev]);\n\t\t} else {\n\t\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_ES18XX,\n\t\t\t\t\t  mpu_port[dev], MPU401_INFO_IRQ_HOOK,\n\t\t\t\t\t  -1, &chip->rmidi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_card_register(card);\n}\n\nstatic int snd_es18xx_isa_match(struct device *pdev, unsigned int dev)\n{\n\treturn enable[dev] && !is_isapnp_selected(dev);\n}\n\nstatic int snd_es18xx_isa_probe1(int dev, struct device *devptr)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_es18xx_card_new(devptr, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_audiodrive_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_drvdata(devptr, card);\n\treturn 0;\n}\n\nstatic int snd_es18xx_isa_probe(struct device *pdev, unsigned int dev)\n{\n\tint err;\n\tstatic const int possible_irqs[] = {5, 9, 10, 7, 11, 12, -1};\n\tstatic const int possible_dmas[] = {1, 0, 3, 5, -1};\n\n\tif (irq[dev] == SNDRV_AUTO_IRQ) {\n\t\tirq[dev] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1[dev] == SNDRV_AUTO_DMA) {\n\t\tdma1[dev] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma1[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma2[dev] == SNDRV_AUTO_DMA) {\n\t\tdma2[dev] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma2[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA2\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (port[dev] != SNDRV_AUTO_PORT) {\n\t\treturn snd_es18xx_isa_probe1(dev, pdev);\n\t} else {\n\t\tstatic const unsigned long possible_ports[] = {0x220, 0x240, 0x260, 0x280};\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\n\t\t\tport[dev] = possible_ports[i];\n\t\t\terr = snd_es18xx_isa_probe1(dev, pdev);\n\t\t\tif (! err)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int snd_es18xx_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\t  pm_message_t state)\n{\n\treturn snd_es18xx_suspend(dev_get_drvdata(dev), state);\n}\n\nstatic int snd_es18xx_isa_resume(struct device *dev, unsigned int n)\n{\n\treturn snd_es18xx_resume(dev_get_drvdata(dev));\n}\n#endif\n\n#define DEV_NAME \"es18xx\"\n\nstatic struct isa_driver snd_es18xx_isa_driver = {\n\t.match\t\t= snd_es18xx_isa_match,\n\t.probe\t\t= snd_es18xx_isa_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_es18xx_isa_suspend,\n\t.resume\t\t= snd_es18xx_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n\n#ifdef CONFIG_PNP\nstatic int snd_audiodrive_pnp_detect(struct pnp_dev *pdev,\n\t\t\t\t     const struct pnp_device_id *id)\n{\n\tstatic int dev;\n\tint err;\n\tstruct snd_card *card;\n\n\tif (pnp_device_is_isapnp(pdev))\n\t\treturn -ENOENT;\t \n\tfor (; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\terr = snd_es18xx_card_new(&pdev->dev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_audiodrive_pnp(dev, card->private_data, pdev);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_audiodrive_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tpnp_set_drvdata(pdev, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_audiodrive_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\treturn snd_es18xx_suspend(pnp_get_drvdata(pdev), state);\n}\nstatic int snd_audiodrive_pnp_resume(struct pnp_dev *pdev)\n{\n\treturn snd_es18xx_resume(pnp_get_drvdata(pdev));\n}\n#endif\n\nstatic struct pnp_driver es18xx_pnp_driver = {\n\t.name = \"es18xx-pnpbios\",\n\t.id_table = snd_audiodrive_pnpbiosids,\n\t.probe = snd_audiodrive_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend = snd_audiodrive_pnp_suspend,\n\t.resume = snd_audiodrive_pnp_resume,\n#endif\n};\n\nstatic int snd_audiodrive_pnpc_detect(struct pnp_card_link *pcard,\n\t\t\t\t      const struct pnp_card_device_id *pid)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tres = snd_es18xx_card_new(&pcard->card->dev, dev, &card);\n\tif (res < 0)\n\t\treturn res;\n\n\tres = snd_audiodrive_pnpc(dev, card->private_data, pcard, pid);\n\tif (res < 0)\n\t\treturn res;\n\tres = snd_audiodrive_probe(card, dev);\n\tif (res < 0)\n\t\treturn res;\n\n\tpnp_set_card_drvdata(pcard, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_audiodrive_pnpc_suspend(struct pnp_card_link *pcard, pm_message_t state)\n{\n\treturn snd_es18xx_suspend(pnp_get_card_drvdata(pcard), state);\n}\n\nstatic int snd_audiodrive_pnpc_resume(struct pnp_card_link *pcard)\n{\n\treturn snd_es18xx_resume(pnp_get_card_drvdata(pcard));\n}\n\n#endif\n\nstatic struct pnp_card_driver es18xx_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DISABLE,\n\t.name = \"es18xx\",\n\t.id_table = snd_audiodrive_pnpids,\n\t.probe = snd_audiodrive_pnpc_detect,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_audiodrive_pnpc_suspend,\n\t.resume\t\t= snd_audiodrive_pnpc_resume,\n#endif\n};\n#endif  \n\nstatic int __init alsa_card_es18xx_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_es18xx_isa_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_driver(&es18xx_pnp_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\terr = pnp_register_card_driver(&es18xx_pnpc_driver);\n\tif (!err)\n\t\tpnpc_registered = 1;\n\n\tif (isa_registered || pnp_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_es18xx_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnpc_registered)\n\t\tpnp_unregister_card_driver(&es18xx_pnpc_driver);\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&es18xx_pnp_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_es18xx_isa_driver);\n}\n\nmodule_init(alsa_card_es18xx_init)\nmodule_exit(alsa_card_es18xx_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}