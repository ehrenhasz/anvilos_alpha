{
  "module_name": "ad1816a.c",
  "hash_id": "f7b1d0884d562721ecd13611d97d3647a2ef5c6d0a9cce4c26c539946d8b26d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/ad1816a/ad1816a.c",
  "human_readable_source": "\n\n \n\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/ad1816a.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n\n#define PFX \"ad1816a: \"\n\nMODULE_AUTHOR(\"Massimo Piccioni <dafastidio@libero.it>\");\nMODULE_DESCRIPTION(\"AD1816A, AD1815\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int clockfreq[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ad1816a based soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ad1816a based soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ad1816a based soundcard.\");\nmodule_param_array(clockfreq, int, NULL, 0444);\nMODULE_PARM_DESC(clockfreq, \"Clock frequency for ad1816a driver (default = 0).\");\n\nstatic const struct pnp_card_device_id snd_ad1816a_pnpids[] = {\n\t \n\t{ .id = \"ADS7150\", .devs = { { .id = \"ADS7150\" }, { .id = \"ADS7151\" } } },\n\t \n\t{ .id = \"ADS7180\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"ADS7181\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"AZT1022\", .devs = { { .id = \"AZT1018\" }, { .id = \"AZT2002\" } } },\n\t \n\t{ .id = \"LWC1061\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"MDK1605\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"SMM7180\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"TER1112\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"TER1112\", .devs = { { .id = \"TER1100\" }, { .id = \"TER1101\" } } },\n\t \n\t{ .id = \"TER1411\", .devs = { { .id = \"ADS7180\" }, { .id = \"ADS7181\" } } },\n\t \n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_ad1816a_pnpids);\n\n\n#define\tDRIVER_NAME\t\"snd-card-ad1816a\"\n\n\nstatic int snd_card_ad1816a_pnp(int dev, struct pnp_card_link *card,\n\t\t\t\tconst struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\tpdev = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (pdev == NULL)\n\t\treturn -EBUSY;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"AUDIO PnP configure failure\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tport[dev] = pnp_port_start(pdev, 2);\n\tfm_port[dev] = pnp_port_start(pdev, 1);\n\tdma1[dev] = pnp_dma(pdev, 0);\n\tdma2[dev] = pnp_dma(pdev, 1);\n\tirq[dev] = pnp_irq(pdev, 0);\n\n\tpdev = pnp_request_card_device(card, id->devs[1].id, NULL);\n\tif (pdev == NULL) {\n\t\tmpu_port[dev] = -1;\n\t\tsnd_printk(KERN_WARNING PFX \"MPU401 device busy, skipping.\\n\");\n\t\treturn 0;\n\t}\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"MPU401 PnP configure failure\\n\");\n\t\tmpu_port[dev] = -1;\n\t} else {\n\t\tmpu_port[dev] = pnp_port_start(pdev, 0);\n\t\tmpu_irq[dev] = pnp_irq(pdev, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_card_ad1816a_probe(int dev, struct pnp_card_link *pcard,\n\t\t\t\t  const struct pnp_card_device_id *pid)\n{\n\tint error;\n\tstruct snd_card *card;\n\tstruct snd_ad1816a *chip;\n\tstruct snd_opl3 *opl3;\n\n\terror = snd_devm_card_new(&pcard->card->dev,\n\t\t\t\t  index[dev], id[dev], THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_ad1816a), &card);\n\tif (error < 0)\n\t\treturn error;\n\tchip = card->private_data;\n\n\terror = snd_card_ad1816a_pnp(dev, pcard, pid);\n\tif (error)\n\t\treturn error;\n\n\terror = snd_ad1816a_create(card, port[dev],\n\t\t\t\t   irq[dev],\n\t\t\t\t   dma1[dev],\n\t\t\t\t   dma2[dev],\n\t\t\t\t   chip);\n\tif (error)\n\t\treturn error;\n\tif (clockfreq[dev] >= 5000 && clockfreq[dev] <= 100000)\n\t\tchip->clock_freq = clockfreq[dev];\n\n\tstrcpy(card->driver, \"AD1816A\");\n\tstrcpy(card->shortname, \"ADI SoundPort AD1816A\");\n\tsprintf(card->longname, \"%s, SS at 0x%lx, irq %d, dma %d&%d\",\n\t\tcard->shortname, chip->port, irq[dev], dma1[dev], dma2[dev]);\n\n\terror = snd_ad1816a_pcm(chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_ad1816a_mixer(chip);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_ad1816a_timer(chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (mpu_port[dev] > 0) {\n\t\tif (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\t\tmpu_port[dev], 0, mpu_irq[dev],\n\t\t\t\t\tNULL) < 0)\n\t\t\tprintk(KERN_ERR PFX \"no MPU-401 device at 0x%lx.\\n\", mpu_port[dev]);\n\t}\n\n\tif (fm_port[dev] > 0) {\n\t\tif (snd_opl3_create(card,\n\t\t\t\t    fm_port[dev], fm_port[dev] + 2,\n\t\t\t\t    OPL3_HW_AUTO, 0, &opl3) < 0) {\n\t\t\tprintk(KERN_ERR PFX \"no OPL device at 0x%lx-0x%lx.\\n\", fm_port[dev], fm_port[dev] + 2);\n\t\t} else {\n\t\t\terror = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = snd_card_register(card);\n\tif (error < 0)\n\t\treturn error;\n\tpnp_set_card_drvdata(pcard, card);\n\treturn 0;\n}\n\nstatic unsigned int ad1816a_devices;\n\nstatic int snd_ad1816a_pnp_detect(struct pnp_card_link *card,\n\t\t\t\t  const struct pnp_card_device_id *id)\n{\n\tstatic int dev;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (!enable[dev])\n\t\t\tcontinue;\n\t\tres = snd_card_ad1816a_probe(dev, card, id);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tdev++;\n\t\tad1816a_devices++;\n\t\treturn 0;\n\t}\n        return -ENODEV;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_ad1816a_pnp_suspend(struct pnp_card_link *pcard,\n\t\t\t\t   pm_message_t state)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ad1816a_suspend(card->private_data);\n\treturn 0;\n}\n\nstatic int snd_ad1816a_pnp_resume(struct pnp_card_link *pcard)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\n\tsnd_ad1816a_resume(card->private_data);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic struct pnp_card_driver ad1816a_pnpc_driver = {\n\t.flags\t\t= PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= \"ad1816a\",\n\t.id_table\t= snd_ad1816a_pnpids,\n\t.probe\t\t= snd_ad1816a_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_ad1816a_pnp_suspend,\n\t.resume\t\t= snd_ad1816a_pnp_resume,\n#endif\n};\n\nstatic int __init alsa_card_ad1816a_init(void)\n{\n\tint err;\n\n\terr = pnp_register_card_driver(&ad1816a_pnpc_driver);\n\tif (err)\n\t\treturn err;\n\n\tif (!ad1816a_devices) {\n\t\tpnp_unregister_card_driver(&ad1816a_pnpc_driver);\n#ifdef MODULE\n\t\tprintk(KERN_ERR \"no AD1816A based soundcards found.\\n\");\n#endif\t \n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_ad1816a_exit(void)\n{\n\tpnp_unregister_card_driver(&ad1816a_pnpc_driver);\n}\n\nmodule_init(alsa_card_ad1816a_init)\nmodule_exit(alsa_card_ad1816a_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}