{
  "module_name": "ad1816a_lib.c",
  "hash_id": "ff3293d7380ccada4efe167407daf58aaeddd271c1ec921cd8ce3de4be7b9ee4",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/ad1816a/ad1816a_lib.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n#include <sound/ad1816a.h>\n\n#include <asm/dma.h>\n\nstatic inline int snd_ad1816a_busy_wait(struct snd_ad1816a *chip)\n{\n\tint timeout;\n\n\tfor (timeout = 1000; timeout-- > 0; udelay(10))\n\t\tif (inb(AD1816A_REG(AD1816A_CHIP_STATUS)) & AD1816A_READY)\n\t\t\treturn 0;\n\n\tsnd_printk(KERN_WARNING \"chip busy.\\n\");\n\treturn -EBUSY;\n}\n\nstatic inline unsigned char snd_ad1816a_in(struct snd_ad1816a *chip, unsigned char reg)\n{\n\tsnd_ad1816a_busy_wait(chip);\n\treturn inb(AD1816A_REG(reg));\n}\n\nstatic inline void snd_ad1816a_out(struct snd_ad1816a *chip, unsigned char reg,\n\t\t\t    unsigned char value)\n{\n\tsnd_ad1816a_busy_wait(chip);\n\toutb(value, AD1816A_REG(reg));\n}\n\nstatic inline void snd_ad1816a_out_mask(struct snd_ad1816a *chip, unsigned char reg,\n\t\t\t\t unsigned char mask, unsigned char value)\n{\n\tsnd_ad1816a_out(chip, reg,\n\t\t(value & mask) | (snd_ad1816a_in(chip, reg) & ~mask));\n}\n\nstatic unsigned short snd_ad1816a_read(struct snd_ad1816a *chip, unsigned char reg)\n{\n\tsnd_ad1816a_out(chip, AD1816A_INDIR_ADDR, reg & 0x3f);\n\treturn snd_ad1816a_in(chip, AD1816A_INDIR_DATA_LOW) |\n\t\t(snd_ad1816a_in(chip, AD1816A_INDIR_DATA_HIGH) << 8);\n}\n\nstatic void snd_ad1816a_write(struct snd_ad1816a *chip, unsigned char reg,\n\t\t\t      unsigned short value)\n{\n\tsnd_ad1816a_out(chip, AD1816A_INDIR_ADDR, reg & 0x3f);\n\tsnd_ad1816a_out(chip, AD1816A_INDIR_DATA_LOW, value & 0xff);\n\tsnd_ad1816a_out(chip, AD1816A_INDIR_DATA_HIGH, (value >> 8) & 0xff);\n}\n\nstatic void snd_ad1816a_write_mask(struct snd_ad1816a *chip, unsigned char reg,\n\t\t\t\t   unsigned short mask, unsigned short value)\n{\n\tsnd_ad1816a_write(chip, reg,\n\t\t(value & mask) | (snd_ad1816a_read(chip, reg) & ~mask));\n}\n\n\nstatic unsigned char snd_ad1816a_get_format(struct snd_ad1816a *chip,\n\t\t\t\t\t    snd_pcm_format_t format,\n\t\t\t\t\t    int channels)\n{\n\tunsigned char retval = AD1816A_FMT_LINEAR_8;\n\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tretval = AD1816A_FMT_ULAW_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tretval = AD1816A_FMT_ALAW_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tretval = AD1816A_FMT_LINEAR_16_LIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tretval = AD1816A_FMT_LINEAR_16_BIG;\n\t}\n\treturn (channels > 1) ? (retval | AD1816A_FMT_STEREO) : retval;\n}\n\nstatic int snd_ad1816a_open(struct snd_ad1816a *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tif (chip->mode & mode) {\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch ((mode &= AD1816A_MODE_OPEN)) {\n\tcase AD1816A_MODE_PLAYBACK:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_PLAYBACK_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_PLAYBACK_IRQ_ENABLE, 0xffff);\n\t\tbreak;\n\tcase AD1816A_MODE_CAPTURE:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_CAPTURE_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_CAPTURE_IRQ_ENABLE, 0xffff);\n\t\tbreak;\n\tcase AD1816A_MODE_TIMER:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_TIMER_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_TIMER_IRQ_ENABLE, 0xffff);\n\t}\n\tchip->mode |= mode;\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\nstatic void snd_ad1816a_close(struct snd_ad1816a *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tswitch ((mode &= AD1816A_MODE_OPEN)) {\n\tcase AD1816A_MODE_PLAYBACK:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_PLAYBACK_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_PLAYBACK_IRQ_ENABLE, 0x0000);\n\t\tbreak;\n\tcase AD1816A_MODE_CAPTURE:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_CAPTURE_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_CAPTURE_IRQ_ENABLE, 0x0000);\n\t\tbreak;\n\tcase AD1816A_MODE_TIMER:\n\t\tsnd_ad1816a_out_mask(chip, AD1816A_INTERRUPT_STATUS,\n\t\t\tAD1816A_TIMER_IRQ_PENDING, 0x00);\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_TIMER_IRQ_ENABLE, 0x0000);\n\t}\n\tchip->mode &= ~mode;\n\tif (!(chip->mode & AD1816A_MODE_OPEN))\n\t\tchip->mode = 0;\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\n\nstatic int snd_ad1816a_trigger(struct snd_ad1816a *chip, unsigned char what,\n\t\t\t       int channel, int cmd, int iscapture)\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock(&chip->lock);\n\t\tcmd = (cmd == SNDRV_PCM_TRIGGER_START) ? 0xff: 0x00;\n\t\t \n\t\t \n\t\tif (! iscapture)\n\t\t\tsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\n\t\t\t\tAD1816A_PLAYBACK_ENABLE, cmd);\n\t\telse\n\t\t\tsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\n\t\t\t\tAD1816A_CAPTURE_ENABLE, cmd);\n\t\tspin_unlock(&chip->lock);\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"invalid trigger mode 0x%x.\\n\", what);\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}\n\nstatic int snd_ad1816a_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\treturn snd_ad1816a_trigger(chip, AD1816A_PLAYBACK_ENABLE,\n\t\t\t\t   SNDRV_PCM_STREAM_PLAYBACK, cmd, 0);\n}\n\nstatic int snd_ad1816a_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\treturn snd_ad1816a_trigger(chip, AD1816A_CAPTURE_ENABLE,\n\t\t\t\t   SNDRV_PCM_STREAM_CAPTURE, cmd, 1);\n}\n\nstatic int snd_ad1816a_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tunsigned long flags;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size, rate;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tchip->p_dma_size = size = snd_pcm_lib_buffer_bytes(substream);\n\tsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\n\t\tAD1816A_PLAYBACK_ENABLE | AD1816A_PLAYBACK_PIO, 0x00);\n\n\tsnd_dma_program(chip->dma1, runtime->dma_addr, size,\n\t\t\tDMA_MODE_WRITE | DMA_AUTOINIT);\n\n\trate = runtime->rate;\n\tif (chip->clock_freq)\n\t\trate = (rate * 33000) / chip->clock_freq;\n\tsnd_ad1816a_write(chip, AD1816A_PLAYBACK_SAMPLE_RATE, rate);\n\tsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\n\t\tAD1816A_FMT_ALL | AD1816A_FMT_STEREO,\n\t\tsnd_ad1816a_get_format(chip, runtime->format,\n\t\t\truntime->channels));\n\n\tsnd_ad1816a_write(chip, AD1816A_PLAYBACK_BASE_COUNT,\n\t\tsnd_pcm_lib_period_bytes(substream) / 4 - 1);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\nstatic int snd_ad1816a_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tunsigned long flags;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size, rate;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tchip->c_dma_size = size = snd_pcm_lib_buffer_bytes(substream);\n\tsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\n\t\tAD1816A_CAPTURE_ENABLE | AD1816A_CAPTURE_PIO, 0x00);\n\n\tsnd_dma_program(chip->dma2, runtime->dma_addr, size,\n\t\t\tDMA_MODE_READ | DMA_AUTOINIT);\n\n\trate = runtime->rate;\n\tif (chip->clock_freq)\n\t\trate = (rate * 33000) / chip->clock_freq;\n\tsnd_ad1816a_write(chip, AD1816A_CAPTURE_SAMPLE_RATE, rate);\n\tsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\n\t\tAD1816A_FMT_ALL | AD1816A_FMT_STEREO,\n\t\tsnd_ad1816a_get_format(chip, runtime->format,\n\t\t\truntime->channels));\n\n\tsnd_ad1816a_write(chip, AD1816A_CAPTURE_BASE_COUNT,\n\t\tsnd_pcm_lib_period_bytes(substream) / 4 - 1);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\n\nstatic snd_pcm_uframes_t snd_ad1816a_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tif (!(chip->mode & AD1816A_MODE_PLAYBACK))\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_ad1816a_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tif (!(chip->mode & AD1816A_MODE_CAPTURE))\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n\nstatic irqreturn_t snd_ad1816a_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_ad1816a *chip = dev_id;\n\tunsigned char status;\n\n\tspin_lock(&chip->lock);\n\tstatus = snd_ad1816a_in(chip, AD1816A_INTERRUPT_STATUS);\n\tspin_unlock(&chip->lock);\n\n\tif ((status & AD1816A_PLAYBACK_IRQ_PENDING) && chip->playback_substream)\n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\n\tif ((status & AD1816A_CAPTURE_IRQ_PENDING) && chip->capture_substream)\n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\n\tif ((status & AD1816A_TIMER_IRQ_PENDING) && chip->timer)\n\t\tsnd_timer_interrupt(chip->timer, chip->timer->sticks);\n\n\tspin_lock(&chip->lock);\n\tsnd_ad1816a_out(chip, AD1816A_INTERRUPT_STATUS, 0x00);\n\tspin_unlock(&chip->lock);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic const struct snd_pcm_hardware snd_ad1816a_playback = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_BE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t55200,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ad1816a_capture = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_BE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t55200,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_ad1816a_timer_close(struct snd_timer *timer)\n{\n\tstruct snd_ad1816a *chip = snd_timer_chip(timer);\n\tsnd_ad1816a_close(chip, AD1816A_MODE_TIMER);\n\treturn 0;\n}\n\nstatic int snd_ad1816a_timer_open(struct snd_timer *timer)\n{\n\tstruct snd_ad1816a *chip = snd_timer_chip(timer);\n\tsnd_ad1816a_open(chip, AD1816A_MODE_TIMER);\n\treturn 0;\n}\n\nstatic unsigned long snd_ad1816a_timer_resolution(struct snd_timer *timer)\n{\n\tif (snd_BUG_ON(!timer))\n\t\treturn 0;\n\n\treturn 10000;\n}\n\nstatic int snd_ad1816a_timer_start(struct snd_timer *timer)\n{\n\tunsigned short bits;\n\tunsigned long flags;\n\tstruct snd_ad1816a *chip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tbits = snd_ad1816a_read(chip, AD1816A_INTERRUPT_ENABLE);\n\n\tif (!(bits & AD1816A_TIMER_ENABLE)) {\n\t\tsnd_ad1816a_write(chip, AD1816A_TIMER_BASE_COUNT,\n\t\t\ttimer->sticks & 0xffff);\n\n\t\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\t\tAD1816A_TIMER_ENABLE, 0xffff);\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\nstatic int snd_ad1816a_timer_stop(struct snd_timer *timer)\n{\n\tunsigned long flags;\n\tstruct snd_ad1816a *chip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tsnd_ad1816a_write_mask(chip, AD1816A_INTERRUPT_ENABLE,\n\t\tAD1816A_TIMER_ENABLE, 0x0000);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_ad1816a_timer_table = {\n\t.flags =\tSNDRV_TIMER_HW_AUTO,\n\t.resolution =\t10000,\n\t.ticks =\t65535,\n\t.open =\t\tsnd_ad1816a_timer_open,\n\t.close =\tsnd_ad1816a_timer_close,\n\t.c_resolution =\tsnd_ad1816a_timer_resolution,\n\t.start =\tsnd_ad1816a_timer_start,\n\t.stop =\t\tsnd_ad1816a_timer_stop,\n};\n\nstatic int snd_ad1816a_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint error;\n\n\terror = snd_ad1816a_open(chip, AD1816A_MODE_PLAYBACK);\n\tif (error < 0)\n\t\treturn error;\n\truntime->hw = snd_ad1816a_playback;\n\tsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);\n\tchip->playback_substream = substream;\n\treturn 0;\n}\n\nstatic int snd_ad1816a_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint error;\n\n\terror = snd_ad1816a_open(chip, AD1816A_MODE_CAPTURE);\n\tif (error < 0)\n\t\treturn error;\n\truntime->hw = snd_ad1816a_capture;\n\tsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);\n\tchip->capture_substream = substream;\n\treturn 0;\n}\n\nstatic int snd_ad1816a_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\tsnd_ad1816a_close(chip, AD1816A_MODE_PLAYBACK);\n\treturn 0;\n}\n\nstatic int snd_ad1816a_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ad1816a *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\tsnd_ad1816a_close(chip, AD1816A_MODE_CAPTURE);\n\treturn 0;\n}\n\n\nstatic void snd_ad1816a_init(struct snd_ad1816a *chip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tsnd_ad1816a_out(chip, AD1816A_INTERRUPT_STATUS, 0x00);\n\tsnd_ad1816a_out_mask(chip, AD1816A_PLAYBACK_CONFIG,\n\t\tAD1816A_PLAYBACK_ENABLE | AD1816A_PLAYBACK_PIO, 0x00);\n\tsnd_ad1816a_out_mask(chip, AD1816A_CAPTURE_CONFIG,\n\t\tAD1816A_CAPTURE_ENABLE | AD1816A_CAPTURE_PIO, 0x00);\n\tsnd_ad1816a_write(chip, AD1816A_INTERRUPT_ENABLE, 0x0000);\n\tsnd_ad1816a_write_mask(chip, AD1816A_CHIP_CONFIG,\n\t\tAD1816A_CAPTURE_NOT_EQUAL | AD1816A_WSS_ENABLE, 0xffff);\n\tsnd_ad1816a_write(chip, AD1816A_DSP_CONFIG, 0x0000);\n\tsnd_ad1816a_write(chip, AD1816A_POWERDOWN_CTRL, 0x0000);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\n#ifdef CONFIG_PM\nvoid snd_ad1816a_suspend(struct snd_ad1816a *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tfor (reg = 0; reg < 48; reg++)\n\t\tchip->image[reg] = snd_ad1816a_read(chip, reg);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nvoid snd_ad1816a_resume(struct snd_ad1816a *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\n\tsnd_ad1816a_init(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tfor (reg = 0; reg < 48; reg++)\n\t\tsnd_ad1816a_write(chip, reg, chip->image[reg]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n#endif\n\nstatic int snd_ad1816a_probe(struct snd_ad1816a *chip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tswitch (chip->version = snd_ad1816a_read(chip, AD1816A_VERSION_ID)) {\n\tcase 0:\n\t\tchip->hardware = AD1816A_HW_AD1815;\n\t\tbreak;\n\tcase 1:\n\t\tchip->hardware = AD1816A_HW_AD18MAX10;\n\t\tbreak;\n\tcase 3:\n\t\tchip->hardware = AD1816A_HW_AD1816A;\n\t\tbreak;\n\tdefault:\n\t\tchip->hardware = AD1816A_HW_AUTO;\n\t}\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn 0;\n}\n\nstatic const char *snd_ad1816a_chip_id(struct snd_ad1816a *chip)\n{\n\tswitch (chip->hardware) {\n\tcase AD1816A_HW_AD1816A: return \"AD1816A\";\n\tcase AD1816A_HW_AD1815:\treturn \"AD1815\";\n\tcase AD1816A_HW_AD18MAX10: return \"AD18max10\";\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"Unknown chip version %d:%d.\\n\",\n\t\t\tchip->version, chip->hardware);\n\t\treturn \"AD1816A - unknown\";\n\t}\n}\n\nint snd_ad1816a_create(struct snd_card *card,\n\t\t       unsigned long port, int irq, int dma1, int dma2,\n\t\t       struct snd_ad1816a *chip)\n{\n\tint error;\n\n\tchip->irq = -1;\n\tchip->dma1 = -1;\n\tchip->dma2 = -1;\n\n\tchip->res_port = devm_request_region(card->dev, port, 16, \"AD1816A\");\n\tif (!chip->res_port) {\n\t\tsnd_printk(KERN_ERR \"ad1816a: can't grab port 0x%lx\\n\", port);\n\t\treturn -EBUSY;\n\t}\n\tif (devm_request_irq(card->dev, irq, snd_ad1816a_interrupt, 0,\n\t\t\t     \"AD1816A\", (void *) chip)) {\n\t\tsnd_printk(KERN_ERR \"ad1816a: can't grab IRQ %d\\n\", irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\tif (snd_devm_request_dma(card->dev, dma1, \"AD1816A - 1\")) {\n\t\tsnd_printk(KERN_ERR \"ad1816a: can't grab DMA1 %d\\n\", dma1);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma1 = dma1;\n\tif (snd_devm_request_dma(card->dev, dma2, \"AD1816A - 2\")) {\n\t\tsnd_printk(KERN_ERR \"ad1816a: can't grab DMA2 %d\\n\", dma2);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma2 = dma2;\n\n\tchip->card = card;\n\tchip->port = port;\n\tspin_lock_init(&chip->lock);\n\n\terror = snd_ad1816a_probe(chip);\n\tif (error)\n\t\treturn error;\n\n\tsnd_ad1816a_init(chip);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ad1816a_playback_ops = {\n\t.open =\t\tsnd_ad1816a_playback_open,\n\t.close =\tsnd_ad1816a_playback_close,\n\t.prepare =\tsnd_ad1816a_playback_prepare,\n\t.trigger =\tsnd_ad1816a_playback_trigger,\n\t.pointer =\tsnd_ad1816a_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ad1816a_capture_ops = {\n\t.open =\t\tsnd_ad1816a_capture_open,\n\t.close =\tsnd_ad1816a_capture_close,\n\t.prepare =\tsnd_ad1816a_capture_prepare,\n\t.trigger =\tsnd_ad1816a_capture_trigger,\n\t.pointer =\tsnd_ad1816a_capture_pointer,\n};\n\nint snd_ad1816a_pcm(struct snd_ad1816a *chip, int device)\n{\n\tint error;\n\tstruct snd_pcm *pcm;\n\n\terror = snd_pcm_new(chip->card, \"AD1816A\", device, 1, 1, &pcm);\n\tif (error)\n\t\treturn error;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ad1816a_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ad1816a_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = (chip->dma1 == chip->dma2 ) ? SNDRV_PCM_INFO_JOINT_DUPLEX : 0;\n\n\tstrcpy(pcm->name, snd_ad1816a_chip_id(chip));\n\tsnd_ad1816a_init(chip);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, chip->card->dev,\n\t\t\t\t       64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\n\n\tchip->pcm = pcm;\n\treturn 0;\n}\n\nint snd_ad1816a_timer(struct snd_ad1816a *chip, int device)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_id tid;\n\tint error;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = chip->card->number;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\terror = snd_timer_new(chip->card, \"AD1816A\", &tid, &timer);\n\tif (error < 0)\n\t\treturn error;\n\tstrcpy(timer->name, snd_ad1816a_chip_id(chip));\n\ttimer->private_data = chip;\n\tchip->timer = timer;\n\ttimer->hw = snd_ad1816a_timer_table;\n\treturn 0;\n}\n\n \n\nstatic int snd_ad1816a_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[8] = {\n\t\t\"Line\", \"Mix\", \"CD\", \"Synth\", \"Video\",\n\t\t\"Mic\", \"Phone\",\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 2, 7, texts);\n}\n\nstatic int snd_ad1816a_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned short val;\n\t\n\tspin_lock_irqsave(&chip->lock, flags);\n\tval = snd_ad1816a_read(chip, AD1816A_ADC_SOURCE_SEL);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tucontrol->value.enumerated.item[0] = (val >> 12) & 7;\n\tucontrol->value.enumerated.item[1] = (val >> 4) & 7;\n\treturn 0;\n}\n\nstatic int snd_ad1816a_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned short val;\n\tint change;\n\t\n\tif (ucontrol->value.enumerated.item[0] > 6 ||\n\t    ucontrol->value.enumerated.item[1] > 6)\n\t\treturn -EINVAL;\n\tval = (ucontrol->value.enumerated.item[0] << 12) |\n\t      (ucontrol->value.enumerated.item[1] << 4);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tchange = snd_ad1816a_read(chip, AD1816A_ADC_SOURCE_SEL) != val;\n\tsnd_ad1816a_write(chip, AD1816A_ADC_SOURCE_SEL, val);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn change;\n}\n\n#define AD1816A_SINGLE_TLV(xname, reg, shift, mask, invert, xtlv)\t\\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .info = snd_ad1816a_info_single, \\\n  .get = snd_ad1816a_get_single, .put = snd_ad1816a_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = (xtlv) } }\n#define AD1816A_SINGLE(xname, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ad1816a_info_single, \\\n  .get = snd_ad1816a_get_single, .put = snd_ad1816a_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_ad1816a_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_ad1816a_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\t\n\tspin_lock_irqsave(&chip->lock, flags);\n\tucontrol->value.integer.value[0] = (snd_ad1816a_read(chip, reg) >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_ad1816a_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short old_val, val;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irqsave(&chip->lock, flags);\n\told_val = snd_ad1816a_read(chip, reg);\n\tval = (old_val & ~(mask << shift)) | val;\n\tchange = val != old_val;\n\tsnd_ad1816a_write(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn change;\n}\n\n#define AD1816A_DOUBLE_TLV(xname, reg, shift_left, shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .info = snd_ad1816a_info_double,\t\t\\\n  .get = snd_ad1816a_get_double, .put = snd_ad1816a_put_double, \\\n  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = (xtlv) } }\n\n#define AD1816A_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ad1816a_info_double, \\\n  .get = snd_ad1816a_get_double, .put = snd_ad1816a_put_double, \\\n  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }\n\nstatic int snd_ad1816a_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_ad1816a_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift_left = (kcontrol->private_value >> 8) & 0x0f;\n\tint shift_right = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned short val;\n\t\n\tspin_lock_irqsave(&chip->lock, flags);\n\tval = snd_ad1816a_read(chip, reg);\n\tucontrol->value.integer.value[0] = (val >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (val >> shift_right) & mask;\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_ad1816a_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ad1816a *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift_left = (kcontrol->private_value >> 8) & 0x0f;\n\tint shift_right = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short old_val, val1, val2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->lock, flags);\n\told_val = snd_ad1816a_read(chip, reg);\n\tval1 = (old_val & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\n\tchange = val1 != old_val;\n\tsnd_ad1816a_write(chip, reg, val1);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_ad1816a_controls[] = {\nAD1816A_DOUBLE(\"Master Playback Switch\", AD1816A_MASTER_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"Master Playback Volume\", AD1816A_MASTER_ATT, 8, 0, 31, 1,\n\t\t   db_scale_5bit),\nAD1816A_DOUBLE(\"PCM Playback Switch\", AD1816A_VOICE_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"PCM Playback Volume\", AD1816A_VOICE_ATT, 8, 0, 63, 1,\n\t\t   db_scale_6bit),\nAD1816A_DOUBLE(\"Line Playback Switch\", AD1816A_LINE_GAIN_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"Line Playback Volume\", AD1816A_LINE_GAIN_ATT, 8, 0, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nAD1816A_DOUBLE(\"CD Playback Switch\", AD1816A_CD_GAIN_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"CD Playback Volume\", AD1816A_CD_GAIN_ATT, 8, 0, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nAD1816A_DOUBLE(\"Synth Playback Switch\", AD1816A_SYNTH_GAIN_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"Synth Playback Volume\", AD1816A_SYNTH_GAIN_ATT, 8, 0, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nAD1816A_DOUBLE(\"FM Playback Switch\", AD1816A_FM_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"FM Playback Volume\", AD1816A_FM_ATT, 8, 0, 63, 1,\n\t\t   db_scale_6bit),\nAD1816A_SINGLE(\"Mic Playback Switch\", AD1816A_MIC_GAIN_ATT, 15, 1, 1),\nAD1816A_SINGLE_TLV(\"Mic Playback Volume\", AD1816A_MIC_GAIN_ATT, 8, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nAD1816A_SINGLE(\"Mic Boost\", AD1816A_MIC_GAIN_ATT, 14, 1, 0),\nAD1816A_DOUBLE(\"Video Playback Switch\", AD1816A_VID_GAIN_ATT, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"Video Playback Volume\", AD1816A_VID_GAIN_ATT, 8, 0, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nAD1816A_SINGLE(\"Phone Capture Switch\", AD1816A_PHONE_IN_GAIN_ATT, 15, 1, 1),\nAD1816A_SINGLE_TLV(\"Phone Capture Volume\", AD1816A_PHONE_IN_GAIN_ATT, 0, 15, 1,\n\t\t   db_scale_4bit),\nAD1816A_SINGLE(\"Phone Playback Switch\", AD1816A_PHONE_OUT_ATT, 7, 1, 1),\nAD1816A_SINGLE_TLV(\"Phone Playback Volume\", AD1816A_PHONE_OUT_ATT, 0, 31, 1,\n\t\t   db_scale_5bit),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_ad1816a_info_mux,\n\t.get = snd_ad1816a_get_mux,\n\t.put = snd_ad1816a_put_mux,\n},\nAD1816A_DOUBLE(\"Capture Switch\", AD1816A_ADC_PGA, 15, 7, 1, 1),\nAD1816A_DOUBLE_TLV(\"Capture Volume\", AD1816A_ADC_PGA, 8, 0, 15, 0,\n\t\t   db_scale_rec_gain),\nAD1816A_SINGLE(\"3D Control - Switch\", AD1816A_3D_PHAT_CTRL, 15, 1, 1),\nAD1816A_SINGLE(\"3D Control - Level\", AD1816A_3D_PHAT_CTRL, 0, 15, 0),\n};\n                                        \nint snd_ad1816a_mixer(struct snd_ad1816a *chip)\n{\n\tstruct snd_card *card;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!chip || !chip->card))\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, snd_ad1816a_chip_id(chip));\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_ad1816a_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ad1816a_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}