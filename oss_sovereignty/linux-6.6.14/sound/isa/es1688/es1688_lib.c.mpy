{
  "module_name": "es1688_lib.c",
  "hash_id": "0d42d741b8d0fe39c61d971a7ed072fda1d457be3e4a8ee3019c21398b14a1e9",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/es1688/es1688_lib.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/es1688.h>\n#include <sound/initval.h>\n\n#include <asm/dma.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ESS ESx688 lowlevel module\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int snd_es1688_dsp_command(struct snd_es1688 *chip, unsigned char val)\n{\n\tint i;\n\n\tfor (i = 10000; i; i--)\n\t\tif ((inb(ES1688P(chip, STATUS)) & 0x80) == 0) {\n\t\t\toutb(val, ES1688P(chip, COMMAND));\n\t\t\treturn 1;\n\t\t}\n#ifdef CONFIG_SND_DEBUG\n\tprintk(KERN_DEBUG \"snd_es1688_dsp_command: timeout (0x%x)\\n\", val);\n#endif\n\treturn 0;\n}\n\nstatic int snd_es1688_dsp_get_byte(struct snd_es1688 *chip)\n{\n\tint i;\n\n\tfor (i = 1000; i; i--)\n\t\tif (inb(ES1688P(chip, DATA_AVAIL)) & 0x80)\n\t\t\treturn inb(ES1688P(chip, READ));\n\tsnd_printd(\"es1688 get byte failed: 0x%lx = 0x%x!!!\\n\", ES1688P(chip, DATA_AVAIL), inb(ES1688P(chip, DATA_AVAIL)));\n\treturn -ENODEV;\n}\n\nstatic int snd_es1688_write(struct snd_es1688 *chip,\n\t\t\t    unsigned char reg, unsigned char data)\n{\n\tif (!snd_es1688_dsp_command(chip, reg))\n\t\treturn 0;\n\treturn snd_es1688_dsp_command(chip, data);\n}\n\nstatic int snd_es1688_read(struct snd_es1688 *chip, unsigned char reg)\n{\n\t \n\tif (!snd_es1688_dsp_command(chip, 0xc0))\n\t\treturn -1;\n\tif (!snd_es1688_dsp_command(chip, reg))\n\t\treturn -1;\n\treturn snd_es1688_dsp_get_byte(chip);\n}\n\nvoid snd_es1688_mixer_write(struct snd_es1688 *chip,\n\t\t\t    unsigned char reg, unsigned char data)\n{\n\toutb(reg, ES1688P(chip, MIXER_ADDR));\n\tudelay(10);\n\toutb(data, ES1688P(chip, MIXER_DATA));\n\tudelay(10);\n}\n\nstatic unsigned char snd_es1688_mixer_read(struct snd_es1688 *chip, unsigned char reg)\n{\n\tunsigned char result;\n\n\toutb(reg, ES1688P(chip, MIXER_ADDR));\n\tudelay(10);\n\tresult = inb(ES1688P(chip, MIXER_DATA));\n\tudelay(10);\n\treturn result;\n}\n\nint snd_es1688_reset(struct snd_es1688 *chip)\n{\n\tint i;\n\n\toutb(3, ES1688P(chip, RESET));\t\t \n\tudelay(10);\n\toutb(0, ES1688P(chip, RESET));\n\tudelay(30);\n\tfor (i = 0; i < 1000 && !(inb(ES1688P(chip, DATA_AVAIL)) & 0x80); i++);\n\tif (inb(ES1688P(chip, READ)) != 0xaa) {\n\t\tsnd_printd(\"ess_reset at 0x%lx: failed!!!\\n\", chip->port);\n\t\treturn -ENODEV;\n\t}\n\tsnd_es1688_dsp_command(chip, 0xc6);\t \n\treturn 0;\n}\nEXPORT_SYMBOL(snd_es1688_reset);\n\nstatic int snd_es1688_probe(struct snd_es1688 *chip)\n{\n\tunsigned long flags;\n\tunsigned short major, minor;\n\tint i;\n\n\t \n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE2));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE2));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE2));\t \n\tinb(ES1688P(chip, ENABLE1));\t \n\tinb(ES1688P(chip, ENABLE0));\t \n\n\tif (snd_es1688_reset(chip) < 0) {\n\t\tsnd_printdd(\"ESS: [0x%lx] reset failed... 0x%x\\n\", chip->port, inb(ES1688P(chip, READ)));\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tsnd_es1688_dsp_command(chip, 0xe7);\t \n\n\tfor (i = 1000, major = minor = 0; i; i--) {\n\t\tif (inb(ES1688P(chip, DATA_AVAIL)) & 0x80) {\n\t\t\tif (major == 0) {\n\t\t\t\tmajor = inb(ES1688P(chip, READ));\n\t\t\t} else {\n\t\t\t\tminor = inb(ES1688P(chip, READ));\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tsnd_printdd(\"ESS: [0x%lx] found.. major = 0x%x, minor = 0x%x\\n\", chip->port, major, minor);\n\n\tchip->version = (major << 8) | minor;\n\tif (!chip->version)\n\t\treturn -ENODEV;\t \n\n\tswitch (chip->version & 0xfff0) {\n\tcase 0x4880:\n\t\tsnd_printk(KERN_ERR \"[0x%lx] ESS: AudioDrive ES488 detected, \"\n\t\t\t   \"but driver is in another place\\n\", chip->port);\n\t\treturn -ENODEV;\n\tcase 0x6880:\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"[0x%lx] ESS: unknown AudioDrive chip \"\n\t\t\t   \"with version 0x%x (Jazz16 soundcard?)\\n\",\n\t\t\t   chip->port, chip->version);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_write(chip, 0xb1, 0x10);\t \n\tsnd_es1688_write(chip, 0xb2, 0x00);\t \n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\t \n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\tsnd_es1688_mixer_write(chip, 0x40, 0x01);\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\n\treturn 0;\n}\n\nstatic int snd_es1688_init(struct snd_es1688 * chip, int enable)\n{\n\tstatic const int irqs[16] = {-1, -1, 0, -1, -1, 1, -1, 2, -1, 0, 3, -1, -1, -1, -1, -1};\n\tunsigned long flags;\n\tint cfg, irq_bits, dma, dma_bits, tmp, tmp1;\n\n\t \n\tcfg = 0x01;\t\t \n\tif (enable && chip->mpu_port >= 0x300 && chip->mpu_irq > 0 && chip->hardware != ES1688_HW_688) {\n\t\ttmp = (chip->mpu_port & 0x0f0) >> 4;\n\t\tif (tmp <= 3) {\n\t\t\tswitch (chip->mpu_irq) {\n\t\t\tcase 9:\n\t\t\t\ttmp1 = 4;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\ttmp1 = 5;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\ttmp1 = 6;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\ttmp1 = 7;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp1 = 0;\n\t\t\t}\n\t\t\tif (tmp1) {\n\t\t\t\tcfg |= (tmp << 3) | (tmp1 << 5);\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\tsnd_printk(KERN_DEBUG \"mpu cfg = 0x%x\\n\", cfg);\n#endif\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_mixer_write(chip, 0x40, cfg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_read(chip, 0xb1);\n\tsnd_es1688_read(chip, 0xb2);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (enable) {\n\t\tcfg = 0xf0;\t \n\t\tirq_bits = irqs[chip->irq & 0x0f];\n\t\tif (irq_bits < 0) {\n\t\t\tsnd_printk(KERN_ERR \"[0x%lx] ESS: bad IRQ %d \"\n\t\t\t\t   \"for ES1688 chip!!\\n\",\n\t\t\t\t   chip->port, chip->irq);\n#if 0\n\t\t\tirq_bits = 0;\n\t\t\tcfg = 0x10;\n#endif\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tsnd_es1688_write(chip, 0xb1, cfg | (irq_bits << 2));\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\tcfg = 0xf0;\t \n\t\tdma = chip->dma8;\n\t\tif (dma > 3 || dma == 2) {\n\t\t\tsnd_printk(KERN_ERR \"[0x%lx] ESS: bad DMA channel %d \"\n\t\t\t\t   \"for ES1688 chip!!\\n\", chip->port, dma);\n#if 0\n\t\t\tdma_bits = 0;\n\t\t\tcfg = 0x00;\t \n#endif\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tdma_bits = dma;\n\t\t\tif (dma != 3)\n\t\t\t\tdma_bits++;\n\t\t}\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tsnd_es1688_write(chip, 0xb2, cfg | (dma_bits << 2));\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t} else {\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tsnd_es1688_write(chip, 0xb1, 0x10);\t \n\t\tsnd_es1688_write(chip, 0xb2, 0x00);\t \n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t}\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_read(chip, 0xb1);\n\tsnd_es1688_read(chip, 0xb2);\n\tsnd_es1688_reset(chip);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic const struct snd_ratnum clocks[2] = {\n\t{\n\t\t.num = 795444,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t},\n\t{\n\t\t.num = 397722,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t}\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums hw_constraints_clocks  = {\n\t.nrats = 2,\n\t.rats = clocks,\n};\n\nstatic void snd_es1688_set_rate(struct snd_es1688 *chip, struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int bits, divider;\n\n\tif (runtime->rate_num == clocks[0].num)\n\t\tbits = 256 - runtime->rate_den;\n\telse\n\t\tbits = 128 - runtime->rate_den;\n\t \n\tdivider = 256 - 7160000*20/(8*82*runtime->rate);\n\t \n\tsnd_es1688_write(chip, 0xa1, bits);\n\tsnd_es1688_write(chip, 0xa2, divider);\n}\n\nstatic int snd_es1688_trigger(struct snd_es1688 *chip, int cmd, unsigned char value)\n{\n\tint val;\n\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tvalue = 0x00;\n\t} else if (cmd != SNDRV_PCM_TRIGGER_START) {\n\t\treturn -EINVAL;\n\t}\n\tspin_lock(&chip->reg_lock);\n\tchip->trigger_value = value;\n\tval = snd_es1688_read(chip, 0xb8);\n\tif ((val < 0) || (val & 0x0f) == value) {\n\t\tspin_unlock(&chip->reg_lock);\n\t\treturn -EINVAL;\t \n\t}\n#if 0\n\tprintk(KERN_DEBUG \"trigger: val = 0x%x, value = 0x%x\\n\", val, value);\n\tprintk(KERN_DEBUG \"trigger: pointer = 0x%x\\n\",\n\t       snd_dma_pointer(chip->dma8, chip->dma_size));\n#endif\n\tsnd_es1688_write(chip, 0xb8, (val & 0xf0) | value);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_es1688_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tchip->dma_size = size;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_reset(chip);\n\tsnd_es1688_set_rate(chip, substream);\n\tsnd_es1688_write(chip, 0xb8, 4);\t \n\tsnd_es1688_write(chip, 0xa8, (snd_es1688_read(chip, 0xa8) & ~0x03) | (3 - runtime->channels));\n\tsnd_es1688_write(chip, 0xb9, 2);\t \n\tif (runtime->channels == 1) {\n\t\tif (snd_pcm_format_width(runtime->format) == 8) {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb6, 0x80);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x51);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xd0);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb6, 0x00);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x71);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xf4);\n\t\t}\n\t} else {\n\t\tif (snd_pcm_format_width(runtime->format) == 8) {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb6, 0x80);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x51);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x98);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb6, 0x00);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x71);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xbc);\n\t\t}\n\t}\n\tsnd_es1688_write(chip, 0xb1, (snd_es1688_read(chip, 0xb1) & 0x0f) | 0x50);\n\tsnd_es1688_write(chip, 0xb2, (snd_es1688_read(chip, 0xb2) & 0x0f) | 0x50);\n\tsnd_es1688_dsp_command(chip, ES1688_DSP_CMD_SPKON);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t \n\tcount = -count;\n\tsnd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_write(chip, 0xa4, (unsigned char) count);\n\tsnd_es1688_write(chip, 0xa5, (unsigned char) (count >> 8));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_es1688_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\treturn snd_es1688_trigger(chip, cmd, 0x05);\n}\n\nstatic int snd_es1688_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tchip->dma_size = size;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_reset(chip);\n\tsnd_es1688_set_rate(chip, substream);\n\tsnd_es1688_dsp_command(chip, ES1688_DSP_CMD_SPKOFF);\n\tsnd_es1688_write(chip, 0xb8, 0x0e);\t \n\tsnd_es1688_write(chip, 0xa8, (snd_es1688_read(chip, 0xa8) & ~0x03) | (3 - runtime->channels));\n\tsnd_es1688_write(chip, 0xb9, 2);\t \n\tif (runtime->channels == 1) {\n\t\tif (snd_pcm_format_width(runtime->format) == 8) {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb7, 0x51);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xd0);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb7, 0x71);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xf4);\n\t\t}\n\t} else {\n\t\tif (snd_pcm_format_width(runtime->format) == 8) {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb7, 0x51);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0x98);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_es1688_write(chip, 0xb7, 0x71);\n\t\t\tsnd_es1688_write(chip, 0xb7, 0xbc);\n\t\t}\n\t}\n\tsnd_es1688_write(chip, 0xb1, (snd_es1688_read(chip, 0xb1) & 0x0f) | 0x50);\n\tsnd_es1688_write(chip, 0xb2, (snd_es1688_read(chip, 0xb2) & 0x0f) | 0x50);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t \n\tcount = -count;\n\tsnd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1688_write(chip, 0xa4, (unsigned char) count);\n\tsnd_es1688_write(chip, 0xa5, (unsigned char) (count >> 8));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_es1688_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\treturn snd_es1688_trigger(chip, cmd, 0x0f);\n}\n\nstatic irqreturn_t snd_es1688_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_es1688 *chip = dev_id;\n\n\tif (chip->trigger_value == 0x05)\t \n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\tif (chip->trigger_value == 0x0f)\t \n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\n\tinb(ES1688P(chip, DATA_AVAIL));\t \n\treturn IRQ_HANDLED;\n}\n\nstatic snd_pcm_uframes_t snd_es1688_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\t\n\tif (chip->trigger_value != 0x05)\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma8, chip->dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_es1688_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\t\n\tif (chip->trigger_value != 0x0f)\n\t\treturn 0;\n\tptr = snd_dma_pointer(chip->dma8, chip->dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_es1688_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_es1688_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic int snd_es1688_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (chip->capture_substream != NULL)\n\t\treturn -EAGAIN;\n\tchip->playback_substream = substream;\n\truntime->hw = snd_es1688_playback;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clocks);\n\treturn 0;\n}\n\nstatic int snd_es1688_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (chip->playback_substream != NULL)\n\t\treturn -EAGAIN;\n\tchip->capture_substream = substream;\n\truntime->hw = snd_es1688_capture;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clocks);\n\treturn 0;\n}\n\nstatic int snd_es1688_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_es1688_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_es1688_free(struct snd_es1688 *chip)\n{\n\tif (chip->hardware != ES1688_HW_UNDEF)\n\t\tsnd_es1688_init(chip, 0);\n\trelease_and_free_resource(chip->res_port);\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, (void *) chip);\n\tif (chip->dma8 >= 0) {\n\t\tdisable_dma(chip->dma8);\n\t\tfree_dma(chip->dma8);\n\t}\n\treturn 0;\n}\n\nstatic int snd_es1688_dev_free(struct snd_device *device)\n{\n\tstruct snd_es1688 *chip = device->device_data;\n\treturn snd_es1688_free(chip);\n}\n\nstatic const char *snd_es1688_chip_id(struct snd_es1688 *chip)\n{\n\tstatic char tmp[16];\n\tsprintf(tmp, \"ES%s688 rev %i\", chip->hardware == ES1688_HW_688 ? \"\" : \"1\", chip->version & 0x0f);\n\treturn tmp;\n}\n\nint snd_es1688_create(struct snd_card *card,\n\t\t      struct snd_es1688 *chip,\n\t\t      unsigned long port,\n\t\t      unsigned long mpu_port,\n\t\t      int irq,\n\t\t      int mpu_irq,\n\t\t      int dma8,\n\t\t      unsigned short hardware)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_es1688_dev_free,\n\t};\n                                \n\tint err;\n\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tchip->irq = -1;\n\tchip->dma8 = -1;\n\tchip->hardware = ES1688_HW_UNDEF;\n\t\n\tchip->res_port = request_region(port + 4, 12, \"ES1688\");\n\tif (chip->res_port == NULL) {\n\t\tsnd_printk(KERN_ERR \"es1688: can't grab port 0x%lx\\n\", port + 4);\n\t\terr = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\terr = request_irq(irq, snd_es1688_interrupt, 0, \"ES1688\", (void *) chip);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"es1688: can't grab IRQ %d\\n\", irq);\n\t\tgoto exit;\n\t}\n\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\terr = request_dma(dma8, \"ES1688\");\n\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"es1688: can't grab DMA8 %d\\n\", dma8);\n\t\tgoto exit;\n\t}\n\tchip->dma8 = dma8;\n\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->mixer_lock);\n\tchip->port = port;\n\tmpu_port &= ~0x000f;\n\tif (mpu_port < 0x300 || mpu_port > 0x330)\n\t\tmpu_port = 0;\n\tchip->mpu_port = mpu_port;\n\tchip->mpu_irq = mpu_irq;\n\tchip->hardware = hardware;\n\n\terr = snd_es1688_probe(chip);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = snd_es1688_init(chip, 1);\n\tif (err < 0)\n\t\tgoto exit;\n\n\t \n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\nexit:\n\tif (err)\n\t\tsnd_es1688_free(chip);\n\treturn err;\n}\n\nstatic const struct snd_pcm_ops snd_es1688_playback_ops = {\n\t.open =\t\t\tsnd_es1688_playback_open,\n\t.close =\t\tsnd_es1688_playback_close,\n\t.prepare =\t\tsnd_es1688_playback_prepare,\n\t.trigger =\t\tsnd_es1688_playback_trigger,\n\t.pointer =\t\tsnd_es1688_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_es1688_capture_ops = {\n\t.open =\t\t\tsnd_es1688_capture_open,\n\t.close =\t\tsnd_es1688_capture_close,\n\t.prepare =\t\tsnd_es1688_capture_prepare,\n\t.trigger =\t\tsnd_es1688_capture_trigger,\n\t.pointer =\t\tsnd_es1688_capture_pointer,\n};\n\nint snd_es1688_pcm(struct snd_card *card, struct snd_es1688 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, \"ESx688\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1688_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1688_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\tstrcpy(pcm->name, snd_es1688_chip_id(chip));\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t       64*1024, 64*1024);\n\treturn 0;\n}\n\n \n\nstatic int snd_es1688_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[8] = {\n\t\t\"Mic\", \"Mic Master\", \"CD\", \"AOUT\",\n\t\t\"Mic1\", \"Mix\", \"Line\", \"Master\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 8, texts);\n}\n\nstatic int snd_es1688_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = snd_es1688_mixer_read(chip, ES1688_REC_DEV) & 7;\n\treturn 0;\n}\n\nstatic int snd_es1688_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned char oval, nval;\n\tint change;\n\t\n\tif (ucontrol->value.enumerated.item[0] > 8)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toval = snd_es1688_mixer_read(chip, ES1688_REC_DEV);\n\tnval = (ucontrol->value.enumerated.item[0] & 7) | (oval & ~15);\n\tchange = nval != oval;\n\tif (change)\n\t\tsnd_es1688_mixer_write(chip, ES1688_REC_DEV, nval);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define ES1688_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es1688_info_single, \\\n  .get = snd_es1688_get_single, .put = snd_es1688_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_es1688_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es1688_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (snd_es1688_mixer_read(chip, reg) >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_es1688_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned char oval, nval;\n\t\n\tnval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tnval = mask - nval;\n\tnval <<= shift;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toval = snd_es1688_mixer_read(chip, reg);\n\tnval = (oval & ~(mask << shift)) | nval;\n\tchange = nval != oval;\n\tif (change)\n\t\tsnd_es1688_mixer_write(chip, reg, nval);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define ES1688_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es1688_info_double, \\\n  .get = snd_es1688_get_double, .put = snd_es1688_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\nstatic int snd_es1688_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es1688_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tunsigned char left, right;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (left_reg < 0xa0)\n\t\tleft = snd_es1688_mixer_read(chip, left_reg);\n\telse\n\t\tleft = snd_es1688_read(chip, left_reg);\n\tif (left_reg != right_reg) {\n\t\tif (right_reg < 0xa0) \n\t\t\tright = snd_es1688_mixer_read(chip, right_reg);\n\t\telse\n\t\t\tright = snd_es1688_read(chip, right_reg);\n\t} else\n\t\tright = left;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (left >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (right >> shift_right) & mask;\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_es1688_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned char val1, val2, oval1, oval2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (left_reg != right_reg) {\n\t\tif (left_reg < 0xa0)\n\t\t\toval1 = snd_es1688_mixer_read(chip, left_reg);\n\t\telse\n\t\t\toval1 = snd_es1688_read(chip, left_reg);\n\t\tif (right_reg < 0xa0)\n\t\t\toval2 = snd_es1688_mixer_read(chip, right_reg);\n\t\telse\n\t\t\toval2 = snd_es1688_read(chip, right_reg);\n\t\tval1 = (oval1 & ~(mask << shift_left)) | val1;\n\t\tval2 = (oval2 & ~(mask << shift_right)) | val2;\n\t\tchange = val1 != oval1 || val2 != oval2;\n\t\tif (change) {\n\t\t\tif (left_reg < 0xa0)\n\t\t\t\tsnd_es1688_mixer_write(chip, left_reg, val1);\n\t\t\telse\n\t\t\t\tsnd_es1688_write(chip, left_reg, val1);\n\t\t\tif (right_reg < 0xa0)\n\t\t\t\tsnd_es1688_mixer_write(chip, right_reg, val1);\n\t\t\telse\n\t\t\t\tsnd_es1688_write(chip, right_reg, val1);\n\t\t}\n\t} else {\n\t\tif (left_reg < 0xa0)\n\t\t\toval1 = snd_es1688_mixer_read(chip, left_reg);\n\t\telse\n\t\t\toval1 = snd_es1688_read(chip, left_reg);\n\t\tval1 = (oval1 & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\n\t\tchange = val1 != oval1;\n\t\tif (change) {\n\t\t\tif (left_reg < 0xa0)\n\t\t\t\tsnd_es1688_mixer_write(chip, left_reg, val1);\n\t\t\telse\n\t\t\t\tsnd_es1688_write(chip, left_reg, val1);\n\t\t}\n\t\t\t\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_es1688_controls[] = {\nES1688_DOUBLE(\"Master Playback Volume\", 0, ES1688_MASTER_DEV, ES1688_MASTER_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"PCM Playback Volume\", 0, ES1688_PCM_DEV, ES1688_PCM_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"Line Playback Volume\", 0, ES1688_LINE_DEV, ES1688_LINE_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"CD Playback Volume\", 0, ES1688_CD_DEV, ES1688_CD_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"FM Playback Volume\", 0, ES1688_FM_DEV, ES1688_FM_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"Mic Playback Volume\", 0, ES1688_MIC_DEV, ES1688_MIC_DEV, 4, 0, 15, 0),\nES1688_DOUBLE(\"Aux Playback Volume\", 0, ES1688_AUX_DEV, ES1688_AUX_DEV, 4, 0, 15, 0),\nES1688_SINGLE(\"Beep Playback Volume\", 0, ES1688_SPEAKER_DEV, 0, 7, 0),\nES1688_DOUBLE(\"Capture Volume\", 0, ES1688_RECLEV_DEV, ES1688_RECLEV_DEV, 4, 0, 15, 0),\nES1688_SINGLE(\"Capture Switch\", 0, ES1688_REC_DEV, 4, 1, 1),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_es1688_info_mux,\n\t.get = snd_es1688_get_mux,\n\t.put = snd_es1688_put_mux,\n},\n};\n\n#define ES1688_INIT_TABLE_SIZE (sizeof(snd_es1688_init_table)/2)\n\nstatic const unsigned char snd_es1688_init_table[][2] = {\n\t{ ES1688_MASTER_DEV, 0 },\n\t{ ES1688_PCM_DEV, 0 },\n\t{ ES1688_LINE_DEV, 0 },\n\t{ ES1688_CD_DEV, 0 },\n\t{ ES1688_FM_DEV, 0 },\n\t{ ES1688_MIC_DEV, 0 },\n\t{ ES1688_AUX_DEV, 0 },\n\t{ ES1688_SPEAKER_DEV, 0 },\n\t{ ES1688_RECLEV_DEV, 0 },\n\t{ ES1688_REC_DEV, 0x17 }\n};\n                                        \nint snd_es1688_mixer(struct snd_card *card, struct snd_es1688 *chip)\n{\n\tunsigned int idx;\n\tint err;\n\tunsigned char reg, val;\n\n\tif (snd_BUG_ON(!chip || !card))\n\t\treturn -EINVAL;\n\n\tstrcpy(card->mixername, snd_es1688_chip_id(chip));\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_es1688_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es1688_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (idx = 0; idx < ES1688_INIT_TABLE_SIZE; idx++) {\n\t\treg = snd_es1688_init_table[idx][0];\n\t\tval = snd_es1688_init_table[idx][1];\n\t\tif (reg < 0xa0)\n\t\t\tsnd_es1688_mixer_write(chip, reg, val);\n\t\telse\n\t\t\tsnd_es1688_write(chip, reg, val);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_es1688_mixer_write);\nEXPORT_SYMBOL(snd_es1688_create);\nEXPORT_SYMBOL(snd_es1688_pcm);\nEXPORT_SYMBOL(snd_es1688_mixer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}