{
  "module_name": "es1688.c",
  "hash_id": "d3b1e722267fd5778330cc98a2e174932108cd5cb192c40b28a5b2ed8dfca064",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/es1688/es1688.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/isapnp.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/es1688.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\n#define CRD_NAME \"Generic ESS ES1688/ES688 AudioDrive\"\n#define DEV_NAME \"es1688\"\n\nMODULE_DESCRIPTION(CRD_NAME);\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"snd_es968\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;\n#endif\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CRD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CRD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"PnP detection for specified soundcard.\");\n#endif\nMODULE_PARM_DESC(enable, \"Enable \" CRD_NAME \" soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for ES1688 driver.\");\nMODULE_PARM_DESC(irq, \"IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma8, \"8-bit DMA # for \" CRD_NAME \" driver.\");\n\n#ifdef CONFIG_PNP\n#define is_isapnp_selected(dev)\t\tisapnp[dev]\n#else\n#define is_isapnp_selected(dev)\t\t0\n#endif\n\nstatic int snd_es1688_match(struct device *dev, unsigned int n)\n{\n\treturn enable[n] && !is_isapnp_selected(n);\n}\n\nstatic int snd_es1688_legacy_create(struct snd_card *card,\n\t\t\t\t    struct device *dev, unsigned int n)\n{\n\tstruct snd_es1688 *chip = card->private_data;\n\tstatic const long possible_ports[] = {0x220, 0x240, 0x260};\n\tstatic const int possible_irqs[] = {5, 9, 10, 7, -1};\n\tstatic const int possible_dmas[] = {1, 3, 0, -1};\n\n\tint i, error;\n\n\tif (irq[n] == SNDRV_AUTO_IRQ) {\n\t\tirq[n] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma8[n] == SNDRV_AUTO_DMA) {\n\t\tdma8[n] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma8[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free DMA\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (port[n] != SNDRV_AUTO_PORT)\n\t\treturn snd_es1688_create(card, chip, port[n], mpu_port[n],\n\t\t\t\tirq[n], mpu_irq[n], dma8[n], ES1688_HW_AUTO);\n\n\ti = 0;\n\tdo {\n\t\tport[n] = possible_ports[i];\n\t\terror = snd_es1688_create(card, chip, port[n], mpu_port[n],\n\t\t\t\tirq[n], mpu_irq[n], dma8[n], ES1688_HW_AUTO);\n\t} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));\n\n\treturn error;\n}\n\nstatic int snd_es1688_probe(struct snd_card *card, unsigned int n)\n{\n\tstruct snd_es1688 *chip = card->private_data;\n\tstruct snd_opl3 *opl3;\n\tint error;\n\n\terror = snd_es1688_pcm(card, chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_es1688_mixer(card, chip);\n\tif (error < 0)\n\t\treturn error;\n\n\tstrscpy(card->driver, \"ES1688\", sizeof(card->driver));\n\tstrscpy(card->shortname, chip->pcm->name, sizeof(card->shortname));\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s at 0x%lx, irq %i, dma %i\", chip->pcm->name, chip->port,\n\t\t  chip->irq, chip->dma8);\n\n\tif (fm_port[n] == SNDRV_AUTO_PORT)\n\t\tfm_port[n] = port[n];\t \n\n\tif (fm_port[n] > 0) {\n\t\tif (snd_opl3_create(card, fm_port[n], fm_port[n] + 2,\n\t\t\t\tOPL3_HW_OPL3, 0, &opl3) < 0)\n\t\t\tdev_warn(card->dev,\n\t\t\t\t \"opl3 not detected at 0x%lx\\n\", fm_port[n]);\n\t\telse {\n\t\t\terror =\tsnd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (mpu_irq[n] >= 0 && mpu_irq[n] != SNDRV_AUTO_IRQ &&\n\t\t\tchip->mpu_port > 0) {\n\t\terror = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,\n\t\t\t\tchip->mpu_port, 0,\n\t\t\t\tmpu_irq[n], NULL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn snd_card_register(card);\n}\n\nstatic int snd_es1688_isa_probe(struct device *dev, unsigned int n)\n{\n\tstruct snd_card *card;\n\tint error;\n\n\terror = snd_devm_card_new(dev, index[n], id[n], THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_es1688), &card);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_es1688_legacy_create(card, dev, n);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_es1688_probe(card, n);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_set_drvdata(dev, card);\n\n\treturn 0;\n}\n\nstatic struct isa_driver snd_es1688_driver = {\n\t.match\t\t= snd_es1688_match,\n\t.probe\t\t= snd_es1688_isa_probe,\n#if 0\t \n\t.suspend\t= snd_es1688_suspend,\n\t.resume\t\t= snd_es1688_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t}\n};\n\nstatic int snd_es968_pnp_is_probed;\n\n#ifdef CONFIG_PNP\nstatic int snd_card_es968_pnp(struct snd_card *card, unsigned int n,\n\t\t\t      struct pnp_card_link *pcard,\n\t\t\t      const struct pnp_card_device_id *pid)\n{\n\tstruct snd_es1688 *chip = card->private_data;\n\tstruct pnp_dev *pdev;\n\tint error;\n\n\tpdev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\terror = pnp_activate_dev(pdev);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"ES968 pnp configure failure\\n\");\n\t\treturn error;\n\t}\n\tport[n] = pnp_port_start(pdev, 0);\n\tdma8[n] = pnp_dma(pdev, 0);\n\tirq[n] = pnp_irq(pdev, 0);\n\n\treturn snd_es1688_create(card, chip, port[n], mpu_port[n], irq[n],\n\t\t\t\t mpu_irq[n], dma8[n], ES1688_HW_AUTO);\n}\n\nstatic int snd_es968_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t\tconst struct pnp_card_device_id *pid)\n{\n\tstruct snd_card *card;\n\tstatic unsigned int dev;\n\tint error;\n\n\tif (snd_es968_pnp_is_probed)\n\t\treturn -EBUSY;\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev == SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\terror = snd_devm_card_new(&pcard->card->dev,\n\t\t\t\t  index[dev], id[dev], THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_es1688), &card);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_card_es968_pnp(card, dev, pcard, pid);\n\tif (error < 0)\n\t\treturn error;\n\terror = snd_es1688_probe(card, dev);\n\tif (error < 0)\n\t\treturn error;\n\tpnp_set_card_drvdata(pcard, card);\n\tsnd_es968_pnp_is_probed = 1;\n\treturn 0;\n}\n\nstatic void snd_es968_pnp_remove(struct pnp_card_link *pcard)\n{\n\tsnd_es968_pnp_is_probed = 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_es968_pnp_suspend(struct pnp_card_link *pcard,\n\t\t\t\t pm_message_t state)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\treturn 0;\n}\n\nstatic int snd_es968_pnp_resume(struct pnp_card_link *pcard)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\tstruct snd_es1688 *chip = card->private_data;\n\n\tsnd_es1688_reset(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic const struct pnp_card_device_id snd_es968_pnpids[] = {\n\t{ .id = \"ESS0968\", .devs = { { \"@@@0968\" }, } },\n\t{ .id = \"ESS0968\", .devs = { { \"ESS0968\" }, } },\n\t{ .id = \"\", }  \n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_es968_pnpids);\n\nstatic struct pnp_card_driver es968_pnpc_driver = {\n\t.flags\t\t= PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= DEV_NAME \" PnP\",\n\t.id_table\t= snd_es968_pnpids,\n\t.probe\t\t= snd_es968_pnp_detect,\n\t.remove\t\t= snd_es968_pnp_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_es968_pnp_suspend,\n\t.resume\t\t= snd_es968_pnp_resume,\n#endif\n};\n#endif\n\nstatic int __init alsa_card_es1688_init(void)\n{\n#ifdef CONFIG_PNP\n\tpnp_register_card_driver(&es968_pnpc_driver);\n\tif (snd_es968_pnp_is_probed)\n\t\treturn 0;\n\tpnp_unregister_card_driver(&es968_pnpc_driver);\n#endif\n\treturn isa_register_driver(&snd_es1688_driver, SNDRV_CARDS);\n}\n\nstatic void __exit alsa_card_es1688_exit(void)\n{\n\tif (!snd_es968_pnp_is_probed) {\n\t\tisa_unregister_driver(&snd_es1688_driver);\n\t\treturn;\n\t}\n#ifdef CONFIG_PNP\n\tpnp_unregister_card_driver(&es968_pnpc_driver);\n#endif\n}\n\nmodule_init(alsa_card_es1688_init);\nmodule_exit(alsa_card_es1688_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}