{
  "module_name": "opti92x-ad1848.c",
  "hash_id": "0a8f43a03080d545ae11ac4094c094fdf58672ed3cbc3096daf29343e15e31f6",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/opti9xx/opti92x-ad1848.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#ifndef OPTi93X\n#include <sound/opl4.h>\n#endif\n#define SNDRV_LEGACY_FIND_FREE_IOPORT\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Massimo Piccioni <dafastidio@libero.it>\");\nMODULE_LICENSE(\"GPL\");\n#ifdef OPTi93X\nMODULE_DESCRIPTION(\"OPTi93X\");\n#else\t \n#ifdef CS4231\nMODULE_DESCRIPTION(\"OPTi92X - CS4231\");\n#else\t \nMODULE_DESCRIPTION(\"OPTi92X - AD1848\");\n#endif\t \n#endif\t \n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t\t \n\n#ifdef CONFIG_PNP\nstatic bool isapnp = true;\t\t\t \n#endif\nstatic long port = SNDRV_DEFAULT_PORT1; \t \nstatic long mpu_port = SNDRV_DEFAULT_PORT1;\t \nstatic long fm_port = SNDRV_DEFAULT_PORT1;\t \nstatic int irq = SNDRV_DEFAULT_IRQ1;\t\t \nstatic int mpu_irq = SNDRV_DEFAULT_IRQ1;\t \nstatic int dma1 = SNDRV_DEFAULT_DMA1;\t\t \n#if defined(CS4231) || defined(OPTi93X)\nstatic int dma2 = SNDRV_DEFAULT_DMA1;\t\t \n#endif\t \n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for opti9xx based soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for opti9xx based soundcard.\");\n\n\n#ifdef CONFIG_PNP\nmodule_param(isapnp, bool, 0444);\nMODULE_PARM_DESC(isapnp, \"Enable ISA PnP detection for specified soundcard.\");\n#endif\nmodule_param_hw(port, long, ioport, 0444);\nMODULE_PARM_DESC(port, \"WSS port # for opti9xx driver.\");\nmodule_param_hw(mpu_port, long, ioport, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for opti9xx driver.\");\nmodule_param_hw(fm_port, long, ioport, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for opti9xx driver.\");\nmodule_param_hw(irq, int, irq, 0444);\nMODULE_PARM_DESC(irq, \"WSS irq # for opti9xx driver.\");\nmodule_param_hw(mpu_irq, int, irq, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 irq # for opti9xx driver.\");\nmodule_param_hw(dma1, int, dma, 0444);\nMODULE_PARM_DESC(dma1, \"1st dma # for opti9xx driver.\");\n#if defined(CS4231) || defined(OPTi93X)\nmodule_param_hw(dma2, int, dma, 0444);\nMODULE_PARM_DESC(dma2, \"2nd dma # for opti9xx driver.\");\n#endif\t \n\n#define OPTi9XX_HW_82C928\t1\n#define OPTi9XX_HW_82C929\t2\n#define OPTi9XX_HW_82C924\t3\n#define OPTi9XX_HW_82C925\t4\n#define OPTi9XX_HW_82C930\t5\n#define OPTi9XX_HW_82C931\t6\n#define OPTi9XX_HW_82C933\t7\n#define OPTi9XX_HW_LAST\t\tOPTi9XX_HW_82C933\n\n#define OPTi9XX_MC_REG(n)\tn\n\n#ifdef OPTi93X\n\n#define OPTi93X_STATUS\t\t\t0x02\n#define OPTi93X_PORT(chip, r)\t\t((chip)->port + OPTi93X_##r)\n\n#define OPTi93X_IRQ_PLAYBACK\t\t0x04\n#define OPTi93X_IRQ_CAPTURE\t\t0x08\n\n#endif  \n\nstruct snd_opti9xx {\n\tunsigned short hardware;\n\tunsigned char password;\n\tchar name[7];\n\n\tunsigned long mc_base;\n\tstruct resource *res_mc_base;\n\tunsigned long mc_base_size;\n#ifdef OPTi93X\n\tunsigned long mc_indir_index;\n\tstruct resource *res_mc_indir;\n#endif\t \n\tstruct snd_wss *codec;\n\tunsigned long pwd_reg;\n\n\tspinlock_t lock;\n\n\tlong wss_base;\n\tint irq;\n};\n\nstatic int snd_opti9xx_pnp_is_probed;\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_card_device_id snd_opti9xx_pnpids[] = {\n#ifndef OPTi93X\n\t \n\t{ .id = \"OPT0924\",\n\t  .devs = { { \"OPT0000\" }, { \"OPT0002\" }, { \"OPT0005\" } },\n\t  .driver_data = 0x0924 },\n\t \n\t{ .id = \"OPT0925\",\n\t  .devs = { { \"OPT9250\" }, { \"OPT0002\" }, { \"OPT0005\" } },\n\t  .driver_data = 0x0925 },\n#else\n\t \n\t{ .id = \"OPT0931\", .devs = { { \"OPT9310\" }, { \"OPT0002\" } },\n\t  .driver_data = 0x0931 },\n#endif\t \n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);\n\n#endif\t \n\n#define DEV_NAME KBUILD_MODNAME\n\nstatic const char * const snd_opti9xx_names[] = {\n\t\"unknown\",\n\t\"82C928\",\t\"82C929\",\n\t\"82C924\",\t\"82C925\",\n\t\"82C930\",\t\"82C931\",\t\"82C933\"\n};\n\nstatic int snd_opti9xx_init(struct snd_opti9xx *chip,\n\t\t\t    unsigned short hardware)\n{\n\tstatic const int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};\n\n\tchip->hardware = hardware;\n\tstrcpy(chip->name, snd_opti9xx_names[hardware]);\n\n\tspin_lock_init(&chip->lock);\n\n\tchip->irq = -1;\n\n#ifndef OPTi93X\n#ifdef CONFIG_PNP\n\tif (isapnp && chip->mc_base)\n\t\t \n\t\tchip->mc_base |= 0xc00;\n\telse\n#endif\t \n\t{\n\t\tchip->mc_base = 0xf8c;\n\t\tchip->mc_base_size = opti9xx_mc_size[hardware];\n\t}\n#else\n\t\tchip->mc_base_size = opti9xx_mc_size[hardware];\n#endif\n\n\tswitch (hardware) {\n#ifndef OPTi93X\n\tcase OPTi9XX_HW_82C928:\n\tcase OPTi9XX_HW_82C929:\n\t\tchip->password = (hardware == OPTi9XX_HW_82C928) ? 0xe2 : 0xe3;\n\t\tchip->pwd_reg = 3;\n\t\tbreak;\n\n\tcase OPTi9XX_HW_82C924:\n\tcase OPTi9XX_HW_82C925:\n\t\tchip->password = 0xe5;\n\t\tchip->pwd_reg = 3;\n\t\tbreak;\n#else\t \n\n\tcase OPTi9XX_HW_82C930:\n\tcase OPTi9XX_HW_82C931:\n\tcase OPTi9XX_HW_82C933:\n\t\tchip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;\n\t\tif (!chip->mc_indir_index)\n\t\t\tchip->mc_indir_index = 0xe0e;\n\t\tchip->password = 0xe4;\n\t\tchip->pwd_reg = 0;\n\t\tbreak;\n#endif\t \n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"chip %d not supported\\n\", hardware);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,\n\t\t\t\t      unsigned char reg)\n{\n\tunsigned long flags;\n\tunsigned char retval = 0xff;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\n\tswitch (chip->hardware) {\n#ifndef OPTi93X\n\tcase OPTi9XX_HW_82C924:\n\tcase OPTi9XX_HW_82C925:\n\t\tif (reg > 7) {\n\t\t\toutb(reg, chip->mc_base + 8);\n\t\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\t\tretval = inb(chip->mc_base + 9);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C928:\n\tcase OPTi9XX_HW_82C929:\n\t\tretval = inb(chip->mc_base + reg);\n\t\tbreak;\n#else\t \n\n\tcase OPTi9XX_HW_82C930:\n\tcase OPTi9XX_HW_82C931:\n\tcase OPTi9XX_HW_82C933:\n\t\toutb(reg, chip->mc_indir_index);\n\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\tretval = inb(chip->mc_indir_index + 1);\n\t\tbreak;\n#endif\t \n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"chip %d not supported\\n\", chip->hardware);\n\t}\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn retval;\n}\n\nstatic void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,\n\t\t\t      unsigned char value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\n\tswitch (chip->hardware) {\n#ifndef OPTi93X\n\tcase OPTi9XX_HW_82C924:\n\tcase OPTi9XX_HW_82C925:\n\t\tif (reg > 7) {\n\t\t\toutb(reg, chip->mc_base + 8);\n\t\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\t\toutb(value, chip->mc_base + 9);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C928:\n\tcase OPTi9XX_HW_82C929:\n\t\toutb(value, chip->mc_base + reg);\n\t\tbreak;\n#else\t \n\n\tcase OPTi9XX_HW_82C930:\n\tcase OPTi9XX_HW_82C931:\n\tcase OPTi9XX_HW_82C933:\n\t\toutb(reg, chip->mc_indir_index);\n\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\toutb(value, chip->mc_indir_index + 1);\n\t\tbreak;\n#endif\t \n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"chip %d not supported\\n\", chip->hardware);\n\t}\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\n\nstatic inline void snd_opti9xx_write_mask(struct snd_opti9xx *chip,\n\t\tunsigned char reg, unsigned char value, unsigned char mask)\n{\n\tunsigned char oldval = snd_opti9xx_read(chip, reg);\n\n\tsnd_opti9xx_write(chip, reg, (oldval & ~mask) | (value & mask));\n}\n\nstatic int snd_opti9xx_configure(struct snd_opti9xx *chip,\n\t\t\t\t\t   long port,\n\t\t\t\t\t   int irq, int dma1, int dma2,\n\t\t\t\t\t   long mpu_port, int mpu_irq)\n{\n\tunsigned char wss_base_bits;\n\tunsigned char irq_bits;\n\tunsigned char dma_bits;\n\tunsigned char mpu_port_bits = 0;\n\tunsigned char mpu_irq_bits;\n\n\tswitch (chip->hardware) {\n#ifndef OPTi93X\n\tcase OPTi9XX_HW_82C924:\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0xf0, 0xfc);\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C925:\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);\n#ifdef CS4231\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\n#else\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);\n#endif\t \n\t\tbreak;\n\n\tcase OPTi9XX_HW_82C928:\n\tcase OPTi9XX_HW_82C929:\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);\n#ifdef CS4231\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\n#else\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);\n#endif\t \n\t\tbreak;\n\n#else\t \n\tcase OPTi9XX_HW_82C931:\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(20), 0x04, 0x0c);\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C933:\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(21), 0x82, 0xff);\n\t\t \n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(26), 0x01, 0x01);\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C930:\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |\n\t\t\t(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),\n\t\t\t0x34);\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);\n\t\tbreak;\n#endif\t \n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"chip %d not supported\\n\", chip->hardware);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (port & 0x3ff) {\n\tcase 0x130:\n\t\tchip->wss_base = 0x530;\n\t\twss_base_bits = 0x00;\n\t\tbreak;\n\tcase 0x204:\n\t\tchip->wss_base = 0x604;\n\t\twss_base_bits = 0x03;\n\t\tbreak;\n\tcase 0x280:\n\t\tchip->wss_base = 0xe80;\n\t\twss_base_bits = 0x01;\n\t\tbreak;\n\tcase 0x340:\n\t\tchip->wss_base = 0xf40;\n\t\twss_base_bits = 0x02;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"WSS port 0x%lx not valid\\n\", port);\n\t\tgoto __skip_base;\n\t}\n\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);\n\n__skip_base:\n\tswitch (irq) {\n\n\tcase 5:\n\t\tirq_bits = 0x05;\n\t\tbreak;\n\n\tcase 7:\n\t\tirq_bits = 0x01;\n\t\tbreak;\n\tcase 9:\n\t\tirq_bits = 0x02;\n\t\tbreak;\n\tcase 10:\n\t\tirq_bits = 0x03;\n\t\tbreak;\n\tcase 11:\n\t\tirq_bits = 0x04;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"WSS irq # %d not valid\\n\", irq);\n\t\tgoto __skip_resources;\n\t}\n\n\tswitch (dma1) {\n\tcase 0:\n\t\tdma_bits = 0x01;\n\t\tbreak;\n\tcase 1:\n\t\tdma_bits = 0x02;\n\t\tbreak;\n\tcase 3:\n\t\tdma_bits = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"WSS dma1 # %d not valid\\n\", dma1);\n\t\tgoto __skip_resources;\n\t}\n\n#if defined(CS4231) || defined(OPTi93X)\n\tif (dma1 == dma2) {\n\t\tsnd_printk(KERN_ERR \"don't want to share dmas\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (dma2) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"WSS dma2 # %d not valid\\n\", dma2);\n\t\tgoto __skip_resources;\n\t}\n\tdma_bits |= 0x04;\n#endif\t \n\n#ifndef OPTi93X\n\t outb(irq_bits << 3 | dma_bits, chip->wss_base);\n#else  \n\tsnd_opti9xx_write(chip, OPTi9XX_MC_REG(3), (irq_bits << 3 | dma_bits));\n#endif  \n\n__skip_resources:\n\tif (chip->hardware > OPTi9XX_HW_82C928) {\n\t\tswitch (mpu_port) {\n\t\tcase 0:\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0x300:\n\t\t\tmpu_port_bits = 0x03;\n\t\t\tbreak;\n\t\tcase 0x310:\n\t\t\tmpu_port_bits = 0x02;\n\t\t\tbreak;\n\t\tcase 0x320:\n\t\t\tmpu_port_bits = 0x01;\n\t\t\tbreak;\n\t\tcase 0x330:\n\t\t\tmpu_port_bits = 0x00;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"MPU-401 port 0x%lx not valid\\n\", mpu_port);\n\t\t\tgoto __skip_mpu;\n\t\t}\n\n\t\tswitch (mpu_irq) {\n\t\tcase 5:\n\t\t\tmpu_irq_bits = 0x02;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmpu_irq_bits = 0x03;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmpu_irq_bits = 0x00;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmpu_irq_bits = 0x01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_WARNING \"MPU-401 irq # %d not valid\\n\",\n\t\t\t\tmpu_irq);\n\t\t\tgoto __skip_mpu;\n\t\t}\n\n\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6),\n\t\t\t(mpu_port <= 0) ? 0x00 :\n\t\t\t\t0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,\n\t\t\t0xf8);\n\t}\n__skip_mpu:\n\n\treturn 0;\n}\n\n#ifdef OPTi93X\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_3db_step, -9300, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_4bit_12db_max, -3300, 300, 0);\n\nstatic const struct snd_kcontrol_new snd_opti93x_controls[] = {\nWSS_DOUBLE(\"Master Playback Switch\", 0,\n\t\tOPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Master Playback Volume\", 0,\n\t\tOPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1,\n\t\tdb_scale_5bit_3db_step),\nWSS_DOUBLE_TLV(\"PCM Playback Volume\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit),\nWSS_DOUBLE_TLV(\"FM Playback Volume\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 1, 1, 15, 1,\n\t\tdb_scale_4bit_12db_max),\nWSS_DOUBLE(\"Line Playback Switch\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Line Playback Volume\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 15, 1,\n\t\tdb_scale_4bit_12db_max),\nWSS_DOUBLE(\"Mic Playback Switch\", 0,\n\t\tOPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Mic Playback Volume\", 0,\n\t\tOPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1,\n\t\tdb_scale_4bit_12db_max),\nWSS_DOUBLE_TLV(\"CD Playback Volume\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 1, 1, 15, 1,\n\t\tdb_scale_4bit_12db_max),\nWSS_DOUBLE(\"Aux Playback Switch\", 0,\n\t\tOPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Aux Playback Volume\", 0,\n\t\tOPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1,\n\t\tdb_scale_4bit_12db_max),\n};\n\nstatic int snd_opti93x_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card;\n\tunsigned int idx;\n\tstruct snd_ctl_elem_id id1, id2;\n\tint err;\n\n\tif (snd_BUG_ON(!chip || !chip->pcm))\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, chip->pcm->name);\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tstrcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opti93x control\\n\");\n\t\treturn err;\n\t}\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\"); id1.index = 1;\n\tstrcpy(id2.name, \"FM Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opti93x control\\n\");\n\t\treturn err;\n\t}\n\t \n\tstrcpy(id1.name, \"Aux Playback Volume\"); id1.index = 1;\n\tsnd_ctl_remove_id(card, &id1);\n\n\t \n\tid1.index = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_opti93x_controls); idx++) {\n\t\tstrcpy(id1.name, snd_opti93x_controls[idx].name);\n\t\tsnd_ctl_remove_id(card, &id1);\n\n\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_opti93x_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_opti9xx *chip = dev_id;\n\tstruct snd_wss *codec = chip->codec;\n\tunsigned char status;\n\n\tif (!codec)\n\t\treturn IRQ_HANDLED;\n\n\tstatus = snd_opti9xx_read(chip, OPTi9XX_MC_REG(11));\n\tif ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)\n\t\tsnd_pcm_period_elapsed(codec->playback_substream);\n\tif ((status & OPTi93X_IRQ_CAPTURE) && codec->capture_substream) {\n\t\tsnd_wss_overrange(codec);\n\t\tsnd_pcm_period_elapsed(codec->capture_substream);\n\t}\n\toutb(0x00, OPTi93X_PORT(codec, STATUS));\n\treturn IRQ_HANDLED;\n}\n\n#endif  \n\nstatic int snd_opti9xx_read_check(struct snd_card *card,\n\t\t\t\t  struct snd_opti9xx *chip)\n{\n\tunsigned char value;\n#ifdef OPTi93X\n\tunsigned long flags;\n#endif\n\n\tchip->res_mc_base =\n\t\tdevm_request_region(card->dev, chip->mc_base,\n\t\t\t\t    chip->mc_base_size, \"OPTi9xx MC\");\n\tif (!chip->res_mc_base)\n\t\treturn -EBUSY;\n#ifndef OPTi93X\n\tvalue = snd_opti9xx_read(chip, OPTi9XX_MC_REG(1));\n\tif (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))\n\t\tif (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))\n\t\t\treturn 0;\n#else\t \n\tchip->res_mc_indir =\n\t\tdevm_request_region(card->dev, chip->mc_indir_index, 2,\n\t\t\t\t    \"OPTi93x MC\");\n\tif (!chip->res_mc_indir)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\toutb(((chip->mc_indir_index & 0x1f0) >> 4), chip->mc_base);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tvalue = snd_opti9xx_read(chip, OPTi9XX_MC_REG(7));\n\tsnd_opti9xx_write(chip, OPTi9XX_MC_REG(7), 0xff - value);\n\tif (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)\n\t\treturn 0;\n\n\tdevm_release_resource(card->dev, chip->res_mc_indir);\n\tchip->res_mc_indir = NULL;\n#endif\t \n\tdevm_release_resource(card->dev, chip->res_mc_base);\n\tchip->res_mc_base = NULL;\n\n\treturn -ENODEV;\n}\n\nstatic int snd_card_opti9xx_detect(struct snd_card *card,\n\t\t\t\t   struct snd_opti9xx *chip)\n{\n\tint i, err;\n\n#ifndef OPTi93X\n\tfor (i = OPTi9XX_HW_82C928; i < OPTi9XX_HW_82C930; i++) {\n#else\n\tfor (i = OPTi9XX_HW_82C931; i >= OPTi9XX_HW_82C930; i--) {\n#endif\n\t\terr = snd_opti9xx_init(chip, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_opti9xx_read_check(card, chip);\n\t\tif (err == 0)\n\t\t\treturn 1;\n#ifdef OPTi93X\n\t\tchip->mc_indir_index = 0;\n#endif\n\t}\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_PNP\nstatic int snd_card_opti9xx_pnp(struct snd_opti9xx *chip,\n\t\t\t\tstruct pnp_card_link *card,\n\t\t\t\tconst struct pnp_card_device_id *pid)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\tstruct pnp_dev *devmpu;\n#ifndef OPTi93X\n\tstruct pnp_dev *devmc;\n#endif\n\n\tpdev = pnp_request_card_device(card, pid->devs[0].id, NULL);\n\tif (pdev == NULL)\n\t\treturn -EBUSY;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"AUDIO pnp configure failure: %d\\n\", err);\n\t\treturn err;\n\t}\n\n#ifdef OPTi93X\n\tport = pnp_port_start(pdev, 0) - 4;\n\tfm_port = pnp_port_start(pdev, 1) + 8;\n\t \n\tchip->mc_indir_index = (pnp_port_start(pdev, 3) & ~0xf) | 0xe;\n#else\n\tdevmc = pnp_request_card_device(card, pid->devs[2].id, NULL);\n\tif (devmc == NULL)\n\t\treturn -EBUSY;\n\n\terr = pnp_activate_dev(devmc);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"MC pnp configure failure: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tport = pnp_port_start(pdev, 1);\n\tfm_port = pnp_port_start(pdev, 2) + 8;\n\t \n\tchip->mc_base = pnp_port_start(devmc, 0) - 1;\n\tchip->mc_base_size = pnp_port_len(devmc, 0) + 1;\n#endif\t \n\tirq = pnp_irq(pdev, 0);\n\tdma1 = pnp_dma(pdev, 0);\n#if defined(CS4231) || defined(OPTi93X)\n\tdma2 = pnp_dma(pdev, 1);\n#endif\t \n\n\tdevmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);\n\n\tif (devmpu && mpu_port > 0) {\n\t\terr = pnp_activate_dev(devmpu);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"MPU401 pnp configure failure\\n\");\n\t\t\tmpu_port = -1;\n\t\t} else {\n\t\t\tmpu_port = pnp_port_start(devmpu, 0);\n\t\t\tmpu_irq = pnp_irq(devmpu, 0);\n\t\t}\n\t}\n\treturn pid->driver_data;\n}\n#endif\t \n\nstatic int snd_opti9xx_probe(struct snd_card *card)\n{\n\tstatic const long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};\n\tint error;\n\tint xdma2;\n\tstruct snd_opti9xx *chip = card->private_data;\n\tstruct snd_wss *codec;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_hwdep *synth;\n\n#if defined(CS4231) || defined(OPTi93X)\n\txdma2 = dma2;\n#else\n\txdma2 = -1;\n#endif\n\n\tif (port == SNDRV_AUTO_PORT) {\n\t\tport = snd_legacy_find_free_ioport(possible_ports, 4);\n\t\tif (port < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free WSS port\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\terror = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,\n\t\t\t\t      mpu_port, mpu_irq);\n\tif (error)\n\t\treturn error;\n\n\terror = snd_wss_create(card, chip->wss_base + 4, -1, irq, dma1, xdma2,\n#ifdef OPTi93X\n\t\t\t       WSS_HW_OPTI93X, WSS_HWSHARE_IRQ,\n#else\n\t\t\t       WSS_HW_DETECT, 0,\n#endif\n\t\t\t       &codec);\n\tif (error < 0)\n\t\treturn error;\n\tchip->codec = codec;\n\terror = snd_wss_pcm(codec, 0);\n\tif (error < 0)\n\t\treturn error;\n\terror = snd_wss_mixer(codec);\n\tif (error < 0)\n\t\treturn error;\n#ifdef OPTi93X\n\terror = snd_opti93x_mixer(codec);\n\tif (error < 0)\n\t\treturn error;\n#endif\n#ifdef CS4231\n\terror = snd_wss_timer(codec, 0);\n\tif (error < 0)\n\t\treturn error;\n#endif\n#ifdef OPTi93X\n\terror = devm_request_irq(card->dev, irq, snd_opti93x_interrupt,\n\t\t\t\t 0, DEV_NAME\" - WSS\", chip);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"opti9xx: can't grab IRQ %d\\n\", irq);\n\t\treturn error;\n\t}\n#endif\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\tstrcpy(card->driver, chip->name);\n\tsprintf(card->shortname, \"OPTi %s\", card->driver);\n#if defined(CS4231) || defined(OPTi93X)\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s, %s at 0x%lx, irq %d, dma %d&%d\",\n\t\t  card->shortname, codec->pcm->name,\n\t\t  chip->wss_base + 4, irq, dma1, xdma2);\n#else\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s, %s at 0x%lx, irq %d, dma %d\",\n\t\t  card->shortname, codec->pcm->name, chip->wss_base + 4, irq,\n\t\t  dma1);\n#endif\t \n\n\tif (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)\n\t\trmidi = NULL;\n\telse {\n\t\terror = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\tmpu_port, 0, mpu_irq, &rmidi);\n\t\tif (error)\n\t\t\tsnd_printk(KERN_WARNING \"no MPU-401 device at 0x%lx?\\n\",\n\t\t\t\t   mpu_port);\n\t}\n\n\tif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\n\t\tstruct snd_opl3 *opl3 = NULL;\n#ifndef OPTi93X\n\t\tif (chip->hardware == OPTi9XX_HW_82C928 ||\n\t\t    chip->hardware == OPTi9XX_HW_82C929 ||\n\t\t    chip->hardware == OPTi9XX_HW_82C924) {\n\t\t\tstruct snd_opl4 *opl4;\n\t\t\t \n\t\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),\n\t\t\t\t\t       0x20, 0x20);\n\t\t\tif (snd_opl4_create(card, fm_port, fm_port - 8,\n\t\t\t\t\t    2, &opl3, &opl4) < 0) {\n\t\t\t\t \n\t\t\t\tsnd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),\n\t\t\t\t\t\t       0x00, 0x20);\n\t\t\t}\n\t\t}\n#endif\t \n\t\tif (!opl3 && snd_opl3_create(card, fm_port, fm_port + 2,\n\t\t\t\t\t     OPL3_HW_AUTO, 0, &opl3) < 0) {\n\t\t\tsnd_printk(KERN_WARNING \"no OPL device at 0x%lx-0x%lx\\n\",\n\t\t\t\t   fm_port, fm_port + 4 - 1);\n\t\t}\n\t\tif (opl3) {\n\t\t\terror = snd_opl3_hwdep_new(opl3, 0, 1, &synth);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn snd_card_register(card);\n}\n\nstatic int snd_opti9xx_card_new(struct device *pdev, struct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(struct snd_opti9xx), &card);\n\tif (err < 0)\n\t\treturn err;\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_opti9xx_isa_match(struct device *devptr,\n\t\t\t\t unsigned int dev)\n{\n#ifdef CONFIG_PNP\n\tif (snd_opti9xx_pnp_is_probed)\n\t\treturn 0;\n\tif (isapnp)\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\nstatic int snd_opti9xx_isa_probe(struct device *devptr,\n\t\t\t\t unsigned int dev)\n{\n\tstruct snd_card *card;\n\tint error;\n\tstatic const long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};\n#ifdef OPTi93X\n\tstatic const int possible_irqs[] = {5, 9, 10, 11, 7, -1};\n#else\n\tstatic const int possible_irqs[] = {9, 10, 11, 7, -1};\n#endif\t \n\tstatic const int possible_mpu_irqs[] = {5, 9, 10, 7, -1};\n\tstatic const int possible_dma1s[] = {3, 1, 0, -1};\n#if defined(CS4231) || defined(OPTi93X)\n\tstatic const int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};\n#endif\t \n\n\tif (mpu_port == SNDRV_AUTO_PORT) {\n\t\tmpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);\n\t\tif (mpu_port < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free MPU401 port\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (irq == SNDRV_AUTO_IRQ) {\n\t\tirq = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (mpu_irq == SNDRV_AUTO_IRQ) {\n\t\tmpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs);\n\t\tif (mpu_irq < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free MPU401 IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1 == SNDRV_AUTO_DMA) {\n\t\tdma1 = snd_legacy_find_free_dma(possible_dma1s);\n\t\tif (dma1 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n#if defined(CS4231) || defined(OPTi93X)\n\tif (dma2 == SNDRV_AUTO_DMA) {\n\t\tdma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4]);\n\t\tif (dma2 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA2\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n#endif\n\n\terror = snd_opti9xx_card_new(devptr, &card);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_card_opti9xx_detect(card, card->private_data);\n\tif (error < 0)\n\t\treturn error;\n\terror = snd_opti9xx_probe(card);\n\tif (error < 0)\n\t\treturn error;\n\tdev_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_opti9xx_suspend(struct snd_card *card)\n{\n\tstruct snd_opti9xx *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tchip->codec->suspend(chip->codec);\n\treturn 0;\n}\n\nstatic int snd_opti9xx_resume(struct snd_card *card)\n{\n\tstruct snd_opti9xx *chip = card->private_data;\n\tint error, xdma2;\n#if defined(CS4231) || defined(OPTi93X)\n\txdma2 = dma2;\n#else\n\txdma2 = -1;\n#endif\n\n\terror = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,\n\t\t\t\t      mpu_port, mpu_irq);\n\tif (error)\n\t\treturn error;\n\tchip->codec->resume(chip->codec);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic int snd_opti9xx_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\t   pm_message_t state)\n{\n\treturn snd_opti9xx_suspend(dev_get_drvdata(dev));\n}\n\nstatic int snd_opti9xx_isa_resume(struct device *dev, unsigned int n)\n{\n\treturn snd_opti9xx_resume(dev_get_drvdata(dev));\n}\n#endif\n\nstatic struct isa_driver snd_opti9xx_driver = {\n\t.match\t\t= snd_opti9xx_isa_match,\n\t.probe\t\t= snd_opti9xx_isa_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_opti9xx_isa_suspend,\n\t.resume\t\t= snd_opti9xx_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n#ifdef CONFIG_PNP\nstatic int snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,\n\t\t\t\t const struct pnp_card_device_id *pid)\n{\n\tstruct snd_card *card;\n\tint error, hw;\n\tstruct snd_opti9xx *chip;\n\n\tif (snd_opti9xx_pnp_is_probed)\n\t\treturn -EBUSY;\n\tif (! isapnp)\n\t\treturn -ENODEV;\n\terror = snd_opti9xx_card_new(&pcard->card->dev, &card);\n\tif (error < 0)\n\t\treturn error;\n\tchip = card->private_data;\n\n\thw = snd_card_opti9xx_pnp(chip, pcard, pid);\n\tswitch (hw) {\n\tcase 0x0924:\n\t\thw = OPTi9XX_HW_82C924;\n\t\tbreak;\n\tcase 0x0925:\n\t\thw = OPTi9XX_HW_82C925;\n\t\tbreak;\n\tcase 0x0931:\n\t\thw = OPTi9XX_HW_82C931;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\terror = snd_opti9xx_init(chip, hw);\n\tif (error)\n\t\treturn error;\n\terror = snd_opti9xx_read_check(card, chip);\n\tif (error) {\n\t\tsnd_printk(KERN_ERR \"OPTI chip not found\\n\");\n\t\treturn error;\n\t}\n\terror = snd_opti9xx_probe(card);\n\tif (error < 0)\n\t\treturn error;\n\tpnp_set_card_drvdata(pcard, card);\n\tsnd_opti9xx_pnp_is_probed = 1;\n\treturn 0;\n}\n\nstatic void snd_opti9xx_pnp_remove(struct pnp_card_link *pcard)\n{\n\tsnd_opti9xx_pnp_is_probed = 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_opti9xx_pnp_suspend(struct pnp_card_link *pcard,\n\t\t\t\t   pm_message_t state)\n{\n\treturn snd_opti9xx_suspend(pnp_get_card_drvdata(pcard));\n}\n\nstatic int snd_opti9xx_pnp_resume(struct pnp_card_link *pcard)\n{\n\treturn snd_opti9xx_resume(pnp_get_card_drvdata(pcard));\n}\n#endif\n\nstatic struct pnp_card_driver opti9xx_pnpc_driver = {\n\t.flags\t\t= PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= DEV_NAME,\n\t.id_table\t= snd_opti9xx_pnpids,\n\t.probe\t\t= snd_opti9xx_pnp_probe,\n\t.remove\t\t= snd_opti9xx_pnp_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_opti9xx_pnp_suspend,\n\t.resume\t\t= snd_opti9xx_pnp_resume,\n#endif\n};\n#endif\n\n#ifdef OPTi93X\n#define CHIP_NAME\t\"82C93x\"\n#else\n#define CHIP_NAME\t\"82C92x\"\n#endif\n\nstatic int __init alsa_card_opti9xx_init(void)\n{\n#ifdef CONFIG_PNP\n\tpnp_register_card_driver(&opti9xx_pnpc_driver);\n\tif (snd_opti9xx_pnp_is_probed)\n\t\treturn 0;\n\tpnp_unregister_card_driver(&opti9xx_pnpc_driver);\n#endif\n\treturn isa_register_driver(&snd_opti9xx_driver, 1);\n}\n\nstatic void __exit alsa_card_opti9xx_exit(void)\n{\n\tif (!snd_opti9xx_pnp_is_probed) {\n\t\tisa_unregister_driver(&snd_opti9xx_driver);\n\t\treturn;\n\t}\n#ifdef CONFIG_PNP\n\tpnp_unregister_card_driver(&opti9xx_pnpc_driver);\n#endif\n}\n\nmodule_init(alsa_card_opti9xx_init)\nmodule_exit(alsa_card_opti9xx_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}