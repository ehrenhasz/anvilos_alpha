{
  "module_name": "miro.c",
  "hash_id": "f126ca90847760a802cfcf30d56da62bc70b92f63c98185f0973a1c0ce177ac9",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/opti9xx/miro.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/opl4.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#define SNDRV_LEGACY_FIND_FREE_IOPORT\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n#include <sound/aci.h>\n\nMODULE_AUTHOR(\"Martin Langer <martin-langer@gmx.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Miro miroSOUND PCM1 pro, PCM12, PCM20 Radio\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t\t \nstatic long port = SNDRV_DEFAULT_PORT1; \t \nstatic long mpu_port = SNDRV_DEFAULT_PORT1;\t \nstatic long fm_port = SNDRV_DEFAULT_PORT1;\t \nstatic int irq = SNDRV_DEFAULT_IRQ1;\t\t \nstatic int mpu_irq = SNDRV_DEFAULT_IRQ1;\t \nstatic int dma1 = SNDRV_DEFAULT_DMA1;\t\t \nstatic int dma2 = SNDRV_DEFAULT_DMA1;\t\t \nstatic int wss;\nstatic int ide;\n#ifdef CONFIG_PNP\nstatic bool isapnp = 1;\t\t\t\t \n#endif\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for miro soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for miro soundcard.\");\nmodule_param_hw(port, long, ioport, 0444);\nMODULE_PARM_DESC(port, \"WSS port # for miro driver.\");\nmodule_param_hw(mpu_port, long, ioport, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for miro driver.\");\nmodule_param_hw(fm_port, long, ioport, 0444);\nMODULE_PARM_DESC(fm_port, \"FM Port # for miro driver.\");\nmodule_param_hw(irq, int, irq, 0444);\nMODULE_PARM_DESC(irq, \"WSS irq # for miro driver.\");\nmodule_param_hw(mpu_irq, int, irq, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 irq # for miro driver.\");\nmodule_param_hw(dma1, int, dma, 0444);\nMODULE_PARM_DESC(dma1, \"1st dma # for miro driver.\");\nmodule_param_hw(dma2, int, dma, 0444);\nMODULE_PARM_DESC(dma2, \"2nd dma # for miro driver.\");\nmodule_param(wss, int, 0444);\nMODULE_PARM_DESC(wss, \"wss mode\");\nmodule_param(ide, int, 0444);\nMODULE_PARM_DESC(ide, \"enable ide port\");\n#ifdef CONFIG_PNP\nmodule_param(isapnp, bool, 0444);\nMODULE_PARM_DESC(isapnp, \"Enable ISA PnP detection for specified soundcard.\");\n#endif\n\n#define OPTi9XX_HW_DETECT\t0\n#define OPTi9XX_HW_82C928\t1\n#define OPTi9XX_HW_82C929\t2\n#define OPTi9XX_HW_82C924\t3\n#define OPTi9XX_HW_82C925\t4\n#define OPTi9XX_HW_82C930\t5\n#define OPTi9XX_HW_82C931\t6\n#define OPTi9XX_HW_82C933\t7\n#define OPTi9XX_HW_LAST\t\tOPTi9XX_HW_82C933\n\n#define OPTi9XX_MC_REG(n)\tn\n\nstruct snd_miro {\n\tunsigned short hardware;\n\tunsigned char password;\n\tchar name[7];\n\n\tstruct resource *res_mc_base;\n\tstruct resource *res_aci_port;\n\n\tunsigned long mc_base;\n\tunsigned long mc_base_size;\n\tunsigned long pwd_reg;\n\n\tspinlock_t lock;\n\tstruct snd_pcm *pcm;\n\n\tlong wss_base;\n\tint irq;\n\tint dma1;\n\tint dma2;\n\n\tlong mpu_port;\n\tint mpu_irq;\n\n\tstruct snd_miro_aci *aci;\n};\n\nstatic struct snd_miro_aci aci_device;\n\nstatic const char * const snd_opti9xx_names[] = {\n\t\"unknown\",\n\t\"82C928\", \"82C929\",\n\t\"82C924\", \"82C925\",\n\t\"82C930\", \"82C931\", \"82C933\"\n};\n\nstatic int snd_miro_pnp_is_probed;\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_card_device_id snd_miro_pnpids[] = {\n\t \n\t{ .id = \"MIR0924\",\n\t  .devs = { { \"MIR0000\" }, { \"MIR0002\" }, { \"MIR0005\" } }, },\n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_miro_pnpids);\n\n#endif\t \n\n \n\nstatic int aci_busy_wait(struct snd_miro_aci *aci)\n{\n\tlong timeout;\n\tunsigned char byte;\n\n\tfor (timeout = 1; timeout <= ACI_MINTIME + 30; timeout++) {\n\t\tbyte = inb(aci->aci_port + ACI_REG_BUSY);\n\t\tif ((byte & 1) == 0) {\n\t\t\tif (timeout >= ACI_MINTIME)\n\t\t\t\tsnd_printd(\"aci ready in round %ld.\\n\",\n\t\t\t\t\t   timeout-ACI_MINTIME);\n\t\t\treturn byte;\n\t\t}\n\t\tif (timeout >= ACI_MINTIME) {\n\t\t\tlong out=10*HZ;\n\t\t\tswitch (timeout-ACI_MINTIME) {\n\t\t\tcase 0 ... 9:\n\t\t\t\tout /= 10;\n\t\t\t\tfallthrough;\n\t\t\tcase 10 ... 19:\n\t\t\t\tout /= 10;\n\t\t\t\tfallthrough;\n\t\t\tcase 20 ... 30:\n\t\t\t\tout /= 10;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tschedule_timeout(out);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsnd_printk(KERN_ERR \"aci_busy_wait() time out\\n\");\n\treturn -EBUSY;\n}\n\nstatic inline int aci_write(struct snd_miro_aci *aci, unsigned char byte)\n{\n\tif (aci_busy_wait(aci) >= 0) {\n\t\toutb(byte, aci->aci_port + ACI_REG_COMMAND);\n\t\treturn 0;\n\t} else {\n\t\tsnd_printk(KERN_ERR \"aci busy, aci_write(0x%x) stopped.\\n\", byte);\n\t\treturn -EBUSY;\n\t}\n}\n\nstatic inline int aci_read(struct snd_miro_aci *aci)\n{\n\tunsigned char byte;\n\n\tif (aci_busy_wait(aci) >= 0) {\n\t\tbyte = inb(aci->aci_port + ACI_REG_STATUS);\n\t\treturn byte;\n\t} else {\n\t\tsnd_printk(KERN_ERR \"aci busy, aci_read() stopped.\\n\");\n\t\treturn -EBUSY;\n\t}\n}\n\nint snd_aci_cmd(struct snd_miro_aci *aci, int write1, int write2, int write3)\n{\n\tint write[] = {write1, write2, write3};\n\tint value, i;\n\n\tif (mutex_lock_interruptible(&aci->aci_mutex))\n\t\treturn -EINTR;\n\n\tfor (i=0; i<3; i++) {\n\t\tif (write[i]< 0 || write[i] > 255)\n\t\t\tbreak;\n\t\telse {\n\t\t\tvalue = aci_write(aci, write[i]);\n\t\t\tif (value < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tvalue = aci_read(aci);\n\nout:\tmutex_unlock(&aci->aci_mutex);\n\treturn value;\n}\nEXPORT_SYMBOL(snd_aci_cmd);\n\nstatic int aci_getvalue(struct snd_miro_aci *aci, unsigned char index)\n{\n\treturn snd_aci_cmd(aci, ACI_STATUS, index, -1);\n}\n\nstatic int aci_setvalue(struct snd_miro_aci *aci, unsigned char index,\n\t\t\tint value)\n{\n\treturn snd_aci_cmd(aci, index, value, -1);\n}\n\nstruct snd_miro_aci *snd_aci_get_aci(void)\n{\n\tif (aci_device.aci_port == 0)\n\t\treturn NULL;\n\treturn &aci_device;\n}\nEXPORT_SYMBOL(snd_aci_get_aci);\n\n \n\n#define snd_miro_info_capture\tsnd_ctl_boolean_mono_info\n\nstatic int snd_miro_get_capture(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint value;\n\n\tvalue = aci_getvalue(miro->aci, ACI_S_GENERAL);\n\tif (value < 0) {\n\t\tsnd_printk(KERN_ERR \"snd_miro_get_capture() failed: %d\\n\",\n\t\t\t   value);\n\t\treturn value;\n\t}\n\n\tucontrol->value.integer.value[0] = value & 0x20;\n\n\treturn 0;\n}\n\nstatic int snd_miro_put_capture(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint change, value, error;\n\n\tvalue = !(ucontrol->value.integer.value[0]);\n\n\terror = aci_setvalue(miro->aci, ACI_SET_SOLOMODE, value);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"snd_miro_put_capture() failed: %d\\n\",\n\t\t\t   error);\n\t\treturn error;\n\t}\n\n\tchange = (value != miro->aci->aci_solomode);\n\tmiro->aci->aci_solomode = value;\n\t\n\treturn change;\n}\n\nstatic int snd_miro_info_preamp(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 3;\n\n\treturn 0;\n}\n\nstatic int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint value;\n\n\tif (miro->aci->aci_version <= 176) {\n\n\t\t \n\n\t\tucontrol->value.integer.value[0] = miro->aci->aci_preamp;\n\t\treturn 0;\n\t}\n\n\tvalue = aci_getvalue(miro->aci, ACI_GET_PREAMP);\n\tif (value < 0) {\n\t\tsnd_printk(KERN_ERR \"snd_miro_get_preamp() failed: %d\\n\",\n\t\t\t   value);\n\t\treturn value;\n\t}\n\t\n\tucontrol->value.integer.value[0] = value;\n\n\treturn 0;\n}\n\nstatic int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint error, value, change;\n\n\tvalue = ucontrol->value.integer.value[0];\n\n\terror = aci_setvalue(miro->aci, ACI_SET_PREAMP, value);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"snd_miro_put_preamp() failed: %d\\n\",\n\t\t\t   error);\n\t\treturn error;\n\t}\n\n\tchange = (value != miro->aci->aci_preamp);\n\tmiro->aci->aci_preamp = value;\n\n\treturn change;\n}\n\n#define snd_miro_info_amp\tsnd_ctl_boolean_mono_info\n\nstatic int snd_miro_get_amp(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = miro->aci->aci_amp;\n\n\treturn 0;\n}\n\nstatic int snd_miro_put_amp(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint error, value, change;\n\n\tvalue = ucontrol->value.integer.value[0];\n\n\terror = aci_setvalue(miro->aci, ACI_SET_POWERAMP, value);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"snd_miro_put_amp() to %d failed: %d\\n\", value, error);\n\t\treturn error;\n\t}\n\n\tchange = (value != miro->aci->aci_amp);\n\tmiro->aci->aci_amp = value;\n\n\treturn change;\n}\n\n#define MIRO_DOUBLE(ctl_name, ctl_index, get_right_reg, set_right_reg) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = ctl_name, \\\n  .index = ctl_index, \\\n  .info = snd_miro_info_double, \\\n  .get = snd_miro_get_double, \\\n  .put = snd_miro_put_double, \\\n  .private_value = get_right_reg | (set_right_reg << 8) \\\n}\n\nstatic int snd_miro_info_double(struct snd_kcontrol *kcontrol, \n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tint reg = kcontrol->private_value & 0xff;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\n\tif ((reg >= ACI_GET_EQ1) && (reg <= ACI_GET_EQ7)) {\n\n\t\t \n\n\t\tuinfo->value.integer.min = - 0x7f;\n\t\tuinfo->value.integer.max = 0x7f;\n\t} else {\n\n\t\t \n\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 0x20;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_miro_get_double(struct snd_kcontrol *kcontrol, \n\t\t\t       struct snd_ctl_elem_value *uinfo)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tint left_val, right_val;\n\n\tint right_reg = kcontrol->private_value & 0xff;\n\tint left_reg = right_reg + 1;\n\n\tright_val = aci_getvalue(miro->aci, right_reg);\n\tif (right_val < 0) {\n\t\tsnd_printk(KERN_ERR \"aci_getvalue(%d) failed: %d\\n\", right_reg, right_val);\n\t\treturn right_val;\n\t}\n\n\tleft_val = aci_getvalue(miro->aci, left_reg);\n\tif (left_val < 0) {\n\t\tsnd_printk(KERN_ERR \"aci_getvalue(%d) failed: %d\\n\", left_reg, left_val);\n\t\treturn left_val;\n\t}\n\n\tif ((right_reg >= ACI_GET_EQ1) && (right_reg <= ACI_GET_EQ7)) {\n\n\t\t \n\n\t\tif (left_val < 0x80) {\n\t\t\tuinfo->value.integer.value[0] = left_val;\n\t\t} else {\n\t\t\tuinfo->value.integer.value[0] = 0x80 - left_val;\n\t\t}\n\n\t\tif (right_val < 0x80) {\n\t\t\tuinfo->value.integer.value[1] = right_val;\n\t\t} else {\n\t\t\tuinfo->value.integer.value[1] = 0x80 - right_val;\n\t\t}\n\n\t} else {\n\n\t\t \n\n\t\tuinfo->value.integer.value[0] = 0x20 - left_val;\n\t\tuinfo->value.integer.value[1] = 0x20 - right_val;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_miro_put_double(struct snd_kcontrol *kcontrol, \n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\n\tstruct snd_miro_aci *aci = miro->aci;\n\tint left, right, left_old, right_old;\n\tint setreg_left, setreg_right, getreg_left, getreg_right;\n\tint change, error;\n\n\tleft = ucontrol->value.integer.value[0];\n\tright = ucontrol->value.integer.value[1];\n\n\tsetreg_right = (kcontrol->private_value >> 8) & 0xff;\n\tsetreg_left = setreg_right + 8;\n\tif (setreg_right == ACI_SET_MASTER)\n\t\tsetreg_left -= 7;\n\n\tgetreg_right = kcontrol->private_value & 0xff;\n\tgetreg_left = getreg_right + 1;\n\n\tleft_old = aci_getvalue(aci, getreg_left);\n\tif (left_old < 0) {\n\t\tsnd_printk(KERN_ERR \"aci_getvalue(%d) failed: %d\\n\", getreg_left, left_old);\n\t\treturn left_old;\n\t}\n\n\tright_old = aci_getvalue(aci, getreg_right);\n\tif (right_old < 0) {\n\t\tsnd_printk(KERN_ERR \"aci_getvalue(%d) failed: %d\\n\", getreg_right, right_old);\n\t\treturn right_old;\n\t}\n\n\tif ((getreg_right >= ACI_GET_EQ1) && (getreg_right <= ACI_GET_EQ7)) {\n\n\t\t \n\n\t\tif (left < -0x7f || left > 0x7f ||\n\t\t    right < -0x7f || right > 0x7f)\n\t\t\treturn -EINVAL;\n\n\t\tif (left_old > 0x80) \n\t\t\tleft_old = 0x80 - left_old;\n\t\tif (right_old > 0x80) \n\t\t\tright_old = 0x80 - right_old;\n\n\t\tif (left >= 0) {\n\t\t\terror = aci_setvalue(aci, setreg_left, left);\n\t\t\tif (error < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t\t   left, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else {\n\t\t\terror = aci_setvalue(aci, setreg_left, 0x80 - left);\n\t\t\tif (error < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t\t   0x80 - left, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tif (right >= 0) {\n\t\t\terror = aci_setvalue(aci, setreg_right, right);\n\t\t\tif (error < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t\t   right, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else {\n\t\t\terror = aci_setvalue(aci, setreg_right, 0x80 - right);\n\t\t\tif (error < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t\t   0x80 - right, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\t \n\n\t\tif (left < 0 || left > 0x20 ||\n\t\t    right < 0 || right > 0x20)\n\t\t\treturn -EINVAL;\n\n\t\tleft_old = 0x20 - left_old;\n\t\tright_old = 0x20 - right_old;\n\n\t\terror = aci_setvalue(aci, setreg_left, 0x20 - left);\n\t\tif (error < 0) {\n\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t   0x20 - left, error);\n\t\t\treturn error;\n\t\t}\n\t\terror = aci_setvalue(aci, setreg_right, 0x20 - right);\n\t\tif (error < 0) {\n\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\",\n\t\t\t\t   0x20 - right, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tchange = (left != left_old) || (right != right_old);\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_miro_controls[] = {\nMIRO_DOUBLE(\"Master Playback Volume\", 0, ACI_GET_MASTER, ACI_SET_MASTER),\nMIRO_DOUBLE(\"Mic Playback Volume\", 1, ACI_GET_MIC, ACI_SET_MIC),\nMIRO_DOUBLE(\"Line Playback Volume\", 1, ACI_GET_LINE, ACI_SET_LINE),\nMIRO_DOUBLE(\"CD Playback Volume\", 0, ACI_GET_CD, ACI_SET_CD),\nMIRO_DOUBLE(\"Synth Playback Volume\", 0, ACI_GET_SYNTH, ACI_SET_SYNTH),\nMIRO_DOUBLE(\"PCM Playback Volume\", 1, ACI_GET_PCM, ACI_SET_PCM),\nMIRO_DOUBLE(\"Aux Playback Volume\", 2, ACI_GET_LINE2, ACI_SET_LINE2),\n};\n\n \nstatic const struct snd_kcontrol_new snd_miro_eq_controls[] = {\nMIRO_DOUBLE(\"Tone Control - 28 Hz\", 0, ACI_GET_EQ1, ACI_SET_EQ1),\nMIRO_DOUBLE(\"Tone Control - 160 Hz\", 0, ACI_GET_EQ2, ACI_SET_EQ2),\nMIRO_DOUBLE(\"Tone Control - 400 Hz\", 0, ACI_GET_EQ3, ACI_SET_EQ3),\nMIRO_DOUBLE(\"Tone Control - 1 kHz\", 0, ACI_GET_EQ4, ACI_SET_EQ4),\nMIRO_DOUBLE(\"Tone Control - 2.5 kHz\", 0, ACI_GET_EQ5, ACI_SET_EQ5),\nMIRO_DOUBLE(\"Tone Control - 6.3 kHz\", 0, ACI_GET_EQ6, ACI_SET_EQ6),\nMIRO_DOUBLE(\"Tone Control - 16 kHz\", 0, ACI_GET_EQ7, ACI_SET_EQ7),\n};\n\nstatic const struct snd_kcontrol_new snd_miro_radio_control[] = {\nMIRO_DOUBLE(\"Radio Playback Volume\", 0, ACI_GET_LINE1, ACI_SET_LINE1),\n};\n\nstatic const struct snd_kcontrol_new snd_miro_line_control[] = {\nMIRO_DOUBLE(\"Line Playback Volume\", 2, ACI_GET_LINE1, ACI_SET_LINE1),\n};\n\nstatic const struct snd_kcontrol_new snd_miro_preamp_control[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Mic Boost\",\n\t.index = 1,\n\t.info = snd_miro_info_preamp,\n\t.get = snd_miro_get_preamp,\n\t.put = snd_miro_put_preamp,\n}};\n\nstatic const struct snd_kcontrol_new snd_miro_amp_control[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line Boost\",\n\t.index = 0,\n\t.info = snd_miro_info_amp,\n\t.get = snd_miro_get_amp,\n\t.put = snd_miro_put_amp,\n}};\n\nstatic const struct snd_kcontrol_new snd_miro_capture_control[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Capture Switch\",\n\t.index = 0,\n\t.info = snd_miro_info_capture,\n\t.get = snd_miro_get_capture,\n\t.put = snd_miro_put_capture,\n}};\n\nstatic const unsigned char aci_init_values[][2] = {\n\t{ ACI_SET_MUTE, 0x00 },\n\t{ ACI_SET_POWERAMP, 0x00 },\n\t{ ACI_SET_PREAMP, 0x00 },\n\t{ ACI_SET_SOLOMODE, 0x00 },\n\t{ ACI_SET_MIC + 0, 0x20 },\n\t{ ACI_SET_MIC + 8, 0x20 },\n\t{ ACI_SET_LINE + 0, 0x20 },\n\t{ ACI_SET_LINE + 8, 0x20 },\n\t{ ACI_SET_CD + 0, 0x20 },\n\t{ ACI_SET_CD + 8, 0x20 },\n\t{ ACI_SET_PCM + 0, 0x20 },\n\t{ ACI_SET_PCM + 8, 0x20 },\n\t{ ACI_SET_LINE1 + 0, 0x20 },\n\t{ ACI_SET_LINE1 + 8, 0x20 },\n\t{ ACI_SET_LINE2 + 0, 0x20 },\n\t{ ACI_SET_LINE2 + 8, 0x20 },\n\t{ ACI_SET_SYNTH + 0, 0x20 },\n\t{ ACI_SET_SYNTH + 8, 0x20 },\n\t{ ACI_SET_MASTER + 0, 0x20 },\n\t{ ACI_SET_MASTER + 1, 0x20 },\n};\n\nstatic int snd_set_aci_init_values(struct snd_miro *miro)\n{\n\tint idx, error;\n\tstruct snd_miro_aci *aci = miro->aci;\n\n\t \n\n\tif ((aci->aci_product == 'A') && wss) {\n\t\terror = aci_setvalue(aci, ACI_SET_WSS, wss);\n\t\tif (error < 0) {\n\t\t\tsnd_printk(KERN_ERR \"enabling WSS mode failed\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\n\tif (ide) {\n\t\terror = aci_setvalue(aci, ACI_SET_IDE, ide);\n\t\tif (error < 0) {\n\t\t\tsnd_printk(KERN_ERR \"enabling IDE port failed\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\n\tfor (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++) {\n\t\terror = aci_setvalue(aci, aci_init_values[idx][0],\n\t\t\t\t     aci_init_values[idx][1]);\n\t\tif (error < 0) {\n\t\t\tsnd_printk(KERN_ERR \"aci_setvalue(%d) failed: %d\\n\", \n\t\t\t\t   aci_init_values[idx][0], error);\n                        return error;\n                }\n\t}\n\taci->aci_amp = 0;\n\taci->aci_preamp = 0;\n\taci->aci_solomode = 1;\n\n\treturn 0;\n}\n\nstatic int snd_miro_mixer(struct snd_card *card,\n\t\t\t  struct snd_miro *miro)\n{\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!miro || !card))\n\t\treturn -EINVAL;\n\n\tswitch (miro->hardware) {\n\tcase OPTi9XX_HW_82C924:\n\t\tstrcpy(card->mixername, \"ACI & OPTi924\");\n\t\tbreak;\n\tcase OPTi9XX_HW_82C929:\n\t\tstrcpy(card->mixername, \"ACI & OPTi929\");\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_miro_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_controls[idx], miro));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif ((miro->aci->aci_product == 'A') ||\n\t    (miro->aci->aci_product == 'B')) {\n\t\t \n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_line_control[0], miro));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_amp_control[0], miro));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif ((miro->aci->aci_product == 'B') ||\n\t    (miro->aci->aci_product == 'C')) {\n\t\t \n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_preamp_control[0], miro));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (miro->aci->aci_version >= 176) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_capture_control[0], miro));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (miro->aci->aci_product == 'C') {\n\t\t \n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_radio_control[0], miro));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_miro_eq_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_miro_eq_controls[idx], miro));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_miro_init(struct snd_miro *chip,\n\t\t\t unsigned short hardware)\n{\n\tstatic const int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};\n\n\tchip->hardware = hardware;\n\tstrcpy(chip->name, snd_opti9xx_names[hardware]);\n\n\tchip->mc_base_size = opti9xx_mc_size[hardware];  \n\n\tspin_lock_init(&chip->lock);\n\n\tchip->wss_base = -1;\n\tchip->irq = -1;\n\tchip->dma1 = -1;\n\tchip->dma2 = -1;\n\tchip->mpu_port = -1;\n\tchip->mpu_irq = -1;\n\n\tchip->pwd_reg = 3;\n\n#ifdef CONFIG_PNP\n\tif (isapnp && chip->mc_base)\n\t\t \n\t\tchip->mc_base |= 0xc00;\n\telse\n#endif\n\t\tchip->mc_base = 0xf8c;\n\n\tswitch (hardware) {\n\tcase OPTi9XX_HW_82C929:\n\t\tchip->password = 0xe3;\n\t\tbreak;\n\n\tcase OPTi9XX_HW_82C924:\n\t\tchip->password = 0xe5;\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"sorry, no support for %d\\n\", hardware);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned char snd_miro_read(struct snd_miro *chip,\n\t\t\t\t   unsigned char reg)\n{\n\tunsigned long flags;\n\tunsigned char retval = 0xff;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\n\tswitch (chip->hardware) {\n\tcase OPTi9XX_HW_82C924:\n\t\tif (reg > 7) {\n\t\t\toutb(reg, chip->mc_base + 8);\n\t\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\t\tretval = inb(chip->mc_base + 9);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C929:\n\t\tretval = inb(chip->mc_base + reg);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"sorry, no support for %d\\n\", chip->hardware);\n\t}\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\treturn retval;\n}\n\nstatic void snd_miro_write(struct snd_miro *chip, unsigned char reg,\n\t\t\t   unsigned char value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\n\tswitch (chip->hardware) {\n\tcase OPTi9XX_HW_82C924:\n\t\tif (reg > 7) {\n\t\t\toutb(reg, chip->mc_base + 8);\n\t\t\toutb(chip->password, chip->mc_base + chip->pwd_reg);\n\t\t\toutb(value, chip->mc_base + 9);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OPTi9XX_HW_82C929:\n\t\toutb(value, chip->mc_base + reg);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"sorry, no support for %d\\n\", chip->hardware);\n\t}\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic inline void snd_miro_write_mask(struct snd_miro *chip,\n\t\tunsigned char reg, unsigned char value, unsigned char mask)\n{\n\tunsigned char oldval = snd_miro_read(chip, reg);\n\n\tsnd_miro_write(chip, reg, (oldval & ~mask) | (value & mask));\n}\n\n \n\nstatic void snd_miro_proc_read(struct snd_info_entry * entry, \n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_miro *miro = (struct snd_miro *) entry->private_data;\n\tstruct snd_miro_aci *aci = miro->aci;\n\tchar* model = \"unknown\";\n\n\t \n\n\tif ((miro->hardware == OPTi9XX_HW_82C929) &&\n\t    (aci->aci_vendor == 'm') &&\n\t    (aci->aci_product == 'A')) {\n\t\tswitch (aci->aci_version) {\n\t\tcase 3:\n\t\t\tmodel = \"miroSOUND PCM1 pro\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmodel = \"miroSOUND PCM1 pro / (early) PCM12\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif ((miro->hardware == OPTi9XX_HW_82C924) &&\n\t    (aci->aci_vendor == 'm') &&\n\t    (aci->aci_product == 'B')) {\n\t\tswitch (aci->aci_version) {\n\t\tcase 4:\n\t\t\tmodel = \"miroSOUND PCM12\";\n\t\t\tbreak;\n\t\tcase 176:\n\t\t\tmodel = \"miroSOUND PCM12 (Rev. E)\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmodel = \"miroSOUND PCM12 / PCM12 pnp\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif ((miro->hardware == OPTi9XX_HW_82C924) &&\n\t    (aci->aci_vendor == 'm') &&\n\t    (aci->aci_product == 'C')) {\n\t\tswitch (aci->aci_version) {\n\t\tcase 7:\n\t\t\tmodel = \"miroSOUND PCM20 radio (Rev. E)\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmodel = \"miroSOUND PCM20 radio\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsnd_iprintf(buffer, \"\\nGeneral information:\\n\");\n\tsnd_iprintf(buffer, \"  model   : %s\\n\", model);\n\tsnd_iprintf(buffer, \"  opti    : %s\\n\", miro->name);\n\tsnd_iprintf(buffer, \"  codec   : %s\\n\", miro->pcm->name);\n\tsnd_iprintf(buffer, \"  port    : 0x%lx\\n\", miro->wss_base);\n\tsnd_iprintf(buffer, \"  irq     : %d\\n\", miro->irq);\n\tsnd_iprintf(buffer, \"  dma     : %d,%d\\n\\n\", miro->dma1, miro->dma2);\n\n\tsnd_iprintf(buffer, \"MPU-401:\\n\");\n\tsnd_iprintf(buffer, \"  port    : 0x%lx\\n\", miro->mpu_port);\n\tsnd_iprintf(buffer, \"  irq     : %d\\n\\n\", miro->mpu_irq);\n\n\tsnd_iprintf(buffer, \"ACI information:\\n\");\n\tsnd_iprintf(buffer, \"  vendor  : \");\n\tswitch (aci->aci_vendor) {\n\tcase 'm':\n\t\tsnd_iprintf(buffer, \"Miro\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsnd_iprintf(buffer, \"unknown (0x%x)\\n\", aci->aci_vendor);\n\t\tbreak;\n\t}\n\n\tsnd_iprintf(buffer, \"  product : \");\n\tswitch (aci->aci_product) {\n\tcase 'A':\n\t\tsnd_iprintf(buffer, \"miroSOUND PCM1 pro / (early) PCM12\\n\");\n\t\tbreak;\n\tcase 'B':\n\t\tsnd_iprintf(buffer, \"miroSOUND PCM12\\n\");\n\t\tbreak;\n\tcase 'C':\n\t\tsnd_iprintf(buffer, \"miroSOUND PCM20 radio\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsnd_iprintf(buffer, \"unknown (0x%x)\\n\", aci->aci_product);\n\t\tbreak;\n\t}\n\n\tsnd_iprintf(buffer, \"  firmware: %d (0x%x)\\n\",\n\t\t    aci->aci_version, aci->aci_version);\n\tsnd_iprintf(buffer, \"  port    : 0x%lx-0x%lx\\n\", \n\t\t    aci->aci_port, aci->aci_port+2);\n\tsnd_iprintf(buffer, \"  wss     : 0x%x\\n\", wss);\n\tsnd_iprintf(buffer, \"  ide     : 0x%x\\n\", ide);\n\tsnd_iprintf(buffer, \"  solomode: 0x%x\\n\", aci->aci_solomode);\n\tsnd_iprintf(buffer, \"  amp     : 0x%x\\n\", aci->aci_amp);\n\tsnd_iprintf(buffer, \"  preamp  : 0x%x\\n\", aci->aci_preamp);\n}\n\nstatic void snd_miro_proc_init(struct snd_card *card,\n\t\t\t       struct snd_miro *miro)\n{\n\tsnd_card_ro_proc_new(card, \"miro\", miro, snd_miro_proc_read);\n}\n\n \n\nstatic int snd_miro_configure(struct snd_miro *chip)\n{\n\tunsigned char wss_base_bits;\n\tunsigned char irq_bits;\n\tunsigned char dma_bits;\n\tunsigned char mpu_port_bits = 0;\n\tunsigned char mpu_irq_bits;\n\tunsigned long flags;\n\n\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\n\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20);  \n\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\n\n\tswitch (chip->hardware) {\n\tcase OPTi9XX_HW_82C924:\n\t\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);\n\t\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);\n\t\tbreak;\n\tcase OPTi9XX_HW_82C929:\n\t\t \n\t\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"chip %d not supported\\n\", chip->hardware);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (chip->wss_base & 0x3ff) {\n\tcase 0x130:\n\t\tchip->wss_base = 0x530;\n\t\twss_base_bits = 0x00;\n\t\tbreak;\n\tcase 0x204:\n\t\tchip->wss_base = 0x604;\n\t\twss_base_bits = 0x03;\n\t\tbreak;\n\tcase 0x280:\n\t\tchip->wss_base = 0xe80;\n\t\twss_base_bits = 0x01;\n\t\tbreak;\n\tcase 0x340:\n\t\tchip->wss_base = 0xf40;\n\t\twss_base_bits = 0x02;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"WSS port 0x%lx not valid\\n\", chip->wss_base);\n\t\tgoto __skip_base;\n\t}\n\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);\n\n__skip_base:\n\tswitch (chip->irq) {\n\tcase 5:\n\t\tirq_bits = 0x05;\n\t\tbreak;\n\tcase 7:\n\t\tirq_bits = 0x01;\n\t\tbreak;\n\tcase 9:\n\t\tirq_bits = 0x02;\n\t\tbreak;\n\tcase 10:\n\t\tirq_bits = 0x03;\n\t\tbreak;\n\tcase 11:\n\t\tirq_bits = 0x04;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"WSS irq # %d not valid\\n\", chip->irq);\n\t\tgoto __skip_resources;\n\t}\n\n\tswitch (chip->dma1) {\n\tcase 0:\n\t\tdma_bits = 0x01;\n\t\tbreak;\n\tcase 1:\n\t\tdma_bits = 0x02;\n\t\tbreak;\n\tcase 3:\n\t\tdma_bits = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"WSS dma1 # %d not valid\\n\", chip->dma1);\n\t\tgoto __skip_resources;\n\t}\n\n\tif (chip->dma1 == chip->dma2) {\n\t\tsnd_printk(KERN_ERR \"don't want to share dmas\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (chip->dma2) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"WSS dma2 # %d not valid\\n\", chip->dma2);\n\t\tgoto __skip_resources;\n\t}\n\tdma_bits |= 0x04;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(irq_bits << 3 | dma_bits, chip->wss_base);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n__skip_resources:\n\tif (chip->hardware > OPTi9XX_HW_82C928) {\n\t\tswitch (chip->mpu_port) {\n\t\tcase 0:\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0x300:\n\t\t\tmpu_port_bits = 0x03;\n\t\t\tbreak;\n\t\tcase 0x310:\n\t\t\tmpu_port_bits = 0x02;\n\t\t\tbreak;\n\t\tcase 0x320:\n\t\t\tmpu_port_bits = 0x01;\n\t\t\tbreak;\n\t\tcase 0x330:\n\t\t\tmpu_port_bits = 0x00;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_ERR \"MPU-401 port 0x%lx not valid\\n\",\n\t\t\t\t   chip->mpu_port);\n\t\t\tgoto __skip_mpu;\n\t\t}\n\n\t\tswitch (chip->mpu_irq) {\n\t\tcase 5:\n\t\t\tmpu_irq_bits = 0x02;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmpu_irq_bits = 0x03;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmpu_irq_bits = 0x00;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmpu_irq_bits = 0x01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_ERR \"MPU-401 irq # %d not valid\\n\",\n\t\t\t\t   chip->mpu_irq);\n\t\t\tgoto __skip_mpu;\n\t\t}\n\n\t\tsnd_miro_write_mask(chip, OPTi9XX_MC_REG(6),\n\t\t\t(chip->mpu_port <= 0) ? 0x00 :\n\t\t\t\t0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,\n\t\t\t0xf8);\n\t}\n__skip_mpu:\n\n\treturn 0;\n}\n\nstatic int snd_miro_opti_check(struct snd_card *card, struct snd_miro *chip)\n{\n\tunsigned char value;\n\n\tchip->res_mc_base =\n\t\tdevm_request_region(card->dev, chip->mc_base,\n\t\t\t\t    chip->mc_base_size, \"OPTi9xx MC\");\n\tif (chip->res_mc_base == NULL)\n\t\treturn -ENOMEM;\n\n\tvalue = snd_miro_read(chip, OPTi9XX_MC_REG(1));\n\tif (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))\n\t\tif (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))\n\t\t\treturn 0;\n\n\tdevm_release_resource(card->dev, chip->res_mc_base);\n\tchip->res_mc_base = NULL;\n\n\treturn -ENODEV;\n}\n\nstatic int snd_card_miro_detect(struct snd_card *card,\n\t\t\t\tstruct snd_miro *chip)\n{\n\tint i, err;\n\n\tfor (i = OPTi9XX_HW_82C929; i <= OPTi9XX_HW_82C924; i++) {\n\n\t\terr = snd_miro_init(chip, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_miro_opti_check(card, chip);\n\t\tif (err == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int snd_card_miro_aci_detect(struct snd_card *card,\n\t\t\t\t    struct snd_miro *miro)\n{\n\tunsigned char regval;\n\tint i;\n\tstruct snd_miro_aci *aci = &aci_device;\n\n\tmiro->aci = aci;\n\n\tmutex_init(&aci->aci_mutex);\n\n\t \n\n\tregval=inb(miro->mc_base + 4);\n\taci->aci_port = (regval & 0x10) ? 0x344 : 0x354;\n\n\tmiro->res_aci_port =\n\t\tdevm_request_region(card->dev, aci->aci_port, 3, \"miro aci\");\n\tif (miro->res_aci_port == NULL) {\n\t\tsnd_printk(KERN_ERR \"aci i/o area 0x%lx-0x%lx already used.\\n\", \n\t\t\t   aci->aci_port, aci->aci_port+2);\n\t\treturn -ENOMEM;\n\t}\n\n         \n\tfor (i = 0; i < 3; i++)\n\t\tif (snd_aci_cmd(aci, ACI_ERROR_OP, -1, -1) < 0) {\n\t\t\tsnd_printk(KERN_ERR \"can't force aci into known state.\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\taci->aci_vendor = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);\n\taci->aci_product = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);\n\tif (aci->aci_vendor < 0 || aci->aci_product < 0) {\n\t\tsnd_printk(KERN_ERR \"can't read aci id on 0x%lx.\\n\",\n\t\t\t   aci->aci_port);\n\t\treturn -ENXIO;\n\t}\n\n\taci->aci_version = snd_aci_cmd(aci, ACI_READ_VERSION, -1, -1);\n\tif (aci->aci_version < 0) {\n\t\tsnd_printk(KERN_ERR \"can't read aci version on 0x%lx.\\n\", \n\t\t\t   aci->aci_port);\n\t\treturn -ENXIO;\n\t}\n\n\tif (snd_aci_cmd(aci, ACI_INIT, -1, -1) < 0 ||\n\t    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||\n\t    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {\n\t\tsnd_printk(KERN_ERR \"can't initialize aci.\\n\"); \n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_miro_probe(struct snd_card *card)\n{\n\tint error;\n\tstruct snd_miro *miro = card->private_data;\n\tstruct snd_wss *codec;\n\tstruct snd_rawmidi *rmidi;\n\n\tif (!miro->res_mc_base) {\n\t\tmiro->res_mc_base = devm_request_region(card->dev,\n\t\t\t\t\t\t\tmiro->mc_base,\n\t\t\t\t\t\t\tmiro->mc_base_size,\n\t\t\t\t\t\t\t\"miro (OPTi9xx MC)\");\n\t\tif (miro->res_mc_base == NULL) {\n\t\t\tsnd_printk(KERN_ERR \"request for OPTI9xx MC failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\terror = snd_card_miro_aci_detect(card, miro);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"unable to detect aci chip\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmiro->wss_base = port;\n\tmiro->mpu_port = mpu_port;\n\tmiro->irq = irq;\n\tmiro->mpu_irq = mpu_irq;\n\tmiro->dma1 = dma1;\n\tmiro->dma2 = dma2;\n\n\t \n\tsnd_miro_proc_init(card, miro);\n\n\terror = snd_miro_configure(miro);\n\tif (error)\n\t\treturn error;\n\n\terror = snd_wss_create(card, miro->wss_base + 4, -1,\n\t\t\t       miro->irq, miro->dma1, miro->dma2,\n\t\t\t       WSS_HW_DETECT, 0, &codec);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_wss_pcm(codec, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_wss_mixer(codec);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_wss_timer(codec, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tmiro->pcm = codec->pcm;\n\n\terror = snd_miro_mixer(card, miro);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (miro->aci->aci_vendor == 'm') {\n\t\t \n\t\tswitch (miro->aci->aci_product) {\n\t\tcase 'A':\n\t\t\tsprintf(card->shortname, \n\t\t\t\t\"miroSOUND PCM1 pro / PCM12\");\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tsprintf(card->shortname, \n\t\t\t\t\"miroSOUND PCM12\");\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tsprintf(card->shortname, \n\t\t\t\t\"miroSOUND PCM20 radio\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(card->shortname, \n\t\t\t\t\"unknown miro\");\n\t\t\tsnd_printk(KERN_INFO \"unknown miro aci id\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsnd_printk(KERN_INFO \"found unsupported aci card\\n\");\n\t\tsprintf(card->shortname, \"unknown Cardinal Technologies\");\n\t}\n\n\tstrcpy(card->driver, \"miro\");\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d\",\n\t\t  card->shortname, miro->name, codec->pcm->name,\n\t\t  miro->wss_base + 4, miro->irq, miro->dma1, miro->dma2);\n\n\tif (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)\n\t\trmidi = NULL;\n\telse {\n\t\terror = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\tmpu_port, 0, miro->mpu_irq, &rmidi);\n\t\tif (error < 0)\n\t\t\tsnd_printk(KERN_WARNING \"no MPU-401 device at 0x%lx?\\n\",\n\t\t\t\t   mpu_port);\n\t}\n\n\tif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\n\t\tstruct snd_opl3 *opl3 = NULL;\n\t\tstruct snd_opl4 *opl4;\n\n\t\tif (snd_opl4_create(card, fm_port, fm_port - 8,\n\t\t\t\t    2, &opl3, &opl4) < 0)\n\t\t\tsnd_printk(KERN_WARNING \"no OPL4 device at 0x%lx\\n\",\n\t\t\t\t   fm_port);\n\t}\n\n\terror = snd_set_aci_init_values(miro);\n\tif (error < 0)\n                return error;\n\n\treturn snd_card_register(card);\n}\n\nstatic int snd_miro_isa_match(struct device *devptr, unsigned int n)\n{\n#ifdef CONFIG_PNP\n\tif (snd_miro_pnp_is_probed)\n\t\treturn 0;\n\tif (isapnp)\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\nstatic int snd_miro_isa_probe(struct device *devptr, unsigned int n)\n{\n\tstatic const long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};\n\tstatic const long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};\n\tstatic const int possible_irqs[] = {11, 9, 10, 7, -1};\n\tstatic const int possible_mpu_irqs[] = {10, 5, 9, 7, -1};\n\tstatic const int possible_dma1s[] = {3, 1, 0, -1};\n\tstatic const int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},\n\t\t\t\t\t   {0, -1} };\n\n\tint error;\n\tstruct snd_miro *miro;\n\tstruct snd_card *card;\n\n\terror = snd_devm_card_new(devptr, index, id, THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_miro), &card);\n\tif (error < 0)\n\t\treturn error;\n\n\tmiro = card->private_data;\n\n\terror = snd_card_miro_detect(card, miro);\n\tif (error < 0) {\n\t\tsnd_printk(KERN_ERR \"unable to detect OPTi9xx chip\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (port == SNDRV_AUTO_PORT) {\n\t\tport = snd_legacy_find_free_ioport(possible_ports, 4);\n\t\tif (port < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free WSS port\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (mpu_port == SNDRV_AUTO_PORT) {\n\t\tmpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);\n\t\tif (mpu_port < 0) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"unable to find a free MPU401 port\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (irq == SNDRV_AUTO_IRQ) {\n\t\tirq = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (mpu_irq == SNDRV_AUTO_IRQ) {\n\t\tmpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs);\n\t\tif (mpu_irq < 0) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"unable to find a free MPU401 IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1 == SNDRV_AUTO_DMA) {\n\t\tdma1 = snd_legacy_find_free_dma(possible_dma1s);\n\t\tif (dma1 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma2 == SNDRV_AUTO_DMA) {\n\t\tdma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4]);\n\t\tif (dma2 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA2\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\terror = snd_miro_probe(card);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#define DEV_NAME \"miro\"\n\nstatic struct isa_driver snd_miro_driver = {\n\t.match\t\t= snd_miro_isa_match,\n\t.probe\t\t= snd_miro_isa_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n#ifdef CONFIG_PNP\n\nstatic int snd_card_miro_pnp(struct snd_miro *chip,\n\t\t\t     struct pnp_card_link *card,\n\t\t\t     const struct pnp_card_device_id *pid)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\tstruct pnp_dev *devmpu;\n\tstruct pnp_dev *devmc;\n\n\tpdev = pnp_request_card_device(card, pid->devs[0].id, NULL);\n\tif (pdev == NULL)\n\t\treturn -EBUSY;\n\n\tdevmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);\n\tif (devmpu == NULL)\n\t\treturn -EBUSY;\n\n\tdevmc = pnp_request_card_device(card, pid->devs[2].id, NULL);\n\tif (devmc == NULL)\n\t\treturn -EBUSY;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"AUDIO pnp configure failure: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = pnp_activate_dev(devmc);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"MC pnp configure failure: %d\\n\",\n\t\t\t\t    err);\n\t\treturn err;\n\t}\n\n\tport = pnp_port_start(pdev, 1);\n\tfm_port = pnp_port_start(pdev, 2) + 8;\n\n\t \n\tchip->mc_base = pnp_port_start(devmc, 0) - 1;\n\tchip->mc_base_size = pnp_port_len(devmc, 0) + 1;\n\n\tirq = pnp_irq(pdev, 0);\n\tdma1 = pnp_dma(pdev, 0);\n\tdma2 = pnp_dma(pdev, 1);\n\n\tif (mpu_port > 0) {\n\t\terr = pnp_activate_dev(devmpu);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"MPU401 pnp configure failure\\n\");\n\t\t\tmpu_port = -1;\n\t\t\treturn err;\n\t\t}\n\t\tmpu_port = pnp_port_start(devmpu, 0);\n\t\tmpu_irq = pnp_irq(devmpu, 0);\n\t}\n\treturn 0;\n}\n\nstatic int snd_miro_pnp_probe(struct pnp_card_link *pcard,\n\t\t\t      const struct pnp_card_device_id *pid)\n{\n\tstruct snd_card *card;\n\tint err;\n\tstruct snd_miro *miro;\n\n\tif (snd_miro_pnp_is_probed)\n\t\treturn -EBUSY;\n\tif (!isapnp)\n\t\treturn -ENODEV;\n\terr = snd_devm_card_new(&pcard->card->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(struct snd_miro), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tmiro = card->private_data;\n\n\terr = snd_card_miro_pnp(miro, pcard, pid);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = snd_miro_init(miro, OPTi9XX_HW_82C924);\n\tif (err)\n\t\treturn err;\n\n\terr = snd_miro_opti_check(card, miro);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR \"OPTI chip not found\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_miro_probe(card);\n\tif (err < 0)\n\t\treturn err;\n\tpnp_set_card_drvdata(pcard, card);\n\tsnd_miro_pnp_is_probed = 1;\n\treturn 0;\n}\n\nstatic void snd_miro_pnp_remove(struct pnp_card_link *pcard)\n{\n\tsnd_miro_pnp_is_probed = 0;\n}\n\nstatic struct pnp_card_driver miro_pnpc_driver = {\n\t.flags\t\t= PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= \"miro\",\n\t.id_table\t= snd_miro_pnpids,\n\t.probe\t\t= snd_miro_pnp_probe,\n\t.remove\t\t= snd_miro_pnp_remove,\n};\n#endif\n\nstatic int __init alsa_card_miro_init(void)\n{\n#ifdef CONFIG_PNP\n\tpnp_register_card_driver(&miro_pnpc_driver);\n\tif (snd_miro_pnp_is_probed)\n\t\treturn 0;\n\tpnp_unregister_card_driver(&miro_pnpc_driver);\n#endif\n\treturn isa_register_driver(&snd_miro_driver, 1);\n}\n\nstatic void __exit alsa_card_miro_exit(void)\n{\n\tif (!snd_miro_pnp_is_probed) {\n\t\tisa_unregister_driver(&snd_miro_driver);\n\t\treturn;\n\t}\n#ifdef CONFIG_PNP\n\tpnp_unregister_card_driver(&miro_pnpc_driver);\n#endif\n}\n\nmodule_init(alsa_card_miro_init)\nmodule_exit(alsa_card_miro_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}