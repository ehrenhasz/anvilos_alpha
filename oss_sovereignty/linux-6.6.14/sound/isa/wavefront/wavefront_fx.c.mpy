{
  "module_name": "wavefront_fx.c",
  "hash_id": "4a812e01996f40a0493cf7d6e922794efab6eea4ba6e483efcf6174360791d99",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/wavefront/wavefront_fx.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/snd_wavefront.h>\n#include <sound/initval.h>\n\n \n\n#define FX_LSB_TRANSFER 0x01     \n#define FX_MSB_TRANSFER 0x02     \n#define FX_AUTO_INCR    0x04     \n\n#define WAIT_IDLE\t0xff\n\nstatic int\nwavefront_fx_idle (snd_wavefront_t *dev)\n\n{\n\tint i;\n\tunsigned int x = 0x80;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tx = inb (dev->fx_status);\n\t\tif ((x & 0x80) == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (x & 0x80) {\n\t\tsnd_printk (\"FX device never idle.\\n\");\n\t\treturn 0;\n\t}\n\n\treturn (1);\n}\n\nstatic void\nwavefront_fx_mute (snd_wavefront_t *dev, int onoff)\n\n{\n\tif (!wavefront_fx_idle(dev)) {\n\t\treturn;\n\t}\n\n\toutb (onoff ? 0x02 : 0x00, dev->fx_op);\n}\n\nstatic int\nwavefront_fx_memset (snd_wavefront_t *dev,\n\t\t     int page,\n\t\t     int addr,\n\t\t     int cnt,\n\t\t     unsigned short *data)\n{\n\tif (page < 0 || page > 7) {\n\t\tsnd_printk (\"FX memset: \"\n\t\t\t\"page must be >= 0 and <= 7\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (addr < 0 || addr > 0x7f) {\n\t\tsnd_printk (\"FX memset: \"\n\t\t\t\"addr must be >= 0 and <= 7f\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cnt == 1) {\n\n\t\toutb (FX_LSB_TRANSFER, dev->fx_lcr);\n\t\toutb (page, dev->fx_dsp_page);\n\t\toutb (addr, dev->fx_dsp_addr);\n\t\toutb ((data[0] >> 8), dev->fx_dsp_msb);\n\t\toutb ((data[0] & 0xff), dev->fx_dsp_lsb);\n\n\t\tsnd_printk (\"FX: addr %d:%x set to 0x%x\\n\",\n\t\t\tpage, addr, data[0]);\n\n\t} else {\n\t\tint i;\n\n\t\toutb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);\n\t\toutb (page, dev->fx_dsp_page);\n\t\toutb (addr, dev->fx_dsp_addr);\n\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\toutb ((data[i] >> 8), dev->fx_dsp_msb);\n\t\t\toutb ((data[i] & 0xff), dev->fx_dsp_lsb);\n\t\t\tif (!wavefront_fx_idle (dev)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i != cnt) {\n\t\t\tsnd_printk (\"FX memset \"\n\t\t\t\t    \"(0x%x, 0x%x, 0x%lx, %d) incomplete\\n\",\n\t\t\t\t    page, addr, (unsigned long) data, cnt);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nsnd_wavefront_fx_detect (snd_wavefront_t *dev)\n\n{\n\t \n\n\tif (inb (dev->fx_status) & 0x80) {\n\t\tsnd_printk (\"Hmm, probably a Maui or Tropez.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint\nsnd_wavefront_fx_open (struct snd_hwdep *hw, struct file *file)\n\n{\n\tif (!try_module_get(hw->card->module))\n\t\treturn -EFAULT;\n\tfile->private_data = hw;\n\treturn 0;\n}\n\nint \nsnd_wavefront_fx_release (struct snd_hwdep *hw, struct file *file)\n\n{\n\tmodule_put(hw->card->module);\n\treturn 0;\n}\n\nint\nsnd_wavefront_fx_ioctl (struct snd_hwdep *sdev, struct file *file,\n\t\t\tunsigned int cmd, unsigned long arg)\n\n{\n\tstruct snd_card *card;\n\tsnd_wavefront_card_t *acard;\n\tsnd_wavefront_t *dev;\n\twavefront_fx_info r;\n\tunsigned short *page_data = NULL;\n\tunsigned short *pd;\n\tint err = 0;\n\n\tcard = sdev->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENODEV;\n\tif (snd_BUG_ON(!card->private_data))\n\t\treturn -ENODEV;\n\n\tacard = card->private_data;\n\tdev = &acard->wavefront;\n\n\tif (copy_from_user (&r, (void __user *)arg, sizeof (wavefront_fx_info)))\n\t\treturn -EFAULT;\n\n\tswitch (r.request) {\n\tcase WFFX_MUTE:\n\t\twavefront_fx_mute (dev, r.data[0]);\n\t\treturn -EIO;\n\n\tcase WFFX_MEMSET:\n\t\tif (r.data[2] <= 0) {\n\t\t\tsnd_printk (\"cannot write \"\n\t\t\t\t\"<= 0 bytes to FX\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (r.data[2] == 1) {\n\t\t\tpd = (unsigned short *) &r.data[3];\n\t\t} else {\n\t\t\tif (r.data[2] > 256) {\n\t\t\t\tsnd_printk (\"cannot write \"\n\t\t\t\t\t    \"> 512 bytes to FX\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tpage_data = memdup_user((unsigned char __user *)\n\t\t\t\t\t\tr.data[3],\n\t\t\t\t\t\tr.data[2] * sizeof(short));\n\t\t\tif (IS_ERR(page_data))\n\t\t\t\treturn PTR_ERR(page_data);\n\t\t\tpd = page_data;\n\t\t}\n\n\t\terr = wavefront_fx_memset (dev,\n\t\t\t     r.data[0],  \n\t\t\t     r.data[1],  \n\t\t\t     r.data[2],  \n\t\t\t     pd);\n\t\tkfree(page_data);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printk (\"FX: ioctl %d not yet supported\\n\",\n\t\t\t    r.request);\n\t\treturn -ENOTTY;\n\t}\n\treturn err;\n}\n\n \n\nint\nsnd_wavefront_fx_start (snd_wavefront_t *dev)\n{\n\tunsigned int i;\n\tint err;\n\tconst struct firmware *firmware = NULL;\n\n\tif (dev->fx_initialized)\n\t\treturn 0;\n\n\terr = request_firmware(&firmware, \"yamaha/yss225_registers.bin\",\n\t\t\t       dev->card->dev);\n\tif (err < 0) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i + 1 < firmware->size; i += 2) {\n\t\tif (firmware->data[i] >= 8 && firmware->data[i] < 16) {\n\t\t\toutb(firmware->data[i + 1],\n\t\t\t     dev->base + firmware->data[i]);\n\t\t} else if (firmware->data[i] == WAIT_IDLE) {\n\t\t\tif (!wavefront_fx_idle(dev)) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tsnd_printk(KERN_ERR \"invalid address\"\n\t\t\t\t   \" in register data\\n\");\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev->fx_initialized = 1;\n\terr = 0;\n\nout:\n\trelease_firmware(firmware);\n\treturn err;\n}\n\nMODULE_FIRMWARE(\"yamaha/yss225_registers.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}