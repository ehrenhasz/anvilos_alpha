{
  "module_name": "wavefront_midi.c",
  "hash_id": "524b68376ea51129acd81eb9141958f13df6e1fe8ea45ed2031fa6f4f3ff0ced",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/wavefront/wavefront_midi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <sound/core.h>\n#include <sound/snd_wavefront.h>\n\nstatic inline int \nwf_mpu_status (snd_wavefront_midi_t *midi)\n\n{\n\treturn inb (midi->mpu_status_port);\n}\n\nstatic inline int \ninput_avail (snd_wavefront_midi_t *midi)\n\n{\n\treturn !(wf_mpu_status(midi) & INPUT_AVAIL);\n}\n\nstatic inline int\noutput_ready (snd_wavefront_midi_t *midi)\n\n{\n\treturn !(wf_mpu_status(midi) & OUTPUT_READY);\n}\n\nstatic inline int \nread_data (snd_wavefront_midi_t *midi)\n\n{\n\treturn inb (midi->mpu_data_port);\n}\n\nstatic inline void \nwrite_data (snd_wavefront_midi_t *midi, unsigned char byte)\n\n{\n\toutb (byte, midi->mpu_data_port);\n}\n\nstatic snd_wavefront_midi_t *\nget_wavefront_midi (struct snd_rawmidi_substream *substream)\n\n{\n\tstruct snd_card *card;\n\tsnd_wavefront_card_t *acard;\n\n\tif (substream == NULL || substream->rmidi == NULL) \n\t        return NULL;\n\n\tcard = substream->rmidi->card;\n\n\tif (card == NULL) \n\t        return NULL;\n\n\tif (card->private_data == NULL) \n \t        return NULL;\n\n\tacard = card->private_data;\n\n\treturn &acard->wavefront.midi;\n}\n\nstatic void snd_wavefront_midi_output_write(snd_wavefront_card_t *card)\n{\n\tsnd_wavefront_midi_t *midi = &card->wavefront.midi;\n\tsnd_wavefront_mpu_id  mpu;\n\tunsigned long flags;\n\tunsigned char midi_byte;\n\tint max = 256, mask = 1;\n\tint timeout;\n\n\t \n\n\tif (midi->substream_output[midi->output_mpu] == NULL) {\n\t\tgoto __second;\n\t}\n\n\twhile (max > 0) {\n\n\t\t \n\n\t\tfor (timeout = 30000; timeout > 0; timeout--) {\n\t\t\tif (output_ready (midi))\n\t\t\t\tbreak;\n\t\t}\n\t\n\t\tspin_lock_irqsave (&midi->virtual, flags);\n\t\tif ((midi->mode[midi->output_mpu] & MPU401_MODE_OUTPUT) == 0) {\n\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\tgoto __second;\n\t\t}\n\t\tif (output_ready (midi)) {\n\t\t\tif (snd_rawmidi_transmit(midi->substream_output[midi->output_mpu], &midi_byte, 1) == 1) {\n\t\t\t\tif (!midi->isvirtual ||\n\t\t\t\t\t(midi_byte != WF_INTERNAL_SWITCH &&\n\t\t\t\t\t midi_byte != WF_EXTERNAL_SWITCH))\n\t\t\t\t\twrite_data(midi, midi_byte);\n\t\t\t\tmax--;\n\t\t\t} else {\n\t\t\t\tif (midi->istimer) {\n\t\t\t\t\tif (--midi->istimer <= 0)\n\t\t\t\t\t\tdel_timer(&midi->timer);\n\t\t\t\t}\n\t\t\t\tmidi->mode[midi->output_mpu] &= ~MPU401_MODE_OUTPUT_TRIGGER;\n\t\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\t\tgoto __second;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t}\n\n      __second:\n\n\tif (midi->substream_output[!midi->output_mpu] == NULL) {\n\t\treturn;\n\t}\n\n\twhile (max > 0) {\n\n\t\t \n\n\t\tfor (timeout = 30000; timeout > 0; timeout--) {\n\t\t\tif (output_ready (midi))\n\t\t\t\tbreak;\n\t\t}\n\t\n\t\tspin_lock_irqsave (&midi->virtual, flags);\n\t\tif (!midi->isvirtual)\n\t\t\tmask = 0;\n\t\tmpu = midi->output_mpu ^ mask;\n\t\tmask = 0;\t \n\t\tif ((midi->mode[mpu] & MPU401_MODE_OUTPUT) == 0) {\n\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\treturn;\n\t\t}\n\t\tif (snd_rawmidi_transmit_empty(midi->substream_output[mpu]))\n\t\t\tgoto __timer;\n\t\tif (output_ready (midi)) {\n\t\t\tif (mpu != midi->output_mpu) {\n\t\t\t\twrite_data(midi, mpu == internal_mpu ?\n\t\t\t\t\t\t\tWF_INTERNAL_SWITCH :\n\t\t\t\t\t\t\tWF_EXTERNAL_SWITCH);\n\t\t\t\tmidi->output_mpu = mpu;\n\t\t\t} else if (snd_rawmidi_transmit(midi->substream_output[mpu], &midi_byte, 1) == 1) {\n\t\t\t\tif (!midi->isvirtual ||\n\t\t\t\t\t(midi_byte != WF_INTERNAL_SWITCH &&\n\t\t\t\t\t midi_byte != WF_EXTERNAL_SWITCH))\n\t\t\t\t\twrite_data(midi, midi_byte);\n\t\t\t\tmax--;\n\t\t\t} else {\n\t\t\t      __timer:\n\t\t\t\tif (midi->istimer) {\n\t\t\t\t\tif (--midi->istimer <= 0)\n\t\t\t\t\t\tdel_timer(&midi->timer);\n\t\t\t\t}\n\t\t\t\tmidi->mode[mpu] &= ~MPU401_MODE_OUTPUT_TRIGGER;\n\t\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore (&midi->virtual, flags);\n\t}\n}\n\nstatic int snd_wavefront_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (snd_BUG_ON(!substream || !substream->rmidi))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!substream->rmidi->private_data))\n\t\treturn -ENXIO;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t        return -EIO;\n\n\tspin_lock_irqsave (&midi->open, flags);\n\tmidi->mode[mpu] |= MPU401_MODE_INPUT;\n\tmidi->substream_input[mpu] = substream;\n\tspin_unlock_irqrestore (&midi->open, flags);\n\n\treturn 0;\n}\n\nstatic int snd_wavefront_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (snd_BUG_ON(!substream || !substream->rmidi))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!substream->rmidi->private_data))\n\t\treturn -ENXIO;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t        return -EIO;\n\n\tspin_lock_irqsave (&midi->open, flags);\n\tmidi->mode[mpu] |= MPU401_MODE_OUTPUT;\n\tmidi->substream_output[mpu] = substream;\n\tspin_unlock_irqrestore (&midi->open, flags);\n\n\treturn 0;\n}\n\nstatic int snd_wavefront_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (snd_BUG_ON(!substream || !substream->rmidi))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!substream->rmidi->private_data))\n\t\treturn -ENXIO;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t        return -EIO;\n\n\tspin_lock_irqsave (&midi->open, flags);\n\tmidi->mode[mpu] &= ~MPU401_MODE_INPUT;\n\tspin_unlock_irqrestore (&midi->open, flags);\n\n\treturn 0;\n}\n\nstatic int snd_wavefront_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (snd_BUG_ON(!substream || !substream->rmidi))\n\t\treturn -ENXIO;\n\tif (snd_BUG_ON(!substream->rmidi->private_data))\n\t\treturn -ENXIO;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t        return -EIO;\n\n\tspin_lock_irqsave (&midi->open, flags);\n\tmidi->mode[mpu] &= ~MPU401_MODE_OUTPUT;\n\tspin_unlock_irqrestore (&midi->open, flags);\n\treturn 0;\n}\n\nstatic void snd_wavefront_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (substream == NULL || substream->rmidi == NULL) \n\t        return;\n\n\tif (substream->rmidi->private_data == NULL)\n\t        return;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t\treturn;\n\n\tspin_lock_irqsave (&midi->virtual, flags);\n\tif (up) {\n\t\tmidi->mode[mpu] |= MPU401_MODE_INPUT_TRIGGER;\n\t} else {\n\t\tmidi->mode[mpu] &= ~MPU401_MODE_INPUT_TRIGGER;\n\t}\n\tspin_unlock_irqrestore (&midi->virtual, flags);\n}\n\nstatic void snd_wavefront_midi_output_timer(struct timer_list *t)\n{\n\tsnd_wavefront_midi_t *midi = from_timer(midi, t, timer);\n\tsnd_wavefront_card_t *card = midi->timer_card;\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave (&midi->virtual, flags);\n\tmod_timer(&midi->timer, 1 + jiffies);\n\tspin_unlock_irqrestore (&midi->virtual, flags);\n\tsnd_wavefront_midi_output_write(card);\n}\n\nstatic void snd_wavefront_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tsnd_wavefront_mpu_id mpu;\n\n\tif (substream == NULL || substream->rmidi == NULL) \n\t        return;\n\n\tif (substream->rmidi->private_data == NULL)\n\t        return;\n\n\tmpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);\n\n\tmidi = get_wavefront_midi(substream);\n\tif (!midi)\n\t\treturn;\n\n\tspin_lock_irqsave (&midi->virtual, flags);\n\tif (up) {\n\t\tif ((midi->mode[mpu] & MPU401_MODE_OUTPUT_TRIGGER) == 0) {\n\t\t\tif (!midi->istimer) {\n\t\t\t\ttimer_setup(&midi->timer,\n\t\t\t\t\t    snd_wavefront_midi_output_timer,\n\t\t\t\t\t    0);\n\t\t\t\tmod_timer(&midi->timer, 1 + jiffies);\n\t\t\t}\n\t\t\tmidi->istimer++;\n\t\t\tmidi->mode[mpu] |= MPU401_MODE_OUTPUT_TRIGGER;\n\t\t}\n\t} else {\n\t\tmidi->mode[mpu] &= ~MPU401_MODE_OUTPUT_TRIGGER;\n\t}\n\tspin_unlock_irqrestore (&midi->virtual, flags);\n\n\tif (up)\n\t\tsnd_wavefront_midi_output_write((snd_wavefront_card_t *)substream->rmidi->card->private_data);\n}\n\nvoid\nsnd_wavefront_midi_interrupt (snd_wavefront_card_t *card)\n\n{\n\tunsigned long flags;\n\tsnd_wavefront_midi_t *midi;\n\tstatic struct snd_rawmidi_substream *substream = NULL;\n\tstatic int mpu = external_mpu; \n\tint max = 128;\n\tunsigned char byte;\n\n\tmidi = &card->wavefront.midi;\n\n\tif (!input_avail (midi)) {  \n\t\tsnd_wavefront_midi_output_write(card);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave (&midi->virtual, flags);\n\twhile (--max) {\n\n\t\tif (input_avail (midi)) {\n\t\t\tbyte = read_data (midi);\n\n\t\t\tif (midi->isvirtual) {\t\t\t\t\n\t\t\t\tif (byte == WF_EXTERNAL_SWITCH) {\n\t\t\t\t\tsubstream = midi->substream_input[external_mpu];\n\t\t\t\t\tmpu = external_mpu;\n\t\t\t\t} else if (byte == WF_INTERNAL_SWITCH) { \n\t\t\t\t\tsubstream = midi->substream_output[internal_mpu];\n\t\t\t\t\tmpu = internal_mpu;\n\t\t\t\t}  \n\t\t\t} else {\n\t\t\t\tsubstream = midi->substream_input[internal_mpu];\n\t\t\t\tmpu = internal_mpu;\n\t\t\t}\n\n\t\t\tif (substream == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (midi->mode[mpu] & MPU401_MODE_INPUT_TRIGGER) {\n\t\t\t\tsnd_rawmidi_receive(substream, &byte, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} \n\tspin_unlock_irqrestore (&midi->virtual, flags);\n\n\tsnd_wavefront_midi_output_write(card);\n}\n\nvoid\nsnd_wavefront_midi_enable_virtual (snd_wavefront_card_t *card)\n\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&card->wavefront.midi.virtual, flags);\n\tcard->wavefront.midi.isvirtual = 1;\n\tcard->wavefront.midi.output_mpu = internal_mpu;\n\tcard->wavefront.midi.input_mpu = internal_mpu;\n\tspin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);\n}\n\nvoid\nsnd_wavefront_midi_disable_virtual (snd_wavefront_card_t *card)\n\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&card->wavefront.midi.virtual, flags);\n\t \n\t \n\tcard->wavefront.midi.isvirtual = 0;\n\tspin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);\n}\n\nint\nsnd_wavefront_midi_start (snd_wavefront_card_t *card)\n\n{\n\tint ok, i;\n\tunsigned char rbuf[4], wbuf[4];\n\tsnd_wavefront_t *dev;\n\tsnd_wavefront_midi_t *midi;\n\n\tdev = &card->wavefront;\n\tmidi = &dev->midi;\n\n\t \n\n\t \n\n\tfor (i = 0; i < 30000 && !output_ready (midi); i++);\n\n\tif (!output_ready (midi)) {\n\t\tsnd_printk (\"MIDI interface not ready for command\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\n\tdev->interrupts_are_midi = 1;\n\t\n\toutb (UART_MODE_ON, midi->mpu_command_port);\n\n\tfor (ok = 0, i = 50000; i > 0 && !ok; i--) {\n\t\tif (input_avail (midi)) {\n\t\t\tif (read_data (midi) == MPU_ACK) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\tsnd_printk (\"cannot set UART mode for MIDI interface\");\n\t\tdev->interrupts_are_midi = 0;\n\t\treturn -1;\n\t}\n\n\t \n    \n\tif (snd_wavefront_cmd (dev, WFC_MISYNTH_ON, rbuf, wbuf)) {\n\t\tsnd_printk (\"can't enable MIDI-IN-2-synth routing.\\n\");\n\t\t \n\t}\n\n\t \n\n\tif (snd_wavefront_cmd (dev, WFC_VMIDI_OFF, rbuf, wbuf)) { \n\t\tsnd_printk (\"virtual MIDI mode not disabled\\n\");\n\t\treturn 0;  \n\t}\n\n\tsnd_wavefront_midi_enable_virtual (card);\n\n\tif (snd_wavefront_cmd (dev, WFC_VMIDI_ON, rbuf, wbuf)) {\n\t\tsnd_printk (\"cannot enable virtual MIDI mode.\\n\");\n\t\tsnd_wavefront_midi_disable_virtual (card);\n\t} \n\treturn 0;\n}\n\nconst struct snd_rawmidi_ops snd_wavefront_midi_output =\n{\n\t.open =\t\tsnd_wavefront_midi_output_open,\n\t.close =\tsnd_wavefront_midi_output_close,\n\t.trigger =\tsnd_wavefront_midi_output_trigger,\n};\n\nconst struct snd_rawmidi_ops snd_wavefront_midi_input =\n{\n\t.open =\t\tsnd_wavefront_midi_input_open,\n\t.close =\tsnd_wavefront_midi_input_close,\n\t.trigger =\tsnd_wavefront_midi_input_trigger,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}