{
  "module_name": "wavefront_synth.c",
  "hash_id": "bfc89298446cff615cdaad3021baf82d346422b9e93c627d0e2d8957c0966f57",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/wavefront/wavefront_synth.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/snd_wavefront.h>\n#include <sound/initval.h>\n\nstatic int wf_raw = 0;  \n\t\t   \nstatic int fx_raw = 1;  \n\nstatic int debug_default = 0;   \n\n \n\n#define DEFAULT_OSPATH\t\"wavefront.os\"\nstatic char *ospath = DEFAULT_OSPATH;  \n\nstatic int wait_usecs = 150;  \n\nstatic int sleep_interval = 100;    \nstatic int sleep_tries = 50;        \n\nstatic int reset_time = 2;         \n\nstatic int ramcheck_time = 20;     \n\nstatic int osrun_time = 10;        \nmodule_param(wf_raw, int, 0444);\nMODULE_PARM_DESC(wf_raw, \"if non-zero, assume that we need to boot the OS\");\nmodule_param(fx_raw, int, 0444);\nMODULE_PARM_DESC(fx_raw, \"if non-zero, assume that the FX process needs help\");\nmodule_param(debug_default, int, 0444);\nMODULE_PARM_DESC(debug_default, \"debug parameters for card initialization\");\nmodule_param(wait_usecs, int, 0444);\nMODULE_PARM_DESC(wait_usecs, \"how long to wait without sleeping, usecs\");\nmodule_param(sleep_interval, int, 0444);\nMODULE_PARM_DESC(sleep_interval, \"how long to sleep when waiting for reply\");\nmodule_param(sleep_tries, int, 0444);\nMODULE_PARM_DESC(sleep_tries, \"how many times to try sleeping during a wait\");\nmodule_param(ospath, charp, 0444);\nMODULE_PARM_DESC(ospath, \"pathname to processed ICS2115 OS firmware\");\nmodule_param(reset_time, int, 0444);\nMODULE_PARM_DESC(reset_time, \"how long to wait for a reset to take effect\");\nmodule_param(ramcheck_time, int, 0444);\nMODULE_PARM_DESC(ramcheck_time, \"how many seconds to wait for the RAM test\");\nmodule_param(osrun_time, int, 0444);\nMODULE_PARM_DESC(osrun_time, \"how many seconds to wait for the ICS2115 OS\");\n\n \n\n#define WF_DEBUG 1\n\n#ifdef WF_DEBUG\n\n#define DPRINT(cond, ...) \\\n       if ((dev->debug & (cond)) == (cond)) { \\\n\t     snd_printk (__VA_ARGS__); \\\n       }\n#else\n#define DPRINT(cond, args...)\n#endif  \n\n#define LOGNAME \"WaveFront: \"\n\n \n\n#define STAT_RINTR_ENABLED\t0x01\n#define STAT_CAN_READ\t\t0x02\n#define STAT_INTR_READ\t\t0x04\n#define STAT_WINTR_ENABLED\t0x10\n#define STAT_CAN_WRITE\t\t0x20\n#define STAT_INTR_WRITE\t\t0x40\n\nstatic int wavefront_delete_sample (snd_wavefront_t *, int sampnum);\nstatic int wavefront_find_free_sample (snd_wavefront_t *);\n\nstruct wavefront_command {\n\tint cmd;\n\tchar *action;\n\tunsigned int read_cnt;\n\tunsigned int write_cnt;\n\tint need_ack;\n};\n\nstatic struct {\n\tint errno;\n\tconst char *errstr;\n} wavefront_errors[] = {\n\t{ 0x01, \"Bad sample number\" },\n\t{ 0x02, \"Out of sample memory\" },\n\t{ 0x03, \"Bad patch number\" },\n\t{ 0x04, \"Error in number of voices\" },\n\t{ 0x06, \"Sample load already in progress\" },\n\t{ 0x0B, \"No sample load request pending\" },\n\t{ 0x0E, \"Bad MIDI channel number\" },\n\t{ 0x10, \"Download Record Error\" },\n\t{ 0x80, \"Success\" },\n\t{ 0x0 }\n};\n\n#define NEEDS_ACK 1\n\nstatic struct wavefront_command wavefront_commands[] = {\n\t{ WFC_SET_SYNTHVOL, \"set synthesizer volume\", 0, 1, NEEDS_ACK },\n\t{ WFC_GET_SYNTHVOL, \"get synthesizer volume\", 1, 0, 0},\n\t{ WFC_SET_NVOICES, \"set number of voices\", 0, 1, NEEDS_ACK },\n\t{ WFC_GET_NVOICES, \"get number of voices\", 1, 0, 0 },\n\t{ WFC_SET_TUNING, \"set synthesizer tuning\", 0, 2, NEEDS_ACK },\n\t{ WFC_GET_TUNING, \"get synthesizer tuning\", 2, 0, 0 },\n\t{ WFC_DISABLE_CHANNEL, \"disable synth channel\", 0, 1, NEEDS_ACK },\n\t{ WFC_ENABLE_CHANNEL, \"enable synth channel\", 0, 1, NEEDS_ACK },\n\t{ WFC_GET_CHANNEL_STATUS, \"get synth channel status\", 3, 0, 0 },\n\t{ WFC_MISYNTH_OFF, \"disable midi-in to synth\", 0, 0, NEEDS_ACK },\n\t{ WFC_MISYNTH_ON, \"enable midi-in to synth\", 0, 0, NEEDS_ACK },\n\t{ WFC_VMIDI_ON, \"enable virtual midi mode\", 0, 0, NEEDS_ACK },\n\t{ WFC_VMIDI_OFF, \"disable virtual midi mode\", 0, 0, NEEDS_ACK },\n\t{ WFC_MIDI_STATUS, \"report midi status\", 1, 0, 0 },\n\t{ WFC_FIRMWARE_VERSION, \"report firmware version\", 2, 0, 0 },\n\t{ WFC_HARDWARE_VERSION, \"report hardware version\", 2, 0, 0 },\n\t{ WFC_GET_NSAMPLES, \"report number of samples\", 2, 0, 0 },\n\t{ WFC_INSTOUT_LEVELS, \"report instantaneous output levels\", 7, 0, 0 },\n\t{ WFC_PEAKOUT_LEVELS, \"report peak output levels\", 7, 0, 0 },\n\t{ WFC_DOWNLOAD_SAMPLE, \"download sample\",\n\t  0, WF_SAMPLE_BYTES, NEEDS_ACK },\n\t{ WFC_DOWNLOAD_BLOCK, \"download block\", 0, 0, NEEDS_ACK},\n\t{ WFC_DOWNLOAD_SAMPLE_HEADER, \"download sample header\",\n\t  0, WF_SAMPLE_HDR_BYTES, NEEDS_ACK },\n\t{ WFC_UPLOAD_SAMPLE_HEADER, \"upload sample header\", 13, 2, 0 },\n\n\t \n\n\t{ WFC_DOWNLOAD_MULTISAMPLE, \"download multisample\", 0, 0, NEEDS_ACK },\n\n\t \n\n\t{ WFC_UPLOAD_MULTISAMPLE, \"upload multisample\", 2, 1, 0 },\n\t{ WFC_DOWNLOAD_SAMPLE_ALIAS, \"download sample alias\",\n\t  0, WF_ALIAS_BYTES, NEEDS_ACK },\n\t{ WFC_UPLOAD_SAMPLE_ALIAS, \"upload sample alias\", WF_ALIAS_BYTES, 2, 0},\n\t{ WFC_DELETE_SAMPLE, \"delete sample\", 0, 2, NEEDS_ACK },\n\t{ WFC_IDENTIFY_SAMPLE_TYPE, \"identify sample type\", 5, 2, 0 },\n\t{ WFC_UPLOAD_SAMPLE_PARAMS, \"upload sample parameters\" },\n\t{ WFC_REPORT_FREE_MEMORY, \"report free memory\", 4, 0, 0 },\n\t{ WFC_DOWNLOAD_PATCH, \"download patch\", 0, 134, NEEDS_ACK },\n\t{ WFC_UPLOAD_PATCH, \"upload patch\", 132, 2, 0 },\n\t{ WFC_DOWNLOAD_PROGRAM, \"download program\", 0, 33, NEEDS_ACK },\n\t{ WFC_UPLOAD_PROGRAM, \"upload program\", 32, 1, 0 },\n\t{ WFC_DOWNLOAD_EDRUM_PROGRAM, \"download enhanced drum program\", 0, 9,\n\t  NEEDS_ACK},\n\t{ WFC_UPLOAD_EDRUM_PROGRAM, \"upload enhanced drum program\", 8, 1, 0},\n\t{ WFC_SET_EDRUM_CHANNEL, \"set enhanced drum program channel\",\n\t  0, 1, NEEDS_ACK },\n\t{ WFC_DISABLE_DRUM_PROGRAM, \"disable drum program\", 0, 1, NEEDS_ACK },\n\t{ WFC_REPORT_CHANNEL_PROGRAMS, \"report channel program numbers\",\n\t  32, 0, 0 },\n\t{ WFC_NOOP, \"the no-op command\", 0, 0, NEEDS_ACK },\n\t{ 0x00 }\n};\n\nstatic const char *\nwavefront_errorstr (int errnum)\n\n{\n\tint i;\n\n\tfor (i = 0; wavefront_errors[i].errstr; i++) {\n\t\tif (wavefront_errors[i].errno == errnum) {\n\t\t\treturn wavefront_errors[i].errstr;\n\t\t}\n\t}\n\n\treturn \"Unknown WaveFront error\";\n}\n\nstatic struct wavefront_command *\nwavefront_get_command (int cmd) \n\n{\n\tint i;\n\n\tfor (i = 0; wavefront_commands[i].cmd != 0; i++) {\n\t\tif (cmd == wavefront_commands[i].cmd) {\n\t\t\treturn &wavefront_commands[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic inline int\nwavefront_status (snd_wavefront_t *dev) \n\n{\n\treturn inb (dev->status_port);\n}\n\nstatic int\nwavefront_sleep (int limit)\n\n{\n\tschedule_timeout_interruptible(limit);\n\n\treturn signal_pending(current);\n}\n\nstatic int\nwavefront_wait (snd_wavefront_t *dev, int mask)\n\n{\n\tint             i;\n\n\t \n\n\tfor (i = 0; i < wait_usecs; i += 5) {\n\t\tif (wavefront_status (dev) & mask) {\n\t\t\treturn 1;\n\t\t}\n\t\tudelay(5);\n\t}\n\n\tfor (i = 0; i < sleep_tries; i++) {\n\n\t\tif (wavefront_status (dev) & mask) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (wavefront_sleep (HZ/sleep_interval)) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nwavefront_read (snd_wavefront_t *dev)\n\n{\n\tif (wavefront_wait (dev, STAT_CAN_READ))\n\t\treturn inb (dev->data_port);\n\n\tDPRINT (WF_DEBUG_DATA, \"read timeout.\\n\");\n\n\treturn -1;\n}\n\nstatic int\nwavefront_write (snd_wavefront_t *dev, unsigned char data)\n\n{\n\tif (wavefront_wait (dev, STAT_CAN_WRITE)) {\n\t\toutb (data, dev->data_port);\n\t\treturn 0;\n\t}\n\n\tDPRINT (WF_DEBUG_DATA, \"write timeout.\\n\");\n\n\treturn -1;\n}\n\nint\nsnd_wavefront_cmd (snd_wavefront_t *dev, \n\t\t   int cmd, unsigned char *rbuf, unsigned char *wbuf)\n\n{\n\tint ack;\n\tunsigned int i;\n\tint c;\n\tstruct wavefront_command *wfcmd;\n\n\twfcmd = wavefront_get_command(cmd);\n\tif (!wfcmd) {\n\t\tsnd_printk (\"command 0x%x not supported.\\n\",\n\t\t\tcmd);\n\t\treturn 1;\n\t}\n\n\t \n\n\tif (cmd == WFC_DOWNLOAD_MULTISAMPLE) {\n\t\twfcmd->write_cnt = (unsigned long) rbuf;\n\t\trbuf = NULL;\n\t}\n\n\tDPRINT (WF_DEBUG_CMD, \"0x%x [%s] (%d,%d,%d)\\n\",\n\t\t\t       cmd, wfcmd->action, wfcmd->read_cnt,\n\t\t\t       wfcmd->write_cnt, wfcmd->need_ack);\n    \n\tif (wavefront_write (dev, cmd)) { \n\t\tDPRINT ((WF_DEBUG_IO|WF_DEBUG_CMD), \"cannot request \"\n\t\t\t\t\t\t     \"0x%x [%s].\\n\",\n\t\t\t\t\t\t     cmd, wfcmd->action);\n\t\treturn 1;\n\t} \n\n\tif (wfcmd->write_cnt > 0) {\n\t\tDPRINT (WF_DEBUG_DATA, \"writing %d bytes \"\n\t\t\t\t\t\"for 0x%x\\n\",\n\t\t\t\t\twfcmd->write_cnt, cmd);\n\n\t\tfor (i = 0; i < wfcmd->write_cnt; i++) {\n\t\t\tif (wavefront_write (dev, wbuf[i])) {\n\t\t\t\tDPRINT (WF_DEBUG_IO, \"bad write for byte \"\n\t\t\t\t\t\t      \"%d of 0x%x [%s].\\n\",\n\t\t\t\t\t\t      i, cmd, wfcmd->action);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tDPRINT (WF_DEBUG_DATA, \"write[%d] = 0x%x\\n\",\n\t\t\t\t\t\ti, wbuf[i]);\n\t\t}\n\t}\n\n\tif (wfcmd->read_cnt > 0) {\n\t\tDPRINT (WF_DEBUG_DATA, \"reading %d ints \"\n\t\t\t\t\t\"for 0x%x\\n\",\n\t\t\t\t\twfcmd->read_cnt, cmd);\n\n\t\tfor (i = 0; i < wfcmd->read_cnt; i++) {\n\n\t\t\tc = wavefront_read(dev);\n\t\t\tif (c == -1) {\n\t\t\t\tDPRINT (WF_DEBUG_IO, \"bad read for byte \"\n\t\t\t\t\t\t      \"%d of 0x%x [%s].\\n\",\n\t\t\t\t\t\t      i, cmd, wfcmd->action);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t \n\t    \n\t\t\tif (c == 0xff) { \n\t\t\t\tc = wavefront_read(dev);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tDPRINT (WF_DEBUG_IO, \"bad read for \"\n\t\t\t\t\t\t\t      \"error byte at \"\n\t\t\t\t\t\t\t      \"read byte %d \"\n\t\t\t\t\t\t\t      \"of 0x%x [%s].\\n\",\n\t\t\t\t\t\t\t      i, cmd,\n\t\t\t\t\t\t\t      wfcmd->action);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tif (c == 1 &&\n\t\t\t\t    wfcmd->cmd == WFC_IDENTIFY_SAMPLE_TYPE) {\n\t\t\t\t\trbuf[0] = WF_ST_EMPTY;\n\t\t\t\t\treturn (0);\n\n\t\t\t\t} else if (c == 3 &&\n\t\t\t\t\t   wfcmd->cmd == WFC_UPLOAD_PATCH) {\n\n\t\t\t\t\treturn 3;\n\n\t\t\t\t} else if (c == 1 &&\n\t\t\t\t\t   wfcmd->cmd == WFC_UPLOAD_PROGRAM) {\n\n\t\t\t\t\treturn 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tDPRINT (WF_DEBUG_IO, \"error %d (%s) \"\n\t\t\t\t\t\t\t      \"during \"\n\t\t\t\t\t\t\t      \"read for byte \"\n\t\t\t\t\t\t\t      \"%d of 0x%x \"\n\t\t\t\t\t\t\t      \"[%s].\\n\",\n\t\t\t\t\t\t\t      c,\n\t\t\t\t\t\t\t      wavefront_errorstr (c),\n\t\t\t\t\t\t\t      i, cmd,\n\t\t\t\t\t\t\t      wfcmd->action);\n\t\t\t\t\treturn 1;\n\n\t\t\t\t}\n\t\t\n\t\t} else {\n\t\t\t\trbuf[i] = c;\n\t\t\t}\n\t\t\t\n\t\t\tDPRINT (WF_DEBUG_DATA, \"read[%d] = 0x%x\\n\",i, rbuf[i]);\n\t\t}\n\t}\n\t\n\tif ((wfcmd->read_cnt == 0 && wfcmd->write_cnt == 0) || wfcmd->need_ack) {\n\n\t\tDPRINT (WF_DEBUG_CMD, \"reading ACK for 0x%x\\n\", cmd);\n\n\t\t \n\t    \n\t\tack = wavefront_read(dev);\n\t\tif (ack == 0)\n\t\t\tack = WF_ACK;\n\t\n\t\tif (ack != WF_ACK) {\n\t\t\tif (ack == -1) {\n\t\t\t\tDPRINT (WF_DEBUG_IO, \"cannot read ack for \"\n\t\t\t\t\t\t      \"0x%x [%s].\\n\",\n\t\t\t\t\t\t      cmd, wfcmd->action);\n\t\t\t\treturn 1;\n\t\t\n\t\t\t} else {\n\t\t\t\tint err = -1;  \n\n\t\t\t\tif (ack == 0xff) {  \n\t\t    \n\t\t\t\t\terr = wavefront_read(dev);\n\t\t\t\t\tif (err == -1) {\n\t\t\t\t\t\tDPRINT (WF_DEBUG_DATA,\n\t\t\t\t\t\t\t\"cannot read err \"\n\t\t\t\t\t\t\t\"for 0x%x [%s].\\n\",\n\t\t\t\t\t\t\tcmd, wfcmd->action);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDPRINT (WF_DEBUG_IO, \"0x%x [%s] \"\n\t\t\t\t\t\"failed (0x%x, 0x%x, %s)\\n\",\n\t\t\t\t\tcmd, wfcmd->action, ack, err,\n\t\t\t\t\twavefront_errorstr (err));\n\t\t\t\t\n\t\t\t\treturn -err;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDPRINT (WF_DEBUG_DATA, \"ack received \"\n\t\t\t\t\t\"for 0x%x [%s]\\n\",\n\t\t\t\t\tcmd, wfcmd->action);\n\t} else {\n\n\t\tDPRINT (WF_DEBUG_CMD, \"0x%x [%s] does not need \"\n\t\t\t\t       \"ACK (%d,%d,%d)\\n\",\n\t\t\t\t       cmd, wfcmd->action, wfcmd->read_cnt,\n\t\t\t\t       wfcmd->write_cnt, wfcmd->need_ack);\n\t}\n\n\treturn 0;\n\t\n}\n\f\n \n\nstatic unsigned char *\nmunge_int32 (unsigned int src,\n\t     unsigned char *dst,\n\t     unsigned int dst_size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dst_size; i++) {\n\t\t*dst = src & 0x7F;   \n\t\tsrc = src >> 7;      \n\t                              \n\n\t\tdst++;\n\t}\n\treturn dst;\n};\n\nstatic int \ndemunge_int32 (unsigned char* src, int src_size)\n\n{\n\tint i;\n \tint outval = 0;\n\t\n \tfor (i = src_size - 1; i >= 0; i--) {\n\t\toutval=(outval<<7)+src[i];\n\t}\n\n\treturn outval;\n};\n\nstatic \nunsigned char *\nmunge_buf (unsigned char *src, unsigned char *dst, unsigned int dst_size)\n\n{\n\tunsigned int i;\n\tunsigned int last = dst_size / 2;\n\n\tfor (i = 0; i < last; i++) {\n\t\t*dst++ = src[i] & 0x7f;\n\t\t*dst++ = src[i] >> 7;\n\t}\n\treturn dst;\n}\n\nstatic \nunsigned char *\ndemunge_buf (unsigned char *src, unsigned char *dst, unsigned int src_bytes)\n\n{\n\tint i;\n\tunsigned char *end = src + src_bytes;\n    \n\t \n\n\tfor (i = 0; src != end; i++) {\n\t\tdst[i] = *src++;\n\t\tdst[i] |= (*src++)<<7;\n\t}\n\n\treturn dst;\n}\n\f\n \n\nstatic int\nwavefront_delete_sample (snd_wavefront_t *dev, int sample_num)\n\n{\n\tunsigned char wbuf[2];\n\tint x;\n\n\twbuf[0] = sample_num & 0x7f;\n\twbuf[1] = sample_num >> 7;\n\n\tx = snd_wavefront_cmd(dev, WFC_DELETE_SAMPLE, NULL, wbuf);\n\tif (!x)\n\t\tdev->sample_status[sample_num] = WF_ST_EMPTY;\n\n\treturn x;\n}\n\nstatic int\nwavefront_get_sample_status (snd_wavefront_t *dev, int assume_rom)\n\n{\n\tint i;\n\tunsigned char rbuf[32], wbuf[32];\n\tunsigned int    sc_real, sc_alias, sc_multi;\n\n\t \n    \n\tif (snd_wavefront_cmd (dev, WFC_GET_NSAMPLES, rbuf, wbuf)) {\n\t\tsnd_printk (\"cannot request sample count.\\n\");\n\t\treturn -1;\n\t} \n    \n\tsc_real = sc_alias = sc_multi = dev->samples_used = 0;\n    \n\tfor (i = 0; i < WF_MAX_SAMPLE; i++) {\n\t\n\t\twbuf[0] = i & 0x7f;\n\t\twbuf[1] = i >> 7;\n\n\t\tif (snd_wavefront_cmd (dev, WFC_IDENTIFY_SAMPLE_TYPE, rbuf, wbuf)) {\n\t\t\tsnd_printk(KERN_WARNING \"cannot identify sample \"\n\t\t\t\t   \"type of slot %d\\n\", i);\n\t\t\tdev->sample_status[i] = WF_ST_EMPTY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev->sample_status[i] = (WF_SLOT_FILLED|rbuf[0]);\n\n\t\tif (assume_rom) {\n\t\t\tdev->sample_status[i] |= WF_SLOT_ROM;\n\t\t}\n\n\t\tswitch (rbuf[0] & WF_ST_MASK) {\n\t\tcase WF_ST_SAMPLE:\n\t\t\tsc_real++;\n\t\t\tbreak;\n\t\tcase WF_ST_MULTISAMPLE:\n\t\t\tsc_multi++;\n\t\t\tbreak;\n\t\tcase WF_ST_ALIAS:\n\t\t\tsc_alias++;\n\t\t\tbreak;\n\t\tcase WF_ST_EMPTY:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnd_printk (\"unknown sample type for \"\n\t\t\t\t    \"slot %d (0x%x)\\n\", \n\t\t\t\t    i, rbuf[0]);\n\t\t}\n\n\t\tif (rbuf[0] != WF_ST_EMPTY) {\n\t\t\tdev->samples_used++;\n\t\t} \n\t}\n\n\tsnd_printk (\"%d samples used (%d real, %d aliases, %d multi), \"\n\t\t    \"%d empty\\n\", dev->samples_used, sc_real, sc_alias, sc_multi,\n\t\t    WF_MAX_SAMPLE - dev->samples_used);\n\n\n\treturn (0);\n\n}\n\nstatic int\nwavefront_get_patch_status (snd_wavefront_t *dev)\n\n{\n\tunsigned char patchbuf[WF_PATCH_BYTES];\n\tunsigned char patchnum[2];\n\twavefront_patch *p;\n\tint i, x, cnt, cnt2;\n\n\tfor (i = 0; i < WF_MAX_PATCH; i++) {\n\t\tpatchnum[0] = i & 0x7f;\n\t\tpatchnum[1] = i >> 7;\n\n\t\tx = snd_wavefront_cmd(dev, WFC_UPLOAD_PATCH, patchbuf,\n\t\t\t\t      patchnum);\n\t\tif (x == 0) {\n\n\t\t\tdev->patch_status[i] |= WF_SLOT_FILLED;\n\t\t\tp = (wavefront_patch *) patchbuf;\n\t\t\tdev->sample_status\n\t\t\t\t[p->sample_number|(p->sample_msb<<7)] |=\n\t\t\t\tWF_SLOT_USED;\n\t    \n\t\t} else if (x == 3) {  \n\t\t\tdev->patch_status[i] = 0;\n\t\t} else {\n\t\t\tsnd_printk (\"upload patch \"\n\t\t\t\t    \"error 0x%x\\n\", x);\n\t\t\tdev->patch_status[i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0, cnt = 0, cnt2 = 0; i < WF_MAX_PATCH; i++) {\n\t\tif (dev->patch_status[i] & WF_SLOT_FILLED) {\n\t\t\tcnt++;\n\t\t}\n\t\tif (dev->patch_status[i] & WF_SLOT_USED) {\n\t\t\tcnt2++;\n\t\t}\n\t\n\t}\n\tsnd_printk (\"%d patch slots filled, %d in use\\n\", cnt, cnt2);\n\n\treturn (0);\n}\n\nstatic int\nwavefront_get_program_status (snd_wavefront_t *dev)\n\n{\n\tunsigned char progbuf[WF_PROGRAM_BYTES];\n\twavefront_program prog;\n\tunsigned char prognum;\n\tint i, x, l, cnt;\n\n\tfor (i = 0; i < WF_MAX_PROGRAM; i++) {\n\t\tprognum = i;\n\n\t\tx = snd_wavefront_cmd(dev, WFC_UPLOAD_PROGRAM, progbuf,\n\t\t\t\t      &prognum);\n\t\tif (x == 0) {\n\n\t\t\tdev->prog_status[i] |= WF_SLOT_USED;\n\n\t\t\tdemunge_buf (progbuf, (unsigned char *) &prog,\n\t\t\t\t     WF_PROGRAM_BYTES);\n\n\t\t\tfor (l = 0; l < WF_NUM_LAYERS; l++) {\n\t\t\t\tif (prog.layer[l].mute) {\n\t\t\t\t\tdev->patch_status\n\t\t\t\t\t\t[prog.layer[l].patch_number] |=\n\t\t\t\t\t\tWF_SLOT_USED;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (x == 1) {  \n\t\t\tdev->prog_status[i] = 0;\n\t\t} else {\n\t\t\tsnd_printk (\"upload program \"\n\t\t\t\t    \"error 0x%x\\n\", x);\n\t\t\tdev->prog_status[i] = 0;\n\t\t}\n\t}\n\n\tfor (i = 0, cnt = 0; i < WF_MAX_PROGRAM; i++) {\n\t\tif (dev->prog_status[i]) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tsnd_printk (\"%d programs slots in use\\n\", cnt);\n\n\treturn (0);\n}\n\nstatic int\nwavefront_send_patch (snd_wavefront_t *dev, wavefront_patch_info *header)\n\n{\n\tunsigned char buf[WF_PATCH_BYTES+2];\n\tunsigned char *bptr;\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"downloading patch %d\\n\",\n\t\t\t\t      header->number);\n\n\tif (header->number >= ARRAY_SIZE(dev->patch_status))\n\t\treturn -EINVAL;\n\n\tdev->patch_status[header->number] |= WF_SLOT_FILLED;\n\n\tbptr = munge_int32 (header->number, buf, 2);\n\tmunge_buf ((unsigned char *)&header->hdr.p, bptr, WF_PATCH_BYTES);\n    \n\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PATCH, NULL, buf)) {\n\t\tsnd_printk (\"download patch failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nwavefront_send_program (snd_wavefront_t *dev, wavefront_patch_info *header)\n\n{\n\tunsigned char buf[WF_PROGRAM_BYTES+1];\n\tint i;\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"downloading program %d\\n\",\n\t\theader->number);\n\n\tif (header->number >= ARRAY_SIZE(dev->prog_status))\n\t\treturn -EINVAL;\n\n\tdev->prog_status[header->number] = WF_SLOT_USED;\n\n\t \n    \n\tfor (i = 0; i < WF_NUM_LAYERS; i++) {\n\t\tif (header->hdr.pr.layer[i].mute) {\n\t\t\tdev->patch_status[header->hdr.pr.layer[i].patch_number] |=\n\t\t\t\tWF_SLOT_USED;\n\n\t\t\t \n\t\t}\n\t}\n\n\tbuf[0] = header->number;\n\tmunge_buf ((unsigned char *)&header->hdr.pr, &buf[1], WF_PROGRAM_BYTES);\n    \n\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PROGRAM, NULL, buf)) {\n\t\tsnd_printk (\"download patch failed\\n\");\t\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nwavefront_freemem (snd_wavefront_t *dev)\n\n{\n\tchar rbuf[8];\n\n\tif (snd_wavefront_cmd (dev, WFC_REPORT_FREE_MEMORY, rbuf, NULL)) {\n\t\tsnd_printk (\"can't get memory stats.\\n\");\n\t\treturn -1;\n\t} else {\n\t\treturn demunge_int32 (rbuf, 4);\n\t}\n}\n\nstatic int\nwavefront_send_sample (snd_wavefront_t *dev, \n\t\t       wavefront_patch_info *header,\n\t\t       u16 __user *dataptr,\n\t\t       int data_is_unsigned)\n\n{\n\t \n\n\tu16 sample_short = 0;\n\tu32 length;\n\tu16 __user *data_end = NULL;\n\tunsigned int i;\n\tconst unsigned int max_blksize = 4096/2;\n\tunsigned int written;\n\tunsigned int blocksize;\n\tint dma_ack;\n\tint blocknum;\n\tunsigned char sample_hdr[WF_SAMPLE_HDR_BYTES];\n\tunsigned char *shptr;\n\tint skip = 0;\n\tint initial_skip = 0;\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"sample %sdownload for slot %d, \"\n\t\t\t\t      \"type %d, %d bytes from 0x%lx\\n\",\n\t\t\t\t      header->size ? \"\" : \"header \", \n\t\t\t\t      header->number, header->subkey,\n\t\t\t\t      header->size,\n\t\t\t\t      (unsigned long) header->dataptr);\n\n\tif (header->number == WAVEFRONT_FIND_FREE_SAMPLE_SLOT) {\n\t\tint x;\n\n\t\tx = wavefront_find_free_sample(dev);\n\t\tif (x < 0)\n\t\t\treturn -ENOMEM;\n\t\tsnd_printk (\"unspecified sample => %d\\n\", x);\n\t\theader->number = x;\n\t}\n\n\tif (header->number >= WF_MAX_SAMPLE)\n\t\treturn -EINVAL;\n\n\tif (header->size) {\n\n\t\t \n\n\t\tif (dev->rom_samples_rdonly) {\n\t\t\tif (dev->sample_status[header->number] & WF_SLOT_ROM) {\n\t\t\t\tsnd_printk (\"sample slot %d \"\n\t\t\t\t\t    \"write protected\\n\",\n\t\t\t\t\t    header->number);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\twavefront_delete_sample (dev, header->number);\n\t}\n\n\tif (header->size) {\n\t\tdev->freemem = wavefront_freemem (dev);\n\n\t\tif (dev->freemem < (int)header->size) {\n\t\t\tsnd_printk (\"insufficient memory to \"\n\t\t\t\t    \"load %d byte sample.\\n\",\n\t\t\t\t    header->size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\n\t}\n\n\tskip = WF_GET_CHANNEL(&header->hdr.s);\n\n\tif (skip > 0 && header->hdr.s.SampleResolution != LINEAR_16BIT) {\n\t\tsnd_printk (\"channel selection only \"\n\t\t\t    \"possible on 16-bit samples\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (skip) {\n\tcase 0:\n\t\tinitial_skip = 0;\n\t\tskip = 1;\n\t\tbreak;\n\tcase 1:\n\t\tinitial_skip = 0;\n\t\tskip = 2;\n\t\tbreak;\n\tcase 2:\n\t\tinitial_skip = 1;\n\t\tskip = 2;\n\t\tbreak;\n\tcase 3:\n\t\tinitial_skip = 2;\n\t\tskip = 3;\n\t\tbreak;\n\tcase 4:\n\t\tinitial_skip = 3;\n\t\tskip = 4;\n\t\tbreak;\n\tcase 5:\n\t\tinitial_skip = 4;\n\t\tskip = 5;\n\t\tbreak;\n\tcase 6:\n\t\tinitial_skip = 5;\n\t\tskip = 6;\n\t\tbreak;\n\t}\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"channel selection: %d => \"\n\t\t\t\t      \"initial skip = %d, skip = %d\\n\",\n\t\t\t\t      WF_GET_CHANNEL (&header->hdr.s),\n\t\t\t\t      initial_skip, skip);\n    \n\t \n\n\tWF_SET_CHANNEL(&header->hdr.s, 0);\n\n\t \n\n\tlength = header->size / 2;\n\n\t \n\n\tshptr = &sample_hdr[0];\n\n\tshptr = munge_int32 (header->number, shptr, 2);\n\n\tif (header->size) {\n\t\tshptr = munge_int32 (length, shptr, 4);\n\t}\n\n\t \n\n\tshptr = munge_int32 (*((u32 *) &header->hdr.s.sampleStartOffset),\n\t\t\t     shptr, 4);\n\tshptr = munge_int32 (*((u32 *) &header->hdr.s.loopStartOffset),\n\t\t\t     shptr, 4);\n\tshptr = munge_int32 (*((u32 *) &header->hdr.s.loopEndOffset),\n\t\t\t     shptr, 4);\n\tshptr = munge_int32 (*((u32 *) &header->hdr.s.sampleEndOffset),\n\t\t\t     shptr, 4);\n\t\n\t \n\t\n\tshptr = munge_int32 (header->hdr.s.FrequencyBias, shptr, 3);\n\t\n\t \n\t\n\tshptr = munge_int32 (*(&header->hdr.s.FrequencyBias+1),\n\t\t\t     shptr, 2);\n\n\tif (snd_wavefront_cmd (dev, \n\t\t\t   header->size ?\n\t\t\t   WFC_DOWNLOAD_SAMPLE : WFC_DOWNLOAD_SAMPLE_HEADER,\n\t\t\t   NULL, sample_hdr)) {\n\t\tsnd_printk (\"sample %sdownload refused.\\n\",\n\t\t\t    header->size ? \"\" : \"header \");\n\t\treturn -EIO;\n\t}\n\n\tif (header->size == 0) {\n\t\tgoto sent;  \n\t}\n    \n\tdata_end = dataptr + length;\n\n\t \n\n\tdataptr += initial_skip;\n    \n\tfor (written = 0, blocknum = 0;\n\t     written < length; written += max_blksize, blocknum++) {\n\t\n\t\tif ((length - written) > max_blksize) {\n\t\t\tblocksize = max_blksize;\n\t\t} else {\n\t\t\t \n\t\t\tblocksize = ALIGN(length - written, 8);\n\t\t}\n\n\t\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_BLOCK, NULL, NULL)) {\n\t\t\tsnd_printk (\"download block \"\n\t\t\t\t    \"request refused.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tfor (i = 0; i < blocksize; i++) {\n\n\t\t\tif (dataptr < data_end) {\n\t\t\n\t\t\t\tif (get_user(sample_short, dataptr))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tdataptr += skip;\n\t\t\n\t\t\t\tif (data_is_unsigned) {  \n\n\t\t\t\t\tif (WF_SAMPLE_IS_8BIT(&header->hdr.s)) {\n\t\t\t\n\t\t\t\t\t\t \n\t\t\t\n\t\t\t\t\t\t((unsigned char*)\n\t\t\t\t\t\t &sample_short)[0] += 0x7f;\n\t\t\t\t\t\t((unsigned char*)\n\t\t\t\t\t\t &sample_short)[1] += 0x7f;\n\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\n\t\t\t\t\t\t \n\t\t\t\n\t\t\t\t\t\tsample_short += 0x7fff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t \n\t\t\t}\n\t    \n\t\t\tif (i < blocksize - 1) {\n\t\t\t\toutw (sample_short, dev->block_port);\n\t\t\t} else {\n\t\t\t\toutw (sample_short, dev->last_block_port);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\n\t\tdma_ack = wavefront_read(dev);\n\t\tif (dma_ack != WF_DMA_ACK) {\n\t\t\tif (dma_ack == -1) {\n\t\t\t\tsnd_printk (\"upload sample \"\n\t\t\t\t\t    \"DMA ack timeout\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t} else {\n\t\t\t\tsnd_printk (\"upload sample \"\n\t\t\t\t\t    \"DMA ack error 0x%x\\n\",\n\t\t\t\t\t    dma_ack);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_SAMPLE);\n\n\t \n\n sent:\n\treturn (0);\n}\n\nstatic int\nwavefront_send_alias (snd_wavefront_t *dev, wavefront_patch_info *header)\n\n{\n\tunsigned char alias_hdr[WF_ALIAS_BYTES];\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"download alias, %d is \"\n\t\t\t\t      \"alias for %d\\n\",\n\t\t\t\t      header->number,\n\t\t\t\t      header->hdr.a.OriginalSample);\n\n\tif (header->number >= WF_MAX_SAMPLE)\n\t\treturn -EINVAL;\n\n\tmunge_int32 (header->number, &alias_hdr[0], 2);\n\tmunge_int32 (header->hdr.a.OriginalSample, &alias_hdr[2], 2);\n\tmunge_int32 (*((unsigned int *)&header->hdr.a.sampleStartOffset),\n\t\t     &alias_hdr[4], 4);\n\tmunge_int32 (*((unsigned int *)&header->hdr.a.loopStartOffset),\n\t\t     &alias_hdr[8], 4);\n\tmunge_int32 (*((unsigned int *)&header->hdr.a.loopEndOffset),\n\t\t     &alias_hdr[12], 4);\n\tmunge_int32 (*((unsigned int *)&header->hdr.a.sampleEndOffset),\n\t\t     &alias_hdr[16], 4);\n\tmunge_int32 (header->hdr.a.FrequencyBias, &alias_hdr[20], 3);\n\tmunge_int32 (*(&header->hdr.a.FrequencyBias+1), &alias_hdr[23], 2);\n\n\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_SAMPLE_ALIAS, NULL, alias_hdr)) {\n\t\tsnd_printk (\"download alias failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_ALIAS);\n\n\treturn (0);\n}\n\nstatic int\nwavefront_send_multisample (snd_wavefront_t *dev, wavefront_patch_info *header)\n{\n\tint i;\n\tint num_samples;\n\tunsigned char *msample_hdr;\n\n\tif (header->number >= WF_MAX_SAMPLE)\n\t\treturn -EINVAL;\n\n\tmsample_hdr = kmalloc(WF_MSAMPLE_BYTES, GFP_KERNEL);\n\tif (! msample_hdr)\n\t\treturn -ENOMEM;\n\n\tmunge_int32 (header->number, &msample_hdr[0], 2);\n\n\t \n\n\tnum_samples = (1<<(header->hdr.ms.NumberOfSamples&7));\n\tmsample_hdr[2] = (unsigned char) header->hdr.ms.NumberOfSamples;\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"multi %d with %d=%d samples\\n\",\n\t\t\t\t      header->number,\n\t\t\t\t      header->hdr.ms.NumberOfSamples,\n\t\t\t\t      num_samples);\n\n\tfor (i = 0; i < num_samples; i++) {\n\t\tDPRINT(WF_DEBUG_LOAD_PATCH|WF_DEBUG_DATA, \"sample[%d] = %d\\n\",\n\t\t       i, header->hdr.ms.SampleNumber[i]);\n\t\tmunge_int32 (header->hdr.ms.SampleNumber[i],\n\t\t     &msample_hdr[3+(i*2)], 2);\n\t}\n    \n\t \n\n\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_MULTISAMPLE, \n\t\t\t   (unsigned char *) (long) ((num_samples*2)+3),\n\t\t\t   msample_hdr)) {\n\t\tsnd_printk (\"download of multisample failed.\\n\");\n\t\tkfree(msample_hdr);\n\t\treturn -EIO;\n\t}\n\n\tdev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_MULTISAMPLE);\n\n\tkfree(msample_hdr);\n\treturn (0);\n}\n\nstatic int\nwavefront_fetch_multisample (snd_wavefront_t *dev, \n\t\t\t     wavefront_patch_info *header)\n{\n\tint i;\n\tunsigned char log_ns[1];\n\tunsigned char number[2];\n\tint num_samples;\n\n\tmunge_int32 (header->number, number, 2);\n    \n\tif (snd_wavefront_cmd (dev, WFC_UPLOAD_MULTISAMPLE, log_ns, number)) {\n\t\tsnd_printk (\"upload multisample failed.\\n\");\n\t\treturn -EIO;\n\t}\n    \n\tDPRINT (WF_DEBUG_DATA, \"msample %d has %d samples\\n\",\n\t\t\t\theader->number, log_ns[0]);\n\n\theader->hdr.ms.NumberOfSamples = log_ns[0];\n\n\t \n\n\tnum_samples = (1 << log_ns[0]);\n    \n\tfor (i = 0; i < num_samples; i++) {\n\t\tchar d[2];\n\t\tint val;\n\t\n\t\tval = wavefront_read(dev);\n\t\tif (val == -1) {\n\t\t\tsnd_printk (\"upload multisample failed \"\n\t\t\t\t    \"during sample loop.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\td[0] = val;\n\n\t\tval = wavefront_read(dev);\n\t\tif (val == -1) {\n\t\t\tsnd_printk (\"upload multisample failed \"\n\t\t\t\t    \"during sample loop.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\td[1] = val;\n\t\n\t\theader->hdr.ms.SampleNumber[i] =\n\t\t\tdemunge_int32 ((unsigned char *) d, 2);\n\t\n\t\tDPRINT (WF_DEBUG_DATA, \"msample sample[%d] = %d\\n\",\n\t\t\t\t\ti, header->hdr.ms.SampleNumber[i]);\n\t}\n\n\treturn (0);\n}\n\n\nstatic int\nwavefront_send_drum (snd_wavefront_t *dev, wavefront_patch_info *header)\n\n{\n\tunsigned char drumbuf[WF_DRUM_BYTES];\n\twavefront_drum *drum = &header->hdr.d;\n\tint i;\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"downloading edrum for MIDI \"\n\t\t\"note %d, patch = %d\\n\", \n\t\theader->number, drum->PatchNumber);\n\n\tdrumbuf[0] = header->number & 0x7f;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmunge_int32 (((unsigned char *)drum)[i], &drumbuf[1+(i*2)], 2);\n\t}\n\n\tif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_EDRUM_PROGRAM, NULL, drumbuf)) {\n\t\tsnd_printk (\"download drum failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn (0);\n}\n\nstatic int \nwavefront_find_free_sample (snd_wavefront_t *dev)\n\n{\n\tint i;\n\n\tfor (i = 0; i < WF_MAX_SAMPLE; i++) {\n\t\tif (!(dev->sample_status[i] & WF_SLOT_FILLED)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tsnd_printk (\"no free sample slots!\\n\");\n\treturn -1;\n}\n\n#if 0\nstatic int \nwavefront_find_free_patch (snd_wavefront_t *dev)\n\n{\n\tint i;\n\n\tfor (i = 0; i < WF_MAX_PATCH; i++) {\n\t\tif (!(dev->patch_status[i] & WF_SLOT_FILLED)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tsnd_printk (\"no free patch slots!\\n\");\n\treturn -1;\n}\n#endif\n\nstatic int\nwavefront_load_patch (snd_wavefront_t *dev, const char __user *addr)\n{\n\twavefront_patch_info *header;\n\tint err;\n\t\n\theader = kmalloc(sizeof(*header), GFP_KERNEL);\n\tif (! header)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user (header, addr, sizeof(wavefront_patch_info) -\n\t\t\t    sizeof(wavefront_any))) {\n\t\tsnd_printk (\"bad address for load patch.\\n\");\n\t\terr = -EFAULT;\n\t\tgoto __error;\n\t}\n\n\tDPRINT (WF_DEBUG_LOAD_PATCH, \"download \"\n\t\t\t\t      \"Sample type: %d \"\n\t\t\t\t      \"Sample number: %d \"\n\t\t\t\t      \"Sample size: %d\\n\",\n\t\t\t\t      header->subkey,\n\t\t\t\t      header->number,\n\t\t\t\t      header->size);\n\n\tswitch (header->subkey) {\n\tcase WF_ST_SAMPLE:   \n\n\t\tif (copy_from_user (&header->hdr.s, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_sample))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = wavefront_send_sample (dev, header, header->dataptr, 0);\n\t\tbreak;\n\n\tcase WF_ST_MULTISAMPLE:\n\n\t\tif (copy_from_user (&header->hdr.s, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_multisample))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = wavefront_send_multisample (dev, header);\n\t\tbreak;\n\n\tcase WF_ST_ALIAS:\n\n\t\tif (copy_from_user (&header->hdr.a, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_alias))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = wavefront_send_alias (dev, header);\n\t\tbreak;\n\n\tcase WF_ST_DRUM:\n\t\tif (copy_from_user (&header->hdr.d, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_drum))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = wavefront_send_drum (dev, header);\n\t\tbreak;\n\n\tcase WF_ST_PATCH:\n\t\tif (copy_from_user (&header->hdr.p, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_patch))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\terr = wavefront_send_patch (dev, header);\n\t\tbreak;\n\n\tcase WF_ST_PROGRAM:\n\t\tif (copy_from_user (&header->hdr.pr, header->hdrptr,\n\t\t\t\t    sizeof (wavefront_program))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = wavefront_send_program (dev, header);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printk (\"unknown patch type %d.\\n\",\n\t\t\t    header->subkey);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n __error:\n\tkfree(header);\n\treturn err;\n}\n\f\n \n\nstatic void\nprocess_sample_hdr (u8 *buf)\n\n{\n\twavefront_sample s;\n\tu8 *ptr;\n\n\tptr = buf;\n\n\t \n\n\t*((u32 *) &s.sampleStartOffset) = demunge_int32 (ptr, 4); ptr += 4;\n\t*((u32 *) &s.loopStartOffset) = demunge_int32 (ptr, 4); ptr += 4;\n\t*((u32 *) &s.loopEndOffset) = demunge_int32 (ptr, 4); ptr += 4;\n\t*((u32 *) &s.sampleEndOffset) = demunge_int32 (ptr, 4); ptr += 4;\n\t*((u32 *) &s.FrequencyBias) = demunge_int32 (ptr, 3); ptr += 3;\n\n\ts.SampleResolution = *ptr & 0x3;\n\ts.Loop = *ptr & 0x8;\n\ts.Bidirectional = *ptr & 0x10;\n\ts.Reverse = *ptr & 0x40;\n\n\t \n\n\tmemcpy (buf, (unsigned char *) &s, sizeof (wavefront_sample));\n}\n\nstatic int\nwavefront_synth_control (snd_wavefront_card_t *acard, \n\t\t\t wavefront_control *wc)\n\n{\n\tsnd_wavefront_t *dev = &acard->wavefront;\n\tunsigned char patchnumbuf[2];\n\tint i;\n\n\tDPRINT (WF_DEBUG_CMD, \"synth control with \"\n\t\t\"cmd 0x%x\\n\", wc->cmd);\n\n\t \n\n\tswitch (wc->cmd) {\n\t\t\n\tcase WFC_DISABLE_INTERRUPTS:\n\t\tsnd_printk (\"interrupts disabled.\\n\");\n\t\toutb (0x80|0x20, dev->control_port);\n\t\tdev->interrupts_are_midi = 1;\n\t\treturn 0;\n\n\tcase WFC_ENABLE_INTERRUPTS:\n\t\tsnd_printk (\"interrupts enabled.\\n\");\n\t\toutb (0x80|0x40|0x20, dev->control_port);\n\t\tdev->interrupts_are_midi = 1;\n\t\treturn 0;\n\n\tcase WFC_INTERRUPT_STATUS:\n\t\twc->rbuf[0] = dev->interrupts_are_midi;\n\t\treturn 0;\n\n\tcase WFC_ROMSAMPLES_RDONLY:\n\t\tdev->rom_samples_rdonly = wc->wbuf[0];\n\t\twc->status = 0;\n\t\treturn 0;\n\n\tcase WFC_IDENTIFY_SLOT_TYPE:\n\t\ti = wc->wbuf[0] | (wc->wbuf[1] << 7);\n\t\tif (i <0 || i >= WF_MAX_SAMPLE) {\n\t\t\tsnd_printk (\"invalid slot ID %d\\n\",\n\t\t\t\ti);\n\t\t\twc->status = EINVAL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twc->rbuf[0] = dev->sample_status[i];\n\t\twc->status = 0;\n\t\treturn 0;\n\n\tcase WFC_DEBUG_DRIVER:\n\t\tdev->debug = wc->wbuf[0];\n\t\tsnd_printk (\"debug = 0x%x\\n\", dev->debug);\n\t\treturn 0;\n\n\tcase WFC_UPLOAD_PATCH:\n\t\tmunge_int32 (*((u32 *) wc->wbuf), patchnumbuf, 2);\n\t\tmemcpy (wc->wbuf, patchnumbuf, 2);\n\t\tbreak;\n\n\tcase WFC_UPLOAD_MULTISAMPLE:\n\t\t \n\t\twc->status = wavefront_fetch_multisample\n\t\t\t(dev, (wavefront_patch_info *) wc->rbuf);\n\t\treturn 0;\n\n\tcase WFC_UPLOAD_SAMPLE_ALIAS:\n\t\tsnd_printk (\"support for sample alias upload \"\n\t\t\t\"being considered.\\n\");\n\t\twc->status = EINVAL;\n\t\treturn -EINVAL;\n\t}\n\n\twc->status = snd_wavefront_cmd (dev, wc->cmd, wc->rbuf, wc->wbuf);\n\n\t \n\n\tif (wc->status == 0) {\n\t\tswitch (wc->cmd) {\n\t\t\t \n\n\t\tcase WFC_REPORT_FREE_MEMORY:\n\t\t\tdev->freemem = demunge_int32 (wc->rbuf, 4);\n\t\t\tbreak;\n\n\t\tcase WFC_UPLOAD_PATCH:\n\t\t\tdemunge_buf (wc->rbuf, wc->rbuf, WF_PATCH_BYTES);\n\t\t\tbreak;\n\n\t\tcase WFC_UPLOAD_PROGRAM:\n\t\t\tdemunge_buf (wc->rbuf, wc->rbuf, WF_PROGRAM_BYTES);\n\t\t\tbreak;\n\n\t\tcase WFC_UPLOAD_EDRUM_PROGRAM:\n\t\t\tdemunge_buf (wc->rbuf, wc->rbuf, WF_DRUM_BYTES - 1);\n\t\t\tbreak;\n\n\t\tcase WFC_UPLOAD_SAMPLE_HEADER:\n\t\t\tprocess_sample_hdr (wc->rbuf);\n\t\t\tbreak;\n\n\t\tcase WFC_UPLOAD_SAMPLE_ALIAS:\n\t\t\tsnd_printk (\"support for \"\n\t\t\t\t    \"sample aliases still \"\n\t\t\t\t    \"being considered.\\n\");\n\t\t\tbreak;\n\n\t\tcase WFC_VMIDI_OFF:\n\t\t\tsnd_wavefront_midi_disable_virtual (acard);\n\t\t\tbreak;\n\n\t\tcase WFC_VMIDI_ON:\n\t\t\tsnd_wavefront_midi_enable_virtual (acard);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint \nsnd_wavefront_synth_open (struct snd_hwdep *hw, struct file *file)\n\n{\n\tif (!try_module_get(hw->card->module))\n\t\treturn -EFAULT;\n\tfile->private_data = hw;\n\treturn 0;\n}\n\nint \nsnd_wavefront_synth_release (struct snd_hwdep *hw, struct file *file)\n\n{\n\tmodule_put(hw->card->module);\n\treturn 0;\n}\n\nint\nsnd_wavefront_synth_ioctl (struct snd_hwdep *hw, struct file *file,\n\t\t\t   unsigned int cmd, unsigned long arg)\n\n{\n\tstruct snd_card *card;\n\tsnd_wavefront_t *dev;\n\tsnd_wavefront_card_t *acard;\n\twavefront_control *wc;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tcard = (struct snd_card *) hw->card;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENODEV;\n\tif (snd_BUG_ON(!card->private_data))\n\t\treturn -ENODEV;\n\n\tacard = card->private_data;\n\tdev = &acard->wavefront;\n\t\n\tswitch (cmd) {\n\tcase WFCTL_LOAD_SPP:\n\t\tif (wavefront_load_patch (dev, argp) != 0) {\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase WFCTL_WFCMD:\n\t\twc = memdup_user(argp, sizeof(*wc));\n\t\tif (IS_ERR(wc))\n\t\t\treturn PTR_ERR(wc);\n\n\t\tif (wavefront_synth_control (acard, wc) < 0)\n\t\t\terr = -EIO;\n\t\telse if (copy_to_user (argp, wc, sizeof (*wc)))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = 0;\n\t\tkfree(wc);\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\f\n \n \n \n\nvoid\nsnd_wavefront_internal_interrupt (snd_wavefront_card_t *card)\n{\n\tsnd_wavefront_t *dev = &card->wavefront;\n\n\t \n\n\tif ((wavefront_status(dev) & (STAT_INTR_READ|STAT_INTR_WRITE)) == 0) {\n\t\treturn;\n\t}\n\n\tspin_lock(&dev->irq_lock);\n\tdev->irq_ok = 1;\n\tdev->irq_cnt++;\n\tspin_unlock(&dev->irq_lock);\n\twake_up(&dev->interrupt_sleeper);\n}\n\n \n\nstatic int\nsnd_wavefront_interrupt_bits (int irq)\n\n{\n\tint bits;\n\n\tswitch (irq) {\n\tcase 9:\n\t\tbits = 0x00;\n\t\tbreak;\n\tcase 5:\n\t\tbits = 0x08;\n\t\tbreak;\n\tcase 12:\n\t\tbits = 0x10;\n\t\tbreak;\n\tcase 15:\n\t\tbits = 0x18;\n\t\tbreak;\n\t\n\tdefault:\n\t\tsnd_printk (\"invalid IRQ %d\\n\", irq);\n\t\tbits = -1;\n\t}\n\n\treturn bits;\n}\n\nstatic void\nwavefront_should_cause_interrupt (snd_wavefront_t *dev, \n\t\t\t\t  int val, int port, unsigned long timeout)\n\n{\n\twait_queue_entry_t wait;\n\n\tinit_waitqueue_entry(&wait, current);\n\tspin_lock_irq(&dev->irq_lock);\n\tadd_wait_queue(&dev->interrupt_sleeper, &wait);\n\tdev->irq_ok = 0;\n\toutb (val,port);\n\tspin_unlock_irq(&dev->irq_lock);\n\twhile (!dev->irq_ok && time_before(jiffies, timeout)) {\n\t\tschedule_timeout_uninterruptible(1);\n\t\tbarrier();\n\t}\n}\n\nstatic int\nwavefront_reset_to_cleanliness (snd_wavefront_t *dev)\n\n{\n\tint bits;\n\tint hwv[2];\n\n\t \n\n\tbits = snd_wavefront_interrupt_bits (dev->irq);\n\n\t \n\n\toutb (0x0, dev->control_port); \n  \n\t \n\n\t \n\n\toutb (0x80 | 0x40 | bits, dev->data_port);\t\n  \n\t \n\n\twavefront_should_cause_interrupt(dev, 0x80|0x40|0x10|0x1,\n\t\t\t\t\t dev->control_port,\n\t\t\t\t\t (reset_time*HZ)/100);\n\n\t \n\n\tif (!dev->irq_ok) {\n\t\tsnd_printk (\"intr not received after h/w un-reset.\\n\");\n\t\tgoto gone_bad;\n\t} \n\n\t \n\n\twavefront_should_cause_interrupt(dev, WFC_HARDWARE_VERSION, \n\t\t\t\t\t dev->data_port, ramcheck_time*HZ);\n\n\tif (!dev->irq_ok) {\n\t\tsnd_printk (\"post-RAM-check interrupt not received.\\n\");\n\t\tgoto gone_bad;\n\t} \n\n\tif (!wavefront_wait (dev, STAT_CAN_READ)) {\n\t\tsnd_printk (\"no response to HW version cmd.\\n\");\n\t\tgoto gone_bad;\n\t}\n\t\n\thwv[0] = wavefront_read(dev);\n\tif (hwv[0] == -1) {\n\t\tsnd_printk (\"board not responding correctly.\\n\");\n\t\tgoto gone_bad;\n\t}\n\n\tif (hwv[0] == 0xFF) {  \n\n\t\t \n\t\t\n\t\thwv[0] = wavefront_read(dev);\n\t\tif (hwv[0] == -1) {\n\t\t\tsnd_printk (\"on-board RAM test failed \"\n\t\t\t\t    \"(bad error code).\\n\");\n\t\t} else {\n\t\t\tsnd_printk (\"on-board RAM test failed \"\n\t\t\t\t    \"(error code: 0x%x).\\n\",\n\t\t\t\thwv[0]);\n\t\t}\n\t\tgoto gone_bad;\n\t}\n\n\t \n\n\thwv[1] = wavefront_read(dev);\n\tif (hwv[1] == -1) {\n\t\tsnd_printk (\"incorrect h/w response.\\n\");\n\t\tgoto gone_bad;\n\t}\n\n\tsnd_printk (\"hardware version %d.%d\\n\",\n\t\t    hwv[0], hwv[1]);\n\n\treturn 0;\n\n\n     gone_bad:\n\treturn (1);\n}\n\nstatic int\nwavefront_download_firmware (snd_wavefront_t *dev, char *path)\n\n{\n\tconst unsigned char *buf;\n\tint len, err;\n\tint section_cnt_downloaded = 0;\n\tconst struct firmware *firmware;\n\n\terr = request_firmware(&firmware, path, dev->card->dev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"firmware (%s) download failed!!!\\n\", path);\n\t\treturn 1;\n\t}\n\n\tlen = 0;\n\tbuf = firmware->data;\n\tfor (;;) {\n\t\tint section_length = *(signed char *)buf;\n\t\tif (section_length == 0)\n\t\t\tbreak;\n\t\tif (section_length < 0 || section_length > WF_SECTION_MAX) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"invalid firmware section length %d\\n\",\n\t\t\t\t   section_length);\n\t\t\tgoto failure;\n\t\t}\n\t\tbuf++;\n\t\tlen++;\n\n\t\tif (firmware->size < len + section_length) {\n\t\t\tsnd_printk(KERN_ERR \"firmware section read error.\\n\");\n\t\t\tgoto failure;\n\t\t}\n\n\t\t \n\t\tif (wavefront_write(dev, WFC_DOWNLOAD_OS))\n\t\t\tgoto failure;\n\t\n\t\tfor (; section_length; section_length--) {\n\t\t\tif (wavefront_write(dev, *buf))\n\t\t\t\tgoto failure;\n\t\t\tbuf++;\n\t\t\tlen++;\n\t\t}\n\t\n\t\t \n\t\tif (!wavefront_wait(dev, STAT_CAN_READ)) {\n\t\t\tsnd_printk(KERN_ERR \"time out for firmware ACK.\\n\");\n\t\t\tgoto failure;\n\t\t}\n\t\terr = inb(dev->data_port);\n\t\tif (err != WF_ACK) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"download of section #%d not \"\n\t\t\t\t   \"acknowledged, ack = 0x%x\\n\",\n\t\t\t\t   section_cnt_downloaded + 1, err);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tsection_cnt_downloaded++;\n\t}\n\n\trelease_firmware(firmware);\n\treturn 0;\n\n failure:\n\trelease_firmware(firmware);\n\tsnd_printk(KERN_ERR \"firmware download failed!!!\\n\");\n\treturn 1;\n}\n\n\nstatic int\nwavefront_do_reset (snd_wavefront_t *dev)\n\n{\n\tchar voices[1];\n\n\tif (wavefront_reset_to_cleanliness (dev)) {\n\t\tsnd_printk (\"hw reset failed.\\n\");\n\t\tgoto gone_bad;\n\t}\n\n\tif (dev->israw) {\n\t\tif (wavefront_download_firmware (dev, ospath)) {\n\t\t\tgoto gone_bad;\n\t\t}\n\n\t\tdev->israw = 0;\n\n\t\t \n\n\t\twavefront_should_cause_interrupt (dev, WFC_NOOP,\n\t\t\t\t\t\t  dev->data_port,\n\t\t\t\t\t\t  (osrun_time*HZ));\n\n\t\tif (!dev->irq_ok) {\n\t\t\tsnd_printk (\"no post-OS interrupt.\\n\");\n\t\t\tgoto gone_bad;\n\t\t}\n\t\t\n\t\t \n\t\t\n\t\twavefront_should_cause_interrupt (dev, WFC_NOOP,\n\t\t\t\t\t\t  dev->data_port, (10*HZ));\n\t\t\n\t\tif (!dev->irq_ok) {\n\t\t\tsnd_printk (\"no post-OS interrupt(2).\\n\");\n\t\t\tgoto gone_bad;\n\t\t}\n\n\t\t \n\t\t\n\t\toutb (0x80|0x40, dev->control_port); \n\t}\n\n\t \n\t\n\tdev->freemem = wavefront_freemem(dev);\n\tif (dev->freemem < 0)\n\t\tgoto gone_bad;\n\t\t\n\tsnd_printk (\"available DRAM %dk\\n\", dev->freemem / 1024);\n\n\tif (wavefront_write (dev, 0xf0) ||\n\t    wavefront_write (dev, 1) ||\n\t    (wavefront_read (dev) < 0)) {\n\t\tdev->debug = 0;\n\t\tsnd_printk (\"MPU emulation mode not set.\\n\");\n\t\tgoto gone_bad;\n\t}\n\n\tvoices[0] = 32;\n\n\tif (snd_wavefront_cmd (dev, WFC_SET_NVOICES, NULL, voices)) {\n\t\tsnd_printk (\"cannot set number of voices to 32.\\n\");\n\t\tgoto gone_bad;\n\t}\n\n\n\treturn 0;\n\n gone_bad:\n\t \n\n\toutb (0x0, dev->control_port);\n\tdev->interrupts_are_midi = 0;\n\treturn 1;\n}\n\nint\nsnd_wavefront_start (snd_wavefront_t *dev)\n\n{\n\tint samples_are_from_rom;\n\n\t \n\n\tif (dev->israw) {\n\t\tsamples_are_from_rom = 1;\n\t} else {\n\t\t \n\t\tsamples_are_from_rom = 0;\n\t}\n\n\tif (dev->israw || fx_raw) {\n\t\tif (wavefront_do_reset (dev)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\n\tdev->has_fx = (snd_wavefront_fx_detect (dev) == 0);\n\n\tif (dev->has_fx && fx_raw) {\n\t\tsnd_wavefront_fx_start (dev);\n\t}\n\n\twavefront_get_sample_status (dev, samples_are_from_rom);\n\twavefront_get_program_status (dev);\n\twavefront_get_patch_status (dev);\n\n\t \n\n\toutb (0x80|0x40|0x20, dev->control_port); \n\n\treturn (0);\n}\n\nint\nsnd_wavefront_detect (snd_wavefront_card_t *card)\n\n{\n\tunsigned char   rbuf[4], wbuf[4];\n\tsnd_wavefront_t *dev = &card->wavefront;\n\t\n\t \n\n\tdev->israw = 0;\n\tdev->has_fx = 0;\n\tdev->debug = debug_default;\n\tdev->interrupts_are_midi = 0;\n\tdev->irq_cnt = 0;\n\tdev->rom_samples_rdonly = 1;\n\n\tif (snd_wavefront_cmd (dev, WFC_FIRMWARE_VERSION, rbuf, wbuf) == 0) {\n\n\t\tdev->fw_version[0] = rbuf[0];\n\t\tdev->fw_version[1] = rbuf[1];\n\n\t\tsnd_printk (\"firmware %d.%d already loaded.\\n\",\n\t\t\t    rbuf[0], rbuf[1]);\n\n\t\t \n      \n\t\tif (snd_wavefront_cmd (dev, WFC_HARDWARE_VERSION,\n\t\t\t\t       rbuf, wbuf) == 0) {\n\t\t\tdev->hw_version[0] = rbuf[0];\n\t\t\tdev->hw_version[1] = rbuf[1];\n\t\t} else {\n\t\t\tsnd_printk (\"not raw, but no \"\n\t\t\t\t    \"hardware version!\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!wf_raw) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tsnd_printk (\"reloading firmware as you requested.\\n\");\n\t\t\tdev->israw = 1;\n\t\t}\n\n\t} else {\n\n\t\tdev->israw = 1;\n\t\tsnd_printk (\"no response to firmware probe, assume raw.\\n\");\n\n\t}\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(DEFAULT_OSPATH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}