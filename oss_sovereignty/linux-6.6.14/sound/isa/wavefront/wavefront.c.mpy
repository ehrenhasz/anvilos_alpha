{
  "module_name": "wavefront.c",
  "hash_id": "ab9a3c5f0e2545fe2d0675e4cbe2f1a7c585bde5bf3a15b3e6ae033588c428cb",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/wavefront/wavefront.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/opl3.h>\n#include <sound/wss.h>\n#include <sound/snd_wavefront.h>\n\nMODULE_AUTHOR(\"Paul Barton-Davis <pbd@op.net>\");\nMODULE_DESCRIPTION(\"Turtle Beach Wavefront\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t     \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t     \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t     \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long cs4232_pcm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int cs4232_pcm_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;  \nstatic long cs4232_mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;  \nstatic int cs4232_mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;  \nstatic long ics2115_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;  \nstatic int ics2115_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;     \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t     \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t     \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t     \nstatic bool use_cs4232_midi[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for WaveFront soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for WaveFront soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable WaveFront soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"ISA PnP detection for WaveFront soundcards.\");\n#endif\nmodule_param_hw_array(cs4232_pcm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(cs4232_pcm_port, \"Port # for CS4232 PCM interface.\");\nmodule_param_hw_array(cs4232_pcm_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(cs4232_pcm_irq, \"IRQ # for CS4232 PCM interface.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 # for CS4232 PCM interface.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for CS4232 PCM interface.\");\nmodule_param_hw_array(cs4232_mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(cs4232_mpu_port, \"port # for CS4232 MPU-401 interface.\");\nmodule_param_hw_array(cs4232_mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(cs4232_mpu_irq, \"IRQ # for CS4232 MPU-401 interface.\");\nmodule_param_hw_array(ics2115_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(ics2115_irq, \"IRQ # for ICS2115.\");\nmodule_param_hw_array(ics2115_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(ics2115_port, \"Port # for ICS2115.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port #.\");\nmodule_param_array(use_cs4232_midi, bool, NULL, 0444);\nMODULE_PARM_DESC(use_cs4232_midi, \"Use CS4232 MPU-401 interface (inaccessibly located inside your computer)\");\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\n\nstatic const struct pnp_card_device_id snd_wavefront_pnpids[] = {\n\t \n\t{ .id = \"CSC7532\", .devs = { { \"CSC0000\" }, { \"CSC0010\" }, { \"PnPb006\" }, { \"CSC0004\" } } },\n\t \n\t{ .id = \"CSC7632\", .devs = { { \"CSC0000\" }, { \"CSC0010\" }, { \"PnPb006\" }, { \"CSC0004\" } } },\n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_wavefront_pnpids);\n\nstatic int\nsnd_wavefront_pnp (int dev, snd_wavefront_card_t *acard, struct pnp_card_link *card,\n\t\t   const struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\t \n\n\t \n\n\tacard->wss = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (acard->wss == NULL)\n\t\treturn -EBUSY;\n\n\t \n\n\t \n\n\t \n\n\tif (use_cs4232_midi[dev]) {\n\t\tacard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);\n\t\tif (acard->mpu == NULL)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\n\tacard->synth = pnp_request_card_device(card, id->devs[3].id, NULL);\n\tif (acard->synth == NULL)\n\t\treturn -EBUSY;\n\n\t \n\n\tpdev = acard->wss;\n\n\t \n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"PnP WSS pnp configure failure\\n\");\n\t\treturn err;\n\t}\n\n\tcs4232_pcm_port[dev] = pnp_port_start(pdev, 0);\n\tfm_port[dev] = pnp_port_start(pdev, 1);\n\tdma1[dev] = pnp_dma(pdev, 0);\n\tdma2[dev] = pnp_dma(pdev, 1);\n\tcs4232_pcm_irq[dev] = pnp_irq(pdev, 0);\n\n\t \n\n\tpdev = acard->synth;\n\t\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"PnP ICS2115 pnp configure failure\\n\");\n\t\treturn err;\n\t}\n\n\tics2115_port[dev] = pnp_port_start(pdev, 0);\n\tics2115_irq[dev] = pnp_irq(pdev, 0);\n\n\t \n\n\tif (use_cs4232_midi[dev]) {\n\n\t\tpdev = acard->mpu;\n\n\t\terr = pnp_activate_dev(pdev);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"PnP MPU401 pnp configure failure\\n\");\n\t\t\tcs4232_mpu_port[dev] = SNDRV_AUTO_PORT;\n\t\t} else {\n\t\t\tcs4232_mpu_port[dev] = pnp_port_start(pdev, 0);\n\t\t\tcs4232_mpu_irq[dev] = pnp_irq(pdev, 0);\n\t\t}\n\n\t\tsnd_printk (KERN_INFO \"CS4232 MPU: port=0x%lx, irq=%i\\n\", \n\t\t\t    cs4232_mpu_port[dev], \n\t\t\t    cs4232_mpu_irq[dev]);\n\t}\n\n\tsnd_printdd (\"CS4232: pcm port=0x%lx, fm port=0x%lx, dma1=%i, dma2=%i, irq=%i\\nICS2115: port=0x%lx, irq=%i\\n\", \n\t\t    cs4232_pcm_port[dev], \n\t\t    fm_port[dev],\n\t\t    dma1[dev], \n\t\t    dma2[dev], \n\t\t    cs4232_pcm_irq[dev],\n\t\t    ics2115_port[dev], \n\t\t    ics2115_irq[dev]);\n\t\n\treturn 0;\n}\n\n#endif  \n\nstatic irqreturn_t snd_wavefront_ics2115_interrupt(int irq, void *dev_id)\n{\n\tsnd_wavefront_card_t *acard;\n\n\tacard = (snd_wavefront_card_t *) dev_id;\n\n\tif (acard == NULL) \n\t\treturn IRQ_NONE;\n\n\tif (acard->wavefront.interrupts_are_midi) {\n\t\tsnd_wavefront_midi_interrupt (acard);\n\t} else {\n\t\tsnd_wavefront_internal_interrupt (acard);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic struct snd_hwdep *snd_wavefront_new_synth(struct snd_card *card,\n\t\t\t\t\t\t int hw_dev,\n\t\t\t\t\t\t snd_wavefront_card_t *acard)\n{\n\tstruct snd_hwdep *wavefront_synth;\n\n\tif (snd_wavefront_detect (acard) < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (snd_wavefront_start (&acard->wavefront) < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (snd_hwdep_new(card, \"WaveFront\", hw_dev, &wavefront_synth) < 0)\n\t\treturn NULL;\n\tstrcpy (wavefront_synth->name, \n\t\t\"WaveFront (ICS2115) wavetable synthesizer\");\n\twavefront_synth->ops.open = snd_wavefront_synth_open;\n\twavefront_synth->ops.release = snd_wavefront_synth_release;\n\twavefront_synth->ops.ioctl = snd_wavefront_synth_ioctl;\n\n\treturn wavefront_synth;\n}\n\nstatic struct snd_hwdep *snd_wavefront_new_fx(struct snd_card *card,\n\t\t\t\t\t      int hw_dev,\n\t\t\t\t\t      snd_wavefront_card_t *acard,\n\t\t\t\t\t      unsigned long port)\n\n{\n\tstruct snd_hwdep *fx_processor;\n\n\tif (snd_wavefront_fx_start (&acard->wavefront)) {\n\t\tsnd_printk (KERN_ERR \"cannot initialize YSS225 FX processor\");\n\t\treturn NULL;\n\t}\n\n\tif (snd_hwdep_new (card, \"YSS225\", hw_dev, &fx_processor) < 0)\n\t\treturn NULL;\n\tsprintf (fx_processor->name, \"YSS225 FX Processor at 0x%lx\", port);\n\tfx_processor->ops.open = snd_wavefront_fx_open;\n\tfx_processor->ops.release = snd_wavefront_fx_release;\n\tfx_processor->ops.ioctl = snd_wavefront_fx_ioctl;\n\t\n\treturn fx_processor;\n}\n\nstatic snd_wavefront_mpu_id internal_id = internal_mpu;\nstatic snd_wavefront_mpu_id external_id = external_mpu;\n\nstatic struct snd_rawmidi *snd_wavefront_new_midi(struct snd_card *card,\n\t\t\t\t\t\t  int midi_dev,\n\t\t\t\t\t\t  snd_wavefront_card_t *acard,\n\t\t\t\t\t\t  unsigned long port,\n\t\t\t\t\t\t  snd_wavefront_mpu_id mpu)\n\n{\n\tstruct snd_rawmidi *rmidi;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tacard->wavefront.midi.base = port;\n\t\tif (snd_wavefront_midi_start (acard)) {\n\t\t\tsnd_printk (KERN_ERR \"cannot initialize MIDI interface\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (snd_rawmidi_new (card, \"WaveFront MIDI\", midi_dev, 1, 1, &rmidi) < 0)\n\t\treturn NULL;\n\n\tif (mpu == internal_mpu) {\n\t\tstrcpy(rmidi->name, \"WaveFront MIDI (Internal)\");\n\t\trmidi->private_data = &internal_id;\n\t} else {\n\t\tstrcpy(rmidi->name, \"WaveFront MIDI (External)\");\n\t\trmidi->private_data = &external_id;\n\t}\n\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_wavefront_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_wavefront_midi_input);\n\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t     SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t     SNDRV_RAWMIDI_INFO_DUPLEX;\n\n\treturn rmidi;\n}\n\nstatic int snd_wavefront_card_new(struct device *pdev, int dev,\n\t\t\t\t  struct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tsnd_wavefront_card_t *acard;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(snd_wavefront_card_t), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tacard = card->private_data;\n\tacard->wavefront.irq = -1;\n\tspin_lock_init(&acard->wavefront.irq_lock);\n\tinit_waitqueue_head(&acard->wavefront.interrupt_sleeper);\n\tspin_lock_init(&acard->wavefront.midi.open);\n\tspin_lock_init(&acard->wavefront.midi.virtual);\n\tacard->wavefront.card = card;\n\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int\nsnd_wavefront_probe (struct snd_card *card, int dev)\n{\n\tsnd_wavefront_card_t *acard = card->private_data;\n\tstruct snd_wss *chip;\n\tstruct snd_hwdep *wavefront_synth;\n\tstruct snd_rawmidi *ics2115_internal_rmidi = NULL;\n\tstruct snd_rawmidi *ics2115_external_rmidi = NULL;\n\tstruct snd_hwdep *fx_processor;\n\tint hw_dev = 0, midi_dev = 0, err;\n\n\t \n\n\terr = snd_wss_create(card, cs4232_pcm_port[dev], -1,\n\t\t\t     cs4232_pcm_irq[dev], dma1[dev], dma2[dev],\n\t\t\t     WSS_HW_DETECT, 0, &chip);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"can't allocate WSS device\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_wss_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_timer(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\n\tif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\n\t\tstruct snd_opl3 *opl3;\n\n\t\terr = snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\n\t\t\t\t      OPL3_HW_OPL3_CS, 0, &opl3);\n\t\tif (err < 0) {\n\t\t\tsnd_printk (KERN_ERR \"can't allocate or detect OPL3 synth\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = snd_opl3_hwdep_new(opl3, hw_dev, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\thw_dev++;\n\t}\n\n\t \n\n\tacard->wavefront.res_base =\n\t\tdevm_request_region(card->dev, ics2115_port[dev], 16,\n\t\t\t\t    \"ICS2115\");\n\tif (acard->wavefront.res_base == NULL) {\n\t\tsnd_printk(KERN_ERR \"unable to grab ICS2115 i/o region 0x%lx-0x%lx\\n\",\n\t\t\t   ics2115_port[dev], ics2115_port[dev] + 16 - 1);\n\t\treturn -EBUSY;\n\t}\n\tif (devm_request_irq(card->dev, ics2115_irq[dev],\n\t\t\t     snd_wavefront_ics2115_interrupt,\n\t\t\t     0, \"ICS2115\", acard)) {\n\t\tsnd_printk(KERN_ERR \"unable to use ICS2115 IRQ %d\\n\", ics2115_irq[dev]);\n\t\treturn -EBUSY;\n\t}\n\t\n\tacard->wavefront.irq = ics2115_irq[dev];\n\tcard->sync_irq = acard->wavefront.irq;\n\tacard->wavefront.base = ics2115_port[dev];\n\n\twavefront_synth = snd_wavefront_new_synth(card, hw_dev, acard);\n\tif (wavefront_synth == NULL) {\n\t\tsnd_printk (KERN_ERR \"can't create WaveFront synth device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstrcpy (wavefront_synth->name, \"ICS2115 Wavetable MIDI Synthesizer\");\n\twavefront_synth->iface = SNDRV_HWDEP_IFACE_ICS2115;\n\thw_dev++;\n\n\t \n\n\terr = snd_wss_mixer(chip);\n\tif (err < 0) {\n\t\tsnd_printk (KERN_ERR \"can't allocate mixer device\\n\");\n\t\treturn err;\n\t}\n\n\t \n\n\tif (cs4232_mpu_port[dev] > 0 && cs4232_mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\terr = snd_mpu401_uart_new(card, midi_dev, MPU401_HW_CS4232,\n\t\t\t\t\t  cs4232_mpu_port[dev], 0,\n\t\t\t\t\t  cs4232_mpu_irq[dev], NULL);\n\t\tif (err < 0) {\n\t\t\tsnd_printk (KERN_ERR \"can't allocate CS4232 MPU-401 device\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tmidi_dev++;\n\t}\n\n\t \n\n\tif (ics2115_port[dev] > 0 && ics2115_port[dev] != SNDRV_AUTO_PORT) {\n\t\tics2115_internal_rmidi = \n\t\t\tsnd_wavefront_new_midi (card, \n\t\t\t\t\t\tmidi_dev,\n\t\t\t\t\t\tacard,\n\t\t\t\t\t\tics2115_port[dev],\n\t\t\t\t\t\tinternal_mpu);\n\t\tif (ics2115_internal_rmidi == NULL) {\n\t\t\tsnd_printk (KERN_ERR \"can't setup ICS2115 internal MIDI device\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmidi_dev++;\n\t}\n\n\t \n\n\tif (ics2115_port[dev] > 0 && ics2115_port[dev] != SNDRV_AUTO_PORT) {\n\t\tics2115_external_rmidi = \n\t\t\tsnd_wavefront_new_midi (card, \n\t\t\t\t\t\tmidi_dev,\n\t\t\t\t\t\tacard,\n\t\t\t\t\t\tics2115_port[dev],\n\t\t\t\t\t\texternal_mpu);\n\t\tif (ics2115_external_rmidi == NULL) {\n\t\t\tsnd_printk (KERN_ERR \"can't setup ICS2115 external MIDI device\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmidi_dev++;\n\t}\n\n\t \n\n\tif (acard->wavefront.has_fx) {\n\t\tfx_processor = snd_wavefront_new_fx (card,\n\t\t\t\t\t\t     hw_dev,\n\t\t\t\t\t\t     acard,\n\t\t\t\t\t\t     ics2115_port[dev]);\n\t\tif (fx_processor == NULL) {\n\t\t\tsnd_printk (KERN_ERR \"can't setup FX device\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\thw_dev++;\n\n\t\tstrcpy(card->driver, \"Tropez+\");\n\t\tstrcpy(card->shortname, \"Turtle Beach Tropez+\");\n\t} else {\n\t\t \n\t\tstrcpy(card->driver, \"WaveFront\");\n\t\tstrcpy(card->shortname, \"Turtle Beach WaveFront\");\n\t}\n\n\t \n\n\t \n\n\tsprintf(card->longname, \"%s PCM 0x%lx irq %d dma %d\",\n\t\tcard->driver,\n\t\tchip->port,\n\t\tcs4232_pcm_irq[dev],\n\t\tdma1[dev]);\n\n\tif (dma2[dev] >= 0 && dma2[dev] < 8)\n\t\tsprintf(card->longname + strlen(card->longname), \"&%d\", dma2[dev]);\n\n\tif (cs4232_mpu_port[dev] > 0 && cs4232_mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\tsprintf (card->longname + strlen (card->longname), \n\t\t\t \" MPU-401 0x%lx irq %d\",\n\t\t\t cs4232_mpu_port[dev],\n\t\t\t cs4232_mpu_irq[dev]);\n\t}\n\n\tsprintf (card->longname + strlen (card->longname), \n\t\t \" SYNTH 0x%lx irq %d\",\n\t\t ics2115_port[dev],\n\t\t ics2115_irq[dev]);\n\n\treturn snd_card_register(card);\n}\t\n\nstatic int snd_wavefront_isa_match(struct device *pdev,\n\t\t\t\t   unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n#ifdef CONFIG_PNP\n\tif (isapnp[dev])\n\t\treturn 0;\n#endif\n\tif (cs4232_pcm_port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR \"specify CS4232 port\\n\");\n\t\treturn 0;\n\t}\n\tif (ics2115_port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR \"specify ICS2115 port\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_wavefront_isa_probe(struct device *pdev,\n\t\t\t\t   unsigned int dev)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_wavefront_card_new(pdev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_wavefront_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#define DEV_NAME \"wavefront\"\n\nstatic struct isa_driver snd_wavefront_driver = {\n\t.match\t\t= snd_wavefront_isa_match,\n\t.probe\t\t= snd_wavefront_isa_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n\n#ifdef CONFIG_PNP\nstatic int snd_wavefront_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t\t    const struct pnp_card_device_id *pid)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tres = snd_wavefront_card_new(&pcard->card->dev, dev, &card);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (snd_wavefront_pnp (dev, card->private_data, pcard, pid) < 0) {\n\t\tif (cs4232_pcm_port[dev] == SNDRV_AUTO_PORT) {\n\t\t\tsnd_printk (KERN_ERR \"isapnp detection failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tres = snd_wavefront_probe(card, dev);\n\tif (res < 0)\n\t\treturn res;\n\n\tpnp_set_card_drvdata(pcard, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic struct pnp_card_driver wavefront_pnpc_driver = {\n\t.flags\t\t= PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= \"wavefront\",\n\t.id_table\t= snd_wavefront_pnpids,\n\t.probe\t\t= snd_wavefront_pnp_detect,\n\t \n};\n\n#endif  \n\nstatic int __init alsa_card_wavefront_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_wavefront_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&wavefront_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_wavefront_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&wavefront_pnpc_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_wavefront_driver);\n}\n\nmodule_init(alsa_card_wavefront_init)\nmodule_exit(alsa_card_wavefront_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}