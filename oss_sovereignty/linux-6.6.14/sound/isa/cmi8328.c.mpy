{
  "module_name": "cmi8328.c",
  "hash_id": "ab8f2e61f1b03c190faae72e6c25405850b1f80bb9e8bafd18eb24f6bfdc189f",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/cmi8328.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/isa.h>\n#include <linux/module.h>\n#include <linux/gameport.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/opl3.h>\n#include <sound/mpu401.h>\n#define SNDRV_LEGACY_FIND_FREE_IOPORT\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Ondrej Zary <linux@rainbow-software.org>\");\nMODULE_DESCRIPTION(\"C-Media CMI8328\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_ENABLED(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\n \nstatic const int cmi8328_ports[] = { 0x530, 0xe80, 0xf40, 0x604 };\n#define CMI8328_MAX\tARRAY_SIZE(cmi8328_ports)\n\nstatic int index[CMI8328_MAX] =     {[0 ... (CMI8328_MAX-1)] = -1};\nstatic char *id[CMI8328_MAX] =      {[0 ... (CMI8328_MAX-1)] = NULL};\nstatic long port[CMI8328_MAX] =     {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_PORT};\nstatic int irq[CMI8328_MAX] =       {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_IRQ};\nstatic int dma1[CMI8328_MAX] =      {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_DMA};\nstatic int dma2[CMI8328_MAX] =      {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_DMA};\nstatic long mpuport[CMI8328_MAX] =  {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_PORT};\nstatic int mpuirq[CMI8328_MAX] =    {[0 ... (CMI8328_MAX-1)] = SNDRV_AUTO_IRQ};\n#ifdef SUPPORT_JOYSTICK\nstatic bool gameport[CMI8328_MAX] = {[0 ... (CMI8328_MAX-1)] = true};\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for CMI8328 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for CMI8328 soundcard.\");\n\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for CMI8328 driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for CMI8328 driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 for CMI8328 driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 for CMI8328 driver.\");\n\nmodule_param_hw_array(mpuport, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpuport, \"MPU-401 port # for CMI8328 driver.\");\nmodule_param_hw_array(mpuirq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpuirq, \"IRQ # for CMI8328 MPU-401 port.\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_array(gameport, bool, NULL, 0444);\nMODULE_PARM_DESC(gameport, \"Enable gameport.\");\n#endif\n\nstruct snd_cmi8328 {\n\tu16 port;\n\tu8 cfg[3];\n\tu8 wss_cfg;\n\tstruct snd_card *card;\n\tstruct snd_wss *wss;\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n};\n\n \n#define CFG1 0x61\n#define CFG1_SB_DISABLE\t(1 << 0)\n#define CFG1_GAMEPORT\t(1 << 1)\n \n#define CFG2 0x62\n#define CFG2_MPU_ENABLE (1 << 2)\n \n#define CFG3 0x63\n \n\nstatic u8 snd_cmi8328_cfg_read(u16 port, u8 reg)\n{\n\toutb(0x43, port + 3);\n\toutb(0x21, port + 3);\n\toutb(reg, port + 3);\n\treturn inb(port);\n}\n\nstatic void snd_cmi8328_cfg_write(u16 port, u8 reg, u8 val)\n{\n\toutb(0x43, port + 3);\n\toutb(0x21, port + 3);\n\toutb(reg, port + 3);\n\toutb(val, port + 3);\t \n}\n\n#ifdef CONFIG_PM\nstatic void snd_cmi8328_cfg_save(u16 port, u8 cfg[])\n{\n\tcfg[0] = snd_cmi8328_cfg_read(port, CFG1);\n\tcfg[1] = snd_cmi8328_cfg_read(port, CFG2);\n\tcfg[2] = snd_cmi8328_cfg_read(port, CFG3);\n}\n\nstatic void snd_cmi8328_cfg_restore(u16 port, u8 cfg[])\n{\n\tsnd_cmi8328_cfg_write(port, CFG1, cfg[0]);\n\tsnd_cmi8328_cfg_write(port, CFG2, cfg[1]);\n\tsnd_cmi8328_cfg_write(port, CFG3, cfg[2]);\n}\n#endif  \n\nstatic int snd_cmi8328_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card;\n\tstruct snd_ctl_elem_id id1, id2;\n\tint err;\n\n\tcard = chip->card;\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tstrcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"error renaming control\\n\");\n\t\treturn err;\n\t}\n\t \n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"CD Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"error renaming control\\n\");\n\t\treturn err;\n\t}\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tid1.index = 1;\n\tstrcpy(id2.name, \"Synth Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"error renaming control\\n\");\n\t\treturn err;\n\t}\n\t \n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tid1.index = 1;\n\tstrcpy(id2.name, \"Synth Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"error renaming control\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int array_find(const int array[], int item)\n{\n\tint i;\n\n\tfor (i = 0; array[i] != -1; i++)\n\t\tif (array[i] == item)\n\t\t\treturn i;\n\n\treturn -1;\n}\n \nstatic int array_find_l(const long array[], long item)\n{\n\tint i;\n\n\tfor (i = 0; array[i] != -1; i++)\n\t\tif (array[i] == item)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int snd_cmi8328_probe(struct device *pdev, unsigned int ndev)\n{\n\tstruct snd_card *card;\n\tstruct snd_opl3 *opl3;\n\tstruct snd_cmi8328 *cmi;\n#ifdef SUPPORT_JOYSTICK\n\tstruct resource *res;\n#endif\n\tint err, pos;\n\tstatic const long mpu_ports[] = { 0x330, 0x300, 0x310, 0x320, 0x332, 0x334,\n\t\t\t\t   0x336, -1 };\n\tstatic const u8 mpu_port_bits[] = { 3, 0, 1, 2, 4, 5, 6 };\n\tstatic const int mpu_irqs[] = { 9, 7, 5, 3, -1 };\n\tstatic const u8 mpu_irq_bits[] = { 3, 2, 1, 0 };\n\tstatic const int irqs[] = { 9, 10, 11, 7, -1 };\n\tstatic const u8 irq_bits[] = { 2, 3, 4, 1 };\n\tstatic const int dma1s[] = { 3, 1, 0, -1 };\n\tstatic const u8 dma_bits[] = { 3, 2, 1 };\n\tstatic const int dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1}, {0, -1} };\n\tu16 port = cmi8328_ports[ndev];\n\tu8 val;\n\n\t \n\tif (snd_cmi8328_cfg_read(port, CFG1) == 0xff)\n\t\treturn -ENODEV;\n\t \n\tsnd_cmi8328_cfg_write(port, CFG1, CFG1_SB_DISABLE);\n\tif (snd_cmi8328_cfg_read(port, CFG1) != CFG1_SB_DISABLE)\n\t\treturn -ENODEV;\n\t \n\tsnd_cmi8328_cfg_write(port, CFG2, 0);\t \n\tsnd_cmi8328_cfg_write(port, CFG3, 0);\t \n\n\tif (irq[ndev] == SNDRV_AUTO_IRQ) {\n\t\tirq[ndev] = snd_legacy_find_free_irq(irqs);\n\t\tif (irq[ndev] < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1[ndev] == SNDRV_AUTO_DMA) {\n\t\tdma1[ndev] = snd_legacy_find_free_dma(dma1s);\n\t\tif (dma1[ndev] < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma2[ndev] == SNDRV_AUTO_DMA) {\n\t\tdma2[ndev] = snd_legacy_find_free_dma(dma2s[dma1[ndev] % 4]);\n\t\tif (dma2[ndev] < 0) {\n\t\t\tsnd_printk(KERN_WARNING \"unable to find a free DMA2, full-duplex will not work\\n\");\n\t\t\tdma2[ndev] = -1;\n\t\t}\n\t}\n\t \n\tpos = array_find(irqs, irq[ndev]);\n\tif (pos < 0) {\n\t\tsnd_printk(KERN_ERR \"invalid IRQ %d\\n\", irq[ndev]);\n\t\treturn -EINVAL;\n\t}\n\tval = irq_bits[pos] << 3;\n\t \n\tpos = array_find(dma1s, dma1[ndev]);\n\tif (pos < 0) {\n\t\tsnd_printk(KERN_ERR \"invalid DMA1 %d\\n\", dma1[ndev]);\n\t\treturn -EINVAL;\n\t}\n\tval |= dma_bits[pos];\n\t \n\tif (dma2[ndev] >= 0 && dma1[ndev] != dma2[ndev]) {\n\t\tpos = array_find(dma2s[dma1[ndev]], dma2[ndev]);\n\t\tif (pos < 0) {\n\t\t\tsnd_printk(KERN_ERR \"invalid DMA2 %d\\n\", dma2[ndev]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval |= 0x04;  \n\t}\n\toutb(val, port);\n\n\terr = snd_devm_card_new(pdev, index[ndev], id[ndev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_cmi8328), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcmi = card->private_data;\n\tcmi->card = card;\n\tcmi->port = port;\n\tcmi->wss_cfg = val;\n\n\terr = snd_wss_create(card, port + 4, -1, irq[ndev], dma1[ndev],\n\t\t\tdma2[ndev], WSS_HW_DETECT, 0, &cmi->wss);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_pcm(cmi->wss, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_mixer(cmi->wss);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_cmi8328_mixer(cmi->wss);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_wss_timer(cmi->wss, 0) < 0)\n\t\tsnd_printk(KERN_WARNING \"error initializing WSS timer\\n\");\n\n\tif (mpuport[ndev] == SNDRV_AUTO_PORT) {\n\t\tmpuport[ndev] = snd_legacy_find_free_ioport(mpu_ports, 2);\n\t\tif (mpuport[ndev] < 0)\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free MPU401 port\\n\");\n\t}\n\tif (mpuirq[ndev] == SNDRV_AUTO_IRQ) {\n\t\tmpuirq[ndev] = snd_legacy_find_free_irq(mpu_irqs);\n\t\tif (mpuirq[ndev] < 0)\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free MPU401 IRQ\\n\");\n\t}\n\t \n\tif (mpuport[ndev] > 0 && mpuirq[ndev] > 0) {\n\t\tval = CFG2_MPU_ENABLE;\n\t\tpos = array_find_l(mpu_ports, mpuport[ndev]);\n\t\tif (pos < 0)\n\t\t\tsnd_printk(KERN_WARNING \"invalid MPU401 port 0x%lx\\n\",\n\t\t\t\t\t\t\t\tmpuport[ndev]);\n\t\telse {\n\t\t\tval |= mpu_port_bits[pos] << 5;\n\t\t\tpos = array_find(mpu_irqs, mpuirq[ndev]);\n\t\t\tif (pos < 0)\n\t\t\t\tsnd_printk(KERN_WARNING \"invalid MPU401 IRQ %d\\n\",\n\t\t\t\t\t\t\t\tmpuirq[ndev]);\n\t\t\telse {\n\t\t\t\tval |= mpu_irq_bits[pos] << 3;\n\t\t\t\tsnd_cmi8328_cfg_write(port, CFG2, val);\n\t\t\t\tif (snd_mpu401_uart_new(card, 0,\n\t\t\t\t\t\tMPU401_HW_MPU401, mpuport[ndev],\n\t\t\t\t\t\t0, mpuirq[ndev], NULL) < 0)\n\t\t\t\t\tsnd_printk(KERN_ERR \"error initializing MPU401\\n\");\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (snd_opl3_create(card, 0x388, 0x38a, OPL3_HW_AUTO, 0, &opl3) < 0)\n\t\tsnd_printk(KERN_ERR \"error initializing OPL3\\n\");\n\telse\n\t\tif (snd_opl3_hwdep_new(opl3, 0, 1, NULL) < 0)\n\t\t\tsnd_printk(KERN_WARNING \"error initializing OPL3 hwdep\\n\");\n\n\tstrcpy(card->driver, \"CMI8328\");\n\tstrcpy(card->shortname, \"C-Media CMI8328\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma %d,%d\",\n\t\tcard->shortname, cmi->wss->port, irq[ndev], dma1[ndev],\n\t\t(dma2[ndev] >= 0) ? dma2[ndev] : dma1[ndev]);\n\n\tdev_set_drvdata(pdev, card);\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n#ifdef SUPPORT_JOYSTICK\n\tif (!gameport[ndev])\n\t\treturn 0;\n\t \n\tres = devm_request_region(pdev, 0x200, 8, \"CMI8328 gameport\");\n\tif (!res)\n\t\tsnd_printk(KERN_WARNING \"unable to allocate gameport I/O port\\n\");\n\telse {\n\t\tstruct gameport *gp = cmi->gameport = gameport_allocate_port();\n\t\tif (cmi->gameport) {\n\t\t\tgameport_set_name(gp, \"CMI8328 Gameport\");\n\t\t\tgameport_set_phys(gp, \"%s/gameport0\", dev_name(pdev));\n\t\t\tgameport_set_dev_parent(gp, pdev);\n\t\t\tgp->io = 0x200;\n\t\t\t \n\t\t\tsnd_cmi8328_cfg_write(port, CFG1,\n\t\t\t\t\tCFG1_SB_DISABLE | CFG1_GAMEPORT);\n\t\t\tgameport_register_port(gp);\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void snd_cmi8328_remove(struct device *pdev, unsigned int dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct snd_cmi8328 *cmi = card->private_data;\n\n#ifdef SUPPORT_JOYSTICK\n\tif (cmi->gameport)\n\t\tgameport_unregister_port(cmi->gameport);\n#endif\n\t \n\tsnd_cmi8328_cfg_write(cmi->port, CFG1, CFG1_SB_DISABLE);\n\tsnd_cmi8328_cfg_write(cmi->port, CFG2, 0);\n\tsnd_cmi8328_cfg_write(cmi->port, CFG3, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int snd_cmi8328_suspend(struct device *pdev, unsigned int n,\n\t\t\t\tpm_message_t state)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct snd_cmi8328 *cmi;\n\n\tif (!card)\t \n\t\treturn 0;\n\tcmi = card->private_data;\n\tsnd_cmi8328_cfg_save(cmi->port, cmi->cfg);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tcmi->wss->suspend(cmi->wss);\n\n\treturn 0;\n}\n\nstatic int snd_cmi8328_resume(struct device *pdev, unsigned int n)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct snd_cmi8328 *cmi;\n\n\tif (!card)\t \n\t\treturn 0;\n\tcmi = card->private_data;\n\tsnd_cmi8328_cfg_restore(cmi->port, cmi->cfg);\n\toutb(cmi->wss_cfg, cmi->port);\n\tcmi->wss->resume(cmi->wss);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n#endif\n\nstatic struct isa_driver snd_cmi8328_driver = {\n\t.probe\t\t= snd_cmi8328_probe,\n\t.remove\t\t= snd_cmi8328_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_cmi8328_suspend,\n\t.resume\t\t= snd_cmi8328_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= \"cmi8328\"\n\t},\n};\n\nmodule_isa_driver(snd_cmi8328_driver, CMI8328_MAX);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}