{
  "module_name": "galaxy.c",
  "hash_id": "71de82f49937538cbf186b8c4da453a931f098bf295d2ee695477b4303755570",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/galaxy/galaxy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <asm/processor.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n\nMODULE_DESCRIPTION(CRD_NAME);\nMODULE_AUTHOR(\"Rene Herman\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CRD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CRD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CRD_NAME \" soundcard.\");\n\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long wss_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\n\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(wss_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(wss_port, \"WSS port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"Playback DMA # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"Capture DMA # for \" CRD_NAME \" driver.\");\n\n \n\n#define DSP_PORT_RESET\t\t0x6\n#define DSP_PORT_READ\t\t0xa\n#define DSP_PORT_COMMAND\t0xc\n#define DSP_PORT_STATUS\t\t0xc\n#define DSP_PORT_DATA_AVAIL\t0xe\n\n#define DSP_SIGNATURE\t\t0xaa\n\n#define DSP_COMMAND_GET_VERSION\t0xe1\n\nstatic int dsp_get_byte(void __iomem *port, u8 *val)\n{\n\tint loops = 1000;\n\n\twhile (!(ioread8(port + DSP_PORT_DATA_AVAIL) & 0x80)) {\n\t\tif (!loops--)\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\t*val = ioread8(port + DSP_PORT_READ);\n\treturn 0;\n}\n\nstatic int dsp_reset(void __iomem *port)\n{\n\tu8 val;\n\n\tiowrite8(1, port + DSP_PORT_RESET);\n\tudelay(10);\n\tiowrite8(0, port + DSP_PORT_RESET);\n\n\tif (dsp_get_byte(port, &val) < 0 || val != DSP_SIGNATURE)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int dsp_command(void __iomem *port, u8 cmd)\n{\n\tint loops = 1000;\n\n\twhile (ioread8(port + DSP_PORT_STATUS) & 0x80) {\n\t\tif (!loops--)\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\tiowrite8(cmd, port + DSP_PORT_COMMAND);\n\treturn 0;\n}\n\nstatic int dsp_get_version(void __iomem *port, u8 *major, u8 *minor)\n{\n\tint err;\n\n\terr = dsp_command(port, DSP_COMMAND_GET_VERSION);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_get_byte(port, major);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_get_byte(port, minor);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\n#define WSS_CONFIG_DMA_0\t(1 << 0)\n#define WSS_CONFIG_DMA_1\t(2 << 0)\n#define WSS_CONFIG_DMA_3\t(3 << 0)\n#define WSS_CONFIG_DUPLEX\t(1 << 2)\n#define WSS_CONFIG_IRQ_7\t(1 << 3)\n#define WSS_CONFIG_IRQ_9\t(2 << 3)\n#define WSS_CONFIG_IRQ_10\t(3 << 3)\n#define WSS_CONFIG_IRQ_11\t(4 << 3)\n\n#define WSS_PORT_CONFIG\t\t0\n#define WSS_PORT_SIGNATURE\t3\n\n#define WSS_SIGNATURE\t\t4\n\nstatic int wss_detect(void __iomem *wss_port)\n{\n\tif ((ioread8(wss_port + WSS_PORT_SIGNATURE) & 0x3f) != WSS_SIGNATURE)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void wss_set_config(void __iomem *wss_port, u8 wss_config)\n{\n\tiowrite8(wss_config, wss_port + WSS_PORT_CONFIG);\n}\n\n \n\n#define GALAXY_PORT_CONFIG\t1024\n#define CONFIG_PORT_SET\t\t4\n\n#define DSP_COMMAND_GALAXY_8\t8\n#define GALAXY_COMMAND_GET_TYPE\t5\n\n#define DSP_COMMAND_GALAXY_9\t9\n#define GALAXY_COMMAND_WSSMODE\t0\n#define GALAXY_COMMAND_SB8MODE\t1\n\n#define GALAXY_MODE_WSS\t\tGALAXY_COMMAND_WSSMODE\n#define GALAXY_MODE_SB8\t\tGALAXY_COMMAND_SB8MODE\n\nstruct snd_galaxy {\n\tvoid __iomem *port;\n\tvoid __iomem *config_port;\n\tvoid __iomem *wss_port;\n\tu32 config;\n\tstruct resource *res_port;\n\tstruct resource *res_config_port;\n\tstruct resource *res_wss_port;\n};\n\nstatic u32 config[SNDRV_CARDS];\nstatic u8 wss_config[SNDRV_CARDS];\n\nstatic int snd_galaxy_match(struct device *dev, unsigned int n)\n{\n\tif (!enable[n])\n\t\treturn 0;\n\n\tswitch (port[n]) {\n\tcase SNDRV_AUTO_PORT:\n\t\tdev_err(dev, \"please specify port\\n\");\n\t\treturn 0;\n\tcase 0x220:\n\t\tconfig[n] |= GALAXY_CONFIG_SBA_220;\n\t\tbreak;\n\tcase 0x240:\n\t\tconfig[n] |= GALAXY_CONFIG_SBA_240;\n\t\tbreak;\n\tcase 0x260:\n\t\tconfig[n] |= GALAXY_CONFIG_SBA_260;\n\t\tbreak;\n\tcase 0x280:\n\t\tconfig[n] |= GALAXY_CONFIG_SBA_280;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid port %#lx\\n\", port[n]);\n\t\treturn 0;\n\t}\n\n\tswitch (wss_port[n]) {\n\tcase SNDRV_AUTO_PORT:\n\t\tdev_err(dev,  \"please specify wss_port\\n\");\n\t\treturn 0;\n\tcase 0x530:\n\t\tconfig[n] |= GALAXY_CONFIG_WSS_ENABLE | GALAXY_CONFIG_WSSA_530;\n\t\tbreak;\n\tcase 0x604:\n\t\tconfig[n] |= GALAXY_CONFIG_WSS_ENABLE | GALAXY_CONFIG_WSSA_604;\n\t\tbreak;\n\tcase 0xe80:\n\t\tconfig[n] |= GALAXY_CONFIG_WSS_ENABLE | GALAXY_CONFIG_WSSA_E80;\n\t\tbreak;\n\tcase 0xf40:\n\t\tconfig[n] |= GALAXY_CONFIG_WSS_ENABLE | GALAXY_CONFIG_WSSA_F40;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid WSS port %#lx\\n\", wss_port[n]);\n\t\treturn 0;\n\t}\n\n\tswitch (irq[n]) {\n\tcase SNDRV_AUTO_IRQ:\n\t\tdev_err(dev,  \"please specify irq\\n\");\n\t\treturn 0;\n\tcase 7:\n\t\twss_config[n] |= WSS_CONFIG_IRQ_7;\n\t\tbreak;\n\tcase 2:\n\t\tirq[n] = 9;\n\t\tfallthrough;\n\tcase 9:\n\t\twss_config[n] |= WSS_CONFIG_IRQ_9;\n\t\tbreak;\n\tcase 10:\n\t\twss_config[n] |= WSS_CONFIG_IRQ_10;\n\t\tbreak;\n\tcase 11:\n\t\twss_config[n] |= WSS_CONFIG_IRQ_11;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid IRQ %d\\n\", irq[n]);\n\t\treturn 0;\n\t}\n\n\tswitch (dma1[n]) {\n\tcase SNDRV_AUTO_DMA:\n\t\tdev_err(dev,  \"please specify dma1\\n\");\n\t\treturn 0;\n\tcase 0:\n\t\twss_config[n] |= WSS_CONFIG_DMA_0;\n\t\tbreak;\n\tcase 1:\n\t\twss_config[n] |= WSS_CONFIG_DMA_1;\n\t\tbreak;\n\tcase 3:\n\t\twss_config[n] |= WSS_CONFIG_DMA_3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid playback DMA %d\\n\", dma1[n]);\n\t\treturn 0;\n\t}\n\n\tif (dma2[n] == SNDRV_AUTO_DMA || dma2[n] == dma1[n]) {\n\t\tdma2[n] = -1;\n\t\tgoto mpu;\n\t}\n\n\twss_config[n] |= WSS_CONFIG_DUPLEX;\n\tswitch (dma2[n]) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tif (dma1[n] == 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(dev, \"invalid capture DMA %d\\n\", dma2[n]);\n\t\treturn 0;\n\t}\n\nmpu:\n\tswitch (mpu_port[n]) {\n\tcase SNDRV_AUTO_PORT:\n\t\tdev_warn(dev, \"mpu_port not specified; not using MPU-401\\n\");\n\t\tmpu_port[n] = -1;\n\t\tgoto fm;\n\tcase 0x300:\n\t\tconfig[n] |= GALAXY_CONFIG_MPU_ENABLE | GALAXY_CONFIG_MPUA_300;\n\t\tbreak;\n\tcase 0x330:\n\t\tconfig[n] |= GALAXY_CONFIG_MPU_ENABLE | GALAXY_CONFIG_MPUA_330;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid MPU port %#lx\\n\", mpu_port[n]);\n\t\treturn 0;\n\t}\n\n\tswitch (mpu_irq[n]) {\n\tcase SNDRV_AUTO_IRQ:\n\t\tdev_warn(dev, \"mpu_irq not specified: using polling mode\\n\");\n\t\tmpu_irq[n] = -1;\n\t\tbreak;\n\tcase 2:\n\t\tmpu_irq[n] = 9;\n\t\tfallthrough;\n\tcase 9:\n\t\tconfig[n] |= GALAXY_CONFIG_MPUIRQ_2;\n\t\tbreak;\n#ifdef AZT1605\n\tcase 3:\n\t\tconfig[n] |= GALAXY_CONFIG_MPUIRQ_3;\n\t\tbreak;\n#endif\n\tcase 5:\n\t\tconfig[n] |= GALAXY_CONFIG_MPUIRQ_5;\n\t\tbreak;\n\tcase 7:\n\t\tconfig[n] |= GALAXY_CONFIG_MPUIRQ_7;\n\t\tbreak;\n#ifdef AZT2316\n\tcase 10:\n\t\tconfig[n] |= GALAXY_CONFIG_MPUIRQ_10;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_err(dev, \"invalid MPU IRQ %d\\n\", mpu_irq[n]);\n\t\treturn 0;\n\t}\n\n\tif (mpu_irq[n] == irq[n]) {\n\t\tdev_err(dev, \"cannot share IRQ between WSS and MPU-401\\n\");\n\t\treturn 0;\n\t}\n\nfm:\n\tswitch (fm_port[n]) {\n\tcase SNDRV_AUTO_PORT:\n\t\tdev_warn(dev, \"fm_port not specified: not using OPL3\\n\");\n\t\tfm_port[n] = -1;\n\t\tbreak;\n\tcase 0x388:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"illegal FM port %#lx\\n\", fm_port[n]);\n\t\treturn 0;\n\t}\n\n\tconfig[n] |= GALAXY_CONFIG_GAME_ENABLE;\n\treturn 1;\n}\n\nstatic int galaxy_init(struct snd_galaxy *galaxy, u8 *type)\n{\n\tu8 major;\n\tu8 minor;\n\tint err;\n\n\terr = dsp_reset(galaxy->port);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_get_version(galaxy->port, &major, &minor);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (major != GALAXY_DSP_MAJOR || minor != GALAXY_DSP_MINOR)\n\t\treturn -ENODEV;\n\n\terr = dsp_command(galaxy->port, DSP_COMMAND_GALAXY_8);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_command(galaxy->port, GALAXY_COMMAND_GET_TYPE);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_get_byte(galaxy->port, type);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int galaxy_set_mode(struct snd_galaxy *galaxy, u8 mode)\n{\n\tint err;\n\n\terr = dsp_command(galaxy->port, DSP_COMMAND_GALAXY_9);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dsp_command(galaxy->port, mode);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef AZT1605\n\t \n\terr = dsp_reset(galaxy->port);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\treturn 0;\n}\n\nstatic void galaxy_set_config(struct snd_galaxy *galaxy, u32 config)\n{\n\tu8 tmp = ioread8(galaxy->config_port + CONFIG_PORT_SET);\n\tint i;\n\n\tiowrite8(tmp | 0x80, galaxy->config_port + CONFIG_PORT_SET);\n\tfor (i = 0; i < GALAXY_CONFIG_SIZE; i++) {\n\t\tiowrite8(config, galaxy->config_port + i);\n\t\tconfig >>= 8;\n\t}\n\tiowrite8(tmp & 0x7f, galaxy->config_port + CONFIG_PORT_SET);\n\tmsleep(10);\n}\n\nstatic void galaxy_config(struct snd_galaxy *galaxy, u32 config)\n{\n\tint i;\n\n\tfor (i = GALAXY_CONFIG_SIZE; i; i--) {\n\t\tu8 tmp = ioread8(galaxy->config_port + i - 1);\n\t\tgalaxy->config = (galaxy->config << 8) | tmp;\n\t}\n\tconfig |= galaxy->config & GALAXY_CONFIG_MASK;\n\tgalaxy_set_config(galaxy, config);\n}\n\nstatic int galaxy_wss_config(struct snd_galaxy *galaxy, u8 wss_config)\n{\n\tint err;\n\n\terr = wss_detect(galaxy->wss_port);\n\tif (err < 0)\n\t\treturn err;\n\n\twss_set_config(galaxy->wss_port, wss_config);\n\n\terr = galaxy_set_mode(galaxy, GALAXY_MODE_WSS);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void snd_galaxy_free(struct snd_card *card)\n{\n\tstruct snd_galaxy *galaxy = card->private_data;\n\n\tif (galaxy->wss_port)\n\t\twss_set_config(galaxy->wss_port, 0);\n\tif (galaxy->config_port)\n\t\tgalaxy_set_config(galaxy, galaxy->config);\n}\n\nstatic int __snd_galaxy_probe(struct device *dev, unsigned int n)\n{\n\tstruct snd_galaxy *galaxy;\n\tstruct snd_wss *chip;\n\tstruct snd_card *card;\n\tu8 type;\n\tint err;\n\n\terr = snd_devm_card_new(dev, index[n], id[n], THIS_MODULE,\n\t\t\t\tsizeof(*galaxy), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard->private_free = snd_galaxy_free;\n\tgalaxy = card->private_data;\n\n\tgalaxy->res_port = devm_request_region(dev, port[n], 16, DRV_NAME);\n\tif (!galaxy->res_port) {\n\t\tdev_err(dev, \"could not grab ports %#lx-%#lx\\n\", port[n],\n\t\t\tport[n] + 15);\n\t\treturn -EBUSY;\n\t}\n\tgalaxy->port = devm_ioport_map(dev, port[n], 16);\n\tif (!galaxy->port)\n\t\treturn -ENOMEM;\n\n\terr = galaxy_init(galaxy, &type);\n\tif (err < 0) {\n\t\tdev_err(dev, \"did not find a Sound Galaxy at %#lx\\n\", port[n]);\n\t\treturn err;\n\t}\n\tdev_info(dev, \"Sound Galaxy (type %d) found at %#lx\\n\", type, port[n]);\n\n\tgalaxy->res_config_port =\n\t\tdevm_request_region(dev, port[n] + GALAXY_PORT_CONFIG, 16,\n\t\t\t\t    DRV_NAME);\n\tif (!galaxy->res_config_port) {\n\t\tdev_err(dev, \"could not grab ports %#lx-%#lx\\n\",\n\t\t\tport[n] + GALAXY_PORT_CONFIG,\n\t\t\tport[n] + GALAXY_PORT_CONFIG + 15);\n\t\treturn -EBUSY;\n\t}\n\tgalaxy->config_port =\n\t\tdevm_ioport_map(dev, port[n] + GALAXY_PORT_CONFIG, 16);\n\tif (!galaxy->config_port)\n\t\treturn -ENOMEM;\n\tgalaxy_config(galaxy, config[n]);\n\n\tgalaxy->res_wss_port = devm_request_region(dev, wss_port[n], 4, DRV_NAME);\n\tif (!galaxy->res_wss_port)  {\n\t\tdev_err(dev, \"could not grab ports %#lx-%#lx\\n\", wss_port[n],\n\t\t\twss_port[n] + 3);\n\t\treturn -EBUSY;\n\t}\n\tgalaxy->wss_port = devm_ioport_map(dev, wss_port[n], 4);\n\tif (!galaxy->wss_port)\n\t\treturn -ENOMEM;\n\n\terr = galaxy_wss_config(galaxy, wss_config[n]);\n\tif (err < 0) {\n\t\tdev_err(dev, \"could not configure WSS\\n\");\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, DRV_NAME);\n\tstrcpy(card->shortname, DRV_NAME);\n\tsprintf(card->longname, \"%s at %#lx/%#lx, irq %d, dma %d/%d\",\n\t\tcard->shortname, port[n], wss_port[n], irq[n], dma1[n],\n\t\tdma2[n]);\n\n\terr = snd_wss_create(card, wss_port[n] + 4, -1, irq[n], dma1[n],\n\t\t\t     dma2[n], WSS_HW_DETECT, 0, &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_timer(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mpu_port[n] >= 0) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\t\t  mpu_port[n], 0, mpu_irq[n], NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (fm_port[n] >= 0) {\n\t\tstruct snd_opl3 *opl3;\n\n\t\terr = snd_opl3_create(card, fm_port[n], fm_port[n] + 2,\n\t\t\t\t      OPL3_HW_AUTO, 0, &opl3);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"no OPL device at %#lx\\n\", fm_port[n]);\n\t\t\treturn err;\n\t\t}\n\t\terr = snd_opl3_timer_new(opl3, 1, 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_set_drvdata(dev, card);\n\treturn 0;\n}\n\nstatic int snd_galaxy_probe(struct device *dev, unsigned int n)\n{\n\treturn snd_card_free_on_error(dev, __snd_galaxy_probe(dev, n));\n}\n\nstatic struct isa_driver snd_galaxy_driver = {\n\t.match\t\t= snd_galaxy_match,\n\t.probe\t\t= snd_galaxy_probe,\n\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t}\n};\n\nmodule_isa_driver(snd_galaxy_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}