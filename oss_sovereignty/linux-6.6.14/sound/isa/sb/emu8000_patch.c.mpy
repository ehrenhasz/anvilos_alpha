{
  "module_name": "emu8000_patch.c",
  "hash_id": "654880b97bd84bcf17773db78207ff260c78ede926bbc64551a3d9d0a4b847cf",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/emu8000_patch.c",
  "human_readable_source": "\n \n\n#include \"emu8000_local.h\"\n\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n\nstatic int emu8000_reset_addr;\nmodule_param(emu8000_reset_addr, int, 0444);\nMODULE_PARM_DESC(emu8000_reset_addr, \"reset write address at each time (makes slowdown)\");\n\n\n \nstatic int\nsnd_emu8000_open_dma(struct snd_emu8000 *emu, int write)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < EMU8000_DRAM_VOICES; i++) {\n\t\tsnd_emux_lock_voice(emu->emu, i);\n\t\tsnd_emu8000_dma_chan(emu, i, write);\n\t}\n\n\t \n\tEMU8000_VTFT_WRITE(emu, 30, 0);\n\tEMU8000_PSST_WRITE(emu, 30, 0x1d8);\n\tEMU8000_CSL_WRITE(emu, 30, 0x1e0);\n\tEMU8000_CCCA_WRITE(emu, 30, 0x1d8);\n\tEMU8000_VTFT_WRITE(emu, 31, 0);\n\tEMU8000_PSST_WRITE(emu, 31, 0x1d8);\n\tEMU8000_CSL_WRITE(emu, 31, 0x1e0);\n\tEMU8000_CCCA_WRITE(emu, 31, 0x1d8);\n\n\treturn 0;\n}\n\n \nstatic void\nsnd_emu8000_close_dma(struct snd_emu8000 *emu)\n{\n\tint i;\n\n\tfor (i = 0; i < EMU8000_DRAM_VOICES; i++) {\n\t\tsnd_emu8000_dma_chan(emu, i, EMU8000_RAM_CLOSE);\n\t\tsnd_emux_unlock_voice(emu->emu, i);\n\t}\n}\n\n \n\n#define BLANK_LOOP_START\t4\n#define BLANK_LOOP_END\t\t8\n#define BLANK_LOOP_SIZE\t\t12\n#define BLANK_HEAD_SIZE\t\t48\n\n \nstatic unsigned short\nread_word(const void __user *buf, int offset, int mode)\n{\n\tunsigned short c;\n\tif (mode & SNDRV_SFNT_SAMPLE_8BITS) {\n\t\tunsigned char cc;\n\t\tget_user(cc, (unsigned char __user *)buf + offset);\n\t\tc = cc << 8;  \n\t} else {\n#ifdef SNDRV_LITTLE_ENDIAN\n\t\tget_user(c, (unsigned short __user *)buf + offset);\n#else\n\t\tunsigned short cc;\n\t\tget_user(cc, (unsigned short __user *)buf + offset);\n\t\tc = swab16(cc);\n#endif\n\t}\n\tif (mode & SNDRV_SFNT_SAMPLE_UNSIGNED)\n\t\tc ^= 0x8000;  \n\treturn c;\n}\n\n \nstatic void\nsnd_emu8000_write_wait(struct snd_emu8000 *emu)\n{\n\twhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\n\t\tschedule_timeout_interruptible(1);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic inline void\nwrite_word(struct snd_emu8000 *emu, int *offset, unsigned short data)\n{\n\tif (emu8000_reset_addr) {\n\t\tif (emu8000_reset_addr > 1)\n\t\t\tsnd_emu8000_write_wait(emu);\n\t\tEMU8000_SMALW_WRITE(emu, *offset);\n\t}\n\tEMU8000_SMLD_WRITE(emu, data);\n\t*offset += 1;\n}\n\n \nint\nsnd_emu8000_sample_new(struct snd_emux *rec, struct snd_sf_sample *sp,\n\t\t       struct snd_util_memhdr *hdr,\n\t\t       const void __user *data, long count)\n{\n\tint  i;\n\tint  rc;\n\tint  offset;\n\tint  truesize;\n\tint  dram_offset, dram_start;\n\tstruct snd_emu8000 *emu;\n\n\temu = rec->hw;\n\tif (snd_BUG_ON(!sp))\n\t\treturn -EINVAL;\n\n\tif (sp->v.size == 0)\n\t\treturn 0;\n\n\t \n\tif (sp->v.loopstart > sp->v.loopend)\n\t\tswap(sp->v.loopstart, sp->v.loopend);\n\n\t \n\ttruesize = sp->v.size;\n\tif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP))\n\t\ttruesize += sp->v.loopend - sp->v.loopstart;\n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK)\n\t\ttruesize += BLANK_LOOP_SIZE;\n\n\tsp->block = snd_util_mem_alloc(hdr, truesize * 2);\n\tif (sp->block == NULL) {\n\t\t \n\t\t \n\t\treturn -ENOSPC;\n\t}\n\n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS) {\n\t\tif (!access_ok(data, sp->v.size))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (!access_ok(data, sp->v.size * 2))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tsp->v.end -= sp->v.start;\n\tsp->v.loopstart -= sp->v.start;\n\tsp->v.loopend -= sp->v.start;\n\tsp->v.start = 0;\n\n\t \n\tdram_offset = EMU8000_DRAM_OFFSET + (sp->block->offset >> 1);\n\tdram_start = dram_offset;\n\n\t \n\tsp->v.truesize = truesize * 2;  \n\n\tsnd_emux_terminate_all(emu->emu);\n\trc = snd_emu8000_open_dma(emu, EMU8000_RAM_WRITE);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tsnd_emu8000_write_wait(emu);\n\tEMU8000_SMALW_WRITE(emu, dram_offset);\n\n\t \n\n#if 0\n\t \n\tif (! sp->block->offset) {\n\t\tfor (i = 0; i < BLANK_HEAD_SIZE; i++) {\n\t\t\twrite_word(emu, &dram_offset, 0);\n\t\t}\n\t}\n#endif\n\n\toffset = 0;\n\tfor (i = 0; i < sp->v.size; i++) {\n\t\tunsigned short s;\n\n\t\ts = read_word(data, offset, sp->v.mode_flags);\n\t\toffset++;\n\t\twrite_word(emu, &dram_offset, s);\n\n\t\t \n\t\tcond_resched();\n\n\t\tif (i == sp->v.loopend &&\n\t\t    (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP)))\n\t\t{\n\t\t\tint looplen = sp->v.loopend - sp->v.loopstart;\n\t\t\tint k;\n\n\t\t\t \n\t\t\tfor (k = 1; k <= looplen; k++) {\n\t\t\t\ts = read_word(data, offset - k, sp->v.mode_flags);\n\t\t\t\twrite_word(emu, &dram_offset, s);\n\t\t\t}\n\t\t\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_BIDIR_LOOP) {\n\t\t\t\tsp->v.loopend += looplen;\n\t\t\t} else {\n\t\t\t\tsp->v.loopstart += looplen;\n\t\t\t\tsp->v.loopend += looplen;\n\t\t\t}\n\t\t\tsp->v.end += looplen;\n\t\t}\n\t}\n\n\t \n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK) {\n\t\tfor (i = 0; i < BLANK_LOOP_SIZE; i++) {\n\t\t\twrite_word(emu, &dram_offset, 0);\n\t\t}\n\t\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT) {\n\t\t\tsp->v.loopstart = sp->v.end + BLANK_LOOP_START;\n\t\t\tsp->v.loopend = sp->v.end + BLANK_LOOP_END;\n\t\t}\n\t}\n\n\t \n\tsp->v.start += dram_start;\n\tsp->v.end += dram_start;\n\tsp->v.loopstart += dram_start;\n\tsp->v.loopend += dram_start;\n\n\tsnd_emu8000_close_dma(emu);\n\tsnd_emu8000_init_fm(emu);\n\n\treturn 0;\n}\n\n \nint\nsnd_emu8000_sample_free(struct snd_emux *rec, struct snd_sf_sample *sp,\n\t\t\tstruct snd_util_memhdr *hdr)\n{\n\tif (sp->block) {\n\t\tsnd_util_mem_free(hdr, sp->block);\n\t\tsp->block = NULL;\n\t}\n\treturn 0;\n}\n\n\n \nvoid\nsnd_emu8000_sample_reset(struct snd_emux *rec)\n{\n\tsnd_emux_terminate_all(rec);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}