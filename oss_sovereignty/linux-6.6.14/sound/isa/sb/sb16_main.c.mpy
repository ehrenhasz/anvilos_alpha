{
  "module_name": "sb16_main.c",
  "hash_id": "df62408e8e1e504694944f04d71124cceddc4fc44d5c032c522ac9f9b9f0a511",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb16_main.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/sb16_csp.h>\n#include <sound/mpu401.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for control of 16-bit SoundBlaster cards and clones\");\nMODULE_LICENSE(\"GPL\");\n\n#define runtime_format_bits(runtime) \\\n\t((unsigned int)pcm_format_to_bits((runtime)->format))\n\n#ifdef CONFIG_SND_SB16_CSP\nstatic void snd_sb16_csp_playback_prepare(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\n{\n\tif (chip->hardware == SB_HW_16CSP) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\n\t\t\t \n\t\t\tif ((csp->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) &&\n\t\t\t    (runtime_format_bits(runtime) == csp->acc_format)) {\n\t\t\t\t \n\t\t\t\tif (csp->ops.csp_use(csp) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tgoto __start_CSP;\n\t\t\t\t}\n\t\t\t} else if ((csp->mode & SNDRV_SB_CSP_MODE_QSOUND) && (csp->q_enabled)) {\n\t\t\t\t \n\t\t\t\tif (runtime_format_bits(runtime) & (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t\t\t\t      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE)) {\n\t\t\t\t\t \n\t\t\t\t\tif (csp->ops.csp_use(csp) == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto __start_CSP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (csp->ops.csp_use(csp) == 0) {\n\t\t\t \n\t\t\tif (csp->ops.csp_autoload(csp, runtime->format, SNDRV_SB_CSP_MODE_DSP_WRITE)) {\n\t\t\t\t \n\t\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\t} else {\n\t\t      __start_CSP:\n\t\t\t\t \n\t\t\t\tif (csp->ops.csp_start(csp, (chip->mode & SB_MODE_PLAYBACK_16) ?\n\t\t\t\t\t\t       SNDRV_SB_CSP_SAMPLE_16BIT : SNDRV_SB_CSP_SAMPLE_8BIT,\n\t\t\t\t\t\t       (runtime->channels > 1) ?\n\t\t\t\t\t\t       SNDRV_SB_CSP_STEREO : SNDRV_SB_CSP_MONO)) {\n\t\t\t\t\t \n\t\t\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tchip->open = SNDRV_SB_CSP_MODE_DSP_WRITE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_capture_prepare(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\n{\n\tif (chip->hardware == SB_HW_16CSP) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\n\t\t\t \n\t\t\tif ((csp->mode & SNDRV_SB_CSP_MODE_DSP_READ) &&\n\t\t\t    (runtime_format_bits(runtime) == csp->acc_format)) {\n\t\t\t\t \n\t\t\t\tif (csp->ops.csp_use(csp) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tgoto __start_CSP;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (csp->ops.csp_use(csp) == 0) {\n\t\t\t \n\t\t\tif (csp->ops.csp_autoload(csp, runtime->format, SNDRV_SB_CSP_MODE_DSP_READ)) {\n\t\t\t\t \n\t\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\t} else {\n\t\t      __start_CSP:\n\t\t\t\t \n\t\t\t\tif (csp->ops.csp_start(csp, (chip->mode & SB_MODE_CAPTURE_16) ?\n\t\t\t\t\t\t       SNDRV_SB_CSP_SAMPLE_16BIT : SNDRV_SB_CSP_SAMPLE_8BIT,\n\t\t\t\t\t\t       (runtime->channels > 1) ?\n\t\t\t\t\t\t       SNDRV_SB_CSP_STEREO : SNDRV_SB_CSP_MONO)) {\n\t\t\t\t\t \n\t\t\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tchip->open = SNDRV_SB_CSP_MODE_DSP_READ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_update(struct snd_sb *chip)\n{\n\tif (chip->hardware == SB_HW_16CSP) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->qpos_changed) {\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t\tcsp->ops.csp_qsound_transfer (csp);\n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_playback_open(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\n{\n\t \n\tif (chip->hardware == SB_HW_16CSP) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\n\t\t\t \n\t\t\tif (csp->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) {\n\t\t\t\truntime->hw.formats |= csp->acc_format;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\truntime->hw.formats |= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t\t       SNDRV_PCM_FMTBIT_IMA_ADPCM;\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_playback_close(struct snd_sb *chip)\n{\n\tif ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_WRITE)) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->ops.csp_stop(csp) == 0) {\n\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\tchip->open = 0;\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_capture_open(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\n{\n\t \n\tif (chip->hardware == SB_HW_16CSP) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\n\t\t\t \n\t\t\tif (csp->mode & SNDRV_SB_CSP_MODE_DSP_READ) {\n\t\t\t\truntime->hw.formats |= csp->acc_format;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\truntime->hw.formats |= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t\t       SNDRV_PCM_FMTBIT_IMA_ADPCM;\n\t\t}\n\t}\n}\n\nstatic void snd_sb16_csp_capture_close(struct snd_sb *chip)\n{\n\tif ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_READ)) {\n\t\tstruct snd_sb_csp *csp = chip->csp;\n\n\t\tif (csp->ops.csp_stop(csp) == 0) {\n\t\t\tcsp->ops.csp_unuse(csp);\n\t\t\tchip->open = 0;\n\t\t}\n\t}\n}\n#else\n#define snd_sb16_csp_playback_prepare(chip, runtime)\t \n#define snd_sb16_csp_capture_prepare(chip, runtime)\t \n#define snd_sb16_csp_update(chip)\t\t\t \n#define snd_sb16_csp_playback_open(chip, runtime)\t \n#define snd_sb16_csp_playback_close(chip)\t\t \n#define snd_sb16_csp_capture_open(chip, runtime)\t \n#define snd_sb16_csp_capture_close(chip)      \t \t \n#endif\n\n\nstatic void snd_sb16_setup_rate(struct snd_sb *chip,\n\t\t\t\tunsigned short rate,\n\t\t\t\tint channel)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->mode & (channel == SNDRV_PCM_STREAM_PLAYBACK ? SB_MODE_PLAYBACK_16 : SB_MODE_CAPTURE_16))\n\t\tsnd_sb_ack_16bit(chip);\n\telse\n\t\tsnd_sb_ack_8bit(chip);\n\tif (!(chip->mode & SB_RATE_LOCK)) {\n\t\tchip->locked_rate = rate;\n\t\tsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_IN);\n\t\tsnd_sbdsp_command(chip, rate >> 8);\n\t\tsnd_sbdsp_command(chip, rate & 0xff);\n\t\tsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);\n\t\tsnd_sbdsp_command(chip, rate >> 8);\n\t\tsnd_sbdsp_command(chip, rate & 0xff);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic int snd_sb16_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned char format;\n\tunsigned int size, count, dma;\n\n\tsnd_sb16_csp_playback_prepare(chip, runtime);\n\tif (snd_pcm_format_unsigned(runtime->format) > 0) {\n\t\tformat = runtime->channels > 1 ? SB_DSP4_MODE_UNS_STEREO : SB_DSP4_MODE_UNS_MONO;\n\t} else {\n\t\tformat = runtime->channels > 1 ? SB_DSP4_MODE_SIGN_STEREO : SB_DSP4_MODE_SIGN_MONO;\n\t}\n\n\tsnd_sb16_setup_rate(chip, runtime->rate, SNDRV_PCM_STREAM_PLAYBACK);\n\tsize = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tdma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;\n\tsnd_dma_program(dma, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\n\n\tcount = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->mode & SB_MODE_PLAYBACK_16) {\n\t\tcount >>= 1;\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP4_OUT16_AI);\n\t\tsnd_sbdsp_command(chip, format);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\tsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\n\t} else {\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP4_OUT8_AI);\n\t\tsnd_sbdsp_command(chip, format);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->mode |= SB_RATE_LOCK_PLAYBACK;\n\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);\n\t\t \n\t\tif (chip->mode & SB_RATE_LOCK_CAPTURE)\n\t\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\n\t\tchip->mode &= ~SB_RATE_LOCK_PLAYBACK;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn result;\n}\n\nstatic int snd_sb16_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned char format;\n\tunsigned int size, count, dma;\n\n\tsnd_sb16_csp_capture_prepare(chip, runtime);\n\tif (snd_pcm_format_unsigned(runtime->format) > 0) {\n\t\tformat = runtime->channels > 1 ? SB_DSP4_MODE_UNS_STEREO : SB_DSP4_MODE_UNS_MONO;\n\t} else {\n\t\tformat = runtime->channels > 1 ? SB_DSP4_MODE_SIGN_STEREO : SB_DSP4_MODE_SIGN_MONO;\n\t}\n\tsnd_sb16_setup_rate(chip, runtime->rate, SNDRV_PCM_STREAM_CAPTURE);\n\tsize = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tdma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;\n\tsnd_dma_program(dma, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\n\n\tcount = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->mode & SB_MODE_CAPTURE_16) {\n\t\tcount >>= 1;\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP4_IN16_AI);\n\t\tsnd_sbdsp_command(chip, format);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\tsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\n\t} else {\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP4_IN8_AI);\n\t\tsnd_sbdsp_command(chip, format);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->mode |= SB_RATE_LOCK_CAPTURE;\n\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);\n\t\t \n\t\tif (chip->mode & SB_RATE_LOCK_PLAYBACK)\n\t\t\tsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\n\t\tchip->mode &= ~SB_RATE_LOCK_CAPTURE;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn result;\n}\n\nirqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_sb *chip = dev_id;\n\tunsigned char status;\n\tint ok;\n\n\tspin_lock(&chip->mixer_lock);\n\tstatus = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);\n\tspin_unlock(&chip->mixer_lock);\n\tif ((status & SB_IRQTYPE_MPUIN) && chip->rmidi_callback)\n\t\tchip->rmidi_callback(irq, chip->rmidi->private_data);\n\tif (status & SB_IRQTYPE_8BIT) {\n\t\tok = 0;\n\t\tif (chip->mode & SB_MODE_PLAYBACK_8) {\n\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t\tsnd_sb16_csp_update(chip);\n\t\t\tok++;\n\t\t}\n\t\tif (chip->mode & SB_MODE_CAPTURE_8) {\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\tok++;\n\t\t}\n\t\tspin_lock(&chip->reg_lock);\n\t\tif (!ok)\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\n\t\tsnd_sb_ack_8bit(chip);\n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\tif (status & SB_IRQTYPE_16BIT) {\n\t\tok = 0;\n\t\tif (chip->mode & SB_MODE_PLAYBACK_16) {\n\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t\tsnd_sb16_csp_update(chip);\n\t\t\tok++;\n\t\t}\n\t\tif (chip->mode & SB_MODE_CAPTURE_16) {\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\tok++;\n\t\t}\n\t\tspin_lock(&chip->reg_lock);\n\t\tif (!ok)\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\n\t\tsnd_sb_ack_16bit(chip);\n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic snd_pcm_uframes_t snd_sb16_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned int dma;\n\tsize_t ptr;\n\n\tdma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;\n\tptr = snd_dma_pointer(dma, chip->p_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_sb16_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned int dma;\n\tsize_t ptr;\n\n\tdma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;\n\tptr = snd_dma_pointer(dma, chip->c_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_sb16_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t0,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_44100,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t44100,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_sb16_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t0,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_44100,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t44100,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic int snd_sb16_playback_open(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (chip->mode & SB_MODE_PLAYBACK) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\truntime->hw = snd_sb16_playback;\n\n\t \n\tif (chip->force_mode16 & SB_MODE_CAPTURE_16)\n\t\tgoto __skip_16bit;\n\n\tif (chip->dma16 >= 0 && !(chip->mode & SB_MODE_CAPTURE_16)) {\n\t\tchip->mode |= SB_MODE_PLAYBACK_16;\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\n\t\t \n\t\tif (chip->dma16 <= 3) {\n\t\t\truntime->hw.buffer_bytes_max =\n\t\t\truntime->hw.period_bytes_max = 64 * 1024;\n\t\t} else {\n\t\t\tsnd_sb16_csp_playback_open(chip, runtime);\n\t\t}\n\t\tgoto __open_ok;\n\t}\n\n      __skip_16bit:\n\tif (chip->dma8 >= 0 && !(chip->mode & SB_MODE_CAPTURE_8)) {\n\t\tchip->mode |= SB_MODE_PLAYBACK_8;\n\t\t \n\t\tif (chip->dma16 < 0) {\n\t\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\n\t\t\tchip->mode |= SB_MODE_PLAYBACK_16;\n\t\t} else {\n\t\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8;\n\t\t}\n\t\truntime->hw.buffer_bytes_max =\n\t\truntime->hw.period_bytes_max = 64 * 1024;\n\t\tgoto __open_ok;\n\t}\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn -EAGAIN;\n\n      __open_ok:\n\tif (chip->hardware == SB_HW_ALS100)\n\t\truntime->hw.rate_max = 48000;\n\tif (chip->hardware == SB_HW_CS5530) {\n\t\truntime->hw.buffer_bytes_max = 32 * 1024;\n\t\truntime->hw.periods_min = 2;\n\t\truntime->hw.rate_min = 44100;\n\t}\n\tif (chip->mode & SB_RATE_LOCK)\n\t\truntime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;\n\tchip->playback_substream = substream;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_playback_close(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_sb16_csp_playback_close(chip);\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tchip->playback_substream = NULL;\n\tchip->mode &= ~SB_MODE_PLAYBACK;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_capture_open(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (chip->mode & SB_MODE_CAPTURE) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\truntime->hw = snd_sb16_capture;\n\n\t \n\tif (chip->force_mode16 & SB_MODE_PLAYBACK_16)\n\t\tgoto __skip_16bit;\n\n\tif (chip->dma16 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_16)) {\n\t\tchip->mode |= SB_MODE_CAPTURE_16;\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\n\t\t \n\t\tif (chip->dma16 <= 3) {\n\t\t\truntime->hw.buffer_bytes_max =\n\t\t\truntime->hw.period_bytes_max = 64 * 1024;\n\t\t} else {\n\t\t\tsnd_sb16_csp_capture_open(chip, runtime);\n\t\t}\n\t\tgoto __open_ok;\n\t}\n\n      __skip_16bit:\n\tif (chip->dma8 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_8)) {\n\t\tchip->mode |= SB_MODE_CAPTURE_8;\n\t\t \n\t\tif (chip->dma16 < 0) {\n\t\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\n\t\t\tchip->mode |= SB_MODE_CAPTURE_16;\n\t\t} else {\n\t\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8;\n\t\t}\n\t\truntime->hw.buffer_bytes_max =\n\t\truntime->hw.period_bytes_max = 64 * 1024;\n\t\tgoto __open_ok;\n\t}\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn -EAGAIN;\n\n      __open_ok:\n\tif (chip->hardware == SB_HW_ALS100)\n\t\truntime->hw.rate_max = 48000;\n\tif (chip->hardware == SB_HW_CS5530) {\n\t\truntime->hw.buffer_bytes_max = 32 * 1024;\n\t\truntime->hw.periods_min = 2;\n\t\truntime->hw.rate_min = 44100;\n\t}\n\tif (chip->mode & SB_RATE_LOCK)\n\t\truntime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;\n\tchip->capture_substream = substream;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_capture_close(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_sb16_csp_capture_close(chip);\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tchip->capture_substream = NULL;\n\tchip->mode &= ~SB_MODE_CAPTURE;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int snd_sb16_set_dma_mode(struct snd_sb *chip, int what)\n{\n\tif (chip->dma8 < 0 || chip->dma16 < 0) {\n\t\tif (snd_BUG_ON(what))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (what == 0) {\n\t\tchip->force_mode16 = 0;\n\t} else if (what == 1) {\n\t\tchip->force_mode16 = SB_MODE_PLAYBACK_16;\n\t} else if (what == 2) {\n\t\tchip->force_mode16 = SB_MODE_CAPTURE_16;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb16_get_dma_mode(struct snd_sb *chip)\n{\n\tif (chip->dma8 < 0 || chip->dma16 < 0)\n\t\treturn 0;\n\tswitch (chip->force_mode16) {\n\tcase SB_MODE_PLAYBACK_16:\n\t\treturn 1;\n\tcase SB_MODE_CAPTURE_16:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int snd_sb16_dma_control_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"Auto\", \"Playback\", \"Capture\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_sb16_dma_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.enumerated.item[0] = snd_sb16_get_dma_mode(chip);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb16_dma_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned char nval, oval;\n\tint change;\n\t\n\tnval = ucontrol->value.enumerated.item[0];\n\tif (nval > 2)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toval = snd_sb16_get_dma_mode(chip);\n\tchange = nval != oval;\n\tsnd_sb16_set_dma_mode(chip, nval);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_sb16_dma_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"16-bit DMA Allocation\",\n\t.info = snd_sb16_dma_control_info,\n\t.get = snd_sb16_dma_control_get,\n\t.put = snd_sb16_dma_control_put\n};\n\n \n \nint snd_sb16dsp_configure(struct snd_sb * chip)\n{\n\tunsigned long flags;\n\tunsigned char irqreg = 0, dmareg = 0, mpureg;\n\tunsigned char realirq, realdma, realmpureg;\n\t \n\n\t\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\tmpureg = snd_sbmixer_read(chip, SB_DSP4_MPUSETUP) & ~0x06;\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\tswitch (chip->irq) {\n\tcase 2:\n\tcase 9:\n\t\tirqreg |= SB_IRQSETUP_IRQ9;\n\t\tbreak;\n\tcase 5:\n\t\tirqreg |= SB_IRQSETUP_IRQ5;\n\t\tbreak;\n\tcase 7:\n\t\tirqreg |= SB_IRQSETUP_IRQ7;\n\t\tbreak;\n\tcase 10:\n\t\tirqreg |= SB_IRQSETUP_IRQ10;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (chip->dma8 >= 0) {\n\t\tswitch (chip->dma8) {\n\t\tcase 0:\n\t\t\tdmareg |= SB_DMASETUP_DMA0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdmareg |= SB_DMASETUP_DMA1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdmareg |= SB_DMASETUP_DMA3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (chip->dma16 >= 0 && chip->dma16 != chip->dma8) {\n\t\tswitch (chip->dma16) {\n\t\tcase 5:\n\t\t\tdmareg |= SB_DMASETUP_DMA5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdmareg |= SB_DMASETUP_DMA6;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdmareg |= SB_DMASETUP_DMA7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tswitch (chip->mpu_port) {\n\tcase 0x300:\n\t\tmpureg |= 0x04;\n\t\tbreak;\n\tcase 0x330:\n\t\tmpureg |= 0x00;\n\t\tbreak;\n\tdefault:\n\t\tmpureg |= 0x02;\t \n\t}\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\n\tsnd_sbmixer_write(chip, SB_DSP4_IRQSETUP, irqreg);\n\trealirq = snd_sbmixer_read(chip, SB_DSP4_IRQSETUP);\n\n\tsnd_sbmixer_write(chip, SB_DSP4_DMASETUP, dmareg);\n\trealdma = snd_sbmixer_read(chip, SB_DSP4_DMASETUP);\n\n\tsnd_sbmixer_write(chip, SB_DSP4_MPUSETUP, mpureg);\n\trealmpureg = snd_sbmixer_read(chip, SB_DSP4_MPUSETUP);\n\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\tif ((~realirq) & irqreg || (~realdma) & dmareg) {\n\t\tsnd_printk(KERN_ERR \"SB16 [0x%lx]: unable to set DMA & IRQ (PnP device?)\\n\", chip->port);\n\t\tsnd_printk(KERN_ERR \"SB16 [0x%lx]: wanted: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\\n\", chip->port, realirq, realdma, realmpureg);\n\t\tsnd_printk(KERN_ERR \"SB16 [0x%lx]:    got: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\\n\", chip->port, irqreg, dmareg, mpureg);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_sb16_playback_ops = {\n\t.open =\t\tsnd_sb16_playback_open,\n\t.close =\tsnd_sb16_playback_close,\n\t.prepare =\tsnd_sb16_playback_prepare,\n\t.trigger =\tsnd_sb16_playback_trigger,\n\t.pointer =\tsnd_sb16_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_sb16_capture_ops = {\n\t.open =\t\tsnd_sb16_capture_open,\n\t.close =\tsnd_sb16_capture_close,\n\t.prepare =\tsnd_sb16_capture_prepare,\n\t.trigger =\tsnd_sb16_capture_trigger,\n\t.pointer =\tsnd_sb16_capture_pointer,\n};\n\nint snd_sb16dsp_pcm(struct snd_sb *chip, int device)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, \"SB16 DSP\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsprintf(pcm->name, \"DSP v%i.%i\", chip->version >> 8, chip->version & 0xff);\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tpcm->private_data = chip;\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sb16_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sb16_capture_ops);\n\n\tif (chip->dma16 >= 0 && chip->dma8 != chip->dma16)\n\t\tsnd_ctl_add(card, snd_ctl_new1(&snd_sb16_dma_control, chip));\n\telse\n\t\tpcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, 64*1024, 128*1024);\n\treturn 0;\n}\n\nconst struct snd_pcm_ops *snd_sb16dsp_get_pcm_ops(int direction)\n{\n\treturn direction == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t&snd_sb16_playback_ops : &snd_sb16_capture_ops;\n}\n\nEXPORT_SYMBOL(snd_sb16dsp_pcm);\nEXPORT_SYMBOL(snd_sb16dsp_get_pcm_ops);\nEXPORT_SYMBOL(snd_sb16dsp_configure);\nEXPORT_SYMBOL(snd_sb16dsp_interrupt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}