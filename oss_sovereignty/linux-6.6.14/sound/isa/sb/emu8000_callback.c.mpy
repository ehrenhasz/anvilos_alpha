{
  "module_name": "emu8000_callback.c",
  "hash_id": "23066e11317eb2375fea7e901fe9860404608607886c9fffd6205e211bbf9fc5",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/emu8000_callback.c",
  "human_readable_source": "\n \n\n#include \"emu8000_local.h\"\n#include <linux/export.h>\n#include <sound/asoundef.h>\n\n \nstatic struct snd_emux_voice *get_voice(struct snd_emux *emu,\n\t\t\t\t\tstruct snd_emux_port *port);\nstatic int start_voice(struct snd_emux_voice *vp);\nstatic void trigger_voice(struct snd_emux_voice *vp);\nstatic void release_voice(struct snd_emux_voice *vp);\nstatic void update_voice(struct snd_emux_voice *vp, int update);\nstatic void reset_voice(struct snd_emux *emu, int ch);\nstatic void terminate_voice(struct snd_emux_voice *vp);\nstatic void sysex(struct snd_emux *emu, char *buf, int len, int parsed,\n\t\t  struct snd_midi_channel_set *chset);\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\nstatic int oss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2);\n#endif\nstatic int load_fx(struct snd_emux *emu, int type, int mode,\n\t\t   const void __user *buf, long len);\n\nstatic void set_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_volume(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_pan(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_fmmod(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_fm2frq2(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void set_filterQ(struct snd_emu8000 *hw, struct snd_emux_voice *vp);\nstatic void snd_emu8000_tweak_voice(struct snd_emu8000 *emu, int ch);\n\n \n#define LIMITVALUE(x, a, b) do { if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b); } while (0)\n#define LIMITMAX(x, a) do {if ((x) > (a)) (x) = (a); } while (0)\n\n\n \nstatic const struct snd_emux_operators emu8000_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.get_voice =\tget_voice,\n\t.prepare =\tstart_voice,\n\t.trigger =\ttrigger_voice,\n\t.release =\trelease_voice,\n\t.update =\tupdate_voice,\n\t.terminate =\tterminate_voice,\n\t.reset =\treset_voice,\n\t.sample_new =\tsnd_emu8000_sample_new,\n\t.sample_free =\tsnd_emu8000_sample_free,\n\t.sample_reset = snd_emu8000_sample_reset,\n\t.load_fx =\tload_fx,\n\t.sysex =\tsysex,\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\t.oss_ioctl =\toss_ioctl,\n#endif\n};\n\nvoid\nsnd_emu8000_ops_setup(struct snd_emu8000 *hw)\n{\n\thw->emu->ops = emu8000_ops;\n}\n\n\n\n \nstatic void\nrelease_voice(struct snd_emux_voice *vp)\n{\n\tint dcysusv;\n\tstruct snd_emu8000 *hw;\n\n\thw = vp->hw;\n\tdcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;\n\tEMU8000_DCYSUS_WRITE(hw, vp->ch, dcysusv);\n\tdcysusv = 0x8000 | (unsigned char)vp->reg.parm.volrelease;\n\tEMU8000_DCYSUSV_WRITE(hw, vp->ch, dcysusv);\n}\n\n\n \nstatic void\nterminate_voice(struct snd_emux_voice *vp)\n{\n\tstruct snd_emu8000 *hw; \n\n\thw = vp->hw;\n\tEMU8000_DCYSUSV_WRITE(hw, vp->ch, 0x807F);\n}\n\n\n \nstatic void\nupdate_voice(struct snd_emux_voice *vp, int update)\n{\n\tstruct snd_emu8000 *hw;\n\n\thw = vp->hw;\n\tif (update & SNDRV_EMUX_UPDATE_VOLUME)\n\t\tset_volume(hw, vp);\n\tif (update & SNDRV_EMUX_UPDATE_PITCH)\n\t\tset_pitch(hw, vp);\n\tif ((update & SNDRV_EMUX_UPDATE_PAN) &&\n\t    vp->port->ctrls[EMUX_MD_REALTIME_PAN])\n\t\tset_pan(hw, vp);\n\tif (update & SNDRV_EMUX_UPDATE_FMMOD)\n\t\tset_fmmod(hw, vp);\n\tif (update & SNDRV_EMUX_UPDATE_TREMFREQ)\n\t\tset_tremfreq(hw, vp);\n\tif (update & SNDRV_EMUX_UPDATE_FM2FRQ2)\n\t\tset_fm2frq2(hw, vp);\n\tif (update & SNDRV_EMUX_UPDATE_Q)\n\t\tset_filterQ(hw, vp);\n}\n\n\n \nstatic struct snd_emux_voice *\nget_voice(struct snd_emux *emu, struct snd_emux_port *port)\n{\n\tint  i;\n\tstruct snd_emux_voice *vp;\n\tstruct snd_emu8000 *hw;\n\n\t \n\tenum {\n\t\tOFF=0, RELEASED, PLAYING, END\n\t};\n\n\t \n\tstruct best {\n\t\tunsigned int  time;\n\t\tint voice;\n\t} best[END];\n\tstruct best *bp;\n\n\thw = emu->hw;\n\n\tfor (i = 0; i < END; i++) {\n\t\tbest[i].time = (unsigned int)(-1);  \n\t\tbest[i].voice = -1;\n\t}\n\n\t \n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tint state, val;\n\n\t\tvp = &emu->voices[i];\n\t\tstate = vp->state;\n\n\t\tif (state == SNDRV_EMUX_ST_OFF)\n\t\t\tbp = best + OFF;\n\t\telse if (state == SNDRV_EMUX_ST_RELEASED ||\n\t\t\t state == SNDRV_EMUX_ST_PENDING) {\n\t\t\tbp = best + RELEASED;\n\t\t\tval = (EMU8000_CVCF_READ(hw, vp->ch) >> 16) & 0xffff;\n\t\t\tif (! val)\n\t\t\t\tbp = best + OFF;\n\t\t}\n\t\telse if (state & SNDRV_EMUX_ST_ON)\n\t\t\tbp = best + PLAYING;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tif (state != SNDRV_EMUX_ST_OFF &&\n\t\t    (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {\n\t\t\tval = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;\n\t\t\tif (val >= vp->reg.loopstart)\n\t\t\t\tbp = best + OFF;\n\t\t}\n\n\t\tif (vp->time < bp->time) {\n\t\t\tbp->time = vp->time;\n\t\t\tbp->voice = i;\n\t\t}\n\t}\n\n\tfor (i = 0; i < END; i++) {\n\t\tif (best[i].voice >= 0) {\n\t\t\tvp = &emu->voices[best[i].voice];\n\t\t\tvp->ch = best[i].voice;\n\t\t\treturn vp;\n\t\t}\n\t}\n\n\t \n\treturn NULL;\n}\n\n \nstatic int\nstart_voice(struct snd_emux_voice *vp)\n{\n\tunsigned int temp;\n\tint ch;\n\tint addr;\n\tstruct snd_midi_channel *chan;\n\tstruct snd_emu8000 *hw;\n\n\thw = vp->hw;\n\tch = vp->ch;\n\tchan = vp->chan;\n\n\t \n\tEMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);\n\tEMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);\n\tEMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);\n\tEMU8000_PTRX_WRITE(hw, ch, 0);\n\tEMU8000_CPF_WRITE(hw, ch, 0);\n\n\t \n\tset_pitch(hw, vp);\n\n\t \n\tEMU8000_ENVVAL_WRITE(hw, ch, vp->reg.parm.moddelay);\n\tEMU8000_ATKHLD_WRITE(hw, ch, vp->reg.parm.modatkhld);\n\tEMU8000_DCYSUS_WRITE(hw, ch, vp->reg.parm.moddcysus);\n\tEMU8000_ENVVOL_WRITE(hw, ch, vp->reg.parm.voldelay);\n\tEMU8000_ATKHLDV_WRITE(hw, ch, vp->reg.parm.volatkhld);\n\t \n\n\t \n\tset_volume(hw, vp);\n\n\t \n\tEMU8000_PEFE_WRITE(hw, ch, vp->reg.parm.pefe);\n\n\t \n\tEMU8000_LFO1VAL_WRITE(hw, ch, vp->reg.parm.lfo1delay);\n\tEMU8000_LFO2VAL_WRITE(hw, ch, vp->reg.parm.lfo2delay);\n\n\t \n\tset_fmmod(hw, vp);\n\t \n\tset_tremfreq(hw, vp);\n\t \n\tset_fm2frq2(hw, vp);\n\t \n\tset_pan(hw, vp);\n\n\t \n\taddr = vp->reg.loopend - 1;\n\ttemp = vp->reg.parm.chorus;\n\ttemp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;\n\tLIMITMAX(temp, 255);\n\ttemp = (temp <<24) | (unsigned int)addr;\n\tEMU8000_CSL_WRITE(hw, ch, temp);\n\n\t \n\taddr = vp->reg.start - 1;\n\ttemp = vp->reg.parm.filterQ;\n\ttemp = (temp<<28) | (unsigned int)addr;\n\tEMU8000_CCCA_WRITE(hw, ch, temp);\n\n\t \n\tEMU8000_00A0_WRITE(hw, ch, 0);\n\tEMU8000_0080_WRITE(hw, ch, 0);\n\n\t \n\ttemp = vp->vtarget << 16;\n\tEMU8000_VTFT_WRITE(hw, ch, temp | vp->ftarget);\n\tEMU8000_CVCF_WRITE(hw, ch, temp | 0xff00);\n\n\treturn 0;\n}\n\n \nstatic void\ntrigger_voice(struct snd_emux_voice *vp)\n{\n\tint ch = vp->ch;\n\tunsigned int temp;\n\tstruct snd_emu8000 *hw;\n\n\thw = vp->hw;\n\n\t \n\ttemp = vp->reg.parm.reverb;\n\ttemp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;\n\tLIMITMAX(temp, 255);\n\ttemp = (temp << 8) | (vp->ptarget << 16) | vp->aaux;\n\tEMU8000_PTRX_WRITE(hw, ch, temp);\n\tEMU8000_CPF_WRITE(hw, ch, vp->ptarget << 16);\n\tEMU8000_DCYSUSV_WRITE(hw, ch, vp->reg.parm.voldcysus);\n}\n\n \nstatic void\nreset_voice(struct snd_emux *emu, int ch)\n{\n\tstruct snd_emu8000 *hw;\n\n\thw = emu->hw;\n\tEMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);\n\tsnd_emu8000_tweak_voice(hw, ch);\n}\n\n \nstatic void\nset_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tEMU8000_IP_WRITE(hw, vp->ch, vp->apitch);\n}\n\n \nstatic void\nset_volume(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tint  ifatn;\n\n\tifatn = (unsigned char)vp->acutoff;\n\tifatn = (ifatn << 8);\n\tifatn |= (unsigned char)vp->avol;\n\tEMU8000_IFATN_WRITE(hw, vp->ch, ifatn);\n}\n\n \nstatic void\nset_pan(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tunsigned int temp;\n\n\ttemp = ((unsigned int)vp->apan<<24) | ((unsigned int)vp->reg.loopstart - 1);\n\tEMU8000_PSST_WRITE(hw, vp->ch, temp);\n}\n\n#define MOD_SENSE 18\n\nstatic void\nset_fmmod(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tunsigned short fmmod;\n\tshort pitch;\n\tunsigned char cutoff;\n\tint modulation;\n\n\tpitch = (char)(vp->reg.parm.fmmod>>8);\n\tcutoff = (vp->reg.parm.fmmod & 0xff);\n\tmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\n\tpitch += (MOD_SENSE * modulation) / 1200;\n\tLIMITVALUE(pitch, -128, 127);\n\tfmmod = ((unsigned char)pitch<<8) | cutoff;\n\tEMU8000_FMMOD_WRITE(hw, vp->ch, fmmod);\n}\n\n \nstatic void\nset_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tEMU8000_TREMFRQ_WRITE(hw, vp->ch, vp->reg.parm.tremfrq);\n}\n\n \nstatic void\nset_fm2frq2(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tunsigned short fm2frq2;\n\tshort pitch;\n\tunsigned char freq;\n\tint modulation;\n\n\tpitch = (char)(vp->reg.parm.fm2frq2>>8);\n\tfreq = vp->reg.parm.fm2frq2 & 0xff;\n\tmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\n\tpitch += (MOD_SENSE * modulation) / 1200;\n\tLIMITVALUE(pitch, -128, 127);\n\tfm2frq2 = ((unsigned char)pitch<<8) | freq;\n\tEMU8000_FM2FRQ2_WRITE(hw, vp->ch, fm2frq2);\n}\n\n \nstatic void\nset_filterQ(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\n{\n\tunsigned int addr;\n\taddr = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;\n\taddr |= (vp->reg.parm.filterQ << 28);\n\tEMU8000_CCCA_WRITE(hw, vp->ch, addr);\n}\n\n \nstatic void\nsnd_emu8000_tweak_voice(struct snd_emu8000 *emu, int i)\n{\n\t \n\tEMU8000_ENVVOL_WRITE(emu, i, 0x8000);\n\tEMU8000_ENVVAL_WRITE(emu, i, 0x8000);\n\tEMU8000_DCYSUS_WRITE(emu, i, 0x7F7F);\n\tEMU8000_ATKHLDV_WRITE(emu, i, 0x7F7F);\n\tEMU8000_ATKHLD_WRITE(emu, i, 0x7F7F);\n\tEMU8000_PEFE_WRITE(emu, i, 0);   \n\tEMU8000_LFO1VAL_WRITE(emu, i, 0x8000);  \n\tEMU8000_LFO2VAL_WRITE(emu, i, 0x8000);\n\tEMU8000_IP_WRITE(emu, i, 0xE000);\t \n\tEMU8000_IFATN_WRITE(emu, i, 0xFF00);\t \n\tEMU8000_FMMOD_WRITE(emu, i, 0);\n\tEMU8000_TREMFRQ_WRITE(emu, i, 0);\n\tEMU8000_FM2FRQ2_WRITE(emu, i, 0);\n}\n\n \nstatic void\nsysex(struct snd_emux *emu, char *buf, int len, int parsed, struct snd_midi_channel_set *chset)\n{\n\tstruct snd_emu8000 *hw;\n\n\thw = emu->hw;\n\n\tswitch (parsed) {\n\tcase SNDRV_MIDI_SYSEX_GS_CHORUS_MODE:\n\t\thw->chorus_mode = chset->gs_chorus_mode;\n\t\tsnd_emu8000_update_chorus_mode(hw);\n\t\tbreak;\n\n\tcase SNDRV_MIDI_SYSEX_GS_REVERB_MODE:\n\t\thw->reverb_mode = chset->gs_reverb_mode;\n\t\tsnd_emu8000_update_reverb_mode(hw);\n\t\tbreak;\n\t}\n}\n\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n \nstatic int\noss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2)\n{\n\tstruct snd_emu8000 *hw;\n\n\thw = emu->hw;\n\n\tswitch (cmd) {\n\tcase _EMUX_OSS_REVERB_MODE:\n\t\thw->reverb_mode = p1;\n\t\tsnd_emu8000_update_reverb_mode(hw);\n\t\tbreak;\n\n\tcase _EMUX_OSS_CHORUS_MODE:\n\t\thw->chorus_mode = p1;\n\t\tsnd_emu8000_update_chorus_mode(hw);\n\t\tbreak;\n\n\tcase _EMUX_OSS_INITIALIZE_CHIP:\n\t\t   \n\t\tbreak;\n\n\tcase _EMUX_OSS_EQUALIZER:\n\t\thw->bass_level = p1;\n\t\thw->treble_level = p2;\n\t\tsnd_emu8000_update_equalizer(hw);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\n\n \n\n#define SNDRV_EMU8000_LOAD_CHORUS_FX\t0x10\t \n#define SNDRV_EMU8000_LOAD_REVERB_FX\t0x11\t \n\n\n \n\nstatic int\nload_fx(struct snd_emux *emu, int type, int mode, const void __user *buf, long len)\n{\n\tstruct snd_emu8000 *hw;\n\thw = emu->hw;\n\n\t \n\tbuf += 16;\n\tlen -= 16;\n\n\tswitch (type) {\n\tcase SNDRV_EMU8000_LOAD_CHORUS_FX:\n\t\treturn snd_emu8000_load_chorus_fx(hw, mode, buf, len);\n\tcase SNDRV_EMU8000_LOAD_REVERB_FX:\n\t\treturn snd_emu8000_load_reverb_fx(hw, mode, buf, len);\n\t}\n\treturn -EINVAL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}