{
  "module_name": "emu8000_pcm.c",
  "hash_id": "86653df4a57fdf4548559e360e70faeb19cbd895891bee5fa738c228fad1c2d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/emu8000_pcm.c",
  "human_readable_source": "\n \n\n#include \"emu8000_local.h\"\n\n#include <linux/sched/signal.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n\n \n \n\n \n\n\nstruct snd_emu8k_pcm {\n\tstruct snd_emu8000 *emu;\n\tstruct snd_pcm_substream *substream;\n\n\tunsigned int allocated_bytes;\n\tstruct snd_util_memblk *block;\n\tunsigned int offset;\n\tunsigned int buf_size;\n\tunsigned int period_size;\n\tunsigned int loop_start[2];\n\tunsigned int pitch;\n\tint panning[2];\n\tint last_ptr;\n\tint period_pos;\n\tint voices;\n\tunsigned int dram_opened: 1;\n\tunsigned int running: 1;\n\tunsigned int timer_running: 1;\n\tstruct timer_list timer;\n\tspinlock_t timer_lock;\n};\n\n#define LOOP_BLANK_SIZE\t\t8\n\n\n \nstatic int\nemu8k_open_dram_for_pcm(struct snd_emu8000 *emu, int channels)\n{\n\tint i;\n\n\t \n\tsnd_emux_lock_voice(emu->emu, 0);\n\tif (channels > 1)\n\t\tsnd_emux_lock_voice(emu->emu, 1);\n\n\t \n\tfor (i = channels + 1; i < EMU8000_DRAM_VOICES; i++) {\n\t\tunsigned int mode = EMU8000_RAM_WRITE;\n\t\tsnd_emux_lock_voice(emu->emu, i);\n#ifndef USE_NONINTERLEAVE\n\t\tif (channels > 1 && (i & 1) != 0)\n\t\t\tmode |= EMU8000_RAM_RIGHT;\n#endif\n\t\tsnd_emu8000_dma_chan(emu, i, mode);\n\t}\n\n\t \n\tEMU8000_VTFT_WRITE(emu, 30, 0);\n\tEMU8000_PSST_WRITE(emu, 30, 0x1d8);\n\tEMU8000_CSL_WRITE(emu, 30, 0x1e0);\n\tEMU8000_CCCA_WRITE(emu, 30, 0x1d8);\n\tEMU8000_VTFT_WRITE(emu, 31, 0);\n\tEMU8000_PSST_WRITE(emu, 31, 0x1d8);\n\tEMU8000_CSL_WRITE(emu, 31, 0x1e0);\n\tEMU8000_CCCA_WRITE(emu, 31, 0x1d8);\n\n\treturn 0;\n}\n\n \nstatic void\nsnd_emu8000_write_wait(struct snd_emu8000 *emu, int can_schedule)\n{\n\twhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\n\t\tif (can_schedule) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\nemu8k_close_dram(struct snd_emu8000 *emu)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tsnd_emux_unlock_voice(emu->emu, i);\n\tfor (; i < EMU8000_DRAM_VOICES; i++) {\n\t\tsnd_emu8000_dma_chan(emu, i, EMU8000_RAM_CLOSE);\n\t\tsnd_emux_unlock_voice(emu->emu, i);\n\t}\n}\n\n \n\n#define OFFSET_SAMPLERATE\t1011119\t\t \n#define SAMPLERATE_RATIO\t4096\n\nstatic int calc_rate_offset(int hz)\n{\n\treturn snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);\n}\n\n\n \n\nstatic const struct snd_pcm_hardware emu8k_pcm_hw = {\n#ifdef USE_NONINTERLEAVE\n\t.info =\t\t\tSNDRV_PCM_INFO_NONINTERLEAVED,\n#else\n\t.info =\t\t\tSNDRV_PCM_INFO_INTERLEAVED,\n#endif\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t1024,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n\n};\n\n \nstatic inline int emu8k_get_curpos(struct snd_emu8k_pcm *rec, int ch)\n{\n\tint val = EMU8000_CCCA_READ(rec->emu, ch) & 0xfffffff;\n\tval -= rec->loop_start[ch] - 1;\n\treturn val;\n}\n\n\n \nstatic void emu8k_pcm_timer_func(struct timer_list *t)\n{\n\tstruct snd_emu8k_pcm *rec = from_timer(rec, t, timer);\n\tint ptr, delta;\n\n\tspin_lock(&rec->timer_lock);\n\t \n\tptr = emu8k_get_curpos(rec, 0);\n\tif (ptr < rec->last_ptr)\n\t\tdelta = ptr + rec->buf_size - rec->last_ptr;\n\telse\n\t\tdelta = ptr - rec->last_ptr;\n\trec->period_pos += delta;\n\trec->last_ptr = ptr;\n\n\t \n\tmod_timer(&rec->timer, jiffies + 1);\n\n\t \n\tif (rec->period_pos >= (int)rec->period_size) {\n\t\trec->period_pos %= rec->period_size;\n\t\tspin_unlock(&rec->timer_lock);\n\t\tsnd_pcm_period_elapsed(rec->substream);\n\t\treturn;\n\t}\n\tspin_unlock(&rec->timer_lock);\n}\n\n\n \nstatic int emu8k_pcm_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_emu8000 *emu = snd_pcm_substream_chip(subs);\n\tstruct snd_emu8k_pcm *rec;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\trec = kzalloc(sizeof(*rec), GFP_KERNEL);\n\tif (! rec)\n\t\treturn -ENOMEM;\n\n\trec->emu = emu;\n\trec->substream = subs;\n\truntime->private_data = rec;\n\n\tspin_lock_init(&rec->timer_lock);\n\ttimer_setup(&rec->timer, emu8k_pcm_timer_func, 0);\n\n\truntime->hw = emu8k_pcm_hw;\n\truntime->hw.buffer_bytes_max = emu->mem_size - LOOP_BLANK_SIZE * 3;\n\truntime->hw.period_bytes_max = runtime->hw.buffer_bytes_max / 2;\n\n\t \n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t     DIV_ROUND_UP(1000000, HZ), UINT_MAX);\n\n\treturn 0;\n}\n\nstatic int emu8k_pcm_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\tkfree(rec);\n\tsubs->runtime->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic int calc_pitch_target(int pitch)\n{\n\tint ptarget = 1 << (pitch >> 12);\n\tif (pitch & 0x800) ptarget += (ptarget * 0x102e) / 0x2710;\n\tif (pitch & 0x400) ptarget += (ptarget * 0x764) / 0x2710;\n\tif (pitch & 0x200) ptarget += (ptarget * 0x389) / 0x2710;\n\tptarget += (ptarget >> 1);\n\tif (ptarget > 0xffff) ptarget = 0xffff;\n\treturn ptarget;\n}\n\n \nstatic void setup_voice(struct snd_emu8k_pcm *rec, int ch)\n{\n\tstruct snd_emu8000 *hw = rec->emu;\n\tunsigned int temp;\n\n\t \n\tEMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);\n\tEMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);\n\tEMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);\n\tEMU8000_PTRX_WRITE(hw, ch, 0);\n\tEMU8000_CPF_WRITE(hw, ch, 0);\n\n\t \n\tEMU8000_IP_WRITE(hw, ch, rec->pitch);\n\t \n\tEMU8000_ENVVAL_WRITE(hw, ch, 0x8000);\n\tEMU8000_ATKHLD_WRITE(hw, ch, 0x7f7f);\n\tEMU8000_DCYSUS_WRITE(hw, ch, 0x7f7f);\n\tEMU8000_ENVVOL_WRITE(hw, ch, 0x8000);\n\tEMU8000_ATKHLDV_WRITE(hw, ch, 0x7f7f);\n\t \n\t \n\tEMU8000_PEFE_WRITE(hw, ch, 0x0);\n\t \n\tEMU8000_LFO1VAL_WRITE(hw, ch, 0x8000);\n\tEMU8000_LFO2VAL_WRITE(hw, ch, 0x8000);\n\t \n\tEMU8000_FMMOD_WRITE(hw, ch, 0);\n\t \n\tEMU8000_TREMFRQ_WRITE(hw, ch, 0);\n\t \n\tEMU8000_FM2FRQ2_WRITE(hw, ch, 0);\n\t \n\ttemp = rec->panning[ch];\n\ttemp = (temp <<24) | ((unsigned int)rec->loop_start[ch] - 1);\n\tEMU8000_PSST_WRITE(hw, ch, temp);\n\t \n\ttemp = 0; \n\ttemp = (temp << 24) | ((unsigned int)rec->loop_start[ch] + rec->buf_size - 1);\n\tEMU8000_CSL_WRITE(hw, ch, temp);\n\t \n\ttemp = 0; \n\ttemp = (temp << 28) | ((unsigned int)rec->loop_start[ch] - 1);\n\tEMU8000_CCCA_WRITE(hw, ch, temp);\n\t \n\tEMU8000_00A0_WRITE(hw, ch, 0);\n\tEMU8000_0080_WRITE(hw, ch, 0);\n}\n\n \nstatic void start_voice(struct snd_emu8k_pcm *rec, int ch)\n{\n\tunsigned long flags;\n\tstruct snd_emu8000 *hw = rec->emu;\n\tunsigned int temp, aux;\n\tint pt = calc_pitch_target(rec->pitch);\n\n\t \n\tEMU8000_IFATN_WRITE(hw, ch, 0xff00);\n\tEMU8000_VTFT_WRITE(hw, ch, 0xffff);\n\tEMU8000_CVCF_WRITE(hw, ch, 0xffff);\n\t \n\tEMU8000_DCYSUSV_WRITE(hw, ch, 0x7f7f);\n\t \n\ttemp = 0; \n\tif (rec->panning[ch] == 0)\n\t\taux = 0xff;\n\telse\n\t\taux = (-rec->panning[ch]) & 0xff;\n\ttemp = (temp << 8) | (pt << 16) | aux;\n\tEMU8000_PTRX_WRITE(hw, ch, temp);\n\tEMU8000_CPF_WRITE(hw, ch, pt << 16);\n\n\t \n\tspin_lock_irqsave(&rec->timer_lock, flags);\n\tif (! rec->timer_running) {\n\t\tmod_timer(&rec->timer, jiffies + 1);\n\t\trec->timer_running = 1;\n\t}\n\tspin_unlock_irqrestore(&rec->timer_lock, flags);\n}\n\n \nstatic void stop_voice(struct snd_emu8k_pcm *rec, int ch)\n{\n\tunsigned long flags;\n\tstruct snd_emu8000 *hw = rec->emu;\n\n\tEMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);\n\n\t \n\tspin_lock_irqsave(&rec->timer_lock, flags);\n\tif (rec->timer_running) {\n\t\tdel_timer(&rec->timer);\n\t\trec->timer_running = 0;\n\t}\n\tspin_unlock_irqrestore(&rec->timer_lock, flags);\n}\n\nstatic int emu8k_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\tint ch;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tfor (ch = 0; ch < rec->voices; ch++)\n\t\t\tstart_voice(rec, ch);\n\t\trec->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trec->running = 0;\n\t\tfor (ch = 0; ch < rec->voices; ch++)\n\t\t\tstop_voice(rec, ch);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \n\n \n#define CHECK_SCHEDULER() \\\ndo { \\\n\tcond_resched();\\\n\tif (signal_pending(current))\\\n\t\treturn -EAGAIN;\\\n} while (0)\n\n#define GET_VAL(sval, iter)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!iter)\t\t\t\t\t\t\\\n\t\t\tsval = 0;\t\t\t\t\t\\\n\t\telse if (copy_from_iter(&sval, 2, iter) != 2)\t\t\\\n\t\t\treturn -EFAULT;\t\t\t\t\t\\\n\t} while (0)\n\n#ifdef USE_NONINTERLEAVE\n\n#define LOOP_WRITE(rec, offset, iter, count)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstruct snd_emu8000 *emu = (rec)->emu;\t\t\\\n\t\tsnd_emu8000_write_wait(emu, 1);\t\t\t\\\n\t\tEMU8000_SMALW_WRITE(emu, offset);\t\t\\\n\t\twhile (count > 0) {\t\t\t\t\\\n\t\t\tunsigned short sval;\t\t\t\\\n\t\t\tCHECK_SCHEDULER();\t\t\t\\\n\t\t\tGET_VAL(sval, iter);\t\t\t\\\n\t\t\tEMU8000_SMLD_WRITE(emu, sval);\t\t\\\n\t\t\tcount--;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n \nstatic int emu8k_pcm_copy(struct snd_pcm_substream *subs,\n\t\t\t  int voice, unsigned long pos,\n\t\t\t  struct iov_iter *src, unsigned long count)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\t \n\tpos = (pos << 1) + rec->loop_start[voice];\n\tcount <<= 1;\n\tLOOP_WRITE(rec, pos, src, count);\n\treturn 0;\n}\n\n \nstatic int emu8k_pcm_silence(struct snd_pcm_substream *subs,\n\t\t\t     int voice, unsigned long pos, unsigned long count)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\t \n\tpos = (pos << 1) + rec->loop_start[voice];\n\tcount <<= 1;\n\tLOOP_WRITE(rec, pos, NULL, count);\n\treturn 0;\n}\n\n#else  \n\n#define LOOP_WRITE(rec, pos, iter, count)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct snd_emu8000 *emu = rec->emu;\t\t\t\\\n\t\tsnd_emu8000_write_wait(emu, 1);\t\t\t\t\\\n\t\tEMU8000_SMALW_WRITE(emu, pos + rec->loop_start[0]);\t\\\n\t\tif (rec->voices > 1)\t\t\t\t\t\\\n\t\t\tEMU8000_SMARW_WRITE(emu, pos + rec->loop_start[1]); \\\n\t\twhile (count > 0) {\t\t\t\t\t\\\n\t\t\tunsigned short sval;\t\t\t\t\\\n\t\t\tCHECK_SCHEDULER();\t\t\t\t\\\n\t\t\tGET_VAL(sval, iter);\t\t\t\t\\\n\t\t\tEMU8000_SMLD_WRITE(emu, sval);\t\t\t\\\n\t\t\tif (rec->voices > 1) {\t\t\t\t\\\n\t\t\t\tCHECK_SCHEDULER();\t\t\t\\\n\t\t\t\tGET_VAL(sval, iter);\t\t\t\\\n\t\t\t\tEMU8000_SMRD_WRITE(emu, sval);\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\n \nstatic int emu8k_pcm_copy(struct snd_pcm_substream *subs,\n\t\t\t  int voice, unsigned long pos,\n\t\t\t  struct iov_iter *src, unsigned long count)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\t \n\tpos = bytes_to_frames(subs->runtime, pos);\n\tcount = bytes_to_frames(subs->runtime, count);\n\tLOOP_WRITE(rec, pos, src, count);\n\treturn 0;\n}\n\nstatic int emu8k_pcm_silence(struct snd_pcm_substream *subs,\n\t\t\t     int voice, unsigned long pos, unsigned long count)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\t \n\tpos = bytes_to_frames(subs->runtime, pos);\n\tcount = bytes_to_frames(subs->runtime, count);\n\tLOOP_WRITE(rec, pos, NULL, count);\n\treturn 0;\n}\n#endif\n\n\n \nstatic int emu8k_pcm_hw_params(struct snd_pcm_substream *subs,\n\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\tif (rec->block) {\n\t\t \n\t\tsnd_util_mem_free(rec->emu->memhdr, rec->block);\n\t\trec->block = NULL;\n\t}\n\n\trec->allocated_bytes = params_buffer_bytes(hw_params) + LOOP_BLANK_SIZE * 4;\n\trec->block = snd_util_mem_alloc(rec->emu->memhdr, rec->allocated_bytes);\n\tif (! rec->block)\n\t\treturn -ENOMEM;\n\trec->offset = EMU8000_DRAM_OFFSET + (rec->block->offset >> 1);  \n\t \n\tsubs->dma_buffer.bytes = params_buffer_bytes(hw_params);\n\n\treturn 0;\n}\n\n \nstatic int emu8k_pcm_hw_free(struct snd_pcm_substream *subs)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\tif (rec->block) {\n\t\tint ch;\n\t\tfor (ch = 0; ch < rec->voices; ch++)\n\t\t\tstop_voice(rec, ch); \n\t\tif (rec->dram_opened)\n\t\t\temu8k_close_dram(rec->emu);\n\t\tsnd_util_mem_free(rec->emu->memhdr, rec->block);\n\t\trec->block = NULL;\n\t}\n\treturn 0;\n}\n\n \nstatic int emu8k_pcm_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\n\trec->pitch = 0xe000 + calc_rate_offset(subs->runtime->rate);\n\trec->last_ptr = 0;\n\trec->period_pos = 0;\n\n\trec->buf_size = subs->runtime->buffer_size;\n\trec->period_size = subs->runtime->period_size;\n\trec->voices = subs->runtime->channels;\n\trec->loop_start[0] = rec->offset + LOOP_BLANK_SIZE;\n\tif (rec->voices > 1)\n\t\trec->loop_start[1] = rec->loop_start[0] + rec->buf_size + LOOP_BLANK_SIZE;\n\tif (rec->voices > 1) {\n\t\trec->panning[0] = 0xff;\n\t\trec->panning[1] = 0x00;\n\t} else\n\t\trec->panning[0] = 0x80;\n\n\tif (! rec->dram_opened) {\n\t\tint err, i, ch;\n\n\t\tsnd_emux_terminate_all(rec->emu->emu);\n\t\terr = emu8k_open_dram_for_pcm(rec->emu, rec->voices);\n\t\tif (err)\n\t\t\treturn err;\n\t\trec->dram_opened = 1;\n\n\t\t \n\t\tsnd_emu8000_write_wait(rec->emu, 0);\n\t\tEMU8000_SMALW_WRITE(rec->emu, rec->offset);\n\t\tfor (i = 0; i < LOOP_BLANK_SIZE; i++)\n\t\t\tEMU8000_SMLD_WRITE(rec->emu, 0);\n\t\tfor (ch = 0; ch < rec->voices; ch++) {\n\t\t\tEMU8000_SMALW_WRITE(rec->emu, rec->loop_start[ch] + rec->buf_size);\n\t\t\tfor (i = 0; i < LOOP_BLANK_SIZE; i++)\n\t\t\t\tEMU8000_SMLD_WRITE(rec->emu, 0);\n\t\t}\n\t}\n\n\tsetup_voice(rec, 0);\n\tif (rec->voices > 1)\n\t\tsetup_voice(rec, 1);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t emu8k_pcm_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_emu8k_pcm *rec = subs->runtime->private_data;\n\tif (rec->running)\n\t\treturn emu8k_get_curpos(rec, 0);\n\treturn 0;\n}\n\n\nstatic const struct snd_pcm_ops emu8k_pcm_ops = {\n\t.open =\t\temu8k_pcm_open,\n\t.close =\temu8k_pcm_close,\n\t.hw_params =\temu8k_pcm_hw_params,\n\t.hw_free =\temu8k_pcm_hw_free,\n\t.prepare =\temu8k_pcm_prepare,\n\t.trigger =\temu8k_pcm_trigger,\n\t.pointer =\temu8k_pcm_pointer,\n\t.copy =\t\temu8k_pcm_copy,\n\t.fill_silence =\temu8k_pcm_silence,\n};\n\n\nstatic void snd_emu8000_pcm_free(struct snd_pcm *pcm)\n{\n\tstruct snd_emu8000 *emu = pcm->private_data;\n\temu->pcm = NULL;\n}\n\nint snd_emu8000_pcm_new(struct snd_card *card, struct snd_emu8000 *emu, int index)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, \"Emu8000 PCM\", index, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = emu;\n\tpcm->private_free = snd_emu8000_pcm_free;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &emu8k_pcm_ops);\n\temu->pcm = pcm;\n\n\tsnd_device_register(card, pcm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}