{
  "module_name": "sb_mixer.c",
  "hash_id": "8b31eb82b1c0300a72b06f4f86b30b61c5b9b4a2ce7c4cfe4a2f1f0c5a4f198b",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/control.h>\n\n#undef IO_DEBUG\n\nvoid snd_sbmixer_write(struct snd_sb *chip, unsigned char reg, unsigned char data)\n{\n\toutb(reg, SBP(chip, MIXER_ADDR));\n\tudelay(10);\n\toutb(data, SBP(chip, MIXER_DATA));\n\tudelay(10);\n#ifdef IO_DEBUG\n\tsnd_printk(KERN_DEBUG \"mixer_write 0x%x 0x%x\\n\", reg, data);\n#endif\n}\n\nunsigned char snd_sbmixer_read(struct snd_sb *chip, unsigned char reg)\n{\n\tunsigned char result;\n\n\toutb(reg, SBP(chip, MIXER_ADDR));\n\tudelay(10);\n\tresult = inb(SBP(chip, MIXER_DATA));\n\tudelay(10);\n#ifdef IO_DEBUG\n\tsnd_printk(KERN_DEBUG \"mixer_read 0x%x 0x%x\\n\", reg, result);\n#endif\n\treturn result;\n}\n\n \n\nstatic int snd_sbmixer_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 16) & 0xff;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned char val;\n\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\tval = (snd_sbmixer_read(sb, reg) >> shift) & mask;\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int snd_sbmixer_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 16) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned char val, oval;\n\n\tval = (ucontrol->value.integer.value[0] & mask) << shift;\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, reg);\n\tval = (oval & ~(mask << shift)) | val;\n\tchange = val != oval;\n\tif (change)\n\t\tsnd_sbmixer_write(sb, reg, val);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n \n\nstatic int snd_sbmixer_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_sbmixer_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x07;\n\tint right_shift = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned char left, right;\n\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\tleft = (snd_sbmixer_read(sb, left_reg) >> left_shift) & mask;\n\tright = (snd_sbmixer_read(sb, right_reg) >> right_shift) & mask;\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\tucontrol->value.integer.value[0] = left;\n\tucontrol->value.integer.value[1] = right;\n\treturn 0;\n}\n\nstatic int snd_sbmixer_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x07;\n\tint right_shift = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned char left, right, oleft, oright;\n\n\tleft = (ucontrol->value.integer.value[0] & mask) << left_shift;\n\tright = (ucontrol->value.integer.value[1] & mask) << right_shift;\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\tif (left_reg == right_reg) {\n\t\toleft = snd_sbmixer_read(sb, left_reg);\n\t\tleft = (oleft & ~((mask << left_shift) | (mask << right_shift))) | left | right;\n\t\tchange = left != oleft;\n\t\tif (change)\n\t\t\tsnd_sbmixer_write(sb, left_reg, left);\n\t} else {\n\t\toleft = snd_sbmixer_read(sb, left_reg);\n\t\toright = snd_sbmixer_read(sb, right_reg);\n\t\tleft = (oleft & ~(mask << left_shift)) | left;\n\t\tright = (oright & ~(mask << right_shift)) | right;\n\t\tchange = left != oleft || right != oright;\n\t\tif (change) {\n\t\t\tsnd_sbmixer_write(sb, left_reg, left);\n\t\t\tsnd_sbmixer_write(sb, right_reg, right);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n \n\nstatic int snd_dt019x_input_sw_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[5] = {\n\t\t\"CD\", \"Mic\", \"Line\", \"Synth\", \"Master\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 5, texts);\n}\n\nstatic int snd_dt019x_input_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned char oval;\n\t\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_DT019X_CAPTURE_SW);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\tswitch (oval & 0x07) {\n\tcase SB_DT019X_CAP_CD:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\tcase SB_DT019X_CAP_MIC:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase SB_DT019X_CAP_LINE:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase SB_DT019X_CAP_MAIN:\n\t\tucontrol->value.enumerated.item[0] = 4;\n\t\tbreak;\n\t \n\t \n\t \n\t \n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 4;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_dt019x_input_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval, oval;\n\t\n\tif (ucontrol->value.enumerated.item[0] > 4)\n\t\treturn -EINVAL;\n\tswitch (ucontrol->value.enumerated.item[0]) {\n\tcase 0:\n\t\tnval = SB_DT019X_CAP_CD;\n\t\tbreak;\n\tcase 1:\n\t\tnval = SB_DT019X_CAP_MIC;\n\t\tbreak;\n\tcase 2:\n\t\tnval = SB_DT019X_CAP_LINE;\n\t\tbreak;\n\tcase 3:\n\t\tnval = SB_DT019X_CAP_SYNTH;\n\t\tbreak;\n\tcase 4:\n\t\tnval = SB_DT019X_CAP_MAIN;\n\t\tbreak;\n\tdefault:\n\t\tnval = SB_DT019X_CAP_MAIN;\n\t}\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_DT019X_CAPTURE_SW);\n\tchange = nval != oval;\n\tif (change)\n\t\tsnd_sbmixer_write(sb, SB_DT019X_CAPTURE_SW, nval);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n \n\nstatic int snd_als4k_mono_capture_route_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"L chan only\", \"R chan only\", \"L ch/2 + R ch/2\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_als4k_mono_capture_route_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned char oval;\n\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_ALS4000_MONO_IO_CTRL);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\toval >>= 6;\n\tif (oval > 2)\n\t\toval = 2;\n\n\tucontrol->value.enumerated.item[0] = oval;\n\treturn 0;\n}\n\nstatic int snd_als4k_mono_capture_route_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval, oval;\n\n\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_ALS4000_MONO_IO_CTRL);\n\n\tnval = (oval & ~(3 << 6))\n\t     | (ucontrol->value.enumerated.item[0] << 6);\n\tchange = nval != oval;\n\tif (change)\n\t\tsnd_sbmixer_write(sb, SB_ALS4000_MONO_IO_CTRL, nval);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n \n\nstatic int snd_sb8mixer_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"Mic\", \"CD\", \"Line\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\n\nstatic int snd_sb8mixer_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned char oval;\n\t\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_DSP_CAPTURE_SOURCE);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\tswitch ((oval >> 0x01) & 0x03) {\n\tcase SB_DSP_MIXS_CD:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase SB_DSP_MIXS_LINE:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8mixer_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval, oval;\n\t\n\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\treturn -EINVAL;\n\tswitch (ucontrol->value.enumerated.item[0]) {\n\tcase 1:\n\t\tnval = SB_DSP_MIXS_CD;\n\t\tbreak;\n\tcase 2:\n\t\tnval = SB_DSP_MIXS_LINE;\n\t\tbreak;\n\tdefault:\n\t\tnval = SB_DSP_MIXS_MIC;\n\t}\n\tnval <<= 1;\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval = snd_sbmixer_read(sb, SB_DSP_CAPTURE_SOURCE);\n\tnval |= oval & ~0x06;\n\tchange = nval != oval;\n\tif (change)\n\t\tsnd_sbmixer_write(sb, SB_DSP_CAPTURE_SOURCE, nval);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n \n\nstatic int snd_sb16mixer_info_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_sb16mixer_get_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg1 = kcontrol->private_value & 0xff;\n\tint reg2 = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x0f;\n\tint right_shift = (kcontrol->private_value >> 24) & 0x0f;\n\tunsigned char val1, val2;\n\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\tval1 = snd_sbmixer_read(sb, reg1);\n\tval2 = snd_sbmixer_read(sb, reg2);\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\tucontrol->value.integer.value[0] = (val1 >> left_shift) & 0x01;\n\tucontrol->value.integer.value[1] = (val2 >> left_shift) & 0x01;\n\tucontrol->value.integer.value[2] = (val1 >> right_shift) & 0x01;\n\tucontrol->value.integer.value[3] = (val2 >> right_shift) & 0x01;\n\treturn 0;\n}                                                                                                                   \n\nstatic int snd_sb16mixer_put_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb *sb = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg1 = kcontrol->private_value & 0xff;\n\tint reg2 = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x0f;\n\tint right_shift = (kcontrol->private_value >> 24) & 0x0f;\n\tint change;\n\tunsigned char val1, val2, oval1, oval2;\n\n\tspin_lock_irqsave(&sb->mixer_lock, flags);\n\toval1 = snd_sbmixer_read(sb, reg1);\n\toval2 = snd_sbmixer_read(sb, reg2);\n\tval1 = oval1 & ~((1 << left_shift) | (1 << right_shift));\n\tval2 = oval2 & ~((1 << left_shift) | (1 << right_shift));\n\tval1 |= (ucontrol->value.integer.value[0] & 1) << left_shift;\n\tval2 |= (ucontrol->value.integer.value[1] & 1) << left_shift;\n\tval1 |= (ucontrol->value.integer.value[2] & 1) << right_shift;\n\tval2 |= (ucontrol->value.integer.value[3] & 1) << right_shift;\n\tchange = val1 != oval1 || val2 != oval2;\n\tif (change) {\n\t\tsnd_sbmixer_write(sb, reg1, val1);\n\t\tsnd_sbmixer_write(sb, reg2, val2);\n\t}\n\tspin_unlock_irqrestore(&sb->mixer_lock, flags);\n\treturn change;\n}\n\n\n \n \nint snd_sbmixer_add_ctl(struct snd_sb *chip, const char *name, int index, int type, unsigned long value)\n{\n\tstatic const struct snd_kcontrol_new newctls[] = {\n\t\t[SB_MIX_SINGLE] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_sbmixer_info_single,\n\t\t\t.get = snd_sbmixer_get_single,\n\t\t\t.put = snd_sbmixer_put_single,\n\t\t},\n\t\t[SB_MIX_DOUBLE] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_sbmixer_info_double,\n\t\t\t.get = snd_sbmixer_get_double,\n\t\t\t.put = snd_sbmixer_put_double,\n\t\t},\n\t\t[SB_MIX_INPUT_SW] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_sb16mixer_info_input_sw,\n\t\t\t.get = snd_sb16mixer_get_input_sw,\n\t\t\t.put = snd_sb16mixer_put_input_sw,\n\t\t},\n\t\t[SB_MIX_CAPTURE_PRO] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_sb8mixer_info_mux,\n\t\t\t.get = snd_sb8mixer_get_mux,\n\t\t\t.put = snd_sb8mixer_put_mux,\n\t\t},\n\t\t[SB_MIX_CAPTURE_DT019X] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_dt019x_input_sw_info,\n\t\t\t.get = snd_dt019x_input_sw_get,\n\t\t\t.put = snd_dt019x_input_sw_put,\n\t\t},\n\t\t[SB_MIX_MONO_CAPTURE_ALS4K] = {\n\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t.info = snd_als4k_mono_capture_route_info,\n\t\t\t.get = snd_als4k_mono_capture_route_get,\n\t\t\t.put = snd_als4k_mono_capture_route_put,\n\t\t},\n\t};\n\tstruct snd_kcontrol *ctl;\n\tint err;\n\n\tctl = snd_ctl_new1(&newctls[type], chip);\n\tif (! ctl)\n\t\treturn -ENOMEM;\n\tstrscpy(ctl->id.name, name, sizeof(ctl->id.name));\n\tctl->id.index = index;\n\tctl->private_value = value;\n\terr = snd_ctl_add(chip->card, ctl);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n \n\nstatic const struct sbmix_elem snd_sb20_controls[] = {\n\tSB_SINGLE(\"Master Playback Volume\", SB_DSP20_MASTER_DEV, 1, 7),\n\tSB_SINGLE(\"PCM Playback Volume\", SB_DSP20_PCM_DEV, 1, 3),\n\tSB_SINGLE(\"Synth Playback Volume\", SB_DSP20_FM_DEV, 1, 7),\n\tSB_SINGLE(\"CD Playback Volume\", SB_DSP20_CD_DEV, 1, 7)\n};\n\nstatic const unsigned char snd_sb20_init_values[][2] = {\n\t{ SB_DSP20_MASTER_DEV, 0 },\n\t{ SB_DSP20_FM_DEV, 0 },\n};\n\n \nstatic const struct sbmix_elem snd_sbpro_controls[] = {\n\tSB_DOUBLE(\"Master Playback Volume\",\n\t\t  SB_DSP_MASTER_DEV, SB_DSP_MASTER_DEV, 5, 1, 7),\n\tSB_DOUBLE(\"PCM Playback Volume\",\n\t\t  SB_DSP_PCM_DEV, SB_DSP_PCM_DEV, 5, 1, 7),\n\tSB_SINGLE(\"PCM Playback Filter\", SB_DSP_PLAYBACK_FILT, 5, 1),\n\tSB_DOUBLE(\"Synth Playback Volume\",\n\t\t  SB_DSP_FM_DEV, SB_DSP_FM_DEV, 5, 1, 7),\n\tSB_DOUBLE(\"CD Playback Volume\", SB_DSP_CD_DEV, SB_DSP_CD_DEV, 5, 1, 7),\n\tSB_DOUBLE(\"Line Playback Volume\",\n\t\t  SB_DSP_LINE_DEV, SB_DSP_LINE_DEV, 5, 1, 7),\n\tSB_SINGLE(\"Mic Playback Volume\", SB_DSP_MIC_DEV, 1, 3),\n\t{\n\t\t.name = \"Capture Source\",\n\t\t.type = SB_MIX_CAPTURE_PRO\n\t},\n\tSB_SINGLE(\"Capture Filter\", SB_DSP_CAPTURE_FILT, 5, 1),\n\tSB_SINGLE(\"Capture Low-Pass Filter\", SB_DSP_CAPTURE_FILT, 3, 1)\n};\n\nstatic const unsigned char snd_sbpro_init_values[][2] = {\n\t{ SB_DSP_MASTER_DEV, 0 },\n\t{ SB_DSP_PCM_DEV, 0 },\n\t{ SB_DSP_FM_DEV, 0 },\n};\n\n \nstatic const struct sbmix_elem snd_sb16_controls[] = {\n\tSB_DOUBLE(\"Master Playback Volume\",\n\t\t  SB_DSP4_MASTER_DEV, (SB_DSP4_MASTER_DEV + 1), 3, 3, 31),\n\tSB_DOUBLE(\"PCM Playback Volume\",\n\t\t  SB_DSP4_PCM_DEV, (SB_DSP4_PCM_DEV + 1), 3, 3, 31),\n\tSB16_INPUT_SW(\"Synth Capture Route\",\n\t\t      SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 6, 5),\n\tSB_DOUBLE(\"Synth Playback Volume\",\n\t\t  SB_DSP4_SYNTH_DEV, (SB_DSP4_SYNTH_DEV + 1), 3, 3, 31),\n\tSB16_INPUT_SW(\"CD Capture Route\",\n\t\t      SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 2, 1),\n\tSB_DOUBLE(\"CD Playback Switch\",\n\t\t  SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 2, 1, 1),\n\tSB_DOUBLE(\"CD Playback Volume\",\n\t\t  SB_DSP4_CD_DEV, (SB_DSP4_CD_DEV + 1), 3, 3, 31),\n\tSB16_INPUT_SW(\"Mic Capture Route\",\n\t\t      SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 0, 0),\n\tSB_SINGLE(\"Mic Playback Switch\", SB_DSP4_OUTPUT_SW, 0, 1),\n\tSB_SINGLE(\"Mic Playback Volume\", SB_DSP4_MIC_DEV, 3, 31),\n\tSB_SINGLE(\"Beep Volume\", SB_DSP4_SPEAKER_DEV, 6, 3),\n\tSB_DOUBLE(\"Capture Volume\",\n\t\t  SB_DSP4_IGAIN_DEV, (SB_DSP4_IGAIN_DEV + 1), 6, 6, 3),\n\tSB_DOUBLE(\"Playback Volume\",\n\t\t  SB_DSP4_OGAIN_DEV, (SB_DSP4_OGAIN_DEV + 1), 6, 6, 3),\n\tSB16_INPUT_SW(\"Line Capture Route\",\n\t\t      SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 4, 3),\n\tSB_DOUBLE(\"Line Playback Switch\",\n\t\t  SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 4, 3, 1),\n\tSB_DOUBLE(\"Line Playback Volume\",\n\t\t  SB_DSP4_LINE_DEV, (SB_DSP4_LINE_DEV + 1), 3, 3, 31),\n\tSB_SINGLE(\"Mic Auto Gain\", SB_DSP4_MIC_AGC, 0, 1),\n\tSB_SINGLE(\"3D Enhancement Switch\", SB_DSP4_3DSE, 0, 1),\n\tSB_DOUBLE(\"Tone Control - Bass\",\n\t\t  SB_DSP4_BASS_DEV, (SB_DSP4_BASS_DEV + 1), 4, 4, 15),\n\tSB_DOUBLE(\"Tone Control - Treble\",\n\t\t  SB_DSP4_TREBLE_DEV, (SB_DSP4_TREBLE_DEV + 1), 4, 4, 15)\n};\n\nstatic const unsigned char snd_sb16_init_values[][2] = {\n\t{ SB_DSP4_MASTER_DEV + 0, 0 },\n\t{ SB_DSP4_MASTER_DEV + 1, 0 },\n\t{ SB_DSP4_PCM_DEV + 0, 0 },\n\t{ SB_DSP4_PCM_DEV + 1, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 0, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 1, 0 },\n\t{ SB_DSP4_INPUT_LEFT, 0 },\n\t{ SB_DSP4_INPUT_RIGHT, 0 },\n\t{ SB_DSP4_OUTPUT_SW, 0 },\n\t{ SB_DSP4_SPEAKER_DEV, 0 },\n};\n\n \nstatic const struct sbmix_elem snd_dt019x_controls[] = {\n\t \n\tSB_DOUBLE(\"Master Playback Volume\",\n\t\t  SB_DT019X_MASTER_DEV, SB_DT019X_MASTER_DEV, 4, 0, 15),\n\tSB_DOUBLE(\"PCM Playback Switch\",\n\t\t  SB_DT019X_OUTPUT_SW2, SB_DT019X_OUTPUT_SW2, 2, 1, 1),\n\tSB_DOUBLE(\"PCM Playback Volume\",\n\t\t  SB_DT019X_PCM_DEV, SB_DT019X_PCM_DEV, 4, 0, 15),\n\tSB_DOUBLE(\"Synth Playback Switch\",\n\t\t  SB_DT019X_OUTPUT_SW2, SB_DT019X_OUTPUT_SW2, 4, 3, 1),\n\tSB_DOUBLE(\"Synth Playback Volume\",\n\t\t  SB_DT019X_SYNTH_DEV, SB_DT019X_SYNTH_DEV, 4, 0, 15),\n\tSB_DOUBLE(\"CD Playback Switch\",\n\t\t  SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 2, 1, 1),\n\tSB_DOUBLE(\"CD Playback Volume\",\n\t\t  SB_DT019X_CD_DEV, SB_DT019X_CD_DEV, 4, 0, 15),\n\tSB_SINGLE(\"Mic Playback Switch\", SB_DSP4_OUTPUT_SW, 0, 1),\n\tSB_SINGLE(\"Mic Playback Volume\", SB_DT019X_MIC_DEV, 4, 7),\n\tSB_SINGLE(\"Beep Volume\", SB_DT019X_SPKR_DEV, 0,  7),\n\tSB_DOUBLE(\"Line Playback Switch\",\n\t\t  SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 4, 3, 1),\n\tSB_DOUBLE(\"Line Playback Volume\",\n\t\t  SB_DT019X_LINE_DEV, SB_DT019X_LINE_DEV, 4, 0, 15),\n\t{\n\t\t.name = \"Capture Source\",\n\t\t.type = SB_MIX_CAPTURE_DT019X\n\t}\n};\n\nstatic const unsigned char snd_dt019x_init_values[][2] = {\n        { SB_DT019X_MASTER_DEV, 0 },\n        { SB_DT019X_PCM_DEV, 0 },\n        { SB_DT019X_SYNTH_DEV, 0 },\n        { SB_DT019X_CD_DEV, 0 },\n        { SB_DT019X_MIC_DEV, 0 },\t \n        { SB_DT019X_LINE_DEV, 0 },\n        { SB_DSP4_OUTPUT_SW, 0 },\n        { SB_DT019X_OUTPUT_SW2, 0 },\n        { SB_DT019X_CAPTURE_SW, 0x06 },\n};\n\n \nstatic const struct sbmix_elem snd_als4000_controls[] = {\n\tSB_DOUBLE(\"PCM Playback Switch\",\n\t\t  SB_DT019X_OUTPUT_SW2, SB_DT019X_OUTPUT_SW2, 2, 1, 1),\n\tSB_DOUBLE(\"Synth Playback Switch\",\n\t\t  SB_DT019X_OUTPUT_SW2, SB_DT019X_OUTPUT_SW2, 4, 3, 1),\n\tSB_SINGLE(\"Mic Boost (+20dB)\", SB_ALS4000_MIC_IN_GAIN, 0, 0x03),\n\tSB_SINGLE(\"Master Mono Playback Switch\", SB_ALS4000_MONO_IO_CTRL, 5, 1),\n\t{\n\t\t.name = \"Master Mono Capture Route\",\n\t\t.type = SB_MIX_MONO_CAPTURE_ALS4K\n\t},\n\tSB_SINGLE(\"Mono Playback Switch\", SB_DT019X_OUTPUT_SW2, 0, 1),\n\tSB_SINGLE(\"Analog Loopback Switch\", SB_ALS4000_MIC_IN_GAIN, 7, 0x01),\n\tSB_SINGLE(\"3D Control - Switch\", SB_ALS4000_3D_SND_FX, 6, 0x01),\n\tSB_SINGLE(\"Digital Loopback Switch\",\n\t\t  SB_ALS4000_CR3_CONFIGURATION, 7, 0x01),\n\t \n\tSB_SINGLE(\"3D Control - Level\", SB_ALS4000_3D_SND_FX, 0, 0x07),\n\t \n\tSB_SINGLE(\"3D Control - Freq\", SB_ALS4000_3D_SND_FX, 4, 0x03),\n\t \n\tSB_SINGLE(\"3D Control - Wide\", SB_ALS4000_3D_TIME_DELAY, 0, 0x0f),\n\tSB_SINGLE(\"3D PowerOff Switch\", SB_ALS4000_3D_TIME_DELAY, 4, 0x01),\n\tSB_SINGLE(\"Master Playback 8kHz / 20kHz LPF Switch\",\n\t\t  SB_ALS4000_FMDAC, 5, 0x01),\n#ifdef NOT_AVAILABLE\n\tSB_SINGLE(\"FMDAC Switch (Option ?)\", SB_ALS4000_FMDAC, 0, 0x01),\n\tSB_SINGLE(\"QSound Mode\", SB_ALS4000_QSOUND, 1, 0x1f),\n#endif\n};\n\nstatic const unsigned char snd_als4000_init_values[][2] = {\n\t{ SB_DSP4_MASTER_DEV + 0, 0 },\n\t{ SB_DSP4_MASTER_DEV + 1, 0 },\n\t{ SB_DSP4_PCM_DEV + 0, 0 },\n\t{ SB_DSP4_PCM_DEV + 1, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 0, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 1, 0 },\n\t{ SB_DSP4_SPEAKER_DEV, 0 },\n\t{ SB_DSP4_OUTPUT_SW, 0 },\n\t{ SB_DSP4_INPUT_LEFT, 0 },\n\t{ SB_DSP4_INPUT_RIGHT, 0 },\n\t{ SB_DT019X_OUTPUT_SW2, 0 },\n\t{ SB_ALS4000_MIC_IN_GAIN, 0 },\n};\n\n \nstatic int snd_sbmixer_init(struct snd_sb *chip,\n\t\t\t    const struct sbmix_elem *controls,\n\t\t\t    int controls_count,\n\t\t\t    const unsigned char map[][2],\n\t\t\t    int map_count,\n\t\t\t    char *name)\n{\n\tunsigned long flags;\n\tstruct snd_card *card = chip->card;\n\tint idx, err;\n\n\t \n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\tsnd_sbmixer_write(chip, 0x00, 0x00);\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\n\t \n\tfor (idx = 0; idx < map_count; idx++) {\n\t\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\t\tsnd_sbmixer_write(chip, map[idx][0], map[idx][1]);\n\t\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\t}\n\n\tfor (idx = 0; idx < controls_count; idx++) {\n\t\terr = snd_sbmixer_add_ctl_elem(chip, &controls[idx]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_component_add(card, name);\n\tstrcpy(card->mixername, name);\n\treturn 0;\n}\n\nint snd_sbmixer_new(struct snd_sb *chip)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!chip || !chip->card))\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\tswitch (chip->hardware) {\n\tcase SB_HW_10:\n\t\treturn 0;  \n\tcase SB_HW_20:\n\tcase SB_HW_201:\n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t       snd_sb20_controls,\n\t\t\t\t       ARRAY_SIZE(snd_sb20_controls),\n\t\t\t\t       snd_sb20_init_values,\n\t\t\t\t       ARRAY_SIZE(snd_sb20_init_values),\n\t\t\t\t       \"CTL1335\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SB_HW_PRO:\n\tcase SB_HW_JAZZ16:\n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t       snd_sbpro_controls,\n\t\t\t\t       ARRAY_SIZE(snd_sbpro_controls),\n\t\t\t\t       snd_sbpro_init_values,\n\t\t\t\t       ARRAY_SIZE(snd_sbpro_init_values),\n\t\t\t\t       \"CTL1345\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SB_HW_16:\n\tcase SB_HW_ALS100:\n\tcase SB_HW_CS5530:\n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t       snd_sb16_controls,\n\t\t\t\t       ARRAY_SIZE(snd_sb16_controls),\n\t\t\t\t       snd_sb16_init_values,\n\t\t\t\t       ARRAY_SIZE(snd_sb16_init_values),\n\t\t\t\t       \"CTL1745\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SB_HW_ALS4000:\n\t\t \n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t\tsnd_sb16_controls,\n\t\t\t\t\t16,\n\t\t\t\t\tsnd_sb16_init_values,\n\t\t\t\t\tARRAY_SIZE(snd_sb16_init_values),\n\t\t\t\t\t\"ALS4000\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t       snd_als4000_controls,\n\t\t\t\t       ARRAY_SIZE(snd_als4000_controls),\n\t\t\t\t       snd_als4000_init_values,\n\t\t\t\t       ARRAY_SIZE(snd_als4000_init_values),\n\t\t\t\t       \"ALS4000\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SB_HW_DT019X:\n\t\terr = snd_sbmixer_init(chip,\n\t\t\t\t       snd_dt019x_controls,\n\t\t\t\t       ARRAY_SIZE(snd_dt019x_controls),\n\t\t\t\t       snd_dt019x_init_values,\n\t\t\t\t       ARRAY_SIZE(snd_dt019x_init_values),\n\t\t\t\t       \"DT019X\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(card->mixername, \"???\");\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic const unsigned char sb20_saved_regs[] = {\n\tSB_DSP20_MASTER_DEV,\n\tSB_DSP20_PCM_DEV,\n\tSB_DSP20_FM_DEV,\n\tSB_DSP20_CD_DEV,\n};\n\nstatic const unsigned char sbpro_saved_regs[] = {\n\tSB_DSP_MASTER_DEV,\n\tSB_DSP_PCM_DEV,\n\tSB_DSP_PLAYBACK_FILT,\n\tSB_DSP_FM_DEV,\n\tSB_DSP_CD_DEV,\n\tSB_DSP_LINE_DEV,\n\tSB_DSP_MIC_DEV,\n\tSB_DSP_CAPTURE_SOURCE,\n\tSB_DSP_CAPTURE_FILT,\n};\n\nstatic const unsigned char sb16_saved_regs[] = {\n\tSB_DSP4_MASTER_DEV, SB_DSP4_MASTER_DEV + 1,\n\tSB_DSP4_3DSE,\n\tSB_DSP4_BASS_DEV, SB_DSP4_BASS_DEV + 1,\n\tSB_DSP4_TREBLE_DEV, SB_DSP4_TREBLE_DEV + 1,\n\tSB_DSP4_PCM_DEV, SB_DSP4_PCM_DEV + 1,\n\tSB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT,\n\tSB_DSP4_SYNTH_DEV, SB_DSP4_SYNTH_DEV + 1,\n\tSB_DSP4_OUTPUT_SW,\n\tSB_DSP4_CD_DEV, SB_DSP4_CD_DEV + 1,\n\tSB_DSP4_LINE_DEV, SB_DSP4_LINE_DEV + 1,\n\tSB_DSP4_MIC_DEV,\n\tSB_DSP4_SPEAKER_DEV,\n\tSB_DSP4_IGAIN_DEV, SB_DSP4_IGAIN_DEV + 1,\n\tSB_DSP4_OGAIN_DEV, SB_DSP4_OGAIN_DEV + 1,\n\tSB_DSP4_MIC_AGC\n};\n\nstatic const unsigned char dt019x_saved_regs[] = {\n\tSB_DT019X_MASTER_DEV,\n\tSB_DT019X_PCM_DEV,\n\tSB_DT019X_SYNTH_DEV,\n\tSB_DT019X_CD_DEV,\n\tSB_DT019X_MIC_DEV,\n\tSB_DT019X_SPKR_DEV,\n\tSB_DT019X_LINE_DEV,\n\tSB_DSP4_OUTPUT_SW,\n\tSB_DT019X_OUTPUT_SW2,\n\tSB_DT019X_CAPTURE_SW,\n};\n\nstatic const unsigned char als4000_saved_regs[] = {\n\t \n\tSB_DSP4_MASTER_DEV, SB_DSP4_MASTER_DEV + 1,\n\tSB_DSP4_OUTPUT_SW,\n\tSB_DSP4_PCM_DEV, SB_DSP4_PCM_DEV + 1,\n\tSB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT,\n\tSB_DSP4_SYNTH_DEV, SB_DSP4_SYNTH_DEV + 1,\n\tSB_DSP4_CD_DEV, SB_DSP4_CD_DEV + 1,\n\tSB_DSP4_MIC_DEV,\n\tSB_DSP4_SPEAKER_DEV,\n\tSB_DSP4_IGAIN_DEV, SB_DSP4_IGAIN_DEV + 1,\n\tSB_DSP4_OGAIN_DEV, SB_DSP4_OGAIN_DEV + 1,\n\tSB_DT019X_OUTPUT_SW2,\n\tSB_ALS4000_MONO_IO_CTRL,\n\tSB_ALS4000_MIC_IN_GAIN,\n\tSB_ALS4000_FMDAC,\n\tSB_ALS4000_3D_SND_FX,\n\tSB_ALS4000_3D_TIME_DELAY,\n\tSB_ALS4000_CR3_CONFIGURATION,\n};\n\nstatic void save_mixer(struct snd_sb *chip, const unsigned char *regs, int num_regs)\n{\n\tunsigned char *val = chip->saved_regs;\n\tif (snd_BUG_ON(num_regs > ARRAY_SIZE(chip->saved_regs)))\n\t\treturn;\n\tfor (; num_regs; num_regs--)\n\t\t*val++ = snd_sbmixer_read(chip, *regs++);\n}\n\nstatic void restore_mixer(struct snd_sb *chip, const unsigned char *regs, int num_regs)\n{\n\tunsigned char *val = chip->saved_regs;\n\tif (snd_BUG_ON(num_regs > ARRAY_SIZE(chip->saved_regs)))\n\t\treturn;\n\tfor (; num_regs; num_regs--)\n\t\tsnd_sbmixer_write(chip, *regs++, *val++);\n}\n\nvoid snd_sbmixer_suspend(struct snd_sb *chip)\n{\n\tswitch (chip->hardware) {\n\tcase SB_HW_20:\n\tcase SB_HW_201:\n\t\tsave_mixer(chip, sb20_saved_regs, ARRAY_SIZE(sb20_saved_regs));\n\t\tbreak;\n\tcase SB_HW_PRO:\n\tcase SB_HW_JAZZ16:\n\t\tsave_mixer(chip, sbpro_saved_regs, ARRAY_SIZE(sbpro_saved_regs));\n\t\tbreak;\n\tcase SB_HW_16:\n\tcase SB_HW_ALS100:\n\tcase SB_HW_CS5530:\n\t\tsave_mixer(chip, sb16_saved_regs, ARRAY_SIZE(sb16_saved_regs));\n\t\tbreak;\n\tcase SB_HW_ALS4000:\n\t\tsave_mixer(chip, als4000_saved_regs, ARRAY_SIZE(als4000_saved_regs));\n\t\tbreak;\n\tcase SB_HW_DT019X:\n\t\tsave_mixer(chip, dt019x_saved_regs, ARRAY_SIZE(dt019x_saved_regs));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid snd_sbmixer_resume(struct snd_sb *chip)\n{\n\tswitch (chip->hardware) {\n\tcase SB_HW_20:\n\tcase SB_HW_201:\n\t\trestore_mixer(chip, sb20_saved_regs, ARRAY_SIZE(sb20_saved_regs));\n\t\tbreak;\n\tcase SB_HW_PRO:\n\tcase SB_HW_JAZZ16:\n\t\trestore_mixer(chip, sbpro_saved_regs, ARRAY_SIZE(sbpro_saved_regs));\n\t\tbreak;\n\tcase SB_HW_16:\n\tcase SB_HW_ALS100:\n\tcase SB_HW_CS5530:\n\t\trestore_mixer(chip, sb16_saved_regs, ARRAY_SIZE(sb16_saved_regs));\n\t\tbreak;\n\tcase SB_HW_ALS4000:\n\t\trestore_mixer(chip, als4000_saved_regs, ARRAY_SIZE(als4000_saved_regs));\n\t\tbreak;\n\tcase SB_HW_DT019X:\n\t\trestore_mixer(chip, dt019x_saved_regs, ARRAY_SIZE(dt019x_saved_regs));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}