{
  "module_name": "sb16_csp.c",
  "hash_id": "45caf568f1f006fcf7b63c812303b86237530efcde584d0e02e1d5690b407eba",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb16_csp.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/sb16_csp.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Uros Bizjak <uros@kss-loka.si>\");\nMODULE_DESCRIPTION(\"ALSA driver for SB16 Creative Signal Processor\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"sb16/mulaw_main.csp\");\nMODULE_FIRMWARE(\"sb16/alaw_main.csp\");\nMODULE_FIRMWARE(\"sb16/ima_adpcm_init.csp\");\nMODULE_FIRMWARE(\"sb16/ima_adpcm_playback.csp\");\nMODULE_FIRMWARE(\"sb16/ima_adpcm_capture.csp\");\n\n#ifdef SNDRV_LITTLE_ENDIAN\n#define CSP_HDR_VALUE(a,b,c,d)\t((a) | ((b)<<8) | ((c)<<16) | ((d)<<24))\n#else\n#define CSP_HDR_VALUE(a,b,c,d)\t((d) | ((c)<<8) | ((b)<<16) | ((a)<<24))\n#endif\n\n#define RIFF_HEADER\tCSP_HDR_VALUE('R', 'I', 'F', 'F')\n#define CSP__HEADER\tCSP_HDR_VALUE('C', 'S', 'P', ' ')\n#define LIST_HEADER\tCSP_HDR_VALUE('L', 'I', 'S', 'T')\n#define FUNC_HEADER\tCSP_HDR_VALUE('f', 'u', 'n', 'c')\n#define CODE_HEADER\tCSP_HDR_VALUE('c', 'o', 'd', 'e')\n#define INIT_HEADER\tCSP_HDR_VALUE('i', 'n', 'i', 't')\n#define MAIN_HEADER\tCSP_HDR_VALUE('m', 'a', 'i', 'n')\n\n \nstruct riff_header {\n\t__le32 name;\n\t__le32 len;\n};\n\nstruct desc_header {\n\tstruct riff_header info;\n\t__le16 func_nr;\n\t__le16 VOC_type;\n\t__le16 flags_play_rec;\n\t__le16 flags_16bit_8bit;\n\t__le16 flags_stereo_mono;\n\t__le16 flags_rates;\n};\n\n \nstatic void snd_sb_csp_free(struct snd_hwdep *hw);\nstatic int snd_sb_csp_open(struct snd_hwdep * hw, struct file *file);\nstatic int snd_sb_csp_ioctl(struct snd_hwdep * hw, struct file *file, unsigned int cmd, unsigned long arg);\nstatic int snd_sb_csp_release(struct snd_hwdep * hw, struct file *file);\n\nstatic int csp_detect(struct snd_sb *chip, int *version);\nstatic int set_codec_parameter(struct snd_sb *chip, unsigned char par, unsigned char val);\nstatic int set_register(struct snd_sb *chip, unsigned char reg, unsigned char val);\nstatic int read_register(struct snd_sb *chip, unsigned char reg);\nstatic int set_mode_register(struct snd_sb *chip, unsigned char mode);\nstatic int get_version(struct snd_sb *chip);\n\nstatic int snd_sb_csp_riff_load(struct snd_sb_csp * p,\n\t\t\t\tstruct snd_sb_csp_microcode __user * code);\nstatic int snd_sb_csp_unload(struct snd_sb_csp * p);\nstatic int snd_sb_csp_load_user(struct snd_sb_csp * p, const unsigned char __user *buf, int size, int load_flags);\nstatic int snd_sb_csp_autoload(struct snd_sb_csp * p, snd_pcm_format_t pcm_sfmt, int play_rec_mode);\nstatic int snd_sb_csp_check_version(struct snd_sb_csp * p);\n\nstatic int snd_sb_csp_use(struct snd_sb_csp * p);\nstatic int snd_sb_csp_unuse(struct snd_sb_csp * p);\nstatic int snd_sb_csp_start(struct snd_sb_csp * p, int sample_width, int channels);\nstatic int snd_sb_csp_stop(struct snd_sb_csp * p);\nstatic int snd_sb_csp_pause(struct snd_sb_csp * p);\nstatic int snd_sb_csp_restart(struct snd_sb_csp * p);\n\nstatic int snd_sb_qsound_build(struct snd_sb_csp * p);\nstatic void snd_sb_qsound_destroy(struct snd_sb_csp * p);\nstatic int snd_sb_csp_qsound_transfer(struct snd_sb_csp * p);\n\nstatic int init_proc_entry(struct snd_sb_csp * p, int device);\nstatic void info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer);\n\n \nint snd_sb_csp_new(struct snd_sb *chip, int device, struct snd_hwdep ** rhwdep)\n{\n\tstruct snd_sb_csp *p;\n\tint version;\n\tint err;\n\tstruct snd_hwdep *hw;\n\n\tif (rhwdep)\n\t\t*rhwdep = NULL;\n\n\tif (csp_detect(chip, &version))\n\t\treturn -ENODEV;\n\n\terr = snd_hwdep_new(chip->card, \"SB16-CSP\", device, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\tsnd_device_free(chip->card, hw);\n\t\treturn -ENOMEM;\n\t}\n\tp->chip = chip;\n\tp->version = version;\n\n\t \n\tp->ops.csp_use = snd_sb_csp_use;\n\tp->ops.csp_unuse = snd_sb_csp_unuse;\n\tp->ops.csp_autoload = snd_sb_csp_autoload;\n\tp->ops.csp_start = snd_sb_csp_start;\n\tp->ops.csp_stop = snd_sb_csp_stop;\n\tp->ops.csp_qsound_transfer = snd_sb_csp_qsound_transfer;\n\n\tmutex_init(&p->access_mutex);\n\tsprintf(hw->name, \"CSP v%d.%d\", (version >> 4), (version & 0x0f));\n\thw->iface = SNDRV_HWDEP_IFACE_SB16CSP;\n\thw->private_data = p;\n\thw->private_free = snd_sb_csp_free;\n\n\t \n\thw->ops.open = snd_sb_csp_open;\n\thw->ops.ioctl = snd_sb_csp_ioctl;\n\thw->ops.release = snd_sb_csp_release;\n\n\t \n\tinit_proc_entry(p, device);\n\tif (rhwdep)\n\t\t*rhwdep = hw;\n\treturn 0;\n}\n\n \nstatic void snd_sb_csp_free(struct snd_hwdep *hwdep)\n{\n\tint i;\n\tstruct snd_sb_csp *p = hwdep->private_data;\n\tif (p) {\n\t\tif (p->running & SNDRV_SB_CSP_ST_RUNNING)\n\t\t\tsnd_sb_csp_stop(p);\n\t\tfor (i = 0; i < ARRAY_SIZE(p->csp_programs); ++i)\n\t\t\trelease_firmware(p->csp_programs[i]);\n\t\tkfree(p);\n\t}\n}\n\n \n\n \nstatic int snd_sb_csp_open(struct snd_hwdep * hw, struct file *file)\n{\n\tstruct snd_sb_csp *p = hw->private_data;\n\treturn (snd_sb_csp_use(p));\n}\n\n \nstatic int snd_sb_csp_ioctl(struct snd_hwdep * hw, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_sb_csp *p = hw->private_data;\n\tstruct snd_sb_csp_info info;\n\tstruct snd_sb_csp_start start_info;\n\tint err;\n\n\tif (snd_BUG_ON(!p))\n\t\treturn -EINVAL;\n\n\tif (snd_sb_csp_check_version(p))\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\t\t \n\tcase SNDRV_SB_CSP_IOCTL_INFO:\n\t\tmemset(&info, 0, sizeof(info));\n\t\t*info.codec_name = *p->codec_name;\n\t\tinfo.func_nr = p->func_nr;\n\t\tinfo.acc_format = p->acc_format;\n\t\tinfo.acc_channels = p->acc_channels;\n\t\tinfo.acc_width = p->acc_width;\n\t\tinfo.acc_rates = p->acc_rates;\n\t\tinfo.csp_mode = p->mode;\n\t\tinfo.run_channels = p->run_channels;\n\t\tinfo.run_width = p->run_width;\n\t\tinfo.version = p->version;\n\t\tinfo.state = p->running;\n\t\tif (copy_to_user((void __user *)arg, &info, sizeof(info)))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = 0;\n\t\tbreak;\n\n\t\t \n\tcase SNDRV_SB_CSP_IOCTL_LOAD_CODE:\n\t\terr = (p->running & SNDRV_SB_CSP_ST_RUNNING ?\n\t\t       -EBUSY : snd_sb_csp_riff_load(p, (struct snd_sb_csp_microcode __user *) arg));\n\t\tbreak;\n\tcase SNDRV_SB_CSP_IOCTL_UNLOAD_CODE:\n\t\terr = (p->running & SNDRV_SB_CSP_ST_RUNNING ?\n\t\t       -EBUSY : snd_sb_csp_unload(p));\n\t\tbreak;\n\n\t\t \n\tcase SNDRV_SB_CSP_IOCTL_START:\n\t\tif (copy_from_user(&start_info, (void __user *) arg, sizeof(start_info)))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = snd_sb_csp_start(p, start_info.sample_width, start_info.channels);\n\t\tbreak;\n\tcase SNDRV_SB_CSP_IOCTL_STOP:\n\t\terr = snd_sb_csp_stop(p);\n\t\tbreak;\n\tcase SNDRV_SB_CSP_IOCTL_PAUSE:\n\t\terr = snd_sb_csp_pause(p);\n\t\tbreak;\n\tcase SNDRV_SB_CSP_IOCTL_RESTART:\n\t\terr = snd_sb_csp_restart(p);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int snd_sb_csp_release(struct snd_hwdep * hw, struct file *file)\n{\n\tstruct snd_sb_csp *p = hw->private_data;\n\treturn (snd_sb_csp_unuse(p));\n}\n\n \n\n \nstatic int snd_sb_csp_use(struct snd_sb_csp * p)\n{\n\tmutex_lock(&p->access_mutex);\n\tif (p->used) {\n\t\tmutex_unlock(&p->access_mutex);\n\t\treturn -EAGAIN;\n\t}\n\tp->used++;\n\tmutex_unlock(&p->access_mutex);\n\n\treturn 0;\n\n}\n\n \nstatic int snd_sb_csp_unuse(struct snd_sb_csp * p)\n{\n\tmutex_lock(&p->access_mutex);\n\tp->used--;\n\tmutex_unlock(&p->access_mutex);\n\n\treturn 0;\n}\n\n \nstatic int snd_sb_csp_riff_load(struct snd_sb_csp * p,\n\t\t\t\tstruct snd_sb_csp_microcode __user * mcode)\n{\n\tstruct snd_sb_csp_mc_header info;\n\n\tunsigned char __user *data_ptr;\n\tunsigned char __user *data_end;\n\tunsigned short func_nr = 0;\n\n\tstruct riff_header file_h, item_h, code_h;\n\t__le32 item_type;\n\tstruct desc_header funcdesc_h;\n\n\tunsigned long flags;\n\tint err;\n\n\tif (copy_from_user(&info, mcode, sizeof(info)))\n\t\treturn -EFAULT;\n\tdata_ptr = mcode->data;\n\n\tif (copy_from_user(&file_h, data_ptr, sizeof(file_h)))\n\t\treturn -EFAULT;\n\tif ((le32_to_cpu(file_h.name) != RIFF_HEADER) ||\n\t    (le32_to_cpu(file_h.len) >= SNDRV_SB_CSP_MAX_MICROCODE_FILE_SIZE - sizeof(file_h))) {\n\t\tsnd_printd(\"%s: Invalid RIFF header\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdata_ptr += sizeof(file_h);\n\tdata_end = data_ptr + le32_to_cpu(file_h.len);\n\n\tif (copy_from_user(&item_type, data_ptr, sizeof(item_type)))\n\t\treturn -EFAULT;\n\tif (le32_to_cpu(item_type) != CSP__HEADER) {\n\t\tsnd_printd(\"%s: Invalid RIFF file type\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdata_ptr += sizeof (item_type);\n\n\tfor (; data_ptr < data_end; data_ptr += le32_to_cpu(item_h.len)) {\n\t\tif (copy_from_user(&item_h, data_ptr, sizeof(item_h)))\n\t\t\treturn -EFAULT;\n\t\tdata_ptr += sizeof(item_h);\n\t\tif (le32_to_cpu(item_h.name) != LIST_HEADER)\n\t\t\tcontinue;\n\n\t\tif (copy_from_user(&item_type, data_ptr, sizeof(item_type)))\n\t\t\t return -EFAULT;\n\t\tswitch (le32_to_cpu(item_type)) {\n\t\tcase FUNC_HEADER:\n\t\t\tif (copy_from_user(&funcdesc_h, data_ptr + sizeof(item_type), sizeof(funcdesc_h)))\n\t\t\t\treturn -EFAULT;\n\t\t\tfunc_nr = le16_to_cpu(funcdesc_h.func_nr);\n\t\t\tbreak;\n\t\tcase CODE_HEADER:\n\t\t\tif (func_nr != info.func_req)\n\t\t\t\tbreak;\t \n\t\t\tdata_ptr += sizeof(item_type);\n\n\t\t\t \n\t\t\tif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\n\t\t\t\tsnd_sb_qsound_destroy(p);\n\t\t\t}\n\t\t\t \n\t\t\tp->running = 0;\n\t\t\tp->mode = 0;\n\n\t\t\t \n\t\t\tfor (;;) {\n\t\t\t\tif (data_ptr >= data_end)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(&code_h, data_ptr, sizeof(code_h)))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t \n\t\t\t\tif (le32_to_cpu(code_h.name) != INIT_HEADER)\n\t\t\t\t\tbreak;\n\t\t\t\tdata_ptr += sizeof(code_h);\n\t\t\t\terr = snd_sb_csp_load_user(p, data_ptr, le32_to_cpu(code_h.len),\n\t\t\t\t\t\t      SNDRV_SB_CSP_LOAD_INITBLOCK);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdata_ptr += le32_to_cpu(code_h.len);\n\t\t\t}\n\t\t\t \n\t\t\tif (copy_from_user(&code_h, data_ptr, sizeof(code_h)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (le32_to_cpu(code_h.name) != MAIN_HEADER) {\n\t\t\t\tsnd_printd(\"%s: Missing 'main' microcode\\n\", __func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdata_ptr += sizeof(code_h);\n\t\t\terr = snd_sb_csp_load_user(p, data_ptr,\n\t\t\t\t\t\t   le32_to_cpu(code_h.len), 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tstrscpy(p->codec_name, info.codec_name, sizeof(p->codec_name));\n\t\t\tp->func_nr = func_nr;\n\t\t\tp->mode = le16_to_cpu(funcdesc_h.flags_play_rec);\n\t\t\tswitch (le16_to_cpu(funcdesc_h.VOC_type)) {\n\t\t\tcase 0x0001:\t \n\t\t\t\tif (le16_to_cpu(funcdesc_h.flags_play_rec) == SNDRV_SB_CSP_MODE_DSP_WRITE) {\n\t\t\t\t\tif (snd_sb_qsound_build(p) == 0)\n\t\t\t\t\t\t \n\t\t\t\t\t\tp->mode = SNDRV_SB_CSP_MODE_QSOUND;\n\t\t\t\t}\n\t\t\t\tp->acc_format = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x0006:\t \n\t\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_A_LAW;\n\t\t\t\tbreak;\n\t\t\tcase 0x0007:\t \n\t\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_MU_LAW;\n\t\t\t\tbreak;\n\t\t\tcase 0x0011:\t \n\t\t\tcase 0x0200:\t \n\t\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_IMA_ADPCM;\n\t\t\t\tbreak;\n\t\t\tcase    201:\t \n\t\t\t\t \n\t\t\t\tp->acc_format = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x0202:\t \n\t\t\tcase 0x0203:\t \n\t\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_SPECIAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\t \n\t\t\t\tp->acc_format = p->acc_width = p->acc_rates = 0;\n\t\t\t\tp->mode = 0;\n\t\t\t\tsnd_printd(\"%s: Unsupported CSP codec type: 0x%04x\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   le16_to_cpu(funcdesc_h.VOC_type));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tp->acc_channels = le16_to_cpu(funcdesc_h.flags_stereo_mono);\n\t\t\tp->acc_width = le16_to_cpu(funcdesc_h.flags_16bit_8bit);\n\t\t\tp->acc_rates = le16_to_cpu(funcdesc_h.flags_rates);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&p->chip->reg_lock, flags);\n\t\t\tset_mode_register(p->chip, 0xfc);\n\t\t\tset_mode_register(p->chip, 0x00);\n\t\t\tspin_unlock_irqrestore(&p->chip->reg_lock, flags);\n\n\t\t\t \n\t\t\tp->running = SNDRV_SB_CSP_ST_LOADED;\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\tsnd_printd(\"%s: Function #%d not found\\n\", __func__, info.func_req);\n\treturn -EINVAL;\n}\n\n \nstatic int snd_sb_csp_unload(struct snd_sb_csp * p)\n{\n\tif (p->running & SNDRV_SB_CSP_ST_RUNNING)\n\t\treturn -EBUSY;\n\tif (!(p->running & SNDRV_SB_CSP_ST_LOADED))\n\t\treturn -ENXIO;\n\n\t \n\tp->acc_format = 0;\n\tp->acc_channels = p->acc_width = p->acc_rates = 0;\n\t \n\tif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\n\t\tsnd_sb_qsound_destroy(p);\n\t}\n\t \n\tp->running = 0;\n\tp->mode = 0;\n\treturn 0;\n}\n\n \nstatic inline int command_seq(struct snd_sb *chip, const unsigned char *seq, int size)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (!snd_sbdsp_command(chip, seq[i]))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int set_codec_parameter(struct snd_sb *chip, unsigned char par, unsigned char val)\n{\n\tunsigned char dsp_cmd[3];\n\n\tdsp_cmd[0] = 0x05;\t \n\tdsp_cmd[1] = val;\t \n\tdsp_cmd[2] = par;\t \n\tcommand_seq(chip, dsp_cmd, 3);\n\tsnd_sbdsp_command(chip, 0x03);\t \n\tif (snd_sbdsp_get_byte(chip) != par)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int set_register(struct snd_sb *chip, unsigned char reg, unsigned char val)\n{\n\tunsigned char dsp_cmd[3];\n\n\tdsp_cmd[0] = 0x0e;\t \n\tdsp_cmd[1] = reg;\t \n\tdsp_cmd[2] = val;\t \n\treturn command_seq(chip, dsp_cmd, 3);\n}\n\n \nstatic int read_register(struct snd_sb *chip, unsigned char reg)\n{\n\tunsigned char dsp_cmd[2];\n\n\tdsp_cmd[0] = 0x0f;\t \n\tdsp_cmd[1] = reg;\t \n\tcommand_seq(chip, dsp_cmd, 2);\n\treturn snd_sbdsp_get_byte(chip);\t \n}\n\n \nstatic int set_mode_register(struct snd_sb *chip, unsigned char mode)\n{\n\tunsigned char dsp_cmd[2];\n\n\tdsp_cmd[0] = 0x04;\t \n\tdsp_cmd[1] = mode;\t \n\treturn command_seq(chip, dsp_cmd, 2);\n}\n\n \nstatic int csp_detect(struct snd_sb *chip, int *version)\n{\n\tunsigned char csp_test1, csp_test2;\n\tunsigned long flags;\n\tint result = -ENODEV;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\tset_codec_parameter(chip, 0x00, 0x00);\n\tset_mode_register(chip, 0xfc);\t\t \n\n\tcsp_test1 = read_register(chip, 0x83);\n\tset_register(chip, 0x83, ~csp_test1);\n\tcsp_test2 = read_register(chip, 0x83);\n\tif (csp_test2 != (csp_test1 ^ 0xff))\n\t\tgoto __fail;\n\n\tset_register(chip, 0x83, csp_test1);\n\tcsp_test2 = read_register(chip, 0x83);\n\tif (csp_test2 != csp_test1)\n\t\tgoto __fail;\n\n\tset_mode_register(chip, 0x00);\t\t \n\n\t*version = get_version(chip);\n\tsnd_sbdsp_reset(chip);\t \n\tif (*version >= 0x10 && *version <= 0x1f)\n\t\tresult = 0;\t\t \n\n      __fail:\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn result;\n}\n\n \nstatic int get_version(struct snd_sb *chip)\n{\n\tunsigned char dsp_cmd[2];\n\n\tdsp_cmd[0] = 0x08;\t \n\tdsp_cmd[1] = 0x03;\t \n\tcommand_seq(chip, dsp_cmd, 2);\n\n\treturn (snd_sbdsp_get_byte(chip));\n}\n\n \nstatic int snd_sb_csp_check_version(struct snd_sb_csp * p)\n{\n\tif (p->version < 0x10 || p->version > 0x1f) {\n\t\tsnd_printd(\"%s: Invalid CSP version: 0x%x\\n\", __func__, p->version);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_sb_csp_load(struct snd_sb_csp * p, const unsigned char *buf, int size, int load_flags)\n{\n\tint status, i;\n\tint err;\n\tint result = -EIO;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->chip->reg_lock, flags);\n\tsnd_sbdsp_command(p->chip, 0x01);\t \n\tif (snd_sbdsp_get_byte(p->chip)) {\n\t\tsnd_printd(\"%s: Download command failed\\n\", __func__);\n\t\tgoto __fail;\n\t}\n\t \n\tsnd_sbdsp_command(p->chip, (unsigned char)(size - 1));\n\t \n\tsnd_sbdsp_command(p->chip, (unsigned char)((size - 1) >> 8));\n\t \n\t \n\twhile (size--) {\n\t\tif (!snd_sbdsp_command(p->chip, *buf++))\n\t\t\tgoto __fail;\n\t}\n\tif (snd_sbdsp_get_byte(p->chip))\n\t\tgoto __fail;\n\n\tif (load_flags & SNDRV_SB_CSP_LOAD_INITBLOCK) {\n\t\ti = 0;\n\t\t \n\t\twhile (1) {\n\t\t\tsnd_sbdsp_command(p->chip, 0x03);\n\t\t\tstatus = snd_sbdsp_get_byte(p->chip);\n\t\t\tif (status == 0x55 || ++i >= 10)\n\t\t\t\tbreak;\n\t\t\tudelay (10);\n\t\t}\n\t\tif (status != 0x55) {\n\t\t\tsnd_printd(\"%s: Microcode initialization failed\\n\", __func__);\n\t\t\tgoto __fail;\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock(&p->chip->mixer_lock);\n\t\tstatus = snd_sbmixer_read(p->chip, SB_DSP4_DMASETUP);\n\t\tspin_unlock(&p->chip->mixer_lock);\n\t\tif (!(status & (SB_DMASETUP_DMA7 | SB_DMASETUP_DMA6 | SB_DMASETUP_DMA5))) {\n\t\t\terr = (set_codec_parameter(p->chip, 0xaa, 0x00) ||\n\t\t\t       set_codec_parameter(p->chip, 0xff, 0x00));\n\t\t\tsnd_sbdsp_reset(p->chip);\t\t \n\t\t\tif (err)\n\t\t\t\tgoto __fail;\n\t\t\tset_mode_register(p->chip, 0xc0);\t \n\t\t\tset_mode_register(p->chip, 0x70);\t \n\t\t}\n\t}\n\tresult = 0;\n\n      __fail:\n\tspin_unlock_irqrestore(&p->chip->reg_lock, flags);\n\treturn result;\n}\n \nstatic int snd_sb_csp_load_user(struct snd_sb_csp * p, const unsigned char __user *buf, int size, int load_flags)\n{\n\tint err;\n\tunsigned char *kbuf;\n\n\tkbuf = memdup_user(buf, size);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\terr = snd_sb_csp_load(p, kbuf, size, load_flags);\n\n\tkfree(kbuf);\n\treturn err;\n}\n\nstatic int snd_sb_csp_firmware_load(struct snd_sb_csp *p, int index, int flags)\n{\n\tstatic const char *const names[] = {\n\t\t\"sb16/mulaw_main.csp\",\n\t\t\"sb16/alaw_main.csp\",\n\t\t\"sb16/ima_adpcm_init.csp\",\n\t\t\"sb16/ima_adpcm_playback.csp\",\n\t\t\"sb16/ima_adpcm_capture.csp\",\n\t};\n\tconst struct firmware *program;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(names) != CSP_PROGRAM_COUNT);\n\tprogram = p->csp_programs[index];\n\tif (!program) {\n\t\tint err = request_firmware(&program, names[index],\n\t\t\t\t       p->chip->card->dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tp->csp_programs[index] = program;\n\t}\n\treturn snd_sb_csp_load(p, program->data, program->size, flags);\n}\n\n \nstatic int snd_sb_csp_autoload(struct snd_sb_csp * p, snd_pcm_format_t pcm_sfmt, int play_rec_mode)\n{\n\tunsigned long flags;\n\tint err = 0;\n\n\t \n\tif (p->running & (SNDRV_SB_CSP_ST_RUNNING | SNDRV_SB_CSP_ST_LOADED)) \n\t\treturn -EBUSY;\n\n\t \n\tif (((1U << (__force int)pcm_sfmt) & p->acc_format) && (play_rec_mode & p->mode)) {\n\t\tp->running = SNDRV_SB_CSP_ST_AUTO;\n\t} else {\n\t\tswitch (pcm_sfmt) {\n\t\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\t\terr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_MULAW, 0);\n\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_MU_LAW;\n\t\t\tp->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\t\terr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ALAW, 0);\n\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_A_LAW;\n\t\t\tp->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_FORMAT_IMA_ADPCM:\n\t\t\terr = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ADPCM_INIT,\n\t\t\t\t\t\t       SNDRV_SB_CSP_LOAD_INITBLOCK);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (play_rec_mode == SNDRV_SB_CSP_MODE_DSP_WRITE) {\n\t\t\t\terr = snd_sb_csp_firmware_load\n\t\t\t\t\t(p, CSP_PROGRAM_ADPCM_PLAYBACK, 0);\n\t\t\t\tp->mode = SNDRV_SB_CSP_MODE_DSP_WRITE;\n\t\t\t} else {\n\t\t\t\terr = snd_sb_csp_firmware_load\n\t\t\t\t\t(p, CSP_PROGRAM_ADPCM_CAPTURE, 0);\n\t\t\t\tp->mode = SNDRV_SB_CSP_MODE_DSP_READ;\n\t\t\t}\n\t\t\tp->acc_format = SNDRV_PCM_FMTBIT_IMA_ADPCM;\n\t\t\tbreak;\t\t\t\t  \n\t\tdefault:\n\t\t\t \n\t\t\tif (p->running & SNDRV_SB_CSP_ST_AUTO) {\n\t\t\t\tspin_lock_irqsave(&p->chip->reg_lock, flags);\n\t\t\t\tset_mode_register(p->chip, 0xfc);\n\t\t\t\tset_mode_register(p->chip, 0x00);\n\t\t\t\tspin_unlock_irqrestore(&p->chip->reg_lock, flags);\n\t\t\t\tp->running = 0;\t\t\t \n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (err) {\n\t\t\tp->acc_format = 0;\n\t\t\tp->acc_channels = p->acc_width = p->acc_rates = 0;\n\n\t\t\tp->running = 0;\t\t\t\t \n\t\t\tp->mode = 0;\n\t\t\treturn (err);\n\t\t} else {\n\t\t\tp->running = SNDRV_SB_CSP_ST_AUTO;\t \n\t\t\tp->acc_width = SNDRV_SB_CSP_SAMPLE_16BIT;\t \n\t\t\tp->acc_channels = SNDRV_SB_CSP_MONO | SNDRV_SB_CSP_STEREO;\n\t\t\tp->acc_rates = SNDRV_SB_CSP_RATE_ALL;\t \n\t\t}   \n\n\t}\n\treturn (p->running & SNDRV_SB_CSP_ST_AUTO) ? 0 : -ENXIO;\n}\n\n \nstatic int snd_sb_csp_start(struct snd_sb_csp * p, int sample_width, int channels)\n{\n\tunsigned char s_type;\t \n\tunsigned char mixL, mixR;\n\tint result = -EIO;\n\tunsigned long flags;\n\n\tif (!(p->running & (SNDRV_SB_CSP_ST_LOADED | SNDRV_SB_CSP_ST_AUTO))) {\n\t\tsnd_printd(\"%s: Microcode not loaded\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\tif (p->running & SNDRV_SB_CSP_ST_RUNNING) {\n\t\tsnd_printd(\"%s: CSP already running\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\tif (!(sample_width & p->acc_width)) {\n\t\tsnd_printd(\"%s: Unsupported PCM sample width\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!(channels & p->acc_channels)) {\n\t\tsnd_printd(\"%s: Invalid number of channels\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_irqsave(&p->chip->mixer_lock, flags);\n\tmixL = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV);\n\tmixR = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV + 1);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL & 0x7);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR & 0x7);\n\tspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\n\n\tspin_lock(&p->chip->reg_lock);\n\tset_mode_register(p->chip, 0xc0);\t \n\tset_mode_register(p->chip, 0x70);\t \n\n\ts_type = 0x00;\n\tif (channels == SNDRV_SB_CSP_MONO)\n\t\ts_type = 0x11;\t \n\tif (sample_width == SNDRV_SB_CSP_SAMPLE_8BIT)\n\t\ts_type |= 0x22;\t \n\n\tif (set_codec_parameter(p->chip, 0x81, s_type)) {\n\t\tsnd_printd(\"%s: Set sample type command failed\\n\", __func__);\n\t\tgoto __fail;\n\t}\n\tif (set_codec_parameter(p->chip, 0x80, 0x00)) {\n\t\tsnd_printd(\"%s: Codec start command failed\\n\", __func__);\n\t\tgoto __fail;\n\t}\n\tp->run_width = sample_width;\n\tp->run_channels = channels;\n\n\tp->running |= SNDRV_SB_CSP_ST_RUNNING;\n\n\tif (p->mode & SNDRV_SB_CSP_MODE_QSOUND) {\n\t\tset_codec_parameter(p->chip, 0xe0, 0x01);\n\t\t \n\t\tset_codec_parameter(p->chip, 0x00, 0xff);\n\t\tset_codec_parameter(p->chip, 0x01, 0xff);\n\t\tp->running |= SNDRV_SB_CSP_ST_QSOUND;\n\t\t \n\t\tsnd_sb_csp_qsound_transfer(p);\n\t}\n\tresult = 0;\n\n      __fail:\n\tspin_unlock(&p->chip->reg_lock);\n\n\t \n\tspin_lock_irqsave(&p->chip->mixer_lock, flags);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR);\n\tspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\n\n\treturn result;\n}\n\n \nstatic int snd_sb_csp_stop(struct snd_sb_csp * p)\n{\n\tint result;\n\tunsigned char mixL, mixR;\n\tunsigned long flags;\n\n\tif (!(p->running & SNDRV_SB_CSP_ST_RUNNING))\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&p->chip->mixer_lock, flags);\n\tmixL = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV);\n\tmixR = snd_sbmixer_read(p->chip, SB_DSP4_PCM_DEV + 1);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL & 0x7);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR & 0x7);\n\tspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\n\n\tspin_lock(&p->chip->reg_lock);\n\tif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\n\t\tset_codec_parameter(p->chip, 0xe0, 0x01);\n\t\t \n\t\tset_codec_parameter(p->chip, 0x00, 0x00);\n\t\tset_codec_parameter(p->chip, 0x01, 0x00);\n\n\t\tp->running &= ~SNDRV_SB_CSP_ST_QSOUND;\n\t}\n\tresult = set_mode_register(p->chip, 0xc0);\t \n\tspin_unlock(&p->chip->reg_lock);\n\n\t \n\tspin_lock_irqsave(&p->chip->mixer_lock, flags);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV, mixL);\n\tsnd_sbmixer_write(p->chip, SB_DSP4_PCM_DEV + 1, mixR);\n\tspin_unlock_irqrestore(&p->chip->mixer_lock, flags);\n\n\tif (!(result))\n\t\tp->running &= ~(SNDRV_SB_CSP_ST_PAUSED | SNDRV_SB_CSP_ST_RUNNING);\n\treturn result;\n}\n\n \nstatic int snd_sb_csp_pause(struct snd_sb_csp * p)\n{\n\tint result;\n\tunsigned long flags;\n\n\tif (!(p->running & SNDRV_SB_CSP_ST_RUNNING))\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&p->chip->reg_lock, flags);\n\tresult = set_codec_parameter(p->chip, 0x80, 0xff);\n\tspin_unlock_irqrestore(&p->chip->reg_lock, flags);\n\tif (!(result))\n\t\tp->running |= SNDRV_SB_CSP_ST_PAUSED;\n\n\treturn result;\n}\n\n \nstatic int snd_sb_csp_restart(struct snd_sb_csp * p)\n{\n\tint result;\n\tunsigned long flags;\n\n\tif (!(p->running & SNDRV_SB_CSP_ST_PAUSED))\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&p->chip->reg_lock, flags);\n\tresult = set_codec_parameter(p->chip, 0x80, 0x00);\n\tspin_unlock_irqrestore(&p->chip->reg_lock, flags);\n\tif (!(result))\n\t\tp->running &= ~SNDRV_SB_CSP_ST_PAUSED;\n\n\treturn result;\n}\n\n \n\n \n\n#define snd_sb_qsound_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_sb_qsound_switch_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = p->q_enabled ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_sb_qsound_switch_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval;\n\t\n\tnval = ucontrol->value.integer.value[0] & 0x01;\n\tspin_lock_irqsave(&p->q_lock, flags);\n\tchange = p->q_enabled != nval;\n\tp->q_enabled = nval;\n\tspin_unlock_irqrestore(&p->q_lock, flags);\n\treturn change;\n}\n\nstatic int snd_sb_qsound_space_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\n\treturn 0;\n}\n\nstatic int snd_sb_qsound_space_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&p->q_lock, flags);\n\tucontrol->value.integer.value[0] = p->qpos_left;\n\tucontrol->value.integer.value[1] = p->qpos_right;\n\tspin_unlock_irqrestore(&p->q_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb_qsound_space_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sb_csp *p = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval1, nval2;\n\t\n\tnval1 = ucontrol->value.integer.value[0];\n\tif (nval1 > SNDRV_SB_CSP_QSOUND_MAX_RIGHT)\n\t\tnval1 = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\n\tnval2 = ucontrol->value.integer.value[1];\n\tif (nval2 > SNDRV_SB_CSP_QSOUND_MAX_RIGHT)\n\t\tnval2 = SNDRV_SB_CSP_QSOUND_MAX_RIGHT;\n\tspin_lock_irqsave(&p->q_lock, flags);\n\tchange = p->qpos_left != nval1 || p->qpos_right != nval2;\n\tp->qpos_left = nval1;\n\tp->qpos_right = nval2;\n\tp->qpos_changed = change;\n\tspin_unlock_irqrestore(&p->q_lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_sb_qsound_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"3D Control - Switch\",\n\t.info = snd_sb_qsound_switch_info,\n\t.get = snd_sb_qsound_switch_get,\n\t.put = snd_sb_qsound_switch_put\n};\n\nstatic const struct snd_kcontrol_new snd_sb_qsound_space = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"3D Control - Space\",\n\t.info = snd_sb_qsound_space_info,\n\t.get = snd_sb_qsound_space_get,\n\t.put = snd_sb_qsound_space_put\n};\n\nstatic int snd_sb_qsound_build(struct snd_sb_csp * p)\n{\n\tstruct snd_card *card;\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\tif (snd_BUG_ON(!p))\n\t\treturn -EINVAL;\n\n\tcard = p->chip->card;\n\tp->qpos_left = p->qpos_right = SNDRV_SB_CSP_QSOUND_MAX_RIGHT / 2;\n\tp->qpos_changed = 0;\n\n\tspin_lock_init(&p->q_lock);\n\n\tkctl = snd_ctl_new1(&snd_sb_qsound_switch, p);\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\tgoto __error;\n\tp->qsound_switch = kctl;\n\tkctl = snd_ctl_new1(&snd_sb_qsound_space, p);\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\tgoto __error;\n\tp->qsound_space = kctl;\n\n\treturn 0;\n\n     __error:\n\tsnd_sb_qsound_destroy(p);\n\treturn err;\n}\n\nstatic void snd_sb_qsound_destroy(struct snd_sb_csp * p)\n{\n\tstruct snd_card *card;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!p))\n\t\treturn;\n\n\tcard = p->chip->card;\t\n\t\n\tif (p->qsound_switch) {\n\t\tsnd_ctl_remove(card, p->qsound_switch);\n\t\tp->qsound_switch = NULL;\n\t}\n\tif (p->qsound_space) {\n\t\tsnd_ctl_remove(card, p->qsound_space);\n\t\tp->qsound_space = NULL;\n\t}\n\n\t \n\tspin_lock_irqsave (&p->q_lock, flags);\n\tp->qpos_changed = 0;\n\tspin_unlock_irqrestore (&p->q_lock, flags);\n}\n\n \nstatic int snd_sb_csp_qsound_transfer(struct snd_sb_csp * p)\n{\n\tint err = -ENXIO;\n\n\tspin_lock(&p->q_lock);\n\tif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\n\t\tset_codec_parameter(p->chip, 0xe0, 0x01);\n\t\t \n\t\tset_codec_parameter(p->chip, 0x00, p->qpos_left);\n\t\tset_codec_parameter(p->chip, 0x02, 0x00);\n\t\t \n\t\tset_codec_parameter(p->chip, 0x00, p->qpos_right);\n\t\tset_codec_parameter(p->chip, 0x03, 0x00);\n\t\terr = 0;\n\t}\n\tp->qpos_changed = 0;\n\tspin_unlock(&p->q_lock);\n\treturn err;\n}\n\n \n\n \nstatic int init_proc_entry(struct snd_sb_csp * p, int device)\n{\n\tchar name[16];\n\n\tsprintf(name, \"cspD%d\", device);\n\tsnd_card_ro_proc_new(p->chip->card, name, p, info_read);\n\treturn 0;\n}\n\nstatic void info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_sb_csp *p = entry->private_data;\n\n\tsnd_iprintf(buffer, \"Creative Signal Processor [v%d.%d]\\n\", (p->version >> 4), (p->version & 0x0f));\n\tsnd_iprintf(buffer, \"State: %cx%c%c%c\\n\", ((p->running & SNDRV_SB_CSP_ST_QSOUND) ? 'Q' : '-'),\n\t\t    ((p->running & SNDRV_SB_CSP_ST_PAUSED) ? 'P' : '-'),\n\t\t    ((p->running & SNDRV_SB_CSP_ST_RUNNING) ? 'R' : '-'),\n\t\t    ((p->running & SNDRV_SB_CSP_ST_LOADED) ? 'L' : '-'));\n\tif (p->running & SNDRV_SB_CSP_ST_LOADED) {\n\t\tsnd_iprintf(buffer, \"Codec: %s [func #%d]\\n\", p->codec_name, p->func_nr);\n\t\tsnd_iprintf(buffer, \"Sample rates: \");\n\t\tif (p->acc_rates == SNDRV_SB_CSP_RATE_ALL) {\n\t\t\tsnd_iprintf(buffer, \"All\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"%s%s%s%s\\n\",\n\t\t\t\t    ((p->acc_rates & SNDRV_SB_CSP_RATE_8000) ? \"8000Hz \" : \"\"),\n\t\t\t\t    ((p->acc_rates & SNDRV_SB_CSP_RATE_11025) ? \"11025Hz \" : \"\"),\n\t\t\t\t    ((p->acc_rates & SNDRV_SB_CSP_RATE_22050) ? \"22050Hz \" : \"\"),\n\t\t\t\t    ((p->acc_rates & SNDRV_SB_CSP_RATE_44100) ? \"44100Hz\" : \"\"));\n\t\t}\n\t\tif (p->mode == SNDRV_SB_CSP_MODE_QSOUND) {\n\t\t\tsnd_iprintf(buffer, \"QSound decoder %sabled\\n\",\n\t\t\t\t    p->q_enabled ? \"en\" : \"dis\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"PCM format ID: 0x%x (%s/%s) [%s/%s] [%s/%s]\\n\",\n\t\t\t\t    p->acc_format,\n\t\t\t\t    ((p->acc_width & SNDRV_SB_CSP_SAMPLE_16BIT) ? \"16bit\" : \"-\"),\n\t\t\t\t    ((p->acc_width & SNDRV_SB_CSP_SAMPLE_8BIT) ? \"8bit\" : \"-\"),\n\t\t\t\t    ((p->acc_channels & SNDRV_SB_CSP_MONO) ? \"mono\" : \"-\"),\n\t\t\t\t    ((p->acc_channels & SNDRV_SB_CSP_STEREO) ? \"stereo\" : \"-\"),\n\t\t\t\t    ((p->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) ? \"playback\" : \"-\"),\n\t\t\t\t    ((p->mode & SNDRV_SB_CSP_MODE_DSP_READ) ? \"capture\" : \"-\"));\n\t\t}\n\t}\n\tif (p->running & SNDRV_SB_CSP_ST_AUTO) {\n\t\tsnd_iprintf(buffer, \"Autoloaded Mu-Law, A-Law or Ima-ADPCM hardware codec\\n\");\n\t}\n\tif (p->running & SNDRV_SB_CSP_ST_RUNNING) {\n\t\tsnd_iprintf(buffer, \"Processing %dbit %s PCM samples\\n\",\n\t\t\t    ((p->run_width & SNDRV_SB_CSP_SAMPLE_16BIT) ? 16 : 8),\n\t\t\t    ((p->run_channels & SNDRV_SB_CSP_MONO) ? \"mono\" : \"stereo\"));\n\t}\n\tif (p->running & SNDRV_SB_CSP_ST_QSOUND) {\n\t\tsnd_iprintf(buffer, \"Qsound position: left = 0x%x, right = 0x%x\\n\",\n\t\t\t    p->qpos_left, p->qpos_right);\n\t}\n}\n\n \n\nEXPORT_SYMBOL(snd_sb_csp_new);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}