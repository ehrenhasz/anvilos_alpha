{
  "module_name": "sb8_main.c",
  "hash_id": "1214a566043dbe3c57661d8b9c351b87a8cd277620990bfb50634adb9baf3187",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb8_main.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Uros Bizjak <uros@kss-loka.si>\");\nMODULE_DESCRIPTION(\"Routines for control of 8-bit SoundBlaster cards and clones\");\nMODULE_LICENSE(\"GPL\");\n\n#define SB8_CLOCK\t1000000\n#define SB8_DEN(v)\t((SB8_CLOCK + (v) / 2) / (v))\n#define SB8_RATE(v)\t(SB8_CLOCK / SB8_DEN(v))\n\nstatic const struct snd_ratnum clock = {\n\t.num = SB8_CLOCK,\n\t.den_min = 1,\n\t.den_max = 256,\n\t.den_step = 1,\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums hw_constraints_clock = {\n\t.nrats = 1,\n\t.rats = &clock,\n};\n\nstatic const struct snd_ratnum stereo_clocks[] = {\n\t{\n\t\t.num = SB8_CLOCK,\n\t\t.den_min = SB8_DEN(22050),\n\t\t.den_max = SB8_DEN(22050),\n\t\t.den_step = 1,\n\t},\n\t{\n\t\t.num = SB8_CLOCK,\n\t\t.den_min = SB8_DEN(11025),\n\t\t.den_max = SB8_DEN(11025),\n\t\t.den_step = 1,\n\t}\n};\n\nstatic int snd_sb8_hw_constraint_rate_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tif (c->min > 1) {\n\t  \tunsigned int num = 0, den = 0;\n\t\tint err = snd_interval_ratnum(hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE),\n\t\t\t\t\t  2, stereo_clocks, &num, &den);\n\t\tif (err >= 0 && den) {\n\t\t\tparams->rate_num = num;\n\t\t\tparams->rate_den = den;\n\t\t}\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8_hw_constraint_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (r->min > SB8_RATE(22050) || r->max <= SB8_RATE(11025)) {\n\t\tstruct snd_interval t = { .min = 1, .max = 1 };\n\t\treturn snd_interval_refine(hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS), &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int mixreg, rate, size, count;\n\tunsigned char format;\n\tunsigned char stereo = runtime->channels > 1;\n\tint dma;\n\n\trate = runtime->rate;\n\tswitch (chip->hardware) {\n\tcase SB_HW_JAZZ16:\n\t\tif (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {\n\t\t\tif (chip->mode & SB_MODE_CAPTURE_16)\n\t\t\t\treturn -EBUSY;\n\t\t\telse\n\t\t\t\tchip->mode |= SB_MODE_PLAYBACK_16;\n\t\t}\n\t\tchip->playback_format = SB_DSP_LO_OUTPUT_AUTO;\n\t\tbreak;\n\tcase SB_HW_PRO:\n\t\tif (runtime->channels > 1) {\n\t\t\tif (snd_BUG_ON(rate != SB8_RATE(11025) &&\n\t\t\t\t       rate != SB8_RATE(22050)))\n\t\t\t\treturn -EINVAL;\n\t\t\tchip->playback_format = SB_DSP_HI_OUTPUT_AUTO;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SB_HW_201:\n\t\tif (rate > 23000) {\n\t\t\tchip->playback_format = SB_DSP_HI_OUTPUT_AUTO;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SB_HW_20:\n\t\tchip->playback_format = SB_DSP_LO_OUTPUT_AUTO;\n\t\tbreak;\n\tcase SB_HW_10:\n\t\tchip->playback_format = SB_DSP_OUTPUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (chip->mode & SB_MODE_PLAYBACK_16) {\n\t\tformat = stereo ? SB_DSP_STEREO_16BIT : SB_DSP_MONO_16BIT;\n\t\tdma = chip->dma16;\n\t} else {\n\t\tformat = stereo ? SB_DSP_STEREO_8BIT : SB_DSP_MONO_8BIT;\n\t\tchip->mode |= SB_MODE_PLAYBACK_8;\n\t\tdma = chip->dma8;\n\t}\n\tsize = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tcount = chip->p_period_size = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_sbdsp_command(chip, SB_DSP_SPEAKER_ON);\n\tif (chip->hardware == SB_HW_JAZZ16)\n\t\tsnd_sbdsp_command(chip, format);\n\telse if (stereo) {\n\t\t \n\t\tspin_lock(&chip->mixer_lock);\n\t\tmixreg = snd_sbmixer_read(chip, SB_DSP_STEREO_SW);\n\t\tsnd_sbmixer_write(chip, SB_DSP_STEREO_SW, mixreg | 0x02);\n\t\tspin_unlock(&chip->mixer_lock);\n\n\t\t \n\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_EXIT);\n\t\truntime->dma_area[0] = 0x80;\n\t\tsnd_dma_program(dma, runtime->dma_addr, 1, DMA_MODE_WRITE);\n\t\t \n\t\tsnd_sbdsp_command(chip, SB_DSP_OUTPUT);\n\t\tsnd_sbdsp_command(chip, 0);\n\t\tsnd_sbdsp_command(chip, 0);\n\t}\n\tsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE);\n\tif (stereo) {\n\t\tsnd_sbdsp_command(chip, 256 - runtime->rate_den / 2);\n\t\tspin_lock(&chip->mixer_lock);\n\t\t \n\t\tmixreg = snd_sbmixer_read(chip, SB_DSP_PLAYBACK_FILT);\n\t\tsnd_sbmixer_write(chip, SB_DSP_PLAYBACK_FILT, mixreg | 0x20);\n\t\tspin_unlock(&chip->mixer_lock);\n\t\t \n\t\tchip->force_mode16 = mixreg;\n\t} else {\n\t\tsnd_sbdsp_command(chip, 256 - runtime->rate_den);\n\t}\n\tif (chip->playback_format != SB_DSP_OUTPUT) {\n\t\tif (chip->mode & SB_MODE_PLAYBACK_16)\n\t\t\tcount /= 2;\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP_BLOCK_SIZE);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_dma_program(dma, runtime->dma_addr,\n\t\t\tsize, DMA_MODE_WRITE | DMA_AUTOINIT);\n\treturn 0;\n}\n\nstatic int snd_sb8_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned int count;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_sbdsp_command(chip, chip->playback_format);\n\t\tif (chip->playback_format == SB_DSP_OUTPUT) {\n\t\t\tcount = chip->p_period_size - 1;\n\t\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (chip->playback_format == SB_DSP_HI_OUTPUT_AUTO) {\n\t\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\t\tsnd_sbdsp_reset(chip);\n\t\t\tif (runtime->channels > 1) {\n\t\t\t\tspin_lock(&chip->mixer_lock);\n\t\t\t\t  \n\t\t\t\tsnd_sbmixer_write(chip, SB_DSP_STEREO_SW, chip->force_mode16 & ~0x02);\n\t\t\t\tspin_unlock(&chip->mixer_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\n\t\t}\n\t\tsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_sb8_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int mixreg, rate, size, count;\n\tunsigned char format;\n\tunsigned char stereo = runtime->channels > 1;\n\tint dma;\n\n\trate = runtime->rate;\n\tswitch (chip->hardware) {\n\tcase SB_HW_JAZZ16:\n\t\tif (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {\n\t\t\tif (chip->mode & SB_MODE_PLAYBACK_16)\n\t\t\t\treturn -EBUSY;\n\t\t\telse\n\t\t\t\tchip->mode |= SB_MODE_CAPTURE_16;\n\t\t}\n\t\tchip->capture_format = SB_DSP_LO_INPUT_AUTO;\n\t\tbreak;\n\tcase SB_HW_PRO:\n\t\tif (runtime->channels > 1) {\n\t\t\tif (snd_BUG_ON(rate != SB8_RATE(11025) &&\n\t\t\t\t       rate != SB8_RATE(22050)))\n\t\t\t\treturn -EINVAL;\n\t\t\tchip->capture_format = SB_DSP_HI_INPUT_AUTO;\n\t\t\tbreak;\n\t\t}\n\t\tchip->capture_format = (rate > 23000) ? SB_DSP_HI_INPUT_AUTO : SB_DSP_LO_INPUT_AUTO;\n\t\tbreak;\n\tcase SB_HW_201:\n\t\tif (rate > 13000) {\n\t\t\tchip->capture_format = SB_DSP_HI_INPUT_AUTO;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SB_HW_20:\n\t\tchip->capture_format = SB_DSP_LO_INPUT_AUTO;\n\t\tbreak;\n\tcase SB_HW_10:\n\t\tchip->capture_format = SB_DSP_INPUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (chip->mode & SB_MODE_CAPTURE_16) {\n\t\tformat = stereo ? SB_DSP_STEREO_16BIT : SB_DSP_MONO_16BIT;\n\t\tdma = chip->dma16;\n\t} else {\n\t\tformat = stereo ? SB_DSP_STEREO_8BIT : SB_DSP_MONO_8BIT;\n\t\tchip->mode |= SB_MODE_CAPTURE_8;\n\t\tdma = chip->dma8;\n\t}\n\tsize = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tcount = chip->c_period_size = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\n\tif (chip->hardware == SB_HW_JAZZ16)\n\t\tsnd_sbdsp_command(chip, format);\n\telse if (stereo)\n\t\tsnd_sbdsp_command(chip, SB_DSP_STEREO_8BIT);\n\tsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE);\n\tif (stereo) {\n\t\tsnd_sbdsp_command(chip, 256 - runtime->rate_den / 2);\n\t\tspin_lock(&chip->mixer_lock);\n\t\t \n\t\tmixreg = snd_sbmixer_read(chip, SB_DSP_CAPTURE_FILT);\n\t\tsnd_sbmixer_write(chip, SB_DSP_CAPTURE_FILT, mixreg | 0x20);\n\t\tspin_unlock(&chip->mixer_lock);\n\t\t \n\t\tchip->force_mode16 = mixreg;\n\t} else {\n\t\tsnd_sbdsp_command(chip, 256 - runtime->rate_den);\n\t}\n\tif (chip->capture_format != SB_DSP_INPUT) {\n\t\tif (chip->mode & SB_MODE_PLAYBACK_16)\n\t\t\tcount /= 2;\n\t\tcount--;\n\t\tsnd_sbdsp_command(chip, SB_DSP_BLOCK_SIZE);\n\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\tsnd_sbdsp_command(chip, count >> 8);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_dma_program(dma, runtime->dma_addr,\n\t\t\tsize, DMA_MODE_READ | DMA_AUTOINIT);\n\treturn 0;\n}\n\nstatic int snd_sb8_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t   int cmd)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned int count;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_sbdsp_command(chip, chip->capture_format);\n\t\tif (chip->capture_format == SB_DSP_INPUT) {\n\t\t\tcount = chip->c_period_size - 1;\n\t\t\tsnd_sbdsp_command(chip, count & 0xff);\n\t\t\tsnd_sbdsp_command(chip, count >> 8);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (chip->capture_format == SB_DSP_HI_INPUT_AUTO) {\n\t\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\t\tsnd_sbdsp_reset(chip);\n\t\t\tif (runtime->channels > 1) {\n\t\t\t\t \n\t\t\t\tspin_lock(&chip->mixer_lock);\n\t\t\t\tsnd_sbmixer_write(chip, SB_DSP_CAPTURE_FILT, chip->force_mode16);\n\t\t\t\tspin_unlock(&chip->mixer_lock);\n\t\t\t\t \n\t\t\t\tsnd_sbdsp_command(chip, SB_DSP_MONO_8BIT);\n\t\t\t}\n\t\t} else {\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\n\t\t}\n\t\tsnd_sbdsp_command(chip, SB_DSP_SPEAKER_OFF);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nirqreturn_t snd_sb8dsp_interrupt(struct snd_sb *chip)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tsnd_sb_ack_8bit(chip);\n\tswitch (chip->mode) {\n\tcase SB_MODE_PLAYBACK_16:\t \n\t\tif (chip->hardware != SB_HW_JAZZ16)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SB_MODE_PLAYBACK_8:\n\t\tsubstream = chip->playback_substream;\n\t\tif (chip->playback_format == SB_DSP_OUTPUT)\n\t\t    \tsnd_sb8_playback_trigger(substream, SNDRV_PCM_TRIGGER_START);\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tbreak;\n\tcase SB_MODE_CAPTURE_16:\n\t\tif (chip->hardware != SB_HW_JAZZ16)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SB_MODE_CAPTURE_8:\n\t\tsubstream = chip->capture_substream;\n\t\tif (chip->capture_format == SB_DSP_INPUT)\n\t\t    \tsnd_sb8_capture_trigger(substream, SNDRV_PCM_TRIGGER_START);\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic snd_pcm_uframes_t snd_sb8_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tint dma;\n\n\tif (chip->mode & SB_MODE_PLAYBACK_8)\n\t\tdma = chip->dma8;\n\telse if (chip->mode & SB_MODE_PLAYBACK_16)\n\t\tdma = chip->dma16;\n\telse\n\t\treturn 0;\n\tptr = snd_dma_pointer(dma, chip->p_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_sb8_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tint dma;\n\n\tif (chip->mode & SB_MODE_CAPTURE_8)\n\t\tdma = chip->dma8;\n\telse if (chip->mode & SB_MODE_CAPTURE_16)\n\t\tdma = chip->dma16;\n\telse\n\t\treturn 0;\n\tptr = snd_dma_pointer(dma, chip->c_dma_size);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_sb8_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t SNDRV_PCM_FMTBIT_U8,\n\t.rates =\t\t(SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_22050),\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t23000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t1,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_sb8_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8,\n\t.rates =\t\t(SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_11025),\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t13000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t1,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n \nstatic int snd_sb8_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (chip->open) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tchip->open |= SB_OPEN_PCM;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tchip->playback_substream = substream;\n\t\truntime->hw = snd_sb8_playback;\n\t} else {\n\t\tchip->capture_substream = substream;\n\t\truntime->hw = snd_sb8_capture;\n\t}\n\tswitch (chip->hardware) {\n\tcase SB_HW_JAZZ16:\n\t\tif (chip->dma16 == 5 || chip->dma16 == 7)\n\t\t\truntime->hw.formats |= SNDRV_PCM_FMTBIT_S16_LE;\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_8000_48000;\n\t\truntime->hw.rate_min = 4000;\n\t\truntime->hw.rate_max = 50000;\n\t\truntime->hw.channels_max = 2;\n\t\tbreak;\n\tcase SB_HW_PRO:\n\t\truntime->hw.rate_max = 44100;\n\t\truntime->hw.channels_max = 2;\n\t\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t    snd_sb8_hw_constraint_rate_channels, NULL,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE, -1);\n\t\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t     snd_sb8_hw_constraint_channels_rate, NULL,\n\t\t\t\t     SNDRV_PCM_HW_PARAM_RATE, -1);\n\t\tbreak;\n\tcase SB_HW_201:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\truntime->hw.rate_max = 44100;\n\t\t} else {\n\t\t\truntime->hw.rate_max = 15000;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clock);\n\tif (chip->dma8 > 3 || chip->dma16 >= 0) {\n\t\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 2);\n\t\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 2);\n\t\truntime->hw.buffer_bytes_max = 128 * 1024 * 1024;\n\t\truntime->hw.period_bytes_max = 128 * 1024 * 1024;\n\t}\n\treturn 0;\t\n}\n\nstatic int snd_sb8_close(struct snd_pcm_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\tchip->capture_substream = NULL;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tchip->open &= ~SB_OPEN_PCM;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tchip->mode &= ~SB_MODE_PLAYBACK;\n\telse\n\t\tchip->mode &= ~SB_MODE_CAPTURE;\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\treturn 0;\n}\n\n \n \nstatic const struct snd_pcm_ops snd_sb8_playback_ops = {\n\t.open =\t\t\tsnd_sb8_open,\n\t.close =\t\tsnd_sb8_close,\n\t.prepare =\t\tsnd_sb8_playback_prepare,\n\t.trigger =\t\tsnd_sb8_playback_trigger,\n\t.pointer =\t\tsnd_sb8_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_sb8_capture_ops = {\n\t.open =\t\t\tsnd_sb8_open,\n\t.close =\t\tsnd_sb8_close,\n\t.prepare =\t\tsnd_sb8_capture_prepare,\n\t.trigger =\t\tsnd_sb8_capture_trigger,\n\t.pointer =\t\tsnd_sb8_capture_pointer,\n};\n\nint snd_sb8dsp_pcm(struct snd_sb *chip, int device)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_pcm *pcm;\n\tint err;\n\tsize_t max_prealloc = 64 * 1024;\n\n\terr = snd_pcm_new(card, \"SB8 DSP\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsprintf(pcm->name, \"DSP v%i.%i\", chip->version >> 8, chip->version & 0xff);\n\tpcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sb8_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sb8_capture_ops);\n\n\tif (chip->dma8 > 3 || chip->dma16 >= 0)\n\t\tmax_prealloc = 128 * 1024;\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, 64*1024, max_prealloc);\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_sb8dsp_pcm);\nEXPORT_SYMBOL(snd_sb8dsp_interrupt);\n   \nEXPORT_SYMBOL(snd_sb8dsp_midi_interrupt);\nEXPORT_SYMBOL(snd_sb8dsp_midi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}