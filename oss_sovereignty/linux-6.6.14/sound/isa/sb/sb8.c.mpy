{
  "module_name": "sb8.c",
  "hash_id": "eaad6eee40654e73f7096e0705b2e1b4bfac669eded3921209349f1bf3d05e16",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb8.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Sound Blaster 1.0/2.0/Pro\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Sound Blaster soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Sound Blaster soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Sound Blaster soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for SB8 driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for SB8 driver.\");\nmodule_param_hw_array(dma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma8, \"8-bit DMA # for SB8 driver.\");\n\nstruct snd_sb8 {\n\tstruct resource *fm_res;\t \n\tstruct snd_sb *chip;\n};\n\nstatic irqreturn_t snd_sb8_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_sb *chip = dev_id;\n\n\tif (chip->open & SB_OPEN_PCM) {\n\t\treturn snd_sb8dsp_interrupt(chip);\n\t} else {\n\t\treturn snd_sb8dsp_midi_interrupt(chip);\n\t}\n}\n\nstatic int snd_sb8_match(struct device *pdev, unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n\tif (irq[dev] == SNDRV_AUTO_IRQ) {\n\t\tdev_err(pdev, \"please specify irq\\n\");\n\t\treturn 0;\n\t}\n\tif (dma8[dev] == SNDRV_AUTO_DMA) {\n\t\tdev_err(pdev, \"please specify dma8\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_sb8_probe(struct device *pdev, unsigned int dev)\n{\n\tstruct snd_sb *chip;\n\tstruct snd_card *card;\n\tstruct snd_sb8 *acard;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_sb8), &card);\n\tif (err < 0)\n\t\treturn err;\n\tacard = card->private_data;\n\n\t \n\tacard->fm_res = devm_request_region(card->dev, 0x388, 4,\n\t\t\t\t\t    \"SoundBlaster FM\");\n\n\tif (port[dev] != SNDRV_AUTO_PORT) {\n\t\terr = snd_sbdsp_create(card, port[dev], irq[dev],\n\t\t\t\t       snd_sb8_interrupt, dma8[dev],\n\t\t\t\t       -1, SB_HW_AUTO, &chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tstatic const unsigned long possible_ports[] = {\n\t\t\t0x220, 0x240, 0x260,\n\t\t};\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\n\t\t\terr = snd_sbdsp_create(card, possible_ports[i],\n\t\t\t\t\t       irq[dev],\n\t\t\t\t\t       snd_sb8_interrupt,\n\t\t\t\t\t       dma8[dev],\n\t\t\t\t\t       -1,\n\t\t\t\t\t       SB_HW_AUTO,\n\t\t\t\t\t       &chip);\n\t\t\tif (err >= 0) {\n\t\t\t\tport[dev] = possible_ports[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i >= ARRAY_SIZE(possible_ports))\n\t\t\treturn -EINVAL;\n\t}\n\tacard->chip = chip;\n\t\t\t\n\tif (chip->hardware >= SB_HW_16) {\n\t\tif (chip->hardware == SB_HW_ALS100)\n\t\t\tsnd_printk(KERN_WARNING \"ALS100 chip detected at 0x%lx, try snd-als100 module\\n\",\n\t\t\t\t    port[dev]);\n\t\telse\n\t\t\tsnd_printk(KERN_WARNING \"SB 16 chip detected at 0x%lx, try snd-sb16 module\\n\",\n\t\t\t\t   port[dev]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_sb8dsp_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_sbmixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->hardware == SB_HW_10 || chip->hardware == SB_HW_20) {\n\t\terr = snd_opl3_create(card, chip->port + 8, 0,\n\t\t\t\t      OPL3_HW_AUTO, 1, &opl3);\n\t\tif (err < 0)\n\t\t\tsnd_printk(KERN_WARNING \"sb8: no OPL device at 0x%lx\\n\", chip->port + 8);\n\t} else {\n\t\terr = snd_opl3_create(card, chip->port, chip->port + 2,\n\t\t\t\t      OPL3_HW_AUTO, 1, &opl3);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_WARNING \"sb8: no OPL device at 0x%lx-0x%lx\\n\",\n\t\t\t\t   chip->port, chip->port + 2);\n\t\t}\n\t}\n\tif (err >= 0) {\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_sb8dsp_midi(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, chip->hardware == SB_HW_PRO ? \"SB Pro\" : \"SB8\");\n\tstrcpy(card->shortname, chip->name);\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma %d\",\n\t\tchip->name,\n\t\tchip->port,\n\t\tirq[dev], dma8[dev]);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_sb8_suspend(struct device *dev, unsigned int n,\n\t\t\t   pm_message_t state)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_sb8 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_sbmixer_suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_sb8_resume(struct device *dev, unsigned int n)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_sb8 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_sbdsp_reset(chip);\n\tsnd_sbmixer_resume(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\n#define DEV_NAME \"sb8\"\n\nstatic struct isa_driver snd_sb8_driver = {\n\t.match\t\t= snd_sb8_match,\n\t.probe\t\t= snd_sb8_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_sb8_suspend,\n\t.resume\t\t= snd_sb8_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME \n\t},\n};\n\nmodule_isa_driver(snd_sb8_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}