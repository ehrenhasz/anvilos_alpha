{
  "module_name": "jazz16.c",
  "hash_id": "5c24797d02bd674f8359643edf040acd8b54664ecd3195cc62bc327853142838",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/jazz16.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <asm/dma.h>\n#include <linux/isa.h>\n#include <sound/core.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/sb.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\n#define PFX \"jazz16: \"\n\nMODULE_DESCRIPTION(\"Media Vision Jazz16\");\nMODULE_AUTHOR(\"Krzysztof Helt <krzysztof.h1@wp.pl>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic unsigned long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic unsigned long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic int dma16[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Media Vision Jazz16 based soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Media Vision Jazz16 based soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Media Vision Jazz16 based soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for jazz16 driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for jazz16 driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for jazz16 driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for jazz16 driver.\");\nmodule_param_hw_array(dma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma8, \"DMA8 # for jazz16 driver.\");\nmodule_param_hw_array(dma16, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma16, \"DMA16 # for jazz16 driver.\");\n\n#define SB_JAZZ16_WAKEUP\t0xaf\n#define SB_JAZZ16_SET_PORTS\t0x50\n#define SB_DSP_GET_JAZZ_BRD_REV\t0xfa\n#define SB_JAZZ16_SET_DMAINTR\t0xfb\n#define SB_DSP_GET_JAZZ_MODEL\t0xfe\n\nstruct snd_card_jazz16 {\n\tstruct snd_sb *chip;\n};\n\nstatic irqreturn_t jazz16_interrupt(int irq, void *chip)\n{\n\treturn snd_sb8dsp_interrupt(chip);\n}\n\nstatic int jazz16_configure_ports(unsigned long port,\n\t\t\t\t  unsigned long mpu_port, int idx)\n{\n\tunsigned char val;\n\n\tif (!request_region(0x201, 1, \"jazz16 config\")) {\n\t\tsnd_printk(KERN_ERR \"config port region is already in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\toutb(SB_JAZZ16_WAKEUP - idx, 0x201);\n\tudelay(100);\n\toutb(SB_JAZZ16_SET_PORTS + idx, 0x201);\n\tudelay(100);\n\tval = port & 0x70;\n\tval |= (mpu_port & 0x30) >> 4;\n\toutb(val, 0x201);\n\n\trelease_region(0x201, 1);\n\treturn 0;\n}\n\nstatic int jazz16_detect_board(unsigned long port,\n\t\t\t       unsigned long mpu_port)\n{\n\tint err;\n\tint val;\n\tstruct snd_sb chip;\n\n\tif (!request_region(port, 0x10, \"jazz16\")) {\n\t\tsnd_printk(KERN_ERR \"I/O port region is already in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\t \n\tchip.port = port;\n\n\terr = snd_sbdsp_reset(&chip);\n\tif (err < 0)\n\t\tfor (val = 0; val < 4; val++) {\n\t\t\terr = jazz16_configure_ports(port, mpu_port, val);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\terr = snd_sbdsp_reset(&chip);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t}\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto err_unmap;\n\t}\n\tif (!snd_sbdsp_command(&chip, SB_DSP_GET_JAZZ_BRD_REV)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unmap;\n\t}\n\tval = snd_sbdsp_get_byte(&chip);\n\tif (val >= 0x30)\n\t\tsnd_sbdsp_get_byte(&chip);\n\n\tif ((val & 0xf0) != 0x10) {\n\t\terr = -ENODEV;\n\t\tgoto err_unmap;\n\t}\n\tif (!snd_sbdsp_command(&chip, SB_DSP_GET_JAZZ_MODEL)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unmap;\n\t}\n\tsnd_sbdsp_get_byte(&chip);\n\terr = snd_sbdsp_get_byte(&chip);\n\tsnd_printd(\"Media Vision Jazz16 board detected: rev 0x%x, model 0x%x\\n\",\n\t\t   val, err);\n\n\terr = 0;\n\nerr_unmap:\n\trelease_region(port, 0x10);\n\treturn err;\n}\n\nstatic int jazz16_configure_board(struct snd_sb *chip, int mpu_irq)\n{\n\tstatic const unsigned char jazz_irq_bits[] = { 0, 0, 2, 3, 0, 1, 0, 4,\n\t\t\t\t\t\t 0, 2, 5, 0, 0, 0, 0, 6 };\n\tstatic const unsigned char jazz_dma_bits[] = { 0, 1, 0, 2, 0, 3, 0, 4 };\n\n\tif (jazz_dma_bits[chip->dma8] == 0 ||\n\t    jazz_dma_bits[chip->dma16] == 0 ||\n\t    jazz_irq_bits[chip->irq] == 0)\n\t\treturn -EINVAL;\n\n\tif (!snd_sbdsp_command(chip, SB_JAZZ16_SET_DMAINTR))\n\t\treturn -EBUSY;\n\n\tif (!snd_sbdsp_command(chip,\n\t\t\t       jazz_dma_bits[chip->dma8] |\n\t\t\t       (jazz_dma_bits[chip->dma16] << 4)))\n\t\treturn -EBUSY;\n\n\tif (!snd_sbdsp_command(chip,\n\t\t\t       jazz_irq_bits[chip->irq] |\n\t\t\t       (jazz_irq_bits[mpu_irq] << 4)))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int snd_jazz16_match(struct device *devptr, unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n\tif (port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR \"please specify port\\n\");\n\t\treturn 0;\n\t} else if (port[dev] == 0x200 || (port[dev] & ~0x270)) {\n\t\tsnd_printk(KERN_ERR \"incorrect port specified\\n\");\n\t\treturn 0;\n\t}\n\tif (dma8[dev] != SNDRV_AUTO_DMA &&\n\t    dma8[dev] != 1 && dma8[dev] != 3) {\n\t\tsnd_printk(KERN_ERR \"dma8 must be 1 or 3\\n\");\n\t\treturn 0;\n\t}\n\tif (dma16[dev] != SNDRV_AUTO_DMA &&\n\t    dma16[dev] != 5 && dma16[dev] != 7) {\n\t\tsnd_printk(KERN_ERR \"dma16 must be 5 or 7\\n\");\n\t\treturn 0;\n\t}\n\tif (mpu_port[dev] != SNDRV_AUTO_PORT &&\n\t    (mpu_port[dev] & ~0x030) != 0x300) {\n\t\tsnd_printk(KERN_ERR \"incorrect mpu_port specified\\n\");\n\t\treturn 0;\n\t}\n\tif (mpu_irq[dev] != SNDRV_AUTO_DMA &&\n\t    mpu_irq[dev] != 2 && mpu_irq[dev] != 3 &&\n\t    mpu_irq[dev] != 5 && mpu_irq[dev] != 7) {\n\t\tsnd_printk(KERN_ERR \"mpu_irq must be 2, 3, 5 or 7\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_jazz16_probe(struct device *devptr, unsigned int dev)\n{\n\tstruct snd_card *card;\n\tstruct snd_card_jazz16 *jazz16;\n\tstruct snd_sb *chip;\n\tstruct snd_opl3 *opl3;\n\tstatic const int possible_irqs[] = {2, 3, 5, 7, 9, 10, 15, -1};\n\tstatic const int possible_dmas8[] = {1, 3, -1};\n\tstatic const int possible_dmas16[] = {5, 7, -1};\n\tint err, xirq, xdma8, xdma16, xmpu_port, xmpu_irq;\n\n\terr = snd_devm_card_new(devptr, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_card_jazz16), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tjazz16 = card->private_data;\n\n\txirq = irq[dev];\n\tif (xirq == SNDRV_AUTO_IRQ) {\n\t\txirq = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (xirq < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\txdma8 = dma8[dev];\n\tif (xdma8 == SNDRV_AUTO_DMA) {\n\t\txdma8 = snd_legacy_find_free_dma(possible_dmas8);\n\t\tif (xdma8 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA8\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\txdma16 = dma16[dev];\n\tif (xdma16 == SNDRV_AUTO_DMA) {\n\t\txdma16 = snd_legacy_find_free_dma(possible_dmas16);\n\t\tif (xdma16 < 0) {\n\t\t\tsnd_printk(KERN_ERR \"unable to find a free DMA16\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\txmpu_port = mpu_port[dev];\n\tif (xmpu_port == SNDRV_AUTO_PORT)\n\t\txmpu_port = 0;\n\terr = jazz16_detect_board(port[dev], xmpu_port);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"Media Vision Jazz16 board not detected\\n\");\n\t\treturn err;\n\t}\n\terr = snd_sbdsp_create(card, port[dev], irq[dev],\n\t\t\t       jazz16_interrupt,\n\t\t\t       dma8[dev], dma16[dev],\n\t\t\t       SB_HW_JAZZ16,\n\t\t\t       &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\txmpu_irq = mpu_irq[dev];\n\tif (xmpu_irq == SNDRV_AUTO_IRQ || mpu_port[dev] == SNDRV_AUTO_PORT)\n\t\txmpu_irq = 0;\n\terr = jazz16_configure_board(chip, xmpu_irq);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"Media Vision Jazz16 configuration failed\\n\");\n\t\treturn err;\n\t}\n\n\tjazz16->chip = chip;\n\n\tstrcpy(card->driver, \"jazz16\");\n\tstrcpy(card->shortname, \"Media Vision Jazz16\");\n\tsprintf(card->longname,\n\t\t\"Media Vision Jazz16 at 0x%lx, irq %d, dma8 %d, dma16 %d\",\n\t\tport[dev], xirq, xdma8, xdma16);\n\n\terr = snd_sb8dsp_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_sbmixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_opl3_create(card, chip->port, chip->port + 2,\n\t\t\t      OPL3_HW_AUTO, 1, &opl3);\n\tif (err < 0)\n\t\tsnd_printk(KERN_WARNING \"no OPL device at 0x%lx-0x%lx\\n\",\n\t\t\t   chip->port, chip->port + 2);\n\telse {\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\tif (mpu_irq[dev] == SNDRV_AUTO_IRQ)\n\t\t\tmpu_irq[dev] = -1;\n\n\t\tif (snd_mpu401_uart_new(card, 0,\n\t\t\t\t\tMPU401_HW_MPU401,\n\t\t\t\t\tmpu_port[dev], 0,\n\t\t\t\t\tmpu_irq[dev],\n\t\t\t\t\tNULL) < 0)\n\t\t\tsnd_printk(KERN_ERR \"no MPU-401 device at 0x%lx\\n\",\n\t\t\t\t\tmpu_port[dev]);\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_jazz16_suspend(struct device *pdev, unsigned int n,\n\t\t\t       pm_message_t state)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct snd_card_jazz16 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_sbmixer_suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_jazz16_resume(struct device *pdev, unsigned int n)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\tstruct snd_card_jazz16 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_sbdsp_reset(chip);\n\tsnd_sbmixer_resume(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic struct isa_driver snd_jazz16_driver = {\n\t.match\t\t= snd_jazz16_match,\n\t.probe\t\t= snd_jazz16_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_jazz16_suspend,\n\t.resume\t\t= snd_jazz16_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= \"jazz16\"\n\t},\n};\n\nmodule_isa_driver(snd_jazz16_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}