{
  "module_name": "sb_common.c",
  "hash_id": "8063bde35d8b34a930084483f1723d446f2425a4c01c3096d7231c665c358e53",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb_common.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/initval.h>\n\n#include <asm/dma.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ALSA lowlevel driver for Sound Blaster cards\");\nMODULE_LICENSE(\"GPL\");\n\n#define BUSY_LOOPS 100000\n\n#undef IO_DEBUG\n\nint snd_sbdsp_command(struct snd_sb *chip, unsigned char val)\n{\n\tint i;\n#ifdef IO_DEBUG\n\tsnd_printk(KERN_DEBUG \"command 0x%x\\n\", val);\n#endif\n\tfor (i = BUSY_LOOPS; i; i--)\n\t\tif ((inb(SBP(chip, STATUS)) & 0x80) == 0) {\n\t\t\toutb(val, SBP(chip, COMMAND));\n\t\t\treturn 1;\n\t\t}\n\tsnd_printd(\"%s [0x%lx]: timeout (0x%x)\\n\", __func__, chip->port, val);\n\treturn 0;\n}\n\nint snd_sbdsp_get_byte(struct snd_sb *chip)\n{\n\tint val;\n\tint i;\n\tfor (i = BUSY_LOOPS; i; i--) {\n\t\tif (inb(SBP(chip, DATA_AVAIL)) & 0x80) {\n\t\t\tval = inb(SBP(chip, READ));\n#ifdef IO_DEBUG\n\t\t\tsnd_printk(KERN_DEBUG \"get_byte 0x%x\\n\", val);\n#endif\n\t\t\treturn val;\n\t\t}\n\t}\n\tsnd_printd(\"%s [0x%lx]: timeout\\n\", __func__, chip->port);\n\treturn -ENODEV;\n}\n\nint snd_sbdsp_reset(struct snd_sb *chip)\n{\n\tint i;\n\n\toutb(1, SBP(chip, RESET));\n\tudelay(10);\n\toutb(0, SBP(chip, RESET));\n\tudelay(30);\n\tfor (i = BUSY_LOOPS; i; i--)\n\t\tif (inb(SBP(chip, DATA_AVAIL)) & 0x80) {\n\t\t\tif (inb(SBP(chip, READ)) == 0xaa)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tsnd_printdd(\"%s [0x%lx] failed...\\n\", __func__, chip->port);\n\treturn -ENODEV;\n}\n\nstatic int snd_sbdsp_version(struct snd_sb * chip)\n{\n\tunsigned int result;\n\n\tsnd_sbdsp_command(chip, SB_DSP_GET_VERSION);\n\tresult = (short) snd_sbdsp_get_byte(chip) << 8;\n\tresult |= (short) snd_sbdsp_get_byte(chip);\n\treturn result;\n}\n\nstatic int snd_sbdsp_probe(struct snd_sb * chip)\n{\n\tint version;\n\tint major, minor;\n\tchar *str;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (snd_sbdsp_reset(chip) < 0) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tversion = snd_sbdsp_version(chip);\n\tif (version < 0) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tmajor = version >> 8;\n\tminor = version & 0xff;\n\tsnd_printdd(\"SB [0x%lx]: DSP chip found, version = %i.%i\\n\",\n\t\t    chip->port, major, minor);\n\n\tswitch (chip->hardware) {\n\tcase SB_HW_AUTO:\n\t\tswitch (major) {\n\t\tcase 1:\n\t\t\tchip->hardware = SB_HW_10;\n\t\t\tstr = \"1.0\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (minor) {\n\t\t\t\tchip->hardware = SB_HW_201;\n\t\t\t\tstr = \"2.01+\";\n\t\t\t} else {\n\t\t\t\tchip->hardware = SB_HW_20;\n\t\t\t\tstr = \"2.0\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tchip->hardware = SB_HW_PRO;\n\t\t\tstr = \"Pro\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tchip->hardware = SB_HW_16;\n\t\t\tstr = \"16\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_printk(KERN_INFO \"SB [0x%lx]: unknown DSP chip version %i.%i\\n\",\n\t\t\t\t   chip->port, major, minor);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase SB_HW_ALS100:\n\t\tstr = \"16 (ALS-100)\";\n\t\tbreak;\n\tcase SB_HW_ALS4000:\n\t\tstr = \"16 (ALS-4000)\";\n\t\tbreak;\n\tcase SB_HW_DT019X:\n\t\tstr = \"(DT019X/ALS007)\";\n\t\tbreak;\n\tcase SB_HW_CS5530:\n\t\tstr = \"16 (CS5530)\";\n\t\tbreak;\n\tcase SB_HW_JAZZ16:\n\t\tstr = \"Pro (Jazz16)\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tsprintf(chip->name, \"Sound Blaster %s\", str);\n\tchip->version = (major << 8) | minor;\n\treturn 0;\n}\n\nint snd_sbdsp_create(struct snd_card *card,\n\t\t     unsigned long port,\n\t\t     int irq,\n\t\t     irq_handler_t irq_handler,\n\t\t     int dma8,\n\t\t     int dma16,\n\t\t     unsigned short hardware,\n\t\t     struct snd_sb **r_chip)\n{\n\tstruct snd_sb *chip;\n\tint err;\n\n\tif (snd_BUG_ON(!r_chip))\n\t\treturn -EINVAL;\n\t*r_chip = NULL;\n\tchip = devm_kzalloc(card->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->open_lock);\n\tspin_lock_init(&chip->midi_input_lock);\n\tspin_lock_init(&chip->mixer_lock);\n\tchip->irq = -1;\n\tchip->dma8 = -1;\n\tchip->dma16 = -1;\n\tchip->port = port;\n\t\n\tif (devm_request_irq(card->dev, irq, irq_handler,\n\t\t\t     (hardware == SB_HW_ALS4000 ||\n\t\t\t      hardware == SB_HW_CS5530) ?\n\t\t\t     IRQF_SHARED : 0,\n\t\t\t     \"SoundBlaster\", (void *) chip)) {\n\t\tsnd_printk(KERN_ERR \"sb: can't grab irq %d\\n\", irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\n\tif (hardware == SB_HW_ALS4000)\n\t\tgoto __skip_allocation;\n\t\n\tchip->res_port = devm_request_region(card->dev, port, 16,\n\t\t\t\t\t     \"SoundBlaster\");\n\tif (!chip->res_port) {\n\t\tsnd_printk(KERN_ERR \"sb: can't grab port 0x%lx\\n\", port);\n\t\treturn -EBUSY;\n\t}\n\n#ifdef CONFIG_ISA\n\tif (dma8 >= 0 && snd_devm_request_dma(card->dev, dma8,\n\t\t\t\t\t      \"SoundBlaster - 8bit\")) {\n\t\tsnd_printk(KERN_ERR \"sb: can't grab DMA8 %d\\n\", dma8);\n\t\treturn -EBUSY;\n\t}\n\tchip->dma8 = dma8;\n\tif (dma16 >= 0) {\n\t\tif (hardware != SB_HW_ALS100 && (dma16 < 5 || dma16 > 7)) {\n\t\t\t \n\t\t\tdma16 = -1;\n\t\t} else if (snd_devm_request_dma(card->dev, dma16,\n\t\t\t\t\t\t\"SoundBlaster - 16bit\")) {\n\t\t\tsnd_printk(KERN_ERR \"sb: can't grab DMA16 %d\\n\", dma16);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tchip->dma16 = dma16;\n#endif\n\n      __skip_allocation:\n\tchip->card = card;\n\tchip->hardware = hardware;\n\terr = snd_sbdsp_probe(chip);\n\tif (err < 0)\n\t\treturn err;\n\t*r_chip = chip;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_sbdsp_command);\nEXPORT_SYMBOL(snd_sbdsp_get_byte);\nEXPORT_SYMBOL(snd_sbdsp_reset);\nEXPORT_SYMBOL(snd_sbdsp_create);\n \nEXPORT_SYMBOL(snd_sbmixer_write);\nEXPORT_SYMBOL(snd_sbmixer_read);\nEXPORT_SYMBOL(snd_sbmixer_new);\nEXPORT_SYMBOL(snd_sbmixer_add_ctl);\n#ifdef CONFIG_PM\nEXPORT_SYMBOL(snd_sbmixer_suspend);\nEXPORT_SYMBOL(snd_sbmixer_resume);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}