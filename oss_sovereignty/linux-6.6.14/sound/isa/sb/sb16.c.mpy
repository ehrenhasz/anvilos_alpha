{
  "module_name": "sb16.c",
  "hash_id": "ee644f782d9273a0267b41ac11eb5e0242dde85414be3df2751e030274d1715a",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb16.c",
  "human_readable_source": "\n \n\n#include <asm/dma.h>\n#include <linux/init.h>\n#include <linux/pnp.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/sb16_csp.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/emu8000.h>\n#include <sound/seq_device.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\n#ifdef SNDRV_SBAWE\n#define PFX \"sbawe: \"\n#else\n#define PFX \"sb16: \"\n#endif\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_LICENSE(\"GPL\");\n#ifndef SNDRV_SBAWE\nMODULE_DESCRIPTION(\"Sound Blaster 16\");\n#else\nMODULE_DESCRIPTION(\"Sound Blaster AWE\");\n#endif\n\n#if 0\n#define SNDRV_DEBUG_IRQ\n#endif\n\n#if defined(SNDRV_SBAWE) && IS_ENABLED(CONFIG_SND_SEQUENCER)\n#define SNDRV_SBAWE_EMU8000\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;  \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n#ifdef SNDRV_SBAWE_EMU8000\nstatic long awe_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n#endif\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma16[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int mic_agc[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#ifdef CONFIG_SND_SB16_CSP\nstatic int csp[SNDRV_CARDS];\n#endif\n#ifdef SNDRV_SBAWE_EMU8000\nstatic int seq_ports[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4};\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for SoundBlaster 16 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for SoundBlaster 16 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable SoundBlaster 16 soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"PnP detection for specified soundcard.\");\n#endif\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for SB16 driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for SB16 driver.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for SB16 PnP driver.\");\n#ifdef SNDRV_SBAWE_EMU8000\nmodule_param_hw_array(awe_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(awe_port, \"AWE port # for SB16 PnP driver.\");\n#endif\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for SB16 driver.\");\nmodule_param_hw_array(dma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma8, \"8-bit DMA # for SB16 driver.\");\nmodule_param_hw_array(dma16, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma16, \"16-bit DMA # for SB16 driver.\");\nmodule_param_array(mic_agc, int, NULL, 0444);\nMODULE_PARM_DESC(mic_agc, \"Mic Auto-Gain-Control switch.\");\n#ifdef CONFIG_SND_SB16_CSP\nmodule_param_array(csp, int, NULL, 0444);\nMODULE_PARM_DESC(csp, \"ASP/CSP chip support.\");\n#endif\n#ifdef SNDRV_SBAWE_EMU8000\nmodule_param_array(seq_ports, int, NULL, 0444);\nMODULE_PARM_DESC(seq_ports, \"Number of sequencer ports for WaveTable synth.\");\n#endif\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\n#endif\n\nstruct snd_card_sb16 {\n\tstruct resource *fm_res;\t \n\tstruct snd_sb *chip;\n#ifdef CONFIG_PNP\n\tint dev_no;\n\tstruct pnp_dev *dev;\n#ifdef SNDRV_SBAWE_EMU8000\n\tstruct pnp_dev *devwt;\n#endif\n#endif\n};\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_card_device_id snd_sb16_pnpids[] = {\n#ifndef SNDRV_SBAWE\n\t \n\t{ .id = \"CTL0024\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0025\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0026\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0027\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0028\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0029\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL002a\", .devs = { { \"CTL0031\" } } },\n\t \n\t \n\t{ .id = \"CTL002b\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL002c\", .devs = { { \"CTL0031\" } } },\n\t \n\t{ .id = \"CTL0051\", .devs = { { \"CTL0001\" } } },\n\t \n\t{ .id = \"CTL0070\", .devs = { { \"CTL0001\" } } },\n\t \n\t{ .id = \"CTL0080\", .devs = { { \"CTL0041\" } } },\n\t \n\t \n\t{ .id = \"CTL0086\", .devs = { { \"CTL0041\" } } },\n\t \n\t{ .id = \"CTL00f0\", .devs = { { \"CTL0043\" } } },\n\t \n\t{ .id = \"tBA03b0\", .devs = { {.id=\"PNPb003\" } } },\n#else   \n\t \n\t{ .id = \"CTL0035\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0039\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0042\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0043\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t \n\t{ .id = \"CTL0044\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t \n\t{ .id = \"CTL0045\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0046\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0047\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0048\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL0054\", .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL009a\", .devs = { { \"CTL0041\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL009c\", .devs = { { \"CTL0041\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL009f\", .devs = { { \"CTL0041\" }, { \"CTL0021\" } } },\n\t \n\t{ .id = \"CTL009d\", .devs = { { \"CTL0042\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL009e\", .devs = { { \"CTL0044\" }, { \"CTL0023\" } } },\n\t \n\t{ .id = \"CTL00b2\", .devs = { { \"CTL0044\" }, { \"CTL0023\" } } },\n\t \n\t{ .id = \"CTL00c1\", .devs = { { \"CTL0042\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00c3\", .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00c5\", .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00c7\", .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00e4\", .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00e9\", .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n\t \n\t{ .id = \"CTL00ed\", .devs = { { \"CTL0041\" }, { \"CTL0070\" } } },\n\t \n\t{ .id = \"CTLXXXX\" , .devs = { { \"CTL0031\" }, { \"CTL0021\" } } },\n\t{ .id = \"CTLXXXX\" , .devs = { { \"CTL0041\" }, { \"CTL0021\" } } },\n\t{ .id = \"CTLXXXX\" , .devs = { { \"CTL0042\" }, { \"CTL0022\" } } },\n\t{ .id = \"CTLXXXX\" , .devs = { { \"CTL0044\" }, { \"CTL0023\" } } },\n\t{ .id = \"CTLXXXX\" , .devs = { { \"CTL0045\" }, { \"CTL0022\" } } },\n#endif  \n\t{ .id = \"\", }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_sb16_pnpids);\n\n#endif  \n\n#ifdef SNDRV_SBAWE_EMU8000\n#define DRIVER_NAME\t\"snd-card-sbawe\"\n#else\n#define DRIVER_NAME\t\"snd-card-sb16\"\n#endif\n\n#ifdef CONFIG_PNP\n\nstatic int snd_card_sb16_pnp(int dev, struct snd_card_sb16 *acard,\n\t\t\t     struct pnp_card_link *card,\n\t\t\t     const struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\tacard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (acard->dev == NULL)\n\t\treturn -ENODEV; \n\n#ifdef SNDRV_SBAWE_EMU8000\n\tacard->devwt = pnp_request_card_device(card, id->devs[1].id, acard->dev);\n#endif\n\t \n\tpdev = acard->dev;\n\n\terr = pnp_activate_dev(pdev); \n\tif (err < 0) { \n\t\tsnd_printk(KERN_ERR PFX \"AUDIO pnp configure failure\\n\"); \n\t\treturn err; \n\t} \n\tport[dev] = pnp_port_start(pdev, 0);\n\tmpu_port[dev] = pnp_port_start(pdev, 1);\n\tfm_port[dev] = pnp_port_start(pdev, 2);\n\tdma8[dev] = pnp_dma(pdev, 0);\n\tdma16[dev] = pnp_dma(pdev, 1);\n\tirq[dev] = pnp_irq(pdev, 0);\n\tsnd_printdd(\"pnp SB16: port=0x%lx, mpu port=0x%lx, fm port=0x%lx\\n\",\n\t\t\tport[dev], mpu_port[dev], fm_port[dev]);\n\tsnd_printdd(\"pnp SB16: dma1=%i, dma2=%i, irq=%i\\n\",\n\t\t\tdma8[dev], dma16[dev], irq[dev]);\n#ifdef SNDRV_SBAWE_EMU8000\n\t \n\tpdev = acard->devwt;\n\tif (pdev != NULL) {\n\t\terr = pnp_activate_dev(pdev); \n\t\tif (err < 0) { \n\t\t\tgoto __wt_error; \n\t\t} \n\t\tawe_port[dev] = pnp_port_start(pdev, 0);\n\t\tsnd_printdd(\"pnp SB16: wavetable port=0x%llx\\n\",\n\t\t\t\t(unsigned long long)pnp_port_start(pdev, 0));\n\t} else {\n__wt_error:\n\t\tif (pdev) {\n\t\t\tpnp_release_card_device(pdev);\n\t\t\tsnd_printk(KERN_ERR PFX \"WaveTable pnp configure failure\\n\");\n\t\t}\n\t\tacard->devwt = NULL;\n\t\tawe_port[dev] = -1;\n\t}\n#endif\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_PNP\n#define is_isapnp_selected(dev)\t\tisapnp[dev]\n#else\n#define is_isapnp_selected(dev)\t\t0\n#endif\n\nstatic int snd_sb16_card_new(struct device *devptr, int dev,\n\t\t\t     struct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_devm_card_new(devptr, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_card_sb16), &card);\n\tif (err < 0)\n\t\treturn err;\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_sb16_probe(struct snd_card *card, int dev)\n{\n\tint xirq, xdma8, xdma16;\n\tstruct snd_sb *chip;\n\tstruct snd_card_sb16 *acard = card->private_data;\n\tstruct snd_opl3 *opl3;\n\tstruct snd_hwdep *synth = NULL;\n#ifdef CONFIG_SND_SB16_CSP\n\tstruct snd_hwdep *xcsp = NULL;\n#endif\n\tunsigned long flags;\n\tint err;\n\n\txirq = irq[dev];\n\txdma8 = dma8[dev];\n\txdma16 = dma16[dev];\n\n\terr = snd_sbdsp_create(card, port[dev], xirq, snd_sb16dsp_interrupt,\n\t\t\t       xdma8, xdma16, SB_HW_AUTO, &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tacard->chip = chip;\n\tif (chip->hardware != SB_HW_16) {\n\t\tsnd_printk(KERN_ERR PFX \"SB 16 chip was not detected at 0x%lx\\n\", port[dev]);\n\t\treturn -ENODEV;\n\t}\n\tchip->mpu_port = mpu_port[dev];\n\tif (!is_isapnp_selected(dev)) {\n\t\terr = snd_sb16dsp_configure(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_sb16dsp_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver,\n#ifdef SNDRV_SBAWE_EMU8000\n\t\t\tawe_port[dev] > 0 ? \"SB AWE\" :\n#endif\n\t\t\t\"SB16\");\n\tstrcpy(card->shortname, chip->name);\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i, dma \",\n\t\tchip->name,\n\t\tchip->port,\n\t\txirq);\n\tif (xdma8 >= 0)\n\t\tsprintf(card->longname + strlen(card->longname), \"%d\", xdma8);\n\tif (xdma16 >= 0)\n\t\tsprintf(card->longname + strlen(card->longname), \"%s%d\",\n\t\t\txdma8 >= 0 ? \"&\" : \"\", xdma16);\n\n\tif (chip->mpu_port > 0 && chip->mpu_port != SNDRV_AUTO_PORT) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_SB,\n\t\t\t\t\t  chip->mpu_port,\n\t\t\t\t\t  MPU401_INFO_IRQ_HOOK, -1,\n\t\t\t\t\t  &chip->rmidi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->rmidi_callback = snd_mpu401_uart_interrupt;\n\t}\n\n#ifdef SNDRV_SBAWE_EMU8000\n\tif (awe_port[dev] == SNDRV_AUTO_PORT)\n\t\tawe_port[dev] = 0;  \n#endif\n\n\tif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\n\t\tif (snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\n\t\t\t\t    OPL3_HW_OPL3,\n\t\t\t\t    acard->fm_res != NULL || fm_port[dev] == port[dev],\n\t\t\t\t    &opl3) < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"no OPL device at 0x%lx-0x%lx\\n\",\n\t\t\t\t   fm_port[dev], fm_port[dev] + 2);\n\t\t} else {\n#ifdef SNDRV_SBAWE_EMU8000\n\t\t\tint seqdev = awe_port[dev] > 0 ? 2 : 1;\n#else\n\t\t\tint seqdev = 1;\n#endif\n\t\t\terr = snd_opl3_hwdep_new(opl3, 0, seqdev, &synth);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = snd_sbmixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CONFIG_SND_SB16_CSP\n\t \n\tif ((chip->hardware == SB_HW_16) && csp[dev]) {\n\t\tsnd_sb_csp_new(chip, synth != NULL ? 1 : 0, &xcsp);\n\t\tif (xcsp) {\n\t\t\tchip->csp = xcsp->private_data;\n\t\t\tchip->hardware = SB_HW_16CSP;\n\t\t} else {\n\t\t\tsnd_printk(KERN_INFO PFX \"warning - CSP chip not detected on soundcard #%i\\n\", dev + 1);\n\t\t}\n\t}\n#endif\n#ifdef SNDRV_SBAWE_EMU8000\n\tif (awe_port[dev] > 0) {\n\t\terr = snd_emu8000_new(card, 1, awe_port[dev],\n\t\t\t\t      seq_ports[dev], NULL);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"fatal error - EMU-8000 synthesizer not detected at 0x%lx\\n\", awe_port[dev]);\n\n\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\n\t \n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\tsnd_sbmixer_write(chip, SB_DSP4_MIC_AGC,\n\t\t(snd_sbmixer_read(chip, SB_DSP4_MIC_AGC) & 0x01) |\n\t\t(mic_agc[dev] ? 0x00 : 0x01));\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_sb16_suspend(struct snd_card *card, pm_message_t state)\n{\n\tstruct snd_card_sb16 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_sbmixer_suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_sb16_resume(struct snd_card *card)\n{\n\tstruct snd_card_sb16 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_sbdsp_reset(chip);\n\tsnd_sbmixer_resume(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic int snd_sb16_isa_probe1(int dev, struct device *pdev)\n{\n\tstruct snd_card_sb16 *acard;\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_sb16_card_new(pdev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tacard = card->private_data;\n\t \n\tfm_port[dev] = port[dev];\n\t \n\tacard->fm_res = devm_request_region(card->dev, 0x388, 4,\n\t\t\t\t\t    \"SoundBlaster FM\");\n#ifdef SNDRV_SBAWE_EMU8000\n\t \n\tawe_port[dev] = port[dev] + 0x400;\n#endif\n\n\terr = snd_sb16_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n\nstatic int snd_sb16_isa_match(struct device *pdev, unsigned int dev)\n{\n\treturn enable[dev] && !is_isapnp_selected(dev);\n}\n\nstatic int snd_sb16_isa_probe(struct device *pdev, unsigned int dev)\n{\n\tint err;\n\tstatic const int possible_irqs[] = {5, 9, 10, 7, -1};\n\tstatic const int possible_dmas8[] = {1, 3, 0, -1};\n\tstatic const int possible_dmas16[] = {5, 6, 7, -1};\n\n\tif (irq[dev] == SNDRV_AUTO_IRQ) {\n\t\tirq[dev] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma8[dev] == SNDRV_AUTO_DMA) {\n\t\tdma8[dev] = snd_legacy_find_free_dma(possible_dmas8);\n\t\tif (dma8[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free 8-bit DMA\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma16[dev] == SNDRV_AUTO_DMA) {\n\t\tdma16[dev] = snd_legacy_find_free_dma(possible_dmas16);\n\t\tif (dma16[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free 16-bit DMA\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (port[dev] != SNDRV_AUTO_PORT)\n\t\treturn snd_sb16_isa_probe1(dev, pdev);\n\telse {\n\t\tstatic const int possible_ports[] = {0x220, 0x240, 0x260, 0x280};\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\n\t\t\tport[dev] = possible_ports[i];\n\t\t\terr = snd_sb16_isa_probe1(dev, pdev);\n\t\t\tif (! err)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int snd_sb16_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\tpm_message_t state)\n{\n\treturn snd_sb16_suspend(dev_get_drvdata(dev), state);\n}\n\nstatic int snd_sb16_isa_resume(struct device *dev, unsigned int n)\n{\n\treturn snd_sb16_resume(dev_get_drvdata(dev));\n}\n#endif\n\n#ifdef SNDRV_SBAWE\n#define DEV_NAME \"sbawe\"\n#else\n#define DEV_NAME \"sb16\"\n#endif\n\nstatic struct isa_driver snd_sb16_isa_driver = {\n\t.match\t\t= snd_sb16_isa_match,\n\t.probe\t\t= snd_sb16_isa_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_sb16_isa_suspend,\n\t.resume\t\t= snd_sb16_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n\n#ifdef CONFIG_PNP\nstatic int snd_sb16_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t       const struct pnp_card_device_id *pid)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (!enable[dev] || !isapnp[dev])\n\t\t\tcontinue;\n\t\tres = snd_sb16_card_new(&pcard->card->dev, dev, &card);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tres = snd_card_sb16_pnp(dev, card->private_data, pcard, pid);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tres = snd_sb16_probe(card, dev);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tpnp_set_card_drvdata(pcard, card);\n\t\tdev++;\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_sb16_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\n{\n\treturn snd_sb16_suspend(pnp_get_card_drvdata(pcard), state);\n}\nstatic int snd_sb16_pnp_resume(struct pnp_card_link *pcard)\n{\n\treturn snd_sb16_resume(pnp_get_card_drvdata(pcard));\n}\n#endif\n\nstatic struct pnp_card_driver sb16_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DISABLE,\n#ifdef SNDRV_SBAWE\n\t.name = \"sbawe\",\n#else\n\t.name = \"sb16\",\n#endif\n\t.id_table = snd_sb16_pnpids,\n\t.probe = snd_sb16_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend = snd_sb16_pnp_suspend,\n\t.resume = snd_sb16_pnp_resume,\n#endif\n};\n\n#endif  \n\nstatic int __init alsa_card_sb16_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_sb16_isa_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&sb16_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_sb16_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&sb16_pnpc_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_sb16_isa_driver);\n}\n\nmodule_init(alsa_card_sb16_init)\nmodule_exit(alsa_card_sb16_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}