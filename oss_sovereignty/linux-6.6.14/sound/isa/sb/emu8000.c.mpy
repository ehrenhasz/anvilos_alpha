{
  "module_name": "emu8000.c",
  "hash_id": "3028aa1684c0cfe7c74742d3e35c11943b292e9781c15cfa64183e9943891267",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/emu8000.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/emu8000.h>\n#include <sound/emu8000_reg.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n\n \n\n \n \nvoid snd_emu8000_poke(struct snd_emu8000 *emu, unsigned int port, unsigned int reg, unsigned int val)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&emu->reg_lock, flags);\n\tif (reg != emu->last_reg) {\n\t\toutw((unsigned short)reg, EMU8000_PTR(emu));  \n\t\temu->last_reg = reg;\n\t}\n\toutw((unsigned short)val, port);  \n\tspin_unlock_irqrestore(&emu->reg_lock, flags);\n}\n\n \nunsigned short snd_emu8000_peek(struct snd_emu8000 *emu, unsigned int port, unsigned int reg)\n{\n\tunsigned short res;\n\tunsigned long flags;\n\tspin_lock_irqsave(&emu->reg_lock, flags);\n\tif (reg != emu->last_reg) {\n\t\toutw((unsigned short)reg, EMU8000_PTR(emu));  \n\t\temu->last_reg = reg;\n\t}\n\tres = inw(port);\t \n\tspin_unlock_irqrestore(&emu->reg_lock, flags);\n\treturn res;\n}\n\n \nvoid snd_emu8000_poke_dw(struct snd_emu8000 *emu, unsigned int port, unsigned int reg, unsigned int val)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&emu->reg_lock, flags);\n\tif (reg != emu->last_reg) {\n\t\toutw((unsigned short)reg, EMU8000_PTR(emu));  \n\t\temu->last_reg = reg;\n\t}\n\toutw((unsigned short)val, port);  \n\toutw((unsigned short)(val>>16), port+2);  \n\tspin_unlock_irqrestore(&emu->reg_lock, flags);\n}\n\n \nunsigned int snd_emu8000_peek_dw(struct snd_emu8000 *emu, unsigned int port, unsigned int reg)\n{\n\tunsigned short low;\n\tunsigned int res;\n\tunsigned long flags;\n\tspin_lock_irqsave(&emu->reg_lock, flags);\n\tif (reg != emu->last_reg) {\n\t\toutw((unsigned short)reg, EMU8000_PTR(emu));  \n\t\temu->last_reg = reg;\n\t}\n\tlow = inw(port);\t \n\tres = low + (inw(port+2) << 16);\n\tspin_unlock_irqrestore(&emu->reg_lock, flags);\n\treturn res;\n}\n\n \n  void\nsnd_emu8000_dma_chan(struct snd_emu8000 *emu, int ch, int mode)\n{\n\tunsigned right_bit = (mode & EMU8000_RAM_RIGHT) ? 0x01000000 : 0;\n\tmode &= EMU8000_RAM_MODE_MASK;\n\tif (mode == EMU8000_RAM_CLOSE) {\n\t\tEMU8000_CCCA_WRITE(emu, ch, 0);\n\t\tEMU8000_DCYSUSV_WRITE(emu, ch, 0x807F);\n\t\treturn;\n\t}\n\tEMU8000_DCYSUSV_WRITE(emu, ch, 0x80);\n\tEMU8000_VTFT_WRITE(emu, ch, 0);\n\tEMU8000_CVCF_WRITE(emu, ch, 0);\n\tEMU8000_PTRX_WRITE(emu, ch, 0x40000000);\n\tEMU8000_CPF_WRITE(emu, ch, 0x40000000);\n\tEMU8000_PSST_WRITE(emu, ch, 0);\n\tEMU8000_CSL_WRITE(emu, ch, 0);\n\tif (mode == EMU8000_RAM_WRITE)  \n\t\tEMU8000_CCCA_WRITE(emu, ch, 0x06000000 | right_bit);\n\telse\t    \n\t\tEMU8000_CCCA_WRITE(emu, ch, 0x04000000 | right_bit);\n}\n\n \nstatic void\nsnd_emu8000_read_wait(struct snd_emu8000 *emu)\n{\n\twhile ((EMU8000_SMALR_READ(emu) & 0x80000000) != 0) {\n\t\tschedule_timeout_interruptible(1);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void\nsnd_emu8000_write_wait(struct snd_emu8000 *emu)\n{\n\twhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\n\t\tschedule_timeout_interruptible(1);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int\nsnd_emu8000_detect(struct snd_emu8000 *emu)\n{\n\t \n\tEMU8000_HWCF1_WRITE(emu, 0x0059);\n\tEMU8000_HWCF2_WRITE(emu, 0x0020);\n\tEMU8000_HWCF3_WRITE(emu, 0x0000);\n\t \n\t \n\tif ((EMU8000_HWCF1_READ(emu) & 0x007e) != 0x0058)\n\t\treturn -ENODEV;\n\tif ((EMU8000_HWCF2_READ(emu) & 0x0003) != 0x0003)\n\t\treturn -ENODEV;\n\n\tsnd_printdd(\"EMU8000 [0x%lx]: Synth chip found\\n\",\n                    emu->port1);\n\treturn 0;\n}\n\n\n \nstatic void\ninit_audio(struct snd_emu8000 *emu)\n{\n\tint ch;\n\n\t \n\tfor (ch = 0; ch < EMU8000_CHANNELS; ch++)\n\t\tEMU8000_DCYSUSV_WRITE(emu, ch, 0x80);\n  \n\t \n\tfor (ch = 0; ch < EMU8000_CHANNELS; ch++) {\n\t\tEMU8000_ENVVOL_WRITE(emu, ch, 0);\n\t\tEMU8000_ENVVAL_WRITE(emu, ch, 0);\n\t\tEMU8000_DCYSUS_WRITE(emu, ch, 0);\n\t\tEMU8000_ATKHLDV_WRITE(emu, ch, 0);\n\t\tEMU8000_LFO1VAL_WRITE(emu, ch, 0);\n\t\tEMU8000_ATKHLD_WRITE(emu, ch, 0);\n\t\tEMU8000_LFO2VAL_WRITE(emu, ch, 0);\n\t\tEMU8000_IP_WRITE(emu, ch, 0);\n\t\tEMU8000_IFATN_WRITE(emu, ch, 0);\n\t\tEMU8000_PEFE_WRITE(emu, ch, 0);\n\t\tEMU8000_FMMOD_WRITE(emu, ch, 0);\n\t\tEMU8000_TREMFRQ_WRITE(emu, ch, 0);\n\t\tEMU8000_FM2FRQ2_WRITE(emu, ch, 0);\n\t\tEMU8000_PTRX_WRITE(emu, ch, 0);\n\t\tEMU8000_VTFT_WRITE(emu, ch, 0);\n\t\tEMU8000_PSST_WRITE(emu, ch, 0);\n\t\tEMU8000_CSL_WRITE(emu, ch, 0);\n\t\tEMU8000_CCCA_WRITE(emu, ch, 0);\n\t}\n\n\tfor (ch = 0; ch < EMU8000_CHANNELS; ch++) {\n\t\tEMU8000_CPF_WRITE(emu, ch, 0);\n\t\tEMU8000_CVCF_WRITE(emu, ch, 0);\n\t}\n}\n\n\n \nstatic void\ninit_dma(struct snd_emu8000 *emu)\n{\n\tEMU8000_SMALR_WRITE(emu, 0);\n\tEMU8000_SMARR_WRITE(emu, 0);\n\tEMU8000_SMALW_WRITE(emu, 0);\n\tEMU8000_SMARW_WRITE(emu, 0);\n}\n\n \nstatic const unsigned short init1[128] = {\n\t0x03ff, 0x0030,  0x07ff, 0x0130, 0x0bff, 0x0230,  0x0fff, 0x0330,\n\t0x13ff, 0x0430,  0x17ff, 0x0530, 0x1bff, 0x0630,  0x1fff, 0x0730,\n\t0x23ff, 0x0830,  0x27ff, 0x0930, 0x2bff, 0x0a30,  0x2fff, 0x0b30,\n\t0x33ff, 0x0c30,  0x37ff, 0x0d30, 0x3bff, 0x0e30,  0x3fff, 0x0f30,\n\n\t0x43ff, 0x0030,  0x47ff, 0x0130, 0x4bff, 0x0230,  0x4fff, 0x0330,\n\t0x53ff, 0x0430,  0x57ff, 0x0530, 0x5bff, 0x0630,  0x5fff, 0x0730,\n\t0x63ff, 0x0830,  0x67ff, 0x0930, 0x6bff, 0x0a30,  0x6fff, 0x0b30,\n\t0x73ff, 0x0c30,  0x77ff, 0x0d30, 0x7bff, 0x0e30,  0x7fff, 0x0f30,\n\n\t0x83ff, 0x0030,  0x87ff, 0x0130, 0x8bff, 0x0230,  0x8fff, 0x0330,\n\t0x93ff, 0x0430,  0x97ff, 0x0530, 0x9bff, 0x0630,  0x9fff, 0x0730,\n\t0xa3ff, 0x0830,  0xa7ff, 0x0930, 0xabff, 0x0a30,  0xafff, 0x0b30,\n\t0xb3ff, 0x0c30,  0xb7ff, 0x0d30, 0xbbff, 0x0e30,  0xbfff, 0x0f30,\n\n\t0xc3ff, 0x0030,  0xc7ff, 0x0130, 0xcbff, 0x0230,  0xcfff, 0x0330,\n\t0xd3ff, 0x0430,  0xd7ff, 0x0530, 0xdbff, 0x0630,  0xdfff, 0x0730,\n\t0xe3ff, 0x0830,  0xe7ff, 0x0930, 0xebff, 0x0a30,  0xefff, 0x0b30,\n\t0xf3ff, 0x0c30,  0xf7ff, 0x0d30, 0xfbff, 0x0e30,  0xffff, 0x0f30,\n};\n\nstatic const unsigned short init2[128] = {\n\t0x03ff, 0x8030, 0x07ff, 0x8130, 0x0bff, 0x8230, 0x0fff, 0x8330,\n\t0x13ff, 0x8430, 0x17ff, 0x8530, 0x1bff, 0x8630, 0x1fff, 0x8730,\n\t0x23ff, 0x8830, 0x27ff, 0x8930, 0x2bff, 0x8a30, 0x2fff, 0x8b30,\n\t0x33ff, 0x8c30, 0x37ff, 0x8d30, 0x3bff, 0x8e30, 0x3fff, 0x8f30,\n\n\t0x43ff, 0x8030, 0x47ff, 0x8130, 0x4bff, 0x8230, 0x4fff, 0x8330,\n\t0x53ff, 0x8430, 0x57ff, 0x8530, 0x5bff, 0x8630, 0x5fff, 0x8730,\n\t0x63ff, 0x8830, 0x67ff, 0x8930, 0x6bff, 0x8a30, 0x6fff, 0x8b30,\n\t0x73ff, 0x8c30, 0x77ff, 0x8d30, 0x7bff, 0x8e30, 0x7fff, 0x8f30,\n\n\t0x83ff, 0x8030, 0x87ff, 0x8130, 0x8bff, 0x8230, 0x8fff, 0x8330,\n\t0x93ff, 0x8430, 0x97ff, 0x8530, 0x9bff, 0x8630, 0x9fff, 0x8730,\n\t0xa3ff, 0x8830, 0xa7ff, 0x8930, 0xabff, 0x8a30, 0xafff, 0x8b30,\n\t0xb3ff, 0x8c30, 0xb7ff, 0x8d30, 0xbbff, 0x8e30, 0xbfff, 0x8f30,\n\n\t0xc3ff, 0x8030, 0xc7ff, 0x8130, 0xcbff, 0x8230, 0xcfff, 0x8330,\n\t0xd3ff, 0x8430, 0xd7ff, 0x8530, 0xdbff, 0x8630, 0xdfff, 0x8730,\n\t0xe3ff, 0x8830, 0xe7ff, 0x8930, 0xebff, 0x8a30, 0xefff, 0x8b30,\n\t0xf3ff, 0x8c30, 0xf7ff, 0x8d30, 0xfbff, 0x8e30, 0xffff, 0x8f30,\n};\n\nstatic const unsigned short init3[128] = {\n\t0x0C10, 0x8470, 0x14FE, 0xB488, 0x167F, 0xA470, 0x18E7, 0x84B5,\n\t0x1B6E, 0x842A, 0x1F1D, 0x852A, 0x0DA3, 0x8F7C, 0x167E, 0xF254,\n\t0x0000, 0x842A, 0x0001, 0x852A, 0x18E6, 0x8BAA, 0x1B6D, 0xF234,\n\t0x229F, 0x8429, 0x2746, 0x8529, 0x1F1C, 0x86E7, 0x229E, 0xF224,\n\n\t0x0DA4, 0x8429, 0x2C29, 0x8529, 0x2745, 0x87F6, 0x2C28, 0xF254,\n\t0x383B, 0x8428, 0x320F, 0x8528, 0x320E, 0x8F02, 0x1341, 0xF264,\n\t0x3EB6, 0x8428, 0x3EB9, 0x8528, 0x383A, 0x8FA9, 0x3EB5, 0xF294,\n\t0x3EB7, 0x8474, 0x3EBA, 0x8575, 0x3EB8, 0xC4C3, 0x3EBB, 0xC5C3,\n\n\t0x0000, 0xA404, 0x0001, 0xA504, 0x141F, 0x8671, 0x14FD, 0x8287,\n\t0x3EBC, 0xE610, 0x3EC8, 0x8C7B, 0x031A, 0x87E6, 0x3EC8, 0x86F7,\n\t0x3EC0, 0x821E, 0x3EBE, 0xD208, 0x3EBD, 0x821F, 0x3ECA, 0x8386,\n\t0x3EC1, 0x8C03, 0x3EC9, 0x831E, 0x3ECA, 0x8C4C, 0x3EBF, 0x8C55,\n\n\t0x3EC9, 0xC208, 0x3EC4, 0xBC84, 0x3EC8, 0x8EAD, 0x3EC8, 0xD308,\n\t0x3EC2, 0x8F7E, 0x3ECB, 0x8219, 0x3ECB, 0xD26E, 0x3EC5, 0x831F,\n\t0x3EC6, 0xC308, 0x3EC3, 0xB2FF, 0x3EC9, 0x8265, 0x3EC9, 0x8319,\n\t0x1342, 0xD36E, 0x3EC7, 0xB3FF, 0x0000, 0x8365, 0x1420, 0x9570,\n};\n\nstatic const unsigned short init4[128] = {\n\t0x0C10, 0x8470, 0x14FE, 0xB488, 0x167F, 0xA470, 0x18E7, 0x84B5,\n\t0x1B6E, 0x842A, 0x1F1D, 0x852A, 0x0DA3, 0x0F7C, 0x167E, 0x7254,\n\t0x0000, 0x842A, 0x0001, 0x852A, 0x18E6, 0x0BAA, 0x1B6D, 0x7234,\n\t0x229F, 0x8429, 0x2746, 0x8529, 0x1F1C, 0x06E7, 0x229E, 0x7224,\n\n\t0x0DA4, 0x8429, 0x2C29, 0x8529, 0x2745, 0x07F6, 0x2C28, 0x7254,\n\t0x383B, 0x8428, 0x320F, 0x8528, 0x320E, 0x0F02, 0x1341, 0x7264,\n\t0x3EB6, 0x8428, 0x3EB9, 0x8528, 0x383A, 0x0FA9, 0x3EB5, 0x7294,\n\t0x3EB7, 0x8474, 0x3EBA, 0x8575, 0x3EB8, 0x44C3, 0x3EBB, 0x45C3,\n\n\t0x0000, 0xA404, 0x0001, 0xA504, 0x141F, 0x0671, 0x14FD, 0x0287,\n\t0x3EBC, 0xE610, 0x3EC8, 0x0C7B, 0x031A, 0x07E6, 0x3EC8, 0x86F7,\n\t0x3EC0, 0x821E, 0x3EBE, 0xD208, 0x3EBD, 0x021F, 0x3ECA, 0x0386,\n\t0x3EC1, 0x0C03, 0x3EC9, 0x031E, 0x3ECA, 0x8C4C, 0x3EBF, 0x0C55,\n\n\t0x3EC9, 0xC208, 0x3EC4, 0xBC84, 0x3EC8, 0x0EAD, 0x3EC8, 0xD308,\n\t0x3EC2, 0x8F7E, 0x3ECB, 0x0219, 0x3ECB, 0xD26E, 0x3EC5, 0x031F,\n\t0x3EC6, 0xC308, 0x3EC3, 0x32FF, 0x3EC9, 0x0265, 0x3EC9, 0x8319,\n\t0x1342, 0xD36E, 0x3EC7, 0x33FF, 0x0000, 0x8365, 0x1420, 0x9570,\n};\n\n \nstatic void\nsend_array(struct snd_emu8000 *emu, const unsigned short *data, int size)\n{\n\tint i;\n\tconst unsigned short *p;\n\n\tp = data;\n\tfor (i = 0; i < size; i++, p++)\n\t\tEMU8000_INIT1_WRITE(emu, i, *p);\n\tfor (i = 0; i < size; i++, p++)\n\t\tEMU8000_INIT2_WRITE(emu, i, *p);\n\tfor (i = 0; i < size; i++, p++)\n\t\tEMU8000_INIT3_WRITE(emu, i, *p);\n\tfor (i = 0; i < size; i++, p++)\n\t\tEMU8000_INIT4_WRITE(emu, i, *p);\n}\n\n\n \nstatic void\ninit_arrays(struct snd_emu8000 *emu)\n{\n\tsend_array(emu, init1, ARRAY_SIZE(init1)/4);\n\n\tmsleep((1024 * 1000) / 44100);  \n\tsend_array(emu, init2, ARRAY_SIZE(init2)/4);\n\tsend_array(emu, init3, ARRAY_SIZE(init3)/4);\n\n\tEMU8000_HWCF4_WRITE(emu, 0);\n\tEMU8000_HWCF5_WRITE(emu, 0x83);\n\tEMU8000_HWCF6_WRITE(emu, 0x8000);\n\n\tsend_array(emu, init4, ARRAY_SIZE(init4)/4);\n}\n\n\n#define UNIQUE_ID1\t0xa5b9\n#define UNIQUE_ID2\t0x9d53\n\n \nstatic void\nsize_dram(struct snd_emu8000 *emu)\n{\n\tint i, size;\n\n\tif (emu->dram_checked)\n\t\treturn;\n\n\tsize = 0;\n\n\t \n\tsnd_emu8000_dma_chan(emu, 0, EMU8000_RAM_WRITE);\n\tsnd_emu8000_dma_chan(emu, 1, EMU8000_RAM_READ);\n\tEMU8000_SMALW_WRITE(emu, EMU8000_DRAM_OFFSET);\n\tEMU8000_SMLD_WRITE(emu, UNIQUE_ID1);\n\tsnd_emu8000_init_fm(emu);  \n\tsnd_emu8000_write_wait(emu);\n\n\t \n\tEMU8000_SMALR_WRITE(emu, EMU8000_DRAM_OFFSET);\n\tEMU8000_SMLD_READ(emu);  \n\tif (EMU8000_SMLD_READ(emu) != UNIQUE_ID1)\n\t\tgoto skip_detect;    \n\tsnd_emu8000_read_wait(emu);\n\n\tfor (size = 512 * 1024; size < EMU8000_MAX_DRAM; size += 512 * 1024) {\n\n\t\t \n\t\t \n\t\tEMU8000_SMALW_WRITE(emu, EMU8000_DRAM_OFFSET + (size>>1));\n\t\tEMU8000_SMLD_WRITE(emu, UNIQUE_ID2);\n\t\tsnd_emu8000_write_wait(emu);\n\n\t\t \n\t\t \n\t\tEMU8000_SMALR_WRITE(emu, EMU8000_DRAM_OFFSET + (size>>1));\n\t\t \n\t\tEMU8000_SMLD_READ(emu);  \n\t\tif (EMU8000_SMLD_READ(emu) != UNIQUE_ID2)\n\t\t\tbreak;  \n\t\tsnd_emu8000_read_wait(emu);\n\n\t\t \n\t\tEMU8000_SMALR_WRITE(emu, EMU8000_DRAM_OFFSET);\n\t\tEMU8000_SMLD_READ(emu);  \n\t\tif (EMU8000_SMLD_READ(emu) != UNIQUE_ID1)\n\t\t\tbreak;  \n\t\tsnd_emu8000_read_wait(emu);\n\n\t\t \n\t}\n\nskip_detect:\n\t \n\tfor (i = 0; i < 10000; i++) {\n\t\tif ((EMU8000_SMALW_READ(emu) & 0x80000000) == 0)\n\t\t\tbreak;\n\t\tschedule_timeout_interruptible(1);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\tsnd_emu8000_dma_chan(emu, 0, EMU8000_RAM_CLOSE);\n\tsnd_emu8000_dma_chan(emu, 1, EMU8000_RAM_CLOSE);\n\n\tpr_info(\"EMU8000 [0x%lx]: %d KiB on-board DRAM detected\\n\",\n\t\t    emu->port1, size/1024);\n\n\temu->mem_size = size;\n\temu->dram_checked = 1;\n}\n\n\n \n  void\nsnd_emu8000_init_fm(struct snd_emu8000 *emu)\n{\n\tunsigned long flags;\n\n\t \n\n\t \n\tEMU8000_DCYSUSV_WRITE(emu, 30, 0x80);\n\tEMU8000_PSST_WRITE(emu, 30, 0xFFFFFFE0);  \n\tEMU8000_CSL_WRITE(emu, 30, 0x00FFFFE8 | (emu->fm_chorus_depth << 24));\n\tEMU8000_PTRX_WRITE(emu, 30, (emu->fm_reverb_depth << 8));\n\tEMU8000_CPF_WRITE(emu, 30, 0);\n\tEMU8000_CCCA_WRITE(emu, 30, 0x00FFFFE3);\n\n\t \n\tEMU8000_DCYSUSV_WRITE(emu, 31, 0x80);\n\tEMU8000_PSST_WRITE(emu, 31, 0x00FFFFF0);  \n\tEMU8000_CSL_WRITE(emu, 31, 0x00FFFFF8 | (emu->fm_chorus_depth << 24));\n\tEMU8000_PTRX_WRITE(emu, 31, (emu->fm_reverb_depth << 8));\n\tEMU8000_CPF_WRITE(emu, 31, 0x8000);\n\tEMU8000_CCCA_WRITE(emu, 31, 0x00FFFFF3);\n\n\tsnd_emu8000_poke((emu), EMU8000_DATA0(emu), EMU8000_CMD(1, (30)), 0);\n\n\tspin_lock_irqsave(&emu->reg_lock, flags);\n\twhile (!(inw(EMU8000_PTR(emu)) & 0x1000))\n\t\t;\n\twhile ((inw(EMU8000_PTR(emu)) & 0x1000))\n\t\t;\n\tspin_unlock_irqrestore(&emu->reg_lock, flags);\n\tsnd_emu8000_poke((emu), EMU8000_DATA0(emu), EMU8000_CMD(1, (30)), 0x4828);\n\t \n\toutb(0x3C, EMU8000_PTR(emu));\n\toutb(0, EMU8000_DATA1(emu));\n\n\t \n\tEMU8000_VTFT_WRITE(emu, 30, 0x8000FFFF);\n\tEMU8000_VTFT_WRITE(emu, 31, 0x8000FFFF);\n}\n\n\n \nstatic void\nsnd_emu8000_init_hw(struct snd_emu8000 *emu)\n{\n\tint i;\n\n\temu->last_reg = 0xffff;  \n\n\t \n\tEMU8000_HWCF1_WRITE(emu, 0x0059);\n\tEMU8000_HWCF2_WRITE(emu, 0x0020);\n\n\t \n\tEMU8000_HWCF3_WRITE(emu, 0);\n\n\t \n\tinit_audio(emu);\n\n\t \n\tinit_dma(emu);\n\n\t \n\tinit_arrays(emu);\n\n\t \n\tsnd_emu8000_init_fm(emu);\n\n\t \n\tfor (i = 0; i < EMU8000_DRAM_VOICES; i++)\n\t\tEMU8000_DCYSUSV_WRITE(emu, 0, 0x807F);\n\t\n\t \n\tsize_dram(emu);\n\n\t \n\tEMU8000_HWCF3_WRITE(emu, 0x4);\n\n\t \n\tsnd_emu8000_update_equalizer(emu);\n\tsnd_emu8000_update_chorus_mode(emu);\n\tsnd_emu8000_update_reverb_mode(emu);\n}\n\n\n \n\nstatic const unsigned short bass_parm[12][3] = {\n\t{0xD26A, 0xD36A, 0x0000},  \n\t{0xD25B, 0xD35B, 0x0000},  \n\t{0xD24C, 0xD34C, 0x0000},  \n\t{0xD23D, 0xD33D, 0x0000},  \n\t{0xD21F, 0xD31F, 0x0000},  \n\t{0xC208, 0xC308, 0x0001},  \n\t{0xC219, 0xC319, 0x0001},  \n\t{0xC22A, 0xC32A, 0x0001},  \n\t{0xC24C, 0xC34C, 0x0001},  \n\t{0xC26E, 0xC36E, 0x0001},  \n\t{0xC248, 0xC384, 0x0002},  \n\t{0xC26A, 0xC36A, 0x0002},  \n};\n\nstatic const unsigned short treble_parm[12][9] = {\n\t{0x821E, 0xC26A, 0x031E, 0xC36A, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},  \n\t{0x821E, 0xC25B, 0x031E, 0xC35B, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},\n\t{0x821E, 0xC24C, 0x031E, 0xC34C, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},\n\t{0x821E, 0xC23D, 0x031E, 0xC33D, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},\n\t{0x821E, 0xC21F, 0x031E, 0xC31F, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},\n\t{0x821E, 0xD208, 0x031E, 0xD308, 0x021E, 0xD208, 0x831E, 0xD308, 0x0002},\n\t{0x821E, 0xD208, 0x031E, 0xD308, 0x021D, 0xD219, 0x831D, 0xD319, 0x0002},\n\t{0x821E, 0xD208, 0x031E, 0xD308, 0x021C, 0xD22A, 0x831C, 0xD32A, 0x0002},\n\t{0x821E, 0xD208, 0x031E, 0xD308, 0x021A, 0xD24C, 0x831A, 0xD34C, 0x0002},\n\t{0x821E, 0xD208, 0x031E, 0xD308, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002},  \n\t{0x821D, 0xD219, 0x031D, 0xD319, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002},\n\t{0x821C, 0xD22A, 0x031C, 0xD32A, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002}   \n};\n\n\n \n  void\nsnd_emu8000_update_equalizer(struct snd_emu8000 *emu)\n{\n\tunsigned short w;\n\tint bass = emu->bass_level;\n\tint treble = emu->treble_level;\n\n\tif (bass < 0 || bass > 11 || treble < 0 || treble > 11)\n\t\treturn;\n\tEMU8000_INIT4_WRITE(emu, 0x01, bass_parm[bass][0]);\n\tEMU8000_INIT4_WRITE(emu, 0x11, bass_parm[bass][1]);\n\tEMU8000_INIT3_WRITE(emu, 0x11, treble_parm[treble][0]);\n\tEMU8000_INIT3_WRITE(emu, 0x13, treble_parm[treble][1]);\n\tEMU8000_INIT3_WRITE(emu, 0x1b, treble_parm[treble][2]);\n\tEMU8000_INIT4_WRITE(emu, 0x07, treble_parm[treble][3]);\n\tEMU8000_INIT4_WRITE(emu, 0x0b, treble_parm[treble][4]);\n\tEMU8000_INIT4_WRITE(emu, 0x0d, treble_parm[treble][5]);\n\tEMU8000_INIT4_WRITE(emu, 0x17, treble_parm[treble][6]);\n\tEMU8000_INIT4_WRITE(emu, 0x19, treble_parm[treble][7]);\n\tw = bass_parm[bass][2] + treble_parm[treble][8];\n\tEMU8000_INIT4_WRITE(emu, 0x15, (unsigned short)(w + 0x0262));\n\tEMU8000_INIT4_WRITE(emu, 0x1d, (unsigned short)(w + 0x8362));\n}\n\n\n \n\n \n#define SNDRV_EMU8000_CHORUS_1\t\t0\n#define\tSNDRV_EMU8000_CHORUS_2\t\t1\n#define\tSNDRV_EMU8000_CHORUS_3\t\t2\n#define\tSNDRV_EMU8000_CHORUS_4\t\t3\n#define\tSNDRV_EMU8000_CHORUS_FEEDBACK\t4\n#define\tSNDRV_EMU8000_CHORUS_FLANGER\t5\n#define\tSNDRV_EMU8000_CHORUS_SHORTDELAY\t6\n#define\tSNDRV_EMU8000_CHORUS_SHORTDELAY2\t7\n#define SNDRV_EMU8000_CHORUS_PREDEFINED\t8\n \n#define SNDRV_EMU8000_CHORUS_NUMBERS\t32\n\nstruct soundfont_chorus_fx {\n\tunsigned short feedback;\t \n\tunsigned short delay_offset;\t \n\tunsigned short lfo_depth;\t \n\tunsigned int delay;\t \n\tunsigned int lfo_freq;\t\t \n};\n\n \nstatic char chorus_defined[SNDRV_EMU8000_CHORUS_NUMBERS];\nstatic struct soundfont_chorus_fx chorus_parm[SNDRV_EMU8000_CHORUS_NUMBERS] = {\n\t{0xE600, 0x03F6, 0xBC2C ,0x00000000, 0x0000006D},  \n\t{0xE608, 0x031A, 0xBC6E, 0x00000000, 0x0000017C},  \n\t{0xE610, 0x031A, 0xBC84, 0x00000000, 0x00000083},  \n\t{0xE620, 0x0269, 0xBC6E, 0x00000000, 0x0000017C},  \n\t{0xE680, 0x04D3, 0xBCA6, 0x00000000, 0x0000005B},  \n\t{0xE6E0, 0x044E, 0xBC37, 0x00000000, 0x00000026},  \n\t{0xE600, 0x0B06, 0xBC00, 0x0006E000, 0x00000083},  \n\t{0xE6C0, 0x0B06, 0xBC00, 0x0006E000, 0x00000083},  \n};\n\n  int\nsnd_emu8000_load_chorus_fx(struct snd_emu8000 *emu, int mode, const void __user *buf, long len)\n{\n\tstruct soundfont_chorus_fx rec;\n\tif (mode < SNDRV_EMU8000_CHORUS_PREDEFINED || mode >= SNDRV_EMU8000_CHORUS_NUMBERS) {\n\t\tsnd_printk(KERN_WARNING \"invalid chorus mode %d for uploading\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\tif (len < (long)sizeof(rec) || copy_from_user(&rec, buf, sizeof(rec)))\n\t\treturn -EFAULT;\n\tchorus_parm[mode] = rec;\n\tchorus_defined[mode] = 1;\n\treturn 0;\n}\n\n  void\nsnd_emu8000_update_chorus_mode(struct snd_emu8000 *emu)\n{\n\tint effect = emu->chorus_mode;\n\tif (effect < 0 || effect >= SNDRV_EMU8000_CHORUS_NUMBERS ||\n\t    (effect >= SNDRV_EMU8000_CHORUS_PREDEFINED && !chorus_defined[effect]))\n\t\treturn;\n\tEMU8000_INIT3_WRITE(emu, 0x09, chorus_parm[effect].feedback);\n\tEMU8000_INIT3_WRITE(emu, 0x0c, chorus_parm[effect].delay_offset);\n\tEMU8000_INIT4_WRITE(emu, 0x03, chorus_parm[effect].lfo_depth);\n\tEMU8000_HWCF4_WRITE(emu, chorus_parm[effect].delay);\n\tEMU8000_HWCF5_WRITE(emu, chorus_parm[effect].lfo_freq);\n\tEMU8000_HWCF6_WRITE(emu, 0x8000);\n\tEMU8000_HWCF7_WRITE(emu, 0x0000);\n}\n\n \n\n \n#define\tSNDRV_EMU8000_REVERB_ROOM1\t0\n#define SNDRV_EMU8000_REVERB_ROOM2\t1\n#define\tSNDRV_EMU8000_REVERB_ROOM3\t2\n#define\tSNDRV_EMU8000_REVERB_HALL1\t3\n#define\tSNDRV_EMU8000_REVERB_HALL2\t4\n#define\tSNDRV_EMU8000_REVERB_PLATE\t5\n#define\tSNDRV_EMU8000_REVERB_DELAY\t6\n#define\tSNDRV_EMU8000_REVERB_PANNINGDELAY 7\n#define SNDRV_EMU8000_REVERB_PREDEFINED\t8\n \n#define SNDRV_EMU8000_REVERB_NUMBERS\t32\n\nstruct soundfont_reverb_fx {\n\tunsigned short parms[28];\n};\n\n \nstatic char reverb_defined[SNDRV_EMU8000_CHORUS_NUMBERS];\nstatic struct soundfont_reverb_fx reverb_parm[SNDRV_EMU8000_REVERB_NUMBERS] = {\n{{   \n\t0xB488, 0xA450, 0x9550, 0x84B5, 0x383A, 0x3EB5, 0x72F4,\n\t0x72A4, 0x7254, 0x7204, 0x7204, 0x7204, 0x4416, 0x4516,\n\t0xA490, 0xA590, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,\n\t0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,\n}},\n{{   \n\t0xB488, 0xA458, 0x9558, 0x84B5, 0x383A, 0x3EB5, 0x7284,\n\t0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4448, 0x4548,\n\t0xA440, 0xA540, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,\n\t0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,\n}},\n{{   \n\t0xB488, 0xA460, 0x9560, 0x84B5, 0x383A, 0x3EB5, 0x7284,\n\t0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4416, 0x4516,\n\t0xA490, 0xA590, 0x842C, 0x852C, 0x842C, 0x852C, 0x842B,\n\t0x852B, 0x842B, 0x852B, 0x842A, 0x852A, 0x842A, 0x852A,\n}},\n{{   \n\t0xB488, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7284,\n\t0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4448, 0x4548,\n\t0xA440, 0xA540, 0x842B, 0x852B, 0x842B, 0x852B, 0x842A,\n\t0x852A, 0x842A, 0x852A, 0x8429, 0x8529, 0x8429, 0x8529,\n}},\n{{   \n\t0xB488, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7254,\n\t0x7234, 0x7224, 0x7254, 0x7264, 0x7294, 0x44C3, 0x45C3,\n\t0xA404, 0xA504, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,\n\t0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,\n}},\n{{   \n\t0xB4FF, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7234,\n\t0x7234, 0x7234, 0x7234, 0x7234, 0x7234, 0x4448, 0x4548,\n\t0xA440, 0xA540, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,\n\t0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,\n}},\n{{   \n\t0xB4FF, 0xA470, 0x9500, 0x84B5, 0x333A, 0x39B5, 0x7204,\n\t0x7204, 0x7204, 0x7204, 0x7204, 0x72F4, 0x4400, 0x4500,\n\t0xA4FF, 0xA5FF, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420,\n\t0x8520, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420, 0x8520,\n}},\n{{   \n\t0xB4FF, 0xA490, 0x9590, 0x8474, 0x333A, 0x39B5, 0x7204,\n\t0x7204, 0x7204, 0x7204, 0x7204, 0x72F4, 0x4400, 0x4500,\n\t0xA4FF, 0xA5FF, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420,\n\t0x8520, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420, 0x8520,\n}},\n};\n\nenum { DATA1, DATA2 };\n#define AWE_INIT1(c)\tEMU8000_CMD(2,c), DATA1\n#define AWE_INIT2(c)\tEMU8000_CMD(2,c), DATA2\n#define AWE_INIT3(c)\tEMU8000_CMD(3,c), DATA1\n#define AWE_INIT4(c)\tEMU8000_CMD(3,c), DATA2\n\nstatic struct reverb_cmd_pair {\n\tunsigned short cmd, port;\n} reverb_cmds[28] = {\n  {AWE_INIT1(0x03)}, {AWE_INIT1(0x05)}, {AWE_INIT4(0x1F)}, {AWE_INIT1(0x07)},\n  {AWE_INIT2(0x14)}, {AWE_INIT2(0x16)}, {AWE_INIT1(0x0F)}, {AWE_INIT1(0x17)},\n  {AWE_INIT1(0x1F)}, {AWE_INIT2(0x07)}, {AWE_INIT2(0x0F)}, {AWE_INIT2(0x17)},\n  {AWE_INIT2(0x1D)}, {AWE_INIT2(0x1F)}, {AWE_INIT3(0x01)}, {AWE_INIT3(0x03)},\n  {AWE_INIT1(0x09)}, {AWE_INIT1(0x0B)}, {AWE_INIT1(0x11)}, {AWE_INIT1(0x13)},\n  {AWE_INIT1(0x19)}, {AWE_INIT1(0x1B)}, {AWE_INIT2(0x01)}, {AWE_INIT2(0x03)},\n  {AWE_INIT2(0x09)}, {AWE_INIT2(0x0B)}, {AWE_INIT2(0x11)}, {AWE_INIT2(0x13)},\n};\n\n  int\nsnd_emu8000_load_reverb_fx(struct snd_emu8000 *emu, int mode, const void __user *buf, long len)\n{\n\tstruct soundfont_reverb_fx rec;\n\n\tif (mode < SNDRV_EMU8000_REVERB_PREDEFINED || mode >= SNDRV_EMU8000_REVERB_NUMBERS) {\n\t\tsnd_printk(KERN_WARNING \"invalid reverb mode %d for uploading\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\tif (len < (long)sizeof(rec) || copy_from_user(&rec, buf, sizeof(rec)))\n\t\treturn -EFAULT;\n\treverb_parm[mode] = rec;\n\treverb_defined[mode] = 1;\n\treturn 0;\n}\n\n  void\nsnd_emu8000_update_reverb_mode(struct snd_emu8000 *emu)\n{\n\tint effect = emu->reverb_mode;\n\tint i;\n\n\tif (effect < 0 || effect >= SNDRV_EMU8000_REVERB_NUMBERS ||\n\t    (effect >= SNDRV_EMU8000_REVERB_PREDEFINED && !reverb_defined[effect]))\n\t\treturn;\n\tfor (i = 0; i < 28; i++) {\n\t\tint port;\n\t\tif (reverb_cmds[i].port == DATA1)\n\t\t\tport = EMU8000_DATA1(emu);\n\t\telse\n\t\t\tport = EMU8000_DATA2(emu);\n\t\tsnd_emu8000_poke(emu, port, reverb_cmds[i].cmd, reverb_parm[effect].parms[i]);\n\t}\n}\n\n\n \n\n \nstatic int mixer_bass_treble_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 11;\n\treturn 0;\n}\n\nstatic int mixer_bass_treble_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = kcontrol->private_value ? emu->treble_level : emu->bass_level;\n\treturn 0;\n}\n\nstatic int mixer_bass_treble_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short val1;\n\t\n\tval1 = ucontrol->value.integer.value[0] % 12;\n\tspin_lock_irqsave(&emu->control_lock, flags);\n\tif (kcontrol->private_value) {\n\t\tchange = val1 != emu->treble_level;\n\t\temu->treble_level = val1;\n\t} else {\n\t\tchange = val1 != emu->bass_level;\n\t\temu->bass_level = val1;\n\t}\n\tspin_unlock_irqrestore(&emu->control_lock, flags);\n\tsnd_emu8000_update_equalizer(emu);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new mixer_bass_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Synth Tone Control - Bass\",\n\t.info = mixer_bass_treble_info,\n\t.get = mixer_bass_treble_get,\n\t.put = mixer_bass_treble_put,\n\t.private_value = 0,\n};\n\nstatic const struct snd_kcontrol_new mixer_treble_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Synth Tone Control - Treble\",\n\t.info = mixer_bass_treble_info,\n\t.get = mixer_bass_treble_get,\n\t.put = mixer_bass_treble_put,\n\t.private_value = 1,\n};\n\n \nstatic int mixer_chorus_reverb_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = kcontrol->private_value ? (SNDRV_EMU8000_CHORUS_NUMBERS-1) : (SNDRV_EMU8000_REVERB_NUMBERS-1);\n\treturn 0;\n}\n\nstatic int mixer_chorus_reverb_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = kcontrol->private_value ? emu->chorus_mode : emu->reverb_mode;\n\treturn 0;\n}\n\nstatic int mixer_chorus_reverb_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short val1;\n\t\n\tspin_lock_irqsave(&emu->control_lock, flags);\n\tif (kcontrol->private_value) {\n\t\tval1 = ucontrol->value.integer.value[0] % SNDRV_EMU8000_CHORUS_NUMBERS;\n\t\tchange = val1 != emu->chorus_mode;\n\t\temu->chorus_mode = val1;\n\t} else {\n\t\tval1 = ucontrol->value.integer.value[0] % SNDRV_EMU8000_REVERB_NUMBERS;\n\t\tchange = val1 != emu->reverb_mode;\n\t\temu->reverb_mode = val1;\n\t}\n\tspin_unlock_irqrestore(&emu->control_lock, flags);\n\tif (change) {\n\t\tif (kcontrol->private_value)\n\t\t\tsnd_emu8000_update_chorus_mode(emu);\n\t\telse\n\t\t\tsnd_emu8000_update_reverb_mode(emu);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new mixer_chorus_mode_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Chorus Mode\",\n\t.info = mixer_chorus_reverb_info,\n\t.get = mixer_chorus_reverb_get,\n\t.put = mixer_chorus_reverb_put,\n\t.private_value = 1,\n};\n\nstatic const struct snd_kcontrol_new mixer_reverb_mode_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Reverb Mode\",\n\t.info = mixer_chorus_reverb_info,\n\t.get = mixer_chorus_reverb_get,\n\t.put = mixer_chorus_reverb_put,\n\t.private_value = 0,\n};\n\n \nstatic int mixer_fm_depth_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int mixer_fm_depth_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = kcontrol->private_value ? emu->fm_chorus_depth : emu->fm_reverb_depth;\n\treturn 0;\n}\n\nstatic int mixer_fm_depth_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu8000 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short val1;\n\t\n\tval1 = ucontrol->value.integer.value[0] % 256;\n\tspin_lock_irqsave(&emu->control_lock, flags);\n\tif (kcontrol->private_value) {\n\t\tchange = val1 != emu->fm_chorus_depth;\n\t\temu->fm_chorus_depth = val1;\n\t} else {\n\t\tchange = val1 != emu->fm_reverb_depth;\n\t\temu->fm_reverb_depth = val1;\n\t}\n\tspin_unlock_irqrestore(&emu->control_lock, flags);\n\tif (change)\n\t\tsnd_emu8000_init_fm(emu);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new mixer_fm_chorus_depth_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"FM Chorus Depth\",\n\t.info = mixer_fm_depth_info,\n\t.get = mixer_fm_depth_get,\n\t.put = mixer_fm_depth_put,\n\t.private_value = 1,\n};\n\nstatic const struct snd_kcontrol_new mixer_fm_reverb_depth_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"FM Reverb Depth\",\n\t.info = mixer_fm_depth_info,\n\t.get = mixer_fm_depth_get,\n\t.put = mixer_fm_depth_put,\n\t.private_value = 0,\n};\n\n\nstatic const struct snd_kcontrol_new *mixer_defs[EMU8000_NUM_CONTROLS] = {\n\t&mixer_bass_control,\n\t&mixer_treble_control,\n\t&mixer_chorus_mode_control,\n\t&mixer_reverb_mode_control,\n\t&mixer_fm_chorus_depth_control,\n\t&mixer_fm_reverb_depth_control,\n};\n\n \nstatic int\nsnd_emu8000_create_mixer(struct snd_card *card, struct snd_emu8000 *emu)\n{\n\tstruct snd_kcontrol *kctl;\n\tint i, err = 0;\n\n\tif (snd_BUG_ON(!emu || !card))\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&emu->control_lock);\n\n\tmemset(emu->controls, 0, sizeof(emu->controls));\n\tfor (i = 0; i < EMU8000_NUM_CONTROLS; i++) {\n\t\tkctl = snd_ctl_new1(mixer_defs[i], emu);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\temu->controls[i] = kctl;\n\t}\n\treturn 0;\n\n__error:\n\tfor (i = 0; i < EMU8000_NUM_CONTROLS; i++) {\n\t\tif (emu->controls[i])\n\t\t\tsnd_ctl_remove(card, emu->controls[i]);\n\t}\n\treturn err;\n}\n\n \nint\nsnd_emu8000_new(struct snd_card *card, int index, long port, int seq_ports,\n\t\tstruct snd_seq_device **awe_ret)\n{\n\tstruct snd_seq_device *awe;\n\tstruct snd_emu8000 *hw;\n\tint err;\n\n\tif (awe_ret)\n\t\t*awe_ret = NULL;\n\n\tif (seq_ports <= 0)\n\t\treturn 0;\n\n\thw = devm_kzalloc(card->dev, sizeof(*hw), GFP_KERNEL);\n\tif (hw == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&hw->reg_lock);\n\thw->index = index;\n\thw->port1 = port;\n\thw->port2 = port + 0x400;\n\thw->port3 = port + 0x800;\n\tif (!devm_request_region(card->dev, hw->port1, 4, \"Emu8000-1\") ||\n\t    !devm_request_region(card->dev, hw->port2, 4, \"Emu8000-2\") ||\n\t    !devm_request_region(card->dev, hw->port3, 4, \"Emu8000-3\")) {\n\t\tsnd_printk(KERN_ERR \"sbawe: can't grab ports 0x%lx, 0x%lx, 0x%lx\\n\", hw->port1, hw->port2, hw->port3);\n\t\treturn -EBUSY;\n\t}\n\thw->mem_size = 0;\n\thw->card = card;\n\thw->seq_ports = seq_ports;\n\thw->bass_level = 5;\n\thw->treble_level = 9;\n\thw->chorus_mode = 2;\n\thw->reverb_mode = 4;\n\thw->fm_chorus_depth = 0;\n\thw->fm_reverb_depth = 0;\n\n\tif (snd_emu8000_detect(hw) < 0)\n\t\treturn -ENODEV;\n\n\tsnd_emu8000_init_hw(hw);\n\terr = snd_emu8000_create_mixer(card, hw);\n\tif (err < 0)\n\t\treturn err;\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tif (snd_seq_device_new(card, index, SNDRV_SEQ_DEV_ID_EMU8000,\n\t\t\t       sizeof(struct snd_emu8000*), &awe) >= 0) {\n\t\tstrcpy(awe->name, \"EMU-8000\");\n\t\t*(struct snd_emu8000 **)SNDRV_SEQ_DEVICE_ARGPTR(awe) = hw;\n\t}\n#else\n\tawe = NULL;\n#endif\n\tif (awe_ret)\n\t\t*awe_ret = awe;\n\n\treturn 0;\n}\n\n\n \n\nEXPORT_SYMBOL(snd_emu8000_poke);\nEXPORT_SYMBOL(snd_emu8000_peek);\nEXPORT_SYMBOL(snd_emu8000_poke_dw);\nEXPORT_SYMBOL(snd_emu8000_peek_dw);\nEXPORT_SYMBOL(snd_emu8000_dma_chan);\nEXPORT_SYMBOL(snd_emu8000_init_fm);\nEXPORT_SYMBOL(snd_emu8000_load_chorus_fx);\nEXPORT_SYMBOL(snd_emu8000_load_reverb_fx);\nEXPORT_SYMBOL(snd_emu8000_update_chorus_mode);\nEXPORT_SYMBOL(snd_emu8000_update_reverb_mode);\nEXPORT_SYMBOL(snd_emu8000_update_equalizer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}