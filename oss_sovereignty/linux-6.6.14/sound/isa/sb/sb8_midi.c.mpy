{
  "module_name": "sb8_midi.c",
  "hash_id": "0f61443afda97e445f877fd96849004399c369c272ab80b50382e2c260e0a594",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sb/sb8_midi.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n\n\nirqreturn_t snd_sb8dsp_midi_interrupt(struct snd_sb *chip)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint max = 64;\n\tchar byte;\n\n\tif (!chip)\n\t\treturn IRQ_NONE;\n\t\n\trmidi = chip->rmidi;\n\tif (!rmidi) {\n\t\tinb(SBP(chip, DATA_AVAIL));\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock(&chip->midi_input_lock);\n\twhile (max-- > 0) {\n\t\tif (inb(SBP(chip, DATA_AVAIL)) & 0x80) {\n\t\t\tbyte = inb(SBP(chip, READ));\n\t\t\tif (chip->open & SB_OPEN_MIDI_INPUT_TRIGGER) {\n\t\t\t\tsnd_rawmidi_receive(chip->midi_substream_input, &byte, 1);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&chip->midi_input_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int snd_sb8dsp_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\tunsigned int valid_open_flags;\n\n\tchip = substream->rmidi->private_data;\n\tvalid_open_flags = chip->hardware >= SB_HW_20\n\t\t? SB_OPEN_MIDI_OUTPUT | SB_OPEN_MIDI_OUTPUT_TRIGGER : 0;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (chip->open & ~valid_open_flags) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tchip->open |= SB_OPEN_MIDI_INPUT;\n\tchip->midi_substream_input = substream;\n\tif (!(chip->open & SB_OPEN_MIDI_OUTPUT)) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\tsnd_sbdsp_reset(chip);\t\t \n\t\tif (chip->hardware >= SB_HW_20)\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_MIDI_UART_IRQ);\n\t} else {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8dsp_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\tunsigned int valid_open_flags;\n\n\tchip = substream->rmidi->private_data;\n\tvalid_open_flags = chip->hardware >= SB_HW_20\n\t\t? SB_OPEN_MIDI_INPUT | SB_OPEN_MIDI_INPUT_TRIGGER : 0;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (chip->open & ~valid_open_flags) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tchip->open |= SB_OPEN_MIDI_OUTPUT;\n\tchip->midi_substream_output = substream;\n\tif (!(chip->open & SB_OPEN_MIDI_INPUT)) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\tsnd_sbdsp_reset(chip);\t\t \n\t\tif (chip->hardware >= SB_HW_20)\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_MIDI_UART_IRQ);\n\t} else {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8dsp_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\n\tchip = substream->rmidi->private_data;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tchip->open &= ~(SB_OPEN_MIDI_INPUT | SB_OPEN_MIDI_INPUT_TRIGGER);\n\tchip->midi_substream_input = NULL;\n\tif (!(chip->open & SB_OPEN_MIDI_OUTPUT)) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\tsnd_sbdsp_reset(chip);\t\t \n\t} else {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic int snd_sb8dsp_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\n\tchip = substream->rmidi->private_data;\n\tdel_timer_sync(&chip->midi_timer);\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tchip->open &= ~(SB_OPEN_MIDI_OUTPUT | SB_OPEN_MIDI_OUTPUT_TRIGGER);\n\tchip->midi_substream_output = NULL;\n\tif (!(chip->open & SB_OPEN_MIDI_INPUT)) {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\tsnd_sbdsp_reset(chip);\t\t \n\t} else {\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic void snd_sb8dsp_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\n\tchip = substream->rmidi->private_data;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (up) {\n\t\tif (!(chip->open & SB_OPEN_MIDI_INPUT_TRIGGER)) {\n\t\t\tif (chip->hardware < SB_HW_20)\n\t\t\t\tsnd_sbdsp_command(chip, SB_DSP_MIDI_INPUT_IRQ);\n\t\t\tchip->open |= SB_OPEN_MIDI_INPUT_TRIGGER;\n\t\t}\n\t} else {\n\t\tif (chip->open & SB_OPEN_MIDI_INPUT_TRIGGER) {\n\t\t\tif (chip->hardware < SB_HW_20)\n\t\t\t\tsnd_sbdsp_command(chip, SB_DSP_MIDI_INPUT_IRQ);\n\t\t\tchip->open &= ~SB_OPEN_MIDI_INPUT_TRIGGER;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n}\n\nstatic void snd_sb8dsp_midi_output_write(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\tchar byte;\n\tint max = 32;\n\n\t \n\tchip = substream->rmidi->private_data;\n\twhile (max-- > 0) {\n\t\tspin_lock_irqsave(&chip->open_lock, flags);\n\t\tif (snd_rawmidi_transmit_peek(substream, &byte, 1) != 1) {\n\t\t\tchip->open &= ~SB_OPEN_MIDI_OUTPUT_TRIGGER;\n\t\t\tdel_timer(&chip->midi_timer);\n\t\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (chip->hardware >= SB_HW_20) {\n\t\t\tint timeout = 8;\n\t\t\twhile ((inb(SBP(chip, STATUS)) & 0x80) != 0 && --timeout > 0)\n\t\t\t\t;\n\t\t\tif (timeout == 0) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutb(byte, SBP(chip, WRITE));\n\t\t} else {\n\t\t\tsnd_sbdsp_command(chip, SB_DSP_MIDI_OUTPUT);\n\t\t\tsnd_sbdsp_command(chip, byte);\n\t\t}\n\t\tsnd_rawmidi_transmit_ack(substream, 1);\n\t\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\t}\n}\n\nstatic void snd_sb8dsp_midi_output_timer(struct timer_list *t)\n{\n\tstruct snd_sb *chip = from_timer(chip, t, midi_timer);\n\tstruct snd_rawmidi_substream *substream = chip->midi_substream_output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tmod_timer(&chip->midi_timer, 1 + jiffies);\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\t\n\tsnd_sb8dsp_midi_output_write(substream);\n}\n\nstatic void snd_sb8dsp_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_sb *chip;\n\n\tchip = substream->rmidi->private_data;\n\tspin_lock_irqsave(&chip->open_lock, flags);\n\tif (up) {\n\t\tif (!(chip->open & SB_OPEN_MIDI_OUTPUT_TRIGGER)) {\n\t\t\tmod_timer(&chip->midi_timer, 1 + jiffies);\n\t\t\tchip->open |= SB_OPEN_MIDI_OUTPUT_TRIGGER;\n\t\t}\n\t} else {\n\t\tif (chip->open & SB_OPEN_MIDI_OUTPUT_TRIGGER) {\n\t\t\tchip->open &= ~SB_OPEN_MIDI_OUTPUT_TRIGGER;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->open_lock, flags);\n\n\tif (up)\n\t\tsnd_sb8dsp_midi_output_write(substream);\n}\n\nstatic const struct snd_rawmidi_ops snd_sb8dsp_midi_output =\n{\n\t.open =\t\tsnd_sb8dsp_midi_output_open,\n\t.close =\tsnd_sb8dsp_midi_output_close,\n\t.trigger =\tsnd_sb8dsp_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_sb8dsp_midi_input =\n{\n\t.open =\t\tsnd_sb8dsp_midi_input_open,\n\t.close =\tsnd_sb8dsp_midi_input_close,\n\t.trigger =\tsnd_sb8dsp_midi_input_trigger,\n};\n\nint snd_sb8dsp_midi(struct snd_sb *chip, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(chip->card, \"SB8 MIDI\", device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, \"SB8 MIDI\");\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_sb8dsp_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_sb8dsp_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT;\n\tif (chip->hardware >= SB_HW_20)\n\t\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = chip;\n\ttimer_setup(&chip->midi_timer, snd_sb8dsp_midi_output_timer, 0);\n\tchip->rmidi = rmidi;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}