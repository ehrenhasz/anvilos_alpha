{
  "module_name": "msnd.c",
  "hash_id": "5e3c4c4ffc24ed678202f209491f2e9bf67053dbf2d3f5d25a33124749420742",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/msnd/msnd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"msnd.h\"\n\n#define LOGNAME\t\t\t\"msnd\"\n\n\nvoid snd_msnd_init_queue(void __iomem *base, int start, int size)\n{\n\twritew(PCTODSP_BASED(start), base + JQS_wStart);\n\twritew(PCTODSP_OFFSET(size) - 1, base + JQS_wSize);\n\twritew(0, base + JQS_wHead);\n\twritew(0, base + JQS_wTail);\n}\nEXPORT_SYMBOL(snd_msnd_init_queue);\n\nstatic int snd_msnd_wait_TXDE(struct snd_msnd *dev)\n{\n\tunsigned int io = dev->io;\n\tint timeout = 1000;\n\n\twhile (timeout-- > 0)\n\t\tif (inb(io + HP_ISR) & HPISR_TXDE)\n\t\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int snd_msnd_wait_HC0(struct snd_msnd *dev)\n{\n\tunsigned int io = dev->io;\n\tint timeout = 1000;\n\n\twhile (timeout-- > 0)\n\t\tif (!(inb(io + HP_CVR) & HPCVR_HC))\n\t\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint snd_msnd_send_dsp_cmd(struct snd_msnd *dev, u8 cmd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (snd_msnd_wait_HC0(dev) == 0) {\n\t\toutb(cmd, dev->io + HP_CVR);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tsnd_printd(KERN_ERR LOGNAME \": Send DSP command timeout\\n\");\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL(snd_msnd_send_dsp_cmd);\n\nint snd_msnd_send_word(struct snd_msnd *dev, unsigned char high,\n\t\t   unsigned char mid, unsigned char low)\n{\n\tunsigned int io = dev->io;\n\n\tif (snd_msnd_wait_TXDE(dev) == 0) {\n\t\toutb(high, io + HP_TXH);\n\t\toutb(mid, io + HP_TXM);\n\t\toutb(low, io + HP_TXL);\n\t\treturn 0;\n\t}\n\n\tsnd_printd(KERN_ERR LOGNAME \": Send host word timeout\\n\");\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL(snd_msnd_send_word);\n\nint snd_msnd_upload_host(struct snd_msnd *dev, const u8 *bin, int len)\n{\n\tint i;\n\n\tif (len % 3 != 0) {\n\t\tsnd_printk(KERN_ERR LOGNAME\n\t\t\t   \": Upload host data not multiple of 3!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < len; i += 3)\n\t\tif (snd_msnd_send_word(dev, bin[i], bin[i + 1], bin[i + 2]))\n\t\t\treturn -EIO;\n\n\tinb(dev->io + HP_RXL);\n\tinb(dev->io + HP_CVR);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_msnd_upload_host);\n\nint snd_msnd_enable_irq(struct snd_msnd *dev)\n{\n\tunsigned long flags;\n\n\tif (dev->irq_ref++)\n\t\treturn 0;\n\n\tsnd_printdd(LOGNAME \": Enabling IRQ\\n\");\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (snd_msnd_wait_TXDE(dev) == 0) {\n\t\toutb(inb(dev->io + HP_ICR) | HPICR_TREQ, dev->io + HP_ICR);\n\t\tif (dev->type == msndClassic)\n\t\t\toutb(dev->irqid, dev->io + HP_IRQM);\n\n\t\toutb(inb(dev->io + HP_ICR) & ~HPICR_TREQ, dev->io + HP_ICR);\n\t\toutb(inb(dev->io + HP_ICR) | HPICR_RREQ, dev->io + HP_ICR);\n\t\tenable_irq(dev->irq);\n\t\tsnd_msnd_init_queue(dev->DSPQ, dev->dspq_data_buff,\n\t\t\t\t    dev->dspq_buff_size);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tsnd_printd(KERN_ERR LOGNAME \": Enable IRQ failed\\n\");\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL(snd_msnd_enable_irq);\n\nint snd_msnd_disable_irq(struct snd_msnd *dev)\n{\n\tunsigned long flags;\n\n\tif (--dev->irq_ref > 0)\n\t\treturn 0;\n\n\tif (dev->irq_ref < 0)\n\t\tsnd_printd(KERN_WARNING LOGNAME \": IRQ ref count is %d\\n\",\n\t\t\t   dev->irq_ref);\n\n\tsnd_printdd(LOGNAME \": Disabling IRQ\\n\");\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (snd_msnd_wait_TXDE(dev) == 0) {\n\t\toutb(inb(dev->io + HP_ICR) & ~HPICR_RREQ, dev->io + HP_ICR);\n\t\tif (dev->type == msndClassic)\n\t\t\toutb(HPIRQ_NONE, dev->io + HP_IRQM);\n\t\tdisable_irq(dev->irq);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tsnd_printd(KERN_ERR LOGNAME \": Disable IRQ failed\\n\");\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL(snd_msnd_disable_irq);\n\nstatic inline long get_play_delay_jiffies(struct snd_msnd *chip, long size)\n{\n\tlong tmp = (size * HZ * chip->play_sample_size) / 8;\n\treturn tmp / (chip->play_sample_rate * chip->play_channels);\n}\n\nstatic void snd_msnd_dsp_write_flush(struct snd_msnd *chip)\n{\n\tif (!(chip->mode & FMODE_WRITE) || !test_bit(F_WRITING, &chip->flags))\n\t\treturn;\n\tset_bit(F_WRITEFLUSH, &chip->flags);\n \n\tclear_bit(F_WRITEFLUSH, &chip->flags);\n\tif (!signal_pending(current))\n\t\tschedule_timeout_interruptible(\n\t\t\tget_play_delay_jiffies(chip, chip->play_period_bytes));\n\tclear_bit(F_WRITING, &chip->flags);\n}\n\nvoid snd_msnd_dsp_halt(struct snd_msnd *chip, struct file *file)\n{\n\tif ((file ? file->f_mode : chip->mode) & FMODE_READ) {\n\t\tclear_bit(F_READING, &chip->flags);\n\t\tsnd_msnd_send_dsp_cmd(chip, HDEX_RECORD_STOP);\n\t\tsnd_msnd_disable_irq(chip);\n\t\tif (file) {\n\t\t\tsnd_printd(KERN_INFO LOGNAME\n\t\t\t\t   \": Stopping read for %p\\n\", file);\n\t\t\tchip->mode &= ~FMODE_READ;\n\t\t}\n\t\tclear_bit(F_AUDIO_READ_INUSE, &chip->flags);\n\t}\n\tif ((file ? file->f_mode : chip->mode) & FMODE_WRITE) {\n\t\tif (test_bit(F_WRITING, &chip->flags)) {\n\t\t\tsnd_msnd_dsp_write_flush(chip);\n\t\t\tsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_STOP);\n\t\t}\n\t\tsnd_msnd_disable_irq(chip);\n\t\tif (file) {\n\t\t\tsnd_printd(KERN_INFO\n\t\t\t\t   LOGNAME \": Stopping write for %p\\n\", file);\n\t\t\tchip->mode &= ~FMODE_WRITE;\n\t\t}\n\t\tclear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\n\t}\n}\nEXPORT_SYMBOL(snd_msnd_dsp_halt);\n\n\nint snd_msnd_DARQ(struct snd_msnd *chip, int bank)\n{\n\tint   timeout = 3;\n\tu16 wTmp;\n\t \n\n\t \n\twTmp = readw(chip->DARQ + JQS_wTail) + PCTODSP_OFFSET(DAQDS__size);\n\tif (wTmp > readw(chip->DARQ + JQS_wSize))\n\t\twTmp = 0;\n\twhile (wTmp == readw(chip->DARQ + JQS_wHead) && timeout--)\n\t\tudelay(1);\n\n\tif (chip->capturePeriods == 2) {\n\t\tvoid __iomem *pDAQ = chip->mappedbase + DARQ_DATA_BUFF +\n\t\t\t     bank * DAQDS__size + DAQDS_wStart;\n\t\tunsigned short offset = 0x3000 + chip->capturePeriodBytes;\n\n\t\tif (readw(pDAQ) != PCTODSP_BASED(0x3000))\n\t\t\toffset = 0x3000;\n\t\twritew(PCTODSP_BASED(offset), pDAQ);\n\t}\n\n\twritew(wTmp, chip->DARQ + JQS_wTail);\n\n#if 0\n\t \n\tDAQD = bank * DAQDS__size + chip->mappedbase + DARQ_DATA_BUFF;\n\n\t \n\tsize = readw(DAQD + DAQDS_wSize);\n\n\t \n\toutb(HPBLKSEL_1, chip->io + HP_BLKS);\n\tn = msnd_fifo_write(&chip->DARF,\n\t\t\t    (char *)(chip->base + bank * DAR_BUFF_SIZE),\n\t\t\t    size, 0);\n\tif (n <= 0) {\n\t\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n\t\treturn n;\n\t}\n\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n#endif\n\n\treturn 1;\n}\nEXPORT_SYMBOL(snd_msnd_DARQ);\n\nint snd_msnd_DAPQ(struct snd_msnd *chip, int start)\n{\n\tu16\tDAPQ_tail;\n\tint\tprotect = start, nbanks = 0;\n\tvoid\t__iomem *DAQD;\n\tstatic int play_banks_submitted;\n\t \n\n\tDAPQ_tail = readw(chip->DAPQ + JQS_wTail);\n\twhile (DAPQ_tail != readw(chip->DAPQ + JQS_wHead) || start) {\n\t\tint bank_num = DAPQ_tail / PCTODSP_OFFSET(DAQDS__size);\n\n\t\tif (start) {\n\t\t\tstart = 0;\n\t\t\tplay_banks_submitted = 0;\n\t\t}\n\n\t\t \n\t\tDAQD = bank_num * DAQDS__size + chip->mappedbase +\n\t\t\tDAPQ_DATA_BUFF;\n\n\t\t \n\t\twritew(chip->play_period_bytes, DAQD + DAQDS_wSize);\n\t\tif (play_banks_submitted < 3)\n\t\t\t++play_banks_submitted;\n\t\telse if (chip->playPeriods == 2) {\n\t\t\tunsigned short offset = chip->play_period_bytes;\n\n\t\t\tif (readw(DAQD + DAQDS_wStart) != PCTODSP_BASED(0x0))\n\t\t\t\toffset = 0;\n\n\t\t\twritew(PCTODSP_BASED(offset), DAQD + DAQDS_wStart);\n\t\t}\n\t\t++nbanks;\n\n\t\t \n\t\t \n\n\t\tDAPQ_tail = (++bank_num % 3) * PCTODSP_OFFSET(DAQDS__size);\n\t\twritew(DAPQ_tail, chip->DAPQ + JQS_wTail);\n\t\t \n\t\tsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_START);\n\t\tif (protect)\n\t\t\tif (2 == bank_num)\n\t\t\t\tbreak;\n\t}\n\t \n\t \n\treturn nbanks;\n}\nEXPORT_SYMBOL(snd_msnd_DAPQ);\n\nstatic void snd_msnd_play_reset_queue(struct snd_msnd *chip,\n\t\t\t\t      unsigned int pcm_periods,\n\t\t\t\t      unsigned int pcm_count)\n{\n\tint\tn;\n\tvoid\t__iomem *pDAQ = chip->mappedbase + DAPQ_DATA_BUFF;\n\n\tchip->last_playbank = -1;\n\tchip->playLimit = pcm_count * (pcm_periods - 1);\n\tchip->playPeriods = pcm_periods;\n\twritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wHead);\n\twritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wTail);\n\n\tchip->play_period_bytes = pcm_count;\n\n\tfor (n = 0; n < pcm_periods; ++n, pDAQ += DAQDS__size) {\n\t\twritew(PCTODSP_BASED((u32)(pcm_count * n)),\n\t\t\tpDAQ + DAQDS_wStart);\n\t\twritew(0, pDAQ + DAQDS_wSize);\n\t\twritew(1, pDAQ + DAQDS_wFormat);\n\t\twritew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);\n\t\twritew(chip->play_channels, pDAQ + DAQDS_wChannels);\n\t\twritew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);\n\t\twritew(HIMT_PLAY_DONE * 0x100 + n, pDAQ + DAQDS_wIntMsg);\n\t\twritew(n, pDAQ + DAQDS_wFlags);\n\t}\n}\n\nstatic void snd_msnd_capture_reset_queue(struct snd_msnd *chip,\n\t\t\t\t\t unsigned int pcm_periods,\n\t\t\t\t\t unsigned int pcm_count)\n{\n\tint\t\tn;\n\tvoid\t\t__iomem *pDAQ;\n\t \n\n\t \n\n\tchip->last_recbank = 2;\n\tchip->captureLimit = pcm_count * (pcm_periods - 1);\n\tchip->capturePeriods = pcm_periods;\n\twritew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DARQ + JQS_wHead);\n\twritew(PCTODSP_OFFSET(chip->last_recbank * DAQDS__size),\n\t\tchip->DARQ + JQS_wTail);\n\n#if 0  \n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(HPBLKSEL_1, chip->io + HP_BLKS);\n\tmemset_io(chip->mappedbase, 0, DAR_BUFF_SIZE * 3);\n\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n#endif\n\n\tchip->capturePeriodBytes = pcm_count;\n\tsnd_printdd(\"snd_msnd_capture_reset_queue() %i\\n\", pcm_count);\n\n\tpDAQ = chip->mappedbase + DARQ_DATA_BUFF;\n\n\tfor (n = 0; n < pcm_periods; ++n, pDAQ += DAQDS__size) {\n\t\tu32 tmp = pcm_count * n;\n\n\t\twritew(PCTODSP_BASED(tmp + 0x3000), pDAQ + DAQDS_wStart);\n\t\twritew(pcm_count, pDAQ + DAQDS_wSize);\n\t\twritew(1, pDAQ + DAQDS_wFormat);\n\t\twritew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);\n\t\twritew(chip->capture_channels, pDAQ + DAQDS_wChannels);\n\t\twritew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);\n\t\twritew(HIMT_RECORD_DONE * 0x100 + n, pDAQ + DAQDS_wIntMsg);\n\t\twritew(n, pDAQ + DAQDS_wFlags);\n\t}\n}\n\nstatic const struct snd_pcm_hardware snd_msnd_playback = {\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_BATCH,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t0x3000,\n\t.period_bytes_min =\t0x40,\n\t.period_bytes_max =\t0x1800,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t3,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_msnd_capture = {\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_BATCH,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t0x3000,\n\t.period_bytes_min =\t0x40,\n\t.period_bytes_max =\t0x1800,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t3,\n\t.fifo_size =\t\t0,\n};\n\n\nstatic int snd_msnd_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\tset_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\n\tclear_bit(F_WRITING, &chip->flags);\n\tsnd_msnd_enable_irq(chip);\n\n\truntime->dma_area = (__force void *)chip->mappedbase;\n\truntime->dma_addr = chip->base;\n\truntime->dma_bytes = 0x3000;\n\n\tchip->playback_substream = substream;\n\truntime->hw = snd_msnd_playback;\n\treturn 0;\n}\n\nstatic int snd_msnd_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_msnd_disable_irq(chip);\n\tclear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);\n\treturn 0;\n}\n\n\nstatic int snd_msnd_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tint\ti;\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\tvoid\t__iomem *pDAQ =\tchip->mappedbase + DAPQ_DATA_BUFF;\n\n\tchip->play_sample_size = snd_pcm_format_width(params_format(params));\n\tchip->play_channels = params_channels(params);\n\tchip->play_sample_rate = params_rate(params);\n\n\tfor (i = 0; i < 3; ++i, pDAQ += DAQDS__size) {\n\t\twritew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);\n\t\twritew(chip->play_channels, pDAQ + DAQDS_wChannels);\n\t\twritew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);\n\t}\n\t \n\n\treturn 0;\n}\n\nstatic int snd_msnd_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\tunsigned int pcm_size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int pcm_count = snd_pcm_lib_period_bytes(substream);\n\tunsigned int pcm_periods = pcm_size / pcm_count;\n\n\tsnd_msnd_play_reset_queue(chip, pcm_periods, pcm_count);\n\tchip->playDMAPos = 0;\n\treturn 0;\n}\n\nstatic int snd_msnd_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\tint\tresult = 0;\n\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tsnd_printdd(\"snd_msnd_playback_trigger(START)\\n\");\n\t\tchip->banksPlayed = 0;\n\t\tset_bit(F_WRITING, &chip->flags);\n\t\tsnd_msnd_DAPQ(chip, 1);\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tsnd_printdd(\"snd_msnd_playback_trigger(STop)\\n\");\n\t\t \n\t\tclear_bit(F_WRITING, &chip->flags);\n\t\tsnd_msnd_send_dsp_cmd(chip, HDEX_PLAY_STOP);\n\t} else {\n\t\tsnd_printd(KERN_ERR \"snd_msnd_playback_trigger(?????)\\n\");\n\t\tresult = -EINVAL;\n\t}\n\n\tsnd_printdd(\"snd_msnd_playback_trigger() ENDE\\n\");\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t\nsnd_msnd_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\treturn bytes_to_frames(substream->runtime, chip->playDMAPos);\n}\n\n\nstatic const struct snd_pcm_ops snd_msnd_playback_ops = {\n\t.open =\t\tsnd_msnd_playback_open,\n\t.close =\tsnd_msnd_playback_close,\n\t.hw_params =\tsnd_msnd_playback_hw_params,\n\t.prepare =\tsnd_msnd_playback_prepare,\n\t.trigger =\tsnd_msnd_playback_trigger,\n\t.pointer =\tsnd_msnd_playback_pointer,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic int snd_msnd_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\tset_bit(F_AUDIO_READ_INUSE, &chip->flags);\n\tsnd_msnd_enable_irq(chip);\n\truntime->dma_area = (__force void *)chip->mappedbase + 0x3000;\n\truntime->dma_addr = chip->base + 0x3000;\n\truntime->dma_bytes = 0x3000;\n\tmemset(runtime->dma_area, 0, runtime->dma_bytes);\n\tchip->capture_substream = substream;\n\truntime->hw = snd_msnd_capture;\n\treturn 0;\n}\n\nstatic int snd_msnd_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_msnd_disable_irq(chip);\n\tclear_bit(F_AUDIO_READ_INUSE, &chip->flags);\n\treturn 0;\n}\n\nstatic int snd_msnd_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\tunsigned int pcm_size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int pcm_count = snd_pcm_lib_period_bytes(substream);\n\tunsigned int pcm_periods = pcm_size / pcm_count;\n\n\tsnd_msnd_capture_reset_queue(chip, pcm_periods, pcm_count);\n\tchip->captureDMAPos = 0;\n\treturn 0;\n}\n\nstatic int snd_msnd_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tchip->last_recbank = -1;\n\t\tset_bit(F_READING, &chip->flags);\n\t\tif (snd_msnd_send_dsp_cmd(chip, HDEX_RECORD_START) == 0)\n\t\t\treturn 0;\n\n\t\tclear_bit(F_READING, &chip->flags);\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tclear_bit(F_READING, &chip->flags);\n\t\tsnd_msnd_send_dsp_cmd(chip, HDEX_RECORD_STOP);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic snd_pcm_uframes_t\nsnd_msnd_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\n\treturn bytes_to_frames(runtime, chip->captureDMAPos);\n}\n\n\nstatic int snd_msnd_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tint\t\ti;\n\tstruct snd_msnd *chip = snd_pcm_substream_chip(substream);\n\tvoid\t\t__iomem *pDAQ = chip->mappedbase + DARQ_DATA_BUFF;\n\n\tchip->capture_sample_size = snd_pcm_format_width(params_format(params));\n\tchip->capture_channels = params_channels(params);\n\tchip->capture_sample_rate = params_rate(params);\n\n\tfor (i = 0; i < 3; ++i, pDAQ += DAQDS__size) {\n\t\twritew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);\n\t\twritew(chip->capture_channels, pDAQ + DAQDS_wChannels);\n\t\twritew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);\n\t}\n\treturn 0;\n}\n\n\nstatic const struct snd_pcm_ops snd_msnd_capture_ops = {\n\t.open =\t\tsnd_msnd_capture_open,\n\t.close =\tsnd_msnd_capture_close,\n\t.hw_params =\tsnd_msnd_capture_hw_params,\n\t.prepare =\tsnd_msnd_capture_prepare,\n\t.trigger =\tsnd_msnd_capture_trigger,\n\t.pointer =\tsnd_msnd_capture_pointer,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\n\nint snd_msnd_pcm(struct snd_card *card, int device)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tstruct snd_pcm\t*pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, \"MSNDPINNACLE\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_msnd_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_msnd_capture_ops);\n\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"Hurricane\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_msnd_pcm);\n\nMODULE_DESCRIPTION(\"Common routines for Turtle Beach Multisound drivers\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}