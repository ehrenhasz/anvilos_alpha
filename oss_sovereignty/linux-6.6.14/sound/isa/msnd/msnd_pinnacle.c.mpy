{
  "module_name": "msnd_pinnacle.c",
  "hash_id": "7efc28ccf46ddf363192b299b36939cd737903a0d897535e1ecc0fe6c9e9592e",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/msnd/msnd_pinnacle.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/firmware.h>\n#include <linux/isa.h>\n#include <linux/isapnp.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/asound.h>\n#include <sound/pcm.h>\n#include <sound/mpu401.h>\n\n#ifdef MSND_CLASSIC\n# ifndef __alpha__\n#  define SLOWIO\n# endif\n#endif\n#include \"msnd.h\"\n#ifdef MSND_CLASSIC\n#  include \"msnd_classic.h\"\n#  define LOGNAME\t\t\t\"msnd_classic\"\n#  define DEV_NAME\t\t\t\"msnd-classic\"\n#else\n#  include \"msnd_pinnacle.h\"\n#  define LOGNAME\t\t\t\"snd_msnd_pinnacle\"\n#  define DEV_NAME\t\t\t\"msnd-pinnacle\"\n#endif\n\nstatic void set_default_audio_parameters(struct snd_msnd *chip)\n{\n\tchip->play_sample_size = snd_pcm_format_width(DEFSAMPLESIZE);\n\tchip->play_sample_rate = DEFSAMPLERATE;\n\tchip->play_channels = DEFCHANNELS;\n\tchip->capture_sample_size = snd_pcm_format_width(DEFSAMPLESIZE);\n\tchip->capture_sample_rate = DEFSAMPLERATE;\n\tchip->capture_channels = DEFCHANNELS;\n}\n\nstatic void snd_msnd_eval_dsp_msg(struct snd_msnd *chip, u16 wMessage)\n{\n\tswitch (HIBYTE(wMessage)) {\n\tcase HIMT_PLAY_DONE: {\n\t\tif (chip->banksPlayed < 3)\n\t\t\tsnd_printdd(\"%08X: HIMT_PLAY_DONE: %i\\n\",\n\t\t\t\t(unsigned)jiffies, LOBYTE(wMessage));\n\n\t\tif (chip->last_playbank == LOBYTE(wMessage)) {\n\t\t\tsnd_printdd(\"chip.last_playbank == LOBYTE(wMessage)\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tchip->banksPlayed++;\n\n\t\tif (test_bit(F_WRITING, &chip->flags))\n\t\t\tsnd_msnd_DAPQ(chip, 0);\n\n\t\tchip->last_playbank = LOBYTE(wMessage);\n\t\tchip->playDMAPos += chip->play_period_bytes;\n\t\tif (chip->playDMAPos > chip->playLimit)\n\t\t\tchip->playDMAPos = 0;\n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\n\t\tbreak;\n\t}\n\tcase HIMT_RECORD_DONE:\n\t\tif (chip->last_recbank == LOBYTE(wMessage))\n\t\t\tbreak;\n\t\tchip->last_recbank = LOBYTE(wMessage);\n\t\tchip->captureDMAPos += chip->capturePeriodBytes;\n\t\tif (chip->captureDMAPos > (chip->captureLimit))\n\t\t\tchip->captureDMAPos = 0;\n\n\t\tif (test_bit(F_READING, &chip->flags))\n\t\t\tsnd_msnd_DARQ(chip, chip->last_recbank);\n\n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\tbreak;\n\n\tcase HIMT_DSP:\n\t\tswitch (LOBYTE(wMessage)) {\n#ifndef MSND_CLASSIC\n\t\tcase HIDSP_PLAY_UNDER:\n#endif\n\t\tcase HIDSP_INT_PLAY_UNDER:\n\t\t\tsnd_printd(KERN_WARNING LOGNAME \": Play underflow %i\\n\",\n\t\t\t\tchip->banksPlayed);\n\t\t\tif (chip->banksPlayed > 2)\n\t\t\t\tclear_bit(F_WRITING, &chip->flags);\n\t\t\tbreak;\n\n\t\tcase HIDSP_INT_RECORD_OVER:\n\t\t\tsnd_printd(KERN_WARNING LOGNAME \": Record overflow\\n\");\n\t\t\tclear_bit(F_READING, &chip->flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnd_printd(KERN_WARNING LOGNAME\n\t\t\t\t   \": DSP message %d 0x%02x\\n\",\n\t\t\t\t   LOBYTE(wMessage), LOBYTE(wMessage));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase HIMT_MIDI_IN_UCHAR:\n\t\tif (chip->msndmidi_mpu)\n\t\t\tsnd_msndmidi_input_read(chip->msndmidi_mpu);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_printd(KERN_WARNING LOGNAME \": HIMT message %d 0x%02x\\n\",\n\t\t\t   HIBYTE(wMessage), HIBYTE(wMessage));\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid __iomem *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\tu16 head, tail, size;\n\n\t \n\t \n\n\t \n\thead = readw(chip->DSPQ + JQS_wHead);\n\ttail = readw(chip->DSPQ + JQS_wTail);\n\tsize = readw(chip->DSPQ + JQS_wSize);\n\tif (head > size || tail > size)\n\t\tgoto out;\n\twhile (head != tail) {\n\t\tsnd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));\n\t\tif (++head > size)\n\t\t\thead = 0;\n\t\twritew(head, chip->DSPQ + JQS_wHead);\n\t}\n out:\n\t \n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int snd_msnd_reset_dsp(long io, unsigned char *info)\n{\n\tint timeout = 100;\n\n\toutb(HPDSPRESET_ON, io + HP_DSPR);\n\tmsleep(1);\n#ifndef MSND_CLASSIC\n\tif (info)\n\t\t*info = inb(io + HP_INFO);\n#endif\n\toutb(HPDSPRESET_OFF, io + HP_DSPR);\n\tmsleep(1);\n\twhile (timeout-- > 0) {\n\t\tif (inb(io + HP_CVR) == HP_CVR_DEF)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\tsnd_printk(KERN_ERR LOGNAME \": Cannot reset DSP\\n\");\n\n\treturn -EIO;\n}\n\nstatic int snd_msnd_probe(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tunsigned char info;\n#ifndef MSND_CLASSIC\n\tchar *xv, *rev = NULL;\n\tchar *pin = \"TB Pinnacle\", *fiji = \"TB Fiji\";\n\tchar *pinfiji = \"TB Pinnacle/Fiji\";\n#endif\n\n\tif (!request_region(chip->io, DSP_NUMIO, \"probing\")) {\n\t\tsnd_printk(KERN_ERR LOGNAME \": I/O port conflict\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (snd_msnd_reset_dsp(chip->io, &info) < 0) {\n\t\trelease_region(chip->io, DSP_NUMIO);\n\t\treturn -ENODEV;\n\t}\n\n#ifdef MSND_CLASSIC\n\tstrcpy(card->shortname, \"Classic/Tahiti/Monterey\");\n\tstrcpy(card->longname, \"Turtle Beach Multisound\");\n\tprintk(KERN_INFO LOGNAME \": %s, \"\n\t       \"I/O 0x%lx-0x%lx, IRQ %d, memory mapped to 0x%lX-0x%lX\\n\",\n\t       card->shortname,\n\t       chip->io, chip->io + DSP_NUMIO - 1,\n\t       chip->irq,\n\t       chip->base, chip->base + 0x7fff);\n#else\n\tswitch (info >> 4) {\n\tcase 0xf:\n\t\txv = \"<= 1.15\";\n\t\tbreak;\n\tcase 0x1:\n\t\txv = \"1.18/1.2\";\n\t\tbreak;\n\tcase 0x2:\n\t\txv = \"1.3\";\n\t\tbreak;\n\tcase 0x3:\n\t\txv = \"1.4\";\n\t\tbreak;\n\tdefault:\n\t\txv = \"unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (info & 0x7) {\n\tcase 0x0:\n\t\trev = \"I\";\n\t\tstrcpy(card->shortname, pin);\n\t\tbreak;\n\tcase 0x1:\n\t\trev = \"F\";\n\t\tstrcpy(card->shortname, pin);\n\t\tbreak;\n\tcase 0x2:\n\t\trev = \"G\";\n\t\tstrcpy(card->shortname, pin);\n\t\tbreak;\n\tcase 0x3:\n\t\trev = \"H\";\n\t\tstrcpy(card->shortname, pin);\n\t\tbreak;\n\tcase 0x4:\n\t\trev = \"E\";\n\t\tstrcpy(card->shortname, fiji);\n\t\tbreak;\n\tcase 0x5:\n\t\trev = \"C\";\n\t\tstrcpy(card->shortname, fiji);\n\t\tbreak;\n\tcase 0x6:\n\t\trev = \"D\";\n\t\tstrcpy(card->shortname, fiji);\n\t\tbreak;\n\tcase 0x7:\n\t\trev = \"A-B (Fiji) or A-E (Pinnacle)\";\n\t\tstrcpy(card->shortname, pinfiji);\n\t\tbreak;\n\t}\n\tstrcpy(card->longname, \"Turtle Beach Multisound Pinnacle\");\n\tprintk(KERN_INFO LOGNAME \": %s revision %s, Xilinx version %s, \"\n\t       \"I/O 0x%lx-0x%lx, IRQ %d, memory mapped to 0x%lX-0x%lX\\n\",\n\t       card->shortname,\n\t       rev, xv,\n\t       chip->io, chip->io + DSP_NUMIO - 1,\n\t       chip->irq,\n\t       chip->base, chip->base + 0x7fff);\n#endif\n\n\trelease_region(chip->io, DSP_NUMIO);\n\treturn 0;\n}\n\nstatic int snd_msnd_init_sma(struct snd_msnd *chip)\n{\n\tstatic int initted;\n\tu16 mastVolLeft, mastVolRight;\n\tunsigned long flags;\n\n#ifdef MSND_CLASSIC\n\toutb(chip->memid, chip->io + HP_MEMM);\n#endif\n\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n\t \n\tchip->SMA = chip->mappedbase + SMA_STRUCT_START;\n\n\tif (initted) {\n\t\tmastVolLeft = readw(chip->SMA + SMA_wCurrMastVolLeft);\n\t\tmastVolRight = readw(chip->SMA + SMA_wCurrMastVolRight);\n\t} else\n\t\tmastVolLeft = mastVolRight = 0;\n\tmemset_io(chip->mappedbase, 0, 0x8000);\n\n\t \n\tspin_lock_irqsave(&chip->lock, flags);\n\toutb(HPBLKSEL_1, chip->io + HP_BLKS);\n\tmemset_io(chip->mappedbase, 0, 0x8000);\n\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\t \n\tchip->DAPQ = chip->mappedbase + DAPQ_OFFSET;\n\tsnd_msnd_init_queue(chip->DAPQ, DAPQ_DATA_BUFF, DAPQ_BUFF_SIZE);\n\n\t \n\tchip->DARQ = chip->mappedbase + DARQ_OFFSET;\n\tsnd_msnd_init_queue(chip->DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE);\n\n\t \n\tchip->MODQ = chip->mappedbase + MODQ_OFFSET;\n\tsnd_msnd_init_queue(chip->MODQ, MODQ_DATA_BUFF, MODQ_BUFF_SIZE);\n\n\t \n\tchip->MIDQ = chip->mappedbase + MIDQ_OFFSET;\n\tsnd_msnd_init_queue(chip->MIDQ, MIDQ_DATA_BUFF, MIDQ_BUFF_SIZE);\n\n\t \n\tchip->DSPQ = chip->mappedbase + DSPQ_OFFSET;\n\tsnd_msnd_init_queue(chip->DSPQ, DSPQ_DATA_BUFF, DSPQ_BUFF_SIZE);\n\n\t \n#ifndef MSND_CLASSIC\n\twritew(1, chip->SMA + SMA_wCurrPlayFormat);\n\twritew(chip->play_sample_size, chip->SMA + SMA_wCurrPlaySampleSize);\n\twritew(chip->play_channels, chip->SMA + SMA_wCurrPlayChannels);\n\twritew(chip->play_sample_rate, chip->SMA + SMA_wCurrPlaySampleRate);\n#endif\n\twritew(chip->play_sample_rate, chip->SMA + SMA_wCalFreqAtoD);\n\twritew(mastVolLeft, chip->SMA + SMA_wCurrMastVolLeft);\n\twritew(mastVolRight, chip->SMA + SMA_wCurrMastVolRight);\n#ifndef MSND_CLASSIC\n\twritel(0x00010000, chip->SMA + SMA_dwCurrPlayPitch);\n\twritel(0x00000001, chip->SMA + SMA_dwCurrPlayRate);\n#endif\n\twritew(0x303, chip->SMA + SMA_wCurrInputTagBits);\n\n\tinitted = 1;\n\n\treturn 0;\n}\n\n\nstatic int upload_dsp_code(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tconst struct firmware *init_fw = NULL, *perm_fw = NULL;\n\tint err;\n\n\toutb(HPBLKSEL_0, chip->io + HP_BLKS);\n\n\terr = request_firmware(&init_fw, INITCODEFILE, card->dev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Error loading \" INITCODEFILE);\n\t\tgoto cleanup1;\n\t}\n\terr = request_firmware(&perm_fw, PERMCODEFILE, card->dev);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Error loading \" PERMCODEFILE);\n\t\tgoto cleanup;\n\t}\n\n\tmemcpy_toio(chip->mappedbase, perm_fw->data, perm_fw->size);\n\tif (snd_msnd_upload_host(chip, init_fw->data, init_fw->size) < 0) {\n\t\tprintk(KERN_WARNING LOGNAME \": Error uploading to DSP\\n\");\n\t\terr = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\tprintk(KERN_INFO LOGNAME \": DSP firmware uploaded\\n\");\n\terr = 0;\n\ncleanup:\n\trelease_firmware(perm_fw);\ncleanup1:\n\trelease_firmware(init_fw);\n\treturn err;\n}\n\n#ifdef MSND_CLASSIC\nstatic void reset_proteus(struct snd_msnd *chip)\n{\n\toutb(HPPRORESET_ON, chip->io + HP_PROR);\n\tmsleep(TIME_PRO_RESET);\n\toutb(HPPRORESET_OFF, chip->io + HP_PROR);\n\tmsleep(TIME_PRO_RESET_DONE);\n}\n#endif\n\nstatic int snd_msnd_initialize(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tint err, timeout;\n\n#ifdef MSND_CLASSIC\n\toutb(HPWAITSTATE_0, chip->io + HP_WAIT);\n\toutb(HPBITMODE_16, chip->io + HP_BITM);\n\n\treset_proteus(chip);\n#endif\n\terr = snd_msnd_init_sma(chip);\n\tif (err < 0) {\n\t\tprintk(KERN_WARNING LOGNAME \": Cannot initialize SMA\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_msnd_reset_dsp(chip->io, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = upload_dsp_code(card);\n\tif (err < 0) {\n\t\tprintk(KERN_WARNING LOGNAME \": Cannot upload DSP code\\n\");\n\t\treturn err;\n\t}\n\n\ttimeout = 200;\n\n\twhile (readw(chip->mappedbase)) {\n\t\tmsleep(1);\n\t\tif (!timeout--) {\n\t\t\tsnd_printd(KERN_ERR LOGNAME \": DSP reset timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tsnd_msndmix_setup(chip);\n\treturn 0;\n}\n\nstatic int snd_msnd_dsp_full_reset(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tint rv;\n\n\tif (test_bit(F_RESETTING, &chip->flags) || ++chip->nresets > 10)\n\t\treturn 0;\n\n\tset_bit(F_RESETTING, &chip->flags);\n\tsnd_msnd_dsp_halt(chip, NULL);\t \n\n\trv = snd_msnd_initialize(card);\n\tif (rv)\n\t\tprintk(KERN_WARNING LOGNAME \": DSP reset failed\\n\");\n\tsnd_msndmix_force_recsrc(chip, 0);\n\tclear_bit(F_RESETTING, &chip->flags);\n\treturn rv;\n}\n\n\nstatic int snd_msnd_send_dsp_cmd_chk(struct snd_msnd *chip, u8 cmd)\n{\n\tif (snd_msnd_send_dsp_cmd(chip, cmd) == 0)\n\t\treturn 0;\n\tsnd_msnd_dsp_full_reset(chip->card);\n\treturn snd_msnd_send_dsp_cmd(chip, cmd);\n}\n\nstatic int snd_msnd_calibrate_adc(struct snd_msnd *chip, u16 srate)\n{\n\tsnd_printdd(\"snd_msnd_calibrate_adc(%i)\\n\", srate);\n\twritew(srate, chip->SMA + SMA_wCalFreqAtoD);\n\tif (chip->calibrate_signal == 0)\n\t\twritew(readw(chip->SMA + SMA_wCurrHostStatusFlags)\n\t\t       | 0x0001, chip->SMA + SMA_wCurrHostStatusFlags);\n\telse\n\t\twritew(readw(chip->SMA + SMA_wCurrHostStatusFlags)\n\t\t       & ~0x0001, chip->SMA + SMA_wCurrHostStatusFlags);\n\tif (snd_msnd_send_word(chip, 0, 0, HDEXAR_CAL_A_TO_D) == 0 &&\n\t    snd_msnd_send_dsp_cmd_chk(chip, HDEX_AUX_REQ) == 0) {\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(333));\n\t\treturn 0;\n\t}\n\tprintk(KERN_WARNING LOGNAME \": ADC calibration failed\\n\");\n\treturn -EIO;\n}\n\n \nstatic int snd_msnd_mpu401_open(struct snd_mpu401 *mpu)\n{\n\tsnd_msnd_enable_irq(mpu->private_data);\n\tsnd_msnd_send_dsp_cmd(mpu->private_data, HDEX_MIDI_IN_START);\n\treturn 0;\n}\n\nstatic void snd_msnd_mpu401_close(struct snd_mpu401 *mpu)\n{\n\tsnd_msnd_send_dsp_cmd(mpu->private_data, HDEX_MIDI_IN_STOP);\n\tsnd_msnd_disable_irq(mpu->private_data);\n}\n\nstatic long mpu_io[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\n\nstatic int snd_msnd_attach(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tint err;\n\n\terr = devm_request_irq(card->dev, chip->irq, snd_msnd_interrupt, 0,\n\t\t\t       card->shortname, chip);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Couldn't grab IRQ %d\\n\", chip->irq);\n\t\treturn err;\n\t}\n\tcard->sync_irq = chip->irq;\n\tif (!devm_request_region(card->dev, chip->io, DSP_NUMIO,\n\t\t\t\t card->shortname))\n\t\treturn -EBUSY;\n\n\tif (!devm_request_mem_region(card->dev, chip->base, BUFFSIZE,\n\t\t\t\t     card->shortname)) {\n\t\tprintk(KERN_ERR LOGNAME\n\t\t\t\": unable to grab memory region 0x%lx-0x%lx\\n\",\n\t\t\tchip->base, chip->base + BUFFSIZE - 1);\n\t\treturn -EBUSY;\n\t}\n\tchip->mappedbase = devm_ioremap(card->dev, chip->base, 0x8000);\n\tif (!chip->mappedbase) {\n\t\tprintk(KERN_ERR LOGNAME\n\t\t\t\": unable to map memory region 0x%lx-0x%lx\\n\",\n\t\t\tchip->base, chip->base + BUFFSIZE - 1);\n\t\treturn -EIO;\n\t}\n\n\terr = snd_msnd_dsp_full_reset(card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_msnd_pcm(card, 0);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": error creating new PCM device\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_msndmix_new(card);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": error creating new Mixer device\\n\");\n\t\treturn err;\n\t}\n\n\n\tif (mpu_io[0] != SNDRV_AUTO_PORT) {\n\t\tstruct snd_mpu401 *mpu;\n\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\t\t  mpu_io[0],\n\t\t\t\t\t  MPU401_MODE_INPUT |\n\t\t\t\t\t  MPU401_MODE_OUTPUT,\n\t\t\t\t\t  mpu_irq[0],\n\t\t\t\t\t  &chip->rmidi);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR LOGNAME\n\t\t\t\t\": error creating new Midi device\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tmpu = chip->rmidi->private_data;\n\n\t\tmpu->open_input = snd_msnd_mpu401_open;\n\t\tmpu->close_input = snd_msnd_mpu401_close;\n\t\tmpu->private_data = chip;\n\t}\n\n\tdisable_irq(chip->irq);\n\tsnd_msnd_calibrate_adc(chip, chip->play_sample_rate);\n\tsnd_msndmix_force_recsrc(chip, 0);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n#ifndef MSND_CLASSIC\n\n \n\nstatic int snd_msnd_write_cfg(int cfg, int reg, int value)\n{\n\toutb(reg, cfg);\n\toutb(value, cfg + 1);\n\tif (value != inb(cfg + 1)) {\n\t\tprintk(KERN_ERR LOGNAME \": snd_msnd_write_cfg: I/O error\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int snd_msnd_write_cfg_io0(int cfg, int num, u16 io)\n{\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IO0_BASEHI, HIBYTE(io)))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IO0_BASELO, LOBYTE(io)))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_write_cfg_io1(int cfg, int num, u16 io)\n{\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IO1_BASEHI, HIBYTE(io)))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IO1_BASELO, LOBYTE(io)))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_write_cfg_irq(int cfg, int num, u16 irq)\n{\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IRQ_NUMBER, LOBYTE(irq)))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_IRQ_TYPE, IRQTYPE_EDGE))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_write_cfg_mem(int cfg, int num, int mem)\n{\n\tu16 wmem;\n\n\tmem >>= 8;\n\twmem = (u16)(mem & 0xfff);\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_MEMBASEHI, HIBYTE(wmem)))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_MEMBASELO, LOBYTE(wmem)))\n\t\treturn -EIO;\n\tif (wmem && snd_msnd_write_cfg(cfg, IREG_MEMCONTROL,\n\t\t\t\t       MEMTYPE_HIADDR | MEMTYPE_16BIT))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_activate_logical(int cfg, int num)\n{\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_ACTIVATE, LD_ACTIVATE))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_write_cfg_logical(int cfg, int num, u16 io0,\n\t\t\t\t      u16 io1, u16 irq, int mem)\n{\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg_io0(cfg, num, io0))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg_io1(cfg, num, io1))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg_irq(cfg, num, irq))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg_mem(cfg, num, mem))\n\t\treturn -EIO;\n\tif (snd_msnd_activate_logical(cfg, num))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_msnd_pinnacle_cfg_reset(int cfg)\n{\n\tint i;\n\n\t \n\tprintk(KERN_INFO LOGNAME \": Resetting all devices\\n\");\n\tfor (i = 0; i < 4; ++i)\n\t\tif (snd_msnd_write_cfg_logical(cfg, i, 0, 0, 0, 0))\n\t\t\treturn -EIO;\n\n\treturn 0;\n}\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for msnd_pinnacle soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for msnd_pinnacle soundcard.\");\n\nstatic long io[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic long mem[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n\n#ifndef MSND_CLASSIC\nstatic long cfg[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n\n \nstatic long ide_io0[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long ide_io1[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int ide_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\n\nstatic long joystick_io[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n \nstatic int digital[SNDRV_CARDS];\n\n \nstatic int reset[SNDRV_CARDS];\n#endif\n\nstatic int write_ndelay[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 1 };\n\nstatic int calibrate_signal;\n\n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"ISA PnP detection for specified soundcard.\");\n#define has_isapnp(x) isapnp[x]\n#else\n#define has_isapnp(x) 0\n#endif\n\nMODULE_AUTHOR(\"Karsten Wiese <annabellesgarden@yahoo.de>\");\nMODULE_DESCRIPTION(\"Turtle Beach \" LONGNAME \" Linux Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(INITCODEFILE);\nMODULE_FIRMWARE(PERMCODEFILE);\n\nmodule_param_hw_array(io, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(io, \"IO port #\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nmodule_param_hw_array(mem, long, iomem, NULL, 0444);\nmodule_param_array(write_ndelay, int, NULL, 0444);\nmodule_param(calibrate_signal, int, 0444);\n#ifndef MSND_CLASSIC\nmodule_param_array(digital, int, NULL, 0444);\nmodule_param_hw_array(cfg, long, ioport, NULL, 0444);\nmodule_param_array(reset, int, NULL, 0444);\nmodule_param_hw_array(mpu_io, long, ioport, NULL, 0444);\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nmodule_param_hw_array(ide_io0, long, ioport, NULL, 0444);\nmodule_param_hw_array(ide_io1, long, ioport, NULL, 0444);\nmodule_param_hw_array(ide_irq, int, irq, NULL, 0444);\nmodule_param_hw_array(joystick_io, long, ioport, NULL, 0444);\n#endif\n\n\nstatic int snd_msnd_isa_match(struct device *pdev, unsigned int i)\n{\n\tif (io[i] == SNDRV_AUTO_PORT)\n\t\treturn 0;\n\n\tif (irq[i] == SNDRV_AUTO_PORT || mem[i] == SNDRV_AUTO_PORT) {\n\t\tprintk(KERN_WARNING LOGNAME \": io, irq and mem must be set\\n\");\n\t\treturn 0;\n\t}\n\n#ifdef MSND_CLASSIC\n\tif (!(io[i] == 0x290 ||\n\t      io[i] == 0x260 ||\n\t      io[i] == 0x250 ||\n\t      io[i] == 0x240 ||\n\t      io[i] == 0x230 ||\n\t      io[i] == 0x220 ||\n\t      io[i] == 0x210 ||\n\t      io[i] == 0x3e0)) {\n\t\tprintk(KERN_ERR LOGNAME \": \\\"io\\\" - DSP I/O base must be set \"\n\t\t\t\" to 0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x290, \"\n\t\t\t\"or 0x3E0\\n\");\n\t\treturn 0;\n\t}\n#else\n\tif (io[i] < 0x100 || io[i] > 0x3e0 || (io[i] % 0x10) != 0) {\n\t\tprintk(KERN_ERR LOGNAME\n\t\t\t\": \\\"io\\\" - DSP I/O base must within the range 0x100 \"\n\t\t\t\"to 0x3E0 and must be evenly divisible by 0x10\\n\");\n\t\treturn 0;\n\t}\n#endif  \n\n\tif (!(irq[i] == 5 ||\n\t      irq[i] == 7 ||\n\t      irq[i] == 9 ||\n\t      irq[i] == 10 ||\n\t      irq[i] == 11 ||\n\t      irq[i] == 12)) {\n\t\tprintk(KERN_ERR LOGNAME\n\t\t\t\": \\\"irq\\\" - must be set to 5, 7, 9, 10, 11 or 12\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(mem[i] == 0xb0000 ||\n\t      mem[i] == 0xc8000 ||\n\t      mem[i] == 0xd0000 ||\n\t      mem[i] == 0xd8000 ||\n\t      mem[i] == 0xe0000 ||\n\t      mem[i] == 0xe8000)) {\n\t\tprintk(KERN_ERR LOGNAME \": \\\"mem\\\" - must be set to \"\n\t\t       \"0xb0000, 0xc8000, 0xd0000, 0xd8000, 0xe0000 or \"\n\t\t       \"0xe8000\\n\");\n\t\treturn 0;\n\t}\n\n#ifndef MSND_CLASSIC\n\tif (cfg[i] == SNDRV_AUTO_PORT) {\n\t\tprintk(KERN_INFO LOGNAME \": Assuming PnP mode\\n\");\n\t} else if (cfg[i] != 0x250 && cfg[i] != 0x260 && cfg[i] != 0x270) {\n\t\tprintk(KERN_INFO LOGNAME\n\t\t\t\": Config port must be 0x250, 0x260 or 0x270 \"\n\t\t\t\"(or unspecified for PnP mode)\\n\");\n\t\treturn 0;\n\t}\n#endif  \n\n\treturn 1;\n}\n\nstatic int snd_msnd_isa_probe(struct device *pdev, unsigned int idx)\n{\n\tint err;\n\tstruct snd_card *card;\n\tstruct snd_msnd *chip;\n\n\tif (has_isapnp(idx)\n#ifndef MSND_CLASSIC\n\t    || cfg[idx] == SNDRV_AUTO_PORT\n#endif\n\t    ) {\n\t\tprintk(KERN_INFO LOGNAME \": Assuming PnP mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_devm_card_new(pdev, index[idx], id[idx], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_msnd), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip = card->private_data;\n\tchip->card = card;\n\n#ifdef MSND_CLASSIC\n\tswitch (irq[idx]) {\n\tcase 5:\n\t\tchip->irqid = HPIRQ_5; break;\n\tcase 7:\n\t\tchip->irqid = HPIRQ_7; break;\n\tcase 9:\n\t\tchip->irqid = HPIRQ_9; break;\n\tcase 10:\n\t\tchip->irqid = HPIRQ_10; break;\n\tcase 11:\n\t\tchip->irqid = HPIRQ_11; break;\n\tcase 12:\n\t\tchip->irqid = HPIRQ_12; break;\n\t}\n\n\tswitch (mem[idx]) {\n\tcase 0xb0000:\n\t\tchip->memid = HPMEM_B000; break;\n\tcase 0xc8000:\n\t\tchip->memid = HPMEM_C800; break;\n\tcase 0xd0000:\n\t\tchip->memid = HPMEM_D000; break;\n\tcase 0xd8000:\n\t\tchip->memid = HPMEM_D800; break;\n\tcase 0xe0000:\n\t\tchip->memid = HPMEM_E000; break;\n\tcase 0xe8000:\n\t\tchip->memid = HPMEM_E800; break;\n\t}\n#else\n\tprintk(KERN_INFO LOGNAME \": Non-PnP mode: configuring at port 0x%lx\\n\",\n\t\t\tcfg[idx]);\n\n\tif (!devm_request_region(card->dev, cfg[idx], 2,\n\t\t\t\t \"Pinnacle/Fiji Config\")) {\n\t\tprintk(KERN_ERR LOGNAME \": Config port 0x%lx conflict\\n\",\n\t\t\t   cfg[idx]);\n\t\treturn -EIO;\n\t}\n\tif (reset[idx])\n\t\tif (snd_msnd_pinnacle_cfg_reset(cfg[idx]))\n\t\t\treturn -EIO;\n\n\t \n\terr = snd_msnd_write_cfg_logical(cfg[idx], 0,\n\t\t\t\t\t io[idx], 0,\n\t\t\t\t\t irq[idx], mem[idx]);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\n\t \n\tif (mpu_io[idx] != SNDRV_AUTO_PORT\n\t    && mpu_irq[idx] != SNDRV_AUTO_IRQ) {\n\t\tprintk(KERN_INFO LOGNAME\n\t\t       \": Configuring MPU to I/O 0x%lx IRQ %d\\n\",\n\t\t       mpu_io[idx], mpu_irq[idx]);\n\t\terr = snd_msnd_write_cfg_logical(cfg[idx], 1,\n\t\t\t\t\t\t mpu_io[idx], 0,\n\t\t\t\t\t\t mpu_irq[idx], 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ide_io0[idx] != SNDRV_AUTO_PORT\n\t    && ide_io1[idx] != SNDRV_AUTO_PORT\n\t    && ide_irq[idx] != SNDRV_AUTO_IRQ) {\n\t\tprintk(KERN_INFO LOGNAME\n\t\t       \": Configuring IDE to I/O 0x%lx, 0x%lx IRQ %d\\n\",\n\t\t       ide_io0[idx], ide_io1[idx], ide_irq[idx]);\n\t\terr = snd_msnd_write_cfg_logical(cfg[idx], 2,\n\t\t\t\t\t\t ide_io0[idx], ide_io1[idx],\n\t\t\t\t\t\t ide_irq[idx], 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (joystick_io[idx] != SNDRV_AUTO_PORT) {\n\t\tprintk(KERN_INFO LOGNAME\n\t\t       \": Configuring joystick to I/O 0x%lx\\n\",\n\t\t       joystick_io[idx]);\n\t\terr = snd_msnd_write_cfg_logical(cfg[idx], 3,\n\t\t\t\t\t\t joystick_io[idx], 0,\n\t\t\t\t\t\t 0, 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#endif  \n\n\tset_default_audio_parameters(chip);\n#ifdef MSND_CLASSIC\n\tchip->type = msndClassic;\n#else\n\tchip->type = msndPinnacle;\n#endif\n\tchip->io = io[idx];\n\tchip->irq = irq[idx];\n\tchip->base = mem[idx];\n\n\tchip->calibrate_signal = calibrate_signal ? 1 : 0;\n\tchip->recsrc = 0;\n\tchip->dspq_data_buff = DSPQ_DATA_BUFF;\n\tchip->dspq_buff_size = DSPQ_BUFF_SIZE;\n\tif (write_ndelay[idx])\n\t\tclear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\n\telse\n\t\tset_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\n#ifndef MSND_CLASSIC\n\tif (digital[idx])\n\t\tset_bit(F_HAVEDIGITAL, &chip->flags);\n#endif\n\tspin_lock_init(&chip->lock);\n\terr = snd_msnd_probe(card);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Probe failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_msnd_attach(card);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Attach failed\\n\");\n\t\treturn err;\n\t}\n\tdev_set_drvdata(pdev, card);\n\n\treturn 0;\n}\n\nstatic struct isa_driver snd_msnd_driver = {\n\t.match\t\t= snd_msnd_isa_match,\n\t.probe\t\t= snd_msnd_isa_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n#ifdef CONFIG_PNP\nstatic int snd_msnd_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t       const struct pnp_card_device_id *pid)\n{\n\tstatic int idx;\n\tstruct pnp_dev *pnp_dev;\n\tstruct pnp_dev *mpu_dev;\n\tstruct snd_card *card;\n\tstruct snd_msnd *chip;\n\tint ret;\n\n\tfor ( ; idx < SNDRV_CARDS; idx++) {\n\t\tif (has_isapnp(idx))\n\t\t\tbreak;\n\t}\n\tif (idx >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\t \n\tpnp_dev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\n\tif (!pnp_dev)\n\t\treturn -ENODEV;\n\n\tmpu_dev = pnp_request_card_device(pcard, pid->devs[1].id, NULL);\n\tif (!mpu_dev)\n\t\treturn -ENODEV;\n\n\tif (!pnp_is_active(pnp_dev) && pnp_activate_dev(pnp_dev) < 0) {\n\t\tprintk(KERN_INFO \"msnd_pinnacle: device is inactive\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!pnp_is_active(mpu_dev) && pnp_activate_dev(mpu_dev) < 0) {\n\t\tprintk(KERN_INFO \"msnd_pinnacle: MPU device is inactive\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = snd_devm_card_new(&pcard->card->dev,\n\t\t\t\tindex[idx], id[idx], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_msnd), &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip = card->private_data;\n\tchip->card = card;\n\n\t \n\tio[idx] = pnp_port_start(pnp_dev, 0);\n\tirq[idx] = pnp_irq(pnp_dev, 0);\n\tmem[idx] = pnp_mem_start(pnp_dev, 0);\n\tmpu_io[idx] = pnp_port_start(mpu_dev, 0);\n\tmpu_irq[idx] = pnp_irq(mpu_dev, 0);\n\n\tset_default_audio_parameters(chip);\n#ifdef MSND_CLASSIC\n\tchip->type = msndClassic;\n#else\n\tchip->type = msndPinnacle;\n#endif\n\tchip->io = io[idx];\n\tchip->irq = irq[idx];\n\tchip->base = mem[idx];\n\n\tchip->calibrate_signal = calibrate_signal ? 1 : 0;\n\tchip->recsrc = 0;\n\tchip->dspq_data_buff = DSPQ_DATA_BUFF;\n\tchip->dspq_buff_size = DSPQ_BUFF_SIZE;\n\tif (write_ndelay[idx])\n\t\tclear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\n\telse\n\t\tset_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);\n#ifndef MSND_CLASSIC\n\tif (digital[idx])\n\t\tset_bit(F_HAVEDIGITAL, &chip->flags);\n#endif\n\tspin_lock_init(&chip->lock);\n\tret = snd_msnd_probe(card);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Probe failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_msnd_attach(card);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR LOGNAME \": Attach failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpnp_set_card_drvdata(pcard, card);\n\t++idx;\n\treturn 0;\n}\n\nstatic int isa_registered;\nstatic int pnp_registered;\n\nstatic const struct pnp_card_device_id msnd_pnpids[] = {\n\t \n\t{ .id = \"BVJ0440\", .devs = { { \"TBS0000\" }, { \"TBS0001\" } } },\n\t{ .id = \"\" }\t \n};\n\nMODULE_DEVICE_TABLE(pnp_card, msnd_pnpids);\n\nstatic struct pnp_card_driver msnd_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.name = \"msnd_pinnacle\",\n\t.id_table = msnd_pnpids,\n\t.probe = snd_msnd_pnp_detect,\n};\n#endif  \n\nstatic int __init snd_msnd_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_msnd_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&msnd_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit snd_msnd_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&msnd_pnpc_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_msnd_driver);\n}\n\nmodule_init(snd_msnd_init);\nmodule_exit(snd_msnd_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}