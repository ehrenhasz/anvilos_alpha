{
  "module_name": "msnd_pinnacle_mixer.c",
  "hash_id": "33adbfcbb4cc1ee353210efdd64096680baf586699e45f80c6945639d337d3ac",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/msnd/msnd_pinnacle_mixer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/export.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include \"msnd.h\"\n#include \"msnd_pinnacle.h\"\n\n\n#define MSND_MIXER_VOLUME\t0\n#define MSND_MIXER_PCM\t\t1\n#define MSND_MIXER_AUX\t\t2\t \n#define MSND_MIXER_IMIX\t\t3\t \n#define MSND_MIXER_SYNTH\t4\n#define MSND_MIXER_SPEAKER\t5\n#define MSND_MIXER_LINE\t\t6\n#define MSND_MIXER_MIC\t\t7\n#define MSND_MIXER_RECLEV\t11\t \n#define MSND_MIXER_IGAIN\t12\t \n#define MSND_MIXER_OGAIN\t13\t \n#define MSND_MIXER_DIGITAL\t17\t \n\n \n\n#define MSND_MASK_VOLUME\t(1 << MSND_MIXER_VOLUME)\n#define MSND_MASK_SYNTH\t\t(1 << MSND_MIXER_SYNTH)\n#define MSND_MASK_PCM\t\t(1 << MSND_MIXER_PCM)\n#define MSND_MASK_SPEAKER\t(1 << MSND_MIXER_SPEAKER)\n#define MSND_MASK_LINE\t\t(1 << MSND_MIXER_LINE)\n#define MSND_MASK_MIC\t\t(1 << MSND_MIXER_MIC)\n#define MSND_MASK_IMIX\t\t(1 << MSND_MIXER_IMIX)\n#define MSND_MASK_RECLEV\t(1 << MSND_MIXER_RECLEV)\n#define MSND_MASK_IGAIN\t\t(1 << MSND_MIXER_IGAIN)\n#define MSND_MASK_OGAIN\t\t(1 << MSND_MIXER_OGAIN)\n#define MSND_MASK_AUX\t\t(1 << MSND_MIXER_AUX)\n#define MSND_MASK_DIGITAL\t(1 << MSND_MIXER_DIGITAL)\n\nstatic int snd_msndmix_info_mux(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"Analog\", \"MASS\", \"SPDIF\",\n\t};\n\tstruct snd_msnd *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned items = test_bit(F_HAVEDIGITAL, &chip->flags) ? 3 : 2;\n\n\treturn snd_ctl_enum_info(uinfo, 1, items, texts);\n}\n\nstatic int snd_msndmix_get_mux(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_msnd *chip = snd_kcontrol_chip(kcontrol);\n\t \n\tucontrol->value.enumerated.item[0] = 0;\n\n\tif (chip->recsrc & MSND_MASK_SYNTH) {\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t} else if ((chip->recsrc & MSND_MASK_DIGITAL) &&\n\t\t test_bit(F_HAVEDIGITAL, &chip->flags)) {\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int snd_msndmix_set_mux(struct snd_msnd *chip, int val)\n{\n\tunsigned newrecsrc;\n\tint change;\n\tunsigned char msndbyte;\n\n\tswitch (val) {\n\tcase 0:\n\t\tnewrecsrc = MSND_MASK_IMIX;\n\t\tmsndbyte = HDEXAR_SET_ANA_IN;\n\t\tbreak;\n\tcase 1:\n\t\tnewrecsrc = MSND_MASK_SYNTH;\n\t\tmsndbyte = HDEXAR_SET_SYNTH_IN;\n\t\tbreak;\n\tcase 2:\n\t\tnewrecsrc = MSND_MASK_DIGITAL;\n\t\tmsndbyte = HDEXAR_SET_DAT_IN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tchange  = newrecsrc != chip->recsrc;\n\tif (change) {\n\t\tchange = 0;\n\t\tif (!snd_msnd_send_word(chip, 0, 0, msndbyte))\n\t\t\tif (!snd_msnd_send_dsp_cmd(chip, HDEX_AUX_REQ)) {\n\t\t\t\tchip->recsrc = newrecsrc;\n\t\t\t\tchange = 1;\n\t\t\t}\n\t}\n\treturn change;\n}\n\nstatic int snd_msndmix_put_mux(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\n\treturn snd_msndmix_set_mux(msnd, ucontrol->value.enumerated.item[0]);\n}\n\n\nstatic int snd_msndmix_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\treturn 0;\n}\n\nstatic int snd_msndmix_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\n\tint addr = kcontrol->private_value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&msnd->mixer_lock, flags);\n\tucontrol->value.integer.value[0] = msnd->left_levels[addr] * 100;\n\tucontrol->value.integer.value[0] /= 0xFFFF;\n\tucontrol->value.integer.value[1] = msnd->right_levels[addr] * 100;\n\tucontrol->value.integer.value[1] /= 0xFFFF;\n\tspin_unlock_irqrestore(&msnd->mixer_lock, flags);\n\treturn 0;\n}\n\n#define update_volm(a, b)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\twritew((dev->left_levels[a] >> 1) *\t\t\t\\\n\t\t       readw(dev->SMA + SMA_wCurrMastVolLeft) / 0xffff,\t\\\n\t\t       dev->SMA + SMA_##b##Left);\t\t\t\\\n\t\twritew((dev->right_levels[a] >> 1)  *\t\t\t\\\n\t\t       readw(dev->SMA + SMA_wCurrMastVolRight) / 0xffff, \\\n\t\t       dev->SMA + SMA_##b##Right);\t\t\t\\\n\t} while (0);\n\n#define update_potm(d, s, ar)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\twriteb((dev->left_levels[d] >> 8) *\t\t\t\\\n\t\t       readw(dev->SMA + SMA_wCurrMastVolLeft) / 0xffff, \\\n\t\t       dev->SMA + SMA_##s##Left);\t\t\t\\\n\t\twriteb((dev->right_levels[d] >> 8) *\t\t\t\\\n\t\t       readw(dev->SMA + SMA_wCurrMastVolRight) / 0xffff, \\\n\t\t       dev->SMA + SMA_##s##Right);\t\t\t\\\n\t\tif (snd_msnd_send_word(dev, 0, 0, ar) == 0)\t\t\\\n\t\t\tsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\t\\\n\t} while (0);\n\n#define update_pot(d, s, ar)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\twriteb(dev->left_levels[d] >> 8,\t\t\t\\\n\t\t       dev->SMA + SMA_##s##Left);\t\t\t\\\n\t\twriteb(dev->right_levels[d] >> 8,\t\t\t\\\n\t\t       dev->SMA + SMA_##s##Right);\t\t\t\\\n\t\tif (snd_msnd_send_word(dev, 0, 0, ar) == 0)\t\t\\\n\t\t\tsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\t\\\n\t} while (0);\n\n\nstatic int snd_msndmix_set(struct snd_msnd *dev, int d, int left, int right)\n{\n\tint bLeft, bRight;\n\tint wLeft, wRight;\n\tint updatemaster = 0;\n\n\tif (d >= LEVEL_ENTRIES)\n\t\treturn -EINVAL;\n\n\tbLeft = left * 0xff / 100;\n\twLeft = left * 0xffff / 100;\n\n\tbRight = right * 0xff / 100;\n\twRight = right * 0xffff / 100;\n\n\tdev->left_levels[d] = wLeft;\n\tdev->right_levels[d] = wRight;\n\n\tswitch (d) {\n\t\t \n\tcase MSND_MIXER_LINE:\t\t\t \n\t\t \n\t\twriteb(bLeft, dev->SMA + SMA_bInPotPosLeft);\n\t\twriteb(bRight, dev->SMA + SMA_bInPotPosRight);\n\t\tif (snd_msnd_send_word(dev, 0, 0, HDEXAR_IN_SET_POTS) == 0)\n\t\t\tsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\n\t\tbreak;\n\tcase MSND_MIXER_MIC:\t\t\t \n\t\tif (dev->type == msndClassic)\n\t\t\treturn -EINVAL;\n\t\t \n\t\twriteb(bLeft, dev->SMA + SMA_bMicPotPosLeft);\n\t\twriteb(bRight, dev->SMA + SMA_bMicPotPosRight);\n\t\tif (snd_msnd_send_word(dev, 0, 0, HDEXAR_MIC_SET_POTS) == 0)\n\t\t\tsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\n\t\tbreak;\n\tcase MSND_MIXER_VOLUME:\t\t \n\t\twritew(wLeft, dev->SMA + SMA_wCurrMastVolLeft);\n\t\twritew(wRight, dev->SMA + SMA_wCurrMastVolRight);\n\t\tfallthrough;\n\tcase MSND_MIXER_AUX:\t\t\t \n\t\t \n\n\t\t \n\tcase MSND_MIXER_SYNTH:\t\t\t \n\tcase MSND_MIXER_PCM:\t\t\t \n\tcase MSND_MIXER_IMIX:\t\t\t \n\t\t \n\t\tupdatemaster = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (updatemaster) {\n\t\t \n\t\tupdate_volm(MSND_MIXER_PCM, wCurrPlayVol);\n\t\tupdate_volm(MSND_MIXER_IMIX, wCurrInVol);\n\t\tif (dev->type == msndPinnacle)\n\t\t\tupdate_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);\n\t\tupdate_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_msndmix_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\n\tint change, addr = kcontrol->private_value;\n\tint left, right;\n\tunsigned long flags;\n\n\tleft = ucontrol->value.integer.value[0] % 101;\n\tright = ucontrol->value.integer.value[1] % 101;\n\tspin_lock_irqsave(&msnd->mixer_lock, flags);\n\tchange = msnd->left_levels[addr] != left\n\t\t|| msnd->right_levels[addr] != right;\n\tsnd_msndmix_set(msnd, addr, left, right);\n\tspin_unlock_irqrestore(&msnd->mixer_lock, flags);\n\treturn change;\n}\n\n\n#define DUMMY_VOLUME(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_msndmix_volume_info, \\\n  .get = snd_msndmix_volume_get, .put = snd_msndmix_volume_put, \\\n  .private_value = addr }\n\n\nstatic const struct snd_kcontrol_new snd_msnd_controls[] = {\nDUMMY_VOLUME(\"Master Volume\", 0, MSND_MIXER_VOLUME),\nDUMMY_VOLUME(\"PCM Volume\", 0, MSND_MIXER_PCM),\nDUMMY_VOLUME(\"Aux Volume\", 0, MSND_MIXER_AUX),\nDUMMY_VOLUME(\"Line Volume\", 0, MSND_MIXER_LINE),\nDUMMY_VOLUME(\"Mic Volume\", 0, MSND_MIXER_MIC),\nDUMMY_VOLUME(\"Monitor\",\t0, MSND_MIXER_IMIX),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_msndmix_info_mux,\n\t.get = snd_msndmix_get_mux,\n\t.put = snd_msndmix_put_mux,\n}\n};\n\n\nint snd_msndmix_new(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn -EINVAL;\n\tspin_lock_init(&chip->mixer_lock);\n\tstrcpy(card->mixername, \"MSND Pinnacle Mixer\");\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_msnd_controls); idx++) {\n\t\terr = snd_ctl_add(card,\n\t\t\t\t  snd_ctl_new1(snd_msnd_controls + idx, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_msndmix_new);\n\nvoid snd_msndmix_setup(struct snd_msnd *dev)\n{\n\tupdate_pot(MSND_MIXER_LINE, bInPotPos, HDEXAR_IN_SET_POTS);\n\tupdate_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);\n\tupdate_volm(MSND_MIXER_PCM, wCurrPlayVol);\n\tupdate_volm(MSND_MIXER_IMIX, wCurrInVol);\n\tif (dev->type == msndPinnacle) {\n\t\tupdate_pot(MSND_MIXER_MIC, bMicPotPos, HDEXAR_MIC_SET_POTS);\n\t\tupdate_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);\n\t}\n}\nEXPORT_SYMBOL(snd_msndmix_setup);\n\nint snd_msndmix_force_recsrc(struct snd_msnd *dev, int recsrc)\n{\n\tdev->recsrc = -1;\n\treturn snd_msndmix_set_mux(dev, recsrc);\n}\nEXPORT_SYMBOL(snd_msndmix_force_recsrc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}