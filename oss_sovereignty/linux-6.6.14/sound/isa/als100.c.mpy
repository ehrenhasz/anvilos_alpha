{
  "module_name": "als100.c",
  "hash_id": "d8409e835c5578d6cada11b79e9e1c0fea209a7484fd6e1f19e47440b7c48b51",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/als100.c",
  "human_readable_source": "\n\n \n\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/sb.h>\n\n#define PFX \"als100: \"\n\nMODULE_DESCRIPTION(\"Avance Logic ALS007/ALS1X0\");\nMODULE_AUTHOR(\"Massimo Piccioni <dafastidio@libero.it>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma16[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Avance Logic based soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Avance Logic based soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Avance Logic based soundcard.\");\n\nMODULE_ALIAS(\"snd-dt019x\");\n\nstruct snd_card_als100 {\n\tstruct pnp_dev *dev;\n\tstruct pnp_dev *devmpu;\n\tstruct pnp_dev *devopl;\n\tstruct snd_sb *chip;\n};\n\nstatic const struct pnp_card_device_id snd_als100_pnpids[] = {\n\t \n\t{ .id = \"RWB1688\",\n\t  .devs = { { \"@@@0001\" }, { \"@X@0001\" }, { \"@H@0001\" } },\n\t  .driver_data = SB_HW_DT019X },\n\t \n\t{ .id = \"ALS0007\",\n\t  .devs = { { \"@@@0001\" }, { \"@X@0001\" }, { \"@H@0001\" } },\n\t  .driver_data = SB_HW_DT019X },\n\t \n\t{ .id = \"ALS0001\",\n\t  .devs = { { \"@@@0001\" }, { \"@X@0001\" }, { \"@H@0001\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t \n\t{ .id = \"ALS0110\",\n\t  .devs = { { \"@@@1001\" }, { \"@X@1001\" }, { \"@H@1001\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t \n\t{ .id = \"ALS0120\",\n\t  .devs = { { \"@@@2001\" }, { \"@X@2001\" }, { \"@H@2001\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t \n\t{ .id = \"ALS0200\",\n\t  .devs = { { \"@@@0020\" }, { \"@X@0020\" }, { \"@H@0001\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t \n\t{ .id = \"ALS0200\",\n\t  .devs = { { \"@@@0020\" }, { \"@X@0020\" }, { \"@H@0020\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t \n\t{ .id = \"RTL3000\",\n\t  .devs = { { \"@@@2001\" }, { \"@X@2001\" }, { \"@H@2001\" } },\n\t  .driver_data = SB_HW_ALS100 },\n\t{ .id = \"\" }  \n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_als100_pnpids);\n\nstatic int snd_card_als100_pnp(int dev, struct snd_card_als100 *acard,\n\t\t\t       struct pnp_card_link *card,\n\t\t\t       const struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\tacard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (acard->dev == NULL)\n\t\treturn -ENODEV;\n\n\tacard->devmpu = pnp_request_card_device(card, id->devs[1].id, acard->dev);\n\tacard->devopl = pnp_request_card_device(card, id->devs[2].id, acard->dev);\n\n\tpdev = acard->dev;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"AUDIO pnp configure failure\\n\");\n\t\treturn err;\n\t}\n\tport[dev] = pnp_port_start(pdev, 0);\n\tif (id->driver_data == SB_HW_DT019X)\n\t\tdma8[dev] = pnp_dma(pdev, 0);\n\telse {\n\t\tdma8[dev] = pnp_dma(pdev, 1);\n\t\tdma16[dev] = pnp_dma(pdev, 0);\n\t}\n\tirq[dev] = pnp_irq(pdev, 0);\n\n\tpdev = acard->devmpu;\n\tif (pdev != NULL) {\n\t\terr = pnp_activate_dev(pdev);\n\t\tif (err < 0)\n\t\t\tgoto __mpu_error;\n\t\tmpu_port[dev] = pnp_port_start(pdev, 0);\n\t\tmpu_irq[dev] = pnp_irq(pdev, 0);\n\t} else {\n\t     __mpu_error:\n\t     \tif (pdev) {\n\t\t     \tpnp_release_card_device(pdev);\n\t     \t\tsnd_printk(KERN_ERR PFX \"MPU401 pnp configure failure, skipping\\n\");\n\t     \t}\n\t     \tacard->devmpu = NULL;\n\t     \tmpu_port[dev] = -1;\n\t}\n\n\tpdev = acard->devopl;\n\tif (pdev != NULL) {\n\t\terr = pnp_activate_dev(pdev);\n\t\tif (err < 0)\n\t\t\tgoto __fm_error;\n\t\tfm_port[dev] = pnp_port_start(pdev, 0);\n\t} else {\n\t      __fm_error:\n\t     \tif (pdev) {\n\t\t     \tpnp_release_card_device(pdev);\n\t     \t\tsnd_printk(KERN_ERR PFX \"OPL3 pnp configure failure, skipping\\n\");\n\t     \t}\n\t     \tacard->devopl = NULL;\n\t     \tfm_port[dev] = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_card_als100_probe(int dev,\n\t\t\t\t struct pnp_card_link *pcard,\n\t\t\t\t const struct pnp_card_device_id *pid)\n{\n\tint error;\n\tstruct snd_sb *chip;\n\tstruct snd_card *card;\n\tstruct snd_card_als100 *acard;\n\tstruct snd_opl3 *opl3;\n\n\terror = snd_devm_card_new(&pcard->card->dev,\n\t\t\t\t  index[dev], id[dev], THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_card_als100), &card);\n\tif (error < 0)\n\t\treturn error;\n\tacard = card->private_data;\n\n\terror = snd_card_als100_pnp(dev, acard, pcard, pid);\n\tif (error)\n\t\treturn error;\n\n\tif (pid->driver_data == SB_HW_DT019X)\n\t\tdma16[dev] = -1;\n\n\terror = snd_sbdsp_create(card, port[dev], irq[dev],\n\t\t\t\t  snd_sb16dsp_interrupt,\n\t\t\t\t  dma8[dev], dma16[dev],\n\t\t\t\t  pid->driver_data,\n\t\t\t\t  &chip);\n\tif (error < 0)\n\t\treturn error;\n\tacard->chip = chip;\n\n\tif (pid->driver_data == SB_HW_DT019X) {\n\t\tstrcpy(card->driver, \"DT-019X\");\n\t\tstrcpy(card->shortname, \"Diamond Tech. DT-019X\");\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t \"Diamond Tech. DT-019X, %s at 0x%lx, irq %d, dma %d\",\n\t\t\t chip->name, chip->port, irq[dev], dma8[dev]);\n\t} else {\n\t\tstrcpy(card->driver, \"ALS100\");\n\t\tstrcpy(card->shortname, \"Avance Logic ALS100\");\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t \"Avance Logic ALS100, %s at 0x%lx, irq %d, dma %d&%d\",\n\t\t\t chip->name, chip->port, irq[dev], dma8[dev],\n\t\t\t dma16[dev]);\n\t}\n\n\terror = snd_sb16dsp_pcm(chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_sbmixer_new(chip);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\tint mpu_type = MPU401_HW_ALS100;\n\n\t\tif (mpu_irq[dev] == SNDRV_AUTO_IRQ)\n\t\t\tmpu_irq[dev] = -1;\n\n\t\tif (pid->driver_data == SB_HW_DT019X)\n\t\t\tmpu_type = MPU401_HW_MPU401;\n\n\t\tif (snd_mpu401_uart_new(card, 0,\n\t\t\t\t\tmpu_type,\n\t\t\t\t\tmpu_port[dev], 0, \n\t\t\t\t\tmpu_irq[dev],\n\t\t\t\t\tNULL) < 0)\n\t\t\tsnd_printk(KERN_ERR PFX \"no MPU-401 device at 0x%lx\\n\", mpu_port[dev]);\n\t}\n\n\tif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\n\t\tif (snd_opl3_create(card,\n\t\t\t\t    fm_port[dev], fm_port[dev] + 2,\n\t\t\t\t    OPL3_HW_AUTO, 0, &opl3) < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"no OPL device at 0x%lx-0x%lx\\n\",\n\t\t\t\t   fm_port[dev], fm_port[dev] + 2);\n\t\t} else {\n\t\t\terror = snd_opl3_timer_new(opl3, 0, 1);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\terror = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = snd_card_register(card);\n\tif (error < 0)\n\t\treturn error;\n\tpnp_set_card_drvdata(pcard, card);\n\treturn 0;\n}\n\nstatic unsigned int als100_devices;\n\nstatic int snd_als100_pnp_detect(struct pnp_card_link *card,\n\t\t\t\t const struct pnp_card_device_id *id)\n{\n\tstatic int dev;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (!enable[dev])\n\t\t\tcontinue;\n\t\tres = snd_card_als100_probe(dev, card, id);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tdev++;\n\t\tals100_devices++;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_als100_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\tstruct snd_card_als100 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_sbmixer_suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_als100_pnp_resume(struct pnp_card_link *pcard)\n{\n\tstruct snd_card *card = pnp_get_card_drvdata(pcard);\n\tstruct snd_card_als100 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_sbdsp_reset(chip);\n\tsnd_sbmixer_resume(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic struct pnp_card_driver als100_pnpc_driver = {\n\t.flags          = PNP_DRIVER_RES_DISABLE,\n\t.name\t\t= \"als100\",\n        .id_table       = snd_als100_pnpids,\n        .probe          = snd_als100_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_als100_pnp_suspend,\n\t.resume\t\t= snd_als100_pnp_resume,\n#endif\n};\n\nstatic int __init alsa_card_als100_init(void)\n{\n\tint err;\n\n\terr = pnp_register_card_driver(&als100_pnpc_driver);\n\tif (err)\n\t\treturn err;\n\n\tif (!als100_devices) {\n\t\tpnp_unregister_card_driver(&als100_pnpc_driver);\n#ifdef MODULE\n\t\tsnd_printk(KERN_ERR \"no Avance Logic based soundcards found\\n\");\n#endif\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_als100_exit(void)\n{\n\tpnp_unregister_card_driver(&als100_pnpc_driver);\n}\n\nmodule_init(alsa_card_als100_init)\nmodule_exit(alsa_card_als100_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}