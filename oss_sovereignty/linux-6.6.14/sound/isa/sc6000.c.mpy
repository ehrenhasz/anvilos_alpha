{
  "module_name": "sc6000.c",
  "hash_id": "4a7a6044760263a976ce7c249003500f99f1221a4ab9208c4f9e5a84f8629554",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sc6000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/isa.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/opl3.h>\n#include <sound/mpu401.h>\n#include <sound/control.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Krzysztof Helt\");\nMODULE_DESCRIPTION(\"Gallant SC-6000\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic long mss_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\n\t\t\t\t\t\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic bool joystick[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = false };\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for sc-6000 based soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for sc-6000 based soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable sc-6000 based soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for sc-6000 driver.\");\nmodule_param_hw_array(mss_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mss_port, \"MSS Port # for sc-6000 driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for sc-6000 driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for sc-6000 driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for sc-6000 driver.\");\nmodule_param_hw_array(dma, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma, \"DMA # for sc-6000 driver.\");\nmodule_param_array(joystick, bool, NULL, 0444);\nMODULE_PARM_DESC(joystick, \"Enable gameport.\");\n\n \n#define WRITE_MDIRQ_CFG\t0x50\t \n#define COMMAND_52\t0x52\t \n#define READ_HARD_CFG\t0x58\t \n#define COMMAND_5C\t0x5c\t \n#define COMMAND_60\t0x60\t \n#define COMMAND_66\t0x66\t \n#define COMMAND_6C\t0x6c\t \n#define COMMAND_6E\t0x6e\t \n#define COMMAND_88\t0x88\t \n#define DSP_INIT_MSS\t0x8c\t \n#define COMMAND_C5\t0xc5\t \n#define GET_DSP_VERSION\t0xe1\t \n#define GET_DSP_COPYRIGHT 0xe3\t \n\n \n#define DSP_RESET\t0x06\t \n#define DSP_READ\t0x0a\t \n#define DSP_WRITE\t0x0c\t \n#define DSP_COMMAND\t0x0c\t \n#define DSP_STATUS\t0x0c\t \n#define DSP_DATAVAIL\t0x0e\t \n\n#define PFX \"sc6000: \"\n#define DRV_NAME \"SC-6000\"\n\n \n\n \nstatic unsigned char sc6000_irq_to_softcfg(int irq)\n{\n\tunsigned char val = 0;\n\n\tswitch (irq) {\n\tcase 5:\n\t\tval = 0x28;\n\t\tbreak;\n\tcase 7:\n\t\tval = 0x8;\n\t\tbreak;\n\tcase 9:\n\t\tval = 0x10;\n\t\tbreak;\n\tcase 10:\n\t\tval = 0x18;\n\t\tbreak;\n\tcase 11:\n\t\tval = 0x20;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n \nstatic unsigned char sc6000_dma_to_softcfg(int dma)\n{\n\tunsigned char val = 0;\n\n\tswitch (dma) {\n\tcase 0:\n\t\tval = 1;\n\t\tbreak;\n\tcase 1:\n\t\tval = 2;\n\t\tbreak;\n\tcase 3:\n\t\tval = 3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n \nstatic unsigned char sc6000_mpu_irq_to_softcfg(int mpu_irq)\n{\n\tunsigned char val = 0;\n\n\tswitch (mpu_irq) {\n\tcase 5:\n\t\tval = 4;\n\t\tbreak;\n\tcase 7:\n\t\tval = 0x44;\n\t\tbreak;\n\tcase 9:\n\t\tval = 0x84;\n\t\tbreak;\n\tcase 10:\n\t\tval = 0xc4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn val;\n}\n\nstatic int sc6000_wait_data(char __iomem *vport)\n{\n\tint loop = 1000;\n\tunsigned char val = 0;\n\n\tdo {\n\t\tval = ioread8(vport + DSP_DATAVAIL);\n\t\tif (val & 0x80)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (loop--);\n\n\treturn -EAGAIN;\n}\n\nstatic int sc6000_read(char __iomem *vport)\n{\n\tif (sc6000_wait_data(vport))\n\t\treturn -EBUSY;\n\n\treturn ioread8(vport + DSP_READ);\n\n}\n\nstatic int sc6000_write(char __iomem *vport, int cmd)\n{\n\tunsigned char val;\n\tint loop = 500000;\n\n\tdo {\n\t\tval = ioread8(vport + DSP_STATUS);\n\t\t \n\t\tif (!(val & 0x80)) {\n\t\t\tiowrite8(cmd, vport + DSP_COMMAND);\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t} while (loop--);\n\n\tsnd_printk(KERN_ERR \"DSP Command (0x%x) timeout.\\n\", cmd);\n\n\treturn -EIO;\n}\n\nstatic int sc6000_dsp_get_answer(char __iomem *vport, int command,\n\t\t\t\t char *data, int data_len)\n{\n\tint len = 0;\n\n\tif (sc6000_write(vport, command)) {\n\t\tsnd_printk(KERN_ERR \"CMD 0x%x: failed!\\n\", command);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tint val = sc6000_read(vport);\n\n\t\tif (val < 0)\n\t\t\tbreak;\n\n\t\tdata[len++] = val;\n\n\t} while (len < data_len);\n\n\t \n\treturn len ? len : -EIO;\n}\n\nstatic int sc6000_dsp_reset(char __iomem *vport)\n{\n\tiowrite8(1, vport + DSP_RESET);\n\tudelay(10);\n\tiowrite8(0, vport + DSP_RESET);\n\tudelay(20);\n\tif (sc6000_read(vport) == 0xaa)\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\n \nstatic int sc6000_hw_cfg_write(char __iomem *vport, const int *cfg)\n{\n\tif (sc6000_write(vport, COMMAND_6C) < 0) {\n\t\tsnd_printk(KERN_WARNING \"CMD 0x%x: failed!\\n\", COMMAND_6C);\n\t\treturn -EIO;\n\t}\n\tif (sc6000_write(vport, COMMAND_5C) < 0) {\n\t\tsnd_printk(KERN_ERR \"CMD 0x%x: failed!\\n\", COMMAND_5C);\n\t\treturn -EIO;\n\t}\n\tif (sc6000_write(vport, cfg[0]) < 0) {\n\t\tsnd_printk(KERN_ERR \"DATA 0x%x: failed!\\n\", cfg[0]);\n\t\treturn -EIO;\n\t}\n\tif (sc6000_write(vport, cfg[1]) < 0) {\n\t\tsnd_printk(KERN_ERR \"DATA 0x%x: failed!\\n\", cfg[1]);\n\t\treturn -EIO;\n\t}\n\tif (sc6000_write(vport, COMMAND_C5) < 0) {\n\t\tsnd_printk(KERN_ERR \"CMD 0x%x: failed!\\n\", COMMAND_C5);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc6000_cfg_write(char __iomem *vport, unsigned char softcfg)\n{\n\n\tif (sc6000_write(vport, WRITE_MDIRQ_CFG)) {\n\t\tsnd_printk(KERN_ERR \"CMD 0x%x: failed!\\n\", WRITE_MDIRQ_CFG);\n\t\treturn -EIO;\n\t}\n\tif (sc6000_write(vport, softcfg)) {\n\t\tsnd_printk(KERN_ERR \"sc6000_cfg_write: failed!\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int sc6000_setup_board(char __iomem *vport, int config)\n{\n\tint loop = 10;\n\n\tdo {\n\t\tif (sc6000_write(vport, COMMAND_88)) {\n\t\t\tsnd_printk(KERN_ERR \"CMD 0x%x: failed!\\n\",\n\t\t\t\t   COMMAND_88);\n\t\t\treturn -EIO;\n\t\t}\n\t} while ((sc6000_wait_data(vport) < 0) && loop--);\n\n\tif (sc6000_read(vport) < 0) {\n\t\tsnd_printk(KERN_ERR \"sc6000_read after CMD 0x%x: failed\\n\",\n\t\t\t   COMMAND_88);\n\t\treturn -EIO;\n\t}\n\n\tif (sc6000_cfg_write(vport, config))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int sc6000_init_mss(char __iomem *vport, int config,\n\t\t\t   char __iomem *vmss_port, int mss_config)\n{\n\tif (sc6000_write(vport, DSP_INIT_MSS)) {\n\t\tsnd_printk(KERN_ERR \"sc6000_init_mss [0x%x]: failed!\\n\",\n\t\t\t   DSP_INIT_MSS);\n\t\treturn -EIO;\n\t}\n\n\tmsleep(10);\n\n\tif (sc6000_cfg_write(vport, config))\n\t\treturn -EIO;\n\n\tiowrite8(mss_config, vmss_port);\n\n\treturn 0;\n}\n\nstatic void sc6000_hw_cfg_encode(char __iomem *vport, int *cfg,\n\t\t\t\t long xport, long xmpu,\n\t\t\t\t long xmss_port, int joystick)\n{\n\tcfg[0] = 0;\n\tcfg[1] = 0;\n\tif (xport == 0x240)\n\t\tcfg[0] |= 1;\n\tif (xmpu != SNDRV_AUTO_PORT) {\n\t\tcfg[0] |= (xmpu & 0x30) >> 2;\n\t\tcfg[1] |= 0x20;\n\t}\n\tif (xmss_port == 0xe80)\n\t\tcfg[0] |= 0x10;\n\tcfg[0] |= 0x40;\t\t \n\tif (!joystick)\n\t\tcfg[0] |= 0x02;\n\tcfg[1] |= 0x80;\t\t \n\tcfg[1] &= ~0x40;\t \n\tsnd_printd(\"hw cfg %x, %x\\n\", cfg[0], cfg[1]);\n}\n\nstatic int sc6000_init_board(char __iomem *vport,\n\t\t\t     char __iomem *vmss_port, int dev)\n{\n\tchar answer[15];\n\tchar version[2];\n\tint mss_config = sc6000_irq_to_softcfg(irq[dev]) |\n\t\t\t sc6000_dma_to_softcfg(dma[dev]);\n\tint config = mss_config |\n\t\t     sc6000_mpu_irq_to_softcfg(mpu_irq[dev]);\n\tint err;\n\tint old = 0;\n\n\terr = sc6000_dsp_reset(vport);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"sc6000_dsp_reset: failed!\\n\");\n\t\treturn err;\n\t}\n\n\tmemset(answer, 0, sizeof(answer));\n\terr = sc6000_dsp_get_answer(vport, GET_DSP_COPYRIGHT, answer, 15);\n\tif (err <= 0) {\n\t\tsnd_printk(KERN_ERR \"sc6000_dsp_copyright: failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (strncmp(\"SC-6000\", answer, 7))\n\t\tsnd_printk(KERN_WARNING \"Warning: non SC-6000 audio card!\\n\");\n\n\tif (sc6000_dsp_get_answer(vport, GET_DSP_VERSION, version, 2) < 2) {\n\t\tsnd_printk(KERN_ERR \"sc6000_dsp_version: failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprintk(KERN_INFO PFX \"Detected model: %s, DSP version %d.%d\\n\",\n\t\tanswer, version[0], version[1]);\n\n\t \n\tsc6000_write(vport, COMMAND_5C);\n\tif (sc6000_read(vport) < 0)\n\t\told = 1;\n\n\tif (!old) {\n\t\tint cfg[2];\n\t\tsc6000_hw_cfg_encode(vport, &cfg[0], port[dev], mpu_port[dev],\n\t\t\t\t     mss_port[dev], joystick[dev]);\n\t\tif (sc6000_hw_cfg_write(vport, cfg) < 0) {\n\t\t\tsnd_printk(KERN_ERR \"sc6000_hw_cfg_write: failed!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\terr = sc6000_setup_board(vport, config);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"sc6000_setup_board: failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsc6000_dsp_reset(vport);\n\n\tif (!old) {\n\t\tsc6000_write(vport, COMMAND_60);\n\t\tsc6000_write(vport, 0x02);\n\t\tsc6000_dsp_reset(vport);\n\t}\n\n\terr = sc6000_setup_board(vport, config);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"sc6000_setup_board: failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\terr = sc6000_init_mss(vport, config, vmss_port, mss_config);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot initialize \"\n\t\t\t   \"Microsoft Sound System mode.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_sc6000_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_ctl_elem_id id1, id2;\n\tint err;\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tid2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tstrcpy(id2.name, \"FM Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"FM Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\"); id1.index = 1;\n\tstrcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"CD Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_sc6000_match(struct device *devptr, unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n\tif (port[dev] == SNDRV_AUTO_PORT) {\n\t\tprintk(KERN_ERR PFX \"specify IO port\\n\");\n\t\treturn 0;\n\t}\n\tif (mss_port[dev] == SNDRV_AUTO_PORT) {\n\t\tprintk(KERN_ERR PFX \"specify MSS port\\n\");\n\t\treturn 0;\n\t}\n\tif (port[dev] != 0x220 && port[dev] != 0x240) {\n\t\tprintk(KERN_ERR PFX \"Port must be 0x220 or 0x240\\n\");\n\t\treturn 0;\n\t}\n\tif (mss_port[dev] != 0x530 && mss_port[dev] != 0xe80) {\n\t\tprintk(KERN_ERR PFX \"MSS port must be 0x530 or 0xe80\\n\");\n\t\treturn 0;\n\t}\n\tif (irq[dev] != SNDRV_AUTO_IRQ && !sc6000_irq_to_softcfg(irq[dev])) {\n\t\tprintk(KERN_ERR PFX \"invalid IRQ %d\\n\", irq[dev]);\n\t\treturn 0;\n\t}\n\tif (dma[dev] != SNDRV_AUTO_DMA && !sc6000_dma_to_softcfg(dma[dev])) {\n\t\tprintk(KERN_ERR PFX \"invalid DMA %d\\n\", dma[dev]);\n\t\treturn 0;\n\t}\n\tif (mpu_port[dev] != SNDRV_AUTO_PORT &&\n\t    (mpu_port[dev] & ~0x30L) != 0x300) {\n\t\tprintk(KERN_ERR PFX \"invalid MPU-401 port %lx\\n\",\n\t\t\tmpu_port[dev]);\n\t\treturn 0;\n\t}\n\tif (mpu_port[dev] != SNDRV_AUTO_PORT &&\n\t    mpu_irq[dev] != SNDRV_AUTO_IRQ && mpu_irq[dev] != 0 &&\n\t    !sc6000_mpu_irq_to_softcfg(mpu_irq[dev])) {\n\t\tprintk(KERN_ERR PFX \"invalid MPU-401 IRQ %d\\n\", mpu_irq[dev]);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void snd_sc6000_free(struct snd_card *card)\n{\n\tchar __iomem *vport = (char __force __iomem *)card->private_data;\n\n\tif (vport)\n\t\tsc6000_setup_board(vport, 0);\n}\n\nstatic int __snd_sc6000_probe(struct device *devptr, unsigned int dev)\n{\n\tstatic const int possible_irqs[] = { 5, 7, 9, 10, 11, -1 };\n\tstatic const int possible_dmas[] = { 1, 3, 0, -1 };\n\tint err;\n\tint xirq = irq[dev];\n\tint xdma = dma[dev];\n\tstruct snd_card *card;\n\tstruct snd_wss *chip;\n\tstruct snd_opl3 *opl3;\n\tchar __iomem *vport;\n\tchar __iomem *vmss_port;\n\n\terr = snd_devm_card_new(devptr, index[dev], id[dev], THIS_MODULE,\n\t\t\t\t0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (xirq == SNDRV_AUTO_IRQ) {\n\t\txirq = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (xirq < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (xdma == SNDRV_AUTO_DMA) {\n\t\txdma = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (xdma < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (!devm_request_region(devptr, port[dev], 0x10, DRV_NAME)) {\n\t\tsnd_printk(KERN_ERR PFX\n\t\t\t   \"I/O port region is already in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\tvport = devm_ioport_map(devptr, port[dev], 0x10);\n\tif (!vport) {\n\t\tsnd_printk(KERN_ERR PFX\n\t\t\t   \"I/O port cannot be iomapped.\\n\");\n\t\treturn -EBUSY;\n\t}\n\tcard->private_data = (void __force *)vport;\n\n\t \n\tif (!devm_request_region(devptr, mss_port[dev], 4, DRV_NAME)) {\n\t\tsnd_printk(KERN_ERR PFX\n\t\t\t   \"SC-6000 port I/O port region is already in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\tvmss_port = devm_ioport_map(devptr, mss_port[dev], 4);\n\tif (!vmss_port) {\n\t\tsnd_printk(KERN_ERR PFX\n\t\t\t   \"MSS port I/O cannot be iomapped.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsnd_printd(\"Initializing BASE[0x%lx] IRQ[%d] DMA[%d] MIRQ[%d]\\n\",\n\t\t   port[dev], xirq, xdma,\n\t\t   mpu_irq[dev] == SNDRV_AUTO_IRQ ? 0 : mpu_irq[dev]);\n\n\terr = sc6000_init_board(vport, vmss_port, dev);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = snd_sc6000_free;\n\n\terr = snd_wss_create(card, mss_port[dev] + 4,  -1, xirq, xdma, -1,\n\t\t\t     WSS_HW_DETECT, 0, &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_pcm(chip, 0);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX\n\t\t\t   \"error creating new WSS PCM device\\n\");\n\t\treturn err;\n\t}\n\terr = snd_wss_mixer(chip);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"error creating new WSS mixer\\n\");\n\t\treturn err;\n\t}\n\terr = snd_sc6000_mixer(chip);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"the mixer rewrite failed\\n\");\n\t\treturn err;\n\t}\n\tif (snd_opl3_create(card,\n\t\t\t    0x388, 0x388 + 2,\n\t\t\t    OPL3_HW_AUTO, 0, &opl3) < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"no OPL device at 0x%x-0x%x ?\\n\",\n\t\t\t   0x388, 0x388 + 2);\n\t} else {\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (mpu_port[dev] != SNDRV_AUTO_PORT) {\n\t\tif (mpu_irq[dev] == SNDRV_AUTO_IRQ)\n\t\t\tmpu_irq[dev] = -1;\n\t\tif (snd_mpu401_uart_new(card, 0,\n\t\t\t\t\tMPU401_HW_MPU401,\n\t\t\t\t\tmpu_port[dev], 0,\n\t\t\t\t\tmpu_irq[dev], NULL) < 0)\n\t\t\tsnd_printk(KERN_ERR \"no MPU-401 device at 0x%lx ?\\n\",\n\t\t\t\t\tmpu_port[dev]);\n\t}\n\n\tstrcpy(card->driver, DRV_NAME);\n\tstrcpy(card->shortname, \"SC-6000\");\n\tsprintf(card->longname, \"Gallant SC-6000 at 0x%lx, irq %d, dma %d\",\n\t\tmss_port[dev], xirq, xdma);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_set_drvdata(devptr, card);\n\treturn 0;\n}\n\nstatic int snd_sc6000_probe(struct device *devptr, unsigned int dev)\n{\n\treturn snd_card_free_on_error(devptr, __snd_sc6000_probe(devptr, dev));\n}\n\nstatic struct isa_driver snd_sc6000_driver = {\n\t.match\t\t= snd_sc6000_match,\n\t.probe\t\t= snd_sc6000_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\n\nmodule_isa_driver(snd_sc6000_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}