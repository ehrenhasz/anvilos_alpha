{
  "module_name": "cs4236_lib.c",
  "hash_id": "a63b7d0c5ad9563f17c7af407a5f583650e989f170d4eabe180fd8ad2a6c61c8",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/cs423x/cs4236_lib.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n \n\nstatic const unsigned char snd_cs4236_ext_map[18] = {\n\t \t\t0xff,\n\t \t\t0xff,\n\t \t\t0xdf,\n\t \t\t0xdf,\n\t \t0xe0 | 0x18,\n\t \t0xe0,\n\t \t\t0xbf,\n\t \t\t0xbf,\n\t \t\t0xbf,\n\t \t\t0xbf,\n\t \t0xbf,\n\t \t\t0xe0,\n\t \t\t0x01,\t \n\t \t\t0x01,\t \n\t \t0xbf,\n\t \t0xbf,\n\t \t\t0xbf,\n\t \t\t0xbf\n};\n\n \n\nstatic void snd_cs4236_ctrl_out(struct snd_wss *chip,\n\t\t\t\tunsigned char reg, unsigned char val)\n{\n\toutb(reg, chip->cport + 3);\n\toutb(chip->cimage[reg] = val, chip->cport + 4);\n}\n\nstatic unsigned char snd_cs4236_ctrl_in(struct snd_wss *chip, unsigned char reg)\n{\n\toutb(reg, chip->cport + 3);\n\treturn inb(chip->cport + 4);\n}\n\n \n\n#define CLOCKS 8\n\nstatic const struct snd_ratnum clocks[CLOCKS] = {\n\t{ .num = 16934400, .den_min = 353, .den_max = 353, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 529, .den_max = 529, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 617, .den_max = 617, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 1058, .den_max = 1058, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 1764, .den_max = 1764, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 2117, .den_max = 2117, .den_step = 1 },\n\t{ .num = 16934400, .den_min = 2558, .den_max = 2558, .den_step = 1 },\n\t{ .num = 16934400/16, .den_min = 21, .den_max = 192, .den_step = 1 }\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums hw_constraints_clocks = {\n\t.nrats = CLOCKS,\n\t.rats = clocks,\n};\n\nstatic int snd_cs4236_xrate(struct snd_pcm_runtime *runtime)\n{\n\treturn snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t     &hw_constraints_clocks);\n}\n\nstatic unsigned char divisor_to_rate_register(unsigned int divisor)\n{\n\tswitch (divisor) {\n\tcase 353:\treturn 1;\n\tcase 529:\treturn 2;\n\tcase 617:\treturn 3;\n\tcase 1058:\treturn 4;\n\tcase 1764:\treturn 5;\n\tcase 2117:\treturn 6;\n\tcase 2558:\treturn 7;\n\tdefault:\n\t\tif (divisor < 21 || divisor > 192) {\n\t\t\tsnd_BUG();\n\t\t\treturn 192;\n\t\t}\n\t\treturn divisor;\n\t}\n}\n\nstatic void snd_cs4236_playback_format(struct snd_wss *chip,\n\t\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t\t       unsigned char pdfr)\n{\n\tunsigned long flags;\n\tunsigned char rate = divisor_to_rate_register(params->rate_den);\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t \n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t    chip->image[CS4231_ALT_FEATURE_1] | 0x10);\n\tsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, pdfr & 0xf0);\n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t    chip->image[CS4231_ALT_FEATURE_1] & ~0x10);\n\tsnd_cs4236_ext_out(chip, CS4236_DAC_RATE, rate);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_cs4236_capture_format(struct snd_wss *chip,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      unsigned char cdfr)\n{\n\tunsigned long flags;\n\tunsigned char rate = divisor_to_rate_register(params->rate_den);\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t \n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t    chip->image[CS4231_ALT_FEATURE_1] | 0x20);\n\tsnd_wss_out(chip, CS4231_REC_FORMAT, cdfr & 0xf0);\n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\n\t\t    chip->image[CS4231_ALT_FEATURE_1] & ~0x20);\n\tsnd_cs4236_ext_out(chip, CS4236_ADC_RATE, rate);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\n#ifdef CONFIG_PM\n\nstatic void snd_cs4236_suspend(struct snd_wss *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tfor (reg = 0; reg < 32; reg++)\n\t\tchip->image[reg] = snd_wss_in(chip, reg);\n\tfor (reg = 0; reg < 18; reg++)\n\t\tchip->eimage[reg] = snd_cs4236_ext_in(chip, CS4236_I23VAL(reg));\n\tfor (reg = 2; reg < 9; reg++)\n\t\tchip->cimage[reg] = snd_cs4236_ctrl_in(chip, reg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_cs4236_resume(struct snd_wss *chip)\n{\n\tint reg;\n\tunsigned long flags;\n\t\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tfor (reg = 0; reg < 32; reg++) {\n\t\tswitch (reg) {\n\t\tcase CS4236_EXT_REG:\n\t\tcase CS4231_VERSION:\n\t\tcase 27:\t \n\t\tcase 29:\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_wss_out(chip, reg, chip->image[reg]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (reg = 0; reg < 18; reg++)\n\t\tsnd_cs4236_ext_out(chip, CS4236_I23VAL(reg), chip->eimage[reg]);\n\tfor (reg = 2; reg < 9; reg++) {\n\t\tswitch (reg) {\n\t\tcase 7:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_cs4236_ctrl_out(chip, reg, chip->cimage[reg]);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n}\n\n#endif  \n \nint snd_cs4236_create(struct snd_card *card,\n\t\t      unsigned long port,\n\t\t      unsigned long cport,\n\t\t      int irq, int dma1, int dma2,\n\t\t      unsigned short hardware,\n\t\t      unsigned short hwshare,\n\t\t      struct snd_wss **rchip)\n{\n\tstruct snd_wss *chip;\n\tunsigned char ver1, ver2;\n\tunsigned int reg;\n\tint err;\n\n\t*rchip = NULL;\n\tif (hardware == WSS_HW_DETECT)\n\t\thardware = WSS_HW_DETECT3;\n\n\terr = snd_wss_create(card, port, cport,\n\t\t\t     irq, dma1, dma2, hardware, hwshare, &chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((chip->hardware & WSS_HW_CS4236B_MASK) == 0) {\n\t\tsnd_printd(\"chip is not CS4236+, hardware=0x%x\\n\",\n\t\t\t   chip->hardware);\n\t\t*rchip = chip;\n\t\treturn 0;\n\t}\n#if 0\n\t{\n\t\tint idx;\n\t\tfor (idx = 0; idx < 8; idx++)\n\t\t\tsnd_printk(KERN_DEBUG \"CD%i = 0x%x\\n\",\n\t\t\t\t   idx, inb(chip->cport + idx));\n\t\tfor (idx = 0; idx < 9; idx++)\n\t\t\tsnd_printk(KERN_DEBUG \"C%i = 0x%x\\n\",\n\t\t\t\t   idx, snd_cs4236_ctrl_in(chip, idx));\n\t}\n#endif\n\tif (cport < 0x100 || cport == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR \"please, specify control port \"\n\t\t\t   \"for CS4236+ chips\\n\");\n\t\treturn -ENODEV;\n\t}\n\tver1 = snd_cs4236_ctrl_in(chip, 1);\n\tver2 = snd_cs4236_ext_in(chip, CS4236_VERSION);\n\tsnd_printdd(\"CS4236: [0x%lx] C1 (version) = 0x%x, ext = 0x%x\\n\",\n\t\t\tcport, ver1, ver2);\n\tif (ver1 != ver2) {\n\t\tsnd_printk(KERN_ERR \"CS4236+ chip detected, but \"\n\t\t\t   \"control port 0x%lx is not valid\\n\", cport);\n\t\treturn -ENODEV;\n\t}\n\tsnd_cs4236_ctrl_out(chip, 0, 0x00);\n\tsnd_cs4236_ctrl_out(chip, 2, 0xff);\n\tsnd_cs4236_ctrl_out(chip, 3, 0x00);\n\tsnd_cs4236_ctrl_out(chip, 4, 0x80);\n\treg = ((IEC958_AES1_CON_PCM_CODER & 3) << 6) |\n\t      IEC958_AES0_CON_EMPHASIS_NONE;\n\tsnd_cs4236_ctrl_out(chip, 5, reg);\n\tsnd_cs4236_ctrl_out(chip, 6, IEC958_AES1_CON_PCM_CODER >> 2);\n\tsnd_cs4236_ctrl_out(chip, 7, 0x00);\n\t \n\tsnd_cs4236_ctrl_out(chip, 8, 0x8c);\n\tchip->rate_constraint = snd_cs4236_xrate;\n\tchip->set_playback_format = snd_cs4236_playback_format;\n\tchip->set_capture_format = snd_cs4236_capture_format;\n#ifdef CONFIG_PM\n\tchip->suspend = snd_cs4236_suspend;\n\tchip->resume = snd_cs4236_resume;\n#endif\n\n\t \n\tfor (reg = 0; reg < sizeof(snd_cs4236_ext_map); reg++)\n\t\tsnd_cs4236_ext_out(chip, CS4236_I23VAL(reg),\n\t\t\t\t   snd_cs4236_ext_map[reg]);\n\n\t \n\tsnd_wss_out(chip, CS4231_LEFT_INPUT, 0x40);\n\tsnd_wss_out(chip, CS4231_RIGHT_INPUT, 0x40);\n\tsnd_wss_out(chip, CS4231_AUX1_LEFT_INPUT, 0xff);\n\tsnd_wss_out(chip, CS4231_AUX1_RIGHT_INPUT, 0xff);\n\tsnd_wss_out(chip, CS4231_AUX2_LEFT_INPUT, 0xdf);\n\tsnd_wss_out(chip, CS4231_AUX2_RIGHT_INPUT, 0xdf);\n\tsnd_wss_out(chip, CS4231_RIGHT_LINE_IN, 0xff);\n\tsnd_wss_out(chip, CS4231_LEFT_LINE_IN, 0xff);\n\tsnd_wss_out(chip, CS4231_RIGHT_LINE_IN, 0xff);\n\tswitch (chip->hardware) {\n\tcase WSS_HW_CS4235:\n\tcase WSS_HW_CS4239:\n\t\tsnd_wss_out(chip, CS4235_LEFT_MASTER, 0xff);\n\t\tsnd_wss_out(chip, CS4235_RIGHT_MASTER, 0xff);\n\t\tbreak;\n\t}\n\n\t*rchip = chip;\n\treturn 0;\n}\n\nint snd_cs4236_pcm(struct snd_wss *chip, int device)\n{\n\tint err;\n\t\n\terr = snd_wss_pcm(chip, device);\n\tif (err < 0)\n\t\treturn err;\n\tchip->pcm->info_flags &= ~SNDRV_PCM_INFO_JOINT_DUPLEX;\n\treturn 0;\n}\n\n \n\n#define CS4236_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_cs4236_info_single, \\\n  .get = snd_cs4236_get_single, .put = snd_cs4236_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\n#define CS4236_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_cs4236_info_single, \\\n  .get = snd_cs4236_get_single, .put = snd_cs4236_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_cs4236_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_cs4236_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(reg)] >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = (chip->eimage[CS4236_REG(reg)] & ~(mask << shift)) | val;\n\tchange = val != chip->eimage[CS4236_REG(reg)];\n\tsnd_cs4236_ext_out(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define CS4236_SINGLEC(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_cs4236_info_single, \\\n  .get = snd_cs4236_get_singlec, .put = snd_cs4236_put_singlec, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_cs4236_get_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->cimage[reg] >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = (chip->cimage[reg] & ~(mask << shift)) | val;\n\tchange = val != chip->cimage[reg];\n\tsnd_cs4236_ctrl_out(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define CS4236_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4236_get_double, .put = snd_cs4236_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\n#define CS4236_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, \\\n\t\t\t  shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4236_get_double, .put = snd_cs4236_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | \\\n\t\t   (shift_right << 19) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_cs4236_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_cs4236_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(left_reg)] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (left_reg != right_reg) {\n\t\tval1 = (chip->eimage[CS4236_REG(left_reg)] & ~(mask << shift_left)) | val1;\n\t\tval2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;\n\t\tchange = val1 != chip->eimage[CS4236_REG(left_reg)] || val2 != chip->eimage[CS4236_REG(right_reg)];\n\t\tsnd_cs4236_ext_out(chip, left_reg, val1);\n\t\tsnd_cs4236_ext_out(chip, right_reg, val2);\n\t} else {\n\t\tval1 = (chip->eimage[CS4236_REG(left_reg)] & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\n\t\tchange = val1 != chip->eimage[CS4236_REG(left_reg)];\n\t\tsnd_cs4236_ext_out(chip, left_reg, val1);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define CS4236_DOUBLE1(xname, xindex, left_reg, right_reg, shift_left, \\\n\t\t\tshift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4236_get_double1, .put = snd_cs4236_put_double1, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\n#define CS4236_DOUBLE1_TLV(xname, xindex, left_reg, right_reg, shift_left, \\\n\t\t\t   shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4236_get_double1, .put = snd_cs4236_put_double1, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | \\\n\t\t   (shift_right << 19) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_cs4236_get_double1(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_double1(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;\n\tval2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;\n\tchange = val1 != chip->image[left_reg] || val2 != chip->eimage[CS4236_REG(right_reg)];\n\tsnd_wss_out(chip, left_reg, val1);\n\tsnd_cs4236_ext_out(chip, right_reg, val2);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define CS4236_MASTER_DIGITAL(xname, xindex, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4236_get_master_digital, .put = snd_cs4236_put_master_digital, \\\n  .private_value = 71 << 24, \\\n  .tlv = { .p = (xtlv) } }\n\nstatic inline int snd_cs4236_mixer_master_digital_invert_volume(int vol)\n{\n\treturn (vol < 64) ? 63 - vol : 64 + (71 - vol);\n}\n\nstatic int snd_cs4236_get_master_digital(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & 0x7f);\n\tucontrol->value.integer.value[1] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & 0x7f);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_master_digital(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short val1, val2;\n\t\n\tval1 = snd_cs4236_mixer_master_digital_invert_volume(ucontrol->value.integer.value[0] & 0x7f);\n\tval2 = snd_cs4236_mixer_master_digital_invert_volume(ucontrol->value.integer.value[1] & 0x7f);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval1 = (chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & ~0x7f) | val1;\n\tval2 = (chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & ~0x7f) | val2;\n\tchange = val1 != chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] || val2 != chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)];\n\tsnd_cs4236_ext_out(chip, CS4236_LEFT_MASTER, val1);\n\tsnd_cs4236_ext_out(chip, CS4236_RIGHT_MASTER, val2);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define CS4235_OUTPUT_ACCU(xname, xindex, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_cs4236_info_double, \\\n  .get = snd_cs4235_get_output_accu, .put = snd_cs4235_put_output_accu, \\\n  .private_value = 3 << 24, \\\n  .tlv = { .p = (xtlv) } }\n\nstatic inline int snd_cs4235_mixer_output_accu_get_volume(int vol)\n{\n\tswitch ((vol >> 5) & 3) {\n\tcase 0: return 1;\n\tcase 1: return 3;\n\tcase 2: return 2;\n\tcase 3: return 0;\n \t}\n\treturn 3;\n}\n\nstatic inline int snd_cs4235_mixer_output_accu_set_volume(int vol)\n{\n\tswitch (vol & 3) {\n\tcase 0: return 3 << 5;\n\tcase 1: return 0 << 5;\n\tcase 2: return 2 << 5;\n\tcase 3: return 1 << 5;\n\t}\n\treturn 1 << 5;\n}\n\nstatic int snd_cs4235_get_output_accu(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_LEFT_MASTER]);\n\tucontrol->value.integer.value[1] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_RIGHT_MASTER]);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_cs4235_put_output_accu(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short val1, val2;\n\t\n\tval1 = snd_cs4235_mixer_output_accu_set_volume(ucontrol->value.integer.value[0]);\n\tval2 = snd_cs4235_mixer_output_accu_set_volume(ucontrol->value.integer.value[1]);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval1 = (chip->image[CS4235_LEFT_MASTER] & ~(3 << 5)) | val1;\n\tval2 = (chip->image[CS4235_RIGHT_MASTER] & ~(3 << 5)) | val2;\n\tchange = val1 != chip->image[CS4235_LEFT_MASTER] || val2 != chip->image[CS4235_RIGHT_MASTER];\n\tsnd_wss_out(chip, CS4235_LEFT_MASTER, val1);\n\tsnd_wss_out(chip, CS4235_RIGHT_MASTER, val2);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_7bit, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_6bit_12db_max, -8250, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_22db_max, -2400, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_2bit, -1800, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_cs4236_controls[] = {\n\nCS4236_DOUBLE(\"Master Digital Playback Switch\", 0,\n\t\tCS4236_LEFT_MASTER, CS4236_RIGHT_MASTER, 7, 7, 1, 1),\nCS4236_DOUBLE(\"Master Digital Capture Switch\", 0,\n\t\tCS4236_DAC_MUTE, CS4236_DAC_MUTE, 7, 6, 1, 1),\nCS4236_MASTER_DIGITAL(\"Master Digital Volume\", 0, db_scale_7bit),\n\nCS4236_DOUBLE_TLV(\"Capture Boost Volume\", 0,\n\t\t  CS4236_LEFT_MIX_CTRL, CS4236_RIGHT_MIX_CTRL, 5, 5, 3, 1,\n\t\t  db_scale_2bit),\n\nWSS_DOUBLE(\"PCM Playback Switch\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"PCM Playback Volume\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 63, 1,\n\t\tdb_scale_6bit),\n\nCS4236_DOUBLE(\"DSP Playback Switch\", 0,\n\t\tCS4236_LEFT_DSP, CS4236_RIGHT_DSP, 7, 7, 1, 1),\nCS4236_DOUBLE_TLV(\"DSP Playback Volume\", 0,\n\t\t  CS4236_LEFT_DSP, CS4236_RIGHT_DSP, 0, 0, 63, 1,\n\t\t  db_scale_6bit),\n\nCS4236_DOUBLE(\"FM Playback Switch\", 0,\n\t\tCS4236_LEFT_FM, CS4236_RIGHT_FM, 7, 7, 1, 1),\nCS4236_DOUBLE_TLV(\"FM Playback Volume\", 0,\n\t\t  CS4236_LEFT_FM, CS4236_RIGHT_FM, 0, 0, 63, 1,\n\t\t  db_scale_6bit),\n\nCS4236_DOUBLE(\"Wavetable Playback Switch\", 0,\n\t\tCS4236_LEFT_WAVE, CS4236_RIGHT_WAVE, 7, 7, 1, 1),\nCS4236_DOUBLE_TLV(\"Wavetable Playback Volume\", 0,\n\t\t  CS4236_LEFT_WAVE, CS4236_RIGHT_WAVE, 0, 0, 63, 1,\n\t\t  db_scale_6bit_12db_max),\n\nWSS_DOUBLE(\"Synth Playback Switch\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Synth Volume\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_DOUBLE(\"Synth Capture Switch\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 6, 6, 1, 1),\nWSS_DOUBLE(\"Synth Capture Bypass\", 0,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 5, 5, 1, 1),\n\nCS4236_DOUBLE(\"Mic Playback Switch\", 0,\n\t\tCS4236_LEFT_MIC, CS4236_RIGHT_MIC, 6, 6, 1, 1),\nCS4236_DOUBLE(\"Mic Capture Switch\", 0,\n\t\tCS4236_LEFT_MIC, CS4236_RIGHT_MIC, 7, 7, 1, 1),\nCS4236_DOUBLE_TLV(\"Mic Volume\", 0, CS4236_LEFT_MIC, CS4236_RIGHT_MIC,\n\t\t  0, 0, 31, 1, db_scale_5bit_22db_max),\nCS4236_DOUBLE(\"Mic Playback Boost (+20dB)\", 0,\n\t\tCS4236_LEFT_MIC, CS4236_RIGHT_MIC, 5, 5, 1, 0),\n\nWSS_DOUBLE(\"Line Playback Switch\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Line Volume\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_DOUBLE(\"Line Capture Switch\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 6, 6, 1, 1),\nWSS_DOUBLE(\"Line Capture Bypass\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 5, 5, 1, 1),\n\nWSS_DOUBLE(\"CD Playback Switch\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"CD Volume\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\nWSS_DOUBLE(\"CD Capture Switch\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 6, 6, 1, 1),\n\nCS4236_DOUBLE1(\"Mono Output Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, CS4236_RIGHT_MIX_CTRL, 6, 7, 1, 1),\nCS4236_DOUBLE1(\"Beep Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, CS4236_LEFT_MIX_CTRL, 7, 7, 1, 1),\nWSS_SINGLE_TLV(\"Beep Playback Volume\", 0, CS4231_MONO_CTRL, 0, 15, 1,\n\t\tdb_scale_4bit),\nWSS_SINGLE(\"Beep Bypass Playback Switch\", 0, CS4231_MONO_CTRL, 5, 1, 0),\n\nWSS_DOUBLE_TLV(\"Capture Volume\", 0, CS4231_LEFT_INPUT, CS4231_RIGHT_INPUT,\n\t\t0, 0, 15, 0, db_scale_rec_gain),\nWSS_DOUBLE(\"Analog Loopback Capture Switch\", 0,\n\t\tCS4231_LEFT_INPUT, CS4231_RIGHT_INPUT, 7, 7, 1, 0),\n\nWSS_SINGLE(\"Loopback Digital Playback Switch\", 0, CS4231_LOOPBACK, 0, 1, 0),\nCS4236_DOUBLE1_TLV(\"Loopback Digital Playback Volume\", 0,\n\t\t   CS4231_LOOPBACK, CS4236_RIGHT_LOOPBACK, 2, 0, 63, 1,\n\t\t   db_scale_6bit),\n};\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_6db_max, -5600, 200, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_2bit_16db_max, -2400, 800, 0);\n\nstatic const struct snd_kcontrol_new snd_cs4235_controls[] = {\n\nWSS_DOUBLE(\"Master Playback Switch\", 0,\n\t\tCS4235_LEFT_MASTER, CS4235_RIGHT_MASTER, 7, 7, 1, 1),\nWSS_DOUBLE_TLV(\"Master Playback Volume\", 0,\n\t\tCS4235_LEFT_MASTER, CS4235_RIGHT_MASTER, 0, 0, 31, 1,\n\t\tdb_scale_5bit_6db_max),\n\nCS4235_OUTPUT_ACCU(\"Playback Volume\", 0, db_scale_2bit_16db_max),\n\nWSS_DOUBLE(\"Synth Playback Switch\", 1,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),\nWSS_DOUBLE(\"Synth Capture Switch\", 1,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 6, 6, 1, 1),\nWSS_DOUBLE_TLV(\"Synth Volume\", 1,\n\t\tCS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\n\nCS4236_DOUBLE_TLV(\"Capture Volume\", 0,\n\t\t  CS4236_LEFT_MIX_CTRL, CS4236_RIGHT_MIX_CTRL, 5, 5, 3, 1,\n\t\t  db_scale_2bit),\n\nWSS_DOUBLE(\"PCM Playback Switch\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"PCM Capture Switch\", 0,\n\t\tCS4236_DAC_MUTE, CS4236_DAC_MUTE, 7, 6, 1, 1),\nWSS_DOUBLE_TLV(\"PCM Volume\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 63, 1,\n\t\tdb_scale_6bit),\n\nCS4236_DOUBLE(\"DSP Switch\", 0, CS4236_LEFT_DSP, CS4236_RIGHT_DSP, 7, 7, 1, 1),\n\nCS4236_DOUBLE(\"FM Switch\", 0, CS4236_LEFT_FM, CS4236_RIGHT_FM, 7, 7, 1, 1),\n\nCS4236_DOUBLE(\"Wavetable Switch\", 0,\n\t\tCS4236_LEFT_WAVE, CS4236_RIGHT_WAVE, 7, 7, 1, 1),\n\nCS4236_DOUBLE(\"Mic Capture Switch\", 0,\n\t\tCS4236_LEFT_MIC, CS4236_RIGHT_MIC, 7, 7, 1, 1),\nCS4236_DOUBLE(\"Mic Playback Switch\", 0,\n\t\tCS4236_LEFT_MIC, CS4236_RIGHT_MIC, 6, 6, 1, 1),\nCS4236_SINGLE_TLV(\"Mic Volume\", 0, CS4236_LEFT_MIC, 0, 31, 1,\n\t\t  db_scale_5bit_22db_max),\nCS4236_SINGLE(\"Mic Boost (+20dB)\", 0, CS4236_LEFT_MIC, 5, 1, 0),\n\nWSS_DOUBLE(\"Line Playback Switch\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"Line Capture Switch\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 6, 6, 1, 1),\nWSS_DOUBLE_TLV(\"Line Volume\", 0,\n\t\tCS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\n\nWSS_DOUBLE(\"CD Playback Switch\", 1,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"CD Capture Switch\", 1,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 6, 6, 1, 1),\nWSS_DOUBLE_TLV(\"CD Volume\", 1,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 0, 0, 31, 1,\n\t\tdb_scale_5bit_12db_max),\n\nCS4236_DOUBLE1(\"Beep Playback Switch\", 0,\n\t\tCS4231_MONO_CTRL, CS4236_LEFT_MIX_CTRL, 7, 7, 1, 1),\nWSS_SINGLE(\"Beep Playback Volume\", 0, CS4231_MONO_CTRL, 0, 15, 1),\n\nWSS_DOUBLE(\"Analog Loopback Switch\", 0,\n\t\tCS4231_LEFT_INPUT, CS4231_RIGHT_INPUT, 7, 7, 1, 0),\n};\n\n#define CS4236_IEC958_ENABLE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_cs4236_info_single, \\\n  .get = snd_cs4236_get_iec958_switch, .put = snd_cs4236_put_iec958_switch, \\\n  .private_value = 1 << 16 }\n\nstatic int snd_cs4236_get_iec958_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = chip->image[CS4231_ALT_FEATURE_1] & 0x02 ? 1 : 0;\n#if 0\n\tprintk(KERN_DEBUG \"get valid: ALT = 0x%x, C3 = 0x%x, C4 = 0x%x, \"\n\t       \"C5 = 0x%x, C6 = 0x%x, C8 = 0x%x\\n\",\n\t\t\tsnd_wss_in(chip, CS4231_ALT_FEATURE_1),\n\t\t\tsnd_cs4236_ctrl_in(chip, 3),\n\t\t\tsnd_cs4236_ctrl_in(chip, 4),\n\t\t\tsnd_cs4236_ctrl_in(chip, 5),\n\t\t\tsnd_cs4236_ctrl_in(chip, 6),\n\t\t\tsnd_cs4236_ctrl_in(chip, 8));\n#endif\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_cs4236_put_iec958_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned short enable, val;\n\t\n\tenable = ucontrol->value.integer.value[0] & 1;\n\n\tmutex_lock(&chip->mce_mutex);\n\tsnd_wss_mce_up(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = (chip->image[CS4231_ALT_FEATURE_1] & ~0x0e) | (0<<2) | (enable << 1);\n\tchange = val != chip->image[CS4231_ALT_FEATURE_1];\n\tsnd_wss_out(chip, CS4231_ALT_FEATURE_1, val);\n\tval = snd_cs4236_ctrl_in(chip, 4) | 0xc0;\n\tsnd_cs4236_ctrl_out(chip, 4, val);\n\tudelay(100);\n\tval &= ~0x40;\n\tsnd_cs4236_ctrl_out(chip, 4, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tsnd_wss_mce_down(chip);\n\tmutex_unlock(&chip->mce_mutex);\n\n#if 0\n\tprintk(KERN_DEBUG \"set valid: ALT = 0x%x, C3 = 0x%x, C4 = 0x%x, \"\n\t       \"C5 = 0x%x, C6 = 0x%x, C8 = 0x%x\\n\",\n\t\t\tsnd_wss_in(chip, CS4231_ALT_FEATURE_1),\n\t\t\tsnd_cs4236_ctrl_in(chip, 3),\n\t\t\tsnd_cs4236_ctrl_in(chip, 4),\n\t\t\tsnd_cs4236_ctrl_in(chip, 5),\n\t\t\tsnd_cs4236_ctrl_in(chip, 6),\n\t\t\tsnd_cs4236_ctrl_in(chip, 8));\n#endif\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_cs4236_iec958_controls[] = {\nCS4236_IEC958_ENABLE(\"IEC958 Output Enable\", 0),\nCS4236_SINGLEC(\"IEC958 Output Validity\", 0, 4, 4, 1, 0),\nCS4236_SINGLEC(\"IEC958 Output User\", 0, 4, 5, 1, 0),\nCS4236_SINGLEC(\"IEC958 Output CSBR\", 0, 4, 6, 1, 0),\nCS4236_SINGLEC(\"IEC958 Output Channel Status Low\", 0, 5, 1, 127, 0),\nCS4236_SINGLEC(\"IEC958 Output Channel Status High\", 0, 6, 0, 255, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_cs4236_3d_controls_cs4235[] = {\nCS4236_SINGLEC(\"3D Control - Switch\", 0, 3, 4, 1, 0),\nCS4236_SINGLEC(\"3D Control - Space\", 0, 2, 4, 15, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_cs4236_3d_controls_cs4237[] = {\nCS4236_SINGLEC(\"3D Control - Switch\", 0, 3, 7, 1, 0),\nCS4236_SINGLEC(\"3D Control - Space\", 0, 2, 4, 15, 1),\nCS4236_SINGLEC(\"3D Control - Center\", 0, 2, 0, 15, 1),\nCS4236_SINGLEC(\"3D Control - Mono\", 0, 3, 6, 1, 0),\nCS4236_SINGLEC(\"3D Control - IEC958\", 0, 3, 5, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_cs4236_3d_controls_cs4238[] = {\nCS4236_SINGLEC(\"3D Control - Switch\", 0, 3, 4, 1, 0),\nCS4236_SINGLEC(\"3D Control - Space\", 0, 2, 4, 15, 1),\nCS4236_SINGLEC(\"3D Control - Volume\", 0, 2, 0, 15, 1),\nCS4236_SINGLEC(\"3D Control - IEC958\", 0, 3, 5, 1, 0)\n};\n\nint snd_cs4236_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card;\n\tunsigned int idx, count;\n\tint err;\n\tconst struct snd_kcontrol_new *kcontrol;\n\n\tif (snd_BUG_ON(!chip || !chip->card))\n\t\treturn -EINVAL;\n\tcard = chip->card;\n\tstrcpy(card->mixername, snd_wss_chip_id(chip));\n\n\tif (chip->hardware == WSS_HW_CS4235 ||\n\t    chip->hardware == WSS_HW_CS4239) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs4235_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs4235_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs4236_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs4236_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tswitch (chip->hardware) {\n\tcase WSS_HW_CS4235:\n\tcase WSS_HW_CS4239:\n\t\tcount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4235);\n\t\tkcontrol = snd_cs4236_3d_controls_cs4235;\n\t\tbreak;\n\tcase WSS_HW_CS4237B:\n\t\tcount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4237);\n\t\tkcontrol = snd_cs4236_3d_controls_cs4237;\n\t\tbreak;\n\tcase WSS_HW_CS4238B:\n\t\tcount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4238);\n\t\tkcontrol = snd_cs4236_3d_controls_cs4238;\n\t\tbreak;\n\tdefault:\n\t\tcount = 0;\n\t\tkcontrol = NULL;\n\t}\n\tfor (idx = 0; idx < count; idx++, kcontrol++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(kcontrol, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->hardware == WSS_HW_CS4237B ||\n\t    chip->hardware == WSS_HW_CS4238B) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs4236_iec958_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs4236_iec958_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}