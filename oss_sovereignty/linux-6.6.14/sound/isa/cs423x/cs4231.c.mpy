{
  "module_name": "cs4231.c",
  "hash_id": "7fe5164f6e008c1939a19e64e5dddf70a18c9d9682fe9afbe93478d920d6bc97",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/cs423x/cs4231.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/initval.h>\n\n#define CRD_NAME \"Generic CS4231\"\n#define DEV_NAME \"cs4231\"\n\nMODULE_DESCRIPTION(CRD_NAME);\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long mpu_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CRD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CRD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CRD_NAME \" soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for \" CRD_NAME \" driver.\");\n\nstatic int snd_cs4231_match(struct device *dev, unsigned int n)\n{\n\tif (!enable[n])\n\t\treturn 0;\n\n\tif (port[n] == SNDRV_AUTO_PORT) {\n\t\tdev_err(dev, \"please specify port\\n\");\n\t\treturn 0;\n\t}\n\tif (irq[n] == SNDRV_AUTO_IRQ) {\n\t\tdev_err(dev, \"please specify irq\\n\");\n\t\treturn 0;\n\t}\n\tif (dma1[n] == SNDRV_AUTO_DMA) {\n\t\tdev_err(dev, \"please specify dma1\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_cs4231_probe(struct device *dev, unsigned int n)\n{\n\tstruct snd_card *card;\n\tstruct snd_wss *chip;\n\tint error;\n\n\terror = snd_devm_card_new(dev, index[n], id[n], THIS_MODULE, 0, &card);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_wss_create(card, port[n], -1, irq[n], dma1[n], dma2[n],\n\t\t\tWSS_HW_DETECT, 0, &chip);\n\tif (error < 0)\n\t\treturn error;\n\n\tcard->private_data = chip;\n\n\terror = snd_wss_pcm(chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tstrscpy(card->driver, \"CS4231\", sizeof(card->driver));\n\tstrscpy(card->shortname, chip->pcm->name, sizeof(card->shortname));\n\n\tif (dma2[n] < 0)\n\t\tscnprintf(card->longname, sizeof(card->longname),\n\t\t\t  \"%s at 0x%lx, irq %d, dma %d\",\n\t\t\t  chip->pcm->name, chip->port, irq[n], dma1[n]);\n\telse\n\t\tscnprintf(card->longname, sizeof(card->longname),\n\t\t\t  \"%s at 0x%lx, irq %d, dma %d&%d\",\n\t\t\t  chip->pcm->name, chip->port, irq[n], dma1[n], dma2[n]);\n\n\terror = snd_wss_mixer(chip);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_wss_timer(chip, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (mpu_port[n] > 0 && mpu_port[n] != SNDRV_AUTO_PORT) {\n\t\tif (mpu_irq[n] == SNDRV_AUTO_IRQ)\n\t\t\tmpu_irq[n] = -1;\n\t\tif (snd_mpu401_uart_new(card, 0, MPU401_HW_CS4232,\n\t\t\t\t\tmpu_port[n], 0, mpu_irq[n],\n\t\t\t\t\tNULL) < 0)\n\t\t\tdev_warn(dev, \"MPU401 not detected\\n\");\n\t}\n\n\terror = snd_card_register(card);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_set_drvdata(dev, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_cs4231_suspend(struct device *dev, unsigned int n, pm_message_t state)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_wss *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tchip->suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_cs4231_resume(struct device *dev, unsigned int n)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_wss *chip = card->private_data;\n\n\tchip->resume(chip);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\nstatic struct isa_driver snd_cs4231_driver = {\n\t.match\t\t= snd_cs4231_match,\n\t.probe\t\t= snd_cs4231_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_cs4231_suspend,\n\t.resume\t\t= snd_cs4231_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t}\n};\n\nmodule_isa_driver(snd_cs4231_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}