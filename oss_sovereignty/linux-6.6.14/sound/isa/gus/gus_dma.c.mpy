{
  "module_name": "gus_dma.c",
  "hash_id": "28adcbf5752d027e572e1f9246be9de97d62cc6edb82bfc6e61886852a1a9914",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_dma.c",
  "human_readable_source": "\n \n\n#include <asm/dma.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n\nstatic void snd_gf1_dma_ack(struct snd_gus_card * gus)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL, 0x00);\n\tsnd_gf1_look8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\nstatic void snd_gf1_dma_program(struct snd_gus_card * gus,\n\t\t\t\tunsigned int addr,\n\t\t\t\tunsigned long buf_addr,\n\t\t\t\tunsigned int count,\n\t\t\t\tunsigned int cmd)\n{\n\tunsigned long flags;\n\tunsigned int address;\n\tunsigned char dma_cmd;\n\tunsigned int address_high;\n\n\tsnd_printdd(\"dma_transfer: addr=0x%x, buf=0x%lx, count=0x%x\\n\",\n\t\t    addr, buf_addr, count);\n\n\tif (gus->gf1.dma1 > 3) {\n\t\tif (gus->gf1.enh_mode) {\n\t\t\taddress = addr >> 1;\n\t\t} else {\n\t\t\tif (addr & 0x1f) {\n\t\t\t\tsnd_printd(\"snd_gf1_dma_transfer: unaligned address (0x%x)?\\n\", addr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taddress = (addr & 0x000c0000) | ((addr & 0x0003ffff) >> 1);\n\t\t}\n\t} else {\n\t\taddress = addr;\n\t}\n\n\tdma_cmd = SNDRV_GF1_DMA_ENABLE | (unsigned short) cmd;\n#if 0\n\tdma_cmd |= 0x08;\n#endif\n\tif (dma_cmd & SNDRV_GF1_DMA_16BIT) {\n\t\tcount++;\n\t\tcount &= ~1;\t \n\t}\n\tif (gus->gf1.dma1 > 3) {\n\t\tdma_cmd |= SNDRV_GF1_DMA_WIDTH16;\n\t\tcount++;\n\t\tcount &= ~1;\t \n\t}\n\tsnd_gf1_dma_ack(gus);\n\tsnd_dma_program(gus->gf1.dma1, buf_addr, count, dma_cmd & SNDRV_GF1_DMA_READ ? DMA_MODE_READ : DMA_MODE_WRITE);\n#if 0\n\tsnd_printk(KERN_DEBUG \"address = 0x%x, count = 0x%x, dma_cmd = 0x%x\\n\",\n\t\t   address << 1, count, dma_cmd);\n#endif\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tif (gus->gf1.enh_mode) {\n\t\taddress_high = ((address >> 16) & 0x000000f0) | (address & 0x0000000f);\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_GW_DRAM_DMA_LOW, (unsigned short) (address >> 4));\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_HIGH, (unsigned char) address_high);\n\t} else\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_GW_DRAM_DMA_LOW, (unsigned short) (address >> 4));\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL, dma_cmd);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\nstatic struct snd_gf1_dma_block *snd_gf1_dma_next_block(struct snd_gus_card * gus)\n{\n\tstruct snd_gf1_dma_block *block;\n\n\t \n\tif (gus->gf1.dma_data_pcm) {\n\t\tblock = gus->gf1.dma_data_pcm;\n\t\tif (gus->gf1.dma_data_pcm_last == block) {\n\t\t\tgus->gf1.dma_data_pcm =\n\t\t\tgus->gf1.dma_data_pcm_last = NULL;\n\t\t} else {\n\t\t\tgus->gf1.dma_data_pcm = block->next;\n\t\t}\n\t} else if (gus->gf1.dma_data_synth) {\n\t\tblock = gus->gf1.dma_data_synth;\n\t\tif (gus->gf1.dma_data_synth_last == block) {\n\t\t\tgus->gf1.dma_data_synth =\n\t\t\tgus->gf1.dma_data_synth_last = NULL;\n\t\t} else {\n\t\t\tgus->gf1.dma_data_synth = block->next;\n\t\t}\n\t} else {\n\t\tblock = NULL;\n\t}\n\tif (block) {\n\t\tgus->gf1.dma_ack = block->ack;\n\t\tgus->gf1.dma_private_data = block->private_data;\n\t}\n\treturn block;\n}\n\n\nstatic void snd_gf1_dma_interrupt(struct snd_gus_card * gus)\n{\n\tstruct snd_gf1_dma_block *block;\n\n\tsnd_gf1_dma_ack(gus);\n\tif (gus->gf1.dma_ack)\n\t\tgus->gf1.dma_ack(gus, gus->gf1.dma_private_data);\n\tspin_lock(&gus->dma_lock);\n\tif (gus->gf1.dma_data_pcm == NULL &&\n\t    gus->gf1.dma_data_synth == NULL) {\n\t    \tgus->gf1.dma_ack = NULL;\n\t\tgus->gf1.dma_flags &= ~SNDRV_GF1_DMA_TRIGGER;\n\t\tspin_unlock(&gus->dma_lock);\n\t\treturn;\n\t}\n\tblock = snd_gf1_dma_next_block(gus);\n\tspin_unlock(&gus->dma_lock);\n\tif (!block)\n\t\treturn;\n\tsnd_gf1_dma_program(gus, block->addr, block->buf_addr, block->count, (unsigned short) block->cmd);\n\tkfree(block);\n#if 0\n\tsnd_printd(KERN_DEBUG \"program dma (IRQ) - \"\n\t\t   \"addr = 0x%x, buffer = 0x%lx, count = 0x%x, cmd = 0x%x\\n\",\n\t\t   block->addr, block->buf_addr, block->count, block->cmd);\n#endif\n}\n\nint snd_gf1_dma_init(struct snd_gus_card * gus)\n{\n\tmutex_lock(&gus->dma_mutex);\n\tgus->gf1.dma_shared++;\n\tif (gus->gf1.dma_shared > 1) {\n\t\tmutex_unlock(&gus->dma_mutex);\n\t\treturn 0;\n\t}\n\tgus->gf1.interrupt_handler_dma_write = snd_gf1_dma_interrupt;\n\tgus->gf1.dma_data_pcm = \n\tgus->gf1.dma_data_pcm_last =\n\tgus->gf1.dma_data_synth = \n\tgus->gf1.dma_data_synth_last = NULL;\n\tmutex_unlock(&gus->dma_mutex);\n\treturn 0;\n}\n\nint snd_gf1_dma_done(struct snd_gus_card * gus)\n{\n\tstruct snd_gf1_dma_block *block;\n\n\tmutex_lock(&gus->dma_mutex);\n\tgus->gf1.dma_shared--;\n\tif (!gus->gf1.dma_shared) {\n\t\tsnd_dma_disable(gus->gf1.dma1);\n\t\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_DMA_WRITE);\n\t\tsnd_gf1_dma_ack(gus);\n\t\twhile ((block = gus->gf1.dma_data_pcm)) {\n\t\t\tgus->gf1.dma_data_pcm = block->next;\n\t\t\tkfree(block);\n\t\t}\n\t\twhile ((block = gus->gf1.dma_data_synth)) {\n\t\t\tgus->gf1.dma_data_synth = block->next;\n\t\t\tkfree(block);\n\t\t}\n\t\tgus->gf1.dma_data_pcm_last =\n\t\tgus->gf1.dma_data_synth_last = NULL;\n\t}\n\tmutex_unlock(&gus->dma_mutex);\n\treturn 0;\n}\n\nint snd_gf1_dma_transfer_block(struct snd_gus_card * gus,\n\t\t\t       struct snd_gf1_dma_block * __block,\n\t\t\t       int atomic,\n\t\t\t       int synth)\n{\n\tunsigned long flags;\n\tstruct snd_gf1_dma_block *block;\n\n\tblock = kmalloc(sizeof(*block), atomic ? GFP_ATOMIC : GFP_KERNEL);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\t*block = *__block;\n\tblock->next = NULL;\n\n\tsnd_printdd(\"addr = 0x%x, buffer = 0x%lx, count = 0x%x, cmd = 0x%x\\n\",\n\t\t    block->addr, (long) block->buffer, block->count,\n\t\t    block->cmd);\n\n\tsnd_printdd(\"gus->gf1.dma_data_pcm_last = 0x%lx\\n\",\n\t\t    (long)gus->gf1.dma_data_pcm_last);\n\tsnd_printdd(\"gus->gf1.dma_data_pcm = 0x%lx\\n\",\n\t\t    (long)gus->gf1.dma_data_pcm);\n\n\tspin_lock_irqsave(&gus->dma_lock, flags);\n\tif (synth) {\n\t\tif (gus->gf1.dma_data_synth_last) {\n\t\t\tgus->gf1.dma_data_synth_last->next = block;\n\t\t\tgus->gf1.dma_data_synth_last = block;\n\t\t} else {\n\t\t\tgus->gf1.dma_data_synth = \n\t\t\tgus->gf1.dma_data_synth_last = block;\n\t\t}\n\t} else {\n\t\tif (gus->gf1.dma_data_pcm_last) {\n\t\t\tgus->gf1.dma_data_pcm_last->next = block;\n\t\t\tgus->gf1.dma_data_pcm_last = block;\n\t\t} else {\n\t\t\tgus->gf1.dma_data_pcm = \n\t\t\tgus->gf1.dma_data_pcm_last = block;\n\t\t}\n\t}\n\tif (!(gus->gf1.dma_flags & SNDRV_GF1_DMA_TRIGGER)) {\n\t\tgus->gf1.dma_flags |= SNDRV_GF1_DMA_TRIGGER;\n\t\tblock = snd_gf1_dma_next_block(gus);\n\t\tspin_unlock_irqrestore(&gus->dma_lock, flags);\n\t\tif (block == NULL)\n\t\t\treturn 0;\n\t\tsnd_gf1_dma_program(gus, block->addr, block->buf_addr, block->count, (unsigned short) block->cmd);\n\t\tkfree(block);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&gus->dma_lock, flags);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}