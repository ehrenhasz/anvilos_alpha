{
  "module_name": "gus_irq.c",
  "hash_id": "b0b0b599f8892791beb9b06cfa04fb49e92d53760dbe1c6d911984d12ebb20c3",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_irq.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/gus.h>\n\n#ifdef CONFIG_SND_DEBUG\n#define STAT_ADD(x)\t((x)++)\n#else\n#define STAT_ADD(x)\twhile (0) { ; }\n#endif\n\nirqreturn_t snd_gus_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_gus_card * gus = dev_id;\n\tunsigned char status;\n\tint loop = 100;\n\tint handled = 0;\n\n__again:\n\tstatus = inb(gus->gf1.reg_irqstat);\n\tif (status == 0)\n\t\treturn IRQ_RETVAL(handled);\n\thandled = 1;\n\t \n\tif (status & 0x02) {\n\t\tSTAT_ADD(gus->gf1.interrupt_stat_midi_in);\n\t\tif (gus->gf1.interrupt_handler_midi_in)\n\t\t\tgus->gf1.interrupt_handler_midi_in(gus);\n\t}\n\tif (status & 0x01) {\n\t\tSTAT_ADD(gus->gf1.interrupt_stat_midi_out);\n\t\tif (gus->gf1.interrupt_handler_midi_out)\n\t\t\tgus->gf1.interrupt_handler_midi_out(gus);\n\t}\n\tif (status & (0x20 | 0x40)) {\n\t\tunsigned int already, _current_;\n\t\tunsigned char voice_status, voice;\n\t\tstruct snd_gus_voice *pvoice;\n\n\t\talready = 0;\n\t\twhile (((voice_status = snd_gf1_i_read8(gus, SNDRV_GF1_GB_VOICES_IRQ)) & 0xc0) != 0xc0) {\n\t\t\tvoice = voice_status & 0x1f;\n\t\t\t_current_ = 1 << voice;\n\t\t\tif (already & _current_)\n\t\t\t\tcontinue;\t \n\t\t\talready |= _current_;\t \n#if 0\n\t\t\tprintk(KERN_DEBUG \"voice = %i, voice_status = 0x%x, \"\n\t\t\t       \"voice_verify = %i\\n\",\n\t\t\t       voice, voice_status, inb(GUSP(gus, GF1PAGE)));\n#endif\n\t\t\tpvoice = &gus->gf1.voices[voice]; \n\t\t\tif (pvoice->use) {\n\t\t\t\tif (!(voice_status & 0x80)) {\t \n\t\t\t\t\tSTAT_ADD(pvoice->interrupt_stat_wave);\n\t\t\t\t\tpvoice->handler_wave(gus, pvoice);\n\t\t\t\t}\n\t\t\t\tif (!(voice_status & 0x40)) {\t \n\t\t\t\t\tSTAT_ADD(pvoice->interrupt_stat_volume);\n\t\t\t\t\tpvoice->handler_volume(gus, pvoice);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSTAT_ADD(gus->gf1.interrupt_stat_voice_lost);\n\t\t\t\tsnd_gf1_i_ctrl_stop(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\n\t\t\t\tsnd_gf1_i_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\n\t\t\t}\n\t\t}\n\t}\n\tif (status & 0x04) {\n\t\tSTAT_ADD(gus->gf1.interrupt_stat_timer1);\n\t\tif (gus->gf1.interrupt_handler_timer1)\n\t\t\tgus->gf1.interrupt_handler_timer1(gus);\n\t}\n\tif (status & 0x08) {\n\t\tSTAT_ADD(gus->gf1.interrupt_stat_timer2);\n\t\tif (gus->gf1.interrupt_handler_timer2)\n\t\t\tgus->gf1.interrupt_handler_timer2(gus);\n\t}\n\tif (status & 0x80) {\n\t\tif (snd_gf1_i_look8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL) & 0x40) {\n\t\t\tSTAT_ADD(gus->gf1.interrupt_stat_dma_write);\n\t\t\tif (gus->gf1.interrupt_handler_dma_write)\n\t\t\t\tgus->gf1.interrupt_handler_dma_write(gus);\n\t\t}\n\t\tif (snd_gf1_i_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL) & 0x40) {\n\t\t\tSTAT_ADD(gus->gf1.interrupt_stat_dma_read);\n\t\t\tif (gus->gf1.interrupt_handler_dma_read)\n\t\t\t\tgus->gf1.interrupt_handler_dma_read(gus);\n\t\t}\n\t}\n\tif (--loop > 0)\n\t\tgoto __again;\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_SND_DEBUG\nstatic void snd_gus_irq_info_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_gus_card *gus;\n\tstruct snd_gus_voice *pvoice;\n\tint idx;\n\n\tgus = entry->private_data;\n\tsnd_iprintf(buffer, \"midi out = %u\\n\", gus->gf1.interrupt_stat_midi_out);\n\tsnd_iprintf(buffer, \"midi in = %u\\n\", gus->gf1.interrupt_stat_midi_in);\n\tsnd_iprintf(buffer, \"timer1 = %u\\n\", gus->gf1.interrupt_stat_timer1);\n\tsnd_iprintf(buffer, \"timer2 = %u\\n\", gus->gf1.interrupt_stat_timer2);\n\tsnd_iprintf(buffer, \"dma write = %u\\n\", gus->gf1.interrupt_stat_dma_write);\n\tsnd_iprintf(buffer, \"dma read = %u\\n\", gus->gf1.interrupt_stat_dma_read);\n\tsnd_iprintf(buffer, \"voice lost = %u\\n\", gus->gf1.interrupt_stat_voice_lost);\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tpvoice = &gus->gf1.voices[idx];\n\t\tsnd_iprintf(buffer, \"voice %i: wave = %u, volume = %u\\n\",\n\t\t\t\t\tidx,\n\t\t\t\t\tpvoice->interrupt_stat_wave,\n\t\t\t\t\tpvoice->interrupt_stat_volume);\n\t}\n}\n\nvoid snd_gus_irq_profile_init(struct snd_gus_card *gus)\n{\n\tsnd_card_ro_proc_new(gus->card, \"gusirq\", gus, snd_gus_irq_info_read);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}