{
  "module_name": "gus_reset.c",
  "hash_id": "d9412ed0ebc38b1f4a3a0a6c426a6a12ff38296936f69c07483524db5a4b0782",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_reset.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n\nextern int snd_gf1_synth_init(struct snd_gus_card * gus);\nextern void snd_gf1_synth_done(struct snd_gus_card * gus);\n\n \n\nstatic void snd_gf1_default_interrupt_handler_midi_out(struct snd_gus_card * gus)\n{\n\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd &= ~0x20);\n}\n\nstatic void snd_gf1_default_interrupt_handler_midi_in(struct snd_gus_card * gus)\n{\n\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd &= ~0x80);\n}\n\nstatic void snd_gf1_default_interrupt_handler_timer1(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, gus->gf1.timer_enabled &= ~4);\n}\n\nstatic void snd_gf1_default_interrupt_handler_timer2(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, gus->gf1.timer_enabled &= ~8);\n}\n\nstatic void snd_gf1_default_interrupt_handler_wave_and_volume(struct snd_gus_card * gus, struct snd_gus_voice * voice)\n{\n\tsnd_gf1_i_ctrl_stop(gus, 0x00);\n\tsnd_gf1_i_ctrl_stop(gus, 0x0d);\n}\n\nstatic void snd_gf1_default_interrupt_handler_dma_write(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, 0x41, 0x00);\n}\n\nstatic void snd_gf1_default_interrupt_handler_dma_read(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, 0x49, 0x00);\n}\n\nvoid snd_gf1_set_default_handlers(struct snd_gus_card * gus, unsigned int what)\n{\n\tif (what & SNDRV_GF1_HANDLER_MIDI_OUT)\n\t\tgus->gf1.interrupt_handler_midi_out = snd_gf1_default_interrupt_handler_midi_out;\n\tif (what & SNDRV_GF1_HANDLER_MIDI_IN)\n\t\tgus->gf1.interrupt_handler_midi_in = snd_gf1_default_interrupt_handler_midi_in;\n\tif (what & SNDRV_GF1_HANDLER_TIMER1)\n\t\tgus->gf1.interrupt_handler_timer1 = snd_gf1_default_interrupt_handler_timer1;\n\tif (what & SNDRV_GF1_HANDLER_TIMER2)\n\t\tgus->gf1.interrupt_handler_timer2 = snd_gf1_default_interrupt_handler_timer2;\n\tif (what & SNDRV_GF1_HANDLER_VOICE) {\n\t\tstruct snd_gus_voice *voice;\n\t\t\n\t\tvoice = &gus->gf1.voices[what & 0xffff];\n\t\tvoice->handler_wave =\n\t\tvoice->handler_volume = snd_gf1_default_interrupt_handler_wave_and_volume;\n\t\tvoice->handler_effect = NULL;\n\t\tvoice->volume_change = NULL;\n\t}\n\tif (what & SNDRV_GF1_HANDLER_DMA_WRITE)\n\t\tgus->gf1.interrupt_handler_dma_write = snd_gf1_default_interrupt_handler_dma_write;\n\tif (what & SNDRV_GF1_HANDLER_DMA_READ)\n\t\tgus->gf1.interrupt_handler_dma_read = snd_gf1_default_interrupt_handler_dma_read;\n}\n\n \n\nstatic void snd_gf1_clear_regs(struct snd_gus_card * gus)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tinb(GUSP(gus, IRQSTAT));\n\tsnd_gf1_write8(gus, 0x41, 0);\t \n\tsnd_gf1_write8(gus, 0x45, 0);\t \n\tsnd_gf1_write8(gus, 0x49, 0);\t \n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\nstatic void snd_gf1_look_regs(struct snd_gus_card * gus)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tsnd_gf1_look8(gus, 0x41);\t \n\tsnd_gf1_look8(gus, 0x49);\t \n\tinb(GUSP(gus, IRQSTAT));\n\tsnd_gf1_read8(gus, 0x0f);\t \n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\n \n\nvoid snd_gf1_smart_stop_voice(struct snd_gus_card * gus, unsigned short voice)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tsnd_gf1_select_voice(gus, voice);\n#if 0\n\tprintk(KERN_DEBUG \" -%i- smart stop voice - volume = 0x%x\\n\", voice, snd_gf1_i_read16(gus, SNDRV_GF1_VW_VOLUME));\n#endif\n\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\n\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\nvoid snd_gf1_stop_voice(struct snd_gus_card * gus, unsigned short voice)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tsnd_gf1_select_voice(gus, voice);\n#if 0\n\tprintk(KERN_DEBUG \" -%i- stop voice - volume = 0x%x\\n\", voice, snd_gf1_i_read16(gus, SNDRV_GF1_VW_VOLUME));\n#endif\n\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\n\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\n\tif (gus->gf1.enh_mode)\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ACCUMULATOR, 0);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n#if 0\n\tsnd_gf1_lfo_shutdown(gus, voice, ULTRA_LFO_VIBRATO);\n\tsnd_gf1_lfo_shutdown(gus, voice, ULTRA_LFO_TREMOLO);\n#endif\n}\n\nstatic void snd_gf1_clear_voices(struct snd_gus_card * gus, unsigned short v_min,\n\t\t\t\t unsigned short v_max)\n{\n\tunsigned long flags;\n\tunsigned int daddr;\n\tunsigned short i, w_16;\n\n\tdaddr = gus->gf1.default_voice_address << 4;\n\tfor (i = v_min; i <= v_max; i++) {\n#if 0\n\t\tif (gus->gf1.syn_voices)\n\t\t\tgus->gf1.syn_voices[i].flags = ~VFLG_DYNAMIC;\n#endif\n\t\tspin_lock_irqsave(&gus->reg_lock, flags);\n\t\tsnd_gf1_select_voice(gus, i);\n\t\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\t \n\t\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\t \n\t\tif (gus->gf1.enh_mode)\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_MODE, gus->gf1.memory ? 0x02 : 0x82);\t \n\t\tw_16 = snd_gf1_read8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL) & 0x04;\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_FREQUENCY, 0x400);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_START, daddr, w_16);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_END, daddr, w_16);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_START, 0);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_END, 0);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_RATE, 0);\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, 0);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_CURRENT, daddr, w_16);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_PAN, 7);\n\t\tif (gus->gf1.enh_mode) {\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ACCUMULATOR, 0);\n\t\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_EFFECT_VOLUME, 0);\n\t\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_EFFECT_VOLUME_FINAL, 0);\n\t\t}\n\t\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n#if 0\n\t\tsnd_gf1_lfo_shutdown(gus, i, ULTRA_LFO_VIBRATO);\n\t\tsnd_gf1_lfo_shutdown(gus, i, ULTRA_LFO_TREMOLO);\n#endif\n\t}\n}\n\nvoid snd_gf1_stop_voices(struct snd_gus_card * gus, unsigned short v_min, unsigned short v_max)\n{\n\tunsigned long flags;\n\tshort i, ramp_ok;\n\tunsigned short ramp_end;\n\n\tif (!in_interrupt()) {\t \n\t\tfor (i = v_min, ramp_ok = 0; i <= v_max; i++) {\n\t\t\tspin_lock_irqsave(&gus->reg_lock, flags);\n\t\t\tsnd_gf1_select_voice(gus, i);\n\t\t\tramp_end = snd_gf1_read16(gus, 9) >> 8;\n\t\t\tif (ramp_end > SNDRV_GF1_MIN_OFFSET) {\n\t\t\t\tramp_ok++;\n\t\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_RATE, 20);\t \n\t\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_START, SNDRV_GF1_MIN_OFFSET);\t \n\t\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_END, ramp_end);\t \n\t\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, 0x40);\t \n\t\t\t\tif (gus->gf1.enh_mode) {\n\t\t\t\t\tsnd_gf1_delay(gus);\n\t\t\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, 0x40);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\t\t}\n\t\tmsleep_interruptible(50);\n\t}\n\tsnd_gf1_clear_voices(gus, v_min, v_max);\n}\n\nstatic void snd_gf1_alloc_voice_use(struct snd_gus_card * gus, \n\t\t\t\t    struct snd_gus_voice * pvoice,\n\t\t\t\t    int type, int client, int port)\n{\n\tpvoice->use = 1;\n\tswitch (type) {\n\tcase SNDRV_GF1_VOICE_TYPE_PCM:\n\t\tgus->gf1.pcm_alloc_voices++;\n\t\tpvoice->pcm = 1;\n\t\tbreak;\n\tcase SNDRV_GF1_VOICE_TYPE_SYNTH:\n\t\tpvoice->synth = 1;\n\t\tpvoice->client = client;\n\t\tpvoice->port = port;\n\t\tbreak;\n\tcase SNDRV_GF1_VOICE_TYPE_MIDI:\n\t\tpvoice->midi = 1;\n\t\tpvoice->client = client;\n\t\tpvoice->port = port;\n\t\tbreak;\n\t}\n}\n\nstruct snd_gus_voice *snd_gf1_alloc_voice(struct snd_gus_card * gus, int type, int client, int port)\n{\n\tstruct snd_gus_voice *pvoice;\n\tunsigned long flags;\n\tint idx;\n\n\tspin_lock_irqsave(&gus->voice_alloc, flags);\n\tif (type == SNDRV_GF1_VOICE_TYPE_PCM) {\n\t\tif (gus->gf1.pcm_alloc_voices >= gus->gf1.pcm_channels) {\n\t\t\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tpvoice = &gus->gf1.voices[idx];\n\t\tif (!pvoice->use) {\n\t\t\tsnd_gf1_alloc_voice_use(gus, pvoice, type, client, port);\n\t\t\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\t\t\treturn pvoice;\n\t\t}\n\t} \n\tfor (idx = 0; idx < 32; idx++) {\n\t\tpvoice = &gus->gf1.voices[idx];\n\t\tif (pvoice->midi && !pvoice->client) {\n\t\t\tsnd_gf1_clear_voices(gus, pvoice->number, pvoice->number);\n\t\t\tsnd_gf1_alloc_voice_use(gus, pvoice, type, client, port);\n\t\t\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\t\t\treturn pvoice;\n\t\t}\n\t} \n\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\treturn NULL;\n}\n\nvoid snd_gf1_free_voice(struct snd_gus_card * gus, struct snd_gus_voice *voice)\n{\n\tunsigned long flags;\n\tvoid (*private_free)(struct snd_gus_voice *voice);\n\n\tif (voice == NULL || !voice->use)\n\t\treturn;\n\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_VOICE | voice->number);\n\tsnd_gf1_clear_voices(gus, voice->number, voice->number);\n\tspin_lock_irqsave(&gus->voice_alloc, flags);\n\tprivate_free = voice->private_free;\n\tvoice->private_free = NULL;\n\tvoice->private_data = NULL;\n\tif (voice->pcm)\n\t\tgus->gf1.pcm_alloc_voices--;\n\tvoice->use = voice->pcm = 0;\n\tvoice->sample_ops = NULL;\n\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\tif (private_free)\n\t\tprivate_free(voice);\n}\n\n \n\nint snd_gf1_start(struct snd_gus_card * gus)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\t \n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\t \n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_JOYSTICK_DAC_LEVEL, gus->joystick_dac);\n\n\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_ALL);\n\tfor (i = 0; i < 32; i++) {\n\t\tgus->gf1.voices[i].number = i;\n\t\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_VOICE | i);\n\t}\n\n\tsnd_gf1_uart_cmd(gus, 0x03);\t \n\n\tif (gus->gf1.enh_mode) {\t \n\t\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_GLOBAL_MODE, snd_gf1_i_look8(gus, SNDRV_GF1_GB_GLOBAL_MODE) | 0x01);\n\t\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01);\n\t}\n\tsnd_gf1_clear_regs(gus);\n\tsnd_gf1_select_active_voices(gus);\n\tsnd_gf1_delay(gus);\n\tgus->gf1.default_voice_address = gus->gf1.memory > 0 ? 0 : 512 - 8;\n\t \n\tif (gus->gf1.enh_mode && gus->gf1.memory) {\n\t\tgus->gf1.hw_lfo = 1;\n\t\tgus->gf1.default_voice_address += 1024;\n\t} else {\n\t\tgus->gf1.sw_lfo = 1;\n\t}\n#if 0\n\tsnd_gf1_lfo_init(gus);\n#endif\n\tif (gus->gf1.memory > 0)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tsnd_gf1_poke(gus, gus->gf1.default_voice_address + i, 0);\n\tsnd_gf1_clear_regs(gus);\n\tsnd_gf1_clear_voices(gus, 0, 31);\n\tsnd_gf1_look_regs(gus);\n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 7);\t \n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 7);\t \n\tif (gus->gf1.enh_mode) {\t \n\t\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_GLOBAL_MODE, snd_gf1_i_look8(gus, SNDRV_GF1_GB_GLOBAL_MODE) | 0x01);\n\t\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01);\n\t}\n\twhile ((snd_gf1_i_read8(gus, SNDRV_GF1_GB_VOICES_IRQ) & 0xc0) != 0xc0);\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(gus->gf1.active_voice = 0, GUSP(gus, GF1PAGE));\n\toutb(gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\n\tsnd_gf1_timers_init(gus);\n\tsnd_gf1_look_regs(gus);\n\tsnd_gf1_mem_init(gus);\n\tsnd_gf1_mem_proc_init(gus);\n#ifdef CONFIG_SND_DEBUG\n\tsnd_gus_irq_profile_init(gus);\n#endif\n\n#if 0\n\tif (gus->pnp_flag) {\n\t\tif (gus->chip.playback_fifo_size > 0)\n\t\t\tsnd_gf1_i_write16(gus, SNDRV_GF1_GW_FIFO_RECORD_BASE_ADDR, gus->chip.playback_fifo_block->ptr >> 8);\n\t\tif (gus->chip.record_fifo_size > 0)\n\t\t\tsnd_gf1_i_write16(gus, SNDRV_GF1_GW_FIFO_PLAY_BASE_ADDR, gus->chip.record_fifo_block->ptr >> 8);\n\t\tsnd_gf1_i_write16(gus, SNDRV_GF1_GW_FIFO_SIZE, gus->chip.interwave_fifo_reg);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \n\nint snd_gf1_stop(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, 0);  \n\tsnd_gf1_stop_voices(gus, 0, 31);\t\t \n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\t \n\tsnd_gf1_timers_done(gus);\n\tsnd_gf1_mem_done(gus);\n#if 0\n\tsnd_gf1_lfo_done(gus);\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}