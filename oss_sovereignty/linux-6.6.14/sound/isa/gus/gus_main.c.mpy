{
  "module_name": "gus_main.c",
  "hash_id": "f1b412a12128c096e2bf57411467183df7ade1155ec1bbdac264f4d2bbe8aa5f",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_main.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#include <sound/control.h>\n\n#include <asm/dma.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for Gravis UltraSound soundcards\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int snd_gus_init_dma_irq(struct snd_gus_card * gus, int latches);\n\nint snd_gus_use_inc(struct snd_gus_card * gus)\n{\n\tif (!try_module_get(gus->card->module))\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid snd_gus_use_dec(struct snd_gus_card * gus)\n{\n\tmodule_put(gus->card->module);\n}\n\nstatic int snd_gus_joystick_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 31;\n\treturn 0;\n}\n\nstatic int snd_gus_joystick_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = gus->joystick_dac & 31;\n\treturn 0;\n}\n\nstatic int snd_gus_joystick_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned char nval;\n\t\n\tnval = ucontrol->value.integer.value[0] & 31;\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tchange = gus->joystick_dac != nval;\n\tgus->joystick_dac = nval;\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_JOYSTICK_DAC_LEVEL, gus->joystick_dac);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_gus_joystick_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"Joystick Speed\",\n\t.info = snd_gus_joystick_info,\n\t.get = snd_gus_joystick_get,\n\t.put = snd_gus_joystick_put\n};\n\nstatic void snd_gus_init_control(struct snd_gus_card *gus)\n{\n\tif (!gus->ace_flag)\n\t\tsnd_ctl_add(gus->card, snd_ctl_new1(&snd_gus_joystick_control, gus));\n}\n\n \n\nstatic int snd_gus_free(struct snd_gus_card *gus)\n{\n\tif (gus->gf1.res_port2 == NULL)\n\t\tgoto __hw_end;\n\tsnd_gf1_stop(gus);\n\tsnd_gus_init_dma_irq(gus, 0);\n      __hw_end:\n\trelease_and_free_resource(gus->gf1.res_port1);\n\trelease_and_free_resource(gus->gf1.res_port2);\n\tif (gus->gf1.irq >= 0)\n\t\tfree_irq(gus->gf1.irq, (void *) gus);\n\tif (gus->gf1.dma1 >= 0) {\n\t\tdisable_dma(gus->gf1.dma1);\n\t\tfree_dma(gus->gf1.dma1);\n\t}\n\tif (!gus->equal_dma && gus->gf1.dma2 >= 0) {\n\t\tdisable_dma(gus->gf1.dma2);\n\t\tfree_dma(gus->gf1.dma2);\n\t}\n\tkfree(gus);\n\treturn 0;\n}\n\nstatic int snd_gus_dev_free(struct snd_device *device)\n{\n\tstruct snd_gus_card *gus = device->device_data;\n\treturn snd_gus_free(gus);\n}\n\nint snd_gus_create(struct snd_card *card,\n\t\t   unsigned long port,\n\t\t   int irq, int dma1, int dma2,\n\t\t   int timer_dev,\n\t\t   int voices,\n\t\t   int pcm_channels,\n\t\t   int effect,\n\t\t   struct snd_gus_card **rgus)\n{\n\tstruct snd_gus_card *gus;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_gus_dev_free,\n\t};\n\n\t*rgus = NULL;\n\tgus = kzalloc(sizeof(*gus), GFP_KERNEL);\n\tif (gus == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gus->reg_lock);\n\tspin_lock_init(&gus->voice_alloc);\n\tspin_lock_init(&gus->active_voice_lock);\n\tspin_lock_init(&gus->event_lock);\n\tspin_lock_init(&gus->dma_lock);\n\tspin_lock_init(&gus->pcm_volume_level_lock);\n\tspin_lock_init(&gus->uart_cmd_lock);\n\tmutex_init(&gus->dma_mutex);\n\tgus->gf1.irq = -1;\n\tgus->gf1.dma1 = -1;\n\tgus->gf1.dma2 = -1;\n\tgus->card = card;\n\tgus->gf1.port = port;\n\t \n\tgus->gf1.reg_page = GUSP(gus, GF1PAGE);\n\tgus->gf1.reg_regsel = GUSP(gus, GF1REGSEL);\n\tgus->gf1.reg_data8 = GUSP(gus, GF1DATAHIGH);\n\tgus->gf1.reg_data16 = GUSP(gus, GF1DATALOW);\n\tgus->gf1.reg_irqstat = GUSP(gus, IRQSTAT);\n\tgus->gf1.reg_dram = GUSP(gus, DRAM);\n\tgus->gf1.reg_timerctrl = GUSP(gus, TIMERCNTRL);\n\tgus->gf1.reg_timerdata = GUSP(gus, TIMERDATA);\n\t \n\tgus->gf1.res_port1 = request_region(port, 16, \"GUS GF1 (Adlib/SB)\");\n\tif (!gus->gf1.res_port1) {\n\t\tsnd_printk(KERN_ERR \"gus: can't grab SB port 0x%lx\\n\", port);\n\t\tsnd_gus_free(gus);\n\t\treturn -EBUSY;\n\t}\n\tgus->gf1.res_port2 = request_region(port + 0x100, 12, \"GUS GF1 (Synth)\");\n\tif (!gus->gf1.res_port2) {\n\t\tsnd_printk(KERN_ERR \"gus: can't grab synth port 0x%lx\\n\", port + 0x100);\n\t\tsnd_gus_free(gus);\n\t\treturn -EBUSY;\n\t}\n\tif (irq >= 0 && request_irq(irq, snd_gus_interrupt, 0, \"GUS GF1\", (void *) gus)) {\n\t\tsnd_printk(KERN_ERR \"gus: can't grab irq %d\\n\", irq);\n\t\tsnd_gus_free(gus);\n\t\treturn -EBUSY;\n\t}\n\tgus->gf1.irq = irq;\n\tcard->sync_irq = irq;\n\tif (request_dma(dma1, \"GUS - 1\")) {\n\t\tsnd_printk(KERN_ERR \"gus: can't grab DMA1 %d\\n\", dma1);\n\t\tsnd_gus_free(gus);\n\t\treturn -EBUSY;\n\t}\n\tgus->gf1.dma1 = dma1;\n\tif (dma2 >= 0 && dma1 != dma2) {\n\t\tif (request_dma(dma2, \"GUS - 2\")) {\n\t\t\tsnd_printk(KERN_ERR \"gus: can't grab DMA2 %d\\n\", dma2);\n\t\t\tsnd_gus_free(gus);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tgus->gf1.dma2 = dma2;\n\t} else {\n\t\tgus->gf1.dma2 = gus->gf1.dma1;\n\t\tgus->equal_dma = 1;\n\t}\n\tgus->timer_dev = timer_dev;\n\tif (voices < 14)\n\t\tvoices = 14;\n\tif (voices > 32)\n\t\tvoices = 32;\n\tif (pcm_channels < 0)\n\t\tpcm_channels = 0;\n\tif (pcm_channels > 8)\n\t\tpcm_channels = 8;\n\tpcm_channels++;\n\tpcm_channels &= ~1;\n\tgus->gf1.effect = effect ? 1 : 0;\n\tgus->gf1.active_voices = voices;\n\tgus->gf1.pcm_channels = pcm_channels;\n\tgus->gf1.volume_ramp = 25;\n\tgus->gf1.smooth_pan = 1;\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, gus, &ops);\n\tif (err < 0) {\n\t\tsnd_gus_free(gus);\n\t\treturn err;\n\t}\n\t*rgus = gus;\n\treturn 0;\n}\n\n \n\nstatic int snd_gus_detect_memory(struct snd_gus_card * gus)\n{\n\tint l, idx, local;\n\tunsigned char d;\n\n\tsnd_gf1_poke(gus, 0L, 0xaa);\n\tsnd_gf1_poke(gus, 1L, 0x55);\n\tif (snd_gf1_peek(gus, 0L) != 0xaa || snd_gf1_peek(gus, 1L) != 0x55) {\n\t\tsnd_printk(KERN_ERR \"plain GF1 card at 0x%lx without onboard DRAM?\\n\", gus->gf1.port);\n\t\treturn -ENOMEM;\n\t}\n\tfor (idx = 1, d = 0xab; idx < 4; idx++, d++) {\n\t\tlocal = idx << 18;\n\t\tsnd_gf1_poke(gus, local, d);\n\t\tsnd_gf1_poke(gus, local + 1, d + 1);\n\t\tif (snd_gf1_peek(gus, local) != d ||\n\t\t    snd_gf1_peek(gus, local + 1) != d + 1 ||\n\t\t    snd_gf1_peek(gus, 0L) != 0xaa)\n\t\t\tbreak;\n\t}\n#if 1\n\tgus->gf1.memory = idx << 18;\n#else\n\tgus->gf1.memory = 256 * 1024;\n#endif\n\tfor (l = 0, local = gus->gf1.memory; l < 4; l++, local -= 256 * 1024) {\n\t\tgus->gf1.mem_alloc.banks_8[l].address =\n\t\t    gus->gf1.mem_alloc.banks_8[l].size = 0;\n\t\tgus->gf1.mem_alloc.banks_16[l].address = l << 18;\n\t\tgus->gf1.mem_alloc.banks_16[l].size = local > 0 ? 256 * 1024 : 0;\n\t}\n\tgus->gf1.mem_alloc.banks_8[0].size = gus->gf1.memory;\n\treturn 0;\t\t \n}\n\nstatic int snd_gus_init_dma_irq(struct snd_gus_card * gus, int latches)\n{\n\tstruct snd_card *card;\n\tunsigned long flags;\n\tint irq, dma1, dma2;\n\tstatic const unsigned char irqs[16] =\n\t\t{0, 0, 1, 3, 0, 2, 0, 4, 0, 1, 0, 5, 6, 0, 0, 7};\n\tstatic const unsigned char dmas[8] =\n\t\t{6, 1, 0, 2, 0, 3, 4, 5};\n\n\tif (snd_BUG_ON(!gus))\n\t\treturn -EINVAL;\n\tcard = gus->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\n\tgus->mix_cntrl_reg &= 0xf8;\n\tgus->mix_cntrl_reg |= 0x01;\t \n\tif (gus->codec_flag || gus->ess_flag) {\n\t\tgus->mix_cntrl_reg &= ~1;\t \n\t\tgus->mix_cntrl_reg |= 4;\t \n\t}\n\tdma1 = gus->gf1.dma1;\n\tdma1 = abs(dma1);\n\tdma1 = dmas[dma1 & 7];\n\tdma2 = gus->gf1.dma2;\n\tdma2 = abs(dma2);\n\tdma2 = dmas[dma2 & 7];\n\tdma1 |= gus->equal_dma ? 0x40 : (dma2 << 3);\n\n\tif ((dma1 & 7) == 0 || (dma2 & 7) == 0) {\n\t\tsnd_printk(KERN_ERR \"Error! DMA isn't defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tirq = gus->gf1.irq;\n\tirq = abs(irq);\n\tirq = irqs[irq & 0x0f];\n\tif (irq == 0) {\n\t\tsnd_printk(KERN_ERR \"Error! IRQ isn't defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tirq |= 0x40;\n#if 0\n\tcard->mixer.mix_ctrl_reg |= 0x10;\n#endif\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(5, GUSP(gus, REGCNTRLS));\n\toutb(gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\toutb(0x00, GUSP(gus, IRQDMACNTRLREG));\n\toutb(0, GUSP(gus, REGCNTRLS));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\n\tudelay(100);\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(0x00 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\toutb(dma1, GUSP(gus, IRQDMACNTRLREG));\n\tif (latches) {\n\t\toutb(0x40 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\t\toutb(irq, GUSP(gus, IRQDMACNTRLREG));\n\t}\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\n\tudelay(100);\n\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(0x00 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\toutb(dma1, GUSP(gus, IRQDMACNTRLREG));\n\tif (latches) {\n\t\toutb(0x40 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\t\toutb(irq, GUSP(gus, IRQDMACNTRLREG));\n\t}\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\n\tsnd_gf1_delay(gus);\n\n\tif (latches)\n\t\tgus->mix_cntrl_reg |= 0x08;\t \n\telse\n\t\tgus->mix_cntrl_reg &= ~0x08;\t \n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\n\toutb(0, GUSP(gus, GF1PAGE));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int snd_gus_check_version(struct snd_gus_card * gus)\n{\n\tunsigned long flags;\n\tunsigned char val, rev;\n\tstruct snd_card *card;\n\n\tcard = gus->card;\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toutb(0x20, GUSP(gus, REGCNTRLS));\n\tval = inb(GUSP(gus, REGCNTRLS));\n\trev = inb(GUSP(gus, BOARDVERSION));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\tsnd_printdd(\"GF1 [0x%lx] init - val = 0x%x, rev = 0x%x\\n\", gus->gf1.port, val, rev);\n\tstrcpy(card->driver, \"GUS\");\n\tstrcpy(card->longname, \"Gravis UltraSound Classic (2.4)\");\n\tif ((val != 255 && (val & 0x06)) || (rev >= 5 && rev != 255)) {\n\t\tif (rev >= 5 && rev <= 9) {\n\t\t\tgus->ics_flag = 1;\n\t\t\tif (rev == 5)\n\t\t\t\tgus->ics_flipped = 1;\n\t\t\tcard->longname[27] = '3';\n\t\t\tcard->longname[29] = rev == 5 ? '5' : '7';\n\t\t}\n\t\tif (rev >= 10 && rev != 255) {\n\t\t\tif (rev >= 10 && rev <= 11) {\n\t\t\t\tstrcpy(card->driver, \"GUS MAX\");\n\t\t\t\tstrcpy(card->longname, \"Gravis UltraSound MAX\");\n\t\t\t\tgus->max_flag = 1;\n\t\t\t} else if (rev == 0x30) {\n\t\t\t\tstrcpy(card->driver, \"GUS ACE\");\n\t\t\t\tstrcpy(card->longname, \"Gravis UltraSound Ace\");\n\t\t\t\tgus->ace_flag = 1;\n\t\t\t} else if (rev == 0x50) {\n\t\t\t\tstrcpy(card->driver, \"GUS Extreme\");\n\t\t\t\tstrcpy(card->longname, \"Gravis UltraSound Extreme\");\n\t\t\t\tgus->ess_flag = 1;\n\t\t\t} else {\n\t\t\t\tsnd_printk(KERN_ERR \"unknown GF1 revision number at 0x%lx - 0x%x (0x%x)\\n\", gus->gf1.port, rev, val);\n\t\t\t\tsnd_printk(KERN_ERR \"  please - report to <perex@perex.cz>\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tstrscpy(card->shortname, card->longname, sizeof(card->shortname));\n\tgus->uart_enable = 1;\t \n\tsnd_gus_init_control(gus);\n\treturn 0;\n}\n\nint snd_gus_initialize(struct snd_gus_card *gus)\n{\n\tint err;\n\n\tif (!gus->interwave) {\n\t\terr = snd_gus_check_version(gus);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"version check failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = snd_gus_detect_memory(gus);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_gus_init_dma_irq(gus, 1);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_gf1_start(gus);\n\tgus->initialized = 1;\n\treturn 0;\n}\n\n   \nEXPORT_SYMBOL(snd_gf1_delay);\nEXPORT_SYMBOL(snd_gf1_write8);\nEXPORT_SYMBOL(snd_gf1_look8);\nEXPORT_SYMBOL(snd_gf1_write16);\nEXPORT_SYMBOL(snd_gf1_look16);\nEXPORT_SYMBOL(snd_gf1_i_write8);\nEXPORT_SYMBOL(snd_gf1_i_look8);\nEXPORT_SYMBOL(snd_gf1_i_look16);\nEXPORT_SYMBOL(snd_gf1_dram_addr);\nEXPORT_SYMBOL(snd_gf1_write_addr);\nEXPORT_SYMBOL(snd_gf1_poke);\nEXPORT_SYMBOL(snd_gf1_peek);\n   \nEXPORT_SYMBOL(snd_gf1_alloc_voice);\nEXPORT_SYMBOL(snd_gf1_free_voice);\nEXPORT_SYMBOL(snd_gf1_ctrl_stop);\nEXPORT_SYMBOL(snd_gf1_stop_voice);\n   \nEXPORT_SYMBOL(snd_gf1_new_mixer);\n   \nEXPORT_SYMBOL(snd_gf1_pcm_new);\n   \nEXPORT_SYMBOL(snd_gus_use_inc);\nEXPORT_SYMBOL(snd_gus_use_dec);\nEXPORT_SYMBOL(snd_gus_create);\nEXPORT_SYMBOL(snd_gus_initialize);\n   \nEXPORT_SYMBOL(snd_gus_interrupt);\n   \nEXPORT_SYMBOL(snd_gf1_rawmidi_new);\n   \nEXPORT_SYMBOL(snd_gus_dram_write);\nEXPORT_SYMBOL(snd_gus_dram_read);\n   \nEXPORT_SYMBOL(snd_gf1_lvol_to_gvol_raw);\nEXPORT_SYMBOL(snd_gf1_translate_freq);\n   \nEXPORT_SYMBOL(snd_gf1_mem_alloc);\nEXPORT_SYMBOL(snd_gf1_mem_xfree);\nEXPORT_SYMBOL(snd_gf1_mem_free);\nEXPORT_SYMBOL(snd_gf1_mem_lock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}