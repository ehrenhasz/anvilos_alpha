{
  "module_name": "gus_volume.c",
  "hash_id": "7f5557bc8a8dc23781519f8de520702de0e143622e90df08fd5bd1edac456271",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_volume.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#define __GUS_TABLES_ALLOC__\n#include \"gus_tables.h\"\n\nEXPORT_SYMBOL(snd_gf1_atten_table);  \n\nunsigned short snd_gf1_lvol_to_gvol_raw(unsigned int vol)\n{\n\tunsigned short e, m, tmp;\n\n\tif (vol > 65535)\n\t\tvol = 65535;\n\ttmp = vol;\n\te = 7;\n\tif (tmp < 128) {\n\t\twhile (e > 0 && tmp < (1 << e))\n\t\t\te--;\n\t} else {\n\t\twhile (tmp > 255) {\n\t\t\ttmp >>= 1;\n\t\t\te++;\n\t\t}\n\t}\n\tm = vol - (1 << e);\n\tif (m > 0) {\n\t\tif (e > 8)\n\t\t\tm >>= e - 8;\n\t\telse if (e < 8)\n\t\t\tm <<= 8 - e;\n\t\tm &= 255;\n\t}\n\treturn (e << 8) | m;\n}\n\n#if 0\n\nunsigned int snd_gf1_gvol_to_lvol_raw(unsigned short gf1_vol)\n{\n\tunsigned int rvol;\n\tunsigned short e, m;\n\n\tif (!gf1_vol)\n\t\treturn 0;\n\te = gf1_vol >> 8;\n\tm = (unsigned char) gf1_vol;\n\trvol = 1 << e;\n\tif (e > 8)\n\t\treturn rvol | (m << (e - 8));\n\treturn rvol | (m >> (8 - e));\n}\n\nunsigned int snd_gf1_calc_ramp_rate(struct snd_gus_card * gus,\n\t\t\t\t    unsigned short start,\n\t\t\t\t    unsigned short end,\n\t\t\t\t    unsigned int us)\n{\n\tstatic const unsigned char vol_rates[19] =\n\t{\n\t\t23, 24, 26, 28, 29, 31, 32, 34,\n\t\t36, 37, 39, 40, 42, 44, 45, 47,\n\t\t49, 50, 52\n\t};\n\tunsigned short range, increment, value, i;\n\n\tstart >>= 4;\n\tend >>= 4;\n\tif (start < end)\n\t\tus /= end - start;\n\telse\n\t\tus /= start - end;\n\trange = 4;\n\tvalue = gus->gf1.enh_mode ?\n\t    vol_rates[0] :\n\t    vol_rates[gus->gf1.active_voices - 14];\n\tfor (i = 0; i < 3; i++) {\n\t\tif (us < value) {\n\t\t\trange = i;\n\t\t\tbreak;\n\t\t} else\n\t\t\tvalue <<= 3;\n\t}\n\tif (range == 4) {\n\t\trange = 3;\n\t\tincrement = 1;\n\t} else\n\t\tincrement = (value + (value >> 1)) / us;\n\treturn (range << 6) | (increment & 0x3f);\n}\n\n#endif   \n\nunsigned short snd_gf1_translate_freq(struct snd_gus_card * gus, unsigned int freq16)\n{\n\tfreq16 >>= 3;\n\tif (freq16 < 50)\n\t\tfreq16 = 50;\n\tif (freq16 & 0xf8000000) {\n\t\tfreq16 = ~0xf8000000;\n\t\tsnd_printk(KERN_ERR \"snd_gf1_translate_freq: overflow - freq = 0x%x\\n\", freq16);\n\t}\n\treturn ((freq16 << 9) + (gus->gf1.playback_freq >> 1)) / gus->gf1.playback_freq;\n}\n\n#if 0\n\nshort snd_gf1_compute_vibrato(short cents, unsigned short fc_register)\n{\n\tstatic const short vibrato_table[] =\n\t{\n\t\t0, 0, 32, 592, 61, 1175, 93, 1808,\n\t\t124, 2433, 152, 3007, 182, 3632, 213, 4290,\n\t\t241, 4834, 255, 5200\n\t};\n\n\tlong depth;\n\tconst short *vi1, *vi2;\n\tshort pcents, v1;\n\n\tpcents = cents < 0 ? -cents : cents;\n\tfor (vi1 = vibrato_table, vi2 = vi1 + 2; pcents > *vi2; vi1 = vi2, vi2 += 2);\n\tv1 = *(vi1 + 1);\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tdepth = (((int) (*(vi2 + 1) - *vi1) * (pcents - *vi1) / (*vi2 - *vi1)) + v1) * fc_register >> 14;\n\tif (depth)\n\t\tdepth++;\n\tif (depth > 255)\n\t\tdepth = 255;\n\treturn cents < 0 ? -(short) depth : (short) depth;\n}\n\nunsigned short snd_gf1_compute_pitchbend(unsigned short pitchbend, unsigned short sens)\n{\n\tstatic const long log_table[] = {1024, 1085, 1149, 1218, 1290, 1367, 1448, 1534, 1625, 1722, 1825, 1933};\n\tint wheel, sensitivity;\n\tunsigned int mantissa, f1, f2;\n\tunsigned short semitones, f1_index, f2_index, f1_power, f2_power;\n\tchar bend_down = 0;\n\tint bend;\n\n\tif (!sens)\n\t\treturn 1024;\n\twheel = (int) pitchbend - 8192;\n\tsensitivity = ((int) sens * wheel) / 128;\n\tif (sensitivity < 0) {\n\t\tbend_down = 1;\n\t\tsensitivity = -sensitivity;\n\t}\n\tsemitones = (unsigned int) (sensitivity >> 13);\n\tmantissa = sensitivity % 8192;\n\tf1_index = semitones % 12;\n\tf2_index = (semitones + 1) % 12;\n\tf1_power = semitones / 12;\n\tf2_power = (semitones + 1) / 12;\n\tf1 = log_table[f1_index] << f1_power;\n\tf2 = log_table[f2_index] << f2_power;\n\tbend = (int) ((((f2 - f1) * mantissa) >> 13) + f1);\n\tif (bend_down)\n\t\tbend = 1048576L / bend;\n\treturn bend;\n}\n\nunsigned short snd_gf1_compute_freq(unsigned int freq,\n\t\t\t\t    unsigned int rate,\n\t\t\t\t    unsigned short mix_rate)\n{\n\tunsigned int fc;\n\tint scale = 0;\n\n\twhile (freq >= 4194304L) {\n\t\tscale++;\n\t\tfreq >>= 1;\n\t}\n\tfc = (freq << 10) / rate;\n\tif (fc > 97391L) {\n\t\tfc = 97391;\n\t\tsnd_printk(KERN_ERR \"patch: (1) fc frequency overflow - %u\\n\", fc);\n\t}\n\tfc = (fc * 44100UL) / mix_rate;\n\twhile (scale--)\n\t\tfc <<= 1;\n\tif (fc > 65535L) {\n\t\tfc = 65535;\n\t\tsnd_printk(KERN_ERR \"patch: (2) fc frequency overflow - %u\\n\", fc);\n\t}\n\treturn (unsigned short) fc;\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}