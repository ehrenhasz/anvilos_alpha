{
  "module_name": "gusextreme.c",
  "hash_id": "a32ffcdf06393837d95a4c658d74475d3f0909e1cc60971e82dabfa4a79563da",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gusextreme.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#include <sound/es1688.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#define SNDRV_LEGACY_AUTO_PROBE\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\n#define CRD_NAME \"Gravis UltraSound Extreme\"\n#define DEV_NAME \"gusextreme\"\n\nMODULE_DESCRIPTION(CRD_NAME);\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long gf1_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1};  \nstatic long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1};  \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int gf1_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic int joystick_dac[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 29};\n\t\t\t\t \nstatic int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};\nstatic int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CRD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CRD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CRD_NAME \" soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(gf1_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(gf1_port, \"GF1 port # for \" CRD_NAME \" driver (optional).\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU-401 IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(gf1_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(gf1_irq, \"GF1 IRQ # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma8, \"8-bit DMA # for \" CRD_NAME \" driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"GF1 DMA # for \" CRD_NAME \" driver.\");\nmodule_param_array(joystick_dac, int, NULL, 0444);\nMODULE_PARM_DESC(joystick_dac, \"Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for \" CRD_NAME \" driver.\");\nmodule_param_array(channels, int, NULL, 0444);\nMODULE_PARM_DESC(channels, \"GF1 channels for \" CRD_NAME \" driver.\");\nmodule_param_array(pcm_channels, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_channels, \"Reserved PCM channels for \" CRD_NAME \" driver.\");\n\nstatic int snd_gusextreme_match(struct device *dev, unsigned int n)\n{\n\treturn enable[n];\n}\n\nstatic int snd_gusextreme_es1688_create(struct snd_card *card,\n\t\t\t\t\tstruct snd_es1688 *chip,\n\t\t\t\t\tstruct device *dev, unsigned int n)\n{\n\tstatic const long possible_ports[] = {0x220, 0x240, 0x260};\n\tstatic const int possible_irqs[] = {5, 9, 10, 7, -1};\n\tstatic const int possible_dmas[] = {1, 3, 0, -1};\n\n\tint i, error;\n\n\tif (irq[n] == SNDRV_AUTO_IRQ) {\n\t\tirq[n] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free IRQ for ES1688\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma8[n] == SNDRV_AUTO_DMA) {\n\t\tdma8[n] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma8[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free DMA for ES1688\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (port[n] != SNDRV_AUTO_PORT)\n\t\treturn snd_es1688_create(card, chip, port[n], mpu_port[n],\n\t\t\t\tirq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);\n\n\ti = 0;\n\tdo {\n\t\tport[n] = possible_ports[i];\n\t\terror = snd_es1688_create(card, chip, port[n], mpu_port[n],\n\t\t\t\tirq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);\n\t} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));\n\n\treturn error;\n}\n\nstatic int snd_gusextreme_gus_card_create(struct snd_card *card,\n\t\t\t\t\t  struct device *dev, unsigned int n,\n\t\t\t\t\t  struct snd_gus_card **rgus)\n{\n\tstatic const int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};\n\tstatic const int possible_dmas[] = {5, 6, 7, 3, 1, -1};\n\n\tif (gf1_irq[n] == SNDRV_AUTO_IRQ) {\n\t\tgf1_irq[n] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (gf1_irq[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free IRQ for GF1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1[n] == SNDRV_AUTO_DMA) {\n\t\tdma1[n] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma1[n] < 0) {\n\t\t\tdev_err(dev, \"unable to find a free DMA for GF1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn snd_gus_create(card, gf1_port[n], gf1_irq[n], dma1[n], -1,\n\t\t\t0, channels[n], pcm_channels[n], 0, rgus);\n}\n\nstatic int snd_gusextreme_detect(struct snd_gus_card *gus,\n\t\t\t\t struct snd_es1688 *es1688)\n{\n\tunsigned long flags;\n\tunsigned char d;\n\n\t \n\n\tspin_lock_irqsave(&es1688->mixer_lock, flags);\n\tsnd_es1688_mixer_write(es1688, 0x40, 0x0b);\t \n\tspin_unlock_irqrestore(&es1688->mixer_lock, flags);\n\n\tspin_lock_irqsave(&es1688->reg_lock, flags);\n\toutb(gus->gf1.port & 0x040 ? 2 : 0, ES1688P(es1688, INIT1));\n\toutb(0, 0x201);\n\toutb(gus->gf1.port & 0x020 ? 2 : 0, ES1688P(es1688, INIT1));\n\toutb(0, 0x201);\n\toutb(gus->gf1.port & 0x010 ? 3 : 1, ES1688P(es1688, INIT1));\n\tspin_unlock_irqrestore(&es1688->reg_lock, flags);\n\n\tudelay(100);\n\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\t \n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 0) {\n\t\tsnd_printdd(\"[0x%lx] check 1 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -EIO;\n\t}\n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\t \n\tudelay(160);\n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 1) {\n\t\tsnd_printdd(\"[0x%lx] check 2 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_gusextreme_mixer(struct snd_card *card)\n{\n\tstruct snd_ctl_elem_id id1, id2;\n\tint error;\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\n\t \n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"Synth Playback Volume\");\n\terror = snd_ctl_rename_id(card, &id1, &id2);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tstrcpy(id1.name, \"Master Playback Switch\");\n\tstrcpy(id2.name, \"Synth Playback Switch\");\n\terror = snd_ctl_rename_id(card, &id1, &id2);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int snd_gusextreme_probe(struct device *dev, unsigned int n)\n{\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus;\n\tstruct snd_es1688 *es1688;\n\tstruct snd_opl3 *opl3;\n\tint error;\n\n\terror = snd_devm_card_new(dev, index[n], id[n], THIS_MODULE,\n\t\t\t\t  sizeof(struct snd_es1688), &card);\n\tif (error < 0)\n\t\treturn error;\n\n\tes1688 = card->private_data;\n\n\tif (mpu_port[n] == SNDRV_AUTO_PORT)\n\t\tmpu_port[n] = 0;\n\n\tif (mpu_irq[n] > 15)\n\t\tmpu_irq[n] = -1;\n\n\terror = snd_gusextreme_es1688_create(card, es1688, dev, n);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (gf1_port[n] < 0)\n\t\tgf1_port[n] = es1688->port + 0x20;\n\n\terror = snd_gusextreme_gus_card_create(card, dev, n, &gus);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_gusextreme_detect(gus, es1688);\n\tif (error < 0)\n\t\treturn error;\n\n\tgus->joystick_dac = joystick_dac[n];\n\n\terror = snd_gus_initialize(gus);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = -ENODEV;\n\tif (!gus->ess_flag) {\n\t\tdev_err(dev, \"GUS Extreme soundcard was not \"\n\t\t\t\"detected at 0x%lx\\n\", gus->gf1.port);\n\t\treturn error;\n\t}\n\tgus->codec_flag = 1;\n\n\terror = snd_es1688_pcm(card, es1688, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_es1688_mixer(card, es1688);\n\tif (error < 0)\n\t\treturn error;\n\n\tsnd_component_add(card, \"ES1688\");\n\n\tif (pcm_channels[n] > 0) {\n\t\terror = snd_gf1_pcm_new(gus, 1, 1);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = snd_gf1_new_mixer(gus);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = snd_gusextreme_mixer(card);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (snd_opl3_create(card, es1688->port, es1688->port + 2,\n\t\t\tOPL3_HW_OPL3, 0, &opl3) < 0)\n\t\tdev_warn(dev, \"opl3 not detected at 0x%lx\\n\", es1688->port);\n\telse {\n\t\terror = snd_opl3_hwdep_new(opl3, 0, 2, NULL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (es1688->mpu_port >= 0x300) {\n\t\terror = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,\n\t\t\t\tes1688->mpu_port, 0, mpu_irq[n], NULL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tsprintf(card->longname, \"Gravis UltraSound Extreme at 0x%lx, \"\n\t\t\"irq %i&%i, dma %i&%i\", es1688->port,\n\t\tgus->gf1.irq, es1688->irq, gus->gf1.dma1, es1688->dma8);\n\n\terror = snd_card_register(card);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_set_drvdata(dev, card);\n\treturn 0;\n}\n\nstatic struct isa_driver snd_gusextreme_driver = {\n\t.match\t\t= snd_gusextreme_match,\n\t.probe\t\t= snd_gusextreme_probe,\n#if 0\t \n\t.suspend\t= snd_gusextreme_suspend,\n\t.resume\t\t= snd_gusextreme_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t}\n};\n\nmodule_isa_driver(snd_gusextreme_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}