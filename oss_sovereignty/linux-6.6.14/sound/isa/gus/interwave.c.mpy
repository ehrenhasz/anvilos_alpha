{
  "module_name": "interwave.c",
  "hash_id": "9042a01225359b383fdb50866b8ff9828f66a642debe48b373babed0078c0c17",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/interwave.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#include <sound/wss.h>\n#ifdef SNDRV_STB\n#include <sound/tea6330t.h>\n#endif\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_LICENSE(\"GPL\");\n#ifndef SNDRV_STB\nMODULE_DESCRIPTION(\"AMD InterWave\");\n#else\nMODULE_DESCRIPTION(\"AMD InterWave STB with TEA6330T\");\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;  \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \n#ifdef SNDRV_STB\nstatic long port_tc[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \n#endif\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int joystick_dac[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 29};\n\t\t\t\t \nstatic int midi[SNDRV_CARDS];\nstatic int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};\nstatic int effect[SNDRV_CARDS];\n\n#ifdef SNDRV_STB\n#define PFX \"interwave-stb: \"\n#define INTERWAVE_DRIVER\t\"snd_interwave_stb\"\n#define INTERWAVE_PNP_DRIVER\t\"interwave-stb\"\n#else\n#define PFX \"interwave: \"\n#define INTERWAVE_DRIVER\t\"snd_interwave\"\n#define INTERWAVE_PNP_DRIVER\t\"interwave\"\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for InterWave soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for InterWave soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable InterWave soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"ISA PnP detection for specified soundcard.\");\n#endif\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for InterWave driver.\");\n#ifdef SNDRV_STB\nmodule_param_hw_array(port_tc, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port_tc, \"Tone control (TEA6330T - i2c bus) port # for InterWave driver.\");\n#endif\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for InterWave driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 # for InterWave driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for InterWave driver.\");\nmodule_param_array(joystick_dac, int, NULL, 0444);\nMODULE_PARM_DESC(joystick_dac, \"Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for InterWave driver.\");\nmodule_param_array(midi, int, NULL, 0444);\nMODULE_PARM_DESC(midi, \"MIDI UART enable for InterWave driver.\");\nmodule_param_array(pcm_channels, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_channels, \"Reserved PCM channels for InterWave driver.\");\nmodule_param_array(effect, int, NULL, 0444);\nMODULE_PARM_DESC(effect, \"Effects enable for InterWave driver.\");\n\nstruct snd_interwave {\n\tint irq;\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus;\n\tstruct snd_wss *wss;\n#ifdef SNDRV_STB\n\tstruct resource *i2c_res;\n#endif\n\tunsigned short gus_status_reg;\n\tunsigned short pcm_status_reg;\n#ifdef CONFIG_PNP\n\tstruct pnp_dev *dev;\n#ifdef SNDRV_STB\n\tstruct pnp_dev *devtc;\n#endif\n#endif\n};\n\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\n\nstatic const struct pnp_card_device_id snd_interwave_pnpids[] = {\n#ifndef SNDRV_STB\n\t \n\t{ .id = \"GRV0001\", .devs = { { .id = \"GRV0000\" } } },\n\t \n\t{ .id = \"STB011a\", .devs = { { .id = \"STB0010\" } } },\n\t \n\t{ .id = \"DXP3201\", .devs = { { .id = \"DXP0010\" } } },\n\t \n\t \n\t{ .id = \"CDC1111\", .devs = { { .id = \"CDC1112\" } } },\n\t \n\t{ .id = \"ADV55ff\", .devs = { { .id = \"ADV0010\" } } },\n\t \n\t{ .id = \"ADV550a\", .devs = { { .id = \"ADV0010\" } } },\n#else\n\t \n\t{ .id = \"ADV550a\", .devs = { { .id = \"ADV0010\" }, { .id = \"ADV0015\" } } },\n#endif\n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_interwave_pnpids);\n\n#endif  \n\n\n#ifdef SNDRV_STB\nstatic void snd_interwave_i2c_setlines(struct snd_i2c_bus *bus, int ctrl, int data)\n{\n\tunsigned long port = bus->private_value;\n\n#if 0\n\tprintk(KERN_DEBUG \"i2c_setlines - 0x%lx <- %i,%i\\n\", port, ctrl, data);\n#endif\n\toutb((data << 1) | ctrl, port);\n\tudelay(10);\n}\n\nstatic int snd_interwave_i2c_getclockline(struct snd_i2c_bus *bus)\n{\n\tunsigned long port = bus->private_value;\n\tunsigned char res;\n\n\tres = inb(port) & 1;\n#if 0\n\tprintk(KERN_DEBUG \"i2c_getclockline - 0x%lx -> %i\\n\", port, res);\n#endif\n\treturn res;\n}\n\nstatic int snd_interwave_i2c_getdataline(struct snd_i2c_bus *bus, int ack)\n{\n\tunsigned long port = bus->private_value;\n\tunsigned char res;\n\n\tif (ack)\n\t\tudelay(10);\n\tres = (inb(port) & 2) >> 1;\n#if 0\n\tprintk(KERN_DEBUG \"i2c_getdataline - 0x%lx -> %i\\n\", port, res);\n#endif\n\treturn res;\n}\n\nstatic struct snd_i2c_bit_ops snd_interwave_i2c_bit_ops = {\n\t.setlines = snd_interwave_i2c_setlines,\n\t.getclock = snd_interwave_i2c_getclockline,\n\t.getdata  = snd_interwave_i2c_getdataline,\n};\n\nstatic int snd_interwave_detect_stb(struct snd_interwave *iwcard,\n\t\t\t\t    struct snd_gus_card *gus, int dev,\n\t\t\t\t    struct snd_i2c_bus **rbus)\n{\n\tunsigned long port;\n\tstruct snd_i2c_bus *bus;\n\tstruct snd_card *card = iwcard->card;\n\tchar name[32];\n\tint err;\n\n\t*rbus = NULL;\n\tport = port_tc[dev];\n\tif (port == SNDRV_AUTO_PORT) {\n\t\tport = 0x350;\n\t\tif (gus->gf1.port == 0x250) {\n\t\t\tport = 0x360;\n\t\t}\n\t\twhile (port <= 0x380) {\n\t\t\tiwcard->i2c_res = devm_request_region(card->dev, port, 1,\n\t\t\t\t\t\t\t      \"InterWave (I2C bus)\");\n\t\t\tif (iwcard->i2c_res)\n\t\t\t\tbreak;\n\t\t\tport += 0x10;\n\t\t}\n\t} else {\n\t\tiwcard->i2c_res = devm_request_region(card->dev, port, 1,\n\t\t\t\t\t\t      \"InterWave (I2C bus)\");\n\t}\n\tif (iwcard->i2c_res == NULL) {\n\t\tsnd_printk(KERN_ERR \"interwave: can't grab i2c bus port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsprintf(name, \"InterWave-%i\", card->number);\n\terr = snd_i2c_bus_create(card, name, NULL, &bus);\n\tif (err < 0)\n\t\treturn err;\n\tbus->private_value = port;\n\tbus->hw_ops.bit = &snd_interwave_i2c_bit_ops;\n\terr = snd_tea6330t_detect(bus, 0);\n\tif (err < 0)\n\t\treturn err;\n\t*rbus = bus;\n\treturn 0;\n}\n#endif\n\nstatic int snd_interwave_detect(struct snd_interwave *iwcard,\n\t\t\t\tstruct snd_gus_card *gus,\n\t\t\t\tint dev\n#ifdef SNDRV_STB\n\t\t\t\t, struct snd_i2c_bus **rbus\n#endif\n\t\t\t\t          )\n{\n\tunsigned long flags;\n\tunsigned char rev1, rev2;\n\tint d;\n\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\t \n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 0) {\n\t\tsnd_printdd(\"[0x%lx] check 1 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -ENODEV;\n\t}\n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\t \n\tudelay(160);\n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 1) {\n\t\tsnd_printdd(\"[0x%lx] check 2 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -ENODEV;\n\t}\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\trev1 = snd_gf1_look8(gus, SNDRV_GF1_GB_VERSION_NUMBER);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, ~rev1);\n\trev2 = snd_gf1_look8(gus, SNDRV_GF1_GB_VERSION_NUMBER);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, rev1);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\tsnd_printdd(\"[0x%lx] InterWave check - rev1=0x%x, rev2=0x%x\\n\", gus->gf1.port, rev1, rev2);\n\tif ((rev1 & 0xf0) == (rev2 & 0xf0) &&\n\t    (rev1 & 0x0f) != (rev2 & 0x0f)) {\n\t\tsnd_printdd(\"[0x%lx] InterWave check - passed\\n\", gus->gf1.port);\n\t\tgus->interwave = 1;\n\t\tstrcpy(gus->card->shortname, \"AMD InterWave\");\n\t\tgus->revision = rev1 >> 4;\n#ifndef SNDRV_STB\n\t\treturn 0;\t \n#else\n\t\treturn snd_interwave_detect_stb(iwcard, gus, dev, rbus);\n#endif\n\t}\n\tsnd_printdd(\"[0x%lx] InterWave check - failed\\n\", gus->gf1.port);\n\treturn -ENODEV;\n}\n\nstatic irqreturn_t snd_interwave_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_interwave *iwcard = dev_id;\n\tint loop, max = 5;\n\tint handled = 0;\n\n\tdo {\n\t\tloop = 0;\n\t\tif (inb(iwcard->gus_status_reg)) {\n\t\t\thandled = 1;\n\t\t\tsnd_gus_interrupt(irq, iwcard->gus);\n\t\t\tloop++;\n\t\t}\n\t\tif (inb(iwcard->pcm_status_reg) & 0x01) {\t \n\t\t\thandled = 1;\n\t\t\tsnd_wss_interrupt(irq, iwcard->wss);\n\t\t\tloop++;\n\t\t}\n\t} while (loop && --max > 0);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void snd_interwave_reset(struct snd_gus_card *gus)\n{\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_RESET, 0x00);\n\tudelay(160);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_RESET, 0x01);\n\tudelay(160);\n}\n\nstatic void snd_interwave_bank_sizes(struct snd_gus_card *gus, int *sizes)\n{\n\tunsigned int idx;\n\tunsigned int local;\n\tunsigned char d;\n\n\tfor (idx = 0; idx < 4; idx++) {\n\t\tsizes[idx] = 0;\n\t\td = 0x55;\n\t\tfor (local = idx << 22;\n\t\t     local < (idx << 22) + 0x400000;\n\t\t     local += 0x40000, d++) {\n\t\t\tsnd_gf1_poke(gus, local, d);\n\t\t\tsnd_gf1_poke(gus, local + 1, d + 1);\n#if 0\n\t\t\tprintk(KERN_DEBUG \"d = 0x%x, local = 0x%x, \"\n\t\t\t       \"local + 1 = 0x%x, idx << 22 = 0x%x\\n\",\n\t\t\t       d,\n\t\t\t       snd_gf1_peek(gus, local),\n\t\t\t       snd_gf1_peek(gus, local + 1),\n\t\t\t       snd_gf1_peek(gus, idx << 22));\n#endif\n\t\t\tif (snd_gf1_peek(gus, local) != d ||\n\t\t\t    snd_gf1_peek(gus, local + 1) != d + 1 ||\n\t\t\t    snd_gf1_peek(gus, idx << 22) != 0x55)\n\t\t\t\tbreak;\n\t\t\tsizes[idx]++;\n\t\t}\n\t}\n#if 0\n\tprintk(KERN_DEBUG \"sizes: %i %i %i %i\\n\",\n\t       sizes[0], sizes[1], sizes[2], sizes[3]);\n#endif\n}\n\nstruct rom_hdr {\n\t  unsigned char iwave[8];\n\t  unsigned char rom_hdr_revision;\n\t  unsigned char series_number;\n\t  unsigned char series_name[16];\n\t  unsigned char date[10];\n\t  unsigned short vendor_revision_major;\n\t  unsigned short vendor_revision_minor;\n\t  unsigned int rom_size;\n\t  unsigned char copyright[128];\n\t  unsigned char vendor_name[64];\n\t  unsigned char rom_description[128];\n\t  unsigned char pad[147];\n\t  unsigned char csum;\n};\n\nstatic void snd_interwave_detect_memory(struct snd_gus_card *gus)\n{\n\tstatic const unsigned int lmc[13] =\n\t{\n\t\t0x00000001, 0x00000101, 0x01010101, 0x00000401,\n\t\t0x04040401, 0x00040101, 0x04040101, 0x00000004,\n\t\t0x00000404, 0x04040404, 0x00000010, 0x00001010,\n\t\t0x10101010\n\t};\n\n\tint bank_pos, pages;\n\tunsigned int i, lmct;\n\tint psizes[4];\n\tunsigned char iwave[8];\n\tunsigned char csum;\n\n\tsnd_interwave_reset(gus);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_GLOBAL_MODE, snd_gf1_read8(gus, SNDRV_GF1_GB_GLOBAL_MODE) | 0x01);\t\t \n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01);\t \n\tsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xff10) | 0x004c);\n\t \n\tpages = 0;\n\tsnd_gf1_poke(gus, 0, 0x55);\n\tsnd_gf1_poke(gus, 1, 0xaa);\n#if 1\n\tif (snd_gf1_peek(gus, 0) == 0x55 && snd_gf1_peek(gus, 1) == 0xaa)\n#else\n\tif (0)\t\t\t \n#endif\n\t{\n\t\tsnd_interwave_bank_sizes(gus, psizes);\n\t\tlmct = (psizes[3] << 24) | (psizes[2] << 16) |\n\t\t    (psizes[1] << 8) | psizes[0];\n#if 0\n\t\tprintk(KERN_DEBUG \"lmct = 0x%08x\\n\", lmct);\n#endif\n\t\tfor (i = 0; i < ARRAY_SIZE(lmc); i++)\n\t\t\tif (lmct == lmc[i]) {\n#if 0\n\t\t\t\tprintk(KERN_DEBUG \"found !!! %i\\n\", i);\n#endif\n\t\t\t\tsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xfff0) | i);\n\t\t\t\tsnd_interwave_bank_sizes(gus, psizes);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i >= ARRAY_SIZE(lmc) && !gus->gf1.enh_mode)\n\t\t\t snd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xfff0) | 2);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tgus->gf1.mem_alloc.banks_8[i].address =\n\t\t\t    gus->gf1.mem_alloc.banks_16[i].address = i << 22;\n\t\t\tgus->gf1.mem_alloc.banks_8[i].size =\n\t\t\t    gus->gf1.mem_alloc.banks_16[i].size = psizes[i] << 18;\n\t\t\tpages += psizes[i];\n\t\t}\n\t}\n\tpages <<= 18;\n\tgus->gf1.memory = pages;\n\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x03);\t \n\tsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xff1f) | (4 << 5));\n\tgus->gf1.rom_banks = 0;\n\tgus->gf1.rom_memory = 0;\n\tfor (bank_pos = 0; bank_pos < 16L * 1024L * 1024L; bank_pos += 4L * 1024L * 1024L) {\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tiwave[i] = snd_gf1_peek(gus, bank_pos + i);\n\t\tif (strncmp(iwave, \"INTRWAVE\", 8))\n\t\t\tcontinue;\t \n\t\tcsum = 0;\n\t\tfor (i = 0; i < sizeof(struct rom_hdr); i++)\n\t\t\tcsum += snd_gf1_peek(gus, bank_pos + i);\n\t\tif (csum != 0)\n\t\t\tcontinue;\t \n\t\tgus->gf1.rom_banks++;\n\t\tgus->gf1.rom_present |= 1 << (bank_pos >> 22);\n\t\tgus->gf1.rom_memory = snd_gf1_peek(gus, bank_pos + 40) |\n\t\t\t\t     (snd_gf1_peek(gus, bank_pos + 41) << 8) |\n\t\t\t\t     (snd_gf1_peek(gus, bank_pos + 42) << 16) |\n\t\t\t\t     (snd_gf1_peek(gus, bank_pos + 43) << 24);\n\t}\n#if 0\n\tif (gus->gf1.rom_memory > 0) {\n\t\tif (gus->gf1.rom_banks == 1 && gus->gf1.rom_present == 8)\n\t\t\tgus->card->type = SNDRV_CARD_TYPE_IW_DYNASONIC;\n\t}\n#endif\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x00);\t \n\n\tif (!gus->gf1.enh_mode)\n\t\tsnd_interwave_reset(gus);\n}\n\nstatic void snd_interwave_init(int dev, struct snd_gus_card *gus)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, 0x00);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_COMPATIBILITY, 0x1f);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_DECODE_CONTROL, 0x49);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, 0x11);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MPU401_CONTROL_A, 0x00);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MPU401_CONTROL_B, 0x30);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_EMULATION_IRQ, 0x00);\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\tgus->equal_irq = 1;\n\tgus->codec_flag = 1;\n\tgus->interwave = 1;\n\tgus->max_flag = 1;\n\tgus->joystick_dac = joystick_dac[dev];\n\n}\n\nstatic const struct snd_kcontrol_new snd_interwave_controls[] = {\nWSS_DOUBLE(\"Master Playback Switch\", 0,\n\t\tCS4231_LINE_LEFT_OUTPUT, CS4231_LINE_RIGHT_OUTPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"Master Playback Volume\", 0,\n\t\tCS4231_LINE_LEFT_OUTPUT, CS4231_LINE_RIGHT_OUTPUT, 0, 0, 31, 1),\nWSS_DOUBLE(\"Mic Playback Switch\", 0,\n\t\tCS4231_LEFT_MIC_INPUT, CS4231_RIGHT_MIC_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"Mic Playback Volume\", 0,\n\t\tCS4231_LEFT_MIC_INPUT, CS4231_RIGHT_MIC_INPUT, 0, 0, 31, 1)\n};\n\nstatic int snd_interwave_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_ctl_elem_id id1, id2;\n\tunsigned int idx;\n\tint err;\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n#if 0\n\t \n\tstrcpy(id1.name, \"Mic Playback Switch\");\n\terr = snd_ctl_remove_id(card, &id1);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Mic Playback Volume\");\n\terr = snd_ctl_remove_id(card, &id1);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_interwave_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_interwave_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_wss_out(chip, CS4231_LINE_LEFT_OUTPUT, 0x9f);\n\tsnd_wss_out(chip, CS4231_LINE_RIGHT_OUTPUT, 0x9f);\n\tsnd_wss_out(chip, CS4231_LEFT_MIC_INPUT, 0x9f);\n\tsnd_wss_out(chip, CS4231_RIGHT_MIC_INPUT, 0x9f);\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tstrcpy(id2.name, \"Synth Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"Synth Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\"); id1.index = 1;\n\tstrcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"CD Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n#ifdef CONFIG_PNP\n\nstatic int snd_interwave_pnp(int dev, struct snd_interwave *iwcard,\n\t\t\t     struct pnp_card_link *card,\n\t\t\t     const struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\tiwcard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (iwcard->dev == NULL)\n\t\treturn -EBUSY;\n\n#ifdef SNDRV_STB\n\tiwcard->devtc = pnp_request_card_device(card, id->devs[1].id, NULL);\n\tif (iwcard->devtc == NULL)\n\t\treturn -EBUSY;\n#endif\n\t \n\tpdev = iwcard->dev;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"InterWave PnP configure failure (out of resources?)\\n\");\n\t\treturn err;\n\t}\n\tif (pnp_port_start(pdev, 0) + 0x100 != pnp_port_start(pdev, 1) ||\n\t    pnp_port_start(pdev, 0) + 0x10c != pnp_port_start(pdev, 2)) {\n\t\tsnd_printk(KERN_ERR \"PnP configure failure (wrong ports)\\n\");\n\t\treturn -ENOENT;\n\t}\n\tport[dev] = pnp_port_start(pdev, 0);\n\tdma1[dev] = pnp_dma(pdev, 0);\n\tif (dma2[dev] >= 0)\n\t\tdma2[dev] = pnp_dma(pdev, 1);\n\tirq[dev] = pnp_irq(pdev, 0);\n\tsnd_printdd(\"isapnp IW: sb port=0x%llx, gf1 port=0x%llx, codec port=0x%llx\\n\",\n\t\t\t(unsigned long long)pnp_port_start(pdev, 0),\n\t\t\t(unsigned long long)pnp_port_start(pdev, 1),\n\t\t\t(unsigned long long)pnp_port_start(pdev, 2));\n\tsnd_printdd(\"isapnp IW: dma1=%i, dma2=%i, irq=%i\\n\", dma1[dev], dma2[dev], irq[dev]);\n#ifdef SNDRV_STB\n\t \n\tpdev = iwcard->devtc;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"InterWave ToneControl PnP configure failure (out of resources?)\\n\");\n\t\treturn err;\n\t}\n\tport_tc[dev] = pnp_port_start(pdev, 0);\n\tsnd_printdd(\"isapnp IW: tone control port=0x%lx\\n\", port_tc[dev]);\n#endif\n\treturn 0;\n}\n#endif  \n\nstatic int snd_interwave_card_new(struct device *pdev, int dev,\n\t\t\t\t  struct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tstruct snd_interwave *iwcard;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_interwave), &card);\n\tif (err < 0)\n\t\treturn err;\n\tiwcard = card->private_data;\n\tiwcard->card = card;\n\tiwcard->irq = -1;\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_interwave_probe_gus(struct snd_card *card, int dev,\n\t\t\t\t   struct snd_gus_card **gusp)\n{\n\treturn snd_gus_create(card, port[dev], -irq[dev], dma1[dev], dma2[dev],\n\t\t\t      0, 32, pcm_channels[dev], effect[dev], gusp);\n}\n\nstatic int snd_interwave_probe(struct snd_card *card, int dev,\n\t\t\t       struct snd_gus_card *gus)\n{\n\tint xirq, xdma1, xdma2;\n\tstruct snd_interwave *iwcard = card->private_data;\n\tstruct snd_wss *wss;\n#ifdef SNDRV_STB\n\tstruct snd_i2c_bus *i2c_bus;\n#endif\n\tchar *str;\n\tint err;\n\n\txirq = irq[dev];\n\txdma1 = dma1[dev];\n\txdma2 = dma2[dev];\n\n\terr = snd_interwave_detect(iwcard, gus, dev\n#ifdef SNDRV_STB\n\t\t\t\t   , &i2c_bus\n#endif\n\t\t\t\t   );\n\tif (err < 0)\n\t\treturn err;\n\n\tiwcard->gus_status_reg = gus->gf1.reg_irqstat;\n\tiwcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;\n\n\tsnd_interwave_init(dev, gus);\n\tsnd_interwave_detect_memory(gus);\n\terr = snd_gus_initialize(gus);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (devm_request_irq(card->dev, xirq, snd_interwave_interrupt, 0,\n\t\t\t     \"InterWave\", iwcard)) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grab IRQ %d\\n\", xirq);\n\t\treturn -EBUSY;\n\t}\n\tiwcard->irq = xirq;\n\tcard->sync_irq = iwcard->irq;\n\n\terr = snd_wss_create(card,\n\t\t\t     gus->gf1.port + 0x10c, -1, xirq,\n\t\t\t     xdma2 < 0 ? xdma1 : xdma2, xdma1,\n\t\t\t     WSS_HW_INTERWAVE,\n\t\t\t     WSS_HWSHARE_IRQ |\n\t\t\t     WSS_HWSHARE_DMA1 |\n\t\t\t     WSS_HWSHARE_DMA2,\n\t\t\t     &wss);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_pcm(wss, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(wss->pcm->name + strlen(wss->pcm->name), \" rev %c\",\n\t\tgus->revision + 'A');\n\tstrcat(wss->pcm->name, \" (codec)\");\n\n\terr = snd_wss_timer(wss, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_mixer(wss);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (pcm_channels[dev] > 0) {\n\t\terr = snd_gf1_pcm_new(gus, 1, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_interwave_mixer(wss);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef SNDRV_STB\n\t{\n\t\tstruct snd_ctl_elem_id id1, id2;\n\t\tmemset(&id1, 0, sizeof(id1));\n\t\tmemset(&id2, 0, sizeof(id2));\n\t\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tstrcpy(id1.name, \"Master Playback Switch\");\n\t\tstrcpy(id2.name, id1.name);\n\t\tid2.index = 1;\n\t\terr = snd_ctl_rename_id(card, &id1, &id2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tstrcpy(id1.name, \"Master Playback Volume\");\n\t\tstrcpy(id2.name, id1.name);\n\t\terr = snd_ctl_rename_id(card, &id1, &id2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_tea6330t_update_mixer(card, i2c_bus, 0, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif\n\n\tgus->uart_enable = midi[dev];\n\terr = snd_gf1_rawmidi_new(gus, 0);\n\tif (err < 0)\n\t\treturn err;\n\n#ifndef SNDRV_STB\n\tstr = \"AMD InterWave\";\n\tif (gus->gf1.rom_banks == 1 && gus->gf1.rom_present == 8)\n\t\tstr = \"Dynasonic 3-D\";\n#else\n\tstr = \"InterWave STB\";\n#endif\n\tstrcpy(card->driver, str);\n\tstrcpy(card->shortname, str);\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i, dma %d\",\n\t\tstr,\n\t\tgus->gf1.port,\n\t\txirq,\n\t\txdma1);\n\tif (xdma2 >= 0)\n\t\tsprintf(card->longname + strlen(card->longname), \"&%d\", xdma2);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tiwcard->wss = wss;\n\tiwcard->gus = gus;\n\treturn 0;\n}\n\nstatic int snd_interwave_isa_match(struct device *pdev,\n\t\t\t\t   unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n#ifdef CONFIG_PNP\n\tif (isapnp[dev])\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\nstatic int snd_interwave_isa_probe(struct device *pdev,\n\t\t\t\t   unsigned int dev)\n{\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus;\n\tint err;\n\tstatic const int possible_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};\n\tstatic const int possible_dmas[] = {0, 1, 3, 5, 6, 7, -1};\n\n\tif (irq[dev] == SNDRV_AUTO_IRQ) {\n\t\tirq[dev] = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (irq[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma1[dev] == SNDRV_AUTO_DMA) {\n\t\tdma1[dev] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma1[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tif (dma2[dev] == SNDRV_AUTO_DMA) {\n\t\tdma2[dev] = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (dma2[dev] < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA2\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\terr = snd_interwave_card_new(pdev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (port[dev] != SNDRV_AUTO_PORT)\n\t\terr = snd_interwave_probe_gus(card, dev, &gus);\n\telse {\n\t\tstatic const long possible_ports[] = {0x210, 0x220, 0x230, 0x240, 0x250, 0x260};\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\n\t\t\tport[dev] = possible_ports[i];\n\t\t\terr = snd_interwave_probe_gus(card, dev, &gus);\n\t\t\tif (! err)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_interwave_probe(card, dev, gus);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\nstatic struct isa_driver snd_interwave_driver = {\n\t.match\t\t= snd_interwave_isa_match,\n\t.probe\t\t= snd_interwave_isa_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= INTERWAVE_DRIVER\n\t},\n};\n\n#ifdef CONFIG_PNP\nstatic int snd_interwave_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t\t    const struct pnp_card_device_id *pid)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\t\t\t\t\n\tres = snd_interwave_card_new(&pcard->card->dev, dev, &card);\n\tif (res < 0)\n\t\treturn res;\n\n\tres = snd_interwave_pnp(dev, card->private_data, pcard, pid);\n\tif (res < 0)\n\t\treturn res;\n\tres = snd_interwave_probe_gus(card, dev, &gus);\n\tif (res < 0)\n\t\treturn res;\n\tres = snd_interwave_probe(card, dev, gus);\n\tif (res < 0)\n\t\treturn res;\n\tpnp_set_card_drvdata(pcard, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic struct pnp_card_driver interwave_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DISABLE,\n\t.name = INTERWAVE_PNP_DRIVER,\n\t.id_table = snd_interwave_pnpids,\n\t.probe = snd_interwave_pnp_detect,\n\t \n};\n\n#endif  \n\nstatic int __init alsa_card_interwave_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_interwave_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&interwave_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_interwave_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&interwave_pnpc_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_interwave_driver);\n}\n\nmodule_init(alsa_card_interwave_init)\nmodule_exit(alsa_card_interwave_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}