{
  "module_name": "gus_mixer.c",
  "hash_id": "58ef24792543da97d12d06b0d016917db66203789dc3a9da7fd1a1c87b07e504",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/gus.h>\n\n \n\n#define GF1_SINGLE(xname, xindex, shift, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_gf1_info_single, \\\n  .get = snd_gf1_get_single, .put = snd_gf1_put_single, \\\n  .private_value = shift | (invert << 8) }\n\n#define snd_gf1_info_single\tsnd_ctl_boolean_mono_info\n\nstatic int snd_gf1_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\t\n\tucontrol->value.integer.value[0] = (gus->mix_cntrl_reg >> shift) & 1;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] ^= 1;\n\treturn 0;\n}\n\nstatic int snd_gf1_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\tint change;\n\tunsigned char oval, nval;\n\t\n\tnval = ucontrol->value.integer.value[0] & 1;\n\tif (invert)\n\t\tnval ^= 1;\n\tnval <<= shift;\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toval = gus->mix_cntrl_reg;\n\tnval = (oval & ~(1 << shift)) | nval;\n\tchange = nval != oval;\n\toutb(gus->mix_cntrl_reg = nval, GUSP(gus, MIXCNTRLREG));\n\toutb(gus->gf1.active_voice = 0, GUSP(gus, GF1PAGE));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\treturn change;\n}\n\n#define ICS_DOUBLE(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_ics_info_double, \\\n  .get = snd_ics_get_double, .put = snd_ics_put_double, \\\n  .private_value = addr }\n\nstatic int snd_ics_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int snd_ics_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint addr = kcontrol->private_value & 0xff;\n\tunsigned char left, right;\n\t\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tleft = gus->gf1.ics_regs[addr][0];\n\tright = gus->gf1.ics_regs[addr][1];\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\tucontrol->value.integer.value[0] = left & 127;\n\tucontrol->value.integer.value[1] = right & 127;\n\treturn 0;\n}\n\nstatic int snd_ics_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint addr = kcontrol->private_value & 0xff;\n\tint change;\n\tunsigned char val1, val2, oval1, oval2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & 127;\n\tval2 = ucontrol->value.integer.value[1] & 127;\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\toval1 = gus->gf1.ics_regs[addr][0];\n\toval2 = gus->gf1.ics_regs[addr][1];\n\tchange = val1 != oval1 || val2 != oval2;\n\tgus->gf1.ics_regs[addr][0] = val1;\n\tgus->gf1.ics_regs[addr][1] = val2;\n\tif (gus->ics_flag && gus->ics_flipped &&\n\t    (addr == SNDRV_ICS_GF1_DEV || addr == SNDRV_ICS_MASTER_DEV))\n\t\tswap(val1, val2);\n\taddr <<= 3;\n\toutb(addr | 0, GUSP(gus, MIXCNTRLPORT));\n\toutb(1, GUSP(gus, MIXDATAPORT));\n\toutb(addr | 2, GUSP(gus, MIXCNTRLPORT));\n\toutb((unsigned char) val1, GUSP(gus, MIXDATAPORT));\n\toutb(addr | 1, GUSP(gus, MIXCNTRLPORT));\n\toutb(2, GUSP(gus, MIXDATAPORT));\n\toutb(addr | 3, GUSP(gus, MIXCNTRLPORT));\n\toutb((unsigned char) val2, GUSP(gus, MIXDATAPORT));\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_gf1_controls[] = {\nGF1_SINGLE(\"Master Playback Switch\", 0, 1, 1),\nGF1_SINGLE(\"Line Switch\", 0, 0, 1),\nGF1_SINGLE(\"Mic Switch\", 0, 2, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_ics_controls[] = {\nGF1_SINGLE(\"Master Playback Switch\", 0, 1, 1),\nICS_DOUBLE(\"Master Playback Volume\", 0, SNDRV_ICS_MASTER_DEV),\nICS_DOUBLE(\"Synth Playback Volume\", 0, SNDRV_ICS_GF1_DEV),\nGF1_SINGLE(\"Line Switch\", 0, 0, 1),\nICS_DOUBLE(\"Line Playback Volume\", 0, SNDRV_ICS_LINE_DEV),\nGF1_SINGLE(\"Mic Switch\", 0, 2, 0),\nICS_DOUBLE(\"Mic Playback Volume\", 0, SNDRV_ICS_MIC_DEV),\nICS_DOUBLE(\"CD Playback Volume\", 0, SNDRV_ICS_CD_DEV)\n};\n\nint snd_gf1_new_mixer(struct snd_gus_card * gus)\n{\n\tstruct snd_card *card;\n\tunsigned int idx, max;\n\tint err;\n\n\tif (snd_BUG_ON(!gus))\n\t\treturn -EINVAL;\n\tcard = gus->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\n\tif (gus->ics_flag)\n\t\tsnd_component_add(card, \"ICS2101\");\n\tif (card->mixername[0] == '\\0') {\n\t\tstrcpy(card->mixername, gus->ics_flag ? \"GF1,ICS2101\" : \"GF1\");\n\t} else {\n\t\tif (gus->ics_flag)\n\t\t\tstrcat(card->mixername, \",ICS2101\");\n\t\tstrcat(card->mixername, \",GF1\");\n\t}\n\n\tif (!gus->ics_flag) {\n\t\tmax = gus->ess_flag ? 1 : ARRAY_SIZE(snd_gf1_controls);\n\t\tfor (idx = 0; idx < max; idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_gf1_controls[idx], gus));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_ics_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ics_controls[idx], gus));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}