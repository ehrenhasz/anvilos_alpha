{
  "module_name": "gus_pcm.c",
  "hash_id": "aefac5d67525c34769c72dd19a3141c75c9bc7a50727133f5442b560ede1999d",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_pcm.c",
  "human_readable_source": "\n \n\n#include <asm/dma.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/gus.h>\n#include <sound/pcm_params.h>\n#include \"gus_tables.h\"\n\n \n\n#define SNDRV_GF1_PCM_RATE\t\t48000\n\n#define SNDRV_GF1_PCM_PFLG_NONE\t\t0\n#define SNDRV_GF1_PCM_PFLG_ACTIVE\t(1<<0)\n#define SNDRV_GF1_PCM_PFLG_NEUTRAL\t(2<<0)\n\nstruct gus_pcm_private {\n\tstruct snd_gus_card * gus;\n\tstruct snd_pcm_substream *substream;\n\tspinlock_t lock;\n\tunsigned int voices;\n\tstruct snd_gus_voice *pvoices[2];\n\tunsigned int memory;\n\tunsigned short flags;\n\tunsigned char voice_ctrl, ramp_ctrl;\n\tunsigned int bpos;\n\tunsigned int blocks;\n\tunsigned int block_size;\n\tunsigned int dma_size;\n\twait_queue_head_t sleep;\n\tatomic_t dma_count;\n\tint final_volume;\n};\n\nstatic void snd_gf1_pcm_block_change_ack(struct snd_gus_card * gus, void *private_data)\n{\n\tstruct gus_pcm_private *pcmp = private_data;\n\n\tif (pcmp) {\n\t\tatomic_dec(&pcmp->dma_count);\n\t\twake_up(&pcmp->sleep);\n\t}\n}\n\nstatic int snd_gf1_pcm_block_change(struct snd_pcm_substream *substream,\n\t\t\t\t    unsigned int offset,\n\t\t\t\t    unsigned int addr,\n\t\t\t\t    unsigned int count)\n{\n\tstruct snd_gf1_dma_block block;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\n\tcount += offset & 31;\n\toffset &= ~31;\n\t \n\tmemset(&block, 0, sizeof(block));\n\tblock.cmd = SNDRV_GF1_DMA_IRQ;\n\tif (snd_pcm_format_unsigned(runtime->format))\n\t\tblock.cmd |= SNDRV_GF1_DMA_UNSIGNED;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tblock.cmd |= SNDRV_GF1_DMA_16BIT;\n\tblock.addr = addr & ~31;\n\tblock.buffer = runtime->dma_area + offset;\n\tblock.buf_addr = runtime->dma_addr + offset;\n\tblock.count = count;\n\tblock.private_data = pcmp;\n\tblock.ack = snd_gf1_pcm_block_change_ack;\n\tif (!snd_gf1_dma_transfer_block(pcmp->gus, &block, 0, 0))\n\t\tatomic_inc(&pcmp->dma_count);\n\treturn 0;\n}\n\nstatic void snd_gf1_pcm_trigger_up(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tstruct snd_gus_card * gus = pcmp->gus;\n\tunsigned long flags;\n\tunsigned char voice_ctrl, ramp_ctrl;\n\tunsigned short rate;\n\tunsigned int curr, begin, end;\n\tunsigned short vol;\n\tunsigned char pan;\n\tunsigned int voice;\n\n\tspin_lock_irqsave(&pcmp->lock, flags);\n\tif (pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE) {\n\t\tspin_unlock_irqrestore(&pcmp->lock, flags);\n\t\treturn;\n\t}\n\tpcmp->flags |= SNDRV_GF1_PCM_PFLG_ACTIVE;\n\tpcmp->final_volume = 0;\n\tspin_unlock_irqrestore(&pcmp->lock, flags);\n\trate = snd_gf1_translate_freq(gus, runtime->rate << 4);\n\t \n\tvoice_ctrl = snd_pcm_format_width(runtime->format) == 16 ? 0x24 : 0x20;\n\t \n\tramp_ctrl = 0x24;\n\tif (pcmp->blocks == 1) {\n\t\tvoice_ctrl |= 0x08;\t \n\t\tramp_ctrl &= ~0x04;\t \n\t}\n\tfor (voice = 0; voice < pcmp->voices; voice++) {\n\t\tbegin = pcmp->memory + voice * (pcmp->dma_size / runtime->channels);\n\t\tcurr = begin + (pcmp->bpos * pcmp->block_size) / runtime->channels;\n\t\tend = curr + (pcmp->block_size / runtime->channels);\n\t\tend -= snd_pcm_format_width(runtime->format) == 16 ? 2 : 1;\n\t\t \n\t\tpan = runtime->channels == 2 ? (!voice ? 1 : 14) : 8;\n\t\tvol = !voice ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\n\t\tspin_lock_irqsave(&gus->reg_lock, flags);\n\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_PAN, pan);\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_FREQUENCY, rate);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_START, begin << 4, voice_ctrl & 4);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_END, end << 4, voice_ctrl & 4);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_CURRENT, curr << 4, voice_ctrl & 4);\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, SNDRV_GF1_MIN_VOLUME << 4);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_RATE, 0x2f);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_START, SNDRV_GF1_MIN_OFFSET);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_END, vol >> 8);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\n\t\tif (!gus->gf1.enh_mode) {\n\t\t\tsnd_gf1_delay(gus);\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\n\t\t}\n\t\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\t}\n\tspin_lock_irqsave(&gus->reg_lock, flags);\n\tfor (voice = 0; voice < pcmp->voices; voice++) {\n\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\n\t\tif (gus->gf1.enh_mode)\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_MODE, 0x00);\t \n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\n\t\tvoice_ctrl &= ~0x20;\n\t}\n\tvoice_ctrl |= 0x20;\n\tif (!gus->gf1.enh_mode) {\n\t\tsnd_gf1_delay(gus);\n\t\tfor (voice = 0; voice < pcmp->voices; voice++) {\n\t\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\n\t\t\tvoice_ctrl &= ~0x20;\t \n\t\t}\n\t}\n\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n}\n\nstatic void snd_gf1_pcm_interrupt_wave(struct snd_gus_card * gus,\n\t\t\t\t       struct snd_gus_voice *pvoice)\n{\n\tstruct gus_pcm_private * pcmp;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned char voice_ctrl, ramp_ctrl;\n\tunsigned int idx;\n\tunsigned int end, step;\n\n\tif (!pvoice->private_data) {\n\t\tsnd_printd(\"snd_gf1_pcm: unknown wave irq?\\n\");\n\t\tsnd_gf1_smart_stop_voice(gus, pvoice->number);\n\t\treturn;\n\t}\n\tpcmp = pvoice->private_data;\n\tif (pcmp == NULL) {\n\t\tsnd_printd(\"snd_gf1_pcm: unknown wave irq?\\n\");\n\t\tsnd_gf1_smart_stop_voice(gus, pvoice->number);\n\t\treturn;\n\t}\t\t\n\tgus = pcmp->gus;\n\truntime = pcmp->substream->runtime;\n\n\tspin_lock(&gus->reg_lock);\n\tsnd_gf1_select_voice(gus, pvoice->number);\n\tvoice_ctrl = snd_gf1_read8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL) & ~0x8b;\n\tramp_ctrl = (snd_gf1_read8(gus, SNDRV_GF1_VB_VOLUME_CONTROL) & ~0xa4) | 0x03;\n#if 0\n\tsnd_gf1_select_voice(gus, pvoice->number);\n\tprintk(KERN_DEBUG \"position = 0x%x\\n\",\n\t       (snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4));\n\tsnd_gf1_select_voice(gus, pcmp->pvoices[1]->number);\n\tprintk(KERN_DEBUG \"position = 0x%x\\n\",\n\t       (snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4));\n\tsnd_gf1_select_voice(gus, pvoice->number);\n#endif\n\tpcmp->bpos++;\n\tpcmp->bpos %= pcmp->blocks;\n\tif (pcmp->bpos + 1 >= pcmp->blocks) {\t \n\t\tvoice_ctrl |= 0x08;\t \n\t} else {\n\t\tramp_ctrl |= 0x04;\t \n\t}\n\tend = pcmp->memory + (((pcmp->bpos + 1) * pcmp->block_size) / runtime->channels);\n\tend -= voice_ctrl & 4 ? 2 : 1;\n\tstep = pcmp->dma_size / runtime->channels;\n\tvoice_ctrl |= 0x20;\n\tif (!pcmp->final_volume) {\n\t\tramp_ctrl |= 0x20;\n\t\tramp_ctrl &= ~0x03;\n\t}\n\tfor (idx = 0; idx < pcmp->voices; idx++, end += step) {\n\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[idx]->number);\n\t\tsnd_gf1_write_addr(gus, SNDRV_GF1_VA_END, end << 4, voice_ctrl & 4);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\n\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\n\t\tvoice_ctrl &= ~0x20;\n\t}\n\tif (!gus->gf1.enh_mode) {\n\t\tsnd_gf1_delay(gus);\n\t\tvoice_ctrl |= 0x20;\n\t\tfor (idx = 0; idx < pcmp->voices; idx++) {\n\t\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[idx]->number);\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\n\t\t\tvoice_ctrl &= ~0x20;\n\t\t}\n\t}\n\tspin_unlock(&gus->reg_lock);\n\n\tsnd_pcm_period_elapsed(pcmp->substream);\n#if 0\n\tif ((runtime->flags & SNDRV_PCM_FLG_MMAP) &&\n\t    *runtime->state == SNDRV_PCM_STATE_RUNNING) {\n\t\tend = pcmp->bpos * pcmp->block_size;\n\t\tif (runtime->channels > 1) {\n\t\t\tsnd_gf1_pcm_block_change(pcmp->substream, end, pcmp->memory + (end / 2), pcmp->block_size / 2);\n\t\t\tsnd_gf1_pcm_block_change(pcmp->substream, end + (pcmp->block_size / 2), pcmp->memory + (pcmp->dma_size / 2) + (end / 2), pcmp->block_size / 2);\n\t\t} else {\n\t\t\tsnd_gf1_pcm_block_change(pcmp->substream, end, pcmp->memory + end, pcmp->block_size);\n\t\t}\n\t}\n#endif\n}\n\nstatic void snd_gf1_pcm_interrupt_volume(struct snd_gus_card * gus,\n\t\t\t\t\t struct snd_gus_voice * pvoice)\n{\n\tunsigned short vol;\n\tint cvoice;\n\tstruct gus_pcm_private *pcmp = pvoice->private_data;\n\n\t \n\tspin_lock(&gus->reg_lock);\n\tsnd_gf1_select_voice(gus, pvoice->number);\n\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\n\tspin_unlock(&gus->reg_lock);\n\tif (pcmp == NULL)\n\t\treturn;\n\t \n\tif (!(pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE))\n\t\treturn;\n\t \n\tcvoice = pcmp->pvoices[0] == pvoice ? 0 : 1;\n\tif (pcmp->substream == NULL)\n\t\treturn;\n\tvol = !cvoice ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\n\tspin_lock(&gus->reg_lock);\n\tsnd_gf1_select_voice(gus, pvoice->number);\n\tsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, vol);\n\tpcmp->final_volume = 1;\n\tspin_unlock(&gus->reg_lock);\n}\n\nstatic void snd_gf1_pcm_volume_change(struct snd_gus_card * gus)\n{\n}\n\nstatic int snd_gf1_pcm_poke_block(struct snd_gus_card *gus, unsigned char *buf,\n\t\t\t\t  unsigned int pos, unsigned int count,\n\t\t\t\t  int w16, int invert)\n{\n\tunsigned int len;\n\tunsigned long flags;\n\n\t \n\twhile (count > 0) {\n\t\tlen = count;\n\t\tif (len > 512)\t\t \n\t\t\tlen = 512;\n\t\tcount -= len;\n\t\tif (gus->interwave) {\n\t\t\tspin_lock_irqsave(&gus->reg_lock, flags);\n\t\t\tsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01 | (invert ? 0x08 : 0x00));\n\t\t\tsnd_gf1_dram_addr(gus, pos);\n\t\t\tif (w16) {\n\t\t\t\toutb(SNDRV_GF1_GW_DRAM_IO16, GUSP(gus, GF1REGSEL));\n\t\t\t\toutsw(GUSP(gus, GF1DATALOW), buf, len >> 1);\n\t\t\t} else {\n\t\t\t\toutsb(GUSP(gus, DRAM), buf, len);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&gus->reg_lock, flags);\n\t\t\tbuf += 512;\n\t\t\tpos += 512;\n\t\t} else {\n\t\t\tinvert = invert ? 0x80 : 0x00;\n\t\t\tif (w16) {\n\t\t\t\tlen >>= 1;\n\t\t\t\twhile (len--) {\n\t\t\t\t\tsnd_gf1_poke(gus, pos++, *buf++);\n\t\t\t\t\tsnd_gf1_poke(gus, pos++, *buf++ ^ invert);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (len--)\n\t\t\t\t\tsnd_gf1_poke(gus, pos++, *buf++ ^ invert);\n\t\t\t}\n\t\t}\n\t\tif (count > 0 && !in_interrupt()) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int get_bpos(struct gus_pcm_private *pcmp, int voice, unsigned int pos,\n\t\t    unsigned int len)\n{\n\tunsigned int bpos = pos + (voice * (pcmp->dma_size / 2));\n\tif (snd_BUG_ON(bpos > pcmp->dma_size))\n\t\treturn -EIO;\n\tif (snd_BUG_ON(bpos + len > pcmp->dma_size))\n\t\treturn -EIO;\n\treturn bpos;\n}\n\nstatic int playback_copy_ack(struct snd_pcm_substream *substream,\n\t\t\t     unsigned int bpos, unsigned int len)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tstruct snd_gus_card *gus = pcmp->gus;\n\tint w16, invert;\n\n\tif (len > 32)\n\t\treturn snd_gf1_pcm_block_change(substream, bpos,\n\t\t\t\t\t\tpcmp->memory + bpos, len);\n\n\tw16 = (snd_pcm_format_width(runtime->format) == 16);\n\tinvert = snd_pcm_format_unsigned(runtime->format);\n\treturn snd_gf1_pcm_poke_block(gus, runtime->dma_area + bpos,\n\t\t\t\t      pcmp->memory + bpos, len, w16, invert);\n}\n\nstatic int snd_gf1_pcm_playback_copy(struct snd_pcm_substream *substream,\n\t\t\t\t     int voice, unsigned long pos,\n\t\t\t\t     struct iov_iter *src, unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tunsigned int len = count;\n\tint bpos;\n\n\tbpos = get_bpos(pcmp, voice, pos, len);\n\tif (bpos < 0)\n\t\treturn pos;\n\tif (copy_from_iter(runtime->dma_area + bpos, len, src) != len)\n\t\treturn -EFAULT;\n\treturn playback_copy_ack(substream, bpos, len);\n}\n\nstatic int snd_gf1_pcm_playback_silence(struct snd_pcm_substream *substream,\n\t\t\t\t\tint voice, unsigned long pos,\n\t\t\t\t\tunsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tunsigned int len = count;\n\tint bpos;\n\t\n\tbpos = get_bpos(pcmp, voice, pos, len);\n\tif (bpos < 0)\n\t\treturn pos;\n\tsnd_pcm_format_set_silence(runtime->format, runtime->dma_area + bpos,\n\t\t\t\t   bytes_to_samples(runtime, count));\n\treturn playback_copy_ack(substream, bpos, len);\n}\n\nstatic int snd_gf1_pcm_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\n\tif (runtime->buffer_changed) {\n\t\tstruct snd_gf1_mem_block *block;\n\t\tif (pcmp->memory > 0) {\n\t\t\tsnd_gf1_mem_free(&gus->gf1.mem_alloc, pcmp->memory);\n\t\t\tpcmp->memory = 0;\n\t\t}\n\t\tblock = snd_gf1_mem_alloc(&gus->gf1.mem_alloc,\n\t\t\t\t\t  SNDRV_GF1_MEM_OWNER_DRIVER,\n\t\t\t\t\t  \"GF1 PCM\",\n\t\t\t\t\t  runtime->dma_bytes, 1, 32,\n\t\t\t\t\t  NULL);\n\t\tif (!block)\n\t\t\treturn -ENOMEM;\n\t\tpcmp->memory = block->ptr;\n\t}\n\tpcmp->voices = params_channels(hw_params);\n\tif (pcmp->pvoices[0] == NULL) {\n\t\tpcmp->pvoices[0] = snd_gf1_alloc_voice(pcmp->gus, SNDRV_GF1_VOICE_TYPE_PCM, 0, 0);\n\t\tif (!pcmp->pvoices[0])\n\t\t\treturn -ENOMEM;\n\t\tpcmp->pvoices[0]->handler_wave = snd_gf1_pcm_interrupt_wave;\n\t\tpcmp->pvoices[0]->handler_volume = snd_gf1_pcm_interrupt_volume;\n\t\tpcmp->pvoices[0]->volume_change = snd_gf1_pcm_volume_change;\n\t\tpcmp->pvoices[0]->private_data = pcmp;\n\t}\n\tif (pcmp->voices > 1 && pcmp->pvoices[1] == NULL) {\n\t\tpcmp->pvoices[1] = snd_gf1_alloc_voice(pcmp->gus, SNDRV_GF1_VOICE_TYPE_PCM, 0, 0);\n\t\tif (!pcmp->pvoices[1])\n\t\t\treturn -ENOMEM;\n\t\tpcmp->pvoices[1]->handler_wave = snd_gf1_pcm_interrupt_wave;\n\t\tpcmp->pvoices[1]->handler_volume = snd_gf1_pcm_interrupt_volume;\n\t\tpcmp->pvoices[1]->volume_change = snd_gf1_pcm_volume_change;\n\t\tpcmp->pvoices[1]->private_data = pcmp;\n\t} else if (pcmp->voices == 1) {\n\t\tif (pcmp->pvoices[1]) {\n\t\t\tsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[1]);\n\t\t\tpcmp->pvoices[1] = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\n\tif (pcmp->pvoices[0]) {\n\t\tsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[0]);\n\t\tpcmp->pvoices[0] = NULL;\n\t}\n\tif (pcmp->pvoices[1]) {\n\t\tsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[1]);\n\t\tpcmp->pvoices[1] = NULL;\n\t}\n\tif (pcmp->memory > 0) {\n\t\tsnd_gf1_mem_free(&pcmp->gus->gf1.mem_alloc, pcmp->memory);\n\t\tpcmp->memory = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\n\tpcmp->bpos = 0;\n\tpcmp->dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tpcmp->block_size = snd_pcm_lib_period_bytes(substream);\n\tpcmp->blocks = pcmp->dma_size / pcmp->block_size;\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tint voice;\n\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tsnd_gf1_pcm_trigger_up(substream);\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tspin_lock(&pcmp->lock);\n\t\tpcmp->flags &= ~SNDRV_GF1_PCM_PFLG_ACTIVE;\n\t\tspin_unlock(&pcmp->lock);\n\t\tvoice = pcmp->pvoices[0]->number;\n\t\tsnd_gf1_stop_voices(gus, voice, voice);\n\t\tif (pcmp->pvoices[1]) {\n\t\t\tvoice = pcmp->pvoices[1]->number;\n\t\t\tsnd_gf1_stop_voices(gus, voice, voice);\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_gf1_pcm_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\tunsigned int pos;\n\tunsigned char voice_ctrl;\n\n\tpos = 0;\n\tspin_lock(&gus->reg_lock);\n\tif (pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE) {\n\t\tsnd_gf1_select_voice(gus, pcmp->pvoices[0]->number);\n\t\tvoice_ctrl = snd_gf1_read8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\n\t\tpos = (snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4) - pcmp->memory;\n\t\tif (substream->runtime->channels > 1)\n\t\t\tpos <<= 1;\n\t\tpos = bytes_to_frames(runtime, pos);\n\t}\n\tspin_unlock(&gus->reg_lock);\n\treturn pos;\n}\n\nstatic const struct snd_ratnum clock = {\n\t.num = 9878400/16,\n\t.den_min = 2,\n\t.den_max = 257,\n\t.den_step = 1,\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums hw_constraints_clocks  = {\n\t.nrats = 1,\n\t.rats = &clock,\n};\n\nstatic int snd_gf1_pcm_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\n\tgus->c_dma_size = params_buffer_bytes(hw_params);\n\tgus->c_period_size = params_period_bytes(hw_params);\n\tgus->c_pos = 0;\n\tgus->gf1.pcm_rcntrl_reg = 0x21;\t\t \n\tif (params_channels(hw_params) > 1)\n\t\tgus->gf1.pcm_rcntrl_reg |= 2;\n\tif (gus->gf1.dma2 > 3)\n\t\tgus->gf1.pcm_rcntrl_reg |= 4;\n\tif (snd_pcm_format_unsigned(params_format(hw_params)))\n\t\tgus->gf1.pcm_rcntrl_reg |= 0x80;\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RECORD_RATE, runtime->rate_den - 2);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, 0);\t \n\tsnd_gf1_i_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\t \n\tsnd_dma_program(gus->gf1.dma2, runtime->dma_addr, gus->c_period_size, DMA_MODE_READ);\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tint val;\n\t\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tval = gus->gf1.pcm_rcntrl_reg;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tval = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&gus->reg_lock);\n\tsnd_gf1_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, val);\n\tsnd_gf1_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\n\tspin_unlock(&gus->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_gf1_pcm_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tint pos = snd_dma_pointer(gus->gf1.dma2, gus->c_period_size);\n\tpos = bytes_to_frames(substream->runtime, (gus->c_pos + pos) % gus->c_dma_size);\n\treturn pos;\n}\n\nstatic void snd_gf1_pcm_interrupt_dma_read(struct snd_gus_card * gus)\n{\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, 0);\t \n\tsnd_gf1_i_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\t \n\tif (gus->pcm_cap_substream != NULL) {\n\t\tsnd_gf1_pcm_capture_prepare(gus->pcm_cap_substream); \n\t\tsnd_gf1_pcm_capture_trigger(gus->pcm_cap_substream, SNDRV_PCM_TRIGGER_START);\n\t\tgus->c_pos += gus->c_period_size;\n\t\tsnd_pcm_period_elapsed(gus->pcm_cap_substream);\n\t}\n}\n\nstatic const struct snd_pcm_hardware snd_gf1_pcm_playback =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_NONINTERLEAVED,\n\t.formats\t\t= (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5510,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_gf1_pcm_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_44100,\n\t.rate_min =\t\t5510,\n\t.rate_max =\t\t44100,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic void snd_gf1_pcm_playback_free(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic int snd_gf1_pcm_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct gus_pcm_private *pcmp;\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tpcmp = kzalloc(sizeof(*pcmp), GFP_KERNEL);\n\tif (pcmp == NULL)\n\t\treturn -ENOMEM;\n\tpcmp->gus = gus;\n\tspin_lock_init(&pcmp->lock);\n\tinit_waitqueue_head(&pcmp->sleep);\n\tatomic_set(&pcmp->dma_count, 0);\n\n\truntime->private_data = pcmp;\n\truntime->private_free = snd_gf1_pcm_playback_free;\n\n#if 0\n\tprintk(KERN_DEBUG \"playback.buffer = 0x%lx, gf1.pcm_buffer = 0x%lx\\n\",\n\t       (long) pcm->playback.buffer, (long) gus->gf1.pcm_buffer);\n#endif\n\terr = snd_gf1_dma_init(gus);\n\tif (err < 0)\n\t\treturn err;\n\tpcmp->flags = SNDRV_GF1_PCM_PFLG_NONE;\n\tpcmp->substream = substream;\n\truntime->hw = snd_gf1_pcm_playback;\n\tsnd_pcm_limit_isa_dma_size(gus->gf1.dma1, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(gus->gf1.dma1, &runtime->hw.period_bytes_max);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct gus_pcm_private *pcmp = runtime->private_data;\n\t\n\tif (!wait_event_timeout(pcmp->sleep, (atomic_read(&pcmp->dma_count) <= 0), 2*HZ))\n\t\tsnd_printk(KERN_ERR \"gf1 pcm - serious DMA problem\\n\");\n\n\tsnd_gf1_dma_done(gus);\t\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\n\tgus->gf1.interrupt_handler_dma_read = snd_gf1_pcm_interrupt_dma_read;\n\tgus->pcm_cap_substream = substream;\n\tsubstream->runtime->hw = snd_gf1_pcm_capture;\n\tsnd_pcm_limit_isa_dma_size(gus->gf1.dma2, &runtime->hw.buffer_bytes_max);\n\tsnd_pcm_limit_isa_dma_size(gus->gf1.dma2, &runtime->hw.period_bytes_max);\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clocks);\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\n\n\tgus->pcm_cap_substream = NULL;\n\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_DMA_READ);\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&gus->pcm_volume_level_lock, flags);\n\tucontrol->value.integer.value[0] = gus->gf1.pcm_volume_level_left1;\n\tucontrol->value.integer.value[1] = gus->gf1.pcm_volume_level_right1;\n\tspin_unlock_irqrestore(&gus->pcm_volume_level_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_gf1_pcm_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint change;\n\tunsigned int idx;\n\tunsigned short val1, val2, vol;\n\tstruct gus_pcm_private *pcmp;\n\tstruct snd_gus_voice *pvoice;\n\t\n\tval1 = ucontrol->value.integer.value[0] & 127;\n\tval2 = ucontrol->value.integer.value[1] & 127;\n\tspin_lock_irqsave(&gus->pcm_volume_level_lock, flags);\n\tchange = val1 != gus->gf1.pcm_volume_level_left1 ||\n\t         val2 != gus->gf1.pcm_volume_level_right1;\n\tgus->gf1.pcm_volume_level_left1 = val1;\n\tgus->gf1.pcm_volume_level_right1 = val2;\n\tgus->gf1.pcm_volume_level_left = snd_gf1_lvol_to_gvol_raw(val1 << 9) << 4;\n\tgus->gf1.pcm_volume_level_right = snd_gf1_lvol_to_gvol_raw(val2 << 9) << 4;\n\tspin_unlock_irqrestore(&gus->pcm_volume_level_lock, flags);\n\t \n\tspin_lock_irqsave(&gus->voice_alloc, flags);\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tpvoice = &gus->gf1.voices[idx];\n\t\tif (!pvoice->pcm)\n\t\t\tcontinue;\n\t\tpcmp = pvoice->private_data;\n\t\tif (!(pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE))\n\t\t\tcontinue;\n\t\t \n\t\tspin_lock(&gus->reg_lock);\n\t\tsnd_gf1_select_voice(gus, pvoice->number);\n\t\tsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\n\t\tvol = pvoice == pcmp->pvoices[0] ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\n\t\tsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, vol);\n\t\tpcmp->final_volume = 1;\n\t\tspin_unlock(&gus->reg_lock);\n\t}\n\tspin_unlock_irqrestore(&gus->voice_alloc, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_gf1_pcm_volume_control =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Playback Volume\",\n\t.info = snd_gf1_pcm_volume_info,\n\t.get = snd_gf1_pcm_volume_get,\n\t.put = snd_gf1_pcm_volume_put\n};\n\nstatic const struct snd_kcontrol_new snd_gf1_pcm_volume_control1 =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"GPCM Playback Volume\",\n\t.info = snd_gf1_pcm_volume_info,\n\t.get = snd_gf1_pcm_volume_get,\n\t.put = snd_gf1_pcm_volume_put\n};\n\nstatic const struct snd_pcm_ops snd_gf1_pcm_playback_ops = {\n\t.open =\t\tsnd_gf1_pcm_playback_open,\n\t.close =\tsnd_gf1_pcm_playback_close,\n\t.hw_params =\tsnd_gf1_pcm_playback_hw_params,\n\t.hw_free =\tsnd_gf1_pcm_playback_hw_free,\n\t.prepare =\tsnd_gf1_pcm_playback_prepare,\n\t.trigger =\tsnd_gf1_pcm_playback_trigger,\n\t.pointer =\tsnd_gf1_pcm_playback_pointer,\n\t.copy =\t\tsnd_gf1_pcm_playback_copy,\n\t.fill_silence =\tsnd_gf1_pcm_playback_silence,\n};\n\nstatic const struct snd_pcm_ops snd_gf1_pcm_capture_ops = {\n\t.open =\t\tsnd_gf1_pcm_capture_open,\n\t.close =\tsnd_gf1_pcm_capture_close,\n\t.hw_params =\tsnd_gf1_pcm_capture_hw_params,\n\t.prepare =\tsnd_gf1_pcm_capture_prepare,\n\t.trigger =\tsnd_gf1_pcm_capture_trigger,\n\t.pointer =\tsnd_gf1_pcm_capture_pointer,\n};\n\nint snd_gf1_pcm_new(struct snd_gus_card *gus, int pcm_dev, int control_index)\n{\n\tstruct snd_card *card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tint capture, err;\n\n\tcard = gus->card;\n\tcapture = !gus->interwave && !gus->ess_flag && !gus->ace_flag ? 1 : 0;\n\terr = snd_pcm_new(card,\n\t\t\t  gus->interwave ? \"AMD InterWave\" : \"GF1\",\n\t\t\t  pcm_dev,\n\t\t\t  gus->gf1.pcm_channels / 2,\n\t\t\t  capture,\n\t\t\t  &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = gus;\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_gf1_pcm_playback_ops);\n\n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   card->dev,\n\t\t\t\t\t   64*1024, gus->gf1.dma1 > 3 ? 128*1024 : 64*1024);\n\t\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tif (capture) {\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_gf1_pcm_capture_ops);\n\t\tif (gus->gf1.dma2 == gus->gf1.dma1)\n\t\t\tpcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\n\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t\t   64*1024, gus->gf1.dma2 > 3 ? 128*1024 : 64*1024);\n\t}\n\tstrcpy(pcm->name, pcm->id);\n\tif (gus->interwave) {\n\t\tsprintf(pcm->name + strlen(pcm->name), \" rev %c\", gus->revision + 'A');\n\t}\n\tstrcat(pcm->name, \" (synth)\");\n\tgus->pcm = pcm;\n\n\tif (gus->codec_flag)\n\t\tkctl = snd_ctl_new1(&snd_gf1_pcm_volume_control1, gus);\n\telse\n\t\tkctl = snd_ctl_new1(&snd_gf1_pcm_volume_control, gus);\n\tkctl->id.index = control_index;\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}