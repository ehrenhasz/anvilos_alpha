{
  "module_name": "gus_mem.c",
  "hash_id": "f6150c23212fc655412c72f2fcc8c414bd9555865ddab084c046d366a84c4062",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_mem.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#include <sound/info.h>\n\n#ifdef CONFIG_SND_DEBUG\nstatic void snd_gf1_mem_info_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer);\n#endif\n\nvoid snd_gf1_mem_lock(struct snd_gf1_mem * alloc, int xup)\n{\n\tif (!xup) {\n\t\tmutex_lock(&alloc->memory_mutex);\n\t} else {\n\t\tmutex_unlock(&alloc->memory_mutex);\n\t}\n}\n\nstatic struct snd_gf1_mem_block *\nsnd_gf1_mem_xalloc(struct snd_gf1_mem *alloc, struct snd_gf1_mem_block *block,\n\t\t   const char *name)\n{\n\tstruct snd_gf1_mem_block *pblock, *nblock;\n\n\tnblock = kmalloc(sizeof(struct snd_gf1_mem_block), GFP_KERNEL);\n\tif (nblock == NULL)\n\t\treturn NULL;\n\t*nblock = *block;\n\tnblock->name = kstrdup(name, GFP_KERNEL);\n\tif (!nblock->name) {\n\t\tkfree(nblock);\n\t\treturn NULL;\n\t}\n\n\tpblock = alloc->first;\n\twhile (pblock) {\n\t\tif (pblock->ptr > nblock->ptr) {\n\t\t\tnblock->prev = pblock->prev;\n\t\t\tnblock->next = pblock;\n\t\t\tpblock->prev = nblock;\n\t\t\tif (pblock == alloc->first)\n\t\t\t\talloc->first = nblock;\n\t\t\telse\n\t\t\t\tnblock->prev->next = nblock;\n\t\t\tmutex_unlock(&alloc->memory_mutex);\n\t\t\treturn nblock;\n\t\t}\n\t\tpblock = pblock->next;\n\t}\n\tnblock->next = NULL;\n\tif (alloc->last == NULL) {\n\t\tnblock->prev = NULL;\n\t\talloc->first = alloc->last = nblock;\n\t} else {\n\t\tnblock->prev = alloc->last;\n\t\talloc->last->next = nblock;\n\t\talloc->last = nblock;\n\t}\n\treturn nblock;\n}\n\nint snd_gf1_mem_xfree(struct snd_gf1_mem * alloc, struct snd_gf1_mem_block * block)\n{\n\tif (block->share) {\t \n\t\tblock->share--;\n\t\tmutex_unlock(&alloc->memory_mutex);\n\t\treturn 0;\n\t}\n\tif (alloc->first == block) {\n\t\talloc->first = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = NULL;\n\t} else {\n\t\tblock->prev->next = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block->prev;\n\t}\n\tif (alloc->last == block) {\n\t\talloc->last = block->prev;\n\t\tif (block->prev)\n\t\t\tblock->prev->next = NULL;\n\t} else {\n\t\tblock->next->prev = block->prev;\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block->next;\n\t}\n\tkfree(block->name);\n\tkfree(block);\n\treturn 0;\n}\n\nstatic struct snd_gf1_mem_block *snd_gf1_mem_look(struct snd_gf1_mem * alloc,\n\t\t\t\t\t     unsigned int address)\n{\n\tstruct snd_gf1_mem_block *block;\n\n\tfor (block = alloc->first; block; block = block->next) {\n\t\tif (block->ptr == address) {\n\t\t\treturn block;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct snd_gf1_mem_block *snd_gf1_mem_share(struct snd_gf1_mem * alloc,\n\t\t\t\t\t      unsigned int *share_id)\n{\n\tstruct snd_gf1_mem_block *block;\n\n\tif (!share_id[0] && !share_id[1] &&\n\t    !share_id[2] && !share_id[3])\n\t\treturn NULL;\n\tfor (block = alloc->first; block; block = block->next)\n\t\tif (!memcmp(share_id, block->share_id,\n\t\t\t\tsizeof(block->share_id)))\n\t\t\treturn block;\n\treturn NULL;\n}\n\nstatic int snd_gf1_mem_find(struct snd_gf1_mem * alloc,\n\t\t\t    struct snd_gf1_mem_block * block,\n\t\t\t    unsigned int size, int w_16, int align)\n{\n\tstruct snd_gf1_bank_info *info = w_16 ? alloc->banks_16 : alloc->banks_8;\n\tunsigned int idx, boundary;\n\tint size1;\n\tstruct snd_gf1_mem_block *pblock;\n\tunsigned int ptr1, ptr2;\n\n\tif (w_16 && align < 2)\n\t\talign = 2;\n\tblock->flags = w_16 ? SNDRV_GF1_MEM_BLOCK_16BIT : 0;\n\tblock->owner = SNDRV_GF1_MEM_OWNER_DRIVER;\n\tblock->share = 0;\n\tblock->share_id[0] = block->share_id[1] =\n\tblock->share_id[2] = block->share_id[3] = 0;\n\tblock->name = NULL;\n\tblock->prev = block->next = NULL;\n\tfor (pblock = alloc->first, idx = 0; pblock; pblock = pblock->next) {\n\t\twhile (pblock->ptr >= (boundary = info[idx].address + info[idx].size))\n\t\t\tidx++;\n\t\twhile (pblock->ptr + pblock->size >= (boundary = info[idx].address + info[idx].size))\n\t\t\tidx++;\n\t\tptr2 = boundary;\n\t\tif (pblock->next) {\n\t\t\tif (pblock->ptr + pblock->size == pblock->next->ptr)\n\t\t\t\tcontinue;\n\t\t\tif (pblock->next->ptr < boundary)\n\t\t\t\tptr2 = pblock->next->ptr;\n\t\t}\n\t\tptr1 = ALIGN(pblock->ptr + pblock->size, align);\n\t\tif (ptr1 >= ptr2)\n\t\t\tcontinue;\n\t\tsize1 = ptr2 - ptr1;\n\t\tif ((int)size <= size1) {\n\t\t\tblock->ptr = ptr1;\n\t\t\tblock->size = size;\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (++idx < 4) {\n\t\tif (size <= info[idx].size) {\n\t\t\t \n\t\t\tblock->ptr = info[idx].address;\n\t\t\tblock->size = size;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}\n\nstruct snd_gf1_mem_block *snd_gf1_mem_alloc(struct snd_gf1_mem * alloc, int owner,\n\t\t\t\t       char *name, int size, int w_16, int align,\n\t\t\t\t       unsigned int *share_id)\n{\n\tstruct snd_gf1_mem_block block, *nblock;\n\n\tsnd_gf1_mem_lock(alloc, 0);\n\tif (share_id != NULL) {\n\t\tnblock = snd_gf1_mem_share(alloc, share_id);\n\t\tif (nblock != NULL) {\n\t\t\tif (size != (int)nblock->size) {\n\t\t\t\t \n\t\t\t\tsnd_printk(KERN_ERR \"snd_gf1_mem_alloc - share: sizes differ\\n\");\n\t\t\t\tgoto __std;\n\t\t\t}\n\t\t\tnblock->share++;\n\t\t\tsnd_gf1_mem_lock(alloc, 1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n      __std:\n\tif (snd_gf1_mem_find(alloc, &block, size, w_16, align) < 0) {\n\t\tsnd_gf1_mem_lock(alloc, 1);\n\t\treturn NULL;\n\t}\n\tif (share_id != NULL)\n\t\tmemcpy(&block.share_id, share_id, sizeof(block.share_id));\n\tblock.owner = owner;\n\tnblock = snd_gf1_mem_xalloc(alloc, &block, name);\n\tsnd_gf1_mem_lock(alloc, 1);\n\treturn nblock;\n}\n\nint snd_gf1_mem_free(struct snd_gf1_mem * alloc, unsigned int address)\n{\n\tint result;\n\tstruct snd_gf1_mem_block *block;\n\n\tsnd_gf1_mem_lock(alloc, 0);\n\tblock = snd_gf1_mem_look(alloc, address);\n\tif (block) {\n\t\tresult = snd_gf1_mem_xfree(alloc, block);\n\t\tsnd_gf1_mem_lock(alloc, 1);\n\t\treturn result;\n\t}\n\tsnd_gf1_mem_lock(alloc, 1);\n\treturn -EINVAL;\n}\n\nint snd_gf1_mem_init(struct snd_gus_card * gus)\n{\n\tstruct snd_gf1_mem *alloc;\n\tstruct snd_gf1_mem_block block;\n\n\talloc = &gus->gf1.mem_alloc;\n\tmutex_init(&alloc->memory_mutex);\n\talloc->first = alloc->last = NULL;\n\tif (!gus->gf1.memory)\n\t\treturn 0;\n\n\tmemset(&block, 0, sizeof(block));\n\tblock.owner = SNDRV_GF1_MEM_OWNER_DRIVER;\n\tif (gus->gf1.enh_mode) {\n\t\tblock.ptr = 0;\n\t\tblock.size = 1024;\n\t\tif (!snd_gf1_mem_xalloc(alloc, &block, \"InterWave LFOs\"))\n\t\t\treturn -ENOMEM;\n\t}\n\tblock.ptr = gus->gf1.default_voice_address;\n\tblock.size = 4;\n\tif (!snd_gf1_mem_xalloc(alloc, &block, \"Voice default (NULL's)\"))\n\t\treturn -ENOMEM;\n#ifdef CONFIG_SND_DEBUG\n\tsnd_card_ro_proc_new(gus->card, \"gusmem\", gus, snd_gf1_mem_info_read);\n#endif\n\treturn 0;\n}\n\nint snd_gf1_mem_done(struct snd_gus_card * gus)\n{\n\tstruct snd_gf1_mem *alloc;\n\tstruct snd_gf1_mem_block *block, *nblock;\n\n\talloc = &gus->gf1.mem_alloc;\n\tblock = alloc->first;\n\twhile (block) {\n\t\tnblock = block->next;\n\t\tsnd_gf1_mem_xfree(alloc, block);\n\t\tblock = nblock;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_DEBUG\nstatic void snd_gf1_mem_info_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_gus_card *gus;\n\tstruct snd_gf1_mem *alloc;\n\tstruct snd_gf1_mem_block *block;\n\tunsigned int total, used;\n\tint i;\n\n\tgus = entry->private_data;\n\talloc = &gus->gf1.mem_alloc;\n\tmutex_lock(&alloc->memory_mutex);\n\tsnd_iprintf(buffer, \"8-bit banks       : \\n    \");\n\tfor (i = 0; i < 4; i++)\n\t\tsnd_iprintf(buffer, \"0x%06x (%04ik)%s\", alloc->banks_8[i].address, alloc->banks_8[i].size >> 10, i + 1 < 4 ? \",\" : \"\");\n\tsnd_iprintf(buffer, \"\\n\"\n\t\t    \"16-bit banks      : \\n    \");\n\tfor (i = total = 0; i < 4; i++) {\n\t\tsnd_iprintf(buffer, \"0x%06x (%04ik)%s\", alloc->banks_16[i].address, alloc->banks_16[i].size >> 10, i + 1 < 4 ? \",\" : \"\");\n\t\ttotal += alloc->banks_16[i].size;\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n\tused = 0;\n\tfor (block = alloc->first, i = 0; block; block = block->next, i++) {\n\t\tused += block->size;\n\t\tsnd_iprintf(buffer, \"Block %i onboard 0x%x size %i (0x%x):\\n\", i, block->ptr, block->size, block->size);\n\t\tif (block->share ||\n\t\t    block->share_id[0] || block->share_id[1] ||\n\t\t    block->share_id[2] || block->share_id[3])\n\t\t\tsnd_iprintf(buffer, \"  Share           : %i [id0 0x%x] [id1 0x%x] [id2 0x%x] [id3 0x%x]\\n\",\n\t\t\t\tblock->share,\n\t\t\t\tblock->share_id[0], block->share_id[1],\n\t\t\t\tblock->share_id[2], block->share_id[3]);\n\t\tsnd_iprintf(buffer, \"  Flags           :%s\\n\",\n\t\tblock->flags & SNDRV_GF1_MEM_BLOCK_16BIT ? \" 16-bit\" : \"\");\n\t\tsnd_iprintf(buffer, \"  Owner           : \");\n\t\tswitch (block->owner) {\n\t\tcase SNDRV_GF1_MEM_OWNER_DRIVER:\n\t\t\tsnd_iprintf(buffer, \"driver - %s\\n\", block->name);\n\t\t\tbreak;\n\t\tcase SNDRV_GF1_MEM_OWNER_WAVE_SIMPLE:\n\t\t\tsnd_iprintf(buffer, \"SIMPLE wave\\n\");\n\t\t\tbreak;\n\t\tcase SNDRV_GF1_MEM_OWNER_WAVE_GF1:\n\t\t\tsnd_iprintf(buffer, \"GF1 wave\\n\");\n\t\t\tbreak;\n\t\tcase SNDRV_GF1_MEM_OWNER_WAVE_IWFFFF:\n\t\t\tsnd_iprintf(buffer, \"IWFFFF wave\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"unknown\\n\");\n\t\t}\n\t}\n\tsnd_iprintf(buffer, \"  Total: memory = %i, used = %i, free = %i\\n\",\n\t\t    total, used, total - used);\n\tmutex_unlock(&alloc->memory_mutex);\n#if 0\n\tultra_iprintf(buffer, \"  Verify: free = %i, max 8-bit block = %i, max 16-bit block = %i\\n\",\n\t\t      ultra_memory_free_size(card, &card->gf1.mem_alloc),\n\t\t  ultra_memory_free_block(card, &card->gf1.mem_alloc, 0),\n\t\t ultra_memory_free_block(card, &card->gf1.mem_alloc, 1));\n#endif\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}