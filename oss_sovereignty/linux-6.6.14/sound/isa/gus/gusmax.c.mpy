{
  "module_name": "gusmax.c",
  "hash_id": "f940eff32e4bb309ce39986fef30b7cb0669151cde26013c59976df2cc881bde",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gusmax.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n#include <sound/wss.h>\n#define SNDRV_LEGACY_FIND_FREE_IRQ\n#define SNDRV_LEGACY_FIND_FREE_DMA\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Gravis UltraSound MAX\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int joystick_dac[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 29};\n\t\t\t\t \nstatic int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};\nstatic int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for GUS MAX soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for GUS MAX soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable GUS MAX soundcard.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for GUS MAX driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for GUS MAX driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 # for GUS MAX driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for GUS MAX driver.\");\nmodule_param_array(joystick_dac, int, NULL, 0444);\nMODULE_PARM_DESC(joystick_dac, \"Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS MAX driver.\");\nmodule_param_array(channels, int, NULL, 0444);\nMODULE_PARM_DESC(channels, \"Used GF1 channels for GUS MAX driver.\");\nmodule_param_array(pcm_channels, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_channels, \"Reserved PCM channels for GUS MAX driver.\");\n\nstruct snd_gusmax {\n\tint irq;\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus;\n\tstruct snd_wss *wss;\n\tunsigned short gus_status_reg;\n\tunsigned short pcm_status_reg;\n};\n\n#define PFX\t\"gusmax: \"\n\nstatic int snd_gusmax_detect(struct snd_gus_card *gus)\n{\n\tunsigned char d;\n\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\t \n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 0) {\n\t\tsnd_printdd(\"[0x%lx] check 1 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -ENODEV;\n\t}\n\tudelay(160);\n\tsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\t \n\tudelay(160);\n\td = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET);\n\tif ((d & 0x07) != 1) {\n\t\tsnd_printdd(\"[0x%lx] check 2 failed - 0x%x\\n\", gus->gf1.port, d);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t snd_gusmax_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_gusmax *maxcard = dev_id;\n\tint loop, max = 5;\n\tint handled = 0;\n\n\tdo {\n\t\tloop = 0;\n\t\tif (inb(maxcard->gus_status_reg)) {\n\t\t\thandled = 1;\n\t\t\tsnd_gus_interrupt(irq, maxcard->gus);\n\t\t\tloop++;\n\t\t}\n\t\tif (inb(maxcard->pcm_status_reg) & 0x01) {  \n\t\t\thandled = 1;\n\t\t\tsnd_wss_interrupt(irq, maxcard->wss);\n\t\t\tloop++;\n\t\t}\n\t} while (loop && --max > 0);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void snd_gusmax_init(int dev, struct snd_card *card,\n\t\t\t    struct snd_gus_card *gus)\n{\n\tgus->equal_irq = 1;\n\tgus->codec_flag = 1;\n\tgus->joystick_dac = joystick_dac[dev];\n\t \n\tgus->max_cntrl_val = (gus->gf1.port >> 4) & 0x0f;\n\tif (gus->gf1.dma1 > 3)\n\t\tgus->max_cntrl_val |= 0x10;\n\tif (gus->gf1.dma2 > 3)\n\t\tgus->max_cntrl_val |= 0x20;\n\tgus->max_cntrl_val |= 0x40;\n\toutb(gus->max_cntrl_val, GUSP(gus, MAXCNTRLPORT));\n}\n\nstatic int snd_gusmax_mixer(struct snd_wss *chip)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_ctl_elem_id id1, id2;\n\tint err;\n\t\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\");\n\tstrcpy(id2.name, \"Synth Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"Synth Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tstrcpy(id1.name, \"Aux Playback Switch\"); id1.index = 1;\n\tstrcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(id1.name, \"Aux Playback Volume\");\n\tstrcpy(id2.name, \"CD Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0)\n\t\treturn err;\n#if 0\n\t \n\tif (snd_mixer_group_rename(mixer,\n\t\t\t\tSNDRV_MIXER_IN_MONO, 0,\n\t\t\t\tSNDRV_MIXER_IN_MIC, 0) < 0)\n\t\tgoto __error;\n\tif (snd_mixer_elem_rename(mixer,\n\t\t\t\tSNDRV_MIXER_IN_MONO, 0, SNDRV_MIXER_ETYPE_INPUT,\n\t\t\t\tSNDRV_MIXER_IN_MIC, 0) < 0)\n\t\tgoto __error;\n\tif (snd_mixer_elem_rename(mixer,\n\t\t\t\t\"Mono Capture Volume\", 0, SNDRV_MIXER_ETYPE_VOLUME1,\n\t\t\t\t\"Mic Capture Volume\", 0) < 0)\n\t\tgoto __error;\n\tif (snd_mixer_elem_rename(mixer,\n\t\t\t\t\"Mono Capture Switch\", 0, SNDRV_MIXER_ETYPE_SWITCH1,\n\t\t\t\t\"Mic Capture Switch\", 0) < 0)\n\t\tgoto __error;\n#endif\n\treturn 0;\n}\n\nstatic int snd_gusmax_match(struct device *pdev, unsigned int dev)\n{\n\treturn enable[dev];\n}\n\nstatic int snd_gusmax_probe(struct device *pdev, unsigned int dev)\n{\n\tstatic const int possible_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};\n\tstatic const int possible_dmas[] = {5, 6, 7, 1, 3, -1};\n\tint xirq, xdma1, xdma2, err;\n\tstruct snd_card *card;\n\tstruct snd_gus_card *gus = NULL;\n\tstruct snd_wss *wss;\n\tstruct snd_gusmax *maxcard;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_gusmax), &card);\n\tif (err < 0)\n\t\treturn err;\n\tmaxcard = card->private_data;\n\tmaxcard->card = card;\n\tmaxcard->irq = -1;\n\t\n\txirq = irq[dev];\n\tif (xirq == SNDRV_AUTO_IRQ) {\n\t\txirq = snd_legacy_find_free_irq(possible_irqs);\n\t\tif (xirq < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free IRQ\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\txdma1 = dma1[dev];\n\tif (xdma1 == SNDRV_AUTO_DMA) {\n\t\txdma1 = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (xdma1 < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\txdma2 = dma2[dev];\n\tif (xdma2 == SNDRV_AUTO_DMA) {\n\t\txdma2 = snd_legacy_find_free_dma(possible_dmas);\n\t\tif (xdma2 < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX \"unable to find a free DMA2\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (port[dev] != SNDRV_AUTO_PORT) {\n\t\terr = snd_gus_create(card,\n\t\t\t\t     port[dev],\n\t\t\t\t     -xirq, xdma1, xdma2,\n\t\t\t\t     0, channels[dev],\n\t\t\t\t     pcm_channels[dev],\n\t\t\t\t     0, &gus);\n\t} else {\n\t\tstatic const unsigned long possible_ports[] = {\n\t\t\t0x220, 0x230, 0x240, 0x250, 0x260\n\t\t};\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\n\t\t\terr = snd_gus_create(card,\n\t\t\t\t\t     possible_ports[i],\n\t\t\t\t\t     -xirq, xdma1, xdma2,\n\t\t\t\t\t     0, channels[dev],\n\t\t\t\t\t     pcm_channels[dev],\n\t\t\t\t\t     0, &gus);\n\t\t\tif (err >= 0) {\n\t\t\t\tport[dev] = possible_ports[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_gusmax_detect(gus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmaxcard->gus_status_reg = gus->gf1.reg_irqstat;\n\tmaxcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;\n\tsnd_gusmax_init(dev, card, gus);\n\terr = snd_gus_initialize(gus);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!gus->max_flag) {\n\t\tsnd_printk(KERN_ERR PFX \"GUS MAX soundcard was not detected at 0x%lx\\n\", gus->gf1.port);\n\t\treturn -ENODEV;\n\t}\n\n\tif (devm_request_irq(card->dev, xirq, snd_gusmax_interrupt, 0,\n\t\t\t     \"GUS MAX\", (void *)maxcard)) {\n\t\tsnd_printk(KERN_ERR PFX \"unable to grab IRQ %d\\n\", xirq);\n\t\treturn -EBUSY;\n\t}\n\tmaxcard->irq = xirq;\n\tcard->sync_irq = maxcard->irq;\n\n\terr = snd_wss_create(card,\n\t\t\t     gus->gf1.port + 0x10c, -1, xirq,\n\t\t\t     xdma2 < 0 ? xdma1 : xdma2, xdma1,\n\t\t\t     WSS_HW_DETECT,\n\t\t\t     WSS_HWSHARE_IRQ |\n\t\t\t     WSS_HWSHARE_DMA1 |\n\t\t\t     WSS_HWSHARE_DMA2,\n\t\t\t     &wss);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_pcm(wss, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_mixer(wss);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_wss_timer(wss, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (pcm_channels[dev] > 0) {\n\t\terr = snd_gf1_pcm_new(gus, 1, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_gusmax_mixer(wss);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_gf1_rawmidi_new(gus, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(card->longname + strlen(card->longname), \" at 0x%lx, irq %i, dma %i\", gus->gf1.port, xirq, xdma1);\n\tif (xdma2 >= 0)\n\t\tsprintf(card->longname + strlen(card->longname), \"&%i\", xdma2);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\t\t\n\tmaxcard->gus = gus;\n\tmaxcard->wss = wss;\n\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#define DEV_NAME \"gusmax\"\n\nstatic struct isa_driver snd_gusmax_driver = {\n\t.match\t\t= snd_gusmax_match,\n\t.probe\t\t= snd_gusmax_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\nmodule_isa_driver(snd_gusmax_driver, SNDRV_CARDS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}