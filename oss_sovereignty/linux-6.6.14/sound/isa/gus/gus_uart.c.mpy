{
  "module_name": "gus_uart.c",
  "hash_id": "64c23e279cb0bc200c22c79bcbeb426fb516cdc14c76d6a7e4b2a596de3c51c8",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/gus/gus_uart.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/gus.h>\n\nstatic void snd_gf1_interrupt_midi_in(struct snd_gus_card * gus)\n{\n\tint count;\n\tunsigned char stat, byte;\n\t__always_unused unsigned char data;\n\tunsigned long flags;\n\n\tcount = 10;\n\twhile (count) {\n\t\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\t\tstat = snd_gf1_uart_stat(gus);\n\t\tif (!(stat & 0x01)) {\t \n\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tcount = 100;\t \n\t\tdata = snd_gf1_uart_get(gus);\n\t\tif (!(gus->gf1.uart_cmd & 0x80)) {\n\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\tif (stat & 0x10) {\t \n\t\t\tgus->gf1.uart_framing++;\n\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tbyte = snd_gf1_uart_get(gus);\n\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\tsnd_rawmidi_receive(gus->midi_substream_input, &byte, 1);\n\t\tif (stat & 0x20) {\n\t\t\tgus->gf1.uart_overrun++;\n\t\t}\n\t}\n}\n\nstatic void snd_gf1_interrupt_midi_out(struct snd_gus_card * gus)\n{\n\tchar byte;\n\tunsigned long flags;\n\n\t \n\tif (snd_gf1_uart_stat(gus) & 0x01)\n\t\tsnd_gf1_interrupt_midi_in(gus);\n\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (snd_gf1_uart_stat(gus) & 0x02) {\t \n\t\tif (snd_rawmidi_transmit(gus->midi_substream_output, &byte, 1) != 1) {\t \n\t\t\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd & ~0x20);  \n\t\t} else {\n\t\t\tsnd_gf1_uart_put(gus, byte);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n}\n\nstatic void snd_gf1_uart_reset(struct snd_gus_card * gus, int close)\n{\n\tsnd_gf1_uart_cmd(gus, 0x03);\t \n\tif (!close && gus->uart_enable) {\n\t\tudelay(160);\n\t\tsnd_gf1_uart_cmd(gus, 0x00);\t \n\t}\n}\n\nstatic int snd_gf1_uart_output_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_gus_card *gus;\n\n\tgus = substream->rmidi->private_data;\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (!(gus->gf1.uart_cmd & 0x80)) {\t \n\t\tsnd_gf1_uart_reset(gus, 0);\n\t}\n\tgus->gf1.interrupt_handler_midi_out = snd_gf1_interrupt_midi_out;\n\tgus->midi_substream_output = substream;\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n#if 0\n\tsnd_printk(KERN_DEBUG \"write init - cmd = 0x%x, stat = 0x%x\\n\", gus->gf1.uart_cmd, snd_gf1_uart_stat(gus));\n#endif\n\treturn 0;\n}\n\nstatic int snd_gf1_uart_input_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_gus_card *gus;\n\tint i;\n\n\tgus = substream->rmidi->private_data;\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (gus->gf1.interrupt_handler_midi_out != snd_gf1_interrupt_midi_out) {\n\t\tsnd_gf1_uart_reset(gus, 0);\n\t}\n\tgus->gf1.interrupt_handler_midi_in = snd_gf1_interrupt_midi_in;\n\tgus->midi_substream_input = substream;\n\tif (gus->uart_enable) {\n\t\tfor (i = 0; i < 1000 && (snd_gf1_uart_stat(gus) & 0x01); i++)\n\t\t\tsnd_gf1_uart_get(gus);\t \n\t\tif (i >= 1000)\n\t\t\tsnd_printk(KERN_ERR \"gus midi uart init read - cleanup error\\n\");\n\t}\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n#if 0\n\tsnd_printk(KERN_DEBUG\n\t\t   \"read init - enable = %i, cmd = 0x%x, stat = 0x%x\\n\",\n\t\t   gus->uart_enable, gus->gf1.uart_cmd, snd_gf1_uart_stat(gus));\n\tsnd_printk(KERN_DEBUG\n\t\t   \"[0x%x] reg (ctrl/status) = 0x%x, reg (data) = 0x%x \"\n\t\t   \"(page = 0x%x)\\n\",\n\t\t   gus->gf1.port + 0x100, inb(gus->gf1.port + 0x100),\n\t\t   inb(gus->gf1.port + 0x101), inb(gus->gf1.port + 0x102));\n#endif\n\treturn 0;\n}\n\nstatic int snd_gf1_uart_output_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_gus_card *gus;\n\n\tgus = substream->rmidi->private_data;\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (gus->gf1.interrupt_handler_midi_in != snd_gf1_interrupt_midi_in)\n\t\tsnd_gf1_uart_reset(gus, 1);\n\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_MIDI_OUT);\n\tgus->midi_substream_output = NULL;\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_gf1_uart_input_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_gus_card *gus;\n\n\tgus = substream->rmidi->private_data;\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (gus->gf1.interrupt_handler_midi_out != snd_gf1_interrupt_midi_out)\n\t\tsnd_gf1_uart_reset(gus, 1);\n\tsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_MIDI_IN);\n\tgus->midi_substream_input = NULL;\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\treturn 0;\n}\n\nstatic void snd_gf1_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct snd_gus_card *gus;\n\tunsigned long flags;\n\n\tgus = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (up) {\n\t\tif ((gus->gf1.uart_cmd & 0x80) == 0)\n\t\t\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd | 0x80);  \n\t} else {\n\t\tif (gus->gf1.uart_cmd & 0x80)\n\t\t\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd & ~0x80);  \n\t}\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n}\n\nstatic void snd_gf1_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_gus_card *gus;\n\tchar byte;\n\tint timeout;\n\n\tgus = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\tif (up) {\n\t\tif ((gus->gf1.uart_cmd & 0x20) == 0) {\n\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\t \n\t\t\ttimeout = 10000;\n\t\t\twhile (timeout-- > 0 && snd_gf1_uart_stat(gus) & 0x01);\n\t\t\t \n\t\t\tspin_lock_irqsave(&gus->uart_cmd_lock, flags);\n\t\t\tif (gus->gf1.uart_cmd & 0x20) {\n\t\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (snd_gf1_uart_stat(gus) & 0x02) {\n\t\t\t\tif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsnd_gf1_uart_put(gus, byte);\n\t\t\t}\n\t\t\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd | 0x20);\t \n\t\t}\n\t} else {\n\t\tif (gus->gf1.uart_cmd & 0x20)\n\t\t\tsnd_gf1_uart_cmd(gus, gus->gf1.uart_cmd & ~0x20);\n\t}\n\tspin_unlock_irqrestore(&gus->uart_cmd_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_gf1_uart_output =\n{\n\t.open =\t\tsnd_gf1_uart_output_open,\n\t.close =\tsnd_gf1_uart_output_close,\n\t.trigger =\tsnd_gf1_uart_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_gf1_uart_input =\n{\n\t.open =\t\tsnd_gf1_uart_input_open,\n\t.close =\tsnd_gf1_uart_input_close,\n\t.trigger =\tsnd_gf1_uart_input_trigger,\n};\n\nint snd_gf1_rawmidi_new(struct snd_gus_card *gus, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(gus->card, \"GF1\", device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, gus->interwave ? \"AMD InterWave\" : \"GF1\");\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_gf1_uart_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_gf1_uart_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = gus;\n\tgus->midi_uart = rmidi;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}