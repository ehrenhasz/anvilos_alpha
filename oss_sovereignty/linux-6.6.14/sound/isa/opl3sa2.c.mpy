{
  "module_name": "opl3sa2.c",
  "hash_id": "e63ff6447a9a13f930245463b946d6db559c8058aa4e1cfeca2573686763011f",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/opl3sa2.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Yamaha OPL3SA2+\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;  \n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long sb_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long wss_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT; \nstatic long fm_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic long midi_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT; \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\t \nstatic int opl3sa3_ymode[SNDRV_CARDS];      \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for OPL3-SA soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for OPL3-SA soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable OPL3-SA soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"PnP detection for specified soundcard.\");\n#endif\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for OPL3-SA driver.\");\nmodule_param_hw_array(sb_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(sb_port, \"SB port # for OPL3-SA driver.\");\nmodule_param_hw_array(wss_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(wss_port, \"WSS port # for OPL3-SA driver.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port # for OPL3-SA driver.\");\nmodule_param_hw_array(midi_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(midi_port, \"MIDI port # for OPL3-SA driver.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for OPL3-SA driver.\");\nmodule_param_hw_array(dma1, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma1, \"DMA1 # for OPL3-SA driver.\");\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for OPL3-SA driver.\");\nmodule_param_array(opl3sa3_ymode, int, NULL, 0444);\nMODULE_PARM_DESC(opl3sa3_ymode, \"Speaker size selection for 3D Enhancement mode: Desktop/Large Notebook/Small Notebook/HiFi.\");\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\nstatic int pnpc_registered;\n#endif\n\n \n#define OPL3SA2_PM_CTRL\t\t0x01\n#define OPL3SA2_SYS_CTRL\t\t0x02\n#define OPL3SA2_IRQ_CONFIG\t0x03\n#define OPL3SA2_IRQ_STATUS\t0x04\n#define OPL3SA2_DMA_CONFIG\t0x06\n#define OPL3SA2_MASTER_LEFT\t0x07\n#define OPL3SA2_MASTER_RIGHT\t0x08\n#define OPL3SA2_MIC\t\t0x09\n#define OPL3SA2_MISC\t\t0x0A\n\n \n#define OPL3SA3_DGTL_DOWN\t0x12\n#define OPL3SA3_ANLG_DOWN\t0x13\n#define OPL3SA3_WIDE\t\t0x14\n#define OPL3SA3_BASS\t\t0x15\n#define OPL3SA3_TREBLE\t\t0x16\n\n \n#define OPL3SA2_PM_ADOWN\t\t0x20\n#define OPL3SA2_PM_PSV\t\t0x04\t\t\n#define OPL3SA2_PM_PDN\t\t0x02\n#define OPL3SA2_PM_PDX\t\t0x01\n\n#define OPL3SA2_PM_D0\t0x00\n#define OPL3SA2_PM_D3\t(OPL3SA2_PM_ADOWN|OPL3SA2_PM_PSV|OPL3SA2_PM_PDN|OPL3SA2_PM_PDX)\n\nstruct snd_opl3sa2 {\n\tint version;\t\t \n\tunsigned long port;\t \n\tstruct resource *res_port;  \n\tint irq;\n\tint single_dma;\n\tspinlock_t reg_lock;\n\tstruct snd_hwdep *synth;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_wss *wss;\n\tunsigned char ctlregs[0x20];\n\tint ymode;\t\t \n\tstruct snd_kcontrol *master_switch;\n\tstruct snd_kcontrol *master_volume;\n};\n\n#define PFX\t\"opl3sa2: \"\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_device_id snd_opl3sa2_pnpbiosids[] = {\n\t{ .id = \"YMH0021\" },\n\t{ .id = \"NMX2210\" },\t \n\t{ .id = \"\" }\t\t \n};\n\nMODULE_DEVICE_TABLE(pnp, snd_opl3sa2_pnpbiosids);\n\nstatic const struct pnp_card_device_id snd_opl3sa2_pnpids[] = {\n\t \n\t{ .id = \"YMH0020\", .devs = { { \"YMH0021\" } } },\n\t \n\t{ .id = \"YMH0030\", .devs = { { \"YMH0021\" } } },\n\t \n\t{ .id = \"YMH0800\", .devs = { { \"YMH0021\" } } },\n\t \n\t{ .id = \"YMH0801\", .devs = { { \"YMH0021\" } } },\n\t \n\t{ .id = \"NMX2200\", .devs = { { \"YMH2210\" } } },\n\t \n\t{ .id = \"NMX2200\", .devs = { { \"NMX2210\" } } },\n\t \n\t{ .id = \"\" }\t \n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_opl3sa2_pnpids);\n\n#endif  \n\n\n \nstatic unsigned char __snd_opl3sa2_read(struct snd_opl3sa2 *chip, unsigned char reg)\n{\n\tunsigned char result;\n#if 0\n\toutb(0x1d, port);\t \n\tprintk(KERN_DEBUG \"read [0x%lx] = 0x%x\\n\", port, inb(port));\n#endif\n\toutb(reg, chip->port);\t \n\tresult = inb(chip->port + 1);\n#if 0\n\tprintk(KERN_DEBUG \"read [0x%lx] = 0x%x [0x%x]\\n\",\n\t       port, result, inb(port));\n#endif\n\treturn result;\n}\n\n \nstatic unsigned char snd_opl3sa2_read(struct snd_opl3sa2 *chip, unsigned char reg)\n{\n\tunsigned long flags;\n\tunsigned char result;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tresult = __snd_opl3sa2_read(chip, reg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn result;\n}\n\n \nstatic void __snd_opl3sa2_write(struct snd_opl3sa2 *chip, unsigned char reg, unsigned char value)\n{\n#if 0\n\toutb(0x1d, port);\t \n#endif\n\toutb(reg, chip->port);\t \n\toutb(value, chip->port + 1);\n\tchip->ctlregs[reg] = value;\n}\n\n \nstatic void snd_opl3sa2_write(struct snd_opl3sa2 *chip, unsigned char reg, unsigned char value)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t__snd_opl3sa2_write(chip, reg, value);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic int snd_opl3sa2_detect(struct snd_card *card)\n{\n\tstruct snd_opl3sa2 *chip = card->private_data;\n\tunsigned long port;\n\tunsigned char tmp, tmp1;\n\tchar str[2];\n\n\tport = chip->port;\n\tchip->res_port = devm_request_region(card->dev, port, 2,\n\t\t\t\t\t     \"OPL3-SA control\");\n\tif (!chip->res_port) {\n\t\tsnd_printk(KERN_ERR PFX \"can't grab port 0x%lx\\n\", port);\n\t\treturn -EBUSY;\n\t}\n\t \n\tchip->version = 0;\n\ttmp = snd_opl3sa2_read(chip, OPL3SA2_MISC);\n\tif (tmp == 0xff) {\n\t\tsnd_printd(\"OPL3-SA [0x%lx] detect = 0x%x\\n\", port, tmp);\n\t\treturn -ENODEV;\n\t}\n\tswitch (tmp & 0x07) {\n\tcase 0x01:\n\t\tchip->version = 2;  \n\t\tbreak;\n\tdefault:\n\t\tchip->version = 3;\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tbreak;\n\t}\n\tstr[0] = chip->version + '0';\n\tstr[1] = 0;\n\tstrcat(card->shortname, str);\n\tsnd_opl3sa2_write(chip, OPL3SA2_MISC, tmp ^ 7);\n\ttmp1 = snd_opl3sa2_read(chip, OPL3SA2_MISC);\n\tif (tmp1 != tmp) {\n\t\tsnd_printd(\"OPL3-SA [0x%lx] detect (1) = 0x%x (0x%x)\\n\", port, tmp, tmp1);\n\t\treturn -ENODEV;\n\t}\n\t \n\ttmp = snd_opl3sa2_read(chip, OPL3SA2_MIC);\n\tsnd_opl3sa2_write(chip, OPL3SA2_MIC, 0x8a);\n\ttmp1 = snd_opl3sa2_read(chip, OPL3SA2_MIC);\n\tif ((tmp1 & 0x9f) != 0x8a) {\n\t\tsnd_printd(\"OPL3-SA [0x%lx] detect (2) = 0x%x (0x%x)\\n\", port, tmp, tmp1);\n\t\treturn -ENODEV;\n\t}\n\tsnd_opl3sa2_write(chip, OPL3SA2_MIC, 0x9f);\n\t \n\t \n\tsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D0);\n\tif (chip->version > 2) {\n\t\t \n\t\tsnd_opl3sa2_write(chip, OPL3SA2_SYS_CTRL, (chip->ymode << 4));\n\t} else {\n\t\t \n\t\tsnd_opl3sa2_write(chip, OPL3SA2_SYS_CTRL, 0x00);\n\t}\n\tsnd_opl3sa2_write(chip, OPL3SA2_IRQ_CONFIG, 0x0d);\t \n\tif (chip->single_dma) {\n\t\tsnd_opl3sa2_write(chip, OPL3SA2_DMA_CONFIG, 0x03);\t \n\t} else {\n\t\tsnd_opl3sa2_write(chip, OPL3SA2_DMA_CONFIG, 0x21);\t \n\t}\n\tsnd_opl3sa2_write(chip, OPL3SA2_MISC, 0x80 | (tmp & 7));\t \n\tif (chip->version > 2) {\n\t\tsnd_opl3sa2_write(chip, OPL3SA3_DGTL_DOWN, 0x00);\t \n\t\tsnd_opl3sa2_write(chip, OPL3SA3_ANLG_DOWN, 0x00);\t \n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t snd_opl3sa2_interrupt(int irq, void *dev_id)\n{\n\tunsigned short status;\n\tstruct snd_card *card = dev_id;\n\tstruct snd_opl3sa2 *chip;\n\tint handled = 0;\n\n\tif (card == NULL)\n\t\treturn IRQ_NONE;\n\n\tchip = card->private_data;\n\tstatus = snd_opl3sa2_read(chip, OPL3SA2_IRQ_STATUS);\n\n\tif (status & 0x20) {\n\t\thandled = 1;\n\t\tsnd_opl3_interrupt(chip->synth);\n\t}\n\n\tif ((status & 0x10) && chip->rmidi != NULL) {\n\t\thandled = 1;\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\t}\n\n\tif (status & 0x07) {\t \n\t\thandled = 1;\n\t\tsnd_wss_interrupt(irq, chip->wss);\n\t}\n\n\tif (status & 0x40) {  \n\t\thandled = 1;\n\t\t \n\t\tsnd_opl3sa2_read(chip, OPL3SA2_MASTER_RIGHT);\n\t\tsnd_opl3sa2_read(chip, OPL3SA2_MASTER_LEFT);\n\t\tif (chip->master_switch && chip->master_volume) {\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->master_switch->id);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t&chip->master_volume->id);\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n#define OPL3SA2_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_wss_info_single, \\\n  .get = snd_opl3sa2_get_single, .put = snd_opl3sa2_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n#define OPL3SA2_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .index = xindex, \\\n  .info = snd_wss_info_single, \\\n  .get = snd_opl3sa2_get_single, .put = snd_opl3sa2_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_opl3sa2_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->ctlregs[reg] >> shift) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_opl3sa2_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val, oval;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toval = chip->ctlregs[reg];\n\tval = (oval & ~(mask << shift)) | val;\n\tchange = val != oval;\n\t__snd_opl3sa2_write(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\n#define OPL3SA2_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_wss_info_double, \\\n  .get = snd_opl3sa2_get_double, .put = snd_opl3sa2_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n#define OPL3SA2_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .index = xindex, \\\n  .info = snd_wss_info_double, \\\n  .get = snd_opl3sa2_get_double, .put = snd_opl3sa2_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_opl3sa2_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = (chip->ctlregs[left_reg] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (chip->ctlregs[right_reg] >> shift_right) & mask;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_opl3sa2_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2, oval1, oval2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (left_reg != right_reg) {\n\t\toval1 = chip->ctlregs[left_reg];\n\t\toval2 = chip->ctlregs[right_reg];\n\t\tval1 = (oval1 & ~(mask << shift_left)) | val1;\n\t\tval2 = (oval2 & ~(mask << shift_right)) | val2;\n\t\tchange = val1 != oval1 || val2 != oval2;\n\t\t__snd_opl3sa2_write(chip, left_reg, val1);\n\t\t__snd_opl3sa2_write(chip, right_reg, val2);\n\t} else {\n\t\toval1 = chip->ctlregs[left_reg];\n\t\tval1 = (oval1 & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\n\t\tchange = val1 != oval1;\n\t\t__snd_opl3sa2_write(chip, left_reg, val1);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_master, -3000, 200, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_opl3sa2_controls[] = {\nOPL3SA2_DOUBLE(\"Master Playback Switch\", 0, 0x07, 0x08, 7, 7, 1, 1),\nOPL3SA2_DOUBLE_TLV(\"Master Playback Volume\", 0, 0x07, 0x08, 0, 0, 15, 1,\n\t\t   db_scale_master),\nOPL3SA2_SINGLE(\"Mic Playback Switch\", 0, 0x09, 7, 1, 1),\nOPL3SA2_SINGLE_TLV(\"Mic Playback Volume\", 0, 0x09, 0, 31, 1,\n\t\t   db_scale_5bit_12db_max),\nOPL3SA2_SINGLE(\"ZV Port Switch\", 0, 0x02, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_opl3sa2_tone_controls[] = {\nOPL3SA2_DOUBLE(\"3D Control - Wide\", 0, 0x14, 0x14, 4, 0, 7, 0),\nOPL3SA2_DOUBLE(\"Tone Control - Bass\", 0, 0x15, 0x15, 4, 0, 7, 0),\nOPL3SA2_DOUBLE(\"Tone Control - Treble\", 0, 0x16, 0x16, 4, 0, 7, 0)\n};\n\nstatic void snd_opl3sa2_master_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\n\tchip->master_switch = NULL;\n\tchip->master_volume = NULL;\n}\n\nstatic int snd_opl3sa2_mixer(struct snd_card *card)\n{\n\tstruct snd_opl3sa2 *chip = card->private_data;\n\tstruct snd_ctl_elem_id id1, id2;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tmemset(&id1, 0, sizeof(id1));\n\tmemset(&id2, 0, sizeof(id2));\n\tid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t \n        strcpy(id1.name, \"Aux Playback Switch\");\n        strcpy(id2.name, \"CD Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opl3sa2 control\\n\");\n                return err;\n\t}\n        strcpy(id1.name, \"Aux Playback Volume\");\n        strcpy(id2.name, \"CD Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opl3sa2 control\\n\");\n                return err;\n\t}\n\t \n        strcpy(id1.name, \"Aux Playback Switch\"); id1.index = 1;\n        strcpy(id2.name, \"FM Playback Switch\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opl3sa2 control\\n\");\n                return err;\n\t}\n        strcpy(id1.name, \"Aux Playback Volume\");\n        strcpy(id2.name, \"FM Playback Volume\");\n\terr = snd_ctl_rename_id(card, &id1, &id2);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Cannot rename opl3sa2 control\\n\");\n                return err;\n\t}\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_opl3sa2_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_opl3sa2_controls[idx], chip);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tswitch (idx) {\n\t\tcase 0: chip->master_switch = kctl; kctl->private_free = snd_opl3sa2_master_free; break;\n\t\tcase 1: chip->master_volume = kctl; kctl->private_free = snd_opl3sa2_master_free; break;\n\t\t}\n\t}\n\tif (chip->version > 2) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_opl3sa2_tone_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_opl3sa2_tone_controls[idx], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM\nstatic int snd_opl3sa2_suspend(struct snd_card *card, pm_message_t state)\n{\n\tif (card) {\n\t\tstruct snd_opl3sa2 *chip = card->private_data;\n\n\t\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\t\tchip->wss->suspend(chip->wss);\n\t\t \n\t\tsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D3);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_opl3sa2_resume(struct snd_card *card)\n{\n\tstruct snd_opl3sa2 *chip;\n\tint i;\n\n\tif (!card)\n\t\treturn 0;\n\n\tchip = card->private_data;\n\t \n\tsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D0);\n\n\t \n\tfor (i = 2; i <= 0x0a; i++) {\n\t\tif (i != OPL3SA2_IRQ_STATUS)\n\t\t\tsnd_opl3sa2_write(chip, i, chip->ctlregs[i]);\n\t}\n\tif (chip->version > 2) {\n\t\tfor (i = 0x12; i <= 0x16; i++)\n\t\t\tsnd_opl3sa2_write(chip, i, chip->ctlregs[i]);\n\t}\n\t \n\tchip->wss->resume(chip->wss);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PNP\nstatic int snd_opl3sa2_pnp(int dev, struct snd_opl3sa2 *chip,\n\t\t\t   struct pnp_dev *pdev)\n{\n\tif (pnp_activate_dev(pdev) < 0) {\n\t\tsnd_printk(KERN_ERR \"PnP configure failure (out of resources?)\\n\");\n\t\treturn -EBUSY;\n\t}\n\tsb_port[dev] = pnp_port_start(pdev, 0);\n\twss_port[dev] = pnp_port_start(pdev, 1);\n\tfm_port[dev] = pnp_port_start(pdev, 2);\n\tmidi_port[dev] = pnp_port_start(pdev, 3);\n\tport[dev] = pnp_port_start(pdev, 4);\n\tdma1[dev] = pnp_dma(pdev, 0);\n\tdma2[dev] = pnp_dma(pdev, 1);\n\tirq[dev] = pnp_irq(pdev, 0);\n\tsnd_printdd(\"%sPnP OPL3-SA: sb port=0x%lx, wss port=0x%lx, fm port=0x%lx, midi port=0x%lx\\n\",\n\t\tpnp_device_is_pnpbios(pdev) ? \"BIOS\" : \"ISA\", sb_port[dev], wss_port[dev], fm_port[dev], midi_port[dev]);\n\tsnd_printdd(\"%sPnP OPL3-SA: control port=0x%lx, dma1=%i, dma2=%i, irq=%i\\n\",\n\t\tpnp_device_is_pnpbios(pdev) ? \"BIOS\" : \"ISA\", port[dev], dma1[dev], dma2[dev], irq[dev]);\n\treturn 0;\n}\n#endif  \n\nstatic int snd_opl3sa2_card_new(struct device *pdev, int dev,\n\t\t\t\tstruct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tstruct snd_opl3sa2 *chip;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_opl3sa2), &card);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(card->driver, \"OPL3SA2\");\n\tstrcpy(card->shortname, \"Yamaha OPL3-SA\");\n\tchip = card->private_data;\n\tspin_lock_init(&chip->reg_lock);\n\tchip->irq = -1;\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_opl3sa2_probe(struct snd_card *card, int dev)\n{\n\tint xirq, xdma1, xdma2;\n\tstruct snd_opl3sa2 *chip;\n\tstruct snd_wss *wss;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\t  \n\tchip = card->private_data;\n\tchip->ymode = opl3sa3_ymode[dev] & 0x03 ;\n\tchip->port = port[dev];\n\txirq = irq[dev];\n\txdma1 = dma1[dev];\n\txdma2 = dma2[dev];\n\tif (xdma2 < 0)\n\t\tchip->single_dma = 1;\n\terr = snd_opl3sa2_detect(card);\n\tif (err < 0)\n\t\treturn err;\n\terr = devm_request_irq(card->dev, xirq, snd_opl3sa2_interrupt, 0,\n\t\t\t       \"OPL3-SA2\", card);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR PFX \"can't grab IRQ %d\\n\", xirq);\n\t\treturn -ENODEV;\n\t}\n\tchip->irq = xirq;\n\tcard->sync_irq = chip->irq;\n\terr = snd_wss_create(card,\n\t\t\t     wss_port[dev] + 4, -1,\n\t\t\t     xirq, xdma1, xdma2,\n\t\t\t     WSS_HW_OPL3SA2, WSS_HWSHARE_IRQ, &wss);\n\tif (err < 0) {\n\t\tsnd_printd(\"Oops, WSS not detected at 0x%lx\\n\", wss_port[dev] + 4);\n\t\treturn err;\n\t}\n\tchip->wss = wss;\n\terr = snd_wss_pcm(wss, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_wss_mixer(wss);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_mixer(card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_wss_timer(wss, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (fm_port[dev] >= 0x340 && fm_port[dev] < 0x400) {\n\t\terr = snd_opl3_create(card, fm_port[dev],\n\t\t\t\t      fm_port[dev] + 2,\n\t\t\t\t      OPL3_HW_OPL3, 0, &opl3);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_opl3_timer_new(opl3, 1, 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, &chip->synth);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (midi_port[dev] >= 0x300 && midi_port[dev] < 0x340) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_OPL3SA2,\n\t\t\t\t\t  midi_port[dev],\n\t\t\t\t\t  MPU401_INFO_IRQ_HOOK, -1,\n\t\t\t\t\t  &chip->rmidi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma %d\",\n\t\tcard->shortname, chip->port, xirq, xdma1);\n\tif (xdma2 >= 0)\n\t\tsprintf(card->longname + strlen(card->longname), \"&%d\", xdma2);\n\n\treturn snd_card_register(card);\n}\n\n#ifdef CONFIG_PNP\nstatic int snd_opl3sa2_pnp_detect(struct pnp_dev *pdev,\n\t\t\t\t  const struct pnp_device_id *id)\n{\n\tstatic int dev;\n\tint err;\n\tstruct snd_card *card;\n\n\tif (pnp_device_is_isapnp(pdev))\n\t\treturn -ENOENT;\t \n\tfor (; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\terr = snd_opl3sa2_card_new(&pdev->dev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_pnp(dev, card->private_data, pdev);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tpnp_set_drvdata(pdev, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_opl3sa2_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\n{\n\treturn snd_opl3sa2_suspend(pnp_get_drvdata(pdev), state);\n}\nstatic int snd_opl3sa2_pnp_resume(struct pnp_dev *pdev)\n{\n\treturn snd_opl3sa2_resume(pnp_get_drvdata(pdev));\n}\n#endif\n\nstatic struct pnp_driver opl3sa2_pnp_driver = {\n\t.name = \"snd-opl3sa2-pnpbios\",\n\t.id_table = snd_opl3sa2_pnpbiosids,\n\t.probe = snd_opl3sa2_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend = snd_opl3sa2_pnp_suspend,\n\t.resume = snd_opl3sa2_pnp_resume,\n#endif\n};\n\nstatic int snd_opl3sa2_pnp_cdetect(struct pnp_card_link *pcard,\n\t\t\t\t   const struct pnp_card_device_id *id)\n{\n\tstatic int dev;\n\tstruct pnp_dev *pdev;\n\tint err;\n\tstruct snd_card *card;\n\n\tpdev = pnp_request_card_device(pcard, id->devs[0].id, NULL);\n\tif (pdev == NULL) {\n\t\tsnd_printk(KERN_ERR PFX \"can't get pnp device from id '%s'\\n\",\n\t\t\t   id->devs[0].id);\n\t\treturn -EBUSY;\n\t}\n\tfor (; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\terr = snd_opl3sa2_card_new(&pdev->dev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_pnp(dev, card->private_data, pdev);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tpnp_set_card_drvdata(pcard, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_opl3sa2_pnp_csuspend(struct pnp_card_link *pcard, pm_message_t state)\n{\n\treturn snd_opl3sa2_suspend(pnp_get_card_drvdata(pcard), state);\n}\nstatic int snd_opl3sa2_pnp_cresume(struct pnp_card_link *pcard)\n{\n\treturn snd_opl3sa2_resume(pnp_get_card_drvdata(pcard));\n}\n#endif\n\nstatic struct pnp_card_driver opl3sa2_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DISABLE,\n\t.name = \"snd-opl3sa2-cpnp\",\n\t.id_table = snd_opl3sa2_pnpids,\n\t.probe = snd_opl3sa2_pnp_cdetect,\n#ifdef CONFIG_PM\n\t.suspend = snd_opl3sa2_pnp_csuspend,\n\t.resume = snd_opl3sa2_pnp_cresume,\n#endif\n};\n#endif  \n\nstatic int snd_opl3sa2_isa_match(struct device *pdev,\n\t\t\t\t unsigned int dev)\n{\n\tif (!enable[dev])\n\t\treturn 0;\n#ifdef CONFIG_PNP\n\tif (isapnp[dev])\n\t\treturn 0;\n#endif\n\tif (port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify port\\n\");\n\t\treturn 0;\n\t}\n\tif (wss_port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify wss_port\\n\");\n\t\treturn 0;\n\t}\n\tif (fm_port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify fm_port\\n\");\n\t\treturn 0;\n\t}\n\tif (midi_port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify midi_port\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_opl3sa2_isa_probe(struct device *pdev,\n\t\t\t\t unsigned int dev)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_opl3sa2_card_new(pdev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3sa2_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_opl3sa2_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\t   pm_message_t state)\n{\n\treturn snd_opl3sa2_suspend(dev_get_drvdata(dev), state);\n}\n\nstatic int snd_opl3sa2_isa_resume(struct device *dev, unsigned int n)\n{\n\treturn snd_opl3sa2_resume(dev_get_drvdata(dev));\n}\n#endif\n\n#define DEV_NAME \"opl3sa2\"\n\nstatic struct isa_driver snd_opl3sa2_isa_driver = {\n\t.match\t\t= snd_opl3sa2_isa_match,\n\t.probe\t\t= snd_opl3sa2_isa_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_opl3sa2_isa_suspend,\n\t.resume\t\t= snd_opl3sa2_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\nstatic int __init alsa_card_opl3sa2_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_opl3sa2_isa_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_driver(&opl3sa2_pnp_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\terr = pnp_register_card_driver(&opl3sa2_pnpc_driver);\n\tif (!err)\n\t\tpnpc_registered = 1;\n\n\tif (isa_registered || pnp_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_opl3sa2_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnpc_registered)\n\t\tpnp_unregister_card_driver(&opl3sa2_pnpc_driver);\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&opl3sa2_pnp_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_opl3sa2_isa_driver);\n}\n\nmodule_init(alsa_card_opl3sa2_init)\nmodule_exit(alsa_card_opl3sa2_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}