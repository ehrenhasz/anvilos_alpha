{
  "module_name": "cmi8330.c",
  "hash_id": "7bf76acfca7176360da286cb9395346c7fdc55f1754aa6f66263a03916754930",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/cmi8330.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/opl3.h>\n#include <sound/mpu401.h>\n#include <sound/sb.h>\n#include <sound/initval.h>\n\n \n \n#define PLAYBACK_ON_SB\n\n \nMODULE_AUTHOR(\"George Talusan <gstalusan@uwaterloo.ca>\");\nMODULE_DESCRIPTION(\"C-Media CMI8330/CMI8329\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_ISAPNP;\n#ifdef CONFIG_PNP\nstatic bool isapnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long sbport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int sbirq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int sbdma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic int sbdma16[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic long wssport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int wssirq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int wssdma[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic long fmport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long mpuport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int mpuirq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for CMI8330/CMI8329 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string  for CMI8330/CMI8329 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable CMI8330/CMI8329 soundcard.\");\n#ifdef CONFIG_PNP\nmodule_param_array(isapnp, bool, NULL, 0444);\nMODULE_PARM_DESC(isapnp, \"PnP detection for specified soundcard.\");\n#endif\n\nmodule_param_hw_array(sbport, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(sbport, \"Port # for CMI8330/CMI8329 SB driver.\");\nmodule_param_hw_array(sbirq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(sbirq, \"IRQ # for CMI8330/CMI8329 SB driver.\");\nmodule_param_hw_array(sbdma8, int, dma, NULL, 0444);\nMODULE_PARM_DESC(sbdma8, \"DMA8 for CMI8330/CMI8329 SB driver.\");\nmodule_param_hw_array(sbdma16, int, dma, NULL, 0444);\nMODULE_PARM_DESC(sbdma16, \"DMA16 for CMI8330/CMI8329 SB driver.\");\n\nmodule_param_hw_array(wssport, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(wssport, \"Port # for CMI8330/CMI8329 WSS driver.\");\nmodule_param_hw_array(wssirq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(wssirq, \"IRQ # for CMI8330/CMI8329 WSS driver.\");\nmodule_param_hw_array(wssdma, int, dma, NULL, 0444);\nMODULE_PARM_DESC(wssdma, \"DMA for CMI8330/CMI8329 WSS driver.\");\n\nmodule_param_hw_array(fmport, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fmport, \"FM port # for CMI8330/CMI8329 driver.\");\nmodule_param_hw_array(mpuport, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpuport, \"MPU-401 port # for CMI8330/CMI8329 driver.\");\nmodule_param_hw_array(mpuirq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpuirq, \"IRQ # for CMI8330/CMI8329 MPU-401 port.\");\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\n#endif\n\n#define CMI8330_RMUX3D    16\n#define CMI8330_MUTEMUX   17\n#define CMI8330_OUTPUTVOL 18\n#define CMI8330_MASTVOL   19\n#define CMI8330_LINVOL    20\n#define CMI8330_CDINVOL   21\n#define CMI8330_WAVVOL    22\n#define CMI8330_RECMUX    23\n#define CMI8330_WAVGAIN   24\n#define CMI8330_LINGAIN   25\n#define CMI8330_CDINGAIN  26\n\nstatic const unsigned char snd_cmi8330_image[((CMI8330_CDINGAIN)-16) + 1] =\n{\n\t0x40,\t\t\t \n#ifdef ENABLE_SB_MIXER\n\t0x40,\t\t\t \n#else\n\t0x0,\t\t\t \n#endif\n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0,\t\t\t \n\t0x0\t\t\t \n};\n\ntypedef int (*snd_pcm_open_callback_t)(struct snd_pcm_substream *);\n\nenum card_type {\n\tCMI8330,\n\tCMI8329\n};\n\nstruct snd_cmi8330 {\n#ifdef CONFIG_PNP\n\tstruct pnp_dev *cap;\n\tstruct pnp_dev *play;\n\tstruct pnp_dev *mpu;\n#endif\n\tstruct snd_card *card;\n\tstruct snd_wss *wss;\n\tstruct snd_sb *sb;\n\n\tstruct snd_pcm *pcm;\n\tstruct snd_cmi8330_stream {\n\t\tstruct snd_pcm_ops ops;\n\t\tsnd_pcm_open_callback_t open;\n\t\tvoid *private_data;  \n\t} streams[2];\n\n\tenum card_type type;\n};\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_card_device_id snd_cmi8330_pnpids[] = {\n\t{ .id = \"CMI0001\", .devs = { { \"@X@0001\" }, { \"@@@0001\" }, { \"@H@0001\" }, { \"A@@0001\" } } },\n\t{ .id = \"CMI0001\", .devs = { { \"@@@0001\" }, { \"@X@0001\" }, { \"@H@0001\" } } },\n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp_card, snd_cmi8330_pnpids);\n\n#endif\n\n\nstatic const struct snd_kcontrol_new snd_cmi8330_controls[] = {\nWSS_DOUBLE(\"Master Playback Volume\", 0,\n\t\tCMI8330_MASTVOL, CMI8330_MASTVOL, 4, 0, 15, 0),\nWSS_SINGLE(\"Loud Playback Switch\", 0,\n\t\tCMI8330_MUTEMUX, 6, 1, 1),\nWSS_DOUBLE(\"PCM Playback Switch\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"PCM Playback Volume\", 0,\n\t\tCS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 63, 1),\nWSS_DOUBLE(\"Line Playback Switch\", 0,\n\t\tCMI8330_MUTEMUX, CMI8330_MUTEMUX, 4, 3, 1, 0),\nWSS_DOUBLE(\"Line Playback Volume\", 0,\n\t\tCMI8330_LINVOL, CMI8330_LINVOL, 4, 0, 15, 0),\nWSS_DOUBLE(\"Line Capture Switch\", 0,\n\t\tCMI8330_RMUX3D, CMI8330_RMUX3D, 2, 1, 1, 0),\nWSS_DOUBLE(\"Line Capture Volume\", 0,\n\t\tCMI8330_LINGAIN, CMI8330_LINGAIN, 4, 0, 15, 0),\nWSS_DOUBLE(\"CD Playback Switch\", 0,\n\t\tCMI8330_MUTEMUX, CMI8330_MUTEMUX, 2, 1, 1, 0),\nWSS_DOUBLE(\"CD Capture Switch\", 0,\n\t\tCMI8330_RMUX3D, CMI8330_RMUX3D, 4, 3, 1, 0),\nWSS_DOUBLE(\"CD Playback Volume\", 0,\n\t\tCMI8330_CDINVOL, CMI8330_CDINVOL, 4, 0, 15, 0),\nWSS_DOUBLE(\"CD Capture Volume\", 0,\n\t\tCMI8330_CDINGAIN, CMI8330_CDINGAIN, 4, 0, 15, 0),\nWSS_SINGLE(\"Mic Playback Switch\", 0,\n\t\tCMI8330_MUTEMUX, 0, 1, 0),\nWSS_SINGLE(\"Mic Playback Volume\", 0,\n\t\tCMI8330_OUTPUTVOL, 0, 7, 0),\nWSS_SINGLE(\"Mic Capture Switch\", 0,\n\t\tCMI8330_RMUX3D, 0, 1, 0),\nWSS_SINGLE(\"Mic Capture Volume\", 0,\n\t\tCMI8330_OUTPUTVOL, 5, 7, 0),\nWSS_DOUBLE(\"Wavetable Playback Switch\", 0,\n\t\tCMI8330_RECMUX, CMI8330_RECMUX, 1, 0, 1, 0),\nWSS_DOUBLE(\"Wavetable Playback Volume\", 0,\n\t\tCMI8330_WAVVOL, CMI8330_WAVVOL, 4, 0, 15, 0),\nWSS_DOUBLE(\"Wavetable Capture Switch\", 0,\n\t\tCMI8330_RECMUX, CMI8330_RECMUX, 5, 4, 1, 0),\nWSS_DOUBLE(\"Wavetable Capture Volume\", 0,\n\t\tCMI8330_WAVGAIN, CMI8330_WAVGAIN, 4, 0, 15, 0),\nWSS_SINGLE(\"3D Control - Switch\", 0,\n\t\tCMI8330_RMUX3D, 5, 1, 1),\nWSS_SINGLE(\"Beep Playback Volume\", 0,\n\t\tCMI8330_OUTPUTVOL, 3, 3, 0),\nWSS_DOUBLE(\"FM Playback Switch\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 7, 7, 1, 1),\nWSS_DOUBLE(\"FM Playback Volume\", 0,\n\t\tCS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 0, 0, 31, 1),\nWSS_SINGLE(SNDRV_CTL_NAME_IEC958(\"Input \", CAPTURE, SWITCH), 0,\n\t\tCMI8330_RMUX3D, 7, 1, 1),\nWSS_SINGLE(SNDRV_CTL_NAME_IEC958(\"Input \", PLAYBACK, SWITCH), 0,\n\t\tCMI8330_MUTEMUX, 7, 1, 1),\n};\n\n#ifdef ENABLE_SB_MIXER\nstatic const struct sbmix_elem cmi8330_sb_mixers[] = {\nSB_DOUBLE(\"SB Master Playback Volume\", SB_DSP4_MASTER_DEV, (SB_DSP4_MASTER_DEV + 1), 3, 3, 31),\nSB_DOUBLE(\"Tone Control - Bass\", SB_DSP4_BASS_DEV, (SB_DSP4_BASS_DEV + 1), 4, 4, 15),\nSB_DOUBLE(\"Tone Control - Treble\", SB_DSP4_TREBLE_DEV, (SB_DSP4_TREBLE_DEV + 1), 4, 4, 15),\nSB_DOUBLE(\"SB PCM Playback Volume\", SB_DSP4_PCM_DEV, (SB_DSP4_PCM_DEV + 1), 3, 3, 31),\nSB_DOUBLE(\"SB Synth Playback Volume\", SB_DSP4_SYNTH_DEV, (SB_DSP4_SYNTH_DEV + 1), 3, 3, 31),\nSB_DOUBLE(\"SB CD Playback Switch\", SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 2, 1, 1),\nSB_DOUBLE(\"SB CD Playback Volume\", SB_DSP4_CD_DEV, (SB_DSP4_CD_DEV + 1), 3, 3, 31),\nSB_DOUBLE(\"SB Line Playback Switch\", SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, 4, 3, 1),\nSB_DOUBLE(\"SB Line Playback Volume\", SB_DSP4_LINE_DEV, (SB_DSP4_LINE_DEV + 1), 3, 3, 31),\nSB_SINGLE(\"SB Mic Playback Switch\", SB_DSP4_OUTPUT_SW, 0, 1),\nSB_SINGLE(\"SB Mic Playback Volume\", SB_DSP4_MIC_DEV, 3, 31),\nSB_SINGLE(\"SB Beep Volume\", SB_DSP4_SPEAKER_DEV, 6, 3),\nSB_DOUBLE(\"SB Capture Volume\", SB_DSP4_IGAIN_DEV, (SB_DSP4_IGAIN_DEV + 1), 6, 6, 3),\nSB_DOUBLE(\"SB Playback Volume\", SB_DSP4_OGAIN_DEV, (SB_DSP4_OGAIN_DEV + 1), 6, 6, 3),\nSB_SINGLE(\"SB Mic Auto Gain\", SB_DSP4_MIC_AGC, 0, 1),\n};\n\nstatic const unsigned char cmi8330_sb_init_values[][2] = {\n\t{ SB_DSP4_MASTER_DEV + 0, 0 },\n\t{ SB_DSP4_MASTER_DEV + 1, 0 },\n\t{ SB_DSP4_PCM_DEV + 0, 0 },\n\t{ SB_DSP4_PCM_DEV + 1, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 0, 0 },\n\t{ SB_DSP4_SYNTH_DEV + 1, 0 },\n\t{ SB_DSP4_INPUT_LEFT, 0 },\n\t{ SB_DSP4_INPUT_RIGHT, 0 },\n\t{ SB_DSP4_OUTPUT_SW, 0 },\n\t{ SB_DSP4_SPEAKER_DEV, 0 },\n};\n\n\nstatic int cmi8330_add_sb_mixers(struct snd_sb *chip)\n{\n\tint idx, err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\tsnd_sbmixer_write(chip, 0x00, 0x00);\t\t \n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(cmi8330_sb_init_values); idx++) {\n\t\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\t\tsnd_sbmixer_write(chip, cmi8330_sb_init_values[idx][0],\n\t\t\t\t  cmi8330_sb_init_values[idx][1]);\n\t\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(cmi8330_sb_mixers); idx++) {\n\t\terr = snd_sbmixer_add_ctl_elem(chip, &cmi8330_sb_mixers[idx]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int snd_cmi8330_mixer(struct snd_card *card, struct snd_cmi8330 *acard)\n{\n\tunsigned int idx;\n\tint err;\n\n\tstrcpy(card->mixername, (acard->type == CMI8329) ? \"CMI8329\" : \"CMI8330/C3D\");\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmi8330_controls); idx++) {\n\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_cmi8330_controls[idx],\n\t\t\t\t\t     acard->wss));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#ifdef ENABLE_SB_MIXER\n\terr = cmi8330_add_sb_mixers(acard->sb);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_PNP\nstatic int snd_cmi8330_pnp(int dev, struct snd_cmi8330 *acard,\n\t\t\t   struct pnp_card_link *card,\n\t\t\t   const struct pnp_card_device_id *id)\n{\n\tstruct pnp_dev *pdev;\n\tint err;\n\n\t \n\tacard->type = (id->devs[3].id[0]) ? CMI8329 : CMI8330;\n\n\tacard->cap = pnp_request_card_device(card, id->devs[0].id, NULL);\n\tif (acard->cap == NULL)\n\t\treturn -EBUSY;\n\n\tacard->play = pnp_request_card_device(card, id->devs[1].id, NULL);\n\tif (acard->play == NULL)\n\t\treturn -EBUSY;\n\n\tacard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);\n\tif (acard->mpu == NULL)\n\t\treturn -EBUSY;\n\n\tpdev = acard->cap;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"AD1848 PnP configure failure\\n\");\n\t\treturn -EBUSY;\n\t}\n\twssport[dev] = pnp_port_start(pdev, 0);\n\twssdma[dev] = pnp_dma(pdev, 0);\n\twssirq[dev] = pnp_irq(pdev, 0);\n\tif (pnp_port_start(pdev, 1))\n\t\tfmport[dev] = pnp_port_start(pdev, 1);\n\n\t \n\tpdev = acard->play;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"SB16 PnP configure failure\\n\");\n\t\treturn -EBUSY;\n\t}\n\tsbport[dev] = pnp_port_start(pdev, 0);\n\tsbdma8[dev] = pnp_dma(pdev, 0);\n\tsbdma16[dev] = pnp_dma(pdev, 1);\n\tsbirq[dev] = pnp_irq(pdev, 0);\n\t \n\tif (fmport[dev] == SNDRV_AUTO_PORT) {\n\t\tif (pnp_port_start(pdev, 1))\n\t\t\tfmport[dev] = pnp_port_start(pdev, 1);\n\t\telse\n\t\t\tfmport[dev] = 0x388;\t \n\t}\n\n\t \n\tpdev = acard->mpu;\n\n\terr = pnp_activate_dev(pdev);\n\tif (err < 0)\n\t\tsnd_printk(KERN_ERR \"MPU-401 PnP configure failure: will be disabled\\n\");\n\telse {\n\t\tmpuport[dev] = pnp_port_start(pdev, 0);\n\t\tmpuirq[dev] = pnp_irq(pdev, 0);\n\t}\n\treturn 0;\n}\n#endif\n\n \n\n#ifdef PLAYBACK_ON_SB\n#define CMI_SB_STREAM\tSNDRV_PCM_STREAM_PLAYBACK\n#define CMI_AD_STREAM\tSNDRV_PCM_STREAM_CAPTURE\n#else\n#define CMI_SB_STREAM\tSNDRV_PCM_STREAM_CAPTURE\n#define CMI_AD_STREAM\tSNDRV_PCM_STREAM_PLAYBACK\n#endif\n\nstatic int snd_cmi8330_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cmi8330 *chip = snd_pcm_substream_chip(substream);\n\n\t \n\tsubstream->private_data = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].private_data;\n\treturn chip->streams[SNDRV_PCM_STREAM_PLAYBACK].open(substream);\n}\n\nstatic int snd_cmi8330_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cmi8330 *chip = snd_pcm_substream_chip(substream);\n\n\t \n\tsubstream->private_data = chip->streams[SNDRV_PCM_STREAM_CAPTURE].private_data;\n\treturn chip->streams[SNDRV_PCM_STREAM_CAPTURE].open(substream);\n}\n\nstatic int snd_cmi8330_pcm(struct snd_card *card, struct snd_cmi8330 *chip)\n{\n\tstruct snd_pcm *pcm;\n\tconst struct snd_pcm_ops *ops;\n\tint err;\n\tstatic const snd_pcm_open_callback_t cmi_open_callbacks[2] = {\n\t\tsnd_cmi8330_playback_open,\n\t\tsnd_cmi8330_capture_open\n\t};\n\n\terr = snd_pcm_new(card, (chip->type == CMI8329) ? \"CMI8329\" : \"CMI8330\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(pcm->name, (chip->type == CMI8329) ? \"CMI8329\" : \"CMI8330\");\n\tpcm->private_data = chip;\n\t\n\t \n\tops = snd_sb16dsp_get_pcm_ops(CMI_SB_STREAM);\n\tchip->streams[CMI_SB_STREAM].ops = *ops;\n\tchip->streams[CMI_SB_STREAM].open = ops->open;\n\tchip->streams[CMI_SB_STREAM].ops.open = cmi_open_callbacks[CMI_SB_STREAM];\n\tchip->streams[CMI_SB_STREAM].private_data = chip->sb;\n\n\t \n\tops = snd_wss_get_pcm_ops(CMI_AD_STREAM);\n\tchip->streams[CMI_AD_STREAM].ops = *ops;\n\tchip->streams[CMI_AD_STREAM].open = ops->open;\n\tchip->streams[CMI_AD_STREAM].ops.open = cmi_open_callbacks[CMI_AD_STREAM];\n\tchip->streams[CMI_AD_STREAM].private_data = chip->wss;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK].ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &chip->streams[SNDRV_PCM_STREAM_CAPTURE].ops);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       card->dev, 64*1024, 128*1024);\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_PM\nstatic int snd_cmi8330_suspend(struct snd_card *card)\n{\n\tstruct snd_cmi8330 *acard = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tacard->wss->suspend(acard->wss);\n\tsnd_sbmixer_suspend(acard->sb);\n\treturn 0;\n}\n\nstatic int snd_cmi8330_resume(struct snd_card *card)\n{\n\tstruct snd_cmi8330 *acard = card->private_data;\n\n\tsnd_sbdsp_reset(acard->sb);\n\tsnd_sbmixer_suspend(acard->sb);\n\tacard->wss->resume(acard->wss);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n#endif\n\n\n \n\n#ifdef CONFIG_PNP\n#define is_isapnp_selected(dev)\t\tisapnp[dev]\n#else\n#define is_isapnp_selected(dev)\t\t0\n#endif\n\n#define PFX\t\"cmi8330: \"\n\nstatic int snd_cmi8330_card_new(struct device *pdev, int dev,\n\t\t\t\tstruct snd_card **cardp)\n{\n\tstruct snd_card *card;\n\tstruct snd_cmi8330 *acard;\n\tint err;\n\n\terr = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_cmi8330), &card);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"could not get a new card\\n\");\n\t\treturn err;\n\t}\n\tacard = card->private_data;\n\tacard->card = card;\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_cmi8330_probe(struct snd_card *card, int dev)\n{\n\tstruct snd_cmi8330 *acard;\n\tint i, err;\n\tstruct snd_opl3 *opl3;\n\n\tacard = card->private_data;\n\terr = snd_wss_create(card, wssport[dev] + 4, -1,\n\t\t\t     wssirq[dev],\n\t\t\t     wssdma[dev], -1,\n\t\t\t     WSS_HW_DETECT, 0, &acard->wss);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"AD1848 device busy??\\n\");\n\t\treturn err;\n\t}\n\tif (acard->wss->hardware != WSS_HW_CMI8330) {\n\t\tsnd_printk(KERN_ERR PFX \"AD1848 not found during probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_sbdsp_create(card, sbport[dev],\n\t\t\t       sbirq[dev],\n\t\t\t       snd_sb16dsp_interrupt,\n\t\t\t       sbdma8[dev],\n\t\t\t       sbdma16[dev],\n\t\t\t       SB_HW_AUTO, &acard->sb);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"SB16 device busy??\\n\");\n\t\treturn err;\n\t}\n\tif (acard->sb->hardware != SB_HW_16) {\n\t\tsnd_printk(KERN_ERR PFX \"SB16 not found during probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnd_wss_out(acard->wss, CS4231_MISC_INFO, 0x40);  \n\tfor (i = CMI8330_RMUX3D; i <= CMI8330_CDINGAIN; i++)\n\t\tsnd_wss_out(acard->wss, i,\n\t\t\t    snd_cmi8330_image[i - CMI8330_RMUX3D]);\n\n\terr = snd_cmi8330_mixer(card, acard);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"failed to create mixers\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_cmi8330_pcm(card, acard);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"failed to create pcms\\n\");\n\t\treturn err;\n\t}\n\tif (fmport[dev] != SNDRV_AUTO_PORT) {\n\t\tif (snd_opl3_create(card,\n\t\t\t\t    fmport[dev], fmport[dev] + 2,\n\t\t\t\t    OPL3_HW_AUTO, 0, &opl3) < 0) {\n\t\t\tsnd_printk(KERN_ERR PFX\n\t\t\t\t   \"no OPL device at 0x%lx-0x%lx ?\\n\",\n\t\t\t\t   fmport[dev], fmport[dev] + 2);\n\t\t} else {\n\t\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (mpuport[dev] != SNDRV_AUTO_PORT) {\n\t\tif (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\t\tmpuport[dev], 0, mpuirq[dev],\n\t\t\t\t\tNULL) < 0)\n\t\t\tprintk(KERN_ERR PFX \"no MPU-401 device at 0x%lx.\\n\",\n\t\t\t\tmpuport[dev]);\n\t}\n\n\tstrcpy(card->driver, (acard->type == CMI8329) ? \"CMI8329\" : \"CMI8330/C3D\");\n\tstrcpy(card->shortname, (acard->type == CMI8329) ? \"C-Media CMI8329\" : \"C-Media CMI8330/C3D\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d, dma %d\",\n\t\tcard->shortname,\n\t\tacard->wss->port,\n\t\twssirq[dev],\n\t\twssdma[dev]);\n\n\treturn snd_card_register(card);\n}\n\nstatic int snd_cmi8330_isa_match(struct device *pdev,\n\t\t\t\t unsigned int dev)\n{\n\tif (!enable[dev] || is_isapnp_selected(dev))\n\t\treturn 0;\n\tif (wssport[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify wssport\\n\");\n\t\treturn 0;\n\t}\n\tif (sbport[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR PFX \"specify sbport\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int snd_cmi8330_isa_probe(struct device *pdev,\n\t\t\t\t unsigned int dev)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_cmi8330_card_new(pdev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_cmi8330_probe(card, dev);\n\tif (err < 0)\n\t\treturn err;\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_cmi8330_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\t   pm_message_t state)\n{\n\treturn snd_cmi8330_suspend(dev_get_drvdata(dev));\n}\n\nstatic int snd_cmi8330_isa_resume(struct device *dev, unsigned int n)\n{\n\treturn snd_cmi8330_resume(dev_get_drvdata(dev));\n}\n#endif\n\n#define DEV_NAME\t\"cmi8330\"\n\nstatic struct isa_driver snd_cmi8330_driver = {\n\t.match\t\t= snd_cmi8330_isa_match,\n\t.probe\t\t= snd_cmi8330_isa_probe,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_cmi8330_isa_suspend,\n\t.resume\t\t= snd_cmi8330_isa_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n\n#ifdef CONFIG_PNP\nstatic int snd_cmi8330_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t\t  const struct pnp_card_device_id *pid)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint res;\n\n\tfor ( ; dev < SNDRV_CARDS; dev++) {\n\t\tif (enable[dev] && isapnp[dev])\n\t\t\tbreak;\n\t}\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\t\t\t       \n\tres = snd_cmi8330_card_new(&pcard->card->dev, dev, &card);\n\tif (res < 0)\n\t\treturn res;\n\tres = snd_cmi8330_pnp(dev, card->private_data, pcard, pid);\n\tif (res < 0) {\n\t\tsnd_printk(KERN_ERR PFX \"PnP detection failed\\n\");\n\t\treturn res;\n\t}\n\tres = snd_cmi8330_probe(card, dev);\n\tif (res < 0)\n\t\treturn res;\n\tpnp_set_card_drvdata(pcard, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int snd_cmi8330_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\n{\n\treturn snd_cmi8330_suspend(pnp_get_card_drvdata(pcard));\n}\n\nstatic int snd_cmi8330_pnp_resume(struct pnp_card_link *pcard)\n{\n\treturn snd_cmi8330_resume(pnp_get_card_drvdata(pcard));\n}\n#endif\n\nstatic struct pnp_card_driver cmi8330_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DISABLE,\n\t.name = \"cmi8330\",\n\t.id_table = snd_cmi8330_pnpids,\n\t.probe = snd_cmi8330_pnp_detect,\n#ifdef CONFIG_PM\n\t.suspend\t= snd_cmi8330_pnp_suspend,\n\t.resume\t\t= snd_cmi8330_pnp_resume,\n#endif\n};\n#endif  \n\nstatic int __init alsa_card_cmi8330_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_cmi8330_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&cmi8330_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_cmi8330_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&cmi8330_pnpc_driver);\n\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_cmi8330_driver);\n}\n\nmodule_init(alsa_card_cmi8330_init)\nmodule_exit(alsa_card_cmi8330_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}