{
  "module_name": "sscape.c",
  "hash_id": "99606e93d76b4d1da270087e5d3aa9efd938cf4863f846a175f5173b6a17b103",
  "original_prompt": "Ingested from linux-6.6.14/sound/isa/sscape.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/isa.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/pnp.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <asm/dma.h>\n#include <sound/core.h>\n#include <sound/wss.h>\n#include <sound/mpu401.h>\n#include <sound/initval.h>\n\n\nMODULE_AUTHOR(\"Chris Rankin\");\nMODULE_DESCRIPTION(\"ENSONIQ SoundScape driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"sndscape.co0\");\nMODULE_FIRMWARE(\"sndscape.co1\");\nMODULE_FIRMWARE(\"sndscape.co2\");\nMODULE_FIRMWARE(\"sndscape.co3\");\nMODULE_FIRMWARE(\"sndscape.co4\");\nMODULE_FIRMWARE(\"scope.cod\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char* id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic long wss_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\nstatic int dma[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;\nstatic bool joystick[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index number for SoundScape soundcard\");\n\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"Description for SoundScape card\");\n\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for SoundScape driver.\");\n\nmodule_param_hw_array(wss_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(wss_port, \"WSS Port # for SoundScape driver.\");\n\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for SoundScape driver.\");\n\nmodule_param_hw_array(mpu_irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(mpu_irq, \"MPU401 IRQ # for SoundScape driver.\");\n\nmodule_param_hw_array(dma, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma, \"DMA # for SoundScape driver.\");\n\nmodule_param_hw_array(dma2, int, dma, NULL, 0444);\nMODULE_PARM_DESC(dma2, \"DMA2 # for SoundScape driver.\");\n\nmodule_param_array(joystick, bool, NULL, 0444);\nMODULE_PARM_DESC(joystick, \"Enable gameport.\");\n\n#ifdef CONFIG_PNP\nstatic int isa_registered;\nstatic int pnp_registered;\n\nstatic const struct pnp_card_device_id sscape_pnpids[] = {\n\t{ .id = \"ENS3081\", .devs = { { \"ENS0000\" } } },  \n\t{ .id = \"ENS4081\", .devs = { { \"ENS1011\" } } },\t \n\t{ .id = \"\" }\t \n};\n\nMODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);\n#endif\n\n\n#define HOST_CTRL_IO(i)  ((i) + 2)\n#define HOST_DATA_IO(i)  ((i) + 3)\n#define ODIE_ADDR_IO(i)  ((i) + 4)\n#define ODIE_DATA_IO(i)  ((i) + 5)\n#define CODEC_IO(i)      ((i) + 8)\n\n#define IC_ODIE  1\n#define IC_OPUS  2\n\n#define RX_READY 0x01\n#define TX_READY 0x02\n\n#define CMD_ACK\t\t\t0x80\n#define CMD_SET_MIDI_VOL\t0x84\n#define CMD_GET_MIDI_VOL\t0x85\n#define CMD_XXX_MIDI_VOL\t0x86\n#define CMD_SET_EXTMIDI\t\t0x8a\n#define CMD_GET_EXTMIDI\t\t0x8b\n#define CMD_SET_MT32\t\t0x8c\n#define CMD_GET_MT32\t\t0x8d\n\nenum GA_REG {\n\tGA_INTSTAT_REG = 0,\n\tGA_INTENA_REG,\n\tGA_DMAA_REG,\n\tGA_DMAB_REG,\n\tGA_INTCFG_REG,\n\tGA_DMACFG_REG,\n\tGA_CDCFG_REG,\n\tGA_SMCFGA_REG,\n\tGA_SMCFGB_REG,\n\tGA_HMCTL_REG\n};\n\n#define DMA_8BIT  0x80\n\n\nenum card_type {\n\tMEDIA_FX,\t \n\tSSCAPE,\t\t \n\tSSCAPE_PNP,\n\tSSCAPE_VIVO,\n};\n\nstruct soundscape {\n\tspinlock_t lock;\n\tunsigned io_base;\n\tint ic_type;\n\tenum card_type type;\n\tstruct resource *io_res;\n\tstruct resource *wss_res;\n\tstruct snd_wss *chip;\n\n\tunsigned char midi_vol;\n};\n\n#define INVALID_IRQ  ((unsigned)-1)\n\n\nstatic inline struct soundscape *get_card_soundscape(struct snd_card *c)\n{\n\treturn (struct soundscape *) (c->private_data);\n}\n\n \nstatic struct snd_dma_buffer *get_dmabuf(struct soundscape *s,\n\t\t\t\t\t struct snd_dma_buffer *buf,\n\t\t\t\t\t unsigned long size)\n{\n\tif (buf) {\n\t\tif (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t s->chip->card->dev,\n\t\t\t\t\t\t size, buf) < 0) {\n\t\t\tsnd_printk(KERN_ERR \"sscape: Failed to allocate \"\n\t\t\t\t\t    \"%lu bytes for DMA\\n\",\n\t\t\t\t\t    size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buf;\n}\n\n \nstatic void free_dmabuf(struct snd_dma_buffer *buf)\n{\n\tif (buf && buf->area)\n\t\tsnd_dma_free_pages(buf);\n}\n\n \nstatic inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg,\n\t\t\t\t       unsigned char val)\n{\n\toutb(reg, ODIE_ADDR_IO(io_base));\n\toutb(val, ODIE_DATA_IO(io_base));\n}\n\n \nstatic void sscape_write(struct soundscape *s, enum GA_REG reg,\n\t\t\t unsigned char val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tsscape_write_unsafe(s->io_base, reg, val);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\n \nstatic inline unsigned char sscape_read_unsafe(unsigned io_base,\n\t\t\t\t\t       enum GA_REG reg)\n{\n\toutb(reg, ODIE_ADDR_IO(io_base));\n\treturn inb(ODIE_DATA_IO(io_base));\n}\n\n \nstatic inline void set_host_mode_unsafe(unsigned io_base)\n{\n\toutb(0x0, HOST_CTRL_IO(io_base));\n}\n\n \nstatic inline void set_midi_mode_unsafe(unsigned io_base)\n{\n\toutb(0x3, HOST_CTRL_IO(io_base));\n}\n\n \nstatic inline int host_read_unsafe(unsigned io_base)\n{\n\tint data = -1;\n\tif ((inb(HOST_CTRL_IO(io_base)) & RX_READY) != 0)\n\t\tdata = inb(HOST_DATA_IO(io_base));\n\n\treturn data;\n}\n\n \nstatic int host_read_ctrl_unsafe(unsigned io_base, unsigned timeout)\n{\n\tint data;\n\n\twhile (((data = host_read_unsafe(io_base)) < 0) && (timeout != 0)) {\n\t\tudelay(100);\n\t\t--timeout;\n\t}  \n\n\treturn data;\n}\n\n \nstatic inline int host_write_unsafe(unsigned io_base, unsigned char data)\n{\n\tif ((inb(HOST_CTRL_IO(io_base)) & TX_READY) != 0) {\n\t\toutb(data, HOST_DATA_IO(io_base));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,\n\t\t\t\t  unsigned timeout)\n{\n\tint err;\n\n\twhile (!(err = host_write_unsafe(io_base, data)) && (timeout != 0)) {\n\t\tudelay(100);\n\t\t--timeout;\n\t}  \n\n\treturn err;\n}\n\n\n \nstatic inline int verify_mpu401(const struct snd_mpu401 *mpu)\n{\n\treturn ((inb(MPU401C(mpu)) & 0xc0) == 0x80);\n}\n\n \nstatic inline void initialise_mpu401(const struct snd_mpu401 *mpu)\n{\n\toutb(0, MPU401D(mpu));\n}\n\n \nstatic void activate_ad1845_unsafe(unsigned io_base)\n{\n\tunsigned char val = sscape_read_unsafe(io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(io_base, GA_HMCTL_REG, (val & 0xcf) | 0x10);\n\tsscape_write_unsafe(io_base, GA_CDCFG_REG, 0x80);\n}\n\n \nstatic void sscape_start_dma_unsafe(unsigned io_base, enum GA_REG reg)\n{\n\tsscape_write_unsafe(io_base, reg,\n\t\t\t    sscape_read_unsafe(io_base, reg) | 0x01);\n\tsscape_write_unsafe(io_base, reg,\n\t\t\t    sscape_read_unsafe(io_base, reg) & 0xfe);\n}\n\n \nstatic int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg,\n\t\t\t\t  unsigned timeout)\n{\n\twhile (!(sscape_read_unsafe(io_base, reg) & 0x01) && (timeout != 0)) {\n\t\tudelay(100);\n\t\t--timeout;\n\t}  \n\n\treturn sscape_read_unsafe(io_base, reg) & 0x01;\n}\n\n \nstatic int obp_startup_ack(struct soundscape *s, unsigned timeout)\n{\n\tunsigned long end_time = jiffies + msecs_to_jiffies(timeout);\n\n\tdo {\n\t\tunsigned long flags;\n\t\tint x;\n\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\tx = host_read_unsafe(s->io_base);\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\tif (x == 0xfe || x == 0xff)\n\t\t\treturn 1;\n\n\t\tmsleep(10);\n\t} while (time_before(jiffies, end_time));\n\n\treturn 0;\n}\n\n \nstatic int host_startup_ack(struct soundscape *s, unsigned timeout)\n{\n\tunsigned long end_time = jiffies + msecs_to_jiffies(timeout);\n\n\tdo {\n\t\tunsigned long flags;\n\t\tint x;\n\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\tx = host_read_unsafe(s->io_base);\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\tif (x == 0xfe)\n\t\t\treturn 1;\n\n\t\tmsleep(10);\n\t} while (time_before(jiffies, end_time));\n\n\treturn 0;\n}\n\n \nstatic int upload_dma_data(struct soundscape *s, const unsigned char *data,\n\t\t\t   size_t size)\n{\n\tunsigned long flags;\n\tstruct snd_dma_buffer dma;\n\tint ret;\n\tunsigned char val;\n\n\tif (!get_dmabuf(s, &dma, PAGE_ALIGN(32 * 1024)))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\t \n\tval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val & 0x3f);\n\n\t \n\tval = (s->chip->dma1 << 4) | DMA_8BIT;\n\tsscape_write_unsafe(s->io_base, GA_DMAA_REG, val);\n\tsscape_write_unsafe(s->io_base, GA_DMAB_REG, 0x20);\n\n\t \n\tval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x80);\n\n\t \n\twhile (size != 0) {\n\t\tunsigned long len;\n\n\t\tlen = min(size, dma.bytes);\n\t\tmemcpy(dma.area, data, len);\n\t\tdata += len;\n\t\tsize -= len;\n\n\t\tsnd_dma_program(s->chip->dma1, dma.addr, len, DMA_MODE_WRITE);\n\t\tsscape_start_dma_unsafe(s->io_base, GA_DMAA_REG);\n\t\tif (!sscape_wait_dma_unsafe(s->io_base, GA_DMAA_REG, 5000)) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&s->lock, flags);\n\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t\t\"sscape: DMA upload has timed out\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tgoto _release_dma;\n\t\t}\n\t}  \n\n\tset_host_mode_unsafe(s->io_base);\n\toutb(0x0, s->io_base);\n\n\t \n\tval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x40);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\t \n\tret = 0;\n\tif (!obp_startup_ack(s, 5000)) {\n\t\tsnd_printk(KERN_ERR \"sscape: No response \"\n\t\t\t\t    \"from on-board processor after upload\\n\");\n\t\tret = -EAGAIN;\n\t} else if (!host_startup_ack(s, 5000)) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t\t\"sscape: SoundScape failed to initialise\\n\");\n\t\tret = -EAGAIN;\n\t}\n\n_release_dma:\n\t \n\tsscape_write(s, GA_DMAA_REG, (s->ic_type == IC_OPUS ? 0x40 : 0x70));\n\tfree_dmabuf(&dma);\n\n\treturn ret;\n}\n\n \nstatic int sscape_upload_bootblock(struct snd_card *card)\n{\n\tstruct soundscape *sscape = get_card_soundscape(card);\n\tunsigned long flags;\n\tconst struct firmware *init_fw = NULL;\n\tint data = 0;\n\tint ret;\n\n\tret = request_firmware(&init_fw, \"scope.cod\", card->dev);\n\tif (ret < 0) {\n\t\tsnd_printk(KERN_ERR \"sscape: Error loading scope.cod\");\n\t\treturn ret;\n\t}\n\tret = upload_dma_data(sscape, init_fw->data, init_fw->size);\n\n\trelease_firmware(init_fw);\n\n\tspin_lock_irqsave(&sscape->lock, flags);\n\tif (ret == 0)\n\t\tdata = host_read_ctrl_unsafe(sscape->io_base, 100);\n\n\tif (data & 0x10)\n\t\tsscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2f);\n\n\tspin_unlock_irqrestore(&sscape->lock, flags);\n\n\tdata &= 0xf;\n\tif (ret == 0 && data > 7) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t\t\"sscape: timeout reading firmware version\\n\");\n\t\tret = -EAGAIN;\n\t}\n\n\treturn (ret == 0) ? data : ret;\n}\n\n \nstatic int sscape_upload_microcode(struct snd_card *card, int version)\n{\n\tstruct soundscape *sscape = get_card_soundscape(card);\n\tconst struct firmware *init_fw = NULL;\n\tchar name[14];\n\tint err;\n\n\tscnprintf(name, sizeof(name), \"sndscape.co%d\", version);\n\n\terr = request_firmware(&init_fw, name, card->dev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"sscape: Error loading sndscape.co%d\",\n\t\t\t\tversion);\n\t\treturn err;\n\t}\n\terr = upload_dma_data(sscape, init_fw->data, init_fw->size);\n\tif (err == 0)\n\t\tsnd_printk(KERN_INFO \"sscape: MIDI firmware loaded %zu KBs\\n\",\n\t\t\t\tinit_fw->size >> 10);\n\n\trelease_firmware(init_fw);\n\n\treturn err;\n}\n\n \nstatic int sscape_midi_info(struct snd_kcontrol *ctl,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int sscape_midi_get(struct snd_kcontrol *kctl,\n\t\t\t   struct snd_ctl_elem_value *uctl)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kctl);\n\tstruct snd_card *card = chip->card;\n\tregister struct soundscape *s = get_card_soundscape(card);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\tuctl->value.integer.value[0] = s->midi_vol;\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn 0;\n}\n\nstatic int sscape_midi_put(struct snd_kcontrol *kctl,\n\t\t\t   struct snd_ctl_elem_value *uctl)\n{\n\tstruct snd_wss *chip = snd_kcontrol_chip(kctl);\n\tstruct snd_card *card = chip->card;\n\tstruct soundscape *s = get_card_soundscape(card);\n\tunsigned long flags;\n\tint change;\n\tunsigned char new_val;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\tnew_val = uctl->value.integer.value[0] & 127;\n\t \n\tset_host_mode_unsafe(s->io_base);\n\n\t \n\tif (s->midi_vol == new_val) {\n\t\tchange = 0;\n\t\tgoto __skip_change;\n\t}\n\tchange = host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)\n\t\t && host_write_ctrl_unsafe(s->io_base, new_val, 100)\n\t\t && host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100)\n\t\t && host_write_ctrl_unsafe(s->io_base, new_val, 100);\n\ts->midi_vol = new_val;\n__skip_change:\n\n\t \n\tset_midi_mode_unsafe(s->io_base);\n\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new midi_mixer_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"MIDI\",\n\t.info = sscape_midi_info,\n\t.get = sscape_midi_get,\n\t.put = sscape_midi_put\n};\n\n \nstatic unsigned get_irq_config(int sscape_type, int irq)\n{\n\tstatic const int valid_irq[] = { 9, 5, 7, 10 };\n\tstatic const int old_irq[] = { 9, 7, 5, 15 };\n\tunsigned cfg;\n\n\tif (sscape_type == MEDIA_FX) {\n\t\tfor (cfg = 0; cfg < ARRAY_SIZE(old_irq); ++cfg)\n\t\t\tif (irq == old_irq[cfg])\n\t\t\t\treturn cfg;\n\t} else {\n\t\tfor (cfg = 0; cfg < ARRAY_SIZE(valid_irq); ++cfg)\n\t\t\tif (irq == valid_irq[cfg])\n\t\t\t\treturn cfg;\n\t}\n\n\treturn INVALID_IRQ;\n}\n\n \nstatic int detect_sscape(struct soundscape *s, long wss_io)\n{\n\tunsigned long flags;\n\tunsigned d;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\n\t \n\tif ((inb(HOST_CTRL_IO(s->io_base)) & 0x78) != 0)\n\t\tgoto _done;\n\n\td = inb(ODIE_ADDR_IO(s->io_base)) & 0xf0;\n\tif ((d & 0x80) != 0)\n\t\tgoto _done;\n\n\tif (d == 0)\n\t\ts->ic_type = IC_ODIE;\n\telse if ((d & 0x60) != 0)\n\t\ts->ic_type = IC_OPUS;\n\telse\n\t\tgoto _done;\n\n\toutb(0xfa, ODIE_ADDR_IO(s->io_base));\n\tif ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0a)\n\t\tgoto _done;\n\n\toutb(0xfe, ODIE_ADDR_IO(s->io_base));\n\tif ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0e)\n\t\tgoto _done;\n\n\toutb(0xfe, ODIE_ADDR_IO(s->io_base));\n\td = inb(ODIE_DATA_IO(s->io_base));\n\tif (s->type != SSCAPE_VIVO && (d & 0x9f) != 0x0e)\n\t\tgoto _done;\n\n\tif (s->ic_type == IC_OPUS)\n\t\tactivate_ad1845_unsafe(s->io_base);\n\n\tif (s->type == SSCAPE_VIVO)\n\t\twss_io += 4;\n\n\td  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);\n\n\t \n\tfor (d = 0; d < 500; d++) {\n\t\tif ((inb(wss_io) & 0x80) == 0)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\tmsleep(1);\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t}\n\n\tif ((inb(wss_io) & 0x80) != 0)\n\t\tgoto _done;\n\n\tif (inb(wss_io + 2) == 0xff)\n\t\tgoto _done;\n\n\td  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d);\n\n\tif ((inb(wss_io) & 0x80) != 0)\n\t\ts->type = MEDIA_FX;\n\n\td = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\n\tsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);\n\t \n\tfor (d = 0; d < 500; d++) {\n\t\tif ((inb(wss_io) & 0x80) == 0)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\tmsleep(1);\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t}\n\n\t \n\tretval = 1;\n\n_done:\n\tspin_unlock_irqrestore(&s->lock, flags);\n\treturn retval;\n}\n\n \nstatic int mpu401_open(struct snd_mpu401 *mpu)\n{\n\tif (!verify_mpu401(mpu)) {\n\t\tsnd_printk(KERN_ERR \"sscape: MIDI disabled, \"\n\t\t\t\t    \"please load firmware\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int create_mpu401(struct snd_card *card, int devnum,\n\t\t\t unsigned long port, int irq)\n{\n\tstruct soundscape *sscape = get_card_soundscape(card);\n\tstruct snd_rawmidi *rawmidi;\n\tint err;\n\n\terr = snd_mpu401_uart_new(card, devnum, MPU401_HW_MPU401, port,\n\t\t\t\t  MPU401_INFO_INTEGRATED, irq, &rawmidi);\n\tif (err == 0) {\n\t\tstruct snd_mpu401 *mpu = rawmidi->private_data;\n\t\tmpu->open_input = mpu401_open;\n\t\tmpu->open_output = mpu401_open;\n\t\tmpu->private_data = sscape;\n\n\t\tinitialise_mpu401(mpu);\n\t}\n\n\treturn err;\n}\n\n\n \nstatic int create_ad1845(struct snd_card *card, unsigned port,\n\t\t\t int irq, int dma1, int dma2)\n{\n\tregister struct soundscape *sscape = get_card_soundscape(card);\n\tstruct snd_wss *chip;\n\tint err;\n\tint codec_type = WSS_HW_DETECT;\n\n\tswitch (sscape->type) {\n\tcase MEDIA_FX:\n\tcase SSCAPE:\n\t\t \n\t\tif (sscape->ic_type != IC_OPUS)\n\t\t\tcodec_type = WSS_HW_AD1848;\n\t\tbreak;\n\n\tcase SSCAPE_VIVO:\n\t\tport += 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = snd_wss_create(card, port, -1, irq, dma1, dma2,\n\t\t\t     codec_type, WSS_HWSHARE_DMA1, &chip);\n\tif (!err) {\n\t\tunsigned long flags;\n\n\t\tif (sscape->type != SSCAPE_VIVO) {\n\t\t\t \n\t\t\tsnd_wss_mce_up(chip);\n\t\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\t\tsnd_wss_out(chip, AD1845_CLOCK, 0x20);\n\t\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\t\tsnd_wss_mce_down(chip);\n\n\t\t}\n\n\t\terr = snd_wss_pcm(chip, 0);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"sscape: No PCM device \"\n\t\t\t\t\t    \"for AD1845 chip\\n\");\n\t\t\tgoto _error;\n\t\t}\n\n\t\terr = snd_wss_mixer(chip);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"sscape: No mixer device \"\n\t\t\t\t\t    \"for AD1845 chip\\n\");\n\t\t\tgoto _error;\n\t\t}\n\t\tif (chip->hardware != WSS_HW_AD1848) {\n\t\t\terr = snd_wss_timer(chip, 0);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"sscape: No timer device \"\n\t\t\t\t\t\t    \"for AD1845 chip\\n\");\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tif (sscape->type != SSCAPE_VIVO) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\t  snd_ctl_new1(&midi_mixer_ctl, chip));\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"sscape: Could not create \"\n\t\t\t\t\t\t    \"MIDI mixer control\\n\");\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tsscape->chip = chip;\n\t}\n\n_error:\n\treturn err;\n}\n\n\n \nstatic int create_sscape(int dev, struct snd_card *card)\n{\n\tstruct soundscape *sscape = get_card_soundscape(card);\n\tunsigned dma_cfg;\n\tunsigned irq_cfg;\n\tunsigned mpu_irq_cfg;\n\tstruct resource *io_res;\n\tstruct resource *wss_res;\n\tunsigned long flags;\n\tint err;\n\tint val;\n\tconst char *name;\n\n\t \n\tio_res = devm_request_region(card->dev, port[dev], 8, \"SoundScape\");\n\tif (!io_res) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"sscape: can't grab port 0x%lx\\n\", port[dev]);\n\t\treturn -EBUSY;\n\t}\n\twss_res = NULL;\n\tif (sscape->type == SSCAPE_VIVO) {\n\t\twss_res = devm_request_region(card->dev, wss_port[dev], 4,\n\t\t\t\t\t      \"SoundScape\");\n\t\tif (!wss_res) {\n\t\t\tsnd_printk(KERN_ERR \"sscape: can't grab port 0x%lx\\n\",\n\t\t\t\t\t    wss_port[dev]);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\terr = snd_devm_request_dma(card->dev, dma[dev], \"SoundScape\");\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"sscape: can't grab DMA %d\\n\", dma[dev]);\n\t\treturn err;\n\t}\n\n\tspin_lock_init(&sscape->lock);\n\tsscape->io_res = io_res;\n\tsscape->wss_res = wss_res;\n\tsscape->io_base = port[dev];\n\n\tif (!detect_sscape(sscape, wss_port[dev])) {\n\t\tprintk(KERN_ERR \"sscape: hardware not detected at 0x%x\\n\",\n\t\t\tsscape->io_base);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (sscape->type) {\n\tcase MEDIA_FX:\n\t\tname = \"MediaFX/SoundFX\";\n\t\tbreak;\n\tcase SSCAPE:\n\t\tname = \"Soundscape\";\n\t\tbreak;\n\tcase SSCAPE_PNP:\n\t\tname = \"Soundscape PnP\";\n\t\tbreak;\n\tcase SSCAPE_VIVO:\n\t\tname = \"Soundscape VIVO\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"unknown Soundscape\";\n\t\tbreak;\n\t}\n\n\tprintk(KERN_INFO \"sscape: %s card detected at 0x%x, using IRQ %d, DMA %d\\n\",\n\t\t\t name, sscape->io_base, irq[dev], dma[dev]);\n\n\t \n\tirq_cfg = get_irq_config(sscape->type, irq[dev]);\n\tif (irq_cfg == INVALID_IRQ) {\n\t\tsnd_printk(KERN_ERR \"sscape: Invalid IRQ %d\\n\", irq[dev]);\n\t\treturn -ENXIO;\n\t}\n\n\tmpu_irq_cfg = get_irq_config(sscape->type, mpu_irq[dev]);\n\tif (mpu_irq_cfg == INVALID_IRQ) {\n\t\tsnd_printk(KERN_ERR \"sscape: Invalid IRQ %d\\n\", mpu_irq[dev]);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tspin_lock_irqsave(&sscape->lock, flags);\n\n\tsscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2e);\n\tsscape_write_unsafe(sscape->io_base, GA_SMCFGB_REG, 0x00);\n\n\t \n\tsscape_write_unsafe(sscape->io_base, GA_DMACFG_REG, 0x50);\n\tdma_cfg = (sscape->ic_type == IC_OPUS ? 0x40 : 0x70);\n\tsscape_write_unsafe(sscape->io_base, GA_DMAA_REG, dma_cfg);\n\tsscape_write_unsafe(sscape->io_base, GA_DMAB_REG, 0x20);\n\n\tmpu_irq_cfg |= mpu_irq_cfg << 2;\n\tval = sscape_read_unsafe(sscape->io_base, GA_HMCTL_REG) & 0xF7;\n\tif (joystick[dev])\n\t\tval |= 8;\n\tsscape_write_unsafe(sscape->io_base, GA_HMCTL_REG, val | 0x10);\n\tsscape_write_unsafe(sscape->io_base, GA_INTCFG_REG, 0xf0 | mpu_irq_cfg);\n\tsscape_write_unsafe(sscape->io_base,\n\t\t\t    GA_CDCFG_REG, 0x09 | DMA_8BIT\n\t\t\t    | (dma[dev] << 4) | (irq_cfg << 1));\n\t \n\tsscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x80);\n\n\tspin_unlock_irqrestore(&sscape->lock, flags);\n\n\t \n\terr = create_ad1845(card, wss_port[dev], irq[dev],\n\t\t\t    dma[dev], dma2[dev]);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t\t\"sscape: No AD1845 device at 0x%lx, IRQ %d\\n\",\n\t\t\t\twss_port[dev], irq[dev]);\n\t\treturn err;\n\t}\n\tstrcpy(card->driver, \"SoundScape\");\n\tstrcpy(card->shortname, name);\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\\n\",\n\t\t name, sscape->chip->port, sscape->chip->irq,\n\t\t sscape->chip->dma1, sscape->chip->dma2);\n\n#define MIDI_DEVNUM  0\n\tif (sscape->type != SSCAPE_VIVO) {\n\t\terr = sscape_upload_bootblock(card);\n\t\tif (err >= 0)\n\t\t\terr = sscape_upload_microcode(card, err);\n\n\t\tif (err == 0) {\n\t\t\terr = create_mpu401(card, MIDI_DEVNUM, port[dev],\n\t\t\t\t\t    mpu_irq[dev]);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"sscape: Failed to create \"\n\t\t\t\t\t\t\"MPU-401 device at 0x%lx\\n\",\n\t\t\t\t\t\tport[dev]);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&sscape->lock, flags);\n\t\t\tsscape->midi_vol = 0;\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\tCMD_SET_MIDI_VOL, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\tsscape->midi_vol, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\tCMD_XXX_MIDI_VOL, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\tsscape->midi_vol, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\tCMD_SET_EXTMIDI, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base,\n\t\t\t\t\t\t0, 100);\n\t\t\thost_write_ctrl_unsafe(sscape->io_base, CMD_ACK, 100);\n\n\t\t\tset_midi_mode_unsafe(sscape->io_base);\n\t\t\tspin_unlock_irqrestore(&sscape->lock, flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int snd_sscape_match(struct device *pdev, unsigned int i)\n{\n\t \n\tif (port[i] == SNDRV_AUTO_PORT)\n\t\treturn 0;\n\n\tif (irq[i] == SNDRV_AUTO_IRQ ||\n\t    mpu_irq[i] == SNDRV_AUTO_IRQ ||\n\t    dma[i] == SNDRV_AUTO_DMA) {\n\t\tprintk(KERN_INFO\n\t\t       \"sscape: insufficient parameters, \"\n\t\t       \"need IO, IRQ, MPU-IRQ and DMA\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int snd_sscape_probe(struct device *pdev, unsigned int dev)\n{\n\tstruct snd_card *card;\n\tstruct soundscape *sscape;\n\tint ret;\n\n\tret = snd_devm_card_new(pdev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct soundscape), &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsscape = get_card_soundscape(card);\n\tsscape->type = SSCAPE;\n\n\tdma[dev] &= 0x03;\n\n\tret = create_sscape(dev, card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_card_register(card);\n\tif (ret < 0) {\n\t\tsnd_printk(KERN_ERR \"sscape: Failed to register sound card\\n\");\n\t\treturn ret;\n\t}\n\tdev_set_drvdata(pdev, card);\n\treturn 0;\n}\n\n#define DEV_NAME \"sscape\"\n\nstatic struct isa_driver snd_sscape_driver = {\n\t.match\t\t= snd_sscape_match,\n\t.probe\t\t= snd_sscape_probe,\n\t \n\t.driver\t\t= {\n\t\t.name\t= DEV_NAME\n\t},\n};\n\n#ifdef CONFIG_PNP\nstatic inline int get_next_autoindex(int i)\n{\n\twhile (i < SNDRV_CARDS && port[i] != SNDRV_AUTO_PORT)\n\t\t++i;\n\treturn i;\n}\n\n\nstatic int sscape_pnp_detect(struct pnp_card_link *pcard,\n\t\t\t     const struct pnp_card_device_id *pid)\n{\n\tstatic int idx = 0;\n\tstruct pnp_dev *dev;\n\tstruct snd_card *card;\n\tstruct soundscape *sscape;\n\tint ret;\n\n\t \n\tidx = get_next_autoindex(idx);\n\tif (idx >= SNDRV_CARDS)\n\t\treturn -ENOSPC;\n\n\t \n\tdev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!pnp_is_active(dev)) {\n\t\tif (pnp_activate_dev(dev) < 0) {\n\t\t\tsnd_printk(KERN_INFO \"sscape: device is inactive\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tret = snd_devm_card_new(&pcard->card->dev,\n\t\t\t\tindex[idx], id[idx], THIS_MODULE,\n\t\t\t\tsizeof(struct soundscape), &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsscape = get_card_soundscape(card);\n\n\t \n\tif (!strncmp(\"ENS4081\", pid->id, 7))\n\t\tsscape->type = SSCAPE_VIVO;\n\telse\n\t\tsscape->type = SSCAPE_PNP;\n\n\t \n\tport[idx] = pnp_port_start(dev, 0);\n\tirq[idx] = pnp_irq(dev, 0);\n\tmpu_irq[idx] = pnp_irq(dev, 1);\n\tdma[idx] = pnp_dma(dev, 0) & 0x03;\n\tif (sscape->type == SSCAPE_PNP) {\n\t\tdma2[idx] = dma[idx];\n\t\twss_port[idx] = CODEC_IO(port[idx]);\n\t} else {\n\t\twss_port[idx] = pnp_port_start(dev, 1);\n\t\tdma2[idx] = pnp_dma(dev, 1);\n\t}\n\n\tret = create_sscape(idx, card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_card_register(card);\n\tif (ret < 0) {\n\t\tsnd_printk(KERN_ERR \"sscape: Failed to register sound card\\n\");\n\t\treturn ret;\n\t}\n\n\tpnp_set_card_drvdata(pcard, card);\n\t++idx;\n\treturn 0;\n}\n\nstatic struct pnp_card_driver sscape_pnpc_driver = {\n\t.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.name = \"sscape\",\n\t.id_table = sscape_pnpids,\n\t.probe = sscape_pnp_detect,\n};\n\n#endif  \n\nstatic int __init sscape_init(void)\n{\n\tint err;\n\n\terr = isa_register_driver(&snd_sscape_driver, SNDRV_CARDS);\n#ifdef CONFIG_PNP\n\tif (!err)\n\t\tisa_registered = 1;\n\n\terr = pnp_register_card_driver(&sscape_pnpc_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (isa_registered)\n\t\terr = 0;\n#endif\n\treturn err;\n}\n\nstatic void __exit sscape_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_card_driver(&sscape_pnpc_driver);\n\tif (isa_registered)\n#endif\n\t\tisa_unregister_driver(&snd_sscape_driver);\n}\n\nmodule_init(sscape_init);\nmodule_exit(sscape_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}