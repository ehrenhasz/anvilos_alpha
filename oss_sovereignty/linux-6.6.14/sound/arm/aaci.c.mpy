{
  "module_name": "aaci.c",
  "hash_id": "aa2b633041eb65e6538b933e8e7b078a561725637c065e892d536a7a9cbf52e7",
  "original_prompt": "Ingested from linux-6.6.14/sound/arm/aaci.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/amba/bus.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/ac97_codec.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"aaci.h\"\n\n#define DRIVER_NAME\t\"aaci-pl041\"\n\n#define FRAME_PERIOD_US\t21\n\n \n#undef CONFIG_PM\n\nstatic void aaci_ac97_select_codec(struct aaci *aaci, struct snd_ac97 *ac97)\n{\n\tu32 v, maincr = aaci->maincr | MAINCR_SCRA(ac97->num);\n\n\t \n\tv = readl(aaci->base + AACI_SLFR);\n\tif (v & SLFR_2RXV)\n\t\treadl(aaci->base + AACI_SL2RX);\n\tif (v & SLFR_1RXV)\n\t\treadl(aaci->base + AACI_SL1RX);\n\n\tif (maincr != readl(aaci->base + AACI_MAINCR)) {\n\t\twritel(maincr, aaci->base + AACI_MAINCR);\n\t\treadl(aaci->base + AACI_MAINCR);\n\t\tudelay(1);\n\t}\n}\n\n \nstatic void aaci_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t    unsigned short val)\n{\n\tstruct aaci *aaci = ac97->private_data;\n\tint timeout;\n\tu32 v;\n\n\tif (ac97->num >= 4)\n\t\treturn;\n\n\tmutex_lock(&aaci->ac97_sem);\n\n\taaci_ac97_select_codec(aaci, ac97);\n\n\t \n\twritel(val << 4, aaci->base + AACI_SL2TX);\n\twritel(reg << 12, aaci->base + AACI_SL1TX);\n\n\t \n\tudelay(FRAME_PERIOD_US);\n\n\t \n\ttimeout = FRAME_PERIOD_US * 8;\n\tdo {\n\t\tudelay(1);\n\t\tv = readl(aaci->base + AACI_SLFR);\n\t} while ((v & (SLFR_1TXB|SLFR_2TXB)) && --timeout);\n\n\tif (v & (SLFR_1TXB|SLFR_2TXB))\n\t\tdev_err(&aaci->dev->dev,\n\t\t\t\"timeout waiting for write to complete\\n\");\n\n\tmutex_unlock(&aaci->ac97_sem);\n}\n\n \nstatic unsigned short aaci_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct aaci *aaci = ac97->private_data;\n\tint timeout, retries = 10;\n\tu32 v;\n\n\tif (ac97->num >= 4)\n\t\treturn ~0;\n\n\tmutex_lock(&aaci->ac97_sem);\n\n\taaci_ac97_select_codec(aaci, ac97);\n\n\t \n\twritel((reg << 12) | (1 << 19), aaci->base + AACI_SL1TX);\n\n\t \n\tudelay(FRAME_PERIOD_US);\n\n\t \n\ttimeout = FRAME_PERIOD_US * 8;\n\tdo {\n\t\tudelay(1);\n\t\tv = readl(aaci->base + AACI_SLFR);\n\t} while ((v & SLFR_1TXB) && --timeout);\n\n\tif (v & SLFR_1TXB) {\n\t\tdev_err(&aaci->dev->dev, \"timeout on slot 1 TX busy\\n\");\n\t\tv = ~0;\n\t\tgoto out;\n\t}\n\n\t \n\tudelay(FRAME_PERIOD_US);\n\n\t \n\ttimeout = FRAME_PERIOD_US * 8;\n\tdo {\n\t\tudelay(1);\n\t\tcond_resched();\n\t\tv = readl(aaci->base + AACI_SLFR) & (SLFR_1RXV|SLFR_2RXV);\n\t} while ((v != (SLFR_1RXV|SLFR_2RXV)) && --timeout);\n\n\tif (v != (SLFR_1RXV|SLFR_2RXV)) {\n\t\tdev_err(&aaci->dev->dev, \"timeout on RX valid\\n\");\n\t\tv = ~0;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tv = readl(aaci->base + AACI_SL1RX) >> 12;\n\t\tif (v == reg) {\n\t\t\tv = readl(aaci->base + AACI_SL2RX) >> 4;\n\t\t\tbreak;\n\t\t} else if (--retries) {\n\t\t\tdev_warn(&aaci->dev->dev,\n\t\t\t\t \"ac97 read back fail.  retry\\n\");\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdev_warn(&aaci->dev->dev,\n\t\t\t\t\"wrong ac97 register read back (%x != %x)\\n\",\n\t\t\t\tv, reg);\n\t\t\tv = ~0;\n\t\t}\n\t} while (retries);\n out:\n\tmutex_unlock(&aaci->ac97_sem);\n\treturn v;\n}\n\nstatic inline void\naaci_chan_wait_ready(struct aaci_runtime *aacirun, unsigned long mask)\n{\n\tu32 val;\n\tint timeout = 5000;\n\n\tdo {\n\t\tudelay(1);\n\t\tval = readl(aacirun->base + AACI_SR);\n\t} while (val & mask && timeout--);\n}\n\n\n\n \nstatic void aaci_fifo_irq(struct aaci *aaci, int channel, u32 mask)\n{\n\tif (mask & ISR_ORINTR) {\n\t\tdev_warn(&aaci->dev->dev, \"RX overrun on chan %d\\n\", channel);\n\t\twritel(ICLR_RXOEC1 << channel, aaci->base + AACI_INTCLR);\n\t}\n\n\tif (mask & ISR_RXTOINTR) {\n\t\tdev_warn(&aaci->dev->dev, \"RX timeout on chan %d\\n\", channel);\n\t\twritel(ICLR_RXTOFEC1 << channel, aaci->base + AACI_INTCLR);\n\t}\n\n\tif (mask & ISR_RXINTR) {\n\t\tstruct aaci_runtime *aacirun = &aaci->capture;\n\t\tbool period_elapsed = false;\n\t\tvoid *ptr;\n\n\t\tif (!aacirun->substream || !aacirun->start) {\n\t\t\tdev_warn(&aaci->dev->dev, \"RX interrupt???\\n\");\n\t\t\twritel(0, aacirun->base + AACI_IE);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&aacirun->lock);\n\n\t\tptr = aacirun->ptr;\n\t\tdo {\n\t\t\tunsigned int len = aacirun->fifo_bytes;\n\t\t\tu32 val;\n\n\t\t\tif (aacirun->bytes <= 0) {\n\t\t\t\taacirun->bytes += aacirun->period;\n\t\t\t\tperiod_elapsed = true;\n\t\t\t}\n\t\t\tif (!(aacirun->cr & CR_EN))\n\t\t\t\tbreak;\n\n\t\t\tval = readl(aacirun->base + AACI_SR);\n\t\t\tif (!(val & SR_RXHF))\n\t\t\t\tbreak;\n\t\t\tif (!(val & SR_RXFF))\n\t\t\t\tlen >>= 1;\n\n\t\t\taacirun->bytes -= len;\n\n\t\t\t \n\t\t\tfor( ; len > 0; len -= 16) {\n\t\t\t\tasm(\n\t\t\t\t\t\"ldmia\t%1, {r0, r1, r2, r3}\\n\\t\"\n\t\t\t\t\t\"stmia\t%0!, {r0, r1, r2, r3}\"\n\t\t\t\t\t: \"+r\" (ptr)\n\t\t\t\t\t: \"r\" (aacirun->fifo)\n\t\t\t\t\t: \"r0\", \"r1\", \"r2\", \"r3\", \"cc\");\n\n\t\t\t\tif (ptr >= aacirun->end)\n\t\t\t\t\tptr = aacirun->start;\n\t\t\t}\n\t\t} while(1);\n\n\t\taacirun->ptr = ptr;\n\n\t\tspin_unlock(&aacirun->lock);\n\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(aacirun->substream);\n\t}\n\n\tif (mask & ISR_URINTR) {\n\t\tdev_dbg(&aaci->dev->dev, \"TX underrun on chan %d\\n\", channel);\n\t\twritel(ICLR_TXUEC1 << channel, aaci->base + AACI_INTCLR);\n\t}\n\n\tif (mask & ISR_TXINTR) {\n\t\tstruct aaci_runtime *aacirun = &aaci->playback;\n\t\tbool period_elapsed = false;\n\t\tvoid *ptr;\n\n\t\tif (!aacirun->substream || !aacirun->start) {\n\t\t\tdev_warn(&aaci->dev->dev, \"TX interrupt???\\n\");\n\t\t\twritel(0, aacirun->base + AACI_IE);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock(&aacirun->lock);\n\n\t\tptr = aacirun->ptr;\n\t\tdo {\n\t\t\tunsigned int len = aacirun->fifo_bytes;\n\t\t\tu32 val;\n\n\t\t\tif (aacirun->bytes <= 0) {\n\t\t\t\taacirun->bytes += aacirun->period;\n\t\t\t\tperiod_elapsed = true;\n\t\t\t}\n\t\t\tif (!(aacirun->cr & CR_EN))\n\t\t\t\tbreak;\n\n\t\t\tval = readl(aacirun->base + AACI_SR);\n\t\t\tif (!(val & SR_TXHE))\n\t\t\t\tbreak;\n\t\t\tif (!(val & SR_TXFE))\n\t\t\t\tlen >>= 1;\n\n\t\t\taacirun->bytes -= len;\n\n\t\t\t \n\t\t\tfor ( ; len > 0; len -= 16) {\n\t\t\t\tasm(\n\t\t\t\t\t\"ldmia\t%0!, {r0, r1, r2, r3}\\n\\t\"\n\t\t\t\t\t\"stmia\t%1, {r0, r1, r2, r3}\"\n\t\t\t\t\t: \"+r\" (ptr)\n\t\t\t\t\t: \"r\" (aacirun->fifo)\n\t\t\t\t\t: \"r0\", \"r1\", \"r2\", \"r3\", \"cc\");\n\n\t\t\t\tif (ptr >= aacirun->end)\n\t\t\t\t\tptr = aacirun->start;\n\t\t\t}\n\t\t} while (1);\n\n\t\taacirun->ptr = ptr;\n\n\t\tspin_unlock(&aacirun->lock);\n\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(aacirun->substream);\n\t}\n}\n\nstatic irqreturn_t aaci_irq(int irq, void *devid)\n{\n\tstruct aaci *aaci = devid;\n\tu32 mask;\n\tint i;\n\n\tmask = readl(aaci->base + AACI_ALLINTS);\n\tif (mask) {\n\t\tu32 m = mask;\n\t\tfor (i = 0; i < 4; i++, m >>= 7) {\n\t\t\tif (m & 0x7f) {\n\t\t\t\taaci_fifo_irq(aaci, i, m);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mask ? IRQ_HANDLED : IRQ_NONE;\n}\n\n\n\n \nstatic const struct snd_pcm_hardware aaci_hw_info = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t  SNDRV_PCM_INFO_RESUME,\n\n\t \n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE,\n\n\t \n\t.channels_min\t\t= 2,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 64 * 1024,\n\t.period_bytes_min\t= 256,\n\t.period_bytes_max\t= PAGE_SIZE,\n\t.periods_min\t\t= 4,\n\t.periods_max\t\t= PAGE_SIZE / 16,\n};\n\n \nstatic int aaci_rule_channels(struct snd_pcm_hw_params *p,\n\tstruct snd_pcm_hw_rule *rule)\n{\n\tstatic const unsigned int channel_list[] = { 2, 4, 6 };\n\tstruct aaci *aaci = rule->private;\n\tunsigned int mask = 1 << 0, slots;\n\n\t \n\tslots = aaci->ac97_bus->pcms[0].r[0].slots;\n\tif (slots & (1 << AC97_SLOT_PCM_SLEFT)) {\n\t\tmask |= 1 << 1;\n\t\tif (slots & (1 << AC97_SLOT_LFE))\n\t\t\tmask |= 1 << 2;\n\t}\n\n\treturn snd_interval_list(hw_param_interval(p, rule->var),\n\t\t\t\t ARRAY_SIZE(channel_list), channel_list, mask);\n}\n\nstatic int aaci_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct aaci *aaci = substream->private_data;\n\tstruct aaci_runtime *aacirun;\n\tint ret = 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\taacirun = &aaci->playback;\n\t} else {\n\t\taacirun = &aaci->capture;\n\t}\n\n\taacirun->substream = substream;\n\truntime->private_data = aacirun;\n\truntime->hw = aaci_hw_info;\n\truntime->hw.rates = aacirun->pcm->rates;\n\tsnd_pcm_limit_hw_rates(runtime);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\truntime->hw.channels_max = 6;\n\n\t\t \n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t  aaci_rule_channels, aaci,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (aacirun->pcm->r[1].slots)\n\t\t\tsnd_ac97_pcm_double_rate_rules(runtime);\n\t}\n\n\t \n\truntime->hw.fifo_size = aaci->fifo_depth * 2;\n\n\tmutex_lock(&aaci->irq_lock);\n\tif (!aaci->users++) {\n\t\tret = request_irq(aaci->dev->irq[0], aaci_irq,\n\t\t\t   IRQF_SHARED, DRIVER_NAME, aaci);\n\t\tif (ret != 0)\n\t\t\taaci->users--;\n\t}\n\tmutex_unlock(&aaci->irq_lock);\n\n\treturn ret;\n}\n\n\n \nstatic int aaci_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct aaci *aaci = substream->private_data;\n\tstruct aaci_runtime *aacirun = substream->runtime->private_data;\n\n\tWARN_ON(aacirun->cr & CR_EN);\n\n\taacirun->substream = NULL;\n\n\tmutex_lock(&aaci->irq_lock);\n\tif (!--aaci->users)\n\t\tfree_irq(aaci->dev->irq[0], aaci);\n\tmutex_unlock(&aaci->irq_lock);\n\n\treturn 0;\n}\n\nstatic int aaci_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct aaci_runtime *aacirun = substream->runtime->private_data;\n\n\t \n\tWARN_ON(aacirun->cr & CR_EN);\n\n\tif (aacirun->pcm_open)\n\t\tsnd_ac97_pcm_close(aacirun->pcm);\n\taacirun->pcm_open = 0;\n\n\treturn 0;\n}\n\n \nstatic const u32 channels_to_slotmask[] = {\n\t[2] = CR_SL3 | CR_SL4,\n\t[4] = CR_SL3 | CR_SL4 | CR_SL7 | CR_SL8,\n\t[6] = CR_SL3 | CR_SL4 | CR_SL7 | CR_SL8 | CR_SL6 | CR_SL9,\n};\n\nstatic int aaci_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct aaci_runtime *aacirun = substream->runtime->private_data;\n\tstruct aaci *aaci = substream->private_data;\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tint dbl = rate > 48000;\n\tint err;\n\n\taaci_pcm_hw_free(substream);\n\tif (aacirun->pcm_open) {\n\t\tsnd_ac97_pcm_close(aacirun->pcm);\n\t\taacirun->pcm_open = 0;\n\t}\n\n\t \n\tif (dbl && channels != 2)\n\t\treturn -EINVAL;\n\n\terr = snd_ac97_pcm_open(aacirun->pcm, rate, channels,\n\t\t\t\taacirun->pcm->r[dbl].slots);\n\n\taacirun->pcm_open = err == 0;\n\taacirun->cr = CR_FEN | CR_COMPACT | CR_SZ16;\n\taacirun->cr |= channels_to_slotmask[channels + dbl * 2];\n\n\t \n\taacirun->fifo_bytes = aaci->fifo_depth * 4 / 2;\n\n\treturn err;\n}\n\nstatic int aaci_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct aaci_runtime *aacirun = runtime->private_data;\n\n\taacirun->period\t= snd_pcm_lib_period_bytes(substream);\n\taacirun->start\t= runtime->dma_area;\n\taacirun->end\t= aacirun->start + snd_pcm_lib_buffer_bytes(substream);\n\taacirun->ptr\t= aacirun->start;\n\taacirun->bytes\t= aacirun->period;\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t aaci_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct aaci_runtime *aacirun = runtime->private_data;\n\tssize_t bytes = aacirun->ptr - aacirun->start;\n\n\treturn bytes_to_frames(runtime, bytes);\n}\n\n\n \nstatic void aaci_pcm_playback_stop(struct aaci_runtime *aacirun)\n{\n\tu32 ie;\n\n\tie = readl(aacirun->base + AACI_IE);\n\tie &= ~(IE_URIE|IE_TXIE);\n\twritel(ie, aacirun->base + AACI_IE);\n\taacirun->cr &= ~CR_EN;\n\taaci_chan_wait_ready(aacirun, SR_TXB);\n\twritel(aacirun->cr, aacirun->base + AACI_TXCR);\n}\n\nstatic void aaci_pcm_playback_start(struct aaci_runtime *aacirun)\n{\n\tu32 ie;\n\n\taaci_chan_wait_ready(aacirun, SR_TXB);\n\taacirun->cr |= CR_EN;\n\n\tie = readl(aacirun->base + AACI_IE);\n\tie |= IE_URIE | IE_TXIE;\n\twritel(ie, aacirun->base + AACI_IE);\n\twritel(aacirun->cr, aacirun->base + AACI_TXCR);\n}\n\nstatic int aaci_pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct aaci_runtime *aacirun = substream->runtime->private_data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&aacirun->lock, flags);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\taaci_pcm_playback_start(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\taaci_pcm_playback_start(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\taaci_pcm_playback_stop(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\taaci_pcm_playback_stop(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock_irqrestore(&aacirun->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct snd_pcm_ops aaci_playback_ops = {\n\t.open\t\t= aaci_pcm_open,\n\t.close\t\t= aaci_pcm_close,\n\t.hw_params\t= aaci_pcm_hw_params,\n\t.hw_free\t= aaci_pcm_hw_free,\n\t.prepare\t= aaci_pcm_prepare,\n\t.trigger\t= aaci_pcm_playback_trigger,\n\t.pointer\t= aaci_pcm_pointer,\n};\n\nstatic void aaci_pcm_capture_stop(struct aaci_runtime *aacirun)\n{\n\tu32 ie;\n\n\taaci_chan_wait_ready(aacirun, SR_RXB);\n\n\tie = readl(aacirun->base + AACI_IE);\n\tie &= ~(IE_ORIE | IE_RXIE);\n\twritel(ie, aacirun->base+AACI_IE);\n\n\taacirun->cr &= ~CR_EN;\n\n\twritel(aacirun->cr, aacirun->base + AACI_RXCR);\n}\n\nstatic void aaci_pcm_capture_start(struct aaci_runtime *aacirun)\n{\n\tu32 ie;\n\n\taaci_chan_wait_ready(aacirun, SR_RXB);\n\n#ifdef DEBUG\n\t \n\taacirun->cr |= 0xf << 17;\n#endif\n\n\taacirun->cr |= CR_EN;\n\twritel(aacirun->cr, aacirun->base + AACI_RXCR);\n\n\tie = readl(aacirun->base + AACI_IE);\n\tie |= IE_ORIE |IE_RXIE;  \n\twritel(ie, aacirun->base + AACI_IE);\n}\n\nstatic int aaci_pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct aaci_runtime *aacirun = substream->runtime->private_data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&aacirun->lock, flags);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\taaci_pcm_capture_start(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\taaci_pcm_capture_start(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\taaci_pcm_capture_stop(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\taaci_pcm_capture_stop(aacirun);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock_irqrestore(&aacirun->lock, flags);\n\n\treturn ret;\n}\n\nstatic int aaci_pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct aaci *aaci = substream->private_data;\n\n\taaci_pcm_prepare(substream);\n\n\t \n\taaci_ac97_write(aaci->ac97, AC97_EXTENDED_STATUS, 0x0001);  \n\taaci_ac97_write(aaci->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\n\taaci_ac97_write(aaci->ac97, AC97_PCM_MIC_ADC_RATE, runtime->rate);\n\n\t \n\taaci_ac97_write(aaci->ac97, AC97_REC_SEL, 0x0404);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops aaci_capture_ops = {\n\t.open\t\t= aaci_pcm_open,\n\t.close\t\t= aaci_pcm_close,\n\t.hw_params\t= aaci_pcm_hw_params,\n\t.hw_free\t= aaci_pcm_hw_free,\n\t.prepare\t= aaci_pcm_capture_prepare,\n\t.trigger\t= aaci_pcm_capture_trigger,\n\t.pointer\t= aaci_pcm_pointer,\n};\n\n \n#ifdef CONFIG_PM\nstatic int aaci_do_suspend(struct snd_card *card)\n{\n\tstruct aaci *aaci = card->private_data;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3cold);\n\treturn 0;\n}\n\nstatic int aaci_do_resume(struct snd_card *card)\n{\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic int aaci_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\treturn card ? aaci_do_suspend(card) : 0;\n}\n\nstatic int aaci_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\treturn card ? aaci_do_resume(card) : 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(aaci_dev_pm_ops, aaci_suspend, aaci_resume);\n#define AACI_DEV_PM_OPS (&aaci_dev_pm_ops)\n#else\n#define AACI_DEV_PM_OPS NULL\n#endif\n\n\nstatic const struct ac97_pcm ac97_defs[] = {\n\t[0] = {\t \n\t\t.exclusive = 1,\n\t\t.r = {\n\t\t\t[0] = {\n\t\t\t\t.slots\t= (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_RIGHT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_CENTER) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_SLEFT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_SRIGHT) |\n\t\t\t\t\t  (1 << AC97_SLOT_LFE),\n\t\t\t},\n\t\t\t[1] = {\n\t\t\t\t.slots\t= (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_RIGHT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_LEFT_0) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_RIGHT_0),\n\t\t\t},\n\t\t},\n\t},\n\t[1] = {\t \n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\n\t\t\t[0] = {\n\t\t\t\t.slots\t= (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t  (1 << AC97_SLOT_PCM_RIGHT),\n\t\t\t},\n\t\t},\n\t},\n\t[2] = {\t \n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\n\t\t\t[0] = {\n\t\t\t\t.slots\t= (1 << AC97_SLOT_MIC),\n\t\t\t},\n\t\t},\n\t}\n};\n\nstatic const struct snd_ac97_bus_ops aaci_bus_ops = {\n\t.write\t= aaci_ac97_write,\n\t.read\t= aaci_ac97_read,\n};\n\nstatic int aaci_probe_ac97(struct aaci *aaci)\n{\n\tstruct snd_ac97_template ac97_template;\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\tint ret;\n\n\t \n\twritel(0, aaci->base + AACI_RESET);\n\tudelay(2);\n\twritel(RESET_NRST, aaci->base + AACI_RESET);\n\n\t \n\tudelay(FRAME_PERIOD_US * 2);\n\n\tret = snd_ac97_bus(aaci->card, 0, &aaci_bus_ops, aaci, &ac97_bus);\n\tif (ret)\n\t\tgoto out;\n\n\tac97_bus->clock = 48000;\n\taaci->ac97_bus = ac97_bus;\n\n\tmemset(&ac97_template, 0, sizeof(struct snd_ac97_template));\n\tac97_template.private_data = aaci;\n\tac97_template.num = 0;\n\tac97_template.scaps = AC97_SCAP_SKIP_MODEM;\n\n\tret = snd_ac97_mixer(ac97_bus, &ac97_template, &ac97);\n\tif (ret)\n\t\tgoto out;\n\taaci->ac97 = ac97;\n\n\t \n\tif (ac97_is_audio(ac97))\n\t\tsnd_ac97_write_cache(ac97, AC97_PC_BEEP, 0x801e);\n\n\tret = snd_ac97_pcm_assign(ac97_bus, ARRAY_SIZE(ac97_defs), ac97_defs);\n\tif (ret)\n\t\tgoto out;\n\n\taaci->playback.pcm = &ac97_bus->pcms[0];\n\taaci->capture.pcm  = &ac97_bus->pcms[1];\n\n out:\n\treturn ret;\n}\n\nstatic void aaci_free_card(struct snd_card *card)\n{\n\tstruct aaci *aaci = card->private_data;\n\n\tiounmap(aaci->base);\n}\n\nstatic struct aaci *aaci_init_card(struct amba_device *dev)\n{\n\tstruct aaci *aaci;\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_card_new(&dev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, sizeof(struct aaci), &card);\n\tif (err < 0)\n\t\treturn NULL;\n\n\tcard->private_free = aaci_free_card;\n\n\tstrscpy(card->driver, DRIVER_NAME, sizeof(card->driver));\n\tstrscpy(card->shortname, \"ARM AC'97 Interface\", sizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s PL%03x rev%u at 0x%08llx, irq %d\",\n\t\t card->shortname, amba_part(dev), amba_rev(dev),\n\t\t (unsigned long long)dev->res.start, dev->irq[0]);\n\n\taaci = card->private_data;\n\tmutex_init(&aaci->ac97_sem);\n\tmutex_init(&aaci->irq_lock);\n\taaci->card = card;\n\taaci->dev = dev;\n\n\t \n\taaci->maincr = MAINCR_IE | MAINCR_SL1RXEN | MAINCR_SL1TXEN |\n\t\t       MAINCR_SL2RXEN | MAINCR_SL2TXEN;\n\n\treturn aaci;\n}\n\nstatic int aaci_init_pcm(struct aaci *aaci)\n{\n\tstruct snd_pcm *pcm;\n\tint ret;\n\n\tret = snd_pcm_new(aaci->card, \"AACI AC'97\", 0, 1, 1, &pcm);\n\tif (ret == 0) {\n\t\taaci->pcm = pcm;\n\t\tpcm->private_data = aaci;\n\t\tpcm->info_flags = 0;\n\n\t\tstrscpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));\n\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &aaci_playback_ops);\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &aaci_capture_ops);\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       aaci->card->dev,\n\t\t\t\t\t       0, 64 * 1024);\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int aaci_size_fifo(struct aaci *aaci)\n{\n\tstruct aaci_runtime *aacirun = &aaci->playback;\n\tint i;\n\n\t \n\twritel(CR_FEN | CR_SZ16 | CR_EN, aacirun->base + AACI_TXCR);\n\n\tfor (i = 0; !(readl(aacirun->base + AACI_SR) & SR_TXFF) && i < 4096; i++)\n\t\twritel(0, aacirun->fifo);\n\n\twritel(0, aacirun->base + AACI_TXCR);\n\n\t \n\twritel(aaci->maincr & ~MAINCR_IE, aaci->base + AACI_MAINCR);\n\treadl(aaci->base + AACI_MAINCR);\n\tudelay(1);\n\twritel(aaci->maincr, aaci->base + AACI_MAINCR);\n\n\t \n\tif (i == 4096)\n\t\ti = 8;\n\n\treturn i;\n}\n\nstatic int aaci_probe(struct amba_device *dev,\n\t\t      const struct amba_id *id)\n{\n\tstruct aaci *aaci;\n\tint ret, i;\n\n\tret = amba_request_regions(dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\taaci = aaci_init_card(dev);\n\tif (!aaci) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\taaci->base = ioremap(dev->res.start, resource_size(&dev->res));\n\tif (!aaci->base) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_init(&aaci->playback.lock);\n\taaci->playback.base = aaci->base + AACI_CSCH1;\n\taaci->playback.fifo = aaci->base + AACI_DR1;\n\n\t \n\tspin_lock_init(&aaci->capture.lock);\n\taaci->capture.base = aaci->base + AACI_CSCH1;\n\taaci->capture.fifo = aaci->base + AACI_DR1;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tvoid __iomem *base = aaci->base + i * 0x14;\n\n\t\twritel(0, base + AACI_IE);\n\t\twritel(0, base + AACI_TXCR);\n\t\twritel(0, base + AACI_RXCR);\n\t}\n\n\twritel(0x1fff, aaci->base + AACI_INTCLR);\n\twritel(aaci->maincr, aaci->base + AACI_MAINCR);\n\t \n\treadl(aaci->base + AACI_CSCH1);\n\tret = aaci_probe_ac97(aaci);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\taaci->fifo_depth = aaci_size_fifo(aaci);\n\tif (aaci->fifo_depth & 15) {\n\t\tprintk(KERN_WARNING \"AACI: FIFO depth %d not supported\\n\",\n\t\t       aaci->fifo_depth);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = aaci_init_pcm(aaci);\n\tif (ret)\n\t\tgoto out;\n\n\tret = snd_card_register(aaci->card);\n\tif (ret == 0) {\n\t\tdev_info(&dev->dev, \"%s\\n\", aaci->card->longname);\n\t\tdev_info(&dev->dev, \"FIFO %u entries\\n\", aaci->fifo_depth);\n\t\tamba_set_drvdata(dev, aaci->card);\n\t\treturn ret;\n\t}\n\n out:\n\tif (aaci)\n\t\tsnd_card_free(aaci->card);\n\tamba_release_regions(dev);\n\treturn ret;\n}\n\nstatic void aaci_remove(struct amba_device *dev)\n{\n\tstruct snd_card *card = amba_get_drvdata(dev);\n\n\tif (card) {\n\t\tstruct aaci *aaci = card->private_data;\n\t\twritel(0, aaci->base + AACI_MAINCR);\n\n\t\tsnd_card_free(card);\n\t\tamba_release_regions(dev);\n\t}\n}\n\nstatic struct amba_id aaci_ids[] = {\n\t{\n\t\t.id\t= 0x00041041,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, aaci_ids);\n\nstatic struct amba_driver aaci_driver = {\n\t.drv\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= AACI_DEV_PM_OPS,\n\t},\n\t.probe\t\t= aaci_probe,\n\t.remove\t\t= aaci_remove,\n\t.id_table\t= aaci_ids,\n};\n\nmodule_amba_driver(aaci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ARM PrimeCell PL041 Advanced Audio CODEC Interface driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}