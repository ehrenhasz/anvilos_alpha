{
  "module_name": "pxa2xx-ac97-lib.c",
  "hash_id": "a5b422e6e54931f8b4f97d1a999569fa820f18dd9f93a57d902a7f696d841a1f",
  "original_prompt": "Ingested from linux-6.6.14/sound/arm/pxa2xx-ac97-lib.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/soc/pxa/cpu.h>\n\n#include <sound/pxa2xx-lib.h>\n\n#include <linux/platform_data/asoc-pxa.h>\n\n#include \"pxa2xx-ac97-regs.h\"\n\nstatic DEFINE_MUTEX(car_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(gsr_wq);\nstatic volatile long gsr_bits;\nstatic struct clk *ac97_clk;\nstatic struct clk *ac97conf_clk;\nstatic int reset_gpio;\nstatic void __iomem *ac97_reg_base;\n\n \n\nint pxa2xx_ac97_read(int slot, unsigned short reg)\n{\n\tint val = -ENODEV;\n\tu32 __iomem *reg_addr;\n\n\tif (slot > 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&car_mutex);\n\n\t \n\tif (cpu_is_pxa25x() && reg == AC97_GPIO_STATUS)\n\t\treg_addr = ac97_reg_base +\n\t\t\t   (slot ? SMC_REG_BASE : PMC_REG_BASE);\n\telse\n\t\treg_addr = ac97_reg_base +\n\t\t\t   (slot ? SAC_REG_BASE : PAC_REG_BASE);\n\treg_addr += (reg >> 1);\n\n\t \n\twritel(GSR_CDONE | GSR_SDONE, ac97_reg_base + GSR);\n\tgsr_bits = 0;\n\tval = (readl(reg_addr) & 0xffff);\n\tif (reg == AC97_GPIO_STATUS)\n\t\tgoto out;\n\tif (wait_event_timeout(gsr_wq, (readl(ac97_reg_base + GSR) | gsr_bits) & GSR_SDONE, 1) <= 0 &&\n\t    !((readl(ac97_reg_base + GSR) | gsr_bits) & GSR_SDONE)) {\n\t\tprintk(KERN_ERR \"%s: read error (ac97_reg=%d GSR=%#lx)\\n\",\n\t\t\t\t__func__, reg, readl(ac97_reg_base + GSR) | gsr_bits);\n\t\tval = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\twritel(GSR_CDONE | GSR_SDONE, ac97_reg_base + GSR);\n\tgsr_bits = 0;\n\tval = (readl(reg_addr) & 0xffff);\n\t \n\twait_event_timeout(gsr_wq, (readl(ac97_reg_base + GSR) | gsr_bits) & GSR_SDONE, 1);\n\nout:\tmutex_unlock(&car_mutex);\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_read);\n\nint pxa2xx_ac97_write(int slot, unsigned short reg, unsigned short val)\n{\n\tu32 __iomem *reg_addr;\n\tint ret = 0;\n\n\tmutex_lock(&car_mutex);\n\n\t \n\tif (cpu_is_pxa25x() && reg == AC97_GPIO_STATUS)\n\t\treg_addr = ac97_reg_base +\n\t\t\t   (slot ? SMC_REG_BASE : PMC_REG_BASE);\n\telse\n\t\treg_addr = ac97_reg_base +\n\t\t\t   (slot ? SAC_REG_BASE : PAC_REG_BASE);\n\treg_addr += (reg >> 1);\n\n\twritel(GSR_CDONE | GSR_SDONE, ac97_reg_base + GSR);\n\tgsr_bits = 0;\n\twritel(val, reg_addr);\n\tif (wait_event_timeout(gsr_wq, (readl(ac97_reg_base + GSR) | gsr_bits) & GSR_CDONE, 1) <= 0 &&\n\t    !((readl(ac97_reg_base + GSR) | gsr_bits) & GSR_CDONE)) {\n\t\tprintk(KERN_ERR \"%s: write error (ac97_reg=%d GSR=%#lx)\\n\",\n\t\t\t\t__func__, reg, readl(ac97_reg_base + GSR) | gsr_bits);\n\t\tret = -EIO;\n\t}\n\n\tmutex_unlock(&car_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_write);\n\n#ifdef CONFIG_PXA25x\nstatic inline void pxa_ac97_warm_pxa25x(void)\n{\n\tgsr_bits = 0;\n\n\twritel(readl(ac97_reg_base + GCR) | (GCR_WARM_RST), ac97_reg_base + GCR);\n}\n\nstatic inline void pxa_ac97_cold_pxa25x(void)\n{\n\twritel(readl(ac97_reg_base + GCR) & ( GCR_COLD_RST), ac97_reg_base + GCR);   \n\twritel(readl(ac97_reg_base + GCR) & (~GCR_COLD_RST), ac97_reg_base + GCR);   \n\n\tgsr_bits = 0;\n\n\twritel(GCR_COLD_RST, ac97_reg_base + GCR);\n}\n#endif\n\n#ifdef CONFIG_PXA27x\nstatic inline void pxa_ac97_warm_pxa27x(void)\n{\n\tgsr_bits = 0;\n\n\t \n\tpxa27x_configure_ac97reset(reset_gpio, true);\n\tudelay(10);\n\twritel(readl(ac97_reg_base + GCR) | (GCR_WARM_RST), ac97_reg_base + GCR);\n\tpxa27x_configure_ac97reset(reset_gpio, false);\n\tudelay(500);\n}\n\nstatic inline void pxa_ac97_cold_pxa27x(void)\n{\n\twritel(readl(ac97_reg_base + GCR) & ( GCR_COLD_RST), ac97_reg_base + GCR);   \n\twritel(readl(ac97_reg_base + GCR) & (~GCR_COLD_RST), ac97_reg_base + GCR);   \n\n\tgsr_bits = 0;\n\n\t \n\tclk_prepare_enable(ac97conf_clk);\n\tudelay(5);\n\tclk_disable_unprepare(ac97conf_clk);\n\twritel(GCR_COLD_RST | GCR_WARM_RST, ac97_reg_base + GCR);\n}\n#endif\n\n#ifdef CONFIG_PXA3xx\nstatic inline void pxa_ac97_warm_pxa3xx(void)\n{\n\tgsr_bits = 0;\n\n\t \n\twritel(readl(ac97_reg_base + GCR) | (GCR_WARM_RST), ac97_reg_base + GCR);\n}\n\nstatic inline void pxa_ac97_cold_pxa3xx(void)\n{\n\t \n\twritel(0, ac97_reg_base + GCR);\n\twritel(GCR_CLKBPB, ac97_reg_base + GCR);\n\tudelay(100);\n\twritel(0, ac97_reg_base + GCR);\n\n\twritel(readl(ac97_reg_base + GCR) & ( GCR_COLD_RST), ac97_reg_base + GCR);   \n\twritel(readl(ac97_reg_base + GCR) & (~GCR_COLD_RST), ac97_reg_base + GCR);   \n\n\tgsr_bits = 0;\n\n\t \n\twritel(readl(ac97_reg_base + GCR) & (~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN)), ac97_reg_base + GCR);\n\n\twritel(GCR_WARM_RST | GCR_COLD_RST, ac97_reg_base + GCR);\n}\n#endif\n\nbool pxa2xx_ac97_try_warm_reset(void)\n{\n\tunsigned long gsr;\n\tunsigned int timeout = 100;\n\n#ifdef CONFIG_PXA25x\n\tif (cpu_is_pxa25x())\n\t\tpxa_ac97_warm_pxa25x();\n\telse\n#endif\n#ifdef CONFIG_PXA27x\n\tif (cpu_is_pxa27x())\n\t\tpxa_ac97_warm_pxa27x();\n\telse\n#endif\n#ifdef CONFIG_PXA3xx\n\tif (cpu_is_pxa3xx())\n\t\tpxa_ac97_warm_pxa3xx();\n\telse\n#endif\n\t\tsnd_BUG();\n\n\twhile (!((readl(ac97_reg_base + GSR) | gsr_bits) & (GSR_PCR | GSR_SCR)) && timeout--)\n\t\tmdelay(1);\n\n\tgsr = readl(ac97_reg_base + GSR) | gsr_bits;\n\tif (!(gsr & (GSR_PCR | GSR_SCR))) {\n\t\tprintk(KERN_INFO \"%s: warm reset timeout (GSR=%#lx)\\n\",\n\t\t\t\t __func__, gsr);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_try_warm_reset);\n\nbool pxa2xx_ac97_try_cold_reset(void)\n{\n\tunsigned long gsr;\n\tunsigned int timeout = 1000;\n\n#ifdef CONFIG_PXA25x\n\tif (cpu_is_pxa25x())\n\t\tpxa_ac97_cold_pxa25x();\n\telse\n#endif\n#ifdef CONFIG_PXA27x\n\tif (cpu_is_pxa27x())\n\t\tpxa_ac97_cold_pxa27x();\n\telse\n#endif\n#ifdef CONFIG_PXA3xx\n\tif (cpu_is_pxa3xx())\n\t\tpxa_ac97_cold_pxa3xx();\n\telse\n#endif\n\t\tsnd_BUG();\n\n\twhile (!((readl(ac97_reg_base + GSR) | gsr_bits) & (GSR_PCR | GSR_SCR)) && timeout--)\n\t\tmdelay(1);\n\n\tgsr = readl(ac97_reg_base + GSR) | gsr_bits;\n\tif (!(gsr & (GSR_PCR | GSR_SCR))) {\n\t\tprintk(KERN_INFO \"%s: cold reset timeout (GSR=%#lx)\\n\",\n\t\t\t\t __func__, gsr);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_try_cold_reset);\n\n\nvoid pxa2xx_ac97_finish_reset(void)\n{\n\tu32 gcr = readl(ac97_reg_base + GCR);\n\tgcr &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);\n\tgcr |= GCR_SDONE_IE|GCR_CDONE_IE;\n\twritel(gcr, ac97_reg_base + GCR);\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_finish_reset);\n\nstatic irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)\n{\n\tlong status;\n\n\tstatus = readl(ac97_reg_base + GSR);\n\tif (status) {\n\t\twritel(status, ac97_reg_base + GSR);\n\t\tgsr_bits |= status;\n\t\twake_up(&gsr_wq);\n\n\t\t \n\t\tif (cpu_is_pxa27x()) {\n\t\t\twritel(MISR_EOC, ac97_reg_base + MISR);\n\t\t\twritel(PISR_EOC, ac97_reg_base + PISR);\n\t\t\twritel(MCSR_EOC, ac97_reg_base + MCSR);\n\t\t}\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_PM\nint pxa2xx_ac97_hw_suspend(void)\n{\n\twritel(readl(ac97_reg_base + GCR) | (GCR_ACLINK_OFF), ac97_reg_base + GCR);\n\tclk_disable_unprepare(ac97_clk);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_hw_suspend);\n\nint pxa2xx_ac97_hw_resume(void)\n{\n\tclk_prepare_enable(ac97_clk);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_hw_resume);\n#endif\n\nint pxa2xx_ac97_hw_probe(struct platform_device *dev)\n{\n\tint ret;\n\tint irq;\n\tpxa2xx_audio_ops_t *pdata = dev->dev.platform_data;\n\n\tac97_reg_base = devm_platform_ioremap_resource(dev, 0);\n\tif (IS_ERR(ac97_reg_base)) {\n\t\tdev_err(&dev->dev, \"Missing MMIO resource\\n\");\n\t\treturn PTR_ERR(ac97_reg_base);\n\t}\n\n\tif (pdata) {\n\t\tswitch (pdata->reset_gpio) {\n\t\tcase 95:\n\t\tcase 113:\n\t\t\treset_gpio = pdata->reset_gpio;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\treset_gpio = 113;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&dev->dev, \"Invalid reset GPIO %d\\n\",\n\t\t\t\tpdata->reset_gpio);\n\t\t}\n\t} else if (!pdata && dev->dev.of_node) {\n\t\tpdata = devm_kzalloc(&dev->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t\tpdata->reset_gpio = of_get_named_gpio(dev->dev.of_node,\n\t\t\t\t\t\t      \"reset-gpios\", 0);\n\t\tif (pdata->reset_gpio == -ENOENT)\n\t\t\tpdata->reset_gpio = -1;\n\t\telse if (pdata->reset_gpio < 0)\n\t\t\treturn pdata->reset_gpio;\n\t\treset_gpio = pdata->reset_gpio;\n\t} else {\n\t\tif (cpu_is_pxa27x())\n\t\t\treset_gpio = 113;\n\t}\n\n\tif (cpu_is_pxa27x()) {\n\t\t \n\t\tret = gpio_request_one(reset_gpio, GPIOF_OUT_INIT_HIGH,\n\t\t\t\t       \"pxa27x ac97 reset\");\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: gpio_request_one() failed: %d\\n\",\n\t\t\t       __func__, ret);\n\t\t\tgoto err_conf;\n\t\t}\n\t\tpxa27x_configure_ac97reset(reset_gpio, false);\n\n\t\tac97conf_clk = clk_get(&dev->dev, \"AC97CONFCLK\");\n\t\tif (IS_ERR(ac97conf_clk)) {\n\t\t\tret = PTR_ERR(ac97conf_clk);\n\t\t\tac97conf_clk = NULL;\n\t\t\tgoto err_conf;\n\t\t}\n\t}\n\n\tac97_clk = clk_get(&dev->dev, \"AC97CLK\");\n\tif (IS_ERR(ac97_clk)) {\n\t\tret = PTR_ERR(ac97_clk);\n\t\tac97_clk = NULL;\n\t\tgoto err_clk;\n\t}\n\n\tret = clk_prepare_enable(ac97_clk);\n\tif (ret)\n\t\tgoto err_clk2;\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_irq;\n\t}\n\n\tret = request_irq(irq, pxa2xx_ac97_irq, 0, \"AC97\", NULL);\n\tif (ret < 0)\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\twritel(readl(ac97_reg_base + GCR) | (GCR_ACLINK_OFF), ac97_reg_base + GCR);\nerr_clk2:\n\tclk_put(ac97_clk);\n\tac97_clk = NULL;\nerr_clk:\n\tif (ac97conf_clk) {\n\t\tclk_put(ac97conf_clk);\n\t\tac97conf_clk = NULL;\n\t}\nerr_conf:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_hw_probe);\n\nvoid pxa2xx_ac97_hw_remove(struct platform_device *dev)\n{\n\tif (cpu_is_pxa27x())\n\t\tgpio_free(reset_gpio);\n\twritel(readl(ac97_reg_base + GCR) | (GCR_ACLINK_OFF), ac97_reg_base + GCR);\n\tfree_irq(platform_get_irq(dev, 0), NULL);\n\tif (ac97conf_clk) {\n\t\tclk_put(ac97conf_clk);\n\t\tac97conf_clk = NULL;\n\t}\n\tclk_disable_unprepare(ac97_clk);\n\tclk_put(ac97_clk);\n\tac97_clk = NULL;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_hw_remove);\n\nu32 pxa2xx_ac97_read_modr(void)\n{\n\tif (!ac97_reg_base)\n\t\treturn 0;\n\n\treturn readl(ac97_reg_base + MODR);\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_read_modr);\n\nu32 pxa2xx_ac97_read_misr(void)\n{\n\tif (!ac97_reg_base)\n\t\treturn 0;\n\n\treturn readl(ac97_reg_base + MISR);\n}\nEXPORT_SYMBOL_GPL(pxa2xx_ac97_read_misr);\n\nMODULE_AUTHOR(\"Nicolas Pitre\");\nMODULE_DESCRIPTION(\"Intel/Marvell PXA sound library\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}