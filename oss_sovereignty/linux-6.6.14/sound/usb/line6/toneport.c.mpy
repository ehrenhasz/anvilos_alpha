{
  "module_name": "toneport.c",
  "hash_id": "82165c872c44ef2558e084e2ca2c6858aa416f396470578af36f87290cc34eca",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/toneport.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/leds.h>\n#include <sound/core.h>\n#include <sound/control.h>\n\n#include \"capture.h\"\n#include \"driver.h\"\n#include \"playback.h\"\n\nenum line6_device_type {\n\tLINE6_GUITARPORT,\n\tLINE6_PODSTUDIO_GX,\n\tLINE6_PODSTUDIO_UX1,\n\tLINE6_PODSTUDIO_UX2,\n\tLINE6_TONEPORT_GX,\n\tLINE6_TONEPORT_UX1,\n\tLINE6_TONEPORT_UX2,\n};\n\nstruct usb_line6_toneport;\n\nstruct toneport_led {\n\tstruct led_classdev dev;\n\tchar name[64];\n\tstruct usb_line6_toneport *toneport;\n\tbool registered;\n};\n\nstruct usb_line6_toneport {\n\t \n\tstruct usb_line6 line6;\n\n\t \n\tint source;\n\n\t \n\tu32 serial_number;\n\n\t \n\tu8 firmware_version;\n\n\t \n\tenum line6_device_type type;\n\n\t \n\tstruct toneport_led leds[2];\n};\n\n#define line6_to_toneport(x) container_of(x, struct usb_line6_toneport, line6)\n\nstatic int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);\n\n#define TONEPORT_PCM_DELAY 1\n\nstatic const struct snd_ratden toneport_ratden = {\n\t.num_min = 44100,\n\t.num_max = 44100,\n\t.num_step = 1,\n\t.den = 1\n};\n\nstatic struct line6_pcm_properties toneport_pcm_properties = {\n\t.playback_hw = {\n\t\t\t\t  .info = (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\t   SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t\t   SNDRV_PCM_INFO_SYNC_START),\n\t\t\t\t  .formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t\t\t  .rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t\t  .rate_min = 44100,\n\t\t\t\t  .rate_max = 44100,\n\t\t\t\t  .channels_min = 2,\n\t\t\t\t  .channels_max = 2,\n\t\t\t\t  .buffer_bytes_max = 60000,\n\t\t\t\t  .period_bytes_min = 64,\n\t\t\t\t  .period_bytes_max = 8192,\n\t\t\t\t  .periods_min = 1,\n\t\t\t\t  .periods_max = 1024},\n\t.capture_hw = {\n\t\t\t\t .info = (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\t  SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\t  SNDRV_PCM_INFO_SYNC_START),\n\t\t\t\t .formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t\t\t .rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t\t .rate_min = 44100,\n\t\t\t\t .rate_max = 44100,\n\t\t\t\t .channels_min = 2,\n\t\t\t\t .channels_max = 2,\n\t\t\t\t .buffer_bytes_max = 60000,\n\t\t\t\t .period_bytes_min = 64,\n\t\t\t\t .period_bytes_max = 8192,\n\t\t\t\t .periods_min = 1,\n\t\t\t\t .periods_max = 1024},\n\t.rates = {\n\t\t\t    .nrats = 1,\n\t\t\t    .rats = &toneport_ratden},\n\t.bytes_per_channel = 2\n};\n\nstatic const struct {\n\tconst char *name;\n\tint code;\n} toneport_source_info[] = {\n\t{\"Microphone\", 0x0a01},\n\t{\"Line\", 0x0801},\n\t{\"Instrument\", 0x0b01},\n\t{\"Inst & Mic\", 0x0901}\n};\n\nstatic int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)\n{\n\tint ret;\n\n\tret = usb_control_msg_send(usbdev, 0, 0x67,\n\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t\t   cmd1, cmd2, NULL, 0, LINE6_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (ret) {\n\t\tdev_err(&usbdev->dev, \"send failed (error %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_toneport_monitor_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 256;\n\treturn 0;\n}\n\n \nstatic int snd_toneport_monitor_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = line6pcm->volume_monitor;\n\treturn 0;\n}\n\n \nstatic int snd_toneport_monitor_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\tint err;\n\n\tif (ucontrol->value.integer.value[0] == line6pcm->volume_monitor)\n\t\treturn 0;\n\n\tline6pcm->volume_monitor = ucontrol->value.integer.value[0];\n\n\tif (line6pcm->volume_monitor > 0) {\n\t\terr = line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR, true);\n\t\tif (err < 0) {\n\t\t\tline6pcm->volume_monitor = 0;\n\t\t\tline6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tline6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);\n\t}\n\n\treturn 1;\n}\n\n \nstatic int snd_toneport_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tconst int size = ARRAY_SIZE(toneport_source_info);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = size;\n\n\tif (uinfo->value.enumerated.item >= size)\n\t\tuinfo->value.enumerated.item = size - 1;\n\n\tstrcpy(uinfo->value.enumerated.name,\n\t       toneport_source_info[uinfo->value.enumerated.item].name);\n\n\treturn 0;\n}\n\n \nstatic int snd_toneport_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\tstruct usb_line6_toneport *toneport = line6_to_toneport(line6pcm->line6);\n\n\tucontrol->value.enumerated.item[0] = toneport->source;\n\treturn 0;\n}\n\n \nstatic int snd_toneport_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\tstruct usb_line6_toneport *toneport = line6_to_toneport(line6pcm->line6);\n\tunsigned int source;\n\n\tsource = ucontrol->value.enumerated.item[0];\n\tif (source >= ARRAY_SIZE(toneport_source_info))\n\t\treturn -EINVAL;\n\tif (source == toneport->source)\n\t\treturn 0;\n\n\ttoneport->source = source;\n\ttoneport_send_cmd(toneport->line6.usbdev,\n\t\t\t  toneport_source_info[source].code, 0x0000);\n\treturn 1;\n}\n\nstatic void toneport_startup(struct usb_line6 *line6)\n{\n\tline6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);\n}\n\n \nstatic const struct snd_kcontrol_new toneport_control_monitor = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Monitor Playback Volume\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_toneport_monitor_info,\n\t.get = snd_toneport_monitor_get,\n\t.put = snd_toneport_monitor_put\n};\n\n \nstatic const struct snd_kcontrol_new toneport_control_source = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Capture Source\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_toneport_source_info,\n\t.get = snd_toneport_source_get,\n\t.put = snd_toneport_source_put\n};\n\n \n\nstatic bool toneport_has_led(struct usb_line6_toneport *toneport)\n{\n\tswitch (toneport->type) {\n\tcase LINE6_GUITARPORT:\n\tcase LINE6_TONEPORT_GX:\n\t \n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char * const toneport_led_colors[2] = { \"red\", \"green\" };\nstatic const int toneport_led_init_vals[2] = { 0x00, 0x26 };\n\nstatic void toneport_update_led(struct usb_line6_toneport *toneport)\n{\n\ttoneport_send_cmd(toneport->line6.usbdev,\n\t\t\t  (toneport->leds[0].dev.brightness << 8) | 0x0002,\n\t\t\t  toneport->leds[1].dev.brightness);\n}\n\nstatic void toneport_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct toneport_led *leds =\n\t\tcontainer_of(led_cdev, struct toneport_led, dev);\n\ttoneport_update_led(leds->toneport);\n}\n\nstatic int toneport_init_leds(struct usb_line6_toneport *toneport)\n{\n\tstruct device *dev = &toneport->line6.usbdev->dev;\n\tint i, err;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct toneport_led *led = &toneport->leds[i];\n\t\tstruct led_classdev *leddev = &led->dev;\n\n\t\tled->toneport = toneport;\n\t\tsnprintf(led->name, sizeof(led->name), \"%s::%s\",\n\t\t\t dev_name(dev), toneport_led_colors[i]);\n\t\tleddev->name = led->name;\n\t\tleddev->brightness = toneport_led_init_vals[i];\n\t\tleddev->max_brightness = 0x26;\n\t\tleddev->brightness_set = toneport_led_brightness_set;\n\t\terr = led_classdev_register(dev, leddev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tled->registered = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void toneport_remove_leds(struct usb_line6_toneport *toneport)\n{\n\tstruct toneport_led *led;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tled = &toneport->leds[i];\n\t\tif (!led->registered)\n\t\t\tbreak;\n\t\tled_classdev_unregister(&led->dev);\n\t\tled->registered = false;\n\t}\n}\n\nstatic bool toneport_has_source_select(struct usb_line6_toneport *toneport)\n{\n\tswitch (toneport->type) {\n\tcase LINE6_TONEPORT_UX1:\n\tcase LINE6_TONEPORT_UX2:\n\tcase LINE6_PODSTUDIO_UX1:\n\tcase LINE6_PODSTUDIO_UX2:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int toneport_setup(struct usb_line6_toneport *toneport)\n{\n\tu32 *ticks;\n\tstruct usb_line6 *line6 = &toneport->line6;\n\tstruct usb_device *usbdev = line6->usbdev;\n\n\tticks = kmalloc(sizeof(*ticks), GFP_KERNEL);\n\tif (!ticks)\n\t\treturn -ENOMEM;\n\n\t \n\t \n\t*ticks = (u32)ktime_get_real_seconds();\n\tline6_write_data(line6, 0x80c6, ticks, 4);\n\tkfree(ticks);\n\n\t \n\ttoneport_send_cmd(usbdev, 0x0301, 0x0000);\n\n\t \n\tif (toneport_has_source_select(toneport))\n\t\ttoneport_send_cmd(usbdev,\n\t\t\t\t  toneport_source_info[toneport->source].code,\n\t\t\t\t  0x0000);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_update_led(toneport);\n\n\tschedule_delayed_work(&toneport->line6.startup_work,\n\t\t\t      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));\n\treturn 0;\n}\n\n \nstatic void line6_toneport_disconnect(struct usb_line6 *line6)\n{\n\tstruct usb_line6_toneport *toneport = line6_to_toneport(line6);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_remove_leds(toneport);\n}\n\n\n \nstatic int toneport_init(struct usb_line6 *line6,\n\t\t\t const struct usb_device_id *id)\n{\n\tint err;\n\tstruct usb_line6_toneport *toneport = line6_to_toneport(line6);\n\n\ttoneport->type = id->driver_info;\n\n\tline6->disconnect = line6_toneport_disconnect;\n\tline6->startup = toneport_startup;\n\n\t \n\terr = line6_init_pcm(line6, &toneport_pcm_properties);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_ctl_add(line6->card,\n\t\t\t  snd_ctl_new1(&toneport_control_monitor,\n\t\t\t\t       line6->line6pcm));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (toneport_has_source_select(toneport)) {\n\t\terr =\n\t\t    snd_ctl_add(line6->card,\n\t\t\t\tsnd_ctl_new1(&toneport_control_source,\n\t\t\t\t\t     line6->line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tline6_read_serial_number(line6, &toneport->serial_number);\n\tline6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);\n\n\tif (toneport_has_led(toneport)) {\n\t\terr = toneport_init_leds(toneport);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = toneport_setup(toneport);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn snd_card_register(line6->card);\n}\n\n#ifdef CONFIG_PM\n \nstatic int toneport_reset_resume(struct usb_interface *interface)\n{\n\tint err;\n\n\terr = toneport_setup(usb_get_intfdata(interface));\n\tif (err)\n\t\treturn err;\n\treturn line6_resume(interface);\n}\n#endif\n\n#define LINE6_DEVICE(prod) USB_DEVICE(0x0e41, prod)\n#define LINE6_IF_NUM(prod, n) USB_DEVICE_INTERFACE_NUMBER(0x0e41, prod, n)\n\n \nstatic const struct usb_device_id toneport_id_table[] = {\n\t{ LINE6_DEVICE(0x4750),    .driver_info = LINE6_GUITARPORT },\n\t{ LINE6_DEVICE(0x4153),    .driver_info = LINE6_PODSTUDIO_GX },\n\t{ LINE6_DEVICE(0x4150),    .driver_info = LINE6_PODSTUDIO_UX1 },\n\t{ LINE6_IF_NUM(0x4151, 0), .driver_info = LINE6_PODSTUDIO_UX2 },\n\t{ LINE6_DEVICE(0x4147),    .driver_info = LINE6_TONEPORT_GX },\n\t{ LINE6_DEVICE(0x4141),    .driver_info = LINE6_TONEPORT_UX1 },\n\t{ LINE6_IF_NUM(0x4142, 0), .driver_info = LINE6_TONEPORT_UX2 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, toneport_id_table);\n\nstatic const struct line6_properties toneport_properties_table[] = {\n\t[LINE6_GUITARPORT] = {\n\t\t.id = \"GuitarPort\",\n\t\t.name = \"GuitarPort\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_PODSTUDIO_GX] = {\n\t\t.id = \"PODStudioGX\",\n\t\t.name = \"POD Studio GX\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_PODSTUDIO_UX1] = {\n\t\t.id = \"PODStudioUX1\",\n\t\t.name = \"POD Studio UX1\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_PODSTUDIO_UX2] = {\n\t\t.id = \"PODStudioUX2\",\n\t\t.name = \"POD Studio UX2\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_TONEPORT_GX] = {\n\t\t.id = \"TonePortGX\",\n\t\t.name = \"TonePort GX\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_TONEPORT_UX1] = {\n\t\t.id = \"TonePortUX1\",\n\t\t.name = \"TonePort UX1\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_TONEPORT_UX2] = {\n\t\t.id = \"TonePortUX2\",\n\t\t.name = \"TonePort UX2\",\n\t\t.capabilities\t= LINE6_CAP_PCM,\n\t\t.altsetting = 2,   \n\t\t \n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n};\n\n \nstatic int toneport_probe(struct usb_interface *interface,\n\t\t\t  const struct usb_device_id *id)\n{\n\treturn line6_probe(interface, id, \"Line6-TonePort\",\n\t\t\t   &toneport_properties_table[id->driver_info],\n\t\t\t   toneport_init, sizeof(struct usb_line6_toneport));\n}\n\nstatic struct usb_driver toneport_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = toneport_probe,\n\t.disconnect = line6_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = line6_suspend,\n\t.resume = line6_resume,\n\t.reset_resume = toneport_reset_resume,\n#endif\n\t.id_table = toneport_id_table,\n};\n\nmodule_usb_driver(toneport_driver);\n\nMODULE_DESCRIPTION(\"TonePort USB driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}