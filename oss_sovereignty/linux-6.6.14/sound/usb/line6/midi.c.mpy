{
  "module_name": "midi.c",
  "hash_id": "4b1dceca9260a6af1db8d0fd909998b26ce0d4d34ef3614e73dd52fd9f6cd333",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/midi.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/rawmidi.h>\n\n#include \"driver.h\"\n#include \"midi.h\"\n\n#define line6_rawmidi_substream_midi(substream) \\\n\t((struct snd_line6_midi *)((substream)->rmidi->private_data))\n\nstatic int send_midi_async(struct usb_line6 *line6, unsigned char *data,\n\t\t\t   int length);\n\n \nvoid line6_midi_receive(struct usb_line6 *line6, unsigned char *data,\n\t\t\tint length)\n{\n\tif (line6->line6midi->substream_receive)\n\t\tsnd_rawmidi_receive(line6->line6midi->substream_receive,\n\t\t\t\t    data, length);\n}\n\n \nstatic void line6_midi_transmit(struct snd_rawmidi_substream *substream)\n{\n\tstruct usb_line6 *line6 =\n\t    line6_rawmidi_substream_midi(substream)->line6;\n\tstruct snd_line6_midi *line6midi = line6->line6midi;\n\tstruct midi_buffer *mb = &line6midi->midibuf_out;\n\tunsigned char chunk[LINE6_FALLBACK_MAXPACKETSIZE];\n\tint req, done;\n\n\tfor (;;) {\n\t\treq = min3(line6_midibuf_bytes_free(mb), line6->max_packet_size,\n\t\t\t   LINE6_FALLBACK_MAXPACKETSIZE);\n\t\tdone = snd_rawmidi_transmit_peek(substream, chunk, req);\n\n\t\tif (done == 0)\n\t\t\tbreak;\n\n\t\tline6_midibuf_write(mb, chunk, done);\n\t\tsnd_rawmidi_transmit_ack(substream, done);\n\t}\n\n\tfor (;;) {\n\t\tdone = line6_midibuf_read(mb, chunk,\n\t\t\t\t\t  LINE6_FALLBACK_MAXPACKETSIZE,\n\t\t\t\t\t  LINE6_MIDIBUF_READ_TX);\n\n\t\tif (done == 0)\n\t\t\tbreak;\n\n\t\tsend_midi_async(line6, chunk, done);\n\t}\n}\n\n \nstatic void midi_sent(struct urb *urb)\n{\n\tunsigned long flags;\n\tint status;\n\tint num;\n\tstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\n\n\tstatus = urb->status;\n\tkfree(urb->transfer_buffer);\n\tusb_free_urb(urb);\n\n\tif (status == -ESHUTDOWN)\n\t\treturn;\n\n\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\tnum = --line6->line6midi->num_active_send_urbs;\n\n\tif (num == 0) {\n\t\tline6_midi_transmit(line6->line6midi->substream_transmit);\n\t\tnum = line6->line6midi->num_active_send_urbs;\n\t}\n\n\tif (num == 0)\n\t\twake_up(&line6->line6midi->send_wait);\n\n\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n}\n\n \nstatic int send_midi_async(struct usb_line6 *line6, unsigned char *data,\n\t\t\t   int length)\n{\n\tstruct urb *urb;\n\tint retval;\n\tunsigned char *transfer_buffer;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\ttransfer_buffer = kmemdup(data, length, GFP_ATOMIC);\n\n\tif (transfer_buffer == NULL) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_int_urb(urb, line6->usbdev,\n\t\t\t usb_sndintpipe(line6->usbdev,\n\t\t\t\t\t line6->properties->ep_ctrl_w),\n\t\t\t transfer_buffer, length, midi_sent, line6,\n\t\t\t line6->interval);\n\turb->actual_length = 0;\n\tretval = usb_urb_ep_type_check(urb);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t++line6->line6midi->num_active_send_urbs;\n\treturn 0;\n\n error:\n\tdev_err(line6->ifcdev, \"usb_submit_urb failed\\n\");\n\tusb_free_urb(urb);\n\treturn retval;\n}\n\nstatic int line6_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int line6_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic void line6_midi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int up)\n{\n\tunsigned long flags;\n\tstruct usb_line6 *line6 =\n\t    line6_rawmidi_substream_midi(substream)->line6;\n\n\tline6->line6midi->substream_transmit = substream;\n\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\n\tif (line6->line6midi->num_active_send_urbs == 0)\n\t\tline6_midi_transmit(substream);\n\n\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n}\n\nstatic void line6_midi_output_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct usb_line6 *line6 =\n\t    line6_rawmidi_substream_midi(substream)->line6;\n\tstruct snd_line6_midi *midi = line6->line6midi;\n\n\twait_event_interruptible(midi->send_wait,\n\t\t\t\t midi->num_active_send_urbs == 0);\n}\n\nstatic int line6_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int line6_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic void line6_midi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t     int up)\n{\n\tstruct usb_line6 *line6 =\n\t    line6_rawmidi_substream_midi(substream)->line6;\n\n\tif (up)\n\t\tline6->line6midi->substream_receive = substream;\n\telse\n\t\tline6->line6midi->substream_receive = NULL;\n}\n\nstatic const struct snd_rawmidi_ops line6_midi_output_ops = {\n\t.open = line6_midi_output_open,\n\t.close = line6_midi_output_close,\n\t.trigger = line6_midi_output_trigger,\n\t.drain = line6_midi_output_drain,\n};\n\nstatic const struct snd_rawmidi_ops line6_midi_input_ops = {\n\t.open = line6_midi_input_open,\n\t.close = line6_midi_input_close,\n\t.trigger = line6_midi_input_trigger,\n};\n\n \nstatic int snd_line6_new_midi(struct usb_line6 *line6,\n\t\t\t      struct snd_rawmidi **rmidi_ret)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(line6->card, \"Line 6 MIDI\", 0, 1, 1, rmidi_ret);\n\tif (err < 0)\n\t\treturn err;\n\n\trmidi = *rmidi_ret;\n\tstrcpy(rmidi->id, line6->properties->id);\n\tstrcpy(rmidi->name, line6->properties->name);\n\n\trmidi->info_flags =\n\t    SNDRV_RAWMIDI_INFO_OUTPUT |\n\t    SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\n\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &line6_midi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &line6_midi_input_ops);\n\treturn 0;\n}\n\n \nstatic void snd_line6_midi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_line6_midi *line6midi = rmidi->private_data;\n\n\tline6_midibuf_destroy(&line6midi->midibuf_in);\n\tline6_midibuf_destroy(&line6midi->midibuf_out);\n\tkfree(line6midi);\n}\n\n \nint line6_init_midi(struct usb_line6 *line6)\n{\n\tint err;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_line6_midi *line6midi;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\terr = snd_line6_new_midi(line6, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6midi = kzalloc(sizeof(struct snd_line6_midi), GFP_KERNEL);\n\tif (!line6midi)\n\t\treturn -ENOMEM;\n\n\trmidi->private_data = line6midi;\n\trmidi->private_free = snd_line6_midi_free;\n\n\tinit_waitqueue_head(&line6midi->send_wait);\n\tspin_lock_init(&line6midi->lock);\n\tline6midi->line6 = line6;\n\n\terr = line6_midibuf_init(&line6midi->midibuf_in, MIDI_BUFFER_SIZE, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_midibuf_init(&line6midi->midibuf_out, MIDI_BUFFER_SIZE, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6->line6midi = line6midi;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(line6_init_midi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}