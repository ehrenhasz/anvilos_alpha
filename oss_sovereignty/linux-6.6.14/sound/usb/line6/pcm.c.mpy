{
  "module_name": "pcm.c",
  "hash_id": "62a4af0c4f1c9356b14f70ab2c718d4bcd406a15891cf8ac04ef7da036fefe49",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/pcm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"capture.h\"\n#include \"driver.h\"\n#include \"playback.h\"\n\n \nstatic int snd_line6_impulse_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_line6_impulse_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = line6pcm->impulse_volume;\n\treturn 0;\n}\n\nstatic int snd_line6_impulse_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\tint value = ucontrol->value.integer.value[0];\n\tint err;\n\n\tif (line6pcm->impulse_volume == value)\n\t\treturn 0;\n\n\tline6pcm->impulse_volume = value;\n\tif (value > 0) {\n\t\terr = line6_pcm_acquire(line6pcm, LINE6_STREAM_IMPULSE, true);\n\t\tif (err < 0) {\n\t\t\tline6pcm->impulse_volume = 0;\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tline6_pcm_release(line6pcm, LINE6_STREAM_IMPULSE);\n\t}\n\treturn 1;\n}\n\n \nstatic int snd_line6_impulse_period_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 2000;\n\treturn 0;\n}\n\nstatic int snd_line6_impulse_period_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = line6pcm->impulse_period;\n\treturn 0;\n}\n\nstatic int snd_line6_impulse_period_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (line6pcm->impulse_period == value)\n\t\treturn 0;\n\n\tline6pcm->impulse_period = value;\n\treturn 1;\n}\n\n \nstatic void line6_unlink_audio_urbs(struct snd_line6_pcm *line6pcm,\n\t\t\t\t    struct line6_pcm_stream *pcms)\n{\n\tint i;\n\n\tfor (i = 0; i < line6pcm->line6->iso_buffers; i++) {\n\t\tif (test_bit(i, &pcms->active_urbs)) {\n\t\t\tif (!test_and_set_bit(i, &pcms->unlink_urbs))\n\t\t\t\tusb_unlink_urb(pcms->urbs[i]);\n\t\t}\n\t}\n}\n\n \nstatic void line6_wait_clear_audio_urbs(struct snd_line6_pcm *line6pcm,\n\t\t\t\t\tstruct line6_pcm_stream *pcms)\n{\n\tint timeout = HZ;\n\tint i;\n\tint alive;\n\n\tdo {\n\t\talive = 0;\n\t\tfor (i = 0; i < line6pcm->line6->iso_buffers; i++) {\n\t\t\tif (test_bit(i, &pcms->active_urbs))\n\t\t\t\talive++;\n\t\t}\n\t\tif (!alive)\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(1);\n\t} while (--timeout > 0);\n\tif (alive)\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"timeout: still %d active urbs..\\n\", alive);\n}\n\nstatic inline struct line6_pcm_stream *\nget_stream(struct snd_line6_pcm *line6pcm, int direction)\n{\n\treturn (direction == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\t&line6pcm->out : &line6pcm->in;\n}\n\n \nstatic int line6_buffer_acquire(struct snd_line6_pcm *line6pcm,\n\t\t\t\tstruct line6_pcm_stream *pstr, int direction, int type)\n{\n\tconst int pkt_size =\n\t\t(direction == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\t\tline6pcm->max_packet_size_out :\n\t\t\tline6pcm->max_packet_size_in;\n\n\t \n\tif (!test_and_set_bit(type, &pstr->opened) && !pstr->buffer) {\n\t\tpstr->buffer =\n\t\t\tkmalloc(array3_size(line6pcm->line6->iso_buffers,\n\t\t\t\t\t    LINE6_ISO_PACKETS, pkt_size),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!pstr->buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic void line6_buffer_release(struct snd_line6_pcm *line6pcm,\n\t\t\t\t struct line6_pcm_stream *pstr, int type)\n{\n\tclear_bit(type, &pstr->opened);\n\tif (!pstr->opened) {\n\t\tline6_wait_clear_audio_urbs(line6pcm, pstr);\n\t\tkfree(pstr->buffer);\n\t\tpstr->buffer = NULL;\n\t}\n}\n\n \nstatic int line6_stream_start(struct snd_line6_pcm *line6pcm, int direction,\n\t\t\t      int type)\n{\n\tunsigned long flags;\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, direction);\n\tint ret = 0;\n\n\tspin_lock_irqsave(&pstr->lock, flags);\n\tif (!test_and_set_bit(type, &pstr->running) &&\n\t    !(pstr->active_urbs || pstr->unlink_urbs)) {\n\t\tpstr->count = 0;\n\t\t \n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = line6_submit_audio_out_all_urbs(line6pcm);\n\t\telse\n\t\t\tret = line6_submit_audio_in_all_urbs(line6pcm);\n\t}\n\n\tif (ret < 0)\n\t\tclear_bit(type, &pstr->running);\n\tspin_unlock_irqrestore(&pstr->lock, flags);\n\treturn ret;\n}\n\n \nstatic void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,\n\t\t\t  int type)\n{\n\tunsigned long flags;\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, direction);\n\n\tspin_lock_irqsave(&pstr->lock, flags);\n\tclear_bit(type, &pstr->running);\n\tif (!pstr->running) {\n\t\tspin_unlock_irqrestore(&pstr->lock, flags);\n\t\tline6_unlink_audio_urbs(line6pcm, pstr);\n\t\tspin_lock_irqsave(&pstr->lock, flags);\n\t\tif (direction == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tline6pcm->prev_fbuf = NULL;\n\t\t\tline6pcm->prev_fsize = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pstr->lock, flags);\n}\n\n \nint snd_line6_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tint err;\n\n\tclear_bit(LINE6_FLAG_PREPARED, &line6pcm->flags);\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\tcontinue;\n\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t\tif (s->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t\t\t\t(line6pcm->line6->properties->capabilities &\n\t\t\t\t\tLINE6_CAP_IN_NEEDS_OUT)) {\n\t\t\t\terr = line6_stream_start(line6pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t\t LINE6_STREAM_CAPTURE_HELPER);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\terr = line6_stream_start(line6pcm, s->stream,\n\t\t\t\t\t\t LINE6_STREAM_PCM);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\t\tif (s->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t\t\t\t(line6pcm->line6->properties->capabilities &\n\t\t\t\t\tLINE6_CAP_IN_NEEDS_OUT)) {\n\t\t\t\tline6_stream_stop(line6pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t  LINE6_STREAM_CAPTURE_HELPER);\n\t\t\t}\n\t\t\tline6_stream_stop(line6pcm, s->stream,\n\t\t\t\t\t  LINE6_STREAM_PCM);\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\treturn -EINVAL;\n\t\t\tset_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags);\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\tif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\treturn -EINVAL;\n\t\t\tclear_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nsnd_pcm_uframes_t snd_line6_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\n\n\treturn pstr->pos_done;\n}\n\n \nint line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type, bool start)\n{\n\tstruct line6_pcm_stream *pstr;\n\tint ret = 0, dir;\n\n\t \n\tmutex_lock(&line6pcm->state_mutex);\n\tfor (dir = 0; dir < 2; dir++) {\n\t\tpstr = get_stream(line6pcm, dir);\n\t\tret = line6_buffer_acquire(line6pcm, pstr, dir, type);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (!pstr->running)\n\t\t\tline6_wait_clear_audio_urbs(line6pcm, pstr);\n\t}\n\tif (start) {\n\t\tfor (dir = 0; dir < 2; dir++) {\n\t\t\tret = line6_stream_start(line6pcm, dir, type);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n error:\n\tmutex_unlock(&line6pcm->state_mutex);\n\tif (ret < 0)\n\t\tline6_pcm_release(line6pcm, type);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(line6_pcm_acquire);\n\n \nvoid line6_pcm_release(struct snd_line6_pcm *line6pcm, int type)\n{\n\tstruct line6_pcm_stream *pstr;\n\tint dir;\n\n\tmutex_lock(&line6pcm->state_mutex);\n\tfor (dir = 0; dir < 2; dir++)\n\t\tline6_stream_stop(line6pcm, dir, type);\n\tfor (dir = 0; dir < 2; dir++) {\n\t\tpstr = get_stream(line6pcm, dir);\n\t\tline6_buffer_release(line6pcm, pstr, type);\n\t}\n\tmutex_unlock(&line6pcm->state_mutex);\n}\nEXPORT_SYMBOL_GPL(line6_pcm_release);\n\n \nint snd_line6_hw_params(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tint ret;\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\n\n\tmutex_lock(&line6pcm->state_mutex);\n\tret = line6_buffer_acquire(line6pcm, pstr, substream->stream,\n\t                           LINE6_STREAM_PCM);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpstr->period = params_period_bytes(hw_params);\n error:\n\tmutex_unlock(&line6pcm->state_mutex);\n\treturn ret;\n}\n\n \nint snd_line6_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\n\n\tmutex_lock(&line6pcm->state_mutex);\n\tline6_buffer_release(line6pcm, pstr, LINE6_STREAM_PCM);\n\tmutex_unlock(&line6pcm->state_mutex);\n\treturn 0;\n}\n\n\n \nstatic int snd_line6_control_playback_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 256;\n\treturn 0;\n}\n\n \nstatic int snd_line6_control_playback_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint i;\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] = line6pcm->volume_playback[i];\n\n\treturn 0;\n}\n\n \nstatic int snd_line6_control_playback_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint i, changed = 0;\n\tstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (line6pcm->volume_playback[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tline6pcm->volume_playback[i] =\n\t\t\t    ucontrol->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t}\n\n\treturn changed;\n}\n\n \nstatic const struct snd_kcontrol_new line6_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Volume\",\n\t\t.info = snd_line6_control_playback_info,\n\t\t.get = snd_line6_control_playback_get,\n\t\t.put = snd_line6_control_playback_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Impulse Response Volume\",\n\t\t.info = snd_line6_impulse_volume_info,\n\t\t.get = snd_line6_impulse_volume_get,\n\t\t.put = snd_line6_impulse_volume_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Impulse Response Period\",\n\t\t.info = snd_line6_impulse_period_info,\n\t\t.get = snd_line6_impulse_period_get,\n\t\t.put = snd_line6_impulse_period_put\n\t},\n};\n\n \nstatic void cleanup_urbs(struct line6_pcm_stream *pcms, int iso_buffers)\n{\n\tint i;\n\n\t \n\tif (pcms->urbs == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < iso_buffers; i++) {\n\t\tif (pcms->urbs[i]) {\n\t\t\tusb_kill_urb(pcms->urbs[i]);\n\t\t\tusb_free_urb(pcms->urbs[i]);\n\t\t}\n\t}\n\tkfree(pcms->urbs);\n\tpcms->urbs = NULL;\n}\n\nstatic void line6_cleanup_pcm(struct snd_pcm *pcm)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_chip(pcm);\n\n\tcleanup_urbs(&line6pcm->out, line6pcm->line6->iso_buffers);\n\tcleanup_urbs(&line6pcm->in, line6pcm->line6->iso_buffers);\n\tkfree(line6pcm);\n}\n\n \nstatic int snd_line6_new_pcm(struct usb_line6 *line6, struct snd_pcm **pcm_ret)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(line6->card, (char *)line6->properties->name,\n\t\t\t  0, 1, 1, pcm_ret);\n\tif (err < 0)\n\t\treturn err;\n\tpcm = *pcm_ret;\n\tstrcpy(pcm->name, line6->properties->name);\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_line6_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_line6_capture_ops);\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 64 * 1024, 128 * 1024);\n\treturn 0;\n}\n\n \nvoid line6_pcm_disconnect(struct snd_line6_pcm *line6pcm)\n{\n\tline6_unlink_audio_urbs(line6pcm, &line6pcm->out);\n\tline6_unlink_audio_urbs(line6pcm, &line6pcm->in);\n\tline6_wait_clear_audio_urbs(line6pcm, &line6pcm->out);\n\tline6_wait_clear_audio_urbs(line6pcm, &line6pcm->in);\n}\n\n \nint line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t \n\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\n\tline6->line6pcm = line6pcm;\n\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read));\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write));\n\tif (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"cannot get proper max packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(line6_init_pcm);\n\n \nint snd_line6_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\tstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\n\n\tmutex_lock(&line6pcm->state_mutex);\n\tif (!pstr->running)\n\t\tline6_wait_clear_audio_urbs(line6pcm, pstr);\n\n\tif (!test_and_set_bit(LINE6_FLAG_PREPARED, &line6pcm->flags)) {\n\t\tline6pcm->out.count = 0;\n\t\tline6pcm->out.pos = 0;\n\t\tline6pcm->out.pos_done = 0;\n\t\tline6pcm->out.bytes = 0;\n\t\tline6pcm->in.count = 0;\n\t\tline6pcm->in.pos_done = 0;\n\t\tline6pcm->in.bytes = 0;\n\t}\n\n\tmutex_unlock(&line6pcm->state_mutex);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}