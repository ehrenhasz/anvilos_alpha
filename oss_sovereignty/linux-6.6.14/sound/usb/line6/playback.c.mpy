{
  "module_name": "playback.c",
  "hash_id": "782f93d36770fd151714ad703a2e71897f1bb5805060f7013fb3b2f82603f27d",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/playback.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"capture.h\"\n#include \"driver.h\"\n#include \"pcm.h\"\n#include \"playback.h\"\n\n \nstatic void change_volume(struct urb *urb_out, int volume[],\n\t\t\t  int bytes_per_frame)\n{\n\tint chn = 0;\n\n\tif (volume[0] == 256 && volume[1] == 256)\n\t\treturn;\t\t \n\n\tif (bytes_per_frame == 4) {\n\t\t__le16 *p, *buf_end;\n\n\t\tp = (__le16 *)urb_out->transfer_buffer;\n\t\tbuf_end = p + urb_out->transfer_buffer_length / sizeof(*p);\n\n\t\tfor (; p < buf_end; ++p) {\n\t\t\tshort pv = le16_to_cpu(*p);\n\t\t\tint val = (pv * volume[chn & 1]) >> 8;\n\t\t\tpv = clamp(val, -0x8000, 0x7fff);\n\t\t\t*p = cpu_to_le16(pv);\n\t\t\t++chn;\n\t\t}\n\t} else if (bytes_per_frame == 6) {\n\t\tunsigned char *p, *buf_end;\n\n\t\tp = (unsigned char *)urb_out->transfer_buffer;\n\t\tbuf_end = p + urb_out->transfer_buffer_length;\n\n\t\tfor (; p < buf_end; p += 3) {\n\t\t\tint val;\n\n\t\t\tval = p[0] + (p[1] << 8) + ((signed char)p[2] << 16);\n\t\t\tval = (val * volume[chn & 1]) >> 8;\n\t\t\tval = clamp(val, -0x800000, 0x7fffff);\n\t\t\tp[0] = val;\n\t\t\tp[1] = val >> 8;\n\t\t\tp[2] = val >> 16;\n\t\t\t++chn;\n\t\t}\n\t}\n}\n\n \nstatic void create_impulse_test_signal(struct snd_line6_pcm *line6pcm,\n\t\t\t\t       struct urb *urb_out, int bytes_per_frame)\n{\n\tint frames = urb_out->transfer_buffer_length / bytes_per_frame;\n\n\tif (bytes_per_frame == 4) {\n\t\tint i;\n\t\tshort *pi = (short *)line6pcm->prev_fbuf;\n\t\tshort *po = (short *)urb_out->transfer_buffer;\n\n\t\tfor (i = 0; i < frames; ++i) {\n\t\t\tpo[0] = pi[0];\n\t\t\tpo[1] = 0;\n\t\t\tpi += 2;\n\t\t\tpo += 2;\n\t\t}\n\t} else if (bytes_per_frame == 6) {\n\t\tint i, j;\n\t\tunsigned char *pi = line6pcm->prev_fbuf;\n\t\tunsigned char *po = urb_out->transfer_buffer;\n\n\t\tfor (i = 0; i < frames; ++i) {\n\t\t\tfor (j = 0; j < bytes_per_frame / 2; ++j)\n\t\t\t\tpo[j] = pi[j];\n\n\t\t\tfor (; j < bytes_per_frame; ++j)\n\t\t\t\tpo[j] = 0;\n\n\t\t\tpi += bytes_per_frame;\n\t\t\tpo += bytes_per_frame;\n\t\t}\n\t}\n\tif (--line6pcm->impulse_count <= 0) {\n\t\t((unsigned char *)(urb_out->transfer_buffer))[bytes_per_frame -\n\t\t\t\t\t\t\t      1] =\n\t\t    line6pcm->impulse_volume;\n\t\tline6pcm->impulse_count = line6pcm->impulse_period;\n\t}\n}\n\n \nstatic void add_monitor_signal(struct urb *urb_out, unsigned char *signal,\n\t\t\t       int volume, int bytes_per_frame)\n{\n\tif (volume == 0)\n\t\treturn;\t\t \n\n\tif (bytes_per_frame == 4) {\n\t\t__le16 *pi, *po, *buf_end;\n\n\t\tpi = (__le16 *)signal;\n\t\tpo = (__le16 *)urb_out->transfer_buffer;\n\t\tbuf_end = po + urb_out->transfer_buffer_length / sizeof(*po);\n\n\t\tfor (; po < buf_end; ++pi, ++po) {\n\t\t\tshort pov = le16_to_cpu(*po);\n\t\t\tshort piv = le16_to_cpu(*pi);\n\t\t\tint val = pov + ((piv * volume) >> 8);\n\t\t\tpov = clamp(val, -0x8000, 0x7fff);\n\t\t\t*po = cpu_to_le16(pov);\n\t\t}\n\t}\n\n\t \n}\n\n \nstatic int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)\n{\n\tint index;\n\tint i, urb_size, urb_frames;\n\tint ret;\n\tconst int bytes_per_frame =\n\t\tline6pcm->properties->bytes_per_channel *\n\t\tline6pcm->properties->playback_hw.channels_max;\n\tconst int frame_increment =\n\t\tline6pcm->properties->rates.rats[0].num_min;\n\tconst int frame_factor =\n\t\tline6pcm->properties->rates.rats[0].den *\n\t\t(line6pcm->line6->intervals_per_second / LINE6_ISO_INTERVAL);\n\tstruct urb *urb_out;\n\n\tindex = find_first_zero_bit(&line6pcm->out.active_urbs,\n\t\t\t\t    line6pcm->line6->iso_buffers);\n\n\tif (index < 0 || index >= line6pcm->line6->iso_buffers) {\n\t\tdev_err(line6pcm->line6->ifcdev, \"no free URB found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\turb_out = line6pcm->out.urbs[index];\n\turb_size = 0;\n\n\t \n\tfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\n\t\t \n\t\tint fsize = 0;\n\t\tstruct usb_iso_packet_descriptor *fout =\n\t\t    &urb_out->iso_frame_desc[i];\n\n\t\tfsize = line6pcm->prev_fsize;\n\t\tif (fsize == 0) {\n\t\t\tint n;\n\n\t\t\tline6pcm->out.count += frame_increment;\n\t\t\tn = line6pcm->out.count / frame_factor;\n\t\t\tline6pcm->out.count -= n * frame_factor;\n\t\t\tfsize = n;\n\t\t}\n\n\t\tfsize *= bytes_per_frame;\n\n\t\tfout->offset = urb_size;\n\t\tfout->length = fsize;\n\t\turb_size += fsize;\n\t}\n\n\tif (urb_size == 0) {\n\t\t \n\t\tdev_err(line6pcm->line6->ifcdev, \"driver bug: urb_size = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\turb_frames = urb_size / bytes_per_frame;\n\turb_out->transfer_buffer =\n\t    line6pcm->out.buffer +\n\t    index * LINE6_ISO_PACKETS * line6pcm->max_packet_size_out;\n\turb_out->transfer_buffer_length = urb_size;\n\turb_out->context = line6pcm;\n\n\tif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running) &&\n\t    !test_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags)) {\n\t\tstruct snd_pcm_runtime *runtime =\n\t\t    get_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK)->runtime;\n\n\t\tif (line6pcm->out.pos + urb_frames > runtime->buffer_size) {\n\t\t\t \n\t\t\tint len;\n\n\t\t\tlen = runtime->buffer_size - line6pcm->out.pos;\n\n\t\t\tif (len > 0) {\n\t\t\t\tmemcpy(urb_out->transfer_buffer,\n\t\t\t\t       runtime->dma_area +\n\t\t\t\t       line6pcm->out.pos * bytes_per_frame,\n\t\t\t\t       len * bytes_per_frame);\n\t\t\t\tmemcpy(urb_out->transfer_buffer +\n\t\t\t\t       len * bytes_per_frame, runtime->dma_area,\n\t\t\t\t       (urb_frames - len) * bytes_per_frame);\n\t\t\t} else\n\t\t\t\tdev_err(line6pcm->line6->ifcdev, \"driver bug: len = %d\\n\",\n\t\t\t\t\tlen);\n\t\t} else {\n\t\t\tmemcpy(urb_out->transfer_buffer,\n\t\t\t       runtime->dma_area +\n\t\t\t       line6pcm->out.pos * bytes_per_frame,\n\t\t\t       urb_out->transfer_buffer_length);\n\t\t}\n\n\t\tline6pcm->out.pos += urb_frames;\n\t\tif (line6pcm->out.pos >= runtime->buffer_size)\n\t\t\tline6pcm->out.pos -= runtime->buffer_size;\n\n\t\tchange_volume(urb_out, line6pcm->volume_playback,\n\t\t\t      bytes_per_frame);\n\t} else {\n\t\tmemset(urb_out->transfer_buffer, 0,\n\t\t       urb_out->transfer_buffer_length);\n\t}\n\n\tspin_lock_nested(&line6pcm->in.lock, SINGLE_DEPTH_NESTING);\n\tif (line6pcm->prev_fbuf) {\n\t\tif (test_bit(LINE6_STREAM_IMPULSE, &line6pcm->out.running)) {\n\t\t\tcreate_impulse_test_signal(line6pcm, urb_out,\n\t\t\t\t\t\t   bytes_per_frame);\n\t\t\tif (test_bit(LINE6_STREAM_PCM, &line6pcm->in.running)) {\n\t\t\t\tline6_capture_copy(line6pcm,\n\t\t\t\t\t\t   urb_out->transfer_buffer,\n\t\t\t\t\t\t   urb_out->\n\t\t\t\t\t\t   transfer_buffer_length);\n\t\t\t\tline6_capture_check_period(line6pcm,\n\t\t\t\t\turb_out->transfer_buffer_length);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(line6pcm->line6->properties->capabilities & LINE6_CAP_HWMON)\n\t\t\t    && line6pcm->out.running && line6pcm->in.running)\n\t\t\t\tadd_monitor_signal(urb_out, line6pcm->prev_fbuf,\n\t\t\t\t\t\t   line6pcm->volume_monitor,\n\t\t\t\t\t\t   bytes_per_frame);\n\t\t}\n\t\tline6pcm->prev_fbuf = NULL;\n\t\tline6pcm->prev_fsize = 0;\n\t}\n\tspin_unlock(&line6pcm->in.lock);\n\n\tret = usb_submit_urb(urb_out, GFP_ATOMIC);\n\n\tif (ret == 0)\n\t\tset_bit(index, &line6pcm->out.active_urbs);\n\telse\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"URB out #%d submission failed (%d)\\n\", index, ret);\n\n\treturn 0;\n}\n\n \nint line6_submit_audio_out_all_urbs(struct snd_line6_pcm *line6pcm)\n{\n\tint ret = 0, i;\n\n\tfor (i = 0; i < line6pcm->line6->iso_buffers; ++i) {\n\t\tret = submit_audio_out_urb(line6pcm);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void audio_out_callback(struct urb *urb)\n{\n\tint i, index, length = 0, shutdown = 0;\n\tunsigned long flags;\n\tstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\n\tstruct snd_pcm_substream *substream =\n\t    get_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK);\n\tconst int bytes_per_frame =\n\t\tline6pcm->properties->bytes_per_channel *\n\t\tline6pcm->properties->playback_hw.channels_max;\n\n#if USE_CLEAR_BUFFER_WORKAROUND\n\tmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\n#endif\n\n\tline6pcm->out.last_frame = urb->start_frame;\n\n\t \n\tfor (index = 0; index < line6pcm->line6->iso_buffers; index++)\n\t\tif (urb == line6pcm->out.urbs[index])\n\t\t\tbreak;\n\n\tif (index >= line6pcm->line6->iso_buffers)\n\t\treturn;\t\t \n\n\tfor (i = 0; i < LINE6_ISO_PACKETS; i++)\n\t\tlength += urb->iso_frame_desc[i].length;\n\n\tspin_lock_irqsave(&line6pcm->out.lock, flags);\n\n\tif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running)) {\n\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t\tline6pcm->out.pos_done +=\n\t\t    length / bytes_per_frame;\n\n\t\tif (line6pcm->out.pos_done >= runtime->buffer_size)\n\t\t\tline6pcm->out.pos_done -= runtime->buffer_size;\n\t}\n\n\tclear_bit(index, &line6pcm->out.active_urbs);\n\n\tfor (i = 0; i < LINE6_ISO_PACKETS; i++)\n\t\tif (urb->iso_frame_desc[i].status == -EXDEV) {\n\t\t\tshutdown = 1;\n\t\t\tbreak;\n\t\t}\n\n\tif (test_and_clear_bit(index, &line6pcm->out.unlink_urbs))\n\t\tshutdown = 1;\n\n\tif (!shutdown) {\n\t\tsubmit_audio_out_urb(line6pcm);\n\n\t\tif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running)) {\n\t\t\tline6pcm->out.bytes += length;\n\t\t\tif (line6pcm->out.bytes >= line6pcm->out.period) {\n\t\t\t\tline6pcm->out.bytes %= line6pcm->out.period;\n\t\t\t\tspin_unlock(&line6pcm->out.lock);\n\t\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\t\tspin_lock(&line6pcm->out.lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&line6pcm->out.lock, flags);\n}\n\n \nstatic int snd_line6_playback_open(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\n\terr = snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    &line6pcm->properties->rates);\n\tif (err < 0)\n\t\treturn err;\n\n\truntime->hw = line6pcm->properties->playback_hw;\n\treturn 0;\n}\n\n \nstatic int snd_line6_playback_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nconst struct snd_pcm_ops snd_line6_playback_ops = {\n\t.open = snd_line6_playback_open,\n\t.close = snd_line6_playback_close,\n\t.hw_params = snd_line6_hw_params,\n\t.hw_free = snd_line6_hw_free,\n\t.prepare = snd_line6_prepare,\n\t.trigger = snd_line6_trigger,\n\t.pointer = snd_line6_pointer,\n};\n\nint line6_create_audio_out_urbs(struct snd_line6_pcm *line6pcm)\n{\n\tstruct usb_line6 *line6 = line6pcm->line6;\n\tint i;\n\n\tline6pcm->out.urbs = kcalloc(line6->iso_buffers, sizeof(struct urb *),\n\t\t\t\t     GFP_KERNEL);\n\tif (line6pcm->out.urbs == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < line6->iso_buffers; ++i) {\n\t\tstruct urb *urb;\n\n\t\t \n\t\turb = line6pcm->out.urbs[i] =\n\t\t    usb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\n\n\t\tif (urb == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\turb->dev = line6->usbdev;\n\t\turb->pipe =\n\t\t    usb_sndisocpipe(line6->usbdev,\n\t\t\t\t    line6->properties->ep_audio_w &\n\t\t\t\t    USB_ENDPOINT_NUMBER_MASK);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->start_frame = -1;\n\t\turb->number_of_packets = LINE6_ISO_PACKETS;\n\t\turb->interval = LINE6_ISO_INTERVAL;\n\t\turb->error_count = 0;\n\t\turb->complete = audio_out_callback;\n\t\tif (usb_urb_ep_type_check(urb))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}