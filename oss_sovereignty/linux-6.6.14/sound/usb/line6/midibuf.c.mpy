{
  "module_name": "midibuf.c",
  "hash_id": "54a7d6d37847dc9326741338f5694ed27ccbf4bbc84e4c655e69d3bfc3010c69",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/midibuf.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"midibuf.h\"\n\n\nstatic int midibuf_message_length(unsigned char code)\n{\n\tint message_length;\n\n\tif (code < 0x80)\n\t\tmessage_length = -1;\n\telse if (code < 0xf0) {\n\t\tstatic const int length[] = { 3, 3, 3, 3, 2, 2, 3 };\n\n\t\tmessage_length = length[(code >> 4) - 8];\n\t} else {\n\t\tstatic const int length[] = { -1, 2, 2, 2, -1, -1, 1, 1, 1, -1,\n\t\t\t1, 1, 1, -1, 1, 1\n\t\t};\n\t\tmessage_length = length[code & 0x0f];\n\t}\n\n\treturn message_length;\n}\n\nstatic int midibuf_is_empty(struct midi_buffer *this)\n{\n\treturn (this->pos_read == this->pos_write) && !this->full;\n}\n\nstatic int midibuf_is_full(struct midi_buffer *this)\n{\n\treturn this->full;\n}\n\nvoid line6_midibuf_reset(struct midi_buffer *this)\n{\n\tthis->pos_read = this->pos_write = this->full = 0;\n\tthis->command_prev = -1;\n}\n\nint line6_midibuf_init(struct midi_buffer *this, int size, int split)\n{\n\tthis->buf = kmalloc(size, GFP_KERNEL);\n\n\tif (this->buf == NULL)\n\t\treturn -ENOMEM;\n\n\tthis->size = size;\n\tthis->split = split;\n\tline6_midibuf_reset(this);\n\treturn 0;\n}\n\nint line6_midibuf_bytes_free(struct midi_buffer *this)\n{\n\treturn\n\t    midibuf_is_full(this) ?\n\t    0 :\n\t    (this->pos_read - this->pos_write + this->size - 1) % this->size +\n\t    1;\n}\n\nint line6_midibuf_bytes_used(struct midi_buffer *this)\n{\n\treturn\n\t    midibuf_is_empty(this) ?\n\t    0 :\n\t    (this->pos_write - this->pos_read + this->size - 1) % this->size +\n\t    1;\n}\n\nint line6_midibuf_write(struct midi_buffer *this, unsigned char *data,\n\t\t\tint length)\n{\n\tint bytes_free;\n\tint length1, length2;\n\tint skip_active_sense = 0;\n\n\tif (midibuf_is_full(this) || (length <= 0))\n\t\treturn 0;\n\n\t \n\tif (data[length - 1] == 0xfe) {\n\t\t--length;\n\t\tskip_active_sense = 1;\n\t}\n\n\tbytes_free = line6_midibuf_bytes_free(this);\n\n\tif (length > bytes_free)\n\t\tlength = bytes_free;\n\n\tif (length > 0) {\n\t\tlength1 = this->size - this->pos_write;\n\n\t\tif (length < length1) {\n\t\t\t \n\t\t\tmemcpy(this->buf + this->pos_write, data, length);\n\t\t\tthis->pos_write += length;\n\t\t} else {\n\t\t\t \n\t\t\tlength2 = length - length1;\n\t\t\tmemcpy(this->buf + this->pos_write, data, length1);\n\t\t\tmemcpy(this->buf, data + length1, length2);\n\t\t\tthis->pos_write = length2;\n\t\t}\n\n\t\tif (this->pos_write == this->pos_read)\n\t\t\tthis->full = 1;\n\t}\n\n\treturn length + skip_active_sense;\n}\n\nint line6_midibuf_read(struct midi_buffer *this, unsigned char *data,\n\t\t       int length, int read_type)\n{\n\tint bytes_used;\n\tint length1, length2;\n\tint command;\n\tint midi_length;\n\tint repeat = 0;\n\tint i;\n\n\t \n\tif (length < 3)\n\t\treturn -EINVAL;\n\n\tif (midibuf_is_empty(this))\n\t\treturn 0;\n\n\tbytes_used = line6_midibuf_bytes_used(this);\n\n\tif (length > bytes_used)\n\t\tlength = bytes_used;\n\n\tlength1 = this->size - this->pos_read;\n\n\tcommand = this->buf[this->pos_read];\n\t \n\tif (read_type == LINE6_MIDIBUF_READ_RX) {\n\t\tif (command == 0xb2 || command == 0xc2 || command == 0xf2) {\n\t\t\tunsigned char fixed = command & 0xf0;\n\t\t\tthis->buf[this->pos_read] = fixed;\n\t\t\tcommand = fixed;\n\t\t}\n\t}\n\n\t \n\tif (command & 0x80) {\n\t\tmidi_length = midibuf_message_length(command);\n\t\tthis->command_prev = command;\n\t} else {\n\t\tif (this->command_prev > 0) {\n\t\t\tint midi_length_prev =\n\t\t\t    midibuf_message_length(this->command_prev);\n\n\t\t\tif (midi_length_prev > 1) {\n\t\t\t\tmidi_length = midi_length_prev - 1;\n\t\t\t\trepeat = 1;\n\t\t\t} else\n\t\t\t\tmidi_length = -1;\n\t\t} else\n\t\t\tmidi_length = -1;\n\t}\n\n\tif (midi_length < 0) {\n\t\t \n\t\tif (length < length1) {\n\t\t\t \n\t\t\tfor (i = 1; i < length; ++i)\n\t\t\t\tif (this->buf[this->pos_read + i] & 0x80)\n\t\t\t\t\tbreak;\n\n\t\t\tmidi_length = i;\n\t\t} else {\n\t\t\t \n\t\t\tlength2 = length - length1;\n\n\t\t\tfor (i = 1; i < length1; ++i)\n\t\t\t\tif (this->buf[this->pos_read + i] & 0x80)\n\t\t\t\t\tbreak;\n\n\t\t\tif (i < length1)\n\t\t\t\tmidi_length = i;\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < length2; ++i)\n\t\t\t\t\tif (this->buf[i] & 0x80)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tmidi_length = length1 + i;\n\t\t\t}\n\t\t}\n\n\t\tif (midi_length == length)\n\t\t\tmidi_length = -1;\t \n\t}\n\n\tif (midi_length < 0) {\n\t\tif (!this->split)\n\t\t\treturn 0;\t \n\t} else {\n\t\tif (length < midi_length)\n\t\t\treturn 0;\t \n\n\t\tlength = midi_length;\n\t}\n\n\tif (length < length1) {\n\t\t \n\t\tmemcpy(data + repeat, this->buf + this->pos_read, length);\n\t\tthis->pos_read += length;\n\t} else {\n\t\t \n\t\tlength2 = length - length1;\n\t\tmemcpy(data + repeat, this->buf + this->pos_read, length1);\n\t\tmemcpy(data + repeat + length1, this->buf, length2);\n\t\tthis->pos_read = length2;\n\t}\n\n\tif (repeat)\n\t\tdata[0] = this->command_prev;\n\n\tthis->full = 0;\n\treturn length + repeat;\n}\n\nint line6_midibuf_ignore(struct midi_buffer *this, int length)\n{\n\tint bytes_used = line6_midibuf_bytes_used(this);\n\n\tif (length > bytes_used)\n\t\tlength = bytes_used;\n\n\tthis->pos_read = (this->pos_read + length) % this->size;\n\tthis->full = 0;\n\treturn length;\n}\n\nvoid line6_midibuf_destroy(struct midi_buffer *this)\n{\n\tkfree(this->buf);\n\tthis->buf = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}