{
  "module_name": "variax.c",
  "hash_id": "c4d7612ac5cfee6a8dd9c9189622fa6161c8607c6ddccdf4a78b1ddb4e7eeca6",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/variax.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <sound/core.h>\n\n#include \"driver.h\"\n\n#define VARIAX_STARTUP_DELAY1 1000\n#define VARIAX_STARTUP_DELAY3 100\n#define VARIAX_STARTUP_DELAY4 100\n\n \nenum {\n\tVARIAX_STARTUP_VERSIONREQ,\n\tVARIAX_STARTUP_ACTIVATE,\n\tVARIAX_STARTUP_SETUP,\n};\n\nenum {\n\tLINE6_PODXTLIVE_VARIAX,\n\tLINE6_VARIAX\n};\n\nstruct usb_line6_variax {\n\t \n\tstruct usb_line6 line6;\n\n\t \n\tunsigned char *buffer_activate;\n\n\t \n\tint startup_progress;\n};\n\n#define line6_to_variax(x)\tcontainer_of(x, struct usb_line6_variax, line6)\n\n#define VARIAX_OFFSET_ACTIVATE 7\n\n \nstatic const char variax_init_version[] = {\n\t0xf0, 0x7e, 0x7f, 0x06, 0x02, 0x00, 0x01, 0x0c,\n\t0x07, 0x00, 0x00, 0x00\n};\n\n \nstatic const char variax_init_done[] = {\n\t0xf0, 0x00, 0x01, 0x0c, 0x07, 0x00, 0x6b\n};\n\nstatic const char variax_activate[] = {\n\t0xf0, 0x00, 0x01, 0x0c, 0x07, 0x00, 0x2a, 0x01,\n\t0xf7\n};\n\nstatic void variax_activate_async(struct usb_line6_variax *variax, int a)\n{\n\tvariax->buffer_activate[VARIAX_OFFSET_ACTIVATE] = a;\n\tline6_send_raw_message_async(&variax->line6, variax->buffer_activate,\n\t\t\t\t     sizeof(variax_activate));\n}\n\n \n\nstatic void variax_startup(struct usb_line6 *line6)\n{\n\tstruct usb_line6_variax *variax = line6_to_variax(line6);\n\n\tswitch (variax->startup_progress) {\n\tcase VARIAX_STARTUP_VERSIONREQ:\n\t\t \n\t\tschedule_delayed_work(&line6->startup_work,\n\t\t\t\t      msecs_to_jiffies(VARIAX_STARTUP_DELAY1));\n\t\t \n\t\tline6_version_request_async(line6);\n\t\tbreak;\n\tcase VARIAX_STARTUP_ACTIVATE:\n\t\t \n\t\tvariax_activate_async(variax, 1);\n\t\tvariax->startup_progress = VARIAX_STARTUP_SETUP;\n\t\tschedule_delayed_work(&line6->startup_work,\n\t\t\t\t      msecs_to_jiffies(VARIAX_STARTUP_DELAY4));\n\t\tbreak;\n\tcase VARIAX_STARTUP_SETUP:\n\t\t \n\t\tsnd_card_register(variax->line6.card);\n\t\tbreak;\n\t}\n}\n\n \nstatic void line6_variax_process_message(struct usb_line6 *line6)\n{\n\tstruct usb_line6_variax *variax = line6_to_variax(line6);\n\tconst unsigned char *buf = variax->line6.buffer_message;\n\n\tswitch (buf[0]) {\n\tcase LINE6_RESET:\n\t\tdev_info(variax->line6.ifcdev, \"VARIAX reset\\n\");\n\t\tbreak;\n\n\tcase LINE6_SYSEX_BEGIN:\n\t\tif (memcmp(buf + 1, variax_init_version + 1,\n\t\t\t   sizeof(variax_init_version) - 1) == 0) {\n\t\t\tif (variax->startup_progress >= VARIAX_STARTUP_ACTIVATE)\n\t\t\t\tbreak;\n\t\t\tvariax->startup_progress = VARIAX_STARTUP_ACTIVATE;\n\t\t\tcancel_delayed_work(&line6->startup_work);\n\t\t\tschedule_delayed_work(&line6->startup_work,\n\t\t\t\t\t      msecs_to_jiffies(VARIAX_STARTUP_DELAY3));\n\t\t} else if (memcmp(buf + 1, variax_init_done + 1,\n\t\t\t\t  sizeof(variax_init_done) - 1) == 0) {\n\t\t\t \n\t\t\tif (variax->startup_progress >= VARIAX_STARTUP_SETUP)\n\t\t\t\tbreak;\n\t\t\tcancel_delayed_work(&line6->startup_work);\n\t\t\tschedule_delayed_work(&line6->startup_work, 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void line6_variax_disconnect(struct usb_line6 *line6)\n{\n\tstruct usb_line6_variax *variax = line6_to_variax(line6);\n\n\tkfree(variax->buffer_activate);\n}\n\n \nstatic int variax_init(struct usb_line6 *line6,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_line6_variax *variax = line6_to_variax(line6);\n\n\tline6->process_message = line6_variax_process_message;\n\tline6->disconnect = line6_variax_disconnect;\n\tline6->startup = variax_startup;\n\n\t \n\tvariax->buffer_activate = kmemdup(variax_activate,\n\t\t\t\t\t  sizeof(variax_activate), GFP_KERNEL);\n\n\tif (variax->buffer_activate == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tschedule_delayed_work(&line6->startup_work,\n\t\t\t      msecs_to_jiffies(VARIAX_STARTUP_DELAY1));\n\treturn 0;\n}\n\n#define LINE6_DEVICE(prod) USB_DEVICE(0x0e41, prod)\n#define LINE6_IF_NUM(prod, n) USB_DEVICE_INTERFACE_NUMBER(0x0e41, prod, n)\n\n \nstatic const struct usb_device_id variax_id_table[] = {\n\t{ LINE6_IF_NUM(0x4650, 1), .driver_info = LINE6_PODXTLIVE_VARIAX },\n\t{ LINE6_DEVICE(0x534d),    .driver_info = LINE6_VARIAX },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, variax_id_table);\n\nstatic const struct line6_properties variax_properties_table[] = {\n\t[LINE6_PODXTLIVE_VARIAX] = {\n\t\t.id = \"PODxtLive\",\n\t\t.name = \"PODxt Live\",\n\t\t.capabilities\t= LINE6_CAP_CONTROL\n\t\t\t\t| LINE6_CAP_CONTROL_MIDI,\n\t\t.altsetting = 1,\n\t\t.ep_ctrl_r = 0x86,\n\t\t.ep_ctrl_w = 0x05,\n\t\t.ep_audio_r = 0x82,\n\t\t.ep_audio_w = 0x01,\n\t},\n\t[LINE6_VARIAX] = {\n\t\t.id = \"Variax\",\n\t\t.name = \"Variax Workbench\",\n\t\t.capabilities\t= LINE6_CAP_CONTROL\n\t\t\t\t| LINE6_CAP_CONTROL_MIDI,\n\t\t.altsetting = 1,\n\t\t.ep_ctrl_r = 0x82,\n\t\t.ep_ctrl_w = 0x01,\n\t\t \n\t}\n};\n\n \nstatic int variax_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn line6_probe(interface, id, \"Line6-Variax\",\n\t\t\t   &variax_properties_table[id->driver_info],\n\t\t\t   variax_init, sizeof(struct usb_line6_variax));\n}\n\nstatic struct usb_driver variax_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = variax_probe,\n\t.disconnect = line6_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = line6_suspend,\n\t.resume = line6_resume,\n\t.reset_resume = line6_resume,\n#endif\n\t.id_table = variax_id_table,\n};\n\nmodule_usb_driver(variax_driver);\n\nMODULE_DESCRIPTION(\"Variax Workbench USB driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}