{
  "module_name": "driver.c",
  "hash_id": "ab1ac2e022b7fa0ab82f1404ca194e8ad770121bb75ce10a4b329f36a7d8954a",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/driver.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/hwdep.h>\n\n#include \"capture.h\"\n#include \"driver.h\"\n#include \"midi.h\"\n#include \"playback.h\"\n\n#define DRIVER_AUTHOR  \"Markus Grabner <grabner@icg.tugraz.at>\"\n#define DRIVER_DESC    \"Line 6 USB Driver\"\n\n \nconst unsigned char line6_midi_id[3] = {\n\t0x00, 0x01, 0x0c\n};\nEXPORT_SYMBOL_GPL(line6_midi_id);\n\n \nstatic const char line6_request_version[] = {\n\t0xf0, 0x7e, 0x7f, 0x06, 0x01, 0xf7\n};\n\n \nstruct message {\n\tstruct usb_line6 *line6;\n\tconst char *buffer;\n\tint size;\n\tint done;\n};\n\n \nstatic void line6_data_received(struct urb *urb);\nstatic int line6_send_raw_message_async_part(struct message *msg,\n\t\t\t\t\t     struct urb *urb);\n\n \nstatic int line6_start_listen(struct usb_line6 *line6)\n{\n\tint err;\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tusb_fill_int_urb(line6->urb_listen, line6->usbdev,\n\t\t\tusb_rcvintpipe(line6->usbdev, line6->properties->ep_ctrl_r),\n\t\t\tline6->buffer_listen, LINE6_BUFSIZE_LISTEN,\n\t\t\tline6_data_received, line6, line6->interval);\n\t} else {\n\t\tusb_fill_bulk_urb(line6->urb_listen, line6->usbdev,\n\t\t\tusb_rcvbulkpipe(line6->usbdev, line6->properties->ep_ctrl_r),\n\t\t\tline6->buffer_listen, LINE6_BUFSIZE_LISTEN,\n\t\t\tline6_data_received, line6);\n\t}\n\n\t \n\tif (usb_urb_ep_type_check(line6->urb_listen)) {\n\t\tdev_err(line6->ifcdev, \"invalid control EP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tline6->urb_listen->actual_length = 0;\n\terr = usb_submit_urb(line6->urb_listen, GFP_ATOMIC);\n\treturn err;\n}\n\n \nstatic void line6_stop_listen(struct usb_line6 *line6)\n{\n\tusb_kill_urb(line6->urb_listen);\n}\n\n \nint line6_send_raw_message(struct usb_line6 *line6, const char *buffer,\n\t\t\t\t  int size)\n{\n\tint i, done = 0;\n\tconst struct line6_properties *properties = line6->properties;\n\n\tfor (i = 0; i < size; i += line6->max_packet_size) {\n\t\tint partial;\n\t\tconst char *frag_buf = buffer + i;\n\t\tint frag_size = min(line6->max_packet_size, size - i);\n\t\tint retval;\n\n\t\tif (properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\t\tretval = usb_interrupt_msg(line6->usbdev,\n\t\t\t\t\t\tusb_sndintpipe(line6->usbdev, properties->ep_ctrl_w),\n\t\t\t\t\t\t(char *)frag_buf, frag_size,\n\t\t\t\t\t\t&partial, LINE6_TIMEOUT);\n\t\t} else {\n\t\t\tretval = usb_bulk_msg(line6->usbdev,\n\t\t\t\t\t\tusb_sndbulkpipe(line6->usbdev, properties->ep_ctrl_w),\n\t\t\t\t\t\t(char *)frag_buf, frag_size,\n\t\t\t\t\t\t&partial, LINE6_TIMEOUT);\n\t\t}\n\n\t\tif (retval) {\n\t\t\tdev_err(line6->ifcdev,\n\t\t\t\t\"usb_bulk_msg failed (%d)\\n\", retval);\n\t\t\tbreak;\n\t\t}\n\n\t\tdone += frag_size;\n\t}\n\n\treturn done;\n}\nEXPORT_SYMBOL_GPL(line6_send_raw_message);\n\n \nstatic void line6_async_request_sent(struct urb *urb)\n{\n\tstruct message *msg = (struct message *)urb->context;\n\n\tif (msg->done >= msg->size) {\n\t\tusb_free_urb(urb);\n\t\tkfree(msg);\n\t} else\n\t\tline6_send_raw_message_async_part(msg, urb);\n}\n\n \nstatic int line6_send_raw_message_async_part(struct message *msg,\n\t\t\t\t\t     struct urb *urb)\n{\n\tint retval;\n\tstruct usb_line6 *line6 = msg->line6;\n\tint done = msg->done;\n\tint bytes = min(msg->size - done, line6->max_packet_size);\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tusb_fill_int_urb(urb, line6->usbdev,\n\t\t\tusb_sndintpipe(line6->usbdev, line6->properties->ep_ctrl_w),\n\t\t\t(char *)msg->buffer + done, bytes,\n\t\t\tline6_async_request_sent, msg, line6->interval);\n\t} else {\n\t\tusb_fill_bulk_urb(urb, line6->usbdev,\n\t\t\tusb_sndbulkpipe(line6->usbdev, line6->properties->ep_ctrl_w),\n\t\t\t(char *)msg->buffer + done, bytes,\n\t\t\tline6_async_request_sent, msg);\n\t}\n\n\tmsg->done += bytes;\n\n\t \n\tretval = usb_urb_ep_type_check(urb);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tdev_err(line6->ifcdev, \"%s: usb_submit_urb failed (%d)\\n\",\n\t\t__func__, retval);\n\tusb_free_urb(urb);\n\tkfree(msg);\n\treturn retval;\n}\n\n \nint line6_send_raw_message_async(struct usb_line6 *line6, const char *buffer,\n\t\t\t\t int size)\n{\n\tstruct message *msg;\n\tstruct urb *urb;\n\n\t \n\tmsg = kmalloc(sizeof(struct message), GFP_ATOMIC);\n\tif (msg == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\n\tif (urb == NULL) {\n\t\tkfree(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmsg->line6 = line6;\n\tmsg->buffer = buffer;\n\tmsg->size = size;\n\tmsg->done = 0;\n\n\t \n\treturn line6_send_raw_message_async_part(msg, urb);\n}\nEXPORT_SYMBOL_GPL(line6_send_raw_message_async);\n\n \nint line6_version_request_async(struct usb_line6 *line6)\n{\n\tchar *buffer;\n\tint retval;\n\n\tbuffer = kmemdup(line6_request_version,\n\t\t\tsizeof(line6_request_version), GFP_ATOMIC);\n\tif (buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tretval = line6_send_raw_message_async(line6, buffer,\n\t\t\t\t\t      sizeof(line6_request_version));\n\tkfree(buffer);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(line6_version_request_async);\n\n \nint line6_send_sysex_message(struct usb_line6 *line6, const char *buffer,\n\t\t\t     int size)\n{\n\treturn line6_send_raw_message(line6, buffer,\n\t\t\t\t      size + SYSEX_EXTRA_SIZE) -\n\t    SYSEX_EXTRA_SIZE;\n}\nEXPORT_SYMBOL_GPL(line6_send_sysex_message);\n\n \nchar *line6_alloc_sysex_buffer(struct usb_line6 *line6, int code1, int code2,\n\t\t\t       int size)\n{\n\tchar *buffer = kmalloc(size + SYSEX_EXTRA_SIZE, GFP_ATOMIC);\n\n\tif (!buffer)\n\t\treturn NULL;\n\n\tbuffer[0] = LINE6_SYSEX_BEGIN;\n\tmemcpy(buffer + 1, line6_midi_id, sizeof(line6_midi_id));\n\tbuffer[sizeof(line6_midi_id) + 1] = code1;\n\tbuffer[sizeof(line6_midi_id) + 2] = code2;\n\tbuffer[sizeof(line6_midi_id) + 3 + size] = LINE6_SYSEX_END;\n\treturn buffer;\n}\nEXPORT_SYMBOL_GPL(line6_alloc_sysex_buffer);\n\n \nstatic void line6_data_received(struct urb *urb)\n{\n\tstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\n\tstruct midi_buffer *mb = &line6->line6midi->midibuf_in;\n\tint done;\n\n\tif (urb->status == -ESHUTDOWN)\n\t\treturn;\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tdone =\n\t\t\tline6_midibuf_write(mb, urb->transfer_buffer, urb->actual_length);\n\n\t\tif (done < urb->actual_length) {\n\t\t\tline6_midibuf_ignore(mb, done);\n\t\t\tdev_dbg(line6->ifcdev, \"%d %d buffer overflow - message skipped\\n\",\n\t\t\t\tdone, urb->actual_length);\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tdone =\n\t\t\t\tline6_midibuf_read(mb, line6->buffer_message,\n\t\t\t\t\t\t   LINE6_MIDI_MESSAGE_MAXLEN,\n\t\t\t\t\t\t   LINE6_MIDIBUF_READ_RX);\n\n\t\t\tif (done <= 0)\n\t\t\t\tbreak;\n\n\t\t\tline6->message_length = done;\n\t\t\tline6_midi_receive(line6, line6->buffer_message, done);\n\n\t\t\tif (line6->process_message)\n\t\t\t\tline6->process_message(line6);\n\t\t}\n\t} else {\n\t\tline6->buffer_message = urb->transfer_buffer;\n\t\tline6->message_length = urb->actual_length;\n\t\tif (line6->process_message)\n\t\t\tline6->process_message(line6);\n\t\tline6->buffer_message = NULL;\n\t}\n\n\tline6_start_listen(line6);\n}\n\n#define LINE6_READ_WRITE_STATUS_DELAY 2   \n#define LINE6_READ_WRITE_MAX_RETRIES 50\n\n \nint line6_read_data(struct usb_line6 *line6, unsigned address, void *data,\n\t\t    unsigned datalen)\n{\n\tstruct usb_device *usbdev = line6->usbdev;\n\tint ret;\n\tu8 len;\n\tunsigned count;\n\n\tif (address > 0xffff || datalen > 0xff)\n\t\treturn -EINVAL;\n\n\t \n\tret = usb_control_msg_send(usbdev, 0, 0x67,\n\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t\t   (datalen << 8) | 0x21, address, NULL, 0,\n\t\t\t\t   LINE6_TIMEOUT, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(line6->ifcdev, \"read request failed (error %d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\t \n\tfor (count = 0; count < LINE6_READ_WRITE_MAX_RETRIES; count++) {\n\t\tmdelay(LINE6_READ_WRITE_STATUS_DELAY);\n\n\t\tret = usb_control_msg_recv(usbdev, 0, 0x67,\n\t\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t\t\t   0x0012, 0x0000, &len, 1,\n\t\t\t\t\t   LINE6_TIMEOUT, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(line6->ifcdev,\n\t\t\t\t\"receive length failed (error %d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (len != 0xff)\n\t\t\tbreak;\n\t}\n\n\tret = -EIO;\n\tif (len == 0xff) {\n\t\tdev_err(line6->ifcdev, \"read failed after %d retries\\n\",\n\t\t\tcount);\n\t\tgoto exit;\n\t} else if (len != datalen) {\n\t\t \n\t\tdev_err(line6->ifcdev,\n\t\t\t\"length mismatch (expected %d, got %d)\\n\",\n\t\t\t(int)datalen, len);\n\t\tgoto exit;\n\t}\n\n\t \n\tret = usb_control_msg_recv(usbdev, 0, 0x67,\n\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t\t   0x0013, 0x0000, data, datalen, LINE6_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\tif (ret)\n\t\tdev_err(line6->ifcdev, \"read failed (error %d)\\n\", ret);\n\nexit:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(line6_read_data);\n\n \nint line6_write_data(struct usb_line6 *line6, unsigned address, void *data,\n\t\t     unsigned datalen)\n{\n\tstruct usb_device *usbdev = line6->usbdev;\n\tint ret;\n\tunsigned char *status;\n\tint count;\n\n\tif (address > 0xffff || datalen > 0xffff)\n\t\treturn -EINVAL;\n\n\tstatus = kmalloc(1, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg_send(usbdev, 0, 0x67,\n\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t\t   0x0022, address, data, datalen, LINE6_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(line6->ifcdev,\n\t\t\t\"write request failed (error %d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tfor (count = 0; count < LINE6_READ_WRITE_MAX_RETRIES; count++) {\n\t\tmdelay(LINE6_READ_WRITE_STATUS_DELAY);\n\n\t\tret = usb_control_msg_recv(usbdev, 0, 0x67,\n\t\t\t\t\t   USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t\t\t   0x0012, 0x0000, status, 1, LINE6_TIMEOUT,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(line6->ifcdev,\n\t\t\t\t\"receiving status failed (error %d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (*status != 0xff)\n\t\t\tbreak;\n\t}\n\n\tif (*status == 0xff) {\n\t\tdev_err(line6->ifcdev, \"write failed after %d retries\\n\",\n\t\t\tcount);\n\t\tret = -EIO;\n\t} else if (*status != 0) {\n\t\tdev_err(line6->ifcdev, \"write failed (error %d)\\n\", ret);\n\t\tret = -EIO;\n\t}\nexit:\n\tkfree(status);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(line6_write_data);\n\n \nint line6_read_serial_number(struct usb_line6 *line6, u32 *serial_number)\n{\n\treturn line6_read_data(line6, 0x80d0, serial_number,\n\t\t\t       sizeof(*serial_number));\n}\nEXPORT_SYMBOL_GPL(line6_read_serial_number);\n\n \nstatic void line6_destruct(struct snd_card *card)\n{\n\tstruct usb_line6 *line6 = card->private_data;\n\tstruct usb_device *usbdev = line6->usbdev;\n\n\t \n\tkfree(line6->buffer_message);\n\n\tkfree(line6->buffer_listen);\n\n\t \n\tusb_free_urb(line6->urb_listen);\n\tline6->urb_listen = NULL;\n\n\t \n\tusb_put_dev(usbdev);\n}\n\nstatic void line6_get_usb_properties(struct usb_line6 *line6)\n{\n\tstruct usb_device *usbdev = line6->usbdev;\n\tconst struct line6_properties *properties = line6->properties;\n\tint pipe;\n\tstruct usb_host_endpoint *ep = NULL;\n\n\tif (properties->capabilities & LINE6_CAP_CONTROL) {\n\t\tif (properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\t\tpipe = usb_rcvintpipe(line6->usbdev,\n\t\t\t\tline6->properties->ep_ctrl_r);\n\t\t} else {\n\t\t\tpipe = usb_rcvbulkpipe(line6->usbdev,\n\t\t\t\tline6->properties->ep_ctrl_r);\n\t\t}\n\t\tep = usbdev->ep_in[usb_pipeendpoint(pipe)];\n\t}\n\n\t \n\tif (ep) {\n\t\tline6->interval = ep->desc.bInterval;\n\t\tline6->max_packet_size = le16_to_cpu(ep->desc.wMaxPacketSize);\n\t} else {\n\t\tif (properties->capabilities & LINE6_CAP_CONTROL) {\n\t\t\tdev_err(line6->ifcdev,\n\t\t\t\t\"endpoint not available, using fallback values\");\n\t\t}\n\t\tline6->interval = LINE6_FALLBACK_INTERVAL;\n\t\tline6->max_packet_size = LINE6_FALLBACK_MAXPACKETSIZE;\n\t}\n\n\t \n\tif (usbdev->speed == USB_SPEED_LOW) {\n\t\tline6->intervals_per_second = USB_LOW_INTERVALS_PER_SECOND;\n\t\tline6->iso_buffers = USB_LOW_ISO_BUFFERS;\n\t} else {\n\t\tline6->intervals_per_second = USB_HIGH_INTERVALS_PER_SECOND;\n\t\tline6->iso_buffers = USB_HIGH_ISO_BUFFERS;\n\t}\n}\n\n \nstatic int line6_hwdep_open(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct usb_line6 *line6 = hw->private_data;\n\n\t \n\n\tline6->messages.active = 1;\n\tline6->messages.nonblock = file->f_flags & O_NONBLOCK ? 1 : 0;\n\n\treturn 0;\n}\n\n \nstatic int line6_hwdep_release(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct usb_line6 *line6 = hw->private_data;\n\n\tline6->messages.active = 0;\n\n\treturn 0;\n}\n\n \nstatic long\nline6_hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,\n\t\t\t\t\tloff_t *offset)\n{\n\tstruct usb_line6 *line6 = hwdep->private_data;\n\tlong rv = 0;\n\tunsigned int out_count;\n\n\tif (mutex_lock_interruptible(&line6->messages.read_lock))\n\t\treturn -ERESTARTSYS;\n\n\twhile (kfifo_len(&line6->messages.fifo) == 0) {\n\t\tmutex_unlock(&line6->messages.read_lock);\n\n\t\tif (line6->messages.nonblock)\n\t\t\treturn -EAGAIN;\n\n\t\trv = wait_event_interruptible(\n\t\t\tline6->messages.wait_queue,\n\t\t\tkfifo_len(&line6->messages.fifo) != 0);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\n\t\tif (mutex_lock_interruptible(&line6->messages.read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (kfifo_peek_len(&line6->messages.fifo) > count) {\n\t\t \n\t\trv = -EINVAL;\n\t} else {\n\t\trv = kfifo_to_user(&line6->messages.fifo, buf, count, &out_count);\n\t\tif (rv == 0)\n\t\t\trv = out_count;\n\t}\n\n\tmutex_unlock(&line6->messages.read_lock);\n\treturn rv;\n}\n\n \nstatic long\nline6_hwdep_write(struct snd_hwdep *hwdep, const char __user *data, long count,\n\t\t\t\t\tloff_t *offset)\n{\n\tstruct usb_line6 *line6 = hwdep->private_data;\n\tint rv;\n\tchar *data_copy;\n\n\tif (count > line6->max_packet_size * LINE6_RAW_MESSAGES_MAXCOUNT) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tdata_copy = memdup_user(data, count);\n\tif (IS_ERR(data_copy))\n\t\treturn PTR_ERR(data_copy);\n\n\trv = line6_send_raw_message(line6, data_copy, count);\n\n\tkfree(data_copy);\n\treturn rv;\n}\n\nstatic __poll_t\nline6_hwdep_poll(struct snd_hwdep *hwdep, struct file *file, poll_table *wait)\n{\n\t__poll_t rv;\n\tstruct usb_line6 *line6 = hwdep->private_data;\n\n\tpoll_wait(file, &line6->messages.wait_queue, wait);\n\n\tmutex_lock(&line6->messages.read_lock);\n\trv = kfifo_len(&line6->messages.fifo) == 0 ? 0 : EPOLLIN | EPOLLRDNORM;\n\tmutex_unlock(&line6->messages.read_lock);\n\n\treturn rv;\n}\n\nstatic const struct snd_hwdep_ops hwdep_ops = {\n\t.open    = line6_hwdep_open,\n\t.release = line6_hwdep_release,\n\t.read    = line6_hwdep_read,\n\t.write   = line6_hwdep_write,\n\t.poll    = line6_hwdep_poll,\n};\n\n \nstatic void line6_hwdep_push_message(struct usb_line6 *line6)\n{\n\tif (!line6->messages.active)\n\t\treturn;\n\n\tif (kfifo_avail(&line6->messages.fifo) >= line6->message_length) {\n\t\t \n\t\tkfifo_in(&line6->messages.fifo,\n\t\t\tline6->buffer_message, line6->message_length);\n\t}  \n\n\twake_up_interruptible(&line6->messages.wait_queue);\n}\n\nstatic int line6_hwdep_init(struct usb_line6 *line6)\n{\n\tint err;\n\tstruct snd_hwdep *hwdep;\n\n\t \n\tline6->process_message = line6_hwdep_push_message;\n\tline6->messages.active = 0;\n\tinit_waitqueue_head(&line6->messages.wait_queue);\n\tmutex_init(&line6->messages.read_lock);\n\tINIT_KFIFO(line6->messages.fifo);\n\n\terr = snd_hwdep_new(line6->card, \"config\", 0, &hwdep);\n\tif (err < 0)\n\t\tgoto end;\n\tstrcpy(hwdep->name, \"config\");\n\thwdep->iface = SNDRV_HWDEP_IFACE_LINE6;\n\thwdep->ops = hwdep_ops;\n\thwdep->private_data = line6;\n\thwdep->exclusive = true;\n\nend:\n\treturn err;\n}\n\nstatic int line6_init_cap_control(struct usb_line6 *line6)\n{\n\tint ret;\n\n\t \n\tline6->buffer_listen = kmalloc(LINE6_BUFSIZE_LISTEN, GFP_KERNEL);\n\tif (!line6->buffer_listen)\n\t\treturn -ENOMEM;\n\n\tline6->urb_listen = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!line6->urb_listen)\n\t\treturn -ENOMEM;\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tline6->buffer_message = kmalloc(LINE6_MIDI_MESSAGE_MAXLEN, GFP_KERNEL);\n\t\tif (!line6->buffer_message)\n\t\t\treturn -ENOMEM;\n\n\t\tret = line6_init_midi(line6);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = line6_hwdep_init(line6);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = line6_start_listen(line6);\n\tif (ret < 0) {\n\t\tdev_err(line6->ifcdev, \"cannot start listening: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void line6_startup_work(struct work_struct *work)\n{\n\tstruct usb_line6 *line6 =\n\t\tcontainer_of(work, struct usb_line6, startup_work.work);\n\n\tif (line6->startup)\n\t\tline6->startup(line6);\n}\n\n \nint line6_probe(struct usb_interface *interface,\n\t\tconst struct usb_device_id *id,\n\t\tconst char *driver_name,\n\t\tconst struct line6_properties *properties,\n\t\tint (*private_init)(struct usb_line6 *, const struct usb_device_id *id),\n\t\tsize_t data_size)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tstruct snd_card *card;\n\tstruct usb_line6 *line6;\n\tint interface_number;\n\tint ret;\n\n\tif (WARN_ON(data_size < sizeof(*line6)))\n\t\treturn -EINVAL;\n\n\t \n\tif (usbdev->descriptor.bNumConfigurations != 1)\n\t\treturn -ENODEV;\n\n\tret = snd_card_new(&interface->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, data_size, &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tline6 = card->private_data;\n\tline6->card = card;\n\tline6->properties = properties;\n\tline6->usbdev = usbdev;\n\tline6->ifcdev = &interface->dev;\n\tINIT_DELAYED_WORK(&line6->startup_work, line6_startup_work);\n\n\tstrcpy(card->id, properties->id);\n\tstrcpy(card->driver, driver_name);\n\tstrcpy(card->shortname, properties->name);\n\tsprintf(card->longname, \"Line 6 %s at USB %s\", properties->name,\n\t\tdev_name(line6->ifcdev));\n\tcard->private_free = line6_destruct;\n\n\tusb_set_intfdata(interface, line6);\n\n\t \n\tusb_get_dev(usbdev);\n\n\t \n\tdev_info(&interface->dev, \"Line 6 %s found\\n\", properties->name);\n\n\t \n\tinterface_number = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tret = usb_set_interface(usbdev, interface_number,\n\t\t\t\tproperties->altsetting);\n\tif (ret < 0) {\n\t\tdev_err(&interface->dev, \"set_interface failed\\n\");\n\t\tgoto error;\n\t}\n\n\tline6_get_usb_properties(line6);\n\n\tif (properties->capabilities & LINE6_CAP_CONTROL) {\n\t\tret = line6_init_cap_control(line6);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tret = private_init(line6, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\n\tdev_info(&interface->dev, \"Line 6 %s now attached\\n\",\n\t\t properties->name);\n\n\treturn 0;\n\n error:\n\t \n\tline6_disconnect(interface);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(line6_probe);\n\n \nvoid line6_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_line6 *line6 = usb_get_intfdata(interface);\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\n\tif (!line6)\n\t\treturn;\n\n\tif (WARN_ON(usbdev != line6->usbdev))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&line6->startup_work);\n\n\tif (line6->urb_listen != NULL)\n\t\tline6_stop_listen(line6);\n\n\tsnd_card_disconnect(line6->card);\n\tif (line6->line6pcm)\n\t\tline6_pcm_disconnect(line6->line6pcm);\n\tif (line6->disconnect)\n\t\tline6->disconnect(line6);\n\n\tdev_info(&interface->dev, \"Line 6 %s now disconnected\\n\",\n\t\t line6->properties->name);\n\n\t \n\tusb_set_intfdata(interface, NULL);\n\n\tsnd_card_free_when_closed(line6->card);\n}\nEXPORT_SYMBOL_GPL(line6_disconnect);\n\n#ifdef CONFIG_PM\n\n \nint line6_suspend(struct usb_interface *interface, pm_message_t message)\n{\n\tstruct usb_line6 *line6 = usb_get_intfdata(interface);\n\tstruct snd_line6_pcm *line6pcm = line6->line6pcm;\n\n\tsnd_power_change_state(line6->card, SNDRV_CTL_POWER_D3hot);\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL)\n\t\tline6_stop_listen(line6);\n\n\tif (line6pcm != NULL)\n\t\tline6pcm->flags = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(line6_suspend);\n\n \nint line6_resume(struct usb_interface *interface)\n{\n\tstruct usb_line6 *line6 = usb_get_intfdata(interface);\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL)\n\t\tline6_start_listen(line6);\n\n\tsnd_power_change_state(line6->card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(line6_resume);\n\n#endif  \n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}