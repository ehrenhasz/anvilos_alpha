{
  "module_name": "capture.c",
  "hash_id": "8fe399c2cc4cb661b18d21f881e971ae9b63b9144a3d8a4b91e0f2b3c78d2cb8",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/line6/capture.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"capture.h\"\n#include \"driver.h\"\n#include \"pcm.h\"\n\n \nstatic int submit_audio_in_urb(struct snd_line6_pcm *line6pcm)\n{\n\tint index;\n\tint i, urb_size;\n\tint ret;\n\tstruct urb *urb_in;\n\n\tindex = find_first_zero_bit(&line6pcm->in.active_urbs,\n\t\t\t\t    line6pcm->line6->iso_buffers);\n\n\tif (index < 0 || index >= line6pcm->line6->iso_buffers) {\n\t\tdev_err(line6pcm->line6->ifcdev, \"no free URB found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\turb_in = line6pcm->in.urbs[index];\n\turb_size = 0;\n\n\tfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\n\t\tstruct usb_iso_packet_descriptor *fin =\n\t\t    &urb_in->iso_frame_desc[i];\n\t\tfin->offset = urb_size;\n\t\tfin->length = line6pcm->max_packet_size_in;\n\t\turb_size += line6pcm->max_packet_size_in;\n\t}\n\n\turb_in->transfer_buffer =\n\t    line6pcm->in.buffer +\n\t    index * LINE6_ISO_PACKETS * line6pcm->max_packet_size_in;\n\turb_in->transfer_buffer_length = urb_size;\n\turb_in->context = line6pcm;\n\n\tret = usb_submit_urb(urb_in, GFP_ATOMIC);\n\n\tif (ret == 0)\n\t\tset_bit(index, &line6pcm->in.active_urbs);\n\telse\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"URB in #%d submission failed (%d)\\n\", index, ret);\n\n\treturn 0;\n}\n\n \nint line6_submit_audio_in_all_urbs(struct snd_line6_pcm *line6pcm)\n{\n\tint ret = 0, i;\n\n\tfor (i = 0; i < line6pcm->line6->iso_buffers; ++i) {\n\t\tret = submit_audio_in_urb(line6pcm);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nvoid line6_capture_copy(struct snd_line6_pcm *line6pcm, char *fbuf, int fsize)\n{\n\tstruct snd_pcm_substream *substream =\n\t    get_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tconst int bytes_per_frame =\n\t\tline6pcm->properties->bytes_per_channel *\n\t\tline6pcm->properties->capture_hw.channels_max;\n\tint frames = fsize / bytes_per_frame;\n\n\tif (runtime == NULL)\n\t\treturn;\n\n\tif (line6pcm->in.pos_done + frames > runtime->buffer_size) {\n\t\t \n\t\tint len;\n\n\t\tlen = runtime->buffer_size - line6pcm->in.pos_done;\n\n\t\tif (len > 0) {\n\t\t\tmemcpy(runtime->dma_area +\n\t\t\t       line6pcm->in.pos_done * bytes_per_frame, fbuf,\n\t\t\t       len * bytes_per_frame);\n\t\t\tmemcpy(runtime->dma_area, fbuf + len * bytes_per_frame,\n\t\t\t       (frames - len) * bytes_per_frame);\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\t\"driver bug: len = %d\\n\", len);\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(runtime->dma_area +\n\t\t       line6pcm->in.pos_done * bytes_per_frame, fbuf, fsize);\n\t}\n\n\tline6pcm->in.pos_done += frames;\n\tif (line6pcm->in.pos_done >= runtime->buffer_size)\n\t\tline6pcm->in.pos_done -= runtime->buffer_size;\n}\n\nvoid line6_capture_check_period(struct snd_line6_pcm *line6pcm, int length)\n{\n\tstruct snd_pcm_substream *substream =\n\t    get_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\n\n\tline6pcm->in.bytes += length;\n\tif (line6pcm->in.bytes >= line6pcm->in.period) {\n\t\tline6pcm->in.bytes %= line6pcm->in.period;\n\t\tspin_unlock(&line6pcm->in.lock);\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tspin_lock(&line6pcm->in.lock);\n\t}\n}\n\n \nstatic void audio_in_callback(struct urb *urb)\n{\n\tint i, index, length = 0, shutdown = 0;\n\tunsigned long flags;\n\n\tstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\n\n\tline6pcm->in.last_frame = urb->start_frame;\n\n\t \n\tfor (index = 0; index < line6pcm->line6->iso_buffers; ++index)\n\t\tif (urb == line6pcm->in.urbs[index])\n\t\t\tbreak;\n\n\tspin_lock_irqsave(&line6pcm->in.lock, flags);\n\n\tfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\n\t\tchar *fbuf;\n\t\tint fsize;\n\t\tstruct usb_iso_packet_descriptor *fin = &urb->iso_frame_desc[i];\n\n\t\tif (fin->status == -EXDEV) {\n\t\t\tshutdown = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfbuf = urb->transfer_buffer + fin->offset;\n\t\tfsize = fin->actual_length;\n\n\t\tif (fsize > line6pcm->max_packet_size_in) {\n\t\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\t\"driver and/or device bug: packet too large (%d > %d)\\n\",\n\t\t\t\tfsize, line6pcm->max_packet_size_in);\n\t\t}\n\n\t\tlength += fsize;\n\n\t\tBUILD_BUG_ON_MSG(LINE6_ISO_PACKETS != 1,\n\t\t\t\"The following code assumes LINE6_ISO_PACKETS == 1\");\n\t\t \n\n\t\tline6pcm->prev_fbuf = fbuf;\n\t\tline6pcm->prev_fsize = fsize /\n\t\t\t(line6pcm->properties->bytes_per_channel *\n\t\t\tline6pcm->properties->capture_hw.channels_max);\n\n\t\tif (!test_bit(LINE6_STREAM_IMPULSE, &line6pcm->in.running) &&\n\t\t    test_bit(LINE6_STREAM_PCM, &line6pcm->in.running) &&\n\t\t    fsize > 0)\n\t\t\tline6_capture_copy(line6pcm, fbuf, fsize);\n\t}\n\n\tclear_bit(index, &line6pcm->in.active_urbs);\n\n\tif (test_and_clear_bit(index, &line6pcm->in.unlink_urbs))\n\t\tshutdown = 1;\n\n\tif (!shutdown) {\n\t\tsubmit_audio_in_urb(line6pcm);\n\n\t\tif (!test_bit(LINE6_STREAM_IMPULSE, &line6pcm->in.running) &&\n\t\t    test_bit(LINE6_STREAM_PCM, &line6pcm->in.running))\n\t\t\tline6_capture_check_period(line6pcm, length);\n\t}\n\n\tspin_unlock_irqrestore(&line6pcm->in.lock, flags);\n}\n\n \nstatic int snd_line6_capture_open(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\n\terr = snd_pcm_hw_constraint_ratdens(runtime, 0,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    &line6pcm->properties->rates);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6_pcm_acquire(line6pcm, LINE6_STREAM_CAPTURE_HELPER, false);\n\n\truntime->hw = line6pcm->properties->capture_hw;\n\treturn 0;\n}\n\n \nstatic int snd_line6_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\n\n\tline6_pcm_release(line6pcm, LINE6_STREAM_CAPTURE_HELPER);\n\treturn 0;\n}\n\n \nconst struct snd_pcm_ops snd_line6_capture_ops = {\n\t.open = snd_line6_capture_open,\n\t.close = snd_line6_capture_close,\n\t.hw_params = snd_line6_hw_params,\n\t.hw_free = snd_line6_hw_free,\n\t.prepare = snd_line6_prepare,\n\t.trigger = snd_line6_trigger,\n\t.pointer = snd_line6_pointer,\n};\n\nint line6_create_audio_in_urbs(struct snd_line6_pcm *line6pcm)\n{\n\tstruct usb_line6 *line6 = line6pcm->line6;\n\tint i;\n\n\tline6pcm->in.urbs = kcalloc(line6->iso_buffers, sizeof(struct urb *),\n\t\t\t\t    GFP_KERNEL);\n\tif (line6pcm->in.urbs == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < line6->iso_buffers; ++i) {\n\t\tstruct urb *urb;\n\n\t\t \n\t\turb = line6pcm->in.urbs[i] =\n\t\t    usb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\n\n\t\tif (urb == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\turb->dev = line6->usbdev;\n\t\turb->pipe =\n\t\t    usb_rcvisocpipe(line6->usbdev,\n\t\t\t\t    line6->properties->ep_audio_r &\n\t\t\t\t    USB_ENDPOINT_NUMBER_MASK);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->start_frame = -1;\n\t\turb->number_of_packets = LINE6_ISO_PACKETS;\n\t\turb->interval = LINE6_ISO_INTERVAL;\n\t\turb->error_count = 0;\n\t\turb->complete = audio_in_callback;\n\t\tif (usb_urb_ep_type_check(urb))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}