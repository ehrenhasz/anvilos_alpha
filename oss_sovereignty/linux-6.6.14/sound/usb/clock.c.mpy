{
  "module_name": "clock.c",
  "hash_id": "01ecb1b375caf7e836fcef61e9ac47dd5b7c0584ef42cfc007dc9f2ef2153d16",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/clock.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"helper.h\"\n#include \"clock.h\"\n#include \"quirks.h\"\n\nunion uac23_clock_source_desc {\n\tstruct uac_clock_source_descriptor v2;\n\tstruct uac3_clock_source_descriptor v3;\n};\n\nunion uac23_clock_selector_desc {\n\tstruct uac_clock_selector_descriptor v2;\n\tstruct uac3_clock_selector_descriptor v3;\n};\n\nunion uac23_clock_multiplier_desc {\n\tstruct uac_clock_multiplier_descriptor v2;\n\tstruct uac_clock_multiplier_descriptor v3;\n};\n\n#define GET_VAL(p, proto, field) \\\n\t((proto) == UAC_VERSION_3 ? (p)->v3.field : (p)->v2.field)\n\nstatic void *find_uac_clock_desc(struct usb_host_interface *iface, int id,\n\t\t\t\t bool (*validator)(void *, int, int),\n\t\t\t\t u8 type, int proto)\n{\n\tvoid *cs = NULL;\n\n\twhile ((cs = snd_usb_find_csint_desc(iface->extra, iface->extralen,\n\t\t\t\t\t     cs, type))) {\n\t\tif (validator(cs, id, proto))\n\t\t\treturn cs;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool validate_clock_source(void *p, int id, int proto)\n{\n\tunion uac23_clock_source_desc *cs = p;\n\n\treturn GET_VAL(cs, proto, bClockID) == id;\n}\n\nstatic bool validate_clock_selector(void *p, int id, int proto)\n{\n\tunion uac23_clock_selector_desc *cs = p;\n\n\treturn GET_VAL(cs, proto, bClockID) == id;\n}\n\nstatic bool validate_clock_multiplier(void *p, int id, int proto)\n{\n\tunion uac23_clock_multiplier_desc *cs = p;\n\n\treturn GET_VAL(cs, proto, bClockID) == id;\n}\n\n#define DEFINE_FIND_HELPER(name, obj, validator, type2, type3)\t\t\\\nstatic obj *name(struct snd_usb_audio *chip, int id, int proto)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn find_uac_clock_desc(chip->ctrl_intf, id, validator,\t\\\n\t\t\t\t   proto == UAC_VERSION_3 ? (type3) : (type2), \\\n\t\t\t\t   proto);\t\t\t\t\\\n}\n\nDEFINE_FIND_HELPER(snd_usb_find_clock_source,\n\t\t   union uac23_clock_source_desc, validate_clock_source,\n\t\t   UAC2_CLOCK_SOURCE, UAC3_CLOCK_SOURCE);\nDEFINE_FIND_HELPER(snd_usb_find_clock_selector,\n\t\t   union uac23_clock_selector_desc, validate_clock_selector,\n\t\t   UAC2_CLOCK_SELECTOR, UAC3_CLOCK_SELECTOR);\nDEFINE_FIND_HELPER(snd_usb_find_clock_multiplier,\n\t\t   union uac23_clock_multiplier_desc, validate_clock_multiplier,\n\t\t   UAC2_CLOCK_MULTIPLIER, UAC3_CLOCK_MULTIPLIER);\n\nstatic int uac_clock_selector_get_val(struct snd_usb_audio *chip, int selector_id)\n{\n\tunsigned char buf;\n\tint ret;\n\n\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0),\n\t\t\t      UAC2_CS_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      UAC2_CX_CLOCK_SELECTOR << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (selector_id << 8),\n\t\t\t      &buf, sizeof(buf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf;\n}\n\nstatic int uac_clock_selector_set_val(struct snd_usb_audio *chip, int selector_id,\n\t\t\t\t\tunsigned char pin)\n{\n\tint ret;\n\n\tret = snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),\n\t\t\t      UAC2_CS_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t      UAC2_CX_CLOCK_SELECTOR << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (selector_id << 8),\n\t\t\t      &pin, sizeof(pin));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != sizeof(pin)) {\n\t\tusb_audio_err(chip,\n\t\t\t\"setting selector (id %d) unexpected length %d\\n\",\n\t\t\tselector_id, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = uac_clock_selector_get_val(chip, selector_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != pin) {\n\t\tusb_audio_err(chip,\n\t\t\t\"setting selector (id %d) to %x failed (current: %d)\\n\",\n\t\t\tselector_id, pin, ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic bool uac_clock_source_is_valid_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t    const struct audioformat *fmt,\n\t\t\t\t\t    int source_id)\n{\n\tbool ret = false;\n\tint count;\n\tunsigned char data;\n\tstruct usb_device *dev = chip->dev;\n\tunion uac23_clock_source_desc *cs_desc;\n\n\tcs_desc = snd_usb_find_clock_source(chip, source_id, fmt->protocol);\n\tif (!cs_desc)\n\t\treturn false;\n\n\tif (fmt->protocol == UAC_VERSION_2) {\n\t\t \n\t\tif (fmt->nr_rates == 1 &&\n\t\t    (fmt->clock & 0xff) == cs_desc->v2.bClockID &&\n\t\t    (cs_desc->v2.bmAttributes & 0x3) !=\n\t\t\t\tUAC_CLOCK_SOURCE_TYPE_EXT)\n\t\t\treturn true;\n\t}\n\n\t \n\tif (chip->usb_id == USB_ID(0x07fd, 0x0004)) {\n\t\tcount = 0;\n\n\t\twhile ((!ret) && (count < 50)) {\n\t\t\tint err;\n\n\t\t\tmsleep(100);\n\n\t\t\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,\n\t\t\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t\t      UAC2_CS_CONTROL_CLOCK_VALID << 8,\n\t\t\t\t\t      snd_usb_ctrl_intf(chip) | (source_id << 8),\n\t\t\t\t\t      &data, sizeof(data));\n\t\t\tif (err < 0) {\n\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t \"%s(): cannot get clock validity for id %d\\n\",\n\t\t\t\t\t   __func__, source_id);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tret = !!data;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic bool uac_clock_source_is_valid(struct snd_usb_audio *chip,\n\t\t\t\t      const struct audioformat *fmt,\n\t\t\t\t      int source_id)\n{\n\tint err;\n\tunsigned char data;\n\tstruct usb_device *dev = chip->dev;\n\tu32 bmControls;\n\tunion uac23_clock_source_desc *cs_desc;\n\n\tcs_desc = snd_usb_find_clock_source(chip, source_id, fmt->protocol);\n\tif (!cs_desc)\n\t\treturn false;\n\n\tif (fmt->protocol == UAC_VERSION_3)\n\t\tbmControls = le32_to_cpu(cs_desc->v3.bmControls);\n\telse\n\t\tbmControls = cs_desc->v2.bmControls;\n\n\t \n\tif (!uac_v2v3_control_is_readable(bmControls,\n\t\t\t\t      UAC2_CS_CONTROL_CLOCK_VALID))\n\t\treturn true;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t      UAC2_CS_CONTROL_CLOCK_VALID << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (source_id << 8),\n\t\t\t      &data, sizeof(data));\n\n\tif (err < 0) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"%s(): cannot get clock validity for id %d\\n\",\n\t\t\t   __func__, source_id);\n\t\treturn false;\n\t}\n\n\tif (data)\n\t\treturn true;\n\telse\n\t\treturn uac_clock_source_is_valid_quirk(chip, fmt, source_id);\n}\n\nstatic int __uac_clock_find_source(struct snd_usb_audio *chip,\n\t\t\t\t   const struct audioformat *fmt, int entity_id,\n\t\t\t\t   unsigned long *visited, bool validate)\n{\n\tunion uac23_clock_source_desc *source;\n\tunion uac23_clock_selector_desc *selector;\n\tunion uac23_clock_multiplier_desc *multiplier;\n\tint ret, i, cur, err, pins, clock_id;\n\tconst u8 *sources;\n\tint proto = fmt->protocol;\n\n\tentity_id &= 0xff;\n\n\tif (test_and_set_bit(entity_id, visited)) {\n\t\tusb_audio_warn(chip,\n\t\t\t \"%s(): recursive clock topology detected, id %d.\\n\",\n\t\t\t __func__, entity_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsource = snd_usb_find_clock_source(chip, entity_id, proto);\n\tif (source) {\n\t\tentity_id = GET_VAL(source, proto, bClockID);\n\t\tif (validate && !uac_clock_source_is_valid(chip, fmt,\n\t\t\t\t\t\t\t\tentity_id)) {\n\t\t\tusb_audio_err(chip,\n\t\t\t\t\"clock source %d is not valid, cannot use\\n\",\n\t\t\t\tentity_id);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\treturn entity_id;\n\t}\n\n\tselector = snd_usb_find_clock_selector(chip, entity_id, proto);\n\tif (selector) {\n\t\tpins = GET_VAL(selector, proto, bNrInPins);\n\t\tclock_id = GET_VAL(selector, proto, bClockID);\n\t\tsources = GET_VAL(selector, proto, baCSourceID);\n\t\tcur = 0;\n\n\t\tif (pins == 1) {\n\t\t\tret = 1;\n\t\t\tgoto find_source;\n\t\t}\n\n\t\t \n\t\tret = uac_clock_selector_get_val(chip, clock_id);\n\t\tif (ret < 0) {\n\t\t\tif (!chip->autoclock)\n\t\t\t\treturn ret;\n\t\t\tgoto find_others;\n\t\t}\n\n\t\t \n\n\t\tif (ret > pins || ret < 1) {\n\t\t\tusb_audio_err(chip,\n\t\t\t\t\"%s(): selector reported illegal value, id %d, ret %d\\n\",\n\t\t\t\t__func__, clock_id, ret);\n\n\t\t\tif (!chip->autoclock)\n\t\t\t\treturn -EINVAL;\n\t\t\tgoto find_others;\n\t\t}\n\n\tfind_source:\n\t\tcur = ret;\n\t\tret = __uac_clock_find_source(chip, fmt,\n\t\t\t\t\t      sources[ret - 1],\n\t\t\t\t\t      visited, validate);\n\t\tif (ret > 0) {\n\t\t\t \n\t\t\tif (chip->quirk_flags & QUIRK_FLAG_SKIP_CLOCK_SELECTOR)\n\t\t\t\treturn ret;\n\t\t\terr = uac_clock_selector_set_val(chip, entity_id, cur);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (!validate || ret > 0 || !chip->autoclock)\n\t\t\treturn ret;\n\n\tfind_others:\n\t\t \n\t\tfor (i = 1; i <= pins; i++) {\n\t\t\tif (i == cur)\n\t\t\t\tcontinue;\n\n\t\t\tret = __uac_clock_find_source(chip, fmt,\n\t\t\t\t\t\t      sources[i - 1],\n\t\t\t\t\t\t      visited, true);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\terr = uac_clock_selector_set_val(chip, entity_id, i);\n\t\t\tif (err < 0)\n\t\t\t\tcontinue;\n\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"found and selected valid clock source %d\\n\",\n\t\t\t\t ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmultiplier = snd_usb_find_clock_multiplier(chip, entity_id, proto);\n\tif (multiplier)\n\t\treturn __uac_clock_find_source(chip, fmt,\n\t\t\t\t\t       GET_VAL(multiplier, proto, bCSourceID),\n\t\t\t\t\t       visited, validate);\n\n\treturn -EINVAL;\n}\n\n \nint snd_usb_clock_find_source(struct snd_usb_audio *chip,\n\t\t\t      const struct audioformat *fmt, bool validate)\n{\n\tDECLARE_BITMAP(visited, 256);\n\tmemset(visited, 0, sizeof(visited));\n\n\tswitch (fmt->protocol) {\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3:\n\t\treturn __uac_clock_find_source(chip, fmt, fmt->clock, visited,\n\t\t\t\t\t       validate);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int set_sample_rate_v1(struct snd_usb_audio *chip,\n\t\t\t      const struct audioformat *fmt, int rate)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned char data[3];\n\tint err, crate;\n\n\t \n\tif (!(fmt->attributes & UAC_EP_CS_ATTR_SAMPLE_RATE))\n\t\treturn 0;\n\n\tdata[0] = rate;\n\tdata[1] = rate >> 8;\n\tdata[2] = rate >> 16;\n\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t      UAC_EP_CS_ATTR_SAMPLE_RATE << 8,\n\t\t\t      fmt->endpoint, data, sizeof(data));\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"%d:%d: cannot set freq %d to ep %#x\\n\",\n\t\t\tfmt->iface, fmt->altsetting, rate, fmt->endpoint);\n\t\treturn err;\n\t}\n\n\t \n\tif (chip->quirk_flags & QUIRK_FLAG_GET_SAMPLE_RATE)\n\t\treturn 0;\n\t \n\tif (chip->sample_rate_read_error > 2)\n\t\treturn 0;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC_GET_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_IN,\n\t\t\t      UAC_EP_CS_ATTR_SAMPLE_RATE << 8,\n\t\t\t      fmt->endpoint, data, sizeof(data));\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"%d:%d: cannot get freq at ep %#x\\n\",\n\t\t\tfmt->iface, fmt->altsetting, fmt->endpoint);\n\t\tchip->sample_rate_read_error++;\n\t\treturn 0;  \n\t}\n\n\tcrate = data[0] | (data[1] << 8) | (data[2] << 16);\n\tif (!crate) {\n\t\tdev_info(&dev->dev, \"failed to read current rate; disabling the check\\n\");\n\t\tchip->sample_rate_read_error = 3;  \n\t\treturn 0;\n\t}\n\n\tif (crate != rate) {\n\t\tdev_warn(&dev->dev, \"current rate %d is different from the runtime rate %d\\n\", crate, rate);\n\t\t\n\t}\n\n\treturn 0;\n}\n\nstatic int get_sample_rate_v2v3(struct snd_usb_audio *chip, int iface,\n\t\t\t      int altsetting, int clock)\n{\n\tstruct usb_device *dev = chip->dev;\n\t__le32 data;\n\tint err;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t      UAC2_CS_CONTROL_SAM_FREQ << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (clock << 8),\n\t\t\t      &data, sizeof(data));\n\tif (err < 0) {\n\t\tdev_warn(&dev->dev, \"%d:%d: cannot get freq (v2/v3): err %d\\n\",\n\t\t\t iface, altsetting, err);\n\t\treturn 0;\n\t}\n\n\treturn le32_to_cpu(data);\n}\n\n \nint snd_usb_set_sample_rate_v2v3(struct snd_usb_audio *chip,\n\t\t\t\t const struct audioformat *fmt,\n\t\t\t\t int clock, int rate)\n{\n\tbool writeable;\n\tu32 bmControls;\n\t__le32 data;\n\tint err;\n\tunion uac23_clock_source_desc *cs_desc;\n\n\tcs_desc = snd_usb_find_clock_source(chip, clock, fmt->protocol);\n\n\tif (!cs_desc)\n\t\treturn 0;\n\n\tif (fmt->protocol == UAC_VERSION_3)\n\t\tbmControls = le32_to_cpu(cs_desc->v3.bmControls);\n\telse\n\t\tbmControls = cs_desc->v2.bmControls;\n\n\twriteable = uac_v2v3_control_is_writeable(bmControls,\n\t\t\t\t\t\t  UAC2_CS_CONTROL_SAM_FREQ);\n\tif (!writeable)\n\t\treturn 0;\n\n\tdata = cpu_to_le32(rate);\n\terr = snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t      UAC2_CS_CONTROL_SAM_FREQ << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (clock << 8),\n\t\t\t      &data, sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn get_sample_rate_v2v3(chip, fmt->iface, fmt->altsetting, clock);\n}\n\nstatic int set_sample_rate_v2v3(struct snd_usb_audio *chip,\n\t\t\t\tconst struct audioformat *fmt, int rate)\n{\n\tint cur_rate, prev_rate;\n\tint clock;\n\n\t \n\tclock = snd_usb_clock_find_source(chip, fmt, true);\n\tif (clock < 0) {\n\t\t \n\t\tclock = snd_usb_clock_find_source(chip, fmt, false);\n\n\t\t \n\t\tif (chip->quirk_flags & QUIRK_FLAG_IGNORE_CLOCK_SOURCE)\n\t\t\treturn 0;\n\n\t\tif (clock < 0)\n\t\t\treturn clock;\n\t}\n\n\tprev_rate = get_sample_rate_v2v3(chip, fmt->iface, fmt->altsetting, clock);\n\tif (prev_rate == rate)\n\t\tgoto validation;\n\n\tcur_rate = snd_usb_set_sample_rate_v2v3(chip, fmt, clock, rate);\n\tif (cur_rate < 0) {\n\t\tusb_audio_err(chip,\n\t\t\t      \"%d:%d: cannot set freq %d (v2/v3): err %d\\n\",\n\t\t\t      fmt->iface, fmt->altsetting, rate, cur_rate);\n\t\treturn cur_rate;\n\t}\n\n\tif (!cur_rate)\n\t\tcur_rate = prev_rate;\n\n\tif (cur_rate != rate) {\n\t\tusb_audio_dbg(chip,\n\t\t\t      \"%d:%d: freq mismatch: req %d, clock runs @%d\\n\",\n\t\t\t      fmt->iface, fmt->altsetting, rate, cur_rate);\n\t\t \n\t}\n\n\t \n\tif (USB_ID_VENDOR(chip->usb_id) == 0x0644) {\n\t\tbool cur_base_48k = (rate % 48000 == 0);\n\t\tbool prev_base_48k = (prev_rate % 48000 == 0);\n\t\tif (cur_base_48k != prev_base_48k) {\n\t\t\tusb_set_interface(chip->dev, fmt->iface, fmt->altsetting);\n\t\t\tif (chip->quirk_flags & QUIRK_FLAG_IFACE_DELAY)\n\t\t\t\tmsleep(50);\n\t\t}\n\t}\n\nvalidation:\n\t \n\tif (!uac_clock_source_is_valid(chip, fmt, clock))\n\t\treturn -ENXIO;\n\treturn 0;\n}\n\nint snd_usb_init_sample_rate(struct snd_usb_audio *chip,\n\t\t\t     const struct audioformat *fmt, int rate)\n{\n\tusb_audio_dbg(chip, \"%d:%d Set sample rate %d, clock %d\\n\",\n\t\t      fmt->iface, fmt->altsetting, rate, fmt->clock);\n\n\tswitch (fmt->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\treturn set_sample_rate_v1(chip, fmt, rate);\n\n\tcase UAC_VERSION_3:\n\t\tif (chip->badd_profile >= UAC3_FUNCTION_SUBCLASS_GENERIC_IO) {\n\t\t\tif (rate != UAC3_BADD_SAMPLING_RATE)\n\t\t\t\treturn -ENXIO;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase UAC_VERSION_2:\n\t\treturn set_sample_rate_v2v3(chip, fmt, rate);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}