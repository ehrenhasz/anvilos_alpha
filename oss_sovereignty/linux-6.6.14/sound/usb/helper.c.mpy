{
  "module_name": "helper.c",
  "hash_id": "b21117d7a650dc86281f5308f42d8712e932756ca8f8745ee3c1d65e0e50b979",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/helper.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include \"usbaudio.h\"\n#include \"helper.h\"\n#include \"quirks.h\"\n\n \nunsigned int snd_usb_combine_bytes(unsigned char *bytes, int size)\n{\n\tswitch (size) {\n\tcase 1:  return *bytes;\n\tcase 2:  return combine_word(bytes);\n\tcase 3:  return combine_triple(bytes);\n\tcase 4:  return combine_quad(bytes);\n\tdefault: return 0;\n\t}\n}\n\n \nvoid *snd_usb_find_desc(void *descstart, int desclen, void *after, u8 dtype)\n{\n\tu8 *p, *end, *next;\n\n\tp = descstart;\n\tend = p + desclen;\n\tfor (; p < end;) {\n\t\tif (p[0] < 2)\n\t\t\treturn NULL;\n\t\tnext = p + p[0];\n\t\tif (next > end)\n\t\t\treturn NULL;\n\t\tif (p[1] == dtype && (!after || (void *)p > after)) {\n\t\t\treturn p;\n\t\t}\n\t\tp = next;\n\t}\n\treturn NULL;\n}\n\n \nvoid *snd_usb_find_csint_desc(void *buffer, int buflen, void *after, u8 dsubtype)\n{\n\tunsigned char *p = after;\n\n\twhile ((p = snd_usb_find_desc(buffer, buflen, p,\n\t\t\t\t      USB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (p[0] >= 3 && p[2] == dsubtype)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n \nint snd_usb_ctl_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\n\t\t    __u8 requesttype, __u16 value, __u16 index, void *data,\n\t\t    __u16 size)\n{\n\tint err;\n\tvoid *buf = NULL;\n\tint timeout;\n\n\tif (usb_pipe_type_check(dev, pipe))\n\t\treturn -EINVAL;\n\n\tif (size > 0) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (requesttype & USB_DIR_IN)\n\t\ttimeout = USB_CTRL_GET_TIMEOUT;\n\telse\n\t\ttimeout = USB_CTRL_SET_TIMEOUT;\n\n\terr = usb_control_msg(dev, pipe, request, requesttype,\n\t\t\t      value, index, buf, size, timeout);\n\n\tif (size > 0) {\n\t\tmemcpy(data, buf, size);\n\t\tkfree(buf);\n\t}\n\n\tsnd_usb_ctl_msg_quirk(dev, pipe, request, requesttype,\n\t\t\t      value, index, data, size);\n\n\treturn err;\n}\n\nunsigned char snd_usb_parse_datainterval(struct snd_usb_audio *chip,\n\t\t\t\t\t struct usb_host_interface *alts)\n{\n\tswitch (snd_usb_get_speed(chip->dev)) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (get_endpoint(alts, 0)->bInterval >= 1 &&\n\t\t    get_endpoint(alts, 0)->bInterval <= 4)\n\t\t\treturn get_endpoint(alts, 0)->bInterval - 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct usb_host_interface *\nsnd_usb_get_host_interface(struct snd_usb_audio *chip, int ifnum, int altsetting)\n{\n\tstruct usb_interface *iface;\n\n\tiface = usb_ifnum_to_if(chip->dev, ifnum);\n\tif (!iface)\n\t\treturn NULL;\n\treturn usb_altnum_to_altsetting(iface, altsetting);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}