{
  "module_name": "mixer_us16x08.c",
  "hash_id": "40d26691a4caa7b4da154bd8d796ecde9fd2d83c77266e59e977952ae2849874",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_us16x08.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n\n#include \"mixer_us16x08.h\"\n\n \nstatic const char route_msg[] = {\n\t0x61,\n\t0x02,\n\t0x03,  \n\t0x62,\n\t0x02,\n\t0x01,  \n\t0x41,\n\t0x01,\n\t0x61,\n\t0x02,\n\t0x01,\n\t0x62,\n\t0x02,\n\t0x01,  \n\t0x42,\n\t0x01,\n\t0x43,\n\t0x01,\n\t0x00,\n\t0x00\n};\n\nstatic const char mix_init_msg1[] = {\n\t0x71, 0x01, 0x00, 0x00\n};\n\nstatic const char mix_init_msg2[] = {\n\t0x62, 0x02, 0x00, 0x61, 0x02, 0x04, 0xb1, 0x01, 0x00, 0x00\n};\n\nstatic const char mix_msg_in[] = {\n\t \n\t0x61, 0x02, 0x04, 0x62, 0x02, 0x01,\n\t0x81,  \n\t0x02,  \n\t0x00,  \n\t0x00,\n\t0x00\n};\n\nstatic const char mix_msg_out[] = {\n\t \n\t0x61, 0x02, 0x02, 0x62, 0x02, 0x01,\n\t0x81,  \n\t0x02,  \n\t0x00,  \n\t0x00,\n\t0x00\n};\n\nstatic const char bypass_msg_out[] = {\n\t0x45,\n\t0x02,\n\t0x01,  \n\t0x00,\n\t0x00\n};\n\nstatic const char bus_msg_out[] = {\n\t0x44,\n\t0x02,\n\t0x01,  \n\t0x00,\n\t0x00\n};\n\nstatic const char comp_msg[] = {\n\t \n\t0x61, 0x02, 0x04, 0x62, 0x02, 0x01,\n\t0x91,\n\t0x02,\n\t0xf0,  \n\t0x92,\n\t0x02,\n\t0x0a,  \n\t0x93,\n\t0x02,\n\t0x02,  \n\t0x94,\n\t0x02,\n\t0x01,  \n\t0x95,\n\t0x02,\n\t0x03,  \n\t0x96,\n\t0x02,\n\t0x01,\n\t0x97,\n\t0x02,\n\t0x01,  \n\t0x00,\n\t0x00\n};\n\nstatic const char eqs_msq[] = {\n\t \n\t0x61, 0x02, 0x04, 0x62, 0x02, 0x01,\n\t0x51,  \n\t0x02,\n\t0x04,  \n\t0x52,\n\t0x02,\n\t0x0c,  \n\t0x53,\n\t0x02,\n\t0x0f,  \n\t0x54,\n\t0x02,\n\t0x02,  \n\t0x55,\n\t0x02,\n\t0x01,  \n\t0x00,\n\t0x00\n};\n\n \nstatic const char ratio_map[] = {\n\t0x0a, 0x0b, 0x0d, 0x0f, 0x11, 0x14, 0x19, 0x1e,\n\t0x23, 0x28, 0x32, 0x3c, 0x50, 0xa0, 0xff\n};\n\n \nstatic const char *const route_names[] = {\n\t\"Master Left\", \"Master Right\", \"Output 1\", \"Output 2\", \"Output 3\",\n\t\"Output 4\", \"Output 5\", \"Output 6\", \"Output 7\", \"Output 8\",\n};\n\nstatic int snd_us16x08_recv_urb(struct snd_usb_audio *chip,\n\tunsigned char *buf, int size)\n{\n\n\tmutex_lock(&chip->mutex);\n\tsnd_usb_ctl_msg(chip->dev,\n\t\tusb_rcvctrlpipe(chip->dev, 0),\n\t\tSND_US16X08_URB_METER_REQUEST,\n\t\tSND_US16X08_URB_METER_REQUESTTYPE, 0, 0, buf, size);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\n \nstatic int snd_us16x08_send_urb(struct snd_usb_audio *chip, char *buf, int size)\n{\n\treturn snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),\n\t\t\tSND_US16X08_URB_REQUEST, SND_US16X08_URB_REQUESTTYPE,\n\t\t\t0, 0, buf, size);\n}\n\nstatic int snd_us16x08_route_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 10, route_names);\n}\n\nstatic int snd_us16x08_route_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tint index = ucontrol->id.index;\n\n\t \n\tucontrol->value.enumerated.item[0] = elem->cache_val[index];\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_route_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tint index = ucontrol->id.index;\n\tchar buf[sizeof(route_msg)];\n\tint val, val_org, err;\n\n\t \n\tval = ucontrol->value.enumerated.item[0];\n\n\t \n\tif (val < 0 || val > 9)\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(buf, route_msg, sizeof(route_msg));\n\n\tif (val < 2) {\n\t\t \n\t\tval_org = val;\n\t\tbuf[2] = 0x02;\n\t} else {\n\t\t \n\t\tbuf[2] = 0x03;\n\t\tval_org = val - 2;\n\t}\n\n\t \n\tbuf[5] = (unsigned char) (val_org & 0x0f) + 1;\n\t \n\tbuf[13] = index + 1;\n\n\terr = snd_us16x08_send_urb(chip, buf, sizeof(route_msg));\n\n\tif (err > 0) {\n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set routing, err:%d\\n\", err);\n\t}\n\n\treturn err > 0 ? 1 : 0;\n}\n\nstatic int snd_us16x08_master_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->count = 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.max = SND_US16X08_KCMAX(kcontrol);\n\tuinfo->value.integer.min = SND_US16X08_KCMIN(kcontrol);\n\tuinfo->value.integer.step = SND_US16X08_KCSTEP(kcontrol);\n\treturn 0;\n}\n\nstatic int snd_us16x08_master_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tint index = ucontrol->id.index;\n\n\tucontrol->value.integer.value[0] = elem->cache_val[index];\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_master_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tchar buf[sizeof(mix_msg_out)];\n\tint val, err;\n\tint index = ucontrol->id.index;\n\n\t \n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tif (val < SND_US16X08_KCMIN(kcontrol)\n\t\t|| val > SND_US16X08_KCMAX(kcontrol))\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(buf, mix_msg_out, sizeof(mix_msg_out));\n\n\tbuf[8] = val - SND_US16X08_KCBIAS(kcontrol);\n\tbuf[6] = elem->head.id;\n\n\t \n\tbuf[5] = index + 1;\n\terr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_out));\n\n\tif (err > 0) {\n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set master, err:%d\\n\", err);\n\t}\n\n\treturn err > 0 ? 1 : 0;\n}\n\nstatic int snd_us16x08_bus_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tchar buf[sizeof(mix_msg_out)];\n\tint val, err = 0;\n\n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tswitch (elem->head.id) {\n\tcase SND_US16X08_ID_BYPASS:\n\t\tmemcpy(buf, bypass_msg_out, sizeof(bypass_msg_out));\n\t\tbuf[2] = val;\n\t\terr = snd_us16x08_send_urb(chip, buf, sizeof(bypass_msg_out));\n\t\tbreak;\n\tcase SND_US16X08_ID_BUSS_OUT:\n\t\tmemcpy(buf, bus_msg_out, sizeof(bus_msg_out));\n\t\tbuf[2] = val;\n\t\terr = snd_us16x08_send_urb(chip, buf, sizeof(bus_msg_out));\n\t\tbreak;\n\tcase SND_US16X08_ID_MUTE:\n\t\tmemcpy(buf, mix_msg_out, sizeof(mix_msg_out));\n\t\tbuf[8] = val;\n\t\tbuf[6] = elem->head.id;\n\t\tbuf[5] = 1;\n\t\terr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_out));\n\t\tbreak;\n\t}\n\n\tif (err > 0) {\n\t\telem->cached |= 1;\n\t\telem->cache_val[0] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set bus parameter, err:%d\\n\", err);\n\t}\n\n\treturn err > 0 ? 1 : 0;\n}\n\nstatic int snd_us16x08_bus_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\n\tswitch (elem->head.id) {\n\tcase SND_US16X08_ID_BUSS_OUT:\n\t\tucontrol->value.integer.value[0] = elem->cache_val[0];\n\t\tbreak;\n\tcase SND_US16X08_ID_BYPASS:\n\t\tucontrol->value.integer.value[0] = elem->cache_val[0];\n\t\tbreak;\n\tcase SND_US16X08_ID_MUTE:\n\t\tucontrol->value.integer.value[0] = elem->cache_val[0];\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_us16x08_channel_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tint index = ucontrol->id.index;\n\n\tucontrol->value.integer.value[0] = elem->cache_val[index];\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_channel_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tchar buf[sizeof(mix_msg_in)];\n\tint val, err;\n\tint index = ucontrol->id.index;\n\n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tif (val < SND_US16X08_KCMIN(kcontrol)\n\t\t|| val > SND_US16X08_KCMAX(kcontrol))\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(buf, mix_msg_in, sizeof(mix_msg_in));\n\n\t \n\tbuf[8] = val - SND_US16X08_KCBIAS(kcontrol);\n\tbuf[6] = elem->head.id;\n\tbuf[5] = index + 1;\n\n\terr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_in));\n\n\tif (err > 0) {\n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set channel, err:%d\\n\", err);\n\t}\n\n\treturn err > 0 ? 1 : 0;\n}\n\nstatic int snd_us16x08_mix_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->count = 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.max = SND_US16X08_KCMAX(kcontrol);\n\tuinfo->value.integer.min = SND_US16X08_KCMIN(kcontrol);\n\tuinfo->value.integer.step = SND_US16X08_KCSTEP(kcontrol);\n\treturn 0;\n}\n\nstatic int snd_us16x08_comp_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_us16x08_comp_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\tint val_idx = COMP_STORE_IDX(elem->head.id);\n\n\tucontrol->value.integer.value[0] = store->val[val_idx][index];\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_comp_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tstruct snd_us16x08_comp_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\tchar buf[sizeof(comp_msg)];\n\tint val_idx, val;\n\tint err;\n\n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tif (val < SND_US16X08_KCMIN(kcontrol)\n\t\t|| val > SND_US16X08_KCMAX(kcontrol))\n\t\treturn -EINVAL;\n\n\t \n\tval_idx = elem->head.id - SND_US16X08_ID_COMP_BASE;\n\n\tstore->val[val_idx][index] = ucontrol->value.integer.value[0];\n\n\t \n\tmemcpy(buf, comp_msg, sizeof(comp_msg));\n\n\t \n\tbuf[8] = store->val[\n\t\tCOMP_STORE_IDX(SND_US16X08_ID_COMP_THRESHOLD)][index]\n\t\t- SND_US16X08_COMP_THRESHOLD_BIAS;\n\tbuf[11] = ratio_map[store->val[\n\t\tCOMP_STORE_IDX(SND_US16X08_ID_COMP_RATIO)][index]];\n\tbuf[14] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_ATTACK)][index]\n\t\t+ SND_US16X08_COMP_ATTACK_BIAS;\n\tbuf[17] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RELEASE)][index]\n\t\t+ SND_US16X08_COMP_RELEASE_BIAS;\n\tbuf[20] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_GAIN)][index];\n\tbuf[26] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)][index];\n\n\t \n\tbuf[5] = index + 1;\n\n\terr = snd_us16x08_send_urb(chip, buf, sizeof(comp_msg));\n\n\tif (err > 0) {\n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set compressor, err:%d\\n\", err);\n\t}\n\n\treturn 1;\n}\n\nstatic int snd_us16x08_eqswitch_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint val;\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_us16x08_eq_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\n\t \n\tval = store->val[EQ_STORE_BAND_IDX(elem->head.id)]\n\t\t[EQ_STORE_PARAM_IDX(elem->head.id)][index];\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_eqswitch_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tstruct snd_us16x08_eq_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\tchar buf[sizeof(eqs_msq)];\n\tint val, err = 0;\n\tint b_idx;\n\n\t \n\tval = ucontrol->value.integer.value[0] + SND_US16X08_KCBIAS(kcontrol);\n\n\t \n\tmemcpy(buf, eqs_msq, sizeof(eqs_msq));\n\n\t \n\tbuf[5] = index + 1;\n\tfor (b_idx = 0; b_idx < SND_US16X08_ID_EQ_BAND_COUNT; b_idx++) {\n\t\t \n\t\tbuf[20] = val;\n\t\tbuf[17] = store->val[b_idx][2][index];\n\t\tbuf[14] = store->val[b_idx][1][index];\n\t\tbuf[11] = store->val[b_idx][0][index];\n\t\tbuf[8] = b_idx + 1;\n\t\terr = snd_us16x08_send_urb(chip, buf, sizeof(eqs_msq));\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tstore->val[b_idx][3][index] = val;\n\t\tmsleep(15);\n\t}\n\n\tif (err > 0) {\n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set eq switch, err:%d\\n\", err);\n\t}\n\n\treturn 1;\n}\n\nstatic int snd_us16x08_eq_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint val;\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_us16x08_eq_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\tint b_idx = EQ_STORE_BAND_IDX(elem->head.id) - 1;\n\tint p_idx = EQ_STORE_PARAM_IDX(elem->head.id);\n\n\tval = store->val[b_idx][p_idx][index];\n\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\n\nstatic int snd_us16x08_eq_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tstruct snd_us16x08_eq_store *store = elem->private_data;\n\tint index = ucontrol->id.index;\n\tchar buf[sizeof(eqs_msq)];\n\tint val, err;\n\tint b_idx = EQ_STORE_BAND_IDX(elem->head.id) - 1;\n\tint p_idx = EQ_STORE_PARAM_IDX(elem->head.id);\n\n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tif (val < SND_US16X08_KCMIN(kcontrol)\n\t\t|| val > SND_US16X08_KCMAX(kcontrol))\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(buf, eqs_msq, sizeof(eqs_msq));\n\n\tstore->val[b_idx][p_idx][index] = val;\n\tbuf[20] = store->val[b_idx][3][index];\n\tbuf[17] = store->val[b_idx][2][index];\n\tbuf[14] = store->val[b_idx][1][index];\n\tbuf[11] = store->val[b_idx][0][index];\n\n\t \n\tbuf[5] = index + 1;\n\n\t \n\tbuf[8] = b_idx + 1;\n\n\terr = snd_us16x08_send_urb(chip, buf, sizeof(eqs_msq));\n\n\tif (err > 0) {\n\t\t \n\t\telem->cached |= 1 << index;\n\t\telem->cache_val[index] = val;\n\t} else {\n\t\tusb_audio_dbg(chip, \"Failed to set eq param, err:%d\\n\", err);\n\t}\n\n\treturn 1;\n}\n\nstatic int snd_us16x08_meter_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->count = 34;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.max = 0x7FFF;\n\tuinfo->value.integer.min = 0;\n\n\treturn 0;\n}\n\n \nstatic int snd_get_meter_comp_index(struct snd_us16x08_meter_store *store)\n{\n\tint ret;\n\n\t \n\tif (store->comp_active_index) {\n\t\t \n\t\tif (store->comp_active_index & 0x20) {\n\t\t\t \n\t\t\tif (store->comp_index -\n\t\t\t\tstore->comp_active_index > 1)\n\t\t\t\tstore->comp_index =\n\t\t\t\tstore->comp_active_index;\n\n\t\t\tret = store->comp_index++ & 0x1F;\n\t\t} else {\n\t\t\t \n\t\t\tret = store->comp_active_index;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (store->comp_index <= SND_US16X08_MAX_CHANNELS\n\t\t\t&& !store->comp_store->val[\n\t\t\tCOMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)]\n\t\t\t[store->comp_index - 1]) {\n\t\t\tstore->comp_index++;\n\t\t}\n\t\tret = store->comp_index++;\n\t\tif (store->comp_index > SND_US16X08_MAX_CHANNELS)\n\t\t\tstore->comp_index = 1;\n\t}\n\treturn ret;\n}\n\n \nstatic void get_meter_levels_from_urb(int s,\n\tstruct snd_us16x08_meter_store *store,\n\tu8 *meter_urb)\n{\n\tint val = MUC2(meter_urb, s) + (MUC3(meter_urb, s) << 8);\n\n\tif (MUA0(meter_urb, s) == 0x61 && MUA1(meter_urb, s) == 0x02 &&\n\t\tMUA2(meter_urb, s) == 0x04 && MUB0(meter_urb, s) == 0x62) {\n\t\tif (MUC0(meter_urb, s) == 0x72)\n\t\t\tstore->meter_level[MUB2(meter_urb, s) - 1] = val;\n\t\tif (MUC0(meter_urb, s) == 0xb2)\n\t\t\tstore->comp_level[MUB2(meter_urb, s) - 1] = val;\n\t}\n\tif (MUA0(meter_urb, s) == 0x61 && MUA1(meter_urb, s) == 0x02 &&\n\t\tMUA2(meter_urb, s) == 0x02 && MUB0(meter_urb, s) == 0x62)\n\t\tstore->master_level[MUB2(meter_urb, s) - 1] = val;\n}\n\n \nstatic int snd_us16x08_meter_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint i, set;\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tstruct snd_us16x08_meter_store *store = elem->private_data;\n\tu8 meter_urb[64];\n\n\tswitch (kcontrol->private_value) {\n\tcase 0: {\n\t\tchar tmp[sizeof(mix_init_msg1)];\n\n\t\tmemcpy(tmp, mix_init_msg1, sizeof(mix_init_msg1));\n\t\tsnd_us16x08_send_urb(chip, tmp, 4);\n\t\tsnd_us16x08_recv_urb(chip, meter_urb,\n\t\t\tsizeof(meter_urb));\n\t\tkcontrol->private_value++;\n\t\tbreak;\n\t}\n\tcase 1:\n\t\tsnd_us16x08_recv_urb(chip, meter_urb,\n\t\t\tsizeof(meter_urb));\n\t\tkcontrol->private_value++;\n\t\tbreak;\n\tcase 2:\n\t\tsnd_us16x08_recv_urb(chip, meter_urb,\n\t\t\tsizeof(meter_urb));\n\t\tkcontrol->private_value++;\n\t\tbreak;\n\tcase 3: {\n\t\tchar tmp[sizeof(mix_init_msg2)];\n\n\t\tmemcpy(tmp, mix_init_msg2, sizeof(mix_init_msg2));\n\t\ttmp[2] = snd_get_meter_comp_index(store);\n\t\tsnd_us16x08_send_urb(chip, tmp, 10);\n\t\tsnd_us16x08_recv_urb(chip, meter_urb,\n\t\t\tsizeof(meter_urb));\n\t\tkcontrol->private_value = 0;\n\t\tbreak;\n\t}\n\t}\n\n\tfor (set = 0; set < 6; set++)\n\t\tget_meter_levels_from_urb(set, store, meter_urb);\n\n\tfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\n\t\tucontrol->value.integer.value[i] =\n\t\t\tstore ? store->meter_level[i] : 0;\n\t}\n\n\tucontrol->value.integer.value[i++] = store ? store->master_level[0] : 0;\n\tucontrol->value.integer.value[i++] = store ? store->master_level[1] : 0;\n\n\tfor (i = 2; i < SND_US16X08_MAX_CHANNELS + 2; i++)\n\t\tucontrol->value.integer.value[i + SND_US16X08_MAX_CHANNELS] =\n\t\tstore ? store->comp_level[i - 2] : 0;\n\n\treturn 1;\n}\n\nstatic int snd_us16x08_meter_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kcontrol->private_data;\n\tstruct snd_us16x08_meter_store *store = elem->private_data;\n\tint val;\n\n\tval = ucontrol->value.integer.value[0];\n\n\t \n\tif (val < 0 || val >= SND_US16X08_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tstore->comp_active_index = val;\n\tstore->comp_index = val;\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new snd_us16x08_ch_boolean_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_switch_info,\n\t.get = snd_us16x08_channel_get,\n\t.put = snd_us16x08_channel_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_ch_int_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_channel_get,\n\t.put = snd_us16x08_channel_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_FADER_BIAS, 1, 0, 133)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_pan_int_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_channel_get,\n\t.put = snd_us16x08_channel_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_FADER_BIAS, 1, 0, 255)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_master_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 1,\n\t.info = snd_us16x08_master_info,\n\t.get = snd_us16x08_master_get,\n\t.put = snd_us16x08_master_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_FADER_BIAS, 1, 0, 133)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_route_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 8,\n\t.info = snd_us16x08_route_info,\n\t.get = snd_us16x08_route_get,\n\t.put = snd_us16x08_route_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 9)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_bus_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 1,\n\t.info = snd_us16x08_switch_info,\n\t.get = snd_us16x08_bus_get,\n\t.put = snd_us16x08_bus_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_compswitch_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_switch_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_comp_threshold_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_COMP_THRESHOLD_BIAS, 1,\n\t0, 0x20)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_comp_ratio_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0,\n\tsizeof(ratio_map) - 1),  \n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_comp_gain_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 0x14)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_comp_attack_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value =\n\tSND_US16X08_KCSET(SND_US16X08_COMP_ATTACK_BIAS, 1, 0, 0xc6),\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_comp_release_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_comp_get,\n\t.put = snd_us16x08_comp_put,\n\t.private_value =\n\tSND_US16X08_KCSET(SND_US16X08_COMP_RELEASE_BIAS, 1, 0, 0x63),\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_gain_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_eq_get,\n\t.put = snd_us16x08_eq_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 24),\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_low_freq_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_eq_get,\n\t.put = snd_us16x08_eq_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 0x1F),\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_mid_freq_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_eq_get,\n\t.put = snd_us16x08_eq_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 0x3F)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_mid_width_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_eq_get,\n\t.put = snd_us16x08_eq_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 0x06)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_high_freq_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_mix_info,\n\t.get = snd_us16x08_eq_get,\n\t.put = snd_us16x08_eq_put,\n\t.private_value =\n\tSND_US16X08_KCSET(SND_US16X08_EQ_HIGHFREQ_BIAS, 1, 0, 0x1F)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_eq_switch_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 16,\n\t.info = snd_us16x08_switch_info,\n\t.get = snd_us16x08_eqswitch_get,\n\t.put = snd_us16x08_eqswitch_put,\n\t.private_value = SND_US16X08_KCSET(SND_US16X08_NO_BIAS, 1, 0, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_us16x08_meter_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.count = 1,\n\t.info = snd_us16x08_meter_info,\n\t.get = snd_us16x08_meter_get,\n\t.put = snd_us16x08_meter_put\n};\n\n \n\n \nstatic struct snd_us16x08_comp_store *snd_us16x08_create_comp_store(void)\n{\n\tint i;\n\tstruct snd_us16x08_comp_store *tmp;\n\n\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn NULL;\n\n\tfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_THRESHOLD)][i]\n\t\t\t= 0x20;\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RATIO)][i] = 0x00;\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_GAIN)][i] = 0x00;\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)][i] = 0x00;\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_ATTACK)][i] = 0x00;\n\t\ttmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RELEASE)][i] = 0x00;\n\t}\n\treturn tmp;\n}\n\n \nstatic struct snd_us16x08_eq_store *snd_us16x08_create_eq_store(void)\n{\n\tint i, b_idx;\n\tstruct snd_us16x08_eq_store *tmp;\n\n\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn NULL;\n\n\tfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\n\t\tfor (b_idx = 0; b_idx < SND_US16X08_ID_EQ_BAND_COUNT; b_idx++) {\n\t\t\ttmp->val[b_idx][0][i] = 0x0c;\n\t\t\ttmp->val[b_idx][3][i] = 0x00;\n\t\t\tswitch (b_idx) {\n\t\t\tcase 0:  \n\t\t\t\ttmp->val[b_idx][1][i] = 0x05;\n\t\t\t\ttmp->val[b_idx][2][i] = 0xff;\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\ttmp->val[b_idx][1][i] = 0x0e;\n\t\t\t\ttmp->val[b_idx][2][i] = 0x02;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\ttmp->val[b_idx][1][i] = 0x1b;\n\t\t\t\ttmp->val[b_idx][2][i] = 0x02;\n\t\t\t\tbreak;\n\t\t\tcase 3:  \n\t\t\t\ttmp->val[b_idx][1][i] = 0x2f\n\t\t\t\t\t- SND_US16X08_EQ_HIGHFREQ_BIAS;\n\t\t\t\ttmp->val[b_idx][2][i] = 0xff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn tmp;\n}\n\nstatic struct snd_us16x08_meter_store *snd_us16x08_create_meter_store(void)\n{\n\tstruct snd_us16x08_meter_store *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn NULL;\n\ttmp->comp_index = 1;\n\ttmp->comp_active_index = 0;\n\treturn tmp;\n}\n\n \nstatic void elem_private_free(struct snd_kcontrol *kctl)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tif (elem)\n\t\tkfree(elem->private_data);\n\tkfree(elem);\n\tkctl->private_data = NULL;\n}\n\nstatic int add_new_ctl(struct usb_mixer_interface *mixer,\n\tconst struct snd_kcontrol_new *ncontrol,\n\tint index, int val_type, int channels,\n\tconst char *name, void *opt,\n\tbool do_private_free,\n\tstruct usb_mixer_elem_info **elem_ret)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *elem;\n\tint err;\n\n\tusb_audio_dbg(mixer->chip, \"us16x08 add mixer %s\\n\", name);\n\n\telem = kzalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\telem->head.mixer = mixer;\n\telem->head.resume = NULL;\n\telem->control = 0;\n\telem->idx_off = 0;\n\telem->head.id = index;\n\telem->val_type = val_type;\n\telem->channels = channels;\n\telem->private_data = opt;\n\n\tkctl = snd_ctl_new1(ncontrol, elem);\n\tif (!kctl) {\n\t\tkfree(elem);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (do_private_free)\n\t\tkctl->private_free = elem_private_free;\n\telse\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tstrscpy(kctl->id.name, name, sizeof(kctl->id.name));\n\n\terr = snd_usb_mixer_add_control(&elem->head, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (elem_ret)\n\t\t*elem_ret = elem;\n\n\treturn 0;\n}\n\n \nstatic const struct snd_us16x08_control_params eq_controls[] = {\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_switch_ctl,\n\t\t.control_id = SND_US16X08_ID_EQENABLE,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ Switch\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_gain_ctl,\n\t\t.control_id = SND_US16X08_ID_EQLOWLEVEL,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ Low Volume\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_low_freq_ctl,\n\t\t.control_id = SND_US16X08_ID_EQLOWFREQ,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ Low Frequency\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_gain_ctl,\n\t\t.control_id = SND_US16X08_ID_EQLOWMIDLEVEL,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidLow Volume\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_mid_freq_ctl,\n\t\t.control_id = SND_US16X08_ID_EQLOWMIDFREQ,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidLow Frequency\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_mid_width_ctl,\n\t\t.control_id = SND_US16X08_ID_EQLOWMIDWIDTH,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidLow Q\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_gain_ctl,\n\t\t.control_id = SND_US16X08_ID_EQHIGHMIDLEVEL,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidHigh Volume\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_mid_freq_ctl,\n\t\t.control_id = SND_US16X08_ID_EQHIGHMIDFREQ,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidHigh Frequency\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_mid_width_ctl,\n\t\t.control_id = SND_US16X08_ID_EQHIGHMIDWIDTH,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ MidHigh Q\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_gain_ctl,\n\t\t.control_id = SND_US16X08_ID_EQHIGHLEVEL,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ High Volume\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_eq_high_freq_ctl,\n\t\t.control_id = SND_US16X08_ID_EQHIGHFREQ,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"EQ High Frequency\",\n\t},\n};\n\n \nstatic const struct snd_us16x08_control_params comp_controls[] = {\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_compswitch_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_SWITCH,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Switch\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_comp_threshold_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_THRESHOLD,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Threshold Volume\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_comp_ratio_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_RATIO,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Ratio\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_comp_attack_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_ATTACK,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Attack\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_comp_release_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_RELEASE,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Release\",\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_comp_gain_ctl,\n\t\t.control_id = SND_US16X08_ID_COMP_GAIN,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Compressor Volume\",\n\t},\n};\n\n \nstatic const struct snd_us16x08_control_params channel_controls[] = {\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_ch_boolean_ctl,\n\t\t.control_id = SND_US16X08_ID_PHASE,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"Phase Switch\",\n\t\t.default_val = 0\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_ch_int_ctl,\n\t\t.control_id = SND_US16X08_ID_FADER,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Line Volume\",\n\t\t.default_val = 127\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_ch_boolean_ctl,\n\t\t.control_id = SND_US16X08_ID_MUTE,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"Mute Switch\",\n\t\t.default_val = 0\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_pan_int_ctl,\n\t\t.control_id = SND_US16X08_ID_PAN,\n\t\t.type = USB_MIXER_U16,\n\t\t.num_channels = 16,\n\t\t.name = \"Pan Left-Right Volume\",\n\t\t.default_val = 127\n\t},\n};\n\n \nstatic const struct snd_us16x08_control_params master_controls[] = {\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_master_ctl,\n\t\t.control_id = SND_US16X08_ID_FADER,\n\t\t.type = USB_MIXER_U8,\n\t\t.num_channels = 16,\n\t\t.name = \"Master Volume\",\n\t\t.default_val = 127\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_bus_ctl,\n\t\t.control_id = SND_US16X08_ID_BYPASS,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"DSP Bypass Switch\",\n\t\t.default_val = 0\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_bus_ctl,\n\t\t.control_id = SND_US16X08_ID_BUSS_OUT,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"Buss Out Switch\",\n\t\t.default_val = 0\n\t},\n\t{  \n\t\t.kcontrol_new = &snd_us16x08_bus_ctl,\n\t\t.control_id = SND_US16X08_ID_MUTE,\n\t\t.type = USB_MIXER_BOOLEAN,\n\t\t.num_channels = 16,\n\t\t.name = \"Master Mute Switch\",\n\t\t.default_val = 0\n\t},\n\n};\n\nint snd_us16x08_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint i, j;\n\tint err;\n\tstruct usb_mixer_elem_info *elem;\n\tstruct snd_us16x08_comp_store *comp_store;\n\tstruct snd_us16x08_meter_store *meter_store;\n\tstruct snd_us16x08_eq_store *eq_store;\n\n\t \n\tif (mixer->hostif->desc.bInterfaceNumber == 3) {\n\n\t\t \n\t\terr = add_new_ctl(mixer, &snd_us16x08_route_ctl,\n\t\t\tSND_US16X08_ID_ROUTE, USB_MIXER_U8, 8, \"Line Out Route\",\n\t\t\tNULL, false, &elem);\n\t\tif (err < 0) {\n\t\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\t\"Failed to create route control, err:%d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < 8; i++)\n\t\t\telem->cache_val[i] = i < 2 ? i : i + 2;\n\t\telem->cached = 0xff;\n\n\t\t \n\t\tcomp_store = snd_us16x08_create_comp_store();\n\t\tif (!comp_store)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(master_controls); i++) {\n\n\t\t\terr = add_new_ctl(mixer,\n\t\t\t\tmaster_controls[i].kcontrol_new,\n\t\t\t\tmaster_controls[i].control_id,\n\t\t\t\tmaster_controls[i].type,\n\t\t\t\tmaster_controls[i].num_channels,\n\t\t\t\tmaster_controls[i].name,\n\t\t\t\tcomp_store,\n\t\t\t\ti == 0,  \n\t\t\t\t&elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\telem->cache_val[0] = master_controls[i].default_val;\n\t\t\telem->cached = 1;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(channel_controls); i++) {\n\n\t\t\terr = add_new_ctl(mixer,\n\t\t\t\tchannel_controls[i].kcontrol_new,\n\t\t\t\tchannel_controls[i].control_id,\n\t\t\t\tchannel_controls[i].type,\n\t\t\t\tchannel_controls[i].num_channels,\n\t\t\t\tchannel_controls[i].name,\n\t\t\t\tcomp_store,\n\t\t\t\tfalse, &elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tfor (j = 0; j < SND_US16X08_MAX_CHANNELS; j++) {\n\t\t\t\telem->cache_val[j] =\n\t\t\t\t\tchannel_controls[i].default_val;\n\t\t\t}\n\t\t\telem->cached = 0xffff;\n\t\t}\n\n\t\t \n\t\teq_store = snd_us16x08_create_eq_store();\n\t\tif (!eq_store)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(eq_controls); i++) {\n\n\t\t\terr = add_new_ctl(mixer,\n\t\t\t\teq_controls[i].kcontrol_new,\n\t\t\t\teq_controls[i].control_id,\n\t\t\t\teq_controls[i].type,\n\t\t\t\teq_controls[i].num_channels,\n\t\t\t\teq_controls[i].name,\n\t\t\t\teq_store,\n\t\t\t\ti == 0,  \n\t\t\t\tNULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(comp_controls); i++) {\n\n\t\t\terr = add_new_ctl(mixer,\n\t\t\t\tcomp_controls[i].kcontrol_new,\n\t\t\t\tcomp_controls[i].control_id,\n\t\t\t\tcomp_controls[i].type,\n\t\t\t\tcomp_controls[i].num_channels,\n\t\t\t\tcomp_controls[i].name,\n\t\t\t\tcomp_store,\n\t\t\t\tfalse, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tmeter_store = snd_us16x08_create_meter_store();\n\t\tif (!meter_store)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tmeter_store->comp_store = comp_store;\n\t\terr = add_new_ctl(mixer, &snd_us16x08_meter_ctl,\n\t\t\tSND_US16X08_ID_METER, USB_MIXER_U16, 0, \"Level Meter\",\n\t\t\tmeter_store, true, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}