{
  "module_name": "midi.c",
  "hash_id": "50a6ca72c34f13b71cbd0c6a9096b428662721ca88e1fe06b785ac528401e118",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/midi.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/rawmidi.h>\n#include <sound/asequencer.h>\n#include \"usbaudio.h\"\n#include \"midi.h\"\n#include \"power.h\"\n#include \"helper.h\"\n\n \n \n\n \n#define ERROR_DELAY_JIFFIES (HZ / 10)\n\n#define OUTPUT_URBS 7\n#define INPUT_URBS 7\n\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"USB Audio/MIDI helper module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstruct snd_usb_midi_in_endpoint;\nstruct snd_usb_midi_out_endpoint;\nstruct snd_usb_midi_endpoint;\n\nstruct usb_protocol_ops {\n\tvoid (*input)(struct snd_usb_midi_in_endpoint*, uint8_t*, int);\n\tvoid (*output)(struct snd_usb_midi_out_endpoint *ep, struct urb *urb);\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t);\n\tvoid (*init_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n\tvoid (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n};\n\nstruct snd_usb_midi {\n\tstruct usb_device *dev;\n\tstruct snd_card *card;\n\tstruct usb_interface *iface;\n\tconst struct snd_usb_audio_quirk *quirk;\n\tstruct snd_rawmidi *rmidi;\n\tconst struct usb_protocol_ops *usb_protocol_ops;\n\tstruct list_head list;\n\tstruct timer_list error_timer;\n\tspinlock_t disc_lock;\n\tstruct rw_semaphore disc_rwsem;\n\tstruct mutex mutex;\n\tu32 usb_id;\n\tint next_midi_device;\n\n\tstruct snd_usb_midi_endpoint {\n\t\tstruct snd_usb_midi_out_endpoint *out;\n\t\tstruct snd_usb_midi_in_endpoint *in;\n\t} endpoints[MIDI_MAX_ENDPOINTS];\n\tunsigned long input_triggered;\n\tunsigned int opened[2];\n\tunsigned char disconnected;\n\tunsigned char input_running;\n\n\tstruct snd_kcontrol *roland_load_ctl;\n};\n\nstruct snd_usb_midi_out_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct out_urb_context {\n\t\tstruct urb *urb;\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t} urbs[OUTPUT_URBS];\n\tunsigned int active_urbs;\n\tunsigned int drain_urbs;\n\tint max_transfer;\t\t \n\tstruct work_struct work;\n\tunsigned int next_urb;\n\tspinlock_t buffer_lock;\n\n\tstruct usbmidi_out_port {\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tint active;\n\t\tuint8_t cable;\t\t \n\t\tuint8_t state;\n#define STATE_UNKNOWN\t0\n#define STATE_1PARAM\t1\n#define STATE_2PARAM_1\t2\n#define STATE_2PARAM_2\t3\n#define STATE_SYSEX_0\t4\n#define STATE_SYSEX_1\t5\n#define STATE_SYSEX_2\t6\n\t\tuint8_t data[2];\n\t} ports[0x10];\n\tint current_port;\n\n\twait_queue_head_t drain_wait;\n};\n\nstruct snd_usb_midi_in_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct urb *urbs[INPUT_URBS];\n\tstruct usbmidi_in_port {\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tu8 running_status_length;\n\t} ports[0x10];\n\tu8 seen_f5;\n\tbool in_sysex;\n\tu8 last_cin;\n\tu8 error_resubmit;\n\tint current_port;\n};\n\nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep);\n\nstatic const uint8_t snd_usbmidi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n \nstatic int snd_usbmidi_submit_urb(struct urb *urb, gfp_t flags)\n{\n\tint err = usb_submit_urb(urb, flags);\n\tif (err < 0 && err != -ENODEV)\n\t\tdev_err(&urb->dev->dev, \"usb_submit_urb: %d\\n\", err);\n\treturn err;\n}\n\n \nstatic int snd_usbmidi_urb_error(const struct urb *urb)\n{\n\tswitch (urb->status) {\n\t \n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\tcase -ENODEV:\n\t\treturn -ENODEV;\n\t \n\tcase -EPROTO:\n\tcase -ETIME:\n\tcase -EILSEQ:\n\t\treturn -EIO;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"urb status %d\\n\", urb->status);\n\t\treturn 0;  \n\t}\n}\n\n \nstatic void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   int portidx, uint8_t *data, int length)\n{\n\tstruct usbmidi_in_port *port = &ep->ports[portidx];\n\n\tif (!port->substream) {\n\t\tdev_dbg(&ep->umidi->dev->dev, \"unexpected port %d!\\n\", portidx);\n\t\treturn;\n\t}\n\tif (!test_bit(port->substream->number, &ep->umidi->input_triggered))\n\t\treturn;\n\tsnd_rawmidi_receive(port->substream, data, length);\n}\n\n#ifdef DUMP_PACKETS\nstatic void dump_urb(const char *type, const u8 *data, int length)\n{\n\tsnd_printk(KERN_DEBUG \"%s packet: [\", type);\n\tfor (; length > 0; ++data, --length)\n\t\tprintk(KERN_CONT \" %02x\", *data);\n\tprintk(KERN_CONT \" ]\\n\");\n}\n#else\n#define dump_urb(type, data, length)  \n#endif\n\n \nstatic void snd_usbmidi_in_urb_complete(struct urb *urb)\n{\n\tstruct snd_usb_midi_in_endpoint *ep = urb->context;\n\n\tif (urb->status == 0) {\n\t\tdump_urb(\"received\", urb->transfer_buffer, urb->actual_length);\n\t\tep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,\n\t\t\t\t\t\t   urb->actual_length);\n\t} else {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV) {\n\t\t\t\tep->error_resubmit = 1;\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\turb->dev = ep->umidi->dev;\n\tsnd_usbmidi_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void snd_usbmidi_out_urb_complete(struct urb *urb)\n{\n\tstruct out_urb_context *context = urb->context;\n\tstruct snd_usb_midi_out_endpoint *ep = context->ep;\n\tunsigned int urb_index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->buffer_lock, flags);\n\turb_index = context - ep->urbs;\n\tep->active_urbs &= ~(1 << urb_index);\n\tif (unlikely(ep->drain_urbs)) {\n\t\tep->drain_urbs &= ~(1 << urb_index);\n\t\twake_up(&ep->drain_wait);\n\t}\n\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n\tif (urb->status < 0) {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\treturn;\n\t\t}\n\t}\n\tsnd_usbmidi_do_output(ep);\n}\n\n \nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int urb_index;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->buffer_lock, flags);\n\tif (ep->umidi->disconnected) {\n\t\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n\t\treturn;\n\t}\n\n\turb_index = ep->next_urb;\n\tfor (;;) {\n\t\tif (!(ep->active_urbs & (1 << urb_index))) {\n\t\t\turb = ep->urbs[urb_index].urb;\n\t\t\turb->transfer_buffer_length = 0;\n\t\t\tep->umidi->usb_protocol_ops->output(ep, urb);\n\t\t\tif (urb->transfer_buffer_length == 0)\n\t\t\t\tbreak;\n\n\t\t\tdump_urb(\"sending\", urb->transfer_buffer,\n\t\t\t\t urb->transfer_buffer_length);\n\t\t\turb->dev = ep->umidi->dev;\n\t\t\tif (snd_usbmidi_submit_urb(urb, GFP_ATOMIC) < 0)\n\t\t\t\tbreak;\n\t\t\tep->active_urbs |= 1 << urb_index;\n\t\t}\n\t\tif (++urb_index >= OUTPUT_URBS)\n\t\t\turb_index = 0;\n\t\tif (urb_index == ep->next_urb)\n\t\t\tbreak;\n\t}\n\tep->next_urb = urb_index;\n\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n}\n\nstatic void snd_usbmidi_out_work(struct work_struct *work)\n{\n\tstruct snd_usb_midi_out_endpoint *ep =\n\t\tcontainer_of(work, struct snd_usb_midi_out_endpoint, work);\n\n\tsnd_usbmidi_do_output(ep);\n}\n\n \nstatic void snd_usbmidi_error_timer(struct timer_list *t)\n{\n\tstruct snd_usb_midi *umidi = from_timer(umidi, t, error_timer);\n\tunsigned int i, j;\n\n\tspin_lock(&umidi->disc_lock);\n\tif (umidi->disconnected) {\n\t\tspin_unlock(&umidi->disc_lock);\n\t\treturn;\n\t}\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_in_endpoint *in = umidi->endpoints[i].in;\n\t\tif (in && in->error_resubmit) {\n\t\t\tin->error_resubmit = 0;\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j) {\n\t\t\t\tif (atomic_read(&in->urbs[j]->use_count))\n\t\t\t\t\tcontinue;\n\t\t\t\tin->urbs[j]->dev = umidi->dev;\n\t\t\t\tsnd_usbmidi_submit_urb(in->urbs[j], GFP_ATOMIC);\n\t\t\t}\n\t\t}\n\t\tif (umidi->endpoints[i].out)\n\t\t\tsnd_usbmidi_do_output(umidi->endpoints[i].out);\n\t}\n\tspin_unlock(&umidi->disc_lock);\n}\n\n \nstatic int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t const void *data, int len)\n{\n\tint err = 0;\n\tvoid *buf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tdump_urb(\"sending\", buf, len);\n\tif (ep->urbs[0].urb)\n\t\terr = usb_bulk_msg(ep->umidi->dev, ep->urbs[0].urb->pipe,\n\t\t\t\t   buf, len, NULL, 250);\n\tkfree(buf);\n\treturn err;\n}\n\n \n\nstatic void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tint length = snd_usbmidi_cin_length[buffer[i] & 0x0f];\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\nstatic void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t      uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i + 3] != 0) {\n\t\t\tint port = buffer[i + 3] >> 4;\n\t\t\tint length = buffer[i + 3] & 3;\n\t\t\tsnd_usbmidi_input_data(ep, port, &buffer[i], length);\n\t\t}\n}\n\n \nstatic void snd_usbmidi_maudio_broken_running_status_input(\n\t\t\t\t\tstruct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t\tuint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tu8 cin = buffer[i] & 0x0f;\n\t\t\tstruct usbmidi_in_port *port = &ep->ports[cable];\n\t\t\tint length;\n\n\t\t\tlength = snd_usbmidi_cin_length[cin];\n\t\t\tif (cin == 0xf && buffer[i + 1] >= 0xf8)\n\t\t\t\t;  \n\t\t\telse if (cin >= 0x8 && cin <= 0xe)\n\t\t\t\t \n\t\t\t\tport->running_status_length = length - 1;\n\t\t\telse if (cin == 0x4 &&\n\t\t\t\t port->running_status_length != 0 &&\n\t\t\t\t buffer[i + 1] < 0x80)\n\t\t\t\t \n\t\t\t\tlength = port->running_status_length;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tport->running_status_length = 0;\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\n \nstatic void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tunsigned int i, cin, length;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4) {\n\t\tif (buffer[i] == 0 && i > 0)\n\t\t\tbreak;\n\t\tcin = buffer[i] & 0x0f;\n\t\tif (ep->in_sysex &&\n\t\t    cin == ep->last_cin &&\n\t\t    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)\n\t\t\tcin = 0x4;\n#if 0\n\t\tif (buffer[i + 1] == 0x90) {\n\t\t\t \n\t\t}\n#endif\n\t\tlength = snd_usbmidi_cin_length[cin];\n\t\tsnd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);\n\t\tep->in_sysex = cin == 0x4;\n\t\tif (!ep->in_sysex)\n\t\t\tep->last_cin = cin;\n\t}\n}\n\n \nstatic void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || (buffer[0] & 0x0f) != 0x0f)\n\t\tsnd_usbmidi_standard_input(ep, buffer, buffer_length);\n\telse\n\t\tsnd_usbmidi_input_data(ep, buffer[0] >> 4,\n\t\t\t\t       &buffer[1], buffer_length - 1);\n}\n\n \nstatic void snd_usbmidi_output_standard_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t       uint8_t p1, uint8_t p2,\n\t\t\t\t\t       uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p0;\n\tbuf[1] = p1;\n\tbuf[2] = p2;\n\tbuf[3] = p3;\n\turb->transfer_buffer_length += 4;\n}\n\n \nstatic void snd_usbmidi_output_midiman_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t      uint8_t p1, uint8_t p2,\n\t\t\t\t\t      uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p1;\n\tbuf[1] = p2;\n\tbuf[2] = p3;\n\tbuf[3] = (p0 & 0xf0) | snd_usbmidi_cin_length[p0 & 0x0f];\n\turb->transfer_buffer_length += 4;\n}\n\n \nstatic void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port,\n\t\t\t\t      uint8_t b, struct urb *urb)\n{\n\tuint8_t p0 = port->cable;\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t) =\n\t\tport->ep->umidi->usb_protocol_ops->output_packet;\n\n\tif (b >= 0xf8) {\n\t\toutput_packet(urb, p0 | 0x0f, b, 0, 0);\n\t} else if (b >= 0xf0) {\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\toutput_packet(urb, p0 | 0x05, 0xf6, 0, 0);\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf7:\n\t\t\tswitch (port->state) {\n\t\t\tcase STATE_SYSEX_0:\n\t\t\t\toutput_packet(urb, p0 | 0x05, 0xf7, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_1:\n\t\t\t\toutput_packet(urb, p0 | 0x06, port->data[0],\n\t\t\t\t\t      0xf7, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_2:\n\t\t\t\toutput_packet(urb, p0 | 0x07, port->data[0],\n\t\t\t\t\t      port->data[1], 0xf7);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else if (b >= 0x80) {\n\t\tport->data[0] = b;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tport->state = STATE_1PARAM;\n\t\telse\n\t\t\tport->state = STATE_2PARAM_1;\n\t} else {  \n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x02;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], b, 0);\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t\tport->state = STATE_2PARAM_1;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x03;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], port->data[1], b);\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\toutput_packet(urb, p0 | 0x04, port->data[0],\n\t\t\t\t      port->data[1], b);\n\t\t\tport->state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tint p;\n\n\t \n\tfor (p = 0; p < 0x10; ++p) {\n\t\tstruct usbmidi_out_port *port = &ep->ports[p];\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\twhile (urb->transfer_buffer_length + 3 < ep->max_transfer) {\n\t\t\tuint8_t b;\n\t\t\tif (snd_rawmidi_transmit(port->substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnd_usbmidi_transmit_byte(port, b, urb);\n\t\t}\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_standard_ops = {\n\t.input = snd_usbmidi_standard_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_midiman_ops = {\n\t.input = snd_usbmidi_midiman_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_midiman_packet,\n};\n\nstatic const\nstruct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {\n\t.input = snd_usbmidi_maudio_broken_running_status_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_cme_ops = {\n\t.input = snd_usbmidi_cme_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {\n\t.input = ch345_broken_sysex_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\n \nstatic void snd_usbmidi_akai_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tunsigned int pos = 0;\n\tunsigned int len = (unsigned int)buffer_length;\n\twhile (pos < len) {\n\t\tunsigned int port = (buffer[pos] >> 4) - 1;\n\t\tunsigned int msg_len = buffer[pos] & 0x0f;\n\t\tpos++;\n\t\tif (pos + msg_len <= len && port < 2)\n\t\t\tsnd_usbmidi_input_data(ep, 0, &buffer[pos], msg_len);\n\t\tpos += msg_len;\n\t}\n}\n\n#define MAX_AKAI_SYSEX_LEN 9\n\nstatic void snd_usbmidi_akai_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t    struct urb *urb)\n{\n\tuint8_t *msg;\n\tint pos, end, count, buf_end;\n\tuint8_t tmp[MAX_AKAI_SYSEX_LEN];\n\tstruct snd_rawmidi_substream *substream = ep->ports[0].substream;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\n\tmsg = urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf_end = ep->max_transfer - MAX_AKAI_SYSEX_LEN - 1;\n\n\t \n\twhile (urb->transfer_buffer_length < buf_end) {\n\t\tcount = snd_rawmidi_transmit_peek(substream,\n\t\t\t\t\t\t  tmp, MAX_AKAI_SYSEX_LEN);\n\t\tif (!count) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tfor (pos = 0; pos < count && tmp[pos] != 0xF0; pos++)\n\t\t\t;\n\n\t\tif (pos > 0) {\n\t\t\tsnd_rawmidi_transmit_ack(substream, pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (end = 1; end < count && tmp[end] < 0xF0; end++)\n\t\t\t;\n\n\t\t \n\t\tif (end < count && tmp[end] == 0xF0) {\n\t\t\t \n\t\t\tsnd_rawmidi_transmit_ack(substream, end);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (end < count && tmp[end] == 0xF7) {\n\t\t\t \n\t\t\tcount = end + 1;\n\t\t\tmsg[0] = 0x10 | count;\n\t\t\tmemcpy(&msg[1], tmp, count);\n\t\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t\t\turb->transfer_buffer_length += count + 1;\n\t\t\tmsg += count + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (count < MAX_AKAI_SYSEX_LEN) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_akai_ops = {\n\t.input = snd_usbmidi_akai_input,\n\t.output = snd_usbmidi_akai_output,\n};\n\n \n\nstatic void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || !buffer[0] || buffer_length < buffer[0] + 1)\n\t\treturn;\n\tsnd_usbmidi_input_data(ep, 0, &buffer[2], buffer[0] - 1);\n}\n\nstatic void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tuint8_t *transfer_buffer;\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\ttransfer_buffer = urb->transfer_buffer;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     &transfer_buffer[2],\n\t\t\t\t     ep->max_transfer - 2);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\ttransfer_buffer[0] = 0;\n\ttransfer_buffer[1] = count;\n\turb->transfer_buffer_length = 2 + count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_novation_ops = {\n\t.input = snd_usbmidi_novation_input,\n\t.output = snd_usbmidi_novation_output,\n};\n\n \n\nstatic void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t   struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     ep->max_transfer);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\turb->transfer_buffer_length = count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_raw_ops = {\n\t.input = snd_usbmidi_raw_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\n \n\nstatic void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length > 2)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_ftdi_ops = {\n\t.input = snd_usbmidi_ftdi_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\nstatic void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length != 9)\n\t\treturn;\n\tbuffer_length = 8;\n\twhile (buffer_length && buffer[buffer_length - 1] == 0xFD)\n\t\tbuffer_length--;\n\tif (buffer_length)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tswitch (snd_usb_get_speed(ep->umidi->dev)) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tcount = 1;\n\t\tbreak;\n\tdefault:\n\t\tcount = 2;\n\t}\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     count);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\n\tmemset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);\n\turb->transfer_buffer_length = ep->max_transfer;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_122l_ops = {\n\t.input = snd_usbmidi_us122l_input,\n\t.output = snd_usbmidi_us122l_output,\n};\n\n \n\nstatic void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 init_data[] = {\n\t\t \n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t \n\t\t0x64,\t\t\t \n\t\t0x0b,\t\t\t \n\t\t0x00,\t\t\t \n\t\t0x00,\t\t\t \n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n\t \n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n}\n\nstatic void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 finish_data[] = {\n\t\t \n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t \n\t\t0x64,\t\t\t \n\t\t0x10,\t\t\t \n\t\t0x00,\t\t\t \n\t\t0x7f,\t\t\t \n\t\t0x40,\t\t\t \n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, finish_data, sizeof(finish_data));\n}\n\nstatic void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < buffer_length; ++i)\n\t\tif (buffer[i] == 0xff) {\n\t\t\tbuffer_length = i;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (ep->seen_f5)\n\t\tgoto switch_port;\n\n\twhile (buffer_length > 0) {\n\t\t \n\t\tfor (i = 0; i < buffer_length; ++i)\n\t\t\tif (buffer[i] == 0xf5)\n\t\t\t\tbreak;\n\t\tsnd_usbmidi_input_data(ep, ep->current_port, buffer, i);\n\t\tbuffer += i;\n\t\tbuffer_length -= i;\n\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\t \n\t\tep->seen_f5 = 1;\n\t\t++buffer;\n\t\t--buffer_length;\n\n\tswitch_port:\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\tif (buffer[0] < 0x80) {\n\t\t\tep->current_port = (buffer[0] - 1) & 15;\n\t\t\t++buffer;\n\t\t\t--buffer_length;\n\t\t}\n\t\tep->seen_f5 = 0;\n\t}\n}\n\nstatic void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint port0 = ep->current_port;\n\tuint8_t *buf = urb->transfer_buffer;\n\tint buf_free = ep->max_transfer;\n\tint length, i;\n\n\tfor (i = 0; i < 0x10; ++i) {\n\t\t \n\t\tint portnum = (port0 + i) & 15;\n\t\tstruct usbmidi_out_port *port = &ep->ports[portnum];\n\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\tif (snd_rawmidi_transmit_peek(port->substream, buf, 1) != 1) {\n\t\t\tport->active = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (portnum != ep->current_port) {\n\t\t\tif (buf_free < 2)\n\t\t\t\tbreak;\n\t\t\tep->current_port = portnum;\n\t\t\tbuf[0] = 0xf5;\n\t\t\tbuf[1] = (portnum + 1) & 15;\n\t\t\tbuf += 2;\n\t\t\tbuf_free -= 2;\n\t\t}\n\n\t\tif (buf_free < 1)\n\t\t\tbreak;\n\t\tlength = snd_rawmidi_transmit(port->substream, buf, buf_free);\n\t\tif (length > 0) {\n\t\t\tbuf += length;\n\t\t\tbuf_free -= length;\n\t\t\tif (buf_free < 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (buf_free < ep->max_transfer && buf_free > 0) {\n\t\t*buf = 0xff;\n\t\t--buf_free;\n\t}\n\turb->transfer_buffer_length = ep->max_transfer - buf_free;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_emagic_ops = {\n\t.input = snd_usbmidi_emagic_input,\n\t.output = snd_usbmidi_emagic_output,\n\t.init_out_endpoint = snd_usbmidi_emagic_init_out,\n\t.finish_out_endpoint = snd_usbmidi_emagic_finish_out,\n};\n\n\nstatic void update_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tint is_light_load;\n\n\tintf = umidi->iface;\n\tis_light_load = intf->cur_altsetting != intf->altsetting;\n\tif (umidi->roland_load_ctl->private_value == is_light_load)\n\t\treturn;\n\thostif = &intf->altsetting[umidi->roland_load_ctl->private_value];\n\tintfd = get_iface_desc(hostif);\n\tsnd_usbmidi_input_stop(&umidi->list);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\tsnd_usbmidi_input_start(&umidi->list);\n}\n\nstatic int substream_open(struct snd_rawmidi_substream *substream, int dir,\n\t\t\t  int open)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct snd_kcontrol *ctl;\n\n\tdown_read(&umidi->disc_rwsem);\n\tif (umidi->disconnected) {\n\t\tup_read(&umidi->disc_rwsem);\n\t\treturn open ? -ENODEV : 0;\n\t}\n\n\tmutex_lock(&umidi->mutex);\n\tif (open) {\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access |=\n\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t\tupdate_roland_altsetting(umidi);\n\t\t\t}\n\t\t}\n\t\tumidi->opened[dir]++;\n\t\tif (umidi->opened[1])\n\t\t\tsnd_usbmidi_input_start(&umidi->list);\n\t} else {\n\t\tumidi->opened[dir]--;\n\t\tif (!umidi->opened[1])\n\t\t\tsnd_usbmidi_input_stop(&umidi->list);\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access &=\n\t\t\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&umidi->mutex);\n\tup_read(&umidi->disc_rwsem);\n\treturn 0;\n}\n\nstatic int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct usbmidi_out_port *port = NULL;\n\tint i, j;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tif (umidi->endpoints[i].out)\n\t\t\tfor (j = 0; j < 0x10; ++j)\n\t\t\t\tif (umidi->endpoints[i].out->ports[j].substream == substream) {\n\t\t\t\t\tport = &umidi->endpoints[i].out->ports[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\tif (!port)\n\t\treturn -ENXIO;\n\n\tsubstream->runtime->private_data = port;\n\tport->state = STATE_UNKNOWN;\n\treturn substream_open(substream, 0, 1);\n}\n\nstatic int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct usbmidi_out_port *port = substream->runtime->private_data;\n\n\tcancel_work_sync(&port->ep->work);\n\treturn substream_open(substream, 0, 0);\n}\n\nstatic void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t       int up)\n{\n\tstruct usbmidi_out_port *port =\n\t\t(struct usbmidi_out_port *)substream->runtime->private_data;\n\n\tport->active = up;\n\tif (up) {\n\t\tif (port->ep->umidi->disconnected) {\n\t\t\t \n\t\t\tsnd_rawmidi_proceed(substream);\n\t\t\treturn;\n\t\t}\n\t\tqueue_work(system_highpri_wq, &port->ep->work);\n\t}\n}\n\nstatic void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct usbmidi_out_port *port = substream->runtime->private_data;\n\tstruct snd_usb_midi_out_endpoint *ep = port->ep;\n\tunsigned int drain_urbs;\n\tDEFINE_WAIT(wait);\n\tlong timeout = msecs_to_jiffies(50);\n\n\tif (ep->umidi->disconnected)\n\t\treturn;\n\t \n\tspin_lock_irq(&ep->buffer_lock);\n\tdrain_urbs = ep->active_urbs;\n\tif (drain_urbs) {\n\t\tep->drain_urbs |= drain_urbs;\n\t\tdo {\n\t\t\tprepare_to_wait(&ep->drain_wait, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ep->buffer_lock);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tspin_lock_irq(&ep->buffer_lock);\n\t\t\tdrain_urbs &= ep->drain_urbs;\n\t\t} while (drain_urbs && timeout);\n\t\tfinish_wait(&ep->drain_wait, &wait);\n\t}\n\tport->active = 0;\n\tspin_unlock_irq(&ep->buffer_lock);\n}\n\nstatic int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 1);\n}\n\nstatic int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 0);\n}\n\nstatic void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int up)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\n\tif (up)\n\t\tset_bit(substream->number, &umidi->input_triggered);\n\telse\n\t\tclear_bit(substream->number, &umidi->input_triggered);\n}\n\nstatic const struct snd_rawmidi_ops snd_usbmidi_output_ops = {\n\t.open = snd_usbmidi_output_open,\n\t.close = snd_usbmidi_output_close,\n\t.trigger = snd_usbmidi_output_trigger,\n\t.drain = snd_usbmidi_output_drain,\n};\n\nstatic const struct snd_rawmidi_ops snd_usbmidi_input_ops = {\n\t.open = snd_usbmidi_input_open,\n\t.close = snd_usbmidi_input_close,\n\t.trigger = snd_usbmidi_input_trigger\n};\n\nstatic void free_urb_and_buffer(struct snd_usb_midi *umidi, struct urb *urb,\n\t\t\t\tunsigned int buffer_length)\n{\n\tusb_free_coherent(umidi->dev, buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\n \nstatic void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < INPUT_URBS; ++i)\n\t\tif (ep->urbs[i])\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i],\n\t\t\t\t\t    ep->urbs[i]->transfer_buffer_length);\n\tkfree(ep);\n}\n\n \nstatic int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t  struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t  struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_in_endpoint *ep;\n\tvoid *buffer;\n\tunsigned int pipe;\n\tint length;\n\tunsigned int i;\n\tint err;\n\n\trep->in = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tep->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (ep_info->in_interval)\n\t\tpipe = usb_rcvintpipe(umidi->dev, ep_info->in_ep);\n\telse\n\t\tpipe = usb_rcvbulkpipe(umidi->dev, ep_info->in_ep);\n\tlength = usb_maxpacket(umidi->dev, pipe);\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev, length, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i]->transfer_dma);\n\t\tif (!buffer) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tif (ep_info->in_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t pipe, buffer, length,\n\t\t\t\t\t snd_usbmidi_in_urb_complete,\n\t\t\t\t\t ep, ep_info->in_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t  pipe, buffer, length,\n\t\t\t\t\t  snd_usbmidi_in_urb_complete, ep);\n\t\tep->urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\terr = usb_urb_ep_type_check(ep->urbs[i]);\n\t\tif (err < 0) {\n\t\t\tdev_err(&umidi->dev->dev, \"invalid MIDI in EP %x\\n\",\n\t\t\t\tep_info->in_ep);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trep->in = ep;\n\treturn 0;\n\n error:\n\tsnd_usbmidi_in_endpoint_delete(ep);\n\treturn err;\n}\n\n \nstatic void snd_usbmidi_out_endpoint_clear(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i)\n\t\tif (ep->urbs[i].urb) {\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i].urb,\n\t\t\t\t\t    ep->max_transfer);\n\t\t\tep->urbs[i].urb = NULL;\n\t\t}\n}\n\nstatic void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep)\n{\n\tsnd_usbmidi_out_endpoint_clear(ep);\n\tkfree(ep);\n}\n\n \nstatic int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t   struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t   struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_out_endpoint *ep;\n\tunsigned int i;\n\tunsigned int pipe;\n\tvoid *buffer;\n\tint err;\n\n\trep->out = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tep->urbs[i].urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i].urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tep->urbs[i].ep = ep;\n\t}\n\tif (ep_info->out_interval)\n\t\tpipe = usb_sndintpipe(umidi->dev, ep_info->out_ep);\n\telse\n\t\tpipe = usb_sndbulkpipe(umidi->dev, ep_info->out_ep);\n\tswitch (umidi->usb_id) {\n\tdefault:\n\t\tep->max_transfer = usb_maxpacket(umidi->dev, pipe);\n\t\tbreak;\n\t\t \n\tcase USB_ID(0x0a67, 0x5011):  \n\tcase USB_ID(0x0a92, 0x1020):  \n\tcase USB_ID(0x1430, 0x474b):  \n\tcase USB_ID(0x15ca, 0x0101):  \n\tcase USB_ID(0x15ca, 0x1806):  \n\tcase USB_ID(0x1a86, 0x752d):  \n\tcase USB_ID(0xfc08, 0x0101):  \n\t\tep->max_transfer = 4;\n\t\tbreak;\n\t\t \n\tcase USB_ID(0x0644, 0x800e):  \n\tcase USB_ID(0x0644, 0x800f):  \n\t\tep->max_transfer = 9;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev,\n\t\t\t\t\t    ep->max_transfer, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i].urb->transfer_dma);\n\t\tif (!buffer) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tif (ep_info->out_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t pipe, buffer, ep->max_transfer,\n\t\t\t\t\t snd_usbmidi_out_urb_complete,\n\t\t\t\t\t &ep->urbs[i], ep_info->out_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t  pipe, buffer, ep->max_transfer,\n\t\t\t\t\t  snd_usbmidi_out_urb_complete,\n\t\t\t\t\t  &ep->urbs[i]);\n\t\terr = usb_urb_ep_type_check(ep->urbs[i].urb);\n\t\tif (err < 0) {\n\t\t\tdev_err(&umidi->dev->dev, \"invalid MIDI out EP %x\\n\",\n\t\t\t\tep_info->out_ep);\n\t\t\tgoto error;\n\t\t}\n\t\tep->urbs[i].urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\tspin_lock_init(&ep->buffer_lock);\n\tINIT_WORK(&ep->work, snd_usbmidi_out_work);\n\tinit_waitqueue_head(&ep->drain_wait);\n\n\tfor (i = 0; i < 0x10; ++i)\n\t\tif (ep_info->out_cables & (1 << i)) {\n\t\t\tep->ports[i].ep = ep;\n\t\t\tep->ports[i].cable = i << 4;\n\t\t}\n\n\tif (umidi->usb_protocol_ops->init_out_endpoint)\n\t\tumidi->usb_protocol_ops->init_out_endpoint(ep);\n\n\trep->out = ep;\n\treturn 0;\n\n error:\n\tsnd_usbmidi_out_endpoint_delete(ep);\n\treturn err;\n}\n\n \nstatic void snd_usbmidi_free(struct snd_usb_midi *umidi)\n{\n\tint i;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep->out);\n\t\tif (ep->in)\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t}\n\tmutex_destroy(&umidi->mutex);\n\tkfree(umidi);\n}\n\n \nvoid snd_usbmidi_disconnect(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\t \n\tdown_write(&umidi->disc_rwsem);\n\tspin_lock_irq(&umidi->disc_lock);\n\tumidi->disconnected = 1;\n\tspin_unlock_irq(&umidi->disc_lock);\n\tup_write(&umidi->disc_rwsem);\n\n\tdel_timer_sync(&umidi->error_timer);\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\tcancel_work_sync(&ep->out->work);\n\t\tif (ep->out) {\n\t\t\tfor (j = 0; j < OUTPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->out->urbs[j].urb);\n\t\t\tif (umidi->usb_protocol_ops->finish_out_endpoint)\n\t\t\t\tumidi->usb_protocol_ops->finish_out_endpoint(ep->out);\n\t\t\tep->out->active_urbs = 0;\n\t\t\tif (ep->out->drain_urbs) {\n\t\t\t\tep->out->drain_urbs = 0;\n\t\t\t\twake_up(&ep->out->drain_wait);\n\t\t\t}\n\t\t}\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t\t \n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_clear(ep->out);\n\t\tif (ep->in) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t\t\tep->in = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(snd_usbmidi_disconnect);\n\nstatic void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tsnd_usbmidi_free(umidi);\n}\n\nstatic struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t\t\tint stream,\n\t\t\t\t\t\t\t\tint number)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\tlist_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams,\n\t\t\t    list) {\n\t\tif (substream->number == number)\n\t\t\treturn substream;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct port_info {\n\tu32 id;\n\tshort int port;\n\tshort int voices;\n\tconst char *name;\n\tunsigned int seq_flags;\n} snd_usbmidi_port_info[] = {\n#define PORT_INFO(vendor, product, num, name_, voices_, flags) \\\n\t{ .id = USB_ID(vendor, product), \\\n\t  .port = num, .voices = voices_, \\\n\t  .name = name_, .seq_flags = flags }\n#define EXTERNAL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_PORT)\n#define CONTROL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE)\n#define GM_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define ROLAND_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define SOUNDCANVAS_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_MT32 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n\t \n\tGM_SYNTH_PORT(0x0499, 0x105c, 0, \"%s Tone Generator\", 128),\n\tCONTROL_PORT(0x0499, 0x105c, 1, \"%s Remote Control\"),\n\tEXTERNAL_PORT(0x0499, 0x105c, 2, \"%s Thru\"),\n\tCONTROL_PORT(0x0499, 0x105c, 3, \"%s Editor\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0000, 2, \"%s Control\"),\n\t \n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 0, \"%s Part A\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 1, \"%s Part B\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 2, \"%s Part C\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 3, \"%s Part D\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0003, 4, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0003, 5, \"%s MIDI 2\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x0004, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0004, 1, \"%s Control\"),\n\t \n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0007, 2, \"%s MIDI\"),\n\t \n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000b, 2, \"%s MIDI\"),\n\t \n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000c, 2, \"%s MIDI\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0014, 8, \"%s Control\"),\n\t \n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0016, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0016, 3, \"%s MIDI 2\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0023, 5, \"%s Control\"),\n\t \n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 0, \"%s Part A\", 64),\n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0027, 2, \"%s MIDI\"),\n\t \n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0029, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0029, 3, \"%s MIDI 2\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x002b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x002b, 1, \"%s Control\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x002f, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 1, \"%s External MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 2, \"%s Sync\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x0033, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 2, \"%s 2\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x003b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x003b, 1, \"%s Control\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x0044, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0044, 1, \"%s Control\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x0048, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 2, \"%s 2\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x004d, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 2, \"%s 2\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0089, 0, \"%s Control\"),\n\t \n\tCONTROL_PORT(0x0582, 0x009a, 3, \"%s Control\"),\n\t \n\tCONTROL_PORT(0x0582, 0x00b2, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x00b2, 1, \"%s MIDI\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x00eb, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x00eb, 1, \"%s Control\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0102, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0102, 1, \"%s MIDI\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x010f, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x010f, 1, \"%s 1\"),\n\tCONTROL_PORT(0x0582, 0x010f, 2, \"%s 2\"),\n\t \n\tROLAND_SYNTH_PORT(0x0582, 0x0114, 0, \"%s Synth\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0114, 1, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0114, 2, \"%s Control\"),\n\t \n\tEXTERNAL_PORT(0x0582, 0x0120, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0120, 1, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0121, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0121, 1, \"%s Control\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0145, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0145, 1, \"%s MIDI\"),\n\t \n\tCONTROL_PORT(0x0582, 0x0156, 0, \"%s Keyboard\"),\n\tEXTERNAL_PORT(0x0582, 0x0156, 1, \"%s MIDI\"),\n\t \n\tROLAND_SYNTH_PORT(0x0582, 0x015b, 0, \"%s Synth\", 128),\n\tCONTROL_PORT(0x0582, 0x015b, 1, \"%s Control\"),\n\t \n\tCONTROL_PORT(0x0763, 0x1031, 8, \"%s Control\"),\n\tCONTROL_PORT(0x0763, 0x1033, 8, \"%s Control\"),\n\t \n\tEXTERNAL_PORT(0x07fd, 0x0001, 0, \"%s MIDI A\"),\n\tEXTERNAL_PORT(0x07fd, 0x0001, 1, \"%s MIDI B\"),\n\t \n\tEXTERNAL_PORT(0x086a, 0x0001, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0002, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0003, 4, \"%s Broadcast\"),\n\t \n\tCONTROL_PORT(0x09e8, 0x0062, 0, \"%s Control\"),\n\tPORT_INFO(0x09e8, 0x0062, 1, \"%s MIDI\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE),\n\t \n\tEXTERNAL_PORT(0x133e, 0x0815, 0, \"%s MIDI\"),\n\tPORT_INFO(0x133e, 0x0815, 1, \"%s Synth\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\tSNDRV_SEQ_PORT_TYPE_SYNTHESIZER),\n};\n\nstatic struct port_info *find_port_info(struct snd_usb_midi *umidi, int number)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_usbmidi_port_info); ++i) {\n\t\tif (snd_usbmidi_port_info[i].id == umidi->usb_id &&\n\t\t    snd_usbmidi_port_info[i].port == number)\n\t\t\treturn &snd_usbmidi_port_info[i];\n\t}\n\treturn NULL;\n}\n\nstatic void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi, int number,\n\t\t\t\t      struct snd_seq_port_info *seq_port_info)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tstruct port_info *port_info;\n\n\t \n\tport_info = find_port_info(umidi, number);\n\tif (port_info) {\n\t\tseq_port_info->type = port_info->seq_flags;\n\t\tseq_port_info->midi_voices = port_info->voices;\n\t}\n}\n\nstatic struct usb_midi_in_jack_descriptor *find_usb_in_jack_descriptor(\n\t\t\t\t\tstruct usb_host_interface *hostif, uint8_t jack_id)\n{\n\tunsigned char *extra = hostif->extra;\n\tint extralen = hostif->extralen;\n\n\twhile (extralen > 4) {\n\t\tstruct usb_midi_in_jack_descriptor *injd =\n\t\t\t\t(struct usb_midi_in_jack_descriptor *)extra;\n\n\t\tif (injd->bLength >= sizeof(*injd) &&\n\t\t    injd->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    injd->bDescriptorSubtype == UAC_MIDI_IN_JACK &&\n\t\t\t\tinjd->bJackID == jack_id)\n\t\t\treturn injd;\n\t\tif (!extra[0])\n\t\t\tbreak;\n\t\textralen -= extra[0];\n\t\textra += extra[0];\n\t}\n\treturn NULL;\n}\n\nstatic struct usb_midi_out_jack_descriptor *find_usb_out_jack_descriptor(\n\t\t\t\t\tstruct usb_host_interface *hostif, uint8_t jack_id)\n{\n\tunsigned char *extra = hostif->extra;\n\tint extralen = hostif->extralen;\n\n\twhile (extralen > 4) {\n\t\tstruct usb_midi_out_jack_descriptor *outjd =\n\t\t\t\t(struct usb_midi_out_jack_descriptor *)extra;\n\n\t\tif (outjd->bLength >= sizeof(*outjd) &&\n\t\t    outjd->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    outjd->bDescriptorSubtype == UAC_MIDI_OUT_JACK &&\n\t\t\t\toutjd->bJackID == jack_id)\n\t\t\treturn outjd;\n\t\tif (!extra[0])\n\t\t\tbreak;\n\t\textralen -= extra[0];\n\t\textra += extra[0];\n\t}\n\treturn NULL;\n}\n\nstatic void snd_usbmidi_init_substream(struct snd_usb_midi *umidi,\n\t\t\t\t       int stream, int number, int jack_id,\n\t\t\t\t       struct snd_rawmidi_substream **rsubstream)\n{\n\tstruct port_info *port_info;\n\tconst char *name_format;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_midi_in_jack_descriptor *injd;\n\tstruct usb_midi_out_jack_descriptor *outjd;\n\tuint8_t jack_name_buf[32];\n\tuint8_t *default_jack_name = \"MIDI\";\n\tuint8_t *jack_name = default_jack_name;\n\tuint8_t iJack;\n\tsize_t sz;\n\tint res;\n\n\tstruct snd_rawmidi_substream *substream =\n\t\tsnd_usbmidi_find_substream(umidi, stream, number);\n\tif (!substream) {\n\t\tdev_err(&umidi->dev->dev, \"substream %d:%d not found\\n\", stream,\n\t\t\tnumber);\n\t\treturn;\n\t}\n\n\tintf = umidi->iface;\n\tif (intf && jack_id >= 0) {\n\t\thostif = intf->cur_altsetting;\n\t\tiJack = 0;\n\t\tif (stream != SNDRV_RAWMIDI_STREAM_OUTPUT) {\n\t\t\t \n\t\t\toutjd = find_usb_out_jack_descriptor(hostif, jack_id);\n\t\t\tif (outjd) {\n\t\t\t\tsz = USB_DT_MIDI_OUT_SIZE(outjd->bNrInputPins);\n\t\t\t\tif (outjd->bLength >= sz)\n\t\t\t\t\tiJack = *(((uint8_t *) outjd) + sz - sizeof(uint8_t));\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tinjd = find_usb_in_jack_descriptor(hostif, jack_id);\n\t\t\tif (injd)\n\t\t\t\tiJack = injd->iJack;\n\t\t}\n\t\tif (iJack != 0) {\n\t\t\tres = usb_string(umidi->dev, iJack, jack_name_buf,\n\t\t\t  ARRAY_SIZE(jack_name_buf));\n\t\t\tif (res)\n\t\t\t\tjack_name = jack_name_buf;\n\t\t}\n\t}\n\n\tport_info = find_port_info(umidi, number);\n\tname_format = port_info ? port_info->name :\n\t\t(jack_name != default_jack_name  ? \"%s %s\" : \"%s %s %d\");\n\tsnprintf(substream->name, sizeof(substream->name),\n\t\t name_format, umidi->card->shortname, jack_name, number + 1);\n\n\t*rsubstream = substream;\n}\n\n \nstatic int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint i, j, err;\n\tint out_ports = 0, in_ports = 0;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_cables) {\n\t\t\terr = snd_usbmidi_out_endpoint_create(umidi,\n\t\t\t\t\t\t\t      &endpoints[i],\n\t\t\t\t\t\t\t      &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (endpoints[i].in_cables) {\n\t\t\terr = snd_usbmidi_in_endpoint_create(umidi,\n\t\t\t\t\t\t\t     &endpoints[i],\n\t\t\t\t\t\t\t     &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (j = 0; j < 0x10; ++j) {\n\t\t\tif (endpoints[i].out_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t\t   out_ports,\n\t\t\t\t\t\t\t   endpoints[i].assoc_out_jacks[j],\n\t\t\t\t\t\t\t   &umidi->endpoints[i].out->ports[j].substream);\n\t\t\t\t++out_ports;\n\t\t\t}\n\t\t\tif (endpoints[i].in_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t\t   in_ports,\n\t\t\t\t\t\t\t   endpoints[i].assoc_in_jacks[j],\n\t\t\t\t\t\t\t   &umidi->endpoints[i].in->ports[j].substream);\n\t\t\t\t++in_ports;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(&umidi->dev->dev, \"created %d output and %d input ports\\n\",\n\t\t    out_ports, in_ports);\n\treturn 0;\n}\n\nstatic struct usb_ms_endpoint_descriptor *find_usb_ms_endpoint_descriptor(\n\t\t\t\t\tstruct usb_host_endpoint *hostep)\n{\n\tunsigned char *extra = hostep->extra;\n\tint extralen = hostep->extralen;\n\n\twhile (extralen > 3) {\n\t\tstruct usb_ms_endpoint_descriptor *ms_ep =\n\t\t\t\t(struct usb_ms_endpoint_descriptor *)extra;\n\n\t\tif (ms_ep->bLength > 3 &&\n\t\t    ms_ep->bDescriptorType == USB_DT_CS_ENDPOINT &&\n\t\t    ms_ep->bDescriptorSubtype == UAC_MS_GENERAL)\n\t\t\treturn ms_ep;\n\t\tif (!extra[0])\n\t\t\tbreak;\n\t\textralen -= extra[0];\n\t\textra += extra[0];\n\t}\n\treturn NULL;\n}\n\n \nstatic int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi,\n\t\t\t\t   struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_ms_header_descriptor *ms_header;\n\tstruct usb_host_endpoint *hostep;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_ms_endpoint_descriptor *ms_ep;\n\tint i, j, epidx;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENXIO;\n\thostif = &intf->altsetting[0];\n\tintfd = get_iface_desc(hostif);\n\tms_header = (struct usb_ms_header_descriptor *)hostif->extra;\n\tif (hostif->extralen >= 7 &&\n\t    ms_header->bLength >= 7 &&\n\t    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t    ms_header->bDescriptorSubtype == UAC_HEADER)\n\t\tdev_dbg(&umidi->dev->dev, \"MIDIStreaming version %02x.%02x\\n\",\n\t\t\t    ((uint8_t *)&ms_header->bcdMSC)[1], ((uint8_t *)&ms_header->bcdMSC)[0]);\n\telse\n\t\tdev_warn(&umidi->dev->dev,\n\t\t\t \"MIDIStreaming interface descriptor not found\\n\");\n\n\tepidx = 0;\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\thostep = &hostif->endpoint[i];\n\t\tep = get_ep_desc(hostep);\n\t\tif (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))\n\t\t\tcontinue;\n\t\tms_ep = find_usb_ms_endpoint_descriptor(hostep);\n\t\tif (!ms_ep)\n\t\t\tcontinue;\n\t\tif (ms_ep->bLength <= sizeof(*ms_ep))\n\t\t\tcontinue;\n\t\tif (ms_ep->bNumEmbMIDIJack > 0x10)\n\t\t\tcontinue;\n\t\tif (ms_ep->bLength < sizeof(*ms_ep) + ms_ep->bNumEmbMIDIJack)\n\t\t\tcontinue;\n\t\tif (usb_endpoint_dir_out(ep)) {\n\t\t\tif (endpoints[epidx].out_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].out_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].out_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\t \n\t\t\t\tendpoints[epidx].out_interval = 1;\n\t\t\tendpoints[epidx].out_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tfor (j = 0; j < ms_ep->bNumEmbMIDIJack; ++j)\n\t\t\t\tendpoints[epidx].assoc_out_jacks[j] = ms_ep->baAssocJackID[j];\n\t\t\tfor (; j < ARRAY_SIZE(endpoints[epidx].assoc_out_jacks); ++j)\n\t\t\t\tendpoints[epidx].assoc_out_jacks[j] = -1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t} else {\n\t\t\tif (endpoints[epidx].in_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].in_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].in_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\tendpoints[epidx].in_interval = 1;\n\t\t\tendpoints[epidx].in_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tfor (j = 0; j < ms_ep->bNumEmbMIDIJack; ++j)\n\t\t\t\tendpoints[epidx].assoc_in_jacks[j] = ms_ep->baAssocJackID[j];\n\t\t\tfor (; j < ARRAY_SIZE(endpoints[epidx].assoc_in_jacks); ++j)\n\t\t\t\tendpoints[epidx].assoc_in_jacks[j] = -1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int roland_load_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"High Load\", \"Light Load\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int roland_load_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tvalue->value.enumerated.item[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int roland_load_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_usb_midi *umidi = kcontrol->private_data;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&umidi->mutex);\n\tchanged = value->value.enumerated.item[0] != kcontrol->private_value;\n\tif (changed)\n\t\tkcontrol->private_value = value->value.enumerated.item[0];\n\tmutex_unlock(&umidi->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new roland_load_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"MIDI Input Mode\",\n\t.info = roland_load_info,\n\t.get = roland_load_get,\n\t.put = roland_load_put,\n\t.private_value = 1,\n};\n\n \nstatic void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting != 2)\n\t\treturn;\n\n\thostif = &intf->altsetting[1];\n\tintfd = get_iface_desc(hostif);\n        \n\tif (intfd->bNumEndpoints != 2 ||\n\t    !((get_endpoint(hostif, 0)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT ||\n\t      (get_endpoint(hostif, 1)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))\n\t\treturn;\n\n\tdev_dbg(&umidi->dev->dev, \"switching to altsetting %d with int ep\\n\",\n\t\t    intfd->bAlternateSetting);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\n\tumidi->roland_load_ctl = snd_ctl_new1(&roland_load_ctl, umidi);\n\tif (snd_ctl_add(umidi->card, umidi->roland_load_ctl) < 0)\n\t\tumidi->roland_load_ctl = NULL;\n}\n\n \nstatic int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint,\n\t\t\t\t\tint max_endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint i, out_eps = 0, in_eps = 0;\n\n\tif (USB_ID_VENDOR(umidi->usb_id) == 0x0582)\n\t\tsnd_usbmidi_switch_roland_altsetting(umidi);\n\n\tif (endpoint[0].out_ep || endpoint[0].in_ep)\n\t\treturn 0;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting < 1)\n\t\treturn -ENOENT;\n\thostif = intf->cur_altsetting;\n\tintfd = get_iface_desc(hostif);\n\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\tepd = get_endpoint(hostif, i);\n\t\tif (!usb_endpoint_xfer_bulk(epd) &&\n\t\t    !usb_endpoint_xfer_int(epd))\n\t\t\tcontinue;\n\t\tif (out_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_out(epd)) {\n\t\t\tendpoint[out_eps].out_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[out_eps].out_interval = epd->bInterval;\n\t\t\t++out_eps;\n\t\t}\n\t\tif (in_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_in(epd)) {\n\t\t\tendpoint[in_eps].in_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[in_eps].in_interval = epd->bInterval;\n\t\t\t++in_eps;\n\t\t}\n\t}\n\treturn (out_eps || in_eps) ? 0 : -ENOENT;\n}\n\n \nstatic int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint err, i;\n\n\terr = snd_usbmidi_detect_endpoints(umidi, endpoints, MIDI_MAX_ENDPOINTS);\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_ep)\n\t\t\tendpoints[i].out_cables = 0x0001;\n\t\tif (endpoints[i].in_ep)\n\t\t\tendpoints[i].in_cables = 0x0001;\n\t}\n\treturn err;\n}\n\n \nstatic int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tuint8_t *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\tif (intfd->bNumEndpoints < 1)\n\t\treturn -ENOENT;\n\n\t \n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[1] == USB_DT_CS_INTERFACE) {\n\t\t\tif (cs_desc[2] == UAC_MIDI_IN_JACK)\n\t\t\t\tendpoint->in_cables =\n\t\t\t\t\t(endpoint->in_cables << 1) | 1;\n\t\t\telse if (cs_desc[2] == UAC_MIDI_OUT_JACK)\n\t\t\t\tendpoint->out_cables =\n\t\t\t\t\t(endpoint->out_cables << 1) | 1;\n\t\t}\n\t}\n\tif (!endpoint->in_cables && !endpoint->out_cables)\n\t\treturn -ENOENT;\n\n\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n}\n\n \nstatic int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tu8 *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\t \n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[0] >= 6 &&\n\t\t    cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t    cs_desc[2] == 0xf1 &&\n\t\t    cs_desc[3] == 0x02) {\n\t\t\tif (cs_desc[4] > 0x10 || cs_desc[5] > 0x10)\n\t\t\t\tcontinue;\n\t\t\tendpoint->in_cables  = (1 << cs_desc[4]) - 1;\n\t\t\tendpoint->out_cables = (1 << cs_desc[5]) - 1;\n\t\t\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n\t\t} else if (cs_desc[0] >= 7 &&\n\t\t\t   cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t\t   cs_desc[2] == UAC_HEADER) {\n\t\t\treturn snd_usbmidi_get_ms_info(umidi, endpoint);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,\n\t\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct snd_usb_midi_endpoint_info ep_info;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint cable, err;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\t \n\tif (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {\n\t\tdev_dbg(&umidi->dev->dev, \"not enough endpoints\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tepd = get_endpoint(hostif, 0);\n\tif (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[0] isn't interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\tepd = get_endpoint(hostif, 2);\n\tif (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[2] isn't bulk output\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (endpoint->out_cables > 0x0001) {\n\t\tepd = get_endpoint(hostif, 4);\n\t\tif (!usb_endpoint_dir_out(epd) ||\n\t\t    !usb_endpoint_xfer_bulk(epd)) {\n\t\t\tdev_dbg(&umidi->dev->dev,\n\t\t\t\t\"endpoint[4] isn't bulk output\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.out_interval = 0;\n\tep_info.out_cables = endpoint->out_cables & 0x5555;\n\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t      &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.in_interval = get_endpoint(hostif, 0)->bInterval;\n\tep_info.in_cables = endpoint->in_cables;\n\terr = snd_usbmidi_in_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t     &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (endpoint->out_cables > 0x0001) {\n\t\tep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tep_info.out_cables = endpoint->out_cables & 0xaaaa;\n\t\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t\t      &umidi->endpoints[1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (cable = 0; cable < 0x10; ++cable) {\n\t\tif (endpoint->out_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   -1  ,\n\t\t\t\t\t\t   &umidi->endpoints[cable & 1].out->ports[cable].substream);\n\t\tif (endpoint->in_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   -1  ,\n\t\t\t\t\t\t   &umidi->endpoints[0].in->ports[cable].substream);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_global_ops snd_usbmidi_ops = {\n\t.get_port_info = snd_usbmidi_get_port_info,\n};\n\nstatic int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,\n\t\t\t\t      int out_ports, int in_ports)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(umidi->card, \"USB MIDI\",\n\t\t\t      umidi->next_midi_device++,\n\t\t\t      out_ports, in_ports, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, umidi->card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->ops = &snd_usbmidi_ops;\n\trmidi->private_data = umidi;\n\trmidi->private_free = snd_usbmidi_rawmidi_free;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_usbmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_usbmidi_input_ops);\n\n\tumidi->rmidi = rmidi;\n\treturn 0;\n}\n\n \nvoid snd_usbmidi_input_stop(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (!umidi->input_running)\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t}\n\tumidi->input_running = 0;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_stop);\n\nstatic void snd_usbmidi_input_start_ep(struct snd_usb_midi *umidi,\n\t\t\t\t       struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tif (!ep)\n\t\treturn;\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tstruct urb *urb = ep->urbs[i];\n\t\tspin_lock_irqsave(&umidi->disc_lock, flags);\n\t\tif (!atomic_read(&urb->use_count)) {\n\t\t\turb->dev = ep->umidi->dev;\n\t\t\tsnd_usbmidi_submit_urb(urb, GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock_irqrestore(&umidi->disc_lock, flags);\n\t}\n}\n\n \nvoid snd_usbmidi_input_start(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tint i;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (umidi->input_running || !umidi->opened[1])\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tsnd_usbmidi_input_start_ep(umidi, umidi->endpoints[i].in);\n\tumidi->input_running = 1;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_start);\n\n \nvoid snd_usbmidi_suspend(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_stop(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_suspend);\n\n \nvoid snd_usbmidi_resume(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_start(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_resume);\n\n \nint __snd_usbmidi_create(struct snd_card *card,\n\t\t\t struct usb_interface *iface,\n\t\t\t struct list_head *midi_list,\n\t\t\t const struct snd_usb_audio_quirk *quirk,\n\t\t\t unsigned int usb_id,\n\t\t\t unsigned int *num_rawmidis)\n{\n\tstruct snd_usb_midi *umidi;\n\tstruct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];\n\tint out_ports, in_ports;\n\tint i, err;\n\n\tumidi = kzalloc(sizeof(*umidi), GFP_KERNEL);\n\tif (!umidi)\n\t\treturn -ENOMEM;\n\tumidi->dev = interface_to_usbdev(iface);\n\tumidi->card = card;\n\tumidi->iface = iface;\n\tumidi->quirk = quirk;\n\tumidi->usb_protocol_ops = &snd_usbmidi_standard_ops;\n\tif (num_rawmidis)\n\t\tumidi->next_midi_device = *num_rawmidis;\n\tspin_lock_init(&umidi->disc_lock);\n\tinit_rwsem(&umidi->disc_rwsem);\n\tmutex_init(&umidi->mutex);\n\tif (!usb_id)\n\t\tusb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),\n\t\t\t       le16_to_cpu(umidi->dev->descriptor.idProduct));\n\tumidi->usb_id = usb_id;\n\ttimer_setup(&umidi->error_timer, snd_usbmidi_error_timer, 0);\n\n\t \n\tmemset(endpoints, 0, sizeof(endpoints));\n\tswitch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {\n\tcase QUIRK_MIDI_STANDARD_INTERFACE:\n\t\terr = snd_usbmidi_get_ms_info(umidi, endpoints);\n\t\tif (umidi->usb_id == USB_ID(0x0763, 0x0150))  \n\t\t\tumidi->usb_protocol_ops =\n\t\t\t\t&snd_usbmidi_maudio_broken_running_status_ops;\n\t\tbreak;\n\tcase QUIRK_MIDI_US122L:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_122l_ops;\n\t\tfallthrough;\n\tcase QUIRK_MIDI_FIXED_ENDPOINT:\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_YAMAHA:\n\t\terr = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_ROLAND:\n\t\terr = snd_usbmidi_detect_roland(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_MIDIMAN:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_NOVATION:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_novation_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_RAW_BYTES:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_raw_ops;\n\t\t \n\t\tif (umidi->usb_id == USB_ID(0x07fd, 0x0001))  \n\t\t\tusb_set_interface(umidi->dev, 0, 0);\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_EMAGIC:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_emagic_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_CME:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_cme_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_AKAI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_akai_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\t \n\t\tendpoints[1].out_cables = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_FTDI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops;\n\n\t\t \n\t\terr = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0),\n\t\t\t\t      3, 0x40, 0x60, 0, NULL, 0, 1000);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_CH345:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&umidi->dev->dev, \"invalid quirk type %d\\n\",\n\t\t\tquirk->type);\n\t\terr = -ENXIO;\n\t\tbreak;\n\t}\n\tif (err < 0)\n\t\tgoto free_midi;\n\n\t \n\tout_ports = 0;\n\tin_ports = 0;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tout_ports += hweight16(endpoints[i].out_cables);\n\t\tin_ports += hweight16(endpoints[i].in_cables);\n\t}\n\terr = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);\n\tif (err < 0)\n\t\tgoto free_midi;\n\n\t \n\tif (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)\n\t\terr = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);\n\telse\n\t\terr = snd_usbmidi_create_endpoints(umidi, endpoints);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tusb_autopm_get_interface_no_resume(umidi->iface);\n\n\tlist_add_tail(&umidi->list, midi_list);\n\tif (num_rawmidis)\n\t\t*num_rawmidis = umidi->next_midi_device;\n\treturn 0;\n\nfree_midi:\n\tkfree(umidi);\nexit:\n\treturn err;\n}\nEXPORT_SYMBOL(__snd_usbmidi_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}