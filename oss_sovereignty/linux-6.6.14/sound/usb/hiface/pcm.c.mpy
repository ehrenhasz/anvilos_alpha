{
  "module_name": "pcm.c",
  "hash_id": "6712b42388825dc6ddb0d6ab3c9a2e375a898fd935d376ed72892d9c788cc7a9",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/hiface/pcm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <sound/pcm.h>\n\n#include \"pcm.h\"\n#include \"chip.h\"\n\n#define OUT_EP          0x2\n#define PCM_N_URBS      8\n#define PCM_PACKET_SIZE 4096\n#define PCM_BUFFER_SIZE (2 * PCM_N_URBS * PCM_PACKET_SIZE)\n\nstruct pcm_urb {\n\tstruct hiface_chip *chip;\n\n\tstruct urb instance;\n\tstruct usb_anchor submitted;\n\tu8 *buffer;\n};\n\nstruct pcm_substream {\n\tspinlock_t lock;\n\tstruct snd_pcm_substream *instance;\n\n\tbool active;\n\tsnd_pcm_uframes_t dma_off;     \n\tsnd_pcm_uframes_t period_off;  \n};\n\nenum {  \n\tSTREAM_DISABLED,  \n\tSTREAM_STARTING,  \n\tSTREAM_RUNNING,   \n\tSTREAM_STOPPING\n};\n\nstruct pcm_runtime {\n\tstruct hiface_chip *chip;\n\tstruct snd_pcm *instance;\n\n\tstruct pcm_substream playback;\n\tbool panic;  \n\n\tstruct pcm_urb out_urbs[PCM_N_URBS];\n\n\tstruct mutex stream_mutex;\n\tu8 stream_state;  \n\tu8 extra_freq;\n\twait_queue_head_t stream_wait_queue;\n\tbool stream_wait_cond;\n};\n\nstatic const unsigned int rates[] = { 44100, 48000, 88200, 96000, 176400, 192000,\n\t\t\t\t      352800, 384000 };\nstatic const struct snd_pcm_hw_constraint_list constraints_extra_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic const struct snd_pcm_hardware pcm_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\n\t.rates = SNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000 |\n\t\tSNDRV_PCM_RATE_88200 |\n\t\tSNDRV_PCM_RATE_96000 |\n\t\tSNDRV_PCM_RATE_176400 |\n\t\tSNDRV_PCM_RATE_192000,\n\n\t.rate_min = 44100,\n\t.rate_max = 192000,  \n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = PCM_BUFFER_SIZE,\n\t.period_bytes_min = PCM_PACKET_SIZE,\n\t.period_bytes_max = PCM_BUFFER_SIZE,\n\t.periods_min = 2,\n\t.periods_max = 1024\n};\n\n \n#define HIFACE_SET_RATE_REQUEST 0xb0\n\n#define HIFACE_RATE_44100  0x43\n#define HIFACE_RATE_48000  0x4b\n#define HIFACE_RATE_88200  0x42\n#define HIFACE_RATE_96000  0x4a\n#define HIFACE_RATE_176400 0x40\n#define HIFACE_RATE_192000 0x48\n#define HIFACE_RATE_352800 0x58\n#define HIFACE_RATE_384000 0x68\n\nstatic int hiface_pcm_set_rate(struct pcm_runtime *rt, unsigned int rate)\n{\n\tstruct usb_device *device = rt->chip->dev;\n\tu16 rate_value;\n\tint ret;\n\n\t \n\tswitch (rate) {\n\tcase 44100:\n\t\trate_value = HIFACE_RATE_44100;\n\t\tbreak;\n\tcase 48000:\n\t\trate_value = HIFACE_RATE_48000;\n\t\tbreak;\n\tcase 88200:\n\t\trate_value = HIFACE_RATE_88200;\n\t\tbreak;\n\tcase 96000:\n\t\trate_value = HIFACE_RATE_96000;\n\t\tbreak;\n\tcase 176400:\n\t\trate_value = HIFACE_RATE_176400;\n\t\tbreak;\n\tcase 192000:\n\t\trate_value = HIFACE_RATE_192000;\n\t\tbreak;\n\tcase 352800:\n\t\trate_value = HIFACE_RATE_352800;\n\t\tbreak;\n\tcase 384000:\n\t\trate_value = HIFACE_RATE_384000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&device->dev, \"Unsupported rate %d\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = usb_control_msg_send(device, 0,\n\t\t\t\t   HIFACE_SET_RATE_REQUEST,\n\t\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t\t   rate_value, 0, NULL, 0, 100, GFP_KERNEL);\n\tif (ret)\n\t\tdev_err(&device->dev, \"Error setting samplerate %d.\\n\", rate);\n\n\treturn ret;\n}\n\nstatic struct pcm_substream *hiface_pcm_get_substream(struct snd_pcm_substream\n\t\t\t\t\t\t      *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct device *device = &rt->chip->dev->dev;\n\n\tif (alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn &rt->playback;\n\n\tdev_err(device, \"Error getting pcm substream slot.\\n\");\n\treturn NULL;\n}\n\n \nstatic void hiface_pcm_stream_stop(struct pcm_runtime *rt)\n{\n\tint i, time;\n\n\tif (rt->stream_state != STREAM_DISABLED) {\n\t\trt->stream_state = STREAM_STOPPING;\n\n\t\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\t\ttime = usb_wait_anchor_empty_timeout(\n\t\t\t\t\t&rt->out_urbs[i].submitted, 100);\n\t\t\tif (!time)\n\t\t\t\tusb_kill_anchored_urbs(\n\t\t\t\t\t&rt->out_urbs[i].submitted);\n\t\t\tusb_kill_urb(&rt->out_urbs[i].instance);\n\t\t}\n\n\t\trt->stream_state = STREAM_DISABLED;\n\t}\n}\n\n \nstatic int hiface_pcm_stream_start(struct pcm_runtime *rt)\n{\n\tint ret = 0;\n\tint i;\n\n\tif (rt->stream_state == STREAM_DISABLED) {\n\n\t\t \n\t\trt->panic = false;\n\n\t\t \n\t\trt->stream_state = STREAM_STARTING;\n\t\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\t\tmemset(rt->out_urbs[i].buffer, 0, PCM_PACKET_SIZE);\n\t\t\tusb_anchor_urb(&rt->out_urbs[i].instance,\n\t\t\t\t       &rt->out_urbs[i].submitted);\n\t\t\tret = usb_submit_urb(&rt->out_urbs[i].instance,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (ret) {\n\t\t\t\thiface_pcm_stream_stop(rt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twait_event_timeout(rt->stream_wait_queue, rt->stream_wait_cond,\n\t\t\t\t   HZ);\n\t\tif (rt->stream_wait_cond) {\n\t\t\tstruct device *device = &rt->chip->dev->dev;\n\t\t\tdev_dbg(device, \"%s: Stream is running wakeup event\\n\",\n\t\t\t\t __func__);\n\t\t\trt->stream_state = STREAM_RUNNING;\n\t\t} else {\n\t\t\thiface_pcm_stream_stop(rt);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic void memcpy_swahw32(u8 *dest, u8 *src, unsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n / 4; i++)\n\t\t((u32 *)dest)[i] = swahw32(((u32 *)src)[i]);\n}\n\n \n \nstatic bool hiface_pcm_playback(struct pcm_substream *sub, struct pcm_urb *urb)\n{\n\tstruct snd_pcm_runtime *alsa_rt = sub->instance->runtime;\n\tstruct device *device = &urb->chip->dev->dev;\n\tu8 *source;\n\tunsigned int pcm_buffer_size;\n\n\tWARN_ON(alsa_rt->format != SNDRV_PCM_FORMAT_S32_LE);\n\n\tpcm_buffer_size = snd_pcm_lib_buffer_bytes(sub->instance);\n\n\tif (sub->dma_off + PCM_PACKET_SIZE <= pcm_buffer_size) {\n\t\tdev_dbg(device, \"%s: (1) buffer_size %#x dma_offset %#x\\n\", __func__,\n\t\t\t (unsigned int) pcm_buffer_size,\n\t\t\t (unsigned int) sub->dma_off);\n\n\t\tsource = alsa_rt->dma_area + sub->dma_off;\n\t\tmemcpy_swahw32(urb->buffer, source, PCM_PACKET_SIZE);\n\t} else {\n\t\t \n\t\tunsigned int len;\n\n\t\tdev_dbg(device, \"%s: (2) buffer_size %#x dma_offset %#x\\n\", __func__,\n\t\t\t (unsigned int) pcm_buffer_size,\n\t\t\t (unsigned int) sub->dma_off);\n\n\t\tlen = pcm_buffer_size - sub->dma_off;\n\n\t\tsource = alsa_rt->dma_area + sub->dma_off;\n\t\tmemcpy_swahw32(urb->buffer, source, len);\n\n\t\tsource = alsa_rt->dma_area;\n\t\tmemcpy_swahw32(urb->buffer + len, source,\n\t\t\t       PCM_PACKET_SIZE - len);\n\t}\n\tsub->dma_off += PCM_PACKET_SIZE;\n\tif (sub->dma_off >= pcm_buffer_size)\n\t\tsub->dma_off -= pcm_buffer_size;\n\n\tsub->period_off += PCM_PACKET_SIZE;\n\tif (sub->period_off >= alsa_rt->period_size) {\n\t\tsub->period_off %= alsa_rt->period_size;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void hiface_pcm_out_urb_handler(struct urb *usb_urb)\n{\n\tstruct pcm_urb *out_urb = usb_urb->context;\n\tstruct pcm_runtime *rt = out_urb->chip->pcm;\n\tstruct pcm_substream *sub;\n\tbool do_period_elapsed = false;\n\tunsigned long flags;\n\tint ret;\n\n\tif (rt->panic || rt->stream_state == STREAM_STOPPING)\n\t\treturn;\n\n\tif (unlikely(usb_urb->status == -ENOENT ||\t \n\t\t     usb_urb->status == -ENODEV ||\t \n\t\t     usb_urb->status == -ECONNRESET ||\t \n\t\t     usb_urb->status == -ESHUTDOWN)) {\t \n\t\tgoto out_fail;\n\t}\n\n\tif (rt->stream_state == STREAM_STARTING) {\n\t\trt->stream_wait_cond = true;\n\t\twake_up(&rt->stream_wait_queue);\n\t}\n\n\t \n\tsub = &rt->playback;\n\tspin_lock_irqsave(&sub->lock, flags);\n\tif (sub->active)\n\t\tdo_period_elapsed = hiface_pcm_playback(sub, out_urb);\n\telse\n\t\tmemset(out_urb->buffer, 0, PCM_PACKET_SIZE);\n\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\tif (do_period_elapsed)\n\t\tsnd_pcm_period_elapsed(sub->instance);\n\n\tret = usb_submit_urb(&out_urb->instance, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out_fail;\n\n\treturn;\n\nout_fail:\n\trt->panic = true;\n}\n\nstatic int hiface_pcm_open(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = NULL;\n\tstruct snd_pcm_runtime *alsa_rt = alsa_sub->runtime;\n\tint ret;\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\n\tmutex_lock(&rt->stream_mutex);\n\talsa_rt->hw = pcm_hw;\n\n\tif (alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsub = &rt->playback;\n\n\tif (!sub) {\n\t\tstruct device *device = &rt->chip->dev->dev;\n\t\tmutex_unlock(&rt->stream_mutex);\n\t\tdev_err(device, \"Invalid stream type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rt->extra_freq) {\n\t\talsa_rt->hw.rates |= SNDRV_PCM_RATE_KNOT;\n\t\talsa_rt->hw.rate_max = 384000;\n\n\t\t \n\t\tret = snd_pcm_hw_constraint_list(alsa_sub->runtime, 0,\n\t\t\t\t\t\t SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t &constraints_extra_rates);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsub->instance = alsa_sub;\n\tsub->active = false;\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int hiface_pcm_close(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = hiface_pcm_get_substream(alsa_sub);\n\tunsigned long flags;\n\n\tif (rt->panic)\n\t\treturn 0;\n\n\tmutex_lock(&rt->stream_mutex);\n\tif (sub) {\n\t\thiface_pcm_stream_stop(rt);\n\n\t\t \n\t\tspin_lock_irqsave(&sub->lock, flags);\n\t\tsub->instance = NULL;\n\t\tsub->active = false;\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\t}\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int hiface_pcm_prepare(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = hiface_pcm_get_substream(alsa_sub);\n\tstruct snd_pcm_runtime *alsa_rt = alsa_sub->runtime;\n\tint ret;\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\tif (!sub)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&rt->stream_mutex);\n\n\thiface_pcm_stream_stop(rt);\n\n\tsub->dma_off = 0;\n\tsub->period_off = 0;\n\n\tif (rt->stream_state == STREAM_DISABLED) {\n\n\t\tret = hiface_pcm_set_rate(rt, alsa_rt->rate);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = hiface_pcm_stream_start(rt);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int hiface_pcm_trigger(struct snd_pcm_substream *alsa_sub, int cmd)\n{\n\tstruct pcm_substream *sub = hiface_pcm_get_substream(alsa_sub);\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\tif (!sub)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irq(&sub->lock);\n\t\tsub->active = true;\n\t\tspin_unlock_irq(&sub->lock);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irq(&sub->lock);\n\t\tsub->active = false;\n\t\tspin_unlock_irq(&sub->lock);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic snd_pcm_uframes_t hiface_pcm_pointer(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_substream *sub = hiface_pcm_get_substream(alsa_sub);\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tunsigned long flags;\n\tsnd_pcm_uframes_t dma_offset;\n\n\tif (rt->panic || !sub)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tdma_offset = sub->dma_off;\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\treturn bytes_to_frames(alsa_sub->runtime, dma_offset);\n}\n\nstatic const struct snd_pcm_ops pcm_ops = {\n\t.open = hiface_pcm_open,\n\t.close = hiface_pcm_close,\n\t.prepare = hiface_pcm_prepare,\n\t.trigger = hiface_pcm_trigger,\n\t.pointer = hiface_pcm_pointer,\n};\n\nstatic int hiface_pcm_init_urb(struct pcm_urb *urb,\n\t\t\t       struct hiface_chip *chip,\n\t\t\t       unsigned int ep,\n\t\t\t       void (*handler)(struct urb *))\n{\n\turb->chip = chip;\n\tusb_init_urb(&urb->instance);\n\n\turb->buffer = kzalloc(PCM_PACKET_SIZE, GFP_KERNEL);\n\tif (!urb->buffer)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(&urb->instance, chip->dev,\n\t\t\t  usb_sndbulkpipe(chip->dev, ep), (void *)urb->buffer,\n\t\t\t  PCM_PACKET_SIZE, handler, urb);\n\tif (usb_urb_ep_type_check(&urb->instance))\n\t\treturn -EINVAL;\n\tinit_usb_anchor(&urb->submitted);\n\n\treturn 0;\n}\n\nvoid hiface_pcm_abort(struct hiface_chip *chip)\n{\n\tstruct pcm_runtime *rt = chip->pcm;\n\n\tif (rt) {\n\t\trt->panic = true;\n\n\t\tmutex_lock(&rt->stream_mutex);\n\t\thiface_pcm_stream_stop(rt);\n\t\tmutex_unlock(&rt->stream_mutex);\n\t}\n}\n\nstatic void hiface_pcm_destroy(struct hiface_chip *chip)\n{\n\tstruct pcm_runtime *rt = chip->pcm;\n\tint i;\n\n\tfor (i = 0; i < PCM_N_URBS; i++)\n\t\tkfree(rt->out_urbs[i].buffer);\n\n\tkfree(chip->pcm);\n\tchip->pcm = NULL;\n}\n\nstatic void hiface_pcm_free(struct snd_pcm *pcm)\n{\n\tstruct pcm_runtime *rt = pcm->private_data;\n\n\tif (rt)\n\t\thiface_pcm_destroy(rt->chip);\n}\n\nint hiface_pcm_init(struct hiface_chip *chip, u8 extra_freq)\n{\n\tint i;\n\tint ret;\n\tstruct snd_pcm *pcm;\n\tstruct pcm_runtime *rt;\n\n\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->chip = chip;\n\trt->stream_state = STREAM_DISABLED;\n\tif (extra_freq)\n\t\trt->extra_freq = 1;\n\n\tinit_waitqueue_head(&rt->stream_wait_queue);\n\tmutex_init(&rt->stream_mutex);\n\tspin_lock_init(&rt->playback.lock);\n\n\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\tret = hiface_pcm_init_urb(&rt->out_urbs[i], chip, OUT_EP,\n\t\t\t\t    hiface_pcm_out_urb_handler);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = snd_pcm_new(chip->card, \"USB-SPDIF Audio\", 0, 1, 0, &pcm);\n\tif (ret < 0) {\n\t\tdev_err(&chip->dev->dev, \"Cannot create pcm instance\\n\");\n\t\tgoto error;\n\t}\n\n\tpcm->private_data = rt;\n\tpcm->private_free = hiface_pcm_free;\n\n\tstrscpy(pcm->name, \"USB-SPDIF Audio\", sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\n\trt->instance = pcm;\n\n\tchip->pcm = rt;\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < PCM_N_URBS; i++)\n\t\tkfree(rt->out_urbs[i].buffer);\n\tkfree(rt);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}