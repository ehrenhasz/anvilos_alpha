{
  "module_name": "chip.c",
  "hash_id": "d853b4f4d2122c936cd828e4565f6ca0d33aa44224e705b702d0cfd1b52ec6f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/hiface/chip.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/initval.h>\n\n#include \"chip.h\"\n#include \"pcm.h\"\n\nMODULE_AUTHOR(\"Michael Trimarchi <michael@amarulasolutions.com>\");\nMODULE_AUTHOR(\"Antonio Ospite <ao2@amarulasolutions.com>\");\nMODULE_DESCRIPTION(\"M2Tech hiFace USB-SPDIF audio driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;  \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;  \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;  \n\n#define DRIVER_NAME \"snd-usb-hiface\"\n#define CARD_NAME \"hiFace\"\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstruct hiface_vendor_quirk {\n\tconst char *device_name;\n\tu8 extra_freq;\n};\n\nstatic int hiface_chip_create(struct usb_interface *intf,\n\t\t\t      struct usb_device *device, int idx,\n\t\t\t      const struct hiface_vendor_quirk *quirk,\n\t\t\t      struct hiface_chip **rchip)\n{\n\tstruct snd_card *card = NULL;\n\tstruct hiface_chip *chip;\n\tint ret;\n\tint len;\n\n\t*rchip = NULL;\n\n\t \n\tret = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   sizeof(*chip), &card);\n\tif (ret < 0) {\n\t\tdev_err(&device->dev, \"cannot create alsa card.\\n\");\n\t\treturn ret;\n\t}\n\n\tstrscpy(card->driver, DRIVER_NAME, sizeof(card->driver));\n\n\tif (quirk && quirk->device_name)\n\t\tstrscpy(card->shortname, quirk->device_name, sizeof(card->shortname));\n\telse\n\t\tstrscpy(card->shortname, \"M2Tech generic audio\", sizeof(card->shortname));\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(device, card->longname + len,\n\t\t\t      sizeof(card->longname) - len);\n\n\tchip = card->private_data;\n\tchip->dev = device;\n\tchip->card = card;\n\n\t*rchip = chip;\n\treturn 0;\n}\n\nstatic int hiface_chip_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *usb_id)\n{\n\tconst struct hiface_vendor_quirk *quirk = (struct hiface_vendor_quirk *)usb_id->driver_info;\n\tint ret;\n\tint i;\n\tstruct hiface_chip *chip;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\n\tret = usb_set_interface(device, 0, 0);\n\tif (ret != 0) {\n\t\tdev_err(&device->dev, \"can't set first interface for \" CARD_NAME \" device.\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\n\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\tif (enable[i])\n\t\t\tbreak;\n\n\tif (i >= SNDRV_CARDS) {\n\t\tdev_err(&device->dev, \"no available \" CARD_NAME \" audio device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = hiface_chip_create(intf, device, i, quirk, &chip);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = hiface_pcm_init(chip, quirk ? quirk->extra_freq : 0);\n\tif (ret < 0)\n\t\tgoto err_chip_destroy;\n\n\tret = snd_card_register(chip->card);\n\tif (ret < 0) {\n\t\tdev_err(&device->dev, \"cannot register \" CARD_NAME \" card\\n\");\n\t\tgoto err_chip_destroy;\n\t}\n\n\tmutex_unlock(&register_mutex);\n\n\tusb_set_intfdata(intf, chip);\n\treturn 0;\n\nerr_chip_destroy:\n\tsnd_card_free(chip->card);\nerr:\n\tmutex_unlock(&register_mutex);\n\treturn ret;\n}\n\nstatic void hiface_chip_disconnect(struct usb_interface *intf)\n{\n\tstruct hiface_chip *chip;\n\tstruct snd_card *card;\n\n\tchip = usb_get_intfdata(intf);\n\tif (!chip)\n\t\treturn;\n\n\tcard = chip->card;\n\n\t \n\tsnd_card_disconnect(card);\n\n\thiface_pcm_abort(chip);\n\tsnd_card_free_when_closed(card);\n}\n\nstatic const struct usb_device_id device_table[] = {\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x0384),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Young\",\n\t\t\t.extra_freq = 1,\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x930b),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"hiFace\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x931b),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"North Star\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x931c),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"W4S Young\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x931d),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Corrson\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x931e),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"AUDIA\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x931f),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"SL Audio\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x9320),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Empirical\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x04b4, 0x9321),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Rockna\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x9001),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Pathos\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x9002),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Metronome\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x9006),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"CAD\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x9008),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Audio Esclusive\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x931c),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Rotel\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x249c, 0x932c),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Eeaudio\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x245f, 0x931c),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"CHORD\",\n\t\t}\n\t},\n\t{\n\t\tUSB_DEVICE(0x25c6, 0x9002),\n\t\t.driver_info = (unsigned long)&(const struct hiface_vendor_quirk) {\n\t\t\t.device_name = \"Vitus\",\n\t\t}\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\nstatic struct usb_driver hiface_usb_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = hiface_chip_probe,\n\t.disconnect = hiface_chip_disconnect,\n\t.id_table = device_table,\n};\n\nmodule_usb_driver(hiface_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}