{
  "module_name": "audio.c",
  "hash_id": "fe79ae9ac573653ae522bb77e085d83797cc8e96bbbc825e1ae081d74424efb3",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/caiaq/audio.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"device.h\"\n#include \"audio.h\"\n\n#define N_URBS\t\t\t32\n#define CLOCK_DRIFT_TOLERANCE\t5\n#define FRAMES_PER_URB\t\t8\n#define BYTES_PER_FRAME\t\t512\n#define CHANNELS_PER_STREAM\t2\n#define BYTES_PER_SAMPLE\t3\n#define BYTES_PER_SAMPLE_USB\t4\n#define MAX_BUFFER_SIZE\t\t(128*1024)\n#define MAX_ENDPOINT_SIZE\t512\n\n#define ENDPOINT_CAPTURE\t2\n#define ENDPOINT_PLAYBACK\t6\n\n#define MAKE_CHECKBYTE(cdev,stream,i) \\\n\t(stream << 1) | (~(i / (cdev->n_streams * BYTES_PER_SAMPLE_USB)) & 1)\n\nstatic const struct snd_pcm_hardware snd_usb_caiaq_pcm_hardware = {\n\t.info \t\t= (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.formats \t= SNDRV_PCM_FMTBIT_S24_3BE,\n\t.rates \t\t= (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\n\t\t\t   SNDRV_PCM_RATE_96000),\n\t.rate_min\t= 44100,\n\t.rate_max\t= 0,  \n\t.channels_min\t= CHANNELS_PER_STREAM,\n\t.channels_max\t= CHANNELS_PER_STREAM,\n\t.buffer_bytes_max = MAX_BUFFER_SIZE,\n\t.period_bytes_min = 128,\n\t.period_bytes_max = MAX_BUFFER_SIZE,\n\t.periods_min\t= 1,\n\t.periods_max\t= 1024,\n};\n\nstatic void\nactivate_substream(struct snd_usb_caiaqdev *cdev,\n\t           struct snd_pcm_substream *sub)\n{\n\tspin_lock(&cdev->spinlock);\n\n\tif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tcdev->sub_playback[sub->number] = sub;\n\telse\n\t\tcdev->sub_capture[sub->number] = sub;\n\n\tspin_unlock(&cdev->spinlock);\n}\n\nstatic void\ndeactivate_substream(struct snd_usb_caiaqdev *cdev,\n\t\t     struct snd_pcm_substream *sub)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&cdev->spinlock, flags);\n\n\tif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tcdev->sub_playback[sub->number] = NULL;\n\telse\n\t\tcdev->sub_capture[sub->number] = NULL;\n\n\tspin_unlock_irqrestore(&cdev->spinlock, flags);\n}\n\nstatic int\nall_substreams_zero(struct snd_pcm_substream **subs)\n{\n\tint i;\n\tfor (i = 0; i < MAX_STREAMS; i++)\n\t\tif (subs[i] != NULL)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int stream_start(struct snd_usb_caiaqdev *cdev)\n{\n\tint i, ret;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, cdev);\n\n\tif (cdev->streaming)\n\t\treturn -EINVAL;\n\n\tmemset(cdev->sub_playback, 0, sizeof(cdev->sub_playback));\n\tmemset(cdev->sub_capture, 0, sizeof(cdev->sub_capture));\n\tcdev->input_panic = 0;\n\tcdev->output_panic = 0;\n\tcdev->first_packet = 4;\n\tcdev->streaming = 1;\n\tcdev->warned = 0;\n\n\tfor (i = 0; i < N_URBS; i++) {\n\t\tret = usb_submit_urb(cdev->data_urbs_in[i], GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to trigger read #%d! (ret %d)\\n\",\n\t\t\t\ti, ret);\n\t\t\tcdev->streaming = 0;\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void stream_stop(struct snd_usb_caiaqdev *cdev)\n{\n\tint i;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, cdev);\n\tif (!cdev->streaming)\n\t\treturn;\n\n\tcdev->streaming = 0;\n\n\tfor (i = 0; i < N_URBS; i++) {\n\t\tusb_kill_urb(cdev->data_urbs_in[i]);\n\n\t\tif (test_bit(i, &cdev->outurb_active_mask))\n\t\t\tusb_kill_urb(cdev->data_urbs_out[i]);\n\t}\n\n\tcdev->outurb_active_mask = 0;\n}\n\nstatic int snd_usb_caiaq_substream_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, substream);\n\tsubstream->runtime->hw = cdev->pcm_info;\n\tsnd_pcm_limit_hw_rates(substream->runtime);\n\n\treturn 0;\n}\n\nstatic int snd_usb_caiaq_substream_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, substream);\n\tif (all_substreams_zero(cdev->sub_playback) &&\n\t    all_substreams_zero(cdev->sub_capture)) {\n\t\t \n\t\tstream_stop(cdev);\n\t\tcdev->pcm_info.rates = cdev->samplerates;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_usb_caiaq_pcm_hw_free(struct snd_pcm_substream *sub)\n{\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\n\tdeactivate_substream(cdev, sub);\n\treturn 0;\n}\n\n \n#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12\n#error \"Change this table\"\n#endif\n\nstatic const unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050, 32000, 44100,\n\t\t\t\t48000, 64000, 88200, 96000, 176400, 192000 };\n\nstatic int snd_usb_caiaq_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tint bytes_per_sample, bpp, ret, i;\n\tint index = substream->number;\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tint out_pos;\n\n\t\tswitch (cdev->spec.data_alignment) {\n\t\tcase 0:\n\t\tcase 2:\n\t\t\tout_pos = BYTES_PER_SAMPLE + 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tout_pos = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcdev->period_out_count[index] = out_pos;\n\t\tcdev->audio_out_buf_pos[index] = out_pos;\n\t} else {\n\t\tint in_pos;\n\n\t\tswitch (cdev->spec.data_alignment) {\n\t\tcase 0:\n\t\t\tin_pos = BYTES_PER_SAMPLE + 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tin_pos = BYTES_PER_SAMPLE;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tin_pos = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcdev->period_in_count[index] = in_pos;\n\t\tcdev->audio_in_buf_pos[index] = in_pos;\n\t}\n\n\tif (cdev->streaming)\n\t\treturn 0;\n\n\t \n\tfor (i=0; i < ARRAY_SIZE(rates); i++)\n\t\tif (runtime->rate == rates[i])\n\t\t\tcdev->pcm_info.rates = 1 << i;\n\n\tsnd_pcm_limit_hw_rates(runtime);\n\n\tbytes_per_sample = BYTES_PER_SAMPLE;\n\tif (cdev->spec.data_alignment >= 2)\n\t\tbytes_per_sample++;\n\n\tbpp = ((runtime->rate / 8000) + CLOCK_DRIFT_TOLERANCE)\n\t\t* bytes_per_sample * CHANNELS_PER_STREAM * cdev->n_streams;\n\n\tif (bpp > MAX_ENDPOINT_SIZE)\n\t\tbpp = MAX_ENDPOINT_SIZE;\n\n\tret = snd_usb_caiaq_set_audio_params(cdev, runtime->rate,\n\t\t\t\t\t     runtime->sample_bits, bpp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stream_start(cdev);\n\tif (ret)\n\t\treturn ret;\n\n\tcdev->output_running = 0;\n\twait_event_timeout(cdev->prepare_wait_queue, cdev->output_running, HZ);\n\tif (!cdev->output_running) {\n\t\tstream_stop(cdev);\n\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_usb_caiaq_pcm_trigger(struct snd_pcm_substream *sub, int cmd)\n{\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p) cmd %d\\n\", __func__, sub, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tactivate_substream(cdev, sub);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdeactivate_substream(cdev, sub);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nsnd_usb_caiaq_pcm_pointer(struct snd_pcm_substream *sub)\n{\n\tint index = sub->number;\n\tstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\n\tsnd_pcm_uframes_t ptr;\n\n\tspin_lock(&cdev->spinlock);\n\n\tif (cdev->input_panic || cdev->output_panic) {\n\t\tptr = SNDRV_PCM_POS_XRUN;\n\t\tgoto unlock;\n\t}\n\n\tif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tptr = bytes_to_frames(sub->runtime,\n\t\t\t\t\tcdev->audio_out_buf_pos[index]);\n\telse\n\t\tptr = bytes_to_frames(sub->runtime,\n\t\t\t\t\tcdev->audio_in_buf_pos[index]);\n\nunlock:\n\tspin_unlock(&cdev->spinlock);\n\treturn ptr;\n}\n\n \nstatic const struct snd_pcm_ops snd_usb_caiaq_ops = {\n\t.open =\t\tsnd_usb_caiaq_substream_open,\n\t.close =\tsnd_usb_caiaq_substream_close,\n\t.hw_free =\tsnd_usb_caiaq_pcm_hw_free,\n\t.prepare =\tsnd_usb_caiaq_pcm_prepare,\n\t.trigger =\tsnd_usb_caiaq_pcm_trigger,\n\t.pointer =\tsnd_usb_caiaq_pcm_pointer,\n};\n\nstatic void check_for_elapsed_periods(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t      struct snd_pcm_substream **subs)\n{\n\tint stream, pb, *cnt;\n\tstruct snd_pcm_substream *sub;\n\n\tfor (stream = 0; stream < cdev->n_streams; stream++) {\n\t\tsub = subs[stream];\n\t\tif (!sub)\n\t\t\tcontinue;\n\n\t\tpb = snd_pcm_lib_period_bytes(sub);\n\t\tcnt = (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\t\t\t\t&cdev->period_out_count[stream] :\n\t\t\t\t\t&cdev->period_in_count[stream];\n\n\t\tif (*cnt >= pb) {\n\t\t\tsnd_pcm_period_elapsed(sub);\n\t\t\t*cnt %= pb;\n\t\t}\n\t}\n}\n\nstatic void read_in_urb_mode0(struct snd_usb_caiaqdev *cdev,\n\t\t\t      const struct urb *urb,\n\t\t\t      const struct usb_iso_packet_descriptor *iso)\n{\n\tunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\n\tstruct snd_pcm_substream *sub;\n\tint stream, i;\n\n\tif (all_substreams_zero(cdev->sub_capture))\n\t\treturn;\n\n\tfor (i = 0; i < iso->actual_length;) {\n\t\tfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\n\t\t\tsub = cdev->sub_capture[stream];\n\t\t\tif (sub) {\n\t\t\t\tstruct snd_pcm_runtime *rt = sub->runtime;\n\t\t\t\tchar *audio_buf = rt->dma_area;\n\t\t\t\tint sz = frames_to_bytes(rt, rt->buffer_size);\n\t\t\t\taudio_buf[cdev->audio_in_buf_pos[stream]++]\n\t\t\t\t\t= usb_buf[i];\n\t\t\t\tcdev->period_in_count[stream]++;\n\t\t\t\tif (cdev->audio_in_buf_pos[stream] == sz)\n\t\t\t\t\tcdev->audio_in_buf_pos[stream] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void read_in_urb_mode2(struct snd_usb_caiaqdev *cdev,\n\t\t\t      const struct urb *urb,\n\t\t\t      const struct usb_iso_packet_descriptor *iso)\n{\n\tunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\n\tunsigned char check_byte;\n\tstruct snd_pcm_substream *sub;\n\tint stream, i;\n\n\tfor (i = 0; i < iso->actual_length;) {\n\t\tif (i % (cdev->n_streams * BYTES_PER_SAMPLE_USB) == 0) {\n\t\t\tfor (stream = 0;\n\t\t\t     stream < cdev->n_streams;\n\t\t\t     stream++, i++) {\n\t\t\t\tif (cdev->first_packet)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcheck_byte = MAKE_CHECKBYTE(cdev, stream, i);\n\n\t\t\t\tif ((usb_buf[i] & 0x3f) != check_byte)\n\t\t\t\t\tcdev->input_panic = 1;\n\n\t\t\t\tif (usb_buf[i] & 0x80)\n\t\t\t\t\tcdev->output_panic = 1;\n\t\t\t}\n\t\t}\n\t\tcdev->first_packet = 0;\n\n\t\tfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\n\t\t\tsub = cdev->sub_capture[stream];\n\t\t\tif (cdev->input_panic)\n\t\t\t\tusb_buf[i] = 0;\n\n\t\t\tif (sub) {\n\t\t\t\tstruct snd_pcm_runtime *rt = sub->runtime;\n\t\t\t\tchar *audio_buf = rt->dma_area;\n\t\t\t\tint sz = frames_to_bytes(rt, rt->buffer_size);\n\t\t\t\taudio_buf[cdev->audio_in_buf_pos[stream]++] =\n\t\t\t\t\tusb_buf[i];\n\t\t\t\tcdev->period_in_count[stream]++;\n\t\t\t\tif (cdev->audio_in_buf_pos[stream] == sz)\n\t\t\t\t\tcdev->audio_in_buf_pos[stream] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void read_in_urb_mode3(struct snd_usb_caiaqdev *cdev,\n\t\t\t      const struct urb *urb,\n\t\t\t      const struct usb_iso_packet_descriptor *iso)\n{\n\tunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\tint stream, i;\n\n\t \n\tif (iso->actual_length % (BYTES_PER_SAMPLE_USB * CHANNELS_PER_STREAM))\n\t\treturn;\n\n\tfor (i = 0; i < iso->actual_length;) {\n\t\tfor (stream = 0; stream < cdev->n_streams; stream++) {\n\t\t\tstruct snd_pcm_substream *sub = cdev->sub_capture[stream];\n\t\t\tchar *audio_buf = NULL;\n\t\t\tint c, n, sz = 0;\n\n\t\t\tif (sub && !cdev->input_panic) {\n\t\t\t\tstruct snd_pcm_runtime *rt = sub->runtime;\n\t\t\t\taudio_buf = rt->dma_area;\n\t\t\t\tsz = frames_to_bytes(rt, rt->buffer_size);\n\t\t\t}\n\n\t\t\tfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\n\t\t\t\t \n\t\t\t\tif (audio_buf) {\n\t\t\t\t\tfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\n\t\t\t\t\t\taudio_buf[cdev->audio_in_buf_pos[stream]++] = usb_buf[i+n];\n\n\t\t\t\t\t\tif (cdev->audio_in_buf_pos[stream] == sz)\n\t\t\t\t\t\t\tcdev->audio_in_buf_pos[stream] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tcdev->period_in_count[stream] += BYTES_PER_SAMPLE;\n\t\t\t\t}\n\n\t\t\t\ti += BYTES_PER_SAMPLE;\n\n\t\t\t\tif (usb_buf[i] != ((stream << 1) | c) &&\n\t\t\t\t    !cdev->first_packet) {\n\t\t\t\t\tif (!cdev->input_panic)\n\t\t\t\t\t\tdev_warn(dev, \" EXPECTED: %02x got %02x, c %d, stream %d, i %d\\n\",\n\t\t\t\t\t\t\t ((stream << 1) | c), usb_buf[i], c, stream, i);\n\t\t\t\t\tcdev->input_panic = 1;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cdev->first_packet > 0)\n\t\tcdev->first_packet--;\n}\n\nstatic void read_in_urb(struct snd_usb_caiaqdev *cdev,\n\t\t\tconst struct urb *urb,\n\t\t\tconst struct usb_iso_packet_descriptor *iso)\n{\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tif (!cdev->streaming)\n\t\treturn;\n\n\tif (iso->actual_length < cdev->bpp)\n\t\treturn;\n\n\tswitch (cdev->spec.data_alignment) {\n\tcase 0:\n\t\tread_in_urb_mode0(cdev, urb, iso);\n\t\tbreak;\n\tcase 2:\n\t\tread_in_urb_mode2(cdev, urb, iso);\n\t\tbreak;\n\tcase 3:\n\t\tread_in_urb_mode3(cdev, urb, iso);\n\t\tbreak;\n\t}\n\n\tif ((cdev->input_panic || cdev->output_panic) && !cdev->warned) {\n\t\tdev_warn(dev, \"streaming error detected %s %s\\n\",\n\t\t\t\tcdev->input_panic ? \"(input)\" : \"\",\n\t\t\t\tcdev->output_panic ? \"(output)\" : \"\");\n\t\tcdev->warned = 1;\n\t}\n}\n\nstatic void fill_out_urb_mode_0(struct snd_usb_caiaqdev *cdev,\n\t\t\t\tstruct urb *urb,\n\t\t\t\tconst struct usb_iso_packet_descriptor *iso)\n{\n\tunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\n\tstruct snd_pcm_substream *sub;\n\tint stream, i;\n\n\tfor (i = 0; i < iso->length;) {\n\t\tfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\n\t\t\tsub = cdev->sub_playback[stream];\n\t\t\tif (sub) {\n\t\t\t\tstruct snd_pcm_runtime *rt = sub->runtime;\n\t\t\t\tchar *audio_buf = rt->dma_area;\n\t\t\t\tint sz = frames_to_bytes(rt, rt->buffer_size);\n\t\t\t\tusb_buf[i] =\n\t\t\t\t\taudio_buf[cdev->audio_out_buf_pos[stream]];\n\t\t\t\tcdev->period_out_count[stream]++;\n\t\t\t\tcdev->audio_out_buf_pos[stream]++;\n\t\t\t\tif (cdev->audio_out_buf_pos[stream] == sz)\n\t\t\t\t\tcdev->audio_out_buf_pos[stream] = 0;\n\t\t\t} else\n\t\t\t\tusb_buf[i] = 0;\n\t\t}\n\n\t\t \n\t\tif (cdev->spec.data_alignment == 2 &&\n\t\t    i % (cdev->n_streams * BYTES_PER_SAMPLE_USB) ==\n\t\t        (cdev->n_streams * CHANNELS_PER_STREAM))\n\t\t\tfor (stream = 0; stream < cdev->n_streams; stream++, i++)\n\t\t\t\tusb_buf[i] = MAKE_CHECKBYTE(cdev, stream, i);\n\t}\n}\n\nstatic void fill_out_urb_mode_3(struct snd_usb_caiaqdev *cdev,\n\t\t\t\tstruct urb *urb,\n\t\t\t\tconst struct usb_iso_packet_descriptor *iso)\n{\n\tunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\n\tint stream, i;\n\n\tfor (i = 0; i < iso->length;) {\n\t\tfor (stream = 0; stream < cdev->n_streams; stream++) {\n\t\t\tstruct snd_pcm_substream *sub = cdev->sub_playback[stream];\n\t\t\tchar *audio_buf = NULL;\n\t\t\tint c, n, sz = 0;\n\n\t\t\tif (sub) {\n\t\t\t\tstruct snd_pcm_runtime *rt = sub->runtime;\n\t\t\t\taudio_buf = rt->dma_area;\n\t\t\t\tsz = frames_to_bytes(rt, rt->buffer_size);\n\t\t\t}\n\n\t\t\tfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\n\t\t\t\tfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\n\t\t\t\t\tif (audio_buf) {\n\t\t\t\t\t\tusb_buf[i+n] = audio_buf[cdev->audio_out_buf_pos[stream]++];\n\n\t\t\t\t\t\tif (cdev->audio_out_buf_pos[stream] == sz)\n\t\t\t\t\t\t\tcdev->audio_out_buf_pos[stream] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusb_buf[i+n] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (audio_buf)\n\t\t\t\t\tcdev->period_out_count[stream] += BYTES_PER_SAMPLE;\n\n\t\t\t\ti += BYTES_PER_SAMPLE;\n\n\t\t\t\t \n\t\t\t\tusb_buf[i++] = (stream << 1) | c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void fill_out_urb(struct snd_usb_caiaqdev *cdev,\n\t\t\t\tstruct urb *urb,\n\t\t\t\tconst struct usb_iso_packet_descriptor *iso)\n{\n\tswitch (cdev->spec.data_alignment) {\n\tcase 0:\n\tcase 2:\n\t\tfill_out_urb_mode_0(cdev, urb, iso);\n\t\tbreak;\n\tcase 3:\n\t\tfill_out_urb_mode_3(cdev, urb, iso);\n\t\tbreak;\n\t}\n}\n\nstatic void read_completed(struct urb *urb)\n{\n\tstruct snd_usb_caiaq_cb_info *info = urb->context;\n\tstruct snd_usb_caiaqdev *cdev;\n\tstruct device *dev;\n\tstruct urb *out = NULL;\n\tint i, frame, len, send_it = 0, outframe = 0;\n\tunsigned long flags;\n\tsize_t offset = 0;\n\n\tif (urb->status || !info)\n\t\treturn;\n\n\tcdev = info->cdev;\n\tdev = caiaqdev_to_dev(cdev);\n\n\tif (!cdev->streaming)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < N_URBS; i++)\n\t\tif (test_and_set_bit(i, &cdev->outurb_active_mask) == 0) {\n\t\t\tout = cdev->data_urbs_out[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (!out) {\n\t\tdev_err(dev, \"Unable to find an output urb to use\\n\");\n\t\tgoto requeue;\n\t}\n\n\t \n\tfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\n\t\tif (urb->iso_frame_desc[frame].status)\n\t\t\tcontinue;\n\n\t\tlen = urb->iso_frame_desc[outframe].actual_length;\n\t\tout->iso_frame_desc[outframe].length = len;\n\t\tout->iso_frame_desc[outframe].actual_length = 0;\n\t\tout->iso_frame_desc[outframe].offset = offset;\n\t\toffset += len;\n\n\t\tif (len > 0) {\n\t\t\tspin_lock_irqsave(&cdev->spinlock, flags);\n\t\t\tfill_out_urb(cdev, out, &out->iso_frame_desc[outframe]);\n\t\t\tread_in_urb(cdev, urb, &urb->iso_frame_desc[frame]);\n\t\t\tspin_unlock_irqrestore(&cdev->spinlock, flags);\n\t\t\tcheck_for_elapsed_periods(cdev, cdev->sub_playback);\n\t\t\tcheck_for_elapsed_periods(cdev, cdev->sub_capture);\n\t\t\tsend_it = 1;\n\t\t}\n\n\t\toutframe++;\n\t}\n\n\tif (send_it) {\n\t\tout->number_of_packets = outframe;\n\t\tusb_submit_urb(out, GFP_ATOMIC);\n\t} else {\n\t\tstruct snd_usb_caiaq_cb_info *oinfo = out->context;\n\t\tclear_bit(oinfo->index, &cdev->outurb_active_mask);\n\t}\n\nrequeue:\n\t \n\tfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\n\t\turb->iso_frame_desc[frame].offset = BYTES_PER_FRAME * frame;\n\t\turb->iso_frame_desc[frame].length = BYTES_PER_FRAME;\n\t\turb->iso_frame_desc[frame].actual_length = 0;\n\t}\n\n\turb->number_of_packets = FRAMES_PER_URB;\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void write_completed(struct urb *urb)\n{\n\tstruct snd_usb_caiaq_cb_info *info = urb->context;\n\tstruct snd_usb_caiaqdev *cdev = info->cdev;\n\n\tif (!cdev->output_running) {\n\t\tcdev->output_running = 1;\n\t\twake_up(&cdev->prepare_wait_queue);\n\t}\n\n\tclear_bit(info->index, &cdev->outurb_active_mask);\n}\n\nstatic struct urb **alloc_urbs(struct snd_usb_caiaqdev *cdev, int dir, int *ret)\n{\n\tint i, frame;\n\tstruct urb **urbs;\n\tstruct usb_device *usb_dev = cdev->chip.dev;\n\tunsigned int pipe;\n\n\tpipe = (dir == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\tusb_sndisocpipe(usb_dev, ENDPOINT_PLAYBACK) :\n\t\tusb_rcvisocpipe(usb_dev, ENDPOINT_CAPTURE);\n\n\turbs = kmalloc_array(N_URBS, sizeof(*urbs), GFP_KERNEL);\n\tif (!urbs) {\n\t\t*ret = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < N_URBS; i++) {\n\t\turbs[i] = usb_alloc_urb(FRAMES_PER_URB, GFP_KERNEL);\n\t\tif (!urbs[i]) {\n\t\t\t*ret = -ENOMEM;\n\t\t\treturn urbs;\n\t\t}\n\n\t\turbs[i]->transfer_buffer =\n\t\t\tkmalloc_array(BYTES_PER_FRAME, FRAMES_PER_URB,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!urbs[i]->transfer_buffer) {\n\t\t\t*ret = -ENOMEM;\n\t\t\treturn urbs;\n\t\t}\n\n\t\tfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\n\t\t\tstruct usb_iso_packet_descriptor *iso =\n\t\t\t\t&urbs[i]->iso_frame_desc[frame];\n\n\t\t\tiso->offset = BYTES_PER_FRAME * frame;\n\t\t\tiso->length = BYTES_PER_FRAME;\n\t\t}\n\n\t\turbs[i]->dev = usb_dev;\n\t\turbs[i]->pipe = pipe;\n\t\turbs[i]->transfer_buffer_length = FRAMES_PER_URB\n\t\t\t\t\t\t* BYTES_PER_FRAME;\n\t\turbs[i]->context = &cdev->data_cb_info[i];\n\t\turbs[i]->interval = 1;\n\t\turbs[i]->number_of_packets = FRAMES_PER_URB;\n\t\turbs[i]->complete = (dir == SNDRV_PCM_STREAM_CAPTURE) ?\n\t\t\t\t\tread_completed : write_completed;\n\t}\n\n\t*ret = 0;\n\treturn urbs;\n}\n\nstatic void free_urbs(struct urb **urbs)\n{\n\tint i;\n\n\tif (!urbs)\n\t\treturn;\n\n\tfor (i = 0; i < N_URBS; i++) {\n\t\tif (!urbs[i])\n\t\t\tcontinue;\n\n\t\tusb_kill_urb(urbs[i]);\n\t\tkfree(urbs[i]->transfer_buffer);\n\t\tusb_free_urb(urbs[i]);\n\t}\n\n\tkfree(urbs);\n}\n\nint snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *cdev)\n{\n\tint i, ret;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tcdev->n_audio_in  = max(cdev->spec.num_analog_audio_in,\n\t\t\t       cdev->spec.num_digital_audio_in) /\n\t\t\t\tCHANNELS_PER_STREAM;\n\tcdev->n_audio_out = max(cdev->spec.num_analog_audio_out,\n\t\t\t       cdev->spec.num_digital_audio_out) /\n\t\t\t\tCHANNELS_PER_STREAM;\n\tcdev->n_streams = max(cdev->n_audio_in, cdev->n_audio_out);\n\n\tdev_dbg(dev, \"cdev->n_audio_in = %d\\n\", cdev->n_audio_in);\n\tdev_dbg(dev, \"cdev->n_audio_out = %d\\n\", cdev->n_audio_out);\n\tdev_dbg(dev, \"cdev->n_streams = %d\\n\", cdev->n_streams);\n\n\tif (cdev->n_streams > MAX_STREAMS) {\n\t\tdev_err(dev, \"unable to initialize device, too many streams.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cdev->n_streams < 1) {\n\t\tdev_err(dev, \"bogus number of streams: %d\\n\", cdev->n_streams);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_pcm_new(cdev->chip.card, cdev->product_name, 0,\n\t\t\tcdev->n_audio_out, cdev->n_audio_in, &cdev->pcm);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"snd_pcm_new() returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcdev->pcm->private_data = cdev;\n\tstrscpy(cdev->pcm->name, cdev->product_name, sizeof(cdev->pcm->name));\n\n\tmemset(cdev->sub_playback, 0, sizeof(cdev->sub_playback));\n\tmemset(cdev->sub_capture, 0, sizeof(cdev->sub_capture));\n\n\tmemcpy(&cdev->pcm_info, &snd_usb_caiaq_pcm_hardware,\n\t\t\tsizeof(snd_usb_caiaq_pcm_hardware));\n\n\t \n\tcdev->samplerates = cdev->pcm_info.rates;\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_SESSIONIO):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_GUITARRIGMOBILE):\n\t\tcdev->samplerates |= SNDRV_PCM_RATE_192000;\n\t\tfallthrough;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO2DJ):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORAUDIO2):\n\t\tcdev->samplerates |= SNDRV_PCM_RATE_88200;\n\t\tbreak;\n\t}\n\n\tsnd_pcm_set_ops(cdev->pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_usb_caiaq_ops);\n\tsnd_pcm_set_ops(cdev->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_usb_caiaq_ops);\n\tsnd_pcm_set_managed_buffer_all(cdev->pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\n\tcdev->data_cb_info =\n\t\tkmalloc_array(N_URBS, sizeof(struct snd_usb_caiaq_cb_info),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!cdev->data_cb_info)\n\t\treturn -ENOMEM;\n\n\tcdev->outurb_active_mask = 0;\n\tBUILD_BUG_ON(N_URBS > (sizeof(cdev->outurb_active_mask) * 8));\n\n\tfor (i = 0; i < N_URBS; i++) {\n\t\tcdev->data_cb_info[i].cdev = cdev;\n\t\tcdev->data_cb_info[i].index = i;\n\t}\n\n\tcdev->data_urbs_in = alloc_urbs(cdev, SNDRV_PCM_STREAM_CAPTURE, &ret);\n\tif (ret < 0) {\n\t\tkfree(cdev->data_cb_info);\n\t\tfree_urbs(cdev->data_urbs_in);\n\t\treturn ret;\n\t}\n\n\tcdev->data_urbs_out = alloc_urbs(cdev, SNDRV_PCM_STREAM_PLAYBACK, &ret);\n\tif (ret < 0) {\n\t\tkfree(cdev->data_cb_info);\n\t\tfree_urbs(cdev->data_urbs_in);\n\t\tfree_urbs(cdev->data_urbs_out);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *cdev)\n{\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, cdev);\n\tstream_stop(cdev);\n\tfree_urbs(cdev->data_urbs_in);\n\tfree_urbs(cdev->data_urbs_out);\n\tkfree(cdev->data_cb_info);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}