{
  "module_name": "input.c",
  "hash_id": "fcd2446b1b789e3d0de93f0a40033c06d67008697cbd338b85797f1081781ad7",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/caiaq/input.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"device.h\"\n#include \"input.h\"\n\nstatic const unsigned short keycode_ak1[] =  { KEY_C, KEY_B, KEY_A };\nstatic const unsigned short keycode_rk2[] =  { KEY_1, KEY_2, KEY_3, KEY_4,\n\t\t\t\t\t KEY_5, KEY_6, KEY_7 };\nstatic const unsigned short keycode_rk3[] =  { KEY_1, KEY_2, KEY_3, KEY_4,\n\t\t\t\t\t KEY_5, KEY_6, KEY_7, KEY_8, KEY_9 };\n\nstatic const unsigned short keycode_kore[] = {\n\tKEY_FN_F1,       \n\tKEY_FN_F7,       \n\tKEY_FN_F2,       \n\tKEY_FN_F3,       \n\tKEY_FN_F4,       \n\tKEY_FN_F5,       \n\tKEY_FN_F6,       \n\tKEY_FN_F8,       \n\tKEY_RIGHT,\n\tKEY_DOWN,\n\tKEY_UP,\n\tKEY_LEFT,\n\tKEY_SOUND,       \n\tKEY_RECORD,\n\tKEY_PLAYPAUSE,\n\tKEY_STOP,\n\tBTN_4,           \n\tBTN_3,\n\tBTN_2,\n\tBTN_1,\n\tBTN_8,\n\tBTN_7,\n\tBTN_6,\n\tBTN_5,\n\tKEY_BRL_DOT4,    \n\tKEY_BRL_DOT3,\n\tKEY_BRL_DOT2,\n\tKEY_BRL_DOT1,\n\tKEY_BRL_DOT8,\n\tKEY_BRL_DOT7,\n\tKEY_BRL_DOT6,\n\tKEY_BRL_DOT5\n};\n\n#define MASCHINE_BUTTONS   (42)\n#define MASCHINE_BUTTON(X) ((X) + BTN_MISC)\n#define MASCHINE_PADS      (16)\n#define MASCHINE_PAD(X)    ((X) + ABS_PRESSURE)\n\nstatic const unsigned short keycode_maschine[] = {\n\tMASCHINE_BUTTON(40),  \n\tMASCHINE_BUTTON(39),  \n\tMASCHINE_BUTTON(38),  \n\tMASCHINE_BUTTON(37),  \n\tMASCHINE_BUTTON(36),  \n\tMASCHINE_BUTTON(35),  \n\tMASCHINE_BUTTON(34),  \n\tMASCHINE_BUTTON(33),  \n\tKEY_RESERVED,  \n\n\tMASCHINE_BUTTON(30),  \n\tMASCHINE_BUTTON(31),  \n\tMASCHINE_BUTTON(32),  \n\tMASCHINE_BUTTON(28),  \n\tMASCHINE_BUTTON(27),  \n\tMASCHINE_BUTTON(26),  \n\tMASCHINE_BUTTON(25),  \n\n\tMASCHINE_BUTTON(21),  \n\tMASCHINE_BUTTON(22),  \n\tMASCHINE_BUTTON(23),  \n\tMASCHINE_BUTTON(24),  \n\tMASCHINE_BUTTON(20),  \n\tMASCHINE_BUTTON(19),  \n\tMASCHINE_BUTTON(18),  \n\tMASCHINE_BUTTON(17),  \n\n\tMASCHINE_BUTTON(0),   \n\tMASCHINE_BUTTON(2),   \n\tMASCHINE_BUTTON(4),   \n\tMASCHINE_BUTTON(6),   \n\tMASCHINE_BUTTON(7),   \n\tMASCHINE_BUTTON(5),   \n\tMASCHINE_BUTTON(3),   \n\tMASCHINE_BUTTON(1),   \n\n\tMASCHINE_BUTTON(15),  \n\tMASCHINE_BUTTON(14),\n\tMASCHINE_BUTTON(13),\n\tMASCHINE_BUTTON(12),\n\tMASCHINE_BUTTON(11),\n\tMASCHINE_BUTTON(10),\n\tMASCHINE_BUTTON(9),\n\tMASCHINE_BUTTON(8),\n\n\tMASCHINE_BUTTON(16),  \n\tMASCHINE_BUTTON(29)   \n};\n\n#define KONTROLX1_INPUTS\t(40)\n#define KONTROLS4_BUTTONS\t(12 * 8)\n#define KONTROLS4_AXIS\t\t(46)\n\n#define KONTROLS4_BUTTON(X)\t((X) + BTN_MISC)\n#define KONTROLS4_ABS(X)\t((X) + ABS_HAT0X)\n\n#define DEG90\t\t(range / 2)\n#define DEG180\t\t(range)\n#define DEG270\t\t(DEG90 + DEG180)\n#define DEG360\t\t(DEG180 * 2)\n#define HIGH_PEAK\t(268)\n#define LOW_PEAK\t(-7)\n\n \nstatic unsigned int decode_erp(unsigned char a, unsigned char b)\n{\n\tint weight_a, weight_b;\n\tint pos_a, pos_b;\n\tint ret;\n\tint range = HIGH_PEAK - LOW_PEAK;\n\tint mid_value = (HIGH_PEAK + LOW_PEAK) / 2;\n\n\tweight_b = abs(mid_value - a) - (range / 2 - 100) / 2;\n\n\tif (weight_b < 0)\n\t\tweight_b = 0;\n\n\tif (weight_b > 100)\n\t\tweight_b = 100;\n\n\tweight_a = 100 - weight_b;\n\n\tif (a < mid_value) {\n\t\t \n\t\tpos_b = b - LOW_PEAK + DEG270;\n\t\tif (pos_b >= DEG360)\n\t\t\tpos_b -= DEG360;\n\t} else\n\t\t \n\t\tpos_b = HIGH_PEAK - b + DEG90;\n\n\n\tif (b > mid_value)\n\t\t \n\t\tpos_a = a - LOW_PEAK;\n\telse\n\t\t \n\t\tpos_a = HIGH_PEAK - a + DEG180;\n\n\t \n\t \n\tret = pos_a * weight_a + pos_b * weight_b;\n\n\t \n\tret *= 10;\n\tret /= DEG360;\n\n\tif (ret < 0)\n\t\tret += 1000;\n\n\tif (ret >= 1000)\n\t\tret -= 1000;\n\n\treturn ret;\n}\n\n#undef DEG90\n#undef DEG180\n#undef DEG270\n#undef DEG360\n#undef HIGH_PEAK\n#undef LOW_PEAK\n\nstatic inline void snd_caiaq_input_report_abs(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t\t      int axis, const unsigned char *buf,\n\t\t\t\t\t      int offset)\n{\n\tinput_report_abs(cdev->input_dev, axis,\n\t\t\t (buf[offset * 2] << 8) | buf[offset * 2 + 1]);\n}\n\nstatic void snd_caiaq_input_read_analog(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t\tconst unsigned char *buf,\n\t\t\t\t\tunsigned int len)\n{\n\tstruct input_dev *input_dev = cdev->input_dev;\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_X, buf, 2);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_Y, buf, 0);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_Z, buf, 1);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_X, buf, 0);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_Y, buf, 1);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_Z, buf, 2);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT0X, buf, 4);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT0Y, buf, 2);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT1X, buf, 6);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT1Y, buf, 1);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT2X, buf, 7);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT2Y, buf, 0);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT3X, buf, 5);\n\t\tsnd_caiaq_input_report_abs(cdev, ABS_HAT3Y, buf, 3);\n\t\tbreak;\n\t}\n\n\tinput_sync(input_dev);\n}\n\nstatic void snd_caiaq_input_read_erp(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t     const char *buf, unsigned int len)\n{\n\tstruct input_dev *input_dev = cdev->input_dev;\n\tint i;\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\n\t\ti = decode_erp(buf[0], buf[1]);\n\t\tinput_report_abs(input_dev, ABS_X, i);\n\t\tinput_sync(input_dev);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):\n\t\ti = decode_erp(buf[7], buf[5]);\n\t\tinput_report_abs(input_dev, ABS_HAT0X, i);\n\t\ti = decode_erp(buf[12], buf[14]);\n\t\tinput_report_abs(input_dev, ABS_HAT0Y, i);\n\t\ti = decode_erp(buf[15], buf[13]);\n\t\tinput_report_abs(input_dev, ABS_HAT1X, i);\n\t\ti = decode_erp(buf[0], buf[2]);\n\t\tinput_report_abs(input_dev, ABS_HAT1Y, i);\n\t\ti = decode_erp(buf[3], buf[1]);\n\t\tinput_report_abs(input_dev, ABS_HAT2X, i);\n\t\ti = decode_erp(buf[8], buf[10]);\n\t\tinput_report_abs(input_dev, ABS_HAT2Y, i);\n\t\ti = decode_erp(buf[11], buf[9]);\n\t\tinput_report_abs(input_dev, ABS_HAT3X, i);\n\t\ti = decode_erp(buf[4], buf[6]);\n\t\tinput_report_abs(input_dev, ABS_HAT3Y, i);\n\t\tinput_sync(input_dev);\n\t\tbreak;\n\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_MASCHINECONTROLLER):\n\t\t \n\t\tinput_report_abs(input_dev, ABS_HAT0X, decode_erp(buf[21], buf[20]));\n\t\tinput_report_abs(input_dev, ABS_HAT0Y, decode_erp(buf[15], buf[14]));\n\t\tinput_report_abs(input_dev, ABS_HAT1X, decode_erp(buf[9],  buf[8]));\n\t\tinput_report_abs(input_dev, ABS_HAT1Y, decode_erp(buf[3],  buf[2]));\n\n\t\t \n\t\tinput_report_abs(input_dev, ABS_HAT2X, decode_erp(buf[19], buf[18]));\n\t\tinput_report_abs(input_dev, ABS_HAT2Y, decode_erp(buf[13], buf[12]));\n\t\tinput_report_abs(input_dev, ABS_HAT3X, decode_erp(buf[7],  buf[6]));\n\t\tinput_report_abs(input_dev, ABS_HAT3Y, decode_erp(buf[1],  buf[0]));\n\n\t\t \n\t\tinput_report_abs(input_dev, ABS_RX, decode_erp(buf[17], buf[16]));\n\t\t \n\t\tinput_report_abs(input_dev, ABS_RY, decode_erp(buf[11], buf[10]));\n\t\t \n\t\tinput_report_abs(input_dev, ABS_RZ, decode_erp(buf[5],  buf[4]));\n\n\t\tinput_sync(input_dev);\n\t\tbreak;\n\t}\n}\n\nstatic void snd_caiaq_input_read_io(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t    unsigned char *buf, unsigned int len)\n{\n\tstruct input_dev *input_dev = cdev->input_dev;\n\tunsigned short *keycode = input_dev->keycode;\n\tint i;\n\n\tif (!keycode)\n\t\treturn;\n\n\tif (input_dev->id.product == USB_PID_RIGKONTROL2)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = ~buf[i];\n\n\tfor (i = 0; i < input_dev->keycodemax && i < len * 8; i++)\n\t\tinput_report_key(input_dev, keycode[i],\n\t\t\t\t buf[i / 8] & (1 << (i % 8)));\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):\n\t\tinput_report_abs(cdev->input_dev, ABS_MISC, 255 - buf[4]);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\t\t \n\t\tinput_report_abs(cdev->input_dev, ABS_X, buf[5] & 0xf);\n\t\tinput_report_abs(cdev->input_dev, ABS_Y, buf[5] >> 4);\n\t\tinput_report_abs(cdev->input_dev, ABS_Z, buf[6] & 0xf);\n\t\tinput_report_abs(cdev->input_dev, ABS_MISC, buf[6] >> 4);\n\t\tbreak;\n\t}\n\n\tinput_sync(input_dev);\n}\n\n#define TKS4_MSGBLOCK_SIZE\t16\n\nstatic void snd_usb_caiaq_tks4_dispatch(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t\tconst unsigned char *buf,\n\t\t\t\t\tunsigned int len)\n{\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\twhile (len) {\n\t\tunsigned int i, block_id = (buf[0] << 8) | buf[1];\n\n\t\tswitch (block_id) {\n\t\tcase 0:\n\t\t\t \n\t\t\tfor (i = 0; i < KONTROLS4_BUTTONS; i++)\n\t\t\t\tinput_report_key(cdev->input_dev, KONTROLS4_BUTTON(i),\n\t\t\t\t\t\t (buf[4 + (i / 8)] >> (i % 8)) & 1);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(36), buf[9] | ((buf[8] & 0x3) << 8));\n\t\t\t \n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(37), buf[13] | ((buf[12] & 0x3) << 8));\n\n\t\t\t \n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(38), buf[3] & 0xf);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(39), buf[4] >> 4);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(40), buf[4] & 0xf);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(41), buf[5] >> 4);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(42), buf[5] & 0xf);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(43), buf[6] >> 4);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(44), buf[6] & 0xf);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(45), buf[7] >> 4);\n\t\t\tinput_report_abs(cdev->input_dev, KONTROLS4_ABS(46), buf[7] & 0xf);\n\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(0), buf, 1);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(1), buf, 2);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(2), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(3), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(4), buf, 6);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(7), buf, 7);\n\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(6), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(5), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(8), buf, 6);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(9), buf, 7);\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(10), buf, 1);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(11), buf, 2);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(12), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(13), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(14), buf, 5);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(15), buf, 6);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(16), buf, 7);\n\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(17), buf, 1);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(18), buf, 2);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(19), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(20), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(21), buf, 5);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(22), buf, 6);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(23), buf, 7);\n\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(24), buf, 1);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(25), buf, 2);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(26), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(27), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(28), buf, 5);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(29), buf, 6);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(30), buf, 7);\n\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(31), buf, 1);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(32), buf, 2);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(33), buf, 3);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(34), buf, 4);\n\t\t\t \n\t\t\tsnd_caiaq_input_report_abs(cdev, KONTROLS4_ABS(35), buf, 5);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"%s(): bogus block (id %d)\\n\",\n\t\t\t\t__func__, block_id);\n\t\t\treturn;\n\t\t}\n\n\t\tlen -= TKS4_MSGBLOCK_SIZE;\n\t\tbuf += TKS4_MSGBLOCK_SIZE;\n\t}\n\n\tinput_sync(cdev->input_dev);\n}\n\n#define MASCHINE_MSGBLOCK_SIZE 2\n\nstatic void snd_usb_caiaq_maschine_dispatch(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t\tconst unsigned char *buf,\n\t\t\t\t\tunsigned int len)\n{\n\tunsigned int i, pad_id;\n\t__le16 *pressure = (__le16 *) buf;\n\n\tfor (i = 0; i < MASCHINE_PADS; i++) {\n\t\tpad_id = le16_to_cpu(*pressure) >> 12;\n\t\tinput_report_abs(cdev->input_dev, MASCHINE_PAD(pad_id),\n\t\t\t\t le16_to_cpu(*pressure) & 0xfff);\n\t\tpressure++;\n\t}\n\n\tinput_sync(cdev->input_dev);\n}\n\nstatic void snd_usb_caiaq_ep4_reply_dispatch(struct urb *urb)\n{\n\tstruct snd_usb_caiaqdev *cdev = urb->context;\n\tunsigned char *buf = urb->transfer_buffer;\n\tstruct device *dev = &urb->dev->dev;\n\tint ret;\n\n\tif (urb->status || !cdev || urb != cdev->ep4_in_urb)\n\t\treturn;\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\t\tif (urb->actual_length < 24)\n\t\t\tgoto requeue;\n\n\t\tif (buf[0] & 0x3)\n\t\t\tsnd_caiaq_input_read_io(cdev, buf + 1, 7);\n\n\t\tif (buf[0] & 0x4)\n\t\t\tsnd_caiaq_input_read_analog(cdev, buf + 8, 16);\n\n\t\tbreak;\n\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLS4):\n\t\tsnd_usb_caiaq_tks4_dispatch(cdev, buf, urb->actual_length);\n\t\tbreak;\n\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_MASCHINECONTROLLER):\n\t\tif (urb->actual_length < (MASCHINE_PADS * MASCHINE_MSGBLOCK_SIZE))\n\t\t\tgoto requeue;\n\n\t\tsnd_usb_caiaq_maschine_dispatch(cdev, buf, urb->actual_length);\n\t\tbreak;\n\t}\n\nrequeue:\n\tcdev->ep4_in_urb->actual_length = 0;\n\tret = usb_submit_urb(cdev->ep4_in_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_err(dev, \"unable to submit urb. OOM!?\\n\");\n}\n\nstatic int snd_usb_caiaq_input_open(struct input_dev *idev)\n{\n\tstruct snd_usb_caiaqdev *cdev = input_get_drvdata(idev);\n\n\tif (!cdev)\n\t\treturn -EINVAL;\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLS4):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_MASCHINECONTROLLER):\n\t\tif (usb_submit_urb(cdev->ep4_in_urb, GFP_KERNEL) != 0)\n\t\t\treturn -EIO;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_usb_caiaq_input_close(struct input_dev *idev)\n{\n\tstruct snd_usb_caiaqdev *cdev = input_get_drvdata(idev);\n\n\tif (!cdev)\n\t\treturn;\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLS4):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_MASCHINECONTROLLER):\n\t\tusb_kill_urb(cdev->ep4_in_urb);\n\t\tbreak;\n\t}\n}\n\nvoid snd_usb_caiaq_input_dispatch(struct snd_usb_caiaqdev *cdev,\n\t\t\t\t  char *buf,\n\t\t\t\t  unsigned int len)\n{\n\tif (!cdev->input_dev || len < 1)\n\t\treturn;\n\n\tswitch (buf[0]) {\n\tcase EP1_CMD_READ_ANALOG:\n\t\tsnd_caiaq_input_read_analog(cdev, buf + 1, len - 1);\n\t\tbreak;\n\tcase EP1_CMD_READ_ERP:\n\t\tsnd_caiaq_input_read_erp(cdev, buf + 1, len - 1);\n\t\tbreak;\n\tcase EP1_CMD_READ_IO:\n\t\tsnd_caiaq_input_read_io(cdev, buf + 1, len - 1);\n\t\tbreak;\n\t}\n}\n\nint snd_usb_caiaq_input_init(struct snd_usb_caiaqdev *cdev)\n{\n\tstruct usb_device *usb_dev = cdev->chip.dev;\n\tstruct input_dev *input;\n\tint i, ret = 0;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tusb_make_path(usb_dev, cdev->phys, sizeof(cdev->phys));\n\tstrlcat(cdev->phys, \"/input0\", sizeof(cdev->phys));\n\n\tinput->name = cdev->product_name;\n\tinput->phys = cdev->phys;\n\tusb_to_input_id(usb_dev, &input->id);\n\tinput->dev.parent = &usb_dev->dev;\n\n\tinput_set_drvdata(input, cdev);\n\n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\tBIT_MASK(ABS_Z);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < sizeof(keycode_rk2));\n\t\tmemcpy(cdev->keycode, keycode_rk2, sizeof(keycode_rk2));\n\t\tinput->keycodemax = ARRAY_SIZE(keycode_rk2);\n\t\tinput_set_abs_params(input, ABS_X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 0);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\tBIT_MASK(ABS_Z);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < sizeof(keycode_rk3));\n\t\tmemcpy(cdev->keycode, keycode_rk3, sizeof(keycode_rk3));\n\t\tinput->keycodemax = ARRAY_SIZE(keycode_rk3);\n\t\tinput_set_abs_params(input, ABS_X, 0, 1024, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Y, 0, 1024, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Z, 0, 1024, 0, 10);\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 0);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_X);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < sizeof(keycode_ak1));\n\t\tmemcpy(cdev->keycode, keycode_ak1, sizeof(keycode_ak1));\n\t\tinput->keycodemax = ARRAY_SIZE(keycode_ak1);\n\t\tinput_set_abs_params(input, ABS_X, 0, 999, 0, 10);\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 0, 5);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT2X) | BIT_MASK(ABS_HAT2Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT3X) | BIT_MASK(ABS_HAT3Y) |\n\t\t\t\t   BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\t\t   BIT_MASK(ABS_Z);\n\t\tinput->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < sizeof(keycode_kore));\n\t\tmemcpy(cdev->keycode, keycode_kore, sizeof(keycode_kore));\n\t\tinput->keycodemax = ARRAY_SIZE(keycode_kore);\n\t\tinput_set_abs_params(input, ABS_HAT0X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT0Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_MISC, 0, 255, 0, 1);\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 5);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLX1):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT2X) | BIT_MASK(ABS_HAT2Y) |\n\t\t\t\t   BIT_MASK(ABS_HAT3X) | BIT_MASK(ABS_HAT3Y) |\n\t\t\t\t   BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\t\t   BIT_MASK(ABS_Z);\n\t\tinput->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < KONTROLX1_INPUTS);\n\t\tfor (i = 0; i < KONTROLX1_INPUTS; i++)\n\t\t\tcdev->keycode[i] = BTN_MISC + i;\n\t\tinput->keycodemax = KONTROLX1_INPUTS;\n\n\t\t \n\t\tinput_set_abs_params(input, ABS_HAT0X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT0Y, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1Y, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2Y, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3X, 0, 4096, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3Y, 0, 4096, 0, 10);\n\n\t\t \n\t\tinput_set_abs_params(input, ABS_X, 0, 0xf, 0, 1);\n\t\tinput_set_abs_params(input, ABS_Y, 0, 0xf, 0, 1);\n\t\tinput_set_abs_params(input, ABS_Z, 0, 0xf, 0, 1);\n\t\tinput_set_abs_params(input, ABS_MISC, 0, 0xf, 0, 1);\n\n\t\tcdev->ep4_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!cdev->ep4_in_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit_free_idev;\n\t\t}\n\n\t\tusb_fill_bulk_urb(cdev->ep4_in_urb, usb_dev,\n\t\t\t\t  usb_rcvbulkpipe(usb_dev, 0x4),\n\t\t\t\t  cdev->ep4_in_buf, EP4_BUFSIZE,\n\t\t\t\t  snd_usb_caiaq_ep4_reply_dispatch, cdev);\n\t\tret = usb_urb_ep_type_check(cdev->ep4_in_urb);\n\t\tif (ret < 0)\n\t\t\tgoto exit_free_idev;\n\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 5);\n\n\t\tbreak;\n\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORKONTROLS4):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < KONTROLS4_BUTTONS);\n\t\tfor (i = 0; i < KONTROLS4_BUTTONS; i++)\n\t\t\tcdev->keycode[i] = KONTROLS4_BUTTON(i);\n\t\tinput->keycodemax = KONTROLS4_BUTTONS;\n\n\t\tfor (i = 0; i < KONTROLS4_AXIS; i++) {\n\t\t\tint axis = KONTROLS4_ABS(i);\n\t\t\tinput->absbit[BIT_WORD(axis)] |= BIT_MASK(axis);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 36; i++)\n\t\t\tinput_set_abs_params(input, KONTROLS4_ABS(i), 0, 0xfff, 0, 10);\n\n\t\t \n\t\tinput_set_abs_params(input, KONTROLS4_ABS(36), 0, 0x3ff, 0, 1);\n\t\tinput_set_abs_params(input, KONTROLS4_ABS(37), 0, 0x3ff, 0, 1);\n\n\t\t \n\t\tfor (i = 0; i < 9; i++)\n\t\t\tinput_set_abs_params(input, KONTROLS4_ABS(38+i), 0, 0xf, 0, 1);\n\n\t\tcdev->ep4_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!cdev->ep4_in_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit_free_idev;\n\t\t}\n\n\t\tusb_fill_bulk_urb(cdev->ep4_in_urb, usb_dev,\n\t\t\t\t  usb_rcvbulkpipe(usb_dev, 0x4),\n\t\t\t\t  cdev->ep4_in_buf, EP4_BUFSIZE,\n\t\t\t\t  snd_usb_caiaq_ep4_reply_dispatch, cdev);\n\t\tret = usb_urb_ep_type_check(cdev->ep4_in_urb);\n\t\tif (ret < 0)\n\t\t\tgoto exit_free_idev;\n\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 5);\n\n\t\tbreak;\n\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_MASCHINECONTROLLER):\n\t\tinput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput->absbit[0] = BIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |\n\t\t\tBIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y) |\n\t\t\tBIT_MASK(ABS_HAT2X) | BIT_MASK(ABS_HAT2Y) |\n\t\t\tBIT_MASK(ABS_HAT3X) | BIT_MASK(ABS_HAT3Y) |\n\t\t\tBIT_MASK(ABS_RX) | BIT_MASK(ABS_RY) |\n\t\t\tBIT_MASK(ABS_RZ);\n\n\t\tBUILD_BUG_ON(sizeof(cdev->keycode) < sizeof(keycode_maschine));\n\t\tmemcpy(cdev->keycode, keycode_maschine, sizeof(keycode_maschine));\n\t\tinput->keycodemax = ARRAY_SIZE(keycode_maschine);\n\n\t\tfor (i = 0; i < MASCHINE_PADS; i++) {\n\t\t\tinput->absbit[0] |= MASCHINE_PAD(i);\n\t\t\tinput_set_abs_params(input, MASCHINE_PAD(i), 0, 0xfff, 5, 10);\n\t\t}\n\n\t\tinput_set_abs_params(input, ABS_HAT0X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT0Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT1Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT2Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3X, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_HAT3Y, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_RX, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_RY, 0, 999, 0, 10);\n\t\tinput_set_abs_params(input, ABS_RZ, 0, 999, 0, 10);\n\n\t\tcdev->ep4_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!cdev->ep4_in_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit_free_idev;\n\t\t}\n\n\t\tusb_fill_bulk_urb(cdev->ep4_in_urb, usb_dev,\n\t\t\t\t  usb_rcvbulkpipe(usb_dev, 0x4),\n\t\t\t\t  cdev->ep4_in_buf, EP4_BUFSIZE,\n\t\t\t\t  snd_usb_caiaq_ep4_reply_dispatch, cdev);\n\t\tret = usb_urb_ep_type_check(cdev->ep4_in_urb);\n\t\tif (ret < 0)\n\t\t\tgoto exit_free_idev;\n\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 10, 5);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto exit_free_idev;\n\t}\n\n\tinput->open = snd_usb_caiaq_input_open;\n\tinput->close = snd_usb_caiaq_input_close;\n\tinput->keycode = cdev->keycode;\n\tinput->keycodesize = sizeof(unsigned short);\n\tfor (i = 0; i < input->keycodemax; i++)\n\t\t__set_bit(cdev->keycode[i], input->keybit);\n\n\tcdev->input_dev = input;\n\n\tret = input_register_device(input);\n\tif (ret < 0)\n\t\tgoto exit_free_idev;\n\n\treturn 0;\n\nexit_free_idev:\n\tinput_free_device(input);\n\tcdev->input_dev = NULL;\n\treturn ret;\n}\n\nvoid snd_usb_caiaq_input_free(struct snd_usb_caiaqdev *cdev)\n{\n\tif (!cdev || !cdev->input_dev)\n\t\treturn;\n\n\tusb_kill_urb(cdev->ep4_in_urb);\n\tusb_free_urb(cdev->ep4_in_urb);\n\tcdev->ep4_in_urb = NULL;\n\n\tinput_unregister_device(cdev->input_dev);\n\tcdev->input_dev = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}