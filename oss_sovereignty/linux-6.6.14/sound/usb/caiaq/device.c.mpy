{
  "module_name": "device.c",
  "hash_id": "28fe7c00bfdfcfa1f486de1792eb14d5e9cd871705f627bf8868a9756b5a63a9",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/caiaq/device.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/usb.h>\n#include <sound/initval.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"device.h\"\n#include \"audio.h\"\n#include \"midi.h\"\n#include \"control.h\"\n#include \"input.h\"\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@caiaq.de>\");\nMODULE_DESCRIPTION(\"caiaq USB audio\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;  \nstatic char* id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;  \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the caiaq sound device\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the caiaq soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable the caiaq soundcard.\");\n\nenum {\n\tSAMPLERATE_44100\t= 0,\n\tSAMPLERATE_48000\t= 1,\n\tSAMPLERATE_96000\t= 2,\n\tSAMPLERATE_192000\t= 3,\n\tSAMPLERATE_88200\t= 4,\n\tSAMPLERATE_INVALID\t= 0xff\n};\n\nenum {\n\tDEPTH_NONE\t= 0,\n\tDEPTH_16\t= 1,\n\tDEPTH_24\t= 2,\n\tDEPTH_32\t= 3\n};\n\nstatic const struct usb_device_id snd_usb_id_table[] = {\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\tUSB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =\tUSB_PID_RIGKONTROL2\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\tUSB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =\tUSB_PID_RIGKONTROL3\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\tUSB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =\tUSB_PID_KORECONTROLLER\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\tUSB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =\tUSB_PID_KORECONTROLLER2\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_AK1\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_AUDIO8DJ\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_SESSIONIO\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_GUITARRIGMOBILE\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_AUDIO4DJ\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_AUDIO2DJ\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_TRAKTORKONTROLX1\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_TRAKTORKONTROLS4\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_TRAKTORAUDIO2\n\t},\n\t{\n\t\t.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =     USB_VID_NATIVEINSTRUMENTS,\n\t\t.idProduct =    USB_PID_MASCHINECONTROLLER\n\t},\n\t{   }\n};\n\nstatic void usb_ep1_command_reply_dispatch (struct urb* urb)\n{\n\tint ret;\n\tstruct device *dev = &urb->dev->dev;\n\tstruct snd_usb_caiaqdev *cdev = urb->context;\n\tunsigned char *buf = urb->transfer_buffer;\n\n\tif (urb->status || !cdev) {\n\t\tdev_warn(dev, \"received EP1 urb->status = %i\\n\", urb->status);\n\t\treturn;\n\t}\n\n\tswitch(buf[0]) {\n\tcase EP1_CMD_GET_DEVICE_INFO:\n\t \tmemcpy(&cdev->spec, buf+1, sizeof(struct caiaq_device_spec));\n\t\tcdev->spec.fw_version = le16_to_cpu(cdev->spec.fw_version);\n\t\tdev_dbg(dev, \"device spec (firmware %d): audio: %d in, %d out, \"\n\t\t\t\"MIDI: %d in, %d out, data alignment %d\\n\",\n\t\t\tcdev->spec.fw_version,\n\t\t\tcdev->spec.num_analog_audio_in,\n\t\t\tcdev->spec.num_analog_audio_out,\n\t\t\tcdev->spec.num_midi_in,\n\t\t\tcdev->spec.num_midi_out,\n\t\t\tcdev->spec.data_alignment);\n\n\t\tcdev->spec_received++;\n\t\twake_up(&cdev->ep1_wait_queue);\n\t\tbreak;\n\tcase EP1_CMD_AUDIO_PARAMS:\n\t\tcdev->audio_parm_answer = buf[1];\n\t\twake_up(&cdev->ep1_wait_queue);\n\t\tbreak;\n\tcase EP1_CMD_MIDI_READ:\n\t\tsnd_usb_caiaq_midi_handle_input(cdev, buf[1], buf + 3, buf[2]);\n\t\tbreak;\n\tcase EP1_CMD_READ_IO:\n\t\tif (cdev->chip.usb_id ==\n\t\t\tUSB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ)) {\n\t\t\tif (urb->actual_length > sizeof(cdev->control_state))\n\t\t\t\turb->actual_length = sizeof(cdev->control_state);\n\t\t\tmemcpy(cdev->control_state, buf + 1, urb->actual_length);\n\t\t\twake_up(&cdev->ep1_wait_queue);\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_SND_USB_CAIAQ_INPUT\n\t\tfallthrough;\n\tcase EP1_CMD_READ_ERP:\n\tcase EP1_CMD_READ_ANALOG:\n\t\tsnd_usb_caiaq_input_dispatch(cdev, buf, urb->actual_length);\n#endif\n\t\tbreak;\n\t}\n\n\tcdev->ep1_in_urb.actual_length = 0;\n\tret = usb_submit_urb(&cdev->ep1_in_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_err(dev, \"unable to submit urb. OOM!?\\n\");\n}\n\nint snd_usb_caiaq_send_command(struct snd_usb_caiaqdev *cdev,\n\t\t\t       unsigned char command,\n\t\t\t       const unsigned char *buffer,\n\t\t\t       int len)\n{\n\tint actual_len;\n\tstruct usb_device *usb_dev = cdev->chip.dev;\n\n\tif (!usb_dev)\n\t\treturn -EIO;\n\n\tif (len > EP1_BUFSIZE - 1)\n\t\tlen = EP1_BUFSIZE - 1;\n\n\tif (buffer && len > 0)\n\t\tmemcpy(cdev->ep1_out_buf+1, buffer, len);\n\n\tcdev->ep1_out_buf[0] = command;\n\treturn usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, 1),\n\t\t\t   cdev->ep1_out_buf, len+1, &actual_len, 200);\n}\n\nint snd_usb_caiaq_send_command_bank(struct snd_usb_caiaqdev *cdev,\n\t\t\t       unsigned char command,\n\t\t\t       unsigned char bank,\n\t\t\t       const unsigned char *buffer,\n\t\t\t       int len)\n{\n\tint actual_len;\n\tstruct usb_device *usb_dev = cdev->chip.dev;\n\n\tif (!usb_dev)\n\t\treturn -EIO;\n\n\tif (len > EP1_BUFSIZE - 2)\n\t\tlen = EP1_BUFSIZE - 2;\n\n\tif (buffer && len > 0)\n\t\tmemcpy(cdev->ep1_out_buf+2, buffer, len);\n\n\tcdev->ep1_out_buf[0] = command;\n\tcdev->ep1_out_buf[1] = bank;\n\n\treturn usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, 1),\n\t\t\t   cdev->ep1_out_buf, len+2, &actual_len, 200);\n}\n\nint snd_usb_caiaq_set_audio_params (struct snd_usb_caiaqdev *cdev,\n\t\t   \t\t    int rate, int depth, int bpp)\n{\n\tint ret;\n\tchar tmp[5];\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\tswitch (rate) {\n\tcase 44100:\ttmp[0] = SAMPLERATE_44100;   break;\n\tcase 48000:\ttmp[0] = SAMPLERATE_48000;   break;\n\tcase 88200:\ttmp[0] = SAMPLERATE_88200;   break;\n\tcase 96000:\ttmp[0] = SAMPLERATE_96000;   break;\n\tcase 192000:\ttmp[0] = SAMPLERATE_192000;  break;\n\tdefault:\treturn -EINVAL;\n\t}\n\n\tswitch (depth) {\n\tcase 16:\ttmp[1] = DEPTH_16;   break;\n\tcase 24:\ttmp[1] = DEPTH_24;   break;\n\tdefault:\treturn -EINVAL;\n\t}\n\n\ttmp[2] = bpp & 0xff;\n\ttmp[3] = bpp >> 8;\n\ttmp[4] = 1;  \n\n\tdev_dbg(dev, \"setting audio params: %d Hz, %d bits, %d bpp\\n\",\n\t\trate, depth, bpp);\n\n\tcdev->audio_parm_answer = -1;\n\tret = snd_usb_caiaq_send_command(cdev, EP1_CMD_AUDIO_PARAMS,\n\t\t\t\t\t tmp, sizeof(tmp));\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_event_timeout(cdev->ep1_wait_queue,\n\t    cdev->audio_parm_answer >= 0, HZ))\n\t\treturn -EPIPE;\n\n\tif (cdev->audio_parm_answer != 1)\n\t\tdev_dbg(dev, \"unable to set the device's audio params\\n\");\n\telse\n\t\tcdev->bpp = bpp;\n\n\treturn cdev->audio_parm_answer == 1 ? 0 : -EINVAL;\n}\n\nint snd_usb_caiaq_set_auto_msg(struct snd_usb_caiaqdev *cdev,\n\t\t\t       int digital, int analog, int erp)\n{\n\tchar tmp[3] = { digital, analog, erp };\n\treturn snd_usb_caiaq_send_command(cdev, EP1_CMD_AUTO_MSG,\n\t\t\t\t\t  tmp, sizeof(tmp));\n}\n\nstatic void setup_card(struct snd_usb_caiaqdev *cdev)\n{\n\tint ret;\n\tchar val[4];\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\n\t \n\tswitch (cdev->chip.usb_id) {\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):\n\t\t \n\t\tval[0] = 0x00;\n\t\tval[1] = 0x00;\n\t\tval[2] = 0x01;\n\t\tsnd_usb_caiaq_send_command(cdev, EP1_CMD_WRITE_IO, val, 3);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\n\t\t \n\t\tval[0] = 0x00;\n\t\tval[1] = 0x40;\n\t\tval[2] = 0x40;\n\t\tval[3] = 0x00;\n\t\tsnd_usb_caiaq_send_command(cdev, EP1_CMD_WRITE_IO, val, 4);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\n\t\t \n\t\tval[0] = 0x00;\n\t\tsnd_usb_caiaq_send_command(cdev, EP1_CMD_WRITE_IO, val, 1);\n\t\tbreak;\n\tcase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):\n\t\t \n\t\tcdev->control_state[0] = 0xff;\n\t\tsnd_usb_caiaq_set_auto_msg(cdev, 1, 0, 0);\n\t\tsnd_usb_caiaq_send_command(cdev, EP1_CMD_READ_IO, NULL, 0);\n\n\t\tif (!wait_event_timeout(cdev->ep1_wait_queue,\n\t\t\t\t\tcdev->control_state[0] != 0xff, HZ))\n\t\t\treturn;\n\n\t\t \n\t\tif ((cdev->control_state[1] != 2) ||\n\t\t    (cdev->control_state[2] != 3) ||\n\t\t    (cdev->control_state[4] != 2)) {\n\t\t\tcdev->control_state[1] = 2;\n\t\t\tcdev->control_state[2] = 3;\n\t\t\tcdev->control_state[4] = 2;\n\t\t\tsnd_usb_caiaq_send_command(cdev,\n\t\t\t\tEP1_CMD_WRITE_IO, cdev->control_state, 6);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (cdev->spec.num_analog_audio_out +\n\t    cdev->spec.num_analog_audio_in +\n\t    cdev->spec.num_digital_audio_out +\n\t    cdev->spec.num_digital_audio_in > 0) {\n\t\tret = snd_usb_caiaq_audio_init(cdev);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"Unable to set up audio system (ret=%d)\\n\", ret);\n\t}\n\n\tif (cdev->spec.num_midi_in +\n\t    cdev->spec.num_midi_out > 0) {\n\t\tret = snd_usb_caiaq_midi_init(cdev);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"Unable to set up MIDI system (ret=%d)\\n\", ret);\n\t}\n\n#ifdef CONFIG_SND_USB_CAIAQ_INPUT\n\tret = snd_usb_caiaq_input_init(cdev);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Unable to set up input system (ret=%d)\\n\", ret);\n#endif\n\n\t \n\tret = snd_card_register(cdev->chip.card);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"snd_card_register() returned %d\\n\", ret);\n\t\tsnd_card_free(cdev->chip.card);\n\t}\n\n\tret = snd_usb_caiaq_control_init(cdev);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Unable to set up control system (ret=%d)\\n\", ret);\n}\n\nstatic int create_card(struct usb_device *usb_dev,\n\t\t       struct usb_interface *intf,\n\t\t       struct snd_card **cardp)\n{\n\tint devnum;\n\tint err;\n\tstruct snd_card *card;\n\tstruct snd_usb_caiaqdev *cdev;\n\n\tfor (devnum = 0; devnum < SNDRV_CARDS; devnum++)\n\t\tif (enable[devnum])\n\t\t\tbreak;\n\n\tif (devnum >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\terr = snd_card_new(&intf->dev,\n\t\t\t   index[devnum], id[devnum], THIS_MODULE,\n\t\t\t   sizeof(struct snd_usb_caiaqdev), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tcdev = caiaqdev(card);\n\tcdev->chip.dev = usb_dev;\n\tcdev->chip.card = card;\n\tcdev->chip.usb_id = USB_ID(le16_to_cpu(usb_dev->descriptor.idVendor),\n\t\t\t\t  le16_to_cpu(usb_dev->descriptor.idProduct));\n\tspin_lock_init(&cdev->spinlock);\n\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int init_card(struct snd_usb_caiaqdev *cdev)\n{\n\tchar *c, usbpath[32];\n\tstruct usb_device *usb_dev = cdev->chip.dev;\n\tstruct snd_card *card = cdev->chip.card;\n\tstruct device *dev = caiaqdev_to_dev(cdev);\n\tint err, len;\n\n\tif (usb_set_interface(usb_dev, 0, 1) != 0) {\n\t\tdev_err(dev, \"can't set alt interface.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tusb_init_urb(&cdev->ep1_in_urb);\n\tusb_init_urb(&cdev->midi_out_urb);\n\n\tusb_fill_bulk_urb(&cdev->ep1_in_urb, usb_dev,\n\t\t\t  usb_rcvbulkpipe(usb_dev, 0x1),\n\t\t\t  cdev->ep1_in_buf, EP1_BUFSIZE,\n\t\t\t  usb_ep1_command_reply_dispatch, cdev);\n\n\tusb_fill_bulk_urb(&cdev->midi_out_urb, usb_dev,\n\t\t\t  usb_sndbulkpipe(usb_dev, 0x1),\n\t\t\t  cdev->midi_out_buf, EP1_BUFSIZE,\n\t\t\t  snd_usb_caiaq_midi_output_done, cdev);\n\n\t \n\tif (usb_urb_ep_type_check(&cdev->ep1_in_urb) ||\n\t    usb_urb_ep_type_check(&cdev->midi_out_urb)) {\n\t\tdev_err(dev, \"invalid EPs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinit_waitqueue_head(&cdev->ep1_wait_queue);\n\tinit_waitqueue_head(&cdev->prepare_wait_queue);\n\n\tif (usb_submit_urb(&cdev->ep1_in_urb, GFP_KERNEL) != 0)\n\t\treturn -EIO;\n\n\terr = snd_usb_caiaq_send_command(cdev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);\n\tif (err)\n\t\tgoto err_kill_urb;\n\n\tif (!wait_event_timeout(cdev->ep1_wait_queue, cdev->spec_received, HZ)) {\n\t\terr = -ENODEV;\n\t\tgoto err_kill_urb;\n\t}\n\n\tusb_string(usb_dev, usb_dev->descriptor.iManufacturer,\n\t\t   cdev->vendor_name, CAIAQ_USB_STR_LEN);\n\n\tusb_string(usb_dev, usb_dev->descriptor.iProduct,\n\t\t   cdev->product_name, CAIAQ_USB_STR_LEN);\n\n\tstrscpy(card->driver, MODNAME, sizeof(card->driver));\n\tstrscpy(card->shortname, cdev->product_name, sizeof(card->shortname));\n\tstrscpy(card->mixername, cdev->product_name, sizeof(card->mixername));\n\n\t \n\n\tif (*card->id == '\\0') {\n\t\tchar id[sizeof(card->id)];\n\n\t\tmemset(id, 0, sizeof(id));\n\n\t\tfor (c = card->shortname, len = 0;\n\t\t\t*c && len < sizeof(card->id); c++)\n\t\t\tif (*c != ' ')\n\t\t\t\tid[len++] = *c;\n\n\t\tsnd_card_set_id(card, id);\n\t}\n\n\tusb_make_path(usb_dev, usbpath, sizeof(usbpath));\n\tscnprintf(card->longname, sizeof(card->longname), \"%s %s (%s)\",\n\t\t       cdev->vendor_name, cdev->product_name, usbpath);\n\n\tsetup_card(cdev);\n\treturn 0;\n\n err_kill_urb:\n\tusb_kill_urb(&cdev->ep1_in_urb);\n\treturn err;\n}\n\nstatic int snd_probe(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tint ret;\n\tstruct snd_card *card = NULL;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\n\tret = create_card(usb_dev, intf, &card);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusb_set_intfdata(intf, card);\n\tret = init_card(caiaqdev(card));\n\tif (ret < 0) {\n\t\tdev_err(&usb_dev->dev, \"unable to init card! (ret=%d)\\n\", ret);\n\t\tsnd_card_free(card);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_card *card = usb_get_intfdata(intf);\n\tstruct device *dev = intf->usb_dev;\n\tstruct snd_usb_caiaqdev *cdev;\n\n\tif (!card)\n\t\treturn;\n\n\tcdev = caiaqdev(card);\n\tdev_dbg(dev, \"%s(%p)\\n\", __func__, intf);\n\n\tsnd_card_disconnect(card);\n\n#ifdef CONFIG_SND_USB_CAIAQ_INPUT\n\tsnd_usb_caiaq_input_free(cdev);\n#endif\n\tsnd_usb_caiaq_audio_free(cdev);\n\n\tusb_kill_urb(&cdev->ep1_in_urb);\n\tusb_kill_urb(&cdev->midi_out_urb);\n\n\tsnd_card_free(card);\n\tusb_reset_device(interface_to_usbdev(intf));\n}\n\n\nMODULE_DEVICE_TABLE(usb, snd_usb_id_table);\nstatic struct usb_driver snd_usb_driver = {\n\t.name \t\t= MODNAME,\n\t.probe \t\t= snd_probe,\n\t.disconnect\t= snd_disconnect,\n\t.id_table \t= snd_usb_id_table,\n};\n\nmodule_usb_driver(snd_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}