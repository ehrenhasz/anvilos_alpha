{
  "module_name": "stream.c",
  "hash_id": "c19d3f5e08b1c33b56c68e94244ab04c80120c51dcbc779cbb255aade38bcf0a",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/stream.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"pcm.h\"\n#include \"helper.h\"\n#include \"format.h\"\n#include \"clock.h\"\n#include \"stream.h\"\n#include \"power.h\"\n#include \"media.h\"\n\nstatic void audioformat_free(struct audioformat *fp)\n{\n\tlist_del(&fp->list);  \n\tkfree(fp->rate_table);\n\tkfree(fp->chmap);\n\tkfree(fp);\n}\n\n \nstatic void free_substream(struct snd_usb_substream *subs)\n{\n\tstruct audioformat *fp, *n;\n\n\tif (!subs->num_formats)\n\t\treturn;  \n\tlist_for_each_entry_safe(fp, n, &subs->fmt_list, list)\n\t\taudioformat_free(fp);\n\tkfree(subs->str_pd);\n\tsnd_media_stream_delete(subs);\n}\n\n\n \nstatic void snd_usb_audio_stream_free(struct snd_usb_stream *stream)\n{\n\tfree_substream(&stream->substream[0]);\n\tfree_substream(&stream->substream[1]);\n\tlist_del(&stream->list);\n\tkfree(stream);\n}\n\nstatic void snd_usb_audio_pcm_free(struct snd_pcm *pcm)\n{\n\tstruct snd_usb_stream *stream = pcm->private_data;\n\tif (stream) {\n\t\tstream->pcm = NULL;\n\t\tsnd_usb_audio_stream_free(stream);\n\t}\n}\n\n \n\nstatic void snd_usb_init_substream(struct snd_usb_stream *as,\n\t\t\t\t   int stream,\n\t\t\t\t   struct audioformat *fp,\n\t\t\t\t   struct snd_usb_power_domain *pd)\n{\n\tstruct snd_usb_substream *subs = &as->substream[stream];\n\n\tINIT_LIST_HEAD(&subs->fmt_list);\n\tspin_lock_init(&subs->lock);\n\n\tsubs->stream = as;\n\tsubs->direction = stream;\n\tsubs->dev = as->chip->dev;\n\tsubs->txfr_quirk = !!(as->chip->quirk_flags & QUIRK_FLAG_ALIGN_TRANSFER);\n\tsubs->tx_length_quirk = !!(as->chip->quirk_flags & QUIRK_FLAG_TX_LENGTH);\n\tsubs->speed = snd_usb_get_speed(subs->dev);\n\tsubs->pkt_offset_adj = 0;\n\tsubs->stream_offset_adj = 0;\n\n\tsnd_usb_set_pcm_ops(as->pcm, stream);\n\n\tlist_add_tail(&fp->list, &subs->fmt_list);\n\tsubs->formats |= fp->formats;\n\tsubs->num_formats++;\n\tsubs->fmt_type = fp->fmt_type;\n\tsubs->ep_num = fp->endpoint;\n\tif (fp->channels > subs->channels_max)\n\t\tsubs->channels_max = fp->channels;\n\n\tif (pd) {\n\t\tsubs->str_pd = pd;\n\t\t \n\t\tsnd_usb_power_domain_set(subs->stream->chip, pd,\n\t\t\t\t\t UAC3_PD_STATE_D1);\n\t}\n\n\tsnd_usb_preallocate_buffer(subs);\n}\n\n \nstatic int usb_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_substream *subs = info->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = subs->channels_max;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\n \nstatic bool have_dup_chmap(struct snd_usb_substream *subs,\n\t\t\t   struct audioformat *fp)\n{\n\tstruct audioformat *prev = fp;\n\n\tlist_for_each_entry_continue_reverse(prev, &subs->fmt_list, list) {\n\t\tif (prev->chmap &&\n\t\t    !memcmp(prev->chmap, fp->chmap, sizeof(*fp->chmap)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int usb_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t     unsigned int size, unsigned int __user *tlv)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_substream *subs = info->private_data;\n\tstruct audioformat *fp;\n\tunsigned int __user *dst;\n\tint count = 0;\n\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tint i, ch_bytes;\n\n\t\tif (!fp->chmap)\n\t\t\tcontinue;\n\t\tif (have_dup_chmap(subs, fp))\n\t\t\tcontinue;\n\t\t \n\t\tch_bytes = fp->chmap->channels * 4;\n\t\tif (size < 8 + ch_bytes)\n\t\t\treturn -ENOMEM;\n\t\tif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\n\t\t    put_user(ch_bytes, dst + 1))\n\t\t\treturn -EFAULT;\n\t\tdst += 2;\n\t\tfor (i = 0; i < fp->chmap->channels; i++, dst++) {\n\t\t\tif (put_user(fp->chmap->map[i], dst))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcount += 8 + ch_bytes;\n\t\tsize -= 8 + ch_bytes;\n\t}\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int usb_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_substream *subs = info->private_data;\n\tstruct snd_pcm_chmap_elem *chmap = NULL;\n\tint i = 0;\n\n\tif (subs->cur_audiofmt)\n\t\tchmap = subs->cur_audiofmt->chmap;\n\tif (chmap) {\n\t\tfor (i = 0; i < chmap->channels; i++)\n\t\t\tucontrol->value.integer.value[i] = chmap->map[i];\n\t}\n\tfor (; i < subs->channels_max; i++)\n\t\tucontrol->value.integer.value[i] = 0;\n\treturn 0;\n}\n\n \nstatic int add_chmap(struct snd_pcm *pcm, int stream,\n\t\t     struct snd_usb_substream *subs)\n{\n\tstruct audioformat *fp;\n\tstruct snd_pcm_chmap *chmap;\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\tlist_for_each_entry(fp, &subs->fmt_list, list)\n\t\tif (fp->chmap)\n\t\t\tgoto ok;\n\t \n\treturn 0;\n\n ok:\n\terr = snd_pcm_add_chmap_ctls(pcm, stream, NULL, 0, 0, &chmap);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tchmap->private_data = subs;\n\tkctl = chmap->kctl;\n\tkctl->info = usb_chmap_ctl_info;\n\tkctl->get = usb_chmap_ctl_get;\n\tkctl->tlv.c = usb_chmap_ctl_tlv;\n\n\treturn 0;\n}\n\n \nstatic struct snd_pcm_chmap_elem *convert_chmap(int channels, unsigned int bits,\n\t\t\t\t\t\tint protocol)\n{\n\tstatic const unsigned int uac1_maps[] = {\n\t\tSNDRV_CHMAP_FL,\t\t \n\t\tSNDRV_CHMAP_FR,\t\t \n\t\tSNDRV_CHMAP_FC,\t\t \n\t\tSNDRV_CHMAP_LFE,\t \n\t\tSNDRV_CHMAP_SL,\t\t \n\t\tSNDRV_CHMAP_SR,\t\t \n\t\tSNDRV_CHMAP_FLC,\t \n\t\tSNDRV_CHMAP_FRC,\t \n\t\tSNDRV_CHMAP_RC,\t\t \n\t\tSNDRV_CHMAP_SL,\t\t \n\t\tSNDRV_CHMAP_SR,\t\t \n\t\tSNDRV_CHMAP_TC,\t\t \n\t\t0  \n\t};\n\tstatic const unsigned int uac2_maps[] = {\n\t\tSNDRV_CHMAP_FL,\t\t \n\t\tSNDRV_CHMAP_FR,\t\t \n\t\tSNDRV_CHMAP_FC,\t\t \n\t\tSNDRV_CHMAP_LFE,\t \n\t\tSNDRV_CHMAP_RL,\t\t \n\t\tSNDRV_CHMAP_RR,\t\t \n\t\tSNDRV_CHMAP_FLC,\t \n\t\tSNDRV_CHMAP_FRC,\t \n\t\tSNDRV_CHMAP_RC,\t\t \n\t\tSNDRV_CHMAP_SL,\t\t \n\t\tSNDRV_CHMAP_SR,\t\t \n\t\tSNDRV_CHMAP_TC,\t\t \n\t\tSNDRV_CHMAP_TFL,\t \n\t\tSNDRV_CHMAP_TFC,\t \n\t\tSNDRV_CHMAP_TFR,\t \n\t\tSNDRV_CHMAP_TRL,\t \n\t\tSNDRV_CHMAP_TRC,\t \n\t\tSNDRV_CHMAP_TRR,\t \n\t\tSNDRV_CHMAP_TFLC,\t \n\t\tSNDRV_CHMAP_TFRC,\t \n\t\tSNDRV_CHMAP_LLFE,\t \n\t\tSNDRV_CHMAP_RLFE,\t \n\t\tSNDRV_CHMAP_TSL,\t \n\t\tSNDRV_CHMAP_TSR,\t \n\t\tSNDRV_CHMAP_BC,\t\t \n\t\tSNDRV_CHMAP_RLC,\t \n\t\tSNDRV_CHMAP_RRC,\t \n\t\t0  \n\t};\n\tstruct snd_pcm_chmap_elem *chmap;\n\tconst unsigned int *maps;\n\tint c;\n\n\tif (channels > ARRAY_SIZE(chmap->map))\n\t\treturn NULL;\n\n\tchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\n\tif (!chmap)\n\t\treturn NULL;\n\n\tmaps = protocol == UAC_VERSION_2 ? uac2_maps : uac1_maps;\n\tchmap->channels = channels;\n\tc = 0;\n\n\tif (bits) {\n\t\tfor (; bits && *maps; maps++, bits >>= 1)\n\t\t\tif (bits & 1)\n\t\t\t\tchmap->map[c++] = *maps;\n\t} else {\n\t\t \n\t\tif (channels == 1)\n\t\t\tchmap->map[c++] = SNDRV_CHMAP_MONO;\n\t\telse\n\t\t\tfor (; c < channels && *maps; maps++)\n\t\t\t\tchmap->map[c++] = *maps;\n\t}\n\n\tfor (; c < channels; c++)\n\t\tchmap->map[c] = SNDRV_CHMAP_UNKNOWN;\n\n\treturn chmap;\n}\n\n \nstatic struct\nsnd_pcm_chmap_elem *convert_chmap_v3(struct uac3_cluster_header_descriptor\n\t\t\t\t\t\t\t\t*cluster)\n{\n\tunsigned int channels = cluster->bNrChannels;\n\tstruct snd_pcm_chmap_elem *chmap;\n\tvoid *p = cluster;\n\tint len, c;\n\n\tif (channels > ARRAY_SIZE(chmap->map))\n\t\treturn NULL;\n\n\tchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\n\tif (!chmap)\n\t\treturn NULL;\n\n\tlen = le16_to_cpu(cluster->wLength);\n\tc = 0;\n\tp += sizeof(struct uac3_cluster_header_descriptor);\n\n\twhile (((p - (void *)cluster) < len) && (c < channels)) {\n\t\tstruct uac3_cluster_segment_descriptor *cs_desc = p;\n\t\tu16 cs_len;\n\t\tu8 cs_type;\n\n\t\tcs_len = le16_to_cpu(cs_desc->wLength);\n\t\tcs_type = cs_desc->bSegmentType;\n\n\t\tif (cs_type == UAC3_CHANNEL_INFORMATION) {\n\t\t\tstruct uac3_cluster_information_segment_descriptor *is = p;\n\t\t\tunsigned char map;\n\n\t\t\t \n\t\t\tswitch (is->bChRelationship) {\n\t\t\tcase UAC3_CH_MONO:\n\t\t\t\tmap = SNDRV_CHMAP_MONO;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_LEFT:\n\t\t\tcase UAC3_CH_FRONT_LEFT:\n\t\t\tcase UAC3_CH_HEADPHONE_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_FL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_RIGHT:\n\t\t\tcase UAC3_CH_FRONT_RIGHT:\n\t\t\tcase UAC3_CH_HEADPHONE_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_FR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_FRONT_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_FC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_FRONT_LEFT_OF_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_FLC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_FRONT_RIGHT_OF_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_FRC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_SIDE_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_SL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_SIDE_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_SR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BACK_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_RL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BACK_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_RR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BACK_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_RC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BACK_LEFT_OF_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_RLC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BACK_RIGHT_OF_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_RRC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_TC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_FRONT_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_TFL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_FRONT_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_TFR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_FRONT_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_TFC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_FRONT_LOC:\n\t\t\t\tmap = SNDRV_CHMAP_TFLC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_FRONT_ROC:\n\t\t\t\tmap = SNDRV_CHMAP_TFRC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_SIDE_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_TSL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_SIDE_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_TSR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_BACK_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_TRL;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_BACK_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_TRR;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_TOP_BACK_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_TRC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_BOTTOM_CENTER:\n\t\t\t\tmap = SNDRV_CHMAP_BC;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_LOW_FREQUENCY_EFFECTS:\n\t\t\t\tmap = SNDRV_CHMAP_LFE;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_LFE_LEFT:\n\t\t\t\tmap = SNDRV_CHMAP_LLFE;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_LFE_RIGHT:\n\t\t\t\tmap = SNDRV_CHMAP_RLFE;\n\t\t\t\tbreak;\n\t\t\tcase UAC3_CH_RELATIONSHIP_UNDEFINED:\n\t\t\tdefault:\n\t\t\t\tmap = SNDRV_CHMAP_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchmap->map[c++] = map;\n\t\t}\n\t\tp += cs_len;\n\t}\n\n\tif (channels < c)\n\t\tpr_err(\"%s: channel number mismatch\\n\", __func__);\n\n\tchmap->channels = channels;\n\n\tfor (; c < channels; c++)\n\t\tchmap->map[c] = SNDRV_CHMAP_UNKNOWN;\n\n\treturn chmap;\n}\n\n \nstatic int __snd_usb_add_audio_stream(struct snd_usb_audio *chip,\n\t\t\t\t      int stream,\n\t\t\t\t      struct audioformat *fp,\n\t\t\t\t      struct snd_usb_power_domain *pd)\n\n{\n\tstruct snd_usb_stream *as;\n\tstruct snd_usb_substream *subs;\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\tif (as->fmt_type != fp->fmt_type)\n\t\t\tcontinue;\n\t\tsubs = &as->substream[stream];\n\t\tif (subs->ep_num == fp->endpoint) {\n\t\t\tlist_add_tail(&fp->list, &subs->fmt_list);\n\t\t\tsubs->num_formats++;\n\t\t\tsubs->formats |= fp->formats;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (chip->card->registered)\n\t\tchip->need_delayed_register = true;\n\n\t \n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\tif (as->fmt_type != fp->fmt_type)\n\t\t\tcontinue;\n\t\tsubs = &as->substream[stream];\n\t\tif (subs->ep_num)\n\t\t\tcontinue;\n\t\terr = snd_pcm_new_stream(as->pcm, stream, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_usb_init_substream(as, stream, fp, pd);\n\t\treturn add_chmap(as->pcm, stream, subs);\n\t}\n\n\t \n\tas = kzalloc(sizeof(*as), GFP_KERNEL);\n\tif (!as)\n\t\treturn -ENOMEM;\n\tas->pcm_index = chip->pcm_devs;\n\tas->chip = chip;\n\tas->fmt_type = fp->fmt_type;\n\terr = snd_pcm_new(chip->card, \"USB Audio\", chip->pcm_devs,\n\t\t\t  stream == SNDRV_PCM_STREAM_PLAYBACK ? 1 : 0,\n\t\t\t  stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1,\n\t\t\t  &pcm);\n\tif (err < 0) {\n\t\tkfree(as);\n\t\treturn err;\n\t}\n\tas->pcm = pcm;\n\tpcm->private_data = as;\n\tpcm->private_free = snd_usb_audio_pcm_free;\n\tpcm->info_flags = 0;\n\tif (chip->pcm_devs > 0)\n\t\tsprintf(pcm->name, \"USB Audio #%d\", chip->pcm_devs);\n\telse\n\t\tstrcpy(pcm->name, \"USB Audio\");\n\n\tsnd_usb_init_substream(as, stream, fp, pd);\n\n\t \n\tif (chip->usb_id == USB_ID(0x0763, 0x2003))\n\t\tlist_add(&as->list, &chip->pcm_list);\n\telse\n\t\tlist_add_tail(&as->list, &chip->pcm_list);\n\n\tchip->pcm_devs++;\n\n\tsnd_usb_proc_pcm_format_add(as);\n\n\treturn add_chmap(pcm, stream, &as->substream[stream]);\n}\n\nint snd_usb_add_audio_stream(struct snd_usb_audio *chip,\n\t\t\t     int stream,\n\t\t\t     struct audioformat *fp)\n{\n\treturn __snd_usb_add_audio_stream(chip, stream, fp, NULL);\n}\n\nstatic int snd_usb_add_audio_stream_v3(struct snd_usb_audio *chip,\n\t\t\t\t       int stream,\n\t\t\t\t       struct audioformat *fp,\n\t\t\t\t       struct snd_usb_power_domain *pd)\n{\n\treturn __snd_usb_add_audio_stream(chip, stream, fp, pd);\n}\n\nstatic int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,\n\t\t\t\t\t struct usb_host_interface *alts,\n\t\t\t\t\t int protocol, int iface_no)\n{\n\t \n\tstruct uac_iso_endpoint_descriptor *csep;\n\tstruct usb_interface_descriptor *altsd = get_iface_desc(alts);\n\tint attributes = 0;\n\n\tcsep = snd_usb_find_desc(alts->endpoint[0].extra, alts->endpoint[0].extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\t \n\tif (!csep && altsd->bNumEndpoints >= 2)\n\t\tcsep = snd_usb_find_desc(alts->endpoint[1].extra, alts->endpoint[1].extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\t \n\tif (!csep)\n\t\tcsep = snd_usb_find_desc(alts->extra, alts->extralen, NULL, USB_DT_CS_ENDPOINT);\n\n\tif (!csep || csep->bLength < 7 ||\n\t    csep->bDescriptorSubtype != UAC_EP_GENERAL)\n\t\tgoto error;\n\n\tif (protocol == UAC_VERSION_1) {\n\t\tattributes = csep->bmAttributes;\n\t} else if (protocol == UAC_VERSION_2) {\n\t\tstruct uac2_iso_endpoint_descriptor *csep2 =\n\t\t\t(struct uac2_iso_endpoint_descriptor *) csep;\n\n\t\tif (csep2->bLength < sizeof(*csep2))\n\t\t\tgoto error;\n\t\tattributes = csep->bmAttributes & UAC_EP_CS_ATTR_FILL_MAX;\n\n\t\t \n\t\tif (csep2->bmControls & UAC2_CONTROL_PITCH)\n\t\t\tattributes |= UAC_EP_CS_ATTR_PITCH_CONTROL;\n\t} else {  \n\t\tstruct uac3_iso_endpoint_descriptor *csep3 =\n\t\t\t(struct uac3_iso_endpoint_descriptor *) csep;\n\n\t\tif (csep3->bLength < sizeof(*csep3))\n\t\t\tgoto error;\n\t\t \n\t\tif (le32_to_cpu(csep3->bmControls) & UAC2_CONTROL_PITCH)\n\t\t\tattributes |= UAC_EP_CS_ATTR_PITCH_CONTROL;\n\t}\n\n\treturn attributes;\n\n error:\n\tusb_audio_warn(chip,\n\t\t       \"%u:%d : no or invalid class specific endpoint descriptor\\n\",\n\t\t       iface_no, altsd->bAlternateSetting);\n\treturn 0;\n}\n\n \nstatic void *\nsnd_usb_find_input_terminal_descriptor(struct usb_host_interface *ctrl_iface,\n\t\t\t\t       int terminal_id, int protocol)\n{\n\tstruct uac2_input_terminal_descriptor *term = NULL;\n\n\twhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\n\t\t\t\t\t       ctrl_iface->extralen,\n\t\t\t\t\t       term, UAC_INPUT_TERMINAL))) {\n\t\tif (!snd_usb_validate_audio_desc(term, protocol))\n\t\t\tcontinue;\n\t\tif (term->bTerminalID == terminal_id)\n\t\t\treturn term;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *\nsnd_usb_find_output_terminal_descriptor(struct usb_host_interface *ctrl_iface,\n\t\t\t\t\tint terminal_id, int protocol)\n{\n\t \n\tstruct uac2_output_terminal_descriptor *term = NULL;\n\n\twhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\n\t\t\t\t\t       ctrl_iface->extralen,\n\t\t\t\t\t       term, UAC_OUTPUT_TERMINAL))) {\n\t\tif (!snd_usb_validate_audio_desc(term, protocol))\n\t\t\tcontinue;\n\t\tif (term->bTerminalID == terminal_id)\n\t\t\treturn term;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct audioformat *\naudio_format_alloc_init(struct snd_usb_audio *chip,\n\t\t       struct usb_host_interface *alts,\n\t\t       int protocol, int iface_no, int altset_idx,\n\t\t       int altno, int num_channels, int clock)\n{\n\tstruct audioformat *fp;\n\n\tfp = kzalloc(sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn NULL;\n\n\tfp->iface = iface_no;\n\tfp->altsetting = altno;\n\tfp->altset_idx = altset_idx;\n\tfp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;\n\tfp->ep_attr = get_endpoint(alts, 0)->bmAttributes;\n\tfp->datainterval = snd_usb_parse_datainterval(chip, alts);\n\tfp->protocol = protocol;\n\tfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\tfp->channels = num_channels;\n\tif (snd_usb_get_speed(chip->dev) == USB_SPEED_HIGH)\n\t\tfp->maxpacksize = (((fp->maxpacksize >> 11) & 3) + 1)\n\t\t\t\t* (fp->maxpacksize & 0x7ff);\n\tfp->clock = clock;\n\tINIT_LIST_HEAD(&fp->list);\n\n\treturn fp;\n}\n\nstatic struct audioformat *\nsnd_usb_get_audioformat_uac12(struct snd_usb_audio *chip,\n\t\t\t      struct usb_host_interface *alts,\n\t\t\t      int protocol, int iface_no, int altset_idx,\n\t\t\t      int altno, int stream, int bm_quirk)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct uac_format_type_i_continuous_descriptor *fmt;\n\tunsigned int num_channels = 0, chconfig = 0;\n\tstruct audioformat *fp;\n\tint clock = 0;\n\tu64 format;\n\n\t \n\tif (protocol == UAC_VERSION_1) {\n\t\tstruct uac1_as_header_descriptor *as =\n\t\t\tsnd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t\t\tNULL, UAC_AS_GENERAL);\n\t\tstruct uac_input_terminal_descriptor *iterm;\n\n\t\tif (!as) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d : UAC_AS_GENERAL descriptor not found\\n\",\n\t\t\t\tiface_no, altno);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (as->bLength < sizeof(*as)) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d : invalid UAC_AS_GENERAL desc\\n\",\n\t\t\t\tiface_no, altno);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tformat = le16_to_cpu(as->wFormatTag);  \n\n\t\titerm = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t       as->bTerminalLink,\n\t\t\t\t\t\t\t       protocol);\n\t\tif (iterm) {\n\t\t\tnum_channels = iterm->bNrChannels;\n\t\t\tchconfig = le16_to_cpu(iterm->wChannelConfig);\n\t\t}\n\t} else {  \n\t\tstruct uac2_input_terminal_descriptor *input_term;\n\t\tstruct uac2_output_terminal_descriptor *output_term;\n\t\tstruct uac2_as_header_descriptor *as =\n\t\t\tsnd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t\t\tNULL, UAC_AS_GENERAL);\n\n\t\tif (!as) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d : UAC_AS_GENERAL descriptor not found\\n\",\n\t\t\t\tiface_no, altno);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (as->bLength < sizeof(*as)) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d : invalid UAC_AS_GENERAL desc\\n\",\n\t\t\t\tiface_no, altno);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnum_channels = as->bNrChannels;\n\t\tformat = le32_to_cpu(as->bmFormats);\n\t\tchconfig = le32_to_cpu(as->bmChannelConfig);\n\n\t\t \n\t\tinput_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t\t    as->bTerminalLink,\n\t\t\t\t\t\t\t\t    protocol);\n\t\tif (input_term) {\n\t\t\tclock = input_term->bCSourceID;\n\t\t\tif (!chconfig && (num_channels == input_term->bNrChannels))\n\t\t\t\tchconfig = le32_to_cpu(input_term->bmChannelConfig);\n\t\t\tgoto found_clock;\n\t\t}\n\n\t\toutput_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t\t      as->bTerminalLink,\n\t\t\t\t\t\t\t\t      protocol);\n\t\tif (output_term) {\n\t\t\tclock = output_term->bCSourceID;\n\t\t\tgoto found_clock;\n\t\t}\n\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : bogus bTerminalLink %d\\n\",\n\t\t\tiface_no, altno, as->bTerminalLink);\n\t\treturn NULL;\n\t}\n\nfound_clock:\n\t \n\tfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t      NULL, UAC_FORMAT_TYPE);\n\tif (!fmt) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : no UAC_FORMAT_TYPE desc\\n\",\n\t\t\tiface_no, altno);\n\t\treturn NULL;\n\t}\n\tif (((protocol == UAC_VERSION_1) && (fmt->bLength < 8))\n\t\t\t|| ((protocol == UAC_VERSION_2) &&\n\t\t\t\t\t(fmt->bLength < 6))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : invalid UAC_FORMAT_TYPE desc\\n\",\n\t\t\tiface_no, altno);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (bm_quirk && fmt->bNrChannels == 1 && fmt->bSubframeSize == 2)\n\t\treturn NULL;\n\n\tfp = audio_format_alloc_init(chip, alts, protocol, iface_no,\n\t\t\t\t     altset_idx, altno, num_channels, clock);\n\tif (!fp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfp->attributes = parse_uac_endpoint_attributes(chip, alts, protocol,\n\t\t\t\t\t\t       iface_no);\n\n\t \n\tsnd_usb_audioformat_attributes_quirk(chip, fp, stream);\n\n\t \n\tif (snd_usb_parse_audio_format(chip, fp, format,\n\t\t\t\t\tfmt, stream) < 0) {\n\t\taudioformat_free(fp);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (fp->channels != num_channels)\n\t\tchconfig = 0;\n\n\tfp->chmap = convert_chmap(fp->channels, chconfig, protocol);\n\n\treturn fp;\n}\n\nstatic struct audioformat *\nsnd_usb_get_audioformat_uac3(struct snd_usb_audio *chip,\n\t\t\t     struct usb_host_interface *alts,\n\t\t\t     struct snd_usb_power_domain **pd_out,\n\t\t\t     int iface_no, int altset_idx,\n\t\t\t     int altno, int stream)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct uac3_input_terminal_descriptor *input_term;\n\tstruct uac3_output_terminal_descriptor *output_term;\n\tstruct uac3_cluster_header_descriptor *cluster;\n\tstruct uac3_as_header_descriptor *as = NULL;\n\tstruct uac3_hc_descriptor_header hc_header;\n\tstruct snd_pcm_chmap_elem *chmap;\n\tstruct snd_usb_power_domain *pd;\n\tunsigned char badd_profile;\n\tu64 badd_formats = 0;\n\tunsigned int num_channels;\n\tstruct audioformat *fp;\n\tu16 cluster_id, wLength;\n\tint clock = 0;\n\tint err;\n\n\tbadd_profile = chip->badd_profile;\n\n\tif (badd_profile >= UAC3_FUNCTION_SUBCLASS_GENERIC_IO) {\n\t\tunsigned int maxpacksize =\n\t\t\tle16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\n\t\tswitch (maxpacksize) {\n\t\tdefault:\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d : incorrect wMaxPacketSize for BADD profile\\n\",\n\t\t\t\tiface_no, altno);\n\t\t\treturn NULL;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_MONO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_MONO_16:\n\t\t\tbadd_formats = SNDRV_PCM_FMTBIT_S16_LE;\n\t\t\tnum_channels = 1;\n\t\t\tbreak;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_MONO_24:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_MONO_24:\n\t\t\tbadd_formats = SNDRV_PCM_FMTBIT_S24_3LE;\n\t\t\tnum_channels = 1;\n\t\t\tbreak;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_STEREO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_STEREO_16:\n\t\t\tbadd_formats = SNDRV_PCM_FMTBIT_S16_LE;\n\t\t\tnum_channels = 2;\n\t\t\tbreak;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_STEREO_24:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_STEREO_24:\n\t\t\tbadd_formats = SNDRV_PCM_FMTBIT_S24_3LE;\n\t\t\tnum_channels = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\n\t\tif (!chmap)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tif (num_channels == 1) {\n\t\t\tchmap->map[0] = SNDRV_CHMAP_MONO;\n\t\t} else {\n\t\t\tchmap->map[0] = SNDRV_CHMAP_FL;\n\t\t\tchmap->map[1] = SNDRV_CHMAP_FR;\n\t\t}\n\n\t\tchmap->channels = num_channels;\n\t\tclock = UAC3_BADD_CS_ID9;\n\t\tgoto found_clock;\n\t}\n\n\tas = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t     NULL, UAC_AS_GENERAL);\n\tif (!as) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : UAC_AS_GENERAL descriptor not found\\n\",\n\t\t\tiface_no, altno);\n\t\treturn NULL;\n\t}\n\n\tif (as->bLength < sizeof(*as)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : invalid UAC_AS_GENERAL desc\\n\",\n\t\t\tiface_no, altno);\n\t\treturn NULL;\n\t}\n\n\tcluster_id = le16_to_cpu(as->wClusterDescrID);\n\tif (!cluster_id) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : no cluster descriptor\\n\",\n\t\t\tiface_no, altno);\n\t\treturn NULL;\n\t}\n\n\t \n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_rcvctrlpipe(chip->dev, 0),\n\t\t\tUAC3_CS_REQ_HIGH_CAPABILITY_DESCRIPTOR,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\tcluster_id,\n\t\t\tsnd_usb_ctrl_intf(chip),\n\t\t\t&hc_header, sizeof(hc_header));\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err != sizeof(hc_header)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : can't get High Capability descriptor\\n\",\n\t\t\tiface_no, altno);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\t \n\twLength = le16_to_cpu(hc_header.wLength);\n\tcluster = kzalloc(wLength, GFP_KERNEL);\n\tif (!cluster)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_rcvctrlpipe(chip->dev, 0),\n\t\t\tUAC3_CS_REQ_HIGH_CAPABILITY_DESCRIPTOR,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\tcluster_id,\n\t\t\tsnd_usb_ctrl_intf(chip),\n\t\t\tcluster, wLength);\n\tif (err < 0) {\n\t\tkfree(cluster);\n\t\treturn ERR_PTR(err);\n\t} else if (err != wLength) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%u:%d : can't get Cluster Descriptor\\n\",\n\t\t\tiface_no, altno);\n\t\tkfree(cluster);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tnum_channels = cluster->bNrChannels;\n\tchmap = convert_chmap_v3(cluster);\n\tkfree(cluster);\n\n\t \n\tinput_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t    as->bTerminalLink,\n\t\t\t\t\t\t\t    UAC_VERSION_3);\n\tif (input_term) {\n\t\tclock = input_term->bCSourceID;\n\t\tgoto found_clock;\n\t}\n\n\toutput_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,\n\t\t\t\t\t\t\t      as->bTerminalLink,\n\t\t\t\t\t\t\t      UAC_VERSION_3);\n\tif (output_term) {\n\t\tclock = output_term->bCSourceID;\n\t\tgoto found_clock;\n\t}\n\n\tdev_err(&dev->dev, \"%u:%d : bogus bTerminalLink %d\\n\",\n\t\t\tiface_no, altno, as->bTerminalLink);\n\tkfree(chmap);\n\treturn NULL;\n\nfound_clock:\n\tfp = audio_format_alloc_init(chip, alts, UAC_VERSION_3, iface_no,\n\t\t\t\t     altset_idx, altno, num_channels, clock);\n\tif (!fp) {\n\t\tkfree(chmap);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfp->chmap = chmap;\n\n\tif (badd_profile >= UAC3_FUNCTION_SUBCLASS_GENERIC_IO) {\n\t\tfp->attributes = 0;  \n\n\t\tfp->fmt_type = UAC_FORMAT_TYPE_I;\n\t\tfp->formats = badd_formats;\n\n\t\tfp->nr_rates = 0;\t \n\t\tfp->rate_min = UAC3_BADD_SAMPLING_RATE;\n\t\tfp->rate_max = UAC3_BADD_SAMPLING_RATE;\n\t\tfp->rates = SNDRV_PCM_RATE_CONTINUOUS;\n\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd) {\n\t\t\taudioformat_free(fp);\n\t\t\treturn NULL;\n\t\t}\n\t\tpd->pd_id = (stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\t\t\t\tUAC3_BADD_PD_ID10 : UAC3_BADD_PD_ID11;\n\t\tpd->pd_d1d0_rec = UAC3_BADD_PD_RECOVER_D1D0;\n\t\tpd->pd_d2d0_rec = UAC3_BADD_PD_RECOVER_D2D0;\n\n\t} else {\n\t\tfp->attributes = parse_uac_endpoint_attributes(chip, alts,\n\t\t\t\t\t\t\t       UAC_VERSION_3,\n\t\t\t\t\t\t\t       iface_no);\n\n\t\tpd = snd_usb_find_power_domain(chip->ctrl_intf,\n\t\t\t\t\t       as->bTerminalLink);\n\n\t\t \n\t\tif (snd_usb_parse_audio_format_v3(chip, fp, as, stream) < 0) {\n\t\t\tkfree(pd);\n\t\t\taudioformat_free(fp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pd)\n\t\t*pd_out = pd;\n\n\treturn fp;\n}\n\nstatic int __snd_usb_parse_audio_interface(struct snd_usb_audio *chip,\n\t\t\t\t\t   int iface_no,\n\t\t\t\t\t   bool *has_non_pcm, bool non_pcm)\n{\n\tstruct usb_device *dev;\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tint i, altno, err, stream;\n\tstruct audioformat *fp = NULL;\n\tstruct snd_usb_power_domain *pd = NULL;\n\tbool set_iface_first;\n\tint num, protocol;\n\n\tdev = chip->dev;\n\n\t \n\tiface = usb_ifnum_to_if(dev, iface_no);\n\n\tnum = iface->num_altsetting;\n\n\t \n\tif (chip->usb_id == USB_ID(0x04fa, 0x4201) && num >= 4)\n\t\tnum = 4;\n\n\tfor (i = 0; i < num; i++) {\n\t\talts = &iface->altsetting[i];\n\t\taltsd = get_iface_desc(alts);\n\t\tprotocol = altsd->bInterfaceProtocol;\n\t\t \n\t\tif (((altsd->bInterfaceClass != USB_CLASS_AUDIO ||\n\t\t      (altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING &&\n\t\t       altsd->bInterfaceSubClass != USB_SUBCLASS_VENDOR_SPEC)) &&\n\t\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t\t    altsd->bNumEndpoints < 1 ||\n\t\t    le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) == 0)\n\t\t\tcontinue;\n\t\t \n\t\tif ((get_endpoint(alts, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=\n\t\t    USB_ENDPOINT_XFER_ISOC)\n\t\t\tcontinue;\n\t\t \n\t\tstream = (get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN) ?\n\t\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\t\taltno = altsd->bAlternateSetting;\n\n\t\tif (snd_usb_apply_interface_quirk(chip, iface_no, altno))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (USB_ID_VENDOR(chip->usb_id) == 0x0582 &&\n\t\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t\t    protocol <= 2)\n\t\t\tprotocol = UAC_VERSION_1;\n\n\t\tswitch (protocol) {\n\t\tdefault:\n\t\t\tdev_dbg(&dev->dev, \"%u:%d: unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t\tiface_no, altno, protocol);\n\t\t\tprotocol = UAC_VERSION_1;\n\t\t\tfallthrough;\n\t\tcase UAC_VERSION_1:\n\t\tcase UAC_VERSION_2: {\n\t\t\tint bm_quirk = 0;\n\n\t\t\t \n\t\t\tif (altno == 2 && num == 3 &&\n\t\t\t    fp && fp->altsetting == 1 && fp->channels == 1 &&\n\t\t\t    fp->formats == SNDRV_PCM_FMTBIT_S16_LE &&\n\t\t\t    protocol == UAC_VERSION_1 &&\n\t\t\t    le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) ==\n\t\t\t\t\t\t\tfp->maxpacksize * 2)\n\t\t\t\tbm_quirk = 1;\n\n\t\t\tfp = snd_usb_get_audioformat_uac12(chip, alts, protocol,\n\t\t\t\t\t\t\t   iface_no, i, altno,\n\t\t\t\t\t\t\t   stream, bm_quirk);\n\t\t\tbreak;\n\t\t}\n\t\tcase UAC_VERSION_3:\n\t\t\tfp = snd_usb_get_audioformat_uac3(chip, alts, &pd,\n\t\t\t\t\t\tiface_no, i, altno, stream);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fp)\n\t\t\tcontinue;\n\t\telse if (IS_ERR(fp))\n\t\t\treturn PTR_ERR(fp);\n\n\t\tif (fp->fmt_type != UAC_FORMAT_TYPE_I)\n\t\t\t*has_non_pcm = true;\n\t\tif ((fp->fmt_type == UAC_FORMAT_TYPE_I) == non_pcm) {\n\t\t\taudioformat_free(fp);\n\t\t\tkfree(pd);\n\t\t\tfp = NULL;\n\t\t\tpd = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_usb_audioformat_set_sync_ep(chip, fp);\n\n\t\tdev_dbg(&dev->dev, \"%u:%d: add audio endpoint %#x\\n\", iface_no, altno, fp->endpoint);\n\t\tif (protocol == UAC_VERSION_3)\n\t\t\terr = snd_usb_add_audio_stream_v3(chip, stream, fp, pd);\n\t\telse\n\t\t\terr = snd_usb_add_audio_stream(chip, stream, fp);\n\n\t\tif (err < 0) {\n\t\t\taudioformat_free(fp);\n\t\t\tkfree(pd);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = snd_usb_add_endpoint(chip, fp->endpoint,\n\t\t\t\t\t   SND_USB_ENDPOINT_TYPE_DATA);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (fp->sync_ep) {\n\t\t\terr = snd_usb_add_endpoint(chip, fp->sync_ep,\n\t\t\t\t\t\t   fp->implicit_fb ?\n\t\t\t\t\t\t   SND_USB_ENDPOINT_TYPE_DATA :\n\t\t\t\t\t\t   SND_USB_ENDPOINT_TYPE_SYNC);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tset_iface_first = false;\n\t\tif (protocol == UAC_VERSION_1 ||\n\t\t    (chip->quirk_flags & QUIRK_FLAG_SET_IFACE_FIRST))\n\t\t\tset_iface_first = true;\n\n\t\t \n\t\tusb_set_interface(chip->dev, iface_no, 0);\n\t\tif (set_iface_first)\n\t\t\tusb_set_interface(chip->dev, iface_no, altno);\n\t\tsnd_usb_init_pitch(chip, fp);\n\t\tsnd_usb_init_sample_rate(chip, fp, fp->rate_max);\n\t\tif (!set_iface_first)\n\t\t\tusb_set_interface(chip->dev, iface_no, altno);\n\t}\n\treturn 0;\n}\n\nint snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)\n{\n\tint err;\n\tbool has_non_pcm = false;\n\n\t \n\terr = __snd_usb_parse_audio_interface(chip, iface_no, &has_non_pcm, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (has_non_pcm) {\n\t\t \n\t\terr = __snd_usb_parse_audio_interface(chip, iface_no, &has_non_pcm, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}