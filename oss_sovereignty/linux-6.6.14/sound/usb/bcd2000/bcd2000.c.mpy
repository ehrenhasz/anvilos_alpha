{
  "module_name": "bcd2000.c",
  "hash_id": "730467b562552418497b17a843b248f5d5a24652e6622c5d05eaf5ac6390eafd",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/bcd2000/bcd2000.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/bitmap.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n\n#define PREFIX \"snd-bcd2000: \"\n#define BUFSIZE 64\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x1397, 0x00bd) },\n\t{ },\n};\n\nstatic const unsigned char device_cmd_prefix[] = {0x03, 0x00};\n\nstatic const unsigned char bcd2000_init_sequence[] = {\n\t0x07, 0x00, 0x00, 0x00, 0x78, 0x48, 0x1c, 0x81,\n\t0xc4, 0x00, 0x00, 0x00, 0x5e, 0x53, 0x4a, 0xf7,\n\t0x18, 0xfa, 0x11, 0xff, 0x6c, 0xf3, 0x90, 0xff,\n\t0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n\t0x18, 0xfa, 0x11, 0xff, 0x14, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0xf2, 0x34, 0x4a, 0xf7,\n\t0x18, 0xfa, 0x11, 0xff\n};\n\nstruct bcd2000 {\n\tstruct usb_device *dev;\n\tstruct snd_card *card;\n\tstruct usb_interface *intf;\n\tint card_index;\n\n\tint midi_out_active;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *midi_receive_substream;\n\tstruct snd_rawmidi_substream *midi_out_substream;\n\n\tunsigned char midi_in_buf[BUFSIZE];\n\tunsigned char midi_out_buf[BUFSIZE];\n\n\tstruct urb *midi_out_urb;\n\tstruct urb *midi_in_urb;\n\n\tstruct usb_anchor anchor;\n};\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\n\nstatic DEFINE_MUTEX(devices_mutex);\nstatic DECLARE_BITMAP(devices_used, SNDRV_CARDS);\nstatic struct usb_driver bcd2000_driver;\n\n#ifdef CONFIG_SND_DEBUG\nstatic void bcd2000_dump_buffer(const char *prefix, const char *buf, int len)\n{\n\tprint_hex_dump(KERN_DEBUG, prefix,\n\t\t\tDUMP_PREFIX_NONE, 16, 1,\n\t\t\tbuf, len, false);\n}\n#else\nstatic void bcd2000_dump_buffer(const char *prefix, const char *buf, int len) {}\n#endif\n\nstatic int bcd2000_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int bcd2000_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic void bcd2000_midi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t\tint up)\n{\n\tstruct bcd2000 *bcd2k = substream->rmidi->private_data;\n\tbcd2k->midi_receive_substream = up ? substream : NULL;\n}\n\nstatic void bcd2000_midi_handle_input(struct bcd2000 *bcd2k,\n\t\t\t\tconst unsigned char *buf, unsigned int buf_len)\n{\n\tunsigned int payload_length, tocopy;\n\tstruct snd_rawmidi_substream *midi_receive_substream;\n\n\tmidi_receive_substream = READ_ONCE(bcd2k->midi_receive_substream);\n\tif (!midi_receive_substream)\n\t\treturn;\n\n\tbcd2000_dump_buffer(PREFIX \"received from device: \", buf, buf_len);\n\n\tif (buf_len < 2)\n\t\treturn;\n\n\tpayload_length = buf[0];\n\n\t \n\tif (payload_length == 0)\n\t\treturn;\n\n\ttocopy = min(payload_length, buf_len-1);\n\n\tbcd2000_dump_buffer(PREFIX \"sending to userspace: \",\n\t\t\t\t\t&buf[1], tocopy);\n\n\tsnd_rawmidi_receive(midi_receive_substream,\n\t\t\t\t\t&buf[1], tocopy);\n}\n\nstatic void bcd2000_midi_send(struct bcd2000 *bcd2k)\n{\n\tint len, ret;\n\tstruct snd_rawmidi_substream *midi_out_substream;\n\n\tBUILD_BUG_ON(sizeof(device_cmd_prefix) >= BUFSIZE);\n\n\tmidi_out_substream = READ_ONCE(bcd2k->midi_out_substream);\n\tif (!midi_out_substream)\n\t\treturn;\n\n\t \n\tmemcpy(bcd2k->midi_out_buf, device_cmd_prefix,\n\t\tsizeof(device_cmd_prefix));\n\n\t \n\tlen = snd_rawmidi_transmit(midi_out_substream,\n\t\t\t\tbcd2k->midi_out_buf + 3, BUFSIZE - 3);\n\n\tif (len < 0)\n\t\tdev_err(&bcd2k->dev->dev, \"%s: snd_rawmidi_transmit error %d\\n\",\n\t\t\t\t__func__, len);\n\n\tif (len <= 0)\n\t\treturn;\n\n\t \n\tbcd2k->midi_out_buf[2] = len;\n\tbcd2k->midi_out_urb->transfer_buffer_length = BUFSIZE;\n\n\tbcd2000_dump_buffer(PREFIX \"sending to device: \",\n\t\t\tbcd2k->midi_out_buf, len+3);\n\n\t \n\tret = usb_submit_urb(bcd2k->midi_out_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_err(&bcd2k->dev->dev, PREFIX\n\t\t\t\"%s (%p): usb_submit_urb() failed, ret=%d, len=%d\\n\",\n\t\t\t__func__, midi_out_substream, ret, len);\n\telse\n\t\tbcd2k->midi_out_active = 1;\n}\n\nstatic int bcd2000_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int bcd2000_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct bcd2000 *bcd2k = substream->rmidi->private_data;\n\n\tif (bcd2k->midi_out_active) {\n\t\tusb_kill_urb(bcd2k->midi_out_urb);\n\t\tbcd2k->midi_out_active = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void bcd2000_midi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t\tint up)\n{\n\tstruct bcd2000 *bcd2k = substream->rmidi->private_data;\n\n\tif (up) {\n\t\tbcd2k->midi_out_substream = substream;\n\t\t \n\t\tif (!bcd2k->midi_out_active)\n\t\t\tbcd2000_midi_send(bcd2k);\n\t} else {\n\t\tbcd2k->midi_out_substream = NULL;\n\t}\n}\n\nstatic void bcd2000_output_complete(struct urb *urb)\n{\n\tstruct bcd2000 *bcd2k = urb->context;\n\n\tbcd2k->midi_out_active = 0;\n\n\tif (urb->status)\n\t\tdev_warn(&urb->dev->dev,\n\t\t\tPREFIX \"output urb->status: %d\\n\", urb->status);\n\n\tif (urb->status == -ESHUTDOWN)\n\t\treturn;\n\n\t \n\tbcd2000_midi_send(bcd2k);\n}\n\nstatic void bcd2000_input_complete(struct urb *urb)\n{\n\tint ret;\n\tstruct bcd2000 *bcd2k = urb->context;\n\n\tif (urb->status)\n\t\tdev_warn(&urb->dev->dev,\n\t\t\tPREFIX \"input urb->status: %i\\n\", urb->status);\n\n\tif (!bcd2k || urb->status == -ESHUTDOWN)\n\t\treturn;\n\n\tif (urb->actual_length > 0)\n\t\tbcd2000_midi_handle_input(bcd2k, urb->transfer_buffer,\n\t\t\t\t\turb->actual_length);\n\n\t \n\tret = usb_submit_urb(bcd2k->midi_in_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_err(&bcd2k->dev->dev, PREFIX\n\t\t\t\"%s: usb_submit_urb() failed, ret=%d\\n\",\n\t\t\t__func__, ret);\n}\n\nstatic const struct snd_rawmidi_ops bcd2000_midi_output = {\n\t.open =    bcd2000_midi_output_open,\n\t.close =   bcd2000_midi_output_close,\n\t.trigger = bcd2000_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops bcd2000_midi_input = {\n\t.open =    bcd2000_midi_input_open,\n\t.close =   bcd2000_midi_input_close,\n\t.trigger = bcd2000_midi_input_trigger,\n};\n\nstatic void bcd2000_init_device(struct bcd2000 *bcd2k)\n{\n\tint ret;\n\n\tinit_usb_anchor(&bcd2k->anchor);\n\tusb_anchor_urb(bcd2k->midi_out_urb, &bcd2k->anchor);\n\tusb_anchor_urb(bcd2k->midi_in_urb, &bcd2k->anchor);\n\n\t \n\tmemcpy(bcd2k->midi_out_buf, bcd2000_init_sequence, 52);\n\tbcd2k->midi_out_urb->transfer_buffer_length = 52;\n\n\t \n\tret = usb_submit_urb(bcd2k->midi_out_urb, GFP_KERNEL);\n\tif (ret < 0)\n\t\tdev_err(&bcd2k->dev->dev, PREFIX\n\t\t\t\"%s: usb_submit_urb() out failed, ret=%d: \",\n\t\t\t__func__, ret);\n\telse\n\t\tbcd2k->midi_out_active = 1;\n\n\t \n\tret = usb_submit_urb(bcd2k->midi_in_urb, GFP_KERNEL);\n\tif (ret < 0)\n\t\tdev_err(&bcd2k->dev->dev, PREFIX\n\t\t\t\"%s: usb_submit_urb() in failed, ret=%d: \",\n\t\t\t__func__, ret);\n\n\t \n\tusb_wait_anchor_empty_timeout(&bcd2k->anchor, 1000);\n}\n\nstatic int bcd2000_init_midi(struct bcd2000 *bcd2k)\n{\n\tint ret;\n\tstruct snd_rawmidi *rmidi;\n\n\tret = snd_rawmidi_new(bcd2k->card, bcd2k->card->shortname, 0,\n\t\t\t\t\t1,  \n\t\t\t\t\t1,  \n\t\t\t\t\t&rmidi);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstrscpy(rmidi->name, bcd2k->card->shortname, sizeof(rmidi->name));\n\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = bcd2k;\n\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t&bcd2000_midi_output);\n\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t&bcd2000_midi_input);\n\n\tbcd2k->rmidi = rmidi;\n\n\tbcd2k->midi_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tbcd2k->midi_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!bcd2k->midi_in_urb || !bcd2k->midi_out_urb) {\n\t\tdev_err(&bcd2k->dev->dev, PREFIX \"usb_alloc_urb failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_int_urb(bcd2k->midi_in_urb, bcd2k->dev,\n\t\t\t\tusb_rcvintpipe(bcd2k->dev, 0x81),\n\t\t\t\tbcd2k->midi_in_buf, BUFSIZE,\n\t\t\t\tbcd2000_input_complete, bcd2k, 1);\n\n\tusb_fill_int_urb(bcd2k->midi_out_urb, bcd2k->dev,\n\t\t\t\tusb_sndintpipe(bcd2k->dev, 0x1),\n\t\t\t\tbcd2k->midi_out_buf, BUFSIZE,\n\t\t\t\tbcd2000_output_complete, bcd2k, 1);\n\n\t \n\tif (usb_urb_ep_type_check(bcd2k->midi_in_urb) ||\n\t    usb_urb_ep_type_check(bcd2k->midi_out_urb)) {\n\t\tdev_err(&bcd2k->dev->dev, \"invalid MIDI EP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbcd2000_init_device(bcd2k);\n\n\treturn 0;\n}\n\nstatic void bcd2000_free_usb_related_resources(struct bcd2000 *bcd2k,\n\t\t\t\t\t\tstruct usb_interface *interface)\n{\n\tusb_kill_urb(bcd2k->midi_out_urb);\n\tusb_kill_urb(bcd2k->midi_in_urb);\n\n\tusb_free_urb(bcd2k->midi_out_urb);\n\tusb_free_urb(bcd2k->midi_in_urb);\n\n\tif (bcd2k->intf) {\n\t\tusb_set_intfdata(bcd2k->intf, NULL);\n\t\tbcd2k->intf = NULL;\n\t}\n}\n\nstatic int bcd2000_probe(struct usb_interface *interface,\n\t\t\t\tconst struct usb_device_id *usb_id)\n{\n\tstruct snd_card *card;\n\tstruct bcd2000 *bcd2k;\n\tunsigned int card_index;\n\tchar usb_path[32];\n\tint err;\n\n\tmutex_lock(&devices_mutex);\n\n\tfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index)\n\t\tif (!test_bit(card_index, devices_used))\n\t\t\tbreak;\n\n\tif (card_index >= SNDRV_CARDS) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&interface->dev, index[card_index], id[card_index],\n\t\t\tTHIS_MODULE, sizeof(*bcd2k), &card);\n\tif (err < 0) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\n\tbcd2k = card->private_data;\n\tbcd2k->dev = interface_to_usbdev(interface);\n\tbcd2k->card = card;\n\tbcd2k->card_index = card_index;\n\tbcd2k->intf = interface;\n\n\tsnd_card_set_dev(card, &interface->dev);\n\n\tstrscpy(card->driver, \"snd-bcd2000\", sizeof(card->driver));\n\tstrscpy(card->shortname, \"BCD2000\", sizeof(card->shortname));\n\tusb_make_path(bcd2k->dev, usb_path, sizeof(usb_path));\n\tsnprintf(bcd2k->card->longname, sizeof(bcd2k->card->longname),\n\t\t    \"Behringer BCD2000 at %s\",\n\t\t\tusb_path);\n\n\terr = bcd2000_init_midi(bcd2k);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\tusb_set_intfdata(interface, bcd2k);\n\tset_bit(card_index, devices_used);\n\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n\nprobe_error:\n\tdev_info(&bcd2k->dev->dev, PREFIX \"error during probing\");\n\tbcd2000_free_usb_related_resources(bcd2k, interface);\n\tsnd_card_free(card);\n\tmutex_unlock(&devices_mutex);\n\treturn err;\n}\n\nstatic void bcd2000_disconnect(struct usb_interface *interface)\n{\n\tstruct bcd2000 *bcd2k = usb_get_intfdata(interface);\n\n\tif (!bcd2k)\n\t\treturn;\n\n\tmutex_lock(&devices_mutex);\n\n\t \n\tsnd_card_disconnect(bcd2k->card);\n\n\tbcd2000_free_usb_related_resources(bcd2k, interface);\n\n\tclear_bit(bcd2k->card_index, devices_used);\n\n\tsnd_card_free_when_closed(bcd2k->card);\n\n\tmutex_unlock(&devices_mutex);\n}\n\nstatic struct usb_driver bcd2000_driver = {\n\t.name =\t\t\"snd-bcd2000\",\n\t.probe =\tbcd2000_probe,\n\t.disconnect =\tbcd2000_disconnect,\n\t.id_table =\tid_table,\n};\n\nmodule_usb_driver(bcd2000_driver);\n\nMODULE_DEVICE_TABLE(usb, id_table);\nMODULE_AUTHOR(\"Mario Kicherer, dev@kicherer.org\");\nMODULE_DESCRIPTION(\"Behringer BCD2000 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}