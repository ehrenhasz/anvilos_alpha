{
  "module_name": "pcm.c",
  "hash_id": "b11cf9f79e31fe7b6f36550a0f1ed1b10aeb8725ed95ecc5d76e90d40b65ab06",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/pcm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bitrev.h>\n#include <linux/ratelimit.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"pcm.h\"\n#include \"clock.h\"\n#include \"power.h\"\n#include \"media.h\"\n#include \"implicit.h\"\n\n#define SUBSTREAM_FLAG_DATA_EP_STARTED\t0\n#define SUBSTREAM_FLAG_SYNC_EP_STARTED\t1\n\n \nstatic snd_pcm_uframes_t snd_usb_pcm_delay(struct snd_usb_substream *subs,\n\t\t\t\t\t   struct snd_pcm_runtime *runtime)\n{\n\tunsigned int current_frame_number;\n\tunsigned int frame_diff;\n\tint est_delay;\n\tint queued;\n\n\tif (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tqueued = bytes_to_frames(runtime, subs->inflight_bytes);\n\t\tif (!queued)\n\t\t\treturn 0;\n\t} else if (!subs->running) {\n\t\treturn 0;\n\t}\n\n\tcurrent_frame_number = usb_get_current_frame_number(subs->dev);\n\t \n\tframe_diff = (current_frame_number - subs->last_frame_number) & 0xff;\n\n\t \n\test_delay = frame_diff * runtime->rate / 1000;\n\n\tif (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\test_delay = queued - est_delay;\n\t\tif (est_delay < 0)\n\t\t\test_delay = 0;\n\t}\n\n\treturn est_delay;\n}\n\n \nstatic snd_pcm_uframes_t snd_usb_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usb_substream *subs = runtime->private_data;\n\tunsigned int hwptr_done;\n\n\tif (atomic_read(&subs->stream->chip->shutdown))\n\t\treturn SNDRV_PCM_POS_XRUN;\n\tspin_lock(&subs->lock);\n\thwptr_done = subs->hwptr_done;\n\truntime->delay = snd_usb_pcm_delay(subs, runtime);\n\tspin_unlock(&subs->lock);\n\treturn bytes_to_frames(runtime, hwptr_done);\n}\n\n \nstatic const struct audioformat *\nfind_format(struct list_head *fmt_list_head, snd_pcm_format_t format,\n\t    unsigned int rate, unsigned int channels, bool strict_match,\n\t    struct snd_usb_substream *subs)\n{\n\tconst struct audioformat *fp;\n\tconst struct audioformat *found = NULL;\n\tint cur_attr = 0, attr;\n\n\tlist_for_each_entry(fp, fmt_list_head, list) {\n\t\tif (strict_match) {\n\t\t\tif (!(fp->formats & pcm_format_to_bits(format)))\n\t\t\t\tcontinue;\n\t\t\tif (fp->channels != channels)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (rate < fp->rate_min || rate > fp->rate_max)\n\t\t\tcontinue;\n\t\tif (!(fp->rates & SNDRV_PCM_RATE_CONTINUOUS)) {\n\t\t\tunsigned int i;\n\t\t\tfor (i = 0; i < fp->nr_rates; i++)\n\t\t\t\tif (fp->rate_table[i] == rate)\n\t\t\t\t\tbreak;\n\t\t\tif (i >= fp->nr_rates)\n\t\t\t\tcontinue;\n\t\t}\n\t\tattr = fp->ep_attr & USB_ENDPOINT_SYNCTYPE;\n\t\tif (!found) {\n\t\t\tfound = fp;\n\t\t\tcur_attr = attr;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (subs && attr != cur_attr) {\n\t\t\tif ((attr == USB_ENDPOINT_SYNC_ASYNC &&\n\t\t\t     subs->direction == SNDRV_PCM_STREAM_PLAYBACK) ||\n\t\t\t    (attr == USB_ENDPOINT_SYNC_ADAPTIVE &&\n\t\t\t     subs->direction == SNDRV_PCM_STREAM_CAPTURE))\n\t\t\t\tcontinue;\n\t\t\tif ((cur_attr == USB_ENDPOINT_SYNC_ASYNC &&\n\t\t\t     subs->direction == SNDRV_PCM_STREAM_PLAYBACK) ||\n\t\t\t    (cur_attr == USB_ENDPOINT_SYNC_ADAPTIVE &&\n\t\t\t     subs->direction == SNDRV_PCM_STREAM_CAPTURE)) {\n\t\t\t\tfound = fp;\n\t\t\t\tcur_attr = attr;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (fp->maxpacksize > found->maxpacksize) {\n\t\t\tfound = fp;\n\t\t\tcur_attr = attr;\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic const struct audioformat *\nfind_substream_format(struct snd_usb_substream *subs,\n\t\t      const struct snd_pcm_hw_params *params)\n{\n\treturn find_format(&subs->fmt_list, params_format(params),\n\t\t\t   params_rate(params), params_channels(params),\n\t\t\t   true, subs);\n}\n\nbool snd_usb_pcm_has_fixed_rate(struct snd_usb_substream *subs)\n{\n\tconst struct audioformat *fp;\n\tstruct snd_usb_audio *chip;\n\tint rate = -1;\n\n\tif (!subs)\n\t\treturn false;\n\tchip = subs->stream->chip;\n\tif (!(chip->quirk_flags & QUIRK_FLAG_FIXED_RATE))\n\t\treturn false;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (fp->rates & SNDRV_PCM_RATE_CONTINUOUS)\n\t\t\treturn false;\n\t\tif (fp->nr_rates < 1)\n\t\t\tcontinue;\n\t\tif (fp->nr_rates > 1)\n\t\t\treturn false;\n\t\tif (rate < 0) {\n\t\t\trate = fp->rate_table[0];\n\t\t\tcontinue;\n\t\t}\n\t\tif (rate != fp->rate_table[0])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int init_pitch_v1(struct snd_usb_audio *chip, int ep)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned char data[1];\n\tint err;\n\n\tdata[0] = 1;\n\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,\n\t\t\t      USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT,\n\t\t\t      UAC_EP_CS_ATTR_PITCH_CONTROL << 8, ep,\n\t\t\t      data, sizeof(data));\n\treturn err;\n}\n\nstatic int init_pitch_v2(struct snd_usb_audio *chip, int ep)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned char data[1];\n\tint err;\n\n\tdata[0] = 1;\n\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t      UAC2_EP_CS_PITCH << 8, 0,\n\t\t\t      data, sizeof(data));\n\treturn err;\n}\n\n \nint snd_usb_init_pitch(struct snd_usb_audio *chip,\n\t\t       const struct audioformat *fmt)\n{\n\tint err;\n\n\t \n\tif (!(fmt->attributes & UAC_EP_CS_ATTR_PITCH_CONTROL))\n\t\treturn 0;\n\n\tusb_audio_dbg(chip, \"enable PITCH for EP 0x%x\\n\", fmt->endpoint);\n\n\tswitch (fmt->protocol) {\n\tcase UAC_VERSION_1:\n\t\terr = init_pitch_v1(chip, fmt->endpoint);\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\terr = init_pitch_v2(chip, fmt->endpoint);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"failed to enable PITCH for EP 0x%x\\n\",\n\t\t\t      fmt->endpoint);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool stop_endpoints(struct snd_usb_substream *subs, bool keep_pending)\n{\n\tbool stopped = 0;\n\n\tif (test_and_clear_bit(SUBSTREAM_FLAG_SYNC_EP_STARTED, &subs->flags)) {\n\t\tsnd_usb_endpoint_stop(subs->sync_endpoint, keep_pending);\n\t\tstopped = true;\n\t}\n\tif (test_and_clear_bit(SUBSTREAM_FLAG_DATA_EP_STARTED, &subs->flags)) {\n\t\tsnd_usb_endpoint_stop(subs->data_endpoint, keep_pending);\n\t\tstopped = true;\n\t}\n\treturn stopped;\n}\n\nstatic int start_endpoints(struct snd_usb_substream *subs)\n{\n\tint err;\n\n\tif (!subs->data_endpoint)\n\t\treturn -EINVAL;\n\n\tif (!test_and_set_bit(SUBSTREAM_FLAG_DATA_EP_STARTED, &subs->flags)) {\n\t\terr = snd_usb_endpoint_start(subs->data_endpoint);\n\t\tif (err < 0) {\n\t\t\tclear_bit(SUBSTREAM_FLAG_DATA_EP_STARTED, &subs->flags);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (subs->sync_endpoint &&\n\t    !test_and_set_bit(SUBSTREAM_FLAG_SYNC_EP_STARTED, &subs->flags)) {\n\t\terr = snd_usb_endpoint_start(subs->sync_endpoint);\n\t\tif (err < 0) {\n\t\t\tclear_bit(SUBSTREAM_FLAG_SYNC_EP_STARTED, &subs->flags);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\n error:\n\tstop_endpoints(subs, false);\n\treturn err;\n}\n\nstatic void sync_pending_stops(struct snd_usb_substream *subs)\n{\n\tsnd_usb_endpoint_sync_pending_stop(subs->sync_endpoint);\n\tsnd_usb_endpoint_sync_pending_stop(subs->data_endpoint);\n}\n\n \nstatic int snd_usb_pcm_sync_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\n\tsync_pending_stops(subs);\n\treturn 0;\n}\n\n \nint snd_usb_audioformat_set_sync_ep(struct snd_usb_audio *chip,\n\t\t\t\t    struct audioformat *fmt)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tunsigned int ep, attr, sync_attr;\n\tbool is_playback;\n\tint err;\n\n\tif (fmt->sync_ep)\n\t\treturn 0;  \n\n\talts = snd_usb_get_host_interface(chip, fmt->iface, fmt->altsetting);\n\tif (!alts)\n\t\treturn 0;\n\taltsd = get_iface_desc(alts);\n\n\terr = snd_usb_parse_implicit_fb_quirk(chip, fmt, alts);\n\tif (err > 0)\n\t\treturn 0;  \n\n\t \n\n\tif (fmt->ep_idx > 0 || altsd->bNumEndpoints < 2)\n\t\treturn 0;\n\n\tis_playback = !(get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN);\n\tattr = fmt->ep_attr & USB_ENDPOINT_SYNCTYPE;\n\tif ((is_playback && (attr == USB_ENDPOINT_SYNC_SYNC ||\n\t\t\t     attr == USB_ENDPOINT_SYNC_ADAPTIVE)) ||\n\t    (!is_playback && attr != USB_ENDPOINT_SYNC_ADAPTIVE))\n\t\treturn 0;\n\n\tsync_attr = get_endpoint(alts, 1)->bmAttributes;\n\n\t \n\n\t \n\t \n\tif ((sync_attr & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_ISOC ||\n\t    (get_endpoint(alts, 1)->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&\n\t     get_endpoint(alts, 1)->bSynchAddress != 0)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%d:%d : invalid sync pipe. bmAttributes %02x, bLength %d, bSynchAddress %02x\\n\",\n\t\t\t   fmt->iface, fmt->altsetting,\n\t\t\t   get_endpoint(alts, 1)->bmAttributes,\n\t\t\t   get_endpoint(alts, 1)->bLength,\n\t\t\t   get_endpoint(alts, 1)->bSynchAddress);\n\t\tif (is_playback && attr == USB_ENDPOINT_SYNC_NONE)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\tep = get_endpoint(alts, 1)->bEndpointAddress;\n\tif (get_endpoint(alts, 0)->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&\n\t    get_endpoint(alts, 0)->bSynchAddress != 0 &&\n\t    ((is_playback && ep != (unsigned int)(get_endpoint(alts, 0)->bSynchAddress | USB_DIR_IN)) ||\n\t     (!is_playback && ep != (unsigned int)(get_endpoint(alts, 0)->bSynchAddress & ~USB_DIR_IN)))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%d:%d : invalid sync pipe. is_playback %d, ep %02x, bSynchAddress %02x\\n\",\n\t\t\t   fmt->iface, fmt->altsetting,\n\t\t\t   is_playback, ep, get_endpoint(alts, 0)->bSynchAddress);\n\t\tif (is_playback && attr == USB_ENDPOINT_SYNC_NONE)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tfmt->sync_ep = ep;\n\tfmt->sync_iface = altsd->bInterfaceNumber;\n\tfmt->sync_altsetting = altsd->bAlternateSetting;\n\tfmt->sync_ep_idx = 1;\n\tif ((sync_attr & USB_ENDPOINT_USAGE_MASK) == USB_ENDPOINT_USAGE_IMPLICIT_FB)\n\t\tfmt->implicit_fb = 1;\n\n\tdev_dbg(&dev->dev, \"%d:%d: found sync_ep=0x%x, iface=%d, alt=%d, implicit_fb=%d\\n\",\n\t\tfmt->iface, fmt->altsetting, fmt->sync_ep, fmt->sync_iface,\n\t\tfmt->sync_altsetting, fmt->implicit_fb);\n\n\treturn 0;\n}\n\nstatic int snd_usb_pcm_change_state(struct snd_usb_substream *subs, int state)\n{\n\tint ret;\n\n\tif (!subs->str_pd)\n\t\treturn 0;\n\n\tret = snd_usb_power_domain_set(subs->stream->chip, subs->str_pd, state);\n\tif (ret < 0) {\n\t\tdev_err(&subs->dev->dev,\n\t\t\t\"Cannot change Power Domain ID: %d to state: %d. Err: %d\\n\",\n\t\t\tsubs->str_pd->pd_id, state, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_pcm_suspend(struct snd_usb_stream *as)\n{\n\tint ret;\n\n\tret = snd_usb_pcm_change_state(&as->substream[0], UAC3_PD_STATE_D2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_usb_pcm_change_state(&as->substream[1], UAC3_PD_STATE_D2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint snd_usb_pcm_resume(struct snd_usb_stream *as)\n{\n\tint ret;\n\n\tret = snd_usb_pcm_change_state(&as->substream[0], UAC3_PD_STATE_D1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_usb_pcm_change_state(&as->substream[1], UAC3_PD_STATE_D1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void close_endpoints(struct snd_usb_audio *chip,\n\t\t\t    struct snd_usb_substream *subs)\n{\n\tif (subs->data_endpoint) {\n\t\tsnd_usb_endpoint_set_sync(chip, subs->data_endpoint, NULL);\n\t\tsnd_usb_endpoint_close(chip, subs->data_endpoint);\n\t\tsubs->data_endpoint = NULL;\n\t}\n\n\tif (subs->sync_endpoint) {\n\t\tsnd_usb_endpoint_close(chip, subs->sync_endpoint);\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\n \nstatic int snd_usb_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tconst struct audioformat *fmt;\n\tconst struct audioformat *sync_fmt;\n\tbool fixed_rate, sync_fixed_rate;\n\tint ret;\n\n\tret = snd_media_start_pipeline(subs);\n\tif (ret)\n\t\treturn ret;\n\n\tfixed_rate = snd_usb_pcm_has_fixed_rate(subs);\n\tfmt = find_substream_format(subs, hw_params);\n\tif (!fmt) {\n\t\tusb_audio_dbg(chip,\n\t\t\t      \"cannot find format: format=%s, rate=%d, channels=%d\\n\",\n\t\t\t      snd_pcm_format_name(params_format(hw_params)),\n\t\t\t      params_rate(hw_params), params_channels(hw_params));\n\t\tret = -EINVAL;\n\t\tgoto stop_pipeline;\n\t}\n\n\tif (fmt->implicit_fb) {\n\t\tsync_fmt = snd_usb_find_implicit_fb_sync_format(chip, fmt,\n\t\t\t\t\t\t\t\thw_params,\n\t\t\t\t\t\t\t\t!substream->stream,\n\t\t\t\t\t\t\t\t&sync_fixed_rate);\n\t\tif (!sync_fmt) {\n\t\t\tusb_audio_dbg(chip,\n\t\t\t\t      \"cannot find sync format: ep=0x%x, iface=%d:%d, format=%s, rate=%d, channels=%d\\n\",\n\t\t\t\t      fmt->sync_ep, fmt->sync_iface,\n\t\t\t\t      fmt->sync_altsetting,\n\t\t\t\t      snd_pcm_format_name(params_format(hw_params)),\n\t\t\t\t      params_rate(hw_params), params_channels(hw_params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto stop_pipeline;\n\t\t}\n\t} else {\n\t\tsync_fmt = fmt;\n\t\tsync_fixed_rate = fixed_rate;\n\t}\n\n\tret = snd_usb_lock_shutdown(chip);\n\tif (ret < 0)\n\t\tgoto stop_pipeline;\n\n\tret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (subs->data_endpoint) {\n\t\tif (snd_usb_endpoint_compatible(chip, subs->data_endpoint,\n\t\t\t\t\t\tfmt, hw_params))\n\t\t\tgoto unlock;\n\t\tif (stop_endpoints(subs, false))\n\t\t\tsync_pending_stops(subs);\n\t\tclose_endpoints(chip, subs);\n\t}\n\n\tsubs->data_endpoint = snd_usb_endpoint_open(chip, fmt, hw_params, false, fixed_rate);\n\tif (!subs->data_endpoint) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (fmt->sync_ep) {\n\t\tsubs->sync_endpoint = snd_usb_endpoint_open(chip, sync_fmt,\n\t\t\t\t\t\t\t    hw_params,\n\t\t\t\t\t\t\t    fmt == sync_fmt,\n\t\t\t\t\t\t\t    sync_fixed_rate);\n\t\tif (!subs->sync_endpoint) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tsnd_usb_endpoint_set_sync(chip, subs->data_endpoint,\n\t\t\t\t\t  subs->sync_endpoint);\n\t}\n\n\tmutex_lock(&chip->mutex);\n\tsubs->cur_audiofmt = fmt;\n\tmutex_unlock(&chip->mutex);\n\n\tif (!subs->data_endpoint->need_setup)\n\t\tgoto unlock;\n\n\tif (subs->sync_endpoint) {\n\t\tret = snd_usb_endpoint_set_params(chip, subs->sync_endpoint);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = snd_usb_endpoint_set_params(chip, subs->data_endpoint);\n\n unlock:\n\tif (ret < 0)\n\t\tclose_endpoints(chip, subs);\n\n\tsnd_usb_unlock_shutdown(chip);\n stop_pipeline:\n\tif (ret < 0)\n\t\tsnd_media_stop_pipeline(subs);\n\n\treturn ret;\n}\n\n \nstatic int snd_usb_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\n\tsnd_media_stop_pipeline(subs);\n\tmutex_lock(&chip->mutex);\n\tsubs->cur_audiofmt = NULL;\n\tmutex_unlock(&chip->mutex);\n\tif (!snd_usb_lock_shutdown(chip)) {\n\t\tif (stop_endpoints(subs, false))\n\t\t\tsync_pending_stops(subs);\n\t\tclose_endpoints(chip, subs);\n\t\tsnd_usb_unlock_shutdown(chip);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int in_free_wheeling_mode(struct snd_pcm_runtime *runtime)\n{\n\treturn runtime->stop_threshold > runtime->buffer_size;\n}\n\n \nstatic int lowlatency_playback_available(struct snd_pcm_runtime *runtime,\n\t\t\t\t\t struct snd_usb_substream *subs)\n{\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\n\tif (subs->direction == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn false;\n\t \n\tif (!chip->lowlatency)\n\t\treturn false;\n\tif (in_free_wheeling_mode(runtime))\n\t\treturn false;\n\t \n\tif (snd_usb_endpoint_implicit_feedback_sink(subs->data_endpoint))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usb_substream *subs = runtime->private_data;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tint retry = 0;\n\tint ret;\n\n\tret = snd_usb_lock_shutdown(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (snd_BUG_ON(!subs->data_endpoint)) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n again:\n\tif (subs->sync_endpoint) {\n\t\tret = snd_usb_endpoint_prepare(chip, subs->sync_endpoint);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = snd_usb_endpoint_prepare(chip, subs->data_endpoint);\n\tif (ret < 0)\n\t\tgoto unlock;\n\telse if (ret > 0)\n\t\tsnd_usb_set_format_quirk(subs, subs->cur_audiofmt);\n\tret = 0;\n\n\t \n\tsubs->buffer_bytes = frames_to_bytes(runtime, runtime->buffer_size);\n\tsubs->inflight_bytes = 0;\n\tsubs->hwptr_done = 0;\n\tsubs->transfer_done = 0;\n\tsubs->last_frame_number = 0;\n\tsubs->period_elapsed_pending = 0;\n\truntime->delay = 0;\n\n\tsubs->lowlatency_playback = lowlatency_playback_available(runtime, subs);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    !subs->lowlatency_playback) {\n\t\tret = start_endpoints(subs);\n\t\t \n\t\tif (ret == -EPIPE && !retry++) {\n\t\t\tsync_pending_stops(subs);\n\t\t\tgoto again;\n\t\t}\n\t}\n unlock:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn ret;\n}\n\n \n\n#ifdef HW_CONST_DEBUG\n#define hwc_debug(fmt, args...) pr_debug(fmt, ##args)\n#else\n#define hwc_debug(fmt, args...) do { } while(0)\n#endif\n\nstatic const struct snd_pcm_hardware snd_usb_hardware =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_BATCH |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t256,\n\t.buffer_bytes_max =\tINT_MAX,  \n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\tINT_MAX,  \n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n};\n\nstatic int hw_check_valid_format(struct snd_usb_substream *subs,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t const struct audioformat *fp)\n{\n\tstruct snd_interval *it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *ct = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *fmts = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_interval *pt = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_TIME);\n\tstruct snd_mask check_fmts;\n\tunsigned int ptime;\n\n\t \n\tsnd_mask_none(&check_fmts);\n\tcheck_fmts.bits[0] = (u32)fp->formats;\n\tcheck_fmts.bits[1] = (u32)(fp->formats >> 32);\n\tsnd_mask_intersect(&check_fmts, fmts);\n\tif (snd_mask_empty(&check_fmts)) {\n\t\thwc_debug(\"   > check: no supported format 0x%llx\\n\", fp->formats);\n\t\treturn 0;\n\t}\n\t \n\tif (fp->channels < ct->min || fp->channels > ct->max) {\n\t\thwc_debug(\"   > check: no valid channels %d (%d/%d)\\n\", fp->channels, ct->min, ct->max);\n\t\treturn 0;\n\t}\n\t \n\tif (fp->rate_min > it->max || (fp->rate_min == it->max && it->openmax)) {\n\t\thwc_debug(\"   > check: rate_min %d > max %d\\n\", fp->rate_min, it->max);\n\t\treturn 0;\n\t}\n\tif (fp->rate_max < it->min || (fp->rate_max == it->min && it->openmin)) {\n\t\thwc_debug(\"   > check: rate_max %d < min %d\\n\", fp->rate_max, it->min);\n\t\treturn 0;\n\t}\n\t \n\tif (subs->speed != USB_SPEED_FULL) {\n\t\tptime = 125 * (1 << fp->datainterval);\n\t\tif (ptime > pt->max || (ptime == pt->max && pt->openmax)) {\n\t\t\thwc_debug(\"   > check: ptime %u > max %u\\n\", ptime, pt->max);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int apply_hw_params_minmax(struct snd_interval *it, unsigned int rmin,\n\t\t\t\t  unsigned int rmax)\n{\n\tint changed;\n\n\tif (rmin > rmax) {\n\t\thwc_debug(\"  --> get empty\\n\");\n\t\tit->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\n\tchanged = 0;\n\tif (it->min < rmin) {\n\t\tit->min = rmin;\n\t\tit->openmin = 0;\n\t\tchanged = 1;\n\t}\n\tif (it->max > rmax) {\n\t\tit->max = rmax;\n\t\tit->openmax = 0;\n\t\tchanged = 1;\n\t}\n\tif (snd_interval_checkempty(it)) {\n\t\tit->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\thwc_debug(\"  --> (%d, %d) (changed = %d)\\n\", it->min, it->max, changed);\n\treturn changed;\n}\n\n \nstatic const struct snd_usb_endpoint *\nget_endpoint_in_use(struct snd_usb_audio *chip, int endpoint,\n\t\t    const struct snd_usb_endpoint *ref_ep)\n{\n\tconst struct snd_usb_endpoint *ep;\n\n\tep = snd_usb_get_endpoint(chip, endpoint);\n\tif (ep && ep->cur_audiofmt && (ep != ref_ep || ep->opened > 1))\n\t\treturn ep;\n\treturn NULL;\n}\n\nstatic int hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tconst struct snd_usb_endpoint *ep;\n\tconst struct audioformat *fp;\n\tstruct snd_interval *it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tunsigned int rmin, rmax, r;\n\tint i;\n\n\thwc_debug(\"hw_rule_rate: (%d,%d)\\n\", it->min, it->max);\n\trmin = UINT_MAX;\n\trmax = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\n\t\tep = get_endpoint_in_use(chip, fp->endpoint,\n\t\t\t\t\t subs->data_endpoint);\n\t\tif (ep) {\n\t\t\thwc_debug(\"rate limit %d for ep#%x\\n\",\n\t\t\t\t  ep->cur_rate, fp->endpoint);\n\t\t\trmin = min(rmin, ep->cur_rate);\n\t\t\trmax = max(rmax, ep->cur_rate);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fp->implicit_fb) {\n\t\t\tep = get_endpoint_in_use(chip, fp->sync_ep,\n\t\t\t\t\t\t subs->sync_endpoint);\n\t\t\tif (ep) {\n\t\t\t\thwc_debug(\"rate limit %d for sync_ep#%x\\n\",\n\t\t\t\t\t  ep->cur_rate, fp->sync_ep);\n\t\t\t\trmin = min(rmin, ep->cur_rate);\n\t\t\t\trmax = max(rmax, ep->cur_rate);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tr = snd_usb_endpoint_get_clock_rate(chip, fp->clock);\n\t\tif (r > 0) {\n\t\t\tif (!snd_interval_test(it, r))\n\t\t\t\tcontinue;\n\t\t\trmin = min(rmin, r);\n\t\t\trmax = max(rmax, r);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fp->rate_table && fp->nr_rates) {\n\t\t\tfor (i = 0; i < fp->nr_rates; i++) {\n\t\t\t\tr = fp->rate_table[i];\n\t\t\t\tif (!snd_interval_test(it, r))\n\t\t\t\t\tcontinue;\n\t\t\t\trmin = min(rmin, r);\n\t\t\t\trmax = max(rmax, r);\n\t\t\t}\n\t\t} else {\n\t\t\trmin = min(rmin, fp->rate_min);\n\t\t\trmax = max(rmax, fp->rate_max);\n\t\t}\n\t}\n\n\treturn apply_hw_params_minmax(it, rmin, rmax);\n}\n\n\nstatic int hw_rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tconst struct audioformat *fp;\n\tstruct snd_interval *it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tunsigned int rmin, rmax;\n\n\thwc_debug(\"hw_rule_channels: (%d,%d)\\n\", it->min, it->max);\n\trmin = UINT_MAX;\n\trmax = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\t\trmin = min(rmin, fp->channels);\n\t\trmax = max(rmax, fp->channels);\n\t}\n\n\treturn apply_hw_params_minmax(it, rmin, rmax);\n}\n\nstatic int apply_hw_params_format_bits(struct snd_mask *fmt, u64 fbits)\n{\n\tu32 oldbits[2];\n\tint changed;\n\n\toldbits[0] = fmt->bits[0];\n\toldbits[1] = fmt->bits[1];\n\tfmt->bits[0] &= (u32)fbits;\n\tfmt->bits[1] &= (u32)(fbits >> 32);\n\tif (!fmt->bits[0] && !fmt->bits[1]) {\n\t\thwc_debug(\"  --> get empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tchanged = (oldbits[0] != fmt->bits[0] || oldbits[1] != fmt->bits[1]);\n\thwc_debug(\"  --> %x:%x (changed = %d)\\n\", fmt->bits[0], fmt->bits[1], changed);\n\treturn changed;\n}\n\nstatic int hw_rule_format(struct snd_pcm_hw_params *params,\n\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tconst struct snd_usb_endpoint *ep;\n\tconst struct audioformat *fp;\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tu64 fbits;\n\n\thwc_debug(\"hw_rule_format: %x:%x\\n\", fmt->bits[0], fmt->bits[1]);\n\tfbits = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\n\t\tep = get_endpoint_in_use(chip, fp->endpoint,\n\t\t\t\t\t subs->data_endpoint);\n\t\tif (ep) {\n\t\t\thwc_debug(\"format limit %d for ep#%x\\n\",\n\t\t\t\t  ep->cur_format, fp->endpoint);\n\t\t\tfbits |= pcm_format_to_bits(ep->cur_format);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fp->implicit_fb) {\n\t\t\tep = get_endpoint_in_use(chip, fp->sync_ep,\n\t\t\t\t\t\t subs->sync_endpoint);\n\t\t\tif (ep) {\n\t\t\t\thwc_debug(\"format limit %d for sync_ep#%x\\n\",\n\t\t\t\t\t  ep->cur_format, fp->sync_ep);\n\t\t\t\tfbits |= pcm_format_to_bits(ep->cur_format);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfbits |= fp->formats;\n\t}\n\treturn apply_hw_params_format_bits(fmt, fbits);\n}\n\nstatic int hw_rule_period_time(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tconst struct audioformat *fp;\n\tstruct snd_interval *it;\n\tunsigned char min_datainterval;\n\tunsigned int pmin;\n\n\tit = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_TIME);\n\thwc_debug(\"hw_rule_period_time: (%u,%u)\\n\", it->min, it->max);\n\tmin_datainterval = 0xff;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\t\tmin_datainterval = min(min_datainterval, fp->datainterval);\n\t}\n\tif (min_datainterval == 0xff) {\n\t\thwc_debug(\"  --> get empty\\n\");\n\t\tit->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tpmin = 125 * (1 << min_datainterval);\n\n\treturn apply_hw_params_minmax(it, pmin, UINT_MAX);\n}\n\n \nstatic int hw_rule_period_size_implicit_fb(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tconst struct audioformat *fp;\n\tconst struct snd_usb_endpoint *ep;\n\tstruct snd_interval *it;\n\tunsigned int rmin, rmax;\n\n\tit = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\thwc_debug(\"hw_rule_period_size: (%u,%u)\\n\", it->min, it->max);\n\trmin = UINT_MAX;\n\trmax = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\t\tep = get_endpoint_in_use(chip, fp->endpoint,\n\t\t\t\t\t subs->data_endpoint);\n\t\tif (ep) {\n\t\t\thwc_debug(\"period size limit %d for ep#%x\\n\",\n\t\t\t\t  ep->cur_period_frames, fp->endpoint);\n\t\t\trmin = min(rmin, ep->cur_period_frames);\n\t\t\trmax = max(rmax, ep->cur_period_frames);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fp->implicit_fb) {\n\t\t\tep = get_endpoint_in_use(chip, fp->sync_ep,\n\t\t\t\t\t\t subs->sync_endpoint);\n\t\t\tif (ep) {\n\t\t\t\thwc_debug(\"period size limit %d for sync_ep#%x\\n\",\n\t\t\t\t\t  ep->cur_period_frames, fp->sync_ep);\n\t\t\t\trmin = min(rmin, ep->cur_period_frames);\n\t\t\t\trmax = max(rmax, ep->cur_period_frames);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rmax)\n\t\treturn 0;  \n\treturn apply_hw_params_minmax(it, rmin, rmax);\n}\n\nstatic int hw_rule_periods_implicit_fb(struct snd_pcm_hw_params *params,\n\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_usb_substream *subs = rule->private;\n\tstruct snd_usb_audio *chip = subs->stream->chip;\n\tconst struct audioformat *fp;\n\tconst struct snd_usb_endpoint *ep;\n\tstruct snd_interval *it;\n\tunsigned int rmin, rmax;\n\n\tit = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIODS);\n\thwc_debug(\"hw_rule_periods: (%u,%u)\\n\", it->min, it->max);\n\trmin = UINT_MAX;\n\trmax = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (!hw_check_valid_format(subs, params, fp))\n\t\t\tcontinue;\n\t\tep = get_endpoint_in_use(chip, fp->endpoint,\n\t\t\t\t\t subs->data_endpoint);\n\t\tif (ep) {\n\t\t\thwc_debug(\"periods limit %d for ep#%x\\n\",\n\t\t\t\t  ep->cur_buffer_periods, fp->endpoint);\n\t\t\trmin = min(rmin, ep->cur_buffer_periods);\n\t\t\trmax = max(rmax, ep->cur_buffer_periods);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fp->implicit_fb) {\n\t\t\tep = get_endpoint_in_use(chip, fp->sync_ep,\n\t\t\t\t\t\t subs->sync_endpoint);\n\t\t\tif (ep) {\n\t\t\t\thwc_debug(\"periods limit %d for sync_ep#%x\\n\",\n\t\t\t\t\t  ep->cur_buffer_periods, fp->sync_ep);\n\t\t\t\trmin = min(rmin, ep->cur_buffer_periods);\n\t\t\t\trmax = max(rmax, ep->cur_buffer_periods);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rmax)\n\t\treturn 0;  \n\treturn apply_hw_params_minmax(it, rmin, rmax);\n}\n\n \n\nstatic int setup_hw_info(struct snd_pcm_runtime *runtime, struct snd_usb_substream *subs)\n{\n\tconst struct audioformat *fp;\n\tunsigned int pt, ptmin;\n\tint param_period_time_if_needed = -1;\n\tint err;\n\n\truntime->hw.formats = subs->formats;\n\n\truntime->hw.rate_min = 0x7fffffff;\n\truntime->hw.rate_max = 0;\n\truntime->hw.channels_min = 256;\n\truntime->hw.channels_max = 0;\n\truntime->hw.rates = 0;\n\tptmin = UINT_MAX;\n\t \n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\truntime->hw.rates |= fp->rates;\n\t\tif (runtime->hw.rate_min > fp->rate_min)\n\t\t\truntime->hw.rate_min = fp->rate_min;\n\t\tif (runtime->hw.rate_max < fp->rate_max)\n\t\t\truntime->hw.rate_max = fp->rate_max;\n\t\tif (runtime->hw.channels_min > fp->channels)\n\t\t\truntime->hw.channels_min = fp->channels;\n\t\tif (runtime->hw.channels_max < fp->channels)\n\t\t\truntime->hw.channels_max = fp->channels;\n\t\tif (fp->fmt_type == UAC_FORMAT_TYPE_II && fp->frame_size > 0) {\n\t\t\t \n\t\t\truntime->hw.period_bytes_min = runtime->hw.period_bytes_max =\n\t\t\t\tfp->frame_size;\n\t\t}\n\t\tpt = 125 * (1 << fp->datainterval);\n\t\tptmin = min(ptmin, pt);\n\t}\n\n\tparam_period_time_if_needed = SNDRV_PCM_HW_PARAM_PERIOD_TIME;\n\tif (subs->speed == USB_SPEED_FULL)\n\t\t \n\t\tptmin = 1000;\n\tif (ptmin == 1000)\n\t\t \n\t\tparam_period_time_if_needed = -1;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   ptmin, UINT_MAX);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  hw_rule_rate, subs,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  param_period_time_if_needed,\n\t\t\t\t  -1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_channels, subs,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  param_period_time_if_needed,\n\t\t\t\t  -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_format, subs,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  param_period_time_if_needed,\n\t\t\t\t  -1);\n\tif (err < 0)\n\t\treturn err;\n\tif (param_period_time_if_needed >= 0) {\n\t\terr = snd_pcm_hw_rule_add(runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t  hw_rule_period_time, subs,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  -1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   0, 1000000);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_TIME,\n\t\t\t\t\t   0, 2000000);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t  hw_rule_period_size_implicit_fb, subs,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIODS,\n\t\t\t\t  hw_rule_periods_implicit_fb, subs,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIODS, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tif (fp->implicit_fb) {\n\t\t\truntime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_usb_pcm_open(struct snd_pcm_substream *substream)\n{\n\tint direction = substream->stream;\n\tstruct snd_usb_stream *as = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usb_substream *subs = &as->substream[direction];\n\tint ret;\n\n\truntime->hw = snd_usb_hardware;\n\t \n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    as->chip->lowlatency)\n\t\truntime->hw.info |= SNDRV_PCM_INFO_SYNC_APPLPTR;\n\truntime->private_data = subs;\n\tsubs->pcm_substream = substream;\n\t \n\n\t \n\tsubs->dsd_dop.byte_idx = 0;\n\tsubs->dsd_dop.channel = 0;\n\tsubs->dsd_dop.marker = 1;\n\n\tret = setup_hw_info(runtime, subs);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_usb_autoresume(subs->stream->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = snd_media_stream_init(subs, as->pcm, direction);\n\tif (ret < 0)\n\t\tsnd_usb_autosuspend(subs->stream->chip);\n\treturn ret;\n}\n\nstatic int snd_usb_pcm_close(struct snd_pcm_substream *substream)\n{\n\tint direction = substream->stream;\n\tstruct snd_usb_stream *as = snd_pcm_substream_chip(substream);\n\tstruct snd_usb_substream *subs = &as->substream[direction];\n\tint ret;\n\n\tsnd_media_stop_pipeline(subs);\n\n\tif (!snd_usb_lock_shutdown(subs->stream->chip)) {\n\t\tret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D1);\n\t\tsnd_usb_unlock_shutdown(subs->stream->chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsubs->pcm_substream = NULL;\n\tsnd_usb_autosuspend(subs->stream->chip);\n\n\treturn 0;\n}\n\n \nstatic void retire_capture_urb(struct snd_usb_substream *subs,\n\t\t\t       struct urb *urb)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tunsigned int stride, frames, bytes, oldptr;\n\tint i, period_elapsed = 0;\n\tunsigned long flags;\n\tunsigned char *cp;\n\tint current_frame_number;\n\n\t \n\tcurrent_frame_number = usb_get_current_frame_number(subs->dev);\n\n\tstride = runtime->frame_bits >> 3;\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tcp = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset + subs->pkt_offset_adj;\n\t\tif (urb->iso_frame_desc[i].status && printk_ratelimit()) {\n\t\t\tdev_dbg(&subs->dev->dev, \"frame %d active: %d\\n\",\n\t\t\t\ti, urb->iso_frame_desc[i].status);\n\t\t\t\n\t\t}\n\t\tbytes = urb->iso_frame_desc[i].actual_length;\n\t\tif (subs->stream_offset_adj > 0) {\n\t\t\tunsigned int adj = min(subs->stream_offset_adj, bytes);\n\t\t\tcp += adj;\n\t\t\tbytes -= adj;\n\t\t\tsubs->stream_offset_adj -= adj;\n\t\t}\n\t\tframes = bytes / stride;\n\t\tif (!subs->txfr_quirk)\n\t\t\tbytes = frames * stride;\n\t\tif (bytes % (runtime->sample_bits >> 3) != 0) {\n\t\t\tint oldbytes = bytes;\n\t\t\tbytes = frames * stride;\n\t\t\tdev_warn_ratelimited(&subs->dev->dev,\n\t\t\t\t \"Corrected urb data len. %d->%d\\n\",\n\t\t\t\t\t\t\toldbytes, bytes);\n\t\t}\n\t\t \n\t\tspin_lock_irqsave(&subs->lock, flags);\n\t\toldptr = subs->hwptr_done;\n\t\tsubs->hwptr_done += bytes;\n\t\tif (subs->hwptr_done >= subs->buffer_bytes)\n\t\t\tsubs->hwptr_done -= subs->buffer_bytes;\n\t\tframes = (bytes + (oldptr % stride)) / stride;\n\t\tsubs->transfer_done += frames;\n\t\tif (subs->transfer_done >= runtime->period_size) {\n\t\t\tsubs->transfer_done -= runtime->period_size;\n\t\t\tperiod_elapsed = 1;\n\t\t}\n\n\t\t \n\t\tsubs->last_frame_number = current_frame_number;\n\n\t\tspin_unlock_irqrestore(&subs->lock, flags);\n\t\t \n\t\tif (oldptr + bytes > subs->buffer_bytes) {\n\t\t\tunsigned int bytes1 = subs->buffer_bytes - oldptr;\n\n\t\t\tmemcpy(runtime->dma_area + oldptr, cp, bytes1);\n\t\t\tmemcpy(runtime->dma_area, cp + bytes1, bytes - bytes1);\n\t\t} else {\n\t\t\tmemcpy(runtime->dma_area + oldptr, cp, bytes);\n\t\t}\n\t}\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n}\n\nstatic void urb_ctx_queue_advance(struct snd_usb_substream *subs,\n\t\t\t\t  struct urb *urb, unsigned int bytes)\n{\n\tstruct snd_urb_ctx *ctx = urb->context;\n\n\tctx->queued += bytes;\n\tsubs->inflight_bytes += bytes;\n\tsubs->hwptr_done += bytes;\n\tif (subs->hwptr_done >= subs->buffer_bytes)\n\t\tsubs->hwptr_done -= subs->buffer_bytes;\n}\n\nstatic inline void fill_playback_urb_dsd_dop(struct snd_usb_substream *subs,\n\t\t\t\t\t     struct urb *urb, unsigned int bytes)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tunsigned int dst_idx = 0;\n\tunsigned int src_idx = subs->hwptr_done;\n\tunsigned int wrap = subs->buffer_bytes;\n\tu8 *dst = urb->transfer_buffer;\n\tu8 *src = runtime->dma_area;\n\tstatic const u8 marker[] = { 0x05, 0xfa };\n\tunsigned int queued = 0;\n\n\t \n\n\twhile (bytes--) {\n\t\tif (++subs->dsd_dop.byte_idx == 3) {\n\t\t\t \n\t\t\tdst[dst_idx++] = marker[subs->dsd_dop.marker];\n\t\t\tsrc_idx += 2;\n\t\t\tsubs->dsd_dop.byte_idx = 0;\n\n\t\t\tif (++subs->dsd_dop.channel % runtime->channels == 0) {\n\t\t\t\t \n\t\t\t\tsubs->dsd_dop.marker++;\n\t\t\t\tsubs->dsd_dop.marker %= ARRAY_SIZE(marker);\n\t\t\t\tsubs->dsd_dop.channel = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tint idx = (src_idx + subs->dsd_dop.byte_idx - 1) % wrap;\n\n\t\t\tif (subs->cur_audiofmt->dsd_bitrev)\n\t\t\t\tdst[dst_idx++] = bitrev8(src[idx]);\n\t\t\telse\n\t\t\t\tdst[dst_idx++] = src[idx];\n\t\t\tqueued++;\n\t\t}\n\t}\n\n\turb_ctx_queue_advance(subs, urb, queued);\n}\n\n \nstatic void fill_playback_urb_dsd_bitrev(struct snd_usb_substream *subs,\n\t\t\t\t\t struct urb *urb, unsigned int bytes)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tconst u8 *src = runtime->dma_area;\n\tu8 *buf = urb->transfer_buffer;\n\tint i, ofs = subs->hwptr_done;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\t*buf++ = bitrev8(src[ofs]);\n\t\tif (++ofs >= subs->buffer_bytes)\n\t\t\tofs = 0;\n\t}\n\n\turb_ctx_queue_advance(subs, urb, bytes);\n}\n\nstatic void copy_to_urb(struct snd_usb_substream *subs, struct urb *urb,\n\t\t\tint offset, int stride, unsigned int bytes)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\n\tif (subs->hwptr_done + bytes > subs->buffer_bytes) {\n\t\t \n\t\tunsigned int bytes1 = subs->buffer_bytes - subs->hwptr_done;\n\n\t\tmemcpy(urb->transfer_buffer + offset,\n\t\t       runtime->dma_area + subs->hwptr_done, bytes1);\n\t\tmemcpy(urb->transfer_buffer + offset + bytes1,\n\t\t       runtime->dma_area, bytes - bytes1);\n\t} else {\n\t\tmemcpy(urb->transfer_buffer + offset,\n\t\t       runtime->dma_area + subs->hwptr_done, bytes);\n\t}\n\n\turb_ctx_queue_advance(subs, urb, bytes);\n}\n\nstatic unsigned int copy_to_urb_quirk(struct snd_usb_substream *subs,\n\t\t\t\t      struct urb *urb, int stride,\n\t\t\t\t      unsigned int bytes)\n{\n\t__le32 packet_length;\n\tint i;\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tunsigned int length = urb->iso_frame_desc[i].length;\n\t\tunsigned int offset = urb->iso_frame_desc[i].offset;\n\n\t\tpacket_length = cpu_to_le32(length);\n\t\toffset += i * sizeof(packet_length);\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length += sizeof(packet_length);\n\t\tmemcpy(urb->transfer_buffer + offset,\n\t\t       &packet_length, sizeof(packet_length));\n\t\tcopy_to_urb(subs, urb, offset + sizeof(packet_length),\n\t\t\t    stride, length);\n\t}\n\t \n\tbytes += urb->number_of_packets * sizeof(packet_length);\n\treturn bytes;\n}\n\nstatic int prepare_playback_urb(struct snd_usb_substream *subs,\n\t\t\t\tstruct urb *urb,\n\t\t\t\tbool in_stream_lock)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tstruct snd_usb_endpoint *ep = subs->data_endpoint;\n\tstruct snd_urb_ctx *ctx = urb->context;\n\tunsigned int frames, bytes;\n\tint counts;\n\tunsigned int transfer_done, frame_limit, avail = 0;\n\tint i, stride, period_elapsed = 0;\n\tunsigned long flags;\n\tint err = 0;\n\n\tstride = ep->stride;\n\n\tframes = 0;\n\tctx->queued = 0;\n\turb->number_of_packets = 0;\n\n\tspin_lock_irqsave(&subs->lock, flags);\n\tframe_limit = subs->frame_limit + ep->max_urb_frames;\n\ttransfer_done = subs->transfer_done;\n\n\tif (subs->lowlatency_playback &&\n\t    runtime->state != SNDRV_PCM_STATE_DRAINING) {\n\t\tunsigned int hwptr = subs->hwptr_done / stride;\n\n\t\t \n\t\tavail = (runtime->control->appl_ptr - runtime->hw_ptr_base)\n\t\t\t% runtime->buffer_size;\n\t\tif (avail <= hwptr)\n\t\t\tavail += runtime->buffer_size;\n\t\tavail -= hwptr;\n\t}\n\n\tfor (i = 0; i < ctx->packets; i++) {\n\t\tcounts = snd_usb_endpoint_next_packet_size(ep, ctx, i, avail);\n\t\tif (counts < 0)\n\t\t\tbreak;\n\t\t \n\t\turb->iso_frame_desc[i].offset = frames * stride;\n\t\turb->iso_frame_desc[i].length = counts * stride;\n\t\tframes += counts;\n\t\tavail -= counts;\n\t\turb->number_of_packets++;\n\t\ttransfer_done += counts;\n\t\tif (transfer_done >= runtime->period_size) {\n\t\t\ttransfer_done -= runtime->period_size;\n\t\t\tframe_limit = 0;\n\t\t\tperiod_elapsed = 1;\n\t\t\tif (subs->fmt_type == UAC_FORMAT_TYPE_II) {\n\t\t\t\tif (transfer_done > 0) {\n\t\t\t\t\t \n\t\t\t\t\tframes -= transfer_done;\n\t\t\t\t\tcounts -= transfer_done;\n\t\t\t\t\turb->iso_frame_desc[i].length =\n\t\t\t\t\t\tcounts * stride;\n\t\t\t\t\ttransfer_done = 0;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (i < ctx->packets) {\n\t\t\t\t\t \n\t\t\t\t\turb->iso_frame_desc[i].offset =\n\t\t\t\t\t\tframes * stride;\n\t\t\t\t\turb->iso_frame_desc[i].length = 0;\n\t\t\t\t\turb->number_of_packets++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((period_elapsed || transfer_done >= frame_limit) &&\n\t\t    !snd_usb_endpoint_implicit_feedback_sink(ep))\n\t\t\tbreak;\n\t}\n\n\tif (!frames) {\n\t\terr = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tbytes = frames * stride;\n\tsubs->transfer_done = transfer_done;\n\tsubs->frame_limit = frame_limit;\n\tif (unlikely(ep->cur_format == SNDRV_PCM_FORMAT_DSD_U16_LE &&\n\t\t     subs->cur_audiofmt->dsd_dop)) {\n\t\tfill_playback_urb_dsd_dop(subs, urb, bytes);\n\t} else if (unlikely(ep->cur_format == SNDRV_PCM_FORMAT_DSD_U8 &&\n\t\t\t   subs->cur_audiofmt->dsd_bitrev)) {\n\t\tfill_playback_urb_dsd_bitrev(subs, urb, bytes);\n\t} else {\n\t\t \n\t\tif (!subs->tx_length_quirk)\n\t\t\tcopy_to_urb(subs, urb, 0, stride, bytes);\n\t\telse\n\t\t\tbytes = copy_to_urb_quirk(subs, urb, stride, bytes);\n\t\t\t \n\t}\n\n\tsubs->last_frame_number = usb_get_current_frame_number(subs->dev);\n\n\tif (subs->trigger_tstamp_pending_update) {\n\t\t \n\t\tsnd_pcm_gettime(runtime, &runtime->trigger_tstamp);\n\t\tsubs->trigger_tstamp_pending_update = false;\n\t}\n\n\tif (period_elapsed && !subs->running && subs->lowlatency_playback) {\n\t\tsubs->period_elapsed_pending = 1;\n\t\tperiod_elapsed = 0;\n\t}\n\n unlock:\n\tspin_unlock_irqrestore(&subs->lock, flags);\n\tif (err < 0)\n\t\treturn err;\n\turb->transfer_buffer_length = bytes;\n\tif (period_elapsed) {\n\t\tif (in_stream_lock)\n\t\t\tsnd_pcm_period_elapsed_under_stream_lock(subs->pcm_substream);\n\t\telse\n\t\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n\t}\n\treturn 0;\n}\n\n \nstatic void retire_playback_urb(struct snd_usb_substream *subs,\n\t\t\t       struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct snd_urb_ctx *ctx = urb->context;\n\tbool period_elapsed = false;\n\n\tspin_lock_irqsave(&subs->lock, flags);\n\tif (ctx->queued) {\n\t\tif (subs->inflight_bytes >= ctx->queued)\n\t\t\tsubs->inflight_bytes -= ctx->queued;\n\t\telse\n\t\t\tsubs->inflight_bytes = 0;\n\t}\n\n\tsubs->last_frame_number = usb_get_current_frame_number(subs->dev);\n\tif (subs->running) {\n\t\tperiod_elapsed = subs->period_elapsed_pending;\n\t\tsubs->period_elapsed_pending = 0;\n\t}\n\tspin_unlock_irqrestore(&subs->lock, flags);\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n}\n\n \nstatic int snd_usb_pcm_playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\tstruct snd_usb_endpoint *ep;\n\n\tif (!subs->lowlatency_playback || !subs->running)\n\t\treturn 0;\n\tep = subs->data_endpoint;\n\tif (!ep)\n\t\treturn 0;\n\t \n\tif (!ep->active_mask)\n\t\treturn snd_usb_queue_pending_output_urbs(ep, true);\n\treturn 0;\n}\n\nstatic int snd_usb_substream_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t      int cmd)\n{\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsubs->trigger_tstamp_pending_update = true;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t      prepare_playback_urb,\n\t\t\t\t\t      retire_playback_urb,\n\t\t\t\t\t      subs);\n\t\tif (subs->lowlatency_playback &&\n\t\t    cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t\tif (in_free_wheeling_mode(substream->runtime))\n\t\t\t\tsubs->lowlatency_playback = false;\n\t\t\terr = start_endpoints(subs);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t\t\t      NULL, NULL, NULL);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tsubs->running = 1;\n\t\tdev_dbg(&subs->dev->dev, \"%d:%d Start Playback PCM\\n\",\n\t\t\tsubs->cur_audiofmt->iface,\n\t\t\tsubs->cur_audiofmt->altsetting);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstop_endpoints(subs, substream->runtime->state == SNDRV_PCM_STATE_DRAINING);\n\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t      NULL, NULL, NULL);\n\t\tsubs->running = 0;\n\t\tdev_dbg(&subs->dev->dev, \"%d:%d Stop Playback PCM\\n\",\n\t\t\tsubs->cur_audiofmt->iface,\n\t\t\tsubs->cur_audiofmt->altsetting);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      retire_playback_urb,\n\t\t\t\t\t      subs);\n\t\tsubs->running = 0;\n\t\tdev_dbg(&subs->dev->dev, \"%d:%d Pause Playback PCM\\n\",\n\t\t\tsubs->cur_audiofmt->iface,\n\t\t\tsubs->cur_audiofmt->altsetting);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t     int cmd)\n{\n\tint err;\n\tstruct snd_usb_substream *subs = substream->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\terr = start_endpoints(subs);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t      NULL, retire_capture_urb,\n\t\t\t\t\t      subs);\n\t\tsubs->last_frame_number = usb_get_current_frame_number(subs->dev);\n\t\tsubs->running = 1;\n\t\tdev_dbg(&subs->dev->dev, \"%d:%d Start Capture PCM\\n\",\n\t\t\tsubs->cur_audiofmt->iface,\n\t\t\tsubs->cur_audiofmt->altsetting);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstop_endpoints(subs, false);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tsnd_usb_endpoint_set_callback(subs->data_endpoint,\n\t\t\t\t\t      NULL, NULL, NULL);\n\t\tsubs->running = 0;\n\t\tdev_dbg(&subs->dev->dev, \"%d:%d Stop Capture PCM\\n\",\n\t\t\tsubs->cur_audiofmt->iface,\n\t\t\tsubs->cur_audiofmt->altsetting);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct snd_pcm_ops snd_usb_playback_ops = {\n\t.open =\t\tsnd_usb_pcm_open,\n\t.close =\tsnd_usb_pcm_close,\n\t.hw_params =\tsnd_usb_hw_params,\n\t.hw_free =\tsnd_usb_hw_free,\n\t.prepare =\tsnd_usb_pcm_prepare,\n\t.trigger =\tsnd_usb_substream_playback_trigger,\n\t.sync_stop =\tsnd_usb_pcm_sync_stop,\n\t.pointer =\tsnd_usb_pcm_pointer,\n\t.ack =\t\tsnd_usb_pcm_playback_ack,\n};\n\nstatic const struct snd_pcm_ops snd_usb_capture_ops = {\n\t.open =\t\tsnd_usb_pcm_open,\n\t.close =\tsnd_usb_pcm_close,\n\t.hw_params =\tsnd_usb_hw_params,\n\t.hw_free =\tsnd_usb_hw_free,\n\t.prepare =\tsnd_usb_pcm_prepare,\n\t.trigger =\tsnd_usb_substream_capture_trigger,\n\t.sync_stop =\tsnd_usb_pcm_sync_stop,\n\t.pointer =\tsnd_usb_pcm_pointer,\n};\n\nvoid snd_usb_set_pcm_ops(struct snd_pcm *pcm, int stream)\n{\n\tconst struct snd_pcm_ops *ops;\n\n\tops = stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\t&snd_usb_playback_ops : &snd_usb_capture_ops;\n\tsnd_pcm_set_ops(pcm, stream, ops);\n}\n\nvoid snd_usb_preallocate_buffer(struct snd_usb_substream *subs)\n{\n\tstruct snd_pcm *pcm = subs->stream->pcm;\n\tstruct snd_pcm_substream *s = pcm->streams[subs->direction].substream;\n\tstruct device *dev = subs->dev->bus->sysdev;\n\n\tif (snd_usb_use_vmalloc)\n\t\tsnd_pcm_set_managed_buffer(s, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t\t   NULL, 0, 0);\n\telse\n\t\tsnd_pcm_set_managed_buffer(s, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t   dev, 64*1024, 512*1024);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}