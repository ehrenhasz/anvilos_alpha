{
  "module_name": "mixer_s1810c.c",
  "hash_id": "e1d58e9e740637d710db505957d28f87515762d32ccc314c2d381b78bf37a1b5",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_s1810c.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/control.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"mixer_quirks.h\"\n#include \"helper.h\"\n#include \"mixer_s1810c.h\"\n\n#define SC1810C_CMD_REQ\t160\n#define SC1810C_CMD_REQTYPE \\\n\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT)\n#define SC1810C_CMD_F1\t\t0x50617269\n#define SC1810C_CMD_F2\t\t0x14\n\n \nstruct s1810c_ctl_packet {\n\tu32 a;\n\tu32 b;\n\tu32 fixed1;\n\tu32 fixed2;\n\tu32 c;\n\tu32 d;\n\tu32 e;\n};\n\n#define SC1810C_CTL_LINE_SW\t0\n#define SC1810C_CTL_MUTE_SW\t1\n#define SC1810C_CTL_AB_SW\t3\n#define SC1810C_CTL_48V_SW\t4\n\n#define SC1810C_SET_STATE_REQ\t161\n#define SC1810C_SET_STATE_REQTYPE SC1810C_CMD_REQTYPE\n#define SC1810C_SET_STATE_F1\t0x64656D73\n#define SC1810C_SET_STATE_F2\t0xF4\n\n#define SC1810C_GET_STATE_REQ\t162\n#define SC1810C_GET_STATE_REQTYPE \\\n\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN)\n#define SC1810C_GET_STATE_F1\tSC1810C_SET_STATE_F1\n#define SC1810C_GET_STATE_F2\tSC1810C_SET_STATE_F2\n\n#define SC1810C_STATE_F1_IDX\t2\n#define SC1810C_STATE_F2_IDX\t3\n\n \nstruct s1810c_state_packet {\n\tu32 fields[63];\n};\n\n#define SC1810C_STATE_48V_SW\t58\n#define SC1810C_STATE_LINE_SW\t59\n#define SC1810C_STATE_MUTE_SW\t60\n#define SC1810C_STATE_AB_SW\t62\n\nstruct s1810_mixer_state {\n\tuint16_t seqnum;\n\tstruct mutex usb_mutex;\n\tstruct mutex data_mutex;\n};\n\nstatic int\nsnd_s1810c_send_ctl_packet(struct usb_device *dev, u32 a,\n\t\t\t   u32 b, u32 c, u32 d, u32 e)\n{\n\tstruct s1810c_ctl_packet pkt = { 0 };\n\tint ret = 0;\n\n\tpkt.fixed1 = SC1810C_CMD_F1;\n\tpkt.fixed2 = SC1810C_CMD_F2;\n\n\tpkt.a = a;\n\tpkt.b = b;\n\tpkt.c = c;\n\tpkt.d = d;\n\t \n\tpkt.e = (c == 4) ? 0 : e;\n\n\tret = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      SC1810C_CMD_REQ,\n\t\t\t      SC1810C_CMD_REQTYPE, 0, 0, &pkt, sizeof(pkt));\n\tif (ret < 0) {\n\t\tdev_warn(&dev->dev, \"could not send ctl packet\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nsnd_sc1810c_get_status_field(struct usb_device *dev,\n\t\t\t     u32 *field, int field_idx, uint16_t *seqnum)\n{\n\tstruct s1810c_state_packet pkt_out = { { 0 } };\n\tstruct s1810c_state_packet pkt_in = { { 0 } };\n\tint ret = 0;\n\n\tpkt_out.fields[SC1810C_STATE_F1_IDX] = SC1810C_SET_STATE_F1;\n\tpkt_out.fields[SC1810C_STATE_F2_IDX] = SC1810C_SET_STATE_F2;\n\tret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      SC1810C_SET_STATE_REQ,\n\t\t\t      SC1810C_SET_STATE_REQTYPE,\n\t\t\t      (*seqnum), 0, &pkt_out, sizeof(pkt_out));\n\tif (ret < 0) {\n\t\tdev_warn(&dev->dev, \"could not send state packet (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      SC1810C_GET_STATE_REQ,\n\t\t\t      SC1810C_GET_STATE_REQTYPE,\n\t\t\t      (*seqnum), 0, &pkt_in, sizeof(pkt_in));\n\tif (ret < 0) {\n\t\tdev_warn(&dev->dev, \"could not get state field %u (%d)\\n\",\n\t\t\t field_idx, ret);\n\t\treturn ret;\n\t}\n\n\t(*field) = pkt_in.fields[field_idx];\n\t(*seqnum)++;\n\treturn 0;\n}\n\n \nstatic int snd_s1810c_init_mixer_maps(struct snd_usb_audio *chip)\n{\n\tu32 a, b, c, e, n, off;\n\tstruct usb_device *dev = chip->dev;\n\n\t \n\ta = 0x64;\n\te = 0xbc;\n\tfor (n = 0; n < 2; n++) {\n\t\toff = n * 18;\n\t\tfor (b = off; b < 18 + off; b++) {\n\t\t\t \n\t\t\tfor (c = 0; c <= 8; c++) {\n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, e);\n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, e);\n\t\t\t}\n\t\t\t \n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 0, e);\n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 1, e);\n\t\t}\n\t\t \n\t\te = 0xb53bf0;\n\t}\n\n\t \n\ta = 0x65;\n\te = 0x01000000;\n\tfor (b = 1; b < 3; b++) {\n\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 0, e);\n\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 1, e);\n\t}\n\tsnd_s1810c_send_ctl_packet(dev, a, 0, 0, 0, e);\n\tsnd_s1810c_send_ctl_packet(dev, a, 0, 0, 1, e);\n\n\t \n\ta = 0x64;\n\te = 0xbc;\n\tc = 3;\n\tfor (n = 0; n < 2; n++) {\n\t\toff = n * 18;\n\t\tfor (b = off; b < 18 + off; b++) {\n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, e);\n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, e);\n\t\t}\n\t\te = 0xb53bf0;\n\t}\n\n\t \n\ta = 0x65;\n\te = 0x01000000;\n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 0, e);\n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 1, e);\n\n\t \n\ta = 0x65;\n\te = 0x01000000;\n\tfor (b = 0; b < 4; b++) {\n\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 0, e);\n\t\tsnd_s1810c_send_ctl_packet(dev, a, b, 0, 1, e);\n\t}\n\n\t \n\ta = 0x64;\n\te = 0x01000000;\n\tfor (c = 0; c < 4; c++) {\n\t\tfor (b = 0; b < 36; b++) {\n\t\t\tif ((c == 0 && b == 18) ||\t \n\t\t\t    (c == 1 && b == 20) ||\t \n\t\t\t    (c == 2 && b == 22) ||\t \n\t\t\t    (c == 3 && b == 24)) {\t \n\t\t\t\t \n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, e);\n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, 0);\n\t\t\t\tb++;\n\t\t\t\t \n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, 0);\n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, e);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, 0);\n\t\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ta = 0x64;\n\te = 0xbc;\n\tc = 3;\n\tfor (n = 0; n < 2; n++) {\n\t\toff = n * 18;\n\t\tfor (b = off; b < 18 + off; b++) {\n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 0, e);\n\t\t\tsnd_s1810c_send_ctl_packet(dev, a, b, c, 1, e);\n\t\t}\n\t\te = 0xb53bf0;\n\t}\n\n\t \n\ta = 0x65;\n\te = 0x01000000;\n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 0, e);\n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 1, e);\n\n\t \n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 0, e);\n\tsnd_s1810c_send_ctl_packet(dev, a, 3, 0, 1, e);\n\n\treturn 0;\n}\n\n \nstatic int\nsnd_s1810c_get_switch_state(struct usb_mixer_interface *mixer,\n\t\t\t    struct snd_kcontrol *kctl, u32 *state)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tstruct s1810_mixer_state *private = mixer->private_data;\n\tu32 field = 0;\n\tu32 ctl_idx = (u32) (kctl->private_value & 0xFF);\n\tint ret = 0;\n\n\tmutex_lock(&private->usb_mutex);\n\tret = snd_sc1810c_get_status_field(chip->dev, &field,\n\t\t\t\t\t   ctl_idx, &private->seqnum);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t*state = field;\n unlock:\n\tmutex_unlock(&private->usb_mutex);\n\treturn ret ? ret : 0;\n}\n\n \nstatic int\nsnd_s1810c_set_switch_state(struct usb_mixer_interface *mixer,\n\t\t\t    struct snd_kcontrol *kctl)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tstruct s1810_mixer_state *private = mixer->private_data;\n\tu32 pval = (u32) kctl->private_value;\n\tu32 ctl_id = (pval >> 8) & 0xFF;\n\tu32 ctl_val = (pval >> 16) & 0x1;\n\tint ret = 0;\n\n\tmutex_lock(&private->usb_mutex);\n\tret = snd_s1810c_send_ctl_packet(chip->dev, 0, 0, 0, ctl_id, ctl_val);\n\tmutex_unlock(&private->usb_mutex);\n\treturn ret;\n}\n\n \n\nstatic int\nsnd_s1810c_switch_get(struct snd_kcontrol *kctl,\n\t\t      struct snd_ctl_elem_value *ctl_elem)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tstruct s1810_mixer_state *private = mixer->private_data;\n\tu32 pval = (u32) kctl->private_value;\n\tu32 ctl_idx = pval & 0xFF;\n\tu32 state = 0;\n\tint ret = 0;\n\n\tmutex_lock(&private->data_mutex);\n\tret = snd_s1810c_get_switch_state(mixer, kctl, &state);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tswitch (ctl_idx) {\n\tcase SC1810C_STATE_LINE_SW:\n\tcase SC1810C_STATE_AB_SW:\n\t\tctl_elem->value.enumerated.item[0] = (int)state;\n\t\tbreak;\n\tdefault:\n\t\tctl_elem->value.integer.value[0] = (long)state;\n\t}\n\n unlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn (ret < 0) ? ret : 0;\n}\n\nstatic int\nsnd_s1810c_switch_set(struct snd_kcontrol *kctl,\n\t\t      struct snd_ctl_elem_value *ctl_elem)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tstruct s1810_mixer_state *private = mixer->private_data;\n\tu32 pval = (u32) kctl->private_value;\n\tu32 ctl_idx = pval & 0xFF;\n\tu32 curval = 0;\n\tu32 newval = 0;\n\tint ret = 0;\n\n\tmutex_lock(&private->data_mutex);\n\tret = snd_s1810c_get_switch_state(mixer, kctl, &curval);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tswitch (ctl_idx) {\n\tcase SC1810C_STATE_LINE_SW:\n\tcase SC1810C_STATE_AB_SW:\n\t\tnewval = (u32) ctl_elem->value.enumerated.item[0];\n\t\tbreak;\n\tdefault:\n\t\tnewval = (u32) ctl_elem->value.integer.value[0];\n\t}\n\n\tif (curval == newval)\n\t\tgoto unlock;\n\n\tkctl->private_value &= ~(0x1 << 16);\n\tkctl->private_value |= (unsigned int)(newval & 0x1) << 16;\n\tret = snd_s1810c_set_switch_state(mixer, kctl);\n\n unlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn (ret < 0) ? 0 : 1;\n}\n\nstatic int\nsnd_s1810c_switch_init(struct usb_mixer_interface *mixer,\n\t\t       const struct snd_kcontrol_new *new_kctl)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *elem;\n\n\telem = kzalloc(sizeof(struct usb_mixer_elem_info), GFP_KERNEL);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\telem->head.mixer = mixer;\n\telem->control = 0;\n\telem->head.id = 0;\n\telem->channels = 1;\n\n\tkctl = snd_ctl_new1(new_kctl, elem);\n\tif (!kctl) {\n\t\tkfree(elem);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\treturn snd_usb_mixer_add_control(&elem->head, kctl);\n}\n\nstatic int\nsnd_s1810c_line_sw_info(struct snd_kcontrol *kctl,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = {\n\t\t\"Preamp On (Mic/Inst)\",\n\t\t\"Preamp Off (Line in)\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic const struct snd_kcontrol_new snd_s1810c_line_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line 1/2 Source Type\",\n\t.info = snd_s1810c_line_sw_info,\n\t.get = snd_s1810c_switch_get,\n\t.put = snd_s1810c_switch_set,\n\t.private_value = (SC1810C_STATE_LINE_SW | SC1810C_CTL_LINE_SW << 8)\n};\n\nstatic const struct snd_kcontrol_new snd_s1810c_mute_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Mute Main Out Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_s1810c_switch_get,\n\t.put = snd_s1810c_switch_set,\n\t.private_value = (SC1810C_STATE_MUTE_SW | SC1810C_CTL_MUTE_SW << 8)\n};\n\nstatic const struct snd_kcontrol_new snd_s1810c_48v_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"48V Phantom Power On Mic Inputs Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_s1810c_switch_get,\n\t.put = snd_s1810c_switch_set,\n\t.private_value = (SC1810C_STATE_48V_SW | SC1810C_CTL_48V_SW << 8)\n};\n\nstatic int\nsnd_s1810c_ab_sw_info(struct snd_kcontrol *kctl,\n\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = {\n\t\t\"1/2\",\n\t\t\"3/4\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic const struct snd_kcontrol_new snd_s1810c_ab_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Headphone 1 Source Route\",\n\t.info = snd_s1810c_ab_sw_info,\n\t.get = snd_s1810c_switch_get,\n\t.put = snd_s1810c_switch_set,\n\t.private_value = (SC1810C_STATE_AB_SW | SC1810C_CTL_AB_SW << 8)\n};\n\nstatic void snd_sc1810_mixer_state_free(struct usb_mixer_interface *mixer)\n{\n\tstruct s1810_mixer_state *private = mixer->private_data;\n\tkfree(private);\n\tmixer->private_data = NULL;\n}\n\n \nint snd_sc1810_init_mixer(struct usb_mixer_interface *mixer)\n{\n\tstruct s1810_mixer_state *private = NULL;\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tstruct usb_device *dev = chip->dev;\n\tint ret = 0;\n\n\t \n\tif (!list_empty(&chip->mixer_list))\n\t\treturn 0;\n\n\tdev_info(&dev->dev,\n\t\t \"Presonus Studio 1810c, device_setup: %u\\n\", chip->setup);\n\tif (chip->setup == 1)\n\t\tdev_info(&dev->dev, \"(8out/18in @ 48kHz)\\n\");\n\telse if (chip->setup == 2)\n\t\tdev_info(&dev->dev, \"(6out/8in @ 192kHz)\\n\");\n\telse\n\t\tdev_info(&dev->dev, \"(8out/14in @ 96kHz)\\n\");\n\n\tret = snd_s1810c_init_mixer_maps(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprivate = kzalloc(sizeof(struct s1810_mixer_state), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&private->usb_mutex);\n\tmutex_init(&private->data_mutex);\n\n\tmixer->private_data = private;\n\tmixer->private_free = snd_sc1810_mixer_state_free;\n\n\tprivate->seqnum = 1;\n\n\tret = snd_s1810c_switch_init(mixer, &snd_s1810c_line_sw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_s1810c_switch_init(mixer, &snd_s1810c_mute_sw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_s1810c_switch_init(mixer, &snd_s1810c_48v_sw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_s1810c_switch_init(mixer, &snd_s1810c_ab_sw);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}