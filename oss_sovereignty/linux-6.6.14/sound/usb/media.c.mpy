{
  "module_name": "media.c",
  "hash_id": "5820661285ef2d474de1e53e5aedce44715b33bd45165bca27fe972dc2778744",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/media.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <sound/pcm.h>\n#include <sound/core.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"mixer.h\"\n#include \"media.h\"\n\nint snd_media_stream_init(struct snd_usb_substream *subs, struct snd_pcm *pcm,\n\t\t\t  int stream)\n{\n\tstruct media_device *mdev;\n\tstruct media_ctl *mctl;\n\tstruct device *pcm_dev = pcm->streams[stream].dev;\n\tu32 intf_type;\n\tint ret = 0;\n\tu16 mixer_pad;\n\tstruct media_entity *entity;\n\n\tmdev = subs->stream->chip->media_dev;\n\tif (!mdev)\n\t\treturn 0;\n\n\tif (subs->media_ctl)\n\t\treturn 0;\n\n\t \n\tmctl = kzalloc(sizeof(*mctl), GFP_KERNEL);\n\tif (!mctl)\n\t\treturn -ENOMEM;\n\n\tmctl->media_dev = mdev;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tintf_type = MEDIA_INTF_T_ALSA_PCM_PLAYBACK;\n\t\tmctl->media_entity.function = MEDIA_ENT_F_AUDIO_PLAYBACK;\n\t\tmctl->media_pad.flags = MEDIA_PAD_FL_SOURCE;\n\t\tmixer_pad = 1;\n\t} else {\n\t\tintf_type = MEDIA_INTF_T_ALSA_PCM_CAPTURE;\n\t\tmctl->media_entity.function = MEDIA_ENT_F_AUDIO_CAPTURE;\n\t\tmctl->media_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tmixer_pad = 2;\n\t}\n\tmctl->media_entity.name = pcm->name;\n\tmedia_entity_pads_init(&mctl->media_entity, 1, &mctl->media_pad);\n\tret =  media_device_register_entity(mctl->media_dev,\n\t\t\t\t\t    &mctl->media_entity);\n\tif (ret)\n\t\tgoto free_mctl;\n\n\tmctl->intf_devnode = media_devnode_create(mdev, intf_type, 0,\n\t\t\t\t\t\t  MAJOR(pcm_dev->devt),\n\t\t\t\t\t\t  MINOR(pcm_dev->devt));\n\tif (!mctl->intf_devnode) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_entity;\n\t}\n\tmctl->intf_link = media_create_intf_link(&mctl->media_entity,\n\t\t\t\t\t\t &mctl->intf_devnode->intf,\n\t\t\t\t\t\t MEDIA_LNK_FL_ENABLED);\n\tif (!mctl->intf_link) {\n\t\tret = -ENOMEM;\n\t\tgoto devnode_remove;\n\t}\n\n\t \n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tswitch (entity->function) {\n\t\tcase MEDIA_ENT_F_AUDIO_MIXER:\n\t\t\tret = media_create_pad_link(entity, mixer_pad,\n\t\t\t\t\t\t    &mctl->media_entity, 0,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret)\n\t\t\t\tgoto remove_intf_link;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsubs->media_ctl = mctl;\n\treturn 0;\n\nremove_intf_link:\n\tmedia_remove_intf_link(mctl->intf_link);\ndevnode_remove:\n\tmedia_devnode_remove(mctl->intf_devnode);\nunregister_entity:\n\tmedia_device_unregister_entity(&mctl->media_entity);\nfree_mctl:\n\tkfree(mctl);\n\treturn ret;\n}\n\nvoid snd_media_stream_delete(struct snd_usb_substream *subs)\n{\n\tstruct media_ctl *mctl = subs->media_ctl;\n\n\tif (mctl) {\n\t\tstruct media_device *mdev;\n\n\t\tmdev = mctl->media_dev;\n\t\tif (mdev && media_devnode_is_registered(mdev->devnode)) {\n\t\t\tmedia_devnode_remove(mctl->intf_devnode);\n\t\t\tmedia_device_unregister_entity(&mctl->media_entity);\n\t\t\tmedia_entity_cleanup(&mctl->media_entity);\n\t\t}\n\t\tkfree(mctl);\n\t\tsubs->media_ctl = NULL;\n\t}\n}\n\nint snd_media_start_pipeline(struct snd_usb_substream *subs)\n{\n\tstruct media_ctl *mctl = subs->media_ctl;\n\tint ret = 0;\n\n\tif (!mctl)\n\t\treturn 0;\n\n\tmutex_lock(&mctl->media_dev->graph_mutex);\n\tif (mctl->media_dev->enable_source)\n\t\tret = mctl->media_dev->enable_source(&mctl->media_entity,\n\t\t\t\t\t\t     &mctl->media_pipe);\n\tmutex_unlock(&mctl->media_dev->graph_mutex);\n\treturn ret;\n}\n\nvoid snd_media_stop_pipeline(struct snd_usb_substream *subs)\n{\n\tstruct media_ctl *mctl = subs->media_ctl;\n\n\tif (!mctl)\n\t\treturn;\n\n\tmutex_lock(&mctl->media_dev->graph_mutex);\n\tif (mctl->media_dev->disable_source)\n\t\tmctl->media_dev->disable_source(&mctl->media_entity);\n\tmutex_unlock(&mctl->media_dev->graph_mutex);\n}\n\nstatic int snd_media_mixer_init(struct snd_usb_audio *chip)\n{\n\tstruct device *ctl_dev = chip->card->ctl_dev;\n\tstruct media_intf_devnode *ctl_intf;\n\tstruct usb_mixer_interface *mixer;\n\tstruct media_device *mdev = chip->media_dev;\n\tstruct media_mixer_ctl *mctl;\n\tu32 intf_type = MEDIA_INTF_T_ALSA_CONTROL;\n\tint ret;\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tctl_intf = chip->ctl_intf_media_devnode;\n\tif (!ctl_intf) {\n\t\tctl_intf = media_devnode_create(mdev, intf_type, 0,\n\t\t\t\t\t\tMAJOR(ctl_dev->devt),\n\t\t\t\t\t\tMINOR(ctl_dev->devt));\n\t\tif (!ctl_intf)\n\t\t\treturn -ENOMEM;\n\t\tchip->ctl_intf_media_devnode = ctl_intf;\n\t}\n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\n\t\tif (mixer->media_mixer_ctl)\n\t\t\tcontinue;\n\n\t\t \n\t\tmctl = kzalloc(sizeof(*mctl), GFP_KERNEL);\n\t\tif (!mctl)\n\t\t\treturn -ENOMEM;\n\n\t\tmctl->media_dev = mdev;\n\t\tmctl->media_entity.function = MEDIA_ENT_F_AUDIO_MIXER;\n\t\tmctl->media_entity.name = chip->card->mixername;\n\t\tmctl->media_pad[0].flags = MEDIA_PAD_FL_SINK;\n\t\tmctl->media_pad[1].flags = MEDIA_PAD_FL_SOURCE;\n\t\tmctl->media_pad[2].flags = MEDIA_PAD_FL_SOURCE;\n\t\tmedia_entity_pads_init(&mctl->media_entity, MEDIA_MIXER_PAD_MAX,\n\t\t\t\t  mctl->media_pad);\n\t\tret =  media_device_register_entity(mctl->media_dev,\n\t\t\t\t\t\t    &mctl->media_entity);\n\t\tif (ret) {\n\t\t\tkfree(mctl);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmctl->intf_link = media_create_intf_link(&mctl->media_entity,\n\t\t\t\t\t\t\t &ctl_intf->intf,\n\t\t\t\t\t\t\t MEDIA_LNK_FL_ENABLED);\n\t\tif (!mctl->intf_link) {\n\t\t\tmedia_device_unregister_entity(&mctl->media_entity);\n\t\t\tmedia_entity_cleanup(&mctl->media_entity);\n\t\t\tkfree(mctl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmctl->intf_devnode = ctl_intf;\n\t\tmixer->media_mixer_ctl = mctl;\n\t}\n\treturn 0;\n}\n\nstatic void snd_media_mixer_delete(struct snd_usb_audio *chip)\n{\n\tstruct usb_mixer_interface *mixer;\n\tstruct media_device *mdev = chip->media_dev;\n\n\tif (!mdev)\n\t\treturn;\n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\tstruct media_mixer_ctl *mctl;\n\n\t\tmctl = mixer->media_mixer_ctl;\n\t\tif (!mixer->media_mixer_ctl)\n\t\t\tcontinue;\n\n\t\tif (media_devnode_is_registered(mdev->devnode)) {\n\t\t\tmedia_device_unregister_entity(&mctl->media_entity);\n\t\t\tmedia_entity_cleanup(&mctl->media_entity);\n\t\t}\n\t\tkfree(mctl);\n\t\tmixer->media_mixer_ctl = NULL;\n\t}\n\tif (media_devnode_is_registered(mdev->devnode))\n\t\tmedia_devnode_remove(chip->ctl_intf_media_devnode);\n\tchip->ctl_intf_media_devnode = NULL;\n}\n\nint snd_media_device_create(struct snd_usb_audio *chip,\n\t\t\tstruct usb_interface *iface)\n{\n\tstruct media_device *mdev;\n\tstruct usb_device *usbdev = interface_to_usbdev(iface);\n\tint ret = 0;\n\n\t \n\tif (chip->media_dev) {\n\t\tmdev = chip->media_dev;\n\t\tgoto snd_mixer_init;\n\t}\n\n\tmdev = media_device_usb_allocate(usbdev, KBUILD_MODNAME, THIS_MODULE);\n\tif (IS_ERR(mdev))\n\t\treturn -ENOMEM;\n\n\t \n\tchip->media_dev = mdev;\n\nsnd_mixer_init:\n\t \n\tret = snd_media_mixer_init(chip);\n\t \n\tif (ret)\n\t\tdev_err(&usbdev->dev,\n\t\t\t\"Couldn't create media mixer entities. Error: %d\\n\",\n\t\t\tret);\n\n\tif (!media_devnode_is_registered(mdev->devnode)) {\n\t\t \n\t\tif (ret)\n\t\t\tgoto create_fail;\n\n\t\t \n\t\tret = media_device_register(mdev);\ncreate_fail:\n\t\tif (ret) {\n\t\t\tsnd_media_mixer_delete(chip);\n\t\t\tmedia_device_delete(mdev, KBUILD_MODNAME, THIS_MODULE);\n\t\t\t \n\t\t\tchip->media_dev = NULL;\n\t\t\tdev_err(&usbdev->dev,\n\t\t\t\t\"Couldn't register media device. Error: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid snd_media_device_delete(struct snd_usb_audio *chip)\n{\n\tstruct media_device *mdev = chip->media_dev;\n\tstruct snd_usb_stream *stream;\n\n\t \n\tlist_for_each_entry(stream, &chip->pcm_list, list) {\n\t\tsnd_media_stream_delete(&stream->substream[0]);\n\t\tsnd_media_stream_delete(&stream->substream[1]);\n\t}\n\n\tsnd_media_mixer_delete(chip);\n\n\tif (mdev) {\n\t\tmedia_device_delete(mdev, KBUILD_MODNAME, THIS_MODULE);\n\t\tchip->media_dev = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}