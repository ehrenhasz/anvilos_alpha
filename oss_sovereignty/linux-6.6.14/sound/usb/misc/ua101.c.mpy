{
  "module_name": "ua101.c",
  "hash_id": "9872dc2c105db49cdb1ce66d3d148293b5583cd8135a5275fc6bb03bf446f88f",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/misc/ua101.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"../usbaudio.h\"\n#include \"../midi.h\"\n\nMODULE_DESCRIPTION(\"Edirol UA-101/1000 driver\");\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n#define MIN_QUEUE_LENGTH\t12\n \n#define MAX_QUEUE_LENGTH\t30\n \n#define DEFAULT_QUEUE_LENGTH\t21\n\n#define MAX_PACKET_SIZE\t\t672  \n#define MAX_MEMORY_BUFFERS\tDIV_ROUND_UP(MAX_QUEUE_LENGTH, \\\n\t\t\t\t\t     PAGE_SIZE / MAX_PACKET_SIZE)\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nstatic unsigned int queue_length = 21;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"card index\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"enable card\");\nmodule_param(queue_length, uint, 0644);\nMODULE_PARM_DESC(queue_length, \"USB queue length in microframes, \"\n\t\t __stringify(MIN_QUEUE_LENGTH)\"-\"__stringify(MAX_QUEUE_LENGTH));\n\nenum {\n\tINTF_PLAYBACK,\n\tINTF_CAPTURE,\n\tINTF_MIDI,\n\n\tINTF_COUNT\n};\n\n \nenum {\n\tUSB_CAPTURE_RUNNING,\n\tUSB_PLAYBACK_RUNNING,\n\tALSA_CAPTURE_OPEN,\n\tALSA_PLAYBACK_OPEN,\n\tALSA_CAPTURE_RUNNING,\n\tALSA_PLAYBACK_RUNNING,\n\tCAPTURE_URB_COMPLETED,\n\tPLAYBACK_URB_COMPLETED,\n\tDISCONNECTED,\n};\n\nstruct ua101 {\n\tstruct usb_device *dev;\n\tstruct snd_card *card;\n\tstruct usb_interface *intf[INTF_COUNT];\n\tint card_index;\n\tstruct snd_pcm *pcm;\n\tstruct list_head midi_list;\n\tu64 format_bit;\n\tunsigned int rate;\n\tunsigned int packets_per_second;\n\tspinlock_t lock;\n\tstruct mutex mutex;\n\tunsigned long states;\n\n\t \n\tunsigned int rate_feedback_start;\n\tunsigned int rate_feedback_count;\n\tu8 rate_feedback[MAX_QUEUE_LENGTH];\n\n\tstruct list_head ready_playback_urbs;\n\tstruct work_struct playback_work;\n\twait_queue_head_t alsa_capture_wait;\n\twait_queue_head_t rate_feedback_wait;\n\twait_queue_head_t alsa_playback_wait;\n\tstruct ua101_stream {\n\t\tstruct snd_pcm_substream *substream;\n\t\tunsigned int usb_pipe;\n\t\tunsigned int channels;\n\t\tunsigned int frame_bytes;\n\t\tunsigned int max_packet_bytes;\n\t\tunsigned int period_pos;\n\t\tunsigned int buffer_pos;\n\t\tunsigned int queue_length;\n\t\tstruct ua101_urb {\n\t\t\tstruct urb urb;\n\t\t\tstruct usb_iso_packet_descriptor iso_frame_desc[1];\n\t\t\tstruct list_head ready_list;\n\t\t} *urbs[MAX_QUEUE_LENGTH];\n\t\tstruct {\n\t\t\tunsigned int size;\n\t\t\tvoid *addr;\n\t\t\tdma_addr_t dma;\n\t\t} buffers[MAX_MEMORY_BUFFERS];\n\t} capture, playback;\n};\n\nstatic DEFINE_MUTEX(devices_mutex);\nstatic unsigned int devices_used;\nstatic struct usb_driver ua101_driver;\n\nstatic void abort_alsa_playback(struct ua101 *ua);\nstatic void abort_alsa_capture(struct ua101 *ua);\n\nstatic const char *usb_error_string(int err)\n{\n\tswitch (err) {\n\tcase -ENODEV:\n\t\treturn \"no device\";\n\tcase -ENOENT:\n\t\treturn \"endpoint not enabled\";\n\tcase -EPIPE:\n\t\treturn \"endpoint stalled\";\n\tcase -ENOSPC:\n\t\treturn \"not enough bandwidth\";\n\tcase -ESHUTDOWN:\n\t\treturn \"device disabled\";\n\tcase -EHOSTUNREACH:\n\t\treturn \"device suspended\";\n\tcase -EINVAL:\n\tcase -EAGAIN:\n\tcase -EFBIG:\n\tcase -EMSGSIZE:\n\t\treturn \"internal error\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}\n\nstatic void abort_usb_capture(struct ua101 *ua)\n{\n\tif (test_and_clear_bit(USB_CAPTURE_RUNNING, &ua->states)) {\n\t\twake_up(&ua->alsa_capture_wait);\n\t\twake_up(&ua->rate_feedback_wait);\n\t}\n}\n\nstatic void abort_usb_playback(struct ua101 *ua)\n{\n\tif (test_and_clear_bit(USB_PLAYBACK_RUNNING, &ua->states))\n\t\twake_up(&ua->alsa_playback_wait);\n}\n\nstatic void playback_urb_complete(struct urb *usb_urb)\n{\n\tstruct ua101_urb *urb = (struct ua101_urb *)usb_urb;\n\tstruct ua101 *ua = urb->urb.context;\n\tunsigned long flags;\n\n\tif (unlikely(urb->urb.status == -ENOENT ||\t \n\t\t     urb->urb.status == -ENODEV ||\t \n\t\t     urb->urb.status == -ECONNRESET ||\t \n\t\t     urb->urb.status == -ESHUTDOWN)) {\t \n\t\tabort_usb_playback(ua);\n\t\tabort_alsa_playback(ua);\n\t\treturn;\n\t}\n\n\tif (test_bit(USB_PLAYBACK_RUNNING, &ua->states)) {\n\t\t \n\t\tspin_lock_irqsave(&ua->lock, flags);\n\t\tlist_add_tail(&urb->ready_list, &ua->ready_playback_urbs);\n\t\tif (ua->rate_feedback_count > 0)\n\t\t\tqueue_work(system_highpri_wq, &ua->playback_work);\n\t\tua->playback.substream->runtime->delay -=\n\t\t\t\turb->urb.iso_frame_desc[0].length /\n\t\t\t\t\t\tua->playback.frame_bytes;\n\t\tspin_unlock_irqrestore(&ua->lock, flags);\n\t}\n}\n\nstatic void first_playback_urb_complete(struct urb *urb)\n{\n\tstruct ua101 *ua = urb->context;\n\n\turb->complete = playback_urb_complete;\n\tplayback_urb_complete(urb);\n\n\tset_bit(PLAYBACK_URB_COMPLETED, &ua->states);\n\twake_up(&ua->alsa_playback_wait);\n}\n\n \nstatic bool copy_playback_data(struct ua101_stream *stream, struct urb *urb,\n\t\t\t       unsigned int frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int frame_bytes, frames1;\n\tconst u8 *source;\n\n\truntime = stream->substream->runtime;\n\tframe_bytes = stream->frame_bytes;\n\tsource = runtime->dma_area + stream->buffer_pos * frame_bytes;\n\tif (stream->buffer_pos + frames <= runtime->buffer_size) {\n\t\tmemcpy(urb->transfer_buffer, source, frames * frame_bytes);\n\t} else {\n\t\t \n\t\tframes1 = runtime->buffer_size - stream->buffer_pos;\n\t\tmemcpy(urb->transfer_buffer, source, frames1 * frame_bytes);\n\t\tmemcpy(urb->transfer_buffer + frames1 * frame_bytes,\n\t\t       runtime->dma_area, (frames - frames1) * frame_bytes);\n\t}\n\n\tstream->buffer_pos += frames;\n\tif (stream->buffer_pos >= runtime->buffer_size)\n\t\tstream->buffer_pos -= runtime->buffer_size;\n\tstream->period_pos += frames;\n\tif (stream->period_pos >= runtime->period_size) {\n\t\tstream->period_pos -= runtime->period_size;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline void add_with_wraparound(struct ua101 *ua,\n\t\t\t\t       unsigned int *value, unsigned int add)\n{\n\t*value += add;\n\tif (*value >= ua->playback.queue_length)\n\t\t*value -= ua->playback.queue_length;\n}\n\nstatic void playback_work(struct work_struct *work)\n{\n\tstruct ua101 *ua = container_of(work, struct ua101, playback_work);\n\tunsigned long flags;\n\tunsigned int frames;\n\tstruct ua101_urb *urb;\n\tbool do_period_elapsed = false;\n\tint err;\n\n\tif (unlikely(!test_bit(USB_PLAYBACK_RUNNING, &ua->states)))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&ua->lock, flags);\n\twhile (ua->rate_feedback_count > 0 &&\n\t       !list_empty(&ua->ready_playback_urbs)) {\n\t\t \n\t\tframes = ua->rate_feedback[ua->rate_feedback_start];\n\t\tadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\n\t\tua->rate_feedback_count--;\n\n\t\t \n\t\turb = list_first_entry(&ua->ready_playback_urbs,\n\t\t\t\t       struct ua101_urb, ready_list);\n\t\tlist_del(&urb->ready_list);\n\n\t\t \n\t\turb->urb.iso_frame_desc[0].length =\n\t\t\tframes * ua->playback.frame_bytes;\n\t\tif (test_bit(ALSA_PLAYBACK_RUNNING, &ua->states))\n\t\t\tdo_period_elapsed |= copy_playback_data(&ua->playback,\n\t\t\t\t\t\t\t\t&urb->urb,\n\t\t\t\t\t\t\t\tframes);\n\t\telse\n\t\t\tmemset(urb->urb.transfer_buffer, 0,\n\t\t\t       urb->urb.iso_frame_desc[0].length);\n\n\t\t \n\t\terr = usb_submit_urb(&urb->urb, GFP_ATOMIC);\n\t\tif (unlikely(err < 0)) {\n\t\t\tspin_unlock_irqrestore(&ua->lock, flags);\n\t\t\tabort_usb_playback(ua);\n\t\t\tabort_alsa_playback(ua);\n\t\t\tdev_err(&ua->dev->dev, \"USB request error %d: %s\\n\",\n\t\t\t\terr, usb_error_string(err));\n\t\t\treturn;\n\t\t}\n\t\tua->playback.substream->runtime->delay += frames;\n\t}\n\tspin_unlock_irqrestore(&ua->lock, flags);\n\tif (do_period_elapsed)\n\t\tsnd_pcm_period_elapsed(ua->playback.substream);\n}\n\n \nstatic bool copy_capture_data(struct ua101_stream *stream, struct urb *urb,\n\t\t\t      unsigned int frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int frame_bytes, frames1;\n\tu8 *dest;\n\n\truntime = stream->substream->runtime;\n\tframe_bytes = stream->frame_bytes;\n\tdest = runtime->dma_area + stream->buffer_pos * frame_bytes;\n\tif (stream->buffer_pos + frames <= runtime->buffer_size) {\n\t\tmemcpy(dest, urb->transfer_buffer, frames * frame_bytes);\n\t} else {\n\t\t \n\t\tframes1 = runtime->buffer_size - stream->buffer_pos;\n\t\tmemcpy(dest, urb->transfer_buffer, frames1 * frame_bytes);\n\t\tmemcpy(runtime->dma_area,\n\t\t       urb->transfer_buffer + frames1 * frame_bytes,\n\t\t       (frames - frames1) * frame_bytes);\n\t}\n\n\tstream->buffer_pos += frames;\n\tif (stream->buffer_pos >= runtime->buffer_size)\n\t\tstream->buffer_pos -= runtime->buffer_size;\n\tstream->period_pos += frames;\n\tif (stream->period_pos >= runtime->period_size) {\n\t\tstream->period_pos -= runtime->period_size;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void capture_urb_complete(struct urb *urb)\n{\n\tstruct ua101 *ua = urb->context;\n\tstruct ua101_stream *stream = &ua->capture;\n\tunsigned long flags;\n\tunsigned int frames, write_ptr;\n\tbool do_period_elapsed;\n\tint err;\n\n\tif (unlikely(urb->status == -ENOENT ||\t\t \n\t\t     urb->status == -ENODEV ||\t\t \n\t\t     urb->status == -ECONNRESET ||\t \n\t\t     urb->status == -ESHUTDOWN))\t \n\t\tgoto stream_stopped;\n\n\tif (urb->status >= 0 && urb->iso_frame_desc[0].status >= 0)\n\t\tframes = urb->iso_frame_desc[0].actual_length /\n\t\t\tstream->frame_bytes;\n\telse\n\t\tframes = 0;\n\n\tspin_lock_irqsave(&ua->lock, flags);\n\n\tif (frames > 0 && test_bit(ALSA_CAPTURE_RUNNING, &ua->states))\n\t\tdo_period_elapsed = copy_capture_data(stream, urb, frames);\n\telse\n\t\tdo_period_elapsed = false;\n\n\tif (test_bit(USB_CAPTURE_RUNNING, &ua->states)) {\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (unlikely(err < 0)) {\n\t\t\tspin_unlock_irqrestore(&ua->lock, flags);\n\t\t\tdev_err(&ua->dev->dev, \"USB request error %d: %s\\n\",\n\t\t\t\terr, usb_error_string(err));\n\t\t\tgoto stream_stopped;\n\t\t}\n\n\t\t \n\t\twrite_ptr = ua->rate_feedback_start;\n\t\tadd_with_wraparound(ua, &write_ptr, ua->rate_feedback_count);\n\t\tua->rate_feedback[write_ptr] = frames;\n\t\tif (ua->rate_feedback_count < ua->playback.queue_length) {\n\t\t\tua->rate_feedback_count++;\n\t\t\tif (ua->rate_feedback_count ==\n\t\t\t\t\t\tua->playback.queue_length)\n\t\t\t\twake_up(&ua->rate_feedback_wait);\n\t\t} else {\n\t\t\t \n\t\t\tadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\n\t\t}\n\t\tif (test_bit(USB_PLAYBACK_RUNNING, &ua->states) &&\n\t\t    !list_empty(&ua->ready_playback_urbs))\n\t\t\tqueue_work(system_highpri_wq, &ua->playback_work);\n\t}\n\n\tspin_unlock_irqrestore(&ua->lock, flags);\n\n\tif (do_period_elapsed)\n\t\tsnd_pcm_period_elapsed(stream->substream);\n\n\treturn;\n\nstream_stopped:\n\tabort_usb_playback(ua);\n\tabort_usb_capture(ua);\n\tabort_alsa_playback(ua);\n\tabort_alsa_capture(ua);\n}\n\nstatic void first_capture_urb_complete(struct urb *urb)\n{\n\tstruct ua101 *ua = urb->context;\n\n\turb->complete = capture_urb_complete;\n\tcapture_urb_complete(urb);\n\n\tset_bit(CAPTURE_URB_COMPLETED, &ua->states);\n\twake_up(&ua->alsa_capture_wait);\n}\n\nstatic int submit_stream_urbs(struct ua101 *ua, struct ua101_stream *stream)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < stream->queue_length; ++i) {\n\t\tint err = usb_submit_urb(&stream->urbs[i]->urb, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\tdev_err(&ua->dev->dev, \"USB request error %d: %s\\n\",\n\t\t\t\terr, usb_error_string(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void kill_stream_urbs(struct ua101_stream *stream)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < stream->queue_length; ++i)\n\t\tif (stream->urbs[i])\n\t\t\tusb_kill_urb(&stream->urbs[i]->urb);\n}\n\nstatic int enable_iso_interface(struct ua101 *ua, unsigned int intf_index)\n{\n\tstruct usb_host_interface *alts;\n\n\talts = ua->intf[intf_index]->cur_altsetting;\n\tif (alts->desc.bAlternateSetting != 1) {\n\t\tint err = usb_set_interface(ua->dev,\n\t\t\t\t\t    alts->desc.bInterfaceNumber, 1);\n\t\tif (err < 0) {\n\t\t\tdev_err(&ua->dev->dev,\n\t\t\t\t\"cannot initialize interface; error %d: %s\\n\",\n\t\t\t\terr, usb_error_string(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void disable_iso_interface(struct ua101 *ua, unsigned int intf_index)\n{\n\tstruct usb_host_interface *alts;\n\n\tif (!ua->intf[intf_index])\n\t\treturn;\n\n\talts = ua->intf[intf_index]->cur_altsetting;\n\tif (alts->desc.bAlternateSetting != 0) {\n\t\tint err = usb_set_interface(ua->dev,\n\t\t\t\t\t    alts->desc.bInterfaceNumber, 0);\n\t\tif (err < 0 && !test_bit(DISCONNECTED, &ua->states))\n\t\t\tdev_warn(&ua->dev->dev,\n\t\t\t\t \"interface reset failed; error %d: %s\\n\",\n\t\t\t\t err, usb_error_string(err));\n\t}\n}\n\nstatic void stop_usb_capture(struct ua101 *ua)\n{\n\tclear_bit(USB_CAPTURE_RUNNING, &ua->states);\n\n\tkill_stream_urbs(&ua->capture);\n\n\tdisable_iso_interface(ua, INTF_CAPTURE);\n}\n\nstatic int start_usb_capture(struct ua101 *ua)\n{\n\tint err;\n\n\tif (test_bit(DISCONNECTED, &ua->states))\n\t\treturn -ENODEV;\n\n\tif (test_bit(USB_CAPTURE_RUNNING, &ua->states))\n\t\treturn 0;\n\n\tkill_stream_urbs(&ua->capture);\n\n\terr = enable_iso_interface(ua, INTF_CAPTURE);\n\tif (err < 0)\n\t\treturn err;\n\n\tclear_bit(CAPTURE_URB_COMPLETED, &ua->states);\n\tua->capture.urbs[0]->urb.complete = first_capture_urb_complete;\n\tua->rate_feedback_start = 0;\n\tua->rate_feedback_count = 0;\n\n\tset_bit(USB_CAPTURE_RUNNING, &ua->states);\n\terr = submit_stream_urbs(ua, &ua->capture);\n\tif (err < 0)\n\t\tstop_usb_capture(ua);\n\treturn err;\n}\n\nstatic void stop_usb_playback(struct ua101 *ua)\n{\n\tclear_bit(USB_PLAYBACK_RUNNING, &ua->states);\n\n\tkill_stream_urbs(&ua->playback);\n\n\tcancel_work_sync(&ua->playback_work);\n\n\tdisable_iso_interface(ua, INTF_PLAYBACK);\n}\n\nstatic int start_usb_playback(struct ua101 *ua)\n{\n\tunsigned int i, frames;\n\tstruct urb *urb;\n\tint err = 0;\n\n\tif (test_bit(DISCONNECTED, &ua->states))\n\t\treturn -ENODEV;\n\n\tif (test_bit(USB_PLAYBACK_RUNNING, &ua->states))\n\t\treturn 0;\n\n\tkill_stream_urbs(&ua->playback);\n\tcancel_work_sync(&ua->playback_work);\n\n\terr = enable_iso_interface(ua, INTF_PLAYBACK);\n\tif (err < 0)\n\t\treturn err;\n\n\tclear_bit(PLAYBACK_URB_COMPLETED, &ua->states);\n\tua->playback.urbs[0]->urb.complete =\n\t\tfirst_playback_urb_complete;\n\tspin_lock_irq(&ua->lock);\n\tINIT_LIST_HEAD(&ua->ready_playback_urbs);\n\tspin_unlock_irq(&ua->lock);\n\n\t \n\twait_event(ua->rate_feedback_wait,\n\t\t   ua->rate_feedback_count >= ua->playback.queue_length ||\n\t\t   !test_bit(USB_CAPTURE_RUNNING, &ua->states) ||\n\t\t   test_bit(DISCONNECTED, &ua->states));\n\tif (test_bit(DISCONNECTED, &ua->states)) {\n\t\tstop_usb_playback(ua);\n\t\treturn -ENODEV;\n\t}\n\tif (!test_bit(USB_CAPTURE_RUNNING, &ua->states)) {\n\t\tstop_usb_playback(ua);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < ua->playback.queue_length; ++i) {\n\t\t \n\t\tspin_lock_irq(&ua->lock);\n\t\tframes = ua->rate_feedback[ua->rate_feedback_start];\n\t\tadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\n\t\tua->rate_feedback_count--;\n\t\tspin_unlock_irq(&ua->lock);\n\t\turb = &ua->playback.urbs[i]->urb;\n\t\turb->iso_frame_desc[0].length =\n\t\t\tframes * ua->playback.frame_bytes;\n\t\tmemset(urb->transfer_buffer, 0,\n\t\t       urb->iso_frame_desc[0].length);\n\t}\n\n\tset_bit(USB_PLAYBACK_RUNNING, &ua->states);\n\terr = submit_stream_urbs(ua, &ua->playback);\n\tif (err < 0)\n\t\tstop_usb_playback(ua);\n\treturn err;\n}\n\nstatic void abort_alsa_capture(struct ua101 *ua)\n{\n\tif (test_bit(ALSA_CAPTURE_RUNNING, &ua->states))\n\t\tsnd_pcm_stop_xrun(ua->capture.substream);\n}\n\nstatic void abort_alsa_playback(struct ua101 *ua)\n{\n\tif (test_bit(ALSA_PLAYBACK_RUNNING, &ua->states))\n\t\tsnd_pcm_stop_xrun(ua->playback.substream);\n}\n\nstatic int set_stream_hw(struct ua101 *ua, struct snd_pcm_substream *substream,\n\t\t\t unsigned int channels)\n{\n\tint err;\n\n\tsubstream->runtime->hw.info =\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_FIFO_IN_FRAMES;\n\tsubstream->runtime->hw.formats = ua->format_bit;\n\tsubstream->runtime->hw.rates = snd_pcm_rate_to_rate_bit(ua->rate);\n\tsubstream->runtime->hw.rate_min = ua->rate;\n\tsubstream->runtime->hw.rate_max = ua->rate;\n\tsubstream->runtime->hw.channels_min = channels;\n\tsubstream->runtime->hw.channels_max = channels;\n\tsubstream->runtime->hw.buffer_bytes_max = 45000 * 1024;\n\tsubstream->runtime->hw.period_bytes_min = 1;\n\tsubstream->runtime->hw.period_bytes_max = UINT_MAX;\n\tsubstream->runtime->hw.periods_min = 2;\n\tsubstream->runtime->hw.periods_max = UINT_MAX;\n\terr = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   1500000 / ua->packets_per_second,\n\t\t\t\t\t   UINT_MAX);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_msbits(substream->runtime, 0, 32, 24);\n\treturn err;\n}\n\nstatic int capture_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tua->capture.substream = substream;\n\terr = set_stream_hw(ua, substream, ua->capture.channels);\n\tif (err < 0)\n\t\treturn err;\n\tsubstream->runtime->hw.fifo_size =\n\t\tDIV_ROUND_CLOSEST(ua->rate, ua->packets_per_second);\n\tsubstream->runtime->delay = substream->runtime->hw.fifo_size;\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tif (err >= 0)\n\t\tset_bit(ALSA_CAPTURE_OPEN, &ua->states);\n\tmutex_unlock(&ua->mutex);\n\treturn err;\n}\n\nstatic int playback_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tua->playback.substream = substream;\n\terr = set_stream_hw(ua, substream, ua->playback.channels);\n\tif (err < 0)\n\t\treturn err;\n\tsubstream->runtime->hw.fifo_size =\n\t\tDIV_ROUND_CLOSEST(ua->rate * ua->playback.queue_length,\n\t\t\t\t  ua->packets_per_second);\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tif (err < 0)\n\t\tgoto error;\n\terr = start_usb_playback(ua);\n\tif (err < 0) {\n\t\tif (!test_bit(ALSA_CAPTURE_OPEN, &ua->states))\n\t\t\tstop_usb_capture(ua);\n\t\tgoto error;\n\t}\n\tset_bit(ALSA_PLAYBACK_OPEN, &ua->states);\nerror:\n\tmutex_unlock(&ua->mutex);\n\treturn err;\n}\n\nstatic int capture_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\n\tmutex_lock(&ua->mutex);\n\tclear_bit(ALSA_CAPTURE_OPEN, &ua->states);\n\tif (!test_bit(ALSA_PLAYBACK_OPEN, &ua->states))\n\t\tstop_usb_capture(ua);\n\tmutex_unlock(&ua->mutex);\n\treturn 0;\n}\n\nstatic int playback_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\n\tmutex_lock(&ua->mutex);\n\tstop_usb_playback(ua);\n\tclear_bit(ALSA_PLAYBACK_OPEN, &ua->states);\n\tif (!test_bit(ALSA_CAPTURE_OPEN, &ua->states))\n\t\tstop_usb_capture(ua);\n\tmutex_unlock(&ua->mutex);\n\treturn 0;\n}\n\nstatic int capture_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tmutex_unlock(&ua->mutex);\n\treturn err;\n}\n\nstatic int playback_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tif (err >= 0)\n\t\terr = start_usb_playback(ua);\n\tmutex_unlock(&ua->mutex);\n\treturn err;\n}\n\nstatic int capture_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tmutex_unlock(&ua->mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twait_event(ua->alsa_capture_wait,\n\t\t   test_bit(CAPTURE_URB_COMPLETED, &ua->states) ||\n\t\t   !test_bit(USB_CAPTURE_RUNNING, &ua->states));\n\tif (test_bit(DISCONNECTED, &ua->states))\n\t\treturn -ENODEV;\n\tif (!test_bit(USB_CAPTURE_RUNNING, &ua->states))\n\t\treturn -EIO;\n\n\tua->capture.period_pos = 0;\n\tua->capture.buffer_pos = 0;\n\treturn 0;\n}\n\nstatic int playback_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct ua101 *ua = substream->private_data;\n\tint err;\n\n\tmutex_lock(&ua->mutex);\n\terr = start_usb_capture(ua);\n\tif (err >= 0)\n\t\terr = start_usb_playback(ua);\n\tmutex_unlock(&ua->mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twait_event(ua->alsa_playback_wait,\n\t\t   test_bit(PLAYBACK_URB_COMPLETED, &ua->states) ||\n\t\t   !test_bit(USB_PLAYBACK_RUNNING, &ua->states));\n\tif (test_bit(DISCONNECTED, &ua->states))\n\t\treturn -ENODEV;\n\tif (!test_bit(USB_PLAYBACK_RUNNING, &ua->states))\n\t\treturn -EIO;\n\n\tsubstream->runtime->delay = 0;\n\tua->playback.period_pos = 0;\n\tua->playback.buffer_pos = 0;\n\treturn 0;\n}\n\nstatic int capture_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct ua101 *ua = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (!test_bit(USB_CAPTURE_RUNNING, &ua->states))\n\t\t\treturn -EIO;\n\t\tset_bit(ALSA_CAPTURE_RUNNING, &ua->states);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tclear_bit(ALSA_CAPTURE_RUNNING, &ua->states);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int playback_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct ua101 *ua = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (!test_bit(USB_PLAYBACK_RUNNING, &ua->states))\n\t\t\treturn -EIO;\n\t\tset_bit(ALSA_PLAYBACK_RUNNING, &ua->states);\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tclear_bit(ALSA_PLAYBACK_RUNNING, &ua->states);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline snd_pcm_uframes_t ua101_pcm_pointer(struct ua101 *ua,\n\t\t\t\t\t\t  struct ua101_stream *stream)\n{\n\tunsigned long flags;\n\tunsigned int pos;\n\n\tspin_lock_irqsave(&ua->lock, flags);\n\tpos = stream->buffer_pos;\n\tspin_unlock_irqrestore(&ua->lock, flags);\n\treturn pos;\n}\n\nstatic snd_pcm_uframes_t capture_pcm_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct ua101 *ua = subs->private_data;\n\n\treturn ua101_pcm_pointer(ua, &ua->capture);\n}\n\nstatic snd_pcm_uframes_t playback_pcm_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct ua101 *ua = subs->private_data;\n\n\treturn ua101_pcm_pointer(ua, &ua->playback);\n}\n\nstatic const struct snd_pcm_ops capture_pcm_ops = {\n\t.open = capture_pcm_open,\n\t.close = capture_pcm_close,\n\t.hw_params = capture_pcm_hw_params,\n\t.prepare = capture_pcm_prepare,\n\t.trigger = capture_pcm_trigger,\n\t.pointer = capture_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops playback_pcm_ops = {\n\t.open = playback_pcm_open,\n\t.close = playback_pcm_close,\n\t.hw_params = playback_pcm_hw_params,\n\t.prepare = playback_pcm_prepare,\n\t.trigger = playback_pcm_trigger,\n\t.pointer = playback_pcm_pointer,\n};\n\nstatic const struct uac_format_type_i_discrete_descriptor *\nfind_format_descriptor(struct usb_interface *interface)\n{\n\tstruct usb_host_interface *alt;\n\tu8 *extra;\n\tint extralen;\n\n\tif (interface->num_altsetting != 2) {\n\t\tdev_err(&interface->dev, \"invalid num_altsetting\\n\");\n\t\treturn NULL;\n\t}\n\n\talt = &interface->altsetting[0];\n\tif (alt->desc.bNumEndpoints != 0) {\n\t\tdev_err(&interface->dev, \"invalid bNumEndpoints\\n\");\n\t\treturn NULL;\n\t}\n\n\talt = &interface->altsetting[1];\n\tif (alt->desc.bNumEndpoints != 1) {\n\t\tdev_err(&interface->dev, \"invalid bNumEndpoints\\n\");\n\t\treturn NULL;\n\t}\n\n\textra = alt->extra;\n\textralen = alt->extralen;\n\twhile (extralen >= sizeof(struct usb_descriptor_header)) {\n\t\tstruct uac_format_type_i_discrete_descriptor *desc;\n\n\t\tdesc = (struct uac_format_type_i_discrete_descriptor *)extra;\n\t\tif (desc->bLength > extralen) {\n\t\t\tdev_err(&interface->dev, \"descriptor overflow\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (desc->bLength == UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1) &&\n\t\t    desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    desc->bDescriptorSubtype == UAC_FORMAT_TYPE) {\n\t\t\tif (desc->bFormatType != UAC_FORMAT_TYPE_I_PCM ||\n\t\t\t    desc->bSamFreqType != 1) {\n\t\t\t\tdev_err(&interface->dev,\n\t\t\t\t\t\"invalid format type\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn desc;\n\t\t}\n\t\textralen -= desc->bLength;\n\t\textra += desc->bLength;\n\t}\n\tdev_err(&interface->dev, \"sample format descriptor not found\\n\");\n\treturn NULL;\n}\n\nstatic int detect_usb_format(struct ua101 *ua)\n{\n\tconst struct uac_format_type_i_discrete_descriptor *fmt_capture;\n\tconst struct uac_format_type_i_discrete_descriptor *fmt_playback;\n\tconst struct usb_endpoint_descriptor *epd;\n\tunsigned int rate2;\n\n\tfmt_capture = find_format_descriptor(ua->intf[INTF_CAPTURE]);\n\tfmt_playback = find_format_descriptor(ua->intf[INTF_PLAYBACK]);\n\tif (!fmt_capture || !fmt_playback)\n\t\treturn -ENXIO;\n\n\tswitch (fmt_capture->bSubframeSize) {\n\tcase 3:\n\t\tua->format_bit = SNDRV_PCM_FMTBIT_S24_3LE;\n\t\tbreak;\n\tcase 4:\n\t\tua->format_bit = SNDRV_PCM_FMTBIT_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ua->dev->dev, \"sample width is not 24 or 32 bits\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (fmt_capture->bSubframeSize != fmt_playback->bSubframeSize) {\n\t\tdev_err(&ua->dev->dev,\n\t\t\t\"playback/capture sample widths do not match\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (fmt_capture->bBitResolution != 24 ||\n\t    fmt_playback->bBitResolution != 24) {\n\t\tdev_err(&ua->dev->dev, \"sample width is not 24 bits\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tua->rate = combine_triple(fmt_capture->tSamFreq[0]);\n\trate2 = combine_triple(fmt_playback->tSamFreq[0]);\n\tif (ua->rate != rate2) {\n\t\tdev_err(&ua->dev->dev,\n\t\t\t\"playback/capture rates do not match: %u/%u\\n\",\n\t\t\trate2, ua->rate);\n\t\treturn -ENXIO;\n\t}\n\n\tswitch (ua->dev->speed) {\n\tcase USB_SPEED_FULL:\n\t\tua->packets_per_second = 1000;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tua->packets_per_second = 8000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ua->dev->dev, \"unknown device speed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tua->capture.channels = fmt_capture->bNrChannels;\n\tua->playback.channels = fmt_playback->bNrChannels;\n\tua->capture.frame_bytes =\n\t\tfmt_capture->bSubframeSize * ua->capture.channels;\n\tua->playback.frame_bytes =\n\t\tfmt_playback->bSubframeSize * ua->playback.channels;\n\n\tepd = &ua->intf[INTF_CAPTURE]->altsetting[1].endpoint[0].desc;\n\tif (!usb_endpoint_is_isoc_in(epd) || usb_endpoint_maxp(epd) == 0) {\n\t\tdev_err(&ua->dev->dev, \"invalid capture endpoint\\n\");\n\t\treturn -ENXIO;\n\t}\n\tua->capture.usb_pipe = usb_rcvisocpipe(ua->dev, usb_endpoint_num(epd));\n\tua->capture.max_packet_bytes = usb_endpoint_maxp(epd);\n\n\tepd = &ua->intf[INTF_PLAYBACK]->altsetting[1].endpoint[0].desc;\n\tif (!usb_endpoint_is_isoc_out(epd) || usb_endpoint_maxp(epd) == 0) {\n\t\tdev_err(&ua->dev->dev, \"invalid playback endpoint\\n\");\n\t\treturn -ENXIO;\n\t}\n\tua->playback.usb_pipe = usb_sndisocpipe(ua->dev, usb_endpoint_num(epd));\n\tua->playback.max_packet_bytes = usb_endpoint_maxp(epd);\n\treturn 0;\n}\n\nstatic int alloc_stream_buffers(struct ua101 *ua, struct ua101_stream *stream)\n{\n\tunsigned int remaining_packets, packets, packets_per_page, i;\n\tsize_t size;\n\n\tstream->queue_length = queue_length;\n\tstream->queue_length = max(stream->queue_length,\n\t\t\t\t   (unsigned int)MIN_QUEUE_LENGTH);\n\tstream->queue_length = min(stream->queue_length,\n\t\t\t\t   (unsigned int)MAX_QUEUE_LENGTH);\n\n\t \n\tremaining_packets = stream->queue_length;\n\tpackets_per_page = PAGE_SIZE / stream->max_packet_bytes;\n\tfor (i = 0; i < ARRAY_SIZE(stream->buffers); ++i) {\n\t\tpackets = min(remaining_packets, packets_per_page);\n\t\tsize = packets * stream->max_packet_bytes;\n\t\tstream->buffers[i].addr =\n\t\t\tusb_alloc_coherent(ua->dev, size, GFP_KERNEL,\n\t\t\t\t\t   &stream->buffers[i].dma);\n\t\tif (!stream->buffers[i].addr)\n\t\t\treturn -ENOMEM;\n\t\tstream->buffers[i].size = size;\n\t\tremaining_packets -= packets;\n\t\tif (!remaining_packets)\n\t\t\tbreak;\n\t}\n\tif (remaining_packets) {\n\t\tdev_err(&ua->dev->dev, \"too many packets\\n\");\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\nstatic void free_stream_buffers(struct ua101 *ua, struct ua101_stream *stream)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stream->buffers); ++i)\n\t\tusb_free_coherent(ua->dev,\n\t\t\t\t  stream->buffers[i].size,\n\t\t\t\t  stream->buffers[i].addr,\n\t\t\t\t  stream->buffers[i].dma);\n}\n\nstatic int alloc_stream_urbs(struct ua101 *ua, struct ua101_stream *stream,\n\t\t\t     void (*urb_complete)(struct urb *))\n{\n\tunsigned max_packet_size = stream->max_packet_bytes;\n\tstruct ua101_urb *urb;\n\tunsigned int b, u = 0;\n\n\tfor (b = 0; b < ARRAY_SIZE(stream->buffers); ++b) {\n\t\tunsigned int size = stream->buffers[b].size;\n\t\tu8 *addr = stream->buffers[b].addr;\n\t\tdma_addr_t dma = stream->buffers[b].dma;\n\n\t\twhile (size >= max_packet_size) {\n\t\t\tif (u >= stream->queue_length)\n\t\t\t\tgoto bufsize_error;\n\t\t\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\t\t\tusb_init_urb(&urb->urb);\n\t\t\turb->urb.dev = ua->dev;\n\t\t\turb->urb.pipe = stream->usb_pipe;\n\t\t\turb->urb.transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\t\turb->urb.transfer_buffer = addr;\n\t\t\turb->urb.transfer_dma = dma;\n\t\t\turb->urb.transfer_buffer_length = max_packet_size;\n\t\t\turb->urb.number_of_packets = 1;\n\t\t\turb->urb.interval = 1;\n\t\t\turb->urb.context = ua;\n\t\t\turb->urb.complete = urb_complete;\n\t\t\turb->urb.iso_frame_desc[0].offset = 0;\n\t\t\turb->urb.iso_frame_desc[0].length = max_packet_size;\n\t\t\tstream->urbs[u++] = urb;\n\t\t\tsize -= max_packet_size;\n\t\t\taddr += max_packet_size;\n\t\t\tdma += max_packet_size;\n\t\t}\n\t}\n\tif (u == stream->queue_length)\n\t\treturn 0;\nbufsize_error:\n\tdev_err(&ua->dev->dev, \"internal buffer size error\\n\");\n\treturn -ENXIO;\n}\n\nstatic void free_stream_urbs(struct ua101_stream *stream)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < stream->queue_length; ++i) {\n\t\tkfree(stream->urbs[i]);\n\t\tstream->urbs[i] = NULL;\n\t}\n}\n\nstatic void free_usb_related_resources(struct ua101 *ua,\n\t\t\t\t       struct usb_interface *interface)\n{\n\tunsigned int i;\n\tstruct usb_interface *intf;\n\n\tmutex_lock(&ua->mutex);\n\tfree_stream_urbs(&ua->capture);\n\tfree_stream_urbs(&ua->playback);\n\tmutex_unlock(&ua->mutex);\n\tfree_stream_buffers(ua, &ua->capture);\n\tfree_stream_buffers(ua, &ua->playback);\n\n\tfor (i = 0; i < ARRAY_SIZE(ua->intf); ++i) {\n\t\tmutex_lock(&ua->mutex);\n\t\tintf = ua->intf[i];\n\t\tua->intf[i] = NULL;\n\t\tmutex_unlock(&ua->mutex);\n\t\tif (intf) {\n\t\t\tusb_set_intfdata(intf, NULL);\n\t\t\tif (intf != interface)\n\t\t\t\tusb_driver_release_interface(&ua101_driver,\n\t\t\t\t\t\t\t     intf);\n\t\t}\n\t}\n}\n\nstatic void ua101_card_free(struct snd_card *card)\n{\n\tstruct ua101 *ua = card->private_data;\n\n\tmutex_destroy(&ua->mutex);\n}\n\nstatic int ua101_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *usb_id)\n{\n\tstatic const struct snd_usb_midi_endpoint_info midi_ep = {\n\t\t.out_cables = 0x0001,\n\t\t.in_cables = 0x0001\n\t};\n\tstatic const struct snd_usb_audio_quirk midi_quirk = {\n\t\t.type = QUIRK_MIDI_FIXED_ENDPOINT,\n\t\t.data = &midi_ep\n\t};\n\tstatic const int intf_numbers[2][3] = {\n\t\t{\t \n\t\t\t[INTF_PLAYBACK] = 0,\n\t\t\t[INTF_CAPTURE] = 1,\n\t\t\t[INTF_MIDI] = 2,\n\t\t},\n\t\t{\t \n\t\t\t[INTF_CAPTURE] = 1,\n\t\t\t[INTF_PLAYBACK] = 2,\n\t\t\t[INTF_MIDI] = 3,\n\t\t},\n\t};\n\tstruct snd_card *card;\n\tstruct ua101 *ua;\n\tunsigned int card_index, i;\n\tint is_ua1000;\n\tconst char *name;\n\tchar usb_path[32];\n\tint err;\n\n\tis_ua1000 = usb_id->idProduct == 0x0044;\n\n\tif (interface->altsetting->desc.bInterfaceNumber !=\n\t    intf_numbers[is_ua1000][0])\n\t\treturn -ENODEV;\n\n\tmutex_lock(&devices_mutex);\n\n\tfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index)\n\t\tif (enable[card_index] && !(devices_used & (1 << card_index)))\n\t\t\tbreak;\n\tif (card_index >= SNDRV_CARDS) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENOENT;\n\t}\n\terr = snd_card_new(&interface->dev,\n\t\t\t   index[card_index], id[card_index], THIS_MODULE,\n\t\t\t   sizeof(*ua), &card);\n\tif (err < 0) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\tcard->private_free = ua101_card_free;\n\tua = card->private_data;\n\tua->dev = interface_to_usbdev(interface);\n\tua->card = card;\n\tua->card_index = card_index;\n\tINIT_LIST_HEAD(&ua->midi_list);\n\tspin_lock_init(&ua->lock);\n\tmutex_init(&ua->mutex);\n\tINIT_LIST_HEAD(&ua->ready_playback_urbs);\n\tINIT_WORK(&ua->playback_work, playback_work);\n\tinit_waitqueue_head(&ua->alsa_capture_wait);\n\tinit_waitqueue_head(&ua->rate_feedback_wait);\n\tinit_waitqueue_head(&ua->alsa_playback_wait);\n\n\tua->intf[0] = interface;\n\tfor (i = 1; i < ARRAY_SIZE(ua->intf); ++i) {\n\t\tua->intf[i] = usb_ifnum_to_if(ua->dev,\n\t\t\t\t\t      intf_numbers[is_ua1000][i]);\n\t\tif (!ua->intf[i]) {\n\t\t\tdev_err(&ua->dev->dev, \"interface %u not found\\n\",\n\t\t\t\tintf_numbers[is_ua1000][i]);\n\t\t\terr = -ENXIO;\n\t\t\tgoto probe_error;\n\t\t}\n\t\terr = usb_driver_claim_interface(&ua101_driver,\n\t\t\t\t\t\t ua->intf[i], ua);\n\t\tif (err < 0) {\n\t\t\tua->intf[i] = NULL;\n\t\t\terr = -EBUSY;\n\t\t\tgoto probe_error;\n\t\t}\n\t}\n\n\terr = detect_usb_format(ua);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\tname = usb_id->idProduct == 0x0044 ? \"UA-1000\" : \"UA-101\";\n\tstrcpy(card->driver, \"UA-101\");\n\tstrcpy(card->shortname, name);\n\tusb_make_path(ua->dev, usb_path, sizeof(usb_path));\n\tsnprintf(ua->card->longname, sizeof(ua->card->longname),\n\t\t \"EDIROL %s (serial %s), %u Hz at %s, %s speed\", name,\n\t\t ua->dev->serial ? ua->dev->serial : \"?\", ua->rate, usb_path,\n\t\t ua->dev->speed == USB_SPEED_HIGH ? \"high\" : \"full\");\n\n\terr = alloc_stream_buffers(ua, &ua->capture);\n\tif (err < 0)\n\t\tgoto probe_error;\n\terr = alloc_stream_buffers(ua, &ua->playback);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\terr = alloc_stream_urbs(ua, &ua->capture, capture_urb_complete);\n\tif (err < 0)\n\t\tgoto probe_error;\n\terr = alloc_stream_urbs(ua, &ua->playback, playback_urb_complete);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\terr = snd_pcm_new(card, name, 0, 1, 1, &ua->pcm);\n\tif (err < 0)\n\t\tgoto probe_error;\n\tua->pcm->private_data = ua;\n\tstrcpy(ua->pcm->name, name);\n\tsnd_pcm_set_ops(ua->pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_pcm_ops);\n\tsnd_pcm_set_ops(ua->pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(ua->pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\n\terr = snd_usbmidi_create(card, ua->intf[INTF_MIDI],\n\t\t\t\t &ua->midi_list, &midi_quirk);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\tusb_set_intfdata(interface, ua);\n\tdevices_used |= 1 << card_index;\n\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n\nprobe_error:\n\tfree_usb_related_resources(ua, interface);\n\tsnd_card_free(card);\n\tmutex_unlock(&devices_mutex);\n\treturn err;\n}\n\nstatic void ua101_disconnect(struct usb_interface *interface)\n{\n\tstruct ua101 *ua = usb_get_intfdata(interface);\n\tstruct list_head *midi;\n\n\tif (!ua)\n\t\treturn;\n\n\tmutex_lock(&devices_mutex);\n\n\tset_bit(DISCONNECTED, &ua->states);\n\twake_up(&ua->rate_feedback_wait);\n\n\t \n\tsnd_card_disconnect(ua->card);\n\n\t \n\tlist_for_each(midi, &ua->midi_list)\n\t\tsnd_usbmidi_disconnect(midi);\n\tabort_alsa_playback(ua);\n\tabort_alsa_capture(ua);\n\tmutex_lock(&ua->mutex);\n\tstop_usb_playback(ua);\n\tstop_usb_capture(ua);\n\tmutex_unlock(&ua->mutex);\n\n\tfree_usb_related_resources(ua, interface);\n\n\tdevices_used &= ~(1 << ua->card_index);\n\n\tsnd_card_free_when_closed(ua->card);\n\n\tmutex_unlock(&devices_mutex);\n}\n\nstatic const struct usb_device_id ua101_ids[] = {\n\t{ USB_DEVICE(0x0582, 0x0044) },  \n\t{ USB_DEVICE(0x0582, 0x007d) },  \n\t{ USB_DEVICE(0x0582, 0x008d) },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ua101_ids);\n\nstatic struct usb_driver ua101_driver = {\n\t.name = \"snd-ua101\",\n\t.id_table = ua101_ids,\n\t.probe = ua101_probe,\n\t.disconnect = ua101_disconnect,\n#if 0\n\t.suspend = ua101_suspend,\n\t.resume = ua101_resume,\n#endif\n};\n\nmodule_usb_driver(ua101_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}