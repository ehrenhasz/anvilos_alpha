{
  "module_name": "quirks.c",
  "hash_id": "3903a643aac9456b5905903a9cc28a81f1b18434bba8dc33167a6b25e5dd80bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/quirks.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n#include <linux/bits.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"mixer.h\"\n#include \"mixer_quirks.h\"\n#include \"midi.h\"\n#include \"midi2.h\"\n#include \"quirks.h\"\n#include \"helper.h\"\n#include \"endpoint.h\"\n#include \"pcm.h\"\n#include \"clock.h\"\n#include \"stream.h\"\n\n \nstatic int create_composite_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  struct usb_interface *iface,\n\t\t\t\t  struct usb_driver *driver,\n\t\t\t\t  const struct snd_usb_audio_quirk *quirk_comp)\n{\n\tint probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;\n\tconst struct snd_usb_audio_quirk *quirk;\n\tint err;\n\n\tfor (quirk = quirk_comp->data; quirk->ifnum >= 0; ++quirk) {\n\t\tiface = usb_ifnum_to_if(chip->dev, quirk->ifnum);\n\t\tif (!iface)\n\t\t\tcontinue;\n\t\tif (quirk->ifnum != probed_ifnum &&\n\t\t    usb_interface_claimed(iface))\n\t\t\tcontinue;\n\t\terr = snd_usb_create_quirk(chip, iface, driver, quirk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (quirk = quirk_comp->data; quirk->ifnum >= 0; ++quirk) {\n\t\tiface = usb_ifnum_to_if(chip->dev, quirk->ifnum);\n\t\tif (!iface)\n\t\t\tcontinue;\n\t\tif (quirk->ifnum != probed_ifnum &&\n\t\t    !usb_interface_claimed(iface)) {\n\t\t\terr = usb_driver_claim_interface(driver, iface,\n\t\t\t\t\t\t\t USB_AUDIO_IFACE_UNUSED);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ignore_interface_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  struct usb_interface *iface,\n\t\t\t\t  struct usb_driver *driver,\n\t\t\t\t  const struct snd_usb_audio_quirk *quirk)\n{\n\treturn 0;\n}\n\n\nstatic int create_any_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t struct usb_interface *intf,\n\t\t\t\t struct usb_driver *driver,\n\t\t\t\t const struct snd_usb_audio_quirk *quirk)\n{\n\treturn snd_usb_midi_v2_create(chip, intf, quirk, 0);\n}\n\n \nstatic int create_standard_audio_quirk(struct snd_usb_audio *chip,\n\t\t\t\t       struct usb_interface *iface,\n\t\t\t\t       struct usb_driver *driver,\n\t\t\t\t       const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tint err;\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\terr = snd_usb_parse_audio_interface(chip, altsd->bInterfaceNumber);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"cannot setup if %d: error %d\\n\",\n\t\t\t   altsd->bInterfaceNumber, err);\n\t\treturn err;\n\t}\n\t \n\tusb_set_interface(chip->dev, altsd->bInterfaceNumber, 0);\n\treturn 0;\n}\n\n \nstatic int add_audio_stream_from_fixed_fmt(struct snd_usb_audio *chip,\n\t\t\t\t\t   struct audioformat *fp)\n{\n\tint stream, err;\n\n\tstream = (fp->endpoint & USB_DIR_IN) ?\n\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\n\tsnd_usb_audioformat_set_sync_ep(chip, fp);\n\n\terr = snd_usb_add_audio_stream(chip, stream, fp);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_usb_add_endpoint(chip, fp->endpoint,\n\t\t\t\t   SND_USB_ENDPOINT_TYPE_DATA);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (fp->sync_ep) {\n\t\terr = snd_usb_add_endpoint(chip, fp->sync_ep,\n\t\t\t\t\t   fp->implicit_fb ?\n\t\t\t\t\t   SND_USB_ENDPOINT_TYPE_DATA :\n\t\t\t\t\t   SND_USB_ENDPOINT_TYPE_SYNC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int create_fixed_stream_quirk(struct snd_usb_audio *chip,\n\t\t\t\t     struct usb_interface *iface,\n\t\t\t\t     struct usb_driver *driver,\n\t\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct audioformat *fp;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tunsigned *rate_table = NULL;\n\tint err;\n\n\tfp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&fp->list);\n\tif (fp->nr_rates > MAX_NR_RATES) {\n\t\tkfree(fp);\n\t\treturn -EINVAL;\n\t}\n\tif (fp->nr_rates > 0) {\n\t\trate_table = kmemdup(fp->rate_table,\n\t\t\t\t     sizeof(int) * fp->nr_rates, GFP_KERNEL);\n\t\tif (!rate_table) {\n\t\t\tkfree(fp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfp->rate_table = rate_table;\n\t}\n\n\tif (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||\n\t    fp->altset_idx >= iface->num_altsetting) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\talts = &iface->altsetting[fp->altset_idx];\n\taltsd = get_iface_desc(alts);\n\tif (altsd->bNumEndpoints <= fp->ep_idx) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tfp->protocol = altsd->bInterfaceProtocol;\n\n\tif (fp->datainterval == 0)\n\t\tfp->datainterval = snd_usb_parse_datainterval(chip, alts);\n\tif (fp->maxpacksize == 0)\n\t\tfp->maxpacksize = le16_to_cpu(get_endpoint(alts, fp->ep_idx)->wMaxPacketSize);\n\tif (!fp->fmt_type)\n\t\tfp->fmt_type = UAC_FORMAT_TYPE_I;\n\n\terr = add_audio_stream_from_fixed_fmt(chip, fp);\n\tif (err < 0)\n\t\tgoto error;\n\n\tusb_set_interface(chip->dev, fp->iface, 0);\n\tsnd_usb_init_pitch(chip, fp);\n\tsnd_usb_init_sample_rate(chip, fp, fp->rate_max);\n\treturn 0;\n\n error:\n\tlist_del(&fp->list);  \n\tkfree(fp);\n\tkfree(rate_table);\n\treturn err;\n}\n\nstatic int create_auto_pcm_quirk(struct snd_usb_audio *chip,\n\t\t\t\t struct usb_interface *iface,\n\t\t\t\t struct usb_driver *driver)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_endpoint_descriptor *epd;\n\tstruct uac1_as_header_descriptor *ashd;\n\tstruct uac_format_type_i_discrete_descriptor *fmtd;\n\n\t \n\n\t \n\tif (iface->num_altsetting < 2)\n\t\treturn -ENODEV;\n\talts = &iface->altsetting[1];\n\taltsd = get_iface_desc(alts);\n\n\t \n\tif (altsd->bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_xfer_isoc(epd))\n\t\treturn -ENODEV;\n\n\t \n\tashd = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL,\n\t\t\t\t       UAC_AS_GENERAL);\n\tfmtd = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL,\n\t\t\t\t       UAC_FORMAT_TYPE);\n\tif (!ashd || ashd->bLength < 7 ||\n\t    !fmtd || fmtd->bLength < 8)\n\t\treturn -ENODEV;\n\n\treturn create_standard_audio_quirk(chip, iface, driver, NULL);\n}\n\nstatic int create_yamaha_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t    struct usb_interface *iface,\n\t\t\t\t    struct usb_driver *driver,\n\t\t\t\t    struct usb_host_interface *alts)\n{\n\tstatic const struct snd_usb_audio_quirk yamaha_midi_quirk = {\n\t\t.type = QUIRK_MIDI_YAMAHA\n\t};\n\tstruct usb_midi_in_jack_descriptor *injd;\n\tstruct usb_midi_out_jack_descriptor *outjd;\n\n\t \n\tinjd = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t       NULL, USB_MS_MIDI_IN_JACK);\n\toutjd = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t\tNULL, USB_MS_MIDI_OUT_JACK);\n\tif (!injd && !outjd)\n\t\treturn -ENODEV;\n\tif ((injd && !snd_usb_validate_midi_desc(injd)) ||\n\t    (outjd && !snd_usb_validate_midi_desc(outjd)))\n\t\treturn -ENODEV;\n\tif (injd && (injd->bLength < 5 ||\n\t\t     (injd->bJackType != USB_MS_EMBEDDED &&\n\t\t      injd->bJackType != USB_MS_EXTERNAL)))\n\t\treturn -ENODEV;\n\tif (outjd && (outjd->bLength < 6 ||\n\t\t      (outjd->bJackType != USB_MS_EMBEDDED &&\n\t\t       outjd->bJackType != USB_MS_EXTERNAL)))\n\t\treturn -ENODEV;\n\treturn create_any_midi_quirk(chip, iface, driver, &yamaha_midi_quirk);\n}\n\nstatic int create_roland_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t    struct usb_interface *iface,\n\t\t\t\t    struct usb_driver *driver,\n\t\t\t\t    struct usb_host_interface *alts)\n{\n\tstatic const struct snd_usb_audio_quirk roland_midi_quirk = {\n\t\t.type = QUIRK_MIDI_ROLAND\n\t};\n\tu8 *roland_desc = NULL;\n\n\t \n\tfor (;;) {\n\t\troland_desc = snd_usb_find_csint_desc(alts->extra,\n\t\t\t\t\t\t      alts->extralen,\n\t\t\t\t\t\t      roland_desc, 0xf1);\n\t\tif (!roland_desc)\n\t\t\treturn -ENODEV;\n\t\tif (roland_desc[0] < 6 || roland_desc[3] != 2)\n\t\t\tcontinue;\n\t\treturn create_any_midi_quirk(chip, iface, driver,\n\t\t\t\t\t     &roland_midi_quirk);\n\t}\n}\n\nstatic int create_std_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t struct usb_interface *iface,\n\t\t\t\t struct usb_driver *driver,\n\t\t\t\t struct usb_host_interface *alts)\n{\n\tstruct usb_ms_header_descriptor *mshd;\n\tstruct usb_ms_endpoint_descriptor *msepd;\n\n\t \n\tmshd = (struct usb_ms_header_descriptor *)alts->extra;\n\tif (alts->extralen < 7 ||\n\t    mshd->bLength < 7 ||\n\t    mshd->bDescriptorType != USB_DT_CS_INTERFACE ||\n\t    mshd->bDescriptorSubtype != USB_MS_HEADER)\n\t\treturn -ENODEV;\n\t \n\tmsepd = (struct usb_ms_endpoint_descriptor *)alts->endpoint[0].extra;\n\tif (alts->endpoint[0].extralen < 4 ||\n\t    msepd->bLength < 4 ||\n\t    msepd->bDescriptorType != USB_DT_CS_ENDPOINT ||\n\t    msepd->bDescriptorSubtype != UAC_MS_GENERAL ||\n\t    msepd->bNumEmbMIDIJack < 1 ||\n\t    msepd->bNumEmbMIDIJack > 16)\n\t\treturn -ENODEV;\n\n\treturn create_any_midi_quirk(chip, iface, driver, NULL);\n}\n\nstatic int create_auto_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  struct usb_interface *iface,\n\t\t\t\t  struct usb_driver *driver)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint err;\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t \n\tif (altsd->bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_xfer_bulk(epd) &&\n\t    !usb_endpoint_xfer_int(epd))\n\t\treturn -ENODEV;\n\n\tswitch (USB_ID_VENDOR(chip->usb_id)) {\n\tcase 0x0499:  \n\t\terr = create_yamaha_midi_quirk(chip, iface, driver, alts);\n\t\tif (err != -ENODEV)\n\t\t\treturn err;\n\t\tbreak;\n\tcase 0x0582:  \n\t\terr = create_roland_midi_quirk(chip, iface, driver, alts);\n\t\tif (err != -ENODEV)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn create_std_midi_quirk(chip, iface, driver, alts);\n}\n\nstatic int create_autodetect_quirk(struct snd_usb_audio *chip,\n\t\t\t\t   struct usb_interface *iface,\n\t\t\t\t   struct usb_driver *driver,\n\t\t\t\t   const struct snd_usb_audio_quirk *quirk)\n{\n\tint err;\n\n\terr = create_auto_pcm_quirk(chip, iface, driver);\n\tif (err == -ENODEV)\n\t\terr = create_auto_midi_quirk(chip, iface, driver);\n\treturn err;\n}\n\n \nstatic int create_uaxx_quirk(struct snd_usb_audio *chip,\n\t\t\t     struct usb_interface *iface,\n\t\t\t     struct usb_driver *driver,\n\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstatic const struct audioformat ua_format = {\n\t\t.formats = SNDRV_PCM_FMTBIT_S24_3LE,\n\t\t.channels = 2,\n\t\t.fmt_type = UAC_FORMAT_TYPE_I,\n\t\t.altsetting = 1,\n\t\t.altset_idx = 1,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t};\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct audioformat *fp;\n\tint err;\n\n\t \n\tif (iface->num_altsetting < 2)\n\t\treturn -ENXIO;\n\talts = &iface->altsetting[1];\n\taltsd = get_iface_desc(alts);\n\n\tif (altsd->bNumEndpoints == 2) {\n\t\tstatic const struct snd_usb_midi_endpoint_info ua700_ep = {\n\t\t\t.out_cables = 0x0003,\n\t\t\t.in_cables  = 0x0003\n\t\t};\n\t\tstatic const struct snd_usb_audio_quirk ua700_quirk = {\n\t\t\t.type = QUIRK_MIDI_FIXED_ENDPOINT,\n\t\t\t.data = &ua700_ep\n\t\t};\n\t\tstatic const struct snd_usb_midi_endpoint_info uaxx_ep = {\n\t\t\t.out_cables = 0x0001,\n\t\t\t.in_cables  = 0x0001\n\t\t};\n\t\tstatic const struct snd_usb_audio_quirk uaxx_quirk = {\n\t\t\t.type = QUIRK_MIDI_FIXED_ENDPOINT,\n\t\t\t.data = &uaxx_ep\n\t\t};\n\t\tconst struct snd_usb_audio_quirk *quirk =\n\t\t\tchip->usb_id == USB_ID(0x0582, 0x002b)\n\t\t\t? &ua700_quirk : &uaxx_quirk;\n\t\treturn __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t    &chip->midi_list, quirk,\n\t\t\t\t\t    chip->usb_id,\n\t\t\t\t\t    &chip->num_rawmidis);\n\t}\n\n\tif (altsd->bNumEndpoints != 1)\n\t\treturn -ENXIO;\n\n\tfp = kmemdup(&ua_format, sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->iface = altsd->bInterfaceNumber;\n\tfp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;\n\tfp->ep_attr = get_endpoint(alts, 0)->bmAttributes;\n\tfp->datainterval = 0;\n\tfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\tINIT_LIST_HEAD(&fp->list);\n\n\tswitch (fp->maxpacksize) {\n\tcase 0x120:\n\t\tfp->rate_max = fp->rate_min = 44100;\n\t\tbreak;\n\tcase 0x138:\n\tcase 0x140:\n\t\tfp->rate_max = fp->rate_min = 48000;\n\t\tbreak;\n\tcase 0x258:\n\tcase 0x260:\n\t\tfp->rate_max = fp->rate_min = 96000;\n\t\tbreak;\n\tdefault:\n\t\tusb_audio_err(chip, \"unknown sample rate\\n\");\n\t\tkfree(fp);\n\t\treturn -ENXIO;\n\t}\n\n\terr = add_audio_stream_from_fixed_fmt(chip, fp);\n\tif (err < 0) {\n\t\tlist_del(&fp->list);  \n\t\tkfree(fp);\n\t\treturn err;\n\t}\n\tusb_set_interface(chip->dev, fp->iface, 0);\n\treturn 0;\n}\n\n \nstatic int create_standard_mixer_quirk(struct snd_usb_audio *chip,\n\t\t\t\t       struct usb_interface *iface,\n\t\t\t\t       struct usb_driver *driver,\n\t\t\t\t       const struct snd_usb_audio_quirk *quirk)\n{\n\tif (quirk->ifnum < 0)\n\t\treturn 0;\n\n\treturn snd_usb_create_mixer(chip, quirk->ifnum);\n}\n\n \nint snd_usb_create_quirk(struct snd_usb_audio *chip,\n\t\t\t struct usb_interface *iface,\n\t\t\t struct usb_driver *driver,\n\t\t\t const struct snd_usb_audio_quirk *quirk)\n{\n\ttypedef int (*quirk_func_t)(struct snd_usb_audio *,\n\t\t\t\t    struct usb_interface *,\n\t\t\t\t    struct usb_driver *,\n\t\t\t\t    const struct snd_usb_audio_quirk *);\n\tstatic const quirk_func_t quirk_funcs[] = {\n\t\t[QUIRK_IGNORE_INTERFACE] = ignore_interface_quirk,\n\t\t[QUIRK_COMPOSITE] = create_composite_quirk,\n\t\t[QUIRK_AUTODETECT] = create_autodetect_quirk,\n\t\t[QUIRK_MIDI_STANDARD_INTERFACE] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_FIXED_ENDPOINT] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_ROLAND] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_RAW_BYTES] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_CME] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_AKAI] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_FTDI] = create_any_midi_quirk,\n\t\t[QUIRK_MIDI_CH345] = create_any_midi_quirk,\n\t\t[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,\n\t\t[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,\n\t\t[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,\n\t\t[QUIRK_AUDIO_STANDARD_MIXER] = create_standard_mixer_quirk,\n\t};\n\n\tif (quirk->type < QUIRK_TYPE_COUNT) {\n\t\treturn quirk_funcs[quirk->type](chip, iface, driver, quirk);\n\t} else {\n\t\tusb_audio_err(chip, \"invalid quirk type %d\\n\", quirk->type);\n\t\treturn -ENXIO;\n\t}\n}\n\n \n\n#define EXTIGY_FIRMWARE_SIZE_OLD 794\n#define EXTIGY_FIRMWARE_SIZE_NEW 483\n\nstatic int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interface *intf)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint err;\n\n\tif (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||\n\t    le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {\n\t\tdev_dbg(&dev->dev, \"sending Extigy boot sequence...\\n\");\n\t\t \n\t\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),\n\t\t\t\t      0x10, 0x43, 0x0001, 0x000a, NULL, 0);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev, \"error sending boot message: %d\\n\", err);\n\t\terr = usb_get_descriptor(dev, USB_DT_DEVICE, 0,\n\t\t\t\t&dev->descriptor, sizeof(dev->descriptor));\n\t\tconfig = dev->actconfig;\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev, \"error usb_get_descriptor: %d\\n\", err);\n\t\terr = usb_reset_configuration(dev);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev, \"error usb_reset_configuration: %d\\n\", err);\n\t\tdev_dbg(&dev->dev, \"extigy_boot: new boot length = %d\\n\",\n\t\t\t    le16_to_cpu(get_cfg_desc(config)->wTotalLength));\n\t\treturn -ENODEV;  \n\t}\n\treturn 0;\n}\n\nstatic int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev)\n{\n\tu8 buf = 1;\n\n\tsnd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), 0x2a,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t0, 0, &buf, 1);\n\tif (buf == 0) {\n\t\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0x29,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t\t1, 2000, NULL, 0);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)\n{\n\tint err;\n\n\tif (dev->actconfig->desc.bConfigurationValue == 1) {\n\t\tdev_info(&dev->dev,\n\t\t\t   \"Fast Track Pro switching to config #2\\n\");\n\t\t \n\t\terr = usb_driver_set_configuration(dev, 2);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"error usb_driver_set_configuration: %d\\n\",\n\t\t\t\terr);\n\t\t \n\t\treturn -ENODEV;\n\t} else\n\t\tdev_info(&dev->dev, \"Fast Track Pro config OK\\n\");\n\n\treturn 0;\n}\n\n \nstatic int snd_usb_cm106_write_int_reg(struct usb_device *dev, int reg, u16 value)\n{\n\tu8 buf[4];\n\tbuf[0] = 0x20;\n\tbuf[1] = value & 0xff;\n\tbuf[2] = (value >> 8) & 0xff;\n\tbuf[3] = reg;\n\treturn snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), USB_REQ_SET_CONFIGURATION,\n\t\t\t       USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t       0, 0, &buf, 4);\n}\n\nstatic int snd_usb_cm106_boot_quirk(struct usb_device *dev)\n{\n\t \n\treturn snd_usb_cm106_write_int_reg(dev, 2, 0x8004);\n}\n\n \n#define CM6206_REG0_DMA_MASTER BIT(15)\n#define CM6206_REG0_SPDIFO_RATE_48K (2 << 12)\n#define CM6206_REG0_SPDIFO_RATE_96K (7 << 12)\n \n#define CM6206_REG0_SPDIFO_CAT_CODE_GENERAL (0 << 4)\n#define CM6206_REG0_SPDIFO_EMPHASIS_CD BIT(3)\n#define CM6206_REG0_SPDIFO_COPYRIGHT_NA BIT(2)\n#define CM6206_REG0_SPDIFO_NON_AUDIO BIT(1)\n#define CM6206_REG0_SPDIFO_PRO_FORMAT BIT(0)\n\n#define CM6206_REG1_TEST_SEL_CLK BIT(14)\n#define CM6206_REG1_PLLBIN_EN BIT(13)\n#define CM6206_REG1_SOFT_MUTE_EN BIT(12)\n#define CM6206_REG1_GPIO4_OUT BIT(11)\n#define CM6206_REG1_GPIO4_OE BIT(10)\n#define CM6206_REG1_GPIO3_OUT BIT(9)\n#define CM6206_REG1_GPIO3_OE BIT(8)\n#define CM6206_REG1_GPIO2_OUT BIT(7)\n#define CM6206_REG1_GPIO2_OE BIT(6)\n#define CM6206_REG1_GPIO1_OUT BIT(5)\n#define CM6206_REG1_GPIO1_OE BIT(4)\n#define CM6206_REG1_SPDIFO_INVALID BIT(3)\n#define CM6206_REG1_SPDIF_LOOP_EN BIT(2)\n#define CM6206_REG1_SPDIFO_DIS BIT(1)\n#define CM6206_REG1_SPDIFI_MIX BIT(0)\n\n#define CM6206_REG2_DRIVER_ON BIT(15)\n#define CM6206_REG2_HEADP_SEL_SIDE_CHANNELS (0 << 13)\n#define CM6206_REG2_HEADP_SEL_SURROUND_CHANNELS (1 << 13)\n#define CM6206_REG2_HEADP_SEL_CENTER_SUBW (2 << 13)\n#define CM6206_REG2_HEADP_SEL_FRONT_CHANNELS (3 << 13)\n#define CM6206_REG2_MUTE_HEADPHONE_RIGHT BIT(12)\n#define CM6206_REG2_MUTE_HEADPHONE_LEFT BIT(11)\n#define CM6206_REG2_MUTE_REAR_SURROUND_RIGHT BIT(10)\n#define CM6206_REG2_MUTE_REAR_SURROUND_LEFT BIT(9)\n#define CM6206_REG2_MUTE_SIDE_SURROUND_RIGHT BIT(8)\n#define CM6206_REG2_MUTE_SIDE_SURROUND_LEFT BIT(7)\n#define CM6206_REG2_MUTE_SUBWOOFER BIT(6)\n#define CM6206_REG2_MUTE_CENTER BIT(5)\n#define CM6206_REG2_MUTE_RIGHT_FRONT BIT(3)\n#define CM6206_REG2_MUTE_LEFT_FRONT BIT(3)\n#define CM6206_REG2_EN_BTL BIT(2)\n#define CM6206_REG2_MCUCLKSEL_1_5_MHZ (0)\n#define CM6206_REG2_MCUCLKSEL_3_MHZ (1)\n#define CM6206_REG2_MCUCLKSEL_6_MHZ (2)\n#define CM6206_REG2_MCUCLKSEL_12_MHZ (3)\n\n \n#define CM6206_REG3_FLYSPEED_DEFAULT (2 << 11)\n#define CM6206_REG3_VRAP25EN BIT(10)\n#define CM6206_REG3_MSEL1 BIT(9)\n#define CM6206_REG3_SPDIFI_RATE_44_1K BIT(0 << 7)\n#define CM6206_REG3_SPDIFI_RATE_48K BIT(2 << 7)\n#define CM6206_REG3_SPDIFI_RATE_32K BIT(3 << 7)\n#define CM6206_REG3_PINSEL BIT(6)\n#define CM6206_REG3_FOE BIT(5)\n#define CM6206_REG3_ROE BIT(4)\n#define CM6206_REG3_CBOE BIT(3)\n#define CM6206_REG3_LOSE BIT(2)\n#define CM6206_REG3_HPOE BIT(1)\n#define CM6206_REG3_SPDIFI_CANREC BIT(0)\n\n#define CM6206_REG5_DA_RSTN BIT(13)\n#define CM6206_REG5_AD_RSTN BIT(12)\n#define CM6206_REG5_SPDIFO_AD2SPDO BIT(12)\n#define CM6206_REG5_SPDIFO_SEL_FRONT (0 << 9)\n#define CM6206_REG5_SPDIFO_SEL_SIDE_SUR (1 << 9)\n#define CM6206_REG5_SPDIFO_SEL_CEN_LFE (2 << 9)\n#define CM6206_REG5_SPDIFO_SEL_REAR_SUR (3 << 9)\n#define CM6206_REG5_CODECM BIT(8)\n#define CM6206_REG5_EN_HPF BIT(7)\n#define CM6206_REG5_T_SEL_DSDA4 BIT(6)\n#define CM6206_REG5_T_SEL_DSDA3 BIT(5)\n#define CM6206_REG5_T_SEL_DSDA2 BIT(4)\n#define CM6206_REG5_T_SEL_DSDA1 BIT(3)\n#define CM6206_REG5_T_SEL_DSDAD_NORMAL 0\n#define CM6206_REG5_T_SEL_DSDAD_FRONT 4\n#define CM6206_REG5_T_SEL_DSDAD_S_SURROUND 5\n#define CM6206_REG5_T_SEL_DSDAD_CEN_LFE 6\n#define CM6206_REG5_T_SEL_DSDAD_R_SURROUND 7\n\nstatic int snd_usb_cm6206_boot_quirk(struct usb_device *dev)\n{\n\tint err  = 0, reg;\n\tint val[] = {\n\t\t \n\t\tCM6206_REG0_SPDIFO_RATE_48K |\n\t\tCM6206_REG0_SPDIFO_COPYRIGHT_NA,\n\t\t \n\t\tCM6206_REG1_PLLBIN_EN |\n\t\tCM6206_REG1_SOFT_MUTE_EN,\n\t\t \n\t\tCM6206_REG2_DRIVER_ON |\n\t\tCM6206_REG2_HEADP_SEL_FRONT_CHANNELS |\n\t\tCM6206_REG2_MUTE_HEADPHONE_RIGHT |\n\t\tCM6206_REG2_MUTE_HEADPHONE_LEFT,\n\t\t \n\t\tCM6206_REG3_FLYSPEED_DEFAULT |\n\t\tCM6206_REG3_VRAP25EN |\n\t\tCM6206_REG3_FOE |\n\t\tCM6206_REG3_ROE |\n\t\tCM6206_REG3_CBOE |\n\t\tCM6206_REG3_LOSE |\n\t\tCM6206_REG3_HPOE |\n\t\tCM6206_REG3_SPDIFI_CANREC,\n\t\t \n\t\t0x0000,\n\t\t \n\t\tCM6206_REG5_DA_RSTN |\n\t\tCM6206_REG5_AD_RSTN };\n\n\tfor (reg = 0; reg < ARRAY_SIZE(val); reg++) {\n\t\terr = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n \nstatic int snd_usb_gamecon780_boot_quirk(struct usb_device *dev)\n{\n\t \n\tu8 buf[2] = { 0x74, 0xe3 };\n\treturn snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\tUAC_FU_VOLUME << 8, 9 << 8, buf, 2);\n}\n\n \nstatic int snd_usb_novation_boot_quirk(struct usb_device *dev)\n{\n\t \n\tusb_set_interface(dev, 0, 1);\n\treturn 0;\n}\n\n \nstatic int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\t \n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf;\n\n\tif (usb_pipe_type_check(dev, usb_sndintpipe(dev, 0x05)))\n\t\treturn -EINVAL;\n\tbuf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)\n{\n\tint ret;\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t  0xaf, USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t  1, 0, NULL, 0, 1000);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusb_reset_device(dev);\n\n\t \n\treturn -EAGAIN;\n}\n\nstatic void mbox2_setup_48_24_magic(struct usb_device *dev)\n{\n\tu8 srate[3];\n\tu8 temp[12];\n\n\t \n\tsrate[0] = 0x80;\n\tsrate[1] = 0xbb;\n\tsrate[2] = 0x00;\n\n\t \n\tsnd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t0x01, 0x22, 0x0100, 0x0085, &temp, 0x0003);\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t0x81, 0xa2, 0x0100, 0x0085, &srate, 0x0003);\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t0x81, 0xa2, 0x0100, 0x0086, &srate, 0x0003);\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t0x81, 0xa2, 0x0100, 0x0003, &srate, 0x0003);\n\treturn;\n}\n\n \n\n#define MBOX2_FIRMWARE_SIZE    646\n#define MBOX2_BOOT_LOADING     0x01  \n#define MBOX2_BOOT_READY       0x02  \n\nstatic int snd_usb_mbox2_boot_quirk(struct usb_device *dev)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint err;\n\tu8 bootresponse[0x12];\n\tint fwsize;\n\tint count;\n\n\tfwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);\n\n\tif (fwsize != MBOX2_FIRMWARE_SIZE) {\n\t\tdev_err(&dev->dev, \"Invalid firmware size=%d.\\n\", fwsize);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"Sending Digidesign Mbox 2 boot sequence...\\n\");\n\n\tcount = 0;\n\tbootresponse[0] = MBOX2_BOOT_LOADING;\n\twhile ((bootresponse[0] == MBOX2_BOOT_LOADING) && (count < 10)) {\n\t\tmsleep(500);  \n\t\tsnd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t \n\t\t\t0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);\n\t\tif (bootresponse[0] == MBOX2_BOOT_READY)\n\t\t\tbreak;\n\t\tdev_dbg(&dev->dev, \"device not ready, resending boot sequence...\\n\");\n\t\tcount++;\n\t}\n\n\tif (bootresponse[0] != MBOX2_BOOT_READY) {\n\t\tdev_err(&dev->dev, \"Unknown bootresponse=%d, or timed out, ignoring device.\\n\", bootresponse[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"device initialised!\\n\");\n\n\terr = usb_get_descriptor(dev, USB_DT_DEVICE, 0,\n\t\t&dev->descriptor, sizeof(dev->descriptor));\n\tconfig = dev->actconfig;\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_get_descriptor: %d\\n\", err);\n\n\terr = usb_reset_configuration(dev);\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_reset_configuration: %d\\n\", err);\n\tdev_dbg(&dev->dev, \"mbox2_boot: new boot length = %d\\n\",\n\t\tle16_to_cpu(get_cfg_desc(config)->wTotalLength));\n\n\tmbox2_setup_48_24_magic(dev);\n\n\tdev_info(&dev->dev, \"Digidesign Mbox 2: 24bit 48kHz\");\n\n\treturn 0;  \n}\n\nstatic int snd_usb_axefx3_boot_quirk(struct usb_device *dev)\n{\n\tint err;\n\n\tdev_dbg(&dev->dev, \"Waiting for Axe-Fx III to boot up...\\n\");\n\n\t \n\terr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,\n\t\t\t\t1, 1, NULL, 0, 120000);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"failed waiting for Axe-Fx III to boot: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_dbg(&dev->dev, \"Axe-Fx III is now ready\\n\");\n\n\terr = usb_set_interface(dev, 1, 0);\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"error stopping Axe-Fx III interface: %d\\n\", err);\n\n\treturn 0;\n}\n\nstatic void mbox3_setup_48_24_magic(struct usb_device *dev)\n{\n\t \n\t \n\t \n\n\n\t \n\tu8 com_buff[4] = {0x80, 0xbb, 0x00, 0x00};\n\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x01, 0x21, 0x0100, 0x0001, &com_buff, 4);  \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x01, 0x21, 0x0100, 0x8101, &com_buff, 4);\n\n\t \n\t \n\t \n\tcom_buff[0] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t0x01, 0x21, 0x0003, 0x2001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x01;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0100, 0x8001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0110, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0111, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0114, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0115, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0118, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0119, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011c, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011d, 0x4001, &com_buff, 2);\n\n\t \n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x00;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0100, 0x4001, &com_buff, 2);\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0101, 0x4001, &com_buff, 2);\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0104, 0x4001, &com_buff, 2);\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x00;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0105, 0x4001, &com_buff, 2);\n\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0108, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0109, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010c, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010d, 0x4001, &com_buff, 2);\n\n\t \n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0120, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0121, 0x4001, &com_buff, 2);\n\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0100, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0101, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0102, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0103, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0104, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0105, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0106, 0x4201, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0107, 0x4201, &com_buff, 2);\n\n\t \n\tcom_buff[0] = 0x02;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t3, 0x21, 0x0000, 0x2001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t3, 0x21, 0x0002, 0x2001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t3, 0x21, 0x0001, 0x2001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0112, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0113, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0116, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0117, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011a, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011b, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011e, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x011f, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0102, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0103, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0106, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0107, 0x4001, &com_buff, 2);\n\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x00;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010a, 0x4001, &com_buff, 2);\n\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010b, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010e, 0x4001, &com_buff, 2);\n\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x00;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x010f, 0x4001, &com_buff, 2);\n\n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x80;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0122, 0x4001, &com_buff, 2);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0123, 0x4001, &com_buff, 2);\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tcom_buff[0] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0200, 0x4301, &com_buff, 1);\t \n\t \n\n\n\t \n\t \n\t \n\tcom_buff[0] = 0x00;\n\tcom_buff[1] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0400, 0x4301, &com_buff, 2);\n\n\t \n\t \n\t \n\tcom_buff[0] = 0x00;\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0500, 0x4301, &com_buff, 1);\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t1, 0x21, 0x0300, 0x4301, &com_buff, 1);\n\n\t \n\t \n\t \n\t \n\t \n\tcom_buff[0] = 0x05;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t3, 0x21, 0x0005, 0x2001, &com_buff, 1);\n\n\t \n\tcom_buff[0] = 0x00;\n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t3, 0x21, 0x0004, 0x2001, &com_buff, 1);\n}\n\n#define MBOX3_DESCRIPTOR_SIZE\t464\n\nstatic int snd_usb_mbox3_boot_quirk(struct usb_device *dev)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint err;\n\tint descriptor_size;\n\n\tdescriptor_size = le16_to_cpu(get_cfg_desc(config)->wTotalLength);\n\n\tif (descriptor_size != MBOX3_DESCRIPTOR_SIZE) {\n\t\tdev_err(&dev->dev, \"Invalid descriptor size=%d.\\n\", descriptor_size);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"device initialised!\\n\");\n\n\terr = usb_get_descriptor(dev, USB_DT_DEVICE, 0,\n\t\t&dev->descriptor, sizeof(dev->descriptor));\n\tconfig = dev->actconfig;\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_get_descriptor: %d\\n\", err);\n\n\terr = usb_reset_configuration(dev);\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_reset_configuration: %d\\n\", err);\n\tdev_dbg(&dev->dev, \"mbox3_boot: new boot length = %d\\n\",\n\t\tle16_to_cpu(get_cfg_desc(config)->wTotalLength));\n\n\tmbox3_setup_48_24_magic(dev);\n\tdev_info(&dev->dev, \"Digidesign Mbox 3: 24bit 48kHz\");\n\n\treturn 0;  \n}\n\n#define MICROBOOK_BUF_SIZE 128\n\nstatic int snd_usb_motu_microbookii_communicate(struct usb_device *dev, u8 *buf,\n\t\t\t\t\t\tint buf_size, int *length)\n{\n\tint err, actual_length;\n\n\tif (usb_pipe_type_check(dev, usb_sndintpipe(dev, 0x01)))\n\t\treturn -EINVAL;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x01), buf, *length,\n\t\t\t\t&actual_length, 1000);\n\tif (err < 0)\n\t\treturn err;\n\n\tprint_hex_dump(KERN_DEBUG, \"MicroBookII snd: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       buf, actual_length, false);\n\n\tmemset(buf, 0, buf_size);\n\n\tif (usb_pipe_type_check(dev, usb_rcvintpipe(dev, 0x82)))\n\t\treturn -EINVAL;\n\terr = usb_interrupt_msg(dev, usb_rcvintpipe(dev, 0x82), buf, buf_size,\n\t\t\t\t&actual_length, 1000);\n\tif (err < 0)\n\t\treturn err;\n\n\tprint_hex_dump(KERN_DEBUG, \"MicroBookII rcv: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       buf, actual_length, false);\n\n\t*length = actual_length;\n\treturn 0;\n}\n\nstatic int snd_usb_motu_microbookii_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length, poll_attempts = 0;\n\tstatic const u8 set_samplerate_seq[] = { 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t\t 0x00, 0x00, 0x0b, 0x14,\n\t\t\t\t\t\t 0x00, 0x00, 0x00, 0x01 };\n\tstatic const u8 poll_ready_seq[] = { 0x00, 0x04, 0x00, 0x00,\n\t\t\t\t\t     0x00, 0x00, 0x0b, 0x18 };\n\tu8 *buf = kzalloc(MICROBOOK_BUF_SIZE, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdev_info(&dev->dev, \"Waiting for MOTU Microbook II to boot up...\\n\");\n\n\t \n\tmemcpy(buf, set_samplerate_seq, sizeof(set_samplerate_seq));\n\tactual_length = sizeof(set_samplerate_seq);\n\terr = snd_usb_motu_microbookii_communicate(dev, buf, MICROBOOK_BUF_SIZE,\n\t\t\t\t\t\t   &actual_length);\n\n\tif (err < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"failed setting the sample rate for Motu MicroBook II: %d\\n\",\n\t\t\terr);\n\t\tgoto free_buf;\n\t}\n\n\t \n\twhile (true) {\n\t\tif (++poll_attempts > 100) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"failed booting Motu MicroBook II: timeout\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto free_buf;\n\t\t}\n\n\t\tmemset(buf, 0, MICROBOOK_BUF_SIZE);\n\t\tmemcpy(buf, poll_ready_seq, sizeof(poll_ready_seq));\n\n\t\tactual_length = sizeof(poll_ready_seq);\n\t\terr = snd_usb_motu_microbookii_communicate(\n\t\t\tdev, buf, MICROBOOK_BUF_SIZE, &actual_length);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"failed booting Motu MicroBook II: communication error %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto free_buf;\n\t\t}\n\n\t\t \n\t\tif (actual_length == 12 && buf[actual_length - 1] == 1)\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t}\n\n\tdev_info(&dev->dev, \"MOTU MicroBook II ready\\n\");\n\nfree_buf:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int snd_usb_motu_m_series_boot_quirk(struct usb_device *dev)\n{\n\tmsleep(4000);\n\n\treturn 0;\n}\n\n \n#define MAUDIO_SET\t\t0x01  \n#define MAUDIO_SET_COMPATIBLE\t0x80  \n#define MAUDIO_SET_DTS\t\t0x02  \n#define MAUDIO_SET_96K\t\t0x04  \n#define MAUDIO_SET_24B\t\t0x08  \n#define MAUDIO_SET_DI\t\t0x10  \n#define MAUDIO_SET_MASK\t\t0x1f  \n#define MAUDIO_SET_24B_48K_DI\t 0x19  \n#define MAUDIO_SET_24B_48K_NOTDI 0x09  \n#define MAUDIO_SET_16B_48K_DI\t 0x11  \n#define MAUDIO_SET_16B_48K_NOTDI 0x01  \n\nstatic int quattro_skip_setting_quirk(struct snd_usb_audio *chip,\n\t\t\t\t      int iface, int altno)\n{\n\t \n\tusb_set_interface(chip->dev, iface, 0);\n\tif (chip->setup & MAUDIO_SET) {\n\t\tif (chip->setup & MAUDIO_SET_COMPATIBLE) {\n\t\t\tif (iface != 1 && iface != 2)\n\t\t\t\treturn 1;  \n\t\t} else {\n\t\t\tunsigned int mask;\n\t\t\tif (iface == 1 || iface == 2)\n\t\t\t\treturn 1;  \n\t\t\tif ((chip->setup & MAUDIO_SET_96K) && altno != 1)\n\t\t\t\treturn 1;  \n\t\t\tmask = chip->setup & MAUDIO_SET_MASK;\n\t\t\tif (mask == MAUDIO_SET_24B_48K_DI && altno != 2)\n\t\t\t\treturn 1;  \n\t\t\tif (mask == MAUDIO_SET_24B_48K_NOTDI && altno != 3)\n\t\t\t\treturn 1;  \n\t\t\tif (mask == MAUDIO_SET_16B_48K_NOTDI && altno != 4)\n\t\t\t\treturn 1;  \n\t\t}\n\t}\n\tusb_audio_dbg(chip,\n\t\t    \"using altsetting %d for interface %d config %d\\n\",\n\t\t    altno, iface, chip->setup);\n\treturn 0;  \n}\n\nstatic int audiophile_skip_setting_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t int iface,\n\t\t\t\t\t int altno)\n{\n\t \n\tusb_set_interface(chip->dev, iface, 0);\n\n\tif (chip->setup & MAUDIO_SET) {\n\t\tunsigned int mask;\n\t\tif ((chip->setup & MAUDIO_SET_DTS) && altno != 6)\n\t\t\treturn 1;  \n\t\tif ((chip->setup & MAUDIO_SET_96K) && altno != 1)\n\t\t\treturn 1;  \n\t\tmask = chip->setup & MAUDIO_SET_MASK;\n\t\tif (mask == MAUDIO_SET_24B_48K_DI && altno != 2)\n\t\t\treturn 1;  \n\t\tif (mask == MAUDIO_SET_24B_48K_NOTDI && altno != 3)\n\t\t\treturn 1;  \n\t\tif (mask == MAUDIO_SET_16B_48K_DI && altno != 4)\n\t\t\treturn 1;  \n\t\tif (mask == MAUDIO_SET_16B_48K_NOTDI && altno != 5)\n\t\t\treturn 1;  \n\t}\n\n\treturn 0;  \n}\n\nstatic int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t   int iface, int altno)\n{\n\t \n\tusb_set_interface(chip->dev, iface, 0);\n\n\t \n\tif (chip->setup & (MAUDIO_SET | MAUDIO_SET_24B)) {\n\t\tif (chip->setup & MAUDIO_SET_96K) {\n\t\t\tif (altno != 3 && altno != 6)\n\t\t\t\treturn 1;\n\t\t} else if (chip->setup & MAUDIO_SET_DI) {\n\t\t\tif (iface == 4)\n\t\t\t\treturn 1;  \n\t\t\tif (altno != 2 && altno != 5)\n\t\t\t\treturn 1;  \n\t\t} else {\n\t\t\tif (iface == 5)\n\t\t\t\treturn 1;  \n\t\t\tif (altno != 2 && altno != 5)\n\t\t\t\treturn 1;  \n\t\t}\n\t} else {\n\t\t \n\t\tif (altno != 1)\n\t\t\treturn 1;\n\t}\n\n\tusb_audio_dbg(chip,\n\t\t    \"using altsetting %d for interface %d config %d\\n\",\n\t\t    altno, iface, chip->setup);\n\treturn 0;  \n}\n\nstatic int s1810c_skip_setting_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t   int iface, int altno)\n{\n\t \n\n\t \n\tif ((chip->setup == 0 || chip->setup > 2) && altno != 2)\n\t\treturn 1;\n\telse if (chip->setup == 1 && altno != 1)\n\t\treturn 1;\n\telse if (chip->setup == 2 && altno != 3)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  int iface,\n\t\t\t\t  int altno)\n{\n\t \n\tif (chip->usb_id == USB_ID(0x0763, 0x2003))\n\t\treturn audiophile_skip_setting_quirk(chip, iface, altno);\n\t \n\tif (chip->usb_id == USB_ID(0x0763, 0x2001))\n\t\treturn quattro_skip_setting_quirk(chip, iface, altno);\n\t \n\tif (chip->usb_id == USB_ID(0x0763, 0x2012))\n\t\treturn fasttrackpro_skip_setting_quirk(chip, iface, altno);\n\t \n\tif (chip->usb_id == USB_ID(0x194f, 0x010c))\n\t\treturn s1810c_skip_setting_quirk(chip, iface, altno);\n\n\n\treturn 0;\n}\n\nint snd_usb_apply_boot_quirk(struct usb_device *dev,\n\t\t\t     struct usb_interface *intf,\n\t\t\t     const struct snd_usb_audio_quirk *quirk,\n\t\t\t     unsigned int id)\n{\n\tswitch (id) {\n\tcase USB_ID(0x041e, 0x3000):\n\t\t \n\t\t \n\t\treturn snd_usb_extigy_boot_quirk(dev, intf);\n\n\tcase USB_ID(0x041e, 0x3020):\n\t\t \n\t\treturn snd_usb_audigy2nx_boot_quirk(dev);\n\n\tcase USB_ID(0x10f5, 0x0200):\n\t\t \n\t\treturn snd_usb_cm106_boot_quirk(dev);\n\n\tcase USB_ID(0x0d8c, 0x0102):\n\t\t \n\tcase USB_ID(0x0ccd, 0x00b1):  \n\t\treturn snd_usb_cm6206_boot_quirk(dev);\n\n\tcase USB_ID(0x0dba, 0x3000):\n\t\t \n\t\treturn snd_usb_mbox2_boot_quirk(dev);\n\tcase USB_ID(0x0dba, 0x5000):\n\t\t \n\t\treturn snd_usb_mbox3_boot_quirk(dev);\n\n\n\tcase USB_ID(0x1235, 0x0010):  \n\tcase USB_ID(0x1235, 0x0018):  \n\t\treturn snd_usb_novation_boot_quirk(dev);\n\n\tcase USB_ID(0x133e, 0x0815):\n\t\t \n\t\treturn snd_usb_accessmusic_boot_quirk(dev);\n\n\tcase USB_ID(0x17cc, 0x1000):  \n\tcase USB_ID(0x17cc, 0x1010):  \n\tcase USB_ID(0x17cc, 0x1020):  \n\t\treturn snd_usb_nativeinstruments_boot_quirk(dev);\n\tcase USB_ID(0x0763, 0x2012):   \n\t\treturn snd_usb_fasttrackpro_boot_quirk(dev);\n\tcase USB_ID(0x047f, 0xc010):  \n\t\treturn snd_usb_gamecon780_boot_quirk(dev);\n\tcase USB_ID(0x2466, 0x8010):  \n\t\treturn snd_usb_axefx3_boot_quirk(dev);\n\tcase USB_ID(0x07fd, 0x0004):  \n\t\t \n\t\tif (get_iface_desc(intf->altsetting)->bInterfaceClass ==\n\t\t    USB_CLASS_VENDOR_SPEC &&\n\t\t    get_iface_desc(intf->altsetting)->bInterfaceNumber < 3)\n\t\t\treturn snd_usb_motu_microbookii_boot_quirk(dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_apply_boot_quirk_once(struct usb_device *dev,\n\t\t\t\t  struct usb_interface *intf,\n\t\t\t\t  const struct snd_usb_audio_quirk *quirk,\n\t\t\t\t  unsigned int id)\n{\n\tswitch (id) {\n\tcase USB_ID(0x07fd, 0x0008):  \n\t\treturn snd_usb_motu_m_series_boot_quirk(dev);\n\t}\n\n\treturn 0;\n}\n\n \nint snd_usb_is_big_endian_format(struct snd_usb_audio *chip,\n\t\t\t\t const struct audioformat *fp)\n{\n\t \n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2001):  \n\t\tif (fp->altsetting == 2 || fp->altsetting == 3 ||\n\t\t\tfp->altsetting == 5 || fp->altsetting == 6)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2003):  \n\t\tif (chip->setup == 0x00 ||\n\t\t\tfp->altsetting == 1 || fp->altsetting == 2 ||\n\t\t\tfp->altsetting == 3)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2012):  \n\t\tif (fp->altsetting == 2 || fp->altsetting == 3 ||\n\t\t\tfp->altsetting == 5 || fp->altsetting == 6)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\nenum {\n\tEMU_QUIRK_SR_44100HZ = 0,\n\tEMU_QUIRK_SR_48000HZ,\n\tEMU_QUIRK_SR_88200HZ,\n\tEMU_QUIRK_SR_96000HZ,\n\tEMU_QUIRK_SR_176400HZ,\n\tEMU_QUIRK_SR_192000HZ\n};\n\nstatic void set_format_emu_quirk(struct snd_usb_substream *subs,\n\t\t\t\t const struct audioformat *fmt)\n{\n\tunsigned char emu_samplerate_id = 0;\n\n\t \n\tif (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (subs->stream->substream[SNDRV_PCM_STREAM_CAPTURE].cur_audiofmt)\n\t\t\treturn;\n\t}\n\n\tswitch (fmt->rate_min) {\n\tcase 48000:\n\t\temu_samplerate_id = EMU_QUIRK_SR_48000HZ;\n\t\tbreak;\n\tcase 88200:\n\t\temu_samplerate_id = EMU_QUIRK_SR_88200HZ;\n\t\tbreak;\n\tcase 96000:\n\t\temu_samplerate_id = EMU_QUIRK_SR_96000HZ;\n\t\tbreak;\n\tcase 176400:\n\t\temu_samplerate_id = EMU_QUIRK_SR_176400HZ;\n\t\tbreak;\n\tcase 192000:\n\t\temu_samplerate_id = EMU_QUIRK_SR_192000HZ;\n\t\tbreak;\n\tdefault:\n\t\temu_samplerate_id = EMU_QUIRK_SR_44100HZ;\n\t\tbreak;\n\t}\n\tsnd_emuusb_set_samplerate(subs->stream->chip, emu_samplerate_id);\n\tsubs->pkt_offset_adj = (emu_samplerate_id >= EMU_QUIRK_SR_176400HZ) ? 4 : 0;\n}\n\nstatic int pioneer_djm_set_format_quirk(struct snd_usb_substream *subs,\n\t\t\t\t\tu16 windex)\n{\n\tunsigned int cur_rate = subs->data_endpoint->cur_rate;\n\tu8 sr[3];\n\t\n\tsr[0] = cur_rate & 0xff;\n\tsr[1] = (cur_rate >> 8) & 0xff;\n\tsr[2] = (cur_rate >> 16) & 0xff;\n\tusb_set_interface(subs->dev, 0, 1);\n\t\n\tsnd_usb_ctl_msg(subs->stream->chip->dev,\n\t\tusb_sndctrlpipe(subs->stream->chip->dev, 0),\n\t\t0x01, 0x22, 0x0100, windex, &sr, 0x0003);\n\treturn 0;\n}\n\nvoid snd_usb_set_format_quirk(struct snd_usb_substream *subs,\n\t\t\t      const struct audioformat *fmt)\n{\n\tswitch (subs->stream->chip->usb_id) {\n\tcase USB_ID(0x041e, 0x3f02):  \n\tcase USB_ID(0x041e, 0x3f04):  \n\tcase USB_ID(0x041e, 0x3f0a):  \n\tcase USB_ID(0x041e, 0x3f19):  \n\t\tset_format_emu_quirk(subs, fmt);\n\t\tbreak;\n\tcase USB_ID(0x534d, 0x0021):  \n\tcase USB_ID(0x534d, 0x2109):  \n\t\tsubs->stream_offset_adj = 2;\n\t\tbreak;\n\tcase USB_ID(0x2b73, 0x0013):  \n\t\tpioneer_djm_set_format_quirk(subs, 0x0082);\n\t\tbreak;\n\tcase USB_ID(0x08e4, 0x017f):  \n\tcase USB_ID(0x08e4, 0x0163):  \n\t\tpioneer_djm_set_format_quirk(subs, 0x0086);\n\t\tbreak;\n\t}\n}\n\nint snd_usb_select_mode_quirk(struct snd_usb_audio *chip,\n\t\t\t      const struct audioformat *fmt)\n{\n\tstruct usb_device *dev = chip->dev;\n\tint err;\n\n\tif (chip->quirk_flags & QUIRK_FLAG_ITF_USB_DSD_DAC) {\n\t\t \n\t\terr = usb_set_interface(dev, fmt->iface, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmsleep(20);  \n\n\t\t \n\t\tif (fmt->formats & SNDRV_PCM_FMTBIT_DSD_U32_BE) {\n\t\t\t \n\t\t\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,\n\t\t\t\t\t      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t\t\t      1, 1, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,\n\t\t\t\t\t      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t\t\t      0, 1, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t}\n\t\tmsleep(20);\n\t}\n\treturn 0;\n}\n\nvoid snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)\n{\n\t \n\tif (USB_ID_VENDOR(ep->chip->usb_id) == 0x23ba &&\n\t    ep->type == SND_USB_ENDPOINT_TYPE_SYNC)\n\t\tep->skip_packets = 4;\n\n\t \n\tif ((ep->chip->usb_id == USB_ID(0x0763, 0x2030) ||\n\t     ep->chip->usb_id == USB_ID(0x0763, 0x2031)) &&\n\t    ep->type == SND_USB_ENDPOINT_TYPE_DATA)\n\t\tep->skip_packets = 16;\n\n\t \n\tif ((ep->chip->usb_id == USB_ID(0x0644, 0x8038) ||   \n\t     ep->chip->usb_id == USB_ID(0x1852, 0x5034)) &&  \n\t    ep->syncmaxsize == 4)\n\t\tep->tenor_fb_quirk = 1;\n}\n\n \nvoid snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,\n\t\t\t   __u8 request, __u8 requesttype, __u16 value,\n\t\t\t   __u16 index, void *data, __u16 size)\n{\n\tstruct snd_usb_audio *chip = dev_get_drvdata(&dev->dev);\n\n\tif (!chip || (requesttype & USB_TYPE_MASK) != USB_TYPE_CLASS)\n\t\treturn;\n\n\tif (chip->quirk_flags & QUIRK_FLAG_CTL_MSG_DELAY)\n\t\tmsleep(20);\n\telse if (chip->quirk_flags & QUIRK_FLAG_CTL_MSG_DELAY_1M)\n\t\tusleep_range(1000, 2000);\n\telse if (chip->quirk_flags & QUIRK_FLAG_CTL_MSG_DELAY_5M)\n\t\tusleep_range(5000, 6000);\n}\n\n \nu64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,\n\t\t\t\t\tstruct audioformat *fp,\n\t\t\t\t\tunsigned int sample_bytes)\n{\n\tstruct usb_interface *iface;\n\n\t \n\tif (USB_ID_VENDOR(chip->usb_id) == 0x23ba &&\n\t    USB_ID_PRODUCT(chip->usb_id) < 0x0110) {\n\t\tswitch (fp->altsetting) {\n\t\tcase 1:\n\t\t\tfp->dsd_dop = true;\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U16_LE;\n\t\tcase 2:\n\t\t\tfp->dsd_bitrev = true;\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U8;\n\t\tcase 3:\n\t\t\tfp->dsd_bitrev = true;\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U16_LE;\n\t\t}\n\t}\n\n\t \n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x139f, 0x5504):  \n\tcase USB_ID(0x20b1, 0x3089):  \n\tcase USB_ID(0x2522, 0x0007):  \n\tcase USB_ID(0x2522, 0x0009):  \n\tcase USB_ID(0x2522, 0x0012):  \n\tcase USB_ID(0x2772, 0x0230):  \n\t\tif (fp->altsetting == 2)\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\t\tbreak;\n\n\tcase USB_ID(0x0d8c, 0x0316):  \n\tcase USB_ID(0x10cb, 0x0103):  \n\tcase USB_ID(0x16d0, 0x06b2):  \n\tcase USB_ID(0x16d0, 0x06b4):  \n\tcase USB_ID(0x16d0, 0x0733):  \n\tcase USB_ID(0x16d0, 0x09d8):  \n\tcase USB_ID(0x16d0, 0x09db):  \n\tcase USB_ID(0x16d0, 0x09dd):  \n\tcase USB_ID(0x1db5, 0x0003):  \n\tcase USB_ID(0x20a0, 0x4143):  \n\tcase USB_ID(0x22e1, 0xca01):  \n\tcase USB_ID(0x249c, 0x9326):  \n\tcase USB_ID(0x2616, 0x0106):  \n\tcase USB_ID(0x2622, 0x0041):  \n\tcase USB_ID(0x278b, 0x5100):  \n\tcase USB_ID(0x27f7, 0x3002):  \n\tcase USB_ID(0x29a2, 0x0086):  \n\tcase USB_ID(0x6b42, 0x0042):  \n\t\tif (fp->altsetting == 3)\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\t\tbreak;\n\n\t \n\tcase USB_ID(0x16d0, 0x071a):   \n\t\tif (fp->altsetting == 2) {\n\t\t\tswitch (le16_to_cpu(chip->dev->descriptor.bcdDevice)) {\n\t\t\tcase 0x199:\n\t\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_LE;\n\t\t\tcase 0x19b:\n\t\t\tcase 0x203:\n\t\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase USB_ID(0x16d0, 0x0a23):\n\t\tif (fp->altsetting == 2)\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (chip->quirk_flags & QUIRK_FLAG_ITF_USB_DSD_DAC) {\n\t\tiface = usb_ifnum_to_if(chip->dev, fp->iface);\n\n\t\t \n\t\tif (fp->altsetting == iface->num_altsetting - 1)\n\t\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\t}\n\n\t \n\tif ((chip->quirk_flags & QUIRK_FLAG_DSD_RAW) && fp->dsd_raw)\n\t\treturn SNDRV_PCM_FMTBIT_DSD_U32_BE;\n\n\treturn 0;\n}\n\nvoid snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t  struct audioformat *fp,\n\t\t\t\t\t  int stream)\n{\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0a92, 0x0053):  \n\t\t \n\t\tfp->attributes &= ~UAC_EP_CS_ATTR_SAMPLE_RATE;\n\t\tbreak;\n\tcase USB_ID(0x041e, 0x3020):  \n\tcase USB_ID(0x0763, 0x2003):  \n\t\t \n\t\tfp->attributes |= UAC_EP_CS_ATTR_SAMPLE_RATE;\n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2001):   \n\tcase USB_ID(0x0763, 0x2012):   \n\tcase USB_ID(0x047f, 0x0ca1):  \n\tcase USB_ID(0x077d, 0x07af):  \n\t \n\t\tfp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tfp->ep_attr |= USB_ENDPOINT_SYNC_ADAPTIVE;\n\t\telse\n\t\t\tfp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;\n\t\tbreak;\n\tcase USB_ID(0x07fd, 0x0004):   \n\t\t \n\t\tfp->attributes &= ~UAC_EP_CS_ATTR_FILL_MAX;\n\t\tbreak;\n\tcase USB_ID(0x1224, 0x2a25):   \n\t\t \n\t\tfp->attributes |= UAC_EP_CS_ATTR_FILL_MAX;\n\t\tbreak;\n\tcase USB_ID(0x3511, 0x2b1e):  \n\t\t \n\t\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tfp->attributes &= ~UAC_EP_CS_ATTR_PITCH_CONTROL;\n\t\tbreak;\n\t}\n}\n\n \nstruct usb_audio_quirk_flags_table {\n\tu32 id;\n\tu32 flags;\n};\n\n#define DEVICE_FLG(vid, pid, _flags) \\\n\t{ .id = USB_ID(vid, pid), .flags = (_flags) }\n#define VENDOR_FLG(vid, _flags) DEVICE_FLG(vid, 0, _flags)\n\nstatic const struct usb_audio_quirk_flags_table quirk_flags_table[] = {\n\t \n\tDEVICE_FLG(0x041e, 0x3000,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x041e, 0x4080,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x045e, 0x083c,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE | QUIRK_FLAG_CTL_MSG_DELAY |\n\t\t   QUIRK_FLAG_DISABLE_AUTOSUSPEND),\n\tDEVICE_FLG(0x046d, 0x084c,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE | QUIRK_FLAG_CTL_MSG_DELAY_1M),\n\tDEVICE_FLG(0x046d, 0x0991,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY_1M | QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x046d, 0x09a4,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY_1M | QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x0499, 0x1509,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x04d8, 0xfeea,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x04e8, 0xa051,  \n\t\t   QUIRK_FLAG_SKIP_CLOCK_SELECTOR | QUIRK_FLAG_CTL_MSG_DELAY_5M),\n\tDEVICE_FLG(0x054c, 0x0b8c,  \n\t\t   QUIRK_FLAG_SET_IFACE_FIRST),\n\tDEVICE_FLG(0x0556, 0x0014,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x05a3, 0x9420,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x05a7, 0x1020,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x05e1, 0x0408,  \n\t\t   QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x05e1, 0x0480,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x0644, 0x8043,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY |\n\t\t   QUIRK_FLAG_IFACE_DELAY),\n\tDEVICE_FLG(0x0644, 0x8044,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY |\n\t\t   QUIRK_FLAG_IFACE_DELAY),\n\tDEVICE_FLG(0x0644, 0x804a,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY |\n\t\t   QUIRK_FLAG_IFACE_DELAY),\n\tDEVICE_FLG(0x0644, 0x805f,  \n\t\t   QUIRK_FLAG_FORCE_IFACE_RESET),\n\tDEVICE_FLG(0x0644, 0x806b,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY |\n\t\t   QUIRK_FLAG_IFACE_DELAY),\n\tDEVICE_FLG(0x06f8, 0xb000,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x06f8, 0xd002,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x0711, 0x5800,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x074d, 0x3553,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x0763, 0x2030,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x0763, 0x2031,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x08bb, 0x2702,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x0951, 0x16ad,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY_1M),\n\tDEVICE_FLG(0x0b0e, 0x0349,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY_1M),\n\tDEVICE_FLG(0x0fd9, 0x0008,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x1395, 0x740a,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x1397, 0x0507,  \n\t\t   QUIRK_FLAG_PLAYBACK_FIRST | QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x1397, 0x0508,  \n\t\t   QUIRK_FLAG_PLAYBACK_FIRST | QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x1397, 0x0509,  \n\t\t   QUIRK_FLAG_PLAYBACK_FIRST | QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x13e5, 0x0001,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x154e, 0x1002,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY),\n\tDEVICE_FLG(0x154e, 0x1003,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY),\n\tDEVICE_FLG(0x154e, 0x3005,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY),\n\tDEVICE_FLG(0x154e, 0x3006,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY),\n\tDEVICE_FLG(0x154e, 0x300b,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tDEVICE_FLG(0x154e, 0x500e,  \n\t\t   QUIRK_FLAG_IGNORE_CLOCK_SOURCE),\n\tDEVICE_FLG(0x1686, 0x00dd,  \n\t\t   QUIRK_FLAG_TX_LENGTH | QUIRK_FLAG_CTL_MSG_DELAY_1M),\n\tDEVICE_FLG(0x17aa, 0x1046,  \n\t\t   QUIRK_FLAG_DISABLE_AUTOSUSPEND),\n\tDEVICE_FLG(0x17aa, 0x104d,  \n\t\t   QUIRK_FLAG_DISABLE_AUTOSUSPEND),\n\tDEVICE_FLG(0x1852, 0x5065,  \n\t\t   QUIRK_FLAG_ITF_USB_DSD_DAC | QUIRK_FLAG_CTL_MSG_DELAY),\n\tDEVICE_FLG(0x1901, 0x0191,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x2040, 0x7200,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7201,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7210,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7211,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7213,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7217,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x721b,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x721e,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x721f,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7240,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7260,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7270,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7280,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x7281,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x2040, 0x8200,  \n\t\t   QUIRK_FLAG_SHARE_MEDIA_DEVICE | QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x21b4, 0x0081,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x21b4, 0x0230,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tDEVICE_FLG(0x21b4, 0x0232,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tDEVICE_FLG(0x2522, 0x0007,  \n\t\t   QUIRK_FLAG_SET_IFACE_FIRST),\n\tDEVICE_FLG(0x2708, 0x0002,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x2912, 0x30c8,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x30be, 0x0101,  \n\t\t   QUIRK_FLAG_IGNORE_CTL_ERROR),\n\tDEVICE_FLG(0x413c, 0xa506,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x534d, 0x0021,  \n\t\t   QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x534d, 0x2109,  \n\t\t   QUIRK_FLAG_ALIGN_TRANSFER),\n\tDEVICE_FLG(0x1224, 0x2a25,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tDEVICE_FLG(0x2b53, 0x0023,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x2b53, 0x0024,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x2b53, 0x0031,  \n\t\t   QUIRK_FLAG_GENERIC_IMPLICIT_FB),\n\tDEVICE_FLG(0x0525, 0xa4ad,  \n\t\t   QUIRK_FLAG_IFACE_SKIP_CLOSE),\n\tDEVICE_FLG(0x0ecb, 0x205c,  \n\t\t   QUIRK_FLAG_FIXED_RATE),\n\tDEVICE_FLG(0x0ecb, 0x2069,  \n\t\t   QUIRK_FLAG_FIXED_RATE),\n\tDEVICE_FLG(0x1bcf, 0x2283,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\n\t \n\tVENDOR_FLG(0x045e,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tVENDOR_FLG(0x046d,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY_1M),\n\tVENDOR_FLG(0x047f,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE | QUIRK_FLAG_CTL_MSG_DELAY),\n\tVENDOR_FLG(0x0644,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY | QUIRK_FLAG_IFACE_DELAY),\n\tVENDOR_FLG(0x07fd,  \n\t\t   QUIRK_FLAG_VALIDATE_RATES),\n\tVENDOR_FLG(0x1235,  \n\t\t   QUIRK_FLAG_VALIDATE_RATES),\n\tVENDOR_FLG(0x1511,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x152a,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x18d1,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x1de7,  \n\t\t   QUIRK_FLAG_GET_SAMPLE_RATE),\n\tVENDOR_FLG(0x20b1,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x21ed,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x22d9,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x23ba,  \n\t\t   QUIRK_FLAG_CTL_MSG_DELAY | QUIRK_FLAG_IFACE_DELAY |\n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x25ce,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x278b,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x292b,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x2972,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x2ab6,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x2afd,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x2d87,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x3336,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x3353,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x35f4,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0x3842,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\tVENDOR_FLG(0xc502,  \n\t\t   QUIRK_FLAG_DSD_RAW),\n\n\t{}  \n};\n\nvoid snd_usb_init_quirk_flags(struct snd_usb_audio *chip)\n{\n\tconst struct usb_audio_quirk_flags_table *p;\n\n\tfor (p = quirk_flags_table; p->id; p++) {\n\t\tif (chip->usb_id == p->id ||\n\t\t    (!USB_ID_PRODUCT(p->id) &&\n\t\t     USB_ID_VENDOR(chip->usb_id) == USB_ID_VENDOR(p->id))) {\n\t\t\tusb_audio_dbg(chip,\n\t\t\t\t      \"Set quirk_flags 0x%x for device %04x:%04x\\n\",\n\t\t\t\t      p->flags, USB_ID_VENDOR(chip->usb_id),\n\t\t\t\t      USB_ID_PRODUCT(chip->usb_id));\n\t\t\tchip->quirk_flags |= p->flags;\n\t\t\treturn;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}