{
  "module_name": "mixer_quirks.c",
  "hash_id": "bd363bfeb70aadcd23c10b93a160fd40e644417c5e37659cf508ced27f65f50d",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_quirks.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/init.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/hda_verbs.h>\n#include <sound/hwdep.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"mixer_quirks.h\"\n#include \"mixer_scarlett.h\"\n#include \"mixer_scarlett_gen2.h\"\n#include \"mixer_us16x08.h\"\n#include \"mixer_s1810c.h\"\n#include \"helper.h\"\n\nstruct std_mono_table {\n\tunsigned int unitid, control, cmask;\n\tint val_type;\n\tconst char *name;\n\tsnd_kcontrol_tlv_rw_t *tlv_callback;\n};\n\n \nstatic int snd_create_std_mono_ctl_offset(struct usb_mixer_interface *mixer,\n\t\t\t\tunsigned int unitid,\n\t\t\t\tunsigned int control,\n\t\t\t\tunsigned int cmask,\n\t\t\t\tint val_type,\n\t\t\t\tunsigned int idx_off,\n\t\t\t\tconst char *name,\n\t\t\t\tsnd_kcontrol_tlv_rw_t *tlv_callback)\n{\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, mixer, unitid);\n\tcval->val_type = val_type;\n\tcval->channels = 1;\n\tcval->control = control;\n\tcval->cmask = cmask;\n\tcval->idx_off = idx_off;\n\n\t \n\tcval->min = 0;\n\tcval->max = 1;\n\tcval->res = 0;\n\tcval->dBmin = 0;\n\tcval->dBmax = 0;\n\n\t \n\tkctl = snd_ctl_new1(snd_usb_feature_unit_ctl, cval);\n\tif (!kctl) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsnprintf(kctl->id.name, sizeof(kctl->id.name), name);\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t \n\tif (tlv_callback) {\n\t\tkctl->tlv.c = tlv_callback;\n\t\tkctl->vd[0].access |=\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\t \n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int snd_create_std_mono_ctl(struct usb_mixer_interface *mixer,\n\t\t\t\tunsigned int unitid,\n\t\t\t\tunsigned int control,\n\t\t\t\tunsigned int cmask,\n\t\t\t\tint val_type,\n\t\t\t\tconst char *name,\n\t\t\t\tsnd_kcontrol_tlv_rw_t *tlv_callback)\n{\n\treturn snd_create_std_mono_ctl_offset(mixer, unitid, control, cmask,\n\t\tval_type, 0  , name, tlv_callback);\n}\n\n \nstatic int snd_create_std_mono_table(struct usb_mixer_interface *mixer,\n\t\t\t\t     const struct std_mono_table *t)\n{\n\tint err;\n\n\twhile (t->name != NULL) {\n\t\terr = snd_create_std_mono_ctl(mixer, t->unitid, t->control,\n\t\t\t\tt->cmask, t->val_type, t->name, t->tlv_callback);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tt++;\n\t}\n\n\treturn 0;\n}\n\nstatic int add_single_ctl_with_resume(struct usb_mixer_interface *mixer,\n\t\t\t\t      int id,\n\t\t\t\t      usb_mixer_elem_resume_func_t resume,\n\t\t\t\t      const struct snd_kcontrol_new *knew,\n\t\t\t\t      struct usb_mixer_elem_list **listp)\n{\n\tstruct usb_mixer_elem_list *list;\n\tstruct snd_kcontrol *kctl;\n\n\tlist = kzalloc(sizeof(*list), GFP_KERNEL);\n\tif (!list)\n\t\treturn -ENOMEM;\n\tif (listp)\n\t\t*listp = list;\n\tlist->mixer = mixer;\n\tlist->id = id;\n\tlist->resume = resume;\n\tkctl = snd_ctl_new1(knew, list);\n\tif (!kctl) {\n\t\tkfree(list);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\t \n\treturn snd_usb_mixer_add_list(list, kctl, false);\n}\n\n \nstatic const struct rc_config {\n\tu32 usb_id;\n\tu8  offset;\n\tu8  length;\n\tu8  packet_length;\n\tu8  min_packet_length;  \n\tu8  mute_mixer_id;\n\tu32 mute_code;\n} rc_configs[] = {\n\t{ USB_ID(0x041e, 0x3000), 0, 1, 2, 1,  18, 0x0013 },  \n\t{ USB_ID(0x041e, 0x3020), 2, 1, 6, 6,  18, 0x0013 },  \n\t{ USB_ID(0x041e, 0x3040), 2, 2, 6, 6,  2,  0x6e91 },  \n\t{ USB_ID(0x041e, 0x3042), 0, 1, 1, 1,  1,  0x000d },  \n\t{ USB_ID(0x041e, 0x30df), 0, 1, 1, 1,  1,  0x000d },  \n\t{ USB_ID(0x041e, 0x3237), 0, 1, 1, 1,  1,  0x000d },  \n\t{ USB_ID(0x041e, 0x3263), 0, 1, 1, 1,  1,  0x000d },  \n\t{ USB_ID(0x041e, 0x3048), 2, 2, 6, 6,  2,  0x6e91 },  \n};\n\nstatic void snd_usb_soundblaster_remote_complete(struct urb *urb)\n{\n\tstruct usb_mixer_interface *mixer = urb->context;\n\tconst struct rc_config *rc = mixer->rc_cfg;\n\tu32 code;\n\n\tif (urb->status < 0 || urb->actual_length < rc->min_packet_length)\n\t\treturn;\n\n\tcode = mixer->rc_buffer[rc->offset];\n\tif (rc->length == 2)\n\t\tcode |= mixer->rc_buffer[rc->offset + 1] << 8;\n\n\t \n\tif (code == rc->mute_code)\n\t\tsnd_usb_mixer_notify_id(mixer, rc->mute_mixer_id);\n\tmixer->rc_code = code;\n\twmb();\n\twake_up(&mixer->rc_waitq);\n}\n\nstatic long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw, char __user *buf,\n\t\t\t\t     long count, loff_t *offset)\n{\n\tstruct usb_mixer_interface *mixer = hw->private_data;\n\tint err;\n\tu32 rc_code;\n\n\tif (count != 1 && count != 4)\n\t\treturn -EINVAL;\n\terr = wait_event_interruptible(mixer->rc_waitq,\n\t\t\t\t       (rc_code = xchg(&mixer->rc_code, 0)) != 0);\n\tif (err == 0) {\n\t\tif (count == 1)\n\t\t\terr = put_user(rc_code, buf);\n\t\telse\n\t\t\terr = put_user(rc_code, (u32 __user *)buf);\n\t}\n\treturn err < 0 ? err : count;\n}\n\nstatic __poll_t snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw, struct file *file,\n\t\t\t\t\t    poll_table *wait)\n{\n\tstruct usb_mixer_interface *mixer = hw->private_data;\n\n\tpoll_wait(file, &mixer->rc_waitq, wait);\n\treturn mixer->rc_code ? EPOLLIN | EPOLLRDNORM : 0;\n}\n\nstatic int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer)\n{\n\tstruct snd_hwdep *hwdep;\n\tint err, len, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rc_configs); ++i)\n\t\tif (rc_configs[i].usb_id == mixer->chip->usb_id)\n\t\t\tbreak;\n\tif (i >= ARRAY_SIZE(rc_configs))\n\t\treturn 0;\n\tmixer->rc_cfg = &rc_configs[i];\n\n\tlen = mixer->rc_cfg->packet_length;\n\n\tinit_waitqueue_head(&mixer->rc_waitq);\n\terr = snd_hwdep_new(mixer->chip->card, \"SB remote control\", 0, &hwdep);\n\tif (err < 0)\n\t\treturn err;\n\tsnprintf(hwdep->name, sizeof(hwdep->name),\n\t\t \"%s remote control\", mixer->chip->card->shortname);\n\thwdep->iface = SNDRV_HWDEP_IFACE_SB_RC;\n\thwdep->private_data = mixer;\n\thwdep->ops.read = snd_usb_sbrc_hwdep_read;\n\thwdep->ops.poll = snd_usb_sbrc_hwdep_poll;\n\thwdep->exclusive = 1;\n\n\tmixer->rc_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mixer->rc_urb)\n\t\treturn -ENOMEM;\n\tmixer->rc_setup_packet = kmalloc(sizeof(*mixer->rc_setup_packet), GFP_KERNEL);\n\tif (!mixer->rc_setup_packet) {\n\t\tusb_free_urb(mixer->rc_urb);\n\t\tmixer->rc_urb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tmixer->rc_setup_packet->bRequestType =\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\tmixer->rc_setup_packet->bRequest = UAC_GET_MEM;\n\tmixer->rc_setup_packet->wValue = cpu_to_le16(0);\n\tmixer->rc_setup_packet->wIndex = cpu_to_le16(0);\n\tmixer->rc_setup_packet->wLength = cpu_to_le16(len);\n\tusb_fill_control_urb(mixer->rc_urb, mixer->chip->dev,\n\t\t\t     usb_rcvctrlpipe(mixer->chip->dev, 0),\n\t\t\t     (u8*)mixer->rc_setup_packet, mixer->rc_buffer, len,\n\t\t\t     snd_usb_soundblaster_remote_complete, mixer);\n\treturn 0;\n}\n\n#define snd_audigy2nx_led_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = kcontrol->private_value >> 8;\n\treturn 0;\n}\n\nstatic int snd_audigy2nx_led_update(struct usb_mixer_interface *mixer,\n\t\t\t\t    int value, int index)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->usb_id == USB_ID(0x041e, 0x3042))\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0), 0x24,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t      !value, 0, NULL, 0);\n\t \n\tif (chip->usb_id == USB_ID(0x041e, 0x30df))\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0), 0x24,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t      !value, 0, NULL, 0);\n\telse\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0), 0x24,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t      value, index + 2, NULL, 0);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint index = kcontrol->private_value & 0xff;\n\tunsigned int value = ucontrol->value.integer.value[0];\n\tint old_value = kcontrol->private_value >> 8;\n\tint err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\tif (value == old_value)\n\t\treturn 0;\n\tkcontrol->private_value = (value << 8) | index;\n\terr = snd_audigy2nx_led_update(mixer, value, index);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_audigy2nx_led_resume(struct usb_mixer_elem_list *list)\n{\n\tint priv_value = list->kctl->private_value;\n\n\treturn snd_audigy2nx_led_update(list->mixer, priv_value >> 8,\n\t\t\t\t\tpriv_value & 0xff);\n}\n\n \nstatic const struct snd_kcontrol_new snd_audigy2nx_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_audigy2nx_led_info,\n\t.get = snd_audigy2nx_led_get,\n\t.put = snd_audigy2nx_led_put,\n};\n\nstatic const char * const snd_audigy2nx_led_names[] = {\n\t\"CMSS LED Switch\",\n\t\"Power LED Switch\",\n\t\"Dolby Digital LED Switch\",\n};\n\nstatic int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_audigy2nx_led_names); ++i) {\n\t\tstruct snd_kcontrol_new knew;\n\n\t\t \n\t\tif ((mixer->chip->usb_id == USB_ID(0x041e, 0x3042)) && i == 0)\n\t\t\tcontinue;\n\t\t \n\t\tif ((mixer->chip->usb_id == USB_ID(0x041e, 0x30df)) && i == 0)\n\t\t\tcontinue;\n\t\tif (i > 1 &&  \n\t\t\t(mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\n\t\t\t mixer->chip->usb_id == USB_ID(0x041e, 0x3042) ||\n\t\t\t mixer->chip->usb_id == USB_ID(0x041e, 0x30df) ||\n\t\t\t mixer->chip->usb_id == USB_ID(0x041e, 0x3048)))\n\t\t\tbreak; \n\n\t\tknew = snd_audigy2nx_control;\n\t\tknew.name = snd_audigy2nx_led_names[i];\n\t\tknew.private_value = (1 << 8) | i;  \n\t\terr = add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t\t snd_audigy2nx_led_resume,\n\t\t\t\t\t\t &knew, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void snd_audigy2nx_proc_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstatic const struct sb_jack {\n\t\tint unitid;\n\t\tconst char *name;\n\t}  jacks_audigy2nx[] = {\n\t\t{4,  \"dig in \"},\n\t\t{7,  \"line in\"},\n\t\t{19, \"spk out\"},\n\t\t{20, \"hph out\"},\n\t\t{-1, NULL}\n\t}, jacks_live24ext[] = {\n\t\t{4,  \"line in\"},  \n\t\t{3,  \"hph out\"},  \n\t\t{0,  \"RC     \"},  \n\t\t{-1, NULL}\n\t};\n\tconst struct sb_jack *jacks;\n\tstruct usb_mixer_interface *mixer = entry->private_data;\n\tint i, err;\n\tu8 buf[3];\n\n\tsnd_iprintf(buffer, \"%s jacks\\n\\n\", mixer->chip->card->shortname);\n\tif (mixer->chip->usb_id == USB_ID(0x041e, 0x3020))\n\t\tjacks = jacks_audigy2nx;\n\telse if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\n\t\t mixer->chip->usb_id == USB_ID(0x041e, 0x3048))\n\t\tjacks = jacks_live24ext;\n\telse\n\t\treturn;\n\n\tfor (i = 0; jacks[i].name; ++i) {\n\t\tsnd_iprintf(buffer, \"%s: \", jacks[i].name);\n\t\terr = snd_usb_lock_shutdown(mixer->chip);\n\t\tif (err < 0)\n\t\t\treturn;\n\t\terr = snd_usb_ctl_msg(mixer->chip->dev,\n\t\t\t\t      usb_rcvctrlpipe(mixer->chip->dev, 0),\n\t\t\t\t      UAC_GET_MEM, USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t\t      USB_RECIP_INTERFACE, 0,\n\t\t\t\t      jacks[i].unitid << 8, buf, 3);\n\t\tsnd_usb_unlock_shutdown(mixer->chip);\n\t\tif (err == 3 && (buf[0] == 3 || buf[0] == 6))\n\t\t\tsnd_iprintf(buffer, \"%02x %02x\\n\", buf[1], buf[2]);\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"?\\n\");\n\t}\n}\n\n \nstatic int snd_emu0204_ch_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\"1/2\", \"3/4\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int snd_emu0204_ch_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int snd_emu0204_ch_switch_update(struct usb_mixer_interface *mixer,\n\t\t\t\t\tint value)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\tunsigned char buf[2];\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tbuf[0] = 0x01;\n\tbuf[1] = value ? 0x02 : 0x01;\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t      usb_sndctrlpipe(chip->dev, 0), UAC_SET_CUR,\n\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t      0x0400, 0x0e00, buf, 2);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_emu0204_ch_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\tint err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value == kcontrol->private_value)\n\t\treturn 0;\n\n\tkcontrol->private_value = value;\n\terr = snd_emu0204_ch_switch_update(mixer, value);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_emu0204_ch_switch_resume(struct usb_mixer_elem_list *list)\n{\n\treturn snd_emu0204_ch_switch_update(list->mixer,\n\t\t\t\t\t    list->kctl->private_value);\n}\n\nstatic const struct snd_kcontrol_new snd_emu0204_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Front Jack Channels\",\n\t.info = snd_emu0204_ch_switch_info,\n\t.get = snd_emu0204_ch_switch_get,\n\t.put = snd_emu0204_ch_switch_put,\n\t.private_value = 0,\n};\n\nstatic int snd_emu0204_controls_create(struct usb_mixer_interface *mixer)\n{\n\treturn add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t  snd_emu0204_ch_switch_resume,\n\t\t\t\t\t  &snd_emu0204_control, NULL);\n}\n\n \n\nstatic int snd_xonar_u1_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = !!(kcontrol->private_value & 0x02);\n\treturn 0;\n}\n\nstatic int snd_xonar_u1_switch_update(struct usb_mixer_interface *mixer,\n\t\t\t\t      unsigned char status)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0), 0x08,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t      50, 0, &status, 1);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_xonar_u1_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tu8 old_status, new_status;\n\tint err;\n\n\told_status = kcontrol->private_value;\n\tif (ucontrol->value.integer.value[0])\n\t\tnew_status = old_status | 0x02;\n\telse\n\t\tnew_status = old_status & ~0x02;\n\tif (new_status == old_status)\n\t\treturn 0;\n\n\tkcontrol->private_value = new_status;\n\terr = snd_xonar_u1_switch_update(list->mixer, new_status);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_xonar_u1_switch_resume(struct usb_mixer_elem_list *list)\n{\n\treturn snd_xonar_u1_switch_update(list->mixer,\n\t\t\t\t\t  list->kctl->private_value);\n}\n\nstatic const struct snd_kcontrol_new snd_xonar_u1_output_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Digital Playback Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_xonar_u1_switch_get,\n\t.put = snd_xonar_u1_switch_put,\n\t.private_value = 0x05,\n};\n\nstatic int snd_xonar_u1_controls_create(struct usb_mixer_interface *mixer)\n{\n\treturn add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t  snd_xonar_u1_switch_resume,\n\t\t\t\t\t  &snd_xonar_u1_output_switch, NULL);\n}\n\n \n\nstatic int snd_mbox1_is_spdif_synced(struct snd_usb_audio *chip)\n{\n\tunsigned char buff[3];\n\tint err;\n\tint is_spdif_synced;\n\n\t \n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_rcvctrlpipe(chip->dev, 0), 0x81,\n\t\t\t      USB_DIR_IN |\n\t\t\t      USB_TYPE_CLASS |\n\t\t\t      USB_RECIP_ENDPOINT, 0x100, 0x81, buff, 3);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tis_spdif_synced = !(buff[0] | buff[1] | buff[2]);\n\treturn is_spdif_synced;\n}\n\nstatic int snd_mbox1_set_clk_source(struct snd_usb_audio *chip, int rate_or_zero)\n{\n\t \n\tunsigned char buff[3];\n\n\tbuff[0] = (rate_or_zero >>  0) & 0xff;\n\tbuff[1] = (rate_or_zero >>  8) & 0xff;\n\tbuff[2] = (rate_or_zero >> 16) & 0xff;\n\n\t \n\treturn snd_usb_ctl_msg(chip->dev,\n\t\t\t       usb_sndctrlpipe(chip->dev, 0), 0x1,\n\t\t\t       USB_TYPE_CLASS |\n\t\t\t       USB_RECIP_ENDPOINT, 0x100, 0x81, buff, 3);\n}\n\nstatic int snd_mbox1_is_spdif_input(struct snd_usb_audio *chip)\n{\n\t \n\tint err;\n\tunsigned char source[1];\n\n\t \n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_rcvctrlpipe(chip->dev, 0), 0x81,\n\t\t\t      USB_DIR_IN |\n\t\t\t      USB_TYPE_CLASS |\n\t\t\t      USB_RECIP_INTERFACE, 0x00, 0x500, source, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn (source[0] == 2);\n}\n\nstatic int snd_mbox1_set_input_source(struct snd_usb_audio *chip, int is_spdif)\n{\n\t \n\tunsigned char buff[1];\n\n\tbuff[0] = (is_spdif & 1) + 1;\n\n\t \n\treturn snd_usb_ctl_msg(chip->dev,\n\t\t\t       usb_sndctrlpipe(chip->dev, 0), 0x1,\n\t\t\t       USB_TYPE_CLASS |\n\t\t\t       USB_RECIP_INTERFACE, 0x00, 0x500, buff, 1);\n}\n\n \n\nstatic int snd_mbox1_clk_switch_get(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_is_spdif_synced(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\tkctl->private_value = err;\n\terr = 0;\n\tucontrol->value.enumerated.item[0] = kctl->private_value;\nerr:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_mbox1_clk_switch_update(struct usb_mixer_interface *mixer, int is_spdif_sync)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_mbox1_is_spdif_input(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_is_spdif_synced(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\t \n\terr = snd_mbox1_set_clk_source(chip, is_spdif_sync ? 0 : 48000);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_is_spdif_synced(chip);\nerr:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_mbox1_clk_switch_put(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\tbool cur_val, new_val;\n\n\tcur_val = kctl->private_value;\n\tnew_val = ucontrol->value.enumerated.item[0];\n\tif (cur_val == new_val)\n\t\treturn 0;\n\n\tkctl->private_value = new_val;\n\terr = snd_mbox1_clk_switch_update(mixer, new_val);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_mbox1_clk_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = {\n\t\t\"Internal\",\n\t\t\"S/PDIF\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int snd_mbox1_clk_switch_resume(struct usb_mixer_elem_list *list)\n{\n\treturn snd_mbox1_clk_switch_update(list->mixer, list->kctl->private_value);\n}\n\n \n\nstatic int snd_mbox1_src_switch_get(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = kctl->private_value;\n\treturn 0;\n}\n\nstatic int snd_mbox1_src_switch_update(struct usb_mixer_interface *mixer, int is_spdif_input)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_mbox1_is_spdif_input(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_set_input_source(chip, is_spdif_input);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_is_spdif_input(chip);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = snd_mbox1_is_spdif_synced(chip);\nerr:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_mbox1_src_switch_put(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\tbool cur_val, new_val;\n\n\tcur_val = kctl->private_value;\n\tnew_val = ucontrol->value.enumerated.item[0];\n\tif (cur_val == new_val)\n\t\treturn 0;\n\n\tkctl->private_value = new_val;\n\terr = snd_mbox1_src_switch_update(mixer, new_val);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_mbox1_src_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = {\n\t\t\"Analog\",\n\t\t\"S/PDIF\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int snd_mbox1_src_switch_resume(struct usb_mixer_elem_list *list)\n{\n\treturn snd_mbox1_src_switch_update(list->mixer, list->kctl->private_value);\n}\n\nstatic const struct snd_kcontrol_new snd_mbox1_clk_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Clock Source\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_mbox1_clk_switch_info,\n\t.get = snd_mbox1_clk_switch_get,\n\t.put = snd_mbox1_clk_switch_put,\n\t.private_value = 0\n};\n\nstatic const struct snd_kcontrol_new snd_mbox1_src_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Input Source\",\n\t.index = 1,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_mbox1_src_switch_info,\n\t.get = snd_mbox1_src_switch_get,\n\t.put = snd_mbox1_src_switch_put,\n\t.private_value = 0\n};\n\nstatic int snd_mbox1_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\terr = add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t snd_mbox1_clk_switch_resume,\n\t\t\t\t\t &snd_mbox1_clk_switch, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn add_single_ctl_with_resume(mixer, 1,\n\t\t\t\t\t  snd_mbox1_src_switch_resume,\n\t\t\t\t\t  &snd_mbox1_src_switch, NULL);\n}\n\n \n\n#define _MAKE_NI_CONTROL(bRequest,wIndex) ((bRequest) << 16 | (wIndex))\n\nstatic int snd_ni_control_init_val(struct usb_mixer_interface *mixer,\n\t\t\t\t   struct snd_kcontrol *kctl)\n{\n\tstruct usb_device *dev = mixer->chip->dev;\n\tunsigned int pval = kctl->private_value;\n\tu8 value;\n\tint err;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      (pval >> 16) & 0xff,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t      0, pval & 0xffff, &value, 1);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"unable to issue vendor read request (ret = %d)\", err);\n\t\treturn err;\n\t}\n\n\tkctl->private_value |= ((unsigned int)value << 24);\n\treturn 0;\n}\n\nstatic int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = kcontrol->private_value >> 24;\n\treturn 0;\n}\n\nstatic int snd_ni_update_cur_val(struct usb_mixer_elem_list *list)\n{\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tunsigned int pval = list->kctl->private_value;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = usb_control_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),\n\t\t\t      (pval >> 16) & 0xff,\n\t\t\t      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t      pval >> 24, pval & 0xffff, NULL, 0, 1000);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tu8 oldval = (kcontrol->private_value >> 24) & 0xff;\n\tu8 newval = ucontrol->value.integer.value[0];\n\tint err;\n\n\tif (oldval == newval)\n\t\treturn 0;\n\n\tkcontrol->private_value &= ~(0xff << 24);\n\tkcontrol->private_value |= (unsigned int)newval << 24;\n\terr = snd_ni_update_cur_val(list);\n\treturn err < 0 ? err : 1;\n}\n\nstatic const struct snd_kcontrol_new snd_nativeinstruments_ta6_mixers[] = {\n\t{\n\t\t.name = \"Direct Thru Channel A\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x03),\n\t},\n\t{\n\t\t.name = \"Direct Thru Channel B\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x05),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel A\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x03),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel B\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x05),\n\t},\n};\n\nstatic const struct snd_kcontrol_new snd_nativeinstruments_ta10_mixers[] = {\n\t{\n\t\t.name = \"Direct Thru Channel A\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x03),\n\t},\n\t{\n\t\t.name = \"Direct Thru Channel B\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x05),\n\t},\n\t{\n\t\t.name = \"Direct Thru Channel C\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x07),\n\t},\n\t{\n\t\t.name = \"Direct Thru Channel D\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x01, 0x09),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel A\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x03),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel B\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x05),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel C\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x07),\n\t},\n\t{\n\t\t.name = \"Phono Input Channel D\",\n\t\t.private_value = _MAKE_NI_CONTROL(0x02, 0x09),\n\t},\n};\n\nstatic int snd_nativeinstruments_create_mixer(struct usb_mixer_interface *mixer,\n\t\t\t\t\t      const struct snd_kcontrol_new *kc,\n\t\t\t\t\t      unsigned int count)\n{\n\tint i, err = 0;\n\tstruct snd_kcontrol_new template = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.get = snd_nativeinstruments_control_get,\n\t\t.put = snd_nativeinstruments_control_put,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t};\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct usb_mixer_elem_list *list;\n\n\t\ttemplate.name = kc[i].name;\n\t\ttemplate.private_value = kc[i].private_value;\n\n\t\terr = add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t\t snd_ni_update_cur_val,\n\t\t\t\t\t\t &template, &list);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tsnd_ni_control_init_val(mixer, list->kctl);\n\t}\n\n\treturn err;\n}\n\n \n \nstatic int snd_ftu_eff_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[8] = {\n\t\t\"Room 1\", \"Room 2\", \"Room 3\", \"Hall 1\",\n\t\t\"Hall 2\", \"Plate\", \"Delay\", \"Echo\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int snd_ftu_eff_switch_init(struct usb_mixer_interface *mixer,\n\t\t\t\t   struct snd_kcontrol *kctl)\n{\n\tstruct usb_device *dev = mixer->chip->dev;\n\tunsigned int pval = kctl->private_value;\n\tint err;\n\tunsigned char value[2];\n\n\tvalue[0] = 0x00;\n\tvalue[1] = 0x00;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC_GET_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      pval & 0xff00,\n\t\t\t      snd_usb_ctrl_intf(mixer->chip) | ((pval & 0xff) << 8),\n\t\t\t      value, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tkctl->private_value |= (unsigned int)value[0] << 24;\n\treturn 0;\n}\n\nstatic int snd_ftu_eff_switch_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = kctl->private_value >> 24;\n\treturn 0;\n}\n\nstatic int snd_ftu_eff_switch_update(struct usb_mixer_elem_list *list)\n{\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tunsigned int pval = list->kctl->private_value;\n\tunsigned char value[2];\n\tint err;\n\n\tvalue[0] = pval >> 24;\n\tvalue[1] = 0;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0),\n\t\t\t      UAC_SET_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t      pval & 0xff00,\n\t\t\t      snd_usb_ctrl_intf(chip) | ((pval & 0xff) << 8),\n\t\t\t      value, 2);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_ftu_eff_switch_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tunsigned int pval = list->kctl->private_value;\n\tint cur_val, err, new_val;\n\n\tcur_val = pval >> 24;\n\tnew_val = ucontrol->value.enumerated.item[0];\n\tif (cur_val == new_val)\n\t\treturn 0;\n\n\tkctl->private_value &= ~(0xff << 24);\n\tkctl->private_value |= new_val << 24;\n\terr = snd_ftu_eff_switch_update(list);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_ftu_create_effect_switch(struct usb_mixer_interface *mixer,\n\tint validx, int bUnitID)\n{\n\tstatic struct snd_kcontrol_new template = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Effect Program Switch\",\n\t\t.index = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ftu_eff_switch_info,\n\t\t.get = snd_ftu_eff_switch_get,\n\t\t.put = snd_ftu_eff_switch_put\n\t};\n\tstruct usb_mixer_elem_list *list;\n\tint err;\n\n\terr = add_single_ctl_with_resume(mixer, bUnitID,\n\t\t\t\t\t snd_ftu_eff_switch_update,\n\t\t\t\t\t &template, &list);\n\tif (err < 0)\n\t\treturn err;\n\tlist->kctl->private_value = (validx << 8) | bUnitID;\n\tsnd_ftu_eff_switch_init(mixer, list->kctl);\n\treturn 0;\n}\n\n \nstatic int snd_ftu_create_volume_ctls(struct usb_mixer_interface *mixer)\n{\n\tchar name[64];\n\tunsigned int control, cmask;\n\tint in, out, err;\n\n\tconst unsigned int id = 5;\n\tconst int val_type = USB_MIXER_S16;\n\n\tfor (out = 0; out < 8; out++) {\n\t\tcontrol = out + 1;\n\t\tfor (in = 0; in < 8; in++) {\n\t\t\tcmask = 1 << in;\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\"AIn%d - Out%d Capture Volume\",\n\t\t\t\tin  + 1, out + 1);\n\t\t\terr = snd_create_std_mono_ctl(mixer, id, control,\n\t\t\t\t\t\t\tcmask, val_type, name,\n\t\t\t\t\t\t\t&snd_usb_mixer_vol_tlv);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tfor (in = 8; in < 16; in++) {\n\t\t\tcmask = 1 << in;\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\"DIn%d - Out%d Playback Volume\",\n\t\t\t\tin - 7, out + 1);\n\t\t\terr = snd_create_std_mono_ctl(mixer, id, control,\n\t\t\t\t\t\t\tcmask, val_type, name,\n\t\t\t\t\t\t\t&snd_usb_mixer_vol_tlv);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_ftu_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Volume\";\n\tconst unsigned int id = 6;\n\tconst int val_type = USB_MIXER_U8;\n\tconst unsigned int control = 2;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, snd_usb_mixer_vol_tlv);\n}\n\n \nstatic int snd_ftu_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Duration\";\n\tconst unsigned int id = 6;\n\tconst int val_type = USB_MIXER_S16;\n\tconst unsigned int control = 3;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, snd_usb_mixer_vol_tlv);\n}\n\n \nstatic int snd_ftu_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Feedback Volume\";\n\tconst unsigned int id = 6;\n\tconst int val_type = USB_MIXER_U8;\n\tconst unsigned int control = 4;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, NULL);\n}\n\nstatic int snd_ftu_create_effect_return_ctls(struct usb_mixer_interface *mixer)\n{\n\tunsigned int cmask;\n\tint err, ch;\n\tchar name[48];\n\n\tconst unsigned int id = 7;\n\tconst int val_type = USB_MIXER_S16;\n\tconst unsigned int control = 7;\n\n\tfor (ch = 0; ch < 4; ++ch) {\n\t\tcmask = 1 << ch;\n\t\tsnprintf(name, sizeof(name),\n\t\t\t\"Effect Return %d Volume\", ch + 1);\n\t\terr = snd_create_std_mono_ctl(mixer, id, control,\n\t\t\t\t\t\tcmask, val_type, name,\n\t\t\t\t\t\tsnd_usb_mixer_vol_tlv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ftu_create_effect_send_ctls(struct usb_mixer_interface *mixer)\n{\n\tunsigned int  cmask;\n\tint err, ch;\n\tchar name[48];\n\n\tconst unsigned int id = 5;\n\tconst int val_type = USB_MIXER_S16;\n\tconst unsigned int control = 9;\n\n\tfor (ch = 0; ch < 8; ++ch) {\n\t\tcmask = 1 << ch;\n\t\tsnprintf(name, sizeof(name),\n\t\t\t\"Effect Send AIn%d Volume\", ch + 1);\n\t\terr = snd_create_std_mono_ctl(mixer, id, control, cmask,\n\t\t\t\t\t\tval_type, name,\n\t\t\t\t\t\tsnd_usb_mixer_vol_tlv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (ch = 8; ch < 16; ++ch) {\n\t\tcmask = 1 << ch;\n\t\tsnprintf(name, sizeof(name),\n\t\t\t\"Effect Send DIn%d Volume\", ch - 7);\n\t\terr = snd_create_std_mono_ctl(mixer, id, control, cmask,\n\t\t\t\t\t\tval_type, name,\n\t\t\t\t\t\tsnd_usb_mixer_vol_tlv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ftu_create_mixer(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\n\terr = snd_ftu_create_volume_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_switch(mixer, 1, 6);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_volume_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_duration_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_feedback_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_return_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_send_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nvoid snd_emuusb_set_samplerate(struct snd_usb_audio *chip,\n\t\t\t       unsigned char samplerate_id)\n{\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_info *cval;\n\tint unitid = 12;  \n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\tif (mixer->id_elems[unitid]) {\n\t\t\tcval = mixer_elem_list_to_info(mixer->id_elems[unitid]);\n\t\t\tsnd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR,\n\t\t\t\t\t\t    cval->control << 8,\n\t\t\t\t\t\t    samplerate_id);\n\t\t\tsnd_usb_mixer_notify_id(mixer, unitid);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n \nstatic int snd_c400_create_vol_ctls(struct usb_mixer_interface *mixer)\n{\n\tchar name[64];\n\tunsigned int cmask, offset;\n\tint out, chan, err;\n\tint num_outs = 0;\n\tint num_ins = 0;\n\n\tconst unsigned int id = 0x40;\n\tconst int val_type = USB_MIXER_S16;\n\tconst int control = 1;\n\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030):\n\t\tnum_outs = 6;\n\t\tnum_ins = 4;\n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2031):\n\t\tnum_outs = 8;\n\t\tnum_ins = 6;\n\t\tbreak;\n\t}\n\n\tfor (chan = 0; chan < num_outs + num_ins; chan++) {\n\t\tfor (out = 0; out < num_outs; out++) {\n\t\t\tif (chan < num_outs) {\n\t\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\t\"PCM%d-Out%d Playback Volume\",\n\t\t\t\t\tchan + 1, out + 1);\n\t\t\t} else {\n\t\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\t\"In%d-Out%d Playback Volume\",\n\t\t\t\t\tchan - num_outs + 1, out + 1);\n\t\t\t}\n\n\t\t\tcmask = (out == 0) ? 0 : 1 << (out - 1);\n\t\t\toffset = chan * num_outs;\n\t\t\terr = snd_create_std_mono_ctl_offset(mixer, id, control,\n\t\t\t\t\t\tcmask, val_type, offset, name,\n\t\t\t\t\t\t&snd_usb_mixer_vol_tlv);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_c400_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Volume\";\n\tconst unsigned int id = 0x43;\n\tconst int val_type = USB_MIXER_U8;\n\tconst unsigned int control = 3;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, snd_usb_mixer_vol_tlv);\n}\n\n \nstatic int snd_c400_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Duration\";\n\tconst unsigned int id = 0x43;\n\tconst int val_type = USB_MIXER_S16;\n\tconst unsigned int control = 4;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, snd_usb_mixer_vol_tlv);\n}\n\n \nstatic int snd_c400_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\n{\n\tstatic const char name[] = \"Effect Feedback Volume\";\n\tconst unsigned int id = 0x43;\n\tconst int val_type = USB_MIXER_U8;\n\tconst unsigned int control = 5;\n\tconst unsigned int cmask = 0;\n\n\treturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\n\t\t\t\t\tname, NULL);\n}\n\nstatic int snd_c400_create_effect_vol_ctls(struct usb_mixer_interface *mixer)\n{\n\tchar name[64];\n\tunsigned int cmask;\n\tint chan, err;\n\tint num_outs = 0;\n\tint num_ins = 0;\n\n\tconst unsigned int id = 0x42;\n\tconst int val_type = USB_MIXER_S16;\n\tconst int control = 1;\n\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030):\n\t\tnum_outs = 6;\n\t\tnum_ins = 4;\n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2031):\n\t\tnum_outs = 8;\n\t\tnum_ins = 6;\n\t\tbreak;\n\t}\n\n\tfor (chan = 0; chan < num_outs + num_ins; chan++) {\n\t\tif (chan < num_outs) {\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\"Effect Send DOut%d\",\n\t\t\t\tchan + 1);\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t\"Effect Send AIn%d\",\n\t\t\t\tchan - num_outs + 1);\n\t\t}\n\n\t\tcmask = (chan == 0) ? 0 : 1 << (chan - 1);\n\t\terr = snd_create_std_mono_ctl(mixer, id, control,\n\t\t\t\t\t\tcmask, val_type, name,\n\t\t\t\t\t\t&snd_usb_mixer_vol_tlv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_c400_create_effect_ret_vol_ctls(struct usb_mixer_interface *mixer)\n{\n\tchar name[64];\n\tunsigned int cmask;\n\tint chan, err;\n\tint num_outs = 0;\n\tint offset = 0;\n\n\tconst unsigned int id = 0x40;\n\tconst int val_type = USB_MIXER_S16;\n\tconst int control = 1;\n\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030):\n\t\tnum_outs = 6;\n\t\toffset = 0x3c;\n\t\t \n\t\tbreak;\n\tcase USB_ID(0x0763, 0x2031):\n\t\tnum_outs = 8;\n\t\toffset = 0x70;\n\t\t \n\t\tbreak;\n\t}\n\n\tfor (chan = 0; chan < num_outs; chan++) {\n\t\tsnprintf(name, sizeof(name),\n\t\t\t\"Effect Return %d\",\n\t\t\tchan + 1);\n\n\t\tcmask = (chan == 0) ? 0 :\n\t\t\t1 << (chan + (chan % 2) * num_outs - 1);\n\t\terr = snd_create_std_mono_ctl_offset(mixer, id, control,\n\t\t\t\t\t\tcmask, val_type, offset, name,\n\t\t\t\t\t\t&snd_usb_mixer_vol_tlv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_c400_create_mixer(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\n\terr = snd_c400_create_vol_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_c400_create_effect_vol_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_c400_create_effect_ret_vol_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ftu_create_effect_switch(mixer, 2, 0x43);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_c400_create_effect_volume_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_c400_create_effect_duration_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_c400_create_effect_feedback_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic const struct std_mono_table ebox44_table[] = {\n\t{\n\t\t.unitid = 4,\n\t\t.control = 1,\n\t\t.cmask = 0x0,\n\t\t.val_type = USB_MIXER_INV_BOOLEAN,\n\t\t.name = \"Headphone Playback Switch\"\n\t},\n\t{\n\t\t.unitid = 4,\n\t\t.control = 2,\n\t\t.cmask = 0x1,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Headphone A Mix Playback Volume\"\n\t},\n\t{\n\t\t.unitid = 4,\n\t\t.control = 2,\n\t\t.cmask = 0x2,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Headphone B Mix Playback Volume\"\n\t},\n\n\t{\n\t\t.unitid = 7,\n\t\t.control = 1,\n\t\t.cmask = 0x0,\n\t\t.val_type = USB_MIXER_INV_BOOLEAN,\n\t\t.name = \"Output Playback Switch\"\n\t},\n\t{\n\t\t.unitid = 7,\n\t\t.control = 2,\n\t\t.cmask = 0x1,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Output A Playback Volume\"\n\t},\n\t{\n\t\t.unitid = 7,\n\t\t.control = 2,\n\t\t.cmask = 0x2,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Output B Playback Volume\"\n\t},\n\n\t{\n\t\t.unitid = 10,\n\t\t.control = 1,\n\t\t.cmask = 0x0,\n\t\t.val_type = USB_MIXER_INV_BOOLEAN,\n\t\t.name = \"Input Capture Switch\"\n\t},\n\t{\n\t\t.unitid = 10,\n\t\t.control = 2,\n\t\t.cmask = 0x1,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Input A Capture Volume\"\n\t},\n\t{\n\t\t.unitid = 10,\n\t\t.control = 2,\n\t\t.cmask = 0x2,\n\t\t.val_type = USB_MIXER_S16,\n\t\t.name = \"Input B Capture Volume\"\n\t},\n\n\t{}\n};\n\n \nstatic int snd_microii_spdif_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_microii_spdif_default_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tint err;\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alts;\n\tunsigned int ep;\n\tunsigned char data[3];\n\tint rate;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tucontrol->value.iec958.status[0] = kcontrol->private_value & 0xff;\n\tucontrol->value.iec958.status[1] = (kcontrol->private_value >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = 0x00;\n\n\t \n\tiface = usb_ifnum_to_if(chip->dev, 1);\n\tif (!iface || iface->num_altsetting < 2) {\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\talts = &iface->altsetting[1];\n\tif (get_iface_desc(alts)->bNumEndpoints < 1) {\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\tep = get_endpoint(alts, 0)->bEndpointAddress;\n\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_rcvctrlpipe(chip->dev, 0),\n\t\t\tUAC_GET_CUR,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_IN,\n\t\t\tUAC_EP_CS_ATTR_SAMPLE_RATE << 8,\n\t\t\tep,\n\t\t\tdata,\n\t\t\tsizeof(data));\n\tif (err < 0)\n\t\tgoto end;\n\n\trate = data[0] | (data[1] << 8) | (data[2] << 16);\n\tucontrol->value.iec958.status[3] = (rate == 48000) ?\n\t\t\tIEC958_AES3_CON_FS_48000 : IEC958_AES3_CON_FS_44100;\n\n\terr = 0;\n end:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_microii_spdif_default_update(struct usb_mixer_elem_list *list)\n{\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tunsigned int pval = list->kctl->private_value;\n\tu8 reg;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\treg = ((pval >> 4) & 0xf0) | (pval & 0x0f);\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_sndctrlpipe(chip->dev, 0),\n\t\t\tUAC_SET_CUR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\treg,\n\t\t\t2,\n\t\t\tNULL,\n\t\t\t0);\n\tif (err < 0)\n\t\tgoto end;\n\n\treg = (pval & IEC958_AES0_NONAUDIO) ? 0xa0 : 0x20;\n\treg |= (pval >> 12) & 0x0f;\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_sndctrlpipe(chip->dev, 0),\n\t\t\tUAC_SET_CUR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\treg,\n\t\t\t3,\n\t\t\tNULL,\n\t\t\t0);\n\tif (err < 0)\n\t\tgoto end;\n\n end:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_microii_spdif_default_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tunsigned int pval, pval_old;\n\tint err;\n\n\tpval = pval_old = kcontrol->private_value;\n\tpval &= 0xfffff0f0;\n\tpval |= (ucontrol->value.iec958.status[1] & 0x0f) << 8;\n\tpval |= (ucontrol->value.iec958.status[0] & 0x0f);\n\n\tpval &= 0xffff0fff;\n\tpval |= (ucontrol->value.iec958.status[1] & 0xf0) << 8;\n\n\t \n\n\t \n\n\tif (pval == pval_old)\n\t\treturn 0;\n\n\tkcontrol->private_value = pval;\n\terr = snd_microii_spdif_default_update(list);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_microii_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0x0f;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0x00;\n\tucontrol->value.iec958.status[3] = 0x00;\n\n\treturn 0;\n}\n\nstatic int snd_microii_spdif_switch_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = !(kcontrol->private_value & 0x02);\n\n\treturn 0;\n}\n\nstatic int snd_microii_spdif_switch_update(struct usb_mixer_elem_list *list)\n{\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tu8 reg = list->kctl->private_value;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_sndctrlpipe(chip->dev, 0),\n\t\t\tUAC_SET_CUR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\treg,\n\t\t\t9,\n\t\t\tNULL,\n\t\t\t0);\n\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_microii_spdif_switch_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tu8 reg;\n\tint err;\n\n\treg = ucontrol->value.integer.value[0] ? 0x28 : 0x2a;\n\tif (reg != list->kctl->private_value)\n\t\treturn 0;\n\n\tkcontrol->private_value = reg;\n\terr = snd_microii_spdif_switch_update(list);\n\treturn err < 0 ? err : 1;\n}\n\nstatic const struct snd_kcontrol_new snd_microii_mixer_spdif[] = {\n\t{\n\t\t.iface =    SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =     SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info =     snd_microii_spdif_info,\n\t\t.get =      snd_microii_spdif_default_get,\n\t\t.put =      snd_microii_spdif_default_put,\n\t\t.private_value = 0x00000100UL, \n\t},\n\t{\n\t\t.access =   SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface =    SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =     SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, MASK),\n\t\t.info =     snd_microii_spdif_info,\n\t\t.get =      snd_microii_spdif_mask_get,\n\t},\n\t{\n\t\t.iface =    SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =     SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, SWITCH),\n\t\t.info =     snd_ctl_boolean_mono_info,\n\t\t.get =      snd_microii_spdif_switch_get,\n\t\t.put =      snd_microii_spdif_switch_put,\n\t\t.private_value = 0x00000028UL, \n\t}\n};\n\nstatic int snd_microii_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint err, i;\n\tstatic const usb_mixer_elem_resume_func_t resume_funcs[] = {\n\t\tsnd_microii_spdif_default_update,\n\t\tNULL,\n\t\tsnd_microii_spdif_switch_update\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_microii_mixer_spdif); ++i) {\n\t\terr = add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t\t resume_funcs[i],\n\t\t\t\t\t\t &snd_microii_mixer_spdif[i],\n\t\t\t\t\t\t NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int snd_soundblaster_e1_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int snd_soundblaster_e1_switch_update(struct usb_mixer_interface *mixer,\n\t\t\t\t\t     unsigned char state)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\tunsigned char buff[2];\n\n\tbuff[0] = 0x02;\n\tbuff[1] = state ? 0x02 : 0x00;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\tusb_sndctrlpipe(chip->dev, 0), HID_REQ_SET_REPORT,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t0x0202, 3, buff, 2);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_soundblaster_e1_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tunsigned char value = !!ucontrol->value.integer.value[0];\n\tint err;\n\n\tif (kcontrol->private_value == value)\n\t\treturn 0;\n\tkcontrol->private_value = value;\n\terr = snd_soundblaster_e1_switch_update(list->mixer, value);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_soundblaster_e1_switch_resume(struct usb_mixer_elem_list *list)\n{\n\treturn snd_soundblaster_e1_switch_update(list->mixer,\n\t\t\t\t\t\t list->kctl->private_value);\n}\n\nstatic int snd_soundblaster_e1_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = {\n\t\t\"Mic\", \"Aux\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic const struct snd_kcontrol_new snd_soundblaster_e1_input_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Input Source\",\n\t.info = snd_soundblaster_e1_switch_info,\n\t.get = snd_soundblaster_e1_switch_get,\n\t.put = snd_soundblaster_e1_switch_put,\n\t.private_value = 0,\n};\n\nstatic int snd_soundblaster_e1_switch_create(struct usb_mixer_interface *mixer)\n{\n\treturn add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t  snd_soundblaster_e1_switch_resume,\n\t\t\t\t\t  &snd_soundblaster_e1_input_switch,\n\t\t\t\t\t  NULL);\n}\n\n \n\n#define HDA_VERB_CMD(V, N, D) (((N) << 20) | ((V) << 8) | (D))\n\n#define REALTEK_HDA_VALUE 0x0038\n\n#define REALTEK_HDA_SET\t\t62\n#define REALTEK_MANUAL_MODE\t72\n#define REALTEK_HDA_GET_OUT\t88\n#define REALTEK_HDA_GET_IN\t89\n\n#define REALTEK_AUDIO_FUNCTION_GROUP\t0x01\n#define REALTEK_LINE1\t\t\t0x1a\n#define REALTEK_VENDOR_REGISTERS\t0x20\n#define REALTEK_HP_OUT\t\t\t0x21\n\n#define REALTEK_CBJ_CTRL2 0x50\n\n#define REALTEK_JACK_INTERRUPT_NODE 5\n\n#define REALTEK_MIC_FLAG 0x100\n\nstatic int realtek_hda_set(struct snd_usb_audio *chip, u32 cmd)\n{\n\tstruct usb_device *dev = chip->dev;\n\t__be32 buf = cpu_to_be32(cmd);\n\n\treturn snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), REALTEK_HDA_SET,\n\t\t\t       USB_RECIP_DEVICE | USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t       REALTEK_HDA_VALUE, 0, &buf, sizeof(buf));\n}\n\nstatic int realtek_hda_get(struct snd_usb_audio *chip, u32 cmd, u32 *value)\n{\n\tstruct usb_device *dev = chip->dev;\n\tint err;\n\t__be32 buf = cpu_to_be32(cmd);\n\n\terr = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), REALTEK_HDA_GET_OUT,\n\t\t\t      USB_RECIP_DEVICE | USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t      REALTEK_HDA_VALUE, 0, &buf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), REALTEK_HDA_GET_IN,\n\t\t\t      USB_RECIP_DEVICE | USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      REALTEK_HDA_VALUE, 0, &buf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\n\t*value = be32_to_cpu(buf);\n\treturn 0;\n}\n\nstatic int realtek_ctl_connector_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tu32 pv = kcontrol->private_value;\n\tu32 node_id = pv & 0xff;\n\tu32 sense;\n\tu32 cbj_ctrl2;\n\tbool presence;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = realtek_hda_get(chip,\n\t\t\t      HDA_VERB_CMD(AC_VERB_GET_PIN_SENSE, node_id, 0),\n\t\t\t      &sense);\n\tif (err < 0)\n\t\tgoto err;\n\tif (pv & REALTEK_MIC_FLAG) {\n\t\terr = realtek_hda_set(chip,\n\t\t\t\t      HDA_VERB_CMD(AC_VERB_SET_COEF_INDEX,\n\t\t\t\t\t\t   REALTEK_VENDOR_REGISTERS,\n\t\t\t\t\t\t   REALTEK_CBJ_CTRL2));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\terr = realtek_hda_get(chip,\n\t\t\t\t      HDA_VERB_CMD(AC_VERB_GET_PROC_COEF,\n\t\t\t\t\t\t   REALTEK_VENDOR_REGISTERS, 0),\n\t\t\t\t      &cbj_ctrl2);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t}\nerr:\n\tsnd_usb_unlock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tpresence = sense & AC_PINSENSE_PRESENCE;\n\tif (pv & REALTEK_MIC_FLAG)\n\t\tpresence = presence && (cbj_ctrl2 & 0x0070) == 0x0070;\n\tucontrol->value.integer.value[0] = presence;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new realtek_connector_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"\",  \n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = realtek_ctl_connector_get,\n};\n\nstatic int realtek_resume_jack(struct usb_mixer_elem_list *list)\n{\n\tsnd_ctl_notify(list->mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t       &list->kctl->id);\n\treturn 0;\n}\n\nstatic int realtek_add_jack(struct usb_mixer_interface *mixer,\n\t\t\t    char *name, u32 val)\n{\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\tsnd_usb_mixer_elem_init_std(&cval->head, mixer,\n\t\t\t\t    REALTEK_JACK_INTERRUPT_NODE);\n\tcval->head.resume = realtek_resume_jack;\n\tcval->val_type = USB_MIXER_BOOLEAN;\n\tcval->channels = 1;\n\tcval->min = 0;\n\tcval->max = 1;\n\tkctl = snd_ctl_new1(&realtek_connector_ctl_ro, cval);\n\tif (!kctl) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_value = val;\n\tstrscpy(kctl->id.name, name, sizeof(kctl->id.name));\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int dell_dock_mixer_create(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\tstruct usb_device *dev = mixer->chip->dev;\n\n\t \n\trealtek_hda_set(mixer->chip,\n\t\t\tHDA_VERB_CMD(AC_VERB_SET_POWER_STATE,\n\t\t\t\t     REALTEK_AUDIO_FUNCTION_GROUP,\n\t\t\t\t     AC_PWRST_D3));\n\n\t \n\tsnd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), REALTEK_MANUAL_MODE,\n\t\t\tUSB_RECIP_DEVICE | USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0, NULL, 0);\n\n\terr = realtek_add_jack(mixer, \"Line Out Jack\", REALTEK_LINE1);\n\tif (err < 0)\n\t\treturn err;\n\terr = realtek_add_jack(mixer, \"Headphone Jack\", REALTEK_HP_OUT);\n\tif (err < 0)\n\t\treturn err;\n\terr = realtek_add_jack(mixer, \"Headset Mic Jack\",\n\t\t\t       REALTEK_HP_OUT | REALTEK_MIC_FLAG);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void dell_dock_init_vol(struct snd_usb_audio *chip, int ch, int id)\n{\n\tu16 buf = 0;\n\n\tsnd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0), UAC_SET_CUR,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t(UAC_FU_VOLUME << 8) | ch,\n\t\t\tsnd_usb_ctrl_intf(chip) | (id << 8),\n\t\t\t&buf, 2);\n}\n\nstatic int dell_dock_mixer_init(struct usb_mixer_interface *mixer)\n{\n\t \n\tdell_dock_init_vol(mixer->chip, 1, 16);\n\tdell_dock_init_vol(mixer->chip, 2, 16);\n\tdell_dock_init_vol(mixer->chip, 1, 19);\n\tdell_dock_init_vol(mixer->chip, 2, 19);\n\treturn 0;\n}\n\n \n\n#define SND_RME_GET_STATUS1\t\t\t23\n#define SND_RME_GET_CURRENT_FREQ\t\t17\n#define SND_RME_CLK_SYSTEM_SHIFT\t\t16\n#define SND_RME_CLK_SYSTEM_MASK\t\t\t0x1f\n#define SND_RME_CLK_AES_SHIFT\t\t\t8\n#define SND_RME_CLK_SPDIF_SHIFT\t\t\t12\n#define SND_RME_CLK_AES_SPDIF_MASK\t\t0xf\n#define SND_RME_CLK_SYNC_SHIFT\t\t\t6\n#define SND_RME_CLK_SYNC_MASK\t\t\t0x3\n#define SND_RME_CLK_FREQMUL_SHIFT\t\t18\n#define SND_RME_CLK_FREQMUL_MASK\t\t0x7\n#define SND_RME_CLK_SYSTEM(x) \\\n\t((x >> SND_RME_CLK_SYSTEM_SHIFT) & SND_RME_CLK_SYSTEM_MASK)\n#define SND_RME_CLK_AES(x) \\\n\t((x >> SND_RME_CLK_AES_SHIFT) & SND_RME_CLK_AES_SPDIF_MASK)\n#define SND_RME_CLK_SPDIF(x) \\\n\t((x >> SND_RME_CLK_SPDIF_SHIFT) & SND_RME_CLK_AES_SPDIF_MASK)\n#define SND_RME_CLK_SYNC(x) \\\n\t((x >> SND_RME_CLK_SYNC_SHIFT) & SND_RME_CLK_SYNC_MASK)\n#define SND_RME_CLK_FREQMUL(x) \\\n\t((x >> SND_RME_CLK_FREQMUL_SHIFT) & SND_RME_CLK_FREQMUL_MASK)\n#define SND_RME_CLK_AES_LOCK\t\t\t0x1\n#define SND_RME_CLK_AES_SYNC\t\t\t0x4\n#define SND_RME_CLK_SPDIF_LOCK\t\t\t0x2\n#define SND_RME_CLK_SPDIF_SYNC\t\t\t0x8\n#define SND_RME_SPDIF_IF_SHIFT\t\t\t4\n#define SND_RME_SPDIF_FORMAT_SHIFT\t\t5\n#define SND_RME_BINARY_MASK\t\t\t0x1\n#define SND_RME_SPDIF_IF(x) \\\n\t((x >> SND_RME_SPDIF_IF_SHIFT) & SND_RME_BINARY_MASK)\n#define SND_RME_SPDIF_FORMAT(x) \\\n\t((x >> SND_RME_SPDIF_FORMAT_SHIFT) & SND_RME_BINARY_MASK)\n\nstatic const u32 snd_rme_rate_table[] = {\n\t32000, 44100, 48000, 50000,\n\t64000, 88200, 96000, 100000,\n\t128000, 176400, 192000, 200000,\n\t256000,\t352800, 384000, 400000,\n\t512000, 705600, 768000, 800000\n};\n \n#define SND_RME_RATE_IDX_AES_SPDIF_NUM\t\t12\n\nenum snd_rme_domain {\n\tSND_RME_DOMAIN_SYSTEM,\n\tSND_RME_DOMAIN_AES,\n\tSND_RME_DOMAIN_SPDIF\n};\n\nenum snd_rme_clock_status {\n\tSND_RME_CLOCK_NOLOCK,\n\tSND_RME_CLOCK_LOCK,\n\tSND_RME_CLOCK_SYNC\n};\n\nstatic int snd_rme_read_value(struct snd_usb_audio *chip,\n\t\t\t      unsigned int item,\n\t\t\t      u32 *value)\n{\n\tstruct usb_device *dev = chip->dev;\n\tint err;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      item,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, 0,\n\t\t\t      value, sizeof(*value));\n\tif (err < 0)\n\t\tdev_err(&dev->dev,\n\t\t\t\"unable to issue vendor read request %d (ret = %d)\",\n\t\t\titem, err);\n\treturn err;\n}\n\nstatic int snd_rme_get_status1(struct snd_kcontrol *kcontrol,\n\t\t\t       u32 *status1)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_rme_read_value(chip, SND_RME_GET_STATUS1, status1);\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_rme_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status1;\n\tu32 rate = 0;\n\tint idx;\n\tint err;\n\n\terr = snd_rme_get_status1(kcontrol, &status1);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (kcontrol->private_value) {\n\tcase SND_RME_DOMAIN_SYSTEM:\n\t\tidx = SND_RME_CLK_SYSTEM(status1);\n\t\tif (idx < ARRAY_SIZE(snd_rme_rate_table))\n\t\t\trate = snd_rme_rate_table[idx];\n\t\tbreak;\n\tcase SND_RME_DOMAIN_AES:\n\t\tidx = SND_RME_CLK_AES(status1);\n\t\tif (idx < SND_RME_RATE_IDX_AES_SPDIF_NUM)\n\t\t\trate = snd_rme_rate_table[idx];\n\t\tbreak;\n\tcase SND_RME_DOMAIN_SPDIF:\n\t\tidx = SND_RME_CLK_SPDIF(status1);\n\t\tif (idx < SND_RME_RATE_IDX_AES_SPDIF_NUM)\n\t\t\trate = snd_rme_rate_table[idx];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tucontrol->value.integer.value[0] = rate;\n\treturn 0;\n}\n\nstatic int snd_rme_sync_state_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status1;\n\tint idx = SND_RME_CLOCK_NOLOCK;\n\tint err;\n\n\terr = snd_rme_get_status1(kcontrol, &status1);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (kcontrol->private_value) {\n\tcase SND_RME_DOMAIN_AES:   \n\t\tif (status1 & SND_RME_CLK_AES_SYNC)\n\t\t\tidx = SND_RME_CLOCK_SYNC;\n\t\telse if (status1 & SND_RME_CLK_AES_LOCK)\n\t\t\tidx = SND_RME_CLOCK_LOCK;\n\t\tbreak;\n\tcase SND_RME_DOMAIN_SPDIF:   \n\t\tif (status1 & SND_RME_CLK_SPDIF_SYNC)\n\t\t\tidx = SND_RME_CLOCK_SYNC;\n\t\telse if (status1 & SND_RME_CLK_SPDIF_LOCK)\n\t\t\tidx = SND_RME_CLOCK_LOCK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tucontrol->value.enumerated.item[0] = idx;\n\treturn 0;\n}\n\nstatic int snd_rme_spdif_if_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status1;\n\tint err;\n\n\terr = snd_rme_get_status1(kcontrol, &status1);\n\tif (err < 0)\n\t\treturn err;\n\tucontrol->value.enumerated.item[0] = SND_RME_SPDIF_IF(status1);\n\treturn 0;\n}\n\nstatic int snd_rme_spdif_format_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status1;\n\tint err;\n\n\terr = snd_rme_get_status1(kcontrol, &status1);\n\tif (err < 0)\n\t\treturn err;\n\tucontrol->value.enumerated.item[0] = SND_RME_SPDIF_FORMAT(status1);\n\treturn 0;\n}\n\nstatic int snd_rme_sync_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status1;\n\tint err;\n\n\terr = snd_rme_get_status1(kcontrol, &status1);\n\tif (err < 0)\n\t\treturn err;\n\tucontrol->value.enumerated.item[0] = SND_RME_CLK_SYNC(status1);\n\treturn 0;\n}\n\nstatic int snd_rme_current_freq_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct snd_usb_audio *chip = list->mixer->chip;\n\tu32 status1;\n\tconst u64 num = 104857600000000ULL;\n\tu32 den;\n\tunsigned int freq;\n\tint err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_rme_read_value(chip, SND_RME_GET_STATUS1, &status1);\n\tif (err < 0)\n\t\tgoto end;\n\terr = snd_rme_read_value(chip, SND_RME_GET_CURRENT_FREQ, &den);\n\tif (err < 0)\n\t\tgoto end;\n\tfreq = (den == 0) ? 0 : div64_u64(num, den);\n\tfreq <<= SND_RME_CLK_FREQMUL(status1);\n\tucontrol->value.integer.value[0] = freq;\n\nend:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_rme_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tswitch (kcontrol->private_value) {\n\tcase SND_RME_DOMAIN_SYSTEM:\n\t\tuinfo->value.integer.min = 32000;\n\t\tuinfo->value.integer.max = 800000;\n\t\tbreak;\n\tcase SND_RME_DOMAIN_AES:\n\tcase SND_RME_DOMAIN_SPDIF:\n\tdefault:\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 200000;\n\t}\n\tuinfo->value.integer.step = 0;\n\treturn 0;\n}\n\nstatic int snd_rme_sync_state_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const sync_states[] = {\n\t\t\"No Lock\", \"Lock\", \"Sync\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t ARRAY_SIZE(sync_states), sync_states);\n}\n\nstatic int snd_rme_spdif_if_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const spdif_if[] = {\n\t\t\"Coaxial\", \"Optical\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t ARRAY_SIZE(spdif_if), spdif_if);\n}\n\nstatic int snd_rme_spdif_format_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const optical_type[] = {\n\t\t\"Consumer\", \"Professional\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t ARRAY_SIZE(optical_type), optical_type);\n}\n\nstatic int snd_rme_sync_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const sync_sources[] = {\n\t\t\"Internal\", \"AES\", \"SPDIF\", \"Internal\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t ARRAY_SIZE(sync_sources), sync_sources);\n}\n\nstatic const struct snd_kcontrol_new snd_rme_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"AES Rate\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_rate_info,\n\t\t.get = snd_rme_rate_get,\n\t\t.private_value = SND_RME_DOMAIN_AES\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"AES Sync\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_sync_state_info,\n\t\t.get = snd_rme_sync_state_get,\n\t\t.private_value = SND_RME_DOMAIN_AES\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"SPDIF Rate\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_rate_info,\n\t\t.get = snd_rme_rate_get,\n\t\t.private_value = SND_RME_DOMAIN_SPDIF\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"SPDIF Sync\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_sync_state_info,\n\t\t.get = snd_rme_sync_state_get,\n\t\t.private_value = SND_RME_DOMAIN_SPDIF\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"SPDIF Interface\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_spdif_if_info,\n\t\t.get = snd_rme_spdif_if_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"SPDIF Format\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_spdif_format_info,\n\t\t.get = snd_rme_spdif_format_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Sync Source\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_sync_source_info,\n\t\t.get = snd_rme_sync_source_get\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"System Rate\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_rate_info,\n\t\t.get = snd_rme_rate_get,\n\t\t.private_value = SND_RME_DOMAIN_SYSTEM\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Current Frequency\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_rme_rate_info,\n\t\t.get = snd_rme_current_freq_get\n\t}\n};\n\nstatic int snd_rme_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_rme_controls); ++i) {\n\t\terr = add_single_ctl_with_resume(mixer, 0,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &snd_rme_controls[i],\n\t\t\t\t\t\t NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nenum {\n\tSND_BBFPRO_CTL_REG1 = 0,\n\tSND_BBFPRO_CTL_REG2\n};\n\n#define SND_BBFPRO_CTL_REG_MASK 1\n#define SND_BBFPRO_CTL_IDX_MASK 0xff\n#define SND_BBFPRO_CTL_IDX_SHIFT 1\n#define SND_BBFPRO_CTL_VAL_MASK 1\n#define SND_BBFPRO_CTL_VAL_SHIFT 9\n#define SND_BBFPRO_CTL_REG1_CLK_MASTER 0\n#define SND_BBFPRO_CTL_REG1_CLK_OPTICAL 1\n#define SND_BBFPRO_CTL_REG1_SPDIF_PRO 7\n#define SND_BBFPRO_CTL_REG1_SPDIF_EMPH 8\n#define SND_BBFPRO_CTL_REG1_SPDIF_OPTICAL 10\n#define SND_BBFPRO_CTL_REG2_48V_AN1 0\n#define SND_BBFPRO_CTL_REG2_48V_AN2 1\n#define SND_BBFPRO_CTL_REG2_SENS_IN3 2\n#define SND_BBFPRO_CTL_REG2_SENS_IN4 3\n#define SND_BBFPRO_CTL_REG2_PAD_AN1 4\n#define SND_BBFPRO_CTL_REG2_PAD_AN2 5\n\n#define SND_BBFPRO_MIXER_IDX_MASK 0x1ff\n#define SND_BBFPRO_MIXER_VAL_MASK 0x3ffff\n#define SND_BBFPRO_MIXER_VAL_SHIFT 9\n#define SND_BBFPRO_MIXER_VAL_MIN 0 \n#define SND_BBFPRO_MIXER_VAL_MAX 65536 \n\n#define SND_BBFPRO_USBREQ_CTL_REG1 0x10\n#define SND_BBFPRO_USBREQ_CTL_REG2 0x17\n#define SND_BBFPRO_USBREQ_MIXER 0x12\n\nstatic int snd_bbfpro_ctl_update(struct usb_mixer_interface *mixer, u8 reg,\n\t\t\t\t u8 index, u8 value)\n{\n\tint err;\n\tu16 usb_req, usb_idx, usb_val;\n\tstruct snd_usb_audio *chip = mixer->chip;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (reg == SND_BBFPRO_CTL_REG1) {\n\t\tusb_req = SND_BBFPRO_USBREQ_CTL_REG1;\n\t\tif (index == SND_BBFPRO_CTL_REG1_CLK_OPTICAL) {\n\t\t\tusb_idx = 3;\n\t\t\tusb_val = value ? 3 : 0;\n\t\t} else {\n\t\t\tusb_idx = 1 << index;\n\t\t\tusb_val = value ? usb_idx : 0;\n\t\t}\n\t} else {\n\t\tusb_req = SND_BBFPRO_USBREQ_CTL_REG2;\n\t\tusb_idx = 1 << index;\n\t\tusb_val = value ? usb_idx : 0;\n\t}\n\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0), usb_req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      usb_val, usb_idx, NULL, 0);\n\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_bbfpro_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tu8 reg, idx, val;\n\tint pv;\n\n\tpv = kcontrol->private_value;\n\treg = pv & SND_BBFPRO_CTL_REG_MASK;\n\tidx = (pv >> SND_BBFPRO_CTL_IDX_SHIFT) & SND_BBFPRO_CTL_IDX_MASK;\n\tval = kcontrol->private_value >> SND_BBFPRO_CTL_VAL_SHIFT;\n\n\tif ((reg == SND_BBFPRO_CTL_REG1 &&\n\t     idx == SND_BBFPRO_CTL_REG1_CLK_OPTICAL) ||\n\t    (reg == SND_BBFPRO_CTL_REG2 &&\n\t    (idx == SND_BBFPRO_CTL_REG2_SENS_IN3 ||\n\t     idx == SND_BBFPRO_CTL_REG2_SENS_IN4))) {\n\t\tucontrol->value.enumerated.item[0] = val;\n\t} else {\n\t\tucontrol->value.integer.value[0] = val;\n\t}\n\treturn 0;\n}\n\nstatic int snd_bbfpro_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tu8 reg, idx;\n\tint pv;\n\n\tpv = kcontrol->private_value;\n\treg = pv & SND_BBFPRO_CTL_REG_MASK;\n\tidx = (pv >> SND_BBFPRO_CTL_IDX_SHIFT) & SND_BBFPRO_CTL_IDX_MASK;\n\n\tif (reg == SND_BBFPRO_CTL_REG1 &&\n\t    idx == SND_BBFPRO_CTL_REG1_CLK_OPTICAL) {\n\t\tstatic const char * const texts[2] = {\n\t\t\t\"AutoSync\",\n\t\t\t\"Internal\"\n\t\t};\n\t\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n\t} else if (reg == SND_BBFPRO_CTL_REG2 &&\n\t\t   (idx == SND_BBFPRO_CTL_REG2_SENS_IN3 ||\n\t\t    idx == SND_BBFPRO_CTL_REG2_SENS_IN4)) {\n\t\tstatic const char * const texts[2] = {\n\t\t\t\"-10dBV\",\n\t\t\t\"+4dBu\"\n\t\t};\n\t\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n\t}\n\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\treturn 0;\n}\n\nstatic int snd_bbfpro_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint err;\n\tu8 reg, idx;\n\tint old_value, pv, val;\n\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\n\tpv = kcontrol->private_value;\n\treg = pv & SND_BBFPRO_CTL_REG_MASK;\n\tidx = (pv >> SND_BBFPRO_CTL_IDX_SHIFT) & SND_BBFPRO_CTL_IDX_MASK;\n\told_value = (pv >> SND_BBFPRO_CTL_VAL_SHIFT) & SND_BBFPRO_CTL_VAL_MASK;\n\n\tif ((reg == SND_BBFPRO_CTL_REG1 &&\n\t     idx == SND_BBFPRO_CTL_REG1_CLK_OPTICAL) ||\n\t    (reg == SND_BBFPRO_CTL_REG2 &&\n\t    (idx == SND_BBFPRO_CTL_REG2_SENS_IN3 ||\n\t     idx == SND_BBFPRO_CTL_REG2_SENS_IN4))) {\n\t\tval = ucontrol->value.enumerated.item[0];\n\t} else {\n\t\tval = ucontrol->value.integer.value[0];\n\t}\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tif (val == old_value)\n\t\treturn 0;\n\n\tkcontrol->private_value = reg\n\t\t| ((idx & SND_BBFPRO_CTL_IDX_MASK) << SND_BBFPRO_CTL_IDX_SHIFT)\n\t\t| ((val & SND_BBFPRO_CTL_VAL_MASK) << SND_BBFPRO_CTL_VAL_SHIFT);\n\n\terr = snd_bbfpro_ctl_update(mixer, reg, idx, val);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_bbfpro_ctl_resume(struct usb_mixer_elem_list *list)\n{\n\tu8 reg, idx;\n\tint value, pv;\n\n\tpv = list->kctl->private_value;\n\treg = pv & SND_BBFPRO_CTL_REG_MASK;\n\tidx = (pv >> SND_BBFPRO_CTL_IDX_SHIFT) & SND_BBFPRO_CTL_IDX_MASK;\n\tvalue = (pv >> SND_BBFPRO_CTL_VAL_SHIFT) & SND_BBFPRO_CTL_VAL_MASK;\n\n\treturn snd_bbfpro_ctl_update(list->mixer, reg, idx, value);\n}\n\nstatic int snd_bbfpro_vol_update(struct usb_mixer_interface *mixer, u16 index,\n\t\t\t\t u32 value)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\tu16 idx;\n\tu16 usb_idx, usb_val;\n\tu32 v;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tidx = index & SND_BBFPRO_MIXER_IDX_MASK;\n\t\n\tv = value & SND_BBFPRO_MIXER_VAL_MASK;\n\tusb_idx = idx | (v & 0x3) << 14;\n\tusb_val = (v >> 2) & 0xffff;\n\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t      usb_sndctrlpipe(chip->dev, 0),\n\t\t\t      SND_BBFPRO_USBREQ_MIXER,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE,\n\t\t\t      usb_val, usb_idx, NULL, 0);\n\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int snd_bbfpro_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] =\n\t\tkcontrol->private_value >> SND_BBFPRO_MIXER_VAL_SHIFT;\n\treturn 0;\n}\n\nstatic int snd_bbfpro_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = SND_BBFPRO_MIXER_VAL_MIN;\n\tuinfo->value.integer.max = SND_BBFPRO_MIXER_VAL_MAX;\n\treturn 0;\n}\n\nstatic int snd_bbfpro_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint err;\n\tu16 idx;\n\tu32 new_val, old_value, uvalue;\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\n\tuvalue = ucontrol->value.integer.value[0];\n\tidx = kcontrol->private_value & SND_BBFPRO_MIXER_IDX_MASK;\n\told_value = kcontrol->private_value >> SND_BBFPRO_MIXER_VAL_SHIFT;\n\n\tif (uvalue > SND_BBFPRO_MIXER_VAL_MAX)\n\t\treturn -EINVAL;\n\n\tif (uvalue == old_value)\n\t\treturn 0;\n\n\tnew_val = uvalue & SND_BBFPRO_MIXER_VAL_MASK;\n\n\tkcontrol->private_value = idx\n\t\t| (new_val << SND_BBFPRO_MIXER_VAL_SHIFT);\n\n\terr = snd_bbfpro_vol_update(mixer, idx, new_val);\n\treturn err < 0 ? err : 1;\n}\n\nstatic int snd_bbfpro_vol_resume(struct usb_mixer_elem_list *list)\n{\n\tint pv = list->kctl->private_value;\n\tu16 idx = pv & SND_BBFPRO_MIXER_IDX_MASK;\n\tu32 val = (pv >> SND_BBFPRO_MIXER_VAL_SHIFT)\n\t\t& SND_BBFPRO_MIXER_VAL_MASK;\n\treturn snd_bbfpro_vol_update(list->mixer, idx, val);\n}\n\n\nstatic const struct snd_kcontrol_new snd_bbfpro_ctl_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.index = 0,\n\t.info = snd_bbfpro_ctl_info,\n\t.get = snd_bbfpro_ctl_get,\n\t.put = snd_bbfpro_ctl_put\n};\n\nstatic const struct snd_kcontrol_new snd_bbfpro_vol_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.index = 0,\n\t.info = snd_bbfpro_vol_info,\n\t.get = snd_bbfpro_vol_get,\n\t.put = snd_bbfpro_vol_put\n};\n\nstatic int snd_bbfpro_ctl_add(struct usb_mixer_interface *mixer, u8 reg,\n\t\t\t      u8 index, char *name)\n{\n\tstruct snd_kcontrol_new knew = snd_bbfpro_ctl_control;\n\n\tknew.name = name;\n\tknew.private_value = (reg & SND_BBFPRO_CTL_REG_MASK)\n\t\t| ((index & SND_BBFPRO_CTL_IDX_MASK)\n\t\t\t<< SND_BBFPRO_CTL_IDX_SHIFT);\n\n\treturn add_single_ctl_with_resume(mixer, 0, snd_bbfpro_ctl_resume,\n\t\t&knew, NULL);\n}\n\nstatic int snd_bbfpro_vol_add(struct usb_mixer_interface *mixer, u16 index,\n\t\t\t      char *name)\n{\n\tstruct snd_kcontrol_new knew = snd_bbfpro_vol_control;\n\n\tknew.name = name;\n\tknew.private_value = index & SND_BBFPRO_MIXER_IDX_MASK;\n\n\treturn add_single_ctl_with_resume(mixer, 0, snd_bbfpro_vol_resume,\n\t\t&knew, NULL);\n}\n\nstatic int snd_bbfpro_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint err, i, o;\n\tchar name[48];\n\n\tstatic const char * const input[] = {\n\t\t\"AN1\", \"AN2\", \"IN3\", \"IN4\", \"AS1\", \"AS2\", \"ADAT3\",\n\t\t\"ADAT4\", \"ADAT5\", \"ADAT6\", \"ADAT7\", \"ADAT8\"};\n\n\tstatic const char * const output[] = {\n\t\t\"AN1\", \"AN2\", \"PH3\", \"PH4\", \"AS1\", \"AS2\", \"ADAT3\", \"ADAT4\",\n\t\t\"ADAT5\", \"ADAT6\", \"ADAT7\", \"ADAT8\"};\n\n\tfor (o = 0 ; o < 12 ; ++o) {\n\t\tfor (i = 0 ; i < 12 ; ++i) {\n\t\t\t\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t \"%s-%s-%s Playback Volume\",\n\t\t\t\t (i < 2 ? \"Mic\" : \"Line\"),\n\t\t\t\t input[i], output[o]);\n\t\t\terr = snd_bbfpro_vol_add(mixer, (26 * o + i), name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t \"PCM-%s-%s Playback Volume\",\n\t\t\t\t output[i], output[o]);\n\t\t\terr = snd_bbfpro_vol_add(mixer, (26 * o + 12 + i),\n\t\t\t\t\t\t name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG1,\n\t\t\t\t SND_BBFPRO_CTL_REG1_CLK_OPTICAL,\n\t\t\t\t \"Sample Clock Source\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG1,\n\t\t\t\t SND_BBFPRO_CTL_REG1_SPDIF_PRO,\n\t\t\t\t \"IEC958 Pro Mask\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG1,\n\t\t\t\t SND_BBFPRO_CTL_REG1_SPDIF_EMPH,\n\t\t\t\t \"IEC958 Emphasis\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG1,\n\t\t\t\t SND_BBFPRO_CTL_REG1_SPDIF_OPTICAL,\n\t\t\t\t \"IEC958 Switch\");\n\tif (err < 0)\n\t\treturn err;\n\n\t\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_48V_AN1,\n\t\t\t\t \"Mic-AN1 48V\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_48V_AN2,\n\t\t\t\t \"Mic-AN2 48V\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_SENS_IN3,\n\t\t\t\t \"Line-IN3 Sens.\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_SENS_IN4,\n\t\t\t\t \"Line-IN4 Sens.\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_PAD_AN1,\n\t\t\t\t \"Mic-AN1 PAD\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_bbfpro_ctl_add(mixer, SND_BBFPRO_CTL_REG2,\n\t\t\t\t SND_BBFPRO_CTL_REG2_PAD_AN2,\n\t\t\t\t \"Mic-AN2 PAD\");\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\n\n#define SND_DJM_CAP_LINE\t0x00\n#define SND_DJM_CAP_CDLINE\t0x01\n#define SND_DJM_CAP_DIGITAL\t0x02\n#define SND_DJM_CAP_PHONO\t0x03\n#define SND_DJM_CAP_PFADER\t0x06\n#define SND_DJM_CAP_XFADERA\t0x07\n#define SND_DJM_CAP_XFADERB\t0x08\n#define SND_DJM_CAP_MIC\t\t0x09\n#define SND_DJM_CAP_AUX\t\t0x0d\n#define SND_DJM_CAP_RECOUT\t0x0a\n#define SND_DJM_CAP_NONE\t0x0f\n#define SND_DJM_CAP_CH1PFADER\t0x11\n#define SND_DJM_CAP_CH2PFADER\t0x12\n#define SND_DJM_CAP_CH3PFADER\t0x13\n#define SND_DJM_CAP_CH4PFADER\t0x14\n\n\n#define SND_DJM_PB_CH1\t\t0x00\n#define SND_DJM_PB_CH2\t\t0x01\n#define SND_DJM_PB_AUX\t\t0x04\n\n#define SND_DJM_WINDEX_CAP\t0x8002\n#define SND_DJM_WINDEX_CAPLVL\t0x8003\n#define SND_DJM_WINDEX_PB\t0x8016\n\n\n#define SND_DJM_VALUE_MASK\t0x0000ffff\n#define SND_DJM_GROUP_MASK\t0x00ff0000\n#define SND_DJM_DEVICE_MASK\t0xff000000\n#define SND_DJM_GROUP_SHIFT\t16\n#define SND_DJM_DEVICE_SHIFT\t24\n\n\n\n#define SND_DJM_250MK2_IDX\t0x0\n#define SND_DJM_750_IDX\t\t0x1\n#define SND_DJM_850_IDX\t\t0x2\n#define SND_DJM_900NXS2_IDX\t0x3\n#define SND_DJM_750MK2_IDX\t0x4\n#define SND_DJM_450_IDX\t\t0x5\n\n\n#define SND_DJM_CTL(_name, suffix, _default_value, _windex) { \\\n\t.name = _name, \\\n\t.options = snd_djm_opts_##suffix, \\\n\t.noptions = ARRAY_SIZE(snd_djm_opts_##suffix), \\\n\t.default_value = _default_value, \\\n\t.wIndex = _windex }\n\n#define SND_DJM_DEVICE(suffix) { \\\n\t.controls = snd_djm_ctls_##suffix, \\\n\t.ncontrols = ARRAY_SIZE(snd_djm_ctls_##suffix) }\n\n\nstruct snd_djm_device {\n\tconst char *name;\n\tconst struct snd_djm_ctl *controls;\n\tsize_t ncontrols;\n};\n\nstruct snd_djm_ctl {\n\tconst char *name;\n\tconst u16 *options;\n\tsize_t noptions;\n\tu16 default_value;\n\tu16 wIndex;\n};\n\nstatic const char *snd_djm_get_label_caplevel(u16 wvalue)\n{\n\tswitch (wvalue) {\n\tcase 0x0000:\treturn \"-19dB\";\n\tcase 0x0100:\treturn \"-15dB\";\n\tcase 0x0200:\treturn \"-10dB\";\n\tcase 0x0300:\treturn \"-5dB\";\n\tdefault:\treturn NULL;\n\t}\n};\n\nstatic const char *snd_djm_get_label_cap_common(u16 wvalue)\n{\n\tswitch (wvalue & 0x00ff) {\n\tcase SND_DJM_CAP_LINE:\t\treturn \"Control Tone LINE\";\n\tcase SND_DJM_CAP_CDLINE:\treturn \"Control Tone CD/LINE\";\n\tcase SND_DJM_CAP_DIGITAL:\treturn \"Control Tone DIGITAL\";\n\tcase SND_DJM_CAP_PHONO:\t\treturn \"Control Tone PHONO\";\n\tcase SND_DJM_CAP_PFADER:\treturn \"Post Fader\";\n\tcase SND_DJM_CAP_XFADERA:\treturn \"Cross Fader A\";\n\tcase SND_DJM_CAP_XFADERB:\treturn \"Cross Fader B\";\n\tcase SND_DJM_CAP_MIC:\t\treturn \"Mic\";\n\tcase SND_DJM_CAP_RECOUT:\treturn \"Rec Out\";\n\tcase SND_DJM_CAP_AUX:\t\treturn \"Aux\";\n\tcase SND_DJM_CAP_NONE:\t\treturn \"None\";\n\tcase SND_DJM_CAP_CH1PFADER:\treturn \"Post Fader Ch1\";\n\tcase SND_DJM_CAP_CH2PFADER:\treturn \"Post Fader Ch2\";\n\tcase SND_DJM_CAP_CH3PFADER:\treturn \"Post Fader Ch3\";\n\tcase SND_DJM_CAP_CH4PFADER:\treturn \"Post Fader Ch4\";\n\tdefault:\t\t\treturn NULL;\n\t}\n};\n\n\n\nstatic const char *snd_djm_get_label_cap_850(u16 wvalue)\n{\n\tswitch (wvalue & 0x00ff) {\n\tcase 0x00:\t\treturn \"Control Tone CD/LINE\";\n\tcase 0x01:\t\treturn \"Control Tone LINE\";\n\tdefault:\t\treturn snd_djm_get_label_cap_common(wvalue);\n\t}\n};\n\nstatic const char *snd_djm_get_label_cap(u8 device_idx, u16 wvalue)\n{\n\tswitch (device_idx) {\n\tcase SND_DJM_850_IDX:\t\treturn snd_djm_get_label_cap_850(wvalue);\n\tdefault:\t\t\treturn snd_djm_get_label_cap_common(wvalue);\n\t}\n};\n\nstatic const char *snd_djm_get_label_pb(u16 wvalue)\n{\n\tswitch (wvalue & 0x00ff) {\n\tcase SND_DJM_PB_CH1:\treturn \"Ch1\";\n\tcase SND_DJM_PB_CH2:\treturn \"Ch2\";\n\tcase SND_DJM_PB_AUX:\treturn \"Aux\";\n\tdefault:\t\treturn NULL;\n\t}\n};\n\nstatic const char *snd_djm_get_label(u8 device_idx, u16 wvalue, u16 windex)\n{\n\tswitch (windex) {\n\tcase SND_DJM_WINDEX_CAPLVL:\treturn snd_djm_get_label_caplevel(wvalue);\n\tcase SND_DJM_WINDEX_CAP:\treturn snd_djm_get_label_cap(device_idx, wvalue);\n\tcase SND_DJM_WINDEX_PB:\t\treturn snd_djm_get_label_pb(wvalue);\n\tdefault:\t\t\treturn NULL;\n\t}\n};\n\n\nstatic const u16 snd_djm_opts_cap_level[] = {\n\t0x0000, 0x0100, 0x0200, 0x0300 };\n\n\n\nstatic const u16 snd_djm_opts_250mk2_cap1[] = {\n\t0x0103, 0x0100, 0x0106, 0x0107, 0x0108, 0x0109, 0x010d, 0x010a };\n\nstatic const u16 snd_djm_opts_250mk2_cap2[] = {\n\t0x0203, 0x0200, 0x0206, 0x0207, 0x0208, 0x0209, 0x020d, 0x020a };\n\nstatic const u16 snd_djm_opts_250mk2_cap3[] = {\n\t0x030a, 0x0311, 0x0312, 0x0307, 0x0308, 0x0309, 0x030d };\n\nstatic const u16 snd_djm_opts_250mk2_pb1[] = { 0x0100, 0x0101, 0x0104 };\nstatic const u16 snd_djm_opts_250mk2_pb2[] = { 0x0200, 0x0201, 0x0204 };\nstatic const u16 snd_djm_opts_250mk2_pb3[] = { 0x0300, 0x0301, 0x0304 };\n\nstatic const struct snd_djm_ctl snd_djm_ctls_250mk2[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   250mk2_cap1, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   250mk2_cap2, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   250mk2_cap3, 0, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch1 Output\",   250mk2_pb1, 0, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch2 Output\",   250mk2_pb2, 1, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch3 Output\",   250mk2_pb3, 2, SND_DJM_WINDEX_PB)\n};\n\n\n\nstatic const u16 snd_djm_opts_450_cap1[] = {\n\t0x0103, 0x0100, 0x0106, 0x0107, 0x0108, 0x0109, 0x010d, 0x010a };\n\nstatic const u16 snd_djm_opts_450_cap2[] = {\n\t0x0203, 0x0200, 0x0206, 0x0207, 0x0208, 0x0209, 0x020d, 0x020a };\n\nstatic const u16 snd_djm_opts_450_cap3[] = {\n\t0x030a, 0x0311, 0x0312, 0x0307, 0x0308, 0x0309, 0x030d };\n\nstatic const u16 snd_djm_opts_450_pb1[] = { 0x0100, 0x0101, 0x0104 };\nstatic const u16 snd_djm_opts_450_pb2[] = { 0x0200, 0x0201, 0x0204 };\nstatic const u16 snd_djm_opts_450_pb3[] = { 0x0300, 0x0301, 0x0304 };\n\nstatic const struct snd_djm_ctl snd_djm_ctls_450[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   450_cap1, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   450_cap2, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   450_cap3, 0, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch1 Output\",   450_pb1, 0, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch2 Output\",   450_pb2, 1, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch3 Output\",   450_pb3, 2, SND_DJM_WINDEX_PB)\n};\n\n\n\nstatic const u16 snd_djm_opts_750_cap1[] = {\n\t0x0101, 0x0103, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a, 0x010f };\nstatic const u16 snd_djm_opts_750_cap2[] = {\n\t0x0200, 0x0201, 0x0206, 0x0207, 0x0208, 0x0209, 0x020a, 0x020f };\nstatic const u16 snd_djm_opts_750_cap3[] = {\n\t0x0300, 0x0301, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a, 0x030f };\nstatic const u16 snd_djm_opts_750_cap4[] = {\n\t0x0401, 0x0403, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a, 0x040f };\n\nstatic const struct snd_djm_ctl snd_djm_ctls_750[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   750_cap1, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   750_cap2, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   750_cap3, 0, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch4 Input\",   750_cap4, 0, SND_DJM_WINDEX_CAP)\n};\n\n\n\nstatic const u16 snd_djm_opts_850_cap1[] = {\n\t0x0100, 0x0103, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a, 0x010f };\nstatic const u16 snd_djm_opts_850_cap2[] = {\n\t0x0200, 0x0201, 0x0206, 0x0207, 0x0208, 0x0209, 0x020a, 0x020f };\nstatic const u16 snd_djm_opts_850_cap3[] = {\n\t0x0300, 0x0301, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a, 0x030f };\nstatic const u16 snd_djm_opts_850_cap4[] = {\n\t0x0400, 0x0403, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a, 0x040f };\n\nstatic const struct snd_djm_ctl snd_djm_ctls_850[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   850_cap1, 1, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   850_cap2, 0, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   850_cap3, 0, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch4 Input\",   850_cap4, 1, SND_DJM_WINDEX_CAP)\n};\n\n\n\nstatic const u16 snd_djm_opts_900nxs2_cap1[] = {\n\t0x0100, 0x0102, 0x0103, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a };\nstatic const u16 snd_djm_opts_900nxs2_cap2[] = {\n\t0x0200, 0x0202, 0x0203, 0x0206, 0x0207, 0x0208, 0x0209, 0x020a };\nstatic const u16 snd_djm_opts_900nxs2_cap3[] = {\n\t0x0300, 0x0302, 0x0303, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a };\nstatic const u16 snd_djm_opts_900nxs2_cap4[] = {\n\t0x0400, 0x0402, 0x0403, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a };\nstatic const u16 snd_djm_opts_900nxs2_cap5[] = {\n\t0x0507, 0x0508, 0x0509, 0x050a, 0x0511, 0x0512, 0x0513, 0x0514 };\n\nstatic const struct snd_djm_ctl snd_djm_ctls_900nxs2[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   900nxs2_cap1, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   900nxs2_cap2, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   900nxs2_cap3, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch4 Input\",   900nxs2_cap4, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch5 Input\",   900nxs2_cap5, 3, SND_DJM_WINDEX_CAP)\n};\n\n\nstatic const u16 snd_djm_opts_750mk2_cap1[] = {\n\t0x0100, 0x0102, 0x0103, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a };\nstatic const u16 snd_djm_opts_750mk2_cap2[] = {\n\t0x0200, 0x0202, 0x0203, 0x0206, 0x0207, 0x0208, 0x0209, 0x020a };\nstatic const u16 snd_djm_opts_750mk2_cap3[] = {\n\t0x0300, 0x0302, 0x0303, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a };\nstatic const u16 snd_djm_opts_750mk2_cap4[] = {\n\t0x0400, 0x0402, 0x0403, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a };\nstatic const u16 snd_djm_opts_750mk2_cap5[] = {\n\t0x0507, 0x0508, 0x0509, 0x050a, 0x0511, 0x0512, 0x0513, 0x0514 };\n\nstatic const u16 snd_djm_opts_750mk2_pb1[] = { 0x0100, 0x0101, 0x0104 };\nstatic const u16 snd_djm_opts_750mk2_pb2[] = { 0x0200, 0x0201, 0x0204 };\nstatic const u16 snd_djm_opts_750mk2_pb3[] = { 0x0300, 0x0301, 0x0304 };\n\n\nstatic const struct snd_djm_ctl snd_djm_ctls_750mk2[] = {\n\tSND_DJM_CTL(\"Capture Level\", cap_level, 0, SND_DJM_WINDEX_CAPLVL),\n\tSND_DJM_CTL(\"Ch1 Input\",   750mk2_cap1, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch2 Input\",   750mk2_cap2, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch3 Input\",   750mk2_cap3, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch4 Input\",   750mk2_cap4, 2, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch5 Input\",   750mk2_cap5, 3, SND_DJM_WINDEX_CAP),\n\tSND_DJM_CTL(\"Ch1 Output\",   750mk2_pb1, 0, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch2 Output\",   750mk2_pb2, 1, SND_DJM_WINDEX_PB),\n\tSND_DJM_CTL(\"Ch3 Output\",   750mk2_pb3, 2, SND_DJM_WINDEX_PB)\n};\n\n\nstatic const struct snd_djm_device snd_djm_devices[] = {\n\t[SND_DJM_250MK2_IDX] = SND_DJM_DEVICE(250mk2),\n\t[SND_DJM_750_IDX] = SND_DJM_DEVICE(750),\n\t[SND_DJM_850_IDX] = SND_DJM_DEVICE(850),\n\t[SND_DJM_900NXS2_IDX] = SND_DJM_DEVICE(900nxs2),\n\t[SND_DJM_750MK2_IDX] = SND_DJM_DEVICE(750mk2),\n\t[SND_DJM_450_IDX] = SND_DJM_DEVICE(450),\n};\n\n\nstatic int snd_djm_controls_info(struct snd_kcontrol *kctl,\n\t\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tunsigned long private_value = kctl->private_value;\n\tu8 device_idx = (private_value & SND_DJM_DEVICE_MASK) >> SND_DJM_DEVICE_SHIFT;\n\tu8 ctl_idx = (private_value & SND_DJM_GROUP_MASK) >> SND_DJM_GROUP_SHIFT;\n\tconst struct snd_djm_device *device = &snd_djm_devices[device_idx];\n\tconst char *name;\n\tconst struct snd_djm_ctl *ctl;\n\tsize_t noptions;\n\n\tif (ctl_idx >= device->ncontrols)\n\t\treturn -EINVAL;\n\n\tctl = &device->controls[ctl_idx];\n\tnoptions = ctl->noptions;\n\tif (info->value.enumerated.item >= noptions)\n\t\tinfo->value.enumerated.item = noptions - 1;\n\n\tname = snd_djm_get_label(device_idx,\n\t\t\t\tctl->options[info->value.enumerated.item],\n\t\t\t\tctl->wIndex);\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tstrscpy(info->value.enumerated.name, name, sizeof(info->value.enumerated.name));\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = 1;\n\tinfo->value.enumerated.items = noptions;\n\treturn 0;\n}\n\nstatic int snd_djm_controls_update(struct usb_mixer_interface *mixer,\n\t\t\t\tu8 device_idx, u8 group, u16 value)\n{\n\tint err;\n\tconst struct snd_djm_device *device = &snd_djm_devices[device_idx];\n\n\tif ((group >= device->ncontrols) || value >= device->controls[group].noptions)\n\t\treturn -EINVAL;\n\n\terr = snd_usb_lock_shutdown(mixer->chip);\n\tif (err)\n\t\treturn err;\n\n\terr = snd_usb_ctl_msg(\n\t\tmixer->chip->dev, usb_sndctrlpipe(mixer->chip->dev, 0),\n\t\tUSB_REQ_SET_FEATURE,\n\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\tdevice->controls[group].options[value],\n\t\tdevice->controls[group].wIndex,\n\t\tNULL, 0);\n\n\tsnd_usb_unlock_shutdown(mixer->chip);\n\treturn err;\n}\n\nstatic int snd_djm_controls_get(struct snd_kcontrol *kctl,\n\t\t\t\tstruct snd_ctl_elem_value *elem)\n{\n\telem->value.enumerated.item[0] = kctl->private_value & SND_DJM_VALUE_MASK;\n\treturn 0;\n}\n\nstatic int snd_djm_controls_put(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *elem)\n{\n\tstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tunsigned long private_value = kctl->private_value;\n\n\tu8 device = (private_value & SND_DJM_DEVICE_MASK) >> SND_DJM_DEVICE_SHIFT;\n\tu8 group = (private_value & SND_DJM_GROUP_MASK) >> SND_DJM_GROUP_SHIFT;\n\tu16 value = elem->value.enumerated.item[0];\n\n\tkctl->private_value = (((unsigned long)device << SND_DJM_DEVICE_SHIFT) |\n\t\t\t      (group << SND_DJM_GROUP_SHIFT) |\n\t\t\t      value);\n\n\treturn snd_djm_controls_update(mixer, device, group, value);\n}\n\nstatic int snd_djm_controls_resume(struct usb_mixer_elem_list *list)\n{\n\tunsigned long private_value = list->kctl->private_value;\n\tu8 device = (private_value & SND_DJM_DEVICE_MASK) >> SND_DJM_DEVICE_SHIFT;\n\tu8 group = (private_value & SND_DJM_GROUP_MASK) >> SND_DJM_GROUP_SHIFT;\n\tu16 value = (private_value & SND_DJM_VALUE_MASK);\n\n\treturn snd_djm_controls_update(list->mixer, device, group, value);\n}\n\nstatic int snd_djm_controls_create(struct usb_mixer_interface *mixer,\n\t\tconst u8 device_idx)\n{\n\tint err, i;\n\tu16 value;\n\n\tconst struct snd_djm_device *device = &snd_djm_devices[device_idx];\n\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface  = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.index = 0,\n\t\t.info = snd_djm_controls_info,\n\t\t.get  = snd_djm_controls_get,\n\t\t.put  = snd_djm_controls_put\n\t};\n\n\tfor (i = 0; i < device->ncontrols; i++) {\n\t\tvalue = device->controls[i].default_value;\n\t\tknew.name = device->controls[i].name;\n\t\tknew.private_value = (\n\t\t\t((unsigned long)device_idx << SND_DJM_DEVICE_SHIFT) |\n\t\t\t(i << SND_DJM_GROUP_SHIFT) |\n\t\t\tvalue);\n\t\terr = snd_djm_controls_update(mixer, device_idx, i, value);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = add_single_ctl_with_resume(mixer, 0, snd_djm_controls_resume,\n\t\t\t\t\t\t &knew, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)\n{\n\tint err = 0;\n\n\terr = snd_usb_soundblaster_remote_init(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (mixer->chip->usb_id) {\n\t \n\tcase USB_ID(0x0644, 0x8047):\n\t\terr = snd_us16x08_controls_create(mixer);\n\t\tbreak;\n\tcase USB_ID(0x041e, 0x3020):\n\tcase USB_ID(0x041e, 0x3040):\n\tcase USB_ID(0x041e, 0x3042):\n\tcase USB_ID(0x041e, 0x30df):\n\tcase USB_ID(0x041e, 0x3048):\n\t\terr = snd_audigy2nx_controls_create(mixer);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tsnd_card_ro_proc_new(mixer->chip->card, \"audigy2nx\",\n\t\t\t\t     mixer, snd_audigy2nx_proc_read);\n\t\tbreak;\n\n\t \n\tcase USB_ID(0x041e, 0x3f19):\n\t\terr = snd_emu0204_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x0763, 0x2030):  \n\tcase USB_ID(0x0763, 0x2031):  \n\t\terr = snd_c400_create_mixer(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x0763, 0x2080):  \n\tcase USB_ID(0x0763, 0x2081):  \n\t\terr = snd_ftu_create_mixer(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x0b05, 0x1739):  \n\tcase USB_ID(0x0b05, 0x1743):  \n\tcase USB_ID(0x0b05, 0x17a0):  \n\t\terr = snd_xonar_u1_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x0d8c, 0x0103):  \n\t\terr = snd_microii_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x0dba, 0x1000):  \n\t\terr = snd_mbox1_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x17cc, 0x1011):  \n\t\terr = snd_nativeinstruments_create_mixer(mixer,\n\t\t\t\tsnd_nativeinstruments_ta6_mixers,\n\t\t\t\tARRAY_SIZE(snd_nativeinstruments_ta6_mixers));\n\t\tbreak;\n\n\tcase USB_ID(0x17cc, 0x1021):  \n\t\terr = snd_nativeinstruments_create_mixer(mixer,\n\t\t\t\tsnd_nativeinstruments_ta10_mixers,\n\t\t\t\tARRAY_SIZE(snd_nativeinstruments_ta10_mixers));\n\t\tbreak;\n\n\tcase USB_ID(0x200c, 0x1018):  \n\t\t \n\t\terr = snd_create_std_mono_table(mixer, ebox44_table);\n\t\tbreak;\n\n\tcase USB_ID(0x1235, 0x8012):  \n\tcase USB_ID(0x1235, 0x8002):  \n\tcase USB_ID(0x1235, 0x8004):  \n\tcase USB_ID(0x1235, 0x8014):  \n\tcase USB_ID(0x1235, 0x800c):  \n\t\terr = snd_scarlett_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x1235, 0x8203):  \n\tcase USB_ID(0x1235, 0x8204):  \n\tcase USB_ID(0x1235, 0x8201):  \n\tcase USB_ID(0x1235, 0x8211):  \n\tcase USB_ID(0x1235, 0x8210):  \n\tcase USB_ID(0x1235, 0x8212):  \n\tcase USB_ID(0x1235, 0x8213):  \n\tcase USB_ID(0x1235, 0x8214):  \n\tcase USB_ID(0x1235, 0x8215):  \n\tcase USB_ID(0x1235, 0x820c):  \n\t\terr = snd_scarlett_gen2_init(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x041e, 0x323b):  \n\t\terr = snd_soundblaster_e1_switch_create(mixer);\n\t\tbreak;\n\tcase USB_ID(0x0bda, 0x4014):  \n\t\terr = dell_dock_mixer_create(mixer);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\terr = dell_dock_mixer_init(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x2a39, 0x3fd2):  \n\tcase USB_ID(0x2a39, 0x3fd3):  \n\tcase USB_ID(0x2a39, 0x3fd4):  \n\t\terr = snd_rme_controls_create(mixer);\n\t\tbreak;\n\n\tcase USB_ID(0x194f, 0x010c):  \n\t\terr = snd_sc1810_init_mixer(mixer);\n\t\tbreak;\n\tcase USB_ID(0x2a39, 0x3fb0):  \n\t\terr = snd_bbfpro_controls_create(mixer);\n\t\tbreak;\n\tcase USB_ID(0x2b73, 0x0017):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_250MK2_IDX);\n\t\tbreak;\n\tcase USB_ID(0x2b73, 0x0013):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_450_IDX);\n\t\tbreak;\n\tcase USB_ID(0x08e4, 0x017f):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_750_IDX);\n\t\tbreak;\n\tcase USB_ID(0x2b73, 0x001b):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_750MK2_IDX);\n\t\tbreak;\n\tcase USB_ID(0x08e4, 0x0163):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_850_IDX);\n\t\tbreak;\n\tcase USB_ID(0x2b73, 0x000a):  \n\t\terr = snd_djm_controls_create(mixer, SND_DJM_900NXS2_IDX);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nvoid snd_usb_mixer_resume_quirk(struct usb_mixer_interface *mixer)\n{\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x0bda, 0x4014):  \n\t\tdell_dock_mixer_init(mixer);\n\t\tbreak;\n\t}\n}\n\nvoid snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,\n\t\t\t\t    int unitid)\n{\n\tif (!mixer->rc_cfg)\n\t\treturn;\n\t \n\tswitch (unitid) {\n\tcase 0:  \n\t\tmixer->rc_urb->dev = mixer->chip->dev;\n\t\tusb_submit_urb(mixer->rc_urb, GFP_ATOMIC);\n\t\tbreak;\n\tcase 4:  \n\tcase 7:  \n\tcase 19:  \n\tcase 20:  \n\t\tbreak;\n\t \n\tcase 3:\t \n\t\tif (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\n\t\t    mixer->chip->usb_id == USB_ID(0x041e, 0x3048))\n\t\t\tsnd_usb_mixer_notify_id(mixer, mixer->rc_cfg->mute_mixer_id);\n\t\tbreak;\n\tdefault:\n\t\tusb_audio_dbg(mixer->chip, \"memory change in unknown unit %d\\n\", unitid);\n\t\tbreak;\n\t}\n}\n\nstatic void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,\n\t\t\t\t\t struct usb_mixer_elem_info *cval,\n\t\t\t\t\t struct snd_kcontrol *kctl)\n{\n\t \n\tstatic const DECLARE_TLV_DB_RANGE(scale,\n\t\t 0,  1, TLV_DB_MINMAX_ITEM(-5300, -4970),\n\t\t 2,  5, TLV_DB_MINMAX_ITEM(-4710, -4160),\n\t\t 6,  7, TLV_DB_MINMAX_ITEM(-3884, -3710),\n\t\t 8, 14, TLV_DB_MINMAX_ITEM(-3443, -2560),\n\t\t15, 16, TLV_DB_MINMAX_ITEM(-2475, -2324),\n\t\t17, 19, TLV_DB_MINMAX_ITEM(-2228, -2031),\n\t\t20, 26, TLV_DB_MINMAX_ITEM(-1910, -1393),\n\t\t27, 31, TLV_DB_MINMAX_ITEM(-1322, -1032),\n\t\t32, 40, TLV_DB_MINMAX_ITEM(-968, -490),\n\t\t41, 50, TLV_DB_MINMAX_ITEM(-441, 0),\n\t);\n\n\tif (cval->min == 0 && cval->max == 50) {\n\t\tusb_audio_info(mixer->chip, \"applying DragonFly dB scale quirk (0-50 variant)\\n\");\n\t\tkctl->tlv.p = scale;\n\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\n\t} else if (cval->min == 0 && cval->max <= 1000) {\n\t\t \n\t\tusb_audio_info(mixer->chip, \"ignoring too narrow dB range on a DragonFly device\");\n\t\tkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n}\n\nvoid snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,\n\t\t\t\t  struct usb_mixer_elem_info *cval, int unitid,\n\t\t\t\t  struct snd_kcontrol *kctl)\n{\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x21b4, 0x0081):  \n\t\tif (unitid == 7 && cval->control == UAC_FU_VOLUME)\n\t\t\tsnd_dragonfly_quirk_db_scale(mixer, cval, kctl);\n\t\tbreak;\n\t \n\tcase USB_ID(0x0d8c, 0x000c):  \n\tcase USB_ID(0x0d8c, 0x0014):  \n\tcase USB_ID(0x19f7, 0x0003):  \n\t\tif (strstr(kctl->id.name, \"Playback\"))\n\t\t\tcval->min_mute = 1;\n\t\tbreak;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}