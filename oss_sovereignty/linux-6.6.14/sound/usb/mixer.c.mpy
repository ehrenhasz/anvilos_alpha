{
  "module_name": "mixer.c",
  "hash_id": "144479dc8ed34a3c4bb5f2c399ec2f9e5627e21e60acd3cfac61c2a12924e66c",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/hwdep.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n#include \"mixer_quirks.h\"\n#include \"power.h\"\n\n#define MAX_ID_ELEMS\t256\n\nstruct usb_audio_term {\n\tint id;\n\tint type;\n\tint channels;\n\tunsigned int chconfig;\n\tint name;\n};\n\nstruct usbmix_name_map;\n\nstruct mixer_build {\n\tstruct snd_usb_audio *chip;\n\tstruct usb_mixer_interface *mixer;\n\tunsigned char *buffer;\n\tunsigned int buflen;\n\tDECLARE_BITMAP(unitbitmap, MAX_ID_ELEMS);\n\tDECLARE_BITMAP(termbitmap, MAX_ID_ELEMS);\n\tstruct usb_audio_term oterm;\n\tconst struct usbmix_name_map *map;\n\tconst struct usbmix_selector_map *selector_map;\n};\n\n \nenum {\n\tUSB_XU_CLOCK_RATE \t\t= 0xe301,\n\tUSB_XU_CLOCK_SOURCE\t\t= 0xe302,\n\tUSB_XU_DIGITAL_IO_STATUS\t= 0xe303,\n\tUSB_XU_DEVICE_OPTIONS\t\t= 0xe304,\n\tUSB_XU_DIRECT_MONITORING\t= 0xe305,\n\tUSB_XU_METERING\t\t\t= 0xe306\n};\nenum {\n\tUSB_XU_CLOCK_SOURCE_SELECTOR = 0x02,\t \n\tUSB_XU_CLOCK_RATE_SELECTOR = 0x03,\t \n\tUSB_XU_DIGITAL_FORMAT_SELECTOR = 0x01,\t \n\tUSB_XU_SOFT_LIMIT_SELECTOR = 0x03\t \n};\n\n \n#include \"mixer_maps.c\"\n\nstatic const struct usbmix_name_map *\nfind_map(const struct usbmix_name_map *p, int unitid, int control)\n{\n\tif (!p)\n\t\treturn NULL;\n\n\tfor (; p->id; p++) {\n\t\tif (p->id == unitid &&\n\t\t    (!control || !p->control || control == p->control))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n \nstatic int\ncheck_mapped_name(const struct usbmix_name_map *p, char *buf, int buflen)\n{\n\tint len;\n\n\tif (!p || !p->name)\n\t\treturn 0;\n\n\tbuflen--;\n\tlen = strscpy(buf, p->name, buflen);\n\treturn len < 0 ? buflen : len;\n}\n\n \n#define filter_error(cval, err) \\\n\t((cval)->head.mixer->ignore_ctl_error ? 0 : (err))\n\n \nstatic inline int\ncheck_ignored_ctl(const struct usbmix_name_map *p)\n{\n\tif (!p || p->name || p->dB)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline void check_mapped_dB(const struct usbmix_name_map *p,\n\t\t\t\t   struct usb_mixer_elem_info *cval)\n{\n\tif (p && p->dB) {\n\t\tcval->dBmin = p->dB->min;\n\t\tcval->dBmax = p->dB->max;\n\t\tcval->min_mute = p->dB->min_mute;\n\t\tcval->initialized = 1;\n\t}\n}\n\n \nstatic int check_mapped_selector_name(struct mixer_build *state, int unitid,\n\t\t\t\t      int index, char *buf, int buflen)\n{\n\tconst struct usbmix_selector_map *p;\n\tint len;\n\n\tif (!state->selector_map)\n\t\treturn 0;\n\tfor (p = state->selector_map; p->id; p++) {\n\t\tif (p->id == unitid && index < p->count) {\n\t\t\tlen = strscpy(buf, p->names[index], buflen);\n\t\t\treturn len < 0 ? buflen : len;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t \n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC3_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int snd_usb_copy_string_desc(struct snd_usb_audio *chip,\n\t\t\t\t    int index, char *buf, int maxlen)\n{\n\tint len = usb_string(chip->dev, index, buf, maxlen - 1);\n\n\tif (len < 0)\n\t\treturn 0;\n\n\tbuf[len] = 0;\n\treturn len;\n}\n\n \nstatic int convert_signed_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_U8:\n\t\tval &= 0xff;\n\t\tbreak;\n\tcase USB_MIXER_S8:\n\t\tval &= 0xff;\n\t\tif (val >= 0x80)\n\t\t\tval -= 0x100;\n\t\tbreak;\n\tcase USB_MIXER_U16:\n\t\tval &= 0xffff;\n\t\tbreak;\n\tcase USB_MIXER_S16:\n\t\tval &= 0xffff;\n\t\tif (val >= 0x8000)\n\t\t\tval -= 0x10000;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n \nstatic int convert_bytes_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_S8:\n\tcase USB_MIXER_U8:\n\t\treturn val & 0xff;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn val & 0xffff;\n\t}\n\treturn 0;  \n}\n\nstatic int get_relative_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tif (val < cval->min)\n\t\treturn 0;\n\telse if (val >= cval->max)\n\t\treturn DIV_ROUND_UP(cval->max - cval->min, cval->res);\n\telse\n\t\treturn (val - cval->min) / cval->res;\n}\n\nstatic int get_abs_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (val < 0)\n\t\treturn cval->min;\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tval *= cval->res;\n\tval += cval->min;\n\tif (val > cval->max)\n\t\treturn cval->max;\n\treturn val;\n}\n\nstatic int uac2_ctl_value_size(int val_type)\n{\n\tswitch (val_type) {\n\tcase USB_MIXER_S32:\n\tcase USB_MIXER_U32:\n\t\treturn 4;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;  \n}\n\n\n \n\nstatic inline int mixer_ctrl_intf(struct usb_mixer_interface *mixer)\n{\n\treturn get_iface_desc(mixer->hostif)->bInterfaceNumber;\n}\n\nstatic int get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[2];\n\tint val_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\tint timeout = 10;\n\tint idx = 0, err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = mixer_ctrl_intf(cval->head.mixer) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= val_len) {\n\t\t\t*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(buf, val_len));\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip,\n\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\trequest, validx, idx, cval->val_type);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\t \n\tunsigned char buf[sizeof(__u16) + 3 * sizeof(__u32)];\n\tunsigned char *val;\n\tint idx = 0, ret, val_size, size;\n\t__u8 bRequest;\n\n\tval_size = uac2_ctl_value_size(cval->val_type);\n\n\tif (request == UAC_GET_CUR) {\n\t\tbRequest = UAC2_CS_CUR;\n\t\tsize = val_size;\n\t} else {\n\t\tbRequest = UAC2_CS_RANGE;\n\t\tsize = sizeof(__u16) + 3 * val_size;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (snd_usb_lock_shutdown(chip))\n\t\treturn -EIO;\n\n\tidx = mixer_ctrl_intf(cval->head.mixer) | (cval->head.id << 8);\n\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      validx, idx, buf, size);\n\tsnd_usb_unlock_shutdown(chip);\n\n\tif (ret < 0) {\n\t\tusb_audio_dbg(chip,\n\t\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\t\trequest, validx, idx, cval->val_type);\n\t\treturn ret;\n\t}\n\n\t \n\n\tswitch (request) {\n\tcase UAC_GET_CUR:\n\t\tval = buf;\n\t\tbreak;\n\tcase UAC_GET_MIN:\n\t\tval = buf + sizeof(__u16);\n\t\tbreak;\n\tcase UAC_GET_MAX:\n\t\tval = buf + sizeof(__u16) + val_size;\n\t\tbreak;\n\tcase UAC_GET_RES:\n\t\tval = buf + sizeof(__u16) + val_size * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*value_ret = convert_signed_value(cval,\n\t\t\t\t\t  snd_usb_combine_bytes(val, val_size));\n\n\treturn 0;\n}\n\nstatic int get_ctl_value(struct usb_mixer_elem_info *cval, int request,\n\t\t\t int validx, int *value_ret)\n{\n\tvalidx += cval->idx_off;\n\n\treturn (cval->head.mixer->protocol == UAC_VERSION_1) ?\n\t\tget_ctl_value_v1(cval, request, validx, value_ret) :\n\t\tget_ctl_value_v2(cval, request, validx, value_ret);\n}\n\nstatic int get_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR, validx, value);\n}\n\n \nstatic inline int get_cur_mix_raw(struct usb_mixer_elem_info *cval,\n\t\t\t\t  int channel, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR,\n\t\t\t     (cval->control << 8) | channel,\n\t\t\t     value);\n}\n\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int channel, int index, int *value)\n{\n\tint err;\n\n\tif (cval->cached & (1 << channel)) {\n\t\t*value = cval->cache_val[index];\n\t\treturn 0;\n\t}\n\terr = get_cur_mix_raw(cval, channel, value);\n\tif (err < 0) {\n\t\tif (!cval->head.mixer->ignore_ctl_error)\n\t\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t\t\"cannot get current value for control %d ch %d: err = %d\\n\",\n\t\t\t\t      cval->control, channel, err);\n\t\treturn err;\n\t}\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = *value;\n\treturn 0;\n}\n\n \n\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t\tint request, int validx, int value_set)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4];\n\tint idx = 0, val_len, err, timeout = 10;\n\n\tvalidx += cval->idx_off;\n\n\n\tif (cval->head.mixer->protocol == UAC_VERSION_1) {\n\t\tval_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\t} else {  \n\t\tval_len = uac2_ctl_value_size(cval->val_type);\n\n\t\t \n\t\tif (request != UAC_SET_CUR) {\n\t\t\tusb_audio_dbg(chip, \"RANGE setting not yet supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trequest = UAC2_CS_CUR;\n\t}\n\n\tvalue_set = convert_bytes_value(cval, value_set);\n\tbuf[0] = value_set & 0xff;\n\tbuf[1] = (value_set >> 8) & 0xff;\n\tbuf[2] = (value_set >> 16) & 0xff;\n\tbuf[3] = (value_set >> 24) & 0xff;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = mixer_ctrl_intf(cval->head.mixer) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t\t      usb_sndctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= 0) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip, \"cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\\n\",\n\t\t      request, validx, idx, cval->val_type, buf[0], buf[1]);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int set_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int value)\n{\n\treturn snd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR, validx, value);\n}\n\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\n\t\t\t     int index, int value)\n{\n\tint err;\n\tunsigned int read_only = (channel == 0) ?\n\t\tcval->master_readonly :\n\t\tcval->ch_readonly & (1 << (channel - 1));\n\n\tif (read_only) {\n\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t      \"%s(): channel %d of control %d is read_only\\n\",\n\t\t\t    __func__, channel, cval->control);\n\t\treturn 0;\n\t}\n\n\terr = snd_usb_mixer_set_ctl_value(cval,\n\t\t\t\t\t  UAC_SET_CUR, (cval->control << 8) | channel,\n\t\t\t\t\t  value);\n\tif (err < 0)\n\t\treturn err;\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = value;\n\treturn 0;\n}\n\n \nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t unsigned int size, unsigned int __user *_tlv)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tDECLARE_TLV_DB_MINMAX(scale, 0, 0);\n\n\tif (size < sizeof(scale))\n\t\treturn -ENOMEM;\n\tif (cval->min_mute)\n\t\tscale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;\n\tscale[2] = cval->dBmin;\n\tscale[3] = cval->dBmax;\n\tif (copy_to_user(_tlv, scale, sizeof(scale)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid);\n\n\n \nstatic int check_matrix_bitmap(unsigned char *bmap,\n\t\t\t       int ich, int och, int num_outs)\n{\n\tint idx = ich * num_outs + och;\n\treturn bmap[idx >> 3] & (0x80 >> (idx & 7));\n}\n\n \n\nint snd_usb_mixer_add_list(struct usb_mixer_elem_list *list,\n\t\t\t   struct snd_kcontrol *kctl,\n\t\t\t   bool is_std_info)\n{\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\n\twhile (snd_ctl_find_id(mixer->chip->card, &kctl->id))\n\t\tkctl->id.index++;\n\terr = snd_ctl_add(mixer->chip->card, kctl);\n\tif (err < 0) {\n\t\tusb_audio_dbg(mixer->chip, \"cannot add control (err = %d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\tlist->kctl = kctl;\n\tlist->is_std_info = is_std_info;\n\tlist->next_id_elem = mixer->id_elems[list->id];\n\tmixer->id_elems[list->id] = list;\n\treturn 0;\n}\n\n \n\nstatic struct iterm_name_combo {\n\tint type;\n\tchar *name;\n} iterm_names[] = {\n\t{ 0x0300, \"Output\" },\n\t{ 0x0301, \"Speaker\" },\n\t{ 0x0302, \"Headphone\" },\n\t{ 0x0303, \"HMD Audio\" },\n\t{ 0x0304, \"Desktop Speaker\" },\n\t{ 0x0305, \"Room Speaker\" },\n\t{ 0x0306, \"Com Speaker\" },\n\t{ 0x0307, \"LFE\" },\n\t{ 0x0600, \"External In\" },\n\t{ 0x0601, \"Analog In\" },\n\t{ 0x0602, \"Digital In\" },\n\t{ 0x0603, \"Line\" },\n\t{ 0x0604, \"Legacy In\" },\n\t{ 0x0605, \"IEC958 In\" },\n\t{ 0x0606, \"1394 DA Stream\" },\n\t{ 0x0607, \"1394 DV Stream\" },\n\t{ 0x0700, \"Embedded\" },\n\t{ 0x0701, \"Noise Source\" },\n\t{ 0x0702, \"Equalization Noise\" },\n\t{ 0x0703, \"CD\" },\n\t{ 0x0704, \"DAT\" },\n\t{ 0x0705, \"DCC\" },\n\t{ 0x0706, \"MiniDisk\" },\n\t{ 0x0707, \"Analog Tape\" },\n\t{ 0x0708, \"Phonograph\" },\n\t{ 0x0709, \"VCR Audio\" },\n\t{ 0x070a, \"Video Disk Audio\" },\n\t{ 0x070b, \"DVD Audio\" },\n\t{ 0x070c, \"TV Tuner Audio\" },\n\t{ 0x070d, \"Satellite Rec Audio\" },\n\t{ 0x070e, \"Cable Tuner Audio\" },\n\t{ 0x070f, \"DSS Audio\" },\n\t{ 0x0710, \"Radio Receiver\" },\n\t{ 0x0711, \"Radio Transmitter\" },\n\t{ 0x0712, \"Multi-Track Recorder\" },\n\t{ 0x0713, \"Synthesizer\" },\n\t{ 0 },\n};\n\nstatic int get_term_name(struct snd_usb_audio *chip, struct usb_audio_term *iterm,\n\t\t\t unsigned char *name, int maxlen, int term_only)\n{\n\tstruct iterm_name_combo *names;\n\tint len;\n\n\tif (iterm->name) {\n\t\tlen = snd_usb_copy_string_desc(chip, iterm->name,\n\t\t\t\t\t\tname, maxlen);\n\t\tif (len)\n\t\t\treturn len;\n\t}\n\n\t \n\tif (iterm->type >> 16) {\n\t\tif (term_only)\n\t\t\treturn 0;\n\t\tswitch (iterm->type >> 16) {\n\t\tcase UAC3_SELECTOR_UNIT:\n\t\t\tstrcpy(name, \"Selector\");\n\t\t\treturn 8;\n\t\tcase UAC3_PROCESSING_UNIT:\n\t\t\tstrcpy(name, \"Process Unit\");\n\t\t\treturn 12;\n\t\tcase UAC3_EXTENSION_UNIT:\n\t\t\tstrcpy(name, \"Ext Unit\");\n\t\t\treturn 8;\n\t\tcase UAC3_MIXER_UNIT:\n\t\t\tstrcpy(name, \"Mixer\");\n\t\t\treturn 5;\n\t\tdefault:\n\t\t\treturn sprintf(name, \"Unit %d\", iterm->id);\n\t\t}\n\t}\n\n\tswitch (iterm->type & 0xff00) {\n\tcase 0x0100:\n\t\tstrcpy(name, \"PCM\");\n\t\treturn 3;\n\tcase 0x0200:\n\t\tstrcpy(name, \"Mic\");\n\t\treturn 3;\n\tcase 0x0400:\n\t\tstrcpy(name, \"Headset\");\n\t\treturn 7;\n\tcase 0x0500:\n\t\tstrcpy(name, \"Phone\");\n\t\treturn 5;\n\t}\n\n\tfor (names = iterm_names; names->type; names++) {\n\t\tif (names->type == iterm->type) {\n\t\t\tstrcpy(name, names->name);\n\t\t\treturn strlen(names->name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_cluster_channels_v3(struct mixer_build *state, unsigned int cluster_id)\n{\n\tstruct uac3_cluster_header_descriptor c_header;\n\tint err;\n\n\terr = snd_usb_ctl_msg(state->chip->dev,\n\t\t\tusb_rcvctrlpipe(state->chip->dev, 0),\n\t\t\tUAC3_CS_REQ_HIGH_CAPABILITY_DESCRIPTOR,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\tcluster_id,\n\t\t\tsnd_usb_ctrl_intf(state->chip),\n\t\t\t&c_header, sizeof(c_header));\n\tif (err < 0)\n\t\tgoto error;\n\tif (err != sizeof(c_header)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\treturn c_header.bNrChannels;\n\nerror:\n\tusb_audio_err(state->chip, \"cannot request logical cluster ID: %d (err: %d)\\n\", cluster_id, err);\n\treturn err;\n}\n\n \nstatic int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0;  \n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\n\treturn mu_channels;\n}\n\n \nstatic int __check_input_term(struct mixer_build *state, int id,\n\t\t\t      struct usb_audio_term *term);\n\nstatic int parse_term_uac1_iterm_unit(struct mixer_build *state,\n\t\t\t\t      struct usb_audio_term *term,\n\t\t\t\t      void *p1, int id)\n{\n\tstruct uac_input_terminal_descriptor *d = p1;\n\n\tterm->type = le16_to_cpu(d->wTerminalType);\n\tterm->channels = d->bNrChannels;\n\tterm->chconfig = le16_to_cpu(d->wChannelConfig);\n\tterm->name = d->iTerminal;\n\treturn 0;\n}\n\nstatic int parse_term_uac2_iterm_unit(struct mixer_build *state,\n\t\t\t\t      struct usb_audio_term *term,\n\t\t\t\t      void *p1, int id)\n{\n\tstruct uac2_input_terminal_descriptor *d = p1;\n\tint err;\n\n\t \n\terr = __check_input_term(state, d->bCSourceID, term);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tterm->id = id;\n\tterm->type = le16_to_cpu(d->wTerminalType);\n\tterm->channels = d->bNrChannels;\n\tterm->chconfig = le32_to_cpu(d->bmChannelConfig);\n\tterm->name = d->iTerminal;\n\treturn 0;\n}\n\nstatic int parse_term_uac3_iterm_unit(struct mixer_build *state,\n\t\t\t\t      struct usb_audio_term *term,\n\t\t\t\t      void *p1, int id)\n{\n\tstruct uac3_input_terminal_descriptor *d = p1;\n\tint err;\n\n\t \n\terr = __check_input_term(state, d->bCSourceID, term);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tterm->id = id;\n\tterm->type = le16_to_cpu(d->wTerminalType);\n\n\terr = get_cluster_channels_v3(state, le16_to_cpu(d->wClusterDescrID));\n\tif (err < 0)\n\t\treturn err;\n\tterm->channels = err;\n\n\t \n\tterm->chconfig = 0;\n\n\tterm->name = le16_to_cpu(d->wTerminalDescrStr);\n\treturn 0;\n}\n\nstatic int parse_term_mixer_unit(struct mixer_build *state,\n\t\t\t\t struct usb_audio_term *term,\n\t\t\t\t void *p1, int id)\n{\n\tstruct uac_mixer_unit_descriptor *d = p1;\n\tint protocol = state->mixer->protocol;\n\tint err;\n\n\terr = uac_mixer_unit_get_channels(state, d);\n\tif (err <= 0)\n\t\treturn err;\n\n\tterm->type = UAC3_MIXER_UNIT << 16;  \n\tterm->channels = err;\n\tif (protocol != UAC_VERSION_3) {\n\t\tterm->chconfig = uac_mixer_unit_wChannelConfig(d, protocol);\n\t\tterm->name = uac_mixer_unit_iMixer(d);\n\t}\n\treturn 0;\n}\n\nstatic int parse_term_selector_unit(struct mixer_build *state,\n\t\t\t\t    struct usb_audio_term *term,\n\t\t\t\t    void *p1, int id)\n{\n\tstruct uac_selector_unit_descriptor *d = p1;\n\tint err;\n\n\t \n\terr = __check_input_term(state, d->baSourceID[0], term);\n\tif (err < 0)\n\t\treturn err;\n\tterm->type = UAC3_SELECTOR_UNIT << 16;  \n\tterm->id = id;\n\tif (state->mixer->protocol != UAC_VERSION_3)\n\t\tterm->name = uac_selector_unit_iSelector(d);\n\treturn 0;\n}\n\nstatic int parse_term_proc_unit(struct mixer_build *state,\n\t\t\t\tstruct usb_audio_term *term,\n\t\t\t\tvoid *p1, int id, int vtype)\n{\n\tstruct uac_processing_unit_descriptor *d = p1;\n\tint protocol = state->mixer->protocol;\n\tint err;\n\n\tif (d->bNrInPins) {\n\t\t \n\t\terr = __check_input_term(state, d->baSourceID[0], term);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tterm->type = vtype << 16;  \n\tterm->id = id;\n\n\tif (protocol == UAC_VERSION_3)\n\t\treturn 0;\n\n\tif (!term->channels) {\n\t\tterm->channels = uac_processing_unit_bNrChannels(d);\n\t\tterm->chconfig = uac_processing_unit_wChannelConfig(d, protocol);\n\t}\n\tterm->name = uac_processing_unit_iProcessing(d, protocol);\n\treturn 0;\n}\n\nstatic int parse_term_effect_unit(struct mixer_build *state,\n\t\t\t\t  struct usb_audio_term *term,\n\t\t\t\t  void *p1, int id)\n{\n\tstruct uac2_effect_unit_descriptor *d = p1;\n\tint err;\n\n\terr = __check_input_term(state, d->bSourceID, term);\n\tif (err < 0)\n\t\treturn err;\n\tterm->type = UAC3_EFFECT_UNIT << 16;  \n\tterm->id = id;\n\treturn 0;\n}\n\nstatic int parse_term_uac2_clock_source(struct mixer_build *state,\n\t\t\t\t\tstruct usb_audio_term *term,\n\t\t\t\t\tvoid *p1, int id)\n{\n\tstruct uac_clock_source_descriptor *d = p1;\n\n\tterm->type = UAC3_CLOCK_SOURCE << 16;  \n\tterm->id = id;\n\tterm->name = d->iClockSource;\n\treturn 0;\n}\n\nstatic int parse_term_uac3_clock_source(struct mixer_build *state,\n\t\t\t\t\tstruct usb_audio_term *term,\n\t\t\t\t\tvoid *p1, int id)\n{\n\tstruct uac3_clock_source_descriptor *d = p1;\n\n\tterm->type = UAC3_CLOCK_SOURCE << 16;  \n\tterm->id = id;\n\tterm->name = le16_to_cpu(d->wClockSourceStr);\n\treturn 0;\n}\n\n#define PTYPE(a, b)\t((a) << 8 | (b))\n\n \nstatic int __check_input_term(struct mixer_build *state, int id,\n\t\t\t      struct usb_audio_term *term)\n{\n\tint protocol = state->mixer->protocol;\n\tvoid *p1;\n\tunsigned char *hdr;\n\n\tfor (;;) {\n\t\t \n\t\tif (test_and_set_bit(id, state->termbitmap))\n\t\t\treturn -EINVAL;\n\n\t\tp1 = find_audio_control_unit(state, id);\n\t\tif (!p1)\n\t\t\tbreak;\n\t\tif (!snd_usb_validate_audio_desc(p1, protocol))\n\t\t\tbreak;  \n\n\t\thdr = p1;\n\t\tterm->id = id;\n\n\t\tswitch (PTYPE(protocol, hdr[2])) {\n\t\tcase PTYPE(UAC_VERSION_1, UAC_FEATURE_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC_FEATURE_UNIT):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_FEATURE_UNIT): {\n\t\t\t \n\t\t\tstruct uac_feature_unit_descriptor *d = p1;\n\n\t\t\tid = d->bSourceID;\n\t\t\tbreak;  \n\t\t}\n\t\tcase PTYPE(UAC_VERSION_1, UAC_INPUT_TERMINAL):\n\t\t\treturn parse_term_uac1_iterm_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_2, UAC_INPUT_TERMINAL):\n\t\t\treturn parse_term_uac2_iterm_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_3, UAC_INPUT_TERMINAL):\n\t\t\treturn parse_term_uac3_iterm_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_1, UAC_MIXER_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC_MIXER_UNIT):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_MIXER_UNIT):\n\t\t\treturn parse_term_mixer_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_1, UAC_SELECTOR_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC_SELECTOR_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC2_CLOCK_SELECTOR):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_SELECTOR_UNIT):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_CLOCK_SELECTOR):\n\t\t\treturn parse_term_selector_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_1, UAC1_PROCESSING_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC2_PROCESSING_UNIT_V2):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_PROCESSING_UNIT):\n\t\t\treturn parse_term_proc_unit(state, term, p1, id,\n\t\t\t\t\t\t    UAC3_PROCESSING_UNIT);\n\t\tcase PTYPE(UAC_VERSION_2, UAC2_EFFECT_UNIT):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_EFFECT_UNIT):\n\t\t\treturn parse_term_effect_unit(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_1, UAC1_EXTENSION_UNIT):\n\t\tcase PTYPE(UAC_VERSION_2, UAC2_EXTENSION_UNIT_V2):\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_EXTENSION_UNIT):\n\t\t\treturn parse_term_proc_unit(state, term, p1, id,\n\t\t\t\t\t\t    UAC3_EXTENSION_UNIT);\n\t\tcase PTYPE(UAC_VERSION_2, UAC2_CLOCK_SOURCE):\n\t\t\treturn parse_term_uac2_clock_source(state, term, p1, id);\n\t\tcase PTYPE(UAC_VERSION_3, UAC3_CLOCK_SOURCE):\n\t\t\treturn parse_term_uac3_clock_source(state, term, p1, id);\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\n\nstatic int check_input_term(struct mixer_build *state, int id,\n\t\t\t    struct usb_audio_term *term)\n{\n\tmemset(term, 0, sizeof(*term));\n\tmemset(state->termbitmap, 0, sizeof(state->termbitmap));\n\treturn __check_input_term(state, id, term);\n}\n\n \n\n \nstruct usb_feature_control_info {\n\tint control;\n\tconst char *name;\n\tint type;\t \n\tint type_uac2;\t \n};\n\nstatic const struct usb_feature_control_info audio_feature_info[] = {\n\t{ UAC_FU_MUTE,\t\t\t\"Mute\",\t\t\tUSB_MIXER_INV_BOOLEAN, -1 },\n\t{ UAC_FU_VOLUME,\t\t\"Volume\",\t\tUSB_MIXER_S16, -1 },\n\t{ UAC_FU_BASS,\t\t\t\"Tone Control - Bass\",\tUSB_MIXER_S8, -1 },\n\t{ UAC_FU_MID,\t\t\t\"Tone Control - Mid\",\tUSB_MIXER_S8, -1 },\n\t{ UAC_FU_TREBLE,\t\t\"Tone Control - Treble\", USB_MIXER_S8, -1 },\n\t{ UAC_FU_GRAPHIC_EQUALIZER,\t\"Graphic Equalizer\",\tUSB_MIXER_S8, -1 },  \n\t{ UAC_FU_AUTOMATIC_GAIN,\t\"Auto Gain Control\",\tUSB_MIXER_BOOLEAN, -1 },\n\t{ UAC_FU_DELAY,\t\t\t\"Delay Control\",\tUSB_MIXER_U16, USB_MIXER_U32 },\n\t{ UAC_FU_BASS_BOOST,\t\t\"Bass Boost\",\t\tUSB_MIXER_BOOLEAN, -1 },\n\t{ UAC_FU_LOUDNESS,\t\t\"Loudness\",\t\tUSB_MIXER_BOOLEAN, -1 },\n\t \n\t{ UAC2_FU_INPUT_GAIN,\t\t\"Input Gain Control\",\tUSB_MIXER_S16, -1 },\n\t{ UAC2_FU_INPUT_GAIN_PAD,\t\"Input Gain Pad Control\", USB_MIXER_S16, -1 },\n\t{ UAC2_FU_PHASE_INVERTER,\t \"Phase Inverter Control\", USB_MIXER_BOOLEAN, -1 },\n};\n\nstatic void usb_mixer_elem_info_free(struct usb_mixer_elem_info *cval)\n{\n\tkfree(cval);\n}\n\n \nvoid snd_usb_mixer_elem_free(struct snd_kcontrol *kctl)\n{\n\tusb_mixer_elem_info_free(kctl->private_data);\n\tkctl->private_data = NULL;\n}\n\n \n\n \nstatic void volume_control_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t  struct snd_kcontrol *kctl)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030):  \n\tcase USB_ID(0x0763, 0x2031):  \n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0xffff;\n\t\t\tcval->res = 0x00e6;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(kctl->id.name, \"Effect Return\") != NULL) {\n\t\t\tcval->min = 0xb706;\n\t\t\tcval->max = 0xff7b;\n\t\t\tcval->res = 0x0073;\n\t\t\tbreak;\n\t\t}\n\t\tif ((strstr(kctl->id.name, \"Playback Volume\") != NULL) ||\n\t\t\t(strstr(kctl->id.name, \"Effect Send\") != NULL)) {\n\t\t\tcval->min = 0xb5fb;  \n\t\t\tcval->max = 0xfcfe;\n\t\t\tcval->res = 0x0073;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0763, 0x2081):  \n\tcase USB_ID(0x0763, 0x2080):  \n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirk for FTU Effect Duration\\n\");\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0x7f00;\n\t\t\tcval->res = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirks for FTU Effect Feedback/Volume\\n\");\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0x7f;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0d8c, 0x0103):\n\t\tif (!strcmp(kctl->id.name, \"PCM Playback Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"set volume quirk for CM102-A+/102S+\\n\");\n\t\t\tcval->min = -256;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0471, 0x0101):\n\tcase USB_ID(0x0471, 0x0104):\n\tcase USB_ID(0x0471, 0x0105):\n\tcase USB_ID(0x0672, 0x1041):\n\t \n\t\tif (!strcmp(kctl->id.name, \"PCM Playback Volume\") &&\n\t\t    cval->min == -15616) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"set volume quirk for UDA1321/N101 chip\\n\");\n\t\t\tcval->max = -256;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x09a4):\n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set volume quirk for QuickCam E3500\\n\");\n\t\t\tcval->min = 6080;\n\t\t\tcval->max = 8768;\n\t\t\tcval->res = 192;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x0807):  \n\tcase USB_ID(0x046d, 0x0808):\n\tcase USB_ID(0x046d, 0x0809):\n\tcase USB_ID(0x046d, 0x0819):  \n\tcase USB_ID(0x046d, 0x081b):  \n\tcase USB_ID(0x046d, 0x081d):  \n\tcase USB_ID(0x046d, 0x0825):  \n\tcase USB_ID(0x046d, 0x0826):  \n\tcase USB_ID(0x046d, 0x08ca):  \n\tcase USB_ID(0x046d, 0x0991):\n\tcase USB_ID(0x046d, 0x09a2):  \n\t \n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set resolution quirk: cval->res = 384\\n\");\n\t\t\tcval->res = 384;\n\t\t}\n\t\tbreak;\n\tcase USB_ID(0x0495, 0x3042):  \n\t\tif ((strstr(kctl->id.name, \"Playback Volume\") != NULL) ||\n\t\t\tstrstr(kctl->id.name, \"Capture Volume\") != NULL) {\n\t\t\tcval->min >>= 8;\n\t\t\tcval->max = 0;\n\t\t\tcval->res = 1;\n\t\t}\n\t\tbreak;\n\tcase USB_ID(0x1224, 0x2a25):  \n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set resolution quirk: cval->res = 16\\n\");\n\t\t\tcval->res = 16;\n\t\t}\n\t\tbreak;\n\tcase USB_ID(0x1bcf, 0x2283):  \n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set resolution quirk: cval->res = 16\\n\");\n\t\t\tcval->res = 16;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void init_cur_mix_raw(struct usb_mixer_elem_info *cval, int ch, int idx)\n{\n\tint val, err;\n\n\terr = snd_usb_get_cur_mix_value(cval, ch, idx, &val);\n\tif (!err)\n\t\treturn;\n\tif (!cval->head.mixer->ignore_ctl_error)\n\t\tusb_audio_warn(cval->head.mixer->chip,\n\t\t\t       \"%d:%d: failed to get current value for ch %d (%d)\\n\",\n\t\t\t       cval->head.id, mixer_ctrl_intf(cval->head.mixer),\n\t\t\t       ch, err);\n\tsnd_usb_set_cur_mix_value(cval, ch, idx, cval->min);\n}\n\n \nstatic int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t   int default_min, struct snd_kcontrol *kctl)\n{\n\tint i, idx;\n\n\t \n\tcval->min = default_min;\n\tcval->max = cval->min + 1;\n\tcval->res = 1;\n\tcval->dBmin = cval->dBmax = 0;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tcval->initialized = 1;\n\t} else {\n\t\tint minchn = 0;\n\t\tif (cval->cmask) {\n\t\t\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\t\t\tif (cval->cmask & (1 << i)) {\n\t\t\t\t\tminchn = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||\n\t\t    get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {\n\t\t\tusb_audio_err(cval->head.mixer->chip,\n\t\t\t\t      \"%d:%d: cannot get min/max values for control %d (id %d)\\n\",\n\t\t\t\t   cval->head.id, mixer_ctrl_intf(cval->head.mixer),\n\t\t\t\t\t\t\t       cval->control, cval->head.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t  (cval->control << 8) | minchn,\n\t\t\t\t  &cval->res) < 0) {\n\t\t\tcval->res = 1;\n\t\t} else if (cval->head.mixer->protocol == UAC_VERSION_1) {\n\t\t\tint last_valid_res = cval->res;\n\n\t\t\twhile (cval->res > 1) {\n\t\t\t\tif (snd_usb_mixer_set_ctl_value(cval, UAC_SET_RES,\n\t\t\t\t\t\t\t\t(cval->control << 8) | minchn,\n\t\t\t\t\t\t\t\tcval->res / 2) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res /= 2;\n\t\t\t}\n\t\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t\t  (cval->control << 8) | minchn, &cval->res) < 0)\n\t\t\t\tcval->res = last_valid_res;\n\t\t}\n\t\tif (cval->res == 0)\n\t\t\tcval->res = 1;\n\n\t\t \n\t\tif (cval->min + cval->res < cval->max) {\n\t\t\tint last_valid_res = cval->res;\n\t\t\tint saved, test, check;\n\t\t\tif (get_cur_mix_raw(cval, minchn, &saved) < 0)\n\t\t\t\tgoto no_res_check;\n\t\t\tfor (;;) {\n\t\t\t\ttest = saved;\n\t\t\t\tif (test < cval->max)\n\t\t\t\t\ttest += cval->res;\n\t\t\t\telse\n\t\t\t\t\ttest -= cval->res;\n\t\t\t\tif (test < cval->min || test > cval->max ||\n\t\t\t\t    snd_usb_set_cur_mix_value(cval, minchn, 0, test) ||\n\t\t\t\t    get_cur_mix_raw(cval, minchn, &check)) {\n\t\t\t\t\tcval->res = last_valid_res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (test == check)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res *= 2;\n\t\t\t}\n\t\t\tsnd_usb_set_cur_mix_value(cval, minchn, 0, saved);\n\t\t}\n\nno_res_check:\n\t\tcval->initialized = 1;\n\t}\n\n\tif (kctl)\n\t\tvolume_control_quirks(cval, kctl);\n\n\t \n\tcval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;\n\tcval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;\n\tif (cval->dBmin > cval->dBmax) {\n\t\t \n\t\tif (cval->dBmin < 0)\n\t\t\tcval->dBmax = 0;\n\t\telse if (cval->dBmin > 0)\n\t\t\tcval->dBmin = 0;\n\t\tif (cval->dBmin > cval->dBmax) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (cval->dBmax <= -9600) {\n\t\t\tusb_audio_info(cval->head.mixer->chip,\n\t\t\t\t       \"%d:%d: bogus dB values (%d/%d), disabling dB reporting\\n\",\n\t\t\t\t       cval->head.id, mixer_ctrl_intf(cval->head.mixer),\n\t\t\t\t       cval->dBmin, cval->dBmax);\n\t\t\tcval->dBmin = cval->dBmax = 0;\n\t\t}\n\t}\n\n\t \n\tif (!cval->cmask) {\n\t\tinit_cur_mix_raw(cval, 0, 0);\n\t} else {\n\t\tidx = 0;\n\t\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\t\tif (cval->cmask & (1 << i)) {\n\t\t\t\tinit_cur_mix_raw(cval, i + 1, idx);\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define get_min_max(cval, def)\tget_min_max_with_quirks(cval, def, NULL)\n\n \nstatic int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = cval->channels;\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 1;\n\t} else {\n\t\tif (!cval->initialized) {\n\t\t\tget_min_max_with_quirks(cval, 0, kcontrol);\n\t\t\tif (cval->initialized && cval->dBmin >= cval->dBmax) {\n\t\t\t\tkcontrol->vd[0].access &= \n\t\t\t\t\t~(SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);\n\t\t\t\tsnd_ctl_notify(cval->head.mixer->chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t\t\t       &kcontrol->id);\n\t\t\t}\n\t\t}\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max =\n\t\t\tDIV_ROUND_UP(cval->max - cval->min, cval->res);\n\t}\n\treturn 0;\n}\n\n \nstatic int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, err;\n\n\tucontrol->value.integer.value[0] = cval->min;\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &val);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = get_relative_value(cval, val);\n\t\t\tucontrol->value.integer.value[cnt] = val;\n\t\t\tcnt++;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\t \n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &val);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = get_relative_value(cval, val);\n\t\tucontrol->value.integer.value[0] = val;\n\t}\n\treturn 0;\n}\n\n \nstatic int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, oval, err;\n\tint changed = 0;\n\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &oval);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = ucontrol->value.integer.value[cnt];\n\t\t\tval = get_abs_value(cval, val);\n\t\t\tif (oval != val) {\n\t\t\t\tsnd_usb_set_cur_mix_value(cval, c + 1, cnt, val);\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t} else {\n\t\t \n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &oval);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = ucontrol->value.integer.value[0];\n\t\tval = get_abs_value(cval, val);\n\t\tif (val != oval) {\n\t\t\tsnd_usb_set_cur_mix_value(cval, 0, 0, val);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\treturn changed;\n}\n\n \nstatic int mixer_ctl_master_bool_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, err;\n\n\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &val);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = (val != 0);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int get_connector_value(struct usb_mixer_elem_info *cval,\n\t\t\t       char *name, int *val)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tint idx = 0, validx, ret;\n\n\tvalidx = cval->control << 8 | 0;\n\n\tret = snd_usb_lock_shutdown(chip) ? -EIO : 0;\n\tif (ret)\n\t\tgoto error;\n\n\tidx = mixer_ctrl_intf(cval->head.mixer) | (cval->head.id << 8);\n\tif (cval->head.mixer->protocol == UAC_VERSION_2) {\n\t\tstruct uac2_connectors_ctl_blk uac2_conn;\n\n\t\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), UAC2_CS_CUR,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t\t      validx, idx, &uac2_conn, sizeof(uac2_conn));\n\t\tif (val)\n\t\t\t*val = !!uac2_conn.bNrChannels;\n\t} else {  \n\t\tstruct uac3_insertion_ctl_blk uac3_conn;\n\n\t\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), UAC2_CS_CUR,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t\t      validx, idx, &uac3_conn, sizeof(uac3_conn));\n\t\tif (val)\n\t\t\t*val = !!uac3_conn.bmConInserted;\n\t}\n\n\tsnd_usb_unlock_shutdown(chip);\n\n\tif (ret < 0) {\n\t\tif (name && strstr(name, \"Speaker\")) {\n\t\t\tif (val)\n\t\t\t\t*val = 1;\n\t\t\treturn 0;\n\t\t}\nerror:\n\t\tusb_audio_err(chip,\n\t\t\t\"cannot get connectors status: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\t\tUAC_GET_CUR, validx, idx, cval->val_type);\n\n\t\tif (val)\n\t\t\t*val = 0;\n\n\t\treturn filter_error(cval, ret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mixer_ctl_connector_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint ret, val;\n\n\tret = get_connector_value(cval, kcontrol->id.name, &val);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new usb_feature_unit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",  \n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = mixer_ctl_feature_put,\n};\n\n \nstatic const struct snd_kcontrol_new usb_feature_unit_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",  \n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = NULL,\n};\n\n \nstatic const struct snd_kcontrol_new usb_bool_master_control_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"\",  \n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = mixer_ctl_master_bool_get,\n\t.put = NULL,\n};\n\nstatic const struct snd_kcontrol_new usb_connector_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"\",  \n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = mixer_ctl_connector_get,\n\t.put = NULL,\n};\n\n \nconst struct snd_kcontrol_new *snd_usb_feature_unit_ctl = &usb_feature_unit_ctl;\n\n \nstatic size_t append_ctl_name(struct snd_kcontrol *kctl, const char *str)\n{\n\treturn strlcat(kctl->id.name, str, sizeof(kctl->id.name));\n}\n\n \nstatic void check_no_speaker_on_headset(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_card *card)\n{\n\tstatic const char * const names_to_check[] = {\n\t\t\"Headset\", \"headset\", \"Headphone\", \"headphone\", NULL};\n\tconst char * const *s;\n\tbool found = false;\n\n\tif (strcmp(\"Speaker\", kctl->id.name))\n\t\treturn;\n\n\tfor (s = names_to_check; *s; s++)\n\t\tif (strstr(card->shortname, *s)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found)\n\t\treturn;\n\n\tsnd_ctl_rename(card, kctl, \"Headphone\");\n}\n\nstatic const struct usb_feature_control_info *get_feature_control_info(int control)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(audio_feature_info); ++i) {\n\t\tif (audio_feature_info[i].control == control)\n\t\t\treturn &audio_feature_info[i];\n\t}\n\treturn NULL;\n}\n\nstatic void __build_feature_ctl(struct usb_mixer_interface *mixer,\n\t\t\t\tconst struct usbmix_name_map *imap,\n\t\t\t\tunsigned int ctl_mask, int control,\n\t\t\t\tstruct usb_audio_term *iterm,\n\t\t\t\tstruct usb_audio_term *oterm,\n\t\t\t\tint unitid, int nameid, int readonly_mask)\n{\n\tconst struct usb_feature_control_info *ctl_info;\n\tunsigned int len = 0;\n\tint mapped_name = 0;\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *cval;\n\tconst struct usbmix_name_map *map;\n\tunsigned int range;\n\n\tif (control == UAC_FU_GRAPHIC_EQUALIZER) {\n\t\t \n\t\treturn;\n\t}\n\n\tmap = find_map(imap, unitid, control);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\tsnd_usb_mixer_elem_init_std(&cval->head, mixer, unitid);\n\tcval->control = control;\n\tcval->cmask = ctl_mask;\n\n\tctl_info = get_feature_control_info(control);\n\tif (!ctl_info) {\n\t\tusb_mixer_elem_info_free(cval);\n\t\treturn;\n\t}\n\tif (mixer->protocol == UAC_VERSION_1)\n\t\tcval->val_type = ctl_info->type;\n\telse  \n\t\tcval->val_type = ctl_info->type_uac2 >= 0 ?\n\t\t\tctl_info->type_uac2 : ctl_info->type;\n\n\tif (ctl_mask == 0) {\n\t\tcval->channels = 1;\t \n\t\tcval->master_readonly = readonly_mask;\n\t} else {\n\t\tint i, c = 0;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (ctl_mask & (1 << i))\n\t\t\t\tc++;\n\t\tcval->channels = c;\n\t\tcval->ch_readonly = readonly_mask;\n\t}\n\n\t \n\tif (cval->channels == readonly_mask)\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\n\telse\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\n\tif (!kctl) {\n\t\tusb_audio_err(mixer->chip, \"cannot malloc kcontrol\\n\");\n\t\tusb_mixer_elem_info_free(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tmapped_name = len != 0;\n\tif (!len && nameid)\n\t\tlen = snd_usb_copy_string_desc(mixer->chip, nameid,\n\t\t\t\tkctl->id.name, sizeof(kctl->id.name));\n\n\tswitch (control) {\n\tcase UAC_FU_MUTE:\n\tcase UAC_FU_VOLUME:\n\t\t \n\t\tif (!len) {\n\t\t\tif (iterm)\n\t\t\t\tlen = get_term_name(mixer->chip, iterm,\n\t\t\t\t\t\t    kctl->id.name,\n\t\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len && oterm)\n\t\t\t\tlen = get_term_name(mixer->chip, oterm,\n\t\t\t\t\t\t    kctl->id.name,\n\t\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len)\n\t\t\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t\t\t \"Feature %d\", unitid);\n\t\t}\n\n\t\tif (!mapped_name)\n\t\t\tcheck_no_speaker_on_headset(kctl, mixer->chip->card);\n\n\t\t \n\t\tif (!mapped_name && oterm && !(oterm->type >> 16)) {\n\t\t\tif ((oterm->type & 0xff00) == 0x0100)\n\t\t\t\tappend_ctl_name(kctl, \" Capture\");\n\t\t\telse\n\t\t\t\tappend_ctl_name(kctl, \" Playback\");\n\t\t}\n\t\tappend_ctl_name(kctl, control == UAC_FU_MUTE ?\n\t\t\t\t\" Switch\" : \" Volume\");\n\t\tbreak;\n\tdefault:\n\t\tif (!len)\n\t\t\tstrscpy(kctl->id.name, audio_feature_info[control-1].name,\n\t\t\t\tsizeof(kctl->id.name));\n\t\tbreak;\n\t}\n\n\t \n\tget_min_max_with_quirks(cval, 0, kctl);\n\n\t \n\tif (cval->max <= cval->min) {\n\t\tusb_audio_dbg(mixer->chip,\n\t\t\t      \"[%d] FU [%s] skipped due to invalid volume\\n\",\n\t\t\t      cval->head.id, kctl->id.name);\n\t\tsnd_ctl_free_one(kctl);\n\t\treturn;\n\t}\n\n\n\tif (control == UAC_FU_VOLUME) {\n\t\tcheck_mapped_dB(map, cval);\n\t\tif (cval->dBmin < cval->dBmax || !cval->initialized) {\n\t\t\tkctl->tlv.c = snd_usb_mixer_vol_tlv;\n\t\t\tkctl->vd[0].access |=\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t\t}\n\t}\n\n\tsnd_usb_mixer_fu_apply_quirk(mixer, cval, unitid, kctl);\n\n\trange = (cval->max - cval->min) / cval->res;\n\t \n\tif (range > 384) {\n\t\tusb_audio_warn(mixer->chip,\n\t\t\t       \"Warning! Unlikely big volume range (=%u), cval->res is probably wrong.\",\n\t\t\t       range);\n\t\tusb_audio_warn(mixer->chip,\n\t\t\t       \"[%d] FU [%s] ch = %d, val = %d/%d/%d\",\n\t\t\t       cval->head.id, kctl->id.name, cval->channels,\n\t\t\t       cval->min, cval->max, cval->res);\n\t}\n\n\tusb_audio_dbg(mixer->chip, \"[%d] FU [%s] ch = %d, val = %d/%d/%d\\n\",\n\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t      cval->min, cval->max, cval->res);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic void build_feature_ctl(struct mixer_build *state, void *raw_desc,\n\t\t\t      unsigned int ctl_mask, int control,\n\t\t\t      struct usb_audio_term *iterm, int unitid,\n\t\t\t      int readonly_mask)\n{\n\tstruct uac_feature_unit_descriptor *desc = raw_desc;\n\tint nameid = uac_feature_unit_iFeature(desc);\n\n\t__build_feature_ctl(state->mixer, state->map, ctl_mask, control,\n\t\t\titerm, &state->oterm, unitid, nameid, readonly_mask);\n}\n\nstatic void build_feature_ctl_badd(struct usb_mixer_interface *mixer,\n\t\t\t      unsigned int ctl_mask, int control, int unitid,\n\t\t\t      const struct usbmix_name_map *badd_map)\n{\n\t__build_feature_ctl(mixer, badd_map, ctl_mask, control,\n\t\t\tNULL, NULL, unitid, 0, 0);\n}\n\nstatic void get_connector_control_name(struct usb_mixer_interface *mixer,\n\t\t\t\t       struct usb_audio_term *term,\n\t\t\t\t       bool is_input, char *name, int name_size)\n{\n\tint name_len = get_term_name(mixer->chip, term, name, name_size, 0);\n\n\tif (name_len == 0)\n\t\tstrscpy(name, \"Unknown\", name_size);\n\n\t \n\tif (is_input)\n\t\tstrlcat(name, \" - Input Jack\", name_size);\n\telse\n\t\tstrlcat(name, \" - Output Jack\", name_size);\n}\n\n \nstatic int connector_mixer_resume(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = mixer_elem_list_to_info(list);\n\n\tget_connector_value(cval, NULL, NULL);\n\treturn 0;\n}\n\n \nstatic void build_connector_control(struct usb_mixer_interface *mixer,\n\t\t\t\t    const struct usbmix_name_map *imap,\n\t\t\t\t    struct usb_audio_term *term, bool is_input)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *cval;\n\tconst struct usbmix_name_map *map;\n\n\tmap = find_map(imap, term->id, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\tsnd_usb_mixer_elem_init_std(&cval->head, mixer, term->id);\n\n\t \n\tcval->head.resume = connector_mixer_resume;\n\n\t \n\tif (mixer->protocol == UAC_VERSION_2)\n\t\tcval->control = UAC2_TE_CONNECTOR;\n\telse  \n\t\tcval->control = UAC3_TE_INSERTION;\n\n\tcval->val_type = USB_MIXER_BOOLEAN;\n\tcval->channels = 1;  \n\tcval->min = 0;\n\tcval->max = 1;\n\tkctl = snd_ctl_new1(&usb_connector_ctl_ro, cval);\n\tif (!kctl) {\n\t\tusb_audio_err(mixer->chip, \"cannot malloc kcontrol\\n\");\n\t\tusb_mixer_elem_info_free(cval);\n\t\treturn;\n\t}\n\n\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name)))\n\t\tstrlcat(kctl->id.name, \" Jack\", sizeof(kctl->id.name));\n\telse\n\t\tget_connector_control_name(mixer, term, is_input, kctl->id.name,\n\t\t\t\t\t   sizeof(kctl->id.name));\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int parse_clock_source_unit(struct mixer_build *state, int unitid,\n\t\t\t\t   void *_ftr)\n{\n\tstruct uac_clock_source_descriptor *hdr = _ftr;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tif (state->mixer->protocol != UAC_VERSION_2)\n\t\treturn -EINVAL;\n\n\t \n\tif (!uac_v2v3_control_is_readable(hdr->bmControls,\n\t\t\t\t      UAC2_CS_CONTROL_CLOCK_VALID))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, hdr->bClockID);\n\n\tcval->min = 0;\n\tcval->max = 1;\n\tcval->channels = 1;\n\tcval->val_type = USB_MIXER_BOOLEAN;\n\tcval->control = UAC2_CS_CONTROL_CLOCK_VALID;\n\n\tcval->master_readonly = 1;\n\t \n\tkctl = snd_ctl_new1(&usb_bool_master_control_ctl_ro, cval);\n\n\tif (!kctl) {\n\t\tusb_mixer_elem_info_free(cval);\n\t\treturn -ENOMEM;\n\t}\n\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\tret = snd_usb_copy_string_desc(state->chip, hdr->iClockSource,\n\t\t\t\t       kctl->id.name, sizeof(kctl->id.name));\n\tif (ret > 0)\n\t\tappend_ctl_name(kctl, \" Validity\");\n\telse\n\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t \"Clock Source %d Validity\", hdr->bClockID);\n\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n \nstatic int parse_audio_feature_unit(struct mixer_build *state, int unitid,\n\t\t\t\t    void *_ftr)\n{\n\tint channels, i, j;\n\tstruct usb_audio_term iterm;\n\tunsigned int master_bits;\n\tint err, csize;\n\tstruct uac_feature_unit_descriptor *hdr = _ftr;\n\t__u8 *bmaControls;\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\tcsize = hdr->bControlSize;\n\t\tchannels = (hdr->bLength - 7) / csize - 1;\n\t\tbmaControls = hdr->bmaControls;\n\t} else if (state->mixer->protocol == UAC_VERSION_2) {\n\t\tstruct uac2_feature_unit_descriptor *ftr = _ftr;\n\t\tcsize = 4;\n\t\tchannels = (hdr->bLength - 6) / 4 - 1;\n\t\tbmaControls = ftr->bmaControls;\n\t} else {  \n\t\tstruct uac3_feature_unit_descriptor *ftr = _ftr;\n\n\t\tcsize = 4;\n\t\tchannels = (ftr->bLength - 7) / 4 - 1;\n\t\tbmaControls = ftr->bmaControls;\n\t}\n\n\t \n\terr = parse_audio_unit(state, hdr->bSourceID);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = check_input_term(state, hdr->bSourceID, &iterm);\n\tif (err < 0)\n\t\treturn err;\n\n\tmaster_bits = snd_usb_combine_bytes(bmaControls, csize);\n\t \n\tswitch (state->chip->usb_id) {\n\tcase USB_ID(0x08bb, 0x2702):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: master volume quirk for PCM2702 chip\\n\");\n\t\t \n\t\tmaster_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);\n\t\tbreak;\n\tcase USB_ID(0x1130, 0xf211):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: volume control quirk for Tenx TP6911 Audio Headset\\n\");\n\t\t \n\t\tchannels = 0;\n\t\tbreak;\n\n\t}\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t \n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tint control = audio_feature_info[i].control;\n\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (mask & (1 << i))\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t}\n\t\t\t \n\n\t\t\t \n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, control,\n\t\t\t\t\t\t  &iterm, unitid, 0);\n\t\t\tif (master_bits & (1 << i))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, control,\n\t\t\t\t\t\t  &iterm, unitid, 0);\n\t\t}\n\t} else {  \n\t\tfor (i = 0; i < ARRAY_SIZE(audio_feature_info); i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tunsigned int ch_read_only = 0;\n\t\t\tint control = audio_feature_info[i].control;\n\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (uac_v2v3_control_is_readable(mask, control)) {\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t\t\tif (!uac_v2v3_control_is_writeable(mask, control))\n\t\t\t\t\t\tch_read_only |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, control,\n\t\t\t\t\t\t  &iterm, unitid, ch_read_only);\n\t\t\tif (uac_v2v3_control_is_readable(master_bits, control))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, control,\n\t\t\t\t\t\t  &iterm, unitid,\n\t\t\t\t\t\t  !uac_v2v3_control_is_writeable(master_bits,\n\t\t\t\t\t\t\t\t\t\t control));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic bool mixer_bitmap_overflow(struct uac_mixer_unit_descriptor *desc,\n\t\t\t\t  int protocol, int num_ins, int num_outs)\n{\n\tu8 *hdr = (u8 *)desc;\n\tu8 *c = uac_mixer_unit_bmControls(desc, protocol);\n\tsize_t rest;  \n\n\tswitch (protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\trest = 1;  \n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\trest = 2;  \n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\trest = 6;  \n\t\tbreak;\n\t}\n\n\t \n\treturn c + (num_ins * num_outs + 7) / 8 + rest > hdr + hdr[0];\n}\n\n \nstatic void build_mixer_unit_ctl(struct mixer_build *state,\n\t\t\t\t struct uac_mixer_unit_descriptor *desc,\n\t\t\t\t int in_pin, int in_ch, int num_outs,\n\t\t\t\t int unitid, struct usb_audio_term *iterm)\n{\n\tstruct usb_mixer_elem_info *cval;\n\tunsigned int i, len;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\n\tmap = find_map(state->map, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->control = in_ch + 1;  \n\tcval->val_type = USB_MIXER_S16;\n\tfor (i = 0; i < num_outs; i++) {\n\t\t__u8 *c = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (check_matrix_bitmap(c, in_ch, i, num_outs)) {\n\t\t\tcval->cmask |= (1 << i);\n\t\t\tcval->channels++;\n\t\t}\n\t}\n\n\t \n\tget_min_max(cval, 0);\n\n\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\tif (!kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tusb_mixer_elem_info_free(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (!len)\n\t\tlen = get_term_name(state->chip, iterm, kctl->id.name,\n\t\t\t\t    sizeof(kctl->id.name), 0);\n\tif (!len)\n\t\tlen = sprintf(kctl->id.name, \"Mixer Source %d\", in_ch + 1);\n\tappend_ctl_name(kctl, \" Volume\");\n\n\tusb_audio_dbg(state->chip, \"[%d] MU [%s] ch = %d, val = %d/%d\\n\",\n\t\t    cval->head.id, kctl->id.name, cval->channels, cval->min, cval->max);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int parse_audio_input_terminal(struct mixer_build *state, int unitid,\n\t\t\t\t      void *raw_desc)\n{\n\tstruct usb_audio_term iterm;\n\tunsigned int control, bmctls, term_id;\n\n\tif (state->mixer->protocol == UAC_VERSION_2) {\n\t\tstruct uac2_input_terminal_descriptor *d_v2 = raw_desc;\n\t\tcontrol = UAC2_TE_CONNECTOR;\n\t\tterm_id = d_v2->bTerminalID;\n\t\tbmctls = le16_to_cpu(d_v2->bmControls);\n\t} else if (state->mixer->protocol == UAC_VERSION_3) {\n\t\tstruct uac3_input_terminal_descriptor *d_v3 = raw_desc;\n\t\tcontrol = UAC3_TE_INSERTION;\n\t\tterm_id = d_v3->bTerminalID;\n\t\tbmctls = le32_to_cpu(d_v3->bmControls);\n\t} else {\n\t\treturn 0;  \n\t}\n\n\tcheck_input_term(state, term_id, &iterm);\n\n\t \n\tif ((iterm.type & 0xff00) != 0x0100 &&\n\t    uac_v2v3_control_is_readable(bmctls, control))\n\t\tbuild_connector_control(state->mixer, state->map, &iterm, true);\n\n\treturn 0;\n}\n\n \nstatic int parse_audio_mixer_unit(struct mixer_build *state, int unitid,\n\t\t\t\t  void *raw_desc)\n{\n\tstruct uac_mixer_unit_descriptor *desc = raw_desc;\n\tstruct usb_audio_term iterm;\n\tint input_pins, num_ins, num_outs;\n\tint pin, ich, err;\n\n\terr = uac_mixer_unit_get_channels(state, desc);\n\tif (err < 0) {\n\t\tusb_audio_err(state->chip,\n\t\t\t      \"invalid MIXER UNIT descriptor %d\\n\",\n\t\t\t      unitid);\n\t\treturn err;\n\t}\n\n\tnum_outs = err;\n\tinput_pins = desc->bNrInPins;\n\n\tnum_ins = 0;\n\tich = 0;\n\tfor (pin = 0; pin < input_pins; pin++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[pin]);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t\t \n\t\tif (!num_outs)\n\t\t\tcontinue;\n\t\terr = check_input_term(state, desc->baSourceID[pin], &iterm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnum_ins += iterm.channels;\n\t\tif (mixer_bitmap_overflow(desc, state->mixer->protocol,\n\t\t\t\t\t  num_ins, num_outs))\n\t\t\tbreak;\n\t\tfor (; ich < num_ins; ich++) {\n\t\t\tint och, ich_has_controls = 0;\n\n\t\t\tfor (och = 0; och < num_outs; och++) {\n\t\t\t\t__u8 *c = uac_mixer_unit_bmControls(desc,\n\t\t\t\t\t\tstate->mixer->protocol);\n\n\t\t\t\tif (check_matrix_bitmap(c, ich, och, num_outs)) {\n\t\t\t\t\tich_has_controls = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ich_has_controls)\n\t\t\t\tbuild_mixer_unit_ctl(state, desc, pin, ich, num_outs,\n\t\t\t\t\t\t     unitid, &iterm);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint err, val;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.integer.value[0] = cval->min;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\n \nstatic int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.integer.value[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct snd_kcontrol_new mixer_procunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",  \n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_procunit_get,\n\t.put = mixer_ctl_procunit_put,\n};\n\n \nstruct procunit_value_info {\n\tint control;\n\tconst char *suffix;\n\tint val_type;\n\tint min_value;\n};\n\nstruct procunit_info {\n\tint type;\n\tchar *name;\n\tconst struct procunit_value_info *values;\n};\n\nstatic const struct procunit_value_info undefined_proc_info[] = {\n\t{ 0x00, \"Control Undefined\", 0 },\n\t{ 0 }\n};\n\nstatic const struct procunit_value_info updown_proc_info[] = {\n\t{ UAC_UD_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_UD_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info prologic_proc_info[] = {\n\t{ UAC_DP_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DP_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info threed_enh_proc_info[] = {\n\t{ UAC_3D_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_3D_SPACE, \"Spaciousness\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info reverb_proc_info[] = {\n\t{ UAC_REVERB_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_REVERB_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_REVERB_TIME, \"Time\", USB_MIXER_U16 },\n\t{ UAC_REVERB_FEEDBACK, \"Feedback\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info chorus_proc_info[] = {\n\t{ UAC_CHORUS_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_CHORUS_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_CHORUS_RATE, \"Rate\", USB_MIXER_U16 },\n\t{ UAC_CHORUS_DEPTH, \"Depth\", USB_MIXER_U16 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info dcr_proc_info[] = {\n\t{ UAC_DCR_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DCR_RATE, \"Ratio\", USB_MIXER_U16 },\n\t{ UAC_DCR_MAXAMPL, \"Max Amp\", USB_MIXER_S16 },\n\t{ UAC_DCR_THRESHOLD, \"Threshold\", USB_MIXER_S16 },\n\t{ UAC_DCR_ATTACK_TIME, \"Attack Time\", USB_MIXER_U16 },\n\t{ UAC_DCR_RELEASE_TIME, \"Release Time\", USB_MIXER_U16 },\n\t{ 0 }\n};\n\nstatic const struct procunit_info procunits[] = {\n\t{ UAC_PROCESS_UP_DOWNMIX, \"Up Down\", updown_proc_info },\n\t{ UAC_PROCESS_DOLBY_PROLOGIC, \"Dolby Prologic\", prologic_proc_info },\n\t{ UAC_PROCESS_STEREO_EXTENDER, \"3D Stereo Extender\", threed_enh_proc_info },\n\t{ UAC_PROCESS_REVERB, \"Reverb\", reverb_proc_info },\n\t{ UAC_PROCESS_CHORUS, \"Chorus\", chorus_proc_info },\n\t{ UAC_PROCESS_DYN_RANGE_COMP, \"DCR\", dcr_proc_info },\n\t{ 0 },\n};\n\nstatic const struct procunit_value_info uac3_updown_proc_info[] = {\n\t{ UAC3_UD_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info uac3_stereo_ext_proc_info[] = {\n\t{ UAC3_EXT_WIDTH_CONTROL, \"Width Control\", USB_MIXER_U8 },\n\t{ 0 }\n};\n\nstatic const struct procunit_info uac3_procunits[] = {\n\t{ UAC3_PROCESS_UP_DOWNMIX, \"Up Down\", uac3_updown_proc_info },\n\t{ UAC3_PROCESS_STEREO_EXTENDER, \"3D Stereo Extender\", uac3_stereo_ext_proc_info },\n\t{ UAC3_PROCESS_MULTI_FUNCTION, \"Multi-Function\", undefined_proc_info },\n\t{ 0 },\n};\n\n \nstatic const struct procunit_value_info clock_rate_xu_info[] = {\n\t{ USB_XU_CLOCK_RATE_SELECTOR, \"Selector\", USB_MIXER_U8, 0 },\n\t{ 0 }\n};\nstatic const struct procunit_value_info clock_source_xu_info[] = {\n\t{ USB_XU_CLOCK_SOURCE_SELECTOR, \"External\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic const struct procunit_value_info spdif_format_xu_info[] = {\n\t{ USB_XU_DIGITAL_FORMAT_SELECTOR, \"SPDIF/AC3\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic const struct procunit_value_info soft_limit_xu_info[] = {\n\t{ USB_XU_SOFT_LIMIT_SELECTOR, \" \", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic const struct procunit_info extunits[] = {\n\t{ USB_XU_CLOCK_RATE, \"Clock rate\", clock_rate_xu_info },\n\t{ USB_XU_CLOCK_SOURCE, \"DigitalIn CLK source\", clock_source_xu_info },\n\t{ USB_XU_DIGITAL_IO_STATUS, \"DigitalOut format:\", spdif_format_xu_info },\n\t{ USB_XU_DEVICE_OPTIONS, \"AnalogueIn Soft Limit\", soft_limit_xu_info },\n\t{ 0 }\n};\n\n \nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, const struct procunit_info *list,\n\t\t\t\tbool extension_unit)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len, val;\n\tconst struct procunit_info *info;\n\tconst struct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic const struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic const struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\tconst char *name = extension_unit ?\n\t\t\"Extension Unit\" : \"Processing Unit\";\n\n\tnum_ins = desc->bNrInPins;\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else {  \n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t \n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t \n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\t\tif (err < 0) {\n\t\t\tusb_mixer_elem_info_free(cval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tusb_mixer_elem_info_free(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t  ;\n\t\t} else if (info->name) {\n\t\t\tstrscpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tif (extension_unit)\n\t\t\t\tnameid = uac_extension_unit_iExtension(desc, state->mixer->protocol);\n\t\t\telse\n\t\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrscpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int parse_audio_processing_unit(struct mixer_build *state, int unitid,\n\t\t\t\t       void *raw_desc)\n{\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t\t    procunits, false);\n\tcase UAC_VERSION_3:\n\t\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t\t    uac3_procunits, false);\n\t}\n}\n\nstatic int parse_audio_extension_unit(struct mixer_build *state, int unitid,\n\t\t\t\t      void *raw_desc)\n{\n\t \n\treturn build_audio_procunit(state, unitid, raw_desc, extunits, true);\n}\n\n \n\n \nstatic int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tconst char **itemlist = (const char **)kcontrol->private_value;\n\n\tif (snd_BUG_ON(!itemlist))\n\t\treturn -EINVAL;\n\treturn snd_ctl_enum_info(uinfo, 1, cval->max, itemlist);\n}\n\n \nstatic int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\n \nstatic int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.enumerated.item[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct snd_kcontrol_new mixer_selectunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",  \n\t.info = mixer_ctl_selector_info,\n\t.get = mixer_ctl_selector_get,\n\t.put = mixer_ctl_selector_put,\n};\n\n \nstatic void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl)\n{\n\tint i, num_ins = 0;\n\n\tif (kctl->private_data) {\n\t\tstruct usb_mixer_elem_info *cval = kctl->private_data;\n\t\tnum_ins = cval->max;\n\t\tusb_mixer_elem_info_free(cval);\n\t\tkctl->private_data = NULL;\n\t}\n\tif (kctl->private_value) {\n\t\tchar **itemlist = (char **)kctl->private_value;\n\t\tfor (i = 0; i < num_ins; i++)\n\t\t\tkfree(itemlist[i]);\n\t\tkfree(itemlist);\n\t\tkctl->private_value = 0;\n\t}\n}\n\n \nstatic int parse_audio_selector_unit(struct mixer_build *state, int unitid,\n\t\t\t\t     void *raw_desc)\n{\n\tstruct uac_selector_unit_descriptor *desc = raw_desc;\n\tunsigned int i, nameid, len;\n\tint err;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\tchar **namelist;\n\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (desc->bNrInPins == 1)  \n\t\treturn 0;\n\n\tmap = find_map(state->map, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->val_type = USB_MIXER_U8;\n\tcval->channels = 1;\n\tcval->min = 1;\n\tcval->max = desc->bNrInPins;\n\tcval->res = 1;\n\tcval->initialized = 1;\n\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tcval->control = 0;\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3:\n\t\tif (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR ||\n\t\t    desc->bDescriptorSubtype == UAC3_CLOCK_SELECTOR)\n\t\t\tcval->control = UAC2_CX_CLOCK_SELECTOR;\n\t\telse  \n\t\t\tcval->control = UAC2_SU_SELECTOR;\n\t\tbreak;\n\t}\n\n\tnamelist = kcalloc(desc->bNrInPins, sizeof(char *), GFP_KERNEL);\n\tif (!namelist) {\n\t\terr = -ENOMEM;\n\t\tgoto error_cval;\n\t}\n#define MAX_ITEM_NAME_LEN\t64\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\tstruct usb_audio_term iterm;\n\t\tnamelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);\n\t\tif (!namelist[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_name;\n\t\t}\n\t\tlen = check_mapped_selector_name(state, unitid, i, namelist[i],\n\t\t\t\t\t\t MAX_ITEM_NAME_LEN);\n\t\tif (! len && check_input_term(state, desc->baSourceID[i], &iterm) >= 0)\n\t\t\tlen = get_term_name(state->chip, &iterm, namelist[i],\n\t\t\t\t\t    MAX_ITEM_NAME_LEN, 0);\n\t\tif (! len)\n\t\t\tsprintf(namelist[i], \"Input %u\", i);\n\t}\n\n\tkctl = snd_ctl_new1(&mixer_selectunit_ctl, cval);\n\tif (! kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto error_name;\n\t}\n\tkctl->private_value = (unsigned long)namelist;\n\tkctl->private_free = usb_mixer_selector_elem_free;\n\n\t \n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (!len) {\n\t\t \n\t\tswitch (state->mixer->protocol) {\n\t\tcase UAC_VERSION_1:\n\t\tcase UAC_VERSION_2:\n\t\tdefault:\n\t\t \n\t\t\tnameid = uac_selector_unit_iSelector(desc);\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\tnameid, kctl->id.name,\n\t\t\t\t\t\t\tsizeof(kctl->id.name));\n\t\t\tbreak;\n\t\tcase UAC_VERSION_3:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!len)\n\t\t\tlen = get_term_name(state->chip, &state->oterm,\n\t\t\t\t    kctl->id.name, sizeof(kctl->id.name), 0);\n\t\t \n\t\tif (!len)\n\t\t\tstrscpy(kctl->id.name, \"USB\", sizeof(kctl->id.name));\n\n\t\t \n\t\tif (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR ||\n\t\t    desc->bDescriptorSubtype == UAC3_CLOCK_SELECTOR)\n\t\t\tappend_ctl_name(kctl, \" Clock Source\");\n\t\telse if ((state->oterm.type & 0xff00) == 0x0100)\n\t\t\tappend_ctl_name(kctl, \" Capture Source\");\n\t\telse\n\t\t\tappend_ctl_name(kctl, \" Playback Source\");\n\t}\n\n\tusb_audio_dbg(state->chip, \"[%d] SU [%s] items = %d\\n\",\n\t\t    cval->head.id, kctl->id.name, desc->bNrInPins);\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n\n error_name:\n\tfor (i = 0; i < desc->bNrInPins; i++)\n\t\tkfree(namelist[i]);\n\tkfree(namelist);\n error_cval:\n\tusb_mixer_elem_info_free(cval);\n\treturn err;\n}\n\n \n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid)\n{\n\tunsigned char *p1;\n\tint protocol = state->mixer->protocol;\n\n\tif (test_and_set_bit(unitid, state->unitbitmap))\n\t\treturn 0;  \n\n\tp1 = find_audio_control_unit(state, unitid);\n\tif (!p1) {\n\t\tusb_audio_err(state->chip, \"unit %d not found!\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!snd_usb_validate_audio_desc(p1, protocol)) {\n\t\tusb_audio_dbg(state->chip, \"invalid unit %d\\n\", unitid);\n\t\treturn 0;  \n\t}\n\n\tswitch (PTYPE(protocol, p1[2])) {\n\tcase PTYPE(UAC_VERSION_1, UAC_INPUT_TERMINAL):\n\tcase PTYPE(UAC_VERSION_2, UAC_INPUT_TERMINAL):\n\tcase PTYPE(UAC_VERSION_3, UAC_INPUT_TERMINAL):\n\t\treturn parse_audio_input_terminal(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_1, UAC_MIXER_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC_MIXER_UNIT):\n\tcase PTYPE(UAC_VERSION_3, UAC3_MIXER_UNIT):\n\t\treturn parse_audio_mixer_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_2, UAC2_CLOCK_SOURCE):\n\tcase PTYPE(UAC_VERSION_3, UAC3_CLOCK_SOURCE):\n\t\treturn parse_clock_source_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_1, UAC_SELECTOR_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC_SELECTOR_UNIT):\n\tcase PTYPE(UAC_VERSION_3, UAC3_SELECTOR_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC2_CLOCK_SELECTOR):\n\tcase PTYPE(UAC_VERSION_3, UAC3_CLOCK_SELECTOR):\n\t\treturn parse_audio_selector_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_1, UAC_FEATURE_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC_FEATURE_UNIT):\n\tcase PTYPE(UAC_VERSION_3, UAC3_FEATURE_UNIT):\n\t\treturn parse_audio_feature_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_1, UAC1_PROCESSING_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC2_PROCESSING_UNIT_V2):\n\tcase PTYPE(UAC_VERSION_3, UAC3_PROCESSING_UNIT):\n\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_1, UAC1_EXTENSION_UNIT):\n\tcase PTYPE(UAC_VERSION_2, UAC2_EXTENSION_UNIT_V2):\n\tcase PTYPE(UAC_VERSION_3, UAC3_EXTENSION_UNIT):\n\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\tcase PTYPE(UAC_VERSION_2, UAC2_EFFECT_UNIT):\n\tcase PTYPE(UAC_VERSION_3, UAC3_EFFECT_UNIT):\n\t\treturn 0;  \n\tdefault:\n\t\tusb_audio_err(state->chip,\n\t\t\t      \"unit %u: unexpected type 0x%02x\\n\",\n\t\t\t      unitid, p1[2]);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\t \n\tsnd_usb_mixer_disconnect(mixer);\n\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}\n\nstatic int snd_usb_mixer_dev_free(struct snd_device *device)\n{\n\tstruct usb_mixer_interface *mixer = device->device_data;\n\tsnd_usb_mixer_free(mixer);\n\treturn 0;\n}\n\n \nstruct uac3_badd_profile {\n\tint subclass;\n\tconst char *name;\n\tint c_chmask;\t \n\tint p_chmask;\t \n\tint st_chmask;\t \n};\n\nstatic const struct uac3_badd_profile uac3_badd_profiles[] = {\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_GENERIC_IO,\n\t\t.name = \"GENERIC IO\",\n\t\t.c_chmask = -1,\t\t \n\t\t.p_chmask = -1,\t\t \n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_HEADPHONE,\n\t\t.name = \"HEADPHONE\",\n\t\t.p_chmask = 3,\n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_SPEAKER,\n\t\t.name = \"SPEAKER\",\n\t\t.p_chmask = -1,\t\t \n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_MICROPHONE,\n\t\t.name = \"MICROPHONE\",\n\t\t.c_chmask = -1,\t\t \n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_HEADSET,\n\t\t.name = \"HEADSET\",\n\t\t.c_chmask = 1,\n\t\t.p_chmask = -1,\t\t \n\t\t.st_chmask = 1,\n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_HEADSET_ADAPTER,\n\t\t.name = \"HEADSET ADAPTER\",\n\t\t.c_chmask = 1,\n\t\t.p_chmask = 3,\n\t\t.st_chmask = 1,\n\t},\n\t{\n\t\t \n\t\t.subclass = UAC3_FUNCTION_SUBCLASS_SPEAKERPHONE,\n\t\t.name = \"SPEAKERPHONE\",\n\t\t.c_chmask = 1,\n\t\t.p_chmask = 1,\n\t},\n\t{ 0 }  \n};\n\nstatic bool uac3_badd_func_has_valid_channels(struct usb_mixer_interface *mixer,\n\t\t\t\t\t      const struct uac3_badd_profile *f,\n\t\t\t\t\t      int c_chmask, int p_chmask)\n{\n\t \n\tif (f->c_chmask < 0 && f->p_chmask < 0) {\n\t\tif (!c_chmask && !p_chmask) {\n\t\t\tusb_audio_warn(mixer->chip, \"BAAD %s: no channels?\",\n\t\t\t\t       f->name);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tif ((f->c_chmask < 0 && !c_chmask) ||\n\t    (f->c_chmask >= 0 && f->c_chmask != c_chmask)) {\n\t\tusb_audio_warn(mixer->chip, \"BAAD %s c_chmask mismatch\",\n\t\t\t       f->name);\n\t\treturn false;\n\t}\n\tif ((f->p_chmask < 0 && !p_chmask) ||\n\t    (f->p_chmask >= 0 && f->p_chmask != p_chmask)) {\n\t\tusb_audio_warn(mixer->chip, \"BAAD %s p_chmask mismatch\",\n\t\t\t       f->name);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int snd_usb_mixer_controls_badd(struct usb_mixer_interface *mixer,\n\t\t\t\t       int ctrlif)\n{\n\tstruct usb_device *dev = mixer->chip->dev;\n\tstruct usb_interface_assoc_descriptor *assoc;\n\tint badd_profile = mixer->chip->badd_profile;\n\tconst struct uac3_badd_profile *f;\n\tconst struct usbmix_ctl_map *map;\n\tint p_chmask = 0, c_chmask = 0, st_chmask = 0;\n\tint i;\n\n\tassoc = usb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t \n\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\tint intf = assoc->bFirstInterface + i;\n\n\t\tstruct usb_interface *iface;\n\t\tstruct usb_host_interface *alts;\n\t\tstruct usb_interface_descriptor *altsd;\n\t\tunsigned int maxpacksize;\n\t\tchar dir_in;\n\t\tint chmask, num;\n\n\t\tif (intf == ctrlif)\n\t\t\tcontinue;\n\n\t\tiface = usb_ifnum_to_if(dev, intf);\n\t\tif (!iface)\n\t\t\tcontinue;\n\n\t\tnum = iface->num_altsetting;\n\n\t\tif (num < 2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\talts = &iface->altsetting[1];\n\t\taltsd = get_iface_desc(alts);\n\n\t\tif (altsd->bNumEndpoints < 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tdir_in = (get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN);\n\t\tmaxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\n\t\tswitch (maxpacksize) {\n\t\tdefault:\n\t\t\tusb_audio_err(mixer->chip,\n\t\t\t\t\"incorrect wMaxPacketSize 0x%x for BADD profile\\n\",\n\t\t\t\tmaxpacksize);\n\t\t\treturn -EINVAL;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_MONO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_MONO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_MONO_24:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_MONO_24:\n\t\t\tchmask = 1;\n\t\t\tbreak;\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_STEREO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_STEREO_16:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_SYNC_STEREO_24:\n\t\tcase UAC3_BADD_EP_MAXPSIZE_ASYNC_STEREO_24:\n\t\t\tchmask = 3;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dir_in)\n\t\t\tc_chmask = chmask;\n\t\telse\n\t\t\tp_chmask = chmask;\n\t}\n\n\tusb_audio_dbg(mixer->chip,\n\t\t\"UAC3 BADD profile 0x%x: detected c_chmask=%d p_chmask=%d\\n\",\n\t\tbadd_profile, c_chmask, p_chmask);\n\n\t \n\tfor (map = uac3_badd_usbmix_ctl_maps; map->id; map++) {\n\t\tif (map->id == badd_profile)\n\t\t\tbreak;\n\t}\n\n\tif (!map->id)\n\t\treturn -EINVAL;\n\n\tfor (f = uac3_badd_profiles; f->name; f++) {\n\t\tif (badd_profile == f->subclass)\n\t\t\tbreak;\n\t}\n\tif (!f->name)\n\t\treturn -EINVAL;\n\tif (!uac3_badd_func_has_valid_channels(mixer, f, c_chmask, p_chmask))\n\t\treturn -EINVAL;\n\tst_chmask = f->st_chmask;\n\n\t \n\tif (p_chmask) {\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, 0, UAC_FU_MUTE,\n\t\t\t\t       UAC3_BADD_FU_ID2, map->map);\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, p_chmask, UAC_FU_VOLUME,\n\t\t\t\t       UAC3_BADD_FU_ID2, map->map);\n\t}\n\n\t \n\tif (c_chmask) {\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, 0, UAC_FU_MUTE,\n\t\t\t\t       UAC3_BADD_FU_ID5, map->map);\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, c_chmask, UAC_FU_VOLUME,\n\t\t\t\t       UAC3_BADD_FU_ID5, map->map);\n\t}\n\n\t \n\tif (st_chmask) {\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, 0, UAC_FU_MUTE,\n\t\t\t\t       UAC3_BADD_FU_ID7, map->map);\n\t\t \n\t\tbuild_feature_ctl_badd(mixer, 1, UAC_FU_VOLUME,\n\t\t\t\t       UAC3_BADD_FU_ID7, map->map);\n\t}\n\n\t \n\tif (f->subclass == UAC3_FUNCTION_SUBCLASS_HEADSET_ADAPTER) {\n\t\tstruct usb_audio_term iterm, oterm;\n\n\t\t \n\t\tmemset(&iterm, 0, sizeof(iterm));\n\t\titerm.id = UAC3_BADD_IT_ID4;\n\t\titerm.type = UAC_BIDIR_TERMINAL_HEADSET;\n\t\tbuild_connector_control(mixer, map->map, &iterm, true);\n\n\t\t \n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.id = UAC3_BADD_OT_ID3;\n\t\toterm.type = UAC_BIDIR_TERMINAL_HEADSET;\n\t\tbuild_connector_control(mixer, map->map, &oterm, false);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)\n{\n\tstruct mixer_build state;\n\tint err;\n\tconst struct usbmix_ctl_map *map;\n\tvoid *p;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.chip = mixer->chip;\n\tstate.mixer = mixer;\n\tstate.buffer = mixer->hostif->extra;\n\tstate.buflen = mixer->hostif->extralen;\n\n\t \n\tfor (map = usbmix_ctl_maps; map->id; map++) {\n\t\tif (map->id == state.chip->usb_id) {\n\t\t\tstate.map = map->map;\n\t\t\tstate.selector_map = map->selector_map;\n\t\t\tmixer->connector_map = map->connector_map;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = NULL;\n\twhile ((p = snd_usb_find_csint_desc(mixer->hostif->extra,\n\t\t\t\t\t    mixer->hostif->extralen,\n\t\t\t\t\t    p, UAC_OUTPUT_TERMINAL)) != NULL) {\n\t\tif (!snd_usb_validate_audio_desc(p, mixer->protocol))\n\t\t\tcontinue;  \n\n\t\tif (mixer->protocol == UAC_VERSION_1) {\n\t\t\tstruct uac1_output_terminal_descriptor *desc = p;\n\n\t\t\t \n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\t\t} else if (mixer->protocol == UAC_VERSION_2) {\n\t\t\tstruct uac2_output_terminal_descriptor *desc = p;\n\n\t\t\t \n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = parse_audio_unit(&state, desc->bCSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\tif ((state.oterm.type & 0xff00) != 0x0100 &&\n\t\t\t    uac_v2v3_control_is_readable(le16_to_cpu(desc->bmControls),\n\t\t\t\t\t\t\t UAC2_TE_CONNECTOR)) {\n\t\t\t\tbuild_connector_control(state.mixer, state.map,\n\t\t\t\t\t\t\t&state.oterm, false);\n\t\t\t}\n\t\t} else {   \n\t\t\tstruct uac3_output_terminal_descriptor *desc = p;\n\n\t\t\t \n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = le16_to_cpu(desc->wTerminalDescrStr);\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = parse_audio_unit(&state, desc->bCSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\tif ((state.oterm.type & 0xff00) != 0x0100 &&\n\t\t\t    uac_v2v3_control_is_readable(le32_to_cpu(desc->bmControls),\n\t\t\t\t\t\t\t UAC3_TE_INSERTION)) {\n\t\t\t\tbuild_connector_control(state.mixer, state.map,\n\t\t\t\t\t\t\t&state.oterm, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int delegate_notify(struct usb_mixer_interface *mixer, int unitid,\n\t\t\t   u8 *control, u8 *channel)\n{\n\tconst struct usbmix_connector_map *map = mixer->connector_map;\n\n\tif (!map)\n\t\treturn unitid;\n\n\tfor (; map->id; map++) {\n\t\tif (map->id == unitid) {\n\t\t\tif (control && map->control)\n\t\t\t\t*control = map->control;\n\t\t\tif (channel && map->channel)\n\t\t\t\t*channel = map->channel;\n\t\t\treturn map->delegated_id;\n\t\t}\n\t}\n\treturn unitid;\n}\n\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid)\n{\n\tstruct usb_mixer_elem_list *list;\n\n\tunitid = delegate_notify(mixer, unitid, NULL, NULL);\n\n\tfor_each_mixer_elem(list, mixer, unitid) {\n\t\tstruct usb_mixer_elem_info *info;\n\n\t\tif (!list->is_std_info)\n\t\t\tcontinue;\n\t\tinfo = mixer_elem_list_to_info(list);\n\t\t \n\t\tinfo->cached = 0;\n\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &list->kctl->id);\n\t}\n}\n\nstatic void snd_usb_mixer_dump_cval(struct snd_info_buffer *buffer,\n\t\t\t\t    struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = mixer_elem_list_to_info(list);\n\tstatic const char * const val_types[] = {\n\t\t[USB_MIXER_BOOLEAN] = \"BOOLEAN\",\n\t\t[USB_MIXER_INV_BOOLEAN] = \"INV_BOOLEAN\",\n\t\t[USB_MIXER_S8] = \"S8\",\n\t\t[USB_MIXER_U8] = \"U8\",\n\t\t[USB_MIXER_S16] = \"S16\",\n\t\t[USB_MIXER_U16] = \"U16\",\n\t\t[USB_MIXER_S32] = \"S32\",\n\t\t[USB_MIXER_U32] = \"U32\",\n\t\t[USB_MIXER_BESPOKEN] = \"BESPOKEN\",\n\t};\n\tsnd_iprintf(buffer, \"    Info: id=%i, control=%i, cmask=0x%x, \"\n\t\t\t    \"channels=%i, type=\\\"%s\\\"\\n\", cval->head.id,\n\t\t\t    cval->control, cval->cmask, cval->channels,\n\t\t\t    val_types[cval->val_type]);\n\tsnd_iprintf(buffer, \"    Volume: min=%i, max=%i, dBmin=%i, dBmax=%i\\n\",\n\t\t\t    cval->min, cval->max, cval->dBmin, cval->dBmax);\n}\n\nstatic void snd_usb_mixer_proc_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_usb_audio *chip = entry->private_data;\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_list *list;\n\tint unitid;\n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\tsnd_iprintf(buffer,\n\t\t\t\"USB Mixer: usb_id=0x%08x, ctrlif=%i, ctlerr=%i\\n\",\n\t\t\t\tchip->usb_id, mixer_ctrl_intf(mixer),\n\t\t\t\tmixer->ignore_ctl_error);\n\t\tsnd_iprintf(buffer, \"Card: %s\\n\", chip->card->longname);\n\t\tfor (unitid = 0; unitid < MAX_ID_ELEMS; unitid++) {\n\t\t\tfor_each_mixer_elem(list, mixer, unitid) {\n\t\t\t\tsnd_iprintf(buffer, \"  Unit: %i\\n\", list->id);\n\t\t\t\tif (list->kctl)\n\t\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t\t    \"    Control: name=\\\"%s\\\", index=%i\\n\",\n\t\t\t\t\t\t    list->kctl->id.name,\n\t\t\t\t\t\t    list->kctl->id.index);\n\t\t\t\tif (list->dump)\n\t\t\t\t\tlist->dump(buffer, list);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,\n\t\t\t\t       int attribute, int value, int index)\n{\n\tstruct usb_mixer_elem_list *list;\n\t__u8 unitid = (index >> 8) & 0xff;\n\t__u8 control = (value >> 8) & 0xff;\n\t__u8 channel = value & 0xff;\n\tunsigned int count = 0;\n\n\tif (channel >= MAX_CHANNELS) {\n\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\"%s(): bogus channel number %d\\n\",\n\t\t\t__func__, channel);\n\t\treturn;\n\t}\n\n\tunitid = delegate_notify(mixer, unitid, &control, &channel);\n\n\tfor_each_mixer_elem(list, mixer, unitid)\n\t\tcount++;\n\n\tif (count == 0)\n\t\treturn;\n\n\tfor_each_mixer_elem(list, mixer, unitid) {\n\t\tstruct usb_mixer_elem_info *info;\n\n\t\tif (!list->kctl)\n\t\t\tcontinue;\n\t\tif (!list->is_std_info)\n\t\t\tcontinue;\n\n\t\tinfo = mixer_elem_list_to_info(list);\n\t\tif (count > 1 && info->control != control)\n\t\t\tcontinue;\n\n\t\tswitch (attribute) {\n\t\tcase UAC2_CS_CUR:\n\t\t\t \n\t\t\tif (channel)\n\t\t\t\tinfo->cached &= ~(1 << channel);\n\t\t\telse  \n\t\t\t\tinfo->cached = 0;\n\n\t\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &info->head.kctl->id);\n\t\t\tbreak;\n\n\t\tcase UAC2_CS_RANGE:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase UAC2_CS_MEM:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\t\"unknown attribute %d in interrupt\\n\",\n\t\t\t\tattribute);\n\t\t\tbreak;\n\t\t}  \n\t}\n}\n\nstatic void snd_usb_mixer_interrupt(struct urb *urb)\n{\n\tstruct usb_mixer_interface *mixer = urb->context;\n\tint len = urb->actual_length;\n\tint ustatus = urb->status;\n\n\tif (ustatus != 0)\n\t\tgoto requeue;\n\n\tif (mixer->protocol == UAC_VERSION_1) {\n\t\tstruct uac1_status_word *status;\n\n\t\tfor (status = urb->transfer_buffer;\n\t\t     len >= sizeof(*status);\n\t\t     len -= sizeof(*status), status++) {\n\t\t\tdev_dbg(&urb->dev->dev, \"status interrupt: %02x %02x\\n\",\n\t\t\t\t\t\tstatus->bStatusType,\n\t\t\t\t\t\tstatus->bOriginator);\n\n\t\t\t \n\t\t\tif ((status->bStatusType & UAC1_STATUS_TYPE_ORIG_MASK) !=\n\t\t\t\tUAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF)\n\t\t\t\tcontinue;\n\n\t\t\tif (status->bStatusType & UAC1_STATUS_TYPE_MEM_CHANGED)\n\t\t\t\tsnd_usb_mixer_rc_memory_change(mixer, status->bOriginator);\n\t\t\telse\n\t\t\t\tsnd_usb_mixer_notify_id(mixer, status->bOriginator);\n\t\t}\n\t} else {  \n\t\tstruct uac2_interrupt_data_msg *msg;\n\n\t\tfor (msg = urb->transfer_buffer;\n\t\t     len >= sizeof(*msg);\n\t\t     len -= sizeof(*msg), msg++) {\n\t\t\t \n\t\t\tif ((msg->bInfo & UAC2_INTERRUPT_DATA_MSG_VENDOR) ||\n\t\t\t    (msg->bInfo & UAC2_INTERRUPT_DATA_MSG_EP))\n\t\t\t\tcontinue;\n\n\t\t\tsnd_usb_mixer_interrupt_v2(mixer, msg->bAttribute,\n\t\t\t\t\t\t   le16_to_cpu(msg->wValue),\n\t\t\t\t\t\t   le16_to_cpu(msg->wIndex));\n\t\t}\n\t}\n\nrequeue:\n\tif (ustatus != -ENOENT &&\n\t    ustatus != -ECONNRESET &&\n\t    ustatus != -ESHUTDOWN) {\n\t\turb->dev = mixer->chip->dev;\n\t\tusb_submit_urb(urb, GFP_ATOMIC);\n\t}\n}\n\n \nstatic int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_endpoint_descriptor *ep;\n\tvoid *transfer_buffer;\n\tint buffer_length;\n\tunsigned int epnum;\n\n\t \n\tif (get_iface_desc(mixer->hostif)->bNumEndpoints < 1)\n\t\treturn 0;\n\tep = get_endpoint(mixer->hostif, 0);\n\tif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_int(ep))\n\t\treturn 0;\n\n\tepnum = usb_endpoint_num(ep);\n\tbuffer_length = le16_to_cpu(ep->wMaxPacketSize);\n\ttransfer_buffer = kmalloc(buffer_length, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\tmixer->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mixer->urb) {\n\t\tkfree(transfer_buffer);\n\t\treturn -ENOMEM;\n\t}\n\tusb_fill_int_urb(mixer->urb, mixer->chip->dev,\n\t\t\t usb_rcvintpipe(mixer->chip->dev, epnum),\n\t\t\t transfer_buffer, buffer_length,\n\t\t\t snd_usb_mixer_interrupt, mixer, ep->bInterval);\n\tusb_submit_urb(mixer->urb, GFP_KERNEL);\n\treturn 0;\n}\n\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstatic const struct snd_device_ops dev_ops = {\n\t\t.dev_free = snd_usb_mixer_dev_free\n\t};\n\tstruct usb_mixer_interface *mixer;\n\tint err;\n\n\tstrcpy(chip->card->mixername, \"USB Mixer\");\n\n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\tmixer->chip = chip;\n\tmixer->ignore_ctl_error = !!(chip->quirk_flags & QUIRK_FLAG_IGNORE_CTL_ERROR);\n\tmixer->id_elems = kcalloc(MAX_ID_ELEMS, sizeof(*mixer->id_elems),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mixer->id_elems) {\n\t\tkfree(mixer);\n\t\treturn -ENOMEM;\n\t}\n\n\tmixer->hostif = &usb_ifnum_to_if(chip->dev, ctrlif)->altsetting[0];\n\tswitch (get_iface_desc(mixer->hostif)->bInterfaceProtocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tmixer->protocol = UAC_VERSION_1;\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tmixer->protocol = UAC_VERSION_2;\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmixer->protocol = UAC_VERSION_3;\n\t\tbreak;\n\t}\n\n\tif (mixer->protocol == UAC_VERSION_3 &&\n\t\t\tchip->badd_profile >= UAC3_FUNCTION_SUBCLASS_GENERIC_IO) {\n\t\terr = snd_usb_mixer_controls_badd(mixer, ctrlif);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t} else {\n\t\terr = snd_usb_mixer_controls(mixer);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t}\n\n\terr = snd_usb_mixer_status_create(mixer);\n\tif (err < 0)\n\t\tgoto _error;\n\n\terr = snd_usb_mixer_apply_create_quirk(mixer);\n\tif (err < 0)\n\t\tgoto _error;\n\n\terr = snd_device_new(chip->card, SNDRV_DEV_CODEC, mixer, &dev_ops);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tif (list_empty(&chip->mixer_list))\n\t\tsnd_card_ro_proc_new(chip->card, \"usbmixer\", chip,\n\t\t\t\t     snd_usb_mixer_proc_read);\n\n\tlist_add(&mixer->list, &chip->mixer_list);\n\treturn 0;\n\n_error:\n\tsnd_usb_mixer_free(mixer);\n\treturn err;\n}\n\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tif (mixer->disconnected)\n\t\treturn;\n\tif (mixer->urb)\n\t\tusb_kill_urb(mixer->urb);\n\tif (mixer->rc_urb)\n\t\tusb_kill_urb(mixer->rc_urb);\n\tif (mixer->private_free)\n\t\tmixer->private_free(mixer);\n\tmixer->disconnected = true;\n}\n\n \nstatic void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n\nstatic int snd_usb_mixer_activate(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\n\tif (mixer->urb) {\n\t\terr = usb_submit_urb(mixer->urb, GFP_NOIO);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_inactivate(mixer);\n\tif (mixer->private_suspend)\n\t\tmixer->private_suspend(mixer);\n\treturn 0;\n}\n\nstatic int restore_mixer_value(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = mixer_elem_list_to_info(list);\n\tint c, err, idx;\n\n\tif (cval->val_type == USB_MIXER_BESPOKEN)\n\t\treturn 0;\n\n\tif (cval->cmask) {\n\t\tidx = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\tif (cval->cached & (1 << (c + 1))) {\n\t\t\t\terr = snd_usb_set_cur_mix_value(cval, c + 1, idx,\n\t\t\t\t\t\t\tcval->cache_val[idx]);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t} else {\n\t\t \n\t\tif (cval->cached)\n\t\t\tsnd_usb_set_cur_mix_value(cval, 0, 0, *cval->cache_val);\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_mixer_elem_list *list;\n\tint id, err;\n\n\t \n\tfor (id = 0; id < MAX_ID_ELEMS; id++) {\n\t\tfor_each_mixer_elem(list, mixer, id) {\n\t\t\tif (list->resume) {\n\t\t\t\terr = list->resume(list);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_usb_mixer_resume_quirk(mixer);\n\n\treturn snd_usb_mixer_activate(mixer);\n}\n\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\n\t\t\t\t struct usb_mixer_interface *mixer,\n\t\t\t\t int unitid)\n{\n\tlist->mixer = mixer;\n\tlist->id = unitid;\n\tlist->dump = snd_usb_mixer_dump_cval;\n\tlist->resume = restore_mixer_value;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}