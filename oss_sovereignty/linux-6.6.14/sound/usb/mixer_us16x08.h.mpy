{
  "module_name": "mixer_us16x08.h",
  "hash_id": "acbcee2ee7e392c375d232fa81c86422c1625f16bf8676335a9c69bc459e78c7",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_us16x08.h",
  "human_readable_source": " \n#ifndef __USB_MIXER_US16X08_H\n#define __USB_MIXER_US16X08_H\n\n#define SND_US16X08_MAX_CHANNELS 16\n\n \n#define SND_US16X08_NO_BIAS 0\n#define SND_US16X08_FADER_BIAS 127\n#define SND_US16X08_EQ_HIGHFREQ_BIAS 0x20\n#define SND_US16X08_COMP_THRESHOLD_BIAS 0x20\n#define SND_US16X08_COMP_ATTACK_BIAS 2\n#define SND_US16X08_COMP_RELEASE_BIAS 1\n\n \n#define SND_US16X08_KCBIAS(x) (((x)->private_value >> 24) & 0xff)\n#define SND_US16X08_KCSTEP(x) (((x)->private_value >> 16) & 0xff)\n#define SND_US16X08_KCMIN(x) (((x)->private_value >> 8) & 0xff)\n#define SND_US16X08_KCMAX(x) (((x)->private_value >> 0) & 0xff)\n \n#define SND_US16X08_KCSET(bias, step, min, max)  \\\n\t(((bias) << 24) | ((step) << 16) | ((min) << 8) | (max))\n\n \n#define SND_US16X08_URB_REQUEST 0x1D\n#define SND_US16X08_URB_REQUESTTYPE 0x40\n\n \n#define SND_US16X08_URB_METER_REQUEST       0x1e\n#define SND_US16X08_URB_METER_REQUESTTYPE   0xc0\n\n#define MUA0(x, y) ((x)[(y) * 10 + 4])\n#define MUA1(x, y) ((x)[(y) * 10 + 5])\n#define MUA2(x, y) ((x)[(y) * 10 + 6])\n#define MUB0(x, y) ((x)[(y) * 10 + 7])\n#define MUB1(x, y) ((x)[(y) * 10 + 8])\n#define MUB2(x, y) ((x)[(y) * 10 + 9])\n#define MUC0(x, y) ((x)[(y) * 10 + 10])\n#define MUC1(x, y) ((x)[(y) * 10 + 11])\n#define MUC2(x, y) ((x)[(y) * 10 + 12])\n#define MUC3(x, y) ((x)[(y) * 10 + 13])\n\n \n#define SND_US16X08_ID_BYPASS 0x45\n#define SND_US16X08_ID_BUSS_OUT 0x44\n#define SND_US16X08_ID_PHASE 0x85\n#define SND_US16X08_ID_MUTE 0x83\n#define SND_US16X08_ID_FADER 0x81\n#define SND_US16X08_ID_PAN 0x82\n#define SND_US16X08_ID_METER 0xB1\n\n#define SND_US16X08_ID_EQ_BAND_COUNT 4\n#define SND_US16X08_ID_EQ_PARAM_COUNT 4\n\n \n#define SND_US16X08_ID_EQLOWLEVEL 0x01\n#define SND_US16X08_ID_EQLOWMIDLEVEL 0x02\n#define SND_US16X08_ID_EQHIGHMIDLEVEL 0x03\n#define SND_US16X08_ID_EQHIGHLEVEL 0x04\n\n \n#define SND_US16X08_ID_EQLOWFREQ 0x11\n#define SND_US16X08_ID_EQLOWMIDFREQ 0x12\n#define SND_US16X08_ID_EQHIGHMIDFREQ 0x13\n#define SND_US16X08_ID_EQHIGHFREQ 0x14\n\n \n#define SND_US16X08_ID_EQLOWMIDWIDTH 0x22\n#define SND_US16X08_ID_EQHIGHMIDWIDTH 0x23\n\n#define SND_US16X08_ID_EQENABLE 0x30\n\n#define EQ_STORE_BAND_IDX(x) ((x) & 0xf)\n#define EQ_STORE_PARAM_IDX(x) (((x) & 0xf0) >> 4)\n\n#define SND_US16X08_ID_ROUTE 0x00\n\n \n#define SND_US16X08_ID_COMP_BASE\t0x32\n#define SND_US16X08_ID_COMP_THRESHOLD\tSND_US16X08_ID_COMP_BASE\n#define SND_US16X08_ID_COMP_RATIO\t(SND_US16X08_ID_COMP_BASE + 1)\n#define SND_US16X08_ID_COMP_ATTACK\t(SND_US16X08_ID_COMP_BASE + 2)\n#define SND_US16X08_ID_COMP_RELEASE\t(SND_US16X08_ID_COMP_BASE + 3)\n#define SND_US16X08_ID_COMP_GAIN\t(SND_US16X08_ID_COMP_BASE + 4)\n#define SND_US16X08_ID_COMP_SWITCH\t(SND_US16X08_ID_COMP_BASE + 5)\n#define SND_US16X08_ID_COMP_COUNT\t6\n\n#define COMP_STORE_IDX(x) ((x) - SND_US16X08_ID_COMP_BASE)\n\nstruct snd_us16x08_eq_store {\n\tu8 val[SND_US16X08_ID_EQ_BAND_COUNT][SND_US16X08_ID_EQ_PARAM_COUNT]\n\t\t[SND_US16X08_MAX_CHANNELS];\n};\n\nstruct snd_us16x08_comp_store {\n\tu8 val[SND_US16X08_ID_COMP_COUNT][SND_US16X08_MAX_CHANNELS];\n};\n\nstruct snd_us16x08_meter_store {\n\tint meter_level[SND_US16X08_MAX_CHANNELS];\n\tint master_level[2];  \n\tint comp_index;  \n\tint comp_active_index;  \n\tint comp_level[16];  \n\tstruct snd_us16x08_comp_store *comp_store;\n};\n\nstruct snd_us16x08_control_params {\n\tconst struct snd_kcontrol_new *kcontrol_new;\n\tint control_id;\n\tint type;\n\tint num_channels;\n\tconst char *name;\n\tint default_val;\n};\n\n#define snd_us16x08_switch_info snd_ctl_boolean_mono_info\n\nint snd_us16x08_controls_create(struct usb_mixer_interface *mixer);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}