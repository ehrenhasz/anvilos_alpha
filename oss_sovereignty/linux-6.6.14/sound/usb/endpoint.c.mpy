{
  "module_name": "endpoint.c",
  "hash_id": "295edc6acad5ebbbf77ad5e111eaee9936467e0dce358d85eea2d067a23ecf31",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/endpoint.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/ratelimit.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"usbaudio.h\"\n#include \"helper.h\"\n#include \"card.h\"\n#include \"endpoint.h\"\n#include \"pcm.h\"\n#include \"clock.h\"\n#include \"quirks.h\"\n\nenum {\n\tEP_STATE_STOPPED,\n\tEP_STATE_RUNNING,\n\tEP_STATE_STOPPING,\n};\n\n \nstruct snd_usb_iface_ref {\n\tunsigned char iface;\n\tbool need_setup;\n\tint opened;\n\tint altset;\n\tstruct list_head list;\n};\n\n \nstruct snd_usb_clock_ref {\n\tunsigned char clock;\n\tatomic_t locked;\n\tint opened;\n\tint rate;\n\tbool need_setup;\n\tstruct list_head list;\n};\n\n \n\n \nstatic inline unsigned get_usb_full_speed_rate(unsigned int rate)\n{\n\treturn ((rate << 13) + 62) / 125;\n}\n\n \nstatic inline unsigned get_usb_high_speed_rate(unsigned int rate)\n{\n\treturn ((rate << 10) + 62) / 125;\n}\n\n \nstatic void release_urb_ctx(struct snd_urb_ctx *u)\n{\n\tif (u->urb && u->buffer_size)\n\t\tusb_free_coherent(u->ep->chip->dev, u->buffer_size,\n\t\t\t\t  u->urb->transfer_buffer,\n\t\t\t\t  u->urb->transfer_dma);\n\tusb_free_urb(u->urb);\n\tu->urb = NULL;\n\tu->buffer_size = 0;\n}\n\nstatic const char *usb_error_string(int err)\n{\n\tswitch (err) {\n\tcase -ENODEV:\n\t\treturn \"no device\";\n\tcase -ENOENT:\n\t\treturn \"endpoint not enabled\";\n\tcase -EPIPE:\n\t\treturn \"endpoint stalled\";\n\tcase -ENOSPC:\n\t\treturn \"not enough bandwidth\";\n\tcase -ESHUTDOWN:\n\t\treturn \"device disabled\";\n\tcase -EHOSTUNREACH:\n\t\treturn \"device suspended\";\n\tcase -EINVAL:\n\tcase -EAGAIN:\n\tcase -EFBIG:\n\tcase -EMSGSIZE:\n\t\treturn \"internal error\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}\n\nstatic inline bool ep_state_running(struct snd_usb_endpoint *ep)\n{\n\treturn atomic_read(&ep->state) == EP_STATE_RUNNING;\n}\n\nstatic inline bool ep_state_update(struct snd_usb_endpoint *ep, int old, int new)\n{\n\treturn atomic_try_cmpxchg(&ep->state, &old, new);\n}\n\n \nint snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep)\n{\n\treturn  ep->implicit_fb_sync && usb_pipeout(ep->pipe);\n}\n\n \nstatic int slave_next_packet_size(struct snd_usb_endpoint *ep,\n\t\t\t\t  unsigned int avail)\n{\n\tunsigned long flags;\n\tunsigned int phase;\n\tint ret;\n\n\tif (ep->fill_max)\n\t\treturn ep->maxframesize;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tphase = (ep->phase & 0xffff) + (ep->freqm << ep->datainterval);\n\tret = min(phase >> 16, ep->maxframesize);\n\tif (avail && ret >= avail)\n\t\tret = -EAGAIN;\n\telse\n\t\tep->phase = phase;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int next_packet_size(struct snd_usb_endpoint *ep, unsigned int avail)\n{\n\tunsigned int sample_accum;\n\tint ret;\n\n\tif (ep->fill_max)\n\t\treturn ep->maxframesize;\n\n\tsample_accum = ep->sample_accum + ep->sample_rem;\n\tif (sample_accum >= ep->pps) {\n\t\tsample_accum -= ep->pps;\n\t\tret = ep->packsize[1];\n\t} else {\n\t\tret = ep->packsize[0];\n\t}\n\tif (avail && ret >= avail)\n\t\tret = -EAGAIN;\n\telse\n\t\tep->sample_accum = sample_accum;\n\n\treturn ret;\n}\n\n \nint snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep,\n\t\t\t\t      struct snd_urb_ctx *ctx, int idx,\n\t\t\t\t      unsigned int avail)\n{\n\tunsigned int packet;\n\n\tpacket = ctx->packet_size[idx];\n\tif (packet) {\n\t\tif (avail && packet >= avail)\n\t\t\treturn -EAGAIN;\n\t\treturn packet;\n\t}\n\n\tif (ep->sync_source)\n\t\treturn slave_next_packet_size(ep, avail);\n\telse\n\t\treturn next_packet_size(ep, avail);\n}\n\nstatic void call_retire_callback(struct snd_usb_endpoint *ep,\n\t\t\t\t struct urb *urb)\n{\n\tstruct snd_usb_substream *data_subs;\n\n\tdata_subs = READ_ONCE(ep->data_subs);\n\tif (data_subs && ep->retire_data_urb)\n\t\tep->retire_data_urb(data_subs, urb);\n}\n\nstatic void retire_outbound_urb(struct snd_usb_endpoint *ep,\n\t\t\t\tstruct snd_urb_ctx *urb_ctx)\n{\n\tcall_retire_callback(ep, urb_ctx->urb);\n}\n\nstatic void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,\n\t\t\t\t    struct snd_usb_endpoint *sender,\n\t\t\t\t    const struct urb *urb);\n\nstatic void retire_inbound_urb(struct snd_usb_endpoint *ep,\n\t\t\t       struct snd_urb_ctx *urb_ctx)\n{\n\tstruct urb *urb = urb_ctx->urb;\n\tstruct snd_usb_endpoint *sync_sink;\n\n\tif (unlikely(ep->skip_packets > 0)) {\n\t\tep->skip_packets--;\n\t\treturn;\n\t}\n\n\tsync_sink = READ_ONCE(ep->sync_sink);\n\tif (sync_sink)\n\t\tsnd_usb_handle_sync_urb(sync_sink, ep, urb);\n\n\tcall_retire_callback(ep, urb);\n}\n\nstatic inline bool has_tx_length_quirk(struct snd_usb_audio *chip)\n{\n\treturn chip->quirk_flags & QUIRK_FLAG_TX_LENGTH;\n}\n\nstatic void prepare_silent_urb(struct snd_usb_endpoint *ep,\n\t\t\t       struct snd_urb_ctx *ctx)\n{\n\tstruct urb *urb = ctx->urb;\n\tunsigned int offs = 0;\n\tunsigned int extra = 0;\n\t__le32 packet_length;\n\tint i;\n\n\t \n\tif (has_tx_length_quirk(ep->chip))\n\t\textra = sizeof(packet_length);\n\n\tfor (i = 0; i < ctx->packets; ++i) {\n\t\tunsigned int offset;\n\t\tunsigned int length;\n\t\tint counts;\n\n\t\tcounts = snd_usb_endpoint_next_packet_size(ep, ctx, i, 0);\n\t\tlength = counts * ep->stride;  \n\t\toffset = offs * ep->stride + extra * i;\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length = length + extra;\n\t\tif (extra) {\n\t\t\tpacket_length = cpu_to_le32(length);\n\t\t\tmemcpy(urb->transfer_buffer + offset,\n\t\t\t       &packet_length, sizeof(packet_length));\n\t\t}\n\t\tmemset(urb->transfer_buffer + offset + extra,\n\t\t       ep->silence_value, length);\n\t\toffs += counts;\n\t}\n\n\turb->number_of_packets = ctx->packets;\n\turb->transfer_buffer_length = offs * ep->stride + ctx->packets * extra;\n\tctx->queued = 0;\n}\n\n \nstatic int prepare_outbound_urb(struct snd_usb_endpoint *ep,\n\t\t\t\tstruct snd_urb_ctx *ctx,\n\t\t\t\tbool in_stream_lock)\n{\n\tstruct urb *urb = ctx->urb;\n\tunsigned char *cp = urb->transfer_buffer;\n\tstruct snd_usb_substream *data_subs;\n\n\turb->dev = ep->chip->dev;  \n\n\tswitch (ep->type) {\n\tcase SND_USB_ENDPOINT_TYPE_DATA:\n\t\tdata_subs = READ_ONCE(ep->data_subs);\n\t\tif (data_subs && ep->prepare_data_urb)\n\t\t\treturn ep->prepare_data_urb(data_subs, urb, in_stream_lock);\n\t\t \n\t\tprepare_silent_urb(ep, ctx);\n\t\tbreak;\n\n\tcase SND_USB_ENDPOINT_TYPE_SYNC:\n\t\tif (snd_usb_get_speed(ep->chip->dev) >= USB_SPEED_HIGH) {\n\t\t\t \n\t\t\turb->iso_frame_desc[0].length = 4;\n\t\t\turb->iso_frame_desc[0].offset = 0;\n\t\t\tcp[0] = ep->freqn;\n\t\t\tcp[1] = ep->freqn >> 8;\n\t\t\tcp[2] = ep->freqn >> 16;\n\t\t\tcp[3] = ep->freqn >> 24;\n\t\t} else {\n\t\t\t \n\t\t\turb->iso_frame_desc[0].length = 3;\n\t\t\turb->iso_frame_desc[0].offset = 0;\n\t\t\tcp[0] = ep->freqn >> 2;\n\t\t\tcp[1] = ep->freqn >> 10;\n\t\t\tcp[2] = ep->freqn >> 18;\n\t\t}\n\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int prepare_inbound_urb(struct snd_usb_endpoint *ep,\n\t\t\t       struct snd_urb_ctx *urb_ctx)\n{\n\tint i, offs;\n\tstruct urb *urb = urb_ctx->urb;\n\n\turb->dev = ep->chip->dev;  \n\n\tswitch (ep->type) {\n\tcase SND_USB_ENDPOINT_TYPE_DATA:\n\t\toffs = 0;\n\t\tfor (i = 0; i < urb_ctx->packets; i++) {\n\t\t\turb->iso_frame_desc[i].offset = offs;\n\t\t\turb->iso_frame_desc[i].length = ep->curpacksize;\n\t\t\toffs += ep->curpacksize;\n\t\t}\n\n\t\turb->transfer_buffer_length = offs;\n\t\turb->number_of_packets = urb_ctx->packets;\n\t\tbreak;\n\n\tcase SND_USB_ENDPOINT_TYPE_SYNC:\n\t\turb->iso_frame_desc[0].length = min(4u, ep->syncmaxsize);\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void notify_xrun(struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_substream *data_subs;\n\n\tdata_subs = READ_ONCE(ep->data_subs);\n\tif (data_subs && data_subs->pcm_substream)\n\t\tsnd_pcm_stop_xrun(data_subs->pcm_substream);\n}\n\nstatic struct snd_usb_packet_info *\nnext_packet_fifo_enqueue(struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_packet_info *p;\n\n\tp = ep->next_packet + (ep->next_packet_head + ep->next_packet_queued) %\n\t\tARRAY_SIZE(ep->next_packet);\n\tep->next_packet_queued++;\n\treturn p;\n}\n\nstatic struct snd_usb_packet_info *\nnext_packet_fifo_dequeue(struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_packet_info *p;\n\n\tp = ep->next_packet + ep->next_packet_head;\n\tep->next_packet_head++;\n\tep->next_packet_head %= ARRAY_SIZE(ep->next_packet);\n\tep->next_packet_queued--;\n\treturn p;\n}\n\nstatic void push_back_to_ready_list(struct snd_usb_endpoint *ep,\n\t\t\t\t    struct snd_urb_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_add_tail(&ctx->ready_list, &ep->ready_playback_urbs);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nint snd_usb_queue_pending_output_urbs(struct snd_usb_endpoint *ep,\n\t\t\t\t      bool in_stream_lock)\n{\n\tbool implicit_fb = snd_usb_endpoint_implicit_feedback_sink(ep);\n\n\twhile (ep_state_running(ep)) {\n\n\t\tunsigned long flags;\n\t\tstruct snd_usb_packet_info *packet;\n\t\tstruct snd_urb_ctx *ctx = NULL;\n\t\tint err, i;\n\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tif ((!implicit_fb || ep->next_packet_queued > 0) &&\n\t\t    !list_empty(&ep->ready_playback_urbs)) {\n\t\t\t \n\t\t\tctx = list_first_entry(&ep->ready_playback_urbs,\n\t\t\t\t\t       struct snd_urb_ctx, ready_list);\n\t\t\tlist_del_init(&ctx->ready_list);\n\t\t\tif (implicit_fb)\n\t\t\t\tpacket = next_packet_fifo_dequeue(ep);\n\t\t}\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t\tif (ctx == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tif (implicit_fb) {\n\t\t\tfor (i = 0; i < packet->packets; i++)\n\t\t\t\tctx->packet_size[i] = packet->packet_size[i];\n\t\t}\n\n\t\t \n\t\terr = prepare_outbound_urb(ep, ctx, in_stream_lock);\n\t\t \n\t\tif (unlikely(!ep_state_running(ep)))\n\t\t\tbreak;\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tpush_back_to_ready_list(ep, ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!in_stream_lock)\n\t\t\t\tnotify_xrun(ep);\n\t\t\treturn -EPIPE;\n\t\t}\n\n\t\tif (!atomic_read(&ep->chip->shutdown))\n\t\t\terr = usb_submit_urb(ctx->urb, GFP_ATOMIC);\n\t\telse\n\t\t\terr = -ENODEV;\n\t\tif (err < 0) {\n\t\t\tif (!atomic_read(&ep->chip->shutdown)) {\n\t\t\t\tusb_audio_err(ep->chip,\n\t\t\t\t\t      \"Unable to submit urb #%d: %d at %s\\n\",\n\t\t\t\t\t      ctx->index, err, __func__);\n\t\t\t\tif (!in_stream_lock)\n\t\t\t\t\tnotify_xrun(ep);\n\t\t\t}\n\t\t\treturn -EPIPE;\n\t\t}\n\n\t\tset_bit(ctx->index, &ep->active_mask);\n\t\tatomic_inc(&ep->submitted_urbs);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void snd_complete_urb(struct urb *urb)\n{\n\tstruct snd_urb_ctx *ctx = urb->context;\n\tstruct snd_usb_endpoint *ep = ctx->ep;\n\tint err;\n\n\tif (unlikely(urb->status == -ENOENT ||\t\t \n\t\t     urb->status == -ENODEV ||\t\t \n\t\t     urb->status == -ECONNRESET ||\t \n\t\t     urb->status == -ESHUTDOWN))\t \n\t\tgoto exit_clear;\n\t \n\tif (unlikely(atomic_read(&ep->chip->shutdown)))\n\t\tgoto exit_clear;\n\n\tif (unlikely(!ep_state_running(ep)))\n\t\tgoto exit_clear;\n\n\tif (usb_pipeout(ep->pipe)) {\n\t\tretire_outbound_urb(ep, ctx);\n\t\t \n\t\tif (unlikely(!ep_state_running(ep)))\n\t\t\tgoto exit_clear;\n\n\t\t \n\t\tif (ep->lowlatency_playback ||\n\t\t     snd_usb_endpoint_implicit_feedback_sink(ep)) {\n\t\t\tpush_back_to_ready_list(ep, ctx);\n\t\t\tclear_bit(ctx->index, &ep->active_mask);\n\t\t\tsnd_usb_queue_pending_output_urbs(ep, false);\n\t\t\tatomic_dec(&ep->submitted_urbs);  \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tprepare_outbound_urb(ep, ctx, false);\n\t\t \n\t\tif (unlikely(!ep_state_running(ep)))\n\t\t\tgoto exit_clear;\n\t} else {\n\t\tretire_inbound_urb(ep, ctx);\n\t\t \n\t\tif (unlikely(!ep_state_running(ep)))\n\t\t\tgoto exit_clear;\n\n\t\tprepare_inbound_urb(ep, ctx);\n\t}\n\n\tif (!atomic_read(&ep->chip->shutdown))\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\telse\n\t\terr = -ENODEV;\n\tif (err == 0)\n\t\treturn;\n\n\tif (!atomic_read(&ep->chip->shutdown)) {\n\t\tusb_audio_err(ep->chip, \"cannot submit urb (err = %d)\\n\", err);\n\t\tnotify_xrun(ep);\n\t}\n\nexit_clear:\n\tclear_bit(ctx->index, &ep->active_mask);\n\tatomic_dec(&ep->submitted_urbs);\n}\n\n \nstatic struct snd_usb_iface_ref *\niface_ref_find(struct snd_usb_audio *chip, int iface)\n{\n\tstruct snd_usb_iface_ref *ip;\n\n\tlist_for_each_entry(ip, &chip->iface_ref_list, list)\n\t\tif (ip->iface == iface)\n\t\t\treturn ip;\n\n\tip = kzalloc(sizeof(*ip), GFP_KERNEL);\n\tif (!ip)\n\t\treturn NULL;\n\tip->iface = iface;\n\tlist_add_tail(&ip->list, &chip->iface_ref_list);\n\treturn ip;\n}\n\n \nstatic struct snd_usb_clock_ref *\nclock_ref_find(struct snd_usb_audio *chip, int clock)\n{\n\tstruct snd_usb_clock_ref *ref;\n\n\tlist_for_each_entry(ref, &chip->clock_ref_list, list)\n\t\tif (ref->clock == clock)\n\t\t\treturn ref;\n\n\tref = kzalloc(sizeof(*ref), GFP_KERNEL);\n\tif (!ref)\n\t\treturn NULL;\n\tref->clock = clock;\n\tatomic_set(&ref->locked, 0);\n\tlist_add_tail(&ref->list, &chip->clock_ref_list);\n\treturn ref;\n}\n\n \nstruct snd_usb_endpoint *\nsnd_usb_get_endpoint(struct snd_usb_audio *chip, int ep_num)\n{\n\tstruct snd_usb_endpoint *ep;\n\n\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\tif (ep->ep_num == ep_num)\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\n#define ep_type_name(type) \\\n\t(type == SND_USB_ENDPOINT_TYPE_DATA ? \"data\" : \"sync\")\n\n \nint snd_usb_add_endpoint(struct snd_usb_audio *chip, int ep_num, int type)\n{\n\tstruct snd_usb_endpoint *ep;\n\tbool is_playback;\n\n\tep = snd_usb_get_endpoint(chip, ep_num);\n\tif (ep)\n\t\treturn 0;\n\n\tusb_audio_dbg(chip, \"Creating new %s endpoint #%x\\n\",\n\t\t      ep_type_name(type),\n\t\t      ep_num);\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep->chip = chip;\n\tspin_lock_init(&ep->lock);\n\tep->type = type;\n\tep->ep_num = ep_num;\n\tINIT_LIST_HEAD(&ep->ready_playback_urbs);\n\tatomic_set(&ep->submitted_urbs, 0);\n\n\tis_playback = ((ep_num & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\n\tep_num &= USB_ENDPOINT_NUMBER_MASK;\n\tif (is_playback)\n\t\tep->pipe = usb_sndisocpipe(chip->dev, ep_num);\n\telse\n\t\tep->pipe = usb_rcvisocpipe(chip->dev, ep_num);\n\n\tlist_add_tail(&ep->list, &chip->ep_list);\n\treturn 0;\n}\n\n \nstatic void endpoint_set_syncinterval(struct snd_usb_audio *chip,\n\t\t\t\t      struct snd_usb_endpoint *ep)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_endpoint_descriptor *desc;\n\n\talts = snd_usb_get_host_interface(chip, ep->iface, ep->altsetting);\n\tif (!alts)\n\t\treturn;\n\n\tdesc = get_endpoint(alts, ep->ep_idx);\n\tif (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&\n\t    desc->bRefresh >= 1 && desc->bRefresh <= 9)\n\t\tep->syncinterval = desc->bRefresh;\n\telse if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)\n\t\tep->syncinterval = 1;\n\telse if (desc->bInterval >= 1 && desc->bInterval <= 16)\n\t\tep->syncinterval = desc->bInterval - 1;\n\telse\n\t\tep->syncinterval = 3;\n\n\tep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);\n}\n\nstatic bool endpoint_compatible(struct snd_usb_endpoint *ep,\n\t\t\t\tconst struct audioformat *fp,\n\t\t\t\tconst struct snd_pcm_hw_params *params)\n{\n\tif (!ep->opened)\n\t\treturn false;\n\tif (ep->cur_audiofmt != fp)\n\t\treturn false;\n\tif (ep->cur_rate != params_rate(params) ||\n\t    ep->cur_format != params_format(params) ||\n\t    ep->cur_period_frames != params_period_size(params) ||\n\t    ep->cur_buffer_periods != params_periods(params))\n\t\treturn false;\n\treturn true;\n}\n\n \nbool snd_usb_endpoint_compatible(struct snd_usb_audio *chip,\n\t\t\t\t struct snd_usb_endpoint *ep,\n\t\t\t\t const struct audioformat *fp,\n\t\t\t\t const struct snd_pcm_hw_params *params)\n{\n\tbool ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = endpoint_compatible(ep, fp, params);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\n \nstruct snd_usb_endpoint *\nsnd_usb_endpoint_open(struct snd_usb_audio *chip,\n\t\t      const struct audioformat *fp,\n\t\t      const struct snd_pcm_hw_params *params,\n\t\t      bool is_sync_ep,\n\t\t      bool fixed_rate)\n{\n\tstruct snd_usb_endpoint *ep;\n\tint ep_num = is_sync_ep ? fp->sync_ep : fp->endpoint;\n\n\tmutex_lock(&chip->mutex);\n\tep = snd_usb_get_endpoint(chip, ep_num);\n\tif (!ep) {\n\t\tusb_audio_err(chip, \"Cannot find EP 0x%x to open\\n\", ep_num);\n\t\tgoto unlock;\n\t}\n\n\tif (!ep->opened) {\n\t\tif (is_sync_ep) {\n\t\t\tep->iface = fp->sync_iface;\n\t\t\tep->altsetting = fp->sync_altsetting;\n\t\t\tep->ep_idx = fp->sync_ep_idx;\n\t\t} else {\n\t\t\tep->iface = fp->iface;\n\t\t\tep->altsetting = fp->altsetting;\n\t\t\tep->ep_idx = fp->ep_idx;\n\t\t}\n\t\tusb_audio_dbg(chip, \"Open EP 0x%x, iface=%d:%d, idx=%d\\n\",\n\t\t\t      ep_num, ep->iface, ep->altsetting, ep->ep_idx);\n\n\t\tep->iface_ref = iface_ref_find(chip, ep->iface);\n\t\tif (!ep->iface_ref) {\n\t\t\tep = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (fp->protocol != UAC_VERSION_1) {\n\t\t\tep->clock_ref = clock_ref_find(chip, fp->clock);\n\t\t\tif (!ep->clock_ref) {\n\t\t\t\tep = NULL;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tep->clock_ref->opened++;\n\t\t}\n\n\t\tep->cur_audiofmt = fp;\n\t\tep->cur_channels = fp->channels;\n\t\tep->cur_rate = params_rate(params);\n\t\tep->cur_format = params_format(params);\n\t\tep->cur_frame_bytes = snd_pcm_format_physical_width(ep->cur_format) *\n\t\t\tep->cur_channels / 8;\n\t\tep->cur_period_frames = params_period_size(params);\n\t\tep->cur_period_bytes = ep->cur_period_frames * ep->cur_frame_bytes;\n\t\tep->cur_buffer_periods = params_periods(params);\n\n\t\tif (ep->type == SND_USB_ENDPOINT_TYPE_SYNC)\n\t\t\tendpoint_set_syncinterval(chip, ep);\n\n\t\tep->implicit_fb_sync = fp->implicit_fb;\n\t\tep->need_setup = true;\n\t\tep->need_prepare = true;\n\t\tep->fixed_rate = fixed_rate;\n\n\t\tusb_audio_dbg(chip, \"  channels=%d, rate=%d, format=%s, period_bytes=%d, periods=%d, implicit_fb=%d\\n\",\n\t\t\t      ep->cur_channels, ep->cur_rate,\n\t\t\t      snd_pcm_format_name(ep->cur_format),\n\t\t\t      ep->cur_period_bytes, ep->cur_buffer_periods,\n\t\t\t      ep->implicit_fb_sync);\n\n\t} else {\n\t\tif (WARN_ON(!ep->iface_ref)) {\n\t\t\tep = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (!endpoint_compatible(ep, fp, params)) {\n\t\t\tusb_audio_err(chip, \"Incompatible EP setup for 0x%x\\n\",\n\t\t\t\t      ep_num);\n\t\t\tep = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tusb_audio_dbg(chip, \"Reopened EP 0x%x (count %d)\\n\",\n\t\t\t      ep_num, ep->opened);\n\t}\n\n\tif (!ep->iface_ref->opened++)\n\t\tep->iface_ref->need_setup = true;\n\n\tep->opened++;\n\n unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn ep;\n}\n\n \nvoid snd_usb_endpoint_set_sync(struct snd_usb_audio *chip,\n\t\t\t       struct snd_usb_endpoint *data_ep,\n\t\t\t       struct snd_usb_endpoint *sync_ep)\n{\n\tdata_ep->sync_source = sync_ep;\n}\n\n \nvoid snd_usb_endpoint_set_callback(struct snd_usb_endpoint *ep,\n\t\t\t\t   int (*prepare)(struct snd_usb_substream *subs,\n\t\t\t\t\t\t  struct urb *urb,\n\t\t\t\t\t\t  bool in_stream_lock),\n\t\t\t\t   void (*retire)(struct snd_usb_substream *subs,\n\t\t\t\t\t\t  struct urb *urb),\n\t\t\t\t   struct snd_usb_substream *data_subs)\n{\n\tep->prepare_data_urb = prepare;\n\tep->retire_data_urb = retire;\n\tif (data_subs)\n\t\tep->lowlatency_playback = data_subs->lowlatency_playback;\n\telse\n\t\tep->lowlatency_playback = false;\n\tWRITE_ONCE(ep->data_subs, data_subs);\n}\n\nstatic int endpoint_set_interface(struct snd_usb_audio *chip,\n\t\t\t\t  struct snd_usb_endpoint *ep,\n\t\t\t\t  bool set)\n{\n\tint altset = set ? ep->altsetting : 0;\n\tint err;\n\n\tif (ep->iface_ref->altset == altset)\n\t\treturn 0;\n\n\tusb_audio_dbg(chip, \"Setting usb interface %d:%d for EP 0x%x\\n\",\n\t\t      ep->iface, altset, ep->ep_num);\n\terr = usb_set_interface(chip->dev, ep->iface, altset);\n\tif (err < 0) {\n\t\tusb_audio_err_ratelimited(\n\t\t\tchip, \"%d:%d: usb_set_interface failed (%d)\\n\",\n\t\t\tep->iface, altset, err);\n\t\treturn err;\n\t}\n\n\tif (chip->quirk_flags & QUIRK_FLAG_IFACE_DELAY)\n\t\tmsleep(50);\n\tep->iface_ref->altset = altset;\n\treturn 0;\n}\n\n \nvoid snd_usb_endpoint_close(struct snd_usb_audio *chip,\n\t\t\t    struct snd_usb_endpoint *ep)\n{\n\tmutex_lock(&chip->mutex);\n\tusb_audio_dbg(chip, \"Closing EP 0x%x (count %d)\\n\",\n\t\t      ep->ep_num, ep->opened);\n\n\tif (!--ep->iface_ref->opened &&\n\t\t!(chip->quirk_flags & QUIRK_FLAG_IFACE_SKIP_CLOSE))\n\t\tendpoint_set_interface(chip, ep, false);\n\n\tif (!--ep->opened) {\n\t\tif (ep->clock_ref) {\n\t\t\tif (!--ep->clock_ref->opened)\n\t\t\t\tep->clock_ref->rate = 0;\n\t\t}\n\t\tep->iface = 0;\n\t\tep->altsetting = 0;\n\t\tep->cur_audiofmt = NULL;\n\t\tep->cur_rate = 0;\n\t\tep->iface_ref = NULL;\n\t\tep->clock_ref = NULL;\n\t\tusb_audio_dbg(chip, \"EP 0x%x closed\\n\", ep->ep_num);\n\t}\n\tmutex_unlock(&chip->mutex);\n}\n\n \nvoid snd_usb_endpoint_suspend(struct snd_usb_endpoint *ep)\n{\n\tep->need_prepare = true;\n\tif (ep->iface_ref)\n\t\tep->iface_ref->need_setup = true;\n\tif (ep->clock_ref)\n\t\tep->clock_ref->rate = 0;\n}\n\n \nstatic int wait_clear_urbs(struct snd_usb_endpoint *ep)\n{\n\tunsigned long end_time = jiffies + msecs_to_jiffies(1000);\n\tint alive;\n\n\tif (atomic_read(&ep->state) != EP_STATE_STOPPING)\n\t\treturn 0;\n\n\tdo {\n\t\talive = atomic_read(&ep->submitted_urbs);\n\t\tif (!alive)\n\t\t\tbreak;\n\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\n\tif (alive)\n\t\tusb_audio_err(ep->chip,\n\t\t\t\"timeout: still %d active urbs on EP #%x\\n\",\n\t\t\talive, ep->ep_num);\n\n\tif (ep_state_update(ep, EP_STATE_STOPPING, EP_STATE_STOPPED)) {\n\t\tep->sync_sink = NULL;\n\t\tsnd_usb_endpoint_set_callback(ep, NULL, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nvoid snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep)\n{\n\tif (ep)\n\t\twait_clear_urbs(ep);\n}\n\n \nstatic int stop_urbs(struct snd_usb_endpoint *ep, bool force, bool keep_pending)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tif (!force && atomic_read(&ep->running))\n\t\treturn -EBUSY;\n\n\tif (!ep_state_update(ep, EP_STATE_RUNNING, EP_STATE_STOPPING))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tINIT_LIST_HEAD(&ep->ready_playback_urbs);\n\tep->next_packet_head = 0;\n\tep->next_packet_queued = 0;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (keep_pending)\n\t\treturn 0;\n\n\tfor (i = 0; i < ep->nurbs; i++) {\n\t\tif (test_bit(i, &ep->active_mask)) {\n\t\t\tif (!test_and_set_bit(i, &ep->unlink_mask)) {\n\t\t\t\tstruct urb *u = ep->urb[i].urb;\n\t\t\t\tusb_unlink_urb(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int release_urbs(struct snd_usb_endpoint *ep, bool force)\n{\n\tint i, err;\n\n\t \n\tsnd_usb_endpoint_set_callback(ep, NULL, NULL, NULL);\n\n\t \n\terr = stop_urbs(ep, force, false);\n\tif (err)\n\t\treturn err;\n\n\twait_clear_urbs(ep);\n\n\tfor (i = 0; i < ep->nurbs; i++)\n\t\trelease_urb_ctx(&ep->urb[i]);\n\n\tusb_free_coherent(ep->chip->dev, SYNC_URBS * 4,\n\t\t\t  ep->syncbuf, ep->sync_dma);\n\n\tep->syncbuf = NULL;\n\tep->nurbs = 0;\n\treturn 0;\n}\n\n \nstatic int data_ep_set_params(struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_audio *chip = ep->chip;\n\tunsigned int maxsize, minsize, packs_per_ms, max_packs_per_urb;\n\tunsigned int max_packs_per_period, urbs_per_period, urb_packs;\n\tunsigned int max_urbs, i;\n\tconst struct audioformat *fmt = ep->cur_audiofmt;\n\tint frame_bits = ep->cur_frame_bytes * 8;\n\tint tx_length_quirk = (has_tx_length_quirk(chip) &&\n\t\t\t       usb_pipeout(ep->pipe));\n\n\tusb_audio_dbg(chip, \"Setting params for data EP 0x%x, pipe 0x%x\\n\",\n\t\t      ep->ep_num, ep->pipe);\n\n\tif (ep->cur_format == SNDRV_PCM_FORMAT_DSD_U16_LE && fmt->dsd_dop) {\n\t\t \n\t\tframe_bits += ep->cur_channels << 3;\n\t}\n\n\tep->datainterval = fmt->datainterval;\n\tep->stride = frame_bits >> 3;\n\n\tswitch (ep->cur_format) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tep->silence_value = 0x80;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_DSD_U8:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_BE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_BE:\n\t\tep->silence_value = 0x69;\n\t\tbreak;\n\tdefault:\n\t\tep->silence_value = 0;\n\t}\n\n\t \n\tep->freqmax = ep->freqn + (ep->freqn >> 1);\n\t \n\tmaxsize = (((ep->freqmax << ep->datainterval) + 0xffff) >> 16) *\n\t\t\t (frame_bits >> 3);\n\tif (tx_length_quirk)\n\t\tmaxsize += sizeof(__le32);  \n\t \n\tif (ep->maxpacksize && ep->maxpacksize < maxsize) {\n\t\t \n\t\tunsigned int data_maxsize = maxsize = ep->maxpacksize;\n\n\t\tif (tx_length_quirk)\n\t\t\t \n\t\t\tdata_maxsize -= sizeof(__le32);\n\t\tep->freqmax = (data_maxsize / (frame_bits >> 3))\n\t\t\t\t<< (16 - ep->datainterval);\n\t}\n\n\tif (ep->fill_max)\n\t\tep->curpacksize = ep->maxpacksize;\n\telse\n\t\tep->curpacksize = maxsize;\n\n\tif (snd_usb_get_speed(chip->dev) != USB_SPEED_FULL) {\n\t\tpacks_per_ms = 8 >> ep->datainterval;\n\t\tmax_packs_per_urb = MAX_PACKS_HS;\n\t} else {\n\t\tpacks_per_ms = 1;\n\t\tmax_packs_per_urb = MAX_PACKS;\n\t}\n\tif (ep->sync_source && !ep->implicit_fb_sync)\n\t\tmax_packs_per_urb = min(max_packs_per_urb,\n\t\t\t\t\t1U << ep->sync_source->syncinterval);\n\tmax_packs_per_urb = max(1u, max_packs_per_urb >> ep->datainterval);\n\n\t \n\tif (usb_pipein(ep->pipe) || ep->implicit_fb_sync) {\n\n\t\t \n\t\turb_packs = min(max_packs_per_urb, packs_per_ms);\n\t\twhile (urb_packs > 1 && urb_packs * maxsize >= ep->cur_period_bytes)\n\t\t\turb_packs >>= 1;\n\t\tep->nurbs = MAX_URBS;\n\n\t \n\t} else {\n\t\t \n\t\tminsize = (ep->freqn >> (16 - ep->datainterval)) *\n\t\t\t\t(frame_bits >> 3);\n\t\t \n\t\tif (ep->sync_source)\n\t\t\tminsize -= minsize >> 3;\n\t\tminsize = max(minsize, 1u);\n\n\t\t \n\t\tmax_packs_per_period = DIV_ROUND_UP(ep->cur_period_bytes, minsize);\n\n\t\t \n\t\turbs_per_period = DIV_ROUND_UP(max_packs_per_period,\n\t\t\t\tmax_packs_per_urb);\n\t\t \n\t\turb_packs = DIV_ROUND_UP(max_packs_per_period, urbs_per_period);\n\n\t\t \n\t\tep->max_urb_frames = DIV_ROUND_UP(ep->cur_period_frames,\n\t\t\t\t\t\t  urbs_per_period);\n\n\t\t \n\t\tmax_urbs = min((unsigned) MAX_URBS,\n\t\t\t\tMAX_QUEUE * packs_per_ms / urb_packs);\n\t\tep->nurbs = min(max_urbs, urbs_per_period * ep->cur_buffer_periods);\n\t}\n\n\t \n\tfor (i = 0; i < ep->nurbs; i++) {\n\t\tstruct snd_urb_ctx *u = &ep->urb[i];\n\t\tu->index = i;\n\t\tu->ep = ep;\n\t\tu->packets = urb_packs;\n\t\tu->buffer_size = maxsize * u->packets;\n\n\t\tif (fmt->fmt_type == UAC_FORMAT_TYPE_II)\n\t\t\tu->packets++;  \n\t\tu->urb = usb_alloc_urb(u->packets, GFP_KERNEL);\n\t\tif (!u->urb)\n\t\t\tgoto out_of_memory;\n\n\t\tu->urb->transfer_buffer =\n\t\t\tusb_alloc_coherent(chip->dev, u->buffer_size,\n\t\t\t\t\t   GFP_KERNEL, &u->urb->transfer_dma);\n\t\tif (!u->urb->transfer_buffer)\n\t\t\tgoto out_of_memory;\n\t\tu->urb->pipe = ep->pipe;\n\t\tu->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tu->urb->interval = 1 << ep->datainterval;\n\t\tu->urb->context = u;\n\t\tu->urb->complete = snd_complete_urb;\n\t\tINIT_LIST_HEAD(&u->ready_list);\n\t}\n\n\treturn 0;\n\nout_of_memory:\n\trelease_urbs(ep, false);\n\treturn -ENOMEM;\n}\n\n \nstatic int sync_ep_set_params(struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_audio *chip = ep->chip;\n\tint i;\n\n\tusb_audio_dbg(chip, \"Setting params for sync EP 0x%x, pipe 0x%x\\n\",\n\t\t      ep->ep_num, ep->pipe);\n\n\tep->syncbuf = usb_alloc_coherent(chip->dev, SYNC_URBS * 4,\n\t\t\t\t\t GFP_KERNEL, &ep->sync_dma);\n\tif (!ep->syncbuf)\n\t\treturn -ENOMEM;\n\n\tep->nurbs = SYNC_URBS;\n\tfor (i = 0; i < SYNC_URBS; i++) {\n\t\tstruct snd_urb_ctx *u = &ep->urb[i];\n\t\tu->index = i;\n\t\tu->ep = ep;\n\t\tu->packets = 1;\n\t\tu->urb = usb_alloc_urb(1, GFP_KERNEL);\n\t\tif (!u->urb)\n\t\t\tgoto out_of_memory;\n\t\tu->urb->transfer_buffer = ep->syncbuf + i * 4;\n\t\tu->urb->transfer_dma = ep->sync_dma + i * 4;\n\t\tu->urb->transfer_buffer_length = 4;\n\t\tu->urb->pipe = ep->pipe;\n\t\tu->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tu->urb->number_of_packets = 1;\n\t\tu->urb->interval = 1 << ep->syncinterval;\n\t\tu->urb->context = u;\n\t\tu->urb->complete = snd_complete_urb;\n\t}\n\n\treturn 0;\n\nout_of_memory:\n\trelease_urbs(ep, false);\n\treturn -ENOMEM;\n}\n\n \nstatic int update_clock_ref_rate(struct snd_usb_audio *chip,\n\t\t\t\t struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_clock_ref *clock = ep->clock_ref;\n\tint rate = ep->cur_rate;\n\n\tif (!clock || clock->rate == rate)\n\t\treturn rate;\n\tif (clock->rate) {\n\t\tif (atomic_read(&clock->locked))\n\t\t\treturn clock->rate;\n\t\tif (clock->rate != rate) {\n\t\t\tusb_audio_err(chip, \"Mismatched sample rate %d vs %d for EP 0x%x\\n\",\n\t\t\t\t      clock->rate, rate, ep->ep_num);\n\t\t\treturn clock->rate;\n\t\t}\n\t}\n\tclock->rate = rate;\n\tclock->need_setup = true;\n\treturn rate;\n}\n\n \nint snd_usb_endpoint_set_params(struct snd_usb_audio *chip,\n\t\t\t\tstruct snd_usb_endpoint *ep)\n{\n\tconst struct audioformat *fmt = ep->cur_audiofmt;\n\tint err = 0;\n\n\tmutex_lock(&chip->mutex);\n\tif (!ep->need_setup)\n\t\tgoto unlock;\n\n\t \n\terr = release_urbs(ep, false);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tep->datainterval = fmt->datainterval;\n\tep->maxpacksize = fmt->maxpacksize;\n\tep->fill_max = !!(fmt->attributes & UAC_EP_CS_ATTR_FILL_MAX);\n\n\tif (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL) {\n\t\tep->freqn = get_usb_full_speed_rate(ep->cur_rate);\n\t\tep->pps = 1000 >> ep->datainterval;\n\t} else {\n\t\tep->freqn = get_usb_high_speed_rate(ep->cur_rate);\n\t\tep->pps = 8000 >> ep->datainterval;\n\t}\n\n\tep->sample_rem = ep->cur_rate % ep->pps;\n\tep->packsize[0] = ep->cur_rate / ep->pps;\n\tep->packsize[1] = (ep->cur_rate + (ep->pps - 1)) / ep->pps;\n\n\t \n\tep->freqm = ep->freqn;\n\tep->freqshift = INT_MIN;\n\n\tep->phase = 0;\n\n\tswitch (ep->type) {\n\tcase  SND_USB_ENDPOINT_TYPE_DATA:\n\t\terr = data_ep_set_params(ep);\n\t\tbreak;\n\tcase  SND_USB_ENDPOINT_TYPE_SYNC:\n\t\terr = sync_ep_set_params(ep);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tusb_audio_dbg(chip, \"Set up %d URBS, ret=%d\\n\", ep->nurbs, err);\n\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\tep->maxframesize = ep->maxpacksize / ep->cur_frame_bytes;\n\tep->curframesize = ep->curpacksize / ep->cur_frame_bytes;\n\n\terr = update_clock_ref_rate(chip, ep);\n\tif (err >= 0) {\n\t\tep->need_setup = false;\n\t\terr = 0;\n\t}\n\n unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn err;\n}\n\nstatic int init_sample_rate(struct snd_usb_audio *chip,\n\t\t\t    struct snd_usb_endpoint *ep)\n{\n\tstruct snd_usb_clock_ref *clock = ep->clock_ref;\n\tint rate, err;\n\n\trate = update_clock_ref_rate(chip, ep);\n\tif (rate < 0)\n\t\treturn rate;\n\tif (clock && !clock->need_setup)\n\t\treturn 0;\n\n\tif (!ep->fixed_rate) {\n\t\terr = snd_usb_init_sample_rate(chip, ep->cur_audiofmt, rate);\n\t\tif (err < 0) {\n\t\t\tif (clock)\n\t\t\t\tclock->rate = 0;  \n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (clock)\n\t\tclock->need_setup = false;\n\treturn 0;\n}\n\n \nint snd_usb_endpoint_prepare(struct snd_usb_audio *chip,\n\t\t\t     struct snd_usb_endpoint *ep)\n{\n\tbool iface_first;\n\tint err = 0;\n\n\tmutex_lock(&chip->mutex);\n\tif (WARN_ON(!ep->iface_ref))\n\t\tgoto unlock;\n\tif (!ep->need_prepare)\n\t\tgoto unlock;\n\n\t \n\tif (!ep->iface_ref->need_setup) {\n\t\t \n\t\tif (ep->cur_audiofmt->protocol == UAC_VERSION_1) {\n\t\t\terr = init_sample_rate(chip, ep);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tendpoint_set_interface(chip, ep, false);\n\n\t \n\tiface_first = ep->cur_audiofmt->protocol == UAC_VERSION_1;\n\t \n\tif (chip->quirk_flags & QUIRK_FLAG_SET_IFACE_FIRST)\n\t\tiface_first = true;\n\tif (iface_first) {\n\t\terr = endpoint_set_interface(chip, ep, true);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\n\terr = snd_usb_init_pitch(chip, ep->cur_audiofmt);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\terr = init_sample_rate(chip, ep);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\terr = snd_usb_select_mode_quirk(chip, ep->cur_audiofmt);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\tif (!iface_first) {\n\t\terr = endpoint_set_interface(chip, ep, true);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tep->iface_ref->need_setup = false;\n\n done:\n\tep->need_prepare = false;\n\terr = 1;\n\nunlock:\n\tmutex_unlock(&chip->mutex);\n\treturn err;\n}\n\n \nint snd_usb_endpoint_get_clock_rate(struct snd_usb_audio *chip, int clock)\n{\n\tstruct snd_usb_clock_ref *ref;\n\tint rate = 0;\n\n\tif (!clock)\n\t\treturn 0;\n\tmutex_lock(&chip->mutex);\n\tlist_for_each_entry(ref, &chip->clock_ref_list, list) {\n\t\tif (ref->clock == clock) {\n\t\t\trate = ref->rate;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn rate;\n}\n\n \nint snd_usb_endpoint_start(struct snd_usb_endpoint *ep)\n{\n\tbool is_playback = usb_pipeout(ep->pipe);\n\tint err;\n\tunsigned int i;\n\n\tif (atomic_read(&ep->chip->shutdown))\n\t\treturn -EBADFD;\n\n\tif (ep->sync_source)\n\t\tWRITE_ONCE(ep->sync_source->sync_sink, ep);\n\n\tusb_audio_dbg(ep->chip, \"Starting %s EP 0x%x (running %d)\\n\",\n\t\t      ep_type_name(ep->type), ep->ep_num,\n\t\t      atomic_read(&ep->running));\n\n\t \n\tif (atomic_inc_return(&ep->running) != 1)\n\t\treturn 0;\n\n\tif (ep->clock_ref)\n\t\tatomic_inc(&ep->clock_ref->locked);\n\n\tep->active_mask = 0;\n\tep->unlink_mask = 0;\n\tep->phase = 0;\n\tep->sample_accum = 0;\n\n\tsnd_usb_endpoint_start_quirk(ep);\n\n\t \n\n\tif (!ep_state_update(ep, EP_STATE_STOPPED, EP_STATE_RUNNING))\n\t\tgoto __error;\n\n\tif (snd_usb_endpoint_implicit_feedback_sink(ep) &&\n\t    !(ep->chip->quirk_flags & QUIRK_FLAG_PLAYBACK_FIRST)) {\n\t\tusb_audio_dbg(ep->chip, \"No URB submission due to implicit fb sync\\n\");\n\t\ti = 0;\n\t\tgoto fill_rest;\n\t}\n\n\tfor (i = 0; i < ep->nurbs; i++) {\n\t\tstruct urb *urb = ep->urb[i].urb;\n\n\t\tif (snd_BUG_ON(!urb))\n\t\t\tgoto __error;\n\n\t\tif (is_playback)\n\t\t\terr = prepare_outbound_urb(ep, urb->context, true);\n\t\telse\n\t\t\terr = prepare_inbound_urb(ep, urb->context);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tif (err == -EAGAIN)\n\t\t\t\tbreak;\n\t\t\tusb_audio_dbg(ep->chip,\n\t\t\t\t      \"EP 0x%x: failed to prepare urb: %d\\n\",\n\t\t\t\t      ep->ep_num, err);\n\t\t\tgoto __error;\n\t\t}\n\n\t\tif (!atomic_read(&ep->chip->shutdown))\n\t\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\telse\n\t\t\terr = -ENODEV;\n\t\tif (err < 0) {\n\t\t\tif (!atomic_read(&ep->chip->shutdown))\n\t\t\t\tusb_audio_err(ep->chip,\n\t\t\t\t\t      \"cannot submit urb %d, error %d: %s\\n\",\n\t\t\t\t\t      i, err, usb_error_string(err));\n\t\t\tgoto __error;\n\t\t}\n\t\tset_bit(i, &ep->active_mask);\n\t\tatomic_inc(&ep->submitted_urbs);\n\t}\n\n\tif (!i) {\n\t\tusb_audio_dbg(ep->chip, \"XRUN at starting EP 0x%x\\n\",\n\t\t\t      ep->ep_num);\n\t\tgoto __error;\n\t}\n\n\tusb_audio_dbg(ep->chip, \"%d URBs submitted for EP 0x%x\\n\",\n\t\t      i, ep->ep_num);\n\n fill_rest:\n\t \n\tif (is_playback) {\n\t\tfor (; i < ep->nurbs; i++)\n\t\t\tpush_back_to_ready_list(ep, ep->urb + i);\n\t}\n\n\treturn 0;\n\n__error:\n\tsnd_usb_endpoint_stop(ep, false);\n\treturn -EPIPE;\n}\n\n \nvoid snd_usb_endpoint_stop(struct snd_usb_endpoint *ep, bool keep_pending)\n{\n\tif (!ep)\n\t\treturn;\n\n\tusb_audio_dbg(ep->chip, \"Stopping %s EP 0x%x (running %d)\\n\",\n\t\t      ep_type_name(ep->type), ep->ep_num,\n\t\t      atomic_read(&ep->running));\n\n\tif (snd_BUG_ON(!atomic_read(&ep->running)))\n\t\treturn;\n\n\tif (!atomic_dec_return(&ep->running)) {\n\t\tif (ep->sync_source)\n\t\t\tWRITE_ONCE(ep->sync_source->sync_sink, NULL);\n\t\tstop_urbs(ep, false, keep_pending);\n\t\tif (ep->clock_ref)\n\t\t\tatomic_dec(&ep->clock_ref->locked);\n\n\t\tif (ep->chip->quirk_flags & QUIRK_FLAG_FORCE_IFACE_RESET &&\n\t\t    usb_pipeout(ep->pipe)) {\n\t\t\tep->need_prepare = true;\n\t\t\tif (ep->iface_ref)\n\t\t\t\tep->iface_ref->need_setup = true;\n\t\t}\n\t}\n}\n\n \nvoid snd_usb_endpoint_release(struct snd_usb_endpoint *ep)\n{\n\trelease_urbs(ep, true);\n}\n\n \nvoid snd_usb_endpoint_free_all(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_endpoint *ep, *en;\n\tstruct snd_usb_iface_ref *ip, *in;\n\tstruct snd_usb_clock_ref *cp, *cn;\n\n\tlist_for_each_entry_safe(ep, en, &chip->ep_list, list)\n\t\tkfree(ep);\n\n\tlist_for_each_entry_safe(ip, in, &chip->iface_ref_list, list)\n\t\tkfree(ip);\n\n\tlist_for_each_entry_safe(cp, cn, &chip->clock_ref_list, list)\n\t\tkfree(cp);\n}\n\n \nstatic void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,\n\t\t\t\t    struct snd_usb_endpoint *sender,\n\t\t\t\t    const struct urb *urb)\n{\n\tint shift;\n\tunsigned int f;\n\tunsigned long flags;\n\n\tsnd_BUG_ON(ep == sender);\n\n\t \n\tif (snd_usb_endpoint_implicit_feedback_sink(ep) &&\n\t    atomic_read(&ep->running)) {\n\n\t\t \n\t\tint i, bytes = 0;\n\t\tstruct snd_urb_ctx *in_ctx;\n\t\tstruct snd_usb_packet_info *out_packet;\n\n\t\tin_ctx = urb->context;\n\n\t\t \n\t\tfor (i = 0; i < in_ctx->packets; i++)\n\t\t\tif (urb->iso_frame_desc[i].status == 0)\n\t\t\t\tbytes += urb->iso_frame_desc[i].actual_length;\n\n\t\t \n\t\tif (bytes == 0)\n\t\t\treturn;\n\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tif (ep->next_packet_queued >= ARRAY_SIZE(ep->next_packet)) {\n\t\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\t\tusb_audio_err(ep->chip,\n\t\t\t\t      \"next package FIFO overflow EP 0x%x\\n\",\n\t\t\t\t      ep->ep_num);\n\t\t\tnotify_xrun(ep);\n\t\t\treturn;\n\t\t}\n\n\t\tout_packet = next_packet_fifo_enqueue(ep);\n\n\t\t \n\n\t\tout_packet->packets = in_ctx->packets;\n\t\tfor (i = 0; i < in_ctx->packets; i++) {\n\t\t\tif (urb->iso_frame_desc[i].status == 0)\n\t\t\t\tout_packet->packet_size[i] =\n\t\t\t\t\turb->iso_frame_desc[i].actual_length / sender->stride;\n\t\t\telse\n\t\t\t\tout_packet->packet_size[i] = 0;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\tsnd_usb_queue_pending_output_urbs(ep, false);\n\n\t\treturn;\n\t}\n\n\t \n\n\tif (urb->iso_frame_desc[0].status != 0 ||\n\t    urb->iso_frame_desc[0].actual_length < 3)\n\t\treturn;\n\n\tf = le32_to_cpup(urb->transfer_buffer);\n\tif (urb->iso_frame_desc[0].actual_length == 3)\n\t\tf &= 0x00ffffff;\n\telse\n\t\tf &= 0x0fffffff;\n\n\tif (f == 0)\n\t\treturn;\n\n\tif (unlikely(sender->tenor_fb_quirk)) {\n\t\t \n\t\tif (f < ep->freqn - 0x8000)\n\t\t\tf += 0xf000;\n\t\telse if (f > ep->freqn + 0x8000)\n\t\t\tf -= 0xf000;\n\t} else if (unlikely(ep->freqshift == INT_MIN)) {\n\t\t \n\t\tshift = 0;\n\t\twhile (f < ep->freqn - ep->freqn / 4) {\n\t\t\tf <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\twhile (f > ep->freqn + ep->freqn / 2) {\n\t\t\tf >>= 1;\n\t\t\tshift--;\n\t\t}\n\t\tep->freqshift = shift;\n\t} else if (ep->freqshift >= 0)\n\t\tf <<= ep->freqshift;\n\telse\n\t\tf >>= -ep->freqshift;\n\n\tif (likely(f >= ep->freqn - ep->freqn / 8 && f <= ep->freqmax)) {\n\t\t \n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tep->freqm = f;\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t} else {\n\t\t \n\t\tep->freqshift = INT_MIN;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}