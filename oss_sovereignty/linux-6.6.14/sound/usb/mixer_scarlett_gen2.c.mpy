{
  "module_name": "mixer_scarlett_gen2.c",
  "hash_id": "a053000744e6418220f3e13f4b1fcafb291bddb0196ae10d5d5a9ddf82ea3043",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_scarlett_gen2.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n\n#include <sound/control.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n\n#include \"mixer_scarlett_gen2.h\"\n\n \n#define SCARLETT2_ENABLE 0x01\n\n \n#define SCARLETT2_MSD_ENABLE 0x02\n\n \n#define SCARLETT2_VOLUME_BIAS 127\n\n \n#define SCARLETT2_MIXER_MIN_DB -80\n#define SCARLETT2_MIXER_BIAS (-SCARLETT2_MIXER_MIN_DB * 2)\n#define SCARLETT2_MIXER_MAX_DB 6\n#define SCARLETT2_MIXER_MAX_VALUE \\\n\t((SCARLETT2_MIXER_MAX_DB - SCARLETT2_MIXER_MIN_DB) * 2)\n#define SCARLETT2_MIXER_VALUE_COUNT (SCARLETT2_MIXER_MAX_VALUE + 1)\n\n \nstatic const u16 scarlett2_mixer_values[SCARLETT2_MIXER_VALUE_COUNT] = {\n\t0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,\n\t2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8,\n\t9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t23, 24, 25, 27, 29, 30, 32, 34, 36, 38, 41, 43, 46, 48, 51,\n\t54, 57, 61, 65, 68, 73, 77, 81, 86, 91, 97, 103, 109, 115,\n\t122, 129, 137, 145, 154, 163, 173, 183, 194, 205, 217, 230,\n\t244, 259, 274, 290, 307, 326, 345, 365, 387, 410, 434, 460,\n\t487, 516, 547, 579, 614, 650, 689, 730, 773, 819, 867, 919,\n\t973, 1031, 1092, 1157, 1225, 1298, 1375, 1456, 1543, 1634,\n\t1731, 1833, 1942, 2057, 2179, 2308, 2445, 2590, 2744, 2906,\n\t3078, 3261, 3454, 3659, 3876, 4105, 4349, 4606, 4879, 5168,\n\t5475, 5799, 6143, 6507, 6892, 7301, 7733, 8192, 8677, 9191,\n\t9736, 10313, 10924, 11571, 12257, 12983, 13752, 14567, 15430,\n\t16345\n};\n\n \n#define SCARLETT2_ANALOGUE_MAX 10\n\n \n#define SCARLETT2_LEVEL_SWITCH_MAX 2\n#define SCARLETT2_PAD_SWITCH_MAX 8\n#define SCARLETT2_AIR_SWITCH_MAX 8\n#define SCARLETT2_PHANTOM_SWITCH_MAX 2\n\n \n#define SCARLETT2_INPUT_MIX_MAX 25\n\n \n#define SCARLETT2_OUTPUT_MIX_MAX 12\n\n \n#define SCARLETT2_MUX_MAX 77\n\n \n#define SCARLETT2_MAX_METERS 65\n\n \nenum {\n\tSCARLETT2_CONFIG_SET_NO_MIXER = 0,\n\tSCARLETT2_CONFIG_SET_GEN_2 = 1,\n\tSCARLETT2_CONFIG_SET_GEN_3 = 2,\n\tSCARLETT2_CONFIG_SET_CLARETT = 3,\n\tSCARLETT2_CONFIG_SET_COUNT = 4\n};\n\n \nenum {\n\tSCARLETT2_PORT_TYPE_NONE     = 0,\n\tSCARLETT2_PORT_TYPE_ANALOGUE = 1,\n\tSCARLETT2_PORT_TYPE_SPDIF    = 2,\n\tSCARLETT2_PORT_TYPE_ADAT     = 3,\n\tSCARLETT2_PORT_TYPE_MIX      = 4,\n\tSCARLETT2_PORT_TYPE_PCM      = 5,\n\tSCARLETT2_PORT_TYPE_COUNT    = 6,\n};\n\n \nenum {\n\tSCARLETT2_PORT_IN    = 0,\n\tSCARLETT2_PORT_OUT   = 1,\n\tSCARLETT2_PORT_DIRNS = 2,\n};\n\n \nenum {\n\tSCARLETT2_BUTTON_MUTE    = 0,\n\tSCARLETT2_BUTTON_DIM     = 1,\n\tSCARLETT2_DIM_MUTE_COUNT = 2,\n};\n\nstatic const char *const scarlett2_dim_mute_names[SCARLETT2_DIM_MUTE_COUNT] = {\n\t\"Mute Playback Switch\", \"Dim Playback Switch\"\n};\n\n \nstruct scarlett2_port {\n\tu16 id;\n\tconst char * const src_descr;\n\tint src_num_offset;\n\tconst char * const dst_descr;\n};\n\nstatic const struct scarlett2_port scarlett2_ports[SCARLETT2_PORT_TYPE_COUNT] = {\n\t[SCARLETT2_PORT_TYPE_NONE] = {\n\t\t.id = 0x000,\n\t\t.src_descr = \"Off\"\n\t},\n\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {\n\t\t.id = 0x080,\n\t\t.src_descr = \"Analogue %d\",\n\t\t.src_num_offset = 1,\n\t\t.dst_descr = \"Analogue Output %02d Playback\"\n\t},\n\t[SCARLETT2_PORT_TYPE_SPDIF] = {\n\t\t.id = 0x180,\n\t\t.src_descr = \"S/PDIF %d\",\n\t\t.src_num_offset = 1,\n\t\t.dst_descr = \"S/PDIF Output %d Playback\"\n\t},\n\t[SCARLETT2_PORT_TYPE_ADAT] = {\n\t\t.id = 0x200,\n\t\t.src_descr = \"ADAT %d\",\n\t\t.src_num_offset = 1,\n\t\t.dst_descr = \"ADAT Output %d Playback\"\n\t},\n\t[SCARLETT2_PORT_TYPE_MIX] = {\n\t\t.id = 0x300,\n\t\t.src_descr = \"Mix %c\",\n\t\t.src_num_offset = 'A',\n\t\t.dst_descr = \"Mixer Input %02d Capture\"\n\t},\n\t[SCARLETT2_PORT_TYPE_PCM] = {\n\t\t.id = 0x600,\n\t\t.src_descr = \"PCM %d\",\n\t\t.src_num_offset = 1,\n\t\t.dst_descr = \"PCM %02d Capture\"\n\t},\n};\n\n \n#define SCARLETT2_MUX_TABLES 3\n\n \n#define SCARLETT2_MAX_MUX_ENTRIES 10\n\n \nstruct scarlett2_mux_entry {\n\tu8 port_type;\n\tu8 start;\n\tu8 count;\n};\n\nstruct scarlett2_device_info {\n\tu32 usb_id;  \n\n\t \n\tu8 has_msd_mode;\n\n\t \n\tu8 config_set;\n\n\t \n\tu8 line_out_hw_vol;\n\n\t \n\tu8 has_speaker_switching;\n\n\t \n\tu8 has_talkback;\n\n\t \n\tu8 level_input_count;\n\n\t \n\tu8 level_input_first;\n\n\t \n\tu8 pad_input_count;\n\n\t \n\tu8 air_input_count;\n\n\t \n\tu8 phantom_count;\n\n\t \n\tu8 inputs_per_phantom;\n\n\t \n\tu8 direct_monitor;\n\n\t \n\tu8 line_out_remap_enable;\n\tu8 line_out_remap[SCARLETT2_ANALOGUE_MAX];\n\n\t \n\tconst char * const line_out_descrs[SCARLETT2_ANALOGUE_MAX];\n\n\t \n\tconst int port_count[SCARLETT2_PORT_TYPE_COUNT][SCARLETT2_PORT_DIRNS];\n\n\t \n\tstruct scarlett2_mux_entry mux_assignment[SCARLETT2_MUX_TABLES]\n\t\t\t\t\t\t [SCARLETT2_MAX_MUX_ENTRIES];\n};\n\nstruct scarlett2_data {\n\tstruct usb_mixer_interface *mixer;\n\tstruct mutex usb_mutex;  \n\tstruct mutex data_mutex;  \n\tstruct delayed_work work;\n\tconst struct scarlett2_device_info *info;\n\t__u8 bInterfaceNumber;\n\t__u8 bEndpointAddress;\n\t__u16 wMaxPacketSize;\n\t__u8 bInterval;\n\tint num_mux_srcs;\n\tint num_mux_dsts;\n\tu16 scarlett2_seq;\n\tu8 sync_updated;\n\tu8 vol_updated;\n\tu8 input_other_updated;\n\tu8 monitor_other_updated;\n\tu8 mux_updated;\n\tu8 speaker_switching_switched;\n\tu8 sync;\n\tu8 master_vol;\n\tu8 vol[SCARLETT2_ANALOGUE_MAX];\n\tu8 vol_sw_hw_switch[SCARLETT2_ANALOGUE_MAX];\n\tu8 mute_switch[SCARLETT2_ANALOGUE_MAX];\n\tu8 level_switch[SCARLETT2_LEVEL_SWITCH_MAX];\n\tu8 pad_switch[SCARLETT2_PAD_SWITCH_MAX];\n\tu8 dim_mute[SCARLETT2_DIM_MUTE_COUNT];\n\tu8 air_switch[SCARLETT2_AIR_SWITCH_MAX];\n\tu8 phantom_switch[SCARLETT2_PHANTOM_SWITCH_MAX];\n\tu8 phantom_persistence;\n\tu8 direct_monitor_switch;\n\tu8 speaker_switching_switch;\n\tu8 talkback_switch;\n\tu8 talkback_map[SCARLETT2_OUTPUT_MIX_MAX];\n\tu8 msd_switch;\n\tu8 standalone_switch;\n\tstruct snd_kcontrol *sync_ctl;\n\tstruct snd_kcontrol *master_vol_ctl;\n\tstruct snd_kcontrol *vol_ctls[SCARLETT2_ANALOGUE_MAX];\n\tstruct snd_kcontrol *sw_hw_ctls[SCARLETT2_ANALOGUE_MAX];\n\tstruct snd_kcontrol *mute_ctls[SCARLETT2_ANALOGUE_MAX];\n\tstruct snd_kcontrol *dim_mute_ctls[SCARLETT2_DIM_MUTE_COUNT];\n\tstruct snd_kcontrol *level_ctls[SCARLETT2_LEVEL_SWITCH_MAX];\n\tstruct snd_kcontrol *pad_ctls[SCARLETT2_PAD_SWITCH_MAX];\n\tstruct snd_kcontrol *air_ctls[SCARLETT2_AIR_SWITCH_MAX];\n\tstruct snd_kcontrol *phantom_ctls[SCARLETT2_PHANTOM_SWITCH_MAX];\n\tstruct snd_kcontrol *mux_ctls[SCARLETT2_MUX_MAX];\n\tstruct snd_kcontrol *direct_monitor_ctl;\n\tstruct snd_kcontrol *speaker_switching_ctl;\n\tstruct snd_kcontrol *talkback_ctl;\n\tu8 mux[SCARLETT2_MUX_MAX];\n\tu8 mix[SCARLETT2_INPUT_MIX_MAX * SCARLETT2_OUTPUT_MIX_MAX];\n};\n\n \n\nstatic const struct scarlett2_device_info s6i6_gen2_info = {\n\t.usb_id = USB_ID(0x1235, 0x8203),\n\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_2,\n\t.level_input_count = 2,\n\t.pad_input_count = 2,\n\n\t.line_out_descrs = {\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  4,  4 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 10, 18 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = {  6,  6 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info s18i8_gen2_info = {\n\t.usb_id = USB_ID(0x1235, 0x8204),\n\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_2,\n\t.level_input_count = 2,\n\t.pad_input_count = 4,\n\n\t.line_out_descrs = {\n\t\t\"Monitor L\",\n\t\t\"Monitor R\",\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  8,  6 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_ADAT]     = {  8,  0 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 10, 18 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = {  8, 18 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 14 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  4 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info s18i20_gen2_info = {\n\t.usb_id = USB_ID(0x1235, 0x8201),\n\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_2,\n\t.line_out_hw_vol = 1,\n\n\t.line_out_descrs = {\n\t\t\"Monitor L\",\n\t\t\"Monitor R\",\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  8, 10 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_ADAT]     = {  8,  8 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 10, 18 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = { 20, 18 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,     0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 14 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,     0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  6 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info solo_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8211),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_NO_MIXER,\n\t.level_input_count = 1,\n\t.level_input_first = 1,\n\t.air_input_count = 1,\n\t.phantom_count = 1,\n\t.inputs_per_phantom = 1,\n\t.direct_monitor = 1,\n};\n\nstatic const struct scarlett2_device_info s2i2_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8210),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_NO_MIXER,\n\t.level_input_count = 2,\n\t.air_input_count = 2,\n\t.phantom_count = 1,\n\t.inputs_per_phantom = 2,\n\t.direct_monitor = 2,\n};\n\nstatic const struct scarlett2_device_info s4i4_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8212),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_3,\n\t.level_input_count = 2,\n\t.pad_input_count = 2,\n\t.air_input_count = 2,\n\t.phantom_count = 1,\n\t.inputs_per_phantom = 2,\n\n\t.line_out_descrs = {\n\t\t\"Monitor L\",\n\t\t\"Monitor R\",\n\t\t\"Headphones L\",\n\t\t\"Headphones R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = { 1, 0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = { 4, 4 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 6, 8 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = { 4, 6 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 16 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 16 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  6 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 16 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info s8i6_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8213),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_3,\n\t.level_input_count = 2,\n\t.pad_input_count = 2,\n\t.air_input_count = 2,\n\t.phantom_count = 1,\n\t.inputs_per_phantom = 2,\n\n\t.line_out_descrs = {\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = { 1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = { 6,  4 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = { 2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 8,  8 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = { 6, 10 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      8,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 18 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      8,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 18 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      8,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 18 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info s18i8_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8214),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_3,\n\t.line_out_hw_vol = 1,\n\t.has_speaker_switching = 1,\n\t.level_input_count = 2,\n\t.pad_input_count = 4,\n\t.air_input_count = 4,\n\t.phantom_count = 2,\n\t.inputs_per_phantom = 2,\n\n\t.line_out_remap_enable = 1,\n\t.line_out_remap = { 0, 1, 6, 7, 2, 3, 4, 5 },\n\n\t.line_out_descrs = {\n\t\t\"Monitor L\",\n\t\t\"Monitor R\",\n\t\t\"Alt Monitor L\",\n\t\t\"Alt Monitor R\",\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  8,  8 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_ADAT]     = {  8,  0 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 10, 20 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = {  8, 20 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      12,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  6,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  2,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      10,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,       0, 20 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 10 },\n\t\t{ 0,                             0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      12,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  6,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  2,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      10,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,       0, 20 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 10 },\n\t\t{ 0,                             0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  6,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  2,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,       0, 20 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 10 },\n\t\t{ 0,                             0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info s18i20_gen3_info = {\n\t.usb_id = USB_ID(0x1235, 0x8215),\n\n\t.has_msd_mode = 1,\n\t.config_set = SCARLETT2_CONFIG_SET_GEN_3,\n\t.line_out_hw_vol = 1,\n\t.has_speaker_switching = 1,\n\t.has_talkback = 1,\n\t.level_input_count = 2,\n\t.pad_input_count = 8,\n\t.air_input_count = 8,\n\t.phantom_count = 2,\n\t.inputs_per_phantom = 4,\n\n\t.line_out_descrs = {\n\t\t\"Monitor 1 L\",\n\t\t\"Monitor 1 R\",\n\t\t\"Monitor 2 L\",\n\t\t\"Monitor 2 R\",\n\t\tNULL,\n\t\tNULL,\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  9, 10 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_ADAT]     = {  8,  8 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 12, 25 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = { 20, 20 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      10, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       8,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,       0, 25 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 12 },\n\t\t{ 0,                             0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      10,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,      0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       8,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,       0, 25 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 10 },\n\t\t{ 0,                             0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,       0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE,  0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,     0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,      0, 24 },\n\t\t{ 0,                             0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info clarett_8pre_info = {\n\t.usb_id = USB_ID(0x1235, 0x820c),\n\n\t.config_set = SCARLETT2_CONFIG_SET_CLARETT,\n\t.line_out_hw_vol = 1,\n\t.level_input_count = 2,\n\t.air_input_count = 8,\n\n\t.line_out_descrs = {\n\t\t\"Monitor L\",\n\t\t\"Monitor R\",\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\t\"Headphones 1 L\",\n\t\t\"Headphones 1 R\",\n\t\t\"Headphones 2 L\",\n\t\t\"Headphones 2 R\",\n\t},\n\n\t.port_count = {\n\t\t[SCARLETT2_PORT_TYPE_NONE]     = {  1,  0 },\n\t\t[SCARLETT2_PORT_TYPE_ANALOGUE] = {  8, 10 },\n\t\t[SCARLETT2_PORT_TYPE_SPDIF]    = {  2,  2 },\n\t\t[SCARLETT2_PORT_TYPE_ADAT]     = {  8,  8 },\n\t\t[SCARLETT2_PORT_TYPE_MIX]      = { 10, 18 },\n\t\t[SCARLETT2_PORT_TYPE_PCM]      = { 20, 18 },\n\t},\n\n\t.mux_assignment = { {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,     0,  8 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 14 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_ADAT,     0,  4 },\n\t\t{ SCARLETT2_PORT_TYPE_MIX,      0, 18 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0,  8 },\n\t\t{ 0,                            0,  0 },\n\t}, {\n\t\t{ SCARLETT2_PORT_TYPE_PCM,      0, 12 },\n\t\t{ SCARLETT2_PORT_TYPE_ANALOGUE, 0, 10 },\n\t\t{ SCARLETT2_PORT_TYPE_SPDIF,    0,  2 },\n\t\t{ SCARLETT2_PORT_TYPE_NONE,     0, 22 },\n\t\t{ 0,                            0,  0 },\n\t} },\n};\n\nstatic const struct scarlett2_device_info *scarlett2_devices[] = {\n\t \n\t&s6i6_gen2_info,\n\t&s18i8_gen2_info,\n\t&s18i20_gen2_info,\n\n\t \n\t&solo_gen3_info,\n\t&s2i2_gen3_info,\n\t&s4i4_gen3_info,\n\t&s8i6_gen3_info,\n\t&s18i8_gen3_info,\n\t&s18i20_gen3_info,\n\n\t \n\t&clarett_8pre_info,\n\n\t \n\tNULL\n};\n\n \nstatic int scarlett2_get_port_start_num(\n\tconst int port_count[][SCARLETT2_PORT_DIRNS],\n\tint direction, int port_type)\n{\n\tint i, num = 0;\n\n\tfor (i = 0; i < port_type; i++)\n\t\tnum += port_count[i][direction];\n\n\treturn num;\n}\n\n \n\n \n#define SCARLETT2_USB_NOTIFY_SYNC          0x00000008\n#define SCARLETT2_USB_NOTIFY_DIM_MUTE      0x00200000\n#define SCARLETT2_USB_NOTIFY_MONITOR       0x00400000\n#define SCARLETT2_USB_NOTIFY_INPUT_OTHER   0x00800000\n#define SCARLETT2_USB_NOTIFY_MONITOR_OTHER 0x01000000\n\n \n#define SCARLETT2_USB_CMD_INIT 0\n#define SCARLETT2_USB_CMD_REQ  2\n#define SCARLETT2_USB_CMD_RESP 3\n\n#define SCARLETT2_USB_INIT_1    0x00000000\n#define SCARLETT2_USB_INIT_2    0x00000002\n#define SCARLETT2_USB_GET_METER 0x00001001\n#define SCARLETT2_USB_GET_MIX   0x00002001\n#define SCARLETT2_USB_SET_MIX   0x00002002\n#define SCARLETT2_USB_GET_MUX   0x00003001\n#define SCARLETT2_USB_SET_MUX   0x00003002\n#define SCARLETT2_USB_GET_SYNC  0x00006004\n#define SCARLETT2_USB_GET_DATA  0x00800000\n#define SCARLETT2_USB_SET_DATA  0x00800001\n#define SCARLETT2_USB_DATA_CMD  0x00800002\n\n#define SCARLETT2_USB_CONFIG_SAVE 6\n\n#define SCARLETT2_USB_VOLUME_STATUS_OFFSET 0x31\n#define SCARLETT2_USB_METER_LEVELS_GET_MAGIC 1\n\n \nstruct scarlett2_usb_volume_status {\n\t \n\tu8 dim_mute[SCARLETT2_DIM_MUTE_COUNT];\n\n\tu8 pad1;\n\n\t \n\ts16 sw_vol[SCARLETT2_ANALOGUE_MAX];\n\n\t \n\ts16 hw_vol[SCARLETT2_ANALOGUE_MAX];\n\n\t \n\tu8 mute_switch[SCARLETT2_ANALOGUE_MAX];\n\n\t \n\tu8 sw_hw_switch[SCARLETT2_ANALOGUE_MAX];\n\n\tu8 pad3[6];\n\n\t \n\ts16 master_vol;\n} __packed;\n\n \nenum {\n\tSCARLETT2_CONFIG_DIM_MUTE = 0,\n\tSCARLETT2_CONFIG_LINE_OUT_VOLUME = 1,\n\tSCARLETT2_CONFIG_MUTE_SWITCH = 2,\n\tSCARLETT2_CONFIG_SW_HW_SWITCH = 3,\n\tSCARLETT2_CONFIG_LEVEL_SWITCH = 4,\n\tSCARLETT2_CONFIG_PAD_SWITCH = 5,\n\tSCARLETT2_CONFIG_MSD_SWITCH = 6,\n\tSCARLETT2_CONFIG_AIR_SWITCH = 7,\n\tSCARLETT2_CONFIG_STANDALONE_SWITCH = 8,\n\tSCARLETT2_CONFIG_PHANTOM_SWITCH = 9,\n\tSCARLETT2_CONFIG_PHANTOM_PERSISTENCE = 10,\n\tSCARLETT2_CONFIG_DIRECT_MONITOR = 11,\n\tSCARLETT2_CONFIG_MONITOR_OTHER_SWITCH = 12,\n\tSCARLETT2_CONFIG_MONITOR_OTHER_ENABLE = 13,\n\tSCARLETT2_CONFIG_TALKBACK_MAP = 14,\n\tSCARLETT2_CONFIG_COUNT = 15\n};\n\n \nstruct scarlett2_config {\n\tu8 offset;\n\tu8 size;\n\tu8 activate;\n};\n\nstatic const struct scarlett2_config\n\tscarlett2_config_items[SCARLETT2_CONFIG_SET_COUNT]\n\t\t\t      [SCARLETT2_CONFIG_COUNT] =\n\n \n{ {\n\t[SCARLETT2_CONFIG_MSD_SWITCH] = {\n\t\t.offset = 0x04, .size = 8, .activate = 6 },\n\n\t[SCARLETT2_CONFIG_PHANTOM_PERSISTENCE] = {\n\t\t.offset = 0x05, .size = 8, .activate = 6 },\n\n\t[SCARLETT2_CONFIG_PHANTOM_SWITCH] = {\n\t\t.offset = 0x06, .size = 8, .activate = 3 },\n\n\t[SCARLETT2_CONFIG_DIRECT_MONITOR] = {\n\t\t.offset = 0x07, .size = 8, .activate = 4 },\n\n\t[SCARLETT2_CONFIG_LEVEL_SWITCH] = {\n\t\t.offset = 0x08, .size = 1, .activate = 7 },\n\n\t[SCARLETT2_CONFIG_AIR_SWITCH] = {\n\t\t.offset = 0x09, .size = 1, .activate = 8 },\n\n \n}, {\n\t[SCARLETT2_CONFIG_DIM_MUTE] = {\n\t\t.offset = 0x31, .size = 8, .activate = 2 },\n\n\t[SCARLETT2_CONFIG_LINE_OUT_VOLUME] = {\n\t\t.offset = 0x34, .size = 16, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_MUTE_SWITCH] = {\n\t\t.offset = 0x5c, .size = 8, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_SW_HW_SWITCH] = {\n\t\t.offset = 0x66, .size = 8, .activate = 3 },\n\n\t[SCARLETT2_CONFIG_LEVEL_SWITCH] = {\n\t\t.offset = 0x7c, .size = 8, .activate = 7 },\n\n\t[SCARLETT2_CONFIG_PAD_SWITCH] = {\n\t\t.offset = 0x84, .size = 8, .activate = 8 },\n\n\t[SCARLETT2_CONFIG_STANDALONE_SWITCH] = {\n\t\t.offset = 0x8d, .size = 8, .activate = 6 },\n\n \n}, {\n\t[SCARLETT2_CONFIG_DIM_MUTE] = {\n\t\t.offset = 0x31, .size = 8, .activate = 2 },\n\n\t[SCARLETT2_CONFIG_LINE_OUT_VOLUME] = {\n\t\t.offset = 0x34, .size = 16, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_MUTE_SWITCH] = {\n\t\t.offset = 0x5c, .size = 8, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_SW_HW_SWITCH] = {\n\t\t.offset = 0x66, .size = 8, .activate = 3 },\n\n\t[SCARLETT2_CONFIG_LEVEL_SWITCH] = {\n\t\t.offset = 0x7c, .size = 8, .activate = 7 },\n\n\t[SCARLETT2_CONFIG_PAD_SWITCH] = {\n\t\t.offset = 0x84, .size = 8, .activate = 8 },\n\n\t[SCARLETT2_CONFIG_AIR_SWITCH] = {\n\t\t.offset = 0x8c, .size = 8, .activate = 8 },\n\n\t[SCARLETT2_CONFIG_STANDALONE_SWITCH] = {\n\t\t.offset = 0x95, .size = 8, .activate = 6 },\n\n\t[SCARLETT2_CONFIG_PHANTOM_SWITCH] = {\n\t\t.offset = 0x9c, .size = 1, .activate = 8 },\n\n\t[SCARLETT2_CONFIG_MSD_SWITCH] = {\n\t\t.offset = 0x9d, .size = 8, .activate = 6 },\n\n\t[SCARLETT2_CONFIG_PHANTOM_PERSISTENCE] = {\n\t\t.offset = 0x9e, .size = 8, .activate = 6 },\n\n\t[SCARLETT2_CONFIG_MONITOR_OTHER_SWITCH] = {\n\t\t.offset = 0x9f, .size = 1, .activate = 10 },\n\n\t[SCARLETT2_CONFIG_MONITOR_OTHER_ENABLE] = {\n\t\t.offset = 0xa0, .size = 1, .activate = 10 },\n\n\t[SCARLETT2_CONFIG_TALKBACK_MAP] = {\n\t\t.offset = 0xb0, .size = 16, .activate = 10 },\n\n \n}, {\n\t[SCARLETT2_CONFIG_DIM_MUTE] = {\n\t\t.offset = 0x31, .size = 8, .activate = 2 },\n\n\t[SCARLETT2_CONFIG_LINE_OUT_VOLUME] = {\n\t\t.offset = 0x34, .size = 16, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_MUTE_SWITCH] = {\n\t\t.offset = 0x5c, .size = 8, .activate = 1 },\n\n\t[SCARLETT2_CONFIG_SW_HW_SWITCH] = {\n\t\t.offset = 0x66, .size = 8, .activate = 3 },\n\n\t[SCARLETT2_CONFIG_LEVEL_SWITCH] = {\n\t\t.offset = 0x7c, .size = 8, .activate = 7 },\n\n\t[SCARLETT2_CONFIG_AIR_SWITCH] = {\n\t\t.offset = 0x95, .size = 8, .activate = 8 },\n\n\t[SCARLETT2_CONFIG_STANDALONE_SWITCH] = {\n\t\t.offset = 0x8d, .size = 8, .activate = 6 },\n} };\n\n \nstruct scarlett2_usb_packet {\n\t__le32 cmd;\n\t__le16 size;\n\t__le16 seq;\n\t__le32 error;\n\t__le32 pad;\n\tu8 data[];\n};\n\nstatic void scarlett2_fill_request_header(struct scarlett2_data *private,\n\t\t\t\t\t  struct scarlett2_usb_packet *req,\n\t\t\t\t\t  u32 cmd, u16 req_size)\n{\n\t \n\tu16 seq = private->scarlett2_seq++;\n\n\treq->cmd = cpu_to_le32(cmd);\n\treq->size = cpu_to_le16(req_size);\n\treq->seq = cpu_to_le16(seq);\n\treq->error = 0;\n\treq->pad = 0;\n}\n\nstatic int scarlett2_usb_tx(struct usb_device *dev, int interface,\n\t\t\t    void *buf, u16 size)\n{\n\treturn snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tSCARLETT2_USB_CMD_REQ,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t0, interface, buf, size);\n}\n\nstatic int scarlett2_usb_rx(struct usb_device *dev, int interface,\n\t\t\t    u32 usb_req, void *buf, u16 size)\n{\n\treturn snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\tusb_req,\n\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t0, interface, buf, size);\n}\n\n \nstatic int scarlett2_usb(\n\tstruct usb_mixer_interface *mixer, u32 cmd,\n\tvoid *req_data, u16 req_size, void *resp_data, u16 resp_size)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tstruct usb_device *dev = mixer->chip->dev;\n\tstruct scarlett2_usb_packet *req, *resp = NULL;\n\tsize_t req_buf_size = struct_size(req, data, req_size);\n\tsize_t resp_buf_size = struct_size(resp, data, resp_size);\n\tint err;\n\n\treq = kmalloc(req_buf_size, GFP_KERNEL);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tresp = kmalloc(resp_buf_size, GFP_KERNEL);\n\tif (!resp) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tmutex_lock(&private->usb_mutex);\n\n\t \n\n\tscarlett2_fill_request_header(private, req, cmd, req_size);\n\n\tif (req_size)\n\t\tmemcpy(req->data, req_data, req_size);\n\n\terr = scarlett2_usb_tx(dev, private->bInterfaceNumber,\n\t\t\t       req, req_buf_size);\n\n\tif (err != req_buf_size) {\n\t\tusb_audio_err(\n\t\t\tmixer->chip,\n\t\t\t\"Scarlett Gen 2/3 USB request result cmd %x was %d\\n\",\n\t\t\tcmd, err);\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\n\terr = scarlett2_usb_rx(dev, private->bInterfaceNumber,\n\t\t\t       SCARLETT2_USB_CMD_RESP,\n\t\t\t       resp, resp_buf_size);\n\n\t \n\n\tif (err != resp_buf_size) {\n\t\tusb_audio_err(\n\t\t\tmixer->chip,\n\t\t\t\"Scarlett Gen 2/3 USB response result cmd %x was %d \"\n\t\t\t\"expected %zu\\n\",\n\t\t\tcmd, err, resp_buf_size);\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (resp->cmd != req->cmd ||\n\t    (resp->seq != req->seq &&\n\t\t(le16_to_cpu(req->seq) != 1 || resp->seq != 0)) ||\n\t    resp_size != le16_to_cpu(resp->size) ||\n\t    resp->error ||\n\t    resp->pad) {\n\t\tusb_audio_err(\n\t\t\tmixer->chip,\n\t\t\t\"Scarlett Gen 2/3 USB invalid response; \"\n\t\t\t   \"cmd tx/rx %d/%d seq %d/%d size %d/%d \"\n\t\t\t   \"error %d pad %d\\n\",\n\t\t\tle32_to_cpu(req->cmd), le32_to_cpu(resp->cmd),\n\t\t\tle16_to_cpu(req->seq), le16_to_cpu(resp->seq),\n\t\t\tresp_size, le16_to_cpu(resp->size),\n\t\t\tle32_to_cpu(resp->error),\n\t\t\tle32_to_cpu(resp->pad));\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (resp_data && resp_size > 0)\n\t\tmemcpy(resp_data, resp->data, resp_size);\n\nunlock:\n\tmutex_unlock(&private->usb_mutex);\nerror:\n\tkfree(req);\n\tkfree(resp);\n\treturn err;\n}\n\n \nstatic int scarlett2_usb_get(\n\tstruct usb_mixer_interface *mixer,\n\tint offset, void *buf, int size)\n{\n\tstruct {\n\t\t__le32 offset;\n\t\t__le32 size;\n\t} __packed req;\n\n\treq.offset = cpu_to_le32(offset);\n\treq.size = cpu_to_le32(size);\n\treturn scarlett2_usb(mixer, SCARLETT2_USB_GET_DATA,\n\t\t\t     &req, sizeof(req), buf, size);\n}\n\n \nstatic int scarlett2_usb_get_config(\n\tstruct usb_mixer_interface *mixer,\n\tint config_item_num, int count, void *buf)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst struct scarlett2_config *config_item =\n\t\t&scarlett2_config_items[info->config_set][config_item_num];\n\tint size, err, i;\n\tu8 *buf_8;\n\tu8 value;\n\n\t \n\tif (config_item->size >= 8) {\n\t\tsize = config_item->size / 8 * count;\n\t\terr = scarlett2_usb_get(mixer, config_item->offset, buf, size);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (size == 2) {\n\t\t\tu16 *buf_16 = buf;\n\n\t\t\tfor (i = 0; i < count; i++, buf_16++)\n\t\t\t\t*buf_16 = le16_to_cpu(*(__le16 *)buf_16);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\terr = scarlett2_usb_get(mixer, config_item->offset, &value, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tbuf_8 = buf;\n\tfor (i = 0; i < 8 && i < count; i++, value >>= 1)\n\t\t*buf_8++ = value & 1;\n\n\treturn 0;\n}\n\n \nstatic void scarlett2_config_save(struct usb_mixer_interface *mixer)\n{\n\t__le32 req = cpu_to_le32(SCARLETT2_USB_CONFIG_SAVE);\n\n\tint err = scarlett2_usb(mixer, SCARLETT2_USB_DATA_CMD,\n\t\t\t\t&req, sizeof(u32),\n\t\t\t\tNULL, 0);\n\tif (err < 0)\n\t\tusb_audio_err(mixer->chip, \"config save failed: %d\\n\", err);\n}\n\n \nstatic void scarlett2_config_save_work(struct work_struct *work)\n{\n\tstruct scarlett2_data *private =\n\t\tcontainer_of(work, struct scarlett2_data, work.work);\n\n\tscarlett2_config_save(private->mixer);\n}\n\n \nstatic int scarlett2_usb_set_config(\n\tstruct usb_mixer_interface *mixer,\n\tint config_item_num, int index, int value)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst struct scarlett2_config *config_item =\n\t       &scarlett2_config_items[info->config_set][config_item_num];\n\tstruct {\n\t\t__le32 offset;\n\t\t__le32 bytes;\n\t\t__le32 value;\n\t} __packed req;\n\t__le32 req2;\n\tint offset, size;\n\tint err;\n\n\t \n\tcancel_delayed_work_sync(&private->work);\n\n\t \n\tif (config_item->size >= 8) {\n\t\tsize = config_item->size / 8;\n\t\toffset = config_item->offset + index * size;\n\n\t \n\t} else {\n\t\tu8 tmp;\n\n\t\tsize = 1;\n\t\toffset = config_item->offset;\n\n\t\terr = scarlett2_usb_get(mixer, offset, &tmp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (value)\n\t\t\ttmp |= (1 << index);\n\t\telse\n\t\t\ttmp &= ~(1 << index);\n\n\t\tvalue = tmp;\n\t}\n\n\t \n\treq.offset = cpu_to_le32(offset);\n\treq.bytes = cpu_to_le32(size);\n\treq.value = cpu_to_le32(value);\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_SET_DATA,\n\t\t\t    &req, sizeof(u32) * 2 + size,\n\t\t\t    NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treq2 = cpu_to_le32(config_item->activate);\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_DATA_CMD,\n\t\t\t    &req2, sizeof(req2), NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (config_item->activate != SCARLETT2_USB_CONFIG_SAVE)\n\t\tschedule_delayed_work(&private->work, msecs_to_jiffies(2000));\n\n\treturn 0;\n}\n\n \nstatic int scarlett2_usb_get_sync_status(\n\tstruct usb_mixer_interface *mixer,\n\tu8 *sync)\n{\n\t__le32 data;\n\tint err;\n\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_GET_SYNC,\n\t\t\t    NULL, 0, &data, sizeof(data));\n\tif (err < 0)\n\t\treturn err;\n\n\t*sync = !!data;\n\treturn 0;\n}\n\n \nstatic int scarlett2_usb_get_volume_status(\n\tstruct usb_mixer_interface *mixer,\n\tstruct scarlett2_usb_volume_status *buf)\n{\n\treturn scarlett2_usb_get(mixer, SCARLETT2_USB_VOLUME_STATUS_OFFSET,\n\t\t\t\t buf, sizeof(*buf));\n}\n\n \nstatic int scarlett2_usb_get_mix(struct usb_mixer_interface *mixer,\n\t\t\t\t int mix_num)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tint num_mixer_in =\n\t\tinfo->port_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_OUT];\n\tint err, i, j, k;\n\n\tstruct {\n\t\t__le16 mix_num;\n\t\t__le16 count;\n\t} __packed req;\n\n\t__le16 data[SCARLETT2_INPUT_MIX_MAX];\n\n\treq.mix_num = cpu_to_le16(mix_num);\n\treq.count = cpu_to_le16(num_mixer_in);\n\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_GET_MIX,\n\t\t\t    &req, sizeof(req),\n\t\t\t    data, num_mixer_in * sizeof(u16));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0, j = mix_num * num_mixer_in; i < num_mixer_in; i++, j++) {\n\t\tu16 mixer_value = le16_to_cpu(data[i]);\n\n\t\tfor (k = 0; k < SCARLETT2_MIXER_VALUE_COUNT; k++)\n\t\t\tif (scarlett2_mixer_values[k] >= mixer_value)\n\t\t\t\tbreak;\n\t\tif (k == SCARLETT2_MIXER_VALUE_COUNT)\n\t\t\tk = SCARLETT2_MIXER_MAX_VALUE;\n\t\tprivate->mix[j] = k;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int scarlett2_usb_set_mix(struct usb_mixer_interface *mixer,\n\t\t\t\t int mix_num)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tstruct {\n\t\t__le16 mix_num;\n\t\t__le16 data[SCARLETT2_INPUT_MIX_MAX];\n\t} __packed req;\n\n\tint i, j;\n\tint num_mixer_in =\n\t\tinfo->port_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_OUT];\n\n\treq.mix_num = cpu_to_le16(mix_num);\n\n\tfor (i = 0, j = mix_num * num_mixer_in; i < num_mixer_in; i++, j++)\n\t\treq.data[i] = cpu_to_le16(\n\t\t\tscarlett2_mixer_values[private->mix[j]]\n\t\t);\n\n\treturn scarlett2_usb(mixer, SCARLETT2_USB_SET_MIX,\n\t\t\t     &req, (num_mixer_in + 1) * sizeof(u16),\n\t\t\t     NULL, 0);\n}\n\n \nstatic u32 scarlett2_mux_src_num_to_id(\n\tconst int port_count[][SCARLETT2_PORT_DIRNS], int num)\n{\n\tint port_type;\n\n\tfor (port_type = 0;\n\t     port_type < SCARLETT2_PORT_TYPE_COUNT;\n\t     port_type++) {\n\t\tif (num < port_count[port_type][SCARLETT2_PORT_IN])\n\t\t\treturn scarlett2_ports[port_type].id | num;\n\t\tnum -= port_count[port_type][SCARLETT2_PORT_IN];\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic u32 scarlett2_mux_id_to_num(\n\tconst int port_count[][SCARLETT2_PORT_DIRNS], int direction, u32 id)\n{\n\tint port_type;\n\tint port_num = 0;\n\n\tfor (port_type = 0;\n\t     port_type < SCARLETT2_PORT_TYPE_COUNT;\n\t     port_type++) {\n\t\tint base = scarlett2_ports[port_type].id;\n\t\tint count = port_count[port_type][direction];\n\n\t\tif (id >= base && id < base + count)\n\t\t\treturn port_num + id - base;\n\t\tport_num += count;\n\t}\n\n\t \n\treturn -1;\n}\n\n \nstatic void scarlett2_usb_populate_mux(struct scarlett2_data *private,\n\t\t\t\t       u32 mux_entry)\n{\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\n\tint dst_idx, src_idx;\n\n\tdst_idx = scarlett2_mux_id_to_num(port_count, SCARLETT2_PORT_OUT,\n\t\t\t\t\t  mux_entry & 0xFFF);\n\tif (dst_idx < 0)\n\t\treturn;\n\n\tif (dst_idx >= private->num_mux_dsts) {\n\t\tusb_audio_err(private->mixer->chip,\n\t\t\t\"BUG: scarlett2_mux_id_to_num(%06x, OUT): %d >= %d\",\n\t\t\tmux_entry, dst_idx, private->num_mux_dsts);\n\t\treturn;\n\t}\n\n\tsrc_idx = scarlett2_mux_id_to_num(port_count, SCARLETT2_PORT_IN,\n\t\t\t\t\t  mux_entry >> 12);\n\tif (src_idx < 0)\n\t\treturn;\n\n\tif (src_idx >= private->num_mux_srcs) {\n\t\tusb_audio_err(private->mixer->chip,\n\t\t\t\"BUG: scarlett2_mux_id_to_num(%06x, IN): %d >= %d\",\n\t\t\tmux_entry, src_idx, private->num_mux_srcs);\n\t\treturn;\n\t}\n\n\tprivate->mux[dst_idx] = src_idx;\n}\n\n \nstatic int scarlett2_usb_get_mux(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint count = private->num_mux_dsts;\n\tint err, i;\n\n\tstruct {\n\t\t__le16 num;\n\t\t__le16 count;\n\t} __packed req;\n\n\t__le32 data[SCARLETT2_MUX_MAX];\n\n\tprivate->mux_updated = 0;\n\n\treq.num = 0;\n\treq.count = cpu_to_le16(count);\n\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_GET_MUX,\n\t\t\t    &req, sizeof(req),\n\t\t\t    data, count * sizeof(u32));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < count; i++)\n\t\tscarlett2_usb_populate_mux(private, le32_to_cpu(data[i]));\n\n\treturn 0;\n}\n\n \nstatic int scarlett2_usb_set_mux(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint table;\n\n\tstruct {\n\t\t__le16 pad;\n\t\t__le16 num;\n\t\t__le32 data[SCARLETT2_MUX_MAX];\n\t} __packed req;\n\n\treq.pad = 0;\n\n\t \n\tfor (table = 0; table < SCARLETT2_MUX_TABLES; table++) {\n\t\tconst struct scarlett2_mux_entry *entry;\n\n\t\t \n\t\tint i = 0, err;\n\n\t\treq.num = cpu_to_le16(table);\n\n\t\t \n\t\tfor (entry = info->mux_assignment[table];\n\t\t     entry->count;\n\t\t     entry++) {\n\t\t\tint j;\n\t\t\tint port_type = entry->port_type;\n\t\t\tint port_idx = entry->start;\n\t\t\tint mux_idx = scarlett2_get_port_start_num(port_count,\n\t\t\t\tSCARLETT2_PORT_OUT, port_type) + port_idx;\n\t\t\tint dst_id = scarlett2_ports[port_type].id + port_idx;\n\n\t\t\t \n\t\t\tif (!dst_id) {\n\t\t\t\tfor (j = 0; j < entry->count; j++)\n\t\t\t\t\treq.data[i++] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (j = 0; j < entry->count; j++) {\n\t\t\t\tint src_id = scarlett2_mux_src_num_to_id(\n\t\t\t\t\tport_count, private->mux[mux_idx++]);\n\t\t\t\treq.data[i++] = cpu_to_le32(dst_id |\n\t\t\t\t\t\t\t    src_id << 12);\n\t\t\t\tdst_id++;\n\t\t\t}\n\t\t}\n\n\t\terr = scarlett2_usb(mixer, SCARLETT2_USB_SET_MUX,\n\t\t\t\t    &req, (i + 1) * sizeof(u32),\n\t\t\t\t    NULL, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int scarlett2_usb_get_meter_levels(struct usb_mixer_interface *mixer,\n\t\t\t\t\t  u16 num_meters, u16 *levels)\n{\n\tstruct {\n\t\t__le16 pad;\n\t\t__le16 num_meters;\n\t\t__le32 magic;\n\t} __packed req;\n\tu32 resp[SCARLETT2_MAX_METERS];\n\tint i, err;\n\n\treq.pad = 0;\n\treq.num_meters = cpu_to_le16(num_meters);\n\treq.magic = cpu_to_le32(SCARLETT2_USB_METER_LEVELS_GET_MAGIC);\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_GET_METER,\n\t\t\t    &req, sizeof(req), resp, num_meters * sizeof(u32));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < num_meters; i++)\n\t\tlevels[i] = resp[i];\n\n\treturn 0;\n}\n\n \n\n \nstatic int scarlett2_add_new_ctl(struct usb_mixer_interface *mixer,\n\t\t\t\t const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t int index, int channels, const char *name,\n\t\t\t\t struct snd_kcontrol **kctl_return)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\t \n\telem->head.mixer = mixer;\n\telem->control = index;\n\telem->head.id = 0;\n\telem->channels = channels;\n\telem->val_type = USB_MIXER_BESPOKEN;\n\n\tkctl = snd_ctl_new1(ncontrol, elem);\n\tif (!kctl) {\n\t\tkfree(elem);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tstrscpy(kctl->id.name, name, sizeof(kctl->id.name));\n\n\terr = snd_usb_mixer_add_control(&elem->head, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (kctl_return)\n\t\t*kctl_return = kctl;\n\n\treturn 0;\n}\n\n \n\n \nstatic int scarlett2_update_sync(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tprivate->sync_updated = 0;\n\treturn scarlett2_usb_get_sync_status(mixer, &private->sync);\n}\n\nstatic int scarlett2_sync_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *texts[2] = {\n\t\t\"Unlocked\", \"Locked\"\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int scarlett2_sync_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->sync_updated) {\n\t\terr = scarlett2_update_sync(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->sync;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_sync_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.name = \"\",\n\t.info = scarlett2_sync_ctl_info,\n\t.get  = scarlett2_sync_ctl_get\n};\n\nstatic int scarlett2_add_sync_ctl(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\t \n\tif (private->info->config_set == SCARLETT2_CONFIG_SET_NO_MIXER)\n\t\treturn 0;\n\n\treturn scarlett2_add_new_ctl(mixer, &scarlett2_sync_ctl,\n\t\t\t\t     0, 1, \"Sync Status\", &private->sync_ctl);\n}\n\n \n\n \nstatic int scarlett2_update_volumes(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tstruct scarlett2_usb_volume_status volume_status;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\tint err, i;\n\tint mute;\n\n\tprivate->vol_updated = 0;\n\n\terr = scarlett2_usb_get_volume_status(mixer, &volume_status);\n\tif (err < 0)\n\t\treturn err;\n\n\tprivate->master_vol = clamp(\n\t\tvolume_status.master_vol + SCARLETT2_VOLUME_BIAS,\n\t\t0, SCARLETT2_VOLUME_BIAS);\n\n\tif (info->line_out_hw_vol)\n\t\tfor (i = 0; i < SCARLETT2_DIM_MUTE_COUNT; i++)\n\t\t\tprivate->dim_mute[i] = !!volume_status.dim_mute[i];\n\n\tmute = private->dim_mute[SCARLETT2_BUTTON_MUTE];\n\n\tfor (i = 0; i < num_line_out; i++)\n\t\tif (private->vol_sw_hw_switch[i]) {\n\t\t\tprivate->vol[i] = private->master_vol;\n\t\t\tprivate->mute_switch[i] = mute;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int scarlett2_volume_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = elem->channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SCARLETT2_VOLUME_BIAS;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int scarlett2_master_volume_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->vol_updated) {\n\t\terr = scarlett2_update_volumes(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] = private->master_vol;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int line_out_remap(struct scarlett2_data *private, int index)\n{\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint line_out_count =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\n\tif (!info->line_out_remap_enable)\n\t\treturn index;\n\n\tif (index >= line_out_count)\n\t\treturn index;\n\n\treturn info->line_out_remap[index];\n}\n\nstatic int scarlett2_volume_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->vol_updated) {\n\t\terr = scarlett2_update_volumes(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] = private->vol[index];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_volume_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->vol[index];\n\tval = ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->vol[index] = val;\n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_LINE_OUT_VOLUME,\n\t\t\t\t       index, val - SCARLETT2_VOLUME_BIAS);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const DECLARE_TLV_DB_MINMAX(\n\tdb_scale_scarlett2_gain, -SCARLETT2_VOLUME_BIAS * 100, 0\n);\n\nstatic const struct snd_kcontrol_new scarlett2_master_volume_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"\",\n\t.info = scarlett2_volume_ctl_info,\n\t.get  = scarlett2_master_volume_ctl_get,\n\t.private_value = 0,  \n\t.tlv = { .p = db_scale_scarlett2_gain }\n};\n\nstatic const struct snd_kcontrol_new scarlett2_line_out_volume_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"\",\n\t.info = scarlett2_volume_ctl_info,\n\t.get  = scarlett2_volume_ctl_get,\n\t.put  = scarlett2_volume_ctl_put,\n\t.private_value = 0,  \n\t.tlv = { .p = db_scale_scarlett2_gain }\n};\n\n \n\nstatic int scarlett2_mute_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->vol_updated) {\n\t\terr = scarlett2_update_volumes(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] = private->mute_switch[index];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_mute_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->mute_switch[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->mute_switch[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_MUTE_SWITCH,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_mute_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_mute_ctl_get,\n\t.put  = scarlett2_mute_ctl_put,\n};\n\n \n\nstatic void scarlett2_sw_hw_ctl_ro(struct scarlett2_data *private, int index)\n{\n\tprivate->sw_hw_ctls[index]->vd[0].access &=\n\t\t~SNDRV_CTL_ELEM_ACCESS_WRITE;\n}\n\nstatic void scarlett2_sw_hw_ctl_rw(struct scarlett2_data *private, int index)\n{\n\tprivate->sw_hw_ctls[index]->vd[0].access |=\n\t\tSNDRV_CTL_ELEM_ACCESS_WRITE;\n}\n\nstatic int scarlett2_sw_hw_enum_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const values[2] = {\n\t\t\"SW\", \"HW\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, values);\n}\n\nstatic int scarlett2_sw_hw_enum_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\n\tucontrol->value.enumerated.item[0] = private->vol_sw_hw_switch[index];\n\treturn 0;\n}\n\nstatic void scarlett2_vol_ctl_set_writable(struct usb_mixer_interface *mixer,\n\t\t\t\t\t   int index, int value)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tstruct snd_card *card = mixer->chip->card;\n\n\t \n\tif (value) {\n\t\tprivate->vol_ctls[index]->vd[0].access |=\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE;\n\t\tprivate->mute_ctls[index]->vd[0].access |=\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE;\n\t} else {\n\t\tprivate->vol_ctls[index]->vd[0].access &=\n\t\t\t~SNDRV_CTL_ELEM_ACCESS_WRITE;\n\t\tprivate->mute_ctls[index]->vd[0].access &=\n\t\t\t~SNDRV_CTL_ELEM_ACCESS_WRITE;\n\t}\n\n\t \n\tsnd_ctl_notify(card,\n\t\t       SNDRV_CTL_EVENT_MASK_VALUE | SNDRV_CTL_EVENT_MASK_INFO,\n\t\t       &private->vol_ctls[index]->id);\n\tsnd_ctl_notify(card,\n\t\t       SNDRV_CTL_EVENT_MASK_VALUE | SNDRV_CTL_EVENT_MASK_INFO,\n\t\t       &private->mute_ctls[index]->id);\n}\n\nstatic int scarlett2_sw_hw_change(struct usb_mixer_interface *mixer,\n\t\t\t\t  int ctl_index, int val)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, ctl_index);\n\tint err;\n\n\tprivate->vol_sw_hw_switch[index] = val;\n\n\t \n\tscarlett2_vol_ctl_set_writable(mixer, ctl_index, !val);\n\n\t \n\tprivate->vol[index] = private->master_vol;\n\tprivate->mute_switch[index] = private->dim_mute[SCARLETT2_BUTTON_MUTE];\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_LINE_OUT_VOLUME,\n\t\tindex, private->master_vol - SCARLETT2_VOLUME_BIAS);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_MUTE_SWITCH,\n\t\tindex, private->dim_mute[SCARLETT2_BUTTON_MUTE]);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_SW_HW_SWITCH,\n\t\t\t\t\tindex, val);\n}\n\nstatic int scarlett2_sw_hw_enum_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint ctl_index = elem->control;\n\tint index = line_out_remap(private, ctl_index);\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->vol_sw_hw_switch[index];\n\tval = !!ucontrol->value.enumerated.item[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\terr = scarlett2_sw_hw_change(mixer, ctl_index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_sw_hw_enum_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett2_sw_hw_enum_ctl_info,\n\t.get  = scarlett2_sw_hw_enum_ctl_get,\n\t.put  = scarlett2_sw_hw_enum_ctl_put,\n};\n\n \n\nstatic int scarlett2_update_input_other(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tprivate->input_other_updated = 0;\n\n\tif (info->level_input_count) {\n\t\tint err = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_LEVEL_SWITCH,\n\t\t\tinfo->level_input_count + info->level_input_first,\n\t\t\tprivate->level_switch);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (info->pad_input_count) {\n\t\tint err = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_PAD_SWITCH,\n\t\t\tinfo->pad_input_count, private->pad_switch);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (info->air_input_count) {\n\t\tint err = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_AIR_SWITCH,\n\t\t\tinfo->air_input_count, private->air_switch);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (info->phantom_count) {\n\t\tint err = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_PHANTOM_SWITCH,\n\t\t\tinfo->phantom_count, private->phantom_switch);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_PHANTOM_PERSISTENCE,\n\t\t\t1, &private->phantom_persistence);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int scarlett2_level_enum_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const values[2] = {\n\t\t\"Line\", \"Inst\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, values);\n}\n\nstatic int scarlett2_level_enum_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tint index = elem->control + info->level_input_first;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->input_other_updated) {\n\t\terr = scarlett2_update_input_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->level_switch[index];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_level_enum_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tint index = elem->control + info->level_input_first;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->level_switch[index];\n\tval = !!ucontrol->value.enumerated.item[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->level_switch[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_LEVEL_SWITCH,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_level_enum_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett2_level_enum_ctl_info,\n\t.get  = scarlett2_level_enum_ctl_get,\n\t.put  = scarlett2_level_enum_ctl_put,\n};\n\n \n\nstatic int scarlett2_pad_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->input_other_updated) {\n\t\terr = scarlett2_update_input_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] =\n\t\tprivate->pad_switch[elem->control];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_pad_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint index = elem->control;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->pad_switch[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->pad_switch[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_PAD_SWITCH,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_pad_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_pad_ctl_get,\n\t.put  = scarlett2_pad_ctl_put,\n};\n\n \n\nstatic int scarlett2_air_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->input_other_updated) {\n\t\terr = scarlett2_update_input_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] = private->air_switch[elem->control];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_air_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint index = elem->control;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->air_switch[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->air_switch[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_AIR_SWITCH,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_air_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_air_ctl_get,\n\t.put  = scarlett2_air_ctl_put,\n};\n\n \n\nstatic int scarlett2_phantom_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->input_other_updated) {\n\t\terr = scarlett2_update_input_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] =\n\t\tprivate->phantom_switch[elem->control];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_phantom_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint index = elem->control;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->phantom_switch[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->phantom_switch[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_PHANTOM_SWITCH,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_phantom_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_phantom_ctl_get,\n\t.put  = scarlett2_phantom_ctl_put,\n};\n\n \n\nstatic int scarlett2_phantom_persistence_ctl_get(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\n\tucontrol->value.integer.value[0] = private->phantom_persistence;\n\treturn 0;\n}\n\nstatic int scarlett2_phantom_persistence_ctl_put(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint index = elem->control;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->phantom_persistence;\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->phantom_persistence = val;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_PHANTOM_PERSISTENCE, index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_phantom_persistence_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_phantom_persistence_ctl_get,\n\t.put  = scarlett2_phantom_persistence_ctl_put,\n};\n\n \n\nstatic int scarlett2_update_monitor_other(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tint err;\n\n\t \n\tu8 monitor_other_enable[2];\n\n\t \n\tu8 monitor_other_switch[2];\n\n\tprivate->monitor_other_updated = 0;\n\n\tif (info->direct_monitor)\n\t\treturn scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_DIRECT_MONITOR,\n\t\t\t1, &private->direct_monitor_switch);\n\n\t \n\tif (!info->has_speaker_switching)\n\t\treturn 0;\n\n\terr = scarlett2_usb_get_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_ENABLE,\n\t\t2, monitor_other_enable);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = scarlett2_usb_get_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_SWITCH,\n\t\t2, monitor_other_switch);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!monitor_other_enable[0])\n\t\tprivate->speaker_switching_switch = 0;\n\telse\n\t\tprivate->speaker_switching_switch = monitor_other_switch[0] + 1;\n\n\tif (info->has_talkback) {\n\t\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] =\n\t\t\tinfo->port_count;\n\t\tint num_mixes =\n\t\t\tport_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_IN];\n\t\tu16 bitmap;\n\t\tint i;\n\n\t\tif (!monitor_other_enable[1])\n\t\t\tprivate->talkback_switch = 0;\n\t\telse\n\t\t\tprivate->talkback_switch = monitor_other_switch[1] + 1;\n\n\t\terr = scarlett2_usb_get_config(mixer,\n\t\t\t\t\t       SCARLETT2_CONFIG_TALKBACK_MAP,\n\t\t\t\t\t       1, &bitmap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tfor (i = 0; i < num_mixes; i++, bitmap >>= 1)\n\t\t\tprivate->talkback_map[i] = bitmap & 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int scarlett2_direct_monitor_ctl_get(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->monitor_other_updated) {\n\t\terr = scarlett2_update_monitor_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->direct_monitor_switch;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_direct_monitor_ctl_put(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint index = elem->control;\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->direct_monitor_switch;\n\tval = min(ucontrol->value.enumerated.item[0], 2U);\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->direct_monitor_switch = val;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_DIRECT_MONITOR, index, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_direct_monitor_stereo_enum_ctl_info(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const values[3] = {\n\t\t\"Off\", \"Mono\", \"Stereo\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, values);\n}\n\n \nstatic const struct snd_kcontrol_new scarlett2_direct_monitor_ctl[2] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get  = scarlett2_direct_monitor_ctl_get,\n\t\t.put  = scarlett2_direct_monitor_ctl_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"\",\n\t\t.info = scarlett2_direct_monitor_stereo_enum_ctl_info,\n\t\t.get  = scarlett2_direct_monitor_ctl_get,\n\t\t.put  = scarlett2_direct_monitor_ctl_put,\n\t}\n};\n\nstatic int scarlett2_add_direct_monitor_ctl(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst char *s;\n\n\tif (!info->direct_monitor)\n\t\treturn 0;\n\n\ts = info->direct_monitor == 1\n\t      ? \"Direct Monitor Playback Switch\"\n\t      : \"Direct Monitor Playback Enum\";\n\n\treturn scarlett2_add_new_ctl(\n\t\tmixer, &scarlett2_direct_monitor_ctl[info->direct_monitor - 1],\n\t\t0, 1, s, &private->direct_monitor_ctl);\n}\n\n \n\nstatic int scarlett2_speaker_switch_enum_ctl_info(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const values[3] = {\n\t\t\"Off\", \"Main\", \"Alt\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, values);\n}\n\nstatic int scarlett2_speaker_switch_enum_ctl_get(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->monitor_other_updated) {\n\t\terr = scarlett2_update_monitor_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->speaker_switching_switch;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\n \nstatic int scarlett2_speaker_switch_enable(struct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint i, err;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint index = line_out_remap(private, i);\n\n\t\t \n\t\tif (!private->vol_sw_hw_switch[index]) {\n\t\t\terr = scarlett2_sw_hw_change(private->mixer, i, 1);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tscarlett2_sw_hw_ctl_ro(private, i);\n\t\tsnd_ctl_notify(card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t\t SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &private->sw_hw_ctls[i]->id);\n\t}\n\n\t \n\tprivate->speaker_switching_switched = 1;\n\n\treturn 0;\n}\n\n \nstatic void scarlett2_speaker_switch_disable(struct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tscarlett2_sw_hw_ctl_rw(private, i);\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &private->sw_hw_ctls[i]->id);\n\t}\n\n\t \n\tprivate->speaker_switching_switched = 1;\n}\n\nstatic int scarlett2_speaker_switch_enum_ctl_put(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->speaker_switching_switch;\n\tval = min(ucontrol->value.enumerated.item[0], 2U);\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->speaker_switching_switch = val;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_ENABLE,\n\t\t0, !!val);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_SWITCH,\n\t\t0, val == 2);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\tif (!oval && val)\n\t\terr = scarlett2_speaker_switch_enable(mixer);\n\telse if (oval && !val)\n\t\tscarlett2_speaker_switch_disable(mixer);\n\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_speaker_switch_enum_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett2_speaker_switch_enum_ctl_info,\n\t.get  = scarlett2_speaker_switch_enum_ctl_get,\n\t.put  = scarlett2_speaker_switch_enum_ctl_put,\n};\n\nstatic int scarlett2_add_speaker_switch_ctl(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tif (!info->has_speaker_switching)\n\t\treturn 0;\n\n\treturn scarlett2_add_new_ctl(\n\t\tmixer, &scarlett2_speaker_switch_enum_ctl,\n\t\t0, 1, \"Speaker Switching Playback Enum\",\n\t\t&private->speaker_switching_ctl);\n}\n\n \n\nstatic int scarlett2_talkback_enum_ctl_info(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const values[3] = {\n\t\t\"Disabled\", \"Off\", \"On\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, values);\n}\n\nstatic int scarlett2_talkback_enum_ctl_get(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->monitor_other_updated) {\n\t\terr = scarlett2_update_monitor_other(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->talkback_switch;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_talkback_enum_ctl_put(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->talkback_switch;\n\tval = min(ucontrol->value.enumerated.item[0], 2U);\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->talkback_switch = val;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_ENABLE,\n\t\t1, !!val);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\terr = scarlett2_usb_set_config(\n\t\tmixer, SCARLETT2_CONFIG_MONITOR_OTHER_SWITCH,\n\t\t1, val == 2);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_talkback_enum_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett2_talkback_enum_ctl_info,\n\t.get  = scarlett2_talkback_enum_ctl_get,\n\t.put  = scarlett2_talkback_enum_ctl_put,\n};\n\nstatic int scarlett2_talkback_map_ctl_get(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = elem->control;\n\n\tucontrol->value.integer.value[0] = private->talkback_map[index];\n\n\treturn 0;\n}\n\nstatic int scarlett2_talkback_map_ctl_put(\n\tstruct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] =\n\t\tprivate->info->port_count;\n\tint num_mixes = port_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_IN];\n\n\tint index = elem->control;\n\tint oval, val, err = 0, i;\n\tu16 bitmap = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->talkback_map[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->talkback_map[index] = val;\n\n\tfor (i = 0; i < num_mixes; i++)\n\t\tbitmap |= private->talkback_map[i] << i;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_TALKBACK_MAP,\n\t\t\t\t       0, bitmap);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_talkback_map_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_talkback_map_ctl_get,\n\t.put  = scarlett2_talkback_map_ctl_put,\n};\n\nstatic int scarlett2_add_talkback_ctls(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_mixes = port_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_IN];\n\tint err, i;\n\tchar s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tif (!info->has_talkback)\n\t\treturn 0;\n\n\terr = scarlett2_add_new_ctl(\n\t\tmixer, &scarlett2_talkback_enum_ctl,\n\t\t0, 1, \"Talkback Playback Enum\",\n\t\t&private->talkback_ctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < num_mixes; i++) {\n\t\tsnprintf(s, sizeof(s),\n\t\t\t \"Talkback Mix %c Playback Switch\", i + 'A');\n\t\terr = scarlett2_add_new_ctl(mixer, &scarlett2_talkback_map_ctl,\n\t\t\t\t\t    i, 1, s, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int scarlett2_dim_mute_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->vol_updated) {\n\t\terr = scarlett2_update_volumes(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.integer.value[0] = private->dim_mute[elem->control];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_dim_mute_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\n\tint index = elem->control;\n\tint oval, val, err = 0, i;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->dim_mute[index];\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->dim_mute[index] = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_DIM_MUTE,\n\t\t\t\t       index, val);\n\tif (err == 0)\n\t\terr = 1;\n\n\tif (index == SCARLETT2_BUTTON_MUTE)\n\t\tfor (i = 0; i < num_line_out; i++) {\n\t\t\tint line_index = line_out_remap(private, i);\n\n\t\t\tif (private->vol_sw_hw_switch[line_index]) {\n\t\t\t\tprivate->mute_switch[line_index] = val;\n\t\t\t\tsnd_ctl_notify(mixer->chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t       &private->mute_ctls[i]->id);\n\t\t\t}\n\t\t}\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_dim_mute_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_dim_mute_ctl_get,\n\t.put  = scarlett2_dim_mute_ctl_put\n};\n\n \n\nstatic int scarlett2_add_line_out_ctls(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\tint err, i;\n\tchar s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\t \n\tif (info->line_out_hw_vol) {\n\t\tsnprintf(s, sizeof(s), \"Master HW Playback Volume\");\n\t\terr = scarlett2_add_new_ctl(mixer,\n\t\t\t\t\t    &scarlett2_master_volume_ctl,\n\t\t\t\t\t    0, 1, s, &private->master_vol_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < num_line_out; i++) {\n\t\tint index = line_out_remap(private, i);\n\n\t\t \n\t\tif (info->line_out_descrs[i])\n\t\t\tsnprintf(s, sizeof(s),\n\t\t\t\t \"Line %02d (%s) Playback Volume\",\n\t\t\t\t i + 1, info->line_out_descrs[i]);\n\t\telse\n\t\t\tsnprintf(s, sizeof(s),\n\t\t\t\t \"Line %02d Playback Volume\",\n\t\t\t\t i + 1);\n\t\terr = scarlett2_add_new_ctl(mixer,\n\t\t\t\t\t    &scarlett2_line_out_volume_ctl,\n\t\t\t\t\t    i, 1, s, &private->vol_ctls[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tsnprintf(s, sizeof(s),\n\t\t\t \"Line %02d Mute Playback Switch\",\n\t\t\t i + 1);\n\t\terr = scarlett2_add_new_ctl(mixer,\n\t\t\t\t\t    &scarlett2_mute_ctl,\n\t\t\t\t\t    i, 1, s,\n\t\t\t\t\t    &private->mute_ctls[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (private->vol_sw_hw_switch[index])\n\t\t\tscarlett2_vol_ctl_set_writable(mixer, i, 0);\n\n\t\t \n\t\tif (info->line_out_hw_vol) {\n\t\t\tsnprintf(s, sizeof(s),\n\t\t\t\t \"Line Out %02d Volume Control Playback Enum\",\n\t\t\t\t i + 1);\n\t\t\terr = scarlett2_add_new_ctl(mixer,\n\t\t\t\t\t\t    &scarlett2_sw_hw_enum_ctl,\n\t\t\t\t\t\t    i, 1, s,\n\t\t\t\t\t\t    &private->sw_hw_ctls[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\tif (private->speaker_switching_switch && i < 4)\n\t\t\t\tscarlett2_sw_hw_ctl_ro(private, i);\n\t\t}\n\t}\n\n\t \n\tif (info->line_out_hw_vol)\n\t\tfor (i = 0; i < SCARLETT2_DIM_MUTE_COUNT; i++) {\n\t\t\terr = scarlett2_add_new_ctl(\n\t\t\t\tmixer, &scarlett2_dim_mute_ctl,\n\t\t\t\ti, 1, scarlett2_dim_mute_names[i],\n\t\t\t\t&private->dim_mute_ctls[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n\n \n\nstatic int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tint err, i;\n\tchar s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tconst char *fmt = \"Line In %d %s Capture %s\";\n\tconst char *fmt2 = \"Line In %d-%d %s Capture %s\";\n\n\t \n\tfor (i = 0; i < info->level_input_count; i++) {\n\t\tsnprintf(s, sizeof(s), fmt, i + 1 + info->level_input_first,\n\t\t\t \"Level\", \"Enum\");\n\t\terr = scarlett2_add_new_ctl(mixer, &scarlett2_level_enum_ctl,\n\t\t\t\t\t    i, 1, s, &private->level_ctls[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < info->pad_input_count; i++) {\n\t\tsnprintf(s, sizeof(s), fmt, i + 1, \"Pad\", \"Switch\");\n\t\terr = scarlett2_add_new_ctl(mixer, &scarlett2_pad_ctl,\n\t\t\t\t\t    i, 1, s, &private->pad_ctls[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < info->air_input_count; i++) {\n\t\tsnprintf(s, sizeof(s), fmt, i + 1, \"Air\", \"Switch\");\n\t\terr = scarlett2_add_new_ctl(mixer, &scarlett2_air_ctl,\n\t\t\t\t\t    i, 1, s, &private->air_ctls[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (info->inputs_per_phantom == 1) {\n\t\tfor (i = 0; i < info->phantom_count; i++) {\n\t\t\tscnprintf(s, sizeof(s), fmt, i + 1,\n\t\t\t\t  \"Phantom Power\", \"Switch\");\n\t\t\terr = scarlett2_add_new_ctl(\n\t\t\t\tmixer, &scarlett2_phantom_ctl,\n\t\t\t\ti, 1, s, &private->phantom_ctls[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else if (info->inputs_per_phantom > 1) {\n\t\tfor (i = 0; i < info->phantom_count; i++) {\n\t\t\tint from = i * info->inputs_per_phantom + 1;\n\t\t\tint to = (i + 1) * info->inputs_per_phantom;\n\n\t\t\tscnprintf(s, sizeof(s), fmt2, from, to,\n\t\t\t\t  \"Phantom Power\", \"Switch\");\n\t\t\terr = scarlett2_add_new_ctl(\n\t\t\t\tmixer, &scarlett2_phantom_ctl,\n\t\t\t\ti, 1, s, &private->phantom_ctls[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (info->phantom_count) {\n\t\terr = scarlett2_add_new_ctl(\n\t\t\tmixer, &scarlett2_phantom_persistence_ctl, 0, 1,\n\t\t\t\"Phantom Power Persistence Capture Switch\", NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int scarlett2_mixer_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = elem->channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SCARLETT2_MIXER_MAX_VALUE;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int scarlett2_mixer_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\n\tucontrol->value.integer.value[0] = private->mix[elem->control];\n\treturn 0;\n}\n\nstatic int scarlett2_mixer_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint oval, val, num_mixer_in, mix_num, err = 0;\n\tint index = elem->control;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->mix[index];\n\tval = clamp(ucontrol->value.integer.value[0],\n\t\t    0L, (long)SCARLETT2_MIXER_MAX_VALUE);\n\tnum_mixer_in = port_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_OUT];\n\tmix_num = index / num_mixer_in;\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->mix[index] = val;\n\terr = scarlett2_usb_set_mix(mixer, mix_num);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const DECLARE_TLV_DB_MINMAX(\n\tdb_scale_scarlett2_mixer,\n\tSCARLETT2_MIXER_MIN_DB * 100,\n\tSCARLETT2_MIXER_MAX_DB * 100\n);\n\nstatic const struct snd_kcontrol_new scarlett2_mixer_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"\",\n\t.info = scarlett2_mixer_ctl_info,\n\t.get  = scarlett2_mixer_ctl_get,\n\t.put  = scarlett2_mixer_ctl_put,\n\t.private_value = SCARLETT2_MIXER_MAX_DB,  \n\t.tlv = { .p = db_scale_scarlett2_mixer }\n};\n\nstatic int scarlett2_add_mixer_ctls(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint err, i, j;\n\tint index;\n\tchar s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tint num_inputs =\n\t\tport_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_OUT];\n\tint num_outputs =\n\t\tport_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_IN];\n\n\tfor (i = 0, index = 0; i < num_outputs; i++)\n\t\tfor (j = 0; j < num_inputs; j++, index++) {\n\t\t\tsnprintf(s, sizeof(s),\n\t\t\t\t \"Mix %c Input %02d Playback Volume\",\n\t\t\t\t 'A' + i, j + 1);\n\t\t\terr = scarlett2_add_new_ctl(mixer, &scarlett2_mixer_ctl,\n\t\t\t\t\t\t    index, 1, s, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n\n \n\nstatic int scarlett2_mux_src_enum_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tunsigned int item = uinfo->value.enumerated.item;\n\tint items = private->num_mux_srcs;\n\tint port_type;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = elem->channels;\n\tuinfo->value.enumerated.items = items;\n\n\tif (item >= items)\n\t\titem = uinfo->value.enumerated.item = items - 1;\n\n\tfor (port_type = 0;\n\t     port_type < SCARLETT2_PORT_TYPE_COUNT;\n\t     port_type++) {\n\t\tif (item < port_count[port_type][SCARLETT2_PORT_IN]) {\n\t\t\tconst struct scarlett2_port *port =\n\t\t\t\t&scarlett2_ports[port_type];\n\n\t\t\tsprintf(uinfo->value.enumerated.name,\n\t\t\t\tport->src_descr, item + port->src_num_offset);\n\t\t\treturn 0;\n\t\t}\n\t\titem -= port_count[port_type][SCARLETT2_PORT_IN];\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int scarlett2_mux_src_enum_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\tif (private->mux_updated) {\n\t\terr = scarlett2_usb_get_mux(mixer);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\tucontrol->value.enumerated.item[0] = private->mux[index];\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic int scarlett2_mux_src_enum_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tint index = line_out_remap(private, elem->control);\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->mux[index];\n\tval = min(ucontrol->value.enumerated.item[0],\n\t\t  private->num_mux_srcs - 1U);\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->mux[index] = val;\n\terr = scarlett2_usb_set_mux(mixer);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_mux_src_enum_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett2_mux_src_enum_ctl_info,\n\t.get  = scarlett2_mux_src_enum_ctl_get,\n\t.put  = scarlett2_mux_src_enum_ctl_put,\n};\n\nstatic int scarlett2_add_mux_enums(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint port_type, channel, i;\n\n\tfor (i = 0, port_type = 0;\n\t     port_type < SCARLETT2_PORT_TYPE_COUNT;\n\t     port_type++) {\n\t\tfor (channel = 0;\n\t\t     channel < port_count[port_type][SCARLETT2_PORT_OUT];\n\t\t     channel++, i++) {\n\t\t\tint err;\n\t\t\tchar s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\t\t\tconst char *const descr =\n\t\t\t\tscarlett2_ports[port_type].dst_descr;\n\n\t\t\tsnprintf(s, sizeof(s) - 5, descr, channel + 1);\n\t\t\tstrcat(s, \" Enum\");\n\n\t\t\terr = scarlett2_add_new_ctl(mixer,\n\t\t\t\t\t\t    &scarlett2_mux_src_enum_ctl,\n\t\t\t\t\t\t    i, 1, s,\n\t\t\t\t\t\t    &private->mux_ctls[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int scarlett2_meter_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = elem->channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 4095;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int scarlett2_meter_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tu16 meter_levels[SCARLETT2_MAX_METERS];\n\tint i, err;\n\n\terr = scarlett2_usb_get_meter_levels(elem->head.mixer, elem->channels,\n\t\t\t\t\t     meter_levels);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < elem->channels; i++)\n\t\tucontrol->value.integer.value[i] = meter_levels[i];\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_meter_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.name = \"\",\n\t.info = scarlett2_meter_ctl_info,\n\t.get  = scarlett2_meter_ctl_get\n};\n\nstatic int scarlett2_add_meter_ctl(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\t \n\tif (private->info->config_set == SCARLETT2_CONFIG_SET_NO_MIXER)\n\t\treturn 0;\n\n\treturn scarlett2_add_new_ctl(mixer, &scarlett2_meter_ctl,\n\t\t\t\t     0, private->num_mux_dsts,\n\t\t\t\t     \"Level Meter\", NULL);\n}\n\n \n\nstatic int scarlett2_msd_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\n\tucontrol->value.integer.value[0] = private->msd_switch;\n\treturn 0;\n}\n\nstatic int scarlett2_msd_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->msd_switch;\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->msd_switch = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer, SCARLETT2_CONFIG_MSD_SWITCH,\n\t\t\t\t       0, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_msd_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_msd_ctl_get,\n\t.put  = scarlett2_msd_ctl_put,\n};\n\nstatic int scarlett2_add_msd_ctl(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tif (!info->has_msd_mode)\n\t\treturn 0;\n\n\t \n\tif (!private->msd_switch && !(mixer->chip->setup & SCARLETT2_MSD_ENABLE))\n\t\treturn 0;\n\n\t \n\treturn scarlett2_add_new_ctl(mixer, &scarlett2_msd_ctl,\n\t\t\t\t     0, 1, \"MSD Mode Switch\", NULL);\n}\n\n \n\nstatic int scarlett2_standalone_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett2_data *private = elem->head.mixer->private_data;\n\n\tucontrol->value.integer.value[0] = private->standalone_switch;\n\treturn 0;\n}\n\nstatic int scarlett2_standalone_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct usb_mixer_interface *mixer = elem->head.mixer;\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tint oval, val, err = 0;\n\n\tmutex_lock(&private->data_mutex);\n\n\toval = private->standalone_switch;\n\tval = !!ucontrol->value.integer.value[0];\n\n\tif (oval == val)\n\t\tgoto unlock;\n\n\tprivate->standalone_switch = val;\n\n\t \n\terr = scarlett2_usb_set_config(mixer,\n\t\t\t\t       SCARLETT2_CONFIG_STANDALONE_SWITCH,\n\t\t\t\t       0, val);\n\tif (err == 0)\n\t\terr = 1;\n\nunlock:\n\tmutex_unlock(&private->data_mutex);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new scarlett2_standalone_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get  = scarlett2_standalone_ctl_get,\n\t.put  = scarlett2_standalone_ctl_put,\n};\n\nstatic int scarlett2_add_standalone_ctl(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tif (private->info->config_set == SCARLETT2_CONFIG_SET_NO_MIXER)\n\t\treturn 0;\n\n\t \n\treturn scarlett2_add_new_ctl(mixer, &scarlett2_standalone_ctl,\n\t\t\t\t     0, 1, \"Standalone Switch\", NULL);\n}\n\n \n\nstatic void scarlett2_private_free(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tcancel_delayed_work_sync(&private->work);\n\tkfree(private);\n\tmixer->private_data = NULL;\n}\n\nstatic void scarlett2_private_suspend(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tif (cancel_delayed_work_sync(&private->work))\n\t\tscarlett2_config_save(private->mixer);\n}\n\n \n\nstatic void scarlett2_count_mux_io(struct scarlett2_data *private)\n{\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint port_type, srcs = 0, dsts = 0;\n\n\tfor (port_type = 0;\n\t     port_type < SCARLETT2_PORT_TYPE_COUNT;\n\t     port_type++) {\n\t\tsrcs += port_count[port_type][SCARLETT2_PORT_IN];\n\t\tdsts += port_count[port_type][SCARLETT2_PORT_OUT];\n\t}\n\n\tprivate->num_mux_srcs = srcs;\n\tprivate->num_mux_dsts = dsts;\n}\n\n \nstatic int scarlett2_find_fc_interface(struct usb_device *dev,\n\t\t\t\t       struct scarlett2_data *private)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint i;\n\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc =\n\t\t\t&intf->altsetting[0].desc;\n\t\tstruct usb_endpoint_descriptor *epd;\n\n\t\tif (desc->bInterfaceClass != 255)\n\t\t\tcontinue;\n\n\t\tepd = get_endpoint(intf->altsetting, 0);\n\t\tprivate->bInterfaceNumber = desc->bInterfaceNumber;\n\t\tprivate->bEndpointAddress = epd->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tprivate->wMaxPacketSize = le16_to_cpu(epd->wMaxPacketSize);\n\t\tprivate->bInterval = epd->bInterval;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int scarlett2_init_private(struct usb_mixer_interface *mixer,\n\t\t\t\t  const struct scarlett2_device_info *info)\n{\n\tstruct scarlett2_data *private =\n\t\tkzalloc(sizeof(struct scarlett2_data), GFP_KERNEL);\n\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&private->usb_mutex);\n\tmutex_init(&private->data_mutex);\n\tINIT_DELAYED_WORK(&private->work, scarlett2_config_save_work);\n\n\tmixer->private_data = private;\n\tmixer->private_free = scarlett2_private_free;\n\tmixer->private_suspend = scarlett2_private_suspend;\n\n\tprivate->info = info;\n\tscarlett2_count_mux_io(private);\n\tprivate->scarlett2_seq = 0;\n\tprivate->mixer = mixer;\n\n\treturn scarlett2_find_fc_interface(mixer->chip->dev, private);\n}\n\n \nstatic int scarlett2_usb_init(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_device *dev = mixer->chip->dev;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tu8 buf[24];\n\tint err;\n\n\tif (usb_pipe_type_check(dev, usb_sndctrlpipe(dev, 0)))\n\t\treturn -EINVAL;\n\n\t \n\terr = scarlett2_usb_rx(dev, private->bInterfaceNumber,\n\t\t\t       SCARLETT2_USB_CMD_INIT, buf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tprivate->scarlett2_seq = 1;\n\terr = scarlett2_usb(mixer, SCARLETT2_USB_INIT_1, NULL, 0, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tprivate->scarlett2_seq = 1;\n\treturn scarlett2_usb(mixer, SCARLETT2_USB_INIT_2, NULL, 0, NULL, 84);\n}\n\n \nstatic int scarlett2_read_configs(struct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\tint num_mixer_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_MIX][SCARLETT2_PORT_IN];\n\tstruct scarlett2_usb_volume_status volume_status;\n\tint err, i;\n\n\tif (info->has_msd_mode) {\n\t\terr = scarlett2_usb_get_config(\n\t\t\tmixer, SCARLETT2_CONFIG_MSD_SWITCH,\n\t\t\t1, &private->msd_switch);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (private->msd_switch)\n\t\t\treturn 0;\n\t}\n\n\terr = scarlett2_update_input_other(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = scarlett2_update_monitor_other(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (info->config_set == SCARLETT2_CONFIG_SET_NO_MIXER)\n\t\treturn 0;\n\n\terr = scarlett2_usb_get_config(\n\t\tmixer, SCARLETT2_CONFIG_STANDALONE_SWITCH,\n\t\t1, &private->standalone_switch);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = scarlett2_update_sync(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = scarlett2_usb_get_volume_status(mixer, &volume_status);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (info->line_out_hw_vol)\n\t\tfor (i = 0; i < SCARLETT2_DIM_MUTE_COUNT; i++)\n\t\t\tprivate->dim_mute[i] = !!volume_status.dim_mute[i];\n\n\tprivate->master_vol = clamp(\n\t\tvolume_status.master_vol + SCARLETT2_VOLUME_BIAS,\n\t\t0, SCARLETT2_VOLUME_BIAS);\n\n\tfor (i = 0; i < num_line_out; i++) {\n\t\tint volume, mute;\n\n\t\tprivate->vol_sw_hw_switch[i] =\n\t\t\tinfo->line_out_hw_vol\n\t\t\t\t&& volume_status.sw_hw_switch[i];\n\n\t\tvolume = private->vol_sw_hw_switch[i]\n\t\t\t   ? volume_status.master_vol\n\t\t\t   : volume_status.sw_vol[i];\n\t\tvolume = clamp(volume + SCARLETT2_VOLUME_BIAS,\n\t\t\t       0, SCARLETT2_VOLUME_BIAS);\n\t\tprivate->vol[i] = volume;\n\n\t\tmute = private->vol_sw_hw_switch[i]\n\t\t\t ? private->dim_mute[SCARLETT2_BUTTON_MUTE]\n\t\t\t : volume_status.mute_switch[i];\n\t\tprivate->mute_switch[i] = mute;\n\t}\n\n\tfor (i = 0; i < num_mixer_out; i++) {\n\t\terr = scarlett2_usb_get_mix(mixer, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn scarlett2_usb_get_mux(mixer);\n}\n\n \nstatic void scarlett2_notify_sync(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct scarlett2_data *private = mixer->private_data;\n\n\tprivate->sync_updated = 1;\n\n\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t       &private->sync_ctl->id);\n}\n\n \nstatic void scarlett2_notify_monitor(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\tint i;\n\n\t \n\tif (!info->line_out_hw_vol)\n\t\treturn;\n\n\tprivate->vol_updated = 1;\n\n\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t       &private->master_vol_ctl->id);\n\n\tfor (i = 0; i < num_line_out; i++)\n\t\tif (private->vol_sw_hw_switch[line_out_remap(private, i)])\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &private->vol_ctls[i]->id);\n}\n\n \nstatic void scarlett2_notify_dim_mute(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tconst int (*port_count)[SCARLETT2_PORT_DIRNS] = info->port_count;\n\tint num_line_out =\n\t\tport_count[SCARLETT2_PORT_TYPE_ANALOGUE][SCARLETT2_PORT_OUT];\n\tint i;\n\n\tprivate->vol_updated = 1;\n\n\tif (!info->line_out_hw_vol)\n\t\treturn;\n\n\tfor (i = 0; i < SCARLETT2_DIM_MUTE_COUNT; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->dim_mute_ctls[i]->id);\n\n\tfor (i = 0; i < num_line_out; i++)\n\t\tif (private->vol_sw_hw_switch[line_out_remap(private, i)])\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &private->mute_ctls[i]->id);\n}\n\n \nstatic void scarlett2_notify_input_other(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\tint i;\n\n\tprivate->input_other_updated = 1;\n\n\tfor (i = 0; i < info->level_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->level_ctls[i]->id);\n\tfor (i = 0; i < info->pad_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->pad_ctls[i]->id);\n\tfor (i = 0; i < info->air_input_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->air_ctls[i]->id);\n\tfor (i = 0; i < info->phantom_count; i++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->phantom_ctls[i]->id);\n}\n\n \nstatic void scarlett2_notify_monitor_other(\n\tstruct usb_mixer_interface *mixer)\n{\n\tstruct snd_card *card = mixer->chip->card;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tconst struct scarlett2_device_info *info = private->info;\n\n\tprivate->monitor_other_updated = 1;\n\n\tif (info->direct_monitor) {\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->direct_monitor_ctl->id);\n\t\treturn;\n\t}\n\n\tif (info->has_speaker_switching)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->speaker_switching_ctl->id);\n\n\tif (info->has_talkback)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &private->talkback_ctl->id);\n\n\t \n\tif (private->speaker_switching_switched) {\n\t\tint i;\n\n\t\tscarlett2_notify_dim_mute(mixer);\n\n\t\tprivate->speaker_switching_switched = 0;\n\t\tprivate->mux_updated = 1;\n\n\t\tfor (i = 0; i < private->num_mux_dsts; i++)\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &private->mux_ctls[i]->id);\n\t}\n}\n\n \nstatic void scarlett2_notify(struct urb *urb)\n{\n\tstruct usb_mixer_interface *mixer = urb->context;\n\tint len = urb->actual_length;\n\tint ustatus = urb->status;\n\tu32 data;\n\n\tif (ustatus != 0 || len != 8)\n\t\tgoto requeue;\n\n\tdata = le32_to_cpu(*(__le32 *)urb->transfer_buffer);\n\tif (data & SCARLETT2_USB_NOTIFY_SYNC)\n\t\tscarlett2_notify_sync(mixer);\n\tif (data & SCARLETT2_USB_NOTIFY_MONITOR)\n\t\tscarlett2_notify_monitor(mixer);\n\tif (data & SCARLETT2_USB_NOTIFY_DIM_MUTE)\n\t\tscarlett2_notify_dim_mute(mixer);\n\tif (data & SCARLETT2_USB_NOTIFY_INPUT_OTHER)\n\t\tscarlett2_notify_input_other(mixer);\n\tif (data & SCARLETT2_USB_NOTIFY_MONITOR_OTHER)\n\t\tscarlett2_notify_monitor_other(mixer);\n\nrequeue:\n\tif (ustatus != -ENOENT &&\n\t    ustatus != -ECONNRESET &&\n\t    ustatus != -ESHUTDOWN) {\n\t\turb->dev = mixer->chip->dev;\n\t\tusb_submit_urb(urb, GFP_ATOMIC);\n\t}\n}\n\nstatic int scarlett2_init_notify(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_device *dev = mixer->chip->dev;\n\tstruct scarlett2_data *private = mixer->private_data;\n\tunsigned int pipe = usb_rcvintpipe(dev, private->bEndpointAddress);\n\tvoid *transfer_buffer;\n\n\tif (mixer->urb) {\n\t\tusb_audio_err(mixer->chip,\n\t\t\t      \"%s: mixer urb already in use!\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (usb_pipe_type_check(dev, pipe))\n\t\treturn -EINVAL;\n\n\tmixer->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mixer->urb)\n\t\treturn -ENOMEM;\n\n\ttransfer_buffer = kmalloc(private->wMaxPacketSize, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(mixer->urb, dev, pipe,\n\t\t\t transfer_buffer, private->wMaxPacketSize,\n\t\t\t scarlett2_notify, mixer, private->bInterval);\n\n\treturn usb_submit_urb(mixer->urb, GFP_KERNEL);\n}\n\nstatic int snd_scarlett_gen2_controls_create(struct usb_mixer_interface *mixer)\n{\n\tconst struct scarlett2_device_info **info = scarlett2_devices;\n\tint err;\n\n\t \n\twhile (*info && (*info)->usb_id != mixer->chip->usb_id)\n\t\tinfo++;\n\tif (!*info)\n\t\treturn -EINVAL;\n\n\t \n\terr = scarlett2_init_private(mixer, *info);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_usb_init(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_read_configs(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_msd_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (((struct scarlett2_data *)mixer->private_data)->msd_switch)\n\t\treturn 0;\n\n\t \n\terr = scarlett2_add_line_out_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_line_in_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_mux_enums(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_mixer_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_meter_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_sync_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_direct_monitor_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_speaker_switch_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_talkback_ctls(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_add_standalone_ctl(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = scarlett2_init_notify(mixer);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint snd_scarlett_gen2_init(struct usb_mixer_interface *mixer)\n{\n\tstruct snd_usb_audio *chip = mixer->chip;\n\tint err;\n\n\t \n\tif (!mixer->protocol)\n\t\treturn 0;\n\n\tif (!(chip->setup & SCARLETT2_ENABLE)) {\n\t\tusb_audio_info(chip,\n\t\t\t\"Focusrite Scarlett Gen 2/3 Mixer Driver disabled; \"\n\t\t\t\"use options snd_usb_audio vid=0x%04x pid=0x%04x \"\n\t\t\t\"device_setup=1 to enable and report any issues \"\n\t\t\t\"to g@b4.vu\",\n\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t\treturn 0;\n\t}\n\n\tusb_audio_info(chip,\n\t\t\"Focusrite Scarlett Gen 2/3 Mixer Driver enabled pid=0x%04x\",\n\t\tUSB_ID_PRODUCT(chip->usb_id));\n\n\terr = snd_scarlett_gen2_controls_create(mixer);\n\tif (err < 0)\n\t\tusb_audio_err(mixer->chip,\n\t\t\t      \"Error initialising Scarlett Mixer Driver: %d\",\n\t\t\t      err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}