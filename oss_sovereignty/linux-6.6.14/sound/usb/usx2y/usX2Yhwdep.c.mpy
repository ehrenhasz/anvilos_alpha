{
  "module_name": "usX2Yhwdep.c",
  "hash_id": "429bbbcb3043f0c3f6e6631dfe4a7b5f9d1dc1a1fb24460363cc36fd4c9b022c",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/usX2Yhwdep.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <sound/core.h>\n#include <sound/memalloc.h>\n#include <sound/pcm.h>\n#include <sound/hwdep.h>\n#include \"usx2y.h\"\n#include \"usbusx2y.h\"\n#include \"usX2Yhwdep.h\"\n\nstatic vm_fault_t snd_us428ctls_vm_fault(struct vm_fault *vmf)\n{\n\tunsigned long offset;\n\tstruct page *page;\n\tvoid *vaddr;\n\n\tsnd_printdd(\"ENTER, start %lXh, pgoff %ld\\n\",\n\t\t   vmf->vma->vm_start,\n\t\t   vmf->pgoff);\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tvaddr = (char *)((struct usx2ydev *)vmf->vma->vm_private_data)->us428ctls_sharedmem + offset;\n\tpage = virt_to_page(vaddr);\n\tget_page(page);\n\tvmf->page = page;\n\n\tsnd_printdd(\"vaddr=%p made us428ctls_vm_fault() page %p\\n\",\n\t\t    vaddr, page);\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct us428ctls_vm_ops = {\n\t.fault = snd_us428ctls_vm_fault,\n};\n\nstatic int snd_us428ctls_mmap(struct snd_hwdep *hw, struct file *filp, struct vm_area_struct *area)\n{\n\tunsigned long\tsize = (unsigned long)(area->vm_end - area->vm_start);\n\tstruct usx2ydev\t*us428 = hw->private_data;\n\n\t\n\t\n\tif (!(us428->chip_status & USX2Y_STAT_CHIP_INIT))\n\t\treturn -EBUSY;\n\n\t \n\tif (size > US428_SHAREDMEM_PAGES) {\n\t\tsnd_printd(\"%lu > %lu\\n\", size, (unsigned long)US428_SHAREDMEM_PAGES);\n\t\treturn -EINVAL;\n\t}\n\n\tarea->vm_ops = &us428ctls_vm_ops;\n\tvm_flags_set(area, VM_DONTEXPAND | VM_DONTDUMP);\n\tarea->vm_private_data = hw->private_data;\n\treturn 0;\n}\n\nstatic __poll_t snd_us428ctls_poll(struct snd_hwdep *hw, struct file *file, poll_table *wait)\n{\n\t__poll_t\tmask = 0;\n\tstruct usx2ydev\t*us428 = hw->private_data;\n\tstruct us428ctls_sharedmem *shm = us428->us428ctls_sharedmem;\n\n\tif (us428->chip_status & USX2Y_STAT_CHIP_HUP)\n\t\treturn EPOLLHUP;\n\n\tpoll_wait(file, &us428->us428ctls_wait_queue_head, wait);\n\n\tif (shm && shm->ctl_snapshot_last != shm->ctl_snapshot_red)\n\t\tmask |= EPOLLIN;\n\n\treturn mask;\n}\n\n\nstatic int snd_usx2y_hwdep_dsp_status(struct snd_hwdep *hw,\n\t\t\t\t      struct snd_hwdep_dsp_status *info)\n{\n\tstatic const char * const type_ids[USX2Y_TYPE_NUMS] = {\n\t\t[USX2Y_TYPE_122] = \"us122\",\n\t\t[USX2Y_TYPE_224] = \"us224\",\n\t\t[USX2Y_TYPE_428] = \"us428\",\n\t};\n\tstruct usx2ydev\t*us428 = hw->private_data;\n\tint id = -1;\n\n\tswitch (le16_to_cpu(us428->dev->descriptor.idProduct)) {\n\tcase USB_ID_US122:\n\t\tid = USX2Y_TYPE_122;\n\t\tbreak;\n\tcase USB_ID_US224:\n\t\tid = USX2Y_TYPE_224;\n\t\tbreak;\n\tcase USB_ID_US428:\n\t\tid = USX2Y_TYPE_428;\n\t\tbreak;\n\t}\n\tif (id < 0)\n\t\treturn -ENODEV;\n\tstrcpy(info->id, type_ids[id]);\n\tinfo->num_dsps = 2;\t\t\n\tif (us428->chip_status & USX2Y_STAT_CHIP_INIT)\n\t\tinfo->chip_ready = 1;\n\tinfo->version = USX2Y_DRIVER_VERSION;\n\treturn 0;\n}\n\nstatic int usx2y_create_usbmidi(struct snd_card *card)\n{\n\tstatic const struct snd_usb_midi_endpoint_info quirk_data_1 = {\n\t\t.out_ep = 0x06,\n\t\t.in_ep = 0x06,\n\t\t.out_cables =\t0x001,\n\t\t.in_cables =\t0x001\n\t};\n\tstatic const struct snd_usb_audio_quirk quirk_1 = {\n\t\t.vendor_name =\t\"TASCAM\",\n\t\t.product_name =\tNAME_ALLCAPS,\n\t\t.ifnum =\t0,\n\t\t.type = QUIRK_MIDI_FIXED_ENDPOINT,\n\t\t.data = &quirk_data_1\n\t};\n\tstatic const struct snd_usb_midi_endpoint_info quirk_data_2 = {\n\t\t.out_ep = 0x06,\n\t\t.in_ep = 0x06,\n\t\t.out_cables =\t0x003,\n\t\t.in_cables =\t0x003\n\t};\n\tstatic const struct snd_usb_audio_quirk quirk_2 = {\n\t\t.vendor_name =\t\"TASCAM\",\n\t\t.product_name =\t\"US428\",\n\t\t.ifnum =\t0,\n\t\t.type = QUIRK_MIDI_FIXED_ENDPOINT,\n\t\t.data = &quirk_data_2\n\t};\n\tstruct usb_device *dev = usx2y(card)->dev;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, 0);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\tle16_to_cpu(dev->descriptor.idProduct) == USB_ID_US428 ?\n\t\t&quirk_2 : &quirk_1;\n\n\tsnd_printdd(\"%s\\n\", __func__);\n\treturn snd_usbmidi_create(card, iface, &usx2y(card)->midi_list, quirk);\n}\n\nstatic int usx2y_create_alsa_devices(struct snd_card *card)\n{\n\tint err;\n\n\terr = usx2y_create_usbmidi(card);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"%s: usx2y_create_usbmidi error %i\\n\", __func__, err);\n\t\treturn err;\n\t}\n\terr = usx2y_audio_create(card);\n\tif (err < 0)\n\t\treturn err;\n\terr = usx2y_hwdep_pcm_new(card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_usx2y_hwdep_dsp_load(struct snd_hwdep *hw,\n\t\t\t\t    struct snd_hwdep_dsp_image *dsp)\n{\n\tstruct usx2ydev *priv = hw->private_data;\n\tstruct usb_device *dev = priv->dev;\n\tint lret, err;\n\tchar *buf;\n\n\tsnd_printdd(\"dsp_load %s\\n\", dsp->name);\n\n\tbuf = memdup_user(dsp->image, dsp->length);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\terr = usb_set_interface(dev, 0, 1);\n\tif (err)\n\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\telse\n\t\terr = usb_bulk_msg(dev, usb_sndbulkpipe(dev, 2), buf, dsp->length, &lret, 6000);\n\tkfree(buf);\n\tif (err)\n\t\treturn err;\n\tif (dsp->index == 1) {\n\t\tmsleep(250);\t\t\t\t\n\t\terr = usx2y_async_seq04_init(priv);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR \"usx2y_async_seq04_init error\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = usx2y_in04_init(priv);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR \"usx2y_in04_init error\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = usx2y_create_alsa_devices(hw->card);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR \"usx2y_create_alsa_devices error %i\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tpriv->chip_status |= USX2Y_STAT_CHIP_INIT;\n\t\tsnd_printdd(\"%s: alsa all started\\n\", hw->name);\n\t}\n\treturn err;\n}\n\nint usx2y_hwdep_new(struct snd_card *card, struct usb_device *device)\n{\n\tint err;\n\tstruct snd_hwdep *hw;\n\tstruct usx2ydev\t*us428 = usx2y(card);\n\n\terr = snd_hwdep_new(card, SND_USX2Y_LOADER_ID, 0, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thw->iface = SNDRV_HWDEP_IFACE_USX2Y;\n\thw->private_data = us428;\n\thw->ops.dsp_status = snd_usx2y_hwdep_dsp_status;\n\thw->ops.dsp_load = snd_usx2y_hwdep_dsp_load;\n\thw->ops.mmap = snd_us428ctls_mmap;\n\thw->ops.poll = snd_us428ctls_poll;\n\thw->exclusive = 1;\n\tsprintf(hw->name, \"/dev/bus/usb/%03d/%03d\", device->bus->busnum, device->devnum);\n\n\tus428->us428ctls_sharedmem = alloc_pages_exact(US428_SHAREDMEM_PAGES, GFP_KERNEL);\n\tif (!us428->us428ctls_sharedmem)\n\t\treturn -ENOMEM;\n\tmemset(us428->us428ctls_sharedmem, -1, US428_SHAREDMEM_PAGES);\n\tus428->us428ctls_sharedmem->ctl_snapshot_last = -2;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}