{
  "module_name": "usbusx2yaudio.c",
  "hash_id": "a4306832f5eb8e7b5f6ff27ef28928313a6a6eea125ef74c04318527d0aac890",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/usbusx2yaudio.c",
  "human_readable_source": "\n \n\n\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"usx2y.h\"\n#include \"usbusx2y.h\"\n\n \n#define USX2Y_NRPACKS 4\n\n \n#define USX2Y_NRPACKS_VARIABLE 1\n\n#ifdef USX2Y_NRPACKS_VARIABLE\nstatic int nrpacks = USX2Y_NRPACKS;  \n#define  nr_of_packs() nrpacks\nmodule_param(nrpacks, int, 0444);\nMODULE_PARM_DESC(nrpacks, \"Number of packets per URB.\");\n#else\n#define nr_of_packs() USX2Y_NRPACKS\n#endif\n\nstatic int usx2y_urb_capt_retire(struct snd_usx2y_substream *subs)\n{\n\tstruct urb\t*urb = subs->completed_urb;\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tunsigned char\t*cp;\n\tint\t\ti, len, lens = 0, hwptr_done = subs->hwptr_done;\n\tint\t\tcnt, blen;\n\tstruct usx2ydev\t*usx2y = subs->usx2y;\n\n\tfor (i = 0; i < nr_of_packs(); i++) {\n\t\tcp = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tif (urb->iso_frame_desc[i].status) {  \n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"active frame status %i. Most probably some hardware problem.\\n\",\n\t\t\t\t   urb->iso_frame_desc[i].status);\n\t\t\treturn urb->iso_frame_desc[i].status;\n\t\t}\n\t\tlen = urb->iso_frame_desc[i].actual_length / usx2y->stride;\n\t\tif (!len) {\n\t\t\tsnd_printd(\"0 == len ERROR!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((hwptr_done + len) > runtime->buffer_size) {\n\t\t\tcnt = runtime->buffer_size - hwptr_done;\n\t\t\tblen = cnt * usx2y->stride;\n\t\t\tmemcpy(runtime->dma_area + hwptr_done * usx2y->stride, cp, blen);\n\t\t\tmemcpy(runtime->dma_area, cp + blen, len * usx2y->stride - blen);\n\t\t} else {\n\t\t\tmemcpy(runtime->dma_area + hwptr_done * usx2y->stride, cp,\n\t\t\t       len * usx2y->stride);\n\t\t}\n\t\tlens += len;\n\t\thwptr_done += len;\n\t\tif (hwptr_done >= runtime->buffer_size)\n\t\t\thwptr_done -= runtime->buffer_size;\n\t}\n\n\tsubs->hwptr_done = hwptr_done;\n\tsubs->transfer_done += lens;\n\t \n\tif (subs->transfer_done >= runtime->period_size) {\n\t\tsubs->transfer_done -= runtime->period_size;\n\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n\t}\n\treturn 0;\n}\n\n \nstatic int usx2y_urb_play_prepare(struct snd_usx2y_substream *subs,\n\t\t\t\t  struct urb *cap_urb,\n\t\t\t\t  struct urb *urb)\n{\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tint count, counts, pack, len;\n\n\tcount = 0;\n\tfor (pack = 0; pack <  nr_of_packs(); pack++) {\n\t\t \n\t\tcounts = cap_urb->iso_frame_desc[pack].actual_length / usx2y->stride;\n\t\tcount += counts;\n\t\tif (counts < 43 || counts > 50) {\n\t\t\tsnd_printk(KERN_ERR \"should not be here with counts=%i\\n\", counts);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\t \n\t\turb->iso_frame_desc[pack].offset = pack ?\n\t\t\turb->iso_frame_desc[pack - 1].offset +\n\t\t\turb->iso_frame_desc[pack - 1].length :\n\t\t\t0;\n\t\turb->iso_frame_desc[pack].length = cap_urb->iso_frame_desc[pack].actual_length;\n\t}\n\tif (atomic_read(&subs->state) >= STATE_PRERUNNING) {\n\t\tif (subs->hwptr + count > runtime->buffer_size) {\n\t\t\t \n\t\t\tlen = runtime->buffer_size - subs->hwptr;\n\t\t\turb->transfer_buffer = subs->tmpbuf;\n\t\t\tmemcpy(subs->tmpbuf, runtime->dma_area +\n\t\t\t       subs->hwptr * usx2y->stride, len * usx2y->stride);\n\t\t\tmemcpy(subs->tmpbuf + len * usx2y->stride,\n\t\t\t       runtime->dma_area, (count - len) * usx2y->stride);\n\t\t\tsubs->hwptr += count;\n\t\t\tsubs->hwptr -= runtime->buffer_size;\n\t\t} else {\n\t\t\t \n\t\t\turb->transfer_buffer = runtime->dma_area + subs->hwptr * usx2y->stride;\n\t\t\tsubs->hwptr += count;\n\t\t\tif (subs->hwptr >= runtime->buffer_size)\n\t\t\t\tsubs->hwptr -= runtime->buffer_size;\n\t\t}\n\t} else {\n\t\turb->transfer_buffer = subs->tmpbuf;\n\t}\n\turb->transfer_buffer_length = count * usx2y->stride;\n\treturn 0;\n}\n\n \nstatic void usx2y_urb_play_retire(struct snd_usx2y_substream *subs, struct urb *urb)\n{\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tint\t\tlen = urb->actual_length / subs->usx2y->stride;\n\n\tsubs->transfer_done += len;\n\tsubs->hwptr_done +=  len;\n\tif (subs->hwptr_done >= runtime->buffer_size)\n\t\tsubs->hwptr_done -= runtime->buffer_size;\n\tif (subs->transfer_done >= runtime->period_size) {\n\t\tsubs->transfer_done -= runtime->period_size;\n\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n\t}\n}\n\nstatic int usx2y_urb_submit(struct snd_usx2y_substream *subs, struct urb *urb, int frame)\n{\n\tint err;\n\n\tif (!urb)\n\t\treturn -ENODEV;\n\turb->start_frame = frame + NRURBS * nr_of_packs();   \n\turb->hcpriv = NULL;\n\turb->dev = subs->usx2y->dev;  \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"usb_submit_urb() returned %i\\n\", err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int usx2y_usbframe_complete(struct snd_usx2y_substream *capsubs,\n\t\t\t\t   struct snd_usx2y_substream *playbacksubs,\n\t\t\t\t   int frame)\n{\n\tint err, state;\n\tstruct urb *urb = playbacksubs->completed_urb;\n\n\tstate = atomic_read(&playbacksubs->state);\n\tif (urb) {\n\t\tif (state == STATE_RUNNING)\n\t\t\tusx2y_urb_play_retire(playbacksubs, urb);\n\t\telse if (state >= STATE_PRERUNNING)\n\t\t\tatomic_inc(&playbacksubs->state);\n\t} else {\n\t\tswitch (state) {\n\t\tcase STATE_STARTING1:\n\t\t\turb = playbacksubs->urb[0];\n\t\t\tatomic_inc(&playbacksubs->state);\n\t\t\tbreak;\n\t\tcase STATE_STARTING2:\n\t\t\turb = playbacksubs->urb[1];\n\t\t\tatomic_inc(&playbacksubs->state);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (urb) {\n\t\terr = usx2y_urb_play_prepare(playbacksubs, capsubs->completed_urb, urb);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = usx2y_urb_submit(playbacksubs, urb, frame);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tplaybacksubs->completed_urb = NULL;\n\n\tstate = atomic_read(&capsubs->state);\n\tif (state >= STATE_PREPARED) {\n\t\tif (state == STATE_RUNNING) {\n\t\t\terr = usx2y_urb_capt_retire(capsubs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (state >= STATE_PRERUNNING) {\n\t\t\tatomic_inc(&capsubs->state);\n\t\t}\n\t\terr = usx2y_urb_submit(capsubs, capsubs->completed_urb, frame);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tcapsubs->completed_urb = NULL;\n\treturn 0;\n}\n\nstatic void usx2y_clients_stop(struct usx2ydev *usx2y)\n{\n\tstruct snd_usx2y_substream *subs;\n\tstruct urb *urb;\n\tint s, u;\n\n\tfor (s = 0; s < 4; s++) {\n\t\tsubs = usx2y->subs[s];\n\t\tif (subs) {\n\t\t\tsnd_printdd(\"%i %p state=%i\\n\", s, subs, atomic_read(&subs->state));\n\t\t\tatomic_set(&subs->state, STATE_STOPPED);\n\t\t}\n\t}\n\tfor (s = 0; s < 4; s++) {\n\t\tsubs = usx2y->subs[s];\n\t\tif (subs) {\n\t\t\tif (atomic_read(&subs->state) >= STATE_PRERUNNING)\n\t\t\t\tsnd_pcm_stop_xrun(subs->pcm_substream);\n\t\t\tfor (u = 0; u < NRURBS; u++) {\n\t\t\t\turb = subs->urb[u];\n\t\t\t\tif (urb)\n\t\t\t\t\tsnd_printdd(\"%i status=%i start_frame=%i\\n\",\n\t\t\t\t\t\t    u, urb->status, urb->start_frame);\n\t\t\t}\n\t\t}\n\t}\n\tusx2y->prepare_subs = NULL;\n\twake_up(&usx2y->prepare_wait_queue);\n}\n\nstatic void usx2y_error_urb_status(struct usx2ydev *usx2y,\n\t\t\t\t   struct snd_usx2y_substream *subs, struct urb *urb)\n{\n\tsnd_printk(KERN_ERR \"ep=%i stalled with status=%i\\n\", subs->endpoint, urb->status);\n\turb->status = 0;\n\tusx2y_clients_stop(usx2y);\n}\n\nstatic void i_usx2y_urb_complete(struct urb *urb)\n{\n\tstruct snd_usx2y_substream *subs = urb->context;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *capsubs, *playbacksubs;\n\n\tif (unlikely(atomic_read(&subs->state) < STATE_PREPARED)) {\n\t\tsnd_printdd(\"hcd_frame=%i ep=%i%s status=%i start_frame=%i\\n\",\n\t\t\t    usb_get_current_frame_number(usx2y->dev),\n\t\t\t    subs->endpoint, usb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\t    urb->status, urb->start_frame);\n\t\treturn;\n\t}\n\tif (unlikely(urb->status)) {\n\t\tusx2y_error_urb_status(usx2y, subs, urb);\n\t\treturn;\n\t}\n\n\tsubs->completed_urb = urb;\n\n\tcapsubs = usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\tplaybacksubs = usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\n\tif (capsubs->completed_urb &&\n\t    atomic_read(&capsubs->state) >= STATE_PREPARED &&\n\t    (playbacksubs->completed_urb ||\n\t     atomic_read(&playbacksubs->state) < STATE_PREPARED)) {\n\t\tif (!usx2y_usbframe_complete(capsubs, playbacksubs, urb->start_frame)) {\n\t\t\tusx2y->wait_iso_frame += nr_of_packs();\n\t\t} else {\n\t\t\tsnd_printdd(\"\\n\");\n\t\t\tusx2y_clients_stop(usx2y);\n\t\t}\n\t}\n}\n\nstatic void usx2y_urbs_set_complete(struct usx2ydev *usx2y,\n\t\t\t\t    void (*complete)(struct urb *))\n{\n\tstruct snd_usx2y_substream *subs;\n\tstruct urb *urb;\n\tint s, u;\n\n\tfor (s = 0; s < 4; s++) {\n\t\tsubs = usx2y->subs[s];\n\t\tif (subs) {\n\t\t\tfor (u = 0; u < NRURBS; u++) {\n\t\t\t\turb = subs->urb[u];\n\t\t\t\tif (urb)\n\t\t\t\t\turb->complete = complete;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void usx2y_subs_startup_finish(struct usx2ydev *usx2y)\n{\n\tusx2y_urbs_set_complete(usx2y, i_usx2y_urb_complete);\n\tusx2y->prepare_subs = NULL;\n}\n\nstatic void i_usx2y_subs_startup(struct urb *urb)\n{\n\tstruct snd_usx2y_substream *subs = urb->context;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *prepare_subs = usx2y->prepare_subs;\n\n\tif (prepare_subs) {\n\t\tif (urb->start_frame == prepare_subs->urb[0]->start_frame) {\n\t\t\tusx2y_subs_startup_finish(usx2y);\n\t\t\tatomic_inc(&prepare_subs->state);\n\t\t\twake_up(&usx2y->prepare_wait_queue);\n\t\t}\n\t}\n\n\ti_usx2y_urb_complete(urb);\n}\n\nstatic void usx2y_subs_prepare(struct snd_usx2y_substream *subs)\n{\n\tsnd_printdd(\"usx2y_substream_prepare(%p) ep=%i urb0=%p urb1=%p\\n\",\n\t\t    subs, subs->endpoint, subs->urb[0], subs->urb[1]);\n\t \n\tsubs->hwptr = 0;\n\tsubs->hwptr_done = 0;\n\tsubs->transfer_done = 0;\n}\n\nstatic void usx2y_urb_release(struct urb **urb, int free_tb)\n{\n\tif (*urb) {\n\t\tusb_kill_urb(*urb);\n\t\tif (free_tb)\n\t\t\tkfree((*urb)->transfer_buffer);\n\t\tusb_free_urb(*urb);\n\t\t*urb = NULL;\n\t}\n}\n\n \nstatic void usx2y_urbs_release(struct snd_usx2y_substream *subs)\n{\n\tint i;\n\n\tsnd_printdd(\"%s %i\\n\", __func__, subs->endpoint);\n\tfor (i = 0; i < NRURBS; i++)\n\t\tusx2y_urb_release(subs->urb + i,\n\t\t\t\t  subs != subs->usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK]);\n\n\tkfree(subs->tmpbuf);\n\tsubs->tmpbuf = NULL;\n}\n\n \nstatic int usx2y_urbs_allocate(struct snd_usx2y_substream *subs)\n{\n\tint i;\n\tunsigned int pipe;\n\tint is_playback = subs == subs->usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\tstruct usb_device *dev = subs->usx2y->dev;\n\tstruct urb **purb;\n\n\tpipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :\n\t\t\tusb_rcvisocpipe(dev, subs->endpoint);\n\tsubs->maxpacksize = usb_maxpacket(dev, pipe);\n\tif (!subs->maxpacksize)\n\t\treturn -EINVAL;\n\n\tif (is_playback && !subs->tmpbuf) {\t \n\t\tsubs->tmpbuf = kcalloc(nr_of_packs(), subs->maxpacksize, GFP_KERNEL);\n\t\tif (!subs->tmpbuf)\n\t\t\treturn -ENOMEM;\n\t}\n\t \n\tfor (i = 0; i < NRURBS; i++) {\n\t\tpurb = subs->urb + i;\n\t\tif (*purb) {\n\t\t\tusb_kill_urb(*purb);\n\t\t\tcontinue;\n\t\t}\n\t\t*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);\n\t\tif (!*purb) {\n\t\t\tusx2y_urbs_release(subs);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!is_playback && !(*purb)->transfer_buffer) {\n\t\t\t \n\t\t\t(*purb)->transfer_buffer =\n\t\t\t\tkmalloc_array(subs->maxpacksize,\n\t\t\t\t\t      nr_of_packs(), GFP_KERNEL);\n\t\t\tif (!(*purb)->transfer_buffer) {\n\t\t\t\tusx2y_urbs_release(subs);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\t(*purb)->dev = dev;\n\t\t(*purb)->pipe = pipe;\n\t\t(*purb)->number_of_packets = nr_of_packs();\n\t\t(*purb)->context = subs;\n\t\t(*purb)->interval = 1;\n\t\t(*purb)->complete = i_usx2y_subs_startup;\n\t}\n\treturn 0;\n}\n\nstatic void usx2y_subs_startup(struct snd_usx2y_substream *subs)\n{\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\n\tusx2y->prepare_subs = subs;\n\tsubs->urb[0]->start_frame = -1;\n\twmb();\n\tusx2y_urbs_set_complete(usx2y, i_usx2y_subs_startup);\n}\n\nstatic int usx2y_urbs_start(struct snd_usx2y_substream *subs)\n{\n\tint i, err;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct urb *urb;\n\tunsigned long pack;\n\n\terr = usx2y_urbs_allocate(subs);\n\tif (err < 0)\n\t\treturn err;\n\tsubs->completed_urb = NULL;\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct snd_usx2y_substream *subs = usx2y->subs[i];\n\n\t\tif (subs && atomic_read(&subs->state) >= STATE_PREPARED)\n\t\t\tgoto start;\n\t}\n\n start:\n\tusx2y_subs_startup(subs);\n\tfor (i = 0; i < NRURBS; i++) {\n\t\turb = subs->urb[i];\n\t\tif (usb_pipein(urb->pipe)) {\n\t\t\tif (!i)\n\t\t\t\tatomic_set(&subs->state, STATE_STARTING3);\n\t\t\turb->dev = usx2y->dev;\n\t\t\tfor (pack = 0; pack < nr_of_packs(); pack++) {\n\t\t\t\turb->iso_frame_desc[pack].offset = subs->maxpacksize * pack;\n\t\t\t\turb->iso_frame_desc[pack].length = subs->maxpacksize;\n\t\t\t}\n\t\t\turb->transfer_buffer_length = subs->maxpacksize * nr_of_packs();\n\t\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"cannot submit datapipe for urb %d, err = %d\\n\", i, err);\n\t\t\t\terr = -EPIPE;\n\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (!i)\n\t\t\t\t\tusx2y->wait_iso_frame = urb->start_frame;\n\t\t\t}\n\t\t\turb->transfer_flags = 0;\n\t\t} else {\n\t\t\tatomic_set(&subs->state, STATE_STARTING1);\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = 0;\n\twait_event(usx2y->prepare_wait_queue, !usx2y->prepare_subs);\n\tif (atomic_read(&subs->state) != STATE_PREPARED)\n\t\terr = -EPIPE;\n\n cleanup:\n\tif (err) {\n\t\tusx2y_subs_startup_finish(usx2y);\n\t\tusx2y_clients_stop(usx2y);\t\n\t}\n\treturn err;\n}\n\n \nstatic snd_pcm_uframes_t snd_usx2y_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usx2y_substream *subs = substream->runtime->private_data;\n\n\treturn subs->hwptr_done;\n}\n\n \nstatic int snd_usx2y_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_usx2y_substream *subs = substream->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_printdd(\"%s(START)\\n\", __func__);\n\t\tif (atomic_read(&subs->state) == STATE_PREPARED &&\n\t\t    atomic_read(&subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE]->state) >= STATE_PREPARED) {\n\t\t\tatomic_set(&subs->state, STATE_PRERUNNING);\n\t\t} else {\n\t\t\tsnd_printdd(\"\\n\");\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_printdd(\"%s(STOP)\\n\", __func__);\n\t\tif (atomic_read(&subs->state) >= STATE_PRERUNNING)\n\t\t\tatomic_set(&subs->state, STATE_PREPARED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstruct s_c2 {\n\tchar c1, c2;\n};\n\nstatic const struct s_c2 setrate_44100[] = {\n\t{ 0x14, 0x08},\t\n\t{ 0x18, 0x40},\t\n\t{ 0x18, 0x42},\n\t{ 0x18, 0x45},\n\t{ 0x18, 0x46},\n\t{ 0x18, 0x48},\n\t{ 0x18, 0x4A},\n\t{ 0x18, 0x4C},\n\t{ 0x18, 0x4E},\n\t{ 0x18, 0x50},\n\t{ 0x18, 0x52},\n\t{ 0x18, 0x54},\n\t{ 0x18, 0x56},\n\t{ 0x18, 0x58},\n\t{ 0x18, 0x5A},\n\t{ 0x18, 0x5C},\n\t{ 0x18, 0x5E},\n\t{ 0x18, 0x60},\n\t{ 0x18, 0x62},\n\t{ 0x18, 0x64},\n\t{ 0x18, 0x66},\n\t{ 0x18, 0x68},\n\t{ 0x18, 0x6A},\n\t{ 0x18, 0x6C},\n\t{ 0x18, 0x6E},\n\t{ 0x18, 0x70},\n\t{ 0x18, 0x72},\n\t{ 0x18, 0x74},\n\t{ 0x18, 0x76},\n\t{ 0x18, 0x78},\n\t{ 0x18, 0x7A},\n\t{ 0x18, 0x7C},\n\t{ 0x18, 0x7E}\n};\n\nstatic const struct s_c2 setrate_48000[] = {\n\t{ 0x14, 0x09},\t\n\t{ 0x18, 0x40},\t\n\t{ 0x18, 0x42},\n\t{ 0x18, 0x45},\n\t{ 0x18, 0x46},\n\t{ 0x18, 0x48},\n\t{ 0x18, 0x4A},\n\t{ 0x18, 0x4C},\n\t{ 0x18, 0x4E},\n\t{ 0x18, 0x50},\n\t{ 0x18, 0x52},\n\t{ 0x18, 0x54},\n\t{ 0x18, 0x56},\n\t{ 0x18, 0x58},\n\t{ 0x18, 0x5A},\n\t{ 0x18, 0x5C},\n\t{ 0x18, 0x5E},\n\t{ 0x18, 0x60},\n\t{ 0x18, 0x62},\n\t{ 0x18, 0x64},\n\t{ 0x18, 0x66},\n\t{ 0x18, 0x68},\n\t{ 0x18, 0x6A},\n\t{ 0x18, 0x6C},\n\t{ 0x18, 0x6E},\n\t{ 0x18, 0x70},\n\t{ 0x18, 0x73},\n\t{ 0x18, 0x74},\n\t{ 0x18, 0x76},\n\t{ 0x18, 0x78},\n\t{ 0x18, 0x7A},\n\t{ 0x18, 0x7C},\n\t{ 0x18, 0x7E}\n};\n\n#define NOOF_SETRATE_URBS ARRAY_SIZE(setrate_48000)\n\nstatic void i_usx2y_04int(struct urb *urb)\n{\n\tstruct usx2ydev *usx2y = urb->context;\n\n\tif (urb->status)\n\t\tsnd_printk(KERN_ERR \"snd_usx2y_04int() urb->status=%i\\n\", urb->status);\n\tif (!--usx2y->us04->len)\n\t\twake_up(&usx2y->in04_wait_queue);\n}\n\nstatic int usx2y_rate_set(struct usx2ydev *usx2y, int rate)\n{\n\tint err = 0, i;\n\tstruct snd_usx2y_urb_seq *us = NULL;\n\tint *usbdata = NULL;\n\tconst struct s_c2 *ra = rate == 48000 ? setrate_48000 : setrate_44100;\n\tstruct urb *urb;\n\n\tif (usx2y->rate != rate) {\n\t\tus = kzalloc(struct_size(us, urb, NOOF_SETRATE_URBS),\n\t\t\t     GFP_KERNEL);\n\t\tif (!us) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tusbdata = kmalloc_array(NOOF_SETRATE_URBS, sizeof(int),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!usbdata) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfor (i = 0; i < NOOF_SETRATE_URBS; ++i) {\n\t\t\tus->urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!us->urb[i]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t((char *)(usbdata + i))[0] = ra[i].c1;\n\t\t\t((char *)(usbdata + i))[1] = ra[i].c2;\n\t\t\tusb_fill_bulk_urb(us->urb[i], usx2y->dev, usb_sndbulkpipe(usx2y->dev, 4),\n\t\t\t\t\t  usbdata + i, 2, i_usx2y_04int, usx2y);\n\t\t}\n\t\terr = usb_urb_ep_type_check(us->urb[0]);\n\t\tif (err < 0)\n\t\t\tgoto cleanup;\n\t\tus->submitted =\t0;\n\t\tus->len =\tNOOF_SETRATE_URBS;\n\t\tusx2y->us04 =\tus;\n\t\twait_event_timeout(usx2y->in04_wait_queue, !us->len, HZ);\n\t\tusx2y->us04 =\tNULL;\n\t\tif (us->len)\n\t\t\terr = -ENODEV;\n\tcleanup:\n\t\tif (us) {\n\t\t\tus->submitted =\t2*NOOF_SETRATE_URBS;\n\t\t\tfor (i = 0; i < NOOF_SETRATE_URBS; ++i) {\n\t\t\t\turb = us->urb[i];\n\t\t\t\tif (!urb)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (urb->status) {\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\terr = -ENODEV;\n\t\t\t\t\tusb_kill_urb(urb);\n\t\t\t\t}\n\t\t\t\tusb_free_urb(urb);\n\t\t\t}\n\t\t\tusx2y->us04 = NULL;\n\t\t\tkfree(usbdata);\n\t\t\tkfree(us);\n\t\t\tif (!err)\n\t\t\t\tusx2y->rate = rate;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int usx2y_format_set(struct usx2ydev *usx2y, snd_pcm_format_t format)\n{\n\tint alternate, err;\n\tstruct list_head *p;\n\n\tif (format == SNDRV_PCM_FORMAT_S24_3LE) {\n\t\talternate = 2;\n\t\tusx2y->stride = 6;\n\t} else {\n\t\talternate = 1;\n\t\tusx2y->stride = 4;\n\t}\n\tlist_for_each(p, &usx2y->midi_list) {\n\t\tsnd_usbmidi_input_stop(p);\n\t}\n\tusb_kill_urb(usx2y->in04_urb);\n\terr = usb_set_interface(usx2y->dev, 0, alternate);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\t\treturn err;\n\t}\n\tusx2y->in04_urb->dev = usx2y->dev;\n\terr = usb_submit_urb(usx2y->in04_urb, GFP_KERNEL);\n\tlist_for_each(p, &usx2y->midi_list) {\n\t\tsnd_usbmidi_input_start(p);\n\t}\n\tusx2y->format = format;\n\tusx2y->rate = 0;\n\treturn err;\n}\n\n\nstatic int snd_usx2y_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *hw_params)\n{\n\tint\t\t\terr = 0;\n\tunsigned int\t\trate = params_rate(hw_params);\n\tsnd_pcm_format_t\tformat = params_format(hw_params);\n\tstruct snd_card *card = substream->pstr->pcm->card;\n\tstruct usx2ydev\t*dev = usx2y(card);\n\tstruct snd_usx2y_substream *subs;\n\tstruct snd_pcm_substream *test_substream;\n\tint i;\n\n\tmutex_lock(&usx2y(card)->pcm_mutex);\n\tsnd_printdd(\"snd_usx2y_hw_params(%p, %p)\\n\", substream, hw_params);\n\t \n\tfor (i = 0; i < dev->pcm_devs * 2; i++) {\n\t\tsubs = dev->subs[i];\n\t\tif (!subs)\n\t\t\tcontinue;\n\t\ttest_substream = subs->pcm_substream;\n\t\tif (!test_substream || test_substream == substream ||\n\t\t    !test_substream->runtime)\n\t\t\tcontinue;\n\t\tif ((test_substream->runtime->format &&\n\t\t     test_substream->runtime->format != format) ||\n\t\t    (test_substream->runtime->rate &&\n\t\t     test_substream->runtime->rate != rate)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n error:\n\tmutex_unlock(&usx2y(card)->pcm_mutex);\n\treturn err;\n}\n\n \nstatic int snd_usx2y_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\tstruct snd_usx2y_substream *cap_subs, *playback_subs;\n\n\tmutex_lock(&subs->usx2y->pcm_mutex);\n\tsnd_printdd(\"snd_usx2y_hw_free(%p)\\n\", substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tcap_subs = subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\t\tatomic_set(&subs->state, STATE_STOPPED);\n\t\tusx2y_urbs_release(subs);\n\t\tif (!cap_subs->pcm_substream ||\n\t\t    !cap_subs->pcm_substream->runtime ||\n\t\t    cap_subs->pcm_substream->runtime->state < SNDRV_PCM_STATE_PREPARED) {\n\t\t\tatomic_set(&cap_subs->state, STATE_STOPPED);\n\t\t\tusx2y_urbs_release(cap_subs);\n\t\t}\n\t} else {\n\t\tplayback_subs = subs->usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tif (atomic_read(&playback_subs->state) < STATE_PREPARED) {\n\t\t\tatomic_set(&subs->state, STATE_STOPPED);\n\t\t\tusx2y_urbs_release(subs);\n\t\t}\n\t}\n\tmutex_unlock(&subs->usx2y->pcm_mutex);\n\treturn 0;\n}\n\n \nstatic int snd_usx2y_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *capsubs = subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\tint err = 0;\n\n\tsnd_printdd(\"%s(%p)\\n\", __func__, substream);\n\n\tmutex_lock(&usx2y->pcm_mutex);\n\tusx2y_subs_prepare(subs);\n\t\n\t\n\tif (atomic_read(&capsubs->state) < STATE_PREPARED) {\n\t\tif (usx2y->format != runtime->format) {\n\t\t\terr = usx2y_format_set(usx2y, runtime->format);\n\t\t\tif (err < 0)\n\t\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tif (usx2y->rate != runtime->rate) {\n\t\t\terr = usx2y_rate_set(usx2y, runtime->rate);\n\t\t\tif (err < 0)\n\t\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tsnd_printdd(\"starting capture pipe for %s\\n\", subs == capsubs ? \"self\" : \"playpipe\");\n\t\terr = usx2y_urbs_start(capsubs);\n\t\tif (err < 0)\n\t\t\tgoto up_prepare_mutex;\n\t}\n\n\tif (subs != capsubs && atomic_read(&subs->state) < STATE_PREPARED)\n\t\terr = usx2y_urbs_start(subs);\n\n up_prepare_mutex:\n\tmutex_unlock(&usx2y->pcm_mutex);\n\treturn err;\n}\n\nstatic const struct snd_pcm_hardware snd_usx2y_2c = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_BATCH),\n\t.formats =                 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,\n\t.rates =                   SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min =                44100,\n\t.rate_max =                48000,\n\t.channels_min =            2,\n\t.channels_max =            2,\n\t.buffer_bytes_max =\t(2*128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =              0\n};\n\nstatic int snd_usx2y_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usx2y_substream\t*subs =\n\t\t((struct snd_usx2y_substream **)\n\t\t snd_pcm_substream_chip(substream))[substream->stream];\n\tstruct snd_pcm_runtime\t*runtime = substream->runtime;\n\n\tif (subs->usx2y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS)\n\t\treturn -EBUSY;\n\n\truntime->hw = snd_usx2y_2c;\n\truntime->private_data = subs;\n\tsubs->pcm_substream = substream;\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 1000, 200000);\n\treturn 0;\n}\n\nstatic int snd_usx2y_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\n\tsubs->pcm_substream = NULL;\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_usx2y_pcm_ops = {\n\t.open =\t\tsnd_usx2y_pcm_open,\n\t.close =\tsnd_usx2y_pcm_close,\n\t.hw_params =\tsnd_usx2y_pcm_hw_params,\n\t.hw_free =\tsnd_usx2y_pcm_hw_free,\n\t.prepare =\tsnd_usx2y_pcm_prepare,\n\t.trigger =\tsnd_usx2y_pcm_trigger,\n\t.pointer =\tsnd_usx2y_pcm_pointer,\n};\n\n \nstatic void usx2y_audio_stream_free(struct snd_usx2y_substream **usx2y_substream)\n{\n\tint stream;\n\n\tfor_each_pcm_streams(stream) {\n\t\tkfree(usx2y_substream[stream]);\n\t\tusx2y_substream[stream] = NULL;\n\t}\n}\n\nstatic void snd_usx2y_pcm_private_free(struct snd_pcm *pcm)\n{\n\tstruct snd_usx2y_substream **usx2y_stream = pcm->private_data;\n\n\tif (usx2y_stream)\n\t\tusx2y_audio_stream_free(usx2y_stream);\n}\n\nstatic int usx2y_audio_stream_new(struct snd_card *card, int playback_endpoint, int capture_endpoint)\n{\n\tstruct snd_pcm *pcm;\n\tint err, i;\n\tstruct snd_usx2y_substream **usx2y_substream =\n\t\tusx2y(card)->subs + 2 * usx2y(card)->pcm_devs;\n\n\tfor (i = playback_endpoint ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\n\t     i <= SNDRV_PCM_STREAM_CAPTURE; ++i) {\n\t\tusx2y_substream[i] = kzalloc(sizeof(struct snd_usx2y_substream), GFP_KERNEL);\n\t\tif (!usx2y_substream[i])\n\t\t\treturn -ENOMEM;\n\n\t\tusx2y_substream[i]->usx2y = usx2y(card);\n\t}\n\n\tif (playback_endpoint)\n\t\tusx2y_substream[SNDRV_PCM_STREAM_PLAYBACK]->endpoint = playback_endpoint;\n\tusx2y_substream[SNDRV_PCM_STREAM_CAPTURE]->endpoint = capture_endpoint;\n\n\terr = snd_pcm_new(card, NAME_ALLCAPS\" Audio\", usx2y(card)->pcm_devs,\n\t\t\t  playback_endpoint ? 1 : 0, 1,\n\t\t\t  &pcm);\n\tif (err < 0) {\n\t\tusx2y_audio_stream_free(usx2y_substream);\n\t\treturn err;\n\t}\n\n\tif (playback_endpoint)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_usx2y_pcm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usx2y_pcm_ops);\n\n\tpcm->private_data = usx2y_substream;\n\tpcm->private_free = snd_usx2y_pcm_private_free;\n\tpcm->info_flags = 0;\n\n\tsprintf(pcm->name, NAME_ALLCAPS\" Audio #%d\", usx2y(card)->pcm_devs);\n\n\tif (playback_endpoint) {\n\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   64*1024, 128*1024);\n\t}\n\n\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t   NULL,\n\t\t\t\t   64*1024, 128*1024);\n\tusx2y(card)->pcm_devs++;\n\n\treturn 0;\n}\n\n \nint usx2y_audio_create(struct snd_card *card)\n{\n\tint err;\n\n\terr = usx2y_audio_stream_new(card, 0xA, 0x8);\n\tif (err < 0)\n\t\treturn err;\n\tif (le16_to_cpu(usx2y(card)->dev->descriptor.idProduct) == USB_ID_US428) {\n\t\terr = usx2y_audio_stream_new(card, 0, 0xA);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (le16_to_cpu(usx2y(card)->dev->descriptor.idProduct) != USB_ID_US122)\n\t\terr = usx2y_rate_set(usx2y(card), 44100);\t\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}