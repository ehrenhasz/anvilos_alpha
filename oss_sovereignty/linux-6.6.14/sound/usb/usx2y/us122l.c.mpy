{
  "module_name": "us122l.c",
  "hash_id": "c4452d6bf923cf6590d6e36525723ef88d19d24998733035a4ba1da10217a981",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/us122l.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/hwdep.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#define MODNAME \"US122L\"\n#include \"usb_stream.c\"\n#include \"../usbaudio.h\"\n#include \"../midi.h\"\n#include \"us122l.h\"\n\nMODULE_AUTHOR(\"Karsten Wiese <fzu@wemgehoertderstaat.de>\");\nMODULE_DESCRIPTION(\"TASCAM \"NAME_ALLCAPS\" Version 0.5\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \n\t\t\t\t\t\t\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \"NAME_ALLCAPS\".\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \"NAME_ALLCAPS\".\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \"NAME_ALLCAPS\".\");\n\n \n#define US122L_FLAG_US144\tBIT(0)\n\nstatic int snd_us122l_card_used[SNDRV_CARDS];\n\nstatic int us122l_create_usbmidi(struct snd_card *card)\n{\n\tstatic const struct snd_usb_midi_endpoint_info quirk_data = {\n\t\t.out_ep = 4,\n\t\t.in_ep = 3,\n\t\t.out_cables =\t0x001,\n\t\t.in_cables =\t0x001\n\t};\n\tstatic const struct snd_usb_audio_quirk quirk = {\n\t\t.vendor_name =\t\"US122L\",\n\t\t.product_name =\tNAME_ALLCAPS,\n\t\t.ifnum =\t1,\n\t\t.type = QUIRK_MIDI_US122L,\n\t\t.data = &quirk_data\n\t};\n\tstruct usb_device *dev = US122L(card)->dev;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, 1);\n\n\treturn snd_usbmidi_create(card, iface,\n\t\t\t\t  &US122L(card)->midi_list, &quirk);\n}\n\nstatic int us144_create_usbmidi(struct snd_card *card)\n{\n\tstatic const struct snd_usb_midi_endpoint_info quirk_data = {\n\t\t.out_ep = 4,\n\t\t.in_ep = 3,\n\t\t.out_cables =\t0x001,\n\t\t.in_cables =\t0x001\n\t};\n\tstatic const struct snd_usb_audio_quirk quirk = {\n\t\t.vendor_name =\t\"US144\",\n\t\t.product_name =\tNAME_ALLCAPS,\n\t\t.ifnum =\t0,\n\t\t.type = QUIRK_MIDI_US122L,\n\t\t.data = &quirk_data\n\t};\n\tstruct usb_device *dev = US122L(card)->dev;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, 0);\n\n\treturn snd_usbmidi_create(card, iface,\n\t\t\t\t  &US122L(card)->midi_list, &quirk);\n}\n\nstatic void pt_info_set(struct usb_device *dev, u8 v)\n{\n\tint ret;\n\n\tret = usb_control_msg_send(dev, 0, 'I',\n\t\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t   v, 0, NULL, 0, 1000, GFP_NOIO);\n\tsnd_printdd(KERN_DEBUG \"%i\\n\", ret);\n}\n\nstatic void usb_stream_hwdep_vm_open(struct vm_area_struct *area)\n{\n\tstruct us122l *us122l = area->vm_private_data;\n\n\tatomic_inc(&us122l->mmap_count);\n\tsnd_printdd(KERN_DEBUG \"%i\\n\", atomic_read(&us122l->mmap_count));\n}\n\nstatic vm_fault_t usb_stream_hwdep_vm_fault(struct vm_fault *vmf)\n{\n\tunsigned long offset;\n\tstruct page *page;\n\tvoid *vaddr;\n\tstruct us122l *us122l = vmf->vma->vm_private_data;\n\tstruct usb_stream *s;\n\n\tmutex_lock(&us122l->mutex);\n\ts = us122l->sk.s;\n\tif (!s)\n\t\tgoto unlock;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset < PAGE_ALIGN(s->read_size)) {\n\t\tvaddr = (char *)s + offset;\n\t} else {\n\t\toffset -= PAGE_ALIGN(s->read_size);\n\t\tif (offset >= PAGE_ALIGN(s->write_size))\n\t\t\tgoto unlock;\n\n\t\tvaddr = us122l->sk.write_page + offset;\n\t}\n\tpage = virt_to_page(vaddr);\n\n\tget_page(page);\n\tmutex_unlock(&us122l->mutex);\n\n\tvmf->page = page;\n\n\treturn 0;\nunlock:\n\tmutex_unlock(&us122l->mutex);\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic void usb_stream_hwdep_vm_close(struct vm_area_struct *area)\n{\n\tstruct us122l *us122l = area->vm_private_data;\n\n\tatomic_dec(&us122l->mmap_count);\n\tsnd_printdd(KERN_DEBUG \"%i\\n\", atomic_read(&us122l->mmap_count));\n}\n\nstatic const struct vm_operations_struct usb_stream_hwdep_vm_ops = {\n\t.open = usb_stream_hwdep_vm_open,\n\t.fault = usb_stream_hwdep_vm_fault,\n\t.close = usb_stream_hwdep_vm_close,\n};\n\nstatic int usb_stream_hwdep_open(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct us122l\t*us122l = hw->private_data;\n\tstruct usb_interface *iface;\n\n\tsnd_printdd(KERN_DEBUG \"%p %p\\n\", hw, file);\n\tif (hw->used >= 2)\n\t\treturn -EBUSY;\n\n\tif (!us122l->first)\n\t\tus122l->first = file;\n\n\tif (us122l->is_us144) {\n\t\tiface = usb_ifnum_to_if(us122l->dev, 0);\n\t\tusb_autopm_get_interface(iface);\n\t}\n\tiface = usb_ifnum_to_if(us122l->dev, 1);\n\tusb_autopm_get_interface(iface);\n\treturn 0;\n}\n\nstatic int usb_stream_hwdep_release(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct us122l\t*us122l = hw->private_data;\n\tstruct usb_interface *iface;\n\n\tsnd_printdd(KERN_DEBUG \"%p %p\\n\", hw, file);\n\n\tif (us122l->is_us144) {\n\t\tiface = usb_ifnum_to_if(us122l->dev, 0);\n\t\tusb_autopm_put_interface(iface);\n\t}\n\tiface = usb_ifnum_to_if(us122l->dev, 1);\n\tusb_autopm_put_interface(iface);\n\tif (us122l->first == file)\n\t\tus122l->first = NULL;\n\tmutex_lock(&us122l->mutex);\n\tif (us122l->master == file)\n\t\tus122l->master = us122l->slave;\n\n\tus122l->slave = NULL;\n\tmutex_unlock(&us122l->mutex);\n\treturn 0;\n}\n\nstatic int usb_stream_hwdep_mmap(struct snd_hwdep *hw,\n\t\t\t\t struct file *filp, struct vm_area_struct *area)\n{\n\tunsigned long\tsize = area->vm_end - area->vm_start;\n\tstruct us122l\t*us122l = hw->private_data;\n\tunsigned long offset;\n\tstruct usb_stream *s;\n\tint err = 0;\n\tbool read;\n\n\toffset = area->vm_pgoff << PAGE_SHIFT;\n\tmutex_lock(&us122l->mutex);\n\ts = us122l->sk.s;\n\tread = offset < s->read_size;\n\tif (read && area->vm_flags & VM_WRITE) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\tsnd_printdd(KERN_DEBUG \"%lu %u\\n\", size,\n\t\t    read ? s->read_size : s->write_size);\n\t \n\tif (size > PAGE_ALIGN(read ? s->read_size : s->write_size)) {\n\t\tsnd_printk(KERN_WARNING \"%lu > %u\\n\", size,\n\t\t\t   read ? s->read_size : s->write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tarea->vm_ops = &usb_stream_hwdep_vm_ops;\n\tvm_flags_set(area, VM_DONTDUMP);\n\tif (!read)\n\t\tvm_flags_set(area, VM_DONTEXPAND);\n\tarea->vm_private_data = us122l;\n\tatomic_inc(&us122l->mmap_count);\nout:\n\tmutex_unlock(&us122l->mutex);\n\treturn err;\n}\n\nstatic __poll_t usb_stream_hwdep_poll(struct snd_hwdep *hw,\n\t\t\t\t\t  struct file *file, poll_table *wait)\n{\n\tstruct us122l\t*us122l = hw->private_data;\n\tunsigned int\t*polled;\n\t__poll_t\tmask;\n\n\tpoll_wait(file, &us122l->sk.sleep, wait);\n\n\tmask = EPOLLIN | EPOLLOUT | EPOLLWRNORM | EPOLLERR;\n\tif (mutex_trylock(&us122l->mutex)) {\n\t\tstruct usb_stream *s = us122l->sk.s;\n\n\t\tif (s && s->state == usb_stream_ready) {\n\t\t\tif (us122l->first == file)\n\t\t\t\tpolled = &s->periods_polled;\n\t\t\telse\n\t\t\t\tpolled = &us122l->second_periods_polled;\n\t\t\tif (*polled != s->periods_done) {\n\t\t\t\t*polled = s->periods_done;\n\t\t\t\tmask = EPOLLIN | EPOLLOUT | EPOLLWRNORM;\n\t\t\t} else {\n\t\t\t\tmask = 0;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&us122l->mutex);\n\t}\n\treturn mask;\n}\n\nstatic void us122l_stop(struct us122l *us122l)\n{\n\tstruct list_head *p;\n\n\tlist_for_each(p, &us122l->midi_list)\n\t\tsnd_usbmidi_input_stop(p);\n\n\tusb_stream_stop(&us122l->sk);\n\tusb_stream_free(&us122l->sk);\n}\n\nstatic int us122l_set_sample_rate(struct usb_device *dev, int rate)\n{\n\tunsigned int ep = 0x81;\n\tunsigned char data[3];\n\tint err;\n\n\tdata[0] = rate;\n\tdata[1] = rate >> 8;\n\tdata[2] = rate >> 16;\n\terr = usb_control_msg_send(dev, 0, UAC_SET_CUR,\n\t\t\t\t   USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t\t   UAC_EP_CS_ATTR_SAMPLE_RATE << 8, ep, data, 3,\n\t\t\t\t   1000, GFP_NOIO);\n\tif (err)\n\t\tsnd_printk(KERN_ERR \"%d: cannot set freq %d to ep 0x%x\\n\",\n\t\t\t   dev->devnum, rate, ep);\n\treturn err;\n}\n\nstatic bool us122l_start(struct us122l *us122l,\n\t\t\t unsigned int rate, unsigned int period_frames)\n{\n\tstruct list_head *p;\n\tint err;\n\tunsigned int use_packsize = 0;\n\tbool success = false;\n\n\tif (us122l->dev->speed == USB_SPEED_HIGH) {\n\t\t \n\t\tswitch (rate) {\n\t\tcase 44100:\n\t\t\tuse_packsize = 36;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tuse_packsize = 42;\n\t\t\tbreak;\n\t\tcase 88200:\n\t\t\tuse_packsize = 72;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!usb_stream_new(&us122l->sk, us122l->dev, 1, 2,\n\t\t\t    rate, use_packsize, period_frames, 6))\n\t\tgoto out;\n\n\terr = us122l_set_sample_rate(us122l->dev, rate);\n\tif (err < 0) {\n\t\tus122l_stop(us122l);\n\t\tsnd_printk(KERN_ERR \"us122l_set_sample_rate error\\n\");\n\t\tgoto out;\n\t}\n\terr = usb_stream_start(&us122l->sk);\n\tif (err < 0) {\n\t\tus122l_stop(us122l);\n\t\tsnd_printk(KERN_ERR \"%s error %i\\n\", __func__, err);\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &us122l->midi_list)\n\t\tsnd_usbmidi_input_start(p);\n\tsuccess = true;\nout:\n\treturn success;\n}\n\nstatic int usb_stream_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\n\t\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct usb_stream_config cfg;\n\tstruct us122l *us122l = hw->private_data;\n\tstruct usb_stream *s;\n\tunsigned int min_period_frames;\n\tint err = 0;\n\tbool high_speed;\n\n\tif (cmd != SNDRV_USB_STREAM_IOCTL_SET_PARAMS)\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&cfg, (void __user *)arg, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tif (cfg.version != USB_STREAM_INTERFACE_VERSION)\n\t\treturn -ENXIO;\n\n\thigh_speed = us122l->dev->speed == USB_SPEED_HIGH;\n\tif ((cfg.sample_rate != 44100 && cfg.sample_rate != 48000  &&\n\t     (!high_speed ||\n\t      (cfg.sample_rate != 88200 && cfg.sample_rate != 96000))) ||\n\t    cfg.frame_size != 6 ||\n\t    cfg.period_frames > 0x3000)\n\t\treturn -EINVAL;\n\n\tswitch (cfg.sample_rate) {\n\tcase 44100:\n\t\tmin_period_frames = 48;\n\t\tbreak;\n\tcase 48000:\n\t\tmin_period_frames = 52;\n\t\tbreak;\n\tdefault:\n\t\tmin_period_frames = 104;\n\t\tbreak;\n\t}\n\tif (!high_speed)\n\t\tmin_period_frames <<= 1;\n\tif (cfg.period_frames < min_period_frames)\n\t\treturn -EINVAL;\n\n\tsnd_power_wait(hw->card);\n\n\tmutex_lock(&us122l->mutex);\n\ts = us122l->sk.s;\n\tif (!us122l->master) {\n\t\tus122l->master = file;\n\t} else if (us122l->master != file) {\n\t\tif (!s || memcmp(&cfg, &s->cfg, sizeof(cfg))) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tus122l->slave = file;\n\t}\n\tif (!s || memcmp(&cfg, &s->cfg, sizeof(cfg)) ||\n\t    s->state == usb_stream_xrun) {\n\t\tus122l_stop(us122l);\n\t\tif (!us122l_start(us122l, cfg.sample_rate, cfg.period_frames))\n\t\t\terr = -EIO;\n\t\telse\n\t\t\terr = 1;\n\t}\nunlock:\n\tmutex_unlock(&us122l->mutex);\n\twake_up_all(&us122l->sk.sleep);\n\treturn err;\n}\n\n#define SND_USB_STREAM_ID \"USB STREAM\"\nstatic int usb_stream_hwdep_new(struct snd_card *card)\n{\n\tint err;\n\tstruct snd_hwdep *hw;\n\tstruct usb_device *dev = US122L(card)->dev;\n\n\terr = snd_hwdep_new(card, SND_USB_STREAM_ID, 0, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thw->iface = SNDRV_HWDEP_IFACE_USB_STREAM;\n\thw->private_data = US122L(card);\n\thw->ops.open = usb_stream_hwdep_open;\n\thw->ops.release = usb_stream_hwdep_release;\n\thw->ops.ioctl = usb_stream_hwdep_ioctl;\n\thw->ops.ioctl_compat = usb_stream_hwdep_ioctl;\n\thw->ops.mmap = usb_stream_hwdep_mmap;\n\thw->ops.poll = usb_stream_hwdep_poll;\n\n\tsprintf(hw->name, \"/dev/bus/usb/%03d/%03d/hwdeppcm\",\n\t\tdev->bus->busnum, dev->devnum);\n\treturn 0;\n}\n\nstatic bool us122l_create_card(struct snd_card *card)\n{\n\tint err;\n\tstruct us122l *us122l = US122L(card);\n\n\tif (us122l->is_us144) {\n\t\terr = usb_set_interface(us122l->dev, 0, 1);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\terr = usb_set_interface(us122l->dev, 1, 1);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\t\treturn false;\n\t}\n\n\tpt_info_set(us122l->dev, 0x11);\n\tpt_info_set(us122l->dev, 0x10);\n\n\tif (!us122l_start(us122l, 44100, 256))\n\t\treturn false;\n\n\tif (us122l->is_us144)\n\t\terr = us144_create_usbmidi(card);\n\telse\n\t\terr = us122l_create_usbmidi(card);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"us122l_create_usbmidi error %i\\n\", err);\n\t\tgoto stop;\n\t}\n\terr = usb_stream_hwdep_new(card);\n\tif (err < 0) {\n\t\t \n\t\tstruct list_head *p;\n\n\t\tlist_for_each(p, &us122l->midi_list)\n\t\t\tsnd_usbmidi_disconnect(p);\n\n\t\tgoto stop;\n\t}\n\treturn true;\n\nstop:\n\tus122l_stop(us122l);\n\treturn false;\n}\n\nstatic void snd_us122l_free(struct snd_card *card)\n{\n\tstruct us122l\t*us122l = US122L(card);\n\tint\t\tindex = us122l->card_index;\n\n\tif (index >= 0 && index < SNDRV_CARDS)\n\t\tsnd_us122l_card_used[index] = 0;\n}\n\nstatic int usx2y_create_card(struct usb_device *device,\n\t\t\t     struct usb_interface *intf,\n\t\t\t     struct snd_card **cardp,\n\t\t\t     unsigned long flags)\n{\n\tint\t\tdev;\n\tstruct snd_card *card;\n\tint err;\n\n\tfor (dev = 0; dev < SNDRV_CARDS; ++dev)\n\t\tif (enable[dev] && !snd_us122l_card_used[dev])\n\t\t\tbreak;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\terr = snd_card_new(&intf->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct us122l), &card);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_us122l_card_used[US122L(card)->card_index = dev] = 1;\n\tcard->private_free = snd_us122l_free;\n\tUS122L(card)->dev = device;\n\tmutex_init(&US122L(card)->mutex);\n\tinit_waitqueue_head(&US122L(card)->sk.sleep);\n\tUS122L(card)->is_us144 = flags & US122L_FLAG_US144;\n\tINIT_LIST_HEAD(&US122L(card)->midi_list);\n\tstrcpy(card->driver, \"USB \"NAME_ALLCAPS\"\");\n\tsprintf(card->shortname, \"TASCAM \"NAME_ALLCAPS\"\");\n\tsprintf(card->longname, \"%s (%x:%x if %d at %03d/%03d)\",\n\t\tcard->shortname,\n\t\tle16_to_cpu(device->descriptor.idVendor),\n\t\tle16_to_cpu(device->descriptor.idProduct),\n\t\t0,\n\t\tUS122L(card)->dev->bus->busnum,\n\t\tUS122L(card)->dev->devnum\n\t\t);\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int us122l_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *device_id,\n\t\t\t    struct snd_card **cardp)\n{\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tstruct snd_card *card;\n\tint err;\n\n\terr = usx2y_create_card(device, intf, &card, device_id->driver_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!us122l_create_card(card)) {\n\t\tsnd_card_free(card);\n\t\treturn -EINVAL;\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tusb_get_intf(usb_ifnum_to_if(device, 0));\n\tusb_get_dev(device);\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic int snd_us122l_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tstruct snd_card *card;\n\tint err;\n\n\tif (id->driver_info & US122L_FLAG_US144 &&\n\t\t\tdevice->speed == USB_SPEED_HIGH) {\n\t\tsnd_printk(KERN_ERR \"disable ehci-hcd to run US-144\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnd_printdd(KERN_DEBUG\"%p:%i\\n\",\n\t\t    intf, intf->cur_altsetting->desc.bInterfaceNumber);\n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 1)\n\t\treturn 0;\n\n\terr = us122l_usb_probe(usb_get_intf(intf), id, &card);\n\tif (err < 0) {\n\t\tusb_put_intf(intf);\n\t\treturn err;\n\t}\n\n\tusb_set_intfdata(intf, card);\n\treturn 0;\n}\n\nstatic void snd_us122l_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_card *card;\n\tstruct us122l *us122l;\n\tstruct list_head *p;\n\n\tcard = usb_get_intfdata(intf);\n\tif (!card)\n\t\treturn;\n\n\tsnd_card_disconnect(card);\n\n\tus122l = US122L(card);\n\tmutex_lock(&us122l->mutex);\n\tus122l_stop(us122l);\n\tmutex_unlock(&us122l->mutex);\n\n\t \n\tlist_for_each(p, &us122l->midi_list) {\n\t\tsnd_usbmidi_disconnect(p);\n\t}\n\n\tusb_put_intf(usb_ifnum_to_if(us122l->dev, 0));\n\tusb_put_intf(usb_ifnum_to_if(us122l->dev, 1));\n\tusb_put_dev(us122l->dev);\n\n\twhile (atomic_read(&us122l->mmap_count))\n\t\tmsleep(500);\n\n\tsnd_card_free(card);\n}\n\nstatic int snd_us122l_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_card *card;\n\tstruct us122l *us122l;\n\tstruct list_head *p;\n\n\tcard = usb_get_intfdata(intf);\n\tif (!card)\n\t\treturn 0;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tus122l = US122L(card);\n\tif (!us122l)\n\t\treturn 0;\n\n\tlist_for_each(p, &us122l->midi_list)\n\t\tsnd_usbmidi_input_stop(p);\n\n\tmutex_lock(&us122l->mutex);\n\tusb_stream_stop(&us122l->sk);\n\tmutex_unlock(&us122l->mutex);\n\n\treturn 0;\n}\n\nstatic int snd_us122l_resume(struct usb_interface *intf)\n{\n\tstruct snd_card *card;\n\tstruct us122l *us122l;\n\tstruct list_head *p;\n\tint err;\n\n\tcard = usb_get_intfdata(intf);\n\tif (!card)\n\t\treturn 0;\n\n\tus122l = US122L(card);\n\tif (!us122l)\n\t\treturn 0;\n\n\tmutex_lock(&us122l->mutex);\n\t \n\tif (us122l->is_us144) {\n\t\terr = usb_set_interface(us122l->dev, 0, 1);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\terr = usb_set_interface(us122l->dev, 1, 1);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR \"usb_set_interface error\\n\");\n\t\tgoto unlock;\n\t}\n\n\tpt_info_set(us122l->dev, 0x11);\n\tpt_info_set(us122l->dev, 0x10);\n\n\terr = us122l_set_sample_rate(us122l->dev,\n\t\t\t\t     us122l->sk.s->cfg.sample_rate);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"us122l_set_sample_rate error\\n\");\n\t\tgoto unlock;\n\t}\n\terr = usb_stream_start(&us122l->sk);\n\tif (err)\n\t\tgoto unlock;\n\n\tlist_for_each(p, &us122l->midi_list)\n\t\tsnd_usbmidi_input_start(p);\nunlock:\n\tmutex_unlock(&us122l->mutex);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn err;\n}\n\nstatic const struct usb_device_id snd_us122l_usb_id_table[] = {\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x0644,\n\t\t.idProduct =\tUSB_ID_US122L\n\t},\n\t{\t \n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x0644,\n\t\t.idProduct =\tUSB_ID_US144,\n\t\t.driver_info =\tUS122L_FLAG_US144\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x0644,\n\t\t.idProduct =\tUSB_ID_US122MKII\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x0644,\n\t\t.idProduct =\tUSB_ID_US144MKII,\n\t\t.driver_info =\tUS122L_FLAG_US144\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(usb, snd_us122l_usb_id_table);\n\nstatic struct usb_driver snd_us122l_usb_driver = {\n\t.name =\t\t\"snd-usb-us122l\",\n\t.probe =\tsnd_us122l_probe,\n\t.disconnect =\tsnd_us122l_disconnect,\n\t.suspend =\tsnd_us122l_suspend,\n\t.resume =\tsnd_us122l_resume,\n\t.reset_resume =\tsnd_us122l_resume,\n\t.id_table =\tsnd_us122l_usb_id_table,\n\t.supports_autosuspend = 1\n};\n\nmodule_usb_driver(snd_us122l_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}