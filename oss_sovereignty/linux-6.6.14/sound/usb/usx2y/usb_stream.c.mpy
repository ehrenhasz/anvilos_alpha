{
  "module_name": "usb_stream.c",
  "hash_id": "829b2c7f1c38a6a562e05a4f68a53891a5caea11bc3cda5f8a59b9b283dd2914",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/usb_stream.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/gfp.h>\n\n#include \"usb_stream.h\"\n\n \n\nstatic unsigned int usb_stream_next_packet_size(struct usb_stream_kernel *sk)\n{\n\tstruct usb_stream *s = sk->s;\n\n\tsk->out_phase_peeked = (sk->out_phase & 0xffff) + sk->freqn;\n\treturn (sk->out_phase_peeked >> 16) * s->cfg.frame_size;\n}\n\nstatic void playback_prep_freqn(struct usb_stream_kernel *sk, struct urb *urb)\n{\n\tstruct usb_stream *s = sk->s;\n\tint pack, lb = 0;\n\n\tfor (pack = 0; pack < sk->n_o_ps; pack++) {\n\t\tint l = usb_stream_next_packet_size(sk);\n\n\t\tif (s->idle_outsize + lb + l > s->period_size)\n\t\t\tgoto check;\n\n\t\tsk->out_phase = sk->out_phase_peeked;\n\t\turb->iso_frame_desc[pack].offset = lb;\n\t\turb->iso_frame_desc[pack].length = l;\n\t\tlb += l;\n\t}\n\tsnd_printdd(KERN_DEBUG \"%i\\n\", lb);\n\ncheck:\n\turb->number_of_packets = pack;\n\turb->transfer_buffer_length = lb;\n\ts->idle_outsize += lb - s->period_size;\n\tsnd_printdd(KERN_DEBUG \"idle=%i ul=%i ps=%i\\n\", s->idle_outsize,\n\t\t    lb, s->period_size);\n}\n\nstatic int init_pipe_urbs(struct usb_stream_kernel *sk,\n\t\t\t  unsigned int use_packsize,\n\t\t\t  struct urb **urbs, char *transfer,\n\t\t\t  struct usb_device *dev, int pipe)\n{\n\tint u, p;\n\tint maxpacket = use_packsize ?\n\t\tuse_packsize : usb_maxpacket(dev, pipe);\n\tint transfer_length = maxpacket * sk->n_o_ps;\n\n\tfor (u = 0; u < USB_STREAM_NURBS;\n\t     ++u, transfer += transfer_length) {\n\t\tstruct urb *urb = urbs[u];\n\t\tstruct usb_iso_packet_descriptor *desc;\n\n\t\turb->transfer_buffer = transfer;\n\t\turb->dev = dev;\n\t\turb->pipe = pipe;\n\t\turb->number_of_packets = sk->n_o_ps;\n\t\turb->context = sk;\n\t\turb->interval = 1;\n\t\tif (usb_pipeout(pipe))\n\t\t\tcontinue;\n\t\tif (usb_urb_ep_type_check(urb))\n\t\t\treturn -EINVAL;\n\n\t\turb->transfer_buffer_length = transfer_length;\n\t\tdesc = urb->iso_frame_desc;\n\t\tdesc->offset = 0;\n\t\tdesc->length = maxpacket;\n\t\tfor (p = 1; p < sk->n_o_ps; ++p) {\n\t\t\tdesc[p].offset = desc[p - 1].offset + maxpacket;\n\t\t\tdesc[p].length = maxpacket;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_urbs(struct usb_stream_kernel *sk, unsigned int use_packsize,\n\t\t     struct usb_device *dev, int in_pipe, int out_pipe)\n{\n\tstruct usb_stream\t*s = sk->s;\n\tchar\t\t\t*indata =\n\t\t(char *)s + sizeof(*s) + sizeof(struct usb_stream_packet) * s->inpackets;\n\tint\t\t\tu;\n\n\tfor (u = 0; u < USB_STREAM_NURBS; ++u) {\n\t\tsk->inurb[u] = usb_alloc_urb(sk->n_o_ps, GFP_KERNEL);\n\t\tif (!sk->inurb[u])\n\t\t\treturn -ENOMEM;\n\n\t\tsk->outurb[u] = usb_alloc_urb(sk->n_o_ps, GFP_KERNEL);\n\t\tif (!sk->outurb[u])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (init_pipe_urbs(sk, use_packsize, sk->inurb, indata, dev, in_pipe) ||\n\t    init_pipe_urbs(sk, use_packsize, sk->outurb, sk->write_page, dev,\n\t\t\t   out_pipe))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic inline unsigned int get_usb_full_speed_rate(unsigned int rate)\n{\n\treturn ((rate << 13) + 62) / 125;\n}\n\n \nstatic inline unsigned int get_usb_high_speed_rate(unsigned int rate)\n{\n\treturn ((rate << 10) + 62) / 125;\n}\n\nvoid usb_stream_free(struct usb_stream_kernel *sk)\n{\n\tstruct usb_stream *s;\n\tunsigned int u;\n\n\tfor (u = 0; u < USB_STREAM_NURBS; ++u) {\n\t\tusb_free_urb(sk->inurb[u]);\n\t\tsk->inurb[u] = NULL;\n\t\tusb_free_urb(sk->outurb[u]);\n\t\tsk->outurb[u] = NULL;\n\t}\n\n\ts = sk->s;\n\tif (!s)\n\t\treturn;\n\n\tif (sk->write_page) {\n\t\tfree_pages_exact(sk->write_page, s->write_size);\n\t\tsk->write_page = NULL;\n\t}\n\n\tfree_pages_exact(s, s->read_size);\n\tsk->s = NULL;\n}\n\nstruct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,\n\t\t\t\t  struct usb_device *dev,\n\t\t\t\t  unsigned int in_endpoint,\n\t\t\t\t  unsigned int out_endpoint,\n\t\t\t\t  unsigned int sample_rate,\n\t\t\t\t  unsigned int use_packsize,\n\t\t\t\t  unsigned int period_frames,\n\t\t\t\t  unsigned int frame_size)\n{\n\tint packets, max_packsize;\n\tint in_pipe, out_pipe;\n\tint read_size = sizeof(struct usb_stream);\n\tint write_size;\n\tint usb_frames = dev->speed == USB_SPEED_HIGH ? 8000 : 1000;\n\n\tin_pipe = usb_rcvisocpipe(dev, in_endpoint);\n\tout_pipe = usb_sndisocpipe(dev, out_endpoint);\n\n\tmax_packsize = use_packsize ?\n\t\tuse_packsize : usb_maxpacket(dev, in_pipe);\n\n\t \n\n\tpackets = period_frames * usb_frames / sample_rate + 1;\n\n\tif (dev->speed == USB_SPEED_HIGH)\n\t\tpackets = (packets + 7) & ~7;\n\n\tread_size += packets * USB_STREAM_URBDEPTH *\n\t\t(max_packsize + sizeof(struct usb_stream_packet));\n\n\tmax_packsize = usb_maxpacket(dev, out_pipe);\n\twrite_size = max_packsize * packets * USB_STREAM_URBDEPTH;\n\n\tif (read_size >= 256*PAGE_SIZE || write_size >= 256*PAGE_SIZE) {\n\t\tsnd_printk(KERN_WARNING \"a size exceeds 128*PAGE_SIZE\\n\");\n\t\tgoto out;\n\t}\n\n\tsk->s = alloc_pages_exact(read_size,\n\t\t\t\t  GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN);\n\tif (!sk->s) {\n\t\tpr_warn(\"us122l: couldn't allocate read buffer\\n\");\n\t\tgoto out;\n\t}\n\tsk->s->cfg.version = USB_STREAM_INTERFACE_VERSION;\n\n\tsk->s->read_size = read_size;\n\n\tsk->s->cfg.sample_rate = sample_rate;\n\tsk->s->cfg.frame_size = frame_size;\n\tsk->n_o_ps = packets;\n\tsk->s->inpackets = packets * USB_STREAM_URBDEPTH;\n\tsk->s->cfg.period_frames = period_frames;\n\tsk->s->period_size = frame_size * period_frames;\n\n\tsk->s->write_size = write_size;\n\n\tsk->write_page = alloc_pages_exact(write_size,\n\t\t\t\t\t   GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN);\n\tif (!sk->write_page) {\n\t\tpr_warn(\"us122l: couldn't allocate write buffer\\n\");\n\t\tusb_stream_free(sk);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (dev->speed == USB_SPEED_FULL)\n\t\tsk->freqn = get_usb_full_speed_rate(sample_rate);\n\telse\n\t\tsk->freqn = get_usb_high_speed_rate(sample_rate);\n\n\tif (init_urbs(sk, use_packsize, dev, in_pipe, out_pipe) < 0) {\n\t\tusb_stream_free(sk);\n\t\treturn NULL;\n\t}\n\n\tsk->s->state = usb_stream_stopped;\nout:\n\treturn sk->s;\n}\n\n \n\nstatic bool balance_check(struct usb_stream_kernel *sk, struct urb *urb)\n{\n\tbool r;\n\n\tif (unlikely(urb->status)) {\n\t\tif (urb->status != -ESHUTDOWN && urb->status != -ENOENT)\n\t\t\tsnd_printk(KERN_WARNING \"status=%i\\n\", urb->status);\n\t\tsk->iso_frame_balance = 0x7FFFFFFF;\n\t\treturn false;\n\t}\n\tr = sk->iso_frame_balance == 0;\n\tif (!r)\n\t\tsk->i_urb = urb;\n\treturn r;\n}\n\nstatic bool balance_playback(struct usb_stream_kernel *sk, struct urb *urb)\n{\n\tsk->iso_frame_balance += urb->number_of_packets;\n\treturn balance_check(sk, urb);\n}\n\nstatic bool balance_capture(struct usb_stream_kernel *sk, struct urb *urb)\n{\n\tsk->iso_frame_balance -= urb->number_of_packets;\n\treturn balance_check(sk, urb);\n}\n\nstatic void subs_set_complete(struct urb **urbs, void (*complete)(struct urb *))\n{\n\tint u;\n\n\tfor (u = 0; u < USB_STREAM_NURBS; u++) {\n\t\tstruct urb *urb = urbs[u];\n\n\t\turb->complete = complete;\n\t}\n}\n\nstatic int usb_stream_prepare_playback(struct usb_stream_kernel *sk,\n\t\tstruct urb *inurb)\n{\n\tstruct usb_stream *s = sk->s;\n\tstruct urb *io;\n\tstruct usb_iso_packet_descriptor *id, *od;\n\tint p = 0, lb = 0, l = 0;\n\n\tio = sk->idle_outurb;\n\tod = io->iso_frame_desc;\n\n\tfor (; s->sync_packet < 0; ++p, ++s->sync_packet) {\n\t\tstruct urb *ii = sk->completed_inurb;\n\n\t\tid = ii->iso_frame_desc +\n\t\t\tii->number_of_packets + s->sync_packet;\n\t\tl = id->actual_length;\n\n\t\tod[p].length = l;\n\t\tod[p].offset = lb;\n\t\tlb += l;\n\t}\n\n\tfor (;\n\t     s->sync_packet < inurb->number_of_packets && p < sk->n_o_ps;\n\t     ++p, ++s->sync_packet) {\n\t\tl = inurb->iso_frame_desc[s->sync_packet].actual_length;\n\n\t\tif (s->idle_outsize + lb + l > s->period_size)\n\t\t\tgoto check_ok;\n\n\t\tod[p].length = l;\n\t\tod[p].offset = lb;\n\t\tlb += l;\n\t}\n\ncheck_ok:\n\ts->sync_packet -= inurb->number_of_packets;\n\tif (unlikely(s->sync_packet < -2 || s->sync_packet > 0)) {\n\t\tsnd_printk(KERN_WARNING \"invalid sync_packet = %i;\"\n\t\t\t   \" p=%i nop=%i %i %x %x %x > %x\\n\",\n\t\t\t   s->sync_packet, p, inurb->number_of_packets,\n\t\t\t   s->idle_outsize + lb + l,\n\t\t\t   s->idle_outsize, lb,  l,\n\t\t\t   s->period_size);\n\t\treturn -1;\n\t}\n\tif (unlikely(lb % s->cfg.frame_size)) {\n\t\tsnd_printk(KERN_WARNING\"invalid outsize = %i\\n\",\n\t\t\t   lb);\n\t\treturn -1;\n\t}\n\ts->idle_outsize += lb - s->period_size;\n\tio->number_of_packets = p;\n\tio->transfer_buffer_length = lb;\n\tif (s->idle_outsize <= 0)\n\t\treturn 0;\n\n\tsnd_printk(KERN_WARNING \"idle=%i\\n\", s->idle_outsize);\n\treturn -1;\n}\n\nstatic void prepare_inurb(int number_of_packets, struct urb *iu)\n{\n\tstruct usb_iso_packet_descriptor *id;\n\tint p;\n\n\tiu->number_of_packets = number_of_packets;\n\tid = iu->iso_frame_desc;\n\tid->offset = 0;\n\tfor (p = 0; p < iu->number_of_packets - 1; ++p)\n\t\tid[p + 1].offset = id[p].offset + id[p].length;\n\n\tiu->transfer_buffer_length =\n\t\tid[0].length * iu->number_of_packets;\n}\n\nstatic int submit_urbs(struct usb_stream_kernel *sk,\n\t\t       struct urb *inurb, struct urb *outurb)\n{\n\tint err;\n\n\tprepare_inurb(sk->idle_outurb->number_of_packets, sk->idle_inurb);\n\terr = usb_submit_urb(sk->idle_inurb, GFP_ATOMIC);\n\tif (err < 0)\n\t\tgoto report_failure;\n\n\tsk->idle_inurb = sk->completed_inurb;\n\tsk->completed_inurb = inurb;\n\terr = usb_submit_urb(sk->idle_outurb, GFP_ATOMIC);\n\tif (err < 0)\n\t\tgoto report_failure;\n\n\tsk->idle_outurb = sk->completed_outurb;\n\tsk->completed_outurb = outurb;\n\treturn 0;\n\nreport_failure:\n\tsnd_printk(KERN_ERR \"%i\\n\", err);\n\treturn err;\n}\n\n#ifdef DEBUG_LOOP_BACK\n \nstatic void loop_back(struct usb_stream *s)\n{\n\tchar *i, *o;\n\tint il, ol, l, p;\n\tstruct urb *iu;\n\tstruct usb_iso_packet_descriptor *id;\n\n\to = s->playback1st_to;\n\tol = s->playback1st_size;\n\tl = 0;\n\n\tif (s->insplit_pack >= 0) {\n\t\tiu = sk->idle_inurb;\n\t\tid = iu->iso_frame_desc;\n\t\tp = s->insplit_pack;\n\t} else\n\t\tgoto second;\nloop:\n\tfor (; p < iu->number_of_packets && l < s->period_size; ++p) {\n\t\ti = iu->transfer_buffer + id[p].offset;\n\t\til = id[p].actual_length;\n\t\tif (l + il > s->period_size)\n\t\t\til = s->period_size - l;\n\t\tif (il <= ol) {\n\t\t\tmemcpy(o, i, il);\n\t\t\to += il;\n\t\t\tol -= il;\n\t\t} else {\n\t\t\tmemcpy(o, i, ol);\n\t\t\tsingen_6pack(o, ol);\n\t\t\to = s->playback_to;\n\t\t\tmemcpy(o, i + ol, il - ol);\n\t\t\to += il - ol;\n\t\t\tol = s->period_size - s->playback1st_size;\n\t\t}\n\t\tl += il;\n\t}\n\tif (iu == sk->completed_inurb) {\n\t\tif (l != s->period_size)\n\t\t\tprintk(KERN_DEBUG\"%s:%i %i\\n\", __func__, __LINE__,\n\t\t\t       l/(int)s->cfg.frame_size);\n\n\t\treturn;\n\t}\nsecond:\n\tiu = sk->completed_inurb;\n\tid = iu->iso_frame_desc;\n\tp = 0;\n\tgoto loop;\n\n}\n#else\nstatic void loop_back(struct usb_stream *s)\n{\n}\n#endif\n\nstatic void stream_idle(struct usb_stream_kernel *sk,\n\t\t\tstruct urb *inurb, struct urb *outurb)\n{\n\tstruct usb_stream *s = sk->s;\n\tint l, p;\n\tint insize = s->idle_insize;\n\tint urb_size = 0;\n\n\ts->inpacket_split = s->next_inpacket_split;\n\ts->inpacket_split_at = s->next_inpacket_split_at;\n\ts->next_inpacket_split = -1;\n\ts->next_inpacket_split_at = 0;\n\n\tfor (p = 0; p < inurb->number_of_packets; ++p) {\n\t\tstruct usb_iso_packet_descriptor *id = inurb->iso_frame_desc;\n\n\t\tl = id[p].actual_length;\n\t\tif (unlikely(l == 0 || id[p].status)) {\n\t\t\tsnd_printk(KERN_WARNING \"underrun, status=%u\\n\",\n\t\t\t\t   id[p].status);\n\t\t\tgoto err_out;\n\t\t}\n\t\ts->inpacket_head++;\n\t\ts->inpacket_head %= s->inpackets;\n\t\tif (s->inpacket_split == -1)\n\t\t\ts->inpacket_split = s->inpacket_head;\n\n\t\ts->inpacket[s->inpacket_head].offset =\n\t\t\tid[p].offset + (inurb->transfer_buffer - (void *)s);\n\t\ts->inpacket[s->inpacket_head].length = l;\n\t\tif (insize + l > s->period_size &&\n\t\t    s->next_inpacket_split == -1) {\n\t\t\ts->next_inpacket_split = s->inpacket_head;\n\t\t\ts->next_inpacket_split_at = s->period_size - insize;\n\t\t}\n\t\tinsize += l;\n\t\turb_size += l;\n\t}\n\ts->idle_insize += urb_size - s->period_size;\n\tif (s->idle_insize < 0) {\n\t\tsnd_printk(KERN_WARNING \"%i\\n\",\n\t\t\t   (s->idle_insize)/(int)s->cfg.frame_size);\n\t\tgoto err_out;\n\t}\n\ts->insize_done += urb_size;\n\n\tl = s->idle_outsize;\n\ts->outpacket[0].offset = (sk->idle_outurb->transfer_buffer -\n\t\t\t\t  sk->write_page) - l;\n\n\tif (usb_stream_prepare_playback(sk, inurb) < 0)\n\t\tgoto err_out;\n\n\ts->outpacket[0].length = sk->idle_outurb->transfer_buffer_length + l;\n\ts->outpacket[1].offset = sk->completed_outurb->transfer_buffer -\n\t\tsk->write_page;\n\n\tif (submit_urbs(sk, inurb, outurb) < 0)\n\t\tgoto err_out;\n\n\tloop_back(s);\n\ts->periods_done++;\n\twake_up_all(&sk->sleep);\n\treturn;\nerr_out:\n\ts->state = usb_stream_xrun;\n\twake_up_all(&sk->sleep);\n}\n\nstatic void i_capture_idle(struct urb *urb)\n{\n\tstruct usb_stream_kernel *sk = urb->context;\n\n\tif (balance_capture(sk, urb))\n\t\tstream_idle(sk, urb, sk->i_urb);\n}\n\nstatic void i_playback_idle(struct urb *urb)\n{\n\tstruct usb_stream_kernel *sk = urb->context;\n\n\tif (balance_playback(sk, urb))\n\t\tstream_idle(sk, sk->i_urb, urb);\n}\n\nstatic void stream_start(struct usb_stream_kernel *sk,\n\t\t\t struct urb *inurb, struct urb *outurb)\n{\n\tstruct usb_stream *s = sk->s;\n\n\tif (s->state >= usb_stream_sync1) {\n\t\tint l, p, max_diff, max_diff_0;\n\t\tint urb_size = 0;\n\t\tunsigned int frames_per_packet, min_frames = 0;\n\n\t\tframes_per_packet = (s->period_size - s->idle_insize);\n\t\tframes_per_packet <<= 8;\n\t\tframes_per_packet /=\n\t\t\ts->cfg.frame_size * inurb->number_of_packets;\n\t\tframes_per_packet++;\n\n\t\tmax_diff_0 = s->cfg.frame_size;\n\t\tif (s->cfg.period_frames >= 256)\n\t\t\tmax_diff_0 <<= 1;\n\t\tif (s->cfg.period_frames >= 1024)\n\t\t\tmax_diff_0 <<= 1;\n\t\tmax_diff = max_diff_0;\n\t\tfor (p = 0; p < inurb->number_of_packets; ++p) {\n\t\t\tint diff;\n\n\t\t\tl = inurb->iso_frame_desc[p].actual_length;\n\t\t\turb_size += l;\n\n\t\t\tmin_frames += frames_per_packet;\n\t\t\tdiff = urb_size -\n\t\t\t\t(min_frames >> 8) * s->cfg.frame_size;\n\t\t\tif (diff < max_diff) {\n\t\t\t\tsnd_printdd(KERN_DEBUG \"%i %i %i %i\\n\",\n\t\t\t\t\t    s->insize_done,\n\t\t\t\t\t    urb_size / (int)s->cfg.frame_size,\n\t\t\t\t\t    inurb->number_of_packets, diff);\n\t\t\t\tmax_diff = diff;\n\t\t\t}\n\t\t}\n\t\ts->idle_insize -= max_diff - max_diff_0;\n\t\ts->idle_insize += urb_size - s->period_size;\n\t\tif (s->idle_insize < 0) {\n\t\t\tsnd_printk(KERN_WARNING \"%i %i %i\\n\",\n\t\t\t\t   s->idle_insize, urb_size, s->period_size);\n\t\t\treturn;\n\t\t} else if (s->idle_insize == 0) {\n\t\t\ts->next_inpacket_split =\n\t\t\t\t(s->inpacket_head + 1) % s->inpackets;\n\t\t\ts->next_inpacket_split_at = 0;\n\t\t} else {\n\t\t\tunsigned int split = s->inpacket_head;\n\n\t\t\tl = s->idle_insize;\n\t\t\twhile (l > s->inpacket[split].length) {\n\t\t\t\tl -= s->inpacket[split].length;\n\t\t\t\tif (split == 0)\n\t\t\t\t\tsplit = s->inpackets - 1;\n\t\t\t\telse\n\t\t\t\t\tsplit--;\n\t\t\t}\n\t\t\ts->next_inpacket_split = split;\n\t\t\ts->next_inpacket_split_at =\n\t\t\t\ts->inpacket[split].length - l;\n\t\t}\n\n\t\ts->insize_done += urb_size;\n\n\t\tif (usb_stream_prepare_playback(sk, inurb) < 0)\n\t\t\treturn;\n\n\t} else\n\t\tplayback_prep_freqn(sk, sk->idle_outurb);\n\n\tif (submit_urbs(sk, inurb, outurb) < 0)\n\t\treturn;\n\n\tif (s->state == usb_stream_sync1 && s->insize_done > 360000) {\n\t\t \n\t\ts->state = usb_stream_ready;\n\t\tsubs_set_complete(sk->inurb, i_capture_idle);\n\t\tsubs_set_complete(sk->outurb, i_playback_idle);\n\t}\n}\n\nstatic void i_capture_start(struct urb *urb)\n{\n\tstruct usb_iso_packet_descriptor *id = urb->iso_frame_desc;\n\tstruct usb_stream_kernel *sk = urb->context;\n\tstruct usb_stream *s = sk->s;\n\tint p;\n\tint empty = 0;\n\n\tif (urb->status) {\n\t\tsnd_printk(KERN_WARNING \"status=%i\\n\", urb->status);\n\t\treturn;\n\t}\n\n\tfor (p = 0; p < urb->number_of_packets; ++p) {\n\t\tint l = id[p].actual_length;\n\n\t\tif (l < s->cfg.frame_size) {\n\t\t\t++empty;\n\t\t\tif (s->state >= usb_stream_sync0) {\n\t\t\t\tsnd_printk(KERN_WARNING \"%i\\n\", l);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ts->inpacket_head++;\n\t\ts->inpacket_head %= s->inpackets;\n\t\ts->inpacket[s->inpacket_head].offset =\n\t\t\tid[p].offset + (urb->transfer_buffer - (void *)s);\n\t\ts->inpacket[s->inpacket_head].length = l;\n\t}\n#ifdef SHOW_EMPTY\n\tif (empty) {\n\t\tprintk(KERN_DEBUG\"%s:%i: %i\", __func__, __LINE__,\n\t\t       urb->iso_frame_desc[0].actual_length);\n\t\tfor (pack = 1; pack < urb->number_of_packets; ++pack) {\n\t\t\tint l = urb->iso_frame_desc[pack].actual_length;\n\n\t\t\tprintk(KERN_CONT \" %i\", l);\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n#endif\n\tif (!empty && s->state < usb_stream_sync1)\n\t\t++s->state;\n\n\tif (balance_capture(sk, urb))\n\t\tstream_start(sk, urb, sk->i_urb);\n}\n\nstatic void i_playback_start(struct urb *urb)\n{\n\tstruct usb_stream_kernel *sk = urb->context;\n\n\tif (balance_playback(sk, urb))\n\t\tstream_start(sk, sk->i_urb, urb);\n}\n\nint usb_stream_start(struct usb_stream_kernel *sk)\n{\n\tstruct usb_stream *s = sk->s;\n\tint frame = 0, iters = 0;\n\tint u, err;\n\tint try = 0;\n\n\tif (s->state != usb_stream_stopped)\n\t\treturn -EAGAIN;\n\n\tsubs_set_complete(sk->inurb, i_capture_start);\n\tsubs_set_complete(sk->outurb, i_playback_start);\n\tmemset(sk->write_page, 0, s->write_size);\ndotry:\n\ts->insize_done = 0;\n\ts->idle_insize = 0;\n\ts->idle_outsize = 0;\n\ts->sync_packet = -1;\n\ts->inpacket_head = -1;\n\tsk->iso_frame_balance = 0;\n\t++try;\n\tfor (u = 0; u < 2; u++) {\n\t\tstruct urb *inurb = sk->inurb[u];\n\t\tstruct urb *outurb = sk->outurb[u];\n\n\t\tplayback_prep_freqn(sk, outurb);\n\t\tinurb->number_of_packets = outurb->number_of_packets;\n\t\tinurb->transfer_buffer_length =\n\t\t\tinurb->number_of_packets *\n\t\t\tinurb->iso_frame_desc[0].length;\n\n\t\tif (u == 0) {\n\t\t\tint now;\n\t\t\tstruct usb_device *dev = inurb->dev;\n\n\t\t\tframe = usb_get_current_frame_number(dev);\n\t\t\tdo {\n\t\t\t\tnow = usb_get_current_frame_number(dev);\n\t\t\t\t++iters;\n\t\t\t} while (now > -1 && now == frame);\n\t\t}\n\t\terr = usb_submit_urb(inurb, GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"usb_submit_urb(sk->inurb[%i]) returned %i\\n\",\n\t\t\t\t   u, err);\n\t\t\treturn err;\n\t\t}\n\t\terr = usb_submit_urb(outurb, GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"usb_submit_urb(sk->outurb[%i]) returned %i\\n\",\n\t\t\t\t   u, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (inurb->start_frame != outurb->start_frame) {\n\t\t\tsnd_printd(KERN_DEBUG\n\t\t\t\t   \"u[%i] start_frames differ in:%u out:%u\\n\",\n\t\t\t\t   u, inurb->start_frame, outurb->start_frame);\n\t\t\tgoto check_retry;\n\t\t}\n\t}\n\tsnd_printdd(KERN_DEBUG \"%i %i\\n\", frame, iters);\n\ttry = 0;\ncheck_retry:\n\tif (try) {\n\t\tusb_stream_stop(sk);\n\t\tif (try < 5) {\n\t\t\tmsleep(1500);\n\t\t\tsnd_printd(KERN_DEBUG \"goto dotry;\\n\");\n\t\t\tgoto dotry;\n\t\t}\n\t\tsnd_printk(KERN_WARNING\n\t\t\t   \"couldn't start all urbs on the same start_frame.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tsk->idle_inurb = sk->inurb[USB_STREAM_NURBS - 2];\n\tsk->idle_outurb = sk->outurb[USB_STREAM_NURBS - 2];\n\tsk->completed_inurb = sk->inurb[USB_STREAM_NURBS - 1];\n\tsk->completed_outurb = sk->outurb[USB_STREAM_NURBS - 1];\n\n \n\t{\n\t\tint wait_ms = 3000;\n\n\t\twhile (s->state != usb_stream_ready && wait_ms > 0) {\n\t\t\tsnd_printdd(KERN_DEBUG \"%i\\n\", s->state);\n\t\t\tmsleep(200);\n\t\t\twait_ms -= 200;\n\t\t}\n\t}\n\n\treturn s->state == usb_stream_ready ? 0 : -EFAULT;\n}\n\n\n \n\nvoid usb_stream_stop(struct usb_stream_kernel *sk)\n{\n\tint u;\n\n\tif (!sk->s)\n\t\treturn;\n\tfor (u = 0; u < USB_STREAM_NURBS; ++u) {\n\t\tusb_kill_urb(sk->inurb[u]);\n\t\tusb_kill_urb(sk->outurb[u]);\n\t}\n\tsk->s->state = usb_stream_stopped;\n\tmsleep(400);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}