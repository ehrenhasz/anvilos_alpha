{
  "module_name": "usx2yhwdeppcm.c",
  "hash_id": "e47c936c1a3f4699ede624b6e3ceec0d36b9d0985404fea341270dec0920498f",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/usx2yhwdeppcm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include \"usbusx2yaudio.c\"\n\n#if defined(USX2Y_NRPACKS_VARIABLE) || USX2Y_NRPACKS == 1\n\n#include <sound/hwdep.h>\n\nstatic int usx2y_usbpcm_urb_capt_retire(struct snd_usx2y_substream *subs)\n{\n\tstruct urb\t*urb = subs->completed_urb;\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\tint\t\ti, lens = 0, hwptr_done = subs->hwptr_done;\n\tstruct usx2ydev\t*usx2y = subs->usx2y;\n\tint head;\n\n\tif (usx2y->hwdep_pcm_shm->capture_iso_start < 0) { \n\t\thead = usx2y->hwdep_pcm_shm->captured_iso_head + 1;\n\t\tif (head >= ARRAY_SIZE(usx2y->hwdep_pcm_shm->captured_iso))\n\t\t\thead = 0;\n\t\tusx2y->hwdep_pcm_shm->capture_iso_start = head;\n\t\tsnd_printdd(\"cap start %i\\n\", head);\n\t}\n\tfor (i = 0; i < nr_of_packs(); i++) {\n\t\tif (urb->iso_frame_desc[i].status) {  \n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"active frame status %i. Most probably some hardware problem.\\n\",\n\t\t\t\t   urb->iso_frame_desc[i].status);\n\t\t\treturn urb->iso_frame_desc[i].status;\n\t\t}\n\t\tlens += urb->iso_frame_desc[i].actual_length / usx2y->stride;\n\t}\n\thwptr_done += lens;\n\tif (hwptr_done >= runtime->buffer_size)\n\t\thwptr_done -= runtime->buffer_size;\n\tsubs->hwptr_done = hwptr_done;\n\tsubs->transfer_done += lens;\n\t \n\tif (subs->transfer_done >= runtime->period_size) {\n\t\tsubs->transfer_done -= runtime->period_size;\n\t\tsnd_pcm_period_elapsed(subs->pcm_substream);\n\t}\n\treturn 0;\n}\n\nstatic int usx2y_iso_frames_per_buffer(struct snd_pcm_runtime *runtime,\n\t\t\t\t\t      struct usx2ydev *usx2y)\n{\n\treturn (runtime->buffer_size * 1000) / usx2y->rate + 1;\t\n}\n\n \nstatic int usx2y_hwdep_urb_play_prepare(struct snd_usx2y_substream *subs,\n\t\t\t\t\tstruct urb *urb)\n{\n\tint count, counts, pack;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_hwdep_pcm_shm *shm = usx2y->hwdep_pcm_shm;\n\tstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\n\n\tif (shm->playback_iso_start < 0) {\n\t\tshm->playback_iso_start = shm->captured_iso_head -\n\t\t\tusx2y_iso_frames_per_buffer(runtime, usx2y);\n\t\tif (shm->playback_iso_start < 0)\n\t\t\tshm->playback_iso_start += ARRAY_SIZE(shm->captured_iso);\n\t\tshm->playback_iso_head = shm->playback_iso_start;\n\t}\n\n\tcount = 0;\n\tfor (pack = 0; pack < nr_of_packs(); pack++) {\n\t\t \n\t\tcounts = shm->captured_iso[shm->playback_iso_head].length / usx2y->stride;\n\t\tif (counts < 43 || counts > 50) {\n\t\t\tsnd_printk(KERN_ERR \"should not be here with counts=%i\\n\", counts);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\t \n\t\turb->iso_frame_desc[pack].offset = shm->captured_iso[shm->playback_iso_head].offset;\n\t\turb->iso_frame_desc[pack].length = shm->captured_iso[shm->playback_iso_head].length;\n\t\tif (atomic_read(&subs->state) != STATE_RUNNING)\n\t\t\tmemset((char *)urb->transfer_buffer + urb->iso_frame_desc[pack].offset, 0,\n\t\t\t       urb->iso_frame_desc[pack].length);\n\t\tif (++shm->playback_iso_head >= ARRAY_SIZE(shm->captured_iso))\n\t\t\tshm->playback_iso_head = 0;\n\t\tcount += counts;\n\t}\n\turb->transfer_buffer_length = count * usx2y->stride;\n\treturn 0;\n}\n\nstatic void usx2y_usbpcm_urb_capt_iso_advance(struct snd_usx2y_substream *subs,\n\t\t\t\t\t      struct urb *urb)\n{\n\tstruct usb_iso_packet_descriptor *desc;\n\tstruct snd_usx2y_hwdep_pcm_shm *shm;\n\tint pack, head;\n\n\tfor (pack = 0; pack < nr_of_packs(); ++pack) {\n\t\tdesc = urb->iso_frame_desc + pack;\n\t\tif (subs) {\n\t\t\tshm = subs->usx2y->hwdep_pcm_shm;\n\t\t\thead = shm->captured_iso_head + 1;\n\t\t\tif (head >= ARRAY_SIZE(shm->captured_iso))\n\t\t\t\thead = 0;\n\t\t\tshm->captured_iso[head].frame = urb->start_frame + pack;\n\t\t\tshm->captured_iso[head].offset = desc->offset;\n\t\t\tshm->captured_iso[head].length = desc->actual_length;\n\t\t\tshm->captured_iso_head = head;\n\t\t\tshm->captured_iso_frames++;\n\t\t}\n\t\tdesc->offset += desc->length * NRURBS * nr_of_packs();\n\t\tif (desc->offset + desc->length >= SSS)\n\t\t\tdesc->offset -= (SSS - desc->length);\n\t}\n}\n\nstatic int usx2y_usbpcm_usbframe_complete(struct snd_usx2y_substream *capsubs,\n\t\t\t\t\t  struct snd_usx2y_substream *capsubs2,\n\t\t\t\t\t  struct snd_usx2y_substream *playbacksubs,\n\t\t\t\t\t  int frame)\n{\n\tint err, state;\n\tstruct urb *urb = playbacksubs->completed_urb;\n\n\tstate = atomic_read(&playbacksubs->state);\n\tif (urb) {\n\t\tif (state == STATE_RUNNING)\n\t\t\tusx2y_urb_play_retire(playbacksubs, urb);\n\t\telse if (state >= STATE_PRERUNNING)\n\t\t\tatomic_inc(&playbacksubs->state);\n\t} else {\n\t\tswitch (state) {\n\t\tcase STATE_STARTING1:\n\t\t\turb = playbacksubs->urb[0];\n\t\t\tatomic_inc(&playbacksubs->state);\n\t\t\tbreak;\n\t\tcase STATE_STARTING2:\n\t\t\turb = playbacksubs->urb[1];\n\t\t\tatomic_inc(&playbacksubs->state);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (urb) {\n\t\terr = usx2y_hwdep_urb_play_prepare(playbacksubs, urb);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = usx2y_hwdep_urb_play_prepare(playbacksubs, urb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tplaybacksubs->completed_urb = NULL;\n\n\tstate = atomic_read(&capsubs->state);\n\tif (state >= STATE_PREPARED) {\n\t\tif (state == STATE_RUNNING) {\n\t\t\terr = usx2y_usbpcm_urb_capt_retire(capsubs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (state >= STATE_PRERUNNING) {\n\t\t\tatomic_inc(&capsubs->state);\n\t\t}\n\t\tusx2y_usbpcm_urb_capt_iso_advance(capsubs, capsubs->completed_urb);\n\t\tif (capsubs2)\n\t\t\tusx2y_usbpcm_urb_capt_iso_advance(NULL, capsubs2->completed_urb);\n\t\terr = usx2y_urb_submit(capsubs, capsubs->completed_urb, frame);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (capsubs2) {\n\t\t\terr = usx2y_urb_submit(capsubs2, capsubs2->completed_urb, frame);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tcapsubs->completed_urb = NULL;\n\tif (capsubs2)\n\t\tcapsubs2->completed_urb = NULL;\n\treturn 0;\n}\n\nstatic void i_usx2y_usbpcm_urb_complete(struct urb *urb)\n{\n\tstruct snd_usx2y_substream *subs = urb->context;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *capsubs, *capsubs2, *playbacksubs;\n\n\tif (unlikely(atomic_read(&subs->state) < STATE_PREPARED)) {\n\t\tsnd_printdd(\"hcd_frame=%i ep=%i%s status=%i start_frame=%i\\n\",\n\t\t\t    usb_get_current_frame_number(usx2y->dev),\n\t\t\t    subs->endpoint, usb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\t    urb->status, urb->start_frame);\n\t\treturn;\n\t}\n\tif (unlikely(urb->status)) {\n\t\tusx2y_error_urb_status(usx2y, subs, urb);\n\t\treturn;\n\t}\n\n\tsubs->completed_urb = urb;\n\tcapsubs = usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\tcapsubs2 = usx2y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\n\tplaybacksubs = usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (capsubs->completed_urb && atomic_read(&capsubs->state) >= STATE_PREPARED &&\n\t    (!capsubs2 || capsubs2->completed_urb) &&\n\t    (playbacksubs->completed_urb || atomic_read(&playbacksubs->state) < STATE_PREPARED)) {\n\t\tif (!usx2y_usbpcm_usbframe_complete(capsubs, capsubs2, playbacksubs, urb->start_frame)) {\n\t\t\tusx2y->wait_iso_frame += nr_of_packs();\n\t\t} else {\n\t\t\tsnd_printdd(\"\\n\");\n\t\t\tusx2y_clients_stop(usx2y);\n\t\t}\n\t}\n}\n\nstatic void usx2y_hwdep_urb_release(struct urb **urb)\n{\n\tusb_kill_urb(*urb);\n\tusb_free_urb(*urb);\n\t*urb = NULL;\n}\n\n \nstatic void usx2y_usbpcm_urbs_release(struct snd_usx2y_substream *subs)\n{\n\tint i;\n\n\tsnd_printdd(\"snd_usx2y_urbs_release() %i\\n\", subs->endpoint);\n\tfor (i = 0; i < NRURBS; i++)\n\t\tusx2y_hwdep_urb_release(subs->urb + i);\n}\n\nstatic void usx2y_usbpcm_subs_startup_finish(struct usx2ydev *usx2y)\n{\n\tusx2y_urbs_set_complete(usx2y, i_usx2y_usbpcm_urb_complete);\n\tusx2y->prepare_subs = NULL;\n}\n\nstatic void i_usx2y_usbpcm_subs_startup(struct urb *urb)\n{\n\tstruct snd_usx2y_substream *subs = urb->context;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *prepare_subs = usx2y->prepare_subs;\n\tstruct snd_usx2y_substream *cap_subs2;\n\n\tif (prepare_subs &&\n\t    urb->start_frame == prepare_subs->urb[0]->start_frame) {\n\t\tatomic_inc(&prepare_subs->state);\n\t\tif (prepare_subs == usx2y->subs[SNDRV_PCM_STREAM_CAPTURE]) {\n\t\t\tcap_subs2 = usx2y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\n\t\t\tif (cap_subs2)\n\t\t\t\tatomic_inc(&cap_subs2->state);\n\t\t}\n\t\tusx2y_usbpcm_subs_startup_finish(usx2y);\n\t\twake_up(&usx2y->prepare_wait_queue);\n\t}\n\n\ti_usx2y_usbpcm_urb_complete(urb);\n}\n\n \nstatic int usx2y_usbpcm_urbs_allocate(struct snd_usx2y_substream *subs)\n{\n\tint i;\n\tunsigned int pipe;\n\tint is_playback = subs == subs->usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\tstruct usb_device *dev = subs->usx2y->dev;\n\tstruct urb **purb;\n\n\tpipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :\n\t\t\tusb_rcvisocpipe(dev, subs->endpoint);\n\tsubs->maxpacksize = usb_maxpacket(dev, pipe);\n\tif (!subs->maxpacksize)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < NRURBS; i++) {\n\t\tpurb = subs->urb + i;\n\t\tif (*purb) {\n\t\t\tusb_kill_urb(*purb);\n\t\t\tcontinue;\n\t\t}\n\t\t*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);\n\t\tif (!*purb) {\n\t\t\tusx2y_usbpcm_urbs_release(subs);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t(*purb)->transfer_buffer = is_playback ?\n\t\t\tsubs->usx2y->hwdep_pcm_shm->playback : (\n\t\t\t\tsubs->endpoint == 0x8 ?\n\t\t\t\tsubs->usx2y->hwdep_pcm_shm->capture0x8 :\n\t\t\t\tsubs->usx2y->hwdep_pcm_shm->capture0xA);\n\n\t\t(*purb)->dev = dev;\n\t\t(*purb)->pipe = pipe;\n\t\t(*purb)->number_of_packets = nr_of_packs();\n\t\t(*purb)->context = subs;\n\t\t(*purb)->interval = 1;\n\t\t(*purb)->complete = i_usx2y_usbpcm_subs_startup;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_usx2y_usbpcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\tstruct snd_usx2y_substream *cap_subs;\n\tstruct snd_usx2y_substream *playback_subs;\n\tstruct snd_usx2y_substream *cap_subs2;\n\n\tmutex_lock(&subs->usx2y->pcm_mutex);\n\tsnd_printdd(\"%s(%p)\\n\", __func__, substream);\n\n\tcap_subs2 = subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tcap_subs = subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\t\tatomic_set(&subs->state, STATE_STOPPED);\n\t\tusx2y_usbpcm_urbs_release(subs);\n\t\tif (!cap_subs->pcm_substream ||\n\t\t    !cap_subs->pcm_substream->runtime ||\n\t\t    cap_subs->pcm_substream->runtime->state < SNDRV_PCM_STATE_PREPARED) {\n\t\t\tatomic_set(&cap_subs->state, STATE_STOPPED);\n\t\t\tif (cap_subs2)\n\t\t\t\tatomic_set(&cap_subs2->state, STATE_STOPPED);\n\t\t\tusx2y_usbpcm_urbs_release(cap_subs);\n\t\t\tif (cap_subs2)\n\t\t\t\tusx2y_usbpcm_urbs_release(cap_subs2);\n\t\t}\n\t} else {\n\t\tplayback_subs = subs->usx2y->subs[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tif (atomic_read(&playback_subs->state) < STATE_PREPARED) {\n\t\t\tatomic_set(&subs->state, STATE_STOPPED);\n\t\t\tif (cap_subs2)\n\t\t\t\tatomic_set(&cap_subs2->state, STATE_STOPPED);\n\t\t\tusx2y_usbpcm_urbs_release(subs);\n\t\t\tif (cap_subs2)\n\t\t\t\tusx2y_usbpcm_urbs_release(cap_subs2);\n\t\t}\n\t}\n\tmutex_unlock(&subs->usx2y->pcm_mutex);\n\treturn 0;\n}\n\nstatic void usx2y_usbpcm_subs_startup(struct snd_usx2y_substream *subs)\n{\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\n\tusx2y->prepare_subs = subs;\n\tsubs->urb[0]->start_frame = -1;\n\tsmp_wmb();\t\n\tusx2y_urbs_set_complete(usx2y, i_usx2y_usbpcm_subs_startup);\n}\n\nstatic int usx2y_usbpcm_urbs_start(struct snd_usx2y_substream *subs)\n{\n\tint\tp, u, err, stream = subs->pcm_substream->stream;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct urb *urb;\n\tunsigned long pack;\n\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tusx2y->hwdep_pcm_shm->captured_iso_head = -1;\n\t\tusx2y->hwdep_pcm_shm->captured_iso_frames = 0;\n\t}\n\n\tfor (p = 0; 3 >= (stream + p); p += 2) {\n\t\tstruct snd_usx2y_substream *subs = usx2y->subs[stream + p];\n\t\tif (subs) {\n\t\t\terr = usx2y_usbpcm_urbs_allocate(subs);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tsubs->completed_urb = NULL;\n\t\t}\n\t}\n\n\tfor (p = 0; p < 4; p++) {\n\t\tstruct snd_usx2y_substream *subs = usx2y->subs[p];\n\n\t\tif (subs && atomic_read(&subs->state) >= STATE_PREPARED)\n\t\t\tgoto start;\n\t}\n\n start:\n\tusx2y_usbpcm_subs_startup(subs);\n\tfor (u = 0; u < NRURBS; u++) {\n\t\tfor (p = 0; 3 >= (stream + p); p += 2) {\n\t\t\tstruct snd_usx2y_substream *subs = usx2y->subs[stream + p];\n\n\t\t\tif (!subs)\n\t\t\t\tcontinue;\n\t\t\turb = subs->urb[u];\n\t\t\tif (usb_pipein(urb->pipe)) {\n\t\t\t\tif (!u)\n\t\t\t\t\tatomic_set(&subs->state, STATE_STARTING3);\n\t\t\t\turb->dev = usx2y->dev;\n\t\t\t\tfor (pack = 0; pack < nr_of_packs(); pack++) {\n\t\t\t\t\turb->iso_frame_desc[pack].offset = subs->maxpacksize * (pack + u * nr_of_packs());\n\t\t\t\t\turb->iso_frame_desc[pack].length = subs->maxpacksize;\n\t\t\t\t}\n\t\t\t\turb->transfer_buffer_length = subs->maxpacksize * nr_of_packs();\n\t\t\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tsnd_printk(KERN_ERR \"cannot usb_submit_urb() for urb %d, err = %d\\n\", u, err);\n\t\t\t\t\terr = -EPIPE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}  else {\n\t\t\t\t\tsnd_printdd(\"%i\\n\", urb->start_frame);\n\t\t\t\t\tif (!u)\n\t\t\t\t\t\tusx2y->wait_iso_frame = urb->start_frame;\n\t\t\t\t}\n\t\t\t\turb->transfer_flags = 0;\n\t\t\t} else {\n\t\t\t\tatomic_set(&subs->state, STATE_STARTING1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\terr = 0;\n\twait_event(usx2y->prepare_wait_queue, !usx2y->prepare_subs);\n\tif (atomic_read(&subs->state) != STATE_PREPARED)\n\t\terr = -EPIPE;\n\n cleanup:\n\tif (err) {\n\t\tusx2y_subs_startup_finish(usx2y);\t\n\t\tusx2y_clients_stop(usx2y);\t\n\t}\n\treturn err;\n}\n\n#define USX2Y_HWDEP_PCM_PAGES\t\\\n\tPAGE_ALIGN(sizeof(struct snd_usx2y_hwdep_pcm_shm))\n\n \nstatic int snd_usx2y_usbpcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\tstruct usx2ydev *usx2y = subs->usx2y;\n\tstruct snd_usx2y_substream *capsubs = subs->usx2y->subs[SNDRV_PCM_STREAM_CAPTURE];\n\tint err = 0;\n\n\tsnd_printdd(\"snd_usx2y_pcm_prepare(%p)\\n\", substream);\n\n\tmutex_lock(&usx2y->pcm_mutex);\n\n\tif (!usx2y->hwdep_pcm_shm) {\n\t\tusx2y->hwdep_pcm_shm = alloc_pages_exact(USX2Y_HWDEP_PCM_PAGES,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!usx2y->hwdep_pcm_shm) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tmemset(usx2y->hwdep_pcm_shm, 0, USX2Y_HWDEP_PCM_PAGES);\n\t}\n\n\tusx2y_subs_prepare(subs);\n\t\n\t\n\tif (atomic_read(&capsubs->state) < STATE_PREPARED) {\n\t\tif (usx2y->format != runtime->format) {\n\t\t\terr = usx2y_format_set(usx2y, runtime->format);\n\t\t\tif (err < 0)\n\t\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tif (usx2y->rate != runtime->rate) {\n\t\t\terr = usx2y_rate_set(usx2y, runtime->rate);\n\t\t\tif (err < 0)\n\t\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tsnd_printdd(\"starting capture pipe for %s\\n\", subs == capsubs ?\n\t\t\t    \"self\" : \"playpipe\");\n\t\terr = usx2y_usbpcm_urbs_start(capsubs);\n\t\tif (err < 0)\n\t\t\tgoto up_prepare_mutex;\n\t}\n\n\tif (subs != capsubs) {\n\t\tusx2y->hwdep_pcm_shm->playback_iso_start = -1;\n\t\tif (atomic_read(&subs->state) < STATE_PREPARED) {\n\t\t\twhile (usx2y_iso_frames_per_buffer(runtime, usx2y) >\n\t\t\t       usx2y->hwdep_pcm_shm->captured_iso_frames) {\n\t\t\t\tsnd_printdd(\"Wait: iso_frames_per_buffer=%i,captured_iso_frames=%i\\n\",\n\t\t\t\t\t    usx2y_iso_frames_per_buffer(runtime, usx2y),\n\t\t\t\t\t    usx2y->hwdep_pcm_shm->captured_iso_frames);\n\t\t\t\tif (msleep_interruptible(10)) {\n\t\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\t\tgoto up_prepare_mutex;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = usx2y_usbpcm_urbs_start(subs);\n\t\t\tif (err < 0)\n\t\t\t\tgoto up_prepare_mutex;\n\t\t}\n\t\tsnd_printdd(\"Ready: iso_frames_per_buffer=%i,captured_iso_frames=%i\\n\",\n\t\t\t    usx2y_iso_frames_per_buffer(runtime, usx2y),\n\t\t\t    usx2y->hwdep_pcm_shm->captured_iso_frames);\n\t} else {\n\t\tusx2y->hwdep_pcm_shm->capture_iso_start = -1;\n\t}\n\n up_prepare_mutex:\n\tmutex_unlock(&usx2y->pcm_mutex);\n\treturn err;\n}\n\nstatic const struct snd_pcm_hardware snd_usx2y_4c = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =                 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,\n\t.rates =                   SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min =                44100,\n\t.rate_max =                48000,\n\t.channels_min =            2,\n\t.channels_max =            4,\n\t.buffer_bytes_max =\t(2*128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =              0\n};\n\nstatic int snd_usx2y_usbpcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_usx2y_substream\t*subs =\n\t\t((struct snd_usx2y_substream **)\n\t\t snd_pcm_substream_chip(substream))[substream->stream];\n\tstruct snd_pcm_runtime\t*runtime = substream->runtime;\n\n\tif (!(subs->usx2y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS))\n\t\treturn -EBUSY;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = snd_usx2y_2c;\n\telse\n\t\truntime->hw = (subs->usx2y->subs[3] ? snd_usx2y_4c : snd_usx2y_2c);\n\truntime->private_data = subs;\n\tsubs->pcm_substream = substream;\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 1000, 200000);\n\treturn 0;\n}\n\nstatic int snd_usx2y_usbpcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_usx2y_substream *subs = runtime->private_data;\n\n\tsubs->pcm_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_usx2y_usbpcm_ops = {\n\t.open =\t\tsnd_usx2y_usbpcm_open,\n\t.close =\tsnd_usx2y_usbpcm_close,\n\t.hw_params =\tsnd_usx2y_pcm_hw_params,\n\t.hw_free =\tsnd_usx2y_usbpcm_hw_free,\n\t.prepare =\tsnd_usx2y_usbpcm_prepare,\n\t.trigger =\tsnd_usx2y_pcm_trigger,\n\t.pointer =\tsnd_usx2y_pcm_pointer,\n};\n\nstatic int usx2y_pcms_busy_check(struct snd_card *card)\n{\n\tstruct usx2ydev\t*dev = usx2y(card);\n\tstruct snd_usx2y_substream *subs;\n\tint i;\n\n\tfor (i = 0; i < dev->pcm_devs * 2; i++) {\n\t\tsubs = dev->subs[i];\n\t\tif (subs && subs->pcm_substream &&\n\t\t    SUBSTREAM_BUSY(subs->pcm_substream))\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int snd_usx2y_hwdep_pcm_open(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct snd_card *card = hw->card;\n\tint err;\n\n\tmutex_lock(&usx2y(card)->pcm_mutex);\n\terr = usx2y_pcms_busy_check(card);\n\tif (!err)\n\t\tusx2y(card)->chip_status |= USX2Y_STAT_CHIP_MMAP_PCM_URBS;\n\tmutex_unlock(&usx2y(card)->pcm_mutex);\n\treturn err;\n}\n\nstatic int snd_usx2y_hwdep_pcm_release(struct snd_hwdep *hw, struct file *file)\n{\n\tstruct snd_card *card = hw->card;\n\tint err;\n\n\tmutex_lock(&usx2y(card)->pcm_mutex);\n\terr = usx2y_pcms_busy_check(card);\n\tif (!err)\n\t\tusx2y(hw->card)->chip_status &= ~USX2Y_STAT_CHIP_MMAP_PCM_URBS;\n\tmutex_unlock(&usx2y(card)->pcm_mutex);\n\treturn err;\n}\n\nstatic void snd_usx2y_hwdep_pcm_vm_open(struct vm_area_struct *area)\n{\n}\n\nstatic void snd_usx2y_hwdep_pcm_vm_close(struct vm_area_struct *area)\n{\n}\n\nstatic vm_fault_t snd_usx2y_hwdep_pcm_vm_fault(struct vm_fault *vmf)\n{\n\tunsigned long offset;\n\tvoid *vaddr;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tvaddr = (char *)((struct usx2ydev *)vmf->vma->vm_private_data)->hwdep_pcm_shm + offset;\n\tvmf->page = virt_to_page(vaddr);\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct snd_usx2y_hwdep_pcm_vm_ops = {\n\t.open = snd_usx2y_hwdep_pcm_vm_open,\n\t.close = snd_usx2y_hwdep_pcm_vm_close,\n\t.fault = snd_usx2y_hwdep_pcm_vm_fault,\n};\n\nstatic int snd_usx2y_hwdep_pcm_mmap(struct snd_hwdep *hw, struct file *filp, struct vm_area_struct *area)\n{\n\tunsigned long\tsize = (unsigned long)(area->vm_end - area->vm_start);\n\tstruct usx2ydev\t*usx2y = hw->private_data;\n\n\tif (!(usx2y->chip_status & USX2Y_STAT_CHIP_INIT))\n\t\treturn -EBUSY;\n\n\t \n\tif (size > USX2Y_HWDEP_PCM_PAGES) {\n\t\tsnd_printd(\"%lu > %lu\\n\", size, (unsigned long)USX2Y_HWDEP_PCM_PAGES);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!usx2y->hwdep_pcm_shm)\n\t\treturn -ENODEV;\n\n\tarea->vm_ops = &snd_usx2y_hwdep_pcm_vm_ops;\n\tvm_flags_set(area, VM_DONTEXPAND | VM_DONTDUMP);\n\tarea->vm_private_data = hw->private_data;\n\treturn 0;\n}\n\nstatic void snd_usx2y_hwdep_pcm_private_free(struct snd_hwdep *hwdep)\n{\n\tstruct usx2ydev *usx2y = hwdep->private_data;\n\n\tif (usx2y->hwdep_pcm_shm)\n\t\tfree_pages_exact(usx2y->hwdep_pcm_shm, USX2Y_HWDEP_PCM_PAGES);\n}\n\nint usx2y_hwdep_pcm_new(struct snd_card *card)\n{\n\tint err;\n\tstruct snd_hwdep *hw;\n\tstruct snd_pcm *pcm;\n\tstruct usb_device *dev = usx2y(card)->dev;\n\n\tif (nr_of_packs() != 1)\n\t\treturn 0;\n\n\terr = snd_hwdep_new(card, SND_USX2Y_USBPCM_ID, 1, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thw->iface = SNDRV_HWDEP_IFACE_USX2Y_PCM;\n\thw->private_data = usx2y(card);\n\thw->private_free = snd_usx2y_hwdep_pcm_private_free;\n\thw->ops.open = snd_usx2y_hwdep_pcm_open;\n\thw->ops.release = snd_usx2y_hwdep_pcm_release;\n\thw->ops.mmap = snd_usx2y_hwdep_pcm_mmap;\n\thw->exclusive = 1;\n\tsprintf(hw->name, \"/dev/bus/usb/%03d/%03d/hwdeppcm\", dev->bus->busnum, dev->devnum);\n\n\terr = snd_pcm_new(card, NAME_ALLCAPS\" hwdep Audio\", 2, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_usx2y_usbpcm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usx2y_usbpcm_ops);\n\n\tpcm->private_data = usx2y(card)->subs;\n\tpcm->info_flags = 0;\n\n\tsprintf(pcm->name, NAME_ALLCAPS\" hwdep Audio\");\n\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t   NULL,\n\t\t\t\t   64*1024, 128*1024);\n\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t   NULL,\n\t\t\t\t   64*1024, 128*1024);\n\n\treturn 0;\n}\n\n#else\n\nint usx2y_hwdep_pcm_new(struct snd_card *card)\n{\n\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}