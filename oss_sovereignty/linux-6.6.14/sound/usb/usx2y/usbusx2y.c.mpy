{
  "module_name": "usbusx2y.c",
  "hash_id": "5bed08ed7842750e83dd70681c781755f0cc9ef070a482b1aa745e62ad23df3a",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/usx2y/usbusx2y.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n\n#include <sound/rawmidi.h>\n#include \"usx2y.h\"\n#include \"usbusx2y.h\"\n#include \"usX2Yhwdep.h\"\n\nMODULE_AUTHOR(\"Karsten Wiese <annabellesgarden@yahoo.de>\");\nMODULE_DESCRIPTION(\"TASCAM \"NAME_ALLCAPS\" Version 0.8.7.2\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;  \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;  \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \"NAME_ALLCAPS\".\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \"NAME_ALLCAPS\".\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \"NAME_ALLCAPS\".\");\n\nstatic int snd_usx2y_card_used[SNDRV_CARDS];\n\nstatic void snd_usx2y_card_private_free(struct snd_card *card);\nstatic void usx2y_unlinkseq(struct snd_usx2y_async_seq *s);\n\n \nstatic void i_usx2y_out04_int(struct urb *urb)\n{\n#ifdef CONFIG_SND_DEBUG\n\tif (urb->status) {\n\t\tint i;\n\t\tstruct usx2ydev *usx2y = urb->context;\n\n\t\tfor (i = 0; i < 10 && usx2y->as04.urb[i] != urb; i++)\n\t\t\t;\n\t\tsnd_printdd(\"%s urb %i status=%i\\n\", __func__, i, urb->status);\n\t}\n#endif\n}\n\nstatic void i_usx2y_in04_int(struct urb *urb)\n{\n\tint\t\t\terr = 0;\n\tstruct usx2ydev\t\t*usx2y = urb->context;\n\tstruct us428ctls_sharedmem\t*us428ctls = usx2y->us428ctls_sharedmem;\n\tstruct us428_p4out *p4out;\n\tint i, j, n, diff, send;\n\n\tusx2y->in04_int_calls++;\n\n\tif (urb->status) {\n\t\tsnd_printdd(\"Interrupt Pipe 4 came back with status=%i\\n\", urb->status);\n\t\treturn;\n\t}\n\n\t\n\tif (us428ctls) {\n\t\tdiff = -1;\n\t\tif (us428ctls->ctl_snapshot_last == -2) {\n\t\t\tdiff = 0;\n\t\t\tmemcpy(usx2y->in04_last, usx2y->in04_buf, sizeof(usx2y->in04_last));\n\t\t\tus428ctls->ctl_snapshot_last = -1;\n\t\t} else {\n\t\t\tfor (i = 0; i < 21; i++) {\n\t\t\t\tif (usx2y->in04_last[i] != ((char *)usx2y->in04_buf)[i]) {\n\t\t\t\t\tif (diff < 0)\n\t\t\t\t\t\tdiff = i;\n\t\t\t\t\tusx2y->in04_last[i] = ((char *)usx2y->in04_buf)[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (diff >= 0) {\n\t\t\tn = us428ctls->ctl_snapshot_last + 1;\n\t\t\tif (n >= N_US428_CTL_BUFS || n < 0)\n\t\t\t\tn = 0;\n\t\t\tmemcpy(us428ctls->ctl_snapshot + n, usx2y->in04_buf, sizeof(us428ctls->ctl_snapshot[0]));\n\t\t\tus428ctls->ctl_snapshot_differs_at[n] = diff;\n\t\t\tus428ctls->ctl_snapshot_last = n;\n\t\t\twake_up(&usx2y->us428ctls_wait_queue_head);\n\t\t}\n\t}\n\n\tif (usx2y->us04) {\n\t\tif (!usx2y->us04->submitted) {\n\t\t\tdo {\n\t\t\t\terr = usb_submit_urb(usx2y->us04->urb[usx2y->us04->submitted++], GFP_ATOMIC);\n\t\t\t} while (!err && usx2y->us04->submitted < usx2y->us04->len);\n\t\t}\n\t} else {\n\t\tif (us428ctls && us428ctls->p4out_last >= 0 && us428ctls->p4out_last < N_US428_P4OUT_BUFS) {\n\t\t\tif (us428ctls->p4out_last != us428ctls->p4out_sent) {\n\t\t\t\tsend = us428ctls->p4out_sent + 1;\n\t\t\t\tif (send >= N_US428_P4OUT_BUFS)\n\t\t\t\t\tsend = 0;\n\t\t\t\tfor (j = 0; j < URBS_ASYNC_SEQ && !err; ++j) {\n\t\t\t\t\tif (!usx2y->as04.urb[j]->status) {\n\t\t\t\t\t\tp4out = us428ctls->p4out + send;\t\n\t\t\t\t\t\tusb_fill_bulk_urb(usx2y->as04.urb[j], usx2y->dev,\n\t\t\t\t\t\t\t\t  usb_sndbulkpipe(usx2y->dev, 0x04), &p4out->val.vol,\n\t\t\t\t\t\t\t\t  p4out->type == ELT_LIGHT ? sizeof(struct us428_lights) : 5,\n\t\t\t\t\t\t\t\t  i_usx2y_out04_int, usx2y);\n\t\t\t\t\t\terr = usb_submit_urb(usx2y->as04.urb[j], GFP_ATOMIC);\n\t\t\t\t\t\tus428ctls->p4out_sent = send;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err)\n\t\tsnd_printk(KERN_ERR \"in04_int() usb_submit_urb err=%i\\n\", err);\n\n\turb->dev = usx2y->dev;\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\n \nint usx2y_async_seq04_init(struct usx2ydev *usx2y)\n{\n\tint\terr = 0, i;\n\n\tif (WARN_ON(usx2y->as04.buffer))\n\t\treturn -EBUSY;\n\n\tusx2y->as04.buffer = kmalloc_array(URBS_ASYNC_SEQ,\n\t\t\t\t\t   URB_DATA_LEN_ASYNC_SEQ, GFP_KERNEL);\n\tif (!usx2y->as04.buffer) {\n\t\terr = -ENOMEM;\n\t} else {\n\t\tfor (i = 0; i < URBS_ASYNC_SEQ; ++i) {\n\t\t\tusx2y->as04.urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!usx2y->as04.urb[i]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusb_fill_bulk_urb(usx2y->as04.urb[i], usx2y->dev,\n\t\t\t\t\t  usb_sndbulkpipe(usx2y->dev, 0x04),\n\t\t\t\t\t  usx2y->as04.buffer + URB_DATA_LEN_ASYNC_SEQ * i, 0,\n\t\t\t\t\t  i_usx2y_out04_int, usx2y);\n\t\t\terr = usb_urb_ep_type_check(usx2y->as04.urb[i]);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (err)\n\t\tusx2y_unlinkseq(&usx2y->as04);\n\treturn err;\n}\n\nint usx2y_in04_init(struct usx2ydev *usx2y)\n{\n\tint err;\n\n\tif (WARN_ON(usx2y->in04_urb))\n\t\treturn -EBUSY;\n\n\tusx2y->in04_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usx2y->in04_urb) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tusx2y->in04_buf = kmalloc(21, GFP_KERNEL);\n\tif (!usx2y->in04_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_waitqueue_head(&usx2y->in04_wait_queue);\n\tusb_fill_int_urb(usx2y->in04_urb, usx2y->dev, usb_rcvintpipe(usx2y->dev, 0x4),\n\t\t\t usx2y->in04_buf, 21,\n\t\t\t i_usx2y_in04_int, usx2y,\n\t\t\t 10);\n\tif (usb_urb_ep_type_check(usx2y->in04_urb)) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\treturn usb_submit_urb(usx2y->in04_urb, GFP_KERNEL);\n\n error:\n\tkfree(usx2y->in04_buf);\n\tusb_free_urb(usx2y->in04_urb);\n\tusx2y->in04_buf = NULL;\n\tusx2y->in04_urb = NULL;\n\treturn err;\n}\n\nstatic void usx2y_unlinkseq(struct snd_usx2y_async_seq *s)\n{\n\tint\ti;\n\n\tfor (i = 0; i < URBS_ASYNC_SEQ; ++i) {\n\t\tif (!s->urb[i])\n\t\t\tcontinue;\n\t\tusb_kill_urb(s->urb[i]);\n\t\tusb_free_urb(s->urb[i]);\n\t\ts->urb[i] = NULL;\n\t}\n\tkfree(s->buffer);\n\ts->buffer = NULL;\n}\n\nstatic const struct usb_device_id snd_usx2y_usb_id_table[] = {\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x1604,\n\t\t.idProduct =\tUSB_ID_US428\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x1604,\n\t\t.idProduct =\tUSB_ID_US122\n\t},\n\t{\n\t\t.match_flags =\tUSB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor =\t0x1604,\n\t\t.idProduct =\tUSB_ID_US224\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(usb, snd_usx2y_usb_id_table);\n\nstatic int usx2y_create_card(struct usb_device *device,\n\t\t\t     struct usb_interface *intf,\n\t\t\t     struct snd_card **cardp)\n{\n\tint\t\tdev;\n\tstruct snd_card *card;\n\tint err;\n\n\tfor (dev = 0; dev < SNDRV_CARDS; ++dev)\n\t\tif (enable[dev] && !snd_usx2y_card_used[dev])\n\t\t\tbreak;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\terr = snd_card_new(&intf->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct usx2ydev), &card);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_usx2y_card_used[usx2y(card)->card_index = dev] = 1;\n\tcard->private_free = snd_usx2y_card_private_free;\n\tusx2y(card)->dev = device;\n\tinit_waitqueue_head(&usx2y(card)->prepare_wait_queue);\n\tinit_waitqueue_head(&usx2y(card)->us428ctls_wait_queue_head);\n\tmutex_init(&usx2y(card)->pcm_mutex);\n\tINIT_LIST_HEAD(&usx2y(card)->midi_list);\n\tstrcpy(card->driver, \"USB \"NAME_ALLCAPS\"\");\n\tsprintf(card->shortname, \"TASCAM \"NAME_ALLCAPS\"\");\n\tsprintf(card->longname, \"%s (%x:%x if %d at %03d/%03d)\",\n\t\tcard->shortname,\n\t\tle16_to_cpu(device->descriptor.idVendor),\n\t\tle16_to_cpu(device->descriptor.idProduct),\n\t\t0,\n\t\tusx2y(card)->dev->bus->busnum, usx2y(card)->dev->devnum);\n\t*cardp = card;\n\treturn 0;\n}\n\nstatic void snd_usx2y_card_private_free(struct snd_card *card)\n{\n\tstruct usx2ydev *usx2y = usx2y(card);\n\n\tkfree(usx2y->in04_buf);\n\tusb_free_urb(usx2y->in04_urb);\n\tif (usx2y->us428ctls_sharedmem)\n\t\tfree_pages_exact(usx2y->us428ctls_sharedmem,\n\t\t\t\t US428_SHAREDMEM_PAGES);\n\tif (usx2y->card_index >= 0 && usx2y->card_index < SNDRV_CARDS)\n\t\tsnd_usx2y_card_used[usx2y->card_index] = 0;\n}\n\nstatic void snd_usx2y_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_card *card;\n\tstruct usx2ydev *usx2y;\n\tstruct list_head *p;\n\n\tcard = usb_get_intfdata(intf);\n\tif (!card)\n\t\treturn;\n\tusx2y = usx2y(card);\n\tusx2y->chip_status = USX2Y_STAT_CHIP_HUP;\n\tusx2y_unlinkseq(&usx2y->as04);\n\tusb_kill_urb(usx2y->in04_urb);\n\tsnd_card_disconnect(card);\n\n\t \n\tlist_for_each(p, &usx2y->midi_list) {\n\t\tsnd_usbmidi_disconnect(p);\n\t}\n\tif (usx2y->us428ctls_sharedmem)\n\t\twake_up(&usx2y->us428ctls_wait_queue_head);\n\tsnd_card_free(card);\n}\n\nstatic int snd_usx2y_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tstruct snd_card *card;\n\tint err;\n\n\tif (le16_to_cpu(device->descriptor.idVendor) != 0x1604 ||\n\t    (le16_to_cpu(device->descriptor.idProduct) != USB_ID_US122 &&\n\t     le16_to_cpu(device->descriptor.idProduct) != USB_ID_US224 &&\n\t     le16_to_cpu(device->descriptor.idProduct) != USB_ID_US428))\n\t\treturn -EINVAL;\n\n\terr = usx2y_create_card(device, intf, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = usx2y_hwdep_new(card, device);\n\tif (err < 0)\n\t\tgoto error;\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdev_set_drvdata(&intf->dev, card);\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct usb_driver snd_usx2y_usb_driver = {\n\t.name =\t\t\"snd-usb-usx2y\",\n\t.probe =\tsnd_usx2y_probe,\n\t.disconnect =\tsnd_usx2y_disconnect,\n\t.id_table =\tsnd_usx2y_usb_id_table,\n};\nmodule_usb_driver(snd_usx2y_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}