{
  "module_name": "implicit.c",
  "hash_id": "bf7a190b11e5e29ad73f54717be6a4abcd72cbfc996c57fa2ff1833ec091a469",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/implicit.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"helper.h\"\n#include \"pcm.h\"\n#include \"implicit.h\"\n\nenum {\n\tIMPLICIT_FB_NONE,\n\tIMPLICIT_FB_GENERIC,\n\tIMPLICIT_FB_FIXED,\n\tIMPLICIT_FB_BOTH,\t \n};\n\nstruct snd_usb_implicit_fb_match {\n\tunsigned int id;\n\tunsigned int iface_class;\n\tunsigned int ep_num;\n\tunsigned int iface;\n\tint type;\n};\n\n#define IMPLICIT_FB_GENERIC_DEV(vend, prod) \\\n\t{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_GENERIC }\n#define IMPLICIT_FB_FIXED_DEV(vend, prod, ep, ifnum) \\\n\t{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_FIXED, .ep_num = (ep),\\\n\t    .iface = (ifnum) }\n#define IMPLICIT_FB_BOTH_DEV(vend, prod, ep, ifnum) \\\n\t{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_BOTH, .ep_num = (ep),\\\n\t    .iface = (ifnum) }\n#define IMPLICIT_FB_SKIP_DEV(vend, prod) \\\n\t{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_NONE }\n\n \nstatic const struct snd_usb_implicit_fb_match playback_implicit_fb_quirks[] = {\n\t \n\t \n\tIMPLICIT_FB_FIXED_DEV(0x0763, 0x2030, 0x81, 3),  \n\tIMPLICIT_FB_FIXED_DEV(0x0763, 0x2031, 0x81, 3),  \n\tIMPLICIT_FB_FIXED_DEV(0x0763, 0x2080, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x0763, 0x2081, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x2466, 0x8010, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x31e9, 0x0001, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x31e9, 0x0002, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x0499, 0x172f, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x0d9a, 0x00df, 0x81, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x22f0, 0x0006, 0x81, 3),  \n\tIMPLICIT_FB_FIXED_DEV(0x1686, 0xf029, 0x82, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x2466, 0x8003, 0x86, 2),  \n\tIMPLICIT_FB_FIXED_DEV(0x0499, 0x172a, 0x86, 2),  \n\n\t \n\t{ .id = USB_ID(0x07fd, 0x0004), .iface_class = USB_CLASS_AUDIO,\n\t  .type = IMPLICIT_FB_NONE },\t\t \n\t \n\t{ .id = USB_ID(0x07fd, 0x0004), .iface_class = USB_CLASS_VENDOR_SPEC,\n\t  .type = IMPLICIT_FB_FIXED,\n\t  .ep_num = 0x84, .iface = 0 },\t\t \n\n\t{}  \n};\n\n \nstatic const struct snd_usb_implicit_fb_match capture_implicit_fb_quirks[] = {\n\t{}  \n};\n\n \nstatic int add_implicit_fb_sync_ep(struct snd_usb_audio *chip,\n\t\t\t\t   struct audioformat *fmt,\n\t\t\t\t   int ep, int ep_idx, int ifnum,\n\t\t\t\t   const struct usb_host_interface *alts)\n{\n\tstruct usb_interface *iface;\n\n\tif (!alts) {\n\t\tiface = usb_ifnum_to_if(chip->dev, ifnum);\n\t\tif (!iface || iface->num_altsetting < 2)\n\t\t\treturn 0;\n\t\talts = &iface->altsetting[1];\n\t}\n\n\tfmt->sync_ep = ep;\n\tfmt->sync_iface = ifnum;\n\tfmt->sync_altsetting = alts->desc.bAlternateSetting;\n\tfmt->sync_ep_idx = ep_idx;\n\tfmt->implicit_fb = 1;\n\tusb_audio_dbg(chip,\n\t\t      \"%d:%d: added %s implicit_fb sync_ep %x, iface %d:%d\\n\",\n\t\t      fmt->iface, fmt->altsetting,\n\t\t      (ep & USB_DIR_IN) ? \"playback\" : \"capture\",\n\t\t      fmt->sync_ep, fmt->sync_iface, fmt->sync_altsetting);\n\treturn 1;\n}\n\n \nstatic int add_generic_uac2_implicit_fb(struct snd_usb_audio *chip,\n\t\t\t\t\tstruct audioformat *fmt,\n\t\t\t\t\tunsigned int ifnum,\n\t\t\t\t\tunsigned int altsetting)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_endpoint_descriptor *epd;\n\n\talts = snd_usb_get_host_interface(chip, ifnum, altsetting);\n\tif (!alts)\n\t\treturn 0;\n\tif (alts->desc.bInterfaceClass != USB_CLASS_AUDIO ||\n\t    alts->desc.bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING ||\n\t    alts->desc.bInterfaceProtocol != UAC_VERSION_2 ||\n\t    alts->desc.bNumEndpoints < 1)\n\t\treturn 0;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_in(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=\n\t\t\t\t\tUSB_ENDPOINT_USAGE_IMPLICIT_FB)\n\t\treturn 0;\n\treturn add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress, 0,\n\t\t\t\t       ifnum, alts);\n}\n\nstatic bool roland_sanity_check_iface(struct usb_host_interface *alts)\n{\n\tif (alts->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC ||\n\t    (alts->desc.bInterfaceSubClass != 2 &&\n\t     alts->desc.bInterfaceProtocol != 2) ||\n\t    alts->desc.bNumEndpoints < 1)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic int add_roland_implicit_fb(struct snd_usb_audio *chip,\n\t\t\t\t  struct audioformat *fmt,\n\t\t\t\t  struct usb_host_interface *alts)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\n\tif (!roland_sanity_check_iface(alts))\n\t\treturn 0;\n\t \n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_out(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn 0;\n\n\t \n\talts = snd_usb_get_host_interface(chip,\n\t\t\t\t\t  alts->desc.bInterfaceNumber + 1,\n\t\t\t\t\t  alts->desc.bAlternateSetting);\n\tif (!alts || !roland_sanity_check_iface(alts))\n\t\treturn 0;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_in(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn 0;\n\tchip->quirk_flags |= QUIRK_FLAG_PLAYBACK_FIRST;\n\treturn add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress, 0,\n\t\t\t\t       alts->desc.bInterfaceNumber, alts);\n}\n\n \nstatic int add_roland_capture_quirk(struct snd_usb_audio *chip,\n\t\t\t\t    struct audioformat *fmt,\n\t\t\t\t    struct usb_host_interface *alts)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\n\tif (!roland_sanity_check_iface(alts))\n\t\treturn 0;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_in(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn 0;\n\n\talts = snd_usb_get_host_interface(chip,\n\t\t\t\t\t  alts->desc.bInterfaceNumber - 1,\n\t\t\t\t\t  alts->desc.bAlternateSetting);\n\tif (!alts || !roland_sanity_check_iface(alts))\n\t\treturn 0;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_out(epd))\n\t\treturn 0;\n\treturn add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress, 0,\n\t\t\t\t       alts->desc.bInterfaceNumber, alts);\n}\n\n \nstatic bool is_pioneer_implicit_fb(struct snd_usb_audio *chip,\n\t\t\t\t   struct usb_host_interface *alts)\n\n{\n\tstruct usb_endpoint_descriptor *epd;\n\n\tif (USB_ID_VENDOR(chip->usb_id) != 0x2b73 &&\n\t    USB_ID_VENDOR(chip->usb_id) != 0x08e4)\n\t\treturn false;\n\tif (alts->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)\n\t\treturn false;\n\tif (alts->desc.bNumEndpoints != 2)\n\t\treturn false;\n\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_out(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn false;\n\n\tepd = get_endpoint(alts, 1);\n\tif (!usb_endpoint_is_isoc_in(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC ||\n\t    ((epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=\n\t     USB_ENDPOINT_USAGE_DATA &&\n\t     (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=\n\t     USB_ENDPOINT_USAGE_IMPLICIT_FB))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int __add_generic_implicit_fb(struct snd_usb_audio *chip,\n\t\t\t\t     struct audioformat *fmt,\n\t\t\t\t     int iface, int altset)\n{\n\tstruct usb_host_interface *alts;\n\tstruct usb_endpoint_descriptor *epd;\n\n\talts = snd_usb_get_host_interface(chip, iface, altset);\n\tif (!alts)\n\t\treturn 0;\n\n\tif ((alts->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC &&\n\t     alts->desc.bInterfaceClass != USB_CLASS_AUDIO) ||\n\t    alts->desc.bNumEndpoints < 1)\n\t\treturn 0;\n\tepd = get_endpoint(alts, 0);\n\tif (!usb_endpoint_is_isoc_in(epd) ||\n\t    (epd->bmAttributes & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn 0;\n\treturn add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress, 0,\n\t\t\t\t       iface, alts);\n}\n\n \nstatic int add_generic_implicit_fb(struct snd_usb_audio *chip,\n\t\t\t\t   struct audioformat *fmt,\n\t\t\t\t   struct usb_host_interface *alts)\n{\n\tif ((fmt->ep_attr & USB_ENDPOINT_SYNCTYPE) != USB_ENDPOINT_SYNC_ASYNC)\n\t\treturn 0;\n\n\tif (__add_generic_implicit_fb(chip, fmt,\n\t\t\t\t      alts->desc.bInterfaceNumber + 1,\n\t\t\t\t      alts->desc.bAlternateSetting))\n\t\treturn 1;\n\treturn __add_generic_implicit_fb(chip, fmt,\n\t\t\t\t\t alts->desc.bInterfaceNumber - 1,\n\t\t\t\t\t alts->desc.bAlternateSetting);\n}\n\nstatic const struct snd_usb_implicit_fb_match *\nfind_implicit_fb_entry(struct snd_usb_audio *chip,\n\t\t       const struct snd_usb_implicit_fb_match *match,\n\t\t       const struct usb_host_interface *alts)\n{\n\tfor (; match->id; match++)\n\t\tif (match->id == chip->usb_id &&\n\t\t    (!match->iface_class ||\n\t\t     (alts->desc.bInterfaceClass == match->iface_class)))\n\t\t\treturn match;\n\n\treturn NULL;\n}\n\n \nstatic int audioformat_implicit_fb_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t struct audioformat *fmt,\n\t\t\t\t\t struct usb_host_interface *alts)\n{\n\tconst struct snd_usb_implicit_fb_match *p;\n\tunsigned int attr = fmt->ep_attr & USB_ENDPOINT_SYNCTYPE;\n\n\tp = find_implicit_fb_entry(chip, playback_implicit_fb_quirks, alts);\n\tif (p) {\n\t\tswitch (p->type) {\n\t\tcase IMPLICIT_FB_GENERIC:\n\t\t\treturn add_generic_implicit_fb(chip, fmt, alts);\n\t\tcase IMPLICIT_FB_NONE:\n\t\t\treturn 0;  \n\t\tcase IMPLICIT_FB_FIXED:\n\t\t\treturn add_implicit_fb_sync_ep(chip, fmt, p->ep_num, 0,\n\t\t\t\t\t\t       p->iface, NULL);\n\t\t}\n\t}\n\n\t \n\tp = find_implicit_fb_entry(chip, capture_implicit_fb_quirks, alts);\n\tif (p) {\n\t\tswitch (p->type) {\n\t\tcase IMPLICIT_FB_FIXED:\n\t\t\treturn 0;  \n\t\tcase IMPLICIT_FB_BOTH:\n\t\t\tchip->quirk_flags |= QUIRK_FLAG_PLAYBACK_FIRST;\n\t\t\treturn add_generic_implicit_fb(chip, fmt, alts);\n\t\t}\n\t}\n\n\t \n\tif (attr == USB_ENDPOINT_SYNC_ASYNC &&\n\t    alts->desc.bInterfaceClass == USB_CLASS_AUDIO &&\n\t    alts->desc.bInterfaceProtocol == UAC_VERSION_2 &&\n\t    alts->desc.bNumEndpoints == 1) {\n\t\tif (add_generic_uac2_implicit_fb(chip, fmt,\n\t\t\t\t\t\t alts->desc.bInterfaceNumber + 1,\n\t\t\t\t\t\t alts->desc.bAlternateSetting))\n\t\t\treturn 1;\n\t}\n\n\t \n\tif (USB_ID_VENDOR(chip->usb_id) == 0x0582) {\n\t\tif (add_roland_implicit_fb(chip, fmt, alts) > 0)\n\t\t\treturn 1;\n\t}\n\n\t \n\tif (is_pioneer_implicit_fb(chip, alts)) {\n\t\tchip->quirk_flags |= QUIRK_FLAG_PLAYBACK_FIRST;\n\t\treturn add_implicit_fb_sync_ep(chip, fmt,\n\t\t\t\t\t       get_endpoint(alts, 1)->bEndpointAddress,\n\t\t\t\t\t       1, alts->desc.bInterfaceNumber,\n\t\t\t\t\t       alts);\n\t}\n\n\t \n\tif (chip->generic_implicit_fb ||\n\t    (chip->quirk_flags & QUIRK_FLAG_GENERIC_IMPLICIT_FB))\n\t\treturn add_generic_implicit_fb(chip, fmt, alts);\n\n\t \n\treturn 0;\n}\n\n \nstatic int audioformat_capture_quirk(struct snd_usb_audio *chip,\n\t\t\t\t     struct audioformat *fmt,\n\t\t\t\t     struct usb_host_interface *alts)\n{\n\tconst struct snd_usb_implicit_fb_match *p;\n\n\tp = find_implicit_fb_entry(chip, capture_implicit_fb_quirks, alts);\n\tif (p && (p->type == IMPLICIT_FB_FIXED || p->type == IMPLICIT_FB_BOTH))\n\t\treturn add_implicit_fb_sync_ep(chip, fmt, p->ep_num, 0,\n\t\t\t\t\t       p->iface, NULL);\n\n\t \n\tif (USB_ID_VENDOR(chip->usb_id) == 0x0582) {\n\t\tif (add_roland_capture_quirk(chip, fmt, alts) > 0)\n\t\t\treturn 1;\n\t}\n\n\tif (is_pioneer_implicit_fb(chip, alts))\n\t\treturn 1;  \n\treturn 0;\n}\n\n \nint snd_usb_parse_implicit_fb_quirk(struct snd_usb_audio *chip,\n\t\t\t\t    struct audioformat *fmt,\n\t\t\t\t    struct usb_host_interface *alts)\n{\n\tif (chip->quirk_flags & QUIRK_FLAG_SKIP_IMPLICIT_FB)\n\t\treturn 0;\n\tif (fmt->endpoint & USB_DIR_IN)\n\t\treturn audioformat_capture_quirk(chip, fmt, alts);\n\telse\n\t\treturn audioformat_implicit_fb_quirk(chip, fmt, alts);\n}\n\n \nstatic int match_endpoint_audioformats(struct snd_usb_substream *subs,\n\t\t\t\t       const struct audioformat *fp,\n\t\t\t\t       int rate, int channels,\n\t\t\t\t       snd_pcm_format_t pcm_format)\n{\n\tint i, score;\n\n\tif (fp->channels < 1)\n\t\treturn 0;\n\n\tif (!(fp->formats & pcm_format_to_bits(pcm_format)))\n\t\treturn 0;\n\n\tif (fp->rates & SNDRV_PCM_RATE_CONTINUOUS) {\n\t\tif (rate < fp->rate_min || rate > fp->rate_max)\n\t\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < fp->nr_rates; i++) {\n\t\t\tif (fp->rate_table[i] == rate)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= fp->nr_rates)\n\t\t\treturn 0;\n\t}\n\n\tscore = 1;\n\tif (fp->channels == channels)\n\t\tscore++;\n\n\treturn score;\n}\n\nstatic struct snd_usb_substream *\nfind_matching_substream(struct snd_usb_audio *chip, int stream, int ep_num,\n\t\t\tint fmt_type)\n{\n\tstruct snd_usb_stream *as;\n\tstruct snd_usb_substream *subs;\n\n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\tsubs = &as->substream[stream];\n\t\tif (as->fmt_type == fmt_type && subs->ep_num == ep_num)\n\t\t\treturn subs;\n\t}\n\n\treturn NULL;\n}\n\n \nconst struct audioformat *\nsnd_usb_find_implicit_fb_sync_format(struct snd_usb_audio *chip,\n\t\t\t\t     const struct audioformat *target,\n\t\t\t\t     const struct snd_pcm_hw_params *params,\n\t\t\t\t     int stream,\n\t\t\t\t     bool *fixed_rate)\n{\n\tstruct snd_usb_substream *subs;\n\tconst struct audioformat *fp, *sync_fmt = NULL;\n\tint score, high_score;\n\n\t \n\tif (target->iface == target->sync_iface &&\n\t    target->altsetting == target->sync_altsetting)\n\t\tsync_fmt = target;\n\n\tsubs = find_matching_substream(chip, stream, target->sync_ep,\n\t\t\t\t       target->fmt_type);\n\tif (!subs)\n\t\tgoto end;\n\n\thigh_score = 0;\n\tlist_for_each_entry(fp, &subs->fmt_list, list) {\n\t\tscore = match_endpoint_audioformats(subs, fp,\n\t\t\t\t\t\t    params_rate(params),\n\t\t\t\t\t\t    params_channels(params),\n\t\t\t\t\t\t    params_format(params));\n\t\tif (score > high_score) {\n\t\t\tsync_fmt = fp;\n\t\t\thigh_score = score;\n\t\t}\n\t}\n\n end:\n\tif (fixed_rate)\n\t\t*fixed_rate = snd_usb_pcm_has_fixed_rate(subs);\n\treturn sync_fmt;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}