{
  "module_name": "mixer_scarlett.c",
  "hash_id": "d6561b2024d41fa3703538a67131877846f34bcefe594834aaf61a8280ba7745",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/mixer_scarlett.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n#include \"power.h\"\n\n#include \"mixer_scarlett.h\"\n\n \n#define SND_SCARLETT_LEVEL_BIAS 128\n#define SND_SCARLETT_MATRIX_IN_MAX 18\n#define SND_SCARLETT_CONTROLS_MAX 10\n#define SND_SCARLETT_OFFSETS_MAX 5\n\nenum {\n\tSCARLETT_OUTPUTS,\n\tSCARLETT_SWITCH_IMPEDANCE,\n\tSCARLETT_SWITCH_PAD,\n\tSCARLETT_SWITCH_GAIN,\n};\n\nenum {\n\tSCARLETT_OFFSET_PCM = 0,\n\tSCARLETT_OFFSET_ANALOG = 1,\n\tSCARLETT_OFFSET_SPDIF = 2,\n\tSCARLETT_OFFSET_ADAT = 3,\n\tSCARLETT_OFFSET_MIX = 4,\n};\n\nstruct scarlett_mixer_elem_enum_info {\n\tint start;\n\tint len;\n\tint offsets[SND_SCARLETT_OFFSETS_MAX];\n\tchar const * const *names;\n};\n\nstruct scarlett_mixer_control {\n\tunsigned char num;\n\tunsigned char type;\n\tconst char *name;\n};\n\nstruct scarlett_device_info {\n\tint matrix_in;\n\tint matrix_out;\n\tint input_len;\n\tint output_len;\n\n\tstruct scarlett_mixer_elem_enum_info opt_master;\n\tstruct scarlett_mixer_elem_enum_info opt_matrix;\n\n\t \n\tint matrix_mux_init[SND_SCARLETT_MATRIX_IN_MAX];\n\n\tint num_controls;\t \n\tconst struct scarlett_mixer_control controls[SND_SCARLETT_CONTROLS_MAX];\n};\n\n \n\nstatic const struct scarlett_mixer_elem_enum_info opt_pad = {\n\t.start = 0,\n\t.len = 2,\n\t.offsets = {},\n\t.names = (char const * const []){\n\t\t\"0dB\", \"-10dB\"\n\t}\n};\n\nstatic const struct scarlett_mixer_elem_enum_info opt_gain = {\n\t.start = 0,\n\t.len = 2,\n\t.offsets = {},\n\t.names = (char const * const []){\n\t\t\"Lo\", \"Hi\"\n\t}\n};\n\nstatic const struct scarlett_mixer_elem_enum_info opt_impedance = {\n\t.start = 0,\n\t.len = 2,\n\t.offsets = {},\n\t.names = (char const * const []){\n\t\t\"Line\", \"Hi-Z\"\n\t}\n};\n\nstatic const struct scarlett_mixer_elem_enum_info opt_clock = {\n\t.start = 1,\n\t.len = 3,\n\t.offsets = {},\n\t.names = (char const * const []){\n\t\t\"Internal\", \"SPDIF\", \"ADAT\"\n\t}\n};\n\nstatic const struct scarlett_mixer_elem_enum_info opt_sync = {\n\t.start = 0,\n\t.len = 2,\n\t.offsets = {},\n\t.names = (char const * const []){\n\t\t\"No Lock\", \"Locked\"\n\t}\n};\n\nstatic int scarlett_ctl_switch_info(struct snd_kcontrol *kctl,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = elem->channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int scarlett_ctl_switch_get(struct snd_kcontrol *kctl,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tint i, err, val;\n\n\tfor (i = 0; i < elem->channels; i++) {\n\t\terr = snd_usb_get_cur_mix_value(elem, i, i, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tval = !val;  \n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int scarlett_ctl_switch_put(struct snd_kcontrol *kctl,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tint i, changed = 0;\n\tint err, oval, val;\n\n\tfor (i = 0; i < elem->channels; i++) {\n\t\terr = snd_usb_get_cur_mix_value(elem, i, i, &oval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tval = ucontrol->value.integer.value[i];\n\t\tval = !val;\n\t\tif (oval != val) {\n\t\t\terr = snd_usb_set_cur_mix_value(elem, i, i, val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\treturn changed;\n}\n\nstatic int scarlett_ctl_resume(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *elem = mixer_elem_list_to_info(list);\n\tint i;\n\n\tfor (i = 0; i < elem->channels; i++)\n\t\tif (elem->cached & (1 << i))\n\t\t\tsnd_usb_set_cur_mix_value(elem, i, i,\n\t\t\t\t\t\t  elem->cache_val[i]);\n\treturn 0;\n}\n\nstatic int scarlett_ctl_info(struct snd_kcontrol *kctl,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = elem->channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = (int)kctl->private_value +\n\t\tSND_SCARLETT_LEVEL_BIAS;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int scarlett_ctl_get(struct snd_kcontrol *kctl,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tint i, err, val;\n\n\tfor (i = 0; i < elem->channels; i++) {\n\t\terr = snd_usb_get_cur_mix_value(elem, i, i, &val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tval = clamp(val / 256, -128, (int)kctl->private_value) +\n\t\t\t\t    SND_SCARLETT_LEVEL_BIAS;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int scarlett_ctl_put(struct snd_kcontrol *kctl,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tint i, changed = 0;\n\tint err, oval, val;\n\n\tfor (i = 0; i < elem->channels; i++) {\n\t\terr = snd_usb_get_cur_mix_value(elem, i, i, &oval);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tval = ucontrol->value.integer.value[i] -\n\t\t\tSND_SCARLETT_LEVEL_BIAS;\n\t\tval = val * 256;\n\t\tif (oval != val) {\n\t\t\terr = snd_usb_set_cur_mix_value(elem, i, i, val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\treturn changed;\n}\n\nstatic void scarlett_generate_name(int i, char *dst, int offsets[])\n{\n\tif (i > offsets[SCARLETT_OFFSET_MIX])\n\t\tsprintf(dst, \"Mix %c\",\n\t\t\t'A'+(i - offsets[SCARLETT_OFFSET_MIX] - 1));\n\telse if (i > offsets[SCARLETT_OFFSET_ADAT])\n\t\tsprintf(dst, \"ADAT %d\", i - offsets[SCARLETT_OFFSET_ADAT]);\n\telse if (i > offsets[SCARLETT_OFFSET_SPDIF])\n\t\tsprintf(dst, \"SPDIF %d\", i - offsets[SCARLETT_OFFSET_SPDIF]);\n\telse if (i > offsets[SCARLETT_OFFSET_ANALOG])\n\t\tsprintf(dst, \"Analog %d\", i - offsets[SCARLETT_OFFSET_ANALOG]);\n\telse if (i > offsets[SCARLETT_OFFSET_PCM])\n\t\tsprintf(dst, \"PCM %d\", i - offsets[SCARLETT_OFFSET_PCM]);\n\telse\n\t\tsprintf(dst, \"Off\");\n}\n\nstatic int scarlett_ctl_enum_dynamic_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\n\tunsigned int items = opt->len;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = elem->channels;\n\tuinfo->value.enumerated.items = items;\n\n\tif (uinfo->value.enumerated.item >= items)\n\t\tuinfo->value.enumerated.item = items - 1;\n\n\t \n\tscarlett_generate_name(uinfo->value.enumerated.item,\n\t\t\t       uinfo->value.enumerated.name,\n\t\t\t       opt->offsets);\n\n\treturn 0;\n}\n\nstatic int scarlett_ctl_enum_info(struct snd_kcontrol *kctl,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\n\n\treturn snd_ctl_enum_info(uinfo, elem->channels, opt->len,\n\t\t\t\t (const char * const *)opt->names);\n}\n\nstatic int scarlett_ctl_enum_get(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\n\tint err, val;\n\n\terr = snd_usb_get_cur_mix_value(elem, 0, 0, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = clamp(val - opt->start, 0, opt->len-1);\n\n\tucontrol->value.enumerated.item[0] = val;\n\n\treturn 0;\n}\n\nstatic int scarlett_ctl_enum_put(struct snd_kcontrol *kctl,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\n\tint err, oval, val;\n\n\terr = snd_usb_get_cur_mix_value(elem, 0, 0, &oval);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = ucontrol->value.integer.value[0];\n\tval = val + opt->start;\n\tif (val != oval) {\n\t\tsnd_usb_set_cur_mix_value(elem, 0, 0, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int scarlett_ctl_enum_resume(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *elem = mixer_elem_list_to_info(list);\n\n\tif (elem->cached)\n\t\tsnd_usb_set_cur_mix_value(elem, 0, 0, *elem->cache_val);\n\treturn 0;\n}\n\nstatic int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *elem = kctl->private_data;\n\tstruct snd_usb_audio *chip = elem->head.mixer->chip;\n\tunsigned char buf[2 * MAX_CHANNELS] = {0, };\n\tint wValue = (elem->control << 8) | elem->idx_off;\n\tint idx = snd_usb_ctrl_intf(chip) | (elem->head.id << 8);\n\tint err;\n\n\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t\tusb_rcvctrlpipe(chip->dev, 0),\n\t\t\t\tUAC2_CS_MEM,\n\t\t\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS |\n\t\t\t\tUSB_DIR_IN, wValue, idx, buf, elem->channels);\n\tif (err < 0)\n\t\treturn err;\n\n\tucontrol->value.enumerated.item[0] = clamp((int)buf[0], 0, 1);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett_ctl_switch_info,\n\t.get =  scarlett_ctl_switch_get,\n\t.put =  scarlett_ctl_switch_put,\n};\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_scarlett_gain, -12800, 100, 0);\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"\",\n\t.info = scarlett_ctl_info,\n\t.get =  scarlett_ctl_get,\n\t.put =  scarlett_ctl_put,\n\t.private_value = 6,   \n\t.tlv = { .p = db_scale_scarlett_gain }\n};\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl_master = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.name = \"\",\n\t.info = scarlett_ctl_info,\n\t.get =  scarlett_ctl_get,\n\t.put =  scarlett_ctl_put,\n\t.private_value = 6,   \n\t.tlv = { .p = db_scale_scarlett_gain }\n};\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett_ctl_enum_info,\n\t.get =  scarlett_ctl_enum_get,\n\t.put =  scarlett_ctl_enum_put,\n};\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl_dynamic_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\",\n\t.info = scarlett_ctl_enum_dynamic_info,\n\t.get =  scarlett_ctl_enum_get,\n\t.put =  scarlett_ctl_enum_put,\n};\n\nstatic const struct snd_kcontrol_new usb_scarlett_ctl_sync = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.name = \"\",\n\t.info = scarlett_ctl_enum_info,\n\t.get =  scarlett_ctl_meter_get,\n};\n\nstatic int add_new_ctl(struct usb_mixer_interface *mixer,\n\t\t       const struct snd_kcontrol_new *ncontrol,\n\t\t       usb_mixer_elem_resume_func_t resume,\n\t\t       int index, int offset, int num,\n\t\t       int val_type, int channels, const char *name,\n\t\t       const struct scarlett_mixer_elem_enum_info *opt,\n\t\t       struct usb_mixer_elem_info **elem_ret\n)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\n\telem->head.mixer = mixer;\n\telem->head.resume = resume;\n\telem->control = offset;\n\telem->idx_off = num;\n\telem->head.id = index;\n\telem->val_type = val_type;\n\n\telem->channels = channels;\n\n\t \n\telem->private_data = (void *)opt;\n\n\tkctl = snd_ctl_new1(ncontrol, elem);\n\tif (!kctl) {\n\t\tkfree(elem);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tstrscpy(kctl->id.name, name, sizeof(kctl->id.name));\n\n\terr = snd_usb_mixer_add_control(&elem->head, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (elem_ret)\n\t\t*elem_ret = elem;\n\n\treturn 0;\n}\n\nstatic int add_output_ctls(struct usb_mixer_interface *mixer,\n\t\t\t   int index, const char *name,\n\t\t\t   const struct scarlett_device_info *info)\n{\n\tint err;\n\tchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tstruct usb_mixer_elem_info *elem;\n\n\t \n\tsnprintf(mx, sizeof(mx), \"Master %d (%s) Playback Switch\",\n\t\tindex + 1, name);\n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_switch,\n\t\t\t  scarlett_ctl_resume, 0x0a, 0x01,\n\t\t\t  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnprintf(mx, sizeof(mx), \"Master %d (%s) Playback Volume\",\n\t\tindex + 1, name);\n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_master,\n\t\t\t  scarlett_ctl_resume, 0x0a, 0x02,\n\t\t\t  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnprintf(mx, sizeof(mx), \"Master %dL (%s) Source Playback Enum\",\n\t\tindex + 1, name);\n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\n\t\t\t  scarlett_ctl_enum_resume, 0x33, 0x00,\n\t\t\t  2*index, USB_MIXER_S16, 1, mx, &info->opt_master,\n\t\t\t  &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnprintf(mx, sizeof(mx), \"Master %dR (%s) Source Playback Enum\",\n\t\tindex + 1, name);\n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\n\t\t\t  scarlett_ctl_enum_resume, 0x33, 0x00,\n\t\t\t  2*index+1, USB_MIXER_S16, 1, mx, &info->opt_master,\n\t\t\t  &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\n \nstatic const struct scarlett_device_info s6i6_info = {\n\t.matrix_in = 18,\n\t.matrix_out = 8,\n\t.input_len = 6,\n\t.output_len = 6,\n\n\t.opt_master = {\n\t\t.start = -1,\n\t\t.len = 27,\n\t\t.offsets = {0, 12, 16, 18, 18},\n\t\t.names = NULL\n\t},\n\n\t.opt_matrix = {\n\t\t.start = -1,\n\t\t.len = 19,\n\t\t.offsets = {0, 12, 16, 18, 18},\n\t\t.names = NULL\n\t},\n\n\t.num_controls = 9,\n\t.controls = {\n\t\t{ .num = 0, .type = SCARLETT_OUTPUTS, .name = \"Monitor\" },\n\t\t{ .num = 1, .type = SCARLETT_OUTPUTS, .name = \"Headphone\" },\n\t\t{ .num = 2, .type = SCARLETT_OUTPUTS, .name = \"SPDIF\" },\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 3, .type = SCARLETT_SWITCH_GAIN, .name = NULL},\n\t\t{ .num = 4, .type = SCARLETT_SWITCH_GAIN, .name = NULL},\n\t},\n\n\t.matrix_mux_init = {\n\t\t12, 13, 14, 15,                  \n\t\t16, 17,                           \n\t\t0, 1, 2, 3, 4, 5, 6, 7,      \n\t\t8, 9, 10, 11\n\t}\n};\n\n \nstatic const struct scarlett_device_info s8i6_info = {\n\t.matrix_in = 18,\n\t.matrix_out = 6,\n\t.input_len = 8,\n\t.output_len = 6,\n\n\t.opt_master = {\n\t\t.start = -1,\n\t\t.len = 25,\n\t\t.offsets = {0, 12, 16, 18, 18},\n\t\t.names = NULL\n\t},\n\n\t.opt_matrix = {\n\t\t.start = -1,\n\t\t.len = 19,\n\t\t.offsets = {0, 12, 16, 18, 18},\n\t\t.names = NULL\n\t},\n\n\t.num_controls = 7,\n\t.controls = {\n\t\t{ .num = 0, .type = SCARLETT_OUTPUTS, .name = \"Monitor\" },\n\t\t{ .num = 1, .type = SCARLETT_OUTPUTS, .name = \"Headphone\" },\n\t\t{ .num = 2, .type = SCARLETT_OUTPUTS, .name = \"SPDIF\" },\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t},\n\n\t.matrix_mux_init = {\n\t\t12, 13, 14, 15,                  \n\t\t16, 17,                           \n\t\t0, 1, 2, 3, 4, 5, 6, 7,      \n\t\t8, 9, 10, 11\n\t}\n};\n\nstatic const struct scarlett_device_info s18i6_info = {\n\t.matrix_in = 18,\n\t.matrix_out = 6,\n\t.input_len = 18,\n\t.output_len = 6,\n\n\t.opt_master = {\n\t\t.start = -1,\n\t\t.len = 31,\n\t\t.offsets = {0, 6, 14, 16, 24},\n\t\t.names = NULL,\n\t},\n\n\t.opt_matrix = {\n\t\t.start = -1,\n\t\t.len = 25,\n\t\t.offsets = {0, 6, 14, 16, 24},\n\t\t.names = NULL,\n\t},\n\n\t.num_controls = 5,\n\t.controls = {\n\t\t{ .num = 0, .type = SCARLETT_OUTPUTS, .name = \"Monitor\" },\n\t\t{ .num = 1, .type = SCARLETT_OUTPUTS, .name = \"Headphone\" },\n\t\t{ .num = 2, .type = SCARLETT_OUTPUTS, .name = \"SPDIF\" },\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t},\n\n\t.matrix_mux_init = {\n\t\t 6,  7,  8,  9, 10, 11, 12, 13,  \n\t\t16, 17, 18, 19, 20, 21,      \n\t\t14, 15,                           \n\t\t0, 1                           \n\t}\n};\n\nstatic const struct scarlett_device_info s18i8_info = {\n\t.matrix_in = 18,\n\t.matrix_out = 8,\n\t.input_len = 18,\n\t.output_len = 8,\n\n\t.opt_master = {\n\t\t.start = -1,\n\t\t.len = 35,\n\t\t.offsets = {0, 8, 16, 18, 26},\n\t\t.names = NULL\n\t},\n\n\t.opt_matrix = {\n\t\t.start = -1,\n\t\t.len = 27,\n\t\t.offsets = {0, 8, 16, 18, 26},\n\t\t.names = NULL\n\t},\n\n\t.num_controls = 10,\n\t.controls = {\n\t\t{ .num = 0, .type = SCARLETT_OUTPUTS, .name = \"Monitor\" },\n\t\t{ .num = 1, .type = SCARLETT_OUTPUTS, .name = \"Headphone 1\" },\n\t\t{ .num = 2, .type = SCARLETT_OUTPUTS, .name = \"Headphone 2\" },\n\t\t{ .num = 3, .type = SCARLETT_OUTPUTS, .name = \"SPDIF\" },\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},\n\t\t{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t\t{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},\n\t},\n\n\t.matrix_mux_init = {\n\t\t 8,  9, 10, 11, 12, 13, 14, 15,  \n\t\t18, 19, 20, 21, 22, 23,      \n\t\t16, 17,                           \n\t\t0, 1                           \n\t}\n};\n\nstatic const struct scarlett_device_info s18i20_info = {\n\t.matrix_in = 18,\n\t.matrix_out = 8,\n\t.input_len = 18,\n\t.output_len = 20,\n\n\t.opt_master = {\n\t\t.start = -1,\n\t\t.len = 47,\n\t\t.offsets = {0, 20, 28, 30, 38},\n\t\t.names = NULL\n\t},\n\n\t.opt_matrix = {\n\t\t.start = -1,\n\t\t.len = 39,\n\t\t.offsets = {0, 20, 28, 30, 38},\n\t\t.names = NULL\n\t},\n\n\t.num_controls = 10,\n\t.controls = {\n\t\t{ .num = 0, .type = SCARLETT_OUTPUTS, .name = \"Monitor\" },\n\t\t{ .num = 1, .type = SCARLETT_OUTPUTS, .name = \"Line 3/4\" },\n\t\t{ .num = 2, .type = SCARLETT_OUTPUTS, .name = \"Line 5/6\" },\n\t\t{ .num = 3, .type = SCARLETT_OUTPUTS, .name = \"Line 7/8\" },\n\t\t{ .num = 4, .type = SCARLETT_OUTPUTS, .name = \"Line 9/10\" },\n\t\t{ .num = 5, .type = SCARLETT_OUTPUTS, .name = \"SPDIF\" },\n\t\t{ .num = 6, .type = SCARLETT_OUTPUTS, .name = \"ADAT 1/2\" },\n\t\t{ .num = 7, .type = SCARLETT_OUTPUTS, .name = \"ADAT 3/4\" },\n\t\t{ .num = 8, .type = SCARLETT_OUTPUTS, .name = \"ADAT 5/6\" },\n\t\t{ .num = 9, .type = SCARLETT_OUTPUTS, .name = \"ADAT 7/8\" },\n\t\t \n\t},\n\n\t.matrix_mux_init = {\n\t\t20, 21, 22, 23, 24, 25, 26, 27,  \n\t\t30, 31, 32, 33, 34, 35,      \n\t\t28, 29,                           \n\t\t0, 1                           \n\t}\n};\n\n\nstatic int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,\n\tconst struct scarlett_device_info *info)\n{\n\tint i, err;\n\tchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tconst struct scarlett_mixer_control *ctl;\n\tstruct usb_mixer_elem_info *elem;\n\n\t \n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_switch,\n\t\t\t  scarlett_ctl_resume, 0x0a, 0x01, 0,\n\t\t\t  USB_MIXER_S16, 1, \"Master Playback Switch\", NULL,\n\t\t\t  &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_master,\n\t\t\t  scarlett_ctl_resume, 0x0a, 0x02, 0,\n\t\t\t  USB_MIXER_S16, 1, \"Master Playback Volume\", NULL,\n\t\t\t  &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < info->num_controls; i++) {\n\t\tctl = &info->controls[i];\n\n\t\tswitch (ctl->type) {\n\t\tcase SCARLETT_OUTPUTS:\n\t\t\terr = add_output_ctls(mixer, ctl->num, ctl->name, info);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase SCARLETT_SWITCH_IMPEDANCE:\n\t\t\tsprintf(mx, \"Input %d Impedance Switch\", ctl->num);\n\t\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\n\t\t\t\t\t  scarlett_ctl_enum_resume, 0x01,\n\t\t\t\t\t  0x09, ctl->num, USB_MIXER_S16, 1, mx,\n\t\t\t\t\t  &opt_impedance, &elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase SCARLETT_SWITCH_PAD:\n\t\t\tsprintf(mx, \"Input %d Pad Switch\", ctl->num);\n\t\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\n\t\t\t\t\t  scarlett_ctl_enum_resume, 0x01,\n\t\t\t\t\t  0x0b, ctl->num, USB_MIXER_S16, 1, mx,\n\t\t\t\t\t  &opt_pad, &elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase SCARLETT_SWITCH_GAIN:\n\t\t\tsprintf(mx, \"Input %d Gain Switch\", ctl->num);\n\t\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\n\t\t\t\t\t  scarlett_ctl_enum_resume, 0x01,\n\t\t\t\t\t  0x08, ctl->num, USB_MIXER_S16, 1, mx,\n\t\t\t\t\t  &opt_gain, &elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint snd_scarlett_controls_create(struct usb_mixer_interface *mixer)\n{\n\tint err, i, o;\n\tchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tconst struct scarlett_device_info *info;\n\tstruct usb_mixer_elem_info *elem;\n\tstatic char sample_rate_buffer[4] = { '\\x80', '\\xbb', '\\x00', '\\x00' };\n\n\t \n\tif (!mixer->protocol)\n\t\treturn 0;\n\n\tswitch (mixer->chip->usb_id) {\n\tcase USB_ID(0x1235, 0x8012):\n\t\tinfo = &s6i6_info;\n\t\tbreak;\n\tcase USB_ID(0x1235, 0x8002):\n\t\tinfo = &s8i6_info;\n\t\tbreak;\n\tcase USB_ID(0x1235, 0x8004):\n\t\tinfo = &s18i6_info;\n\t\tbreak;\n\tcase USB_ID(0x1235, 0x8014):\n\t\tinfo = &s18i8_info;\n\t\tbreak;\n\tcase USB_ID(0x1235, 0x800c):\n\t\tinfo = &s18i20_info;\n\t\tbreak;\n\tdefault:  \n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = scarlett_controls_create_generic(mixer, info);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < info->matrix_in; i++) {\n\t\tsnprintf(mx, sizeof(mx), \"Matrix %02d Input Playback Route\",\n\t\t\t i+1);\n\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\n\t\t\t\t  scarlett_ctl_enum_resume, 0x32,\n\t\t\t\t  0x06, i, USB_MIXER_S16, 1, mx,\n\t\t\t\t  &info->opt_matrix, &elem);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tfor (o = 0; o < info->matrix_out; o++) {\n\t\t\tsprintf(mx, \"Matrix %02d Mix %c Playback Volume\", i+1,\n\t\t\t\to+'A');\n\t\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl,\n\t\t\t\t\t  scarlett_ctl_resume, 0x3c, 0x00,\n\t\t\t\t\t  (i << 3) + (o & 0x07), USB_MIXER_S16,\n\t\t\t\t\t  1, mx, NULL, &elem);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t}\n\t}\n\n\tfor (i = 0; i < info->input_len; i++) {\n\t\tsnprintf(mx, sizeof(mx), \"Input Source %02d Capture Route\",\n\t\t\t i+1);\n\t\terr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\n\t\t\t\t  scarlett_ctl_enum_resume, 0x34,\n\t\t\t\t  0x00, i, USB_MIXER_S16, 1, mx,\n\t\t\t\t  &info->opt_master, &elem);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\n\t\t\t  scarlett_ctl_enum_resume, 0x28, 0x01, 0,\n\t\t\t  USB_MIXER_U8, 1, \"Sample Clock Source\",\n\t\t\t  &opt_clock, &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = add_new_ctl(mixer, &usb_scarlett_ctl_sync, NULL, 0x3c, 0x00, 2,\n\t\t\t  USB_MIXER_U8, 1, \"Sample Clock Sync Status\",\n\t\t\t  &opt_sync, &elem);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_usb_ctl_msg(mixer->chip->dev,\n\t\tusb_sndctrlpipe(mixer->chip->dev, 0), UAC2_CS_CUR,\n\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS |\n\t\tUSB_DIR_OUT, 0x0100, snd_usb_ctrl_intf(mixer->chip) |\n\t\t(0x29 << 8), sample_rate_buffer, 4);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}