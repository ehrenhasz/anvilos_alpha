{
  "module_name": "power.c",
  "hash_id": "4ee366a9e60173d531e4373398236679ae33c99ddfe39a828a36b56eba68e23b",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/power.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n\n#include \"usbaudio.h\"\n#include \"helper.h\"\n#include \"power.h\"\n\nstruct snd_usb_power_domain *\nsnd_usb_find_power_domain(struct usb_host_interface *ctrl_iface,\n\t\t\t  unsigned char id)\n{\n\tstruct snd_usb_power_domain *pd;\n\tvoid *p;\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\n\tp = NULL;\n\twhile ((p = snd_usb_find_csint_desc(ctrl_iface->extra,\n\t\t\t\t\t    ctrl_iface->extralen,\n\t\t\t\t\t    p, UAC3_POWER_DOMAIN)) != NULL) {\n\t\tstruct uac3_power_domain_descriptor *pd_desc = p;\n\t\tint i;\n\n\t\tif (!snd_usb_validate_audio_desc(p, UAC_VERSION_3))\n\t\t\tcontinue;\n\t\tfor (i = 0; i < pd_desc->bNrEntities; i++) {\n\t\t\tif (pd_desc->baEntityID[i] == id) {\n\t\t\t\tpd->pd_id = pd_desc->bPowerDomainID;\n\t\t\t\tpd->pd_d1d0_rec =\n\t\t\t\t\tle16_to_cpu(pd_desc->waRecoveryTime1);\n\t\t\t\tpd->pd_d2d0_rec =\n\t\t\t\t\tle16_to_cpu(pd_desc->waRecoveryTime2);\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(pd);\n\treturn NULL;\n}\n\nint snd_usb_power_domain_set(struct snd_usb_audio *chip,\n\t\t\t     struct snd_usb_power_domain *pd,\n\t\t\t     unsigned char state)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned char current_state;\n\tint err, idx;\n\n\tidx = snd_usb_ctrl_intf(chip) | (pd->pd_id << 8);\n\n\terr = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0),\n\t\t\t      UAC2_CS_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      UAC3_AC_POWER_DOMAIN_CONTROL << 8, idx,\n\t\t\t      &current_state, sizeof(current_state));\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"Can't get UAC3 power state for id %d\\n\",\n\t\t\tpd->pd_id);\n\t\treturn err;\n\t}\n\n\tif (current_state == state) {\n\t\tdev_dbg(&dev->dev, \"UAC3 power domain id %d already in state %d\\n\",\n\t\t\tpd->pd_id, state);\n\t\treturn 0;\n\t}\n\n\terr = snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t      UAC3_AC_POWER_DOMAIN_CONTROL << 8, idx,\n\t\t\t      &state, sizeof(state));\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"Can't set UAC3 power state to %d for id %d\\n\",\n\t\t\tstate, pd->pd_id);\n\t\treturn err;\n\t}\n\n\tif (state == UAC3_PD_STATE_D0) {\n\t\tswitch (current_state) {\n\t\tcase UAC3_PD_STATE_D2:\n\t\t\tudelay(pd->pd_d2d0_rec * 50);\n\t\t\tbreak;\n\t\tcase UAC3_PD_STATE_D1:\n\t\t\tudelay(pd->pd_d1d0_rec * 50);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(&dev->dev, \"UAC3 power domain id %d change to state %d\\n\",\n\t\tpd->pd_id, state);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}