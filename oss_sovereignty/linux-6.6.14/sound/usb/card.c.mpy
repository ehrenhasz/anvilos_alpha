{
  "module_name": "card.c",
  "hash_id": "c265f09d9acbb2103d80394f6a8dc20f258e846ceff2cfda3cbda2b8f0e70f14",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/card.c",
  "human_readable_source": "\n \n\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n#include <linux/module.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"midi.h\"\n#include \"midi2.h\"\n#include \"mixer.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"pcm.h\"\n#include \"format.h\"\n#include \"power.h\"\n#include \"stream.h\"\n#include \"media.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"USB Audio\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; \n \nstatic int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int device_setup[SNDRV_CARDS];  \nstatic bool ignore_ctl_error;\nstatic bool autoclock = true;\nstatic bool lowlatency = true;\nstatic char *quirk_alias[SNDRV_CARDS];\nstatic char *delayed_register[SNDRV_CARDS];\nstatic bool implicit_fb[SNDRV_CARDS];\nstatic unsigned int quirk_flags[SNDRV_CARDS];\n\nbool snd_usb_use_vmalloc = true;\nbool snd_usb_skip_validation;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the USB audio adapter.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the USB audio adapter.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable USB audio adapter.\");\nmodule_param_array(vid, int, NULL, 0444);\nMODULE_PARM_DESC(vid, \"Vendor ID for the USB audio device.\");\nmodule_param_array(pid, int, NULL, 0444);\nMODULE_PARM_DESC(pid, \"Product ID for the USB audio device.\");\nmodule_param_array(device_setup, int, NULL, 0444);\nMODULE_PARM_DESC(device_setup, \"Specific device setup (if needed).\");\nmodule_param(ignore_ctl_error, bool, 0444);\nMODULE_PARM_DESC(ignore_ctl_error,\n\t\t \"Ignore errors from USB controller for mixer interfaces.\");\nmodule_param(autoclock, bool, 0444);\nMODULE_PARM_DESC(autoclock, \"Enable auto-clock selection for UAC2 devices (default: yes).\");\nmodule_param(lowlatency, bool, 0444);\nMODULE_PARM_DESC(lowlatency, \"Enable low latency playback (default: yes).\");\nmodule_param_array(quirk_alias, charp, NULL, 0444);\nMODULE_PARM_DESC(quirk_alias, \"Quirk aliases, e.g. 0123abcd:5678beef.\");\nmodule_param_array(delayed_register, charp, NULL, 0444);\nMODULE_PARM_DESC(delayed_register, \"Quirk for delayed registration, given by id:iface, e.g. 0123abcd:4.\");\nmodule_param_array(implicit_fb, bool, NULL, 0444);\nMODULE_PARM_DESC(implicit_fb, \"Apply generic implicit feedback sync mode.\");\nmodule_param_array(quirk_flags, uint, NULL, 0444);\nMODULE_PARM_DESC(quirk_flags, \"Driver quirk bit flags.\");\nmodule_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);\nMODULE_PARM_DESC(use_vmalloc, \"Use vmalloc for PCM intermediate buffers (default: yes).\");\nmodule_param_named(skip_validation, snd_usb_skip_validation, bool, 0444);\nMODULE_PARM_DESC(skip_validation, \"Skip unit descriptor validation (default: no).\");\n\n \n\nstatic DEFINE_MUTEX(register_mutex);\nstatic struct snd_usb_audio *usb_chip[SNDRV_CARDS];\nstatic struct usb_driver usb_audio_driver;\n\n \nstatic void snd_usb_stream_disconnect(struct snd_usb_stream *as)\n{\n\tint idx;\n\tstruct snd_usb_substream *subs;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubs = &as->substream[idx];\n\t\tif (!subs->num_formats)\n\t\t\tcontinue;\n\t\tsubs->data_endpoint = NULL;\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\nstatic int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t \n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = snd_usb_midi_v2_create(chip, iface, NULL,\n\t\t\t\t\t\t chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn usb_driver_claim_interface(&usb_audio_driver, iface,\n\t\t\t\t\t\t  USB_AUDIO_IFACE_UNUSED);\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0);  \n\t\treturn usb_driver_claim_interface(&usb_audio_driver, iface,\n\t\t\t\t\t\t  USB_AUDIO_IFACE_UNUSED);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tint i, protocol;\n\n\t \n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\tfallthrough;\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1;\n\t\tint rest_bytes;\n\n\t\th1 = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t\t NULL, UAC_HEADER);\n\t\tif (!h1 || h1->bLength < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trest_bytes = (void *)(host_iface->extra +\n\t\t\t\thost_iface->extralen) - (void *)h1;\n\n\t\t \n\t\tif (rest_bytes <= 0) {\n\t\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t \n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2/v3 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (protocol == UAC_VERSION_3) {\n\t\t\tint badd = assoc->bFunctionSubClass;\n\n\t\t\tif (badd != UAC3_FUNCTION_SUBCLASS_FULL_ADC_3_0 &&\n\t\t\t    (badd < UAC3_FUNCTION_SUBCLASS_GENERIC_IO ||\n\t\t\t     badd > UAC3_FUNCTION_SUBCLASS_SPEAKERPHONE)) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Unsupported UAC3 BADD profile\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tchip->badd_profile = badd;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\n \nstruct usb_audio_device_name {\n\tu32 id;\n\tconst char *vendor_name;\n\tconst char *product_name;\n\tconst char *profile_name;\t \n};\n\n#define PROFILE_NAME(vid, pid, vendor, product, profile)\t \\\n\t{ .id = USB_ID(vid, pid), .vendor_name = (vendor),\t \\\n\t  .product_name = (product), .profile_name = (profile) }\n#define DEVICE_NAME(vid, pid, vendor, product) \\\n\tPROFILE_NAME(vid, pid, vendor, product, NULL)\n\n \nstatic const struct usb_audio_device_name usb_audio_names[] = {\n\t \n\tPROFILE_NAME(0x03f0, 0x0269, \"HP\", \"Thunderbolt Dock Audio Headset\",\n\t\t     \"HP-Thunderbolt-Dock-Audio-Headset\"),\n\t \n\tPROFILE_NAME(0x03f0, 0x0567, \"HP\", \"Thunderbolt Dock Audio Module\",\n\t\t     \"HP-Thunderbolt-Dock-Audio-Module\"),\n\n\t \n\tPROFILE_NAME(0x0414, 0xa000, \"Gigabyte\", \"Aorus Master Front Headphone\",\n\t\t     \"Gigabyte-Aorus-Master-Front-Headphone\"),\n\tPROFILE_NAME(0x0414, 0xa001, \"Gigabyte\", \"Aorus Master Main Audio\",\n\t\t     \"Gigabyte-Aorus-Master-Main-Audio\"),\n\n\t \n\tPROFILE_NAME(0x0414, 0xa002,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\n\t \n\tDEVICE_NAME(0x041e, 0x3010, \"Creative Labs\", \"Sound Blaster MP3+\"),\n\t \n\tDEVICE_NAME(0x041e, 0x3048, \"Toshiba\", \"SB-0500\"),\n\n\tDEVICE_NAME(0x046d, 0x0990, \"Logitech, Inc.\", \"QuickCam Pro 9000\"),\n\n\tDEVICE_NAME(0x05e1, 0x0408, \"Syntek\", \"STK1160\"),\n\tDEVICE_NAME(0x05e1, 0x0480, \"Hauppauge\", \"Woodbury\"),\n\n\t \n\tPROFILE_NAME(0x0b05, 0x1915, \"ASUS\", \"Zenith II Front Headphone\",\n\t\t     \"Zenith-II-Front-Headphone\"),\n\tPROFILE_NAME(0x0b05, 0x1916, \"ASUS\", \"Zenith II Main Audio\",\n\t\t     \"Zenith-II-Main-Audio\"),\n\n\t \n\tPROFILE_NAME(0x0b05, 0x1917,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\t \n\tPROFILE_NAME(0x0b05, 0x1918,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\n\t \n\tPROFILE_NAME(0x0bda, 0x4014, \"Dell\", \"WD15 Dock\", \"Dell-WD15-Dock\"),\n\t \n\tPROFILE_NAME(0x0bda, 0x402e, \"Dell\", \"WD19 Dock\", \"Dell-WD15-Dock\"),\n\n\tDEVICE_NAME(0x0ccd, 0x0028, \"TerraTec\", \"Aureon5.1MkII\"),\n\n\t \n\tDEVICE_NAME(0x0d8c, 0x0102, NULL, \"ICUSBAUDIO7D\"),\n\tDEVICE_NAME(0x0d8c, 0x0103, NULL, \"Audio Advantage MicroII\"),\n\n\t \n\tPROFILE_NAME(0x0db0, 0x0d64,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\t \n\tPROFILE_NAME(0x0db0, 0x543d,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\n\tDEVICE_NAME(0x0fd9, 0x0008, \"Hauppauge\", \"HVR-950Q\"),\n\n\t \n\tDEVICE_NAME(0x103d, 0x0100, \"Stanton\", \"ScratchAmp\"),\n\tDEVICE_NAME(0x103d, 0x0101, \"Stanton\", \"ScratchAmp\"),\n\n\t \n\tDEVICE_NAME(0x13e5, 0x0001, \"Rane\", \"SL-1\"),\n\n\t \n\tPROFILE_NAME(0x17aa, 0x1046, \"Lenovo\", \"ThinkStation P620 Rear\",\n\t\t     \"Lenovo-ThinkStation-P620-Rear\"),\n\t \n\tPROFILE_NAME(0x17aa, 0x104d, \"Lenovo\", \"ThinkStation P620 Main\",\n\t\t     \"Lenovo-ThinkStation-P620-Main\"),\n\n\t \n\tPROFILE_NAME(0x26ce, 0x0a01,\n\t\t     \"Realtek\", \"ALC1220-VB-DT\", \"Realtek-ALC1220-VB-Desktop\"),\n\n\tDEVICE_NAME(0x2040, 0x7200, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7201, \"Hauppauge\", \"HVR-950Q-MXL\"),\n\tDEVICE_NAME(0x2040, 0x7210, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7211, \"Hauppauge\", \"HVR-950Q-MXL\"),\n\tDEVICE_NAME(0x2040, 0x7213, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7217, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x721b, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x721e, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x721f, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7240, \"Hauppauge\", \"HVR-850\"),\n\tDEVICE_NAME(0x2040, 0x7260, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7270, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7280, \"Hauppauge\", \"HVR-950Q\"),\n\tDEVICE_NAME(0x2040, 0x7281, \"Hauppauge\", \"HVR-950Q-MXL\"),\n\tDEVICE_NAME(0x2040, 0x8200, \"Hauppauge\", \"Woodbury\"),\n\n\t{ }  \n};\n\nstatic const struct usb_audio_device_name *\nlookup_device_name(u32 id)\n{\n\tstatic const struct usb_audio_device_name *p;\n\n\tfor (p = usb_audio_names; p->id; p++)\n\t\tif (p->id == id)\n\t\t\treturn p;\n\treturn NULL;\n}\n\n \n\nstatic void snd_usb_audio_free(struct snd_card *card)\n{\n\tstruct snd_usb_audio *chip = card->private_data;\n\n\tsnd_usb_endpoint_free_all(chip);\n\tsnd_usb_midi_v2_free_all(chip);\n\n\tmutex_destroy(&chip->mutex);\n\tif (!atomic_read(&chip->shutdown))\n\t\tdev_set_drvdata(&chip->dev->dev, NULL);\n}\n\nstatic void usb_audio_make_shortname(struct usb_device *dev,\n\t\t\t\t     struct snd_usb_audio *chip,\n\t\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\tconst struct usb_audio_device_name *preset;\n\tconst char *s = NULL;\n\n\tpreset = lookup_device_name(chip->usb_id);\n\tif (preset && preset->product_name)\n\t\ts = preset->product_name;\n\telse if (quirk && quirk->product_name)\n\t\ts = quirk->product_name;\n\tif (s && *s) {\n\t\tstrscpy(card->shortname, s, sizeof(card->shortname));\n\t\treturn;\n\t}\n\n\t \n\tif (!dev->descriptor.iProduct ||\n\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t       card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t \n\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t}\n\n\tstrim(card->shortname);\n}\n\nstatic void usb_audio_make_longname(struct usb_device *dev,\n\t\t\t\t    struct snd_usb_audio *chip,\n\t\t\t\t    const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\tconst struct usb_audio_device_name *preset;\n\tconst char *s = NULL;\n\tint len;\n\n\tpreset = lookup_device_name(chip->usb_id);\n\n\t \n\tif (preset && preset->profile_name)\n\t\ts = preset->profile_name;\n\tif (s && *s) {\n\t\tstrscpy(card->longname, s, sizeof(card->longname));\n\t\treturn;\n\t}\n\n\tif (preset && preset->vendor_name)\n\t\ts = preset->vendor_name;\n\telse if (quirk && quirk->vendor_name)\n\t\ts = quirk->vendor_name;\n\t*card->longname = 0;\n\tif (s && *s) {\n\t\tstrscpy(card->longname, s, sizeof(card->longname));\n\t} else {\n\t\t \n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tusb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t   card->longname, sizeof(card->longname));\n\t\t \n\t}\n\tif (*card->longname) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err;\n\tchar component[14];\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   sizeof(*chip), &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = card->private_data;\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->generic_implicit_fb = implicit_fb[idx];\n\tchip->autoclock = autoclock;\n\tchip->lowlatency = lowlatency;\n\tatomic_set(&chip->active, 1);  \n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->iface_ref_list);\n\tINIT_LIST_HEAD(&chip->clock_ref_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->midi_v2_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tif (quirk_flags[idx])\n\t\tchip->quirk_flags = quirk_flags[idx];\n\telse\n\t\tsnd_usb_init_quirk_flags(chip);\n\n\tcard->private_free = snd_usb_audio_free;\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\tusb_audio_make_shortname(dev, chip, quirk);\n\tusb_audio_make_longname(dev, chip, quirk);\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}\n\n \nstatic bool get_alias_id(struct usb_device *dev, unsigned int *id)\n{\n\tint i;\n\tunsigned int src, dst;\n\n\tfor (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {\n\t\tif (!quirk_alias[i] ||\n\t\t    sscanf(quirk_alias[i], \"%x:%x\", &src, &dst) != 2 ||\n\t\t    src != *id)\n\t\t\tcontinue;\n\t\tdev_info(&dev->dev,\n\t\t\t \"device (%04x:%04x): applying quirk alias %04x:%04x\\n\",\n\t\t\t USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),\n\t\t\t USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));\n\t\t*id = dst;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int check_delayed_register_option(struct snd_usb_audio *chip)\n{\n\tint i;\n\tunsigned int id, inum;\n\n\tfor (i = 0; i < ARRAY_SIZE(delayed_register); i++) {\n\t\tif (delayed_register[i] &&\n\t\t    sscanf(delayed_register[i], \"%x:%x\", &id, &inum) == 2 &&\n\t\t    id == chip->usb_id)\n\t\t\treturn inum;\n\t}\n\n\treturn -1;\n}\n\nstatic const struct usb_device_id usb_audio_ids[];  \n\n \nstatic void find_last_interface(struct snd_usb_audio *chip)\n{\n\tstruct usb_host_config *config = chip->dev->actconfig;\n\tstruct usb_interface *intf;\n\tint i;\n\n\tif (!config)\n\t\treturn;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tintf = config->interface[i];\n\t\tif (usb_match_id(intf, usb_audio_ids))\n\t\t\tchip->last_iface = intf->altsetting[0].desc.bInterfaceNumber;\n\t}\n\tusb_audio_dbg(chip, \"Found last interface = %d\\n\", chip->last_iface);\n}\n\n \nstatic const struct snd_usb_audio_quirk *\nget_alias_quirk(struct usb_device *dev, unsigned int id)\n{\n\tconst struct usb_device_id *p;\n\n\tfor (p = usb_audio_ids; p->match_flags; p++) {\n\t\t \n\t\tif ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==\n\t\t    USB_DEVICE_ID_MATCH_DEVICE &&\n\t\t    p->idVendor == USB_ID_VENDOR(id) &&\n\t\t    p->idProduct == USB_ID_PRODUCT(id))\n\t\t\treturn (const struct snd_usb_audio_quirk *)p->driver_info;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int try_to_register_card(struct snd_usb_audio *chip, int ifnum)\n{\n\tif (check_delayed_register_option(chip) == ifnum ||\n\t    chip->last_iface == ifnum ||\n\t    usb_interface_claimed(usb_ifnum_to_if(chip->dev, chip->last_iface)))\n\t\treturn snd_card_register(chip->card);\n\treturn 0;\n}\n\n \nstatic int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\tif (quirk && quirk->ifnum == QUIRK_NODEV_INTERFACE)\n\t\treturn -ENODEV;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\n\t \n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active);  \n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\terr = snd_usb_apply_boot_quirk_once(dev, intf, quirk, id);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\n\t\t \n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t\tfind_last_interface(chip);\n\t}\n\n\tif (chip->num_interfaces >= MAX_CARD_INTERFACES) {\n\t\tdev_info(&dev->dev, \"Too many interfaces assigned to the single USB-audio card\\n\");\n\t\terr = -EINVAL;\n\t\tgoto __error;\n\t}\n\n\tdev_set_drvdata(&dev->dev, chip);\n\n\tif (ignore_ctl_error)\n\t\tchip->quirk_flags |= QUIRK_FLAG_IGNORE_CTL_ERROR;\n\n\tif (chip->quirk_flags & QUIRK_FLAG_DISABLE_AUTOSUSPEND)\n\t\tusb_disable_autosuspend(interface_to_usbdev(intf));\n\n\t \n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\terr = 1;  \n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t \n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t \n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (chip->need_delayed_register) {\n\t\tdev_info(&dev->dev,\n\t\t\t \"Found post-registration device assignment: %08x:%02x\\n\",\n\t\t\t chip->usb_id, ifnum);\n\t\tchip->need_delayed_register = false;  \n\t}\n\n\terr = try_to_register_card(chip, ifnum);\n\tif (err < 0)\n\t\tgoto __error_no_register;\n\n\tif (chip->quirk_flags & QUIRK_FLAG_SHARE_MEDIA_DEVICE) {\n\t\t \n\t\tsnd_media_device_create(chip, intf);\n\t}\n\n\tif (quirk)\n\t\tchip->quirk_type = quirk->type;\n\n\tusb_chip[chip->index] = chip;\n\tchip->intf[chip->num_interfaces] = intf;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\t \n\tif (chip)\n\t\ttry_to_register_card(chip, ifnum);\n\n __error_no_register:\n\tif (chip) {\n\t\t \n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\n \nstatic void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == USB_AUDIO_IFACE_UNUSED)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t \n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t \n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t \n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t \n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\tsnd_usb_midi_v2_disconnect_all(chip);\n\t\t \n\t\tsnd_media_device_delete(chip);\n\n\t\t \n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tif (chip->quirk_flags & QUIRK_FLAG_DISABLE_AUTOSUSPEND)\n\t\tusb_enable_autosuspend(interface_to_usbdev(intf));\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}\n\n \nint snd_usb_lock_shutdown(struct snd_usb_audio *chip)\n{\n\tint err;\n\n\tatomic_inc(&chip->usage_count);\n\tif (atomic_read(&chip->shutdown)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\terr = snd_usb_autoresume(chip);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n\treturn err;\n}\n\n \nvoid snd_usb_unlock_shutdown(struct snd_usb_audio *chip)\n{\n\tsnd_usb_autosuspend(chip);\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n}\n\nint snd_usb_autoresume(struct snd_usb_audio *chip)\n{\n\tint i, err;\n\n\tif (atomic_read(&chip->shutdown))\n\t\treturn -EIO;\n\tif (atomic_inc_return(&chip->active) != 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < chip->num_interfaces; i++) {\n\t\terr = usb_autopm_get_interface(chip->intf[i]);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\twhile (--i >= 0)\n\t\t\t\tusb_autopm_put_interface(chip->intf[i]);\n\t\t\tatomic_dec(&chip->active);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid snd_usb_autosuspend(struct snd_usb_audio *chip)\n{\n\tint i;\n\n\tif (atomic_read(&chip->shutdown))\n\t\treturn;\n\tif (!atomic_dec_and_test(&chip->active))\n\t\treturn;\n\n\tfor (i = 0; i < chip->num_interfaces; i++)\n\t\tusb_autopm_put_interface(chip->intf[i]);\n}\n\nstatic int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct snd_usb_endpoint *ep;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\n\tif (chip == USB_AUDIO_IFACE_UNUSED)\n\t\treturn 0;\n\n\tif (!chip->num_suspended_intf++) {\n\t\tlist_for_each_entry(as, &chip->pcm_list, list)\n\t\t\tsnd_usb_pcm_suspend(as);\n\t\tlist_for_each_entry(ep, &chip->ep_list, list)\n\t\t\tsnd_usb_endpoint_suspend(ep);\n\t\tlist_for_each(p, &chip->midi_list)\n\t\t\tsnd_usbmidi_suspend(p);\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list)\n\t\t\tsnd_usb_mixer_suspend(mixer);\n\t\tsnd_usb_midi_v2_suspend_all(chip);\n\t}\n\n\tif (!PMSG_IS_AUTO(message) && !chip->system_suspend) {\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\t\tchip->system_suspend = chip->num_suspended_intf;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_audio_resume(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == USB_AUDIO_IFACE_UNUSED)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active);  \n\tif (chip->num_suspended_intf > 1)\n\t\tgoto out;\n\n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\terr = snd_usb_pcm_resume(as);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tsnd_usb_midi_v2_resume_all(chip);\n\n out:\n\tif (chip->num_suspended_intf == chip->system_suspend) {\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\t\tchip->system_suspend = 0;\n\t}\n\tchip->num_suspended_intf--;\n\nerr_out:\n\tatomic_dec(&chip->active);  \n\treturn err;\n}\n\nstatic const struct usb_device_id usb_audio_ids [] = {\n#include \"quirks-table.h\"\n    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),\n      .bInterfaceClass = USB_CLASS_AUDIO,\n      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },\n    { }\t\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, usb_audio_ids);\n\n \n\nstatic struct usb_driver usb_audio_driver = {\n\t.name =\t\t\"snd-usb-audio\",\n\t.probe =\tusb_audio_probe,\n\t.disconnect =\tusb_audio_disconnect,\n\t.suspend =\tusb_audio_suspend,\n\t.resume =\tusb_audio_resume,\n\t.reset_resume =\tusb_audio_resume,\n\t.id_table =\tusb_audio_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usb_audio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}