{
  "module_name": "comm.c",
  "hash_id": "2f90798baab3b8b92d0acf2a6f0795d0ff66efe1a232587cbf526ab0ea5fb99f",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/comm.c",
  "human_readable_source": "\n \n\n#include \"comm.h\"\n#include \"chip.h\"\n#include \"midi.h\"\n\nenum {\n\tCOMM_EP = 1,\n\tCOMM_FPGA_EP = 2\n};\n\nstatic void usb6fire_comm_init_urb(struct comm_runtime *rt, struct urb *urb,\n\t\tu8 *buffer, void *context, void(*handler)(struct urb *urb))\n{\n\tusb_init_urb(urb);\n\turb->transfer_buffer = buffer;\n\turb->pipe = usb_sndintpipe(rt->chip->dev, COMM_EP);\n\turb->complete = handler;\n\turb->context = context;\n\turb->interval = 1;\n\turb->dev = rt->chip->dev;\n}\n\nstatic void usb6fire_comm_receiver_handler(struct urb *urb)\n{\n\tstruct comm_runtime *rt = urb->context;\n\tstruct midi_runtime *midi_rt = rt->chip->midi;\n\n\tif (!urb->status) {\n\t\tif (rt->receiver_buffer[0] == 0x10)  \n\t\t\tif (midi_rt)\n\t\t\t\tmidi_rt->in_received(midi_rt,\n\t\t\t\t\t\trt->receiver_buffer + 2,\n\t\t\t\t\t\trt->receiver_buffer[1]);\n\t}\n\n\tif (!rt->chip->shutdown) {\n\t\turb->status = 0;\n\t\turb->actual_length = 0;\n\t\tif (usb_submit_urb(urb, GFP_ATOMIC) < 0)\n\t\t\tdev_warn(&urb->dev->dev,\n\t\t\t\t\t\"comm data receiver aborted.\\n\");\n\t}\n}\n\nstatic void usb6fire_comm_init_buffer(u8 *buffer, u8 id, u8 request,\n\t\tu8 reg, u8 vl, u8 vh)\n{\n\tbuffer[0] = 0x01;\n\tbuffer[2] = request;\n\tbuffer[3] = id;\n\tswitch (request) {\n\tcase 0x02:\n\t\tbuffer[1] = 0x05;  \n\t\tbuffer[4] = reg;\n\t\tbuffer[5] = vl;\n\t\tbuffer[6] = vh;\n\t\tbreak;\n\n\tcase 0x12:\n\t\tbuffer[1] = 0x0b;  \n\t\tbuffer[4] = 0x00;\n\t\tbuffer[5] = 0x18;\n\t\tbuffer[6] = 0x05;\n\t\tbuffer[7] = 0x00;\n\t\tbuffer[8] = 0x01;\n\t\tbuffer[9] = 0x00;\n\t\tbuffer[10] = 0x9e;\n\t\tbuffer[11] = reg;\n\t\tbuffer[12] = vl;\n\t\tbreak;\n\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0x22:\n\t\tbuffer[1] = 0x04;\n\t\tbuffer[4] = reg;\n\t\tbuffer[5] = vl;\n\t\tbreak;\n\t}\n}\n\nstatic int usb6fire_comm_send_buffer(u8 *buffer, struct usb_device *dev)\n{\n\tint ret;\n\tint actual_len;\n\n\tret = usb_interrupt_msg(dev, usb_sndintpipe(dev, COMM_EP),\n\t\t\tbuffer, buffer[1] + 2, &actual_len, 1000);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (actual_len != buffer[1] + 2)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int usb6fire_comm_write8(struct comm_runtime *rt, u8 request,\n\t\tu8 reg, u8 value)\n{\n\tu8 *buffer;\n\tint ret;\n\n\t \n\tbuffer = kmalloc(13, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tusb6fire_comm_init_buffer(buffer, 0x00, request, reg, value, 0x00);\n\tret = usb6fire_comm_send_buffer(buffer, rt->chip->dev);\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int usb6fire_comm_write16(struct comm_runtime *rt, u8 request,\n\t\tu8 reg, u8 vl, u8 vh)\n{\n\tu8 *buffer;\n\tint ret;\n\n\t \n\tbuffer = kmalloc(13, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tusb6fire_comm_init_buffer(buffer, 0x00, request, reg, vl, vh);\n\tret = usb6fire_comm_send_buffer(buffer, rt->chip->dev);\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nint usb6fire_comm_init(struct sfire_chip *chip)\n{\n\tstruct comm_runtime *rt = kzalloc(sizeof(struct comm_runtime),\n\t\t\tGFP_KERNEL);\n\tstruct urb *urb;\n\tint ret;\n\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->receiver_buffer = kzalloc(COMM_RECEIVER_BUFSIZE, GFP_KERNEL);\n\tif (!rt->receiver_buffer) {\n\t\tkfree(rt);\n\t\treturn -ENOMEM;\n\t}\n\n\turb = &rt->receiver;\n\trt->serial = 1;\n\trt->chip = chip;\n\tusb_init_urb(urb);\n\trt->init_urb = usb6fire_comm_init_urb;\n\trt->write8 = usb6fire_comm_write8;\n\trt->write16 = usb6fire_comm_write16;\n\n\t \n\turb->transfer_buffer = rt->receiver_buffer;\n\turb->transfer_buffer_length = COMM_RECEIVER_BUFSIZE;\n\turb->pipe = usb_rcvintpipe(chip->dev, COMM_EP);\n\turb->dev = chip->dev;\n\turb->complete = usb6fire_comm_receiver_handler;\n\turb->context = rt;\n\turb->interval = 1;\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(rt->receiver_buffer);\n\t\tkfree(rt);\n\t\tdev_err(&chip->dev->dev, \"cannot create comm data receiver.\");\n\t\treturn ret;\n\t}\n\tchip->comm = rt;\n\treturn 0;\n}\n\nvoid usb6fire_comm_abort(struct sfire_chip *chip)\n{\n\tstruct comm_runtime *rt = chip->comm;\n\n\tif (rt)\n\t\tusb_poison_urb(&rt->receiver);\n}\n\nvoid usb6fire_comm_destroy(struct sfire_chip *chip)\n{\n\tstruct comm_runtime *rt = chip->comm;\n\n\tkfree(rt->receiver_buffer);\n\tkfree(rt);\n\tchip->comm = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}