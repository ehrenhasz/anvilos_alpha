{
  "module_name": "chip.c",
  "hash_id": "c849f4d508f9dfbdea3f9e6afc978d8bc575cc7520b501a481ba44a79d53999c",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/chip.c",
  "human_readable_source": "\n \n\n#include \"chip.h\"\n#include \"firmware.h\"\n#include \"pcm.h\"\n#include \"control.h\"\n#include \"comm.h\"\n#include \"midi.h\"\n\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Torsten Schenk <torsten.schenk@zoho.com>\");\nMODULE_DESCRIPTION(\"TerraTec DMX 6Fire USB audio driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;  \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;  \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;  \nstatic struct sfire_chip *chips[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;\nstatic struct usb_device *devices[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the 6fire sound device\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the 6fire sound device.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable the 6fire sound device.\");\n\nstatic DEFINE_MUTEX(register_mutex);\n\nstatic void usb6fire_chip_abort(struct sfire_chip *chip)\n{\n\tif (chip) {\n\t\tif (chip->pcm)\n\t\t\tusb6fire_pcm_abort(chip);\n\t\tif (chip->midi)\n\t\t\tusb6fire_midi_abort(chip);\n\t\tif (chip->comm)\n\t\t\tusb6fire_comm_abort(chip);\n\t\tif (chip->control)\n\t\t\tusb6fire_control_abort(chip);\n\t\tif (chip->card) {\n\t\t\tsnd_card_disconnect(chip->card);\n\t\t\tsnd_card_free_when_closed(chip->card);\n\t\t\tchip->card = NULL;\n\t\t}\n\t}\n}\n\nstatic void usb6fire_chip_destroy(struct sfire_chip *chip)\n{\n\tif (chip) {\n\t\tif (chip->pcm)\n\t\t\tusb6fire_pcm_destroy(chip);\n\t\tif (chip->midi)\n\t\t\tusb6fire_midi_destroy(chip);\n\t\tif (chip->comm)\n\t\t\tusb6fire_comm_destroy(chip);\n\t\tif (chip->control)\n\t\t\tusb6fire_control_destroy(chip);\n\t\tif (chip->card)\n\t\t\tsnd_card_free(chip->card);\n\t}\n}\n\nstatic int usb6fire_chip_probe(struct usb_interface *intf,\n\t\t\t       const struct usb_device_id *usb_id)\n{\n\tint ret;\n\tint i;\n\tstruct sfire_chip *chip = NULL;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tint regidx = -1;  \n\tstruct snd_card *card = NULL;\n\n\t \n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (devices[i] == device) {\n\t\t\tif (chips[i])\n\t\t\t\tchips[i]->intf_count++;\n\t\t\tusb_set_intfdata(intf, chips[i]);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn 0;\n\t\t} else if (!devices[i] && regidx < 0)\n\t\t\tregidx = i;\n\t}\n\tif (regidx < 0) {\n\t\tmutex_unlock(&register_mutex);\n\t\tdev_err(&intf->dev, \"too many cards registered.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdevices[regidx] = device;\n\tmutex_unlock(&register_mutex);\n\n\t \n\tret = usb6fire_fw_init(intf);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FW_NOT_READY)  \n\t\treturn 0;\n\n\t \n\tif (usb_set_interface(device, 0, 0) != 0) {\n\t\tdev_err(&intf->dev, \"can't set first interface.\\n\");\n\t\treturn -EIO;\n\t}\n\tret = snd_card_new(&intf->dev, index[regidx], id[regidx],\n\t\t\t   THIS_MODULE, sizeof(struct sfire_chip), &card);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"cannot create alsa card.\\n\");\n\t\treturn ret;\n\t}\n\tstrcpy(card->driver, \"6FireUSB\");\n\tstrcpy(card->shortname, \"TerraTec DMX6FireUSB\");\n\tsprintf(card->longname, \"%s at %d:%d\", card->shortname,\n\t\t\tdevice->bus->busnum, device->devnum);\n\n\tchip = card->private_data;\n\tchips[regidx] = chip;\n\tchip->dev = device;\n\tchip->regidx = regidx;\n\tchip->intf_count = 1;\n\tchip->card = card;\n\n\tret = usb6fire_comm_init(chip);\n\tif (ret < 0)\n\t\tgoto destroy_chip;\n\n\tret = usb6fire_midi_init(chip);\n\tif (ret < 0)\n\t\tgoto destroy_chip;\n\n\tret = usb6fire_pcm_init(chip);\n\tif (ret < 0)\n\t\tgoto destroy_chip;\n\n\tret = usb6fire_control_init(chip);\n\tif (ret < 0)\n\t\tgoto destroy_chip;\n\n\tret = snd_card_register(card);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"cannot register card.\");\n\t\tgoto destroy_chip;\n\t}\n\tusb_set_intfdata(intf, chip);\n\treturn 0;\n\ndestroy_chip:\n\tusb6fire_chip_destroy(chip);\n\treturn ret;\n}\n\nstatic void usb6fire_chip_disconnect(struct usb_interface *intf)\n{\n\tstruct sfire_chip *chip;\n\n\tchip = usb_get_intfdata(intf);\n\tif (chip) {  \n\t\tchip->intf_count--;\n\t\tif (!chip->intf_count) {\n\t\t\tmutex_lock(&register_mutex);\n\t\t\tdevices[chip->regidx] = NULL;\n\t\t\tchips[chip->regidx] = NULL;\n\t\t\tmutex_unlock(&register_mutex);\n\n\t\t\tchip->shutdown = true;\n\t\t\tusb6fire_chip_abort(chip);\n\t\t\tusb6fire_chip_destroy(chip);\n\t\t}\n\t}\n}\n\nstatic const struct usb_device_id device_table[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE,\n\t\t.idVendor = 0x0ccd,\n\t\t.idProduct = 0x0080\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\nstatic struct usb_driver usb_driver = {\n\t.name = \"snd-usb-6fire\",\n\t.probe = usb6fire_chip_probe,\n\t.disconnect = usb6fire_chip_disconnect,\n\t.id_table = device_table,\n};\n\nmodule_usb_driver(usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}