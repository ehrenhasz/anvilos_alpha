{
  "module_name": "pcm.c",
  "hash_id": "9c6d8f51d1938dcfddacd1c08a4c0e98613f27361592adf64d866d91a2668cc2",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/pcm.c",
  "human_readable_source": "\n \n\n#include \"pcm.h\"\n#include \"chip.h\"\n#include \"comm.h\"\n#include \"control.h\"\n\nenum {\n\tOUT_N_CHANNELS = 6, IN_N_CHANNELS = 4\n};\n\n \nstatic const int rates_in_packet_size[] = { 228, 228, 420, 420, 404, 404 };\nstatic const int rates_out_packet_size[] = { 228, 228, 420, 420, 604, 604 };\nstatic const int rates[] = { 44100, 48000, 88200, 96000, 176400, 192000 };\nstatic const int rates_alsaid[] = {\n\tSNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_48000,\n\tSNDRV_PCM_RATE_88200, SNDRV_PCM_RATE_96000,\n\tSNDRV_PCM_RATE_176400, SNDRV_PCM_RATE_192000 };\n\nenum {  \n\tOUT_EP = 6, IN_EP = 2, MAX_BUFSIZE = 128 * 1024\n};\n\nenum {  \n\tSTREAM_DISABLED,  \n\tSTREAM_STARTING,  \n\tSTREAM_RUNNING,  \n\tSTREAM_STOPPING\n};\n\nstatic const struct snd_pcm_hardware pcm_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\n\t.rates = SNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000 |\n\t\tSNDRV_PCM_RATE_88200 |\n\t\tSNDRV_PCM_RATE_96000 |\n\t\tSNDRV_PCM_RATE_176400 |\n\t\tSNDRV_PCM_RATE_192000,\n\n\t.rate_min = 44100,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = 0,  \n\t.buffer_bytes_max = MAX_BUFSIZE,\n\t.period_bytes_min = PCM_N_PACKETS_PER_URB * (PCM_MAX_PACKET_SIZE - 4),\n\t.period_bytes_max = MAX_BUFSIZE,\n\t.periods_min = 2,\n\t.periods_max = 1024\n};\n\nstatic int usb6fire_pcm_set_rate(struct pcm_runtime *rt)\n{\n\tint ret;\n\tstruct control_runtime *ctrl_rt = rt->chip->control;\n\n\tctrl_rt->usb_streaming = false;\n\tret = ctrl_rt->update_streaming(ctrl_rt);\n\tif (ret < 0) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"error stopping streaming while setting samplerate %d.\\n\",\n\t\t\trates[rt->rate]);\n\t\treturn ret;\n\t}\n\n\tret = ctrl_rt->set_rate(ctrl_rt, rt->rate);\n\tif (ret < 0) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"error setting samplerate %d.\\n\",\n\t\t\trates[rt->rate]);\n\t\treturn ret;\n\t}\n\n\tret = ctrl_rt->set_channels(ctrl_rt, OUT_N_CHANNELS, IN_N_CHANNELS,\n\t\t\tfalse, false);\n\tif (ret < 0) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"error initializing channels while setting samplerate %d.\\n\",\n\t\t\trates[rt->rate]);\n\t\treturn ret;\n\t}\n\n\tctrl_rt->usb_streaming = true;\n\tret = ctrl_rt->update_streaming(ctrl_rt);\n\tif (ret < 0) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"error starting streaming while setting samplerate %d.\\n\",\n\t\t\trates[rt->rate]);\n\t\treturn ret;\n\t}\n\n\trt->in_n_analog = IN_N_CHANNELS;\n\trt->out_n_analog = OUT_N_CHANNELS;\n\trt->in_packet_size = rates_in_packet_size[rt->rate];\n\trt->out_packet_size = rates_out_packet_size[rt->rate];\n\treturn 0;\n}\n\nstatic struct pcm_substream *usb6fire_pcm_get_substream(\n\t\tstruct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\n\tif (alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn &rt->playback;\n\telse if (alsa_sub->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn &rt->capture;\n\tdev_err(&rt->chip->dev->dev, \"error getting pcm substream slot.\\n\");\n\treturn NULL;\n}\n\n \nstatic void usb6fire_pcm_stream_stop(struct pcm_runtime *rt)\n{\n\tint i;\n\tstruct control_runtime *ctrl_rt = rt->chip->control;\n\n\tif (rt->stream_state != STREAM_DISABLED) {\n\n\t\trt->stream_state = STREAM_STOPPING;\n\n\t\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\t\tusb_kill_urb(&rt->in_urbs[i].instance);\n\t\t\tusb_kill_urb(&rt->out_urbs[i].instance);\n\t\t}\n\t\tctrl_rt->usb_streaming = false;\n\t\tctrl_rt->update_streaming(ctrl_rt);\n\t\trt->stream_state = STREAM_DISABLED;\n\t}\n}\n\n \nstatic int usb6fire_pcm_stream_start(struct pcm_runtime *rt)\n{\n\tint ret;\n\tint i;\n\tint k;\n\tstruct usb_iso_packet_descriptor *packet;\n\n\tif (rt->stream_state == STREAM_DISABLED) {\n\t\t \n\t\trt->stream_wait_cond = false;\n\t\trt->stream_state = STREAM_STARTING;\n\t\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\t\tfor (k = 0; k < PCM_N_PACKETS_PER_URB; k++) {\n\t\t\t\tpacket = &rt->in_urbs[i].packets[k];\n\t\t\t\tpacket->offset = k * rt->in_packet_size;\n\t\t\t\tpacket->length = rt->in_packet_size;\n\t\t\t\tpacket->actual_length = 0;\n\t\t\t\tpacket->status = 0;\n\t\t\t}\n\t\t\tret = usb_submit_urb(&rt->in_urbs[i].instance,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (ret) {\n\t\t\t\tusb6fire_pcm_stream_stop(rt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twait_event_timeout(rt->stream_wait_queue, rt->stream_wait_cond,\n\t\t\t\tHZ);\n\t\tif (rt->stream_wait_cond)\n\t\t\trt->stream_state = STREAM_RUNNING;\n\t\telse {\n\t\t\tusb6fire_pcm_stream_stop(rt);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void usb6fire_pcm_capture(struct pcm_substream *sub, struct pcm_urb *urb)\n{\n\tint i;\n\tint frame;\n\tint frame_count;\n\tunsigned int total_length = 0;\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(sub->instance);\n\tstruct snd_pcm_runtime *alsa_rt = sub->instance->runtime;\n\tu32 *src = NULL;\n\tu32 *dest = (u32 *) (alsa_rt->dma_area + sub->dma_off\n\t\t\t* (alsa_rt->frame_bits >> 3));\n\tu32 *dest_end = (u32 *) (alsa_rt->dma_area + alsa_rt->buffer_size\n\t\t\t* (alsa_rt->frame_bits >> 3));\n\tint bytes_per_frame = alsa_rt->channels << 2;\n\n\tfor (i = 0; i < PCM_N_PACKETS_PER_URB; i++) {\n\t\t \n\t\tif (urb->packets[i].actual_length > 4)\n\t\t\tframe_count = (urb->packets[i].actual_length - 4)\n\t\t\t\t\t/ (rt->in_n_analog << 2);\n\t\telse\n\t\t\tframe_count = 0;\n\n\t\tif (alsa_rt->format == SNDRV_PCM_FORMAT_S24_LE)\n\t\t\tsrc = (u32 *) (urb->buffer + total_length);\n\t\telse if (alsa_rt->format == SNDRV_PCM_FORMAT_S32_LE)\n\t\t\tsrc = (u32 *) (urb->buffer - 1 + total_length);\n\t\telse\n\t\t\treturn;\n\t\tsrc++;  \n\t\ttotal_length += urb->packets[i].length;\n\t\tfor (frame = 0; frame < frame_count; frame++) {\n\t\t\tmemcpy(dest, src, bytes_per_frame);\n\t\t\tdest += alsa_rt->channels;\n\t\t\tsrc += rt->in_n_analog;\n\t\t\tsub->dma_off++;\n\t\t\tsub->period_off++;\n\t\t\tif (dest == dest_end) {\n\t\t\t\tsub->dma_off = 0;\n\t\t\t\tdest = (u32 *) alsa_rt->dma_area;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void usb6fire_pcm_playback(struct pcm_substream *sub,\n\t\tstruct pcm_urb *urb)\n{\n\tint i;\n\tint frame;\n\tint frame_count;\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(sub->instance);\n\tstruct snd_pcm_runtime *alsa_rt = sub->instance->runtime;\n\tu32 *src = (u32 *) (alsa_rt->dma_area + sub->dma_off\n\t\t\t* (alsa_rt->frame_bits >> 3));\n\tu32 *src_end = (u32 *) (alsa_rt->dma_area + alsa_rt->buffer_size\n\t\t\t* (alsa_rt->frame_bits >> 3));\n\tu32 *dest;\n\tint bytes_per_frame = alsa_rt->channels << 2;\n\n\tif (alsa_rt->format == SNDRV_PCM_FORMAT_S32_LE)\n\t\tdest = (u32 *) (urb->buffer - 1);\n\telse if (alsa_rt->format == SNDRV_PCM_FORMAT_S24_LE)\n\t\tdest = (u32 *) (urb->buffer);\n\telse {\n\t\tdev_err(&rt->chip->dev->dev, \"Unknown sample format.\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < PCM_N_PACKETS_PER_URB; i++) {\n\t\t \n\t\tif (urb->packets[i].length > 4)\n\t\t\tframe_count = (urb->packets[i].length - 4)\n\t\t\t\t\t/ (rt->out_n_analog << 2);\n\t\telse\n\t\t\tframe_count = 0;\n\t\tdest++;  \n\t\tfor (frame = 0; frame < frame_count; frame++) {\n\t\t\tmemcpy(dest, src, bytes_per_frame);\n\t\t\tsrc += alsa_rt->channels;\n\t\t\tdest += rt->out_n_analog;\n\t\t\tsub->dma_off++;\n\t\t\tsub->period_off++;\n\t\t\tif (src == src_end) {\n\t\t\t\tsrc = (u32 *) alsa_rt->dma_area;\n\t\t\t\tsub->dma_off = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void usb6fire_pcm_in_urb_handler(struct urb *usb_urb)\n{\n\tstruct pcm_urb *in_urb = usb_urb->context;\n\tstruct pcm_urb *out_urb = in_urb->peer;\n\tstruct pcm_runtime *rt = in_urb->chip->pcm;\n\tstruct pcm_substream *sub;\n\tunsigned long flags;\n\tint total_length = 0;\n\tint frame_count;\n\tint frame;\n\tint channel;\n\tint i;\n\tu8 *dest;\n\n\tif (usb_urb->status || rt->panic || rt->stream_state == STREAM_STOPPING)\n\t\treturn;\n\tfor (i = 0; i < PCM_N_PACKETS_PER_URB; i++)\n\t\tif (in_urb->packets[i].status) {\n\t\t\trt->panic = true;\n\t\t\treturn;\n\t\t}\n\n\tif (rt->stream_state == STREAM_DISABLED) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"internal error: stream disabled in in-urb handler.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsub = &rt->capture;\n\tspin_lock_irqsave(&sub->lock, flags);\n\tif (sub->active) {\n\t\tusb6fire_pcm_capture(sub, in_urb);\n\t\tif (sub->period_off >= sub->instance->runtime->period_size) {\n\t\t\tsub->period_off %= sub->instance->runtime->period_size;\n\t\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t\t\tsnd_pcm_period_elapsed(sub->instance);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t} else\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\t \n\tfor (i = 0; i < PCM_N_PACKETS_PER_URB; i++) {\n\t\tout_urb->packets[i].offset = total_length;\n\t\tout_urb->packets[i].length = (in_urb->packets[i].actual_length\n\t\t\t\t- 4) / (rt->in_n_analog << 2)\n\t\t\t\t* (rt->out_n_analog << 2) + 4;\n\t\tout_urb->packets[i].status = 0;\n\t\ttotal_length += out_urb->packets[i].length;\n\t}\n\tmemset(out_urb->buffer, 0, total_length);\n\n\t \n\tsub = &rt->playback;\n\tspin_lock_irqsave(&sub->lock, flags);\n\tif (sub->active) {\n\t\tusb6fire_pcm_playback(sub, out_urb);\n\t\tif (sub->period_off >= sub->instance->runtime->period_size) {\n\t\t\tsub->period_off %= sub->instance->runtime->period_size;\n\t\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t\t\tsnd_pcm_period_elapsed(sub->instance);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t} else\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\t \n\tdest = out_urb->buffer;\n\tfor (i = 0; i < PCM_N_PACKETS_PER_URB; i++)\n\t\tif (out_urb->packets[i].length >= 4) {\n\t\t\tframe_count = (out_urb->packets[i].length - 4)\n\t\t\t\t\t/ (rt->out_n_analog << 2);\n\t\t\t*(dest++) = 0xaa;\n\t\t\t*(dest++) = 0xaa;\n\t\t\t*(dest++) = frame_count;\n\t\t\t*(dest++) = 0x00;\n\t\t\tfor (frame = 0; frame < frame_count; frame++)\n\t\t\t\tfor (channel = 0;\n\t\t\t\t\t\tchannel < rt->out_n_analog;\n\t\t\t\t\t\tchannel++) {\n\t\t\t\t\tdest += 3;  \n\t\t\t\t\t*(dest++) = 0x40;\n\t\t\t\t}\n\t\t}\n\tusb_submit_urb(&out_urb->instance, GFP_ATOMIC);\n\tusb_submit_urb(&in_urb->instance, GFP_ATOMIC);\n}\n\nstatic void usb6fire_pcm_out_urb_handler(struct urb *usb_urb)\n{\n\tstruct pcm_urb *urb = usb_urb->context;\n\tstruct pcm_runtime *rt = urb->chip->pcm;\n\n\tif (rt->stream_state == STREAM_STARTING) {\n\t\trt->stream_wait_cond = true;\n\t\twake_up(&rt->stream_wait_queue);\n\t}\n}\n\nstatic int usb6fire_pcm_open(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = NULL;\n\tstruct snd_pcm_runtime *alsa_rt = alsa_sub->runtime;\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\n\tmutex_lock(&rt->stream_mutex);\n\talsa_rt->hw = pcm_hw;\n\n\tif (alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (rt->rate < ARRAY_SIZE(rates))\n\t\t\talsa_rt->hw.rates = rates_alsaid[rt->rate];\n\t\talsa_rt->hw.channels_max = OUT_N_CHANNELS;\n\t\tsub = &rt->playback;\n\t} else if (alsa_sub->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tif (rt->rate < ARRAY_SIZE(rates))\n\t\t\talsa_rt->hw.rates = rates_alsaid[rt->rate];\n\t\talsa_rt->hw.channels_max = IN_N_CHANNELS;\n\t\tsub = &rt->capture;\n\t}\n\n\tif (!sub) {\n\t\tmutex_unlock(&rt->stream_mutex);\n\t\tdev_err(&rt->chip->dev->dev, \"invalid stream type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsub->instance = alsa_sub;\n\tsub->active = false;\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int usb6fire_pcm_close(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = usb6fire_pcm_get_substream(alsa_sub);\n\tunsigned long flags;\n\n\tif (rt->panic)\n\t\treturn 0;\n\n\tmutex_lock(&rt->stream_mutex);\n\tif (sub) {\n\t\t \n\t\tspin_lock_irqsave(&sub->lock, flags);\n\t\tsub->instance = NULL;\n\t\tsub->active = false;\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\n\t\t \n\t\tif (!rt->playback.instance && !rt->capture.instance) {\n\t\t\tusb6fire_pcm_stream_stop(rt);\n\t\t\trt->rate = ARRAY_SIZE(rates);\n\t\t}\n\t}\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int usb6fire_pcm_prepare(struct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tstruct pcm_substream *sub = usb6fire_pcm_get_substream(alsa_sub);\n\tstruct snd_pcm_runtime *alsa_rt = alsa_sub->runtime;\n\tint ret;\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\tif (!sub)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&rt->stream_mutex);\n\tsub->dma_off = 0;\n\tsub->period_off = 0;\n\n\tif (rt->stream_state == STREAM_DISABLED) {\n\t\tfor (rt->rate = 0; rt->rate < ARRAY_SIZE(rates); rt->rate++)\n\t\t\tif (alsa_rt->rate == rates[rt->rate])\n\t\t\t\tbreak;\n\t\tif (rt->rate == ARRAY_SIZE(rates)) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\t\"invalid rate %d in prepare.\\n\",\n\t\t\t\talsa_rt->rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = usb6fire_pcm_set_rate(rt);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tret = usb6fire_pcm_stream_start(rt);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&rt->stream_mutex);\n\t\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\t\"could not start pcm stream.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&rt->stream_mutex);\n\treturn 0;\n}\n\nstatic int usb6fire_pcm_trigger(struct snd_pcm_substream *alsa_sub, int cmd)\n{\n\tstruct pcm_substream *sub = usb6fire_pcm_get_substream(alsa_sub);\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tunsigned long flags;\n\n\tif (rt->panic)\n\t\treturn -EPIPE;\n\tif (!sub)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&sub->lock, flags);\n\t\tsub->active = true;\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&sub->lock, flags);\n\t\tsub->active = false;\n\t\tspin_unlock_irqrestore(&sub->lock, flags);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic snd_pcm_uframes_t usb6fire_pcm_pointer(\n\t\tstruct snd_pcm_substream *alsa_sub)\n{\n\tstruct pcm_substream *sub = usb6fire_pcm_get_substream(alsa_sub);\n\tstruct pcm_runtime *rt = snd_pcm_substream_chip(alsa_sub);\n\tunsigned long flags;\n\tsnd_pcm_uframes_t ret;\n\n\tif (rt->panic || !sub)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\n\tspin_lock_irqsave(&sub->lock, flags);\n\tret = sub->dma_off;\n\tspin_unlock_irqrestore(&sub->lock, flags);\n\treturn ret;\n}\n\nstatic const struct snd_pcm_ops pcm_ops = {\n\t.open = usb6fire_pcm_open,\n\t.close = usb6fire_pcm_close,\n\t.prepare = usb6fire_pcm_prepare,\n\t.trigger = usb6fire_pcm_trigger,\n\t.pointer = usb6fire_pcm_pointer,\n};\n\nstatic void usb6fire_pcm_init_urb(struct pcm_urb *urb,\n\t\t\t\t  struct sfire_chip *chip, bool in, int ep,\n\t\t\t\t  void (*handler)(struct urb *))\n{\n\turb->chip = chip;\n\tusb_init_urb(&urb->instance);\n\turb->instance.transfer_buffer = urb->buffer;\n\turb->instance.transfer_buffer_length =\n\t\t\tPCM_N_PACKETS_PER_URB * PCM_MAX_PACKET_SIZE;\n\turb->instance.dev = chip->dev;\n\turb->instance.pipe = in ? usb_rcvisocpipe(chip->dev, ep)\n\t\t\t: usb_sndisocpipe(chip->dev, ep);\n\turb->instance.interval = 1;\n\turb->instance.complete = handler;\n\turb->instance.context = urb;\n\turb->instance.number_of_packets = PCM_N_PACKETS_PER_URB;\n}\n\nstatic int usb6fire_pcm_buffers_init(struct pcm_runtime *rt)\n{\n\tint i;\n\n\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\trt->out_urbs[i].buffer = kcalloc(PCM_MAX_PACKET_SIZE,\n\t\t\t\t\t\t PCM_N_PACKETS_PER_URB,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!rt->out_urbs[i].buffer)\n\t\t\treturn -ENOMEM;\n\t\trt->in_urbs[i].buffer = kcalloc(PCM_MAX_PACKET_SIZE,\n\t\t\t\t\t\tPCM_N_PACKETS_PER_URB,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!rt->in_urbs[i].buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void usb6fire_pcm_buffers_destroy(struct pcm_runtime *rt)\n{\n\tint i;\n\n\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\tkfree(rt->out_urbs[i].buffer);\n\t\tkfree(rt->in_urbs[i].buffer);\n\t}\n}\n\nint usb6fire_pcm_init(struct sfire_chip *chip)\n{\n\tint i;\n\tint ret;\n\tstruct snd_pcm *pcm;\n\tstruct pcm_runtime *rt =\n\t\t\tkzalloc(sizeof(struct pcm_runtime), GFP_KERNEL);\n\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\tret = usb6fire_pcm_buffers_init(rt);\n\tif (ret) {\n\t\tusb6fire_pcm_buffers_destroy(rt);\n\t\tkfree(rt);\n\t\treturn ret;\n\t}\n\n\trt->chip = chip;\n\trt->stream_state = STREAM_DISABLED;\n\trt->rate = ARRAY_SIZE(rates);\n\tinit_waitqueue_head(&rt->stream_wait_queue);\n\tmutex_init(&rt->stream_mutex);\n\n\tspin_lock_init(&rt->playback.lock);\n\tspin_lock_init(&rt->capture.lock);\n\n\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\tusb6fire_pcm_init_urb(&rt->in_urbs[i], chip, true, IN_EP,\n\t\t\t\tusb6fire_pcm_in_urb_handler);\n\t\tusb6fire_pcm_init_urb(&rt->out_urbs[i], chip, false, OUT_EP,\n\t\t\t\tusb6fire_pcm_out_urb_handler);\n\n\t\trt->in_urbs[i].peer = &rt->out_urbs[i];\n\t\trt->out_urbs[i].peer = &rt->in_urbs[i];\n\t}\n\n\tret = snd_pcm_new(chip->card, \"DMX6FireUSB\", 0, 1, 1, &pcm);\n\tif (ret < 0) {\n\t\tusb6fire_pcm_buffers_destroy(rt);\n\t\tkfree(rt);\n\t\tdev_err(&chip->dev->dev, \"cannot create pcm instance.\\n\");\n\t\treturn ret;\n\t}\n\n\tpcm->private_data = rt;\n\tstrcpy(pcm->name, \"DMX 6Fire USB\");\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\trt->instance = pcm;\n\n\tchip->pcm = rt;\n\treturn 0;\n}\n\nvoid usb6fire_pcm_abort(struct sfire_chip *chip)\n{\n\tstruct pcm_runtime *rt = chip->pcm;\n\tint i;\n\n\tif (rt) {\n\t\trt->panic = true;\n\n\t\tif (rt->playback.instance)\n\t\t\tsnd_pcm_stop_xrun(rt->playback.instance);\n\n\t\tif (rt->capture.instance)\n\t\t\tsnd_pcm_stop_xrun(rt->capture.instance);\n\n\t\tfor (i = 0; i < PCM_N_URBS; i++) {\n\t\t\tusb_poison_urb(&rt->in_urbs[i].instance);\n\t\t\tusb_poison_urb(&rt->out_urbs[i].instance);\n\t\t}\n\n\t}\n}\n\nvoid usb6fire_pcm_destroy(struct sfire_chip *chip)\n{\n\tstruct pcm_runtime *rt = chip->pcm;\n\n\tusb6fire_pcm_buffers_destroy(rt);\n\tkfree(rt);\n\tchip->pcm = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}