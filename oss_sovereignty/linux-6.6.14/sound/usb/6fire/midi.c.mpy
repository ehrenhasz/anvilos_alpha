{
  "module_name": "midi.c",
  "hash_id": "d6e2c38705f88a999ce572d9067d3d1a7b8069598e39c64bd04dc9d305b30757",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/midi.c",
  "human_readable_source": "\n \n\n#include <sound/rawmidi.h>\n\n#include \"midi.h\"\n#include \"chip.h\"\n#include \"comm.h\"\n\nenum {\n\tMIDI_BUFSIZE = 64\n};\n\nstatic void usb6fire_midi_out_handler(struct urb *urb)\n{\n\tstruct midi_runtime *rt = urb->context;\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rt->out_lock, flags);\n\n\tif (rt->out) {\n\t\tret = snd_rawmidi_transmit(rt->out, rt->out_buffer + 4,\n\t\t\t\tMIDI_BUFSIZE - 4);\n\t\tif (ret > 0) {  \n\t\t\trt->out_buffer[1] = ret + 2;\n\t\t\trt->out_buffer[3] = rt->out_serial++;\n\t\t\turb->transfer_buffer_length = ret + 4;\n\n\t\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\t\"midi out urb submit failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t} else  \n\t\t\trt->out = NULL;\n\t}\n\tspin_unlock_irqrestore(&rt->out_lock, flags);\n}\n\nstatic void usb6fire_midi_in_received(\n\t\tstruct midi_runtime *rt, u8 *data, int length)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rt->in_lock, flags);\n\tif (rt->in)\n\t\tsnd_rawmidi_receive(rt->in, data, length);\n\tspin_unlock_irqrestore(&rt->in_lock, flags);\n}\n\nstatic int usb6fire_midi_out_open(struct snd_rawmidi_substream *alsa_sub)\n{\n\treturn 0;\n}\n\nstatic int usb6fire_midi_out_close(struct snd_rawmidi_substream *alsa_sub)\n{\n\treturn 0;\n}\n\nstatic void usb6fire_midi_out_trigger(\n\t\tstruct snd_rawmidi_substream *alsa_sub, int up)\n{\n\tstruct midi_runtime *rt = alsa_sub->rmidi->private_data;\n\tstruct urb *urb = &rt->out_urb;\n\t__s8 ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rt->out_lock, flags);\n\tif (up) {  \n\t\tif (rt->out) {  \n\t\t\tspin_unlock_irqrestore(&rt->out_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tret = snd_rawmidi_transmit(alsa_sub, rt->out_buffer + 4,\n\t\t\t\tMIDI_BUFSIZE - 4);\n\t\tif (ret > 0) {\n\t\t\trt->out_buffer[1] = ret + 2;\n\t\t\trt->out_buffer[3] = rt->out_serial++;\n\t\t\turb->transfer_buffer_length = ret + 4;\n\n\t\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\t\"midi out urb submit failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\telse\n\t\t\t\trt->out = alsa_sub;\n\t\t}\n\t} else if (rt->out == alsa_sub)\n\t\trt->out = NULL;\n\tspin_unlock_irqrestore(&rt->out_lock, flags);\n}\n\nstatic void usb6fire_midi_out_drain(struct snd_rawmidi_substream *alsa_sub)\n{\n\tstruct midi_runtime *rt = alsa_sub->rmidi->private_data;\n\tint retry = 0;\n\n\twhile (rt->out && retry++ < 100)\n\t\tmsleep(10);\n}\n\nstatic int usb6fire_midi_in_open(struct snd_rawmidi_substream *alsa_sub)\n{\n\treturn 0;\n}\n\nstatic int usb6fire_midi_in_close(struct snd_rawmidi_substream *alsa_sub)\n{\n\treturn 0;\n}\n\nstatic void usb6fire_midi_in_trigger(\n\t\tstruct snd_rawmidi_substream *alsa_sub, int up)\n{\n\tstruct midi_runtime *rt = alsa_sub->rmidi->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rt->in_lock, flags);\n\tif (up)\n\t\trt->in = alsa_sub;\n\telse\n\t\trt->in = NULL;\n\tspin_unlock_irqrestore(&rt->in_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops out_ops = {\n\t.open = usb6fire_midi_out_open,\n\t.close = usb6fire_midi_out_close,\n\t.trigger = usb6fire_midi_out_trigger,\n\t.drain = usb6fire_midi_out_drain\n};\n\nstatic const struct snd_rawmidi_ops in_ops = {\n\t.open = usb6fire_midi_in_open,\n\t.close = usb6fire_midi_in_close,\n\t.trigger = usb6fire_midi_in_trigger\n};\n\nint usb6fire_midi_init(struct sfire_chip *chip)\n{\n\tint ret;\n\tstruct midi_runtime *rt = kzalloc(sizeof(struct midi_runtime),\n\t\t\tGFP_KERNEL);\n\tstruct comm_runtime *comm_rt = chip->comm;\n\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->out_buffer = kzalloc(MIDI_BUFSIZE, GFP_KERNEL);\n\tif (!rt->out_buffer) {\n\t\tkfree(rt);\n\t\treturn -ENOMEM;\n\t}\n\n\trt->chip = chip;\n\trt->in_received = usb6fire_midi_in_received;\n\trt->out_buffer[0] = 0x80;  \n\trt->out_buffer[1] = 0x00;  \n\trt->out_buffer[2] = 0x00;  \n\tspin_lock_init(&rt->in_lock);\n\tspin_lock_init(&rt->out_lock);\n\n\tcomm_rt->init_urb(comm_rt, &rt->out_urb, rt->out_buffer, rt,\n\t\t\tusb6fire_midi_out_handler);\n\n\tret = snd_rawmidi_new(chip->card, \"6FireUSB\", 0, 1, 1, &rt->instance);\n\tif (ret < 0) {\n\t\tkfree(rt->out_buffer);\n\t\tkfree(rt);\n\t\tdev_err(&chip->dev->dev, \"unable to create midi.\\n\");\n\t\treturn ret;\n\t}\n\trt->instance->private_data = rt;\n\tstrcpy(rt->instance->name, \"DMX6FireUSB MIDI\");\n\trt->instance->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\tSNDRV_RAWMIDI_INFO_INPUT |\n\t\t\tSNDRV_RAWMIDI_INFO_DUPLEX;\n\tsnd_rawmidi_set_ops(rt->instance, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t&out_ops);\n\tsnd_rawmidi_set_ops(rt->instance, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t&in_ops);\n\n\tchip->midi = rt;\n\treturn 0;\n}\n\nvoid usb6fire_midi_abort(struct sfire_chip *chip)\n{\n\tstruct midi_runtime *rt = chip->midi;\n\n\tif (rt)\n\t\tusb_poison_urb(&rt->out_urb);\n}\n\nvoid usb6fire_midi_destroy(struct sfire_chip *chip)\n{\n\tstruct midi_runtime *rt = chip->midi;\n\n\tkfree(rt->out_buffer);\n\tkfree(rt);\n\tchip->midi = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}