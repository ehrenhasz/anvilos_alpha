{
  "module_name": "control.c",
  "hash_id": "3d0d71d2004ebb2ca62424d00fc3c1b6b96eaed13775a73e1f3a7cec98bbeee8",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/control.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n\n#include \"control.h\"\n#include \"comm.h\"\n#include \"chip.h\"\n\nstatic const char * const opt_coax_texts[2] = { \"Optical\", \"Coax\" };\nstatic const char * const line_phono_texts[2] = { \"Line\", \"Phono\" };\n\n \nstatic const struct {\n\tu8 type;\n\tu8 reg;\n\tu8 value;\n}\ninit_data[] = {\n\t{ 0x22, 0x00, 0x00 }, { 0x20, 0x00, 0x08 }, { 0x22, 0x01, 0x01 },\n\t{ 0x20, 0x01, 0x08 }, { 0x22, 0x02, 0x00 }, { 0x20, 0x02, 0x08 },\n\t{ 0x22, 0x03, 0x00 }, { 0x20, 0x03, 0x08 }, { 0x22, 0x04, 0x00 },\n\t{ 0x20, 0x04, 0x08 }, { 0x22, 0x05, 0x01 }, { 0x20, 0x05, 0x08 },\n\t{ 0x22, 0x04, 0x01 }, { 0x12, 0x04, 0x00 }, { 0x12, 0x05, 0x00 },\n\t{ 0x12, 0x0d, 0x38 }, { 0x12, 0x21, 0x82 }, { 0x12, 0x22, 0x80 },\n\t{ 0x12, 0x23, 0x00 }, { 0x12, 0x06, 0x02 }, { 0x12, 0x03, 0x00 },\n\t{ 0x12, 0x02, 0x00 }, { 0x22, 0x03, 0x01 },\n\t{ 0 }  \n};\n\nstatic const int rates_altsetting[] = { 1, 1, 2, 2, 3, 3 };\n \nstatic const u16 rates_6fire_vl[] = {0x00, 0x01, 0x00, 0x01, 0x00, 0x01};\nstatic const u16 rates_6fire_vh[] = {0x11, 0x11, 0x10, 0x10, 0x00, 0x00};\n\nstatic DECLARE_TLV_DB_MINMAX(tlv_output, -9000, 0);\nstatic DECLARE_TLV_DB_MINMAX(tlv_input, -1500, 1500);\n\nenum {\n\tDIGITAL_THRU_ONLY_SAMPLERATE = 3\n};\n\nstatic void usb6fire_control_output_vol_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\tint i;\n\n\tif (comm_rt)\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tif (!(rt->ovol_updated & (1 << i))) {\n\t\t\t\tcomm_rt->write8(comm_rt, 0x12, 0x0f + i,\n\t\t\t\t\t180 - rt->output_vol[i]);\n\t\t\t\trt->ovol_updated |= 1 << i;\n\t\t\t}\n}\n\nstatic void usb6fire_control_output_mute_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\n\tif (comm_rt)\n\t\tcomm_rt->write8(comm_rt, 0x12, 0x0e, ~rt->output_mute);\n}\n\nstatic void usb6fire_control_input_vol_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\tint i;\n\n\tif (comm_rt)\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tif (!(rt->ivol_updated & (1 << i))) {\n\t\t\t\tcomm_rt->write8(comm_rt, 0x12, 0x1c + i,\n\t\t\t\t\trt->input_vol[i] & 0x3f);\n\t\t\t\trt->ivol_updated |= 1 << i;\n\t\t\t}\n}\n\nstatic void usb6fire_control_line_phono_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\tif (comm_rt) {\n\t\tcomm_rt->write8(comm_rt, 0x22, 0x02, rt->line_phono_switch);\n\t\tcomm_rt->write8(comm_rt, 0x21, 0x02, rt->line_phono_switch);\n\t}\n}\n\nstatic void usb6fire_control_opt_coax_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\tif (comm_rt) {\n\t\tcomm_rt->write8(comm_rt, 0x22, 0x00, rt->opt_coax_switch);\n\t\tcomm_rt->write8(comm_rt, 0x21, 0x00, rt->opt_coax_switch);\n\t}\n}\n\nstatic int usb6fire_control_set_rate(struct control_runtime *rt, int rate)\n{\n\tint ret;\n\tstruct usb_device *device = rt->chip->dev;\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\n\tif (rate < 0 || rate >= CONTROL_N_RATES)\n\t\treturn -EINVAL;\n\n\tret = usb_set_interface(device, 1, rates_altsetting[rate]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = comm_rt->write16(comm_rt, 0x02, 0x01, rates_6fire_vl[rate],\n\t\t\trates_6fire_vh[rate]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int usb6fire_control_set_channels(\n\tstruct control_runtime *rt, int n_analog_out,\n\tint n_analog_in, bool spdif_out, bool spdif_in)\n{\n\tint ret;\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\n\t \n\tret = comm_rt->write16(comm_rt, 0x02, 0x02,\n\t\t\t(1 << (n_analog_out / 2)) - 1,\n\t\t\t(1 << (n_analog_in / 2)) - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tret = comm_rt->write16(comm_rt, 0x02, 0x03, 0x00, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int usb6fire_control_streaming_update(struct control_runtime *rt)\n{\n\tstruct comm_runtime *comm_rt = rt->chip->comm;\n\n\tif (comm_rt) {\n\t\tif (!rt->usb_streaming && rt->digital_thru_switch)\n\t\t\tusb6fire_control_set_rate(rt,\n\t\t\t\tDIGITAL_THRU_ONLY_SAMPLERATE);\n\t\treturn comm_rt->write16(comm_rt, 0x02, 0x00, 0x00,\n\t\t\t(rt->usb_streaming ? 0x01 : 0x00) |\n\t\t\t(rt->digital_thru_switch ? 0x08 : 0x00));\n\t}\n\treturn -EINVAL;\n}\n\nstatic int usb6fire_control_output_vol_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 180;\n\treturn 0;\n}\n\nstatic int usb6fire_control_output_vol_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tunsigned int ch = kcontrol->private_value;\n\tint changed = 0;\n\n\tif (ch > 4) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"Invalid channel in volume control.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rt->output_vol[ch] != ucontrol->value.integer.value[0]) {\n\t\trt->output_vol[ch] = ucontrol->value.integer.value[0];\n\t\trt->ovol_updated &= ~(1 << ch);\n\t\tchanged = 1;\n\t}\n\tif (rt->output_vol[ch + 1] != ucontrol->value.integer.value[1]) {\n\t\trt->output_vol[ch + 1] = ucontrol->value.integer.value[1];\n\t\trt->ovol_updated &= ~(2 << ch);\n\t\tchanged = 1;\n\t}\n\n\tif (changed)\n\t\tusb6fire_control_output_vol_update(rt);\n\n\treturn changed;\n}\n\nstatic int usb6fire_control_output_vol_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tunsigned int ch = kcontrol->private_value;\n\n\tif (ch > 4) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"Invalid channel in volume control.\");\n\t\treturn -EINVAL;\n\t}\n\n\tucontrol->value.integer.value[0] = rt->output_vol[ch];\n\tucontrol->value.integer.value[1] = rt->output_vol[ch + 1];\n\treturn 0;\n}\n\nstatic int usb6fire_control_output_mute_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tunsigned int ch = kcontrol->private_value;\n\tu8 old = rt->output_mute;\n\tu8 value = 0;\n\n\tif (ch > 4) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"Invalid channel in volume control.\");\n\t\treturn -EINVAL;\n\t}\n\n\trt->output_mute &= ~(3 << ch);\n\tif (ucontrol->value.integer.value[0])\n\t\tvalue |= 1;\n\tif (ucontrol->value.integer.value[1])\n\t\tvalue |= 2;\n\trt->output_mute |= value << ch;\n\n\tif (rt->output_mute != old)\n\t\tusb6fire_control_output_mute_update(rt);\n\n\treturn rt->output_mute != old;\n}\n\nstatic int usb6fire_control_output_mute_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tunsigned int ch = kcontrol->private_value;\n\tu8 value = rt->output_mute >> ch;\n\n\tif (ch > 4) {\n\t\tdev_err(&rt->chip->dev->dev,\n\t\t\t\"Invalid channel in volume control.\");\n\t\treturn -EINVAL;\n\t}\n\n\tucontrol->value.integer.value[0] = 1 & value;\n\tvalue >>= 1;\n\tucontrol->value.integer.value[1] = 1 & value;\n\n\treturn 0;\n}\n\nstatic int usb6fire_control_input_vol_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 30;\n\treturn 0;\n}\n\nstatic int usb6fire_control_input_vol_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\n\tif (rt->input_vol[0] != ucontrol->value.integer.value[0]) {\n\t\trt->input_vol[0] = ucontrol->value.integer.value[0] - 15;\n\t\trt->ivol_updated &= ~(1 << 0);\n\t\tchanged = 1;\n\t}\n\tif (rt->input_vol[1] != ucontrol->value.integer.value[1]) {\n\t\trt->input_vol[1] = ucontrol->value.integer.value[1] - 15;\n\t\trt->ivol_updated &= ~(1 << 1);\n\t\tchanged = 1;\n\t}\n\n\tif (changed)\n\t\tusb6fire_control_input_vol_update(rt);\n\n\treturn changed;\n}\n\nstatic int usb6fire_control_input_vol_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = rt->input_vol[0] + 15;\n\tucontrol->value.integer.value[1] = rt->input_vol[1] + 15;\n\n\treturn 0;\n}\n\nstatic int usb6fire_control_line_phono_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 2, line_phono_texts);\n}\n\nstatic int usb6fire_control_line_phono_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tif (rt->line_phono_switch != ucontrol->value.integer.value[0]) {\n\t\trt->line_phono_switch = ucontrol->value.integer.value[0];\n\t\tusb6fire_control_line_phono_update(rt);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic int usb6fire_control_line_phono_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = rt->line_phono_switch;\n\treturn 0;\n}\n\nstatic int usb6fire_control_opt_coax_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 2, opt_coax_texts);\n}\n\nstatic int usb6fire_control_opt_coax_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\n\tif (rt->opt_coax_switch != ucontrol->value.enumerated.item[0]) {\n\t\trt->opt_coax_switch = ucontrol->value.enumerated.item[0];\n\t\tusb6fire_control_opt_coax_update(rt);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic int usb6fire_control_opt_coax_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = rt->opt_coax_switch;\n\treturn 0;\n}\n\nstatic int usb6fire_control_digital_thru_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\n\tif (rt->digital_thru_switch != ucontrol->value.integer.value[0]) {\n\t\trt->digital_thru_switch = ucontrol->value.integer.value[0];\n\t\tusb6fire_control_streaming_update(rt);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic int usb6fire_control_digital_thru_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct control_runtime *rt = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = rt->digital_thru_switch;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vol_elements[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Volume\",\n\t\t.index = 0,\n\t\t.private_value = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = usb6fire_control_output_vol_info,\n\t\t.get = usb6fire_control_output_vol_get,\n\t\t.put = usb6fire_control_output_vol_put,\n\t\t.tlv = { .p = tlv_output }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Volume\",\n\t\t.index = 1,\n\t\t.private_value = 2,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = usb6fire_control_output_vol_info,\n\t\t.get = usb6fire_control_output_vol_get,\n\t\t.put = usb6fire_control_output_vol_put,\n\t\t.tlv = { .p = tlv_output }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Volume\",\n\t\t.index = 2,\n\t\t.private_value = 4,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = usb6fire_control_output_vol_info,\n\t\t.get = usb6fire_control_output_vol_get,\n\t\t.put = usb6fire_control_output_vol_put,\n\t\t.tlv = { .p = tlv_output }\n\t},\n\t{}\n};\n\nstatic const struct snd_kcontrol_new mute_elements[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Switch\",\n\t\t.index = 0,\n\t\t.private_value = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_stereo_info,\n\t\t.get = usb6fire_control_output_mute_get,\n\t\t.put = usb6fire_control_output_mute_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Switch\",\n\t\t.index = 1,\n\t\t.private_value = 2,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_stereo_info,\n\t\t.get = usb6fire_control_output_mute_get,\n\t\t.put = usb6fire_control_output_mute_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Playback Switch\",\n\t\t.index = 2,\n\t\t.private_value = 4,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_stereo_info,\n\t\t.get = usb6fire_control_output_mute_get,\n\t\t.put = usb6fire_control_output_mute_put,\n\t},\n\t{}\n};\n\nstatic const struct snd_kcontrol_new elements[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line/Phono Capture Route\",\n\t\t.index = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = usb6fire_control_line_phono_info,\n\t\t.get = usb6fire_control_line_phono_get,\n\t\t.put = usb6fire_control_line_phono_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Opt/Coax Capture Route\",\n\t\t.index = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = usb6fire_control_opt_coax_info,\n\t\t.get = usb6fire_control_opt_coax_get,\n\t\t.put = usb6fire_control_opt_coax_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Digital Thru Playback Route\",\n\t\t.index = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = usb6fire_control_digital_thru_get,\n\t\t.put = usb6fire_control_digital_thru_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Capture Volume\",\n\t\t.index = 0,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = usb6fire_control_input_vol_info,\n\t\t.get = usb6fire_control_input_vol_get,\n\t\t.put = usb6fire_control_input_vol_put,\n\t\t.tlv = { .p = tlv_input }\n\t},\n\t{}\n};\n\nstatic int usb6fire_control_add_virtual(\n\tstruct control_runtime *rt,\n\tstruct snd_card *card,\n\tchar *name,\n\tconst struct snd_kcontrol_new *elems)\n{\n\tint ret;\n\tint i;\n\tstruct snd_kcontrol *vmaster =\n\t\tsnd_ctl_make_virtual_master(name, tlv_output);\n\tstruct snd_kcontrol *control;\n\n\tif (!vmaster)\n\t\treturn -ENOMEM;\n\tret = snd_ctl_add(card, vmaster);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti = 0;\n\twhile (elems[i].name) {\n\t\tcontrol = snd_ctl_new1(&elems[i], rt);\n\t\tif (!control)\n\t\t\treturn -ENOMEM;\n\t\tret = snd_ctl_add(card, control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = snd_ctl_add_follower(vmaster, control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\treturn 0;\n}\n\nint usb6fire_control_init(struct sfire_chip *chip)\n{\n\tint i;\n\tint ret;\n\tstruct control_runtime *rt = kzalloc(sizeof(struct control_runtime),\n\t\t\tGFP_KERNEL);\n\tstruct comm_runtime *comm_rt = chip->comm;\n\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->chip = chip;\n\trt->update_streaming = usb6fire_control_streaming_update;\n\trt->set_rate = usb6fire_control_set_rate;\n\trt->set_channels = usb6fire_control_set_channels;\n\n\ti = 0;\n\twhile (init_data[i].type) {\n\t\tcomm_rt->write8(comm_rt, init_data[i].type, init_data[i].reg,\n\t\t\t\tinit_data[i].value);\n\t\ti++;\n\t}\n\n\tusb6fire_control_opt_coax_update(rt);\n\tusb6fire_control_line_phono_update(rt);\n\tusb6fire_control_output_vol_update(rt);\n\tusb6fire_control_output_mute_update(rt);\n\tusb6fire_control_input_vol_update(rt);\n\tusb6fire_control_streaming_update(rt);\n\n\tret = usb6fire_control_add_virtual(rt, chip->card,\n\t\t\"Master Playback Volume\", vol_elements);\n\tif (ret) {\n\t\tdev_err(&chip->dev->dev, \"cannot add control.\\n\");\n\t\tkfree(rt);\n\t\treturn ret;\n\t}\n\tret = usb6fire_control_add_virtual(rt, chip->card,\n\t\t\"Master Playback Switch\", mute_elements);\n\tif (ret) {\n\t\tdev_err(&chip->dev->dev, \"cannot add control.\\n\");\n\t\tkfree(rt);\n\t\treturn ret;\n\t}\n\n\ti = 0;\n\twhile (elements[i].name) {\n\t\tret = snd_ctl_add(chip->card, snd_ctl_new1(&elements[i], rt));\n\t\tif (ret < 0) {\n\t\t\tkfree(rt);\n\t\t\tdev_err(&chip->dev->dev, \"cannot add control.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\n\tchip->control = rt;\n\treturn 0;\n}\n\nvoid usb6fire_control_abort(struct sfire_chip *chip)\n{}\n\nvoid usb6fire_control_destroy(struct sfire_chip *chip)\n{\n\tkfree(chip->control);\n\tchip->control = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}