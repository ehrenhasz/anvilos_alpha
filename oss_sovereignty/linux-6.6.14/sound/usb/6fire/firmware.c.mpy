{
  "module_name": "firmware.c",
  "hash_id": "00cae2c1dfd35b5e08ccc2dbbfa05a1d60d2524b02979aa447049738485c5bc1",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/6fire/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/bitrev.h>\n#include <linux/kernel.h>\n\n#include \"firmware.h\"\n#include \"chip.h\"\n\nMODULE_FIRMWARE(\"6fire/dmx6firel2.ihx\");\nMODULE_FIRMWARE(\"6fire/dmx6fireap.ihx\");\nMODULE_FIRMWARE(\"6fire/dmx6firecf.bin\");\n\nenum {\n\tFPGA_BUFSIZE = 512, FPGA_EP = 2\n};\n\n \nstatic const u8 ep_w_max_packet_size[] = {\n\t0xe4, 0x00, 0xe4, 0x00,  \n\t0xa4, 0x01, 0xa4, 0x01,  \n\t0x94, 0x01, 0x5c, 0x02   \n};\n\nstatic const u8 known_fw_versions[][2] = {\n\t{ 0x03, 0x01 }\n};\n\nstruct ihex_record {\n\tu16 address;\n\tu8 len;\n\tu8 data[256];\n\tchar error;  \n\n\tu8 max_len;  \n\n\t \n\tconst char *txt_data;\n\tunsigned int txt_length;\n\tunsigned int txt_offset;  \n};\n\nstatic u8 usb6fire_fw_ihex_hex(const u8 *data, u8 *crc)\n{\n\tu8 val = 0;\n\tint hval;\n\n\thval = hex_to_bin(data[0]);\n\tif (hval >= 0)\n\t\tval |= (hval << 4);\n\n\thval = hex_to_bin(data[1]);\n\tif (hval >= 0)\n\t\tval |= hval;\n\n\t*crc += val;\n\treturn val;\n}\n\n \nstatic bool usb6fire_fw_ihex_next_record(struct ihex_record *record)\n{\n\tu8 crc = 0;\n\tu8 type;\n\tint i;\n\n\trecord->error = false;\n\n\t \n\twhile (record->txt_offset < record->txt_length\n\t\t\t&& record->txt_data[record->txt_offset] != ':')\n\t\trecord->txt_offset++;\n\tif (record->txt_offset == record->txt_length)\n\t\treturn false;\n\n\t \n\trecord->txt_offset++;\n\tif (record->txt_offset + 8 > record->txt_length) {\n\t\trecord->error = true;\n\t\treturn false;\n\t}\n\n\trecord->len = usb6fire_fw_ihex_hex(record->txt_data +\n\t\t\trecord->txt_offset, &crc);\n\trecord->txt_offset += 2;\n\trecord->address = usb6fire_fw_ihex_hex(record->txt_data +\n\t\t\trecord->txt_offset, &crc) << 8;\n\trecord->txt_offset += 2;\n\trecord->address |= usb6fire_fw_ihex_hex(record->txt_data +\n\t\t\trecord->txt_offset, &crc);\n\trecord->txt_offset += 2;\n\ttype = usb6fire_fw_ihex_hex(record->txt_data +\n\t\t\trecord->txt_offset, &crc);\n\trecord->txt_offset += 2;\n\n\t \n\tif (record->txt_offset + 2 * (record->len + 1) > record->txt_length) {\n\t\trecord->error = true;\n\t\treturn false;\n\t}\n\tfor (i = 0; i < record->len; i++) {\n\t\trecord->data[i] = usb6fire_fw_ihex_hex(record->txt_data\n\t\t\t\t+ record->txt_offset, &crc);\n\t\trecord->txt_offset += 2;\n\t}\n\tusb6fire_fw_ihex_hex(record->txt_data + record->txt_offset, &crc);\n\tif (crc) {\n\t\trecord->error = true;\n\t\treturn false;\n\t}\n\n\tif (type == 1 || !record->len)  \n\t\treturn false;\n\telse if (type == 0)\n\t\treturn true;\n\telse {\n\t\trecord->error = true;\n\t\treturn false;\n\t}\n}\n\nstatic int usb6fire_fw_ihex_init(const struct firmware *fw,\n\t\tstruct ihex_record *record)\n{\n\trecord->txt_data = fw->data;\n\trecord->txt_length = fw->size;\n\trecord->txt_offset = 0;\n\trecord->max_len = 0;\n\t \n\twhile (usb6fire_fw_ihex_next_record(record))\n\t\trecord->max_len = max(record->len, record->max_len);\n\tif (record->error)\n\t\treturn -EINVAL;\n\trecord->txt_offset = 0;\n\treturn 0;\n}\n\nstatic int usb6fire_fw_ezusb_write(struct usb_device *device,\n\t\tint type, int value, char *data, int len)\n{\n\treturn usb_control_msg_send(device, 0, type,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t    value, 0, data, len, 1000, GFP_KERNEL);\n}\n\nstatic int usb6fire_fw_ezusb_read(struct usb_device *device,\n\t\tint type, int value, char *data, int len)\n{\n\treturn usb_control_msg_recv(device, 0, type,\n\t\t\t\t    USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t    value, 0, data, len, 1000, GFP_KERNEL);\n}\n\nstatic int usb6fire_fw_fpga_write(struct usb_device *device,\n\t\tchar *data, int len)\n{\n\tint actual_len;\n\tint ret;\n\n\tret = usb_bulk_msg(device, usb_sndbulkpipe(device, FPGA_EP), data, len,\n\t\t\t&actual_len, 1000);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (actual_len != len)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int usb6fire_fw_ezusb_upload(\n\t\tstruct usb_interface *intf, const char *fwname,\n\t\tunsigned int postaddr, u8 *postdata, unsigned int postlen)\n{\n\tint ret;\n\tu8 data;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tconst struct firmware *fw = NULL;\n\tstruct ihex_record *rec = kmalloc(sizeof(struct ihex_record),\n\t\t\tGFP_KERNEL);\n\n\tif (!rec)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, fwname, &device->dev);\n\tif (ret < 0) {\n\t\tkfree(rec);\n\t\tdev_err(&intf->dev,\n\t\t\t\"error requesting ezusb firmware %s.\\n\", fwname);\n\t\treturn ret;\n\t}\n\tret = usb6fire_fw_ihex_init(fw, rec);\n\tif (ret < 0) {\n\t\tkfree(rec);\n\t\trelease_firmware(fw);\n\t\tdev_err(&intf->dev,\n\t\t\t\"error validating ezusb firmware %s.\\n\", fwname);\n\t\treturn ret;\n\t}\n\t \n\tdata = 0x01;  \n\tret = usb6fire_fw_ezusb_write(device, 0xa0, 0xe600, &data, 1);\n\tif (ret) {\n\t\tkfree(rec);\n\t\trelease_firmware(fw);\n\t\tdev_err(&intf->dev,\n\t\t\t\"unable to upload ezusb firmware %s: begin message.\\n\",\n\t\t\tfwname);\n\t\treturn ret;\n\t}\n\n\twhile (usb6fire_fw_ihex_next_record(rec)) {  \n\t\tret = usb6fire_fw_ezusb_write(device, 0xa0, rec->address,\n\t\t\t\trec->data, rec->len);\n\t\tif (ret) {\n\t\t\tkfree(rec);\n\t\t\trelease_firmware(fw);\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"unable to upload ezusb firmware %s: data urb.\\n\",\n\t\t\t\tfwname);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trelease_firmware(fw);\n\tkfree(rec);\n\tif (postdata) {  \n\t\tret = usb6fire_fw_ezusb_write(device, 0xa0, postaddr,\n\t\t\t\tpostdata, postlen);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"unable to upload ezusb firmware %s: post urb.\\n\",\n\t\t\t\tfwname);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata = 0x00;  \n\tret = usb6fire_fw_ezusb_write(device, 0xa0, 0xe600, &data, 1);\n\tif (ret) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unable to upload ezusb firmware %s: end message.\\n\",\n\t\t\tfwname);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int usb6fire_fw_fpga_upload(\n\t\tstruct usb_interface *intf, const char *fwname)\n{\n\tint ret;\n\tint i;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\tu8 *buffer = kmalloc(FPGA_BUFSIZE, GFP_KERNEL);\n\tconst char *c;\n\tconst char *end;\n\tconst struct firmware *fw;\n\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, fwname, &device->dev);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"unable to get fpga firmware %s.\\n\",\n\t\t\t\tfwname);\n\t\tkfree(buffer);\n\t\treturn -EIO;\n\t}\n\n\tc = fw->data;\n\tend = fw->data + fw->size;\n\n\tret = usb6fire_fw_ezusb_write(device, 8, 0, NULL, 0);\n\tif (ret) {\n\t\tkfree(buffer);\n\t\trelease_firmware(fw);\n\t\tdev_err(&intf->dev,\n\t\t\t\"unable to upload fpga firmware: begin urb.\\n\");\n\t\treturn ret;\n\t}\n\n\twhile (c != end) {\n\t\tfor (i = 0; c != end && i < FPGA_BUFSIZE; i++, c++)\n\t\t\tbuffer[i] = bitrev8((u8)*c);\n\n\t\tret = usb6fire_fw_fpga_write(device, buffer, i);\n\t\tif (ret < 0) {\n\t\t\trelease_firmware(fw);\n\t\t\tkfree(buffer);\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"unable to upload fpga firmware: fw urb.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\trelease_firmware(fw);\n\tkfree(buffer);\n\n\tret = usb6fire_fw_ezusb_write(device, 9, 0, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unable to upload fpga firmware: end urb.\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int usb6fire_fw_check(struct usb_interface *intf, const u8 *version)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(known_fw_versions); i++)\n\t\tif (!memcmp(version, known_fw_versions + i, 2))\n\t\t\treturn 0;\n\n\tdev_err(&intf->dev, \"invalid firmware version in device: %4ph. \"\n\t\t\t\"please reconnect to power. if this failure \"\n\t\t\t\"still happens, check your firmware installation.\",\n\t\t\tversion);\n\treturn -EINVAL;\n}\n\nint usb6fire_fw_init(struct usb_interface *intf)\n{\n\tint i;\n\tint ret;\n\tstruct usb_device *device = interface_to_usbdev(intf);\n\t \n\tu8 buffer[12];\n\n\tret = usb6fire_fw_ezusb_read(device, 1, 0, buffer, 8);\n\tif (ret) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unable to receive device firmware state.\\n\");\n\t\treturn ret;\n\t}\n\tif (buffer[0] != 0xeb || buffer[1] != 0xaa || buffer[2] != 0x55) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unknown device firmware state received from device:\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tprintk(KERN_CONT \"%02x \", buffer[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tif (buffer[3] == 0x01) {\n\t\tret = usb6fire_fw_ezusb_upload(intf,\n\t\t\t\t\"6fire/dmx6firel2.ihx\", 0, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn FW_NOT_READY;\n\t}\n\t \n\telse if (buffer[3] == 0x02) {\n\t\tret = usb6fire_fw_check(intf, buffer + 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = usb6fire_fw_fpga_upload(intf, \"6fire/dmx6firecf.bin\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmemcpy(buffer, ep_w_max_packet_size,\n\t\t\t\tsizeof(ep_w_max_packet_size));\n\t\tret = usb6fire_fw_ezusb_upload(intf, \"6fire/dmx6fireap.ihx\",\n\t\t\t\t0x0003,\tbuffer, sizeof(ep_w_max_packet_size));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn FW_NOT_READY;\n\t}\n\t \n\telse if (buffer[3] == 0x03)\n\t\treturn usb6fire_fw_check(intf, buffer + 4);\n\t \n\telse {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unknown device firmware state received from device: \");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tprintk(KERN_CONT \"%02x \", buffer[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}