{
  "module_name": "format.c",
  "hash_id": "f4b8a5993a2db5944e13a28de6af14950ec8a5b440ec0e0ee9ff95bd678f398b",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/format.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"quirks.h\"\n#include \"helper.h\"\n#include \"clock.h\"\n#include \"format.h\"\n\n \nstatic u64 parse_audio_format_i_type(struct snd_usb_audio *chip,\n\t\t\t\t     struct audioformat *fp,\n\t\t\t\t     u64 format, void *_fmt)\n{\n\tint sample_width, sample_bytes;\n\tu64 pcm_formats = 0;\n\n\tswitch (fp->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault: {\n\t\tstruct uac_format_type_i_discrete_descriptor *fmt = _fmt;\n\t\tif (format >= 64) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"%u:%d: invalid format type 0x%llx is detected, processed as PCM\\n\",\n\t\t\t\t       fp->iface, fp->altsetting, format);\n\t\t\tformat = UAC_FORMAT_TYPE_I_PCM;\n\t\t}\n\t\tsample_width = fmt->bBitResolution;\n\t\tsample_bytes = fmt->bSubframeSize;\n\t\tformat = 1ULL << format;\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct uac_format_type_i_ext_descriptor *fmt = _fmt;\n\t\tsample_width = fmt->bBitResolution;\n\t\tsample_bytes = fmt->bSubslotSize;\n\n\t\tif (format & UAC2_FORMAT_TYPE_I_RAW_DATA) {\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_SPECIAL;\n\t\t\t \n\t\t\tfp->dsd_raw = true;\n\t\t}\n\n\t\tformat <<= 1;\n\t\tbreak;\n\t}\n\tcase UAC_VERSION_3: {\n\t\tstruct uac3_as_header_descriptor *as = _fmt;\n\n\t\tsample_width = as->bBitResolution;\n\t\tsample_bytes = as->bSubslotSize;\n\n\t\tif (format & UAC3_FORMAT_TYPE_I_RAW_DATA)\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_SPECIAL;\n\n\t\tformat <<= 1;\n\t\tbreak;\n\t}\n\t}\n\n\tfp->fmt_bits = sample_width;\n\n\tif ((pcm_formats == 0) &&\n\t    (format == 0 || format == (1 << UAC_FORMAT_TYPE_I_UNDEFINED))) {\n\t\t \n\t\tusb_audio_info(chip, \"%u:%d : format type 0 is detected, processed as PCM\\n\",\n\t\t\tfp->iface, fp->altsetting);\n\t\tformat = 1 << UAC_FORMAT_TYPE_I_PCM;\n\t}\n\tif (format & (1 << UAC_FORMAT_TYPE_I_PCM)) {\n\t\tif (((chip->usb_id == USB_ID(0x0582, 0x0016)) ||\n\t\t      \n\t\t     (chip->usb_id == USB_ID(0x0582, 0x000c))) &&\n\t\t      \n\t\t    sample_width == 24 && sample_bytes == 2)\n\t\t\tsample_bytes = 3;\n\t\telse if (sample_width > sample_bytes * 8) {\n\t\t\tusb_audio_info(chip, \"%u:%d : sample bitwidth %d in over sample bytes %d\\n\",\n\t\t\t\t fp->iface, fp->altsetting,\n\t\t\t\t sample_width, sample_bytes);\n\t\t}\n\t\t \n\t\tswitch (sample_bytes) {\n\t\tcase 1:\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (snd_usb_is_big_endian_format(chip, fp))\n\t\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S16_BE;  \n\t\t\telse\n\t\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S16_LE;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (snd_usb_is_big_endian_format(chip, fp))\n\t\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S24_3BE;  \n\t\t\telse\n\t\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S24_3LE;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"%u:%d : unsupported sample bitwidth %d in %d bytes\\n\",\n\t\t\t\t fp->iface, fp->altsetting,\n\t\t\t\t sample_width, sample_bytes);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (format & (1 << UAC_FORMAT_TYPE_I_PCM8)) {\n\t\t \n\t\tif (chip->usb_id == USB_ID(0x04fa, 0x4201))\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_S8;\n\t\telse\n\t\t\tpcm_formats |= SNDRV_PCM_FMTBIT_U8;\n\t}\n\tif (format & (1 << UAC_FORMAT_TYPE_I_IEEE_FLOAT)) {\n\t\tpcm_formats |= SNDRV_PCM_FMTBIT_FLOAT_LE;\n\t}\n\tif (format & (1 << UAC_FORMAT_TYPE_I_ALAW)) {\n\t\tpcm_formats |= SNDRV_PCM_FMTBIT_A_LAW;\n\t}\n\tif (format & (1 << UAC_FORMAT_TYPE_I_MULAW)) {\n\t\tpcm_formats |= SNDRV_PCM_FMTBIT_MU_LAW;\n\t}\n\tif (format & ~0x3f) {\n\t\tusb_audio_info(chip,\n\t\t\t \"%u:%d : unsupported format bits %#llx\\n\",\n\t\t\t fp->iface, fp->altsetting, format);\n\t}\n\n\tpcm_formats |= snd_usb_interface_dsd_format_quirks(chip, fp, sample_bytes);\n\n\treturn pcm_formats;\n}\n\nstatic int set_fixed_rate(struct audioformat *fp, int rate, int rate_bits)\n{\n\tkfree(fp->rate_table);\n\tfp->rate_table = kmalloc(sizeof(int), GFP_KERNEL);\n\tif (!fp->rate_table)\n\t\treturn -ENOMEM;\n\tfp->nr_rates = 1;\n\tfp->rate_min = rate;\n\tfp->rate_max = rate;\n\tfp->rates = rate_bits;\n\tfp->rate_table[0] = rate;\n\treturn 0;\n}\n\n \nstatic void set_rate_table_min_max(struct audioformat *fp)\n{\n\tunsigned int rate;\n\tint i;\n\n\tfp->rate_min = INT_MAX;\n\tfp->rate_max = 0;\n\tfp->rates = 0;\n\tfor (i = 0; i < fp->nr_rates; i++) {\n\t\trate = fp->rate_table[i];\n\t\tfp->rate_min = min(fp->rate_min, rate);\n\t\tfp->rate_max = max(fp->rate_max, rate);\n\t\tfp->rates |= snd_pcm_rate_to_rate_bit(rate);\n\t}\n}\n\n \nstatic int parse_audio_format_rates_v1(struct snd_usb_audio *chip, struct audioformat *fp,\n\t\t\t\t       unsigned char *fmt, int offset)\n{\n\tint nr_rates = fmt[offset];\n\n\tif (fmt[0] < offset + 1 + 3 * (nr_rates ? nr_rates : 2)) {\n\t\tusb_audio_err(chip,\n\t\t\t\"%u:%d : invalid UAC_FORMAT_TYPE desc\\n\",\n\t\t\tfp->iface, fp->altsetting);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr_rates) {\n\t\t \n\t\tint r, idx;\n\n\t\tfp->rate_table = kmalloc_array(nr_rates, sizeof(int),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (fp->rate_table == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tfp->nr_rates = 0;\n\t\tfor (r = 0, idx = offset + 1; r < nr_rates; r++, idx += 3) {\n\t\t\tunsigned int rate = combine_triple(&fmt[idx]);\n\t\t\tif (!rate)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tif (rate == 48000 && nr_rates == 1 &&\n\t\t\t    (chip->usb_id == USB_ID(0x0d8c, 0x0201) ||\n\t\t\t     chip->usb_id == USB_ID(0x0d8c, 0x0102) ||\n\t\t\t     chip->usb_id == USB_ID(0x0d8c, 0x0078) ||\n\t\t\t     chip->usb_id == USB_ID(0x0ccd, 0x00b1)) &&\n\t\t\t    fp->altsetting == 5 && fp->maxpacksize == 392)\n\t\t\t\trate = 96000;\n\t\t\t \n\t\t\tif (rate == 16000 &&\n\t\t\t    (chip->usb_id == USB_ID(0x041e, 0x4064) ||\n\t\t\t     chip->usb_id == USB_ID(0x041e, 0x4068)))\n\t\t\t\trate = 8000;\n\n\t\t\tfp->rate_table[fp->nr_rates++] = rate;\n\t\t}\n\t\tif (!fp->nr_rates) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"%u:%d: All rates were zero\\n\",\n\t\t\t\t       fp->iface, fp->altsetting);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tset_rate_table_min_max(fp);\n\t} else {\n\t\t \n\t\tfp->rates = SNDRV_PCM_RATE_CONTINUOUS;\n\t\tfp->rate_min = combine_triple(&fmt[offset + 1]);\n\t\tfp->rate_max = combine_triple(&fmt[offset + 4]);\n\t}\n\n\t \n\tif (chip->usb_id == USB_ID(0x0b0e, 0x030b)) {\n\t\t \n\t\tif (fp->nr_rates != 1)\n\t\t\treturn set_fixed_rate(fp, 48000, SNDRV_PCM_RATE_48000);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic bool s1810c_valid_sample_rate(struct audioformat *fp,\n\t\t\t\t     unsigned int rate)\n{\n\tswitch (fp->altsetting) {\n\tcase 1:\n\t\t \n\t\treturn rate <= 48000;\n\tcase 2:\n\t\t \n\t\treturn (rate == 88200 || rate == 96000);\n\tcase 3:\n\t\t \n\t\treturn rate >= 176400;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}\n\n \nstatic bool focusrite_valid_sample_rate(struct snd_usb_audio *chip,\n\t\t\t\t\tstruct audioformat *fp,\n\t\t\t\t\tunsigned int rate)\n{\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alts;\n\tunsigned char *fmt;\n\tunsigned int max_rate;\n\n\tiface = usb_ifnum_to_if(chip->dev, fp->iface);\n\tif (!iface)\n\t\treturn true;\n\n\talts = &iface->altsetting[fp->altset_idx];\n\tfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t      NULL, UAC_FORMAT_TYPE);\n\tif (!fmt)\n\t\treturn true;\n\n\tif (fmt[0] == 10) {  \n\t\tmax_rate = combine_quad(&fmt[6]);\n\n\t\t \n\t\tif (max_rate != 48000 &&\n\t\t    max_rate != 96000 &&\n\t\t    max_rate != 192000 &&\n\t\t    max_rate != 384000) {\n\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"%u:%d : unexpected max rate: %u\\n\",\n\t\t\t\tfp->iface, fp->altsetting, max_rate);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn rate <= max_rate;\n\t}\n\n\treturn true;\n}\n\n \nstatic int parse_uac2_sample_rate_range(struct snd_usb_audio *chip,\n\t\t\t\t\tstruct audioformat *fp, int nr_triplets,\n\t\t\t\t\tconst unsigned char *data)\n{\n\tint i, nr_rates = 0;\n\n\tfor (i = 0; i < nr_triplets; i++) {\n\t\tint min = combine_quad(&data[2 + 12 * i]);\n\t\tint max = combine_quad(&data[6 + 12 * i]);\n\t\tint res = combine_quad(&data[10 + 12 * i]);\n\t\tunsigned int rate;\n\n\t\tif ((max < 0) || (min < 0) || (res < 0) || (max < min))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (res == 1) {\n\t\t\tfp->rate_min = min;\n\t\t\tfp->rate_max = max;\n\t\t\tfp->rates = SNDRV_PCM_RATE_CONTINUOUS;\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (rate = min; rate <= max; rate += res) {\n\n\t\t\t \n\t\t\tif (chip->usb_id == USB_ID(0x194f, 0x010c) &&\n\t\t\t    !s1810c_valid_sample_rate(fp, rate))\n\t\t\t\tgoto skip_rate;\n\n\t\t\t \n\t\t\tif (USB_ID_VENDOR(chip->usb_id) == 0x1235 &&\n\t\t\t    !focusrite_valid_sample_rate(chip, fp, rate))\n\t\t\t\tgoto skip_rate;\n\n\t\t\tif (fp->rate_table)\n\t\t\t\tfp->rate_table[nr_rates] = rate;\n\t\t\tnr_rates++;\n\t\t\tif (nr_rates >= MAX_NR_RATES) {\n\t\t\t\tusb_audio_err(chip, \"invalid uac2 rates\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\nskip_rate:\n\t\t\t \n\t\t\tif (res == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_rates;\n}\n\n \nstatic int line6_parse_audio_format_rates_quirk(struct snd_usb_audio *chip,\n\t\t\t\t\t\tstruct audioformat *fp)\n{\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0e41, 0x4241):  \n\tcase USB_ID(0x0e41, 0x4242):  \n\tcase USB_ID(0x0e41, 0x4244):  \n\tcase USB_ID(0x0e41, 0x4246):  \n\tcase USB_ID(0x0e41, 0x4253):  \n\tcase USB_ID(0x0e41, 0x4247):  \n\tcase USB_ID(0x0e41, 0x4248):  \n\tcase USB_ID(0x0e41, 0x4249):  \n\tcase USB_ID(0x0e41, 0x424a):  \n\tcase USB_ID(0x0e41, 0x424b):  \n\tcase USB_ID(0x19f7, 0x0011):  \n\t\treturn set_fixed_rate(fp, 48000, SNDRV_PCM_RATE_48000);\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic bool check_valid_altsetting_v2v3(struct snd_usb_audio *chip, int iface,\n\t\t\t\t\tint altsetting)\n{\n\tstruct usb_device *dev = chip->dev;\n\t__le64 raw_data = 0;\n\tu64 data;\n\tint err;\n\n\t \n\tif (snd_BUG_ON(altsetting >= 64 - 8))\n\t\treturn false;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t      UAC2_AS_VAL_ALT_SETTINGS << 8,\n\t\t\t      iface, &raw_data, sizeof(raw_data));\n\tif (err < 0)\n\t\treturn false;\n\n\tdata = le64_to_cpu(raw_data);\n\t \n\tif ((data & 0xff) * 8 < altsetting)\n\t\treturn false;\n\tif (data & (1ULL << (altsetting + 8)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int validate_sample_rate_table_v2v3(struct snd_usb_audio *chip,\n\t\t\t\t\t   struct audioformat *fp,\n\t\t\t\t\t   int clock)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned int *table;\n\tunsigned int nr_rates;\n\tint i, err;\n\n\t \n\tif (!(chip->quirk_flags & QUIRK_FLAG_VALIDATE_RATES))\n\t\treturn 0;  \n\n\ttable = kcalloc(fp->nr_rates, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t \n\tusb_set_interface(dev, fp->iface, 0);\n\n\tnr_rates = 0;\n\tfor (i = 0; i < fp->nr_rates; i++) {\n\t\terr = snd_usb_set_sample_rate_v2v3(chip, fp, clock,\n\t\t\t\t\t\t   fp->rate_table[i]);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\tif (check_valid_altsetting_v2v3(chip, fp->iface, fp->altsetting))\n\t\t\ttable[nr_rates++] = fp->rate_table[i];\n\t}\n\n\tif (!nr_rates) {\n\t\tusb_audio_dbg(chip,\n\t\t\t      \"No valid sample rate available for %d:%d, assuming a firmware bug\\n\",\n\t\t\t      fp->iface, fp->altsetting);\n\t\tnr_rates = fp->nr_rates;  \n\t}\n\n\tif (fp->nr_rates == nr_rates) {\n\t\tkfree(table);\n\t\treturn 0;\n\t}\n\n\tkfree(fp->rate_table);\n\tfp->rate_table = table;\n\tfp->nr_rates = nr_rates;\n\treturn 0;\n}\n\n \nstatic int parse_audio_format_rates_v2v3(struct snd_usb_audio *chip,\n\t\t\t\t       struct audioformat *fp)\n{\n\tstruct usb_device *dev = chip->dev;\n\tunsigned char tmp[2], *data;\n\tint nr_triplets, data_size, ret = 0, ret_l6;\n\tint clock = snd_usb_clock_find_source(chip, fp, false);\n\n\tif (clock < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%s(): unable to find clock source (clock %d)\\n\",\n\t\t\t\t__func__, clock);\n\t\tgoto err;\n\t}\n\n\t \n\tret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t      UAC2_CS_CONTROL_SAM_FREQ << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (clock << 8),\n\t\t\t      tmp, sizeof(tmp));\n\n\tif (ret < 0) {\n\t\t \n\t\tret_l6 = line6_parse_audio_format_rates_quirk(chip, fp);\n\t\tif (ret_l6 == -ENODEV) {\n\t\t\t \n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%s(): unable to retrieve number of sample rates (clock %d)\\n\",\n\t\t\t\t__func__, clock);\n\t\t\tgoto err;\n\t\t}\n\t\tif (ret_l6 == 0) {\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t\"%s(): unable to retrieve number of sample rates: set it to a predefined value (clock %d).\\n\",\n\t\t\t\t__func__, clock);\n\t\t\treturn 0;\n\t\t}\n\t\tret = ret_l6;\n\t\tgoto err;\n\t}\n\n\tnr_triplets = (tmp[1] << 8) | tmp[0];\n\tdata_size = 2 + 12 * nr_triplets;\n\tdata = kzalloc(data_size, GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t      UAC2_CS_CONTROL_SAM_FREQ << 8,\n\t\t\t      snd_usb_ctrl_intf(chip) | (clock << 8),\n\t\t\t      data, data_size);\n\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"%s(): unable to retrieve sample rate range (clock %d)\\n\",\n\t\t\t\t__func__, clock);\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\t \n\tkfree(fp->rate_table);\n\tfp->rate_table = NULL;\n\tfp->nr_rates = parse_uac2_sample_rate_range(chip, fp, nr_triplets, data);\n\n\tif (fp->nr_rates == 0) {\n\t\t \n\t\tret = 0;\n\t\tgoto err_free;\n\t}\n\n\tfp->rate_table = kmalloc_array(fp->nr_rates, sizeof(int), GFP_KERNEL);\n\tif (!fp->rate_table) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\t \n\tparse_uac2_sample_rate_range(chip, fp, nr_triplets, data);\n\n\tret = validate_sample_rate_table_v2v3(chip, fp, clock);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tset_rate_table_min_max(fp);\n\nerr_free:\n\tkfree(data);\nerr:\n\treturn ret;\n}\n\n \nstatic int parse_audio_format_i(struct snd_usb_audio *chip,\n\t\t\t\tstruct audioformat *fp, u64 format,\n\t\t\t\tvoid *_fmt)\n{\n\tsnd_pcm_format_t pcm_format;\n\tunsigned int fmt_type;\n\tint ret;\n\n\tswitch (fp->protocol) {\n\tdefault:\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2: {\n\t\tstruct uac_format_type_i_continuous_descriptor *fmt = _fmt;\n\n\t\tfmt_type = fmt->bFormatType;\n\t\tbreak;\n\t}\n\tcase UAC_VERSION_3: {\n\t\t \n\t\tfmt_type = fp->fmt_type;\n\t\tbreak;\n\t}\n\t}\n\n\tif (fmt_type == UAC_FORMAT_TYPE_III) {\n\t\t \n\t\tswitch (chip->usb_id) {\n\n\t\tcase USB_ID(0x0763, 0x2003):  \n\t\t\tif (chip->setup == 0x00 && \n\t\t\t    fp->altsetting == 6)\n\t\t\t\tpcm_format = SNDRV_PCM_FORMAT_S16_BE;\n\t\t\telse\n\t\t\t\tpcm_format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpcm_format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t}\n\t\tfp->formats = pcm_format_to_bits(pcm_format);\n\t} else {\n\t\tfp->formats = parse_audio_format_i_type(chip, fp, format, _fmt);\n\t\tif (!fp->formats)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\t \n\tswitch (fp->protocol) {\n\tdefault:\n\tcase UAC_VERSION_1: {\n\t\tstruct uac_format_type_i_continuous_descriptor *fmt = _fmt;\n\n\t\tfp->channels = fmt->bNrChannels;\n\t\tret = parse_audio_format_rates_v1(chip, fp, (unsigned char *) fmt, 7);\n\t\tbreak;\n\t}\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3: {\n\t\t \n\t\tret = parse_audio_format_rates_v2v3(chip, fp);\n\t\tbreak;\n\t}\n\t}\n\n\tif (fp->channels < 1) {\n\t\tusb_audio_err(chip,\n\t\t\t\"%u:%d : invalid channels %d\\n\",\n\t\t\tfp->iface, fp->altsetting, fp->channels);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int parse_audio_format_ii(struct snd_usb_audio *chip,\n\t\t\t\t struct audioformat *fp,\n\t\t\t\t u64 format, void *_fmt)\n{\n\tint brate, framesize, ret;\n\n\tswitch (format) {\n\tcase UAC_FORMAT_TYPE_II_AC3:\n\t\t \n\t\t\n\t\tfp->formats = SNDRV_PCM_FMTBIT_U8;  \n\t\tbreak;\n\tcase UAC_FORMAT_TYPE_II_MPEG:\n\t\tfp->formats = SNDRV_PCM_FMTBIT_MPEG;\n\t\tbreak;\n\tdefault:\n\t\tusb_audio_info(chip,\n\t\t\t \"%u:%d : unknown format tag %#llx is detected.  processed as MPEG.\\n\",\n\t\t\t fp->iface, fp->altsetting, format);\n\t\tfp->formats = SNDRV_PCM_FMTBIT_MPEG;\n\t\tbreak;\n\t}\n\n\tfp->channels = 1;\n\n\tswitch (fp->protocol) {\n\tdefault:\n\tcase UAC_VERSION_1: {\n\t\tstruct uac_format_type_ii_discrete_descriptor *fmt = _fmt;\n\t\tbrate = le16_to_cpu(fmt->wMaxBitRate);\n\t\tframesize = le16_to_cpu(fmt->wSamplesPerFrame);\n\t\tusb_audio_info(chip, \"found format II with max.bitrate = %d, frame size=%d\\n\", brate, framesize);\n\t\tfp->frame_size = framesize;\n\t\tret = parse_audio_format_rates_v1(chip, fp, _fmt, 8);  \n\t\tbreak;\n\t}\n\tcase UAC_VERSION_2: {\n\t\tstruct uac_format_type_ii_ext_descriptor *fmt = _fmt;\n\t\tbrate = le16_to_cpu(fmt->wMaxBitRate);\n\t\tframesize = le16_to_cpu(fmt->wSamplesPerFrame);\n\t\tusb_audio_info(chip, \"found format II with max.bitrate = %d, frame size=%d\\n\", brate, framesize);\n\t\tfp->frame_size = framesize;\n\t\tret = parse_audio_format_rates_v2v3(chip, fp);\n\t\tbreak;\n\t}\n\t}\n\n\treturn ret;\n}\n\nint snd_usb_parse_audio_format(struct snd_usb_audio *chip,\n\t\t\t       struct audioformat *fp, u64 format,\n\t\t\t       struct uac_format_type_i_continuous_descriptor *fmt,\n\t\t\t       int stream)\n{\n\tint err;\n\n\tswitch (fmt->bFormatType) {\n\tcase UAC_FORMAT_TYPE_I:\n\tcase UAC_FORMAT_TYPE_III:\n\t\terr = parse_audio_format_i(chip, fp, format, fmt);\n\t\tbreak;\n\tcase UAC_FORMAT_TYPE_II:\n\t\terr = parse_audio_format_ii(chip, fp, format, fmt);\n\t\tbreak;\n\tdefault:\n\t\tusb_audio_info(chip,\n\t\t\t \"%u:%d : format type %d is not supported yet\\n\",\n\t\t\t fp->iface, fp->altsetting,\n\t\t\t fmt->bFormatType);\n\t\treturn -ENOTSUPP;\n\t}\n\tfp->fmt_type = fmt->bFormatType;\n\tif (err < 0)\n\t\treturn err;\n#if 1\n\t \n\t \n\tif (chip->usb_id == USB_ID(0x041e, 0x3000) ||\n\t    chip->usb_id == USB_ID(0x041e, 0x3020) ||\n\t    chip->usb_id == USB_ID(0x041e, 0x3061)) {\n\t\tif (fmt->bFormatType == UAC_FORMAT_TYPE_I &&\n\t\t    fp->rates != SNDRV_PCM_RATE_48000 &&\n\t\t    fp->rates != SNDRV_PCM_RATE_96000)\n\t\t\treturn -ENOTSUPP;\n\t}\n#endif\n\treturn 0;\n}\n\nint snd_usb_parse_audio_format_v3(struct snd_usb_audio *chip,\n\t\t\t       struct audioformat *fp,\n\t\t\t       struct uac3_as_header_descriptor *as,\n\t\t\t       int stream)\n{\n\tu64 format = le64_to_cpu(as->bmFormats);\n\tint err;\n\n\t \n\tif (format & 0x7f)\n\t\tfp->fmt_type = UAC_FORMAT_TYPE_I;\n\telse\n\t\tfp->fmt_type = UAC_FORMAT_TYPE_III;\n\n\terr = parse_audio_format_i(chip, fp, format, as);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}