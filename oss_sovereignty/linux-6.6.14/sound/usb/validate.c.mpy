{
  "module_name": "validate.c",
  "hash_id": "94c9a2dc6ad9b8ff8cacc34d1d7b397c5225c0378649d88557eb256b8ab2d318",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/validate.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n#include <linux/usb/midi.h>\n#include \"usbaudio.h\"\n#include \"helper.h\"\n\nstruct usb_desc_validator {\n\tunsigned char protocol;\n\tunsigned char type;\n\tbool (*func)(const void *p, const struct usb_desc_validator *v);\n\tsize_t size;\n};\n\n#define UAC_VERSION_ALL\t\t(unsigned char)(-1)\n\n \nstatic bool validate_uac1_header(const void *p,\n\t\t\t\t const struct usb_desc_validator *v)\n{\n\tconst struct uac1_ac_header_descriptor *d = p;\n\n\treturn d->bLength >= sizeof(*d) &&\n\t\td->bLength >= sizeof(*d) + d->bInCollection;\n}\n\n \nstatic bool validate_mixer_unit(const void *p,\n\t\t\t\tconst struct usb_desc_validator *v)\n{\n\tconst struct uac_mixer_unit_descriptor *d = p;\n\tsize_t len;\n\n\tif (d->bLength < sizeof(*d) || !d->bNrInPins)\n\t\treturn false;\n\tlen = sizeof(*d) + d->bNrInPins;\n\t \n\tswitch (v->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tlen += 2 + 1;  \n\t\t \n\t\tlen += 1;  \n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tlen += 4 + 1;  \n\t\t \n\t\tlen += 1 + 1;  \n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tlen += 2;  \n\t\t \n\t\tbreak;\n\t}\n\treturn d->bLength >= len;\n}\n\n \nstatic bool validate_processing_unit(const void *p,\n\t\t\t\t     const struct usb_desc_validator *v)\n{\n\tconst struct uac_processing_unit_descriptor *d = p;\n\tconst unsigned char *hdr = p;\n\tsize_t len, m;\n\n\tif (d->bLength < sizeof(*d))\n\t\treturn false;\n\tlen = sizeof(*d) + d->bNrInPins;\n\tif (d->bLength < len)\n\t\treturn false;\n\tswitch (v->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\t \n\t\tlen += 1 + 2 + 1;\n\t\tif (d->bLength < len + 1)  \n\t\t\treturn false;\n\t\tm = hdr[len];\n\t\tlen += 1 + m + 1;  \n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\t \n\t\tlen += 1 + 4 + 1;\n\t\tif (v->type == UAC2_PROCESSING_UNIT_V2)\n\t\t\tlen += 2;  \n\t\telse\n\t\t\tlen += 1;  \n\t\tlen += 1;  \n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\t \n\t\tlen += 2 + 4;\n\t\tbreak;\n\t}\n\tif (d->bLength < len)\n\t\treturn false;\n\n\tswitch (v->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tif (v->type == UAC1_EXTENSION_UNIT)\n\t\t\treturn true;  \n\t\tswitch (le16_to_cpu(d->wProcessType)) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX:\n\t\tcase UAC_PROCESS_DOLBY_PROLOGIC:\n\t\t\tif (d->bLength < len + 1)  \n\t\t\t\treturn false;\n\t\t\tm = hdr[len];\n\t\t\tlen += 1 + m * 2;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tif (v->type == UAC2_EXTENSION_UNIT_V2)\n\t\t\treturn true;  \n\t\tswitch (le16_to_cpu(d->wProcessType)) {\n\t\tcase UAC2_PROCESS_UP_DOWNMIX:\n\t\tcase UAC2_PROCESS_DOLBY_PROLOCIC:  \n\t\t\tif (d->bLength < len + 1)  \n\t\t\t\treturn false;\n\t\t\tm = hdr[len];\n\t\t\tlen += 1 + m * 4;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tif (v->type == UAC3_EXTENSION_UNIT) {\n\t\t\tlen += 2;  \n\t\t\tbreak;\n\t\t}\n\t\tswitch (le16_to_cpu(d->wProcessType)) {\n\t\tcase UAC3_PROCESS_UP_DOWNMIX:\n\t\t\tif (d->bLength < len + 1)  \n\t\t\t\treturn false;\n\t\t\tm = hdr[len];\n\t\t\tlen += 1 + m * 2;  \n\t\t\tbreak;\n\t\tcase UAC3_PROCESS_MULTI_FUNCTION:\n\t\t\tlen += 2 + 4;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (d->bLength < len)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool validate_selector_unit(const void *p,\n\t\t\t\t   const struct usb_desc_validator *v)\n{\n\tconst struct uac_selector_unit_descriptor *d = p;\n\tsize_t len;\n\n\tif (d->bLength < sizeof(*d))\n\t\treturn false;\n\tlen = sizeof(*d) + d->bNrInPins;\n\tswitch (v->protocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tlen += 1;  \n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tlen += 1 + 1;  \n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tlen += 4 + 2;  \n\t\tbreak;\n\t}\n\treturn d->bLength >= len;\n}\n\nstatic bool validate_uac1_feature_unit(const void *p,\n\t\t\t\t       const struct usb_desc_validator *v)\n{\n\tconst struct uac_feature_unit_descriptor *d = p;\n\n\tif (d->bLength < sizeof(*d) || !d->bControlSize)\n\t\treturn false;\n\t \n\treturn d->bLength >= sizeof(*d) + d->bControlSize + 1;\n}\n\nstatic bool validate_uac2_feature_unit(const void *p,\n\t\t\t\t       const struct usb_desc_validator *v)\n{\n\tconst struct uac2_feature_unit_descriptor *d = p;\n\n\tif (d->bLength < sizeof(*d))\n\t\treturn false;\n\t \n\treturn d->bLength >= sizeof(*d) + 4 + 1;\n}\n\nstatic bool validate_uac3_feature_unit(const void *p,\n\t\t\t\t       const struct usb_desc_validator *v)\n{\n\tconst struct uac3_feature_unit_descriptor *d = p;\n\n\tif (d->bLength < sizeof(*d))\n\t\treturn false;\n\t \n\treturn d->bLength >= sizeof(*d) + 4 + 2;\n}\n\nstatic bool validate_midi_out_jack(const void *p,\n\t\t\t\t   const struct usb_desc_validator *v)\n{\n\tconst struct usb_midi_out_jack_descriptor *d = p;\n\n\treturn d->bLength >= sizeof(*d) &&\n\t\td->bLength >= sizeof(*d) + d->bNrInputPins * 2;\n}\n\n#define FIXED(p, t, s) { .protocol = (p), .type = (t), .size = sizeof(s) }\n#define FUNC(p, t, f) { .protocol = (p), .type = (t), .func = (f) }\n\nstatic const struct usb_desc_validator audio_validators[] = {\n\t \n\tFUNC(UAC_VERSION_1, UAC_HEADER, validate_uac1_header),\n\tFIXED(UAC_VERSION_1, UAC_INPUT_TERMINAL,\n\t      struct uac_input_terminal_descriptor),\n\tFIXED(UAC_VERSION_1, UAC_OUTPUT_TERMINAL,\n\t      struct uac1_output_terminal_descriptor),\n\tFUNC(UAC_VERSION_1, UAC_MIXER_UNIT, validate_mixer_unit),\n\tFUNC(UAC_VERSION_1, UAC_SELECTOR_UNIT, validate_selector_unit),\n\tFUNC(UAC_VERSION_1, UAC_FEATURE_UNIT, validate_uac1_feature_unit),\n\tFUNC(UAC_VERSION_1, UAC1_PROCESSING_UNIT, validate_processing_unit),\n\tFUNC(UAC_VERSION_1, UAC1_EXTENSION_UNIT, validate_processing_unit),\n\n\t \n\tFIXED(UAC_VERSION_2, UAC_HEADER, struct uac2_ac_header_descriptor),\n\tFIXED(UAC_VERSION_2, UAC_INPUT_TERMINAL,\n\t      struct uac2_input_terminal_descriptor),\n\tFIXED(UAC_VERSION_2, UAC_OUTPUT_TERMINAL,\n\t      struct uac2_output_terminal_descriptor),\n\tFUNC(UAC_VERSION_2, UAC_MIXER_UNIT, validate_mixer_unit),\n\tFUNC(UAC_VERSION_2, UAC_SELECTOR_UNIT, validate_selector_unit),\n\tFUNC(UAC_VERSION_2, UAC_FEATURE_UNIT, validate_uac2_feature_unit),\n\t \n\tFUNC(UAC_VERSION_2, UAC2_PROCESSING_UNIT_V2, validate_processing_unit),\n\tFUNC(UAC_VERSION_2, UAC2_EXTENSION_UNIT_V2, validate_processing_unit),\n\tFIXED(UAC_VERSION_2, UAC2_CLOCK_SOURCE,\n\t      struct uac_clock_source_descriptor),\n\tFUNC(UAC_VERSION_2, UAC2_CLOCK_SELECTOR, validate_selector_unit),\n\tFIXED(UAC_VERSION_2, UAC2_CLOCK_MULTIPLIER,\n\t      struct uac_clock_multiplier_descriptor),\n\t \n\n\t \n\tFIXED(UAC_VERSION_2, UAC_HEADER, struct uac3_ac_header_descriptor),\n\tFIXED(UAC_VERSION_3, UAC_INPUT_TERMINAL,\n\t      struct uac3_input_terminal_descriptor),\n\tFIXED(UAC_VERSION_3, UAC_OUTPUT_TERMINAL,\n\t      struct uac3_output_terminal_descriptor),\n\t \n\tFUNC(UAC_VERSION_3, UAC3_MIXER_UNIT, validate_mixer_unit),\n\tFUNC(UAC_VERSION_3, UAC3_SELECTOR_UNIT, validate_selector_unit),\n\tFUNC(UAC_VERSION_3, UAC_FEATURE_UNIT, validate_uac3_feature_unit),\n\t \n\tFUNC(UAC_VERSION_3, UAC3_PROCESSING_UNIT, validate_processing_unit),\n\tFUNC(UAC_VERSION_3, UAC3_EXTENSION_UNIT, validate_processing_unit),\n\tFIXED(UAC_VERSION_3, UAC3_CLOCK_SOURCE,\n\t      struct uac3_clock_source_descriptor),\n\tFUNC(UAC_VERSION_3, UAC3_CLOCK_SELECTOR, validate_selector_unit),\n\tFIXED(UAC_VERSION_3, UAC3_CLOCK_MULTIPLIER,\n\t      struct uac3_clock_multiplier_descriptor),\n\t \n\t \n\t{ }  \n};\n\nstatic const struct usb_desc_validator midi_validators[] = {\n\tFIXED(UAC_VERSION_ALL, USB_MS_HEADER,\n\t      struct usb_ms_header_descriptor),\n\tFIXED(UAC_VERSION_ALL, USB_MS_MIDI_IN_JACK,\n\t      struct usb_midi_in_jack_descriptor),\n\tFUNC(UAC_VERSION_ALL, USB_MS_MIDI_OUT_JACK,\n\t     validate_midi_out_jack),\n\t{ }  \n};\n\n\n \nstatic bool validate_desc(unsigned char *hdr, int protocol,\n\t\t\t  const struct usb_desc_validator *v)\n{\n\tif (hdr[1] != USB_DT_CS_INTERFACE)\n\t\treturn true;  \n\n\tfor (; v->type; v++) {\n\t\tif (v->type == hdr[2] &&\n\t\t    (v->protocol == UAC_VERSION_ALL ||\n\t\t     v->protocol == protocol)) {\n\t\t\tif (v->func)\n\t\t\t\treturn v->func(hdr, v);\n\t\t\t \n\t\t\treturn hdr[0] >= v->size;\n\t\t}\n\t}\n\n\treturn true;  \n}\n\nbool snd_usb_validate_audio_desc(void *p, int protocol)\n{\n\tunsigned char *c = p;\n\tbool valid;\n\n\tvalid = validate_desc(p, protocol, audio_validators);\n\tif (!valid && snd_usb_skip_validation) {\n\t\tprint_hex_dump(KERN_ERR, \"USB-audio: buggy audio desc: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1, c, c[0], true);\n\t\tvalid = true;\n\t}\n\treturn valid;\n}\n\nbool snd_usb_validate_midi_desc(void *p)\n{\n\tunsigned char *c = p;\n\tbool valid;\n\n\tvalid = validate_desc(p, UAC_VERSION_1, midi_validators);\n\tif (!valid && snd_usb_skip_validation) {\n\t\tprint_hex_dump(KERN_ERR, \"USB-audio: buggy midi desc: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1, c, c[0], true);\n\t\tvalid = true;\n\t}\n\treturn valid;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}