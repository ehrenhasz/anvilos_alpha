{
  "module_name": "midi2.c",
  "hash_id": "b973b3f09ad2ddd4e2b4abaad57b2aa9d732b44f39f54c09e7771185c55500d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/usb/midi2.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n#include <linux/usb/midi-v2.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/ump.h>\n#include \"usbaudio.h\"\n#include \"midi.h\"\n#include \"midi2.h\"\n#include \"helper.h\"\n\nstatic bool midi2_enable = true;\nmodule_param(midi2_enable, bool, 0444);\nMODULE_PARM_DESC(midi2_enable, \"Enable MIDI 2.0 support.\");\n\nstatic bool midi2_ump_probe = true;\nmodule_param(midi2_ump_probe, bool, 0444);\nMODULE_PARM_DESC(midi2_ump_probe, \"Probe UMP v1.1 support at first.\");\n\n \nenum {\n\tSTR_OUT = SNDRV_RAWMIDI_STREAM_OUTPUT,\n\tSTR_IN = SNDRV_RAWMIDI_STREAM_INPUT\n};\n\n#define NUM_URBS\t8\n\nstruct snd_usb_midi2_urb;\nstruct snd_usb_midi2_endpoint;\nstruct snd_usb_midi2_ump;\nstruct snd_usb_midi2_interface;\n\n \nstruct snd_usb_midi2_urb {\n\tstruct urb *urb;\n\tstruct snd_usb_midi2_endpoint *ep;\n\tunsigned int index;\t\t \n};\n\n \nstruct snd_usb_midi2_endpoint {\n\tstruct usb_device *dev;\n\tconst struct usb_ms20_endpoint_descriptor *ms_ep;  \n\tstruct snd_usb_midi2_endpoint *pair;\t \n\tstruct snd_usb_midi2_ump *rmidi;\t \n\tstruct snd_ump_endpoint *ump;\t\t \n\tint direction;\t\t\t \n\tunsigned int endpoint;\t\t \n\tunsigned int pipe;\t\t \n\tunsigned int packets;\t\t \n\tunsigned int interval;\t\t \n\twait_queue_head_t wait;\t\t \n\tspinlock_t lock;\t\t \n\tstruct snd_rawmidi_substream *substream;  \n\tunsigned int num_urbs;\t\t \n\tunsigned long urb_free;\t\t \n\tunsigned long urb_free_mask;\t \n\tatomic_t running;\t\t \n\tatomic_t suspended;\t\t \n\tbool disconnected;\t\t \n\tstruct list_head list;\t\t \n\tstruct snd_usb_midi2_urb urbs[NUM_URBS];\n};\n\n \nstruct snd_usb_midi2_ump {\n\tstruct usb_device *dev;\n\tstruct snd_usb_midi2_interface *umidi;\t \n\tstruct snd_ump_endpoint *ump;\t\t \n\tstruct snd_usb_midi2_endpoint *eps[2];\t \n\tint index;\t\t\t\t \n\tunsigned char usb_block_id;\t\t \n\tbool ump_parsed;\t\t\t \n\tstruct list_head list;\t\t \n};\n\n \nstruct snd_usb_midi2_interface {\n\tstruct snd_usb_audio *chip;\t \n\tstruct usb_interface *iface;\t \n\tstruct usb_host_interface *hostif;\n\tconst char *blk_descs;\t\t \n\tunsigned int blk_desc_size;\t \n\tbool disconnected;\n\tstruct list_head ep_list;\t \n\tstruct list_head rawmidi_list;\t \n\tstruct list_head list;\t\t \n};\n\n \nstatic void do_submit_urbs_locked(struct snd_usb_midi2_endpoint *ep,\n\t\t\t\t  int (*prepare)(struct snd_usb_midi2_endpoint *,\n\t\t\t\t\t\t struct urb *))\n{\n\tstruct snd_usb_midi2_urb *ctx;\n\tint index, err = 0;\n\n\tif (ep->disconnected)\n\t\treturn;\n\n\twhile (ep->urb_free) {\n\t\tindex = find_first_bit(&ep->urb_free, ep->num_urbs);\n\t\tif (index >= ep->num_urbs)\n\t\t\treturn;\n\t\tctx = &ep->urbs[index];\n\t\terr = prepare(ep, ctx->urb);\n\t\tif (err < 0)\n\t\t\treturn;\n\t\tif (!ctx->urb->transfer_buffer_length)\n\t\t\treturn;\n\t\tctx->urb->dev = ep->dev;\n\t\terr = usb_submit_urb(ctx->urb, GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(&ep->dev->dev,\n\t\t\t\t\"usb_submit_urb error %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(index, &ep->urb_free);\n\t}\n}\n\n \nstatic int prepare_output_urb(struct snd_usb_midi2_endpoint *ep,\n\t\t\t      struct urb *urb)\n{\n\tint count;\n\n\tcount = snd_ump_transmit(ep->ump, urb->transfer_buffer,\n\t\t\t\t ep->packets);\n\tif (count < 0) {\n\t\tdev_dbg(&ep->dev->dev, \"rawmidi transmit error %d\\n\", count);\n\t\treturn count;\n\t}\n\tcpu_to_le32_array((u32 *)urb->transfer_buffer, count >> 2);\n\turb->transfer_buffer_length = count;\n\treturn 0;\n}\n\nstatic void submit_output_urbs_locked(struct snd_usb_midi2_endpoint *ep)\n{\n\tdo_submit_urbs_locked(ep, prepare_output_urb);\n}\n\n \nstatic void output_urb_complete(struct urb *urb)\n{\n\tstruct snd_usb_midi2_urb *ctx = urb->context;\n\tstruct snd_usb_midi2_endpoint *ep = ctx->ep;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tset_bit(ctx->index, &ep->urb_free);\n\tif (urb->status >= 0 && atomic_read(&ep->running))\n\t\tsubmit_output_urbs_locked(ep);\n\tif (ep->urb_free == ep->urb_free_mask)\n\t\twake_up(&ep->wait);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic int prepare_input_urb(struct snd_usb_midi2_endpoint *ep,\n\t\t\t     struct urb *urb)\n{\n\turb->transfer_buffer_length = ep->packets;\n\treturn 0;\n}\n\nstatic void submit_input_urbs_locked(struct snd_usb_midi2_endpoint *ep)\n{\n\tdo_submit_urbs_locked(ep, prepare_input_urb);\n}\n\n \nstatic void input_urb_complete(struct urb *urb)\n{\n\tstruct snd_usb_midi2_urb *ctx = urb->context;\n\tstruct snd_usb_midi2_endpoint *ep = ctx->ep;\n\tunsigned long flags;\n\tint len;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep->disconnected || urb->status < 0)\n\t\tgoto dequeue;\n\tlen = urb->actual_length;\n\tlen &= ~3;  \n\tif (len > ep->packets)\n\t\tlen = ep->packets;\n\tif (len > 0) {\n\t\tle32_to_cpu_array((u32 *)urb->transfer_buffer, len >> 2);\n\t\tsnd_ump_receive(ep->ump, (u32 *)urb->transfer_buffer, len);\n\t}\n dequeue:\n\tset_bit(ctx->index, &ep->urb_free);\n\tsubmit_input_urbs_locked(ep);\n\tif (ep->urb_free == ep->urb_free_mask)\n\t\twake_up(&ep->wait);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic void submit_io_urbs(struct snd_usb_midi2_endpoint *ep)\n{\n\tunsigned long flags;\n\n\tif (!ep)\n\t\treturn;\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep->direction == STR_IN)\n\t\tsubmit_input_urbs_locked(ep);\n\telse\n\t\tsubmit_output_urbs_locked(ep);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic void kill_midi_urbs(struct snd_usb_midi2_endpoint *ep, bool suspending)\n{\n\tint i;\n\n\tif (!ep)\n\t\treturn;\n\tif (suspending)\n\t\tep->suspended = ep->running;\n\tatomic_set(&ep->running, 0);\n\tfor (i = 0; i < ep->num_urbs; i++) {\n\t\tif (!ep->urbs[i].urb)\n\t\t\tbreak;\n\t\tusb_kill_urb(ep->urbs[i].urb);\n\t}\n}\n\n \nstatic void drain_urb_queue(struct snd_usb_midi2_endpoint *ep)\n{\n\tif (!ep)\n\t\treturn;\n\tspin_lock_irq(&ep->lock);\n\tatomic_set(&ep->running, 0);\n\twait_event_lock_irq_timeout(ep->wait,\n\t\t\t\t    ep->disconnected ||\n\t\t\t\t    ep->urb_free == ep->urb_free_mask,\n\t\t\t\t    ep->lock, msecs_to_jiffies(500));\n\tspin_unlock_irq(&ep->lock);\n}\n\n \nstatic void free_midi_urbs(struct snd_usb_midi2_endpoint *ep)\n{\n\tstruct snd_usb_midi2_urb *ctx;\n\tint i;\n\n\tif (!ep)\n\t\treturn;\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tctx = &ep->urbs[i];\n\t\tif (!ctx->urb)\n\t\t\tbreak;\n\t\tusb_free_coherent(ep->dev, ep->packets,\n\t\t\t\t  ctx->urb->transfer_buffer,\n\t\t\t\t  ctx->urb->transfer_dma);\n\t\tusb_free_urb(ctx->urb);\n\t\tctx->urb = NULL;\n\t}\n\tep->num_urbs = 0;\n}\n\n \n \nstatic int alloc_midi_urbs(struct snd_usb_midi2_endpoint *ep)\n{\n\tstruct snd_usb_midi2_urb *ctx;\n\tvoid (*comp)(struct urb *urb);\n\tvoid *buffer;\n\tint i, err;\n\tint endpoint, len;\n\n\tendpoint = ep->endpoint;\n\tlen = ep->packets;\n\tif (ep->direction == STR_IN)\n\t\tcomp = input_urb_complete;\n\telse\n\t\tcomp = output_urb_complete;\n\n\tep->num_urbs = 0;\n\tep->urb_free = ep->urb_free_mask = 0;\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\tctx = &ep->urbs[i];\n\t\tctx->index = i;\n\t\tctx->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ctx->urb) {\n\t\t\tdev_err(&ep->dev->dev, \"URB alloc failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tctx->ep = ep;\n\t\tbuffer = usb_alloc_coherent(ep->dev, len, GFP_KERNEL,\n\t\t\t\t\t    &ctx->urb->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tdev_err(&ep->dev->dev,\n\t\t\t\t\"URB buffer alloc failed (size %d)\\n\", len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ep->interval)\n\t\t\tusb_fill_int_urb(ctx->urb, ep->dev, ep->pipe,\n\t\t\t\t\t buffer, len, comp, ctx, ep->interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ctx->urb, ep->dev, ep->pipe,\n\t\t\t\t\t  buffer, len, comp, ctx);\n\t\terr = usb_urb_ep_type_check(ctx->urb);\n\t\tif (err < 0) {\n\t\t\tdev_err(&ep->dev->dev, \"invalid MIDI EP %x\\n\",\n\t\t\t\tendpoint);\n\t\t\treturn err;\n\t\t}\n\t\tctx->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tep->num_urbs++;\n\t}\n\tep->urb_free = ep->urb_free_mask = GENMASK(ep->num_urbs - 1, 0);\n\treturn 0;\n}\n\nstatic struct snd_usb_midi2_endpoint *\nump_to_endpoint(struct snd_ump_endpoint *ump, int dir)\n{\n\tstruct snd_usb_midi2_ump *rmidi = ump->private_data;\n\n\treturn rmidi->eps[dir];\n}\n\n \nstatic int snd_usb_midi_v2_open(struct snd_ump_endpoint *ump, int dir)\n{\n\tstruct snd_usb_midi2_endpoint *ep = ump_to_endpoint(ump, dir);\n\tint err = 0;\n\n\tif (!ep || !ep->endpoint)\n\t\treturn -ENODEV;\n\tif (ep->disconnected)\n\t\treturn -EIO;\n\tif (ep->direction == STR_OUT) {\n\t\terr = alloc_midi_urbs(ep);\n\t\tif (err) {\n\t\t\tfree_midi_urbs(ep);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void snd_usb_midi_v2_close(struct snd_ump_endpoint *ump, int dir)\n{\n\tstruct snd_usb_midi2_endpoint *ep = ump_to_endpoint(ump, dir);\n\n\tif (ep->direction == STR_OUT) {\n\t\tkill_midi_urbs(ep, false);\n\t\tdrain_urb_queue(ep);\n\t\tfree_midi_urbs(ep);\n\t}\n}\n\n \nstatic void snd_usb_midi_v2_trigger(struct snd_ump_endpoint *ump, int dir,\n\t\t\t\t    int up)\n{\n\tstruct snd_usb_midi2_endpoint *ep = ump_to_endpoint(ump, dir);\n\n\tatomic_set(&ep->running, up);\n\tif (up && ep->direction == STR_OUT && !ep->disconnected)\n\t\tsubmit_io_urbs(ep);\n}\n\n \nstatic void snd_usb_midi_v2_drain(struct snd_ump_endpoint *ump, int dir)\n{\n\tstruct snd_usb_midi2_endpoint *ep = ump_to_endpoint(ump, dir);\n\n\tdrain_urb_queue(ep);\n}\n\n \nstatic int start_input_streams(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_endpoint *ep;\n\tint err;\n\n\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\tif (ep->direction == STR_IN) {\n\t\t\terr = alloc_midi_urbs(ep);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\tif (ep->direction == STR_IN)\n\t\t\tsubmit_io_urbs(ep);\n\t}\n\n\treturn 0;\n\n error:\n\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\tif (ep->direction == STR_IN)\n\t\t\tfree_midi_urbs(ep);\n\t}\n\n\treturn err;\n}\n\nstatic const struct snd_ump_ops snd_usb_midi_v2_ump_ops = {\n\t.open = snd_usb_midi_v2_open,\n\t.close = snd_usb_midi_v2_close,\n\t.trigger = snd_usb_midi_v2_trigger,\n\t.drain = snd_usb_midi_v2_drain,\n};\n\n \nstatic int create_midi2_endpoint(struct snd_usb_midi2_interface *umidi,\n\t\t\t\t struct usb_host_endpoint *hostep,\n\t\t\t\t const struct usb_ms20_endpoint_descriptor *ms_ep)\n{\n\tstruct snd_usb_midi2_endpoint *ep;\n\tint endpoint, dir;\n\n\tusb_audio_dbg(umidi->chip, \"Creating an EP 0x%02x, #GTB=%d\\n\",\n\t\t      hostep->desc.bEndpointAddress,\n\t\t      ms_ep->bNumGrpTrmBlock);\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ep->lock);\n\tinit_waitqueue_head(&ep->wait);\n\tep->dev = umidi->chip->dev;\n\tendpoint = hostep->desc.bEndpointAddress;\n\tdir = (endpoint & USB_DIR_IN) ? STR_IN : STR_OUT;\n\n\tep->endpoint = endpoint;\n\tep->direction = dir;\n\tep->ms_ep = ms_ep;\n\tif (usb_endpoint_xfer_int(&hostep->desc))\n\t\tep->interval = hostep->desc.bInterval;\n\telse\n\t\tep->interval = 0;\n\tif (dir == STR_IN) {\n\t\tif (ep->interval)\n\t\t\tep->pipe = usb_rcvintpipe(ep->dev, endpoint);\n\t\telse\n\t\t\tep->pipe = usb_rcvbulkpipe(ep->dev, endpoint);\n\t} else {\n\t\tif (ep->interval)\n\t\t\tep->pipe = usb_sndintpipe(ep->dev, endpoint);\n\t\telse\n\t\t\tep->pipe = usb_sndbulkpipe(ep->dev, endpoint);\n\t}\n\tep->packets = usb_maxpacket(ep->dev, ep->pipe);\n\tlist_add_tail(&ep->list, &umidi->ep_list);\n\n\treturn 0;\n}\n\n \nstatic void free_midi2_endpoint(struct snd_usb_midi2_endpoint *ep)\n{\n\tlist_del(&ep->list);\n\tfree_midi_urbs(ep);\n\tkfree(ep);\n}\n\n \nstatic void free_all_midi2_endpoints(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_endpoint *ep;\n\n\twhile (!list_empty(&umidi->ep_list)) {\n\t\tep = list_first_entry(&umidi->ep_list,\n\t\t\t\t      struct snd_usb_midi2_endpoint, list);\n\t\tfree_midi2_endpoint(ep);\n\t}\n}\n\n \nstatic void *find_usb_ms_endpoint_descriptor(struct usb_host_endpoint *hostep,\n\t\t\t\t\t     unsigned char subtype)\n{\n\tunsigned char *extra = hostep->extra;\n\tint extralen = hostep->extralen;\n\n\twhile (extralen > 3) {\n\t\tstruct usb_ms_endpoint_descriptor *ms_ep =\n\t\t\t(struct usb_ms_endpoint_descriptor *)extra;\n\n\t\tif (ms_ep->bLength > 3 &&\n\t\t    ms_ep->bDescriptorType == USB_DT_CS_ENDPOINT &&\n\t\t    ms_ep->bDescriptorSubtype == subtype)\n\t\t\treturn ms_ep;\n\t\tif (!extra[0])\n\t\t\tbreak;\n\t\textralen -= extra[0];\n\t\textra += extra[0];\n\t}\n\treturn NULL;\n}\n\n \nstatic int get_group_terminal_block_descs(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct usb_host_interface *hostif = umidi->hostif;\n\tstruct usb_device *dev = umidi->chip->dev;\n\tstruct usb_ms20_gr_trm_block_header_descriptor header = { 0 };\n\tunsigned char *data;\n\tint err, size;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      USB_REQ_GET_DESCRIPTOR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_STANDARD | USB_DIR_IN,\n\t\t\t      USB_DT_CS_GR_TRM_BLOCK << 8 | hostif->desc.bAlternateSetting,\n\t\t\t      hostif->desc.bInterfaceNumber,\n\t\t\t      &header, sizeof(header));\n\tif (err < 0)\n\t\treturn err;\n\tsize = __le16_to_cpu(header.wTotalLength);\n\tif (!size) {\n\t\tdev_err(&dev->dev, \"Failed to get GTB descriptors for %d:%d\\n\",\n\t\t\thostif->desc.bInterfaceNumber, hostif->desc.bAlternateSetting);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\terr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      USB_REQ_GET_DESCRIPTOR,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_STANDARD | USB_DIR_IN,\n\t\t\t      USB_DT_CS_GR_TRM_BLOCK << 8 | hostif->desc.bAlternateSetting,\n\t\t\t      hostif->desc.bInterfaceNumber, data, size);\n\tif (err < 0) {\n\t\tkfree(data);\n\t\treturn err;\n\t}\n\n\tumidi->blk_descs = data;\n\tumidi->blk_desc_size = size;\n\treturn 0;\n}\n\n \nstatic const struct usb_ms20_gr_trm_block_descriptor *\nfind_group_terminal_block(struct snd_usb_midi2_interface *umidi, int id)\n{\n\tconst unsigned char *data = umidi->blk_descs;\n\tint size = umidi->blk_desc_size;\n\tconst struct usb_ms20_gr_trm_block_descriptor *desc;\n\n\tsize -= sizeof(struct usb_ms20_gr_trm_block_header_descriptor);\n\tdata += sizeof(struct usb_ms20_gr_trm_block_header_descriptor);\n\twhile (size > 0 && *data && *data <= size) {\n\t\tdesc = (const struct usb_ms20_gr_trm_block_descriptor *)data;\n\t\tif (desc->bLength >= sizeof(*desc) &&\n\t\t    desc->bDescriptorType == USB_DT_CS_GR_TRM_BLOCK &&\n\t\t    desc->bDescriptorSubtype == USB_MS_GR_TRM_BLOCK &&\n\t\t    desc->bGrpTrmBlkID == id)\n\t\t\treturn desc;\n\t\tsize -= *data;\n\t\tdata += *data;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int parse_group_terminal_block(struct snd_usb_midi2_ump *rmidi,\n\t\t\t\t      const struct usb_ms20_gr_trm_block_descriptor *desc)\n{\n\tstruct snd_ump_endpoint *ump = rmidi->ump;\n\tunsigned int protocol, protocol_caps;\n\n\t \n\tswitch (desc->bMIDIProtocol) {\n\tcase USB_MS_MIDI_PROTO_1_0_64:\n\tcase USB_MS_MIDI_PROTO_1_0_64_JRTS:\n\tcase USB_MS_MIDI_PROTO_1_0_128:\n\tcase USB_MS_MIDI_PROTO_1_0_128_JRTS:\n\t\tprotocol = SNDRV_UMP_EP_INFO_PROTO_MIDI1;\n\t\tbreak;\n\tcase USB_MS_MIDI_PROTO_2_0:\n\tcase USB_MS_MIDI_PROTO_2_0_JRTS:\n\t\tprotocol = SNDRV_UMP_EP_INFO_PROTO_MIDI2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (ump->info.protocol && ump->info.protocol != protocol)\n\t\tusb_audio_info(rmidi->umidi->chip,\n\t\t\t       \"Overriding preferred MIDI protocol in GTB %d: %x -> %x\\n\",\n\t\t\t       rmidi->usb_block_id, ump->info.protocol,\n\t\t\t       protocol);\n\tump->info.protocol = protocol;\n\n\tprotocol_caps = protocol;\n\tswitch (desc->bMIDIProtocol) {\n\tcase USB_MS_MIDI_PROTO_1_0_64_JRTS:\n\tcase USB_MS_MIDI_PROTO_1_0_128_JRTS:\n\tcase USB_MS_MIDI_PROTO_2_0_JRTS:\n\t\tprotocol_caps |= SNDRV_UMP_EP_INFO_PROTO_JRTS_TX |\n\t\t\tSNDRV_UMP_EP_INFO_PROTO_JRTS_RX;\n\t\tbreak;\n\t}\n\n\tif (ump->info.protocol_caps && ump->info.protocol_caps != protocol_caps)\n\t\tusb_audio_info(rmidi->umidi->chip,\n\t\t\t       \"Overriding MIDI protocol caps in GTB %d: %x -> %x\\n\",\n\t\t\t       rmidi->usb_block_id, ump->info.protocol_caps,\n\t\t\t       protocol_caps);\n\tump->info.protocol_caps = protocol_caps;\n\n\treturn 0;\n}\n\n \nstatic int parse_group_terminal_blocks(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\tconst struct usb_ms20_gr_trm_block_descriptor *desc;\n\tint err;\n\n\terr = get_group_terminal_block_descs(umidi);\n\tif (err < 0)\n\t\treturn err;\n\tif (!umidi->blk_descs)\n\t\treturn 0;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\tdesc = find_group_terminal_block(umidi, rmidi->usb_block_id);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\terr = parse_group_terminal_block(rmidi, desc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int parse_midi_2_0_endpoints(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct usb_host_interface *hostif = umidi->hostif;\n\tstruct usb_host_endpoint *hostep;\n\tstruct usb_ms20_endpoint_descriptor *ms_ep;\n\tint i, err;\n\n\tfor (i = 0; i < hostif->desc.bNumEndpoints; i++) {\n\t\thostep = &hostif->endpoint[i];\n\t\tif (!usb_endpoint_xfer_bulk(&hostep->desc) &&\n\t\t    !usb_endpoint_xfer_int(&hostep->desc))\n\t\t\tcontinue;\n\t\tms_ep = find_usb_ms_endpoint_descriptor(hostep, USB_MS_GENERAL_2_0);\n\t\tif (!ms_ep)\n\t\t\tcontinue;\n\t\tif (ms_ep->bLength <= sizeof(*ms_ep))\n\t\t\tcontinue;\n\t\tif (!ms_ep->bNumGrpTrmBlock)\n\t\t\tcontinue;\n\t\tif (ms_ep->bLength < sizeof(*ms_ep) + ms_ep->bNumGrpTrmBlock)\n\t\t\tcontinue;\n\t\terr = create_midi2_endpoint(umidi, hostep, ms_ep);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void free_all_midi2_umps(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\n\twhile (!list_empty(&umidi->rawmidi_list)) {\n\t\trmidi = list_first_entry(&umidi->rawmidi_list,\n\t\t\t\t\t struct snd_usb_midi2_ump, list);\n\t\tlist_del(&rmidi->list);\n\t\tkfree(rmidi);\n\t}\n}\n\nstatic int create_midi2_ump(struct snd_usb_midi2_interface *umidi,\n\t\t\t    struct snd_usb_midi2_endpoint *ep_in,\n\t\t\t    struct snd_usb_midi2_endpoint *ep_out,\n\t\t\t    int blk_id)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\tstruct snd_ump_endpoint *ump;\n\tint input, output;\n\tchar idstr[16];\n\tint err;\n\n\trmidi = kzalloc(sizeof(*rmidi), GFP_KERNEL);\n\tif (!rmidi)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&rmidi->list);\n\trmidi->dev = umidi->chip->dev;\n\trmidi->umidi = umidi;\n\trmidi->usb_block_id = blk_id;\n\n\trmidi->index = umidi->chip->num_rawmidis;\n\tsnprintf(idstr, sizeof(idstr), \"UMP %d\", rmidi->index);\n\tinput = ep_in ? 1 : 0;\n\toutput = ep_out ? 1 : 0;\n\terr = snd_ump_endpoint_new(umidi->chip->card, idstr, rmidi->index,\n\t\t\t\t   output, input, &ump);\n\tif (err < 0) {\n\t\tusb_audio_dbg(umidi->chip, \"Failed to create a UMP object\\n\");\n\t\tkfree(rmidi);\n\t\treturn err;\n\t}\n\n\trmidi->ump = ump;\n\tumidi->chip->num_rawmidis++;\n\n\tump->private_data = rmidi;\n\tump->ops = &snd_usb_midi_v2_ump_ops;\n\n\trmidi->eps[STR_IN] = ep_in;\n\trmidi->eps[STR_OUT] = ep_out;\n\tif (ep_in) {\n\t\tep_in->pair = ep_out;\n\t\tep_in->rmidi = rmidi;\n\t\tep_in->ump = ump;\n\t}\n\tif (ep_out) {\n\t\tep_out->pair = ep_in;\n\t\tep_out->rmidi = rmidi;\n\t\tep_out->ump = ump;\n\t}\n\n\tlist_add_tail(&rmidi->list, &umidi->rawmidi_list);\n\treturn 0;\n}\n\n \nstatic struct snd_usb_midi2_ump *\nfind_midi2_ump(struct snd_usb_midi2_interface *umidi, int blk_id)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\tif (rmidi->usb_block_id == blk_id)\n\t\t\treturn rmidi;\n\t}\n\treturn NULL;\n}\n\n \nstatic int find_matching_ep_partner(struct snd_usb_midi2_interface *umidi,\n\t\t\t\t    struct snd_usb_midi2_endpoint *ep,\n\t\t\t\t    int blk_id)\n{\n\tstruct snd_usb_midi2_endpoint *pair_ep;\n\tint blk;\n\n\tusb_audio_dbg(umidi->chip, \"Looking for a pair for EP-in 0x%02x\\n\",\n\t\t      ep->endpoint);\n\tlist_for_each_entry(pair_ep, &umidi->ep_list, list) {\n\t\tif (pair_ep->direction != STR_OUT)\n\t\t\tcontinue;\n\t\tif (pair_ep->pair)\n\t\t\tcontinue;  \n\t\tfor (blk = 0; blk < pair_ep->ms_ep->bNumGrpTrmBlock; blk++) {\n\t\t\tif (pair_ep->ms_ep->baAssoGrpTrmBlkID[blk] == blk_id) {\n\t\t\t\tusb_audio_dbg(umidi->chip,\n\t\t\t\t\t      \"Found a match with EP-out 0x%02x blk %d\\n\",\n\t\t\t\t\t      pair_ep->endpoint, blk);\n\t\t\t\treturn create_midi2_ump(umidi, ep, pair_ep, blk_id);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int parse_ump_endpoints(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\tint err;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\tif (!rmidi->ump ||\n\t\t    !(rmidi->ump->core.info_flags & SNDRV_RAWMIDI_INFO_DUPLEX))\n\t\t\tcontinue;\n\t\terr = snd_ump_parse_endpoint(rmidi->ump);\n\t\tif (!err) {\n\t\t\trmidi->ump_parsed = true;\n\t\t} else {\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn err;\n\t\t\t \n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int create_gtb_block(struct snd_usb_midi2_ump *rmidi, int dir, int blk)\n{\n\tstruct snd_usb_midi2_interface *umidi = rmidi->umidi;\n\tconst struct usb_ms20_gr_trm_block_descriptor *desc;\n\tstruct snd_ump_block *fb;\n\tint type, err;\n\n\tdesc = find_group_terminal_block(umidi, blk);\n\tif (!desc)\n\t\treturn 0;\n\n\tusb_audio_dbg(umidi->chip,\n\t\t      \"GTB %d: type=%d, group=%d/%d, protocol=%d, in bw=%d, out bw=%d\\n\",\n\t\t      blk, desc->bGrpTrmBlkType, desc->nGroupTrm,\n\t\t      desc->nNumGroupTrm, desc->bMIDIProtocol,\n\t\t      __le16_to_cpu(desc->wMaxInputBandwidth),\n\t\t      __le16_to_cpu(desc->wMaxOutputBandwidth));\n\n\t \n\tswitch (desc->bGrpTrmBlkType) {\n\tcase USB_MS_GR_TRM_BLOCK_TYPE_BIDIRECTIONAL:\n\t\ttype = SNDRV_UMP_DIR_BIDIRECTION;\n\t\tbreak;\n\tcase USB_MS_GR_TRM_BLOCK_TYPE_INPUT_ONLY:\n\t\ttype = SNDRV_UMP_DIR_INPUT;\n\t\tbreak;\n\tcase USB_MS_GR_TRM_BLOCK_TYPE_OUTPUT_ONLY:\n\t\ttype = SNDRV_UMP_DIR_OUTPUT;\n\t\tbreak;\n\tdefault:\n\t\tusb_audio_dbg(umidi->chip, \"Unsupported GTB type %d\\n\",\n\t\t\t      desc->bGrpTrmBlkType);\n\t\treturn 0;  \n\t}\n\n\t \n\terr = snd_ump_block_new(rmidi->ump, blk - 1, type,\n\t\t\t\tdesc->nGroupTrm, desc->nNumGroupTrm,\n\t\t\t\t&fb);\n\tif (err == -EBUSY)\n\t\treturn 0;  \n\telse if (err)\n\t\treturn err;\n\n\tif (desc->iBlockItem)\n\t\tusb_string(rmidi->dev, desc->iBlockItem,\n\t\t\t   fb->info.name, sizeof(fb->info.name));\n\n\tif (__le16_to_cpu(desc->wMaxInputBandwidth) == 1 ||\n\t    __le16_to_cpu(desc->wMaxOutputBandwidth) == 1)\n\t\tfb->info.flags |= SNDRV_UMP_BLOCK_IS_MIDI1 |\n\t\t\tSNDRV_UMP_BLOCK_IS_LOWSPEED;\n\n\tusb_audio_dbg(umidi->chip,\n\t\t      \"Created a UMP block %d from GTB, name=%s\\n\",\n\t\t      blk, fb->info.name);\n\treturn 0;\n}\n\n \nstatic int create_blocks_from_gtb(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_ump *rmidi;\n\tint i, blk, err, dir;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\tif (!rmidi->ump)\n\t\t\tcontinue;\n\t\t \n\t\tif (rmidi->ump_parsed || rmidi->ump->info.num_blocks)\n\t\t\tcontinue;\n\t\t \n\t\trmidi->ump->info.flags |= SNDRV_UMP_EP_INFO_STATIC_BLOCKS;\n\t\t \n\t\tfor (dir = 0; dir < 2; dir++) {\n\t\t\tif (!rmidi->eps[dir])\n\t\t\t\tcontinue;\n\t\t\tfor (i = 0; i < rmidi->eps[dir]->ms_ep->bNumGrpTrmBlock; i++) {\n\t\t\t\tblk = rmidi->eps[dir]->ms_ep->baAssoGrpTrmBlkID[i];\n\t\t\t\terr = create_gtb_block(rmidi, dir, blk);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int attach_legacy_rawmidi(struct snd_usb_midi2_interface *umidi)\n{\n#if IS_ENABLED(CONFIG_SND_UMP_LEGACY_RAWMIDI)\n\tstruct snd_usb_midi2_ump *rmidi;\n\tint err;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\terr = snd_ump_attach_legacy_rawmidi(rmidi->ump,\n\t\t\t\t\t\t    \"Legacy MIDI\",\n\t\t\t\t\t\t    umidi->chip->num_rawmidis);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tumidi->chip->num_rawmidis++;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void snd_usb_midi_v2_free(struct snd_usb_midi2_interface *umidi)\n{\n\tfree_all_midi2_endpoints(umidi);\n\tfree_all_midi2_umps(umidi);\n\tlist_del(&umidi->list);\n\tkfree(umidi->blk_descs);\n\tkfree(umidi);\n}\n\n \nstatic int parse_midi_2_0(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct snd_usb_midi2_endpoint *ep;\n\tint blk, id, err;\n\n\t \n\terr = parse_midi_2_0_endpoints(umidi);\n\tif (err < 0)\n\t\treturn err;\n\tif (list_empty(&umidi->ep_list)) {\n\t\tusb_audio_warn(umidi->chip, \"No MIDI endpoints found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\t \n\t\tif (ep->direction != STR_IN)\n\t\t\tcontinue;\n\t\tfor (blk = 0; blk < ep->ms_ep->bNumGrpTrmBlock; blk++) {\n\t\t\tid = ep->ms_ep->baAssoGrpTrmBlkID[blk];\n\t\t\terr = find_matching_ep_partner(umidi, ep, id);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\tif (ep->rmidi)\n\t\t\tcontinue;  \n\t\tfor (blk = 0; blk < ep->ms_ep->bNumGrpTrmBlock; blk++) {\n\t\t\tid = ep->ms_ep->baAssoGrpTrmBlkID[blk];\n\t\t\tif (find_midi2_ump(umidi, id))\n\t\t\t\tcontinue;\n\t\t\tusb_audio_dbg(umidi->chip,\n\t\t\t\t      \"Creating a unidirection UMP for EP=0x%02x, blk=%d\\n\",\n\t\t\t\t      ep->endpoint, id);\n\t\t\tif (ep->direction == STR_IN)\n\t\t\t\terr = create_midi2_ump(umidi, ep, NULL, id);\n\t\t\telse\n\t\t\t\terr = create_midi2_ump(umidi, NULL, ep, id);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool is_midi2_altset(struct usb_host_interface *hostif)\n{\n\tstruct usb_ms_header_descriptor *ms_header =\n\t\t(struct usb_ms_header_descriptor *)hostif->extra;\n\n\tif (hostif->extralen < 7 ||\n\t    ms_header->bLength < 7 ||\n\t    ms_header->bDescriptorType != USB_DT_CS_INTERFACE ||\n\t    ms_header->bDescriptorSubtype != UAC_HEADER)\n\t\treturn false;\n\n\treturn le16_to_cpu(ms_header->bcdMSC) == USB_MS_REV_MIDI_2_0;\n}\n\n \nstatic int set_altset(struct snd_usb_midi2_interface *umidi)\n{\n\tusb_audio_dbg(umidi->chip, \"Setting host iface %d:%d\\n\",\n\t\t      umidi->hostif->desc.bInterfaceNumber,\n\t\t      umidi->hostif->desc.bAlternateSetting);\n\treturn usb_set_interface(umidi->chip->dev,\n\t\t\t\t umidi->hostif->desc.bInterfaceNumber,\n\t\t\t\t umidi->hostif->desc.bAlternateSetting);\n}\n\n \nstatic void fill_ump_ep_name(struct snd_ump_endpoint *ump,\n\t\t\t     struct usb_device *dev, int id)\n{\n\tint len;\n\n\tusb_string(dev, id, ump->info.name, sizeof(ump->info.name));\n\n\t \n\tlen = strlen(ump->info.name);\n\tif (len > 5 && !strcmp(ump->info.name + len - 5, \" MIDI\"))\n\t\tump->info.name[len - 5] = 0;\n}\n\n \nstatic void set_fallback_rawmidi_names(struct snd_usb_midi2_interface *umidi)\n{\n\tstruct usb_device *dev = umidi->chip->dev;\n\tstruct snd_usb_midi2_ump *rmidi;\n\tstruct snd_ump_endpoint *ump;\n\n\tlist_for_each_entry(rmidi, &umidi->rawmidi_list, list) {\n\t\tump = rmidi->ump;\n\t\t \n\t\tif (!*ump->info.name && umidi->hostif->desc.iInterface)\n\t\t\tfill_ump_ep_name(ump, dev, umidi->hostif->desc.iInterface);\n\t\telse if (!*ump->info.name && dev->descriptor.iProduct)\n\t\t\tfill_ump_ep_name(ump, dev, dev->descriptor.iProduct);\n\t\t \n\t\tif (!*ump->info.name)\n\t\t\tsprintf(ump->info.name, \"USB MIDI %d\", rmidi->index);\n\t\t \n\t\tif (!*ump->core.name)\n\t\t\tstrscpy(ump->core.name, ump->info.name,\n\t\t\t\tsizeof(ump->core.name));\n\t\t \n\t\tif (!*ump->info.product_id && dev->descriptor.iSerialNumber)\n\t\t\tusb_string(dev, dev->descriptor.iSerialNumber,\n\t\t\t\t   ump->info.product_id,\n\t\t\t\t   sizeof(ump->info.product_id));\n\t}\n}\n\n \nint snd_usb_midi_v2_create(struct snd_usb_audio *chip,\n\t\t\t   struct usb_interface *iface,\n\t\t\t   const struct snd_usb_audio_quirk *quirk,\n\t\t\t   unsigned int usb_id)\n{\n\tstruct snd_usb_midi2_interface *umidi;\n\tstruct usb_host_interface *hostif;\n\tint err;\n\n\tusb_audio_dbg(chip, \"Parsing interface %d...\\n\",\n\t\t      iface->altsetting[0].desc.bInterfaceNumber);\n\n\t \n\tif (!midi2_enable) {\n\t\tusb_audio_info(chip, \"Falling back to MIDI 1.0 by module option\\n\");\n\t\tgoto fallback_to_midi1;\n\t}\n\tif ((quirk && quirk->type != QUIRK_MIDI_STANDARD_INTERFACE) ||\n\t    iface->num_altsetting < 2) {\n\t\tusb_audio_info(chip, \"Quirk or no altest; falling back to MIDI 1.0\\n\");\n\t\tgoto fallback_to_midi1;\n\t}\n\thostif = &iface->altsetting[1];\n\tif (!is_midi2_altset(hostif)) {\n\t\tusb_audio_info(chip, \"No MIDI 2.0 at altset 1, falling back to MIDI 1.0\\n\");\n\t\tgoto fallback_to_midi1;\n\t}\n\tif (!hostif->desc.bNumEndpoints) {\n\t\tusb_audio_info(chip, \"No endpoint at altset 1, falling back to MIDI 1.0\\n\");\n\t\tgoto fallback_to_midi1;\n\t}\n\n\tusb_audio_dbg(chip, \"Creating a MIDI 2.0 instance for %d:%d\\n\",\n\t\t      hostif->desc.bInterfaceNumber,\n\t\t      hostif->desc.bAlternateSetting);\n\n\tumidi = kzalloc(sizeof(*umidi), GFP_KERNEL);\n\tif (!umidi)\n\t\treturn -ENOMEM;\n\tumidi->chip = chip;\n\tumidi->iface = iface;\n\tumidi->hostif = hostif;\n\tINIT_LIST_HEAD(&umidi->rawmidi_list);\n\tINIT_LIST_HEAD(&umidi->ep_list);\n\n\tlist_add_tail(&umidi->list, &chip->midi_v2_list);\n\n\terr = set_altset(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to set altset\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\terr = parse_midi_2_0(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to parse MIDI 2.0 interface\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\terr = parse_group_terminal_blocks(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to parse GTB\\n\");\n\t\tgoto error;\n\t}\n\n\terr = start_input_streams(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to start input streams\\n\");\n\t\tgoto error;\n\t}\n\n\tif (midi2_ump_probe) {\n\t\terr = parse_ump_endpoints(umidi);\n\t\tif (err < 0) {\n\t\t\tusb_audio_err(chip, \"Failed to parse UMP endpoint\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\terr = create_blocks_from_gtb(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to create GTB blocks\\n\");\n\t\tgoto error;\n\t}\n\n\tset_fallback_rawmidi_names(umidi);\n\n\terr = attach_legacy_rawmidi(umidi);\n\tif (err < 0) {\n\t\tusb_audio_err(chip, \"Failed to create legacy rawmidi\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n error:\n\tsnd_usb_midi_v2_free(umidi);\n\treturn err;\n\n fallback_to_midi1:\n\treturn __snd_usbmidi_create(chip->card, iface, &chip->midi_list,\n\t\t\t\t    quirk, usb_id, &chip->num_rawmidis);\n}\n\nstatic void suspend_midi2_endpoint(struct snd_usb_midi2_endpoint *ep)\n{\n\tkill_midi_urbs(ep, true);\n\tdrain_urb_queue(ep);\n}\n\nvoid snd_usb_midi_v2_suspend_all(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_midi2_interface *umidi;\n\tstruct snd_usb_midi2_endpoint *ep;\n\n\tlist_for_each_entry(umidi, &chip->midi_v2_list, list) {\n\t\tlist_for_each_entry(ep, &umidi->ep_list, list)\n\t\t\tsuspend_midi2_endpoint(ep);\n\t}\n}\n\nstatic void resume_midi2_endpoint(struct snd_usb_midi2_endpoint *ep)\n{\n\tep->running = ep->suspended;\n\tif (ep->direction == STR_IN)\n\t\tsubmit_io_urbs(ep);\n\t \n}\n\nvoid snd_usb_midi_v2_resume_all(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_midi2_interface *umidi;\n\tstruct snd_usb_midi2_endpoint *ep;\n\n\tlist_for_each_entry(umidi, &chip->midi_v2_list, list) {\n\t\tset_altset(umidi);\n\t\tlist_for_each_entry(ep, &umidi->ep_list, list)\n\t\t\tresume_midi2_endpoint(ep);\n\t}\n}\n\nvoid snd_usb_midi_v2_disconnect_all(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_midi2_interface *umidi;\n\tstruct snd_usb_midi2_endpoint *ep;\n\n\tlist_for_each_entry(umidi, &chip->midi_v2_list, list) {\n\t\tumidi->disconnected = 1;\n\t\tlist_for_each_entry(ep, &umidi->ep_list, list) {\n\t\t\tep->disconnected = 1;\n\t\t\tkill_midi_urbs(ep, false);\n\t\t\tdrain_urb_queue(ep);\n\t\t}\n\t}\n}\n\n \nvoid snd_usb_midi_v2_free_all(struct snd_usb_audio *chip)\n{\n\tstruct snd_usb_midi2_interface *umidi, *next;\n\n\tlist_for_each_entry_safe(umidi, next, &chip->midi_v2_list, list)\n\t\tsnd_usb_midi_v2_free(umidi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}