{
  "module_name": "hdac_controller.c",
  "hash_id": "82d8b35b3e5728895bd1a3824776f8a27ff49f4ec83b86e0850b6fd60f3067ee",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_controller.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_register.h>\n#include \"local.h\"\n\n \nstatic void azx_clear_corbrp(struct hdac_bus *bus)\n{\n\tint timeout;\n\n\tfor (timeout = 1000; timeout > 0; timeout--) {\n\t\tif (snd_hdac_chip_readw(bus, CORBRP) & AZX_CORBRP_RST)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (timeout <= 0)\n\t\tdev_err(bus->dev, \"CORB reset timeout#1, CORBRP = %d\\n\",\n\t\t\tsnd_hdac_chip_readw(bus, CORBRP));\n\n\tsnd_hdac_chip_writew(bus, CORBRP, 0);\n\tfor (timeout = 1000; timeout > 0; timeout--) {\n\t\tif (snd_hdac_chip_readw(bus, CORBRP) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (timeout <= 0)\n\t\tdev_err(bus->dev, \"CORB reset timeout#2, CORBRP = %d\\n\",\n\t\t\tsnd_hdac_chip_readw(bus, CORBRP));\n}\n\n \nvoid snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)\n{\n\tWARN_ON_ONCE(!bus->rb.area);\n\n\tspin_lock_irq(&bus->reg_lock);\n\t \n\tbus->corb.addr = bus->rb.addr;\n\tbus->corb.buf = (__le32 *)bus->rb.area;\n\tsnd_hdac_chip_writel(bus, CORBLBASE, (u32)bus->corb.addr);\n\tsnd_hdac_chip_writel(bus, CORBUBASE, upper_32_bits(bus->corb.addr));\n\n\t \n\tsnd_hdac_chip_writeb(bus, CORBSIZE, 0x02);\n\t \n\tsnd_hdac_chip_writew(bus, CORBWP, 0);\n\n\t \n\tsnd_hdac_chip_writew(bus, CORBRP, AZX_CORBRP_RST);\n\tif (!bus->corbrp_self_clear)\n\t\tazx_clear_corbrp(bus);\n\n\t \n\tsnd_hdac_chip_writeb(bus, CORBCTL, AZX_CORBCTL_RUN);\n\n\t \n\tbus->rirb.addr = bus->rb.addr + 2048;\n\tbus->rirb.buf = (__le32 *)(bus->rb.area + 2048);\n\tbus->rirb.wp = bus->rirb.rp = 0;\n\tmemset(bus->rirb.cmds, 0, sizeof(bus->rirb.cmds));\n\tsnd_hdac_chip_writel(bus, RIRBLBASE, (u32)bus->rirb.addr);\n\tsnd_hdac_chip_writel(bus, RIRBUBASE, upper_32_bits(bus->rirb.addr));\n\n\t \n\tsnd_hdac_chip_writeb(bus, RIRBSIZE, 0x02);\n\t \n\tsnd_hdac_chip_writew(bus, RIRBWP, AZX_RIRBWP_RST);\n\t \n\tsnd_hdac_chip_writew(bus, RINTCNT, 1);\n\t \n\tif (bus->not_use_interrupts)\n\t\tsnd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN);\n\telse\n\t\tsnd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);\n\t \n\tsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);\n\tspin_unlock_irq(&bus->reg_lock);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_init_cmd_io);\n\n \nstatic void hdac_wait_for_cmd_dmas(struct hdac_bus *bus)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile ((snd_hdac_chip_readb(bus, RIRBCTL) & AZX_RBCTL_DMA_EN)\n\t\t&& time_before(jiffies, timeout))\n\t\tudelay(10);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile ((snd_hdac_chip_readb(bus, CORBCTL) & AZX_CORBCTL_RUN)\n\t\t&& time_before(jiffies, timeout))\n\t\tudelay(10);\n}\n\n \nvoid snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus)\n{\n\tspin_lock_irq(&bus->reg_lock);\n\t \n\tsnd_hdac_chip_writeb(bus, RIRBCTL, 0);\n\tsnd_hdac_chip_writeb(bus, CORBCTL, 0);\n\tspin_unlock_irq(&bus->reg_lock);\n\n\thdac_wait_for_cmd_dmas(bus);\n\n\tspin_lock_irq(&bus->reg_lock);\n\t \n\tsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, 0);\n\tspin_unlock_irq(&bus->reg_lock);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_stop_cmd_io);\n\nstatic unsigned int azx_command_addr(u32 cmd)\n{\n\tunsigned int addr = cmd >> 28;\n\n\tif (snd_BUG_ON(addr >= HDA_MAX_CODECS))\n\t\taddr = 0;\n\treturn addr;\n}\n\n \nint snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)\n{\n\tunsigned int addr = azx_command_addr(val);\n\tunsigned int wp, rp;\n\n\tspin_lock_irq(&bus->reg_lock);\n\n\tbus->last_cmd[azx_command_addr(val)] = val;\n\n\t \n\twp = snd_hdac_chip_readw(bus, CORBWP);\n\tif (wp == 0xffff) {\n\t\t \n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\treturn -EIO;\n\t}\n\twp++;\n\twp %= AZX_MAX_CORB_ENTRIES;\n\n\trp = snd_hdac_chip_readw(bus, CORBRP);\n\tif (wp == rp) {\n\t\t \n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tbus->rirb.cmds[addr]++;\n\tbus->corb.buf[wp] = cpu_to_le32(val);\n\tsnd_hdac_chip_writew(bus, CORBWP, wp);\n\n\tspin_unlock_irq(&bus->reg_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_send_cmd);\n\n#define AZX_RIRB_EX_UNSOL_EV\t(1<<4)\n\n \nvoid snd_hdac_bus_update_rirb(struct hdac_bus *bus)\n{\n\tunsigned int rp, wp;\n\tunsigned int addr;\n\tu32 res, res_ex;\n\n\twp = snd_hdac_chip_readw(bus, RIRBWP);\n\tif (wp == 0xffff) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (wp == bus->rirb.wp)\n\t\treturn;\n\tbus->rirb.wp = wp;\n\n\twhile (bus->rirb.rp != wp) {\n\t\tbus->rirb.rp++;\n\t\tbus->rirb.rp %= AZX_MAX_RIRB_ENTRIES;\n\n\t\trp = bus->rirb.rp << 1;  \n\t\tres_ex = le32_to_cpu(bus->rirb.buf[rp + 1]);\n\t\tres = le32_to_cpu(bus->rirb.buf[rp]);\n\t\taddr = res_ex & 0xf;\n\t\tif (addr >= HDA_MAX_CODECS) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"spurious response %#x:%#x, rp = %d, wp = %d\",\n\t\t\t\tres, res_ex, bus->rirb.rp, wp);\n\t\t\tsnd_BUG();\n\t\t} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)\n\t\t\tsnd_hdac_bus_queue_event(bus, res, res_ex);\n\t\telse if (bus->rirb.cmds[addr]) {\n\t\t\tbus->rirb.res[addr] = res;\n\t\t\tbus->rirb.cmds[addr]--;\n\t\t\tif (!bus->rirb.cmds[addr] &&\n\t\t\t    waitqueue_active(&bus->rirb_wq))\n\t\t\t\twake_up(&bus->rirb_wq);\n\t\t} else {\n\t\t\tdev_err_ratelimited(bus->dev,\n\t\t\t\t\"spurious response %#x:%#x, last cmd=%#08x\\n\",\n\t\t\t\tres, res_ex, bus->last_cmd[addr]);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_update_rirb);\n\n \nint snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,\n\t\t\t      unsigned int *res)\n{\n\tunsigned long timeout;\n\tunsigned long loopcounter;\n\twait_queue_entry_t wait;\n\tbool warned = false;\n\n\tinit_wait_entry(&wait, 0);\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\tfor (loopcounter = 0;; loopcounter++) {\n\t\tspin_lock_irq(&bus->reg_lock);\n\t\tif (!bus->polling_mode)\n\t\t\tprepare_to_wait(&bus->rirb_wq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (bus->polling_mode)\n\t\t\tsnd_hdac_bus_update_rirb(bus);\n\t\tif (!bus->rirb.cmds[addr]) {\n\t\t\tif (res)\n\t\t\t\t*res = bus->rirb.res[addr];  \n\t\t\tif (!bus->polling_mode)\n\t\t\t\tfinish_wait(&bus->rirb_wq, &wait);\n\t\t\tspin_unlock_irq(&bus->reg_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n#define LOOP_COUNT_MAX\t3000\n\t\tif (!bus->polling_mode) {\n\t\t\tschedule_timeout(msecs_to_jiffies(2));\n\t\t} else if (bus->needs_damn_long_delay ||\n\t\t\t   loopcounter > LOOP_COUNT_MAX) {\n\t\t\tif (loopcounter > LOOP_COUNT_MAX && !warned) {\n\t\t\t\tdev_dbg_ratelimited(bus->dev,\n\t\t\t\t\t\t    \"too slow response, last cmd=%#08x\\n\",\n\t\t\t\t\t\t    bus->last_cmd[addr]);\n\t\t\t\twarned = true;\n\t\t\t}\n\t\t\tmsleep(2);  \n\t\t} else {\n\t\t\tudelay(10);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (!bus->polling_mode)\n\t\tfinish_wait(&bus->rirb_wq, &wait);\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_get_response);\n\n#define HDAC_MAX_CAPS 10\n \nint snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)\n{\n\tunsigned int cur_cap;\n\tunsigned int offset;\n\tunsigned int counter = 0;\n\n\toffset = snd_hdac_chip_readw(bus, LLCH);\n\n\t \n\tdo {\n\t\tcur_cap = _snd_hdac_chip_readl(bus, offset);\n\n\t\tdev_dbg(bus->dev, \"Capability version: 0x%x\\n\",\n\t\t\t(cur_cap & AZX_CAP_HDR_VER_MASK) >> AZX_CAP_HDR_VER_OFF);\n\n\t\tdev_dbg(bus->dev, \"HDA capability ID: 0x%x\\n\",\n\t\t\t(cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF);\n\n\t\tif (cur_cap == -1) {\n\t\t\tdev_dbg(bus->dev, \"Invalid capability reg read\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF) {\n\t\tcase AZX_ML_CAP_ID:\n\t\t\tdev_dbg(bus->dev, \"Found ML capability\\n\");\n\t\t\tbus->mlcap = bus->remap_addr + offset;\n\t\t\tbreak;\n\n\t\tcase AZX_GTS_CAP_ID:\n\t\t\tdev_dbg(bus->dev, \"Found GTS capability offset=%x\\n\", offset);\n\t\t\tbus->gtscap = bus->remap_addr + offset;\n\t\t\tbreak;\n\n\t\tcase AZX_PP_CAP_ID:\n\t\t\t \n\t\t\tdev_dbg(bus->dev, \"Found PP capability offset=%x\\n\", offset);\n\t\t\tbus->ppcap = bus->remap_addr + offset;\n\t\t\tbreak;\n\n\t\tcase AZX_SPB_CAP_ID:\n\t\t\t \n\t\t\tdev_dbg(bus->dev, \"Found SPB capability\\n\");\n\t\t\tbus->spbcap = bus->remap_addr + offset;\n\t\t\tbreak;\n\n\t\tcase AZX_DRSM_CAP_ID:\n\t\t\t \n\t\t\tdev_dbg(bus->dev, \"Found DRSM capability\\n\");\n\t\t\tbus->drsmcap = bus->remap_addr + offset;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(bus->dev, \"Unknown capability %d\\n\", cur_cap);\n\t\t\tcur_cap = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcounter++;\n\n\t\tif (counter > HDAC_MAX_CAPS) {\n\t\t\tdev_err(bus->dev, \"We exceeded HDAC capabilities!!!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\toffset = cur_cap & AZX_CAP_HDR_NXT_PTR_MASK;\n\n\t} while (offset);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_parse_capabilities);\n\n \n\n \nvoid snd_hdac_bus_enter_link_reset(struct hdac_bus *bus)\n{\n\tunsigned long timeout;\n\n\t \n\tsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_RESET, 0);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile ((snd_hdac_chip_readb(bus, GCTL) & AZX_GCTL_RESET) &&\n\t       time_before(jiffies, timeout))\n\t\tusleep_range(500, 1000);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_enter_link_reset);\n\n \nvoid snd_hdac_bus_exit_link_reset(struct hdac_bus *bus)\n{\n\tunsigned long timeout;\n\n\tsnd_hdac_chip_updateb(bus, GCTL, AZX_GCTL_RESET, AZX_GCTL_RESET);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (!snd_hdac_chip_readb(bus, GCTL) && time_before(jiffies, timeout))\n\t\tusleep_range(500, 1000);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_exit_link_reset);\n\n \nint snd_hdac_bus_reset_link(struct hdac_bus *bus, bool full_reset)\n{\n\tif (!full_reset)\n\t\tgoto skip_reset;\n\n\t \n\tif (snd_hdac_chip_readb(bus, GCTL) & AZX_GCTL_RESET)\n\t\tsnd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);\n\n\t \n\tsnd_hdac_bus_enter_link_reset(bus);\n\n\t \n\tusleep_range(500, 1000);\n\n\t \n\tsnd_hdac_bus_exit_link_reset(bus);\n\n\t \n\tusleep_range(1000, 1200);\n\n skip_reset:\n\t \n\tif (!snd_hdac_chip_readb(bus, GCTL)) {\n\t\tdev_dbg(bus->dev, \"controller not ready!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (!bus->codec_mask) {\n\t\tbus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);\n\t\tdev_dbg(bus->dev, \"codec_mask = 0x%lx\\n\", bus->codec_mask);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_reset_link);\n\n \nstatic void azx_int_enable(struct hdac_bus *bus)\n{\n\t \n\tsnd_hdac_chip_updatel(bus, INTCTL,\n\t\t\t      AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN,\n\t\t\t      AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);\n}\n\n \nstatic void azx_int_disable(struct hdac_bus *bus)\n{\n\tstruct hdac_stream *azx_dev;\n\n\t \n\tlist_for_each_entry(azx_dev, &bus->stream_list, list)\n\t\tsnd_hdac_stream_updateb(azx_dev, SD_CTL, SD_INT_MASK, 0);\n\n\t \n\tsnd_hdac_chip_writel(bus, INTCTL, 0);\n}\n\n \nstatic void azx_int_clear(struct hdac_bus *bus)\n{\n\tstruct hdac_stream *azx_dev;\n\n\t \n\tlist_for_each_entry(azx_dev, &bus->stream_list, list)\n\t\tsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);\n\n\t \n\tsnd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);\n\n\t \n\tsnd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);\n\n\t \n\tsnd_hdac_chip_writel(bus, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);\n}\n\n \nbool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)\n{\n\tif (bus->chip_init)\n\t\treturn false;\n\n\t \n\tsnd_hdac_bus_reset_link(bus, full_reset);\n\n\t \n\tazx_int_clear(bus);\n\n\t \n\tsnd_hdac_bus_init_cmd_io(bus);\n\n\t \n\tazx_int_enable(bus);\n\n\t \n\tif (bus->use_posbuf && bus->posbuf.addr) {\n\t\tsnd_hdac_chip_writel(bus, DPLBASE, (u32)bus->posbuf.addr);\n\t\tsnd_hdac_chip_writel(bus, DPUBASE, upper_32_bits(bus->posbuf.addr));\n\t}\n\n\tbus->chip_init = true;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_init_chip);\n\n \nvoid snd_hdac_bus_stop_chip(struct hdac_bus *bus)\n{\n\tif (!bus->chip_init)\n\t\treturn;\n\n\t \n\tazx_int_disable(bus);\n\tazx_int_clear(bus);\n\n\t \n\tsnd_hdac_bus_stop_cmd_io(bus);\n\n\t \n\tif (bus->posbuf.addr) {\n\t\tsnd_hdac_chip_writel(bus, DPLBASE, 0);\n\t\tsnd_hdac_chip_writel(bus, DPUBASE, 0);\n\t}\n\n\tbus->chip_init = false;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_stop_chip);\n\n \nint snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,\n\t\t\t\t    void (*ack)(struct hdac_bus *,\n\t\t\t\t\t\tstruct hdac_stream *))\n{\n\tstruct hdac_stream *azx_dev;\n\tu8 sd_status;\n\tint handled = 0;\n\n\tlist_for_each_entry(azx_dev, &bus->stream_list, list) {\n\t\tif (status & azx_dev->sd_int_sta_mask) {\n\t\t\tsd_status = snd_hdac_stream_readb(azx_dev, SD_STS);\n\t\t\tsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);\n\t\t\thandled |= 1 << azx_dev->index;\n\t\t\tif ((!azx_dev->substream && !azx_dev->cstream) ||\n\t\t\t    !azx_dev->running || !(sd_status & SD_INT_COMPLETE))\n\t\t\t\tcontinue;\n\t\t\tif (ack)\n\t\t\t\tack(bus, azx_dev);\n\t\t}\n\t}\n\treturn handled;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_handle_stream_irq);\n\n \nint snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus)\n{\n\tstruct hdac_stream *s;\n\tint num_streams = 0;\n\tint dma_type = bus->dma_type ? bus->dma_type : SNDRV_DMA_TYPE_DEV;\n\tint err;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\t \n\t\terr = snd_dma_alloc_pages(dma_type, bus->dev,\n\t\t\t\t\t  BDL_SIZE, &s->bdl);\n\t\tnum_streams++;\n\t\tif (err < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (WARN_ON(!num_streams))\n\t\treturn -EINVAL;\n\t \n\terr = snd_dma_alloc_pages(dma_type, bus->dev,\n\t\t\t\t  num_streams * 8, &bus->posbuf);\n\tif (err < 0)\n\t\treturn -ENOMEM;\n\tlist_for_each_entry(s, &bus->stream_list, list)\n\t\ts->posbuf = (__le32 *)(bus->posbuf.area + s->index * 8);\n\n\t \n\treturn snd_dma_alloc_pages(dma_type, bus->dev, PAGE_SIZE, &bus->rb);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_alloc_stream_pages);\n\n \nvoid snd_hdac_bus_free_stream_pages(struct hdac_bus *bus)\n{\n\tstruct hdac_stream *s;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tif (s->bdl.area)\n\t\t\tsnd_dma_free_pages(&s->bdl);\n\t}\n\n\tif (bus->rb.area)\n\t\tsnd_dma_free_pages(&bus->rb);\n\tif (bus->posbuf.area)\n\t\tsnd_dma_free_pages(&bus->posbuf);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_free_stream_pages);\n\n \nvoid snd_hdac_bus_link_power(struct hdac_device *codec, bool enable)\n{\n\tif (enable)\n\t\tset_bit(codec->addr, &codec->bus->codec_powered);\n\telse\n\t\tclear_bit(codec->addr, &codec->bus->codec_powered);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_link_power);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}