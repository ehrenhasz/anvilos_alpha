{
  "module_name": "hdac_regmap.c",
  "hash_id": "f827d93c4fdb78440b48c3b54bb8e9da936513d77c73cd15cbb5aa0861a05604",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_regmap.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/export.h>\n#include <linux/pm.h>\n#include <sound/core.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_regmap.h>\n#include \"local.h\"\n\nstatic int codec_pm_lock(struct hdac_device *codec)\n{\n\treturn snd_hdac_keep_power_up(codec);\n}\n\nstatic void codec_pm_unlock(struct hdac_device *codec, int lock)\n{\n\tif (lock == 1)\n\t\tsnd_hdac_power_down_pm(codec);\n}\n\n#define get_verb(reg)\t(((reg) >> 8) & 0xfff)\n\nstatic bool hda_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tstruct hdac_device *codec = dev_to_hdac_dev(dev);\n\tunsigned int verb = get_verb(reg);\n\n\tswitch (verb) {\n\tcase AC_VERB_GET_PROC_COEF:\n\t\treturn !codec->cache_coef;\n\tcase AC_VERB_GET_COEF_INDEX:\n\tcase AC_VERB_GET_PROC_STATE:\n\tcase AC_VERB_GET_POWER_STATE:\n\tcase AC_VERB_GET_PIN_SENSE:\n\tcase AC_VERB_GET_HDMI_DIP_SIZE:\n\tcase AC_VERB_GET_HDMI_ELDD:\n\tcase AC_VERB_GET_HDMI_DIP_INDEX:\n\tcase AC_VERB_GET_HDMI_DIP_DATA:\n\tcase AC_VERB_GET_HDMI_DIP_XMIT:\n\tcase AC_VERB_GET_HDMI_CP_CTRL:\n\tcase AC_VERB_GET_HDMI_CHAN_SLOT:\n\tcase AC_VERB_GET_DEVICE_SEL:\n\tcase AC_VERB_GET_DEVICE_LIST:\t \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hda_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct hdac_device *codec = dev_to_hdac_dev(dev);\n\tunsigned int verb = get_verb(reg);\n\tconst unsigned int *v;\n\tint i;\n\n\tsnd_array_for_each(&codec->vendor_verbs, i, v) {\n\t\tif (verb == *v)\n\t\t\treturn true;\n\t}\n\n\tif (codec->caps_overwriting)\n\t\treturn true;\n\n\tswitch (verb & 0xf00) {\n\tcase AC_VERB_GET_STREAM_FORMAT:\n\tcase AC_VERB_GET_AMP_GAIN_MUTE:\n\t\treturn true;\n\tcase AC_VERB_GET_PROC_COEF:\n\t\treturn codec->cache_coef;\n\tcase 0xf00:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (verb) {\n\tcase AC_VERB_GET_CONNECT_SEL:\n\tcase AC_VERB_GET_SDI_SELECT:\n\tcase AC_VERB_GET_PIN_WIDGET_CONTROL:\n\tcase AC_VERB_GET_UNSOLICITED_RESPONSE:  \n\tcase AC_VERB_GET_BEEP_CONTROL:\n\tcase AC_VERB_GET_EAPD_BTLENABLE:\n\tcase AC_VERB_GET_DIGI_CONVERT_1:\n\tcase AC_VERB_GET_DIGI_CONVERT_2:  \n\tcase AC_VERB_GET_VOLUME_KNOB_CONTROL:\n\tcase AC_VERB_GET_GPIO_MASK:\n\tcase AC_VERB_GET_GPIO_DIRECTION:\n\tcase AC_VERB_GET_GPIO_DATA:  \n\tcase AC_VERB_GET_GPIO_WAKE_MASK:\n\tcase AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK:\n\tcase AC_VERB_GET_GPIO_STICKY_MASK:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hda_readable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct hdac_device *codec = dev_to_hdac_dev(dev);\n\tunsigned int verb = get_verb(reg);\n\n\tif (codec->caps_overwriting)\n\t\treturn true;\n\n\tswitch (verb) {\n\tcase AC_VERB_PARAMETERS:\n\tcase AC_VERB_GET_CONNECT_LIST:\n\tcase AC_VERB_GET_SUBSYSTEM_ID:\n\t\treturn true;\n\t \n\tcase AC_VERB_GET_CONFIG_DEFAULT:  \n\tcase AC_VERB_GET_CONV:  \n\tcase AC_VERB_GET_CVT_CHAN_COUNT:  \n\t\treturn true;\n\t}\n\n\treturn hda_writeable_reg(dev, reg);\n}\n\n \nstatic bool is_stereo_amp_verb(unsigned int reg)\n{\n\tif (((reg >> 8) & 0x700) != AC_VERB_SET_AMP_GAIN_MUTE)\n\t\treturn false;\n\treturn (reg & (AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT)) ==\n\t\t(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);\n}\n\n \nstatic int hda_reg_read_stereo_amp(struct hdac_device *codec,\n\t\t\t\t   unsigned int reg, unsigned int *val)\n{\n\tunsigned int left, right;\n\tint err;\n\n\treg &= ~(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);\n\terr = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_LEFT, 0, &left);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_RIGHT, 0, &right);\n\tif (err < 0)\n\t\treturn err;\n\t*val = left | (right << 8);\n\treturn 0;\n}\n\n \nstatic int hda_reg_write_stereo_amp(struct hdac_device *codec,\n\t\t\t\t    unsigned int reg, unsigned int val)\n{\n\tint err;\n\tunsigned int verb, left, right;\n\n\tverb = AC_VERB_SET_AMP_GAIN_MUTE << 8;\n\tif (reg & AC_AMP_GET_OUTPUT)\n\t\tverb |= AC_AMP_SET_OUTPUT;\n\telse\n\t\tverb |= AC_AMP_SET_INPUT | ((reg & 0xf) << 8);\n\treg = (reg & ~0xfffff) | verb;\n\n\tleft = val & 0xff;\n\tright = (val >> 8) & 0xff;\n\tif (left == right) {\n\t\treg |= AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT;\n\t\treturn snd_hdac_exec_verb(codec, reg | left, 0, NULL);\n\t}\n\n\terr = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_LEFT | left, 0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_RIGHT | right, 0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n \nstatic int hda_reg_read_coef(struct hdac_device *codec, unsigned int reg,\n\t\t\t     unsigned int *val)\n{\n\tunsigned int verb;\n\tint err;\n\n\tif (!codec->cache_coef)\n\t\treturn -EINVAL;\n\t \n\tverb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);\n\terr = snd_hdac_exec_verb(codec, verb, 0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tverb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8);\n\treturn snd_hdac_exec_verb(codec, verb, 0, val);\n}\n\n \nstatic int hda_reg_write_coef(struct hdac_device *codec, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\tunsigned int verb;\n\tint err;\n\n\tif (!codec->cache_coef)\n\t\treturn -EINVAL;\n\t \n\tverb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);\n\terr = snd_hdac_exec_verb(codec, verb, 0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tverb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8) |\n\t\t(val & 0xffff);\n\treturn snd_hdac_exec_verb(codec, verb, 0, NULL);\n}\n\nstatic int hda_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct hdac_device *codec = context;\n\tint verb = get_verb(reg);\n\tint err;\n\tint pm_lock = 0;\n\n\tif (verb != AC_VERB_GET_POWER_STATE) {\n\t\tpm_lock = codec_pm_lock(codec);\n\t\tif (pm_lock < 0)\n\t\t\treturn -EAGAIN;\n\t}\n\treg |= (codec->addr << 28);\n\tif (is_stereo_amp_verb(reg)) {\n\t\terr = hda_reg_read_stereo_amp(codec, reg, val);\n\t\tgoto out;\n\t}\n\tif (verb == AC_VERB_GET_PROC_COEF) {\n\t\terr = hda_reg_read_coef(codec, reg, val);\n\t\tgoto out;\n\t}\n\tif ((verb & 0x700) == AC_VERB_SET_AMP_GAIN_MUTE)\n\t\treg &= ~AC_AMP_FAKE_MUTE;\n\n\terr = snd_hdac_exec_verb(codec, reg, 0, val);\n\tif (err < 0)\n\t\tgoto out;\n\t \n\tif (verb == AC_VERB_GET_POWER_STATE) {\n\t\tif (*val & AC_PWRST_ERROR)\n\t\t\t*val = -1;\n\t\telse  \n\t\t\t*val = (*val >> 4) & 0x0f;\n\t}\n out:\n\tcodec_pm_unlock(codec, pm_lock);\n\treturn err;\n}\n\nstatic int hda_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct hdac_device *codec = context;\n\tunsigned int verb;\n\tint i, bytes, err;\n\tint pm_lock = 0;\n\n\tif (codec->caps_overwriting)\n\t\treturn 0;\n\n\treg &= ~0x00080000U;  \n\treg |= (codec->addr << 28);\n\tverb = get_verb(reg);\n\n\tif (verb != AC_VERB_SET_POWER_STATE) {\n\t\tpm_lock = codec_pm_lock(codec);\n\t\tif (pm_lock < 0)\n\t\t\treturn codec->lazy_cache ? 0 : -EAGAIN;\n\t}\n\n\tif (is_stereo_amp_verb(reg)) {\n\t\terr = hda_reg_write_stereo_amp(codec, reg, val);\n\t\tgoto out;\n\t}\n\n\tif (verb == AC_VERB_SET_PROC_COEF) {\n\t\terr = hda_reg_write_coef(codec, reg, val);\n\t\tgoto out;\n\t}\n\n\tswitch (verb & 0xf00) {\n\tcase AC_VERB_SET_AMP_GAIN_MUTE:\n\t\tif ((reg & AC_AMP_FAKE_MUTE) && (val & AC_AMP_MUTE))\n\t\t\tval = 0;\n\t\tverb = AC_VERB_SET_AMP_GAIN_MUTE;\n\t\tif (reg & AC_AMP_GET_LEFT)\n\t\t\tverb |= AC_AMP_SET_LEFT >> 8;\n\t\telse\n\t\t\tverb |= AC_AMP_SET_RIGHT >> 8;\n\t\tif (reg & AC_AMP_GET_OUTPUT) {\n\t\t\tverb |= AC_AMP_SET_OUTPUT >> 8;\n\t\t} else {\n\t\t\tverb |= AC_AMP_SET_INPUT >> 8;\n\t\t\tverb |= reg & 0xf;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (verb) {\n\tcase AC_VERB_SET_DIGI_CONVERT_1:\n\t\tbytes = 2;\n\t\tbreak;\n\tcase AC_VERB_SET_CONFIG_DEFAULT_BYTES_0:\n\t\tbytes = 4;\n\t\tbreak;\n\tdefault:\n\t\tbytes = 1;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < bytes; i++) {\n\t\treg &= ~0xfffff;\n\t\treg |= (verb + i) << 8 | ((val >> (8 * i)) & 0xff);\n\t\terr = snd_hdac_exec_verb(codec, reg, 0, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n out:\n\tcodec_pm_unlock(codec, pm_lock);\n\treturn err;\n}\n\nstatic const struct regmap_config hda_regmap_cfg = {\n\t.name = \"hdaudio\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.max_register = 0xfffffff,\n\t.writeable_reg = hda_writeable_reg,\n\t.readable_reg = hda_readable_reg,\n\t.volatile_reg = hda_volatile_reg,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_read = hda_reg_read,\n\t.reg_write = hda_reg_write,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.disable_locking = true,\n};\n\n \nint snd_hdac_regmap_init(struct hdac_device *codec)\n{\n\tstruct regmap *regmap;\n\n\tregmap = regmap_init(&codec->dev, NULL, codec, &hda_regmap_cfg);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\tcodec->regmap = regmap;\n\tsnd_array_init(&codec->vendor_verbs, sizeof(unsigned int), 8);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_init);\n\n \nvoid snd_hdac_regmap_exit(struct hdac_device *codec)\n{\n\tif (codec->regmap) {\n\t\tregmap_exit(codec->regmap);\n\t\tcodec->regmap = NULL;\n\t\tsnd_array_free(&codec->vendor_verbs);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_exit);\n\n \nint snd_hdac_regmap_add_vendor_verb(struct hdac_device *codec,\n\t\t\t\t    unsigned int verb)\n{\n\tunsigned int *p = snd_array_new(&codec->vendor_verbs);\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\t*p = verb | 0x800;  \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_add_vendor_verb);\n\n \n\n \nstatic int reg_raw_write(struct hdac_device *codec, unsigned int reg,\n\t\t\t unsigned int val)\n{\n\tint err;\n\n\tmutex_lock(&codec->regmap_lock);\n\tif (!codec->regmap)\n\t\terr = hda_reg_write(codec, reg, val);\n\telse\n\t\terr = regmap_write(codec->regmap, reg, val);\n\tmutex_unlock(&codec->regmap_lock);\n\treturn err;\n}\n\n \n#define CALL_RAW_FUNC(codec, func_call)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\\\n\t\tint _err = func_call;\t\t\t\t\\\n\t\tif (_err == -EAGAIN) {\t\t\t\t\\\n\t\t\t_err = snd_hdac_power_up_pm(codec);\t\\\n\t\t\tif (_err >= 0)\t\t\t\t\\\n\t\t\t\t_err = func_call;\t\t\\\n\t\t\tsnd_hdac_power_down_pm(codec);\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\t_err;})\n\n \nint snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,\n\t\t\t      unsigned int val)\n{\n\treturn CALL_RAW_FUNC(codec, reg_raw_write(codec, reg, val));\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_write_raw);\n\nstatic int reg_raw_read(struct hdac_device *codec, unsigned int reg,\n\t\t\tunsigned int *val, bool uncached)\n{\n\tint err;\n\n\tmutex_lock(&codec->regmap_lock);\n\tif (uncached || !codec->regmap)\n\t\terr = hda_reg_read(codec, reg, val);\n\telse\n\t\terr = regmap_read(codec->regmap, reg, val);\n\tmutex_unlock(&codec->regmap_lock);\n\treturn err;\n}\n\nstatic int __snd_hdac_regmap_read_raw(struct hdac_device *codec,\n\t\t\t\t      unsigned int reg, unsigned int *val,\n\t\t\t\t      bool uncached)\n{\n\treturn CALL_RAW_FUNC(codec, reg_raw_read(codec, reg, val, uncached));\n}\n\n \nint snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,\n\t\t\t     unsigned int *val)\n{\n\treturn __snd_hdac_regmap_read_raw(codec, reg, val, false);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_read_raw);\n\n \nint snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,\n\t\t\t\t      unsigned int reg, unsigned int *val)\n{\n\treturn __snd_hdac_regmap_read_raw(codec, reg, val, true);\n}\n\nstatic int reg_raw_update(struct hdac_device *codec, unsigned int reg,\n\t\t\t  unsigned int mask, unsigned int val)\n{\n\tunsigned int orig;\n\tbool change;\n\tint err;\n\n\tmutex_lock(&codec->regmap_lock);\n\tif (codec->regmap) {\n\t\terr = regmap_update_bits_check(codec->regmap, reg, mask, val,\n\t\t\t\t\t       &change);\n\t\tif (!err)\n\t\t\terr = change ? 1 : 0;\n\t} else {\n\t\terr = hda_reg_read(codec, reg, &orig);\n\t\tif (!err) {\n\t\t\tval &= mask;\n\t\t\tval |= orig & ~mask;\n\t\t\tif (val != orig) {\n\t\t\t\terr = hda_reg_write(codec, reg, val);\n\t\t\t\tif (!err)\n\t\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&codec->regmap_lock);\n\treturn err;\n}\n\n \nint snd_hdac_regmap_update_raw(struct hdac_device *codec, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val)\n{\n\treturn CALL_RAW_FUNC(codec, reg_raw_update(codec, reg, mask, val));\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw);\n\nstatic int reg_raw_update_once(struct hdac_device *codec, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val)\n{\n\tint err = 0;\n\n\tif (!codec->regmap)\n\t\treturn reg_raw_update(codec, reg, mask, val);\n\n\tmutex_lock(&codec->regmap_lock);\n\t \n\tif (!regcache_reg_cached(codec->regmap, reg))\n\t\terr = regmap_update_bits(codec->regmap, reg, mask, val);\n\tmutex_unlock(&codec->regmap_lock);\n\treturn err;\n}\n\n \nint snd_hdac_regmap_update_raw_once(struct hdac_device *codec, unsigned int reg,\n\t\t\t\t    unsigned int mask, unsigned int val)\n{\n\treturn CALL_RAW_FUNC(codec, reg_raw_update_once(codec, reg, mask, val));\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw_once);\n\n \nvoid snd_hdac_regmap_sync(struct hdac_device *codec)\n{\n\tmutex_lock(&codec->regmap_lock);\n\tif (codec->regmap)\n\t\tregcache_sync(codec->regmap);\n\tmutex_unlock(&codec->regmap_lock);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_regmap_sync);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}