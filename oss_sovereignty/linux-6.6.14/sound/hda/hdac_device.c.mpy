{
  "module_name": "hdac_device.c",
  "hash_id": "53ac3232fe4bbc2386e4276b676f365b2a5080452afe86f29007c5307c7c5e80",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_device.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/pm_runtime.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_regmap.h>\n#include <sound/pcm.h>\n#include \"local.h\"\n\nstatic void setup_fg_nodes(struct hdac_device *codec);\nstatic int get_codec_vendor_name(struct hdac_device *codec);\n\nstatic void default_release(struct device *dev)\n{\n\tsnd_hdac_device_exit(dev_to_hdac_dev(dev));\n}\n\n \nint snd_hdac_device_init(struct hdac_device *codec, struct hdac_bus *bus,\n\t\t\t const char *name, unsigned int addr)\n{\n\tstruct device *dev;\n\thda_nid_t fg;\n\tint err;\n\n\tdev = &codec->dev;\n\tdevice_initialize(dev);\n\tdev->parent = bus->dev;\n\tdev->bus = &snd_hda_bus_type;\n\tdev->release = default_release;\n\tdev->groups = hdac_dev_attr_groups;\n\tdev_set_name(dev, \"%s\", name);\n\tdevice_enable_async_suspend(dev);\n\n\tcodec->bus = bus;\n\tcodec->addr = addr;\n\tcodec->type = HDA_DEV_CORE;\n\tmutex_init(&codec->widget_lock);\n\tmutex_init(&codec->regmap_lock);\n\tpm_runtime_set_active(&codec->dev);\n\tpm_runtime_get_noresume(&codec->dev);\n\tatomic_set(&codec->in_pm, 0);\n\n\terr = snd_hdac_bus_add_device(bus, codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tcodec->vendor_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\n\t\t\t\t\t      AC_PAR_VENDOR_ID);\n\tif (codec->vendor_id == -1) {\n\t\t \n\t\tcodec->vendor_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\n\t\t\t\t\t\t      AC_PAR_VENDOR_ID);\n\t}\n\n\tcodec->subsystem_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\n\t\t\t\t\t\t AC_PAR_SUBSYSTEM_ID);\n\tcodec->revision_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\n\t\t\t\t\t\tAC_PAR_REV_ID);\n\n\tsetup_fg_nodes(codec);\n\tif (!codec->afg && !codec->mfg) {\n\t\tdev_err(dev, \"no AFG or MFG node found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tfg = codec->afg ? codec->afg : codec->mfg;\n\n\terr = snd_hdac_refresh_widgets(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcodec->power_caps = snd_hdac_read_parm(codec, fg, AC_PAR_POWER_STATE);\n\t \n\tif (codec->subsystem_id == -1 || codec->subsystem_id == 0)\n\t\tsnd_hdac_read(codec, fg, AC_VERB_GET_SUBSYSTEM_ID, 0,\n\t\t\t      &codec->subsystem_id);\n\n\terr = get_codec_vendor_name(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcodec->chip_name = kasprintf(GFP_KERNEL, \"ID %x\",\n\t\t\t\t     codec->vendor_id & 0xffff);\n\tif (!codec->chip_name) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n error:\n\tput_device(&codec->dev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_device_init);\n\n \nvoid snd_hdac_device_exit(struct hdac_device *codec)\n{\n\tpm_runtime_put_noidle(&codec->dev);\n\t \n\tpm_runtime_set_suspended(&codec->dev);\n\tsnd_hdac_bus_remove_device(codec->bus, codec);\n\tkfree(codec->vendor_name);\n\tkfree(codec->chip_name);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_device_exit);\n\n \nint snd_hdac_device_register(struct hdac_device *codec)\n{\n\tint err;\n\n\terr = device_add(&codec->dev);\n\tif (err < 0)\n\t\treturn err;\n\tmutex_lock(&codec->widget_lock);\n\terr = hda_widget_sysfs_init(codec);\n\tmutex_unlock(&codec->widget_lock);\n\tif (err < 0) {\n\t\tdevice_del(&codec->dev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_device_register);\n\n \nvoid snd_hdac_device_unregister(struct hdac_device *codec)\n{\n\tif (device_is_registered(&codec->dev)) {\n\t\tmutex_lock(&codec->widget_lock);\n\t\thda_widget_sysfs_exit(codec);\n\t\tmutex_unlock(&codec->widget_lock);\n\t\tdevice_del(&codec->dev);\n\t\tsnd_hdac_bus_remove_device(codec->bus, codec);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_device_unregister);\n\n \nint snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name)\n{\n\tchar *newname;\n\n\tif (!name)\n\t\treturn 0;\n\tnewname = kstrdup(name, GFP_KERNEL);\n\tif (!newname)\n\t\treturn -ENOMEM;\n\tkfree(codec->chip_name);\n\tcodec->chip_name = newname;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_device_set_chip_name);\n\n \nint snd_hdac_codec_modalias(const struct hdac_device *codec, char *buf, size_t size)\n{\n\treturn scnprintf(buf, size, \"hdaudio:v%08Xr%08Xa%02X\\n\",\n\t\t\tcodec->vendor_id, codec->revision_id, codec->type);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_codec_modalias);\n\n \nstatic unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\t      unsigned int verb, unsigned int parm)\n{\n\tu32 val, addr;\n\n\taddr = codec->addr;\n\tif ((addr & ~0xf) || (nid & ~0x7f) ||\n\t    (verb & ~0xfff) || (parm & ~0xffff)) {\n\t\tdev_err(&codec->dev, \"out of range cmd %x:%x:%x:%x\\n\",\n\t\t\taddr, nid, verb, parm);\n\t\treturn -1;\n\t}\n\n\tval = addr << 28;\n\tval |= (u32)nid << 20;\n\tval |= verb << 8;\n\tval |= parm;\n\treturn val;\n}\n\n \nint snd_hdac_exec_verb(struct hdac_device *codec, unsigned int cmd,\n\t\t       unsigned int flags, unsigned int *res)\n{\n\tif (codec->exec_verb)\n\t\treturn codec->exec_verb(codec, cmd, flags, res);\n\treturn snd_hdac_bus_exec_verb(codec->bus, codec->addr, cmd, res);\n}\n\n\n \nint snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,\n\t\t  unsigned int verb, unsigned int parm, unsigned int *res)\n{\n\tunsigned int cmd = snd_hdac_make_cmd(codec, nid, verb, parm);\n\n\treturn snd_hdac_exec_verb(codec, cmd, 0, res);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_read);\n\n \nint _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,\n\t\t\tunsigned int *res)\n{\n\tunsigned int cmd;\n\n\tcmd = snd_hdac_regmap_encode_verb(nid, AC_VERB_PARAMETERS) | parm;\n\treturn snd_hdac_regmap_read_raw(codec, cmd, res);\n}\nEXPORT_SYMBOL_GPL(_snd_hdac_read_parm);\n\n \nint snd_hdac_read_parm_uncached(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\tint parm)\n{\n\tunsigned int cmd, val;\n\n\tcmd = snd_hdac_regmap_encode_verb(nid, AC_VERB_PARAMETERS) | parm;\n\tif (snd_hdac_regmap_read_raw_uncached(codec, cmd, &val) < 0)\n\t\treturn -1;\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_read_parm_uncached);\n\n \nint snd_hdac_override_parm(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t   unsigned int parm, unsigned int val)\n{\n\tunsigned int verb = (AC_VERB_PARAMETERS << 8) | (nid << 20) | parm;\n\tint err;\n\n\tif (!codec->regmap)\n\t\treturn -EINVAL;\n\n\tcodec->caps_overwriting = true;\n\terr = snd_hdac_regmap_write_raw(codec, verb, val);\n\tcodec->caps_overwriting = false;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_override_parm);\n\n \nint snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t   hda_nid_t *start_id)\n{\n\tunsigned int parm;\n\n\tparm = snd_hdac_read_parm_uncached(codec, nid, AC_PAR_NODE_COUNT);\n\tif (parm == -1) {\n\t\t*start_id = 0;\n\t\treturn 0;\n\t}\n\t*start_id = (parm >> 16) & 0x7fff;\n\treturn (int)(parm & 0x7fff);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_sub_nodes);\n\n \nstatic void setup_fg_nodes(struct hdac_device *codec)\n{\n\tint i, total_nodes, function_id;\n\thda_nid_t nid;\n\n\ttotal_nodes = snd_hdac_get_sub_nodes(codec, AC_NODE_ROOT, &nid);\n\tfor (i = 0; i < total_nodes; i++, nid++) {\n\t\tfunction_id = snd_hdac_read_parm(codec, nid,\n\t\t\t\t\t\t AC_PAR_FUNCTION_TYPE);\n\t\tswitch (function_id & 0xff) {\n\t\tcase AC_GRP_AUDIO_FUNCTION:\n\t\t\tcodec->afg = nid;\n\t\t\tcodec->afg_function_id = function_id & 0xff;\n\t\t\tcodec->afg_unsol = (function_id >> 8) & 1;\n\t\t\tbreak;\n\t\tcase AC_GRP_MODEM_FUNCTION:\n\t\t\tcodec->mfg = nid;\n\t\t\tcodec->mfg_function_id = function_id & 0xff;\n\t\t\tcodec->mfg_unsol = (function_id >> 8) & 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nint snd_hdac_refresh_widgets(struct hdac_device *codec)\n{\n\thda_nid_t start_nid;\n\tint nums, err = 0;\n\n\t \n\tmutex_lock(&codec->widget_lock);\n\tnums = snd_hdac_get_sub_nodes(codec, codec->afg, &start_nid);\n\tif (!start_nid || nums <= 0 || nums >= 0xff) {\n\t\tdev_err(&codec->dev, \"cannot read sub nodes for FG 0x%02x\\n\",\n\t\t\tcodec->afg);\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\terr = hda_widget_sysfs_reinit(codec, start_nid, nums);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tcodec->num_nodes = nums;\n\tcodec->start_nid = start_nid;\n\tcodec->end_nid = start_nid + nums;\nunlock:\n\tmutex_unlock(&codec->widget_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_refresh_widgets);\n\n \nstatic unsigned int get_num_conns(struct hdac_device *codec, hda_nid_t nid)\n{\n\tunsigned int wcaps = get_wcaps(codec, nid);\n\tunsigned int parm;\n\n\tif (!(wcaps & AC_WCAP_CONN_LIST) &&\n\t    get_wcaps_type(wcaps) != AC_WID_VOL_KNB)\n\t\treturn 0;\n\n\tparm = snd_hdac_read_parm(codec, nid, AC_PAR_CONNLIST_LEN);\n\tif (parm == -1)\n\t\tparm = 0;\n\treturn parm;\n}\n\n \nint snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t     hda_nid_t *conn_list, int max_conns)\n{\n\tunsigned int parm;\n\tint i, conn_len, conns, err;\n\tunsigned int shift, num_elems, mask;\n\thda_nid_t prev_nid;\n\tint null_count = 0;\n\n\tparm = get_num_conns(codec, nid);\n\tif (!parm)\n\t\treturn 0;\n\n\tif (parm & AC_CLIST_LONG) {\n\t\t \n\t\tshift = 16;\n\t\tnum_elems = 2;\n\t} else {\n\t\t \n\t\tshift = 8;\n\t\tnum_elems = 4;\n\t}\n\tconn_len = parm & AC_CLIST_LENGTH;\n\tmask = (1 << (shift-1)) - 1;\n\n\tif (!conn_len)\n\t\treturn 0;  \n\n\tif (conn_len == 1) {\n\t\t \n\t\terr = snd_hdac_read(codec, nid, AC_VERB_GET_CONNECT_LIST, 0,\n\t\t\t\t    &parm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (conn_list)\n\t\t\tconn_list[0] = parm & mask;\n\t\treturn 1;\n\t}\n\n\t \n\tconns = 0;\n\tprev_nid = 0;\n\tfor (i = 0; i < conn_len; i++) {\n\t\tint range_val;\n\t\thda_nid_t val, n;\n\n\t\tif (i % num_elems == 0) {\n\t\t\terr = snd_hdac_read(codec, nid,\n\t\t\t\t\t    AC_VERB_GET_CONNECT_LIST, i,\n\t\t\t\t\t    &parm);\n\t\t\tif (err < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\t\trange_val = !!(parm & (1 << (shift-1)));  \n\t\tval = parm & mask;\n\t\tif (val == 0 && null_count++) {   \n\t\t\tdev_dbg(&codec->dev,\n\t\t\t\t\"invalid CONNECT_LIST verb %x[%i]:%x\\n\",\n\t\t\t\tnid, i, parm);\n\t\t\treturn 0;\n\t\t}\n\t\tparm >>= shift;\n\t\tif (range_val) {\n\t\t\t \n\t\t\tif (!prev_nid || prev_nid >= val) {\n\t\t\t\tdev_warn(&codec->dev,\n\t\t\t\t\t \"invalid dep_range_val %x:%x\\n\",\n\t\t\t\t\t prev_nid, val);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (n = prev_nid + 1; n <= val; n++) {\n\t\t\t\tif (conn_list) {\n\t\t\t\t\tif (conns >= max_conns)\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\tconn_list[conns] = n;\n\t\t\t\t}\n\t\t\t\tconns++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conn_list) {\n\t\t\t\tif (conns >= max_conns)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\tconn_list[conns] = val;\n\t\t\t}\n\t\t\tconns++;\n\t\t}\n\t\tprev_nid = val;\n\t}\n\treturn conns;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_connections);\n\n#ifdef CONFIG_PM\n \nint snd_hdac_power_up(struct hdac_device *codec)\n{\n\treturn pm_runtime_get_sync(&codec->dev);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_power_up);\n\n \nint snd_hdac_power_down(struct hdac_device *codec)\n{\n\tstruct device *dev = &codec->dev;\n\n\tpm_runtime_mark_last_busy(dev);\n\treturn pm_runtime_put_autosuspend(dev);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_power_down);\n\n \nint snd_hdac_power_up_pm(struct hdac_device *codec)\n{\n\tif (!atomic_inc_not_zero(&codec->in_pm))\n\t\treturn snd_hdac_power_up(codec);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_power_up_pm);\n\n \nint snd_hdac_keep_power_up(struct hdac_device *codec)\n{\n\tif (!atomic_inc_not_zero(&codec->in_pm)) {\n\t\tint ret = pm_runtime_get_if_active(&codec->dev, true);\n\t\tif (!ret)\n\t\t\treturn -1;\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint snd_hdac_power_down_pm(struct hdac_device *codec)\n{\n\tif (atomic_dec_if_positive(&codec->in_pm) < 0)\n\t\treturn snd_hdac_power_down(codec);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_power_down_pm);\n#endif\n\n \nstruct hda_vendor_id {\n\tunsigned int id;\n\tconst char *name;\n};\n\nstatic const struct hda_vendor_id hda_vendor_ids[] = {\n\t{ 0x0014, \"Loongson\" },\n\t{ 0x1002, \"ATI\" },\n\t{ 0x1013, \"Cirrus Logic\" },\n\t{ 0x1057, \"Motorola\" },\n\t{ 0x1095, \"Silicon Image\" },\n\t{ 0x10de, \"Nvidia\" },\n\t{ 0x10ec, \"Realtek\" },\n\t{ 0x1102, \"Creative\" },\n\t{ 0x1106, \"VIA\" },\n\t{ 0x111d, \"IDT\" },\n\t{ 0x11c1, \"LSI\" },\n\t{ 0x11d4, \"Analog Devices\" },\n\t{ 0x13f6, \"C-Media\" },\n\t{ 0x14f1, \"Conexant\" },\n\t{ 0x17e8, \"Chrontel\" },\n\t{ 0x1854, \"LG\" },\n\t{ 0x19e5, \"Huawei\" },\n\t{ 0x1aec, \"Wolfson Microelectronics\" },\n\t{ 0x1af4, \"QEMU\" },\n\t{ 0x434d, \"C-Media\" },\n\t{ 0x8086, \"Intel\" },\n\t{ 0x8384, \"SigmaTel\" },\n\t{}  \n};\n\n \nstatic int get_codec_vendor_name(struct hdac_device *codec)\n{\n\tconst struct hda_vendor_id *c;\n\tu16 vendor_id = codec->vendor_id >> 16;\n\n\tfor (c = hda_vendor_ids; c->id; c++) {\n\t\tif (c->id == vendor_id) {\n\t\t\tcodec->vendor_name = kstrdup(c->name, GFP_KERNEL);\n\t\t\treturn codec->vendor_name ? 0 : -ENOMEM;\n\t\t}\n\t}\n\n\tcodec->vendor_name = kasprintf(GFP_KERNEL, \"Generic %04x\", vendor_id);\n\treturn codec->vendor_name ? 0 : -ENOMEM;\n}\n\n \nstruct hda_rate_tbl {\n\tunsigned int hz;\n\tunsigned int alsa_bits;\n\tunsigned int hda_fmt;\n};\n\n \n#define HDA_RATE(base, mult, div) \\\n\t(AC_FMT_BASE_##base##K | (((mult) - 1) << AC_FMT_MULT_SHIFT) | \\\n\t (((div) - 1) << AC_FMT_DIV_SHIFT))\n\nstatic const struct hda_rate_tbl rate_bits[] = {\n\t \n\n\t \n\t{ 8000, SNDRV_PCM_RATE_8000, HDA_RATE(48, 1, 6) },\n\t{ 11025, SNDRV_PCM_RATE_11025, HDA_RATE(44, 1, 4) },\n\t{ 16000, SNDRV_PCM_RATE_16000, HDA_RATE(48, 1, 3) },\n\t{ 22050, SNDRV_PCM_RATE_22050, HDA_RATE(44, 1, 2) },\n\t{ 32000, SNDRV_PCM_RATE_32000, HDA_RATE(48, 2, 3) },\n\t{ 44100, SNDRV_PCM_RATE_44100, HDA_RATE(44, 1, 1) },\n\t{ 48000, SNDRV_PCM_RATE_48000, HDA_RATE(48, 1, 1) },\n\t{ 88200, SNDRV_PCM_RATE_88200, HDA_RATE(44, 2, 1) },\n\t{ 96000, SNDRV_PCM_RATE_96000, HDA_RATE(48, 2, 1) },\n\t{ 176400, SNDRV_PCM_RATE_176400, HDA_RATE(44, 4, 1) },\n\t{ 192000, SNDRV_PCM_RATE_192000, HDA_RATE(48, 4, 1) },\n#define AC_PAR_PCM_RATE_BITS\t11\n\t \n\n\t \n\t{ 9600, SNDRV_PCM_RATE_KNOT, HDA_RATE(48, 1, 5) },\n\n\t{ 0 }  \n};\n\n \nunsigned int snd_hdac_calc_stream_format(unsigned int rate,\n\t\t\t\t\t unsigned int channels,\n\t\t\t\t\t snd_pcm_format_t format,\n\t\t\t\t\t unsigned int maxbps,\n\t\t\t\t\t unsigned short spdif_ctls)\n{\n\tint i;\n\tunsigned int val = 0;\n\n\tfor (i = 0; rate_bits[i].hz; i++)\n\t\tif (rate_bits[i].hz == rate) {\n\t\t\tval = rate_bits[i].hda_fmt;\n\t\t\tbreak;\n\t\t}\n\tif (!rate_bits[i].hz)\n\t\treturn 0;\n\n\tif (channels == 0 || channels > 8)\n\t\treturn 0;\n\tval |= channels - 1;\n\n\tswitch (snd_pcm_format_width(format)) {\n\tcase 8:\n\t\tval |= AC_FMT_BITS_8;\n\t\tbreak;\n\tcase 16:\n\t\tval |= AC_FMT_BITS_16;\n\t\tbreak;\n\tcase 20:\n\tcase 24:\n\tcase 32:\n\t\tif (maxbps >= 32 || format == SNDRV_PCM_FORMAT_FLOAT_LE)\n\t\t\tval |= AC_FMT_BITS_32;\n\t\telse if (maxbps >= 24)\n\t\t\tval |= AC_FMT_BITS_24;\n\t\telse\n\t\t\tval |= AC_FMT_BITS_20;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (spdif_ctls & AC_DIG1_NONAUDIO)\n\t\tval |= AC_FMT_TYPE_NON_PCM;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_calc_stream_format);\n\nstatic unsigned int query_pcm_param(struct hdac_device *codec, hda_nid_t nid)\n{\n\tunsigned int val = 0;\n\n\tif (nid != codec->afg &&\n\t    (get_wcaps(codec, nid) & AC_WCAP_FORMAT_OVRD))\n\t\tval = snd_hdac_read_parm(codec, nid, AC_PAR_PCM);\n\tif (!val || val == -1)\n\t\tval = snd_hdac_read_parm(codec, codec->afg, AC_PAR_PCM);\n\tif (!val || val == -1)\n\t\treturn 0;\n\treturn val;\n}\n\nstatic unsigned int query_stream_param(struct hdac_device *codec, hda_nid_t nid)\n{\n\tunsigned int streams = snd_hdac_read_parm(codec, nid, AC_PAR_STREAM);\n\n\tif (!streams || streams == -1)\n\t\tstreams = snd_hdac_read_parm(codec, codec->afg, AC_PAR_STREAM);\n\tif (!streams || streams == -1)\n\t\treturn 0;\n\treturn streams;\n}\n\n \nint snd_hdac_query_supported_pcm(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\t u32 *ratesp, u64 *formatsp, unsigned int *bpsp)\n{\n\tunsigned int i, val, wcaps;\n\n\twcaps = get_wcaps(codec, nid);\n\tval = query_pcm_param(codec, nid);\n\n\tif (ratesp) {\n\t\tu32 rates = 0;\n\t\tfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++) {\n\t\t\tif (val & (1 << i))\n\t\t\t\trates |= rate_bits[i].alsa_bits;\n\t\t}\n\t\tif (rates == 0) {\n\t\t\tdev_err(&codec->dev,\n\t\t\t\t\"rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\\n\",\n\t\t\t\tnid, val,\n\t\t\t\t(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);\n\t\t\treturn -EIO;\n\t\t}\n\t\t*ratesp = rates;\n\t}\n\n\tif (formatsp || bpsp) {\n\t\tu64 formats = 0;\n\t\tunsigned int streams, bps;\n\n\t\tstreams = query_stream_param(codec, nid);\n\t\tif (!streams)\n\t\t\treturn -EIO;\n\n\t\tbps = 0;\n\t\tif (streams & AC_SUPFMT_PCM) {\n\t\t\tif (val & AC_SUPPCM_BITS_8) {\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_U8;\n\t\t\t\tbps = 8;\n\t\t\t}\n\t\t\tif (val & AC_SUPPCM_BITS_16) {\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S16_LE;\n\t\t\t\tbps = 16;\n\t\t\t}\n\t\t\tif (wcaps & AC_WCAP_DIGITAL) {\n\t\t\t\tif (val & AC_SUPPCM_BITS_32)\n\t\t\t\t\tformats |= SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;\n\t\t\t\tif (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24))\n\t\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\t\tif (val & AC_SUPPCM_BITS_24)\n\t\t\t\t\tbps = 24;\n\t\t\t\telse if (val & AC_SUPPCM_BITS_20)\n\t\t\t\t\tbps = 20;\n\t\t\t} else if (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24|\n\t\t\t\t\t  AC_SUPPCM_BITS_32)) {\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\t\tif (val & AC_SUPPCM_BITS_32)\n\t\t\t\t\tbps = 32;\n\t\t\t\telse if (val & AC_SUPPCM_BITS_24)\n\t\t\t\t\tbps = 24;\n\t\t\t\telse if (val & AC_SUPPCM_BITS_20)\n\t\t\t\t\tbps = 20;\n\t\t\t}\n\t\t}\n#if 0  \n\t\tif (streams & AC_SUPFMT_FLOAT32) {\n\t\t\tformats |= SNDRV_PCM_FMTBIT_FLOAT_LE;\n\t\t\tif (!bps)\n\t\t\t\tbps = 32;\n\t\t}\n#endif\n\t\tif (streams == AC_SUPFMT_AC3) {\n\t\t\t \n\t\t\t \n\t\t\tformats |= SNDRV_PCM_FMTBIT_U8;\n\t\t\tbps = 8;\n\t\t}\n\t\tif (formats == 0) {\n\t\t\tdev_err(&codec->dev,\n\t\t\t\t\"formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\\n\",\n\t\t\t\tnid, val,\n\t\t\t\t(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,\n\t\t\t\tstreams);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (formatsp)\n\t\t\t*formatsp = formats;\n\t\tif (bpsp)\n\t\t\t*bpsp = bps;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_query_supported_pcm);\n\n \nbool snd_hdac_is_supported_format(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\t  unsigned int format)\n{\n\tint i;\n\tunsigned int val = 0, rate, stream;\n\n\tval = query_pcm_param(codec, nid);\n\tif (!val)\n\t\treturn false;\n\n\trate = format & 0xff00;\n\tfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++)\n\t\tif (rate_bits[i].hda_fmt == rate) {\n\t\t\tif (val & (1 << i))\n\t\t\t\tbreak;\n\t\t\treturn false;\n\t\t}\n\tif (i >= AC_PAR_PCM_RATE_BITS)\n\t\treturn false;\n\n\tstream = query_stream_param(codec, nid);\n\tif (!stream)\n\t\treturn false;\n\n\tif (stream & AC_SUPFMT_PCM) {\n\t\tswitch (format & 0xf0) {\n\t\tcase 0x00:\n\t\t\tif (!(val & AC_SUPPCM_BITS_8))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tif (!(val & AC_SUPPCM_BITS_16))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 0x20:\n\t\t\tif (!(val & AC_SUPPCM_BITS_20))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 0x30:\n\t\t\tif (!(val & AC_SUPPCM_BITS_24))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tif (!(val & AC_SUPPCM_BITS_32))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t \n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_is_supported_format);\n\nstatic unsigned int codec_read(struct hdac_device *hdac, hda_nid_t nid,\n\t\t\tint flags, unsigned int verb, unsigned int parm)\n{\n\tunsigned int cmd = snd_hdac_make_cmd(hdac, nid, verb, parm);\n\tunsigned int res;\n\n\tif (snd_hdac_exec_verb(hdac, cmd, flags, &res))\n\t\treturn -1;\n\n\treturn res;\n}\n\nstatic int codec_write(struct hdac_device *hdac, hda_nid_t nid,\n\t\t\tint flags, unsigned int verb, unsigned int parm)\n{\n\tunsigned int cmd = snd_hdac_make_cmd(hdac, nid, verb, parm);\n\n\treturn snd_hdac_exec_verb(hdac, cmd, flags, NULL);\n}\n\n \nint snd_hdac_codec_read(struct hdac_device *hdac, hda_nid_t nid,\n\t\t\tint flags, unsigned int verb, unsigned int parm)\n{\n\treturn codec_read(hdac, nid, flags, verb, parm);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_codec_read);\n\n \nint snd_hdac_codec_write(struct hdac_device *hdac, hda_nid_t nid,\n\t\t\tint flags, unsigned int verb, unsigned int parm)\n{\n\treturn codec_write(hdac, nid, flags, verb, parm);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_codec_write);\n\n \nbool snd_hdac_check_power_state(struct hdac_device *hdac,\n\t\thda_nid_t nid, unsigned int target_state)\n{\n\tunsigned int state = codec_read(hdac, nid, 0,\n\t\t\t\tAC_VERB_GET_POWER_STATE, 0);\n\n\tif (state & AC_PWRST_ERROR)\n\t\treturn true;\n\tstate = (state >> 4) & 0x0f;\n\treturn (state == target_state);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_check_power_state);\n \nunsigned int snd_hdac_sync_power_state(struct hdac_device *codec,\n\t\t\thda_nid_t nid, unsigned int power_state)\n{\n\tunsigned long end_time = jiffies + msecs_to_jiffies(500);\n\tunsigned int state, actual_state, count;\n\n\tfor (count = 0; count < 500; count++) {\n\t\tstate = snd_hdac_codec_read(codec, nid, 0,\n\t\t\t\tAC_VERB_GET_POWER_STATE, 0);\n\t\tif (state & AC_PWRST_ERROR) {\n\t\t\tmsleep(20);\n\t\t\tbreak;\n\t\t}\n\t\tactual_state = (state >> 4) & 0x0f;\n\t\tif (actual_state == power_state)\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, end_time))\n\t\t\tbreak;\n\t\t \n\t\tmsleep(1);\n\t}\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_sync_power_state);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}