{
  "module_name": "hdac_sysfs.c",
  "hash_id": "08a56cfb34ddcca96ba971b4874d1e1166f7f70b81d6183f1e296a9d759af34e",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <sound/core.h>\n#include <sound/hdaudio.h>\n#include \"local.h\"\n\nstruct hdac_widget_tree {\n\tstruct kobject *root;\n\tstruct kobject *afg;\n\tstruct kobject **nodes;\n};\n\n#define CODEC_ATTR(type)\t\t\t\t\t\\\nstatic ssize_t type##_show(struct device *dev,\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\\\n\t\t\t   char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hdac_device *codec = dev_to_hdac_dev(dev);\t\\\n\treturn sysfs_emit(buf, \"0x%x\\n\", codec->type);\t\t\\\n} \\\nstatic DEVICE_ATTR_RO(type)\n\n#define CODEC_ATTR_STR(type)\t\t\t\t\t\\\nstatic ssize_t type##_show(struct device *dev,\t\t\t\\\n\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hdac_device *codec = dev_to_hdac_dev(dev);\t\\\n\treturn sysfs_emit(buf, \"%s\\n\",\t\t\t\t\\\n\t\t\t  codec->type ? codec->type : \"\");\t\\\n} \\\nstatic DEVICE_ATTR_RO(type)\n\nCODEC_ATTR(type);\nCODEC_ATTR(vendor_id);\nCODEC_ATTR(subsystem_id);\nCODEC_ATTR(revision_id);\nCODEC_ATTR(afg);\nCODEC_ATTR(mfg);\nCODEC_ATTR_STR(vendor_name);\nCODEC_ATTR_STR(chip_name);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snd_hdac_codec_modalias(dev_to_hdac_dev(dev), buf, 256);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *hdac_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_vendor_id.attr,\n\t&dev_attr_subsystem_id.attr,\n\t&dev_attr_revision_id.attr,\n\t&dev_attr_afg.attr,\n\t&dev_attr_mfg.attr,\n\t&dev_attr_vendor_name.attr,\n\t&dev_attr_chip_name.attr,\n\t&dev_attr_modalias.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hdac_dev_attr_group = {\n\t.attrs\t= hdac_dev_attrs,\n};\n\nconst struct attribute_group *hdac_dev_attr_groups[] = {\n\t&hdac_dev_attr_group,\n\tNULL\n};\n\n \n\nstruct widget_attribute;\n\nstruct widget_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(struct hdac_device *codec, hda_nid_t nid,\n\t\t\tstruct widget_attribute *attr, char *buf);\n\tssize_t (*store)(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t struct widget_attribute *attr,\n\t\t\t const char *buf, size_t count);\n};\n\nstatic int get_codec_nid(struct kobject *kobj, struct hdac_device **codecp)\n{\n\tstruct device *dev = kobj_to_dev(kobj->parent->parent);\n\tint nid;\n\tssize_t ret;\n\n\tret = kstrtoint(kobj->name, 16, &nid);\n\tif (ret < 0)\n\t\treturn ret;\n\t*codecp = dev_to_hdac_dev(dev);\n\treturn nid;\n}\n\nstatic ssize_t widget_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct widget_attribute *wid_attr =\n\t\tcontainer_of(attr, struct widget_attribute, attr);\n\tstruct hdac_device *codec;\n\tint nid;\n\n\tif (!wid_attr->show)\n\t\treturn -EIO;\n\tnid = get_codec_nid(kobj, &codec);\n\tif (nid < 0)\n\t\treturn nid;\n\treturn wid_attr->show(codec, nid, wid_attr, buf);\n}\n\nstatic ssize_t widget_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct widget_attribute *wid_attr =\n\t\tcontainer_of(attr, struct widget_attribute, attr);\n\tstruct hdac_device *codec;\n\tint nid;\n\n\tif (!wid_attr->store)\n\t\treturn -EIO;\n\tnid = get_codec_nid(kobj, &codec);\n\tif (nid < 0)\n\t\treturn nid;\n\treturn wid_attr->store(codec, nid, wid_attr, buf, count);\n}\n\nstatic const struct sysfs_ops widget_sysfs_ops = {\n\t.show\t= widget_attr_show,\n\t.store\t= widget_attr_store,\n};\n\nstatic void widget_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type widget_ktype = {\n\t.release\t= widget_release,\n\t.sysfs_ops\t= &widget_sysfs_ops,\n};\n\n#define WIDGET_ATTR_RO(_name) \\\n\tstruct widget_attribute wid_attr_##_name = __ATTR_RO(_name)\n#define WIDGET_ATTR_RW(_name) \\\n\tstruct widget_attribute wid_attr_##_name = __ATTR_RW(_name)\n\nstatic ssize_t caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\tstruct widget_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\", get_wcaps(codec, nid));\n}\n\nstatic ssize_t pin_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t     struct widget_attribute *attr, char *buf)\n{\n\tif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_PIN_CAP));\n}\n\nstatic ssize_t pin_cfg_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t    struct widget_attribute *attr, char *buf)\n{\n\tunsigned int val;\n\n\tif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\n\t\treturn 0;\n\tif (snd_hdac_read(codec, nid, AC_VERB_GET_CONFIG_DEFAULT, 0, &val))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\", val);\n}\n\nstatic bool has_pcm_cap(struct hdac_device *codec, hda_nid_t nid)\n{\n\tif (nid == codec->afg || nid == codec->mfg)\n\t\treturn true;\n\tswitch (get_wcaps_type(get_wcaps(codec, nid))) {\n\tcase AC_WID_AUD_OUT:\n\tcase AC_WID_AUD_IN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic ssize_t pcm_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t     struct widget_attribute *attr, char *buf)\n{\n\tif (!has_pcm_cap(codec, nid))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_PCM));\n}\n\nstatic ssize_t pcm_formats_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\tstruct widget_attribute *attr, char *buf)\n{\n\tif (!has_pcm_cap(codec, nid))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_STREAM));\n}\n\nstatic ssize_t amp_in_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\tstruct widget_attribute *attr, char *buf)\n{\n\tif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_IN_AMP))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_AMP_IN_CAP));\n}\n\nstatic ssize_t amp_out_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\t struct widget_attribute *attr, char *buf)\n{\n\tif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_OUT_AMP))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_AMP_OUT_CAP));\n}\n\nstatic ssize_t power_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t       struct widget_attribute *attr, char *buf)\n{\n\tif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_POWER))\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_POWER_STATE));\n}\n\nstatic ssize_t gpio_caps_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t      struct widget_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t  snd_hdac_read_parm(codec, nid, AC_PAR_GPIO_CAP));\n}\n\nstatic ssize_t connections_show(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t\tstruct widget_attribute *attr, char *buf)\n{\n\thda_nid_t list[32];\n\tint i, nconns;\n\tssize_t ret = 0;\n\n\tnconns = snd_hdac_get_connections(codec, nid, list, ARRAY_SIZE(list));\n\tif (nconns <= 0)\n\t\treturn nconns;\n\tfor (i = 0; i < nconns; i++)\n\t\tret += sysfs_emit_at(buf,  ret, \"%s0x%02x\", i ? \" \" : \"\", list[i]);\n\tret += sysfs_emit_at(buf, ret, \"\\n\");\n\treturn ret;\n}\n\nstatic WIDGET_ATTR_RO(caps);\nstatic WIDGET_ATTR_RO(pin_caps);\nstatic WIDGET_ATTR_RO(pin_cfg);\nstatic WIDGET_ATTR_RO(pcm_caps);\nstatic WIDGET_ATTR_RO(pcm_formats);\nstatic WIDGET_ATTR_RO(amp_in_caps);\nstatic WIDGET_ATTR_RO(amp_out_caps);\nstatic WIDGET_ATTR_RO(power_caps);\nstatic WIDGET_ATTR_RO(gpio_caps);\nstatic WIDGET_ATTR_RO(connections);\n\nstatic struct attribute *widget_node_attrs[] = {\n\t&wid_attr_caps.attr,\n\t&wid_attr_pin_caps.attr,\n\t&wid_attr_pin_cfg.attr,\n\t&wid_attr_pcm_caps.attr,\n\t&wid_attr_pcm_formats.attr,\n\t&wid_attr_amp_in_caps.attr,\n\t&wid_attr_amp_out_caps.attr,\n\t&wid_attr_power_caps.attr,\n\t&wid_attr_connections.attr,\n\tNULL,\n};\n\nstatic struct attribute *widget_afg_attrs[] = {\n\t&wid_attr_pcm_caps.attr,\n\t&wid_attr_pcm_formats.attr,\n\t&wid_attr_amp_in_caps.attr,\n\t&wid_attr_amp_out_caps.attr,\n\t&wid_attr_power_caps.attr,\n\t&wid_attr_gpio_caps.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group widget_node_group = {\n\t.attrs = widget_node_attrs,\n};\n\nstatic const struct attribute_group widget_afg_group = {\n\t.attrs = widget_afg_attrs,\n};\n\nstatic void free_widget_node(struct kobject *kobj,\n\t\t\t     const struct attribute_group *group)\n{\n\tif (kobj) {\n\t\tsysfs_remove_group(kobj, group);\n\t\tkobject_put(kobj);\n\t}\n}\n\nstatic void widget_tree_free(struct hdac_device *codec)\n{\n\tstruct hdac_widget_tree *tree = codec->widgets;\n\tstruct kobject **p;\n\n\tif (!tree)\n\t\treturn;\n\tfree_widget_node(tree->afg, &widget_afg_group);\n\tif (tree->nodes) {\n\t\tfor (p = tree->nodes; *p; p++)\n\t\t\tfree_widget_node(*p, &widget_node_group);\n\t\tkfree(tree->nodes);\n\t}\n\tkobject_put(tree->root);\n\tkfree(tree);\n\tcodec->widgets = NULL;\n}\n\nstatic int add_widget_node(struct kobject *parent, hda_nid_t nid,\n\t\t\t   const struct attribute_group *group,\n\t\t\t   struct kobject **res)\n{\n\tstruct kobject *kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);\n\tint err;\n\n\tif (!kobj)\n\t\treturn -ENOMEM;\n\tkobject_init(kobj, &widget_ktype);\n\terr = kobject_add(kobj, parent, \"%02x\", nid);\n\tif (err < 0) {\n\t\tkobject_put(kobj);\n\t\treturn err;\n\t}\n\terr = sysfs_create_group(kobj, group);\n\tif (err < 0) {\n\t\tkobject_put(kobj);\n\t\treturn err;\n\t}\n\n\t*res = kobj;\n\treturn 0;\n}\n\nstatic int widget_tree_create(struct hdac_device *codec)\n{\n\tstruct hdac_widget_tree *tree;\n\tint i, err;\n\thda_nid_t nid;\n\n\ttree = codec->widgets = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn -ENOMEM;\n\n\ttree->root = kobject_create_and_add(\"widgets\", &codec->dev.kobj);\n\tif (!tree->root)\n\t\treturn -ENOMEM;\n\n\ttree->nodes = kcalloc(codec->num_nodes + 1, sizeof(*tree->nodes),\n\t\t\t      GFP_KERNEL);\n\tif (!tree->nodes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, nid = codec->start_nid; i < codec->num_nodes; i++, nid++) {\n\t\terr = add_widget_node(tree->root, nid, &widget_node_group,\n\t\t\t\t      &tree->nodes[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (codec->afg) {\n\t\terr = add_widget_node(tree->root, codec->afg,\n\t\t\t\t      &widget_afg_group, &tree->afg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tkobject_uevent(tree->root, KOBJ_CHANGE);\n\treturn 0;\n}\n\n \nint hda_widget_sysfs_init(struct hdac_device *codec)\n{\n\tint err;\n\n\tif (codec->widgets)\n\t\treturn 0;  \n\n\terr = widget_tree_create(codec);\n\tif (err < 0) {\n\t\twidget_tree_free(codec);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nvoid hda_widget_sysfs_exit(struct hdac_device *codec)\n{\n\twidget_tree_free(codec);\n}\n\n \nint hda_widget_sysfs_reinit(struct hdac_device *codec,\n\t\t\t    hda_nid_t start_nid, int num_nodes)\n{\n\tstruct hdac_widget_tree *tree;\n\thda_nid_t end_nid = start_nid + num_nodes;\n\thda_nid_t nid;\n\tint i;\n\n\tif (!codec->widgets)\n\t\treturn 0;\n\n\ttree = kmemdup(codec->widgets, sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn -ENOMEM;\n\n\ttree->nodes = kcalloc(num_nodes + 1, sizeof(*tree->nodes), GFP_KERNEL);\n\tif (!tree->nodes) {\n\t\tkfree(tree);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0, nid = codec->start_nid; i < codec->num_nodes; i++, nid++) {\n\t\tif (nid < start_nid || nid >= end_nid)\n\t\t\tfree_widget_node(codec->widgets->nodes[i],\n\t\t\t\t\t &widget_node_group);\n\t}\n\n\t \n\tfor (i = 0, nid = start_nid; i < num_nodes; i++, nid++) {\n\t\tif (nid < codec->start_nid || nid >= codec->end_nid)\n\t\t\tadd_widget_node(tree->root, nid, &widget_node_group,\n\t\t\t\t\t&tree->nodes[i]);\n\t\telse\n\t\t\ttree->nodes[i] =\n\t\t\t\tcodec->widgets->nodes[nid - codec->start_nid];\n\t}\n\n\t \n\tkfree(codec->widgets->nodes);\n\tkfree(codec->widgets);\n\tcodec->widgets = tree;\n\n\tkobject_uevent(tree->root, KOBJ_CHANGE);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}