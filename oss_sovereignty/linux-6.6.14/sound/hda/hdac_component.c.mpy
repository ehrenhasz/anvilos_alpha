{
  "module_name": "hdac_component.c",
  "hash_id": "ee1a5b8a761716c0ce32fb37e47ff97c86a158b10335888a23fb3f163476c2f3",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_component.c",
  "human_readable_source": "\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/component.h>\n#include <sound/core.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_component.h>\n#include <sound/hda_register.h>\n\nstatic void hdac_acomp_release(struct device *dev, void *res)\n{\n}\n\nstatic struct drm_audio_component *hdac_get_acomp(struct device *dev)\n{\n\treturn devres_find(dev, hdac_acomp_release, NULL, NULL);\n}\n\n \nint snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)\n{\n\tstruct drm_audio_component *acomp = bus->audio_component;\n\n\tif (!acomp || !acomp->ops)\n\t\treturn -ENODEV;\n\n\tif (!acomp->ops->codec_wake_override)\n\t\treturn 0;\n\n\tdev_dbg(bus->dev, \"%s codec wakeup\\n\",\n\t\tenable ? \"enable\" : \"disable\");\n\n\tacomp->ops->codec_wake_override(acomp->dev, enable);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);\n\n \nvoid snd_hdac_display_power(struct hdac_bus *bus, unsigned int idx, bool enable)\n{\n\tstruct drm_audio_component *acomp = bus->audio_component;\n\n\tdev_dbg(bus->dev, \"display power %s\\n\",\n\t\tenable ? \"enable\" : \"disable\");\n\n\tmutex_lock(&bus->lock);\n\tif (enable)\n\t\tset_bit(idx, &bus->display_power_status);\n\telse\n\t\tclear_bit(idx, &bus->display_power_status);\n\n\tif (!acomp || !acomp->ops)\n\t\tgoto unlock;\n\n\tif (bus->display_power_status) {\n\t\tif (!bus->display_power_active) {\n\t\t\tunsigned long cookie = -1;\n\n\t\t\tif (acomp->ops->get_power)\n\t\t\t\tcookie = acomp->ops->get_power(acomp->dev);\n\n\t\t\tsnd_hdac_set_codec_wakeup(bus, true);\n\t\t\tsnd_hdac_set_codec_wakeup(bus, false);\n\t\t\tbus->display_power_active = cookie;\n\t\t}\n\t} else {\n\t\tif (bus->display_power_active) {\n\t\t\tunsigned long cookie = bus->display_power_active;\n\n\t\t\tif (acomp->ops->put_power)\n\t\t\t\tacomp->ops->put_power(acomp->dev, cookie);\n\n\t\t\tbus->display_power_active = 0;\n\t\t}\n\t}\n unlock:\n\tmutex_unlock(&bus->lock);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_display_power);\n\n \nint snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,\n\t\t\t     int dev_id, int rate)\n{\n\tstruct hdac_bus *bus = codec->bus;\n\tstruct drm_audio_component *acomp = bus->audio_component;\n\tint port, pipe;\n\n\tif (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)\n\t\treturn -ENODEV;\n\tport = nid;\n\tif (acomp->audio_ops && acomp->audio_ops->pin2port) {\n\t\tport = acomp->audio_ops->pin2port(codec, nid);\n\t\tif (port < 0)\n\t\t\treturn -EINVAL;\n\t}\n\tpipe = dev_id;\n\treturn acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);\n\n \nint snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,\n\t\t\t   bool *audio_enabled, char *buffer, int max_bytes)\n{\n\tstruct hdac_bus *bus = codec->bus;\n\tstruct drm_audio_component *acomp = bus->audio_component;\n\tint port, pipe;\n\n\tif (!acomp || !acomp->ops || !acomp->ops->get_eld)\n\t\treturn -ENODEV;\n\n\tport = nid;\n\tif (acomp->audio_ops && acomp->audio_ops->pin2port) {\n\t\tport = acomp->audio_ops->pin2port(codec, nid);\n\t\tif (port < 0)\n\t\t\treturn -EINVAL;\n\t}\n\tpipe = dev_id;\n\treturn acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,\n\t\t\t\t   buffer, max_bytes);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);\n\nstatic int hdac_component_master_bind(struct device *dev)\n{\n\tstruct drm_audio_component *acomp = hdac_get_acomp(dev);\n\tint ret;\n\n\tif (WARN_ON(!acomp))\n\t\treturn -EINVAL;\n\n\tret = component_bind_all(dev, acomp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (WARN_ON(!(acomp->dev && acomp->ops))) {\n\t\tret = -EINVAL;\n\t\tgoto out_unbind;\n\t}\n\n\t \n\tif (!try_module_get(acomp->ops->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unbind;\n\t}\n\n\tif (acomp->audio_ops && acomp->audio_ops->master_bind) {\n\t\tret = acomp->audio_ops->master_bind(dev, acomp);\n\t\tif (ret < 0)\n\t\t\tgoto module_put;\n\t}\n\n\tcomplete_all(&acomp->master_bind_complete);\n\treturn 0;\n\n module_put:\n\tmodule_put(acomp->ops->owner);\nout_unbind:\n\tcomponent_unbind_all(dev, acomp);\n\tcomplete_all(&acomp->master_bind_complete);\n\n\treturn ret;\n}\n\nstatic void hdac_component_master_unbind(struct device *dev)\n{\n\tstruct drm_audio_component *acomp = hdac_get_acomp(dev);\n\n\tif (acomp->audio_ops && acomp->audio_ops->master_unbind)\n\t\tacomp->audio_ops->master_unbind(dev, acomp);\n\tmodule_put(acomp->ops->owner);\n\tcomponent_unbind_all(dev, acomp);\n\tWARN_ON(acomp->ops || acomp->dev);\n}\n\nstatic const struct component_master_ops hdac_component_master_ops = {\n\t.bind = hdac_component_master_bind,\n\t.unbind = hdac_component_master_unbind,\n};\n\n \nint snd_hdac_acomp_register_notifier(struct hdac_bus *bus,\n\t\t\t\t    const struct drm_audio_component_audio_ops *aops)\n{\n\tif (!bus->audio_component)\n\t\treturn -ENODEV;\n\n\tbus->audio_component->audio_ops = aops;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_acomp_register_notifier);\n\n \nint snd_hdac_acomp_init(struct hdac_bus *bus,\n\t\t\tconst struct drm_audio_component_audio_ops *aops,\n\t\t\tint (*match_master)(struct device *, int, void *),\n\t\t\tsize_t extra_size)\n{\n\tstruct component_match *match = NULL;\n\tstruct device *dev = bus->dev;\n\tstruct drm_audio_component *acomp;\n\tint ret;\n\n\tif (WARN_ON(hdac_get_acomp(dev)))\n\t\treturn -EBUSY;\n\n\tacomp = devres_alloc(hdac_acomp_release, sizeof(*acomp) + extra_size,\n\t\t\t     GFP_KERNEL);\n\tif (!acomp)\n\t\treturn -ENOMEM;\n\tacomp->audio_ops = aops;\n\tinit_completion(&acomp->master_bind_complete);\n\tbus->audio_component = acomp;\n\tdevres_add(dev, acomp);\n\n\tcomponent_match_add_typed(dev, &match, match_master, bus);\n\tret = component_master_add_with_match(dev, &hdac_component_master_ops,\n\t\t\t\t\t      match);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tbus->audio_component = NULL;\n\tdevres_destroy(dev, hdac_acomp_release, NULL, NULL);\n\tdev_info(dev, \"failed to add audio component master (%d)\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_acomp_init);\n\n \nint snd_hdac_acomp_exit(struct hdac_bus *bus)\n{\n\tstruct device *dev = bus->dev;\n\tstruct drm_audio_component *acomp = bus->audio_component;\n\n\tif (!acomp)\n\t\treturn 0;\n\n\tif (WARN_ON(bus->display_power_active) && acomp->ops)\n\t\tacomp->ops->put_power(acomp->dev, bus->display_power_active);\n\n\tbus->display_power_active = 0;\n\tbus->display_power_status = 0;\n\n\tcomponent_master_del(dev, &hdac_component_master_ops);\n\n\tbus->audio_component = NULL;\n\tdevres_destroy(dev, hdac_acomp_release, NULL, NULL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_acomp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}