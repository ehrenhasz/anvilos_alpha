{
  "module_name": "hdmi_chmap.c",
  "hash_id": "1b64771cb94e4538438d53a5b85d51da61ec2335033986bb4f8067171d81ecc4",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdmi_chmap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/hda_chmap.h>\n\n \nenum cea_speaker_placement {\n\tFL  = (1 <<  0),\t \n\tFC  = (1 <<  1),\t \n\tFR  = (1 <<  2),\t \n\tFLC = (1 <<  3),\t \n\tFRC = (1 <<  4),\t \n\tRL  = (1 <<  5),\t \n\tRC  = (1 <<  6),\t \n\tRR  = (1 <<  7),\t \n\tRLC = (1 <<  8),\t \n\tRRC = (1 <<  9),\t \n\tLFE = (1 << 10),\t \n\tFLW = (1 << 11),\t \n\tFRW = (1 << 12),\t \n\tFLH = (1 << 13),\t \n\tFCH = (1 << 14),\t \n\tFRH = (1 << 15),\t \n\tTC  = (1 << 16),\t \n};\n\nstatic const char * const cea_speaker_allocation_names[] = {\n\t  \"FL/FR\",\n\t  \"LFE\",\n\t  \"FC\",\n\t  \"RL/RR\",\n\t  \"RC\",\n\t  \"FLC/FRC\",\n\t  \"RLC/RRC\",\n\t  \"FLW/FRW\",\n\t  \"FLH/FRH\",\n\t  \"TC\",\n\t  \"FCH\",\n};\n\n \nstatic const int eld_speaker_allocation_bits[] = {\n\t[0] = FL | FR,\n\t[1] = LFE,\n\t[2] = FC,\n\t[3] = RL | RR,\n\t[4] = RC,\n\t[5] = FLC | FRC,\n\t[6] = RLC | RRC,\n\t \n\t[7] = FLW | FRW,\n\t[8] = FLH | FRH,\n\t[9] = TC,\n\t[10] = FCH,\n};\n\n \nstatic int hdmi_channel_mapping[0x32][8] = {\n\t \n\t[0x00] = { 0x00, 0x11, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7 },\n\t \n\t[0x01] = { 0x00, 0x11, 0x22, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7 },\n\t \n\t[0x02] = { 0x00, 0x11, 0x23, 0xf2, 0xf4, 0xf5, 0xf6, 0xf7 },\n\t \n\t[0x08] = { 0x00, 0x11, 0x24, 0x35, 0xf3, 0xf2, 0xf6, 0xf7 },\n\t \n\t[0x03] = { 0x00, 0x11, 0x23, 0x32, 0x44, 0xf5, 0xf6, 0xf7 },\n\t \n\t[0x09] = { 0x00, 0x11, 0x24, 0x35, 0x42, 0xf3, 0xf6, 0xf7 },\n\t \n\t[0x0a] = { 0x00, 0x11, 0x24, 0x35, 0x43, 0xf2, 0xf6, 0xf7 },\n\t \n\t[0x0b] = { 0x00, 0x11, 0x24, 0x35, 0x43, 0x52, 0xf6, 0xf7 },\n\t \n\t[0x13] = { 0x00, 0x11, 0x26, 0x37, 0x43, 0x52, 0x64, 0x75 },\n};\n\n \nstatic struct hdac_cea_channel_speaker_allocation channel_allocations[] = {\n \n{ .ca_index = 0x00,  .speakers = {   0,    0,   0,   0,   0,    0,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x01,  .speakers = {   0,    0,   0,   0,   0,  LFE,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x02,  .speakers = {   0,    0,   0,   0,  FC,    0,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x08,  .speakers = {   0,    0,  RR,  RL,   0,    0,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x09,  .speakers = {   0,    0,  RR,  RL,   0,  LFE,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x0a,  .speakers = {   0,    0,  RR,  RL,  FC,    0,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x0b,  .speakers = {   0,    0,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x0f,  .speakers = {   0,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\t\t\t\t  \n{ .ca_index = 0x13,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\n{ .ca_index = 0x03,  .speakers = {   0,    0,   0,   0,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x04,  .speakers = {   0,    0,   0,  RC,   0,    0,  FR,  FL } },\n{ .ca_index = 0x05,  .speakers = {   0,    0,   0,  RC,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x06,  .speakers = {   0,    0,   0,  RC,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x07,  .speakers = {   0,    0,   0,  RC,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x0c,  .speakers = {   0,   RC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x0d,  .speakers = {   0,   RC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x0e,  .speakers = {   0,   RC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x10,  .speakers = { RRC,  RLC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x11,  .speakers = { RRC,  RLC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x12,  .speakers = { RRC,  RLC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x14,  .speakers = { FRC,  FLC,   0,   0,   0,    0,  FR,  FL } },\n{ .ca_index = 0x15,  .speakers = { FRC,  FLC,   0,   0,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x16,  .speakers = { FRC,  FLC,   0,   0,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x17,  .speakers = { FRC,  FLC,   0,   0,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x18,  .speakers = { FRC,  FLC,   0,  RC,   0,    0,  FR,  FL } },\n{ .ca_index = 0x19,  .speakers = { FRC,  FLC,   0,  RC,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x1a,  .speakers = { FRC,  FLC,   0,  RC,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x1b,  .speakers = { FRC,  FLC,   0,  RC,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x1c,  .speakers = { FRC,  FLC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x1d,  .speakers = { FRC,  FLC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x1e,  .speakers = { FRC,  FLC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x1f,  .speakers = { FRC,  FLC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x20,  .speakers = {   0,  FCH,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x21,  .speakers = {   0,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x22,  .speakers = {  TC,    0,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x23,  .speakers = {  TC,    0,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x24,  .speakers = { FRH,  FLH,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x25,  .speakers = { FRH,  FLH,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x26,  .speakers = { FRW,  FLW,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x27,  .speakers = { FRW,  FLW,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x28,  .speakers = {  TC,   RC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x29,  .speakers = {  TC,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x2a,  .speakers = { FCH,   RC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x2b,  .speakers = { FCH,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x2c,  .speakers = {  TC,  FCH,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x2d,  .speakers = {  TC,  FCH,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x2e,  .speakers = { FRH,  FLH,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x2f,  .speakers = { FRH,  FLH,  RR,  RL,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x30,  .speakers = { FRW,  FLW,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x31,  .speakers = { FRW,  FLW,  RR,  RL,  FC,  LFE,  FR,  FL } },\n};\n\nstatic int hdmi_pin_set_slot_channel(struct hdac_device *codec,\n\t\thda_nid_t pin_nid, int asp_slot, int channel)\n{\n\treturn snd_hdac_codec_write(codec, pin_nid, 0,\n\t\t\t\tAC_VERB_SET_HDMI_CHAN_SLOT,\n\t\t\t\t(channel << 4) | asp_slot);\n}\n\nstatic int hdmi_pin_get_slot_channel(struct hdac_device *codec,\n\t\t\thda_nid_t pin_nid, int asp_slot)\n{\n\treturn (snd_hdac_codec_read(codec, pin_nid, 0,\n\t\t\t\t   AC_VERB_GET_HDMI_CHAN_SLOT,\n\t\t\t\t   asp_slot) & 0xf0) >> 4;\n}\n\nstatic int hdmi_get_channel_count(struct hdac_device *codec, hda_nid_t cvt_nid)\n{\n\treturn 1 + snd_hdac_codec_read(codec, cvt_nid, 0,\n\t\t\t\t\tAC_VERB_GET_CVT_CHAN_COUNT, 0);\n}\n\nstatic void hdmi_set_channel_count(struct hdac_device *codec,\n\t\t\t\t   hda_nid_t cvt_nid, int chs)\n{\n\tif (chs != hdmi_get_channel_count(codec, cvt_nid))\n\t\tsnd_hdac_codec_write(codec, cvt_nid, 0,\n\t\t\t\t    AC_VERB_SET_CVT_CHAN_COUNT, chs - 1);\n}\n\n \n\n \nstatic void init_channel_allocations(void)\n{\n\tint i, j;\n\tstruct hdac_cea_channel_speaker_allocation *p;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tp = channel_allocations + i;\n\t\tp->channels = 0;\n\t\tp->spk_mask = 0;\n\t\tfor (j = 0; j < ARRAY_SIZE(p->speakers); j++)\n\t\t\tif (p->speakers[j]) {\n\t\t\t\tp->channels++;\n\t\t\t\tp->spk_mask |= p->speakers[j];\n\t\t\t}\n\t}\n}\n\nstatic int get_channel_allocation_order(int ca)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tif (channel_allocations[i].ca_index == ca)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nvoid snd_hdac_print_channel_allocation(int spk_alloc, char *buf, int buflen)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(cea_speaker_allocation_names); i++) {\n\t\tif (spk_alloc & (1 << i))\n\t\t\tj += scnprintf(buf + j, buflen - j,  \" %s\",\n\t\t\t\t\tcea_speaker_allocation_names[i]);\n\t}\n\tbuf[j] = '\\0';\t \n}\nEXPORT_SYMBOL_GPL(snd_hdac_print_channel_allocation);\n\n \nstatic int hdmi_channel_allocation_spk_alloc_blk(struct hdac_device *codec,\n\t\t\t\t   int spk_alloc, int channels)\n{\n\tint i;\n\tint ca = 0;\n\tint spk_mask = 0;\n\tchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\n\n\t \n\tif (channels <= 2)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\n\t\tif (spk_alloc & (1 << i))\n\t\t\tspk_mask |= eld_speaker_allocation_bits[i];\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tif (channels == channel_allocations[i].channels &&\n\t\t    (spk_mask & channel_allocations[i].spk_mask) ==\n\t\t\t\tchannel_allocations[i].spk_mask) {\n\t\t\tca = channel_allocations[i].ca_index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ca) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\t\tif (channels == channel_allocations[i].channels) {\n\t\t\t\tca = channel_allocations[i].ca_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_hdac_print_channel_allocation(spk_alloc, buf, sizeof(buf));\n\tdev_dbg(&codec->dev, \"HDMI: select CA 0x%x for %d-channel allocation: %s\\n\",\n\t\t    ca, channels, buf);\n\n\treturn ca;\n}\n\nstatic void hdmi_debug_channel_mapping(struct hdac_chmap *chmap,\n\t\t\t\t       hda_nid_t pin_nid)\n{\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tint i;\n\tint channel;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tchannel = chmap->ops.pin_get_slot_channel(\n\t\t\t\tchmap->hdac, pin_nid, i);\n\t\tdev_dbg(&chmap->hdac->dev, \"HDMI: ASP channel %d => slot %d\\n\",\n\t\t\t\t\t\tchannel, i);\n\t}\n#endif\n}\n\nstatic void hdmi_std_setup_channel_mapping(struct hdac_chmap *chmap,\n\t\t\t\t       hda_nid_t pin_nid,\n\t\t\t\t       bool non_pcm,\n\t\t\t\t       int ca)\n{\n\tstruct hdac_cea_channel_speaker_allocation *ch_alloc;\n\tint i;\n\tint err;\n\tint order;\n\tint non_pcm_mapping[8];\n\n\torder = get_channel_allocation_order(ca);\n\tch_alloc = &channel_allocations[order];\n\n\tif (hdmi_channel_mapping[ca][1] == 0) {\n\t\tint hdmi_slot = 0;\n\t\t \n\t\tfor (i = 0; i < ch_alloc->channels; i++) {\n\t\t\twhile (!WARN_ON(hdmi_slot >= 8) &&\n\t\t\t       !ch_alloc->speakers[7 - hdmi_slot])\n\t\t\t\thdmi_slot++;  \n\n\t\t\thdmi_channel_mapping[ca][i] = (i << 4) | hdmi_slot++;\n\t\t}\n\t\t \n\t\tfor (hdmi_slot = 0; hdmi_slot < 8; hdmi_slot++)\n\t\t\tif (!ch_alloc->speakers[7 - hdmi_slot])\n\t\t\t\thdmi_channel_mapping[ca][i++] = (0xf << 4) | hdmi_slot;\n\t}\n\n\tif (non_pcm) {\n\t\tfor (i = 0; i < ch_alloc->channels; i++)\n\t\t\tnon_pcm_mapping[i] = (i << 4) | i;\n\t\tfor (; i < 8; i++)\n\t\t\tnon_pcm_mapping[i] = (0xf << 4) | i;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tint slotsetup = non_pcm ? non_pcm_mapping[i] : hdmi_channel_mapping[ca][i];\n\t\tint hdmi_slot = slotsetup & 0x0f;\n\t\tint channel = (slotsetup & 0xf0) >> 4;\n\n\t\terr = chmap->ops.pin_set_slot_channel(chmap->hdac,\n\t\t\t\tpin_nid, hdmi_slot, channel);\n\t\tif (err) {\n\t\t\tdev_dbg(&chmap->hdac->dev, \"HDMI: channel mapping failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstruct channel_map_table {\n\tunsigned char map;\t\t \n\tint spk_mask;\t\t\t \n};\n\nstatic struct channel_map_table map_tables[] = {\n\t{ SNDRV_CHMAP_FL,\tFL },\n\t{ SNDRV_CHMAP_FR,\tFR },\n\t{ SNDRV_CHMAP_RL,\tRL },\n\t{ SNDRV_CHMAP_RR,\tRR },\n\t{ SNDRV_CHMAP_LFE,\tLFE },\n\t{ SNDRV_CHMAP_FC,\tFC },\n\t{ SNDRV_CHMAP_RLC,\tRLC },\n\t{ SNDRV_CHMAP_RRC,\tRRC },\n\t{ SNDRV_CHMAP_RC,\tRC },\n\t{ SNDRV_CHMAP_FLC,\tFLC },\n\t{ SNDRV_CHMAP_FRC,\tFRC },\n\t{ SNDRV_CHMAP_TFL,\tFLH },\n\t{ SNDRV_CHMAP_TFR,\tFRH },\n\t{ SNDRV_CHMAP_FLW,\tFLW },\n\t{ SNDRV_CHMAP_FRW,\tFRW },\n\t{ SNDRV_CHMAP_TC,\tTC },\n\t{ SNDRV_CHMAP_TFC,\tFCH },\n\t{}  \n};\n\n \nint snd_hdac_chmap_to_spk_mask(unsigned char c)\n{\n\tstruct channel_map_table *t = map_tables;\n\n\tfor (; t->map; t++) {\n\t\tif (t->map == c)\n\t\t\treturn t->spk_mask;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_chmap_to_spk_mask);\n\n \nstatic int to_cea_slot(int ordered_ca, unsigned char pos)\n{\n\tint mask = snd_hdac_chmap_to_spk_mask(pos);\n\tint i;\n\n\t \n\tif (ordered_ca >= ARRAY_SIZE(channel_allocations))\n\t\treturn -1;\n\n\tif (mask) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (channel_allocations[ordered_ca].speakers[7 - i] == mask)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n \nint snd_hdac_spk_to_chmap(int spk)\n{\n\tstruct channel_map_table *t = map_tables;\n\n\tfor (; t->map; t++) {\n\t\tif (t->spk_mask == spk)\n\t\t\treturn t->map;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_spk_to_chmap);\n\n \nstatic int from_cea_slot(int ordered_ca, unsigned char slot)\n{\n\tint mask;\n\n\t \n\tif (slot >= 8)\n\t\treturn 0;\n\n\tmask = channel_allocations[ordered_ca].speakers[7 - slot];\n\n\treturn snd_hdac_spk_to_chmap(mask);\n}\n\n \nstatic int hdmi_manual_channel_allocation(int chs, unsigned char *map)\n{\n\tint i, spks = 0, spk_mask = 0;\n\n\tfor (i = 0; i < chs; i++) {\n\t\tint mask = snd_hdac_chmap_to_spk_mask(map[i]);\n\n\t\tif (mask) {\n\t\t\tspk_mask |= mask;\n\t\t\tspks++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tif ((chs == channel_allocations[i].channels ||\n\t\t     spks == channel_allocations[i].channels) &&\n\t\t    (spk_mask & channel_allocations[i].spk_mask) ==\n\t\t\t\tchannel_allocations[i].spk_mask)\n\t\t\treturn channel_allocations[i].ca_index;\n\t}\n\treturn -1;\n}\n\n \nstatic int hdmi_manual_setup_channel_mapping(struct hdac_chmap *chmap,\n\t\t\t\t\t     hda_nid_t pin_nid,\n\t\t\t\t\t     int chs, unsigned char *map,\n\t\t\t\t\t     int ca)\n{\n\tint ordered_ca = get_channel_allocation_order(ca);\n\tint alsa_pos, hdmi_slot;\n\tint assignments[8] = {[0 ... 7] = 0xf};\n\n\tfor (alsa_pos = 0; alsa_pos < chs; alsa_pos++) {\n\n\t\thdmi_slot = to_cea_slot(ordered_ca, map[alsa_pos]);\n\n\t\tif (hdmi_slot < 0)\n\t\t\tcontinue;  \n\n\t\tassignments[hdmi_slot] = alsa_pos;\n\t}\n\n\tfor (hdmi_slot = 0; hdmi_slot < 8; hdmi_slot++) {\n\t\tint err;\n\n\t\terr = chmap->ops.pin_set_slot_channel(chmap->hdac,\n\t\t\t\tpin_nid, hdmi_slot, assignments[hdmi_slot]);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void hdmi_setup_fake_chmap(unsigned char *map, int ca)\n{\n\tint i;\n\tint ordered_ca = get_channel_allocation_order(ca);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (ordered_ca < ARRAY_SIZE(channel_allocations) &&\n\t\t    i < channel_allocations[ordered_ca].channels)\n\t\t\tmap[i] = from_cea_slot(ordered_ca, hdmi_channel_mapping[ca][i] & 0x0f);\n\t\telse\n\t\t\tmap[i] = 0;\n\t}\n}\n\nvoid snd_hdac_setup_channel_mapping(struct hdac_chmap *chmap,\n\t\t\t\t       hda_nid_t pin_nid, bool non_pcm, int ca,\n\t\t\t\t       int channels, unsigned char *map,\n\t\t\t\t       bool chmap_set)\n{\n\tif (!non_pcm && chmap_set) {\n\t\thdmi_manual_setup_channel_mapping(chmap, pin_nid,\n\t\t\t\t\t\t  channels, map, ca);\n\t} else {\n\t\thdmi_std_setup_channel_mapping(chmap, pin_nid, non_pcm, ca);\n\t\thdmi_setup_fake_chmap(map, ca);\n\t}\n\n\thdmi_debug_channel_mapping(chmap, pin_nid);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_setup_channel_mapping);\n\nint snd_hdac_get_active_channels(int ca)\n{\n\tint ordered_ca = get_channel_allocation_order(ca);\n\n\t \n\tif (ordered_ca >= ARRAY_SIZE(channel_allocations))\n\t\tordered_ca = 0;\n\n\treturn channel_allocations[ordered_ca].channels;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_active_channels);\n\nstruct hdac_cea_channel_speaker_allocation *snd_hdac_get_ch_alloc_from_ca(int ca)\n{\n\treturn &channel_allocations[get_channel_allocation_order(ca)];\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_ch_alloc_from_ca);\n\nint snd_hdac_channel_allocation(struct hdac_device *hdac, int spk_alloc,\n\t\tint channels, bool chmap_set, bool non_pcm, unsigned char *map)\n{\n\tint ca;\n\n\tif (!non_pcm && chmap_set)\n\t\tca = hdmi_manual_channel_allocation(channels, map);\n\telse\n\t\tca = hdmi_channel_allocation_spk_alloc_blk(hdac,\n\t\t\t\t\tspk_alloc, channels);\n\n\tif (ca < 0)\n\t\tca = 0;\n\n\treturn ca;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_channel_allocation);\n\n \nstatic int hdmi_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_chmap *chmap = info->private_data;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chmap->channels_max;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\nstatic int hdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,\n\t\tstruct hdac_cea_channel_speaker_allocation *cap, int channels)\n{\n\t \n\tif (cap->channels != channels)\n\t\treturn -1;\n\n\t \n\treturn SNDRV_CTL_TLVT_CHMAP_VAR;\n}\n\nstatic void hdmi_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,\n\t\tstruct hdac_cea_channel_speaker_allocation *cap,\n\t\tunsigned int *chmap, int channels)\n{\n\tint count = 0;\n\tint c;\n\n\tfor (c = 7; c >= 0; c--) {\n\t\tint spk = cap->speakers[c];\n\n\t\tif (!spk)\n\t\t\tcontinue;\n\n\t\tchmap[count++] = snd_hdac_spk_to_chmap(spk);\n\t}\n\n\tWARN_ON(count != channels);\n}\n\nstatic int spk_mask_from_spk_alloc(int spk_alloc)\n{\n\tint i;\n\tint spk_mask = eld_speaker_allocation_bits[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\n\t\tif (spk_alloc & (1 << i))\n\t\t\tspk_mask |= eld_speaker_allocation_bits[i];\n\t}\n\n\treturn spk_mask;\n}\n\nstatic int hdmi_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t      unsigned int size, unsigned int __user *tlv)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_chmap *chmap = info->private_data;\n\tint pcm_idx = kcontrol->private_value;\n\tunsigned int __user *dst;\n\tint chs, count = 0;\n\tunsigned long max_chs;\n\tint type;\n\tint spk_alloc, spk_mask;\n\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\n\tspk_alloc = chmap->ops.get_spk_alloc(chmap->hdac, pcm_idx);\n\tspk_mask = spk_mask_from_spk_alloc(spk_alloc);\n\n\tmax_chs = hweight_long(spk_mask);\n\n\tfor (chs = 2; chs <= max_chs; chs++) {\n\t\tint i;\n\t\tstruct hdac_cea_channel_speaker_allocation *cap;\n\n\t\tcap = channel_allocations;\n\t\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++, cap++) {\n\t\t\tint chs_bytes = chs * 4;\n\t\t\tunsigned int tlv_chmap[8];\n\n\t\t\tif (cap->channels != chs)\n\t\t\t\tcontinue;\n\n\t\t\tif (!(cap->spk_mask == (spk_mask & cap->spk_mask)))\n\t\t\t\tcontinue;\n\n\t\t\ttype = chmap->ops.chmap_cea_alloc_validate_get_type(\n\t\t\t\t\t\t\tchmap, cap, chs);\n\t\t\tif (type < 0)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (size < 8)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (put_user(type, dst) ||\n\t\t\t    put_user(chs_bytes, dst + 1))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdst += 2;\n\t\t\tsize -= 8;\n\t\t\tcount += 8;\n\n\t\t\tif (size < chs_bytes)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsize -= chs_bytes;\n\t\t\tcount += chs_bytes;\n\t\t\tchmap->ops.cea_alloc_to_tlv_chmap(chmap, cap,\n\t\t\t\t\t\ttlv_chmap, chs);\n\n\t\t\tif (copy_to_user(dst, tlv_chmap, chs_bytes))\n\t\t\t\treturn -EFAULT;\n\t\t\tdst += chs;\n\t\t}\n\t}\n\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int hdmi_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_chmap *chmap = info->private_data;\n\tint pcm_idx = kcontrol->private_value;\n\tunsigned char pcm_chmap[8];\n\tint i;\n\n\tmemset(pcm_chmap, 0, sizeof(pcm_chmap));\n\tchmap->ops.get_chmap(chmap->hdac, pcm_idx, pcm_chmap);\n\n\tfor (i = 0; i < ARRAY_SIZE(pcm_chmap); i++)\n\t\tucontrol->value.integer.value[i] = pcm_chmap[i];\n\n\treturn 0;\n}\n\nstatic int hdmi_chmap_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_chmap *hchmap = info->private_data;\n\tint pcm_idx = kcontrol->private_value;\n\tunsigned int ctl_idx;\n\tstruct snd_pcm_substream *substream;\n\tunsigned char chmap[8], per_pin_chmap[8];\n\tint i, err, ca, prepared = 0;\n\n\t \n\tif (!hchmap->ops.is_pcm_attached(hchmap->hdac, pcm_idx))\n\t\treturn 0;\n\n\tctl_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tsubstream = snd_pcm_chmap_substream(info, ctl_idx);\n\tif (!substream || !substream->runtime)\n\t\treturn 0;  \n\tswitch (substream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_SETUP:\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tprepared = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\tmemset(chmap, 0, sizeof(chmap));\n\tfor (i = 0; i < ARRAY_SIZE(chmap); i++)\n\t\tchmap[i] = ucontrol->value.integer.value[i];\n\n\thchmap->ops.get_chmap(hchmap->hdac, pcm_idx, per_pin_chmap);\n\tif (!memcmp(chmap, per_pin_chmap, sizeof(chmap)))\n\t\treturn 0;\n\tca = hdmi_manual_channel_allocation(ARRAY_SIZE(chmap), chmap);\n\tif (ca < 0)\n\t\treturn -EINVAL;\n\tif (hchmap->ops.chmap_validate) {\n\t\terr = hchmap->ops.chmap_validate(hchmap, ca,\n\t\t\t\tARRAY_SIZE(chmap), chmap);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thchmap->ops.set_chmap(hchmap->hdac, pcm_idx, chmap, prepared);\n\n\treturn 0;\n}\n\nstatic const struct hdac_chmap_ops chmap_ops = {\n\t.chmap_cea_alloc_validate_get_type\t= hdmi_chmap_cea_alloc_validate_get_type,\n\t.cea_alloc_to_tlv_chmap\t\t\t= hdmi_cea_alloc_to_tlv_chmap,\n\t.pin_get_slot_channel\t\t\t= hdmi_pin_get_slot_channel,\n\t.pin_set_slot_channel\t\t\t= hdmi_pin_set_slot_channel,\n\t.set_channel_count\t\t\t= hdmi_set_channel_count,\n};\n\nvoid snd_hdac_register_chmap_ops(struct hdac_device *hdac,\n\t\t\t\tstruct hdac_chmap *chmap)\n{\n\tchmap->ops = chmap_ops;\n\tchmap->hdac = hdac;\n\tinit_channel_allocations();\n}\nEXPORT_SYMBOL_GPL(snd_hdac_register_chmap_ops);\n\nint snd_hdac_add_chmap_ctls(struct snd_pcm *pcm, int pcm_idx,\n\t\t\t\tstruct hdac_chmap *hchmap)\n{\n\tstruct snd_pcm_chmap *chmap;\n\tstruct snd_kcontrol *kctl;\n\tint err, i;\n\n\terr = snd_pcm_add_chmap_ctls(pcm,\n\t\t\t\t     SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     NULL, 0, pcm_idx, &chmap);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tchmap->private_data = hchmap;\n\tkctl = chmap->kctl;\n\tfor (i = 0; i < kctl->count; i++)\n\t\tkctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;\n\tkctl->info = hdmi_chmap_ctl_info;\n\tkctl->get = hdmi_chmap_ctl_get;\n\tkctl->put = hdmi_chmap_ctl_put;\n\tkctl->tlv.c = hdmi_chmap_ctl_tlv;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_add_chmap_ctls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}