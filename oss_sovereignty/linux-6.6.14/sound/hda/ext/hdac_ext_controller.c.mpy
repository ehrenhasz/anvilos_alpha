{
  "module_name": "hdac_ext_controller.c",
  "hash_id": "52f825d4e28531084dd34f213d88459e3abb3a8f32af39744e3f115520adcf73",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/ext/hdac_ext_controller.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <sound/hda_register.h>\n#include <sound/hdaudio_ext.h>\n\n \n\n \nvoid snd_hdac_ext_bus_ppcap_enable(struct hdac_bus *bus, bool enable)\n{\n\n\tif (!bus->ppcap) {\n\t\tdev_err(bus->dev, \"Address of PP capability is NULL\");\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tsnd_hdac_updatel(bus->ppcap, AZX_REG_PP_PPCTL,\n\t\t\t\t AZX_PPCTL_GPROCEN, AZX_PPCTL_GPROCEN);\n\telse\n\t\tsnd_hdac_updatel(bus->ppcap, AZX_REG_PP_PPCTL,\n\t\t\t\t AZX_PPCTL_GPROCEN, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_ppcap_enable);\n\n \nvoid snd_hdac_ext_bus_ppcap_int_enable(struct hdac_bus *bus, bool enable)\n{\n\n\tif (!bus->ppcap) {\n\t\tdev_err(bus->dev, \"Address of PP capability is NULL\\n\");\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tsnd_hdac_updatel(bus->ppcap, AZX_REG_PP_PPCTL,\n\t\t\t\t AZX_PPCTL_PIE, AZX_PPCTL_PIE);\n\telse\n\t\tsnd_hdac_updatel(bus->ppcap, AZX_REG_PP_PPCTL,\n\t\t\t\t AZX_PPCTL_PIE, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_ppcap_int_enable);\n\n \n\n \nint snd_hdac_ext_bus_get_ml_capabilities(struct hdac_bus *bus)\n{\n\tint idx;\n\tu32 link_count;\n\tstruct hdac_ext_link *hlink;\n\n\tlink_count = readl(bus->mlcap + AZX_REG_ML_MLCD) + 1;\n\n\tdev_dbg(bus->dev, \"In %s Link count: %d\\n\", __func__, link_count);\n\n\tfor (idx = 0; idx < link_count; idx++) {\n\t\thlink  = kzalloc(sizeof(*hlink), GFP_KERNEL);\n\t\tif (!hlink)\n\t\t\treturn -ENOMEM;\n\t\thlink->index = idx;\n\t\thlink->bus = bus;\n\t\thlink->ml_addr = bus->mlcap + AZX_ML_BASE +\n\t\t\t\t\t(AZX_ML_INTERVAL * idx);\n\t\thlink->lcaps  = readl(hlink->ml_addr + AZX_REG_ML_LCAP);\n\t\thlink->lsdiid = readw(hlink->ml_addr + AZX_REG_ML_LSDIID);\n\n\t\t \n\t\thlink->ref_count = 1;\n\n\t\tlist_add_tail(&hlink->list, &bus->hlink_list);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_get_ml_capabilities);\n\n \n\nvoid snd_hdac_ext_link_free_all(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink;\n\n\twhile (!list_empty(&bus->hlink_list)) {\n\t\thlink = list_first_entry(&bus->hlink_list, struct hdac_ext_link, list);\n\t\tlist_del(&hlink->list);\n\t\tkfree(hlink);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_link_free_all);\n\n \nstruct hdac_ext_link *snd_hdac_ext_bus_get_hlink_by_addr(struct hdac_bus *bus, int addr)\n{\n\tstruct hdac_ext_link *hlink;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\tif (hlink->lsdiid & (0x1 << addr))\n\t\t\treturn hlink;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_get_hlink_by_addr);\n\n \nstruct hdac_ext_link *snd_hdac_ext_bus_get_hlink_by_name(struct hdac_bus *bus,\n\t\t\t\t\t\t\t const char *codec_name)\n{\n\tint bus_idx, addr;\n\n\tif (sscanf(codec_name, \"ehdaudio%dD%d\", &bus_idx, &addr) != 2)\n\t\treturn NULL;\n\tif (bus->idx != bus_idx)\n\t\treturn NULL;\n\tif (addr < 0 || addr > 31)\n\t\treturn NULL;\n\n\treturn snd_hdac_ext_bus_get_hlink_by_addr(bus, addr);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_get_hlink_by_name);\n\nstatic int check_hdac_link_power_active(struct hdac_ext_link *hlink, bool enable)\n{\n\tint timeout;\n\tu32 val;\n\tint mask = (1 << AZX_ML_LCTL_CPA_SHIFT);\n\n\tudelay(3);\n\ttimeout = 150;\n\n\tdo {\n\t\tval = readl(hlink->ml_addr + AZX_REG_ML_LCTL);\n\t\tif (enable) {\n\t\t\tif (((val & mask) >> AZX_ML_LCTL_CPA_SHIFT))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!((val & mask) >> AZX_ML_LCTL_CPA_SHIFT))\n\t\t\t\treturn 0;\n\t\t}\n\t\tudelay(3);\n\t} while (--timeout);\n\n\treturn -EIO;\n}\n\n \nint snd_hdac_ext_bus_link_power_up(struct hdac_ext_link *hlink)\n{\n\tsnd_hdac_updatel(hlink->ml_addr, AZX_REG_ML_LCTL,\n\t\t\t AZX_ML_LCTL_SPA, AZX_ML_LCTL_SPA);\n\n\treturn check_hdac_link_power_active(hlink, true);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_power_up);\n\n \nint snd_hdac_ext_bus_link_power_down(struct hdac_ext_link *hlink)\n{\n\tsnd_hdac_updatel(hlink->ml_addr, AZX_REG_ML_LCTL, AZX_ML_LCTL_SPA, 0);\n\n\treturn check_hdac_link_power_active(hlink, false);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_power_down);\n\n \nint snd_hdac_ext_bus_link_power_up_all(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink = NULL;\n\tint ret;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tret = snd_hdac_ext_bus_link_power_up(hlink);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_power_up_all);\n\n \nint snd_hdac_ext_bus_link_power_down_all(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink = NULL;\n\tint ret;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tret = snd_hdac_ext_bus_link_power_down(hlink);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_power_down_all);\n\n \nvoid snd_hdac_ext_bus_link_set_stream_id(struct hdac_ext_link *link,\n\t\t\t\t\t int stream)\n{\n\tsnd_hdac_updatew(link->ml_addr, AZX_REG_ML_LOSIDV, (1 << stream), 1 << stream);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_set_stream_id);\n\n \nvoid snd_hdac_ext_bus_link_clear_stream_id(struct hdac_ext_link *link,\n\t\t\t\t\t   int stream)\n{\n\tsnd_hdac_updatew(link->ml_addr, AZX_REG_ML_LOSIDV, (1 << stream), 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_clear_stream_id);\n\nint snd_hdac_ext_bus_link_get(struct hdac_bus *bus,\n\t\t\t\tstruct hdac_ext_link *hlink)\n{\n\tunsigned long codec_mask;\n\tint ret = 0;\n\n\tmutex_lock(&bus->lock);\n\n\t \n\tif (++hlink->ref_count == 1) {\n\t\tif (!bus->cmd_dma_state) {\n\t\t\tsnd_hdac_bus_init_cmd_io(bus);\n\t\t\tbus->cmd_dma_state = true;\n\t\t}\n\n\t\tret = snd_hdac_ext_bus_link_power_up(hlink);\n\n\t\t \n\t\tsnd_hdac_updatew(hlink->ml_addr, AZX_REG_ML_LOSIDV,\n\t\t\t\t AZX_ML_LOSIDV_STREAM_MASK, 0);\n\t\t \n\t\tudelay(521);\n\t\tcodec_mask = snd_hdac_chip_readw(bus, STATESTS);\n\t\tdev_dbg(bus->dev, \"codec_mask = 0x%lx\\n\", codec_mask);\n\t\tsnd_hdac_chip_writew(bus, STATESTS, codec_mask);\n\t\tif (!bus->codec_mask)\n\t\t\tbus->codec_mask = codec_mask;\n\t}\n\n\tmutex_unlock(&bus->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_get);\n\nint snd_hdac_ext_bus_link_put(struct hdac_bus *bus,\n\t\t\t      struct hdac_ext_link *hlink)\n{\n\tint ret = 0;\n\tstruct hdac_ext_link *hlink_tmp;\n\tbool link_up = false;\n\n\tmutex_lock(&bus->lock);\n\n\t \n\tif (--hlink->ref_count == 0) {\n\t\tret = snd_hdac_ext_bus_link_power_down(hlink);\n\n\t\t \n\t\tlist_for_each_entry(hlink_tmp, &bus->hlink_list, list) {\n\t\t\tif (hlink_tmp->ref_count) {\n\t\t\t\tlink_up = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!link_up) {\n\t\t\tsnd_hdac_bus_stop_cmd_io(bus);\n\t\t\tbus->cmd_dma_state = false;\n\t\t}\n\t}\n\n\tmutex_unlock(&bus->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_put);\n\nstatic void hdac_ext_codec_link_up(struct hdac_device *codec)\n{\n\tconst char *devname = dev_name(&codec->dev);\n\tstruct hdac_ext_link *hlink =\n\t\tsnd_hdac_ext_bus_get_hlink_by_name(codec->bus, devname);\n\n\tif (hlink)\n\t\tsnd_hdac_ext_bus_link_get(codec->bus, hlink);\n}\n\nstatic void hdac_ext_codec_link_down(struct hdac_device *codec)\n{\n\tconst char *devname = dev_name(&codec->dev);\n\tstruct hdac_ext_link *hlink =\n\t\tsnd_hdac_ext_bus_get_hlink_by_name(codec->bus, devname);\n\n\tif (hlink)\n\t\tsnd_hdac_ext_bus_link_put(codec->bus, hlink);\n}\n\nvoid snd_hdac_ext_bus_link_power(struct hdac_device *codec, bool enable)\n{\n\tstruct hdac_bus *bus = codec->bus;\n\tbool oldstate = test_bit(codec->addr, &bus->codec_powered);\n\n\tif (enable == oldstate)\n\t\treturn;\n\n\tsnd_hdac_bus_link_power(codec, enable);\n\n\tif (enable)\n\t\thdac_ext_codec_link_up(codec);\n\telse\n\t\thdac_ext_codec_link_down(codec);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_ext_bus_link_power);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}