{
  "module_name": "hdac_stream.c",
  "hash_id": "2176de838cdabb301cca9daaf9fbffea9cbc5208d9fd47d998110d2ac1df169b",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_stream.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/clocksource.h>\n#include <sound/compress_driver.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_register.h>\n#include \"trace.h\"\n\n \n\n \nint snd_hdac_get_stream_stripe_ctl(struct hdac_bus *bus,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int channels = runtime->channels,\n\t\t     rate = runtime->rate,\n\t\t     bits_per_sample = runtime->sample_bits,\n\t\t     max_sdo_lines, value, sdo_line;\n\n\t \n\tmax_sdo_lines = snd_hdac_chip_readl(bus, GCAP) & AZX_GCAP_NSDO;\n\n\t \n\tfor (sdo_line = max_sdo_lines; sdo_line > 0; sdo_line >>= 1) {\n\t\tif (rate > 48000)\n\t\t\tvalue = (channels * bits_per_sample *\n\t\t\t\t\t(rate / 48000)) / sdo_line;\n\t\telse\n\t\t\tvalue = (channels * bits_per_sample) / sdo_line;\n\n\t\tif (value >= bus->sdo_limit)\n\t\t\tbreak;\n\t}\n\n\t \n\treturn sdo_line >> 1;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_stream_stripe_ctl);\n\n \nvoid snd_hdac_stream_init(struct hdac_bus *bus, struct hdac_stream *azx_dev,\n\t\t\t  int idx, int direction, int tag)\n{\n\tazx_dev->bus = bus;\n\t \n\tazx_dev->sd_addr = bus->remap_addr + (0x20 * idx + 0x80);\n\t \n\tazx_dev->sd_int_sta_mask = 1 << idx;\n\tazx_dev->index = idx;\n\tazx_dev->direction = direction;\n\tazx_dev->stream_tag = tag;\n\tsnd_hdac_dsp_lock_init(azx_dev);\n\tlist_add_tail(&azx_dev->list, &bus->stream_list);\n\n\tif (bus->spbcap) {\n\t\tazx_dev->spib_addr = bus->spbcap + AZX_SPB_BASE +\n\t\t\t\t\tAZX_SPB_INTERVAL * idx +\n\t\t\t\t\tAZX_SPB_SPIB;\n\n\t\tazx_dev->fifo_addr = bus->spbcap + AZX_SPB_BASE +\n\t\t\t\t\tAZX_SPB_INTERVAL * idx +\n\t\t\t\t\tAZX_SPB_MAXFIFO;\n\t}\n\n\tif (bus->drsmcap)\n\t\tazx_dev->dpibr_addr = bus->drsmcap + AZX_DRSM_BASE +\n\t\t\t\t\tAZX_DRSM_INTERVAL * idx;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_init);\n\n \nvoid snd_hdac_stream_start(struct hdac_stream *azx_dev)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tint stripe_ctl;\n\n\ttrace_snd_hdac_stream_start(bus, azx_dev);\n\n\tazx_dev->start_wallclk = snd_hdac_chip_readl(bus, WALLCLK);\n\n\t \n\tsnd_hdac_chip_updatel(bus, INTCTL,\n\t\t\t      1 << azx_dev->index,\n\t\t\t      1 << azx_dev->index);\n\t \n\tif (azx_dev->stripe) {\n\t\tif (azx_dev->substream)\n\t\t\tstripe_ctl = snd_hdac_get_stream_stripe_ctl(bus, azx_dev->substream);\n\t\telse\n\t\t\tstripe_ctl = 0;\n\t\tsnd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,\n\t\t\t\t\tstripe_ctl);\n\t}\n\t \n\tif (bus->access_sdnctl_in_dword)\n\t\tsnd_hdac_stream_updatel(azx_dev, SD_CTL,\n\t\t\t\t0, SD_CTL_DMA_START | SD_INT_MASK);\n\telse\n\t\tsnd_hdac_stream_updateb(azx_dev, SD_CTL,\n\t\t\t\t0, SD_CTL_DMA_START | SD_INT_MASK);\n\tazx_dev->running = true;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_start);\n\n \nstatic void snd_hdac_stream_clear(struct hdac_stream *azx_dev)\n{\n\tsnd_hdac_stream_updateb(azx_dev, SD_CTL,\n\t\t\t\tSD_CTL_DMA_START | SD_INT_MASK, 0);\n\tsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);  \n\tif (azx_dev->stripe)\n\t\tsnd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);\n\tazx_dev->running = false;\n}\n\n \nvoid snd_hdac_stream_stop(struct hdac_stream *azx_dev)\n{\n\ttrace_snd_hdac_stream_stop(azx_dev->bus, azx_dev);\n\n\tsnd_hdac_stream_clear(azx_dev);\n\t \n\tsnd_hdac_chip_updatel(azx_dev->bus, INTCTL, 1 << azx_dev->index, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_stop);\n\n \nvoid snd_hdac_stop_streams(struct hdac_bus *bus)\n{\n\tstruct hdac_stream *stream;\n\n\tlist_for_each_entry(stream, &bus->stream_list, list)\n\t\tsnd_hdac_stream_stop(stream);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stop_streams);\n\n \nvoid snd_hdac_stop_streams_and_chip(struct hdac_bus *bus)\n{\n\n\tif (bus->chip_init) {\n\t\tsnd_hdac_stop_streams(bus);\n\t\tsnd_hdac_bus_stop_chip(bus);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stop_streams_and_chip);\n\n \nvoid snd_hdac_stream_reset(struct hdac_stream *azx_dev)\n{\n\tunsigned char val;\n\tint dma_run_state;\n\n\tsnd_hdac_stream_clear(azx_dev);\n\n\tdma_run_state = snd_hdac_stream_readb(azx_dev, SD_CTL) & SD_CTL_DMA_START;\n\n\tsnd_hdac_stream_updateb(azx_dev, SD_CTL, 0, SD_CTL_STREAM_RESET);\n\n\t \n\tsnd_hdac_stream_readb_poll(azx_dev, SD_CTL, val, (val & SD_CTL_STREAM_RESET), 3, 300);\n\n\tif (azx_dev->bus->dma_stop_delay && dma_run_state)\n\t\tudelay(azx_dev->bus->dma_stop_delay);\n\n\tsnd_hdac_stream_updateb(azx_dev, SD_CTL, SD_CTL_STREAM_RESET, 0);\n\n\t \n\tsnd_hdac_stream_readb_poll(azx_dev, SD_CTL, val, !(val & SD_CTL_STREAM_RESET), 3, 300);\n\n\t \n\tif (azx_dev->posbuf)\n\t\t*azx_dev->posbuf = 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_reset);\n\n \nint snd_hdac_stream_setup(struct hdac_stream *azx_dev)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned int val;\n\n\tif (azx_dev->substream)\n\t\truntime = azx_dev->substream->runtime;\n\telse\n\t\truntime = NULL;\n\t \n\tsnd_hdac_stream_clear(azx_dev);\n\t \n\tval = snd_hdac_stream_readl(azx_dev, SD_CTL);\n\tval = (val & ~SD_CTL_STREAM_TAG_MASK) |\n\t\t(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);\n\tif (!bus->snoop)\n\t\tval |= SD_CTL_TRAFFIC_PRIO;\n\tsnd_hdac_stream_writel(azx_dev, SD_CTL, val);\n\n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);\n\n\t \n\t \n\tsnd_hdac_stream_writew(azx_dev, SD_FORMAT, azx_dev->format_val);\n\n\t \n\tsnd_hdac_stream_writew(azx_dev, SD_LVI, azx_dev->frags - 1);\n\n\t \n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);\n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPU,\n\t\t\t       upper_32_bits(azx_dev->bdl.addr));\n\n\t \n\tif (bus->use_posbuf && bus->posbuf.addr) {\n\t\tif (!(snd_hdac_chip_readl(bus, DPLBASE) & AZX_DPLBASE_ENABLE))\n\t\t\tsnd_hdac_chip_writel(bus, DPLBASE,\n\t\t\t\t(u32)bus->posbuf.addr | AZX_DPLBASE_ENABLE);\n\t}\n\n\t \n\tsnd_hdac_stream_updatel(azx_dev, SD_CTL, 0, SD_INT_MASK);\n\n\tazx_dev->fifo_size = snd_hdac_stream_readw(azx_dev, SD_FIFOSIZE) + 1;\n\n\t \n\tif (runtime && runtime->period_size > 64)\n\t\tazx_dev->delay_negative_threshold =\n\t\t\t-frames_to_bytes(runtime, 64);\n\telse\n\t\tazx_dev->delay_negative_threshold = 0;\n\n\t \n\tif (runtime)\n\t\tazx_dev->period_wallclk = (((runtime->period_size * 24000) /\n\t\t\t\t    runtime->rate) * 1000);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_setup);\n\n \nvoid snd_hdac_stream_cleanup(struct hdac_stream *azx_dev)\n{\n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_CTL, 0);\n\tazx_dev->bufsize = 0;\n\tazx_dev->period_bytes = 0;\n\tazx_dev->format_val = 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_cleanup);\n\n \nstruct hdac_stream *snd_hdac_stream_assign(struct hdac_bus *bus,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct hdac_stream *azx_dev;\n\tstruct hdac_stream *res = NULL;\n\n\t \n\tint key = (substream->number << 2) | (substream->stream + 1);\n\n\tif (substream->pcm)\n\t\tkey |= (substream->pcm->device << 16);\n\n\tspin_lock_irq(&bus->reg_lock);\n\tlist_for_each_entry(azx_dev, &bus->stream_list, list) {\n\t\tif (azx_dev->direction != substream->stream)\n\t\t\tcontinue;\n\t\tif (azx_dev->opened)\n\t\t\tcontinue;\n\t\tif (azx_dev->assigned_key == key) {\n\t\t\tres = azx_dev;\n\t\t\tbreak;\n\t\t}\n\t\tif (!res || bus->reverse_assign)\n\t\t\tres = azx_dev;\n\t}\n\tif (res) {\n\t\tres->opened = 1;\n\t\tres->running = 0;\n\t\tres->assigned_key = key;\n\t\tres->substream = substream;\n\t}\n\tspin_unlock_irq(&bus->reg_lock);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_assign);\n\n \nvoid snd_hdac_stream_release_locked(struct hdac_stream *azx_dev)\n{\n\tazx_dev->opened = 0;\n\tazx_dev->running = 0;\n\tazx_dev->substream = NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_release_locked);\n\n \nvoid snd_hdac_stream_release(struct hdac_stream *azx_dev)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\n\tspin_lock_irq(&bus->reg_lock);\n\tsnd_hdac_stream_release_locked(azx_dev);\n\tspin_unlock_irq(&bus->reg_lock);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_release);\n\n \nstruct hdac_stream *snd_hdac_get_stream(struct hdac_bus *bus,\n\t\t\t\t\tint dir, int stream_tag)\n{\n\tstruct hdac_stream *s;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tif (s->direction == dir && s->stream_tag == stream_tag)\n\t\t\treturn s;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_get_stream);\n\n \nstatic int setup_bdle(struct hdac_bus *bus,\n\t\t      struct snd_dma_buffer *dmab,\n\t\t      struct hdac_stream *azx_dev, __le32 **bdlp,\n\t\t      int ofs, int size, int with_ioc)\n{\n\t__le32 *bdl = *bdlp;\n\n\twhile (size > 0) {\n\t\tdma_addr_t addr;\n\t\tint chunk;\n\n\t\tif (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)\n\t\t\treturn -EINVAL;\n\n\t\taddr = snd_sgbuf_get_addr(dmab, ofs);\n\t\t \n\t\tbdl[0] = cpu_to_le32((u32)addr);\n\t\tbdl[1] = cpu_to_le32(upper_32_bits(addr));\n\t\t \n\t\tchunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);\n\t\t \n\t\tif (bus->align_bdle_4k) {\n\t\t\tu32 remain = 0x1000 - (ofs & 0xfff);\n\n\t\t\tif (chunk > remain)\n\t\t\t\tchunk = remain;\n\t\t}\n\t\tbdl[2] = cpu_to_le32(chunk);\n\t\t \n\t\tsize -= chunk;\n\t\tbdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);\n\t\tbdl += 4;\n\t\tazx_dev->frags++;\n\t\tofs += chunk;\n\t}\n\t*bdlp = bdl;\n\treturn ofs;\n}\n\n \nint snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tstruct snd_pcm_substream *substream = azx_dev->substream;\n\tstruct snd_compr_stream *cstream = azx_dev->cstream;\n\tstruct snd_pcm_runtime *runtime = NULL;\n\tstruct snd_dma_buffer *dmab;\n\t__le32 *bdl;\n\tint i, ofs, periods, period_bytes;\n\tint pos_adj, pos_align;\n\n\tif (substream) {\n\t\truntime = substream->runtime;\n\t\tdmab = snd_pcm_get_dma_buf(substream);\n\t} else if (cstream) {\n\t\tdmab = snd_pcm_get_dma_buf(cstream);\n\t} else {\n\t\tWARN(1, \"No substream or cstream assigned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\n\n\tperiod_bytes = azx_dev->period_bytes;\n\tperiods = azx_dev->bufsize / period_bytes;\n\n\t \n\tbdl = (__le32 *)azx_dev->bdl.area;\n\tofs = 0;\n\tazx_dev->frags = 0;\n\n\tpos_adj = bus->bdl_pos_adj;\n\tif (runtime && !azx_dev->no_period_wakeup && pos_adj > 0) {\n\t\tpos_align = pos_adj;\n\t\tpos_adj = DIV_ROUND_UP(pos_adj * runtime->rate, 48000);\n\t\tif (!pos_adj)\n\t\t\tpos_adj = pos_align;\n\t\telse\n\t\t\tpos_adj = roundup(pos_adj, pos_align);\n\t\tpos_adj = frames_to_bytes(runtime, pos_adj);\n\t\tif (pos_adj >= period_bytes) {\n\t\t\tdev_warn(bus->dev, \"Too big adjustment %d\\n\",\n\t\t\t\t pos_adj);\n\t\t\tpos_adj = 0;\n\t\t} else {\n\t\t\tofs = setup_bdle(bus, dmab, azx_dev,\n\t\t\t\t\t &bdl, ofs, pos_adj, true);\n\t\t\tif (ofs < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else\n\t\tpos_adj = 0;\n\n\tfor (i = 0; i < periods; i++) {\n\t\tif (i == periods - 1 && pos_adj)\n\t\t\tofs = setup_bdle(bus, dmab, azx_dev,\n\t\t\t\t\t &bdl, ofs, period_bytes - pos_adj, 0);\n\t\telse\n\t\t\tofs = setup_bdle(bus, dmab, azx_dev,\n\t\t\t\t\t &bdl, ofs, period_bytes,\n\t\t\t\t\t !azx_dev->no_period_wakeup);\n\t\tif (ofs < 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\n error:\n\tdev_err(bus->dev, \"Too many BDL entries: buffer=%d, period=%d\\n\",\n\t\tazx_dev->bufsize, period_bytes);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_setup_periods);\n\n \nint snd_hdac_stream_set_params(struct hdac_stream *azx_dev,\n\t\t\t\t unsigned int format_val)\n{\n\tstruct snd_pcm_substream *substream = azx_dev->substream;\n\tstruct snd_compr_stream *cstream = azx_dev->cstream;\n\tunsigned int bufsize, period_bytes;\n\tunsigned int no_period_wakeup;\n\tint err;\n\n\tif (substream) {\n\t\tbufsize = snd_pcm_lib_buffer_bytes(substream);\n\t\tperiod_bytes = snd_pcm_lib_period_bytes(substream);\n\t\tno_period_wakeup = substream->runtime->no_period_wakeup;\n\t} else if (cstream) {\n\t\tbufsize = cstream->runtime->buffer_size;\n\t\tperiod_bytes = cstream->runtime->fragment_size;\n\t\tno_period_wakeup = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bufsize != azx_dev->bufsize ||\n\t    period_bytes != azx_dev->period_bytes ||\n\t    format_val != azx_dev->format_val ||\n\t    no_period_wakeup != azx_dev->no_period_wakeup) {\n\t\tazx_dev->bufsize = bufsize;\n\t\tazx_dev->period_bytes = period_bytes;\n\t\tazx_dev->format_val = format_val;\n\t\tazx_dev->no_period_wakeup = no_period_wakeup;\n\t\terr = snd_hdac_stream_setup_periods(azx_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_set_params);\n\nstatic u64 azx_cc_read(const struct cyclecounter *cc)\n{\n\tstruct hdac_stream *azx_dev = container_of(cc, struct hdac_stream, cc);\n\n\treturn snd_hdac_chip_readl(azx_dev->bus, WALLCLK);\n}\n\nstatic void azx_timecounter_init(struct hdac_stream *azx_dev,\n\t\t\t\t bool force, u64 last)\n{\n\tstruct timecounter *tc = &azx_dev->tc;\n\tstruct cyclecounter *cc = &azx_dev->cc;\n\tu64 nsec;\n\n\tcc->read = azx_cc_read;\n\tcc->mask = CLOCKSOURCE_MASK(32);\n\n\t \n\tclocks_calc_mult_shift(&cc->mult, &cc->shift, 24000000,\n\t\t\t       NSEC_PER_SEC, 178);\n\n\tnsec = 0;  \n\ttimecounter_init(tc, cc, nsec);\n\tif (force) {\n\t\t \n\t\ttc->cycle_last = last;\n\t}\n}\n\n \nvoid snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,\n\t\t\t\t      unsigned int streams)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tstruct snd_pcm_runtime *runtime = azx_dev->substream->runtime;\n\tstruct hdac_stream *s;\n\tbool inited = false;\n\tu64 cycle_last = 0;\n\tint i = 0;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tif (streams & (1 << i)) {\n\t\t\tazx_timecounter_init(s, inited, cycle_last);\n\t\t\tif (!inited) {\n\t\t\t\tinited = true;\n\t\t\t\tcycle_last = s->tc.cycle_last;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tsnd_pcm_gettime(runtime, &runtime->trigger_tstamp);\n\truntime->trigger_tstamp_latched = true;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_timecounter_init);\n\n \nvoid snd_hdac_stream_sync_trigger(struct hdac_stream *azx_dev, bool set,\n\t\t\t\t  unsigned int streams, unsigned int reg)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tunsigned int val;\n\n\tif (!reg)\n\t\treg = AZX_REG_SSYNC;\n\tval = _snd_hdac_chip_readl(bus, reg);\n\tif (set)\n\t\tval |= streams;\n\telse\n\t\tval &= ~streams;\n\t_snd_hdac_chip_writel(bus, reg, val);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_sync_trigger);\n\n \nvoid snd_hdac_stream_sync(struct hdac_stream *azx_dev, bool start,\n\t\t\t  unsigned int streams)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tint i, nwait, timeout;\n\tstruct hdac_stream *s;\n\n\tfor (timeout = 5000; timeout; timeout--) {\n\t\tnwait = 0;\n\t\ti = 0;\n\t\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\t\tif (!(streams & (1 << i++)))\n\t\t\t\tcontinue;\n\n\t\t\tif (start) {\n\t\t\t\t \n\t\t\t\tif (!(snd_hdac_stream_readb(s, SD_STS) &\n\t\t\t\t      SD_STS_FIFO_READY))\n\t\t\t\t\tnwait++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (snd_hdac_stream_readb(s, SD_CTL) &\n\t\t\t\t    SD_CTL_DMA_START) {\n\t\t\t\t\tnwait++;\n\t\t\t\t\t \n\t\t\t\t\tif (timeout == 1)\n\t\t\t\t\t\tsnd_hdac_stream_reset(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!nwait)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_sync);\n\n \nvoid snd_hdac_stream_spbcap_enable(struct hdac_bus *bus,\n\t\t\t\t   bool enable, int index)\n{\n\tu32 mask = 0;\n\n\tif (!bus->spbcap) {\n\t\tdev_err(bus->dev, \"Address of SPB capability is NULL\\n\");\n\t\treturn;\n\t}\n\n\tmask |= (1 << index);\n\n\tif (enable)\n\t\tsnd_hdac_updatel(bus->spbcap, AZX_REG_SPB_SPBFCCTL, mask, mask);\n\telse\n\t\tsnd_hdac_updatel(bus->spbcap, AZX_REG_SPB_SPBFCCTL, mask, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_spbcap_enable);\n\n \nint snd_hdac_stream_set_spib(struct hdac_bus *bus,\n\t\t\t     struct hdac_stream *azx_dev, u32 value)\n{\n\tif (!bus->spbcap) {\n\t\tdev_err(bus->dev, \"Address of SPB capability is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twritel(value, azx_dev->spib_addr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_set_spib);\n\n \nint snd_hdac_stream_get_spbmaxfifo(struct hdac_bus *bus,\n\t\t\t\t   struct hdac_stream *azx_dev)\n{\n\tif (!bus->spbcap) {\n\t\tdev_err(bus->dev, \"Address of SPB capability is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn readl(azx_dev->fifo_addr);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_get_spbmaxfifo);\n\n \nvoid snd_hdac_stream_drsm_enable(struct hdac_bus *bus,\n\t\t\t\t bool enable, int index)\n{\n\tu32 mask = 0;\n\n\tif (!bus->drsmcap) {\n\t\tdev_err(bus->dev, \"Address of DRSM capability is NULL\\n\");\n\t\treturn;\n\t}\n\n\tmask |= (1 << index);\n\n\tif (enable)\n\t\tsnd_hdac_updatel(bus->drsmcap, AZX_REG_DRSM_CTL, mask, mask);\n\telse\n\t\tsnd_hdac_updatel(bus->drsmcap, AZX_REG_DRSM_CTL, mask, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_drsm_enable);\n\n \nint snd_hdac_stream_wait_drsm(struct hdac_stream *azx_dev)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\tu32 mask, reg;\n\tint ret;\n\n\tmask = 1 << azx_dev->index;\n\n\tret = read_poll_timeout(snd_hdac_reg_readl, reg, !(reg & mask), 250, 2000, false, bus,\n\t\t\t\tbus->drsmcap + AZX_REG_DRSM_CTL);\n\tif (ret)\n\t\tdev_dbg(bus->dev, \"polling RSM 0x%08x failed: %d\\n\", mask, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_wait_drsm);\n\n \nint snd_hdac_stream_set_dpibr(struct hdac_bus *bus,\n\t\t\t      struct hdac_stream *azx_dev, u32 value)\n{\n\tif (!bus->drsmcap) {\n\t\tdev_err(bus->dev, \"Address of DRSM capability is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twritel(value, azx_dev->dpibr_addr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_set_dpibr);\n\n \nint snd_hdac_stream_set_lpib(struct hdac_stream *azx_dev, u32 value)\n{\n\tsnd_hdac_stream_writel(azx_dev, SD_LPIB, value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_stream_set_lpib);\n\n#ifdef CONFIG_SND_HDA_DSP_LOADER\n \nint snd_hdac_dsp_prepare(struct hdac_stream *azx_dev, unsigned int format,\n\t\t\t unsigned int byte_size, struct snd_dma_buffer *bufp)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\t__le32 *bdl;\n\tint err;\n\n\tsnd_hdac_dsp_lock(azx_dev);\n\tspin_lock_irq(&bus->reg_lock);\n\tif (azx_dev->running || azx_dev->locked) {\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tazx_dev->locked = true;\n\tspin_unlock_irq(&bus->reg_lock);\n\n\terr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG, bus->dev,\n\t\t\t\t  byte_size, bufp);\n\tif (err < 0)\n\t\tgoto err_alloc;\n\n\tazx_dev->substream = NULL;\n\tazx_dev->bufsize = byte_size;\n\tazx_dev->period_bytes = byte_size;\n\tazx_dev->format_val = format;\n\n\tsnd_hdac_stream_reset(azx_dev);\n\n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\n\n\tazx_dev->frags = 0;\n\tbdl = (__le32 *)azx_dev->bdl.area;\n\terr = setup_bdle(bus, bufp, azx_dev, &bdl, 0, byte_size, 0);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hdac_stream_setup(azx_dev);\n\tsnd_hdac_dsp_unlock(azx_dev);\n\treturn azx_dev->stream_tag;\n\n error:\n\tsnd_dma_free_pages(bufp);\n err_alloc:\n\tspin_lock_irq(&bus->reg_lock);\n\tazx_dev->locked = false;\n\tspin_unlock_irq(&bus->reg_lock);\n unlock:\n\tsnd_hdac_dsp_unlock(azx_dev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_dsp_prepare);\n\n \nvoid snd_hdac_dsp_trigger(struct hdac_stream *azx_dev, bool start)\n{\n\tif (start)\n\t\tsnd_hdac_stream_start(azx_dev);\n\telse\n\t\tsnd_hdac_stream_stop(azx_dev);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_dsp_trigger);\n\n \nvoid snd_hdac_dsp_cleanup(struct hdac_stream *azx_dev,\n\t\t\t  struct snd_dma_buffer *dmab)\n{\n\tstruct hdac_bus *bus = azx_dev->bus;\n\n\tif (!dmab->area || !azx_dev->locked)\n\t\treturn;\n\n\tsnd_hdac_dsp_lock(azx_dev);\n\t \n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\n\tsnd_hdac_stream_writel(azx_dev, SD_CTL, 0);\n\tazx_dev->bufsize = 0;\n\tazx_dev->period_bytes = 0;\n\tazx_dev->format_val = 0;\n\n\tsnd_dma_free_pages(dmab);\n\tdmab->area = NULL;\n\n\tspin_lock_irq(&bus->reg_lock);\n\tazx_dev->locked = false;\n\tspin_unlock_irq(&bus->reg_lock);\n\tsnd_hdac_dsp_unlock(azx_dev);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_dsp_cleanup);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}