{
  "module_name": "intel-nhlt.c",
  "hash_id": "54a6342d41924be9b31588a1f427634bcb056382bd5f7017d3097005668d19d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/intel-nhlt.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <sound/intel-nhlt.h>\n\nstruct nhlt_acpi_table *intel_nhlt_init(struct device *dev)\n{\n\tstruct nhlt_acpi_table *nhlt;\n\tacpi_status status;\n\n\tstatus = acpi_get_table(ACPI_SIG_NHLT, 0,\n\t\t\t\t(struct acpi_table_header **)&nhlt);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(dev, \"NHLT table not found\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn nhlt;\n}\nEXPORT_SYMBOL_GPL(intel_nhlt_init);\n\nvoid intel_nhlt_free(struct nhlt_acpi_table *nhlt)\n{\n\tacpi_put_table((struct acpi_table_header *)nhlt);\n}\nEXPORT_SYMBOL_GPL(intel_nhlt_free);\n\nint intel_nhlt_get_dmic_geo(struct device *dev, struct nhlt_acpi_table *nhlt)\n{\n\tstruct nhlt_endpoint *epnt;\n\tstruct nhlt_dmic_array_config *cfg;\n\tstruct nhlt_vendor_dmic_array_config *cfg_vendor;\n\tstruct nhlt_fmt *fmt_configs;\n\tunsigned int dmic_geo = 0;\n\tu16 max_ch = 0;\n\tu8 i, j;\n\n\tif (!nhlt)\n\t\treturn 0;\n\n\tif (nhlt->header.length <= sizeof(struct acpi_table_header)) {\n\t\tdev_warn(dev, \"Invalid DMIC description table\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (j = 0, epnt = nhlt->desc; j < nhlt->endpoint_count; j++,\n\t     epnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length)) {\n\n\t\tif (epnt->linktype != NHLT_LINK_DMIC)\n\t\t\tcontinue;\n\n\t\tcfg = (struct nhlt_dmic_array_config  *)(epnt->config.caps);\n\t\tfmt_configs = (struct nhlt_fmt *)(epnt->config.caps + epnt->config.size);\n\n\t\t \n\t\tif (fmt_configs->fmt_count) {\n\t\t\tstruct nhlt_fmt_cfg *fmt_cfg = fmt_configs->fmt_config;\n\n\t\t\tdev_dbg(dev, \"found %d format definitions\\n\",\n\t\t\t\tfmt_configs->fmt_count);\n\n\t\t\tfor (i = 0; i < fmt_configs->fmt_count; i++) {\n\t\t\t\tstruct wav_fmt_ext *fmt_ext;\n\n\t\t\t\tfmt_ext = &fmt_cfg->fmt_ext;\n\n\t\t\t\tif (fmt_ext->fmt.channels > max_ch)\n\t\t\t\t\tmax_ch = fmt_ext->fmt.channels;\n\n\t\t\t\t \n\t\t\t\tfmt_cfg = (struct nhlt_fmt_cfg *)(fmt_cfg->config.caps +\n\t\t\t\t\t\t\t\t  fmt_cfg->config.size);\n\t\t\t}\n\t\t\tdev_dbg(dev, \"max channels found %d\\n\", max_ch);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"No format information found\\n\");\n\t\t}\n\n\t\tif (cfg->device_config.config_type != NHLT_CONFIG_TYPE_MIC_ARRAY) {\n\t\t\tdmic_geo = max_ch;\n\t\t} else {\n\t\t\tswitch (cfg->array_type) {\n\t\t\tcase NHLT_MIC_ARRAY_2CH_SMALL:\n\t\t\tcase NHLT_MIC_ARRAY_2CH_BIG:\n\t\t\t\tdmic_geo = MIC_ARRAY_2CH;\n\t\t\t\tbreak;\n\n\t\t\tcase NHLT_MIC_ARRAY_4CH_1ST_GEOM:\n\t\t\tcase NHLT_MIC_ARRAY_4CH_L_SHAPED:\n\t\t\tcase NHLT_MIC_ARRAY_4CH_2ND_GEOM:\n\t\t\t\tdmic_geo = MIC_ARRAY_4CH;\n\t\t\t\tbreak;\n\t\t\tcase NHLT_MIC_ARRAY_VENDOR_DEFINED:\n\t\t\t\tcfg_vendor = (struct nhlt_vendor_dmic_array_config *)cfg;\n\t\t\t\tdmic_geo = cfg_vendor->nb_mics;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(dev, \"%s: undefined DMIC array_type 0x%0x\\n\",\n\t\t\t\t\t __func__, cfg->array_type);\n\t\t\t}\n\n\t\t\tif (dmic_geo > 0) {\n\t\t\t\tdev_dbg(dev, \"Array with %d dmics\\n\", dmic_geo);\n\t\t\t}\n\t\t\tif (max_ch > dmic_geo) {\n\t\t\t\tdev_dbg(dev, \"max channels %d exceed dmic number %d\\n\",\n\t\t\t\t\tmax_ch, dmic_geo);\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"dmic number %d max_ch %d\\n\", dmic_geo, max_ch);\n\n\treturn dmic_geo;\n}\nEXPORT_SYMBOL_GPL(intel_nhlt_get_dmic_geo);\n\nbool intel_nhlt_has_endpoint_type(struct nhlt_acpi_table *nhlt, u8 link_type)\n{\n\tstruct nhlt_endpoint *epnt;\n\tint i;\n\n\tif (!nhlt)\n\t\treturn false;\n\n\tepnt = (struct nhlt_endpoint *)nhlt->desc;\n\tfor (i = 0; i < nhlt->endpoint_count; i++) {\n\t\tif (epnt->linktype == link_type)\n\t\t\treturn true;\n\n\t\tepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(intel_nhlt_has_endpoint_type);\n\nint intel_nhlt_ssp_endpoint_mask(struct nhlt_acpi_table *nhlt, u8 device_type)\n{\n\tstruct nhlt_endpoint *epnt;\n\tint ssp_mask = 0;\n\tint i;\n\n\tif (!nhlt || (device_type != NHLT_DEVICE_BT && device_type != NHLT_DEVICE_I2S))\n\t\treturn 0;\n\n\tepnt = (struct nhlt_endpoint *)nhlt->desc;\n\tfor (i = 0; i < nhlt->endpoint_count; i++) {\n\t\tif (epnt->linktype == NHLT_LINK_SSP && epnt->device_type == device_type) {\n\t\t\t \n\t\t\tssp_mask |= BIT(epnt->virtual_bus_id);\n\t\t}\n\t\tepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\n\t}\n\n\treturn ssp_mask;\n}\nEXPORT_SYMBOL(intel_nhlt_ssp_endpoint_mask);\n\n#define SSP_BLOB_V1_0_SIZE\t\t84\n#define SSP_BLOB_V1_0_MDIVC_OFFSET\t19  \n\n#define SSP_BLOB_V1_5_SIZE\t\t96\n#define SSP_BLOB_V1_5_MDIVC_OFFSET\t21  \n#define SSP_BLOB_VER_1_5\t\t0xEE000105\n\n#define SSP_BLOB_V2_0_SIZE\t\t88\n#define SSP_BLOB_V2_0_MDIVC_OFFSET\t20  \n#define SSP_BLOB_VER_2_0\t\t0xEE000200\n\nint intel_nhlt_ssp_mclk_mask(struct nhlt_acpi_table *nhlt, int ssp_num)\n{\n\tstruct nhlt_endpoint *epnt;\n\tstruct nhlt_fmt *fmt;\n\tstruct nhlt_fmt_cfg *cfg;\n\tint mclk_mask = 0;\n\tint i, j;\n\n\tif (!nhlt)\n\t\treturn 0;\n\n\tepnt = (struct nhlt_endpoint *)nhlt->desc;\n\tfor (i = 0; i < nhlt->endpoint_count; i++) {\n\n\t\t \n\t\tif (epnt->linktype == NHLT_LINK_SSP &&\n\t\t    epnt->device_type == NHLT_DEVICE_I2S &&\n\t\t    epnt->virtual_bus_id == ssp_num) {\n\n\t\t\tfmt = (struct nhlt_fmt *)(epnt->config.caps + epnt->config.size);\n\t\t\tcfg = fmt->fmt_config;\n\n\t\t\t \n\t\t\tfor (j = 0; j < fmt->fmt_count; j++) {\n\t\t\t\tu32 *blob;\n\t\t\t\tint mdivc_offset;\n\t\t\t\tint size;\n\n\t\t\t\t \n\t\t\t\tif (cfg->config.size < 8)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tblob = (u32 *)cfg->config.caps;\n\n\t\t\t\tif (blob[1] == SSP_BLOB_VER_2_0) {\n\t\t\t\t\tmdivc_offset = SSP_BLOB_V2_0_MDIVC_OFFSET;\n\t\t\t\t\tsize = SSP_BLOB_V2_0_SIZE;\n\t\t\t\t} else if (blob[1] == SSP_BLOB_VER_1_5) {\n\t\t\t\t\tmdivc_offset = SSP_BLOB_V1_5_MDIVC_OFFSET;\n\t\t\t\t\tsize = SSP_BLOB_V1_5_SIZE;\n\t\t\t\t} else {\n\t\t\t\t\tmdivc_offset = SSP_BLOB_V1_0_MDIVC_OFFSET;\n\t\t\t\t\tsize = SSP_BLOB_V1_0_SIZE;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (cfg->config.size < size)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tmclk_mask |=  blob[mdivc_offset] & GENMASK(1, 0);\n\n\t\t\t\tcfg = (struct nhlt_fmt_cfg *)(cfg->config.caps + cfg->config.size);\n\t\t\t}\n\t\t}\n\t\tepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\n\t}\n\n\t \n\tif (hweight_long(mclk_mask) != 1)\n\t\treturn -EINVAL;\n\n\treturn mclk_mask;\n}\nEXPORT_SYMBOL(intel_nhlt_ssp_mclk_mask);\n\nstatic struct nhlt_specific_cfg *\nnhlt_get_specific_cfg(struct device *dev, struct nhlt_fmt *fmt, u8 num_ch,\n\t\t      u32 rate, u8 vbps, u8 bps, bool ignore_vbps)\n{\n\tstruct nhlt_fmt_cfg *cfg = fmt->fmt_config;\n\tstruct wav_fmt *wfmt;\n\tu16 _bps, _vbps;\n\tint i;\n\n\tdev_dbg(dev, \"Endpoint format count=%d\\n\", fmt->fmt_count);\n\n\tfor (i = 0; i < fmt->fmt_count; i++) {\n\t\twfmt = &cfg->fmt_ext.fmt;\n\t\t_bps = wfmt->bits_per_sample;\n\t\t_vbps = cfg->fmt_ext.sample.valid_bits_per_sample;\n\n\t\tdev_dbg(dev, \"Endpoint format: ch=%d fmt=%d/%d rate=%d\\n\",\n\t\t\twfmt->channels, _vbps, _bps, wfmt->samples_per_sec);\n\n\t\t \n\t\tif (wfmt->channels == num_ch && wfmt->samples_per_sec == rate &&\n\t\t    (ignore_vbps || vbps == _vbps) && bps == _bps)\n\t\t\treturn &cfg->config;\n\n\t\tcfg = (struct nhlt_fmt_cfg *)(cfg->config.caps + cfg->config.size);\n\t}\n\n\treturn NULL;\n}\n\nstatic bool nhlt_check_ep_match(struct device *dev, struct nhlt_endpoint *epnt,\n\t\t\t\tu32 bus_id, u8 link_type, u8 dir, u8 dev_type)\n{\n\tdev_dbg(dev, \"Endpoint: vbus_id=%d link_type=%d dir=%d dev_type = %d\\n\",\n\t\tepnt->virtual_bus_id, epnt->linktype,\n\t\tepnt->direction, epnt->device_type);\n\n\tif ((epnt->virtual_bus_id != bus_id) ||\n\t    (epnt->linktype != link_type) ||\n\t    (epnt->direction != dir))\n\t\treturn false;\n\n\t \n\treturn epnt->linktype == NHLT_LINK_DMIC ||\n\t       epnt->device_type == dev_type;\n}\n\nstruct nhlt_specific_cfg *\nintel_nhlt_get_endpoint_blob(struct device *dev, struct nhlt_acpi_table *nhlt,\n\t\t\t     u32 bus_id, u8 link_type, u8 vbps, u8 bps,\n\t\t\t     u8 num_ch, u32 rate, u8 dir, u8 dev_type)\n{\n\tstruct nhlt_specific_cfg *cfg;\n\tstruct nhlt_endpoint *epnt;\n\tbool ignore_vbps = false;\n\tstruct nhlt_fmt *fmt;\n\tint i;\n\n\tif (!nhlt)\n\t\treturn NULL;\n\n\tdev_dbg(dev, \"Looking for configuration:\\n\");\n\tdev_dbg(dev, \"  vbus_id=%d link_type=%d dir=%d, dev_type=%d\\n\",\n\t\tbus_id, link_type, dir, dev_type);\n\tif (link_type == NHLT_LINK_DMIC && bps == 32 && (vbps == 24 || vbps == 32)) {\n\t\t \n\t\tdev_dbg(dev,\n\t\t\t\"  ch=%d fmt=%d rate=%d (vbps is ignored for DMIC 32bit format)\\n\",\n\t\t\tnum_ch, bps, rate);\n\t\tignore_vbps = true;\n\t} else {\n\t\tdev_dbg(dev, \"  ch=%d fmt=%d/%d rate=%d\\n\", num_ch, vbps, bps, rate);\n\t}\n\tdev_dbg(dev, \"Endpoint count=%d\\n\", nhlt->endpoint_count);\n\n\tepnt = (struct nhlt_endpoint *)nhlt->desc;\n\n\tfor (i = 0; i < nhlt->endpoint_count; i++) {\n\t\tif (nhlt_check_ep_match(dev, epnt, bus_id, link_type, dir, dev_type)) {\n\t\t\tfmt = (struct nhlt_fmt *)(epnt->config.caps + epnt->config.size);\n\n\t\t\tcfg = nhlt_get_specific_cfg(dev, fmt, num_ch, rate,\n\t\t\t\t\t\t    vbps, bps, ignore_vbps);\n\t\t\tif (cfg)\n\t\t\t\treturn cfg;\n\t\t}\n\n\t\tepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(intel_nhlt_get_endpoint_blob);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}