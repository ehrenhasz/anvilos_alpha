{
  "module_name": "hdac_bus.c",
  "hash_id": "cda05d80aa90c9bde380d1b8f29035d13baab2c952656b7deff6c59576ac5336",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/hdac_bus.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <sound/hdaudio.h>\n#include \"local.h\"\n#include \"trace.h\"\n\nstatic void snd_hdac_bus_process_unsol_events(struct work_struct *work);\n\nstatic const struct hdac_bus_ops default_ops = {\n\t.command = snd_hdac_bus_send_cmd,\n\t.get_response = snd_hdac_bus_get_response,\n\t.link_power = snd_hdac_bus_link_power,\n};\n\n \nint snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,\n\t\t      const struct hdac_bus_ops *ops)\n{\n\tmemset(bus, 0, sizeof(*bus));\n\tbus->dev = dev;\n\tif (ops)\n\t\tbus->ops = ops;\n\telse\n\t\tbus->ops = &default_ops;\n\tbus->dma_type = SNDRV_DMA_TYPE_DEV;\n\tINIT_LIST_HEAD(&bus->stream_list);\n\tINIT_LIST_HEAD(&bus->codec_list);\n\tINIT_WORK(&bus->unsol_work, snd_hdac_bus_process_unsol_events);\n\tspin_lock_init(&bus->reg_lock);\n\tmutex_init(&bus->cmd_mutex);\n\tmutex_init(&bus->lock);\n\tINIT_LIST_HEAD(&bus->hlink_list);\n\tinit_waitqueue_head(&bus->rirb_wq);\n\tbus->irq = -1;\n\n\t \n\tbus->sdo_limit = 8;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_init);\n\n \nvoid snd_hdac_bus_exit(struct hdac_bus *bus)\n{\n\tWARN_ON(!list_empty(&bus->stream_list));\n\tWARN_ON(!list_empty(&bus->codec_list));\n\tcancel_work_sync(&bus->unsol_work);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_exit);\n\n \nint snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,\n\t\t\t   unsigned int cmd, unsigned int *res)\n{\n\tint err;\n\n\tmutex_lock(&bus->cmd_mutex);\n\terr = snd_hdac_bus_exec_verb_unlocked(bus, addr, cmd, res);\n\tmutex_unlock(&bus->cmd_mutex);\n\treturn err;\n}\n\n \nint snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,\n\t\t\t\t    unsigned int cmd, unsigned int *res)\n{\n\tunsigned int tmp;\n\tint err;\n\n\tif (cmd == ~0)\n\t\treturn -EINVAL;\n\n\tif (res)\n\t\t*res = -1;\n\telse if (bus->sync_write)\n\t\tres = &tmp;\n\tfor (;;) {\n\t\ttrace_hda_send_cmd(bus, cmd);\n\t\terr = bus->ops->command(bus, cmd);\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\t\t \n\t\terr = bus->ops->get_response(bus, addr, &tmp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (!err && res) {\n\t\terr = bus->ops->get_response(bus, addr, res);\n\t\ttrace_hda_get_response(bus, addr, *res);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb_unlocked);\n\n \nvoid snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)\n{\n\tunsigned int wp;\n\n\tif (!bus)\n\t\treturn;\n\n\ttrace_hda_unsol_event(bus, res, res_ex);\n\twp = (bus->unsol_wp + 1) % HDA_UNSOL_QUEUE_SIZE;\n\tbus->unsol_wp = wp;\n\n\twp <<= 1;\n\tbus->unsol_queue[wp] = res;\n\tbus->unsol_queue[wp + 1] = res_ex;\n\n\tschedule_work(&bus->unsol_work);\n}\n\n \nstatic void snd_hdac_bus_process_unsol_events(struct work_struct *work)\n{\n\tstruct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);\n\tstruct hdac_device *codec;\n\tstruct hdac_driver *drv;\n\tunsigned int rp, caddr, res;\n\n\tspin_lock_irq(&bus->reg_lock);\n\twhile (bus->unsol_rp != bus->unsol_wp) {\n\t\trp = (bus->unsol_rp + 1) % HDA_UNSOL_QUEUE_SIZE;\n\t\tbus->unsol_rp = rp;\n\t\trp <<= 1;\n\t\tres = bus->unsol_queue[rp];\n\t\tcaddr = bus->unsol_queue[rp + 1];\n\t\tif (!(caddr & (1 << 4)))  \n\t\t\tcontinue;\n\t\tcodec = bus->caddr_tbl[caddr & 0x0f];\n\t\tif (!codec || !codec->registered)\n\t\t\tcontinue;\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\tdrv = drv_to_hdac_driver(codec->dev.driver);\n\t\tif (drv->unsol_event)\n\t\t\tdrv->unsol_event(codec, res);\n\t\tspin_lock_irq(&bus->reg_lock);\n\t}\n\tspin_unlock_irq(&bus->reg_lock);\n}\n\n \nint snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)\n{\n\tif (bus->caddr_tbl[codec->addr]) {\n\t\tdev_err(bus->dev, \"address 0x%x is already occupied\\n\",\n\t\t\tcodec->addr);\n\t\treturn -EBUSY;\n\t}\n\n\tlist_add_tail(&codec->list, &bus->codec_list);\n\tbus->caddr_tbl[codec->addr] = codec;\n\tset_bit(codec->addr, &bus->codec_powered);\n\tbus->num_codecs++;\n\treturn 0;\n}\n\n \nvoid snd_hdac_bus_remove_device(struct hdac_bus *bus,\n\t\t\t\tstruct hdac_device *codec)\n{\n\tWARN_ON(bus != codec->bus);\n\tif (list_empty(&codec->list))\n\t\treturn;\n\tlist_del_init(&codec->list);\n\tbus->caddr_tbl[codec->addr] = NULL;\n\tclear_bit(codec->addr, &bus->codec_powered);\n\tbus->num_codecs--;\n\tflush_work(&bus->unsol_work);\n}\n\n#ifdef CONFIG_SND_HDA_ALIGNED_MMIO\n \nunsigned int snd_hdac_aligned_read(void __iomem *addr, unsigned int mask)\n{\n\tvoid __iomem *aligned_addr =\n\t\t(void __iomem *)((unsigned long)(addr) & ~0x3);\n\tunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\n\tunsigned int v;\n\n\tv = readl(aligned_addr);\n\treturn (v >> shift) & mask;\n}\nEXPORT_SYMBOL_GPL(snd_hdac_aligned_read);\n\nvoid snd_hdac_aligned_write(unsigned int val, void __iomem *addr,\n\t\t\t    unsigned int mask)\n{\n\tvoid __iomem *aligned_addr =\n\t\t(void __iomem *)((unsigned long)(addr) & ~0x3);\n\tunsigned int shift = ((unsigned long)(addr) & 0x3) << 3;\n\tunsigned int v;\n\n\tv = readl(aligned_addr);\n\tv &= ~(mask << shift);\n\tv |= val << shift;\n\twritel(v, aligned_addr);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_aligned_write);\n#endif  \n\nvoid snd_hdac_codec_link_up(struct hdac_device *codec)\n{\n\tstruct hdac_bus *bus = codec->bus;\n\n\tif (bus->ops->link_power)\n\t\tbus->ops->link_power(codec, true);\n\telse\n\t\tsnd_hdac_bus_link_power(codec, true);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_codec_link_up);\n\nvoid snd_hdac_codec_link_down(struct hdac_device *codec)\n{\n\tstruct hdac_bus *bus = codec->bus;\n\n\tif (bus->ops->link_power)\n\t\tbus->ops->link_power(codec, false);\n\telse\n\t\tsnd_hdac_bus_link_power(codec, false);\n}\nEXPORT_SYMBOL_GPL(snd_hdac_codec_link_down);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}