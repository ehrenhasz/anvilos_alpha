{
  "module_name": "intel-sdw-acpi.c",
  "hash_id": "ea2441bc9b58ed9023f0ccc12aa2c18d763ec95c7ce3dfc30715c56ffe49f7be",
  "original_prompt": "Ingested from linux-6.6.14/sound/hda/intel-sdw-acpi.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/fwnode.h>\n#include <linux/module.h>\n#include <linux/soundwire/sdw_intel.h>\n#include <linux/string.h>\n\n#define SDW_LINK_TYPE\t\t4  \n#define SDW_MAX_LINKS\t\t4\n\nstatic int ctrl_link_mask;\nmodule_param_named(sdw_link_mask, ctrl_link_mask, int, 0444);\nMODULE_PARM_DESC(sdw_link_mask, \"Intel link mask (one bit per link)\");\n\nstatic bool is_link_enabled(struct fwnode_handle *fw_node, u8 idx)\n{\n\tstruct fwnode_handle *link;\n\tchar name[32];\n\tu32 quirk_mask = 0;\n\n\t \n\tsnprintf(name, sizeof(name),\n\t\t \"mipi-sdw-link-%hhu-subproperties\", idx);\n\n\tlink = fwnode_get_named_child_node(fw_node, name);\n\tif (!link)\n\t\treturn false;\n\n\tfwnode_property_read_u32(link,\n\t\t\t\t \"intel-quirk-mask\",\n\t\t\t\t &quirk_mask);\n\n\tif (quirk_mask & SDW_INTEL_QUIRK_MASK_BUS_DISABLE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nsdw_intel_scan_controller(struct sdw_intel_acpi_info *info)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(info->handle);\n\tu8 count, i;\n\tint ret;\n\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\t \n\tcount = 0;\n\tret = fwnode_property_read_u8_array(acpi_fwnode_handle(adev),\n\t\t\t\t\t    \"mipi-sdw-master-count\", &count, 1);\n\n\t \n\n\tif (ret) {\n\t\tdev_err(&adev->dev,\n\t\t\t\"Failed to read mipi-sdw-master-count: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (count > SDW_MAX_LINKS) {\n\t\tdev_err(&adev->dev, \"Link count %d exceeds max %d\\n\",\n\t\t\tcount, SDW_MAX_LINKS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&adev->dev, \"No SoundWire links detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&adev->dev, \"ACPI reports %d SDW Link devices\\n\", count);\n\n\tinfo->count = count;\n\tinfo->link_mask = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (ctrl_link_mask && !(ctrl_link_mask & BIT(i))) {\n\t\t\tdev_dbg(&adev->dev,\n\t\t\t\t\"Link %d masked, will not be enabled\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_link_enabled(acpi_fwnode_handle(adev), i)) {\n\t\t\tdev_dbg(&adev->dev,\n\t\t\t\t\"Link %d not selected in firmware\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo->link_mask |= BIT(i);\n\t}\n\n\treturn 0;\n}\n\nstatic acpi_status sdw_intel_acpi_cb(acpi_handle handle, u32 level,\n\t\t\t\t     void *cdata, void **return_value)\n{\n\tstruct sdw_intel_acpi_info *info = cdata;\n\tacpi_status status;\n\tu64 adr;\n\n\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &adr);\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;  \n\n\tif (!acpi_fetch_acpi_dev(handle)) {\n\t\tpr_err(\"%s: Couldn't find ACPI handle\\n\", __func__);\n\t\treturn AE_NOT_FOUND;\n\t}\n\n\t \n\tif (FIELD_GET(GENMASK(31, 28), adr) != SDW_LINK_TYPE)\n\t\treturn AE_OK;  \n\n\t \n\tinfo->handle = handle;\n\n\t \n\treturn AE_CTRL_TERMINATE;\n}\n\n \nint sdw_intel_acpi_scan(acpi_handle *parent_handle,\n\t\t\tstruct sdw_intel_acpi_info *info)\n{\n\tacpi_status status;\n\n\tinfo->handle = NULL;\n\t \n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE,\n\t\t\t\t     parent_handle, 2,\n\t\t\t\t     sdw_intel_acpi_cb,\n\t\t\t\t     NULL, info, NULL);\n\tif (ACPI_FAILURE(status) || info->handle == NULL)\n\t\treturn -ENODEV;\n\n\treturn sdw_intel_scan_controller(info);\n}\nEXPORT_SYMBOL_NS(sdw_intel_acpi_scan, SND_INTEL_SOUNDWIRE_ACPI);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Intel Soundwire ACPI helpers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}