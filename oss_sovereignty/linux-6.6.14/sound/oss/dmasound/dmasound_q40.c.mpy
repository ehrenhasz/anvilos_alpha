{
  "module_name": "dmasound_q40.c",
  "hash_id": "4a72e4a4860176accf419f246271f2d72a1848d1dda0ec03c462474890e3cfc8",
  "original_prompt": "Ingested from linux-6.6.14/sound/oss/dmasound/dmasound_q40.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/soundcard.h>\n#include <linux/interrupt.h>\n\n#include <linux/uaccess.h>\n#include <asm/q40ints.h>\n#include <asm/q40_master.h>\n\n#include \"dmasound.h\"\n\n#define DMASOUND_Q40_REVISION 0\n#define DMASOUND_Q40_EDITION 3\n\nstatic int expand_bal;\t \nstatic int expand_data;\t \n\n\n \n\n\nstatic void *Q40Alloc(unsigned int size, gfp_t flags);\nstatic void Q40Free(void *, unsigned int);\nstatic int Q40IrqInit(void);\n#ifdef MODULE\nstatic void Q40IrqCleanUp(void);\n#endif\nstatic void Q40Silence(void);\nstatic void Q40Init(void);\nstatic int Q40SetFormat(int format);\nstatic int Q40SetVolume(int volume);\nstatic void Q40PlayNextFrame(int index);\nstatic void Q40Play(void);\nstatic irqreturn_t Q40StereoInterrupt(int irq, void *dummy);\nstatic irqreturn_t Q40MonoInterrupt(int irq, void *dummy);\nstatic void Q40Interrupt(void);\n\n\n \n\n\n\n \nstatic ssize_t q40_ct_law(const u_char __user *userPtr, size_t userCount,\n\t\t\t   u_char frame[], ssize_t *frameUsed,\n\t\t\t   ssize_t frameLeft)\n{\n\tchar *table = dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8;\n\tssize_t count, used;\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\n\tused = count = min_t(size_t, userCount, frameLeft);\n\tif (copy_from_user(p,userPtr,count))\n\t  return -EFAULT;\n\twhile (count > 0) {\n\t\t*p = table[*p]+128;\n\t\tp++;\n\t\tcount--;\n\t}\n\t*frameUsed += used ;\n\treturn used;\n}\n\n\nstatic ssize_t q40_ct_s8(const u_char __user *userPtr, size_t userCount,\n\t\t\t  u_char frame[], ssize_t *frameUsed,\n\t\t\t  ssize_t frameLeft)\n{\n\tssize_t count, used;\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\n\tused = count = min_t(size_t, userCount, frameLeft);\n\tif (copy_from_user(p,userPtr,count))\n\t  return -EFAULT;\n\twhile (count > 0) {\n\t\t*p = *p + 128;\n\t\tp++;\n\t\tcount--;\n\t}\n\t*frameUsed += used;\n\treturn used;\n}\n\nstatic ssize_t q40_ct_u8(const u_char __user *userPtr, size_t userCount,\n\t\t\t  u_char frame[], ssize_t *frameUsed,\n\t\t\t  ssize_t frameLeft)\n{\n\tssize_t count, used;\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\n\tused = count = min_t(size_t, userCount, frameLeft);\n\tif (copy_from_user(p,userPtr,count))\n\t  return -EFAULT;\n\t*frameUsed += used;\n\treturn used;\n}\n\n\n \nstatic ssize_t q40_ctx_law(const u_char __user *userPtr, size_t userCount,\n\t\t\t    u_char frame[], ssize_t *frameUsed,\n\t\t\t    ssize_t frameLeft)\n{\n\tunsigned char *table = (unsigned char *)\n\t\t(dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8);\n\tunsigned int data = expand_data;\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n\n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\tif (bal < 0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tbreak;\n\t\t\tif (get_user(c, userPtr++))\n\t\t\t\treturn -EFAULT;\n\t\t\tdata = table[c];\n\t\t\tdata += 0x80;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft);\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n\nstatic ssize_t q40_ctx_s8(const u_char __user *userPtr, size_t userCount,\n\t\t\t   u_char frame[], ssize_t *frameUsed,\n\t\t\t   ssize_t frameLeft)\n{\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tunsigned int data = expand_data;\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n\n\n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\tif (bal < 0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tbreak;\n\t\t\tif (get_user(c, userPtr++))\n\t\t\t\treturn -EFAULT;\n\t\t\tdata = c ;\n\t\t\tdata += 0x80;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft);\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n\nstatic ssize_t q40_ctx_u8(const u_char __user *userPtr, size_t userCount,\n\t\t\t   u_char frame[], ssize_t *frameUsed,\n\t\t\t   ssize_t frameLeft)\n{\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tunsigned int data = expand_data;\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n\n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\tif (bal < 0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tbreak;\n\t\t\tif (get_user(c, userPtr++))\n\t\t\t\treturn -EFAULT;\n\t\t\tdata = c ;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft) ;\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n \nstatic ssize_t q40_ctc_law(const u_char __user *userPtr, size_t userCount,\n\t\t\t    u_char frame[], ssize_t *frameUsed,\n\t\t\t    ssize_t frameLeft)\n{\n\tunsigned char *table = (unsigned char *)\n\t\t(dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8: dmasound_alaw2dma8);\n\tunsigned int data = expand_data;\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n \n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\twhile(bal<0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tgoto lout;\n\t\t\tif (!(bal<(-hSpeed))) {\n\t\t\t\tif (get_user(c, userPtr))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tdata = 0x80 + table[c];\n\t\t\t}\n\t\t\tuserPtr++;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n lout:\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft);\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n\nstatic ssize_t q40_ctc_s8(const u_char __user *userPtr, size_t userCount,\n\t\t\t   u_char frame[], ssize_t *frameUsed,\n\t\t\t   ssize_t frameLeft)\n{\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tunsigned int data = expand_data;\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n\n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\twhile (bal < 0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tgoto lout;\n\t\t\tif (!(bal<(-hSpeed))) {\n\t\t\t\tif (get_user(c, userPtr))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tdata = c + 0x80;\n\t\t\t}\n\t\t\tuserPtr++;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n lout:\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft);\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n\nstatic ssize_t q40_ctc_u8(const u_char __user *userPtr, size_t userCount,\n\t\t\t   u_char frame[], ssize_t *frameUsed,\n\t\t\t   ssize_t frameLeft)\n{\n\tu_char *p = (u_char *) &frame[*frameUsed];\n\tunsigned int data = expand_data;\n\tint bal = expand_bal;\n\tint hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\n\tint utotal, ftotal;\n\n\tftotal = frameLeft;\n\tutotal = userCount;\n\twhile (frameLeft) {\n\t\tu_char c;\n\t\twhile (bal < 0) {\n\t\t\tif (userCount == 0)\n\t\t\t\tgoto lout;\n\t\t\tif (!(bal<(-hSpeed))) {\n\t\t\t\tif (get_user(c, userPtr))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tdata = c ;\n\t\t\t}\n\t\t\tuserPtr++;\n\t\t\tuserCount--;\n\t\t\tbal += hSpeed;\n\t\t}\n\t\t*p++ = data;\n\t\tframeLeft--;\n\t\tbal -= sSpeed;\n\t}\n lout:\n\texpand_bal = bal;\n\texpand_data = data;\n\t*frameUsed += (ftotal - frameLeft) ;\n\tutotal -= userCount;\n\treturn utotal;\n}\n\n\nstatic TRANS transQ40Normal = {\n\tq40_ct_law, q40_ct_law, q40_ct_s8, q40_ct_u8, NULL, NULL, NULL, NULL\n};\n\nstatic TRANS transQ40Expanding = {\n\tq40_ctx_law, q40_ctx_law, q40_ctx_s8, q40_ctx_u8, NULL, NULL, NULL, NULL\n};\n\nstatic TRANS transQ40Compressing = {\n\tq40_ctc_law, q40_ctc_law, q40_ctc_s8, q40_ctc_u8, NULL, NULL, NULL, NULL\n};\n\n\n \n\nstatic void *Q40Alloc(unsigned int size, gfp_t flags)\n{\n         return kmalloc(size, flags);  \n}\n\nstatic void Q40Free(void *ptr, unsigned int size)\n{\n\tkfree(ptr);\n}\n\nstatic int __init Q40IrqInit(void)\n{\n\t \n\tif (request_irq(Q40_IRQ_SAMPLE, Q40StereoInterrupt, 0,\n\t\t    \"DMA sound\", Q40Interrupt))\n\t\treturn 0;\n\n\treturn(1);\n}\n\n\n#ifdef MODULE\nstatic void Q40IrqCleanUp(void)\n{\n        master_outb(0,SAMPLE_ENABLE_REG);\n\tfree_irq(Q40_IRQ_SAMPLE, Q40Interrupt);\n}\n#endif  \n\n\nstatic void Q40Silence(void)\n{\n        master_outb(0,SAMPLE_ENABLE_REG);\n\t*DAC_LEFT=*DAC_RIGHT=127;\n}\n\nstatic char *q40_pp;\nstatic unsigned int q40_sc;\n\nstatic void Q40PlayNextFrame(int index)\n{\n\tu_char *start;\n\tu_long size;\n\tu_char speed;\n\tint error;\n\n\t \n\tstart = write_sq.buffers[write_sq.front];\n\tsize = (write_sq.count == index ? write_sq.rear_size : write_sq.block_size);\n\n\tq40_pp=start;\n\tq40_sc=size;\n\n\twrite_sq.front = (write_sq.front+1) % write_sq.max_count;\n\twrite_sq.active++;\n\n\tspeed=(dmasound.hard.speed==10000 ? 0 : 1);\n\n\tmaster_outb( 0,SAMPLE_ENABLE_REG);\n\tfree_irq(Q40_IRQ_SAMPLE, Q40Interrupt);\n\tif (dmasound.soft.stereo)\n\t\terror = request_irq(Q40_IRQ_SAMPLE, Q40StereoInterrupt, 0,\n\t\t\t\t    \"Q40 sound\", Q40Interrupt);\n\t  else\n\t\terror = request_irq(Q40_IRQ_SAMPLE, Q40MonoInterrupt, 0,\n\t\t\t\t    \"Q40 sound\", Q40Interrupt);\n\tif (error && printk_ratelimit())\n\t\tpr_err(\"Couldn't register sound interrupt\\n\");\n\n\tmaster_outb( speed, SAMPLE_RATE_REG);\n\tmaster_outb( 1,SAMPLE_CLEAR_REG);\n\tmaster_outb( 1,SAMPLE_ENABLE_REG);\n}\n\nstatic void Q40Play(void)\n{\n        unsigned long flags;\n\n\tif (write_sq.active || write_sq.count<=0 ) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (write_sq.count <= 1 && write_sq.rear_size < write_sq.block_size && !write_sq.syncing) {\n\t          \n\t         return;\n\t}\n\tspin_lock_irqsave(&dmasound.lock, flags);\n\tQ40PlayNextFrame(1);\n\tspin_unlock_irqrestore(&dmasound.lock, flags);\n}\n\nstatic irqreturn_t Q40StereoInterrupt(int irq, void *dummy)\n{\n\tspin_lock(&dmasound.lock);\n        if (q40_sc>1){\n            *DAC_LEFT=*q40_pp++;\n\t    *DAC_RIGHT=*q40_pp++;\n\t    q40_sc -=2;\n\t    master_outb(1,SAMPLE_CLEAR_REG);\n\t}else Q40Interrupt();\n\tspin_unlock(&dmasound.lock);\n\treturn IRQ_HANDLED;\n}\nstatic irqreturn_t Q40MonoInterrupt(int irq, void *dummy)\n{\n\tspin_lock(&dmasound.lock);\n        if (q40_sc>0){\n            *DAC_LEFT=*q40_pp;\n\t    *DAC_RIGHT=*q40_pp++;\n\t    q40_sc --;\n\t    master_outb(1,SAMPLE_CLEAR_REG);\n\t}else Q40Interrupt();\n\tspin_unlock(&dmasound.lock);\n\treturn IRQ_HANDLED;\n}\nstatic void Q40Interrupt(void)\n{\n\tif (!write_sq.active) {\n\t           \n\t           WAKE_UP(write_sq.sync_queue);\n\t\t   master_outb(0,SAMPLE_ENABLE_REG);  \n\t\t   goto exit;\n\t} else write_sq.active=0;\n\twrite_sq.count--;\n\tQ40Play();\n\n\tif (q40_sc<2)\n\t      {  \n\t\tmaster_outb(0,SAMPLE_ENABLE_REG);\n\t\t*DAC_LEFT=*DAC_RIGHT=127;\n\t      }\n\tWAKE_UP(write_sq.action_queue);\n\n exit:\n\tmaster_outb(1,SAMPLE_CLEAR_REG);\n}\n\n\nstatic void Q40Init(void)\n{\n\tint i, idx;\n\tconst int freq[] = {10000, 20000};\n\n\t \n\n\tidx = -1;\n\tfor (i = 0; i < 2; i++)\n\t\tif ((100 * abs(dmasound.soft.speed - freq[i]) / freq[i]) <= catchRadius)\n\t\t\tidx = i;\n\n\tdmasound.hard = dmasound.soft;\n\t   \n\tdmasound.hard.size=8;\n\n\tif (idx > -1) {\n\t\tdmasound.soft.speed = freq[idx];\n\t\tdmasound.trans_write = &transQ40Normal;\n\t} else\n\t\tdmasound.trans_write = &transQ40Expanding;\n\n\tQ40Silence();\n\n\tif (dmasound.hard.speed > 20200) {\n\t\t \n\t\tdmasound.hard.speed = 20000;\n\t\tdmasound.trans_write = &transQ40Compressing;\n\t} else if (dmasound.hard.speed > 10000) {\n\t\tdmasound.hard.speed = 20000;\n\t} else {\n\t\tdmasound.hard.speed = 10000;\n\t}\n\texpand_bal = -dmasound.soft.speed;\n}\n\n\nstatic int Q40SetFormat(int format)\n{\n\t \n\n\tswitch (format) {\n\tcase AFMT_QUERY:\n\t\treturn(dmasound.soft.format);\n\tcase AFMT_MU_LAW:\n\tcase AFMT_A_LAW:\n\tcase AFMT_S8:\n\tcase AFMT_U8:\n\t\tbreak;\n\tdefault:\n\t\tformat = AFMT_S8;\n\t}\n\n\tdmasound.soft.format = format;\n\tdmasound.soft.size = 8;\n\tif (dmasound.minDev == SND_DEV_DSP) {\n\t\tdmasound.dsp.format = format;\n\t\tdmasound.dsp.size = 8;\n\t}\n\tQ40Init();\n\n\treturn(format);\n}\n\nstatic int Q40SetVolume(int volume)\n{\n    return 0;\n}\n\n\n \n\nstatic SETTINGS def_hard = {\n\t.format\t= AFMT_U8,\n\t.stereo\t= 0,\n\t.size\t= 8,\n\t.speed\t= 10000\n} ;\n\nstatic SETTINGS def_soft = {\n\t.format\t= AFMT_U8,\n\t.stereo\t= 0,\n\t.size\t= 8,\n\t.speed\t= 8000\n} ;\n\nstatic MACHINE machQ40 = {\n\t.name\t\t= \"Q40\",\n\t.name2\t\t= \"Q40\",\n\t.owner\t\t= THIS_MODULE,\n\t.dma_alloc\t= Q40Alloc,\n\t.dma_free\t= Q40Free,\n\t.irqinit\t= Q40IrqInit,\n#ifdef MODULE\n\t.irqcleanup\t= Q40IrqCleanUp,\n#endif  \n\t.init\t\t= Q40Init,\n\t.silence\t= Q40Silence,\n\t.setFormat\t= Q40SetFormat,\n\t.setVolume\t= Q40SetVolume,\n\t.play\t\t= Q40Play,\n \t.min_dsp_speed\t= 10000,\n\t.version\t= ((DMASOUND_Q40_REVISION<<8) | DMASOUND_Q40_EDITION),\n\t.hardware_afmts\t= AFMT_U8,  \n\t.capabilities\t= DSP_CAP_BATCH   \n};\n\n\n \n\n\nstatic int __init dmasound_q40_init(void)\n{\n\tif (MACH_IS_Q40) {\n\t    dmasound.mach = machQ40;\n\t    dmasound.mach.default_hard = def_hard ;\n\t    dmasound.mach.default_soft = def_soft ;\n\t    return dmasound_init();\n\t} else\n\t    return -ENODEV;\n}\n\nstatic void __exit dmasound_q40_cleanup(void)\n{\n\tdmasound_deinit();\n}\n\nmodule_init(dmasound_q40_init);\nmodule_exit(dmasound_q40_cleanup);\n\nMODULE_DESCRIPTION(\"Q40/Q60 sound driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}