{
  "module_name": "dmasound_paula.c",
  "hash_id": "543da3a31b5d2361b583dd818ff3f96b09c3ba1d77e10a48fdc9fceac09f9a1d",
  "original_prompt": "Ingested from linux-6.6.14/sound/oss/dmasound/dmasound_paula.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/soundcard.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n#include <asm/setup.h>\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/machdep.h>\n\n#include \"dmasound.h\"\n\n#define DMASOUND_PAULA_REVISION 0\n#define DMASOUND_PAULA_EDITION 4\n\n#define custom amiga_custom\n    \n\nextern volatile u_short amiga_audio_min_period;\n\n\n    \n\nextern u_short amiga_audio_period;\n\n\n    \n\n#define AMI_AUDIO_OFF\t(DMAF_AUD0 | DMAF_AUD1 | DMAF_AUD2 | DMAF_AUD3)\n#define AMI_AUDIO_8\t(DMAF_SETCLR | DMAF_MASTER | DMAF_AUD0 | DMAF_AUD1)\n#define AMI_AUDIO_14\t(AMI_AUDIO_8 | DMAF_AUD2 | DMAF_AUD3)\n\n\n     \n\nstatic int write_sq_block_size_half, write_sq_block_size_quarter;\n\n\n \n\n\nstatic void *AmiAlloc(unsigned int size, gfp_t flags);\nstatic void AmiFree(void *obj, unsigned int size);\nstatic int AmiIrqInit(void);\n#ifdef MODULE\nstatic void AmiIrqCleanUp(void);\n#endif\nstatic void AmiSilence(void);\nstatic void AmiInit(void);\nstatic int AmiSetFormat(int format);\nstatic int AmiSetVolume(int volume);\nstatic int AmiSetTreble(int treble);\nstatic void AmiPlayNextFrame(int index);\nstatic void AmiPlay(void);\nstatic irqreturn_t AmiInterrupt(int irq, void *dummy);\n\n#ifdef CONFIG_HEARTBEAT\n\n     \n\nstatic void (*saved_heartbeat)(int) = NULL;\n\nstatic inline void disable_heartbeat(void)\n{\n\tif (mach_heartbeat) {\n\t    saved_heartbeat = mach_heartbeat;\n\t    mach_heartbeat = NULL;\n\t}\n\tAmiSetTreble(dmasound.treble);\n}\n\nstatic inline void enable_heartbeat(void)\n{\n\tif (saved_heartbeat)\n\t    mach_heartbeat = saved_heartbeat;\n}\n#else  \n#define disable_heartbeat()\tdo { } while (0)\n#define enable_heartbeat()\tdo { } while (0)\n#endif  \n\n\n \n\nstatic void AmiMixerInit(void);\nstatic int AmiMixerIoctl(u_int cmd, u_long arg);\nstatic int AmiWriteSqSetup(void);\nstatic int AmiStateInfo(char *buffer, size_t space);\n\n\n \n\n \n\n\n     \n\nstatic ssize_t ami_ct_s8(const u_char __user *userPtr, size_t userCount,\n\t\t\t u_char frame[], ssize_t *frameUsed, ssize_t frameLeft)\n{\n\tssize_t count, used;\n\n\tif (!dmasound.soft.stereo) {\n\t\tvoid *p = &frame[*frameUsed];\n\t\tcount = min_t(unsigned long, userCount, frameLeft) & ~1;\n\t\tused = count;\n\t\tif (copy_from_user(p, userPtr, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tu_char *left = &frame[*frameUsed>>1];\n\t\tu_char *right = left+write_sq_block_size_half;\n\t\tcount = min_t(unsigned long, userCount, frameLeft)>>1 & ~1;\n\t\tused = count*2;\n\t\twhile (count > 0) {\n\t\t\tif (get_user(*left++, userPtr++)\n\t\t\t    || get_user(*right++, userPtr++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount--;\n\t\t}\n\t}\n\t*frameUsed += used;\n\treturn used;\n}\n\n\n     \n\n#define GENERATE_AMI_CT8(funcname, convsample)\t\t\t\t\\\nstatic ssize_t funcname(const u_char __user *userPtr, size_t userCount,\t\\\n\t\t\tu_char frame[], ssize_t *frameUsed,\t\t\\\n\t\t\tssize_t frameLeft)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tssize_t count, used;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!dmasound.soft.stereo) {\t\t\t\t\t\\\n\t\tu_char *p = &frame[*frameUsed];\t\t\t\t\\\n\t\tcount = min_t(size_t, userCount, frameLeft) & ~1;\t\\\n\t\tused = count;\t\t\t\t\t\t\\\n\t\twhile (count > 0) {\t\t\t\t\t\\\n\t\t\tu_char data;\t\t\t\t\t\\\n\t\t\tif (get_user(data, userPtr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\t*p++ = convsample(data);\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tu_char *left = &frame[*frameUsed>>1];\t\t\t\\\n\t\tu_char *right = left+write_sq_block_size_half;\t\t\\\n\t\tcount = min_t(size_t, userCount, frameLeft)>>1 & ~1;\t\\\n\t\tused = count*2;\t\t\t\t\t\t\\\n\t\twhile (count > 0) {\t\t\t\t\t\\\n\t\t\tu_char data;\t\t\t\t\t\\\n\t\t\tif (get_user(data, userPtr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\t*left++ = convsample(data);\t\t\t\\\n\t\t\tif (get_user(data, userPtr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\t*right++ = convsample(data);\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t*frameUsed += used;\t\t\t\t\t\t\\\n\treturn used;\t\t\t\t\t\t\t\\\n}\n\n#define AMI_CT_ULAW(x)\t(dmasound_ulaw2dma8[(x)])\n#define AMI_CT_ALAW(x)\t(dmasound_alaw2dma8[(x)])\n#define AMI_CT_U8(x)\t((x) ^ 0x80)\n\nGENERATE_AMI_CT8(ami_ct_ulaw, AMI_CT_ULAW)\nGENERATE_AMI_CT8(ami_ct_alaw, AMI_CT_ALAW)\nGENERATE_AMI_CT8(ami_ct_u8, AMI_CT_U8)\n\n\n     \n\n#define GENERATE_AMI_CT_16(funcname, convsample)\t\t\t\\\nstatic ssize_t funcname(const u_char __user *userPtr, size_t userCount,\t\\\n\t\t\tu_char frame[], ssize_t *frameUsed,\t\t\\\n\t\t\tssize_t frameLeft)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst u_short __user *ptr = (const u_short __user *)userPtr;\t\\\n\tssize_t count, used;\t\t\t\t\t\t\\\n\tu_short data;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!dmasound.soft.stereo) {\t\t\t\t\t\\\n\t\tu_char *high = &frame[*frameUsed>>1];\t\t\t\\\n\t\tu_char *low = high+write_sq_block_size_half;\t\t\\\n\t\tcount = min_t(size_t, userCount, frameLeft)>>1 & ~1;\t\\\n\t\tused = count*2;\t\t\t\t\t\t\\\n\t\twhile (count > 0) {\t\t\t\t\t\\\n\t\t\tif (get_user(data, ptr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\tdata = convsample(data);\t\t\t\\\n\t\t\t*high++ = data>>8;\t\t\t\t\\\n\t\t\t*low++ = (data>>2) & 0x3f;\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tu_char *lefth = &frame[*frameUsed>>2];\t\t\t\\\n\t\tu_char *leftl = lefth+write_sq_block_size_quarter;\t\\\n\t\tu_char *righth = lefth+write_sq_block_size_half;\t\\\n\t\tu_char *rightl = righth+write_sq_block_size_quarter;\t\\\n\t\tcount = min_t(size_t, userCount, frameLeft)>>2 & ~1;\t\\\n\t\tused = count*4;\t\t\t\t\t\t\\\n\t\twhile (count > 0) {\t\t\t\t\t\\\n\t\t\tif (get_user(data, ptr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\tdata = convsample(data);\t\t\t\\\n\t\t\t*lefth++ = data>>8;\t\t\t\t\\\n\t\t\t*leftl++ = (data>>2) & 0x3f;\t\t\t\\\n\t\t\tif (get_user(data, ptr++))\t\t\t\\\n\t\t\t\treturn -EFAULT;\t\t\t\t\\\n\t\t\tdata = convsample(data);\t\t\t\\\n\t\t\t*righth++ = data>>8;\t\t\t\t\\\n\t\t\t*rightl++ = (data>>2) & 0x3f;\t\t\t\\\n\t\t\tcount--;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t*frameUsed += used;\t\t\t\t\t\t\\\n\treturn used;\t\t\t\t\t\t\t\\\n}\n\n#define AMI_CT_S16BE(x)\t(x)\n#define AMI_CT_U16BE(x)\t((x) ^ 0x8000)\n#define AMI_CT_S16LE(x)\t(le2be16((x)))\n#define AMI_CT_U16LE(x)\t(le2be16((x)) ^ 0x8000)\n\nGENERATE_AMI_CT_16(ami_ct_s16be, AMI_CT_S16BE)\nGENERATE_AMI_CT_16(ami_ct_u16be, AMI_CT_U16BE)\nGENERATE_AMI_CT_16(ami_ct_s16le, AMI_CT_S16LE)\nGENERATE_AMI_CT_16(ami_ct_u16le, AMI_CT_U16LE)\n\n\nstatic TRANS transAmiga = {\n\t.ct_ulaw\t= ami_ct_ulaw,\n\t.ct_alaw\t= ami_ct_alaw,\n\t.ct_s8\t\t= ami_ct_s8,\n\t.ct_u8\t\t= ami_ct_u8,\n\t.ct_s16be\t= ami_ct_s16be,\n\t.ct_u16be\t= ami_ct_u16be,\n\t.ct_s16le\t= ami_ct_s16le,\n\t.ct_u16le\t= ami_ct_u16le,\n};\n\n \n\nstatic inline void StopDMA(void)\n{\n\tcustom.aud[0].audvol = custom.aud[1].audvol = 0;\n\tcustom.aud[2].audvol = custom.aud[3].audvol = 0;\n\tcustom.dmacon = AMI_AUDIO_OFF;\n\tenable_heartbeat();\n}\n\nstatic void *AmiAlloc(unsigned int size, gfp_t flags)\n{\n\treturn amiga_chip_alloc((long)size, \"dmasound [Paula]\");\n}\n\nstatic void AmiFree(void *obj, unsigned int size)\n{\n\tamiga_chip_free (obj);\n}\n\nstatic int __init AmiIrqInit(void)\n{\n\t \n\tStopDMA();\n\n\t \n\tif (request_irq(IRQ_AMIGA_AUD0, AmiInterrupt, 0, \"DMA sound\",\n\t\t\tAmiInterrupt))\n\t\treturn 0;\n\treturn 1;\n}\n\n#ifdef MODULE\nstatic void AmiIrqCleanUp(void)\n{\n\t \n\tStopDMA();\n\t \n\tfree_irq(IRQ_AMIGA_AUD0, AmiInterrupt);\n}\n#endif  \n\nstatic void AmiSilence(void)\n{\n\t \n\tStopDMA();\n}\n\n\nstatic void AmiInit(void)\n{\n\tint period, i;\n\n\tAmiSilence();\n\n\tif (dmasound.soft.speed)\n\t\tperiod = amiga_colorclock/dmasound.soft.speed-1;\n\telse\n\t\tperiod = amiga_audio_min_period;\n\tdmasound.hard = dmasound.soft;\n\tdmasound.trans_write = &transAmiga;\n\n\tif (period < amiga_audio_min_period) {\n\t\t \n\t\tperiod = amiga_audio_min_period;\n\t} else if (period > 65535) {\n\t\tperiod = 65535;\n\t}\n\tdmasound.hard.speed = amiga_colorclock/(period+1);\n\n\tfor (i = 0; i < 4; i++)\n\t\tcustom.aud[i].audper = period;\n\tamiga_audio_period = period;\n}\n\n\nstatic int AmiSetFormat(int format)\n{\n\tint size;\n\n\t \n\n\tswitch (format) {\n\tcase AFMT_QUERY:\n\t\treturn dmasound.soft.format;\n\tcase AFMT_MU_LAW:\n\tcase AFMT_A_LAW:\n\tcase AFMT_U8:\n\tcase AFMT_S8:\n\t\tsize = 8;\n\t\tbreak;\n\tcase AFMT_S16_BE:\n\tcase AFMT_U16_BE:\n\tcase AFMT_S16_LE:\n\tcase AFMT_U16_LE:\n\t\tsize = 16;\n\t\tbreak;\n\tdefault:  \n\t\tsize = 8;\n\t\tformat = AFMT_S8;\n\t}\n\n\tdmasound.soft.format = format;\n\tdmasound.soft.size = size;\n\tif (dmasound.minDev == SND_DEV_DSP) {\n\t\tdmasound.dsp.format = format;\n\t\tdmasound.dsp.size = dmasound.soft.size;\n\t}\n\tAmiInit();\n\n\treturn format;\n}\n\n\n#define VOLUME_VOXWARE_TO_AMI(v) \\\n\t(((v) < 0) ? 0 : ((v) > 100) ? 64 : ((v) * 64)/100)\n#define VOLUME_AMI_TO_VOXWARE(v) ((v)*100/64)\n\nstatic int AmiSetVolume(int volume)\n{\n\tdmasound.volume_left = VOLUME_VOXWARE_TO_AMI(volume & 0xff);\n\tcustom.aud[0].audvol = dmasound.volume_left;\n\tdmasound.volume_right = VOLUME_VOXWARE_TO_AMI((volume & 0xff00) >> 8);\n\tcustom.aud[1].audvol = dmasound.volume_right;\n\tif (dmasound.hard.size == 16) {\n\t\tif (dmasound.volume_left == 64 && dmasound.volume_right == 64) {\n\t\t\tcustom.aud[2].audvol = 1;\n\t\t\tcustom.aud[3].audvol = 1;\n\t\t} else {\n\t\t\tcustom.aud[2].audvol = 0;\n\t\t\tcustom.aud[3].audvol = 0;\n\t\t}\n\t}\n\treturn VOLUME_AMI_TO_VOXWARE(dmasound.volume_left) |\n\t       (VOLUME_AMI_TO_VOXWARE(dmasound.volume_right) << 8);\n}\n\nstatic int AmiSetTreble(int treble)\n{\n\tdmasound.treble = treble;\n\tif (treble < 50)\n\t\tciaa.pra &= ~0x02;\n\telse\n\t\tciaa.pra |= 0x02;\n\treturn treble;\n}\n\n\n#define AMI_PLAY_LOADED\t\t1\n#define AMI_PLAY_PLAYING\t2\n#define AMI_PLAY_MASK\t\t3\n\n\nstatic void AmiPlayNextFrame(int index)\n{\n\tu_char *start, *ch0, *ch1, *ch2, *ch3;\n\tu_long size;\n\n\t \n\tstart = write_sq.buffers[write_sq.front];\n\tsize = (write_sq.count == index ? write_sq.rear_size\n\t\t\t\t\t: write_sq.block_size)>>1;\n\n\tif (dmasound.hard.stereo) {\n\t\tch0 = start;\n\t\tch1 = start+write_sq_block_size_half;\n\t\tsize >>= 1;\n\t} else {\n\t\tch0 = start;\n\t\tch1 = start;\n\t}\n\n\tdisable_heartbeat();\n\tcustom.aud[0].audvol = dmasound.volume_left;\n\tcustom.aud[1].audvol = dmasound.volume_right;\n\tif (dmasound.hard.size == 8) {\n\t\tcustom.aud[0].audlc = (u_short *)ZTWO_PADDR(ch0);\n\t\tcustom.aud[0].audlen = size;\n\t\tcustom.aud[1].audlc = (u_short *)ZTWO_PADDR(ch1);\n\t\tcustom.aud[1].audlen = size;\n\t\tcustom.dmacon = AMI_AUDIO_8;\n\t} else {\n\t\tsize >>= 1;\n\t\tcustom.aud[0].audlc = (u_short *)ZTWO_PADDR(ch0);\n\t\tcustom.aud[0].audlen = size;\n\t\tcustom.aud[1].audlc = (u_short *)ZTWO_PADDR(ch1);\n\t\tcustom.aud[1].audlen = size;\n\t\tif (dmasound.volume_left == 64 && dmasound.volume_right == 64) {\n\t\t\t \n\t\t\tch3 = ch0+write_sq_block_size_quarter;\n\t\t\tch2 = ch1+write_sq_block_size_quarter;\n\t\t\tcustom.aud[2].audvol = 1;   \n\t\t\tcustom.aud[3].audvol = 1;   \n\t\t\tcustom.aud[2].audlc = (u_short *)ZTWO_PADDR(ch2);\n\t\t\tcustom.aud[2].audlen = size;\n\t\t\tcustom.aud[3].audlc = (u_short *)ZTWO_PADDR(ch3);\n\t\t\tcustom.aud[3].audlen = size;\n\t\t\tcustom.dmacon = AMI_AUDIO_14;\n\t\t} else {\n\t\t\tcustom.aud[2].audvol = 0;\n\t\t\tcustom.aud[3].audvol = 0;\n\t\t\tcustom.dmacon = AMI_AUDIO_8;\n\t\t}\n\t}\n\twrite_sq.front = (write_sq.front+1) % write_sq.max_count;\n\twrite_sq.active |= AMI_PLAY_LOADED;\n}\n\n\nstatic void AmiPlay(void)\n{\n\tint minframes = 1;\n\n\tcustom.intena = IF_AUD0;\n\n\tif (write_sq.active & AMI_PLAY_LOADED) {\n\t\t \n\t\tcustom.intena = IF_SETCLR | IF_AUD0;\n\t\treturn;\n\t}\n\n\tif (write_sq.active & AMI_PLAY_PLAYING)\n\t\t \n\t\tminframes = 2;\n\n\tif (write_sq.count < minframes) {\n\t\t \n\t\tcustom.intena = IF_SETCLR | IF_AUD0;\n\t\treturn;\n\t}\n\n\tif (write_sq.count <= minframes &&\n\t    write_sq.rear_size < write_sq.block_size && !write_sq.syncing) {\n\t\t \n\t\tcustom.intena = IF_SETCLR | IF_AUD0;\n\t\treturn;\n\t}\n\n\tAmiPlayNextFrame(minframes);\n\n\tcustom.intena = IF_SETCLR | IF_AUD0;\n}\n\n\nstatic irqreturn_t AmiInterrupt(int irq, void *dummy)\n{\n\tint minframes = 1;\n\n\tcustom.intena = IF_AUD0;\n\n\tif (!write_sq.active) {\n\t\t \n\t\tWAKE_UP(write_sq.sync_queue);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (write_sq.active & AMI_PLAY_PLAYING) {\n\t\t \n\t\twrite_sq.count--;\n\t\tWAKE_UP(write_sq.action_queue);\n\t}\n\n\tif (write_sq.active & AMI_PLAY_LOADED)\n\t\t \n\t\tminframes = 2;\n\n\t \n\twrite_sq.active = (write_sq.active<<1) & AMI_PLAY_MASK;\n\n\tif (!write_sq.active)\n\t\t \n\t\tStopDMA();\n\n\tcustom.intena = IF_SETCLR | IF_AUD0;\n\n\tif (write_sq.count >= minframes)\n\t\t \n\t\tAmiPlay();\n\n\tif (!write_sq.active)\n\t\t \n\t\tWAKE_UP(write_sq.sync_queue);\n\treturn IRQ_HANDLED;\n}\n\n \n\n\n \n\nstatic void __init AmiMixerInit(void)\n{\n\tdmasound.volume_left = 64;\n\tdmasound.volume_right = 64;\n\tcustom.aud[0].audvol = dmasound.volume_left;\n\tcustom.aud[3].audvol = 1;\t \n\tcustom.aud[1].audvol = dmasound.volume_right;\n\tcustom.aud[2].audvol = 1;\t \n\tdmasound.treble = 50;\n}\n\nstatic int AmiMixerIoctl(u_int cmd, u_long arg)\n{\n\tint data;\n\tswitch (cmd) {\n\t    case SOUND_MIXER_READ_DEVMASK:\n\t\t    return IOCTL_OUT(arg, SOUND_MASK_VOLUME | SOUND_MASK_TREBLE);\n\t    case SOUND_MIXER_READ_RECMASK:\n\t\t    return IOCTL_OUT(arg, 0);\n\t    case SOUND_MIXER_READ_STEREODEVS:\n\t\t    return IOCTL_OUT(arg, SOUND_MASK_VOLUME);\n\t    case SOUND_MIXER_READ_VOLUME:\n\t\t    return IOCTL_OUT(arg,\n\t\t\t    VOLUME_AMI_TO_VOXWARE(dmasound.volume_left) |\n\t\t\t    VOLUME_AMI_TO_VOXWARE(dmasound.volume_right) << 8);\n\t    case SOUND_MIXER_WRITE_VOLUME:\n\t\t    IOCTL_IN(arg, data);\n\t\t    return IOCTL_OUT(arg, dmasound_set_volume(data));\n\t    case SOUND_MIXER_READ_TREBLE:\n\t\t    return IOCTL_OUT(arg, dmasound.treble);\n\t    case SOUND_MIXER_WRITE_TREBLE:\n\t\t    IOCTL_IN(arg, data);\n\t\t    return IOCTL_OUT(arg, dmasound_set_treble(data));\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic int AmiWriteSqSetup(void)\n{\n\twrite_sq_block_size_half = write_sq.block_size>>1;\n\twrite_sq_block_size_quarter = write_sq_block_size_half>>1;\n\treturn 0;\n}\n\n\nstatic int AmiStateInfo(char *buffer, size_t space)\n{\n\tint len = 0;\n\tlen += sprintf(buffer+len, \"\\tsound.volume_left = %d [0...64]\\n\",\n\t\t       dmasound.volume_left);\n\tlen += sprintf(buffer+len, \"\\tsound.volume_right = %d [0...64]\\n\",\n\t\t       dmasound.volume_right);\n\tif (len >= space) {\n\t\tprintk(KERN_ERR \"dmasound_paula: overflowed state buffer alloc.\\n\") ;\n\t\tlen = space ;\n\t}\n\treturn len;\n}\n\n\n \n\nstatic SETTINGS def_hard = {\n\t.format\t= AFMT_S8,\n\t.stereo\t= 0,\n\t.size\t= 8,\n\t.speed\t= 8000\n} ;\n\nstatic SETTINGS def_soft = {\n\t.format\t= AFMT_U8,\n\t.stereo\t= 0,\n\t.size\t= 8,\n\t.speed\t= 8000\n} ;\n\nstatic MACHINE machAmiga = {\n\t.name\t\t= \"Amiga\",\n\t.name2\t\t= \"AMIGA\",\n\t.owner\t\t= THIS_MODULE,\n\t.dma_alloc\t= AmiAlloc,\n\t.dma_free\t= AmiFree,\n\t.irqinit\t= AmiIrqInit,\n#ifdef MODULE\n\t.irqcleanup\t= AmiIrqCleanUp,\n#endif  \n\t.init\t\t= AmiInit,\n\t.silence\t= AmiSilence,\n\t.setFormat\t= AmiSetFormat,\n\t.setVolume\t= AmiSetVolume,\n\t.setTreble\t= AmiSetTreble,\n\t.play\t\t= AmiPlay,\n\t.mixer_init\t= AmiMixerInit,\n\t.mixer_ioctl\t= AmiMixerIoctl,\n\t.write_sq_setup\t= AmiWriteSqSetup,\n\t.state_info\t= AmiStateInfo,\n\t.min_dsp_speed\t= 8000,\n\t.version\t= ((DMASOUND_PAULA_REVISION<<8) | DMASOUND_PAULA_EDITION),\n\t.hardware_afmts\t= (AFMT_S8 | AFMT_S16_BE),  \n\t.capabilities\t= DSP_CAP_BATCH           \n};\n\n\n \n\n\nstatic int __init amiga_audio_probe(struct platform_device *pdev)\n{\n\tdmasound.mach = machAmiga;\n\tdmasound.mach.default_hard = def_hard ;\n\tdmasound.mach.default_soft = def_soft ;\n\treturn dmasound_init();\n}\n\nstatic int __exit amiga_audio_remove(struct platform_device *pdev)\n{\n\tdmasound_deinit();\n\treturn 0;\n}\n\nstatic struct platform_driver amiga_audio_driver = {\n\t.remove = __exit_p(amiga_audio_remove),\n\t.driver   = {\n\t\t.name\t= \"amiga-audio\",\n\t},\n};\n\nmodule_platform_driver_probe(amiga_audio_driver, amiga_audio_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:amiga-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}