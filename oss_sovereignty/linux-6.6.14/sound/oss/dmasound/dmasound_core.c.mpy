{
  "module_name": "dmasound_core.c",
  "hash_id": "0ed99bda2be74a06f3389d37e686521b0f4129a4a89f2069b032fcfab35ce5aa",
  "original_prompt": "Ingested from linux-6.6.14/sound/oss/dmasound/dmasound_core.c",
  "human_readable_source": " \n\n  \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sound.h>\n#include <linux/init.h>\n#include <linux/soundcard.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/sched/signal.h>\n\n#include <linux/uaccess.h>\n\n#include \"dmasound.h\"\n\n#define DMASOUND_CORE_REVISION 1\n#define DMASOUND_CORE_EDITION 6\n\n     \n\nstatic DEFINE_MUTEX(dmasound_core_mutex);\nint dmasound_catchRadius = 0;\nmodule_param(dmasound_catchRadius, int, 0);\n\nstatic unsigned int numWriteBufs = DEFAULT_N_BUFFERS;\nmodule_param(numWriteBufs, int, 0);\nstatic unsigned int writeBufSize = DEFAULT_BUFF_SIZE ;\t \nmodule_param(writeBufSize, int, 0);\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int sq_unit = -1;\nstatic int mixer_unit = -1;\nstatic int state_unit = -1;\nstatic int irq_installed;\n\n \nstatic fmode_t shared_resource_owner;\nstatic int shared_resources_initialised;\n\n     \n\nstruct sound_settings dmasound = {\n\t.lock = __SPIN_LOCK_UNLOCKED(dmasound.lock)\n};\n\nstatic inline void sound_silence(void)\n{\n\tdmasound.mach.silence();  \n}\n\nstatic inline int sound_set_format(int format)\n{\n\treturn dmasound.mach.setFormat(format);\n}\n\n\nstatic int sound_set_speed(int speed)\n{\n\tif (speed < 0)\n\t\treturn dmasound.soft.speed;\n\n\t \n\tif (dmasound.mach.max_dsp_speed &&\n\t   (speed > dmasound.mach.max_dsp_speed))\n\t\tspeed = dmasound.mach.max_dsp_speed ;\n\n\tdmasound.soft.speed = speed;\n\n\tif (dmasound.minDev == SND_DEV_DSP)\n\t\tdmasound.dsp.speed = dmasound.soft.speed;\n\n\treturn dmasound.soft.speed;\n}\n\nstatic int sound_set_stereo(int stereo)\n{\n\tif (stereo < 0)\n\t\treturn dmasound.soft.stereo;\n\n\tstereo = !!stereo;     \n\n\tdmasound.soft.stereo = stereo;\n\tif (dmasound.minDev == SND_DEV_DSP)\n\t\tdmasound.dsp.stereo = stereo;\n\n\treturn stereo;\n}\n\nstatic ssize_t sound_copy_translate(TRANS *trans, const u_char __user *userPtr,\n\t\t\t\t    size_t userCount, u_char frame[],\n\t\t\t\t    ssize_t *frameUsed, ssize_t frameLeft)\n{\n\tssize_t (*ct_func)(const u_char __user *, size_t, u_char *, ssize_t *, ssize_t);\n\n\tswitch (dmasound.soft.format) {\n\t    case AFMT_MU_LAW:\n\t\tct_func = trans->ct_ulaw;\n\t\tbreak;\n\t    case AFMT_A_LAW:\n\t\tct_func = trans->ct_alaw;\n\t\tbreak;\n\t    case AFMT_S8:\n\t\tct_func = trans->ct_s8;\n\t\tbreak;\n\t    case AFMT_U8:\n\t\tct_func = trans->ct_u8;\n\t\tbreak;\n\t    case AFMT_S16_BE:\n\t\tct_func = trans->ct_s16be;\n\t\tbreak;\n\t    case AFMT_U16_BE:\n\t\tct_func = trans->ct_u16be;\n\t\tbreak;\n\t    case AFMT_S16_LE:\n\t\tct_func = trans->ct_s16le;\n\t\tbreak;\n\t    case AFMT_U16_LE:\n\t\tct_func = trans->ct_u16le;\n\t\tbreak;\n\t    default:\n\t\treturn 0;\n\t}\n\t \n\tif (ct_func)\n\t\treturn ct_func(userPtr, userCount, frame, frameUsed, frameLeft);\n\treturn 0;\n}\n\n     \n\nstatic struct {\n    int busy;\n    int modify_counter;\n} mixer;\n\nstatic int mixer_open(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&dmasound_core_mutex);\n\tif (!try_module_get(dmasound.mach.owner)) {\n\t\tmutex_unlock(&dmasound_core_mutex);\n\t\treturn -ENODEV;\n\t}\n\tmixer.busy = 1;\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn 0;\n}\n\nstatic int mixer_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&dmasound_core_mutex);\n\tmixer.busy = 0;\n\tmodule_put(dmasound.mach.owner);\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn 0;\n}\n\nstatic int mixer_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tif (_SIOC_DIR(cmd) & _SIOC_WRITE)\n\t    mixer.modify_counter++;\n\tswitch (cmd) {\n\t    case OSS_GETVERSION:\n\t\treturn IOCTL_OUT(arg, SOUND_VERSION);\n\t    case SOUND_MIXER_INFO:\n\t\t{\n\t\t    mixer_info info;\n\t\t    memset(&info, 0, sizeof(info));\n\t\t    strscpy(info.id, dmasound.mach.name2, sizeof(info.id));\n\t\t    strscpy(info.name, dmasound.mach.name2, sizeof(info.name));\n\t\t    info.modify_counter = mixer.modify_counter;\n\t\t    if (copy_to_user((void __user *)arg, &info, sizeof(info)))\n\t\t\t    return -EFAULT;\n\t\t    return 0;\n\t\t}\n\t}\n\tif (dmasound.mach.mixer_ioctl)\n\t    return dmasound.mach.mixer_ioctl(cmd, arg);\n\treturn -EINVAL;\n}\n\nstatic long mixer_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tint ret;\n\n\tmutex_lock(&dmasound_core_mutex);\n\tret = mixer_ioctl(file, cmd, arg);\n\tmutex_unlock(&dmasound_core_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations mixer_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= mixer_unlocked_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= mixer_open,\n\t.release\t= mixer_release,\n};\n\nstatic void mixer_init(void)\n{\n\tmixer_unit = register_sound_mixer(&mixer_fops, -1);\n\tif (mixer_unit < 0)\n\t\treturn;\n\n\tmixer.busy = 0;\n\tdmasound.treble = 0;\n\tdmasound.bass = 0;\n\tif (dmasound.mach.mixer_init)\n\t    dmasound.mach.mixer_init();\n}\n\n\n     \n\nstruct sound_queue dmasound_write_sq;\nstatic void sq_reset_output(void) ;\n\nstatic int sq_allocate_buffers(struct sound_queue *sq, int num, int size)\n{\n\tint i;\n\n\tif (sq->buffers)\n\t\treturn 0;\n\tsq->numBufs = num;\n\tsq->bufSize = size;\n\tsq->buffers = kmalloc_array (num, sizeof(char *), GFP_KERNEL);\n\tif (!sq->buffers)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < num; i++) {\n\t\tsq->buffers[i] = dmasound.mach.dma_alloc(size, GFP_KERNEL);\n\t\tif (!sq->buffers[i]) {\n\t\t\twhile (i--)\n\t\t\t\tdmasound.mach.dma_free(sq->buffers[i], size);\n\t\t\tkfree(sq->buffers);\n\t\t\tsq->buffers = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sq_release_buffers(struct sound_queue *sq)\n{\n\tint i;\n\n\tif (sq->buffers) {\n\t\tfor (i = 0; i < sq->numBufs; i++)\n\t\t\tdmasound.mach.dma_free(sq->buffers[i], sq->bufSize);\n\t\tkfree(sq->buffers);\n\t\tsq->buffers = NULL;\n\t}\n}\n\n\nstatic int sq_setup(struct sound_queue *sq)\n{\n\tint (*setup_func)(void) = NULL;\n\tint hard_frame ;\n\n\tif (sq->locked) {  \n#ifdef DEBUG_DMASOUND\nprintk(\"dmasound_core: tried to sq_setup a locked queue\\n\") ;\n#endif\n\t\treturn -EINVAL ;\n\t}\n\tsq->locked = 1 ;  \n\n\t \n\n\tdmasound.mach.init();\n\n\t \n\n\tif (sq->user_frags <= 0) {\n\t\tsq->max_count = sq->numBufs ;\n\t\tsq->max_active = sq->numBufs ;\n\t\tsq->block_size = sq->bufSize;\n\t\t \n\t\tsq->user_frags = sq->numBufs ;\n\t\tsq->user_frag_size = sq->bufSize ;\n\t\tsq->user_frag_size *=\n\t\t\t(dmasound.soft.size * (dmasound.soft.stereo+1) ) ;\n\t\tsq->user_frag_size /=\n\t\t\t(dmasound.hard.size * (dmasound.hard.stereo+1) ) ;\n\t} else {\n\t\t \n\t\tsq->block_size = sq->user_frag_size ;\n\t\tsq->block_size *=\n\t\t\t(dmasound.hard.size * (dmasound.hard.stereo+1) ) ;\n\t\tsq->block_size /=\n\t\t\t(dmasound.soft.size * (dmasound.soft.stereo+1) ) ;\n\t\t \n\t\tsq->block_size *= dmasound.hard.speed ;\n\t\tsq->block_size /= dmasound.soft.speed ;\n\t\t \n\t\thard_frame =\n\t\t\t(dmasound.hard.size * (dmasound.hard.stereo+1))/8 ;\n\t\tsq->block_size +=  (hard_frame - 1) ;\n\t\tsq->block_size &= ~(hard_frame - 1) ;  \n\t\t \n\t\tif ( sq->block_size <= 0 || sq->block_size > sq->bufSize) {\n#ifdef DEBUG_DMASOUND\nprintk(\"dmasound_core: invalid frag size (user set %d)\\n\", sq->user_frag_size) ;\n#endif\n\t\t\tsq->block_size = sq->bufSize ;\n\t\t}\n\t\tif ( sq->user_frags <= sq->numBufs ) {\n\t\t\tsq->max_count = sq->user_frags ;\n\t\t\t \n\t\t\tsq->max_active = (sq->max_active <= sq->max_count) ?\n\t\t\t\tsq->max_active : sq->max_count ;\n\t\t} else {\n#ifdef DEBUG_DMASOUND\nprintk(\"dmasound_core: invalid frag count (user set %d)\\n\", sq->user_frags) ;\n#endif\n\t\t\tsq->max_count =\n\t\t\tsq->max_active = sq->numBufs ;\n\t\t}\n\t}\n\tsq->front = sq->count = sq->rear_size = 0;\n\tsq->syncing = 0;\n\tsq->active = 0;\n\n\tif (sq == &write_sq) {\n\t    sq->rear = -1;\n\t    setup_func = dmasound.mach.write_sq_setup;\n\t}\n\tif (setup_func)\n\t    return setup_func();\n\treturn 0 ;\n}\n\nstatic inline void sq_play(void)\n{\n\tdmasound.mach.play();\n}\n\nstatic ssize_t sq_write(struct file *file, const char __user *src, size_t uLeft,\n\t\t\tloff_t *ppos)\n{\n\tssize_t uWritten = 0;\n\tu_char *dest;\n\tssize_t uUsed = 0, bUsed, bLeft;\n\tunsigned long flags ;\n\n\t \n\tif (uLeft == 0)\n\t\treturn 0;\n\n\t \n\n\tif (shared_resources_initialised == 0) {\n\t\tdmasound.mach.init() ;\n\t\tshared_resources_initialised = 1 ;\n\t}\n\n\t \n\n\tif (write_sq.locked == 0) {\n\t\tif ((uWritten = sq_setup(&write_sq)) < 0) return uWritten ;\n\t\tuWritten = 0 ;\n\t}\n\n \n\t \n\n\t \n\n\tspin_lock_irqsave(&dmasound.lock, flags);\n\twrite_sq.syncing &= ~2 ;  \n\tspin_unlock_irqrestore(&dmasound.lock, flags);\n\n\tif (write_sq.count > 0 &&\n\t    (bLeft = write_sq.block_size-write_sq.rear_size) > 0) {\n\t\tdest = write_sq.buffers[write_sq.rear];\n\t\tbUsed = write_sq.rear_size;\n\t\tuUsed = sound_copy_translate(dmasound.trans_write, src, uLeft,\n\t\t\t\t\t     dest, &bUsed, bLeft);\n\t\tif (uUsed <= 0)\n\t\t\treturn uUsed;\n\t\tsrc += uUsed;\n\t\tuWritten += uUsed;\n\t\tuLeft = (uUsed <= uLeft) ? (uLeft - uUsed) : 0 ;  \n\t\twrite_sq.rear_size = bUsed;\n\t}\n\n\twhile (uLeft) {\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (write_sq.count >= write_sq.max_active) {\n\t\t\tprepare_to_wait(&write_sq.action_queue, &wait, TASK_INTERRUPTIBLE);\n\t\t\tsq_play();\n\t\t\tif (write_sq.non_blocking) {\n\t\t\t\tfinish_wait(&write_sq.action_queue, &wait);\n\t\t\t\treturn uWritten > 0 ? uWritten : -EAGAIN;\n\t\t\t}\n\t\t\tif (write_sq.count < write_sq.max_active)\n\t\t\t\tbreak;\n\n\t\t\tschedule_timeout(HZ);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tfinish_wait(&write_sq.action_queue, &wait);\n\t\t\t\treturn uWritten > 0 ? uWritten : -EINTR;\n\t\t\t}\n\t\t}\n\n\t\tfinish_wait(&write_sq.action_queue, &wait);\n\n\t\t \n\n\t\tdest = write_sq.buffers[(write_sq.rear+1) % write_sq.max_count];\n\t\tbUsed = 0;\n\t\tbLeft = write_sq.block_size;\n\t\tuUsed = sound_copy_translate(dmasound.trans_write, src, uLeft,\n\t\t\t\t\t     dest, &bUsed, bLeft);\n\t\tif (uUsed <= 0)\n\t\t\tbreak;\n\t\tsrc += uUsed;\n\t\tuWritten += uUsed;\n\t\tuLeft = (uUsed <= uLeft) ? (uLeft - uUsed) : 0 ;  \n\t\tif (bUsed) {\n\t\t\twrite_sq.rear = (write_sq.rear+1) % write_sq.max_count;\n\t\t\twrite_sq.rear_size = bUsed;\n\t\t\twrite_sq.count++;\n\t\t}\n\t}  \n\n\tsq_play();\n\n\treturn uUsed < 0? uUsed: uWritten;\n}\n\nstatic __poll_t sq_poll(struct file *file, struct poll_table_struct *wait)\n{\n\t__poll_t mask = 0;\n\tint retVal;\n\t\n\tif (write_sq.locked == 0) {\n\t\tif ((retVal = sq_setup(&write_sq)) < 0)\n\t\t\treturn retVal;\n\t\treturn 0;\n\t}\n\tif (file->f_mode & FMODE_WRITE )\n\t\tpoll_wait(file, &write_sq.action_queue, wait);\n\tif (file->f_mode & FMODE_WRITE)\n\t\tif (write_sq.count < write_sq.max_active || write_sq.block_size - write_sq.rear_size > 0)\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n\n}\n\nstatic inline void sq_init_waitqueue(struct sound_queue *sq)\n{\n\tinit_waitqueue_head(&sq->action_queue);\n\tinit_waitqueue_head(&sq->open_queue);\n\tinit_waitqueue_head(&sq->sync_queue);\n\tsq->busy = 0;\n}\n\n#if 0  \nstatic inline void sq_wake_up(struct sound_queue *sq, struct file *file,\n\t\t\t      fmode_t mode)\n{\n\tif (file->f_mode & mode) {\n\t\tsq->busy = 0;  \n\t\tWAKE_UP(sq->open_queue);\n\t}\n}\n#endif\n\nstatic int sq_open2(struct sound_queue *sq, struct file *file, fmode_t mode,\n\t\t    int numbufs, int bufsize)\n{\n\tint rc = 0;\n\n\tif (file->f_mode & mode) {\n\t\tif (sq->busy) {\n#if 0  \n\t\t\trc = -EBUSY;\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn rc;\n\t\t\trc = -EINTR;\n\t\t\tif (wait_event_interruptible(sq->open_queue, !sq->busy))\n\t\t\t\treturn rc;\n\t\t\trc = 0;\n#else\n\t\t\t \n\t\t\treturn -EBUSY ;\n#endif\n\t\t}\n\t\tsq->busy = 1;  \n\n\t\t \n\t\tif (( rc = sq_allocate_buffers(sq, numbufs, bufsize))) {\n#if 0  \n\t\t\tsq_wake_up(sq, file, mode);\n#else\n\t\t\tsq->busy = 0 ;\n#endif\n\t\t\treturn rc;\n\t\t}\n\n\t\tsq->non_blocking = file->f_flags & O_NONBLOCK;\n\t}\n\treturn rc;\n}\n\n#define write_sq_init_waitqueue()\tsq_init_waitqueue(&write_sq)\n#if 0  \n#define write_sq_wake_up(file)\t\tsq_wake_up(&write_sq, file, FMODE_WRITE)\n#endif\n#define write_sq_release_buffers()\tsq_release_buffers(&write_sq)\n#define write_sq_open(file)\t\\\n\tsq_open2(&write_sq, file, FMODE_WRITE, numWriteBufs, writeBufSize )\n\nstatic int sq_open(struct inode *inode, struct file *file)\n{\n\tint rc;\n\n\tmutex_lock(&dmasound_core_mutex);\n\tif (!try_module_get(dmasound.mach.owner)) {\n\t\tmutex_unlock(&dmasound_core_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\trc = write_sq_open(file);  \n\tif (rc)\n\t\tgoto out;\n\tif (file->f_mode & FMODE_READ) {\n\t\t \n\t\trc = -ENXIO ;  \n\t\tgoto out;\n\t}\n\n\tif (dmasound.mach.sq_open)\n\t    dmasound.mach.sq_open(file->f_mode);\n\n\t \n\n\tdmasound.minDev = iminor(inode) & 0x0f;\n\n\t \n\n\tif (shared_resource_owner == 0) {\n\t\t \n\t\tdmasound.soft = dmasound.mach.default_soft ;\n\t\tdmasound.dsp = dmasound.mach.default_soft ;\n\t\tdmasound.hard = dmasound.mach.default_hard ;\n\t}\n\n#ifndef DMASOUND_STRICT_OSS_COMPLIANCE\n\t \n\tif (dmasound.minDev == SND_DEV_AUDIO) {\n\t\tsound_set_speed(8000);\n\t\tsound_set_stereo(0);\n\t\tsound_set_format(AFMT_MU_LAW);\n\t}\n#endif\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn 0;\n out:\n\tmodule_put(dmasound.mach.owner);\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn rc;\n}\n\nstatic void sq_reset_output(void)\n{\n\tsound_silence();  \n\twrite_sq.active = 0;\n\twrite_sq.count = 0;\n\twrite_sq.rear_size = 0;\n\t \n\twrite_sq.front = 0 ;\n\twrite_sq.rear = -1 ;  \n\n\t \n\twrite_sq.locked = 0 ;\n\twrite_sq.user_frags = 0 ;\n\twrite_sq.user_frag_size = 0 ;\n}\n\nstatic void sq_reset(void)\n{\n\tsq_reset_output() ;\n\t \n\n\t \n\tshared_resources_initialised = 0 ;\n}\n\nstatic int sq_fsync(void)\n{\n\tint rc = 0;\n\tint timeout = 5;\n\n\twrite_sq.syncing |= 1;\n\tsq_play();\t \n\n\twhile (write_sq.active) {\n\t\twait_event_interruptible_timeout(write_sq.sync_queue,\n\t\t\t\t\t\t !write_sq.active, HZ);\n\t\tif (signal_pending(current)) {\n\t\t\t \n\t\t\tsq_reset_output();\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (!--timeout) {\n\t\t\tprintk(KERN_WARNING \"dmasound: Timeout draining output\\n\");\n\t\t\tsq_reset_output();\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twrite_sq.syncing = 0 ;\n\treturn rc;\n}\n\nstatic int sq_release(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\n\tmutex_lock(&dmasound_core_mutex);\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (write_sq.busy)\n\t\t\trc = sq_fsync();\n\n\t\tsq_reset_output() ;  \n\t\twrite_sq_release_buffers();\n\t\twrite_sq.busy = 0;\n\t}\n\n\tif (file->f_mode & shared_resource_owner) {  \n\t\tshared_resource_owner = 0 ;\n\t\tshared_resources_initialised = 0 ;\n\t\tdmasound.hard = dmasound.mach.default_hard ;\n\t}\n\n\tmodule_put(dmasound.mach.owner);\n\n#if 0  \n\t \n\n\t \n\t \n\t \n\tread_sq_wake_up(file);  \n\twrite_sq_wake_up(file);  \n#endif  \n\n\tmutex_unlock(&dmasound_core_mutex);\n\n\treturn rc;\n}\n\n \n\nstatic int shared_resources_are_mine(fmode_t md)\n{\n\tif (shared_resource_owner)\n\t\treturn (shared_resource_owner & md) != 0;\n\telse {\n\t\tshared_resource_owner = md ;\n\t\treturn 1 ;\n\t}\n}\n\n \n\nstatic int queues_are_quiescent(void)\n{\n\tif (write_sq.locked)\n\t\treturn 0 ;\n\treturn 1 ;\n}\n\n \n\n \n\nstatic int set_queue_frags(struct sound_queue *sq, int bufs, int size)\n{\n\tif (sq->locked) {\n#ifdef DEBUG_DMASOUND\nprintk(\"dmasound_core: tried to set_queue_frags on a locked queue\\n\") ;\n#endif\n\t\treturn -EINVAL ;\n\t}\n\n\tif ((size < MIN_FRAG_SIZE) || (size > MAX_FRAG_SIZE))\n\t\treturn -EINVAL ;\n\tsize = (1<<size) ;  \n\tif (size > sq->bufSize)\n\t\treturn -EINVAL ;  \n\n\tif (bufs <= 0)\n\t\treturn -EINVAL ;\n\tif (bufs > sq->numBufs)  \n\t\tbufs = sq->numBufs ;\n\n\t \n\tsq->user_frags =\n\tsq->max_active = bufs ;\n\tsq->user_frag_size = size ;\n\n\treturn 0 ;\n}\n\nstatic int sq_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tint val, result;\n\tu_long fmt;\n\tint data;\n\tint size, nbufs;\n\taudio_buf_info info;\n\n\tswitch (cmd) {\n\tcase SNDCTL_DSP_RESET:\n\t\tsq_reset();\n\t\treturn 0;\n\tcase SNDCTL_DSP_GETFMTS:\n\t\tfmt = dmasound.mach.hardware_afmts ;  \n\t\treturn IOCTL_OUT(arg, fmt);\n\tcase SNDCTL_DSP_GETBLKSIZE:\n\t\t \n\t\tsize = 0 ;\n\t\tif (file->f_mode & FMODE_WRITE) {\n\t\t\tif ( !write_sq.locked )\n\t\t\t\tsq_setup(&write_sq) ;\n\t\t\tsize = write_sq.user_frag_size ;\n\t\t}\n\t\treturn IOCTL_OUT(arg, size);\n\tcase SNDCTL_DSP_POST:\n\t\t \n\t\twrite_sq.syncing |= 0x2 ;\n\t\tsq_play() ;\n\t\treturn 0 ;\n\tcase SNDCTL_DSP_SYNC:\n\t\t \n\t\tresult = 0 ;\n\t\tif (file->f_mode & FMODE_WRITE) {\n\t\t\tresult = sq_fsync();\n\t\t\tsq_reset_output() ;\n\t\t}\n\t\t \n\t\tif (file->f_mode & shared_resource_owner)\n\t\t\tshared_resources_initialised = 0 ;\n\t\treturn result ;\n\tcase SOUND_PCM_READ_RATE:\n\t\treturn IOCTL_OUT(arg, dmasound.soft.speed);\n\tcase SNDCTL_DSP_SPEED:\n\t\t \n\t\tif (shared_resources_are_mine(file->f_mode)) {\n\t\t\tIOCTL_IN(arg, data);\n\t\t\tdata = sound_set_speed(data) ;\n\t\t\tshared_resources_initialised = 0 ;\n\t\t\treturn IOCTL_OUT(arg, data);\n\t\t} else\n\t\t\treturn -EINVAL ;\n\t\tbreak ;\n\t \n\tcase SNDCTL_DSP_STEREO:\n\t\tif (shared_resources_are_mine(file->f_mode) &&\n\t\t    queues_are_quiescent()) {\n\t\t\tIOCTL_IN(arg, data);\n\t\t\tshared_resources_initialised = 0 ;\n\t\t\treturn IOCTL_OUT(arg, sound_set_stereo(data));\n\t\t} else\n\t\t\treturn -EINVAL ;\n\t\tbreak ;\n\tcase SOUND_PCM_WRITE_CHANNELS:\n\t\tif (shared_resources_are_mine(file->f_mode) &&\n\t\t    queues_are_quiescent()) {\n\t\t\tIOCTL_IN(arg, data);\n\t\t\t \n\t\t\tshared_resources_initialised = 0 ;\n\t\t\treturn IOCTL_OUT(arg, sound_set_stereo(data-1)+1);\n\t\t} else\n\t\t\treturn -EINVAL ;\n\t\tbreak ;\n\tcase SNDCTL_DSP_SETFMT:\n\t\tif (shared_resources_are_mine(file->f_mode) &&\n\t\t    queues_are_quiescent()) {\n\t\t    \tint format;\n\t\t\tIOCTL_IN(arg, data);\n\t\t\tshared_resources_initialised = 0 ;\n\t\t\tformat = sound_set_format(data);\n\t\t\tresult = IOCTL_OUT(arg, format);\n\t\t\tif (result < 0)\n\t\t\t\treturn result;\n\t\t\tif (format != data && data != AFMT_QUERY)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn -EINVAL ;\n\tcase SNDCTL_DSP_SUBDIVIDE:\n\t\treturn -EINVAL ;\n\tcase SNDCTL_DSP_SETFRAGMENT:\n\t\t \n\t\tIOCTL_IN(arg, data);\n\t\tresult = 0 ;\n\t\tnbufs = (data >> 16) & 0x7fff ;  \n\t\tsize = data & 0xffff;\n\t\tif (file->f_mode & FMODE_WRITE) {\n\t\t\tresult = set_queue_frags(&write_sq, nbufs, size) ;\n\t\t\tif (result)\n\t\t\t\treturn result ;\n\t\t}\n\t\t \n\t\treturn IOCTL_OUT(arg, data);\n\tcase SNDCTL_DSP_GETOSPACE:\n\t\t \n\t\tif (file->f_mode & FMODE_WRITE) {\n\t\t\tif ( !write_sq.locked )\n\t\t\t\tsq_setup(&write_sq) ;\n\t\t\tinfo.fragments = write_sq.max_active - write_sq.count;\n\t\t\tinfo.fragstotal = write_sq.max_active;\n\t\t\tinfo.fragsize = write_sq.user_frag_size;\n\t\t\tinfo.bytes = info.fragments * info.fragsize;\n\t\t\tif (copy_to_user((void __user *)arg, &info, sizeof(info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn -EINVAL ;\n\t\tbreak ;\n\tcase SNDCTL_DSP_GETCAPS:\n\t\tval = dmasound.mach.capabilities & 0xffffff00;\n\t\treturn IOCTL_OUT(arg,val);\n\n\tdefault:\n\t\treturn mixer_ioctl(file, cmd, arg);\n\t}\n\treturn -EINVAL;\n}\n\nstatic long sq_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tint ret;\n\n\tmutex_lock(&dmasound_core_mutex);\n\tret = sq_ioctl(file, cmd, arg);\n\tmutex_unlock(&dmasound_core_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations sq_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= sq_write,\n\t.poll\t\t= sq_poll,\n\t.unlocked_ioctl\t= sq_unlocked_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= sq_open,\n\t.release\t= sq_release,\n};\n\nstatic int sq_init(void)\n{\n\tconst struct file_operations *fops = &sq_fops;\n\n\tsq_unit = register_sound_dsp(fops, -1);\n\tif (sq_unit < 0) {\n\t\tprintk(KERN_ERR \"dmasound_core: couldn't register fops\\n\") ;\n\t\treturn sq_unit ;\n\t}\n\n\twrite_sq_init_waitqueue();\n\n\t \n\n\tif (shared_resource_owner == 0) {\n\t\tdmasound.soft = dmasound.mach.default_soft ;\n\t\tdmasound.hard = dmasound.mach.default_hard ;\n\t\tdmasound.dsp = dmasound.mach.default_soft ;\n\t\tshared_resources_initialised = 0 ;\n\t}\n\treturn 0 ;\n}\n\n\n     \n\n \n\n#define STAT_BUFF_LEN 768\n\n \n\n#define LOW_LEVEL_STAT_ALLOC 162\n\nstatic struct {\n    int busy;\n    char buf[STAT_BUFF_LEN];\t \n    int len, ptr;\n} state;\n\n \n\nstatic char *get_afmt_string(int afmt)\n{\n        switch(afmt) {\n            case AFMT_MU_LAW:\n                return \"mu-law\";\n            case AFMT_A_LAW:\n                return \"A-law\";\n            case AFMT_U8:\n                return \"unsigned 8 bit\";\n            case AFMT_S8:\n                return \"signed 8 bit\";\n            case AFMT_S16_BE:\n                return \"signed 16 bit BE\";\n            case AFMT_U16_BE:\n                return \"unsigned 16 bit BE\";\n            case AFMT_S16_LE:\n                return \"signed 16 bit LE\";\n            case AFMT_U16_LE:\n                return \"unsigned 16 bit LE\";\n\t    case 0:\n\t\treturn \"format not set\" ;\n            default:\n                break ;\n        }\n        return \"ERROR: Unsupported AFMT_XXXX code\" ;\n}\n\nstatic int state_open(struct inode *inode, struct file *file)\n{\n\tchar *buffer = state.buf;\n\tint len = 0;\n\tint ret;\n\n\tmutex_lock(&dmasound_core_mutex);\n\tret = -EBUSY;\n\tif (state.busy)\n\t\tgoto out;\n\n\tret = -ENODEV;\n\tif (!try_module_get(dmasound.mach.owner))\n\t\tgoto out;\n\n\tstate.ptr = 0;\n\tstate.busy = 1;\n\n\tlen += sprintf(buffer+len, \"%sDMA sound driver rev %03d :\\n\",\n\t\tdmasound.mach.name, (DMASOUND_CORE_REVISION<<4) +\n\t\t((dmasound.mach.version>>8) & 0x0f));\n\tlen += sprintf(buffer+len,\n\t\t\"Core driver edition %02d.%02d : %s driver edition %02d.%02d\\n\",\n\t\tDMASOUND_CORE_REVISION, DMASOUND_CORE_EDITION, dmasound.mach.name2,\n\t\t(dmasound.mach.version >> 8), (dmasound.mach.version & 0xff)) ;\n\n\t \n\n\tif (dmasound.mach.state_info)\n\t\tlen += dmasound.mach.state_info(buffer+len,\n\t\t\t(size_t) LOW_LEVEL_STAT_ALLOC) ;\n\n\t \n\n\t \n\n\tlen += sprintf(buffer+len,\"\\t\\t === Formats & settings ===\\n\") ;\n\tlen += sprintf(buffer+len,\"Parameter %20s%20s\\n\",\"soft\",\"hard\") ;\n\tlen += sprintf(buffer+len,\"Format   :%20s%20s\\n\",\n\t\tget_afmt_string(dmasound.soft.format),\n\t\tget_afmt_string(dmasound.hard.format));\n\n\tlen += sprintf(buffer+len,\"Samp Rate:%14d s/sec%14d s/sec\\n\",\n\t\t       dmasound.soft.speed, dmasound.hard.speed);\n\n\tlen += sprintf(buffer+len,\"Channels :%20s%20s\\n\",\n\t\t       dmasound.soft.stereo ? \"stereo\" : \"mono\",\n\t\t       dmasound.hard.stereo ? \"stereo\" : \"mono\" );\n\n\t \n\n\tlen += sprintf(buffer+len,\"\\t\\t === Sound Queue status ===\\n\");\n\tlen += sprintf(buffer+len,\"Allocated:%8s%6s\\n\",\"Buffers\",\"Size\") ;\n\tlen += sprintf(buffer+len,\"%9s:%8d%6d\\n\",\n\t\t\"write\", write_sq.numBufs, write_sq.bufSize) ;\n\tlen += sprintf(buffer+len,\n\t\t\"Current  : MaxFrg FragSiz MaxAct Frnt Rear \"\n\t\t\"Cnt RrSize A B S L  xruns\\n\") ;\n\tlen += sprintf(buffer+len,\"%9s:%7d%8d%7d%5d%5d%4d%7d%2d%2d%2d%2d%7d\\n\",\n\t\t\"write\", write_sq.max_count, write_sq.block_size,\n\t\twrite_sq.max_active, write_sq.front, write_sq.rear,\n\t\twrite_sq.count, write_sq.rear_size, write_sq.active,\n\t\twrite_sq.busy, write_sq.syncing, write_sq.locked, write_sq.xruns) ;\n#ifdef DEBUG_DMASOUND\nprintk(\"dmasound: stat buffer used %d bytes\\n\", len) ;\n#endif\n\n\tif (len >= STAT_BUFF_LEN)\n\t\tprintk(KERN_ERR \"dmasound_core: stat buffer overflowed!\\n\");\n\n\tstate.len = len;\n\tret = 0;\nout:\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn ret;\n}\n\nstatic int state_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&dmasound_core_mutex);\n\tstate.busy = 0;\n\tmodule_put(dmasound.mach.owner);\n\tmutex_unlock(&dmasound_core_mutex);\n\treturn 0;\n}\n\nstatic ssize_t state_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tint n = state.len - state.ptr;\n\tif (n > count)\n\t\tn = count;\n\tif (n <= 0)\n\t\treturn 0;\n\tif (copy_to_user(buf, &state.buf[state.ptr], n))\n\t\treturn -EFAULT;\n\tstate.ptr += n;\n\treturn n;\n}\n\nstatic const struct file_operations state_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= state_read,\n\t.open\t\t= state_open,\n\t.release\t= state_release,\n};\n\nstatic int state_init(void)\n{\n\tstate_unit = register_sound_special(&state_fops, SND_DEV_STATUS);\n\tif (state_unit < 0)\n\t\treturn state_unit ;\n\tstate.busy = 0;\n\treturn 0 ;\n}\n\n\n     \n\nint dmasound_init(void)\n{\n\tint res ;\n\n\tif (irq_installed)\n\t\treturn -EBUSY;\n\n\t \n\n\t \n\tif ((res = sq_init()) < 0)\n\t\treturn res ;\n\n\t \n\tif ((res = state_init()) < 0)\n\t\treturn res ;\n\n\t \n\tmixer_init();\n\n\tif (!dmasound.mach.irqinit()) {\n\t\tprintk(KERN_ERR \"DMA sound driver: Interrupt initialization failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tirq_installed = 1;\n\n\tprintk(KERN_INFO \"%s DMA sound driver rev %03d installed\\n\",\n\t\tdmasound.mach.name, (DMASOUND_CORE_REVISION<<4) +\n\t\t((dmasound.mach.version>>8) & 0x0f));\n\tprintk(KERN_INFO\n\t\t\"Core driver edition %02d.%02d : %s driver edition %02d.%02d\\n\",\n\t\tDMASOUND_CORE_REVISION, DMASOUND_CORE_EDITION, dmasound.mach.name2,\n\t\t(dmasound.mach.version >> 8), (dmasound.mach.version & 0xff)) ;\n\tprintk(KERN_INFO \"Write will use %4d fragments of %7d bytes as default\\n\",\n\t\tnumWriteBufs, writeBufSize) ;\n\treturn 0;\n}\n\nvoid dmasound_deinit(void)\n{\n\tif (irq_installed) {\n\t\tsound_silence();\n\t\tdmasound.mach.irqcleanup();\n\t\tirq_installed = 0;\n\t}\n\n\twrite_sq_release_buffers();\n\n\tif (mixer_unit >= 0)\n\t\tunregister_sound_mixer(mixer_unit);\n\tif (state_unit >= 0)\n\t\tunregister_sound_special(state_unit);\n\tif (sq_unit >= 0)\n\t\tunregister_sound_dsp(sq_unit);\n}\n\nstatic int __maybe_unused dmasound_setup(char *str)\n{\n\tint ints[6], size;\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\n\t \n\n\t \n\n\tswitch (ints[0]) {\n\tcase 3:\n\t\tif ((ints[3] < 0) || (ints[3] > MAX_CATCH_RADIUS))\n\t\t\tprintk(\"dmasound_setup: invalid catch radius, using default = %d\\n\", catchRadius);\n\t\telse\n\t\t\tcatchRadius = ints[3];\n\t\tfallthrough;\n\tcase 2:\n\t\tif (ints[1] < MIN_BUFFERS)\n\t\t\tprintk(\"dmasound_setup: invalid number of buffers, using default = %d\\n\", numWriteBufs);\n\t\telse\n\t\t\tnumWriteBufs = ints[1];\n\t\tfallthrough;\n\tcase 1:\n\t\tif ((size = ints[2]) < 256)  \n\t\t\tsize <<= 10 ;\n                if (size < MIN_BUFSIZE || size > MAX_BUFSIZE)\n                        printk(\"dmasound_setup: invalid write buffer size, using default = %d\\n\", writeBufSize);\n                else\n                        writeBufSize = size;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"dmasound_setup: invalid number of arguments\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n__setup(\"dmasound=\", dmasound_setup);\n\n     \n\n#ifdef HAS_8BIT_TABLES\n \n\nchar dmasound_ulaw2dma8[] = {\n\t-126,\t-122,\t-118,\t-114,\t-110,\t-106,\t-102,\t-98,\n\t-94,\t-90,\t-86,\t-82,\t-78,\t-74,\t-70,\t-66,\n\t-63,\t-61,\t-59,\t-57,\t-55,\t-53,\t-51,\t-49,\n\t-47,\t-45,\t-43,\t-41,\t-39,\t-37,\t-35,\t-33,\n\t-31,\t-30,\t-29,\t-28,\t-27,\t-26,\t-25,\t-24,\n\t-23,\t-22,\t-21,\t-20,\t-19,\t-18,\t-17,\t-16,\n\t-16,\t-15,\t-15,\t-14,\t-14,\t-13,\t-13,\t-12,\n\t-12,\t-11,\t-11,\t-10,\t-10,\t-9,\t-9,\t-8,\n\t-8,\t-8,\t-7,\t-7,\t-7,\t-7,\t-6,\t-6,\n\t-6,\t-6,\t-5,\t-5,\t-5,\t-5,\t-4,\t-4,\n\t-4,\t-4,\t-4,\t-4,\t-3,\t-3,\t-3,\t-3,\n\t-3,\t-3,\t-3,\t-3,\t-2,\t-2,\t-2,\t-2,\n\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t0,\n\t125,\t121,\t117,\t113,\t109,\t105,\t101,\t97,\n\t93,\t89,\t85,\t81,\t77,\t73,\t69,\t65,\n\t62,\t60,\t58,\t56,\t54,\t52,\t50,\t48,\n\t46,\t44,\t42,\t40,\t38,\t36,\t34,\t32,\n\t30,\t29,\t28,\t27,\t26,\t25,\t24,\t23,\n\t22,\t21,\t20,\t19,\t18,\t17,\t16,\t15,\n\t15,\t14,\t14,\t13,\t13,\t12,\t12,\t11,\n\t11,\t10,\t10,\t9,\t9,\t8,\t8,\t7,\n\t7,\t7,\t6,\t6,\t6,\t6,\t5,\t5,\n\t5,\t5,\t4,\t4,\t4,\t4,\t3,\t3,\n\t3,\t3,\t3,\t3,\t2,\t2,\t2,\t2,\n\t2,\t2,\t2,\t2,\t1,\t1,\t1,\t1,\n\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0\n};\n\n \n\nchar dmasound_alaw2dma8[] = {\n\t-22,\t-21,\t-24,\t-23,\t-18,\t-17,\t-20,\t-19,\n\t-30,\t-29,\t-32,\t-31,\t-26,\t-25,\t-28,\t-27,\n\t-11,\t-11,\t-12,\t-12,\t-9,\t-9,\t-10,\t-10,\n\t-15,\t-15,\t-16,\t-16,\t-13,\t-13,\t-14,\t-14,\n\t-86,\t-82,\t-94,\t-90,\t-70,\t-66,\t-78,\t-74,\n\t-118,\t-114,\t-126,\t-122,\t-102,\t-98,\t-110,\t-106,\n\t-43,\t-41,\t-47,\t-45,\t-35,\t-33,\t-39,\t-37,\n\t-59,\t-57,\t-63,\t-61,\t-51,\t-49,\t-55,\t-53,\n\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\n\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\t-2,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\n\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\n\t-6,\t-6,\t-6,\t-6,\t-5,\t-5,\t-5,\t-5,\n\t-8,\t-8,\t-8,\t-8,\t-7,\t-7,\t-7,\t-7,\n\t-3,\t-3,\t-3,\t-3,\t-3,\t-3,\t-3,\t-3,\n\t-4,\t-4,\t-4,\t-4,\t-4,\t-4,\t-4,\t-4,\n\t21,\t20,\t23,\t22,\t17,\t16,\t19,\t18,\n\t29,\t28,\t31,\t30,\t25,\t24,\t27,\t26,\n\t10,\t10,\t11,\t11,\t8,\t8,\t9,\t9,\n\t14,\t14,\t15,\t15,\t12,\t12,\t13,\t13,\n\t86,\t82,\t94,\t90,\t70,\t66,\t78,\t74,\n\t118,\t114,\t126,\t122,\t102,\t98,\t110,\t106,\n\t43,\t41,\t47,\t45,\t35,\t33,\t39,\t37,\n\t59,\t57,\t63,\t61,\t51,\t49,\t55,\t53,\n\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\n\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\n\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\n\t5,\t5,\t5,\t5,\t4,\t4,\t4,\t4,\n\t7,\t7,\t7,\t7,\t6,\t6,\t6,\t6,\n\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\n\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3\n};\n#endif  \n\n     \n\nEXPORT_SYMBOL(dmasound);\nEXPORT_SYMBOL(dmasound_init);\nEXPORT_SYMBOL(dmasound_deinit);\nEXPORT_SYMBOL(dmasound_write_sq);\nEXPORT_SYMBOL(dmasound_catchRadius);\n#ifdef HAS_8BIT_TABLES\nEXPORT_SYMBOL(dmasound_ulaw2dma8);\nEXPORT_SYMBOL(dmasound_alaw2dma8);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}