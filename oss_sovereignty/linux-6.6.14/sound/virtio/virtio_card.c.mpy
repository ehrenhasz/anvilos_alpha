{
  "module_name": "virtio_card.c",
  "hash_id": "3353493ba0754bb750938f656f9599fda7edceba975a4c9492922a4e6572b1ea",
  "original_prompt": "Ingested from linux-6.6.14/sound/virtio/virtio_card.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/virtio_config.h>\n#include <sound/initval.h>\n#include <uapi/linux/virtio_ids.h>\n\n#include \"virtio_card.h\"\n\nu32 virtsnd_msg_timeout_ms = MSEC_PER_SEC;\nmodule_param_named(msg_timeout_ms, virtsnd_msg_timeout_ms, uint, 0644);\nMODULE_PARM_DESC(msg_timeout_ms, \"Message completion timeout in milliseconds\");\n\nstatic void virtsnd_remove(struct virtio_device *vdev);\n\n \nstatic void virtsnd_event_send(struct virtqueue *vqueue,\n\t\t\t       struct virtio_snd_event *event, bool notify,\n\t\t\t       gfp_t gfp)\n{\n\tstruct scatterlist sg;\n\tstruct scatterlist *psgs[1] = { &sg };\n\n\t \n\tmemset(event, 0, sizeof(*event));\n\n\tsg_init_one(&sg, event, sizeof(*event));\n\n\tif (virtqueue_add_sgs(vqueue, psgs, 0, 1, event, gfp) || !notify)\n\t\treturn;\n\n\tif (virtqueue_kick_prepare(vqueue))\n\t\tvirtqueue_notify(vqueue);\n}\n\n \nstatic void virtsnd_event_dispatch(struct virtio_snd *snd,\n\t\t\t\t   struct virtio_snd_event *event)\n{\n\tswitch (le32_to_cpu(event->hdr.code)) {\n\tcase VIRTIO_SND_EVT_JACK_CONNECTED:\n\tcase VIRTIO_SND_EVT_JACK_DISCONNECTED:\n\t\tvirtsnd_jack_event(snd, event);\n\t\tbreak;\n\tcase VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED:\n\tcase VIRTIO_SND_EVT_PCM_XRUN:\n\t\tvirtsnd_pcm_event(snd, event);\n\t\tbreak;\n\t}\n}\n\n \nstatic void virtsnd_event_notify_cb(struct virtqueue *vqueue)\n{\n\tstruct virtio_snd *snd = vqueue->vdev->priv;\n\tstruct virtio_snd_queue *queue = virtsnd_event_queue(snd);\n\tstruct virtio_snd_event *event;\n\tu32 length;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tdo {\n\t\tvirtqueue_disable_cb(vqueue);\n\t\twhile ((event = virtqueue_get_buf(vqueue, &length))) {\n\t\t\tvirtsnd_event_dispatch(snd, event);\n\t\t\tvirtsnd_event_send(vqueue, event, true, GFP_ATOMIC);\n\t\t}\n\t\tif (unlikely(virtqueue_is_broken(vqueue)))\n\t\t\tbreak;\n\t} while (!virtqueue_enable_cb(vqueue));\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n\n \nstatic int virtsnd_find_vqs(struct virtio_snd *snd)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstatic vq_callback_t *callbacks[VIRTIO_SND_VQ_MAX] = {\n\t\t[VIRTIO_SND_VQ_CONTROL] = virtsnd_ctl_notify_cb,\n\t\t[VIRTIO_SND_VQ_EVENT] = virtsnd_event_notify_cb,\n\t\t[VIRTIO_SND_VQ_TX] = virtsnd_pcm_tx_notify_cb,\n\t\t[VIRTIO_SND_VQ_RX] = virtsnd_pcm_rx_notify_cb\n\t};\n\tstatic const char *names[VIRTIO_SND_VQ_MAX] = {\n\t\t[VIRTIO_SND_VQ_CONTROL] = \"virtsnd-ctl\",\n\t\t[VIRTIO_SND_VQ_EVENT] = \"virtsnd-event\",\n\t\t[VIRTIO_SND_VQ_TX] = \"virtsnd-tx\",\n\t\t[VIRTIO_SND_VQ_RX] = \"virtsnd-rx\"\n\t};\n\tstruct virtqueue *vqs[VIRTIO_SND_VQ_MAX] = { 0 };\n\tunsigned int i;\n\tunsigned int n;\n\tint rc;\n\n\trc = virtio_find_vqs(vdev, VIRTIO_SND_VQ_MAX, vqs, callbacks, names,\n\t\t\t     NULL);\n\tif (rc) {\n\t\tdev_err(&vdev->dev, \"failed to initialize virtqueues\\n\");\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < VIRTIO_SND_VQ_MAX; ++i)\n\t\tsnd->queues[i].vqueue = vqs[i];\n\n\t \n\tvirtqueue_disable_cb(vqs[VIRTIO_SND_VQ_EVENT]);\n\n\tn = virtqueue_get_vring_size(vqs[VIRTIO_SND_VQ_EVENT]);\n\n\tsnd->event_msgs = kmalloc_array(n, sizeof(*snd->event_msgs),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!snd->event_msgs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; ++i)\n\t\tvirtsnd_event_send(vqs[VIRTIO_SND_VQ_EVENT],\n\t\t\t\t   &snd->event_msgs[i], false, GFP_KERNEL);\n\n\treturn 0;\n}\n\n \nstatic void virtsnd_enable_event_vq(struct virtio_snd *snd)\n{\n\tstruct virtio_snd_queue *queue = virtsnd_event_queue(snd);\n\n\tif (!virtqueue_enable_cb(queue->vqueue))\n\t\tvirtsnd_event_notify_cb(queue->vqueue);\n}\n\n \nstatic void virtsnd_disable_event_vq(struct virtio_snd *snd)\n{\n\tstruct virtio_snd_queue *queue = virtsnd_event_queue(snd);\n\tstruct virtio_snd_event *event;\n\tu32 length;\n\tunsigned long flags;\n\n\tif (queue->vqueue) {\n\t\tspin_lock_irqsave(&queue->lock, flags);\n\t\tvirtqueue_disable_cb(queue->vqueue);\n\t\twhile ((event = virtqueue_get_buf(queue->vqueue, &length)))\n\t\t\tvirtsnd_event_dispatch(snd, event);\n\t\tspin_unlock_irqrestore(&queue->lock, flags);\n\t}\n}\n\n \nstatic int virtsnd_build_devs(struct virtio_snd *snd)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct device *dev = &vdev->dev;\n\tint rc;\n\n\trc = snd_card_new(dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t  THIS_MODULE, 0, &snd->card);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsnd->card->private_data = snd;\n\n\tstrscpy(snd->card->driver, VIRTIO_SND_CARD_DRIVER,\n\t\tsizeof(snd->card->driver));\n\tstrscpy(snd->card->shortname, VIRTIO_SND_CARD_NAME,\n\t\tsizeof(snd->card->shortname));\n\tif (dev->parent->bus)\n\t\tsnprintf(snd->card->longname, sizeof(snd->card->longname),\n\t\t\t VIRTIO_SND_CARD_NAME \" at %s/%s/%s\",\n\t\t\t dev->parent->bus->name, dev_name(dev->parent),\n\t\t\t dev_name(dev));\n\telse\n\t\tsnprintf(snd->card->longname, sizeof(snd->card->longname),\n\t\t\t VIRTIO_SND_CARD_NAME \" at %s/%s\",\n\t\t\t dev_name(dev->parent), dev_name(dev));\n\n\trc = virtsnd_jack_parse_cfg(snd);\n\tif (rc)\n\t\treturn rc;\n\n\trc = virtsnd_pcm_parse_cfg(snd);\n\tif (rc)\n\t\treturn rc;\n\n\trc = virtsnd_chmap_parse_cfg(snd);\n\tif (rc)\n\t\treturn rc;\n\n\tif (snd->njacks) {\n\t\trc = virtsnd_jack_build_devs(snd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (snd->nsubstreams) {\n\t\trc = virtsnd_pcm_build_devs(snd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (snd->nchmaps) {\n\t\trc = virtsnd_chmap_build_devs(snd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn snd_card_register(snd->card);\n}\n\n \nstatic int virtsnd_validate(struct virtio_device *vdev)\n{\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"configuration access disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"device does not comply with spec version 1.x\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!virtsnd_msg_timeout_ms) {\n\t\tdev_err(&vdev->dev, \"msg_timeout_ms value cannot be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (virtsnd_pcm_validate(vdev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int virtsnd_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_snd *snd;\n\tunsigned int i;\n\tint rc;\n\n\tsnd = devm_kzalloc(&vdev->dev, sizeof(*snd), GFP_KERNEL);\n\tif (!snd)\n\t\treturn -ENOMEM;\n\n\tsnd->vdev = vdev;\n\tINIT_LIST_HEAD(&snd->ctl_msgs);\n\tINIT_LIST_HEAD(&snd->pcm_list);\n\n\tvdev->priv = snd;\n\n\tfor (i = 0; i < VIRTIO_SND_VQ_MAX; ++i)\n\t\tspin_lock_init(&snd->queues[i].lock);\n\n\trc = virtsnd_find_vqs(snd);\n\tif (rc)\n\t\tgoto on_exit;\n\n\tvirtio_device_ready(vdev);\n\n\trc = virtsnd_build_devs(snd);\n\tif (rc)\n\t\tgoto on_exit;\n\n\tvirtsnd_enable_event_vq(snd);\n\non_exit:\n\tif (rc)\n\t\tvirtsnd_remove(vdev);\n\n\treturn rc;\n}\n\n \nstatic void virtsnd_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_snd *snd = vdev->priv;\n\tunsigned int i;\n\n\tvirtsnd_disable_event_vq(snd);\n\tvirtsnd_ctl_msg_cancel_all(snd);\n\n\tif (snd->card)\n\t\tsnd_card_free(snd->card);\n\n\tvdev->config->del_vqs(vdev);\n\tvirtio_reset_device(vdev);\n\n\tfor (i = 0; snd->substreams && i < snd->nsubstreams; ++i) {\n\t\tstruct virtio_pcm_substream *vss = &snd->substreams[i];\n\n\t\tcancel_work_sync(&vss->elapsed_period);\n\t\tvirtsnd_pcm_msg_free(vss);\n\t}\n\n\tkfree(snd->event_msgs);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int virtsnd_freeze(struct virtio_device *vdev)\n{\n\tstruct virtio_snd *snd = vdev->priv;\n\tunsigned int i;\n\n\tvirtsnd_disable_event_vq(snd);\n\tvirtsnd_ctl_msg_cancel_all(snd);\n\n\tvdev->config->del_vqs(vdev);\n\tvirtio_reset_device(vdev);\n\n\tfor (i = 0; i < snd->nsubstreams; ++i)\n\t\tcancel_work_sync(&snd->substreams[i].elapsed_period);\n\n\tkfree(snd->event_msgs);\n\tsnd->event_msgs = NULL;\n\n\treturn 0;\n}\n\n \nstatic int virtsnd_restore(struct virtio_device *vdev)\n{\n\tstruct virtio_snd *snd = vdev->priv;\n\tint rc;\n\n\trc = virtsnd_find_vqs(snd);\n\tif (rc)\n\t\treturn rc;\n\n\tvirtio_device_ready(vdev);\n\n\tvirtsnd_enable_event_vq(snd);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_SOUND, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic struct virtio_driver virtsnd_driver = {\n\t.driver.name = KBUILD_MODNAME,\n\t.driver.owner = THIS_MODULE,\n\t.id_table = id_table,\n\t.validate = virtsnd_validate,\n\t.probe = virtsnd_probe,\n\t.remove = virtsnd_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze = virtsnd_freeze,\n\t.restore = virtsnd_restore,\n#endif\n};\n\nmodule_virtio_driver(virtsnd_driver);\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio sound card driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}