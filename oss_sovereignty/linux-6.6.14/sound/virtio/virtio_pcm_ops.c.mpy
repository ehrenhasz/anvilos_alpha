{
  "module_name": "virtio_pcm_ops.c",
  "hash_id": "13208267ad1dea5d895a3087148223c99b079cbb84dfef93896715bace443fe6",
  "original_prompt": "Ingested from linux-6.6.14/sound/virtio/virtio_pcm_ops.c",
  "human_readable_source": "\n \n#include <sound/pcm_params.h>\n\n#include \"virtio_card.h\"\n\n \n\n \nstruct virtsnd_a2v_format {\n\tsnd_pcm_format_t alsa_bit;\n\tunsigned int vio_bit;\n};\n\nstatic const struct virtsnd_a2v_format g_a2v_format_map[] = {\n\t{ SNDRV_PCM_FORMAT_IMA_ADPCM, VIRTIO_SND_PCM_FMT_IMA_ADPCM },\n\t{ SNDRV_PCM_FORMAT_MU_LAW, VIRTIO_SND_PCM_FMT_MU_LAW },\n\t{ SNDRV_PCM_FORMAT_A_LAW, VIRTIO_SND_PCM_FMT_A_LAW },\n\t{ SNDRV_PCM_FORMAT_S8, VIRTIO_SND_PCM_FMT_S8 },\n\t{ SNDRV_PCM_FORMAT_U8, VIRTIO_SND_PCM_FMT_U8 },\n\t{ SNDRV_PCM_FORMAT_S16_LE, VIRTIO_SND_PCM_FMT_S16 },\n\t{ SNDRV_PCM_FORMAT_U16_LE, VIRTIO_SND_PCM_FMT_U16 },\n\t{ SNDRV_PCM_FORMAT_S18_3LE, VIRTIO_SND_PCM_FMT_S18_3 },\n\t{ SNDRV_PCM_FORMAT_U18_3LE, VIRTIO_SND_PCM_FMT_U18_3 },\n\t{ SNDRV_PCM_FORMAT_S20_3LE, VIRTIO_SND_PCM_FMT_S20_3 },\n\t{ SNDRV_PCM_FORMAT_U20_3LE, VIRTIO_SND_PCM_FMT_U20_3 },\n\t{ SNDRV_PCM_FORMAT_S24_3LE, VIRTIO_SND_PCM_FMT_S24_3 },\n\t{ SNDRV_PCM_FORMAT_U24_3LE, VIRTIO_SND_PCM_FMT_U24_3 },\n\t{ SNDRV_PCM_FORMAT_S20_LE, VIRTIO_SND_PCM_FMT_S20 },\n\t{ SNDRV_PCM_FORMAT_U20_LE, VIRTIO_SND_PCM_FMT_U20 },\n\t{ SNDRV_PCM_FORMAT_S24_LE, VIRTIO_SND_PCM_FMT_S24 },\n\t{ SNDRV_PCM_FORMAT_U24_LE, VIRTIO_SND_PCM_FMT_U24 },\n\t{ SNDRV_PCM_FORMAT_S32_LE, VIRTIO_SND_PCM_FMT_S32 },\n\t{ SNDRV_PCM_FORMAT_U32_LE, VIRTIO_SND_PCM_FMT_U32 },\n\t{ SNDRV_PCM_FORMAT_FLOAT_LE, VIRTIO_SND_PCM_FMT_FLOAT },\n\t{ SNDRV_PCM_FORMAT_FLOAT64_LE, VIRTIO_SND_PCM_FMT_FLOAT64 },\n\t{ SNDRV_PCM_FORMAT_DSD_U8, VIRTIO_SND_PCM_FMT_DSD_U8 },\n\t{ SNDRV_PCM_FORMAT_DSD_U16_LE, VIRTIO_SND_PCM_FMT_DSD_U16 },\n\t{ SNDRV_PCM_FORMAT_DSD_U32_LE, VIRTIO_SND_PCM_FMT_DSD_U32 },\n\t{ SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE,\n\t  VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME }\n};\n\n \nstruct virtsnd_a2v_rate {\n\tunsigned int rate;\n\tunsigned int vio_bit;\n};\n\nstatic const struct virtsnd_a2v_rate g_a2v_rate_map[] = {\n\t{ 5512, VIRTIO_SND_PCM_RATE_5512 },\n\t{ 8000, VIRTIO_SND_PCM_RATE_8000 },\n\t{ 11025, VIRTIO_SND_PCM_RATE_11025 },\n\t{ 16000, VIRTIO_SND_PCM_RATE_16000 },\n\t{ 22050, VIRTIO_SND_PCM_RATE_22050 },\n\t{ 32000, VIRTIO_SND_PCM_RATE_32000 },\n\t{ 44100, VIRTIO_SND_PCM_RATE_44100 },\n\t{ 48000, VIRTIO_SND_PCM_RATE_48000 },\n\t{ 64000, VIRTIO_SND_PCM_RATE_64000 },\n\t{ 88200, VIRTIO_SND_PCM_RATE_88200 },\n\t{ 96000, VIRTIO_SND_PCM_RATE_96000 },\n\t{ 176400, VIRTIO_SND_PCM_RATE_176400 },\n\t{ 192000, VIRTIO_SND_PCM_RATE_192000 }\n};\n\nstatic int virtsnd_pcm_sync_stop(struct snd_pcm_substream *substream);\n\n \nstatic int virtsnd_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct virtio_pcm *vpcm = snd_pcm_substream_chip(substream);\n\tstruct virtio_pcm_stream *vs = &vpcm->streams[substream->stream];\n\tstruct virtio_pcm_substream *vss = vs->substreams[substream->number];\n\n\tsubstream->runtime->hw = vss->hw;\n\tsubstream->private_data = vss;\n\n\tsnd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t      SNDRV_PCM_HW_PARAM_PERIODS);\n\n\tvss->stopped = !!virtsnd_pcm_msg_pending_num(vss);\n\tvss->suspended = false;\n\n\t \n\treturn virtsnd_pcm_sync_stop(substream);\n}\n\n \nstatic int virtsnd_pcm_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int virtsnd_pcm_dev_set_params(struct virtio_pcm_substream *vss,\n\t\t\t\t      unsigned int buffer_bytes,\n\t\t\t\t      unsigned int period_bytes,\n\t\t\t\t      unsigned int channels,\n\t\t\t\t      snd_pcm_format_t format,\n\t\t\t\t      unsigned int rate)\n{\n\tstruct virtio_snd_msg *msg;\n\tstruct virtio_snd_pcm_set_params *request;\n\tunsigned int i;\n\tint vformat = -1;\n\tint vrate = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_a2v_format_map); ++i)\n\t\tif (g_a2v_format_map[i].alsa_bit == format) {\n\t\t\tvformat = g_a2v_format_map[i].vio_bit;\n\n\t\t\tbreak;\n\t\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(g_a2v_rate_map); ++i)\n\t\tif (g_a2v_rate_map[i].rate == rate) {\n\t\t\tvrate = g_a2v_rate_map[i].vio_bit;\n\n\t\t\tbreak;\n\t\t}\n\n\tif (vformat == -1 || vrate == -1)\n\t\treturn -EINVAL;\n\n\tmsg = virtsnd_pcm_ctl_msg_alloc(vss, VIRTIO_SND_R_PCM_SET_PARAMS,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\trequest = virtsnd_ctl_msg_request(msg);\n\trequest->buffer_bytes = cpu_to_le32(buffer_bytes);\n\trequest->period_bytes = cpu_to_le32(period_bytes);\n\trequest->channels = channels;\n\trequest->format = vformat;\n\trequest->rate = vrate;\n\n\tif (vss->features & (1U << VIRTIO_SND_PCM_F_MSG_POLLING))\n\t\trequest->features |=\n\t\t\tcpu_to_le32(1U << VIRTIO_SND_PCM_F_MSG_POLLING);\n\n\tif (vss->features & (1U << VIRTIO_SND_PCM_F_EVT_XRUNS))\n\t\trequest->features |=\n\t\t\tcpu_to_le32(1U << VIRTIO_SND_PCM_F_EVT_XRUNS);\n\n\treturn virtsnd_ctl_msg_send_sync(vss->snd, msg);\n}\n\n \nstatic int virtsnd_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\tstruct virtio_device *vdev = vss->snd->vdev;\n\tint rc;\n\n\tif (virtsnd_pcm_msg_pending_num(vss)) {\n\t\tdev_err(&vdev->dev, \"SID %u: invalid I/O queue state\\n\",\n\t\t\tvss->sid);\n\t\treturn -EBADFD;\n\t}\n\n\trc = virtsnd_pcm_dev_set_params(vss, params_buffer_bytes(hw_params),\n\t\t\t\t\tparams_period_bytes(hw_params),\n\t\t\t\t\tparams_channels(hw_params),\n\t\t\t\t\tparams_format(hw_params),\n\t\t\t\t\tparams_rate(hw_params));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tvirtsnd_pcm_msg_free(vss);\n\n\treturn virtsnd_pcm_msg_alloc(vss, params_periods(hw_params),\n\t\t\t\t     params_period_bytes(hw_params));\n}\n\n \nstatic int virtsnd_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\n\t \n\tif (!virtsnd_pcm_msg_pending_num(vss))\n\t\tvirtsnd_pcm_msg_free(vss);\n\n\treturn 0;\n}\n\n \nstatic int virtsnd_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\tstruct virtio_device *vdev = vss->snd->vdev;\n\tstruct virtio_snd_msg *msg;\n\n\tif (!vss->suspended) {\n\t\tif (virtsnd_pcm_msg_pending_num(vss)) {\n\t\t\tdev_err(&vdev->dev, \"SID %u: invalid I/O queue state\\n\",\n\t\t\t\tvss->sid);\n\t\t\treturn -EBADFD;\n\t\t}\n\n\t\tvss->buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\t\tvss->hw_ptr = 0;\n\t\tvss->msg_last_enqueued = -1;\n\t} else {\n\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\tunsigned int buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\t\tunsigned int period_bytes = snd_pcm_lib_period_bytes(substream);\n\t\tint rc;\n\n\t\trc = virtsnd_pcm_dev_set_params(vss, buffer_bytes, period_bytes,\n\t\t\t\t\t\truntime->channels,\n\t\t\t\t\t\truntime->format, runtime->rate);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tvss->xfer_xrun = false;\n\tvss->suspended = false;\n\tvss->msg_count = 0;\n\n\tmsg = virtsnd_pcm_ctl_msg_alloc(vss, VIRTIO_SND_R_PCM_PREPARE,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\treturn virtsnd_ctl_msg_send_sync(vss->snd, msg);\n}\n\n \nstatic int virtsnd_pcm_trigger(struct snd_pcm_substream *substream, int command)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\tstruct virtio_snd *snd = vss->snd;\n\tstruct virtio_snd_queue *queue;\n\tstruct virtio_snd_msg *msg;\n\tunsigned long flags;\n\tint rc;\n\n\tswitch (command) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tqueue = virtsnd_pcm_queue(vss);\n\n\t\tspin_lock_irqsave(&queue->lock, flags);\n\t\tspin_lock(&vss->lock);\n\t\trc = virtsnd_pcm_msg_send(vss);\n\t\tif (!rc)\n\t\t\tvss->xfer_enabled = true;\n\t\tspin_unlock(&vss->lock);\n\t\tspin_unlock_irqrestore(&queue->lock, flags);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tmsg = virtsnd_pcm_ctl_msg_alloc(vss, VIRTIO_SND_R_PCM_START,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!msg) {\n\t\t\tspin_lock_irqsave(&vss->lock, flags);\n\t\t\tvss->xfer_enabled = false;\n\t\t\tspin_unlock_irqrestore(&vss->lock, flags);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\treturn virtsnd_ctl_msg_send_sync(snd, msg);\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tvss->suspended = true;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tvss->stopped = true;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&vss->lock, flags);\n\t\tvss->xfer_enabled = false;\n\t\tspin_unlock_irqrestore(&vss->lock, flags);\n\n\t\tmsg = virtsnd_pcm_ctl_msg_alloc(vss, VIRTIO_SND_R_PCM_STOP,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\treturn virtsnd_ctl_msg_send_sync(snd, msg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int virtsnd_pcm_sync_stop(struct snd_pcm_substream *substream)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\tstruct virtio_snd *snd = vss->snd;\n\tstruct virtio_snd_msg *msg;\n\tunsigned int js = msecs_to_jiffies(virtsnd_msg_timeout_ms);\n\tint rc;\n\n\tcancel_work_sync(&vss->elapsed_period);\n\n\tif (!vss->stopped)\n\t\treturn 0;\n\n\tmsg = virtsnd_pcm_ctl_msg_alloc(vss, VIRTIO_SND_R_PCM_RELEASE,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\trc = virtsnd_ctl_msg_send_sync(snd, msg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = wait_event_interruptible_timeout(vss->msg_empty,\n\t\t\t\t\t      !virtsnd_pcm_msg_pending_num(vss),\n\t\t\t\t\t      js);\n\tif (rc <= 0) {\n\t\tdev_warn(&snd->vdev->dev, \"SID %u: failed to flush I/O queue\\n\",\n\t\t\t vss->sid);\n\n\t\treturn !rc ? -ETIMEDOUT : rc;\n\t}\n\n\tvss->stopped = false;\n\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t\nvirtsnd_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct virtio_pcm_substream *vss = snd_pcm_substream_chip(substream);\n\tsnd_pcm_uframes_t hw_ptr = SNDRV_PCM_POS_XRUN;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vss->lock, flags);\n\tif (!vss->xfer_xrun)\n\t\thw_ptr = bytes_to_frames(substream->runtime, vss->hw_ptr);\n\tspin_unlock_irqrestore(&vss->lock, flags);\n\n\treturn hw_ptr;\n}\n\n \nconst struct snd_pcm_ops virtsnd_pcm_ops = {\n\t.open = virtsnd_pcm_open,\n\t.close = virtsnd_pcm_close,\n\t.ioctl = snd_pcm_lib_ioctl,\n\t.hw_params = virtsnd_pcm_hw_params,\n\t.hw_free = virtsnd_pcm_hw_free,\n\t.prepare = virtsnd_pcm_prepare,\n\t.trigger = virtsnd_pcm_trigger,\n\t.sync_stop = virtsnd_pcm_sync_stop,\n\t.pointer = virtsnd_pcm_pointer,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}