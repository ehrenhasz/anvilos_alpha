{
  "module_name": "virtio_pcm_msg.c",
  "hash_id": "28da512369d9030fbc2313239d454df277e8b69e66fe52d87542fa6f819d22cd",
  "original_prompt": "Ingested from linux-6.6.14/sound/virtio/virtio_pcm_msg.c",
  "human_readable_source": "\n \n#include <sound/pcm_params.h>\n\n#include \"virtio_card.h\"\n\n \nstruct virtio_pcm_msg {\n\tstruct virtio_pcm_substream *substream;\n\tstruct virtio_snd_pcm_xfer xfer;\n\tstruct virtio_snd_pcm_status status;\n\tsize_t length;\n\tstruct scatterlist sgs[];\n};\n\n \nenum pcm_msg_sg_index {\n\tPCM_MSG_SG_XFER = 0,\n\tPCM_MSG_SG_STATUS,\n\tPCM_MSG_SG_DATA\n};\n\n \nstatic int virtsnd_pcm_sg_num(u8 *data, unsigned int length)\n{\n\tphys_addr_t sg_address;\n\tunsigned int sg_length;\n\tint num = 0;\n\n\twhile (length) {\n\t\tstruct page *pg = vmalloc_to_page(data);\n\t\tphys_addr_t pg_address = page_to_phys(pg);\n\t\tsize_t pg_length;\n\n\t\tpg_length = PAGE_SIZE - offset_in_page(data);\n\t\tif (pg_length > length)\n\t\t\tpg_length = length;\n\n\t\tif (!num || sg_address + sg_length != pg_address) {\n\t\t\tsg_address = pg_address;\n\t\t\tsg_length = pg_length;\n\t\t\tnum++;\n\t\t} else {\n\t\t\tsg_length += pg_length;\n\t\t}\n\n\t\tdata += pg_length;\n\t\tlength -= pg_length;\n\t}\n\n\treturn num;\n}\n\n \nstatic void virtsnd_pcm_sg_from(struct scatterlist *sgs, int nsgs, u8 *data,\n\t\t\t\tunsigned int length)\n{\n\tint idx = -1;\n\n\twhile (length) {\n\t\tstruct page *pg = vmalloc_to_page(data);\n\t\tsize_t pg_length;\n\n\t\tpg_length = PAGE_SIZE - offset_in_page(data);\n\t\tif (pg_length > length)\n\t\t\tpg_length = length;\n\n\t\tif (idx == -1 ||\n\t\t    sg_phys(&sgs[idx]) + sgs[idx].length != page_to_phys(pg)) {\n\t\t\tif (idx + 1 == nsgs)\n\t\t\t\tbreak;\n\t\t\tsg_set_page(&sgs[++idx], pg, pg_length,\n\t\t\t\t    offset_in_page(data));\n\t\t} else {\n\t\t\tsgs[idx].length += pg_length;\n\t\t}\n\n\t\tdata += pg_length;\n\t\tlength -= pg_length;\n\t}\n\n\tsg_mark_end(&sgs[idx]);\n}\n\n \nint virtsnd_pcm_msg_alloc(struct virtio_pcm_substream *vss,\n\t\t\t  unsigned int periods, unsigned int period_bytes)\n{\n\tstruct snd_pcm_runtime *runtime = vss->substream->runtime;\n\tunsigned int i;\n\n\tvss->msgs = kcalloc(periods, sizeof(*vss->msgs), GFP_KERNEL);\n\tif (!vss->msgs)\n\t\treturn -ENOMEM;\n\n\tvss->nmsgs = periods;\n\n\tfor (i = 0; i < periods; ++i) {\n\t\tu8 *data = runtime->dma_area + period_bytes * i;\n\t\tint sg_num = virtsnd_pcm_sg_num(data, period_bytes);\n\t\tstruct virtio_pcm_msg *msg;\n\n\t\tmsg = kzalloc(struct_size(msg, sgs, sg_num + 2), GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\tmsg->substream = vss;\n\t\tsg_init_one(&msg->sgs[PCM_MSG_SG_XFER], &msg->xfer,\n\t\t\t    sizeof(msg->xfer));\n\t\tsg_init_one(&msg->sgs[PCM_MSG_SG_STATUS], &msg->status,\n\t\t\t    sizeof(msg->status));\n\t\tmsg->length = period_bytes;\n\t\tvirtsnd_pcm_sg_from(&msg->sgs[PCM_MSG_SG_DATA], sg_num, data,\n\t\t\t\t    period_bytes);\n\n\t\tvss->msgs[i] = msg;\n\t}\n\n\treturn 0;\n}\n\n \nvoid virtsnd_pcm_msg_free(struct virtio_pcm_substream *vss)\n{\n\tunsigned int i;\n\n\tfor (i = 0; vss->msgs && i < vss->nmsgs; ++i)\n\t\tkfree(vss->msgs[i]);\n\tkfree(vss->msgs);\n\n\tvss->msgs = NULL;\n\tvss->nmsgs = 0;\n}\n\n \nint virtsnd_pcm_msg_send(struct virtio_pcm_substream *vss)\n{\n\tstruct snd_pcm_runtime *runtime = vss->substream->runtime;\n\tstruct virtio_snd *snd = vss->snd;\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct virtqueue *vqueue = virtsnd_pcm_queue(vss)->vqueue;\n\tint i;\n\tint n;\n\tbool notify = false;\n\n\ti = (vss->msg_last_enqueued + 1) % runtime->periods;\n\tn = runtime->periods - vss->msg_count;\n\n\tfor (; n; --n, i = (i + 1) % runtime->periods) {\n\t\tstruct virtio_pcm_msg *msg = vss->msgs[i];\n\t\tstruct scatterlist *psgs[] = {\n\t\t\t&msg->sgs[PCM_MSG_SG_XFER],\n\t\t\t&msg->sgs[PCM_MSG_SG_DATA],\n\t\t\t&msg->sgs[PCM_MSG_SG_STATUS]\n\t\t};\n\t\tint rc;\n\n\t\tmsg->xfer.stream_id = cpu_to_le32(vss->sid);\n\t\tmemset(&msg->status, 0, sizeof(msg->status));\n\n\t\tif (vss->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trc = virtqueue_add_sgs(vqueue, psgs, 2, 1, msg,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\telse\n\t\t\trc = virtqueue_add_sgs(vqueue, psgs, 1, 2, msg,\n\t\t\t\t\t       GFP_ATOMIC);\n\n\t\tif (rc) {\n\t\t\tdev_err(&vdev->dev,\n\t\t\t\t\"SID %u: failed to send I/O message\\n\",\n\t\t\t\tvss->sid);\n\t\t\treturn rc;\n\t\t}\n\n\t\tvss->msg_last_enqueued = i;\n\t\tvss->msg_count++;\n\t}\n\n\tif (!(vss->features & (1U << VIRTIO_SND_PCM_F_MSG_POLLING)))\n\t\tnotify = virtqueue_kick_prepare(vqueue);\n\n\tif (notify)\n\t\tvirtqueue_notify(vqueue);\n\n\treturn 0;\n}\n\n \nunsigned int virtsnd_pcm_msg_pending_num(struct virtio_pcm_substream *vss)\n{\n\tunsigned int num;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vss->lock, flags);\n\tnum = vss->msg_count;\n\tspin_unlock_irqrestore(&vss->lock, flags);\n\n\treturn num;\n}\n\n \nstatic void virtsnd_pcm_msg_complete(struct virtio_pcm_msg *msg,\n\t\t\t\t     size_t written_bytes)\n{\n\tstruct virtio_pcm_substream *vss = msg->substream;\n\n\t \n\tspin_lock(&vss->lock);\n\t \n\tif (vss->direction == SNDRV_PCM_STREAM_PLAYBACK ||\n\t    written_bytes <= sizeof(msg->status))\n\t\tvss->hw_ptr += msg->length;\n\telse\n\t\tvss->hw_ptr += written_bytes - sizeof(msg->status);\n\n\tif (vss->hw_ptr >= vss->buffer_bytes)\n\t\tvss->hw_ptr -= vss->buffer_bytes;\n\n\tvss->xfer_xrun = false;\n\tvss->msg_count--;\n\n\tif (vss->xfer_enabled) {\n\t\tstruct snd_pcm_runtime *runtime = vss->substream->runtime;\n\n\t\truntime->delay =\n\t\t\tbytes_to_frames(runtime,\n\t\t\t\t\tle32_to_cpu(msg->status.latency_bytes));\n\n\t\tschedule_work(&vss->elapsed_period);\n\n\t\tvirtsnd_pcm_msg_send(vss);\n\t} else if (!vss->msg_count) {\n\t\twake_up_all(&vss->msg_empty);\n\t}\n\tspin_unlock(&vss->lock);\n}\n\n \nstatic inline void virtsnd_pcm_notify_cb(struct virtio_snd_queue *queue)\n{\n\tstruct virtio_pcm_msg *msg;\n\tu32 written_bytes;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tdo {\n\t\tvirtqueue_disable_cb(queue->vqueue);\n\t\twhile ((msg = virtqueue_get_buf(queue->vqueue, &written_bytes)))\n\t\t\tvirtsnd_pcm_msg_complete(msg, written_bytes);\n\t\tif (unlikely(virtqueue_is_broken(queue->vqueue)))\n\t\t\tbreak;\n\t} while (!virtqueue_enable_cb(queue->vqueue));\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n\n \nvoid virtsnd_pcm_tx_notify_cb(struct virtqueue *vqueue)\n{\n\tstruct virtio_snd *snd = vqueue->vdev->priv;\n\n\tvirtsnd_pcm_notify_cb(virtsnd_tx_queue(snd));\n}\n\n \nvoid virtsnd_pcm_rx_notify_cb(struct virtqueue *vqueue)\n{\n\tstruct virtio_snd *snd = vqueue->vdev->priv;\n\n\tvirtsnd_pcm_notify_cb(virtsnd_rx_queue(snd));\n}\n\n \nstruct virtio_snd_msg *\nvirtsnd_pcm_ctl_msg_alloc(struct virtio_pcm_substream *vss,\n\t\t\t  unsigned int command, gfp_t gfp)\n{\n\tsize_t request_size = sizeof(struct virtio_snd_pcm_hdr);\n\tsize_t response_size = sizeof(struct virtio_snd_hdr);\n\tstruct virtio_snd_msg *msg;\n\n\tswitch (command) {\n\tcase VIRTIO_SND_R_PCM_SET_PARAMS:\n\t\trequest_size = sizeof(struct virtio_snd_pcm_set_params);\n\t\tbreak;\n\t}\n\n\tmsg = virtsnd_ctl_msg_alloc(request_size, response_size, gfp);\n\tif (msg) {\n\t\tstruct virtio_snd_pcm_hdr *hdr = virtsnd_ctl_msg_request(msg);\n\n\t\thdr->hdr.code = cpu_to_le32(command);\n\t\thdr->stream_id = cpu_to_le32(vss->sid);\n\t}\n\n\treturn msg;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}