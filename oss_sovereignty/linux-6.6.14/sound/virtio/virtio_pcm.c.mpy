{
  "module_name": "virtio_pcm.c",
  "hash_id": "feea57011d705014f607e4c36afc5c382f8998af340950a4305350a3ccdc28f9",
  "original_prompt": "Ingested from linux-6.6.14/sound/virtio/virtio_pcm.c",
  "human_readable_source": "\n \n#include <linux/moduleparam.h>\n#include <linux/virtio_config.h>\n\n#include \"virtio_card.h\"\n\nstatic u32 pcm_buffer_ms = 160;\nmodule_param(pcm_buffer_ms, uint, 0644);\nMODULE_PARM_DESC(pcm_buffer_ms, \"PCM substream buffer time in milliseconds\");\n\nstatic u32 pcm_periods_min = 2;\nmodule_param(pcm_periods_min, uint, 0644);\nMODULE_PARM_DESC(pcm_periods_min, \"Minimum number of PCM periods\");\n\nstatic u32 pcm_periods_max = 16;\nmodule_param(pcm_periods_max, uint, 0644);\nMODULE_PARM_DESC(pcm_periods_max, \"Maximum number of PCM periods\");\n\nstatic u32 pcm_period_ms_min = 10;\nmodule_param(pcm_period_ms_min, uint, 0644);\nMODULE_PARM_DESC(pcm_period_ms_min, \"Minimum PCM period time in milliseconds\");\n\nstatic u32 pcm_period_ms_max = 80;\nmodule_param(pcm_period_ms_max, uint, 0644);\nMODULE_PARM_DESC(pcm_period_ms_max, \"Maximum PCM period time in milliseconds\");\n\n \nstatic const snd_pcm_format_t g_v2a_format_map[] = {\n\t[VIRTIO_SND_PCM_FMT_IMA_ADPCM] = SNDRV_PCM_FORMAT_IMA_ADPCM,\n\t[VIRTIO_SND_PCM_FMT_MU_LAW] = SNDRV_PCM_FORMAT_MU_LAW,\n\t[VIRTIO_SND_PCM_FMT_A_LAW] = SNDRV_PCM_FORMAT_A_LAW,\n\t[VIRTIO_SND_PCM_FMT_S8] = SNDRV_PCM_FORMAT_S8,\n\t[VIRTIO_SND_PCM_FMT_U8] = SNDRV_PCM_FORMAT_U8,\n\t[VIRTIO_SND_PCM_FMT_S16] = SNDRV_PCM_FORMAT_S16_LE,\n\t[VIRTIO_SND_PCM_FMT_U16] = SNDRV_PCM_FORMAT_U16_LE,\n\t[VIRTIO_SND_PCM_FMT_S18_3] = SNDRV_PCM_FORMAT_S18_3LE,\n\t[VIRTIO_SND_PCM_FMT_U18_3] = SNDRV_PCM_FORMAT_U18_3LE,\n\t[VIRTIO_SND_PCM_FMT_S20_3] = SNDRV_PCM_FORMAT_S20_3LE,\n\t[VIRTIO_SND_PCM_FMT_U20_3] = SNDRV_PCM_FORMAT_U20_3LE,\n\t[VIRTIO_SND_PCM_FMT_S24_3] = SNDRV_PCM_FORMAT_S24_3LE,\n\t[VIRTIO_SND_PCM_FMT_U24_3] = SNDRV_PCM_FORMAT_U24_3LE,\n\t[VIRTIO_SND_PCM_FMT_S20] = SNDRV_PCM_FORMAT_S20_LE,\n\t[VIRTIO_SND_PCM_FMT_U20] = SNDRV_PCM_FORMAT_U20_LE,\n\t[VIRTIO_SND_PCM_FMT_S24] = SNDRV_PCM_FORMAT_S24_LE,\n\t[VIRTIO_SND_PCM_FMT_U24] = SNDRV_PCM_FORMAT_U24_LE,\n\t[VIRTIO_SND_PCM_FMT_S32] = SNDRV_PCM_FORMAT_S32_LE,\n\t[VIRTIO_SND_PCM_FMT_U32] = SNDRV_PCM_FORMAT_U32_LE,\n\t[VIRTIO_SND_PCM_FMT_FLOAT] = SNDRV_PCM_FORMAT_FLOAT_LE,\n\t[VIRTIO_SND_PCM_FMT_FLOAT64] = SNDRV_PCM_FORMAT_FLOAT64_LE,\n\t[VIRTIO_SND_PCM_FMT_DSD_U8] = SNDRV_PCM_FORMAT_DSD_U8,\n\t[VIRTIO_SND_PCM_FMT_DSD_U16] = SNDRV_PCM_FORMAT_DSD_U16_LE,\n\t[VIRTIO_SND_PCM_FMT_DSD_U32] = SNDRV_PCM_FORMAT_DSD_U32_LE,\n\t[VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME] =\n\t\tSNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE\n};\n\n \nstruct virtsnd_v2a_rate {\n\tunsigned int alsa_bit;\n\tunsigned int rate;\n};\n\nstatic const struct virtsnd_v2a_rate g_v2a_rate_map[] = {\n\t[VIRTIO_SND_PCM_RATE_5512] = { SNDRV_PCM_RATE_5512, 5512 },\n\t[VIRTIO_SND_PCM_RATE_8000] = { SNDRV_PCM_RATE_8000, 8000 },\n\t[VIRTIO_SND_PCM_RATE_11025] = { SNDRV_PCM_RATE_11025, 11025 },\n\t[VIRTIO_SND_PCM_RATE_16000] = { SNDRV_PCM_RATE_16000, 16000 },\n\t[VIRTIO_SND_PCM_RATE_22050] = { SNDRV_PCM_RATE_22050, 22050 },\n\t[VIRTIO_SND_PCM_RATE_32000] = { SNDRV_PCM_RATE_32000, 32000 },\n\t[VIRTIO_SND_PCM_RATE_44100] = { SNDRV_PCM_RATE_44100, 44100 },\n\t[VIRTIO_SND_PCM_RATE_48000] = { SNDRV_PCM_RATE_48000, 48000 },\n\t[VIRTIO_SND_PCM_RATE_64000] = { SNDRV_PCM_RATE_64000, 64000 },\n\t[VIRTIO_SND_PCM_RATE_88200] = { SNDRV_PCM_RATE_88200, 88200 },\n\t[VIRTIO_SND_PCM_RATE_96000] = { SNDRV_PCM_RATE_96000, 96000 },\n\t[VIRTIO_SND_PCM_RATE_176400] = { SNDRV_PCM_RATE_176400, 176400 },\n\t[VIRTIO_SND_PCM_RATE_192000] = { SNDRV_PCM_RATE_192000, 192000 }\n};\n\n \nstatic int virtsnd_pcm_build_hw(struct virtio_pcm_substream *vss,\n\t\t\t\tstruct virtio_snd_pcm_info *info)\n{\n\tstruct virtio_device *vdev = vss->snd->vdev;\n\tunsigned int i;\n\tu64 values;\n\tsize_t sample_max = 0;\n\tsize_t sample_min = 0;\n\n\tvss->features = le32_to_cpu(info->features);\n\n\t \n\tvss->hw.info =\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_PAUSE;\n\n\tif (!info->channels_min || info->channels_min > info->channels_max) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"SID %u: invalid channel range [%u %u]\\n\",\n\t\t\tvss->sid, info->channels_min, info->channels_max);\n\t\treturn -EINVAL;\n\t}\n\n\tvss->hw.channels_min = info->channels_min;\n\tvss->hw.channels_max = info->channels_max;\n\n\tvalues = le64_to_cpu(info->formats);\n\n\tvss->hw.formats = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_v2a_format_map); ++i)\n\t\tif (values & (1ULL << i)) {\n\t\t\tsnd_pcm_format_t alsa_fmt = g_v2a_format_map[i];\n\t\t\tint bytes = snd_pcm_format_physical_width(alsa_fmt) / 8;\n\n\t\t\tif (!sample_min || sample_min > bytes)\n\t\t\t\tsample_min = bytes;\n\n\t\t\tif (sample_max < bytes)\n\t\t\t\tsample_max = bytes;\n\n\t\t\tvss->hw.formats |= pcm_format_to_bits(alsa_fmt);\n\t\t}\n\n\tif (!vss->hw.formats) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"SID %u: no supported PCM sample formats found\\n\",\n\t\t\tvss->sid);\n\t\treturn -EINVAL;\n\t}\n\n\tvalues = le64_to_cpu(info->rates);\n\n\tvss->hw.rates = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_v2a_rate_map); ++i)\n\t\tif (values & (1ULL << i)) {\n\t\t\tif (!vss->hw.rate_min ||\n\t\t\t    vss->hw.rate_min > g_v2a_rate_map[i].rate)\n\t\t\t\tvss->hw.rate_min = g_v2a_rate_map[i].rate;\n\n\t\t\tif (vss->hw.rate_max < g_v2a_rate_map[i].rate)\n\t\t\t\tvss->hw.rate_max = g_v2a_rate_map[i].rate;\n\n\t\t\tvss->hw.rates |= g_v2a_rate_map[i].alsa_bit;\n\t\t}\n\n\tif (!vss->hw.rates) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"SID %u: no supported PCM frame rates found\\n\",\n\t\t\tvss->sid);\n\t\treturn -EINVAL;\n\t}\n\n\tvss->hw.periods_min = pcm_periods_min;\n\tvss->hw.periods_max = pcm_periods_max;\n\n\t \n\tvss->hw.buffer_bytes_max =\n\t\tPAGE_ALIGN(sample_max * vss->hw.channels_max * pcm_buffer_ms *\n\t\t\t   (vss->hw.rate_max / MSEC_PER_SEC));\n\n\t \n\tvss->hw.period_bytes_min =\n\t\tsample_min * vss->hw.channels_min * pcm_period_ms_min *\n\t\t(vss->hw.rate_min / MSEC_PER_SEC);\n\n\t \n\tvss->hw.period_bytes_max =\n\t\tsample_max * vss->hw.channels_max * pcm_period_ms_max *\n\t\t(vss->hw.rate_max / MSEC_PER_SEC);\n\n\treturn 0;\n}\n\n \nstruct virtio_pcm *virtsnd_pcm_find(struct virtio_snd *snd, u32 nid)\n{\n\tstruct virtio_pcm *vpcm;\n\n\tlist_for_each_entry(vpcm, &snd->pcm_list, list)\n\t\tif (vpcm->nid == nid)\n\t\t\treturn vpcm;\n\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstruct virtio_pcm *virtsnd_pcm_find_or_create(struct virtio_snd *snd, u32 nid)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct virtio_pcm *vpcm;\n\n\tvpcm = virtsnd_pcm_find(snd, nid);\n\tif (!IS_ERR(vpcm))\n\t\treturn vpcm;\n\n\tvpcm = devm_kzalloc(&vdev->dev, sizeof(*vpcm), GFP_KERNEL);\n\tif (!vpcm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvpcm->nid = nid;\n\tlist_add_tail(&vpcm->list, &snd->pcm_list);\n\n\treturn vpcm;\n}\n\n \nint virtsnd_pcm_validate(struct virtio_device *vdev)\n{\n\tif (pcm_periods_min < 2 || pcm_periods_min > pcm_periods_max) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"invalid range [%u %u] of the number of PCM periods\\n\",\n\t\t\tpcm_periods_min, pcm_periods_max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pcm_period_ms_min || pcm_period_ms_min > pcm_period_ms_max) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"invalid range [%u %u] of the size of the PCM period\\n\",\n\t\t\tpcm_period_ms_min, pcm_period_ms_max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcm_buffer_ms < pcm_periods_min * pcm_period_ms_min) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"pcm_buffer_ms(=%u) value cannot be < %u ms\\n\",\n\t\t\tpcm_buffer_ms, pcm_periods_min * pcm_period_ms_min);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcm_period_ms_max > pcm_buffer_ms / 2) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"pcm_period_ms_max(=%u) value cannot be > %u ms\\n\",\n\t\t\tpcm_period_ms_max, pcm_buffer_ms / 2);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void virtsnd_pcm_period_elapsed(struct work_struct *work)\n{\n\tstruct virtio_pcm_substream *vss =\n\t\tcontainer_of(work, struct virtio_pcm_substream, elapsed_period);\n\n\tsnd_pcm_period_elapsed(vss->substream);\n}\n\n \nint virtsnd_pcm_parse_cfg(struct virtio_snd *snd)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct virtio_snd_pcm_info *info;\n\tu32 i;\n\tint rc;\n\n\tvirtio_cread_le(vdev, struct virtio_snd_config, streams,\n\t\t\t&snd->nsubstreams);\n\tif (!snd->nsubstreams)\n\t\treturn 0;\n\n\tsnd->substreams = devm_kcalloc(&vdev->dev, snd->nsubstreams,\n\t\t\t\t       sizeof(*snd->substreams), GFP_KERNEL);\n\tif (!snd->substreams)\n\t\treturn -ENOMEM;\n\n\tinfo = kcalloc(snd->nsubstreams, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\trc = virtsnd_ctl_query_info(snd, VIRTIO_SND_R_PCM_INFO, 0,\n\t\t\t\t    snd->nsubstreams, sizeof(*info), info);\n\tif (rc)\n\t\tgoto on_exit;\n\n\tfor (i = 0; i < snd->nsubstreams; ++i) {\n\t\tstruct virtio_pcm_substream *vss = &snd->substreams[i];\n\t\tstruct virtio_pcm *vpcm;\n\n\t\tvss->snd = snd;\n\t\tvss->sid = i;\n\t\tINIT_WORK(&vss->elapsed_period, virtsnd_pcm_period_elapsed);\n\t\tinit_waitqueue_head(&vss->msg_empty);\n\t\tspin_lock_init(&vss->lock);\n\n\t\trc = virtsnd_pcm_build_hw(vss, &info[i]);\n\t\tif (rc)\n\t\t\tgoto on_exit;\n\n\t\tvss->nid = le32_to_cpu(info[i].hdr.hda_fn_nid);\n\n\t\tvpcm = virtsnd_pcm_find_or_create(snd, vss->nid);\n\t\tif (IS_ERR(vpcm)) {\n\t\t\trc = PTR_ERR(vpcm);\n\t\t\tgoto on_exit;\n\t\t}\n\n\t\tswitch (info[i].direction) {\n\t\tcase VIRTIO_SND_D_OUTPUT:\n\t\t\tvss->direction = SNDRV_PCM_STREAM_PLAYBACK;\n\t\t\tbreak;\n\t\tcase VIRTIO_SND_D_INPUT:\n\t\t\tvss->direction = SNDRV_PCM_STREAM_CAPTURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&vdev->dev, \"SID %u: unknown direction (%u)\\n\",\n\t\t\t\tvss->sid, info[i].direction);\n\t\t\trc = -EINVAL;\n\t\t\tgoto on_exit;\n\t\t}\n\n\t\tvpcm->streams[vss->direction].nsubstreams++;\n\t}\n\non_exit:\n\tkfree(info);\n\n\treturn rc;\n}\n\n \nint virtsnd_pcm_build_devs(struct virtio_snd *snd)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct virtio_pcm *vpcm;\n\tu32 i;\n\tint rc;\n\n\tlist_for_each_entry(vpcm, &snd->pcm_list, list) {\n\t\tunsigned int npbs =\n\t\t\tvpcm->streams[SNDRV_PCM_STREAM_PLAYBACK].nsubstreams;\n\t\tunsigned int ncps =\n\t\t\tvpcm->streams[SNDRV_PCM_STREAM_CAPTURE].nsubstreams;\n\n\t\tif (!npbs && !ncps)\n\t\t\tcontinue;\n\n\t\trc = snd_pcm_new(snd->card, VIRTIO_SND_CARD_DRIVER, vpcm->nid,\n\t\t\t\t npbs, ncps, &vpcm->pcm);\n\t\tif (rc) {\n\t\t\tdev_err(&vdev->dev, \"snd_pcm_new[%u] failed: %d\\n\",\n\t\t\t\tvpcm->nid, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tvpcm->pcm->info_flags = 0;\n\t\tvpcm->pcm->dev_class = SNDRV_PCM_CLASS_GENERIC;\n\t\tvpcm->pcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\t\tsnprintf(vpcm->pcm->name, sizeof(vpcm->pcm->name),\n\t\t\t VIRTIO_SND_PCM_NAME \" %u\", vpcm->pcm->device);\n\t\tvpcm->pcm->private_data = vpcm;\n\t\tvpcm->pcm->nonatomic = true;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(vpcm->streams); ++i) {\n\t\t\tstruct virtio_pcm_stream *stream = &vpcm->streams[i];\n\n\t\t\tif (!stream->nsubstreams)\n\t\t\t\tcontinue;\n\n\t\t\tstream->substreams =\n\t\t\t\tdevm_kcalloc(&vdev->dev, stream->nsubstreams,\n\t\t\t\t\t     sizeof(*stream->substreams),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!stream->substreams)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tstream->nsubstreams = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < snd->nsubstreams; ++i) {\n\t\tstruct virtio_pcm_stream *vs;\n\t\tstruct virtio_pcm_substream *vss = &snd->substreams[i];\n\n\t\tvpcm = virtsnd_pcm_find(snd, vss->nid);\n\t\tif (IS_ERR(vpcm))\n\t\t\treturn PTR_ERR(vpcm);\n\n\t\tvs = &vpcm->streams[vss->direction];\n\t\tvs->substreams[vs->nsubstreams++] = vss;\n\t}\n\n\tlist_for_each_entry(vpcm, &snd->pcm_list, list) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vpcm->streams); ++i) {\n\t\t\tstruct virtio_pcm_stream *vs = &vpcm->streams[i];\n\t\t\tstruct snd_pcm_str *ks = &vpcm->pcm->streams[i];\n\t\t\tstruct snd_pcm_substream *kss;\n\n\t\t\tif (!vs->nsubstreams)\n\t\t\t\tcontinue;\n\n\t\t\tfor (kss = ks->substream; kss; kss = kss->next)\n\t\t\t\tvs->substreams[kss->number]->substream = kss;\n\n\t\t\tsnd_pcm_set_ops(vpcm->pcm, i, &virtsnd_pcm_ops);\n\t\t}\n\n\t\tsnd_pcm_set_managed_buffer_all(vpcm->pcm,\n\t\t\t\t\t       SNDRV_DMA_TYPE_VMALLOC, NULL,\n\t\t\t\t\t       0, 0);\n\t}\n\n\treturn 0;\n}\n\n \nvoid virtsnd_pcm_event(struct virtio_snd *snd, struct virtio_snd_event *event)\n{\n\tstruct virtio_pcm_substream *vss;\n\tu32 sid = le32_to_cpu(event->data);\n\n\tif (sid >= snd->nsubstreams)\n\t\treturn;\n\n\tvss = &snd->substreams[sid];\n\n\tswitch (le32_to_cpu(event->hdr.code)) {\n\tcase VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED:\n\t\t \n\t\tbreak;\n\tcase VIRTIO_SND_EVT_PCM_XRUN:\n\t\tspin_lock(&vss->lock);\n\t\tif (vss->xfer_enabled)\n\t\t\tvss->xfer_xrun = true;\n\t\tspin_unlock(&vss->lock);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}