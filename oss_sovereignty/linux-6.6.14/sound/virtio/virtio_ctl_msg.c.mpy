{
  "module_name": "virtio_ctl_msg.c",
  "hash_id": "6fbea7a061a07aa0e129d5a18583ea27735d66ab58ad57d2ab23c0224422197d",
  "original_prompt": "Ingested from linux-6.6.14/sound/virtio/virtio_ctl_msg.c",
  "human_readable_source": "\n \n#include <linux/moduleparam.h>\n#include <linux/virtio_config.h>\n\n#include \"virtio_card.h\"\n\n \nstruct virtio_snd_msg {\n\tstruct scatterlist sg_request;\n\tstruct scatterlist sg_response;\n\tstruct list_head list;\n\tstruct completion notify;\n\trefcount_t ref_count;\n};\n\n \nvoid virtsnd_ctl_msg_ref(struct virtio_snd_msg *msg)\n{\n\trefcount_inc(&msg->ref_count);\n}\n\n \nvoid virtsnd_ctl_msg_unref(struct virtio_snd_msg *msg)\n{\n\tif (refcount_dec_and_test(&msg->ref_count))\n\t\tkfree(msg);\n}\n\n \nvoid *virtsnd_ctl_msg_request(struct virtio_snd_msg *msg)\n{\n\treturn sg_virt(&msg->sg_request);\n}\n\n \nvoid *virtsnd_ctl_msg_response(struct virtio_snd_msg *msg)\n{\n\treturn sg_virt(&msg->sg_response);\n}\n\n \nstruct virtio_snd_msg *virtsnd_ctl_msg_alloc(size_t request_size,\n\t\t\t\t\t     size_t response_size, gfp_t gfp)\n{\n\tstruct virtio_snd_msg *msg;\n\n\tif (!request_size || !response_size)\n\t\treturn NULL;\n\n\tmsg = kzalloc(sizeof(*msg) + request_size + response_size, gfp);\n\tif (!msg)\n\t\treturn NULL;\n\n\tsg_init_one(&msg->sg_request, (u8 *)msg + sizeof(*msg), request_size);\n\tsg_init_one(&msg->sg_response, (u8 *)msg + sizeof(*msg) + request_size,\n\t\t    response_size);\n\n\tINIT_LIST_HEAD(&msg->list);\n\tinit_completion(&msg->notify);\n\t \n\trefcount_set(&msg->ref_count, 1);\n\n\treturn msg;\n}\n\n \nint virtsnd_ctl_msg_send(struct virtio_snd *snd, struct virtio_snd_msg *msg,\n\t\t\t struct scatterlist *out_sgs,\n\t\t\t struct scatterlist *in_sgs, bool nowait)\n{\n\tstruct virtio_device *vdev = snd->vdev;\n\tstruct virtio_snd_queue *queue = virtsnd_control_queue(snd);\n\tunsigned int js = msecs_to_jiffies(virtsnd_msg_timeout_ms);\n\tstruct virtio_snd_hdr *request = virtsnd_ctl_msg_request(msg);\n\tstruct virtio_snd_hdr *response = virtsnd_ctl_msg_response(msg);\n\tunsigned int nouts = 0;\n\tunsigned int nins = 0;\n\tstruct scatterlist *psgs[4];\n\tbool notify = false;\n\tunsigned long flags;\n\tint rc;\n\n\tvirtsnd_ctl_msg_ref(msg);\n\n\t \n\tresponse->code = cpu_to_le32(VIRTIO_SND_S_IO_ERR);\n\n\tpsgs[nouts++] = &msg->sg_request;\n\tif (out_sgs)\n\t\tpsgs[nouts++] = out_sgs;\n\n\tpsgs[nouts + nins++] = &msg->sg_response;\n\tif (in_sgs)\n\t\tpsgs[nouts + nins++] = in_sgs;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\trc = virtqueue_add_sgs(queue->vqueue, psgs, nouts, nins, msg,\n\t\t\t       GFP_ATOMIC);\n\tif (!rc) {\n\t\tnotify = virtqueue_kick_prepare(queue->vqueue);\n\n\t\tlist_add_tail(&msg->list, &snd->ctl_msgs);\n\t}\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\n\tif (rc) {\n\t\tdev_err(&vdev->dev, \"failed to send control message (0x%08x)\\n\",\n\t\t\tle32_to_cpu(request->code));\n\n\t\t \n\t\tvirtsnd_ctl_msg_unref(msg);\n\n\t\tgoto on_exit;\n\t}\n\n\tif (notify)\n\t\tvirtqueue_notify(queue->vqueue);\n\n\tif (nowait)\n\t\tgoto on_exit;\n\n\trc = wait_for_completion_interruptible_timeout(&msg->notify, js);\n\tif (rc <= 0) {\n\t\tif (!rc) {\n\t\t\tdev_err(&vdev->dev,\n\t\t\t\t\"control message (0x%08x) timeout\\n\",\n\t\t\t\tle32_to_cpu(request->code));\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\n\t\tgoto on_exit;\n\t}\n\n\tswitch (le32_to_cpu(response->code)) {\n\tcase VIRTIO_SND_S_OK:\n\t\trc = 0;\n\t\tbreak;\n\tcase VIRTIO_SND_S_NOT_SUPP:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\tcase VIRTIO_SND_S_IO_ERR:\n\t\trc = -EIO;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\non_exit:\n\tvirtsnd_ctl_msg_unref(msg);\n\n\treturn rc;\n}\n\n \nvoid virtsnd_ctl_msg_complete(struct virtio_snd_msg *msg)\n{\n\tlist_del(&msg->list);\n\tcomplete(&msg->notify);\n\n\tvirtsnd_ctl_msg_unref(msg);\n}\n\n \nvoid virtsnd_ctl_msg_cancel_all(struct virtio_snd *snd)\n{\n\tstruct virtio_snd_queue *queue = virtsnd_control_queue(snd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\twhile (!list_empty(&snd->ctl_msgs)) {\n\t\tstruct virtio_snd_msg *msg =\n\t\t\tlist_first_entry(&snd->ctl_msgs, struct virtio_snd_msg,\n\t\t\t\t\t list);\n\n\t\tvirtsnd_ctl_msg_complete(msg);\n\t}\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n\n \nint virtsnd_ctl_query_info(struct virtio_snd *snd, int command, int start_id,\n\t\t\t   int count, size_t size, void *info)\n{\n\tstruct virtio_snd_msg *msg;\n\tstruct virtio_snd_query_info *query;\n\tstruct scatterlist sg;\n\n\tmsg = virtsnd_ctl_msg_alloc(sizeof(*query),\n\t\t\t\t    sizeof(struct virtio_snd_hdr), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tquery = virtsnd_ctl_msg_request(msg);\n\tquery->hdr.code = cpu_to_le32(command);\n\tquery->start_id = cpu_to_le32(start_id);\n\tquery->count = cpu_to_le32(count);\n\tquery->size = cpu_to_le32(size);\n\n\tsg_init_one(&sg, info, count * size);\n\n\treturn virtsnd_ctl_msg_send(snd, msg, NULL, &sg, false);\n}\n\n \nvoid virtsnd_ctl_notify_cb(struct virtqueue *vqueue)\n{\n\tstruct virtio_snd *snd = vqueue->vdev->priv;\n\tstruct virtio_snd_queue *queue = virtsnd_control_queue(snd);\n\tstruct virtio_snd_msg *msg;\n\tu32 length;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tdo {\n\t\tvirtqueue_disable_cb(vqueue);\n\t\twhile ((msg = virtqueue_get_buf(vqueue, &length)))\n\t\t\tvirtsnd_ctl_msg_complete(msg);\n\t\tif (unlikely(virtqueue_is_broken(vqueue)))\n\t\t\tbreak;\n\t} while (!virtqueue_enable_cb(vqueue));\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}