{
  "module_name": "snd_ps3.c",
  "hash_id": "6b45f2c5b1cf6b1d31fd4885d90c247bda0f85649dd15c670259eae1e9f2e9b4",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/snd_ps3.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#include <sound/asound.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/memalloc.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include <asm/dma.h>\n#include <asm/firmware.h>\n#include <asm/lv1call.h>\n#include <asm/ps3.h>\n#include <asm/ps3av.h>\n\n#include \"snd_ps3.h\"\n#include \"snd_ps3_reg.h\"\n\n\n \nstatic struct snd_ps3_card_info the_card;\n\nstatic int snd_ps3_start_delay = CONFIG_SND_PS3_DEFAULT_START_DELAY;\n\nmodule_param_named(start_delay, snd_ps3_start_delay, uint, 0644);\nMODULE_PARM_DESC(start_delay, \"time to insert silent data in ms\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\nstatic char *id = SNDRV_DEFAULT_STR1;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for PS3 soundchip.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for PS3 soundchip.\");\n\n\n \nstatic inline u32 read_reg(unsigned int reg)\n{\n\treturn in_be32(the_card.mapped_mmio_vaddr + reg);\n}\nstatic inline void write_reg(unsigned int reg, u32 val)\n{\n\tout_be32(the_card.mapped_mmio_vaddr + reg, val);\n}\nstatic inline void update_reg(unsigned int reg, u32 or_val)\n{\n\tu32 newval = read_reg(reg) | or_val;\n\twrite_reg(reg, newval);\n}\nstatic inline void update_mask_reg(unsigned int reg, u32 mask, u32 or_val)\n{\n\tu32 newval = (read_reg(reg) & mask) | or_val;\n\twrite_reg(reg, newval);\n}\n\n \nstatic const struct snd_pcm_hardware snd_ps3_pcm_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = (SNDRV_PCM_FMTBIT_S16_BE |\n\t\t    SNDRV_PCM_FMTBIT_S24_BE),\n\t.rates = (SNDRV_PCM_RATE_44100 |\n\t\t  SNDRV_PCM_RATE_48000 |\n\t\t  SNDRV_PCM_RATE_88200 |\n\t\t  SNDRV_PCM_RATE_96000),\n\t.rate_min = 44100,\n\t.rate_max = 96000,\n\n\t.channels_min = 2,  \n\t.channels_max = 2,\n\n\t.buffer_bytes_max = PS3_AUDIO_FIFO_SIZE * 64,\n\n\t \n\t.period_bytes_min = PS3_AUDIO_FIFO_STAGE_SIZE * 4,\n\t.period_bytes_max = PS3_AUDIO_FIFO_STAGE_SIZE * 4,\n\n\t.periods_min = 16,\n\t.periods_max = 32,  \n\n\t.fifo_size = PS3_AUDIO_FIFO_SIZE\n};\n\nstatic int snd_ps3_verify_dma_stop(struct snd_ps3_card_info *card,\n\t\t\t\t   int count, int force_stop)\n{\n\tint dma_ch, done, retries, stop_forced = 0;\n\tuint32_t status;\n\n\tfor (dma_ch = 0; dma_ch < 8; dma_ch++) {\n\t\tretries = count;\n\t\tdo {\n\t\t\tstatus = read_reg(PS3_AUDIO_KICK(dma_ch)) &\n\t\t\t\tPS3_AUDIO_KICK_STATUS_MASK;\n\t\t\tswitch (status) {\n\t\t\tcase PS3_AUDIO_KICK_STATUS_DONE:\n\t\t\tcase PS3_AUDIO_KICK_STATUS_NOTIFY:\n\t\t\tcase PS3_AUDIO_KICK_STATUS_CLEAR:\n\t\t\tcase PS3_AUDIO_KICK_STATUS_ERROR:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdone = 0;\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t} while (!done && --retries);\n\t\tif (!retries && force_stop) {\n\t\t\tpr_info(\"%s: DMA ch %d is not stopped.\",\n\t\t\t\t__func__, dma_ch);\n\t\t\t \n\t\t\tupdate_reg(PS3_AUDIO_CONFIG, PS3_AUDIO_CONFIG_CLEAR);\n\t\t\tstop_forced = 1;\n\t\t}\n\t}\n\treturn stop_forced;\n}\n\n \nstatic void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info *card)\n{\n\tint stop_forced;\n\t \n\n\t \n\tstop_forced = snd_ps3_verify_dma_stop(card, 700, 1);\n\n\t \n\tupdate_reg(PS3_AUDIO_INTR_0, 0);\n\tupdate_reg(PS3_AUDIO_AX_IS, 0);\n\n\t \n\tif (stop_forced)\n\t\tupdate_mask_reg(PS3_AUDIO_CONFIG, ~PS3_AUDIO_CONFIG_CLEAR, 0);\n\t \n\twmb();\n}\n\nstatic void snd_ps3_kick_dma(struct snd_ps3_card_info *card)\n{\n\n\tupdate_reg(PS3_AUDIO_KICK(0), PS3_AUDIO_KICK_REQUEST);\n\t \n\twmb();\n}\n\n \nstatic dma_addr_t v_to_bus(struct snd_ps3_card_info *card, void *paddr, int ch)\n{\n\treturn card->dma_start_bus_addr[ch] +\n\t\t(paddr - card->dma_start_vaddr[ch]);\n};\n\n\n \nstatic void snd_ps3_bump_buffer(struct snd_ps3_card_info *card,\n\t\t\t\tenum snd_ps3_ch ch, size_t byte_count,\n\t\t\t\tint stage)\n{\n\tif (!stage)\n\t\tcard->dma_last_transfer_vaddr[ch] =\n\t\t\tcard->dma_next_transfer_vaddr[ch];\n\tcard->dma_next_transfer_vaddr[ch] += byte_count;\n\tif ((card->dma_start_vaddr[ch] + (card->dma_buffer_size / 2)) <=\n\t    card->dma_next_transfer_vaddr[ch]) {\n\t\tcard->dma_next_transfer_vaddr[ch] = card->dma_start_vaddr[ch];\n\t}\n}\n \nstatic int snd_ps3_program_dma(struct snd_ps3_card_info *card,\n\t\t\t       enum snd_ps3_dma_filltype filltype)\n{\n\t \n\tuint32_t dma_addr;\n\tint fill_stages, dma_ch, stage;\n\tenum snd_ps3_ch ch;\n\tuint32_t ch0_kick_event = 0;  \n\tunsigned long irqsave;\n\tint silent = 0;\n\n\tswitch (filltype) {\n\tcase SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL:\n\t\tsilent = 1;\n\t\tfallthrough;\n\tcase SND_PS3_DMA_FILLTYPE_FIRSTFILL:\n\t\tch0_kick_event = PS3_AUDIO_KICK_EVENT_ALWAYS;\n\t\tbreak;\n\n\tcase SND_PS3_DMA_FILLTYPE_SILENT_RUNNING:\n\t\tsilent = 1;\n\t\tfallthrough;\n\tcase SND_PS3_DMA_FILLTYPE_RUNNING:\n\t\tch0_kick_event = PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY;\n\t\tbreak;\n\t}\n\n\tsnd_ps3_verify_dma_stop(card, 700, 0);\n\tfill_stages = 4;\n\tspin_lock_irqsave(&card->dma_lock, irqsave);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tfor (stage = 0; stage < fill_stages; stage++) {\n\t\t\tdma_ch = stage * 2 + ch;\n\t\t\tif (silent)\n\t\t\t\tdma_addr = card->null_buffer_start_dma_addr;\n\t\t\telse\n\t\t\t\tdma_addr =\n\t\t\t\tv_to_bus(card,\n\t\t\t\t\t card->dma_next_transfer_vaddr[ch],\n\t\t\t\t\t ch);\n\n\t\t\twrite_reg(PS3_AUDIO_SOURCE(dma_ch),\n\t\t\t\t  (PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY |\n\t\t\t\t   dma_addr));\n\n\t\t\t \n\t\t\tif (ch == 0)\n\t\t\t\twrite_reg(PS3_AUDIO_DEST(dma_ch),\n\t\t\t\t\t  (PS3_AUDIO_DEST_TARGET_AUDIOFIFO |\n\t\t\t\t\t   PS3_AUDIO_AO_3W_LDATA(0)));\n\t\t\telse\n\t\t\t\twrite_reg(PS3_AUDIO_DEST(dma_ch),\n\t\t\t\t\t  (PS3_AUDIO_DEST_TARGET_AUDIOFIFO |\n\t\t\t\t\t   PS3_AUDIO_AO_3W_RDATA(0)));\n\n\t\t\t \n\t\t\twrite_reg(PS3_AUDIO_DMASIZE(dma_ch), 0);\n\t\t\t \n\t\t\tif (!silent)\n\t\t\t\tsnd_ps3_bump_buffer(card, ch,\n\t\t\t\t\t\t    PS3_AUDIO_DMAC_BLOCK_SIZE,\n\t\t\t\t\t\t    stage);\n\n\t\t\t \n\t\t\tif (dma_ch == 0)\n\t\t\t\twrite_reg(PS3_AUDIO_KICK(dma_ch),\n\t\t\t\t\t  ch0_kick_event);\n\t\t\telse\n\t\t\t\twrite_reg(PS3_AUDIO_KICK(dma_ch),\n\t\t\t\t\t  PS3_AUDIO_KICK_EVENT_AUDIO_DMA(dma_ch\n\t\t\t\t\t\t\t\t\t - 1) |\n\t\t\t\t\t  PS3_AUDIO_KICK_REQUEST);\n\t\t}\n\t}\n\t \n\twmb();\n\tspin_unlock_irqrestore(&card->dma_lock, irqsave);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t snd_ps3_interrupt(int irq, void *dev_id)\n{\n\n\tuint32_t port_intr;\n\tint underflow_occured = 0;\n\tstruct snd_ps3_card_info *card = dev_id;\n\n\tif (!card->running) {\n\t\tupdate_reg(PS3_AUDIO_AX_IS, 0);\n\t\tupdate_reg(PS3_AUDIO_INTR_0, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tport_intr = read_reg(PS3_AUDIO_AX_IS);\n\t \n\tif (port_intr & PS3_AUDIO_AX_IE_ASOBEIE(0)) {\n\t\twrite_reg(PS3_AUDIO_AX_IS, PS3_AUDIO_AX_IE_ASOBEIE(0));\n\t\tif (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {\n\t\t\twrite_reg(PS3_AUDIO_AX_IS, port_intr);\n\t\t\tunderflow_occured = 1;\n\t\t}\n\t\tif (card->silent) {\n\t\t\t \n\t\t\tsnd_ps3_program_dma(card,\n\t\t\t\t(underflow_occured) ?\n\t\t\t\tSND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL :\n\t\t\t\tSND_PS3_DMA_FILLTYPE_SILENT_RUNNING);\n\t\t\tsnd_ps3_kick_dma(card);\n\t\t\tcard->silent--;\n\t\t} else {\n\t\t\tsnd_ps3_program_dma(card,\n\t\t\t\t(underflow_occured) ?\n\t\t\t\tSND_PS3_DMA_FILLTYPE_FIRSTFILL :\n\t\t\t\tSND_PS3_DMA_FILLTYPE_RUNNING);\n\t\t\tsnd_ps3_kick_dma(card);\n\t\t\tsnd_pcm_period_elapsed(card->substream);\n\t\t}\n\t} else if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {\n\t\twrite_reg(PS3_AUDIO_AX_IS, PS3_AUDIO_AX_IE_ASOBUIE(0));\n\t\t \n\t\tsnd_ps3_program_dma(card,\n\t\t\t\t    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\n\t\tsnd_ps3_kick_dma(card);\n\t\tsnd_ps3_program_dma(card,\n\t\t\t\t    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\n\t\tsnd_ps3_kick_dma(card);\n\t}\n\t \n\treturn IRQ_HANDLED;\n};\n\n \nstatic int snd_ps3_mute(int mute_on)\n{\n\treturn ps3av_audio_mute(mute_on);\n}\n\n \nstatic int snd_ps3_change_avsetting(struct snd_ps3_card_info *card)\n{\n\tint ret, retries, i;\n\tpr_debug(\"%s: start\\n\", __func__);\n\n\tret = ps3av_set_audio_mode(card->avs.avs_audio_ch,\n\t\t\t\t  card->avs.avs_audio_rate,\n\t\t\t\t  card->avs.avs_audio_width,\n\t\t\t\t  card->avs.avs_audio_format,\n\t\t\t\t  card->avs.avs_audio_source);\n\t \n\n\t \n\tupdate_mask_reg(PS3_AUDIO_AO_3WMCTRL,\n\t\t\t~(PS3_AUDIO_AO_3WMCTRL_ASOEN(0) |\n\t\t\t  PS3_AUDIO_AO_3WMCTRL_ASOEN(1) |\n\t\t\t  PS3_AUDIO_AO_3WMCTRL_ASOEN(2) |\n\t\t\t  PS3_AUDIO_AO_3WMCTRL_ASOEN(3)),\n\t\t\t0);\n\twmb();\t \n\t \n\tretries = 1000;\n\twhile ((read_reg(PS3_AUDIO_AO_3WMCTRL) &\n\t\t(PS3_AUDIO_AO_3WMCTRL_ASORUN(0) |\n\t\t PS3_AUDIO_AO_3WMCTRL_ASORUN(1) |\n\t\t PS3_AUDIO_AO_3WMCTRL_ASORUN(2) |\n\t\t PS3_AUDIO_AO_3WMCTRL_ASORUN(3))) &&\n\t       --retries) {\n\t\tudelay(1);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tupdate_reg(PS3_AUDIO_AO_3WCTRL(i),\n\t\t\t   PS3_AUDIO_AO_3WCTRL_ASOBRST_RESET);\n\t\tudelay(10);\n\t}\n\twmb();  \n\n\t \n\tupdate_reg(PS3_AUDIO_AO_3WMCTRL, PS3_AUDIO_AO_3WMCTRL_ASOEN(0));\n\n\n\t \n\tupdate_mask_reg(PS3_AUDIO_AO_3WCTRL(0),\n\t\t\t~PS3_AUDIO_AO_3WCTRL_ASODF,\n\t\t\tPS3_AUDIO_AO_3WCTRL_ASODF_LSB);\n\tupdate_mask_reg(PS3_AUDIO_AO_SPDCTRL(0),\n\t\t\t~PS3_AUDIO_AO_SPDCTRL_SPODF,\n\t\t\tPS3_AUDIO_AO_SPDCTRL_SPODF_LSB);\n\t \n\twmb();\n\t \n\tpr_debug(\"%s: end\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic int snd_ps3_set_avsetting(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\n\tstruct snd_ps3_avsetting_info avs;\n\tint ret;\n\n\tavs = card->avs;\n\n\tpr_debug(\"%s: called freq=%d width=%d\\n\", __func__,\n\t\t substream->runtime->rate,\n\t\t snd_pcm_format_width(substream->runtime->format));\n\n\tpr_debug(\"%s: before freq=%d width=%d\\n\", __func__,\n\t\t card->avs.avs_audio_rate, card->avs.avs_audio_width);\n\n\t \n\tswitch (substream->runtime->rate) {\n\tcase 44100:\n\t\tavs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_44K;\n\t\tbreak;\n\tcase 48000:\n\t\tavs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;\n\t\tbreak;\n\tcase 88200:\n\t\tavs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_88K;\n\t\tbreak;\n\tcase 96000:\n\t\tavs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_96K;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: invalid rate %d\\n\", __func__,\n\t\t\tsubstream->runtime->rate);\n\t\treturn 1;\n\t}\n\n\t \n\tswitch (snd_pcm_format_width(substream->runtime->format)) {\n\tcase 16:\n\t\tavs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;\n\t\tbreak;\n\tcase 24:\n\t\tavs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_24;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: invalid width %d\\n\", __func__,\n\t\t\tsnd_pcm_format_width(substream->runtime->format));\n\t\treturn 1;\n\t}\n\n\tmemcpy(avs.avs_cs_info, ps3av_mode_cs_info, 8);\n\n\tif (memcmp(&card->avs, &avs, sizeof(avs))) {\n\t\tpr_debug(\"%s: after freq=%d width=%d\\n\", __func__,\n\t\t\t card->avs.avs_audio_rate, card->avs.avs_audio_width);\n\n\t\tcard->avs = avs;\n\t\tsnd_ps3_change_avsetting(card);\n\t\tret = 0;\n\t} else\n\t\tret = 1;\n\n\t \n\tif (avs.avs_cs_info[0] & 0x02)\n\t\tps3av_audio_mute_analog(1);  \n\telse\n\t\tps3av_audio_mute_analog(0);\n\n\treturn ret;\n}\n\n \nstatic int snd_ps3_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\n\n\t \n\tcard->substream = substream;\n\n\truntime->hw = snd_ps3_pcm_hw;\n\n\tcard->start_delay = snd_ps3_start_delay;\n\n\t \n\tsnd_ps3_mute(0);  \n\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   PS3_AUDIO_FIFO_STAGE_SIZE * 4 * 2);\n\treturn 0;\n};\n\nstatic int snd_ps3_pcm_close(struct snd_pcm_substream *substream)\n{\n\t \n\tsnd_ps3_mute(1);\n\treturn 0;\n};\n\nstatic int snd_ps3_delay_to_bytes(struct snd_pcm_substream *substream,\n\t\t\t\t  unsigned int delay_ms)\n{\n\tint ret;\n\tint rate ;\n\n\trate = substream->runtime->rate;\n\tret = snd_pcm_format_size(substream->runtime->format,\n\t\t\t\t  rate * delay_ms / 1000)\n\t\t* substream->runtime->channels;\n\n\tpr_debug(\"%s: time=%d rate=%d bytes=%ld, frames=%d, ret=%d\\n\",\n\t\t __func__,\n\t\t delay_ms,\n\t\t rate,\n\t\t snd_pcm_format_size(substream->runtime->format, rate),\n\t\t rate * delay_ms / 1000,\n\t\t ret);\n\n\treturn ret;\n};\n\nstatic int snd_ps3_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\n\tunsigned long irqsave;\n\n\tif (!snd_ps3_set_avsetting(substream)) {\n\t\t \n\t\twrite_reg(PS3_AUDIO_AX_IE,\n\t\t\t  PS3_AUDIO_AX_IE_ASOBEIE(0) |\n\t\t\t  PS3_AUDIO_AX_IE_ASOBUIE(0));\n\t\t \n\t\tcard->silent = snd_ps3_delay_to_bytes(substream,\n\t\t\t\t\t\t      card->start_delay) /\n\t\t\t(PS3_AUDIO_FIFO_STAGE_SIZE * 4);  \n\t}\n\n\t \n\tspin_lock_irqsave(&card->dma_lock, irqsave);\n\t{\n\t\tcard->dma_buffer_size = runtime->dma_bytes;\n\n\t\tcard->dma_last_transfer_vaddr[SND_PS3_CH_L] =\n\t\t\tcard->dma_next_transfer_vaddr[SND_PS3_CH_L] =\n\t\t\tcard->dma_start_vaddr[SND_PS3_CH_L] =\n\t\t\truntime->dma_area;\n\t\tcard->dma_start_bus_addr[SND_PS3_CH_L] = runtime->dma_addr;\n\n\t\tcard->dma_last_transfer_vaddr[SND_PS3_CH_R] =\n\t\t\tcard->dma_next_transfer_vaddr[SND_PS3_CH_R] =\n\t\t\tcard->dma_start_vaddr[SND_PS3_CH_R] =\n\t\t\truntime->dma_area + (runtime->dma_bytes / 2);\n\t\tcard->dma_start_bus_addr[SND_PS3_CH_R] =\n\t\t\truntime->dma_addr + (runtime->dma_bytes / 2);\n\n\t\tpr_debug(\"%s: vaddr=%p bus=%#llx\\n\", __func__,\n\t\t\t card->dma_start_vaddr[SND_PS3_CH_L],\n\t\t\t card->dma_start_bus_addr[SND_PS3_CH_L]);\n\n\t}\n\tspin_unlock_irqrestore(&card->dma_lock, irqsave);\n\n\t \n\tmb();\n\n\treturn 0;\n};\n\nstatic int snd_ps3_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd)\n{\n\tstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tupdate_reg(PS3_AUDIO_AX_IS, 0);\n\n\t\tspin_lock(&card->dma_lock);\n\t\t{\n\t\t\tcard->running = 1;\n\t\t}\n\t\tspin_unlock(&card->dma_lock);\n\n\t\tsnd_ps3_program_dma(card,\n\t\t\t\t    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\n\t\tsnd_ps3_kick_dma(card);\n\t\twhile (read_reg(PS3_AUDIO_KICK(7)) &\n\t\t       PS3_AUDIO_KICK_STATUS_MASK) {\n\t\t\tudelay(1);\n\t\t}\n\t\tsnd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);\n\t\tsnd_ps3_kick_dma(card);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock(&card->dma_lock);\n\t\t{\n\t\t\tcard->running = 0;\n\t\t}\n\t\tspin_unlock(&card->dma_lock);\n\t\tsnd_ps3_wait_for_dma_stop(card);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n};\n\n \nstatic snd_pcm_uframes_t snd_ps3_pcm_pointer(\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\n\tsize_t bytes;\n\tsnd_pcm_uframes_t ret;\n\n\tspin_lock(&card->dma_lock);\n\t{\n\t\tbytes = (size_t)(card->dma_last_transfer_vaddr[SND_PS3_CH_L] -\n\t\t\t\t card->dma_start_vaddr[SND_PS3_CH_L]);\n\t}\n\tspin_unlock(&card->dma_lock);\n\n\tret = bytes_to_frames(substream->runtime, bytes * 2);\n\n\treturn ret;\n};\n\n \nstatic int snd_ps3_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\n \nstatic int snd_ps3_spdif_cmask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff, 8);\n\treturn 0;\n}\n\nstatic int snd_ps3_spdif_pmask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\treturn 0;\n}\n\nstatic int snd_ps3_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tmemcpy(ucontrol->value.iec958.status, ps3av_mode_cs_info, 8);\n\treturn 0;\n}\n\nstatic int snd_ps3_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tif (memcmp(ps3av_mode_cs_info, ucontrol->value.iec958.status, 8)) {\n\t\tmemcpy(ps3av_mode_cs_info, ucontrol->value.iec958.status, 8);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new spdif_ctls[] = {\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.info = snd_ps3_spdif_mask_info,\n\t\t.get = snd_ps3_spdif_cmask_get,\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PRO_MASK),\n\t\t.info = snd_ps3_spdif_mask_info,\n\t\t.get = snd_ps3_spdif_pmask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = snd_ps3_spdif_mask_info,\n\t\t.get = snd_ps3_spdif_default_get,\n\t\t.put = snd_ps3_spdif_default_put,\n\t},\n};\n\nstatic const struct snd_pcm_ops snd_ps3_pcm_spdif_ops = {\n\t.open = snd_ps3_pcm_open,\n\t.close = snd_ps3_pcm_close,\n\t.prepare = snd_ps3_pcm_prepare,\n\t.trigger = snd_ps3_pcm_trigger,\n\t.pointer = snd_ps3_pcm_pointer,\n};\n\n\nstatic int snd_ps3_map_mmio(void)\n{\n\tthe_card.mapped_mmio_vaddr =\n\t\tioremap(the_card.ps3_dev->m_region->bus_addr,\n\t\t\tthe_card.ps3_dev->m_region->len);\n\n\tif (!the_card.mapped_mmio_vaddr) {\n\t\tpr_info(\"%s: ioremap 0 failed p=%#lx l=%#lx \\n\",\n\t\t       __func__, the_card.ps3_dev->m_region->lpar_addr,\n\t\t       the_card.ps3_dev->m_region->len);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n};\n\nstatic void snd_ps3_unmap_mmio(void)\n{\n\tiounmap(the_card.mapped_mmio_vaddr);\n\tthe_card.mapped_mmio_vaddr = NULL;\n}\n\nstatic int snd_ps3_allocate_irq(void)\n{\n\tint ret;\n\tu64 lpar_addr, lpar_size;\n\tu64 __iomem *mapped;\n\n\t \n\n\t \n\tret = lv1_gpu_device_map(1, &lpar_addr, &lpar_size);\n\tif (ret) {\n\t\tpr_info(\"%s: device map 1 failed %d\\n\", __func__,\n\t\t\tret);\n\t\treturn -ENXIO;\n\t}\n\n\tmapped = ioremap(lpar_addr, lpar_size);\n\tif (!mapped) {\n\t\tpr_info(\"%s: ioremap 1 failed \\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tthe_card.audio_irq_outlet = in_be64(mapped);\n\n\tiounmap(mapped);\n\tret = lv1_gpu_device_unmap(1);\n\tif (ret)\n\t\tpr_info(\"%s: unmap 1 failed\\n\", __func__);\n\n\t \n\tret = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY,\n\t\t\t\t the_card.audio_irq_outlet,\n\t\t\t\t &the_card.irq_no);\n\tif (ret) {\n\t\tpr_info(\"%s:ps3_alloc_irq failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = request_irq(the_card.irq_no, snd_ps3_interrupt, 0,\n\t\t\t  SND_PS3_DRIVER_NAME, &the_card);\n\tif (ret) {\n\t\tpr_info(\"%s: request_irq failed (%d)\\n\", __func__, ret);\n\t\tgoto cleanup_irq;\n\t}\n\n\treturn 0;\n\n cleanup_irq:\n\tps3_irq_plug_destroy(the_card.irq_no);\n\treturn ret;\n};\n\nstatic void snd_ps3_free_irq(void)\n{\n\tfree_irq(the_card.irq_no, &the_card);\n\tps3_irq_plug_destroy(the_card.irq_no);\n}\n\nstatic void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start)\n{\n\tuint64_t val;\n\tint ret;\n\n\tval = (ioaddr_start & (0x0fUL << 32)) >> (32 - 20) |\n\t\t(0x03UL << 24) |\n\t\t(0x0fUL << 12) |\n\t\t(PS3_AUDIO_IOID);\n\n\tret = lv1_gpu_attribute(0x100, 0x007, val);\n\tif (ret)\n\t\tpr_info(\"%s: gpu_attribute failed %d\\n\", __func__,\n\t\t\tret);\n}\n\nstatic void snd_ps3_audio_fixup(struct snd_ps3_card_info *card)\n{\n\t \n\n\t \n\twrite_reg(PS3_AUDIO_INTR_EN_0, 0);\n\n\t \n\tupdate_mask_reg(PS3_AUDIO_AX_IC,\n\t\t\tPS3_AUDIO_AX_IC_AASOIMD_MASK,\n\t\t\tPS3_AUDIO_AX_IC_AASOIMD_EVERY4);\n\n\t \n\tupdate_mask_reg(PS3_AUDIO_AO_3WMCTRL,\n\t\t\t~(PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED |\n\t\t\t  PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED),\n\t\t\t0);\n\tupdate_reg(PS3_AUDIO_AO_3WMCTRL,\n\t\t   PS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT);\n}\n\nstatic int snd_ps3_init_avsetting(struct snd_ps3_card_info *card)\n{\n\tint ret;\n\tpr_debug(\"%s: start\\n\", __func__);\n\tcard->avs.avs_audio_ch = PS3AV_CMD_AUDIO_NUM_OF_CH_2;\n\tcard->avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;\n\tcard->avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;\n\tcard->avs.avs_audio_format = PS3AV_CMD_AUDIO_FORMAT_PCM;\n\tcard->avs.avs_audio_source = PS3AV_CMD_AUDIO_SOURCE_SERIAL;\n\tmemcpy(card->avs.avs_cs_info, ps3av_mode_cs_info, 8);\n\n\tret = snd_ps3_change_avsetting(card);\n\n\tsnd_ps3_audio_fixup(card);\n\n\t \n\tsnd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\n\tsnd_ps3_kick_dma(card);\n\tpr_debug(\"%s: end\\n\", __func__);\n\treturn ret;\n}\n\nstatic int snd_ps3_driver_probe(struct ps3_system_bus_device *dev)\n{\n\tint i, ret;\n\tu64 lpar_addr, lpar_size;\n\tstatic u64 dummy_mask;\n\n\tthe_card.ps3_dev = dev;\n\n\tret = ps3_open_hv_device(dev);\n\n\tif (ret)\n\t\treturn -ENXIO;\n\n\t \n\tret = lv1_gpu_device_map(2, &lpar_addr, &lpar_size);\n\tif (ret) {\n\t\tpr_info(\"%s: device map 2 failed %d\\n\", __func__, ret);\n\t\tgoto clean_open;\n\t}\n\tps3_mmio_region_init(dev, dev->m_region, lpar_addr, lpar_size,\n\t\tPAGE_SHIFT);\n\n\tret = snd_ps3_map_mmio();\n\tif (ret)\n\t\tgoto clean_dev_map;\n\n\t \n\tps3_dma_region_init(dev, dev->d_region,\n\t\t\t    PAGE_SHIFT,  \n\t\t\t    0,  \n\t\t\t    NULL,\n\t\t\t    ALIGN(SND_PS3_DMA_REGION_SIZE, PAGE_SIZE));\n\tdev->d_region->ioid = PS3_AUDIO_IOID;\n\n\tret = ps3_dma_region_create(dev->d_region);\n\tif (ret) {\n\t\tpr_info(\"%s: region_create\\n\", __func__);\n\t\tgoto clean_mmio;\n\t}\n\n\tdummy_mask = DMA_BIT_MASK(32);\n\tdev->core.dma_mask = &dummy_mask;\n\tdma_set_coherent_mask(&dev->core, dummy_mask);\n\n\tsnd_ps3_audio_set_base_addr(dev->d_region->bus_addr);\n\n\t \n\tthe_card.start_delay = snd_ps3_start_delay;\n\n\t \n\tif (snd_ps3_allocate_irq()) {\n\t\tret = -ENXIO;\n\t\tgoto clean_dma_region;\n\t}\n\n\t \n\tret = snd_card_new(&dev->core, index, id, THIS_MODULE,\n\t\t\t   0, &the_card.card);\n\tif (ret < 0)\n\t\tgoto clean_irq;\n\n\tstrcpy(the_card.card->driver, \"PS3\");\n\tstrcpy(the_card.card->shortname, \"PS3\");\n\tstrcpy(the_card.card->longname, \"PS3 sound\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(spdif_ctls); i++) {\n\t\tret = snd_ctl_add(the_card.card,\n\t\t\t\t  snd_ctl_new1(&spdif_ctls[i], &the_card));\n\t\tif (ret < 0)\n\t\t\tgoto clean_card;\n\t}\n\n\t \n\t \n\tret = snd_pcm_new(the_card.card,\n\t\t\t  \"SPDIF\",\n\t\t\t  0,  \n\t\t\t  1,  \n\t\t\t  0,  \n\t\t\t  &(the_card.pcm));\n\tif (ret)\n\t\tgoto clean_card;\n\n\tthe_card.pcm->private_data = &the_card;\n\tstrcpy(the_card.pcm->name, \"SPDIF\");\n\n\t \n\tsnd_pcm_set_ops(the_card.pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_ps3_pcm_spdif_ops);\n\n\tthe_card.pcm->info_flags = SNDRV_PCM_INFO_NONINTERLEAVED;\n\t \n\tsnd_pcm_set_managed_buffer_all(the_card.pcm,\n\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &dev->core,\n\t\t\t\t       SND_PS3_PCM_PREALLOC_SIZE,\n\t\t\t\t       SND_PS3_PCM_PREALLOC_SIZE);\n\n\t \n\tthe_card.null_buffer_start_vaddr =\n\t\tdma_alloc_coherent(&the_card.ps3_dev->core,\n\t\t\t\t   PAGE_SIZE,\n\t\t\t\t   &the_card.null_buffer_start_dma_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (!the_card.null_buffer_start_vaddr) {\n\t\tpr_info(\"%s: nullbuffer alloc failed\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto clean_card;\n\t}\n\tpr_debug(\"%s: null vaddr=%p dma=%#llx\\n\", __func__,\n\t\t the_card.null_buffer_start_vaddr,\n\t\t the_card.null_buffer_start_dma_addr);\n\t \n\tsnd_ps3_init_avsetting(&the_card);\n\n\t \n\tret = snd_card_register(the_card.card);\n\tif (ret < 0)\n\t\tgoto clean_dma_map;\n\n\tpr_info(\"%s started. start_delay=%dms\\n\",\n\t\tthe_card.card->longname, the_card.start_delay);\n\treturn 0;\n\nclean_dma_map:\n\tdma_free_coherent(&the_card.ps3_dev->core,\n\t\t\t  PAGE_SIZE,\n\t\t\t  the_card.null_buffer_start_vaddr,\n\t\t\t  the_card.null_buffer_start_dma_addr);\nclean_card:\n\tsnd_card_free(the_card.card);\nclean_irq:\n\tsnd_ps3_free_irq();\nclean_dma_region:\n\tps3_dma_region_free(dev->d_region);\nclean_mmio:\n\tsnd_ps3_unmap_mmio();\nclean_dev_map:\n\tlv1_gpu_device_unmap(2);\nclean_open:\n\tps3_close_hv_device(dev);\n\t \n\treturn ret;\n};  \n\n \nstatic void snd_ps3_driver_remove(struct ps3_system_bus_device *dev)\n{\n\tpr_info(\"%s:start id=%d\\n\", __func__,  dev->match_id);\n\n\t \n\tsnd_card_free(the_card.card);\n\n\tdma_free_coherent(&dev->core,\n\t\t\t  PAGE_SIZE,\n\t\t\t  the_card.null_buffer_start_vaddr,\n\t\t\t  the_card.null_buffer_start_dma_addr);\n\n\tps3_dma_region_free(dev->d_region);\n\n\tsnd_ps3_free_irq();\n\tsnd_ps3_unmap_mmio();\n\n\tlv1_gpu_device_unmap(2);\n\tps3_close_hv_device(dev);\n\tpr_info(\"%s:end id=%d\\n\", __func__, dev->match_id);\n}  \n\nstatic struct ps3_system_bus_driver snd_ps3_bus_driver_info = {\n\t.match_id = PS3_MATCH_ID_SOUND,\n\t.probe = snd_ps3_driver_probe,\n\t.remove = snd_ps3_driver_remove,\n\t.shutdown = snd_ps3_driver_remove,\n\t.core = {\n\t\t.name = SND_PS3_DRIVER_NAME,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\n\n \nstatic int __init snd_ps3_init(void)\n{\n\tint ret;\n\n\tif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\n\t\treturn -ENXIO;\n\n\tmemset(&the_card, 0, sizeof(the_card));\n\tspin_lock_init(&the_card.dma_lock);\n\n\t \n\tret = ps3_system_bus_driver_register(&snd_ps3_bus_driver_info);\n\n\treturn ret;\n}\nmodule_init(snd_ps3_init);\n\nstatic void __exit snd_ps3_exit(void)\n{\n\tps3_system_bus_driver_unregister(&snd_ps3_bus_driver_info);\n}\nmodule_exit(snd_ps3_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PS3 sound driver\");\nMODULE_AUTHOR(\"Sony Computer Entertainment Inc.\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_SOUND);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}