{
  "module_name": "powermac.c",
  "hash_id": "1ab5fb4e908f79166cc41970c3df287a162bc85ba464ca6ed1b9b0f076b4df55",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/powermac.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include \"pmac.h\"\n#include \"awacs.h\"\n#include \"burgundy.h\"\n\n#define CHIP_NAME \"PMac\"\n\nMODULE_DESCRIPTION(\"PowerMac\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t\t \nstatic bool enable_beep = 1;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CHIP_NAME \" soundchip.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CHIP_NAME \" soundchip.\");\nmodule_param(enable_beep, bool, 0444);\nMODULE_PARM_DESC(enable_beep, \"Enable beep using PCM.\");\n\nstatic struct platform_device *device;\n\n\n \n\nstatic int snd_pmac_probe(struct platform_device *devptr)\n{\n\tstruct snd_card *card;\n\tstruct snd_pmac *chip;\n\tchar *name_ext;\n\tint err;\n\n\terr = snd_card_new(&devptr->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pmac_new(card, &chip);\n\tif (err < 0)\n\t\tgoto __error;\n\tcard->private_data = chip;\n\n\tswitch (chip->model) {\n\tcase PMAC_BURGUNDY:\n\t\tstrcpy(card->driver, \"PMac Burgundy\");\n\t\tstrcpy(card->shortname, \"PowerMac Burgundy\");\n\t\tsprintf(card->longname, \"%s (Dev %d) Sub-frame %d\",\n\t\t\tcard->shortname, chip->device_id, chip->subframe);\n\t\terr = snd_pmac_burgundy_init(chip);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\tbreak;\n\tcase PMAC_DACA:\n\t\tstrcpy(card->driver, \"PMac DACA\");\n\t\tstrcpy(card->shortname, \"PowerMac DACA\");\n\t\tsprintf(card->longname, \"%s (Dev %d) Sub-frame %d\",\n\t\t\tcard->shortname, chip->device_id, chip->subframe);\n\t\terr = snd_pmac_daca_init(chip);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\tbreak;\n\tcase PMAC_TUMBLER:\n\tcase PMAC_SNAPPER:\n\t\tname_ext = chip->model == PMAC_TUMBLER ? \"Tumbler\" : \"Snapper\";\n\t\tsprintf(card->driver, \"PMac %s\", name_ext);\n\t\tsprintf(card->shortname, \"PowerMac %s\", name_ext);\n\t\tsprintf(card->longname, \"%s (Dev %d) Sub-frame %d\",\n\t\t\tcard->shortname, chip->device_id, chip->subframe);\n\t\terr = snd_pmac_tumbler_init(chip);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_pmac_tumbler_post_init();\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\tbreak;\n\tcase PMAC_AWACS:\n\tcase PMAC_SCREAMER:\n\t\tname_ext = chip->model == PMAC_SCREAMER ? \"Screamer\" : \"AWACS\";\n\t\tsprintf(card->driver, \"PMac %s\", name_ext);\n\t\tsprintf(card->shortname, \"PowerMac %s\", name_ext);\n\t\tif (chip->is_pbook_3400)\n\t\t\tname_ext = \" [PB3400]\";\n\t\telse if (chip->is_pbook_G3)\n\t\t\tname_ext = \" [PBG3]\";\n\t\telse\n\t\t\tname_ext = \"\";\n\t\tsprintf(card->longname, \"%s%s Rev %d\",\n\t\t\tcard->shortname, name_ext, chip->revision);\n\t\terr = snd_pmac_awacs_init(chip);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR \"unsupported hardware %d\\n\", chip->model);\n\t\terr = -EINVAL;\n\t\tgoto __error;\n\t}\n\n\terr = snd_pmac_pcm_new(chip);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tchip->initialized = 1;\n\tif (enable_beep)\n\t\tsnd_pmac_attach_beep(chip);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n\n__error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n\nstatic void snd_pmac_remove(struct platform_device *devptr)\n{\n\tsnd_card_free(platform_get_drvdata(devptr));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_pmac_driver_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tsnd_pmac_suspend(card->private_data);\n\treturn 0;\n}\n\nstatic int snd_pmac_driver_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tsnd_pmac_resume(card->private_data);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_pmac_pm, snd_pmac_driver_suspend, snd_pmac_driver_resume);\n#define SND_PMAC_PM_OPS\t&snd_pmac_pm\n#else\n#define SND_PMAC_PM_OPS\tNULL\n#endif\n\n#define SND_PMAC_DRIVER\t\t\"snd_powermac\"\n\nstatic struct platform_driver snd_pmac_driver = {\n\t.probe\t\t= snd_pmac_probe,\n\t.remove_new\t= snd_pmac_remove,\n\t.driver\t\t= {\n\t\t.name\t= SND_PMAC_DRIVER,\n\t\t.pm\t= SND_PMAC_PM_OPS,\n\t},\n};\n\nstatic int __init alsa_card_pmac_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&snd_pmac_driver);\n\tif (err < 0)\n\t\treturn err;\n\tdevice = platform_device_register_simple(SND_PMAC_DRIVER, -1, NULL, 0);\n\treturn 0;\n\n}\n\nstatic void __exit alsa_card_pmac_exit(void)\n{\n\tif (!IS_ERR(device))\n\t\tplatform_device_unregister(device);\n\tplatform_driver_unregister(&snd_pmac_driver);\n}\n\nmodule_init(alsa_card_pmac_init)\nmodule_exit(alsa_card_pmac_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}