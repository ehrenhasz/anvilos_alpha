{
  "module_name": "beep.c",
  "hash_id": "14eb8c39568e1d4f3878e2a17bb474fd1fe59591877717fabf5ad5850f5f5396",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/beep.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include \"pmac.h\"\n\nstruct pmac_beep {\n\tint running;\t\t \n\tint volume;\t\t \n\tint volume_play;\t \n\tint hz;\n\tint nsamples;\n\tshort *buf;\t\t \n\tdma_addr_t addr;\t \n\tstruct input_dev *dev;\n};\n\n \nvoid snd_pmac_beep_stop(struct snd_pmac *chip)\n{\n\tstruct pmac_beep *beep = chip->beep;\n\tif (beep && beep->running) {\n\t\tbeep->running = 0;\n\t\tsnd_pmac_beep_dma_stop(chip);\n\t}\n}\n\n \nstatic const short beep_wform[256] = {\n\t0,\t40,\t79,\t117,\t153,\t187,\t218,\t245,\n\t269,\t288,\t304,\t316,\t323,\t327,\t327,\t324,\n\t318,\t310,\t299,\t288,\t275,\t262,\t249,\t236,\n\t224,\t213,\t204,\t196,\t190,\t186,\t183,\t182,\n\t182,\t183,\t186,\t189,\t192,\t196,\t200,\t203,\n\t206,\t208,\t209,\t209,\t209,\t207,\t204,\t201,\n\t197,\t193,\t188,\t183,\t179,\t174,\t170,\t166,\n\t163,\t161,\t160,\t159,\t159,\t160,\t161,\t162,\n\t164,\t166,\t168,\t169,\t171,\t171,\t171,\t170,\n\t169,\t167,\t163,\t159,\t155,\t150,\t144,\t139,\n\t133,\t128,\t122,\t117,\t113,\t110,\t107,\t105,\n\t103,\t103,\t103,\t103,\t104,\t104,\t105,\t105,\n\t105,\t103,\t101,\t97,\t92,\t86,\t78,\t68,\n\t58,\t45,\t32,\t18,\t3,\t-11,\t-26,\t-41,\n\t-55,\t-68,\t-79,\t-88,\t-95,\t-100,\t-102,\t-102,\n\t-99,\t-93,\t-85,\t-75,\t-62,\t-48,\t-33,\t-16,\n\t0,\t16,\t33,\t48,\t62,\t75,\t85,\t93,\n\t99,\t102,\t102,\t100,\t95,\t88,\t79,\t68,\n\t55,\t41,\t26,\t11,\t-3,\t-18,\t-32,\t-45,\n\t-58,\t-68,\t-78,\t-86,\t-92,\t-97,\t-101,\t-103,\n\t-105,\t-105,\t-105,\t-104,\t-104,\t-103,\t-103,\t-103,\n\t-103,\t-105,\t-107,\t-110,\t-113,\t-117,\t-122,\t-128,\n\t-133,\t-139,\t-144,\t-150,\t-155,\t-159,\t-163,\t-167,\n\t-169,\t-170,\t-171,\t-171,\t-171,\t-169,\t-168,\t-166,\n\t-164,\t-162,\t-161,\t-160,\t-159,\t-159,\t-160,\t-161,\n\t-163,\t-166,\t-170,\t-174,\t-179,\t-183,\t-188,\t-193,\n\t-197,\t-201,\t-204,\t-207,\t-209,\t-209,\t-209,\t-208,\n\t-206,\t-203,\t-200,\t-196,\t-192,\t-189,\t-186,\t-183,\n\t-182,\t-182,\t-183,\t-186,\t-190,\t-196,\t-204,\t-213,\n\t-224,\t-236,\t-249,\t-262,\t-275,\t-288,\t-299,\t-310,\n\t-318,\t-324,\t-327,\t-327,\t-323,\t-316,\t-304,\t-288,\n\t-269,\t-245,\t-218,\t-187,\t-153,\t-117,\t-79,\t-40,\n};\n\n#define BEEP_SRATE\t22050\t \n#define BEEP_BUFLEN\t512\n#define BEEP_VOLUME\t15\t \n\nstatic int snd_pmac_beep_event(struct input_dev *dev, unsigned int type,\n\t\t\t       unsigned int code, int hz)\n{\n\tstruct snd_pmac *chip;\n\tstruct pmac_beep *beep;\n\tunsigned long flags;\n\tint beep_speed = 0;\n\tint srate;\n\tint period, ncycles, nsamples;\n\tint i, j, f;\n\tshort *p;\n\n\tif (type != EV_SND)\n\t\treturn -1;\n\n\tswitch (code) {\n\tcase SND_BELL: if (hz) hz = 1000; break;\n\tcase SND_TONE: break;\n\tdefault: return -1;\n\t}\n\n\tchip = input_get_drvdata(dev);\n\tif (!chip)\n\t\treturn -1;\n\tbeep = chip->beep;\n\tif (!beep)\n\t\treturn -1;\n\n\tif (! hz) {\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t\tif (beep->running)\n\t\t\tsnd_pmac_beep_stop(chip);\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn 0;\n\t}\n\n\tbeep_speed = snd_pmac_rate_index(chip, &chip->playback, BEEP_SRATE);\n\tsrate = chip->freq_table[beep_speed];\n\n\tif (hz <= srate / BEEP_BUFLEN || hz > srate / 2)\n\t\thz = 1000;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->playback.running || chip->capture.running || beep->running) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn 0;\n\t}\n\tbeep->running = 1;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tif (hz == beep->hz && beep->volume == beep->volume_play) {\n\t\tnsamples = beep->nsamples;\n\t} else {\n\t\tperiod = srate * 256 / hz;\t \n\t\tncycles = BEEP_BUFLEN * 256 / period;\n\t\tnsamples = (period * ncycles) >> 8;\n\t\tf = ncycles * 65536 / nsamples;\n\t\tj = 0;\n\t\tp = beep->buf;\n\t\tfor (i = 0; i < nsamples; ++i, p += 2) {\n\t\t\tp[0] = p[1] = beep_wform[j >> 8] * beep->volume;\n\t\t\tj = (j + f) & 0xffff;\n\t\t}\n\t\tbeep->hz = hz;\n\t\tbeep->volume_play = beep->volume;\n\t\tbeep->nsamples = nsamples;\n\t}\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_pmac_beep_dma_start(chip, beep->nsamples * 4, beep->addr, beep_speed);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int snd_pmac_info_beep(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\treturn 0;\n}\n\nstatic int snd_pmac_get_beep(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tif (snd_BUG_ON(!chip->beep))\n\t\treturn -ENXIO;\n\tucontrol->value.integer.value[0] = chip->beep->volume;\n\treturn 0;\n}\n\nstatic int snd_pmac_put_beep(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int oval, nval;\n\tif (snd_BUG_ON(!chip->beep))\n\t\treturn -ENXIO;\n\toval = chip->beep->volume;\n\tnval = ucontrol->value.integer.value[0];\n\tif (nval > 100)\n\t\treturn -EINVAL;\n\tchip->beep->volume = nval;\n\treturn oval != chip->beep->volume;\n}\n\nstatic const struct snd_kcontrol_new snd_pmac_beep_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Beep Playback Volume\",\n\t.info = snd_pmac_info_beep,\n\t.get = snd_pmac_get_beep,\n\t.put = snd_pmac_put_beep,\n};\n\n \nint snd_pmac_attach_beep(struct snd_pmac *chip)\n{\n\tstruct pmac_beep *beep;\n\tstruct input_dev *input_dev;\n\tstruct snd_kcontrol *beep_ctl;\n\tvoid *dmabuf;\n\tint err = -ENOMEM;\n\n\tbeep = kzalloc(sizeof(*beep), GFP_KERNEL);\n\tif (! beep)\n\t\treturn -ENOMEM;\n\tdmabuf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\n\t\t\t\t    &beep->addr, GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (! dmabuf || ! input_dev)\n\t\tgoto fail1;\n\n\t \n\tinput_dev->name = \"PowerMac Beep\";\n\tinput_dev->phys = \"powermac/beep\";\n\tinput_dev->id.bustype = BUS_ADB;\n\tinput_dev->id.vendor = 0x001f;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_SND);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\tinput_dev->event = snd_pmac_beep_event;\n\tinput_dev->dev.parent = &chip->pdev->dev;\n\tinput_set_drvdata(input_dev, chip);\n\n\tbeep->dev = input_dev;\n\tbeep->buf = dmabuf;\n\tbeep->volume = BEEP_VOLUME;\n\tbeep->running = 0;\n\n\tbeep_ctl = snd_ctl_new1(&snd_pmac_beep_mixer, chip);\n\terr = snd_ctl_add(chip->card, beep_ctl);\n\tif (err < 0)\n\t\tgoto fail1;\n\n\tchip->beep = beep;\n\n\terr = input_register_device(beep->dev);\n\tif (err)\n\t\tgoto fail2;\n \n \treturn 0;\n \n fail2:\tsnd_ctl_remove(chip->card, beep_ctl);\n fail1:\tinput_free_device(input_dev);\n\tif (dmabuf)\n\t\tdma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\n\t\t\t\t  dmabuf, beep->addr);\n\tkfree(beep);\n\treturn err;\n}\n\nvoid snd_pmac_detach_beep(struct snd_pmac *chip)\n{\n\tif (chip->beep) {\n\t\tinput_unregister_device(chip->beep->dev);\n\t\tdma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\n\t\t\t\t  chip->beep->buf, chip->beep->addr);\n\t\tkfree(chip->beep);\n\t\tchip->beep = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}