{
  "module_name": "awacs.c",
  "hash_id": "d9e84b7b220863c028eca43b01894bb97844d0895d403d9e4ed3e00fe71fea50",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/awacs.c",
  "human_readable_source": "\n \n\n\n#include <linux/io.h>\n#include <asm/nvram.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include \"pmac.h\"\n\n\n#ifdef CONFIG_ADB_CUDA\n#define PMAC_AMP_AVAIL\n#endif\n\n#ifdef PMAC_AMP_AVAIL\nstruct awacs_amp {\n\tunsigned char amp_master;\n\tunsigned char amp_vol[2][2];\n\tunsigned char amp_tone[2];\n};\n\n#define CHECK_CUDA_AMP() (sys_ctrler == SYS_CTRLER_CUDA)\n\n#endif  \n\n\nstatic void snd_pmac_screamer_wait(struct snd_pmac *chip)\n{\n\tlong timeout = 2000;\n\twhile (!(in_le32(&chip->awacs->codec_stat) & MASK_VALID)) {\n\t\tmdelay(1);\n\t\tif (! --timeout) {\n\t\t\tsnd_printd(\"snd_pmac_screamer_wait timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void\nsnd_pmac_awacs_write(struct snd_pmac *chip, int val)\n{\n\tlong timeout = 5000000;\n\n\tif (chip->model == PMAC_SCREAMER)\n\t\tsnd_pmac_screamer_wait(chip);\n\tout_le32(&chip->awacs->codec_ctrl, val | (chip->subframe << 22));\n\twhile (in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) {\n\t\tif (! --timeout) {\n\t\t\tsnd_printd(\"snd_pmac_awacs_write timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nsnd_pmac_awacs_write_reg(struct snd_pmac *chip, int reg, int val)\n{\n\tsnd_pmac_awacs_write(chip, val | (reg << 12));\n\tchip->awacs_reg[reg] = val;\n}\n\nstatic void\nsnd_pmac_awacs_write_noreg(struct snd_pmac *chip, int reg, int val)\n{\n\tsnd_pmac_awacs_write(chip, val | (reg << 12));\n}\n\n#ifdef CONFIG_PM\n \nstatic void screamer_recalibrate(struct snd_pmac *chip)\n{\n\tif (chip->model != PMAC_SCREAMER)\n\t\treturn;\n\n\t \n\tsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\n\tif (chip->manufacturer == 0x1)\n\t\t \n\t\tmsleep(750);\n\tsnd_pmac_awacs_write_noreg(chip, 1,\n\t\t\t\t   chip->awacs_reg[1] | MASK_RECALIBRATE |\n\t\t\t\t   MASK_CMUTE | MASK_AMUTE);\n\tsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\n\tsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\n}\n\n#else\n#define screamer_recalibrate(chip)  \n#endif\n\n\n \nstatic void snd_pmac_awacs_set_format(struct snd_pmac *chip)\n{\n\tchip->awacs_reg[1] &= ~MASK_SAMPLERATE;\n\tchip->awacs_reg[1] |= chip->rate_index << 3;\n\tsnd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);\n}\n\n\n \n \nstatic int snd_pmac_awacs_info_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 15;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_get_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint lshift = (kcontrol->private_value >> 8) & 0xff;\n\tint inverted = (kcontrol->private_value >> 16) & 1;\n\tunsigned long flags;\n\tint vol[2];\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tvol[0] = (chip->awacs_reg[reg] >> lshift) & 0xf;\n\tvol[1] = chip->awacs_reg[reg] & 0xf;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (inverted) {\n\t\tvol[0] = 0x0f - vol[0];\n\t\tvol[1] = 0x0f - vol[1];\n\t}\n\tucontrol->value.integer.value[0] = vol[0];\n\tucontrol->value.integer.value[1] = vol[1];\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint lshift = (kcontrol->private_value >> 8) & 0xff;\n\tint inverted = (kcontrol->private_value >> 16) & 1;\n\tint val, oldval;\n\tunsigned long flags;\n\tunsigned int vol[2];\n\n\tvol[0] = ucontrol->value.integer.value[0];\n\tvol[1] = ucontrol->value.integer.value[1];\n\tif (vol[0] > 0x0f || vol[1] > 0x0f)\n\t\treturn -EINVAL;\n\tif (inverted) {\n\t\tvol[0] = 0x0f - vol[0];\n\t\tvol[1] = 0x0f - vol[1];\n\t}\n\tvol[0] &= 0x0f;\n\tvol[1] &= 0x0f;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toldval = chip->awacs_reg[reg];\n\tval = oldval & ~(0xf | (0xf << lshift));\n\tval |= vol[0] << lshift;\n\tval |= vol[1];\n\tif (oldval != val)\n\t\tsnd_pmac_awacs_write_reg(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn oldval != reg;\n}\n\n\n#define AWACS_VOLUME(xname, xreg, xshift, xinverted) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0, \\\n  .info = snd_pmac_awacs_info_volume, \\\n  .get = snd_pmac_awacs_get_volume, \\\n  .put = snd_pmac_awacs_put_volume, \\\n  .private_value = (xreg) | ((xshift) << 8) | ((xinverted) << 16) }\n\n \nstatic int snd_pmac_awacs_get_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint invert = (kcontrol->private_value >> 16) & 1;\n\tint val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = (chip->awacs_reg[reg] >> shift) & 1;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (invert)\n\t\tval = 1 - val;\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint invert = (kcontrol->private_value >> 16) & 1;\n\tint mask = 1 << shift;\n\tint val, changed;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = chip->awacs_reg[reg] & ~mask;\n\tif (ucontrol->value.integer.value[0] != invert)\n\t\tval |= mask;\n\tchanged = chip->awacs_reg[reg] != val;\n\tif (changed)\n\t\tsnd_pmac_awacs_write_reg(chip, reg, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn changed;\n}\n\n#define AWACS_SWITCH(xname, xreg, xshift, xinvert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0, \\\n  .info = snd_pmac_boolean_mono_info, \\\n  .get = snd_pmac_awacs_get_switch, \\\n  .put = snd_pmac_awacs_put_switch, \\\n  .private_value = (xreg) | ((xshift) << 8) | ((xinvert) << 16) }\n\n\n#ifdef PMAC_AMP_AVAIL\n \nstatic void awacs_set_cuda(int reg, int val)\n{\n\tstruct adb_request req;\n\tcuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a,\n\t\t\treg, val);\n\twhile (! req.complete)\n\t\tcuda_poll();\n}\n\n \nstatic void awacs_amp_set_tone(struct awacs_amp *amp, int bass, int treble)\n{\n\tamp->amp_tone[0] = bass;\n\tamp->amp_tone[1] = treble;\n\tif (bass > 7)\n\t\tbass = (14 - bass) + 8;\n\tif (treble > 7)\n\t\ttreble = (14 - treble) + 8;\n\tawacs_set_cuda(2, (bass << 4) | treble);\n}\n\n \nstatic int awacs_amp_set_vol(struct awacs_amp *amp, int index,\n\t\t\t     int lvol, int rvol, int do_check)\n{\n\tif (do_check && amp->amp_vol[index][0] == lvol &&\n\t\t\tamp->amp_vol[index][1] == rvol)\n\t\treturn 0;\n\tawacs_set_cuda(3 + index, lvol);\n\tawacs_set_cuda(5 + index, rvol);\n\tamp->amp_vol[index][0] = lvol;\n\tamp->amp_vol[index][1] = rvol;\n\treturn 1;\n}\n\n \nstatic void awacs_amp_set_master(struct awacs_amp *amp, int vol)\n{\n\tamp->amp_master = vol;\n\tif (vol <= 79)\n\t\tvol = 32 + (79 - vol);\n\telse\n\t\tvol = 32 - (vol - 79);\n\tawacs_set_cuda(1, vol);\n}\n\nstatic void awacs_amp_free(struct snd_pmac *chip)\n{\n\tstruct awacs_amp *amp = chip->mixer_data;\n\tif (!amp)\n\t\treturn;\n\tkfree(amp);\n\tchip->mixer_data = NULL;\n\tchip->mixer_free = NULL;\n}\n\n\n \nstatic int snd_pmac_awacs_info_volume_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 31;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_get_volume_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);\n\tucontrol->value.integer.value[1] = 31 - (amp->amp_vol[index][1] & 31);\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_volume_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tint vol[2];\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tvol[0] = (31 - (ucontrol->value.integer.value[0] & 31))\n\t\t| (amp->amp_vol[index][0] & 32);\n\tvol[1] = (31 - (ucontrol->value.integer.value[1] & 31))\n\t\t| (amp->amp_vol[index][1] & 32);\n\treturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\n}\n\nstatic int snd_pmac_awacs_get_switch_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32)\n\t\t\t\t\t? 0 : 1;\n\tucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32)\n\t\t\t\t\t? 0 : 1;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_switch_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tint vol[2];\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tvol[0] = (ucontrol->value.integer.value[0] ? 0 : 32)\n\t\t| (amp->amp_vol[index][0] & 31);\n\tvol[1] = (ucontrol->value.integer.value[1] ? 0 : 32)\n\t\t| (amp->amp_vol[index][1] & 31);\n\treturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\n}\n\nstatic int snd_pmac_awacs_info_tone_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 14;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_get_tone_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = amp->amp_tone[index];\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_tone_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint index = kcontrol->private_value;\n\tstruct awacs_amp *amp = chip->mixer_data;\n\tunsigned int val;\n\n\tval = ucontrol->value.integer.value[0];\n\tif (val > 14)\n\t\treturn -EINVAL;\n\tif (val != amp->amp_tone[index]) {\n\t\tamp->amp_tone[index] = val;\n\t\tawacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_info_master_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 99;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_get_master_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct awacs_amp *amp = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = amp->amp_master;\n\treturn 0;\n}\n\nstatic int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct awacs_amp *amp = chip->mixer_data;\n\tunsigned int val;\n\n\tval = ucontrol->value.integer.value[0];\n\tif (val > 99)\n\t\treturn -EINVAL;\n\tif (val != amp->amp_master) {\n\t\tamp->amp_master = val;\n\t\tawacs_amp_set_master(amp, amp->amp_master);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define AMP_CH_SPK\t0\n#define AMP_CH_HD\t1\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] = {\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Speaker Playback Volume\",\n\t  .info = snd_pmac_awacs_info_volume_amp,\n\t  .get = snd_pmac_awacs_get_volume_amp,\n\t  .put = snd_pmac_awacs_put_volume_amp,\n\t  .private_value = AMP_CH_SPK,\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Headphone Playback Volume\",\n\t  .info = snd_pmac_awacs_info_volume_amp,\n\t  .get = snd_pmac_awacs_get_volume_amp,\n\t  .put = snd_pmac_awacs_put_volume_amp,\n\t  .private_value = AMP_CH_HD,\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Tone Control - Bass\",\n\t  .info = snd_pmac_awacs_info_tone_amp,\n\t  .get = snd_pmac_awacs_get_tone_amp,\n\t  .put = snd_pmac_awacs_put_tone_amp,\n\t  .private_value = 0,\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Tone Control - Treble\",\n\t  .info = snd_pmac_awacs_info_tone_amp,\n\t  .get = snd_pmac_awacs_get_tone_amp,\n\t  .put = snd_pmac_awacs_put_tone_amp,\n\t  .private_value = 1,\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Amp Master Playback Volume\",\n\t  .info = snd_pmac_awacs_info_master_amp,\n\t  .get = snd_pmac_awacs_get_master_amp,\n\t  .put = snd_pmac_awacs_put_master_amp,\n\t},\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Headphone Playback Switch\",\n\t.info = snd_pmac_boolean_stereo_info,\n\t.get = snd_pmac_awacs_get_switch_amp,\n\t.put = snd_pmac_awacs_put_switch_amp,\n\t.private_value = AMP_CH_HD,\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Speaker Playback Switch\",\n\t.info = snd_pmac_boolean_stereo_info,\n\t.get = snd_pmac_awacs_get_switch_amp,\n\t.put = snd_pmac_awacs_put_switch_amp,\n\t.private_value = AMP_CH_SPK,\n};\n\n#endif  \n\n\n \nstatic int snd_pmac_screamer_mic_boost_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 3;\n\treturn 0;\n}\n\nstatic int snd_pmac_screamer_mic_boost_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint val = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->awacs_reg[6] & MASK_MIC_BOOST)\n\t\tval |= 2;\n\tif (chip->awacs_reg[0] & MASK_GAINLINE)\n\t\tval |= 1;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint val0, val6;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval0 = chip->awacs_reg[0] & ~MASK_GAINLINE;\n\tval6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;\n\tif (ucontrol->value.integer.value[0] & 1)\n\t\tval0 |= MASK_GAINLINE;\n\tif (ucontrol->value.integer.value[0] & 2)\n\t\tval6 |= MASK_MIC_BOOST;\n\tif (val0 != chip->awacs_reg[0]) {\n\t\tsnd_pmac_awacs_write_reg(chip, 0, val0);\n\t\tchanged = 1;\n\t}\n\tif (val6 != chip->awacs_reg[6]) {\n\t\tsnd_pmac_awacs_write_reg(chip, 6, val6);\n\t\tchanged = 1;\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn changed;\n}\n\n \nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers[] = {\n\tAWACS_SWITCH(\"Master Capture Switch\", 1, SHIFT_LOOPTHRU, 0),\n\tAWACS_VOLUME(\"Master Capture Volume\", 0, 4, 0),\n \n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] = {\n\tAWACS_VOLUME(\"Master Playback Volume\", 2, 6, 1),\n\tAWACS_VOLUME(\"Play-through Playback Volume\", 5, 6, 1),\n\tAWACS_SWITCH(\"Line Capture Switch\", 0, SHIFT_MUX_MIC, 0),\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_LINE, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] = {\n\tAWACS_VOLUME(\"Line out Playback Volume\", 2, 6, 1),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] = {\n\tAWACS_VOLUME(\"Play-through Playback Volume\", 5, 6, 1),\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_CD, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] = {\n\tAWACS_VOLUME(\"Line out Playback Volume\", 2, 6, 1),\n\tAWACS_VOLUME(\"Master Playback Volume\", 5, 6, 1),\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_CD, 0),\n\tAWACS_SWITCH(\"Line Capture Switch\", 0, SHIFT_MUX_MIC, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] = {\n\tAWACS_VOLUME(\"Line out Playback Volume\", 2, 6, 1),\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_CD, 0),\n\tAWACS_SWITCH(\"Line Capture Switch\", 0, SHIFT_MUX_MIC, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] = {\n\tAWACS_VOLUME(\"Headphone Playback Volume\", 2, 6, 1),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] = {\n\tAWACS_VOLUME(\"Master Playback Volume\", 2, 6, 1),\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_CD, 0),\n};\n\n \nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers2[] = {\n\tAWACS_SWITCH(\"Line Capture Switch\", 0, SHIFT_MUX_LINE, 0),\n\tAWACS_SWITCH(\"Mic Capture Switch\", 0, SHIFT_MUX_MIC, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mixers2[] = {\n\tAWACS_SWITCH(\"Line Capture Switch\", 0, SHIFT_MUX_MIC, 0),\n\tAWACS_SWITCH(\"Mic Capture Switch\", 0, SHIFT_MUX_LINE, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] = {\n\tAWACS_SWITCH(\"CD Capture Switch\", 0, SHIFT_MUX_CD, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_master_sw =\nAWACS_SWITCH(\"Master Playback Switch\", 1, SHIFT_HDMUTE, 1);\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac =\nAWACS_SWITCH(\"Line out Playback Switch\", 1, SHIFT_HDMUTE, 1);\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 =\nAWACS_SWITCH(\"Headphone Playback Switch\", 1, SHIFT_HDMUTE, 1);\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] = {\n\tAWACS_SWITCH(\"Mic Boost Capture Switch\", 0, SHIFT_GAINLINE, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] = {\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Mic Boost Capture Volume\",\n\t  .info = snd_pmac_screamer_mic_boost_info,\n\t  .get = snd_pmac_screamer_mic_boost_get,\n\t  .put = snd_pmac_screamer_mic_boost_put,\n\t},\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] =\n{\n\tAWACS_SWITCH(\"Line Boost Capture Switch\", 0, SHIFT_GAINLINE, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] =\n{\n\tAWACS_SWITCH(\"Line Boost Capture Switch\", 0, SHIFT_GAINLINE, 0),\n\tAWACS_SWITCH(\"CD Boost Capture Switch\", 6, SHIFT_MIC_BOOST, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] =\n{\n\tAWACS_SWITCH(\"Line Boost Capture Switch\", 0, SHIFT_GAINLINE, 0),\n\tAWACS_SWITCH(\"Mic Boost Capture Switch\", 6, SHIFT_MIC_BOOST, 0),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] = {\n\tAWACS_VOLUME(\"Speaker Playback Volume\", 4, 6, 1),\n};\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw =\nAWACS_SWITCH(\"Speaker Playback Switch\", 1, SHIFT_SPKMUTE, 1);\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 =\nAWACS_SWITCH(\"Speaker Playback Switch\", 1, SHIFT_PAROUT1, 1);\n\nstatic const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 =\nAWACS_SWITCH(\"Speaker Playback Switch\", 1, SHIFT_PAROUT1, 0);\n\n\n \nstatic int build_mixers(struct snd_pmac *chip, int nums,\n\t\t\tconst struct snd_kcontrol_new *mixers)\n{\n\tint i, err;\n\n\tfor (i = 0; i < nums; i++) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void awacs_restore_all_regs(struct snd_pmac *chip)\n{\n\tsnd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);\n\tsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\n\tsnd_pmac_awacs_write_noreg(chip, 2, chip->awacs_reg[2]);\n\tsnd_pmac_awacs_write_noreg(chip, 4, chip->awacs_reg[4]);\n\tif (chip->model == PMAC_SCREAMER) {\n\t\tsnd_pmac_awacs_write_noreg(chip, 5, chip->awacs_reg[5]);\n\t\tsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\n\t\tsnd_pmac_awacs_write_noreg(chip, 7, chip->awacs_reg[7]);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic void snd_pmac_awacs_suspend(struct snd_pmac *chip)\n{\n\tsnd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]\n\t\t\t\t\t     | MASK_AMUTE | MASK_CMUTE));\n}\n\nstatic void snd_pmac_awacs_resume(struct snd_pmac *chip)\n{\n\tif (of_machine_is_compatible(\"PowerBook3,1\")\n\t    || of_machine_is_compatible(\"PowerBook3,2\")) {\n\t\tmsleep(100);\n\t\tsnd_pmac_awacs_write_reg(chip, 1,\n\t\t\tchip->awacs_reg[1] & ~MASK_PAROUT);\n\t\tmsleep(300);\n\t}\n\n\tawacs_restore_all_regs(chip);\n\tif (chip->model == PMAC_SCREAMER) {\n\t\t \n\t\tmdelay(5);\n\t\tsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\n\t}\n\tscreamer_recalibrate(chip);\n#ifdef PMAC_AMP_AVAIL\n\tif (chip->mixer_data) {\n\t\tstruct awacs_amp *amp = chip->mixer_data;\n\t\tawacs_amp_set_vol(amp, 0,\n\t\t\t\t  amp->amp_vol[0][0], amp->amp_vol[0][1], 0);\n\t\tawacs_amp_set_vol(amp, 1,\n\t\t\t\t  amp->amp_vol[1][0], amp->amp_vol[1][1], 0);\n\t\tawacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);\n\t\tawacs_amp_set_master(amp, amp->amp_master);\n\t}\n#endif\n}\n#endif  \n\n#define IS_PM7500 (of_machine_is_compatible(\"AAPL,7500\") \\\n\t\t|| of_machine_is_compatible(\"AAPL,8500\") \\\n\t\t|| of_machine_is_compatible(\"AAPL,9500\"))\n#define IS_PM5500 (of_machine_is_compatible(\"AAPL,e411\"))\n#define IS_BEIGE (of_machine_is_compatible(\"AAPL,Gossamer\"))\n#define IS_IMAC1 (of_machine_is_compatible(\"PowerMac2,1\"))\n#define IS_IMAC2 (of_machine_is_compatible(\"PowerMac2,2\") \\\n\t\t|| of_machine_is_compatible(\"PowerMac4,1\"))\n#define IS_G4AGP (of_machine_is_compatible(\"PowerMac3,1\"))\n#define IS_LOMBARD (of_machine_is_compatible(\"PowerBook1,1\"))\n\nstatic int imac1, imac2;\n\n#ifdef PMAC_SUPPORT_AUTOMUTE\n \nstatic int snd_pmac_awacs_detect_headphone(struct snd_pmac *chip)\n{\n\treturn (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;\n}\n\n#ifdef PMAC_AMP_AVAIL\nstatic int toggle_amp_mute(struct awacs_amp *amp, int index, int mute)\n{\n\tint vol[2];\n\tvol[0] = amp->amp_vol[index][0] & 31;\n\tvol[1] = amp->amp_vol[index][1] & 31;\n\tif (mute) {\n\t\tvol[0] |= 32;\n\t\tvol[1] |= 32;\n\t}\n\treturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\n}\n#endif\n\nstatic void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)\n{\n\tif (chip->auto_mute) {\n#ifdef PMAC_AMP_AVAIL\n\t\tif (chip->mixer_data) {\n\t\t\tstruct awacs_amp *amp = chip->mixer_data;\n\t\t\tint changed;\n\t\t\tif (snd_pmac_awacs_detect_headphone(chip)) {\n\t\t\t\tchanged = toggle_amp_mute(amp, AMP_CH_HD, 0);\n\t\t\t\tchanged |= toggle_amp_mute(amp, AMP_CH_SPK, 1);\n\t\t\t} else {\n\t\t\t\tchanged = toggle_amp_mute(amp, AMP_CH_HD, 1);\n\t\t\t\tchanged |= toggle_amp_mute(amp, AMP_CH_SPK, 0);\n\t\t\t}\n\t\t\tif (do_notify && ! changed)\n\t\t\t\treturn;\n\t\t} else\n#endif\n\t\t{\n\t\t\tint reg = chip->awacs_reg[1]\n\t\t\t\t| (MASK_HDMUTE | MASK_SPKMUTE);\n\t\t\tif (imac1) {\n\t\t\t\treg &= ~MASK_SPKMUTE;\n\t\t\t\treg |= MASK_PAROUT1;\n\t\t\t} else if (imac2) {\n\t\t\t\treg &= ~MASK_SPKMUTE;\n\t\t\t\treg &= ~MASK_PAROUT1;\n\t\t\t}\n\t\t\tif (snd_pmac_awacs_detect_headphone(chip))\n\t\t\t\treg &= ~MASK_HDMUTE;\n\t\t\telse if (imac1)\n\t\t\t\treg &= ~MASK_PAROUT1;\n\t\t\telse if (imac2)\n\t\t\t\treg |= MASK_PAROUT1;\n\t\t\telse\n\t\t\t\treg &= ~MASK_SPKMUTE;\n\t\t\tif (do_notify && reg == chip->awacs_reg[1])\n\t\t\t\treturn;\n\t\t\tsnd_pmac_awacs_write_reg(chip, 1, reg);\n\t\t}\n\t\tif (do_notify) {\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->master_sw_ctl->id);\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->speaker_sw_ctl->id);\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->hp_detect_ctl->id);\n\t\t}\n\t}\n}\n#endif  \n\n\n \nint\nsnd_pmac_awacs_init(struct snd_pmac *chip)\n{\n\tint pm7500 = IS_PM7500;\n\tint pm5500 = IS_PM5500;\n\tint beige = IS_BEIGE;\n\tint g4agp = IS_G4AGP;\n\tint lombard = IS_LOMBARD;\n\tint imac;\n\tint err, vol;\n\tstruct snd_kcontrol *vmaster_sw, *vmaster_vol;\n\tstruct snd_kcontrol *master_vol, *speaker_vol;\n\n\timac1 = IS_IMAC1;\n\timac2 = IS_IMAC2;\n\timac = imac1 || imac2;\n\t \n\tchip->awacs_reg[0] = MASK_MUX_CD | 0xff | MASK_GAINLINE;\n\tchip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;\n\t \n\tif (chip->has_iic || chip->device_id == 0x5 ||\n\t     \n\t    chip->device_id == 0xb)\n\t\tchip->awacs_reg[1] |= MASK_PAROUT;\n\t \n\t\n\t\n\tvol = 0x0f;  \n\tvol = vol + (vol << 6);\n\tchip->awacs_reg[2] = vol;\n\tchip->awacs_reg[4] = vol;\n\tif (chip->model == PMAC_SCREAMER) {\n\t\t \n\t\tchip->awacs_reg[5] = vol;\n\t\t \n\t\tchip->awacs_reg[6] = MASK_MIC_BOOST;\n\t\tchip->awacs_reg[7] = 0;\n\t}\n\n\tawacs_restore_all_regs(chip);\n\tchip->manufacturer = (in_le32(&chip->awacs->codec_stat) >> 8) & 0xf;\n\tscreamer_recalibrate(chip);\n\n\tchip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;\n#ifdef PMAC_AMP_AVAIL\n\tif (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {\n\t\tstruct awacs_amp *amp = kzalloc(sizeof(*amp), GFP_KERNEL);\n\t\tif (! amp)\n\t\t\treturn -ENOMEM;\n\t\tchip->mixer_data = amp;\n\t\tchip->mixer_free = awacs_amp_free;\n\t\t \n\t\tawacs_amp_set_vol(amp, 0, 63, 63, 0);\n\t\tawacs_amp_set_vol(amp, 1, 63, 63, 0);\n\t\tawacs_amp_set_tone(amp, 7, 7);  \n\t\tawacs_amp_set_master(amp, 79);  \n\t}\n#endif  \n\n\tif (chip->hp_stat_mask == 0) {\n\t\t \n\t\tswitch (chip->model) {\n\t\tcase PMAC_AWACS:\n\t\t\tchip->hp_stat_mask = pm7500 || pm5500 ? MASK_HDPCONN\n\t\t\t\t: MASK_LOCONN;\n\t\t\tbreak;\n\t\tcase PMAC_SCREAMER:\n\t\t\tswitch (chip->device_id) {\n\t\t\tcase 0x08:\n\t\t\tcase 0x0B:\n\t\t\t\tchip->hp_stat_mask = imac\n\t\t\t\t\t? MASK_LOCONN_IMAC |\n\t\t\t\t\tMASK_HDPLCONN_IMAC |\n\t\t\t\t\tMASK_HDPRCONN_IMAC\n\t\t\t\t\t: MASK_HDPCONN;\n\t\t\t\tbreak;\n\t\t\tcase 0x00:\n\t\t\tcase 0x05:\n\t\t\t\tchip->hp_stat_mask = MASK_LOCONN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tchip->hp_stat_mask = MASK_HDPCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_BUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tstrcpy(chip->card->mixername, \"PowerMac AWACS\");\n\n\terr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),\n\t\t\t\tsnd_pmac_awacs_mixers);\n\tif (err < 0)\n\t\treturn err;\n\tif (beige || g4agp)\n\t\t;\n\telse if (chip->model == PMAC_SCREAMER || pm5500)\n\t\terr = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),\n\t\t\t\t   snd_pmac_screamer_mixers2);\n\telse if (!pm7500)\n\t\terr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers2),\n\t\t\t\t   snd_pmac_awacs_mixers2);\n\tif (err < 0)\n\t\treturn err;\n\tif (pm5500) {\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_awacs_mixers2_pmac5500),\n\t\t\t\t   snd_pmac_awacs_mixers2_pmac5500);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tmaster_vol = NULL;\n\tif (pm7500)\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac7500),\n\t\t\t\t   snd_pmac_awacs_mixers_pmac7500);\n\telse if (pm5500)\n\t\terr = snd_ctl_add(chip->card,\n\t\t    (master_vol = snd_ctl_new1(snd_pmac_awacs_mixers_pmac5500,\n\t\t\t\t\t\tchip)));\n\telse if (beige)\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_screamer_mixers_beige),\n\t\t\t\t   snd_pmac_screamer_mixers_beige);\n\telse if (imac || lombard) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t    (master_vol = snd_ctl_new1(snd_pmac_screamer_mixers_lo,\n\t\t\t\t\t\tchip)));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_screamer_mixers_imac),\n\t\t\t\t   snd_pmac_screamer_mixers_imac);\n\t} else if (g4agp)\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_screamer_mixers_g4agp),\n\t\t\t\t   snd_pmac_screamer_mixers_g4agp);\n\telse\n\t\terr = build_mixers(chip,\n\t\t\t\t   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac),\n\t\t\t\t   snd_pmac_awacs_mixers_pmac);\n\tif (err < 0)\n\t\treturn err;\n\tchip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp || lombard)\n\t\t\t? &snd_pmac_awacs_master_sw_imac\n\t\t\t: pm5500\n\t\t\t? &snd_pmac_awacs_master_sw_pmac5500\n\t\t\t: &snd_pmac_awacs_master_sw, chip);\n\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n#ifdef PMAC_AMP_AVAIL\n\tif (chip->mixer_data) {\n\t\t \n\t\terr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_amp_vol),\n\t\t\t\t\tsnd_pmac_awacs_amp_vol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tchip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw,\n\t\t\t\t\t\t\tchip);\n\t\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw,\n\t\t\t\t\t\t\tchip);\n\t\terr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n#endif  \n\t{\n\t\t \n\t\terr = snd_ctl_add(chip->card,\n\t\t    (speaker_vol = snd_ctl_new1(snd_pmac_awacs_speaker_vol,\n\t\t\t\t\t\tchip)));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->speaker_sw_ctl = snd_ctl_new1(imac1\n\t\t\t\t? &snd_pmac_awacs_speaker_sw_imac1\n\t\t\t\t: imac2\n\t\t\t\t? &snd_pmac_awacs_speaker_sw_imac2\n\t\t\t\t: &snd_pmac_awacs_speaker_sw, chip);\n\t\terr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (pm5500 || imac || lombard) {\n\t\tvmaster_sw = snd_ctl_make_virtual_master(\n\t\t\t\"Master Playback Switch\", (unsigned int *) NULL);\n\t\terr = snd_ctl_add_follower_uncached(vmaster_sw,\n\t\t\t\t\t\t    chip->master_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add_follower_uncached(vmaster_sw,\n\t\t\t\t\t\t    chip->speaker_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(chip->card, vmaster_sw);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tvmaster_vol = snd_ctl_make_virtual_master(\n\t\t\t\"Master Playback Volume\", (unsigned int *) NULL);\n\t\terr = snd_ctl_add_follower(vmaster_vol, master_vol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add_follower(vmaster_vol, speaker_vol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(chip->card, vmaster_vol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (beige || g4agp)\n\t\terr = build_mixers(chip,\n\t\t\t\tARRAY_SIZE(snd_pmac_screamer_mic_boost_beige),\n\t\t\t\tsnd_pmac_screamer_mic_boost_beige);\n\telse if (imac)\n\t\terr = build_mixers(chip,\n\t\t\t\tARRAY_SIZE(snd_pmac_screamer_mic_boost_imac),\n\t\t\t\tsnd_pmac_screamer_mic_boost_imac);\n\telse if (chip->model == PMAC_SCREAMER)\n\t\terr = build_mixers(chip,\n\t\t\t\tARRAY_SIZE(snd_pmac_screamer_mic_boost),\n\t\t\t\tsnd_pmac_screamer_mic_boost);\n\telse if (pm7500)\n\t\terr = build_mixers(chip,\n\t\t\t\tARRAY_SIZE(snd_pmac_awacs_mic_boost_pmac7500),\n\t\t\t\tsnd_pmac_awacs_mic_boost_pmac7500);\n\telse\n\t\terr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mic_boost),\n\t\t\t\tsnd_pmac_awacs_mic_boost);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tchip->set_format = snd_pmac_awacs_set_format;\n#ifdef CONFIG_PM\n\tchip->suspend = snd_pmac_awacs_suspend;\n\tchip->resume = snd_pmac_awacs_resume;\n#endif\n#ifdef PMAC_SUPPORT_AUTOMUTE\n\terr = snd_pmac_add_automute(chip);\n\tif (err < 0)\n\t\treturn err;\n\tchip->detect_headphone = snd_pmac_awacs_detect_headphone;\n\tchip->update_automute = snd_pmac_awacs_update_automute;\n\tsnd_pmac_awacs_update_automute(chip, 0);  \n#endif\n\tif (chip->model == PMAC_SCREAMER) {\n\t\tsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\n\t\tsnd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}