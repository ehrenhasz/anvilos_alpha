{
  "module_name": "pmac.c",
  "hash_id": "7408d43cfc235fa29b0d2b2e45d87ab177db54743ee862bbd5498f7fb9a04c49",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/pmac.c",
  "human_readable_source": "\n \n\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <sound/core.h>\n#include \"pmac.h\"\n#include <sound/pcm_params.h>\n#include <asm/pmac_feature.h>\n\n\n \nstatic const int awacs_freqs[8] = {\n\t44100, 29400, 22050, 17640, 14700, 11025, 8820, 7350\n};\n \nstatic const int tumbler_freqs[1] = {\n\t44100\n};\n\n\n \nstatic struct pmac_dbdma emergency_dbdma;\nstatic int emergency_in_use;\n\n\n \nstatic int snd_pmac_dbdma_alloc(struct snd_pmac *chip, struct pmac_dbdma *rec, int size)\n{\n\tunsigned int rsize = sizeof(struct dbdma_cmd) * (size + 1);\n\n\trec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,\n\t\t\t\t\t&rec->dma_base, GFP_KERNEL);\n\tif (rec->space == NULL)\n\t\treturn -ENOMEM;\n\trec->size = size;\n\tmemset(rec->space, 0, rsize);\n\trec->cmds = (void __iomem *)DBDMA_ALIGN(rec->space);\n\trec->addr = rec->dma_base + (unsigned long)((char *)rec->cmds - (char *)rec->space);\n\n\treturn 0;\n}\n\nstatic void snd_pmac_dbdma_free(struct snd_pmac *chip, struct pmac_dbdma *rec)\n{\n\tif (rec->space) {\n\t\tunsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);\n\n\t\tdma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);\n\t}\n}\n\n\n \n\n \n\nunsigned int snd_pmac_rate_index(struct snd_pmac *chip, struct pmac_stream *rec, unsigned int rate)\n{\n\tint i, ok, found;\n\n\tok = rec->cur_freqs;\n\tif (rate > chip->freq_table[0])\n\t\treturn 0;\n\tfound = 0;\n\tfor (i = 0; i < chip->num_freqs; i++, ok >>= 1) {\n\t\tif (! (ok & 1)) continue;\n\t\tfound = i;\n\t\tif (rate >= chip->freq_table[i])\n\t\t\tbreak;\n\t}\n\treturn found;\n}\n\n \nstatic inline int another_stream(int stream)\n{\n\treturn (stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\tSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n}\n\n \nstatic struct pmac_stream *snd_pmac_get_stream(struct snd_pmac *chip, int stream)\n{\n\tswitch (stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\treturn &chip->playback;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\treturn &chip->capture;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn NULL;\n\t}\n}\n\n \nstatic inline void\nsnd_pmac_wait_ack(struct pmac_stream *rec)\n{\n\tint timeout = 50000;\n\twhile ((in_le32(&rec->dma->status) & RUN) && timeout-- > 0)\n\t\tudelay(1);\n}\n\n \nstatic void snd_pmac_pcm_set_format(struct snd_pmac *chip)\n{\n\t \n\tout_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));\n\tout_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE ? 1 : 0);\n\tif (chip->set_format)\n\t\tchip->set_format(chip);\n}\n\n \nstatic inline void snd_pmac_dma_stop(struct pmac_stream *rec)\n{\n\tout_le32(&rec->dma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);\n\tsnd_pmac_wait_ack(rec);\n}\n\n \nstatic inline void snd_pmac_dma_set_command(struct pmac_stream *rec, struct pmac_dbdma *cmd)\n{\n\tout_le32(&rec->dma->cmdptr, cmd->addr);\n}\n\n \nstatic inline void snd_pmac_dma_run(struct pmac_stream *rec, int status)\n{\n\tout_le32(&rec->dma->control, status | (status << 16));\n}\n\n\n \nstatic int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec, struct snd_pcm_substream *subs)\n{\n\tint i;\n\tvolatile struct dbdma_cmd __iomem *cp;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tint rate_index;\n\tlong offset;\n\tstruct pmac_stream *astr;\n\n\trec->dma_size = snd_pcm_lib_buffer_bytes(subs);\n\trec->period_size = snd_pcm_lib_period_bytes(subs);\n\trec->nperiods = rec->dma_size / rec->period_size;\n\trec->cur_period = 0;\n\trate_index = snd_pmac_rate_index(chip, rec, runtime->rate);\n\n\t \n\tastr = snd_pmac_get_stream(chip, another_stream(rec->stream));\n\tif (! astr)\n\t\treturn -EINVAL;\n\tastr->cur_freqs = 1 << rate_index;\n\tastr->cur_formats = 1 << runtime->format;\n\tchip->rate_index = rate_index;\n\tchip->format = runtime->format;\n\n\t \n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_pmac_dma_stop(rec);\n\tchip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);\n\tsnd_pmac_dma_set_command(rec, &chip->extra_dma);\n\tsnd_pmac_dma_run(rec, RUN);\n\tspin_unlock_irq(&chip->reg_lock);\n\tmdelay(5);\n\tspin_lock_irq(&chip->reg_lock);\n\t \n\toffset = runtime->dma_addr;\n\tfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {\n\t\tcp->phy_addr = cpu_to_le32(offset);\n\t\tcp->req_count = cpu_to_le16(rec->period_size);\n\t\t \n\t\tcp->xfer_status = cpu_to_le16(0);\n\t\toffset += rec->period_size;\n\t}\n\t \n\tcp->command = cpu_to_le16(DBDMA_NOP | BR_ALWAYS);\n\tcp->cmd_dep = cpu_to_le32(rec->cmd.addr);\n\n\tsnd_pmac_dma_stop(rec);\n\tsnd_pmac_dma_set_command(rec, &rec->cmd);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_pmac_pcm_trigger(struct snd_pmac *chip, struct pmac_stream *rec,\n\t\t\t\tstruct snd_pcm_substream *subs, int cmd)\n{\n\tvolatile struct dbdma_cmd __iomem *cp;\n\tint i, command;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (rec->running)\n\t\t\treturn -EBUSY;\n\t\tcommand = (subs->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\t   OUTPUT_MORE : INPUT_MORE) + INTR_ALWAYS;\n\t\tspin_lock(&chip->reg_lock);\n\t\tsnd_pmac_beep_stop(chip);\n\t\tsnd_pmac_pcm_set_format(chip);\n\t\tfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)\n\t\t\tout_le16(&cp->command, command);\n\t\tsnd_pmac_dma_set_command(rec, &rec->cmd);\n\t\t(void)in_le32(&rec->dma->status);\n\t\tsnd_pmac_dma_run(rec, RUN|WAKE);\n\t\trec->running = 1;\n\t\tspin_unlock(&chip->reg_lock);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tspin_lock(&chip->reg_lock);\n\t\trec->running = 0;\n\t\t \n\t\tsnd_pmac_dma_stop(rec);\n\t\tfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)\n\t\t\tout_le16(&cp->command, DBDMA_STOP);\n\t\tspin_unlock(&chip->reg_lock);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \ninline\nstatic snd_pcm_uframes_t snd_pmac_pcm_pointer(struct snd_pmac *chip,\n\t\t\t\t\t      struct pmac_stream *rec,\n\t\t\t\t\t      struct snd_pcm_substream *subs)\n{\n\tint count = 0;\n\n#if 1  \n\tint stat;\n\tvolatile struct dbdma_cmd __iomem *cp = &rec->cmd.cmds[rec->cur_period];\n\tstat = le16_to_cpu(cp->xfer_status);\n\tif (stat & (ACTIVE|DEAD)) {\n\t\tcount = in_le16(&cp->res_count);\n\t\tif (count)\n\t\t\tcount = rec->period_size - count;\n\t}\n#endif\n\tcount += rec->cur_period * rec->period_size;\n\t \n\treturn bytes_to_frames(subs->runtime, count);\n}\n\n \n\nstatic int snd_pmac_playback_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_prepare(chip, &chip->playback, subs);\n}\n\nstatic int snd_pmac_playback_trigger(struct snd_pcm_substream *subs,\n\t\t\t\t     int cmd)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_trigger(chip, &chip->playback, subs, cmd);\n}\n\nstatic snd_pcm_uframes_t snd_pmac_playback_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_pointer(chip, &chip->playback, subs);\n}\n\n\n \n\nstatic int snd_pmac_capture_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_prepare(chip, &chip->capture, subs);\n}\n\nstatic int snd_pmac_capture_trigger(struct snd_pcm_substream *subs,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_trigger(chip, &chip->capture, subs, cmd);\n}\n\nstatic snd_pcm_uframes_t snd_pmac_capture_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\treturn snd_pmac_pcm_pointer(chip, &chip->capture, subs);\n}\n\n\n \nstatic inline void snd_pmac_pcm_dead_xfer(struct pmac_stream *rec,\n\t\t\t\t\t  volatile struct dbdma_cmd __iomem *cp)\n{\n\tunsigned short req, res ;\n\tunsigned int phy ;\n\n\t \n\n\t \n\t(void)in_le32(&rec->dma->status);\n\tout_le32(&rec->dma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\n\n\tif (!emergency_in_use) {  \n\t\tmemcpy((void *)emergency_dbdma.cmds, (void *)cp,\n\t\t       sizeof(struct dbdma_cmd));\n\t\temergency_in_use = 1;\n\t\tcp->xfer_status = cpu_to_le16(0);\n\t\tcp->req_count = cpu_to_le16(rec->period_size);\n\t\tcp = emergency_dbdma.cmds;\n\t}\n\n\t \n\treq = le16_to_cpu(cp->req_count);\n\tres = le16_to_cpu(cp->res_count);\n\tphy = le32_to_cpu(cp->phy_addr);\n\tphy += (req - res);\n\tcp->req_count = cpu_to_le16(res);\n\tcp->res_count = cpu_to_le16(0);\n\tcp->xfer_status = cpu_to_le16(0);\n\tcp->phy_addr = cpu_to_le32(phy);\n\n\tcp->cmd_dep = cpu_to_le32(rec->cmd.addr\n\t\t+ sizeof(struct dbdma_cmd)*((rec->cur_period+1)%rec->nperiods));\n\n\tcp->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS | INTR_ALWAYS);\n\n\t \n\tout_le32(&rec->dma->cmdptr, emergency_dbdma.addr);\n\n\t \n\t(void)in_le32(&rec->dma->status);\n\t \n\tout_le32(&rec->dma->control, ((RUN|WAKE) << 16) + (RUN|WAKE));\n}\n\n \nstatic void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)\n{\n\tvolatile struct dbdma_cmd __iomem *cp;\n\tint c;\n\tint stat;\n\n\tspin_lock(&chip->reg_lock);\n\tif (rec->running) {\n\t\tfor (c = 0; c < rec->nperiods; c++) {  \n\n\t\t\tif (emergency_in_use)    \n\t\t\t\tcp = emergency_dbdma.cmds;\n\t\t\telse\n\t\t\t\tcp = &rec->cmd.cmds[rec->cur_period];\n\n\t\t\tstat = le16_to_cpu(cp->xfer_status);\n\n\t\t\tif (stat & DEAD) {\n\t\t\t\tsnd_pmac_pcm_dead_xfer(rec, cp);\n\t\t\t\tbreak;  \n\t\t\t}\n\n\t\t\tif (emergency_in_use)\n\t\t\t\temergency_in_use = 0 ;  \n\n\t\t\tif (! (stat & ACTIVE))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcp->xfer_status = cpu_to_le16(0);\n\t\t\tcp->req_count = cpu_to_le16(rec->period_size);\n\t\t\t \n\t\t\trec->cur_period++;\n\t\t\tif (rec->cur_period >= rec->nperiods) {\n\t\t\t\trec->cur_period = 0;\n\t\t\t}\n\n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(rec->substream);\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n}\n\n\n \n\nstatic const struct snd_pcm_hardware snd_pmac_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_44100,\n\t.rate_min =\t\t7350,\n\t.rate_max =\t\t44100,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t131072,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t16384,\n\t.periods_min =\t\t3,\n\t.periods_max =\t\tPMAC_MAX_FRAGS,\n};\n\nstatic const struct snd_pcm_hardware snd_pmac_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_44100,\n\t.rate_min =\t\t7350,\n\t.rate_max =\t\t44100,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t131072,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t16384,\n\t.periods_min =\t\t3,\n\t.periods_max =\t\tPMAC_MAX_FRAGS,\n};\n\n\n#if 0  \nstatic int snd_pmac_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pmac *chip = rule->private;\n\tstruct pmac_stream *rec = snd_pmac_get_stream(chip, rule->deps[0]);\n\tint i, freq_table[8], num_freqs;\n\n\tif (! rec)\n\t\treturn -EINVAL;\n\tnum_freqs = 0;\n\tfor (i = chip->num_freqs - 1; i >= 0; i--) {\n\t\tif (rec->cur_freqs & (1 << i))\n\t\t\tfreq_table[num_freqs++] = chip->freq_table[i];\n\t}\n\n\treturn snd_interval_list(hw_param_interval(params, rule->var),\n\t\t\t\t num_freqs, freq_table, 0);\n}\n\nstatic int snd_pmac_hw_rule_format(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pmac *chip = rule->private;\n\tstruct pmac_stream *rec = snd_pmac_get_stream(chip, rule->deps[0]);\n\n\tif (! rec)\n\t\treturn -EINVAL;\n\treturn snd_mask_refine_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),\n\t\t\t\t   rec->cur_formats);\n}\n#endif  \n\nstatic int snd_pmac_pcm_open(struct snd_pmac *chip, struct pmac_stream *rec,\n\t\t\t     struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tint i;\n\n\t \n\truntime->hw.rates = 0;\n\tfor (i = 0; i < chip->num_freqs; i++)\n\t\tif (chip->freqs_ok & (1 << i))\n\t\t\truntime->hw.rates |=\n\t\t\t\tsnd_pcm_rate_to_rate_bit(chip->freq_table[i]);\n\n\t \n\tfor (i = 0; i < chip->num_freqs; i++) {\n\t\tif (chip->freqs_ok & (1 << i)) {\n\t\t\truntime->hw.rate_max = chip->freq_table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = chip->num_freqs - 1; i >= 0; i--) {\n\t\tif (chip->freqs_ok & (1 << i)) {\n\t\t\truntime->hw.rate_min = chip->freq_table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\truntime->hw.formats = chip->formats_ok;\n\tif (chip->can_capture) {\n\t\tif (! chip->can_duplex)\n\t\t\truntime->hw.info |= SNDRV_PCM_INFO_HALF_DUPLEX;\n\t\truntime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\n\t}\n\truntime->private_data = rec;\n\trec->substream = subs;\n\n#if 0  \n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t    snd_pmac_hw_rule_rate, chip, rec->stream, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t    snd_pmac_hw_rule_format, chip, rec->stream, -1);\n#endif\n\n\truntime->hw.periods_max = rec->cmd.size - 1;\n\n\t \n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\treturn 0;\n}\n\nstatic int snd_pmac_pcm_close(struct snd_pmac *chip, struct pmac_stream *rec,\n\t\t\t      struct snd_pcm_substream *subs)\n{\n\tstruct pmac_stream *astr;\n\n\tsnd_pmac_dma_stop(rec);\n\n\tastr = snd_pmac_get_stream(chip, another_stream(rec->stream));\n\tif (! astr)\n\t\treturn -EINVAL;\n\n\t \n\tastr->cur_freqs = chip->freqs_ok;\n\tastr->cur_formats = chip->formats_ok;\n\n\treturn 0;\n}\n\nstatic int snd_pmac_playback_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\n\tsubs->runtime->hw = snd_pmac_playback;\n\treturn snd_pmac_pcm_open(chip, &chip->playback, subs);\n}\n\nstatic int snd_pmac_capture_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\n\tsubs->runtime->hw = snd_pmac_capture;\n\treturn snd_pmac_pcm_open(chip, &chip->capture, subs);\n}\n\nstatic int snd_pmac_playback_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\n\treturn snd_pmac_pcm_close(chip, &chip->playback, subs);\n}\n\nstatic int snd_pmac_capture_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pmac *chip = snd_pcm_substream_chip(subs);\n\n\treturn snd_pmac_pcm_close(chip, &chip->capture, subs);\n}\n\n \n\nstatic const struct snd_pcm_ops snd_pmac_playback_ops = {\n\t.open =\t\tsnd_pmac_playback_open,\n\t.close =\tsnd_pmac_playback_close,\n\t.prepare =\tsnd_pmac_playback_prepare,\n\t.trigger =\tsnd_pmac_playback_trigger,\n\t.pointer =\tsnd_pmac_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_pmac_capture_ops = {\n\t.open =\t\tsnd_pmac_capture_open,\n\t.close =\tsnd_pmac_capture_close,\n\t.prepare =\tsnd_pmac_capture_prepare,\n\t.trigger =\tsnd_pmac_capture_trigger,\n\t.pointer =\tsnd_pmac_capture_pointer,\n};\n\nint snd_pmac_pcm_new(struct snd_pmac *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\tint num_captures = 1;\n\n\tif (! chip->can_capture)\n\t\tnum_captures = 0;\n\terr = snd_pcm_new(chip->card, chip->card->driver, 0, 1, num_captures, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_pmac_playback_ops);\n\tif (chip->can_capture)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pmac_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm = pcm;\n\n\tchip->formats_ok = SNDRV_PCM_FMTBIT_S16_BE;\n\tif (chip->can_byte_swap)\n\t\tchip->formats_ok |= SNDRV_PCM_FMTBIT_S16_LE;\n\n\tchip->playback.cur_formats = chip->formats_ok;\n\tchip->capture.cur_formats = chip->formats_ok;\n\tchip->playback.cur_freqs = chip->freqs_ok;\n\tchip->capture.cur_freqs = chip->freqs_ok;\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pdev->dev,\n\t\t\t\t       64 * 1024, 64 * 1024);\n\n\treturn 0;\n}\n\n\nstatic void snd_pmac_dbdma_reset(struct snd_pmac *chip)\n{\n\tout_le32(&chip->playback.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);\n\tsnd_pmac_wait_ack(&chip->playback);\n\tout_le32(&chip->capture.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);\n\tsnd_pmac_wait_ack(&chip->capture);\n}\n\n\n \nvoid snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long addr, int speed)\n{\n\tstruct pmac_stream *rec = &chip->playback;\n\n\tsnd_pmac_dma_stop(rec);\n\tchip->extra_dma.cmds->req_count = cpu_to_le16(bytes);\n\tchip->extra_dma.cmds->xfer_status = cpu_to_le16(0);\n\tchip->extra_dma.cmds->cmd_dep = cpu_to_le32(chip->extra_dma.addr);\n\tchip->extra_dma.cmds->phy_addr = cpu_to_le32(addr);\n\tchip->extra_dma.cmds->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS);\n\tout_le32(&chip->awacs->control,\n\t\t (in_le32(&chip->awacs->control) & ~0x1f00)\n\t\t | (speed << 8));\n\tout_le32(&chip->awacs->byteswap, 0);\n\tsnd_pmac_dma_set_command(rec, &chip->extra_dma);\n\tsnd_pmac_dma_run(rec, RUN);\n}\n\nvoid snd_pmac_beep_dma_stop(struct snd_pmac *chip)\n{\n\tsnd_pmac_dma_stop(&chip->playback);\n\tchip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);\n\tsnd_pmac_pcm_set_format(chip);  \n}\n\n\n \nstatic irqreturn_t\nsnd_pmac_tx_intr(int irq, void *devid)\n{\n\tstruct snd_pmac *chip = devid;\n\tsnd_pmac_pcm_update(chip, &chip->playback);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t\nsnd_pmac_rx_intr(int irq, void *devid)\n{\n\tstruct snd_pmac *chip = devid;\n\tsnd_pmac_pcm_update(chip, &chip->capture);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t\nsnd_pmac_ctrl_intr(int irq, void *devid)\n{\n\tstruct snd_pmac *chip = devid;\n\tint ctrl = in_le32(&chip->awacs->control);\n\n\t \n\tif (ctrl & MASK_PORTCHG) {\n\t\t \n\t\tif (chip->update_automute)\n\t\t\tchip->update_automute(chip, 1);\n\t}\n\tif (ctrl & MASK_CNTLERR) {\n\t\tint err = (in_le32(&chip->awacs->codec_stat) & MASK_ERRCODE) >> 16;\n\t\tif (err && chip->model <= PMAC_SCREAMER)\n\t\t\tsnd_printk(KERN_DEBUG \"error %x\\n\", err);\n\t}\n\t \n\tout_le32(&chip->awacs->control, ctrl);\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void snd_pmac_sound_feature(struct snd_pmac *chip, int enable)\n{\n\tif (ppc_md.feature_call)\n\t\tppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);\n}\n\n \n\nstatic int snd_pmac_free(struct snd_pmac *chip)\n{\n\t \n\tif (chip->initialized) {\n\t\tsnd_pmac_dbdma_reset(chip);\n\t\t \n\t\tout_le32(&chip->awacs->control, in_le32(&chip->awacs->control) & 0xfff);\n\t}\n\n\tif (chip->node)\n\t\tsnd_pmac_sound_feature(chip, 0);\n\n\t \n\tif (chip->mixer_free)\n\t\tchip->mixer_free(chip);\n\n\tsnd_pmac_detach_beep(chip);\n\n\t \n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, (void*)chip);\n\tif (chip->tx_irq >= 0)\n\t\tfree_irq(chip->tx_irq, (void*)chip);\n\tif (chip->rx_irq >= 0)\n\t\tfree_irq(chip->rx_irq, (void*)chip);\n\tsnd_pmac_dbdma_free(chip, &chip->playback.cmd);\n\tsnd_pmac_dbdma_free(chip, &chip->capture.cmd);\n\tsnd_pmac_dbdma_free(chip, &chip->extra_dma);\n\tsnd_pmac_dbdma_free(chip, &emergency_dbdma);\n\tiounmap(chip->macio_base);\n\tiounmap(chip->latch_base);\n\tiounmap(chip->awacs);\n\tiounmap(chip->playback.dma);\n\tiounmap(chip->capture.dma);\n\n\tif (chip->node) {\n\t\tint i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (chip->requested & (1 << i))\n\t\t\t\trelease_mem_region(chip->rsrc[i].start,\n\t\t\t\t\t\t   resource_size(&chip->rsrc[i]));\n\t\t}\n\t}\n\n\tpci_dev_put(chip->pdev);\n\tof_node_put(chip->node);\n\tkfree(chip);\n\treturn 0;\n}\n\n\n \nstatic int snd_pmac_dev_free(struct snd_device *device)\n{\n\tstruct snd_pmac *chip = device->device_data;\n\treturn snd_pmac_free(chip);\n}\n\n\n \n\nstatic void detect_byte_swap(struct snd_pmac *chip)\n{\n\tstruct device_node *mio;\n\n\t \n\tfor (mio = chip->node->parent; mio; mio = mio->parent) {\n\t\tif (of_node_name_eq(mio, \"mac-io\")) {\n\t\t\tif (of_device_is_compatible(mio, \"Keylargo\"))\n\t\t\t\tchip->can_byte_swap = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"PowerBook3,1\") ||\n\t    of_machine_is_compatible(\"PowerBook2,1\"))\n\t\tchip->can_byte_swap = 0 ;\n\n\tif (of_machine_is_compatible(\"PowerBook2,1\"))\n\t\tchip->can_duplex = 0;\n}\n\n\n \nstatic int snd_pmac_detect(struct snd_pmac *chip)\n{\n\tstruct device_node *sound;\n\tstruct device_node *dn;\n\tconst unsigned int *prop;\n\tunsigned int l;\n\tstruct macio_chip* macio;\n\n\tif (!machine_is(powermac))\n\t\treturn -ENODEV;\n\n\tchip->subframe = 0;\n\tchip->revision = 0;\n\tchip->freqs_ok = 0xff;  \n\tchip->model = PMAC_AWACS;\n\tchip->can_byte_swap = 1;\n\tchip->can_duplex = 1;\n\tchip->can_capture = 1;\n\tchip->num_freqs = ARRAY_SIZE(awacs_freqs);\n\tchip->freq_table = awacs_freqs;\n\tchip->pdev = NULL;\n\n\tchip->control_mask = MASK_IEPC | MASK_IEE | 0x11;  \n\n\t \n\tif (of_machine_is_compatible(\"AAPL,3400/2400\")\n\t    || of_machine_is_compatible(\"AAPL,3500\"))\n\t\tchip->is_pbook_3400 = 1;\n\telse if (of_machine_is_compatible(\"PowerBook1,1\")\n\t\t || of_machine_is_compatible(\"AAPL,PowerBook1998\"))\n\t\tchip->is_pbook_G3 = 1;\n\tchip->node = of_find_node_by_name(NULL, \"awacs\");\n\tsound = of_node_get(chip->node);\n\n\t \n\tif (!chip->node)\n\t\tchip->node = of_find_node_by_name(NULL, \"davbus\");\n\t \n\tif (! chip->node) {\n\t\tchip->node = of_find_node_by_name(NULL, \"i2s-a\");\n\t\tif (chip->node && chip->node->parent &&\n\t\t    chip->node->parent->parent) {\n\t\t\tif (of_device_is_compatible(chip->node->parent->parent,\n\t\t\t\t\t\t \"K2-Keylargo\"))\n\t\t\t\tchip->is_k2 = 1;\n\t\t}\n\t}\n\tif (! chip->node)\n\t\treturn -ENODEV;\n\n\tif (!sound) {\n\t\tfor_each_node_by_name(sound, \"sound\")\n\t\t\tif (sound->parent == chip->node)\n\t\t\t\tbreak;\n\t}\n\tif (! sound) {\n\t\tof_node_put(chip->node);\n\t\tchip->node = NULL;\n\t\treturn -ENODEV;\n\t}\n\tprop = of_get_property(sound, \"sub-frame\", NULL);\n\tif (prop && *prop < 16)\n\t\tchip->subframe = *prop;\n\tprop = of_get_property(sound, \"layout-id\", NULL);\n\tif (prop) {\n\t\t \n\t\tprintk(KERN_INFO \"snd-powermac no longer handles any \"\n\t\t\t\t \"machines with a layout-id property \"\n\t\t\t\t \"in the device-tree, use snd-aoa.\\n\");\n\t\tof_node_put(sound);\n\t\tof_node_put(chip->node);\n\t\tchip->node = NULL;\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (of_device_is_compatible(sound, \"screamer\")) {\n\t\tchip->model = PMAC_SCREAMER;\n\t\t\n\t}\n\tif (of_device_is_compatible(sound, \"burgundy\")) {\n\t\tchip->model = PMAC_BURGUNDY;\n\t\tchip->control_mask = MASK_IEPC | 0x11;  \n\t}\n\tif (of_device_is_compatible(sound, \"daca\")) {\n\t\tchip->model = PMAC_DACA;\n\t\tchip->can_capture = 0;   \n\t\tchip->can_duplex = 0;\n\t\t\n\t\tchip->control_mask = MASK_IEPC | 0x11;  \n\t}\n\tif (of_device_is_compatible(sound, \"tumbler\")) {\n\t\tchip->model = PMAC_TUMBLER;\n\t\tchip->can_capture = of_machine_is_compatible(\"PowerMac4,2\")\n\t\t\t\t|| of_machine_is_compatible(\"PowerBook3,2\")\n\t\t\t\t|| of_machine_is_compatible(\"PowerBook3,3\")\n\t\t\t\t|| of_machine_is_compatible(\"PowerBook4,1\")\n\t\t\t\t|| of_machine_is_compatible(\"PowerBook4,2\")\n\t\t\t\t|| of_machine_is_compatible(\"PowerBook4,3\");\n\t\tchip->can_duplex = 0;\n\t\t\n\t\tchip->num_freqs = ARRAY_SIZE(tumbler_freqs);\n\t\tchip->freq_table = tumbler_freqs;\n\t\tchip->control_mask = MASK_IEPC | 0x11;  \n\t}\n\tif (of_device_is_compatible(sound, \"snapper\")) {\n\t\tchip->model = PMAC_SNAPPER;\n\t\t\n\t\tchip->num_freqs = ARRAY_SIZE(tumbler_freqs);\n\t\tchip->freq_table = tumbler_freqs;\n\t\tchip->control_mask = MASK_IEPC | 0x11;  \n\t}\n\tprop = of_get_property(sound, \"device-id\", NULL);\n\tif (prop)\n\t\tchip->device_id = *prop;\n\tdn = of_find_node_by_name(NULL, \"perch\");\n\tchip->has_iic = (dn != NULL);\n\tof_node_put(dn);\n\n\t \n\tmacio = macio_find(chip->node, macio_unknown);\n\tif (macio == NULL)\n\t\tprintk(KERN_WARNING \"snd-powermac: can't locate macio !\\n\");\n\telse {\n\t\tstruct pci_dev *pdev = NULL;\n\n\t\tfor_each_pci_dev(pdev) {\n\t\t\tstruct device_node *np = pci_device_to_OF_node(pdev);\n\t\t\tif (np && np == macio->of_node) {\n\t\t\t\tchip->pdev = pdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (chip->pdev == NULL)\n\t\tprintk(KERN_WARNING \"snd-powermac: can't locate macio PCI\"\n\t\t       \" device !\\n\");\n\n\tdetect_byte_swap(chip);\n\n\t \n\tprop = of_get_property(sound, \"sample-rates\", &l);\n\tif (! prop)\n\t\tprop = of_get_property(sound, \"output-frame-rates\", &l);\n\tif (prop) {\n\t\tint i;\n\t\tchip->freqs_ok = 0;\n\t\tfor (l /= sizeof(int); l > 0; --l) {\n\t\t\tunsigned int r = *prop++;\n\t\t\t \n\t\t\tif (r >= 0x10000)\n\t\t\t\tr >>= 16;\n\t\t\tfor (i = 0; i < chip->num_freqs; ++i) {\n\t\t\t\tif (r == chip->freq_table[i]) {\n\t\t\t\t\tchip->freqs_ok |= (1 << i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tchip->freqs_ok = 1;\n\t}\n\n\tof_node_put(sound);\n\treturn 0;\n}\n\n#ifdef PMAC_SUPPORT_AUTOMUTE\n \nstatic int pmac_auto_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = chip->auto_mute;\n\treturn 0;\n}\n\nstatic int pmac_auto_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tif (ucontrol->value.integer.value[0] != chip->auto_mute) {\n\t\tchip->auto_mute = !!ucontrol->value.integer.value[0];\n\t\tif (chip->update_automute)\n\t\t\tchip->update_automute(chip, 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tif (chip->detect_headphone)\n\t\tucontrol->value.integer.value[0] = chip->detect_headphone(chip);\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new auto_mute_controls[] = {\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Auto Mute Switch\",\n\t  .info = snd_pmac_boolean_mono_info,\n\t  .get = pmac_auto_mute_get,\n\t  .put = pmac_auto_mute_put,\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Headphone Detection\",\n\t  .access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t  .info = snd_pmac_boolean_mono_info,\n\t  .get = pmac_hp_detect_get,\n\t},\n};\n\nint snd_pmac_add_automute(struct snd_pmac *chip)\n{\n\tint err;\n\tchip->auto_mute = 1;\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"snd-powermac: Failed to add automute control\\n\");\n\t\treturn err;\n\t}\n\tchip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);\n\treturn snd_ctl_add(chip->card, chip->hp_detect_ctl);\n}\n#endif  \n\n \nint snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)\n{\n\tstruct snd_pmac *chip;\n\tstruct device_node *np;\n\tint i, err;\n\tunsigned int irq;\n\tunsigned long ctrl_addr, txdma_addr, rxdma_addr;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_pmac_dev_free,\n\t};\n\n\t*chip_return = NULL;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tchip->card = card;\n\n\tspin_lock_init(&chip->reg_lock);\n\tchip->irq = chip->tx_irq = chip->rx_irq = -1;\n\n\tchip->playback.stream = SNDRV_PCM_STREAM_PLAYBACK;\n\tchip->capture.stream = SNDRV_PCM_STREAM_CAPTURE;\n\n\terr = snd_pmac_detect(chip);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tif (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n\t    snd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n\t    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0 ||\n\t    snd_pmac_dbdma_alloc(chip, &emergency_dbdma, 2) < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\tnp = chip->node;\n\tchip->requested = 0;\n\tif (chip->is_k2) {\n\t\tstatic const char * const rnames[] = {\n\t\t\t\"Sound Control\", \"Sound DMA\" };\n\t\tfor (i = 0; i < 2; i ++) {\n\t\t\tif (of_address_to_resource(np->parent, i,\n\t\t\t\t\t\t   &chip->rsrc[i])) {\n\t\t\t\tprintk(KERN_ERR \"snd: can't translate rsrc \"\n\t\t\t\t       \" %d (%s)\\n\", i, rnames[i]);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tif (request_mem_region(chip->rsrc[i].start,\n\t\t\t\t\t       resource_size(&chip->rsrc[i]),\n\t\t\t\t\t       rnames[i]) == NULL) {\n\t\t\t\tprintk(KERN_ERR \"snd: can't request rsrc \"\n\t\t\t\t       \" %d (%s: %pR)\\n\",\n\t\t\t\t       i, rnames[i], &chip->rsrc[i]);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip->requested |= (1 << i);\n\t\t}\n\t\tctrl_addr = chip->rsrc[0].start;\n\t\ttxdma_addr = chip->rsrc[1].start;\n\t\trxdma_addr = txdma_addr + 0x100;\n\t} else {\n\t\tstatic const char * const rnames[] = {\n\t\t\t\"Sound Control\", \"Sound Tx DMA\", \"Sound Rx DMA\" };\n\t\tfor (i = 0; i < 3; i ++) {\n\t\t\tif (of_address_to_resource(np, i,\n\t\t\t\t\t\t   &chip->rsrc[i])) {\n\t\t\t\tprintk(KERN_ERR \"snd: can't translate rsrc \"\n\t\t\t\t       \" %d (%s)\\n\", i, rnames[i]);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tif (request_mem_region(chip->rsrc[i].start,\n\t\t\t\t\t       resource_size(&chip->rsrc[i]),\n\t\t\t\t\t       rnames[i]) == NULL) {\n\t\t\t\tprintk(KERN_ERR \"snd: can't request rsrc \"\n\t\t\t\t       \" %d (%s: %pR)\\n\",\n\t\t\t\t       i, rnames[i], &chip->rsrc[i]);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip->requested |= (1 << i);\n\t\t}\n\t\tctrl_addr = chip->rsrc[0].start;\n\t\ttxdma_addr = chip->rsrc[1].start;\n\t\trxdma_addr = chip->rsrc[2].start;\n\t}\n\n\tchip->awacs = ioremap(ctrl_addr, 0x1000);\n\tchip->playback.dma = ioremap(txdma_addr, 0x100);\n\tchip->capture.dma = ioremap(rxdma_addr, 0x100);\n\tif (chip->model <= PMAC_BURGUNDY) {\n\t\tirq = irq_of_parse_and_map(np, 0);\n\t\tif (request_irq(irq, snd_pmac_ctrl_intr, 0,\n\t\t\t\t\"PMac\", (void*)chip)) {\n\t\t\tsnd_printk(KERN_ERR \"pmac: unable to grab IRQ %d\\n\",\n\t\t\t\t   irq);\n\t\t\terr = -EBUSY;\n\t\t\tgoto __error;\n\t\t}\n\t\tchip->irq = irq;\n\t}\n\tirq = irq_of_parse_and_map(np, 1);\n\tif (request_irq(irq, snd_pmac_tx_intr, 0, \"PMac Output\", (void*)chip)){\n\t\tsnd_printk(KERN_ERR \"pmac: unable to grab IRQ %d\\n\", irq);\n\t\terr = -EBUSY;\n\t\tgoto __error;\n\t}\n\tchip->tx_irq = irq;\n\tirq = irq_of_parse_and_map(np, 2);\n\tif (request_irq(irq, snd_pmac_rx_intr, 0, \"PMac Input\", (void*)chip)) {\n\t\tsnd_printk(KERN_ERR \"pmac: unable to grab IRQ %d\\n\", irq);\n\t\terr = -EBUSY;\n\t\tgoto __error;\n\t}\n\tchip->rx_irq = irq;\n\n\tsnd_pmac_sound_feature(chip, 1);\n\n\t \n\tif (chip->model <= PMAC_BURGUNDY)\n\t\tout_le32(&chip->awacs->control, chip->control_mask);\n\n\t \n\tif (chip->is_pbook_3400) {\n\t\t \n\t\t \n\t\tchip->latch_base = ioremap (0xf301a000, 0x1000);\n\t\tin_8(chip->latch_base + 0x190);\n\t} else if (chip->is_pbook_G3) {\n\t\tstruct device_node* mio;\n\t\tfor (mio = chip->node->parent; mio; mio = mio->parent) {\n\t\t\tif (of_node_name_eq(mio, \"mac-io\")) {\n\t\t\t\tstruct resource r;\n\t\t\t\tif (of_address_to_resource(mio, 0, &r) == 0)\n\t\t\t\t\tchip->macio_base =\n\t\t\t\t\t\tioremap(r.start, 0x40);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\t \n\t\tif (chip->macio_base)\n\t\t\tout_8(chip->macio_base + 0x37, 3);\n\t}\n\n\t \n\tsnd_pmac_dbdma_reset(chip);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t*chip_return = chip;\n\treturn 0;\n\n __error:\n\tsnd_pmac_free(chip);\n\treturn err;\n}\n\n\n \n\n#ifdef CONFIG_PM\n\n \n\nvoid snd_pmac_suspend(struct snd_pmac *chip)\n{\n\tunsigned long flags;\n\n\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tif (chip->suspend)\n\t\tchip->suspend(chip);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_pmac_beep_stop(chip);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (chip->irq >= 0)\n\t\tdisable_irq(chip->irq);\n\tif (chip->tx_irq >= 0)\n\t\tdisable_irq(chip->tx_irq);\n\tif (chip->rx_irq >= 0)\n\t\tdisable_irq(chip->rx_irq);\n\tsnd_pmac_sound_feature(chip, 0);\n}\n\nvoid snd_pmac_resume(struct snd_pmac *chip)\n{\n\tsnd_pmac_sound_feature(chip, 1);\n\tif (chip->resume)\n\t\tchip->resume(chip);\n\t \n\tif (chip->macio_base && chip->is_pbook_G3)\n\t\tout_8(chip->macio_base + 0x37, 3);\n\telse if (chip->is_pbook_3400)\n\t\tin_8(chip->latch_base + 0x190);\n\n\tsnd_pmac_pcm_set_format(chip);\n\n\tif (chip->irq >= 0)\n\t\tenable_irq(chip->irq);\n\tif (chip->tx_irq >= 0)\n\t\tenable_irq(chip->tx_irq);\n\tif (chip->rx_irq >= 0)\n\t\tenable_irq(chip->rx_irq);\n\n\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n}\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}