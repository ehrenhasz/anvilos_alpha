{
  "module_name": "tumbler.c",
  "hash_id": "5e6ba19d3c8f39f9748224d6c92268f4b967f85cb8f37c2e0185dc68a0f461bc",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/tumbler.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/of_irq.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <asm/irq.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include \"pmac.h\"\n#include \"tumbler_volume.h\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(fmt...) printk(KERN_DEBUG fmt)\n#else\n#define DBG(fmt...)\n#endif\n\n#define IS_G4DA (of_machine_is_compatible(\"PowerMac3,4\"))\n\n \n#define TAS_I2C_ADDR\t0x34\n\n \n#define TAS_REG_MCS\t0x01\t \n#define TAS_REG_DRC\t0x02\n#define TAS_REG_VOL\t0x04\n#define TAS_REG_TREBLE\t0x05\n#define TAS_REG_BASS\t0x06\n#define TAS_REG_INPUT1\t0x07\n#define TAS_REG_INPUT2\t0x08\n\n \n#define TAS_REG_PCM\tTAS_REG_INPUT1\n \n \n#define TAS_REG_LMIX\tTAS_REG_INPUT1\n#define TAS_REG_RMIX\tTAS_REG_INPUT2\n#define TAS_REG_MCS2\t0x43\t\t \n#define TAS_REG_ACS\t0x40\t\t \n\n \nenum {\n\tVOL_IDX_PCM_MONO,  \n\tVOL_IDX_BASS, VOL_IDX_TREBLE,\n\tVOL_IDX_LAST_MONO\n};\n\n \nenum {\n\tVOL_IDX_PCM, VOL_IDX_PCM2, VOL_IDX_ADC,\n\tVOL_IDX_LAST_MIX\n};\n\nstruct pmac_gpio {\n\tunsigned int addr;\n\tu8 active_val;\n\tu8 inactive_val;\n\tu8 active_state;\n};\n\nstruct pmac_tumbler {\n\tstruct pmac_keywest i2c;\n\tstruct pmac_gpio audio_reset;\n\tstruct pmac_gpio amp_mute;\n\tstruct pmac_gpio line_mute;\n\tstruct pmac_gpio line_detect;\n\tstruct pmac_gpio hp_mute;\n\tstruct pmac_gpio hp_detect;\n\tint headphone_irq;\n\tint lineout_irq;\n\tunsigned int save_master_vol[2];\n\tunsigned int master_vol[2];\n\tunsigned int save_master_switch[2];\n\tunsigned int master_switch[2];\n\tunsigned int mono_vol[VOL_IDX_LAST_MONO];\n\tunsigned int mix_vol[VOL_IDX_LAST_MIX][2];  \n\tint drc_range;\n\tint drc_enable;\n\tint capture_source;\n\tint anded_reset;\n\tint auto_mute_notify;\n\tint reset_on_sleep;\n\tu8  acs;\n};\n\n\n \n\nstatic int send_init_client(struct pmac_keywest *i2c, const unsigned int *regs)\n{\n\twhile (*regs > 0) {\n\t\tint err, count = 10;\n\t\tdo {\n\t\t\terr = i2c_smbus_write_byte_data(i2c->client,\n\t\t\t\t\t\t\tregs[0], regs[1]);\n\t\t\tif (err >= 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"(W) i2c error %d\\n\", err);\n\t\t\tmdelay(10);\n\t\t} while (count--);\n\t\tif (err < 0)\n\t\t\treturn -ENXIO;\n\t\tregs += 2;\n\t}\n\treturn 0;\n}\n\n\nstatic int tumbler_init_client(struct pmac_keywest *i2c)\n{\n\tstatic const unsigned int regs[] = {\n\t\t \n\t\tTAS_REG_MCS, (1<<6)|(2<<4)|(2<<2)|0,\n\t\t0,  \n\t};\n\tDBG(\"(I) tumbler init client\\n\");\n\treturn send_init_client(i2c, regs);\n}\n\nstatic int snapper_init_client(struct pmac_keywest *i2c)\n{\n\tstatic const unsigned int regs[] = {\n\t\t \n\t\tTAS_REG_MCS, (1<<6)|(2<<4)|0,\n\t\t \n\t\tTAS_REG_MCS2, (1<<1),\n\t\t \n\t\tTAS_REG_ACS, 0,\n\t\t0,  \n\t};\n\tDBG(\"(I) snapper init client\\n\");\n\treturn send_init_client(i2c, regs);\n}\n\t\n \n#define do_gpio_write(gp, val) \\\n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, (gp)->addr, val)\n#define do_gpio_read(gp) \\\n\tpmac_call_feature(PMAC_FTR_READ_GPIO, NULL, (gp)->addr, 0)\n#define tumbler_gpio_free(gp)  \n\nstatic void write_audio_gpio(struct pmac_gpio *gp, int active)\n{\n\tif (! gp->addr)\n\t\treturn;\n\tactive = active ? gp->active_val : gp->inactive_val;\n\tdo_gpio_write(gp, active);\n\tDBG(\"(I) gpio %x write %d\\n\", gp->addr, active);\n}\n\nstatic int check_audio_gpio(struct pmac_gpio *gp)\n{\n\tint ret;\n\n\tif (! gp->addr)\n\t\treturn 0;\n\n\tret = do_gpio_read(gp);\n\n\treturn (ret & 0x1) == (gp->active_val & 0x1);\n}\n\nstatic int read_audio_gpio(struct pmac_gpio *gp)\n{\n\tint ret;\n\tif (! gp->addr)\n\t\treturn 0;\n\tret = do_gpio_read(gp);\n\tret = (ret & 0x02) !=0;\n\treturn ret == gp->active_state;\n}\n\n \nstatic int tumbler_set_master_volume(struct pmac_tumbler *mix)\n{\n\tunsigned char block[6];\n\tunsigned int left_vol, right_vol;\n  \n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n  \n\tif (! mix->master_switch[0])\n\t\tleft_vol = 0;\n\telse {\n\t\tleft_vol = mix->master_vol[0];\n\t\tif (left_vol >= ARRAY_SIZE(master_volume_table))\n\t\t\tleft_vol = ARRAY_SIZE(master_volume_table) - 1;\n\t\tleft_vol = master_volume_table[left_vol];\n\t}\n\tif (! mix->master_switch[1])\n\t\tright_vol = 0;\n\telse {\n\t\tright_vol = mix->master_vol[1];\n\t\tif (right_vol >= ARRAY_SIZE(master_volume_table))\n\t\t\tright_vol = ARRAY_SIZE(master_volume_table) - 1;\n\t\tright_vol = master_volume_table[right_vol];\n\t}\n\n\tblock[0] = (left_vol >> 16) & 0xff;\n\tblock[1] = (left_vol >> 8)  & 0xff;\n\tblock[2] = (left_vol >> 0)  & 0xff;\n\n\tblock[3] = (right_vol >> 16) & 0xff;\n\tblock[4] = (right_vol >> 8)  & 0xff;\n\tblock[5] = (right_vol >> 0)  & 0xff;\n  \n\tif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_VOL, 6,\n\t\t\t\t\t   block) < 0) {\n\t\tsnd_printk(KERN_ERR \"failed to set volume \\n\");\n\t\treturn -EINVAL;\n\t}\n\tDBG(\"(I) succeeded to set volume (%u, %u)\\n\", left_vol, right_vol);\n\treturn 0;\n}\n\n\n \nstatic int tumbler_info_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = ARRAY_SIZE(master_volume_table) - 1;\n\treturn 0;\n}\n\nstatic int tumbler_get_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = mix->master_vol[0];\n\tucontrol->value.integer.value[1] = mix->master_vol[1];\n\treturn 0;\n}\n\nstatic int tumbler_put_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tunsigned int vol[2];\n\tint change;\n\n\tvol[0] = ucontrol->value.integer.value[0];\n\tvol[1] = ucontrol->value.integer.value[1];\n\tif (vol[0] >= ARRAY_SIZE(master_volume_table) ||\n\t    vol[1] >= ARRAY_SIZE(master_volume_table))\n\t\treturn -EINVAL;\n\tchange = mix->master_vol[0] != vol[0] ||\n\t\tmix->master_vol[1] != vol[1];\n\tif (change) {\n\t\tmix->master_vol[0] = vol[0];\n\t\tmix->master_vol[1] = vol[1];\n\t\ttumbler_set_master_volume(mix);\n\t}\n\treturn change;\n}\n\n \nstatic int tumbler_get_master_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tucontrol->value.integer.value[0] = mix->master_switch[0];\n\tucontrol->value.integer.value[1] = mix->master_switch[1];\n\treturn 0;\n}\n\nstatic int tumbler_put_master_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tint change;\n\n\tchange = mix->master_switch[0] != ucontrol->value.integer.value[0] ||\n\t\tmix->master_switch[1] != ucontrol->value.integer.value[1];\n\tif (change) {\n\t\tmix->master_switch[0] = !!ucontrol->value.integer.value[0];\n\t\tmix->master_switch[1] = !!ucontrol->value.integer.value[1];\n\t\ttumbler_set_master_volume(mix);\n\t}\n\treturn change;\n}\n\n\n \n\n#define TAS3001_DRC_MAX\t\t0x5f\n\nstatic int tumbler_set_drc(struct pmac_tumbler *mix)\n{\n\tunsigned char val[2];\n\n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n  \n\tif (mix->drc_enable) {\n\t\tval[0] = 0xc1;  \n\t\tif (mix->drc_range > TAS3001_DRC_MAX)\n\t\t\tval[1] = 0xf0;\n\t\telse if (mix->drc_range < 0)\n\t\t\tval[1] = 0x91;\n\t\telse\n\t\t\tval[1] = mix->drc_range + 0x91;\n\t} else {\n\t\tval[0] = 0;\n\t\tval[1] = 0;\n\t}\n\n\tif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_DRC,\n\t\t\t\t\t   2, val) < 0) {\n\t\tsnd_printk(KERN_ERR \"failed to set DRC\\n\");\n\t\treturn -EINVAL;\n\t}\n\tDBG(\"(I) succeeded to set DRC (%u, %u)\\n\", val[0], val[1]);\n\treturn 0;\n}\n\n \n\n#define TAS3004_DRC_MAX\t\t0xef\n\nstatic int snapper_set_drc(struct pmac_tumbler *mix)\n{\n\tunsigned char val[6];\n\n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n  \n\tif (mix->drc_enable)\n\t\tval[0] = 0x50;  \n\telse\n\t\tval[0] = 0x51;  \n\tval[1] = 0x02;  \n\tif (mix->drc_range > 0xef)\n\t\tval[2] = 0xef;\n\telse if (mix->drc_range < 0)\n\t\tval[2] = 0x00;\n\telse\n\t\tval[2] = mix->drc_range;\n\tval[3] = 0xb0;\n\tval[4] = 0x60;\n\tval[5] = 0xa0;\n\n\tif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_DRC,\n\t\t\t\t\t   6, val) < 0) {\n\t\tsnd_printk(KERN_ERR \"failed to set DRC\\n\");\n\t\treturn -EINVAL;\n\t}\n\tDBG(\"(I) succeeded to set DRC (%u, %u)\\n\", val[0], val[1]);\n\treturn 0;\n}\n\nstatic int tumbler_info_drc_value(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max =\n\t\tchip->model == PMAC_TUMBLER ? TAS3001_DRC_MAX : TAS3004_DRC_MAX;\n\treturn 0;\n}\n\nstatic int tumbler_get_drc_value(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tucontrol->value.integer.value[0] = mix->drc_range;\n\treturn 0;\n}\n\nstatic int tumbler_put_drc_value(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tunsigned int val;\n\tint change;\n\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tval = ucontrol->value.integer.value[0];\n\tif (chip->model == PMAC_TUMBLER) {\n\t\tif (val > TAS3001_DRC_MAX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (val > TAS3004_DRC_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\tchange = mix->drc_range != val;\n\tif (change) {\n\t\tmix->drc_range = val;\n\t\tif (chip->model == PMAC_TUMBLER)\n\t\t\ttumbler_set_drc(mix);\n\t\telse\n\t\t\tsnapper_set_drc(mix);\n\t}\n\treturn change;\n}\n\nstatic int tumbler_get_drc_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tucontrol->value.integer.value[0] = mix->drc_enable;\n\treturn 0;\n}\n\nstatic int tumbler_put_drc_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tint change;\n\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tchange = mix->drc_enable != ucontrol->value.integer.value[0];\n\tif (change) {\n\t\tmix->drc_enable = !!ucontrol->value.integer.value[0];\n\t\tif (chip->model == PMAC_TUMBLER)\n\t\t\ttumbler_set_drc(mix);\n\t\telse\n\t\t\tsnapper_set_drc(mix);\n\t}\n\treturn change;\n}\n\n\n \n\nstruct tumbler_mono_vol {\n\tint index;\n\tint reg;\n\tint bytes;\n\tunsigned int max;\n\tconst unsigned int *table;\n};\n\nstatic int tumbler_set_mono_volume(struct pmac_tumbler *mix,\n\t\t\t\t   const struct tumbler_mono_vol *info)\n{\n\tunsigned char block[4];\n\tunsigned int vol;\n\tint i;\n  \n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n  \n\tvol = mix->mono_vol[info->index];\n\tif (vol >= info->max)\n\t\tvol = info->max - 1;\n\tvol = info->table[vol];\n\tfor (i = 0; i < info->bytes; i++)\n\t\tblock[i] = (vol >> ((info->bytes - i - 1) * 8)) & 0xff;\n\tif (i2c_smbus_write_i2c_block_data(mix->i2c.client, info->reg,\n\t\t\t\t\t   info->bytes, block) < 0) {\n\t\tsnd_printk(KERN_ERR \"failed to set mono volume %d\\n\",\n\t\t\t   info->index);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tumbler_info_mono(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = info->max - 1;\n\treturn 0;\n}\n\nstatic int tumbler_get_mono(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tucontrol->value.integer.value[0] = mix->mono_vol[info->index];\n\treturn 0;\n}\n\nstatic int tumbler_put_mono(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tunsigned int vol;\n\tint change;\n\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tvol = ucontrol->value.integer.value[0];\n\tif (vol >= info->max)\n\t\treturn -EINVAL;\n\tchange = mix->mono_vol[info->index] != vol;\n\tif (change) {\n\t\tmix->mono_vol[info->index] = vol;\n\t\ttumbler_set_mono_volume(mix, info);\n\t}\n\treturn change;\n}\n\n \nstatic const struct tumbler_mono_vol tumbler_pcm_vol_info = {\n\t.index = VOL_IDX_PCM_MONO,\n\t.reg = TAS_REG_PCM,\n\t.bytes = 3,\n\t.max = ARRAY_SIZE(mixer_volume_table),\n\t.table = mixer_volume_table,\n};\n\nstatic const struct tumbler_mono_vol tumbler_bass_vol_info = {\n\t.index = VOL_IDX_BASS,\n\t.reg = TAS_REG_BASS,\n\t.bytes = 1,\n\t.max = ARRAY_SIZE(bass_volume_table),\n\t.table = bass_volume_table,\n};\n\nstatic const struct tumbler_mono_vol tumbler_treble_vol_info = {\n\t.index = VOL_IDX_TREBLE,\n\t.reg = TAS_REG_TREBLE,\n\t.bytes = 1,\n\t.max = ARRAY_SIZE(treble_volume_table),\n\t.table = treble_volume_table,\n};\n\n \nstatic const struct tumbler_mono_vol snapper_bass_vol_info = {\n\t.index = VOL_IDX_BASS,\n\t.reg = TAS_REG_BASS,\n\t.bytes = 1,\n\t.max = ARRAY_SIZE(snapper_bass_volume_table),\n\t.table = snapper_bass_volume_table,\n};\n\nstatic const struct tumbler_mono_vol snapper_treble_vol_info = {\n\t.index = VOL_IDX_TREBLE,\n\t.reg = TAS_REG_TREBLE,\n\t.bytes = 1,\n\t.max = ARRAY_SIZE(snapper_treble_volume_table),\n\t.table = snapper_treble_volume_table,\n};\n\n\n#define DEFINE_MONO(xname,type) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\\\n\t.name = xname, \\\n\t.info = tumbler_info_mono, \\\n\t.get = tumbler_get_mono, \\\n\t.put = tumbler_put_mono, \\\n\t.private_value = (unsigned long)(&tumbler_##type##_vol_info), \\\n}\n\n#define DEFINE_SNAPPER_MONO(xname,type) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\\\n\t.name = xname, \\\n\t.info = tumbler_info_mono, \\\n\t.get = tumbler_get_mono, \\\n\t.put = tumbler_put_mono, \\\n\t.private_value = (unsigned long)(&snapper_##type##_vol_info), \\\n}\n\n\n \n\nstatic int snapper_set_mix_vol1(struct pmac_tumbler *mix, int idx, int ch, int reg)\n{\n\tint i, j, vol;\n\tunsigned char block[9];\n\n\tvol = mix->mix_vol[idx][ch];\n\tif (vol >= ARRAY_SIZE(mixer_volume_table)) {\n\t\tvol = ARRAY_SIZE(mixer_volume_table) - 1;\n\t\tmix->mix_vol[idx][ch] = vol;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tvol = mix->mix_vol[i][ch];\n\t\tvol = mixer_volume_table[vol];\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tblock[i * 3 + j] = (vol >> ((2 - j) * 8)) & 0xff;\n\t}\n\tif (i2c_smbus_write_i2c_block_data(mix->i2c.client, reg,\n\t\t\t\t\t   9, block) < 0) {\n\t\tsnd_printk(KERN_ERR \"failed to set mono volume %d\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int snapper_set_mix_vol(struct pmac_tumbler *mix, int idx)\n{\n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n\tif (snapper_set_mix_vol1(mix, idx, 0, TAS_REG_LMIX) < 0 ||\n\t    snapper_set_mix_vol1(mix, idx, 1, TAS_REG_RMIX) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int snapper_info_mix(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = ARRAY_SIZE(mixer_volume_table) - 1;\n\treturn 0;\n}\n\nstatic int snapper_get_mix(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tint idx = (int)kcontrol->private_value;\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tucontrol->value.integer.value[0] = mix->mix_vol[idx][0];\n\tucontrol->value.integer.value[1] = mix->mix_vol[idx][1];\n\treturn 0;\n}\n\nstatic int snapper_put_mix(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tint idx = (int)kcontrol->private_value;\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tunsigned int vol[2];\n\tint change;\n\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tvol[0] = ucontrol->value.integer.value[0];\n\tvol[1] = ucontrol->value.integer.value[1];\n\tif (vol[0] >= ARRAY_SIZE(mixer_volume_table) ||\n\t    vol[1] >= ARRAY_SIZE(mixer_volume_table))\n\t\treturn -EINVAL;\n\tchange = mix->mix_vol[idx][0] != vol[0] ||\n\t\tmix->mix_vol[idx][1] != vol[1];\n\tif (change) {\n\t\tmix->mix_vol[idx][0] = vol[0];\n\t\tmix->mix_vol[idx][1] = vol[1];\n\t\tsnapper_set_mix_vol(mix, idx);\n\t}\n\treturn change;\n}\n\n\n \n\nenum { TUMBLER_MUTE_HP, TUMBLER_MUTE_AMP, TUMBLER_MUTE_LINE };\n\nstatic int tumbler_get_mute_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tstruct pmac_gpio *gp;\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tswitch(kcontrol->private_value) {\n\tcase TUMBLER_MUTE_HP:\n\t\tgp = &mix->hp_mute;\tbreak;\n\tcase TUMBLER_MUTE_AMP:\n\t\tgp = &mix->amp_mute;\tbreak;\n\tcase TUMBLER_MUTE_LINE:\n\t\tgp = &mix->line_mute;\tbreak;\n\tdefault:\n\t\tgp = NULL;\n\t}\n\tif (gp == NULL)\n\t\treturn -EINVAL;\n\tucontrol->value.integer.value[0] = !check_audio_gpio(gp);\n\treturn 0;\n}\n\nstatic int tumbler_put_mute_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix;\n\tstruct pmac_gpio *gp;\n\tint val;\n#ifdef PMAC_SUPPORT_AUTOMUTE\n\tif (chip->update_automute && chip->auto_mute)\n\t\treturn 0;  \n#endif\t\n\tmix = chip->mixer_data;\n\tif (!mix)\n\t\treturn -ENODEV;\n\tswitch(kcontrol->private_value) {\n\tcase TUMBLER_MUTE_HP:\n\t\tgp = &mix->hp_mute;\tbreak;\n\tcase TUMBLER_MUTE_AMP:\n\t\tgp = &mix->amp_mute;\tbreak;\n\tcase TUMBLER_MUTE_LINE:\n\t\tgp = &mix->line_mute;\tbreak;\n\tdefault:\n\t\tgp = NULL;\n\t}\n\tif (gp == NULL)\n\t\treturn -EINVAL;\n\tval = ! check_audio_gpio(gp);\n\tif (val != ucontrol->value.integer.value[0]) {\n\t\twrite_audio_gpio(gp, ! ucontrol->value.integer.value[0]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snapper_set_capture_source(struct pmac_tumbler *mix)\n{\n\tif (! mix->i2c.client)\n\t\treturn -ENODEV;\n\tif (mix->capture_source)\n\t\tmix->acs |= 2;\n\telse\n\t\tmix->acs &= ~2;\n\treturn i2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\n}\n\nstatic int snapper_info_capture_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\n\t\t\"Line\", \"Mic\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snapper_get_capture_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tucontrol->value.enumerated.item[0] = mix->capture_source;\n\treturn 0;\n}\n\nstatic int snapper_put_capture_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tint change;\n\n\tchange = ucontrol->value.enumerated.item[0] != mix->capture_source;\n\tif (change) {\n\t\tmix->capture_source = !!ucontrol->value.enumerated.item[0];\n\t\tsnapper_set_capture_source(mix);\n\t}\n\treturn change;\n}\n\n#define DEFINE_SNAPPER_MIX(xname,idx,ofs) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\\\n\t.name = xname, \\\n\t.info = snapper_info_mix, \\\n\t.get = snapper_get_mix, \\\n\t.put = snapper_put_mix, \\\n\t.index = idx,\\\n\t.private_value = ofs, \\\n}\n\n\n \nstatic const struct snd_kcontrol_new tumbler_mixers[] = {\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Master Playback Volume\",\n\t  .info = tumbler_info_master_volume,\n\t  .get = tumbler_get_master_volume,\n\t  .put = tumbler_put_master_volume\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Master Playback Switch\",\n\t  .info = snd_pmac_boolean_stereo_info,\n\t  .get = tumbler_get_master_switch,\n\t  .put = tumbler_put_master_switch\n\t},\n\tDEFINE_MONO(\"Tone Control - Bass\", bass),\n\tDEFINE_MONO(\"Tone Control - Treble\", treble),\n\tDEFINE_MONO(\"PCM Playback Volume\", pcm),\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"DRC Range\",\n\t  .info = tumbler_info_drc_value,\n\t  .get = tumbler_get_drc_value,\n\t  .put = tumbler_put_drc_value\n\t},\n};\n\nstatic const struct snd_kcontrol_new snapper_mixers[] = {\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Master Playback Volume\",\n\t  .info = tumbler_info_master_volume,\n\t  .get = tumbler_get_master_volume,\n\t  .put = tumbler_put_master_volume\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Master Playback Switch\",\n\t  .info = snd_pmac_boolean_stereo_info,\n\t  .get = tumbler_get_master_switch,\n\t  .put = tumbler_put_master_switch\n\t},\n\tDEFINE_SNAPPER_MIX(\"PCM Playback Volume\", 0, VOL_IDX_PCM),\n\t \n\tDEFINE_SNAPPER_MIX(\"Mic Playback Volume\", 0, VOL_IDX_PCM2),\n\tDEFINE_SNAPPER_MIX(\"Monitor Mix Volume\", 0, VOL_IDX_ADC),\n\tDEFINE_SNAPPER_MONO(\"Tone Control - Bass\", bass),\n\tDEFINE_SNAPPER_MONO(\"Tone Control - Treble\", treble),\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"DRC Range\",\n\t  .info = tumbler_info_drc_value,\n\t  .get = tumbler_get_drc_value,\n\t  .put = tumbler_put_drc_value\n\t},\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .name = \"Input Source\",  \n\t  .info = snapper_info_capture_source,\n\t  .get = snapper_get_capture_source,\n\t  .put = snapper_put_capture_source\n\t},\n};\n\nstatic const struct snd_kcontrol_new tumbler_hp_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Headphone Playback Switch\",\n\t.info = snd_pmac_boolean_mono_info,\n\t.get = tumbler_get_mute_switch,\n\t.put = tumbler_put_mute_switch,\n\t.private_value = TUMBLER_MUTE_HP,\n};\nstatic const struct snd_kcontrol_new tumbler_speaker_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Speaker Playback Switch\",\n\t.info = snd_pmac_boolean_mono_info,\n\t.get = tumbler_get_mute_switch,\n\t.put = tumbler_put_mute_switch,\n\t.private_value = TUMBLER_MUTE_AMP,\n};\nstatic const struct snd_kcontrol_new tumbler_lineout_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line Out Playback Switch\",\n\t.info = snd_pmac_boolean_mono_info,\n\t.get = tumbler_get_mute_switch,\n\t.put = tumbler_put_mute_switch,\n\t.private_value = TUMBLER_MUTE_LINE,\n};\nstatic const struct snd_kcontrol_new tumbler_drc_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DRC Switch\",\n\t.info = snd_pmac_boolean_mono_info,\n\t.get = tumbler_get_drc_switch,\n\t.put = tumbler_put_drc_switch\n};\n\n\n#ifdef PMAC_SUPPORT_AUTOMUTE\n \nstatic int tumbler_detect_headphone(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tint detect = 0;\n\n\tif (mix->hp_detect.addr)\n\t\tdetect |= read_audio_gpio(&mix->hp_detect);\n\treturn detect;\n}\n\nstatic int tumbler_detect_lineout(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tint detect = 0;\n\n\tif (mix->line_detect.addr)\n\t\tdetect |= read_audio_gpio(&mix->line_detect);\n\treturn detect;\n}\n\nstatic void check_mute(struct snd_pmac *chip, struct pmac_gpio *gp, int val, int do_notify,\n\t\t       struct snd_kcontrol *sw)\n{\n\tif (check_audio_gpio(gp) != val) {\n\t\twrite_audio_gpio(gp, val);\n\t\tif (do_notify)\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &sw->id);\n\t}\n}\n\nstatic struct work_struct device_change;\nstatic struct snd_pmac *device_change_chip;\n\nstatic void device_change_handler(struct work_struct *work)\n{\n\tstruct snd_pmac *chip = device_change_chip;\n\tstruct pmac_tumbler *mix;\n\tint headphone, lineout;\n\n\tif (!chip)\n\t\treturn;\n\n\tmix = chip->mixer_data;\n\tif (snd_BUG_ON(!mix))\n\t\treturn;\n\n\theadphone = tumbler_detect_headphone(chip);\n\tlineout = tumbler_detect_lineout(chip);\n\n\tDBG(\"headphone: %d, lineout: %d\\n\", headphone, lineout);\n\n\tif (headphone || lineout) {\n\t\t \n\t\tif (headphone)\n\t\t\tcheck_mute(chip, &mix->hp_mute, 0, mix->auto_mute_notify,\n\t\t\t\t   chip->master_sw_ctl);\n\t\tif (lineout && mix->line_mute.addr != 0)\n\t\t\tcheck_mute(chip, &mix->line_mute, 0, mix->auto_mute_notify,\n\t\t\t\t   chip->lineout_sw_ctl);\n\t\tif (mix->anded_reset)\n\t\t\tmsleep(10);\n\t\tcheck_mute(chip, &mix->amp_mute, !IS_G4DA, mix->auto_mute_notify,\n\t\t\t   chip->speaker_sw_ctl);\n\t} else {\n\t\t \n\t\tcheck_mute(chip, &mix->amp_mute, 0, mix->auto_mute_notify,\n\t\t\t   chip->speaker_sw_ctl);\n\t\tif (mix->anded_reset)\n\t\t\tmsleep(10);\n\t\tcheck_mute(chip, &mix->hp_mute, 1, mix->auto_mute_notify,\n\t\t\t   chip->master_sw_ctl);\n\t\tif (mix->line_mute.addr != 0)\n\t\t\tcheck_mute(chip, &mix->line_mute, 1, mix->auto_mute_notify,\n\t\t\t\t   chip->lineout_sw_ctl);\n\t}\n\tif (mix->auto_mute_notify)\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->hp_detect_ctl->id);\n\n#ifdef CONFIG_SND_POWERMAC_AUTO_DRC\n\tmix->drc_enable = ! (headphone || lineout);\n\tif (mix->auto_mute_notify)\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->drc_sw_ctl->id);\n\tif (chip->model == PMAC_TUMBLER)\n\t\ttumbler_set_drc(mix);\n\telse\n\t\tsnapper_set_drc(mix);\n#endif\n\n\t \n\ttumbler_set_master_volume(mix);\n}\n\nstatic void tumbler_update_automute(struct snd_pmac *chip, int do_notify)\n{\n\tif (chip->auto_mute) {\n\t\tstruct pmac_tumbler *mix;\n\t\tmix = chip->mixer_data;\n\t\tif (snd_BUG_ON(!mix))\n\t\t\treturn;\n\t\tmix->auto_mute_notify = do_notify;\n\t\tschedule_work(&device_change);\n\t}\n}\n#endif  \n\n\n \nstatic irqreturn_t headphone_intr(int irq, void *devid)\n{\n\tstruct snd_pmac *chip = devid;\n\tif (chip->update_automute && chip->initialized) {\n\t\tchip->update_automute(chip, 1);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n \nstatic struct device_node *find_audio_device(const char *name)\n{\n\tstruct device_node *gpiop;\n\tstruct device_node *np;\n  \n\tgpiop = of_find_node_by_name(NULL, \"gpio\");\n\tif (! gpiop)\n\t\treturn NULL;\n  \n\tfor_each_child_of_node(gpiop, np) {\n\t\tconst char *property = of_get_property(np, \"audio-gpio\", NULL);\n\t\tif (property && strcmp(property, name) == 0)\n\t\t\tbreak;\n\t}  \n\tof_node_put(gpiop);\n\treturn np;\n}\n\n \nstatic struct device_node *find_compatible_audio_device(const char *name)\n{\n\tstruct device_node *gpiop;\n\tstruct device_node *np;\n  \n\tgpiop = of_find_node_by_name(NULL, \"gpio\");\n\tif (!gpiop)\n\t\treturn NULL;\n  \n\tfor_each_child_of_node(gpiop, np) {\n\t\tif (of_device_is_compatible(np, name))\n\t\t\tbreak;\n\t}  \n\tof_node_put(gpiop);\n\treturn np;\n}\n\n \nstatic long tumbler_find_device(const char *device, const char *platform,\n\t\t\t\tstruct pmac_gpio *gp, int is_compatible)\n{\n\tstruct device_node *node;\n\tconst u32 *base;\n\tu32 addr;\n\tlong ret;\n\n\tif (is_compatible)\n\t\tnode = find_compatible_audio_device(device);\n\telse\n\t\tnode = find_audio_device(device);\n\tif (! node) {\n\t\tDBG(\"(W) cannot find audio device %s !\\n\", device);\n\t\tsnd_printdd(\"cannot find device %s\\n\", device);\n\t\treturn -ENODEV;\n\t}\n\n\tbase = of_get_property(node, \"AAPL,address\", NULL);\n\tif (! base) {\n\t\tbase = of_get_property(node, \"reg\", NULL);\n\t\tif (!base) {\n\t\t\tDBG(\"(E) cannot find address for device %s !\\n\", device);\n\t\t\tsnd_printd(\"cannot find address for device %s\\n\", device);\n\t\t\tof_node_put(node);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\taddr = *base;\n\t\tif (addr < 0x50)\n\t\t\taddr += 0x50;\n\t} else\n\t\taddr = *base;\n\n\tgp->addr = addr & 0x0000ffff;\n\t \n\tbase = of_get_property(node, \"audio-gpio-active-state\", NULL);\n\tif (base) {\n\t\tgp->active_state = *base;\n\t\tgp->active_val = (*base) ? 0x5 : 0x4;\n\t\tgp->inactive_val = (*base) ? 0x4 : 0x5;\n\t} else {\n\t\tconst u32 *prop = NULL;\n\t\tgp->active_state = IS_G4DA\n\t\t\t\t&& !strncmp(device, \"keywest-gpio1\", 13);\n\t\tgp->active_val = 0x4;\n\t\tgp->inactive_val = 0x5;\n\t\t \n\t\tif (platform)\n\t\t\tprop = of_get_property(node, platform, NULL);\n\t\tif (prop) {\n\t\t\tif (prop[3] == 0x9 && prop[4] == 0x9) {\n\t\t\t\tgp->active_val = 0xd;\n\t\t\t\tgp->inactive_val = 0xc;\n\t\t\t}\n\t\t\tif (prop[3] == 0x1 && prop[4] == 0x1) {\n\t\t\t\tgp->active_val = 0x5;\n\t\t\t\tgp->inactive_val = 0x4;\n\t\t\t}\n\t\t}\n\t}\n\n\tDBG(\"(I) GPIO device %s found, offset: %x, active state: %d !\\n\",\n\t    device, gp->addr, gp->active_state);\n\n\tret = irq_of_parse_and_map(node, 0);\n\tof_node_put(node);\n\treturn ret;\n}\n\n \nstatic void tumbler_reset_audio(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tif (mix->anded_reset) {\n\t\tDBG(\"(I) codec anded reset !\\n\");\n\t\twrite_audio_gpio(&mix->hp_mute, 0);\n\t\twrite_audio_gpio(&mix->amp_mute, 0);\n\t\tmsleep(200);\n\t\twrite_audio_gpio(&mix->hp_mute, 1);\n\t\twrite_audio_gpio(&mix->amp_mute, 1);\n\t\tmsleep(100);\n\t\twrite_audio_gpio(&mix->hp_mute, 0);\n\t\twrite_audio_gpio(&mix->amp_mute, 0);\n\t\tmsleep(100);\n\t} else {\n\t\tDBG(\"(I) codec normal reset !\\n\");\n\n\t\twrite_audio_gpio(&mix->audio_reset, 0);\n\t\tmsleep(200);\n\t\twrite_audio_gpio(&mix->audio_reset, 1);\n\t\tmsleep(100);\n\t\twrite_audio_gpio(&mix->audio_reset, 0);\n\t\tmsleep(100);\n\t}\n}\n\n#ifdef CONFIG_PM\n \nstatic void tumbler_suspend(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tif (mix->headphone_irq >= 0)\n\t\tdisable_irq(mix->headphone_irq);\n\tif (mix->lineout_irq >= 0)\n\t\tdisable_irq(mix->lineout_irq);\n\tmix->save_master_switch[0] = mix->master_switch[0];\n\tmix->save_master_switch[1] = mix->master_switch[1];\n\tmix->save_master_vol[0] = mix->master_vol[0];\n\tmix->save_master_vol[1] = mix->master_vol[1];\n\tmix->master_switch[0] = mix->master_switch[1] = 0;\n\ttumbler_set_master_volume(mix);\n\tif (!mix->anded_reset) {\n\t\twrite_audio_gpio(&mix->amp_mute, 1);\n\t\twrite_audio_gpio(&mix->hp_mute, 1);\n\t}\n\tif (chip->model == PMAC_SNAPPER) {\n\t\tmix->acs |= 1;\n\t\ti2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\n\t}\n\tif (mix->anded_reset) {\n\t\twrite_audio_gpio(&mix->amp_mute, 1);\n\t\twrite_audio_gpio(&mix->hp_mute, 1);\n\t} else\n\t\twrite_audio_gpio(&mix->audio_reset, 1);\n}\n\n \nstatic void tumbler_resume(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tmix->acs &= ~1;\n\tmix->master_switch[0] = mix->save_master_switch[0];\n\tmix->master_switch[1] = mix->save_master_switch[1];\n\tmix->master_vol[0] = mix->save_master_vol[0];\n\tmix->master_vol[1] = mix->save_master_vol[1];\n\ttumbler_reset_audio(chip);\n\tif (mix->i2c.client && mix->i2c.init_client) {\n\t\tif (mix->i2c.init_client(&mix->i2c) < 0)\n\t\t\tprintk(KERN_ERR \"tumbler_init_client error\\n\");\n\t} else\n\t\tprintk(KERN_ERR \"tumbler: i2c is not initialized\\n\");\n\tif (chip->model == PMAC_TUMBLER) {\n\t\ttumbler_set_mono_volume(mix, &tumbler_pcm_vol_info);\n\t\ttumbler_set_mono_volume(mix, &tumbler_bass_vol_info);\n\t\ttumbler_set_mono_volume(mix, &tumbler_treble_vol_info);\n\t\ttumbler_set_drc(mix);\n\t} else {\n\t\tsnapper_set_mix_vol(mix, VOL_IDX_PCM);\n\t\tsnapper_set_mix_vol(mix, VOL_IDX_PCM2);\n\t\tsnapper_set_mix_vol(mix, VOL_IDX_ADC);\n\t\ttumbler_set_mono_volume(mix, &snapper_bass_vol_info);\n\t\ttumbler_set_mono_volume(mix, &snapper_treble_vol_info);\n\t\tsnapper_set_drc(mix);\n\t\tsnapper_set_capture_source(mix);\n\t}\n\ttumbler_set_master_volume(mix);\n\tif (chip->update_automute)\n\t\tchip->update_automute(chip, 0);\n\tif (mix->headphone_irq >= 0) {\n\t\tunsigned char val;\n\n\t\tenable_irq(mix->headphone_irq);\n\t\t \n\t\tval = do_gpio_read(&mix->hp_detect);\n\t\tdo_gpio_write(&mix->hp_detect, val | 0x80);\n\t}\n\tif (mix->lineout_irq >= 0)\n\t\tenable_irq(mix->lineout_irq);\n}\n#endif\n\n \nstatic int tumbler_init(struct snd_pmac *chip)\n{\n\tint irq;\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\n\tif (tumbler_find_device(\"audio-hw-reset\",\n\t\t\t\t\"platform-do-hw-reset\",\n\t\t\t\t&mix->audio_reset, 0) < 0)\n\t\ttumbler_find_device(\"hw-reset\",\n\t\t\t\t    \"platform-do-hw-reset\",\n\t\t\t\t    &mix->audio_reset, 1);\n\tif (tumbler_find_device(\"amp-mute\",\n\t\t\t\t\"platform-do-amp-mute\",\n\t\t\t\t&mix->amp_mute, 0) < 0)\n\t\ttumbler_find_device(\"amp-mute\",\n\t\t\t\t    \"platform-do-amp-mute\",\n\t\t\t\t    &mix->amp_mute, 1);\n\tif (tumbler_find_device(\"headphone-mute\",\n\t\t\t\t\"platform-do-headphone-mute\",\n\t\t\t\t&mix->hp_mute, 0) < 0)\n\t\ttumbler_find_device(\"headphone-mute\",\n\t\t\t\t    \"platform-do-headphone-mute\",\n\t\t\t\t    &mix->hp_mute, 1);\n\tif (tumbler_find_device(\"line-output-mute\",\n\t\t\t\t\"platform-do-lineout-mute\",\n\t\t\t\t&mix->line_mute, 0) < 0)\n\t\ttumbler_find_device(\"line-output-mute\",\n\t\t\t\t   \"platform-do-lineout-mute\",\n\t\t\t\t    &mix->line_mute, 1);\n\tirq = tumbler_find_device(\"headphone-detect\",\n\t\t\t\t  NULL, &mix->hp_detect, 0);\n\tif (irq <= 0)\n\t\tirq = tumbler_find_device(\"headphone-detect\",\n\t\t\t\t\t  NULL, &mix->hp_detect, 1);\n\tif (irq <= 0)\n\t\tirq = tumbler_find_device(\"keywest-gpio15\",\n\t\t\t\t\t  NULL, &mix->hp_detect, 1);\n\tmix->headphone_irq = irq;\n \tirq = tumbler_find_device(\"line-output-detect\",\n\t\t\t\t  NULL, &mix->line_detect, 0);\n\tif (irq <= 0)\n\t\tirq = tumbler_find_device(\"line-output-detect\",\n\t\t\t\t\t  NULL, &mix->line_detect, 1);\n\tif (IS_G4DA && irq <= 0)\n\t\tirq = tumbler_find_device(\"keywest-gpio16\",\n\t\t\t\t\t  NULL, &mix->line_detect, 1);\n\tmix->lineout_irq = irq;\n\n\ttumbler_reset_audio(chip);\n  \n\treturn 0;\n}\n\nstatic void tumbler_cleanup(struct snd_pmac *chip)\n{\n\tstruct pmac_tumbler *mix = chip->mixer_data;\n\tif (! mix)\n\t\treturn;\n\n\tif (mix->headphone_irq >= 0)\n\t\tfree_irq(mix->headphone_irq, chip);\n\tif (mix->lineout_irq >= 0)\n\t\tfree_irq(mix->lineout_irq, chip);\n\ttumbler_gpio_free(&mix->audio_reset);\n\ttumbler_gpio_free(&mix->amp_mute);\n\ttumbler_gpio_free(&mix->hp_mute);\n\ttumbler_gpio_free(&mix->hp_detect);\n\tsnd_pmac_keywest_cleanup(&mix->i2c);\n\tkfree(mix);\n\tchip->mixer_data = NULL;\n}\n\n \nint snd_pmac_tumbler_init(struct snd_pmac *chip)\n{\n\tint i, err;\n\tstruct pmac_tumbler *mix;\n\tconst u32 *paddr;\n\tstruct device_node *tas_node, *np;\n\tchar *chipname;\n\n\trequest_module(\"i2c-powermac\");\n\n\tmix = kzalloc(sizeof(*mix), GFP_KERNEL);\n\tif (! mix)\n\t\treturn -ENOMEM;\n\tmix->headphone_irq = -1;\n\n\tchip->mixer_data = mix;\n\tchip->mixer_free = tumbler_cleanup;\n\tmix->anded_reset = 0;\n\tmix->reset_on_sleep = 1;\n\n\tfor_each_child_of_node(chip->node, np) {\n\t\tif (of_node_name_eq(np, \"sound\")) {\n\t\t\tif (of_property_read_bool(np, \"has-anded-reset\"))\n\t\t\t\tmix->anded_reset = 1;\n\t\t\tif (of_property_present(np, \"layout-id\"))\n\t\t\t\tmix->reset_on_sleep = 0;\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = tumbler_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ttas_node = of_find_node_by_name(NULL, \"deq\");\n\tif (tas_node == NULL)\n\t\ttas_node = of_find_node_by_name(NULL, \"codec\");\n\tif (tas_node == NULL)\n\t\treturn -ENODEV;\n\n\tpaddr = of_get_property(tas_node, \"i2c-address\", NULL);\n\tif (paddr == NULL)\n\t\tpaddr = of_get_property(tas_node, \"reg\", NULL);\n\tif (paddr)\n\t\tmix->i2c.addr = (*paddr) >> 1;\n\telse\n\t\tmix->i2c.addr = TAS_I2C_ADDR;\n\tof_node_put(tas_node);\n\n\tDBG(\"(I) TAS i2c address is: %x\\n\", mix->i2c.addr);\n\n\tif (chip->model == PMAC_TUMBLER) {\n\t\tmix->i2c.init_client = tumbler_init_client;\n\t\tmix->i2c.name = \"TAS3001c\";\n\t\tchipname = \"Tumbler\";\n\t} else {\n\t\tmix->i2c.init_client = snapper_init_client;\n\t\tmix->i2c.name = \"TAS3004\";\n\t\tchipname = \"Snapper\";\n\t}\n\n\terr = snd_pmac_keywest_init(&mix->i2c);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsprintf(chip->card->mixername, \"PowerMac %s\", chipname);\n\n\tif (chip->model == PMAC_TUMBLER) {\n\t\tfor (i = 0; i < ARRAY_SIZE(tumbler_mixers); i++) {\n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&tumbler_mixers[i], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(snapper_mixers); i++) {\n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snapper_mixers[i], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tchip->master_sw_ctl = snd_ctl_new1(&tumbler_hp_sw, chip);\n\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n\tchip->speaker_sw_ctl = snd_ctl_new1(&tumbler_speaker_sw, chip);\n\terr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n\tif (mix->line_mute.addr != 0) {\n\t\tchip->lineout_sw_ctl = snd_ctl_new1(&tumbler_lineout_sw, chip);\n\t\terr = snd_ctl_add(chip->card, chip->lineout_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tchip->drc_sw_ctl = snd_ctl_new1(&tumbler_drc_sw, chip);\n\terr = snd_ctl_add(chip->card, chip->drc_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (chip->model == PMAC_TUMBLER)\n\t\tmix->drc_range = (TAS3001_DRC_MAX * 6) / 10;\n\telse\n\t\tmix->drc_range = (TAS3004_DRC_MAX * 6) / 10;\n\tmix->drc_enable = 1;  \n\tif (chip->model == PMAC_TUMBLER)\n\t\ttumbler_set_drc(mix);\n\telse\n\t\tsnapper_set_drc(mix);\n\n#ifdef CONFIG_PM\n\tchip->suspend = tumbler_suspend;\n\tchip->resume = tumbler_resume;\n#endif\n\n\tINIT_WORK(&device_change, device_change_handler);\n\tdevice_change_chip = chip;\n\n#ifdef PMAC_SUPPORT_AUTOMUTE\n\tif (mix->headphone_irq >= 0 || mix->lineout_irq >= 0) {\n\t\terr = snd_pmac_add_automute(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tchip->detect_headphone = tumbler_detect_headphone;\n\tchip->update_automute = tumbler_update_automute;\n\ttumbler_update_automute(chip, 0);  \n\n\t \n  \tif (mix->headphone_irq >= 0) {\n\t\tunsigned char val;\n\t\terr = request_irq(mix->headphone_irq, headphone_intr, 0,\n\t\t\t\t  \"Sound Headphone Detection\", chip);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\t \n\t\tval = do_gpio_read(&mix->hp_detect);\n\t\tdo_gpio_write(&mix->hp_detect, val | 0x80);\n\t}\n  \tif (mix->lineout_irq >= 0) {\n\t\tunsigned char val;\n\t\terr = request_irq(mix->lineout_irq, headphone_intr, 0,\n\t\t\t\t  \"Sound Lineout Detection\", chip);\n\t\tif (err < 0)\n\t\t\treturn 0;\n\t\t \n\t\tval = do_gpio_read(&mix->line_detect);\n\t\tdo_gpio_write(&mix->line_detect, val | 0x80);\n\t}\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}