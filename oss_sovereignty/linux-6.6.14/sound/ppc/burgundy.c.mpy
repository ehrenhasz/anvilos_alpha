{
  "module_name": "burgundy.c",
  "hash_id": "776ba5a384a9256abc995863b2746ded1cb9b02a02f1651c199dd3d26fded058",
  "original_prompt": "Ingested from linux-6.6.14/sound/ppc/burgundy.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <sound/core.h>\n#include \"pmac.h\"\n#include \"burgundy.h\"\n\n\n \nstatic inline void\nsnd_pmac_burgundy_busy_wait(struct snd_pmac *chip)\n{\n\tint timeout = 50;\n\twhile ((in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) && timeout--)\n\t\tudelay(1);\n\tif (timeout < 0)\n\t\tprintk(KERN_DEBUG \"burgundy_busy_wait: timeout\\n\");\n}\n\nstatic inline void\nsnd_pmac_burgundy_extend_wait(struct snd_pmac *chip)\n{\n\tint timeout;\n\ttimeout = 50;\n\twhile (!(in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)\n\t\tudelay(1);\n\tif (timeout < 0)\n\t\tprintk(KERN_DEBUG \"burgundy_extend_wait: timeout #1\\n\");\n\ttimeout = 50;\n\twhile ((in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)\n\t\tudelay(1);\n\tif (timeout < 0)\n\t\tprintk(KERN_DEBUG \"burgundy_extend_wait: timeout #2\\n\");\n}\n\nstatic void\nsnd_pmac_burgundy_wcw(struct snd_pmac *chip, unsigned addr, unsigned val)\n{\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x200c00 + (val & 0xff));\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x200d00 +((val>>8) & 0xff));\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x200e00 +((val>>16) & 0xff));\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x200f00 +((val>>24) & 0xff));\n\tsnd_pmac_burgundy_busy_wait(chip);\n}\n\nstatic unsigned\nsnd_pmac_burgundy_rcw(struct snd_pmac *chip, unsigned addr)\n{\n\tunsigned val = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x100000);\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tsnd_pmac_burgundy_extend_wait(chip);\n\tval += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;\n\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x100100);\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tsnd_pmac_burgundy_extend_wait(chip);\n\tval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<8;\n\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x100200);\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tsnd_pmac_burgundy_extend_wait(chip);\n\tval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<16;\n\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x100300);\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tsnd_pmac_burgundy_extend_wait(chip);\n\tval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<24;\n\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn val;\n}\n\nstatic void\nsnd_pmac_burgundy_wcb(struct snd_pmac *chip, unsigned int addr,\n\t\t      unsigned int val)\n{\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x300000 + (val & 0xff));\n\tsnd_pmac_burgundy_busy_wait(chip);\n}\n\nstatic unsigned\nsnd_pmac_burgundy_rcb(struct snd_pmac *chip, unsigned int addr)\n{\n\tunsigned val = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\tout_le32(&chip->awacs->codec_ctrl, addr + 0x100000);\n\tsnd_pmac_burgundy_busy_wait(chip);\n\tsnd_pmac_burgundy_extend_wait(chip);\n\tval += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;\n\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn val;\n}\n\n#define BASE2ADDR(base)\t((base) << 12)\n#define ADDR2BASE(addr)\t((addr) >> 12)\n\n \nstatic void\nsnd_pmac_burgundy_write_volume(struct snd_pmac *chip, unsigned int address,\n\t\t\t       long *volume, int shift)\n{\n\tint hardvolume, lvolume, rvolume;\n\n\tif (volume[0] < 0 || volume[0] > 100 ||\n\t    volume[1] < 0 || volume[1] > 100)\n\t\treturn;  \n\tlvolume = volume[0] ? volume[0] + BURGUNDY_VOLUME_OFFSET : 0;\n\trvolume = volume[1] ? volume[1] + BURGUNDY_VOLUME_OFFSET : 0;\n\n\thardvolume = lvolume + (rvolume << shift);\n\tif (shift == 8)\n\t\thardvolume |= hardvolume << 16;\n\n\tsnd_pmac_burgundy_wcw(chip, address, hardvolume);\n}\n\nstatic void\nsnd_pmac_burgundy_read_volume(struct snd_pmac *chip, unsigned int address,\n\t\t\t      long *volume, int shift)\n{\n\tint wvolume;\n\n\twvolume = snd_pmac_burgundy_rcw(chip, address);\n\n\tvolume[0] = wvolume & 0xff;\n\tif (volume[0] >= BURGUNDY_VOLUME_OFFSET)\n\t\tvolume[0] -= BURGUNDY_VOLUME_OFFSET;\n\telse\n\t\tvolume[0] = 0;\n\tvolume[1] = (wvolume >> shift) & 0xff;\n\tif (volume[1] >= BURGUNDY_VOLUME_OFFSET)\n\t\tvolume[1] -= BURGUNDY_VOLUME_OFFSET;\n\telse\n\t\tvolume[1] = 0;\n}\n\nstatic int snd_pmac_burgundy_info_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_get_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tsnd_pmac_burgundy_read_volume(chip, addr,\n\t\t\t\t      ucontrol->value.integer.value, shift);\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_put_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tlong nvoices[2];\n\n\tsnd_pmac_burgundy_write_volume(chip, addr,\n\t\t\t\t       ucontrol->value.integer.value, shift);\n\tsnd_pmac_burgundy_read_volume(chip, addr, nvoices, shift);\n\treturn (nvoices[0] != ucontrol->value.integer.value[0] ||\n\t\tnvoices[1] != ucontrol->value.integer.value[1]);\n}\n\n#define BURGUNDY_VOLUME_W(xname, xindex, addr, shift) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\\\n  .info = snd_pmac_burgundy_info_volume,\\\n  .get = snd_pmac_burgundy_get_volume,\\\n  .put = snd_pmac_burgundy_put_volume,\\\n  .private_value = ((ADDR2BASE(addr) & 0xff) | ((shift) << 8)) }\n\n \nstatic void\nsnd_pmac_burgundy_write_volume_2b(struct snd_pmac *chip, unsigned int address,\n\t\t\t\t  long *volume, int off)\n{\n\tint lvolume, rvolume;\n\n\toff |= off << 2;\n\tlvolume = volume[0] ? volume[0] + BURGUNDY_VOLUME_OFFSET : 0;\n\trvolume = volume[1] ? volume[1] + BURGUNDY_VOLUME_OFFSET : 0;\n\n\tsnd_pmac_burgundy_wcb(chip, address + off, lvolume);\n\tsnd_pmac_burgundy_wcb(chip, address + off + 0x500, rvolume);\n}\n\nstatic void\nsnd_pmac_burgundy_read_volume_2b(struct snd_pmac *chip, unsigned int address,\n\t\t\t\t long *volume, int off)\n{\n\tvolume[0] = snd_pmac_burgundy_rcb(chip, address + off);\n\tif (volume[0] >= BURGUNDY_VOLUME_OFFSET)\n\t\tvolume[0] -= BURGUNDY_VOLUME_OFFSET;\n\telse\n\t\tvolume[0] = 0;\n\tvolume[1] = snd_pmac_burgundy_rcb(chip, address + off + 0x100);\n\tif (volume[1] >= BURGUNDY_VOLUME_OFFSET)\n\t\tvolume[1] -= BURGUNDY_VOLUME_OFFSET;\n\telse\n\t\tvolume[1] = 0;\n}\n\nstatic int snd_pmac_burgundy_info_volume_2b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_get_volume_2b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint off = kcontrol->private_value & 0x300;\n\tsnd_pmac_burgundy_read_volume_2b(chip, addr,\n\t\t\tucontrol->value.integer.value, off);\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_put_volume_2b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint off = kcontrol->private_value & 0x300;\n\tlong nvoices[2];\n\n\tsnd_pmac_burgundy_write_volume_2b(chip, addr,\n\t\t\tucontrol->value.integer.value, off);\n\tsnd_pmac_burgundy_read_volume_2b(chip, addr, nvoices, off);\n\treturn (nvoices[0] != ucontrol->value.integer.value[0] ||\n\t\tnvoices[1] != ucontrol->value.integer.value[1]);\n}\n\n#define BURGUNDY_VOLUME_2B(xname, xindex, addr, off) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\\\n  .info = snd_pmac_burgundy_info_volume_2b,\\\n  .get = snd_pmac_burgundy_get_volume_2b,\\\n  .put = snd_pmac_burgundy_put_volume_2b,\\\n  .private_value = ((ADDR2BASE(addr) & 0xff) | ((off) << 8)) }\n\n \nstatic int snd_pmac_burgundy_info_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 15;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_get_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint atten = (kcontrol->private_value >> 25) & 1;\n\tint oval;\n\n\toval = snd_pmac_burgundy_rcb(chip, addr);\n\tif (atten)\n\t\toval = ~oval & 0xff;\n\tucontrol->value.integer.value[0] = oval & 0xf;\n\tif (stereo)\n\t\tucontrol->value.integer.value[1] = (oval >> 4) & 0xf;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_put_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint atten = (kcontrol->private_value >> 25) & 1;\n\tint oval, val;\n\n\toval = snd_pmac_burgundy_rcb(chip, addr);\n\tif (atten)\n\t\toval = ~oval & 0xff;\n\tval = ucontrol->value.integer.value[0];\n\tif (stereo)\n\t\tval |= ucontrol->value.integer.value[1] << 4;\n\telse\n\t\tval |= ucontrol->value.integer.value[0] << 4;\n\tif (atten)\n\t\tval = ~val & 0xff;\n\tsnd_pmac_burgundy_wcb(chip, addr, val);\n\treturn val != oval;\n}\n\n#define BURGUNDY_VOLUME_B(xname, xindex, addr, stereo, atten) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\\\n  .info = snd_pmac_burgundy_info_gain,\\\n  .get = snd_pmac_burgundy_get_gain,\\\n  .put = snd_pmac_burgundy_put_gain,\\\n  .private_value = (ADDR2BASE(addr) | ((stereo) << 24) | ((atten) << 25)) }\n\n \nstatic int snd_pmac_burgundy_info_switch_w(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_get_switch_w(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\n\tint lmask = 1 << (kcontrol->private_value & 0xff);\n\tint rmask = 1 << ((kcontrol->private_value >> 8) & 0xff);\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint val = snd_pmac_burgundy_rcw(chip, addr);\n\tucontrol->value.integer.value[0] = (val & lmask) ? 1 : 0;\n\tif (stereo)\n\t\tucontrol->value.integer.value[1] = (val & rmask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_put_switch_w(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\n\tint lmask = 1 << (kcontrol->private_value & 0xff);\n\tint rmask = 1 << ((kcontrol->private_value >> 8) & 0xff);\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint val, oval;\n\toval = snd_pmac_burgundy_rcw(chip, addr);\n\tval = oval & ~(lmask | (stereo ? rmask : 0));\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= lmask;\n\tif (stereo && ucontrol->value.integer.value[1])\n\t\tval |= rmask;\n\tsnd_pmac_burgundy_wcw(chip, addr, val);\n\treturn val != oval;\n}\n\n#define BURGUNDY_SWITCH_W(xname, xindex, addr, lbit, rbit, stereo) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\\\n  .info = snd_pmac_burgundy_info_switch_w,\\\n  .get = snd_pmac_burgundy_get_switch_w,\\\n  .put = snd_pmac_burgundy_put_switch_w,\\\n  .private_value = ((lbit) | ((rbit) << 8)\\\n\t\t| (ADDR2BASE(addr) << 16) | ((stereo) << 24)) }\n\n \nstatic int snd_pmac_burgundy_info_switch_b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_get_switch_b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\n\tint lmask = kcontrol->private_value & 0xff;\n\tint rmask = (kcontrol->private_value >> 8) & 0xff;\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint val = snd_pmac_burgundy_rcb(chip, addr);\n\tucontrol->value.integer.value[0] = (val & lmask) ? 1 : 0;\n\tif (stereo)\n\t\tucontrol->value.integer.value[1] = (val & rmask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_pmac_burgundy_put_switch_b(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\n\tint lmask = kcontrol->private_value & 0xff;\n\tint rmask = (kcontrol->private_value >> 8) & 0xff;\n\tint stereo = (kcontrol->private_value >> 24) & 1;\n\tint val, oval;\n\toval = snd_pmac_burgundy_rcb(chip, addr);\n\tval = oval & ~(lmask | rmask);\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= lmask;\n\tif (stereo && ucontrol->value.integer.value[1])\n\t\tval |= rmask;\n\tsnd_pmac_burgundy_wcb(chip, addr, val);\n\treturn val != oval;\n}\n\n#define BURGUNDY_SWITCH_B(xname, xindex, addr, lmask, rmask, stereo) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex,\\\n  .info = snd_pmac_burgundy_info_switch_b,\\\n  .get = snd_pmac_burgundy_get_switch_b,\\\n  .put = snd_pmac_burgundy_put_switch_b,\\\n  .private_value = ((lmask) | ((rmask) << 8)\\\n\t\t| (ADDR2BASE(addr) << 16) | ((stereo) << 24)) }\n\n \nstatic const struct snd_kcontrol_new snd_pmac_burgundy_mixers[] = {\n\tBURGUNDY_VOLUME_W(\"Master Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_MASTER_VOLUME, 8),\n\tBURGUNDY_VOLUME_W(\"CD Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLCD, 16),\n\tBURGUNDY_VOLUME_2B(\"Input Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLMIX01, 2),\n\tBURGUNDY_VOLUME_2B(\"Mixer Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLMIX23, 0),\n\tBURGUNDY_VOLUME_B(\"CD Gain Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_GAINCD, 1, 0),\n\tBURGUNDY_SWITCH_W(\"Master Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_OUTPUTENABLES, 24, 0, 0),\n\tBURGUNDY_SWITCH_W(\"CD Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_CAPTURESELECTS, 0, 16, 1),\n\tBURGUNDY_SWITCH_W(\"CD Playback Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_OUTPUTSELECTS, 0, 16, 1),\n \tBURGUNDY_SWITCH_B(\"PCM Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_HOSTIFEH, 0x01, 0, 0)\n};\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_mixers_imac[] = {\n\tBURGUNDY_VOLUME_W(\"Line in Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLLINE, 16),\n\tBURGUNDY_VOLUME_W(\"Mic Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLMIC, 16),\n\tBURGUNDY_VOLUME_B(\"Line in Gain Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_GAINLINE, 1, 0),\n\tBURGUNDY_VOLUME_B(\"Mic Gain Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_GAINMIC, 1, 0),\n\tBURGUNDY_VOLUME_B(\"Speaker Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_ATTENSPEAKER, 1, 1),\n\tBURGUNDY_VOLUME_B(\"Line out Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_ATTENLINEOUT, 1, 1),\n\tBURGUNDY_VOLUME_B(\"Headphone Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_ATTENHP, 1, 1),\n\tBURGUNDY_SWITCH_W(\"Line in Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_CAPTURESELECTS, 1, 17, 1),\n\tBURGUNDY_SWITCH_W(\"Mic Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_CAPTURESELECTS, 2, 18, 1),\n\tBURGUNDY_SWITCH_W(\"Line in Playback Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_OUTPUTSELECTS, 1, 17, 1),\n\tBURGUNDY_SWITCH_W(\"Mic Playback Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_OUTPUTSELECTS, 2, 18, 1),\n\tBURGUNDY_SWITCH_B(\"Mic Boost Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_INPBOOST, 0x40, 0x80, 1)\n};\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_mixers_pmac[] = {\n\tBURGUNDY_VOLUME_W(\"Line in Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_VOLMIC, 16),\n\tBURGUNDY_VOLUME_B(\"Line in Gain Capture Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_GAINMIC, 1, 0),\n\tBURGUNDY_VOLUME_B(\"Speaker Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_ATTENMONO, 0, 1),\n\tBURGUNDY_VOLUME_B(\"Line out Playback Volume\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_ATTENSPEAKER, 1, 1),\n\tBURGUNDY_SWITCH_W(\"Line in Capture Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_CAPTURESELECTS, 2, 18, 1),\n\tBURGUNDY_SWITCH_W(\"Line in Playback Switch\", 0,\n\t\t\tMASK_ADDR_BURGUNDY_OUTPUTSELECTS, 2, 18, 1),\n \n};\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_master_sw_imac =\nBURGUNDY_SWITCH_B(\"Master Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_OUTPUT_LEFT | BURGUNDY_LINEOUT_LEFT | BURGUNDY_HP_LEFT,\n\tBURGUNDY_OUTPUT_RIGHT | BURGUNDY_LINEOUT_RIGHT | BURGUNDY_HP_RIGHT, 1);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_master_sw_pmac =\nBURGUNDY_SWITCH_B(\"Master Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_OUTPUT_INTERN\n\t| BURGUNDY_OUTPUT_LEFT, BURGUNDY_OUTPUT_RIGHT, 1);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_speaker_sw_imac =\nBURGUNDY_SWITCH_B(\"Speaker Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_OUTPUT_LEFT, BURGUNDY_OUTPUT_RIGHT, 1);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_speaker_sw_pmac =\nBURGUNDY_SWITCH_B(\"Speaker Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_OUTPUT_INTERN, 0, 0);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_line_sw_imac =\nBURGUNDY_SWITCH_B(\"Line out Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_LINEOUT_LEFT, BURGUNDY_LINEOUT_RIGHT, 1);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_line_sw_pmac =\nBURGUNDY_SWITCH_B(\"Line out Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_OUTPUT_LEFT, BURGUNDY_OUTPUT_RIGHT, 1);\nstatic const struct snd_kcontrol_new snd_pmac_burgundy_hp_sw_imac =\nBURGUNDY_SWITCH_B(\"Headphone Playback Switch\", 0,\n\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\tBURGUNDY_HP_LEFT, BURGUNDY_HP_RIGHT, 1);\n\n\n#ifdef PMAC_SUPPORT_AUTOMUTE\n \nstatic int snd_pmac_burgundy_detect_headphone(struct snd_pmac *chip)\n{\n\treturn (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;\n}\n\nstatic void snd_pmac_burgundy_update_automute(struct snd_pmac *chip, int do_notify)\n{\n\tif (chip->auto_mute) {\n\t\tint imac = of_machine_is_compatible(\"iMac\");\n\t\tint reg, oreg;\n\t\treg = oreg = snd_pmac_burgundy_rcb(chip,\n\t\t\t\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES);\n\t\treg &= imac ? ~(BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT\n\t\t\t\t| BURGUNDY_HP_LEFT | BURGUNDY_HP_RIGHT)\n\t\t\t: ~(BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT\n\t\t\t\t| BURGUNDY_OUTPUT_INTERN);\n\t\tif (snd_pmac_burgundy_detect_headphone(chip))\n\t\t\treg |= imac ? (BURGUNDY_HP_LEFT | BURGUNDY_HP_RIGHT)\n\t\t\t\t: (BURGUNDY_OUTPUT_LEFT\n\t\t\t\t\t| BURGUNDY_OUTPUT_RIGHT);\n\t\telse\n\t\t\treg |= imac ? (BURGUNDY_OUTPUT_LEFT\n\t\t\t\t\t| BURGUNDY_OUTPUT_RIGHT)\n\t\t\t\t: (BURGUNDY_OUTPUT_INTERN);\n\t\tif (do_notify && reg == oreg)\n\t\t\treturn;\n\t\tsnd_pmac_burgundy_wcb(chip,\n\t\t\t\tMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES, reg);\n\t\tif (do_notify) {\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->master_sw_ctl->id);\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->speaker_sw_ctl->id);\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->hp_detect_ctl->id);\n\t\t}\n\t}\n}\n#endif  \n\n\n \nint snd_pmac_burgundy_init(struct snd_pmac *chip)\n{\n\tint imac = of_machine_is_compatible(\"iMac\");\n\tint i, err;\n\n\t \n\tif ((in_le32(&chip->awacs->codec_ctrl) & MASK_ERRCODE) == 0xf0000) {\n\t\tprintk(KERN_WARNING \"pmac burgundy: disabled by MacOS :-(\\n\");\n\t\treturn 1;\n\t}\n\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_OUTPUTENABLES,\n\t\t\t   DEF_BURGUNDY_OUTPUTENABLES);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\n\t\t\t   DEF_BURGUNDY_MORE_OUTPUTENABLES);\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_OUTPUTSELECTS,\n\t\t\t   DEF_BURGUNDY_OUTPUTSELECTS);\n\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_INPSEL21,\n\t\t\t   DEF_BURGUNDY_INPSEL21);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_INPSEL3,\n\t\t\t   imac ? DEF_BURGUNDY_INPSEL3_IMAC\n\t\t\t   : DEF_BURGUNDY_INPSEL3_PMAC);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINCD,\n\t\t\t   DEF_BURGUNDY_GAINCD);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINLINE,\n\t\t\t   DEF_BURGUNDY_GAINLINE);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINMIC,\n\t\t\t   DEF_BURGUNDY_GAINMIC);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINMODEM,\n\t\t\t   DEF_BURGUNDY_GAINMODEM);\n\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENSPEAKER,\n\t\t\t   DEF_BURGUNDY_ATTENSPEAKER);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENLINEOUT,\n\t\t\t   DEF_BURGUNDY_ATTENLINEOUT);\n\tsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENHP,\n\t\t\t   DEF_BURGUNDY_ATTENHP);\n\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_MASTER_VOLUME,\n\t\t\t   DEF_BURGUNDY_MASTER_VOLUME);\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLCD,\n\t\t\t   DEF_BURGUNDY_VOLCD);\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLLINE,\n\t\t\t   DEF_BURGUNDY_VOLLINE);\n\tsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLMIC,\n\t\t\t   DEF_BURGUNDY_VOLMIC);\n\n\tif (chip->hp_stat_mask == 0) {\n\t\t \n\t\tif (imac)\n\t\t\tchip->hp_stat_mask = BURGUNDY_HPDETECT_IMAC_UPPER\n\t\t\t\t| BURGUNDY_HPDETECT_IMAC_LOWER\n\t\t\t\t| BURGUNDY_HPDETECT_IMAC_SIDE;\n\t\telse\n\t\t\tchip->hp_stat_mask = BURGUNDY_HPDETECT_PMAC_BACK;\n\t}\n\t \n\tstrcpy(chip->card->mixername, \"PowerMac Burgundy\");\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_pmac_burgundy_mixers); i++) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t    snd_ctl_new1(&snd_pmac_burgundy_mixers[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < (imac ? ARRAY_SIZE(snd_pmac_burgundy_mixers_imac)\n\t\t\t: ARRAY_SIZE(snd_pmac_burgundy_mixers_pmac)); i++) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t    snd_ctl_new1(imac ? &snd_pmac_burgundy_mixers_imac[i]\n\t\t    : &snd_pmac_burgundy_mixers_pmac[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tchip->master_sw_ctl = snd_ctl_new1(imac\n\t\t\t? &snd_pmac_burgundy_master_sw_imac\n\t\t\t: &snd_pmac_burgundy_master_sw_pmac, chip);\n\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n\tchip->master_sw_ctl = snd_ctl_new1(imac\n\t\t\t? &snd_pmac_burgundy_line_sw_imac\n\t\t\t: &snd_pmac_burgundy_line_sw_pmac, chip);\n\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n\tif (imac) {\n\t\tchip->master_sw_ctl = snd_ctl_new1(\n\t\t\t\t&snd_pmac_burgundy_hp_sw_imac, chip);\n\t\terr = snd_ctl_add(chip->card, chip->master_sw_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tchip->speaker_sw_ctl = snd_ctl_new1(imac\n\t\t\t? &snd_pmac_burgundy_speaker_sw_imac\n\t\t\t: &snd_pmac_burgundy_speaker_sw_pmac, chip);\n\terr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\n\tif (err < 0)\n\t\treturn err;\n#ifdef PMAC_SUPPORT_AUTOMUTE\n\terr = snd_pmac_add_automute(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->detect_headphone = snd_pmac_burgundy_detect_headphone;\n\tchip->update_automute = snd_pmac_burgundy_update_automute;\n\tsnd_pmac_burgundy_update_automute(chip, 0);  \n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}