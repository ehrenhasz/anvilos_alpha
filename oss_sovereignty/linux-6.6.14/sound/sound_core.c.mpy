{
  "module_name": "sound_core.c",
  "hash_id": "577e9ea264f28f85184bbaed5ecfd708422b62f6d4a997ea70ea12353f3cd846",
  "original_prompt": "Ingested from linux-6.6.14/sound/sound_core.c",
  "human_readable_source": "\n \n\n \n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kdev_t.h>\n#include <linux/major.h>\n#include <sound/core.h>\n\n#ifdef CONFIG_SOUND_OSS_CORE\nstatic int __init init_oss_soundcore(void);\nstatic void cleanup_oss_soundcore(void);\n#else\nstatic inline int init_oss_soundcore(void)\t{ return 0; }\nstatic inline void cleanup_oss_soundcore(void)\t{ }\n#endif\n\nMODULE_DESCRIPTION(\"Core sound module\");\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_LICENSE(\"GPL\");\n\nstatic char *sound_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (MAJOR(dev->devt) == SOUND_MAJOR)\n\t\treturn NULL;\n\treturn kasprintf(GFP_KERNEL, \"snd/%s\", dev_name(dev));\n}\n\nconst struct class sound_class = {\n\t.name = \"sound\",\n\t.devnode = sound_devnode,\n};\nEXPORT_SYMBOL(sound_class);\n\nstatic int __init init_soundcore(void)\n{\n\tint rc;\n\n\trc = init_oss_soundcore();\n\tif (rc)\n\t\treturn rc;\n\n\trc = class_register(&sound_class);\n\tif (rc) {\n\t\tcleanup_oss_soundcore();\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_soundcore(void)\n{\n\tcleanup_oss_soundcore();\n\tclass_unregister(&sound_class);\n}\n\nsubsys_initcall(init_soundcore);\nmodule_exit(cleanup_soundcore);\n\n\n#ifdef CONFIG_SOUND_OSS_CORE\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sound.h>\n#include <linux/kmod.h>\n\n#define SOUND_STEP 16\n\nstruct sound_unit\n{\n\tint unit_minor;\n\tconst struct file_operations *unit_fops;\n\tstruct sound_unit *next;\n\tchar name[32];\n};\n\n \nstatic int preclaim_oss = IS_ENABLED(CONFIG_SOUND_OSS_CORE_PRECLAIM);\n\nmodule_param(preclaim_oss, int, 0444);\n\nstatic int soundcore_open(struct inode *, struct file *);\n\nstatic const struct file_operations soundcore_fops =\n{\n\t \n\t.owner\t= THIS_MODULE,\n\t.open\t= soundcore_open,\n\t.llseek = noop_llseek,\n};\n\n \n\nstatic int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, const struct file_operations *fops, int index, int low, int top)\n{\n\tint n=low;\n\n\tif (index < 0) {\t \n\n\t\twhile (*list && (*list)->unit_minor<n)\n\t\t\tlist=&((*list)->next);\n\n\t\twhile(n<top)\n\t\t{\n\t\t\t \n\t\t\tif(*list==NULL || (*list)->unit_minor>n)\n\t\t\t\tbreak;\n\t\t\tlist=&((*list)->next);\n\t\t\tn+=SOUND_STEP;\n\t\t}\n\n\t\tif(n>=top)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\tn = low+(index*16);\n\t\twhile (*list) {\n\t\t\tif ((*list)->unit_minor==n)\n\t\t\t\treturn -EBUSY;\n\t\t\tif ((*list)->unit_minor>n)\n\t\t\t\tbreak;\n\t\t\tlist=&((*list)->next);\n\t\t}\n\t}\t\n\t\t\n\t \n\t \n\ts->unit_minor=n;\n\ts->unit_fops=fops;\n\t\n\t \n\t \n\ts->next=*list;\n\t*list=s;\n\t\n\t\n\treturn n;\n}\n\n \n \nstatic struct sound_unit *__sound_remove_unit(struct sound_unit **list, int unit)\n{\n\twhile(*list)\n\t{\n\t\tstruct sound_unit *p=*list;\n\t\tif(p->unit_minor==unit)\n\t\t{\n\t\t\t*list=p->next;\n\t\t\treturn p;\n\t\t}\n\t\tlist=&(p->next);\n\t}\n\tprintk(KERN_ERR \"Sound device %d went missing!\\n\", unit);\n\treturn NULL;\n}\n\n \n\nstatic DEFINE_SPINLOCK(sound_loader_lock);\n\n \n\nstatic int sound_insert_unit(struct sound_unit **list, const struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode, struct device *dev)\n{\n\tstruct sound_unit *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\tint r;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&sound_loader_lock);\nretry:\n\tr = __sound_insert_unit(s, list, fops, index, low, top);\n\tspin_unlock(&sound_loader_lock);\n\t\n\tif (r < 0)\n\t\tgoto fail;\n\telse if (r < SOUND_STEP)\n\t\tsprintf(s->name, \"sound/%s\", name);\n\telse\n\t\tsprintf(s->name, \"sound/%s%d\", name, r / SOUND_STEP);\n\n\tif (!preclaim_oss) {\n\t\t \n\t\tr = __register_chrdev(SOUND_MAJOR, s->unit_minor, 1, s->name,\n\t\t\t\t      &soundcore_fops);\n\t\tif (r < 0) {\n\t\t\tspin_lock(&sound_loader_lock);\n\t\t\t__sound_remove_unit(list, s->unit_minor);\n\t\t\tif (index < 0) {\n\t\t\t\tlow = s->unit_minor + SOUND_STEP;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tspin_unlock(&sound_loader_lock);\n\t\t\tr = -EBUSY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdevice_create(&sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),\n\t\t      NULL, \"%s\", s->name+6);\n\treturn s->unit_minor;\n\nfail:\n\tkfree(s);\n\treturn r;\n}\n\n \n \t\nstatic void sound_remove_unit(struct sound_unit **list, int unit)\n{\n\tstruct sound_unit *p;\n\n\tspin_lock(&sound_loader_lock);\n\tp = __sound_remove_unit(list, unit);\n\tspin_unlock(&sound_loader_lock);\n\tif (p) {\n\t\tif (!preclaim_oss)\n\t\t\t__unregister_chrdev(SOUND_MAJOR, p->unit_minor, 1,\n\t\t\t\t\t    p->name);\n\t\tdevice_destroy(&sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));\n\t\tkfree(p);\n\t}\n}\n\n \n\nstatic struct sound_unit *chains[SOUND_STEP];\n\n \n \nint register_sound_special_device(const struct file_operations *fops, int unit,\n\t\t\t\t  struct device *dev)\n{\n\tconst int chain = unit % SOUND_STEP;\n\tint max_unit = 256;\n\tconst char *name;\n\tchar _name[16];\n\n\tswitch (chain) {\n\t    case 0:\n\t\tname = \"mixer\";\n\t\tbreak;\n\t    case 1:\n\t\tname = \"sequencer\";\n\t\tif (unit >= SOUND_STEP)\n\t\t\tgoto __unknown;\n\t\tmax_unit = unit + 1;\n\t\tbreak;\n\t    case 2:\n\t\tname = \"midi\";\n\t\tbreak;\n\t    case 3:\n\t\tname = \"dsp\";\n\t\tbreak;\n\t    case 4:\n\t\tname = \"audio\";\n\t\tbreak;\n\t    case 5:\n\t\tname = \"dspW\";\n\t\tbreak;\n\t    case 8:\n\t\tname = \"sequencer2\";\n\t\tif (unit >= SOUND_STEP)\n\t\t\tgoto __unknown;\n\t\tmax_unit = unit + 1;\n\t\tbreak;\n\t    case 9:\n\t\tname = \"dmmidi\";\n\t\tbreak;\n\t    case 10:\n\t\tname = \"dmfm\";\n\t\tbreak;\n\t    case 12:\n\t\tname = \"adsp\";\n\t\tbreak;\n\t    case 13:\n\t\tname = \"amidi\";\n\t\tbreak;\n\t    case 14:\n\t\tname = \"admmidi\";\n\t\tbreak;\n\t    default:\n\t    \t{\n\t\t    __unknown:\n\t\t\tsprintf(_name, \"unknown%d\", chain);\n\t\t    \tif (unit >= SOUND_STEP)\n\t\t    \t\tstrcat(_name, \"-\");\n\t\t    \tname = _name;\n\t\t}\n\t\tbreak;\n\t}\n\treturn sound_insert_unit(&chains[chain], fops, -1, unit, max_unit,\n\t\t\t\t name, 0600, dev);\n}\n \nEXPORT_SYMBOL(register_sound_special_device);\n\nint register_sound_special(const struct file_operations *fops, int unit)\n{\n\treturn register_sound_special_device(fops, unit, NULL);\n}\n\nEXPORT_SYMBOL(register_sound_special);\n\n \n\nint register_sound_mixer(const struct file_operations *fops, int dev)\n{\n\treturn sound_insert_unit(&chains[0], fops, dev, 0, 128,\n\t\t\t\t \"mixer\", 0600, NULL);\n}\n\nEXPORT_SYMBOL(register_sound_mixer);\n\n \n \n \n\nint register_sound_dsp(const struct file_operations *fops, int dev)\n{\n\treturn sound_insert_unit(&chains[3], fops, dev, 3, 131,\n\t\t\t\t \"dsp\", 0600, NULL);\n}\n\nEXPORT_SYMBOL(register_sound_dsp);\n\n \n\n\nvoid unregister_sound_special(int unit)\n{\n\tsound_remove_unit(&chains[unit % SOUND_STEP], unit);\n}\n \nEXPORT_SYMBOL(unregister_sound_special);\n\n \n\nvoid unregister_sound_mixer(int unit)\n{\n\tsound_remove_unit(&chains[0], unit);\n}\n\nEXPORT_SYMBOL(unregister_sound_mixer);\n\n \n\nvoid unregister_sound_dsp(int unit)\n{\n\tsound_remove_unit(&chains[3], unit);\n}\n\n\nEXPORT_SYMBOL(unregister_sound_dsp);\n\nstatic struct sound_unit *__look_for_unit(int chain, int unit)\n{\n\tstruct sound_unit *s;\n\t\n\ts=chains[chain];\n\twhile(s && s->unit_minor <= unit)\n\t{\n\t\tif(s->unit_minor==unit)\n\t\t\treturn s;\n\t\ts=s->next;\n\t}\n\treturn NULL;\n}\n\nstatic int soundcore_open(struct inode *inode, struct file *file)\n{\n\tint chain;\n\tint unit = iminor(inode);\n\tstruct sound_unit *s;\n\tconst struct file_operations *new_fops = NULL;\n\n\tchain=unit&0x0F;\n\tif(chain==4 || chain==5)\t \n\t{\n\t\tunit&=0xF0;\n\t\tunit|=3;\n\t\tchain=3;\n\t}\n\t\n\tspin_lock(&sound_loader_lock);\n\ts = __look_for_unit(chain, unit);\n\tif (s)\n\t\tnew_fops = fops_get(s->unit_fops);\n\tif (preclaim_oss && !new_fops) {\n\t\tspin_unlock(&sound_loader_lock);\n\n\t\t \n\t\trequest_module(\"sound-slot-%i\", unit>>4);\n\t\trequest_module(\"sound-service-%i-%i\", unit>>4, chain);\n\n\t\t \n\t\tif (request_module(\"char-major-%d-%d\", SOUND_MAJOR, unit) > 0)\n\t\t\trequest_module(\"char-major-%d\", SOUND_MAJOR);\n\n\t\tspin_lock(&sound_loader_lock);\n\t\ts = __look_for_unit(chain, unit);\n\t\tif (s)\n\t\t\tnew_fops = fops_get(s->unit_fops);\n\t}\n\tspin_unlock(&sound_loader_lock);\n\n\tif (!new_fops)\n\t\treturn -ENODEV;\n\n\t \n\treplace_fops(file, new_fops);\n\n\tif (!file->f_op->open)\n\t\treturn -ENODEV;\n\n\treturn file->f_op->open(inode, file);\n}\n\nMODULE_ALIAS_CHARDEV_MAJOR(SOUND_MAJOR);\n\nstatic void cleanup_oss_soundcore(void)\n{\n\t \n\tunregister_chrdev(SOUND_MAJOR, \"sound\");\n}\n\nstatic int __init init_oss_soundcore(void)\n{\n\tif (preclaim_oss &&\n\t    register_chrdev(SOUND_MAJOR, \"sound\", &soundcore_fops) < 0) {\n\t\tprintk(KERN_ERR \"soundcore: sound device already in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}