{
  "module_name": "emux_seq.c",
  "hash_id": "0e2bdf10160483c80e109df8233fd1e8266d8fb97cfdef72a6dede774259a48a",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_seq.c",
  "human_readable_source": "\n \n\n#include \"emux_voice.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\n \nstatic void free_port(void *private);\nstatic void snd_emux_init_port(struct snd_emux_port *p);\nstatic int snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info);\nstatic int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info);\n\n \nstatic const struct snd_midi_op emux_ops = {\n\t.note_on = snd_emux_note_on,\n\t.note_off = snd_emux_note_off,\n\t.key_press = snd_emux_key_press,\n\t.note_terminate = snd_emux_terminate_note,\n\t.control = snd_emux_control,\n\t.nrpn = snd_emux_nrpn,\n\t.sysex = snd_emux_sysex,\n};\n\n\n \n#define MIDI_CHANNELS\t\t16\n\n \n#define DEFAULT_MIDI_TYPE\t(SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\\\n\t\t\t\t SNDRV_SEQ_PORT_TYPE_MIDI_GM |\\\n\t\t\t\t SNDRV_SEQ_PORT_TYPE_MIDI_GS |\\\n\t\t\t\t SNDRV_SEQ_PORT_TYPE_MIDI_XG |\\\n\t\t\t\t SNDRV_SEQ_PORT_TYPE_HARDWARE |\\\n\t\t\t\t SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n\n \nint\nsnd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)\n{\n\tint  i;\n\tstruct snd_seq_port_callback pinfo;\n\tchar tmpname[64];\n\n\temu->client = snd_seq_create_kernel_client(card, index,\n\t\t\t\t\t\t   \"%s WaveTable\", emu->name);\n\tif (emu->client < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create client\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (emu->num_ports < 0) {\n\t\tsnd_printk(KERN_WARNING \"seqports must be greater than zero\\n\");\n\t\temu->num_ports = 1;\n\t} else if (emu->num_ports >= SNDRV_EMUX_MAX_PORTS) {\n\t\tsnd_printk(KERN_WARNING \"too many ports.\"\n\t\t\t   \"limited max. ports %d\\n\", SNDRV_EMUX_MAX_PORTS);\n\t\temu->num_ports = SNDRV_EMUX_MAX_PORTS;\n\t}\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\tpinfo.owner = THIS_MODULE;\n\tpinfo.use = snd_emux_use;\n\tpinfo.unuse = snd_emux_unuse;\n\tpinfo.event_input = snd_emux_event_input;\n\n\tfor (i = 0; i < emu->num_ports; i++) {\n\t\tstruct snd_emux_port *p;\n\n\t\tsprintf(tmpname, \"%s Port %d\", emu->name, i);\n\t\tp = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,\n\t\t\t\t\t 0, &pinfo);\n\t\tif (!p) {\n\t\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tp->port_mode =  SNDRV_EMUX_PORT_MODE_MIDI;\n\t\tsnd_emux_init_port(p);\n\t\temu->ports[i] = p->chset.port;\n\t\temu->portptrs[i] = p;\n\t}\n\n\treturn 0;\n}\n\n\n \nvoid\nsnd_emux_detach_seq(struct snd_emux *emu)\n{\n\tif (emu->voices)\n\t\tsnd_emux_terminate_all(emu);\n\t\t\n\tif (emu->client >= 0) {\n\t\tsnd_seq_delete_kernel_client(emu->client);\n\t\temu->client = -1;\n\t}\n}\n\n\n \n\nstruct snd_emux_port *\nsnd_emux_create_port(struct snd_emux *emu, char *name,\n\t\t     int max_channels, int oss_port,\n\t\t     struct snd_seq_port_callback *callback)\n{\n\tstruct snd_emux_port *p;\n\tint i, type, cap;\n\n\t \n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tp->chset.channels = kcalloc(max_channels, sizeof(*p->chset.channels),\n\t\t\t\t    GFP_KERNEL);\n\tif (!p->chset.channels) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < max_channels; i++)\n\t\tp->chset.channels[i].number = i;\n\tp->chset.private_data = p;\n\tp->chset.max_channels = max_channels;\n\tp->emu = emu;\n\tp->chset.client = emu->client;\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\tsnd_emux_create_effect(p);\n#endif\n\tcallback->private_free = free_port;\n\tcallback->private_data = p;\n\n\tcap = SNDRV_SEQ_PORT_CAP_WRITE;\n\tif (oss_port) {\n\t\ttype = SNDRV_SEQ_PORT_TYPE_SPECIFIC;\n\t} else {\n\t\ttype = DEFAULT_MIDI_TYPE;\n\t\tcap |= SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\n\t}\n\n\tp->chset.port = snd_seq_event_port_attach(emu->client, callback,\n\t\t\t\t\t\t  cap, type, max_channels,\n\t\t\t\t\t\t  emu->max_voices, name);\n\n\treturn p;\n}\n\n\n \nstatic void\nfree_port(void *private_data)\n{\n\tstruct snd_emux_port *p;\n\n\tp = private_data;\n\tif (p) {\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\t\tsnd_emux_delete_effect(p);\n#endif\n\t\tkfree(p->chset.channels);\n\t\tkfree(p);\n\t}\n}\n\n\n#define DEFAULT_DRUM_FLAGS\t(1<<9)\n\n \nstatic void\nsnd_emux_init_port(struct snd_emux_port *p)\n{\n\tp->drum_flags = DEFAULT_DRUM_FLAGS;\n\tp->volume_atten = 0;\n\n\tsnd_emux_reset_port(p);\n}\n\n\n \nvoid\nsnd_emux_reset_port(struct snd_emux_port *port)\n{\n\tint i;\n\n\t \n\tsnd_emux_sounds_off_all(port);\n\n\tsnd_midi_channel_set_clear(&port->chset);\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\tsnd_emux_clear_effect(port);\n#endif\n\n\t \n\tport->ctrls[EMUX_MD_DEF_BANK] = 0;\n\tport->ctrls[EMUX_MD_DEF_DRUM] = 0;\n\tport->ctrls[EMUX_MD_REALTIME_PAN] = 1;\n\n\tfor (i = 0; i < port->chset.max_channels; i++) {\n\t\tstruct snd_midi_channel *chan = port->chset.channels + i;\n\t\tchan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;\n\t}\n}\n\n\n \nint\nsnd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,\n\t\t     int atomic, int hop)\n{\n\tstruct snd_emux_port *port;\n\n\tport = private_data;\n\tif (snd_BUG_ON(!port || !ev))\n\t\treturn -EINVAL;\n\n\tsnd_midi_process_event(&emux_ops, ev, &port->chset);\n\n\treturn 0;\n}\n\n\n \nstatic int\n__snd_emux_inc_count(struct snd_emux *emu)\n{\n\temu->used++;\n\tif (!try_module_get(emu->ops.owner))\n\t\tgoto __error;\n\tif (!try_module_get(emu->card->module)) {\n\t\tmodule_put(emu->ops.owner);\n\t      __error:\n\t\temu->used--;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint snd_emux_inc_count(struct snd_emux *emu)\n{\n\tint ret;\n\n\tmutex_lock(&emu->register_mutex);\n\tret = __snd_emux_inc_count(emu);\n\tmutex_unlock(&emu->register_mutex);\n\treturn ret;\n}\n\n \nstatic void\n__snd_emux_dec_count(struct snd_emux *emu)\n{\n\tmodule_put(emu->card->module);\n\temu->used--;\n\tif (emu->used <= 0)\n\t\tsnd_emux_terminate_all(emu);\n\tmodule_put(emu->ops.owner);\n}\n\nvoid snd_emux_dec_count(struct snd_emux *emu)\n{\n\tmutex_lock(&emu->register_mutex);\n\t__snd_emux_dec_count(emu);\n\tmutex_unlock(&emu->register_mutex);\n}\n\n \nstatic int\nsnd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_emux_port *p;\n\tstruct snd_emux *emu;\n\n\tp = private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -EINVAL;\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&emu->register_mutex);\n\tsnd_emux_init_port(p);\n\t__snd_emux_inc_count(emu);\n\tmutex_unlock(&emu->register_mutex);\n\treturn 0;\n}\n\n \nstatic int\nsnd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_emux_port *p;\n\tstruct snd_emux *emu;\n\n\tp = private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -EINVAL;\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&emu->register_mutex);\n\tsnd_emux_sounds_off_all(p);\n\t__snd_emux_dec_count(emu);\n\tmutex_unlock(&emu->register_mutex);\n\treturn 0;\n}\n\n\n \nint snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)\n{\n\tint i;\n\n\temu->vmidi = NULL;\n\tif (emu->midi_ports <= 0)\n\t\treturn 0;\n\n\temu->vmidi = kcalloc(emu->midi_ports, sizeof(*emu->vmidi), GFP_KERNEL);\n\tif (!emu->vmidi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < emu->midi_ports; i++) {\n\t\tstruct snd_rawmidi *rmidi;\n\t\tstruct snd_virmidi_dev *rdev;\n\t\tif (snd_virmidi_new(card, emu->midi_devidx + i, &rmidi) < 0)\n\t\t\tgoto __error;\n\t\trdev = rmidi->private_data;\n\t\tsprintf(rmidi->name, \"%s Synth MIDI\", emu->name);\n\t\trdev->seq_mode = SNDRV_VIRMIDI_SEQ_ATTACH;\n\t\trdev->client = emu->client;\n\t\trdev->port = emu->ports[i];\n\t\tif (snd_device_register(card, rmidi) < 0) {\n\t\t\tsnd_device_free(card, rmidi);\n\t\t\tgoto __error;\n\t\t}\n\t\temu->vmidi[i] = rmidi;\n\t\t \n\t}\n\treturn 0;\n\n__error:\n\t \n\tsnd_emux_delete_virmidi(emu);\n\treturn -ENOMEM;\n}\n\nint snd_emux_delete_virmidi(struct snd_emux *emu)\n{\n\tint i;\n\n\tif (!emu->vmidi)\n\t\treturn 0;\n\n\tfor (i = 0; i < emu->midi_ports; i++) {\n\t\tif (emu->vmidi[i])\n\t\t\tsnd_device_free(emu->card, emu->vmidi[i]);\n\t}\n\tkfree(emu->vmidi);\n\temu->vmidi = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}