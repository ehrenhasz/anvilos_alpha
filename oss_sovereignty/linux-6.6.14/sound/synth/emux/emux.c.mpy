{
  "module_name": "emux.c",
  "hash_id": "74a1ade6fb5bce322f1f2b3760ad658f77e51e167691e8413de78ef94d62bdad",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/emux_synth.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include \"emux_voice.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai\");\nMODULE_DESCRIPTION(\"Routines for control of EMU WaveTable chip\");\nMODULE_LICENSE(\"GPL\");\n\n \nint snd_emux_new(struct snd_emux **remu)\n{\n\tstruct snd_emux *emu;\n\n\t*remu = NULL;\n\temu = kzalloc(sizeof(*emu), GFP_KERNEL);\n\tif (emu == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&emu->voice_lock);\n\tmutex_init(&emu->register_mutex);\n\n\temu->client = -1;\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\temu->oss_synth = NULL;\n#endif\n\temu->max_voices = 0;\n\temu->use_time = 0;\n\n\ttimer_setup(&emu->tlist, snd_emux_timer_callback, 0);\n\temu->timer_active = 0;\n\n\t*remu = emu;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_emux_new);\n\n \nstatic int sf_sample_new(void *private_data, struct snd_sf_sample *sp,\n\t\t\t\t  struct snd_util_memhdr *hdr,\n\t\t\t\t  const void __user *buf, long count)\n{\n\tstruct snd_emux *emu = private_data;\n\treturn emu->ops.sample_new(emu, sp, hdr, buf, count);\n\t\n}\n\nstatic int sf_sample_free(void *private_data, struct snd_sf_sample *sp,\n\t\t\t\t   struct snd_util_memhdr *hdr)\n{\n\tstruct snd_emux *emu = private_data;\n\treturn emu->ops.sample_free(emu, sp, hdr);\n\t\n}\n\nstatic void sf_sample_reset(void *private_data)\n{\n\tstruct snd_emux *emu = private_data;\n\temu->ops.sample_reset(emu);\n}\n\nint snd_emux_register(struct snd_emux *emu, struct snd_card *card, int index, char *name)\n{\n\tint err;\n\tstruct snd_sf_callback sf_cb;\n\n\tif (snd_BUG_ON(!emu->hw || emu->max_voices <= 0))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !name))\n\t\treturn -EINVAL;\n\n\temu->card = card;\n\temu->name = kstrdup(name, GFP_KERNEL);\n\temu->voices = kcalloc(emu->max_voices, sizeof(struct snd_emux_voice),\n\t\t\t      GFP_KERNEL);\n\tif (emu->name == NULL || emu->voices == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(&sf_cb, 0, sizeof(sf_cb));\n\tsf_cb.private_data = emu;\n\tif (emu->ops.sample_new)\n\t\tsf_cb.sample_new = sf_sample_new;\n\tif (emu->ops.sample_free)\n\t\tsf_cb.sample_free = sf_sample_free;\n\tif (emu->ops.sample_reset)\n\t\tsf_cb.sample_reset = sf_sample_reset;\n\temu->sflist = snd_sf_new(&sf_cb, emu->memhdr);\n\tif (emu->sflist == NULL)\n\t\treturn -ENOMEM;\n\n\terr = snd_emux_init_hwdep(emu);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_emux_init_voices(emu);\n\n\tsnd_emux_init_seq(emu, card, index);\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\tsnd_emux_init_seq_oss(emu);\n#endif\n\tsnd_emux_init_virmidi(emu, card);\n\n\tsnd_emux_proc_init(emu, card, index);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_emux_register);\n\n \nint snd_emux_free(struct snd_emux *emu)\n{\n\tif (! emu)\n\t\treturn -EINVAL;\n\n\ttimer_shutdown_sync(&emu->tlist);\n\n\tsnd_emux_proc_free(emu);\n\tsnd_emux_delete_virmidi(emu);\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\tsnd_emux_detach_seq_oss(emu);\n#endif\n\tsnd_emux_detach_seq(emu);\n\tsnd_emux_delete_hwdep(emu);\n\tsnd_sf_free(emu->sflist);\n\tkfree(emu->voices);\n\tkfree(emu->name);\n\tkfree(emu);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_emux_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}