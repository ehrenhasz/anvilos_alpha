{
  "module_name": "soundfont.c",
  "hash_id": "d8d47579c82238b180def4cd6b0b2144b2f89deefb9ad45c2770fd0036432fb4",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/soundfont.c",
  "human_readable_source": "\n \n \n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/soundfont.h>\n#include <sound/seq_oss_legacy.h>\n\n \n\nstatic int open_patch(struct snd_sf_list *sflist, const char __user *data,\n\t\t      int count, int client);\nstatic struct snd_soundfont *newsf(struct snd_sf_list *sflist, int type, char *name);\nstatic int is_identical_font(struct snd_soundfont *sf, int type, unsigned char *name);\nstatic int close_patch(struct snd_sf_list *sflist);\nstatic int probe_data(struct snd_sf_list *sflist, int sample_id);\nstatic void set_zone_counter(struct snd_sf_list *sflist,\n\t\t\t     struct snd_soundfont *sf, struct snd_sf_zone *zp);\nstatic struct snd_sf_zone *sf_zone_new(struct snd_sf_list *sflist,\n\t\t\t\t       struct snd_soundfont *sf);\nstatic void set_sample_counter(struct snd_sf_list *sflist,\n\t\t\t       struct snd_soundfont *sf, struct snd_sf_sample *sp);\nstatic struct snd_sf_sample *sf_sample_new(struct snd_sf_list *sflist,\n\t\t\t\t\t   struct snd_soundfont *sf);\nstatic void sf_sample_delete(struct snd_sf_list *sflist,\n\t\t\t     struct snd_soundfont *sf, struct snd_sf_sample *sp);\nstatic int load_map(struct snd_sf_list *sflist, const void __user *data, int count);\nstatic int load_info(struct snd_sf_list *sflist, const void __user *data, long count);\nstatic int remove_info(struct snd_sf_list *sflist, struct snd_soundfont *sf,\n\t\t       int bank, int instr);\nstatic void init_voice_info(struct soundfont_voice_info *avp);\nstatic void init_voice_parm(struct soundfont_voice_parm *pp);\nstatic struct snd_sf_sample *set_sample(struct snd_soundfont *sf,\n\t\t\t\t\tstruct soundfont_voice_info *avp);\nstatic struct snd_sf_sample *find_sample(struct snd_soundfont *sf, int sample_id);\nstatic int load_data(struct snd_sf_list *sflist, const void __user *data, long count);\nstatic void rebuild_presets(struct snd_sf_list *sflist);\nstatic void add_preset(struct snd_sf_list *sflist, struct snd_sf_zone *cur);\nstatic void delete_preset(struct snd_sf_list *sflist, struct snd_sf_zone *zp);\nstatic struct snd_sf_zone *search_first_zone(struct snd_sf_list *sflist,\n\t\t\t\t\t     int bank, int preset, int key);\nstatic int search_zones(struct snd_sf_list *sflist, int *notep, int vel,\n\t\t\tint preset, int bank, struct snd_sf_zone **table,\n\t\t\tint max_layers, int level);\nstatic int get_index(int bank, int instr, int key);\nstatic void snd_sf_init(struct snd_sf_list *sflist);\nstatic void snd_sf_clear(struct snd_sf_list *sflist);\n\n \nstatic void\nlock_preset(struct snd_sf_list *sflist)\n{\n\tunsigned long flags;\n\tmutex_lock(&sflist->presets_mutex);\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tsflist->presets_locked = 1;\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n}\n\n\n \nstatic void\nunlock_preset(struct snd_sf_list *sflist)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tsflist->presets_locked = 0;\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\tmutex_unlock(&sflist->presets_mutex);\n}\n\n\n \nint\nsnd_soundfont_close_check(struct snd_sf_list *sflist, int client)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tif (sflist->open_client == client)  {\n\t\tspin_unlock_irqrestore(&sflist->lock, flags);\n\t\treturn close_patch(sflist);\n\t}\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\treturn 0;\n}\n\n\n \nint\nsnd_soundfont_load(struct snd_sf_list *sflist, const void __user *data,\n\t\t   long count, int client)\n{\n\tstruct soundfont_patch_info patch;\n\tunsigned long flags;\n\tint  rc;\n\n\tif (count < (long)sizeof(patch)) {\n\t\tsnd_printk(KERN_ERR \"patch record too small %ld\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\tif (copy_from_user(&patch, data, sizeof(patch)))\n\t\treturn -EFAULT;\n\n\tcount -= sizeof(patch);\n\tdata += sizeof(patch);\n\n\tif (patch.key != SNDRV_OSS_SOUNDFONT_PATCH) {\n\t\tsnd_printk(KERN_ERR \"The wrong kind of patch %x\\n\", patch.key);\n\t\treturn -EINVAL;\n\t}\n\tif (count < patch.len) {\n\t\tsnd_printk(KERN_ERR \"Patch too short %ld, need %d\\n\",\n\t\t\t   count, patch.len);\n\t\treturn -EINVAL;\n\t}\n\tif (patch.len < 0) {\n\t\tsnd_printk(KERN_ERR \"poor length %d\\n\", patch.len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch.type == SNDRV_SFNT_OPEN_PATCH) {\n\t\t \n\t\tlock_preset(sflist);\n\t\trc = open_patch(sflist, data, count, client);\n\t\tunlock_preset(sflist);\n\t\treturn rc;\n\t}\n\n\t \n\tspin_lock_irqsave(&sflist->lock, flags);\n\tif (sflist->open_client != client) {\n\t\tspin_unlock_irqrestore(&sflist->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\n\tlock_preset(sflist);\n\trc = -EINVAL;\n\tswitch (patch.type) {\n\tcase SNDRV_SFNT_LOAD_INFO:\n\t\trc = load_info(sflist, data, count);\n\t\tbreak;\n\tcase SNDRV_SFNT_LOAD_DATA:\n\t\trc = load_data(sflist, data, count);\n\t\tbreak;\n\tcase SNDRV_SFNT_CLOSE_PATCH:\n\t\trc = close_patch(sflist);\n\t\tbreak;\n\tcase SNDRV_SFNT_REPLACE_DATA:\n\t\t \n\t\tbreak;\n\tcase SNDRV_SFNT_MAP_PRESET:\n\t\trc = load_map(sflist, data, count);\n\t\tbreak;\n\tcase SNDRV_SFNT_PROBE_DATA:\n\t\trc = probe_data(sflist, patch.optarg);\n\t\tbreak;\n\tcase SNDRV_SFNT_REMOVE_INFO:\n\t\t \n\t\tif (!sflist->currsf) {\n\t\t\tsnd_printk(KERN_ERR \"soundfont: remove_info: \"\n\t\t\t\t   \"patch not opened\\n\");\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\tint bank, instr;\n\t\t\tbank = ((unsigned short)patch.optarg >> 8) & 0xff;\n\t\t\tinstr = (unsigned short)patch.optarg & 0xff;\n\t\t\tif (! remove_info(sflist, sflist->currsf, bank, instr))\n\t\t\t\trc = -EINVAL;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tunlock_preset(sflist);\n\n\treturn rc;\n}\n\n\n \nstatic inline int\nis_special_type(int type)\n{\n\ttype &= 0x0f;\n\treturn (type == SNDRV_SFNT_PAT_TYPE_GUS ||\n\t\ttype == SNDRV_SFNT_PAT_TYPE_MAP);\n}\n\n\n \nstatic int\nopen_patch(struct snd_sf_list *sflist, const char __user *data,\n\t   int count, int client)\n{\n\tstruct soundfont_open_parm parm;\n\tstruct snd_soundfont *sf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tif (sflist->open_client >= 0 || sflist->currsf) {\n\t\tspin_unlock_irqrestore(&sflist->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\n\tif (copy_from_user(&parm, data, sizeof(parm)))\n\t\treturn -EFAULT;\n\n\tif (is_special_type(parm.type)) {\n\t\tparm.type |= SNDRV_SFNT_PAT_SHARED;\n\t\tsf = newsf(sflist, parm.type, NULL);\n\t} else \n\t\tsf = newsf(sflist, parm.type, parm.name);\n\tif (sf == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tsflist->open_client = client;\n\tsflist->currsf = sf;\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic struct snd_soundfont *\nnewsf(struct snd_sf_list *sflist, int type, char *name)\n{\n\tstruct snd_soundfont *sf;\n\n\t \n\tif (type & SNDRV_SFNT_PAT_SHARED) {\n\t\tfor (sf = sflist->fonts; sf; sf = sf->next) {\n\t\t\tif (is_identical_font(sf, type, name)) {\n\t\t\t\treturn sf;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsf = kzalloc(sizeof(*sf), GFP_KERNEL);\n\tif (sf == NULL)\n\t\treturn NULL;\n\tsf->id = sflist->fonts_size;\n\tsflist->fonts_size++;\n\n\t \n\tsf->next = sflist->fonts;\n\tsflist->fonts = sf;\n\n\tsf->type = type;\n\tsf->zones = NULL;\n\tsf->samples = NULL;\n\tif (name)\n\t\tmemcpy(sf->name, name, SNDRV_SFNT_PATCH_NAME_LEN);\n\n\treturn sf;\n}\n\n \nstatic int\nis_identical_font(struct snd_soundfont *sf, int type, unsigned char *name)\n{\n\treturn ((sf->type & SNDRV_SFNT_PAT_SHARED) &&\n\t\t(sf->type & 0x0f) == (type & 0x0f) &&\n\t\t(name == NULL ||\n\t\t memcmp(sf->name, name, SNDRV_SFNT_PATCH_NAME_LEN) == 0));\n}\n\n \nstatic int\nclose_patch(struct snd_sf_list *sflist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sflist->lock, flags);\n\tsflist->currsf = NULL;\n\tsflist->open_client = -1;\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\n\trebuild_presets(sflist);\n\n\treturn 0;\n\n}\n\n \nstatic int\nprobe_data(struct snd_sf_list *sflist, int sample_id)\n{\n\t \n\tif (sflist->currsf) {\n\t\t \n\t\tif (find_sample(sflist->currsf, sample_id))\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void\nset_zone_counter(struct snd_sf_list *sflist, struct snd_soundfont *sf,\n\t\t struct snd_sf_zone *zp)\n{\n\tzp->counter = sflist->zone_counter++;\n\tif (sf->type & SNDRV_SFNT_PAT_LOCKED)\n\t\tsflist->zone_locked = sflist->zone_counter;\n}\n\n \nstatic struct snd_sf_zone *\nsf_zone_new(struct snd_sf_list *sflist, struct snd_soundfont *sf)\n{\n\tstruct snd_sf_zone *zp;\n\n\tzp = kzalloc(sizeof(*zp), GFP_KERNEL);\n\tif (!zp)\n\t\treturn NULL;\n\tzp->next = sf->zones;\n\tsf->zones = zp;\n\n\tinit_voice_info(&zp->v);\n\n\tset_zone_counter(sflist, sf, zp);\n\treturn zp;\n}\n\n\n \nstatic void\nset_sample_counter(struct snd_sf_list *sflist, struct snd_soundfont *sf,\n\t\t   struct snd_sf_sample *sp)\n{\n\tsp->counter = sflist->sample_counter++;\n\tif (sf->type & SNDRV_SFNT_PAT_LOCKED)\n\t\tsflist->sample_locked = sflist->sample_counter;\n}\n\n \nstatic struct snd_sf_sample *\nsf_sample_new(struct snd_sf_list *sflist, struct snd_soundfont *sf)\n{\n\tstruct snd_sf_sample *sp;\n\n\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\tif (!sp)\n\t\treturn NULL;\n\n\tsp->next = sf->samples;\n\tsf->samples = sp;\n\n\tset_sample_counter(sflist, sf, sp);\n\treturn sp;\n}\n\n \nstatic void\nsf_sample_delete(struct snd_sf_list *sflist, struct snd_soundfont *sf,\n\t\t struct snd_sf_sample *sp)\n{\n\t \n\tif (sp == sf->samples) {\n\t\tsf->samples = sp->next;\n\t\tkfree(sp);\n\t}\n}\n\n\n \nstatic int\nload_map(struct snd_sf_list *sflist, const void __user *data, int count)\n{\n\tstruct snd_sf_zone *zp, *prevp;\n\tstruct snd_soundfont *sf;\n\tstruct soundfont_voice_map map;\n\n\t \n\tif (count < (int)sizeof(map))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&map, data, sizeof(map)))\n\t\treturn -EFAULT;\n\n\tif (map.map_instr < 0 || map.map_instr >= SF_MAX_INSTRUMENTS)\n\t\treturn -EINVAL;\n\t\n\tsf = newsf(sflist, SNDRV_SFNT_PAT_TYPE_MAP|SNDRV_SFNT_PAT_SHARED, NULL);\n\tif (sf == NULL)\n\t\treturn -ENOMEM;\n\n\tprevp = NULL;\n\tfor (zp = sf->zones; zp; prevp = zp, zp = zp->next) {\n\t\tif (zp->mapped &&\n\t\t    zp->instr == map.map_instr &&\n\t\t    zp->bank == map.map_bank &&\n\t\t    zp->v.low == map.map_key &&\n\t\t    zp->v.start == map.src_instr &&\n\t\t    zp->v.end == map.src_bank &&\n\t\t    zp->v.fixkey == map.src_key) {\n\t\t\t \n\t\t\t \n\t\t\tif (prevp) {\n\t\t\t\tprevp->next = zp->next;\n\t\t\t\tzp->next = sf->zones;\n\t\t\t\tsf->zones = zp;\n\t\t\t}\n\t\t\t \n\t\t\tset_zone_counter(sflist, sf, zp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tzp = sf_zone_new(sflist, sf);\n\tif (!zp)\n\t\treturn -ENOMEM;\n\n\tzp->bank = map.map_bank;\n\tzp->instr = map.map_instr;\n\tzp->mapped = 1;\n\tif (map.map_key >= 0) {\n\t\tzp->v.low = map.map_key;\n\t\tzp->v.high = map.map_key;\n\t}\n\tzp->v.start = map.src_instr;\n\tzp->v.end = map.src_bank;\n\tzp->v.fixkey = map.src_key;\n\tzp->v.sf_id = sf->id;\n\n\tadd_preset(sflist, zp);\n\n\treturn 0;\n}\n\n\n \nstatic int\nremove_info(struct snd_sf_list *sflist, struct snd_soundfont *sf,\n\t    int bank, int instr)\n{\n\tstruct snd_sf_zone *prev, *next, *p;\n\tint removed = 0;\n\n\tprev = NULL;\n\tfor (p = sf->zones; p; p = next) {\n\t\tnext = p->next;\n\t\tif (! p->mapped &&\n\t\t    p->bank == bank && p->instr == instr) {\n\t\t\t \n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tsf->zones = next;\n\t\t\tremoved++;\n\t\t\tkfree(p);\n\t\t} else\n\t\t\tprev = p;\n\t}\n\tif (removed)\n\t\trebuild_presets(sflist);\n\treturn removed;\n}\n\n\n \nstatic int\nload_info(struct snd_sf_list *sflist, const void __user *data, long count)\n{\n\tstruct snd_soundfont *sf;\n\tstruct snd_sf_zone *zone;\n\tstruct soundfont_voice_rec_hdr hdr;\n\tint i;\n\n\t \n\tsf = sflist->currsf;\n\tif (!sf)\n\t\treturn -EINVAL;\n\n\tif (is_special_type(sf->type))\n\t\treturn -EINVAL;\n\n\tif (count < (long)sizeof(hdr)) {\n\t\tprintk(KERN_ERR \"Soundfont error: invalid patch zone length\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (copy_from_user((char*)&hdr, data, sizeof(hdr)))\n\t\treturn -EFAULT;\n\t\n\tdata += sizeof(hdr);\n\tcount -= sizeof(hdr);\n\n\tif (hdr.nvoices <= 0 || hdr.nvoices >= 100) {\n\t\tprintk(KERN_ERR \"Soundfont error: Illegal voice number %d\\n\",\n\t\t       hdr.nvoices);\n\t\treturn -EINVAL;\n\t}\n\n\tif (count < (long)sizeof(struct soundfont_voice_info) * hdr.nvoices) {\n\t\tprintk(KERN_ERR \"Soundfont Error: \"\n\t\t       \"patch length(%ld) is smaller than nvoices(%d)\\n\",\n\t\t       count, hdr.nvoices);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (hdr.write_mode) {\n\tcase SNDRV_SFNT_WR_EXCLUSIVE:\n\t\t \n\t\tfor (zone = sf->zones; zone; zone = zone->next) {\n\t\t\tif (!zone->mapped &&\n\t\t\t    zone->bank == hdr.bank &&\n\t\t\t    zone->instr == hdr.instr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_SFNT_WR_REPLACE:\n\t\t \n\t\tremove_info(sflist, sf, hdr.bank, hdr.instr);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < hdr.nvoices; i++) {\n\t\tstruct snd_sf_zone tmpzone;\n\n\t\t \n\t\tif (copy_from_user(&tmpzone.v, data, sizeof(tmpzone.v))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tdata += sizeof(tmpzone.v);\n\t\tcount -= sizeof(tmpzone.v);\n\n\t\ttmpzone.bank = hdr.bank;\n\t\ttmpzone.instr = hdr.instr;\n\t\ttmpzone.mapped = 0;\n\t\ttmpzone.v.sf_id = sf->id;\n\t\tif (tmpzone.v.mode & SNDRV_SFNT_MODE_INIT_PARM)\n\t\t\tinit_voice_parm(&tmpzone.v.parm);\n\n\t\t \n\t\tzone = sf_zone_new(sflist, sf);\n\t\tif (!zone)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tzone->bank = tmpzone.bank;\n\t\tzone->instr = tmpzone.instr;\n\t\tzone->v = tmpzone.v;\n\n\t\t \n\t\tzone->sample = set_sample(sf, &zone->v);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void\ninit_voice_info(struct soundfont_voice_info *avp)\n{\n\tmemset(avp, 0, sizeof(*avp));\n\n\tavp->root = 60;\n\tavp->high = 127;\n\tavp->velhigh = 127;\n\tavp->fixkey = -1;\n\tavp->fixvel = -1;\n\tavp->fixpan = -1;\n\tavp->pan = -1;\n\tavp->amplitude = 127;\n\tavp->scaleTuning = 100;\n\n\tinit_voice_parm(&avp->parm);\n}\n\n \nstatic void\ninit_voice_parm(struct soundfont_voice_parm *pp)\n{\n\tmemset(pp, 0, sizeof(*pp));\n\n\tpp->moddelay = 0x8000;\n\tpp->modatkhld = 0x7f7f;\n\tpp->moddcysus = 0x7f7f;\n\tpp->modrelease = 0x807f;\n\n\tpp->voldelay = 0x8000;\n\tpp->volatkhld = 0x7f7f;\n\tpp->voldcysus = 0x7f7f;\n\tpp->volrelease = 0x807f;\n\n\tpp->lfo1delay = 0x8000;\n\tpp->lfo2delay = 0x8000;\n\n\tpp->cutoff = 0xff;\n}\t\n\n \nstatic struct snd_sf_sample *\nset_sample(struct snd_soundfont *sf, struct soundfont_voice_info *avp)\n{\n\tstruct snd_sf_sample *sample;\n\n\tsample = find_sample(sf, avp->sample);\n\tif (sample == NULL)\n\t\treturn NULL;\n\n\t \n\tavp->start += sample->v.start;\n\tavp->end += sample->v.end;\n\tavp->loopstart += sample->v.loopstart;\n\tavp->loopend += sample->v.loopend;\n\n\t \n\tavp->sample_mode = sample->v.mode_flags;\n\n\treturn sample;\n}\n\n \nstatic struct snd_sf_sample *\nfind_sample(struct snd_soundfont *sf, int sample_id)\n{\n\tstruct snd_sf_sample *p;\n\n\tif (sf == NULL)\n\t\treturn NULL;\n\n\tfor (p = sf->samples; p; p = p->next) {\n\t\tif (p->v.sample == sample_id)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n\n \nstatic int\nload_data(struct snd_sf_list *sflist, const void __user *data, long count)\n{\n\tstruct snd_soundfont *sf;\n\tstruct soundfont_sample_info sample_info;\n\tstruct snd_sf_sample *sp;\n\tlong off;\n\n\t \n\tsf = sflist->currsf;\n\tif (!sf)\n\t\treturn -EINVAL;\n\n\tif (is_special_type(sf->type))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&sample_info, data, sizeof(sample_info)))\n\t\treturn -EFAULT;\n\n\toff = sizeof(sample_info);\n\n\tif (sample_info.size != (count-off)/2)\n\t\treturn -EINVAL;\n\n\t \n\tif (find_sample(sf, sample_info.sample)) {\n\t\t \n\t\tif (sf->type & SNDRV_SFNT_PAT_SHARED)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsp = sf_sample_new(sflist, sf);\n\tif (!sp)\n\t\treturn -ENOMEM;\n\n\tsp->v = sample_info;\n\tsp->v.sf_id = sf->id;\n\tsp->v.dummy = 0;\n\tsp->v.truesize = sp->v.size;\n\n\t \n\tif (sp->v.size > 0) {\n\t\tint  rc;\n\t\trc = sflist->callback.sample_new\n\t\t\t(sflist->callback.private_data, sp, sflist->memhdr,\n\t\t\t data + off, count - off);\n\t\tif (rc < 0) {\n\t\t\tsf_sample_delete(sflist, sf, sp);\n\t\t\treturn rc;\n\t\t}\n\t\tsflist->mem_used += sp->v.truesize;\n\t}\n\n\treturn count;\n}\n\n\n \nstatic const int log_tbl[129] = {\n\t0x70000, 0x702df, 0x705b9, 0x7088e, 0x70b5d, 0x70e26, 0x710eb, 0x713aa,\n\t0x71663, 0x71918, 0x71bc8, 0x71e72, 0x72118, 0x723b9, 0x72655, 0x728ed,\n\t0x72b80, 0x72e0e, 0x73098, 0x7331d, 0x7359e, 0x7381b, 0x73a93, 0x73d08,\n\t0x73f78, 0x741e4, 0x7444c, 0x746b0, 0x74910, 0x74b6c, 0x74dc4, 0x75019,\n\t0x75269, 0x754b6, 0x75700, 0x75946, 0x75b88, 0x75dc7, 0x76002, 0x7623a,\n\t0x7646e, 0x766a0, 0x768cd, 0x76af8, 0x76d1f, 0x76f43, 0x77164, 0x77382,\n\t0x7759d, 0x777b4, 0x779c9, 0x77bdb, 0x77dea, 0x77ff5, 0x781fe, 0x78404,\n\t0x78608, 0x78808, 0x78a06, 0x78c01, 0x78df9, 0x78fef, 0x791e2, 0x793d2,\n\t0x795c0, 0x797ab, 0x79993, 0x79b79, 0x79d5d, 0x79f3e, 0x7a11d, 0x7a2f9,\n\t0x7a4d3, 0x7a6ab, 0x7a880, 0x7aa53, 0x7ac24, 0x7adf2, 0x7afbe, 0x7b188,\n\t0x7b350, 0x7b515, 0x7b6d8, 0x7b899, 0x7ba58, 0x7bc15, 0x7bdd0, 0x7bf89,\n\t0x7c140, 0x7c2f5, 0x7c4a7, 0x7c658, 0x7c807, 0x7c9b3, 0x7cb5e, 0x7cd07,\n\t0x7ceae, 0x7d053, 0x7d1f7, 0x7d398, 0x7d538, 0x7d6d6, 0x7d872, 0x7da0c,\n\t0x7dba4, 0x7dd3b, 0x7ded0, 0x7e063, 0x7e1f4, 0x7e384, 0x7e512, 0x7e69f,\n\t0x7e829, 0x7e9b3, 0x7eb3a, 0x7ecc0, 0x7ee44, 0x7efc7, 0x7f148, 0x7f2c8,\n\t0x7f446, 0x7f5c2, 0x7f73d, 0x7f8b7, 0x7fa2f, 0x7fba5, 0x7fd1a, 0x7fe8d,\n\t0x80000,\n};\n\n \nint\nsnd_sf_linear_to_log(unsigned int amount, int offset, int ratio)\n{\n\tint v;\n\tint s, low, bit;\n\t\n\tif (amount < 2)\n\t\treturn 0;\n\tfor (bit = 0; ! (amount & 0x80000000L); bit++)\n\t\tamount <<= 1;\n\ts = (amount >> 24) & 0x7f;\n\tlow = (amount >> 16) & 0xff;\n\t \n\tv = (log_tbl[s + 1] * low + log_tbl[s] * (0x100 - low)) >> 8;\n\tv -= offset;\n\tv = (v * ratio) >> 16;\n\tv += (24 - bit) * ratio;\n\treturn v;\n}\n\nEXPORT_SYMBOL(snd_sf_linear_to_log);\n\n\n#define OFFSET_MSEC\t\t653117\t\t \n#define OFFSET_ABSCENT\t\t851781\t\t \n#define OFFSET_SAMPLERATE\t1011119\t\t \n\n#define ABSCENT_RATIO\t\t1200\n#define TIMECENT_RATIO\t\t1200\n#define SAMPLERATE_RATIO\t4096\n\n \nstatic int\nfreq_to_note(int mhz)\n{\n\treturn snd_sf_linear_to_log(mhz, OFFSET_ABSCENT, ABSCENT_RATIO);\n}\n\n \nstatic int\ncalc_rate_offset(int hz)\n{\n\treturn snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);\n}\n\n\n \nstatic int\ncalc_gus_envelope_time(int rate, int start, int end)\n{\n\tint r, p, t;\n\tr = (3 - ((rate >> 6) & 3)) * 3;\n\tp = rate & 0x3f;\n\tif (!p)\n\t\tp = 1;\n\tt = end - start;\n\tif (t < 0) t = -t;\n\tif (13 > r)\n\t\tt = t << (13 - r);\n\telse\n\t\tt = t >> (r - 13);\n\treturn (t * 10) / (p * 441);\n}\n\n \n\n \nstatic const short attack_time_tbl[128] = {\n32767, 32767, 5989, 4235, 2994, 2518, 2117, 1780, 1497, 1373, 1259, 1154, 1058, 970, 890, 816,\n707, 691, 662, 634, 607, 581, 557, 533, 510, 489, 468, 448, 429, 411, 393, 377,\n361, 345, 331, 317, 303, 290, 278, 266, 255, 244, 234, 224, 214, 205, 196, 188,\n180, 172, 165, 158, 151, 145, 139, 133, 127, 122, 117, 112, 107, 102, 98, 94,\n90, 86, 82, 79, 75, 72, 69, 66, 63, 61, 58, 56, 53, 51, 49, 47,\n45, 43, 41, 39, 37, 36, 34, 33, 31, 30, 29, 28, 26, 25, 24, 23,\n22, 21, 20, 19, 19, 18, 17, 16, 16, 15, 15, 14, 13, 13, 12, 12,\n11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 6, 0,\n};\n\nstatic const short decay_time_tbl[128] = {\n32767, 32767, 22614, 15990, 11307, 9508, 7995, 6723, 5653, 5184, 4754, 4359, 3997, 3665, 3361, 3082,\n2828, 2765, 2648, 2535, 2428, 2325, 2226, 2132, 2042, 1955, 1872, 1793, 1717, 1644, 1574, 1507,\n1443, 1382, 1324, 1267, 1214, 1162, 1113, 1066, 978, 936, 897, 859, 822, 787, 754, 722,\n691, 662, 634, 607, 581, 557, 533, 510, 489, 468, 448, 429, 411, 393, 377, 361,\n345, 331, 317, 303, 290, 278, 266, 255, 244, 234, 224, 214, 205, 196, 188, 180,\n172, 165, 158, 151, 145, 139, 133, 127, 122, 117, 112, 107, 102, 98, 94, 90,\n86, 82, 79, 75, 72, 69, 66, 63, 61, 58, 56, 53, 51, 49, 47, 45,\n43, 41, 39, 37, 36, 34, 33, 31, 30, 29, 28, 26, 25, 24, 23, 22,\n};\n\n \nint\nsnd_sf_calc_parm_hold(int msec)\n{\n\tint val = (0x7f * 92 - msec) / 92;\n\tif (val < 1) val = 1;\n\tif (val >= 126) val = 126;\n\treturn val;\n}\n\n \nstatic int\ncalc_parm_search(int msec, const short *table)\n{\n\tint left = 1, right = 127, mid;\n\twhile (left < right) {\n\t\tmid = (left + right) / 2;\n\t\tif (msec < (int)table[mid])\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\tright = mid;\n\t}\n\treturn left;\n}\n\n \nint\nsnd_sf_calc_parm_attack(int msec)\n{\n\treturn calc_parm_search(msec, attack_time_tbl);\n}\n\n \nint\nsnd_sf_calc_parm_decay(int msec)\n{\n\treturn calc_parm_search(msec, decay_time_tbl);\n}\n\nint snd_sf_vol_table[128] = {\n\t255,111,95,86,79,74,70,66,63,61,58,56,54,52,50,49,\n\t47,46,45,43,42,41,40,39,38,37,36,35,34,34,33,32,\n\t31,31,30,29,29,28,27,27,26,26,25,24,24,23,23,22,\n\t22,21,21,21,20,20,19,19,18,18,18,17,17,16,16,16,\n\t15,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,\n\t10,10,10,9,9,9,8,8,8,8,7,7,7,7,6,6,\n\t6,6,5,5,5,5,5,4,4,4,4,3,3,3,3,3,\n\t2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,\n};\n\n\n#define calc_gus_sustain(val)  (0x7f - snd_sf_vol_table[(val)/2])\n#define calc_gus_attenuation(val)\tsnd_sf_vol_table[(val)/2]\n\n \nstatic int\nload_guspatch(struct snd_sf_list *sflist, const char __user *data,\n\t      long count, int client)\n{\n\tstruct patch_info patch;\n\tstruct snd_soundfont *sf;\n\tstruct snd_sf_zone *zone;\n\tstruct snd_sf_sample *smp;\n\tint note, sample_id;\n\tint rc;\n\n\tif (count < (long)sizeof(patch)) {\n\t\tsnd_printk(KERN_ERR \"patch record too small %ld\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\tif (copy_from_user(&patch, data, sizeof(patch)))\n\t\treturn -EFAULT;\n\t\n\tcount -= sizeof(patch);\n\tdata += sizeof(patch);\n\n\tsf = newsf(sflist, SNDRV_SFNT_PAT_TYPE_GUS|SNDRV_SFNT_PAT_SHARED, NULL);\n\tif (sf == NULL)\n\t\treturn -ENOMEM;\n\tsmp = sf_sample_new(sflist, sf);\n\tif (!smp)\n\t\treturn -ENOMEM;\n\tsample_id = sflist->sample_counter;\n\tsmp->v.sample = sample_id;\n\tsmp->v.start = 0;\n\tsmp->v.end = patch.len;\n\tsmp->v.loopstart = patch.loop_start;\n\tsmp->v.loopend = patch.loop_end;\n\tsmp->v.size = patch.len;\n\n\t \n\tsmp->v.mode_flags = 0;\n\tif (!(patch.mode & WAVE_16_BITS))\n\t\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_8BITS;\n\tif (patch.mode & WAVE_UNSIGNED)\n\t\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_UNSIGNED;\n\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_NO_BLANK;\n\tif (!(patch.mode & (WAVE_LOOPING|WAVE_BIDIR_LOOP|WAVE_LOOP_BACK)))\n\t\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_SINGLESHOT;\n\tif (patch.mode & WAVE_BIDIR_LOOP)\n\t\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_BIDIR_LOOP;\n\tif (patch.mode & WAVE_LOOP_BACK)\n\t\tsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_REVERSE_LOOP;\n\n\tif (patch.mode & WAVE_16_BITS) {\n\t\t \n\t\tsmp->v.size /= 2;\n\t\tsmp->v.end /= 2;\n\t\tsmp->v.loopstart /= 2;\n\t\tsmp->v.loopend /= 2;\n\t}\n\t \n\n\tsmp->v.dummy = 0;\n\tsmp->v.truesize = 0;\n\tsmp->v.sf_id = sf->id;\n\n\t \n\tzone = sf_zone_new(sflist, sf);\n\tif (!zone) {\n\t\tsf_sample_delete(sflist, sf, smp);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (sflist->callback.sample_new) {\n\t\trc = sflist->callback.sample_new\n\t\t\t(sflist->callback.private_data, smp, sflist->memhdr,\n\t\t\t data, count);\n\t\tif (rc < 0) {\n\t\t\tsf_sample_delete(sflist, sf, smp);\n\t\t\tkfree(zone);\n\t\t\treturn rc;\n\t\t}\n\t\t \n\t}\n\n\t \n\tsflist->mem_used += smp->v.truesize;\n\n\tzone->v.sample = sample_id;  \n\tzone->v.rate_offset = calc_rate_offset(patch.base_freq);\n\tnote = freq_to_note(patch.base_note);\n\tzone->v.root = note / 100;\n\tzone->v.tune = -(note % 100);\n\tzone->v.low = (freq_to_note(patch.low_note) + 99) / 100;\n\tzone->v.high = freq_to_note(patch.high_note) / 100;\n\t \n\tzone->v.pan = (patch.panning + 128) / 2;\n#if 0\n\tsnd_printk(KERN_DEBUG\n\t\t   \"gus: basefrq=%d (ofs=%d) root=%d,tune=%d, range:%d-%d\\n\",\n\t\t   (int)patch.base_freq, zone->v.rate_offset,\n\t\t   zone->v.root, zone->v.tune, zone->v.low, zone->v.high);\n#endif\n\n\t \n\t \n\tif (patch.mode & WAVE_ENVELOPES) {\n\t\tint attack, hold, decay, release;\n\t\tattack = calc_gus_envelope_time\n\t\t\t(patch.env_rate[0], 0, patch.env_offset[0]);\n\t\thold = calc_gus_envelope_time\n\t\t\t(patch.env_rate[1], patch.env_offset[0],\n\t\t\t patch.env_offset[1]);\n\t\tdecay = calc_gus_envelope_time\n\t\t\t(patch.env_rate[2], patch.env_offset[1],\n\t\t\t patch.env_offset[2]);\n\t\trelease = calc_gus_envelope_time\n\t\t\t(patch.env_rate[3], patch.env_offset[1],\n\t\t\t patch.env_offset[4]);\n\t\trelease += calc_gus_envelope_time\n\t\t\t(patch.env_rate[4], patch.env_offset[3],\n\t\t\t patch.env_offset[4]);\n\t\trelease += calc_gus_envelope_time\n\t\t\t(patch.env_rate[5], patch.env_offset[4],\n\t\t\t patch.env_offset[5]);\n\t\tzone->v.parm.volatkhld = \n\t\t\t(snd_sf_calc_parm_hold(hold) << 8) |\n\t\t\tsnd_sf_calc_parm_attack(attack);\n\t\tzone->v.parm.voldcysus = (calc_gus_sustain(patch.env_offset[2]) << 8) |\n\t\t\tsnd_sf_calc_parm_decay(decay);\n\t\tzone->v.parm.volrelease = 0x8000 | snd_sf_calc_parm_decay(release);\n\t\tzone->v.attenuation = calc_gus_attenuation(patch.env_offset[0]);\n#if 0\n\t\tsnd_printk(KERN_DEBUG\n\t\t\t   \"gus: atkhld=%x, dcysus=%x, volrel=%x, att=%d\\n\",\n\t\t\t   zone->v.parm.volatkhld,\n\t\t\t   zone->v.parm.voldcysus,\n\t\t\t   zone->v.parm.volrelease,\n\t\t\t   zone->v.attenuation);\n#endif\n\t}\n\n\t \n\tif (patch.mode & WAVE_FAST_RELEASE) {\n\t\tzone->v.parm.volrelease = 0x807f;\n\t}\n\n\t \n\tif (patch.mode & WAVE_TREMOLO) {\n\t\tint rate = (patch.tremolo_rate * 1000 / 38) / 42;\n\t\tzone->v.parm.tremfrq = ((patch.tremolo_depth / 2) << 8) | rate;\n\t}\n\t \n\tif (patch.mode & WAVE_VIBRATO) {\n\t\tint rate = (patch.vibrato_rate * 1000 / 38) / 42;\n\t\tzone->v.parm.fm2frq2 = ((patch.vibrato_depth / 6) << 8) | rate;\n\t}\n\t\n\t \n\n\tif (!(smp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT))\n\t\tzone->v.mode = SNDRV_SFNT_MODE_LOOPING;\n\telse\n\t\tzone->v.mode = 0;\n\n\t \n\t \n\tzone->bank = 0;\n\tzone->instr = patch.instr_no;\n\tzone->mapped = 0;\n\tzone->v.sf_id = sf->id;\n\n\tzone->sample = set_sample(sf, &zone->v);\n\n\t \n\tadd_preset(sflist, zone);\n\n\treturn 0;\n}\n\n \nint\nsnd_soundfont_load_guspatch(struct snd_sf_list *sflist, const char __user *data,\n\t\t\t    long count, int client)\n{\n\tint rc;\n\tlock_preset(sflist);\n\trc = load_guspatch(sflist, data, count, client);\n\tunlock_preset(sflist);\n\treturn rc;\n}\n\n\n \nstatic void\nrebuild_presets(struct snd_sf_list *sflist)\n{\n\tstruct snd_soundfont *sf;\n\tstruct snd_sf_zone *cur;\n\n\t \n\tmemset(sflist->presets, 0, sizeof(sflist->presets));\n\n\t \n\tfor (sf = sflist->fonts; sf; sf = sf->next) {\n\t\tfor (cur = sf->zones; cur; cur = cur->next) {\n\t\t\tif (! cur->mapped && cur->sample == NULL) {\n\t\t\t\t \n\t\t\t\tcur->sample = set_sample(sf, &cur->v);\n\t\t\t\tif (cur->sample == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_preset(sflist, cur);\n\t\t}\n\t}\n}\n\n\n \nstatic void\nadd_preset(struct snd_sf_list *sflist, struct snd_sf_zone *cur)\n{\n\tstruct snd_sf_zone *zone;\n\tint index;\n\n\tzone = search_first_zone(sflist, cur->bank, cur->instr, cur->v.low);\n\tif (zone && zone->v.sf_id != cur->v.sf_id) {\n\t\t \n\t\tstruct snd_sf_zone *p;\n\t\t \n\t\tfor (p = zone; p; p = p->next_zone) {\n\t\t\tif (p->counter > cur->counter)\n\t\t\t\t \n\t\t\t\treturn;\n\t\t}\n\t\t \n\t\tdelete_preset(sflist, zone);\n\t\tzone = NULL;  \n\t}\n\n\t \n\tindex = get_index(cur->bank, cur->instr, cur->v.low);\n\tif (index < 0)\n\t\treturn;\n\tcur->next_zone = zone;  \n\tcur->next_instr = sflist->presets[index];  \n\tsflist->presets[index] = cur;\n}\n\n \nstatic void\ndelete_preset(struct snd_sf_list *sflist, struct snd_sf_zone *zp)\n{\n\tint index;\n\tstruct snd_sf_zone *p;\n\n\tindex = get_index(zp->bank, zp->instr, zp->v.low);\n\tif (index < 0)\n\t\treturn;\n\tfor (p = sflist->presets[index]; p; p = p->next_instr) {\n\t\twhile (p->next_instr == zp) {\n\t\t\tp->next_instr = zp->next_instr;\n\t\t\tzp = zp->next_zone;\n\t\t\tif (zp == NULL)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n\n \nint\nsnd_soundfont_search_zone(struct snd_sf_list *sflist, int *notep, int vel,\n\t\t\t  int preset, int bank,\n\t\t\t  int def_preset, int def_bank,\n\t\t\t  struct snd_sf_zone **table, int max_layers)\n{\n\tint nvoices;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&sflist->lock, flags);\n\tif (sflist->presets_locked) {\n\t\tspin_unlock_irqrestore(&sflist->lock, flags);\n\t\treturn 0;\n\t}\n\tnvoices = search_zones(sflist, notep, vel, preset, bank,\n\t\t\t       table, max_layers, 0);\n\tif (! nvoices) {\n\t\tif (preset != def_preset || bank != def_bank)\n\t\t\tnvoices = search_zones(sflist, notep, vel,\n\t\t\t\t\t       def_preset, def_bank,\n\t\t\t\t\t       table, max_layers, 0);\n\t}\n\tspin_unlock_irqrestore(&sflist->lock, flags);\n\treturn nvoices;\n}\n\n\n \nstatic struct snd_sf_zone *\nsearch_first_zone(struct snd_sf_list *sflist, int bank, int preset, int key)\n{\n\tint index;\n\tstruct snd_sf_zone *zp;\n\n\tindex = get_index(bank, preset, key);\n\tif (index < 0)\n\t\treturn NULL;\n\tfor (zp = sflist->presets[index]; zp; zp = zp->next_instr) {\n\t\tif (zp->instr == preset && zp->bank == bank)\n\t\t\treturn zp;\n\t}\n\treturn NULL;\n}\n\n\n \nstatic int\nsearch_zones(struct snd_sf_list *sflist, int *notep, int vel,\n\t     int preset, int bank, struct snd_sf_zone **table,\n\t     int max_layers, int level)\n{\n\tstruct snd_sf_zone *zp;\n\tint nvoices;\n\n\tzp = search_first_zone(sflist, bank, preset, *notep);\n\tnvoices = 0;\n\tfor (; zp; zp = zp->next_zone) {\n\t\tif (*notep >= zp->v.low && *notep <= zp->v.high &&\n\t\t    vel >= zp->v.vellow && vel <= zp->v.velhigh) {\n\t\t\tif (zp->mapped) {\n\t\t\t\t \n\t\t\t\tint key = zp->v.fixkey;\n\t\t\t\tpreset = zp->v.start;\n\t\t\t\tbank = zp->v.end;\n\n\t\t\t\tif (level > 5)  \n\t\t\t\t\treturn 0;\n\t\t\t\tif (key < 0)\n\t\t\t\t\tkey = *notep;\n\t\t\t\tnvoices = search_zones(sflist, &key, vel,\n\t\t\t\t\t\t       preset, bank, table,\n\t\t\t\t\t\t       max_layers, level + 1);\n\t\t\t\tif (nvoices > 0)\n\t\t\t\t\t*notep = key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttable[nvoices++] = zp;\n\t\t\tif (nvoices >= max_layers)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nvoices;\n}\n\n\n \nstatic int\nget_index(int bank, int instr, int key)\n{\n\tint index;\n\tif (SF_IS_DRUM_BANK(bank))\n\t\tindex = key + SF_MAX_INSTRUMENTS;\n\telse\n\t\tindex = instr;\n\tindex = index % SF_MAX_PRESETS;\n\tif (index < 0)\n\t\treturn -1;\n\treturn index;\n}\n\n \nstatic void\nsnd_sf_init(struct snd_sf_list *sflist)\n{\n\tmemset(sflist->presets, 0, sizeof(sflist->presets));\n\n\tsflist->mem_used = 0;\n\tsflist->currsf = NULL;\n\tsflist->open_client = -1;\n\tsflist->fonts = NULL;\n\tsflist->fonts_size = 0;\n\tsflist->zone_counter = 0;\n\tsflist->sample_counter = 0;\n\tsflist->zone_locked = 0;\n\tsflist->sample_locked = 0;\n}\n\n \nstatic void\nsnd_sf_clear(struct snd_sf_list *sflist)\n{\n\tstruct snd_soundfont *sf, *nextsf;\n\tstruct snd_sf_zone *zp, *nextzp;\n\tstruct snd_sf_sample *sp, *nextsp;\n\n\tfor (sf = sflist->fonts; sf; sf = nextsf) {\n\t\tnextsf = sf->next;\n\t\tfor (zp = sf->zones; zp; zp = nextzp) {\n\t\t\tnextzp = zp->next;\n\t\t\tkfree(zp);\n\t\t}\n\t\tfor (sp = sf->samples; sp; sp = nextsp) {\n\t\t\tnextsp = sp->next;\n\t\t\tif (sflist->callback.sample_free)\n\t\t\t\tsflist->callback.sample_free(sflist->callback.private_data,\n\t\t\t\t\t\t\t     sp, sflist->memhdr);\n\t\t\tkfree(sp);\n\t\t}\n\t\tkfree(sf);\n\t}\n\n\tsnd_sf_init(sflist);\n}\n\n\n \nstruct snd_sf_list *\nsnd_sf_new(struct snd_sf_callback *callback, struct snd_util_memhdr *hdr)\n{\n\tstruct snd_sf_list *sflist;\n\n\tsflist = kzalloc(sizeof(*sflist), GFP_KERNEL);\n\tif (!sflist)\n\t\treturn NULL;\n\n\tmutex_init(&sflist->presets_mutex);\n\tspin_lock_init(&sflist->lock);\n\tsflist->memhdr = hdr;\n\n\tif (callback)\n\t\tsflist->callback = *callback;\n\n\tsnd_sf_init(sflist);\n\treturn sflist;\n}\n\n\n \nvoid\nsnd_sf_free(struct snd_sf_list *sflist)\n{\n\tif (sflist == NULL)\n\t\treturn;\n\t\n\tlock_preset(sflist);\n\tif (sflist->callback.sample_reset)\n\t\tsflist->callback.sample_reset(sflist->callback.private_data);\n\tsnd_sf_clear(sflist);\n\tunlock_preset(sflist);\n\n\tkfree(sflist);\n}\n\n \nint\nsnd_soundfont_remove_samples(struct snd_sf_list *sflist)\n{\n\tlock_preset(sflist);\n\tif (sflist->callback.sample_reset)\n\t\tsflist->callback.sample_reset(sflist->callback.private_data);\n\tsnd_sf_clear(sflist);\n\tunlock_preset(sflist);\n\n\treturn 0;\n}\n\n \nint\nsnd_soundfont_remove_unlocked(struct snd_sf_list *sflist)\n{\n\tstruct snd_soundfont *sf;\n\tstruct snd_sf_zone *zp, *nextzp;\n\tstruct snd_sf_sample *sp, *nextsp;\n\n\tlock_preset(sflist);\n\n\tif (sflist->callback.sample_reset)\n\t\tsflist->callback.sample_reset(sflist->callback.private_data);\n\n\t \n\tmemset(sflist->presets, 0, sizeof(sflist->presets));\n\n\tfor (sf = sflist->fonts; sf; sf = sf->next) {\n\t\tfor (zp = sf->zones; zp; zp = nextzp) {\n\t\t\tif (zp->counter < sflist->zone_locked)\n\t\t\t\tbreak;\n\t\t\tnextzp = zp->next;\n\t\t\tsf->zones = nextzp;\n\t\t\tkfree(zp);\n\t\t}\n\n\t\tfor (sp = sf->samples; sp; sp = nextsp) {\n\t\t\tif (sp->counter < sflist->sample_locked)\n\t\t\t\tbreak;\n\t\t\tnextsp = sp->next;\n\t\t\tsf->samples = nextsp;\n\t\t\tsflist->mem_used -= sp->v.truesize;\n\t\t\tif (sflist->callback.sample_free)\n\t\t\t\tsflist->callback.sample_free(sflist->callback.private_data,\n\t\t\t\t\t\t\t     sp, sflist->memhdr);\n\t\t\tkfree(sp);\n\t\t}\n\t}\n\n\tsflist->zone_counter = sflist->zone_locked;\n\tsflist->sample_counter = sflist->sample_locked;\n\n\trebuild_presets(sflist);\n\n\tunlock_preset(sflist);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}