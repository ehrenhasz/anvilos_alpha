{
  "module_name": "emux_proc.c",
  "hash_id": "1a88b07b93e0a29def905185f207852304ec833339bed625fdf05cab542f6a96",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_proc.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n#include <sound/core.h>\n#include <sound/emux_synth.h>\n#include <sound/info.h>\n#include \"emux_voice.h\"\n\nstatic void\nsnd_emux_proc_info_read(struct snd_info_entry *entry, \n\t\t\tstruct snd_info_buffer *buf)\n{\n\tstruct snd_emux *emu;\n\tint i;\n\n\temu = entry->private_data;\n\tmutex_lock(&emu->register_mutex);\n\tif (emu->name)\n\t\tsnd_iprintf(buf, \"Device: %s\\n\", emu->name);\n\tsnd_iprintf(buf, \"Ports: %d\\n\", emu->num_ports);\n\tsnd_iprintf(buf, \"Addresses:\");\n\tfor (i = 0; i < emu->num_ports; i++)\n\t\tsnd_iprintf(buf, \" %d:%d\", emu->client, emu->ports[i]);\n\tsnd_iprintf(buf, \"\\n\");\n\tsnd_iprintf(buf, \"Use Counter: %d\\n\", emu->used);\n\tsnd_iprintf(buf, \"Max Voices: %d\\n\", emu->max_voices);\n\tsnd_iprintf(buf, \"Allocated Voices: %d\\n\", emu->num_voices);\n\tif (emu->memhdr) {\n\t\tsnd_iprintf(buf, \"Memory Size: %d\\n\", emu->memhdr->size);\n\t\tsnd_iprintf(buf, \"Memory Available: %d\\n\", snd_util_mem_avail(emu->memhdr));\n\t\tsnd_iprintf(buf, \"Allocated Blocks: %d\\n\", emu->memhdr->nblocks);\n\t} else {\n\t\tsnd_iprintf(buf, \"Memory Size: 0\\n\");\n\t}\n\tif (emu->sflist) {\n\t\tmutex_lock(&emu->sflist->presets_mutex);\n\t\tsnd_iprintf(buf, \"SoundFonts: %d\\n\", emu->sflist->fonts_size);\n\t\tsnd_iprintf(buf, \"Instruments: %d\\n\", emu->sflist->zone_counter);\n\t\tsnd_iprintf(buf, \"Samples: %d\\n\", emu->sflist->sample_counter);\n\t\tsnd_iprintf(buf, \"Locked Instruments: %d\\n\", emu->sflist->zone_locked);\n\t\tsnd_iprintf(buf, \"Locked Samples: %d\\n\", emu->sflist->sample_locked);\n\t\tmutex_unlock(&emu->sflist->presets_mutex);\n\t}\n#if 0   \n\tif (emu->voices[0].state != SNDRV_EMUX_ST_OFF && emu->voices[0].ch >= 0) {\n\t\tstruct snd_emux_voice *vp = &emu->voices[0];\n\t\tsnd_iprintf(buf, \"voice 0: on\\n\");\n\t\tsnd_iprintf(buf, \"mod delay=%x, atkhld=%x, dcysus=%x, rel=%x\\n\",\n\t\t\t    vp->reg.parm.moddelay,\n\t\t\t    vp->reg.parm.modatkhld,\n\t\t\t    vp->reg.parm.moddcysus,\n\t\t\t    vp->reg.parm.modrelease);\n\t\tsnd_iprintf(buf, \"vol delay=%x, atkhld=%x, dcysus=%x, rel=%x\\n\",\n\t\t\t    vp->reg.parm.voldelay,\n\t\t\t    vp->reg.parm.volatkhld,\n\t\t\t    vp->reg.parm.voldcysus,\n\t\t\t    vp->reg.parm.volrelease);\n\t\tsnd_iprintf(buf, \"lfo1 delay=%x, lfo2 delay=%x, pefe=%x\\n\",\n\t\t\t    vp->reg.parm.lfo1delay,\n\t\t\t    vp->reg.parm.lfo2delay,\n\t\t\t    vp->reg.parm.pefe);\n\t\tsnd_iprintf(buf, \"fmmod=%x, tremfrq=%x, fm2frq2=%x\\n\",\n\t\t\t    vp->reg.parm.fmmod,\n\t\t\t    vp->reg.parm.tremfrq,\n\t\t\t    vp->reg.parm.fm2frq2);\n\t\tsnd_iprintf(buf, \"cutoff=%x, filterQ=%x, chorus=%x, reverb=%x\\n\",\n\t\t\t    vp->reg.parm.cutoff,\n\t\t\t    vp->reg.parm.filterQ,\n\t\t\t    vp->reg.parm.chorus,\n\t\t\t    vp->reg.parm.reverb);\n\t\tsnd_iprintf(buf, \"avol=%x, acutoff=%x, apitch=%x\\n\",\n\t\t\t    vp->avol, vp->acutoff, vp->apitch);\n\t\tsnd_iprintf(buf, \"apan=%x, aaux=%x, ptarget=%x, vtarget=%x, ftarget=%x\\n\",\n\t\t\t    vp->apan, vp->aaux,\n\t\t\t    vp->ptarget,\n\t\t\t    vp->vtarget,\n\t\t\t    vp->ftarget);\n\t\tsnd_iprintf(buf, \"start=%x, end=%x, loopstart=%x, loopend=%x\\n\",\n\t\t\t    vp->reg.start, vp->reg.end, vp->reg.loopstart, vp->reg.loopend);\n\t\tsnd_iprintf(buf, \"sample_mode=%x, rate=%x\\n\", vp->reg.sample_mode, vp->reg.rate_offset);\n\t}\n#endif\n\tmutex_unlock(&emu->register_mutex);\n}\n\n\nvoid snd_emux_proc_init(struct snd_emux *emu, struct snd_card *card, int device)\n{\n\tstruct snd_info_entry *entry;\n\tchar name[64];\n\n\tsprintf(name, \"wavetableD%d\", device);\n\tentry = snd_info_create_card_entry(card, name, card->proc_root);\n\tif (entry == NULL)\n\t\treturn;\n\n\tentry->content = SNDRV_INFO_CONTENT_TEXT;\n\tentry->private_data = emu;\n\tentry->c.text.read = snd_emux_proc_info_read;\n}\n\nvoid snd_emux_proc_free(struct snd_emux *emu)\n{\n\tsnd_info_free_entry(emu->proc);\n\temu->proc = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}