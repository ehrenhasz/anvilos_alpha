{
  "module_name": "emux_effect.c",
  "hash_id": "2dadfc40a747c52f38771308266e83e02491dfd9e843d72442e8d562eb521914",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_effect.c",
  "human_readable_source": "\n \n\n#include \"emux_voice.h\"\n#include <linux/slab.h>\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n \n\n#define xoffsetof(type,tag)\t((long)(&((type)NULL)->tag) - (long)(NULL))\n\n#define parm_offset(tag)\txoffsetof(struct soundfont_voice_parm *, tag)\n\n#define PARM_IS_BYTE\t\t(1 << 0)\n#define PARM_IS_WORD\t\t(1 << 1)\n#define PARM_IS_ALIGNED\t\t(3 << 2)\n#define PARM_IS_ALIGN_HI\t(1 << 2)\n#define PARM_IS_ALIGN_LO\t(2 << 2)\n#define PARM_IS_SIGNED\t\t(1 << 4)\n\n#define PARM_WORD\t(PARM_IS_WORD)\n#define PARM_BYTE_LO\t(PARM_IS_BYTE|PARM_IS_ALIGN_LO)\n#define PARM_BYTE_HI\t(PARM_IS_BYTE|PARM_IS_ALIGN_HI)\n#define PARM_BYTE\t(PARM_IS_BYTE)\n#define PARM_SIGN_LO\t(PARM_IS_BYTE|PARM_IS_ALIGN_LO|PARM_IS_SIGNED)\n#define PARM_SIGN_HI\t(PARM_IS_BYTE|PARM_IS_ALIGN_HI|PARM_IS_SIGNED)\n\nstatic struct emux_parm_defs {\n\tint type;\t \n\tint low, high;\t \n\tlong offset;\t \n\tint update;\t \n} parm_defs[EMUX_NUM_EFFECTS] = {\n\t{PARM_WORD, 0, 0x8000, parm_offset(moddelay), 0},\t \n\t{PARM_BYTE_LO, 1, 0x80, parm_offset(modatkhld), 0},\t \n\t{PARM_BYTE_HI, 0, 0x7e, parm_offset(modatkhld), 0},\t \n\t{PARM_BYTE_LO, 1, 0x7f, parm_offset(moddcysus), 0},\t \n\t{PARM_BYTE_LO, 1, 0x7f, parm_offset(modrelease), 0},\t \n\t{PARM_BYTE_HI, 0, 0x7f, parm_offset(moddcysus), 0},\t \n\t{PARM_BYTE_HI, 0, 0xff, parm_offset(pefe), 0},\t \n\t{PARM_BYTE_LO, 0, 0xff, parm_offset(pefe), 0},\t \n\n\t{PARM_WORD, 0, 0x8000, parm_offset(voldelay), 0},\t \n\t{PARM_BYTE_LO, 1, 0x80, parm_offset(volatkhld), 0},\t \n\t{PARM_BYTE_HI, 0, 0x7e, parm_offset(volatkhld), 0},\t \n\t{PARM_BYTE_LO, 1, 0x7f, parm_offset(voldcysus), 0},\t \n\t{PARM_BYTE_LO, 1, 0x7f, parm_offset(volrelease), 0},\t \n\t{PARM_BYTE_HI, 0, 0x7f, parm_offset(voldcysus), 0},\t \n\n\t{PARM_WORD, 0, 0x8000, parm_offset(lfo1delay), 0},\t \n\t{PARM_BYTE_LO, 0, 0xff, parm_offset(tremfrq), SNDRV_EMUX_UPDATE_TREMFREQ},\t \n\t{PARM_SIGN_HI, -128, 127, parm_offset(tremfrq), SNDRV_EMUX_UPDATE_TREMFREQ},\t \n\t{PARM_SIGN_HI, -128, 127, parm_offset(fmmod), SNDRV_EMUX_UPDATE_FMMOD},\t \n\t{PARM_BYTE_LO, 0, 0xff, parm_offset(fmmod), SNDRV_EMUX_UPDATE_FMMOD},\t \n\n\t{PARM_WORD, 0, 0x8000, parm_offset(lfo2delay), 0},\t \n\t{PARM_BYTE_LO, 0, 0xff, parm_offset(fm2frq2), SNDRV_EMUX_UPDATE_FM2FRQ2},\t \n\t{PARM_SIGN_HI, -128, 127, parm_offset(fm2frq2), SNDRV_EMUX_UPDATE_FM2FRQ2},\t \n\n\t{PARM_WORD, 0, 0xffff, -1, SNDRV_EMUX_UPDATE_PITCH},\t \n\t{PARM_BYTE, 0, 0xff, parm_offset(chorus), 0},\t \n\t{PARM_BYTE, 0, 0xff, parm_offset(reverb), 0},\t \n\t{PARM_BYTE, 0, 0xff, parm_offset(cutoff), SNDRV_EMUX_UPDATE_VOLUME},\t \n\t{PARM_BYTE, 0, 15, parm_offset(filterQ), SNDRV_EMUX_UPDATE_Q},\t \n\n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_WORD, 0, 0xffff, -1, 0},\t \n\t{PARM_BYTE, 0, 0xff, -1, SNDRV_EMUX_UPDATE_VOLUME},\t \n};\n\n \nstatic void\neffect_set_byte(unsigned char *valp, struct snd_midi_channel *chan, int type)\n{\n\tshort effect;\n\tstruct snd_emux_effect_table *fx = chan->private;\n\n\teffect = fx->val[type];\n\tif (fx->flag[type] == EMUX_FX_FLAG_ADD) {\n\t\tif (parm_defs[type].type & PARM_IS_SIGNED)\n\t\t\teffect += *(char*)valp;\n\t\telse\n\t\t\teffect += *valp;\n\t}\n\tif (effect < parm_defs[type].low)\n\t\teffect = parm_defs[type].low;\n\telse if (effect > parm_defs[type].high)\n\t\teffect = parm_defs[type].high;\n\t*valp = (unsigned char)effect;\n}\n\n \nstatic void\neffect_set_word(unsigned short *valp, struct snd_midi_channel *chan, int type)\n{\n\tint effect;\n\tstruct snd_emux_effect_table *fx = chan->private;\n\n\teffect = *(unsigned short*)&fx->val[type];\n\tif (fx->flag[type] == EMUX_FX_FLAG_ADD)\n\t\teffect += *valp;\n\tif (effect < parm_defs[type].low)\n\t\teffect = parm_defs[type].low;\n\telse if (effect > parm_defs[type].high)\n\t\teffect = parm_defs[type].high;\n\t*valp = (unsigned short)effect;\n}\n\n \nstatic int\neffect_get_offset(struct snd_midi_channel *chan, int lo, int hi, int mode)\n{\n\tint addr = 0;\n\tstruct snd_emux_effect_table *fx = chan->private;\n\n\tif (fx->flag[hi])\n\t\taddr = (short)fx->val[hi];\n\taddr = addr << 15;\n\tif (fx->flag[lo])\n\t\taddr += (short)fx->val[lo];\n\tif (!(mode & SNDRV_SFNT_SAMPLE_8BITS))\n\t\taddr /= 2;\n\treturn addr;\n}\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n \nvoid\nsnd_emux_send_effect_oss(struct snd_emux_port *port,\n\t\t\t struct snd_midi_channel *chan, int type, int val)\n{\n\tint mode;\n\n\tif (type & 0x40)\n\t\tmode = EMUX_FX_FLAG_OFF;\n\telse if (type & 0x80)\n\t\tmode = EMUX_FX_FLAG_ADD;\n\telse\n\t\tmode = EMUX_FX_FLAG_SET;\n\ttype &= 0x3f;\n\n\tsnd_emux_send_effect(port, chan, type, val, mode);\n}\n#endif\n\n \nvoid\nsnd_emux_send_effect(struct snd_emux_port *port, struct snd_midi_channel *chan,\n\t\t     int type, int val, int mode)\n{\n\tint i;\n\tint offset;\n\tunsigned char *srcp, *origp;\n\tstruct snd_emux *emu;\n\tstruct snd_emux_effect_table *fx;\n\tunsigned long flags;\n\n\temu = port->emu;\n\tfx = chan->private;\n\tif (emu == NULL || fx == NULL)\n\t\treturn;\n\tif (type < 0 || type >= EMUX_NUM_EFFECTS)\n\t\treturn;\n\n\tfx->val[type] = val;\n\tfx->flag[type] = mode;\n\n\t \n\tif (!parm_defs[type].update)\n\t\treturn;\n\toffset = parm_defs[type].offset;\n\tif (offset < 0)\n\t\treturn;\n\n#ifdef SNDRV_LITTLE_ENDIAN\n\tif (parm_defs[type].type & PARM_IS_ALIGN_HI)\n\t\toffset++;\n#else\n\tif (parm_defs[type].type & PARM_IS_ALIGN_LO)\n\t\toffset++;\n#endif\n\t \n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tstruct snd_emux_voice *vp = &emu->voices[i];\n\t\tif (!STATE_IS_PLAYING(vp->state) || vp->chan != chan)\n\t\t\tcontinue;\n\t\tsrcp = (unsigned char*)&vp->reg.parm + offset;\n\t\torigp = (unsigned char*)&vp->zone->v.parm + offset;\n\t\tif (parm_defs[i].type & PARM_IS_BYTE) {\n\t\t\t*srcp = *origp;\n\t\t\teffect_set_byte(srcp, chan, type);\n\t\t} else {\n\t\t\t*(unsigned short*)srcp = *(unsigned short*)origp;\n\t\t\teffect_set_word((unsigned short*)srcp, chan, type);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n\n\t \n\tsnd_emux_update_channel(port, chan, parm_defs[type].update);\n}\n\n\n \nvoid\nsnd_emux_setup_effect(struct snd_emux_voice *vp)\n{\n\tstruct snd_midi_channel *chan = vp->chan;\n\tstruct snd_emux_effect_table *fx;\n\tunsigned char *srcp;\n\tint i;\n\n\tfx = chan->private;\n\tif (!fx)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < EMUX_FX_END; i++) {\n\t\tint offset;\n\t\tif (!fx->flag[i])\n\t\t\tcontinue;\n\t\toffset = parm_defs[i].offset;\n\t\tif (offset < 0)\n\t\t\tcontinue;\n#ifdef SNDRV_LITTLE_ENDIAN\n\t\tif (parm_defs[i].type & PARM_IS_ALIGN_HI)\n\t\t\toffset++;\n#else\n\t\tif (parm_defs[i].type & PARM_IS_ALIGN_LO)\n\t\t\toffset++;\n#endif\n\t\tsrcp = (unsigned char*)&vp->reg.parm + offset;\n\t\tif (parm_defs[i].type & PARM_IS_BYTE)\n\t\t\teffect_set_byte(srcp, chan, i);\n\t\telse\n\t\t\teffect_set_word((unsigned short*)srcp, chan, i);\n\t}\n\n\t \n\tvp->reg.start += effect_get_offset(chan, EMUX_FX_SAMPLE_START,\n\t\t\t\t\t   EMUX_FX_COARSE_SAMPLE_START,\n\t\t\t\t\t   vp->reg.sample_mode);\n\n\tvp->reg.loopstart += effect_get_offset(chan, EMUX_FX_LOOP_START,\n\t\t\t\t\t       EMUX_FX_COARSE_LOOP_START,\n\t\t\t\t\t       vp->reg.sample_mode);\n\n\tvp->reg.loopend += effect_get_offset(chan, EMUX_FX_LOOP_END,\n\t\t\t\t\t     EMUX_FX_COARSE_LOOP_END,\n\t\t\t\t\t     vp->reg.sample_mode);\n}\n\n \nvoid\nsnd_emux_create_effect(struct snd_emux_port *p)\n{\n\tint i;\n\tp->effect = kcalloc(p->chset.max_channels,\n\t\t\t    sizeof(struct snd_emux_effect_table), GFP_KERNEL);\n\tif (p->effect) {\n\t\tfor (i = 0; i < p->chset.max_channels; i++)\n\t\t\tp->chset.channels[i].private = p->effect + i;\n\t} else {\n\t\tfor (i = 0; i < p->chset.max_channels; i++)\n\t\t\tp->chset.channels[i].private = NULL;\n\t}\n}\n\nvoid\nsnd_emux_delete_effect(struct snd_emux_port *p)\n{\n\tkfree(p->effect);\n\tp->effect = NULL;\n}\n\nvoid\nsnd_emux_clear_effect(struct snd_emux_port *p)\n{\n\tif (p->effect) {\n\t\tmemset(p->effect, 0, sizeof(struct snd_emux_effect_table) *\n\t\t       p->chset.max_channels);\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}