{
  "module_name": "emux_synth.c",
  "hash_id": "b747893d40fa691eb8743db9278639a434733d6f66b4ea4c92916ca03a25d083",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_synth.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include \"emux_voice.h\"\n#include <sound/asoundef.h>\n\n \n\n \n#define LIMITVALUE(x, a, b) do { if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b); } while (0)\n#define LIMITMAX(x, a) do {if ((x) > (a)) (x) = (a); } while (0)\n\nstatic int get_zone(struct snd_emux *emu, struct snd_emux_port *port,\n\t\t    int *notep, int vel, struct snd_midi_channel *chan,\n\t\t    struct snd_sf_zone **table);\nstatic int get_bank(struct snd_emux_port *port, struct snd_midi_channel *chan);\nstatic void terminate_note1(struct snd_emux *emu, int note,\n\t\t\t    struct snd_midi_channel *chan, int free);\nstatic void exclusive_note_off(struct snd_emux *emu, struct snd_emux_port *port,\n\t\t\t       int exclass);\nstatic void terminate_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int free);\nstatic void update_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int update);\nstatic void setup_voice(struct snd_emux_voice *vp);\nstatic int calc_pan(struct snd_emux_voice *vp);\nstatic int calc_volume(struct snd_emux_voice *vp);\nstatic int calc_pitch(struct snd_emux_voice *vp);\n\n\n \nvoid\nsnd_emux_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)\n{\n\tstruct snd_emux *emu;\n\tint i, key, nvoices;\n\tstruct snd_emux_voice *vp;\n\tstruct snd_sf_zone *table[SNDRV_EMUX_MAX_MULTI_VOICES];\n\tunsigned long flags;\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.get_voice || !emu->ops.trigger))\n\t\treturn;\n\n\tkey = note;  \n\tnvoices = get_zone(emu, port, &note, vel, chan, table);\n\tif (! nvoices)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < nvoices; i++) {\n\t\tstruct snd_sf_zone *zp = table[i];\n\t\tif (zp && zp->v.exclusiveClass)\n\t\t\texclusive_note_off(emu, port, zp->v.exclusiveClass);\n\t}\n\n#if 0 \n\t \n\tterminate_note1(emu, key, chan, 0);\n#endif\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < nvoices; i++) {\n\n\t\t \n\t\t \n\n\t\tif (table[i] == NULL)\n\t\t\tcontinue;\n\n\t\tvp = emu->ops.get_voice(emu, port);\n\t\tif (vp == NULL || vp->ch < 0)\n\t\t\tcontinue;\n\t\tif (STATE_IS_PLAYING(vp->state))\n\t\t\temu->ops.terminate(vp);\n\n\t\tvp->time = emu->use_time++;\n\t\tvp->chan = chan;\n\t\tvp->port = port;\n\t\tvp->key = key;\n\t\tvp->note = note;\n\t\tvp->velocity = vel;\n\t\tvp->zone = table[i];\n\t\tif (vp->zone->sample)\n\t\t\tvp->block = vp->zone->sample->block;\n\t\telse\n\t\t\tvp->block = NULL;\n\n\t\tsetup_voice(vp);\n\n\t\tvp->state = SNDRV_EMUX_ST_STANDBY;\n\t\tif (emu->ops.prepare) {\n\t\t\tvp->state = SNDRV_EMUX_ST_OFF;\n\t\t\tif (emu->ops.prepare(vp) >= 0)\n\t\t\t\tvp->state = SNDRV_EMUX_ST_STANDBY;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (vp->state == SNDRV_EMUX_ST_STANDBY &&\n\t\t    vp->chan == chan) {\n\t\t\temu->ops.trigger(vp);\n\t\t\tvp->state = SNDRV_EMUX_ST_ON;\n\t\t\tvp->ontime = jiffies;  \n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\tif (port->port_mode == SNDRV_EMUX_PORT_MODE_OSS_SYNTH) {\n\t\t \n\t\tstruct snd_emux_effect_table *fx = chan->private;\n\t\tif (fx) {\n\t\t\tfx->flag[EMUX_FX_SAMPLE_START] = 0;\n\t\t\tfx->flag[EMUX_FX_COARSE_SAMPLE_START] = 0;\n\t\t}\n\t}\n#endif\n}\n\n \nvoid\nsnd_emux_note_off(void *p, int note, int vel, struct snd_midi_channel *chan)\n{\n\tint ch;\n\tstruct snd_emux *emu;\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.release))\n\t\treturn;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (ch = 0; ch < emu->max_voices; ch++) {\n\t\tvp = &emu->voices[ch];\n\t\tif (STATE_IS_PLAYING(vp->state) &&\n\t\t    vp->chan == chan && vp->key == note) {\n\t\t\tvp->state = SNDRV_EMUX_ST_RELEASED;\n\t\t\tif (vp->ontime == jiffies) {\n\t\t\t\t \n\t\t\t\tvp->state = SNDRV_EMUX_ST_PENDING;\n\t\t\t\tif (! emu->timer_active) {\n\t\t\t\t\tmod_timer(&emu->tlist, jiffies + 1);\n\t\t\t\t\temu->timer_active = 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\t \n\t\t\t\temu->ops.release(vp);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n \nvoid snd_emux_timer_callback(struct timer_list *t)\n{\n\tstruct snd_emux *emu = from_timer(emu, t, tlist);\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\tint ch, do_again = 0;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (ch = 0; ch < emu->max_voices; ch++) {\n\t\tvp = &emu->voices[ch];\n\t\tif (vp->state == SNDRV_EMUX_ST_PENDING) {\n\t\t\tif (vp->ontime == jiffies)\n\t\t\t\tdo_again++;  \n\t\t\telse {\n\t\t\t\temu->ops.release(vp);\n\t\t\t\tvp->state = SNDRV_EMUX_ST_RELEASED;\n\t\t\t}\n\t\t}\n\t}\n\tif (do_again) {\n\t\tmod_timer(&emu->tlist, jiffies + 1);\n\t\temu->timer_active = 1;\n\t} else\n\t\temu->timer_active = 0;\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n \nvoid\nsnd_emux_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)\n{\n\tint ch;\n\tstruct snd_emux *emu;\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.update))\n\t\treturn;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (ch = 0; ch < emu->max_voices; ch++) {\n\t\tvp = &emu->voices[ch];\n\t\tif (vp->state == SNDRV_EMUX_ST_ON &&\n\t\t    vp->chan == chan && vp->key == note) {\n\t\t\tvp->velocity = vel;\n\t\t\tupdate_voice(emu, vp, SNDRV_EMUX_UPDATE_VOLUME);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n\n \nvoid\nsnd_emux_update_channel(struct snd_emux_port *port, struct snd_midi_channel *chan, int update)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_voice *vp;\n\tint i;\n\tunsigned long flags;\n\n\tif (! update)\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.update))\n\t\treturn;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (vp->chan == chan)\n\t\t\tupdate_voice(emu, vp, update);\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n \nvoid\nsnd_emux_update_port(struct snd_emux_port *port, int update)\n{\n\tstruct snd_emux *emu; \n\tstruct snd_emux_voice *vp;\n\tint i;\n\tunsigned long flags;\n\n\tif (! update)\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.update))\n\t\treturn;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (vp->port == port)\n\t\t\tupdate_voice(emu, vp, update);\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n\n \nvoid\nsnd_emux_control(void *p, int type, struct snd_midi_channel *chan)\n{\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\tswitch (type) {\n\tcase MIDI_CTL_MSB_MAIN_VOLUME:\n\tcase MIDI_CTL_MSB_EXPRESSION:\n\t\tsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_VOLUME);\n\t\tbreak;\n\t\t\n\tcase MIDI_CTL_MSB_PAN:\n\t\tsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PAN);\n\t\tbreak;\n\n\tcase MIDI_CTL_SOFT_PEDAL:\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\t\t \n\t\tif (chan->control[type] >= 64)\n\t\t\tsnd_emux_send_effect(port, chan, EMUX_FX_CUTOFF, -160,\n\t\t\t\t     EMUX_FX_FLAG_ADD);\n\t\telse\n\t\t\tsnd_emux_send_effect(port, chan, EMUX_FX_CUTOFF, 0,\n\t\t\t\t     EMUX_FX_FLAG_OFF);\n#endif\n\t\tbreak;\n\n\tcase MIDI_CTL_PITCHBEND:\n\t\tsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PITCH);\n\t\tbreak;\n\n\tcase MIDI_CTL_MSB_MODWHEEL:\n\tcase MIDI_CTL_CHAN_PRESSURE:\n\t\tsnd_emux_update_channel(port, chan,\n\t\t\t\t\tSNDRV_EMUX_UPDATE_FMMOD |\n\t\t\t\t\tSNDRV_EMUX_UPDATE_FM2FRQ2);\n\t\tbreak;\n\n\t}\n\n\tif (port->chset.midi_mode == SNDRV_MIDI_MODE_XG) {\n\t\tsnd_emux_xg_control(port, chan, type);\n\t}\n}\n\n\n \nstatic void\nterminate_note1(struct snd_emux *emu, int note, struct snd_midi_channel *chan, int free)\n{\n\tint  i;\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (STATE_IS_PLAYING(vp->state) && vp->chan == chan &&\n\t\t    vp->key == note)\n\t\t\tterminate_voice(emu, vp, free);\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n\n \nvoid\nsnd_emux_terminate_note(void *p, int note, struct snd_midi_channel *chan)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.terminate))\n\t\treturn;\n\n\tterminate_note1(emu, note, chan, 1);\n}\n\n\n \nvoid\nsnd_emux_terminate_all(struct snd_emux *emu)\n{\n\tint i;\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (STATE_IS_PLAYING(vp->state))\n\t\t\tterminate_voice(emu, vp, 0);\n\t\tif (vp->state == SNDRV_EMUX_ST_OFF) {\n\t\t\tif (emu->ops.free_voice)\n\t\t\t\temu->ops.free_voice(vp);\n\t\t\tif (emu->ops.reset)\n\t\t\t\temu->ops.reset(emu, i);\n\t\t}\n\t\tvp->time = 0;\n\t}\n\t \n\temu->use_time = 0;\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_emux_terminate_all);\n\n \nvoid\nsnd_emux_sounds_off_all(struct snd_emux_port *port)\n{\n\tint i;\n\tstruct snd_emux *emu;\n\tstruct snd_emux_voice *vp;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!port))\n\t\treturn;\n\temu = port->emu;\n\tif (snd_BUG_ON(!emu || !emu->ops.terminate))\n\t\treturn;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (STATE_IS_PLAYING(vp->state) &&\n\t\t    vp->port == port)\n\t\t\tterminate_voice(emu, vp, 0);\n\t\tif (vp->state == SNDRV_EMUX_ST_OFF) {\n\t\t\tif (emu->ops.free_voice)\n\t\t\t\temu->ops.free_voice(vp);\n\t\t\tif (emu->ops.reset)\n\t\t\t\temu->ops.reset(emu, i);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n\n \nstatic void\nexclusive_note_off(struct snd_emux *emu, struct snd_emux_port *port, int exclass)\n{\n\tstruct snd_emux_voice *vp;\n\tint  i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tif (STATE_IS_PLAYING(vp->state) && vp->port == port &&\n\t\t    vp->reg.exclusiveClass == exclass) {\n\t\t\tterminate_voice(emu, vp, 0);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n \nstatic void\nterminate_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int free)\n{\n\temu->ops.terminate(vp);\n\tvp->time = emu->use_time++;\n\tvp->chan = NULL;\n\tvp->port = NULL;\n\tvp->zone = NULL;\n\tvp->block = NULL;\n\tvp->state = SNDRV_EMUX_ST_OFF;\n\tif (free && emu->ops.free_voice)\n\t\temu->ops.free_voice(vp);\n}\n\n\n \nstatic void\nupdate_voice(struct snd_emux *emu, struct snd_emux_voice *vp, int update)\n{\n\tif (!STATE_IS_PLAYING(vp->state))\n\t\treturn;\n\n\tif (vp->chan == NULL || vp->port == NULL)\n\t\treturn;\n\tif (update & SNDRV_EMUX_UPDATE_VOLUME)\n\t\tcalc_volume(vp);\n\tif (update & SNDRV_EMUX_UPDATE_PITCH)\n\t\tcalc_pitch(vp);\n\tif (update & SNDRV_EMUX_UPDATE_PAN) {\n\t\tif (! calc_pan(vp) && (update == SNDRV_EMUX_UPDATE_PAN))\n\t\t\treturn;\n\t}\n\temu->ops.update(vp, update);\n}\n\n\n#if 0 \n \nstatic const unsigned short voltarget[16] = {\n\t0xEAC0, 0xE0C8, 0xD740, 0xCE20, 0xC560, 0xBD08, 0xB500, 0xAD58,\n\t0xA5F8, 0x9EF0, 0x9830, 0x91C0, 0x8B90, 0x85A8, 0x8000, 0x7A90\n};\n#endif\n\n#define LO_BYTE(v)\t((v) & 0xff)\n#define HI_BYTE(v)\t(((v) >> 8) & 0xff)\n\n \nstatic void\nsetup_voice(struct snd_emux_voice *vp)\n{\n\tstruct soundfont_voice_parm *parm;\n\tint pitch;\n\n\t \n\tvp->reg = vp->zone->v;\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\tsnd_emux_setup_effect(vp);\n#endif\n\n\t \n\tvp->apan = -1;\n\tvp->avol = -1;\n\tvp->apitch = -1;\n\n\tcalc_volume(vp);\n\tcalc_pitch(vp);\n\tcalc_pan(vp);\n\n\tparm = &vp->reg.parm;\n\n\t \n\tif (LO_BYTE(parm->modatkhld) >= 0x80 && parm->moddelay >= 0x8000) {\n\t\tparm->moddelay = 0xbfff;\n\t\tpitch = (HI_BYTE(parm->pefe) << 4) + vp->apitch;\n\t\tif (pitch > 0xffff)\n\t\t\tpitch = 0xffff;\n\t\t \n\t\tvp->ftarget = parm->cutoff + LO_BYTE(parm->pefe);\n\t\tLIMITVALUE(vp->ftarget, 0, 255);\n\t\tvp->ftarget <<= 8;\n\t} else {\n\t\tvp->ftarget = parm->cutoff;\n\t\tvp->ftarget <<= 8;\n\t\tpitch = vp->apitch;\n\t}\n\n\t \n\tif (pitch != 0xffff) {\n\t\tvp->ptarget = 1 << (pitch >> 12);\n\t\tif (pitch & 0x800) vp->ptarget += (vp->ptarget*0x102e)/0x2710;\n\t\tif (pitch & 0x400) vp->ptarget += (vp->ptarget*0x764)/0x2710;\n\t\tif (pitch & 0x200) vp->ptarget += (vp->ptarget*0x389)/0x2710;\n\t\tvp->ptarget += (vp->ptarget >> 1);\n\t\tif (vp->ptarget > 0xffff) vp->ptarget = 0xffff;\n\t} else\n\t\tvp->ptarget = 0xffff;\n\n\tif (LO_BYTE(parm->modatkhld) >= 0x80) {\n\t\tparm->modatkhld &= ~0xff;\n\t\tparm->modatkhld |= 0x7f;\n\t}\n\n\t \n\tvp->vtarget = 0;\n#if 0  \n\tif (LO_BYTE(parm->volatkhld) >= 0x80 && parm->voldelay >= 0x8000) {\n\t\tparm->voldelay = 0xbfff;\n\t\tvp->vtarget = voltarget[vp->avol % 0x10] >> (vp->avol >> 4);\n\t}\n#endif\n\n\tif (LO_BYTE(parm->volatkhld) >= 0x80) {\n\t\tparm->volatkhld &= ~0xff;\n\t\tparm->volatkhld |= 0x7f;\n\t}\n}\n\n \nstatic const unsigned char pan_volumes[256] = {\n0x00,0x03,0x06,0x09,0x0c,0x0f,0x12,0x14,0x17,0x1a,0x1d,0x20,0x22,0x25,0x28,0x2a,\n0x2d,0x30,0x32,0x35,0x37,0x3a,0x3c,0x3f,0x41,0x44,0x46,0x49,0x4b,0x4d,0x50,0x52,\n0x54,0x57,0x59,0x5b,0x5d,0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6f,0x71,0x73,0x75,\n0x77,0x79,0x7b,0x7c,0x7e,0x80,0x82,0x84,0x86,0x88,0x89,0x8b,0x8d,0x8f,0x90,0x92,\n0x94,0x96,0x97,0x99,0x9a,0x9c,0x9e,0x9f,0xa1,0xa2,0xa4,0xa5,0xa7,0xa8,0xaa,0xab,\n0xad,0xae,0xaf,0xb1,0xb2,0xb3,0xb5,0xb6,0xb7,0xb9,0xba,0xbb,0xbc,0xbe,0xbf,0xc0,\n0xc1,0xc2,0xc3,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,\n0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdc,0xdd,0xde,0xdf,\n0xdf,0xe0,0xe1,0xe2,0xe2,0xe3,0xe4,0xe4,0xe5,0xe6,0xe6,0xe7,0xe8,0xe8,0xe9,0xe9,\n0xea,0xeb,0xeb,0xec,0xec,0xed,0xed,0xee,0xee,0xef,0xef,0xf0,0xf0,0xf1,0xf1,0xf1,\n0xf2,0xf2,0xf3,0xf3,0xf3,0xf4,0xf4,0xf5,0xf5,0xf5,0xf6,0xf6,0xf6,0xf7,0xf7,0xf7,\n0xf7,0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xfa,0xfa,0xfa,0xfa,0xfb,0xfb,0xfb,\n0xfb,0xfb,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,\n0xfd,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,\n0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n};\n\nstatic int\ncalc_pan(struct snd_emux_voice *vp)\n{\n\tstruct snd_midi_channel *chan = vp->chan;\n\tint pan;\n\n\t \n\tif (vp->reg.fixpan > 0)\t \n\t\tpan = 255 - (int)vp->reg.fixpan * 2;\n\telse {\n\t\tpan = chan->control[MIDI_CTL_MSB_PAN] - 64;\n\t\tif (vp->reg.pan >= 0)  \n\t\t\tpan += vp->reg.pan - 64;\n\t\tpan = 127 - (int)pan * 2;\n\t}\n\tLIMITVALUE(pan, 0, 255);\n\n\tif (vp->emu->linear_panning) {\n\t\t \n\t\tif (pan != vp->apan) {\n\t\t\tvp->apan = pan;\n\t\t\tif (pan == 0)\n\t\t\t\tvp->aaux = 0xff;\n\t\t\telse\n\t\t\t\tvp->aaux = (-pan) & 0xff;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (vp->apan != (int)pan_volumes[pan]) {\n\t\t\tvp->apan = pan_volumes[pan];\n\t\t\tvp->aaux = pan_volumes[255 - pan];\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n\n \n\n \nstatic const unsigned char voltab1[128] = {\n   0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n   0x63, 0x2b, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22,\n   0x21, 0x20, 0x1f, 0x1e, 0x1e, 0x1d, 0x1c, 0x1b, 0x1b, 0x1a,\n   0x19, 0x19, 0x18, 0x17, 0x17, 0x16, 0x16, 0x15, 0x15, 0x14,\n   0x14, 0x13, 0x13, 0x13, 0x12, 0x12, 0x11, 0x11, 0x11, 0x10,\n   0x10, 0x10, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0e, 0x0d,\n   0x0d, 0x0d, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0b, 0x0b, 0x0b,\n   0x0b, 0x0a, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09, 0x09,\n   0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06,\n   0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x04,\n   0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,\n   0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,\n   0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char voltab2[128] = {\n   0x32, 0x31, 0x30, 0x2f, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x2a,\n   0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x24, 0x23, 0x22, 0x21,\n   0x21, 0x20, 0x1f, 0x1e, 0x1e, 0x1d, 0x1c, 0x1c, 0x1b, 0x1a,\n   0x1a, 0x19, 0x19, 0x18, 0x18, 0x17, 0x16, 0x16, 0x15, 0x15,\n   0x14, 0x14, 0x13, 0x13, 0x13, 0x12, 0x12, 0x11, 0x11, 0x10,\n   0x10, 0x10, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0d, 0x0d,\n   0x0d, 0x0c, 0x0c, 0x0c, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0a,\n   0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08,\n   0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06,\n   0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03,\n   0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01,\n   0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char expressiontab[128] = {\n   0x7f, 0x6c, 0x62, 0x5a, 0x54, 0x50, 0x4b, 0x48, 0x45, 0x42,\n   0x40, 0x3d, 0x3b, 0x39, 0x38, 0x36, 0x34, 0x33, 0x31, 0x30,\n   0x2f, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25,\n   0x24, 0x24, 0x23, 0x22, 0x21, 0x21, 0x20, 0x1f, 0x1e, 0x1e,\n   0x1d, 0x1d, 0x1c, 0x1b, 0x1b, 0x1a, 0x1a, 0x19, 0x18, 0x18,\n   0x17, 0x17, 0x16, 0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x13,\n   0x13, 0x12, 0x12, 0x11, 0x11, 0x11, 0x10, 0x10, 0x0f, 0x0f,\n   0x0f, 0x0e, 0x0e, 0x0e, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c, 0x0c,\n   0x0b, 0x0b, 0x0b, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09,\n   0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06,\n   0x06, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03,\n   0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01,\n   0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n \nstatic int\ncalc_volume(struct snd_emux_voice *vp)\n{\n\tint vol;\n\tint main_vol, expression_vol, master_vol;\n\tstruct snd_midi_channel *chan = vp->chan;\n\tstruct snd_emux_port *port = vp->port;\n\n\texpression_vol = chan->control[MIDI_CTL_MSB_EXPRESSION];\n\tLIMITMAX(vp->velocity, 127);\n\tLIMITVALUE(expression_vol, 0, 127);\n\tif (port->port_mode == SNDRV_EMUX_PORT_MODE_OSS_SYNTH) {\n\t\t \n\t\tmain_vol = chan->control[MIDI_CTL_MSB_MAIN_VOLUME];\n\t\tvol = (vp->velocity * main_vol * expression_vol) / (127*127);\n\t\tvol = vol * vp->reg.amplitude / 127;\n\n\t\tLIMITVALUE(vol, 0, 127);\n\n\t\t \n\t\tvol = snd_sf_vol_table[vol];\n\n\t} else {\n\t\tmain_vol = chan->control[MIDI_CTL_MSB_MAIN_VOLUME] * vp->reg.amplitude / 127;\n\t\tLIMITVALUE(main_vol, 0, 127);\n\n\t\tvol = voltab1[main_vol] + voltab2[vp->velocity];\n\t\tvol = (vol * 8) / 3;\n\t\tvol += vp->reg.attenuation;\n\t\tvol += ((0x100 - vol) * expressiontab[expression_vol])/128;\n\t}\n\n\tmaster_vol = port->chset.gs_master_volume;\n\tLIMITVALUE(master_vol, 0, 127);\n\tvol += snd_sf_vol_table[master_vol];\n\tvol += port->volume_atten;\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\tif (chan->private) {\n\t\tstruct snd_emux_effect_table *fx = chan->private;\n\t\tvol += fx->val[EMUX_FX_ATTEN];\n\t}\n#endif\n\n\tLIMITVALUE(vol, 0, 255);\n\tif (vp->avol == vol)\n\t\treturn 0;  \n\n\tvp->avol = vol;\n\tif (!SF_IS_DRUM_BANK(get_bank(port, chan))\n\t    && LO_BYTE(vp->reg.parm.volatkhld) < 0x7d) {\n\t\tint atten;\n\t\tif (vp->velocity < 70)\n\t\t\tatten = 70;\n\t\telse\n\t\t\tatten = vp->velocity;\n\t\tvp->acutoff = (atten * vp->reg.parm.cutoff + 0xa0) >> 7;\n\t} else {\n\t\tvp->acutoff = vp->reg.parm.cutoff;\n\t}\n\n\treturn 1;  \n}\n\n \n\nstatic int\ncalc_pitch(struct snd_emux_voice *vp)\n{\n\tstruct snd_midi_channel *chan = vp->chan;\n\tint offset;\n\n\t \n\tif (vp->reg.fixkey >= 0) {\n\t\toffset = (vp->reg.fixkey - vp->reg.root) * 4096 / 12;\n\t} else {\n\t\toffset = (vp->note - vp->reg.root) * 4096 / 12;\n\t}\n\toffset = (offset * vp->reg.scaleTuning) / 100;\n\toffset += vp->reg.tune * 4096 / 1200;\n\tif (chan->midi_pitchbend != 0) {\n\t\t \n\t\toffset += chan->midi_pitchbend * chan->gm_rpn_pitch_bend_range / 3072;\n\t}\n\n\t \n\t \n\toffset += chan->gm_rpn_coarse_tuning * 4096 / (12 * 128);\n\toffset += chan->gm_rpn_fine_tuning / 24;\n\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\t \n\tif (chan->private) {\n\t\tstruct snd_emux_effect_table *fx = chan->private;\n\t\tif (fx->flag[EMUX_FX_INIT_PITCH])\n\t\t\toffset += fx->val[EMUX_FX_INIT_PITCH];\n\t}\n#endif\n\n\t \n\toffset += 0xe000 + vp->reg.rate_offset;\n\tif (vp->emu->ops.get_pitch_shift)\n\t\toffset += vp->emu->ops.get_pitch_shift(vp->emu);\n\tLIMITVALUE(offset, 0, 0xffff);\n\tif (offset == vp->apitch)\n\t\treturn 0;  \n\tvp->apitch = offset;\n\treturn 1;  \n}\n\n \nstatic int\nget_bank(struct snd_emux_port *port, struct snd_midi_channel *chan)\n{\n\tint val;\n\n\tswitch (port->chset.midi_mode) {\n\tcase SNDRV_MIDI_MODE_XG:\n\t\tval = chan->control[MIDI_CTL_MSB_BANK];\n\t\tif (val == 127)\n\t\t\treturn 128;  \n\t\treturn chan->control[MIDI_CTL_LSB_BANK];\n\n\tcase SNDRV_MIDI_MODE_GS:\n\t\tif (chan->drum_channel)\n\t\t\treturn 128;\n\t\t \n\t\treturn chan->control[MIDI_CTL_MSB_BANK];\n\t\t\n\tdefault:\n\t\tif (chan->drum_channel)\n\t\t\treturn 128;\n\t\treturn chan->control[MIDI_CTL_MSB_BANK];\n\t}\n}\n\n\n \nstatic int\nget_zone(struct snd_emux *emu, struct snd_emux_port *port,\n\t int *notep, int vel, struct snd_midi_channel *chan,\n\t struct snd_sf_zone **table)\n{\n\tint preset, bank, def_preset, def_bank;\n\n\tbank = get_bank(port, chan);\n\tpreset = chan->midi_program;\n\n\tif (SF_IS_DRUM_BANK(bank)) {\n\t\tdef_preset = port->ctrls[EMUX_MD_DEF_DRUM];\n\t\tdef_bank = bank;\n\t} else {\n\t\tdef_preset = preset;\n\t\tdef_bank = port->ctrls[EMUX_MD_DEF_BANK];\n\t}\n\n\treturn snd_soundfont_search_zone(emu->sflist, notep, vel, preset, bank,\n\t\t\t\t\t def_preset, def_bank,\n\t\t\t\t\t table, SNDRV_EMUX_MAX_MULTI_VOICES);\n}\n\n \nvoid\nsnd_emux_init_voices(struct snd_emux *emu)\n{\n\tstruct snd_emux_voice *vp;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tvp = &emu->voices[i];\n\t\tvp->ch = -1;  \n\t\tvp->state = SNDRV_EMUX_ST_OFF;\n\t\tvp->chan = NULL;\n\t\tvp->port = NULL;\n\t\tvp->time = 0;\n\t\tvp->emu = emu;\n\t\tvp->hw = emu->hw;\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\n \nvoid snd_emux_lock_voice(struct snd_emux *emu, int voice)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tif (emu->voices[voice].state == SNDRV_EMUX_ST_OFF)\n\t\temu->voices[voice].state = SNDRV_EMUX_ST_LOCKED;\n\telse\n\t\tsnd_printk(KERN_WARNING\n\t\t\t   \"invalid voice for lock %d (state = %x)\\n\",\n\t\t\t   voice, emu->voices[voice].state);\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_emux_lock_voice);\n\n \nvoid snd_emux_unlock_voice(struct snd_emux *emu, int voice)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tif (emu->voices[voice].state == SNDRV_EMUX_ST_LOCKED)\n\t\temu->voices[voice].state = SNDRV_EMUX_ST_OFF;\n\telse\n\t\tsnd_printk(KERN_WARNING\n\t\t\t   \"invalid voice for unlock %d (state = %x)\\n\",\n\t\t\t   voice, emu->voices[voice].state);\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_emux_unlock_voice);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}