{
  "module_name": "emux_oss.c",
  "hash_id": "718dad0a3bfd7976c1023cc94010e12e828a924873e94cd928076fb1b101734b",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_oss.c",
  "human_readable_source": "\n \n\n\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <sound/core.h>\n#include \"emux_voice.h\"\n#include <sound/asoundef.h>\n\nstatic int snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure);\nstatic int snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg);\nstatic int snd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd,\n\t\t\t\t  unsigned long ioarg);\nstatic int snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,\n\t\t\t\t       const char __user *buf, int offs, int count);\nstatic int snd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg);\nstatic int snd_emux_event_oss_input(struct snd_seq_event *ev, int direct,\n\t\t\t\t    void *private, int atomic, int hop);\nstatic void reset_port_mode(struct snd_emux_port *port, int midi_mode);\nstatic void emuspec_control(struct snd_emux *emu, struct snd_emux_port *port,\n\t\t\t    int cmd, unsigned char *event, int atomic, int hop);\nstatic void gusspec_control(struct snd_emux *emu, struct snd_emux_port *port,\n\t\t\t    int cmd, unsigned char *event, int atomic, int hop);\nstatic void fake_event(struct snd_emux *emu, struct snd_emux_port *port,\n\t\t       int ch, int param, int val, int atomic, int hop);\n\n \nstatic const struct snd_seq_oss_callback oss_callback = {\n\t.owner = THIS_MODULE,\n\t.open = snd_emux_open_seq_oss,\n\t.close = snd_emux_close_seq_oss,\n\t.ioctl = snd_emux_ioctl_seq_oss,\n\t.load_patch = snd_emux_load_patch_seq_oss,\n\t.reset = snd_emux_reset_seq_oss,\n};\n\n\n \n\nvoid\nsnd_emux_init_seq_oss(struct snd_emux *emu)\n{\n\tstruct snd_seq_oss_reg *arg;\n\tstruct snd_seq_device *dev;\n\n\t \n\tif (snd_seq_device_new(emu->card, 1, SNDRV_SEQ_DEV_ID_OSS,\n\t\t\t       sizeof(struct snd_seq_oss_reg), &dev) < 0)\n\t\treturn;\n\n\temu->oss_synth = dev;\n\tstrcpy(dev->name, emu->name);\n\targ = SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\targ->type = SYNTH_TYPE_SAMPLE;\n\targ->subtype = SAMPLE_TYPE_AWE32;\n\targ->nvoices = emu->max_voices;\n\targ->oper = oss_callback;\n\targ->private_data = emu;\n\n\t \n\tsnd_device_register(emu->card, dev);\n}\n\n\n \nvoid\nsnd_emux_detach_seq_oss(struct snd_emux *emu)\n{\n\tif (emu->oss_synth) {\n\t\tsnd_device_free(emu->card, emu->oss_synth);\n\t\temu->oss_synth = NULL;\n\t}\n}\n\n\n \n#define SF_CLIENT_NO(p)\t((p) + 0x1000)\n\n \nstatic int\nsnd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_port *p;\n\tstruct snd_seq_port_callback callback;\n\tchar tmpname[64];\n\n\temu = closure;\n\tif (snd_BUG_ON(!arg || !emu))\n\t\treturn -ENXIO;\n\n\tif (!snd_emux_inc_count(emu))\n\t\treturn -EFAULT;\n\n\tmemset(&callback, 0, sizeof(callback));\n\tcallback.owner = THIS_MODULE;\n\tcallback.event_input = snd_emux_event_oss_input;\n\n\tsprintf(tmpname, \"%s OSS Port\", emu->name);\n\tp = snd_emux_create_port(emu, tmpname, 32,\n\t\t\t\t 1, &callback);\n\tif (p == NULL) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tsnd_emux_dec_count(emu);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\targ->private_data = p;\n\targ->addr.client = p->chset.client;\n\targ->addr.port = p->chset.port;\n\tp->oss_arg = arg;\n\n\treset_port_mode(p, arg->seq_mode);\n\n\tsnd_emux_reset_port(p);\n\treturn 0;\n}\n\n\n#define DEFAULT_DRUM_FLAGS\t((1<<9) | (1<<25))\n\n \nstatic void\nreset_port_mode(struct snd_emux_port *port, int midi_mode)\n{\n\tif (midi_mode) {\n\t\tport->port_mode = SNDRV_EMUX_PORT_MODE_OSS_MIDI;\n\t\tport->drum_flags = DEFAULT_DRUM_FLAGS;\n\t\tport->volume_atten = 0;\n\t\tport->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_KEYPRESS;\n\t} else {\n\t\tport->port_mode = SNDRV_EMUX_PORT_MODE_OSS_SYNTH;\n\t\tport->drum_flags = 0;\n\t\tport->volume_atten = 32;\n\t\tport->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;\n\t}\n}\n\n\n \nstatic int\nsnd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_port *p;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\tp = arg->private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -ENXIO;\n\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\n\tsnd_emux_sounds_off_all(p);\n\tsnd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));\n\tsnd_seq_event_port_detach(p->chset.client, p->chset.port);\n\tsnd_emux_dec_count(emu);\n\n\treturn 0;\n}\n\n\n \nstatic int\nsnd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,\n\t\t\t    const char __user *buf, int offs, int count)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_port *p;\n\tint rc;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\tp = arg->private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -ENXIO;\n\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\n\tif (format == GUS_PATCH)\n\t\trc = snd_soundfont_load_guspatch(emu->sflist, buf, count,\n\t\t\t\t\t\t SF_CLIENT_NO(p->chset.port));\n\telse if (format == SNDRV_OSS_SOUNDFONT_PATCH) {\n\t\tstruct soundfont_patch_info patch;\n\t\tif (count < (int)sizeof(patch))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&patch, buf, sizeof(patch)))\n\t\t\treturn -EFAULT;\n\t\tif (patch.type >= SNDRV_SFNT_LOAD_INFO &&\n\t\t    patch.type <= SNDRV_SFNT_PROBE_DATA)\n\t\t\trc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));\n\t\telse {\n\t\t\tif (emu->ops.load_fx)\n\t\t\t\trc = emu->ops.load_fx(emu, patch.type, patch.optarg, buf, count);\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t}\n\t} else\n\t\trc = 0;\n\treturn rc;\n}\n\n\n \nstatic int\nsnd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd, unsigned long ioarg)\n{\n\tstruct snd_emux_port *p;\n\tstruct snd_emux *emu;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\tp = arg->private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -ENXIO;\n\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\n\tswitch (cmd) {\n\tcase SNDCTL_SEQ_RESETSAMPLES:\n\t\tsnd_soundfont_remove_samples(emu->sflist);\n\t\treturn 0;\n\t\t\t\n\tcase SNDCTL_SYNTH_MEMAVL:\n\t\tif (emu->memhdr)\n\t\t\treturn snd_util_mem_avail(emu->memhdr);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nsnd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg)\n{\n\tstruct snd_emux_port *p;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\tp = arg->private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -ENXIO;\n\tsnd_emux_reset_port(p);\n\treturn 0;\n}\n\n\n \nstatic int\nsnd_emux_event_oss_input(struct snd_seq_event *ev, int direct, void *private_data,\n\t\t\t int atomic, int hop)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_port *p;\n\tunsigned char cmd, *data;\n\n\tp = private_data;\n\tif (snd_BUG_ON(!p))\n\t\treturn -EINVAL;\n\temu = p->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -EINVAL;\n\tif (ev->type != SNDRV_SEQ_EVENT_OSS)\n\t\treturn snd_emux_event_input(ev, direct, private_data, atomic, hop);\n\n\tdata = ev->data.raw8.d;\n\t \n\tif (data[0] != 0xfe)\n\t\treturn 0;\n\tcmd = data[2] & _EMUX_OSS_MODE_VALUE_MASK;\n\tif (data[2] & _EMUX_OSS_MODE_FLAG)\n\t\temuspec_control(emu, p, cmd, data, atomic, hop);\n\telse\n\t\tgusspec_control(emu, p, cmd, data, atomic, hop);\n\treturn 0;\n}\n\n\n \nstatic void\nemuspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,\n\t\tunsigned char *event, int atomic, int hop)\n{\n\tint voice;\n\tunsigned short p1;\n\tshort p2;\n\tint i;\n\tstruct snd_midi_channel *chan;\n\n\tvoice = event[3];\n\tif (voice < 0 || voice >= port->chset.max_channels)\n\t\tchan = NULL;\n\telse\n\t\tchan = &port->chset.channels[voice];\n\n\tp1 = *(unsigned short *) &event[4];\n\tp2 = *(short *) &event[6];\n\n\tswitch (cmd) {\n#if 0  \n\tcase _EMUX_OSS_REMOVE_LAST_SAMPLES:\n\t\tsnd_soundfont_remove_unlocked(emu->sflist);\n\t\tbreak;\n#endif\n\tcase _EMUX_OSS_SEND_EFFECT:\n\t\tif (chan)\n\t\t\tsnd_emux_send_effect_oss(port, chan, p1, p2);\n\t\tbreak;\n\t\t\n\tcase _EMUX_OSS_TERMINATE_ALL:\n\t\tsnd_emux_terminate_all(emu);\n\t\tbreak;\n\n\tcase _EMUX_OSS_TERMINATE_CHANNEL:\n\t\t \n\t\tbreak;\n\tcase _EMUX_OSS_RESET_CHANNEL:\n\t\t \n\t\tbreak;\n\n\tcase _EMUX_OSS_RELEASE_ALL:\n\t\tfake_event(emu, port, voice, MIDI_CTL_ALL_NOTES_OFF, 0, atomic, hop);\n\t\tbreak;\n\tcase _EMUX_OSS_NOTEOFF_ALL:\n\t\tfake_event(emu, port, voice, MIDI_CTL_ALL_SOUNDS_OFF, 0, atomic, hop);\n\t\tbreak;\n\n\tcase _EMUX_OSS_INITIAL_VOLUME:\n\t\tif (p2) {\n\t\t\tport->volume_atten = (short)p1;\n\t\t\tsnd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);\n\t\t}\n\t\tbreak;\n\n\tcase _EMUX_OSS_CHN_PRESSURE:\n\t\tif (chan) {\n\t\t\tchan->midi_pressure = p1;\n\t\t\tsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_FMMOD|SNDRV_EMUX_UPDATE_FM2FRQ2);\n\t\t}\n\t\tbreak;\n\n\tcase _EMUX_OSS_CHANNEL_MODE:\n\t\treset_port_mode(port, p1);\n\t\tsnd_emux_reset_port(port);\n\t\tbreak;\n\n\tcase _EMUX_OSS_DRUM_CHANNELS:\n\t\tport->drum_flags = *(unsigned int*)&event[4];\n\t\tfor (i = 0; i < port->chset.max_channels; i++) {\n\t\t\tchan = &port->chset.channels[i];\n\t\t\tchan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;\n\t\t}\n\t\tbreak;\n\n\tcase _EMUX_OSS_MISC_MODE:\n\t\tif (p1 < EMUX_MD_END)\n\t\t\tport->ctrls[p1] = p2;\n\t\tbreak;\n\tcase _EMUX_OSS_DEBUG_MODE:\n\t\tbreak;\n\n\tdefault:\n\t\tif (emu->ops.oss_ioctl)\n\t\t\temu->ops.oss_ioctl(emu, cmd, p1, p2);\n\t\tbreak;\n\t}\n}\n\n \n\n#include <linux/ultrasound.h>\n\nstatic void\ngusspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,\n\t\tunsigned char *event, int atomic, int hop)\n{\n\tint voice;\n\tunsigned short p1;\n\tint plong;\n\tstruct snd_midi_channel *chan;\n\n\tif (port->port_mode != SNDRV_EMUX_PORT_MODE_OSS_SYNTH)\n\t\treturn;\n\tif (cmd == _GUS_NUMVOICES)\n\t\treturn;\n\tvoice = event[3];\n\tif (voice < 0 || voice >= port->chset.max_channels)\n\t\treturn;\n\n\tchan = &port->chset.channels[voice];\n\n\tp1 = *(unsigned short *) &event[4];\n\tplong = *(int*) &event[4];\n\n\tswitch (cmd) {\n\tcase _GUS_VOICESAMPLE:\n\t\tchan->midi_program = p1;\n\t\treturn;\n\n\tcase _GUS_VOICEBALA:\n\t\t \n\t\tchan->control[MIDI_CTL_MSB_PAN] = (int)p1 << 3;\n\t\tsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PAN);\n\t\treturn;\n\n\tcase _GUS_VOICEVOL:\n\tcase _GUS_VOICEVOL2:\n\t\t \n\t\treturn;\n\n\tcase _GUS_RAMPRANGE:\n\tcase _GUS_RAMPRATE:\n\tcase _GUS_RAMPMODE:\n\tcase _GUS_RAMPON:\n\tcase _GUS_RAMPOFF:\n\t\t \n\t\treturn;\n\n\tcase _GUS_VOLUME_SCALE:\n\t\treturn;\n\n\tcase _GUS_VOICE_POS:\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\n\t\tsnd_emux_send_effect(port, chan, EMUX_FX_SAMPLE_START,\n\t\t\t\t     (short)(plong & 0x7fff),\n\t\t\t\t     EMUX_FX_FLAG_SET);\n\t\tsnd_emux_send_effect(port, chan, EMUX_FX_COARSE_SAMPLE_START,\n\t\t\t\t     (plong >> 15) & 0xffff,\n\t\t\t\t     EMUX_FX_FLAG_SET);\n#endif\n\t\treturn;\n\t}\n}\n\n\n \nstatic void\nfake_event(struct snd_emux *emu, struct snd_emux_port *port, int ch, int param, int val, int atomic, int hop)\n{\n\tstruct snd_seq_event ev;\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = SNDRV_SEQ_EVENT_CONTROLLER;\n\tev.data.control.channel = ch;\n\tev.data.control.param = param;\n\tev.data.control.value = val;\n\tsnd_emux_event_input(&ev, 0, port, atomic, hop);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}