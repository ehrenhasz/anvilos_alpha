{
  "module_name": "emux_hwdep.c",
  "hash_id": "70aa78a8af4f41a142b471db268a0690070f92114b3bf7a8485054dc17e06b46",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_hwdep.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/hwdep.h>\n#include <linux/uaccess.h>\n#include <linux/nospec.h>\n#include \"emux_voice.h\"\n\n#define TMP_CLIENT_ID\t0x1001\n\n \nstatic int\nsnd_emux_hwdep_load_patch(struct snd_emux *emu, void __user *arg)\n{\n\tint err;\n\tstruct soundfont_patch_info patch;\n\n\tif (copy_from_user(&patch, arg, sizeof(patch)))\n\t\treturn -EFAULT;\n\n\tif (patch.key == GUS_PATCH)\n\t\treturn snd_soundfont_load_guspatch(emu->sflist, arg,\n\t\t\t\t\t\t   patch.len + sizeof(patch),\n\t\t\t\t\t\t   TMP_CLIENT_ID);\n\n\tif (patch.type >= SNDRV_SFNT_LOAD_INFO &&\n\t    patch.type <= SNDRV_SFNT_PROBE_DATA) {\n\t\terr = snd_soundfont_load(emu->sflist, arg, patch.len + sizeof(patch), TMP_CLIENT_ID);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tif (emu->ops.load_fx)\n\t\t\treturn emu->ops.load_fx(emu, patch.type, patch.optarg, arg, patch.len + sizeof(patch));\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nsnd_emux_hwdep_misc_mode(struct snd_emux *emu, void __user *arg)\n{\n\tstruct snd_emux_misc_mode info;\n\tint i;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.mode < 0 || info.mode >= EMUX_MD_END)\n\t\treturn -EINVAL;\n\tinfo.mode = array_index_nospec(info.mode, EMUX_MD_END);\n\n\tif (info.port < 0) {\n\t\tfor (i = 0; i < emu->num_ports; i++)\n\t\t\temu->portptrs[i]->ctrls[info.mode] = info.value;\n\t} else {\n\t\tif (info.port < emu->num_ports) {\n\t\t\tinfo.port = array_index_nospec(info.port, emu->num_ports);\n\t\t\temu->portptrs[info.port]->ctrls[info.mode] = info.value;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic int\nsnd_emux_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,\n\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_emux *emu = hw->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_EMUX_IOCTL_VERSION:\n\t\treturn put_user(SNDRV_EMUX_VERSION, (unsigned int __user *)arg);\n\tcase SNDRV_EMUX_IOCTL_LOAD_PATCH:\n\t\treturn snd_emux_hwdep_load_patch(emu, (void __user *)arg);\n\tcase SNDRV_EMUX_IOCTL_RESET_SAMPLES:\n\t\tsnd_soundfont_remove_samples(emu->sflist);\n\t\tbreak;\n\tcase SNDRV_EMUX_IOCTL_REMOVE_LAST_SAMPLES:\n\t\tsnd_soundfont_remove_unlocked(emu->sflist);\n\t\tbreak;\n\tcase SNDRV_EMUX_IOCTL_MEM_AVAIL:\n\t\tif (emu->memhdr) {\n\t\t\tint size = snd_util_mem_avail(emu->memhdr);\n\t\t\treturn put_user(size, (unsigned int __user *)arg);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_EMUX_IOCTL_MISC_MODE:\n\t\treturn snd_emux_hwdep_misc_mode(emu, (void __user *)arg);\n\t}\n\n\treturn 0;\n}\n\n\n \n\nint\nsnd_emux_init_hwdep(struct snd_emux *emu)\n{\n\tstruct snd_hwdep *hw;\n\tint err;\n\n\terr = snd_hwdep_new(emu->card, SNDRV_EMUX_HWDEP_NAME, emu->hwdep_idx, &hw);\n\tif (err < 0)\n\t\treturn err;\n\temu->hwdep = hw;\n\tstrcpy(hw->name, SNDRV_EMUX_HWDEP_NAME);\n\thw->iface = SNDRV_HWDEP_IFACE_EMUX_WAVETABLE;\n\thw->ops.ioctl = snd_emux_hwdep_ioctl;\n\t \n\thw->ops.ioctl_compat = snd_emux_hwdep_ioctl;\n\thw->exclusive = 1;\n\thw->private_data = emu;\n\terr = snd_card_register(emu->card);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n \nvoid\nsnd_emux_delete_hwdep(struct snd_emux *emu)\n{\n\tif (emu->hwdep) {\n\t\tsnd_device_free(emu->card, emu->hwdep);\n\t\temu->hwdep = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}