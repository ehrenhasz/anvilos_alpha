{
  "module_name": "emux_nrpn.c",
  "hash_id": "7a9aa410fe5b70abc044960affc65c640bffda96041e50a500e1a453985fcc40",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/emux/emux_nrpn.c",
  "human_readable_source": "\n \n\n#include \"emux_voice.h\"\n#include <sound/asoundef.h>\n\n \n\n \nstruct nrpn_conv_table {\n\tint control;\n\tint effect;\n\tint (*convert)(int val);\n};\n\n \n\n#define FX_CUTOFF\t0\n#define FX_RESONANCE\t1\n#define FX_ATTACK\t2\n#define FX_RELEASE\t3\n#define FX_VIBRATE\t4\n#define FX_VIBDEPTH\t5\n#define FX_VIBDELAY\t6\n#define FX_NUMS\t\t7\n\n \n\nstatic int send_converted_effect(const struct nrpn_conv_table *table,\n\t\t\t\t int num_tables,\n\t\t\t\t struct snd_emux_port *port,\n\t\t\t\t struct snd_midi_channel *chan,\n\t\t\t\t int type, int val, int mode)\n{\n\tint i, cval;\n\tfor (i = 0; i < num_tables; i++) {\n\t\tif (table[i].control == type) {\n\t\t\tcval = table[i].convert(val);\n\t\t\tsnd_emux_send_effect(port, chan, table[i].effect,\n\t\t\t\t\t     cval, mode);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define DEF_FX_CUTOFF\t\t170\n#define DEF_FX_RESONANCE\t6\n#define DEF_FX_ATTACK\t\t50\n#define DEF_FX_RELEASE\t\t50\n#define DEF_FX_VIBRATE\t\t30\n#define DEF_FX_VIBDEPTH\t\t4\n#define DEF_FX_VIBDELAY\t\t1500\n\n \nstatic const int gs_sense[] =\n{\n\tDEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,\n\tDEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY\n};\n\n \nstatic const int xg_sense[] =\n{\n\tDEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,\n\tDEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY\n};\n\n\n \n\nstatic int fx_delay(int val);\nstatic int fx_attack(int val);\nstatic int fx_hold(int val);\nstatic int fx_decay(int val);\nstatic int fx_the_value(int val);\nstatic int fx_twice_value(int val);\nstatic int fx_conv_pitch(int val);\nstatic int fx_conv_Q(int val);\n\n \t\t \n#define fx_env1_delay\tfx_delay\t \n#define fx_env1_attack\tfx_attack\t \n#define fx_env1_hold\tfx_hold\t\t \n#define fx_env1_decay\tfx_decay\t \n#define fx_env1_release\tfx_decay\t \n#define fx_env1_sustain\tfx_the_value\t \n#define fx_env1_pitch\tfx_the_value\t \n#define fx_env1_cutoff\tfx_the_value\t \n\n#define fx_env2_delay\tfx_delay\t \n#define fx_env2_attack\tfx_attack\t \n#define fx_env2_hold\tfx_hold\t\t \n#define fx_env2_decay\tfx_decay\t \n#define fx_env2_release\tfx_decay\t \n#define fx_env2_sustain\tfx_the_value\t \n\n#define fx_lfo1_delay\tfx_delay\t \n#define fx_lfo1_freq\tfx_twice_value\t \n#define fx_lfo1_volume\tfx_twice_value\t \n#define fx_lfo1_pitch\tfx_the_value\t \n#define fx_lfo1_cutoff\tfx_twice_value\t \n\n#define fx_lfo2_delay\tfx_delay\t \n#define fx_lfo2_freq\tfx_twice_value\t \n#define fx_lfo2_pitch\tfx_the_value\t \n\n#define fx_init_pitch\tfx_conv_pitch\t \n#define fx_chorus\tfx_the_value\t \n#define fx_reverb\tfx_the_value\t \n#define fx_cutoff\tfx_twice_value\t \n#define fx_filterQ\tfx_conv_Q\t \n\nstatic int fx_delay(int val)\n{\n\treturn (unsigned short)snd_sf_calc_parm_delay(val);\n}\n\nstatic int fx_attack(int val)\n{\n\treturn (unsigned short)snd_sf_calc_parm_attack(val);\n}\n\nstatic int fx_hold(int val)\n{\n\treturn (unsigned short)snd_sf_calc_parm_hold(val);\n}\n\nstatic int fx_decay(int val)\n{\n\treturn (unsigned short)snd_sf_calc_parm_decay(val);\n}\n\nstatic int fx_the_value(int val)\n{\n\treturn (unsigned short)(val & 0xff);\n}\n\nstatic int fx_twice_value(int val)\n{\n\treturn (unsigned short)((val * 2) & 0xff);\n}\n\nstatic int fx_conv_pitch(int val)\n{\n\treturn (short)(val * 4096 / 1200);\n}\n\nstatic int fx_conv_Q(int val)\n{\n\treturn (unsigned short)((val / 8) & 0xff);\n}\n\n\nstatic const struct nrpn_conv_table awe_effects[] =\n{\n\t{ 0, EMUX_FX_LFO1_DELAY,\tfx_lfo1_delay},\n\t{ 1, EMUX_FX_LFO1_FREQ,\tfx_lfo1_freq},\n\t{ 2, EMUX_FX_LFO2_DELAY,\tfx_lfo2_delay},\n\t{ 3, EMUX_FX_LFO2_FREQ,\tfx_lfo2_freq},\n\n\t{ 4, EMUX_FX_ENV1_DELAY,\tfx_env1_delay},\n\t{ 5, EMUX_FX_ENV1_ATTACK,fx_env1_attack},\n\t{ 6, EMUX_FX_ENV1_HOLD,\tfx_env1_hold},\n\t{ 7, EMUX_FX_ENV1_DECAY,\tfx_env1_decay},\n\t{ 8, EMUX_FX_ENV1_SUSTAIN,\tfx_env1_sustain},\n\t{ 9, EMUX_FX_ENV1_RELEASE,\tfx_env1_release},\n\n\t{10, EMUX_FX_ENV2_DELAY,\tfx_env2_delay},\n\t{11, EMUX_FX_ENV2_ATTACK,\tfx_env2_attack},\n\t{12, EMUX_FX_ENV2_HOLD,\tfx_env2_hold},\n\t{13, EMUX_FX_ENV2_DECAY,\tfx_env2_decay},\n\t{14, EMUX_FX_ENV2_SUSTAIN,\tfx_env2_sustain},\n\t{15, EMUX_FX_ENV2_RELEASE,\tfx_env2_release},\n\n\t{16, EMUX_FX_INIT_PITCH,\tfx_init_pitch},\n\t{17, EMUX_FX_LFO1_PITCH,\tfx_lfo1_pitch},\n\t{18, EMUX_FX_LFO2_PITCH,\tfx_lfo2_pitch},\n\t{19, EMUX_FX_ENV1_PITCH,\tfx_env1_pitch},\n\t{20, EMUX_FX_LFO1_VOLUME,\tfx_lfo1_volume},\n\t{21, EMUX_FX_CUTOFF,\t\tfx_cutoff},\n\t{22, EMUX_FX_FILTERQ,\tfx_filterQ},\n\t{23, EMUX_FX_LFO1_CUTOFF,\tfx_lfo1_cutoff},\n\t{24, EMUX_FX_ENV1_CUTOFF,\tfx_env1_cutoff},\n\t{25, EMUX_FX_CHORUS,\t\tfx_chorus},\n\t{26, EMUX_FX_REVERB,\t\tfx_reverb},\n};\n\n\n \n\n \nstatic int gs_cutoff(int val)\n{\n\treturn (val - 64) * gs_sense[FX_CUTOFF] / 50;\n}\n\n \nstatic int gs_filterQ(int val)\n{\n\treturn (val - 64) * gs_sense[FX_RESONANCE] / 50;\n}\n\n \nstatic int gs_attack(int val)\n{\n\treturn -(val - 64) * gs_sense[FX_ATTACK] / 50;\n}\n\n \nstatic int gs_decay(int val)\n{\n\treturn -(val - 64) * gs_sense[FX_RELEASE] / 50;\n}\n\n \nstatic int gs_release(int val)\n{\n\treturn -(val - 64) * gs_sense[FX_RELEASE] / 50;\n}\n\n \nstatic int gs_vib_rate(int val)\n{\n\treturn (val - 64) * gs_sense[FX_VIBRATE] / 50;\n}\n\n \nstatic int gs_vib_depth(int val)\n{\n\treturn (val - 64) * gs_sense[FX_VIBDEPTH] / 50;\n}\n\n \nstatic int gs_vib_delay(int val)\n{\n\treturn -(val - 64) * gs_sense[FX_VIBDELAY] / 50;\n}\n\nstatic const struct nrpn_conv_table gs_effects[] =\n{\n\t{32, EMUX_FX_CUTOFF,\tgs_cutoff},\n\t{33, EMUX_FX_FILTERQ,\tgs_filterQ},\n\t{99, EMUX_FX_ENV2_ATTACK, gs_attack},\n\t{100, EMUX_FX_ENV2_DECAY, gs_decay},\n\t{102, EMUX_FX_ENV2_RELEASE, gs_release},\n\t{8, EMUX_FX_LFO1_FREQ, gs_vib_rate},\n\t{9, EMUX_FX_LFO1_VOLUME, gs_vib_depth},\n\t{10, EMUX_FX_LFO1_DELAY, gs_vib_delay},\n};\n\n\n \nvoid\nsnd_emux_nrpn(void *p, struct snd_midi_channel *chan,\n\t      struct snd_midi_channel_set *chset)\n{\n\tstruct snd_emux_port *port;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chan))\n\t\treturn;\n\n\tif (chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 127 &&\n\t    chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB] <= 26) {\n\t\tint val;\n\t\t \n\t\t \n\t\tval = (chan->control[MIDI_CTL_MSB_DATA_ENTRY] << 7) |\n\t\t\tchan->control[MIDI_CTL_LSB_DATA_ENTRY]; \n\t\tval -= 8192;\n\t\tsend_converted_effect\n\t\t\t(awe_effects, ARRAY_SIZE(awe_effects),\n\t\t\t port, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],\n\t\t\t val, EMUX_FX_FLAG_SET);\n\t\treturn;\n\t}\n\n\tif (port->chset.midi_mode == SNDRV_MIDI_MODE_GS &&\n\t    chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 1) {\n\t\tint val;\n\t\t \n\t\t \n\t\tval = chan->control[MIDI_CTL_MSB_DATA_ENTRY];\n\t\tsend_converted_effect\n\t\t\t(gs_effects, ARRAY_SIZE(gs_effects),\n\t\t\t port, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],\n\t\t\t val, EMUX_FX_FLAG_ADD);\n\t\treturn;\n\t}\n}\n\n\n \n\n \nstatic int xg_cutoff(int val)\n{\n\treturn (val - 64) * xg_sense[FX_CUTOFF] / 64;\n}\n\n \nstatic int xg_filterQ(int val)\n{\n\treturn (val - 64) * xg_sense[FX_RESONANCE] / 64;\n}\n\n \nstatic int xg_attack(int val)\n{\n\treturn -(val - 64) * xg_sense[FX_ATTACK] / 64;\n}\n\n \nstatic int xg_release(int val)\n{\n\treturn -(val - 64) * xg_sense[FX_RELEASE] / 64;\n}\n\nstatic const struct nrpn_conv_table xg_effects[] =\n{\n\t{71, EMUX_FX_CUTOFF,\txg_cutoff},\n\t{74, EMUX_FX_FILTERQ,\txg_filterQ},\n\t{72, EMUX_FX_ENV2_RELEASE, xg_release},\n\t{73, EMUX_FX_ENV2_ATTACK, xg_attack},\n};\n\nint\nsnd_emux_xg_control(struct snd_emux_port *port, struct snd_midi_channel *chan,\n\t\t    int param)\n{\n\tif (param >= ARRAY_SIZE(chan->control))\n\t\treturn -EINVAL;\n\n\treturn send_converted_effect(xg_effects, ARRAY_SIZE(xg_effects),\n\t\t\t\t     port, chan, param,\n\t\t\t\t     chan->control[param],\n\t\t\t\t     EMUX_FX_FLAG_ADD);\n}\n\n \nvoid\nsnd_emux_sysex(void *p, unsigned char *buf, int len, int parsed,\n\t       struct snd_midi_channel_set *chset)\n{\n\tstruct snd_emux_port *port;\n\tstruct snd_emux *emu;\n\n\tport = p;\n\tif (snd_BUG_ON(!port || !chset))\n\t\treturn;\n\temu = port->emu;\n\n\tswitch (parsed) {\n\tcase SNDRV_MIDI_SYSEX_GS_MASTER_VOLUME:\n\t\tsnd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);\n\t\tbreak;\n\tdefault:\n\t\tif (emu->ops.sysex)\n\t\t\temu->ops.sysex(emu, buf, len, parsed, chset);\n\t\tbreak;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}