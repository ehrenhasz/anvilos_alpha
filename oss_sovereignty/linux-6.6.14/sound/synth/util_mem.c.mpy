{
  "module_name": "util_mem.c",
  "hash_id": "05d7fc6c371b70d573d917228155a84bd53f83d5c20a0ad77e7b07a0bdaacdbe",
  "original_prompt": "Ingested from linux-6.6.14/sound/synth/util_mem.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/util_mem.h>\n\nMODULE_AUTHOR(\"Takashi Iwai\");\nMODULE_DESCRIPTION(\"Generic memory management routines for soundcard memory allocation\");\nMODULE_LICENSE(\"GPL\");\n\n#define get_memblk(p)\tlist_entry(p, struct snd_util_memblk, list)\n\n \nstruct snd_util_memhdr *\nsnd_util_memhdr_new(int memsize)\n{\n\tstruct snd_util_memhdr *hdr;\n\n\thdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\n\tif (hdr == NULL)\n\t\treturn NULL;\n\thdr->size = memsize;\n\tmutex_init(&hdr->block_mutex);\n\tINIT_LIST_HEAD(&hdr->block);\n\n\treturn hdr;\n}\n\n \nvoid snd_util_memhdr_free(struct snd_util_memhdr *hdr)\n{\n\tstruct list_head *p;\n\n\tif (!hdr)\n\t\treturn;\n\t \n\twhile ((p = hdr->block.next) != &hdr->block) {\n\t\tlist_del(p);\n\t\tkfree(get_memblk(p));\n\t}\n\tkfree(hdr);\n}\n\n \nstruct snd_util_memblk *\n__snd_util_mem_alloc(struct snd_util_memhdr *hdr, int size)\n{\n\tstruct snd_util_memblk *blk;\n\tunsigned int units, prev_offset;\n\tstruct list_head *p;\n\n\tif (snd_BUG_ON(!hdr || size <= 0))\n\t\treturn NULL;\n\n\t \n\tunits = size;\n\tif (units & 1)\n\t\tunits++;\n\tif (units > hdr->size)\n\t\treturn NULL;\n\n\t \n\tprev_offset = 0;\n\tlist_for_each(p, &hdr->block) {\n\t\tblk = get_memblk(p);\n\t\tif (blk->offset - prev_offset >= units)\n\t\t\tgoto __found;\n\t\tprev_offset = blk->offset + blk->size;\n\t}\n\tif (hdr->size - prev_offset < units)\n\t\treturn NULL;\n\n__found:\n\treturn __snd_util_memblk_new(hdr, units, p->prev);\n}\n\n\n \nstruct snd_util_memblk *\n__snd_util_memblk_new(struct snd_util_memhdr *hdr, unsigned int units,\n\t\t      struct list_head *prev)\n{\n\tstruct snd_util_memblk *blk;\n\n\tblk = kmalloc(sizeof(struct snd_util_memblk) + hdr->block_extra_size,\n\t\t      GFP_KERNEL);\n\tif (blk == NULL)\n\t\treturn NULL;\n\n\tif (prev == &hdr->block)\n\t\tblk->offset = 0;\n\telse {\n\t\tstruct snd_util_memblk *p = get_memblk(prev);\n\t\tblk->offset = p->offset + p->size;\n\t}\n\tblk->size = units;\n\tlist_add(&blk->list, prev);\n\thdr->nblocks++;\n\thdr->used += units;\n\treturn blk;\n}\n\n\n \nstruct snd_util_memblk *\nsnd_util_mem_alloc(struct snd_util_memhdr *hdr, int size)\n{\n\tstruct snd_util_memblk *blk;\n\tmutex_lock(&hdr->block_mutex);\n\tblk = __snd_util_mem_alloc(hdr, size);\n\tmutex_unlock(&hdr->block_mutex);\n\treturn blk;\n}\n\n\n \nvoid\n__snd_util_mem_free(struct snd_util_memhdr *hdr, struct snd_util_memblk *blk)\n{\n\tlist_del(&blk->list);\n\thdr->nblocks--;\n\thdr->used -= blk->size;\n\tkfree(blk);\n}\n\n \nint snd_util_mem_free(struct snd_util_memhdr *hdr, struct snd_util_memblk *blk)\n{\n\tif (snd_BUG_ON(!hdr || !blk))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hdr->block_mutex);\n\t__snd_util_mem_free(hdr, blk);\n\tmutex_unlock(&hdr->block_mutex);\n\treturn 0;\n}\n\n \nint snd_util_mem_avail(struct snd_util_memhdr *hdr)\n{\n\tunsigned int size;\n\tmutex_lock(&hdr->block_mutex);\n\tsize = hdr->size - hdr->used;\n\tmutex_unlock(&hdr->block_mutex);\n\treturn size;\n}\n\n\nEXPORT_SYMBOL(snd_util_memhdr_new);\nEXPORT_SYMBOL(snd_util_memhdr_free);\nEXPORT_SYMBOL(snd_util_mem_alloc);\nEXPORT_SYMBOL(snd_util_mem_free);\nEXPORT_SYMBOL(snd_util_mem_avail);\nEXPORT_SYMBOL(__snd_util_mem_alloc);\nEXPORT_SYMBOL(__snd_util_mem_free);\nEXPORT_SYMBOL(__snd_util_memblk_new);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}