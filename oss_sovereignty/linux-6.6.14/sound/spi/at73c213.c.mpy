{
  "module_name": "at73c213.c",
  "hash_id": "d3155b02bf6b380e15f625adf6d141e569fb5c98b1c8952446990309b926f3cc",
  "original_prompt": "Ingested from linux-6.6.14/sound/spi/at73c213.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\n#include <sound/initval.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n\n#include <linux/atmel-ssc.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/at73c213.h>\n\n#include \"at73c213.h\"\n\n#define BITRATE_MIN\t 8000  \n#define BITRATE_TARGET\tCONFIG_SND_AT73C213_TARGET_BITRATE\n#define BITRATE_MAX\t50000  \n\n \nstatic const u8 snd_at73c213_original_image[18] =\n{\n\t0x00,\t \n\t0x05,\t \n\t0x05,\t \n\t0x08,\t \n\t0x08,\t \n\t0x00,\t \n\t0x00,\t \n\t0x22,\t \n\t0x09,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x05,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n\t0x00,\t \n};\n\nstruct snd_at73c213 {\n\tstruct snd_card\t\t\t*card;\n\tstruct snd_pcm\t\t\t*pcm;\n\tstruct snd_pcm_substream\t*substream;\n\tstruct at73c213_board_info\t*board;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tperiod;\n\tunsigned long\t\t\tbitrate;\n\tstruct ssc_device\t\t*ssc;\n\tstruct spi_device\t\t*spi;\n\tu8\t\t\t\tspi_wbuffer[2];\n\tu8\t\t\t\tspi_rbuffer[2];\n\t \n\tu8\t\t\t\treg_image[18];\n\t \n\tspinlock_t\t\t\tlock;\n\t \n\tstruct mutex\t\t\tmixer_lock;\n};\n\n#define get_chip(card) ((struct snd_at73c213 *)card->private_data)\n\nstatic int\nsnd_at73c213_write_reg(struct snd_at73c213 *chip, u8 reg, u8 val)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer msg_xfer = {\n\t\t.len\t\t= 2,\n\t\t.cs_change\t= 0,\n\t};\n\tint retval;\n\n\tspi_message_init(&msg);\n\n\tchip->spi_wbuffer[0] = reg;\n\tchip->spi_wbuffer[1] = val;\n\n\tmsg_xfer.tx_buf = chip->spi_wbuffer;\n\tmsg_xfer.rx_buf = chip->spi_rbuffer;\n\tspi_message_add_tail(&msg_xfer, &msg);\n\n\tretval = spi_sync(chip->spi, &msg);\n\n\tif (!retval)\n\t\tchip->reg_image[reg] = val;\n\n\treturn retval;\n}\n\nstatic struct snd_pcm_hardware snd_at73c213_playback_hw = {\n\t.info\t\t= SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t  SNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.formats\t= SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates\t\t= SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min\t= 8000,   \n\t.rate_max\t= 50000,  \n\t.channels_min\t= 1,\n\t.channels_max\t= 2,\n\t.buffer_bytes_max = 64 * 1024 - 1,\n\t.period_bytes_min = 512,\n\t.period_bytes_max = 64 * 1024 - 1,\n\t.periods_min\t= 4,\n\t.periods_max\t= 1024,\n};\n\n \nstatic int snd_at73c213_set_bitrate(struct snd_at73c213 *chip)\n{\n\tunsigned long ssc_rate = clk_get_rate(chip->ssc->clk);\n\tunsigned long dac_rate_new, ssc_div;\n\tint status;\n\tunsigned long ssc_div_max, ssc_div_min;\n\tint max_tries;\n\n\t \n\n\t \n\tssc_div = ssc_rate / (BITRATE_TARGET * 2 * 16);\n\tssc_div_min = ssc_rate / (BITRATE_MAX * 2 * 16);\n\tssc_div_max = ssc_rate / (BITRATE_MIN * 2 * 16);\n\tmax_tries = (ssc_div_max - ssc_div_min) / 2;\n\n\tif (max_tries < 1)\n\t\tmax_tries = 1;\n\n\t \n\tssc_div = (ssc_div + 1) & ~1UL;\n\n\tif ((ssc_rate / (ssc_div * 2 * 16)) < BITRATE_MIN) {\n\t\tssc_div -= 2;\n\t\tif ((ssc_rate / (ssc_div * 2 * 16)) > BITRATE_MAX)\n\t\t\treturn -ENXIO;\n\t}\n\n\t \n\tdo {\n\t\t \n\t\tif ((ssc_rate / (ssc_div * 2 * 16)) < BITRATE_MIN)\n\t\t\treturn -ENXIO;\n\n\t\t \n\t\tdac_rate_new = 8 * (ssc_rate / ssc_div);\n\n\t\tstatus = clk_round_rate(chip->board->dac_clk, dac_rate_new);\n\t\tif (status <= 0)\n\t\t\treturn status;\n\n\t\t \n\t\tif ((status/256) == (dac_rate_new/256))\n\t\t\tgoto set_rate;\n\n\t\tssc_div += 2;\n\t} while (--max_tries);\n\n\t \n\treturn -ENXIO;\n\nset_rate:\n\tstatus = clk_set_rate(chip->board->dac_clk, status);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tssc_writel(chip->ssc->regs, CMR, ssc_div/2);\n\n\t \n\tchip->bitrate = ssc_rate / (ssc_div * 16 * 2);\n\n\tdev_info(&chip->spi->dev,\n\t\t\t\"at73c213: supported bitrate is %lu (%lu divider)\\n\",\n\t\t\tchip->bitrate, ssc_div);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_at73c213_playback_hw.rate_min = chip->bitrate;\n\tsnd_at73c213_playback_hw.rate_max = chip->bitrate;\n\truntime->hw = snd_at73c213_playback_hw;\n\tchip->substream = substream;\n\n\terr = clk_enable(chip->ssc->clk);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tchip->substream = NULL;\n\tclk_disable(chip->ssc->clk);\n\treturn 0;\n}\n\nstatic int snd_at73c213_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tint channels = params_channels(hw_params);\n\tint val;\n\n\tval = ssc_readl(chip->ssc->regs, TFMR);\n\tval = SSC_BFINS(TFMR_DATNB, channels - 1, val);\n\tssc_writel(chip->ssc->regs, TFMR, val);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint block_size;\n\n\tblock_size = frames_to_bytes(runtime, runtime->period_size);\n\n\tchip->period = 0;\n\n\tssc_writel(chip->ssc->regs, PDC_TPR,\n\t\t\t(long)runtime->dma_addr);\n\tssc_writel(chip->ssc->regs, PDC_TCR,\n\t\t\truntime->period_size * runtime->channels);\n\tssc_writel(chip->ssc->regs, PDC_TNPR,\n\t\t\t(long)runtime->dma_addr + block_size);\n\tssc_writel(chip->ssc->regs, PDC_TNCR,\n\t\t\truntime->period_size * runtime->channels);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t   int cmd)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tint retval = 0;\n\n\tspin_lock(&chip->lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tssc_writel(chip->ssc->regs, IER, SSC_BIT(IER_ENDTX));\n\t\tssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTEN));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTDIS));\n\t\tssc_writel(chip->ssc->regs, IDR, SSC_BIT(IDR_ENDTX));\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&chip->spi->dev, \"spurious command %x\\n\", cmd);\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&chip->lock);\n\n\treturn retval;\n}\n\nstatic snd_pcm_uframes_t\nsnd_at73c213_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t pos;\n\tunsigned long bytes;\n\n\tbytes = ssc_readl(chip->ssc->regs, PDC_TPR)\n\t\t- (unsigned long)runtime->dma_addr;\n\n\tpos = bytes_to_frames(runtime, bytes);\n\tif (pos >= runtime->buffer_size)\n\t\tpos -= runtime->buffer_size;\n\n\treturn pos;\n}\n\nstatic const struct snd_pcm_ops at73c213_playback_ops = {\n\t.open\t\t= snd_at73c213_pcm_open,\n\t.close\t\t= snd_at73c213_pcm_close,\n\t.hw_params\t= snd_at73c213_pcm_hw_params,\n\t.prepare\t= snd_at73c213_pcm_prepare,\n\t.trigger\t= snd_at73c213_pcm_trigger,\n\t.pointer\t= snd_at73c213_pcm_pointer,\n};\n\nstatic int snd_at73c213_pcm_new(struct snd_at73c213 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint retval;\n\n\tretval = snd_pcm_new(chip->card, chip->card->shortname,\n\t\t\tdevice, 1, 0, &pcm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = SNDRV_PCM_INFO_BLOCK_TRANSFER;\n\tstrcpy(pcm->name, \"at73c213\");\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at73c213_playback_ops);\n\n\tsnd_pcm_set_managed_buffer_all(chip->pcm,\n\t\t\tSNDRV_DMA_TYPE_DEV, &chip->ssc->pdev->dev,\n\t\t\t64 * 1024, 64 * 1024);\nout:\n\treturn retval;\n}\n\nstatic irqreturn_t snd_at73c213_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_at73c213 *chip = dev_id;\n\tstruct snd_pcm_runtime *runtime = chip->substream->runtime;\n\tu32 status;\n\tint offset;\n\tint block_size;\n\tint next_period;\n\tint retval = IRQ_NONE;\n\n\tspin_lock(&chip->lock);\n\n\tblock_size = frames_to_bytes(runtime, runtime->period_size);\n\tstatus = ssc_readl(chip->ssc->regs, IMR);\n\n\tif (status & SSC_BIT(IMR_ENDTX)) {\n\t\tchip->period++;\n\t\tif (chip->period == runtime->periods)\n\t\t\tchip->period = 0;\n\t\tnext_period = chip->period + 1;\n\t\tif (next_period == runtime->periods)\n\t\t\tnext_period = 0;\n\n\t\toffset = block_size * next_period;\n\n\t\tssc_writel(chip->ssc->regs, PDC_TNPR,\n\t\t\t\t(long)runtime->dma_addr + offset);\n\t\tssc_writel(chip->ssc->regs, PDC_TNCR,\n\t\t\t\truntime->period_size * runtime->channels);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tssc_readl(chip->ssc->regs, IMR);\n\tspin_unlock(&chip->lock);\n\n\tif (status & SSC_BIT(IMR_ENDTX))\n\t\tsnd_pcm_period_elapsed(chip->substream);\n\n\treturn retval;\n}\n\n \nstatic int snd_at73c213_mono_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tucontrol->value.integer.value[0] =\n\t\t(chip->reg_image[reg] >> shift) & mask;\n\n\tif (invert)\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmask - ucontrol->value.integer.value[0];\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_mono_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change, retval;\n\tunsigned short val;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tval = (chip->reg_image[reg] & ~(mask << shift)) | val;\n\tchange = val != chip->reg_image[reg];\n\tretval = snd_at73c213_write_reg(chip, reg, val);\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn change;\n}\n\nstatic int snd_at73c213_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tif (mask == 1)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_stereo_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tucontrol->value.integer.value[0] =\n\t\t(chip->reg_image[left_reg] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] =\n\t\t(chip->reg_image[right_reg] >> shift_right) & mask;\n\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] =\n\t\t\tmask - ucontrol->value.integer.value[1];\n\t}\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_stereo_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change, retval;\n\tunsigned short val1, val2;\n\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tval1 = (chip->reg_image[left_reg] & ~(mask << shift_left)) | val1;\n\tval2 = (chip->reg_image[right_reg] & ~(mask << shift_right)) | val2;\n\tchange = val1 != chip->reg_image[left_reg]\n\t\t|| val2 != chip->reg_image[right_reg];\n\tretval = snd_at73c213_write_reg(chip, left_reg, val1);\n\tif (retval) {\n\t\tmutex_unlock(&chip->mixer_lock);\n\t\tgoto out;\n\t}\n\tretval = snd_at73c213_write_reg(chip, right_reg, val2);\n\tif (retval) {\n\t\tmutex_unlock(&chip->mixer_lock);\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\treturn change;\n\nout:\n\treturn retval;\n}\n\n#define snd_at73c213_mono_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_at73c213_mono_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tucontrol->value.integer.value[0] =\n\t\t(chip->reg_image[reg] >> shift) & 0x01;\n\n\tif (invert)\n\t\tucontrol->value.integer.value[0] =\n\t\t\t0x01 - ucontrol->value.integer.value[0];\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_mono_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change, retval;\n\tunsigned short val;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\n\tmutex_lock(&chip->mixer_lock);\n\n\tval |= (chip->reg_image[reg] & ~(mask << shift));\n\tchange = val != chip->reg_image[reg];\n\n\tretval = snd_at73c213_write_reg(chip, reg, val);\n\n\tmutex_unlock(&chip->mixer_lock);\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn change;\n}\n\nstatic int snd_at73c213_pa_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = ((kcontrol->private_value >> 16) & 0xff) - 1;\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_line_capture_volume_info(\n\t\tstruct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\t \n\tuinfo->value.integer.min = 14;\n\tuinfo->value.integer.max = 31;\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_aux_capture_volume_info(\n\t\tstruct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\t \n\tuinfo->value.integer.min = 14;\n\tuinfo->value.integer.max = 31;\n\n\treturn 0;\n}\n\n#define AT73C213_MONO_SWITCH(xname, xindex, reg, shift, mask, invert)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.index = xindex,\t\t\t\t\t\t\\\n\t.info = snd_at73c213_mono_switch_info,\t\t\t\t\\\n\t.get = snd_at73c213_mono_switch_get,\t\t\t\t\\\n\t.put = snd_at73c213_mono_switch_put,\t\t\t\t\\\n\t.private_value = (reg | (shift << 8) | (mask << 16) | (invert << 24)) \\\n}\n\n#define AT73C213_STEREO(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{\t\t\t\t\t\t\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.index = xindex,\t\t\t\t\t\t\\\n\t.info = snd_at73c213_stereo_info,\t\t\t\t\\\n\t.get = snd_at73c213_stereo_get,\t\t\t\t\t\\\n\t.put = snd_at73c213_stereo_put,\t\t\t\t\t\\\n\t.private_value = (left_reg | (right_reg << 8)\t\t\t\\\n\t\t\t| (shift_left << 16) | (shift_right << 19)\t\\\n\t\t\t| (mask << 24) | (invert << 22))\t\t\\\n}\n\nstatic const struct snd_kcontrol_new snd_at73c213_controls[] = {\nAT73C213_STEREO(\"Master Playback Volume\", 0, DAC_LMPG, DAC_RMPG, 0, 0, 0x1f, 1),\nAT73C213_STEREO(\"Master Playback Switch\", 0, DAC_LMPG, DAC_RMPG, 5, 5, 1, 1),\nAT73C213_STEREO(\"PCM Playback Volume\", 0, DAC_LLOG, DAC_RLOG, 0, 0, 0x1f, 1),\nAT73C213_STEREO(\"PCM Playback Switch\", 0, DAC_LLOG, DAC_RLOG, 5, 5, 1, 1),\nAT73C213_MONO_SWITCH(\"Mono PA Playback Switch\", 0, DAC_CTRL, DAC_CTRL_ONPADRV,\n\t\t     0x01, 0),\n{\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t= \"PA Playback Volume\",\n\t.index\t= 0,\n\t.info\t= snd_at73c213_pa_volume_info,\n\t.get\t= snd_at73c213_mono_get,\n\t.put\t= snd_at73c213_mono_put,\n\t.private_value\t= PA_CTRL | (PA_CTRL_APAGAIN << 8) | \\\n\t\t(0x0f << 16) | (1 << 24),\n},\nAT73C213_MONO_SWITCH(\"PA High Gain Playback Switch\", 0, PA_CTRL, PA_CTRL_APALP,\n\t\t     0x01, 1),\nAT73C213_MONO_SWITCH(\"PA Playback Switch\", 0, PA_CTRL, PA_CTRL_APAON, 0x01, 0),\n{\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t= \"Aux Capture Volume\",\n\t.index\t= 0,\n\t.info\t= snd_at73c213_aux_capture_volume_info,\n\t.get\t= snd_at73c213_mono_get,\n\t.put\t= snd_at73c213_mono_put,\n\t.private_value\t= DAC_AUXG | (0 << 8) | (0x1f << 16) | (1 << 24),\n},\nAT73C213_MONO_SWITCH(\"Aux Capture Switch\", 0, DAC_CTRL, DAC_CTRL_ONAUXIN,\n\t\t     0x01, 0),\n{\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t= \"Line Capture Volume\",\n\t.index\t= 0,\n\t.info\t= snd_at73c213_line_capture_volume_info,\n\t.get\t= snd_at73c213_stereo_get,\n\t.put\t= snd_at73c213_stereo_put,\n\t.private_value\t= DAC_LLIG | (DAC_RLIG << 8) | (0 << 16) | (0 << 19)\n\t\t| (0x1f << 24) | (1 << 22),\n},\nAT73C213_MONO_SWITCH(\"Line Capture Switch\", 0, DAC_CTRL, 0, 0x03, 0),\n};\n\nstatic int snd_at73c213_mixer(struct snd_at73c213 *chip)\n{\n\tstruct snd_card *card;\n\tint errval, idx;\n\n\tif (chip == NULL || chip->pcm == NULL)\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, chip->pcm->name);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_at73c213_controls); idx++) {\n\t\terrval = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_at73c213_controls[idx],\n\t\t\t\t\tchip));\n\t\tif (errval < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tfor (idx = 1; idx < ARRAY_SIZE(snd_at73c213_controls) + 1; idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_find_numid(card, idx);\n\t\tif (kctl)\n\t\t\tsnd_ctl_remove(card, kctl);\n\t}\n\treturn errval;\n}\n\n \nstatic int snd_at73c213_ssc_init(struct snd_at73c213 *chip)\n{\n\t \n\tssc_writel(chip->ssc->regs, TCMR,\n\t\t\tSSC_BF(TCMR_CKO, 1)\n\t\t\t| SSC_BF(TCMR_START, 4)\n\t\t\t| SSC_BF(TCMR_STTDLY, 1)\n\t\t\t| SSC_BF(TCMR_PERIOD, 16 - 1));\n\t \n\tssc_writel(chip->ssc->regs, TFMR,\n\t\t\tSSC_BF(TFMR_DATLEN, 16 - 1)\n\t\t\t| SSC_BIT(TFMR_MSBF)\n\t\t\t| SSC_BF(TFMR_DATNB, 1)\n\t\t\t| SSC_BF(TFMR_FSLEN, 16 - 1)\n\t\t\t| SSC_BF(TFMR_FSOS, 1));\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_chip_init(struct snd_at73c213 *chip)\n{\n\tint retval;\n\tunsigned char dac_ctrl = 0;\n\n\tretval = snd_at73c213_set_bitrate(chip);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = clk_enable(chip->board->dac_clk);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_RST, 0x04);\n\tif (retval)\n\t\tgoto out_clk;\n\tmsleep(1);\n\tretval = snd_at73c213_write_reg(chip, DAC_RST, 0x03);\n\tif (retval)\n\t\tgoto out_clk;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_PRECH, 0xff);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, PA_CTRL, (1<<PA_CTRL_APAPRECH));\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_CTRL,\n\t\t\t(1<<DAC_CTRL_ONLNOL) | (1<<DAC_CTRL_ONLNOR));\n\tif (retval)\n\t\tgoto out_clk;\n\n\tmsleep(50);\n\n\t \n\tretval = snd_at73c213_write_reg(chip, PA_CTRL,\n\t\t\t(1<<PA_CTRL_APALP) | 0x0f);\n\tif (retval)\n\t\tgoto out_clk;\n\n\tmsleep(450);\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_PRECH, (1<<DAC_PRECH_ONMSTR));\n\tif (retval)\n\t\tgoto out_clk;\n\n\tmsleep(1);\n\n\t \n\tdac_ctrl = (1<<DAC_CTRL_ONDACL) | (1<<DAC_CTRL_ONDACR)\n\t\t| (1<<DAC_CTRL_ONLNOL) | (1<<DAC_CTRL_ONLNOR);\n\n\tretval = snd_at73c213_write_reg(chip, DAC_CTRL, dac_ctrl);\n\tif (retval)\n\t\tgoto out_clk;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_LMPG, 0x3f);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_RMPG, 0x3f);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_LLOG, 0x3f);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_RLOG, 0x3f);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_LLIG, 0x11);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_RLIG, 0x11);\n\tif (retval)\n\t\tgoto out_clk;\n\tretval = snd_at73c213_write_reg(chip, DAC_AUXG, 0x11);\n\tif (retval)\n\t\tgoto out_clk;\n\n\t \n\tssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));\n\n\tgoto out;\n\nout_clk:\n\tclk_disable(chip->board->dac_clk);\nout:\n\treturn retval;\n}\n\nstatic int snd_at73c213_dev_free(struct snd_device *device)\n{\n\tstruct snd_at73c213 *chip = device->device_data;\n\n\tssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\n\tif (chip->irq >= 0) {\n\t\tfree_irq(chip->irq, chip);\n\t\tchip->irq = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_dev_init(struct snd_card *card,\n\t\t\t\t struct spi_device *spi)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free\t= snd_at73c213_dev_free,\n\t};\n\tstruct snd_at73c213 *chip = get_chip(card);\n\tint irq, retval;\n\n\tirq = chip->ssc->irq;\n\tif (irq < 0)\n\t\treturn irq;\n\n\tspin_lock_init(&chip->lock);\n\tmutex_init(&chip->mixer_lock);\n\tchip->card = card;\n\tchip->irq = -1;\n\n\tretval = clk_enable(chip->ssc->clk);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = request_irq(irq, snd_at73c213_interrupt, 0, \"at73c213\", chip);\n\tif (retval) {\n\t\tdev_dbg(&chip->spi->dev, \"unable to request irq %d\\n\", irq);\n\t\tgoto out;\n\t}\n\tchip->irq = irq;\n\n\tmemcpy(&chip->reg_image, &snd_at73c213_original_image,\n\t\t\tsizeof(snd_at73c213_original_image));\n\n\tretval = snd_at73c213_ssc_init(chip);\n\tif (retval)\n\t\tgoto out_irq;\n\n\tretval = snd_at73c213_chip_init(chip);\n\tif (retval)\n\t\tgoto out_irq;\n\n\tretval = snd_at73c213_pcm_new(chip, 0);\n\tif (retval)\n\t\tgoto out_irq;\n\n\tretval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (retval)\n\t\tgoto out_irq;\n\n\tretval = snd_at73c213_mixer(chip);\n\tif (retval)\n\t\tgoto out_snd_dev;\n\n\tgoto out;\n\nout_snd_dev:\n\tsnd_device_free(card, chip);\nout_irq:\n\tfree_irq(chip->irq, chip);\n\tchip->irq = -1;\nout:\n\tclk_disable(chip->ssc->clk);\n\n\treturn retval;\n}\n\nstatic int snd_at73c213_probe(struct spi_device *spi)\n{\n\tstruct snd_card\t\t\t*card;\n\tstruct snd_at73c213\t\t*chip;\n\tstruct at73c213_board_info\t*board;\n\tint\t\t\t\tretval;\n\tchar\t\t\t\tid[16];\n\n\tboard = spi->dev.platform_data;\n\tif (!board) {\n\t\tdev_dbg(&spi->dev, \"no platform_data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!board->dac_clk) {\n\t\tdev_dbg(&spi->dev, \"no DAC clk\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (IS_ERR(board->dac_clk)) {\n\t\tdev_dbg(&spi->dev, \"no DAC clk\\n\");\n\t\treturn PTR_ERR(board->dac_clk);\n\t}\n\n\t \n\tsnprintf(id, sizeof id, \"at73c213_%d\", board->ssc_id);\n\tretval = snd_card_new(&spi->dev, -1, id, THIS_MODULE,\n\t\t\t      sizeof(struct snd_at73c213), &card);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tchip = card->private_data;\n\tchip->spi = spi;\n\tchip->board = board;\n\n\tchip->ssc = ssc_request(board->ssc_id);\n\tif (IS_ERR(chip->ssc)) {\n\t\tdev_dbg(&spi->dev, \"could not get ssc%d device\\n\",\n\t\t\t\tboard->ssc_id);\n\t\tretval = PTR_ERR(chip->ssc);\n\t\tgoto out_card;\n\t}\n\n\tretval = snd_at73c213_dev_init(card, spi);\n\tif (retval)\n\t\tgoto out_ssc;\n\n\tstrcpy(card->driver, \"at73c213\");\n\tstrcpy(card->shortname, board->shortname);\n\tsprintf(card->longname, \"%s on irq %d\", card->shortname, chip->irq);\n\n\tretval = snd_card_register(card);\n\tif (retval)\n\t\tgoto out_ssc;\n\n\tdev_set_drvdata(&spi->dev, card);\n\n\tgoto out;\n\nout_ssc:\n\tssc_free(chip->ssc);\nout_card:\n\tsnd_card_free(card);\nout:\n\treturn retval;\n}\n\nstatic void snd_at73c213_remove(struct spi_device *spi)\n{\n\tstruct snd_card *card = dev_get_drvdata(&spi->dev);\n\tstruct snd_at73c213 *chip = card->private_data;\n\tint retval;\n\n\t \n\tretval = clk_enable(chip->ssc->clk);\n\tif (retval)\n\t\tgoto out;\n\tssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\n\tclk_disable(chip->ssc->clk);\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_LMPG, 0x3f);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_RMPG, 0x3f);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_LLOG, 0x3f);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_RLOG, 0x3f);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_LLIG, 0x11);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_RLIG, 0x11);\n\tif (retval)\n\t\tgoto out;\n\tretval = snd_at73c213_write_reg(chip, DAC_AUXG, 0x11);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, PA_CTRL,\n\t\t\t\t\tchip->reg_image[PA_CTRL] | 0x0f);\n\tif (retval)\n\t\tgoto out;\n\tmsleep(10);\n\tretval = snd_at73c213_write_reg(chip, PA_CTRL,\n\t\t\t\t\t(1 << PA_CTRL_APALP) | 0x0f);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_CTRL, 0x0c);\n\tif (retval)\n\t\tgoto out;\n\tmsleep(2);\n\tretval = snd_at73c213_write_reg(chip, DAC_CTRL, 0x00);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = snd_at73c213_write_reg(chip, DAC_PRECH, 0x00);\n\tif (retval)\n\t\tgoto out;\n\nout:\n\t \n\tclk_disable(chip->board->dac_clk);\n\n\tssc_free(chip->ssc);\n\tsnd_card_free(card);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int snd_at73c213_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_at73c213 *chip = card->private_data;\n\n\tssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\n\tclk_disable(chip->ssc->clk);\n\tclk_disable(chip->board->dac_clk);\n\n\treturn 0;\n}\n\nstatic int snd_at73c213_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_at73c213 *chip = card->private_data;\n\tint retval;\n\n\tretval = clk_enable(chip->board->dac_clk);\n\tif (retval)\n\t\treturn retval;\n\tretval = clk_enable(chip->ssc->clk);\n\tif (retval) {\n\t\tclk_disable(chip->board->dac_clk);\n\t\treturn retval;\n\t}\n\tssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(at73c213_pm_ops, snd_at73c213_suspend,\n\t\tsnd_at73c213_resume);\n#define AT73C213_PM_OPS (&at73c213_pm_ops)\n\n#else\n#define AT73C213_PM_OPS NULL\n#endif\n\nstatic struct spi_driver at73c213_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"at73c213\",\n\t\t.pm\t= AT73C213_PM_OPS,\n\t},\n\t.probe\t\t= snd_at73c213_probe,\n\t.remove\t\t= snd_at73c213_remove,\n};\n\nmodule_spi_driver(at73c213_driver);\n\nMODULE_AUTHOR(\"Hans-Christian Egtvedt <egtvedt@samfundet.no>\");\nMODULE_DESCRIPTION(\"Sound driver for AT73C213 with Atmel SSC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}