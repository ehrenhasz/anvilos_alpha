{
  "module_name": "pdaudiocf_pcm.c",
  "hash_id": "d75d5879228c63e5dfd262c1d33bc3cf076ed0f1fb9f3414f9310c1b290404d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/asoundef.h>\n#include \"pdaudiocf.h\"\n\n\n \nstatic int pdacf_pcm_clear_sram(struct snd_pdacf *chip)\n{\n\tint max_loop = 64 * 1024;\n\n\twhile (inw(chip->port + PDAUDIOCF_REG_RDP) != inw(chip->port + PDAUDIOCF_REG_WDP)) {\n\t\tif (max_loop-- < 0)\n\t\t\treturn -EIO;\n\t\tinw(chip->port + PDAUDIOCF_REG_MD);\n\t}\n\treturn 0;\n}\n\n \nstatic int pdacf_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct snd_pdacf *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tint inc, ret = 0, rate;\n\tunsigned short mask, val, tmp;\n\n\tif (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tchip->pcm_hwptr = 0;\n\t\tchip->pcm_tdone = 0;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tmask = 0;\n\t\tval = PDAUDIOCF_RECORD;\n\t\tinc = 1;\n\t\trate = snd_ak4117_check_rate_and_errors(chip->ak4117, AK4117_CHECK_NO_STAT|AK4117_CHECK_NO_RATE);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tmask = PDAUDIOCF_RECORD;\n\t\tval = 0;\n\t\tinc = -1;\n\t\trate = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&chip->reg_lock);\n\tchip->pcm_running += inc;\n\ttmp = pdacf_reg_read(chip, PDAUDIOCF_REG_SCR);\n\tif (chip->pcm_running) {\n\t\tif ((chip->ak4117->rcs0 & AK4117_UNLCK) || runtime->rate != rate) {\n\t\t\tchip->pcm_running -= inc;\n\t\t\tret = -EIO;\n\t\t\tgoto __end;\n\t\t}\n\t}\n\ttmp &= ~mask;\n\ttmp |= val;\n\tpdacf_reg_write(chip, PDAUDIOCF_REG_SCR, tmp);\n      __end:\n\tmutex_unlock(&chip->reg_lock);\n\tsnd_ak4117_check_rate_and_errors(chip->ak4117, AK4117_CHECK_NO_RATE);\n\treturn ret;\n}\n\n \nstatic int pdacf_pcm_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pdacf *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tu16 val, nval, aval;\n\n\tif (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\tchip->pcm_channels = runtime->channels;\n\n\tchip->pcm_little = snd_pcm_format_little_endian(runtime->format) > 0;\n#ifdef SNDRV_LITTLE_ENDIAN\n\tchip->pcm_swab = snd_pcm_format_big_endian(runtime->format) > 0;\n#else\n\tchip->pcm_swab = chip->pcm_little;\n#endif\n\n\tif (snd_pcm_format_unsigned(runtime->format))\n\t\tchip->pcm_xor = 0x80008000;\n\n\tif (pdacf_pcm_clear_sram(chip) < 0)\n\t\treturn -EIO;\n\t\n\tval = nval = pdacf_reg_read(chip, PDAUDIOCF_REG_SCR);\n\tnval &= ~(PDAUDIOCF_DATAFMT0|PDAUDIOCF_DATAFMT1);\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tbreak;\n\tdefault:  \n\t\tnval |= PDAUDIOCF_DATAFMT0 | PDAUDIOCF_DATAFMT1;\n\t\tbreak;\n\t}\n\taval = 0;\n\tchip->pcm_sample = 4;\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\taval = AK4117_DIF_16R;\n\t\tchip->pcm_frame = 2;\n\t\tchip->pcm_sample = 2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\t\tchip->pcm_sample = 3;\n\t\tfallthrough;\n\tdefault:  \n\t\taval = AK4117_DIF_24R;\n\t\tchip->pcm_frame = 3;\n\t\tchip->pcm_xor &= 0xffff0000;\n\t\tbreak;\n\t}\n\n\tif (val != nval) {\n\t\tsnd_ak4117_reg_write(chip->ak4117, AK4117_REG_IO, AK4117_DIF2|AK4117_DIF1|AK4117_DIF0, aval);\n\t\tpdacf_reg_write(chip, PDAUDIOCF_REG_SCR, nval);\n\t}\n\n\tval = pdacf_reg_read(chip,  PDAUDIOCF_REG_IER);\n\tval &= ~(PDAUDIOCF_IRQLVLEN1);\n\tval |= PDAUDIOCF_IRQLVLEN0;\n\tpdacf_reg_write(chip, PDAUDIOCF_REG_IER, val);\n\n\tchip->pcm_size = runtime->buffer_size;\n\tchip->pcm_period = runtime->period_size;\n\tchip->pcm_area = runtime->dma_area;\n\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_pcm_hardware pdacf_pcm_capture_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_BATCH),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE,\n\t.rates =\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\tSNDRV_PCM_RATE_44100 |\n\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\tSNDRV_PCM_RATE_88200 |\n\t\t\t\tSNDRV_PCM_RATE_96000 |\n\t\t\t\tSNDRV_PCM_RATE_176400 |\n\t\t\t\tSNDRV_PCM_RATE_192000,\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(512*1024),\n\t.period_bytes_min =\t8*1024,\n\t.period_bytes_max =\t(64*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t128,\n\t.fifo_size =\t\t0,\n};\n\n\n \nstatic int pdacf_pcm_capture_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct snd_pdacf *chip = snd_pcm_substream_chip(subs);\n\n\tif (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\truntime->hw = pdacf_pcm_capture_hw;\n\truntime->private_data = chip;\n\tchip->pcm_substream = subs;\n\n\treturn 0;\n}\n\n \nstatic int pdacf_pcm_capture_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pdacf *chip = snd_pcm_substream_chip(subs);\n\n\tif (!chip)\n\t\treturn -EINVAL;\n\tpdacf_reinit(chip, 0);\n\tchip->pcm_substream = NULL;\n\treturn 0;\n}\n\n\n \nstatic snd_pcm_uframes_t pdacf_pcm_capture_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pdacf *chip = snd_pcm_substream_chip(subs);\n\treturn chip->pcm_hwptr;\n}\n\n \nstatic const struct snd_pcm_ops pdacf_pcm_capture_ops = {\n\t.open =\t\tpdacf_pcm_capture_open,\n\t.close =\tpdacf_pcm_capture_close,\n\t.prepare =\tpdacf_pcm_prepare,\n\t.trigger =\tpdacf_pcm_trigger,\n\t.pointer =\tpdacf_pcm_capture_pointer,\n};\n\n\n \nint snd_pdacf_pcm_new(struct snd_pdacf *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"PDAudioCF\", 0, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\t\t\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pdacf_pcm_capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL,\n\t\t\t\t       0, 0);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm = pcm;\n\t\n\terr = snd_ak4117_build(chip->ak4117, pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}