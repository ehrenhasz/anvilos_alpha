{
  "module_name": "vxp_ops.c",
  "hash_id": "0154326ec81d07ac507b016883add05ca989baa0e9f38f6b5f88c8a148424240",
  "original_prompt": "Ingested from linux-6.6.14/sound/pcmcia/vx/vxp_ops.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include \"vxpocket.h\"\n\n\nstatic const int vxp_reg_offset[VX_REG_MAX] = {\n\t[VX_ICR]\t= 0x00,\t\t\n\t[VX_CVR]\t= 0x01,\t\t\n\t[VX_ISR]\t= 0x02,\t\t\n\t[VX_IVR]\t= 0x03,\t\t\n\t[VX_RXH]\t= 0x05,\t\t\n\t[VX_RXM]\t= 0x06,\t\t\n\t[VX_RXL]\t= 0x07,\t\t\n\t[VX_DMA]\t= 0x04,\t\t\n\t[VX_CDSP]\t= 0x08,\t\t\n\t[VX_LOFREQ]\t= 0x09,\t\t\n\t[VX_HIFREQ]\t= 0x0a,\t\t\n\t[VX_DATA]\t= 0x0b,\t\t\n\t[VX_MICRO]\t= 0x0c,\t\t\n\t[VX_DIALOG]\t= 0x0d,\t\t\n\t[VX_CSUER]\t= 0x0e,\t\t\n\t[VX_RUER]\t= 0x0f,\t\t\n};\n\n\nstatic inline unsigned long vxp_reg_addr(struct vx_core *_chip, int reg)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\treturn chip->port + vxp_reg_offset[reg];\n}\n\n \nstatic unsigned char vxp_inb(struct vx_core *chip, int offset)\n{\n\treturn inb(vxp_reg_addr(chip, offset));\n}\n\n \nstatic void vxp_outb(struct vx_core *chip, int offset, unsigned char val)\n{\n\toutb(val, vxp_reg_addr(chip, offset));\n}\n\n \n#undef vx_inb\n#define vx_inb(chip,reg)\tvxp_inb((struct vx_core *)(chip), VX_##reg)\n#undef vx_outb\n#define vx_outb(chip,reg,val)\tvxp_outb((struct vx_core *)(chip), VX_##reg,val)\n\n\n \nstatic int vx_check_magic(struct vx_core *chip)\n{\n\tunsigned long end_time = jiffies + HZ / 5;\n\tint c;\n\tdo {\n\t\tc = vx_inb(chip, CDSP);\n\t\tif (c == CDSP_MAGIC)\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t} while (time_after_eq(end_time, jiffies));\n\tsnd_printk(KERN_ERR \"cannot find xilinx magic word (%x)\\n\", c);\n\treturn -EIO;\n}\n\n\n \n\n#define XX_DSP_RESET_WAIT_TIME\t\t2\t \n\nstatic void vxp_reset_dsp(struct vx_core *_chip)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tvx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_DSP_RESET_MASK);\n\tvx_inb(chip, CDSP);\n\tmdelay(XX_DSP_RESET_WAIT_TIME);\n\t \n\tchip->regCDSP &= ~VXP_CDSP_DSP_RESET_MASK;\n\tvx_outb(chip, CDSP, chip->regCDSP);\n\tvx_inb(chip, CDSP);\n\tmdelay(XX_DSP_RESET_WAIT_TIME);\n}\n\n \nstatic void vxp_reset_codec(struct vx_core *_chip)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tvx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);\n\tvx_inb(chip, CDSP);\n\tmsleep(10);\n\t \n\tchip->regCDSP &= ~VXP_CDSP_CODEC_RESET_MASK;\n\tvx_outb(chip, CDSP, chip->regCDSP);\n\tvx_inb(chip, CDSP);\n\tmsleep(1);\n}\n\n \nstatic int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *fw)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tunsigned int i;\n\tint c;\n\tint regCSUER, regRUER;\n\tconst unsigned char *image;\n\tunsigned char data;\n\n\t \n\tchip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\n\t \n\tregCSUER = vx_inb(chip, CSUER);\n\tregRUER = vx_inb(chip, RUER);\n\n\t \n\tvx_outb(chip, ICR, 0);\n\n\t \n\tsnd_printdd(KERN_DEBUG \"check ISR_HF2\\n\");\n\tif (vx_check_isr(_chip, ISR_HF2, ISR_HF2, 20) < 0)\n\t\tgoto _error;\n\n\t \n\tvx_outb(chip, ICR, ICR_HF1);\n\timage = fw->data;\n\tfor (i = 0; i < fw->size; i++, image++) {\n\t\tdata = *image;\n\t\tif (vx_wait_isr_bit(_chip, ISR_TX_EMPTY) < 0)\n\t\t\tgoto _error;\n\t\tvx_outb(chip, TXL, data);\n\t\t \n\t\tif (vx_wait_for_rx_full(_chip) < 0)\n\t\t\tgoto _error;\n\t\tc = vx_inb(chip, RXL);\n\t\tif (c != (int)data)\n\t\t\tsnd_printk(KERN_ERR \"vxpocket: load xilinx mismatch at %d: 0x%x != 0x%x\\n\", i, c, (int)data);\n        }\n\n\t \n\tvx_outb(chip, ICR, 0);\n\n\t \n\tif (vx_check_isr(_chip, ISR_HF3, ISR_HF3, 20) < 0)\n\t\tgoto _error;\n\n\t \n\tif (vx_wait_for_rx_full(_chip) < 0)\n\t\tgoto _error;\n\n\tc = (int)vx_inb(chip, RXH) << 16;\n\tc |= (int)vx_inb(chip, RXM) << 8;\n\tc |= vx_inb(chip, RXL);\n\n\tsnd_printdd(KERN_DEBUG \"xilinx: dsp size received 0x%x, orig 0x%zx\\n\", c, fw->size);\n\n\tvx_outb(chip, ICR, ICR_HF0);\n\n\t \n\tmsleep(300);\n\n\t \n\tif (vx_check_magic(_chip) < 0)\n\t\tgoto _error;\n\n\t \n\tvx_outb(chip, CSUER, regCSUER);\n\tvx_outb(chip, RUER, regRUER);\n\n\t \n\tchip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\tvx_inb(chip, DIALOG);\n\tmsleep(10);\n\tchip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\tvx_inb(chip, DIALOG);\n\n\t \n\tvxp_reset_codec(_chip);\n\tvx_reset_dsp(_chip);\n\n\treturn 0;\n\n _error:\n\tvx_outb(chip, CSUER, regCSUER);\n\tvx_outb(chip, RUER, regRUER);\n\tchip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\treturn -EIO;\n}\n\n\n \nstatic int vxp_load_dsp(struct vx_core *vx, int index, const struct firmware *fw)\n{\n\tint err;\n\n\tswitch (index) {\n\tcase 0:\n\t\t \n\t\terr = vx_check_magic(vx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_vx_load_boot_image(vx, fw);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\treturn 0;\n\tcase 1:\n\t\t \n\t\treturn vxp_load_xilinx_binary(vx, fw);\n\tcase 2:\n\t\t \n\t\treturn snd_vx_dsp_boot(vx, fw);\n\tcase 3:\n\t\t \n\t\treturn snd_vx_dsp_load(vx, fw);\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n}\n\t\t\n\n \nstatic int vxp_test_and_ack(struct vx_core *_chip)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tif (! (_chip->chip_status & VX_STAT_XILINX_LOADED))\n\t\treturn -ENXIO;\n\n\tif (! (vx_inb(chip, DIALOG) & VXP_DLG_MEMIRQ_MASK))\n\t\treturn -EIO;\n\t\n\t \n\t \n\tvx_outb(chip, DIALOG, chip->regDIALOG | VXP_DLG_ACK_MEMIRQ_MASK);\n\t \n\tvx_inb(chip, DIALOG);\n\tvx_outb(chip, DIALOG, chip->regDIALOG & ~VXP_DLG_ACK_MEMIRQ_MASK);\n\n\treturn 0;\n}\n\n\n \nstatic void vxp_validate_irq(struct vx_core *_chip, int enable)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tif (enable)\n\t\tchip->regCDSP |= VXP_CDSP_VALID_IRQ_MASK;\n\telse\n\t\tchip->regCDSP &= ~VXP_CDSP_VALID_IRQ_MASK;\n\tvx_outb(chip, CDSP, chip->regCDSP);\n}\n\n \nstatic void vx_setup_pseudo_dma(struct vx_core *_chip, int do_write)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tvx_outb(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);\n\t \n\tvx_inb(chip, ISR);\n\tvx_outb(chip, ISR, 0);\n\n\t \n\tchip->regDIALOG |= VXP_DLG_DMA16_SEL_MASK;\n\tchip->regDIALOG |= do_write ? VXP_DLG_DMAWRITE_SEL_MASK : VXP_DLG_DMAREAD_SEL_MASK;\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\n}\n\n \nstatic void vx_release_pseudo_dma(struct vx_core *_chip)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\t \n\tchip->regDIALOG &= ~(VXP_DLG_DMAWRITE_SEL_MASK|\n\t\t\t     VXP_DLG_DMAREAD_SEL_MASK|\n\t\t\t     VXP_DLG_DMA16_SEL_MASK);\n\tvx_outb(chip, DIALOG, chip->regDIALOG);\n\t \n\tvx_outb(chip, ICR, 0);\n}\n\n \nstatic void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,\n\t\t\t  struct vx_pipe *pipe, int count)\n{\n\tlong port = vxp_reg_addr(chip, VX_DMA);\n\tint offset = pipe->hw_ptr;\n\tunsigned short *addr = (unsigned short *)(runtime->dma_area + offset);\n\n\tvx_setup_pseudo_dma(chip, 1);\n\tif (offset + count >= pipe->buffer_bytes) {\n\t\tint length = pipe->buffer_bytes - offset;\n\t\tcount -= length;\n\t\tlength >>= 1;  \n\t\t \n\t\tfor (; length > 0; length--) {\n\t\t\toutw(*addr, port);\n\t\t\taddr++;\n\t\t}\n\t\taddr = (unsigned short *)runtime->dma_area;\n\t\tpipe->hw_ptr = 0;\n\t}\n\tpipe->hw_ptr += count;\n\tcount >>= 1;  \n\t \n\tfor (; count > 0; count--) {\n\t\toutw(*addr, port);\n\t\taddr++;\n\t}\n\tvx_release_pseudo_dma(chip);\n}\n\n\n \nstatic void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,\n\t\t\t struct vx_pipe *pipe, int count)\n{\n\tstruct snd_vxpocket *pchip = to_vxpocket(chip);\n\tlong port = vxp_reg_addr(chip, VX_DMA);\n\tint offset = pipe->hw_ptr;\n\tunsigned short *addr = (unsigned short *)(runtime->dma_area + offset);\n\n\tif (snd_BUG_ON(count % 2))\n\t\treturn;\n\tvx_setup_pseudo_dma(chip, 0);\n\tif (offset + count >= pipe->buffer_bytes) {\n\t\tint length = pipe->buffer_bytes - offset;\n\t\tcount -= length;\n\t\tlength >>= 1;  \n\t\t \n\t\tfor (; length > 0; length--)\n\t\t\t*addr++ = inw(port);\n\t\taddr = (unsigned short *)runtime->dma_area;\n\t\tpipe->hw_ptr = 0;\n\t}\n\tpipe->hw_ptr += count;\n\tcount >>= 1;  \n\t \n\tfor (; count > 1; count--)\n\t\t*addr++ = inw(port);\n\t \n\tpchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;\n\tvx_outb(chip, DIALOG, pchip->regDIALOG);\n\t \n\t*addr = inw(port);\n\t \n\tpchip->regDIALOG &= ~VXP_DLG_DMA16_SEL_MASK;\n\tvx_outb(chip, DIALOG, pchip->regDIALOG);\n\t \n\tvx_outb(chip, ICR, 0);\n}\n\n\n \nstatic void vxp_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)\n{\n\tint i;\n\n\t \n\tif (! codec)\n\t\tvx_inb(chip, LOFREQ);\n\telse\n\t\tvx_inb(chip, CODEC2);\n\t\t\n\t \n\tfor (i = 0; i < 24; i++, data <<= 1)\n\t\tvx_outb(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\n\t\n\t \n\tvx_inb(chip, HIFREQ);\n}\n\n\n \nvoid vx_set_mic_boost(struct vx_core *chip, int boost)\n{\n\tstruct snd_vxpocket *pchip = to_vxpocket(chip);\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn;\n\n\tmutex_lock(&chip->lock);\n\tif (pchip->regCDSP & P24_CDSP_MICS_SEL_MASK) {\n\t\tif (boost) {\n\t\t\t \n\t\t\tpchip->regCDSP &= ~P24_CDSP_MIC20_SEL_MASK;\n\t\t\tpchip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;\n\t\t} else {\n\t\t\t \n\t\t\tpchip->regCDSP |=  P24_CDSP_MIC20_SEL_MASK;\n\t\t\tpchip->regCDSP &= ~P24_CDSP_MIC38_SEL_MASK;\n                }\n\t\tvx_outb(chip, CDSP, pchip->regCDSP);\n\t}\n\tmutex_unlock(&chip->lock);\n}\n\n \nstatic int vx_compute_mic_level(int level)\n{\n\tswitch (level) {\n\tcase 5: level = 6 ; break;\n\tcase 6: level = 8 ; break;\n\tcase 7: level = 11; break;\n\tcase 8: level = 15; break;\n\tdefault: break ;\n\t}\n\treturn level;\n}\n\n \nvoid vx_set_mic_level(struct vx_core *chip, int level)\n{\n\tstruct snd_vxpocket *pchip = to_vxpocket(chip);\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn;\n\n\tmutex_lock(&chip->lock);\n\tif (pchip->regCDSP & VXP_CDSP_MIC_SEL_MASK) {\n\t\tlevel = vx_compute_mic_level(level);\n\t\tvx_outb(chip, MICRO, level);\n\t}\n\tmutex_unlock(&chip->lock);\n}\n\n\n \nstatic void vxp_change_audio_source(struct vx_core *_chip, int src)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\tswitch (src) {\n\tcase VX_AUDIO_SRC_DIGITAL:\n\t\tchip->regCDSP |= VXP_CDSP_DATAIN_SEL_MASK;\n\t\tvx_outb(chip, CDSP, chip->regCDSP);\n\t\tbreak;\n\tcase VX_AUDIO_SRC_LINE:\n\t\tchip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;\n\t\tif (_chip->type == VX_TYPE_VXP440)\n\t\t\tchip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;\n\t\telse\n\t\t\tchip->regCDSP &= ~VXP_CDSP_MIC_SEL_MASK;\n\t\tvx_outb(chip, CDSP, chip->regCDSP);\n\t\tbreak;\n\tcase VX_AUDIO_SRC_MIC:\n\t\tchip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;\n\t\t \n\t\tif (_chip->type == VX_TYPE_VXP440) {\n\t\t\tchip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;\n\t\t\tif (chip->mic_level)\n\t\t\t\tchip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;\n\t\t\telse\n\t\t\t\tchip->regCDSP |= P24_CDSP_MIC20_SEL_MASK;\n\t\t\tvx_outb(chip, CDSP, chip->regCDSP);\n\t\t} else {\n\t\t\tchip->regCDSP |= VXP_CDSP_MIC_SEL_MASK;\n\t\t\tvx_outb(chip, CDSP, chip->regCDSP);\n\t\t\tvx_outb(chip, MICRO, vx_compute_mic_level(chip->mic_level));\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void vxp_set_clock_source(struct vx_core *_chip, int source)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\tif (source == INTERNAL_QUARTZ)\n\t\tchip->regCDSP &= ~VXP_CDSP_CLOCKIN_SEL_MASK;\n\telse\n\t\tchip->regCDSP |= VXP_CDSP_CLOCKIN_SEL_MASK;\n\tvx_outb(chip, CDSP, chip->regCDSP);\n}\n\n\n \nstatic void vxp_reset_board(struct vx_core *_chip, int cold_reset)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\n\tchip->regCDSP = 0;\n\tchip->regDIALOG = 0;\n}\n\n\n \n \nconst struct snd_vx_ops snd_vxpocket_ops = {\n\t.in8 = vxp_inb,\n\t.out8 = vxp_outb,\n\t.test_and_ack = vxp_test_and_ack,\n\t.validate_irq = vxp_validate_irq,\n\t.write_codec = vxp_write_codec_reg,\n\t.reset_codec = vxp_reset_codec,\n\t.change_audio_source = vxp_change_audio_source,\n\t.set_clock_source = vxp_set_clock_source,\n\t.load_dsp = vxp_load_dsp,\n\t.add_controls = vxp_add_mic_controls,\n\t.reset_dsp = vxp_reset_dsp,\n\t.reset_board = vxp_reset_board,\n\t.dma_write = vxp_dma_write,\n\t.dma_read = vxp_dma_read,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}