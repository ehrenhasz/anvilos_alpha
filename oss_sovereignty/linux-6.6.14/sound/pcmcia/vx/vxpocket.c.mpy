{
  "module_name": "vxpocket.c",
  "hash_id": "a8f53bd80be3ab1a5bfebdbe351379467fa7c3207f46e10736a88f50e87392fe",
  "original_prompt": "Ingested from linux-6.6.14/sound/pcmcia/vx/vxpocket.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include \"vxpocket.h\"\n#include <pcmcia/ciscode.h>\n#include <pcmcia/cisreg.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"Digigram VXPocket\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic int ibl[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for VXPocket soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for VXPocket soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable VXPocket soundcard.\");\nmodule_param_array(ibl, int, NULL, 0444);\nMODULE_PARM_DESC(ibl, \"Capture IBL size for VXPocket soundcard.\");\n \n\n \n\nstatic unsigned int card_alloc;\n\n\n \nstatic void vxpocket_release(struct pcmcia_device *link)\n{\n\tfree_irq(link->irq, link->priv);\n\tpcmcia_disable_device(link);\n}\n\n \n\n \n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_old_vol, -11350, 50, 0);\n\nstatic const struct snd_vx_hardware vxpocket_hw = {\n\t.name = \"VXPocket\",\n\t.type = VX_TYPE_VXPOCKET,\n\n\t \n\t.num_codecs = 1,\n\t.num_ins = 1,\n\t.num_outs = 1,\n\t.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,\n\t.output_level_db_scale = db_scale_old_vol,\n};\t\n\n \n\nstatic const struct snd_vx_hardware vxp440_hw = {\n\t.name = \"VXPocket440\",\n\t.type = VX_TYPE_VXP440,\n\n\t \n\t.num_codecs = 2,\n\t.num_ins = 2,\n\t.num_outs = 2,\n\t.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,\n\t.output_level_db_scale = db_scale_old_vol,\n};\t\n\n\n \nstatic int snd_vxpocket_new(struct snd_card *card, int ibl,\n\t\t\t    struct pcmcia_device *link,\n\t\t\t    struct snd_vxpocket **chip_ret)\n{\n\tstruct vx_core *chip;\n\tstruct snd_vxpocket *vxp;\n\n\tchip = snd_vx_create(card, &vxpocket_hw, &snd_vxpocket_ops,\n\t\t\t     sizeof(struct snd_vxpocket) - sizeof(struct vx_core));\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->ibl.size = ibl;\n\n\tvxp = to_vxpocket(chip);\n\n\tvxp->p_dev = link;\n\tlink->priv = chip;\n\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\tlink->resource[0]->end = 16;\n\n\tlink->config_flags |= CONF_ENABLE_IRQ;\n\tlink->config_index = 1;\n\tlink->config_regs = PRESENT_OPTION;\n\n\t*chip_ret = vxp;\n\treturn 0;\n}\n\n\n \nstatic int snd_vxpocket_assign_resources(struct vx_core *chip, int port, int irq)\n{\n\tint err;\n\tstruct snd_card *card = chip->card;\n\tstruct snd_vxpocket *vxp = to_vxpocket(chip);\n\n\tsnd_printdd(KERN_DEBUG \"vxpocket assign resources: port = 0x%x, irq = %d\\n\", port, irq);\n\tvxp->port = port;\n\n\tsprintf(card->shortname, \"Digigram %s\", card->driver);\n\tsprintf(card->longname, \"%s at 0x%x, irq %i\",\n\t\tcard->shortname, port, irq);\n\n\tchip->irq = irq;\n\tcard->sync_irq = chip->irq;\n\n\terr = snd_vx_setup_firmware(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n \n\nstatic int vxpocket_config(struct pcmcia_device *link)\n{\n\tstruct vx_core *chip = link->priv;\n\tint ret;\n\n\tsnd_printdd(KERN_DEBUG \"vxpocket_config called\\n\");\n\n\t \n\tif (!strcmp(link->prod_id[1], \"VX-POCKET\")) {\n\t\tsnd_printdd(\"VX-pocket is detected\\n\");\n\t} else {\n\t\tsnd_printdd(\"VX-pocket 440 is detected\\n\");\n\t\t \n\t\tchip->hw = &vxp440_hw;\n\t\tchip->type = vxp440_hw.type;\n\t\tstrcpy(chip->card->driver, vxp440_hw.name);\n\t}\n\n\tret = pcmcia_request_io(link);\n\tif (ret)\n\t\tgoto failed_preirq;\n\n\tret = request_threaded_irq(link->irq, snd_vx_irq_handler,\n\t\t\t\t   snd_vx_threaded_irq_handler,\n\t\t\t\t   IRQF_SHARED, link->devname, link->priv);\n\tif (ret)\n\t\tgoto failed_preirq;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tchip->dev = &link->dev;\n\n\tif (snd_vxpocket_assign_resources(chip, link->resource[0]->start,\n\t\t\t\t\t\tlink->irq) < 0)\n\t\tgoto failed;\n\n\treturn 0;\n\n failed:\n\tfree_irq(link->irq, link->priv);\nfailed_preirq:\n\tpcmcia_disable_device(link);\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_PM\n\nstatic int vxp_suspend(struct pcmcia_device *link)\n{\n\tstruct vx_core *chip = link->priv;\n\n\tsnd_printdd(KERN_DEBUG \"SUSPEND\\n\");\n\tif (chip) {\n\t\tsnd_printdd(KERN_DEBUG \"snd_vx_suspend calling\\n\");\n\t\tsnd_vx_suspend(chip);\n\t}\n\n\treturn 0;\n}\n\nstatic int vxp_resume(struct pcmcia_device *link)\n{\n\tstruct vx_core *chip = link->priv;\n\n\tsnd_printdd(KERN_DEBUG \"RESUME\\n\");\n\tif (pcmcia_dev_present(link)) {\n\t\t\n\t\tif (chip) {\n\t\t\tsnd_printdd(KERN_DEBUG \"calling snd_vx_resume\\n\");\n\t\t\tsnd_vx_resume(chip);\n\t\t}\n\t}\n\tsnd_printdd(KERN_DEBUG \"resume done!\\n\");\n\n\treturn 0;\n}\n\n#endif\n\n\n \nstatic int vxpocket_probe(struct pcmcia_device *p_dev)\n{\n\tstruct snd_card *card;\n\tstruct snd_vxpocket *vxp;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (!(card_alloc & (1 << i)))\n\t\t\tbreak;\n\t}\n\tif (i >= SNDRV_CARDS) {\n\t\tsnd_printk(KERN_ERR \"vxpocket: too many cards found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (! enable[i])\n\t\treturn -ENODEV;  \n\n\t \n\terr = snd_card_new(&p_dev->dev, index[i], id[i], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"vxpocket: cannot create a card instance\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_vxpocket_new(card, ibl[i], p_dev, &vxp);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tcard->private_data = vxp;\n\n\tvxp->index = i;\n\tcard_alloc |= 1 << i;\n\n\tvxp->p_dev = p_dev;\n\n\treturn vxpocket_config(p_dev);\n}\n\nstatic void vxpocket_detach(struct pcmcia_device *link)\n{\n\tstruct snd_vxpocket *vxp;\n\tstruct vx_core *chip;\n\n\tif (! link)\n\t\treturn;\n\n\tvxp = link->priv;\n\tchip = (struct vx_core *)vxp;\n\tcard_alloc &= ~(1 << vxp->index);\n\n\tchip->chip_status |= VX_STAT_IS_STALE;  \n\tsnd_card_disconnect(chip->card);\n\tvxpocket_release(link);\n\tsnd_card_free_when_closed(chip->card);\n}\n\n \n\nstatic const struct pcmcia_device_id vxp_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x01f1, 0x0100),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, vxp_ids);\n\nstatic struct pcmcia_driver vxp_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"snd-vxpocket\",\n\t.probe\t\t= vxpocket_probe,\n\t.remove\t\t= vxpocket_detach,\n\t.id_table\t= vxp_ids,\n#ifdef CONFIG_PM\n\t.suspend\t= vxp_suspend,\n\t.resume\t\t= vxp_resume,\n#endif\n};\nmodule_pcmcia_driver(vxp_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}