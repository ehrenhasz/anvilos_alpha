{
  "module_name": "vxp_mixer.c",
  "hash_id": "0f55be0e1093755d831627333d0e521e7dd9a3d5d859c3410846304b84f3f6aa",
  "original_prompt": "Ingested from linux-6.6.14/sound/pcmcia/vx/vxp_mixer.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"vxpocket.h\"\n\n#define MIC_LEVEL_MIN\t0\n#define MIC_LEVEL_MAX\t8\n\n \nstatic int vx_mic_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = MIC_LEVEL_MAX;\n\treturn 0;\n}\n\nstatic int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tucontrol->value.integer.value[0] = chip->mic_level;\n\treturn 0;\n}\n\nstatic int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tunsigned int val = ucontrol->value.integer.value[0];\n\n\tif (val > MIC_LEVEL_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&_chip->mixer_mutex);\n\tif (chip->mic_level != ucontrol->value.integer.value[0]) {\n\t\tvx_set_mic_level(_chip, ucontrol->value.integer.value[0]);\n\t\tchip->mic_level = ucontrol->value.integer.value[0];\n\t\tmutex_unlock(&_chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&_chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_mic, -21, 3, 0);\n\nstatic const struct snd_kcontrol_new vx_control_mic_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"Mic Capture Volume\",\n\t.info =\t\tvx_mic_level_info,\n\t.get =\t\tvx_mic_level_get,\n\t.put =\t\tvx_mic_level_put,\n\t.tlv = { .p = db_scale_mic },\n};\n\n \n#define vx_mic_boost_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int vx_mic_boost_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tucontrol->value.integer.value[0] = chip->mic_level;\n\treturn 0;\n}\n\nstatic int vx_mic_boost_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tint val = !!ucontrol->value.integer.value[0];\n\tmutex_lock(&_chip->mixer_mutex);\n\tif (chip->mic_level != val) {\n\t\tvx_set_mic_boost(_chip, val);\n\t\tchip->mic_level = val;\n\t\tmutex_unlock(&_chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&_chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_mic_boost = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Mic Boost\",\n\t.info =\t\tvx_mic_boost_info,\n\t.get =\t\tvx_mic_boost_get,\n\t.put =\t\tvx_mic_boost_put,\n};\n\n\nint vxp_add_mic_controls(struct vx_core *_chip)\n{\n\tstruct snd_vxpocket *chip = to_vxpocket(_chip);\n\tint err;\n\n\t \n\tchip->mic_level = 0;\n\tswitch (_chip->type) {\n\tcase VX_TYPE_VXPOCKET:\n\t\tvx_set_mic_level(_chip, 0);\n\t\tbreak;\n\tcase VX_TYPE_VXP440:\n\t\tvx_set_mic_boost(_chip, 0);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (_chip->type) {\n\tcase VX_TYPE_VXPOCKET:\n\t\terr = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase VX_TYPE_VXP440:\n\t\terr = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_boost, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}