{
  "module_name": "harmony.c",
  "hash_id": "84dfadc076f122fb3a2681160e51c03493537e93e7c85a7ebd7b3b1fba00c104",
  "original_prompt": "Ingested from linux-6.6.14/sound/parisc/harmony.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include <sound/rawmidi.h>\n#include <sound/initval.h>\n#include <sound/info.h>\n\n#include <asm/hardware.h>\n#include <asm/parisc-device.h>\n\n#include \"harmony.h\"\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for Harmony driver.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for Harmony driver.\");\n\n\nstatic const struct parisc_device_id snd_harmony_devtable[] __initconst = {\n\t \n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007A }, \n\t \n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007B }, \n\t \n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007E }, \n\t \n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007F },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, snd_harmony_devtable);\n\n#define NAME \"harmony\"\n#define PFX  NAME \": \"\n\nstatic const unsigned int snd_harmony_rates[] = {\n\t5512, 6615, 8000, 9600,\n\t11025, 16000, 18900, 22050,\n\t27428, 32000, 33075, 37800,\n\t44100, 48000\n};\n\nstatic const unsigned int rate_bits[14] = {\n\tHARMONY_SR_5KHZ, HARMONY_SR_6KHZ, HARMONY_SR_8KHZ,\n\tHARMONY_SR_9KHZ, HARMONY_SR_11KHZ, HARMONY_SR_16KHZ,\n\tHARMONY_SR_18KHZ, HARMONY_SR_22KHZ, HARMONY_SR_27KHZ,\n\tHARMONY_SR_32KHZ, HARMONY_SR_33KHZ, HARMONY_SR_37KHZ,\n\tHARMONY_SR_44KHZ, HARMONY_SR_48KHZ\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraint_rates = {\n\t.count = ARRAY_SIZE(snd_harmony_rates),\n\t.list = snd_harmony_rates,\n\t.mask = 0,\n};\n\nstatic inline unsigned long\nharmony_read(struct snd_harmony *h, unsigned r)\n{\n\treturn __raw_readl(h->iobase + r);\n}\n\nstatic inline void\nharmony_write(struct snd_harmony *h, unsigned r, unsigned long v)\n{\n\t__raw_writel(v, h->iobase + r);\n}\n\nstatic inline void\nharmony_wait_for_control(struct snd_harmony *h)\n{\n\twhile (harmony_read(h, HARMONY_CNTL) & HARMONY_CNTL_C) ;\n}\n\nstatic inline void\nharmony_reset(struct snd_harmony *h)\n{\n\tharmony_write(h, HARMONY_RESET, 1);\n\tmdelay(50);\n\tharmony_write(h, HARMONY_RESET, 0);\n}\n\nstatic void\nharmony_disable_interrupts(struct snd_harmony *h)\n{\n\tu32 dstatus;\n\tharmony_wait_for_control(h);\n\tdstatus = harmony_read(h, HARMONY_DSTATUS);\n\tdstatus &= ~HARMONY_DSTATUS_IE;\n\tharmony_write(h, HARMONY_DSTATUS, dstatus);\n}\n\nstatic void\nharmony_enable_interrupts(struct snd_harmony *h)\n{\n\tu32 dstatus;\n\tharmony_wait_for_control(h);\n\tdstatus = harmony_read(h, HARMONY_DSTATUS);\n\tdstatus |= HARMONY_DSTATUS_IE;\n\tharmony_write(h, HARMONY_DSTATUS, dstatus);\n}\n\nstatic void\nharmony_mute(struct snd_harmony *h)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->mixer_lock, flags);\n\tharmony_wait_for_control(h);\n\tharmony_write(h, HARMONY_GAINCTL, HARMONY_GAIN_SILENCE);\n\tspin_unlock_irqrestore(&h->mixer_lock, flags);\n}\n\nstatic void\nharmony_unmute(struct snd_harmony *h)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->mixer_lock, flags);\n\tharmony_wait_for_control(h);\n\tharmony_write(h, HARMONY_GAINCTL, h->st.gain);\n\tspin_unlock_irqrestore(&h->mixer_lock, flags);\n}\n\nstatic void\nharmony_set_control(struct snd_harmony *h)\n{\n\tu32 ctrl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&h->lock, flags);\n\n\tctrl = (HARMONY_CNTL_C      |\n\t\t(h->st.format << 6) |\n\t\t(h->st.stereo << 5) |\n\t\t(h->st.rate));\n\n\tharmony_wait_for_control(h);\n\tharmony_write(h, HARMONY_CNTL, ctrl);\n\n\tspin_unlock_irqrestore(&h->lock, flags);\n}\n\nstatic irqreturn_t\nsnd_harmony_interrupt(int irq, void *dev)\n{\n\tu32 dstatus;\n\tstruct snd_harmony *h = dev;\n\n\tspin_lock(&h->lock);\n\tharmony_disable_interrupts(h);\n\tharmony_wait_for_control(h);\n\tdstatus = harmony_read(h, HARMONY_DSTATUS);\n\tspin_unlock(&h->lock);\n\n\tif (dstatus & HARMONY_DSTATUS_PN) {\n\t\tif (h->psubs && h->st.playing) {\n\t\t\tspin_lock(&h->lock);\n\t\t\th->pbuf.buf += h->pbuf.count;  \n\t\t\th->pbuf.buf %= h->pbuf.size;  \n\n\t\t\tharmony_write(h, HARMONY_PNXTADD, \n\t\t\t\t      h->pbuf.addr + h->pbuf.buf);\n\t\t\th->stats.play_intr++;\n\t\t\tspin_unlock(&h->lock);\n                        snd_pcm_period_elapsed(h->psubs);\n\t\t} else {\n\t\t\tspin_lock(&h->lock);\n\t\t\tharmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\n\t\t\th->stats.silence_intr++;\n\t\t\tspin_unlock(&h->lock);\n\t\t}\n\t}\n\n\tif (dstatus & HARMONY_DSTATUS_RN) {\n\t\tif (h->csubs && h->st.capturing) {\n\t\t\tspin_lock(&h->lock);\n\t\t\th->cbuf.buf += h->cbuf.count;\n\t\t\th->cbuf.buf %= h->cbuf.size;\n\n\t\t\tharmony_write(h, HARMONY_RNXTADD,\n\t\t\t\t      h->cbuf.addr + h->cbuf.buf);\n\t\t\th->stats.rec_intr++;\n\t\t\tspin_unlock(&h->lock);\n                        snd_pcm_period_elapsed(h->csubs);\n\t\t} else {\n\t\t\tspin_lock(&h->lock);\n\t\t\tharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\n\t\t\th->stats.graveyard_intr++;\n\t\t\tspin_unlock(&h->lock);\n\t\t}\n\t}\n\n\tspin_lock(&h->lock);\n\tharmony_enable_interrupts(h);\n\tspin_unlock(&h->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int \nsnd_harmony_rate_bits(int rate)\n{\n\tunsigned int i;\n\t\n\tfor (i = 0; i < ARRAY_SIZE(snd_harmony_rates); i++)\n\t\tif (snd_harmony_rates[i] == rate)\n\t\t\treturn rate_bits[i];\n\n\treturn HARMONY_SR_44KHZ;\n}\n\nstatic const struct snd_pcm_hardware snd_harmony_playback =\n{\n\t.info =\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | \n\t\t SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.formats = (SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_MU_LAW |\n\t\t    SNDRV_PCM_FMTBIT_A_LAW),\n\t.rates = (SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000 |\n\t\t  SNDRV_PCM_RATE_KNOT),\n\t.rate_min = 5512,\n\t.rate_max = 48000,\n\t.channels_min =\t1,\n\t.channels_max =\t2,\n\t.buffer_bytes_max = MAX_BUF_SIZE,\n\t.period_bytes_min = BUF_SIZE,\n\t.period_bytes_max = BUF_SIZE,\n\t.periods_min = 1,\n\t.periods_max = MAX_BUFS,\n\t.fifo_size = 0,\n};\n\nstatic const struct snd_pcm_hardware snd_harmony_capture =\n{\n        .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n                 SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |\n                 SNDRV_PCM_INFO_BLOCK_TRANSFER),\n        .formats = (SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_MU_LAW |\n                    SNDRV_PCM_FMTBIT_A_LAW),\n        .rates = (SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000 |\n\t\t  SNDRV_PCM_RATE_KNOT),\n        .rate_min = 5512,\n        .rate_max = 48000,\n        .channels_min = 1,\n        .channels_max = 2,\n        .buffer_bytes_max = MAX_BUF_SIZE,\n        .period_bytes_min = BUF_SIZE,\n        .period_bytes_max = BUF_SIZE,\n        .periods_min = 1,\n        .periods_max = MAX_BUFS,\n        .fifo_size = 0,\n};\n\nstatic int\nsnd_harmony_playback_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n\tstruct snd_harmony *h = snd_pcm_substream_chip(ss);\n\n\tif (h->st.capturing)\n\t\treturn -EBUSY;\n\n\tspin_lock(&h->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\th->st.playing = 1;\n\t\tharmony_write(h, HARMONY_PNXTADD, h->pbuf.addr);\n\t\tharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\n\t\tharmony_unmute(h);\n\t\tharmony_enable_interrupts(h);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\th->st.playing = 0;\n\t\tharmony_mute(h);\n\t\tharmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\n\t\tharmony_disable_interrupts(h);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tdefault:\n\t\tspin_unlock(&h->lock);\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock(&h->lock);\n\t\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_capture_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n        struct snd_harmony *h = snd_pcm_substream_chip(ss);\n\n\tif (h->st.playing)\n\t\treturn -EBUSY;\n\n\tspin_lock(&h->lock);\n        switch (cmd) {\n        case SNDRV_PCM_TRIGGER_START:\n\t\th->st.capturing = 1;\n                harmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\n                harmony_write(h, HARMONY_RNXTADD, h->cbuf.addr);\n\t\tharmony_unmute(h);\n                harmony_enable_interrupts(h);\n\t\tbreak;\n        case SNDRV_PCM_TRIGGER_STOP:\n\t\th->st.capturing = 0;\n\t\tharmony_mute(h);\n\t\tharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\n\t\tharmony_disable_interrupts(h);\n\t\tbreak;\n        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n        case SNDRV_PCM_TRIGGER_SUSPEND:\n\tdefault:\n\t\tspin_unlock(&h->lock);\n\t\tsnd_BUG();\n                return -EINVAL;\n        }\n\tspin_unlock(&h->lock);\n\t\t\n        return 0;\n}\n\nstatic int\nsnd_harmony_set_data_format(struct snd_harmony *h, int fmt, int force)\n{\n\tint o = h->st.format;\n\tint n;\n\n\tswitch(fmt) {\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tn = HARMONY_DF_16BIT_LINEAR;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tn = HARMONY_DF_8BIT_ALAW;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tn = HARMONY_DF_8BIT_ULAW;\n\t\tbreak;\n\tdefault:\n\t\tn = HARMONY_DF_16BIT_LINEAR;\n\t\tbreak;\n\t}\n\n\tif (force || o != n) {\n\t\tsnd_pcm_format_set_silence(fmt, h->sdma.area, SILENCE_BUFSZ / \n\t\t\t\t\t   (snd_pcm_format_physical_width(fmt)\n\t\t\t\t\t    / 8));\n\t}\n\n\treturn n;\n}\n\nstatic int\nsnd_harmony_playback_prepare(struct snd_pcm_substream *ss)\n{\n\tstruct snd_harmony *h = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\t\n\tif (h->st.capturing)\n\t\treturn -EBUSY;\n\t\n\th->pbuf.size = snd_pcm_lib_buffer_bytes(ss);\n\th->pbuf.count = snd_pcm_lib_period_bytes(ss);\n\tif (h->pbuf.buf >= h->pbuf.size)\n\t\th->pbuf.buf = 0;\n\th->st.playing = 0;\n\n\th->st.rate = snd_harmony_rate_bits(rt->rate);\n\th->st.format = snd_harmony_set_data_format(h, rt->format, 0);\n\t\n\tif (rt->channels == 2)\n\t\th->st.stereo = HARMONY_SS_STEREO;\n\telse\n\t\th->st.stereo = HARMONY_SS_MONO;\n\n\tharmony_set_control(h);\n\n\th->pbuf.addr = rt->dma_addr;\n\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_capture_prepare(struct snd_pcm_substream *ss)\n{\n        struct snd_harmony *h = snd_pcm_substream_chip(ss);\n        struct snd_pcm_runtime *rt = ss->runtime;\n\n\tif (h->st.playing)\n\t\treturn -EBUSY;\n\n        h->cbuf.size = snd_pcm_lib_buffer_bytes(ss);\n        h->cbuf.count = snd_pcm_lib_period_bytes(ss);\n\tif (h->cbuf.buf >= h->cbuf.size)\n\t        h->cbuf.buf = 0;\n\th->st.capturing = 0;\n\n        h->st.rate = snd_harmony_rate_bits(rt->rate);\n        h->st.format = snd_harmony_set_data_format(h, rt->format, 0);\n\n        if (rt->channels == 2)\n                h->st.stereo = HARMONY_SS_STEREO;\n        else\n                h->st.stereo = HARMONY_SS_MONO;\n\n        harmony_set_control(h);\n\n        h->cbuf.addr = rt->dma_addr;\n\n        return 0;\n}\n\nstatic snd_pcm_uframes_t \nsnd_harmony_playback_pointer(struct snd_pcm_substream *ss)\n{\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tstruct snd_harmony *h = snd_pcm_substream_chip(ss);\n\tunsigned long pcuradd;\n\tunsigned long played;\n\n\tif (!(h->st.playing) || (h->psubs == NULL)) \n\t\treturn 0;\n\n\tif ((h->pbuf.addr == 0) || (h->pbuf.size == 0))\n\t\treturn 0;\n\t\n\tpcuradd = harmony_read(h, HARMONY_PCURADD);\n\tplayed = pcuradd - h->pbuf.addr;\n\n#ifdef HARMONY_DEBUG\n\tprintk(KERN_DEBUG PFX \"playback_pointer is 0x%lx-0x%lx = %d bytes\\n\", \n\t       pcuradd, h->pbuf.addr, played);\t\n#endif\n\n\tif (pcuradd > h->pbuf.addr + h->pbuf.size) {\n\t\treturn 0;\n\t}\n\n\treturn bytes_to_frames(rt, played);\n}\n\nstatic snd_pcm_uframes_t\nsnd_harmony_capture_pointer(struct snd_pcm_substream *ss)\n{\n        struct snd_pcm_runtime *rt = ss->runtime;\n        struct snd_harmony *h = snd_pcm_substream_chip(ss);\n        unsigned long rcuradd;\n        unsigned long caught;\n\n        if (!(h->st.capturing) || (h->csubs == NULL))\n                return 0;\n\n        if ((h->cbuf.addr == 0) || (h->cbuf.size == 0))\n                return 0;\n\n        rcuradd = harmony_read(h, HARMONY_RCURADD);\n        caught = rcuradd - h->cbuf.addr;\n\n#ifdef HARMONY_DEBUG\n        printk(KERN_DEBUG PFX \"capture_pointer is 0x%lx-0x%lx = %d bytes\\n\",\n               rcuradd, h->cbuf.addr, caught);\n#endif\n\n        if (rcuradd > h->cbuf.addr + h->cbuf.size) {\n\t\treturn 0;\n\t}\n\n        return bytes_to_frames(rt, caught);\n}\n\nstatic int \nsnd_harmony_playback_open(struct snd_pcm_substream *ss)\n{\n\tstruct snd_harmony *h = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tint err;\n\t\n\th->psubs = ss;\n\trt->hw = snd_harmony_playback;\n\tsnd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE, \n\t\t\t\t   &hw_constraint_rates);\n\t\n\terr = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\t\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_capture_open(struct snd_pcm_substream *ss)\n{\n        struct snd_harmony *h = snd_pcm_substream_chip(ss);\n        struct snd_pcm_runtime *rt = ss->runtime;\n        int err;\n\n        h->csubs = ss;\n        rt->hw = snd_harmony_capture;\n        snd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE,\n                                   &hw_constraint_rates);\n\n        err = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\n        if (err < 0)\n                return err;\n\n        return 0;\n}\n\nstatic int \nsnd_harmony_playback_close(struct snd_pcm_substream *ss)\n{\n\tstruct snd_harmony *h = snd_pcm_substream_chip(ss);\n\th->psubs = NULL;\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_capture_close(struct snd_pcm_substream *ss)\n{\n        struct snd_harmony *h = snd_pcm_substream_chip(ss);\n        h->csubs = NULL;\n        return 0;\n}\n\nstatic const struct snd_pcm_ops snd_harmony_playback_ops = {\n\t.open =\tsnd_harmony_playback_open,\n\t.close = snd_harmony_playback_close,\n\t.prepare = snd_harmony_playback_prepare,\n\t.trigger = snd_harmony_playback_trigger,\n \t.pointer = snd_harmony_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_harmony_capture_ops = {\n        .open = snd_harmony_capture_open,\n        .close = snd_harmony_capture_close,\n        .prepare = snd_harmony_capture_prepare,\n        .trigger = snd_harmony_capture_trigger,\n        .pointer = snd_harmony_capture_pointer,\n};\n\nstatic int \nsnd_harmony_pcm_init(struct snd_harmony *h)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tif (snd_BUG_ON(!h))\n\t\treturn -EINVAL;\n\n\tharmony_disable_interrupts(h);\n\t\n   \terr = snd_pcm_new(h->card, \"harmony\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, \n\t\t\t&snd_harmony_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_harmony_capture_ops);\n\n\tpcm->private_data = h;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"harmony\");\n\th->pcm = pcm;\n\n\th->psubs = NULL;\n\th->csubs = NULL;\n\t\n\t \n\th->dma.type = SNDRV_DMA_TYPE_DEV;\n\th->dma.dev = &h->dev->dev;\n\terr = snd_dma_alloc_pages(h->dma.type,\n\t\t\t\t  h->dma.dev,\n\t\t\t\t  BUF_SIZE*GRAVEYARD_BUFS,\n\t\t\t\t  &h->gdma);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"cannot allocate graveyard buffer!\\n\");\n\t\treturn err;\n\t}\n\t\n\t \n\terr = snd_dma_alloc_pages(h->dma.type,\n\t\t\t\t  h->dma.dev,\n\t\t\t\t  BUF_SIZE*SILENCE_BUFS,\n\t\t\t\t  &h->sdma);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR PFX \"cannot allocate silence buffer!\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, h->dma.type, h->dma.dev,\n\t\t\t\t       MAX_BUF_SIZE, MAX_BUF_SIZE);\n\n\th->st.format = snd_harmony_set_data_format(h,\n\t\tSNDRV_PCM_FORMAT_S16_BE, 1);\n\n\treturn 0;\n}\n\nstatic void \nsnd_harmony_set_new_gain(struct snd_harmony *h)\n{\n \tharmony_wait_for_control(h);\n\tharmony_write(h, HARMONY_GAINCTL, h->st.gain);\n}\n\nstatic int \nsnd_harmony_mixercontrol_info(struct snd_kcontrol *kc, \n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kc->private_value >> 16) & 0xff;\n\tint left_shift = (kc->private_value) & 0xff;\n\tint right_shift = (kc->private_value >> 8) & 0xff;\n\t\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : \n\t\t       SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = left_shift == right_shift ? 1 : 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\n\treturn 0;\n}\n\nstatic int \nsnd_harmony_volume_get(struct snd_kcontrol *kc, \n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_harmony *h = snd_kcontrol_chip(kc);\n\tint shift_left = (kc->private_value) & 0xff;\n\tint shift_right = (kc->private_value >> 8) & 0xff;\n\tint mask = (kc->private_value >> 16) & 0xff;\n\tint invert = (kc->private_value >> 24) & 0xff;\n\tint left, right;\n\t\n\tspin_lock_irq(&h->mixer_lock);\n\n\tleft = (h->st.gain >> shift_left) & mask;\n\tright = (h->st.gain >> shift_right) & mask;\n\tif (invert) {\n\t\tleft = mask - left;\n\t\tright = mask - right;\n\t}\n\t\n\tucontrol->value.integer.value[0] = left;\n\tif (shift_left != shift_right)\n\t\tucontrol->value.integer.value[1] = right;\n\n\tspin_unlock_irq(&h->mixer_lock);\n\n\treturn 0;\n}  \n\nstatic int \nsnd_harmony_volume_put(struct snd_kcontrol *kc, \n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_harmony *h = snd_kcontrol_chip(kc);\n\tint shift_left = (kc->private_value) & 0xff;\n\tint shift_right = (kc->private_value >> 8) & 0xff;\n\tint mask = (kc->private_value >> 16) & 0xff;\n\tint invert = (kc->private_value >> 24) & 0xff;\n\tint left, right;\n\tint old_gain = h->st.gain;\n\t\n\tspin_lock_irq(&h->mixer_lock);\n\n\tleft = ucontrol->value.integer.value[0] & mask;\n\tif (invert)\n\t\tleft = mask - left;\n\th->st.gain &= ~( (mask << shift_left ) );\n \th->st.gain |= (left << shift_left);\n\n\tif (shift_left != shift_right) {\n\t\tright = ucontrol->value.integer.value[1] & mask;\n\t\tif (invert)\n\t\t\tright = mask - right;\n\t\th->st.gain &= ~( (mask << shift_right) );\n\t\th->st.gain |= (right << shift_right);\n\t}\n\n\tsnd_harmony_set_new_gain(h);\n\n\tspin_unlock_irq(&h->mixer_lock);\n\t\n\treturn h->st.gain != old_gain;\n}\n\nstatic int \nsnd_harmony_captureroute_info(struct snd_kcontrol *kc, \n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"Line\", \"Mic\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int \nsnd_harmony_captureroute_get(struct snd_kcontrol *kc, \n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_harmony *h = snd_kcontrol_chip(kc);\n\tint value;\n\t\n\tspin_lock_irq(&h->mixer_lock);\n\n\tvalue = (h->st.gain >> HARMONY_GAIN_IS_SHIFT) & 1;\n\tucontrol->value.enumerated.item[0] = value;\n\n\tspin_unlock_irq(&h->mixer_lock);\n\n\treturn 0;\n}  \n\nstatic int \nsnd_harmony_captureroute_put(struct snd_kcontrol *kc, \n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_harmony *h = snd_kcontrol_chip(kc);\n\tint value;\n\tint old_gain = h->st.gain;\n\t\n\tspin_lock_irq(&h->mixer_lock);\n\n\tvalue = ucontrol->value.enumerated.item[0] & 1;\n\th->st.gain &= ~HARMONY_GAIN_IS_MASK;\n \th->st.gain |= value << HARMONY_GAIN_IS_SHIFT;\n\n\tsnd_harmony_set_new_gain(h);\n\n\tspin_unlock_irq(&h->mixer_lock);\n\t\n\treturn h->st.gain != old_gain;\n}\n\n#define HARMONY_CONTROLS\tARRAY_SIZE(snd_harmony_controls)\n\n#define HARMONY_VOLUME(xname, left_shift, right_shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,                \\\n  .info = snd_harmony_mixercontrol_info,                             \\\n  .get = snd_harmony_volume_get, .put = snd_harmony_volume_put,      \\\n  .private_value = ((left_shift) | ((right_shift) << 8) |            \\\n                   ((mask) << 16) | ((invert) << 24)) }\n\nstatic const struct snd_kcontrol_new snd_harmony_controls[] = {\n\tHARMONY_VOLUME(\"Master Playback Volume\", HARMONY_GAIN_LO_SHIFT, \n\t\t       HARMONY_GAIN_RO_SHIFT, HARMONY_GAIN_OUT, 1),\n\tHARMONY_VOLUME(\"Capture Volume\", HARMONY_GAIN_LI_SHIFT,\n\t\t       HARMONY_GAIN_RI_SHIFT, HARMONY_GAIN_IN, 0),\n\tHARMONY_VOLUME(\"Monitor Volume\", HARMONY_GAIN_MA_SHIFT,\n\t\t       HARMONY_GAIN_MA_SHIFT, HARMONY_GAIN_MA, 1),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input Route\",\n\t\t.info = snd_harmony_captureroute_info,\n\t\t.get = snd_harmony_captureroute_get,\n\t\t.put = snd_harmony_captureroute_put\n\t},\n\tHARMONY_VOLUME(\"Internal Speaker Switch\", HARMONY_GAIN_SE_SHIFT,\n\t\t       HARMONY_GAIN_SE_SHIFT, 1, 0),\n\tHARMONY_VOLUME(\"Line-Out Switch\", HARMONY_GAIN_LE_SHIFT,\n\t\t       HARMONY_GAIN_LE_SHIFT, 1, 0),\n\tHARMONY_VOLUME(\"Headphones Switch\", HARMONY_GAIN_HE_SHIFT,\n\t\t       HARMONY_GAIN_HE_SHIFT, 1, 0),\n};\n\nstatic void\nsnd_harmony_mixer_reset(struct snd_harmony *h)\n{\n\tharmony_mute(h);\n\tharmony_reset(h);\n\th->st.gain = HARMONY_GAIN_DEFAULT;\n\tharmony_unmute(h);\n}\n\nstatic int\nsnd_harmony_mixer_init(struct snd_harmony *h)\n{\n\tstruct snd_card *card;\n\tint idx, err;\n\n\tif (snd_BUG_ON(!h))\n\t\treturn -EINVAL;\n\tcard = h->card;\n\tstrcpy(card->mixername, \"Harmony Gain control interface\");\n\n\tfor (idx = 0; idx < HARMONY_CONTROLS; idx++) {\n\t\terr = snd_ctl_add(card, \n\t\t\t\t  snd_ctl_new1(&snd_harmony_controls[idx], h));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t\n\tsnd_harmony_mixer_reset(h);\n\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_free(struct snd_harmony *h)\n{\n        if (h->gdma.addr)\n                snd_dma_free_pages(&h->gdma);\n        if (h->sdma.addr)\n                snd_dma_free_pages(&h->sdma);\n\n\tif (h->irq >= 0)\n\t\tfree_irq(h->irq, h);\n\n\tiounmap(h->iobase);\n\tkfree(h);\n\treturn 0;\n}\n\nstatic int\nsnd_harmony_dev_free(struct snd_device *dev)\n{\n\tstruct snd_harmony *h = dev->device_data;\n\treturn snd_harmony_free(h);\n}\n\nstatic int\nsnd_harmony_create(struct snd_card *card, \n\t\t   struct parisc_device *padev, \n\t\t   struct snd_harmony **rchip)\n{\n\tint err;\n\tstruct snd_harmony *h;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_harmony_dev_free,\n\t};\n\n\t*rchip = NULL;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (h == NULL)\n\t\treturn -ENOMEM;\n\n\th->hpa = padev->hpa.start;\n\th->card = card;\n\th->dev = padev;\n\th->irq = -1;\n\th->iobase = ioremap(padev->hpa.start, HARMONY_SIZE);\n\tif (h->iobase == NULL) {\n\t\tprintk(KERN_ERR PFX \"unable to remap hpa 0x%lx\\n\",\n\t\t       (unsigned long)padev->hpa.start);\n\t\terr = -EBUSY;\n\t\tgoto free_and_ret;\n\t}\n\t\t\n\terr = request_irq(padev->irq, snd_harmony_interrupt, 0,\n\t\t\t  \"harmony\", h);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"could not obtain interrupt %d\",\n\t\t       padev->irq);\n\t\tgoto free_and_ret;\n\t}\n\th->irq = padev->irq;\n\n\tspin_lock_init(&h->mixer_lock);\n\tspin_lock_init(&h->lock);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, h, &ops);\n\tif (err < 0)\n\t\tgoto free_and_ret;\n\n\t*rchip = h;\n\n\treturn 0;\n\nfree_and_ret:\n\tsnd_harmony_free(h);\n\treturn err;\n}\n\nstatic int __init\nsnd_harmony_probe(struct parisc_device *padev)\n{\n\tint err;\n\tstruct snd_card *card;\n\tstruct snd_harmony *h;\n\n\terr = snd_card_new(&padev->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_harmony_create(card, padev, &h);\n\tif (err < 0)\n\t\tgoto free_and_ret;\n\n\terr = snd_harmony_pcm_init(h);\n\tif (err < 0)\n\t\tgoto free_and_ret;\n\n\terr = snd_harmony_mixer_init(h);\n\tif (err < 0)\n\t\tgoto free_and_ret;\n\n\tstrcpy(card->driver, \"harmony\");\n\tstrcpy(card->shortname, \"Harmony\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, h->hpa, h->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto free_and_ret;\n\n\tparisc_set_drvdata(padev, card);\n\treturn 0;\n\nfree_and_ret:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void __exit\nsnd_harmony_remove(struct parisc_device *padev)\n{\n\tsnd_card_free(parisc_get_drvdata(padev));\n}\n\nstatic struct parisc_driver snd_harmony_driver __refdata = {\n\t.name = \"harmony\",\n\t.id_table = snd_harmony_devtable,\n\t.probe = snd_harmony_probe,\n\t.remove = __exit_p(snd_harmony_remove),\n};\n\nstatic int __init \nalsa_harmony_init(void)\n{\n\treturn register_parisc_driver(&snd_harmony_driver);\n}\n\nstatic void __exit\nalsa_harmony_fini(void)\n{\n\tunregister_parisc_driver(&snd_harmony_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kyle McMartin <kyle@parisc-linux.org>\");\nMODULE_DESCRIPTION(\"Harmony sound driver\");\n\nmodule_init(alsa_harmony_init);\nmodule_exit(alsa_harmony_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}