{
  "module_name": "cs8427.c",
  "hash_id": "640b9359dc33ea6f310bfd107348597b231a7823835320e8054019d98a4cf521",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/cs8427.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/cs8427.h>\n#include <sound/asoundef.h>\n\nstatic void snd_cs8427_reset(struct snd_i2c_device *cs8427);\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic\");\nMODULE_LICENSE(\"GPL\");\n\n#define CS8427_ADDR\t\t\t(0x20>>1)  \n\nstruct cs8427_stream {\n\tstruct snd_pcm_substream *substream;\n\tchar hw_status[24];\t\t \n\tchar def_status[24];\t\t \n\tchar pcm_status[24];\t\t \n\tchar hw_udata[32];\n\tstruct snd_kcontrol *pcm_ctl;\n};\n\nstruct cs8427 {\n\tunsigned char regmap[0x14];\t \n\tunsigned int rate;\n\tunsigned int reset_timeout;\n\tstruct cs8427_stream playback;\n\tstruct cs8427_stream capture;\n};\n\nint snd_cs8427_reg_write(struct snd_i2c_device *device, unsigned char reg,\n\t\t\t unsigned char val)\n{\n\tint err;\n\tunsigned char buf[2];\n\n\tbuf[0] = reg & 0x7f;\n\tbuf[1] = val;\n\terr = snd_i2c_sendbytes(device, buf, 2);\n\tif (err != 2) {\n\t\tsnd_printk(KERN_ERR \"unable to send bytes 0x%02x:0x%02x \"\n\t\t\t   \"to CS8427 (%i)\\n\", buf[0], buf[1], err);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_cs8427_reg_write);\n\nstatic int snd_cs8427_reg_read(struct snd_i2c_device *device, unsigned char reg)\n{\n\tint err;\n\tunsigned char buf;\n\n\terr = snd_i2c_sendbytes(device, &reg, 1);\n\tif (err != 1) {\n\t\tsnd_printk(KERN_ERR \"unable to send register 0x%x byte \"\n\t\t\t   \"to CS8427\\n\", reg);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\terr = snd_i2c_readbytes(device, &buf, 1);\n\tif (err != 1) {\n\t\tsnd_printk(KERN_ERR \"unable to read register 0x%x byte \"\n\t\t\t   \"from CS8427\\n\", reg);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\treturn buf;\n}\n\nstatic int snd_cs8427_select_corudata(struct snd_i2c_device *device, int udata)\n{\n\tstruct cs8427 *chip = device->private_data;\n\tint err;\n\n\tudata = udata ? CS8427_BSEL : 0;\n\tif (udata != (chip->regmap[CS8427_REG_CSDATABUF] & udata)) {\n\t\tchip->regmap[CS8427_REG_CSDATABUF] &= ~CS8427_BSEL;\n\t\tchip->regmap[CS8427_REG_CSDATABUF] |= udata;\n\t\terr = snd_cs8427_reg_write(device, CS8427_REG_CSDATABUF,\n\t\t\t\t\t   chip->regmap[CS8427_REG_CSDATABUF]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_cs8427_send_corudata(struct snd_i2c_device *device,\n\t\t\t\t    int udata,\n\t\t\t\t    unsigned char *ndata,\n\t\t\t\t    int count)\n{\n\tstruct cs8427 *chip = device->private_data;\n\tchar *hw_data = udata ?\n\t\tchip->playback.hw_udata : chip->playback.hw_status;\n\tunsigned char data[32];\n\tint err, idx;\n\n\tif (!memcmp(hw_data, ndata, count))\n\t\treturn 0;\n\terr = snd_cs8427_select_corudata(device, udata);\n\tif (err < 0)\n\t\treturn err;\n\tmemcpy(hw_data, ndata, count);\n\tif (udata) {\n\t\tmemset(data, 0, sizeof(data));\n\t\tif (memcmp(hw_data, data, count) == 0) {\n\t\t\tchip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;\n\t\t\tchip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS |\n\t\t\t\tCS8427_EFTUI;\n\t\t\terr = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF,\n\t\t\t\t\t\t   chip->regmap[CS8427_REG_UDATABUF]);\n\t\t\treturn err < 0 ? err : 0;\n\t\t}\n\t}\n\tdata[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;\n\tfor (idx = 0; idx < count; idx++)\n\t\tdata[idx + 1] = bitrev8(ndata[idx]);\n\tif (snd_i2c_sendbytes(device, data, count + 1) != count + 1)\n\t\treturn -EIO;\n\treturn 1;\n}\n\nstatic void snd_cs8427_free(struct snd_i2c_device *device)\n{\n\tkfree(device->private_data);\n}\n\nint snd_cs8427_init(struct snd_i2c_bus *bus,\n\t\t    struct snd_i2c_device *device)\n{\n\tstatic unsigned char initvals1[] = {\n\t  CS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,\n\t   \n\t  CS8427_SWCLK | CS8427_TCBLDIR,\n\t   \n\t  0x00,\n\t   \n\t  CS8427_TXDSERIAL | CS8427_SPDAES3RECEIVER,\n\t   \n\t  CS8427_RXDILRCK,\n\t   \n\t  CS8427_SIDEL | CS8427_SILRPOL,\n\t   \n\t  CS8427_SODEL | CS8427_SOLRPOL,\n\t};\n\tstatic unsigned char initvals2[] = {\n\t  CS8427_REG_RECVERRMASK | CS8427_REG_AUTOINC,\n\t   \n\t   \n\t  0xff,  \n\t   \n\t  CS8427_CBMR | CS8427_DETCI,\n\t   \n\t  CS8427_UD | CS8427_EFTUI | CS8427_DETUI,\n\t};\n\tstruct cs8427 *chip = device->private_data;\n\tint err;\n\tunsigned char buf[24];\n\n\tsnd_i2c_lock(bus);\n\terr = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);\n\tif (err != CS8427_VER8427A) {\n\t\t \n\t\tsnd_printk(KERN_WARNING \"invalid CS8427 signature 0x%x: \"\n\t\t\t   \"let me try again...\\n\", err);\n\t\terr = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);\n\t}\n\tif (err != CS8427_VER8427A) {\n\t\tsnd_i2c_unlock(bus);\n\t\tsnd_printk(KERN_ERR \"unable to find CS8427 signature \"\n\t\t\t   \"(expected 0x%x, read 0x%x),\\n\",\n\t\t\t   CS8427_VER8427A, err);\n\t\tsnd_printk(KERN_ERR \"   initialization is not completed\\n\");\n\t\treturn -EFAULT;\n\t}\n\t \n\terr = snd_cs8427_reg_write(device, CS8427_REG_CLOCKSOURCE, 0x00);\n\tif (err < 0)\n\t\tgoto __fail;\n\t \n\tmemcpy(chip->regmap + (initvals1[0] & 0x7f), initvals1 + 1, 6);\n\terr = snd_i2c_sendbytes(device, initvals1, 7);\n\tif (err != 7) {\n\t\terr = err < 0 ? err : -EIO;\n\t\tgoto __fail;\n\t}\n\t \n\tmemset(buf, 0, 7);\n\t \n\tbuf[0] = 9;\t \n\terr = snd_i2c_sendbytes(device, buf, 7);\n\tif (err != 7)\n\t\tgoto __fail;\n\t \n\tmemcpy(chip->regmap + (initvals2[0] & 0x7f), initvals2 + 1, 3);\n\terr = snd_i2c_sendbytes(device, initvals2, 4);\n\tif (err != 4) {\n\t\terr = err < 0 ? err : -EIO;\n\t\tgoto __fail;\n\t}\n\t \n\tput_unaligned_le32(SNDRV_PCM_DEFAULT_CON_SPDIF, buf);\n\tmemset(buf + 4, 0, 24 - 4);\n\tif (snd_cs8427_send_corudata(device, 0, buf, 24) < 0)\n\t\tgoto __fail;\n\tmemcpy(chip->playback.def_status, buf, 24);\n\tmemcpy(chip->playback.pcm_status, buf, 24);\n\tsnd_i2c_unlock(bus);\n\n\t \n\tsnd_cs8427_reset(device);\n\n\treturn 0;\n\n__fail:\n\tsnd_i2c_unlock(bus);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_cs8427_init);\n\nint snd_cs8427_create(struct snd_i2c_bus *bus,\n\t\t      unsigned char addr,\n\t\t      unsigned int reset_timeout,\n\t\t      struct snd_i2c_device **r_cs8427)\n{\n\tint err;\n\tstruct cs8427 *chip;\n\tstruct snd_i2c_device *device;\n\n\terr = snd_i2c_device_create(bus, \"CS8427\", CS8427_ADDR | (addr & 7),\n\t\t\t\t    &device);\n\tif (err < 0)\n\t\treturn err;\n\tchip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL) {\n\t\tsnd_i2c_device_free(device);\n\t\treturn -ENOMEM;\n\t}\n\tdevice->private_free = snd_cs8427_free;\n\n\tif (reset_timeout < 1)\n\t\treset_timeout = 1;\n\tchip->reset_timeout = reset_timeout;\n\n\terr = snd_cs8427_init(bus, device);\n\tif (err)\n\t\tgoto __fail;\n\n#if 0\t \n\t{\n\tchar buf[128];\n\tint xx;\n\tbuf[0] = 0x81;\n\tsnd_i2c_sendbytes(device, buf, 1);\n\tsnd_i2c_readbytes(device, buf, 127);\n\tfor (xx = 0; xx < 127; xx++)\n\t\tprintk(KERN_DEBUG \"reg[0x%x] = 0x%x\\n\", xx+1, buf[xx]);\n\t}\n#endif\n\t\n\tif (r_cs8427)\n\t\t*r_cs8427 = device;\n\treturn 0;\n\n      __fail:\n      \tsnd_i2c_device_free(device);\n      \treturn err < 0 ? err : -EIO;\n}\n\nEXPORT_SYMBOL(snd_cs8427_create);\n\n \nstatic void snd_cs8427_reset(struct snd_i2c_device *cs8427)\n{\n\tstruct cs8427 *chip;\n\tunsigned long end_time;\n\tint data, aes3input = 0;\n\n\tif (snd_BUG_ON(!cs8427))\n\t\treturn;\n\tchip = cs8427->private_data;\n\tsnd_i2c_lock(cs8427->bus);\n\tif ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==\n\t    CS8427_RXDAES3INPUT)   \n\t\taes3input = 1;\n\tchip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);\n\tsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\n\t\t\t     chip->regmap[CS8427_REG_CLOCKSOURCE]);\n\tudelay(200);\n\tchip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;\n\tsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\n\t\t\t     chip->regmap[CS8427_REG_CLOCKSOURCE]);\n\tudelay(200);\n\tsnd_i2c_unlock(cs8427->bus);\n\tend_time = jiffies + chip->reset_timeout;\n\twhile (time_after_eq(end_time, jiffies)) {\n\t\tsnd_i2c_lock(cs8427->bus);\n\t\tdata = snd_cs8427_reg_read(cs8427, CS8427_REG_RECVERRORS);\n\t\tsnd_i2c_unlock(cs8427->bus);\n\t\tif (!(data & CS8427_UNLOCK))\n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tsnd_i2c_lock(cs8427->bus);\n\tchip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;\n\tif (aes3input)\n\t\tchip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;\n\tsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\n\t\t\t     chip->regmap[CS8427_REG_CLOCKSOURCE]);\n\tsnd_i2c_unlock(cs8427->bus);\n}\n\nstatic int snd_cs8427_in_status_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_cs8427_in_status_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\n\tint data;\n\n\tsnd_i2c_lock(device->bus);\n\tdata = snd_cs8427_reg_read(device, kcontrol->private_value);\n\tsnd_i2c_unlock(device->bus);\n\tif (data < 0)\n\t\treturn data;\n\tucontrol->value.integer.value[0] = data;\n\treturn 0;\n}\n\nstatic int snd_cs8427_qsubcode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = 10;\n\treturn 0;\n}\n\nstatic int snd_cs8427_qsubcode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\n\tunsigned char reg = CS8427_REG_QSUBCODE;\n\tint err;\n\n\tsnd_i2c_lock(device->bus);\n\terr = snd_i2c_sendbytes(device, &reg, 1);\n\tif (err != 1) {\n\t\tsnd_printk(KERN_ERR \"unable to send register 0x%x byte \"\n\t\t\t   \"to CS8427\\n\", reg);\n\t\tsnd_i2c_unlock(device->bus);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\terr = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10);\n\tif (err != 10) {\n\t\tsnd_printk(KERN_ERR \"unable to read Q-subcode bytes \"\n\t\t\t   \"from CS8427\\n\");\n\t\tsnd_i2c_unlock(device->bus);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\tsnd_i2c_unlock(device->bus);\n\treturn 0;\n}\n\nstatic int snd_cs8427_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cs8427_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\n\tstruct cs8427 *chip = device->private_data;\n\t\n\tsnd_i2c_lock(device->bus);\n\tmemcpy(ucontrol->value.iec958.status, chip->playback.def_status, 24);\n\tsnd_i2c_unlock(device->bus);\n\treturn 0;\n}\n\nstatic int snd_cs8427_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\n\tstruct cs8427 *chip = device->private_data;\n\tunsigned char *status = kcontrol->private_value ?\n\t\tchip->playback.pcm_status : chip->playback.def_status;\n\tstruct snd_pcm_runtime *runtime = chip->playback.substream ?\n\t\tchip->playback.substream->runtime : NULL;\n\tint err, change;\n\n\tsnd_i2c_lock(device->bus);\n\tchange = memcmp(ucontrol->value.iec958.status, status, 24) != 0;\n\tmemcpy(status, ucontrol->value.iec958.status, 24);\n\tif (change && (kcontrol->private_value ?\n\t\t       runtime != NULL : runtime == NULL)) {\n\t\terr = snd_cs8427_send_corudata(device, 0, status, 24);\n\t\tif (err < 0)\n\t\t\tchange = err;\n\t}\n\tsnd_i2c_unlock(device->bus);\n\treturn change;\n}\n\nstatic int snd_cs8427_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cs8427_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff, 24);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.info =\t\tsnd_cs8427_in_status_info,\n\t.name =\t\t\"IEC958 CS8427 Input Status\",\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t.get =\t\tsnd_cs8427_in_status_get,\n\t.private_value = 15,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.info =\t\tsnd_cs8427_in_status_info,\n\t.name =\t\t\"IEC958 CS8427 Error Status\",\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t.get =\t\tsnd_cs8427_in_status_get,\n\t.private_value = 16,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.info =\t\tsnd_cs8427_spdif_mask_info,\n\t.get =\t\tsnd_cs8427_spdif_mask_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_cs8427_spdif_info,\n\t.get =\t\tsnd_cs8427_spdif_get,\n\t.put =\t\tsnd_cs8427_spdif_put,\n\t.private_value = 0\n},\n{\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE),\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_cs8427_spdif_info,\n\t.get =\t\tsnd_cs8427_spdif_get,\n\t.put =\t\tsnd_cs8427_spdif_put,\n\t.private_value = 1\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.info =\t\tsnd_cs8427_qsubcode_info,\n\t.name =\t\t\"IEC958 Q-subcode Capture Default\",\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t.get =\t\tsnd_cs8427_qsubcode_get\n}};\n\nint snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,\n\t\t\t    struct snd_pcm_substream *play_substream,\n\t\t\t    struct snd_pcm_substream *cap_substream)\n{\n\tstruct cs8427 *chip = cs8427->private_data;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!play_substream || !cap_substream))\n\t\treturn -EINVAL;\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs8427_iec958_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_cs8427_iec958_controls[idx], cs8427);\n\t\tif (kctl == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.device = play_substream->pcm->device;\n\t\tkctl->id.subdevice = play_substream->number;\n\t\terr = snd_ctl_add(cs8427->bus->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (! strcmp(kctl->id.name,\n\t\t\t     SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM)))\n\t\t\tchip->playback.pcm_ctl = kctl;\n\t}\n\n\tchip->playback.substream = play_substream;\n\tchip->capture.substream = cap_substream;\n\tif (snd_BUG_ON(!chip->playback.pcm_ctl))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_cs8427_iec958_build);\n\nint snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)\n{\n\tstruct cs8427 *chip;\n\n\tif (snd_BUG_ON(!cs8427))\n\t\treturn -ENXIO;\n\tchip = cs8427->private_data;\n\tif (active) {\n\t\tmemcpy(chip->playback.pcm_status,\n\t\t       chip->playback.def_status, 24);\n\t\tchip->playback.pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tchip->playback.pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tsnd_ctl_notify(cs8427->bus->card,\n\t\t       SNDRV_CTL_EVENT_MASK_VALUE | SNDRV_CTL_EVENT_MASK_INFO,\n\t\t       &chip->playback.pcm_ctl->id);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_cs8427_iec958_active);\n\nint snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)\n{\n\tstruct cs8427 *chip;\n\tchar *status;\n\tint err, reset;\n\n\tif (snd_BUG_ON(!cs8427))\n\t\treturn -ENXIO;\n\tchip = cs8427->private_data;\n\tstatus = chip->playback.pcm_status;\n\tsnd_i2c_lock(cs8427->bus);\n\tif (status[0] & IEC958_AES0_PROFESSIONAL) {\n\t\tstatus[0] &= ~IEC958_AES0_PRO_FS;\n\t\tswitch (rate) {\n\t\tcase 32000: status[0] |= IEC958_AES0_PRO_FS_32000; break;\n\t\tcase 44100: status[0] |= IEC958_AES0_PRO_FS_44100; break;\n\t\tcase 48000: status[0] |= IEC958_AES0_PRO_FS_48000; break;\n\t\tdefault: status[0] |= IEC958_AES0_PRO_FS_NOTID; break;\n\t\t}\n\t} else {\n\t\tstatus[3] &= ~IEC958_AES3_CON_FS;\n\t\tswitch (rate) {\n\t\tcase 32000: status[3] |= IEC958_AES3_CON_FS_32000; break;\n\t\tcase 44100: status[3] |= IEC958_AES3_CON_FS_44100; break;\n\t\tcase 48000: status[3] |= IEC958_AES3_CON_FS_48000; break;\n\t\t}\n\t}\n\terr = snd_cs8427_send_corudata(cs8427, 0, status, 24);\n\tif (err > 0)\n\t\tsnd_ctl_notify(cs8427->bus->card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->playback.pcm_ctl->id);\n\treset = chip->rate != rate;\n\tchip->rate = rate;\n\tsnd_i2c_unlock(cs8427->bus);\n\tif (reset)\n\t\tsnd_cs8427_reset(cs8427);\n\treturn err < 0 ? err : 0;\n}\n\nEXPORT_SYMBOL(snd_cs8427_iec958_pcm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}