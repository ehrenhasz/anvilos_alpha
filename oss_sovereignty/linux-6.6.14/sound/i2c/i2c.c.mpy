{
  "module_name": "i2c.c",
  "hash_id": "72662fcd0e2eaff31d7f4a0e7eded69897053c5d9606c5b414aca9cef0666817",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <sound/core.h>\n#include <sound/i2c.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Generic i2c interface for ALSA\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int snd_i2c_bit_sendbytes(struct snd_i2c_device *device,\n\t\t\t\t unsigned char *bytes, int count);\nstatic int snd_i2c_bit_readbytes(struct snd_i2c_device *device,\n\t\t\t\t unsigned char *bytes, int count);\nstatic int snd_i2c_bit_probeaddr(struct snd_i2c_bus *bus,\n\t\t\t\t unsigned short addr);\n\nstatic const struct snd_i2c_ops snd_i2c_bit_ops = {\n\t.sendbytes = snd_i2c_bit_sendbytes,\n\t.readbytes = snd_i2c_bit_readbytes,\n\t.probeaddr = snd_i2c_bit_probeaddr,\n};\n\nstatic int snd_i2c_bus_free(struct snd_i2c_bus *bus)\n{\n\tstruct snd_i2c_bus *slave;\n\tstruct snd_i2c_device *device;\n\n\tif (snd_BUG_ON(!bus))\n\t\treturn -EINVAL;\n\twhile (!list_empty(&bus->devices)) {\n\t\tdevice = snd_i2c_device(bus->devices.next);\n\t\tsnd_i2c_device_free(device);\n\t}\n\tif (bus->master)\n\t\tlist_del(&bus->buses);\n\telse {\n\t\twhile (!list_empty(&bus->buses)) {\n\t\t\tslave = snd_i2c_slave_bus(bus->buses.next);\n\t\t\tsnd_device_free(bus->card, slave);\n\t\t}\n\t}\n\tif (bus->private_free)\n\t\tbus->private_free(bus);\n\tkfree(bus);\n\treturn 0;\n}\n\nstatic int snd_i2c_bus_dev_free(struct snd_device *device)\n{\n\tstruct snd_i2c_bus *bus = device->device_data;\n\treturn snd_i2c_bus_free(bus);\n}\n\nint snd_i2c_bus_create(struct snd_card *card, const char *name,\n\t\t       struct snd_i2c_bus *master, struct snd_i2c_bus **ri2c)\n{\n\tstruct snd_i2c_bus *bus;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_i2c_bus_dev_free,\n\t};\n\n\t*ri2c = NULL;\n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (bus == NULL)\n\t\treturn -ENOMEM;\n\tmutex_init(&bus->lock_mutex);\n\tINIT_LIST_HEAD(&bus->devices);\n\tINIT_LIST_HEAD(&bus->buses);\n\tbus->card = card;\n\tbus->ops = &snd_i2c_bit_ops;\n\tif (master) {\n\t\tlist_add_tail(&bus->buses, &master->buses);\n\t\tbus->master = master;\n\t}\n\tstrscpy(bus->name, name, sizeof(bus->name));\n\terr = snd_device_new(card, SNDRV_DEV_BUS, bus, &ops);\n\tif (err < 0) {\n\t\tsnd_i2c_bus_free(bus);\n\t\treturn err;\n\t}\n\t*ri2c = bus;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_i2c_bus_create);\n\nint snd_i2c_device_create(struct snd_i2c_bus *bus, const char *name,\n\t\t\t  unsigned char addr, struct snd_i2c_device **rdevice)\n{\n\tstruct snd_i2c_device *device;\n\n\t*rdevice = NULL;\n\tif (snd_BUG_ON(!bus))\n\t\treturn -EINVAL;\n\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\tif (device == NULL)\n\t\treturn -ENOMEM;\n\tdevice->addr = addr;\n\tstrscpy(device->name, name, sizeof(device->name));\n\tlist_add_tail(&device->list, &bus->devices);\n\tdevice->bus = bus;\n\t*rdevice = device;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_i2c_device_create);\n\nint snd_i2c_device_free(struct snd_i2c_device *device)\n{\n\tif (device->bus)\n\t\tlist_del(&device->list);\n\tif (device->private_free)\n\t\tdevice->private_free(device);\n\tkfree(device);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_i2c_device_free);\n\nint snd_i2c_sendbytes(struct snd_i2c_device *device, unsigned char *bytes, int count)\n{\n\treturn device->bus->ops->sendbytes(device, bytes, count);\n}\n\nEXPORT_SYMBOL(snd_i2c_sendbytes);\n\nint snd_i2c_readbytes(struct snd_i2c_device *device, unsigned char *bytes, int count)\n{\n\treturn device->bus->ops->readbytes(device, bytes, count);\n}\n\nEXPORT_SYMBOL(snd_i2c_readbytes);\n\nint snd_i2c_probeaddr(struct snd_i2c_bus *bus, unsigned short addr)\n{\n\treturn bus->ops->probeaddr(bus, addr);\n}\n\nEXPORT_SYMBOL(snd_i2c_probeaddr);\n\n \n\nstatic inline void snd_i2c_bit_hw_start(struct snd_i2c_bus *bus)\n{\n\tif (bus->hw_ops.bit->start)\n\t\tbus->hw_ops.bit->start(bus);\n}\n\nstatic inline void snd_i2c_bit_hw_stop(struct snd_i2c_bus *bus)\n{\n\tif (bus->hw_ops.bit->stop)\n\t\tbus->hw_ops.bit->stop(bus);\n}\n\nstatic void snd_i2c_bit_direction(struct snd_i2c_bus *bus, int clock, int data)\n{\n\tif (bus->hw_ops.bit->direction)\n\t\tbus->hw_ops.bit->direction(bus, clock, data);\n}\n\nstatic void snd_i2c_bit_set(struct snd_i2c_bus *bus, int clock, int data)\n{\n\tbus->hw_ops.bit->setlines(bus, clock, data);\n}\n\n#if 0\nstatic int snd_i2c_bit_clock(struct snd_i2c_bus *bus)\n{\n\tif (bus->hw_ops.bit->getclock)\n\t\treturn bus->hw_ops.bit->getclock(bus);\n\treturn -ENXIO;\n}\n#endif\n\nstatic int snd_i2c_bit_data(struct snd_i2c_bus *bus, int ack)\n{\n\treturn bus->hw_ops.bit->getdata(bus, ack);\n}\n\nstatic void snd_i2c_bit_start(struct snd_i2c_bus *bus)\n{\n\tsnd_i2c_bit_hw_start(bus);\n\tsnd_i2c_bit_direction(bus, 1, 1);\t \n\tsnd_i2c_bit_set(bus, 1, 1);\n\tsnd_i2c_bit_set(bus, 1, 0);\n\tsnd_i2c_bit_set(bus, 0, 0);\n}\n\nstatic void snd_i2c_bit_stop(struct snd_i2c_bus *bus)\n{\n\tsnd_i2c_bit_set(bus, 0, 0);\n\tsnd_i2c_bit_set(bus, 1, 0);\n\tsnd_i2c_bit_set(bus, 1, 1);\n\tsnd_i2c_bit_hw_stop(bus);\n}\n\nstatic void snd_i2c_bit_send(struct snd_i2c_bus *bus, int data)\n{\n\tsnd_i2c_bit_set(bus, 0, data);\n\tsnd_i2c_bit_set(bus, 1, data);\n\tsnd_i2c_bit_set(bus, 0, data);\n}\n\nstatic int snd_i2c_bit_ack(struct snd_i2c_bus *bus)\n{\n\tint ack;\n\n\tsnd_i2c_bit_set(bus, 0, 1);\n\tsnd_i2c_bit_set(bus, 1, 1);\n\tsnd_i2c_bit_direction(bus, 1, 0);\t \n\tack = snd_i2c_bit_data(bus, 1);\n\tsnd_i2c_bit_direction(bus, 1, 1);\t \n\tsnd_i2c_bit_set(bus, 0, 1);\n\treturn ack ? -EIO : 0;\n}\n\nstatic int snd_i2c_bit_sendbyte(struct snd_i2c_bus *bus, unsigned char data)\n{\n\tint i, err;\n\n\tfor (i = 7; i >= 0; i--)\n\t\tsnd_i2c_bit_send(bus, !!(data & (1 << i)));\n\terr = snd_i2c_bit_ack(bus);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_i2c_bit_readbyte(struct snd_i2c_bus *bus, int last)\n{\n\tint i;\n\tunsigned char data = 0;\n\n\tsnd_i2c_bit_set(bus, 0, 1);\n\tsnd_i2c_bit_direction(bus, 1, 0);\t \n\tfor (i = 7; i >= 0; i--) {\n\t\tsnd_i2c_bit_set(bus, 1, 1);\n\t\tif (snd_i2c_bit_data(bus, 0))\n\t\t\tdata |= (1 << i);\n\t\tsnd_i2c_bit_set(bus, 0, 1);\n\t}\n\tsnd_i2c_bit_direction(bus, 1, 1);\t \n\tsnd_i2c_bit_send(bus, !!last);\n\treturn data;\n}\n\nstatic int snd_i2c_bit_sendbytes(struct snd_i2c_device *device,\n\t\t\t\t unsigned char *bytes, int count)\n{\n\tstruct snd_i2c_bus *bus = device->bus;\n\tint err, res = 0;\n\n\tif (device->flags & SND_I2C_DEVICE_ADDRTEN)\n\t\treturn -EIO;\t\t \n\tsnd_i2c_bit_start(bus);\n\terr = snd_i2c_bit_sendbyte(bus, device->addr << 1);\n\tif (err < 0) {\n\t\tsnd_i2c_bit_hw_stop(bus);\n\t\treturn err;\n\t}\n\twhile (count-- > 0) {\n\t\terr = snd_i2c_bit_sendbyte(bus, *bytes++);\n\t\tif (err < 0) {\n\t\t\tsnd_i2c_bit_hw_stop(bus);\n\t\t\treturn err;\n\t\t}\n\t\tres++;\n\t}\n\tsnd_i2c_bit_stop(bus);\n\treturn res;\n}\n\nstatic int snd_i2c_bit_readbytes(struct snd_i2c_device *device,\n\t\t\t\t unsigned char *bytes, int count)\n{\n\tstruct snd_i2c_bus *bus = device->bus;\n\tint err, res = 0;\n\n\tif (device->flags & SND_I2C_DEVICE_ADDRTEN)\n\t\treturn -EIO;\t\t \n\tsnd_i2c_bit_start(bus);\n\terr = snd_i2c_bit_sendbyte(bus, (device->addr << 1) | 1);\n\tif (err < 0) {\n\t\tsnd_i2c_bit_hw_stop(bus);\n\t\treturn err;\n\t}\n\twhile (count-- > 0) {\n\t\terr = snd_i2c_bit_readbyte(bus, count == 0);\n\t\tif (err < 0) {\n\t\t\tsnd_i2c_bit_hw_stop(bus);\n\t\t\treturn err;\n\t\t}\n\t\t*bytes++ = (unsigned char)err;\n\t\tres++;\n\t}\n\tsnd_i2c_bit_stop(bus);\n\treturn res;\n}\n\nstatic int snd_i2c_bit_probeaddr(struct snd_i2c_bus *bus, unsigned short addr)\n{\n\tint err;\n\n\tif (addr & 0x8000)\t \n\t\treturn -EIO;\t \n\tif (addr & 0x7f80)\t \n\t\treturn -EINVAL;\n\tsnd_i2c_bit_start(bus);\n\terr = snd_i2c_bit_sendbyte(bus, addr << 1);\n\tsnd_i2c_bit_stop(bus);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}