{
  "module_name": "tea6330t.c",
  "hash_id": "ad818fd2c2acd5e4048933c34312620d8961609f804e90e94fc749ad2784057e",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/tea6330t.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tea6330t.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for control of the TEA6330T circuit via i2c bus\");\nMODULE_LICENSE(\"GPL\");\n\n#define TEA6330T_ADDR\t\t\t(0x80>>1)  \n\n#define TEA6330T_SADDR_VOLUME_LEFT\t0x00\t \n#define TEA6330T_SADDR_VOLUME_RIGHT\t0x01\t \n#define TEA6330T_SADDR_BASS\t\t0x02\t \n#define TEA6330T_SADDR_TREBLE\t\t0x03\t \n#define TEA6330T_SADDR_FADER\t\t0x04\t \n#define   TEA6330T_MFN\t\t\t0x20\t \n#define   TEA6330T_FCH\t\t\t0x10\t \n#define TEA6330T_SADDR_AUDIO_SWITCH\t0x05\t \n#define   TEA6330T_GMU\t\t\t0x80\t \n#define   TEA6330T_EQN\t\t\t0x40\t \n\n\nstruct tea6330t {\n\tstruct snd_i2c_device *device;\n\tstruct snd_i2c_bus *bus;\n\tint equalizer;\n\tint fader;\n\tunsigned char regs[8];\n\tunsigned char mleft, mright;\n\tunsigned char bass, treble;\n\tunsigned char max_bass, max_treble;\n};\n\n\nint snd_tea6330t_detect(struct snd_i2c_bus *bus, int equalizer)\n{\n\tint res;\n\n\tsnd_i2c_lock(bus);\n\tres = snd_i2c_probeaddr(bus, TEA6330T_ADDR);\n\tsnd_i2c_unlock(bus);\n\treturn res;\n}\n\n#if 0\nstatic void snd_tea6330t_set(struct tea6330t *tea,\n\t\t\t     unsigned char addr, unsigned char value)\n{\n#if 0\n\tprintk(KERN_DEBUG \"set - 0x%x/0x%x\\n\", addr, value);\n#endif\n\tsnd_i2c_write(tea->bus, TEA6330T_ADDR, addr, value, 1);\n}\n#endif\n\n#define TEA6330T_MASTER_VOLUME(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_tea6330t_info_master_volume, \\\n  .get = snd_tea6330t_get_master_volume, .put = snd_tea6330t_put_master_volume }\n\nstatic int snd_tea6330t_info_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 43;\n\treturn 0;\n}\n\nstatic int snd_tea6330t_get_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_i2c_lock(tea->bus);\n\tucontrol->value.integer.value[0] = tea->mleft - 0x14;\n\tucontrol->value.integer.value[1] = tea->mright - 0x14;\n\tsnd_i2c_unlock(tea->bus);\n\treturn 0;\n}\n\nstatic int snd_tea6330t_put_master_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\tint change, count, err;\n\tunsigned char bytes[3];\n\tunsigned char val1, val2;\n\t\n\tval1 = (ucontrol->value.integer.value[0] % 44) + 0x14;\n\tval2 = (ucontrol->value.integer.value[1] % 44) + 0x14;\n\tsnd_i2c_lock(tea->bus);\n\tchange = val1 != tea->mleft || val2 != tea->mright;\n\ttea->mleft = val1;\n\ttea->mright = val2;\n\tcount = 0;\n\tif (tea->regs[TEA6330T_SADDR_VOLUME_LEFT] != 0) {\n\t\tbytes[count++] = TEA6330T_SADDR_VOLUME_LEFT;\n\t\tbytes[count++] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] = tea->mleft;\n\t}\n\tif (tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] != 0) {\n\t\tif (count == 0)\n\t\t\tbytes[count++] = TEA6330T_SADDR_VOLUME_RIGHT;\n\t\tbytes[count++] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] = tea->mright;\n\t}\n\tif (count > 0) {\n\t\terr = snd_i2c_sendbytes(tea->device, bytes, count);\n\t\tif (err < 0)\n\t\t\tchange = err;\n\t}\n\tsnd_i2c_unlock(tea->bus);\n\treturn change;\n}\n\n#define TEA6330T_MASTER_SWITCH(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_tea6330t_info_master_switch, \\\n  .get = snd_tea6330t_get_master_switch, .put = snd_tea6330t_put_master_switch }\n\n#define snd_tea6330t_info_master_switch\t\tsnd_ctl_boolean_stereo_info\n\nstatic int snd_tea6330t_get_master_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_i2c_lock(tea->bus);\n\tucontrol->value.integer.value[0] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] == 0 ? 0 : 1;\n\tucontrol->value.integer.value[1] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] == 0 ? 0 : 1;\n\tsnd_i2c_unlock(tea->bus);\n\treturn 0;\n}\n\nstatic int snd_tea6330t_put_master_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\tint change, err;\n\tunsigned char bytes[3];\n\tunsigned char oval1, oval2, val1, val2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & 1;\n\tval2 = ucontrol->value.integer.value[1] & 1;\n\tsnd_i2c_lock(tea->bus);\n\toval1 = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] == 0 ? 0 : 1;\n\toval2 = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] == 0 ? 0 : 1;\n\tchange = val1 != oval1 || val2 != oval2;\n\ttea->regs[TEA6330T_SADDR_VOLUME_LEFT] = val1 ? tea->mleft : 0;\n\ttea->regs[TEA6330T_SADDR_VOLUME_RIGHT] = val2 ? tea->mright : 0;\n\tbytes[0] = TEA6330T_SADDR_VOLUME_LEFT;\n\tbytes[1] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT];\n\tbytes[2] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT];\n\terr = snd_i2c_sendbytes(tea->device, bytes, 3);\n\tif (err < 0)\n\t\tchange = err;\n\tsnd_i2c_unlock(tea->bus);\n\treturn change;\n}\n\n#define TEA6330T_BASS(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_tea6330t_info_bass, \\\n  .get = snd_tea6330t_get_bass, .put = snd_tea6330t_put_bass }\n\nstatic int snd_tea6330t_info_bass(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tea->max_bass;\n\treturn 0;\n}\n\nstatic int snd_tea6330t_get_bass(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = tea->bass;\n\treturn 0;\n}\n\nstatic int snd_tea6330t_put_bass(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\tint change, err;\n\tunsigned char bytes[2];\n\tunsigned char val1;\n\t\n\tval1 = ucontrol->value.integer.value[0] % (tea->max_bass + 1);\n\tsnd_i2c_lock(tea->bus);\n\ttea->bass = val1;\n\tval1 += tea->equalizer ? 7 : 3;\n\tchange = tea->regs[TEA6330T_SADDR_BASS] != val1;\n\tbytes[0] = TEA6330T_SADDR_BASS;\n\tbytes[1] = tea->regs[TEA6330T_SADDR_BASS] = val1;\n\terr = snd_i2c_sendbytes(tea->device, bytes, 2);\n\tif (err < 0)\n\t\tchange = err;\n\tsnd_i2c_unlock(tea->bus);\n\treturn change;\n}\n\n#define TEA6330T_TREBLE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_tea6330t_info_treble, \\\n  .get = snd_tea6330t_get_treble, .put = snd_tea6330t_put_treble }\n\nstatic int snd_tea6330t_info_treble(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tea->max_treble;\n\treturn 0;\n}\n\nstatic int snd_tea6330t_get_treble(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = tea->treble;\n\treturn 0;\n}\n\nstatic int snd_tea6330t_put_treble(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\n\tint change, err;\n\tunsigned char bytes[2];\n\tunsigned char val1;\n\t\n\tval1 = ucontrol->value.integer.value[0] % (tea->max_treble + 1);\n\tsnd_i2c_lock(tea->bus);\n\ttea->treble = val1;\n\tval1 += 3;\n\tchange = tea->regs[TEA6330T_SADDR_TREBLE] != val1;\n\tbytes[0] = TEA6330T_SADDR_TREBLE;\n\tbytes[1] = tea->regs[TEA6330T_SADDR_TREBLE] = val1;\n\terr = snd_i2c_sendbytes(tea->device, bytes, 2);\n\tif (err < 0)\n\t\tchange = err;\n\tsnd_i2c_unlock(tea->bus);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_tea6330t_controls[] = {\nTEA6330T_MASTER_SWITCH(\"Master Playback Switch\", 0),\nTEA6330T_MASTER_VOLUME(\"Master Playback Volume\", 0),\nTEA6330T_BASS(\"Tone Control - Bass\", 0),\nTEA6330T_TREBLE(\"Tone Control - Treble\", 0)\n};\n\nstatic void snd_tea6330_free(struct snd_i2c_device *device)\n{\n\tkfree(device->private_data);\n}\n                                        \nint snd_tea6330t_update_mixer(struct snd_card *card,\n\t\t\t      struct snd_i2c_bus *bus,\n\t\t\t      int equalizer, int fader)\n{\n\tstruct snd_i2c_device *device;\n\tstruct tea6330t *tea;\n\tconst struct snd_kcontrol_new *knew;\n\tunsigned int idx;\n\tint err;\n\tu8 default_treble, default_bass;\n\tunsigned char bytes[7];\n\n\ttea = kzalloc(sizeof(*tea), GFP_KERNEL);\n\tif (tea == NULL)\n\t\treturn -ENOMEM;\n\terr = snd_i2c_device_create(bus, \"TEA6330T\", TEA6330T_ADDR, &device);\n\tif (err < 0) {\n\t\tkfree(tea);\n\t\treturn err;\n\t}\n\ttea->device = device;\n\ttea->bus = bus;\n\ttea->equalizer = equalizer;\n\ttea->fader = fader;\n\tdevice->private_data = tea;\n\tdevice->private_free = snd_tea6330_free;\n\n\tsnd_i2c_lock(bus);\n\n\t \n\ttea->regs[TEA6330T_SADDR_FADER] = 0x3f;\n\ttea->regs[TEA6330T_SADDR_AUDIO_SWITCH] = equalizer ? 0 : TEA6330T_EQN;\n\t \n\tif (!tea->equalizer) {\n\t\ttea->max_bass = 9;\n\t\ttea->max_treble = 8;\n\t\tdefault_bass = 3 + 4;\n\t\ttea->bass = 4;\n\t\tdefault_treble = 3 + 4;\n\t\ttea->treble = 4;\n\t} else {\n\t\ttea->max_bass = 5;\n\t\ttea->max_treble = 0;\n\t\tdefault_bass = 7 + 4;\n\t\ttea->bass = 4;\n\t\tdefault_treble = 3;\n\t\ttea->treble = 0;\n\t}\n\ttea->mleft = tea->mright = 0x14;\n\ttea->regs[TEA6330T_SADDR_BASS] = default_bass;\n\ttea->regs[TEA6330T_SADDR_TREBLE] = default_treble;\n\n\t \n\tbytes[0] = TEA6330T_SADDR_VOLUME_LEFT;\n\tfor (idx = 0; idx < 6; idx++)\n\t\tbytes[idx+1] = tea->regs[idx];\n\terr = snd_i2c_sendbytes(device, bytes, 7);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tstrcat(card->mixername, \",TEA6330T\");\n\terr = snd_component_add(card, \"TEA6330T\");\n\tif (err < 0)\n\t\tgoto __error;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_tea6330t_controls); idx++) {\n\t\tknew = &snd_tea6330t_controls[idx];\n\t\tif (tea->treble == 0 && !strcmp(knew->name, \"Tone Control - Treble\"))\n\t\t\tcontinue;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(knew, tea));\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tsnd_i2c_unlock(bus);\n\treturn 0;\n\t\n      __error:\n      \tsnd_i2c_unlock(bus);\n      \tsnd_i2c_device_free(device);\n      \treturn err;\n}\n\nEXPORT_SYMBOL(snd_tea6330t_detect);\nEXPORT_SYMBOL(snd_tea6330t_update_mixer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}