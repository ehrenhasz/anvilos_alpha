{
  "module_name": "ak4117.c",
  "hash_id": "1f01fa4205b87d10e343b0fe2b7a391a765f166769ccb16b4308805691824433",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/other/ak4117.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/ak4117.h>\n#include <sound/asoundef.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"AK4117 IEC958 (S/PDIF) receiver by Asahi Kasei\");\nMODULE_LICENSE(\"GPL\");\n\n#define AK4117_ADDR\t\t\t0x00  \n\nstatic void snd_ak4117_timer(struct timer_list *t);\n\nstatic void reg_write(struct ak4117 *ak4117, unsigned char reg, unsigned char val)\n{\n\tak4117->write(ak4117->private_data, reg, val);\n\tif (reg < sizeof(ak4117->regmap))\n\t\tak4117->regmap[reg] = val;\n}\n\nstatic inline unsigned char reg_read(struct ak4117 *ak4117, unsigned char reg)\n{\n\treturn ak4117->read(ak4117->private_data, reg);\n}\n\n#if 0\nstatic void reg_dump(struct ak4117 *ak4117)\n{\n\tint i;\n\n\tprintk(KERN_DEBUG \"AK4117 REG DUMP:\\n\");\n\tfor (i = 0; i < 0x1b; i++)\n\t\tprintk(KERN_DEBUG \"reg[%02x] = %02x (%02x)\\n\", i, reg_read(ak4117, i), i < sizeof(ak4117->regmap) ? ak4117->regmap[i] : 0);\n}\n#endif\n\nstatic void snd_ak4117_free(struct ak4117 *chip)\n{\n\ttimer_shutdown_sync(&chip->timer);\n\tkfree(chip);\n}\n\nstatic int snd_ak4117_dev_free(struct snd_device *device)\n{\n\tstruct ak4117 *chip = device->device_data;\n\tsnd_ak4117_free(chip);\n\treturn 0;\n}\n\nint snd_ak4117_create(struct snd_card *card, ak4117_read_t *read, ak4117_write_t *write,\n\t\t      const unsigned char pgm[5], void *private_data, struct ak4117 **r_ak4117)\n{\n\tstruct ak4117 *chip;\n\tint err = 0;\n\tunsigned char reg;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =     snd_ak4117_dev_free,\n\t};\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&chip->lock);\n\tchip->card = card;\n\tchip->read = read;\n\tchip->write = write;\n\tchip->private_data = private_data;\n\ttimer_setup(&chip->timer, snd_ak4117_timer, 0);\n\n\tfor (reg = 0; reg < 5; reg++)\n\t\tchip->regmap[reg] = pgm[reg];\n\tsnd_ak4117_reinit(chip);\n\n\tchip->rcs0 = reg_read(chip, AK4117_REG_RCS0) & ~(AK4117_QINT | AK4117_CINT | AK4117_STC);\n\tchip->rcs1 = reg_read(chip, AK4117_REG_RCS1);\n\tchip->rcs2 = reg_read(chip, AK4117_REG_RCS2);\n\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops);\n\tif (err < 0)\n\t\tgoto __fail;\n\n\tif (r_ak4117)\n\t\t*r_ak4117 = chip;\n\treturn 0;\n\n      __fail:\n\tsnd_ak4117_free(chip);\n\treturn err;\n}\n\nvoid snd_ak4117_reg_write(struct ak4117 *chip, unsigned char reg, unsigned char mask, unsigned char val)\n{\n\tif (reg >= 5)\n\t\treturn;\n\treg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);\n}\n\nvoid snd_ak4117_reinit(struct ak4117 *chip)\n{\n\tunsigned char old = chip->regmap[AK4117_REG_PWRDN], reg;\n\n\tdel_timer(&chip->timer);\n\tchip->init = 1;\n\t \n\treg_write(chip, AK4117_REG_PWRDN, 0);\n\tudelay(200);\n\t \n\treg_write(chip, AK4117_REG_PWRDN, (old | AK4117_RST) & ~AK4117_PWN);\n\tudelay(200);\n\tfor (reg = 1; reg < 5; reg++)\n\t\treg_write(chip, reg, chip->regmap[reg]);\n\t \n\treg_write(chip, AK4117_REG_PWRDN, old | AK4117_RST | AK4117_PWN);\n\tchip->init = 0;\n\tmod_timer(&chip->timer, 1 + jiffies);\n}\n\nstatic unsigned int external_rate(unsigned char rcs1)\n{\n\tswitch (rcs1 & (AK4117_FS0|AK4117_FS1|AK4117_FS2|AK4117_FS3)) {\n\tcase AK4117_FS_32000HZ: return 32000;\n\tcase AK4117_FS_44100HZ: return 44100;\n\tcase AK4117_FS_48000HZ: return 48000;\n\tcase AK4117_FS_88200HZ: return 88200;\n\tcase AK4117_FS_96000HZ: return 96000;\n\tcase AK4117_FS_176400HZ: return 176400;\n\tcase AK4117_FS_192000HZ: return 192000;\n\tdefault:\t\treturn 0;\n\t}\n}\n\nstatic int snd_ak4117_in_error_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = LONG_MAX;\n\treturn 0;\n}\n\nstatic int snd_ak4117_in_error_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->lock);\n\tucontrol->value.integer.value[0] =\n\t\t       chip->errors[kcontrol->private_value];\n\tchip->errors[kcontrol->private_value] = 0;\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n#define snd_ak4117_in_bit_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ak4117_in_bit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char reg = kcontrol->private_value & 0xff;\n\tunsigned char bit = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned char inv = (kcontrol->private_value >> 31) & 1;\n\n\tucontrol->value.integer.value[0] = ((reg_read(chip, reg) & (1 << bit)) ? 1 : 0) ^ inv;\n\treturn 0;\n}\n\nstatic int snd_ak4117_rx_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4117_rx_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = (chip->regmap[AK4117_REG_IO] & AK4117_IPS) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_ak4117_rx_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu8 old_val;\n\t\n\tspin_lock_irq(&chip->lock);\n\told_val = chip->regmap[AK4117_REG_IO];\n\tchange = !!ucontrol->value.integer.value[0] != ((old_val & AK4117_IPS) ? 1 : 0);\n\tif (change)\n\t\treg_write(chip, AK4117_REG_IO, (old_val & ~AK4117_IPS) | (ucontrol->value.integer.value[0] ? AK4117_IPS : 0));\n\tspin_unlock_irq(&chip->lock);\n\treturn change;\n}\n\nstatic int snd_ak4117_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\treturn 0;\n}\n\nstatic int snd_ak4117_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = external_rate(reg_read(chip, AK4117_REG_RCS1));\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4117_REG_RXCSB_SIZE; i++)\n\t\tucontrol->value.iec958.status[i] = reg_read(chip, AK4117_REG_RXCSB0 + i);\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff, AK4117_REG_RXCSB_SIZE);\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_pinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffff;\n\tuinfo->count = 4;\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_pget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned short tmp;\n\n\tucontrol->value.integer.value[0] = 0xf8f2;\n\tucontrol->value.integer.value[1] = 0x4e1f;\n\ttmp = reg_read(chip, AK4117_REG_Pc0) | (reg_read(chip, AK4117_REG_Pc1) << 8);\n\tucontrol->value.integer.value[2] = tmp;\n\ttmp = reg_read(chip, AK4117_REG_Pd0) | (reg_read(chip, AK4117_REG_Pd1) << 8);\n\tucontrol->value.integer.value[3] = tmp;\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_qinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = AK4117_REG_QSUB_SIZE;\n\treturn 0;\n}\n\nstatic int snd_ak4117_spdif_qget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4117 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4117_REG_QSUB_SIZE; i++)\n\t\tucontrol->value.bytes.data[i] = reg_read(chip, AK4117_REG_QSUB_ADDR + i);\n\treturn 0;\n}\n\n \nstatic const struct snd_kcontrol_new snd_ak4117_iec958_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Parity Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_error_info,\n\t.get =\t\tsnd_ak4117_in_error_get,\n\t.private_value = AK4117_PARITY_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 V-Bit Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_error_info,\n\t.get =\t\tsnd_ak4117_in_error_get,\n\t.private_value = AK4117_V_BIT_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 C-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_error_info,\n\t.get =\t\tsnd_ak4117_in_error_get,\n\t.private_value = AK4117_CCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_error_info,\n\t.get =\t\tsnd_ak4117_in_error_get,\n\t.private_value = AK4117_QCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 External Rate\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_rate_info,\n\t.get =\t\tsnd_ak4117_rate_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",CAPTURE,MASK),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.info =\t\tsnd_ak4117_spdif_mask_info,\n\t.get =\t\tsnd_ak4117_spdif_mask_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",CAPTURE,DEFAULT),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_spdif_info,\n\t.get =\t\tsnd_ak4117_spdif_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Preamble Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_spdif_pinfo,\n\t.get =\t\tsnd_ak4117_spdif_pget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-subcode Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_spdif_qinfo,\n\t.get =\t\tsnd_ak4117_spdif_qget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Audio\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_bit_info,\n\t.get =\t\tsnd_ak4117_in_bit_get,\n\t.private_value = (1<<31) | (3<<8) | AK4117_REG_RCS0,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Non-PCM Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_bit_info,\n\t.get =\t\tsnd_ak4117_in_bit_get,\n\t.private_value = (5<<8) | AK4117_REG_RCS1,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 DTS Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4117_in_bit_info,\n\t.get =\t\tsnd_ak4117_in_bit_get,\n\t.private_value = (6<<8) | AK4117_REG_RCS1,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"AK4117 Input Select\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\n\t.info =\t\tsnd_ak4117_rx_info,\n\t.get =\t\tsnd_ak4117_rx_get,\n\t.put =\t\tsnd_ak4117_rx_put,\n}\n};\n\nint snd_ak4117_build(struct ak4117 *ak4117, struct snd_pcm_substream *cap_substream)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cap_substream))\n\t\treturn -EINVAL;\n\tak4117->substream = cap_substream;\n\tfor (idx = 0; idx < AK4117_CONTROLS; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_ak4117_iec958_controls[idx], ak4117);\n\t\tif (kctl == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.device = cap_substream->pcm->device;\n\t\tkctl->id.subdevice = cap_substream->number;\n\t\terr = snd_ctl_add(ak4117->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tak4117->kctls[idx] = kctl;\n\t}\n\treturn 0;\n}\n\nint snd_ak4117_external_rate(struct ak4117 *ak4117)\n{\n\tunsigned char rcs1;\n\n\trcs1 = reg_read(ak4117, AK4117_REG_RCS1);\n\treturn external_rate(rcs1);\n}\n\nint snd_ak4117_check_rate_and_errors(struct ak4117 *ak4117, unsigned int flags)\n{\n\tstruct snd_pcm_runtime *runtime = ak4117->substream ? ak4117->substream->runtime : NULL;\n\tunsigned long _flags;\n\tint res = 0;\n\tunsigned char rcs0, rcs1, rcs2;\n\tunsigned char c0, c1;\n\n\trcs1 = reg_read(ak4117, AK4117_REG_RCS1);\n\tif (flags & AK4117_CHECK_NO_STAT)\n\t\tgoto __rate;\n\trcs0 = reg_read(ak4117, AK4117_REG_RCS0);\n\trcs2 = reg_read(ak4117, AK4117_REG_RCS2);\n\t\n\tspin_lock_irqsave(&ak4117->lock, _flags);\n\tif (rcs0 & AK4117_PAR)\n\t\tak4117->errors[AK4117_PARITY_ERRORS]++;\n\tif (rcs0 & AK4117_V)\n\t\tak4117->errors[AK4117_V_BIT_ERRORS]++;\n\tif (rcs2 & AK4117_CCRC)\n\t\tak4117->errors[AK4117_CCRC_ERRORS]++;\n\tif (rcs2 & AK4117_QCRC)\n\t\tak4117->errors[AK4117_QCRC_ERRORS]++;\n\tc0 = (ak4117->rcs0 & (AK4117_QINT | AK4117_CINT | AK4117_STC | AK4117_AUDION | AK4117_AUTO | AK4117_UNLCK)) ^\n                     (rcs0 & (AK4117_QINT | AK4117_CINT | AK4117_STC | AK4117_AUDION | AK4117_AUTO | AK4117_UNLCK));\n\tc1 = (ak4117->rcs1 & (AK4117_DTSCD | AK4117_NPCM | AK4117_PEM | 0x0f)) ^\n\t             (rcs1 & (AK4117_DTSCD | AK4117_NPCM | AK4117_PEM | 0x0f));\n\tak4117->rcs0 = rcs0 & ~(AK4117_QINT | AK4117_CINT | AK4117_STC);\n\tak4117->rcs1 = rcs1;\n\tak4117->rcs2 = rcs2;\n\tspin_unlock_irqrestore(&ak4117->lock, _flags);\n\n\tif (rcs0 & AK4117_PAR)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[0]->id);\n\tif (rcs0 & AK4117_V)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[1]->id);\n\tif (rcs2 & AK4117_CCRC)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[2]->id);\n\tif (rcs2 & AK4117_QCRC)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[3]->id);\n\n\t \n\tif (c1 & 0x0f)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[4]->id);\n\n\tif ((c1 & AK4117_PEM) | (c0 & AK4117_CINT))\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[6]->id);\n\tif (c0 & AK4117_QINT)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[8]->id);\n\n\tif (c0 & AK4117_AUDION)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[9]->id);\n\tif (c1 & AK4117_NPCM)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[10]->id);\n\tif (c1 & AK4117_DTSCD)\n\t\tsnd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[11]->id);\n\t\t\n\tif (ak4117->change_callback && (c0 | c1) != 0)\n\t\tak4117->change_callback(ak4117, c0, c1);\n\n      __rate:\n\t \n\tres = external_rate(rcs1);\n\tif (!(flags & AK4117_CHECK_NO_RATE) && runtime && runtime->rate != res) {\n\t\tsnd_pcm_stream_lock_irqsave(ak4117->substream, _flags);\n\t\tif (snd_pcm_running(ak4117->substream)) {\n\t\t\t\n\t\t\tsnd_pcm_stop(ak4117->substream, SNDRV_PCM_STATE_DRAINING);\n\t\t\twake_up(&runtime->sleep);\n\t\t\tres = 1;\n\t\t}\n\t\tsnd_pcm_stream_unlock_irqrestore(ak4117->substream, _flags);\n\t}\n\treturn res;\n}\n\nstatic void snd_ak4117_timer(struct timer_list *t)\n{\n\tstruct ak4117 *chip = from_timer(chip, t, timer);\n\n\tif (chip->init)\n\t\treturn;\n\tsnd_ak4117_check_rate_and_errors(chip, 0);\n\tmod_timer(&chip->timer, 1 + jiffies);\n}\n\nEXPORT_SYMBOL(snd_ak4117_create);\nEXPORT_SYMBOL(snd_ak4117_reg_write);\nEXPORT_SYMBOL(snd_ak4117_reinit);\nEXPORT_SYMBOL(snd_ak4117_build);\nEXPORT_SYMBOL(snd_ak4117_external_rate);\nEXPORT_SYMBOL(snd_ak4117_check_rate_and_errors);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}