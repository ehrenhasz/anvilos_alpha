{
  "module_name": "ak4xxx-adda.c",
  "hash_id": "9f9208767317f8d18cb48e9676392edff4f6561a88c6db5a1cfc64942f3ac045",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/other/ak4xxx-adda.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/ak4xxx-adda.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"Routines for control of AK452x / AK43xx  AD/DA converters\");\nMODULE_LICENSE(\"GPL\");\n\n \nvoid snd_akm4xxx_write(struct snd_akm4xxx *ak, int chip, unsigned char reg,\n\t\t       unsigned char val)\n{\n\tak->ops.lock(ak, chip);\n\tak->ops.write(ak, chip, reg, val);\n\n\t \n\tsnd_akm4xxx_set(ak, chip, reg, val);\n\tak->ops.unlock(ak, chip);\n}\n\nEXPORT_SYMBOL(snd_akm4xxx_write);\n\n \nstatic void ak4524_reset(struct snd_akm4xxx *ak, int state)\n{\n\tunsigned int chip;\n\tunsigned char reg;\n\n\tfor (chip = 0; chip < ak->num_dacs/2; chip++) {\n\t\tsnd_akm4xxx_write(ak, chip, 0x01, state ? 0x00 : 0x03);\n\t\tif (state)\n\t\t\tcontinue;\n\t\t \n\t\tfor (reg = 0x04; reg < ak->total_regs; reg++)\n\t\t\tsnd_akm4xxx_write(ak, chip, reg,\n\t\t\t\t\t  snd_akm4xxx_get(ak, chip, reg));\n\t}\n}\n\n \nstatic void ak435X_reset(struct snd_akm4xxx *ak, int state)\n{\n\tunsigned char reg;\n\n\tif (state) {\n\t\tsnd_akm4xxx_write(ak, 0, 0x01, 0x02);  \n\t\treturn;\n\t}\n\tfor (reg = 0x00; reg < ak->total_regs; reg++)\n\t\tif (reg != 0x01)\n\t\t\tsnd_akm4xxx_write(ak, 0, reg,\n\t\t\t\t\t  snd_akm4xxx_get(ak, 0, reg));\n\tsnd_akm4xxx_write(ak, 0, 0x01, 0x01);  \n}\n\n \nstatic void ak4381_reset(struct snd_akm4xxx *ak, int state)\n{\n\tunsigned int chip;\n\tunsigned char reg;\n\tfor (chip = 0; chip < ak->num_dacs/2; chip++) {\n\t\tsnd_akm4xxx_write(ak, chip, 0x00, state ? 0x0c : 0x0f);\n\t\tif (state)\n\t\t\tcontinue;\n\t\tfor (reg = 0x01; reg < ak->total_regs; reg++)\n\t\t\tsnd_akm4xxx_write(ak, chip, reg,\n\t\t\t\t\t  snd_akm4xxx_get(ak, chip, reg));\n\t}\n}\n\n \nvoid snd_akm4xxx_reset(struct snd_akm4xxx *ak, int state)\n{\n\tswitch (ak->type) {\n\tcase SND_AK4524:\n\tcase SND_AK4528:\n\tcase SND_AK4620:\n\t\tak4524_reset(ak, state);\n\t\tbreak;\n\tcase SND_AK4529:\n\t\t \n\t\tbreak;\n\tcase SND_AK4355:\n\t\tak435X_reset(ak, state);\n\t\tbreak;\n\tcase SND_AK4358:\n\t\tak435X_reset(ak, state);\n\t\tbreak;\n\tcase SND_AK4381:\n\t\tak4381_reset(ak, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nEXPORT_SYMBOL(snd_akm4xxx_reset);\n\n\n \nstatic const unsigned char vol_cvt_datt[128] = {\n\t0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04,\n\t0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06,\n\t0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x0a,\n\t0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f,\n\t0x10, 0x10, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,\n\t0x15, 0x16, 0x17, 0x17, 0x18, 0x19, 0x1a, 0x1c,\n\t0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x23,\n\t0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2b, 0x2d,\n\t0x2e, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,\n\t0x37, 0x38, 0x39, 0x3b, 0x3c, 0x3e, 0x3f, 0x40,\n\t0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4a,\n\t0x4b, 0x4d, 0x4e, 0x50, 0x51, 0x52, 0x53, 0x54,\n\t0x55, 0x56, 0x58, 0x59, 0x5b, 0x5c, 0x5e, 0x5f,\n\t0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x67, 0x69,\n\t0x6a, 0x6c, 0x6d, 0x6f, 0x70, 0x71, 0x72, 0x73,\n\t0x75, 0x76, 0x77, 0x79, 0x7a, 0x7c, 0x7d, 0x7f,\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_vol_datt, -6350, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_8bit, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_7bit, -6350, 50, 1);\nstatic const DECLARE_TLV_DB_LINEAR(db_scale_linear, TLV_DB_GAIN_MUTE, 0);\n\n \nvoid snd_akm4xxx_init(struct snd_akm4xxx *ak)\n{\n\tstatic const unsigned char inits_ak4524[] = {\n\t\t0x00, 0x07,  \n\t\t0x01, 0x00,  \n\t\t0x02, 0x60,  \n\t\t0x03, 0x19,  \n\t\t0x01, 0x03,  \n\t\t0x04, 0x00,  \n\t\t0x05, 0x00,  \n\t\t0x06, 0x00,  \n\t\t0x07, 0x00,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4528[] = {\n\t\t0x00, 0x07,  \n\t\t0x01, 0x00,  \n\t\t0x02, 0x60,  \n\t\t0x03, 0x0d,  \n\t\t0x01, 0x03,  \n\t\t0x04, 0x00,  \n\t\t0x05, 0x00,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4529[] = {\n\t\t0x09, 0x01,  \n\t\t0x0a, 0x3f,  \n\t\t0x00, 0x0c,  \n\t\t0x01, 0x00,  \n\t\t0x02, 0xff,  \n\t\t0x03, 0xff,  \n\t\t0x04, 0xff,  \n\t\t0x05, 0xff,  \n\t\t0x06, 0xff,  \n\t\t0x07, 0xff,  \n\t\t0x0b, 0xff,  \n\t\t0x0c, 0xff,  \n\t\t0x08, 0x55,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4355[] = {\n\t\t0x01, 0x02,  \n\t\t0x00, 0x06,  \n\t\t0x02, 0x0e,  \n\t\t \n\t\t0x03, 0x01,  \n\t\t0x04, 0x00,  \n\t\t0x05, 0x00,  \n\t\t0x06, 0x00,  \n\t\t0x07, 0x00,  \n\t\t0x08, 0x00,  \n\t\t0x09, 0x00,  \n\t\t0x0a, 0x00,  \n\t\t0x01, 0x01,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4358[] = {\n\t\t0x01, 0x02,  \n\t\t0x00, 0x06,  \n\t\t0x02, 0x4e,  \n\t\t   \n\t\t0x03, 0x01,  \n\t\t0x04, 0x00,  \n\t\t0x05, 0x00,  \n\t\t0x06, 0x00,  \n\t\t0x07, 0x00,  \n\t\t0x08, 0x00,  \n\t\t0x09, 0x00,  \n\t\t0x0b, 0x00,  \n\t\t0x0c, 0x00,  \n\t\t0x0a, 0x00,  \n\t\t0x01, 0x01,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4381[] = {\n\t\t0x00, 0x0c,  \n\t\t0x01, 0x02,  \n\t\t\n\t\t0x02, 0x00,  \n\t\t0x03, 0x00,  \n\t\t0x04, 0x00,  \n\t\t0x00, 0x0f,  \n\t\t0xff, 0xff\n\t};\n\tstatic const unsigned char inits_ak4620[] = {\n\t\t0x00, 0x07,  \n\t\t0x01, 0x00,  \n\t\t0x01, 0x02,  \n\t\t0x01, 0x03,  \n\t\t0x01, 0x0f,  \n\t\t0x02, 0x60,  \n\t\t0x03, 0x01,  \n\t\t0x04, 0x00,  \n\t\t0x05, 0x00,  \n\t\t0x06, 0x00,  \n\t\t0x07, 0x00,  \n\t\t0xff, 0xff\n\t};\n\n\tint chip;\n\tconst unsigned char *ptr, *inits;\n\tunsigned char reg, data;\n\n\tmemset(ak->images, 0, sizeof(ak->images));\n\tmemset(ak->volumes, 0, sizeof(ak->volumes));\n\n\tswitch (ak->type) {\n\tcase SND_AK4524:\n\t\tinits = inits_ak4524;\n\t\tak->num_chips = ak->num_dacs / 2;\n\t\tak->name = \"ak4524\";\n\t\tak->total_regs = 0x08;\n\t\tbreak;\n\tcase SND_AK4528:\n\t\tinits = inits_ak4528;\n\t\tak->num_chips = ak->num_dacs / 2;\n\t\tak->name = \"ak4528\";\n\t\tak->total_regs = 0x06;\n\t\tbreak;\n\tcase SND_AK4529:\n\t\tinits = inits_ak4529;\n\t\tak->num_chips = 1;\n\t\tak->name = \"ak4529\";\n\t\tak->total_regs = 0x0d;\n\t\tbreak;\n\tcase SND_AK4355:\n\t\tinits = inits_ak4355;\n\t\tak->num_chips = 1;\n\t\tak->name = \"ak4355\";\n\t\tak->total_regs = 0x0b;\n\t\tbreak;\n\tcase SND_AK4358:\n\t\tinits = inits_ak4358;\n\t\tak->num_chips = 1;\n\t\tak->name = \"ak4358\";\n\t\tak->total_regs = 0x10;\n\t\tbreak;\n\tcase SND_AK4381:\n\t\tinits = inits_ak4381;\n\t\tak->num_chips = ak->num_dacs / 2;\n\t\tak->name = \"ak4381\";\n\t\tak->total_regs = 0x05;\n\t\tbreak;\n\tcase SND_AK5365:\n\t\t \n\t\tak->num_chips = 1;\n\t\tak->name = \"ak5365\";\n\t\tak->total_regs = 0x08;\n\t\treturn;\n\tcase SND_AK4620:\n\t\tinits = inits_ak4620;\n\t\tak->num_chips = ak->num_dacs / 2;\n\t\tak->name = \"ak4620\";\n\t\tak->total_regs = 0x08;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn;\n\t}\n\n\tfor (chip = 0; chip < ak->num_chips; chip++) {\n\t\tptr = inits;\n\t\twhile (*ptr != 0xff) {\n\t\t\treg = *ptr++;\n\t\t\tdata = *ptr++;\n\t\t\tsnd_akm4xxx_write(ak, chip, reg, data);\n\t\t\tudelay(10);\n\t\t}\n\t}\n}\n\nEXPORT_SYMBOL(snd_akm4xxx_init);\n\n \n#define AK_IPGA \t\t\t(1<<20)\t \n#define AK_VOL_CVT \t\t\t(1<<21)\t \n#define AK_NEEDSMSB \t\t\t(1<<22)\t \n#define AK_INVERT \t\t\t(1<<23)\t \n#define AK_GET_CHIP(val)\t\t(((val) >> 8) & 0xff)\n#define AK_GET_ADDR(val)\t\t((val) & 0xff)\n#define AK_GET_SHIFT(val)\t\t(((val) >> 16) & 0x0f)\n#define AK_GET_VOL_CVT(val)\t\t(((val) >> 21) & 1)\n#define AK_GET_IPGA(val)\t\t(((val) >> 20) & 1)\n#define AK_GET_NEEDSMSB(val)\t\t(((val) >> 22) & 1)\n#define AK_GET_INVERT(val)\t\t(((val) >> 23) & 1)\n#define AK_GET_MASK(val)\t\t(((val) >> 24) & 0xff)\n#define AK_COMPOSE(chip,addr,shift,mask) \\\n\t(((chip) << 8) | (addr) | ((shift) << 16) | ((mask) << 24))\n\nstatic int snd_akm4xxx_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int mask = AK_GET_MASK(kcontrol->private_value);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_akm4xxx_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\n\tucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);\n\treturn 0;\n}\n\nstatic int put_ak_reg(struct snd_kcontrol *kcontrol, int addr,\n\t\t      unsigned char nval)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask = AK_GET_MASK(kcontrol->private_value);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\n\tif (snd_akm4xxx_get_vol(ak, chip, addr) == nval)\n\t\treturn 0;\n\n\tsnd_akm4xxx_set_vol(ak, chip, addr, nval);\n\tif (AK_GET_VOL_CVT(kcontrol->private_value) && nval < 128)\n\t\tnval = vol_cvt_datt[nval];\n\tif (AK_GET_IPGA(kcontrol->private_value) && nval >= 128)\n\t\tnval++;  \n\tif (AK_GET_INVERT(kcontrol->private_value))\n\t\tnval = mask - nval;\n\tif (AK_GET_NEEDSMSB(kcontrol->private_value))\n\t\tnval |= 0x80;\n\t \n\tsnd_akm4xxx_write(ak, chip, addr, nval);\n\treturn 1;\n}\n\nstatic int snd_akm4xxx_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tunsigned int mask = AK_GET_MASK(kcontrol->private_value);\n\tunsigned int val = ucontrol->value.integer.value[0];\n\tif (val > mask)\n\t\treturn -EINVAL;\n\treturn put_ak_reg(kcontrol, AK_GET_ADDR(kcontrol->private_value), val);\n}\n\nstatic int snd_akm4xxx_stereo_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int mask = AK_GET_MASK(kcontrol->private_value);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_akm4xxx_stereo_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\n\tucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);\n\tucontrol->value.integer.value[1] = snd_akm4xxx_get_vol(ak, chip, addr+1);\n\treturn 0;\n}\n\nstatic int snd_akm4xxx_stereo_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tunsigned int mask = AK_GET_MASK(kcontrol->private_value);\n\tunsigned int val[2];\n\tint change;\n\n\tval[0] = ucontrol->value.integer.value[0];\n\tval[1] = ucontrol->value.integer.value[1];\n\tif (val[0] > mask || val[1] > mask)\n\t\treturn -EINVAL;\n\tchange = put_ak_reg(kcontrol, addr, val[0]);\n\tchange |= put_ak_reg(kcontrol, addr + 1, val[1]);\n\treturn change;\n}\n\nstatic int snd_akm4xxx_deemphasis_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"44.1kHz\", \"Off\", \"48kHz\", \"32kHz\",\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\n\nstatic int snd_akm4xxx_deemphasis_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint shift = AK_GET_SHIFT(kcontrol->private_value);\n\tucontrol->value.enumerated.item[0] =\n\t\t(snd_akm4xxx_get(ak, chip, addr) >> shift) & 3;\n\treturn 0;\n}\n\nstatic int snd_akm4xxx_deemphasis_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint shift = AK_GET_SHIFT(kcontrol->private_value);\n\tunsigned char nval = ucontrol->value.enumerated.item[0] & 3;\n\tint change;\n\t\n\tnval = (nval << shift) |\n\t\t(snd_akm4xxx_get(ak, chip, addr) & ~(3 << shift));\n\tchange = snd_akm4xxx_get(ak, chip, addr) != nval;\n\tif (change)\n\t\tsnd_akm4xxx_write(ak, chip, addr, nval);\n\treturn change;\n}\n\n#define ak4xxx_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int ak4xxx_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint shift = AK_GET_SHIFT(kcontrol->private_value);\n\tint invert = AK_GET_INVERT(kcontrol->private_value);\n\t \n\tunsigned char val = snd_akm4xxx_get(ak, chip, addr) & (1<<shift);\n\tif (invert)\n\t\tval = ! val;\n\tucontrol->value.integer.value[0] = (val & (1<<shift)) != 0;\n\treturn 0;\n}\n\nstatic int ak4xxx_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint shift = AK_GET_SHIFT(kcontrol->private_value);\n\tint invert = AK_GET_INVERT(kcontrol->private_value);\n\tlong flag = ucontrol->value.integer.value[0];\n\tunsigned char val, oval;\n\tint change;\n\n\tif (invert)\n\t\tflag = ! flag;\n\toval = snd_akm4xxx_get(ak, chip, addr);\n\tif (flag)\n\t\tval = oval | (1<<shift);\n\telse\n\t\tval = oval & ~(1<<shift);\n\tchange = (oval != val);\n\tif (change)\n\t\tsnd_akm4xxx_write(ak, chip, addr, val);\n\treturn change;\n}\n\n#define AK5365_NUM_INPUTS 5\n\nstatic int ak4xxx_capture_num_inputs(struct snd_akm4xxx *ak, int mixer_ch)\n{\n\tint num_names;\n\tconst char **input_names;\n\n\tinput_names = ak->adc_info[mixer_ch].input_names;\n\tnum_names = 0;\n\twhile (num_names < AK5365_NUM_INPUTS && input_names[num_names])\n\t\t++num_names;\n\treturn num_names;\n}\n\nstatic int ak4xxx_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint mixer_ch = AK_GET_SHIFT(kcontrol->private_value);\n\tunsigned int num_names;\n\n\tnum_names = ak4xxx_capture_num_inputs(ak, mixer_ch);\n\tif (!num_names)\n\t\treturn -EINVAL;\n\treturn snd_ctl_enum_info(uinfo, 1, num_names,\n\t\t\t\t ak->adc_info[mixer_ch].input_names);\n}\n\nstatic int ak4xxx_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint mask = AK_GET_MASK(kcontrol->private_value);\n\tunsigned char val;\n\n\tval = snd_akm4xxx_get(ak, chip, addr) & mask;\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\nstatic int ak4xxx_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\n\tint mixer_ch = AK_GET_SHIFT(kcontrol->private_value);\n\tint chip = AK_GET_CHIP(kcontrol->private_value);\n\tint addr = AK_GET_ADDR(kcontrol->private_value);\n\tint mask = AK_GET_MASK(kcontrol->private_value);\n\tunsigned char oval, val;\n\tint num_names = ak4xxx_capture_num_inputs(ak, mixer_ch);\n\n\tif (ucontrol->value.enumerated.item[0] >= num_names)\n\t\treturn -EINVAL;\n\n\toval = snd_akm4xxx_get(ak, chip, addr);\n\tval = oval & ~mask;\n\tval |= ucontrol->value.enumerated.item[0] & mask;\n\tif (val != oval) {\n\t\tsnd_akm4xxx_write(ak, chip, addr, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int build_dac_controls(struct snd_akm4xxx *ak)\n{\n\tint idx, err, mixer_ch, num_stereo;\n\tstruct snd_kcontrol_new knew;\n\n\tmixer_ch = 0;\n\tfor (idx = 0; idx < ak->num_dacs; ) {\n\t\t \n\t\tif (ak->type == SND_AK4381 \n\t\t\t\t&&  ak->dac_info[mixer_ch].switch_name) {\n\t\t\tmemset(&knew, 0, sizeof(knew));\n\t\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\t\tknew.count = 1;\n\t\t\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t\t\tknew.name = ak->dac_info[mixer_ch].switch_name;\n\t\t\tknew.info = ak4xxx_switch_info;\n\t\t\tknew.get = ak4xxx_switch_get;\n\t\t\tknew.put = ak4xxx_switch_put;\n\t\t\tknew.access = 0;\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, 1, 0, 0) | AK_INVERT;\n\t\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tmemset(&knew, 0, sizeof(knew));\n\t\tif (! ak->dac_info || ! ak->dac_info[mixer_ch].name) {\n\t\t\tknew.name = \"DAC Volume\";\n\t\t\tknew.index = mixer_ch + ak->idx_offset * 2;\n\t\t\tnum_stereo = 1;\n\t\t} else {\n\t\t\tknew.name = ak->dac_info[mixer_ch].name;\n\t\t\tnum_stereo = ak->dac_info[mixer_ch].num_channels;\n\t\t}\n\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tknew.count = 1;\n\t\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tif (num_stereo == 2) {\n\t\t\tknew.info = snd_akm4xxx_stereo_volume_info;\n\t\t\tknew.get = snd_akm4xxx_stereo_volume_get;\n\t\t\tknew.put = snd_akm4xxx_stereo_volume_put;\n\t\t} else {\n\t\t\tknew.info = snd_akm4xxx_volume_info;\n\t\t\tknew.get = snd_akm4xxx_volume_get;\n\t\t\tknew.put = snd_akm4xxx_volume_put;\n\t\t}\n\t\tswitch (ak->type) {\n\t\tcase SND_AK4524:\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, (idx%2) + 6, 0, 127) |\n\t\t\t\tAK_VOL_CVT;\n\t\t\tknew.tlv.p = db_scale_vol_datt;\n\t\t\tbreak;\n\t\tcase SND_AK4528:\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, (idx%2) + 4, 0, 127) |\n\t\t\t\tAK_VOL_CVT;\n\t\t\tknew.tlv.p = db_scale_vol_datt;\n\t\t\tbreak;\n\t\tcase SND_AK4529: {\n\t\t\t \n\t\t\tint val = idx < 6 ? idx + 2 : (idx - 6) + 0xb;\n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(0, val, 0, 255) | AK_INVERT;\n\t\t\tknew.tlv.p = db_scale_8bit;\n\t\t\tbreak;\n\t\t}\n\t\tcase SND_AK4355:\n\t\t\t \n\t\t\tknew.private_value = AK_COMPOSE(0, idx + 4, 0, 255);\n\t\t\tknew.tlv.p = db_scale_8bit;\n\t\t\tbreak;\n\t\tcase SND_AK4358: {\n\t\t\t \n\t\t\tint  addr = idx < 6 ? idx + 4 : idx + 5;\n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(0, addr, 0, 127) | AK_NEEDSMSB;\n\t\t\tknew.tlv.p = db_scale_7bit;\n\t\t\tbreak;\n\t\t}\n\t\tcase SND_AK4381:\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, (idx%2) + 3, 0, 255);\n\t\t\tknew.tlv.p = db_scale_linear;\n\t\t\tbreak;\n\t\tcase SND_AK4620:\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, (idx%2) + 6, 0, 255);\n\t\t\tknew.tlv.p = db_scale_linear;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tidx += num_stereo;\n\t\tmixer_ch++;\n\t}\n\treturn 0;\n}\n\nstatic int build_adc_controls(struct snd_akm4xxx *ak)\n{\n\tint idx, err, mixer_ch, num_stereo, max_steps;\n\tstruct snd_kcontrol_new knew;\n\n\tmixer_ch = 0;\n\tif (ak->type == SND_AK4528)\n\t\treturn 0;\t \n\tfor (idx = 0; idx < ak->num_adcs;) {\n\t\tmemset(&knew, 0, sizeof(knew));\n\t\tif (! ak->adc_info || ! ak->adc_info[mixer_ch].name) {\n\t\t\tknew.name = \"ADC Volume\";\n\t\t\tknew.index = mixer_ch + ak->idx_offset * 2;\n\t\t\tnum_stereo = 1;\n\t\t} else {\n\t\t\tknew.name = ak->adc_info[mixer_ch].name;\n\t\t\tnum_stereo = ak->adc_info[mixer_ch].num_channels;\n\t\t}\n\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tknew.count = 1;\n\t\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tif (num_stereo == 2) {\n\t\t\tknew.info = snd_akm4xxx_stereo_volume_info;\n\t\t\tknew.get = snd_akm4xxx_stereo_volume_get;\n\t\t\tknew.put = snd_akm4xxx_stereo_volume_put;\n\t\t} else {\n\t\t\tknew.info = snd_akm4xxx_volume_info;\n\t\t\tknew.get = snd_akm4xxx_volume_get;\n\t\t\tknew.put = snd_akm4xxx_volume_put;\n\t\t}\n\t\t \n\t\tif (ak->type == SND_AK5365)\n\t\t\tmax_steps = 152;\n\t\telse\n\t\t\tmax_steps = 164;\n\t\tknew.private_value =\n\t\t\tAK_COMPOSE(idx/2, (idx%2) + 4, 0, max_steps) |\n\t\t\tAK_VOL_CVT | AK_IPGA;\n\t\tknew.tlv.p = db_scale_vol_datt;\n\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (ak->type == SND_AK5365 && (idx % 2) == 0) {\n\t\t\tif (! ak->adc_info || \n\t\t\t    ! ak->adc_info[mixer_ch].switch_name) {\n\t\t\t\tknew.name = \"Capture Switch\";\n\t\t\t\tknew.index = mixer_ch + ak->idx_offset * 2;\n\t\t\t} else\n\t\t\t\tknew.name = ak->adc_info[mixer_ch].switch_name;\n\t\t\tknew.info = ak4xxx_switch_info;\n\t\t\tknew.get = ak4xxx_switch_get;\n\t\t\tknew.put = ak4xxx_switch_put;\n\t\t\tknew.access = 0;\n\t\t\t \n\t\t\tknew.private_value =\n\t\t\t\tAK_COMPOSE(idx/2, 2, 0, 0) | AK_INVERT;\n\t\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tmemset(&knew, 0, sizeof(knew));\n\t\t\tif (!ak->adc_info ||\n\t\t\t\t!ak->adc_info[mixer_ch].selector_name) {\n\t\t\t\tknew.name = \"Capture Channel\";\n\t\t\t\tknew.index = mixer_ch + ak->idx_offset * 2;\n\t\t\t} else\n\t\t\t\tknew.name = ak->adc_info[mixer_ch].selector_name;\n\n\t\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\t\tknew.info = ak4xxx_capture_source_info;\n\t\t\tknew.get = ak4xxx_capture_source_get;\n\t\t\tknew.put = ak4xxx_capture_source_put;\n\t\t\tknew.access = 0;\n\t\t\t \n\t\t\tknew.private_value\n\t\t\t\t= AK_COMPOSE(idx/2, 1, mixer_ch, 0x07);\n\t\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tidx += num_stereo;\n\t\tmixer_ch++;\n\t}\n\treturn 0;\n}\n\nstatic int build_deemphasis(struct snd_akm4xxx *ak, int num_emphs)\n{\n\tint idx, err;\n\tstruct snd_kcontrol_new knew;\n\n\tfor (idx = 0; idx < num_emphs; idx++) {\n\t\tmemset(&knew, 0, sizeof(knew));\n\t\tknew.name = \"Deemphasis\";\n\t\tknew.index = idx + ak->idx_offset;\n\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tknew.count = 1;\n\t\tknew.info = snd_akm4xxx_deemphasis_info;\n\t\tknew.get = snd_akm4xxx_deemphasis_get;\n\t\tknew.put = snd_akm4xxx_deemphasis_put;\n\t\tswitch (ak->type) {\n\t\tcase SND_AK4524:\n\t\tcase SND_AK4528:\n\t\tcase SND_AK4620:\n\t\t\t \n\t\t\tknew.private_value = AK_COMPOSE(idx, 3, 0, 0);\n\t\t\tbreak;\n\t\tcase SND_AK4529: {\n\t\t\tint shift = idx == 3 ? 6 : (2 - idx) * 2;\n\t\t\t \n\t\t\tknew.private_value = AK_COMPOSE(0, 8, shift, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase SND_AK4355:\n\t\tcase SND_AK4358:\n\t\t\tknew.private_value = AK_COMPOSE(idx, 3, 0, 0);\n\t\t\tbreak;\n\t\tcase SND_AK4381:\n\t\t\tknew.private_value = AK_COMPOSE(idx, 1, 1, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void proc_regs_read(struct snd_info_entry *entry,\n\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_akm4xxx *ak = entry->private_data;\n\tint reg, val, chip;\n\tfor (chip = 0; chip < ak->num_chips; chip++) {\n\t\tfor (reg = 0; reg < ak->total_regs; reg++) {\n\t\t\tval =  snd_akm4xxx_get(ak, chip, reg);\n\t\t\tsnd_iprintf(buffer, \"chip %d: 0x%02x = 0x%02x\\n\", chip,\n\t\t\t\t\treg, val);\n\t\t}\n\t}\n}\n\nstatic int proc_init(struct snd_akm4xxx *ak)\n{\n\treturn snd_card_ro_proc_new(ak->card, ak->name, ak, proc_regs_read);\n}\n\nint snd_akm4xxx_build_controls(struct snd_akm4xxx *ak)\n{\n\tint err, num_emphs;\n\n\terr = build_dac_controls(ak);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = build_adc_controls(ak);\n\tif (err < 0)\n\t\treturn err;\n\tif (ak->type == SND_AK4355 || ak->type == SND_AK4358)\n\t\tnum_emphs = 1;\n\telse if (ak->type == SND_AK4620)\n\t\tnum_emphs = 0;\n\telse\n\t\tnum_emphs = ak->num_dacs / 2;\n\terr = build_deemphasis(ak, num_emphs);\n\tif (err < 0)\n\t\treturn err;\n\terr = proc_init(ak);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_akm4xxx_build_controls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}