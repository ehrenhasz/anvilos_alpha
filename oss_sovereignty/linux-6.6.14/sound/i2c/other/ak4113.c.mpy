{
  "module_name": "ak4113.c",
  "hash_id": "643cfac4f4cea7e98ba6bc9ac131f3caac2c3c6ab404047a06b4ac2700d07f9f",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/other/ak4113.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/ak4113.h>\n#include <sound/asoundef.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"Pavel Hofman <pavel.hofman@ivitera.com>\");\nMODULE_DESCRIPTION(\"AK4113 IEC958 (S/PDIF) receiver by Asahi Kasei\");\nMODULE_LICENSE(\"GPL\");\n\n#define AK4113_ADDR\t\t\t0x00  \n\nstatic void ak4113_stats(struct work_struct *work);\nstatic void ak4113_init_regs(struct ak4113 *chip);\n\n\nstatic void reg_write(struct ak4113 *ak4113, unsigned char reg,\n\t\tunsigned char val)\n{\n\tak4113->write(ak4113->private_data, reg, val);\n\tif (reg < sizeof(ak4113->regmap))\n\t\tak4113->regmap[reg] = val;\n}\n\nstatic inline unsigned char reg_read(struct ak4113 *ak4113, unsigned char reg)\n{\n\treturn ak4113->read(ak4113->private_data, reg);\n}\n\nstatic void snd_ak4113_free(struct ak4113 *chip)\n{\n\tatomic_inc(&chip->wq_processing);\t \n\tcancel_delayed_work_sync(&chip->work);\n\tkfree(chip);\n}\n\nstatic int snd_ak4113_dev_free(struct snd_device *device)\n{\n\tstruct ak4113 *chip = device->device_data;\n\tsnd_ak4113_free(chip);\n\treturn 0;\n}\n\nint snd_ak4113_create(struct snd_card *card, ak4113_read_t *read,\n\t\tak4113_write_t *write, const unsigned char *pgm,\n\t\tvoid *private_data, struct ak4113 **r_ak4113)\n{\n\tstruct ak4113 *chip;\n\tint err;\n\tunsigned char reg;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =     snd_ak4113_dev_free,\n\t};\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&chip->lock);\n\tchip->card = card;\n\tchip->read = read;\n\tchip->write = write;\n\tchip->private_data = private_data;\n\tINIT_DELAYED_WORK(&chip->work, ak4113_stats);\n\tatomic_set(&chip->wq_processing, 0);\n\tmutex_init(&chip->reinit_mutex);\n\n\tfor (reg = 0; reg < AK4113_WRITABLE_REGS ; reg++)\n\t\tchip->regmap[reg] = pgm[reg];\n\tak4113_init_regs(chip);\n\n\tchip->rcs0 = reg_read(chip, AK4113_REG_RCS0) & ~(AK4113_QINT |\n\t\t\tAK4113_CINT | AK4113_STC);\n\tchip->rcs1 = reg_read(chip, AK4113_REG_RCS1);\n\tchip->rcs2 = reg_read(chip, AK4113_REG_RCS2);\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops);\n\tif (err < 0)\n\t\tgoto __fail;\n\n\tif (r_ak4113)\n\t\t*r_ak4113 = chip;\n\treturn 0;\n\n__fail:\n\tsnd_ak4113_free(chip);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_create);\n\nvoid snd_ak4113_reg_write(struct ak4113 *chip, unsigned char reg,\n\t\tunsigned char mask, unsigned char val)\n{\n\tif (reg >= AK4113_WRITABLE_REGS)\n\t\treturn;\n\treg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_reg_write);\n\nstatic void ak4113_init_regs(struct ak4113 *chip)\n{\n\tunsigned char old = chip->regmap[AK4113_REG_PWRDN], reg;\n\n\t \n\treg_write(chip, AK4113_REG_PWRDN, old & ~(AK4113_RST|AK4113_PWN));\n\tudelay(200);\n\t \n\treg_write(chip, AK4113_REG_PWRDN, (old | AK4113_RST) & ~AK4113_PWN);\n\tudelay(200);\n\tfor (reg = 1; reg < AK4113_WRITABLE_REGS; reg++)\n\t\treg_write(chip, reg, chip->regmap[reg]);\n\t \n\treg_write(chip, AK4113_REG_PWRDN, old | AK4113_RST | AK4113_PWN);\n}\n\nvoid snd_ak4113_reinit(struct ak4113 *chip)\n{\n\tif (atomic_inc_return(&chip->wq_processing) == 1)\n\t\tcancel_delayed_work_sync(&chip->work);\n\tmutex_lock(&chip->reinit_mutex);\n\tak4113_init_regs(chip);\n\tmutex_unlock(&chip->reinit_mutex);\n\t \n\tif (atomic_dec_and_test(&chip->wq_processing))\n\t\tschedule_delayed_work(&chip->work, HZ / 10);\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_reinit);\n\nstatic unsigned int external_rate(unsigned char rcs1)\n{\n\tswitch (rcs1 & (AK4113_FS0|AK4113_FS1|AK4113_FS2|AK4113_FS3)) {\n\tcase AK4113_FS_8000HZ:\n\t\treturn 8000;\n\tcase AK4113_FS_11025HZ:\n\t\treturn 11025;\n\tcase AK4113_FS_16000HZ:\n\t\treturn 16000;\n\tcase AK4113_FS_22050HZ:\n\t\treturn 22050;\n\tcase AK4113_FS_24000HZ:\n\t\treturn 24000;\n\tcase AK4113_FS_32000HZ:\n\t\treturn 32000;\n\tcase AK4113_FS_44100HZ:\n\t\treturn 44100;\n\tcase AK4113_FS_48000HZ:\n\t\treturn 48000;\n\tcase AK4113_FS_64000HZ:\n\t\treturn 64000;\n\tcase AK4113_FS_88200HZ:\n\t\treturn 88200;\n\tcase AK4113_FS_96000HZ:\n\t\treturn 96000;\n\tcase AK4113_FS_176400HZ:\n\t\treturn 176400;\n\tcase AK4113_FS_192000HZ:\n\t\treturn 192000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int snd_ak4113_in_error_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = LONG_MAX;\n\treturn 0;\n}\n\nstatic int snd_ak4113_in_error_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->lock);\n\tucontrol->value.integer.value[0] =\n\t\tchip->errors[kcontrol->private_value];\n\tchip->errors[kcontrol->private_value] = 0;\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n#define snd_ak4113_in_bit_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ak4113_in_bit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char reg = kcontrol->private_value & 0xff;\n\tunsigned char bit = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned char inv = (kcontrol->private_value >> 31) & 1;\n\n\tucontrol->value.integer.value[0] =\n\t\t((reg_read(chip, reg) & (1 << bit)) ? 1 : 0) ^ inv;\n\treturn 0;\n}\n\nstatic int snd_ak4113_rx_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 5;\n\treturn 0;\n}\n\nstatic int snd_ak4113_rx_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] =\n\t\t(AK4113_IPS(chip->regmap[AK4113_REG_IO1]));\n\treturn 0;\n}\n\nstatic int snd_ak4113_rx_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu8 old_val;\n\n\tspin_lock_irq(&chip->lock);\n\told_val = chip->regmap[AK4113_REG_IO1];\n\tchange = ucontrol->value.integer.value[0] != AK4113_IPS(old_val);\n\tif (change)\n\t\treg_write(chip, AK4113_REG_IO1,\n\t\t\t\t(old_val & (~AK4113_IPS(0xff))) |\n\t\t\t\t(AK4113_IPS(ucontrol->value.integer.value[0])));\n\tspin_unlock_irq(&chip->lock);\n\treturn change;\n}\n\nstatic int snd_ak4113_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\treturn 0;\n}\n\nstatic int snd_ak4113_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = external_rate(reg_read(chip,\n\t\t\t\tAK4113_REG_RCS1));\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4113_REG_RXCSB_SIZE; i++)\n\t\tucontrol->value.iec958.status[i] = reg_read(chip,\n\t\t\t\tAK4113_REG_RXCSB0 + i);\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff, AK4113_REG_RXCSB_SIZE);\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_pinfo(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffff;\n\tuinfo->count = 4;\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_pget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned short tmp;\n\n\tucontrol->value.integer.value[0] = 0xf8f2;\n\tucontrol->value.integer.value[1] = 0x4e1f;\n\ttmp = reg_read(chip, AK4113_REG_Pc0) |\n\t\t(reg_read(chip, AK4113_REG_Pc1) << 8);\n\tucontrol->value.integer.value[2] = tmp;\n\ttmp = reg_read(chip, AK4113_REG_Pd0) |\n\t\t(reg_read(chip, AK4113_REG_Pd1) << 8);\n\tucontrol->value.integer.value[3] = tmp;\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_qinfo(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = AK4113_REG_QSUB_SIZE;\n\treturn 0;\n}\n\nstatic int snd_ak4113_spdif_qget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4113 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4113_REG_QSUB_SIZE; i++)\n\t\tucontrol->value.bytes.data[i] = reg_read(chip,\n\t\t\t\tAK4113_REG_QSUB_ADDR + i);\n\treturn 0;\n}\n\n \nstatic const struct snd_kcontrol_new snd_ak4113_iec958_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Parity Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_error_info,\n\t.get =\t\tsnd_ak4113_in_error_get,\n\t.private_value = AK4113_PARITY_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 V-Bit Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_error_info,\n\t.get =\t\tsnd_ak4113_in_error_get,\n\t.private_value = AK4113_V_BIT_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 C-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_error_info,\n\t.get =\t\tsnd_ak4113_in_error_get,\n\t.private_value = AK4113_CCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_error_info,\n\t.get =\t\tsnd_ak4113_in_error_get,\n\t.private_value = AK4113_QCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 External Rate\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_rate_info,\n\t.get =\t\tsnd_ak4113_rate_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\", CAPTURE, MASK),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.info =\t\tsnd_ak4113_spdif_mask_info,\n\t.get =\t\tsnd_ak4113_spdif_mask_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_spdif_info,\n\t.get =\t\tsnd_ak4113_spdif_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Preamble Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_spdif_pinfo,\n\t.get =\t\tsnd_ak4113_spdif_pget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-subcode Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_spdif_qinfo,\n\t.get =\t\tsnd_ak4113_spdif_qget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Audio\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_bit_info,\n\t.get =\t\tsnd_ak4113_in_bit_get,\n\t.private_value = (1<<31) | (1<<8) | AK4113_REG_RCS0,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Non-PCM Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_bit_info,\n\t.get =\t\tsnd_ak4113_in_bit_get,\n\t.private_value = (0<<8) | AK4113_REG_RCS1,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 DTS Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4113_in_bit_info,\n\t.get =\t\tsnd_ak4113_in_bit_get,\n\t.private_value = (1<<8) | AK4113_REG_RCS1,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"AK4113 Input Select\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_WRITE,\n\t.info =\t\tsnd_ak4113_rx_info,\n\t.get =\t\tsnd_ak4113_rx_get,\n\t.put =\t\tsnd_ak4113_rx_put,\n}\n};\n\nstatic void snd_ak4113_proc_regs_read(struct snd_info_entry *entry,\n\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct ak4113 *ak4113 = entry->private_data;\n\tint reg, val;\n\t \n\tfor (reg = 0; reg < 0x1d; reg++) {\n\t\tval = reg_read(ak4113, reg);\n\t\tsnd_iprintf(buffer, \"0x%02x = 0x%02x\\n\", reg, val);\n\t}\n}\n\nstatic void snd_ak4113_proc_init(struct ak4113 *ak4113)\n{\n\tsnd_card_ro_proc_new(ak4113->card, \"ak4113\", ak4113,\n\t\t\t     snd_ak4113_proc_regs_read);\n}\n\nint snd_ak4113_build(struct ak4113 *ak4113,\n\t\tstruct snd_pcm_substream *cap_substream)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cap_substream))\n\t\treturn -EINVAL;\n\tak4113->substream = cap_substream;\n\tfor (idx = 0; idx < AK4113_CONTROLS; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_ak4113_iec958_controls[idx], ak4113);\n\t\tif (kctl == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.device = cap_substream->pcm->device;\n\t\tkctl->id.subdevice = cap_substream->number;\n\t\terr = snd_ctl_add(ak4113->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tak4113->kctls[idx] = kctl;\n\t}\n\tsnd_ak4113_proc_init(ak4113);\n\t \n\tschedule_delayed_work(&ak4113->work, HZ / 10);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_build);\n\nint snd_ak4113_external_rate(struct ak4113 *ak4113)\n{\n\tunsigned char rcs1;\n\n\trcs1 = reg_read(ak4113, AK4113_REG_RCS1);\n\treturn external_rate(rcs1);\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_external_rate);\n\nint snd_ak4113_check_rate_and_errors(struct ak4113 *ak4113, unsigned int flags)\n{\n\tstruct snd_pcm_runtime *runtime =\n\t\tak4113->substream ? ak4113->substream->runtime : NULL;\n\tunsigned long _flags;\n\tint res = 0;\n\tunsigned char rcs0, rcs1, rcs2;\n\tunsigned char c0, c1;\n\n\trcs1 = reg_read(ak4113, AK4113_REG_RCS1);\n\tif (flags & AK4113_CHECK_NO_STAT)\n\t\tgoto __rate;\n\trcs0 = reg_read(ak4113, AK4113_REG_RCS0);\n\trcs2 = reg_read(ak4113, AK4113_REG_RCS2);\n\tspin_lock_irqsave(&ak4113->lock, _flags);\n\tif (rcs0 & AK4113_PAR)\n\t\tak4113->errors[AK4113_PARITY_ERRORS]++;\n\tif (rcs0 & AK4113_V)\n\t\tak4113->errors[AK4113_V_BIT_ERRORS]++;\n\tif (rcs2 & AK4113_CCRC)\n\t\tak4113->errors[AK4113_CCRC_ERRORS]++;\n\tif (rcs2 & AK4113_QCRC)\n\t\tak4113->errors[AK4113_QCRC_ERRORS]++;\n\tc0 = (ak4113->rcs0 & (AK4113_QINT | AK4113_CINT | AK4113_STC |\n\t\t\t\tAK4113_AUDION | AK4113_AUTO | AK4113_UNLCK)) ^\n\t\t(rcs0 & (AK4113_QINT | AK4113_CINT | AK4113_STC |\n\t\t\t AK4113_AUDION | AK4113_AUTO | AK4113_UNLCK));\n\tc1 = (ak4113->rcs1 & (AK4113_DTSCD | AK4113_NPCM | AK4113_PEM |\n\t\t\t\tAK4113_DAT | 0xf0)) ^\n\t\t(rcs1 & (AK4113_DTSCD | AK4113_NPCM | AK4113_PEM |\n\t\t\t AK4113_DAT | 0xf0));\n\tak4113->rcs0 = rcs0 & ~(AK4113_QINT | AK4113_CINT | AK4113_STC);\n\tak4113->rcs1 = rcs1;\n\tak4113->rcs2 = rcs2;\n\tspin_unlock_irqrestore(&ak4113->lock, _flags);\n\n\tif (rcs0 & AK4113_PAR)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[0]->id);\n\tif (rcs0 & AK4113_V)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[1]->id);\n\tif (rcs2 & AK4113_CCRC)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[2]->id);\n\tif (rcs2 & AK4113_QCRC)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[3]->id);\n\n\t \n\tif (c1 & 0xf0)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[4]->id);\n\n\tif ((c1 & AK4113_PEM) | (c0 & AK4113_CINT))\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[6]->id);\n\tif (c0 & AK4113_QINT)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[8]->id);\n\n\tif (c0 & AK4113_AUDION)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[9]->id);\n\tif (c1 & AK4113_NPCM)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[10]->id);\n\tif (c1 & AK4113_DTSCD)\n\t\tsnd_ctl_notify(ak4113->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&ak4113->kctls[11]->id);\n\n\tif (ak4113->change_callback && (c0 | c1) != 0)\n\t\tak4113->change_callback(ak4113, c0, c1);\n\n__rate:\n\t \n\tres = external_rate(rcs1);\n\tif (!(flags & AK4113_CHECK_NO_RATE) && runtime &&\n\t\t\t(runtime->rate != res)) {\n\t\tsnd_pcm_stream_lock_irqsave(ak4113->substream, _flags);\n\t\tif (snd_pcm_running(ak4113->substream)) {\n\t\t\t \n\t\t\tsnd_pcm_stop(ak4113->substream,\n\t\t\t\t\tSNDRV_PCM_STATE_DRAINING);\n\t\t\twake_up(&runtime->sleep);\n\t\t\tres = 1;\n\t\t}\n\t\tsnd_pcm_stream_unlock_irqrestore(ak4113->substream, _flags);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(snd_ak4113_check_rate_and_errors);\n\nstatic void ak4113_stats(struct work_struct *work)\n{\n\tstruct ak4113 *chip = container_of(work, struct ak4113, work.work);\n\n\tif (atomic_inc_return(&chip->wq_processing) == 1)\n\t\tsnd_ak4113_check_rate_and_errors(chip, chip->check_flags);\n\n\tif (atomic_dec_and_test(&chip->wq_processing))\n\t\tschedule_delayed_work(&chip->work, HZ / 10);\n}\n\n#ifdef CONFIG_PM\nvoid snd_ak4113_suspend(struct ak4113 *chip)\n{\n\tatomic_inc(&chip->wq_processing);  \n\tcancel_delayed_work_sync(&chip->work);\n}\nEXPORT_SYMBOL(snd_ak4113_suspend);\n\nvoid snd_ak4113_resume(struct ak4113 *chip)\n{\n\tatomic_dec(&chip->wq_processing);\n\tsnd_ak4113_reinit(chip);\n}\nEXPORT_SYMBOL(snd_ak4113_resume);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}