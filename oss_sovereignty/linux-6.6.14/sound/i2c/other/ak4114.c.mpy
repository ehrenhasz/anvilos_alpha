{
  "module_name": "ak4114.c",
  "hash_id": "9197a74f497d5b8d681172d5cb9c793fd172da2c22b76716bbbb1b7f1a846cd3",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/other/ak4114.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/ak4114.h>\n#include <sound/asoundef.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"AK4114 IEC958 (S/PDIF) receiver by Asahi Kasei\");\nMODULE_LICENSE(\"GPL\");\n\n#define AK4114_ADDR\t\t\t0x00  \n\nstatic void ak4114_stats(struct work_struct *work);\nstatic void ak4114_init_regs(struct ak4114 *chip);\n\nstatic void reg_write(struct ak4114 *ak4114, unsigned char reg, unsigned char val)\n{\n\tak4114->write(ak4114->private_data, reg, val);\n\tif (reg <= AK4114_REG_INT1_MASK)\n\t\tak4114->regmap[reg] = val;\n\telse if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)\n\t\tak4114->txcsb[reg-AK4114_REG_TXCSB0] = val;\n}\n\nstatic inline unsigned char reg_read(struct ak4114 *ak4114, unsigned char reg)\n{\n\treturn ak4114->read(ak4114->private_data, reg);\n}\n\n#if 0\nstatic void reg_dump(struct ak4114 *ak4114)\n{\n\tint i;\n\n\tprintk(KERN_DEBUG \"AK4114 REG DUMP:\\n\");\n\tfor (i = 0; i < 0x20; i++)\n\t\tprintk(KERN_DEBUG \"reg[%02x] = %02x (%02x)\\n\", i, reg_read(ak4114, i), i < ARRAY_SIZE(ak4114->regmap) ? ak4114->regmap[i] : 0);\n}\n#endif\n\nstatic void snd_ak4114_free(struct ak4114 *chip)\n{\n\tatomic_inc(&chip->wq_processing);\t \n\tcancel_delayed_work_sync(&chip->work);\n\tkfree(chip);\n}\n\nstatic int snd_ak4114_dev_free(struct snd_device *device)\n{\n\tstruct ak4114 *chip = device->device_data;\n\tsnd_ak4114_free(chip);\n\treturn 0;\n}\n\nint snd_ak4114_create(struct snd_card *card,\n\t\t      ak4114_read_t *read, ak4114_write_t *write,\n\t\t      const unsigned char pgm[6], const unsigned char txcsb[5],\n\t\t      void *private_data, struct ak4114 **r_ak4114)\n{\n\tstruct ak4114 *chip;\n\tint err = 0;\n\tunsigned char reg;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =     snd_ak4114_dev_free,\n\t};\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&chip->lock);\n\tchip->card = card;\n\tchip->read = read;\n\tchip->write = write;\n\tchip->private_data = private_data;\n\tINIT_DELAYED_WORK(&chip->work, ak4114_stats);\n\tatomic_set(&chip->wq_processing, 0);\n\tmutex_init(&chip->reinit_mutex);\n\n\tfor (reg = 0; reg < 6; reg++)\n\t\tchip->regmap[reg] = pgm[reg];\n\tfor (reg = 0; reg < 5; reg++)\n\t\tchip->txcsb[reg] = txcsb[reg];\n\n\tak4114_init_regs(chip);\n\n\tchip->rcs0 = reg_read(chip, AK4114_REG_RCS0) & ~(AK4114_QINT | AK4114_CINT);\n\tchip->rcs1 = reg_read(chip, AK4114_REG_RCS1);\n\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops);\n\tif (err < 0)\n\t\tgoto __fail;\n\n\tif (r_ak4114)\n\t\t*r_ak4114 = chip;\n\treturn 0;\n\n      __fail:\n\tsnd_ak4114_free(chip);\n\treturn err;\n}\nEXPORT_SYMBOL(snd_ak4114_create);\n\nvoid snd_ak4114_reg_write(struct ak4114 *chip, unsigned char reg, unsigned char mask, unsigned char val)\n{\n\tif (reg <= AK4114_REG_INT1_MASK)\n\t\treg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);\n\telse if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)\n\t\treg_write(chip, reg,\n\t\t\t  (chip->txcsb[reg-AK4114_REG_TXCSB0] & ~mask) | val);\n}\nEXPORT_SYMBOL(snd_ak4114_reg_write);\n\nstatic void ak4114_init_regs(struct ak4114 *chip)\n{\n\tunsigned char old = chip->regmap[AK4114_REG_PWRDN], reg;\n\n\t \n\treg_write(chip, AK4114_REG_PWRDN, old & ~(AK4114_RST|AK4114_PWN));\n\tudelay(200);\n\t \n\treg_write(chip, AK4114_REG_PWRDN, (old | AK4114_RST) & ~AK4114_PWN);\n\tudelay(200);\n\tfor (reg = 1; reg < 6; reg++)\n\t\treg_write(chip, reg, chip->regmap[reg]);\n\tfor (reg = 0; reg < 5; reg++)\n\t\treg_write(chip, reg + AK4114_REG_TXCSB0, chip->txcsb[reg]);\n\t \n\treg_write(chip, AK4114_REG_PWRDN, old | AK4114_RST | AK4114_PWN);\n}\n\nvoid snd_ak4114_reinit(struct ak4114 *chip)\n{\n\tif (atomic_inc_return(&chip->wq_processing) == 1)\n\t\tcancel_delayed_work_sync(&chip->work);\n\tmutex_lock(&chip->reinit_mutex);\n\tak4114_init_regs(chip);\n\tmutex_unlock(&chip->reinit_mutex);\n\t \n\tif (atomic_dec_and_test(&chip->wq_processing))\n\t\tschedule_delayed_work(&chip->work, HZ / 10);\n}\nEXPORT_SYMBOL(snd_ak4114_reinit);\n\nstatic unsigned int external_rate(unsigned char rcs1)\n{\n\tswitch (rcs1 & (AK4114_FS0|AK4114_FS1|AK4114_FS2|AK4114_FS3)) {\n\tcase AK4114_FS_32000HZ: return 32000;\n\tcase AK4114_FS_44100HZ: return 44100;\n\tcase AK4114_FS_48000HZ: return 48000;\n\tcase AK4114_FS_88200HZ: return 88200;\n\tcase AK4114_FS_96000HZ: return 96000;\n\tcase AK4114_FS_176400HZ: return 176400;\n\tcase AK4114_FS_192000HZ: return 192000;\n\tdefault:\t\treturn 0;\n\t}\n}\n\nstatic int snd_ak4114_in_error_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = LONG_MAX;\n\treturn 0;\n}\n\nstatic int snd_ak4114_in_error_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->lock);\n\tucontrol->value.integer.value[0] =\n\t\tchip->errors[kcontrol->private_value];\n\tchip->errors[kcontrol->private_value] = 0;\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n#define snd_ak4114_in_bit_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ak4114_in_bit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char reg = kcontrol->private_value & 0xff;\n\tunsigned char bit = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned char inv = (kcontrol->private_value >> 31) & 1;\n\n\tucontrol->value.integer.value[0] = ((reg_read(chip, reg) & (1 << bit)) ? 1 : 0) ^ inv;\n\treturn 0;\n}\n\nstatic int snd_ak4114_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\treturn 0;\n}\n\nstatic int snd_ak4114_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = external_rate(reg_read(chip, AK4114_REG_RCS1));\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4114_REG_RXCSB_SIZE; i++)\n\t\tucontrol->value.iec958.status[i] = reg_read(chip, AK4114_REG_RXCSB0 + i);\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_playback_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4114_REG_TXCSB_SIZE; i++)\n\t\tucontrol->value.iec958.status[i] = chip->txcsb[i];\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_playback_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4114_REG_TXCSB_SIZE; i++)\n\t\treg_write(chip, AK4114_REG_TXCSB0 + i, ucontrol->value.iec958.status[i]);\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff, AK4114_REG_RXCSB_SIZE);\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_pinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffff;\n\tuinfo->count = 4;\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_pget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned short tmp;\n\n\tucontrol->value.integer.value[0] = 0xf8f2;\n\tucontrol->value.integer.value[1] = 0x4e1f;\n\ttmp = reg_read(chip, AK4114_REG_Pc0) | (reg_read(chip, AK4114_REG_Pc1) << 8);\n\tucontrol->value.integer.value[2] = tmp;\n\ttmp = reg_read(chip, AK4114_REG_Pd0) | (reg_read(chip, AK4114_REG_Pd1) << 8);\n\tucontrol->value.integer.value[3] = tmp;\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_qinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = AK4114_REG_QSUB_SIZE;\n\treturn 0;\n}\n\nstatic int snd_ak4114_spdif_qget(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned i;\n\n\tfor (i = 0; i < AK4114_REG_QSUB_SIZE; i++)\n\t\tucontrol->value.bytes.data[i] = reg_read(chip, AK4114_REG_QSUB_ADDR + i);\n\treturn 0;\n}\n\n \nstatic const struct snd_kcontrol_new snd_ak4114_iec958_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Parity Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_error_info,\n\t.get =\t\tsnd_ak4114_in_error_get,\n\t.private_value = AK4114_PARITY_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 V-Bit Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_error_info,\n\t.get =\t\tsnd_ak4114_in_error_get,\n\t.private_value = AK4114_V_BIT_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 C-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_error_info,\n\t.get =\t\tsnd_ak4114_in_error_get,\n\t.private_value = AK4114_CCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-CRC Errors\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_error_info,\n\t.get =\t\tsnd_ak4114_in_error_get,\n\t.private_value = AK4114_QCRC_ERRORS,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 External Rate\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_rate_info,\n\t.get =\t\tsnd_ak4114_rate_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.info =\t\tsnd_ak4114_spdif_mask_info,\n\t.get =\t\tsnd_ak4114_spdif_mask_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_spdif_info,\n\t.get =\t\tsnd_ak4114_spdif_playback_get,\n\t.put =\t\tsnd_ak4114_spdif_playback_put,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",CAPTURE,MASK),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.info =\t\tsnd_ak4114_spdif_mask_info,\n\t.get =\t\tsnd_ak4114_spdif_mask_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",CAPTURE,DEFAULT),\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_spdif_info,\n\t.get =\t\tsnd_ak4114_spdif_get,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Preamble Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_spdif_pinfo,\n\t.get =\t\tsnd_ak4114_spdif_pget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Q-subcode Capture Default\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_spdif_qinfo,\n\t.get =\t\tsnd_ak4114_spdif_qget,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Audio\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_bit_info,\n\t.get =\t\tsnd_ak4114_in_bit_get,\n\t.private_value = (1<<31) | (1<<8) | AK4114_REG_RCS0,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 Non-PCM Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_bit_info,\n\t.get =\t\tsnd_ak4114_in_bit_get,\n\t.private_value = (6<<8) | AK4114_REG_RCS0,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 DTS Bitstream\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_bit_info,\n\t.get =\t\tsnd_ak4114_in_bit_get,\n\t.private_value = (3<<8) | AK4114_REG_RCS0,\n},\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\t\"IEC958 PPL Lock Status\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tsnd_ak4114_in_bit_info,\n\t.get =\t\tsnd_ak4114_in_bit_get,\n\t.private_value = (1<<31) | (4<<8) | AK4114_REG_RCS0,\n}\n};\n\n\nstatic void snd_ak4114_proc_regs_read(struct snd_info_entry *entry,\n\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct ak4114 *ak4114 = entry->private_data;\n\tint reg, val;\n\t \n\tfor (reg = 0; reg < 0x20; reg++) {\n\t\tval = reg_read(ak4114, reg);\n\t\tsnd_iprintf(buffer, \"0x%02x = 0x%02x\\n\", reg, val);\n\t}\n}\n\nstatic void snd_ak4114_proc_init(struct ak4114 *ak4114)\n{\n\tsnd_card_ro_proc_new(ak4114->card, \"ak4114\", ak4114,\n\t\t\t     snd_ak4114_proc_regs_read);\n}\n\nint snd_ak4114_build(struct ak4114 *ak4114,\n\t\t     struct snd_pcm_substream *ply_substream,\n\t\t     struct snd_pcm_substream *cap_substream)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cap_substream))\n\t\treturn -EINVAL;\n\tak4114->playback_substream = ply_substream;\n\tak4114->capture_substream = cap_substream;\n\tfor (idx = 0; idx < AK4114_CONTROLS; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_ak4114_iec958_controls[idx], ak4114);\n\t\tif (kctl == NULL)\n\t\t\treturn -ENOMEM;\n\t\tif (strstr(kctl->id.name, \"Playback\")) {\n\t\t\tif (ply_substream == NULL) {\n\t\t\t\tsnd_ctl_free_one(kctl);\n\t\t\t\tak4114->kctls[idx] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkctl->id.device = ply_substream->pcm->device;\n\t\t\tkctl->id.subdevice = ply_substream->number;\n\t\t} else {\n\t\t\tkctl->id.device = cap_substream->pcm->device;\n\t\t\tkctl->id.subdevice = cap_substream->number;\n\t\t}\n\t\terr = snd_ctl_add(ak4114->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tak4114->kctls[idx] = kctl;\n\t}\n\tsnd_ak4114_proc_init(ak4114);\n\t \n\tschedule_delayed_work(&ak4114->work, HZ / 10);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ak4114_build);\n\n \nstatic void ak4114_notify(struct ak4114 *ak4114,\n\t\t\t  unsigned char rcs0, unsigned char rcs1,\n\t\t\t  unsigned char c0, unsigned char c1)\n{\n\tif (!ak4114->kctls[0])\n\t\treturn;\n\n\tif (rcs0 & AK4114_PAR)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[0]->id);\n\tif (rcs0 & AK4114_V)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[1]->id);\n\tif (rcs1 & AK4114_CCRC)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[2]->id);\n\tif (rcs1 & AK4114_QCRC)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[3]->id);\n\n\t \n\tif (c1 & 0xf0)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[4]->id);\n\n\tif ((c0 & AK4114_PEM) | (c0 & AK4114_CINT))\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[9]->id);\n\tif (c0 & AK4114_QINT)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[10]->id);\n\n\tif (c0 & AK4114_AUDION)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[11]->id);\n\tif (c0 & AK4114_AUTO)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[12]->id);\n\tif (c0 & AK4114_DTSCD)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[13]->id);\n\tif (c0 & AK4114_UNLCK)\n\t\tsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &ak4114->kctls[14]->id);\n}\n\nint snd_ak4114_external_rate(struct ak4114 *ak4114)\n{\n\tunsigned char rcs1;\n\n\trcs1 = reg_read(ak4114, AK4114_REG_RCS1);\n\treturn external_rate(rcs1);\n}\nEXPORT_SYMBOL(snd_ak4114_external_rate);\n\nint snd_ak4114_check_rate_and_errors(struct ak4114 *ak4114, unsigned int flags)\n{\n\tstruct snd_pcm_runtime *runtime = ak4114->capture_substream ? ak4114->capture_substream->runtime : NULL;\n\tunsigned long _flags;\n\tint res = 0;\n\tunsigned char rcs0, rcs1;\n\tunsigned char c0, c1;\n\n\trcs1 = reg_read(ak4114, AK4114_REG_RCS1);\n\tif (flags & AK4114_CHECK_NO_STAT)\n\t\tgoto __rate;\n\trcs0 = reg_read(ak4114, AK4114_REG_RCS0);\n\tspin_lock_irqsave(&ak4114->lock, _flags);\n\tif (rcs0 & AK4114_PAR)\n\t\tak4114->errors[AK4114_PARITY_ERRORS]++;\n\tif (rcs1 & AK4114_V)\n\t\tak4114->errors[AK4114_V_BIT_ERRORS]++;\n\tif (rcs1 & AK4114_CCRC)\n\t\tak4114->errors[AK4114_CCRC_ERRORS]++;\n\tif (rcs1 & AK4114_QCRC)\n\t\tak4114->errors[AK4114_QCRC_ERRORS]++;\n\tc0 = (ak4114->rcs0 & (AK4114_QINT | AK4114_CINT | AK4114_PEM | AK4114_AUDION | AK4114_AUTO | AK4114_UNLCK)) ^\n                     (rcs0 & (AK4114_QINT | AK4114_CINT | AK4114_PEM | AK4114_AUDION | AK4114_AUTO | AK4114_UNLCK));\n\tc1 = (ak4114->rcs1 & 0xf0) ^ (rcs1 & 0xf0);\n\tak4114->rcs0 = rcs0 & ~(AK4114_QINT | AK4114_CINT);\n\tak4114->rcs1 = rcs1;\n\tspin_unlock_irqrestore(&ak4114->lock, _flags);\n\n\tak4114_notify(ak4114, rcs0, rcs1, c0, c1);\n\tif (ak4114->change_callback && (c0 | c1) != 0)\n\t\tak4114->change_callback(ak4114, c0, c1);\n\n      __rate:\n\t \n\tres = external_rate(rcs1);\n\tif (!(flags & AK4114_CHECK_NO_RATE) && runtime && runtime->rate != res) {\n\t\tsnd_pcm_stream_lock_irqsave(ak4114->capture_substream, _flags);\n\t\tif (snd_pcm_running(ak4114->capture_substream)) {\n\t\t\t\n\t\t\tsnd_pcm_stop(ak4114->capture_substream, SNDRV_PCM_STATE_DRAINING);\n\t\t\tres = 1;\n\t\t}\n\t\tsnd_pcm_stream_unlock_irqrestore(ak4114->capture_substream, _flags);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(snd_ak4114_check_rate_and_errors);\n\nstatic void ak4114_stats(struct work_struct *work)\n{\n\tstruct ak4114 *chip = container_of(work, struct ak4114, work.work);\n\n\tif (atomic_inc_return(&chip->wq_processing) == 1)\n\t\tsnd_ak4114_check_rate_and_errors(chip, chip->check_flags);\n\tif (atomic_dec_and_test(&chip->wq_processing))\n\t\tschedule_delayed_work(&chip->work, HZ / 10);\n}\n\n#ifdef CONFIG_PM\nvoid snd_ak4114_suspend(struct ak4114 *chip)\n{\n\tatomic_inc(&chip->wq_processing);  \n\tcancel_delayed_work_sync(&chip->work);\n}\nEXPORT_SYMBOL(snd_ak4114_suspend);\n\nvoid snd_ak4114_resume(struct ak4114 *chip)\n{\n\tatomic_dec(&chip->wq_processing);\n\tsnd_ak4114_reinit(chip);\n}\nEXPORT_SYMBOL(snd_ak4114_resume);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}