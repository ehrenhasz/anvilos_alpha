{
  "module_name": "pt2258.c",
  "hash_id": "a5f42ecf5fea4ca37b24b5193db025db2d1de77c26ae7fe9dbefac7a7cfc67c8",
  "original_prompt": "Ingested from linux-6.6.14/sound/i2c/other/pt2258.c",
  "human_readable_source": "\n       \n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/i2c.h>\n#include <sound/pt2258.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"Jochen Voss <voss@seehuhn.de>\");\nMODULE_DESCRIPTION(\"PT2258 volume controller (Princeton Technology Corp.)\");\nMODULE_LICENSE(\"GPL\");\n\n#define PT2258_CMD_RESET 0xc0\n#define PT2258_CMD_UNMUTE 0xf8\n#define PT2258_CMD_MUTE 0xf9\n\nstatic const unsigned char pt2258_channel_code[12] = {\n\t0x80, 0x90,\t\t \n\t0x40, 0x50,\t\t \n\t0x00, 0x10,\t\t \n\t0x20, 0x30,\t\t \n\t0x60, 0x70,\t\t \n\t0xa0, 0xb0\t\t \n};\n\nint snd_pt2258_reset(struct snd_pt2258 *pt)\n{\n\tunsigned char bytes[2];\n\tint i;\n\n\t \n\tbytes[0] = PT2258_CMD_RESET;\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\t \n\tpt->mute = 1;\n\tbytes[0] = PT2258_CMD_MUTE;\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\t \n\tfor (i = 0; i < 6; ++i)\n\t\tpt->volume[i] = 0;\n\tbytes[0] = 0xd0;\n\tbytes[1] = 0xe0;\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\treturn 0;\n\n      __error:\n\tsnd_i2c_unlock(pt->i2c_bus);\n\tsnd_printk(KERN_ERR \"PT2258 reset failed\\n\");\n\treturn -EIO;\n}\n\nstatic int pt2258_stereo_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 79;\n\treturn 0;\n}\n\nstatic int pt2258_stereo_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pt2258 *pt = kcontrol->private_data;\n\tint base = kcontrol->private_value;\n\n\t \n\tucontrol->value.integer.value[0] = 79 - pt->volume[base];\n\tucontrol->value.integer.value[1] = 79 - pt->volume[base + 1];\n\treturn 0;\n}\n\nstatic int pt2258_stereo_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pt2258 *pt = kcontrol->private_data;\n\tint base = kcontrol->private_value;\n\tunsigned char bytes[2];\n\tint val0, val1;\n\n\tval0 = 79 - ucontrol->value.integer.value[0];\n\tval1 = 79 - ucontrol->value.integer.value[1];\n\tif (val0 < 0 || val0 > 79 || val1 < 0 || val1 > 79)\n\t\treturn -EINVAL;\n\tif (val0 == pt->volume[base] && val1 == pt->volume[base + 1])\n\t\treturn 0;\n\n\tpt->volume[base] = val0;\n\tbytes[0] = pt2258_channel_code[2 * base] | (val0 / 10);\n\tbytes[1] = pt2258_channel_code[2 * base + 1] | (val0 % 10);\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\tpt->volume[base + 1] = val1;\n\tbytes[0] = pt2258_channel_code[2 * base + 2] | (val1 / 10);\n\tbytes[1] = pt2258_channel_code[2 * base + 3] | (val1 % 10);\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\treturn 1;\n\n      __error:\n\tsnd_i2c_unlock(pt->i2c_bus);\n\tsnd_printk(KERN_ERR \"PT2258 access failed\\n\");\n\treturn -EIO;\n}\n\n#define pt2258_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int pt2258_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pt2258 *pt = kcontrol->private_data;\n\n\tucontrol->value.integer.value[0] = !pt->mute;\n\treturn 0;\n}\n\nstatic int pt2258_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pt2258 *pt = kcontrol->private_data;\n\tunsigned char bytes[2];\n\tint val;\n\n\tval = !ucontrol->value.integer.value[0];\n\tif (pt->mute == val)\n\t\treturn 0;\n\n\tpt->mute = val;\n\tbytes[0] = val ? PT2258_CMD_MUTE : PT2258_CMD_UNMUTE;\n\tsnd_i2c_lock(pt->i2c_bus);\n\tif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\n\t\tgoto __error;\n\tsnd_i2c_unlock(pt->i2c_bus);\n\n\treturn 1;\n\n      __error:\n\tsnd_i2c_unlock(pt->i2c_bus);\n\tsnd_printk(KERN_ERR \"PT2258 access failed 2\\n\");\n\treturn -EIO;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(pt2258_db_scale, -7900, 100, 0);\n\nint snd_pt2258_build_controls(struct snd_pt2258 *pt)\n{\n\tstruct snd_kcontrol_new knew;\n\tchar *names[3] = {\n\t\t\"Mic Loopback Playback Volume\",\n\t\t\"Line Loopback Playback Volume\",\n\t\t\"CD Loopback Playback Volume\"\n\t};\n\tint i, err;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tmemset(&knew, 0, sizeof(knew));\n\t\tknew.name = names[i];\n\t\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tknew.count = 1;\n\t\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t    SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tknew.private_value = 2 * i;\n\t\tknew.info = pt2258_stereo_volume_info;\n\t\tknew.get = pt2258_stereo_volume_get;\n\t\tknew.put = pt2258_stereo_volume_put;\n\t\tknew.tlv.p = pt2258_db_scale;\n\n\t\terr = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmemset(&knew, 0, sizeof(knew));\n\tknew.name = \"Loopback Switch\";\n\tknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tknew.info = pt2258_switch_info;\n\tknew.get = pt2258_switch_get;\n\tknew.put = pt2258_switch_put;\n\tknew.access = 0;\n\terr = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_pt2258_reset);\nEXPORT_SYMBOL(snd_pt2258_build_controls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}