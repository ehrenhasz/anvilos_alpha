{
  "module_name": "ctsrc.c",
  "hash_id": "d7b14fafd9dc0c724c63a1ef775f94f57c847f40e073eb16bb14f2f4a6ca9d8d",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctsrc.c",
  "human_readable_source": "\n \n\n#include \"ctsrc.h\"\n#include \"cthardware.h\"\n#include <linux/slab.h>\n\n#define SRC_RESOURCE_NUM\t256\n#define SRCIMP_RESOURCE_NUM\t256\n\nstatic unsigned int conj_mask;\n\nstatic int src_default_config_memrd(struct src *src);\nstatic int src_default_config_memwr(struct src *src);\nstatic int src_default_config_arcrw(struct src *src);\n\nstatic int (*src_default_config[3])(struct src *) = {\n\t[MEMRD] = src_default_config_memrd,\n\t[MEMWR] = src_default_config_memwr,\n\t[ARCRW] = src_default_config_arcrw\n};\n\nstatic int src_set_state(struct src *src, unsigned int state)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_state(src->rsc.ctrl_blk, state);\n\n\treturn 0;\n}\n\nstatic int src_set_bm(struct src *src, unsigned int bm)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_bm(src->rsc.ctrl_blk, bm);\n\n\treturn 0;\n}\n\nstatic int src_set_sf(struct src *src, unsigned int sf)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_sf(src->rsc.ctrl_blk, sf);\n\n\treturn 0;\n}\n\nstatic int src_set_pm(struct src *src, unsigned int pm)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_pm(src->rsc.ctrl_blk, pm);\n\n\treturn 0;\n}\n\nstatic int src_set_rom(struct src *src, unsigned int rom)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_rom(src->rsc.ctrl_blk, rom);\n\n\treturn 0;\n}\n\nstatic int src_set_vo(struct src *src, unsigned int vo)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_vo(src->rsc.ctrl_blk, vo);\n\n\treturn 0;\n}\n\nstatic int src_set_st(struct src *src, unsigned int st)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_st(src->rsc.ctrl_blk, st);\n\n\treturn 0;\n}\n\nstatic int src_set_bp(struct src *src, unsigned int bp)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_bp(src->rsc.ctrl_blk, bp);\n\n\treturn 0;\n}\n\nstatic int src_set_cisz(struct src *src, unsigned int cisz)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_cisz(src->rsc.ctrl_blk, cisz);\n\n\treturn 0;\n}\n\nstatic int src_set_ca(struct src *src, unsigned int ca)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_ca(src->rsc.ctrl_blk, ca);\n\n\treturn 0;\n}\n\nstatic int src_set_sa(struct src *src, unsigned int sa)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_sa(src->rsc.ctrl_blk, sa);\n\n\treturn 0;\n}\n\nstatic int src_set_la(struct src *src, unsigned int la)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_la(src->rsc.ctrl_blk, la);\n\n\treturn 0;\n}\n\nstatic int src_set_pitch(struct src *src, unsigned int pitch)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_pitch(src->rsc.ctrl_blk, pitch);\n\n\treturn 0;\n}\n\nstatic int src_set_clear_zbufs(struct src *src)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\thw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\n\n\treturn 0;\n}\n\nstatic int src_commit_write(struct src *src)\n{\n\tstruct hw *hw;\n\tint i;\n\tunsigned int dirty = 0;\n\n\thw = src->rsc.hw;\n\tsrc->rsc.ops->master(&src->rsc);\n\tif (src->rsc.msr > 1) {\n\t\t \n\t\tdirty = hw->src_get_dirty(src->rsc.ctrl_blk) & conj_mask;\n\t}\n\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\n\t \n\tif (MEMWR == src->mode)\n\t\treturn 0;\n\n\tfor (i = 1; i < src->rsc.msr; i++) {\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t\thw->src_set_dirty(src->rsc.ctrl_blk, dirty);\n\t\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic int src_get_ca(struct src *src)\n{\n\tstruct hw *hw;\n\n\thw = src->rsc.hw;\n\treturn hw->src_get_ca(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n}\n\nstatic int src_init(struct src *src)\n{\n\tsrc_default_config[src->mode](src);\n\n\treturn 0;\n}\n\nstatic struct src *src_next_interleave(struct src *src)\n{\n\treturn src->intlv;\n}\n\nstatic int src_default_config_memrd(struct src *src)\n{\n\tstruct hw *hw = src->rsc.hw;\n\tunsigned int rsr, msr;\n\n\thw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\n\thw->src_set_bm(src->rsc.ctrl_blk, 1);\n\tfor (rsr = 0, msr = src->rsc.msr; msr > 1; msr >>= 1)\n\t\trsr++;\n\n\thw->src_set_rsr(src->rsc.ctrl_blk, rsr);\n\thw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_S16);\n\thw->src_set_wr(src->rsc.ctrl_blk, 0);\n\thw->src_set_pm(src->rsc.ctrl_blk, 0);\n\thw->src_set_rom(src->rsc.ctrl_blk, 0);\n\thw->src_set_vo(src->rsc.ctrl_blk, 0);\n\thw->src_set_st(src->rsc.ctrl_blk, 0);\n\thw->src_set_ilsz(src->rsc.ctrl_blk, src->multi - 1);\n\thw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_sa(src->rsc.ctrl_blk, 0x0);\n\thw->src_set_la(src->rsc.ctrl_blk, 0x1000);\n\thw->src_set_ca(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\n\thw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\n\n\tsrc->rsc.ops->master(&src->rsc);\n\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\n\tfor (msr = 1; msr < src->rsc.msr; msr++) {\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t\thw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\n\t\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic int src_default_config_memwr(struct src *src)\n{\n\tstruct hw *hw = src->rsc.hw;\n\n\thw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\n\thw->src_set_bm(src->rsc.ctrl_blk, 1);\n\thw->src_set_rsr(src->rsc.ctrl_blk, 0);\n\thw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_S16);\n\thw->src_set_wr(src->rsc.ctrl_blk, 1);\n\thw->src_set_pm(src->rsc.ctrl_blk, 0);\n\thw->src_set_rom(src->rsc.ctrl_blk, 0);\n\thw->src_set_vo(src->rsc.ctrl_blk, 0);\n\thw->src_set_st(src->rsc.ctrl_blk, 0);\n\thw->src_set_ilsz(src->rsc.ctrl_blk, 0);\n\thw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_sa(src->rsc.ctrl_blk, 0x0);\n\thw->src_set_la(src->rsc.ctrl_blk, 0x1000);\n\thw->src_set_ca(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\n\thw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\n\n\tsrc->rsc.ops->master(&src->rsc);\n\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\n\treturn 0;\n}\n\nstatic int src_default_config_arcrw(struct src *src)\n{\n\tstruct hw *hw = src->rsc.hw;\n\tunsigned int rsr, msr;\n\tunsigned int dirty;\n\n\thw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\n\thw->src_set_bm(src->rsc.ctrl_blk, 0);\n\tfor (rsr = 0, msr = src->rsc.msr; msr > 1; msr >>= 1)\n\t\trsr++;\n\n\thw->src_set_rsr(src->rsc.ctrl_blk, rsr);\n\thw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_F32);\n\thw->src_set_wr(src->rsc.ctrl_blk, 0);\n\thw->src_set_pm(src->rsc.ctrl_blk, 0);\n\thw->src_set_rom(src->rsc.ctrl_blk, 0);\n\thw->src_set_vo(src->rsc.ctrl_blk, 0);\n\thw->src_set_st(src->rsc.ctrl_blk, 0);\n\thw->src_set_ilsz(src->rsc.ctrl_blk, 0);\n\thw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_sa(src->rsc.ctrl_blk, 0x0);\n\t \n\thw->src_set_la(src->rsc.ctrl_blk, 0x1000);\n\t \n\thw->src_set_ca(src->rsc.ctrl_blk, 0x80);\n\thw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\n\thw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\n\n\tdirty = hw->src_get_dirty(src->rsc.ctrl_blk);\n\tsrc->rsc.ops->master(&src->rsc);\n\tfor (msr = 0; msr < src->rsc.msr; msr++) {\n\t\thw->src_set_dirty(src->rsc.ctrl_blk, dirty);\n\t\thw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\n\t\t\t\t\t\t\tsrc->rsc.ctrl_blk);\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic const struct src_rsc_ops src_rsc_ops = {\n\t.set_state\t\t= src_set_state,\n\t.set_bm\t\t\t= src_set_bm,\n\t.set_sf\t\t\t= src_set_sf,\n\t.set_pm\t\t\t= src_set_pm,\n\t.set_rom\t\t= src_set_rom,\n\t.set_vo\t\t\t= src_set_vo,\n\t.set_st\t\t\t= src_set_st,\n\t.set_bp\t\t\t= src_set_bp,\n\t.set_cisz\t\t= src_set_cisz,\n\t.set_ca\t\t\t= src_set_ca,\n\t.set_sa\t\t\t= src_set_sa,\n\t.set_la\t\t\t= src_set_la,\n\t.set_pitch\t\t= src_set_pitch,\n\t.set_clr_zbufs\t\t= src_set_clear_zbufs,\n\t.commit_write\t\t= src_commit_write,\n\t.get_ca\t\t\t= src_get_ca,\n\t.init\t\t\t= src_init,\n\t.next_interleave\t= src_next_interleave,\n};\n\nstatic int\nsrc_rsc_init(struct src *src, u32 idx,\n\t     const struct src_desc *desc, struct src_mgr *mgr)\n{\n\tint err;\n\tint i, n;\n\tstruct src *p;\n\n\tn = (MEMRD == desc->mode) ? desc->multi : 1;\n\tfor (i = 0, p = src; i < n; i++, p++) {\n\t\terr = rsc_init(&p->rsc, idx + i, SRC, desc->msr, mgr->mgr.hw);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\t \n\t\tp->ops = &src_rsc_ops;\n\t\tp->multi = (0 == i) ? desc->multi : 1;\n\t\tp->mode = desc->mode;\n\t\tsrc_default_config[desc->mode](p);\n\t\tmgr->src_enable(mgr, p);\n\t\tp->intlv = p + 1;\n\t}\n\t(--p)->intlv = NULL;\t \n\n\tmgr->commit_write(mgr);\n\n\treturn 0;\n\nerror1:\n\tfor (i--, p--; i >= 0; i--, p--) {\n\t\tmgr->src_disable(mgr, p);\n\t\trsc_uninit(&p->rsc);\n\t}\n\tmgr->commit_write(mgr);\n\treturn err;\n}\n\nstatic int src_rsc_uninit(struct src *src, struct src_mgr *mgr)\n{\n\tint i, n;\n\tstruct src *p;\n\n\tn = (MEMRD == src->mode) ? src->multi : 1;\n\tfor (i = 0, p = src; i < n; i++, p++) {\n\t\tmgr->src_disable(mgr, p);\n\t\trsc_uninit(&p->rsc);\n\t\tp->multi = 0;\n\t\tp->ops = NULL;\n\t\tp->mode = NUM_SRCMODES;\n\t\tp->intlv = NULL;\n\t}\n\tmgr->commit_write(mgr);\n\n\treturn 0;\n}\n\nstatic int\nget_src_rsc(struct src_mgr *mgr, const struct src_desc *desc, struct src **rsrc)\n{\n\tunsigned int idx = SRC_RESOURCE_NUM;\n\tint err;\n\tstruct src *src;\n\tunsigned long flags;\n\n\t*rsrc = NULL;\n\n\t \n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tif (MEMRD == desc->mode)\n\t\terr = mgr_get_resource(&mgr->mgr, desc->multi, &idx);\n\telse\n\t\terr = mgr_get_resource(&mgr->mgr, 1, &idx);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tif (err) {\n\t\tdev_err(mgr->card->dev,\n\t\t\t\"Can't meet SRC resource request!\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (MEMRD == desc->mode)\n\t\tsrc = kcalloc(desc->multi, sizeof(*src), GFP_KERNEL);\n\telse\n\t\tsrc = kzalloc(sizeof(*src), GFP_KERNEL);\n\n\tif (!src) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\terr = src_rsc_init(src, idx, desc, mgr);\n\tif (err)\n\t\tgoto error2;\n\n\t*rsrc = src;\n\n\treturn 0;\n\nerror2:\n\tkfree(src);\nerror1:\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tif (MEMRD == desc->mode)\n\t\tmgr_put_resource(&mgr->mgr, desc->multi, idx);\n\telse\n\t\tmgr_put_resource(&mgr->mgr, 1, idx);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\treturn err;\n}\n\nstatic int put_src_rsc(struct src_mgr *mgr, struct src *src)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tsrc->rsc.ops->master(&src->rsc);\n\tif (MEMRD == src->mode)\n\t\tmgr_put_resource(&mgr->mgr, src->multi,\n\t\t\t\t src->rsc.ops->index(&src->rsc));\n\telse\n\t\tmgr_put_resource(&mgr->mgr, 1, src->rsc.ops->index(&src->rsc));\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tsrc_rsc_uninit(src, mgr);\n\tkfree(src);\n\n\treturn 0;\n}\n\nstatic int src_enable_s(struct src_mgr *mgr, struct src *src)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\tint i;\n\n\tsrc->rsc.ops->master(&src->rsc);\n\tfor (i = 0; i < src->rsc.msr; i++) {\n\t\thw->src_mgr_enbs_src(mgr->mgr.ctrl_blk,\n\t\t\t\t     src->rsc.ops->index(&src->rsc));\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic int src_enable(struct src_mgr *mgr, struct src *src)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\tint i;\n\n\tsrc->rsc.ops->master(&src->rsc);\n\tfor (i = 0; i < src->rsc.msr; i++) {\n\t\thw->src_mgr_enb_src(mgr->mgr.ctrl_blk,\n\t\t\t\t    src->rsc.ops->index(&src->rsc));\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic int src_disable(struct src_mgr *mgr, struct src *src)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\tint i;\n\n\tsrc->rsc.ops->master(&src->rsc);\n\tfor (i = 0; i < src->rsc.msr; i++) {\n\t\thw->src_mgr_dsb_src(mgr->mgr.ctrl_blk,\n\t\t\t\t    src->rsc.ops->index(&src->rsc));\n\t\tsrc->rsc.ops->next_conj(&src->rsc);\n\t}\n\tsrc->rsc.ops->master(&src->rsc);\n\n\treturn 0;\n}\n\nstatic int src_mgr_commit_write(struct src_mgr *mgr)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\n\thw->src_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\n\n\treturn 0;\n}\n\nint src_mgr_create(struct hw *hw, struct src_mgr **rsrc_mgr)\n{\n\tint err, i;\n\tstruct src_mgr *src_mgr;\n\n\t*rsrc_mgr = NULL;\n\tsrc_mgr = kzalloc(sizeof(*src_mgr), GFP_KERNEL);\n\tif (!src_mgr)\n\t\treturn -ENOMEM;\n\n\terr = rsc_mgr_init(&src_mgr->mgr, SRC, SRC_RESOURCE_NUM, hw);\n\tif (err)\n\t\tgoto error1;\n\n\tspin_lock_init(&src_mgr->mgr_lock);\n\tconj_mask = hw->src_dirty_conj_mask();\n\n\tsrc_mgr->get_src = get_src_rsc;\n\tsrc_mgr->put_src = put_src_rsc;\n\tsrc_mgr->src_enable_s = src_enable_s;\n\tsrc_mgr->src_enable = src_enable;\n\tsrc_mgr->src_disable = src_disable;\n\tsrc_mgr->commit_write = src_mgr_commit_write;\n\tsrc_mgr->card = hw->card;\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\thw->src_mgr_dsb_src(src_mgr->mgr.ctrl_blk, i);\n\n\thw->src_mgr_commit_write(hw, src_mgr->mgr.ctrl_blk);\n\n\t*rsrc_mgr = src_mgr;\n\n\treturn 0;\n\nerror1:\n\tkfree(src_mgr);\n\treturn err;\n}\n\nint src_mgr_destroy(struct src_mgr *src_mgr)\n{\n\trsc_mgr_uninit(&src_mgr->mgr);\n\tkfree(src_mgr);\n\n\treturn 0;\n}\n\n \n\nstatic void srcimp_master(struct rsc *rsc)\n{\n\trsc->conj = 0;\n\trsc->idx = container_of(rsc, struct srcimp, rsc)->idx[0];\n}\n\nstatic void srcimp_next_conj(struct rsc *rsc)\n{\n\trsc->conj++;\n}\n\nstatic int srcimp_index(const struct rsc *rsc)\n{\n\treturn container_of(rsc, struct srcimp, rsc)->idx[rsc->conj];\n}\n\nstatic const struct rsc_ops srcimp_basic_rsc_ops = {\n\t.master\t\t= srcimp_master,\n\t.next_conj\t= srcimp_next_conj,\n\t.index\t\t= srcimp_index,\n\t.output_slot\t= NULL,\n};\n\nstatic int srcimp_map(struct srcimp *srcimp, struct src *src, struct rsc *input)\n{\n\tstruct imapper *entry;\n\tint i;\n\n\tsrcimp->rsc.ops->master(&srcimp->rsc);\n\tsrc->rsc.ops->master(&src->rsc);\n\tinput->ops->master(input);\n\n\t \n\tfor (i = 0; i < srcimp->rsc.msr; i++) {\n\t\tentry = &srcimp->imappers[i];\n\t\tentry->slot = input->ops->output_slot(input);\n\t\tentry->user = src->rsc.ops->index(&src->rsc);\n\t\tentry->addr = srcimp->rsc.ops->index(&srcimp->rsc);\n\t\tsrcimp->mgr->imap_add(srcimp->mgr, entry);\n\t\tsrcimp->mapped |= (0x1 << i);\n\n\t\tsrcimp->rsc.ops->next_conj(&srcimp->rsc);\n\t\tinput->ops->next_conj(input);\n\t}\n\n\tsrcimp->rsc.ops->master(&srcimp->rsc);\n\tinput->ops->master(input);\n\n\treturn 0;\n}\n\nstatic int srcimp_unmap(struct srcimp *srcimp)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < srcimp->rsc.msr; i++) {\n\t\tif (srcimp->mapped & (0x1 << i)) {\n\t\t\tsrcimp->mgr->imap_delete(srcimp->mgr,\n\t\t\t\t\t\t &srcimp->imappers[i]);\n\t\t\tsrcimp->mapped &= ~(0x1 << i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct srcimp_rsc_ops srcimp_ops = {\n\t.map = srcimp_map,\n\t.unmap = srcimp_unmap\n};\n\nstatic int srcimp_rsc_init(struct srcimp *srcimp,\n\t\t\t   const struct srcimp_desc *desc,\n\t\t\t   struct srcimp_mgr *mgr)\n{\n\tint err;\n\n\terr = rsc_init(&srcimp->rsc, srcimp->idx[0],\n\t\t       SRCIMP, desc->msr, mgr->mgr.hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsrcimp->imappers = kcalloc(desc->msr, sizeof(struct imapper),\n\t\t\t\t   GFP_KERNEL);\n\tif (!srcimp->imappers) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\t \n\tsrcimp->rsc.ops = &srcimp_basic_rsc_ops;\n\tsrcimp->ops = &srcimp_ops;\n\tsrcimp->mgr = mgr;\n\n\tsrcimp->rsc.ops->master(&srcimp->rsc);\n\n\treturn 0;\n\nerror1:\n\trsc_uninit(&srcimp->rsc);\n\treturn err;\n}\n\nstatic int srcimp_rsc_uninit(struct srcimp *srcimp)\n{\n\tkfree(srcimp->imappers);\n\tsrcimp->imappers = NULL;\n\tsrcimp->ops = NULL;\n\tsrcimp->mgr = NULL;\n\trsc_uninit(&srcimp->rsc);\n\n\treturn 0;\n}\n\nstatic int get_srcimp_rsc(struct srcimp_mgr *mgr,\n\t\t\t  const struct srcimp_desc *desc,\n\t\t\t  struct srcimp **rsrcimp)\n{\n\tint err, i;\n\tunsigned int idx;\n\tstruct srcimp *srcimp;\n\tunsigned long flags;\n\n\t*rsrcimp = NULL;\n\n\t \n\tsrcimp = kzalloc(sizeof(*srcimp), GFP_KERNEL);\n\tif (!srcimp)\n\t\treturn -ENOMEM;\n\n\t \n\terr = 0;\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < desc->msr; i++) {\n\t\terr = mgr_get_resource(&mgr->mgr, 1, &idx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tsrcimp->idx[i] = idx;\n\t}\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tif (err) {\n\t\tdev_err(mgr->card->dev,\n\t\t\t\"Can't meet SRCIMP resource request!\\n\");\n\t\tgoto error1;\n\t}\n\n\terr = srcimp_rsc_init(srcimp, desc, mgr);\n\tif (err)\n\t\tgoto error1;\n\n\t*rsrcimp = srcimp;\n\n\treturn 0;\n\nerror1:\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i--; i >= 0; i--)\n\t\tmgr_put_resource(&mgr->mgr, 1, srcimp->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tkfree(srcimp);\n\treturn err;\n}\n\nstatic int put_srcimp_rsc(struct srcimp_mgr *mgr, struct srcimp *srcimp)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < srcimp->rsc.msr; i++)\n\t\tmgr_put_resource(&mgr->mgr, 1, srcimp->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tsrcimp_rsc_uninit(srcimp);\n\tkfree(srcimp);\n\n\treturn 0;\n}\n\nstatic int srcimp_map_op(void *data, struct imapper *entry)\n{\n\tstruct rsc_mgr *mgr = &((struct srcimp_mgr *)data)->mgr;\n\tstruct hw *hw = mgr->hw;\n\n\thw->srcimp_mgr_set_imaparc(mgr->ctrl_blk, entry->slot);\n\thw->srcimp_mgr_set_imapuser(mgr->ctrl_blk, entry->user);\n\thw->srcimp_mgr_set_imapnxt(mgr->ctrl_blk, entry->next);\n\thw->srcimp_mgr_set_imapaddr(mgr->ctrl_blk, entry->addr);\n\thw->srcimp_mgr_commit_write(mgr->hw, mgr->ctrl_blk);\n\n\treturn 0;\n}\n\nstatic int srcimp_imap_add(struct srcimp_mgr *mgr, struct imapper *entry)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&mgr->imap_lock, flags);\n\tif ((0 == entry->addr) && (mgr->init_imap_added)) {\n\t\tinput_mapper_delete(&mgr->imappers,\n\t\t\t\t    mgr->init_imap, srcimp_map_op, mgr);\n\t\tmgr->init_imap_added = 0;\n\t}\n\terr = input_mapper_add(&mgr->imappers, entry, srcimp_map_op, mgr);\n\tspin_unlock_irqrestore(&mgr->imap_lock, flags);\n\n\treturn err;\n}\n\nstatic int srcimp_imap_delete(struct srcimp_mgr *mgr, struct imapper *entry)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&mgr->imap_lock, flags);\n\terr = input_mapper_delete(&mgr->imappers, entry, srcimp_map_op, mgr);\n\tif (list_empty(&mgr->imappers)) {\n\t\tinput_mapper_add(&mgr->imappers, mgr->init_imap,\n\t\t\t\t srcimp_map_op, mgr);\n\t\tmgr->init_imap_added = 1;\n\t}\n\tspin_unlock_irqrestore(&mgr->imap_lock, flags);\n\n\treturn err;\n}\n\nint srcimp_mgr_create(struct hw *hw, struct srcimp_mgr **rsrcimp_mgr)\n{\n\tint err;\n\tstruct srcimp_mgr *srcimp_mgr;\n\tstruct imapper *entry;\n\n\t*rsrcimp_mgr = NULL;\n\tsrcimp_mgr = kzalloc(sizeof(*srcimp_mgr), GFP_KERNEL);\n\tif (!srcimp_mgr)\n\t\treturn -ENOMEM;\n\n\terr = rsc_mgr_init(&srcimp_mgr->mgr, SRCIMP, SRCIMP_RESOURCE_NUM, hw);\n\tif (err)\n\t\tgoto error1;\n\n\tspin_lock_init(&srcimp_mgr->mgr_lock);\n\tspin_lock_init(&srcimp_mgr->imap_lock);\n\tINIT_LIST_HEAD(&srcimp_mgr->imappers);\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\terr = -ENOMEM;\n\t\tgoto error2;\n\t}\n\tentry->slot = entry->addr = entry->next = entry->user = 0;\n\tlist_add(&entry->list, &srcimp_mgr->imappers);\n\tsrcimp_mgr->init_imap = entry;\n\tsrcimp_mgr->init_imap_added = 1;\n\n\tsrcimp_mgr->get_srcimp = get_srcimp_rsc;\n\tsrcimp_mgr->put_srcimp = put_srcimp_rsc;\n\tsrcimp_mgr->imap_add = srcimp_imap_add;\n\tsrcimp_mgr->imap_delete = srcimp_imap_delete;\n\tsrcimp_mgr->card = hw->card;\n\n\t*rsrcimp_mgr = srcimp_mgr;\n\n\treturn 0;\n\nerror2:\n\trsc_mgr_uninit(&srcimp_mgr->mgr);\nerror1:\n\tkfree(srcimp_mgr);\n\treturn err;\n}\n\nint srcimp_mgr_destroy(struct srcimp_mgr *srcimp_mgr)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&srcimp_mgr->imap_lock, flags);\n\tfree_input_mapper_list(&srcimp_mgr->imappers);\n\tspin_unlock_irqrestore(&srcimp_mgr->imap_lock, flags);\n\n\trsc_mgr_uninit(&srcimp_mgr->mgr);\n\tkfree(srcimp_mgr);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}