{
  "module_name": "ctpcm.c",
  "hash_id": "aa551dd8f29f1e8ca087c8b811ceac142af9751961226d682ef875a9f5fcea5e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctpcm.c",
  "human_readable_source": "\n \n\n#include \"ctpcm.h\"\n#include \"cttimer.h\"\n#include <linux/slab.h>\n#include <sound/pcm.h>\n\n \nstatic const struct snd_pcm_hardware ct_pcm_playback_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t   SNDRV_PCM_INFO_PAUSE),\n\t.formats\t\t= (SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_FLOAT_LE),\n\t.rates\t\t\t= (SNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t\t   SNDRV_PCM_RATE_8000_192000),\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 192000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= (128*1024),\n\t.period_bytes_min\t= (64),\n\t.period_bytes_max\t= (128*1024),\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 1024,\n\t.fifo_size\t\t= 0,\n};\n\nstatic const struct snd_pcm_hardware ct_spdif_passthru_playback_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t   SNDRV_PCM_INFO_PAUSE),\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates\t\t\t= (SNDRV_PCM_RATE_48000 |\n\t\t\t\t   SNDRV_PCM_RATE_44100 |\n\t\t\t\t   SNDRV_PCM_RATE_32000),\n\t.rate_min\t\t= 32000,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 2,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= (128*1024),\n\t.period_bytes_min\t= (64),\n\t.period_bytes_max\t= (128*1024),\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 1024,\n\t.fifo_size\t\t= 0,\n};\n\n \nstatic const struct snd_pcm_hardware ct_pcm_capture_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats\t\t= (SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_FLOAT_LE),\n\t.rates\t\t\t= (SNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t\t   SNDRV_PCM_RATE_8000_96000),\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 96000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= (128*1024),\n\t.period_bytes_min\t= (384),\n\t.period_bytes_max\t= (64*1024),\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 1024,\n\t.fifo_size\t\t= 0,\n};\n\nstatic void ct_atc_pcm_interrupt(struct ct_atc_pcm *atc_pcm)\n{\n\tstruct ct_atc_pcm *apcm = atc_pcm;\n\n\tif (!apcm->substream)\n\t\treturn;\n\n\tsnd_pcm_period_elapsed(apcm->substream);\n}\n\nstatic void ct_atc_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(apcm->substream);\n\n\tatc->pcm_release_resources(atc, apcm);\n\tct_timer_instance_free(apcm->timer);\n\tkfree(apcm);\n\truntime->private_data = NULL;\n}\n\n \nstatic int ct_pcm_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm;\n\tint err;\n\n\tapcm = kzalloc(sizeof(*apcm), GFP_KERNEL);\n\tif (!apcm)\n\t\treturn -ENOMEM;\n\n\tapcm->substream = substream;\n\tapcm->interrupt = ct_atc_pcm_interrupt;\n\tif (IEC958 == substream->pcm->device) {\n\t\truntime->hw = ct_spdif_passthru_playback_hw;\n\t\tatc->spdif_out_passthru(atc, 1);\n\t} else {\n\t\truntime->hw = ct_pcm_playback_hw;\n\t\tif (FRONT == substream->pcm->device)\n\t\t\truntime->hw.channels_max = 8;\n\t}\n\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t   1024, UINT_MAX);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\tapcm->timer = ct_timer_instance_new(atc->timer, apcm);\n\tif (!apcm->timer) {\n\t\terr = -ENOMEM;\n\t\tgoto free_pcm;\n\t}\n\truntime->private_data = apcm;\n\truntime->private_free = ct_atc_pcm_free_substream;\n\n\treturn 0;\n\nfree_pcm:\n\tkfree(apcm);\n\treturn err;\n}\n\nstatic int ct_pcm_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\n\t \n\tif (IEC958 == substream->pcm->device)\n\t\tatc->spdif_out_passthru(atc, 0);\n\n\t \n\n\treturn 0;\n}\n\nstatic int ct_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct ct_atc_pcm *apcm = substream->runtime->private_data;\n\n\t \n\tatc->pcm_release_resources(atc, apcm);\n\treturn 0;\n}\n\nstatic int ct_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct ct_atc_pcm *apcm = substream->runtime->private_data;\n\n\t \n\tatc->pcm_release_resources(atc, apcm);\n\treturn 0;\n}\n\n\nstatic int ct_pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\tif (IEC958 == substream->pcm->device)\n\t\terr = atc->spdif_passthru_playback_prepare(atc, apcm);\n\telse\n\t\terr = atc->pcm_playback_prepare(atc, apcm);\n\n\tif (err < 0) {\n\t\tdev_err(atc->card->dev,\n\t\t\t\"Preparing pcm playback failed!!!\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nct_pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tatc->pcm_playback_start(atc, apcm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tatc->pcm_playback_stop(atc, apcm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nct_pcm_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tunsigned long position;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\t \n\tposition = atc->pcm_playback_position(atc, apcm);\n\tposition = bytes_to_frames(runtime, position);\n\tif (position >= runtime->buffer_size)\n\t\tposition = 0;\n\treturn position;\n}\n\n \nstatic int ct_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm;\n\tint err;\n\n\tapcm = kzalloc(sizeof(*apcm), GFP_KERNEL);\n\tif (!apcm)\n\t\treturn -ENOMEM;\n\n\tapcm->started = 0;\n\tapcm->substream = substream;\n\tapcm->interrupt = ct_atc_pcm_interrupt;\n\truntime->hw = ct_pcm_capture_hw;\n\truntime->hw.rate_max = atc->rsr * atc->msr;\n\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t   1024, UINT_MAX);\n\tif (err < 0)\n\t\tgoto free_pcm;\n\n\tapcm->timer = ct_timer_instance_new(atc->timer, apcm);\n\tif (!apcm->timer) {\n\t\terr = -ENOMEM;\n\t\tgoto free_pcm;\n\t}\n\truntime->private_data = apcm;\n\truntime->private_free = ct_atc_pcm_free_substream;\n\n\treturn 0;\n\nfree_pcm:\n\tkfree(apcm);\n\treturn err;\n}\n\nstatic int ct_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\t \n\t \n\treturn 0;\n}\n\nstatic int ct_pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\terr = atc->pcm_capture_prepare(atc, apcm);\n\tif (err < 0) {\n\t\tdev_err(atc->card->dev,\n\t\t\t\"Preparing pcm capture failed!!!\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nct_pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tatc->pcm_capture_start(atc, apcm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tatc->pcm_capture_stop(atc, apcm);\n\t\tbreak;\n\tdefault:\n\t\tatc->pcm_capture_stop(atc, apcm);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nct_pcm_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tunsigned long position;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = runtime->private_data;\n\n\t \n\tposition = atc->pcm_capture_position(atc, apcm);\n\tposition = bytes_to_frames(runtime, position);\n\tif (position >= runtime->buffer_size)\n\t\tposition = 0;\n\treturn position;\n}\n\n \nstatic const struct snd_pcm_ops ct_pcm_playback_ops = {\n\t.open\t \t= ct_pcm_playback_open,\n\t.close\t\t= ct_pcm_playback_close,\n\t.hw_params\t= ct_pcm_hw_params,\n\t.hw_free\t= ct_pcm_hw_free,\n\t.prepare\t= ct_pcm_playback_prepare,\n\t.trigger\t= ct_pcm_playback_trigger,\n\t.pointer\t= ct_pcm_playback_pointer,\n};\n\n \nstatic const struct snd_pcm_ops ct_pcm_capture_ops = {\n\t.open\t \t= ct_pcm_capture_open,\n\t.close\t\t= ct_pcm_capture_close,\n\t.hw_params\t= ct_pcm_hw_params,\n\t.hw_free\t= ct_pcm_hw_free,\n\t.prepare\t= ct_pcm_capture_prepare,\n\t.trigger\t= ct_pcm_capture_trigger,\n\t.pointer\t= ct_pcm_capture_pointer,\n};\n\nstatic const struct snd_pcm_chmap_elem surround_map[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nstatic const struct snd_pcm_chmap_elem clfe_map[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ }\n};\n\nstatic const struct snd_pcm_chmap_elem side_map[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\n\n \nint ct_alsa_pcm_create(struct ct_atc *atc,\n\t\t       enum CTALSADEVS device,\n\t\t       const char *device_name)\n{\n\tstruct snd_pcm *pcm;\n\tconst struct snd_pcm_chmap_elem *map;\n\tint chs;\n\tint err;\n\tint playback_count, capture_count;\n\n\tplayback_count = (IEC958 == device) ? 1 : 256;\n\tcapture_count = (FRONT == device) ? 1 : 0;\n\terr = snd_pcm_new(atc->card, \"ctxfi\", device,\n\t\t\t  playback_count, capture_count, &pcm);\n\tif (err < 0) {\n\t\tdev_err(atc->card->dev, \"snd_pcm_new failed!! Err=%d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tpcm->private_data = atc;\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tstrscpy(pcm->name, device_name, sizeof(pcm->name));\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &ct_pcm_playback_ops);\n\n\tif (FRONT == device)\n\t\tsnd_pcm_set_ops(pcm,\n\t\t\t\tSNDRV_PCM_STREAM_CAPTURE, &ct_pcm_capture_ops);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &atc->pci->dev, 128*1024, 128*1024);\n\n\tchs = 2;\n\tswitch (device) {\n\tcase FRONT:\n\t\tchs = 8;\n\t\tmap = snd_pcm_std_chmaps;\n\t\tbreak;\n\tcase SURROUND:\n\t\tmap = surround_map;\n\t\tbreak;\n\tcase CLFE:\n\t\tmap = clfe_map;\n\t\tbreak;\n\tcase SIDE:\n\t\tmap = side_map;\n\t\tbreak;\n\tdefault:\n\t\tmap = snd_pcm_std_chmaps;\n\t\tbreak;\n\t}\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK, map, chs,\n\t\t\t\t     0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CONFIG_PM_SLEEP\n\tatc->pcms[device] = pcm;\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}