{
  "module_name": "ctdaio.c",
  "hash_id": "116c46842109d6523a73da84bb23884026b70d5938f77d926d0c653cd79dd532",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctdaio.c",
  "human_readable_source": "\n \n\n#include \"ctdaio.h\"\n#include \"cthardware.h\"\n#include \"ctimap.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define DAIO_OUT_MAX\t\tSPDIFOO\n\nstruct daio_usage {\n\tunsigned short data;\n};\n\nstruct daio_rsc_idx {\n\tunsigned short left;\n\tunsigned short right;\n};\n\nstatic const struct daio_rsc_idx idx_20k1[NUM_DAIOTYP] = {\n\t[LINEO1] = {.left = 0x00, .right = 0x01},\n\t[LINEO2] = {.left = 0x18, .right = 0x19},\n\t[LINEO3] = {.left = 0x08, .right = 0x09},\n\t[LINEO4] = {.left = 0x10, .right = 0x11},\n\t[LINEIM] = {.left = 0x1b5, .right = 0x1bd},\n\t[SPDIFOO] = {.left = 0x20, .right = 0x21},\n\t[SPDIFIO] = {.left = 0x15, .right = 0x1d},\n\t[SPDIFI1] = {.left = 0x95, .right = 0x9d},\n};\n\nstatic const struct daio_rsc_idx idx_20k2[NUM_DAIOTYP] = {\n\t[LINEO1] = {.left = 0x40, .right = 0x41},\n\t[LINEO2] = {.left = 0x60, .right = 0x61},\n\t[LINEO3] = {.left = 0x50, .right = 0x51},\n\t[LINEO4] = {.left = 0x70, .right = 0x71},\n\t[LINEIM] = {.left = 0x45, .right = 0xc5},\n\t[MIC]\t = {.left = 0x55, .right = 0xd5},\n\t[SPDIFOO] = {.left = 0x00, .right = 0x01},\n\t[SPDIFIO] = {.left = 0x05, .right = 0x85},\n};\n\nstatic void daio_master(struct rsc *rsc)\n{\n\t \n\trsc->conj = rsc->idx;\n}\n\nstatic int daio_index(const struct rsc *rsc)\n{\n\treturn rsc->conj;\n}\n\nstatic void daio_out_next_conj(struct rsc *rsc)\n{\n\trsc->conj += 2;\n}\n\nstatic void daio_in_next_conj_20k1(struct rsc *rsc)\n{\n\trsc->conj += 0x200;\n}\n\nstatic void daio_in_next_conj_20k2(struct rsc *rsc)\n{\n\trsc->conj += 0x100;\n}\n\nstatic const struct rsc_ops daio_out_rsc_ops = {\n\t.master\t\t= daio_master,\n\t.next_conj\t= daio_out_next_conj,\n\t.index\t\t= daio_index,\n\t.output_slot\t= NULL,\n};\n\nstatic const struct rsc_ops daio_in_rsc_ops_20k1 = {\n\t.master\t\t= daio_master,\n\t.next_conj\t= daio_in_next_conj_20k1,\n\t.index\t\t= NULL,\n\t.output_slot\t= daio_index,\n};\n\nstatic const struct rsc_ops daio_in_rsc_ops_20k2 = {\n\t.master\t\t= daio_master,\n\t.next_conj\t= daio_in_next_conj_20k2,\n\t.index\t\t= NULL,\n\t.output_slot\t= daio_index,\n};\n\nstatic unsigned int daio_device_index(enum DAIOTYP type, struct hw *hw)\n{\n\tswitch (hw->chip_type) {\n\tcase ATC20K1:\n\t\tswitch (type) {\n\t\tcase SPDIFOO:\treturn 0;\n\t\tcase SPDIFIO:\treturn 0;\n\t\tcase SPDIFI1:\treturn 1;\n\t\tcase LINEO1:\treturn 4;\n\t\tcase LINEO2:\treturn 7;\n\t\tcase LINEO3:\treturn 5;\n\t\tcase LINEO4:\treturn 6;\n\t\tcase LINEIM:\treturn 7;\n\t\tdefault:\treturn -EINVAL;\n\t\t}\n\tcase ATC20K2:\n\t\tswitch (type) {\n\t\tcase SPDIFOO:\treturn 0;\n\t\tcase SPDIFIO:\treturn 0;\n\t\tcase LINEO1:\treturn 4;\n\t\tcase LINEO2:\treturn 7;\n\t\tcase LINEO3:\treturn 5;\n\t\tcase LINEO4:\treturn 6;\n\t\tcase LINEIM:\treturn 4;\n\t\tcase MIC:\treturn 5;\n\t\tdefault:\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dao_rsc_reinit(struct dao *dao, const struct dao_desc *desc);\n\nstatic int dao_spdif_get_spos(struct dao *dao, unsigned int *spos)\n{\n\tdao->hw->dao_get_spos(dao->ctrl_blk, spos);\n\treturn 0;\n}\n\nstatic int dao_spdif_set_spos(struct dao *dao, unsigned int spos)\n{\n\tdao->hw->dao_set_spos(dao->ctrl_blk, spos);\n\treturn 0;\n}\n\nstatic int dao_commit_write(struct dao *dao)\n{\n\tdao->hw->dao_commit_write(dao->hw,\n\t\tdaio_device_index(dao->daio.type, dao->hw), dao->ctrl_blk);\n\treturn 0;\n}\n\nstatic int dao_set_left_input(struct dao *dao, struct rsc *input)\n{\n\tstruct imapper *entry;\n\tstruct daio *daio = &dao->daio;\n\tint i;\n\n\tentry = kzalloc((sizeof(*entry) * daio->rscl.msr), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tdao->ops->clear_left_input(dao);\n\t \n\tinput->ops->master(input);\n\tdaio->rscl.ops->master(&daio->rscl);\n\tfor (i = 0; i < daio->rscl.msr; i++, entry++) {\n\t\tentry->slot = input->ops->output_slot(input);\n\t\tentry->user = entry->addr = daio->rscl.ops->index(&daio->rscl);\n\t\tdao->mgr->imap_add(dao->mgr, entry);\n\t\tdao->imappers[i] = entry;\n\n\t\tinput->ops->next_conj(input);\n\t\tdaio->rscl.ops->next_conj(&daio->rscl);\n\t}\n\tinput->ops->master(input);\n\tdaio->rscl.ops->master(&daio->rscl);\n\n\treturn 0;\n}\n\nstatic int dao_set_right_input(struct dao *dao, struct rsc *input)\n{\n\tstruct imapper *entry;\n\tstruct daio *daio = &dao->daio;\n\tint i;\n\n\tentry = kzalloc((sizeof(*entry) * daio->rscr.msr), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tdao->ops->clear_right_input(dao);\n\t \n\tinput->ops->master(input);\n\tdaio->rscr.ops->master(&daio->rscr);\n\tfor (i = 0; i < daio->rscr.msr; i++, entry++) {\n\t\tentry->slot = input->ops->output_slot(input);\n\t\tentry->user = entry->addr = daio->rscr.ops->index(&daio->rscr);\n\t\tdao->mgr->imap_add(dao->mgr, entry);\n\t\tdao->imappers[daio->rscl.msr + i] = entry;\n\n\t\tinput->ops->next_conj(input);\n\t\tdaio->rscr.ops->next_conj(&daio->rscr);\n\t}\n\tinput->ops->master(input);\n\tdaio->rscr.ops->master(&daio->rscr);\n\n\treturn 0;\n}\n\nstatic int dao_clear_left_input(struct dao *dao)\n{\n\tstruct imapper *entry;\n\tstruct daio *daio = &dao->daio;\n\tint i;\n\n\tif (!dao->imappers[0])\n\t\treturn 0;\n\n\tentry = dao->imappers[0];\n\tdao->mgr->imap_delete(dao->mgr, entry);\n\t \n\tfor (i = 1; i < daio->rscl.msr; i++) {\n\t\tentry = dao->imappers[i];\n\t\tdao->mgr->imap_delete(dao->mgr, entry);\n\t\tdao->imappers[i] = NULL;\n\t}\n\n\tkfree(dao->imappers[0]);\n\tdao->imappers[0] = NULL;\n\n\treturn 0;\n}\n\nstatic int dao_clear_right_input(struct dao *dao)\n{\n\tstruct imapper *entry;\n\tstruct daio *daio = &dao->daio;\n\tint i;\n\n\tif (!dao->imappers[daio->rscl.msr])\n\t\treturn 0;\n\n\tentry = dao->imappers[daio->rscl.msr];\n\tdao->mgr->imap_delete(dao->mgr, entry);\n\t \n\tfor (i = 1; i < daio->rscr.msr; i++) {\n\t\tentry = dao->imappers[daio->rscl.msr + i];\n\t\tdao->mgr->imap_delete(dao->mgr, entry);\n\t\tdao->imappers[daio->rscl.msr + i] = NULL;\n\t}\n\n\tkfree(dao->imappers[daio->rscl.msr]);\n\tdao->imappers[daio->rscl.msr] = NULL;\n\n\treturn 0;\n}\n\nstatic const struct dao_rsc_ops dao_ops = {\n\t.set_spos\t\t= dao_spdif_set_spos,\n\t.commit_write\t\t= dao_commit_write,\n\t.get_spos\t\t= dao_spdif_get_spos,\n\t.reinit\t\t\t= dao_rsc_reinit,\n\t.set_left_input\t\t= dao_set_left_input,\n\t.set_right_input\t= dao_set_right_input,\n\t.clear_left_input\t= dao_clear_left_input,\n\t.clear_right_input\t= dao_clear_right_input,\n};\n\nstatic int dai_set_srt_srcl(struct dai *dai, struct rsc *src)\n{\n\tsrc->ops->master(src);\n\tdai->hw->dai_srt_set_srcm(dai->ctrl_blk, src->ops->index(src));\n\treturn 0;\n}\n\nstatic int dai_set_srt_srcr(struct dai *dai, struct rsc *src)\n{\n\tsrc->ops->master(src);\n\tdai->hw->dai_srt_set_srco(dai->ctrl_blk, src->ops->index(src));\n\treturn 0;\n}\n\nstatic int dai_set_srt_msr(struct dai *dai, unsigned int msr)\n{\n\tunsigned int rsr;\n\n\tfor (rsr = 0; msr > 1; msr >>= 1)\n\t\trsr++;\n\n\tdai->hw->dai_srt_set_rsr(dai->ctrl_blk, rsr);\n\treturn 0;\n}\n\nstatic int dai_set_enb_src(struct dai *dai, unsigned int enb)\n{\n\tdai->hw->dai_srt_set_ec(dai->ctrl_blk, enb);\n\treturn 0;\n}\n\nstatic int dai_set_enb_srt(struct dai *dai, unsigned int enb)\n{\n\tdai->hw->dai_srt_set_et(dai->ctrl_blk, enb);\n\treturn 0;\n}\n\nstatic int dai_commit_write(struct dai *dai)\n{\n\tdai->hw->dai_commit_write(dai->hw,\n\t\tdaio_device_index(dai->daio.type, dai->hw), dai->ctrl_blk);\n\treturn 0;\n}\n\nstatic const struct dai_rsc_ops dai_ops = {\n\t.set_srt_srcl\t\t= dai_set_srt_srcl,\n\t.set_srt_srcr\t\t= dai_set_srt_srcr,\n\t.set_srt_msr\t\t= dai_set_srt_msr,\n\t.set_enb_src\t\t= dai_set_enb_src,\n\t.set_enb_srt\t\t= dai_set_enb_srt,\n\t.commit_write\t\t= dai_commit_write,\n};\n\nstatic int daio_rsc_init(struct daio *daio,\n\t\t\t const struct daio_desc *desc,\n\t\t\t struct hw *hw)\n{\n\tint err;\n\tunsigned int idx_l, idx_r;\n\n\tswitch (hw->chip_type) {\n\tcase ATC20K1:\n\t\tidx_l = idx_20k1[desc->type].left;\n\t\tidx_r = idx_20k1[desc->type].right;\n\t\tbreak;\n\tcase ATC20K2:\n\t\tidx_l = idx_20k2[desc->type].left;\n\t\tidx_r = idx_20k2[desc->type].right;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\terr = rsc_init(&daio->rscl, idx_l, DAIO, desc->msr, hw);\n\tif (err)\n\t\treturn err;\n\n\terr = rsc_init(&daio->rscr, idx_r, DAIO, desc->msr, hw);\n\tif (err)\n\t\tgoto error1;\n\n\t \n\tif (desc->type <= DAIO_OUT_MAX) {\n\t\tdaio->rscl.ops = daio->rscr.ops = &daio_out_rsc_ops;\n\t} else {\n\t\tswitch (hw->chip_type) {\n\t\tcase ATC20K1:\n\t\t\tdaio->rscl.ops = daio->rscr.ops = &daio_in_rsc_ops_20k1;\n\t\t\tbreak;\n\t\tcase ATC20K2:\n\t\t\tdaio->rscl.ops = daio->rscr.ops = &daio_in_rsc_ops_20k2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdaio->type = desc->type;\n\n\treturn 0;\n\nerror1:\n\trsc_uninit(&daio->rscl);\n\treturn err;\n}\n\nstatic int daio_rsc_uninit(struct daio *daio)\n{\n\trsc_uninit(&daio->rscl);\n\trsc_uninit(&daio->rscr);\n\n\treturn 0;\n}\n\nstatic int dao_rsc_init(struct dao *dao,\n\t\t\tconst struct daio_desc *desc,\n\t\t\tstruct daio_mgr *mgr)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\tunsigned int conf;\n\tint err;\n\n\terr = daio_rsc_init(&dao->daio, desc, mgr->mgr.hw);\n\tif (err)\n\t\treturn err;\n\n\tdao->imappers = kzalloc(array3_size(sizeof(void *), desc->msr, 2),\n\t\t\t\tGFP_KERNEL);\n\tif (!dao->imappers) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tdao->ops = &dao_ops;\n\tdao->mgr = mgr;\n\tdao->hw = hw;\n\terr = hw->dao_get_ctrl_blk(&dao->ctrl_blk);\n\tif (err)\n\t\tgoto error2;\n\n\thw->daio_mgr_dsb_dao(mgr->mgr.ctrl_blk,\n\t\t\tdaio_device_index(dao->daio.type, hw));\n\thw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\n\n\tconf = (desc->msr & 0x7) | (desc->passthru << 3);\n\thw->daio_mgr_dao_init(mgr->mgr.ctrl_blk,\n\t\t\tdaio_device_index(dao->daio.type, hw), conf);\n\thw->daio_mgr_enb_dao(mgr->mgr.ctrl_blk,\n\t\t\tdaio_device_index(dao->daio.type, hw));\n\thw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\n\n\treturn 0;\n\nerror2:\n\tkfree(dao->imappers);\n\tdao->imappers = NULL;\nerror1:\n\tdaio_rsc_uninit(&dao->daio);\n\treturn err;\n}\n\nstatic int dao_rsc_uninit(struct dao *dao)\n{\n\tif (dao->imappers) {\n\t\tif (dao->imappers[0])\n\t\t\tdao_clear_left_input(dao);\n\n\t\tif (dao->imappers[dao->daio.rscl.msr])\n\t\t\tdao_clear_right_input(dao);\n\n\t\tkfree(dao->imappers);\n\t\tdao->imappers = NULL;\n\t}\n\tdao->hw->dao_put_ctrl_blk(dao->ctrl_blk);\n\tdao->hw = dao->ctrl_blk = NULL;\n\tdaio_rsc_uninit(&dao->daio);\n\n\treturn 0;\n}\n\nstatic int dao_rsc_reinit(struct dao *dao, const struct dao_desc *desc)\n{\n\tstruct daio_mgr *mgr = dao->mgr;\n\tstruct daio_desc dsc = {0};\n\n\tdsc.type = dao->daio.type;\n\tdsc.msr = desc->msr;\n\tdsc.passthru = desc->passthru;\n\tdao_rsc_uninit(dao);\n\treturn dao_rsc_init(dao, &dsc, mgr);\n}\n\nstatic int dai_rsc_init(struct dai *dai,\n\t\t\tconst struct daio_desc *desc,\n\t\t\tstruct daio_mgr *mgr)\n{\n\tint err;\n\tstruct hw *hw = mgr->mgr.hw;\n\tunsigned int rsr, msr;\n\n\terr = daio_rsc_init(&dai->daio, desc, mgr->mgr.hw);\n\tif (err)\n\t\treturn err;\n\n\tdai->ops = &dai_ops;\n\tdai->hw = mgr->mgr.hw;\n\terr = hw->dai_get_ctrl_blk(&dai->ctrl_blk);\n\tif (err)\n\t\tgoto error1;\n\n\tfor (rsr = 0, msr = desc->msr; msr > 1; msr >>= 1)\n\t\trsr++;\n\n\thw->dai_srt_set_rsr(dai->ctrl_blk, rsr);\n\thw->dai_srt_set_drat(dai->ctrl_blk, 0);\n\t \n\thw->dai_srt_set_ec(dai->ctrl_blk, 0);\n\thw->dai_srt_set_et(dai->ctrl_blk, 0);  \n\thw->dai_commit_write(hw,\n\t\tdaio_device_index(dai->daio.type, dai->hw), dai->ctrl_blk);\n\n\treturn 0;\n\nerror1:\n\tdaio_rsc_uninit(&dai->daio);\n\treturn err;\n}\n\nstatic int dai_rsc_uninit(struct dai *dai)\n{\n\tdai->hw->dai_put_ctrl_blk(dai->ctrl_blk);\n\tdai->hw = dai->ctrl_blk = NULL;\n\tdaio_rsc_uninit(&dai->daio);\n\treturn 0;\n}\n\nstatic int daio_mgr_get_rsc(struct rsc_mgr *mgr, enum DAIOTYP type)\n{\n\tif (((struct daio_usage *)mgr->rscs)->data & (0x1 << type))\n\t\treturn -ENOENT;\n\n\t((struct daio_usage *)mgr->rscs)->data |= (0x1 << type);\n\n\treturn 0;\n}\n\nstatic int daio_mgr_put_rsc(struct rsc_mgr *mgr, enum DAIOTYP type)\n{\n\t((struct daio_usage *)mgr->rscs)->data &= ~(0x1 << type);\n\n\treturn 0;\n}\n\nstatic int get_daio_rsc(struct daio_mgr *mgr,\n\t\t\tconst struct daio_desc *desc,\n\t\t\tstruct daio **rdaio)\n{\n\tint err;\n\tunsigned long flags;\n\n\t*rdaio = NULL;\n\n\t \n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\terr = daio_mgr_get_rsc(&mgr->mgr, desc->type);\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tif (err) {\n\t\tdev_err(mgr->card->dev,\n\t\t\t\"Can't meet DAIO resource request!\\n\");\n\t\treturn err;\n\t}\n\n\terr = -ENOMEM;\n\t \n\tif (desc->type <= DAIO_OUT_MAX) {\n\t\tstruct dao *dao = kzalloc(sizeof(*dao), GFP_KERNEL);\n\t\tif (!dao)\n\t\t\tgoto error;\n\n\t\terr = dao_rsc_init(dao, desc, mgr);\n\t\tif (err) {\n\t\t\tkfree(dao);\n\t\t\tgoto error;\n\t\t}\n\n\t\t*rdaio = &dao->daio;\n\t} else {\n\t\tstruct dai *dai = kzalloc(sizeof(*dai), GFP_KERNEL);\n\t\tif (!dai)\n\t\t\tgoto error;\n\n\t\terr = dai_rsc_init(dai, desc, mgr);\n\t\tif (err) {\n\t\t\tkfree(dai);\n\t\t\tgoto error;\n\t\t}\n\n\t\t*rdaio = &dai->daio;\n\t}\n\n\tmgr->daio_enable(mgr, *rdaio);\n\tmgr->commit_write(mgr);\n\n\treturn 0;\n\nerror:\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tdaio_mgr_put_rsc(&mgr->mgr, desc->type);\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\treturn err;\n}\n\nstatic int put_daio_rsc(struct daio_mgr *mgr, struct daio *daio)\n{\n\tunsigned long flags;\n\n\tmgr->daio_disable(mgr, daio);\n\tmgr->commit_write(mgr);\n\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tdaio_mgr_put_rsc(&mgr->mgr, daio->type);\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\n\tif (daio->type <= DAIO_OUT_MAX) {\n\t\tdao_rsc_uninit(container_of(daio, struct dao, daio));\n\t\tkfree(container_of(daio, struct dao, daio));\n\t} else {\n\t\tdai_rsc_uninit(container_of(daio, struct dai, daio));\n\t\tkfree(container_of(daio, struct dai, daio));\n\t}\n\n\treturn 0;\n}\n\nstatic int daio_mgr_enb_daio(struct daio_mgr *mgr, struct daio *daio)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\n\tif (DAIO_OUT_MAX >= daio->type) {\n\t\thw->daio_mgr_enb_dao(mgr->mgr.ctrl_blk,\n\t\t\t\tdaio_device_index(daio->type, hw));\n\t} else {\n\t\thw->daio_mgr_enb_dai(mgr->mgr.ctrl_blk,\n\t\t\t\tdaio_device_index(daio->type, hw));\n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_dsb_daio(struct daio_mgr *mgr, struct daio *daio)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\n\tif (DAIO_OUT_MAX >= daio->type) {\n\t\thw->daio_mgr_dsb_dao(mgr->mgr.ctrl_blk,\n\t\t\t\tdaio_device_index(daio->type, hw));\n\t} else {\n\t\thw->daio_mgr_dsb_dai(mgr->mgr.ctrl_blk,\n\t\t\t\tdaio_device_index(daio->type, hw));\n\t}\n\treturn 0;\n}\n\nstatic int daio_map_op(void *data, struct imapper *entry)\n{\n\tstruct rsc_mgr *mgr = &((struct daio_mgr *)data)->mgr;\n\tstruct hw *hw = mgr->hw;\n\n\thw->daio_mgr_set_imaparc(mgr->ctrl_blk, entry->slot);\n\thw->daio_mgr_set_imapnxt(mgr->ctrl_blk, entry->next);\n\thw->daio_mgr_set_imapaddr(mgr->ctrl_blk, entry->addr);\n\thw->daio_mgr_commit_write(mgr->hw, mgr->ctrl_blk);\n\n\treturn 0;\n}\n\nstatic int daio_imap_add(struct daio_mgr *mgr, struct imapper *entry)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&mgr->imap_lock, flags);\n\tif (!entry->addr && mgr->init_imap_added) {\n\t\tinput_mapper_delete(&mgr->imappers, mgr->init_imap,\n\t\t\t\t\t\t\tdaio_map_op, mgr);\n\t\tmgr->init_imap_added = 0;\n\t}\n\terr = input_mapper_add(&mgr->imappers, entry, daio_map_op, mgr);\n\tspin_unlock_irqrestore(&mgr->imap_lock, flags);\n\n\treturn err;\n}\n\nstatic int daio_imap_delete(struct daio_mgr *mgr, struct imapper *entry)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&mgr->imap_lock, flags);\n\terr = input_mapper_delete(&mgr->imappers, entry, daio_map_op, mgr);\n\tif (list_empty(&mgr->imappers)) {\n\t\tinput_mapper_add(&mgr->imappers, mgr->init_imap,\n\t\t\t\t\t\t\tdaio_map_op, mgr);\n\t\tmgr->init_imap_added = 1;\n\t}\n\tspin_unlock_irqrestore(&mgr->imap_lock, flags);\n\n\treturn err;\n}\n\nstatic int daio_mgr_commit_write(struct daio_mgr *mgr)\n{\n\tstruct hw *hw = mgr->mgr.hw;\n\n\thw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\n\treturn 0;\n}\n\nint daio_mgr_create(struct hw *hw, struct daio_mgr **rdaio_mgr)\n{\n\tint err, i;\n\tstruct daio_mgr *daio_mgr;\n\tstruct imapper *entry;\n\n\t*rdaio_mgr = NULL;\n\tdaio_mgr = kzalloc(sizeof(*daio_mgr), GFP_KERNEL);\n\tif (!daio_mgr)\n\t\treturn -ENOMEM;\n\n\terr = rsc_mgr_init(&daio_mgr->mgr, DAIO, NUM_DAIOTYP, hw);\n\tif (err)\n\t\tgoto error1;\n\n\tspin_lock_init(&daio_mgr->mgr_lock);\n\tspin_lock_init(&daio_mgr->imap_lock);\n\tINIT_LIST_HEAD(&daio_mgr->imappers);\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\terr = -ENOMEM;\n\t\tgoto error2;\n\t}\n\tentry->slot = entry->addr = entry->next = entry->user = 0;\n\tlist_add(&entry->list, &daio_mgr->imappers);\n\tdaio_mgr->init_imap = entry;\n\tdaio_mgr->init_imap_added = 1;\n\n\tdaio_mgr->get_daio = get_daio_rsc;\n\tdaio_mgr->put_daio = put_daio_rsc;\n\tdaio_mgr->daio_enable = daio_mgr_enb_daio;\n\tdaio_mgr->daio_disable = daio_mgr_dsb_daio;\n\tdaio_mgr->imap_add = daio_imap_add;\n\tdaio_mgr->imap_delete = daio_imap_delete;\n\tdaio_mgr->commit_write = daio_mgr_commit_write;\n\tdaio_mgr->card = hw->card;\n\n\tfor (i = 0; i < 8; i++) {\n\t\thw->daio_mgr_dsb_dao(daio_mgr->mgr.ctrl_blk, i);\n\t\thw->daio_mgr_dsb_dai(daio_mgr->mgr.ctrl_blk, i);\n\t}\n\thw->daio_mgr_commit_write(hw, daio_mgr->mgr.ctrl_blk);\n\n\t*rdaio_mgr = daio_mgr;\n\n\treturn 0;\n\nerror2:\n\trsc_mgr_uninit(&daio_mgr->mgr);\nerror1:\n\tkfree(daio_mgr);\n\treturn err;\n}\n\nint daio_mgr_destroy(struct daio_mgr *daio_mgr)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&daio_mgr->imap_lock, flags);\n\tfree_input_mapper_list(&daio_mgr->imappers);\n\tspin_unlock_irqrestore(&daio_mgr->imap_lock, flags);\n\n\trsc_mgr_uninit(&daio_mgr->mgr);\n\tkfree(daio_mgr);\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}