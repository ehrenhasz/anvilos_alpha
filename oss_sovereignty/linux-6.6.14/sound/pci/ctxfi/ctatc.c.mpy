{
  "module_name": "ctatc.c",
  "hash_id": "1a95ca8bc6a53ea7db0c43c262f62672ad1ee71662370c8d23b9315bdd74f49f",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctatc.c",
  "human_readable_source": "\n \n\n#include \"ctatc.h\"\n#include \"ctpcm.h\"\n#include \"ctmixer.h\"\n#include \"ctsrc.h\"\n#include \"ctamixer.h\"\n#include \"ctdaio.h\"\n#include \"cttimer.h\"\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include <sound/asoundef.h>\n\n#define MONO_SUM_SCALE\t0x19a8\t \n#define MAX_MULTI_CHN\t8\n\n#define IEC958_DEFAULT_CON ((IEC958_AES0_NONAUDIO \\\n\t\t\t    | IEC958_AES0_CON_NOT_COPYRIGHT) \\\n\t\t\t    | ((IEC958_AES1_CON_MIXER \\\n\t\t\t    | IEC958_AES1_CON_ORIGINAL) << 8) \\\n\t\t\t    | (0x10 << 16) \\\n\t\t\t    | ((IEC958_AES3_CON_FS_48000) << 24))\n\nstatic const struct snd_pci_quirk subsys_20k1_list[] = {\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, 0x0021, \"SB046x\", CTSB046X),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, 0x0022, \"SB055x\", CTSB055X),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, 0x002f, \"SB055x\", CTSB055X),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, 0x0029, \"SB073x\", CTSB073X),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, 0x0031, \"SB073x\", CTSB073X),\n\tSND_PCI_QUIRK_MASK(PCI_VENDOR_ID_CREATIVE, 0xf000, 0x6000,\n\t\t\t   \"UAA\", CTUAA),\n\t{ }  \n};\n\nstatic const struct snd_pci_quirk subsys_20k2_list[] = {\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, PCI_SUBDEVICE_ID_CREATIVE_SB0760,\n\t\t      \"SB0760\", CTSB0760),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, PCI_SUBDEVICE_ID_CREATIVE_SB1270,\n\t\t      \"SB1270\", CTSB1270),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, PCI_SUBDEVICE_ID_CREATIVE_SB08801,\n\t\t      \"SB0880\", CTSB0880),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, PCI_SUBDEVICE_ID_CREATIVE_SB08802,\n\t\t      \"SB0880\", CTSB0880),\n\tSND_PCI_QUIRK(PCI_VENDOR_ID_CREATIVE, PCI_SUBDEVICE_ID_CREATIVE_SB08803,\n\t\t      \"SB0880\", CTSB0880),\n\tSND_PCI_QUIRK_MASK(PCI_VENDOR_ID_CREATIVE, 0xf000,\n\t\t\t   PCI_SUBDEVICE_ID_CREATIVE_HENDRIX, \"HENDRIX\",\n\t\t\t   CTHENDRIX),\n\t{ }  \n};\n\nstatic const char *ct_subsys_name[NUM_CTCARDS] = {\n\t \n\t[CTSB046X]\t= \"SB046x\",\n\t[CTSB055X]\t= \"SB055x\",\n\t[CTSB073X]\t= \"SB073x\",\n\t[CTUAA]\t\t= \"UAA\",\n\t[CT20K1_UNKNOWN] = \"Unknown\",\n\t \n\t[CTSB0760]\t= \"SB076x\",\n\t[CTHENDRIX]\t= \"Hendrix\",\n\t[CTSB0880]\t= \"SB0880\",\n\t[CTSB1270]      = \"SB1270\",\n\t[CT20K2_UNKNOWN] = \"Unknown\",\n};\n\nstatic struct {\n\tint (*create)(struct ct_atc *atc,\n\t\t\tenum CTALSADEVS device, const char *device_name);\n\tint (*destroy)(void *alsa_dev);\n\tconst char *public_name;\n} alsa_dev_funcs[NUM_CTALSADEVS] = {\n\t[FRONT]\t\t= { .create = ct_alsa_pcm_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"Front/WaveIn\"},\n\t[SURROUND]\t= { .create = ct_alsa_pcm_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"Surround\"},\n\t[CLFE]\t\t= { .create = ct_alsa_pcm_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"Center/LFE\"},\n\t[SIDE]\t\t= { .create = ct_alsa_pcm_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"Side\"},\n\t[IEC958]\t= { .create = ct_alsa_pcm_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"IEC958 Non-audio\"},\n\n\t[MIXER]\t\t= { .create = ct_alsa_mix_create,\n\t\t\t    .destroy = NULL,\n\t\t\t    .public_name = \"Mixer\"}\n};\n\ntypedef int (*create_t)(struct hw *, void **);\ntypedef int (*destroy_t)(void *);\n\nstatic struct {\n\tint (*create)(struct hw *hw, void **rmgr);\n\tint (*destroy)(void *mgr);\n} rsc_mgr_funcs[NUM_RSCTYP] = {\n\t[SRC] \t\t= { .create \t= (create_t)src_mgr_create,\n\t\t\t    .destroy \t= (destroy_t)src_mgr_destroy\t},\n\t[SRCIMP] \t= { .create \t= (create_t)srcimp_mgr_create,\n\t\t\t    .destroy \t= (destroy_t)srcimp_mgr_destroy\t},\n\t[AMIXER]\t= { .create\t= (create_t)amixer_mgr_create,\n\t\t\t    .destroy\t= (destroy_t)amixer_mgr_destroy\t},\n\t[SUM]\t\t= { .create\t= (create_t)sum_mgr_create,\n\t\t\t    .destroy\t= (destroy_t)sum_mgr_destroy\t},\n\t[DAIO]\t\t= { .create\t= (create_t)daio_mgr_create,\n\t\t\t    .destroy\t= (destroy_t)daio_mgr_destroy\t}\n};\n\nstatic int\natc_pcm_release_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm);\n\n \n\nstatic int ct_map_audio_buffer(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct ct_vm *vm;\n\n\tif (!apcm->substream)\n\t\treturn 0;\n\n\truntime = apcm->substream->runtime;\n\tvm = atc->vm;\n\n\tapcm->vm_block = vm->map(vm, apcm->substream, runtime->dma_bytes);\n\n\tif (!apcm->vm_block)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic void ct_unmap_audio_buffer(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct ct_vm *vm;\n\n\tif (!apcm->vm_block)\n\t\treturn;\n\n\tvm = atc->vm;\n\n\tvm->unmap(vm, apcm->vm_block);\n\n\tapcm->vm_block = NULL;\n}\n\nstatic unsigned long atc_get_ptp_phys(struct ct_atc *atc, int index)\n{\n\treturn atc->vm->get_ptp_phys(atc->vm, index);\n}\n\nstatic unsigned int convert_format(snd_pcm_format_t snd_format,\n\t\t\t\t   struct snd_card *card)\n{\n\tswitch (snd_format) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\treturn SRC_SF_U8;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\treturn SRC_SF_S16;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\treturn SRC_SF_S24;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\treturn SRC_SF_S32;\n\tcase SNDRV_PCM_FORMAT_FLOAT_LE:\n\t\treturn SRC_SF_F32;\n\tdefault:\n\t\tdev_err(card->dev, \"not recognized snd format is %d\\n\",\n\t\t\tsnd_format);\n\t\treturn SRC_SF_S16;\n\t}\n}\n\nstatic unsigned int\natc_get_pitch(unsigned int input_rate, unsigned int output_rate)\n{\n\tunsigned int pitch;\n\tint b;\n\n\t \n\tpitch = (input_rate / output_rate) << 24;\n\tinput_rate %= output_rate;\n\tinput_rate /= 100;\n\toutput_rate /= 100;\n\tfor (b = 31; ((b >= 0) && !(input_rate >> b)); )\n\t\tb--;\n\n\tif (b >= 0) {\n\t\tinput_rate <<= (31 - b);\n\t\tinput_rate /= output_rate;\n\t\tb = 24 - (31 - b);\n\t\tif (b >= 0)\n\t\t\tinput_rate <<= b;\n\t\telse\n\t\t\tinput_rate >>= -b;\n\n\t\tpitch |= input_rate;\n\t}\n\n\treturn pitch;\n}\n\nstatic int select_rom(unsigned int pitch)\n{\n\tif (pitch > 0x00428f5c && pitch < 0x01b851ec) {\n\t\t \n\t\treturn 1;\n\t} else if (pitch == 0x01d66666 || pitch == 0x01d66667) {\n\t\t \n\t\treturn 2;\n\t} else if (pitch == 0x02000000) {\n\t\t \n\t\treturn 3;\n\t} else if (pitch <= 0x08000000) {\n\t\t \n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}\n\nstatic int atc_pcm_playback_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\n\tstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\n\tstruct src_desc desc = {0};\n\tstruct amixer_desc mix_dsc = {0};\n\tstruct src *src;\n\tstruct amixer *amixer;\n\tint err;\n\tint n_amixer = apcm->substream->runtime->channels, i = 0;\n\tint device = apcm->substream->pcm->device;\n\tunsigned int pitch;\n\n\t \n\tatc_pcm_release_resources(atc, apcm);\n\n\t \n\tdesc.multi = apcm->substream->runtime->channels;\n\tdesc.msr = atc->msr;\n\tdesc.mode = MEMRD;\n\terr = src_mgr->get_src(src_mgr, &desc, (struct src **)&apcm->src);\n\tif (err)\n\t\tgoto error1;\n\n\tpitch = atc_get_pitch(apcm->substream->runtime->rate,\n\t\t\t\t\t\t(atc->rsr * atc->msr));\n\tsrc = apcm->src;\n\tsrc->ops->set_pitch(src, pitch);\n\tsrc->ops->set_rom(src, select_rom(pitch));\n\tsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format,\n\t\t\t\t\t     atc->card));\n\tsrc->ops->set_pm(src, (src->ops->next_interleave(src) != NULL));\n\n\t \n\tn_amixer = (n_amixer < 2) ? 2 : n_amixer;\n\tapcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);\n\tif (!apcm->amixers) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tmix_dsc.msr = atc->msr;\n\tfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\n\t\terr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\n\t\t\t\t\t(struct amixer **)&apcm->amixers[i]);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\tapcm->n_amixer++;\n\t}\n\n\t \n\terr = ct_map_audio_buffer(atc, apcm);\n\tif (err < 0)\n\t\tgoto error1;\n\n\t \n\tsrc = apcm->src;\n\tfor (i = 0; i < n_amixer; i++) {\n\t\tamixer = apcm->amixers[i];\n\t\tmutex_lock(&atc->atc_mutex);\n\t\tamixer->ops->setup(amixer, &src->rsc,\n\t\t\t\t\tINIT_VOL, atc->pcm[i+device*2]);\n\t\tmutex_unlock(&atc->atc_mutex);\n\t\tsrc = src->ops->next_interleave(src);\n\t\tif (!src)\n\t\t\tsrc = apcm->src;\n\t}\n\n\tct_timer_prepare(apcm->timer);\n\n\treturn 0;\n\nerror1:\n\tatc_pcm_release_resources(atc, apcm);\n\treturn err;\n}\n\nstatic int\natc_pcm_release_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\n\tstruct srcimp_mgr *srcimp_mgr = atc->rsc_mgrs[SRCIMP];\n\tstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\n\tstruct sum_mgr *sum_mgr = atc->rsc_mgrs[SUM];\n\tstruct srcimp *srcimp;\n\tint i;\n\n\tif (apcm->srcimps) {\n\t\tfor (i = 0; i < apcm->n_srcimp; i++) {\n\t\t\tsrcimp = apcm->srcimps[i];\n\t\t\tsrcimp->ops->unmap(srcimp);\n\t\t\tsrcimp_mgr->put_srcimp(srcimp_mgr, srcimp);\n\t\t\tapcm->srcimps[i] = NULL;\n\t\t}\n\t\tkfree(apcm->srcimps);\n\t\tapcm->srcimps = NULL;\n\t}\n\n\tif (apcm->srccs) {\n\t\tfor (i = 0; i < apcm->n_srcc; i++) {\n\t\t\tsrc_mgr->put_src(src_mgr, apcm->srccs[i]);\n\t\t\tapcm->srccs[i] = NULL;\n\t\t}\n\t\tkfree(apcm->srccs);\n\t\tapcm->srccs = NULL;\n\t}\n\n\tif (apcm->amixers) {\n\t\tfor (i = 0; i < apcm->n_amixer; i++) {\n\t\t\tamixer_mgr->put_amixer(amixer_mgr, apcm->amixers[i]);\n\t\t\tapcm->amixers[i] = NULL;\n\t\t}\n\t\tkfree(apcm->amixers);\n\t\tapcm->amixers = NULL;\n\t}\n\n\tif (apcm->mono) {\n\t\tsum_mgr->put_sum(sum_mgr, apcm->mono);\n\t\tapcm->mono = NULL;\n\t}\n\n\tif (apcm->src) {\n\t\tsrc_mgr->put_src(src_mgr, apcm->src);\n\t\tapcm->src = NULL;\n\t}\n\n\tif (apcm->vm_block) {\n\t\t \n\t\tct_unmap_audio_buffer(atc, apcm);\n\t\tapcm->vm_block = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int atc_pcm_playback_start(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tunsigned int max_cisz;\n\tstruct src *src = apcm->src;\n\n\tif (apcm->started)\n\t\treturn 0;\n\tapcm->started = 1;\n\n\tmax_cisz = src->multi * src->rsc.msr;\n\tmax_cisz = 0x80 * (max_cisz < 8 ? max_cisz : 8);\n\n\tsrc->ops->set_sa(src, apcm->vm_block->addr);\n\tsrc->ops->set_la(src, apcm->vm_block->addr + apcm->vm_block->size);\n\tsrc->ops->set_ca(src, apcm->vm_block->addr + max_cisz);\n\tsrc->ops->set_cisz(src, max_cisz);\n\n\tsrc->ops->set_bm(src, 1);\n\tsrc->ops->set_state(src, SRC_STATE_INIT);\n\tsrc->ops->commit_write(src);\n\n\tct_timer_start(apcm->timer);\n\treturn 0;\n}\n\nstatic int atc_pcm_stop(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src;\n\tint i;\n\n\tct_timer_stop(apcm->timer);\n\n\tsrc = apcm->src;\n\tsrc->ops->set_bm(src, 0);\n\tsrc->ops->set_state(src, SRC_STATE_OFF);\n\tsrc->ops->commit_write(src);\n\n\tif (apcm->srccs) {\n\t\tfor (i = 0; i < apcm->n_srcc; i++) {\n\t\t\tsrc = apcm->srccs[i];\n\t\t\tsrc->ops->set_bm(src, 0);\n\t\t\tsrc->ops->set_state(src, SRC_STATE_OFF);\n\t\t\tsrc->ops->commit_write(src);\n\t\t}\n\t}\n\n\tapcm->started = 0;\n\n\treturn 0;\n}\n\nstatic int\natc_pcm_playback_position(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src = apcm->src;\n\tu32 size, max_cisz;\n\tint position;\n\n\tif (!src)\n\t\treturn 0;\n\tposition = src->ops->get_ca(src);\n\n\tif (position < apcm->vm_block->addr) {\n\t\tdev_dbg(atc->card->dev,\n\t\t\t\"bad ca - ca=0x%08x, vba=0x%08x, vbs=0x%08x\\n\",\n\t\t\tposition, apcm->vm_block->addr, apcm->vm_block->size);\n\t\tposition = apcm->vm_block->addr;\n\t}\n\n\tsize = apcm->vm_block->size;\n\tmax_cisz = src->multi * src->rsc.msr;\n\tmax_cisz = 128 * (max_cisz < 8 ? max_cisz : 8);\n\n\treturn (position + size - max_cisz - apcm->vm_block->addr) % size;\n}\n\nstruct src_node_conf_t {\n\tunsigned int pitch;\n\tunsigned int msr:8;\n\tunsigned int mix_msr:8;\n\tunsigned int imp_msr:8;\n\tunsigned int vo:1;\n};\n\nstatic void setup_src_node_conf(struct ct_atc *atc, struct ct_atc_pcm *apcm,\n\t\t\t\tstruct src_node_conf_t *conf, int *n_srcc)\n{\n\tunsigned int pitch;\n\n\t \n\tpitch = atc_get_pitch((atc->rsr * atc->msr),\n\t\t\t\tapcm->substream->runtime->rate);\n\t*n_srcc = 0;\n\n\tif (1 == atc->msr) {  \n\t\t*n_srcc = apcm->substream->runtime->channels;\n\t\tconf[0].pitch = pitch;\n\t\tconf[0].mix_msr = conf[0].imp_msr = conf[0].msr = 1;\n\t\tconf[0].vo = 1;\n\t} else if (2 <= atc->msr) {\n\t\tif (0x8000000 < pitch) {\n\t\t\t \n\t\t\tconf[0].pitch = (atc->msr << 24);\n\t\t\tconf[0].msr = conf[0].mix_msr = 1;\n\t\t\tconf[0].imp_msr = atc->msr;\n\t\t\tconf[0].vo = 0;\n\t\t\tconf[1].pitch = atc_get_pitch(atc->rsr,\n\t\t\t\t\tapcm->substream->runtime->rate);\n\t\t\tconf[1].msr = conf[1].mix_msr = conf[1].imp_msr = 1;\n\t\t\tconf[1].vo = 1;\n\t\t\t*n_srcc = apcm->substream->runtime->channels * 2;\n\t\t} else if (0x1000000 < pitch) {\n\t\t\t \n\t\t\tconf[0].pitch = pitch;\n\t\t\tconf[0].msr = conf[0].mix_msr\n\t\t\t\t    = conf[0].imp_msr = atc->msr;\n\t\t\tconf[0].vo = 1;\n\t\t\t*n_srcc = apcm->substream->runtime->channels;\n\t\t}\n\t}\n}\n\nstatic int\natc_pcm_capture_get_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\n\tstruct srcimp_mgr *srcimp_mgr = atc->rsc_mgrs[SRCIMP];\n\tstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\n\tstruct sum_mgr *sum_mgr = atc->rsc_mgrs[SUM];\n\tstruct src_desc src_dsc = {0};\n\tstruct src *src;\n\tstruct srcimp_desc srcimp_dsc = {0};\n\tstruct srcimp *srcimp;\n\tstruct amixer_desc mix_dsc = {0};\n\tstruct sum_desc sum_dsc = {0};\n\tunsigned int pitch;\n\tint multi, err, i;\n\tint n_srcimp, n_amixer, n_srcc, n_sum;\n\tstruct src_node_conf_t src_node_conf[2] = {{0} };\n\n\t \n\tatc_pcm_release_resources(atc, apcm);\n\n\t \n\n\tmulti = apcm->substream->runtime->channels;\n\n\t \n\tpitch = atc_get_pitch((atc->rsr * atc->msr),\n\t\t\t\tapcm->substream->runtime->rate);\n\n\tsetup_src_node_conf(atc, apcm, src_node_conf, &n_srcc);\n\tn_sum = (1 == multi) ? 1 : 0;\n\tn_amixer = n_sum * 2 + n_srcc;\n\tn_srcimp = n_srcc;\n\tif ((multi > 1) && (0x8000000 >= pitch)) {\n\t\t \n\t\tn_amixer += multi * atc->msr;\n\t\tn_srcimp += multi * atc->msr;\n\t} else {\n\t\tn_srcimp += multi;\n\t}\n\n\tif (n_srcc) {\n\t\tapcm->srccs = kcalloc(n_srcc, sizeof(void *), GFP_KERNEL);\n\t\tif (!apcm->srccs)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (n_amixer) {\n\t\tapcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);\n\t\tif (!apcm->amixers) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error1;\n\t\t}\n\t}\n\tapcm->srcimps = kcalloc(n_srcimp, sizeof(void *), GFP_KERNEL);\n\tif (!apcm->srcimps) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\t \n\tsrc_dsc.multi = 1;\n\tsrc_dsc.mode = ARCRW;\n\tfor (i = 0, apcm->n_srcc = 0; i < n_srcc; i++) {\n\t\tsrc_dsc.msr = src_node_conf[i/multi].msr;\n\t\terr = src_mgr->get_src(src_mgr, &src_dsc,\n\t\t\t\t\t(struct src **)&apcm->srccs[i]);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\tsrc = apcm->srccs[i];\n\t\tpitch = src_node_conf[i/multi].pitch;\n\t\tsrc->ops->set_pitch(src, pitch);\n\t\tsrc->ops->set_rom(src, select_rom(pitch));\n\t\tsrc->ops->set_vo(src, src_node_conf[i/multi].vo);\n\n\t\tapcm->n_srcc++;\n\t}\n\n\t \n\tfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\n\t\tif (i < (n_sum*2))\n\t\t\tmix_dsc.msr = atc->msr;\n\t\telse if (i < (n_sum*2+n_srcc))\n\t\t\tmix_dsc.msr = src_node_conf[(i-n_sum*2)/multi].mix_msr;\n\t\telse\n\t\t\tmix_dsc.msr = 1;\n\n\t\terr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\n\t\t\t\t\t(struct amixer **)&apcm->amixers[i]);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\tapcm->n_amixer++;\n\t}\n\n\t \n\tsum_dsc.msr = atc->msr;\n\terr = sum_mgr->get_sum(sum_mgr, &sum_dsc, (struct sum **)&apcm->mono);\n\tif (err)\n\t\tgoto error1;\n\n\tpitch = atc_get_pitch((atc->rsr * atc->msr),\n\t\t\t\tapcm->substream->runtime->rate);\n\t \n\tfor (i = 0, apcm->n_srcimp = 0; i < n_srcimp; i++) {\n\t\tif (i < (n_srcc))\n\t\t\tsrcimp_dsc.msr = src_node_conf[i/multi].imp_msr;\n\t\telse if (1 == multi)\n\t\t\tsrcimp_dsc.msr = (pitch <= 0x8000000) ? atc->msr : 1;\n\t\telse\n\t\t\tsrcimp_dsc.msr = 1;\n\n\t\terr = srcimp_mgr->get_srcimp(srcimp_mgr, &srcimp_dsc, &srcimp);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\tapcm->srcimps[i] = srcimp;\n\t\tapcm->n_srcimp++;\n\t}\n\n\t \n\tsrc_dsc.multi = apcm->substream->runtime->channels;\n\tsrc_dsc.msr = 1;\n\tsrc_dsc.mode = MEMWR;\n\terr = src_mgr->get_src(src_mgr, &src_dsc, (struct src **)&apcm->src);\n\tif (err)\n\t\tgoto error1;\n\n\tsrc = apcm->src;\n\tsrc->ops->set_pitch(src, pitch);\n\n\t \n\terr = ct_map_audio_buffer(atc, apcm);\n\tif (err < 0)\n\t\tgoto error1;\n\n\treturn 0;\n\nerror1:\n\tatc_pcm_release_resources(atc, apcm);\n\treturn err;\n}\n\nstatic int atc_pcm_capture_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src;\n\tstruct amixer *amixer;\n\tstruct srcimp *srcimp;\n\tstruct ct_mixer *mixer = atc->mixer;\n\tstruct sum *mono;\n\tstruct rsc *out_ports[8] = {NULL};\n\tint err, i, j, n_sum, multi;\n\tunsigned int pitch;\n\tint mix_base = 0, imp_base = 0;\n\n\tatc_pcm_release_resources(atc, apcm);\n\n\t \n\terr = atc_pcm_capture_get_resources(atc, apcm);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmixer->get_output_ports(mixer, MIX_PCMO_FRONT,\n\t\t\t\t&out_ports[0], &out_ports[1]);\n\n\tmulti = apcm->substream->runtime->channels;\n\tif (1 == multi) {\n\t\tmono = apcm->mono;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tamixer = apcm->amixers[i];\n\t\t\tamixer->ops->setup(amixer, out_ports[i],\n\t\t\t\t\t\tMONO_SUM_SCALE, mono);\n\t\t}\n\t\tout_ports[0] = &mono->rsc;\n\t\tn_sum = 1;\n\t\tmix_base = n_sum * 2;\n\t}\n\n\tfor (i = 0; i < apcm->n_srcc; i++) {\n\t\tsrc = apcm->srccs[i];\n\t\tsrcimp = apcm->srcimps[imp_base+i];\n\t\tamixer = apcm->amixers[mix_base+i];\n\t\tsrcimp->ops->map(srcimp, src, out_ports[i%multi]);\n\t\tamixer->ops->setup(amixer, &src->rsc, INIT_VOL, NULL);\n\t\tout_ports[i%multi] = &amixer->rsc;\n\t}\n\n\tpitch = atc_get_pitch((atc->rsr * atc->msr),\n\t\t\t\tapcm->substream->runtime->rate);\n\n\tif ((multi > 1) && (pitch <= 0x8000000)) {\n\t\t \n\t\tfor (i = 0; i < multi; i++) {\n\t\t\tout_ports[i]->ops->master(out_ports[i]);\n\t\t\tfor (j = 0; j < atc->msr; j++) {\n\t\t\t\tamixer = apcm->amixers[apcm->n_srcc+j*multi+i];\n\t\t\t\tamixer->ops->set_input(amixer, out_ports[i]);\n\t\t\t\tamixer->ops->set_scale(amixer, INIT_VOL);\n\t\t\t\tamixer->ops->set_sum(amixer, NULL);\n\t\t\t\tamixer->ops->commit_raw_write(amixer);\n\t\t\t\tout_ports[i]->ops->next_conj(out_ports[i]);\n\n\t\t\t\tsrcimp = apcm->srcimps[apcm->n_srcc+j*multi+i];\n\t\t\t\tsrcimp->ops->map(srcimp, apcm->src,\n\t\t\t\t\t\t\t&amixer->rsc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < multi; i++) {\n\t\t\tsrcimp = apcm->srcimps[apcm->n_srcc+i];\n\t\t\tsrcimp->ops->map(srcimp, apcm->src, out_ports[i]);\n\t\t}\n\t}\n\n\tct_timer_prepare(apcm->timer);\n\n\treturn 0;\n}\n\nstatic int atc_pcm_capture_start(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src;\n\tstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\n\tint i, multi;\n\n\tif (apcm->started)\n\t\treturn 0;\n\n\tapcm->started = 1;\n\tmulti = apcm->substream->runtime->channels;\n\t \n\tfor (i = 0; i < apcm->n_srcc; i++) {\n\t\tsrc = apcm->srccs[i];\n\t\tsrc->ops->set_pm(src, ((i%multi) != (multi-1)));\n\t\tsrc_mgr->src_disable(src_mgr, src);\n\t}\n\n\t \n\tsrc = apcm->src;\n\tsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format,\n\t\t\t\t\t     atc->card));\n\tsrc->ops->set_sa(src, apcm->vm_block->addr);\n\tsrc->ops->set_la(src, apcm->vm_block->addr + apcm->vm_block->size);\n\tsrc->ops->set_ca(src, apcm->vm_block->addr);\n\tsrc_mgr->src_disable(src_mgr, src);\n\n\t \n\tsrc_mgr->commit_write(src_mgr);\n\n\t \n\tfor (i = 0; i < apcm->n_srcc; i++) {\n\t\tsrc = apcm->srccs[i];\n\t\tsrc->ops->set_state(src, SRC_STATE_RUN);\n\t\tsrc->ops->commit_write(src);\n\t\tsrc_mgr->src_enable_s(src_mgr, src);\n\t}\n\tsrc = apcm->src;\n\tsrc->ops->set_bm(src, 1);\n\tsrc->ops->set_state(src, SRC_STATE_RUN);\n\tsrc->ops->commit_write(src);\n\tsrc_mgr->src_enable_s(src_mgr, src);\n\n\t \n\tsrc_mgr->commit_write(src_mgr);\n\n\tct_timer_start(apcm->timer);\n\treturn 0;\n}\n\nstatic int\natc_pcm_capture_position(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src = apcm->src;\n\n\tif (!src)\n\t\treturn 0;\n\treturn src->ops->get_ca(src) - apcm->vm_block->addr;\n}\n\nstatic int spdif_passthru_playback_get_resources(struct ct_atc *atc,\n\t\t\t\t\t\t struct ct_atc_pcm *apcm)\n{\n\tstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\n\tstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\n\tstruct src_desc desc = {0};\n\tstruct amixer_desc mix_dsc = {0};\n\tstruct src *src;\n\tint err;\n\tint n_amixer = apcm->substream->runtime->channels, i;\n\tunsigned int pitch, rsr = atc->pll_rate;\n\n\t \n\tatc_pcm_release_resources(atc, apcm);\n\n\t \n\tdesc.multi = apcm->substream->runtime->channels;\n\tdesc.msr = 1;\n\twhile (apcm->substream->runtime->rate > (rsr * desc.msr))\n\t\tdesc.msr <<= 1;\n\n\tdesc.mode = MEMRD;\n\terr = src_mgr->get_src(src_mgr, &desc, (struct src **)&apcm->src);\n\tif (err)\n\t\tgoto error1;\n\n\tpitch = atc_get_pitch(apcm->substream->runtime->rate, (rsr * desc.msr));\n\tsrc = apcm->src;\n\tsrc->ops->set_pitch(src, pitch);\n\tsrc->ops->set_rom(src, select_rom(pitch));\n\tsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format,\n\t\t\t\t\t     atc->card));\n\tsrc->ops->set_pm(src, (src->ops->next_interleave(src) != NULL));\n\tsrc->ops->set_bp(src, 1);\n\n\t \n\tn_amixer = (n_amixer < 2) ? 2 : n_amixer;\n\tapcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);\n\tif (!apcm->amixers) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tmix_dsc.msr = desc.msr;\n\tfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\n\t\terr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\n\t\t\t\t\t(struct amixer **)&apcm->amixers[i]);\n\t\tif (err)\n\t\t\tgoto error1;\n\n\t\tapcm->n_amixer++;\n\t}\n\n\t \n\terr = ct_map_audio_buffer(atc, apcm);\n\tif (err < 0)\n\t\tgoto error1;\n\n\treturn 0;\n\nerror1:\n\tatc_pcm_release_resources(atc, apcm);\n\treturn err;\n}\n\nstatic int atc_pll_init(struct ct_atc *atc, int rate)\n{\n\tstruct hw *hw = atc->hw;\n\tint err;\n\terr = hw->pll_init(hw, rate);\n\tatc->pll_rate = err ? 0 : rate;\n\treturn err;\n}\n\nstatic int\nspdif_passthru_playback_setup(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct dao *dao = container_of(atc->daios[SPDIFOO], struct dao, daio);\n\tunsigned int rate = apcm->substream->runtime->rate;\n\tunsigned int status;\n\tint err = 0;\n\tunsigned char iec958_con_fs;\n\n\tswitch (rate) {\n\tcase 48000:\n\t\tiec958_con_fs = IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 44100:\n\t\tiec958_con_fs = IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 32000:\n\t\tiec958_con_fs = IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&atc->atc_mutex);\n\tdao->ops->get_spos(dao, &status);\n\tif (((status >> 24) & IEC958_AES3_CON_FS) != iec958_con_fs) {\n\t\tstatus &= ~(IEC958_AES3_CON_FS << 24);\n\t\tstatus |= (iec958_con_fs << 24);\n\t\tdao->ops->set_spos(dao, status);\n\t\tdao->ops->commit_write(dao);\n\t}\n\tif ((rate != atc->pll_rate) && (32000 != rate))\n\t\terr = atc_pll_init(atc, rate);\n\tmutex_unlock(&atc->atc_mutex);\n\n\treturn err;\n}\n\nstatic int\nspdif_passthru_playback_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\n{\n\tstruct src *src;\n\tstruct amixer *amixer;\n\tstruct dao *dao;\n\tint err;\n\tint i;\n\n\tatc_pcm_release_resources(atc, apcm);\n\n\t \n\terr = spdif_passthru_playback_setup(atc, apcm);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = spdif_passthru_playback_get_resources(atc, apcm);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsrc = apcm->src;\n\tfor (i = 0; i < apcm->n_amixer; i++) {\n\t\tamixer = apcm->amixers[i];\n\t\tamixer->ops->setup(amixer, &src->rsc, INIT_VOL, NULL);\n\t\tsrc = src->ops->next_interleave(src);\n\t\tif (!src)\n\t\t\tsrc = apcm->src;\n\t}\n\t \n\tmutex_lock(&atc->atc_mutex);\n\tdao = container_of(atc->daios[SPDIFOO], struct dao, daio);\n\tamixer = apcm->amixers[0];\n\tdao->ops->set_left_input(dao, &amixer->rsc);\n\tamixer = apcm->amixers[1];\n\tdao->ops->set_right_input(dao, &amixer->rsc);\n\tmutex_unlock(&atc->atc_mutex);\n\n\tct_timer_prepare(apcm->timer);\n\n\treturn 0;\n}\n\nstatic int atc_select_line_in(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\tstruct ct_mixer *mixer = atc->mixer;\n\tstruct src *src;\n\n\tif (hw->is_adc_source_selected(hw, ADC_LINEIN))\n\t\treturn 0;\n\n\tmixer->set_input_left(mixer, MIX_MIC_IN, NULL);\n\tmixer->set_input_right(mixer, MIX_MIC_IN, NULL);\n\n\thw->select_adc_source(hw, ADC_LINEIN);\n\n\tsrc = atc->srcs[2];\n\tmixer->set_input_left(mixer, MIX_LINE_IN, &src->rsc);\n\tsrc = atc->srcs[3];\n\tmixer->set_input_right(mixer, MIX_LINE_IN, &src->rsc);\n\n\treturn 0;\n}\n\nstatic int atc_select_mic_in(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\tstruct ct_mixer *mixer = atc->mixer;\n\tstruct src *src;\n\n\tif (hw->is_adc_source_selected(hw, ADC_MICIN))\n\t\treturn 0;\n\n\tmixer->set_input_left(mixer, MIX_LINE_IN, NULL);\n\tmixer->set_input_right(mixer, MIX_LINE_IN, NULL);\n\n\thw->select_adc_source(hw, ADC_MICIN);\n\n\tsrc = atc->srcs[2];\n\tmixer->set_input_left(mixer, MIX_MIC_IN, &src->rsc);\n\tsrc = atc->srcs[3];\n\tmixer->set_input_right(mixer, MIX_MIC_IN, &src->rsc);\n\n\treturn 0;\n}\n\nstatic struct capabilities atc_capabilities(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\n\treturn hw->capabilities(hw);\n}\n\nstatic int atc_output_switch_get(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\n\treturn hw->output_switch_get(hw);\n}\n\nstatic int atc_output_switch_put(struct ct_atc *atc, int position)\n{\n\tstruct hw *hw = atc->hw;\n\n\treturn hw->output_switch_put(hw, position);\n}\n\nstatic int atc_mic_source_switch_get(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\n\treturn hw->mic_source_switch_get(hw);\n}\n\nstatic int atc_mic_source_switch_put(struct ct_atc *atc, int position)\n{\n\tstruct hw *hw = atc->hw;\n\n\treturn hw->mic_source_switch_put(hw, position);\n}\n\nstatic int atc_select_digit_io(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\n\tif (hw->is_adc_source_selected(hw, ADC_NONE))\n\t\treturn 0;\n\n\thw->select_adc_source(hw, ADC_NONE);\n\n\treturn 0;\n}\n\nstatic int atc_daio_unmute(struct ct_atc *atc, unsigned char state, int type)\n{\n\tstruct daio_mgr *daio_mgr = atc->rsc_mgrs[DAIO];\n\n\tif (state)\n\t\tdaio_mgr->daio_enable(daio_mgr, atc->daios[type]);\n\telse\n\t\tdaio_mgr->daio_disable(daio_mgr, atc->daios[type]);\n\n\tdaio_mgr->commit_write(daio_mgr);\n\n\treturn 0;\n}\n\nstatic int\natc_dao_get_status(struct ct_atc *atc, unsigned int *status, int type)\n{\n\tstruct dao *dao = container_of(atc->daios[type], struct dao, daio);\n\treturn dao->ops->get_spos(dao, status);\n}\n\nstatic int\natc_dao_set_status(struct ct_atc *atc, unsigned int status, int type)\n{\n\tstruct dao *dao = container_of(atc->daios[type], struct dao, daio);\n\n\tdao->ops->set_spos(dao, status);\n\tdao->ops->commit_write(dao);\n\treturn 0;\n}\n\nstatic int atc_line_front_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, LINEO1);\n}\n\nstatic int atc_line_surround_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, LINEO2);\n}\n\nstatic int atc_line_clfe_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, LINEO3);\n}\n\nstatic int atc_line_rear_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, LINEO4);\n}\n\nstatic int atc_line_in_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, LINEIM);\n}\n\nstatic int atc_mic_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, MIC);\n}\n\nstatic int atc_spdif_out_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, SPDIFOO);\n}\n\nstatic int atc_spdif_in_unmute(struct ct_atc *atc, unsigned char state)\n{\n\treturn atc_daio_unmute(atc, state, SPDIFIO);\n}\n\nstatic int atc_spdif_out_get_status(struct ct_atc *atc, unsigned int *status)\n{\n\treturn atc_dao_get_status(atc, status, SPDIFOO);\n}\n\nstatic int atc_spdif_out_set_status(struct ct_atc *atc, unsigned int status)\n{\n\treturn atc_dao_set_status(atc, status, SPDIFOO);\n}\n\nstatic int atc_spdif_out_passthru(struct ct_atc *atc, unsigned char state)\n{\n\tstruct dao_desc da_dsc = {0};\n\tstruct dao *dao;\n\tint err;\n\tstruct ct_mixer *mixer = atc->mixer;\n\tstruct rsc *rscs[2] = {NULL};\n\tunsigned int spos = 0;\n\n\tmutex_lock(&atc->atc_mutex);\n\tdao = container_of(atc->daios[SPDIFOO], struct dao, daio);\n\tda_dsc.msr = state ? 1 : atc->msr;\n\tda_dsc.passthru = state ? 1 : 0;\n\terr = dao->ops->reinit(dao, &da_dsc);\n\tif (state) {\n\t\tspos = IEC958_DEFAULT_CON;\n\t} else {\n\t\tmixer->get_output_ports(mixer, MIX_SPDIF_OUT,\n\t\t\t\t\t&rscs[0], &rscs[1]);\n\t\tdao->ops->set_left_input(dao, rscs[0]);\n\t\tdao->ops->set_right_input(dao, rscs[1]);\n\t\t \n\t\tif (atc->pll_rate != atc->rsr)\n\t\t\terr = atc_pll_init(atc, atc->rsr);\n\t}\n\tdao->ops->set_spos(dao, spos);\n\tdao->ops->commit_write(dao);\n\tmutex_unlock(&atc->atc_mutex);\n\n\treturn err;\n}\n\nstatic int atc_release_resources(struct ct_atc *atc)\n{\n\tint i;\n\tstruct daio_mgr *daio_mgr = NULL;\n\tstruct dao *dao = NULL;\n\tstruct daio *daio = NULL;\n\tstruct sum_mgr *sum_mgr = NULL;\n\tstruct src_mgr *src_mgr = NULL;\n\tstruct srcimp_mgr *srcimp_mgr = NULL;\n\tstruct srcimp *srcimp = NULL;\n\tstruct ct_mixer *mixer = NULL;\n\n\t \n\tif (atc->mixer) {\n\t\tmixer = atc->mixer;\n\t\tmixer->set_input_left(mixer, MIX_LINE_IN, NULL);\n\t\tmixer->set_input_right(mixer, MIX_LINE_IN, NULL);\n\t\tmixer->set_input_left(mixer, MIX_MIC_IN, NULL);\n\t\tmixer->set_input_right(mixer, MIX_MIC_IN, NULL);\n\t\tmixer->set_input_left(mixer, MIX_SPDIF_IN, NULL);\n\t\tmixer->set_input_right(mixer, MIX_SPDIF_IN, NULL);\n\t}\n\n\tif (atc->daios) {\n\t\tdaio_mgr = (struct daio_mgr *)atc->rsc_mgrs[DAIO];\n\t\tfor (i = 0; i < atc->n_daio; i++) {\n\t\t\tdaio = atc->daios[i];\n\t\t\tif (daio->type < LINEIM) {\n\t\t\t\tdao = container_of(daio, struct dao, daio);\n\t\t\t\tdao->ops->clear_left_input(dao);\n\t\t\t\tdao->ops->clear_right_input(dao);\n\t\t\t}\n\t\t\tdaio_mgr->put_daio(daio_mgr, daio);\n\t\t}\n\t\tkfree(atc->daios);\n\t\tatc->daios = NULL;\n\t}\n\n\tif (atc->pcm) {\n\t\tsum_mgr = atc->rsc_mgrs[SUM];\n\t\tfor (i = 0; i < atc->n_pcm; i++)\n\t\t\tsum_mgr->put_sum(sum_mgr, atc->pcm[i]);\n\n\t\tkfree(atc->pcm);\n\t\tatc->pcm = NULL;\n\t}\n\n\tif (atc->srcs) {\n\t\tsrc_mgr = atc->rsc_mgrs[SRC];\n\t\tfor (i = 0; i < atc->n_src; i++)\n\t\t\tsrc_mgr->put_src(src_mgr, atc->srcs[i]);\n\n\t\tkfree(atc->srcs);\n\t\tatc->srcs = NULL;\n\t}\n\n\tif (atc->srcimps) {\n\t\tsrcimp_mgr = atc->rsc_mgrs[SRCIMP];\n\t\tfor (i = 0; i < atc->n_srcimp; i++) {\n\t\t\tsrcimp = atc->srcimps[i];\n\t\t\tsrcimp->ops->unmap(srcimp);\n\t\t\tsrcimp_mgr->put_srcimp(srcimp_mgr, atc->srcimps[i]);\n\t\t}\n\t\tkfree(atc->srcimps);\n\t\tatc->srcimps = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ct_atc_destroy(struct ct_atc *atc)\n{\n\tint i = 0;\n\n\tif (!atc)\n\t\treturn 0;\n\n\tif (atc->timer) {\n\t\tct_timer_free(atc->timer);\n\t\tatc->timer = NULL;\n\t}\n\n\tatc_release_resources(atc);\n\n\t \n\tif (atc->mixer)\n\t\tct_mixer_destroy(atc->mixer);\n\n\tfor (i = 0; i < NUM_RSCTYP; i++) {\n\t\tif (rsc_mgr_funcs[i].destroy && atc->rsc_mgrs[i])\n\t\t\trsc_mgr_funcs[i].destroy(atc->rsc_mgrs[i]);\n\n\t}\n\n\tif (atc->hw)\n\t\tdestroy_hw_obj(atc->hw);\n\n\t \n\tif (atc->vm) {\n\t\tct_vm_destroy(atc->vm);\n\t\tatc->vm = NULL;\n\t}\n\n\tkfree(atc);\n\n\treturn 0;\n}\n\nstatic int atc_dev_free(struct snd_device *dev)\n{\n\tstruct ct_atc *atc = dev->device_data;\n\treturn ct_atc_destroy(atc);\n}\n\nstatic int atc_identify_card(struct ct_atc *atc, unsigned int ssid)\n{\n\tconst struct snd_pci_quirk *p;\n\tconst struct snd_pci_quirk *list;\n\tu16 vendor_id, device_id;\n\n\tswitch (atc->chip_type) {\n\tcase ATC20K1:\n\t\tatc->chip_name = \"20K1\";\n\t\tlist = subsys_20k1_list;\n\t\tbreak;\n\tcase ATC20K2:\n\t\tatc->chip_name = \"20K2\";\n\t\tlist = subsys_20k2_list;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\tif (ssid) {\n\t\tvendor_id = ssid >> 16;\n\t\tdevice_id = ssid & 0xffff;\n\t} else {\n\t\tvendor_id = atc->pci->subsystem_vendor;\n\t\tdevice_id = atc->pci->subsystem_device;\n\t}\n\tp = snd_pci_quirk_lookup_id(vendor_id, device_id, list);\n\tif (p) {\n\t\tif (p->value < 0) {\n\t\t\tdev_err(atc->card->dev,\n\t\t\t\t\"Device %04x:%04x is on the denylist\\n\",\n\t\t\t\tvendor_id, device_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tatc->model = p->value;\n\t} else {\n\t\tif (atc->chip_type == ATC20K1)\n\t\t\tatc->model = CT20K1_UNKNOWN;\n\t\telse\n\t\t\tatc->model = CT20K2_UNKNOWN;\n\t}\n\tatc->model_name = ct_subsys_name[atc->model];\n\tdev_info(atc->card->dev, \"chip %s model %s (%04x:%04x) is found\\n\",\n\t\t   atc->chip_name, atc->model_name,\n\t\t   vendor_id, device_id);\n\treturn 0;\n}\n\nint ct_atc_create_alsa_devs(struct ct_atc *atc)\n{\n\tenum CTALSADEVS i;\n\tint err;\n\n\talsa_dev_funcs[MIXER].public_name = atc->chip_name;\n\n\tfor (i = 0; i < NUM_CTALSADEVS; i++) {\n\t\tif (!alsa_dev_funcs[i].create)\n\t\t\tcontinue;\n\n\t\terr = alsa_dev_funcs[i].create(atc, i,\n\t\t\t\talsa_dev_funcs[i].public_name);\n\t\tif (err) {\n\t\t\tdev_err(atc->card->dev,\n\t\t\t\t\"Creating alsa device %d failed!\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int atc_create_hw_devs(struct ct_atc *atc)\n{\n\tstruct hw *hw;\n\tstruct card_conf info = {0};\n\tint i, err;\n\n\terr = create_hw_obj(atc->pci, atc->chip_type, atc->model, &hw);\n\tif (err) {\n\t\tdev_err(atc->card->dev, \"Failed to create hw obj!!!\\n\");\n\t\treturn err;\n\t}\n\thw->card = atc->card;\n\tatc->hw = hw;\n\n\t \n\tinfo.rsr = atc->rsr;\n\tinfo.msr = atc->msr;\n\tinfo.vm_pgt_phys = atc_get_ptp_phys(atc, 0);\n\terr = hw->card_init(hw, &info);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < NUM_RSCTYP; i++) {\n\t\tif (!rsc_mgr_funcs[i].create)\n\t\t\tcontinue;\n\n\t\terr = rsc_mgr_funcs[i].create(atc->hw, &atc->rsc_mgrs[i]);\n\t\tif (err) {\n\t\t\tdev_err(atc->card->dev,\n\t\t\t\t\"Failed to create rsc_mgr %d!!!\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int atc_get_resources(struct ct_atc *atc)\n{\n\tstruct daio_desc da_desc = {0};\n\tstruct daio_mgr *daio_mgr;\n\tstruct src_desc src_dsc = {0};\n\tstruct src_mgr *src_mgr;\n\tstruct srcimp_desc srcimp_dsc = {0};\n\tstruct srcimp_mgr *srcimp_mgr;\n\tstruct sum_desc sum_dsc = {0};\n\tstruct sum_mgr *sum_mgr;\n\tint err, i, num_srcs, num_daios;\n\n\tnum_daios = ((atc->model == CTSB1270) ? 8 : 7);\n\tnum_srcs = ((atc->model == CTSB1270) ? 6 : 4);\n\n\tatc->daios = kcalloc(num_daios, sizeof(void *), GFP_KERNEL);\n\tif (!atc->daios)\n\t\treturn -ENOMEM;\n\n\tatc->srcs = kcalloc(num_srcs, sizeof(void *), GFP_KERNEL);\n\tif (!atc->srcs)\n\t\treturn -ENOMEM;\n\n\tatc->srcimps = kcalloc(num_srcs, sizeof(void *), GFP_KERNEL);\n\tif (!atc->srcimps)\n\t\treturn -ENOMEM;\n\n\tatc->pcm = kcalloc(2 * 4, sizeof(void *), GFP_KERNEL);\n\tif (!atc->pcm)\n\t\treturn -ENOMEM;\n\n\tdaio_mgr = (struct daio_mgr *)atc->rsc_mgrs[DAIO];\n\tda_desc.msr = atc->msr;\n\tfor (i = 0, atc->n_daio = 0; i < num_daios; i++) {\n\t\tda_desc.type = (atc->model != CTSB073X) ? i :\n\t\t\t     ((i == SPDIFIO) ? SPDIFI1 : i);\n\t\terr = daio_mgr->get_daio(daio_mgr, &da_desc,\n\t\t\t\t\t(struct daio **)&atc->daios[i]);\n\t\tif (err) {\n\t\t\tdev_err(atc->card->dev,\n\t\t\t\t\"Failed to get DAIO resource %d!!!\\n\",\n\t\t\t\ti);\n\t\t\treturn err;\n\t\t}\n\t\tatc->n_daio++;\n\t}\n\n\tsrc_mgr = atc->rsc_mgrs[SRC];\n\tsrc_dsc.multi = 1;\n\tsrc_dsc.msr = atc->msr;\n\tsrc_dsc.mode = ARCRW;\n\tfor (i = 0, atc->n_src = 0; i < num_srcs; i++) {\n\t\terr = src_mgr->get_src(src_mgr, &src_dsc,\n\t\t\t\t\t(struct src **)&atc->srcs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tatc->n_src++;\n\t}\n\n\tsrcimp_mgr = atc->rsc_mgrs[SRCIMP];\n\tsrcimp_dsc.msr = 8;\n\tfor (i = 0, atc->n_srcimp = 0; i < num_srcs; i++) {\n\t\terr = srcimp_mgr->get_srcimp(srcimp_mgr, &srcimp_dsc,\n\t\t\t\t\t(struct srcimp **)&atc->srcimps[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tatc->n_srcimp++;\n\t}\n\n\tsum_mgr = atc->rsc_mgrs[SUM];\n\tsum_dsc.msr = atc->msr;\n\tfor (i = 0, atc->n_pcm = 0; i < (2*4); i++) {\n\t\terr = sum_mgr->get_sum(sum_mgr, &sum_dsc,\n\t\t\t\t\t(struct sum **)&atc->pcm[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tatc->n_pcm++;\n\t}\n\n\treturn 0;\n}\n\nstatic void\natc_connect_dai(struct src_mgr *src_mgr, struct dai *dai,\n\t\tstruct src **srcs, struct srcimp **srcimps)\n{\n\tstruct rsc *rscs[2] = {NULL};\n\tstruct src *src;\n\tstruct srcimp *srcimp;\n\tint i = 0;\n\n\trscs[0] = &dai->daio.rscl;\n\trscs[1] = &dai->daio.rscr;\n\tfor (i = 0; i < 2; i++) {\n\t\tsrc = srcs[i];\n\t\tsrcimp = srcimps[i];\n\t\tsrcimp->ops->map(srcimp, src, rscs[i]);\n\t\tsrc_mgr->src_disable(src_mgr, src);\n\t}\n\n\tsrc_mgr->commit_write(src_mgr);  \n\n\tsrc = srcs[0];\n\tsrc->ops->set_pm(src, 1);\n\tfor (i = 0; i < 2; i++) {\n\t\tsrc = srcs[i];\n\t\tsrc->ops->set_state(src, SRC_STATE_RUN);\n\t\tsrc->ops->commit_write(src);\n\t\tsrc_mgr->src_enable_s(src_mgr, src);\n\t}\n\n\tdai->ops->set_srt_srcl(dai, &(srcs[0]->rsc));\n\tdai->ops->set_srt_srcr(dai, &(srcs[1]->rsc));\n\n\tdai->ops->set_enb_src(dai, 1);\n\tdai->ops->set_enb_srt(dai, 1);\n\tdai->ops->commit_write(dai);\n\n\tsrc_mgr->commit_write(src_mgr);  \n}\n\nstatic void atc_connect_resources(struct ct_atc *atc)\n{\n\tstruct dai *dai;\n\tstruct dao *dao;\n\tstruct src *src;\n\tstruct sum *sum;\n\tstruct ct_mixer *mixer;\n\tstruct rsc *rscs[2] = {NULL};\n\tint i, j;\n\n\tmixer = atc->mixer;\n\n\tfor (i = MIX_WAVE_FRONT, j = LINEO1; i <= MIX_SPDIF_OUT; i++, j++) {\n\t\tmixer->get_output_ports(mixer, i, &rscs[0], &rscs[1]);\n\t\tdao = container_of(atc->daios[j], struct dao, daio);\n\t\tdao->ops->set_left_input(dao, rscs[0]);\n\t\tdao->ops->set_right_input(dao, rscs[1]);\n\t}\n\n\tdai = container_of(atc->daios[LINEIM], struct dai, daio);\n\tatc_connect_dai(atc->rsc_mgrs[SRC], dai,\n\t\t\t(struct src **)&atc->srcs[2],\n\t\t\t(struct srcimp **)&atc->srcimps[2]);\n\tsrc = atc->srcs[2];\n\tmixer->set_input_left(mixer, MIX_LINE_IN, &src->rsc);\n\tsrc = atc->srcs[3];\n\tmixer->set_input_right(mixer, MIX_LINE_IN, &src->rsc);\n\n\tif (atc->model == CTSB1270) {\n\t\t \n\t\tdai = container_of(atc->daios[MIC], struct dai, daio);\n\t\tatc_connect_dai(atc->rsc_mgrs[SRC], dai,\n\t\t\t(struct src **)&atc->srcs[4],\n\t\t\t(struct srcimp **)&atc->srcimps[4]);\n\t\tsrc = atc->srcs[4];\n\t\tmixer->set_input_left(mixer, MIX_MIC_IN, &src->rsc);\n\t\tsrc = atc->srcs[5];\n\t\tmixer->set_input_right(mixer, MIX_MIC_IN, &src->rsc);\n\t}\n\n\tdai = container_of(atc->daios[SPDIFIO], struct dai, daio);\n\tatc_connect_dai(atc->rsc_mgrs[SRC], dai,\n\t\t\t(struct src **)&atc->srcs[0],\n\t\t\t(struct srcimp **)&atc->srcimps[0]);\n\n\tsrc = atc->srcs[0];\n\tmixer->set_input_left(mixer, MIX_SPDIF_IN, &src->rsc);\n\tsrc = atc->srcs[1];\n\tmixer->set_input_right(mixer, MIX_SPDIF_IN, &src->rsc);\n\n\tfor (i = MIX_PCMI_FRONT, j = 0; i <= MIX_PCMI_SURROUND; i++, j += 2) {\n\t\tsum = atc->pcm[j];\n\t\tmixer->set_input_left(mixer, i, &sum->rsc);\n\t\tsum = atc->pcm[j+1];\n\t\tmixer->set_input_right(mixer, i, &sum->rsc);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atc_suspend(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\n\tsnd_power_change_state(atc->card, SNDRV_CTL_POWER_D3hot);\n\n\tatc_release_resources(atc);\n\n\thw->suspend(hw);\n\n\treturn 0;\n}\n\nstatic int atc_hw_resume(struct ct_atc *atc)\n{\n\tstruct hw *hw = atc->hw;\n\tstruct card_conf info = {0};\n\n\t \n\tinfo.rsr = atc->rsr;\n\tinfo.msr = atc->msr;\n\tinfo.vm_pgt_phys = atc_get_ptp_phys(atc, 0);\n\treturn hw->resume(hw, &info);\n}\n\nstatic int atc_resources_resume(struct ct_atc *atc)\n{\n\tstruct ct_mixer *mixer;\n\tint err = 0;\n\n\t \n\terr = atc_get_resources(atc);\n\tif (err < 0) {\n\t\tatc_release_resources(atc);\n\t\treturn err;\n\t}\n\n\t \n\tatc_connect_resources(atc);\n\n\tmixer = atc->mixer;\n\tmixer->resume(mixer);\n\n\treturn 0;\n}\n\nstatic int atc_resume(struct ct_atc *atc)\n{\n\tint err = 0;\n\n\t \n\terr = atc_hw_resume(atc);\n\tif (err < 0) {\n\t\tdev_err(atc->card->dev,\n\t\t\t\"pci_enable_device failed, disabling device\\n\");\n\t\tsnd_card_disconnect(atc->card);\n\t\treturn err;\n\t}\n\n\terr = atc_resources_resume(atc);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_power_change_state(atc->card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct ct_atc atc_preset = {\n\t.map_audio_buffer = ct_map_audio_buffer,\n\t.unmap_audio_buffer = ct_unmap_audio_buffer,\n\t.pcm_playback_prepare = atc_pcm_playback_prepare,\n\t.pcm_release_resources = atc_pcm_release_resources,\n\t.pcm_playback_start = atc_pcm_playback_start,\n\t.pcm_playback_stop = atc_pcm_stop,\n\t.pcm_playback_position = atc_pcm_playback_position,\n\t.pcm_capture_prepare = atc_pcm_capture_prepare,\n\t.pcm_capture_start = atc_pcm_capture_start,\n\t.pcm_capture_stop = atc_pcm_stop,\n\t.pcm_capture_position = atc_pcm_capture_position,\n\t.spdif_passthru_playback_prepare = spdif_passthru_playback_prepare,\n\t.get_ptp_phys = atc_get_ptp_phys,\n\t.select_line_in = atc_select_line_in,\n\t.select_mic_in = atc_select_mic_in,\n\t.select_digit_io = atc_select_digit_io,\n\t.line_front_unmute = atc_line_front_unmute,\n\t.line_surround_unmute = atc_line_surround_unmute,\n\t.line_clfe_unmute = atc_line_clfe_unmute,\n\t.line_rear_unmute = atc_line_rear_unmute,\n\t.line_in_unmute = atc_line_in_unmute,\n\t.mic_unmute = atc_mic_unmute,\n\t.spdif_out_unmute = atc_spdif_out_unmute,\n\t.spdif_in_unmute = atc_spdif_in_unmute,\n\t.spdif_out_get_status = atc_spdif_out_get_status,\n\t.spdif_out_set_status = atc_spdif_out_set_status,\n\t.spdif_out_passthru = atc_spdif_out_passthru,\n\t.capabilities = atc_capabilities,\n\t.output_switch_get = atc_output_switch_get,\n\t.output_switch_put = atc_output_switch_put,\n\t.mic_source_switch_get = atc_mic_source_switch_get,\n\t.mic_source_switch_put = atc_mic_source_switch_put,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = atc_suspend,\n\t.resume = atc_resume,\n#endif\n};\n\n \n\nint ct_atc_create(struct snd_card *card, struct pci_dev *pci,\n\t\t  unsigned int rsr, unsigned int msr,\n\t\t  int chip_type, unsigned int ssid,\n\t\t  struct ct_atc **ratc)\n{\n\tstruct ct_atc *atc;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = atc_dev_free,\n\t};\n\tint err;\n\n\t*ratc = NULL;\n\n\tatc = kzalloc(sizeof(*atc), GFP_KERNEL);\n\tif (!atc)\n\t\treturn -ENOMEM;\n\n\t \n\t*atc = atc_preset;\n\n\tatc->card = card;\n\tatc->pci = pci;\n\tatc->rsr = rsr;\n\tatc->msr = msr;\n\tatc->chip_type = chip_type;\n\n\tmutex_init(&atc->atc_mutex);\n\n\t \n\terr = atc_identify_card(atc, ssid);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"ctatc: Card not recognised\\n\");\n\t\tgoto error1;\n\t}\n\n\t \n\terr = ct_vm_create(&atc->vm, pci);\n\tif (err < 0)\n\t\tgoto error1;\n\n\t \n\terr = atc_create_hw_devs(atc);\n\tif (err < 0)\n\t\tgoto error1;\n\n\terr = ct_mixer_create(atc, (struct ct_mixer **)&atc->mixer);\n\tif (err) {\n\t\tdev_err(card->dev, \"Failed to create mixer obj!!!\\n\");\n\t\tgoto error1;\n\t}\n\n\t \n\terr = atc_get_resources(atc);\n\tif (err < 0)\n\t\tgoto error1;\n\n\t \n\tatc_connect_resources(atc);\n\n\tatc->timer = ct_timer_new(atc);\n\tif (!atc->timer) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, atc, &ops);\n\tif (err < 0)\n\t\tgoto error1;\n\n\t*ratc = atc;\n\treturn 0;\n\nerror1:\n\tct_atc_destroy(atc);\n\tdev_err(card->dev, \"Something wrong!!!\\n\");\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}