{
  "module_name": "ctamixer.c",
  "hash_id": "1eec81048192049d3ce8f61c4006854c7b71624aa43e35dcf88399d430423b52",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctamixer.c",
  "human_readable_source": "\n \n\n#include \"ctamixer.h\"\n#include \"cthardware.h\"\n#include <linux/slab.h>\n\n#define AMIXER_RESOURCE_NUM\t256\n#define SUM_RESOURCE_NUM\t256\n\n#define AMIXER_Y_IMMEDIATE\t1\n\n#define BLANK_SLOT\t\t4094\n\nstatic void amixer_master(struct rsc *rsc)\n{\n\trsc->conj = 0;\n\trsc->idx = container_of(rsc, struct amixer, rsc)->idx[0];\n}\n\nstatic void amixer_next_conj(struct rsc *rsc)\n{\n\trsc->conj++;\n}\n\nstatic int amixer_index(const struct rsc *rsc)\n{\n\treturn container_of(rsc, struct amixer, rsc)->idx[rsc->conj];\n}\n\nstatic int amixer_output_slot(const struct rsc *rsc)\n{\n\treturn (amixer_index(rsc) << 4) + 0x4;\n}\n\nstatic const struct rsc_ops amixer_basic_rsc_ops = {\n\t.master\t\t= amixer_master,\n\t.next_conj\t= amixer_next_conj,\n\t.index\t\t= amixer_index,\n\t.output_slot\t= amixer_output_slot,\n};\n\nstatic int amixer_set_input(struct amixer *amixer, struct rsc *rsc)\n{\n\tstruct hw *hw;\n\n\thw = amixer->rsc.hw;\n\thw->amixer_set_mode(amixer->rsc.ctrl_blk, AMIXER_Y_IMMEDIATE);\n\tamixer->input = rsc;\n\tif (!rsc)\n\t\thw->amixer_set_x(amixer->rsc.ctrl_blk, BLANK_SLOT);\n\telse\n\t\thw->amixer_set_x(amixer->rsc.ctrl_blk,\n\t\t\t\t\trsc->ops->output_slot(rsc));\n\n\treturn 0;\n}\n\n \nstatic int amixer_set_y(struct amixer *amixer, unsigned int y)\n{\n\tstruct hw *hw;\n\n\thw = amixer->rsc.hw;\n\thw->amixer_set_y(amixer->rsc.ctrl_blk, y);\n\n\treturn 0;\n}\n\nstatic int amixer_set_invalid_squash(struct amixer *amixer, unsigned int iv)\n{\n\tstruct hw *hw;\n\n\thw = amixer->rsc.hw;\n\thw->amixer_set_iv(amixer->rsc.ctrl_blk, iv);\n\n\treturn 0;\n}\n\nstatic int amixer_set_sum(struct amixer *amixer, struct sum *sum)\n{\n\tstruct hw *hw;\n\n\thw = amixer->rsc.hw;\n\tamixer->sum = sum;\n\tif (!sum) {\n\t\thw->amixer_set_se(amixer->rsc.ctrl_blk, 0);\n\t} else {\n\t\thw->amixer_set_se(amixer->rsc.ctrl_blk, 1);\n\t\thw->amixer_set_sadr(amixer->rsc.ctrl_blk,\n\t\t\t\t\tsum->rsc.ops->index(&sum->rsc));\n\t}\n\n\treturn 0;\n}\n\nstatic int amixer_commit_write(struct amixer *amixer)\n{\n\tstruct hw *hw;\n\tunsigned int index;\n\tint i;\n\tstruct rsc *input;\n\tstruct sum *sum;\n\n\thw = amixer->rsc.hw;\n\tinput = amixer->input;\n\tsum = amixer->sum;\n\n\t \n\tamixer->rsc.ops->master(&amixer->rsc);\n\tif (input)\n\t\tinput->ops->master(input);\n\n\tif (sum)\n\t\tsum->rsc.ops->master(&sum->rsc);\n\n\tfor (i = 0; i < amixer->rsc.msr; i++) {\n\t\thw->amixer_set_dirty_all(amixer->rsc.ctrl_blk);\n\t\tif (input) {\n\t\t\thw->amixer_set_x(amixer->rsc.ctrl_blk,\n\t\t\t\t\t\tinput->ops->output_slot(input));\n\t\t\tinput->ops->next_conj(input);\n\t\t}\n\t\tif (sum) {\n\t\t\thw->amixer_set_sadr(amixer->rsc.ctrl_blk,\n\t\t\t\t\t\tsum->rsc.ops->index(&sum->rsc));\n\t\t\tsum->rsc.ops->next_conj(&sum->rsc);\n\t\t}\n\t\tindex = amixer->rsc.ops->output_slot(&amixer->rsc);\n\t\thw->amixer_commit_write(hw, index, amixer->rsc.ctrl_blk);\n\t\tamixer->rsc.ops->next_conj(&amixer->rsc);\n\t}\n\tamixer->rsc.ops->master(&amixer->rsc);\n\tif (input)\n\t\tinput->ops->master(input);\n\n\tif (sum)\n\t\tsum->rsc.ops->master(&sum->rsc);\n\n\treturn 0;\n}\n\nstatic int amixer_commit_raw_write(struct amixer *amixer)\n{\n\tstruct hw *hw;\n\tunsigned int index;\n\n\thw = amixer->rsc.hw;\n\tindex = amixer->rsc.ops->output_slot(&amixer->rsc);\n\thw->amixer_commit_write(hw, index, amixer->rsc.ctrl_blk);\n\n\treturn 0;\n}\n\nstatic int amixer_get_y(struct amixer *amixer)\n{\n\tstruct hw *hw;\n\n\thw = amixer->rsc.hw;\n\treturn hw->amixer_get_y(amixer->rsc.ctrl_blk);\n}\n\nstatic int amixer_setup(struct amixer *amixer, struct rsc *input,\n\t\t\tunsigned int scale, struct sum *sum)\n{\n\tamixer_set_input(amixer, input);\n\tamixer_set_y(amixer, scale);\n\tamixer_set_sum(amixer, sum);\n\tamixer_commit_write(amixer);\n\treturn 0;\n}\n\nstatic const struct amixer_rsc_ops amixer_ops = {\n\t.set_input\t\t= amixer_set_input,\n\t.set_invalid_squash\t= amixer_set_invalid_squash,\n\t.set_scale\t\t= amixer_set_y,\n\t.set_sum\t\t= amixer_set_sum,\n\t.commit_write\t\t= amixer_commit_write,\n\t.commit_raw_write\t= amixer_commit_raw_write,\n\t.setup\t\t\t= amixer_setup,\n\t.get_scale\t\t= amixer_get_y,\n};\n\nstatic int amixer_rsc_init(struct amixer *amixer,\n\t\t\t   const struct amixer_desc *desc,\n\t\t\t   struct amixer_mgr *mgr)\n{\n\tint err;\n\n\terr = rsc_init(&amixer->rsc, amixer->idx[0],\n\t\t\tAMIXER, desc->msr, mgr->mgr.hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\tamixer->rsc.ops = &amixer_basic_rsc_ops;\n\tamixer->ops = &amixer_ops;\n\tamixer->input = NULL;\n\tamixer->sum = NULL;\n\n\tamixer_setup(amixer, NULL, 0, NULL);\n\n\treturn 0;\n}\n\nstatic int amixer_rsc_uninit(struct amixer *amixer)\n{\n\tamixer_setup(amixer, NULL, 0, NULL);\n\trsc_uninit(&amixer->rsc);\n\tamixer->ops = NULL;\n\tamixer->input = NULL;\n\tamixer->sum = NULL;\n\treturn 0;\n}\n\nstatic int get_amixer_rsc(struct amixer_mgr *mgr,\n\t\t\t  const struct amixer_desc *desc,\n\t\t\t  struct amixer **ramixer)\n{\n\tint err, i;\n\tunsigned int idx;\n\tstruct amixer *amixer;\n\tunsigned long flags;\n\n\t*ramixer = NULL;\n\n\t \n\tamixer = kzalloc(sizeof(*amixer), GFP_KERNEL);\n\tif (!amixer)\n\t\treturn -ENOMEM;\n\n\t \n\terr = 0;\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < desc->msr; i++) {\n\t\terr = mgr_get_resource(&mgr->mgr, 1, &idx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tamixer->idx[i] = idx;\n\t}\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tif (err) {\n\t\tdev_err(mgr->card->dev,\n\t\t\t\"Can't meet AMIXER resource request!\\n\");\n\t\tgoto error;\n\t}\n\n\terr = amixer_rsc_init(amixer, desc, mgr);\n\tif (err)\n\t\tgoto error;\n\n\t*ramixer = amixer;\n\n\treturn 0;\n\nerror:\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i--; i >= 0; i--)\n\t\tmgr_put_resource(&mgr->mgr, 1, amixer->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tkfree(amixer);\n\treturn err;\n}\n\nstatic int put_amixer_rsc(struct amixer_mgr *mgr, struct amixer *amixer)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < amixer->rsc.msr; i++)\n\t\tmgr_put_resource(&mgr->mgr, 1, amixer->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tamixer_rsc_uninit(amixer);\n\tkfree(amixer);\n\n\treturn 0;\n}\n\nint amixer_mgr_create(struct hw *hw, struct amixer_mgr **ramixer_mgr)\n{\n\tint err;\n\tstruct amixer_mgr *amixer_mgr;\n\n\t*ramixer_mgr = NULL;\n\tamixer_mgr = kzalloc(sizeof(*amixer_mgr), GFP_KERNEL);\n\tif (!amixer_mgr)\n\t\treturn -ENOMEM;\n\n\terr = rsc_mgr_init(&amixer_mgr->mgr, AMIXER, AMIXER_RESOURCE_NUM, hw);\n\tif (err)\n\t\tgoto error;\n\n\tspin_lock_init(&amixer_mgr->mgr_lock);\n\n\tamixer_mgr->get_amixer = get_amixer_rsc;\n\tamixer_mgr->put_amixer = put_amixer_rsc;\n\tamixer_mgr->card = hw->card;\n\n\t*ramixer_mgr = amixer_mgr;\n\n\treturn 0;\n\nerror:\n\tkfree(amixer_mgr);\n\treturn err;\n}\n\nint amixer_mgr_destroy(struct amixer_mgr *amixer_mgr)\n{\n\trsc_mgr_uninit(&amixer_mgr->mgr);\n\tkfree(amixer_mgr);\n\treturn 0;\n}\n\n \n\nstatic void sum_master(struct rsc *rsc)\n{\n\trsc->conj = 0;\n\trsc->idx = container_of(rsc, struct sum, rsc)->idx[0];\n}\n\nstatic void sum_next_conj(struct rsc *rsc)\n{\n\trsc->conj++;\n}\n\nstatic int sum_index(const struct rsc *rsc)\n{\n\treturn container_of(rsc, struct sum, rsc)->idx[rsc->conj];\n}\n\nstatic int sum_output_slot(const struct rsc *rsc)\n{\n\treturn (sum_index(rsc) << 4) + 0xc;\n}\n\nstatic const struct rsc_ops sum_basic_rsc_ops = {\n\t.master\t\t= sum_master,\n\t.next_conj\t= sum_next_conj,\n\t.index\t\t= sum_index,\n\t.output_slot\t= sum_output_slot,\n};\n\nstatic int sum_rsc_init(struct sum *sum,\n\t\t\tconst struct sum_desc *desc,\n\t\t\tstruct sum_mgr *mgr)\n{\n\tint err;\n\n\terr = rsc_init(&sum->rsc, sum->idx[0], SUM, desc->msr, mgr->mgr.hw);\n\tif (err)\n\t\treturn err;\n\n\tsum->rsc.ops = &sum_basic_rsc_ops;\n\n\treturn 0;\n}\n\nstatic int sum_rsc_uninit(struct sum *sum)\n{\n\trsc_uninit(&sum->rsc);\n\treturn 0;\n}\n\nstatic int get_sum_rsc(struct sum_mgr *mgr,\n\t\t       const struct sum_desc *desc,\n\t\t       struct sum **rsum)\n{\n\tint err, i;\n\tunsigned int idx;\n\tstruct sum *sum;\n\tunsigned long flags;\n\n\t*rsum = NULL;\n\n\t \n\tsum = kzalloc(sizeof(*sum), GFP_KERNEL);\n\tif (!sum)\n\t\treturn -ENOMEM;\n\n\t \n\terr = 0;\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < desc->msr; i++) {\n\t\terr = mgr_get_resource(&mgr->mgr, 1, &idx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tsum->idx[i] = idx;\n\t}\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tif (err) {\n\t\tdev_err(mgr->card->dev,\n\t\t\t\"Can't meet SUM resource request!\\n\");\n\t\tgoto error;\n\t}\n\n\terr = sum_rsc_init(sum, desc, mgr);\n\tif (err)\n\t\tgoto error;\n\n\t*rsum = sum;\n\n\treturn 0;\n\nerror:\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i--; i >= 0; i--)\n\t\tmgr_put_resource(&mgr->mgr, 1, sum->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tkfree(sum);\n\treturn err;\n}\n\nstatic int put_sum_rsc(struct sum_mgr *mgr, struct sum *sum)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mgr->mgr_lock, flags);\n\tfor (i = 0; i < sum->rsc.msr; i++)\n\t\tmgr_put_resource(&mgr->mgr, 1, sum->idx[i]);\n\n\tspin_unlock_irqrestore(&mgr->mgr_lock, flags);\n\tsum_rsc_uninit(sum);\n\tkfree(sum);\n\n\treturn 0;\n}\n\nint sum_mgr_create(struct hw *hw, struct sum_mgr **rsum_mgr)\n{\n\tint err;\n\tstruct sum_mgr *sum_mgr;\n\n\t*rsum_mgr = NULL;\n\tsum_mgr = kzalloc(sizeof(*sum_mgr), GFP_KERNEL);\n\tif (!sum_mgr)\n\t\treturn -ENOMEM;\n\n\terr = rsc_mgr_init(&sum_mgr->mgr, SUM, SUM_RESOURCE_NUM, hw);\n\tif (err)\n\t\tgoto error;\n\n\tspin_lock_init(&sum_mgr->mgr_lock);\n\n\tsum_mgr->get_sum = get_sum_rsc;\n\tsum_mgr->put_sum = put_sum_rsc;\n\tsum_mgr->card = hw->card;\n\n\t*rsum_mgr = sum_mgr;\n\n\treturn 0;\n\nerror:\n\tkfree(sum_mgr);\n\treturn err;\n}\n\nint sum_mgr_destroy(struct sum_mgr *sum_mgr)\n{\n\trsc_mgr_uninit(&sum_mgr->mgr);\n\tkfree(sum_mgr);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}