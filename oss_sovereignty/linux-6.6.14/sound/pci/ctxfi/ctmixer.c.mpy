{
  "module_name": "ctmixer.c",
  "hash_id": "387e6c5789a385bf2e089b803011a8e44acb5e0e306c9264b3ee25b1c03b4573",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctmixer.c",
  "human_readable_source": "\n \n\n\n#include \"ctmixer.h\"\n#include \"ctamixer.h\"\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/asoundef.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n\nenum CT_SUM_CTL {\n\tSUM_IN_F,\n\tSUM_IN_R,\n\tSUM_IN_C,\n\tSUM_IN_S,\n\tSUM_IN_F_C,\n\n\tNUM_CT_SUMS\n};\n\nenum CT_AMIXER_CTL {\n\t \n\tAMIXER_MASTER_F,\n\tAMIXER_MASTER_R,\n\tAMIXER_MASTER_C,\n\tAMIXER_MASTER_S,\n\tAMIXER_PCM_F,\n\tAMIXER_PCM_R,\n\tAMIXER_PCM_C,\n\tAMIXER_PCM_S,\n\tAMIXER_SPDIFI,\n\tAMIXER_LINEIN,\n\tAMIXER_MIC,\n\tAMIXER_SPDIFO,\n\tAMIXER_WAVE_F,\n\tAMIXER_WAVE_R,\n\tAMIXER_WAVE_C,\n\tAMIXER_WAVE_S,\n\tAMIXER_MASTER_F_C,\n\tAMIXER_PCM_F_C,\n\tAMIXER_SPDIFI_C,\n\tAMIXER_LINEIN_C,\n\tAMIXER_MIC_C,\n\n\t \n\tNUM_CT_AMIXERS\n};\n\nenum CTALSA_MIXER_CTL {\n\t \n\tMIXER_MASTER_P,\n\tMIXER_PCM_P,\n\tMIXER_LINEIN_P,\n\tMIXER_MIC_P,\n\tMIXER_SPDIFI_P,\n\tMIXER_SPDIFO_P,\n\tMIXER_WAVEF_P,\n\tMIXER_WAVER_P,\n\tMIXER_WAVEC_P,\n\tMIXER_WAVES_P,\n\tMIXER_MASTER_C,\n\tMIXER_PCM_C,\n\tMIXER_LINEIN_C,\n\tMIXER_MIC_C,\n\tMIXER_SPDIFI_C,\n\n\t \n\tMIXER_PCM_C_S,\n\tMIXER_LINEIN_C_S,\n\tMIXER_MIC_C_S,\n\tMIXER_SPDIFI_C_S,\n\tMIXER_SPDIFO_P_S,\n\tMIXER_WAVEF_P_S,\n\tMIXER_WAVER_P_S,\n\tMIXER_WAVEC_P_S,\n\tMIXER_WAVES_P_S,\n\tMIXER_DIGITAL_IO_S,\n\tMIXER_IEC958_MASK,\n\tMIXER_IEC958_DEFAULT,\n\tMIXER_IEC958_STREAM,\n\n\t \n\tNUM_CTALSA_MIXERS\n};\n\n#define VOL_MIXER_START\t\tMIXER_MASTER_P\n#define VOL_MIXER_END\t\tMIXER_SPDIFI_C\n#define VOL_MIXER_NUM\t\t(VOL_MIXER_END - VOL_MIXER_START + 1)\n#define SWH_MIXER_START\t\tMIXER_PCM_C_S\n#define SWH_MIXER_END\t\tMIXER_DIGITAL_IO_S\n#define SWH_CAPTURE_START\tMIXER_PCM_C_S\n#define SWH_CAPTURE_END\t\tMIXER_SPDIFI_C_S\n\n#define CHN_NUM\t\t2\n\nstruct ct_kcontrol_init {\n\tunsigned char ctl;\n\tchar *name;\n};\n\nstatic struct ct_kcontrol_init\nct_kcontrol_init_table[NUM_CTALSA_MIXERS] = {\n\t[MIXER_MASTER_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Master Playback Volume\",\n\t},\n\t[MIXER_MASTER_C] = {\n\t\t.ctl = 1,\n\t\t.name = \"Master Capture Volume\",\n\t},\n\t[MIXER_PCM_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"PCM Playback Volume\",\n\t},\n\t[MIXER_PCM_C] = {\n\t\t.ctl = 1,\n\t\t.name = \"PCM Capture Volume\",\n\t},\n\t[MIXER_LINEIN_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Line Playback Volume\",\n\t},\n\t[MIXER_LINEIN_C] = {\n\t\t.ctl = 1,\n\t\t.name = \"Line Capture Volume\",\n\t},\n\t[MIXER_MIC_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Mic Playback Volume\",\n\t},\n\t[MIXER_MIC_C] = {\n\t\t.ctl = 1,\n\t\t.name = \"Mic Capture Volume\",\n\t},\n\t[MIXER_SPDIFI_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"IEC958 Playback Volume\",\n\t},\n\t[MIXER_SPDIFI_C] = {\n\t\t.ctl = 1,\n\t\t.name = \"IEC958 Capture Volume\",\n\t},\n\t[MIXER_SPDIFO_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Digital Playback Volume\",\n\t},\n\t[MIXER_WAVEF_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Front Playback Volume\",\n\t},\n\t[MIXER_WAVES_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Side Playback Volume\",\n\t},\n\t[MIXER_WAVEC_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Center/LFE Playback Volume\",\n\t},\n\t[MIXER_WAVER_P] = {\n\t\t.ctl = 1,\n\t\t.name = \"Surround Playback Volume\",\n\t},\n\t[MIXER_PCM_C_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"PCM Capture Switch\",\n\t},\n\t[MIXER_LINEIN_C_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Line Capture Switch\",\n\t},\n\t[MIXER_MIC_C_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Mic Capture Switch\",\n\t},\n\t[MIXER_SPDIFI_C_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"IEC958 Capture Switch\",\n\t},\n\t[MIXER_SPDIFO_P_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Digital Playback Switch\",\n\t},\n\t[MIXER_WAVEF_P_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Front Playback Switch\",\n\t},\n\t[MIXER_WAVES_P_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Side Playback Switch\",\n\t},\n\t[MIXER_WAVEC_P_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Center/LFE Playback Switch\",\n\t},\n\t[MIXER_WAVER_P_S] = {\n\t\t.ctl = 1,\n\t\t.name = \"Surround Playback Switch\",\n\t},\n\t[MIXER_DIGITAL_IO_S] = {\n\t\t.ctl = 0,\n\t\t.name = \"Digit-IO Playback Switch\",\n\t},\n};\n\nstatic void\nct_mixer_recording_select(struct ct_mixer *mixer, enum CT_AMIXER_CTL type);\n\nstatic void\nct_mixer_recording_unselect(struct ct_mixer *mixer, enum CT_AMIXER_CTL type);\n\n \n \nstatic struct snd_kcontrol *kctls[2] = {NULL};\n\nstatic enum CT_AMIXER_CTL get_amixer_index(enum CTALSA_MIXER_CTL alsa_index)\n{\n\tswitch (alsa_index) {\n\tcase MIXER_MASTER_P:\treturn AMIXER_MASTER_F;\n\tcase MIXER_MASTER_C:\treturn AMIXER_MASTER_F_C;\n\tcase MIXER_PCM_P:\treturn AMIXER_PCM_F;\n\tcase MIXER_PCM_C:\n\tcase MIXER_PCM_C_S:\treturn AMIXER_PCM_F_C;\n\tcase MIXER_LINEIN_P:\treturn AMIXER_LINEIN;\n\tcase MIXER_LINEIN_C:\n\tcase MIXER_LINEIN_C_S:\treturn AMIXER_LINEIN_C;\n\tcase MIXER_MIC_P:\treturn AMIXER_MIC;\n\tcase MIXER_MIC_C:\n\tcase MIXER_MIC_C_S:\treturn AMIXER_MIC_C;\n\tcase MIXER_SPDIFI_P:\treturn AMIXER_SPDIFI;\n\tcase MIXER_SPDIFI_C:\n\tcase MIXER_SPDIFI_C_S:\treturn AMIXER_SPDIFI_C;\n\tcase MIXER_SPDIFO_P:\treturn AMIXER_SPDIFO;\n\tcase MIXER_WAVEF_P:\treturn AMIXER_WAVE_F;\n\tcase MIXER_WAVES_P:\treturn AMIXER_WAVE_S;\n\tcase MIXER_WAVEC_P:\treturn AMIXER_WAVE_C;\n\tcase MIXER_WAVER_P:\treturn AMIXER_WAVE_R;\n\tdefault:\t\treturn NUM_CT_AMIXERS;\n\t}\n}\n\nstatic enum CT_AMIXER_CTL get_recording_amixer(enum CT_AMIXER_CTL index)\n{\n\tswitch (index) {\n\tcase AMIXER_MASTER_F:\treturn AMIXER_MASTER_F_C;\n\tcase AMIXER_PCM_F:\treturn AMIXER_PCM_F_C;\n\tcase AMIXER_SPDIFI:\treturn AMIXER_SPDIFI_C;\n\tcase AMIXER_LINEIN:\treturn AMIXER_LINEIN_C;\n\tcase AMIXER_MIC:\treturn AMIXER_MIC_C;\n\tdefault:\t\treturn NUM_CT_AMIXERS;\n\t}\n}\n\nstatic unsigned char\nget_switch_state(struct ct_mixer *mixer, enum CTALSA_MIXER_CTL type)\n{\n\treturn (mixer->switch_state & (0x1 << (type - SWH_MIXER_START)))\n\t\t? 1 : 0;\n}\n\nstatic void\nset_switch_state(struct ct_mixer *mixer,\n\t\t enum CTALSA_MIXER_CTL type, unsigned char state)\n{\n\tif (state)\n\t\tmixer->switch_state |= (0x1 << (type - SWH_MIXER_START));\n\telse\n\t\tmixer->switch_state &= ~(0x1 << (type - SWH_MIXER_START));\n}\n\n#if 0  \n \nstatic unsigned int uint16_to_float14(unsigned int x)\n{\n\tunsigned int i;\n\n\tif (x < 17)\n\t\treturn 0;\n\n\tx *= 2031;\n\tx /= 65535;\n\tx += 16;\n\n\t \n\tfor (i = 0; !(x & 0x400); i++)\n\t\tx <<= 1;\n\n\tx = (((7 - i) & 0x7) << 10) | (x & 0x3ff);\n\n\treturn x;\n}\n\nstatic unsigned int float14_to_uint16(unsigned int x)\n{\n\tunsigned int e;\n\n\tif (!x)\n\t\treturn x;\n\n\te = (x >> 10) & 0x7;\n\tx &= 0x3ff;\n\tx += 1024;\n\tx >>= (7 - e);\n\tx -= 16;\n\tx *= 65535;\n\tx /= 2031;\n\n\treturn x;\n}\n#endif  \n\n#define VOL_SCALE\t0x1c\n#define VOL_MAX\t\t0x100\n\nstatic const DECLARE_TLV_DB_SCALE(ct_vol_db_scale, -6400, 25, 1);\n\nstatic int ct_alsa_mix_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = VOL_MAX;\n\n\treturn 0;\n}\n\nstatic int ct_alsa_mix_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tenum CT_AMIXER_CTL type = get_amixer_index(kcontrol->private_value);\n\tstruct amixer *amixer;\n\tint i, val;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tamixer = ((struct ct_mixer *)atc->mixer)->\n\t\t\t\t\t\tamixers[type*CHN_NUM+i];\n\t\tval = amixer->ops->get_scale(amixer) / VOL_SCALE;\n\t\tif (val < 0)\n\t\t\tval = 0;\n\t\telse if (val > VOL_MAX)\n\t\t\tval = VOL_MAX;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\n\treturn 0;\n}\n\nstatic int ct_alsa_mix_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tstruct ct_mixer *mixer = atc->mixer;\n\tenum CT_AMIXER_CTL type = get_amixer_index(kcontrol->private_value);\n\tstruct amixer *amixer;\n\tint i, j, val, oval, change = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tval = ucontrol->value.integer.value[i];\n\t\tif (val < 0)\n\t\t\tval = 0;\n\t\telse if (val > VOL_MAX)\n\t\t\tval = VOL_MAX;\n\t\tval *= VOL_SCALE;\n\t\tamixer = mixer->amixers[type*CHN_NUM+i];\n\t\toval = amixer->ops->get_scale(amixer);\n\t\tif (val != oval) {\n\t\t\tamixer->ops->set_scale(amixer, val);\n\t\t\tamixer->ops->commit_write(amixer);\n\t\t\tchange = 1;\n\t\t\t \n\t\t\tif (AMIXER_MASTER_F == type || AMIXER_PCM_F == type) {\n\t\t\t\tfor (j = 1; j < 4; j++) {\n\t\t\t\t\tamixer = mixer->\n\t\t\t\t\t\tamixers[(type+j)*CHN_NUM+i];\n\t\t\t\t\tamixer->ops->set_scale(amixer, val);\n\t\t\t\t\tamixer->ops->commit_write(amixer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic struct snd_kcontrol_new vol_ctl = {\n\t.access\t\t= SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info\t\t= ct_alsa_mix_volume_info,\n\t.get\t\t= ct_alsa_mix_volume_get,\n\t.put\t\t= ct_alsa_mix_volume_put,\n\t.tlv\t\t= { .p =  ct_vol_db_scale },\n};\n\nstatic int output_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[3] = {\n\t  \"FP Headphones\", \"Headphones\", \"Speakers\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 3, names);\n}\n\nstatic int output_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = atc->output_switch_get(atc);\n\treturn 0;\n}\n\nstatic int output_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\treturn -EINVAL;\n\treturn atc->output_switch_put(atc, ucontrol->value.enumerated.item[0]);\n}\n\nstatic struct snd_kcontrol_new output_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Analog Output Playback Enum\",\n\t.info = output_switch_info,\n\t.get = output_switch_get,\n\t.put = output_switch_put,\n};\n\nstatic int mic_source_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[3] = {\n\t  \"Mic\", \"FP Mic\", \"Aux\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 3, names);\n}\n\nstatic int mic_source_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = atc->mic_source_switch_get(atc);\n\treturn 0;\n}\n\nstatic int mic_source_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\treturn -EINVAL;\n\treturn atc->mic_source_switch_put(atc,\n\t\t\t\t\tucontrol->value.enumerated.item[0]);\n}\n\nstatic struct snd_kcontrol_new mic_source_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Mic Source Capture Enum\",\n\t.info = mic_source_switch_info,\n\t.get = mic_source_switch_get,\n\t.put = mic_source_switch_put,\n};\n\nstatic void\ndo_line_mic_switch(struct ct_atc *atc, enum CTALSA_MIXER_CTL type)\n{\n\n\tif (MIXER_LINEIN_C_S == type) {\n\t\tatc->select_line_in(atc);\n\t\tset_switch_state(atc->mixer, MIXER_MIC_C_S, 0);\n\t\tsnd_ctl_notify(atc->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t\t\t&kctls[1]->id);\n\t} else if (MIXER_MIC_C_S == type) {\n\t\tatc->select_mic_in(atc);\n\t\tset_switch_state(atc->mixer, MIXER_LINEIN_C_S, 0);\n\t\tsnd_ctl_notify(atc->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t\t\t&kctls[0]->id);\n\t}\n}\n\nstatic void\ndo_digit_io_switch(struct ct_atc *atc, int state)\n{\n\tstruct ct_mixer *mixer = atc->mixer;\n\n\tif (state) {\n\t\tatc->select_digit_io(atc);\n\t\tatc->spdif_out_unmute(atc,\n\t\t\t\tget_switch_state(mixer, MIXER_SPDIFO_P_S));\n\t\tatc->spdif_in_unmute(atc, 1);\n\t\tatc->line_in_unmute(atc, 0);\n\t\treturn;\n\t}\n\n\tif (get_switch_state(mixer, MIXER_LINEIN_C_S))\n\t\tatc->select_line_in(atc);\n\telse if (get_switch_state(mixer, MIXER_MIC_C_S))\n\t\tatc->select_mic_in(atc);\n\n\tatc->spdif_out_unmute(atc, 0);\n\tatc->spdif_in_unmute(atc, 0);\n\tatc->line_in_unmute(atc, 1);\n\treturn;\n}\n\nstatic void do_switch(struct ct_atc *atc, enum CTALSA_MIXER_CTL type, int state)\n{\n\tstruct ct_mixer *mixer = atc->mixer;\n\tstruct capabilities cap = atc->capabilities(atc);\n\n\t \n\tif ((SWH_CAPTURE_START <= type) && (SWH_CAPTURE_END >= type)) {\n\t\tif (state) {\n\t\t\tct_mixer_recording_select(mixer,\n\t\t\t\t\t\t  get_amixer_index(type));\n\t\t} else {\n\t\t\tct_mixer_recording_unselect(mixer,\n\t\t\t\t\t\t    get_amixer_index(type));\n\t\t}\n\t}\n\t \n\tif (!cap.dedicated_mic &&\n\t    (MIXER_LINEIN_C_S == type || MIXER_MIC_C_S == type)) {\n\t\tif (state)\n\t\t\tdo_line_mic_switch(atc, type);\n\t\tatc->line_in_unmute(atc, state);\n\t} else if (cap.dedicated_mic && (MIXER_LINEIN_C_S == type))\n\t\tatc->line_in_unmute(atc, state);\n\telse if (cap.dedicated_mic && (MIXER_MIC_C_S == type))\n\t\tatc->mic_unmute(atc, state);\n\telse if (MIXER_SPDIFI_C_S == type)\n\t\tatc->spdif_in_unmute(atc, state);\n\telse if (MIXER_WAVEF_P_S == type)\n\t\tatc->line_front_unmute(atc, state);\n\telse if (MIXER_WAVES_P_S == type)\n\t\tatc->line_surround_unmute(atc, state);\n\telse if (MIXER_WAVEC_P_S == type)\n\t\tatc->line_clfe_unmute(atc, state);\n\telse if (MIXER_WAVER_P_S == type)\n\t\tatc->line_rear_unmute(atc, state);\n\telse if (MIXER_SPDIFO_P_S == type)\n\t\tatc->spdif_out_unmute(atc, state);\n\telse if (MIXER_DIGITAL_IO_S == type)\n\t\tdo_digit_io_switch(atc, state);\n\n\treturn;\n}\n\nstatic int ct_alsa_mix_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int ct_alsa_mix_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_mixer *mixer =\n\t\t((struct ct_atc *)snd_kcontrol_chip(kcontrol))->mixer;\n\tenum CTALSA_MIXER_CTL type = kcontrol->private_value;\n\n\tucontrol->value.integer.value[0] = get_switch_state(mixer, type);\n\treturn 0;\n}\n\nstatic int ct_alsa_mix_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tstruct ct_mixer *mixer = atc->mixer;\n\tenum CTALSA_MIXER_CTL type = kcontrol->private_value;\n\tint state;\n\n\tstate = ucontrol->value.integer.value[0];\n\tif (get_switch_state(mixer, type) == state)\n\t\treturn 0;\n\n\tset_switch_state(mixer, type, state);\n\tdo_switch(atc, type, state);\n\n\treturn 1;\n}\n\nstatic struct snd_kcontrol_new swh_ctl = {\n\t.access\t\t= SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info\t\t= ct_alsa_mix_switch_info,\n\t.get\t\t= ct_alsa_mix_switch_get,\n\t.put\t\t= ct_alsa_mix_switch_put\n};\n\nstatic int ct_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int ct_spdif_get_mask(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int ct_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tunsigned int status;\n\n\tatc->spdif_out_get_status(atc, &status);\n\n\tif (status == 0)\n\t\tstatus = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\n\tucontrol->value.iec958.status[0] = (status >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (status >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (status >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (status >> 24) & 0xff;\n\n\treturn 0;\n}\n\nstatic int ct_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int status, old_status;\n\n\tstatus = (ucontrol->value.iec958.status[0] << 0) |\n\t\t (ucontrol->value.iec958.status[1] << 8) |\n\t\t (ucontrol->value.iec958.status[2] << 16) |\n\t\t (ucontrol->value.iec958.status[3] << 24);\n\n\tatc->spdif_out_get_status(atc, &old_status);\n\tchange = (old_status != status);\n\tif (change)\n\t\tatc->spdif_out_set_status(atc, status);\n\n\treturn change;\n}\n\nstatic struct snd_kcontrol_new iec958_mask_ctl = {\n\t.access\t\t= SNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name\t\t= SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, MASK),\n\t.count\t\t= 1,\n\t.info\t\t= ct_spdif_info,\n\t.get\t\t= ct_spdif_get_mask,\n\t.private_value\t= MIXER_IEC958_MASK\n};\n\nstatic struct snd_kcontrol_new iec958_default_ctl = {\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name\t\t= SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t.count\t\t= 1,\n\t.info\t\t= ct_spdif_info,\n\t.get\t\t= ct_spdif_get,\n\t.put\t\t= ct_spdif_put,\n\t.private_value\t= MIXER_IEC958_DEFAULT\n};\n\nstatic struct snd_kcontrol_new iec958_ctl = {\n\t.access\t\t= SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface\t\t= SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name\t\t= SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PCM_STREAM),\n\t.count\t\t= 1,\n\t.info\t\t= ct_spdif_info,\n\t.get\t\t= ct_spdif_get,\n\t.put\t\t= ct_spdif_put,\n\t.private_value\t= MIXER_IEC958_STREAM\n};\n\n#define NUM_IEC958_CTL 3\n\nstatic int\nct_mixer_kcontrol_new(struct ct_mixer *mixer, struct snd_kcontrol_new *new)\n{\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\tkctl = snd_ctl_new1(new, mixer->atc);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\n\tif (SNDRV_CTL_ELEM_IFACE_PCM == kctl->id.iface)\n\t\tkctl->id.device = IEC958;\n\n\terr = snd_ctl_add(mixer->atc->card, kctl);\n\tif (err)\n\t\treturn err;\n\n\tswitch (new->private_value) {\n\tcase MIXER_LINEIN_C_S:\n\t\tkctls[0] = kctl; break;\n\tcase MIXER_MIC_C_S:\n\t\tkctls[1] = kctl; break;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ct_mixer_kcontrols_create(struct ct_mixer *mixer)\n{\n\tenum CTALSA_MIXER_CTL type;\n\tstruct ct_atc *atc = mixer->atc;\n\tstruct capabilities cap = atc->capabilities(atc);\n\tint err;\n\n\t \n\tfor (type = VOL_MIXER_START; type <= VOL_MIXER_END; type++) {\n\t\tif (ct_kcontrol_init_table[type].ctl) {\n\t\t\tvol_ctl.name = ct_kcontrol_init_table[type].name;\n\t\t\tvol_ctl.private_value = (unsigned long)type;\n\t\t\terr = ct_mixer_kcontrol_new(mixer, &vol_ctl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tct_kcontrol_init_table[MIXER_DIGITAL_IO_S].ctl = cap.digit_io_switch;\n\n\tfor (type = SWH_MIXER_START; type <= SWH_MIXER_END; type++) {\n\t\tif (ct_kcontrol_init_table[type].ctl) {\n\t\t\tswh_ctl.name = ct_kcontrol_init_table[type].name;\n\t\t\tswh_ctl.private_value = (unsigned long)type;\n\t\t\terr = ct_mixer_kcontrol_new(mixer, &swh_ctl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = ct_mixer_kcontrol_new(mixer, &iec958_mask_ctl);\n\tif (err)\n\t\treturn err;\n\n\terr = ct_mixer_kcontrol_new(mixer, &iec958_default_ctl);\n\tif (err)\n\t\treturn err;\n\n\terr = ct_mixer_kcontrol_new(mixer, &iec958_ctl);\n\tif (err)\n\t\treturn err;\n\n\tif (cap.output_switch) {\n\t\terr = ct_mixer_kcontrol_new(mixer, &output_ctl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (cap.mic_source_switch) {\n\t\terr = ct_mixer_kcontrol_new(mixer, &mic_source_ctl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tatc->line_front_unmute(atc, 1);\n\tset_switch_state(mixer, MIXER_WAVEF_P_S, 1);\n\tatc->line_surround_unmute(atc, 0);\n\tset_switch_state(mixer, MIXER_WAVES_P_S, 0);\n\tatc->line_clfe_unmute(atc, 0);\n\tset_switch_state(mixer, MIXER_WAVEC_P_S, 0);\n\tatc->line_rear_unmute(atc, 0);\n\tset_switch_state(mixer, MIXER_WAVER_P_S, 0);\n\tatc->spdif_out_unmute(atc, 0);\n\tset_switch_state(mixer, MIXER_SPDIFO_P_S, 0);\n\tatc->line_in_unmute(atc, 0);\n\tif (cap.dedicated_mic)\n\t\tatc->mic_unmute(atc, 0);\n\tatc->spdif_in_unmute(atc, 0);\n\tset_switch_state(mixer, MIXER_PCM_C_S, 0);\n\tset_switch_state(mixer, MIXER_LINEIN_C_S, 0);\n\tset_switch_state(mixer, MIXER_SPDIFI_C_S, 0);\n\n\treturn 0;\n}\n\nstatic void\nct_mixer_recording_select(struct ct_mixer *mixer, enum CT_AMIXER_CTL type)\n{\n\tstruct amixer *amix_d;\n\tstruct sum *sum_c;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tamix_d = mixer->amixers[type*CHN_NUM+i];\n\t\tsum_c = mixer->sums[SUM_IN_F_C*CHN_NUM+i];\n\t\tamix_d->ops->set_sum(amix_d, sum_c);\n\t\tamix_d->ops->commit_write(amix_d);\n\t}\n}\n\nstatic void\nct_mixer_recording_unselect(struct ct_mixer *mixer, enum CT_AMIXER_CTL type)\n{\n\tstruct amixer *amix_d;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tamix_d = mixer->amixers[type*CHN_NUM+i];\n\t\tamix_d->ops->set_sum(amix_d, NULL);\n\t\tamix_d->ops->commit_write(amix_d);\n\t}\n}\n\nstatic int ct_mixer_get_resources(struct ct_mixer *mixer)\n{\n\tstruct sum_mgr *sum_mgr;\n\tstruct sum *sum;\n\tstruct sum_desc sum_desc = {0};\n\tstruct amixer_mgr *amixer_mgr;\n\tstruct amixer *amixer;\n\tstruct amixer_desc am_desc = {0};\n\tint err;\n\tint i;\n\n\t \n\tsum_mgr = (struct sum_mgr *)mixer->atc->rsc_mgrs[SUM];\n\tsum_desc.msr = mixer->atc->msr;\n\tfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\n\t\terr = sum_mgr->get_sum(sum_mgr, &sum_desc, &sum);\n\t\tif (err) {\n\t\t\tdev_err(mixer->atc->card->dev,\n\t\t\t\t\"Failed to get sum resources for front output!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmixer->sums[i] = sum;\n\t}\n\tif (err)\n\t\tgoto error1;\n\n\t \n\tamixer_mgr = (struct amixer_mgr *)mixer->atc->rsc_mgrs[AMIXER];\n\tam_desc.msr = mixer->atc->msr;\n\tfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\n\t\terr = amixer_mgr->get_amixer(amixer_mgr, &am_desc, &amixer);\n\t\tif (err) {\n\t\t\tdev_err(mixer->atc->card->dev,\n\t\t\t\t\"Failed to get amixer resources for mixer obj!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmixer->amixers[i] = amixer;\n\t}\n\tif (err)\n\t\tgoto error2;\n\n\treturn 0;\n\nerror2:\n\tfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\n\t\tif (NULL != mixer->amixers[i]) {\n\t\t\tamixer = mixer->amixers[i];\n\t\t\tamixer_mgr->put_amixer(amixer_mgr, amixer);\n\t\t\tmixer->amixers[i] = NULL;\n\t\t}\n\t}\nerror1:\n\tfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\n\t\tif (NULL != mixer->sums[i]) {\n\t\t\tsum_mgr->put_sum(sum_mgr, (struct sum *)mixer->sums[i]);\n\t\t\tmixer->sums[i] = NULL;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int ct_mixer_get_mem(struct ct_mixer **rmixer)\n{\n\tstruct ct_mixer *mixer;\n\tint err;\n\n\t*rmixer = NULL;\n\t \n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\n\tmixer->amixers = kcalloc(NUM_CT_AMIXERS * CHN_NUM, sizeof(void *),\n\t\t\t\t GFP_KERNEL);\n\tif (!mixer->amixers) {\n\t\terr = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tmixer->sums = kcalloc(NUM_CT_SUMS * CHN_NUM, sizeof(void *),\n\t\t\t      GFP_KERNEL);\n\tif (!mixer->sums) {\n\t\terr = -ENOMEM;\n\t\tgoto error2;\n\t}\n\n\t*rmixer = mixer;\n\treturn 0;\n\nerror2:\n\tkfree(mixer->amixers);\nerror1:\n\tkfree(mixer);\n\treturn err;\n}\n\nstatic int ct_mixer_topology_build(struct ct_mixer *mixer)\n{\n\tstruct sum *sum;\n\tstruct amixer *amix_d, *amix_s;\n\tenum CT_AMIXER_CTL i, j;\n\tenum CT_SUM_CTL k;\n\n\t \n\n\t \n\tfor (i = AMIXER_MASTER_F, k = SUM_IN_F;\n\t\t\t\t\ti <= AMIXER_MASTER_S; i++, k++) {\n\t\tamix_d = mixer->amixers[i*CHN_NUM];\n\t\tsum = mixer->sums[k*CHN_NUM];\n\t\tamix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\n\t\tamix_d = mixer->amixers[i*CHN_NUM+1];\n\t\tsum = mixer->sums[k*CHN_NUM+1];\n\t\tamix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\n\t}\n\n\t \n\tfor (i = AMIXER_WAVE_F, j = AMIXER_MASTER_F;\n\t\t\t\t\ti <= AMIXER_WAVE_S; i++, j++) {\n\t\tamix_d = mixer->amixers[i*CHN_NUM];\n\t\tamix_s = mixer->amixers[j*CHN_NUM];\n\t\tamix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\n\t\tamix_d = mixer->amixers[i*CHN_NUM+1];\n\t\tamix_s = mixer->amixers[j*CHN_NUM+1];\n\t\tamix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\n\t}\n\n\t \n\tamix_d = mixer->amixers[AMIXER_SPDIFO*CHN_NUM];\n\tamix_s = mixer->amixers[AMIXER_MASTER_F*CHN_NUM];\n\tamix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\n\tamix_d = mixer->amixers[AMIXER_SPDIFO*CHN_NUM+1];\n\tamix_s = mixer->amixers[AMIXER_MASTER_F*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\n\n\t \n\tfor (i = AMIXER_PCM_F, k = SUM_IN_F; i <= AMIXER_PCM_S; i++, k++) {\n\t\tamix_d = mixer->amixers[i*CHN_NUM];\n\t\tsum = mixer->sums[k*CHN_NUM];\n\t\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\t\tamix_d = mixer->amixers[i*CHN_NUM+1];\n\t\tsum = mixer->sums[k*CHN_NUM+1];\n\t\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\t}\n\n\t \n\tamix_d = mixer->amixers[AMIXER_LINEIN*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_LINEIN*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_MIC*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_MIC*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_SPDIFI*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_SPDIFI*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_MASTER_F_C*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\n\tamix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\n\tamix_d = mixer->amixers[AMIXER_MASTER_F_C*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_PCM_F_C*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_PCM_F_C*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_LINEIN_C*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_LINEIN_C*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_MIC_C*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_MIC_C*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\t \n\tamix_d = mixer->amixers[AMIXER_SPDIFI_C*CHN_NUM];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\tamix_d = mixer->amixers[AMIXER_SPDIFI_C*CHN_NUM+1];\n\tsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\n\tamix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\n\n\treturn 0;\n}\n\nstatic int mixer_set_input_port(struct amixer *amixer, struct rsc *rsc)\n{\n\tamixer->ops->set_input(amixer, rsc);\n\tamixer->ops->commit_write(amixer);\n\n\treturn 0;\n}\n\nstatic enum CT_AMIXER_CTL port_to_amixer(enum MIXER_PORT_T type)\n{\n\tswitch (type) {\n\tcase MIX_WAVE_FRONT:\treturn AMIXER_WAVE_F;\n\tcase MIX_WAVE_SURROUND:\treturn AMIXER_WAVE_S;\n\tcase MIX_WAVE_CENTLFE:\treturn AMIXER_WAVE_C;\n\tcase MIX_WAVE_REAR:\treturn AMIXER_WAVE_R;\n\tcase MIX_PCMO_FRONT:\treturn AMIXER_MASTER_F_C;\n\tcase MIX_SPDIF_OUT:\treturn AMIXER_SPDIFO;\n\tcase MIX_LINE_IN:\treturn AMIXER_LINEIN;\n\tcase MIX_MIC_IN:\treturn AMIXER_MIC;\n\tcase MIX_SPDIF_IN:\treturn AMIXER_SPDIFI;\n\tcase MIX_PCMI_FRONT:\treturn AMIXER_PCM_F;\n\tcase MIX_PCMI_SURROUND:\treturn AMIXER_PCM_S;\n\tcase MIX_PCMI_CENTLFE:\treturn AMIXER_PCM_C;\n\tcase MIX_PCMI_REAR:\treturn AMIXER_PCM_R;\n\tdefault: \t\treturn 0;\n\t}\n}\n\nstatic int mixer_get_output_ports(struct ct_mixer *mixer,\n\t\t\t\t  enum MIXER_PORT_T type,\n\t\t\t\t  struct rsc **rleft, struct rsc **rright)\n{\n\tenum CT_AMIXER_CTL amix = port_to_amixer(type);\n\n\tif (NULL != rleft)\n\t\t*rleft = &((struct amixer *)mixer->amixers[amix*CHN_NUM])->rsc;\n\n\tif (NULL != rright)\n\t\t*rright =\n\t\t\t&((struct amixer *)mixer->amixers[amix*CHN_NUM+1])->rsc;\n\n\treturn 0;\n}\n\nstatic int mixer_set_input_left(struct ct_mixer *mixer,\n\t\t\t\tenum MIXER_PORT_T type, struct rsc *rsc)\n{\n\tenum CT_AMIXER_CTL amix = port_to_amixer(type);\n\n\tmixer_set_input_port(mixer->amixers[amix*CHN_NUM], rsc);\n\tamix = get_recording_amixer(amix);\n\tif (amix < NUM_CT_AMIXERS)\n\t\tmixer_set_input_port(mixer->amixers[amix*CHN_NUM], rsc);\n\n\treturn 0;\n}\n\nstatic int\nmixer_set_input_right(struct ct_mixer *mixer,\n\t\t      enum MIXER_PORT_T type, struct rsc *rsc)\n{\n\tenum CT_AMIXER_CTL amix = port_to_amixer(type);\n\n\tmixer_set_input_port(mixer->amixers[amix*CHN_NUM+1], rsc);\n\tamix = get_recording_amixer(amix);\n\tif (amix < NUM_CT_AMIXERS)\n\t\tmixer_set_input_port(mixer->amixers[amix*CHN_NUM+1], rsc);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mixer_resume(struct ct_mixer *mixer)\n{\n\tint i, state;\n\tstruct amixer *amixer;\n\n\t \n\tfor (i = 0; i < NUM_CT_AMIXERS*CHN_NUM; i++) {\n\t\tamixer = mixer->amixers[i];\n\t\tamixer->ops->commit_write(amixer);\n\t}\n\n\t \n\tfor (i = SWH_MIXER_START; i <= SWH_MIXER_END; i++) {\n\t\tstate = get_switch_state(mixer, i);\n\t\tdo_switch(mixer->atc, i, state);\n\t}\n\n\treturn 0;\n}\n#endif\n\nint ct_mixer_destroy(struct ct_mixer *mixer)\n{\n\tstruct sum_mgr *sum_mgr = (struct sum_mgr *)mixer->atc->rsc_mgrs[SUM];\n\tstruct amixer_mgr *amixer_mgr =\n\t\t\t(struct amixer_mgr *)mixer->atc->rsc_mgrs[AMIXER];\n\tstruct amixer *amixer;\n\tint i = 0;\n\n\t \n\tfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\n\t\tif (NULL != mixer->amixers[i]) {\n\t\t\tamixer = mixer->amixers[i];\n\t\t\tamixer_mgr->put_amixer(amixer_mgr, amixer);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\n\t\tif (NULL != mixer->sums[i])\n\t\t\tsum_mgr->put_sum(sum_mgr, (struct sum *)mixer->sums[i]);\n\t}\n\n\t \n\tkfree(mixer->sums);\n\tkfree(mixer->amixers);\n\tkfree(mixer);\n\n\treturn 0;\n}\n\nint ct_mixer_create(struct ct_atc *atc, struct ct_mixer **rmixer)\n{\n\tstruct ct_mixer *mixer;\n\tint err;\n\n\t*rmixer = NULL;\n\n\t \n\terr = ct_mixer_get_mem(&mixer);\n\tif (err)\n\t\treturn err;\n\n\tmixer->switch_state = 0;\n\tmixer->atc = atc;\n\t \n\tmixer->get_output_ports = mixer_get_output_ports;\n\tmixer->set_input_left = mixer_set_input_left;\n\tmixer->set_input_right = mixer_set_input_right;\n#ifdef CONFIG_PM_SLEEP\n\tmixer->resume = mixer_resume;\n#endif\n\n\t \n\terr = ct_mixer_get_resources(mixer);\n\tif (err)\n\t\tgoto error;\n\n\t \n\tct_mixer_topology_build(mixer);\n\n\t*rmixer = mixer;\n\n\treturn 0;\n\nerror:\n\tct_mixer_destroy(mixer);\n\treturn err;\n}\n\nint ct_alsa_mix_create(struct ct_atc *atc,\n\t\t       enum CTALSADEVS device,\n\t\t       const char *device_name)\n{\n\tint err;\n\n\t \n\t   \n\terr = ct_mixer_kcontrols_create((struct ct_mixer *)atc->mixer);\n\tif (err)\n\t\treturn err;\n\n\tstrcpy(atc->card->mixername, device_name);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}