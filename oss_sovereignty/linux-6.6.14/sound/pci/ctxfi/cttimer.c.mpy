{
  "module_name": "cttimer.c",
  "hash_id": "8e5f3f7db85aa4d688f73ceeea45562a64d23ff00680638d934e772db70bb576",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/cttimer.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/moduleparam.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"ctatc.h\"\n#include \"cthardware.h\"\n#include \"cttimer.h\"\n\nstatic bool use_system_timer;\nMODULE_PARM_DESC(use_system_timer, \"Force to use system-timer\");\nmodule_param(use_system_timer, bool, 0444);\n\nstruct ct_timer_ops {\n\tvoid (*init)(struct ct_timer_instance *);\n\tvoid (*prepare)(struct ct_timer_instance *);\n\tvoid (*start)(struct ct_timer_instance *);\n\tvoid (*stop)(struct ct_timer_instance *);\n\tvoid (*free_instance)(struct ct_timer_instance *);\n\tvoid (*interrupt)(struct ct_timer *);\n\tvoid (*free_global)(struct ct_timer *);\n};\n\n \nstruct ct_timer_instance {\n\tspinlock_t lock;\n\tstruct ct_timer *timer_base;\n\tstruct ct_atc_pcm *apcm;\n\tstruct snd_pcm_substream *substream;\n\tstruct timer_list timer;\n\tstruct list_head instance_list;\n\tstruct list_head running_list;\n\tunsigned int position;\n\tunsigned int frag_count;\n\tunsigned int running:1;\n\tunsigned int need_update:1;\n};\n\n \nstruct ct_timer {\n\tspinlock_t lock;\t\t \n\tspinlock_t list_lock;\t\t \n\tstruct ct_atc *atc;\n\tconst struct ct_timer_ops *ops;\n\tstruct list_head instance_head;\n\tstruct list_head running_head;\n\tunsigned int wc;\t\t \n\tunsigned int irq_handling:1;\t \n\tunsigned int reprogram:1;\t \n\tunsigned int running:1;\t\t \n};\n\n\n \n\nstatic void ct_systimer_callback(struct timer_list *t)\n{\n\tstruct ct_timer_instance *ti = from_timer(ti, t, timer);\n\tstruct snd_pcm_substream *substream = ti->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ct_atc_pcm *apcm = ti->apcm;\n\tunsigned int period_size = runtime->period_size;\n\tunsigned int buffer_size = runtime->buffer_size;\n\tunsigned long flags;\n\tunsigned int position, dist, interval;\n\n\tposition = substream->ops->pointer(substream);\n\tdist = (position + buffer_size - ti->position) % buffer_size;\n\tif (dist >= period_size ||\n\t    position / period_size != ti->position / period_size) {\n\t\tapcm->interrupt(apcm);\n\t\tti->position = position;\n\t}\n\t \n\tinterval = ((period_size - (position % period_size))\n\t\t   * HZ + (runtime->rate - 1)) / runtime->rate + HZ * 5 / 1000;\n\tspin_lock_irqsave(&ti->lock, flags);\n\tif (ti->running)\n\t\tmod_timer(&ti->timer, jiffies + interval);\n\tspin_unlock_irqrestore(&ti->lock, flags);\n}\n\nstatic void ct_systimer_init(struct ct_timer_instance *ti)\n{\n\ttimer_setup(&ti->timer, ct_systimer_callback, 0);\n}\n\nstatic void ct_systimer_start(struct ct_timer_instance *ti)\n{\n\tstruct snd_pcm_runtime *runtime = ti->substream->runtime;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ti->lock, flags);\n\tti->running = 1;\n\tmod_timer(&ti->timer,\n\t\t  jiffies + (runtime->period_size * HZ +\n\t\t\t     (runtime->rate - 1)) / runtime->rate);\n\tspin_unlock_irqrestore(&ti->lock, flags);\n}\n\nstatic void ct_systimer_stop(struct ct_timer_instance *ti)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ti->lock, flags);\n\tti->running = 0;\n\tdel_timer(&ti->timer);\n\tspin_unlock_irqrestore(&ti->lock, flags);\n}\n\nstatic void ct_systimer_prepare(struct ct_timer_instance *ti)\n{\n\tct_systimer_stop(ti);\n\ttry_to_del_timer_sync(&ti->timer);\n}\n\n#define ct_systimer_free\tct_systimer_prepare\n\nstatic const struct ct_timer_ops ct_systimer_ops = {\n\t.init = ct_systimer_init,\n\t.free_instance = ct_systimer_free,\n\t.prepare = ct_systimer_prepare,\n\t.start = ct_systimer_start,\n\t.stop = ct_systimer_stop,\n};\n\n\n \n\n#define CT_TIMER_FREQ\t48000\n#define MIN_TICKS\t1\n#define MAX_TICKS\t((1 << 13) - 1)\n\nstatic void ct_xfitimer_irq_rearm(struct ct_timer *atimer, int ticks)\n{\n\tstruct hw *hw = atimer->atc->hw;\n\tif (ticks > MAX_TICKS)\n\t\tticks = MAX_TICKS;\n\thw->set_timer_tick(hw, ticks);\n\tif (!atimer->running)\n\t\thw->set_timer_irq(hw, 1);\n\tatimer->running = 1;\n}\n\nstatic void ct_xfitimer_irq_stop(struct ct_timer *atimer)\n{\n\tif (atimer->running) {\n\t\tstruct hw *hw = atimer->atc->hw;\n\t\thw->set_timer_irq(hw, 0);\n\t\thw->set_timer_tick(hw, 0);\n\t\tatimer->running = 0;\n\t}\n}\n\nstatic inline unsigned int ct_xfitimer_get_wc(struct ct_timer *atimer)\n{\n\tstruct hw *hw = atimer->atc->hw;\n\treturn hw->get_wc(hw);\n}\n\n \nstatic int ct_xfitimer_reprogram(struct ct_timer *atimer, int can_update)\n{\n\tstruct ct_timer_instance *ti;\n\tunsigned int min_intr = (unsigned int)-1;\n\tint updates = 0;\n\tunsigned int wc, diff;\n\n\tif (list_empty(&atimer->running_head)) {\n\t\tct_xfitimer_irq_stop(atimer);\n\t\tatimer->reprogram = 0;  \n\t\treturn 0;\n\t}\n\n\twc = ct_xfitimer_get_wc(atimer);\n\tdiff = wc - atimer->wc;\n\tatimer->wc = wc;\n\tlist_for_each_entry(ti, &atimer->running_head, running_list) {\n\t\tif (ti->frag_count > diff)\n\t\t\tti->frag_count -= diff;\n\t\telse {\n\t\t\tunsigned int pos;\n\t\t\tunsigned int period_size, rate;\n\n\t\t\tperiod_size = ti->substream->runtime->period_size;\n\t\t\trate = ti->substream->runtime->rate;\n\t\t\tpos = ti->substream->ops->pointer(ti->substream);\n\t\t\tif (pos / period_size != ti->position / period_size) {\n\t\t\t\tti->need_update = 1;\n\t\t\t\tti->position = pos;\n\t\t\t\tupdates++;\n\t\t\t}\n\t\t\tpos %= period_size;\n\t\t\tpos = period_size - pos;\n\t\t\tti->frag_count = div_u64((u64)pos * CT_TIMER_FREQ +\n\t\t\t\t\t\t rate - 1, rate);\n\t\t}\n\t\tif (ti->need_update && !can_update)\n\t\t\tmin_intr = 0;  \n\t\tif (ti->frag_count < min_intr)\n\t\t\tmin_intr = ti->frag_count;\n\t}\n\n\tif (min_intr < MIN_TICKS)\n\t\tmin_intr = MIN_TICKS;\n\tct_xfitimer_irq_rearm(atimer, min_intr);\n\tatimer->reprogram = 0;  \n\treturn updates;\n}\n\n \nstatic void ct_xfitimer_check_period(struct ct_timer *atimer)\n{\n\tstruct ct_timer_instance *ti;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atimer->list_lock, flags);\n\tlist_for_each_entry(ti, &atimer->instance_head, instance_list) {\n\t\tif (ti->running && ti->need_update) {\n\t\t\tti->need_update = 0;\n\t\t\tti->apcm->interrupt(ti->apcm);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&atimer->list_lock, flags);\n}\n\n \nstatic void ct_xfitimer_callback(struct ct_timer *atimer)\n{\n\tint update;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atimer->lock, flags);\n\tatimer->irq_handling = 1;\n\tdo {\n\t\tupdate = ct_xfitimer_reprogram(atimer, 1);\n\t\tspin_unlock(&atimer->lock);\n\t\tif (update)\n\t\t\tct_xfitimer_check_period(atimer);\n\t\tspin_lock(&atimer->lock);\n\t} while (atimer->reprogram);\n\tatimer->irq_handling = 0;\n\tspin_unlock_irqrestore(&atimer->lock, flags);\n}\n\nstatic void ct_xfitimer_prepare(struct ct_timer_instance *ti)\n{\n\tti->frag_count = ti->substream->runtime->period_size;\n\tti->running = 0;\n\tti->need_update = 0;\n}\n\n\n \nstatic void ct_xfitimer_update(struct ct_timer *atimer)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atimer->lock, flags);\n\tif (atimer->irq_handling) {\n\t\t \n\t\tatimer->reprogram = 1;\n\t\tspin_unlock_irqrestore(&atimer->lock, flags);\n\t\treturn;\n\t}\n\n\tct_xfitimer_irq_stop(atimer);\n\tct_xfitimer_reprogram(atimer, 0);\n\tspin_unlock_irqrestore(&atimer->lock, flags);\n}\n\nstatic void ct_xfitimer_start(struct ct_timer_instance *ti)\n{\n\tstruct ct_timer *atimer = ti->timer_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atimer->lock, flags);\n\tif (list_empty(&ti->running_list))\n\t\tatimer->wc = ct_xfitimer_get_wc(atimer);\n\tti->running = 1;\n\tti->need_update = 0;\n\tlist_add(&ti->running_list, &atimer->running_head);\n\tspin_unlock_irqrestore(&atimer->lock, flags);\n\tct_xfitimer_update(atimer);\n}\n\nstatic void ct_xfitimer_stop(struct ct_timer_instance *ti)\n{\n\tstruct ct_timer *atimer = ti->timer_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atimer->lock, flags);\n\tlist_del_init(&ti->running_list);\n\tti->running = 0;\n\tspin_unlock_irqrestore(&atimer->lock, flags);\n\tct_xfitimer_update(atimer);\n}\n\nstatic void ct_xfitimer_free_global(struct ct_timer *atimer)\n{\n\tct_xfitimer_irq_stop(atimer);\n}\n\nstatic const struct ct_timer_ops ct_xfitimer_ops = {\n\t.prepare = ct_xfitimer_prepare,\n\t.start = ct_xfitimer_start,\n\t.stop = ct_xfitimer_stop,\n\t.interrupt = ct_xfitimer_callback,\n\t.free_global = ct_xfitimer_free_global,\n};\n\n \n\nstruct ct_timer_instance *\nct_timer_instance_new(struct ct_timer *atimer, struct ct_atc_pcm *apcm)\n{\n\tstruct ct_timer_instance *ti;\n\n\tti = kzalloc(sizeof(*ti), GFP_KERNEL);\n\tif (!ti)\n\t\treturn NULL;\n\tspin_lock_init(&ti->lock);\n\tINIT_LIST_HEAD(&ti->instance_list);\n\tINIT_LIST_HEAD(&ti->running_list);\n\tti->timer_base = atimer;\n\tti->apcm = apcm;\n\tti->substream = apcm->substream;\n\tif (atimer->ops->init)\n\t\tatimer->ops->init(ti);\n\n\tspin_lock_irq(&atimer->list_lock);\n\tlist_add(&ti->instance_list, &atimer->instance_head);\n\tspin_unlock_irq(&atimer->list_lock);\n\n\treturn ti;\n}\n\nvoid ct_timer_prepare(struct ct_timer_instance *ti)\n{\n\tif (ti->timer_base->ops->prepare)\n\t\tti->timer_base->ops->prepare(ti);\n\tti->position = 0;\n\tti->running = 0;\n}\n\nvoid ct_timer_start(struct ct_timer_instance *ti)\n{\n\tstruct ct_timer *atimer = ti->timer_base;\n\tatimer->ops->start(ti);\n}\n\nvoid ct_timer_stop(struct ct_timer_instance *ti)\n{\n\tstruct ct_timer *atimer = ti->timer_base;\n\tatimer->ops->stop(ti);\n}\n\nvoid ct_timer_instance_free(struct ct_timer_instance *ti)\n{\n\tstruct ct_timer *atimer = ti->timer_base;\n\n\tatimer->ops->stop(ti);  \n\tif (atimer->ops->free_instance)\n\t\tatimer->ops->free_instance(ti);\n\n\tspin_lock_irq(&atimer->list_lock);\n\tlist_del(&ti->instance_list);\n\tspin_unlock_irq(&atimer->list_lock);\n\n\tkfree(ti);\n}\n\n \n\nstatic void ct_timer_interrupt(void *data, unsigned int status)\n{\n\tstruct ct_timer *timer = data;\n\n\t \n\tif ((status & IT_INT) && timer->ops->interrupt)\n\t\ttimer->ops->interrupt(timer);\n}\n\nstruct ct_timer *ct_timer_new(struct ct_atc *atc)\n{\n\tstruct ct_timer *atimer;\n\tstruct hw *hw;\n\n\tatimer = kzalloc(sizeof(*atimer), GFP_KERNEL);\n\tif (!atimer)\n\t\treturn NULL;\n\tspin_lock_init(&atimer->lock);\n\tspin_lock_init(&atimer->list_lock);\n\tINIT_LIST_HEAD(&atimer->instance_head);\n\tINIT_LIST_HEAD(&atimer->running_head);\n\tatimer->atc = atc;\n\thw = atc->hw;\n\tif (!use_system_timer && hw->set_timer_irq) {\n\t\tdev_info(atc->card->dev, \"Use xfi-native timer\\n\");\n\t\tatimer->ops = &ct_xfitimer_ops;\n\t\thw->irq_callback_data = atimer;\n\t\thw->irq_callback = ct_timer_interrupt;\n\t} else {\n\t\tdev_info(atc->card->dev, \"Use system timer\\n\");\n\t\tatimer->ops = &ct_systimer_ops;\n\t}\n\treturn atimer;\n}\n\nvoid ct_timer_free(struct ct_timer *atimer)\n{\n\tstruct hw *hw = atimer->atc->hw;\n\thw->irq_callback = NULL;\n\tif (atimer->ops->free_global)\n\t\tatimer->ops->free_global(atimer);\n\tkfree(atimer);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}