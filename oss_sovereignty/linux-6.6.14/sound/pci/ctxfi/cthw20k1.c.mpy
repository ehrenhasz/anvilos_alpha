{
  "module_name": "cthw20k1.c",
  "hash_id": "2ea252f74804ac77a17928b45d7579c5999aaa7b5f983e400c2067bb8b837f6c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/cthw20k1.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include \"cthw20k1.h\"\n#include \"ct20k1reg.h\"\n\nstruct hw20k1 {\n\tstruct hw hw;\n\tspinlock_t reg_20k1_lock;\n\tspinlock_t reg_pci_lock;\n};\n\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg);\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data);\nstatic u32 hw_read_pci(struct hw *hw, u32 reg);\nstatic void hw_write_pci(struct hw *hw, u32 reg, u32 data);\n\n \n\n \n\n \n#define SRCCTL_STATE\t0x00000007\n#define SRCCTL_BM\t0x00000008\n#define SRCCTL_RSR\t0x00000030\n#define SRCCTL_SF\t0x000001C0\n#define SRCCTL_WR\t0x00000200\n#define SRCCTL_PM\t0x00000400\n#define SRCCTL_ROM\t0x00001800\n#define SRCCTL_VO\t0x00002000\n#define SRCCTL_ST\t0x00004000\n#define SRCCTL_IE\t0x00008000\n#define SRCCTL_ILSZ\t0x000F0000\n#define SRCCTL_BP\t0x00100000\n\n#define SRCCCR_CISZ\t0x000007FF\n#define SRCCCR_CWA\t0x001FF800\n#define SRCCCR_D\t0x00200000\n#define SRCCCR_RS\t0x01C00000\n#define SRCCCR_NAL\t0x3E000000\n#define SRCCCR_RA\t0xC0000000\n\n#define SRCCA_CA\t0x03FFFFFF\n#define SRCCA_RS\t0x1C000000\n#define SRCCA_NAL\t0xE0000000\n\n#define SRCSA_SA\t0x03FFFFFF\n\n#define SRCLA_LA\t0x03FFFFFF\n\n \n#define MPRLH_PITCH\t0xFFFFFFFF\n\n \nunion src_dirty {\n\tstruct {\n\t\tu16 ctl:1;\n\t\tu16 ccr:1;\n\t\tu16 sa:1;\n\t\tu16 la:1;\n\t\tu16 ca:1;\n\t\tu16 mpr:1;\n\t\tu16 czbfs:1;\t \n\t\tu16 rsv:9;\n\t} bf;\n\tu16 data;\n};\n\nstruct src_rsc_ctrl_blk {\n\tunsigned int\tctl;\n\tunsigned int \tccr;\n\tunsigned int\tca;\n\tunsigned int\tsa;\n\tunsigned int\tla;\n\tunsigned int\tmpr;\n\tunion src_dirty\tdirty;\n};\n\n \nunion src_mgr_dirty {\n\tstruct {\n\t\tu16 enb0:1;\n\t\tu16 enb1:1;\n\t\tu16 enb2:1;\n\t\tu16 enb3:1;\n\t\tu16 enb4:1;\n\t\tu16 enb5:1;\n\t\tu16 enb6:1;\n\t\tu16 enb7:1;\n\t\tu16 enbsa:1;\n\t\tu16 rsv:7;\n\t} bf;\n\tu16 data;\n};\n\nstruct src_mgr_ctrl_blk {\n\tunsigned int\t\tenbsa;\n\tunsigned int\t\tenb[8];\n\tunion src_mgr_dirty\tdirty;\n};\n\n \n#define SRCAIM_ARC\t0x00000FFF\n#define SRCAIM_NXT\t0x00FF0000\n#define SRCAIM_SRC\t0xFF000000\n\nstruct srcimap {\n\tunsigned int srcaim;\n\tunsigned int idx;\n};\n\n \nunion srcimp_mgr_dirty {\n\tstruct {\n\t\tu16 srcimap:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\nstruct srcimp_mgr_ctrl_blk {\n\tstruct srcimap\t\tsrcimap;\n\tunion srcimp_mgr_dirty\tdirty;\n};\n\n \n\nstatic int src_get_rsc_ctrl_blk(void **rblk)\n{\n\tstruct src_rsc_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int src_put_rsc_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int src_set_state(void *blk, unsigned int state)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_STATE, state);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_bm(void *blk, unsigned int bm)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_BM, bm);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_rsr(void *blk, unsigned int rsr)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_RSR, rsr);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_sf(void *blk, unsigned int sf)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_SF, sf);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_wr(void *blk, unsigned int wr)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_WR, wr);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_pm(void *blk, unsigned int pm)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_PM, pm);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_rom(void *blk, unsigned int rom)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ROM, rom);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_vo(void *blk, unsigned int vo)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_VO, vo);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_st(void *blk, unsigned int st)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ST, st);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_ie(void *blk, unsigned int ie)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_IE, ie);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_ilsz(void *blk, unsigned int ilsz)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ILSZ, ilsz);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_bp(void *blk, unsigned int bp)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_BP, bp);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_cisz(void *blk, unsigned int cisz)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ccr, SRCCCR_CISZ, cisz);\n\tctl->dirty.bf.ccr = 1;\n\treturn 0;\n}\n\nstatic int src_set_ca(void *blk, unsigned int ca)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ca, SRCCA_CA, ca);\n\tctl->dirty.bf.ca = 1;\n\treturn 0;\n}\n\nstatic int src_set_sa(void *blk, unsigned int sa)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->sa, SRCSA_SA, sa);\n\tctl->dirty.bf.sa = 1;\n\treturn 0;\n}\n\nstatic int src_set_la(void *blk, unsigned int la)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->la, SRCLA_LA, la);\n\tctl->dirty.bf.la = 1;\n\treturn 0;\n}\n\nstatic int src_set_pitch(void *blk, unsigned int pitch)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->mpr, MPRLH_PITCH, pitch);\n\tctl->dirty.bf.mpr = 1;\n\treturn 0;\n}\n\nstatic int src_set_clear_zbufs(void *blk, unsigned int clear)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.bf.czbfs = (clear ? 1 : 0);\n\treturn 0;\n}\n\nstatic int src_set_dirty(void *blk, unsigned int flags)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\n\treturn 0;\n}\n\nstatic int src_set_dirty_all(void *blk)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\n\treturn 0;\n}\n\n#define AR_SLOT_SIZE\t\t4096\n#define AR_SLOT_BLOCK_SIZE\t16\n#define AR_PTS_PITCH\t\t6\n#define AR_PARAM_SRC_OFFSET\t0x60\n\nstatic unsigned int src_param_pitch_mixer(unsigned int src_idx)\n{\n\treturn ((src_idx << 4) + AR_PTS_PITCH + AR_SLOT_SIZE\n\t\t\t- AR_PARAM_SRC_OFFSET) % AR_SLOT_SIZE;\n\n}\n\nstatic int src_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\tint i;\n\n\tif (ctl->dirty.bf.czbfs) {\n\t\t \n\t\tfor (i = 0; i < 8; i++)\n\t\t\thw_write_20kx(hw, SRCUPZ+idx*0x100+i*0x4, 0);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thw_write_20kx(hw, SRCDN0Z+idx*0x100+i*0x4, 0);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\thw_write_20kx(hw, SRCDN1Z+idx*0x100+i*0x4, 0);\n\n\t\tctl->dirty.bf.czbfs = 0;\n\t}\n\tif (ctl->dirty.bf.mpr) {\n\t\t \n\t\tunsigned int pm_idx = src_param_pitch_mixer(idx);\n\t\thw_write_20kx(hw, PRING_LO_HI+4*pm_idx, ctl->mpr);\n\t\thw_write_20kx(hw, PMOPLO+8*pm_idx, 0x3);\n\t\thw_write_20kx(hw, PMOPHI+8*pm_idx, 0x0);\n\t\tctl->dirty.bf.mpr = 0;\n\t}\n\tif (ctl->dirty.bf.sa) {\n\t\thw_write_20kx(hw, SRCSA+idx*0x100, ctl->sa);\n\t\tctl->dirty.bf.sa = 0;\n\t}\n\tif (ctl->dirty.bf.la) {\n\t\thw_write_20kx(hw, SRCLA+idx*0x100, ctl->la);\n\t\tctl->dirty.bf.la = 0;\n\t}\n\tif (ctl->dirty.bf.ca) {\n\t\thw_write_20kx(hw, SRCCA+idx*0x100, ctl->ca);\n\t\tctl->dirty.bf.ca = 0;\n\t}\n\n\t \n\thw_write_20kx(hw, SRCCF+idx*0x100, 0x0);\n\n\tif (ctl->dirty.bf.ccr) {\n\t\thw_write_20kx(hw, SRCCCR+idx*0x100, ctl->ccr);\n\t\tctl->dirty.bf.ccr = 0;\n\t}\n\tif (ctl->dirty.bf.ctl) {\n\t\thw_write_20kx(hw, SRCCTL+idx*0x100, ctl->ctl);\n\t\tctl->dirty.bf.ctl = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int src_get_ca(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tctl->ca = hw_read_20kx(hw, SRCCA+idx*0x100);\n\tctl->dirty.bf.ca = 0;\n\n\treturn get_field(ctl->ca, SRCCA_CA);\n}\n\nstatic unsigned int src_get_dirty(void *blk)\n{\n\treturn ((struct src_rsc_ctrl_blk *)blk)->dirty.data;\n}\n\nstatic unsigned int src_dirty_conj_mask(void)\n{\n\treturn 0x20;\n}\n\nstatic int src_mgr_enbs_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enbsa = ~(0x0);\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.bf.enbsa = 1;\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\n\treturn 0;\n}\n\nstatic int src_mgr_enb_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\n\treturn 0;\n}\n\nstatic int src_mgr_dsb_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] &= ~(0x1 << (idx%32));\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\n\treturn 0;\n}\n\nstatic int src_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct src_mgr_ctrl_blk *ctl = blk;\n\tint i;\n\tunsigned int ret;\n\n\tif (ctl->dirty.bf.enbsa) {\n\t\tdo {\n\t\t\tret = hw_read_20kx(hw, SRCENBSTAT);\n\t\t} while (ret & 0x1);\n\t\thw_write_20kx(hw, SRCENBS, ctl->enbsa);\n\t\tctl->dirty.bf.enbsa = 0;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((ctl->dirty.data & (0x1 << i))) {\n\t\t\thw_write_20kx(hw, SRCENB+(i*0x100), ctl->enb[i]);\n\t\t\tctl->dirty.data &= ~(0x1 << i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int src_mgr_get_ctrl_blk(void **rblk)\n{\n\tstruct src_mgr_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int src_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_get_ctrl_blk(void **rblk)\n{\n\tstruct srcimp_mgr_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imaparc(void *blk, unsigned int slot)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_ARC, slot);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapuser(void *blk, unsigned int user)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_SRC, user);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapnxt(void *blk, unsigned int next)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_NXT, next);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapaddr(void *blk, unsigned int addr)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tctl->srcimap.idx = addr;\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.srcimap) {\n\t\thw_write_20kx(hw, SRCIMAP+ctl->srcimap.idx*0x100,\n\t\t\t\t\t\tctl->srcimap.srcaim);\n\t\tctl->dirty.bf.srcimap = 0;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define AMOPLO_M\t0x00000003\n#define AMOPLO_X\t0x0003FFF0\n#define AMOPLO_Y\t0xFFFC0000\n\n#define AMOPHI_SADR\t0x000000FF\n#define AMOPHI_SE\t0x80000000\n\n \nunion amixer_dirty {\n\tstruct {\n\t\tu16 amoplo:1;\n\t\tu16 amophi:1;\n\t\tu16 rsv:14;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct amixer_rsc_ctrl_blk {\n\tunsigned int\t\tamoplo;\n\tunsigned int\t\tamophi;\n\tunion amixer_dirty\tdirty;\n};\n\nstatic int amixer_set_mode(void *blk, unsigned int mode)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_M, mode);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_iv(void *blk, unsigned int iv)\n{\n\t \n\treturn 0;\n}\n\nstatic int amixer_set_x(void *blk, unsigned int x)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_X, x);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_y(void *blk, unsigned int y)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_Y, y);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_sadr(void *blk, unsigned int sadr)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amophi, AMOPHI_SADR, sadr);\n\tctl->dirty.bf.amophi = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_se(void *blk, unsigned int se)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amophi, AMOPHI_SE, se);\n\tctl->dirty.bf.amophi = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_dirty(void *blk, unsigned int flags)\n{\n\t((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\n\treturn 0;\n}\n\nstatic int amixer_set_dirty_all(void *blk)\n{\n\t((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\n\treturn 0;\n}\n\nstatic int amixer_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.amoplo || ctl->dirty.bf.amophi) {\n\t\thw_write_20kx(hw, AMOPLO+idx*8, ctl->amoplo);\n\t\tctl->dirty.bf.amoplo = 0;\n\t\thw_write_20kx(hw, AMOPHI+idx*8, ctl->amophi);\n\t\tctl->dirty.bf.amophi = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int amixer_get_y(void *blk)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\treturn get_field(ctl->amoplo, AMOPLO_Y);\n}\n\nstatic unsigned int amixer_get_dirty(void *blk)\n{\n\treturn ((struct amixer_rsc_ctrl_blk *)blk)->dirty.data;\n}\n\nstatic int amixer_rsc_get_ctrl_blk(void **rblk)\n{\n\tstruct amixer_rsc_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int amixer_rsc_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int amixer_mgr_get_ctrl_blk(void **rblk)\n{\n\t \n\n\t*rblk = NULL;\n\t \n\n\treturn 0;\n}\n\nstatic int amixer_mgr_put_ctrl_blk(void *blk)\n{\n\t \n\n\treturn 0;\n}\n\n \n\n \n#define SRTCTL_SRCR\t0x000000FF\n#define SRTCTL_SRCL\t0x0000FF00\n#define SRTCTL_RSR\t0x00030000\n#define SRTCTL_DRAT\t0x000C0000\n#define SRTCTL_RLE\t0x10000000\n#define SRTCTL_RLP\t0x20000000\n#define SRTCTL_EC\t0x40000000\n#define SRTCTL_ET\t0x80000000\n\n \nunion dai_dirty {\n\tstruct {\n\t\tu16 srtctl:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct dai_ctrl_blk {\n\tunsigned int\tsrtctl;\n\tunion dai_dirty\tdirty;\n};\n\n \nunion dao_dirty {\n\tstruct {\n\t\tu16 spos:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct dao_ctrl_blk {\n\tunsigned int \tspos;  \n\tunion dao_dirty\tdirty;\n};\n\n \n#define AIM_ARC\t\t0x00000FFF\n#define AIM_NXT\t\t0x007F0000\n\nstruct daoimap {\n\tunsigned int aim;\n\tunsigned int idx;\n};\n\n \n#define I2SCTL_EA\t0x00000004\n#define I2SCTL_EI\t0x00000010\n\n \n#define SPOCTL_OE\t0x00000001\n#define SPOCTL_OS\t0x0000000E\n#define SPOCTL_RIV\t0x00000010\n#define SPOCTL_LIV\t0x00000020\n#define SPOCTL_SR\t0x000000C0\n\n \n#define SPICTL_EN\t0x00000001\n#define SPICTL_I24\t0x00000002\n#define SPICTL_IB\t0x00000004\n#define SPICTL_SM\t0x00000008\n#define SPICTL_VM\t0x00000010\n\n \nunion daio_mgr_dirty {\n\tstruct {\n\t\tu32 i2soctl:4;\n\t\tu32 i2sictl:4;\n\t\tu32 spoctl:4;\n\t\tu32 spictl:4;\n\t\tu32 daoimap:1;\n\t\tu32 rsv:15;\n\t} bf;\n\tu32 data;\n};\n\n \nstruct daio_mgr_ctrl_blk {\n\tunsigned int\t\ti2sctl;\n\tunsigned int\t\tspoctl;\n\tunsigned int\t\tspictl;\n\tstruct daoimap\t\tdaoimap;\n\tunion daio_mgr_dirty\tdirty;\n};\n\nstatic int dai_srt_set_srcr(void *blk, unsigned int src)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_SRCR, src);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_srcl(void *blk, unsigned int src)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_SRCL, src);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_rsr(void *blk, unsigned int rsr)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_RSR, rsr);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_drat(void *blk, unsigned int drat)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_DRAT, drat);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_ec(void *blk, unsigned int ec)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_EC, ec ? 1 : 0);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_et(void *blk, unsigned int et)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srtctl, SRTCTL_ET, et ? 1 : 0);\n\tctl->dirty.bf.srtctl = 1;\n\treturn 0;\n}\n\nstatic int dai_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.srtctl) {\n\t\tif (idx < 4) {\n\t\t\t \n\t\t\thw_write_20kx(hw, SRTSCTL+0x4*idx, ctl->srtctl);\n\t\t} else {\n\t\t\t \n\t\t\thw_write_20kx(hw, SRTICTL, ctl->srtctl);\n\t\t}\n\t\tctl->dirty.bf.srtctl = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dai_get_ctrl_blk(void **rblk)\n{\n\tstruct dai_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int dai_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int dao_set_spos(void *blk, unsigned int spos)\n{\n\t((struct dao_ctrl_blk *)blk)->spos = spos;\n\t((struct dao_ctrl_blk *)blk)->dirty.bf.spos = 1;\n\treturn 0;\n}\n\nstatic int dao_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct dao_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.spos) {\n\t\tif (idx < 4) {\n\t\t\t \n\t\t\thw_write_20kx(hw, SPOS+0x4*idx, ctl->spos);\n\t\t}\n\t\tctl->dirty.bf.spos = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dao_get_spos(void *blk, unsigned int *spos)\n{\n\t*spos = ((struct dao_ctrl_blk *)blk)->spos;\n\treturn 0;\n}\n\nstatic int dao_get_ctrl_blk(void **rblk)\n{\n\tstruct dao_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int dao_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int daio_mgr_enb_dai(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tset_field(&ctl->spictl, SPICTL_EN << (idx*8), 1);\n\t\tctl->dirty.bf.spictl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\tidx %= 4;\n\t\tset_field(&ctl->i2sctl, I2SCTL_EI << (idx*8), 1);\n\t\tctl->dirty.bf.i2sictl |= (0x1 << idx);\n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_dsb_dai(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tset_field(&ctl->spictl, SPICTL_EN << (idx*8), 0);\n\t\tctl->dirty.bf.spictl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\tidx %= 4;\n\t\tset_field(&ctl->i2sctl, I2SCTL_EI << (idx*8), 0);\n\t\tctl->dirty.bf.i2sictl |= (0x1 << idx);\n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_enb_dao(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tset_field(&ctl->spoctl, SPOCTL_OE << (idx*8), 1);\n\t\tctl->dirty.bf.spoctl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\tidx %= 4;\n\t\tset_field(&ctl->i2sctl, I2SCTL_EA << (idx*8), 1);\n\t\tctl->dirty.bf.i2soctl |= (0x1 << idx);\n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_dsb_dao(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tset_field(&ctl->spoctl, SPOCTL_OE << (idx*8), 0);\n\t\tctl->dirty.bf.spoctl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\tidx %= 4;\n\t\tset_field(&ctl->i2sctl, I2SCTL_EA << (idx*8), 0);\n\t\tctl->dirty.bf.i2soctl |= (0x1 << idx);\n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_dao_init(void *blk, unsigned int idx, unsigned int conf)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tswitch ((conf & 0x7)) {\n\t\tcase 0:\n\t\t\tset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 3);\n\t\t\tbreak;  \n\t\tcase 1:\n\t\t\tset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tset_field(&ctl->spoctl, SPOCTL_LIV << (idx*8),\n\t\t\t  (conf >> 4) & 0x1);  \n\t\tset_field(&ctl->spoctl, SPOCTL_RIV << (idx*8),\n\t\t\t  (conf >> 4) & 0x1);  \n\t\tset_field(&ctl->spoctl, SPOCTL_OS << (idx*8),\n\t\t\t  ((conf >> 3) & 0x1) ? 2 : 2);  \n\n\t\tctl->dirty.bf.spoctl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imaparc(void *blk, unsigned int slot)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->daoimap.aim, AIM_ARC, slot);\n\tctl->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imapnxt(void *blk, unsigned int next)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->daoimap.aim, AIM_NXT, next);\n\tctl->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imapaddr(void *blk, unsigned int addr)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tctl->daoimap.idx = addr;\n\tctl->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\tint i;\n\n\tif (ctl->dirty.bf.i2sictl || ctl->dirty.bf.i2soctl) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((ctl->dirty.bf.i2sictl & (0x1 << i)))\n\t\t\t\tctl->dirty.bf.i2sictl &= ~(0x1 << i);\n\n\t\t\tif ((ctl->dirty.bf.i2soctl & (0x1 << i)))\n\t\t\t\tctl->dirty.bf.i2soctl &= ~(0x1 << i);\n\t\t}\n\t\thw_write_20kx(hw, I2SCTL, ctl->i2sctl);\n\t\tmdelay(1);\n\t}\n\tif (ctl->dirty.bf.spoctl) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((ctl->dirty.bf.spoctl & (0x1 << i)))\n\t\t\t\tctl->dirty.bf.spoctl &= ~(0x1 << i);\n\t\t}\n\t\thw_write_20kx(hw, SPOCTL, ctl->spoctl);\n\t\tmdelay(1);\n\t}\n\tif (ctl->dirty.bf.spictl) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((ctl->dirty.bf.spictl & (0x1 << i)))\n\t\t\t\tctl->dirty.bf.spictl &= ~(0x1 << i);\n\t\t}\n\t\thw_write_20kx(hw, SPICTL, ctl->spictl);\n\t\tmdelay(1);\n\t}\n\tif (ctl->dirty.bf.daoimap) {\n\t\thw_write_20kx(hw, DAOIMAP+ctl->daoimap.idx*4,\n\t\t\t\t\tctl->daoimap.aim);\n\t\tctl->dirty.bf.daoimap = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int daio_mgr_get_ctrl_blk(struct hw *hw, void **rblk)\n{\n\tstruct daio_mgr_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\tblk->i2sctl = hw_read_20kx(hw, I2SCTL);\n\tblk->spoctl = hw_read_20kx(hw, SPOCTL);\n\tblk->spictl = hw_read_20kx(hw, SPICTL);\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int daio_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\n \nstatic int set_timer_irq(struct hw *hw, int enable)\n{\n\thw_write_20kx(hw, GIE, enable ? IT_INT : 0);\n\treturn 0;\n}\n\nstatic int set_timer_tick(struct hw *hw, unsigned int ticks)\n{\n\tif (ticks)\n\t\tticks |= TIMR_IE | TIMR_IP;\n\thw_write_20kx(hw, TIMR, ticks);\n\treturn 0;\n}\n\nstatic unsigned int get_wc(struct hw *hw)\n{\n\treturn hw_read_20kx(hw, WC);\n}\n\n \nstruct dac_conf {\n\tunsigned int msr;  \n};\n\nstruct adc_conf {\n\tunsigned int msr; \t \n\tunsigned char input; \t \n\tunsigned char mic20db; \t \n};\n\nstruct daio_conf {\n\tunsigned int msr;  \n};\n\nstruct trn_conf {\n\tunsigned long vm_pgt_phys;\n};\n\nstatic int hw_daio_init(struct hw *hw, const struct daio_conf *info)\n{\n\tu32 i2sorg;\n\tu32 spdorg;\n\n\t \n\t \n\ti2sorg = 0x94040404;  \n\t \n\ti2sorg &= 0xfffffffc;\n\n\t \n\t \n\thw_write_20kx(hw, SPOCTL, 0x0);\n\tspdorg = 0x05;\n\n\tswitch (info->msr) {\n\tcase 1:\n\t\ti2sorg |= 1;\n\t\tspdorg |= (0x0 << 6);\n\t\tbreak;\n\tcase 2:\n\t\ti2sorg |= 2;\n\t\tspdorg |= (0x1 << 6);\n\t\tbreak;\n\tcase 4:\n\t\ti2sorg |= 3;\n\t\tspdorg |= (0x2 << 6);\n\t\tbreak;\n\tdefault:\n\t\ti2sorg |= 1;\n\t\tbreak;\n\t}\n\n\thw_write_20kx(hw, I2SCTL, i2sorg);\n\thw_write_20kx(hw, SPOCTL, spdorg);\n\n\t \n\t \n\thw_write_20kx(hw, SPICTL, 0x0);\n\tmdelay(1);\n\tspdorg = 0x0a0a0a0a;\n\thw_write_20kx(hw, SPICTL, spdorg);\n\tmdelay(1);\n\n\treturn 0;\n}\n\n \nstatic int hw_trn_init(struct hw *hw, const struct trn_conf *info)\n{\n\tu32 trnctl;\n\tu32 ptp_phys_low, ptp_phys_high;\n\n\t \n\tif ((~0UL) == info->vm_pgt_phys) {\n\t\tdev_err(hw->card->dev,\n\t\t\t\"Wrong device page table page address!\\n\");\n\t\treturn -1;\n\t}\n\n\ttrnctl = 0x13;   \n\tptp_phys_low = (u32)info->vm_pgt_phys;\n\tptp_phys_high = upper_32_bits(info->vm_pgt_phys);\n\tif (sizeof(void *) == 8)  \n\t\ttrnctl |= (1 << 2);\n#if 0  \n#if PAGE_SIZE == 8192\n\ttrnctl |= (1<<5);\n#endif\n#endif\n\thw_write_20kx(hw, PTPALX, ptp_phys_low);\n\thw_write_20kx(hw, PTPAHX, ptp_phys_high);\n\thw_write_20kx(hw, TRNCTL, trnctl);\n\thw_write_20kx(hw, TRNIS, 0x200c01);  \n\n\treturn 0;\n}\n\n \n#define GCTL_EAC\t0x00000001\n#define GCTL_EAI\t0x00000002\n#define GCTL_BEP\t0x00000004\n#define GCTL_BES\t0x00000008\n#define GCTL_DSP\t0x00000010\n#define GCTL_DBP\t0x00000020\n#define GCTL_ABP\t0x00000040\n#define GCTL_TBP\t0x00000080\n#define GCTL_SBP\t0x00000100\n#define GCTL_FBP\t0x00000200\n#define GCTL_XA\t\t0x00000400\n#define GCTL_ET\t\t0x00000800\n#define GCTL_PR\t\t0x00001000\n#define GCTL_MRL\t0x00002000\n#define GCTL_SDE\t0x00004000\n#define GCTL_SDI\t0x00008000\n#define GCTL_SM\t\t0x00010000\n#define GCTL_SR\t\t0x00020000\n#define GCTL_SD\t\t0x00040000\n#define GCTL_SE\t\t0x00080000\n#define GCTL_AID\t0x00100000\n\nstatic int hw_pll_init(struct hw *hw, unsigned int rsr)\n{\n\tunsigned int pllctl;\n\tint i;\n\n\tpllctl = (48000 == rsr) ? 0x1480a001 : 0x1480a731;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (hw_read_20kx(hw, PLLCTL) == pllctl)\n\t\t\tbreak;\n\n\t\thw_write_20kx(hw, PLLCTL, pllctl);\n\t\tmsleep(40);\n\t}\n\tif (i >= 3) {\n\t\tdev_alert(hw->card->dev, \"PLL initialization failed!!!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int hw_auto_init(struct hw *hw)\n{\n\tunsigned int gctl;\n\tint i;\n\n\tgctl = hw_read_20kx(hw, GCTL);\n\tset_field(&gctl, GCTL_EAI, 0);\n\thw_write_20kx(hw, GCTL, gctl);\n\tset_field(&gctl, GCTL_EAI, 1);\n\thw_write_20kx(hw, GCTL, gctl);\n\tmdelay(10);\n\tfor (i = 0; i < 400000; i++) {\n\t\tgctl = hw_read_20kx(hw, GCTL);\n\t\tif (get_field(gctl, GCTL_AID))\n\t\t\tbreak;\n\t}\n\tif (!get_field(gctl, GCTL_AID)) {\n\t\tdev_alert(hw->card->dev, \"Card Auto-init failed!!!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_unlock(struct hw *hw)\n{\n\tif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\n\t\treturn 0;\n\n\thw_write_pci(hw, 0xcc, 0x8c);\n\thw_write_pci(hw, 0xcc, 0x0e);\n\tif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\n\t\treturn 0;\n\n\thw_write_pci(hw, 0xcc, 0xee);\n\thw_write_pci(hw, 0xcc, 0xaa);\n\tif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic void i2c_lock(struct hw *hw)\n{\n\tif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\n\t\thw_write_pci(hw, 0xcc, 0x00);\n}\n\nstatic void i2c_write(struct hw *hw, u32 device, u32 addr, u32 data)\n{\n\tunsigned int ret;\n\n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));\n\thw_write_pci(hw, 0xE0, device);\n\thw_write_pci(hw, 0xE4, (data << 8) | (addr & 0xff));\n}\n\n \n\nstatic int hw_reset_dac(struct hw *hw)\n{\n\tu32 i;\n\tu16 gpioorg;\n\tunsigned int ret;\n\n\tif (i2c_unlock(hw))\n\t\treturn -1;\n\n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));\n\thw_write_pci(hw, 0xEC, 0x05);   \n\n\t \n\tfor (i = 0; i < 2;  i++) {\n\t\t \n\t\tmsleep(100);\n\t\tgpioorg = (u16)hw_read_20kx(hw, GPIO);\n\t\tgpioorg &= 0xfffd;\n\t\thw_write_20kx(hw, GPIO, gpioorg);\n\t\tmdelay(1);\n\t\thw_write_20kx(hw, GPIO, gpioorg | 0x2);\n\t}\n\n\ti2c_write(hw, 0x00180080, 0x01, 0x80);\n\ti2c_write(hw, 0x00180080, 0x02, 0x10);\n\n\ti2c_lock(hw);\n\n\treturn 0;\n}\n\nstatic int hw_dac_init(struct hw *hw, const struct dac_conf *info)\n{\n\tu32 data;\n\tu16 gpioorg;\n\tunsigned int ret;\n\n\tif (hw->model == CTSB055X) {\n\t\t \n\t\tgpioorg = (u16)hw_read_20kx(hw, GPIO);\n\t\tgpioorg &= 0xffbf;\t \n\t\tgpioorg |= 2;\t\t \n\t\thw_write_20kx(hw, GPIO, gpioorg);\n\t\treturn 0;\n\t}\n\n\t \n\tgpioorg = (u16)hw_read_20kx(hw, GPIO);\n\tgpioorg &= 0xffbf;\n\thw_write_20kx(hw, GPIO, gpioorg);\n\n\thw_reset_dac(hw);\n\n\tif (i2c_unlock(hw))\n\t\treturn -1;\n\n\thw_write_pci(hw, 0xEC, 0x05);   \n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));\n\n\tswitch (info->msr) {\n\tcase 1:\n\t\tdata = 0x24;\n\t\tbreak;\n\tcase 2:\n\t\tdata = 0x25;\n\t\tbreak;\n\tcase 4:\n\t\tdata = 0x26;\n\t\tbreak;\n\tdefault:\n\t\tdata = 0x24;\n\t\tbreak;\n\t}\n\n\ti2c_write(hw, 0x00180080, 0x06, data);\n\ti2c_write(hw, 0x00180080, 0x09, data);\n\ti2c_write(hw, 0x00180080, 0x0c, data);\n\ti2c_write(hw, 0x00180080, 0x0f, data);\n\n\ti2c_lock(hw);\n\n\t \n\tgpioorg = (u16)hw_read_20kx(hw, GPIO);\n\tgpioorg = gpioorg | 0x40;\n\thw_write_20kx(hw, GPIO, gpioorg);\n\n\treturn 0;\n}\n\n \n\nstatic int is_adc_input_selected_SB055x(struct hw *hw, enum ADCSRC type)\n{\n\treturn 0;\n}\n\nstatic int is_adc_input_selected_SBx(struct hw *hw, enum ADCSRC type)\n{\n\tu32 data;\n\n\tdata = hw_read_20kx(hw, GPIO);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata = ((data & (0x1<<7)) && (data & (0x1<<8)));\n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata = (!(data & (0x1<<7)) && (data & (0x1<<8)));\n\t\tbreak;\n\tcase ADC_NONE:  \n\t\tdata = (!(data & (0x1<<8)));\n\t\tbreak;\n\tdefault:\n\t\tdata = 0;\n\t}\n\treturn data;\n}\n\nstatic int is_adc_input_selected_hendrix(struct hw *hw, enum ADCSRC type)\n{\n\tu32 data;\n\n\tdata = hw_read_20kx(hw, GPIO);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata = (data & (0x1 << 7)) ? 1 : 0;\n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata = (data & (0x1 << 7)) ? 0 : 1;\n\t\tbreak;\n\tdefault:\n\t\tdata = 0;\n\t}\n\treturn data;\n}\n\nstatic int hw_is_adc_input_selected(struct hw *hw, enum ADCSRC type)\n{\n\tswitch (hw->model) {\n\tcase CTSB055X:\n\t\treturn is_adc_input_selected_SB055x(hw, type);\n\tcase CTSB073X:\n\t\treturn is_adc_input_selected_hendrix(hw, type);\n\tcase CTUAA:\n\t\treturn is_adc_input_selected_hendrix(hw, type);\n\tdefault:\n\t\treturn is_adc_input_selected_SBx(hw, type);\n\t}\n}\n\nstatic int\nadc_input_select_SB055x(struct hw *hw, enum ADCSRC type, unsigned char boost)\n{\n\tu32 data;\n\n\t \n\tdata = hw_read_20kx(hw, GPIO);\n\tdata &= 0xec73;\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata |= (0x1<<7) | (0x1<<8) | (0x1<<9) ;\n\t\tdata |= boost ? (0x1<<2) : 0;\n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata |= (0x1<<8);\n\t\tbreak;\n\tcase ADC_AUX:\n\t\tdata |= (0x1<<8) | (0x1<<12);\n\t\tbreak;\n\tcase ADC_NONE:\n\t\tdata |= (0x1<<12);   \n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\thw_write_20kx(hw, GPIO, data);\n\n\treturn 0;\n}\n\n\nstatic int\nadc_input_select_SBx(struct hw *hw, enum ADCSRC type, unsigned char boost)\n{\n\tu32 data;\n\tu32 i2c_data;\n\tunsigned int ret;\n\n\tif (i2c_unlock(hw))\n\t\treturn -1;\n\n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));  \n\t \n\thw_write_pci(hw, 0xEC, 0x05);\n\n\tdata = hw_read_20kx(hw, GPIO);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata |= ((0x1 << 7) | (0x1 << 8));\n\t\ti2c_data = 0x1;   \n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata &= ~(0x1 << 7);\n\t\tdata |= (0x1 << 8);\n\t\ti2c_data = 0x2;  \n\t\tbreak;\n\tcase ADC_NONE:\n\t\tdata &= ~(0x1 << 8);\n\t\ti2c_data = 0x0;  \n\t\tbreak;\n\tdefault:\n\t\ti2c_lock(hw);\n\t\treturn -1;\n\t}\n\thw_write_20kx(hw, GPIO, data);\n\ti2c_write(hw, 0x001a0080, 0x2a, i2c_data);\n\tif (boost) {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xe7);  \n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xe7);  \n\t} else {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xcf);  \n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xcf);  \n\t}\n\n\ti2c_lock(hw);\n\n\treturn 0;\n}\n\nstatic int\nadc_input_select_hendrix(struct hw *hw, enum ADCSRC type, unsigned char boost)\n{\n\tu32 data;\n\tu32 i2c_data;\n\tunsigned int ret;\n\n\tif (i2c_unlock(hw))\n\t\treturn -1;\n\n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));  \n\t \n\thw_write_pci(hw, 0xEC, 0x05);\n\n\tdata = hw_read_20kx(hw, GPIO);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata |= (0x1 << 7);\n\t\ti2c_data = 0x1;   \n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata &= ~(0x1 << 7);\n\t\ti2c_data = 0x2;  \n\t\tbreak;\n\tdefault:\n\t\ti2c_lock(hw);\n\t\treturn -1;\n\t}\n\thw_write_20kx(hw, GPIO, data);\n\ti2c_write(hw, 0x001a0080, 0x2a, i2c_data);\n\tif (boost) {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xe7);  \n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xe7);  \n\t} else {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xcf);  \n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xcf);  \n\t}\n\n\ti2c_lock(hw);\n\n\treturn 0;\n}\n\nstatic int hw_adc_input_select(struct hw *hw, enum ADCSRC type)\n{\n\tint state = type == ADC_MICIN;\n\n\tswitch (hw->model) {\n\tcase CTSB055X:\n\t\treturn adc_input_select_SB055x(hw, type, state);\n\tcase CTSB073X:\n\t\treturn adc_input_select_hendrix(hw, type, state);\n\tcase CTUAA:\n\t\treturn adc_input_select_hendrix(hw, type, state);\n\tdefault:\n\t\treturn adc_input_select_SBx(hw, type, state);\n\t}\n}\n\nstatic int adc_init_SB055x(struct hw *hw, int input, int mic20db)\n{\n\treturn adc_input_select_SB055x(hw, input, mic20db);\n}\n\nstatic int adc_init_SBx(struct hw *hw, int input, int mic20db)\n{\n\tu16 gpioorg;\n\tu16 input_source;\n\tu32 adcdata;\n\tunsigned int ret;\n\n\tinput_source = 0x100;   \n\tswitch (input) {\n\tcase ADC_MICIN:\n\t\tadcdata = 0x1;\n\t\tinput_source = 0x180;   \n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tadcdata = 0x2;\n\t\tbreak;\n\tcase ADC_VIDEO:\n\t\tadcdata = 0x4;\n\t\tbreak;\n\tcase ADC_AUX:\n\t\tadcdata = 0x8;\n\t\tbreak;\n\tcase ADC_NONE:\n\t\tadcdata = 0x0;\n\t\tinput_source = 0x0;   \n\t\tbreak;\n\tdefault:\n\t\tadcdata = 0x0;\n\t\tbreak;\n\t}\n\n\tif (i2c_unlock(hw))\n\t\treturn -1;\n\n\tdo {\n\t\tret = hw_read_pci(hw, 0xEC);\n\t} while (!(ret & 0x800000));  \n\thw_write_pci(hw, 0xEC, 0x05);   \n\n\ti2c_write(hw, 0x001a0080, 0x0e, 0x08);\n\ti2c_write(hw, 0x001a0080, 0x18, 0x0a);\n\ti2c_write(hw, 0x001a0080, 0x28, 0x86);\n\ti2c_write(hw, 0x001a0080, 0x2a, adcdata);\n\n\tif (mic20db) {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xf7);\n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xf7);\n\t} else {\n\t\ti2c_write(hw, 0x001a0080, 0x1c, 0xcf);\n\t\ti2c_write(hw, 0x001a0080, 0x1e, 0xcf);\n\t}\n\n\tif (!(hw_read_20kx(hw, ID0) & 0x100))\n\t\ti2c_write(hw, 0x001a0080, 0x16, 0x26);\n\n\ti2c_lock(hw);\n\n\tgpioorg = (u16)hw_read_20kx(hw,  GPIO);\n\tgpioorg &= 0xfe7f;\n\tgpioorg |= input_source;\n\thw_write_20kx(hw, GPIO, gpioorg);\n\n\treturn 0;\n}\n\nstatic int hw_adc_init(struct hw *hw, const struct adc_conf *info)\n{\n\tif (hw->model == CTSB055X)\n\t\treturn adc_init_SB055x(hw, info->input, info->mic20db);\n\telse\n\t\treturn adc_init_SBx(hw, info->input, info->mic20db);\n}\n\nstatic struct capabilities hw_capabilities(struct hw *hw)\n{\n\tstruct capabilities cap;\n\n\t \n\tcap.digit_io_switch = !(hw->model == CTSB073X || hw->model == CTUAA);\n\tcap.dedicated_mic = 0;\n\tcap.output_switch = 0;\n\tcap.mic_source_switch = 0;\n\n\treturn cap;\n}\n\n#define CTLBITS(a, b, c, d)\t(((a) << 24) | ((b) << 16) | ((c) << 8) | (d))\n\n#define UAA_CFG_PWRSTATUS\t0x44\n#define UAA_CFG_SPACE_FLAG\t0xA0\n#define UAA_CORE_CHANGE\t\t0x3FFC\nstatic int uaa_to_xfi(struct pci_dev *pci)\n{\n\tunsigned int bar0, bar1, bar2, bar3, bar4, bar5;\n\tunsigned int cmd, irq, cl_size, l_timer, pwr;\n\tunsigned int is_uaa;\n\tunsigned int data[4] = {0};\n\tunsigned int io_base;\n\tvoid __iomem *mem_base;\n\tint i;\n\tconst u32 CTLX = CTLBITS('C', 'T', 'L', 'X');\n\tconst u32 CTL_ = CTLBITS('C', 'T', 'L', '-');\n\tconst u32 CTLF = CTLBITS('C', 'T', 'L', 'F');\n\tconst u32 CTLi = CTLBITS('C', 'T', 'L', 'i');\n\tconst u32 CTLA = CTLBITS('C', 'T', 'L', 'A');\n\tconst u32 CTLZ = CTLBITS('C', 'T', 'L', 'Z');\n\tconst u32 CTLL = CTLBITS('C', 'T', 'L', 'L');\n\n\t \n\tio_base = pci_resource_start(pci, 0);\n\tmem_base = ioremap(io_base, pci_resource_len(pci, 0));\n\tif (!mem_base)\n\t\treturn -ENOENT;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tdata[i] = readl(mem_base + UAA_CORE_CHANGE);\n\n\t \n\tif (data[0] == CTLA) {\n\t\tis_uaa = ((data[1] == CTLZ && data[2] == CTLL\n\t\t\t  && data[3] == CTLA) || (data[1] == CTLA\n\t\t\t  && data[2] == CTLZ && data[3] == CTLL));\n\t} else if (data[0] == CTLZ) {\n\t\tis_uaa = (data[1] == CTLL\n\t\t\t\t&& data[2] == CTLA && data[3] == CTLA);\n\t} else if (data[0] == CTLL) {\n\t\tis_uaa = (data[1] == CTLA\n\t\t\t\t&& data[2] == CTLA && data[3] == CTLZ);\n\t} else {\n\t\tis_uaa = 0;\n\t}\n\n\tif (!is_uaa) {\n\t\t \n\t\tiounmap(mem_base);\n\t\treturn 0;\n\t}\n\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_0, &bar0);\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_1, &bar1);\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_2, &bar2);\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_3, &bar3);\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_4, &bar4);\n\tpci_read_config_dword(pci, PCI_BASE_ADDRESS_5, &bar5);\n\tpci_read_config_dword(pci, PCI_INTERRUPT_LINE, &irq);\n\tpci_read_config_dword(pci, PCI_CACHE_LINE_SIZE, &cl_size);\n\tpci_read_config_dword(pci, PCI_LATENCY_TIMER, &l_timer);\n\tpci_read_config_dword(pci, UAA_CFG_PWRSTATUS, &pwr);\n\tpci_read_config_dword(pci, PCI_COMMAND, &cmd);\n\n\t \n\t \n\tpci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x87654321);\n\t \n\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_0, bar5);\n\t \n\tpci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x12345678);\n\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_1, bar1);\n\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_2, bar2);\n\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_3, bar3);\n\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_4, bar4);\n\tpci_write_config_dword(pci, PCI_INTERRUPT_LINE, irq);\n\tpci_write_config_dword(pci, PCI_CACHE_LINE_SIZE, cl_size);\n\tpci_write_config_dword(pci, PCI_LATENCY_TIMER, l_timer);\n\tpci_write_config_dword(pci, UAA_CFG_PWRSTATUS, pwr);\n\tpci_write_config_dword(pci, PCI_COMMAND, cmd);\n\n\t \n\twritel(CTLX, (mem_base + UAA_CORE_CHANGE));\n\twritel(CTL_, (mem_base + UAA_CORE_CHANGE));\n\twritel(CTLF, (mem_base + UAA_CORE_CHANGE));\n\twritel(CTLi, (mem_base + UAA_CORE_CHANGE));\n\n\tiounmap(mem_base);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ct_20k1_interrupt(int irq, void *dev_id)\n{\n\tstruct hw *hw = dev_id;\n\tunsigned int status;\n\n\tstatus = hw_read_20kx(hw, GIP);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (hw->irq_callback)\n\t\thw->irq_callback(hw->irq_callback_data, status);\n\n\thw_write_20kx(hw, GIP, status);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hw_card_start(struct hw *hw)\n{\n\tint err;\n\tstruct pci_dev *pci = hw->pci;\n\tconst unsigned int dma_bits = BITS_PER_LONG;\n\n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(dma_bits)))\n\t\tdma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32));\n\n\tif (!hw->io_base) {\n\t\terr = pci_request_regions(pci, \"XFi\");\n\t\tif (err < 0)\n\t\t\tgoto error1;\n\n\t\tif (hw->model == CTUAA)\n\t\t\thw->io_base = pci_resource_start(pci, 5);\n\t\telse\n\t\t\thw->io_base = pci_resource_start(pci, 0);\n\n\t}\n\n\t \n\tif (hw->model == CTUAA) {\n\t\terr = uaa_to_xfi(pci);\n\t\tif (err)\n\t\t\tgoto error2;\n\n\t}\n\n\tif (hw->irq < 0) {\n\t\terr = request_irq(pci->irq, ct_20k1_interrupt, IRQF_SHARED,\n\t\t\t\t  KBUILD_MODNAME, hw);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->card->dev,\n\t\t\t\t\"XFi: Cannot get irq %d\\n\", pci->irq);\n\t\t\tgoto error2;\n\t\t}\n\t\thw->irq = pci->irq;\n\t\thw->card->sync_irq = hw->irq;\n\t}\n\n\tpci_set_master(pci);\n\n\treturn 0;\n\nerror2:\n\tpci_release_regions(pci);\n\thw->io_base = 0;\nerror1:\n\tpci_disable_device(pci);\n\treturn err;\n}\n\nstatic int hw_card_stop(struct hw *hw)\n{\n\tunsigned int data;\n\n\t \n\thw_write_20kx(hw, TRNCTL, 0x00);\n\n\t \n\tdata = hw_read_20kx(hw, PLLCTL);\n\thw_write_20kx(hw, PLLCTL, (data & (~(0x0F<<12))));\n\n\treturn 0;\n}\n\nstatic int hw_card_shutdown(struct hw *hw)\n{\n\tif (hw->irq >= 0)\n\t\tfree_irq(hw->irq, hw);\n\n\thw->irq\t= -1;\n\tiounmap(hw->mem_base);\n\thw->mem_base = NULL;\n\n\tif (hw->io_base)\n\t\tpci_release_regions(hw->pci);\n\n\thw->io_base = 0;\n\n\tpci_disable_device(hw->pci);\n\n\treturn 0;\n}\n\nstatic int hw_card_init(struct hw *hw, struct card_conf *info)\n{\n\tint err;\n\tunsigned int gctl;\n\tu32 data;\n\tstruct dac_conf dac_info = {0};\n\tstruct adc_conf adc_info = {0};\n\tstruct daio_conf daio_info = {0};\n\tstruct trn_conf trn_info = {0};\n\n\t \n\terr = hw_card_start(hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hw_pll_init(hw, info->rsr);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = hw_auto_init(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tgctl = hw_read_20kx(hw, GCTL);\n\tset_field(&gctl, GCTL_EAC, 1);\n\tset_field(&gctl, GCTL_DBP, 1);\n\tset_field(&gctl, GCTL_TBP, 1);\n\tset_field(&gctl, GCTL_FBP, 1);\n\tset_field(&gctl, GCTL_ET, 1);\n\thw_write_20kx(hw, GCTL, gctl);\n\tmdelay(10);\n\n\t \n\thw_write_20kx(hw, GIE, 0);\n\t \n\thw_write_20kx(hw, SRCIP, 0);\n\tmsleep(30);\n\n\t \n\tswitch (hw->model) {\n\tcase CTSB055X:\n\t\thw_write_20kx(hw, GPIOCTL, 0x13fe);\n\t\tbreak;\n\tcase CTSB073X:\n\t\thw_write_20kx(hw, GPIOCTL, 0x00e6);\n\t\tbreak;\n\tcase CTUAA:\n\t\thw_write_20kx(hw, GPIOCTL, 0x00c2);\n\t\tbreak;\n\tdefault:\n\t\thw_write_20kx(hw, GPIOCTL, 0x01e6);\n\t\tbreak;\n\t}\n\n\ttrn_info.vm_pgt_phys = info->vm_pgt_phys;\n\terr = hw_trn_init(hw, &trn_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdaio_info.msr = info->msr;\n\terr = hw_daio_init(hw, &daio_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdac_info.msr = info->msr;\n\terr = hw_dac_init(hw, &dac_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tadc_info.msr = info->msr;\n\tadc_info.input = ADC_LINEIN;\n\tadc_info.mic20db = 0;\n\terr = hw_adc_init(hw, &adc_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = hw_read_20kx(hw, SRCMCTL);\n\tdata |= 0x1;  \n\thw_write_20kx(hw, SRCMCTL, data);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hw_suspend(struct hw *hw)\n{\n\tstruct pci_dev *pci = hw->pci;\n\n\thw_card_stop(hw);\n\n\tif (hw->model == CTUAA) {\n\t\t \n\t\tpci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x0);\n\t}\n\n\treturn 0;\n}\n\nstatic int hw_resume(struct hw *hw, struct card_conf *info)\n{\n\t \n\treturn hw_card_init(hw, info);\n}\n#endif\n\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg)\n{\n\tu32 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\n\toutl(reg, hw->io_base + 0x0);\n\tvalue = inl(hw->io_base + 0x4);\n\tspin_unlock_irqrestore(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\n\n\treturn value;\n}\n\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\n\toutl(reg, hw->io_base + 0x0);\n\toutl(data, hw->io_base + 0x4);\n\tspin_unlock_irqrestore(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\n\n}\n\nstatic u32 hw_read_pci(struct hw *hw, u32 reg)\n{\n\tu32 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\n\toutl(reg, hw->io_base + 0x10);\n\tvalue = inl(hw->io_base + 0x14);\n\tspin_unlock_irqrestore(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\n\n\treturn value;\n}\n\nstatic void hw_write_pci(struct hw *hw, u32 reg, u32 data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\n\toutl(reg, hw->io_base + 0x10);\n\toutl(data, hw->io_base + 0x14);\n\tspin_unlock_irqrestore(\n\t\t&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\n}\n\nstatic const struct hw ct20k1_preset = {\n\t.irq = -1,\n\n\t.card_init = hw_card_init,\n\t.card_stop = hw_card_stop,\n\t.pll_init = hw_pll_init,\n\t.is_adc_source_selected = hw_is_adc_input_selected,\n\t.select_adc_source = hw_adc_input_select,\n\t.capabilities = hw_capabilities,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = hw_suspend,\n\t.resume = hw_resume,\n#endif\n\n\t.src_rsc_get_ctrl_blk = src_get_rsc_ctrl_blk,\n\t.src_rsc_put_ctrl_blk = src_put_rsc_ctrl_blk,\n\t.src_mgr_get_ctrl_blk = src_mgr_get_ctrl_blk,\n\t.src_mgr_put_ctrl_blk = src_mgr_put_ctrl_blk,\n\t.src_set_state = src_set_state,\n\t.src_set_bm = src_set_bm,\n\t.src_set_rsr = src_set_rsr,\n\t.src_set_sf = src_set_sf,\n\t.src_set_wr = src_set_wr,\n\t.src_set_pm = src_set_pm,\n\t.src_set_rom = src_set_rom,\n\t.src_set_vo = src_set_vo,\n\t.src_set_st = src_set_st,\n\t.src_set_ie = src_set_ie,\n\t.src_set_ilsz = src_set_ilsz,\n\t.src_set_bp = src_set_bp,\n\t.src_set_cisz = src_set_cisz,\n\t.src_set_ca = src_set_ca,\n\t.src_set_sa = src_set_sa,\n\t.src_set_la = src_set_la,\n\t.src_set_pitch = src_set_pitch,\n\t.src_set_dirty = src_set_dirty,\n\t.src_set_clear_zbufs = src_set_clear_zbufs,\n\t.src_set_dirty_all = src_set_dirty_all,\n\t.src_commit_write = src_commit_write,\n\t.src_get_ca = src_get_ca,\n\t.src_get_dirty = src_get_dirty,\n\t.src_dirty_conj_mask = src_dirty_conj_mask,\n\t.src_mgr_enbs_src = src_mgr_enbs_src,\n\t.src_mgr_enb_src = src_mgr_enb_src,\n\t.src_mgr_dsb_src = src_mgr_dsb_src,\n\t.src_mgr_commit_write = src_mgr_commit_write,\n\n\t.srcimp_mgr_get_ctrl_blk = srcimp_mgr_get_ctrl_blk,\n\t.srcimp_mgr_put_ctrl_blk = srcimp_mgr_put_ctrl_blk,\n\t.srcimp_mgr_set_imaparc = srcimp_mgr_set_imaparc,\n\t.srcimp_mgr_set_imapuser = srcimp_mgr_set_imapuser,\n\t.srcimp_mgr_set_imapnxt = srcimp_mgr_set_imapnxt,\n\t.srcimp_mgr_set_imapaddr = srcimp_mgr_set_imapaddr,\n\t.srcimp_mgr_commit_write = srcimp_mgr_commit_write,\n\n\t.amixer_rsc_get_ctrl_blk = amixer_rsc_get_ctrl_blk,\n\t.amixer_rsc_put_ctrl_blk = amixer_rsc_put_ctrl_blk,\n\t.amixer_mgr_get_ctrl_blk = amixer_mgr_get_ctrl_blk,\n\t.amixer_mgr_put_ctrl_blk = amixer_mgr_put_ctrl_blk,\n\t.amixer_set_mode = amixer_set_mode,\n\t.amixer_set_iv = amixer_set_iv,\n\t.amixer_set_x = amixer_set_x,\n\t.amixer_set_y = amixer_set_y,\n\t.amixer_set_sadr = amixer_set_sadr,\n\t.amixer_set_se = amixer_set_se,\n\t.amixer_set_dirty = amixer_set_dirty,\n\t.amixer_set_dirty_all = amixer_set_dirty_all,\n\t.amixer_commit_write = amixer_commit_write,\n\t.amixer_get_y = amixer_get_y,\n\t.amixer_get_dirty = amixer_get_dirty,\n\n\t.dai_get_ctrl_blk = dai_get_ctrl_blk,\n\t.dai_put_ctrl_blk = dai_put_ctrl_blk,\n\t.dai_srt_set_srco = dai_srt_set_srcr,\n\t.dai_srt_set_srcm = dai_srt_set_srcl,\n\t.dai_srt_set_rsr = dai_srt_set_rsr,\n\t.dai_srt_set_drat = dai_srt_set_drat,\n\t.dai_srt_set_ec = dai_srt_set_ec,\n\t.dai_srt_set_et = dai_srt_set_et,\n\t.dai_commit_write = dai_commit_write,\n\n\t.dao_get_ctrl_blk = dao_get_ctrl_blk,\n\t.dao_put_ctrl_blk = dao_put_ctrl_blk,\n\t.dao_set_spos = dao_set_spos,\n\t.dao_commit_write = dao_commit_write,\n\t.dao_get_spos = dao_get_spos,\n\n\t.daio_mgr_get_ctrl_blk = daio_mgr_get_ctrl_blk,\n\t.daio_mgr_put_ctrl_blk = daio_mgr_put_ctrl_blk,\n\t.daio_mgr_enb_dai = daio_mgr_enb_dai,\n\t.daio_mgr_dsb_dai = daio_mgr_dsb_dai,\n\t.daio_mgr_enb_dao = daio_mgr_enb_dao,\n\t.daio_mgr_dsb_dao = daio_mgr_dsb_dao,\n\t.daio_mgr_dao_init = daio_mgr_dao_init,\n\t.daio_mgr_set_imaparc = daio_mgr_set_imaparc,\n\t.daio_mgr_set_imapnxt = daio_mgr_set_imapnxt,\n\t.daio_mgr_set_imapaddr = daio_mgr_set_imapaddr,\n\t.daio_mgr_commit_write = daio_mgr_commit_write,\n\n\t.set_timer_irq = set_timer_irq,\n\t.set_timer_tick = set_timer_tick,\n\t.get_wc = get_wc,\n};\n\nint create_20k1_hw_obj(struct hw **rhw)\n{\n\tstruct hw20k1 *hw20k1;\n\n\t*rhw = NULL;\n\thw20k1 = kzalloc(sizeof(*hw20k1), GFP_KERNEL);\n\tif (!hw20k1)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&hw20k1->reg_20k1_lock);\n\tspin_lock_init(&hw20k1->reg_pci_lock);\n\n\thw20k1->hw = ct20k1_preset;\n\n\t*rhw = &hw20k1->hw;\n\n\treturn 0;\n}\n\nint destroy_20k1_hw_obj(struct hw *hw)\n{\n\tif (hw->io_base)\n\t\thw_card_shutdown(hw);\n\n\tkfree(container_of(hw, struct hw20k1, hw));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}