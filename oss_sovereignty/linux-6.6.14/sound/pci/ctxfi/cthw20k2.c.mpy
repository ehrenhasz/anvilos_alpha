{
  "module_name": "cthw20k2.c",
  "hash_id": "01f3ad4757075ef8cc70b30df5cd4cec37988ebfff06aaa23649dc98d180bc07",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/cthw20k2.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include \"cthw20k2.h\"\n#include \"ct20k2reg.h\"\n\nstruct hw20k2 {\n\tstruct hw hw;\n\t \n\tunsigned char dev_id;\n\tunsigned char addr_size;\n\tunsigned char data_size;\n\n\tint mic_source;\n};\n\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg);\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data);\n\n \n\n \n\n \n#define SRCCTL_STATE\t0x00000007\n#define SRCCTL_BM\t0x00000008\n#define SRCCTL_RSR\t0x00000030\n#define SRCCTL_SF\t0x000001C0\n#define SRCCTL_WR\t0x00000200\n#define SRCCTL_PM\t0x00000400\n#define SRCCTL_ROM\t0x00001800\n#define SRCCTL_VO\t0x00002000\n#define SRCCTL_ST\t0x00004000\n#define SRCCTL_IE\t0x00008000\n#define SRCCTL_ILSZ\t0x000F0000\n#define SRCCTL_BP\t0x00100000\n\n#define SRCCCR_CISZ\t0x000007FF\n#define SRCCCR_CWA\t0x001FF800\n#define SRCCCR_D\t0x00200000\n#define SRCCCR_RS\t0x01C00000\n#define SRCCCR_NAL\t0x3E000000\n#define SRCCCR_RA\t0xC0000000\n\n#define SRCCA_CA\t0x0FFFFFFF\n#define SRCCA_RS\t0xE0000000\n\n#define SRCSA_SA\t0x0FFFFFFF\n\n#define SRCLA_LA\t0x0FFFFFFF\n\n \n#define MPRLH_PITCH\t0xFFFFFFFF\n\n \nunion src_dirty {\n\tstruct {\n\t\tu16 ctl:1;\n\t\tu16 ccr:1;\n\t\tu16 sa:1;\n\t\tu16 la:1;\n\t\tu16 ca:1;\n\t\tu16 mpr:1;\n\t\tu16 czbfs:1;\t \n\t\tu16 rsv:9;\n\t} bf;\n\tu16 data;\n};\n\nstruct src_rsc_ctrl_blk {\n\tunsigned int\tctl;\n\tunsigned int \tccr;\n\tunsigned int\tca;\n\tunsigned int\tsa;\n\tunsigned int\tla;\n\tunsigned int\tmpr;\n\tunion src_dirty\tdirty;\n};\n\n \nunion src_mgr_dirty {\n\tstruct {\n\t\tu16 enb0:1;\n\t\tu16 enb1:1;\n\t\tu16 enb2:1;\n\t\tu16 enb3:1;\n\t\tu16 enb4:1;\n\t\tu16 enb5:1;\n\t\tu16 enb6:1;\n\t\tu16 enb7:1;\n\t\tu16 enbsa:1;\n\t\tu16 rsv:7;\n\t} bf;\n\tu16 data;\n};\n\nstruct src_mgr_ctrl_blk {\n\tunsigned int\t\tenbsa;\n\tunsigned int\t\tenb[8];\n\tunion src_mgr_dirty\tdirty;\n};\n\n \n#define SRCAIM_ARC\t0x00000FFF\n#define SRCAIM_NXT\t0x00FF0000\n#define SRCAIM_SRC\t0xFF000000\n\nstruct srcimap {\n\tunsigned int srcaim;\n\tunsigned int idx;\n};\n\n \nunion srcimp_mgr_dirty {\n\tstruct {\n\t\tu16 srcimap:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\nstruct srcimp_mgr_ctrl_blk {\n\tstruct srcimap\t\tsrcimap;\n\tunion srcimp_mgr_dirty\tdirty;\n};\n\n \n\nstatic int src_get_rsc_ctrl_blk(void **rblk)\n{\n\tstruct src_rsc_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int src_put_rsc_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int src_set_state(void *blk, unsigned int state)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_STATE, state);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_bm(void *blk, unsigned int bm)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_BM, bm);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_rsr(void *blk, unsigned int rsr)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_RSR, rsr);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_sf(void *blk, unsigned int sf)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_SF, sf);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_wr(void *blk, unsigned int wr)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_WR, wr);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_pm(void *blk, unsigned int pm)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_PM, pm);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_rom(void *blk, unsigned int rom)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ROM, rom);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_vo(void *blk, unsigned int vo)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_VO, vo);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_st(void *blk, unsigned int st)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ST, st);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_ie(void *blk, unsigned int ie)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_IE, ie);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_ilsz(void *blk, unsigned int ilsz)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_ILSZ, ilsz);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_bp(void *blk, unsigned int bp)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ctl, SRCCTL_BP, bp);\n\tctl->dirty.bf.ctl = 1;\n\treturn 0;\n}\n\nstatic int src_set_cisz(void *blk, unsigned int cisz)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ccr, SRCCCR_CISZ, cisz);\n\tctl->dirty.bf.ccr = 1;\n\treturn 0;\n}\n\nstatic int src_set_ca(void *blk, unsigned int ca)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->ca, SRCCA_CA, ca);\n\tctl->dirty.bf.ca = 1;\n\treturn 0;\n}\n\nstatic int src_set_sa(void *blk, unsigned int sa)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->sa, SRCSA_SA, sa);\n\tctl->dirty.bf.sa = 1;\n\treturn 0;\n}\n\nstatic int src_set_la(void *blk, unsigned int la)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->la, SRCLA_LA, la);\n\tctl->dirty.bf.la = 1;\n\treturn 0;\n}\n\nstatic int src_set_pitch(void *blk, unsigned int pitch)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->mpr, MPRLH_PITCH, pitch);\n\tctl->dirty.bf.mpr = 1;\n\treturn 0;\n}\n\nstatic int src_set_clear_zbufs(void *blk, unsigned int clear)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.bf.czbfs = (clear ? 1 : 0);\n\treturn 0;\n}\n\nstatic int src_set_dirty(void *blk, unsigned int flags)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\n\treturn 0;\n}\n\nstatic int src_set_dirty_all(void *blk)\n{\n\t((struct src_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\n\treturn 0;\n}\n\n#define AR_SLOT_SIZE\t\t4096\n#define AR_SLOT_BLOCK_SIZE\t16\n#define AR_PTS_PITCH\t\t6\n#define AR_PARAM_SRC_OFFSET\t0x60\n\nstatic unsigned int src_param_pitch_mixer(unsigned int src_idx)\n{\n\treturn ((src_idx << 4) + AR_PTS_PITCH + AR_SLOT_SIZE\n\t\t\t- AR_PARAM_SRC_OFFSET) % AR_SLOT_SIZE;\n\n}\n\nstatic int src_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\tint i;\n\n\tif (ctl->dirty.bf.czbfs) {\n\t\t \n\t\tfor (i = 0; i < 8; i++)\n\t\t\thw_write_20kx(hw, SRC_UPZ+idx*0x100+i*0x4, 0);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thw_write_20kx(hw, SRC_DN0Z+idx*0x100+i*0x4, 0);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\thw_write_20kx(hw, SRC_DN1Z+idx*0x100+i*0x4, 0);\n\n\t\tctl->dirty.bf.czbfs = 0;\n\t}\n\tif (ctl->dirty.bf.mpr) {\n\t\t \n\t\tunsigned int pm_idx = src_param_pitch_mixer(idx);\n\t\thw_write_20kx(hw, MIXER_PRING_LO_HI+4*pm_idx, ctl->mpr);\n\t\thw_write_20kx(hw, MIXER_PMOPLO+8*pm_idx, 0x3);\n\t\thw_write_20kx(hw, MIXER_PMOPHI+8*pm_idx, 0x0);\n\t\tctl->dirty.bf.mpr = 0;\n\t}\n\tif (ctl->dirty.bf.sa) {\n\t\thw_write_20kx(hw, SRC_SA+idx*0x100, ctl->sa);\n\t\tctl->dirty.bf.sa = 0;\n\t}\n\tif (ctl->dirty.bf.la) {\n\t\thw_write_20kx(hw, SRC_LA+idx*0x100, ctl->la);\n\t\tctl->dirty.bf.la = 0;\n\t}\n\tif (ctl->dirty.bf.ca) {\n\t\thw_write_20kx(hw, SRC_CA+idx*0x100, ctl->ca);\n\t\tctl->dirty.bf.ca = 0;\n\t}\n\n\t \n\thw_write_20kx(hw, SRC_CF+idx*0x100, 0x0);\n\n\tif (ctl->dirty.bf.ccr) {\n\t\thw_write_20kx(hw, SRC_CCR+idx*0x100, ctl->ccr);\n\t\tctl->dirty.bf.ccr = 0;\n\t}\n\tif (ctl->dirty.bf.ctl) {\n\t\thw_write_20kx(hw, SRC_CTL+idx*0x100, ctl->ctl);\n\t\tctl->dirty.bf.ctl = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int src_get_ca(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct src_rsc_ctrl_blk *ctl = blk;\n\n\tctl->ca = hw_read_20kx(hw, SRC_CA+idx*0x100);\n\tctl->dirty.bf.ca = 0;\n\n\treturn get_field(ctl->ca, SRCCA_CA);\n}\n\nstatic unsigned int src_get_dirty(void *blk)\n{\n\treturn ((struct src_rsc_ctrl_blk *)blk)->dirty.data;\n}\n\nstatic unsigned int src_dirty_conj_mask(void)\n{\n\treturn 0x20;\n}\n\nstatic int src_mgr_enbs_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enbsa |= (0x1 << ((idx%128)/4));\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.bf.enbsa = 1;\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\n\treturn 0;\n}\n\nstatic int src_mgr_enb_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\n\treturn 0;\n}\n\nstatic int src_mgr_dsb_src(void *blk, unsigned int idx)\n{\n\t((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] &= ~(0x1 << (idx%32));\n\t((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\n\treturn 0;\n}\n\nstatic int src_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct src_mgr_ctrl_blk *ctl = blk;\n\tint i;\n\tunsigned int ret;\n\n\tif (ctl->dirty.bf.enbsa) {\n\t\tdo {\n\t\t\tret = hw_read_20kx(hw, SRC_ENBSTAT);\n\t\t} while (ret & 0x1);\n\t\thw_write_20kx(hw, SRC_ENBSA, ctl->enbsa);\n\t\tctl->dirty.bf.enbsa = 0;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((ctl->dirty.data & (0x1 << i))) {\n\t\t\thw_write_20kx(hw, SRC_ENB+(i*0x100), ctl->enb[i]);\n\t\t\tctl->dirty.data &= ~(0x1 << i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int src_mgr_get_ctrl_blk(void **rblk)\n{\n\tstruct src_mgr_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int src_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_get_ctrl_blk(void **rblk)\n{\n\tstruct srcimp_mgr_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imaparc(void *blk, unsigned int slot)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_ARC, slot);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapuser(void *blk, unsigned int user)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_SRC, user);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapnxt(void *blk, unsigned int next)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srcimap.srcaim, SRCAIM_NXT, next);\n\tctl->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_set_imapaddr(void *blk, unsigned int addr)\n{\n\t((struct srcimp_mgr_ctrl_blk *)blk)->srcimap.idx = addr;\n\t((struct srcimp_mgr_ctrl_blk *)blk)->dirty.bf.srcimap = 1;\n\treturn 0;\n}\n\nstatic int srcimp_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct srcimp_mgr_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.srcimap) {\n\t\thw_write_20kx(hw, SRC_IMAP+ctl->srcimap.idx*0x100,\n\t\t\t\t\t\tctl->srcimap.srcaim);\n\t\tctl->dirty.bf.srcimap = 0;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define AMOPLO_M\t0x00000003\n#define AMOPLO_IV\t0x00000004\n#define AMOPLO_X\t0x0003FFF0\n#define AMOPLO_Y\t0xFFFC0000\n\n#define AMOPHI_SADR\t0x000000FF\n#define AMOPHI_SE\t0x80000000\n\n \nunion amixer_dirty {\n\tstruct {\n\t\tu16 amoplo:1;\n\t\tu16 amophi:1;\n\t\tu16 rsv:14;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct amixer_rsc_ctrl_blk {\n\tunsigned int\t\tamoplo;\n\tunsigned int\t\tamophi;\n\tunion amixer_dirty\tdirty;\n};\n\nstatic int amixer_set_mode(void *blk, unsigned int mode)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_M, mode);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_iv(void *blk, unsigned int iv)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_IV, iv);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_x(void *blk, unsigned int x)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_X, x);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_y(void *blk, unsigned int y)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amoplo, AMOPLO_Y, y);\n\tctl->dirty.bf.amoplo = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_sadr(void *blk, unsigned int sadr)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amophi, AMOPHI_SADR, sadr);\n\tctl->dirty.bf.amophi = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_se(void *blk, unsigned int se)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->amophi, AMOPHI_SE, se);\n\tctl->dirty.bf.amophi = 1;\n\treturn 0;\n}\n\nstatic int amixer_set_dirty(void *blk, unsigned int flags)\n{\n\t((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\n\treturn 0;\n}\n\nstatic int amixer_set_dirty_all(void *blk)\n{\n\t((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\n\treturn 0;\n}\n\nstatic int amixer_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.amoplo || ctl->dirty.bf.amophi) {\n\t\thw_write_20kx(hw, MIXER_AMOPLO+idx*8, ctl->amoplo);\n\t\tctl->dirty.bf.amoplo = 0;\n\t\thw_write_20kx(hw, MIXER_AMOPHI+idx*8, ctl->amophi);\n\t\tctl->dirty.bf.amophi = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int amixer_get_y(void *blk)\n{\n\tstruct amixer_rsc_ctrl_blk *ctl = blk;\n\n\treturn get_field(ctl->amoplo, AMOPLO_Y);\n}\n\nstatic unsigned int amixer_get_dirty(void *blk)\n{\n\treturn ((struct amixer_rsc_ctrl_blk *)blk)->dirty.data;\n}\n\nstatic int amixer_rsc_get_ctrl_blk(void **rblk)\n{\n\tstruct amixer_rsc_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int amixer_rsc_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int amixer_mgr_get_ctrl_blk(void **rblk)\n{\n\t*rblk = NULL;\n\n\treturn 0;\n}\n\nstatic int amixer_mgr_put_ctrl_blk(void *blk)\n{\n\treturn 0;\n}\n\n \n\n \n#define SRTCTL_SRCO\t0x000000FF\n#define SRTCTL_SRCM\t0x0000FF00\n#define SRTCTL_RSR\t0x00030000\n#define SRTCTL_DRAT\t0x00300000\n#define SRTCTL_EC\t0x01000000\n#define SRTCTL_ET\t0x10000000\n\n \nunion dai_dirty {\n\tstruct {\n\t\tu16 srt:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct dai_ctrl_blk {\n\tunsigned int\tsrt;\n\tunion dai_dirty\tdirty;\n};\n\n \n#define AIM_ARC\t\t0x00000FFF\n#define AIM_NXT\t\t0x007F0000\n\nstruct daoimap {\n\tunsigned int aim;\n\tunsigned int idx;\n};\n\n \n#define ATXCTL_EN\t0x00000001\n#define ATXCTL_MODE\t0x00000010\n#define ATXCTL_CD\t0x00000020\n#define ATXCTL_RAW\t0x00000100\n#define ATXCTL_MT\t0x00000200\n#define ATXCTL_NUC\t0x00003000\n#define ATXCTL_BEN\t0x00010000\n#define ATXCTL_BMUX\t0x00700000\n#define ATXCTL_B24\t0x01000000\n#define ATXCTL_CPF\t0x02000000\n#define ATXCTL_RIV\t0x10000000\n#define ATXCTL_LIV\t0x20000000\n#define ATXCTL_RSAT\t0x40000000\n#define ATXCTL_LSAT\t0x80000000\n\n \nunion dao_dirty {\n\tstruct {\n\t\tu16 atxcsl:1;\n\t\tu16 rsv:15;\n\t} bf;\n\tu16 data;\n};\n\n \nstruct dao_ctrl_blk {\n\t \n\tunsigned int\tatxcsl;\n\tunion dao_dirty\tdirty;\n};\n\n \n#define ARXCTL_EN\t0x00000001\n\n \nunion daio_mgr_dirty {\n\tstruct {\n\t\tu32 atxctl:8;\n\t\tu32 arxctl:8;\n\t\tu32 daoimap:1;\n\t\tu32 rsv:15;\n\t} bf;\n\tu32 data;\n};\n\n \nstruct daio_mgr_ctrl_blk {\n\tstruct daoimap\t\tdaoimap;\n\tunsigned int\t\ttxctl[8];\n\tunsigned int\t\trxctl[8];\n\tunion daio_mgr_dirty\tdirty;\n};\n\nstatic int dai_srt_set_srco(void *blk, unsigned int src)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_SRCO, src);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_srcm(void *blk, unsigned int src)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_SRCM, src);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_rsr(void *blk, unsigned int rsr)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_RSR, rsr);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_drat(void *blk, unsigned int drat)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_DRAT, drat);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_ec(void *blk, unsigned int ec)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_EC, ec ? 1 : 0);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_srt_set_et(void *blk, unsigned int et)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->srt, SRTCTL_ET, et ? 1 : 0);\n\tctl->dirty.bf.srt = 1;\n\treturn 0;\n}\n\nstatic int dai_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct dai_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.srt) {\n\t\thw_write_20kx(hw, AUDIO_IO_RX_SRT_CTL+0x40*idx, ctl->srt);\n\t\tctl->dirty.bf.srt = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dai_get_ctrl_blk(void **rblk)\n{\n\tstruct dai_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int dai_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int dao_set_spos(void *blk, unsigned int spos)\n{\n\t((struct dao_ctrl_blk *)blk)->atxcsl = spos;\n\t((struct dao_ctrl_blk *)blk)->dirty.bf.atxcsl = 1;\n\treturn 0;\n}\n\nstatic int dao_commit_write(struct hw *hw, unsigned int idx, void *blk)\n{\n\tstruct dao_ctrl_blk *ctl = blk;\n\n\tif (ctl->dirty.bf.atxcsl) {\n\t\tif (idx < 4) {\n\t\t\t \n\t\t\thw_write_20kx(hw, AUDIO_IO_TX_CSTAT_L+0x40*idx,\n\t\t\t\t\t\t\tctl->atxcsl);\n\t\t}\n\t\tctl->dirty.bf.atxcsl = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dao_get_spos(void *blk, unsigned int *spos)\n{\n\t*spos = ((struct dao_ctrl_blk *)blk)->atxcsl;\n\treturn 0;\n}\n\nstatic int dao_get_ctrl_blk(void **rblk)\n{\n\tstruct dao_ctrl_blk *blk;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int dao_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\nstatic int daio_mgr_enb_dai(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->rxctl[idx], ARXCTL_EN, 1);\n\tctl->dirty.bf.arxctl |= (0x1 << idx);\n\treturn 0;\n}\n\nstatic int daio_mgr_dsb_dai(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->rxctl[idx], ARXCTL_EN, 0);\n\n\tctl->dirty.bf.arxctl |= (0x1 << idx);\n\treturn 0;\n}\n\nstatic int daio_mgr_enb_dao(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->txctl[idx], ATXCTL_EN, 1);\n\tctl->dirty.bf.atxctl |= (0x1 << idx);\n\treturn 0;\n}\n\nstatic int daio_mgr_dsb_dao(void *blk, unsigned int idx)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->txctl[idx], ATXCTL_EN, 0);\n\tctl->dirty.bf.atxctl |= (0x1 << idx);\n\treturn 0;\n}\n\nstatic int daio_mgr_dao_init(void *blk, unsigned int idx, unsigned int conf)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tif (idx < 4) {\n\t\t \n\t\tswitch ((conf & 0xf)) {\n\t\tcase 1:\n\t\t\tset_field(&ctl->txctl[idx], ATXCTL_NUC, 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset_field(&ctl->txctl[idx], ATXCTL_NUC, 1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tset_field(&ctl->txctl[idx], ATXCTL_NUC, 2);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tset_field(&ctl->txctl[idx], ATXCTL_NUC, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tset_field(&ctl->txctl[idx], ATXCTL_CD, (!(conf & 0x7)));\n\t\t \n\t\tset_field(&ctl->txctl[idx], ATXCTL_LIV, (conf >> 4) & 0x1);\n\t\t \n\t\tset_field(&ctl->txctl[idx], ATXCTL_RIV, (conf >> 4) & 0x1);\n\t\tset_field(&ctl->txctl[idx], ATXCTL_RAW,\n\t\t\t  ((conf >> 3) & 0x1) ? 0 : 0);\n\t\tctl->dirty.bf.atxctl |= (0x1 << idx);\n\t} else {\n\t\t \n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imaparc(void *blk, unsigned int slot)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->daoimap.aim, AIM_ARC, slot);\n\tctl->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imapnxt(void *blk, unsigned int next)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\n\tset_field(&ctl->daoimap.aim, AIM_NXT, next);\n\tctl->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_set_imapaddr(void *blk, unsigned int addr)\n{\n\t((struct daio_mgr_ctrl_blk *)blk)->daoimap.idx = addr;\n\t((struct daio_mgr_ctrl_blk *)blk)->dirty.bf.daoimap = 1;\n\treturn 0;\n}\n\nstatic int daio_mgr_commit_write(struct hw *hw, void *blk)\n{\n\tstruct daio_mgr_ctrl_blk *ctl = blk;\n\tunsigned int data;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((ctl->dirty.bf.atxctl & (0x1 << i))) {\n\t\t\tdata = ctl->txctl[i];\n\t\t\thw_write_20kx(hw, (AUDIO_IO_TX_CTL+(0x40*i)), data);\n\t\t\tctl->dirty.bf.atxctl &= ~(0x1 << i);\n\t\t\tmdelay(1);\n\t\t}\n\t\tif ((ctl->dirty.bf.arxctl & (0x1 << i))) {\n\t\t\tdata = ctl->rxctl[i];\n\t\t\thw_write_20kx(hw, (AUDIO_IO_RX_CTL+(0x40*i)), data);\n\t\t\tctl->dirty.bf.arxctl &= ~(0x1 << i);\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\tif (ctl->dirty.bf.daoimap) {\n\t\thw_write_20kx(hw, AUDIO_IO_AIM+ctl->daoimap.idx*4,\n\t\t\t\t\t\tctl->daoimap.aim);\n\t\tctl->dirty.bf.daoimap = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int daio_mgr_get_ctrl_blk(struct hw *hw, void **rblk)\n{\n\tstruct daio_mgr_ctrl_blk *blk;\n\tint i;\n\n\t*rblk = NULL;\n\tblk = kzalloc(sizeof(*blk), GFP_KERNEL);\n\tif (!blk)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tblk->txctl[i] = hw_read_20kx(hw, AUDIO_IO_TX_CTL+(0x40*i));\n\t\tblk->rxctl[i] = hw_read_20kx(hw, AUDIO_IO_RX_CTL+(0x40*i));\n\t}\n\n\t*rblk = blk;\n\n\treturn 0;\n}\n\nstatic int daio_mgr_put_ctrl_blk(void *blk)\n{\n\tkfree(blk);\n\n\treturn 0;\n}\n\n \nstatic int set_timer_irq(struct hw *hw, int enable)\n{\n\thw_write_20kx(hw, GIE, enable ? IT_INT : 0);\n\treturn 0;\n}\n\nstatic int set_timer_tick(struct hw *hw, unsigned int ticks)\n{\n\tif (ticks)\n\t\tticks |= TIMR_IE | TIMR_IP;\n\thw_write_20kx(hw, TIMR, ticks);\n\treturn 0;\n}\n\nstatic unsigned int get_wc(struct hw *hw)\n{\n\treturn hw_read_20kx(hw, WC);\n}\n\n \nstruct dac_conf {\n\tunsigned int msr;  \n};\n\nstruct adc_conf {\n\tunsigned int msr; \t \n\tunsigned char input; \t \n\tunsigned char mic20db; \t \n};\n\nstruct daio_conf {\n\tunsigned int msr;  \n};\n\nstruct trn_conf {\n\tunsigned long vm_pgt_phys;\n};\n\nstatic int hw_daio_init(struct hw *hw, const struct daio_conf *info)\n{\n\tu32 data;\n\tint i;\n\n\t \n\tif (1 == info->msr) {\n\t\thw_write_20kx(hw, AUDIO_IO_MCLK, 0x01010101);\n\t\thw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x01010101);\n\t\thw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\n\t} else if (2 == info->msr) {\n\t\tif (hw->model != CTSB1270) {\n\t\t\thw_write_20kx(hw, AUDIO_IO_MCLK, 0x11111111);\n\t\t} else {\n\t\t\t \n\t\t\thw_write_20kx(hw, AUDIO_IO_MCLK, 0x11011111);\n\t\t}\n\t\t \n\t\thw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x11111111);\n\t\thw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\n\t} else if ((4 == info->msr) && (hw->model == CTSB1270)) {\n\t\thw_write_20kx(hw, AUDIO_IO_MCLK, 0x21011111);\n\t\thw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x21212121);\n\t\thw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\n\t} else {\n\t\tdev_alert(hw->card->dev,\n\t\t\t  \"ERROR!!! Invalid sampling rate!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i <= 3) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tif (i == 3)\n\t\t\t\tdata = 0x1001001;\n\t\t\telse\n\t\t\t\tdata = 0x1000001;\n\n\t\t\thw_write_20kx(hw, (AUDIO_IO_TX_CTL+(0x40*i)), data);\n\t\t\thw_write_20kx(hw, (AUDIO_IO_RX_CTL+(0x40*i)), data);\n\n\t\t\t \n\n\t\t\thw_write_20kx(hw, AUDIO_IO_TX_CSTAT_L+(0x40*i),\n\t\t\t\t\t0x02109204);  \n\n\t\t\thw_write_20kx(hw, AUDIO_IO_TX_CSTAT_H+(0x40*i), 0x0B);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tdata = 0x11;\n\t\t\thw_write_20kx(hw, AUDIO_IO_RX_CTL+(0x40*i), data);\n\t\t\tif (2 == info->msr) {\n\t\t\t\t \n\t\t\t\tdata |= 0x1000;\n\t\t\t} else if (4 == info->msr) {\n\t\t\t\t \n\t\t\t\tdata |= 0x2000;\n\t\t\t}\n\t\t\thw_write_20kx(hw, AUDIO_IO_TX_CTL+(0x40*i), data);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hw_trn_init(struct hw *hw, const struct trn_conf *info)\n{\n\tu32 vmctl, data;\n\tu32 ptp_phys_low, ptp_phys_high;\n\tint i;\n\n\t \n\tif ((~0UL) == info->vm_pgt_phys) {\n\t\tdev_alert(hw->card->dev,\n\t\t\t  \"Wrong device page table page address!!!\\n\");\n\t\treturn -1;\n\t}\n\n\tvmctl = 0x80000C0F;   \n\tptp_phys_low = (u32)info->vm_pgt_phys;\n\tptp_phys_high = upper_32_bits(info->vm_pgt_phys);\n\tif (sizeof(void *) == 8)  \n\t\tvmctl |= (3 << 8);\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\thw_write_20kx(hw, VMEM_PTPAL+(16*i), ptp_phys_low);\n\t\thw_write_20kx(hw, VMEM_PTPAH+(16*i), ptp_phys_high);\n\t}\n\t \n\thw_write_20kx(hw, VMEM_CTL, vmctl);\n\t \n\thw_write_20kx(hw, TRANSPORT_CTL, 0x03);\n\thw_write_20kx(hw, TRANSPORT_INT, 0x200c01);\n\t \n\tdata = hw_read_20kx(hw, TRANSPORT_ENB);\n\thw_write_20kx(hw, TRANSPORT_ENB, (data | 0x03));\n\n\treturn 0;\n}\n\n \n#define GCTL_AIE\t0x00000001\n#define GCTL_UAA\t0x00000002\n#define GCTL_DPC\t0x00000004\n#define GCTL_DBP\t0x00000008\n#define GCTL_ABP\t0x00000010\n#define GCTL_TBP\t0x00000020\n#define GCTL_SBP\t0x00000040\n#define GCTL_FBP\t0x00000080\n#define GCTL_ME\t\t0x00000100\n#define GCTL_AID\t0x00001000\n\n#define PLLCTL_SRC\t0x00000007\n#define PLLCTL_SPE\t0x00000008\n#define PLLCTL_RD\t0x000000F0\n#define PLLCTL_FD\t0x0001FF00\n#define PLLCTL_OD\t0x00060000\n#define PLLCTL_B\t0x00080000\n#define PLLCTL_AS\t0x00100000\n#define PLLCTL_LF\t0x03E00000\n#define PLLCTL_SPS\t0x1C000000\n#define PLLCTL_AD\t0x60000000\n\n#define PLLSTAT_CCS\t0x00000007\n#define PLLSTAT_SPL\t0x00000008\n#define PLLSTAT_CRD\t0x000000F0\n#define PLLSTAT_CFD\t0x0001FF00\n#define PLLSTAT_SL\t0x00020000\n#define PLLSTAT_FAS\t0x00040000\n#define PLLSTAT_B\t0x00080000\n#define PLLSTAT_PD\t0x00100000\n#define PLLSTAT_OCA\t0x00200000\n#define PLLSTAT_NCA\t0x00400000\n\nstatic int hw_pll_init(struct hw *hw, unsigned int rsr)\n{\n\tunsigned int pllenb;\n\tunsigned int pllctl;\n\tunsigned int pllstat;\n\tint i;\n\n\tpllenb = 0xB;\n\thw_write_20kx(hw, PLL_ENB, pllenb);\n\tpllctl = 0x20C00000;\n\tset_field(&pllctl, PLLCTL_B, 0);\n\tset_field(&pllctl, PLLCTL_FD, 48000 == rsr ? 16 - 4 : 147 - 4);\n\tset_field(&pllctl, PLLCTL_RD, 48000 == rsr ? 1 - 1 : 10 - 1);\n\thw_write_20kx(hw, PLL_CTL, pllctl);\n\tmsleep(40);\n\n\tpllctl = hw_read_20kx(hw, PLL_CTL);\n\tset_field(&pllctl, PLLCTL_FD, 48000 == rsr ? 16 - 2 : 147 - 2);\n\thw_write_20kx(hw, PLL_CTL, pllctl);\n\tmsleep(40);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tpllstat = hw_read_20kx(hw, PLL_STAT);\n\t\tif (get_field(pllstat, PLLSTAT_PD))\n\t\t\tcontinue;\n\n\t\tif (get_field(pllstat, PLLSTAT_B) !=\n\t\t\t\t\tget_field(pllctl, PLLCTL_B))\n\t\t\tcontinue;\n\n\t\tif (get_field(pllstat, PLLSTAT_CCS) !=\n\t\t\t\t\tget_field(pllctl, PLLCTL_SRC))\n\t\t\tcontinue;\n\n\t\tif (get_field(pllstat, PLLSTAT_CRD) !=\n\t\t\t\t\tget_field(pllctl, PLLCTL_RD))\n\t\t\tcontinue;\n\n\t\tif (get_field(pllstat, PLLSTAT_CFD) !=\n\t\t\t\t\tget_field(pllctl, PLLCTL_FD))\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\tif (i >= 1000) {\n\t\tdev_alert(hw->card->dev,\n\t\t\t  \"PLL initialization failed!!!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int hw_auto_init(struct hw *hw)\n{\n\tunsigned int gctl;\n\tint i;\n\n\tgctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\n\tset_field(&gctl, GCTL_AIE, 0);\n\thw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\n\tset_field(&gctl, GCTL_AIE, 1);\n\thw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\n\tmdelay(10);\n\tfor (i = 0; i < 400000; i++) {\n\t\tgctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\n\t\tif (get_field(gctl, GCTL_AID))\n\t\t\tbreak;\n\t}\n\tif (!get_field(gctl, GCTL_AID)) {\n\t\tdev_alert(hw->card->dev, \"Card Auto-init failed!!!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define CS4382_MC1 \t\t0x1\n#define CS4382_MC2 \t\t0x2\n#define CS4382_MC3\t\t0x3\n#define CS4382_FC\t\t0x4\n#define CS4382_IC\t\t0x5\n#define CS4382_XC1\t\t0x6\n#define CS4382_VCA1 \t\t0x7\n#define CS4382_VCB1 \t\t0x8\n#define CS4382_XC2\t\t0x9\n#define CS4382_VCA2 \t\t0xA\n#define CS4382_VCB2 \t\t0xB\n#define CS4382_XC3\t\t0xC\n#define CS4382_VCA3\t\t0xD\n#define CS4382_VCB3\t\t0xE\n#define CS4382_XC4 \t\t0xF\n#define CS4382_VCA4 \t\t0x10\n#define CS4382_VCB4 \t\t0x11\n#define CS4382_CREV \t\t0x12\n\n \n#define STATE_LOCKED\t\t0x00\n#define STATE_UNLOCKED\t\t0xAA\n#define DATA_READY\t\t0x800000     \n#define DATA_ABORT\t\t0x10000      \n\n#define I2C_STATUS_DCM\t0x00000001\n#define I2C_STATUS_BC\t0x00000006\n#define I2C_STATUS_APD\t0x00000008\n#define I2C_STATUS_AB\t0x00010000\n#define I2C_STATUS_DR\t0x00800000\n\n#define I2C_ADDRESS_PTAD\t0x0000FFFF\n#define I2C_ADDRESS_SLAD\t0x007F0000\n\nstruct regs_cs4382 {\n\tu32 mode_control_1;\n\tu32 mode_control_2;\n\tu32 mode_control_3;\n\n\tu32 filter_control;\n\tu32 invert_control;\n\n\tu32 mix_control_P1;\n\tu32 vol_control_A1;\n\tu32 vol_control_B1;\n\n\tu32 mix_control_P2;\n\tu32 vol_control_A2;\n\tu32 vol_control_B2;\n\n\tu32 mix_control_P3;\n\tu32 vol_control_A3;\n\tu32 vol_control_B3;\n\n\tu32 mix_control_P4;\n\tu32 vol_control_A4;\n\tu32 vol_control_B4;\n};\n\nstatic int hw20k2_i2c_unlock_full_access(struct hw *hw)\n{\n\tu8 UnlockKeySequence_FLASH_FULLACCESS_MODE[2] =  {0xB3, 0xD4};\n\n\t \n\thw_write_20kx(hw, I2C_IF_WLOCK,\n\t\t\tUnlockKeySequence_FLASH_FULLACCESS_MODE[0]);\n\thw_write_20kx(hw, I2C_IF_WLOCK,\n\t\t\tUnlockKeySequence_FLASH_FULLACCESS_MODE[1]);\n\t \n\tif (hw_read_20kx(hw, I2C_IF_WLOCK) == STATE_UNLOCKED)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic int hw20k2_i2c_lock_chip(struct hw *hw)\n{\n\t \n\thw_write_20kx(hw, I2C_IF_WLOCK, STATE_LOCKED);\n\thw_write_20kx(hw, I2C_IF_WLOCK, STATE_LOCKED);\n\tif (hw_read_20kx(hw, I2C_IF_WLOCK) == STATE_LOCKED)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic int hw20k2_i2c_init(struct hw *hw, u8 dev_id, u8 addr_size, u8 data_size)\n{\n\tstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\n\tint err;\n\tunsigned int i2c_status;\n\tunsigned int i2c_addr;\n\n\terr = hw20k2_i2c_unlock_full_access(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thw20k2->addr_size = addr_size;\n\thw20k2->data_size = data_size;\n\thw20k2->dev_id = dev_id;\n\n\ti2c_addr = 0;\n\tset_field(&i2c_addr, I2C_ADDRESS_SLAD, dev_id);\n\n\thw_write_20kx(hw, I2C_IF_ADDRESS, i2c_addr);\n\n\ti2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\n\n\tset_field(&i2c_status, I2C_STATUS_DCM, 1);  \n\n\thw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\n\n\treturn 0;\n}\n\nstatic int hw20k2_i2c_uninit(struct hw *hw)\n{\n\tunsigned int i2c_status;\n\tunsigned int i2c_addr;\n\n\ti2c_addr = 0;\n\tset_field(&i2c_addr, I2C_ADDRESS_SLAD, 0x57);  \n\n\thw_write_20kx(hw, I2C_IF_ADDRESS, i2c_addr);\n\n\ti2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\n\n\tset_field(&i2c_status, I2C_STATUS_DCM, 0);  \n\n\thw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\n\n\treturn hw20k2_i2c_lock_chip(hw);\n}\n\nstatic int hw20k2_i2c_wait_data_ready(struct hw *hw)\n{\n\tint i = 0x400000;\n\tunsigned int ret;\n\n\tdo {\n\t\tret = hw_read_20kx(hw, I2C_IF_STATUS);\n\t} while ((!(ret & DATA_READY)) && --i);\n\n\treturn i;\n}\n\nstatic int hw20k2_i2c_read(struct hw *hw, u16 addr, u32 *datap)\n{\n\tstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\n\tunsigned int i2c_status;\n\n\ti2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\n\tset_field(&i2c_status, I2C_STATUS_BC,\n\t\t  (4 == hw20k2->addr_size) ? 0 : hw20k2->addr_size);\n\thw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\n\tif (!hw20k2_i2c_wait_data_ready(hw))\n\t\treturn -1;\n\n\thw_write_20kx(hw, I2C_IF_WDATA, addr);\n\tif (!hw20k2_i2c_wait_data_ready(hw))\n\t\treturn -1;\n\n\t \n\thw_write_20kx(hw, I2C_IF_RDATA, 0);\n\tif (!hw20k2_i2c_wait_data_ready(hw))\n\t\treturn -1;\n\n\t*datap = hw_read_20kx(hw, I2C_IF_RDATA);\n\n\treturn 0;\n}\n\nstatic int hw20k2_i2c_write(struct hw *hw, u16 addr, u32 data)\n{\n\tstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\n\tunsigned int i2c_data = (data << (hw20k2->addr_size * 8)) | addr;\n\tunsigned int i2c_status;\n\n\ti2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\n\n\tset_field(&i2c_status, I2C_STATUS_BC,\n\t\t  (4 == (hw20k2->addr_size + hw20k2->data_size)) ?\n\t\t  0 : (hw20k2->addr_size + hw20k2->data_size));\n\n\thw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\n\thw20k2_i2c_wait_data_ready(hw);\n\t \n\thw_write_20kx(hw, I2C_IF_WDATA, 0);\n\thw20k2_i2c_wait_data_ready(hw);\n\n\t \n\thw_write_20kx(hw, I2C_IF_WDATA, i2c_data);\n\thw20k2_i2c_wait_data_ready(hw);\n\n\treturn 0;\n}\n\nstatic void hw_dac_stop(struct hw *hw)\n{\n\tu32 data;\n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tdata &= 0xFFFFFFFD;\n\thw_write_20kx(hw, GPIO_DATA, data);\n\tusleep_range(10000, 11000);\n}\n\nstatic void hw_dac_start(struct hw *hw)\n{\n\tu32 data;\n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tdata |= 0x2;\n\thw_write_20kx(hw, GPIO_DATA, data);\n\tmsleep(50);\n}\n\nstatic void hw_dac_reset(struct hw *hw)\n{\n\thw_dac_stop(hw);\n\thw_dac_start(hw);\n}\n\nstatic int hw_dac_init(struct hw *hw, const struct dac_conf *info)\n{\n\tint err;\n\tu32 data;\n\tint i;\n\tstruct regs_cs4382 cs_read = {0};\n\tstruct regs_cs4382 cs_def = {\n\t\t.mode_control_1 = 0x00000001,  \n\t\t.mode_control_2 = 0x00000000,  \n\t\t.mode_control_3 = 0x00000084,  \n\t\t.filter_control = 0x00000000,  \n\t\t.invert_control = 0x00000000,  \n\t\t.mix_control_P1 = 0x00000024,  \n\t\t.vol_control_A1 = 0x00000000,  \n\t\t.vol_control_B1 = 0x00000000,  \n\t\t.mix_control_P2 = 0x00000024,  \n\t\t.vol_control_A2 = 0x00000000,  \n\t\t.vol_control_B2 = 0x00000000,  \n\t\t.mix_control_P3 = 0x00000024,  \n\t\t.vol_control_A3 = 0x00000000,  \n\t\t.vol_control_B3 = 0x00000000,  \n\t\t.mix_control_P4 = 0x00000024,  \n\t\t.vol_control_A4 = 0x00000000,  \n\t\t.vol_control_B4 = 0x00000000   \n\t\t\t\t };\n\n\tif (hw->model == CTSB1270) {\n\t\thw_dac_stop(hw);\n\t\tdata = hw_read_20kx(hw, GPIO_DATA);\n\t\tdata &= ~0x0600;\n\t\tif (1 == info->msr)\n\t\t\tdata |= 0x0000;  \n\t\telse if (2 == info->msr)\n\t\t\tdata |= 0x0200;  \n\t\telse\n\t\t\tdata |= 0x0600;  \n\t\thw_write_20kx(hw, GPIO_DATA, data);\n\t\thw_dac_start(hw);\n\t\treturn 0;\n\t}\n\n\t \n\tdata = hw_read_20kx(hw, GPIO_CTRL);\n\tdata |= 0x02;\n\thw_write_20kx(hw, GPIO_CTRL, data);\n\n\terr = hw20k2_i2c_init(hw, 0x18, 1, 1);\n\tif (err < 0)\n\t\tgoto End;\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\thw_dac_reset(hw);\n\t\thw_dac_reset(hw);\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_MC1,  &cs_read.mode_control_1))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_MC2,  &cs_read.mode_control_2))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_MC3,  &cs_read.mode_control_3))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_FC,   &cs_read.filter_control))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_IC,   &cs_read.invert_control))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_XC1,  &cs_read.mix_control_P1))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCA1, &cs_read.vol_control_A1))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCB1, &cs_read.vol_control_B1))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_XC2,  &cs_read.mix_control_P2))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCA2, &cs_read.vol_control_A2))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCB2, &cs_read.vol_control_B2))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_XC3,  &cs_read.mix_control_P3))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCA3, &cs_read.vol_control_A3))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCB3, &cs_read.vol_control_B3))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_XC4,  &cs_read.mix_control_P4))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCA4, &cs_read.vol_control_A4))\n\t\t\tcontinue;\n\n\t\tif (hw20k2_i2c_read(hw, CS4382_VCB4, &cs_read.vol_control_B4))\n\t\t\tcontinue;\n\n\t\tif (memcmp(&cs_read, &cs_def, sizeof(cs_read)))\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i >= 2)\n\t\tgoto End;\n\n\t \n\thw20k2_i2c_write(hw, CS4382_MC1, 0x80);\n\thw20k2_i2c_write(hw, CS4382_MC2, 0x10);\n\tif (1 == info->msr) {\n\t\thw20k2_i2c_write(hw, CS4382_XC1, 0x24);\n\t\thw20k2_i2c_write(hw, CS4382_XC2, 0x24);\n\t\thw20k2_i2c_write(hw, CS4382_XC3, 0x24);\n\t\thw20k2_i2c_write(hw, CS4382_XC4, 0x24);\n\t} else if (2 == info->msr) {\n\t\thw20k2_i2c_write(hw, CS4382_XC1, 0x25);\n\t\thw20k2_i2c_write(hw, CS4382_XC2, 0x25);\n\t\thw20k2_i2c_write(hw, CS4382_XC3, 0x25);\n\t\thw20k2_i2c_write(hw, CS4382_XC4, 0x25);\n\t} else {\n\t\thw20k2_i2c_write(hw, CS4382_XC1, 0x26);\n\t\thw20k2_i2c_write(hw, CS4382_XC2, 0x26);\n\t\thw20k2_i2c_write(hw, CS4382_XC3, 0x26);\n\t\thw20k2_i2c_write(hw, CS4382_XC4, 0x26);\n\t}\n\n\treturn 0;\nEnd:\n\n\thw20k2_i2c_uninit(hw);\n\treturn -1;\n}\n\n \n#define MAKE_WM8775_ADDR(addr, data)\t(u32)(((addr<<1)&0xFE)|((data>>8)&0x1))\n#define MAKE_WM8775_DATA(data)\t(u32)(data&0xFF)\n\n#define WM8775_IC       0x0B\n#define WM8775_MMC      0x0C\n#define WM8775_AADCL    0x0E\n#define WM8775_AADCR    0x0F\n#define WM8775_ADCMC    0x15\n#define WM8775_RESET    0x17\n\nstatic int hw_is_adc_input_selected(struct hw *hw, enum ADCSRC type)\n{\n\tu32 data;\n\tif (hw->model == CTSB1270) {\n\t\t \n\t\t \n\t\treturn 1;\n\t}\n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata = (data & (0x1 << 14)) ? 1 : 0;\n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata = (data & (0x1 << 14)) ? 0 : 1;\n\t\tbreak;\n\tdefault:\n\t\tdata = 0;\n\t}\n\treturn data;\n}\n\n#define MIC_BOOST_0DB 0xCF\n#define MIC_BOOST_STEPS_PER_DB 2\n\nstatic void hw_wm8775_input_select(struct hw *hw, u8 input, s8 gain_in_db)\n{\n\tu32 adcmc, gain;\n\n\tif (input > 3)\n\t\tinput = 3;\n\n\tadcmc = ((u32)1 << input) | 0x100;  \n\n\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_ADCMC, adcmc),\n\t\t\t\tMAKE_WM8775_DATA(adcmc));\n\n\tif (gain_in_db < -103)\n\t\tgain_in_db = -103;\n\tif (gain_in_db > 24)\n\t\tgain_in_db = 24;\n\n\tgain = gain_in_db * MIC_BOOST_STEPS_PER_DB + MIC_BOOST_0DB;\n\n\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_AADCL, gain),\n\t\t\t\tMAKE_WM8775_DATA(gain));\n\t \n\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_AADCR, gain),\n\t\t\t\tMAKE_WM8775_DATA(gain));\n}\n\nstatic int hw_adc_input_select(struct hw *hw, enum ADCSRC type)\n{\n\tu32 data;\n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tswitch (type) {\n\tcase ADC_MICIN:\n\t\tdata |= (0x1 << 14);\n\t\thw_write_20kx(hw, GPIO_DATA, data);\n\t\thw_wm8775_input_select(hw, 0, 20);  \n\t\tbreak;\n\tcase ADC_LINEIN:\n\t\tdata &= ~(0x1 << 14);\n\t\thw_write_20kx(hw, GPIO_DATA, data);\n\t\thw_wm8775_input_select(hw, 1, 0);  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int hw_adc_init(struct hw *hw, const struct adc_conf *info)\n{\n\tint err;\n\tu32 data, ctl;\n\n\t \n\tdata = hw_read_20kx(hw, GPIO_CTRL);\n\tdata |= (0x1 << 15);\n\thw_write_20kx(hw, GPIO_CTRL, data);\n\n\t \n\terr = hw20k2_i2c_init(hw, 0x1A, 1, 1);\n\tif (err < 0) {\n\t\tdev_alert(hw->card->dev, \"Failure to acquire I2C!!!\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tdata &= ~(0x1 << 15);\n\thw_write_20kx(hw, GPIO_DATA, data);\n\n\tif (hw->model == CTSB1270) {\n\t\t \n\t\tdata &= ~0x0C;\n\t\tif (1 == info->msr)\n\t\t\tdata |= 0x00;  \n\t\telse if (2 == info->msr)\n\t\t\tdata |= 0x08;  \n\t\telse\n\t\t\tdata |= 0x04;  \n\t\thw_write_20kx(hw, GPIO_DATA, data);\n\t}\n\n\tusleep_range(10000, 11000);\n\t \n\tdata |= (0x1 << 15);\n\thw_write_20kx(hw, GPIO_DATA, data);\n\tmsleep(50);\n\n\t \n\t \n\t \n\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_IC, 0x26),\n\t\t\t MAKE_WM8775_DATA(0x26));\n\n\t \n\tif (1 == info->msr) {\n\t\t \n\t\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_MMC, 0x02),\n\t\t\t\t\t\tMAKE_WM8775_DATA(0x02));\n\t} else if ((2 == info->msr) || (4 == info->msr)) {\n\t\t \n\t\thw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_MMC, 0x0A),\n\t\t\t\t\t\tMAKE_WM8775_DATA(0x0A));\n\t} else {\n\t\tdev_alert(hw->card->dev,\n\t\t\t  \"Invalid master sampling rate (msr %d)!!!\\n\",\n\t\t\t  info->msr);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (hw->model != CTSB1270) {\n\t\t \n\t\tctl = hw_read_20kx(hw, GPIO_CTRL);\n\t\tctl |= 0x1 << 14;\n\t\thw_write_20kx(hw, GPIO_CTRL, ctl);\n\t\thw_adc_input_select(hw, ADC_LINEIN);\n\t} else {\n\t\thw_wm8775_input_select(hw, 0, 0);\n\t}\n\n\treturn 0;\nerror:\n\thw20k2_i2c_uninit(hw);\n\treturn err;\n}\n\nstatic struct capabilities hw_capabilities(struct hw *hw)\n{\n\tstruct capabilities cap;\n\n\tcap.digit_io_switch = 0;\n\tcap.dedicated_mic = hw->model == CTSB1270;\n\tcap.output_switch = hw->model == CTSB1270;\n\tcap.mic_source_switch = hw->model == CTSB1270;\n\n\treturn cap;\n}\n\nstatic int hw_output_switch_get(struct hw *hw)\n{\n\tu32 data = hw_read_20kx(hw, GPIO_EXT_DATA);\n\n\tswitch (data & 0x30) {\n\tcase 0x00:\n\t     return 0;\n\tcase 0x10:\n\t     return 1;\n\tcase 0x20:\n\t     return 2;\n\tdefault:\n\t     return 3;\n\t}\n}\n\nstatic int hw_output_switch_put(struct hw *hw, int position)\n{\n\tu32 data;\n\n\tif (position == hw_output_switch_get(hw))\n\t\treturn 0;\n\n\t \n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tdata |= (0x03 << 11);\n\thw_write_20kx(hw, GPIO_DATA, data);\n\n\tdata = hw_read_20kx(hw, GPIO_EXT_DATA) & ~0x30;\n\tswitch (position) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tdata |= 0x10;\n\t\tbreak;\n\tdefault:\n\t\tdata |= 0x20;\n\t}\n\thw_write_20kx(hw, GPIO_EXT_DATA, data);\n\n\t \n\tdata = hw_read_20kx(hw, GPIO_DATA);\n\tdata &= ~(0x03 << 11);\n\thw_write_20kx(hw, GPIO_DATA, data);\n\n\treturn 1;\n}\n\nstatic int hw_mic_source_switch_get(struct hw *hw)\n{\n\tstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\n\n\treturn hw20k2->mic_source;\n}\n\nstatic int hw_mic_source_switch_put(struct hw *hw, int position)\n{\n\tstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\n\n\tif (position == hw20k2->mic_source)\n\t\treturn 0;\n\n\tswitch (position) {\n\tcase 0:\n\t\thw_wm8775_input_select(hw, 0, 0);  \n\t\tbreak;\n\tcase 1:\n\t\thw_wm8775_input_select(hw, 1, 0);  \n\t\tbreak;\n\tcase 2:\n\t\thw_wm8775_input_select(hw, 3, 0);  \n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\thw20k2->mic_source = position;\n\n\treturn 1;\n}\n\nstatic irqreturn_t ct_20k2_interrupt(int irq, void *dev_id)\n{\n\tstruct hw *hw = dev_id;\n\tunsigned int status;\n\n\tstatus = hw_read_20kx(hw, GIP);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (hw->irq_callback)\n\t\thw->irq_callback(hw->irq_callback_data, status);\n\n\thw_write_20kx(hw, GIP, status);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hw_card_start(struct hw *hw)\n{\n\tint err = 0;\n\tstruct pci_dev *pci = hw->pci;\n\tunsigned int gctl;\n\tconst unsigned int dma_bits = BITS_PER_LONG;\n\n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(dma_bits)))\n\t\tdma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32));\n\n\tif (!hw->io_base) {\n\t\terr = pci_request_regions(pci, \"XFi\");\n\t\tif (err < 0)\n\t\t\tgoto error1;\n\n\t\thw->io_base = pci_resource_start(hw->pci, 2);\n\t\thw->mem_base = ioremap(hw->io_base,\n\t\t\t\t       pci_resource_len(hw->pci, 2));\n\t\tif (!hw->mem_base) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t \n\tgctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\n\tset_field(&gctl, GCTL_UAA, 0);\n\thw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\n\n\tif (hw->irq < 0) {\n\t\terr = request_irq(pci->irq, ct_20k2_interrupt, IRQF_SHARED,\n\t\t\t\t  KBUILD_MODNAME, hw);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->card->dev,\n\t\t\t\t\"XFi: Cannot get irq %d\\n\", pci->irq);\n\t\t\tgoto error2;\n\t\t}\n\t\thw->irq = pci->irq;\n\t\thw->card->sync_irq = hw->irq;\n\t}\n\n\tpci_set_master(pci);\n\n\treturn 0;\n\n \nerror2:\n\tpci_release_regions(pci);\n\thw->io_base = 0;\nerror1:\n\tpci_disable_device(pci);\n\treturn err;\n}\n\nstatic int hw_card_stop(struct hw *hw)\n{\n\tunsigned int data;\n\n\t \n\thw_write_20kx(hw, TRANSPORT_CTL, 0x00);\n\n\t \n\tdata = hw_read_20kx(hw, PLL_ENB);\n\thw_write_20kx(hw, PLL_ENB, (data & (~0x07)));\n\n\t \n\treturn 0;\n}\n\nstatic int hw_card_shutdown(struct hw *hw)\n{\n\tif (hw->irq >= 0)\n\t\tfree_irq(hw->irq, hw);\n\n\thw->irq\t= -1;\n\tiounmap(hw->mem_base);\n\thw->mem_base = NULL;\n\n\tif (hw->io_base)\n\t\tpci_release_regions(hw->pci);\n\n\thw->io_base = 0;\n\n\tpci_disable_device(hw->pci);\n\n\treturn 0;\n}\n\nstatic int hw_card_init(struct hw *hw, struct card_conf *info)\n{\n\tint err;\n\tunsigned int gctl;\n\tu32 data = 0;\n\tstruct dac_conf dac_info = {0};\n\tstruct adc_conf adc_info = {0};\n\tstruct daio_conf daio_info = {0};\n\tstruct trn_conf trn_info = {0};\n\n\t \n\terr = hw_card_start(hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hw_pll_init(hw, info->rsr);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = hw_auto_init(hw);\n\tif (err < 0)\n\t\treturn err;\n\n\tgctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\n\tset_field(&gctl, GCTL_DBP, 1);\n\tset_field(&gctl, GCTL_TBP, 1);\n\tset_field(&gctl, GCTL_FBP, 1);\n\tset_field(&gctl, GCTL_DPC, 0);\n\thw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\n\n\t \n\thw_write_20kx(hw, GIE, 0);\n\t \n\thw_write_20kx(hw, SRC_IP, 0);\n\n\tif (hw->model != CTSB1270) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\thw_write_20kx(hw, GPIO_CTRL, 0xD802);\n\t} else {\n\t\thw_write_20kx(hw, GPIO_CTRL, 0x9E5F);\n\t}\n\t \n\thw_write_20kx(hw, MIXER_AR_ENABLE, 0x01);\n\n\ttrn_info.vm_pgt_phys = info->vm_pgt_phys;\n\terr = hw_trn_init(hw, &trn_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdaio_info.msr = info->msr;\n\terr = hw_daio_init(hw, &daio_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdac_info.msr = info->msr;\n\terr = hw_dac_init(hw, &dac_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tadc_info.msr = info->msr;\n\tadc_info.input = ADC_LINEIN;\n\tadc_info.mic20db = 0;\n\terr = hw_adc_init(hw, &adc_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = hw_read_20kx(hw, SRC_MCTL);\n\tdata |= 0x1;  \n\thw_write_20kx(hw, SRC_MCTL, data);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hw_suspend(struct hw *hw)\n{\n\thw_card_stop(hw);\n\treturn 0;\n}\n\nstatic int hw_resume(struct hw *hw, struct card_conf *info)\n{\n\t \n\treturn hw_card_init(hw, info);\n}\n#endif\n\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg)\n{\n\treturn readl(hw->mem_base + reg);\n}\n\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data)\n{\n\twritel(data, hw->mem_base + reg);\n}\n\nstatic const struct hw ct20k2_preset = {\n\t.irq = -1,\n\n\t.card_init = hw_card_init,\n\t.card_stop = hw_card_stop,\n\t.pll_init = hw_pll_init,\n\t.is_adc_source_selected = hw_is_adc_input_selected,\n\t.select_adc_source = hw_adc_input_select,\n\t.capabilities = hw_capabilities,\n\t.output_switch_get = hw_output_switch_get,\n\t.output_switch_put = hw_output_switch_put,\n\t.mic_source_switch_get = hw_mic_source_switch_get,\n\t.mic_source_switch_put = hw_mic_source_switch_put,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = hw_suspend,\n\t.resume = hw_resume,\n#endif\n\n\t.src_rsc_get_ctrl_blk = src_get_rsc_ctrl_blk,\n\t.src_rsc_put_ctrl_blk = src_put_rsc_ctrl_blk,\n\t.src_mgr_get_ctrl_blk = src_mgr_get_ctrl_blk,\n\t.src_mgr_put_ctrl_blk = src_mgr_put_ctrl_blk,\n\t.src_set_state = src_set_state,\n\t.src_set_bm = src_set_bm,\n\t.src_set_rsr = src_set_rsr,\n\t.src_set_sf = src_set_sf,\n\t.src_set_wr = src_set_wr,\n\t.src_set_pm = src_set_pm,\n\t.src_set_rom = src_set_rom,\n\t.src_set_vo = src_set_vo,\n\t.src_set_st = src_set_st,\n\t.src_set_ie = src_set_ie,\n\t.src_set_ilsz = src_set_ilsz,\n\t.src_set_bp = src_set_bp,\n\t.src_set_cisz = src_set_cisz,\n\t.src_set_ca = src_set_ca,\n\t.src_set_sa = src_set_sa,\n\t.src_set_la = src_set_la,\n\t.src_set_pitch = src_set_pitch,\n\t.src_set_dirty = src_set_dirty,\n\t.src_set_clear_zbufs = src_set_clear_zbufs,\n\t.src_set_dirty_all = src_set_dirty_all,\n\t.src_commit_write = src_commit_write,\n\t.src_get_ca = src_get_ca,\n\t.src_get_dirty = src_get_dirty,\n\t.src_dirty_conj_mask = src_dirty_conj_mask,\n\t.src_mgr_enbs_src = src_mgr_enbs_src,\n\t.src_mgr_enb_src = src_mgr_enb_src,\n\t.src_mgr_dsb_src = src_mgr_dsb_src,\n\t.src_mgr_commit_write = src_mgr_commit_write,\n\n\t.srcimp_mgr_get_ctrl_blk = srcimp_mgr_get_ctrl_blk,\n\t.srcimp_mgr_put_ctrl_blk = srcimp_mgr_put_ctrl_blk,\n\t.srcimp_mgr_set_imaparc = srcimp_mgr_set_imaparc,\n\t.srcimp_mgr_set_imapuser = srcimp_mgr_set_imapuser,\n\t.srcimp_mgr_set_imapnxt = srcimp_mgr_set_imapnxt,\n\t.srcimp_mgr_set_imapaddr = srcimp_mgr_set_imapaddr,\n\t.srcimp_mgr_commit_write = srcimp_mgr_commit_write,\n\n\t.amixer_rsc_get_ctrl_blk = amixer_rsc_get_ctrl_blk,\n\t.amixer_rsc_put_ctrl_blk = amixer_rsc_put_ctrl_blk,\n\t.amixer_mgr_get_ctrl_blk = amixer_mgr_get_ctrl_blk,\n\t.amixer_mgr_put_ctrl_blk = amixer_mgr_put_ctrl_blk,\n\t.amixer_set_mode = amixer_set_mode,\n\t.amixer_set_iv = amixer_set_iv,\n\t.amixer_set_x = amixer_set_x,\n\t.amixer_set_y = amixer_set_y,\n\t.amixer_set_sadr = amixer_set_sadr,\n\t.amixer_set_se = amixer_set_se,\n\t.amixer_set_dirty = amixer_set_dirty,\n\t.amixer_set_dirty_all = amixer_set_dirty_all,\n\t.amixer_commit_write = amixer_commit_write,\n\t.amixer_get_y = amixer_get_y,\n\t.amixer_get_dirty = amixer_get_dirty,\n\n\t.dai_get_ctrl_blk = dai_get_ctrl_blk,\n\t.dai_put_ctrl_blk = dai_put_ctrl_blk,\n\t.dai_srt_set_srco = dai_srt_set_srco,\n\t.dai_srt_set_srcm = dai_srt_set_srcm,\n\t.dai_srt_set_rsr = dai_srt_set_rsr,\n\t.dai_srt_set_drat = dai_srt_set_drat,\n\t.dai_srt_set_ec = dai_srt_set_ec,\n\t.dai_srt_set_et = dai_srt_set_et,\n\t.dai_commit_write = dai_commit_write,\n\n\t.dao_get_ctrl_blk = dao_get_ctrl_blk,\n\t.dao_put_ctrl_blk = dao_put_ctrl_blk,\n\t.dao_set_spos = dao_set_spos,\n\t.dao_commit_write = dao_commit_write,\n\t.dao_get_spos = dao_get_spos,\n\n\t.daio_mgr_get_ctrl_blk = daio_mgr_get_ctrl_blk,\n\t.daio_mgr_put_ctrl_blk = daio_mgr_put_ctrl_blk,\n\t.daio_mgr_enb_dai = daio_mgr_enb_dai,\n\t.daio_mgr_dsb_dai = daio_mgr_dsb_dai,\n\t.daio_mgr_enb_dao = daio_mgr_enb_dao,\n\t.daio_mgr_dsb_dao = daio_mgr_dsb_dao,\n\t.daio_mgr_dao_init = daio_mgr_dao_init,\n\t.daio_mgr_set_imaparc = daio_mgr_set_imaparc,\n\t.daio_mgr_set_imapnxt = daio_mgr_set_imapnxt,\n\t.daio_mgr_set_imapaddr = daio_mgr_set_imapaddr,\n\t.daio_mgr_commit_write = daio_mgr_commit_write,\n\n\t.set_timer_irq = set_timer_irq,\n\t.set_timer_tick = set_timer_tick,\n\t.get_wc = get_wc,\n};\n\nint create_20k2_hw_obj(struct hw **rhw)\n{\n\tstruct hw20k2 *hw20k2;\n\n\t*rhw = NULL;\n\thw20k2 = kzalloc(sizeof(*hw20k2), GFP_KERNEL);\n\tif (!hw20k2)\n\t\treturn -ENOMEM;\n\n\thw20k2->hw = ct20k2_preset;\n\t*rhw = &hw20k2->hw;\n\n\treturn 0;\n}\n\nint destroy_20k2_hw_obj(struct hw *hw)\n{\n\tif (hw->io_base)\n\t\thw_card_shutdown(hw);\n\n\tkfree(hw);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}