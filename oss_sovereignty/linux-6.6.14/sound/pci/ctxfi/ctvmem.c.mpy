{
  "module_name": "ctvmem.c",
  "hash_id": "4bee803940b2109f6b180bccf111cc44853a103e104fd81754508ffd6e7392d6",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctvmem.c",
  "human_readable_source": "\n \n\n#include \"ctvmem.h\"\n#include \"ctatc.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <sound/pcm.h>\n\n#define CT_PTES_PER_PAGE (CT_PAGE_SIZE / sizeof(void *))\n#define CT_ADDRS_PER_PAGE (CT_PTES_PER_PAGE * CT_PAGE_SIZE)\n\n \nstatic struct ct_vm_block *\nget_vm_block(struct ct_vm *vm, unsigned int size, struct ct_atc *atc)\n{\n\tstruct ct_vm_block *block = NULL, *entry;\n\tstruct list_head *pos;\n\n\tsize = CT_PAGE_ALIGN(size);\n\tif (size > vm->size) {\n\t\tdev_err(atc->card->dev,\n\t\t\t\"Fail! No sufficient device virtual memory space available!\\n\");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&vm->lock);\n\tlist_for_each(pos, &vm->unused) {\n\t\tentry = list_entry(pos, struct ct_vm_block, list);\n\t\tif (entry->size >= size)\n\t\t\tbreak;  \n\t}\n\tif (pos == &vm->unused)\n\t\tgoto out;\n\n\tif (entry->size == size) {\n\t\t \n\t\tlist_move(&entry->list, &vm->used);\n\t\tvm->size -= size;\n\t\tblock = entry;\n\t\tgoto out;\n\t}\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\tgoto out;\n\n\tblock->addr = entry->addr;\n\tblock->size = size;\n\tlist_add(&block->list, &vm->used);\n\tentry->addr += size;\n\tentry->size -= size;\n\tvm->size -= size;\n\n out:\n\tmutex_unlock(&vm->lock);\n\treturn block;\n}\n\nstatic void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)\n{\n\tstruct ct_vm_block *entry, *pre_ent;\n\tstruct list_head *pos, *pre;\n\n\tblock->size = CT_PAGE_ALIGN(block->size);\n\n\tmutex_lock(&vm->lock);\n\tlist_del(&block->list);\n\tvm->size += block->size;\n\n\tlist_for_each(pos, &vm->unused) {\n\t\tentry = list_entry(pos, struct ct_vm_block, list);\n\t\tif (entry->addr >= (block->addr + block->size))\n\t\t\tbreak;  \n\t}\n\tif (pos == &vm->unused) {\n\t\tlist_add_tail(&block->list, &vm->unused);\n\t\tentry = block;\n\t} else {\n\t\tif ((block->addr + block->size) == entry->addr) {\n\t\t\tentry->addr = block->addr;\n\t\t\tentry->size += block->size;\n\t\t\tkfree(block);\n\t\t} else {\n\t\t\t__list_add(&block->list, pos->prev, pos);\n\t\t\tentry = block;\n\t\t}\n\t}\n\n\tpos = &entry->list;\n\tpre = pos->prev;\n\twhile (pre != &vm->unused) {\n\t\tentry = list_entry(pos, struct ct_vm_block, list);\n\t\tpre_ent = list_entry(pre, struct ct_vm_block, list);\n\t\tif ((pre_ent->addr + pre_ent->size) > entry->addr)\n\t\t\tbreak;\n\n\t\tpre_ent->size += entry->size;\n\t\tlist_del(pos);\n\t\tkfree(entry);\n\t\tpos = pre;\n\t\tpre = pos->prev;\n\t}\n\tmutex_unlock(&vm->lock);\n}\n\n \nstatic struct ct_vm_block *\nct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)\n{\n\tstruct ct_vm_block *block;\n\tunsigned int pte_start;\n\tunsigned i, pages;\n\tunsigned long *ptp;\n\tstruct ct_atc *atc = snd_pcm_substream_chip(substream);\n\n\tblock = get_vm_block(vm, size, atc);\n\tif (block == NULL) {\n\t\tdev_err(atc->card->dev,\n\t\t\t\"No virtual memory block that is big enough to allocate!\\n\");\n\t\treturn NULL;\n\t}\n\n\tptp = (unsigned long *)vm->ptp[0].area;\n\tpte_start = (block->addr >> CT_PAGE_SHIFT);\n\tpages = block->size >> CT_PAGE_SHIFT;\n\tfor (i = 0; i < pages; i++) {\n\t\tunsigned long addr;\n\t\taddr = snd_pcm_sgbuf_get_addr(substream, i << CT_PAGE_SHIFT);\n\t\tptp[pte_start + i] = addr;\n\t}\n\n\tblock->size = size;\n\treturn block;\n}\n\nstatic void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)\n{\n\t \n\tput_vm_block(vm, block);\n}\n\n \nstatic dma_addr_t\nct_get_ptp_phys(struct ct_vm *vm, int index)\n{\n\treturn (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;\n}\n\nint ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)\n{\n\tstruct ct_vm *vm;\n\tstruct ct_vm_block *block;\n\tint i, err = 0;\n\n\t*rvm = NULL;\n\n\tvm = kzalloc(sizeof(*vm), GFP_KERNEL);\n\tif (!vm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&vm->lock);\n\n\t \n\tfor (i = 0; i < CT_PTP_NUM; i++) {\n\t\terr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t  &pci->dev,\n\t\t\t\t\t  PAGE_SIZE, &vm->ptp[i]);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tif (err < 0) {\n\t\t \n\t\tct_vm_destroy(vm);\n\t\treturn -ENOMEM;\n\t}\n\tvm->size = CT_ADDRS_PER_PAGE * i;\n\tvm->map = ct_vm_map;\n\tvm->unmap = ct_vm_unmap;\n\tvm->get_ptp_phys = ct_get_ptp_phys;\n\tINIT_LIST_HEAD(&vm->unused);\n\tINIT_LIST_HEAD(&vm->used);\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (NULL != block) {\n\t\tblock->addr = 0;\n\t\tblock->size = vm->size;\n\t\tlist_add(&block->list, &vm->unused);\n\t}\n\n\t*rvm = vm;\n\treturn 0;\n}\n\n \nvoid ct_vm_destroy(struct ct_vm *vm)\n{\n\tint i;\n\tstruct list_head *pos;\n\tstruct ct_vm_block *entry;\n\n\t \n\twhile (!list_empty(&vm->used)) {\n\t\tpos = vm->used.next;\n\t\tlist_del(pos);\n\t\tentry = list_entry(pos, struct ct_vm_block, list);\n\t\tkfree(entry);\n\t}\n\twhile (!list_empty(&vm->unused)) {\n\t\tpos = vm->unused.next;\n\t\tlist_del(pos);\n\t\tentry = list_entry(pos, struct ct_vm_block, list);\n\t\tkfree(entry);\n\t}\n\n\t \n\tfor (i = 0; i < CT_PTP_NUM; i++)\n\t\tsnd_dma_free_pages(&vm->ptp[i]);\n\n\tvm->size = 0;\n\n\tkfree(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}