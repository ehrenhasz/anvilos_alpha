{
  "module_name": "ctimap.c",
  "hash_id": "c52dc52d9e205457db755054c491843fd9cdba267d424ba303dd7f05ef0c5abc",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctimap.c",
  "human_readable_source": "\n \n\n#include \"ctimap.h\"\n#include <linux/slab.h>\n\nint input_mapper_add(struct list_head *mappers, struct imapper *entry,\n\t\t     int (*map_op)(void *, struct imapper *), void *data)\n{\n\tstruct list_head *pos, *pre, *head;\n\tstruct imapper *pre_ent, *pos_ent;\n\n\thead = mappers;\n\n\tif (list_empty(head)) {\n\t\tentry->next = entry->addr;\n\t\tmap_op(data, entry);\n\t\tlist_add(&entry->list, head);\n\t\treturn 0;\n\t}\n\n\tlist_for_each(pos, head) {\n\t\tpos_ent = list_entry(pos, struct imapper, list);\n\t\tif (pos_ent->slot > entry->slot) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pos != head) {\n\t\tpre = pos->prev;\n\t\tif (pre == head)\n\t\t\tpre = head->prev;\n\n\t\t__list_add(&entry->list, pos->prev, pos);\n\t} else {\n\t\tpre = head->prev;\n\t\tpos = head->next;\n\t\tlist_add_tail(&entry->list, head);\n\t}\n\n\tpre_ent = list_entry(pre, struct imapper, list);\n\tpos_ent = list_entry(pos, struct imapper, list);\n\n\tentry->next = pos_ent->addr;\n\tmap_op(data, entry);\n\tpre_ent->next = entry->addr;\n\tmap_op(data, pre_ent);\n\n\treturn 0;\n}\n\nint input_mapper_delete(struct list_head *mappers, struct imapper *entry,\n\t\t     int (*map_op)(void *, struct imapper *), void *data)\n{\n\tstruct list_head *next, *pre, *head;\n\tstruct imapper *pre_ent, *next_ent;\n\n\thead = mappers;\n\n\tif (list_empty(head))\n\t\treturn 0;\n\n\tpre = (entry->list.prev == head) ? head->prev : entry->list.prev;\n\tnext = (entry->list.next == head) ? head->next : entry->list.next;\n\n\tif (pre == &entry->list) {\n\t\t \n\t\tentry->next = entry->addr = entry->user = entry->slot = 0;\n\t\tmap_op(data, entry);\n\t\tlist_del(&entry->list);\n\t\treturn 0;\n\t}\n\n\tpre_ent = list_entry(pre, struct imapper, list);\n\tnext_ent = list_entry(next, struct imapper, list);\n\n\tpre_ent->next = next_ent->addr;\n\tmap_op(data, pre_ent);\n\tlist_del(&entry->list);\n\n\treturn 0;\n}\n\nvoid free_input_mapper_list(struct list_head *head)\n{\n\tstruct imapper *entry;\n\tstruct list_head *pos;\n\n\twhile (!list_empty(head)) {\n\t\tpos = head->next;\n\t\tlist_del(pos);\n\t\tentry = list_entry(pos, struct imapper, list);\n\t\tkfree(entry);\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}