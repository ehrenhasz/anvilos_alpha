{
  "module_name": "ctresource.c",
  "hash_id": "aefb5f105a679526565f7b5098eca18c55646c2fa486120ed7c218ba14199238",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ctxfi/ctresource.c",
  "human_readable_source": "\n \n\n#include \"ctresource.h\"\n#include \"cthardware.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n\n#define AUDIO_SLOT_BLOCK_NUM \t256\n\n \nstatic int\nget_resource(u8 *rscs, unsigned int amount,\n\t     unsigned int multi, unsigned int *ridx)\n{\n\tint i, j, k, n;\n\n\t \n\tfor (i = 0, n = multi; i < amount; i++) {\n\t\tj = i / 8;\n\t\tk = i % 8;\n\t\tif (rscs[j] & ((u8)1 << k)) {\n\t\t\tn = multi;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(--n))\n\t\t\tbreak;  \n\t}\n\n\tif (i >= amount) {\n\t\t \n\t\treturn -ENOENT;\n\t}\n\n\t \n\tfor (n = multi; n > 0; n--) {\n\t\tj = i / 8;\n\t\tk = i % 8;\n\t\trscs[j] |= ((u8)1 << k);\n\t\ti--;\n\t}\n\n\t*ridx = i + 1;\n\n\treturn 0;\n}\n\nstatic int put_resource(u8 *rscs, unsigned int multi, unsigned int idx)\n{\n\tunsigned int i, j, k, n;\n\n\t \n\tfor (n = multi, i = idx; n > 0; n--) {\n\t\tj = i / 8;\n\t\tk = i % 8;\n\t\trscs[j] &= ~((u8)1 << k);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nint mgr_get_resource(struct rsc_mgr *mgr, unsigned int n, unsigned int *ridx)\n{\n\tint err;\n\n\tif (n > mgr->avail)\n\t\treturn -ENOENT;\n\n\terr = get_resource(mgr->rscs, mgr->amount, n, ridx);\n\tif (!err)\n\t\tmgr->avail -= n;\n\n\treturn err;\n}\n\nint mgr_put_resource(struct rsc_mgr *mgr, unsigned int n, unsigned int idx)\n{\n\tput_resource(mgr->rscs, n, idx);\n\tmgr->avail += n;\n\n\treturn 0;\n}\n\nstatic const unsigned char offset_in_audio_slot_block[NUM_RSCTYP] = {\n\t \n\t[SRC]\t\t= 0x1,\n\t[AMIXER]\t= 0x4,\n\t[SUM]\t\t= 0xc,\n};\n\nstatic int rsc_index(const struct rsc *rsc)\n{\n    return rsc->conj;\n}\n\nstatic int audio_ring_slot(const struct rsc *rsc)\n{\n    return (rsc->conj << 4) + offset_in_audio_slot_block[rsc->type];\n}\n\nstatic void rsc_next_conj(struct rsc *rsc)\n{\n\tunsigned int i;\n\tfor (i = 0; (i < 8) && (!(rsc->msr & (0x1 << i))); )\n\t\ti++;\n\trsc->conj += (AUDIO_SLOT_BLOCK_NUM >> i);\n}\n\nstatic void rsc_master(struct rsc *rsc)\n{\n\trsc->conj = rsc->idx;\n}\n\nstatic const struct rsc_ops rsc_generic_ops = {\n\t.index\t\t= rsc_index,\n\t.output_slot\t= audio_ring_slot,\n\t.master\t\t= rsc_master,\n\t.next_conj\t= rsc_next_conj,\n};\n\nint\nrsc_init(struct rsc *rsc, u32 idx, enum RSCTYP type, u32 msr, struct hw *hw)\n{\n\tint err = 0;\n\n\trsc->idx = idx;\n\trsc->conj = idx;\n\trsc->type = type;\n\trsc->msr = msr;\n\trsc->hw = hw;\n\trsc->ops = &rsc_generic_ops;\n\tif (!hw) {\n\t\trsc->ctrl_blk = NULL;\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase SRC:\n\t\terr = hw->src_rsc_get_ctrl_blk(&rsc->ctrl_blk);\n\t\tbreak;\n\tcase AMIXER:\n\t\terr = hw->amixer_rsc_get_ctrl_blk(&rsc->ctrl_blk);\n\t\tbreak;\n\tcase SRCIMP:\n\tcase SUM:\n\tcase DAIO:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(((struct hw *)hw)->card->dev,\n\t\t\t\"Invalid resource type value %d!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err) {\n\t\tdev_err(((struct hw *)hw)->card->dev,\n\t\t\t\"Failed to get resource control block!\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint rsc_uninit(struct rsc *rsc)\n{\n\tif ((NULL != rsc->hw) && (NULL != rsc->ctrl_blk)) {\n\t\tswitch (rsc->type) {\n\t\tcase SRC:\n\t\t\trsc->hw->src_rsc_put_ctrl_blk(rsc->ctrl_blk);\n\t\t\tbreak;\n\t\tcase AMIXER:\n\t\t\trsc->hw->amixer_rsc_put_ctrl_blk(rsc->ctrl_blk);\n\t\t\tbreak;\n\t\tcase SUM:\n\t\tcase DAIO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(((struct hw *)rsc->hw)->card->dev,\n\t\t\t\t\"Invalid resource type value %d!\\n\",\n\t\t\t\trsc->type);\n\t\t\tbreak;\n\t\t}\n\n\t\trsc->hw = rsc->ctrl_blk = NULL;\n\t}\n\n\trsc->idx = rsc->conj = 0;\n\trsc->type = NUM_RSCTYP;\n\trsc->msr = 0;\n\n\treturn 0;\n}\n\nint rsc_mgr_init(struct rsc_mgr *mgr, enum RSCTYP type,\n\t\t unsigned int amount, struct hw *hw)\n{\n\tint err = 0;\n\n\tmgr->type = NUM_RSCTYP;\n\n\tmgr->rscs = kzalloc(DIV_ROUND_UP(amount, 8), GFP_KERNEL);\n\tif (!mgr->rscs)\n\t\treturn -ENOMEM;\n\n\tswitch (type) {\n\tcase SRC:\n\t\terr = hw->src_mgr_get_ctrl_blk(&mgr->ctrl_blk);\n\t\tbreak;\n\tcase SRCIMP:\n\t\terr = hw->srcimp_mgr_get_ctrl_blk(&mgr->ctrl_blk);\n\t\tbreak;\n\tcase AMIXER:\n\t\terr = hw->amixer_mgr_get_ctrl_blk(&mgr->ctrl_blk);\n\t\tbreak;\n\tcase DAIO:\n\t\terr = hw->daio_mgr_get_ctrl_blk(hw, &mgr->ctrl_blk);\n\t\tbreak;\n\tcase SUM:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hw->card->dev,\n\t\t\t\"Invalid resource type value %d!\\n\", type);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (err) {\n\t\tdev_err(hw->card->dev,\n\t\t\t\"Failed to get manager control block!\\n\");\n\t\tgoto error;\n\t}\n\n\tmgr->type = type;\n\tmgr->avail = mgr->amount = amount;\n\tmgr->hw = hw;\n\n\treturn 0;\n\nerror:\n\tkfree(mgr->rscs);\n\treturn err;\n}\n\nint rsc_mgr_uninit(struct rsc_mgr *mgr)\n{\n\tkfree(mgr->rscs);\n\tmgr->rscs = NULL;\n\n\tif ((NULL != mgr->hw) && (NULL != mgr->ctrl_blk)) {\n\t\tswitch (mgr->type) {\n\t\tcase SRC:\n\t\t\tmgr->hw->src_mgr_put_ctrl_blk(mgr->ctrl_blk);\n\t\t\tbreak;\n\t\tcase SRCIMP:\n\t\t\tmgr->hw->srcimp_mgr_put_ctrl_blk(mgr->ctrl_blk);\n\t\t\tbreak;\n\t\tcase AMIXER:\n\t\t\tmgr->hw->amixer_mgr_put_ctrl_blk(mgr->ctrl_blk);\n\t\t\tbreak;\n\t\tcase DAIO:\n\t\t\tmgr->hw->daio_mgr_put_ctrl_blk(mgr->ctrl_blk);\n\t\t\tbreak;\n\t\tcase SUM:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(((struct hw *)mgr->hw)->card->dev,\n\t\t\t\t\"Invalid resource type value %d!\\n\",\n\t\t\t\tmgr->type);\n\t\t\tbreak;\n\t\t}\n\n\t\tmgr->hw = mgr->ctrl_blk = NULL;\n\t}\n\n\tmgr->type = NUM_RSCTYP;\n\tmgr->avail = mgr->amount = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}