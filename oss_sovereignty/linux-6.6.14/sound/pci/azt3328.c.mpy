{
  "module_name": "azt3328.c",
  "hash_id": "d863d47d24e6f9846fb919b03b25586036c1279af245a535b5efb5624f6ced71",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/azt3328.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/bug.h>  \n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n \n#define AZF_USE_AC97_LAYER 1\n\n#ifdef AZF_USE_AC97_LAYER\n#include <sound/ac97_codec.h>\n#endif\n#include \"azt3328.h\"\n\nMODULE_AUTHOR(\"Andreas Mohr <andi AT lisas.de>\");\nMODULE_DESCRIPTION(\"Aztech AZF3328 (PCI168)\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_GAMEPORT 1\n#endif\n\n \n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for AZF3328 soundcard.\");\n\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for AZF3328 soundcard.\");\n\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable AZF3328 soundcard.\");\n\nstatic int seqtimer_scaling = 128;\nmodule_param(seqtimer_scaling, int, 0444);\nMODULE_PARM_DESC(seqtimer_scaling, \"Set 1024000Hz sequencer timer scale factor (lockup danger!). Default 128.\");\n\nenum snd_azf3328_codec_type {\n   \n  AZF_CODEC_PLAYBACK = 0,\n  AZF_CODEC_CAPTURE = 1,\n  AZF_CODEC_I2S_OUT = 2,\n};\n\nstruct snd_azf3328_codec_data {\n\tunsigned long io_base;  \n\tunsigned int dma_base;  \n\tspinlock_t *lock;  \n\tstruct snd_pcm_substream *substream;\n\tbool running;\n\tenum snd_azf3328_codec_type type;\n\tconst char *name;\n};\n\nstruct snd_azf3328 {\n\t \n\n\tunsigned long ctrl_io;  \n\tunsigned long game_io;   \n\tunsigned long mpu_io;    \n\tunsigned long opl3_io;  \n\tunsigned long mixer_io;  \n\n\tspinlock_t reg_lock;\n\n\tstruct snd_timer *timer;\n\n\tstruct snd_pcm *pcm[3];\n\n\t \n\tstruct snd_azf3328_codec_data codecs[3];\n\n#ifdef AZF_USE_AC97_LAYER\n\tstruct snd_ac97 *ac97;\n#endif\n\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\n#ifdef SUPPORT_GAMEPORT\n\tstruct gameport *gameport;\n\tu16 axes[4];\n#endif\n\n\tstruct pci_dev *pci;\n\tint irq;\n\n\t \n\tu16 shadow_reg_ctrl_6AH;\n\n#ifdef CONFIG_PM_SLEEP\n\t \n\tu32 saved_regs_ctrl[AZF_ALIGN(AZF_IO_SIZE_CTRL_PM) / 4];\n\tu32 saved_regs_game[AZF_ALIGN(AZF_IO_SIZE_GAME_PM) / 4];\n\tu32 saved_regs_mpu[AZF_ALIGN(AZF_IO_SIZE_MPU_PM) / 4];\n\tu32 saved_regs_opl3[AZF_ALIGN(AZF_IO_SIZE_OPL3_PM) / 4];\n\tu32 saved_regs_mixer[AZF_ALIGN(AZF_IO_SIZE_MIXER_PM) / 4];\n#endif\n};\n\nstatic const struct pci_device_id snd_azf3328_ids[] = {\n\t{ 0x122D, 0x50DC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },    \n\t{ 0x122D, 0x80DA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_azf3328_ids);\n\n\nstatic int\nsnd_azf3328_io_reg_setb(unsigned reg, u8 mask, bool do_set)\n{\n\t \n\tu8 prev = inb(reg), new;\n\n\tnew = (do_set) ? (prev|mask) : (prev & ~mask);\n\t \n\toutb(new, reg);\n\tif (new != prev)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline void\nsnd_azf3328_codec_outb(const struct snd_azf3328_codec_data *codec,\n\t\t       unsigned reg,\n\t\t       u8 value\n)\n{\n\toutb(value, codec->io_base + reg);\n}\n\nstatic inline u8\nsnd_azf3328_codec_inb(const struct snd_azf3328_codec_data *codec, unsigned reg)\n{\n\treturn inb(codec->io_base + reg);\n}\n\nstatic inline void\nsnd_azf3328_codec_outw(const struct snd_azf3328_codec_data *codec,\n\t\t       unsigned reg,\n\t\t       u16 value\n)\n{\n\toutw(value, codec->io_base + reg);\n}\n\nstatic inline u16\nsnd_azf3328_codec_inw(const struct snd_azf3328_codec_data *codec, unsigned reg)\n{\n\treturn inw(codec->io_base + reg);\n}\n\nstatic inline void\nsnd_azf3328_codec_outl_multi(const struct snd_azf3328_codec_data *codec,\n\t\t\t     unsigned reg, const void *buffer, int count\n)\n{\n\tunsigned long addr = codec->io_base + reg;\n\tif (count) {\n\t\tconst u32 *buf = buffer;\n\t\tdo {\n\t\t\toutl(*buf++, addr);\n\t\t\taddr += 4;\n\t\t} while (--count);\n\t}\n}\n\nstatic inline u32\nsnd_azf3328_codec_inl(const struct snd_azf3328_codec_data *codec, unsigned reg)\n{\n\treturn inl(codec->io_base + reg);\n}\n\nstatic inline void\nsnd_azf3328_ctrl_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)\n{\n\toutb(value, chip->ctrl_io + reg);\n}\n\nstatic inline u8\nsnd_azf3328_ctrl_inb(const struct snd_azf3328 *chip, unsigned reg)\n{\n\treturn inb(chip->ctrl_io + reg);\n}\n\nstatic inline u16\nsnd_azf3328_ctrl_inw(const struct snd_azf3328 *chip, unsigned reg)\n{\n\treturn inw(chip->ctrl_io + reg);\n}\n\nstatic inline void\nsnd_azf3328_ctrl_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\n{\n\toutw(value, chip->ctrl_io + reg);\n}\n\nstatic inline void\nsnd_azf3328_ctrl_outl(const struct snd_azf3328 *chip, unsigned reg, u32 value)\n{\n\toutl(value, chip->ctrl_io + reg);\n}\n\nstatic inline void\nsnd_azf3328_game_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)\n{\n\toutb(value, chip->game_io + reg);\n}\n\nstatic inline void\nsnd_azf3328_game_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\n{\n\toutw(value, chip->game_io + reg);\n}\n\nstatic inline u8\nsnd_azf3328_game_inb(const struct snd_azf3328 *chip, unsigned reg)\n{\n\treturn inb(chip->game_io + reg);\n}\n\nstatic inline u16\nsnd_azf3328_game_inw(const struct snd_azf3328 *chip, unsigned reg)\n{\n\treturn inw(chip->game_io + reg);\n}\n\nstatic inline void\nsnd_azf3328_mixer_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)\n{\n\toutw(value, chip->mixer_io + reg);\n}\n\nstatic inline u16\nsnd_azf3328_mixer_inw(const struct snd_azf3328 *chip, unsigned reg)\n{\n\treturn inw(chip->mixer_io + reg);\n}\n\n#define AZF_MUTE_BIT 0x80\n\nstatic bool\nsnd_azf3328_mixer_mute_control(const struct snd_azf3328 *chip,\n\t\t\t   unsigned reg, bool do_mute\n)\n{\n\tunsigned long portbase = chip->mixer_io + reg + 1;\n\tbool updated;\n\n\t \n\tupdated = snd_azf3328_io_reg_setb(portbase, AZF_MUTE_BIT, do_mute);\n\n\t \n\treturn (do_mute) ? !updated : updated;\n}\n\nstatic inline bool\nsnd_azf3328_mixer_mute_control_master(const struct snd_azf3328 *chip,\n\t\t\t   bool do_mute\n)\n{\n\treturn snd_azf3328_mixer_mute_control(\n\t\tchip,\n\t\tIDX_MIXER_PLAY_MASTER,\n\t\tdo_mute\n\t);\n}\n\nstatic inline bool\nsnd_azf3328_mixer_mute_control_pcm(const struct snd_azf3328 *chip,\n\t\t\t   bool do_mute\n)\n{\n\treturn snd_azf3328_mixer_mute_control(\n\t\tchip,\n\t\tIDX_MIXER_WAVEOUT,\n\t\tdo_mute\n\t);\n}\n\nstatic inline void\nsnd_azf3328_mixer_reset(const struct snd_azf3328 *chip)\n{\n\t \n\tsnd_azf3328_mixer_mute_control_master(chip, 1);\n\tsnd_azf3328_mixer_outw(chip, IDX_MIXER_RESET, 0x0000);\n}\n\n#ifdef AZF_USE_AC97_LAYER\n\nstatic inline void\nsnd_azf3328_mixer_ac97_map_unsupported(const struct snd_azf3328 *chip,\n\t\t\t\t       unsigned short reg, const char *mode)\n{\n\t \n\tdev_warn(chip->card->dev,\n\t\t\"missing %s emulation for AC97 register 0x%02x!\\n\",\n\t\tmode, reg);\n}\n\n \n#define AZF_REG_MASK 0x3f\n#define AZF_AC97_REG_UNSUPPORTED 0x8000\n#define AZF_AC97_REG_REAL_IO_READ 0x4000\n#define AZF_AC97_REG_REAL_IO_WRITE 0x2000\n#define AZF_AC97_REG_REAL_IO_RW \\\n\t(AZF_AC97_REG_REAL_IO_READ | AZF_AC97_REG_REAL_IO_WRITE)\n#define AZF_AC97_REG_EMU_IO_READ 0x0400\n#define AZF_AC97_REG_EMU_IO_WRITE 0x0200\n#define AZF_AC97_REG_EMU_IO_RW \\\n\t(AZF_AC97_REG_EMU_IO_READ | AZF_AC97_REG_EMU_IO_WRITE)\nstatic unsigned short\nsnd_azf3328_mixer_ac97_map_reg_idx(unsigned short reg)\n{\n\tstatic const struct {\n\t\tunsigned short azf_reg;\n\t} azf_reg_mapper[] = {\n\t\t \n\t\t{   IDX_MIXER_RESET\n\t\t\t| AZF_AC97_REG_REAL_IO_WRITE\n\t\t\t| AZF_AC97_REG_EMU_IO_READ },\n\t\t{   IDX_MIXER_PLAY_MASTER },\n\t\t  \n\t\t{   IDX_MIXER_FMSYNTH },\n\t\t{   IDX_MIXER_MODEMOUT },\n\t\t{   IDX_MIXER_BASSTREBLE },\n\t\t{   IDX_MIXER_PCBEEP },\n\t\t{   IDX_MIXER_MODEMIN },\n\t\t{   IDX_MIXER_MIC },\n\t\t{   IDX_MIXER_LINEIN },\n\t\t{   IDX_MIXER_CDAUDIO },\n\t\t{   IDX_MIXER_VIDEO },\n\t\t{   IDX_MIXER_AUX },\n\t\t{   IDX_MIXER_WAVEOUT },\n\t\t{   IDX_MIXER_REC_SELECT },\n\t\t{   IDX_MIXER_REC_VOLUME },\n\t\t{   AZF_AC97_REG_EMU_IO_RW },\n\t\t{   IDX_MIXER_ADVCTL2 },\n\t\t{   IDX_MIXER_ADVCTL1 },\n\t};\n\n\tunsigned short reg_azf = AZF_AC97_REG_UNSUPPORTED;\n\n\t \n\tif (reg <= AC97_3D_CONTROL) {\n\t\tunsigned short reg_idx = reg / 2;\n\t\treg_azf = azf_reg_mapper[reg_idx].azf_reg;\n\t\t \n\t\tif (!(reg_azf & ~AZF_REG_MASK))\n\t\t\treg_azf |= AZF_AC97_REG_REAL_IO_RW;\n\t} else {\n\t\tswitch (reg) {\n\t\tcase AC97_POWERDOWN:\n\t\t\treg_azf = AZF_AC97_REG_EMU_IO_RW;\n\t\t\tbreak;\n\t\tcase AC97_EXTENDED_ID:\n\t\t\treg_azf = AZF_AC97_REG_EMU_IO_READ;\n\t\t\tbreak;\n\t\tcase AC97_EXTENDED_STATUS:\n\t\t\t \n\t\t\treg_azf = AZF_AC97_REG_EMU_IO_RW;\n\t\t\tbreak;\n\t\tcase AC97_VENDOR_ID1:\n\t\tcase AC97_VENDOR_ID2:\n\t\t\treg_azf = AZF_AC97_REG_EMU_IO_READ;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn reg_azf;\n}\n\nstatic const unsigned short\nazf_emulated_ac97_caps =\n\tAC97_BC_DEDICATED_MIC |\n\tAC97_BC_BASS_TREBLE |\n\t \n\tAC97_BC_HEADPHONE |\n\t \n\t \n\t(13 << 10);\n\nstatic const unsigned short\nazf_emulated_ac97_powerdown =\n\t \n\t\tAC97_PD_ADC_STATUS |\n\t\tAC97_PD_DAC_STATUS |\n\t\tAC97_PD_MIXER_STATUS |\n\t\tAC97_PD_VREF_STATUS;\n\n \nstatic const unsigned int\nazf_emulated_ac97_vendor_id = 0x415a5401;\n\nstatic unsigned short\nsnd_azf3328_mixer_ac97_read(struct snd_ac97 *ac97, unsigned short reg_ac97)\n{\n\tconst struct snd_azf3328 *chip = ac97->private_data;\n\tunsigned short reg_azf = snd_azf3328_mixer_ac97_map_reg_idx(reg_ac97);\n\tunsigned short reg_val = 0;\n\tbool unsupported = false;\n\n\tdev_dbg(chip->card->dev, \"snd_azf3328_mixer_ac97_read reg_ac97 %u\\n\",\n\t\treg_ac97);\n\tif (reg_azf & AZF_AC97_REG_UNSUPPORTED)\n\t\tunsupported = true;\n\telse {\n\t\tif (reg_azf & AZF_AC97_REG_REAL_IO_READ)\n\t\t\treg_val = snd_azf3328_mixer_inw(chip,\n\t\t\t\t\t\treg_azf & AZF_REG_MASK);\n\t\telse {\n\t\t\t \n\t\t\tsnd_azf3328_mixer_inw(chip, IDX_MIXER_SOMETHING30H);\n\t\t}\n\n\t\tif (reg_azf & AZF_AC97_REG_EMU_IO_READ) {\n\t\t\tswitch (reg_ac97) {\n\t\t\tcase AC97_RESET:\n\t\t\t\treg_val |= azf_emulated_ac97_caps;\n\t\t\t\tbreak;\n\t\t\tcase AC97_POWERDOWN:\n\t\t\t\treg_val |= azf_emulated_ac97_powerdown;\n\t\t\t\tbreak;\n\t\t\tcase AC97_EXTENDED_ID:\n\t\t\tcase AC97_EXTENDED_STATUS:\n\t\t\t\t \n\t\t\t\treg_val |= 0;\n\t\t\t\tbreak;\n\t\t\tcase AC97_VENDOR_ID1:\n\t\t\t\treg_val = azf_emulated_ac97_vendor_id >> 16;\n\t\t\t\tbreak;\n\t\t\tcase AC97_VENDOR_ID2:\n\t\t\t\treg_val = azf_emulated_ac97_vendor_id & 0xffff;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunsupported = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (unsupported)\n\t\tsnd_azf3328_mixer_ac97_map_unsupported(chip, reg_ac97, \"read\");\n\n\treturn reg_val;\n}\n\nstatic void\nsnd_azf3328_mixer_ac97_write(struct snd_ac97 *ac97,\n\t\t     unsigned short reg_ac97, unsigned short val)\n{\n\tconst struct snd_azf3328 *chip = ac97->private_data;\n\tunsigned short reg_azf = snd_azf3328_mixer_ac97_map_reg_idx(reg_ac97);\n\tbool unsupported = false;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"snd_azf3328_mixer_ac97_write reg_ac97 %u val %u\\n\",\n\t\treg_ac97, val);\n\tif (reg_azf & AZF_AC97_REG_UNSUPPORTED)\n\t\tunsupported = true;\n\telse {\n\t\tif (reg_azf & AZF_AC97_REG_REAL_IO_WRITE)\n\t\t\tsnd_azf3328_mixer_outw(\n\t\t\t\tchip,\n\t\t\t\treg_azf & AZF_REG_MASK,\n\t\t\t\tval\n\t\t\t);\n\t\telse\n\t\tif (reg_azf & AZF_AC97_REG_EMU_IO_WRITE) {\n\t\t\tswitch (reg_ac97) {\n\t\t\tcase AC97_REC_GAIN_MIC:\n\t\t\tcase AC97_POWERDOWN:\n\t\t\tcase AC97_EXTENDED_STATUS:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunsupported = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (unsupported)\n\t\tsnd_azf3328_mixer_ac97_map_unsupported(chip, reg_ac97, \"write\");\n}\n\nstatic int\nsnd_azf3328_mixer_new(struct snd_azf3328 *chip)\n{\n\tstruct snd_ac97_bus *bus;\n\tstruct snd_ac97_template ac97;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_azf3328_mixer_ac97_write,\n\t\t.read = snd_azf3328_mixer_ac97_read,\n\t};\n\tint rc;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.scaps = AC97_SCAP_SKIP_MODEM\n\t\t\t| AC97_SCAP_AUDIO  \n\t\t\t| AC97_SCAP_NO_SPDIF;\n\tac97.private_data = chip;\n\tac97.pci = chip->pci;\n\n\t \n\n\trc = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus);\n\tif (!rc)\n\t\trc = snd_ac97_mixer(bus, &ac97, &chip->ac97);\n\t\t \n\tif (rc)\n\t\tdev_err(chip->card->dev, \"AC97 init failed, err %d!\\n\", rc);\n\n\t \n\treturn rc;\n}\n#else  \nstatic void\nsnd_azf3328_mixer_write_volume_gradually(const struct snd_azf3328 *chip,\n\t\t\t\t\t unsigned reg,\n\t\t\t\t\t unsigned char dst_vol_left,\n\t\t\t\t\t unsigned char dst_vol_right,\n\t\t\t\t\t int chan_sel, int delay\n)\n{\n\tunsigned long portbase = chip->mixer_io + reg;\n\tunsigned char curr_vol_left = 0, curr_vol_right = 0;\n\tint left_change = 0, right_change = 0;\n\n\tif (chan_sel & SET_CHAN_LEFT) {\n\t\tcurr_vol_left  = inb(portbase + 1);\n\n\t\t \n\t\tif (curr_vol_left & AZF_MUTE_BIT)\n\t\t\tdst_vol_left |= AZF_MUTE_BIT;\n\t\telse\n\t\t\tdst_vol_left &= ~AZF_MUTE_BIT;\n\n\t\tleft_change = (curr_vol_left > dst_vol_left) ? -1 : 1;\n\t}\n\n\tif (chan_sel & SET_CHAN_RIGHT) {\n\t\tcurr_vol_right = inb(portbase + 0);\n\n\t\tright_change = (curr_vol_right > dst_vol_right) ? -1 : 1;\n\t}\n\n\tdo {\n\t\tif (left_change) {\n\t\t\tif (curr_vol_left != dst_vol_left) {\n\t\t\t\tcurr_vol_left += left_change;\n\t\t\t\toutb(curr_vol_left, portbase + 1);\n\t\t\t} else\n\t\t\t    left_change = 0;\n\t\t}\n\t\tif (right_change) {\n\t\t\tif (curr_vol_right != dst_vol_right) {\n\t\t\t\tcurr_vol_right += right_change;\n\n\t\t\t \n\t\t\t\toutb(curr_vol_right, portbase + 0);\n\t\t\t} else\n\t\t\t    right_change = 0;\n\t\t}\n\t\tif (delay)\n\t\t\tmdelay(delay);\n\t} while ((left_change) || (right_change));\n}\n\n \nstruct azf3328_mixer_reg {\n\tunsigned reg;\n\tunsigned int lchan_shift, rchan_shift;\n\tunsigned int mask;\n\tunsigned int invert: 1;\n\tunsigned int stereo: 1;\n\tunsigned int enum_c: 4;\n};\n\n#define COMPOSE_MIXER_REG(reg,lchan_shift,rchan_shift,mask,invert,stereo,enum_c) \\\n ((reg) | (lchan_shift << 8) | (rchan_shift << 12) | \\\n  (mask << 16) | \\\n  (invert << 24) | \\\n  (stereo << 25) | \\\n  (enum_c << 26))\n\nstatic void snd_azf3328_mixer_reg_decode(struct azf3328_mixer_reg *r, unsigned long val)\n{\n\tr->reg = val & 0xff;\n\tr->lchan_shift = (val >> 8) & 0x0f;\n\tr->rchan_shift = (val >> 12) & 0x0f;\n\tr->mask = (val >> 16) & 0xff;\n\tr->invert = (val >> 24) & 1;\n\tr->stereo = (val >> 25) & 1;\n\tr->enum_c = (val >> 26) & 0x0f;\n}\n\n \n\n#define AZF3328_MIXER_SWITCH(xname, reg, shift, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_azf3328_info_mixer, \\\n  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \\\n  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, 0x1, invert, 0, 0), \\\n}\n\n#define AZF3328_MIXER_VOL_STEREO(xname, reg, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_azf3328_info_mixer, \\\n  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \\\n  .private_value = COMPOSE_MIXER_REG(reg, 8, 0, mask, invert, 1, 0), \\\n}\n\n#define AZF3328_MIXER_VOL_MONO(xname, reg, mask, is_right_chan) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_azf3328_info_mixer, \\\n  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \\\n  .private_value = COMPOSE_MIXER_REG(reg, is_right_chan ? 0 : 8, 0, mask, 1, 0, 0), \\\n}\n\n#define AZF3328_MIXER_VOL_SPECIAL(xname, reg, mask, shift, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_azf3328_info_mixer, \\\n  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \\\n  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, mask, invert, 0, 0), \\\n}\n\n#define AZF3328_MIXER_ENUM(xname, reg, enum_c, shift) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_azf3328_info_mixer_enum, \\\n  .get = snd_azf3328_get_mixer_enum, .put = snd_azf3328_put_mixer_enum, \\\n  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, 0, 0, 0, enum_c), \\\n}\n\nstatic int\nsnd_azf3328_info_mixer(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct azf3328_mixer_reg reg;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\tuinfo->type = reg.mask == 1 ?\n\t\tSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = reg.stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = reg.mask;\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_get_mixer(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct azf3328_mixer_reg reg;\n\tu16 oreg, val;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\n\toreg = snd_azf3328_mixer_inw(chip, reg.reg);\n\tval = (oreg >> reg.lchan_shift) & reg.mask;\n\tif (reg.invert)\n\t\tval = reg.mask - val;\n\tucontrol->value.integer.value[0] = val;\n\tif (reg.stereo) {\n\t\tval = (oreg >> reg.rchan_shift) & reg.mask;\n\t\tif (reg.invert)\n\t\t\tval = reg.mask - val;\n\t\tucontrol->value.integer.value[1] = val;\n\t}\n\tdev_dbg(chip->card->dev,\n\t\t\"get: %02x is %04x -> vol %02lx|%02lx (shift %02d|%02d, mask %02x, inv. %d, stereo %d)\\n\",\n\t\treg.reg, oreg,\n\t\tucontrol->value.integer.value[0], ucontrol->value.integer.value[1],\n\t\treg.lchan_shift, reg.rchan_shift, reg.mask, reg.invert, reg.stereo);\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_put_mixer(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct azf3328_mixer_reg reg;\n\tu16 oreg, nreg, val;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\toreg = snd_azf3328_mixer_inw(chip, reg.reg);\n\tval = ucontrol->value.integer.value[0] & reg.mask;\n\tif (reg.invert)\n\t\tval = reg.mask - val;\n\tnreg = oreg & ~(reg.mask << reg.lchan_shift);\n\tnreg |= (val << reg.lchan_shift);\n\tif (reg.stereo) {\n\t\tval = ucontrol->value.integer.value[1] & reg.mask;\n\t\tif (reg.invert)\n\t\t\tval = reg.mask - val;\n\t\tnreg &= ~(reg.mask << reg.rchan_shift);\n\t\tnreg |= (val << reg.rchan_shift);\n\t}\n\tif (reg.mask >= 0x07)  \n\t\tsnd_azf3328_mixer_write_volume_gradually(\n\t\t\tchip, reg.reg, nreg >> 8, nreg & 0xff,\n\t\t\t \n\t\t\tSET_CHAN_LEFT|SET_CHAN_RIGHT,\n\t\t\t0);\n\telse\n        \tsnd_azf3328_mixer_outw(chip, reg.reg, nreg);\n\n\tdev_dbg(chip->card->dev,\n\t\t\"put: %02x to %02lx|%02lx, oreg %04x; shift %02d|%02d -> nreg %04x; after: %04x\\n\",\n\t\treg.reg, ucontrol->value.integer.value[0], ucontrol->value.integer.value[1],\n\t\toreg, reg.lchan_shift, reg.rchan_shift,\n\t\tnreg, snd_azf3328_mixer_inw(chip, reg.reg));\n\treturn (nreg != oreg);\n}\n\nstatic int\nsnd_azf3328_info_mixer_enum(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts1[] = {\n\t\t\"Mic1\", \"Mic2\"\n\t};\n\tstatic const char * const texts2[] = {\n\t\t\"Mix\", \"Mic\"\n\t};\n\tstatic const char * const texts3[] = {\n\t\t\"Mic\", \"CD\", \"Video\", \"Aux\",\n\t\t\"Line\", \"Mix\", \"Mix Mono\", \"Phone\"\n        };\n\tstatic const char * const texts4[] = {\n\t\t\"pre 3D\", \"post 3D\"\n        };\n\tstruct azf3328_mixer_reg reg;\n\tconst char * const *p = NULL;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\tif (reg.reg == IDX_MIXER_ADVCTL2) {\n\t\tswitch(reg.lchan_shift) {\n\t\tcase 8:  \n\t\t\tp = texts1;\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\tp = texts2;\n\t\t\tbreak;\n\t\tcase 15:  \n\t\t\tp = texts4;\n\t\t\tbreak;\n\t\t}\n\t} else if (reg.reg == IDX_MIXER_REC_SELECT)\n\t\tp = texts3;\n\n\treturn snd_ctl_enum_info(uinfo,\n\t\t\t\t (reg.reg == IDX_MIXER_REC_SELECT) ? 2 : 1,\n\t\t\t\t reg.enum_c, p);\n}\n\nstatic int\nsnd_azf3328_get_mixer_enum(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct azf3328_mixer_reg reg;\n        unsigned short val;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\tval = snd_azf3328_mixer_inw(chip, reg.reg);\n\tif (reg.reg == IDX_MIXER_REC_SELECT) {\n        \tucontrol->value.enumerated.item[0] = (val >> 8) & (reg.enum_c - 1);\n        \tucontrol->value.enumerated.item[1] = (val >> 0) & (reg.enum_c - 1);\n\t} else\n        \tucontrol->value.enumerated.item[0] = (val >> reg.lchan_shift) & (reg.enum_c - 1);\n\n\tdev_dbg(chip->card->dev,\n\t\t\"get_enum: %02x is %04x -> %d|%d (shift %02d, enum_c %d)\\n\",\n\t\treg.reg, val, ucontrol->value.enumerated.item[0], ucontrol->value.enumerated.item[1],\n\t\treg.lchan_shift, reg.enum_c);\n        return 0;\n}\n\nstatic int\nsnd_azf3328_put_mixer_enum(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_azf3328 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct azf3328_mixer_reg reg;\n\tu16 oreg, nreg, val;\n\n\tsnd_azf3328_mixer_reg_decode(&reg, kcontrol->private_value);\n\toreg = snd_azf3328_mixer_inw(chip, reg.reg);\n\tval = oreg;\n\tif (reg.reg == IDX_MIXER_REC_SELECT) {\n        \tif (ucontrol->value.enumerated.item[0] > reg.enum_c - 1U ||\n            \tucontrol->value.enumerated.item[1] > reg.enum_c - 1U)\n                \treturn -EINVAL;\n        \tval = (ucontrol->value.enumerated.item[0] << 8) |\n        \t      (ucontrol->value.enumerated.item[1] << 0);\n\t} else {\n        \tif (ucontrol->value.enumerated.item[0] > reg.enum_c - 1U)\n                \treturn -EINVAL;\n\t\tval &= ~((reg.enum_c - 1) << reg.lchan_shift);\n        \tval |= (ucontrol->value.enumerated.item[0] << reg.lchan_shift);\n\t}\n\tsnd_azf3328_mixer_outw(chip, reg.reg, val);\n\tnreg = val;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"put_enum: %02x to %04x, oreg %04x\\n\", reg.reg, val, oreg);\n\treturn (nreg != oreg);\n}\n\nstatic const struct snd_kcontrol_new snd_azf3328_mixer_controls[] = {\n\tAZF3328_MIXER_SWITCH(\"Master Playback Switch\", IDX_MIXER_PLAY_MASTER, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"Master Playback Volume\", IDX_MIXER_PLAY_MASTER, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"PCM Playback Switch\", IDX_MIXER_WAVEOUT, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"PCM Playback Volume\",\n\t\t\t\t\tIDX_MIXER_WAVEOUT, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"PCM 3D Bypass Playback Switch\",\n\t\t\t\t\tIDX_MIXER_ADVCTL2, 7, 1),\n\tAZF3328_MIXER_SWITCH(\"FM Playback Switch\", IDX_MIXER_FMSYNTH, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"FM Playback Volume\", IDX_MIXER_FMSYNTH, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"CD Playback Switch\", IDX_MIXER_CDAUDIO, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"CD Playback Volume\", IDX_MIXER_CDAUDIO, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Capture Switch\", IDX_MIXER_REC_VOLUME, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"Capture Volume\", IDX_MIXER_REC_VOLUME, 0x0f, 0),\n\tAZF3328_MIXER_ENUM(\"Capture Source\", IDX_MIXER_REC_SELECT, 8, 0),\n\tAZF3328_MIXER_SWITCH(\"Mic Playback Switch\", IDX_MIXER_MIC, 15, 1),\n\tAZF3328_MIXER_VOL_MONO(\"Mic Playback Volume\", IDX_MIXER_MIC, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Mic Boost (+20dB)\", IDX_MIXER_MIC, 6, 0),\n\tAZF3328_MIXER_SWITCH(\"Line Playback Switch\", IDX_MIXER_LINEIN, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"Line Playback Volume\", IDX_MIXER_LINEIN, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Beep Playback Switch\", IDX_MIXER_PCBEEP, 15, 1),\n\tAZF3328_MIXER_VOL_SPECIAL(\"Beep Playback Volume\", IDX_MIXER_PCBEEP, 0x0f, 1, 1),\n\tAZF3328_MIXER_SWITCH(\"Video Playback Switch\", IDX_MIXER_VIDEO, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"Video Playback Volume\", IDX_MIXER_VIDEO, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Aux Playback Switch\", IDX_MIXER_AUX, 15, 1),\n\tAZF3328_MIXER_VOL_STEREO(\"Aux Playback Volume\", IDX_MIXER_AUX, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Modem Playback Switch\", IDX_MIXER_MODEMOUT, 15, 1),\n\tAZF3328_MIXER_VOL_MONO(\"Modem Playback Volume\", IDX_MIXER_MODEMOUT, 0x1f, 1),\n\tAZF3328_MIXER_SWITCH(\"Modem Capture Switch\", IDX_MIXER_MODEMIN, 15, 1),\n\tAZF3328_MIXER_VOL_MONO(\"Modem Capture Volume\", IDX_MIXER_MODEMIN, 0x1f, 1),\n\tAZF3328_MIXER_ENUM(\"Mic Select\", IDX_MIXER_ADVCTL2, 2, 8),\n\tAZF3328_MIXER_ENUM(\"Mono Output Select\", IDX_MIXER_ADVCTL2, 2, 9),\n\tAZF3328_MIXER_ENUM(\"PCM Output Route\", IDX_MIXER_ADVCTL2, 2, 15),  \n\tAZF3328_MIXER_VOL_SPECIAL(\"Tone Control - Treble\", IDX_MIXER_BASSTREBLE, 0x07, 1, 0),\n\tAZF3328_MIXER_VOL_SPECIAL(\"Tone Control - Bass\", IDX_MIXER_BASSTREBLE, 0x07, 9, 0),\n\tAZF3328_MIXER_SWITCH(\"3D Control - Switch\", IDX_MIXER_ADVCTL2, 13, 0),\n\tAZF3328_MIXER_VOL_SPECIAL(\"3D Control - Width\", IDX_MIXER_ADVCTL1, 0x07, 1, 0),  \n\tAZF3328_MIXER_VOL_SPECIAL(\"3D Control - Depth\", IDX_MIXER_ADVCTL1, 0x03, 8, 0),  \n#if MIXER_TESTING\n\tAZF3328_MIXER_SWITCH(\"0\", IDX_MIXER_ADVCTL2, 0, 0),\n\tAZF3328_MIXER_SWITCH(\"1\", IDX_MIXER_ADVCTL2, 1, 0),\n\tAZF3328_MIXER_SWITCH(\"2\", IDX_MIXER_ADVCTL2, 2, 0),\n\tAZF3328_MIXER_SWITCH(\"3\", IDX_MIXER_ADVCTL2, 3, 0),\n\tAZF3328_MIXER_SWITCH(\"4\", IDX_MIXER_ADVCTL2, 4, 0),\n\tAZF3328_MIXER_SWITCH(\"5\", IDX_MIXER_ADVCTL2, 5, 0),\n\tAZF3328_MIXER_SWITCH(\"6\", IDX_MIXER_ADVCTL2, 6, 0),\n\tAZF3328_MIXER_SWITCH(\"7\", IDX_MIXER_ADVCTL2, 7, 0),\n\tAZF3328_MIXER_SWITCH(\"8\", IDX_MIXER_ADVCTL2, 8, 0),\n\tAZF3328_MIXER_SWITCH(\"9\", IDX_MIXER_ADVCTL2, 9, 0),\n\tAZF3328_MIXER_SWITCH(\"10\", IDX_MIXER_ADVCTL2, 10, 0),\n\tAZF3328_MIXER_SWITCH(\"11\", IDX_MIXER_ADVCTL2, 11, 0),\n\tAZF3328_MIXER_SWITCH(\"12\", IDX_MIXER_ADVCTL2, 12, 0),\n\tAZF3328_MIXER_SWITCH(\"13\", IDX_MIXER_ADVCTL2, 13, 0),\n\tAZF3328_MIXER_SWITCH(\"14\", IDX_MIXER_ADVCTL2, 14, 0),\n\tAZF3328_MIXER_SWITCH(\"15\", IDX_MIXER_ADVCTL2, 15, 0),\n#endif\n};\n\nstatic const u16 snd_azf3328_init_values[][2] = {\n        { IDX_MIXER_PLAY_MASTER,\tMIXER_MUTE_MASK|0x1f1f },\n        { IDX_MIXER_MODEMOUT,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_BASSTREBLE,\t\t0x0000 },\n\t{ IDX_MIXER_PCBEEP,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_MODEMIN,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_MIC,\t\tMIXER_MUTE_MASK|0x001f },\n\t{ IDX_MIXER_LINEIN,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_CDAUDIO,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_VIDEO,\t\tMIXER_MUTE_MASK|0x1f1f },\n\t{ IDX_MIXER_AUX,\t\tMIXER_MUTE_MASK|0x1f1f },\n        { IDX_MIXER_WAVEOUT,\t\tMIXER_MUTE_MASK|0x1f1f },\n        { IDX_MIXER_FMSYNTH,\t\tMIXER_MUTE_MASK|0x1f1f },\n        { IDX_MIXER_REC_VOLUME,\t\tMIXER_MUTE_MASK|0x0707 },\n};\n\nstatic int\nsnd_azf3328_mixer_new(struct snd_azf3328 *chip)\n{\n\tstruct snd_card *card;\n\tconst struct snd_kcontrol_new *sw;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!chip || !chip->card))\n\t\treturn -EINVAL;\n\n\tcard = chip->card;\n\n\t \n\tsnd_azf3328_mixer_outw(chip, IDX_MIXER_RESET, 0x0000);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_azf3328_init_values); ++idx) {\n\t\tsnd_azf3328_mixer_outw(chip,\n\t\t\tsnd_azf3328_init_values[idx][0],\n\t\t\tsnd_azf3328_init_values[idx][1]);\n\t}\n\n\t \n\tsw = snd_azf3328_mixer_controls;\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_azf3328_mixer_controls);\n\t\t\t++idx, ++sw) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(sw, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_component_add(card, \"AZF3328 mixer\");\n\tstrcpy(card->mixername, \"AZF3328 mixer\");\n\n\treturn 0;\n}\n#endif  \n\nstatic void\nsnd_azf3328_codec_setfmt(struct snd_azf3328_codec_data *codec,\n\t\t\t       enum azf_freq_t bitrate,\n\t\t\t       unsigned int format_width,\n\t\t\t       unsigned int channels\n)\n{\n\tunsigned long flags;\n\tu16 val = 0xff00;\n\tu8 freq = 0;\n\n\tswitch (bitrate) {\n\tcase AZF_FREQ_4000:  freq = SOUNDFORMAT_FREQ_SUSPECTED_4000; break;\n\tcase AZF_FREQ_4800:  freq = SOUNDFORMAT_FREQ_SUSPECTED_4800; break;\n\tcase AZF_FREQ_5512:\n\t\t \n\t\t\t     freq = SOUNDFORMAT_FREQ_5510; break;\n\tcase AZF_FREQ_6620:  freq = SOUNDFORMAT_FREQ_6620; break;\n\tcase AZF_FREQ_8000:  freq = SOUNDFORMAT_FREQ_8000; break;\n\tcase AZF_FREQ_9600:  freq = SOUNDFORMAT_FREQ_9600; break;\n\tcase AZF_FREQ_11025: freq = SOUNDFORMAT_FREQ_11025; break;\n\tcase AZF_FREQ_13240: freq = SOUNDFORMAT_FREQ_SUSPECTED_13240; break;\n\tcase AZF_FREQ_16000: freq = SOUNDFORMAT_FREQ_16000; break;\n\tcase AZF_FREQ_22050: freq = SOUNDFORMAT_FREQ_22050; break;\n\tcase AZF_FREQ_32000: freq = SOUNDFORMAT_FREQ_32000; break;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"unknown bitrate %d, assuming 44.1kHz!\\n\", bitrate);\n\t\tfallthrough;\n\tcase AZF_FREQ_44100: freq = SOUNDFORMAT_FREQ_44100; break;\n\tcase AZF_FREQ_48000: freq = SOUNDFORMAT_FREQ_48000; break;\n\tcase AZF_FREQ_66200: freq = SOUNDFORMAT_FREQ_SUSPECTED_66200; break;\n\t}\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\n\tval |= freq;\n\n\tif (channels == 2)\n\t\tval |= SOUNDFORMAT_FLAG_2CHANNELS;\n\n\tif (format_width == 16)\n\t\tval |= SOUNDFORMAT_FLAG_16BIT;\n\n\tspin_lock_irqsave(codec->lock, flags);\n\n\t \n\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_SOUNDFORMAT, val);\n\n\t \n\t \n\tif (codec->type != AZF_CODEC_CAPTURE)\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\tsnd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS) |\n\t\t\tDMA_RUN_SOMETHING1 |\n\t\t\tDMA_RUN_SOMETHING2 |\n\t\t\tSOMETHING_ALMOST_ALWAYS_SET |\n\t\t\tDMA_EPILOGUE_SOMETHING |\n\t\t\tDMA_SOMETHING_ELSE\n\t\t);\n\n\tspin_unlock_irqrestore(codec->lock, flags);\n}\n\nstatic inline void\nsnd_azf3328_codec_setfmt_lowpower(struct snd_azf3328_codec_data *codec\n)\n{\n\t \n\tsnd_azf3328_codec_setfmt(codec, AZF_FREQ_4000, 8, 1);\n}\n\nstatic void\nsnd_azf3328_ctrl_reg_6AH_update(struct snd_azf3328 *chip,\n\t\t\t\t\tunsigned bitmask,\n\t\t\t\t\tbool enable\n)\n{\n\tbool do_mask = !enable;\n\tif (do_mask)\n\t\tchip->shadow_reg_ctrl_6AH |= bitmask;\n\telse\n\t\tchip->shadow_reg_ctrl_6AH &= ~bitmask;\n\tdev_dbg(chip->card->dev,\n\t\t\"6AH_update mask 0x%04x do_mask %d: val 0x%04x\\n\",\n\t\tbitmask, do_mask, chip->shadow_reg_ctrl_6AH);\n\tsnd_azf3328_ctrl_outw(chip, IDX_IO_6AH, chip->shadow_reg_ctrl_6AH);\n}\n\nstatic inline void\nsnd_azf3328_ctrl_enable_codecs(struct snd_azf3328 *chip, bool enable)\n{\n\tdev_dbg(chip->card->dev, \"codec_enable %d\\n\", enable);\n\t \n\tsnd_azf3328_ctrl_reg_6AH_update(\n\t\tchip, IO_6A_PAUSE_PLAYBACK_BIT8, enable\n\t);\n}\n\nstatic void\nsnd_azf3328_ctrl_codec_activity(struct snd_azf3328 *chip,\n\t\t\t\tenum snd_azf3328_codec_type codec_type,\n\t\t\t\tbool enable\n)\n{\n\tstruct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];\n\tbool need_change = (codec->running != enable);\n\n\tdev_dbg(chip->card->dev,\n\t\t\"codec_activity: %s codec, enable %d, need_change %d\\n\",\n\t\t\t\tcodec->name, enable, need_change\n\t);\n\tif (need_change) {\n\t\tstatic const struct {\n\t\t\tenum snd_azf3328_codec_type other1;\n\t\t\tenum snd_azf3328_codec_type other2;\n\t\t} peer_codecs[3] =\n\t\t\t{ { AZF_CODEC_CAPTURE, AZF_CODEC_I2S_OUT },\n\t\t\t  { AZF_CODEC_PLAYBACK, AZF_CODEC_I2S_OUT },\n\t\t\t  { AZF_CODEC_PLAYBACK, AZF_CODEC_CAPTURE } };\n\t\tbool call_function;\n\n\t\tif (enable)\n\t\t\t \n\t\t\tcall_function = 1;\n\t\telse {\n\t\t\t \n\t\t\tcall_function =\n\t\t\t\t((!chip->codecs[peer_codecs[codec_type].other1]\n\t\t\t\t\t.running)\n\t\t\t     &&  (!chip->codecs[peer_codecs[codec_type].other2]\n\t\t\t\t\t.running));\n\t\t}\n\t\tif (call_function)\n\t\t\tsnd_azf3328_ctrl_enable_codecs(chip, enable);\n\n\t\t \n\t\tif (!enable)\n\t\t\tsnd_azf3328_codec_setfmt_lowpower(codec);\n\t\tcodec->running = enable;\n\t}\n}\n\nstatic void\nsnd_azf3328_codec_setdmaa(struct snd_azf3328 *chip,\n\t\t\t  struct snd_azf3328_codec_data *codec,\n\t\t\t  unsigned long addr,\n\t\t\t  unsigned int period_bytes,\n\t\t\t  unsigned int buffer_bytes\n)\n{\n\tWARN_ONCE(period_bytes & 1, \"odd period length!?\\n\");\n\tWARN_ONCE(buffer_bytes != 2 * period_bytes,\n\t\t \"missed our input expectations! %u vs. %u\\n\",\n\t\t buffer_bytes, period_bytes);\n\tif (!codec->running) {\n\t\t \n\n\t\tunsigned long flags;\n\n\t\t \n\t\tu32 area_length;\n\t\tstruct codec_setup_io {\n\t\t\tu32 dma_start_1;\n\t\t\tu32 dma_start_2;\n\t\t\tu32 dma_lengths;\n\t\t} __attribute__((packed)) setup_io;\n\n\t\tarea_length = buffer_bytes/2;\n\n\t\tsetup_io.dma_start_1 = addr;\n\t\tsetup_io.dma_start_2 = addr+area_length;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"setdma: buffers %08x[%u] / %08x[%u], %u, %u\\n\",\n\t\t\t\tsetup_io.dma_start_1, area_length,\n\t\t\t\tsetup_io.dma_start_2, area_length,\n\t\t\t\tperiod_bytes, buffer_bytes);\n\n\t\t \n\n\t\t \n\t\tsetup_io.dma_lengths = (area_length << 16) | (area_length);\n\n\t\tspin_lock_irqsave(codec->lock, flags);\n\t\tsnd_azf3328_codec_outl_multi(\n\t\t\tcodec, IDX_IO_CODEC_DMA_START_1, &setup_io, 3\n\t\t);\n\t\tspin_unlock_irqrestore(codec->lock, flags);\n\t}\n}\n\nstatic int\nsnd_azf3328_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_azf3328_codec_data *codec = runtime->private_data;\n#if 0\n        unsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n#endif\n\n\tcodec->dma_base = runtime->dma_addr;\n\n#if 0\n\tsnd_azf3328_codec_setfmt(codec,\n\t\truntime->rate,\n\t\tsnd_pcm_format_width(runtime->format),\n\t\truntime->channels);\n\tsnd_azf3328_codec_setdmaa(chip, codec,\n\t\t\t\t\truntime->dma_addr, count, size);\n#endif\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_azf3328 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_azf3328_codec_data *codec = runtime->private_data;\n\tint result = 0;\n\tu16 flags1;\n\tbool previously_muted = false;\n\tbool is_main_mixer_playback_codec = (AZF_CODEC_PLAYBACK == codec->type);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdev_dbg(chip->card->dev, \"START PCM %s\\n\", codec->name);\n\n\t\tif (is_main_mixer_playback_codec) {\n\t\t\t \n\t\t\tpreviously_muted =\n\t\t\t\tsnd_azf3328_mixer_mute_control_pcm(\n\t\t\t\t\t\tchip, 1\n\t\t\t\t);\n\t\t}\n\n\t\tsnd_azf3328_codec_setfmt(codec,\n\t\t\truntime->rate,\n\t\t\tsnd_pcm_format_width(runtime->format),\n\t\t\truntime->channels);\n\n\t\tspin_lock(codec->lock);\n\t\t \n\t\tflags1 = snd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS);\n\n\t\t \n\t\tflags1 &= ~DMA_RESUME;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n\n\t\t \n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_IRQTYPE, 0xffff);\n\t\tspin_unlock(codec->lock);\n\n\t\tsnd_azf3328_codec_setdmaa(chip, codec, runtime->dma_addr,\n\t\t\tsnd_pcm_lib_period_bytes(substream),\n\t\t\tsnd_pcm_lib_buffer_bytes(substream)\n\t\t);\n\n\t\tspin_lock(codec->lock);\n#ifdef WIN9X\n\t\t \n\t\tflags1 |= DMA_RUN_SOMETHING1 | DMA_RUN_SOMETHING2;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n\n\t\t \n\t\t \n\t\tflags1 |= DMA_RESUME | DMA_EPILOGUE_SOMETHING;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n#else  \n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\t0x0000);\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\tDMA_RUN_SOMETHING1);\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\tDMA_RUN_SOMETHING1 |\n\t\t\tDMA_RUN_SOMETHING2);\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\tDMA_RESUME |\n\t\t\tSOMETHING_ALMOST_ALWAYS_SET |\n\t\t\tDMA_EPILOGUE_SOMETHING |\n\t\t\tDMA_SOMETHING_ELSE);\n#endif\n\t\tspin_unlock(codec->lock);\n\t\tsnd_azf3328_ctrl_codec_activity(chip, codec->type, 1);\n\n\t\tif (is_main_mixer_playback_codec) {\n\t\t\t \n\t\t\tif (!previously_muted)\n\t\t\t\tsnd_azf3328_mixer_mute_control_pcm(\n\t\t\t\t\t\tchip, 0\n\t\t\t\t);\n\t\t}\n\n\t\tdev_dbg(chip->card->dev, \"PCM STARTED %s\\n\", codec->name);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tdev_dbg(chip->card->dev, \"PCM RESUME %s\\n\", codec->name);\n\t\t \n\t\tspin_lock(codec->lock);\n\t\tif (codec->running)\n\t\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\t\tsnd_azf3328_codec_inw(\n\t\t\t\t\tcodec, IDX_IO_CODEC_DMA_FLAGS\n\t\t\t\t) | DMA_RESUME\n\t\t\t);\n\t\tspin_unlock(codec->lock);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(chip->card->dev, \"PCM STOP %s\\n\", codec->name);\n\n\t\tif (is_main_mixer_playback_codec) {\n\t\t\t \n\t\t\tpreviously_muted =\n\t\t\t\tsnd_azf3328_mixer_mute_control_pcm(\n\t\t\t\t\t\tchip, 1\n\t\t\t\t);\n\t\t}\n\n\t\tspin_lock(codec->lock);\n\t\t \n\t\tflags1 = snd_azf3328_codec_inw(codec, IDX_IO_CODEC_DMA_FLAGS);\n\n\t\t \n\t\tflags1 &= ~DMA_RESUME;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n\n\t\t \n\t\tflags1 |= DMA_RUN_SOMETHING1;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n\n\t\tflags1 &= ~DMA_RUN_SOMETHING1;\n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS, flags1);\n\t\tspin_unlock(codec->lock);\n\t\tsnd_azf3328_ctrl_codec_activity(chip, codec->type, 0);\n\n\t\tif (is_main_mixer_playback_codec) {\n\t\t\t \n\t\t\tif (!previously_muted)\n\t\t\t\tsnd_azf3328_mixer_mute_control_pcm(\n\t\t\t\t\t\tchip, 0\n\t\t\t\t);\n\t\t}\n\n\t\tdev_dbg(chip->card->dev, \"PCM STOPPED %s\\n\", codec->name);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdev_dbg(chip->card->dev, \"PCM SUSPEND %s\\n\", codec->name);\n\t\t \n\t\tsnd_azf3328_codec_outw(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\tsnd_azf3328_codec_inw(\n\t\t\t\tcodec, IDX_IO_CODEC_DMA_FLAGS\n\t\t\t) & ~DMA_RESUME\n\t\t);\n\t\tbreak;\n        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tWARN(1, \"FIXME: SNDRV_PCM_TRIGGER_PAUSE_PUSH NIY!\\n\");\n                break;\n        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tWARN(1, \"FIXME: SNDRV_PCM_TRIGGER_PAUSE_RELEASE NIY!\\n\");\n                break;\n        default:\n\t\tWARN(1, \"FIXME: unknown trigger mode!\\n\");\n                return -EINVAL;\n\t}\n\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t\nsnd_azf3328_pcm_pointer(struct snd_pcm_substream *substream\n)\n{\n\tconst struct snd_azf3328_codec_data *codec =\n\t\tsubstream->runtime->private_data;\n\tunsigned long result;\n\tsnd_pcm_uframes_t frmres;\n\n\tresult = snd_azf3328_codec_inl(codec, IDX_IO_CODEC_DMA_CURRPOS);\n\n\t \n#ifdef QUERY_HARDWARE\n\tresult -= snd_azf3328_codec_inl(codec, IDX_IO_CODEC_DMA_START_1);\n#else\n\tresult -= codec->dma_base;\n#endif\n\tfrmres = bytes_to_frames( substream->runtime, result);\n\tdev_dbg(substream->pcm->card->dev, \"%08li %s @ 0x%8lx, frames %8ld\\n\",\n\t\tjiffies, codec->name, result, frmres);\n\treturn frmres;\n}\n\n \n\n#ifdef SUPPORT_GAMEPORT\nstatic inline void\nsnd_azf3328_gameport_irq_enable(struct snd_azf3328 *chip,\n\t\t\t\tbool enable\n)\n{\n\tsnd_azf3328_io_reg_setb(\n\t\tchip->game_io+IDX_GAME_HWCONFIG,\n\t\tGAME_HWCFG_IRQ_ENABLE,\n\t\tenable\n\t);\n}\n\nstatic inline void\nsnd_azf3328_gameport_legacy_address_enable(struct snd_azf3328 *chip,\n\t\t\t\t\t   bool enable\n)\n{\n\tsnd_azf3328_io_reg_setb(\n\t\tchip->game_io+IDX_GAME_HWCONFIG,\n\t\tGAME_HWCFG_LEGACY_ADDRESS_ENABLE,\n\t\tenable\n\t);\n}\n\nstatic void\nsnd_azf3328_gameport_set_counter_frequency(struct snd_azf3328 *chip,\n\t\t\t\t\t   unsigned int freq_cfg\n)\n{\n\tsnd_azf3328_io_reg_setb(\n\t\tchip->game_io+IDX_GAME_HWCONFIG,\n\t\t0x02,\n\t\t(freq_cfg & 1) != 0\n\t);\n\tsnd_azf3328_io_reg_setb(\n\t\tchip->game_io+IDX_GAME_HWCONFIG,\n\t\t0x04,\n\t\t(freq_cfg & 2) != 0\n\t);\n}\n\nstatic inline void\nsnd_azf3328_gameport_axis_circuit_enable(struct snd_azf3328 *chip, bool enable)\n{\n\tsnd_azf3328_ctrl_reg_6AH_update(\n\t\tchip, IO_6A_SOMETHING2_GAMEPORT, enable\n\t);\n}\n\nstatic inline void\nsnd_azf3328_gameport_interrupt(struct snd_azf3328 *chip)\n{\n\t \n\tdev_dbg(chip->card->dev, \"gameport irq\\n\");\n\n\t  \n\tsnd_azf3328_game_inw(chip, IDX_GAME_AXIS_VALUE);\n}\n\nstatic int\nsnd_azf3328_gameport_open(struct gameport *gameport, int mode)\n{\n\tstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\n\tint res;\n\n\tdev_dbg(chip->card->dev, \"gameport_open, mode %d\\n\", mode);\n\tswitch (mode) {\n\tcase GAMEPORT_MODE_COOKED:\n\tcase GAMEPORT_MODE_RAW:\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tres = -1;\n\t\tbreak;\n\t}\n\n\tsnd_azf3328_gameport_set_counter_frequency(chip,\n\t\t\t\tGAME_HWCFG_ADC_COUNTER_FREQ_STD);\n\tsnd_azf3328_gameport_axis_circuit_enable(chip, (res == 0));\n\n\treturn res;\n}\n\nstatic void\nsnd_azf3328_gameport_close(struct gameport *gameport)\n{\n\tstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\n\n\tdev_dbg(chip->card->dev, \"gameport_close\\n\");\n\tsnd_azf3328_gameport_set_counter_frequency(chip,\n\t\t\t\tGAME_HWCFG_ADC_COUNTER_FREQ_1_200);\n\tsnd_azf3328_gameport_axis_circuit_enable(chip, 0);\n}\n\nstatic int\nsnd_azf3328_gameport_cooked_read(struct gameport *gameport,\n\t\t\t\t int *axes,\n\t\t\t\t int *buttons\n)\n{\n\tstruct snd_azf3328 *chip = gameport_get_port_data(gameport);\n\tint i;\n\tu8 val;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tval = snd_azf3328_game_inb(chip, IDX_GAME_LEGACY_COMPATIBLE);\n\t*buttons = (~(val) >> 4) & 0xf;\n\n\t \n\n\tval = snd_azf3328_game_inb(chip, IDX_GAME_AXES_CONFIG);\n\tif (val & GAME_AXES_SAMPLING_READY) {\n\t\tfor (i = 0; i < ARRAY_SIZE(chip->axes); ++i) {\n\t\t\t \n\t\t\tval = (i << 4) | 0x0f;\n\t\t\tsnd_azf3328_game_outb(chip, IDX_GAME_AXES_CONFIG, val);\n\n\t\t\tchip->axes[i] = snd_azf3328_game_inw(\n\t\t\t\t\t\tchip, IDX_GAME_AXIS_VALUE\n\t\t\t\t\t);\n\t\t}\n\t}\n\n\t \n\n\t \n\tval = 0x03;  \n\tsnd_azf3328_game_outb(chip, IDX_GAME_AXES_CONFIG, val);\n\n\tsnd_azf3328_game_outw(chip, IDX_GAME_AXIS_VALUE, 0xffff);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tfor (i = 0; i < ARRAY_SIZE(chip->axes); i++) {\n\t\taxes[i] = chip->axes[i];\n\t\tif (axes[i] == 0xffff)\n\t\t\taxes[i] = -1;\n\t}\n\n\tdev_dbg(chip->card->dev, \"cooked_read: axes %d %d %d %d buttons %d\\n\",\n\t\taxes[0], axes[1], axes[2], axes[3], *buttons);\n\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_gameport(struct snd_azf3328 *chip, int dev)\n{\n\tstruct gameport *gp;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev, \"cannot alloc memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"AZF3328 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->io = chip->game_io;\n\tgameport_set_port_data(gp, chip);\n\n\tgp->open = snd_azf3328_gameport_open;\n\tgp->close = snd_azf3328_gameport_close;\n\tgp->fuzz = 16;  \n\tgp->cooked_read = snd_azf3328_gameport_cooked_read;\n\n\t \n\tsnd_azf3328_gameport_legacy_address_enable(chip, 0);\n\n\tsnd_azf3328_gameport_set_counter_frequency(chip,\n\t\t\t\tGAME_HWCFG_ADC_COUNTER_FREQ_1_200);\n\tsnd_azf3328_gameport_axis_circuit_enable(chip, 0);\n\n\tgameport_register_port(chip->gameport);\n\n\treturn 0;\n}\n\nstatic void\nsnd_azf3328_gameport_free(struct snd_azf3328 *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n\tsnd_azf3328_gameport_irq_enable(chip, 0);\n}\n#else\nstatic inline int\nsnd_azf3328_gameport(struct snd_azf3328 *chip, int dev) { return -ENOSYS; }\nstatic inline void\nsnd_azf3328_gameport_free(struct snd_azf3328 *chip) { }\nstatic inline void\nsnd_azf3328_gameport_interrupt(struct snd_azf3328 *chip)\n{\n\tdev_warn(chip->card->dev, \"huh, game port IRQ occurred!?\\n\");\n}\n#endif  \n\n \n\nstatic inline void\nsnd_azf3328_irq_log_unknown_type(struct snd_azf3328 *chip, u8 which)\n{\n\tdev_dbg(chip->card->dev,\n\t\t\"unknown IRQ type (%x) occurred, please report!\\n\",\n\t\twhich);\n}\n\nstatic inline void\nsnd_azf3328_pcm_interrupt(struct snd_azf3328 *chip,\n\t\t\t  const struct snd_azf3328_codec_data *first_codec,\n\t\t\t  u8 status\n)\n{\n\tu8 which;\n\tenum snd_azf3328_codec_type codec_type;\n\tconst struct snd_azf3328_codec_data *codec = first_codec;\n\n\tfor (codec_type = AZF_CODEC_PLAYBACK;\n\t\t codec_type <= AZF_CODEC_I2S_OUT;\n\t\t\t ++codec_type, ++codec) {\n\n\t\t \n\t\tif (!(status & (1 << codec_type)))\n\t\t\tcontinue;\n\n\t\tspin_lock(codec->lock);\n\t\twhich = snd_azf3328_codec_inb(codec, IDX_IO_CODEC_IRQTYPE);\n\t\t \n\t\tsnd_azf3328_codec_outb(codec, IDX_IO_CODEC_IRQTYPE, which);\n\t\tspin_unlock(codec->lock);\n\n\t\tif (codec->substream) {\n\t\t\tsnd_pcm_period_elapsed(codec->substream);\n\t\t\tdev_dbg(chip->card->dev, \"%s period done (#%x), @ %x\\n\",\n\t\t\t\tcodec->name,\n\t\t\t\twhich,\n\t\t\t\tsnd_azf3328_codec_inl(\n\t\t\t\t\tcodec, IDX_IO_CODEC_DMA_CURRPOS));\n\t\t} else\n\t\t\tdev_warn(chip->card->dev, \"irq handler problem!\\n\");\n\t\tif (which & IRQ_SOMETHING)\n\t\t\tsnd_azf3328_irq_log_unknown_type(chip, which);\n\t}\n}\n\nstatic irqreturn_t\nsnd_azf3328_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_azf3328 *chip = dev_id;\n\tu8 status;\n\tstatic unsigned long irq_count;\n\n\tstatus = snd_azf3328_ctrl_inb(chip, IDX_IO_IRQSTATUS);\n\n         \n\tif (!(status &\n\t\t(IRQ_PLAYBACK|IRQ_RECORDING|IRQ_I2S_OUT\n\t\t|IRQ_GAMEPORT|IRQ_MPU401|IRQ_TIMER)\n\t))\n\t\treturn IRQ_NONE;  \n\n\tdev_dbg(chip->card->dev,\n\t\t\"irq_count %ld! IDX_IO_IRQSTATUS %04x\\n\",\n\t\t\tirq_count++  ,\n\t\t\tstatus);\n\n\tif (status & IRQ_TIMER) {\n\t\t \n\t\tif (chip->timer)\n\t\t\tsnd_timer_interrupt(chip->timer, chip->timer->sticks);\n\t\t \n                spin_lock(&chip->reg_lock);\n\t\tsnd_azf3328_ctrl_outb(chip, IDX_IO_TIMER_VALUE + 3, 0x07);\n\t\tspin_unlock(&chip->reg_lock);\n\t\tdev_dbg(chip->card->dev, \"timer IRQ\\n\");\n\t}\n\n\tif (status & (IRQ_PLAYBACK|IRQ_RECORDING|IRQ_I2S_OUT))\n\t\tsnd_azf3328_pcm_interrupt(chip, chip->codecs, status);\n\n\tif (status & IRQ_GAMEPORT)\n\t\tsnd_azf3328_gameport_interrupt(chip);\n\n\t \n\tif (status & IRQ_MPU401) {\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\n\t\t \n\t\tdev_dbg(chip->card->dev, \"MPU401 IRQ\\n\");\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic const struct snd_pcm_hardware snd_azf3328_hardware =\n{\n\t \n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_U8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_5512 |\n\t\t\t\tSNDRV_PCM_RATE_8000_48000 |\n\t\t\t\tSNDRV_PCM_RATE_KNOT,\n\t.rate_min =\t\tAZF_FREQ_4000,\n\t.rate_max =\t\tAZF_FREQ_66200,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(64*1024),\n\t.period_bytes_min =\t1024,\n\t.period_bytes_max =\t(32*1024),\n\t \n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t \n\t.fifo_size =\t\t0,\n};\n\n\nstatic const unsigned int snd_azf3328_fixed_rates[] = {\n\tAZF_FREQ_4000,\n\tAZF_FREQ_4800,\n\tAZF_FREQ_5512,\n\tAZF_FREQ_6620,\n\tAZF_FREQ_8000,\n\tAZF_FREQ_9600,\n\tAZF_FREQ_11025,\n\tAZF_FREQ_13240,\n\tAZF_FREQ_16000,\n\tAZF_FREQ_22050,\n\tAZF_FREQ_32000,\n\tAZF_FREQ_44100,\n\tAZF_FREQ_48000,\n\tAZF_FREQ_66200\n};\n\nstatic const struct snd_pcm_hw_constraint_list snd_azf3328_hw_constraints_rates = {\n\t.count = ARRAY_SIZE(snd_azf3328_fixed_rates),\n\t.list = snd_azf3328_fixed_rates,\n\t.mask = 0,\n};\n\n \n\nstatic int\nsnd_azf3328_pcm_open(struct snd_pcm_substream *substream,\n\t\t     enum snd_azf3328_codec_type codec_type\n)\n{\n\tstruct snd_azf3328 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];\n\n\tcodec->substream = substream;\n\n\t \n\truntime->hw = snd_azf3328_hardware;\n\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &snd_azf3328_hw_constraints_rates);\n\truntime->private_data = codec;\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_pcm_playback_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_azf3328_pcm_open(substream, AZF_CODEC_PLAYBACK);\n}\n\nstatic int\nsnd_azf3328_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_azf3328_pcm_open(substream, AZF_CODEC_CAPTURE);\n}\n\nstatic int\nsnd_azf3328_pcm_i2s_out_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_azf3328_pcm_open(substream, AZF_CODEC_I2S_OUT);\n}\n\nstatic int\nsnd_azf3328_pcm_close(struct snd_pcm_substream *substream\n)\n{\n\tstruct snd_azf3328_codec_data *codec =\n\t\tsubstream->runtime->private_data;\n\n\tcodec->substream = NULL;\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_ops snd_azf3328_playback_ops = {\n\t.open =\t\tsnd_azf3328_pcm_playback_open,\n\t.close =\tsnd_azf3328_pcm_close,\n\t.prepare =\tsnd_azf3328_pcm_prepare,\n\t.trigger =\tsnd_azf3328_pcm_trigger,\n\t.pointer =\tsnd_azf3328_pcm_pointer\n};\n\nstatic const struct snd_pcm_ops snd_azf3328_capture_ops = {\n\t.open =\t\tsnd_azf3328_pcm_capture_open,\n\t.close =\tsnd_azf3328_pcm_close,\n\t.prepare =\tsnd_azf3328_pcm_prepare,\n\t.trigger =\tsnd_azf3328_pcm_trigger,\n\t.pointer =\tsnd_azf3328_pcm_pointer\n};\n\nstatic const struct snd_pcm_ops snd_azf3328_i2s_out_ops = {\n\t.open =\t\tsnd_azf3328_pcm_i2s_out_open,\n\t.close =\tsnd_azf3328_pcm_close,\n\t.prepare =\tsnd_azf3328_pcm_prepare,\n\t.trigger =\tsnd_azf3328_pcm_trigger,\n\t.pointer =\tsnd_azf3328_pcm_pointer\n};\n\nstatic int\nsnd_azf3328_pcm(struct snd_azf3328 *chip)\n{\n\t \n\tenum { AZF_PCMDEV_STD, AZF_PCMDEV_I2S_OUT, NUM_AZF_PCMDEVS };\n\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"AZF3328 DSP\", AZF_PCMDEV_STD,\n\t\t\t\t\t\t\t\t1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t\t&snd_azf3328_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t\t&snd_azf3328_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, chip->card->shortname);\n\t \n\tchip->pcm[AZF_CODEC_PLAYBACK] = pcm;\n\tchip->pcm[AZF_CODEC_CAPTURE] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t       64*1024, 64*1024);\n\n\terr = snd_pcm_new(chip->card, \"AZF3328 I2S OUT\", AZF_PCMDEV_I2S_OUT,\n\t\t\t\t\t\t\t\t1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t\t&snd_azf3328_i2s_out_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm[AZF_CODEC_I2S_OUT] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t       64*1024, 64*1024);\n\n\treturn 0;\n}\n\n \n\n \n\nstatic int\nsnd_azf3328_timer_start(struct snd_timer *timer)\n{\n\tstruct snd_azf3328 *chip;\n\tunsigned long flags;\n\tunsigned int delay;\n\n\tchip = snd_timer_chip(timer);\n\tdelay = ((timer->sticks * seqtimer_scaling) - 1) & TIMER_VALUE_MASK;\n\tif (delay < 49) {\n\t\t \n\n\t\tdev_dbg(chip->card->dev, \"delay was too low (%d)!\\n\", delay);\n\t\tdelay = 49;  \n\t}\n\tdev_dbg(chip->card->dev, \"setting timer countdown value %d\\n\", delay);\n\tdelay |= TIMER_COUNTDOWN_ENABLE | TIMER_IRQ_ENABLE;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_azf3328_ctrl_outl(chip, IDX_IO_TIMER_VALUE, delay);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_timer_stop(struct snd_timer *timer)\n{\n\tstruct snd_azf3328 *chip;\n\tunsigned long flags;\n\n\tchip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t \n\t \n\tsnd_azf3328_ctrl_outb(chip, IDX_IO_TIMER_VALUE + 3, 0x04);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\n\nstatic int\nsnd_azf3328_timer_precise_resolution(struct snd_timer *timer,\n\t\t\t\t\t       unsigned long *num, unsigned long *den)\n{\n\t*num = 1;\n\t*den = 1024000 / seqtimer_scaling;\n\treturn 0;\n}\n\nstatic struct snd_timer_hardware snd_azf3328_timer_hw = {\n\t.flags = SNDRV_TIMER_HW_AUTO,\n\t.resolution = 977,  \n\t.ticks = 1024000,  \n\t.start = snd_azf3328_timer_start,\n\t.stop = snd_azf3328_timer_stop,\n\t.precise_resolution = snd_azf3328_timer_precise_resolution,\n};\n\nstatic int\nsnd_azf3328_timer(struct snd_azf3328 *chip, int device)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = chip->card->number;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\n\tsnd_azf3328_timer_hw.resolution *= seqtimer_scaling;\n\tsnd_azf3328_timer_hw.ticks /= seqtimer_scaling;\n\n\terr = snd_timer_new(chip->card, \"AZF3328\", &tid, &timer);\n\tif (err < 0)\n\t\tgoto out;\n\n\tstrcpy(timer->name, \"AZF3328 timer\");\n\ttimer->private_data = chip;\n\ttimer->hw = snd_azf3328_timer_hw;\n\n\tchip->timer = timer;\n\n\tsnd_azf3328_timer_stop(timer);\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\n \n\nstatic void\nsnd_azf3328_free(struct snd_card *card)\n{\n\tstruct snd_azf3328 *chip = card->private_data;\n\n\tsnd_azf3328_mixer_reset(chip);\n\n\tsnd_azf3328_timer_stop(chip->timer);\n\tsnd_azf3328_gameport_free(chip);\n}\n\n#if 0\n \nstatic void\nsnd_azf3328_test_bit(unsigned unsigned reg, int bit)\n{\n\tunsigned char val, valoff, valon;\n\n\tval = inb(reg);\n\n\toutb(val & ~(1 << bit), reg);\n\tvaloff = inb(reg);\n\n\toutb(val|(1 << bit), reg);\n\tvalon = inb(reg);\n\n\toutb(val, reg);\n\n\tprintk(KERN_DEBUG \"reg %04x bit %d: %02x %02x %02x\\n\",\n\t\t\t\treg, bit, val, valoff, valon\n\t);\n}\n#endif\n\nstatic inline void\nsnd_azf3328_debug_show_ports(const struct snd_azf3328 *chip)\n{\n\tu16 tmp;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"ctrl_io 0x%lx, game_io 0x%lx, mpu_io 0x%lx, \"\n\t\t\"opl3_io 0x%lx, mixer_io 0x%lx, irq %d\\n\",\n\t\tchip->ctrl_io, chip->game_io, chip->mpu_io,\n\t\tchip->opl3_io, chip->mixer_io, chip->irq);\n\n\tdev_dbg(chip->card->dev,\n\t\t\"game %02x %02x %02x %02x %02x %02x\\n\",\n\t\tsnd_azf3328_game_inb(chip, 0),\n\t\tsnd_azf3328_game_inb(chip, 1),\n\t\tsnd_azf3328_game_inb(chip, 2),\n\t\tsnd_azf3328_game_inb(chip, 3),\n\t\tsnd_azf3328_game_inb(chip, 4),\n\t\tsnd_azf3328_game_inb(chip, 5));\n\n\tfor (tmp = 0; tmp < 0x07; tmp += 1)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"mpu_io 0x%04x\\n\", inb(chip->mpu_io + tmp));\n\n\tfor (tmp = 0; tmp <= 0x07; tmp += 1)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"0x%02x: game200 0x%04x, game208 0x%04x\\n\",\n\t\t\ttmp, inb(0x200 + tmp), inb(0x208 + tmp));\n\n\tfor (tmp = 0; tmp <= 0x01; tmp += 1)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"0x%02x: mpu300 0x%04x, mpu310 0x%04x, mpu320 0x%04x, \"\n\t\t\t\"mpu330 0x%04x opl388 0x%04x opl38c 0x%04x\\n\",\n\t\t\t\ttmp,\n\t\t\t\tinb(0x300 + tmp),\n\t\t\t\tinb(0x310 + tmp),\n\t\t\t\tinb(0x320 + tmp),\n\t\t\t\tinb(0x330 + tmp),\n\t\t\t\tinb(0x388 + tmp),\n\t\t\t\tinb(0x38c + tmp));\n\n\tfor (tmp = 0; tmp < AZF_IO_SIZE_CTRL; tmp += 2)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"ctrl 0x%02x: 0x%04x\\n\",\n\t\t\ttmp, snd_azf3328_ctrl_inw(chip, tmp));\n\n\tfor (tmp = 0; tmp < AZF_IO_SIZE_MIXER; tmp += 2)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"mixer 0x%02x: 0x%04x\\n\",\n\t\t\ttmp, snd_azf3328_mixer_inw(chip, tmp));\n}\n\nstatic int\nsnd_azf3328_create(struct snd_card *card,\n\t\t   struct pci_dev *pci,\n\t\t   unsigned long device_type)\n{\n\tstruct snd_azf3328 *chip = card->private_data;\n\tint err;\n\tu8 dma_init;\n\tenum snd_azf3328_codec_type codec_type;\n\tstruct snd_azf3328_codec_data *codec_setup;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(24))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 24bit PCI busmaster DMA\\n\"\n\t\t);\n\t\treturn -ENXIO;\n\t}\n\n\terr = pci_request_regions(pci, \"Aztech AZF3328\");\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->ctrl_io  = pci_resource_start(pci, 0);\n\tchip->game_io  = pci_resource_start(pci, 1);\n\tchip->mpu_io   = pci_resource_start(pci, 2);\n\tchip->opl3_io  = pci_resource_start(pci, 3);\n\tchip->mixer_io = pci_resource_start(pci, 4);\n\n\tcodec_setup = &chip->codecs[AZF_CODEC_PLAYBACK];\n\tcodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_PLAYBACK;\n\tcodec_setup->lock = &chip->reg_lock;\n\tcodec_setup->type = AZF_CODEC_PLAYBACK;\n\tcodec_setup->name = \"PLAYBACK\";\n\n\tcodec_setup = &chip->codecs[AZF_CODEC_CAPTURE];\n\tcodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_CAPTURE;\n\tcodec_setup->lock = &chip->reg_lock;\n\tcodec_setup->type = AZF_CODEC_CAPTURE;\n\tcodec_setup->name = \"CAPTURE\";\n\n\tcodec_setup = &chip->codecs[AZF_CODEC_I2S_OUT];\n\tcodec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_I2S_OUT;\n\tcodec_setup->lock = &chip->reg_lock;\n\tcodec_setup->type = AZF_CODEC_I2S_OUT;\n\tcodec_setup->name = \"I2S_OUT\";\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_azf3328_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_azf3328_free;\n\tpci_set_master(pci);\n\n\tsnd_azf3328_debug_show_ports(chip);\n\n\t \n\terr = snd_azf3328_mixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\t\t \n\tdma_init = DMA_RUN_SOMETHING2|DMA_EPILOGUE_SOMETHING|DMA_SOMETHING_ELSE;\n\n\tfor (codec_type = AZF_CODEC_PLAYBACK;\n\t\tcodec_type <= AZF_CODEC_I2S_OUT; ++codec_type) {\n\t\tstruct snd_azf3328_codec_data *codec =\n\t\t\t &chip->codecs[codec_type];\n\n\t\t \n\t\t\t \n\t\tcodec->running = true;\n\t\tsnd_azf3328_ctrl_codec_activity(chip, codec_type, 0);\n\n\t\tspin_lock_irq(codec->lock);\n\t\tsnd_azf3328_codec_outb(codec, IDX_IO_CODEC_DMA_FLAGS,\n\t\t\t\t\t\t dma_init);\n\t\tspin_unlock_irq(codec->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__snd_azf3328_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_azf3328 *chip;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tstrcpy(card->driver, \"AZF3328\");\n\tstrcpy(card->shortname, \"Aztech AZF3328 (PCI168)\");\n\n\terr = snd_azf3328_create(card, pci, pci_id->driver_data);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_mpu401_uart_new(\n\t\tcard, 0,\n\t\tMPU401_HW_AZT2320, chip->mpu_io,\n\t\tMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\n\t\t-1, &chip->rmidi\n\t);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"no MPU-401 device at 0x%lx?\\n\",\n\t\t\t\tchip->mpu_io\n\t\t);\n\t\treturn err;\n\t}\n\n\terr = snd_azf3328_timer(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_azf3328_pcm(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_opl3_create(card, chip->opl3_io, chip->opl3_io+2,\n\t\t\t    OPL3_HW_AUTO, 1, &opl3) < 0) {\n\t\tdev_err(card->dev, \"no OPL3 device at 0x%lx-0x%lx?\\n\",\n\t\t\t   chip->opl3_io, chip->opl3_io+2\n\t\t);\n\t} else {\n\t\t \n\t\terr = snd_opl3_timer_new(opl3, 1, 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\topl3->private_data = chip;\n\t}\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, chip->ctrl_io, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef MODULE\n\tdev_info(card->dev,\n\t\t \"Sound driver for Aztech AZF3328-based soundcards such as PCI168.\\n\");\n\tdev_info(card->dev,\n\t\t \"Hardware was completely undocumented, unfortunately.\\n\");\n\tdev_info(card->dev,\n\t\t \"Feel free to contact andi AT lisas.de for bug reports etc.!\\n\");\n\tdev_info(card->dev,\n\t\t \"User-scalable sequencer timer set to %dHz (1024000Hz / %d).\\n\",\n\t\t 1024000 / seqtimer_scaling, seqtimer_scaling);\n#endif\n\n\tsnd_azf3328_gameport(chip, dev);\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_azf3328_probe(pci, pci_id));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic inline void\nsnd_azf3328_suspend_regs(const struct snd_azf3328 *chip,\n\t\t\t unsigned long io_addr, unsigned count, u32 *saved_regs)\n{\n\tunsigned reg;\n\n\tfor (reg = 0; reg < count; ++reg) {\n\t\t*saved_regs = inl(io_addr);\n\t\tdev_dbg(chip->card->dev, \"suspend: io 0x%04lx: 0x%08x\\n\",\n\t\t\tio_addr, *saved_regs);\n\t\t++saved_regs;\n\t\tio_addr += sizeof(*saved_regs);\n\t}\n}\n\nstatic inline void\nsnd_azf3328_resume_regs(const struct snd_azf3328 *chip,\n\t\t\tconst u32 *saved_regs,\n\t\t\tunsigned long io_addr,\n\t\t\tunsigned count\n)\n{\n\tunsigned reg;\n\n\tfor (reg = 0; reg < count; ++reg) {\n\t\toutl(*saved_regs, io_addr);\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"resume: io 0x%04lx: 0x%08x --> 0x%08x\\n\",\n\t\t\tio_addr, *saved_regs, inl(io_addr));\n\t\t++saved_regs;\n\t\tio_addr += sizeof(*saved_regs);\n\t}\n}\n\nstatic inline void\nsnd_azf3328_suspend_ac97(struct snd_azf3328 *chip)\n{\n#ifdef AZF_USE_AC97_LAYER\n\tsnd_ac97_suspend(chip->ac97);\n#else\n\tsnd_azf3328_suspend_regs(chip, chip->mixer_io,\n\t\tARRAY_SIZE(chip->saved_regs_mixer), chip->saved_regs_mixer);\n\n\t \n\tsnd_azf3328_mixer_mute_control_master(chip, 1);\n\tsnd_azf3328_mixer_mute_control_pcm(chip, 1);\n#endif  \n}\n\nstatic inline void\nsnd_azf3328_resume_ac97(const struct snd_azf3328 *chip)\n{\n#ifdef AZF_USE_AC97_LAYER\n\tsnd_ac97_resume(chip->ac97);\n#else\n\tsnd_azf3328_resume_regs(chip, chip->saved_regs_mixer, chip->mixer_io,\n\t\t\t\t\tARRAY_SIZE(chip->saved_regs_mixer));\n\n\t \n\toutw(((u16 *)chip->saved_regs_mixer)[1], chip->mixer_io + 2);\n#endif  \n}\n\nstatic int\nsnd_azf3328_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_azf3328 *chip = card->private_data;\n\tu16 *saved_regs_ctrl_u16;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tsnd_azf3328_suspend_ac97(chip);\n\n\tsnd_azf3328_suspend_regs(chip, chip->ctrl_io,\n\t\tARRAY_SIZE(chip->saved_regs_ctrl), chip->saved_regs_ctrl);\n\n\t \n\tsaved_regs_ctrl_u16 = (u16 *)chip->saved_regs_ctrl;\n\tsaved_regs_ctrl_u16[IDX_IO_6AH / 2] = chip->shadow_reg_ctrl_6AH;\n\n\tsnd_azf3328_suspend_regs(chip, chip->game_io,\n\t\tARRAY_SIZE(chip->saved_regs_game), chip->saved_regs_game);\n\tsnd_azf3328_suspend_regs(chip, chip->mpu_io,\n\t\tARRAY_SIZE(chip->saved_regs_mpu), chip->saved_regs_mpu);\n\tsnd_azf3328_suspend_regs(chip, chip->opl3_io,\n\t\tARRAY_SIZE(chip->saved_regs_opl3), chip->saved_regs_opl3);\n\treturn 0;\n}\n\nstatic int\nsnd_azf3328_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tconst struct snd_azf3328 *chip = card->private_data;\n\n\tsnd_azf3328_resume_regs(chip, chip->saved_regs_game, chip->game_io,\n\t\t\t\t\tARRAY_SIZE(chip->saved_regs_game));\n\tsnd_azf3328_resume_regs(chip, chip->saved_regs_mpu, chip->mpu_io,\n\t\t\t\t\tARRAY_SIZE(chip->saved_regs_mpu));\n\tsnd_azf3328_resume_regs(chip, chip->saved_regs_opl3, chip->opl3_io,\n\t\t\t\t\tARRAY_SIZE(chip->saved_regs_opl3));\n\n\tsnd_azf3328_resume_ac97(chip);\n\n\tsnd_azf3328_resume_regs(chip, chip->saved_regs_ctrl, chip->ctrl_io,\n\t\t\t\t\tARRAY_SIZE(chip->saved_regs_ctrl));\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_azf3328_pm, snd_azf3328_suspend, snd_azf3328_resume);\n#define SND_AZF3328_PM_OPS\t&snd_azf3328_pm\n#else\n#define SND_AZF3328_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver azf3328_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_azf3328_ids,\n\t.probe = snd_azf3328_probe,\n\t.driver = {\n\t\t.pm = SND_AZF3328_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(azf3328_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}