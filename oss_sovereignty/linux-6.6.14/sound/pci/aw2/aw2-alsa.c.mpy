{
  "module_name": "aw2-alsa.c",
  "hash_id": "456e84a6fdf7092573e9e0e083ea78cd5beb285fefb0069c308de1e5a7a59ad2",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/aw2/aw2-alsa.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n\n#include \"saa7146.h\"\n#include \"aw2-saa7146.h\"\n\nMODULE_AUTHOR(\"Cedric Bregardis <cedric.bregardis@free.fr>, \"\n\t      \"Jean-Christian Hassler <jhassler@free.fr>\");\nMODULE_DESCRIPTION(\"Emagic Audiowerk 2 sound driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define CTL_ROUTE_ANALOG 0\n#define CTL_ROUTE_DIGITAL 1\n\n \n   \nstatic const struct snd_pcm_hardware snd_aw2_playback_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_44100,\n\t.rate_min = 44100,\n\t.rate_max = 44100,\n\t.channels_min = 2,\n\t.channels_max = 4,\n\t.buffer_bytes_max = 32768,\n\t.period_bytes_min = 4096,\n\t.period_bytes_max = 32768,\n\t.periods_min = 1,\n\t.periods_max = 1024,\n};\n\nstatic const struct snd_pcm_hardware snd_aw2_capture_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_44100,\n\t.rate_min = 44100,\n\t.rate_max = 44100,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 32768,\n\t.period_bytes_min = 4096,\n\t.period_bytes_max = 32768,\n\t.periods_min = 1,\n\t.periods_max = 1024,\n};\n\nstruct aw2_pcm_device {\n\tstruct snd_pcm *pcm;\n\tunsigned int stream_number;\n\tstruct aw2 *chip;\n};\n\nstruct aw2 {\n\tstruct snd_aw2_saa7146 saa7146;\n\n\tstruct pci_dev *pci;\n\tint irq;\n\tspinlock_t reg_lock;\n\tstruct mutex mtx;\n\n\tunsigned long iobase_phys;\n\tvoid __iomem *iobase_virt;\n\n\tstruct snd_card *card;\n\n\tstruct aw2_pcm_device device_playback[NB_STREAM_PLAYBACK];\n\tstruct aw2_pcm_device device_capture[NB_STREAM_CAPTURE];\n};\n\n \nstatic int snd_aw2_create(struct snd_card *card, struct pci_dev *pci);\nstatic int snd_aw2_probe(struct pci_dev *pci,\n\t\t\t const struct pci_device_id *pci_id);\nstatic int snd_aw2_pcm_playback_open(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_playback_close(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_capture_open(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_capture_close(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_prepare_playback(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_prepare_capture(struct snd_pcm_substream *substream);\nstatic int snd_aw2_pcm_trigger_playback(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd);\nstatic int snd_aw2_pcm_trigger_capture(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd);\nstatic snd_pcm_uframes_t snd_aw2_pcm_pointer_playback(struct snd_pcm_substream\n\t\t\t\t\t\t      *substream);\nstatic snd_pcm_uframes_t snd_aw2_pcm_pointer_capture(struct snd_pcm_substream\n\t\t\t\t\t\t     *substream);\nstatic int snd_aw2_new_pcm(struct aw2 *chip);\n\nstatic int snd_aw2_control_switch_capture_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo);\nstatic int snd_aw2_control_switch_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value\n\t\t\t\t\t      *ucontrol);\nstatic int snd_aw2_control_switch_capture_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value\n\t\t\t\t\t      *ucontrol);\n\n \nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Audiowerk2 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the Audiowerk2 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Audiowerk2 soundcard.\");\n\nstatic const struct pci_device_id snd_aw2_ids[] = {\n\t{PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA7146, 0, 0,\n\t 0, 0, 0},\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_aw2_ids);\n\n \nstatic struct pci_driver aw2_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_aw2_ids,\n\t.probe = snd_aw2_probe,\n};\n\nmodule_pci_driver(aw2_driver);\n\n \nstatic const struct snd_pcm_ops snd_aw2_playback_ops = {\n\t.open = snd_aw2_pcm_playback_open,\n\t.close = snd_aw2_pcm_playback_close,\n\t.prepare = snd_aw2_pcm_prepare_playback,\n\t.trigger = snd_aw2_pcm_trigger_playback,\n\t.pointer = snd_aw2_pcm_pointer_playback,\n};\n\n \nstatic const struct snd_pcm_ops snd_aw2_capture_ops = {\n\t.open = snd_aw2_pcm_capture_open,\n\t.close = snd_aw2_pcm_capture_close,\n\t.prepare = snd_aw2_pcm_prepare_capture,\n\t.trigger = snd_aw2_pcm_trigger_capture,\n\t.pointer = snd_aw2_pcm_pointer_capture,\n};\n\nstatic const struct snd_kcontrol_new aw2_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Capture Route\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0xffff,\n\t.info = snd_aw2_control_switch_capture_info,\n\t.get = snd_aw2_control_switch_capture_get,\n\t.put = snd_aw2_control_switch_capture_put\n};\n\n \n\n \nstatic void snd_aw2_free(struct snd_card *card)\n{\n\tstruct aw2 *chip = card->private_data;\n\n\t \n\tsnd_aw2_saa7146_free(&chip->saa7146);\n}\n\n \nstatic int snd_aw2_create(struct snd_card *card,\n\t\t\t  struct pci_dev *pci)\n{\n\tstruct aw2 *chip = card->private_data;\n\tint err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_master(pci);\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(card->dev, \"Impossible to set 32bit mask DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\t \n\terr = pcim_iomap_regions(pci, 1 << 0, \"Audiowerk2\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->iobase_phys = pci_resource_start(pci, 0);\n\tchip->iobase_virt = pcim_iomap_table(pci)[0];\n\n\t \n\tsnd_aw2_saa7146_setup(&chip->saa7146, chip->iobase_virt);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_aw2_saa7146_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"Cannot grab irq %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_aw2_free;\n\n\tdev_info(card->dev,\n\t\t \"Audiowerk 2 sound card (saa7146 chipset) detected and managed\\n\");\n\treturn 0;\n}\n\n \nstatic int snd_aw2_probe(struct pci_dev *pci,\n\t\t\t const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct aw2 *chip;\n\tint err;\n\n\t \n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\t \n\terr = snd_aw2_create(card, pci);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tmutex_init(&chip->mtx);\n\t \n\tspin_lock_init(&chip->reg_lock);\n\t \n\tstrcpy(card->driver, \"aw2\");\n\tstrcpy(card->shortname, \"Audiowerk2\");\n\n\tsprintf(card->longname, \"%s with SAA7146 irq %i\",\n\t\tcard->shortname, chip->irq);\n\n\t \n\tsnd_aw2_new_pcm(chip);\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tpci_set_drvdata(pci, card);\n\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n \nstatic int snd_aw2_pcm_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tdev_dbg(substream->pcm->card->dev, \"Playback_open\\n\");\n\truntime->hw = snd_aw2_playback_hw;\n\treturn 0;\n}\n\n \nstatic int snd_aw2_pcm_playback_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n\n}\n\nstatic int snd_aw2_pcm_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tdev_dbg(substream->pcm->card->dev, \"Capture_open\\n\");\n\truntime->hw = snd_aw2_capture_hw;\n\treturn 0;\n}\n\n \nstatic int snd_aw2_pcm_capture_close(struct snd_pcm_substream *substream)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int snd_aw2_pcm_prepare_playback(struct snd_pcm_substream *substream)\n{\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long period_size, buffer_size;\n\n\tmutex_lock(&chip->mtx);\n\n\tperiod_size = snd_pcm_lib_period_bytes(substream);\n\tbuffer_size = snd_pcm_lib_buffer_bytes(substream);\n\n\tsnd_aw2_saa7146_pcm_init_playback(&chip->saa7146,\n\t\t\t\t\t  pcm_device->stream_number,\n\t\t\t\t\t  runtime->dma_addr, period_size,\n\t\t\t\t\t  buffer_size);\n\n\t \n\tsnd_aw2_saa7146_define_it_playback_callback(pcm_device->stream_number,\n\t\t\t\t\t\t    (snd_aw2_saa7146_it_cb)\n\t\t\t\t\t\t    snd_pcm_period_elapsed,\n\t\t\t\t\t\t    (void *)substream);\n\n\tmutex_unlock(&chip->mtx);\n\n\treturn 0;\n}\n\n \nstatic int snd_aw2_pcm_prepare_capture(struct snd_pcm_substream *substream)\n{\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long period_size, buffer_size;\n\n\tmutex_lock(&chip->mtx);\n\n\tperiod_size = snd_pcm_lib_period_bytes(substream);\n\tbuffer_size = snd_pcm_lib_buffer_bytes(substream);\n\n\tsnd_aw2_saa7146_pcm_init_capture(&chip->saa7146,\n\t\t\t\t\t pcm_device->stream_number,\n\t\t\t\t\t runtime->dma_addr, period_size,\n\t\t\t\t\t buffer_size);\n\n\t \n\tsnd_aw2_saa7146_define_it_capture_callback(pcm_device->stream_number,\n\t\t\t\t\t\t   (snd_aw2_saa7146_it_cb)\n\t\t\t\t\t\t   snd_pcm_period_elapsed,\n\t\t\t\t\t\t   (void *)substream);\n\n\tmutex_unlock(&chip->mtx);\n\n\treturn 0;\n}\n\n \nstatic int snd_aw2_pcm_trigger_playback(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tint status = 0;\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_aw2_saa7146_pcm_trigger_start_playback(&chip->saa7146,\n\t\t\t\t\t\t\t   pcm_device->\n\t\t\t\t\t\t\t   stream_number);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_aw2_saa7146_pcm_trigger_stop_playback(&chip->saa7146,\n\t\t\t\t\t\t\t  pcm_device->\n\t\t\t\t\t\t\t  stream_number);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn status;\n}\n\n \nstatic int snd_aw2_pcm_trigger_capture(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tint status = 0;\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_aw2_saa7146_pcm_trigger_start_capture(&chip->saa7146,\n\t\t\t\t\t\t\t  pcm_device->\n\t\t\t\t\t\t\t  stream_number);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_aw2_saa7146_pcm_trigger_stop_capture(&chip->saa7146,\n\t\t\t\t\t\t\t pcm_device->\n\t\t\t\t\t\t\t stream_number);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn status;\n}\n\n \nstatic snd_pcm_uframes_t snd_aw2_pcm_pointer_playback(struct snd_pcm_substream\n\t\t\t\t\t\t      *substream)\n{\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tunsigned int current_ptr;\n\n\t \n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tcurrent_ptr =\n\t\tsnd_aw2_saa7146_get_hw_ptr_playback(&chip->saa7146,\n\t\t\t\t\t\t    pcm_device->stream_number,\n\t\t\t\t\t\t    runtime->dma_area,\n\t\t\t\t\t\t    runtime->buffer_size);\n\n\treturn bytes_to_frames(substream->runtime, current_ptr);\n}\n\n \nstatic snd_pcm_uframes_t snd_aw2_pcm_pointer_capture(struct snd_pcm_substream\n\t\t\t\t\t\t     *substream)\n{\n\tstruct aw2_pcm_device *pcm_device = snd_pcm_substream_chip(substream);\n\tstruct aw2 *chip = pcm_device->chip;\n\tunsigned int current_ptr;\n\n\t \n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tcurrent_ptr =\n\t\tsnd_aw2_saa7146_get_hw_ptr_capture(&chip->saa7146,\n\t\t\t\t\t\t   pcm_device->stream_number,\n\t\t\t\t\t\t   runtime->dma_area,\n\t\t\t\t\t\t   runtime->buffer_size);\n\n\treturn bytes_to_frames(substream->runtime, current_ptr);\n}\n\n \nstatic int snd_aw2_new_pcm(struct aw2 *chip)\n{\n\tstruct snd_pcm *pcm_playback_ana;\n\tstruct snd_pcm *pcm_playback_num;\n\tstruct snd_pcm *pcm_capture;\n\tstruct aw2_pcm_device *pcm_device;\n\tint err = 0;\n\n\t \n\n\terr = snd_pcm_new(chip->card, \"Audiowerk2 analog playback\", 0, 1, 0,\n\t\t\t  &pcm_playback_ana);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"snd_pcm_new error (0x%X)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tpcm_device = &chip->device_playback[NUM_STREAM_PLAYBACK_ANA];\n\n\t \n\tstrcpy(pcm_playback_ana->name, \"Analog playback\");\n\t \n\tpcm_playback_ana->private_data = pcm_device;\n\t \n\tsnd_pcm_set_ops(pcm_playback_ana, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_aw2_playback_ops);\n\t \n\tpcm_device->pcm = pcm_playback_ana;\n\t \n\tpcm_device->chip = chip;\n\t \n\tpcm_device->stream_number = NUM_STREAM_PLAYBACK_ANA;\n\n\t \n\t \n\tsnd_pcm_set_managed_buffer_all(pcm_playback_ana,\n\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64 * 1024, 64 * 1024);\n\n\terr = snd_pcm_new(chip->card, \"Audiowerk2 digital playback\", 1, 1, 0,\n\t\t\t  &pcm_playback_num);\n\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"snd_pcm_new error (0x%X)\\n\", err);\n\t\treturn err;\n\t}\n\t \n\tpcm_device = &chip->device_playback[NUM_STREAM_PLAYBACK_DIG];\n\n\t \n\tstrcpy(pcm_playback_num->name, \"Digital playback\");\n\t \n\tpcm_playback_num->private_data = pcm_device;\n\t \n\tsnd_pcm_set_ops(pcm_playback_num, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_aw2_playback_ops);\n\t \n\tpcm_device->pcm = pcm_playback_num;\n\t \n\tpcm_device->chip = chip;\n\t \n\tpcm_device->stream_number = NUM_STREAM_PLAYBACK_DIG;\n\n\t \n\t \n\tsnd_pcm_set_managed_buffer_all(pcm_playback_num,\n\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64 * 1024, 64 * 1024);\n\n\terr = snd_pcm_new(chip->card, \"Audiowerk2 capture\", 2, 0, 1,\n\t\t\t  &pcm_capture);\n\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"snd_pcm_new error (0x%X)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tpcm_device = &chip->device_capture[NUM_STREAM_CAPTURE_ANA];\n\n\t \n\tstrcpy(pcm_capture->name, \"Capture\");\n\t \n\tpcm_capture->private_data = pcm_device;\n\t \n\tsnd_pcm_set_ops(pcm_capture, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_aw2_capture_ops);\n\t \n\tpcm_device->pcm = pcm_capture;\n\t \n\tpcm_device->chip = chip;\n\t \n\tpcm_device->stream_number = NUM_STREAM_CAPTURE_ANA;\n\n\t \n\t \n\tsnd_pcm_set_managed_buffer_all(pcm_capture,\n\t\t\t\t       SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64 * 1024, 64 * 1024);\n\n\t \n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&aw2_control, chip));\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"snd_ctl_add error (0x%X)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_aw2_control_switch_capture_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\n\t\t\"Analog\", \"Digital\"\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_aw2_control_switch_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value\n\t\t\t\t\t      *ucontrol)\n{\n\tstruct aw2 *chip = snd_kcontrol_chip(kcontrol);\n\tif (snd_aw2_saa7146_is_using_digital_input(&chip->saa7146))\n\t\tucontrol->value.enumerated.item[0] = CTL_ROUTE_DIGITAL;\n\telse\n\t\tucontrol->value.enumerated.item[0] = CTL_ROUTE_ANALOG;\n\treturn 0;\n}\n\nstatic int snd_aw2_control_switch_capture_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value\n\t\t\t\t\t      *ucontrol)\n{\n\tstruct aw2 *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint is_disgital =\n\t    snd_aw2_saa7146_is_using_digital_input(&chip->saa7146);\n\n\tif (((ucontrol->value.integer.value[0] == CTL_ROUTE_DIGITAL)\n\t     && !is_disgital)\n\t    || ((ucontrol->value.integer.value[0] == CTL_ROUTE_ANALOG)\n\t\t&& is_disgital)) {\n\t\tsnd_aw2_saa7146_use_digital_input(&chip->saa7146, !is_disgital);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}