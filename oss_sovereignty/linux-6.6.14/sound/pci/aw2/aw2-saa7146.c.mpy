{
  "module_name": "aw2-saa7146.c",
  "hash_id": "a748d4934af177c84504ffc253db570be464cb91b646655f41ae4198b0e339e5",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/aw2/aw2-saa7146.c",
  "human_readable_source": "\n \n\n#define AW2_SAA7146_M\n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"saa7146.h\"\n#include \"aw2-saa7146.h\"\n\n#include \"aw2-tsl.c\"\n\n#define WRITEREG(value, addr) writel((value), chip->base_addr + (addr))\n#define READREG(addr) readl(chip->base_addr + (addr))\n\nstatic struct snd_aw2_saa7146_cb_param\n arr_substream_it_playback_cb[NB_STREAM_PLAYBACK];\nstatic struct snd_aw2_saa7146_cb_param\n arr_substream_it_capture_cb[NB_STREAM_CAPTURE];\n\nstatic int snd_aw2_saa7146_get_limit(int size);\n\n \nint snd_aw2_saa7146_free(struct snd_aw2_saa7146 *chip)\n{\n\t \n\tWRITEREG(0, IER);\n\n\t \n\tWRITEREG((MRST_N << 16), MC1);\n\n\t \n\tchip->base_addr = NULL;\n\n\treturn 0;\n}\n\nvoid snd_aw2_saa7146_setup(struct snd_aw2_saa7146 *chip,\n\t\t\t   void __iomem *pci_base_addr)\n{\n\t \n\n\tunsigned int acon2;\n\tunsigned int acon1 = 0;\n\tint i;\n\n\t \n\tchip->base_addr = pci_base_addr;\n\n\t \n\tWRITEREG(0, IER);\n\n\t \n\tWRITEREG((MRST_N << 16), MC1);\n\n\t \n#ifdef __BIG_ENDIAN\n\tacon1 |= A1_SWAP;\n\tacon1 |= A2_SWAP;\n#endif\n\t \n\n\t \n\tacon1 |= 0 * WS1_CTRL;\n\tacon1 |= 0 * WS2_CTRL;\n\n\t \n\tacon1 |= 3 * WS4_CTRL;\n\n\t \n\tacon1 |= 2 * WS3_CTRL;\n\n\t \n\tacon1 |= 3 * AUDIO_MODE;\n\tWRITEREG(acon1, ACON1);\n\n\t \n\tWRITEREG(3 * (BurstA1_in) + 3 * (ThreshA1_in) +\n\t\t 3 * (BurstA1_out) + 3 * (ThreshA1_out) +\n\t\t 3 * (BurstA2_out) + 3 * (ThreshA2_out), PCI_BT_A);\n\n\t \n\tWRITEREG((EAP << 16) | EAP, MC1);\n\n\t \n\tWRITEREG((EI2C << 16) | EI2C, MC1);\n\t \n\tWRITEREG(A1_out | A2_out | A1_in | IIC_S | IIC_E, IER);\n\n\t \n\tacon2 = A2_CLKSRC | BCLK1_OEN;\n\tWRITEREG(acon2, ACON2);\n\n\t \n\tsnd_aw2_saa7146_use_digital_input(chip, 0);\n\n\t \n\tfor (i = 0; i < 8; ++i) {\n\t\tWRITEREG(tsl1[i], TSL1 + (i * 4));\n\t\tWRITEREG(tsl2[i], TSL2 + (i * 4));\n\t}\n\n}\n\nvoid snd_aw2_saa7146_pcm_init_playback(struct snd_aw2_saa7146 *chip,\n\t\t\t\t       int stream_number,\n\t\t\t\t       unsigned long dma_addr,\n\t\t\t\t       unsigned long period_size,\n\t\t\t\t       unsigned long buffer_size)\n{\n\tunsigned long dw_page, dw_limit;\n\n\t \n\n\t \n\t \n\tdw_page = (0L << 11);\n\n\t \n\tdw_limit = snd_aw2_saa7146_get_limit(period_size);\n\tdw_page |= (dw_limit << 4);\n\n\tif (stream_number == 0) {\n\t\tWRITEREG(dw_page, PageA2_out);\n\n\t\t \n\t\t \n\t\t \n\t\tWRITEREG(dma_addr, BaseA2_out);\n\n\t\t \n\t\tWRITEREG(dma_addr + buffer_size, ProtA2_out);\n\n\t} else if (stream_number == 1) {\n\t\tWRITEREG(dw_page, PageA1_out);\n\n\t\t \n\t\t \n\t\t \n\t\tWRITEREG(dma_addr, BaseA1_out);\n\n\t\t \n\t\tWRITEREG(dma_addr + buffer_size, ProtA1_out);\n\t} else {\n\t\tpr_err(\"aw2: snd_aw2_saa7146_pcm_init_playback: \"\n\t\t       \"Substream number is not 0 or 1 -> not managed\\n\");\n\t}\n}\n\nvoid snd_aw2_saa7146_pcm_init_capture(struct snd_aw2_saa7146 *chip,\n\t\t\t\t      int stream_number, unsigned long dma_addr,\n\t\t\t\t      unsigned long period_size,\n\t\t\t\t      unsigned long buffer_size)\n{\n\tunsigned long dw_page, dw_limit;\n\n\t \n\n\t \n\t \n\tdw_page = (0L << 11);\n\n\t \n\tdw_limit = snd_aw2_saa7146_get_limit(period_size);\n\tdw_page |= (dw_limit << 4);\n\n\tif (stream_number == 0) {\n\t\tWRITEREG(dw_page, PageA1_in);\n\n\t\t \n\t\t \n\t\t \n\t\tWRITEREG(dma_addr, BaseA1_in);\n\n\t\t \n\t\tWRITEREG(dma_addr + buffer_size, ProtA1_in);\n\t} else {\n\t\tpr_err(\"aw2: snd_aw2_saa7146_pcm_init_capture: \"\n\t\t       \"Substream number is not 0 -> not managed\\n\");\n\t}\n}\n\nvoid snd_aw2_saa7146_define_it_playback_callback(unsigned int stream_number,\n\t\t\t\t\t\t snd_aw2_saa7146_it_cb\n\t\t\t\t\t\t p_it_callback,\n\t\t\t\t\t\t void *p_callback_param)\n{\n\tif (stream_number < NB_STREAM_PLAYBACK) {\n\t\tarr_substream_it_playback_cb[stream_number].p_it_callback =\n\t\t    (snd_aw2_saa7146_it_cb) p_it_callback;\n\t\tarr_substream_it_playback_cb[stream_number].p_callback_param =\n\t\t    (void *)p_callback_param;\n\t}\n}\n\nvoid snd_aw2_saa7146_define_it_capture_callback(unsigned int stream_number,\n\t\t\t\t\t\tsnd_aw2_saa7146_it_cb\n\t\t\t\t\t\tp_it_callback,\n\t\t\t\t\t\tvoid *p_callback_param)\n{\n\tif (stream_number < NB_STREAM_CAPTURE) {\n\t\tarr_substream_it_capture_cb[stream_number].p_it_callback =\n\t\t    (snd_aw2_saa7146_it_cb) p_it_callback;\n\t\tarr_substream_it_capture_cb[stream_number].p_callback_param =\n\t\t    (void *)p_callback_param;\n\t}\n}\n\nvoid snd_aw2_saa7146_pcm_trigger_start_playback(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t\tint stream_number)\n{\n\tunsigned int acon1 = 0;\n\t \n\tacon1 = READREG(ACON1);\n\tif (stream_number == 0) {\n\t\tWRITEREG((TR_E_A2_OUT << 16) | TR_E_A2_OUT, MC1);\n\n\t\t \n\t\tacon1 |= 2 * WS2_CTRL;\n\t\tWRITEREG(acon1, ACON1);\n\n\t} else if (stream_number == 1) {\n\t\tWRITEREG((TR_E_A1_OUT << 16) | TR_E_A1_OUT, MC1);\n\n\t\t \n\t\tacon1 |= 1 * WS1_CTRL;\n\t\tWRITEREG(acon1, ACON1);\n\t}\n}\n\nvoid snd_aw2_saa7146_pcm_trigger_stop_playback(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t       int stream_number)\n{\n\tunsigned int acon1 = 0;\n\tacon1 = READREG(ACON1);\n\tif (stream_number == 0) {\n\t\t \n\t\tacon1 &= ~(3 * WS2_CTRL);\n\t\tWRITEREG(acon1, ACON1);\n\n\t\tWRITEREG((TR_E_A2_OUT << 16), MC1);\n\t} else if (stream_number == 1) {\n\t\t \n\t\tacon1 &= ~(3 * WS1_CTRL);\n\t\tWRITEREG(acon1, ACON1);\n\n\t\tWRITEREG((TR_E_A1_OUT << 16), MC1);\n\t}\n}\n\nvoid snd_aw2_saa7146_pcm_trigger_start_capture(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t       int stream_number)\n{\n\t \n\tif (stream_number == 0)\n\t\tWRITEREG((TR_E_A1_IN << 16) | TR_E_A1_IN, MC1);\n}\n\nvoid snd_aw2_saa7146_pcm_trigger_stop_capture(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t      int stream_number)\n{\n\tif (stream_number == 0)\n\t\tWRITEREG((TR_E_A1_IN << 16), MC1);\n}\n\nirqreturn_t snd_aw2_saa7146_interrupt(int irq, void *dev_id)\n{\n\tunsigned int isr;\n\t__always_unused unsigned int iicsta;\n\tstruct snd_aw2_saa7146 *chip = dev_id;\n\n\tisr = READREG(ISR);\n\tif (!isr)\n\t\treturn IRQ_NONE;\n\n\tWRITEREG(isr, ISR);\n\n\tif (isr & (IIC_S | IIC_E)) {\n\t\tiicsta = READREG(IICSTA);\n\t\tWRITEREG(0x100, IICSTA);\n\t}\n\n\tif (isr & A1_out) {\n\t\tif (arr_substream_it_playback_cb[1].p_it_callback != NULL) {\n\t\t\tarr_substream_it_playback_cb[1].\n\t\t\t    p_it_callback(arr_substream_it_playback_cb[1].\n\t\t\t\t\t  p_callback_param);\n\t\t}\n\t}\n\tif (isr & A2_out) {\n\t\tif (arr_substream_it_playback_cb[0].p_it_callback != NULL) {\n\t\t\tarr_substream_it_playback_cb[0].\n\t\t\t    p_it_callback(arr_substream_it_playback_cb[0].\n\t\t\t\t\t  p_callback_param);\n\t\t}\n\n\t}\n\tif (isr & A1_in) {\n\t\tif (arr_substream_it_capture_cb[0].p_it_callback != NULL) {\n\t\t\tarr_substream_it_capture_cb[0].\n\t\t\t    p_it_callback(arr_substream_it_capture_cb[0].\n\t\t\t\t\t  p_callback_param);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nunsigned int snd_aw2_saa7146_get_hw_ptr_playback(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t\t int stream_number,\n\t\t\t\t\t\t unsigned char *start_addr,\n\t\t\t\t\t\t unsigned int buffer_size)\n{\n\tlong pci_adp = 0;\n\tsize_t ptr = 0;\n\n\tif (stream_number == 0) {\n\t\tpci_adp = READREG(PCI_ADP3);\n\t\tptr = pci_adp - (long)start_addr;\n\n\t\tif (ptr == buffer_size)\n\t\t\tptr = 0;\n\t}\n\tif (stream_number == 1) {\n\t\tpci_adp = READREG(PCI_ADP1);\n\t\tptr = pci_adp - (size_t) start_addr;\n\n\t\tif (ptr == buffer_size)\n\t\t\tptr = 0;\n\t}\n\treturn ptr;\n}\n\nunsigned int snd_aw2_saa7146_get_hw_ptr_capture(struct snd_aw2_saa7146 *chip,\n\t\t\t\t\t\tint stream_number,\n\t\t\t\t\t\tunsigned char *start_addr,\n\t\t\t\t\t\tunsigned int buffer_size)\n{\n\tsize_t pci_adp = 0;\n\tsize_t ptr = 0;\n\tif (stream_number == 0) {\n\t\tpci_adp = READREG(PCI_ADP2);\n\t\tptr = pci_adp - (size_t) start_addr;\n\n\t\tif (ptr == buffer_size)\n\t\t\tptr = 0;\n\t}\n\treturn ptr;\n}\n\nvoid snd_aw2_saa7146_use_digital_input(struct snd_aw2_saa7146 *chip,\n\t\t\t\t       int use_digital)\n{\n\t \n\tif (use_digital)\n\t\tWRITEREG(0x40, GPIO_CTRL);\n\telse\n\t\tWRITEREG(0x50, GPIO_CTRL);\n}\n\nint snd_aw2_saa7146_is_using_digital_input(struct snd_aw2_saa7146 *chip)\n{\n\tunsigned int reg_val = READREG(GPIO_CTRL);\n\tif ((reg_val & 0xFF) == 0x40)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n\nstatic int snd_aw2_saa7146_get_limit(int size)\n{\n\tint limitsize = 32;\n\tint limit = 0;\n\twhile (limitsize < size) {\n\t\tlimitsize *= 2;\n\t\tlimit++;\n\t}\n\treturn limit;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}