{
  "module_name": "lx6464es.c",
  "hash_id": "48e1765e93b4cf5cc34d2ef270d2db544c12b373f0b967fa0ba6a4ea932d1083",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lx6464es/lx6464es.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include <sound/initval.h>\n#include <sound/control.h>\n#include <sound/info.h>\n\n#include \"lx6464es.h\"\n\nMODULE_AUTHOR(\"Tim Blechmann\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"digigram lx6464es\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Digigram LX6464ES interface.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for  Digigram LX6464ES interface.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable/disable specific Digigram LX6464ES soundcards.\");\n\nstatic const char card_name[] = \"LX6464ES\";\n\n\n#define PCI_DEVICE_ID_PLX_LX6464ES\t\tPCI_DEVICE_ID_PLX_9056\n\nstatic const struct pci_device_id snd_lx6464es_ids[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,\n\t\t\t PCI_VENDOR_ID_DIGIGRAM,\n\t\t\t PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM),\n\t},\t\t\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,\n\t\t\t PCI_VENDOR_ID_DIGIGRAM,\n\t\t\t PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM),\n\t},\t\t\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,\n\t\t\t PCI_VENDOR_ID_DIGIGRAM,\n\t\t\t PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_SERIAL_SUBSYSTEM),\n\t},\t\t\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,\n\t\t\t PCI_VENDOR_ID_DIGIGRAM,\n\t\t\t PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_CAE_SERIAL_SUBSYSTEM),\n\t},\t\t\t \n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, snd_lx6464es_ids);\n\n\n\n \n#define CHIPSC_RESET_XILINX (1L<<16)\n\n\n \nstatic const struct snd_pcm_hardware lx_caps = {\n\t.info             = (SNDRV_PCM_INFO_MMAP |\n\t\t\t     SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t     SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t     SNDRV_PCM_INFO_SYNC_START),\n\t.formats\t  = (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t     SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t     SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t     SNDRV_PCM_FMTBIT_S24_3BE),\n\t.rates            = (SNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t     SNDRV_PCM_RATE_8000_192000),\n\t.rate_min         = 8000,\n\t.rate_max         = 192000,\n\t.channels_min     = 2,\n\t.channels_max     = 64,\n\t.buffer_bytes_max = 64*2*3*MICROBLAZE_IBL_MAX*MAX_STREAM_BUFFER,\n\t.period_bytes_min = (2*2*MICROBLAZE_IBL_MIN*2),\n\t.period_bytes_max = (4*64*MICROBLAZE_IBL_MAX*MAX_STREAM_BUFFER),\n\t.periods_min      = 2,\n\t.periods_max      = MAX_STREAM_BUFFER,\n};\n\nstatic int lx_set_granularity(struct lx6464es *chip, u32 gran);\n\n\nstatic int lx_hardware_open(struct lx6464es *chip,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tint err = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint channels = runtime->channels;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tsnd_pcm_uframes_t period_size = runtime->period_size;\n\n\tdev_dbg(chip->card->dev, \"allocating pipe for %d channels\\n\", channels);\n\terr = lx_pipe_allocate(chip, 0, is_capture, channels);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, LXP \"allocating pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = lx_set_granularity(chip, period_size);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"setting granularity to %ld failed\\n\",\n\t\t\t   period_size);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int lx_hardware_start(struct lx6464es *chip,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tint err = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_dbg(chip->card->dev, \"setting stream format\\n\");\n\terr = lx_stream_set_format(chip, runtime, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"setting stream format failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(chip->card->dev, \"starting pipe\\n\");\n\terr = lx_pipe_start(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"starting pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(chip->card->dev, \"waiting for pipe to start\\n\");\n\terr = lx_pipe_wait_for_start(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"waiting for pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n\nstatic int lx_hardware_stop(struct lx6464es *chip,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tint err = 0;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_dbg(chip->card->dev, \"pausing pipe\\n\");\n\terr = lx_pipe_pause(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"pausing pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(chip->card->dev, \"waiting for pipe to become idle\\n\");\n\terr = lx_pipe_wait_for_idle(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"waiting for pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(chip->card->dev, \"stopping pipe\\n\");\n\terr = lx_pipe_stop(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"stopping pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n\nstatic int lx_hardware_close(struct lx6464es *chip,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tint err = 0;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_dbg(chip->card->dev, \"releasing pipe\\n\");\n\terr = lx_pipe_release(chip, 0, is_capture);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"releasing pipe failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n\nstatic int lx_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err = 0;\n\tint board_rate;\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_open\\n\");\n\tmutex_lock(&chip->setup_mutex);\n\n\t \n\truntime->hw = lx_caps;\n\n#if 0\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0) {\n\t\tdev_warn(chip->card->dev, \"could not constrain periods\\n\");\n\t\tgoto exit;\n\t}\n#endif\n\n\t \n\tboard_rate = chip->board_sample_rate;\n\terr = snd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   board_rate);\n\n\tif (err < 0) {\n\t\tdev_warn(chip->card->dev, \"could not constrain periods\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t   MICROBLAZE_IBL_MIN,\n\t\t\t\t\t   MICROBLAZE_IBL_MAX);\n\tif (err < 0) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t   \"could not constrain period size\\n\");\n\t\tgoto exit;\n\t}\n\n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\n\n\tsnd_pcm_set_sync(substream);\n\terr = 0;\n\nexit:\n\truntime->private_data = chip;\n\n\tmutex_unlock(&chip->setup_mutex);\n\tdev_dbg(chip->card->dev, \"<-lx_pcm_open, %d\\n\", err);\n\treturn err;\n}\n\nstatic int lx_pcm_close(struct snd_pcm_substream *substream)\n{\n\tdev_dbg(substream->pcm->card->dev, \"->lx_pcm_close\\n\");\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream\n\t\t\t\t\t       *substream)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\tsnd_pcm_uframes_t pos;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tstruct lx_stream *lx_stream = is_capture ? &chip->capture_stream :\n\t\t&chip->playback_stream;\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_stream_pointer\\n\");\n\n\tmutex_lock(&chip->lock);\n\tpos = lx_stream->frame_pos * substream->runtime->period_size;\n\tmutex_unlock(&chip->lock);\n\n\tdev_dbg(chip->card->dev, \"stream_pointer at %ld\\n\", pos);\n\treturn pos;\n}\n\nstatic int lx_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\tint err = 0;\n\tconst int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_prepare\\n\");\n\n\tmutex_lock(&chip->setup_mutex);\n\n\tif (chip->hardware_running[is_capture]) {\n\t\terr = lx_hardware_stop(chip, substream);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"failed to stop hardware. \"\n\t\t\t\t   \"Error code %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = lx_hardware_close(chip, substream);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"failed to close hardware. \"\n\t\t\t\t   \"Error code %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tdev_dbg(chip->card->dev, \"opening hardware\\n\");\n\terr = lx_hardware_open(chip, substream);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"failed to open hardware. \"\n\t\t\t   \"Error code %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\terr = lx_hardware_start(chip, substream);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"failed to start hardware. \"\n\t\t\t   \"Error code %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\tchip->hardware_running[is_capture] = 1;\n\n\tif (chip->board_sample_rate != substream->runtime->rate) {\n\t\tif (!err)\n\t\t\tchip->board_sample_rate = substream->runtime->rate;\n\t}\n\nexit:\n\tmutex_unlock(&chip->setup_mutex);\n\treturn err;\n}\n\nstatic int lx_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *hw_params, int is_capture)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_hw_params\\n\");\n\n\tmutex_lock(&chip->setup_mutex);\n\n\tif (is_capture)\n\t\tchip->capture_stream.stream = substream;\n\telse\n\t\tchip->playback_stream.stream = substream;\n\n\tmutex_unlock(&chip->setup_mutex);\n\treturn 0;\n}\n\nstatic int lx_pcm_hw_params_playback(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\treturn lx_pcm_hw_params(substream, hw_params, 0);\n}\n\nstatic int lx_pcm_hw_params_capture(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\treturn lx_pcm_hw_params(substream, hw_params, 1);\n}\n\nstatic int lx_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\tint err = 0;\n\tint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_hw_free\\n\");\n\tmutex_lock(&chip->setup_mutex);\n\n\tif (chip->hardware_running[is_capture]) {\n\t\terr = lx_hardware_stop(chip, substream);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"failed to stop hardware. \"\n\t\t\t\t   \"Error code %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = lx_hardware_close(chip, substream);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"failed to close hardware. \"\n\t\t\t\t   \"Error code %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tchip->hardware_running[is_capture] = 0;\n\t}\n\n\tif (is_capture)\n\t\tchip->capture_stream.stream = NULL;\n\telse\n\t\tchip->playback_stream.stream = NULL;\n\nexit:\n\tmutex_unlock(&chip->setup_mutex);\n\treturn err;\n}\n\nstatic void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)\n{\n\tstruct snd_pcm_substream *substream = lx_stream->stream;\n\tconst unsigned int is_capture = lx_stream->is_capture;\n\n\tint err;\n\n\tconst u32 channels = substream->runtime->channels;\n\tconst u32 bytes_per_frame = channels * 3;\n\tconst u32 period_size = substream->runtime->period_size;\n\tconst u32 periods = substream->runtime->periods;\n\tconst u32 period_bytes = period_size * bytes_per_frame;\n\n\tdma_addr_t buf = substream->dma_buffer.addr;\n\tint i;\n\n\tu32 needed, freed;\n\tu32 size_array[5];\n\n\tfor (i = 0; i != periods; ++i) {\n\t\tu32 buffer_index = 0;\n\n\t\terr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed,\n\t\t\t\t    size_array);\n\t\tdev_dbg(chip->card->dev, \"starting: needed %d, freed %d\\n\",\n\t\t\t    needed, freed);\n\n\t\terr = lx_buffer_give(chip, 0, is_capture, period_bytes,\n\t\t\t\t     lower_32_bits(buf), upper_32_bits(buf),\n\t\t\t\t     &buffer_index);\n\n\t\tdev_dbg(chip->card->dev, \"starting: buffer index %x on 0x%lx (%d bytes)\\n\",\n\t\t\t    buffer_index, (unsigned long)buf, period_bytes);\n\t\tbuf += period_bytes;\n\t}\n\n\terr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);\n\tdev_dbg(chip->card->dev, \"starting: needed %d, freed %d\\n\", needed, freed);\n\n\tdev_dbg(chip->card->dev, \"starting: starting stream\\n\");\n\terr = lx_stream_start(chip, 0, is_capture);\n\tif (err < 0)\n\t\tdev_err(chip->card->dev, \"couldn't start stream\\n\");\n\telse\n\t\tlx_stream->status = LX_STREAM_STATUS_RUNNING;\n\n\tlx_stream->frame_pos = 0;\n}\n\nstatic void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)\n{\n\tconst unsigned int is_capture = lx_stream->is_capture;\n\tint err;\n\n\tdev_dbg(chip->card->dev, \"stopping: stopping stream\\n\");\n\terr = lx_stream_stop(chip, 0, is_capture);\n\tif (err < 0)\n\t\tdev_err(chip->card->dev, \"couldn't stop stream\\n\");\n\telse\n\t\tlx_stream->status = LX_STREAM_STATUS_FREE;\n\n}\n\nstatic void lx_trigger_dispatch_stream(struct lx6464es *chip,\n\t\t\t\t       struct lx_stream *lx_stream)\n{\n\tswitch (lx_stream->status) {\n\tcase LX_STREAM_STATUS_SCHEDULE_RUN:\n\t\tlx_trigger_start(chip, lx_stream);\n\t\tbreak;\n\n\tcase LX_STREAM_STATUS_SCHEDULE_STOP:\n\t\tlx_trigger_stop(chip, lx_stream);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int lx_pcm_trigger_dispatch(struct lx6464es *chip,\n\t\t\t\t   struct lx_stream *lx_stream, int cmd)\n{\n\tint err = 0;\n\n\tmutex_lock(&chip->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tlx_stream->status = LX_STREAM_STATUS_SCHEDULE_RUN;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tlx_stream->status = LX_STREAM_STATUS_SCHEDULE_STOP;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tlx_trigger_dispatch_stream(chip, &chip->capture_stream);\n\tlx_trigger_dispatch_stream(chip, &chip->playback_stream);\n\nexit:\n\tmutex_unlock(&chip->lock);\n\treturn err;\n}\n\n\nstatic int lx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct lx6464es *chip = snd_pcm_substream_chip(substream);\n\tconst int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\n\tstruct lx_stream *stream = is_capture ? &chip->capture_stream :\n\t\t&chip->playback_stream;\n\n\tdev_dbg(chip->card->dev, \"->lx_pcm_trigger\\n\");\n\n\treturn lx_pcm_trigger_dispatch(chip, stream, cmd);\n}\n\nstatic void snd_lx6464es_free(struct snd_card *card)\n{\n\tstruct lx6464es *chip = card->private_data;\n\n\tlx_irq_disable(chip);\n}\n\n \nstatic int lx_init_xilinx_reset(struct lx6464es *chip)\n{\n\tint i;\n\tu32 plx_reg = lx_plx_reg_read(chip, ePLX_CHIPSC);\n\n\tdev_dbg(chip->card->dev, \"->lx_init_xilinx_reset\\n\");\n\n\t \n\tplx_reg &= ~CHIPSC_RESET_XILINX;\n\n\tlx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);\n\tmsleep(1);\n\n\tlx_plx_reg_write(chip, ePLX_MBOX3, 0);\n\tmsleep(1);\n\n\tplx_reg |= CHIPSC_RESET_XILINX;\n\tlx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);\n\n\t \n\tfor (i = 0; i != 100; ++i) {\n\t\tu32 reg_mbox3;\n\t\tmsleep(10);\n\t\treg_mbox3 = lx_plx_reg_read(chip, ePLX_MBOX3);\n\t\tif (reg_mbox3) {\n\t\t\tdev_dbg(chip->card->dev, \"xilinx reset done\\n\");\n\t\t\tdev_dbg(chip->card->dev, \"xilinx took %d loops\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\t \n\tlx_dsp_reg_write(chip, eReg_CSM, 0);\n\n\t \n\tmsleep(600);\n\n\treturn 0;\n}\n\nstatic int lx_init_xilinx_test(struct lx6464es *chip)\n{\n\tu32 reg;\n\n\tdev_dbg(chip->card->dev, \"->lx_init_xilinx_test\\n\");\n\n\t \n\tlx_dsp_reg_write(chip, eReg_CSM, 0);\n\n\treg = lx_dsp_reg_read(chip, eReg_CSM);\n\n\tif (reg) {\n\t\tdev_err(chip->card->dev, \"Problem: Reg_CSM %x.\\n\", reg);\n\n\t\t \n\t\tlx_plx_reg_write(chip, ePLX_PCICR, 1);\n\n\t\treg = lx_dsp_reg_read(chip, eReg_CSM);\n\t\tif (reg) {\n\t\t\tdev_err(chip->card->dev, \"Error: Reg_CSM %x.\\n\", reg);\n\t\t\treturn -EAGAIN;  \n\t\t}\n\t}\n\n\tdev_dbg(chip->card->dev, \"Xilinx/MicroBlaze access test successful\\n\");\n\n\treturn 0;\n}\n\n \nstatic int lx_init_ethersound_config(struct lx6464es *chip)\n{\n\tint i;\n\tu32 orig_conf_es = lx_dsp_reg_read(chip, eReg_CONFES);\n\n\t \n\tu32 conf_es = (orig_conf_es & CONFES_READ_PART_MASK) |\n\t\t(64 << IOCR_INPUTS_OFFSET) |\n\t\t(64 << IOCR_OUTPUTS_OFFSET) |\n\t\t(FREQ_RATIO_SINGLE_MODE << FREQ_RATIO_OFFSET);\n\n\tdev_dbg(chip->card->dev, \"->lx_init_ethersound\\n\");\n\n\tchip->freq_ratio = FREQ_RATIO_SINGLE_MODE;\n\n\t \n\tlx_dsp_reg_write(chip, eReg_CONFES, conf_es);\n\n\tfor (i = 0; i != 1000; ++i) {\n\t\tif (lx_dsp_reg_read(chip, eReg_CSES) & 4) {\n\t\t\tdev_dbg(chip->card->dev, \"ethersound initialized after %dms\\n\",\n\t\t\t\t   i);\n\t\t\tgoto ethersound_initialized;\n\t\t}\n\t\tmsleep(1);\n\t}\n\tdev_warn(chip->card->dev,\n\t\t   \"ethersound could not be initialized after %dms\\n\", i);\n\treturn -ETIMEDOUT;\n\n ethersound_initialized:\n\tdev_dbg(chip->card->dev, \"ethersound initialized\\n\");\n\treturn 0;\n}\n\nstatic int lx_init_get_version_features(struct lx6464es *chip)\n{\n\tu32 dsp_version;\n\n\tint err;\n\n\tdev_dbg(chip->card->dev, \"->lx_init_get_version_features\\n\");\n\n\terr = lx_dsp_get_version(chip, &dsp_version);\n\n\tif (err == 0) {\n\t\tu32 freq;\n\n\t\tdev_info(chip->card->dev, \"DSP version: V%02d.%02d #%d\\n\",\n\t\t\t   (dsp_version>>16) & 0xff, (dsp_version>>8) & 0xff,\n\t\t\t   dsp_version & 0xff);\n\n\t\t \n\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\terr = lx_dsp_get_clock_frequency(chip, &freq);\n\t\tif (err == 0)\n\t\t\tchip->board_sample_rate = freq;\n\t\tdev_dbg(chip->card->dev, \"actual clock frequency %d\\n\", freq);\n\t} else {\n\t\tdev_err(chip->card->dev, \"DSP corrupted \\n\");\n\t\terr = -EAGAIN;\n\t}\n\n\treturn err;\n}\n\nstatic int lx_set_granularity(struct lx6464es *chip, u32 gran)\n{\n\tint err = 0;\n\tu32 snapped_gran = MICROBLAZE_IBL_MIN;\n\n\tdev_dbg(chip->card->dev, \"->lx_set_granularity\\n\");\n\n\t \n\twhile ((snapped_gran < gran) &&\n\t       (snapped_gran < MICROBLAZE_IBL_MAX)) {\n\t\tsnapped_gran *= 2;\n\t}\n\n\tif (snapped_gran == chip->pcm_granularity)\n\t\treturn 0;\n\n\terr = lx_dsp_set_granularity(chip, snapped_gran);\n\tif (err < 0) {\n\t\tdev_warn(chip->card->dev, \"could not set granularity\\n\");\n\t\terr = -EAGAIN;\n\t}\n\n\tif (snapped_gran != gran)\n\t\tdev_err(chip->card->dev, \"snapped blocksize to %d\\n\", snapped_gran);\n\n\tdev_dbg(chip->card->dev, \"set blocksize on board %d\\n\", snapped_gran);\n\tchip->pcm_granularity = snapped_gran;\n\n\treturn err;\n}\n\n \nstatic int lx_init_dsp(struct lx6464es *chip)\n{\n\tint err;\n\tint i;\n\n\tdev_dbg(chip->card->dev, \"->lx_init_dsp\\n\");\n\n\tdev_dbg(chip->card->dev, \"initialize board\\n\");\n\terr = lx_init_xilinx_reset(chip);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->card->dev, \"testing board\\n\");\n\terr = lx_init_xilinx_test(chip);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->card->dev, \"initialize ethersound configuration\\n\");\n\terr = lx_init_ethersound_config(chip);\n\tif (err)\n\t\treturn err;\n\n\tlx_irq_enable(chip);\n\n\t \n\tfor (i = 0; i != 1000; ++i) {\n\t\terr = lx_dsp_get_mac(chip);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (chip->mac_address[0] || chip->mac_address[1] || chip->mac_address[2] ||\n\t\t    chip->mac_address[3] || chip->mac_address[4] || chip->mac_address[5])\n\t\t\tgoto mac_ready;\n\t\tmsleep(1);\n\t}\n\treturn -ETIMEDOUT;\n\nmac_ready:\n\tdev_dbg(chip->card->dev, \"mac address ready read after: %dms\\n\", i);\n\tdev_info(chip->card->dev,\n\t\t \"mac address: %02X.%02X.%02X.%02X.%02X.%02X\\n\",\n\t\t   chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],\n\t\t   chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\n\n\terr = lx_init_get_version_features(chip);\n\tif (err)\n\t\treturn err;\n\n\tlx_set_granularity(chip, MICROBLAZE_IBL_DEFAULT);\n\n\tchip->playback_mute = 0;\n\n\treturn err;\n}\n\nstatic const struct snd_pcm_ops lx_ops_playback = {\n\t.open      = lx_pcm_open,\n\t.close     = lx_pcm_close,\n\t.prepare   = lx_pcm_prepare,\n\t.hw_params = lx_pcm_hw_params_playback,\n\t.hw_free   = lx_pcm_hw_free,\n\t.trigger   = lx_pcm_trigger,\n\t.pointer   = lx_pcm_stream_pointer,\n};\n\nstatic const struct snd_pcm_ops lx_ops_capture = {\n\t.open      = lx_pcm_open,\n\t.close     = lx_pcm_close,\n\t.prepare   = lx_pcm_prepare,\n\t.hw_params = lx_pcm_hw_params_capture,\n\t.hw_free   = lx_pcm_hw_free,\n\t.trigger   = lx_pcm_trigger,\n\t.pointer   = lx_pcm_stream_pointer,\n};\n\nstatic int lx_pcm_create(struct lx6464es *chip)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\tu32 size = 64 *\t\t      \n\t\t3 *\t\t      \n\t\tMAX_STREAM_BUFFER *   \n\t\tMICROBLAZE_IBL_MAX *  \n\t\t2;\t\t      \n\n\tsize = PAGE_ALIGN(size);\n\n\t \n\terr = snd_pcm_new(chip->card, (char *)card_name, 0,\n\t\t\t  1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &lx_ops_playback);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &lx_ops_capture);\n\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, card_name);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, size, size);\n\n\tchip->pcm = pcm;\n\tchip->capture_stream.is_capture = 1;\n\n\treturn 0;\n}\n\nstatic int lx_control_playback_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int lx_control_playback_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lx6464es *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = chip->playback_mute;\n\treturn 0;\n}\n\nstatic int lx_control_playback_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lx6464es *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint current_value = chip->playback_mute;\n\n\tif (current_value != ucontrol->value.integer.value[0]) {\n\t\tlx_level_unmute(chip, 0, !current_value);\n\t\tchip->playback_mute = !current_value;\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new lx_control_playback_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Playback Switch\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info = lx_control_playback_info,\n\t.get = lx_control_playback_get,\n\t.put = lx_control_playback_put\n};\n\n\n\nstatic void lx_proc_levels_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tu32 levels[64];\n\tint err;\n\tint i, j;\n\tstruct lx6464es *chip = entry->private_data;\n\n\tsnd_iprintf(buffer, \"capture levels:\\n\");\n\terr = lx_level_peaks(chip, 1, 64, levels);\n\tif (err < 0)\n\t\treturn;\n\n\tfor (i = 0; i != 8; ++i) {\n\t\tfor (j = 0; j != 8; ++j)\n\t\t\tsnd_iprintf(buffer, \"%08x \", levels[i*8+j]);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n\tsnd_iprintf(buffer, \"\\nplayback levels:\\n\");\n\n\terr = lx_level_peaks(chip, 0, 64, levels);\n\tif (err < 0)\n\t\treturn;\n\n\tfor (i = 0; i != 8; ++i) {\n\t\tfor (j = 0; j != 8; ++j)\n\t\t\tsnd_iprintf(buffer, \"%08x \", levels[i*8+j]);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic int lx_proc_create(struct snd_card *card, struct lx6464es *chip)\n{\n\treturn snd_card_ro_proc_new(card, \"levels\", chip, lx_proc_levels_read);\n}\n\n\nstatic int snd_lx6464es_create(struct snd_card *card,\n\t\t\t       struct pci_dev *pci)\n{\n\tstruct lx6464es *chip = card->private_data;\n\tint err;\n\n\tdev_dbg(card->dev, \"->snd_lx6464es_create\\n\");\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_master(pci);\n\n\t \n\terr = dma_set_mask(&pci->dev, DMA_BIT_MASK(32));\n\tif (err < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 32bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\t \n\tmutex_init(&chip->lock);\n\tmutex_init(&chip->msg_lock);\n\tmutex_init(&chip->setup_mutex);\n\n\t \n\terr = pci_request_regions(pci, card_name);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tchip->port_plx = pci_resource_start(pci, 1);\n\tchip->port_plx_remapped = devm_ioport_map(&pci->dev, chip->port_plx,\n\t\t\t\t\t\t  pci_resource_len(pci, 1));\n\tif (!chip->port_plx_remapped)\n\t\treturn -ENOMEM;\n\n\t \n\tchip->port_dsp_bar = pcim_iomap(pci, 2, 0);\n\tif (!chip->port_dsp_bar)\n\t\treturn -ENOMEM;\n\n\terr = devm_request_threaded_irq(&pci->dev, pci->irq, lx_interrupt,\n\t\t\t\t\tlx_threaded_irq, IRQF_SHARED,\n\t\t\t\t\tKBUILD_MODNAME, chip);\n\tif (err) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn err;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_lx6464es_free;\n\n\terr = lx_init_dsp(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"error during DSP initialization\\n\");\n\t\treturn err;\n\t}\n\n\terr = lx_pcm_create(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lx_proc_create(card, chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(card, snd_ctl_new1(&lx_control_playback_switch,\n\t\t\t\t\t     chip));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int snd_lx6464es_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct lx6464es *chip;\n\tint err;\n\n\tdev_dbg(&pci->dev, \"->snd_lx6464es_probe\\n\");\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_lx6464es_create(card, pci);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"error during snd_lx6464es_create\\n\");\n\t\tgoto error;\n\t}\n\n\tstrcpy(card->driver, \"LX6464ES\");\n\tsprintf(card->id, \"LX6464ES_%02X%02X%02X\",\n\t\tchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\n\n\tsprintf(card->shortname, \"LX6464ES %02X.%02X.%02X.%02X.%02X.%02X\",\n\t\tchip->mac_address[0], chip->mac_address[1], chip->mac_address[2],\n\t\tchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\n\n\tsprintf(card->longname, \"%s at 0x%lx, 0x%p, irq %i\",\n\t\tcard->shortname, chip->port_plx,\n\t\tchip->port_dsp_bar, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdev_dbg(chip->card->dev, \"initialization successful\\n\");\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver lx6464es_driver = {\n\t.name =     KBUILD_MODNAME,\n\t.id_table = snd_lx6464es_ids,\n\t.probe =    snd_lx6464es_probe,\n};\n\nmodule_pci_driver(lx6464es_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}