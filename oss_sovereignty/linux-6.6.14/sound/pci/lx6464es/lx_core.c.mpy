{
  "module_name": "lx_core.c",
  "hash_id": "031d25dba432ccd54a7bf3f806292f77040b4b50b38e91ff25fcdf7331ed3ae1",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lx6464es/lx_core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"lx6464es.h\"\n#include \"lx_core.h\"\n\n \n\nstatic const unsigned long dsp_port_offsets[] = {\n\t0,\n\t0x400,\n\t0x401,\n\t0x402,\n\t0x403,\n\t0x404,\n\t0x405,\n\t0x406,\n\t0x407,\n\t0x408,\n\t0x409,\n\t0x40a,\n\t0x40b,\n\t0x40c,\n\n\t0x410,\n\t0x411,\n\t0x412,\n\t0x413,\n\t0x414,\n\t0x415,\n\t0x416,\n\n\t0x420,\n\t0x430,\n\t0x431,\n\t0x432,\n\t0x433,\n\t0x434,\n\t0x440\n};\n\nstatic void __iomem *lx_dsp_register(struct lx6464es *chip, int port)\n{\n\tvoid __iomem *base_address = chip->port_dsp_bar;\n\treturn base_address + dsp_port_offsets[port]*4;\n}\n\nunsigned long lx_dsp_reg_read(struct lx6464es *chip, int port)\n{\n\tvoid __iomem *address = lx_dsp_register(chip, port);\n\treturn ioread32(address);\n}\n\nstatic void lx_dsp_reg_readbuf(struct lx6464es *chip, int port, u32 *data,\n\t\t\t       u32 len)\n{\n\tu32 __iomem *address = lx_dsp_register(chip, port);\n\tint i;\n\n\t \n\tfor (i = 0; i != len; ++i)\n\t\tdata[i] = ioread32(address + i);\n}\n\n\nvoid lx_dsp_reg_write(struct lx6464es *chip, int port, unsigned data)\n{\n\tvoid __iomem *address = lx_dsp_register(chip, port);\n\tiowrite32(data, address);\n}\n\nstatic void lx_dsp_reg_writebuf(struct lx6464es *chip, int port,\n\t\t\t\tconst u32 *data, u32 len)\n{\n\tu32 __iomem *address = lx_dsp_register(chip, port);\n\tint i;\n\n\t \n\tfor (i = 0; i != len; ++i)\n\t\tiowrite32(data[i], address + i);\n}\n\n\nstatic const unsigned long plx_port_offsets[] = {\n\t0x04,\n\t0x40,\n\t0x44,\n\t0x48,\n\t0x4c,\n\t0x50,\n\t0x54,\n\t0x58,\n\t0x5c,\n\t0x64,\n\t0x68,\n\t0x6C\n};\n\nstatic void __iomem *lx_plx_register(struct lx6464es *chip, int port)\n{\n\tvoid __iomem *base_address = chip->port_plx_remapped;\n\treturn base_address + plx_port_offsets[port];\n}\n\nunsigned long lx_plx_reg_read(struct lx6464es *chip, int port)\n{\n\tvoid __iomem *address = lx_plx_register(chip, port);\n\treturn ioread32(address);\n}\n\nvoid lx_plx_reg_write(struct lx6464es *chip, int port, u32 data)\n{\n\tvoid __iomem *address = lx_plx_register(chip, port);\n\tiowrite32(data, address);\n}\n\n \n\n#ifdef CONFIG_SND_DEBUG\n#define CMD_NAME(a) a\n#else\n#define CMD_NAME(a) NULL\n#endif\n\n#define Reg_CSM_MR\t\t\t0x00000002\n#define Reg_CSM_MC\t\t\t0x00000001\n\nstruct dsp_cmd_info {\n\tu32    dcCodeOp;\t \n\tu16    dcCmdLength;\t \n\tu16    dcStatusType;\t \n\tu16    dcStatusLength;\t \n\tchar  *dcOpName;\n};\n\n \n\nstatic const struct dsp_cmd_info dsp_commands[] =\n{\n\t{ (CMD_00_INFO_DEBUG << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1\t, 0  \t\t    , CMD_NAME(\"INFO_DEBUG\") },\n\t{ (CMD_01_GET_SYS_CFG << OPCODE_OFFSET) \t\t, 1  \n\t  , 1      , 2  \t\t    , CMD_NAME(\"GET_SYS_CFG\") },\n\t{ (CMD_02_SET_GRANULARITY << OPCODE_OFFSET)\t        , 1  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"SET_GRANULARITY\") },\n\t{ (CMD_03_SET_TIMER_IRQ << OPCODE_OFFSET)\t\t, 1  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"SET_TIMER_IRQ\") },\n\t{ (CMD_04_GET_EVENT << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1      , 0       , CMD_NAME(\"GET_EVENT\") },\n\t{ (CMD_05_GET_PIPES << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1      , 2        , CMD_NAME(\"GET_PIPES\") },\n\t{ (CMD_06_ALLOCATE_PIPE << OPCODE_OFFSET)\t\t, 1  \n\t  , 0      , 0  \t\t    , CMD_NAME(\"ALLOCATE_PIPE\") },\n\t{ (CMD_07_RELEASE_PIPE << OPCODE_OFFSET)\t\t, 1  \n\t  , 0      , 0  \t\t    , CMD_NAME(\"RELEASE_PIPE\") },\n\t{ (CMD_08_ASK_BUFFERS << OPCODE_OFFSET) \t\t, 1  \n\t  , 1      , MAX_STREAM_BUFFER  , CMD_NAME(\"ASK_BUFFERS\") },\n\t{ (CMD_09_STOP_PIPE << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 0      , 0        , CMD_NAME(\"STOP_PIPE\") },\n\t{ (CMD_0A_GET_PIPE_SPL_COUNT << OPCODE_OFFSET)\t        , 1  \n\t  , 1      , 1        , CMD_NAME(\"GET_PIPE_SPL_COUNT\") },\n\t{ (CMD_0B_TOGGLE_PIPE_STATE << OPCODE_OFFSET)           , 1  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"TOGGLE_PIPE_STATE\") },\n\t{ (CMD_0C_DEF_STREAM << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"DEF_STREAM\") },\n\t{ (CMD_0D_SET_MUTE  << OPCODE_OFFSET)\t\t\t, 3  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"SET_MUTE\") },\n\t{ (CMD_0E_GET_STREAM_SPL_COUNT << OPCODE_OFFSET)        , 1 \n\t  , 1      , 2  \t\t    , CMD_NAME(\"GET_STREAM_SPL_COUNT\") },\n\t{ (CMD_0F_UPDATE_BUFFER << OPCODE_OFFSET)\t\t, 3  \n\t  , 0      , 1  \t\t    , CMD_NAME(\"UPDATE_BUFFER\") },\n\t{ (CMD_10_GET_BUFFER << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1      , 4  \t\t    , CMD_NAME(\"GET_BUFFER\") },\n\t{ (CMD_11_CANCEL_BUFFER << OPCODE_OFFSET)\t\t, 1  \n\t  , 1      , 1        , CMD_NAME(\"CANCEL_BUFFER\") },\n\t{ (CMD_12_GET_PEAK << OPCODE_OFFSET)\t\t\t, 1  \n\t  , 1      , 1  \t\t    , CMD_NAME(\"GET_PEAK\") },\n\t{ (CMD_13_SET_STREAM_STATE << OPCODE_OFFSET)\t        , 1  \n\t  , 1      , 0  \t\t    , CMD_NAME(\"SET_STREAM_STATE\") },\n};\n\nstatic void lx_message_init(struct lx_rmh *rmh, enum cmd_mb_opcodes cmd)\n{\n\tsnd_BUG_ON(cmd >= CMD_14_INVALID);\n\n\trmh->cmd[0] = dsp_commands[cmd].dcCodeOp;\n\trmh->cmd_len = dsp_commands[cmd].dcCmdLength;\n\trmh->stat_len = dsp_commands[cmd].dcStatusLength;\n\trmh->dsp_stat = dsp_commands[cmd].dcStatusType;\n\trmh->cmd_idx = cmd;\n\tmemset(&rmh->cmd[1], 0, (REG_CRM_NUMBER - 1) * sizeof(u32));\n\n#ifdef CONFIG_SND_DEBUG\n\tmemset(rmh->stat, 0, REG_CRM_NUMBER * sizeof(u32));\n#endif\n#ifdef RMH_DEBUG\n\trmh->cmd_idx = cmd;\n#endif\n}\n\n#ifdef RMH_DEBUG\n#define LXRMH \"lx6464es rmh: \"\nstatic void lx_message_dump(struct lx_rmh *rmh)\n{\n\tu8 idx = rmh->cmd_idx;\n\tint i;\n\n\tsnd_printk(LXRMH \"command %s\\n\", dsp_commands[idx].dcOpName);\n\n\tfor (i = 0; i != rmh->cmd_len; ++i)\n\t\tsnd_printk(LXRMH \"\\tcmd[%d] %08x\\n\", i, rmh->cmd[i]);\n\n\tfor (i = 0; i != rmh->stat_len; ++i)\n\t\tsnd_printk(LXRMH \"\\tstat[%d]: %08x\\n\", i, rmh->stat[i]);\n\tsnd_printk(\"\\n\");\n}\n#else\nstatic inline void lx_message_dump(struct lx_rmh *rmh)\n{}\n#endif\n\n\n\n \n#define XILINX_TIMEOUT_MS       40\n#define XILINX_POLL_NO_SLEEP    100\n#define XILINX_POLL_ITERATIONS  150\n\n\nstatic int lx_message_send_atomic(struct lx6464es *chip, struct lx_rmh *rmh)\n{\n\tu32 reg = ED_DSP_TIMED_OUT;\n\tint dwloop;\n\n\tif (lx_dsp_reg_read(chip, eReg_CSM) & (Reg_CSM_MC | Reg_CSM_MR)) {\n\t\tdev_err(chip->card->dev, \"PIOSendMessage eReg_CSM %x\\n\", reg);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tlx_dsp_reg_writebuf(chip, eReg_CRM1, rmh->cmd, rmh->cmd_len);\n\n\t \n\tlx_dsp_reg_write(chip, eReg_CSM, Reg_CSM_MC);\n\n\t \n\tfor (dwloop = 0; dwloop != XILINX_TIMEOUT_MS * 1000; ++dwloop) {\n\t\tif (lx_dsp_reg_read(chip, eReg_CSM) & Reg_CSM_MR) {\n\t\t\tif (rmh->dsp_stat == 0)\n\t\t\t\treg = lx_dsp_reg_read(chip, eReg_CRM1);\n\t\t\telse\n\t\t\t\treg = 0;\n\t\t\tgoto polling_successful;\n\t\t} else\n\t\t\tudelay(1);\n\t}\n\tdev_warn(chip->card->dev, \"TIMEOUT lx_message_send_atomic! \"\n\t\t   \"polling failed\\n\");\n\npolling_successful:\n\tif ((reg & ERROR_VALUE) == 0) {\n\t\t \n\t\tif (rmh->stat_len) {\n\t\t\tsnd_BUG_ON(rmh->stat_len >= (REG_CRM_NUMBER-1));\n\t\t\tlx_dsp_reg_readbuf(chip, eReg_CRM2, rmh->stat,\n\t\t\t\t\t   rmh->stat_len);\n\t\t}\n\t} else\n\t\tdev_err(chip->card->dev, \"rmh error: %08x\\n\", reg);\n\n\t \n\tlx_dsp_reg_write(chip, eReg_CSM, 0);\n\n\tswitch (reg) {\n\tcase ED_DSP_TIMED_OUT:\n\t\tdev_warn(chip->card->dev, \"lx_message_send: dsp timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\n\tcase ED_DSP_CRASHED:\n\t\tdev_warn(chip->card->dev, \"lx_message_send: dsp crashed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tlx_message_dump(rmh);\n\n\treturn reg;\n}\n\n\n \nint lx_dsp_get_version(struct lx6464es *chip, u32 *rdsp_version)\n{\n\tu16 ret;\n\n\tmutex_lock(&chip->msg_lock);\n\n\tlx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);\n\tret = lx_message_send_atomic(chip, &chip->rmh);\n\n\t*rdsp_version = chip->rmh.stat[1];\n\tmutex_unlock(&chip->msg_lock);\n\treturn ret;\n}\n\nint lx_dsp_get_clock_frequency(struct lx6464es *chip, u32 *rfreq)\n{\n\tu16 ret = 0;\n\tu32 freq_raw = 0;\n\tu32 freq = 0;\n\tu32 frequency = 0;\n\n\tmutex_lock(&chip->msg_lock);\n\n\tlx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);\n\tret = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (ret == 0) {\n\t\tfreq_raw = chip->rmh.stat[0] >> FREQ_FIELD_OFFSET;\n\t\tfreq = freq_raw & XES_FREQ_COUNT8_MASK;\n\n\t\tif ((freq < XES_FREQ_COUNT8_48_MAX) ||\n\t\t    (freq > XES_FREQ_COUNT8_44_MIN))\n\t\t\tfrequency = 0;  \n\t\telse if (freq >= XES_FREQ_COUNT8_44_MAX)\n\t\t\tfrequency = 44100;\n\t\telse\n\t\t\tfrequency = 48000;\n\t}\n\n\tmutex_unlock(&chip->msg_lock);\n\n\t*rfreq = frequency * chip->freq_ratio;\n\n\treturn ret;\n}\n\nint lx_dsp_get_mac(struct lx6464es *chip)\n{\n\tu32 macmsb, maclsb;\n\n\tmacmsb = lx_dsp_reg_read(chip, eReg_ADMACESMSB) & 0x00FFFFFF;\n\tmaclsb = lx_dsp_reg_read(chip, eReg_ADMACESLSB) & 0x00FFFFFF;\n\n\t \n\tchip->mac_address[5] = ((u8 *)(&maclsb))[0];\n\tchip->mac_address[4] = ((u8 *)(&maclsb))[1];\n\tchip->mac_address[3] = ((u8 *)(&maclsb))[2];\n\tchip->mac_address[2] = ((u8 *)(&macmsb))[0];\n\tchip->mac_address[1] = ((u8 *)(&macmsb))[1];\n\tchip->mac_address[0] = ((u8 *)(&macmsb))[2];\n\n\treturn 0;\n}\n\n\nint lx_dsp_set_granularity(struct lx6464es *chip, u32 gran)\n{\n\tint ret;\n\n\tmutex_lock(&chip->msg_lock);\n\n\tlx_message_init(&chip->rmh, CMD_02_SET_GRANULARITY);\n\tchip->rmh.cmd[0] |= gran;\n\n\tret = lx_message_send_atomic(chip, &chip->rmh);\n\tmutex_unlock(&chip->msg_lock);\n\treturn ret;\n}\n\nint lx_dsp_read_async_events(struct lx6464es *chip, u32 *data)\n{\n\tint ret;\n\n\tmutex_lock(&chip->msg_lock);\n\n\tlx_message_init(&chip->rmh, CMD_04_GET_EVENT);\n\tchip->rmh.stat_len = 9;\t \n\n\tret = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (!ret)\n\t\tmemcpy(data, chip->rmh.stat, chip->rmh.stat_len * sizeof(u32));\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn ret;\n}\n\n#define PIPE_INFO_TO_CMD(capture, pipe)\t\t\t\t\t\\\n\t((u32)((u32)(pipe) | ((capture) ? ID_IS_CAPTURE : 0L)) << ID_OFFSET)\n\n\n\n \nint lx_pipe_allocate(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t     int channels)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_06_ALLOCATE_PIPE);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.cmd[0] |= channels;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\tmutex_unlock(&chip->msg_lock);\n\n\tif (err != 0)\n\t\tdev_err(chip->card->dev, \"could not allocate pipe\\n\");\n\n\treturn err;\n}\n\nint lx_pipe_release(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_07_RELEASE_PIPE);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\tmutex_unlock(&chip->msg_lock);\n\n\treturn err;\n}\n\nint lx_buffer_ask(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t  u32 *r_needed, u32 *r_freed, u32 *size_array)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n#ifdef CONFIG_SND_DEBUG\n\tif (size_array)\n\t\tmemset(size_array, 0, sizeof(u32)*MAX_STREAM_BUFFER);\n#endif\n\n\t*r_needed = 0;\n\t*r_freed = 0;\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_08_ASK_BUFFERS);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (!err) {\n\t\tint i;\n\t\tfor (i = 0; i < MAX_STREAM_BUFFER; ++i) {\n\t\t\tu32 stat = chip->rmh.stat[i];\n\t\t\tif (stat & (BF_EOB << BUFF_FLAGS_OFFSET)) {\n\t\t\t\t \n\t\t\t\t*r_freed += 1;\n\t\t\t\tif (size_array)\n\t\t\t\t\tsize_array[i] = stat & MASK_DATA_SIZE;\n\t\t\t} else if ((stat & (BF_VALID << BUFF_FLAGS_OFFSET))\n\t\t\t\t   == 0)\n\t\t\t\t \n\t\t\t\t*r_needed += 1;\n\t\t}\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"CMD_08_ASK_BUFFERS: needed %d, freed %d\\n\",\n\t\t\t    *r_needed, *r_freed);\n\t\tfor (i = 0; i < MAX_STREAM_BUFFER && i < chip->rmh.stat_len;\n\t\t     ++i) {\n\t\t\tdev_dbg(chip->card->dev, \"  stat[%d]: %x, %x\\n\", i,\n\t\t\t\tchip->rmh.stat[i],\n\t\t\t\tchip->rmh.stat[i] & MASK_DATA_SIZE);\n\t\t}\n\t}\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\n\nint lx_pipe_stop(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_09_STOP_PIPE);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nstatic int lx_pipe_toggle_state(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0B_TOGGLE_PIPE_STATE);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\n\nint lx_pipe_start(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\tint err;\n\n\terr = lx_pipe_wait_for_idle(chip, pipe, is_capture);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lx_pipe_toggle_state(chip, pipe, is_capture);\n\n\treturn err;\n}\n\nint lx_pipe_pause(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\tint err = 0;\n\n\terr = lx_pipe_wait_for_start(chip, pipe, is_capture);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lx_pipe_toggle_state(chip, pipe, is_capture);\n\n\treturn err;\n}\n\n\nint lx_pipe_sample_count(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t\t u64 *rsample_count)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.stat_len = 2;\t \n\n\terr = lx_message_send_atomic(chip, &chip->rmh);  \n\n\tif (err != 0)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"could not query pipe's sample count\\n\");\n\telse {\n\t\t*rsample_count = ((u64)(chip->rmh.stat[0] & MASK_SPL_COUNT_HI)\n\t\t\t\t  << 24)      \n\t\t\t+ chip->rmh.stat[1];  \n\t}\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nint lx_pipe_state(struct lx6464es *chip, u32 pipe, int is_capture, u16 *rstate)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (err != 0)\n\t\tdev_err(chip->card->dev, \"could not query pipe's state\\n\");\n\telse\n\t\t*rstate = (chip->rmh.stat[0] >> PSTATE_OFFSET) & 0x0F;\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nstatic int lx_pipe_wait_for_state(struct lx6464es *chip, u32 pipe,\n\t\t\t\t  int is_capture, u16 state)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i != 50; ++i) {\n\t\tu16 current_state;\n\t\tint err = lx_pipe_state(chip, pipe, is_capture, &current_state);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!err && current_state == state)\n\t\t\treturn 0;\n\n\t\tmdelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nint lx_pipe_wait_for_start(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\treturn lx_pipe_wait_for_state(chip, pipe, is_capture, PSTATE_RUN);\n}\n\nint lx_pipe_wait_for_idle(struct lx6464es *chip, u32 pipe, int is_capture)\n{\n\treturn lx_pipe_wait_for_state(chip, pipe, is_capture, PSTATE_IDLE);\n}\n\n \nint lx_stream_set_state(struct lx6464es *chip, u32 pipe,\n\t\t\t       int is_capture, enum stream_state_t state)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_13_SET_STREAM_STATE);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.cmd[0] |= state;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\tmutex_unlock(&chip->msg_lock);\n\n\treturn err;\n}\n\nint lx_stream_set_format(struct lx6464es *chip, struct snd_pcm_runtime *runtime,\n\t\t\t u32 pipe, int is_capture)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\tu32 channels = runtime->channels;\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0C_DEF_STREAM);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\tif (runtime->sample_bits == 16)\n\t\t \n\t\tchip->rmh.cmd[0] |= (STREAM_FMT_16b << STREAM_FMT_OFFSET);\n\n\tif (snd_pcm_format_little_endian(runtime->format))\n\t\t \n\t\tchip->rmh.cmd[0] |= (STREAM_FMT_intel << STREAM_FMT_OFFSET);\n\n\tchip->rmh.cmd[0] |= channels-1;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\tmutex_unlock(&chip->msg_lock);\n\n\treturn err;\n}\n\nint lx_stream_state(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t    int *rstate)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\t*rstate = (chip->rmh.stat[0] & SF_START) ? START_STATE : PAUSE_STATE;\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nint lx_stream_sample_position(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t\t      u64 *r_bytepos)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\t*r_bytepos = ((u64) (chip->rmh.stat[0] & MASK_SPL_COUNT_HI)\n\t\t      << 32)\t      \n\t\t+ chip->rmh.stat[1];  \n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\n \nint lx_buffer_give(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t   u32 buffer_size, u32 buf_address_lo, u32 buf_address_hi,\n\t\t   u32 *r_buffer_index)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0F_UPDATE_BUFFER);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.cmd[0] |= BF_NOTIFY_EOB;  \n\n\t \n\n\tchip->rmh.cmd[1] = buffer_size & MASK_DATA_SIZE;\n\tchip->rmh.cmd[2] = buf_address_lo;\n\n\tif (buf_address_hi) {\n\t\tchip->rmh.cmd_len = 4;\n\t\tchip->rmh.cmd[3] = buf_address_hi;\n\t\tchip->rmh.cmd[0] |= BF_64BITS_ADR;\n\t}\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (err == 0) {\n\t\t*r_buffer_index = chip->rmh.stat[0];\n\t\tgoto done;\n\t}\n\n\tif (err == EB_RBUFFERS_TABLE_OVERFLOW)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"lx_buffer_give EB_RBUFFERS_TABLE_OVERFLOW\\n\");\n\n\tif (err == EB_INVALID_STREAM)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"lx_buffer_give EB_INVALID_STREAM\\n\");\n\n\tif (err == EB_CMD_REFUSED)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"lx_buffer_give EB_CMD_REFUSED\\n\");\n\n done:\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nint lx_buffer_free(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t   u32 *r_buffer_size)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.cmd[0] |= MASK_BUFFER_ID;  \n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tif (err == 0)\n\t\t*r_buffer_size = chip->rmh.stat[0]  & MASK_DATA_SIZE;\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nint lx_buffer_cancel(struct lx6464es *chip, u32 pipe, int is_capture,\n\t\t     u32 buffer_index)\n{\n\tint err;\n\tu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);\n\n\tchip->rmh.cmd[0] |= pipe_cmd;\n\tchip->rmh.cmd[0] |= buffer_index;\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\n\n \nint lx_level_unmute(struct lx6464es *chip, int is_capture, int unmute)\n{\n\tint err;\n\t \n\tu64 mute_mask = unmute ? 0 : 0xFFFFFFFFFFFFFFFFLLU;\n\n\tmutex_lock(&chip->msg_lock);\n\tlx_message_init(&chip->rmh, CMD_0D_SET_MUTE);\n\n\tchip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, 0);\n\n\tchip->rmh.cmd[1] = (u32)(mute_mask >> (u64)32);\t        \n\tchip->rmh.cmd[2] = (u32)(mute_mask & (u64)0xFFFFFFFF);  \n\n\tdev_dbg(chip->card->dev,\n\t\t\"mute %x %x %x\\n\", chip->rmh.cmd[0], chip->rmh.cmd[1],\n\t\t   chip->rmh.cmd[2]);\n\n\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\nstatic const u32 peak_map[] = {\n\t0x00000109,  \n\t0x0000083B,  \n\t0x000020C4,  \n\t0x00008273,  \n\t0x00020756,  \n\t0x00040C37,  \n\t0x00081385,  \n\t0x00101D3F,  \n\t0x0016C310,  \n\t0x002026F2,  \n\t0x002D6A86,  \n\t0x004026E6,  \n\t0x005A9DF6,  \n\t0x0065AC8B,  \n\t0x00721481,  \n\t0x007FFFFF,  \n};\n\nint lx_level_peaks(struct lx6464es *chip, int is_capture, int channels,\n\t\t   u32 *r_levels)\n{\n\tint err = 0;\n\tint i;\n\n\tmutex_lock(&chip->msg_lock);\n\tfor (i = 0; i < channels; i += 4) {\n\t\tu32 s0, s1, s2, s3;\n\n\t\tlx_message_init(&chip->rmh, CMD_12_GET_PEAK);\n\t\tchip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, i);\n\n\t\terr = lx_message_send_atomic(chip, &chip->rmh);\n\n\t\tif (err == 0) {\n\t\t\ts0 = peak_map[chip->rmh.stat[0] & 0x0F];\n\t\t\ts1 = peak_map[(chip->rmh.stat[0] >>  4) & 0xf];\n\t\t\ts2 = peak_map[(chip->rmh.stat[0] >>  8) & 0xf];\n\t\t\ts3 = peak_map[(chip->rmh.stat[0] >>  12) & 0xf];\n\t\t} else\n\t\t\ts0 = s1 = s2 = s3 = 0;\n\n\t\tr_levels[0] = s0;\n\t\tr_levels[1] = s1;\n\t\tr_levels[2] = s2;\n\t\tr_levels[3] = s3;\n\n\t\tr_levels += 4;\n\t}\n\n\tmutex_unlock(&chip->msg_lock);\n\treturn err;\n}\n\n \n#define PCX_IRQ_NONE 0\n#define IRQCS_ACTIVE_PCIDB\tBIT(13)\n#define IRQCS_ENABLE_PCIIRQ\tBIT(8)\n#define IRQCS_ENABLE_PCIDB\tBIT(9)\n\nstatic u32 lx_interrupt_test_ack(struct lx6464es *chip)\n{\n\tu32 irqcs = lx_plx_reg_read(chip, ePLX_IRQCS);\n\n\t \n\tif (irqcs & IRQCS_ACTIVE_PCIDB)\t{\n\t\tu32 temp;\n\t\tirqcs = PCX_IRQ_NONE;\n\n\t\twhile ((temp = lx_plx_reg_read(chip, ePLX_L2PCIDB))) {\n\t\t\t \n\t\t\tirqcs |= temp;\n\t\t\tlx_plx_reg_write(chip, ePLX_L2PCIDB, temp);\n\t\t}\n\n\t\treturn irqcs;\n\t}\n\treturn PCX_IRQ_NONE;\n}\n\nstatic int lx_interrupt_ack(struct lx6464es *chip, u32 *r_irqsrc,\n\t\t\t    int *r_async_pending, int *r_async_escmd)\n{\n\tu32 irq_async;\n\tu32 irqsrc = lx_interrupt_test_ack(chip);\n\n\tif (irqsrc == PCX_IRQ_NONE)\n\t\treturn 0;\n\n\t*r_irqsrc = irqsrc;\n\n\tirq_async = irqsrc & MASK_SYS_ASYNC_EVENTS;  \n\n\tif (irq_async & MASK_SYS_STATUS_ESA) {\n\t\tirq_async &= ~MASK_SYS_STATUS_ESA;\n\t\t*r_async_escmd = 1;\n\t}\n\n\tif (irq_async) {\n\t\t \n\t\t*r_async_pending = 1;\n\t}\n\n\treturn 1;\n}\n\nstatic int lx_interrupt_handle_async_events(struct lx6464es *chip, u32 irqsrc,\n\t\t\t\t\t    int *r_freq_changed,\n\t\t\t\t\t    u64 *r_notified_in_pipe_mask,\n\t\t\t\t\t    u64 *r_notified_out_pipe_mask)\n{\n\tint err;\n\tu32 stat[9];\t\t \n\n\t \n\n\tint eb_pending_out = (irqsrc & MASK_SYS_STATUS_EOBO) ? 1 : 0;\n\tint eb_pending_in  = (irqsrc & MASK_SYS_STATUS_EOBI) ? 1 : 0;\n\n\t*r_freq_changed = (irqsrc & MASK_SYS_STATUS_FREQ) ? 1 : 0;\n\n\terr = lx_dsp_read_async_events(chip, stat);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (eb_pending_in) {\n\t\t*r_notified_in_pipe_mask = ((u64)stat[3] << 32)\n\t\t\t+ stat[4];\n\t\tdev_dbg(chip->card->dev, \"interrupt: EOBI pending %llx\\n\",\n\t\t\t    *r_notified_in_pipe_mask);\n\t}\n\tif (eb_pending_out) {\n\t\t*r_notified_out_pipe_mask = ((u64)stat[1] << 32)\n\t\t\t+ stat[2];\n\t\tdev_dbg(chip->card->dev, \"interrupt: EOBO pending %llx\\n\",\n\t\t\t    *r_notified_out_pipe_mask);\n\t}\n\n\t \n\n\treturn err;\n}\n\nstatic int lx_interrupt_request_new_buffer(struct lx6464es *chip,\n\t\t\t\t\t   struct lx_stream *lx_stream)\n{\n\tstruct snd_pcm_substream *substream = lx_stream->stream;\n\tconst unsigned int is_capture = lx_stream->is_capture;\n\tint err;\n\n\tconst u32 channels = substream->runtime->channels;\n\tconst u32 bytes_per_frame = channels * 3;\n\tconst u32 period_size = substream->runtime->period_size;\n\tconst u32 period_bytes = period_size * bytes_per_frame;\n\tconst u32 pos = lx_stream->frame_pos;\n\tconst u32 next_pos = ((pos+1) == substream->runtime->periods) ?\n\t\t0 : pos + 1;\n\n\tdma_addr_t buf = substream->dma_buffer.addr + pos * period_bytes;\n\tu32 buf_hi = 0;\n\tu32 buf_lo = 0;\n\tu32 buffer_index = 0;\n\n\tu32 needed, freed;\n\tu32 size_array[MAX_STREAM_BUFFER];\n\n\tdev_dbg(chip->card->dev, \"->lx_interrupt_request_new_buffer\\n\");\n\n\tmutex_lock(&chip->lock);\n\n\terr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);\n\tdev_dbg(chip->card->dev,\n\t\t\"interrupt: needed %d, freed %d\\n\", needed, freed);\n\n\tunpack_pointer(buf, &buf_lo, &buf_hi);\n\terr = lx_buffer_give(chip, 0, is_capture, period_bytes, buf_lo, buf_hi,\n\t\t\t     &buffer_index);\n\tdev_dbg(chip->card->dev,\n\t\t\"interrupt: gave buffer index %x on 0x%lx (%d bytes)\\n\",\n\t\t    buffer_index, (unsigned long)buf, period_bytes);\n\n\tlx_stream->frame_pos = next_pos;\n\tmutex_unlock(&chip->lock);\n\n\treturn err;\n}\n\nirqreturn_t lx_interrupt(int irq, void *dev_id)\n{\n\tstruct lx6464es *chip = dev_id;\n\tint async_pending, async_escmd;\n\tu32 irqsrc;\n\tbool wake_thread = false;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"**************************************************\\n\");\n\n\tif (!lx_interrupt_ack(chip, &irqsrc, &async_pending, &async_escmd)) {\n\t\tdev_dbg(chip->card->dev, \"IRQ_NONE\\n\");\n\t\treturn IRQ_NONE;  \n\t}\n\n\tif (irqsrc & MASK_SYS_STATUS_CMD_DONE)\n\t\treturn IRQ_HANDLED;\n\n\tif (irqsrc & MASK_SYS_STATUS_EOBI)\n\t\tdev_dbg(chip->card->dev, \"interrupt: EOBI\\n\");\n\n\tif (irqsrc & MASK_SYS_STATUS_EOBO)\n\t\tdev_dbg(chip->card->dev, \"interrupt: EOBO\\n\");\n\n\tif (irqsrc & MASK_SYS_STATUS_URUN)\n\t\tdev_dbg(chip->card->dev, \"interrupt: URUN\\n\");\n\n\tif (irqsrc & MASK_SYS_STATUS_ORUN)\n\t\tdev_dbg(chip->card->dev, \"interrupt: ORUN\\n\");\n\n\tif (async_pending) {\n\t\twake_thread = true;\n\t\tchip->irqsrc = irqsrc;\n\t}\n\n\tif (async_escmd) {\n\t\t \n\n\t\tdev_dbg(chip->card->dev, \"interrupt requests escmd handling\\n\");\n\t}\n\n\treturn wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}\n\nirqreturn_t lx_threaded_irq(int irq, void *dev_id)\n{\n\tstruct lx6464es *chip = dev_id;\n\tu64 notified_in_pipe_mask = 0;\n\tu64 notified_out_pipe_mask = 0;\n\tint freq_changed;\n\tint err;\n\n\t \n\terr = lx_interrupt_handle_async_events(chip, chip->irqsrc,\n\t\t\t\t\t       &freq_changed,\n\t\t\t\t\t       &notified_in_pipe_mask,\n\t\t\t\t\t       &notified_out_pipe_mask);\n\tif (err)\n\t\tdev_err(chip->card->dev, \"error handling async events\\n\");\n\n\tif (notified_in_pipe_mask) {\n\t\tstruct lx_stream *lx_stream = &chip->capture_stream;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"requesting audio transfer for capture\\n\");\n\t\terr = lx_interrupt_request_new_buffer(chip, lx_stream);\n\t\tif (err < 0)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"cannot request new buffer for capture\\n\");\n\t\tsnd_pcm_period_elapsed(lx_stream->stream);\n\t}\n\n\tif (notified_out_pipe_mask) {\n\t\tstruct lx_stream *lx_stream = &chip->playback_stream;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"requesting audio transfer for playback\\n\");\n\t\terr = lx_interrupt_request_new_buffer(chip, lx_stream);\n\t\tif (err < 0)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"cannot request new buffer for playback\\n\");\n\t\tsnd_pcm_period_elapsed(lx_stream->stream);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void lx_irq_set(struct lx6464es *chip, int enable)\n{\n\tu32 reg = lx_plx_reg_read(chip, ePLX_IRQCS);\n\n\t \n\tif (enable)\n\t\treg |=  (IRQCS_ENABLE_PCIIRQ | IRQCS_ENABLE_PCIDB);\n\telse\n\t\treg &= ~(IRQCS_ENABLE_PCIIRQ | IRQCS_ENABLE_PCIDB);\n\tlx_plx_reg_write(chip, ePLX_IRQCS, reg);\n}\n\nvoid lx_irq_enable(struct lx6464es *chip)\n{\n\tdev_dbg(chip->card->dev, \"->lx_irq_enable\\n\");\n\tlx_irq_set(chip, 1);\n}\n\nvoid lx_irq_disable(struct lx6464es *chip)\n{\n\tdev_dbg(chip->card->dev, \"->lx_irq_disable\\n\");\n\tlx_irq_set(chip, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}