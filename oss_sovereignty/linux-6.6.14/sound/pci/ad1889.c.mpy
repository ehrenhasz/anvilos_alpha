{
  "module_name": "ad1889.c",
  "hash_id": "fbae1b7482848c1bda419f4e2bfe52606e15f3f9a2917704699effaa884c2dc7",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ad1889.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/ac97_codec.h>\n\n#include \"ad1889.h\"\n#include \"ac97/ac97_id.h\"\n\n#define\tAD1889_DRVVER\t\"Version: 1.7\"\n\nMODULE_AUTHOR(\"Kyle McMartin <kyle@parisc-linux.org>, Thibaut Varene <t-bone@parisc-linux.org>\");\nMODULE_DESCRIPTION(\"Analog Devices AD1889 ALSA sound driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the AD1889 soundcard.\");\n\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the AD1889 soundcard.\");\n\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable AD1889 soundcard.\");\n\nstatic char *ac97_quirk[SNDRV_CARDS];\nmodule_param_array(ac97_quirk, charp, NULL, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 workaround for strange hardware.\");\n\n#define DEVNAME \"ad1889\"\n#define PFX\tDEVNAME \": \"\n\n \nstruct ad1889_register_state {\n\tu16 reg;\t \n\tu32 addr;\t \n\tunsigned long size;\t \n};\n\nstruct snd_ad1889 {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\n\tint irq;\n\tunsigned long bar;\n\tvoid __iomem *iobase;\n\n\tstruct snd_ac97 *ac97;\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_pcm *pcm;\n\tstruct snd_info_entry *proc;\n\n\tstruct snd_pcm_substream *psubs;\n\tstruct snd_pcm_substream *csubs;\n\n\t \n\tstruct ad1889_register_state wave;\n\tstruct ad1889_register_state ramc;\n\n\tspinlock_t lock;\n};\n\nstatic inline u16\nad1889_readw(struct snd_ad1889 *chip, unsigned reg)\n{\n\treturn readw(chip->iobase + reg);\n}\n\nstatic inline void\nad1889_writew(struct snd_ad1889 *chip, unsigned reg, u16 val)\n{\n\twritew(val, chip->iobase + reg);\n}\n\nstatic inline u32\nad1889_readl(struct snd_ad1889 *chip, unsigned reg)\n{\n\treturn readl(chip->iobase + reg);\n}\n\nstatic inline void\nad1889_writel(struct snd_ad1889 *chip, unsigned reg, u32 val)\n{\n\twritel(val, chip->iobase + reg);\n}\n\nstatic inline void\nad1889_unmute(struct snd_ad1889 *chip)\n{\n\tu16 st;\n\tst = ad1889_readw(chip, AD_DS_WADA) & \n\t\t~(AD_DS_WADA_RWAM | AD_DS_WADA_LWAM);\n\tad1889_writew(chip, AD_DS_WADA, st);\n\tad1889_readw(chip, AD_DS_WADA);\n}\n\nstatic inline void\nad1889_mute(struct snd_ad1889 *chip)\n{\n\tu16 st;\n\tst = ad1889_readw(chip, AD_DS_WADA) | AD_DS_WADA_RWAM | AD_DS_WADA_LWAM;\n\tad1889_writew(chip, AD_DS_WADA, st);\n\tad1889_readw(chip, AD_DS_WADA);\n}\n\nstatic inline void\nad1889_load_adc_buffer_address(struct snd_ad1889 *chip, u32 address)\n{\n\tad1889_writel(chip, AD_DMA_ADCBA, address);\n\tad1889_writel(chip, AD_DMA_ADCCA, address);\n}\n\nstatic inline void\nad1889_load_adc_buffer_count(struct snd_ad1889 *chip, u32 count)\n{\n\tad1889_writel(chip, AD_DMA_ADCBC, count);\n\tad1889_writel(chip, AD_DMA_ADCCC, count);\n}\n\nstatic inline void\nad1889_load_adc_interrupt_count(struct snd_ad1889 *chip, u32 count)\n{\n\tad1889_writel(chip, AD_DMA_ADCIB, count);\n\tad1889_writel(chip, AD_DMA_ADCIC, count);\n}\n\nstatic inline void\nad1889_load_wave_buffer_address(struct snd_ad1889 *chip, u32 address)\n{\n\tad1889_writel(chip, AD_DMA_WAVBA, address);\n\tad1889_writel(chip, AD_DMA_WAVCA, address);\n}\n\nstatic inline void\nad1889_load_wave_buffer_count(struct snd_ad1889 *chip, u32 count)\n{\n\tad1889_writel(chip, AD_DMA_WAVBC, count);\n\tad1889_writel(chip, AD_DMA_WAVCC, count);\n}\n\nstatic inline void\nad1889_load_wave_interrupt_count(struct snd_ad1889 *chip, u32 count)\n{\n\tad1889_writel(chip, AD_DMA_WAVIB, count);\n\tad1889_writel(chip, AD_DMA_WAVIC, count);\n}\n\nstatic void\nad1889_channel_reset(struct snd_ad1889 *chip, unsigned int channel)\n{\n\tu16 reg;\n\t\n\tif (channel & AD_CHAN_WAV) {\n\t\t \n\t\treg = ad1889_readw(chip, AD_DS_WSMC) & ~AD_DS_WSMC_WAEN;\n\t\tad1889_writew(chip, AD_DS_WSMC, reg);\n\t\tchip->wave.reg = reg;\n\t\t\n\t\t \n\t\treg = ad1889_readw(chip, AD_DMA_WAV);\n\t\treg &= AD_DMA_IM_DIS;\n\t\treg &= ~AD_DMA_LOOP;\n\t\tad1889_writew(chip, AD_DMA_WAV, reg);\n\n\t\t \n\t\tad1889_load_wave_buffer_address(chip, 0x0);\n\t\tad1889_load_wave_buffer_count(chip, 0x0);\n\t\tad1889_load_wave_interrupt_count(chip, 0x0);\n\n\t\t \n\t\tad1889_readw(chip, AD_DMA_WAV);\n\t}\n\t\n\tif (channel & AD_CHAN_ADC) {\n\t\t \n\t\treg = ad1889_readw(chip, AD_DS_RAMC) & ~AD_DS_RAMC_ADEN;\n\t\tad1889_writew(chip, AD_DS_RAMC, reg);\n\t\tchip->ramc.reg = reg;\n\n\t\treg = ad1889_readw(chip, AD_DMA_ADC);\n\t\treg &= AD_DMA_IM_DIS;\n\t\treg &= ~AD_DMA_LOOP;\n\t\tad1889_writew(chip, AD_DMA_ADC, reg);\n\t\n\t\tad1889_load_adc_buffer_address(chip, 0x0);\n\t\tad1889_load_adc_buffer_count(chip, 0x0);\n\t\tad1889_load_adc_interrupt_count(chip, 0x0);\n\n\t\t \n\t\tad1889_readw(chip, AD_DMA_ADC);\n\t}\n}\n\nstatic u16\nsnd_ad1889_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct snd_ad1889 *chip = ac97->private_data;\n\treturn ad1889_readw(chip, AD_AC97_BASE + reg);\n}\n\nstatic void\nsnd_ad1889_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\n{\n\tstruct snd_ad1889 *chip = ac97->private_data;\n\tad1889_writew(chip, AD_AC97_BASE + reg, val);\n}\n\nstatic int\nsnd_ad1889_ac97_ready(struct snd_ad1889 *chip)\n{\n\tint retry = 400;  \n\t\n\twhile (!(ad1889_readw(chip, AD_AC97_ACIC) & AD_AC97_ACIC_ACRDY) \n\t\t\t&& --retry)\n\t\tusleep_range(1000, 2000);\n\tif (!retry) {\n\t\tdev_err(chip->card->dev, \"[%s] Link is not ready.\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\tdev_dbg(chip->card->dev, \"[%s] ready after %d ms\\n\", __func__, 400 - retry);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_ad1889_playback_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\t \n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = PERIOD_BYTES_MAX,\n\t.periods_min = PERIODS_MIN,\n\t.periods_max = PERIODS_MAX,\n\t \n};\n\nstatic const struct snd_pcm_hardware snd_ad1889_capture_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\t \n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = PERIOD_BYTES_MAX,\n\t.periods_min = PERIODS_MIN,\n\t.periods_max = PERIODS_MAX,\n\t \n};\n\nstatic int\nsnd_ad1889_playback_open(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\n\tchip->psubs = ss;\n\trt->hw = snd_ad1889_playback_hw;\n\n\treturn 0;\n}\n\nstatic int\nsnd_ad1889_capture_open(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\n\tchip->csubs = ss;\n\trt->hw = snd_ad1889_capture_hw;\n\n\treturn 0;\n}\n\nstatic int\nsnd_ad1889_playback_close(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tchip->psubs = NULL;\n\treturn 0;\n}\n\nstatic int\nsnd_ad1889_capture_close(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tchip->csubs = NULL;\n\treturn 0;\n}\n\nstatic int\nsnd_ad1889_playback_prepare(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(ss);\n\tunsigned int count = snd_pcm_lib_period_bytes(ss);\n\tu16 reg;\n\n\tad1889_channel_reset(chip, AD_CHAN_WAV);\n\n\treg = ad1889_readw(chip, AD_DS_WSMC);\n\t\n\t \n\treg &= ~(AD_DS_WSMC_WA16 | AD_DS_WSMC_WAST);\n\n\tif (snd_pcm_format_width(rt->format) == 16)\n\t\treg |= AD_DS_WSMC_WA16;\n\n\tif (rt->channels > 1)\n\t\treg |= AD_DS_WSMC_WAST;\n\n\t \n\tspin_lock_irq(&chip->lock);\n\t\n\tchip->wave.size = size;\n\tchip->wave.reg = reg;\n\tchip->wave.addr = rt->dma_addr;\n\n\tad1889_writew(chip, AD_DS_WSMC, chip->wave.reg);\n\t\n\t \n\tad1889_writew(chip, AD_DS_WAS, rt->rate);\n\n\t \n\tad1889_load_wave_buffer_address(chip, chip->wave.addr);\n\tad1889_load_wave_buffer_count(chip, size);\n\tad1889_load_wave_interrupt_count(chip, count);\n\n\t \n\tad1889_readw(chip, AD_DS_WSMC);\n\t\n\tspin_unlock_irq(&chip->lock);\n\t\n\tdev_dbg(chip->card->dev,\n\t\t\"prepare playback: addr = 0x%x, count = %u, size = %u, reg = 0x%x, rate = %u\\n\",\n\t\tchip->wave.addr, count, size, reg, rt->rate);\n\treturn 0;\n}\n\nstatic int\nsnd_ad1889_capture_prepare(struct snd_pcm_substream *ss)\n{\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\tstruct snd_pcm_runtime *rt = ss->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(ss);\n\tunsigned int count = snd_pcm_lib_period_bytes(ss);\n\tu16 reg;\n\n\tad1889_channel_reset(chip, AD_CHAN_ADC);\n\t\n\treg = ad1889_readw(chip, AD_DS_RAMC);\n\n\t \n\treg &= ~(AD_DS_RAMC_AD16 | AD_DS_RAMC_ADST);\n\n\tif (snd_pcm_format_width(rt->format) == 16)\n\t\treg |= AD_DS_RAMC_AD16;\n\n\tif (rt->channels > 1)\n\t\treg |= AD_DS_RAMC_ADST;\n\n\t \n\tspin_lock_irq(&chip->lock);\n\t\n\tchip->ramc.size = size;\n\tchip->ramc.reg = reg;\n\tchip->ramc.addr = rt->dma_addr;\n\n\tad1889_writew(chip, AD_DS_RAMC, chip->ramc.reg);\n\n\t \n\tad1889_load_adc_buffer_address(chip, chip->ramc.addr);\n\tad1889_load_adc_buffer_count(chip, size);\n\tad1889_load_adc_interrupt_count(chip, count);\n\n\t \n\tad1889_readw(chip, AD_DS_RAMC);\n\t\n\tspin_unlock_irq(&chip->lock);\n\t\n\tdev_dbg(chip->card->dev,\n\t\t\"prepare capture: addr = 0x%x, count = %u, size = %u, reg = 0x%x, rate = %u\\n\",\n\t\tchip->ramc.addr, count, size, reg, rt->rate);\n\treturn 0;\n}\n\n \nstatic int\nsnd_ad1889_playback_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n\tu16 wsmc;\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\t\n\twsmc = ad1889_readw(chip, AD_DS_WSMC);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tad1889_writew(chip, AD_DMA_WAV, AD_DMA_LOOP | AD_DMA_IM_CNT);\n\t\twsmc |= AD_DS_WSMC_WAEN;\n\t\t \n\t\tad1889_writel(chip, AD_DMA_CHSS, AD_DMA_CHSS_WAVS);\n\t\tad1889_unmute(chip);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tad1889_mute(chip);\n\t\twsmc &= ~AD_DS_WSMC_WAEN;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\t\n\tchip->wave.reg = wsmc;\n\tad1889_writew(chip, AD_DS_WSMC, wsmc);\t\n\tad1889_readw(chip, AD_DS_WSMC);\t \n\n\t \n\tif (cmd == SNDRV_PCM_TRIGGER_STOP)\n\t\tad1889_channel_reset(chip, AD_CHAN_WAV);\n\n\treturn 0;\n}\n\n \nstatic int\nsnd_ad1889_capture_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n\tu16 ramc;\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\n\tramc = ad1889_readw(chip, AD_DS_RAMC);\n\t\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tad1889_writew(chip, AD_DMA_ADC, AD_DMA_LOOP | AD_DMA_IM_CNT);\n\t\tramc |= AD_DS_RAMC_ADEN;\n\t\t \n\t\tad1889_writel(chip, AD_DMA_CHSS, AD_DMA_CHSS_ADCS);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tramc &= ~AD_DS_RAMC_ADEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t\n\tchip->ramc.reg = ramc;\n\tad1889_writew(chip, AD_DS_RAMC, ramc);\t\n\tad1889_readw(chip, AD_DS_RAMC);\t \n\t\n\t \n\tif (cmd == SNDRV_PCM_TRIGGER_STOP)\n\t\tad1889_channel_reset(chip, AD_CHAN_ADC);\n\t\t\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_ad1889_playback_pointer(struct snd_pcm_substream *ss)\n{\n\tsize_t ptr = 0;\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\n\tif (unlikely(!(chip->wave.reg & AD_DS_WSMC_WAEN)))\n\t\treturn 0;\n\n\tptr = ad1889_readl(chip, AD_DMA_WAVCA);\n\tptr -= chip->wave.addr;\n\t\n\tif (snd_BUG_ON(ptr >= chip->wave.size))\n\t\treturn 0;\n\t\n\treturn bytes_to_frames(ss->runtime, ptr);\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_ad1889_capture_pointer(struct snd_pcm_substream *ss)\n{\n\tsize_t ptr = 0;\n\tstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\n\n\tif (unlikely(!(chip->ramc.reg & AD_DS_RAMC_ADEN)))\n\t\treturn 0;\n\n\tptr = ad1889_readl(chip, AD_DMA_ADCCA);\n\tptr -= chip->ramc.addr;\n\n\tif (snd_BUG_ON(ptr >= chip->ramc.size))\n\t\treturn 0;\n\t\n\treturn bytes_to_frames(ss->runtime, ptr);\n}\n\nstatic const struct snd_pcm_ops snd_ad1889_playback_ops = {\n\t.open = snd_ad1889_playback_open,\n\t.close = snd_ad1889_playback_close,\n\t.prepare = snd_ad1889_playback_prepare,\n\t.trigger = snd_ad1889_playback_trigger,\n\t.pointer = snd_ad1889_playback_pointer, \n};\n\nstatic const struct snd_pcm_ops snd_ad1889_capture_ops = {\n\t.open = snd_ad1889_capture_open,\n\t.close = snd_ad1889_capture_close,\n\t.prepare = snd_ad1889_capture_prepare,\n\t.trigger = snd_ad1889_capture_trigger,\n\t.pointer = snd_ad1889_capture_pointer, \n};\n\nstatic irqreturn_t\nsnd_ad1889_interrupt(int irq, void *dev_id)\n{\n\tunsigned long st;\n\tstruct snd_ad1889 *chip = dev_id;\n\n\tst = ad1889_readl(chip, AD_DMA_DISR);\n\n\t \n\tad1889_writel(chip, AD_DMA_DISR, st);\n\n\tst &= AD_INTR_MASK;\n\n\tif (unlikely(!st))\n\t\treturn IRQ_NONE;\n\n\tif (st & (AD_DMA_DISR_PMAI|AD_DMA_DISR_PTAI))\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"Unexpected master or target abort interrupt!\\n\");\n\n\tif ((st & AD_DMA_DISR_WAVI) && chip->psubs)\n\t\tsnd_pcm_period_elapsed(chip->psubs);\n\tif ((st & AD_DMA_DISR_ADCI) && chip->csubs)\n\t\tsnd_pcm_period_elapsed(chip->csubs);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nsnd_ad1889_pcm_init(struct snd_ad1889 *chip, int device)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\terr = snd_pcm_new(chip->card, chip->card->driver, device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, \n\t\t\t&snd_ad1889_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_ad1889_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, chip->card->shortname);\n\t\n\tchip->pcm = pcm;\n\tchip->psubs = NULL;\n\tchip->csubs = NULL;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t       BUFFER_BYTES_MAX / 2, BUFFER_BYTES_MAX);\n\n\treturn 0;\n}\n\nstatic void\nsnd_ad1889_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_ad1889 *chip = entry->private_data;\n\tu16 reg;\n\tint tmp;\n\n\treg = ad1889_readw(chip, AD_DS_WSMC);\n\tsnd_iprintf(buffer, \"Wave output: %s\\n\",\n\t\t\t(reg & AD_DS_WSMC_WAEN) ? \"enabled\" : \"disabled\");\n\tsnd_iprintf(buffer, \"Wave Channels: %s\\n\",\n\t\t\t(reg & AD_DS_WSMC_WAST) ? \"stereo\" : \"mono\");\n\tsnd_iprintf(buffer, \"Wave Quality: %d-bit linear\\n\",\n\t\t\t(reg & AD_DS_WSMC_WA16) ? 16 : 8);\n\t\n\t \n\ttmp = (reg & AD_DS_WSMC_WARQ) ?\n\t\t((((reg & AD_DS_WSMC_WARQ) >> 12) & 0x01) ? 12 : 18) : 4;\n\ttmp /= (reg & AD_DS_WSMC_WAST) ? 2 : 1;\n\t\n\tsnd_iprintf(buffer, \"Wave FIFO: %d %s words\\n\\n\", tmp,\n\t\t\t(reg & AD_DS_WSMC_WAST) ? \"stereo\" : \"mono\");\n\t\t\t\t\n\t\n\tsnd_iprintf(buffer, \"Synthesis output: %s\\n\",\n\t\t\treg & AD_DS_WSMC_SYEN ? \"enabled\" : \"disabled\");\n\t\n\t \n\ttmp = (reg & AD_DS_WSMC_SYRQ) ?\n\t\t((((reg & AD_DS_WSMC_SYRQ) >> 4) & 0x01) ? 12 : 18) : 4;\n\ttmp /= (reg & AD_DS_WSMC_WAST) ? 2 : 1;\n\t\n\tsnd_iprintf(buffer, \"Synthesis FIFO: %d %s words\\n\\n\", tmp,\n\t\t\t(reg & AD_DS_WSMC_WAST) ? \"stereo\" : \"mono\");\n\n\treg = ad1889_readw(chip, AD_DS_RAMC);\n\tsnd_iprintf(buffer, \"ADC input: %s\\n\",\n\t\t\t(reg & AD_DS_RAMC_ADEN) ? \"enabled\" : \"disabled\");\n\tsnd_iprintf(buffer, \"ADC Channels: %s\\n\",\n\t\t\t(reg & AD_DS_RAMC_ADST) ? \"stereo\" : \"mono\");\n\tsnd_iprintf(buffer, \"ADC Quality: %d-bit linear\\n\",\n\t\t\t(reg & AD_DS_RAMC_AD16) ? 16 : 8);\n\t\n\t \n\ttmp = (reg & AD_DS_RAMC_ACRQ) ?\n\t\t((((reg & AD_DS_RAMC_ACRQ) >> 4) & 0x01) ? 12 : 18) : 4;\n\ttmp /= (reg & AD_DS_RAMC_ADST) ? 2 : 1;\n\t\n\tsnd_iprintf(buffer, \"ADC FIFO: %d %s words\\n\\n\", tmp,\n\t\t\t(reg & AD_DS_RAMC_ADST) ? \"stereo\" : \"mono\");\n\t\n\tsnd_iprintf(buffer, \"Resampler input: %s\\n\",\n\t\t\treg & AD_DS_RAMC_REEN ? \"enabled\" : \"disabled\");\n\t\t\t\n\t \n\ttmp = (reg & AD_DS_RAMC_RERQ) ?\n\t\t((((reg & AD_DS_RAMC_RERQ) >> 12) & 0x01) ? 12 : 18) : 4;\n\ttmp /= (reg & AD_DS_RAMC_ADST) ? 2 : 1;\n\t\n\tsnd_iprintf(buffer, \"Resampler FIFO: %d %s words\\n\\n\", tmp,\n\t\t\t(reg & AD_DS_WSMC_WAST) ? \"stereo\" : \"mono\");\n\t\t\t\t\n\t\n\t \n\treg = ad1889_readw(chip, AD_DS_WADA);\n\tsnd_iprintf(buffer, \"Left: %s, -%d dB\\n\",\n\t\t\t(reg & AD_DS_WADA_LWAM) ? \"mute\" : \"unmute\",\n\t\t\t((reg & AD_DS_WADA_LWAA) >> 8) * 3);\n\treg = ad1889_readw(chip, AD_DS_WADA);\n\tsnd_iprintf(buffer, \"Right: %s, -%d dB\\n\",\n\t\t\t(reg & AD_DS_WADA_RWAM) ? \"mute\" : \"unmute\",\n\t\t\t(reg & AD_DS_WADA_RWAA) * 3);\n\t\n\treg = ad1889_readw(chip, AD_DS_WAS);\n\tsnd_iprintf(buffer, \"Wave samplerate: %u Hz\\n\", reg);\n\treg = ad1889_readw(chip, AD_DS_RES);\n\tsnd_iprintf(buffer, \"Resampler samplerate: %u Hz\\n\", reg);\n}\n\nstatic void\nsnd_ad1889_proc_init(struct snd_ad1889 *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, chip->card->driver,\n\t\t\t     chip, snd_ad1889_proc_read);\n}\n\nstatic const struct ac97_quirk ac97_quirks[] = {\n\t{\n\t\t.subvendor = 0x11d4,\t \n\t\t.subdevice = 0x1889,\t \n\t\t.codec_id = AC97_ID_AD1819,\n\t\t.name = \"AD1889\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{ }  \n};\n\nstatic void\nsnd_ad1889_ac97_xinit(struct snd_ad1889 *chip)\n{\n\tu16 reg;\n\n\treg = ad1889_readw(chip, AD_AC97_ACIC);\n\treg |= AD_AC97_ACIC_ACRD;\t\t \n\tad1889_writew(chip, AD_AC97_ACIC, reg);\n\tad1889_readw(chip, AD_AC97_ACIC);\t \n\tudelay(10);\n\t \n\treg |= AD_AC97_ACIC_ACIE;\n\tad1889_writew(chip, AD_AC97_ACIC, reg);\n\t\n\tsnd_ad1889_ac97_ready(chip);\n\n\t \n\treg = ad1889_readw(chip, AD_AC97_ACIC);\n\treg |= AD_AC97_ACIC_ASOE | AD_AC97_ACIC_VSRM;\n\tad1889_writew(chip, AD_AC97_ACIC, reg);\n\tad1889_readw(chip, AD_AC97_ACIC);  \n\n}\n\nstatic int\nsnd_ad1889_ac97_init(struct snd_ad1889 *chip, const char *quirk_override)\n{\n\tint err;\n\tstruct snd_ac97_template ac97;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_ad1889_ac97_write,\n\t\t.read = snd_ad1889_ac97_read,\n\t};\n\n\t \n\tsnd_ad1889_ac97_xinit(chip);\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.pci = chip->pci;\n\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\t\t\n\tsnd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);\n\t\n\treturn 0;\n}\n\nstatic void\nsnd_ad1889_free(struct snd_card *card)\n{\n\tstruct snd_ad1889 *chip = card->private_data;\n\n\tspin_lock_irq(&chip->lock);\n\n\tad1889_mute(chip);\n\n\t \n\tad1889_channel_reset(chip, AD_CHAN_WAV | AD_CHAN_ADC);\n\n\t \n\tad1889_writel(chip, AD_DMA_DISR, AD_DMA_DISR_PTAI | AD_DMA_DISR_PMAI);\n\tad1889_readl(chip, AD_DMA_DISR);\t \n\n\tspin_unlock_irq(&chip->lock);\n}\n\nstatic int\nsnd_ad1889_create(struct snd_card *card, struct pci_dev *pci)\n{\n\tstruct snd_ad1889 *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(card->dev, \"error setting 32-bit DMA mask.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\t \n\terr = pcim_iomap_regions(pci, 1 << 0, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->bar = pci_resource_start(pci, 0);\n\tchip->iobase = pcim_iomap_table(pci)[0];\n\t\n\tpci_set_master(pci);\n\n\tspin_lock_init(&chip->lock);\t \n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_ad1889_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"cannot obtain IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_ad1889_free;\n\n\t \n\tad1889_writew(chip, AD_DS_CCS, AD_DS_CCS_CLKEN);  \n\tad1889_readw(chip, AD_DS_CCS);\t \n\n\tusleep_range(10000, 11000);\n\n\t \n\tad1889_writel(chip, AD_DMA_DISR, AD_DMA_DISR_PMAE | AD_DMA_DISR_PTAE);\n\n\treturn 0;\n}\n\nstatic int\n__snd_ad1889_probe(struct pci_dev *pci,\n\t\t   const struct pci_device_id *pci_id)\n{\n\tint err;\n\tstatic int devno;\n\tstruct snd_card *card;\n\tstruct snd_ad1889 *chip;\n\n\t \n\tif (devno >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[devno]) {\n\t\tdevno++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = snd_devm_card_new(&pci->dev, index[devno], id[devno], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tstrcpy(card->driver, \"AD1889\");\n\tstrcpy(card->shortname, \"Analog Devices AD1889\");\n\n\t \n\terr = snd_ad1889_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsprintf(card->longname, \"%s at 0x%lx irq %i\",\n\t\tcard->shortname, chip->bar, chip->irq);\n\n\t \n\t \n\terr = snd_ad1889_ac97_init(chip, ac97_quirk[devno]);\n\tif (err < 0)\n\t\treturn err;\n\t\n\terr = snd_ad1889_pcm_init(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnd_ad1889_proc_init(chip);\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpci_set_drvdata(pci, card);\n\n\tdevno++;\n\treturn 0;\n}\n\nstatic int snd_ad1889_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_ad1889_probe(pci, pci_id));\n}\n\nstatic const struct pci_device_id snd_ad1889_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ANALOG_DEVICES, PCI_DEVICE_ID_AD1889JS) },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, snd_ad1889_ids);\n\nstatic struct pci_driver ad1889_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_ad1889_ids,\n\t.probe = snd_ad1889_probe,\n};\n\nmodule_pci_driver(ad1889_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}