{
  "module_name": "atiixp_modem.c",
  "hash_id": "17ab320b221c22726472fb9026430c05da31eca66076722ebc06e2f2a2e157aa",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/atiixp_modem.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ATI IXP MC97 controller\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = -2;  \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int ac97_clock = 48000;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for ATI IXP controller.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for ATI IXP controller.\");\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (default 48000Hz).\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n\n \n\n#define ATI_REG_ISR\t\t\t0x00\t \n#define  ATI_REG_ISR_MODEM_IN_XRUN\t(1U<<0)\n#define  ATI_REG_ISR_MODEM_IN_STATUS\t(1U<<1)\n#define  ATI_REG_ISR_MODEM_OUT1_XRUN\t(1U<<2)\n#define  ATI_REG_ISR_MODEM_OUT1_STATUS\t(1U<<3)\n#define  ATI_REG_ISR_MODEM_OUT2_XRUN\t(1U<<4)\n#define  ATI_REG_ISR_MODEM_OUT2_STATUS\t(1U<<5)\n#define  ATI_REG_ISR_MODEM_OUT3_XRUN\t(1U<<6)\n#define  ATI_REG_ISR_MODEM_OUT3_STATUS\t(1U<<7)\n#define  ATI_REG_ISR_PHYS_INTR\t\t(1U<<8)\n#define  ATI_REG_ISR_PHYS_MISMATCH\t(1U<<9)\n#define  ATI_REG_ISR_CODEC0_NOT_READY\t(1U<<10)\n#define  ATI_REG_ISR_CODEC1_NOT_READY\t(1U<<11)\n#define  ATI_REG_ISR_CODEC2_NOT_READY\t(1U<<12)\n#define  ATI_REG_ISR_NEW_FRAME\t\t(1U<<13)\n#define  ATI_REG_ISR_MODEM_GPIO_DATA\t(1U<<14)\n\n#define ATI_REG_IER\t\t\t0x04\t \n#define  ATI_REG_IER_MODEM_IN_XRUN_EN\t(1U<<0)\n#define  ATI_REG_IER_MODEM_STATUS_EN\t(1U<<1)\n#define  ATI_REG_IER_MODEM_OUT1_XRUN_EN\t(1U<<2)\n#define  ATI_REG_IER_MODEM_OUT2_XRUN_EN\t(1U<<4)\n#define  ATI_REG_IER_MODEM_OUT3_XRUN_EN\t(1U<<6)\n#define  ATI_REG_IER_PHYS_INTR_EN\t(1U<<8)\n#define  ATI_REG_IER_PHYS_MISMATCH_EN\t(1U<<9)\n#define  ATI_REG_IER_CODEC0_INTR_EN\t(1U<<10)\n#define  ATI_REG_IER_CODEC1_INTR_EN\t(1U<<11)\n#define  ATI_REG_IER_CODEC2_INTR_EN\t(1U<<12)\n#define  ATI_REG_IER_NEW_FRAME_EN\t(1U<<13)\t \n#define  ATI_REG_IER_MODEM_GPIO_DATA_EN\t(1U<<14)\t \n#define  ATI_REG_IER_MODEM_SET_BUS_BUSY\t(1U<<15)\n\n#define ATI_REG_CMD\t\t\t0x08\t \n#define  ATI_REG_CMD_POWERDOWN\t(1U<<0)\n#define  ATI_REG_CMD_MODEM_RECEIVE_EN\t(1U<<1)\t \n#define  ATI_REG_CMD_MODEM_SEND1_EN\t(1U<<2)\t \n#define  ATI_REG_CMD_MODEM_SEND2_EN\t(1U<<3)\t \n#define  ATI_REG_CMD_MODEM_SEND3_EN\t(1U<<4)\t \n#define  ATI_REG_CMD_MODEM_STATUS_MEM\t(1U<<5)\t \n#define  ATI_REG_CMD_MODEM_IN_DMA_EN\t(1U<<8)\t \n#define  ATI_REG_CMD_MODEM_OUT_DMA1_EN\t(1U<<9)\t \n#define  ATI_REG_CMD_MODEM_OUT_DMA2_EN\t(1U<<10)\t \n#define  ATI_REG_CMD_MODEM_OUT_DMA3_EN\t(1U<<11)\t \n#define  ATI_REG_CMD_AUDIO_PRESENT\t(1U<<20)\n#define  ATI_REG_CMD_MODEM_GPIO_THRU_DMA\t(1U<<22)\t \n#define  ATI_REG_CMD_LOOPBACK_EN\t(1U<<23)\n#define  ATI_REG_CMD_PACKED_DIS\t\t(1U<<24)\n#define  ATI_REG_CMD_BURST_EN\t\t(1U<<25)\n#define  ATI_REG_CMD_PANIC_EN\t\t(1U<<26)\n#define  ATI_REG_CMD_MODEM_PRESENT\t(1U<<27)\n#define  ATI_REG_CMD_ACLINK_ACTIVE\t(1U<<28)\n#define  ATI_REG_CMD_AC_SOFT_RESET\t(1U<<29)\n#define  ATI_REG_CMD_AC_SYNC\t\t(1U<<30)\n#define  ATI_REG_CMD_AC_RESET\t\t(1U<<31)\n\n#define ATI_REG_PHYS_OUT_ADDR\t\t0x0c\n#define  ATI_REG_PHYS_OUT_CODEC_MASK\t(3U<<0)\n#define  ATI_REG_PHYS_OUT_RW\t\t(1U<<2)\n#define  ATI_REG_PHYS_OUT_ADDR_EN\t(1U<<8)\n#define  ATI_REG_PHYS_OUT_ADDR_SHIFT\t9\n#define  ATI_REG_PHYS_OUT_DATA_SHIFT\t16\n\n#define ATI_REG_PHYS_IN_ADDR\t\t0x10\n#define  ATI_REG_PHYS_IN_READ_FLAG\t(1U<<8)\n#define  ATI_REG_PHYS_IN_ADDR_SHIFT\t9\n#define  ATI_REG_PHYS_IN_DATA_SHIFT\t16\n\n#define ATI_REG_SLOTREQ\t\t\t0x14\n\n#define ATI_REG_COUNTER\t\t\t0x18\n#define  ATI_REG_COUNTER_SLOT\t\t(3U<<0)\t \n#define  ATI_REG_COUNTER_BITCLOCK\t(31U<<8)\n\n#define ATI_REG_IN_FIFO_THRESHOLD\t0x1c\n\n#define ATI_REG_MODEM_IN_DMA_LINKPTR\t0x20\n#define ATI_REG_MODEM_IN_DMA_DT_START\t0x24\t \n#define ATI_REG_MODEM_IN_DMA_DT_NEXT\t0x28\t \n#define ATI_REG_MODEM_IN_DMA_DT_CUR\t0x2c\t \n#define ATI_REG_MODEM_IN_DMA_DT_SIZE\t0x30\n#define ATI_REG_MODEM_OUT_FIFO\t\t0x34\t \n#define  ATI_REG_MODEM_OUT1_DMA_THRESHOLD_MASK\t(0xf<<16)\n#define  ATI_REG_MODEM_OUT1_DMA_THRESHOLD_SHIFT\t16\n#define ATI_REG_MODEM_OUT_DMA1_LINKPTR\t0x38\n#define ATI_REG_MODEM_OUT_DMA2_LINKPTR\t0x3c\n#define ATI_REG_MODEM_OUT_DMA3_LINKPTR\t0x40\n#define ATI_REG_MODEM_OUT_DMA1_DT_START\t0x44\n#define ATI_REG_MODEM_OUT_DMA1_DT_NEXT\t0x48\n#define ATI_REG_MODEM_OUT_DMA1_DT_CUR\t0x4c\n#define ATI_REG_MODEM_OUT_DMA2_DT_START\t0x50\n#define ATI_REG_MODEM_OUT_DMA2_DT_NEXT\t0x54\n#define ATI_REG_MODEM_OUT_DMA2_DT_CUR\t0x58\n#define ATI_REG_MODEM_OUT_DMA3_DT_START\t0x5c\n#define ATI_REG_MODEM_OUT_DMA3_DT_NEXT\t0x60\n#define ATI_REG_MODEM_OUT_DMA3_DT_CUR\t0x64\n#define ATI_REG_MODEM_OUT_DMA12_DT_SIZE\t0x68\n#define ATI_REG_MODEM_OUT_DMA3_DT_SIZE\t0x6c\n#define ATI_REG_MODEM_OUT_FIFO_USED     0x70\n#define ATI_REG_MODEM_OUT_GPIO\t\t0x74\n#define  ATI_REG_MODEM_OUT_GPIO_EN\t   1\n#define  ATI_REG_MODEM_OUT_GPIO_DATA_SHIFT 5\n#define ATI_REG_MODEM_IN_GPIO\t\t0x78\n\n#define ATI_REG_MODEM_MIRROR\t\t0x7c\n#define ATI_REG_AUDIO_MIRROR\t\t0x80\n\n#define ATI_REG_MODEM_FIFO_FLUSH\t0x88\n#define  ATI_REG_MODEM_FIFO_OUT1_FLUSH\t(1U<<0)\n#define  ATI_REG_MODEM_FIFO_OUT2_FLUSH\t(1U<<1)\n#define  ATI_REG_MODEM_FIFO_OUT3_FLUSH\t(1U<<2)\n#define  ATI_REG_MODEM_FIFO_IN_FLUSH\t(1U<<3)\n\n \n#define  ATI_REG_LINKPTR_EN\t\t(1U<<0)\n\n#define ATI_MAX_DESCRIPTORS\t256\t \n\n\nstruct atiixp_modem;\n\n \n\nstruct atiixp_dma_desc {\n\t__le32 addr;\t \n\tu16 status;\t \n\tu16 size;\t \n\t__le32 next;\t \n};\n\n \nenum { ATI_DMA_PLAYBACK, ATI_DMA_CAPTURE, NUM_ATI_DMAS };  \nenum { ATI_PCM_OUT, ATI_PCM_IN, NUM_ATI_PCMS };  \nenum { ATI_PCMDEV_ANALOG, NUM_ATI_PCMDEVS };  \n\n#define NUM_ATI_CODECS\t3\n\n\n \nstruct atiixp_dma_ops {\n\tint type;\t\t\t \n\tunsigned int llp_offset;\t \n\tunsigned int dt_cur;\t\t \n\t \n\tvoid (*enable_dma)(struct atiixp_modem *chip, int on);\n\t \n\tvoid (*enable_transfer)(struct atiixp_modem *chip, int on);\n \t \n\tvoid (*flush_dma)(struct atiixp_modem *chip);\n};\n\n \nstruct atiixp_dma {\n\tconst struct atiixp_dma_ops *ops;\n\tstruct snd_dma_buffer desc_buf;\n\tstruct snd_pcm_substream *substream;\t \n\tunsigned int buf_addr, buf_bytes;\t \n\tunsigned int period_bytes, periods;\n\tint opened;\n\tint running;\n\tint pcm_open_flag;\n\tint ac97_pcm_type;\t \n};\n\n \nstruct atiixp_modem {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\n\tstruct resource *res;\t\t \n\tunsigned long addr;\n\tvoid __iomem *remap_addr;\n\tint irq;\n\t\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97[NUM_ATI_CODECS];\n\n\tspinlock_t reg_lock;\n\n\tstruct atiixp_dma dmas[NUM_ATI_DMAS];\n\tstruct ac97_pcm *pcms[NUM_ATI_PCMS];\n\tstruct snd_pcm *pcmdevs[NUM_ATI_PCMDEVS];\n\n\tint max_channels;\t\t \n\n\tunsigned int codec_not_ready_bits;\t \n\n\tint spdif_over_aclink;\t\t \n\tstruct mutex open_mutex;\t \n};\n\n\n \nstatic const struct pci_device_id snd_atiixp_ids[] = {\n\t{ PCI_VDEVICE(ATI, 0x434d), 0 },  \n\t{ PCI_VDEVICE(ATI, 0x4378), 0 },  \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_atiixp_ids);\n\n\n \n\n \nstatic int snd_atiixp_update_bits(struct atiixp_modem *chip, unsigned int reg,\n\t\t\t\t  unsigned int mask, unsigned int value)\n{\n\tvoid __iomem *addr = chip->remap_addr + reg;\n\tunsigned int data, old_data;\n\told_data = data = readl(addr);\n\tdata &= ~mask;\n\tdata |= value;\n\tif (old_data == data)\n\t\treturn 0;\n\twritel(data, addr);\n\treturn 1;\n}\n\n \n#define atiixp_write(chip,reg,value) \\\n\twritel(value, chip->remap_addr + ATI_REG_##reg)\n#define atiixp_read(chip,reg) \\\n\treadl(chip->remap_addr + ATI_REG_##reg)\n#define atiixp_update(chip,reg,mask,val) \\\n\tsnd_atiixp_update_bits(chip, ATI_REG_##reg, mask, val)\n\n \n\n#define ATI_DESC_LIST_SIZE \\\n\tPAGE_ALIGN(ATI_MAX_DESCRIPTORS * sizeof(struct atiixp_dma_desc))\n\n \nstatic int atiixp_build_dma_packets(struct atiixp_modem *chip,\n\t\t\t\t    struct atiixp_dma *dma,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    unsigned int periods,\n\t\t\t\t    unsigned int period_bytes)\n{\n\tunsigned int i;\n\tu32 addr, desc_addr;\n\tunsigned long flags;\n\n\tif (periods > ATI_MAX_DESCRIPTORS)\n\t\treturn -ENOMEM;\n\n\tif (dma->desc_buf.area == NULL) {\n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t\tATI_DESC_LIST_SIZE, &dma->desc_buf) < 0)\n\t\t\treturn -ENOMEM;\n\t\tdma->period_bytes = dma->periods = 0;  \n\t}\n\n\tif (dma->periods == periods && dma->period_bytes == period_bytes)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\twritel(0, chip->remap_addr + dma->ops->llp_offset);\n\tdma->ops->enable_dma(chip, 0);\n\tdma->ops->enable_dma(chip, 1);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\t \n\taddr = (u32)substream->runtime->dma_addr;\n\tdesc_addr = (u32)dma->desc_buf.addr;\n\tfor (i = 0; i < periods; i++) {\n\t\tstruct atiixp_dma_desc *desc;\n\t\tdesc = &((struct atiixp_dma_desc *)dma->desc_buf.area)[i];\n\t\tdesc->addr = cpu_to_le32(addr);\n\t\tdesc->status = 0;\n\t\tdesc->size = period_bytes >> 2;  \n\t\tdesc_addr += sizeof(struct atiixp_dma_desc);\n\t\tif (i == periods - 1)\n\t\t\tdesc->next = cpu_to_le32((u32)dma->desc_buf.addr);\n\t\telse\n\t\t\tdesc->next = cpu_to_le32(desc_addr);\n\t\taddr += period_bytes;\n\t}\n\n\twritel((u32)dma->desc_buf.addr | ATI_REG_LINKPTR_EN,\n\t       chip->remap_addr + dma->ops->llp_offset);\n\n\tdma->period_bytes = period_bytes;\n\tdma->periods = periods;\n\n\treturn 0;\n}\n\n \nstatic void atiixp_clear_dma_packets(struct atiixp_modem *chip,\n\t\t\t\t     struct atiixp_dma *dma,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tif (dma->desc_buf.area) {\n\t\twritel(0, chip->remap_addr + dma->ops->llp_offset);\n\t\tsnd_dma_free_pages(&dma->desc_buf);\n\t\tdma->desc_buf.area = NULL;\n\t}\n}\n\n \nstatic int snd_atiixp_acquire_codec(struct atiixp_modem *chip)\n{\n\tint timeout = 1000;\n\n\twhile (atiixp_read(chip, PHYS_OUT_ADDR) & ATI_REG_PHYS_OUT_ADDR_EN) {\n\t\tif (! timeout--) {\n\t\t\tdev_warn(chip->card->dev, \"codec acquire timeout\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\nstatic unsigned short snd_atiixp_codec_read(struct atiixp_modem *chip,\n\t\t\t\t\t    unsigned short codec,\n\t\t\t\t\t    unsigned short reg)\n{\n\tunsigned int data;\n\tint timeout;\n\n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn 0xffff;\n\tdata = (reg << ATI_REG_PHYS_OUT_ADDR_SHIFT) |\n\t\tATI_REG_PHYS_OUT_ADDR_EN |\n\t\tATI_REG_PHYS_OUT_RW |\n\t\tcodec;\n\tatiixp_write(chip, PHYS_OUT_ADDR, data);\n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn 0xffff;\n\ttimeout = 1000;\n\tdo {\n\t\tdata = atiixp_read(chip, PHYS_IN_ADDR);\n\t\tif (data & ATI_REG_PHYS_IN_READ_FLAG)\n\t\t\treturn data >> ATI_REG_PHYS_IN_DATA_SHIFT;\n\t\tudelay(1);\n\t} while (--timeout);\n\t \n\tif (reg < 0x7c)\n\t\tdev_warn(chip->card->dev, \"codec read timeout (reg %x)\\n\", reg);\n\treturn 0xffff;\n}\n\n\nstatic void snd_atiixp_codec_write(struct atiixp_modem *chip,\n\t\t\t\t   unsigned short codec,\n\t\t\t\t   unsigned short reg, unsigned short val)\n{\n\tunsigned int data;\n    \n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn;\n\tdata = ((unsigned int)val << ATI_REG_PHYS_OUT_DATA_SHIFT) |\n\t\t((unsigned int)reg << ATI_REG_PHYS_OUT_ADDR_SHIFT) |\n\t\tATI_REG_PHYS_OUT_ADDR_EN | codec;\n\tatiixp_write(chip, PHYS_OUT_ADDR, data);\n}\n\n\nstatic unsigned short snd_atiixp_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t   unsigned short reg)\n{\n\tstruct atiixp_modem *chip = ac97->private_data;\n\treturn snd_atiixp_codec_read(chip, ac97->num, reg);\n    \n}\n\nstatic void snd_atiixp_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\t  unsigned short val)\n{\n\tstruct atiixp_modem *chip = ac97->private_data;\n\tif (reg == AC97_GPIO_STATUS) {\n\t\tatiixp_write(chip, MODEM_OUT_GPIO,\n\t\t\t(val << ATI_REG_MODEM_OUT_GPIO_DATA_SHIFT) | ATI_REG_MODEM_OUT_GPIO_EN);\n\t\treturn;\n\t}\n\tsnd_atiixp_codec_write(chip, ac97->num, reg, val);\n}\n\n \nstatic int snd_atiixp_aclink_reset(struct atiixp_modem *chip)\n{\n\tint timeout;\n\n\t \n\tif (atiixp_update(chip, CMD, ATI_REG_CMD_POWERDOWN, 0))\n\t\tudelay(10);\n\n\t \n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SOFT_RESET, ATI_REG_CMD_AC_SOFT_RESET);\n\tatiixp_read(chip, CMD);\n\tudelay(10);\n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SOFT_RESET, 0);\n    \n\ttimeout = 10;\n\twhile (! (atiixp_read(chip, CMD) & ATI_REG_CMD_ACLINK_ACTIVE)) {\n\t\t \n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET,\n\t\t\t      ATI_REG_CMD_AC_SYNC);\n\t\tatiixp_read(chip, CMD);\n\t\tmsleep(1);\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_RESET, ATI_REG_CMD_AC_RESET);\n\t\tif (!--timeout) {\n\t\t\tdev_err(chip->card->dev, \"codec reset timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET,\n\t\t      ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_atiixp_aclink_down(struct atiixp_modem *chip)\n{\n\t\n\t\n\tatiixp_update(chip, CMD,\n\t\t     ATI_REG_CMD_POWERDOWN | ATI_REG_CMD_AC_RESET,\n\t\t     ATI_REG_CMD_POWERDOWN);\n\treturn 0;\n}\n#endif\n\n \n\n#define ALL_CODEC_NOT_READY \\\n\t    (ATI_REG_ISR_CODEC0_NOT_READY |\\\n\t     ATI_REG_ISR_CODEC1_NOT_READY |\\\n\t     ATI_REG_ISR_CODEC2_NOT_READY)\n#define CODEC_CHECK_BITS (ALL_CODEC_NOT_READY|ATI_REG_ISR_NEW_FRAME)\n\nstatic int snd_atiixp_codec_detect(struct atiixp_modem *chip)\n{\n\tint timeout;\n\n\tchip->codec_not_ready_bits = 0;\n\tatiixp_write(chip, IER, CODEC_CHECK_BITS);\n\t \n\ttimeout = 50;\n\twhile (timeout-- > 0) {\n\t\tmsleep(1);\n\t\tif (chip->codec_not_ready_bits)\n\t\t\tbreak;\n\t}\n\tatiixp_write(chip, IER, 0);  \n\n\tif ((chip->codec_not_ready_bits & ALL_CODEC_NOT_READY) == ALL_CODEC_NOT_READY) {\n\t\tdev_err(chip->card->dev, \"no codec detected!\\n\");\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_atiixp_chip_start(struct atiixp_modem *chip)\n{\n\tunsigned int reg;\n\n\t \n\treg = atiixp_read(chip, CMD);\n\treg |= ATI_REG_CMD_BURST_EN;\n\tif(!(reg & ATI_REG_CMD_MODEM_PRESENT))\n\t\treg |= ATI_REG_CMD_MODEM_PRESENT;\n\tatiixp_write(chip, CMD, reg);\n\n\t \n\tatiixp_write(chip, ISR, 0xffffffff);\n\t \n\tatiixp_write(chip, IER,\n\t\t     ATI_REG_IER_MODEM_STATUS_EN |\n\t\t     ATI_REG_IER_MODEM_IN_XRUN_EN |\n\t\t     ATI_REG_IER_MODEM_OUT1_XRUN_EN);\n\treturn 0;\n}\n\n\n \nstatic int snd_atiixp_chip_stop(struct atiixp_modem *chip)\n{\n\t \n\tatiixp_write(chip, ISR, atiixp_read(chip, ISR));\n\t \n\tatiixp_write(chip, IER, 0);\n\treturn 0;\n}\n\n\n \n\n \nstatic snd_pcm_uframes_t snd_atiixp_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct atiixp_dma *dma = runtime->private_data;\n\tunsigned int curptr;\n\tint timeout = 1000;\n\n\twhile (timeout--) {\n\t\tcurptr = readl(chip->remap_addr + dma->ops->dt_cur);\n\t\tif (curptr < dma->buf_addr)\n\t\t\tcontinue;\n\t\tcurptr -= dma->buf_addr;\n\t\tif (curptr >= dma->buf_bytes)\n\t\t\tcontinue;\n\t\treturn bytes_to_frames(runtime, curptr);\n\t}\n\tdev_dbg(chip->card->dev, \"invalid DMA pointer read 0x%x (buf=%x)\\n\",\n\t\t   readl(chip->remap_addr + dma->ops->dt_cur), dma->buf_addr);\n\treturn 0;\n}\n\n \nstatic void snd_atiixp_xrun_dma(struct atiixp_modem *chip,\n\t\t\t\tstruct atiixp_dma *dma)\n{\n\tif (! dma->substream || ! dma->running)\n\t\treturn;\n\tdev_dbg(chip->card->dev, \"XRUN detected (DMA %d)\\n\", dma->ops->type);\n\tsnd_pcm_stop_xrun(dma->substream);\n}\n\n \nstatic void snd_atiixp_update_dma(struct atiixp_modem *chip,\n\t\t\t\t  struct atiixp_dma *dma)\n{\n\tif (! dma->substream || ! dma->running)\n\t\treturn;\n\tsnd_pcm_period_elapsed(dma->substream);\n}\n\n \n \nstatic void snd_atiixp_check_bus_busy(struct atiixp_modem *chip)\n{\n\tunsigned int bus_busy;\n\tif (atiixp_read(chip, CMD) & (ATI_REG_CMD_MODEM_SEND1_EN |\n\t\t\t\t      ATI_REG_CMD_MODEM_RECEIVE_EN))\n\t\tbus_busy = ATI_REG_IER_MODEM_SET_BUS_BUSY;\n\telse\n\t\tbus_busy = 0;\n\tatiixp_update(chip, IER, ATI_REG_IER_MODEM_SET_BUS_BUSY, bus_busy);\n}\n\n \nstatic int snd_atiixp_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\tint err = 0;\n\n\tif (snd_BUG_ON(!dma->ops->enable_transfer ||\n\t\t       !dma->ops->flush_dma))\n\t\treturn -EINVAL;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch(cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdma->ops->enable_transfer(chip, 1);\n\t\tdma->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdma->ops->enable_transfer(chip, 0);\n\t\tdma->running = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (! err) {\n\tsnd_atiixp_check_bus_busy(chip);\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tdma->ops->flush_dma(chip);\n\t\tsnd_atiixp_check_bus_busy(chip);\n\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn err;\n}\n\n\n \n\n \nstatic void atiixp_out_flush_dma(struct atiixp_modem *chip)\n{\n\tatiixp_write(chip, MODEM_FIFO_FLUSH, ATI_REG_MODEM_FIFO_OUT1_FLUSH);\n}\n\n \nstatic void atiixp_out_enable_dma(struct atiixp_modem *chip, int on)\n{\n\tunsigned int data;\n\tdata = atiixp_read(chip, CMD);\n\tif (on) {\n\t\tif (data & ATI_REG_CMD_MODEM_OUT_DMA1_EN)\n\t\t\treturn;\n\t\tatiixp_out_flush_dma(chip);\n\t\tdata |= ATI_REG_CMD_MODEM_OUT_DMA1_EN;\n\t} else\n\t\tdata &= ~ATI_REG_CMD_MODEM_OUT_DMA1_EN;\n\tatiixp_write(chip, CMD, data);\n}\n\n \nstatic void atiixp_out_enable_transfer(struct atiixp_modem *chip, int on)\n{\n\tatiixp_update(chip, CMD, ATI_REG_CMD_MODEM_SEND1_EN,\n\t\t      on ? ATI_REG_CMD_MODEM_SEND1_EN : 0);\n}\n\n \nstatic void atiixp_in_enable_dma(struct atiixp_modem *chip, int on)\n{\n\tatiixp_update(chip, CMD, ATI_REG_CMD_MODEM_IN_DMA_EN,\n\t\t      on ? ATI_REG_CMD_MODEM_IN_DMA_EN : 0);\n}\n\n \nstatic void atiixp_in_enable_transfer(struct atiixp_modem *chip, int on)\n{\n\tif (on) {\n\t\tunsigned int data = atiixp_read(chip, CMD);\n\t\tif (! (data & ATI_REG_CMD_MODEM_RECEIVE_EN)) {\n\t\t\tdata |= ATI_REG_CMD_MODEM_RECEIVE_EN;\n\t\t\tatiixp_write(chip, CMD, data);\n\t\t}\n\t} else\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_MODEM_RECEIVE_EN, 0);\n}\n\n \nstatic void atiixp_in_flush_dma(struct atiixp_modem *chip)\n{\n\tatiixp_write(chip, MODEM_FIFO_FLUSH, ATI_REG_MODEM_FIFO_IN_FLUSH);\n}\n\n \nstatic int snd_atiixp_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tunsigned int data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\t \n\tdata = atiixp_read(chip, MODEM_OUT_FIFO);\n\tdata &= ~ATI_REG_MODEM_OUT1_DMA_THRESHOLD_MASK;\n\tdata |= 0x04 << ATI_REG_MODEM_OUT1_DMA_THRESHOLD_SHIFT;\n\tatiixp_write(chip, MODEM_OUT_FIFO, data);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_capture_prepare(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *hw_params)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\tint err;\n\tint i;\n\n\tdma->buf_addr = substream->runtime->dma_addr;\n\tdma->buf_bytes = params_buffer_bytes(hw_params);\n\n\terr = atiixp_build_dma_packets(chip, dma, substream,\n\t\t\t\t       params_periods(hw_params),\n\t\t\t\t       params_period_bytes(hw_params));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < NUM_ATI_CODECS; i++) {\n\t\tif (! chip->ac97[i])\n\t\t\tcontinue;\n\t\tsnd_ac97_write(chip->ac97[i], AC97_LINE1_RATE, params_rate(hw_params));\n\t\tsnd_ac97_write(chip->ac97[i], AC97_LINE1_LEVEL, 0);\n\t}\n\n\treturn err;\n}\n\nstatic int snd_atiixp_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\n\tatiixp_clear_dma_packets(chip, dma, substream);\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_hardware snd_atiixp_pcm_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\t(SNDRV_PCM_RATE_8000 |\n\t\t\t\t SNDRV_PCM_RATE_16000 |\n\t\t\t\t SNDRV_PCM_RATE_KNOT),\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t16000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t256 * 1024,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t128 * 1024,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tATI_MAX_DESCRIPTORS,\n};\n\nstatic int snd_atiixp_pcm_open(struct snd_pcm_substream *substream,\n\t\t\t       struct atiixp_dma *dma, int pcm_type)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tstatic const unsigned int rates[] = { 8000,  9600, 12000, 16000 };\n\tstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t\t.count = ARRAY_SIZE(rates),\n\t\t.list = rates,\n\t\t.mask = 0,\n\t};\n\n\tif (snd_BUG_ON(!dma->ops || !dma->ops->enable_dma))\n\t\treturn -EINVAL;\n\n\tif (dma->opened)\n\t\treturn -EBUSY;\n\tdma->substream = substream;\n\truntime->hw = snd_atiixp_pcm_hw;\n\tdma->ac97_pcm_type = pcm_type;\n\terr = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t &hw_constraints_rates);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\truntime->private_data = dma;\n\n\t \n\tspin_lock_irq(&chip->reg_lock);\n\tdma->ops->enable_dma(chip, 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\tdma->opened = 1;\n\n\treturn 0;\n}\n\nstatic int snd_atiixp_pcm_close(struct snd_pcm_substream *substream,\n\t\t\t\tstruct atiixp_dma *dma)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\t \n\tif (snd_BUG_ON(!dma->ops || !dma->ops->enable_dma))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&chip->reg_lock);\n\tdma->ops->enable_dma(chip, 0);\n\tspin_unlock_irq(&chip->reg_lock);\n\tdma->substream = NULL;\n\tdma->opened = 0;\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\tmutex_lock(&chip->open_mutex);\n\terr = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 0);\n\tmutex_unlock(&chip->open_mutex);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_atiixp_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\tmutex_lock(&chip->open_mutex);\n\terr = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);\n\tmutex_unlock(&chip->open_mutex);\n\treturn err;\n}\n\nstatic int snd_atiixp_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\treturn snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE], 1);\n}\n\nstatic int snd_atiixp_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp_modem *chip = snd_pcm_substream_chip(substream);\n\treturn snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_CAPTURE]);\n}\n\n\n \nstatic const struct snd_pcm_ops snd_atiixp_playback_ops = {\n\t.open =\t\tsnd_atiixp_playback_open,\n\t.close =\tsnd_atiixp_playback_close,\n\t.hw_params =\tsnd_atiixp_pcm_hw_params,\n\t.hw_free =\tsnd_atiixp_pcm_hw_free,\n\t.prepare =\tsnd_atiixp_playback_prepare,\n\t.trigger =\tsnd_atiixp_pcm_trigger,\n\t.pointer =\tsnd_atiixp_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_atiixp_capture_ops = {\n\t.open =\t\tsnd_atiixp_capture_open,\n\t.close =\tsnd_atiixp_capture_close,\n\t.hw_params =\tsnd_atiixp_pcm_hw_params,\n\t.hw_free =\tsnd_atiixp_pcm_hw_free,\n\t.prepare =\tsnd_atiixp_capture_prepare,\n\t.trigger =\tsnd_atiixp_pcm_trigger,\n\t.pointer =\tsnd_atiixp_pcm_pointer,\n};\n\nstatic const struct atiixp_dma_ops snd_atiixp_playback_dma_ops = {\n\t.type = ATI_DMA_PLAYBACK,\n\t.llp_offset = ATI_REG_MODEM_OUT_DMA1_LINKPTR,\n\t.dt_cur = ATI_REG_MODEM_OUT_DMA1_DT_CUR,\n\t.enable_dma = atiixp_out_enable_dma,\n\t.enable_transfer = atiixp_out_enable_transfer,\n\t.flush_dma = atiixp_out_flush_dma,\n};\n\t\nstatic const struct atiixp_dma_ops snd_atiixp_capture_dma_ops = {\n\t.type = ATI_DMA_CAPTURE,\n\t.llp_offset = ATI_REG_MODEM_IN_DMA_LINKPTR,\n\t.dt_cur = ATI_REG_MODEM_IN_DMA_DT_CUR,\n\t.enable_dma = atiixp_in_enable_dma,\n\t.enable_transfer = atiixp_in_enable_transfer,\n\t.flush_dma = atiixp_in_flush_dma,\n};\n\nstatic int snd_atiixp_pcm_new(struct atiixp_modem *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\t \n\tchip->dmas[ATI_DMA_PLAYBACK].ops = &snd_atiixp_playback_dma_ops;\n\tchip->dmas[ATI_DMA_CAPTURE].ops = &snd_atiixp_capture_dma_ops;\n\n\t \n\terr = snd_pcm_new(chip->card, \"ATI IXP MC97\", ATI_PCMDEV_ANALOG, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_atiixp_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_atiixp_capture_ops);\n\tpcm->dev_class = SNDRV_PCM_CLASS_MODEM;\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"ATI IXP MC97\");\n\tchip->pcmdevs[ATI_PCMDEV_ANALOG] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\n\n\n \nstatic irqreturn_t snd_atiixp_interrupt(int irq, void *dev_id)\n{\n\tstruct atiixp_modem *chip = dev_id;\n\tunsigned int status;\n\n\tstatus = atiixp_read(chip, ISR);\n\n\tif (! status)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & ATI_REG_ISR_MODEM_OUT1_XRUN)\n\t\tsnd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_PLAYBACK]);\n\telse if (status & ATI_REG_ISR_MODEM_OUT1_STATUS)\n\t\tsnd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_PLAYBACK]);\n\tif (status & ATI_REG_ISR_MODEM_IN_XRUN)\n\t\tsnd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_CAPTURE]);\n\telse if (status & ATI_REG_ISR_MODEM_IN_STATUS)\n\t\tsnd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_CAPTURE]);\n\n\t \n\tif (status & CODEC_CHECK_BITS) {\n\t\tunsigned int detected;\n\t\tdetected = status & CODEC_CHECK_BITS;\n\t\tspin_lock(&chip->reg_lock);\n\t\tchip->codec_not_ready_bits |= detected;\n\t\tatiixp_update(chip, IER, detected, 0);  \n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\n\t \n\tatiixp_write(chip, ISR, status);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic int snd_atiixp_mixer_new(struct atiixp_modem *chip, int clock)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint i, err;\n\tint codec_count;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_atiixp_ac97_write,\n\t\t.read = snd_atiixp_ac97_read,\n\t};\n\tstatic const unsigned int codec_skip[NUM_ATI_CODECS] = {\n\t\tATI_REG_ISR_CODEC0_NOT_READY,\n\t\tATI_REG_ISR_CODEC1_NOT_READY,\n\t\tATI_REG_ISR_CODEC2_NOT_READY,\n\t};\n\n\tif (snd_atiixp_codec_detect(chip) < 0)\n\t\treturn -ENXIO;\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\tpbus->clock = clock;\n\tchip->ac97_bus = pbus;\n\n\tcodec_count = 0;\n\tfor (i = 0; i < NUM_ATI_CODECS; i++) {\n\t\tif (chip->codec_not_ready_bits & codec_skip[i])\n\t\t\tcontinue;\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = chip;\n\t\tac97.pci = chip->pci;\n\t\tac97.num = i;\n\t\tac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i]);\n\t\tif (err < 0) {\n\t\t\tchip->ac97[i] = NULL;  \n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"codec %d not available for modem\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tcodec_count++;\n\t}\n\n\tif (! codec_count) {\n\t\tdev_err(chip->card->dev, \"no codec available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int snd_atiixp_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct atiixp_modem *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tfor (i = 0; i < NUM_ATI_CODECS; i++)\n\t\tsnd_ac97_suspend(chip->ac97[i]);\n\tsnd_atiixp_aclink_down(chip);\n\tsnd_atiixp_chip_stop(chip);\n\treturn 0;\n}\n\nstatic int snd_atiixp_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct atiixp_modem *chip = card->private_data;\n\tint i;\n\n\tsnd_atiixp_aclink_reset(chip);\n\tsnd_atiixp_chip_start(chip);\n\n\tfor (i = 0; i < NUM_ATI_CODECS; i++)\n\t\tsnd_ac97_resume(chip->ac97[i]);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_atiixp_pm, snd_atiixp_suspend, snd_atiixp_resume);\n#define SND_ATIIXP_PM_OPS\t&snd_atiixp_pm\n#else\n#define SND_ATIIXP_PM_OPS\tNULL\n#endif  \n\n \n\nstatic void snd_atiixp_proc_read(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct atiixp_modem *chip = entry->private_data;\n\tint i;\n\n\tfor (i = 0; i < 256; i += 4)\n\t\tsnd_iprintf(buffer, \"%02x: %08x\\n\", i, readl(chip->remap_addr + i));\n}\n\nstatic void snd_atiixp_proc_init(struct atiixp_modem *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"atiixp-modem\", chip,\n\t\t\t     snd_atiixp_proc_read);\n}\n\n\n \n\nstatic void snd_atiixp_free(struct snd_card *card)\n{\n\tsnd_atiixp_chip_stop(card->private_data);\n}\n\n \nstatic int snd_atiixp_init(struct snd_card *card, struct pci_dev *pci)\n{\n\tstruct atiixp_modem *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\terr = pcim_iomap_regions(pci, 1 << 0, \"ATI IXP MC97\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->addr = pci_resource_start(pci, 0);\n\tchip->remap_addr = pcim_iomap_table(pci)[0];\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_atiixp_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_atiixp_free;\n\tpci_set_master(pci);\n\n\treturn 0;\n}\n\n\nstatic int __snd_atiixp_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct atiixp_modem *chip;\n\tint err;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tstrcpy(card->driver, \"ATIIXP-MODEM\");\n\tstrcpy(card->shortname, \"ATI IXP Modem\");\n\terr = snd_atiixp_init(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_atiixp_aclink_reset(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_atiixp_mixer_new(chip, ac97_clock);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_atiixp_pcm_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_atiixp_proc_init(chip);\n\n\tsnd_atiixp_chip_start(chip);\n\n\tsprintf(card->longname, \"%s rev %x at 0x%lx, irq %i\",\n\t\tcard->shortname, pci->revision, chip->addr, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_atiixp_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_atiixp_probe(pci, pci_id));\n}\n\nstatic struct pci_driver atiixp_modem_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_atiixp_ids,\n\t.probe = snd_atiixp_probe,\n\t.driver = {\n\t\t.pm = SND_ATIIXP_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(atiixp_modem_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}