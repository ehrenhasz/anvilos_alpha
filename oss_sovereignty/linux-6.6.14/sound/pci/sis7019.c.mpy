{
  "module_name": "sis7019.c",
  "hash_id": "f4d770ca9144e9ee6cd8b4c12319aa2c40809173a5c6a9109531face737a1ebe",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/sis7019.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include \"sis7019.h\"\n\nMODULE_AUTHOR(\"David Dillow <dave@thedillows.org>\");\nMODULE_DESCRIPTION(\"SiS7019\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic bool enable = 1;\nstatic int codecs = 1;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for SiS7019 Audio Accelerator.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for SiS7019 Audio Accelerator.\");\nmodule_param(enable, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable SiS7019 Audio Accelerator.\");\nmodule_param(codecs, int, 0444);\nMODULE_PARM_DESC(codecs, \"Set bit to indicate that codec number is expected to be present (default 1)\");\n\nstatic const struct pci_device_id snd_sis7019_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x7019) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_sis7019_ids);\n\n \nstruct voice {\n\tu16 flags;\n#define \tVOICE_IN_USE\t\t1\n#define \tVOICE_CAPTURE\t\t2\n#define \tVOICE_SSO_TIMING\t4\n#define \tVOICE_SYNC_TIMING\t8\n\tu16 sync_cso;\n\tu16 period_size;\n\tu16 buffer_size;\n\tu16 sync_period_size;\n\tu16 sync_buffer_size;\n\tu32 sso;\n\tu32 vperiod;\n\tstruct snd_pcm_substream *substream;\n\tstruct voice *timing;\n\tvoid __iomem *ctrl_base;\n\tvoid __iomem *wave_base;\n\tvoid __iomem *sync_base;\n\tint num;\n};\n\n \n#ifdef CONFIG_PM_SLEEP\n#define SIS_SUSPEND_PAGES\t4\n#else\n#define SIS_SUSPEND_PAGES\t1\n#endif\n\nstruct sis7019 {\n\tunsigned long ioport;\n\tvoid __iomem *ioaddr;\n\tint irq;\n\tint codecs_present;\n\n\tstruct pci_dev *pci;\n\tstruct snd_pcm *pcm;\n\tstruct snd_card *card;\n\tstruct snd_ac97 *ac97[3];\n\n\t \n\tstruct mutex ac97_mutex;\n\n\t \n\tspinlock_t voice_lock;\n\n\tstruct voice voices[64];\n\tstruct voice capture_voice;\n\n\t \n\tvoid *suspend_state[SIS_SUSPEND_PAGES];\n\n\tint silence_users;\n\tdma_addr_t silence_dma_addr;\n};\n\n \n#define SIS_PRIMARY_CODEC_PRESENT\t0x0001\n#define SIS_SECONDARY_CODEC_PRESENT\t0x0002\n#define SIS_TERTIARY_CODEC_PRESENT\t0x0004\n\n \nstatic const struct snd_pcm_hardware sis_playback_hw_info = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min = 4000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = (0xfff9 * 4),\n\t.period_bytes_min = 9,\n\t.period_bytes_max = (0xfff9 * 4),\n\t.periods_min = 1,\n\t.periods_max = (0xfff9 / 9),\n};\n\nstatic const struct snd_pcm_hardware sis_capture_hw_info = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 4000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = (0xfff9 * 4),\n\t.period_bytes_min = 9,\n\t.period_bytes_max = (0xfff9 * 4),\n\t.periods_min = 1,\n\t.periods_max = (0xfff9 / 9),\n};\n\nstatic void sis_update_sso(struct voice *voice, u16 period)\n{\n\tvoid __iomem *base = voice->ctrl_base;\n\n\tvoice->sso += period;\n\tif (voice->sso >= voice->buffer_size)\n\t\tvoice->sso -= voice->buffer_size;\n\n\t \n\tif (voice->sso < 8)\n\t\tvoice->sso = 8;\n\n\t \n\twritew(voice->sso & 0xffff, base + SIS_PLAY_DMA_SSO_ESO + 2);\n}\n\nstatic void sis_update_voice(struct voice *voice)\n{\n\tif (voice->flags & VOICE_SSO_TIMING) {\n\t\tsis_update_sso(voice, voice->period_size);\n\t} else if (voice->flags & VOICE_SYNC_TIMING) {\n\t\tint sync;\n\n\t\t \n\t\tif (voice->vperiod > voice->period_size) {\n\t\t\tvoice->vperiod -= voice->period_size;\n\t\t\tif (voice->vperiod < voice->period_size)\n\t\t\t\tsis_update_sso(voice, voice->vperiod);\n\t\t\telse\n\t\t\t\tsis_update_sso(voice, voice->period_size);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsync = voice->sync_cso;\n\t\tsync -= readw(voice->sync_base + SIS_CAPTURE_DMA_FORMAT_CSO);\n\t\tif (sync > (voice->sync_buffer_size / 2))\n\t\t\tsync -= voice->sync_buffer_size;\n\n\t\t \n\t\tif (sync > 0) {\n\t\t\tif (sync < 16)\n\t\t\t\tsync = 16;\n\t\t\tsis_update_sso(voice, sync);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (sync > -9)\n\t\t\tvoice->vperiod = voice->sync_period_size + 1;\n\t\telse\n\t\t\tvoice->vperiod = voice->sync_period_size + sync + 10;\n\n\t\tif (voice->vperiod < voice->buffer_size) {\n\t\t\tsis_update_sso(voice, voice->vperiod);\n\t\t\tvoice->vperiod = 0;\n\t\t} else\n\t\t\tsis_update_sso(voice, voice->period_size);\n\n\t\tsync = voice->sync_cso + voice->sync_period_size;\n\t\tif (sync >= voice->sync_buffer_size)\n\t\t\tsync -= voice->sync_buffer_size;\n\t\tvoice->sync_cso = sync;\n\t}\n\n\tsnd_pcm_period_elapsed(voice->substream);\n}\n\nstatic void sis_voice_irq(u32 status, struct voice *voice)\n{\n\tint bit;\n\n\twhile (status) {\n\t\tbit = __ffs(status);\n\t\tstatus >>= bit + 1;\n\t\tvoice += bit;\n\t\tsis_update_voice(voice);\n\t\tvoice++;\n\t}\n}\n\nstatic irqreturn_t sis_interrupt(int irq, void *dev)\n{\n\tstruct sis7019 *sis = dev;\n\tunsigned long io = sis->ioport;\n\tstruct voice *voice;\n\tu32 intr, status;\n\n\t \n\tintr = inl(io + SIS_GISR);\n\tintr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |\n\t\tSIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;\n\tif (!intr)\n\t\treturn IRQ_NONE;\n\n\tdo {\n\t\tstatus = inl(io + SIS_PISR_A);\n\t\tif (status) {\n\t\t\tsis_voice_irq(status, sis->voices);\n\t\t\toutl(status, io + SIS_PISR_A);\n\t\t}\n\n\t\tstatus = inl(io + SIS_PISR_B);\n\t\tif (status) {\n\t\t\tsis_voice_irq(status, &sis->voices[32]);\n\t\t\toutl(status, io + SIS_PISR_B);\n\t\t}\n\n\t\tstatus = inl(io + SIS_RISR);\n\t\tif (status) {\n\t\t\tvoice = &sis->capture_voice;\n\t\t\tif (!voice->timing)\n\t\t\t\tsnd_pcm_period_elapsed(voice->substream);\n\n\t\t\toutl(status, io + SIS_RISR);\n\t\t}\n\n\t\toutl(intr, io + SIS_GISR);\n\t\tintr = inl(io + SIS_GISR);\n\t\tintr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |\n\t\t\tSIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;\n\t} while (intr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 sis_rate_to_delta(unsigned int rate)\n{\n\tu32 delta;\n\n\t \n\tif (rate == 44100)\n\t\tdelta = 0xeb3;\n\telse if (rate == 8000)\n\t\tdelta = 0x2ab;\n\telse if (rate == 48000)\n\t\tdelta = 0x1000;\n\telse\n\t\tdelta = DIV_ROUND_CLOSEST(rate << 12, 48000) & 0x0000ffff;\n\treturn delta;\n}\n\nstatic void __sis_map_silence(struct sis7019 *sis)\n{\n\t \n\tif (!sis->silence_users)\n\t\tsis->silence_dma_addr = dma_map_single(&sis->pci->dev,\n\t\t\t\t\t\tsis->suspend_state[0],\n\t\t\t\t\t\t4096, DMA_TO_DEVICE);\n\tsis->silence_users++;\n}\n\nstatic void __sis_unmap_silence(struct sis7019 *sis)\n{\n\t \n\tsis->silence_users--;\n\tif (!sis->silence_users)\n\t\tdma_unmap_single(&sis->pci->dev, sis->silence_dma_addr, 4096,\n\t\t\t\t\tDMA_TO_DEVICE);\n}\n\nstatic void sis_free_voice(struct sis7019 *sis, struct voice *voice)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sis->voice_lock, flags);\n\tif (voice->timing) {\n\t\t__sis_unmap_silence(sis);\n\t\tvoice->timing->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING |\n\t\t\t\t\t\tVOICE_SYNC_TIMING);\n\t\tvoice->timing = NULL;\n\t}\n\tvoice->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING | VOICE_SYNC_TIMING);\n\tspin_unlock_irqrestore(&sis->voice_lock, flags);\n}\n\nstatic struct voice *__sis_alloc_playback_voice(struct sis7019 *sis)\n{\n\t \n\tstruct voice *voice;\n\tint i;\n\n\tfor (i = 0; i < 64; i++) {\n\t\tvoice = &sis->voices[i];\n\t\tif (voice->flags & VOICE_IN_USE)\n\t\t\tcontinue;\n\t\tvoice->flags |= VOICE_IN_USE;\n\t\tgoto found_one;\n\t}\n\tvoice = NULL;\n\nfound_one:\n\treturn voice;\n}\n\nstatic struct voice *sis_alloc_playback_voice(struct sis7019 *sis)\n{\n\tstruct voice *voice;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sis->voice_lock, flags);\n\tvoice = __sis_alloc_playback_voice(sis);\n\tspin_unlock_irqrestore(&sis->voice_lock, flags);\n\n\treturn voice;\n}\n\nstatic int sis_alloc_timing_voice(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = runtime->private_data;\n\tunsigned int period_size, buffer_size;\n\tunsigned long flags;\n\tint needed;\n\n\t \n\tperiod_size = params_period_size(hw_params);\n\tbuffer_size = params_buffer_size(hw_params);\n\tneeded = (period_size != buffer_size &&\n\t\t\tperiod_size != (buffer_size / 2));\n\n\tif (needed && !voice->timing) {\n\t\tspin_lock_irqsave(&sis->voice_lock, flags);\n\t\tvoice->timing = __sis_alloc_playback_voice(sis);\n\t\tif (voice->timing)\n\t\t\t__sis_map_silence(sis);\n\t\tspin_unlock_irqrestore(&sis->voice_lock, flags);\n\t\tif (!voice->timing)\n\t\t\treturn -ENOMEM;\n\t\tvoice->timing->substream = substream;\n\t} else if (!needed && voice->timing) {\n\t\tsis_free_voice(sis, voice);\n\t\tvoice->timing = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sis_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice;\n\n\tvoice = sis_alloc_playback_voice(sis);\n\tif (!voice)\n\t\treturn -EAGAIN;\n\n\tvoice->substream = substream;\n\truntime->private_data = voice;\n\truntime->hw = sis_playback_hw_info;\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t\t9, 0xfff9);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t\t9, 0xfff9);\n\tsnd_pcm_set_sync(substream);\n\treturn 0;\n}\n\nstatic int sis_substream_close(struct snd_pcm_substream *substream)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = runtime->private_data;\n\n\tsis_free_voice(sis, voice);\n\treturn 0;\n}\n\nstatic int sis_pcm_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = runtime->private_data;\n\tvoid __iomem *ctrl_base = voice->ctrl_base;\n\tvoid __iomem *wave_base = voice->wave_base;\n\tu32 format, dma_addr, control, sso_eso, delta, reg;\n\tu16 leo;\n\n\t \n\tformat = 0;\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tformat |= SIS_PLAY_DMA_FORMAT_8BIT;\n\tif (!snd_pcm_format_signed(runtime->format))\n\t\tformat |= SIS_PLAY_DMA_FORMAT_UNSIGNED;\n\tif (runtime->channels == 1)\n\t\tformat |= SIS_PLAY_DMA_FORMAT_MONO;\n\n\t \n\tdma_addr = runtime->dma_addr;\n\tleo = runtime->buffer_size - 1;\n\tcontrol = leo | SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_LEO;\n\tsso_eso = leo;\n\n\tif (runtime->period_size == (runtime->buffer_size / 2)) {\n\t\tcontrol |= SIS_PLAY_DMA_INTR_AT_MLP;\n\t} else if (runtime->period_size != runtime->buffer_size) {\n\t\tvoice->flags |= VOICE_SSO_TIMING;\n\t\tvoice->sso = runtime->period_size - 1;\n\t\tvoice->period_size = runtime->period_size;\n\t\tvoice->buffer_size = runtime->buffer_size;\n\n\t\tcontrol &= ~SIS_PLAY_DMA_INTR_AT_LEO;\n\t\tcontrol |= SIS_PLAY_DMA_INTR_AT_SSO;\n\t\tsso_eso |= (runtime->period_size - 1) << 16;\n\t}\n\n\tdelta = sis_rate_to_delta(runtime->rate);\n\n\t \n\twritel(format, ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);\n\twritel(dma_addr, ctrl_base + SIS_PLAY_DMA_BASE);\n\twritel(control, ctrl_base + SIS_PLAY_DMA_CONTROL);\n\twritel(sso_eso, ctrl_base + SIS_PLAY_DMA_SSO_ESO);\n\n\tfor (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)\n\t\twritel(0, wave_base + reg);\n\n\twritel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);\n\twritel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);\n\twritel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |\n\t\t\tSIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |\n\t\t\tSIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,\n\t\t\twave_base + SIS_WAVE_CHANNEL_CONTROL);\n\n\t \n\treadl(ctrl_base);\n\n\treturn 0;\n}\n\nstatic int sis_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tunsigned long io = sis->ioport;\n\tstruct snd_pcm_substream *s;\n\tstruct voice *voice;\n\tvoid *chip;\n\tint starting;\n\tu32 record = 0;\n\tu32 play[2] = { 0, 0 };\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tstarting = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tstarting = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t \n\t\tchip = snd_pcm_substream_chip(s);\n\t\tif (chip != sis)\n\t\t\tcontinue;\n\n\t\tvoice = s->runtime->private_data;\n\t\tif (voice->flags & VOICE_CAPTURE) {\n\t\t\trecord |= 1 << voice->num;\n\t\t\tvoice = voice->timing;\n\t\t}\n\n\t\t \n\t\tif (voice)\n\t\t\tplay[voice->num / 32] |= 1 << (voice->num & 0x1f);\n\n\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\n\tif (starting) {\n\t\tif (record)\n\t\t\toutl(record, io + SIS_RECORD_START_REG);\n\t\tif (play[0])\n\t\t\toutl(play[0], io + SIS_PLAY_START_A_REG);\n\t\tif (play[1])\n\t\t\toutl(play[1], io + SIS_PLAY_START_B_REG);\n\t} else {\n\t\tif (record)\n\t\t\toutl(record, io + SIS_RECORD_STOP_REG);\n\t\tif (play[0])\n\t\t\toutl(play[0], io + SIS_PLAY_STOP_A_REG);\n\t\tif (play[1])\n\t\t\toutl(play[1], io + SIS_PLAY_STOP_B_REG);\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t sis_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = runtime->private_data;\n\tu32 cso;\n\n\tcso = readl(voice->ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);\n\tcso &= 0xffff;\n\treturn cso;\n}\n\nstatic int sis_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = &sis->capture_voice;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&sis->voice_lock, flags);\n\tif (voice->flags & VOICE_IN_USE)\n\t\tvoice = NULL;\n\telse\n\t\tvoice->flags |= VOICE_IN_USE;\n\tspin_unlock_irqrestore(&sis->voice_lock, flags);\n\n\tif (!voice)\n\t\treturn -EAGAIN;\n\n\tvoice->substream = substream;\n\truntime->private_data = voice;\n\truntime->hw = sis_capture_hw_info;\n\truntime->hw.rates = sis->ac97[0]->rates[AC97_RATES_ADC];\n\tsnd_pcm_limit_hw_rates(runtime);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t\t9, 0xfff9);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t\t9, 0xfff9);\n\tsnd_pcm_set_sync(substream);\n\treturn 0;\n}\n\nstatic int sis_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tint rc;\n\n\trc = snd_ac97_set_rate(sis->ac97[0], AC97_PCM_LR_ADC_RATE,\n\t\t\t\t\t\tparams_rate(hw_params));\n\tif (rc)\n\t\tgoto out;\n\n\trc = sis_alloc_timing_voice(substream, hw_params);\n\nout:\n\treturn rc;\n}\n\nstatic void sis_prepare_timing_voice(struct voice *voice,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct sis7019 *sis = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *timing = voice->timing;\n\tvoid __iomem *play_base = timing->ctrl_base;\n\tvoid __iomem *wave_base = timing->wave_base;\n\tu16 buffer_size, period_size;\n\tu32 format, control, sso_eso, delta;\n\tu32 vperiod, sso, reg;\n\n\t \n\tbuffer_size = 4096 / runtime->channels;\n\tbuffer_size /= snd_pcm_format_size(runtime->format, 1);\n\tperiod_size = buffer_size;\n\n\t \n\tvperiod = runtime->period_size + 12;\n\tif (vperiod > period_size) {\n\t\tu16 tail = vperiod % period_size;\n\t\tu16 quarter_period = period_size / 4;\n\n\t\tif (tail && tail < quarter_period) {\n\t\t\tu16 loops = vperiod / period_size;\n\n\t\t\ttail = quarter_period - tail;\n\t\t\ttail += loops - 1;\n\t\t\ttail /= loops;\n\t\t\tperiod_size -= tail;\n\t\t}\n\n\t\tsso = period_size - 1;\n\t} else {\n\t\t \n\t\tperiod_size = runtime->period_size;\n\t\tsso = vperiod - 1;\n\t\tvperiod = 0;\n\t}\n\n\t \n\ttiming->flags |= VOICE_SYNC_TIMING;\n\ttiming->sync_base = voice->ctrl_base;\n\ttiming->sync_cso = runtime->period_size;\n\ttiming->sync_period_size = runtime->period_size;\n\ttiming->sync_buffer_size = runtime->buffer_size;\n\ttiming->period_size = period_size;\n\ttiming->buffer_size = buffer_size;\n\ttiming->sso = sso;\n\ttiming->vperiod = vperiod;\n\n\t \n\tformat = 0;\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tformat = SIS_CAPTURE_DMA_FORMAT_8BIT;\n\tif (runtime->channels == 1)\n\t\tformat |= SIS_CAPTURE_DMA_FORMAT_MONO;\n\n\tcontrol = timing->buffer_size - 1;\n\tcontrol |= SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_SSO;\n\tsso_eso = timing->buffer_size - 1;\n\tsso_eso |= timing->sso << 16;\n\n\tdelta = sis_rate_to_delta(runtime->rate);\n\n\t \n\twritel(format, play_base + SIS_PLAY_DMA_FORMAT_CSO);\n\twritel(sis->silence_dma_addr, play_base + SIS_PLAY_DMA_BASE);\n\twritel(control, play_base + SIS_PLAY_DMA_CONTROL);\n\twritel(sso_eso, play_base + SIS_PLAY_DMA_SSO_ESO);\n\n\tfor (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)\n\t\twritel(0, wave_base + reg);\n\n\twritel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);\n\twritel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);\n\twritel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |\n\t\t\tSIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |\n\t\t\tSIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,\n\t\t\twave_base + SIS_WAVE_CHANNEL_CONTROL);\n}\n\nstatic int sis_pcm_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct voice *voice = runtime->private_data;\n\tvoid __iomem *rec_base = voice->ctrl_base;\n\tu32 format, dma_addr, control;\n\tu16 leo;\n\n\t \n\tformat = 0;\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tformat = SIS_CAPTURE_DMA_FORMAT_8BIT;\n\tif (!snd_pcm_format_signed(runtime->format))\n\t\tformat |= SIS_CAPTURE_DMA_FORMAT_UNSIGNED;\n\tif (runtime->channels == 1)\n\t\tformat |= SIS_CAPTURE_DMA_FORMAT_MONO;\n\n\tdma_addr = runtime->dma_addr;\n\tleo = runtime->buffer_size - 1;\n\tcontrol = leo | SIS_CAPTURE_DMA_LOOP;\n\n\t \n\tif (voice->timing) {\n\t\tsis_prepare_timing_voice(voice, substream);\n\t} else {\n\t\tcontrol |= SIS_CAPTURE_DMA_INTR_AT_LEO;\n\t\tif (runtime->period_size != runtime->buffer_size)\n\t\t\tcontrol |= SIS_CAPTURE_DMA_INTR_AT_MLP;\n\t}\n\n\twritel(format, rec_base + SIS_CAPTURE_DMA_FORMAT_CSO);\n\twritel(dma_addr, rec_base + SIS_CAPTURE_DMA_BASE);\n\twritel(control, rec_base + SIS_CAPTURE_DMA_CONTROL);\n\n\t \n\treadl(rec_base);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops sis_playback_ops = {\n\t.open = sis_playback_open,\n\t.close = sis_substream_close,\n\t.prepare = sis_pcm_playback_prepare,\n\t.trigger = sis_pcm_trigger,\n\t.pointer = sis_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops sis_capture_ops = {\n\t.open = sis_capture_open,\n\t.close = sis_substream_close,\n\t.hw_params = sis_capture_hw_params,\n\t.prepare = sis_pcm_capture_prepare,\n\t.trigger = sis_pcm_trigger,\n\t.pointer = sis_pcm_pointer,\n};\n\nstatic int sis_pcm_create(struct sis7019 *sis)\n{\n\tstruct snd_pcm *pcm;\n\tint rc;\n\n\t \n\trc = snd_pcm_new(sis->card, \"SiS7019\", 0, 64, 1, &pcm);\n\tif (rc)\n\t\treturn rc;\n\n\tpcm->private_data = sis;\n\tstrcpy(pcm->name, \"SiS7019\");\n\tsis->pcm = pcm;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sis_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sis_capture_ops);\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &sis->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\nstatic unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)\n{\n\tunsigned long io = sis->ioport;\n\tunsigned short val = 0xffff;\n\tu16 status;\n\tu16 rdy;\n\tint count;\n\tstatic const u16 codec_ready[3] = {\n\t\tSIS_AC97_STATUS_CODEC_READY,\n\t\tSIS_AC97_STATUS_CODEC2_READY,\n\t\tSIS_AC97_STATUS_CODEC3_READY,\n\t};\n\n\trdy = codec_ready[codec];\n\n\n\t \n\tmutex_lock(&sis->ac97_mutex);\n\n\tcount = 0xffff;\n\twhile ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)\n\t\tudelay(1);\n\n\tif (!count)\n\t\tgoto timeout;\n\n\t \n\tcount = 0xffff;\n\tdo {\n\t\tstatus = inw(io + SIS_AC97_STATUS);\n\t\tif ((status & rdy) && !(status & SIS_AC97_STATUS_BUSY))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--count);\n\n\tif (!count)\n\t\tgoto timeout_sema;\n\n\t \n\toutl(cmd, io + SIS_AC97_CMD);\n\tudelay(10);\n\n\tcount = 0xffff;\n\twhile ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)\n\t\tudelay(1);\n\n\t \n\tval = inl(io + SIS_AC97_CMD) >> 16;\n\ntimeout_sema:\n\toutl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);\ntimeout:\n\tmutex_unlock(&sis->ac97_mutex);\n\n\tif (!count) {\n\t\tdev_err(&sis->pci->dev, \"ac97 codec %d timeout cmd 0x%08x\\n\",\n\t\t\t\t\tcodec, cmd);\n\t}\n\n\treturn val;\n}\n\nstatic void sis_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\tunsigned short val)\n{\n\tstatic const u32 cmd[3] = {\n\t\tSIS_AC97_CMD_CODEC_WRITE,\n\t\tSIS_AC97_CMD_CODEC2_WRITE,\n\t\tSIS_AC97_CMD_CODEC3_WRITE,\n\t};\n\tsis_ac97_rw(ac97->private_data, ac97->num,\n\t\t\t(val << 16) | (reg << 8) | cmd[ac97->num]);\n}\n\nstatic unsigned short sis_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstatic const u32 cmd[3] = {\n\t\tSIS_AC97_CMD_CODEC_READ,\n\t\tSIS_AC97_CMD_CODEC2_READ,\n\t\tSIS_AC97_CMD_CODEC3_READ,\n\t};\n\treturn sis_ac97_rw(ac97->private_data, ac97->num,\n\t\t\t\t\t(reg << 8) | cmd[ac97->num]);\n}\n\nstatic int sis_mixer_create(struct sis7019 *sis)\n{\n\tstruct snd_ac97_bus *bus;\n\tstruct snd_ac97_template ac97;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = sis_ac97_write,\n\t\t.read = sis_ac97_read,\n\t};\n\tint rc;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = sis;\n\n\trc = snd_ac97_bus(sis->card, 0, &ops, NULL, &bus);\n\tif (!rc && sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\n\t\trc = snd_ac97_mixer(bus, &ac97, &sis->ac97[0]);\n\tac97.num = 1;\n\tif (!rc && (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT))\n\t\trc = snd_ac97_mixer(bus, &ac97, &sis->ac97[1]);\n\tac97.num = 2;\n\tif (!rc && (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT))\n\t\trc = snd_ac97_mixer(bus, &ac97, &sis->ac97[2]);\n\n\t \n\treturn rc;\n}\n\nstatic void sis_chip_free(struct snd_card *card)\n{\n\tstruct sis7019 *sis = card->private_data;\n\n\t \n\toutl(SIS_GCR_SOFTWARE_RESET, sis->ioport + SIS_GCR);\n\tudelay(25);\n\toutl(0, sis->ioport + SIS_GCR);\n\toutl(0, sis->ioport + SIS_GIER);\n\n\t \n\tif (sis->irq >= 0)\n\t\tfree_irq(sis->irq, sis);\n}\n\nstatic int sis_chip_init(struct sis7019 *sis)\n{\n\tunsigned long io = sis->ioport;\n\tvoid __iomem *ioaddr = sis->ioaddr;\n\tunsigned long timeout;\n\tu16 status;\n\tint count;\n\tint i;\n\n\t \n\toutl(SIS_GCR_SOFTWARE_RESET, io + SIS_GCR);\n\tudelay(25);\n\toutl(0, io + SIS_GCR);\n\n\t \n\tcount = 0xffff;\n\twhile ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)\n\t\tudelay(1);\n\n\tif (!count)\n\t\treturn -EIO;\n\n\toutl(SIS_AC97_CMD_CODEC_COLD_RESET, io + SIS_AC97_CMD);\n\tudelay(250);\n\n\tcount = 0xffff;\n\twhile ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)\n\t\tudelay(1);\n\n\t \n\toutl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);\n\tif (!count)\n\t\treturn -EIO;\n\n\t \n\tsis->codecs_present = 0;\n\ttimeout = msecs_to_jiffies(500) + jiffies;\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tstatus = inl(io + SIS_AC97_STATUS);\n\t\tif (status & SIS_AC97_STATUS_CODEC_READY)\n\t\t\tsis->codecs_present |= SIS_PRIMARY_CODEC_PRESENT;\n\t\tif (status & SIS_AC97_STATUS_CODEC2_READY)\n\t\t\tsis->codecs_present |= SIS_SECONDARY_CODEC_PRESENT;\n\t\tif (status & SIS_AC97_STATUS_CODEC3_READY)\n\t\t\tsis->codecs_present |= SIS_TERTIARY_CODEC_PRESENT;\n\n\t\tif (sis->codecs_present == codecs)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\t \n\tif (!sis->codecs_present) {\n\t\tdev_err(&sis->pci->dev, \"could not find any codecs\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (sis->codecs_present != codecs) {\n\t\tdev_warn(&sis->pci->dev, \"missing codecs, found %0x, expected %0x\\n\",\n\t\t\t\t\t sis->codecs_present, codecs);\n\t}\n\n\t \n\toutl(SIS_AC97_CONF_AUDIO_ALIVE, io + SIS_AC97_CONF);\n\toutl(SIS_AC97_CONF_AUDIO_ALIVE | SIS_AC97_CONF_PCM_LR_ENABLE |\n\t\tSIS_AC97_CONF_PCM_CAP_MIC_ENABLE |\n\t\tSIS_AC97_CONF_PCM_CAP_LR_ENABLE |\n\t\tSIS_AC97_CONF_CODEC_VRA_ENABLE, io + SIS_AC97_CONF);\n\n\t \n\toutl(0, io + SIS_AC97_PSR);\n\n\t \n\toutl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);\n\n\t \n\toutl(0, io + SIS_PLAY_SYNC_GROUP_A);\n\toutl(0, io + SIS_PLAY_SYNC_GROUP_B);\n\toutl(0, io + SIS_PLAY_SYNC_GROUP_C);\n\toutl(0, io + SIS_PLAY_SYNC_GROUP_D);\n\toutl(0, io + SIS_MIXER_SYNC_GROUP);\n\n\tfor (i = 0; i < 64; i++) {\n\t\twritel(i, SIS_MIXER_START_ADDR(ioaddr, i));\n\t\twritel(SIS_MIXER_RIGHT_NO_ATTEN | SIS_MIXER_LEFT_NO_ATTEN |\n\t\t\t\tSIS_MIXER_DEST_0, SIS_MIXER_ADDR(ioaddr, i));\n\t}\n\n\t \n\toutl(0xffff0000, io + SIS_WEVCR);\n\n\t \n\toutl(0, io + SIS_WECCR);\n\n\t \n\toutl(SIS_GIER_AUDIO_PLAY_DMA_IRQ_ENABLE |\n\t\tSIS_GIER_AUDIO_RECORD_DMA_IRQ_ENABLE, io + SIS_GIER);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sis_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct sis7019 *sis = card->private_data;\n\tvoid __iomem *ioaddr = sis->ioaddr;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tif (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\n\t\tsnd_ac97_suspend(sis->ac97[0]);\n\tif (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)\n\t\tsnd_ac97_suspend(sis->ac97[1]);\n\tif (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)\n\t\tsnd_ac97_suspend(sis->ac97[2]);\n\n\t \n\tif (sis->irq >= 0) {\n\t\tfree_irq(sis->irq, sis);\n\t\tsis->irq = -1;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tmemcpy_fromio(sis->suspend_state[i], ioaddr, 4096);\n\t\tioaddr += 4096;\n\t}\n\n\treturn 0;\n}\n\nstatic int sis_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct sis7019 *sis = card->private_data;\n\tvoid __iomem *ioaddr = sis->ioaddr;\n\tint i;\n\n\tif (sis_chip_init(sis)) {\n\t\tdev_err(&pci->dev, \"unable to re-init controller\\n\");\n\t\tgoto error;\n\t}\n\n\tif (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, sis)) {\n\t\tdev_err(&pci->dev, \"unable to regain IRQ %d\\n\", pci->irq);\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tmemcpy_toio(ioaddr, sis->suspend_state[i], 4096);\n\t\tioaddr += 4096;\n\t}\n\n\tmemset(sis->suspend_state[0], 0, 4096);\n\n\tsis->irq = pci->irq;\n\n\tif (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)\n\t\tsnd_ac97_resume(sis->ac97[0]);\n\tif (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)\n\t\tsnd_ac97_resume(sis->ac97[1]);\n\tif (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)\n\t\tsnd_ac97_resume(sis->ac97[2]);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n\nerror:\n\tsnd_card_disconnect(card);\n\treturn -EIO;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sis_pm, sis_suspend, sis_resume);\n#define SIS_PM_OPS\t&sis_pm\n#else\n#define SIS_PM_OPS\tNULL\n#endif  \n\nstatic int sis_alloc_suspend(struct sis7019 *sis)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < SIS_SUSPEND_PAGES; i++) {\n\t\tsis->suspend_state[i] = devm_kmalloc(&sis->pci->dev, 4096,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!sis->suspend_state[i])\n\t\t\treturn -ENOMEM;\n\t}\n\tmemset(sis->suspend_state[0], 0, 4096);\n\n\treturn 0;\n}\n\nstatic int sis_chip_create(struct snd_card *card,\n\t\t\t   struct pci_dev *pci)\n{\n\tstruct sis7019 *sis = card->private_data;\n\tstruct voice *voice;\n\tint rc;\n\tint i;\n\n\trc = pcim_enable_device(pci);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dma_set_mask(&pci->dev, DMA_BIT_MASK(30));\n\tif (rc < 0) {\n\t\tdev_err(&pci->dev, \"architecture does not support 30-bit PCI busmaster DMA\");\n\t\treturn -ENXIO;\n\t}\n\n\tmutex_init(&sis->ac97_mutex);\n\tspin_lock_init(&sis->voice_lock);\n\tsis->card = card;\n\tsis->pci = pci;\n\tsis->irq = -1;\n\tsis->ioport = pci_resource_start(pci, 0);\n\n\trc = pci_request_regions(pci, \"SiS7019\");\n\tif (rc) {\n\t\tdev_err(&pci->dev, \"unable request regions\\n\");\n\t\treturn rc;\n\t}\n\n\tsis->ioaddr = devm_ioremap(&pci->dev, pci_resource_start(pci, 1), 0x4000);\n\tif (!sis->ioaddr) {\n\t\tdev_err(&pci->dev, \"unable to remap MMIO, aborting\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = sis_alloc_suspend(sis);\n\tif (rc < 0) {\n\t\tdev_err(&pci->dev, \"unable to allocate state storage\\n\");\n\t\treturn rc;\n\t}\n\n\trc = sis_chip_init(sis);\n\tif (rc)\n\t\treturn rc;\n\tcard->private_free = sis_chip_free;\n\n\trc = request_irq(pci->irq, sis_interrupt, IRQF_SHARED, KBUILD_MODNAME,\n\t\t\t sis);\n\tif (rc) {\n\t\tdev_err(&pci->dev, \"unable to allocate irq %d\\n\", sis->irq);\n\t\treturn rc;\n\t}\n\n\tsis->irq = pci->irq;\n\tcard->sync_irq = sis->irq;\n\tpci_set_master(pci);\n\n\tfor (i = 0; i < 64; i++) {\n\t\tvoice = &sis->voices[i];\n\t\tvoice->num = i;\n\t\tvoice->ctrl_base = SIS_PLAY_DMA_ADDR(sis->ioaddr, i);\n\t\tvoice->wave_base = SIS_WAVE_ADDR(sis->ioaddr, i);\n\t}\n\n\tvoice = &sis->capture_voice;\n\tvoice->flags = VOICE_CAPTURE;\n\tvoice->num = SIS_CAPTURE_CHAN_AC97_PCM_IN;\n\tvoice->ctrl_base = SIS_CAPTURE_DMA_ADDR(sis->ioaddr, voice->num);\n\n\treturn 0;\n}\n\nstatic int __snd_sis7019_probe(struct pci_dev *pci,\n\t\t\t       const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct sis7019 *sis;\n\tint rc;\n\n\tif (!enable)\n\t\treturn -ENOENT;\n\n\t \n\tcodecs &= SIS_PRIMARY_CODEC_PRESENT | SIS_SECONDARY_CODEC_PRESENT |\n\t\t  SIS_TERTIARY_CODEC_PRESENT;\n\tif (!codecs)\n\t\tcodecs = SIS_PRIMARY_CODEC_PRESENT;\n\n\trc = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t       sizeof(*sis), &card);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tstrcpy(card->driver, \"SiS7019\");\n\tstrcpy(card->shortname, \"SiS7019\");\n\trc = sis_chip_create(card, pci);\n\tif (rc)\n\t\treturn rc;\n\n\tsis = card->private_data;\n\n\trc = sis_mixer_create(sis);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sis_pcm_create(sis);\n\tif (rc)\n\t\treturn rc;\n\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t\"%s Audio Accelerator with %s at 0x%lx, irq %d\",\n\t\t\tcard->shortname, snd_ac97_get_short_name(sis->ac97[0]),\n\t\t\tsis->ioport, sis->irq);\n\n\trc = snd_card_register(card);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_sis7019_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_sis7019_probe(pci, pci_id));\n}\n\nstatic struct pci_driver sis7019_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_sis7019_ids,\n\t.probe = snd_sis7019_probe,\n\t.driver = {\n\t\t.pm = SIS_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(sis7019_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}