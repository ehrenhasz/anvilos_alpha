{
  "module_name": "nm256.c",
  "hash_id": "7858d8879a22e42ba72030dd8e072b2df43de3e6eed54b071d7350a98458c423",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/nm256/nm256.c",
  "human_readable_source": "\n \n  \n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n\n#define CARD_NAME \"NeoMagic 256AV/ZX\"\n#define DRIVER_NAME \"NM256\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"NeoMagic NM256AV/ZX\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int playback_bufsize = 16;\nstatic int capture_bufsize = 16;\nstatic bool force_ac97;\t\t\t \nstatic int buffer_top;\t\t\t \nstatic bool use_cache;\t\t\t \nstatic bool vaio_hack;\t\t\t \nstatic bool reset_workaround;\nstatic bool reset_workaround_2;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param(playback_bufsize, int, 0444);\nMODULE_PARM_DESC(playback_bufsize, \"DAC frame size in kB for \" CARD_NAME \" soundcard.\");\nmodule_param(capture_bufsize, int, 0444);\nMODULE_PARM_DESC(capture_bufsize, \"ADC frame size in kB for \" CARD_NAME \" soundcard.\");\nmodule_param(force_ac97, bool, 0444);\nMODULE_PARM_DESC(force_ac97, \"Force to use AC97 codec for \" CARD_NAME \" soundcard.\");\nmodule_param(buffer_top, int, 0444);\nMODULE_PARM_DESC(buffer_top, \"Set the top address of audio buffer for \" CARD_NAME \" soundcard.\");\nmodule_param(use_cache, bool, 0444);\nMODULE_PARM_DESC(use_cache, \"Enable the cache for coefficient table access.\");\nmodule_param(vaio_hack, bool, 0444);\nMODULE_PARM_DESC(vaio_hack, \"Enable workaround for Sony VAIO notebooks.\");\nmodule_param(reset_workaround, bool, 0444);\nMODULE_PARM_DESC(reset_workaround, \"Enable AC97 RESET workaround for some laptops.\");\nmodule_param(reset_workaround_2, bool, 0444);\nMODULE_PARM_DESC(reset_workaround_2, \"Enable extended AC97 RESET workaround for some other laptops.\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n\n\n \n\n \n#define NM_SIGNATURE 0x4e4d0000\n \n#define NM_SIG_MASK 0xffff0000\n\n \n#define NM_PORT2_SIZE 4096\n\n \n#define NM_MIXER_OFFSET 0x600\n\n \n#define NM_MAX_PLAYBACK_COEF_SIZE\t0x5000\n#define NM_MAX_RECORD_COEF_SIZE\t\t0x1260\n\n \n#define NM_INT_REG 0xa04\n \n#define NM_PLAYBACK_INT 0x40\n#define NM_RECORD_INT 0x100\n#define NM_MISC_INT_1 0x4000\n#define NM_MISC_INT_2 0x1\n#define NM_ACK_INT(chip, X) snd_nm256_writew(chip, NM_INT_REG, (X) << 1)\n\n \n#define NM_MIXER_STATUS_OFFSET 0xa04\n#define NM_MIXER_READY_MASK 0x0800\n#define NM_MIXER_PRESENCE 0xa06\n#define NM_PRESENCE_MASK 0x0050\n#define NM_PRESENCE_VALUE 0x0040\n\n \n#define NM2_PLAYBACK_INT 0x10000\n#define NM2_RECORD_INT 0x80000\n#define NM2_MISC_INT_1 0x8\n#define NM2_MISC_INT_2 0x2\n#define NM2_ACK_INT(chip, X) snd_nm256_writel(chip, NM_INT_REG, (X))\n\n \n#define NM2_MIXER_STATUS_OFFSET 0xa06\n#define NM2_MIXER_READY_MASK 0x0800\n\n \n#define NM_PLAYBACK_REG_OFFSET 0x0\n \n#define NM_RECORD_REG_OFFSET 0x200\n\n \n#define NM_RATE_REG_OFFSET 2\n\n \n#define NM_RATE_STEREO 1\n#define NM_RATE_BITS_16 2\n#define NM_RATE_MASK 0xf0\n\n \n#define NM_PLAYBACK_ENABLE_REG (NM_PLAYBACK_REG_OFFSET + 0x1)\n#define NM_PLAYBACK_ENABLE_FLAG 1\n#define NM_PLAYBACK_ONESHOT 2\n#define NM_PLAYBACK_FREERUN 4\n\n \n#define NM_AUDIO_MUTE_REG (NM_PLAYBACK_REG_OFFSET + 0x18)\n#define NM_AUDIO_MUTE_LEFT 0x8000\n#define NM_AUDIO_MUTE_RIGHT 0x0080\n\n \n#define NM_RECORD_ENABLE_REG (NM_RECORD_REG_OFFSET + 0)\n#define NM_RECORD_ENABLE_FLAG 1\n#define NM_RECORD_FREERUN 2\n\n \n#define NM_COEFF_START_OFFSET\t0x1c\n#define NM_COEFF_END_OFFSET\t0x20\n\n \n#define NM_RBUFFER_START (NM_RECORD_REG_OFFSET + 0x4)\n#define NM_RBUFFER_END   (NM_RECORD_REG_OFFSET + 0x10)\n#define NM_RBUFFER_WMARK (NM_RECORD_REG_OFFSET + 0xc)\n#define NM_RBUFFER_CURRP (NM_RECORD_REG_OFFSET + 0x8)\n\n#define NM_PBUFFER_START (NM_PLAYBACK_REG_OFFSET + 0x4)\n#define NM_PBUFFER_END   (NM_PLAYBACK_REG_OFFSET + 0x14)\n#define NM_PBUFFER_WMARK (NM_PLAYBACK_REG_OFFSET + 0xc)\n#define NM_PBUFFER_CURRP (NM_PLAYBACK_REG_OFFSET + 0x8)\n\nstruct nm256_stream {\n\n\tstruct nm256 *chip;\n\tstruct snd_pcm_substream *substream;\n\tint running;\n\tint suspended;\n\t\n\tu32 buf;\t \n\tint bufsize;\t \n\tvoid __iomem *bufptr;\t\t \n\tunsigned long bufptr_addr;\t \n\n\tint dma_size;\t\t \n\tint period_size;\t \n\tint periods;\t\t \n\tint shift;\t\t \n\tint cur_period;\t\t \n\n};\n\nstruct nm256 {\n\t\n\tstruct snd_card *card;\n\n\tvoid __iomem *cport;\t\t \n\tunsigned long cport_addr;\t \n\n\tvoid __iomem *buffer;\t\t \n\tunsigned long buffer_addr;\t \n\n\tu32 buffer_start;\t\t \n\tu32 buffer_end;\t\t\t \n\tu32 buffer_size;\t\t \n\n\tu32 all_coeff_buf;\t\t \n\tu32 coeff_buf[2];\t\t \n\n\tunsigned int coeffs_current: 1;\t \n\tunsigned int use_cache: 1;\t \n\tunsigned int reset_workaround: 1;  \n\tunsigned int reset_workaround_2: 1;  \n\tunsigned int in_resume: 1;\n\n\tint mixer_base;\t\t\t \n\tint mixer_status_offset;\t \n\tint mixer_status_mask;\t\t \n\n\tint irq;\n\tint irq_acks;\n\tirq_handler_t interrupt;\n\tint badintrcount;\t\t \n\tstruct mutex irq_mutex;\n\n\tstruct nm256_stream streams[2];\n\n\tstruct snd_ac97 *ac97;\n\tunsigned short *ac97_regs;  \n\n\tstruct snd_pcm *pcm;\n\n\tstruct pci_dev *pci;\n\n\tspinlock_t reg_lock;\n\n};\n\n\n \n#include \"nm256_coef.c\"\n\n\n \nstatic const struct pci_device_id snd_nm256_ids[] = {\n\t{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO), 0},\n\t{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO), 0},\n\t{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO), 0},\n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, snd_nm256_ids);\n\n\n \n\nstatic inline u8\nsnd_nm256_readb(struct nm256 *chip, int offset)\n{\n\treturn readb(chip->cport + offset);\n}\n\nstatic inline u16\nsnd_nm256_readw(struct nm256 *chip, int offset)\n{\n\treturn readw(chip->cport + offset);\n}\n\nstatic inline u32\nsnd_nm256_readl(struct nm256 *chip, int offset)\n{\n\treturn readl(chip->cport + offset);\n}\n\nstatic inline void\nsnd_nm256_writeb(struct nm256 *chip, int offset, u8 val)\n{\n\twriteb(val, chip->cport + offset);\n}\n\nstatic inline void\nsnd_nm256_writew(struct nm256 *chip, int offset, u16 val)\n{\n\twritew(val, chip->cport + offset);\n}\n\nstatic inline void\nsnd_nm256_writel(struct nm256 *chip, int offset, u32 val)\n{\n\twritel(val, chip->cport + offset);\n}\n\nstatic inline void\nsnd_nm256_write_buffer(struct nm256 *chip, const void *src, int offset, int size)\n{\n\toffset -= chip->buffer_start;\n#ifdef CONFIG_SND_DEBUG\n\tif (offset < 0 || offset >= chip->buffer_size) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"write_buffer invalid offset = %d size = %d\\n\",\n\t\t\t   offset, size);\n\t\treturn;\n\t}\n#endif\n\tmemcpy_toio(chip->buffer + offset, src, size);\n}\n\n \n\nstatic u16\nsnd_nm256_get_start_offset(int which)\n{\n\tu16 offset = 0;\n\twhile (which-- > 0)\n\t\toffset += coefficient_sizes[which];\n\treturn offset;\n}\n\nstatic void\nsnd_nm256_load_one_coefficient(struct nm256 *chip, int stream, u32 port, int which)\n{\n\tu32 coeff_buf = chip->coeff_buf[stream];\n\tu16 offset = snd_nm256_get_start_offset(which);\n\tu16 size = coefficient_sizes[which];\n\n\tsnd_nm256_write_buffer(chip, coefficients + offset, coeff_buf, size);\n\tsnd_nm256_writel(chip, port, coeff_buf);\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsize--;\n\tsnd_nm256_writel(chip, port + 4, coeff_buf + size);\n}\n\nstatic void\nsnd_nm256_load_coefficient(struct nm256 *chip, int stream, int number)\n{\n\t \n\tu32 poffset = (stream == SNDRV_PCM_STREAM_CAPTURE ?\n\t\t       NM_RECORD_ENABLE_REG : NM_PLAYBACK_ENABLE_REG);\n\tu32 addr = NM_COEFF_START_OFFSET;\n\n\taddr += (stream == SNDRV_PCM_STREAM_CAPTURE ?\n\t\t NM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);\n\n\tif (snd_nm256_readb(chip, poffset) & 1) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"NM256: Engine was enabled while loading coefficients!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnumber &= 7;\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tnumber += 8;\n\n\tif (! chip->use_cache) {\n\t\tsnd_nm256_load_one_coefficient(chip, stream, addr, number);\n\t\treturn;\n\t}\n\tif (! chip->coeffs_current) {\n\t\tsnd_nm256_write_buffer(chip, coefficients, chip->all_coeff_buf,\n\t\t\t\t       NM_TOTAL_COEFF_COUNT * 4);\n\t\tchip->coeffs_current = 1;\n\t} else {\n\t\tu32 base = chip->all_coeff_buf;\n\t\tu32 offset = snd_nm256_get_start_offset(number);\n\t\tu32 end_offset = offset + coefficient_sizes[number];\n\t\tsnd_nm256_writel(chip, addr, base + offset);\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tend_offset--;\n\t\tsnd_nm256_writel(chip, addr + 4, base + end_offset);\n\t}\n}\n\n\n \nstatic const unsigned int samplerates[8] = {\n\t8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000,\n};\nstatic const struct snd_pcm_hw_constraint_list constraints_rates = {\n\t.count = ARRAY_SIZE(samplerates), \n\t.list = samplerates,\n\t.mask = 0,\n};\n\n \nstatic int\nsnd_nm256_fixed_rate(unsigned int rate)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ARRAY_SIZE(samplerates); i++) {\n\t\tif (rate == samplerates[i])\n\t\t\treturn i;\n\t}\n\tsnd_BUG();\n\treturn 0;\n}\n\n \nstatic void\nsnd_nm256_set_format(struct nm256 *chip, struct nm256_stream *s,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint rate_index = snd_nm256_fixed_rate(runtime->rate);\n\tunsigned char ratebits = (rate_index << 4) & NM_RATE_MASK;\n\n\ts->shift = 0;\n\tif (snd_pcm_format_width(runtime->format) == 16) {\n\t\tratebits |= NM_RATE_BITS_16;\n\t\ts->shift++;\n\t}\n\tif (runtime->channels > 1) {\n\t\tratebits |= NM_RATE_STEREO;\n\t\ts->shift++;\n\t}\n\n\truntime->rate = samplerates[rate_index];\n\n\tswitch (substream->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tsnd_nm256_load_coefficient(chip, 0, rate_index);  \n\t\tsnd_nm256_writeb(chip,\n\t\t\t\t NM_PLAYBACK_REG_OFFSET + NM_RATE_REG_OFFSET,\n\t\t\t\t ratebits);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tsnd_nm256_load_coefficient(chip, 1, rate_index);  \n\t\tsnd_nm256_writeb(chip,\n\t\t\t\t NM_RECORD_REG_OFFSET + NM_RATE_REG_OFFSET,\n\t\t\t\t ratebits);\n\t\tbreak;\n\t}\n}\n\n \nstatic int snd_nm256_acquire_irq(struct nm256 *chip)\n{\n\tmutex_lock(&chip->irq_mutex);\n\tif (chip->irq < 0) {\n\t\tif (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,\n\t\t\t\tKBUILD_MODNAME, chip)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"unable to grab IRQ %d\\n\", chip->pci->irq);\n\t\t\tmutex_unlock(&chip->irq_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tchip->irq = chip->pci->irq;\n\t\tchip->card->sync_irq = chip->irq;\n\t}\n\tchip->irq_acks++;\n\tmutex_unlock(&chip->irq_mutex);\n\treturn 0;\n}\n\n \nstatic void snd_nm256_release_irq(struct nm256 *chip)\n{\n\tmutex_lock(&chip->irq_mutex);\n\tif (chip->irq_acks > 0)\n\t\tchip->irq_acks--;\n\tif (chip->irq_acks == 0 && chip->irq >= 0) {\n\t\tfree_irq(chip->irq, chip);\n\t\tchip->irq = -1;\n\t\tchip->card->sync_irq = -1;\n\t}\n\tmutex_unlock(&chip->irq_mutex);\n}\n\n \n\n \nstatic void snd_nm256_pcm_mark(struct nm256 *chip, struct nm256_stream *s, int reg)\n{\n\ts->cur_period++;\n\ts->cur_period %= s->periods;\n\tsnd_nm256_writel(chip, reg, s->buf + s->cur_period * s->period_size);\n}\n\n#define snd_nm256_playback_mark(chip, s) snd_nm256_pcm_mark(chip, s, NM_PBUFFER_WMARK)\n#define snd_nm256_capture_mark(chip, s)  snd_nm256_pcm_mark(chip, s, NM_RBUFFER_WMARK)\n\nstatic void\nsnd_nm256_playback_start(struct nm256 *chip, struct nm256_stream *s,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\t \n\tsnd_nm256_writel(chip, NM_PBUFFER_START, s->buf);\n\tsnd_nm256_writel(chip, NM_PBUFFER_END, s->buf + s->dma_size - (1 << s->shift));\n\tsnd_nm256_writel(chip, NM_PBUFFER_CURRP, s->buf);\n\tsnd_nm256_playback_mark(chip, s);\n\n\t \n\tsnd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG,\n\t\t\t NM_PLAYBACK_ENABLE_FLAG | NM_PLAYBACK_FREERUN);\n\t \n\tsnd_nm256_writew(chip, NM_AUDIO_MUTE_REG, 0x0);\n}\n\nstatic void\nsnd_nm256_capture_start(struct nm256 *chip, struct nm256_stream *s,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\t \n\tsnd_nm256_writel(chip, NM_RBUFFER_START, s->buf);\n\tsnd_nm256_writel(chip, NM_RBUFFER_END, s->buf + s->dma_size);\n\tsnd_nm256_writel(chip, NM_RBUFFER_CURRP, s->buf);\n\tsnd_nm256_capture_mark(chip, s);\n\n\t \n\tsnd_nm256_writeb(chip, NM_RECORD_ENABLE_REG,\n\t\t\t NM_RECORD_ENABLE_FLAG | NM_RECORD_FREERUN);\n}\n\n \nstatic void\nsnd_nm256_playback_stop(struct nm256 *chip)\n{\n\t \n\tsnd_nm256_writew(chip, NM_AUDIO_MUTE_REG,\n\t\t\t NM_AUDIO_MUTE_LEFT | NM_AUDIO_MUTE_RIGHT);\n\t \n\tsnd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG, 0);\n}\n\nstatic void\nsnd_nm256_capture_stop(struct nm256 *chip)\n{\n\t \n\tsnd_nm256_writeb(chip, NM_RECORD_ENABLE_REG, 0);\n}\n\nstatic int\nsnd_nm256_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\tstruct nm256_stream *s = substream->runtime->private_data;\n\tint err = 0;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn -ENXIO;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\ts->suspended = 0;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (! s->running) {\n\t\t\tsnd_nm256_playback_start(chip, s, substream);\n\t\t\ts->running = 1;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\ts->suspended = 1;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (s->running) {\n\t\t\tsnd_nm256_playback_stop(chip);\n\t\t\ts->running = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn err;\n}\n\nstatic int\nsnd_nm256_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\tstruct nm256_stream *s = substream->runtime->private_data;\n\tint err = 0;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn -ENXIO;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (! s->running) {\n\t\t\tsnd_nm256_capture_start(chip, s, substream);\n\t\t\ts->running = 1;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (s->running) {\n\t\t\tsnd_nm256_capture_stop(chip);\n\t\t\ts->running = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn err;\n}\n\n\n \nstatic int snd_nm256_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct nm256_stream *s = runtime->private_data;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn -ENXIO;\n\ts->dma_size = frames_to_bytes(runtime, substream->runtime->buffer_size);\n\ts->period_size = frames_to_bytes(runtime, substream->runtime->period_size);\n\ts->periods = substream->runtime->periods;\n\ts->cur_period = 0;\n\n\tspin_lock_irq(&chip->reg_lock);\n\ts->running = 0;\n\tsnd_nm256_set_format(chip, s, substream);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn 0;\n}\n\n\n \nstatic snd_pcm_uframes_t\nsnd_nm256_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\tstruct nm256_stream *s = substream->runtime->private_data;\n\tunsigned long curp;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn 0;\n\tcurp = snd_nm256_readl(chip, NM_PBUFFER_CURRP) - (unsigned long)s->buf;\n\tcurp %= s->dma_size;\n\treturn bytes_to_frames(substream->runtime, curp);\n}\n\nstatic snd_pcm_uframes_t\nsnd_nm256_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\tstruct nm256_stream *s = substream->runtime->private_data;\n\tunsigned long curp;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn 0;\n\tcurp = snd_nm256_readl(chip, NM_RBUFFER_CURRP) - (unsigned long)s->buf;\n\tcurp %= s->dma_size;\t\n\treturn bytes_to_frames(substream->runtime, curp);\n}\n\n \n \n#ifndef __i386__\n \nstatic int\nsnd_nm256_playback_silence(struct snd_pcm_substream *substream,\n\t\t\t   int channel, unsigned long pos, unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct nm256_stream *s = runtime->private_data;\n\n\tmemset_io(s->bufptr + pos, 0, count);\n\treturn 0;\n}\n\nstatic int\nsnd_nm256_playback_copy(struct snd_pcm_substream *substream,\n\t\t\tint channel, unsigned long pos,\n\t\t\tstruct iov_iter *src, unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct nm256_stream *s = runtime->private_data;\n\n\treturn copy_from_iter_toio(s->bufptr + pos, src, count);\n}\n\n \nstatic int\nsnd_nm256_capture_copy(struct snd_pcm_substream *substream,\n\t\t       int channel, unsigned long pos,\n\t\t       struct iov_iter *dst, unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct nm256_stream *s = runtime->private_data;\n\n\treturn copy_to_iter_fromio(dst, s->bufptr + pos, count);\n}\n\n#endif  \n\n\n \n\n \nstatic void\nsnd_nm256_playback_update(struct nm256 *chip)\n{\n\tstruct nm256_stream *s;\n\n\ts = &chip->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (s->running && s->substream) {\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(s->substream);\n\t\tspin_lock(&chip->reg_lock);\n\t\tsnd_nm256_playback_mark(chip, s);\n\t}\n}\n\n \nstatic void\nsnd_nm256_capture_update(struct nm256 *chip)\n{\n\tstruct nm256_stream *s;\n\n\ts = &chip->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (s->running && s->substream) {\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(s->substream);\n\t\tspin_lock(&chip->reg_lock);\n\t\tsnd_nm256_capture_mark(chip, s);\n\t}\n}\n\n \nstatic const struct snd_pcm_hardware snd_nm256_playback =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP_IOMEM |SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t \n\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT  | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.buffer_bytes_max =\t128 * 1024,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t128 * 1024,\n};\n\nstatic const struct snd_pcm_hardware snd_nm256_capture =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP_IOMEM | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t \n\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT  | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.buffer_bytes_max =\t128 * 1024,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t128 * 1024,\n};\n\n\n \nstatic int snd_nm256_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *hw_params)\n{\n\t \n\tsubstream->runtime->dma_bytes = params_buffer_bytes(hw_params);\n\treturn 0;\n}\n\n \nstatic void snd_nm256_setup_stream(struct nm256 *chip, struct nm256_stream *s,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   const struct snd_pcm_hardware *hw_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\ts->running = 0;\n\truntime->hw = *hw_ptr;\n\truntime->hw.buffer_bytes_max = s->bufsize;\n\truntime->hw.period_bytes_max = s->bufsize / 2;\n\truntime->dma_area = (void __force *) s->bufptr;\n\truntime->dma_addr = s->bufptr_addr;\n\truntime->dma_bytes = s->bufsize;\n\truntime->private_data = s;\n\ts->substream = substream;\n\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &constraints_rates);\n}\n\nstatic int\nsnd_nm256_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\n\tif (snd_nm256_acquire_irq(chip) < 0)\n\t\treturn -EBUSY;\n\tsnd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t       substream, &snd_nm256_playback);\n\treturn 0;\n}\n\nstatic int\nsnd_nm256_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\n\tif (snd_nm256_acquire_irq(chip) < 0)\n\t\treturn -EBUSY;\n\tsnd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_CAPTURE],\n\t\t\t       substream, &snd_nm256_capture);\n\treturn 0;\n}\n\n \nstatic int\nsnd_nm256_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_nm256_release_irq(chip);\n\treturn 0;\n}\n\n\nstatic int\nsnd_nm256_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct nm256 *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_nm256_release_irq(chip);\n\treturn 0;\n}\n\n \nstatic const struct snd_pcm_ops snd_nm256_playback_ops = {\n\t.open =\t\tsnd_nm256_playback_open,\n\t.close =\tsnd_nm256_playback_close,\n\t.hw_params =\tsnd_nm256_pcm_hw_params,\n\t.prepare =\tsnd_nm256_pcm_prepare,\n\t.trigger =\tsnd_nm256_playback_trigger,\n\t.pointer =\tsnd_nm256_playback_pointer,\n#ifndef __i386__\n\t.copy =\t\tsnd_nm256_playback_copy,\n\t.fill_silence =\tsnd_nm256_playback_silence,\n#endif\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_nm256_capture_ops = {\n\t.open =\t\tsnd_nm256_capture_open,\n\t.close =\tsnd_nm256_capture_close,\n\t.hw_params =\tsnd_nm256_pcm_hw_params,\n\t.prepare =\tsnd_nm256_pcm_prepare,\n\t.trigger =\tsnd_nm256_capture_trigger,\n\t.pointer =\tsnd_nm256_capture_pointer,\n#ifndef __i386__\n\t.copy =\t\tsnd_nm256_capture_copy,\n#endif\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic int\nsnd_nm256_pcm(struct nm256 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint i, err;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct nm256_stream *s = &chip->streams[i];\n\t\ts->bufptr = chip->buffer + (s->buf - chip->buffer_start);\n\t\ts->bufptr_addr = chip->buffer_addr + (s->buf - chip->buffer_start);\n\t}\n\n\terr = snd_pcm_new(chip->card, chip->card->driver, device,\n\t\t\t  1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_nm256_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_nm256_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n\n\n \nstatic void\nsnd_nm256_init_chip(struct nm256 *chip)\n{\n\t \n\tsnd_nm256_writeb(chip, 0x0, 0x11);\n\tsnd_nm256_writew(chip, 0x214, 0);\n\t \n\t\n\t\n}\n\n\nstatic irqreturn_t\nsnd_nm256_intr_check(struct nm256 *chip)\n{\n\tif (chip->badintrcount++ > 1000) {\n\t\t \n\t\tif (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)\n\t\t\tsnd_nm256_playback_stop(chip);\n\t\tif (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)\n\t\t\tsnd_nm256_capture_stop(chip);\n\t\tchip->badintrcount = 0;\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n \n\nstatic irqreturn_t\nsnd_nm256_interrupt(int irq, void *dev_id)\n{\n\tstruct nm256 *chip = dev_id;\n\tu16 status;\n\tu8 cbyte;\n\n\tstatus = snd_nm256_readw(chip, NM_INT_REG);\n\n\t \n\tif (status == 0)\n\t\treturn snd_nm256_intr_check(chip);\n\n\tchip->badintrcount = 0;\n\n\t \n\n\tspin_lock(&chip->reg_lock);\n\tif (status & NM_PLAYBACK_INT) {\n\t\tstatus &= ~NM_PLAYBACK_INT;\n\t\tNM_ACK_INT(chip, NM_PLAYBACK_INT);\n\t\tsnd_nm256_playback_update(chip);\n\t}\n\n\tif (status & NM_RECORD_INT) {\n\t\tstatus &= ~NM_RECORD_INT;\n\t\tNM_ACK_INT(chip, NM_RECORD_INT);\n\t\tsnd_nm256_capture_update(chip);\n\t}\n\n\tif (status & NM_MISC_INT_1) {\n\t\tstatus &= ~NM_MISC_INT_1;\n\t\tNM_ACK_INT(chip, NM_MISC_INT_1);\n\t\tdev_dbg(chip->card->dev, \"NM256: Got misc interrupt #1\\n\");\n\t\tsnd_nm256_writew(chip, NM_INT_REG, 0x8000);\n\t\tcbyte = snd_nm256_readb(chip, 0x400);\n\t\tsnd_nm256_writeb(chip, 0x400, cbyte | 2);\n\t}\n\n\tif (status & NM_MISC_INT_2) {\n\t\tstatus &= ~NM_MISC_INT_2;\n\t\tNM_ACK_INT(chip, NM_MISC_INT_2);\n\t\tdev_dbg(chip->card->dev, \"NM256: Got misc interrupt #2\\n\");\n\t\tcbyte = snd_nm256_readb(chip, 0x400);\n\t\tsnd_nm256_writeb(chip, 0x400, cbyte & ~2);\n\t}\n\n\t \n\tif (status) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"NM256: Fire in the hole! Unknown status 0x%x\\n\",\n\t\t\t   status);\n\t\t \n\t\tNM_ACK_INT(chip, status);\n\t}\n\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic irqreturn_t\nsnd_nm256_interrupt_zx(int irq, void *dev_id)\n{\n\tstruct nm256 *chip = dev_id;\n\tu32 status;\n\tu8 cbyte;\n\n\tstatus = snd_nm256_readl(chip, NM_INT_REG);\n\n\t \n\tif (status == 0)\n\t\treturn snd_nm256_intr_check(chip);\n\n\tchip->badintrcount = 0;\n\n\t \n\n\tspin_lock(&chip->reg_lock);\n\tif (status & NM2_PLAYBACK_INT) {\n\t\tstatus &= ~NM2_PLAYBACK_INT;\n\t\tNM2_ACK_INT(chip, NM2_PLAYBACK_INT);\n\t\tsnd_nm256_playback_update(chip);\n\t}\n\n\tif (status & NM2_RECORD_INT) {\n\t\tstatus &= ~NM2_RECORD_INT;\n\t\tNM2_ACK_INT(chip, NM2_RECORD_INT);\n\t\tsnd_nm256_capture_update(chip);\n\t}\n\n\tif (status & NM2_MISC_INT_1) {\n\t\tstatus &= ~NM2_MISC_INT_1;\n\t\tNM2_ACK_INT(chip, NM2_MISC_INT_1);\n\t\tdev_dbg(chip->card->dev, \"NM256: Got misc interrupt #1\\n\");\n\t\tcbyte = snd_nm256_readb(chip, 0x400);\n\t\tsnd_nm256_writeb(chip, 0x400, cbyte | 2);\n\t}\n\n\tif (status & NM2_MISC_INT_2) {\n\t\tstatus &= ~NM2_MISC_INT_2;\n\t\tNM2_ACK_INT(chip, NM2_MISC_INT_2);\n\t\tdev_dbg(chip->card->dev, \"NM256: Got misc interrupt #2\\n\");\n\t\tcbyte = snd_nm256_readb(chip, 0x400);\n\t\tsnd_nm256_writeb(chip, 0x400, cbyte & ~2);\n\t}\n\n\t \n\tif (status) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"NM256: Fire in the hole! Unknown status 0x%x\\n\",\n\t\t\t   status);\n\t\t \n\t\tNM2_ACK_INT(chip, status);\n\t}\n\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int\nsnd_nm256_ac97_ready(struct nm256 *chip)\n{\n\tint timeout = 10;\n\tu32 testaddr;\n\tu16 testb;\n\n\ttestaddr = chip->mixer_status_offset;\n\ttestb = chip->mixer_status_mask;\n\n\t \n\twhile (timeout-- > 0) {\n\t\tif ((snd_nm256_readw(chip, testaddr) & testb) == 0)\n\t\t\treturn 1;\n\t\tudelay(100);\n\t}\n\treturn 0;\n}\n\n \n\nstruct initialValues {\n\tunsigned short reg;\n\tunsigned short value;\n};\n\nstatic const struct initialValues nm256_ac97_init_val[] =\n{\n\t{ AC97_MASTER, \t\t0x8000 },\n\t{ AC97_HEADPHONE,\t0x8000 },\n\t{ AC97_MASTER_MONO,\t0x8000 },\n\t{ AC97_PC_BEEP,\t\t0x8000 },\n\t{ AC97_PHONE,\t\t0x8008 },\n\t{ AC97_MIC,\t\t0x8000 },\n\t{ AC97_LINE,\t\t0x8808 },\n\t{ AC97_CD,\t\t0x8808 },\n\t{ AC97_VIDEO,\t\t0x8808 },\n\t{ AC97_AUX,\t\t0x8808 },\n\t{ AC97_PCM,\t\t0x8808 },\n\t{ AC97_REC_SEL,\t\t0x0000 },\n\t{ AC97_REC_GAIN,\t0x0B0B },\n\t{ AC97_GENERAL_PURPOSE,\t0x0000 },\n\t{ AC97_3D_CONTROL,\t0x8000 }, \n\t{ AC97_VENDOR_ID1, \t0x8384 },\n\t{ AC97_VENDOR_ID2,\t0x7609 },\n};\n\nstatic int nm256_ac97_idx(unsigned short reg)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++)\n\t\tif (nm256_ac97_init_val[i].reg == reg)\n\t\t\treturn i;\n\treturn -1;\n}\n\n \nstatic unsigned short\nsnd_nm256_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct nm256 *chip = ac97->private_data;\n\tint idx = nm256_ac97_idx(reg);\n\n\tif (idx < 0)\n\t\treturn 0;\n\treturn chip->ac97_regs[idx];\n}\n\n \nstatic void\nsnd_nm256_ac97_write(struct snd_ac97 *ac97,\n\t\t     unsigned short reg, unsigned short val)\n{\n\tstruct nm256 *chip = ac97->private_data;\n\tint tries = 2;\n\tint idx = nm256_ac97_idx(reg);\n\tu32 base;\n\n\tif (idx < 0)\n\t\treturn;\n\n\tbase = chip->mixer_base;\n\n\tsnd_nm256_ac97_ready(chip);\n\n\t \n\twhile (tries-- > 0) {\n\t\tsnd_nm256_writew(chip, base + reg, val);\n\t\tmsleep(1);   \n\t\tif (snd_nm256_ac97_ready(chip)) {\n\t\t\t \n\t\t\tchip->ac97_regs[idx] = val;\n\t\t\treturn;\n\t\t}\n\t}\n\tdev_dbg(chip->card->dev, \"nm256: ac97 codec not ready..\\n\");\n}\n\n \nstatic const struct snd_ac97_res_table nm256_res_table[] = {\n\t{ AC97_MASTER, 0x1f1f },\n\t{ AC97_HEADPHONE, 0x1f1f },\n\t{ AC97_MASTER_MONO, 0x001f },\n\t{ AC97_PC_BEEP, 0x001f },\n\t{ AC97_PHONE, 0x001f },\n\t{ AC97_MIC, 0x001f },\n\t{ AC97_LINE, 0x1f1f },\n\t{ AC97_CD, 0x1f1f },\n\t{ AC97_VIDEO, 0x1f1f },\n\t{ AC97_AUX, 0x1f1f },\n\t{ AC97_PCM, 0x1f1f },\n\t{ AC97_REC_GAIN, 0x0f0f },\n\t{ }  \n};\n\n \nstatic void\nsnd_nm256_ac97_reset(struct snd_ac97 *ac97)\n{\n\tstruct nm256 *chip = ac97->private_data;\n\n\t \n\tsnd_nm256_writeb(chip, 0x6c0, 1);\n\tif (! chip->reset_workaround) {\n\t\t \n\t\tsnd_nm256_writeb(chip, 0x6cc, 0x87);\n\t}\n\tif (! chip->reset_workaround_2) {\n\t\t \n\t\tsnd_nm256_writeb(chip, 0x6cc, 0x80);\n\t\tsnd_nm256_writeb(chip, 0x6cc, 0x0);\n\t}\n\tif (! chip->in_resume) {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++) {\n\t\t\t \n\t\t\tsnd_nm256_ac97_write(ac97, nm256_ac97_init_val[i].reg,\n\t\t\t\t\t     nm256_ac97_init_val[i].value);\n\t\t}\n\t}\n}\n\n \nstatic int\nsnd_nm256_mixer(struct nm256 *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.reset = snd_nm256_ac97_reset,\n\t\t.write = snd_nm256_ac97_write,\n\t\t.read = snd_nm256_ac97_read,\n\t};\n\n\tchip->ac97_regs = devm_kcalloc(chip->card->dev,\n\t\t\t\t       ARRAY_SIZE(nm256_ac97_init_val),\n\t\t\t\t       sizeof(short), GFP_KERNEL);\n\tif (! chip->ac97_regs)\n\t\treturn -ENOMEM;\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.scaps = AC97_SCAP_AUDIO;  \n\tac97.private_data = chip;\n\tac97.res_table = nm256_res_table;\n\tpbus->no_vra = 1;\n\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\tif (! (chip->ac97->id & (0xf0000000))) {\n\t\t \n\t\tsprintf(chip->card->mixername, \"%s AC97\", chip->card->driver);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int\nsnd_nm256_peek_for_sig(struct nm256 *chip)\n{\n\t \n\tvoid __iomem *temp;\n\t \n\tunsigned long pointer_found = chip->buffer_end - 0x1400;\n\tu32 sig;\n\n\ttemp = ioremap(chip->buffer_addr + chip->buffer_end - 0x400, 16);\n\tif (temp == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Unable to scan for card signature in video RAM\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsig = readl(temp);\n\tif ((sig & NM_SIG_MASK) == NM_SIGNATURE) {\n\t\tu32 pointer = readl(temp + 4);\n\n\t\t \n\t\tif (pointer == 0xffffffff ||\n\t\t    pointer < chip->buffer_size ||\n\t\t    pointer > chip->buffer_end) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"invalid signature found: 0x%x\\n\", pointer);\n\t\t\tiounmap(temp);\n\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\tpointer_found = pointer;\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"found card signature in video RAM: 0x%x\\n\",\n\t\t\t       pointer);\n\t\t}\n\t}\n\n\tiounmap(temp);\n\tchip->buffer_end = pointer_found;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int nm256_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct nm256 *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\tchip->coeffs_current = 0;\n\treturn 0;\n}\n\nstatic int nm256_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct nm256 *chip = card->private_data;\n\tint i;\n\n\t \n\tchip->in_resume = 1;\n\n\tsnd_nm256_init_chip(chip);\n\n\t \n\tsnd_ac97_resume(chip->ac97);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct nm256_stream *s = &chip->streams[i];\n\t\tif (s->substream && s->suspended) {\n\t\t\tspin_lock_irq(&chip->reg_lock);\n\t\t\tsnd_nm256_set_format(chip, s, s->substream);\n\t\t\tspin_unlock_irq(&chip->reg_lock);\n\t\t}\n\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\tchip->in_resume = 0;\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(nm256_pm, nm256_suspend, nm256_resume);\n#define NM256_PM_OPS\t&nm256_pm\n#else\n#define NM256_PM_OPS\tNULL\n#endif  \n\nstatic void snd_nm256_free(struct snd_card *card)\n{\n\tstruct nm256 *chip = card->private_data;\n\n\tif (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)\n\t\tsnd_nm256_playback_stop(chip);\n\tif (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)\n\t\tsnd_nm256_capture_stop(chip);\n}\n\nstatic int\nsnd_nm256_create(struct snd_card *card, struct pci_dev *pci)\n{\n\tstruct nm256 *chip = card->private_data;\n\tint err, pval;\n\tu32 addr;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->use_cache = use_cache;\n\tspin_lock_init(&chip->reg_lock);\n\tchip->irq = -1;\n\tmutex_init(&chip->irq_mutex);\n\n\t \n\tchip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = playback_bufsize * 1024;\n\tchip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capture_bufsize * 1024;\n\n\t \n\n\tchip->buffer_addr = pci_resource_start(pci, 0);\n\tchip->cport_addr = pci_resource_start(pci, 1);\n\n\terr = pci_request_regions(pci, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\t \n\tchip->cport = devm_ioremap(&pci->dev, chip->cport_addr, NM_PORT2_SIZE);\n\tif (!chip->cport) {\n\t\tdev_err(card->dev, \"unable to map control port %lx\\n\",\n\t\t\tchip->cport_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!strcmp(card->driver, \"NM256AV\")) {\n\t\t \n\t\tpval = snd_nm256_readw(chip, NM_MIXER_PRESENCE);\n\t\tif ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {\n\t\t\tif (! force_ac97) {\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"no ac97 is found!\\n\");\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"force the driver to load by passing in the module parameter\\n\");\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\" force_ac97=1\\n\");\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"or try sb16, opl3sa2, or cs423x drivers instead.\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t}\n\t\tchip->buffer_end = 2560 * 1024;\n\t\tchip->interrupt = snd_nm256_interrupt;\n\t\tchip->mixer_status_offset = NM_MIXER_STATUS_OFFSET;\n\t\tchip->mixer_status_mask = NM_MIXER_READY_MASK;\n\t} else {\n\t\t \n\t\tif (snd_nm256_readb(chip, 0xa0b) != 0)\n\t\t\tchip->buffer_end = 6144 * 1024;\n\t\telse\n\t\t\tchip->buffer_end = 4096 * 1024;\n\n\t\tchip->interrupt = snd_nm256_interrupt_zx;\n\t\tchip->mixer_status_offset = NM2_MIXER_STATUS_OFFSET;\n\t\tchip->mixer_status_mask = NM2_MIXER_READY_MASK;\n\t}\n\t\n\tchip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize +\n\t\tchip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;\n\tif (chip->use_cache)\n\t\tchip->buffer_size += NM_TOTAL_COEFF_COUNT * 4;\n\telse\n\t\tchip->buffer_size += NM_MAX_PLAYBACK_COEF_SIZE + NM_MAX_RECORD_COEF_SIZE;\n\n\tif (buffer_top >= chip->buffer_size && buffer_top < chip->buffer_end)\n\t\tchip->buffer_end = buffer_top;\n\telse {\n\t\t \n\t\terr = snd_nm256_peek_for_sig(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tchip->buffer_start = chip->buffer_end - chip->buffer_size;\n\tchip->buffer_addr += chip->buffer_start;\n\n\tdev_info(card->dev, \"Mapping port 1 from 0x%x - 0x%x\\n\",\n\t       chip->buffer_start, chip->buffer_end);\n\n\tchip->buffer = devm_ioremap(&pci->dev, chip->buffer_addr,\n\t\t\t\t    chip->buffer_size);\n\tif (!chip->buffer) {\n\t\tdev_err(card->dev, \"unable to map ring buffer at %lx\\n\",\n\t\t\tchip->buffer_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\taddr = chip->buffer_start;\n\tchip->streams[SNDRV_PCM_STREAM_PLAYBACK].buf = addr;\n\taddr += chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize;\n\tchip->streams[SNDRV_PCM_STREAM_CAPTURE].buf = addr;\n\taddr += chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;\n\tif (chip->use_cache) {\n\t\tchip->all_coeff_buf = addr;\n\t} else {\n\t\tchip->coeff_buf[SNDRV_PCM_STREAM_PLAYBACK] = addr;\n\t\taddr += NM_MAX_PLAYBACK_COEF_SIZE;\n\t\tchip->coeff_buf[SNDRV_PCM_STREAM_CAPTURE] = addr;\n\t}\n\n\t \n\tchip->mixer_base = NM_MIXER_OFFSET;\n\n\tchip->coeffs_current = 0;\n\n\tsnd_nm256_init_chip(chip);\n\n\t\n\treturn 0;\n}\n\n\nenum { NM_IGNORED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };\n\nstatic const struct snd_pci_quirk nm256_quirks[] = {\n\t \n\tSND_PCI_QUIRK(0x103c, 0x0007, \"HP omnibook 4150\", NM_IGNORED),\n\t \n\tSND_PCI_QUIRK(0x104d, 0x8041, \"Sony PCG-F305\", NM_RESET_WORKAROUND),\n\tSND_PCI_QUIRK(0x1028, 0x0080, \"Dell Latitude LS\", NM_RESET_WORKAROUND),\n\tSND_PCI_QUIRK(0x1028, 0x0091, \"Dell Latitude CSx\", NM_RESET_WORKAROUND_2),\n\t{ }  \n};\n\n\nstatic int snd_nm256_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct nm256 *chip;\n\tint err;\n\tconst struct snd_pci_quirk *q;\n\n\tq = snd_pci_quirk_lookup(pci, nm256_quirks);\n\tif (q) {\n\t\tdev_dbg(&pci->dev, \"Enabled quirk for %s.\\n\",\n\t\t\t    snd_pci_quirk_name(q));\n\t\tswitch (q->value) {\n\t\tcase NM_IGNORED:\n\t\t\tdev_info(&pci->dev,\n\t\t\t\t \"The device is on the denylist. Loading stopped\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase NM_RESET_WORKAROUND_2:\n\t\t\treset_workaround_2 = 1;\n\t\t\tfallthrough;\n\t\tcase NM_RESET_WORKAROUND:\n\t\t\treset_workaround = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tswitch (pci->device) {\n\tcase PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO:\n\t\tstrcpy(card->driver, \"NM256AV\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO:\n\t\tstrcpy(card->driver, \"NM256ZX\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO:\n\t\tstrcpy(card->driver, \"NM256XL+\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pci->dev, \"invalid device id 0x%x\\n\", pci->device);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vaio_hack)\n\t\tbuffer_top = 0x25a800;\t \n\n\tif (playback_bufsize < 4)\n\t\tplayback_bufsize = 4;\n\tif (playback_bufsize > 128)\n\t\tplayback_bufsize = 128;\n\tif (capture_bufsize < 4)\n\t\tcapture_bufsize = 4;\n\tif (capture_bufsize > 128)\n\t\tcapture_bufsize = 128;\n\terr = snd_nm256_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (reset_workaround) {\n\t\tdev_dbg(&pci->dev, \"reset_workaround activated\\n\");\n\t\tchip->reset_workaround = 1;\n\t}\n\n\tif (reset_workaround_2) {\n\t\tdev_dbg(&pci->dev, \"reset_workaround_2 activated\\n\");\n\t\tchip->reset_workaround_2 = 1;\n\t}\n\n\terr = snd_nm256_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_nm256_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(card->shortname, \"NeoMagic %s\", card->driver);\n\tsprintf(card->longname, \"%s at 0x%lx & 0x%lx, irq %d\",\n\t\tcard->shortname,\n\t\tchip->buffer_addr, chip->cport_addr, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = snd_nm256_free;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic struct pci_driver nm256_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_nm256_ids,\n\t.probe = snd_nm256_probe,\n\t.driver = {\n\t\t.pm = NM256_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(nm256_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}