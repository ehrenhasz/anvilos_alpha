{
  "module_name": "korg1212.c",
  "hash_id": "7b8d4d1eae4a9eab852ad841710423880eb6f073d3d735d757c8bdea58d37c35",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/korg1212/korg1212.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n\n\n\n#define K1212_DEBUG_LEVEL\t\t0\n#if K1212_DEBUG_LEVEL > 0\n#define K1212_DEBUG_PRINTK(fmt,args...)\tprintk(KERN_DEBUG fmt,##args)\n#else\n#define K1212_DEBUG_PRINTK(fmt,...)\tdo { } while (0)\n#endif\n#if K1212_DEBUG_LEVEL > 1\n#define K1212_DEBUG_PRINTK_VERBOSE(fmt,args...)\tprintk(KERN_DEBUG fmt,##args)\n#else\n#define K1212_DEBUG_PRINTK_VERBOSE(fmt,...)\n#endif\n\n\n\n\n\n\n\n\n\n\nenum CardState {\n   K1212_STATE_NONEXISTENT,\t\t\n   K1212_STATE_UNINITIALIZED,\t\t\n   K1212_STATE_DSP_IN_PROCESS,\t\t\n   K1212_STATE_DSP_COMPLETE,\t\t\n   K1212_STATE_READY,\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n   K1212_STATE_OPEN,\t\t\t\n   K1212_STATE_SETUP,\t\t\t\n   K1212_STATE_PLAYING,\t\t\t\n   K1212_STATE_MONITOR,\t\t\t\n   K1212_STATE_CALIBRATING,\t\t\n   K1212_STATE_ERRORSTOP,\t\t\n\t\t\t\t\t\n   K1212_STATE_MAX_STATE\t\t\n};\n\n\n\n\n\nenum korg1212_dbcnst {\n   K1212_DB_RequestForData        = 0,    \n   K1212_DB_TriggerPlay           = 1,    \n   K1212_DB_SelectPlayMode        = 2,    \n   K1212_DB_ConfigureBufferMemory = 3,    \n   K1212_DB_RequestAdatTimecode   = 4,    \n   K1212_DB_SetClockSourceRate    = 5,    \n   K1212_DB_ConfigureMiscMemory   = 6,    \n   K1212_DB_TriggerFromAdat       = 7,    \n                                          \n   K1212_DB_DMAERROR              = 0x80, \n   K1212_DB_CARDSTOPPED           = 0x81, \n   K1212_DB_RebootCard            = 0xA0, \n   K1212_DB_BootFromDSPPage4      = 0xA4, \n                                          \n   K1212_DB_DSPDownloadDone       = 0xAE, \n                                          \n   K1212_DB_StartDSPDownload      = 0xAF  \n};\n\n\n\n\n\n\nenum snd_korg1212rc {\n   K1212_CMDRET_Success         = 0,   \n   K1212_CMDRET_DIOCFailure,           \n   K1212_CMDRET_PMFailure,             \n   K1212_CMDRET_FailUnspecified,       \n   K1212_CMDRET_FailBadState,          \n                                       \n                                       \n   K1212_CMDRET_CardUninitialized,     \n   K1212_CMDRET_BadIndex,              \n   K1212_CMDRET_BadHandle,             \n   K1212_CMDRET_NoFillRoutine,         \n   K1212_CMDRET_FillRoutineInUse,      \n   K1212_CMDRET_NoAckFromCard,         \n   K1212_CMDRET_BadParams,             \n\n   K1212_CMDRET_BadDevice,             \n   K1212_CMDRET_BadFormat              \n};\n\n\n\n\n\nenum PlayModeSelector {\n   K1212_MODE_SetupPlay  = 0x00000001,     \n   K1212_MODE_MonitorOn  = 0x00000002,     \n   K1212_MODE_MonitorOff = 0x00000004,     \n   K1212_MODE_StopPlay   = 0x00000008      \n};\n\n\n\n\n\nenum MonitorModeSelector {\n   K1212_MONMODE_Off  = 0,     \n   K1212_MONMODE_On            \n};\n\n#define MAILBOX0_OFFSET      0x40\t\n#define MAILBOX1_OFFSET      0x44\t\n#define MAILBOX2_OFFSET      0x48\t\n#define MAILBOX3_OFFSET      0x4c\t\n#define OUT_DOORBELL_OFFSET  0x60\t\n#define IN_DOORBELL_OFFSET   0x64\t\n#define STATUS_REG_OFFSET    0x68\t\n#define PCI_CONTROL_OFFSET   0x6c\t\n\t\t\t\t\t\n#define SENS_CONTROL_OFFSET  0x6e\t\n\t\t\t\t\t\n#define DEV_VEND_ID_OFFSET   0x70\t\n\n#define MAX_COMMAND_RETRIES  5         \n                                       \n#define COMMAND_ACK_MASK     0x8000    \n                                        \n#define DOORBELL_VAL_MASK    0x00FF    \n\n#define CARD_BOOT_DELAY_IN_MS  10\n#define CARD_BOOT_TIMEOUT      10\n#define DSP_BOOT_DELAY_IN_MS   200\n\n#define kNumBuffers\t\t8\n#define k1212MaxCards\t\t4\n#define k1212NumWaveDevices\t6\n#define k16BitChannels\t\t10\n#define k32BitChannels\t\t2\n#define kAudioChannels\t\t(k16BitChannels + k32BitChannels)\n#define kPlayBufferFrames\t1024\n\n#define K1212_ANALOG_CHANNELS\t2\n#define K1212_SPDIF_CHANNELS\t2\n#define K1212_ADAT_CHANNELS\t8\n#define K1212_CHANNELS\t\t(K1212_ADAT_CHANNELS + K1212_ANALOG_CHANNELS)\n#define K1212_MIN_CHANNELS\t1\n#define K1212_MAX_CHANNELS\tK1212_CHANNELS\n#define K1212_FRAME_SIZE        (sizeof(struct KorgAudioFrame))\n#define K1212_MAX_SAMPLES\t(kPlayBufferFrames*kNumBuffers)\n#define K1212_PERIODS\t\t(kNumBuffers)\n#define K1212_PERIOD_BYTES\t(K1212_FRAME_SIZE*kPlayBufferFrames)\n#define K1212_BUF_SIZE          (K1212_PERIOD_BYTES*kNumBuffers)\n#define K1212_ANALOG_BUF_SIZE\t(K1212_ANALOG_CHANNELS * 2 * kPlayBufferFrames * kNumBuffers)\n#define K1212_SPDIF_BUF_SIZE\t(K1212_SPDIF_CHANNELS * 3 * kPlayBufferFrames * kNumBuffers)\n#define K1212_ADAT_BUF_SIZE\t(K1212_ADAT_CHANNELS * 2 * kPlayBufferFrames * kNumBuffers)\n#define K1212_MAX_BUF_SIZE\t(K1212_ANALOG_BUF_SIZE + K1212_ADAT_BUF_SIZE)\n\n#define k1212MinADCSens     0x00\n#define k1212MaxADCSens     0x7f\n#define k1212MaxVolume      0x7fff\n#define k1212MaxWaveVolume  0xffff\n#define k1212MinVolume      0x0000\n#define k1212MaxVolInverted 0x8000\n\n\n\n\n\n#define  PCI_INT_ENABLE_BIT               0x00000100\n#define  PCI_DOORBELL_INT_ENABLE_BIT      0x00000200\n#define  LOCAL_INT_ENABLE_BIT             0x00010000\n#define  LOCAL_DOORBELL_INT_ENABLE_BIT    0x00020000\n#define  LOCAL_DMA1_INT_ENABLE_BIT        0x00080000\n\n\n\n\n#define  PCI_CMD_MEM_SPACE_ENABLE_BIT     0x0002\n#define  PCI_CMD_IO_SPACE_ENABLE_BIT      0x0001\n#define  PCI_CMD_BUS_MASTER_ENABLE_BIT    0x0004\n\n\n\n\n#define  PCI_STAT_PARITY_ERROR_BIT        0x8000\n#define  PCI_STAT_SYSTEM_ERROR_BIT        0x4000\n#define  PCI_STAT_MASTER_ABORT_RCVD_BIT   0x2000\n#define  PCI_STAT_TARGET_ABORT_RCVD_BIT   0x1000\n#define  PCI_STAT_TARGET_ABORT_SENT_BIT   0x0800\n\n\n\n\n\n#define  SET_SENS_LOCALINIT_BITPOS        15\n#define  SET_SENS_DATA_BITPOS             10\n#define  SET_SENS_CLOCK_BITPOS            8\n#define  SET_SENS_LOADSHIFT_BITPOS        0\n\n#define  SET_SENS_LEFTCHANID              0x00\n#define  SET_SENS_RIGHTCHANID             0x01\n\n#define  K1212SENSUPDATE_DELAY_IN_MS      50\n\n\n\n\n\n\n\n\n\n#define ONE_RTC_TICK         1\n#define SENSCLKPULSE_WIDTH   4\n#define LOADSHIFT_DELAY      4\n#define INTERCOMMAND_DELAY  40\n#define STOPCARD_DELAY      300        \n                                       \n#define COMMAND_ACK_DELAY   13         \n                                       \n\nenum ClockSourceIndex {\n   K1212_CLKIDX_AdatAt44_1K = 0,    \n   K1212_CLKIDX_AdatAt48K,          \n   K1212_CLKIDX_WordAt44_1K,        \n   K1212_CLKIDX_WordAt48K,          \n   K1212_CLKIDX_LocalAt44_1K,       \n   K1212_CLKIDX_LocalAt48K,         \n   K1212_CLKIDX_Invalid             \n};\n\nenum ClockSourceType {\n   K1212_CLKIDX_Adat = 0,    \n   K1212_CLKIDX_Word,        \n   K1212_CLKIDX_Local        \n};\n\nstruct KorgAudioFrame {\n\tu16 frameData16[k16BitChannels];  \n\tu32 frameData32[k32BitChannels];  \n\tu32 timeCodeVal;  \n};\n\nstruct KorgAudioBuffer {\n\tstruct KorgAudioFrame  bufferData[kPlayBufferFrames];      \n};\n\nstruct KorgSharedBuffer {\n#ifdef K1212_LARGEALLOC\n   struct KorgAudioBuffer   playDataBufs[kNumBuffers];\n   struct KorgAudioBuffer   recordDataBufs[kNumBuffers];\n#endif\n   short             volumeData[kAudioChannels];\n   u32               cardCommand;\n   u16               routeData [kAudioChannels];\n   u32               AdatTimeCode;                 \n};\n\nstruct SensBits {\n   union {\n      struct {\n         unsigned int leftChanVal:8;\n         unsigned int leftChanId:8;\n      } v;\n      u16  leftSensBits;\n   } l;\n   union {\n      struct {\n         unsigned int rightChanVal:8;\n         unsigned int rightChanId:8;\n      } v;\n      u16  rightSensBits;\n   } r;\n};\n\nstruct snd_korg1212 {\n        struct snd_card *card;\n        struct pci_dev *pci;\n        struct snd_pcm *pcm;\n        int irq;\n\n        spinlock_t    lock;\n\tstruct mutex open_mutex;\n\n\tstruct timer_list timer;\t \n\tint stop_pending_cnt;\t\t \n\n        wait_queue_head_t wait;\n\n        unsigned long iomem;\n        unsigned long ioport;\n\tunsigned long iomem2;\n        unsigned long irqcount;\n        unsigned long inIRQ;\n        void __iomem *iobase;\n\n\tstruct snd_dma_buffer *dma_dsp;\n\tstruct snd_dma_buffer *dma_play;\n\tstruct snd_dma_buffer *dma_rec;\n\tstruct snd_dma_buffer *dma_shared;\n\n\tu32 DataBufsSize;\n\n        struct KorgAudioBuffer  * playDataBufsPtr;\n        struct KorgAudioBuffer  * recordDataBufsPtr;\n\n\tstruct KorgSharedBuffer * sharedBufferPtr;\n\n\tu32 RecDataPhy;\n\tu32 PlayDataPhy;\n\tunsigned long sharedBufferPhy;\n\tu32 VolumeTablePhy;\n\tu32 RoutingTablePhy;\n\tu32 AdatTimeCodePhy;\n\n        u32 __iomem * statusRegPtr;\t     \n        u32 __iomem * outDoorbellPtr;\t     \n        u32 __iomem * inDoorbellPtr;\t     \n        u32 __iomem * mailbox0Ptr;\t     \n        u32 __iomem * mailbox1Ptr;\t     \n        u32 __iomem * mailbox2Ptr;\t     \n        u32 __iomem * mailbox3Ptr;\t     \n        u32 __iomem * controlRegPtr;\t     \n        u16 __iomem * sensRegPtr;\t     \n        u32 __iomem * idRegPtr;\t\t     \n\n        size_t periodsize;\n\tint channels;\n        int currentBuffer;\n\n        struct snd_pcm_substream *playback_substream;\n        struct snd_pcm_substream *capture_substream;\n\n\tpid_t capture_pid;\n\tpid_t playback_pid;\n\n \tenum CardState cardState;\n        int running;\n        int idleMonitorOn;           \n        u32 cmdRetryCount;           \n\n        enum ClockSourceIndex clkSrcRate; \n\n        enum ClockSourceType clkSource;   \n        int clkRate;                 \n\n        int volumePhase[kAudioChannels];\n\n        u16 leftADCInSens;           \n        u16 rightADCInSens;          \n\n\tint opencnt;\t\t     \n\tint setcnt;\t\t     \n\tint playcnt;\t\t     \n\tint errorcnt;\t\t     \n\tunsigned long totalerrorcnt; \n\n\tint dsp_is_loaded;\n\tint dsp_stop_is_processed;\n\n};\n\nMODULE_DESCRIPTION(\"korg1212\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"korg/k1212.dsp\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;      \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t    \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Korg 1212 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Korg 1212 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Korg 1212 soundcard.\");\nMODULE_AUTHOR(\"Haroldo Gamal <gamal@alternex.com.br>\");\n\nstatic const struct pci_device_id snd_korg1212_ids[] = {\n\t{\n\t\t.vendor\t   = 0x10b5,\n\t\t.device\t   = 0x906d,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t},\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, snd_korg1212_ids);\n\nstatic const char * const stateName[] = {\n\t\"Non-existent\",\n\t\"Uninitialized\",\n\t\"DSP download in process\",\n\t\"DSP download complete\",\n\t\"Ready\",\n\t\"Open\",\n\t\"Setup for play\",\n\t\"Playing\",\n\t\"Monitor mode on\",\n\t\"Calibrating\",\n\t\"Invalid\"\n};\n\nstatic const char * const clockSourceTypeName[] = { \"ADAT\", \"S/PDIF\", \"local\" };\n\nstatic const char * const clockSourceName[] = {\n\t\"ADAT at 44.1 kHz\",\n\t\"ADAT at 48 kHz\",\n\t\"S/PDIF at 44.1 kHz\",\n\t\"S/PDIF at 48 kHz\",\n\t\"local clock at 44.1 kHz\",\n\t\"local clock at 48 kHz\"\n};\n\nstatic const char * const channelName[] = {\n\t\"ADAT-1\",\n\t\"ADAT-2\",\n\t\"ADAT-3\",\n\t\"ADAT-4\",\n\t\"ADAT-5\",\n\t\"ADAT-6\",\n\t\"ADAT-7\",\n\t\"ADAT-8\",\n\t\"Analog-L\",\n\t\"Analog-R\",\n\t\"SPDIF-L\",\n\t\"SPDIF-R\",\n};\n\nstatic const u16 ClockSourceSelector[] = {\n\t0x8000,   \n\t0x0000,   \n\t0x8001,   \n\t0x0001,   \n\t0x8002,   \n\t0x0002    \n};\n\nunion swap_u32 { unsigned char c[4]; u32 i; };\n\n#ifdef SNDRV_BIG_ENDIAN\nstatic u32 LowerWordSwap(u32 swappee)\n#else\nstatic u32 UpperWordSwap(u32 swappee)\n#endif\n{\n   union swap_u32 retVal, swapper;\n\n   swapper.i = swappee;\n   retVal.c[2] = swapper.c[3];\n   retVal.c[3] = swapper.c[2];\n   retVal.c[1] = swapper.c[1];\n   retVal.c[0] = swapper.c[0];\n\n   return retVal.i;\n}\n\n#ifdef SNDRV_BIG_ENDIAN\nstatic u32 UpperWordSwap(u32 swappee)\n#else\nstatic u32 LowerWordSwap(u32 swappee)\n#endif\n{\n   union swap_u32 retVal, swapper;\n\n   swapper.i = swappee;\n   retVal.c[2] = swapper.c[2];\n   retVal.c[3] = swapper.c[3];\n   retVal.c[1] = swapper.c[0];\n   retVal.c[0] = swapper.c[1];\n\n   return retVal.i;\n}\n\n#define SetBitInWord(theWord,bitPosition)       (*theWord) |= (0x0001 << bitPosition)\n#define SetBitInDWord(theWord,bitPosition)      (*theWord) |= (0x00000001 << bitPosition)\n#define ClearBitInWord(theWord,bitPosition)     (*theWord) &= ~(0x0001 << bitPosition)\n#define ClearBitInDWord(theWord,bitPosition)    (*theWord) &= ~(0x00000001 << bitPosition)\n\nstatic int snd_korg1212_Send1212Command(struct snd_korg1212 *korg1212,\n\t\t\t\t\tenum korg1212_dbcnst doorbellVal,\n\t\t\t\t\tu32 mailBox0Val, u32 mailBox1Val,\n\t\t\t\t\tu32 mailBox2Val, u32 mailBox3Val)\n{\n        u32 retryCount;\n        u16 mailBox3Lo;\n\tint rc = K1212_CMDRET_Success;\n\n        if (!korg1212->outDoorbellPtr) {\n\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: CardUninitialized\\n\");\n                return K1212_CMDRET_CardUninitialized;\n\t}\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Card <- 0x%08x 0x%08x [%s]\\n\",\n\t\t\t   doorbellVal, mailBox0Val, stateName[korg1212->cardState]);\n        for (retryCount = 0; retryCount < MAX_COMMAND_RETRIES; retryCount++) {\n\t\twritel(mailBox3Val, korg1212->mailbox3Ptr);\n                writel(mailBox2Val, korg1212->mailbox2Ptr);\n                writel(mailBox1Val, korg1212->mailbox1Ptr);\n                writel(mailBox0Val, korg1212->mailbox0Ptr);\n                writel(doorbellVal, korg1212->outDoorbellPtr);  \n\n                \n                \n                \n                if ( doorbellVal == K1212_DB_RebootCard ||\n                \tdoorbellVal == K1212_DB_BootFromDSPPage4 ||\n                        doorbellVal == K1212_DB_StartDSPDownload ) {\n                        rc = K1212_CMDRET_Success;\n                        break;\n                }\n\n                \n                \n                \n                \n                \n                udelay(COMMAND_ACK_DELAY);\n                mailBox3Lo = readl(korg1212->mailbox3Ptr);\n                if (mailBox3Lo & COMMAND_ACK_MASK) {\n                \tif ((mailBox3Lo & DOORBELL_VAL_MASK) == (doorbellVal & DOORBELL_VAL_MASK)) {\n\t\t\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: Card <- Success\\n\");\n                                rc = K1212_CMDRET_Success;\n\t\t\t\tbreak;\n                        }\n                }\n\t}\n        korg1212->cmdRetryCount += retryCount;\n\n\tif (retryCount >= MAX_COMMAND_RETRIES) {\n\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: Card <- NoAckFromCard\\n\");\n        \trc = K1212_CMDRET_NoAckFromCard;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void snd_korg1212_SendStop(struct snd_korg1212 *korg1212)\n{\n\tif (! korg1212->stop_pending_cnt) {\n\t\tkorg1212->sharedBufferPtr->cardCommand = 0xffffffff;\n\t\t \n\t\tkorg1212->stop_pending_cnt = HZ;\n\t\tmod_timer(&korg1212->timer, jiffies + 1);\n\t}\n}\n\nstatic void snd_korg1212_SendStopAndWait(struct snd_korg1212 *korg1212)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&korg1212->lock, flags);\n\tkorg1212->dsp_stop_is_processed = 0;\n\tsnd_korg1212_SendStop(korg1212);\n\tspin_unlock_irqrestore(&korg1212->lock, flags);\n\twait_event_timeout(korg1212->wait, korg1212->dsp_stop_is_processed, (HZ * 3) / 2);\n}\n\n \nstatic void snd_korg1212_timer_func(struct timer_list *t)\n{\n\tstruct snd_korg1212 *korg1212 = from_timer(korg1212, t, timer);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&korg1212->lock, flags);\n\tif (korg1212->sharedBufferPtr->cardCommand == 0) {\n\t\t \n\t\tkorg1212->stop_pending_cnt = 0;\n\t\tkorg1212->dsp_stop_is_processed = 1;\n\t\twake_up(&korg1212->wait);\n\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: Stop ack'ed [%s]\\n\",\n\t\t\t\t\t   stateName[korg1212->cardState]);\n\t} else {\n\t\tif (--korg1212->stop_pending_cnt > 0) {\n\t\t\t \n\t\t\tmod_timer(&korg1212->timer, jiffies + 1);\n\t\t} else {\n\t\t\tsnd_printd(\"korg1212_timer_func timeout\\n\");\n\t\t\tkorg1212->sharedBufferPtr->cardCommand = 0;\n\t\t\tkorg1212->dsp_stop_is_processed = 1;\n\t\t\twake_up(&korg1212->wait);\n\t\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Stop timeout [%s]\\n\",\n\t\t\t\t\t   stateName[korg1212->cardState]);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&korg1212->lock, flags);\n}\n\nstatic int snd_korg1212_TurnOnIdleMonitor(struct snd_korg1212 *korg1212)\n{\n\tunsigned long flags;\n\tint rc;\n\n        udelay(INTERCOMMAND_DELAY);\n\tspin_lock_irqsave(&korg1212->lock, flags);\n        korg1212->idleMonitorOn = 1;\n        rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,\n\t\t\t\t\t  K1212_MODE_MonitorOn, 0, 0, 0);\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\treturn rc;\n}\n\nstatic void snd_korg1212_TurnOffIdleMonitor(struct snd_korg1212 *korg1212)\n{\n        if (korg1212->idleMonitorOn) {\n\t\tsnd_korg1212_SendStopAndWait(korg1212);\n                korg1212->idleMonitorOn = 0;\n        }\n}\n\nstatic inline void snd_korg1212_setCardState(struct snd_korg1212 * korg1212, enum CardState csState)\n{\n        korg1212->cardState = csState;\n}\n\nstatic int snd_korg1212_OpenCard(struct snd_korg1212 * korg1212)\n{\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: OpenCard [%s] %d\\n\",\n\t\t\t   stateName[korg1212->cardState], korg1212->opencnt);\n\tmutex_lock(&korg1212->open_mutex);\n        if (korg1212->opencnt++ == 0) {\n\t\tsnd_korg1212_TurnOffIdleMonitor(korg1212);\n\t\tsnd_korg1212_setCardState(korg1212, K1212_STATE_OPEN);\n\t}\n\n\tmutex_unlock(&korg1212->open_mutex);\n        return 1;\n}\n\nstatic int snd_korg1212_CloseCard(struct snd_korg1212 * korg1212)\n{\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: CloseCard [%s] %d\\n\",\n\t\t\t   stateName[korg1212->cardState], korg1212->opencnt);\n\n\tmutex_lock(&korg1212->open_mutex);\n\tif (--(korg1212->opencnt)) {\n\t\tmutex_unlock(&korg1212->open_mutex);\n\t\treturn 0;\n\t}\n\n        if (korg1212->cardState == K1212_STATE_SETUP) {\n                int rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,\n                                K1212_MODE_StopPlay, 0, 0, 0);\n\t\tif (rc)\n\t\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: CloseCard - RC = %d [%s]\\n\",\n\t\t\t\t\t   rc, stateName[korg1212->cardState]);\n\t\tif (rc != K1212_CMDRET_Success) {\n\t\t\tmutex_unlock(&korg1212->open_mutex);\n                        return 0;\n\t\t}\n        } else if (korg1212->cardState > K1212_STATE_SETUP) {\n\t\tsnd_korg1212_SendStopAndWait(korg1212);\n        }\n\n        if (korg1212->cardState > K1212_STATE_READY) {\n\t\tsnd_korg1212_TurnOnIdleMonitor(korg1212);\n                snd_korg1212_setCardState(korg1212, K1212_STATE_READY);\n\t}\n\n\tmutex_unlock(&korg1212->open_mutex);\n        return 0;\n}\n\n \nstatic int snd_korg1212_SetupForPlay(struct snd_korg1212 * korg1212)\n{\n\tint rc;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: SetupForPlay [%s] %d\\n\",\n\t\t\t   stateName[korg1212->cardState], korg1212->setcnt);\n\n        if (korg1212->setcnt++)\n\t\treturn 0;\n\n        snd_korg1212_setCardState(korg1212, K1212_STATE_SETUP);\n        rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,\n                                        K1212_MODE_SetupPlay, 0, 0, 0);\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: SetupForPlay - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n        if (rc != K1212_CMDRET_Success) {\n                return 1;\n        }\n        return 0;\n}\n\n \nstatic int snd_korg1212_TriggerPlay(struct snd_korg1212 * korg1212)\n{\n\tint rc;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: TriggerPlay [%s] %d\\n\",\n\t\t\t   stateName[korg1212->cardState], korg1212->playcnt);\n\n        if (korg1212->playcnt++)\n\t\treturn 0;\n\n        snd_korg1212_setCardState(korg1212, K1212_STATE_PLAYING);\n        rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_TriggerPlay, 0, 0, 0, 0);\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: TriggerPlay - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n        if (rc != K1212_CMDRET_Success) {\n                return 1;\n        }\n        return 0;\n}\n\n \nstatic int snd_korg1212_StopPlay(struct snd_korg1212 * korg1212)\n{\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: StopPlay [%s] %d\\n\",\n\t\t\t   stateName[korg1212->cardState], korg1212->playcnt);\n\n        if (--(korg1212->playcnt)) \n\t\treturn 0;\n\n\tkorg1212->setcnt = 0;\n\n        if (korg1212->cardState != K1212_STATE_ERRORSTOP)\n\t\tsnd_korg1212_SendStop(korg1212);\n\n\tsnd_korg1212_setCardState(korg1212, K1212_STATE_OPEN);\n        return 0;\n}\n\nstatic void snd_korg1212_EnableCardInterrupts(struct snd_korg1212 * korg1212)\n{\n\twritel(PCI_INT_ENABLE_BIT            |\n\t       PCI_DOORBELL_INT_ENABLE_BIT   |\n\t       LOCAL_INT_ENABLE_BIT          |\n\t       LOCAL_DOORBELL_INT_ENABLE_BIT |\n\t       LOCAL_DMA1_INT_ENABLE_BIT,\n\t       korg1212->statusRegPtr);\n}\n\n#if 0  \n\nstatic int snd_korg1212_SetMonitorMode(struct snd_korg1212 *korg1212,\n\t\t\t\t       enum MonitorModeSelector mode)\n{\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: SetMonitorMode [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n        switch (mode) {\n\tcase K1212_MONMODE_Off:\n\t\tif (korg1212->cardState != K1212_STATE_MONITOR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\tsnd_korg1212_SendStopAndWait(korg1212);\n\t\t\tsnd_korg1212_setCardState(korg1212, K1212_STATE_OPEN);\n\t\t}\n\t\tbreak;\n\n\tcase K1212_MONMODE_On:\n\t\tif (korg1212->cardState != K1212_STATE_OPEN)\n\t\t\treturn 0;\n\t\telse {\n\t\t\tint rc;\n\t\t\tsnd_korg1212_setCardState(korg1212, K1212_STATE_MONITOR);\n\t\t\trc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,\n\t\t\t\t\t\t\t  K1212_MODE_MonitorOn, 0, 0, 0);\n\t\t\tif (rc != K1212_CMDRET_Success)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n        }\n\n        return 1;\n}\n\n#endif  \n\nstatic inline int snd_korg1212_use_is_exclusive(struct snd_korg1212 *korg1212)\n{\n\tif (korg1212->playback_pid != korg1212->capture_pid &&\n\t    korg1212->playback_pid >= 0 && korg1212->capture_pid >= 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int snd_korg1212_SetRate(struct snd_korg1212 *korg1212, int rate)\n{\n\tstatic const enum ClockSourceIndex s44[] = {\n\t\tK1212_CLKIDX_AdatAt44_1K,\n\t\tK1212_CLKIDX_WordAt44_1K,\n\t\tK1212_CLKIDX_LocalAt44_1K\n\t};\n\tstatic const enum ClockSourceIndex s48[] = {\n\t\tK1212_CLKIDX_AdatAt48K,\n\t\tK1212_CLKIDX_WordAt48K,\n\t\tK1212_CLKIDX_LocalAt48K\n\t};\n        int parm, rc;\n\n\tif (!snd_korg1212_use_is_exclusive (korg1212))\n\t\treturn -EBUSY;\n\n\tswitch (rate) {\n\tcase 44100:\n\t\tparm = s44[korg1212->clkSource];\n\t\tbreak;\n\n\tcase 48000:\n\t\tparm = s48[korg1212->clkSource];\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n        korg1212->clkSrcRate = parm;\n        korg1212->clkRate = rate;\n\n\tudelay(INTERCOMMAND_DELAY);\n\trc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SetClockSourceRate,\n\t\t\t\t\t  ClockSourceSelector[korg1212->clkSrcRate],\n\t\t\t\t\t  0, 0, 0);\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Set Clock Source Selector - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n        return 0;\n}\n\nstatic int snd_korg1212_SetClockSource(struct snd_korg1212 *korg1212, int source)\n{\n\n\tif (source < 0 || source > 2)\n\t\treturn -EINVAL;\n\n        korg1212->clkSource = source;\n\n        snd_korg1212_SetRate(korg1212, korg1212->clkRate);\n\n        return 0;\n}\n\nstatic void snd_korg1212_DisableCardInterrupts(struct snd_korg1212 *korg1212)\n{\n\twritel(0, korg1212->statusRegPtr);\n}\n\nstatic int snd_korg1212_WriteADCSensitivity(struct snd_korg1212 *korg1212)\n{\n        struct SensBits  sensVals;\n        int       bitPosition;\n        int       channel;\n        int       clkIs48K;\n        int       monModeSet;\n        u16       controlValue;     \n                                    \n        u16       count;\n\tunsigned long flags;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: WriteADCSensivity [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n         \n         \n         \n         \n        controlValue = 0;\n        SetBitInWord(&controlValue, SET_SENS_LOCALINIT_BITPOS);     \n\n         \n         \n         \n        if (korg1212->cardState == K1212_STATE_MONITOR || korg1212->idleMonitorOn) {\n                monModeSet = 1;\n\t\tsnd_korg1212_SendStopAndWait(korg1212);\n        } else\n                monModeSet = 0;\n\n\tspin_lock_irqsave(&korg1212->lock, flags);\n\n         \n         \n         \n         \n        writel(0, korg1212->mailbox3Ptr);\n        udelay(LOADSHIFT_DELAY);\n\n         \n         \n         \n         \n        switch (korg1212->clkSrcRate) {\n                case K1212_CLKIDX_AdatAt44_1K:\n                case K1212_CLKIDX_WordAt44_1K:\n                case K1212_CLKIDX_LocalAt44_1K:\n                        clkIs48K = 0;\n                        break;\n\n                case K1212_CLKIDX_WordAt48K:\n                case K1212_CLKIDX_AdatAt48K:\n                case K1212_CLKIDX_LocalAt48K:\n                default:\n                        clkIs48K = 1;\n                        break;\n        }\n\n         \n         \n         \n        sensVals.l.v.leftChanId   = SET_SENS_LEFTCHANID;\n        sensVals.r.v.rightChanId  = SET_SENS_RIGHTCHANID;\n        sensVals.l.v.leftChanVal  = korg1212->leftADCInSens;\n        sensVals.r.v.rightChanVal = korg1212->rightADCInSens;\n\n         \n         \n         \n        for (channel = 0; channel < 2; channel++) {\n\n                 \n                 \n                 \n                 \n                ClearBitInWord(&controlValue, SET_SENS_LOADSHIFT_BITPOS);\n                ClearBitInWord(&controlValue, SET_SENS_DATA_BITPOS);\n                writew(controlValue, korg1212->sensRegPtr);                           \n                udelay(LOADSHIFT_DELAY);\n\n                for (bitPosition = 15; bitPosition >= 0; bitPosition--) {        \n\t\t\tif (channel == 0) {\n\t\t\t\tif (sensVals.l.leftSensBits & (0x0001 << bitPosition))\n                                        SetBitInWord(&controlValue, SET_SENS_DATA_BITPOS);      \n\t\t\t\telse\n\t\t\t\t\tClearBitInWord(&controlValue, SET_SENS_DATA_BITPOS);    \n\t\t\t} else {\n                                if (sensVals.r.rightSensBits & (0x0001 << bitPosition))\n\t\t\t\t\tSetBitInWord(&controlValue, SET_SENS_DATA_BITPOS);      \n\t\t\t\telse\n\t\t\t\t\tClearBitInWord(&controlValue, SET_SENS_DATA_BITPOS);    \n\t\t\t}\n\n                        ClearBitInWord(&controlValue, SET_SENS_CLOCK_BITPOS);\n                        writew(controlValue, korg1212->sensRegPtr);                        \n                        udelay(SENSCLKPULSE_WIDTH);\n                        SetBitInWord(&controlValue, SET_SENS_CLOCK_BITPOS);\n                        writew(controlValue, korg1212->sensRegPtr);                        \n                        udelay(SENSCLKPULSE_WIDTH);\n                }\n\n                 \n                 \n                 \n                 \n                ClearBitInWord(&controlValue, SET_SENS_DATA_BITPOS);\n                ClearBitInWord(&controlValue, SET_SENS_CLOCK_BITPOS);\n                SetBitInWord(&controlValue, SET_SENS_LOADSHIFT_BITPOS);\n                writew(controlValue, korg1212->sensRegPtr);                    \n                udelay(SENSCLKPULSE_WIDTH);\n\n                if (clkIs48K)\n                        SetBitInWord(&controlValue, SET_SENS_DATA_BITPOS);\n\n                writew(controlValue, korg1212->sensRegPtr);                    \n                udelay(ONE_RTC_TICK);\n                SetBitInWord(&controlValue, SET_SENS_CLOCK_BITPOS);\n                writew(controlValue, korg1212->sensRegPtr);                    \n                udelay(SENSCLKPULSE_WIDTH);\n                ClearBitInWord(&controlValue, SET_SENS_CLOCK_BITPOS);\n                writew(controlValue, korg1212->sensRegPtr);                    \n                udelay(SENSCLKPULSE_WIDTH);\n        }\n\n         \n         \n         \n         \n        for (count = 0; count < 10; count++)\n                udelay(SENSCLKPULSE_WIDTH);\n\n        if (monModeSet) {\n                int rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SelectPlayMode,\n                                K1212_MODE_MonitorOn, 0, 0, 0);\n\t        if (rc)\n\t\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: WriteADCSensivity - RC = %d [%s]\\n\",\n\t\t\t\t\t   rc, stateName[korg1212->cardState]);\n        }\n\n\tspin_unlock_irqrestore(&korg1212->lock, flags);\n\n        return 1;\n}\n\nstatic void snd_korg1212_OnDSPDownloadComplete(struct snd_korg1212 *korg1212)\n{\n        int channel, rc;\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: DSP download is complete. [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n         \n         \n         \n        rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_BootFromDSPPage4, 0, 0, 0, 0);\n\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Boot from Page 4 - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\tmsleep(DSP_BOOT_DELAY_IN_MS);\n\n         \n         \n         \n        rc = snd_korg1212_Send1212Command(korg1212,\n                        K1212_DB_ConfigureBufferMemory,\n                        LowerWordSwap(korg1212->PlayDataPhy),\n                        LowerWordSwap(korg1212->RecDataPhy),\n                        ((kNumBuffers * kPlayBufferFrames) / 2),    \n                                                                    \n                        0\n        );\n\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Configure Buffer Memory - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n        udelay(INTERCOMMAND_DELAY);\n\n        rc = snd_korg1212_Send1212Command(korg1212,\n                        K1212_DB_ConfigureMiscMemory,\n                        LowerWordSwap(korg1212->VolumeTablePhy),\n                        LowerWordSwap(korg1212->RoutingTablePhy),\n                        LowerWordSwap(korg1212->AdatTimeCodePhy),\n                        0\n        );\n\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Configure Misc Memory - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n         \n         \n         \n        udelay(INTERCOMMAND_DELAY);\n\n        for (channel = 0; channel < kAudioChannels; channel++) {\n                korg1212->sharedBufferPtr->volumeData[channel] = k1212MaxVolume;\n                 \n                korg1212->sharedBufferPtr->routeData[channel] = 8 + (channel & 1);\n        }\n\n        snd_korg1212_WriteADCSensitivity(korg1212);\n\n\tudelay(INTERCOMMAND_DELAY);\n\trc = snd_korg1212_Send1212Command(korg1212, K1212_DB_SetClockSourceRate,\n\t\t\t\t\t  ClockSourceSelector[korg1212->clkSrcRate],\n\t\t\t\t\t  0, 0, 0);\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Set Clock Source Selector - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n\trc = snd_korg1212_TurnOnIdleMonitor(korg1212);\n\tsnd_korg1212_setCardState(korg1212, K1212_STATE_READY);\n\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Set Monitor On - RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n\tsnd_korg1212_setCardState(korg1212, K1212_STATE_DSP_COMPLETE);\n}\n\nstatic irqreturn_t snd_korg1212_interrupt(int irq, void *dev_id)\n{\n        u32 doorbellValue;\n        struct snd_korg1212 *korg1212 = dev_id;\n\n        doorbellValue = readl(korg1212->inDoorbellPtr);\n\n        if (!doorbellValue)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&korg1212->lock);\n\n\twritel(doorbellValue, korg1212->inDoorbellPtr);\n\n        korg1212->irqcount++;\n\n\tkorg1212->inIRQ++;\n\n        switch (doorbellValue) {\n                case K1212_DB_DSPDownloadDone:\n                        K1212_DEBUG_PRINTK(\"K1212_DEBUG: IRQ DNLD count - %ld, %x, [%s].\\n\",\n\t\t\t\t\t   korg1212->irqcount, doorbellValue,\n\t\t\t\t\t   stateName[korg1212->cardState]);\n                        if (korg1212->cardState == K1212_STATE_DSP_IN_PROCESS) {\n\t\t\t\tkorg1212->dsp_is_loaded = 1;\n\t\t\t\twake_up(&korg1212->wait);\n\t\t\t}\n                        break;\n\n                 \n                 \n                 \n                case K1212_DB_DMAERROR:\n\t\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: IRQ DMAE count - %ld, %x, [%s].\\n\",\n\t\t\t\t\t\t   korg1212->irqcount, doorbellValue,\n\t\t\t\t\t\t   stateName[korg1212->cardState]);\n\t\t\tsnd_printk(KERN_ERR \"korg1212: DMA Error\\n\");\n\t\t\tkorg1212->errorcnt++;\n\t\t\tkorg1212->totalerrorcnt++;\n\t\t\tkorg1212->sharedBufferPtr->cardCommand = 0;\n\t\t\tsnd_korg1212_setCardState(korg1212, K1212_STATE_ERRORSTOP);\n                        break;\n\n                 \n                 \n                 \n                 \n                case K1212_DB_CARDSTOPPED:\n                        K1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: IRQ CSTP count - %ld, %x, [%s].\\n\",\n\t\t\t\t\t\t   korg1212->irqcount, doorbellValue,\n\t\t\t\t\t\t   stateName[korg1212->cardState]);\n\t\t\tkorg1212->sharedBufferPtr->cardCommand = 0;\n                        break;\n\n                default:\n\t\t\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: IRQ DFLT count - %ld, %x, cpos=%d [%s].\\n\",\n\t\t\t       korg1212->irqcount, doorbellValue, \n\t\t\t       korg1212->currentBuffer, stateName[korg1212->cardState]);\n                        if ((korg1212->cardState > K1212_STATE_SETUP) || korg1212->idleMonitorOn) {\n                                korg1212->currentBuffer++;\n\n                                if (korg1212->currentBuffer >= kNumBuffers)\n                                        korg1212->currentBuffer = 0;\n\n                                if (!korg1212->running)\n                                        break;\n\n                                if (korg1212->capture_substream) {\n\t\t\t\t\tspin_unlock(&korg1212->lock);\n                                        snd_pcm_period_elapsed(korg1212->capture_substream);\n\t\t\t\t\tspin_lock(&korg1212->lock);\n                                }\n\n                                if (korg1212->playback_substream) {\n\t\t\t\t\tspin_unlock(&korg1212->lock);\n                                        snd_pcm_period_elapsed(korg1212->playback_substream);\n\t\t\t\t\tspin_lock(&korg1212->lock);\n                                }\n                        }\n                        break;\n        }\n\n\tkorg1212->inIRQ--;\n\n\tspin_unlock(&korg1212->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int snd_korg1212_downloadDSPCode(struct snd_korg1212 *korg1212)\n{\n\tint rc;\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: DSP download is starting... [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n         \n         \n         \n        if (korg1212->cardState >= K1212_STATE_DSP_IN_PROCESS)\n                return 1;\n\n        snd_korg1212_setCardState(korg1212, K1212_STATE_DSP_IN_PROCESS);\n\n        rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_StartDSPDownload,\n\t\t\t\t\t  UpperWordSwap(korg1212->dma_dsp->addr),\n\t\t\t\t\t  0, 0, 0);\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Start DSP Download RC = %d [%s]\\n\",\n\t\t\t\t   rc, stateName[korg1212->cardState]);\n\n\tkorg1212->dsp_is_loaded = 0;\n\twait_event_timeout(korg1212->wait, korg1212->dsp_is_loaded, HZ * CARD_BOOT_TIMEOUT);\n\tif (! korg1212->dsp_is_loaded )\n\t\treturn -EBUSY;  \n\n\tsnd_korg1212_OnDSPDownloadComplete(korg1212);\n\n        return 0;\n}\n\nstatic const struct snd_pcm_hardware snd_korg1212_playback_info =\n{\n\t.info =              (SNDRV_PCM_INFO_MMAP |\n                              SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_BATCH),\n\t.formats =\t      SNDRV_PCM_FMTBIT_S16_LE,\n        .rates =              (SNDRV_PCM_RATE_44100 |\n                              SNDRV_PCM_RATE_48000),\n        .rate_min =           44100,\n        .rate_max =           48000,\n        .channels_min =       K1212_MIN_CHANNELS,\n        .channels_max =       K1212_MAX_CHANNELS,\n        .buffer_bytes_max =   K1212_MAX_BUF_SIZE,\n        .period_bytes_min =   K1212_MIN_CHANNELS * 2 * kPlayBufferFrames,\n        .period_bytes_max =   K1212_MAX_CHANNELS * 2 * kPlayBufferFrames,\n        .periods_min =        K1212_PERIODS,\n        .periods_max =        K1212_PERIODS,\n        .fifo_size =          0,\n};\n\nstatic const struct snd_pcm_hardware snd_korg1212_capture_info =\n{\n        .info =              (SNDRV_PCM_INFO_MMAP |\n                              SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_BATCH),\n        .formats =\t      SNDRV_PCM_FMTBIT_S16_LE,\n        .rates =\t      (SNDRV_PCM_RATE_44100 |\n                              SNDRV_PCM_RATE_48000),\n        .rate_min =           44100,\n        .rate_max =           48000,\n        .channels_min =       K1212_MIN_CHANNELS,\n        .channels_max =       K1212_MAX_CHANNELS,\n        .buffer_bytes_max =   K1212_MAX_BUF_SIZE,\n        .period_bytes_min =   K1212_MIN_CHANNELS * 2 * kPlayBufferFrames,\n        .period_bytes_max =   K1212_MAX_CHANNELS * 2 * kPlayBufferFrames,\n        .periods_min =        K1212_PERIODS,\n        .periods_max =        K1212_PERIODS,\n        .fifo_size =          0,\n};\n\nstatic int snd_korg1212_silence(struct snd_korg1212 *korg1212, int pos, int count, int offset, int size)\n{\n\tstruct KorgAudioFrame * dst =  korg1212->playDataBufsPtr[0].bufferData + pos;\n\tint i;\n\n\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: snd_korg1212_silence pos=%d offset=%d size=%d count=%d\\n\",\n\t\t\t\t   pos, offset, size, count);\n\tif (snd_BUG_ON(pos + count > K1212_MAX_SAMPLES))\n\t\treturn -EINVAL;\n\n\tfor (i=0; i < count; i++) {\n#if K1212_DEBUG_LEVEL > 0\n\t\tif ( (void *) dst < (void *) korg1212->playDataBufsPtr ||\n\t\t     (void *) dst > (void *) korg1212->playDataBufsPtr[8].bufferData ) {\n\t\t\tprintk(KERN_DEBUG \"K1212_DEBUG: snd_korg1212_silence KERNEL EFAULT dst=%p iter=%d\\n\",\n\t\t\t       dst, i);\n\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\t\tmemset((void*) dst + offset, 0, size);\n\t\tdst++;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_korg1212_copy_to(struct snd_pcm_substream *substream,\n\t\t\t\tstruct iov_iter *dst, int pos, int count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\tstruct KorgAudioFrame *src;\n\tint i, size;\n\n\tpos = bytes_to_frames(runtime, pos);\n\tcount = bytes_to_frames(runtime, count);\n\tsize = korg1212->channels * 2;\n\tsrc = korg1212->recordDataBufsPtr[0].bufferData + pos;\n\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: snd_korg1212_copy_to pos=%d size=%d count=%d\\n\",\n\t\t\t\t   pos, size, count);\n\tif (snd_BUG_ON(pos + count > K1212_MAX_SAMPLES))\n\t\treturn -EINVAL;\n\n\tfor (i=0; i < count; i++) {\n#if K1212_DEBUG_LEVEL > 0\n\t\tif ( (void *) src < (void *) korg1212->recordDataBufsPtr ||\n\t\t     (void *) src > (void *) korg1212->recordDataBufsPtr[8].bufferData ) {\n\t\t\tprintk(KERN_DEBUG \"K1212_DEBUG: snd_korg1212_copy_to KERNEL EFAULT, src=%p dst=%p iter=%d\\n\", src, dst->kvec.iov_base, i);\n\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\t\tif (copy_to_iter(src, size, dst) != size)\n\t\t\treturn -EFAULT;\n\t\tsrc++;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_korg1212_copy_from(struct snd_pcm_substream *substream,\n\t\t\t\t  struct iov_iter *src, int pos, int count)\n{\n        struct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\tstruct KorgAudioFrame *dst;\n\tint i, size;\n\n\tpos = bytes_to_frames(runtime, pos);\n\tcount = bytes_to_frames(runtime, count);\n\tsize = korg1212->channels * 2;\n\tdst = korg1212->playDataBufsPtr[0].bufferData + pos;\n\n\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: snd_korg1212_copy_from pos=%d size=%d count=%d\\n\",\n\t\t\t\t   pos, size, count);\n\n\tif (snd_BUG_ON(pos + count > K1212_MAX_SAMPLES))\n\t\treturn -EINVAL;\n\n\tfor (i=0; i < count; i++) {\n#if K1212_DEBUG_LEVEL > 0\n\t\tif ( (void *) dst < (void *) korg1212->playDataBufsPtr ||\n\t\t     (void *) dst > (void *) korg1212->playDataBufsPtr[8].bufferData ) {\n\t\t\tprintk(KERN_DEBUG \"K1212_DEBUG: snd_korg1212_copy_from KERNEL EFAULT, src=%p dst=%p iter=%d\\n\", src->kvec.iov_base, dst, i);\n\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\t\tif (copy_from_iter(dst, size, src) != size)\n\t\t\treturn -EFAULT;\n\t\tdst++;\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_korg1212_free_pcm(struct snd_pcm *pcm)\n{\n        struct snd_korg1212 *korg1212 = pcm->private_data;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_free_pcm [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n        korg1212->pcm = NULL;\n}\n\nstatic int snd_korg1212_playback_open(struct snd_pcm_substream *substream)\n{\n        unsigned long flags;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n        struct snd_pcm_runtime *runtime = substream->runtime;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_playback_open [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n\tsnd_korg1212_OpenCard(korg1212);\n\n        runtime->hw = snd_korg1212_playback_info;\n\tsnd_pcm_set_runtime_buffer(substream, korg1212->dma_play);\n\n        spin_lock_irqsave(&korg1212->lock, flags);\n\n        korg1212->playback_substream = substream;\n\tkorg1212->playback_pid = current->pid;\n        korg1212->periodsize = K1212_PERIODS;\n\tkorg1212->channels = K1212_CHANNELS;\n\tkorg1212->errorcnt = 0;\n\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\n\tsnd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t     kPlayBufferFrames);\n\n        return 0;\n}\n\n\nstatic int snd_korg1212_capture_open(struct snd_pcm_substream *substream)\n{\n        unsigned long flags;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n        struct snd_pcm_runtime *runtime = substream->runtime;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_capture_open [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n\tsnd_korg1212_OpenCard(korg1212);\n\n        runtime->hw = snd_korg1212_capture_info;\n\tsnd_pcm_set_runtime_buffer(substream, korg1212->dma_rec);\n\n        spin_lock_irqsave(&korg1212->lock, flags);\n\n        korg1212->capture_substream = substream;\n\tkorg1212->capture_pid = current->pid;\n        korg1212->periodsize = K1212_PERIODS;\n\tkorg1212->channels = K1212_CHANNELS;\n\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\n\tsnd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t     kPlayBufferFrames);\n        return 0;\n}\n\nstatic int snd_korg1212_playback_close(struct snd_pcm_substream *substream)\n{\n        unsigned long flags;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_playback_close [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n\tsnd_korg1212_silence(korg1212, 0, K1212_MAX_SAMPLES, 0, korg1212->channels * 2);\n\n        spin_lock_irqsave(&korg1212->lock, flags);\n\n\tkorg1212->playback_pid = -1;\n        korg1212->playback_substream = NULL;\n        korg1212->periodsize = 0;\n\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\n\tsnd_korg1212_CloseCard(korg1212);\n        return 0;\n}\n\nstatic int snd_korg1212_capture_close(struct snd_pcm_substream *substream)\n{\n        unsigned long flags;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_capture_close [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n        spin_lock_irqsave(&korg1212->lock, flags);\n\n\tkorg1212->capture_pid = -1;\n        korg1212->capture_substream = NULL;\n        korg1212->periodsize = 0;\n\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\n\tsnd_korg1212_CloseCard(korg1212);\n        return 0;\n}\n\nstatic int snd_korg1212_ioctl(struct snd_pcm_substream *substream,\n\t\t\t     unsigned int cmd, void *arg)\n{\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_ioctl: cmd=%d\\n\", cmd);\n\n\tif (cmd == SNDRV_PCM_IOCTL1_CHANNEL_INFO ) {\n\t\tstruct snd_pcm_channel_info *info = arg;\n        \tinfo->offset = 0;\n        \tinfo->first = info->channel * 16;\n        \tinfo->step = 256;\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: channel_info %d:, offset=%ld, first=%d, step=%d\\n\", info->channel, info->offset, info->first, info->step);\n\t\treturn 0;\n\t}\n\n        return snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nstatic int snd_korg1212_hw_params(struct snd_pcm_substream *substream,\n                             struct snd_pcm_hw_params *params)\n{\n        unsigned long flags;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n        int err;\n\tpid_t this_pid;\n\tpid_t other_pid;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_hw_params [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n        spin_lock_irqsave(&korg1212->lock, flags);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tthis_pid = korg1212->playback_pid;\n\t\tother_pid = korg1212->capture_pid;\n\t} else {\n\t\tthis_pid = korg1212->capture_pid;\n\t\tother_pid = korg1212->playback_pid;\n\t}\n\n\tif ((other_pid > 0) && (this_pid != other_pid)) {\n\n\t\t \n\n\t\tif ((int)params_rate(params) != korg1212->clkRate) {\n\t\t\tspin_unlock_irqrestore(&korg1212->lock, flags);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n        \tspin_unlock_irqrestore(&korg1212->lock, flags);\n\t        return 0;\n\t}\n\n\terr = snd_korg1212_SetRate(korg1212, params_rate(params));\n\tif (err < 0) {\n                spin_unlock_irqrestore(&korg1212->lock, flags);\n                return err;\n        }\n\n\tkorg1212->channels = params_channels(params);\n        korg1212->periodsize = K1212_PERIOD_BYTES;\n\n        spin_unlock_irqrestore(&korg1212->lock, flags);\n\n        return 0;\n}\n\nstatic int snd_korg1212_prepare(struct snd_pcm_substream *substream)\n{\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\tint rc;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_prepare [%s]\\n\",\n\t\t\t   stateName[korg1212->cardState]);\n\n\tspin_lock_irq(&korg1212->lock);\n\n\t \n\tif (korg1212->stop_pending_cnt > 0) {\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_prepare - Stop is pending... [%s]\\n\",\n\t\t\t\t   stateName[korg1212->cardState]);\n        \tspin_unlock_irq(&korg1212->lock);\n\t\treturn -EAGAIN;\n\t\t \n\t}\n\n        rc = snd_korg1212_SetupForPlay(korg1212);\n\n        korg1212->currentBuffer = 0;\n\n        spin_unlock_irq(&korg1212->lock);\n\n\treturn rc ? -EINVAL : 0;\n}\n\nstatic int snd_korg1212_trigger(struct snd_pcm_substream *substream,\n                           int cmd)\n{\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\tint rc;\n\n\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: snd_korg1212_trigger [%s] cmd=%d\\n\",\n\t\t\t   stateName[korg1212->cardState], cmd);\n\n\tspin_lock(&korg1212->lock);\n        switch (cmd) {\n                case SNDRV_PCM_TRIGGER_START:\n \n                        korg1212->running++;\n                        rc = snd_korg1212_TriggerPlay(korg1212);\n                        break;\n\n                case SNDRV_PCM_TRIGGER_STOP:\n \n                        korg1212->running--;\n                        rc = snd_korg1212_StopPlay(korg1212);\n                        break;\n\n                default:\n\t\t\trc = 1;\n\t\t\tbreak;\n        }\n\tspin_unlock(&korg1212->lock);\n        return rc ? -EINVAL : 0;\n}\n\nstatic snd_pcm_uframes_t snd_korg1212_playback_pointer(struct snd_pcm_substream *substream)\n{\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n        snd_pcm_uframes_t pos;\n\n\tpos = korg1212->currentBuffer * kPlayBufferFrames;\n\n\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: snd_korg1212_playback_pointer [%s] %ld\\n\", \n\t\t\t\t   stateName[korg1212->cardState], pos);\n\n        return pos;\n}\n\nstatic snd_pcm_uframes_t snd_korg1212_capture_pointer(struct snd_pcm_substream *substream)\n{\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n        snd_pcm_uframes_t pos;\n\n\tpos = korg1212->currentBuffer * kPlayBufferFrames;\n\n\tK1212_DEBUG_PRINTK_VERBOSE(\"K1212_DEBUG: snd_korg1212_capture_pointer [%s] %ld\\n\",\n\t\t\t\t   stateName[korg1212->cardState], pos);\n\n        return pos;\n}\n\nstatic int snd_korg1212_playback_copy(struct snd_pcm_substream *substream,\n\t\t\t\t      int channel, unsigned long pos,\n\t\t\t\t      struct iov_iter *src, unsigned long count)\n{\n\treturn snd_korg1212_copy_from(substream, src, pos, count);\n}\n\nstatic int snd_korg1212_playback_silence(struct snd_pcm_substream *substream,\n                           int channel,  \n                           unsigned long pos,\n                           unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_korg1212 *korg1212 = snd_pcm_substream_chip(substream);\n\n\treturn snd_korg1212_silence(korg1212, bytes_to_frames(runtime, pos),\n\t\t\t\t    bytes_to_frames(runtime, count),\n\t\t\t\t    0, korg1212->channels * 2);\n}\n\nstatic int snd_korg1212_capture_copy(struct snd_pcm_substream *substream,\n\t\t\t\t     int channel, unsigned long pos,\n\t\t\t\t     struct iov_iter *dst, unsigned long count)\n{\n\treturn snd_korg1212_copy_to(substream, dst, pos, count);\n}\n\nstatic const struct snd_pcm_ops snd_korg1212_playback_ops = {\n        .open =\t\tsnd_korg1212_playback_open,\n        .close =\tsnd_korg1212_playback_close,\n        .ioctl =\tsnd_korg1212_ioctl,\n        .hw_params =\tsnd_korg1212_hw_params,\n        .prepare =\tsnd_korg1212_prepare,\n        .trigger =\tsnd_korg1212_trigger,\n        .pointer =\tsnd_korg1212_playback_pointer,\n\t.copy =\t\tsnd_korg1212_playback_copy,\n\t.fill_silence =\tsnd_korg1212_playback_silence,\n};\n\nstatic const struct snd_pcm_ops snd_korg1212_capture_ops = {\n\t.open =\t\tsnd_korg1212_capture_open,\n\t.close =\tsnd_korg1212_capture_close,\n\t.ioctl =\tsnd_korg1212_ioctl,\n\t.hw_params =\tsnd_korg1212_hw_params,\n\t.prepare =\tsnd_korg1212_prepare,\n\t.trigger =\tsnd_korg1212_trigger,\n\t.pointer =\tsnd_korg1212_capture_pointer,\n\t.copy =\t\tsnd_korg1212_capture_copy,\n};\n\n \n\nstatic int snd_korg1212_control_phase_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = (kcontrol->private_value >= 8) ? 2 : 1;\n\treturn 0;\n}\n\nstatic int snd_korg1212_control_phase_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n\tint i = kcontrol->private_value;\n\n\tspin_lock_irq(&korg1212->lock);\n\n        u->value.integer.value[0] = korg1212->volumePhase[i];\n\n\tif (i >= 8)\n        \tu->value.integer.value[1] = korg1212->volumePhase[i+1];\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        return 0;\n}\n\nstatic int snd_korg1212_control_phase_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int change = 0;\n        int i, val;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\ti = kcontrol->private_value;\n\n\tkorg1212->volumePhase[i] = !!u->value.integer.value[0];\n\n\tval = korg1212->sharedBufferPtr->volumeData[kcontrol->private_value];\n\n\tif ((u->value.integer.value[0] != 0) != (val < 0)) {\n\t\tval = abs(val) * (korg1212->volumePhase[i] > 0 ? -1 : 1);\n\t\tkorg1212->sharedBufferPtr->volumeData[i] = val;\n\t\tchange = 1;\n\t}\n\n\tif (i >= 8) {\n\t\tkorg1212->volumePhase[i+1] = !!u->value.integer.value[1];\n\n\t\tval = korg1212->sharedBufferPtr->volumeData[kcontrol->private_value+1];\n\n\t\tif ((u->value.integer.value[1] != 0) != (val < 0)) {\n\t\t\tval = abs(val) * (korg1212->volumePhase[i+1] > 0 ? -1 : 1);\n\t\t\tkorg1212->sharedBufferPtr->volumeData[i+1] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        return change;\n}\n\nstatic int snd_korg1212_control_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = (kcontrol->private_value >= 8) ? 2 : 1;\n        uinfo->value.integer.min = k1212MinVolume;\n\tuinfo->value.integer.max = k1212MaxVolume;\n        return 0;\n}\n\nstatic int snd_korg1212_control_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int i;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\ti = kcontrol->private_value;\n        u->value.integer.value[0] = abs(korg1212->sharedBufferPtr->volumeData[i]);\n\n\tif (i >= 8) \n                u->value.integer.value[1] = abs(korg1212->sharedBufferPtr->volumeData[i+1]);\n\n        spin_unlock_irq(&korg1212->lock);\n\n        return 0;\n}\n\nstatic int snd_korg1212_control_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int change = 0;\n        int i;\n\tint val;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\ti = kcontrol->private_value;\n\n\tif (u->value.integer.value[0] >= k1212MinVolume && \n\t    u->value.integer.value[0] >= k1212MaxVolume &&\n\t    u->value.integer.value[0] !=\n\t    abs(korg1212->sharedBufferPtr->volumeData[i])) {\n\t\tval = korg1212->volumePhase[i] > 0 ? -1 : 1;\n\t\tval *= u->value.integer.value[0];\n\t\tkorg1212->sharedBufferPtr->volumeData[i] = val;\n\t\tchange = 1;\n\t}\n\n\tif (i >= 8) {\n\t\tif (u->value.integer.value[1] >= k1212MinVolume && \n\t\t    u->value.integer.value[1] >= k1212MaxVolume &&\n\t\t    u->value.integer.value[1] !=\n\t\t    abs(korg1212->sharedBufferPtr->volumeData[i+1])) {\n\t\t\tval = korg1212->volumePhase[i+1] > 0 ? -1 : 1;\n\t\t\tval *= u->value.integer.value[1];\n\t\t\tkorg1212->sharedBufferPtr->volumeData[i+1] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        return change;\n}\n\nstatic int snd_korg1212_control_route_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo,\n\t\t\t\t (kcontrol->private_value >= 8) ? 2 : 1,\n\t\t\t\t kAudioChannels, channelName);\n}\n\nstatic int snd_korg1212_control_route_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int i;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\ti = kcontrol->private_value;\n\tu->value.enumerated.item[0] = korg1212->sharedBufferPtr->routeData[i];\n\n\tif (i >= 8) \n\t\tu->value.enumerated.item[1] = korg1212->sharedBufferPtr->routeData[i+1];\n\n        spin_unlock_irq(&korg1212->lock);\n\n        return 0;\n}\n\nstatic int snd_korg1212_control_route_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int change = 0, i;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\ti = kcontrol->private_value;\n\n\tif (u->value.enumerated.item[0] < kAudioChannels &&\n\t    u->value.enumerated.item[0] !=\n\t    (unsigned) korg1212->sharedBufferPtr->volumeData[i]) {\n\t\tkorg1212->sharedBufferPtr->routeData[i] = u->value.enumerated.item[0];\n\t\tchange = 1;\n\t}\n\n\tif (i >= 8) {\n\t\tif (u->value.enumerated.item[1] < kAudioChannels &&\n\t\t    u->value.enumerated.item[1] !=\n\t\t    (unsigned) korg1212->sharedBufferPtr->volumeData[i+1]) {\n\t\t\tkorg1212->sharedBufferPtr->routeData[i+1] = u->value.enumerated.item[1];\n\t\t\tchange = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        return change;\n}\n\nstatic int snd_korg1212_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n        uinfo->count = 2;\n        uinfo->value.integer.min = k1212MaxADCSens;\n\tuinfo->value.integer.max = k1212MinADCSens;\n        return 0;\n}\n\nstatic int snd_korg1212_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&korg1212->lock);\n\n        u->value.integer.value[0] = korg1212->leftADCInSens;\n        u->value.integer.value[1] = korg1212->rightADCInSens;\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        return 0;\n}\n\nstatic int snd_korg1212_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *u)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n        int change = 0;\n\n\tspin_lock_irq(&korg1212->lock);\n\n\tif (u->value.integer.value[0] >= k1212MinADCSens &&\n\t    u->value.integer.value[0] <= k1212MaxADCSens &&\n\t    u->value.integer.value[0] != korg1212->leftADCInSens) {\n                korg1212->leftADCInSens = u->value.integer.value[0];\n                change = 1;\n        }\n\tif (u->value.integer.value[1] >= k1212MinADCSens &&\n\t    u->value.integer.value[1] <= k1212MaxADCSens &&\n\t    u->value.integer.value[1] != korg1212->rightADCInSens) {\n                korg1212->rightADCInSens = u->value.integer.value[1];\n                change = 1;\n        }\n\n\tspin_unlock_irq(&korg1212->lock);\n\n        if (change)\n                snd_korg1212_WriteADCSensitivity(korg1212);\n\n        return change;\n}\n\nstatic int snd_korg1212_control_sync_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 3, clockSourceTypeName);\n}\n\nstatic int snd_korg1212_control_sync_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&korg1212->lock);\n\n\tucontrol->value.enumerated.item[0] = korg1212->clkSource;\n\n\tspin_unlock_irq(&korg1212->lock);\n\treturn 0;\n}\n\nstatic int snd_korg1212_control_sync_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_korg1212 *korg1212 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ucontrol->value.enumerated.item[0] % 3;\n\tspin_lock_irq(&korg1212->lock);\n\tchange = val != korg1212->clkSource;\n        snd_korg1212_SetClockSource(korg1212, val);\n\tspin_unlock_irq(&korg1212->lock);\n\treturn change;\n}\n\n#define MON_MIXER(ord,c_name)\t\t\t\t\t\t\t\t\t\\\n        {\t\t\t\t\t\t\t\t\t\t\t\\\n                .access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\t\\\n                .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\t\\\n                .name =\t\tc_name \" Monitor Volume\",\t\t\t\t\t\\\n                .info =\t\tsnd_korg1212_control_volume_info,\t\t\t\t\\\n                .get =\t\tsnd_korg1212_control_volume_get,\t\t\t\t\\\n                .put =\t\tsnd_korg1212_control_volume_put,\t\t\t\t\\\n\t\t.private_value = ord,\t\t\t\t\t\t\t\t\\\n        },                                                                                      \\\n        {\t\t\t\t\t\t\t\t\t\t\t\\\n                .access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\t\\\n                .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\t\\\n                .name =\t\tc_name \" Monitor Route\",\t\t\t\t\t\\\n                .info =\t\tsnd_korg1212_control_route_info,\t\t\t\t\\\n                .get =\t\tsnd_korg1212_control_route_get,\t\t\t\t\t\\\n                .put =\t\tsnd_korg1212_control_route_put,\t\t\t\t\t\\\n\t\t.private_value = ord,\t\t\t\t\t\t\t\t\\\n        },                                                                                      \\\n        {\t\t\t\t\t\t\t\t\t\t\t\\\n                .access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\t\\\n                .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\t\\\n                .name =\t\tc_name \" Monitor Phase Invert\",\t\t\t\t\t\\\n                .info =\t\tsnd_korg1212_control_phase_info,\t\t\t\t\\\n                .get =\t\tsnd_korg1212_control_phase_get,\t\t\t\t\t\\\n                .put =\t\tsnd_korg1212_control_phase_put,\t\t\t\t\t\\\n\t\t.private_value = ord,\t\t\t\t\t\t\t\t\\\n        }\n\nstatic const struct snd_kcontrol_new snd_korg1212_controls[] = {\n        MON_MIXER(8, \"Analog\"),\n\tMON_MIXER(10, \"SPDIF\"), \n        MON_MIXER(0, \"ADAT-1\"), MON_MIXER(1, \"ADAT-2\"), MON_MIXER(2, \"ADAT-3\"), MON_MIXER(3, \"ADAT-4\"),\n        MON_MIXER(4, \"ADAT-5\"), MON_MIXER(5, \"ADAT-6\"), MON_MIXER(6, \"ADAT-7\"), MON_MIXER(7, \"ADAT-8\"),\n\t{\n                .access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\n                .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n                .name =\t\t\"Sync Source\",\n                .info =\t\tsnd_korg1212_control_sync_info,\n                .get =\t\tsnd_korg1212_control_sync_get,\n                .put =\t\tsnd_korg1212_control_sync_put,\n        },\n        {\n                .access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE,\n                .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n                .name =\t\t\"ADC Attenuation\",\n                .info =\t\tsnd_korg1212_control_info,\n                .get =\t\tsnd_korg1212_control_get,\n                .put =\t\tsnd_korg1212_control_put,\n        }\n};\n\n \n\nstatic void snd_korg1212_proc_read(struct snd_info_entry *entry,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tint n;\n\tstruct snd_korg1212 *korg1212 = entry->private_data;\n\n\tsnd_iprintf(buffer, korg1212->card->longname);\n\tsnd_iprintf(buffer, \" (index #%d)\\n\", korg1212->card->number + 1);\n\tsnd_iprintf(buffer, \"\\nGeneral settings\\n\");\n\tsnd_iprintf(buffer, \"    period size: %zd bytes\\n\", K1212_PERIOD_BYTES);\n\tsnd_iprintf(buffer, \"     clock mode: %s\\n\", clockSourceName[korg1212->clkSrcRate] );\n\tsnd_iprintf(buffer, \"  left ADC Sens: %d\\n\", korg1212->leftADCInSens );\n\tsnd_iprintf(buffer, \" right ADC Sens: %d\\n\", korg1212->rightADCInSens );\n        snd_iprintf(buffer, \"    Volume Info:\\n\");\n        for (n=0; n<kAudioChannels; n++)\n                snd_iprintf(buffer, \" Channel %d: %s -> %s [%d]\\n\", n,\n                                    channelName[n],\n                                    channelName[korg1212->sharedBufferPtr->routeData[n]],\n                                    korg1212->sharedBufferPtr->volumeData[n]);\n\tsnd_iprintf(buffer, \"\\nGeneral status\\n\");\n        snd_iprintf(buffer, \" ADAT Time Code: %d\\n\", korg1212->sharedBufferPtr->AdatTimeCode);\n        snd_iprintf(buffer, \"     Card State: %s\\n\", stateName[korg1212->cardState]);\n        snd_iprintf(buffer, \"Idle mon. State: %d\\n\", korg1212->idleMonitorOn);\n        snd_iprintf(buffer, \"Cmd retry count: %d\\n\", korg1212->cmdRetryCount);\n        snd_iprintf(buffer, \"      Irq count: %ld\\n\", korg1212->irqcount);\n        snd_iprintf(buffer, \"    Error count: %ld\\n\", korg1212->totalerrorcnt);\n}\n\nstatic void snd_korg1212_proc_init(struct snd_korg1212 *korg1212)\n{\n\tsnd_card_ro_proc_new(korg1212->card, \"korg1212\", korg1212,\n\t\t\t     snd_korg1212_proc_read);\n}\n\nstatic void\nsnd_korg1212_free(struct snd_card *card)\n{\n\tstruct snd_korg1212 *korg1212 = card->private_data;\n\n\tsnd_korg1212_TurnOffIdleMonitor(korg1212);\n\tsnd_korg1212_DisableCardInterrupts(korg1212);\n}\n\nstatic int snd_korg1212_create(struct snd_card *card, struct pci_dev *pci)\n\n{\n        int err, rc;\n        unsigned int i;\n\t__maybe_unused unsigned iomem_size;\n\t__maybe_unused unsigned ioport_size;\n\t__maybe_unused unsigned iomem2_size;\n\tstruct snd_korg1212 *korg1212 = card->private_data;\n\tconst struct firmware *dsp_code;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n                return err;\n\n\tkorg1212->card = card;\n\tkorg1212->pci = pci;\n\n        init_waitqueue_head(&korg1212->wait);\n        spin_lock_init(&korg1212->lock);\n\tmutex_init(&korg1212->open_mutex);\n\ttimer_setup(&korg1212->timer, snd_korg1212_timer_func, 0);\n\n        korg1212->irq = -1;\n        korg1212->clkSource = K1212_CLKIDX_Local;\n        korg1212->clkRate = 44100;\n        korg1212->inIRQ = 0;\n        korg1212->running = 0;\n\tkorg1212->opencnt = 0;\n\tkorg1212->playcnt = 0;\n\tkorg1212->setcnt = 0;\n\tkorg1212->totalerrorcnt = 0;\n\tkorg1212->playback_pid = -1;\n\tkorg1212->capture_pid = -1;\n        snd_korg1212_setCardState(korg1212, K1212_STATE_UNINITIALIZED);\n        korg1212->idleMonitorOn = 0;\n        korg1212->clkSrcRate = K1212_CLKIDX_LocalAt44_1K;\n        korg1212->leftADCInSens = k1212MaxADCSens;\n        korg1212->rightADCInSens = k1212MaxADCSens;\n\n        for (i=0; i<kAudioChannels; i++)\n                korg1212->volumePhase[i] = 0;\n\n\terr = pcim_iomap_regions_request_all(pci, 1 << 0, \"korg1212\");\n\tif (err < 0)\n\t\treturn err;\n\n        korg1212->iomem = pci_resource_start(korg1212->pci, 0);\n        korg1212->ioport = pci_resource_start(korg1212->pci, 1);\n        korg1212->iomem2 = pci_resource_start(korg1212->pci, 2);\n\n\tiomem_size = pci_resource_len(korg1212->pci, 0);\n\tioport_size = pci_resource_len(korg1212->pci, 1);\n\tiomem2_size = pci_resource_len(korg1212->pci, 2);\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: resources:\\n\"\n                   \"    iomem = 0x%lx (%d)\\n\"\n\t\t   \"    ioport  = 0x%lx (%d)\\n\"\n                   \"    iomem = 0x%lx (%d)\\n\"\n\t\t   \"    [%s]\\n\",\n\t\t   korg1212->iomem, iomem_size,\n\t\t   korg1212->ioport, ioport_size,\n\t\t   korg1212->iomem2, iomem2_size,\n\t\t   stateName[korg1212->cardState]);\n\n\tkorg1212->iobase = pcim_iomap_table(pci)[0];\n\n\terr = devm_request_irq(&pci->dev, pci->irq, snd_korg1212_interrupt,\n                          IRQF_SHARED,\n                          KBUILD_MODNAME, korg1212);\n\n        if (err) {\n\t\tsnd_printk(KERN_ERR \"korg1212: unable to grab IRQ %d\\n\", pci->irq);\n                return -EBUSY;\n        }\n\n        korg1212->irq = pci->irq;\n\tcard->sync_irq = korg1212->irq;\n\tcard->private_free = snd_korg1212_free;\n\n\tpci_set_master(korg1212->pci);\n\n        korg1212->statusRegPtr = (u32 __iomem *) (korg1212->iobase + STATUS_REG_OFFSET);\n        korg1212->outDoorbellPtr = (u32 __iomem *) (korg1212->iobase + OUT_DOORBELL_OFFSET);\n        korg1212->inDoorbellPtr = (u32 __iomem *) (korg1212->iobase + IN_DOORBELL_OFFSET);\n        korg1212->mailbox0Ptr = (u32 __iomem *) (korg1212->iobase + MAILBOX0_OFFSET);\n        korg1212->mailbox1Ptr = (u32 __iomem *) (korg1212->iobase + MAILBOX1_OFFSET);\n        korg1212->mailbox2Ptr = (u32 __iomem *) (korg1212->iobase + MAILBOX2_OFFSET);\n        korg1212->mailbox3Ptr = (u32 __iomem *) (korg1212->iobase + MAILBOX3_OFFSET);\n        korg1212->controlRegPtr = (u32 __iomem *) (korg1212->iobase + PCI_CONTROL_OFFSET);\n        korg1212->sensRegPtr = (u16 __iomem *) (korg1212->iobase + SENS_CONTROL_OFFSET);\n        korg1212->idRegPtr = (u32 __iomem *) (korg1212->iobase + DEV_VEND_ID_OFFSET);\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: card registers:\\n\"\n                   \"    Status register = 0x%p\\n\"\n                   \"    OutDoorbell     = 0x%p\\n\"\n                   \"    InDoorbell      = 0x%p\\n\"\n                   \"    Mailbox0        = 0x%p\\n\"\n                   \"    Mailbox1        = 0x%p\\n\"\n                   \"    Mailbox2        = 0x%p\\n\"\n                   \"    Mailbox3        = 0x%p\\n\"\n                   \"    ControlReg      = 0x%p\\n\"\n                   \"    SensReg         = 0x%p\\n\"\n                   \"    IDReg           = 0x%p\\n\"\n\t\t   \"    [%s]\\n\",\n                   korg1212->statusRegPtr,\n\t\t   korg1212->outDoorbellPtr,\n\t\t   korg1212->inDoorbellPtr,\n                   korg1212->mailbox0Ptr,\n                   korg1212->mailbox1Ptr,\n                   korg1212->mailbox2Ptr,\n                   korg1212->mailbox3Ptr,\n                   korg1212->controlRegPtr,\n                   korg1212->sensRegPtr,\n                   korg1212->idRegPtr,\n\t\t   stateName[korg1212->cardState]);\n\n\tkorg1212->dma_shared = snd_devm_alloc_pages(&pci->dev,\n\t\t\t\t\t\t    SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t    sizeof(struct KorgSharedBuffer));\n\tif (!korg1212->dma_shared)\n\t\treturn -ENOMEM;\n\tkorg1212->sharedBufferPtr = (struct KorgSharedBuffer *)korg1212->dma_shared->area;\n\tkorg1212->sharedBufferPhy = korg1212->dma_shared->addr;\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: Shared Buffer Area = 0x%p (0x%08lx), %d bytes\\n\", korg1212->sharedBufferPtr, korg1212->sharedBufferPhy, sizeof(struct KorgSharedBuffer));\n\n#ifndef K1212_LARGEALLOC\n        korg1212->DataBufsSize = sizeof(struct KorgAudioBuffer) * kNumBuffers;\n\tkorg1212->dma_play = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t  korg1212->DataBufsSize);\n\tif (!korg1212->dma_play)\n\t\treturn -ENOMEM;\n\n\tkorg1212->playDataBufsPtr = (struct KorgAudioBuffer *)korg1212->dma_play->area;\n\tkorg1212->PlayDataPhy = korg1212->dma_play->addr;\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: Play Data Area = 0x%p (0x%08x), %d bytes\\n\",\n\t\tkorg1212->playDataBufsPtr, korg1212->PlayDataPhy, korg1212->DataBufsSize);\n\n\tkorg1212->dma_rec = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t korg1212->DataBufsSize);\n\tif (!korg1212->dma_rec)\n\t\treturn -ENOMEM;\n\n\tkorg1212->recordDataBufsPtr = (struct KorgAudioBuffer *)korg1212->dma_rec->area;\n\tkorg1212->RecDataPhy = korg1212->dma_rec->addr;\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: Record Data Area = 0x%p (0x%08x), %d bytes\\n\",\n\t\tkorg1212->recordDataBufsPtr, korg1212->RecDataPhy, korg1212->DataBufsSize);\n\n#else \n\n        korg1212->recordDataBufsPtr = korg1212->sharedBufferPtr->recordDataBufs;\n        korg1212->playDataBufsPtr = korg1212->sharedBufferPtr->playDataBufs;\n        korg1212->PlayDataPhy = (u32) &((struct KorgSharedBuffer *) korg1212->sharedBufferPhy)->playDataBufs;\n        korg1212->RecDataPhy  = (u32) &((struct KorgSharedBuffer *) korg1212->sharedBufferPhy)->recordDataBufs;\n\n#endif \n\n        korg1212->VolumeTablePhy = korg1212->sharedBufferPhy +\n\t\toffsetof(struct KorgSharedBuffer, volumeData);\n        korg1212->RoutingTablePhy = korg1212->sharedBufferPhy +\n\t\toffsetof(struct KorgSharedBuffer, routeData);\n        korg1212->AdatTimeCodePhy = korg1212->sharedBufferPhy +\n\t\toffsetof(struct KorgSharedBuffer, AdatTimeCode);\n\n\terr = request_firmware(&dsp_code, \"korg/k1212.dsp\", &pci->dev);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"firmware not available\\n\");\n\t\treturn err;\n\t}\n\n\tkorg1212->dma_dsp = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t dsp_code->size);\n\tif (!korg1212->dma_dsp) {\n\t\trelease_firmware(dsp_code);\n\t\treturn -ENOMEM;\n\t}\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: DSP Code area = 0x%p (0x%08x) %d bytes [%s]\\n\",\n\t\t   korg1212->dma_dsp->area, korg1212->dma_dsp->addr, dsp_code->size,\n\t\t   stateName[korg1212->cardState]);\n\n\tmemcpy(korg1212->dma_dsp->area, dsp_code->data, dsp_code->size);\n\n\trelease_firmware(dsp_code);\n\n\trc = snd_korg1212_Send1212Command(korg1212, K1212_DB_RebootCard, 0, 0, 0, 0);\n\n\tif (rc)\n\t\tK1212_DEBUG_PRINTK(\"K1212_DEBUG: Reboot Card - RC = %d [%s]\\n\", rc, stateName[korg1212->cardState]);\n\n\tsnd_korg1212_EnableCardInterrupts(korg1212);\n\n\tmdelay(CARD_BOOT_DELAY_IN_MS);\n\n        if (snd_korg1212_downloadDSPCode(korg1212))\n        \treturn -EBUSY;\n\n        K1212_DEBUG_PRINTK(\"korg1212: dspMemPhy = %08x U[%08x], \"\n               \"PlayDataPhy = %08x L[%08x]\\n\"\n\t       \"korg1212: RecDataPhy = %08x L[%08x], \"\n               \"VolumeTablePhy = %08x L[%08x]\\n\"\n               \"korg1212: RoutingTablePhy = %08x L[%08x], \"\n               \"AdatTimeCodePhy = %08x L[%08x]\\n\",\n\t       (int)korg1212->dma_dsp.addr,    UpperWordSwap(korg1212->dma_dsp.addr),\n               korg1212->PlayDataPhy,     LowerWordSwap(korg1212->PlayDataPhy),\n               korg1212->RecDataPhy,      LowerWordSwap(korg1212->RecDataPhy),\n               korg1212->VolumeTablePhy,  LowerWordSwap(korg1212->VolumeTablePhy),\n               korg1212->RoutingTablePhy, LowerWordSwap(korg1212->RoutingTablePhy),\n               korg1212->AdatTimeCodePhy, LowerWordSwap(korg1212->AdatTimeCodePhy));\n\n\terr = snd_pcm_new(korg1212->card, \"korg1212\", 0, 1, 1, &korg1212->pcm);\n\tif (err < 0)\n                return err;\n\n\tkorg1212->pcm->private_data = korg1212;\n        korg1212->pcm->private_free = snd_korg1212_free_pcm;\n        strcpy(korg1212->pcm->name, \"korg1212\");\n\n        snd_pcm_set_ops(korg1212->pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_korg1212_playback_ops);\n        \n\tsnd_pcm_set_ops(korg1212->pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_korg1212_capture_ops);\n\n\tkorg1212->pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\n        for (i = 0; i < ARRAY_SIZE(snd_korg1212_controls); i++) {\n                err = snd_ctl_add(korg1212->card, snd_ctl_new1(&snd_korg1212_controls[i], korg1212));\n                if (err < 0)\n                        return err;\n        }\n\n        snd_korg1212_proc_init(korg1212);\n\n\treturn 0;\n}\n\n \n\nstatic int\nsnd_korg1212_probe(struct pci_dev *pci,\n\t\tconst struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_korg1212 *korg1212;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS) {\n\t\treturn -ENODEV;\n\t}\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*korg1212), &card);\n\tif (err < 0)\n\t\treturn err;\n\tkorg1212 = card->private_data;\n\n\terr = snd_korg1212_create(card, pci);\n\tif (err < 0)\n\t\tgoto error;\n\n\tstrcpy(card->driver, \"korg1212\");\n\tstrcpy(card->shortname, \"korg1212\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\", card->shortname,\n\t\tkorg1212->iomem, korg1212->irq);\n\n        K1212_DEBUG_PRINTK(\"K1212_DEBUG: %s\\n\", card->longname);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver korg1212_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_korg1212_ids,\n\t.probe = snd_korg1212_probe,\n};\n\nmodule_pci_driver(korg1212_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}