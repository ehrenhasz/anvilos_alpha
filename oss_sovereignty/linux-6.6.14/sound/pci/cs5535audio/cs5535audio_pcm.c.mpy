{
  "module_name": "cs5535audio_pcm.c",
  "hash_id": "9ac73b527760cad2900b3c15450707888f9188cb4fc3c65fc3ec9204b49bcb71",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs5535audio/cs5535audio_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/ac97_codec.h>\n#include \"cs5535audio.h\"\n\nstatic const struct snd_pcm_hardware snd_cs5535audio_playback =\n{\n\t.info =\t\t\t(\n\t\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t \t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t \t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t \t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\tSNDRV_PCM_INFO_RESUME\n\t\t\t\t),\n\t.formats =\t\t(\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE\n\t\t\t\t),\n\t.rates =\t\t(\n\t\t\t\tSNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t\tSNDRV_PCM_RATE_8000_48000\n\t\t\t\t),\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(64*1024 - 16),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\tCS5535AUDIO_MAX_DESCRIPTORS,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_cs5535audio_capture =\n{\n\t.info =\t\t\t(\n\t\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t \t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t \t\tSNDRV_PCM_INFO_MMAP_VALID\n\t\t\t\t),\n\t.formats =\t\t(\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE\n\t\t\t\t),\n\t.rates =\t\t(\n\t\t\t\tSNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t\tSNDRV_PCM_RATE_8000_48000\n\t\t\t\t),\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(64*1024 - 16),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\tCS5535AUDIO_MAX_DESCRIPTORS,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_cs5535audio_playback_open(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_cs5535audio_playback;\n\truntime->hw.rates = cs5535au->ac97->rates[AC97_RATES_FRONT_DAC];\n\tsnd_pcm_limit_hw_rates(runtime);\n\tcs5535au->playback_substream = substream;\n\truntime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK]);\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_playback_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n#define CS5535AUDIO_DESC_LIST_SIZE \\\n\tPAGE_ALIGN(CS5535AUDIO_MAX_DESCRIPTORS * sizeof(struct cs5535audio_dma_desc))\n\nstatic int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,\n\t\t\t\t\t struct cs5535audio_dma *dma,\n\t\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t\t unsigned int periods,\n\t\t\t\t\t unsigned int period_bytes)\n{\n\tunsigned int i;\n\tu32 addr, jmpprd_addr;\n\tstruct cs5535audio_dma_desc *lastdesc;\n\n\tif (periods > CS5535AUDIO_MAX_DESCRIPTORS)\n\t\treturn -ENOMEM;\n\n\tif (dma->desc_buf.area == NULL) {\n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t&cs5535au->pci->dev,\n\t\t\t\t\tCS5535AUDIO_DESC_LIST_SIZE+1,\n\t\t\t\t\t&dma->desc_buf) < 0)\n\t\t\treturn -ENOMEM;\n\t\tdma->period_bytes = dma->periods = 0;\n\t}\n\n\tif (dma->periods == periods && dma->period_bytes == period_bytes)\n\t\treturn 0;\n\n\t \n\taddr = (u32) substream->runtime->dma_addr;\n\tfor (i = 0; i < periods; i++) {\n\t\tstruct cs5535audio_dma_desc *desc =\n\t\t\t&((struct cs5535audio_dma_desc *) dma->desc_buf.area)[i];\n\t\tdesc->addr = cpu_to_le32(addr);\n\t\tdesc->size = cpu_to_le16(period_bytes);\n\t\tdesc->ctlreserved = cpu_to_le16(PRD_EOP);\n\t\taddr += period_bytes;\n\t}\n\t \n\tlastdesc = &((struct cs5535audio_dma_desc *) dma->desc_buf.area)[periods];\n\tlastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);\n\tlastdesc->size = 0;\n\tlastdesc->ctlreserved = cpu_to_le16(PRD_JMP);\n\tjmpprd_addr = (u32)dma->desc_buf.addr +\n\t\tsizeof(struct cs5535audio_dma_desc) * periods;\n\n\tdma->substream = substream;\n\tdma->period_bytes = period_bytes;\n\tdma->periods = periods;\n\tspin_lock_irq(&cs5535au->reg_lock);\n\tdma->ops->disable_dma(cs5535au);\n\tdma->ops->setup_prd(cs5535au, jmpprd_addr);\n\tspin_unlock_irq(&cs5535au->reg_lock);\n\treturn 0;\n}\n\nstatic void cs5535audio_playback_enable_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_EN);\n}\n\nstatic void cs5535audio_playback_disable_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM0_CMD, 0);\n}\n\nstatic void cs5535audio_playback_pause_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_PAUSE);\n}\n\nstatic void cs5535audio_playback_setup_prd(struct cs5535audio *cs5535au,\n\t\t\t\t\t   u32 prd_addr)\n{\n\tcs_writel(cs5535au, ACC_BM0_PRD, prd_addr);\n}\n\nstatic u32 cs5535audio_playback_read_prd(struct cs5535audio *cs5535au)\n{\n\treturn cs_readl(cs5535au, ACC_BM0_PRD);\n}\n\nstatic u32 cs5535audio_playback_read_dma_pntr(struct cs5535audio *cs5535au)\n{\n\treturn cs_readl(cs5535au, ACC_BM0_PNTR);\n}\n\nstatic void cs5535audio_capture_enable_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_EN);\n}\n\nstatic void cs5535audio_capture_disable_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM1_CMD, 0);\n}\n\nstatic void cs5535audio_capture_pause_dma(struct cs5535audio *cs5535au)\n{\n\tcs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_PAUSE);\n}\n\nstatic void cs5535audio_capture_setup_prd(struct cs5535audio *cs5535au,\n\t\t\t\t\t  u32 prd_addr)\n{\n\tcs_writel(cs5535au, ACC_BM1_PRD, prd_addr);\n}\n\nstatic u32 cs5535audio_capture_read_prd(struct cs5535audio *cs5535au)\n{\n\treturn cs_readl(cs5535au, ACC_BM1_PRD);\n}\n\nstatic u32 cs5535audio_capture_read_dma_pntr(struct cs5535audio *cs5535au)\n{\n\treturn cs_readl(cs5535au, ACC_BM1_PNTR);\n}\n\nstatic void cs5535audio_clear_dma_packets(struct cs5535audio *cs5535au,\n\t\t\t\t\t  struct cs5535audio_dma *dma,\n\t\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tsnd_dma_free_pages(&dma->desc_buf);\n\tdma->desc_buf.area = NULL;\n\tdma->substream = NULL;\n}\n\nstatic int snd_cs5535audio_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tstruct cs5535audio_dma *dma = substream->runtime->private_data;\n\tint err;\n\n\tdma->buf_addr = substream->runtime->dma_addr;\n\tdma->buf_bytes = params_buffer_bytes(hw_params);\n\n\terr = cs5535audio_build_dma_packets(cs5535au, dma, substream,\n\t\t\t\t\t    params_periods(hw_params),\n\t\t\t\t\t    params_period_bytes(hw_params));\n\tif (!err)\n\t\tdma->pcm_open_flag = 1;\n\n\treturn err;\n}\n\nstatic int snd_cs5535audio_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tstruct cs5535audio_dma *dma = substream->runtime->private_data;\n\n\tif (dma->pcm_open_flag) {\n\t\tif (substream == cs5535au->playback_substream)\n\t\t\tsnd_ac97_update_power(cs5535au->ac97,\n\t\t\t\t\tAC97_PCM_FRONT_DAC_RATE, 0);\n\t\telse\n\t\t\tsnd_ac97_update_power(cs5535au->ac97,\n\t\t\t\t\tAC97_PCM_LR_ADC_RATE, 0);\n\t\tdma->pcm_open_flag = 0;\n\t}\n\tcs5535audio_clear_dma_packets(cs5535au, dma, substream);\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\treturn snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_FRONT_DAC_RATE,\n\t\t\t\t substream->runtime->rate);\n}\n\nstatic int snd_cs5535audio_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tstruct cs5535audio_dma *dma = substream->runtime->private_data;\n\tint err = 0;\n\n\tspin_lock(&cs5535au->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdma->ops->pause_dma(cs5535au);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdma->ops->enable_dma(cs5535au);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdma->ops->enable_dma(cs5535au);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tdma->ops->enable_dma(cs5535au);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdma->ops->disable_dma(cs5535au);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdma->ops->disable_dma(cs5535au);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs5535au->card->dev, \"unhandled trigger\\n\");\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&cs5535au->reg_lock);\n\treturn err;\n}\n\nstatic snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(struct snd_pcm_substream\n\t\t\t\t\t\t\t*substream)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tu32 curdma;\n\tstruct cs5535audio_dma *dma;\n\n\tdma = substream->runtime->private_data;\n\tcurdma = dma->ops->read_dma_pntr(cs5535au);\n\tif (curdma < dma->buf_addr) {\n\t\tdev_err(cs5535au->card->dev, \"curdma=%x < %x bufaddr.\\n\",\n\t\t\t\t\tcurdma, dma->buf_addr);\n\t\treturn 0;\n\t}\n\tcurdma -= dma->buf_addr;\n\tif (curdma >= dma->buf_bytes) {\n\t\tdev_err(cs5535au->card->dev, \"diff=%x >= %x buf_bytes.\\n\",\n\t\t\t\t\tcurdma, dma->buf_bytes);\n\t\treturn 0;\n\t}\n\treturn bytes_to_frames(substream->runtime, curdma);\n}\n\nstatic int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_cs5535audio_capture;\n\truntime->hw.rates = cs5535au->ac97->rates[AC97_RATES_ADC];\n\tsnd_pcm_limit_hw_rates(runtime);\n\tcs5535au->capture_substream = substream;\n\truntime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_CAPTURE]);\n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\tolpc_capture_open(cs5535au->ac97);\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\tolpc_capture_close(cs5535au->ac97);\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);\n\treturn snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_LR_ADC_RATE,\n\t\t\t\t substream->runtime->rate);\n}\n\nstatic const struct snd_pcm_ops snd_cs5535audio_playback_ops = {\n\t.open =\t\tsnd_cs5535audio_playback_open,\n\t.close =\tsnd_cs5535audio_playback_close,\n\t.hw_params =\tsnd_cs5535audio_hw_params,\n\t.hw_free =\tsnd_cs5535audio_hw_free,\n\t.prepare =\tsnd_cs5535audio_playback_prepare,\n\t.trigger =\tsnd_cs5535audio_trigger,\n\t.pointer =\tsnd_cs5535audio_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs5535audio_capture_ops = {\n\t.open =\t\tsnd_cs5535audio_capture_open,\n\t.close =\tsnd_cs5535audio_capture_close,\n\t.hw_params =\tsnd_cs5535audio_hw_params,\n\t.hw_free =\tsnd_cs5535audio_hw_free,\n\t.prepare =\tsnd_cs5535audio_capture_prepare,\n\t.trigger =\tsnd_cs5535audio_trigger,\n\t.pointer =\tsnd_cs5535audio_pcm_pointer,\n};\n\nstatic const struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {\n        .type = CS5535AUDIO_DMA_PLAYBACK,\n        .enable_dma = cs5535audio_playback_enable_dma,\n        .disable_dma = cs5535audio_playback_disable_dma,\n        .setup_prd = cs5535audio_playback_setup_prd,\n        .read_prd = cs5535audio_playback_read_prd,\n        .pause_dma = cs5535audio_playback_pause_dma,\n        .read_dma_pntr = cs5535audio_playback_read_dma_pntr,\n};\n\nstatic const struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {\n        .type = CS5535AUDIO_DMA_CAPTURE,\n        .enable_dma = cs5535audio_capture_enable_dma,\n        .disable_dma = cs5535audio_capture_disable_dma,\n        .setup_prd = cs5535audio_capture_setup_prd,\n        .read_prd = cs5535audio_capture_read_prd,\n        .pause_dma = cs5535audio_capture_pause_dma,\n        .read_dma_pntr = cs5535audio_capture_read_dma_pntr,\n};\n\nint snd_cs5535audio_pcm(struct cs5535audio *cs5535au)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(cs5535au->card, \"CS5535 Audio\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tcs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK].ops =\n\t\t\t\t\t&snd_cs5535audio_playback_dma_ops;\n\tcs5535au->dmas[CS5535AUDIO_DMA_CAPTURE].ops =\n\t\t\t\t\t&snd_cs5535audio_capture_dma_ops;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t&snd_cs5535audio_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&snd_cs5535audio_capture_ops);\n\n\tpcm->private_data = cs5535au;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS5535 Audio\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &cs5535au->pci->dev,\n\t\t\t\t       64*1024, 128*1024);\n\tcs5535au->pcm = pcm;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}