{
  "module_name": "cs5535audio.c",
  "hash_id": "7a4b35d5b3e1e2e341e14252f80b37e5cc35fcf0c35564430cdb14c9edbb874e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs5535audio/cs5535audio.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n#include \"cs5535audio.h\"\n\n#define DRIVER_NAME \"cs5535audio\"\n\nstatic char *ac97_quirk;\nmodule_param(ac97_quirk, charp, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 board specific workarounds.\");\n\nstatic const struct ac97_quirk ac97_quirks[] = {\n#if 0  \n\t{\n\t\t.subvendor = PCI_VENDOR_ID_AMD, \n\t\t.subdevice = PCI_DEVICE_ID_AMD_CS5536_AUDIO, \n\t\t.name = \"AMD RDK\",     \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n#endif\n\t{}\n};\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" DRIVER_NAME);\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" DRIVER_NAME);\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" DRIVER_NAME);\n\nstatic const struct pci_device_id snd_cs5535audio_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_CS5535_AUDIO) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_AUDIO) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_cs5535audio_ids);\n\nstatic void wait_till_cmd_acked(struct cs5535audio *cs5535au, unsigned long timeout)\n{\n\tunsigned int tmp;\n\tdo {\n\t\ttmp = cs_readl(cs5535au, ACC_CODEC_CNTL);\n\t\tif (!(tmp & CMD_NEW))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--timeout);\n\tif (!timeout)\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"Failure writing to cs5535 codec\\n\");\n}\n\nstatic unsigned short snd_cs5535audio_codec_read(struct cs5535audio *cs5535au,\n\t\t\t\t\t\t unsigned short reg)\n{\n\tunsigned int regdata;\n\tunsigned int timeout;\n\tunsigned int val;\n\n\tregdata = ((unsigned int) reg) << 24;\n\tregdata |= ACC_CODEC_CNTL_RD_CMD;\n\tregdata |= CMD_NEW;\n\n\tcs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\n\twait_till_cmd_acked(cs5535au, 50);\n\n\ttimeout = 50;\n\tdo {\n\t\tval = cs_readl(cs5535au, ACC_CODEC_STATUS);\n\t\tif ((val & STS_NEW) && reg == (val >> 24))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--timeout);\n\tif (!timeout)\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"Failure reading codec reg 0x%x, Last value=0x%x\\n\",\n\t\t\treg, val);\n\n\treturn (unsigned short) val;\n}\n\nstatic void snd_cs5535audio_codec_write(struct cs5535audio *cs5535au,\n\t\t\t\t\tunsigned short reg, unsigned short val)\n{\n\tunsigned int regdata;\n\n\tregdata = ((unsigned int) reg) << 24;\n\tregdata |= val;\n\tregdata &= CMD_MASK;\n\tregdata |= CMD_NEW;\n\tregdata &= ACC_CODEC_CNTL_WR_CMD;\n\n\tcs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\n\twait_till_cmd_acked(cs5535au, 50);\n}\n\nstatic void snd_cs5535audio_ac97_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t\t     unsigned short reg, unsigned short val)\n{\n\tstruct cs5535audio *cs5535au = ac97->private_data;\n\tsnd_cs5535audio_codec_write(cs5535au, reg, val);\n}\n\nstatic unsigned short snd_cs5535audio_ac97_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t\t      unsigned short reg)\n{\n\tstruct cs5535audio *cs5535au = ac97->private_data;\n\treturn snd_cs5535audio_codec_read(cs5535au, reg);\n}\n\nstatic int snd_cs5535audio_mixer(struct cs5535audio *cs5535au)\n{\n\tstruct snd_card *card = cs5535au->card;\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_cs5535audio_ac97_codec_write,\n\t\t.read = snd_cs5535audio_ac97_codec_read,\n\t};\n\n\terr = snd_ac97_bus(card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM\n\t\t\t| AC97_SCAP_POWER_SAVE;\n\tac97.private_data = cs5535au;\n\tac97.pci = cs5535au->pci;\n\n\t \n\tolpc_prequirks(card, &ac97);\n\n\terr = snd_ac97_mixer(pbus, &ac97, &cs5535au->ac97);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"mixer failed\\n\");\n\t\treturn err;\n\t}\n\n\tsnd_ac97_tune_hardware(cs5535au->ac97, ac97_quirks, ac97_quirk);\n\n\terr = olpc_quirks(card, cs5535au->ac97);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"olpc quirks failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void process_bm0_irq(struct cs5535audio *cs5535au)\n{\n\tu8 bm_stat;\n\tspin_lock(&cs5535au->reg_lock);\n\tbm_stat = cs_readb(cs5535au, ACC_BM0_STATUS);\n\tspin_unlock(&cs5535au->reg_lock);\n\tif (bm_stat & EOP) {\n\t\tsnd_pcm_period_elapsed(cs5535au->playback_substream);\n\t} else {\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"unexpected bm0 irq src, bm_stat=%x\\n\",\n\t\t\tbm_stat);\n\t}\n}\n\nstatic void process_bm1_irq(struct cs5535audio *cs5535au)\n{\n\tu8 bm_stat;\n\tspin_lock(&cs5535au->reg_lock);\n\tbm_stat = cs_readb(cs5535au, ACC_BM1_STATUS);\n\tspin_unlock(&cs5535au->reg_lock);\n\tif (bm_stat & EOP)\n\t\tsnd_pcm_period_elapsed(cs5535au->capture_substream);\n}\n\nstatic irqreturn_t snd_cs5535audio_interrupt(int irq, void *dev_id)\n{\n\tu16 acc_irq_stat;\n\tunsigned char count;\n\tstruct cs5535audio *cs5535au = dev_id;\n\n\tif (cs5535au == NULL)\n\t\treturn IRQ_NONE;\n\n\tacc_irq_stat = cs_readw(cs5535au, ACC_IRQ_STATUS);\n\n\tif (!acc_irq_stat)\n\t\treturn IRQ_NONE;\n\tfor (count = 0; count < 4; count++) {\n\t\tif (acc_irq_stat & (1 << count)) {\n\t\t\tswitch (count) {\n\t\t\tcase IRQ_STS:\n\t\t\t\tcs_readl(cs5535au, ACC_GPIO_STATUS);\n\t\t\t\tbreak;\n\t\t\tcase WU_IRQ_STS:\n\t\t\t\tcs_readl(cs5535au, ACC_GPIO_STATUS);\n\t\t\t\tbreak;\n\t\t\tcase BM0_IRQ_STS:\n\t\t\t\tprocess_bm0_irq(cs5535au);\n\t\t\t\tbreak;\n\t\t\tcase BM1_IRQ_STS:\n\t\t\t\tprocess_bm1_irq(cs5535au);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(cs5535au->card->dev,\n\t\t\t\t\t\"Unexpected irq src: 0x%x\\n\",\n\t\t\t\t\tacc_irq_stat);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void snd_cs5535audio_free(struct snd_card *card)\n{\n\tolpc_quirks_cleanup();\n}\n\nstatic int snd_cs5535audio_create(struct snd_card *card,\n\t\t\t\t  struct pci_dev *pci)\n{\n\tstruct cs5535audio *cs5535au = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32))) {\n\t\tdev_warn(card->dev, \"unable to get 32bit dma\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_init(&cs5535au->reg_lock);\n\tcs5535au->card = card;\n\tcs5535au->pci = pci;\n\tcs5535au->irq = -1;\n\n\terr = pci_request_regions(pci, \"CS5535 Audio\");\n\tif (err < 0)\n\t\treturn err;\n\n\tcs5535au->port = pci_resource_start(pci, 0);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_cs5535audio_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, cs5535au)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\n\tcs5535au->irq = pci->irq;\n\tcard->sync_irq = cs5535au->irq;\n\tpci_set_master(pci);\n\n\treturn 0;\n}\n\nstatic int __snd_cs5535audio_probe(struct pci_dev *pci,\n\t\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct cs5535audio *cs5535au;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*cs5535au), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcs5535au = card->private_data;\n\tcard->private_free = snd_cs5535audio_free;\n\n\terr = snd_cs5535audio_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_cs5535audio_mixer(cs5535au);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_cs5535audio_pcm(cs5535au);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, DRIVER_NAME);\n\n\tstrcpy(card->shortname, \"CS5535 Audio\");\n\tsprintf(card->longname, \"%s %s at 0x%lx, irq %i\",\n\t\tcard->shortname, card->driver,\n\t\tcs5535au->port, cs5535au->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_probe(struct pci_dev *pci,\n\t\t\t\t const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_cs5535audio_probe(pci, pci_id));\n}\n\nstatic struct pci_driver cs5535audio_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_cs5535audio_ids,\n\t.probe = snd_cs5535audio_probe,\n#ifdef CONFIG_PM_SLEEP\n\t.driver = {\n\t\t.pm = &snd_cs5535audio_pm,\n\t},\n#endif\n};\n\nmodule_pci_driver(cs5535audio_driver);\n\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CS5535 Audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}