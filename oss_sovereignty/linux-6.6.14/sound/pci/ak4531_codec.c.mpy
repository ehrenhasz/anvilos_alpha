{
  "module_name": "ak4531_codec.c",
  "hash_id": "55d87158ed8c53baedaead35afc86b6603ae70149ee371006e935f2bac937366",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ak4531_codec.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/ak4531_codec.h>\n#include <sound/tlv.h>\n\n \n\nstatic void snd_ak4531_proc_init(struct snd_card *card, struct snd_ak4531 *ak4531);\n\n \n \n#if 0\n\nstatic void snd_ak4531_dump(struct snd_ak4531 *ak4531)\n{\n\tint idx;\n\t\n\tfor (idx = 0; idx < 0x19; idx++)\n\t\tprintk(KERN_DEBUG \"ak4531 0x%x: 0x%x\\n\",\n\t\t       idx, ak4531->regs[idx]);\n}\n\n#endif\n\n \n\n#define AK4531_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_ak4531_info_single, \\\n  .get = snd_ak4531_get_single, .put = snd_ak4531_put_single, \\\n  .private_value = reg | (shift << 16) | (mask << 24) | (invert << 22) }\n#define AK4531_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv)    \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .index = xindex, \\\n  .info = snd_ak4531_info_single, \\\n  .get = snd_ak4531_get_single, .put = snd_ak4531_put_single, \\\n  .private_value = reg | (shift << 16) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_ak4531_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n \nstatic int snd_ak4531_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 16) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint val;\n\n\tmutex_lock(&ak4531->reg_mutex);\n\tval = (ak4531->regs[reg] >> shift) & mask;\n\tmutex_unlock(&ak4531->reg_mutex);\n\tif (invert) {\n\t\tval = mask - val;\n\t}\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int snd_ak4531_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 16) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tint val;\n\n\tval = ucontrol->value.integer.value[0] & mask;\n\tif (invert) {\n\t\tval = mask - val;\n\t}\n\tval <<= shift;\n\tmutex_lock(&ak4531->reg_mutex);\n\tval = (ak4531->regs[reg] & ~(mask << shift)) | val;\n\tchange = val != ak4531->regs[reg];\n\tak4531->write(ak4531, reg, ak4531->regs[reg] = val);\n\tmutex_unlock(&ak4531->reg_mutex);\n\treturn change;\n}\n\n#define AK4531_DOUBLE(xname, xindex, left_reg, right_reg, left_shift, right_shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_ak4531_info_double, \\\n  .get = snd_ak4531_get_double, .put = snd_ak4531_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (left_shift << 16) | (right_shift << 19) | (mask << 24) | (invert << 22) }\n#define AK4531_DOUBLE_TLV(xname, xindex, left_reg, right_reg, left_shift, right_shift, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .index = xindex, \\\n  .info = snd_ak4531_info_double, \\\n  .get = snd_ak4531_get_double, .put = snd_ak4531_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (left_shift << 16) | (right_shift << 19) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_ak4531_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n \nstatic int snd_ak4531_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x07;\n\tint right_shift = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint left, right;\n\n\tmutex_lock(&ak4531->reg_mutex);\n\tleft = (ak4531->regs[left_reg] >> left_shift) & mask;\n\tright = (ak4531->regs[right_reg] >> right_shift) & mask;\n\tmutex_unlock(&ak4531->reg_mutex);\n\tif (invert) {\n\t\tleft = mask - left;\n\t\tright = mask - right;\n\t}\n\tucontrol->value.integer.value[0] = left;\n\tucontrol->value.integer.value[1] = right;\n\treturn 0;\n}\n\nstatic int snd_ak4531_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x07;\n\tint right_shift = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tint left, right;\n\n\tleft = ucontrol->value.integer.value[0] & mask;\n\tright = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tleft = mask - left;\n\t\tright = mask - right;\n\t}\n\tleft <<= left_shift;\n\tright <<= right_shift;\n\tmutex_lock(&ak4531->reg_mutex);\n\tif (left_reg == right_reg) {\n\t\tleft = (ak4531->regs[left_reg] & ~((mask << left_shift) | (mask << right_shift))) | left | right;\n\t\tchange = left != ak4531->regs[left_reg];\n\t\tak4531->write(ak4531, left_reg, ak4531->regs[left_reg] = left);\n\t} else {\n\t\tleft = (ak4531->regs[left_reg] & ~(mask << left_shift)) | left;\n\t\tright = (ak4531->regs[right_reg] & ~(mask << right_shift)) | right;\n\t\tchange = left != ak4531->regs[left_reg] || right != ak4531->regs[right_reg];\n\t\tak4531->write(ak4531, left_reg, ak4531->regs[left_reg] = left);\n\t\tak4531->write(ak4531, right_reg, ak4531->regs[right_reg] = right);\n\t}\n\tmutex_unlock(&ak4531->reg_mutex);\n\treturn change;\n}\n\n#define AK4531_INPUT_SW(xname, xindex, reg1, reg2, left_shift, right_shift) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_ak4531_info_input_sw, \\\n  .get = snd_ak4531_get_input_sw, .put = snd_ak4531_put_input_sw, \\\n  .private_value = reg1 | (reg2 << 8) | (left_shift << 16) | (right_shift << 24) }\n\nstatic int snd_ak4531_info_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n \nstatic int snd_ak4531_get_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint reg1 = kcontrol->private_value & 0xff;\n\tint reg2 = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x0f;\n\tint right_shift = (kcontrol->private_value >> 24) & 0x0f;\n\n\tmutex_lock(&ak4531->reg_mutex);\n\tucontrol->value.integer.value[0] = (ak4531->regs[reg1] >> left_shift) & 1;\n\tucontrol->value.integer.value[1] = (ak4531->regs[reg2] >> left_shift) & 1;\n\tucontrol->value.integer.value[2] = (ak4531->regs[reg1] >> right_shift) & 1;\n\tucontrol->value.integer.value[3] = (ak4531->regs[reg2] >> right_shift) & 1;\n\tmutex_unlock(&ak4531->reg_mutex);\n\treturn 0;\n}\n\nstatic int snd_ak4531_put_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\n\tint reg1 = kcontrol->private_value & 0xff;\n\tint reg2 = (kcontrol->private_value >> 8) & 0xff;\n\tint left_shift = (kcontrol->private_value >> 16) & 0x0f;\n\tint right_shift = (kcontrol->private_value >> 24) & 0x0f;\n\tint change;\n\tint val1, val2;\n\n\tmutex_lock(&ak4531->reg_mutex);\n\tval1 = ak4531->regs[reg1] & ~((1 << left_shift) | (1 << right_shift));\n\tval2 = ak4531->regs[reg2] & ~((1 << left_shift) | (1 << right_shift));\n\tval1 |= (ucontrol->value.integer.value[0] & 1) << left_shift;\n\tval2 |= (ucontrol->value.integer.value[1] & 1) << left_shift;\n\tval1 |= (ucontrol->value.integer.value[2] & 1) << right_shift;\n\tval2 |= (ucontrol->value.integer.value[3] & 1) << right_shift;\n\tchange = val1 != ak4531->regs[reg1] || val2 != ak4531->regs[reg2];\n\tak4531->write(ak4531, reg1, ak4531->regs[reg1] = val1);\n\tak4531->write(ak4531, reg2, ak4531->regs[reg2] = val2);\n\tmutex_unlock(&ak4531->reg_mutex);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_master, -6200, 200, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_mono, -2800, 400, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_input, -5000, 200, 0);\n\nstatic const struct snd_kcontrol_new snd_ak4531_controls[] = {\n\nAK4531_DOUBLE_TLV(\"Master Playback Switch\", 0,\n\t\t  AK4531_LMASTER, AK4531_RMASTER, 7, 7, 1, 1,\n\t\t  db_scale_master),\nAK4531_DOUBLE(\"Master Playback Volume\", 0, AK4531_LMASTER, AK4531_RMASTER, 0, 0, 0x1f, 1),\n\nAK4531_SINGLE_TLV(\"Master Mono Playback Switch\", 0, AK4531_MONO_OUT, 7, 1, 1,\n\t\t  db_scale_mono),\nAK4531_SINGLE(\"Master Mono Playback Volume\", 0, AK4531_MONO_OUT, 0, 0x07, 1),\n\nAK4531_DOUBLE(\"PCM Switch\", 0, AK4531_LVOICE, AK4531_RVOICE, 7, 7, 1, 1),\nAK4531_DOUBLE_TLV(\"PCM Volume\", 0, AK4531_LVOICE, AK4531_RVOICE, 0, 0, 0x1f, 1,\n\t\t  db_scale_input),\nAK4531_DOUBLE(\"PCM Playback Switch\", 0, AK4531_OUT_SW2, AK4531_OUT_SW2, 3, 2, 1, 0),\nAK4531_DOUBLE(\"PCM Capture Switch\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 2, 2, 1, 0),\n\nAK4531_DOUBLE(\"PCM Switch\", 1, AK4531_LFM, AK4531_RFM, 7, 7, 1, 1),\nAK4531_DOUBLE_TLV(\"PCM Volume\", 1, AK4531_LFM, AK4531_RFM, 0, 0, 0x1f, 1,\n\t\t  db_scale_input),\nAK4531_DOUBLE(\"PCM Playback Switch\", 1, AK4531_OUT_SW1, AK4531_OUT_SW1, 6, 5, 1, 0),\nAK4531_INPUT_SW(\"PCM Capture Route\", 1, AK4531_LIN_SW1, AK4531_RIN_SW1, 6, 5),\n\nAK4531_DOUBLE(\"CD Switch\", 0, AK4531_LCD, AK4531_RCD, 7, 7, 1, 1),\nAK4531_DOUBLE_TLV(\"CD Volume\", 0, AK4531_LCD, AK4531_RCD, 0, 0, 0x1f, 1,\n\t\t  db_scale_input),\nAK4531_DOUBLE(\"CD Playback Switch\", 0, AK4531_OUT_SW1, AK4531_OUT_SW1, 2, 1, 1, 0),\nAK4531_INPUT_SW(\"CD Capture Route\", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 2, 1),\n\nAK4531_DOUBLE(\"Line Switch\", 0, AK4531_LLINE, AK4531_RLINE, 7, 7, 1, 1),\nAK4531_DOUBLE_TLV(\"Line Volume\", 0, AK4531_LLINE, AK4531_RLINE, 0, 0, 0x1f, 1,\n\t\t  db_scale_input),\nAK4531_DOUBLE(\"Line Playback Switch\", 0, AK4531_OUT_SW1, AK4531_OUT_SW1, 4, 3, 1, 0),\nAK4531_INPUT_SW(\"Line Capture Route\", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 4, 3),\n\nAK4531_DOUBLE(\"Aux Switch\", 0, AK4531_LAUXA, AK4531_RAUXA, 7, 7, 1, 1),\nAK4531_DOUBLE_TLV(\"Aux Volume\", 0, AK4531_LAUXA, AK4531_RAUXA, 0, 0, 0x1f, 1,\n\t\t  db_scale_input),\nAK4531_DOUBLE(\"Aux Playback Switch\", 0, AK4531_OUT_SW2, AK4531_OUT_SW2, 5, 4, 1, 0),\nAK4531_INPUT_SW(\"Aux Capture Route\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 4, 3),\n\nAK4531_SINGLE(\"Mono Switch\", 0, AK4531_MONO1, 7, 1, 1),\nAK4531_SINGLE_TLV(\"Mono Volume\", 0, AK4531_MONO1, 0, 0x1f, 1, db_scale_input),\nAK4531_SINGLE(\"Mono Playback Switch\", 0, AK4531_OUT_SW2, 0, 1, 0),\nAK4531_DOUBLE(\"Mono Capture Switch\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 0, 0, 1, 0),\n\nAK4531_SINGLE(\"Mono Switch\", 1, AK4531_MONO2, 7, 1, 1),\nAK4531_SINGLE_TLV(\"Mono Volume\", 1, AK4531_MONO2, 0, 0x1f, 1, db_scale_input),\nAK4531_SINGLE(\"Mono Playback Switch\", 1, AK4531_OUT_SW2, 1, 1, 0),\nAK4531_DOUBLE(\"Mono Capture Switch\", 1, AK4531_LIN_SW2, AK4531_RIN_SW2, 1, 1, 1, 0),\n\nAK4531_SINGLE_TLV(\"Mic Volume\", 0, AK4531_MIC, 0, 0x1f, 1, db_scale_input),\nAK4531_SINGLE(\"Mic Switch\", 0, AK4531_MIC, 7, 1, 1),\nAK4531_SINGLE(\"Mic Playback Switch\", 0, AK4531_OUT_SW1, 0, 1, 0),\nAK4531_DOUBLE(\"Mic Capture Switch\", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 0, 0, 1, 0),\n\nAK4531_DOUBLE(\"Mic Bypass Capture Switch\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 7, 7, 1, 0),\nAK4531_DOUBLE(\"Mono1 Bypass Capture Switch\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 6, 6, 1, 0),\nAK4531_DOUBLE(\"Mono2 Bypass Capture Switch\", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 5, 5, 1, 0),\n\nAK4531_SINGLE(\"AD Input Select\", 0, AK4531_AD_IN, 0, 1, 0),\nAK4531_SINGLE(\"Mic Boost (+30dB)\", 0, AK4531_MIC_GAIN, 0, 1, 0)\n};\n\nstatic int snd_ak4531_free(struct snd_ak4531 *ak4531)\n{\n\tif (ak4531) {\n\t\tif (ak4531->private_free)\n\t\t\tak4531->private_free(ak4531);\n\t\tkfree(ak4531);\n\t}\n\treturn 0;\n}\n\nstatic int snd_ak4531_dev_free(struct snd_device *device)\n{\n\tstruct snd_ak4531 *ak4531 = device->device_data;\n\treturn snd_ak4531_free(ak4531);\n}\n\nstatic const u8 snd_ak4531_initial_map[0x19 + 1] = {\n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x9f,\t\t \n\t0x87,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x00,\t\t \n\t0x01\t\t \n};\n\nint snd_ak4531_mixer(struct snd_card *card,\n\t\t     struct snd_ak4531 *_ak4531,\n\t\t     struct snd_ak4531 **rak4531)\n{\n\tunsigned int idx;\n\tint err;\n\tstruct snd_ak4531 *ak4531;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_ak4531_dev_free,\n\t};\n\n\tif (snd_BUG_ON(!card || !_ak4531))\n\t\treturn -EINVAL;\n\tif (rak4531)\n\t\t*rak4531 = NULL;\n\tak4531 = kzalloc(sizeof(*ak4531), GFP_KERNEL);\n\tif (ak4531 == NULL)\n\t\treturn -ENOMEM;\n\t*ak4531 = *_ak4531;\n\tmutex_init(&ak4531->reg_mutex);\n\terr = snd_component_add(card, \"AK4531\");\n\tif (err < 0) {\n\t\tsnd_ak4531_free(ak4531);\n\t\treturn err;\n\t}\n\tstrcpy(card->mixername, \"Asahi Kasei AK4531\");\n\tak4531->write(ak4531, AK4531_RESET, 0x03);\t \n\tudelay(100);\n\tak4531->write(ak4531, AK4531_CLOCK, 0x00);\t \n\tfor (idx = 0; idx <= 0x19; idx++) {\n\t\tif (idx == AK4531_RESET || idx == AK4531_CLOCK)\n\t\t\tcontinue;\n\t\tak4531->write(ak4531, idx, ak4531->regs[idx] = snd_ak4531_initial_map[idx]);\t \n\t}\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_ak4531_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ak4531_controls[idx], ak4531));\n\t\tif (err < 0) {\n\t\t\tsnd_ak4531_free(ak4531);\n\t\t\treturn err;\n\t\t}\n\t}\n\tsnd_ak4531_proc_init(card, ak4531);\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, ak4531, &ops);\n\tif (err < 0) {\n\t\tsnd_ak4531_free(ak4531);\n\t\treturn err;\n\t}\n\n#if 0\n\tsnd_ak4531_dump(ak4531);\n#endif\n\tif (rak4531)\n\t\t*rak4531 = ak4531;\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM\nvoid snd_ak4531_suspend(struct snd_ak4531 *ak4531)\n{\n\t \n\tak4531->write(ak4531, AK4531_LMASTER, 0x9f);\n\tak4531->write(ak4531, AK4531_RMASTER, 0x9f);\n\t \n\tak4531->write(ak4531, AK4531_RESET, 0x01);\n}\n\nvoid snd_ak4531_resume(struct snd_ak4531 *ak4531)\n{\n\tint idx;\n\n\t \n\tak4531->write(ak4531, AK4531_RESET, 0x03);\n\tudelay(100);\n\tak4531->write(ak4531, AK4531_CLOCK, 0x00);\n\t \n\tfor (idx = 0; idx <= 0x19; idx++) {\n\t\tif (idx == AK4531_RESET || idx == AK4531_CLOCK)\n\t\t\tcontinue;\n\t\tak4531->write(ak4531, idx, ak4531->regs[idx]);\n\t}\n}\n#endif\n\n \n\nstatic void snd_ak4531_proc_read(struct snd_info_entry *entry, \n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_ak4531 *ak4531 = entry->private_data;\n\n\tsnd_iprintf(buffer, \"Asahi Kasei AK4531\\n\\n\");\n\tsnd_iprintf(buffer, \"Recording source   : %s\\n\"\n\t\t    \"MIC gain           : %s\\n\",\n\t\t    ak4531->regs[AK4531_AD_IN] & 1 ? \"external\" : \"mixer\",\n\t\t    ak4531->regs[AK4531_MIC_GAIN] & 1 ? \"+30dB\" : \"+0dB\");\n}\n\nstatic void\nsnd_ak4531_proc_init(struct snd_card *card, struct snd_ak4531 *ak4531)\n{\n\tsnd_card_ro_proc_new(card, \"ak4531\", ak4531, snd_ak4531_proc_read);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}