{
  "module_name": "mixart_mixer.c",
  "hash_id": "bcb75481ff93a095a8daeb95f5a50659d891b1c09f67ada0fc3975abe993c838",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/mixart/mixart_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include \"mixart.h\"\n#include \"mixart_core.h\"\n#include \"mixart_hwdep.h\"\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"mixart_mixer.h\"\n\nstatic const u32 mixart_analog_level[256] = {\n\t0xc2c00000,\t\t \n\t0xc2bf0000,\t\t \n\t0xc2be0000,\t\t \n\t0xc2bd0000,\t\t \n\t0xc2bc0000,\t\t \n\t0xc2bb0000,\t\t \n\t0xc2ba0000,\t\t \n\t0xc2b90000,\t\t \n\t0xc2b80000,\t\t \n\t0xc2b70000,\t\t \n\t0xc2b60000,\t\t \n\t0xc2b50000,\t\t \n\t0xc2b40000,\t\t \n\t0xc2b30000,\t\t \n\t0xc2b20000,\t\t \n\t0xc2b10000,\t\t \n\t0xc2b00000,\t\t \n\t0xc2af0000,\t\t \n\t0xc2ae0000,\t\t \n\t0xc2ad0000,\t\t \n\t0xc2ac0000,\t\t \n\t0xc2ab0000,\t\t \n\t0xc2aa0000,\t\t \n\t0xc2a90000,\t\t \n\t0xc2a80000,\t\t \n\t0xc2a70000,\t\t \n\t0xc2a60000,\t\t \n\t0xc2a50000,\t\t \n\t0xc2a40000,\t\t \n\t0xc2a30000,\t\t \n\t0xc2a20000,\t\t \n\t0xc2a10000,\t\t \n\t0xc2a00000,\t\t \n\t0xc29f0000,\t\t \n\t0xc29e0000,\t\t \n\t0xc29d0000,\t\t \n\t0xc29c0000,\t\t \n\t0xc29b0000,\t\t \n\t0xc29a0000,\t\t \n\t0xc2990000,\t\t \n\t0xc2980000,\t\t \n\t0xc2970000,\t\t \n\t0xc2960000,\t\t \n\t0xc2950000,\t\t \n\t0xc2940000,\t\t \n\t0xc2930000,\t\t \n\t0xc2920000,\t\t \n\t0xc2910000,\t\t \n\t0xc2900000,\t\t \n\t0xc28f0000,\t\t \n\t0xc28e0000,\t\t \n\t0xc28d0000,\t\t \n\t0xc28c0000,\t\t \n\t0xc28b0000,\t\t \n\t0xc28a0000,\t\t \n\t0xc2890000,\t\t \n\t0xc2880000,\t\t \n\t0xc2870000,\t\t \n\t0xc2860000,\t\t \n\t0xc2850000,\t\t \n\t0xc2840000,\t\t \n\t0xc2830000,\t\t \n\t0xc2820000,\t\t \n\t0xc2810000,\t\t \n\t0xc2800000,\t\t \n\t0xc27e0000,\t\t \n\t0xc27c0000,\t\t \n\t0xc27a0000,\t\t \n\t0xc2780000,\t\t \n\t0xc2760000,\t\t \n\t0xc2740000,\t\t \n\t0xc2720000,\t\t \n\t0xc2700000,\t\t \n\t0xc26e0000,\t\t \n\t0xc26c0000,\t\t \n\t0xc26a0000,\t\t \n\t0xc2680000,\t\t \n\t0xc2660000,\t\t \n\t0xc2640000,\t\t \n\t0xc2620000,\t\t \n\t0xc2600000,\t\t \n\t0xc25e0000,\t\t \n\t0xc25c0000,\t\t \n\t0xc25a0000,\t\t \n\t0xc2580000,\t\t \n\t0xc2560000,\t\t \n\t0xc2540000,\t\t \n\t0xc2520000,\t\t \n\t0xc2500000,\t\t \n\t0xc24e0000,\t\t \n\t0xc24c0000,\t\t \n\t0xc24a0000,\t\t \n\t0xc2480000,\t\t \n\t0xc2460000,\t\t \n\t0xc2440000,\t\t \n\t0xc2420000,\t\t \n\t0xc2400000,\t\t \n\t0xc23e0000,\t\t \n\t0xc23c0000,\t\t \n\t0xc23a0000,\t\t \n\t0xc2380000,\t\t \n\t0xc2360000,\t\t \n\t0xc2340000,\t\t \n\t0xc2320000,\t\t \n\t0xc2300000,\t\t \n\t0xc22e0000,\t\t \n\t0xc22c0000,\t\t \n\t0xc22a0000,\t\t \n\t0xc2280000,\t\t \n\t0xc2260000,\t\t \n\t0xc2240000,\t\t \n\t0xc2220000,\t\t \n\t0xc2200000,\t\t \n\t0xc21e0000,\t\t \n\t0xc21c0000,\t\t \n\t0xc21a0000,\t\t \n\t0xc2180000,\t\t \n\t0xc2160000,\t\t \n\t0xc2140000,\t\t \n\t0xc2120000,\t\t \n\t0xc2100000,\t\t \n\t0xc20e0000,\t\t \n\t0xc20c0000,\t\t \n\t0xc20a0000,\t\t \n\t0xc2080000,\t\t \n\t0xc2060000,\t\t \n\t0xc2040000,\t\t \n\t0xc2020000,\t\t \n\t0xc2000000,\t\t \n\t0xc1fc0000,\t\t \n\t0xc1f80000,\t\t \n\t0xc1f40000,\t\t \n\t0xc1f00000,\t\t \n\t0xc1ec0000,\t\t \n\t0xc1e80000,\t\t \n\t0xc1e40000,\t\t \n\t0xc1e00000,\t\t \n\t0xc1dc0000,\t\t \n\t0xc1d80000,\t\t \n\t0xc1d40000,\t\t \n\t0xc1d00000,\t\t \n\t0xc1cc0000,\t\t \n\t0xc1c80000,\t\t \n\t0xc1c40000,\t\t \n\t0xc1c00000,\t\t \n\t0xc1bc0000,\t\t \n\t0xc1b80000,\t\t \n\t0xc1b40000,\t\t \n\t0xc1b00000,\t\t \n\t0xc1ac0000,\t\t \n\t0xc1a80000,\t\t \n\t0xc1a40000,\t\t \n\t0xc1a00000,\t\t \n\t0xc19c0000,\t\t \n\t0xc1980000,\t\t \n\t0xc1940000,\t\t \n\t0xc1900000,\t\t \n\t0xc18c0000,\t\t \n\t0xc1880000,\t\t \n\t0xc1840000,\t\t \n\t0xc1800000,\t\t \n\t0xc1780000,\t\t \n\t0xc1700000,\t\t \n\t0xc1680000,\t\t \n\t0xc1600000,\t\t \n\t0xc1580000,\t\t \n\t0xc1500000,\t\t \n\t0xc1480000,\t\t \n\t0xc1400000,\t\t \n\t0xc1380000,\t\t \n\t0xc1300000,\t\t \n\t0xc1280000,\t\t \n\t0xc1200000,\t\t \n\t0xc1180000,\t\t \n\t0xc1100000,\t\t \n\t0xc1080000,\t\t \n\t0xc1000000,\t\t \n\t0xc0f00000,\t\t \n\t0xc0e00000,\t\t \n\t0xc0d00000,\t\t \n\t0xc0c00000,\t\t \n\t0xc0b00000,\t\t \n\t0xc0a00000,\t\t \n\t0xc0900000,\t\t \n\t0xc0800000,\t\t \n\t0xc0600000,\t\t \n\t0xc0400000,\t\t \n\t0xc0200000,\t\t \n\t0xc0000000,\t\t \n\t0xbfc00000,\t\t \n\t0xbf800000,\t\t \n\t0xbf000000,\t\t \n\t0x00000000,\t\t \n\t0x3f000000,\t\t \n\t0x3f800000,\t\t \n\t0x3fc00000,\t\t \n\t0x40000000,\t\t \n\t0x40200000,\t\t \n\t0x40400000,\t\t \n\t0x40600000,\t\t \n\t0x40800000,\t\t \n\t0x40900000,\t\t \n\t0x40a00000,\t\t \n\t0x40b00000,\t\t \n\t0x40c00000,\t\t \n\t0x40d00000,\t\t \n\t0x40e00000,\t\t \n\t0x40f00000,\t\t \n\t0x41000000,\t\t \n\t0x41080000,\t\t \n\t0x41100000,\t\t \n\t0x41180000,\t\t \n\t0x41200000,\t\t \n\t0x41280000,\t\t \n\t0x41300000,\t\t \n\t0x41380000,\t\t \n\t0x41400000,\t\t \n\t0x41480000,\t\t \n\t0x41500000,\t\t \n\t0x41580000,\t\t \n\t0x41600000,\t\t \n\t0x41680000,\t\t \n\t0x41700000,\t\t \n\t0x41780000,\t\t \n\t0x41800000,\t\t \n\t0x41840000,\t\t \n\t0x41880000,\t\t \n\t0x418c0000,\t\t \n\t0x41900000,\t\t \n\t0x41940000,\t\t \n\t0x41980000,\t\t \n\t0x419c0000,\t\t \n\t0x41a00000,\t\t \n\t0x41a40000,\t\t \n\t0x41a80000,\t\t \n\t0x41ac0000,\t\t \n\t0x41b00000,\t\t \n\t0x41b40000,\t\t \n\t0x41b80000,\t\t \n\t0x41bc0000,\t\t \n\t0x41c00000,\t\t \n\t0x41c40000,\t\t \n\t0x41c80000,\t\t \n\t0x41cc0000,\t\t \n\t0x41d00000,\t\t \n\t0x41d40000,\t\t \n\t0x41d80000,\t\t \n\t0x41dc0000,\t\t \n\t0x41e00000,\t\t \n\t0x41e40000,\t\t \n\t0x41e80000,\t\t \n\t0x41ec0000,\t\t \n\t0x41f00000,\t\t \n\t0x41f40000,\t\t \n\t0x41f80000,\t\t \n\t0x41fc0000,\t\t \n};\n\n#define MIXART_ANALOG_CAPTURE_LEVEL_MIN   0       \n#define MIXART_ANALOG_CAPTURE_LEVEL_MAX   255     \n#define MIXART_ANALOG_CAPTURE_ZERO_LEVEL  176     \n\n#define MIXART_ANALOG_PLAYBACK_LEVEL_MIN  0       \n#define MIXART_ANALOG_PLAYBACK_LEVEL_MAX  192     \n#define MIXART_ANALOG_PLAYBACK_ZERO_LEVEL 189     \n\nstatic int mixart_update_analog_audio_level(struct snd_mixart* chip, int is_capture)\n{\n\tint i, err;\n\tstruct mixart_msg request;\n\tstruct mixart_io_level io_level;\n\tstruct mixart_return_uid resp;\n\n\tmemset(&io_level, 0, sizeof(io_level));\n\tio_level.channel = -1;  \n\n\tfor(i=0; i<2; i++) {\n\t\tif(is_capture) {\n\t\t\tio_level.level[i].analog_level = mixart_analog_level[chip->analog_capture_volume[i]];\n\t\t} else {\n\t\t\tif(chip->analog_playback_active[i])\n\t\t\t\tio_level.level[i].analog_level = mixart_analog_level[chip->analog_playback_volume[i]];\n\t\t\telse\n\t\t\t\tio_level.level[i].analog_level = mixart_analog_level[MIXART_ANALOG_PLAYBACK_LEVEL_MIN];\n\t\t}\n\t}\n\n\tif(is_capture)\trequest.uid = chip->uid_in_analog_physio;\n\telse\t\trequest.uid = chip->uid_out_analog_physio;\n\trequest.message_id = MSG_PHYSICALIO_SET_LEVEL;\n\trequest.data = &io_level;\n\trequest.size = sizeof(io_level);\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\n\tif((err<0) || (resp.error_code)) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error MSG_PHYSICALIO_SET_LEVEL card(%d) is_capture(%d) error_code(%x)\\n\",\n\t\t\tchip->chip_idx, is_capture, resp.error_code);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int mixart_analog_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tif(kcontrol->private_value == 0) {\t \n\t\tuinfo->value.integer.min = MIXART_ANALOG_PLAYBACK_LEVEL_MIN;   \n\t\tuinfo->value.integer.max = MIXART_ANALOG_PLAYBACK_LEVEL_MAX;   \n\t} else {\t\t\t\t \n\t\tuinfo->value.integer.min = MIXART_ANALOG_CAPTURE_LEVEL_MIN;    \n\t\tuinfo->value.integer.max = MIXART_ANALOG_CAPTURE_LEVEL_MAX;    \n\t}\n\treturn 0;\n}\n\nstatic int mixart_analog_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif(kcontrol->private_value == 0) {\t \n\t\tucontrol->value.integer.value[0] = chip->analog_playback_volume[0];\n\t\tucontrol->value.integer.value[1] = chip->analog_playback_volume[1];\n\t} else {\t\t\t\t \n\t\tucontrol->value.integer.value[0] = chip->analog_capture_volume[0];\n\t\tucontrol->value.integer.value[1] = chip->analog_capture_volume[1];\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_analog_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint is_capture, i;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tis_capture = (kcontrol->private_value != 0);\n\tfor (i = 0; i < 2; i++) {\n\t\tint new_volume = ucontrol->value.integer.value[i];\n\t\tint *stored_volume = is_capture ?\n\t\t\t&chip->analog_capture_volume[i] :\n\t\t\t&chip->analog_playback_volume[i];\n\t\tif (is_capture) {\n\t\t\tif (new_volume < MIXART_ANALOG_CAPTURE_LEVEL_MIN ||\n\t\t\t    new_volume > MIXART_ANALOG_CAPTURE_LEVEL_MAX)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (new_volume < MIXART_ANALOG_PLAYBACK_LEVEL_MIN ||\n\t\t\t    new_volume > MIXART_ANALOG_PLAYBACK_LEVEL_MAX)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (*stored_volume != new_volume) {\n\t\t\t*stored_volume = new_volume;\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tmixart_update_analog_audio_level(chip, is_capture);\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_analog, -9600, 50, 0);\n\nstatic const struct snd_kcontrol_new mixart_control_analog_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t \n\t.info =\t\tmixart_analog_vol_info,\n\t.get =\t\tmixart_analog_vol_get,\n\t.put =\t\tmixart_analog_vol_put,\n\t.tlv = { .p = db_scale_analog },\n};\n\n \n#define mixart_sw_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int mixart_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->analog_playback_active[0];\n\tucontrol->value.integer.value[1] = chip->analog_playback_active[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint i, changed = 0;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->analog_playback_active[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->analog_playback_active[i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)  \n\t\tmixart_update_analog_audio_level(chip, 0);\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mixart_control_output_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Master Playback Switch\",\n\t.info =         mixart_sw_info,\t\t \n\t.get =          mixart_audio_sw_get,\n\t.put =          mixart_audio_sw_put\n};\n\nstatic const u32 mixart_digital_level[256] = {\n\t0x00000000,\t\t \n\t0x366e1c7a,\t\t \n\t0x367c3860,\t\t \n\t0x36859525,\t\t \n\t0x368d7f74,\t\t \n\t0x3695e1d4,\t\t \n\t0x369ec362,\t\t \n\t0x36a82ba8,\t\t \n\t0x36b222a0,\t\t \n\t0x36bcb0c1,\t\t \n\t0x36c7defd,\t\t \n\t0x36d3b6d3,\t\t \n\t0x36e0424e,\t\t \n\t0x36ed8c14,\t\t \n\t0x36fb9f6c,\t\t \n\t0x37054423,\t\t \n\t0x370d29a5,\t\t \n\t0x371586f0,\t\t \n\t0x371e631b,\t\t \n\t0x3727c5ac,\t\t \n\t0x3731b69a,\t\t \n\t0x373c3e53,\t\t \n\t0x374765c8,\t\t \n\t0x3753366f,\t\t \n\t0x375fba4f,\t\t \n\t0x376cfc07,\t\t \n\t0x377b06d5,\t\t \n\t0x3784f352,\t\t \n\t0x378cd40b,\t\t \n\t0x37952c42,\t\t \n\t0x379e030e,\t\t \n\t0x37a75fef,\t\t \n\t0x37b14ad5,\t\t \n\t0x37bbcc2c,\t\t \n\t0x37c6ecdd,\t\t \n\t0x37d2b65a,\t\t \n\t0x37df32a3,\t\t \n\t0x37ec6c50,\t\t \n\t0x37fa6e9b,\t\t \n\t0x3804a2b3,\t\t \n\t0x380c7ea4,\t\t \n\t0x3814d1cc,\t\t \n\t0x381da33c,\t\t \n\t0x3826fa6f,\t\t \n\t0x3830df51,\t\t \n\t0x383b5a49,\t\t \n\t0x3846743b,\t\t \n\t0x38523692,\t\t \n\t0x385eab48,\t\t \n\t0x386bdcf1,\t\t \n\t0x3879d6bc,\t\t \n\t0x38845244,\t\t \n\t0x388c2971,\t\t \n\t0x3894778d,\t\t \n\t0x389d43a4,\t\t \n\t0x38a6952c,\t\t \n\t0x38b0740f,\t\t \n\t0x38bae8ac,\t\t \n\t0x38c5fbe2,\t\t \n\t0x38d1b717,\t\t \n\t0x38de2440,\t\t \n\t0x38eb4de8,\t\t \n\t0x38f93f3a,\t\t \n\t0x39040206,\t\t \n\t0x390bd472,\t\t \n\t0x39141d84,\t\t \n\t0x391ce445,\t\t \n\t0x39263027,\t\t \n\t0x3930090d,\t\t \n\t0x393a7753,\t\t \n\t0x394583d2,\t\t \n\t0x395137ea,\t\t \n\t0x395d9d8a,\t\t \n\t0x396abf37,\t\t \n\t0x3978a814,\t\t \n\t0x3983b1f8,\t\t \n\t0x398b7fa6,\t\t \n\t0x3993c3b2,\t\t \n\t0x399c8521,\t\t \n\t0x39a5cb5f,\t\t \n\t0x39af9e4d,\t\t \n\t0x39ba063f,\t\t \n\t0x39c50c0b,\t\t \n\t0x39d0b90a,\t\t \n\t0x39dd1726,\t\t \n\t0x39ea30db,\t\t \n\t0x39f81149,\t\t \n\t0x3a03621b,\t\t \n\t0x3a0b2b0d,\t\t \n\t0x3a136a16,\t\t \n\t0x3a1c2636,\t\t \n\t0x3a2566d5,\t\t \n\t0x3a2f33cd,\t\t \n\t0x3a399570,\t\t \n\t0x3a44948c,\t\t \n\t0x3a503a77,\t\t \n\t0x3a5c9112,\t\t \n\t0x3a69a2d7,\t\t \n\t0x3a777ada,\t\t \n\t0x3a83126f,\t\t \n\t0x3a8ad6a8,\t\t \n\t0x3a9310b1,\t\t \n\t0x3a9bc784,\t\t \n\t0x3aa50287,\t\t \n\t0x3aaec98e,\t\t \n\t0x3ab924e5,\t\t \n\t0x3ac41d56,\t\t \n\t0x3acfbc31,\t\t \n\t0x3adc0b51,\t\t \n\t0x3ae91528,\t\t \n\t0x3af6e4c6,\t\t \n\t0x3b02c2f2,\t\t \n\t0x3b0a8276,\t\t \n\t0x3b12b782,\t\t \n\t0x3b1b690d,\t\t \n\t0x3b249e76,\t\t \n\t0x3b2e5f8f,\t\t \n\t0x3b38b49f,\t\t \n\t0x3b43a669,\t\t \n\t0x3b4f3e37,\t\t \n\t0x3b5b85e0,\t\t \n\t0x3b6887cf,\t\t \n\t0x3b764f0e,\t\t \n\t0x3b8273a6,\t\t \n\t0x3b8a2e77,\t\t \n\t0x3b925e89,\t\t \n\t0x3b9b0ace,\t\t \n\t0x3ba43aa2,\t\t \n\t0x3badf5d1,\t\t \n\t0x3bb8449c,\t\t \n\t0x3bc32fc3,\t\t \n\t0x3bcec08a,\t\t \n\t0x3bdb00c0,\t\t \n\t0x3be7facc,\t\t \n\t0x3bf5b9b0,\t\t \n\t0x3c02248a,\t\t \n\t0x3c09daac,\t\t \n\t0x3c1205c6,\t\t \n\t0x3c1aacc8,\t\t \n\t0x3c23d70a,\t\t \n\t0x3c2d8c52,\t\t \n\t0x3c37d4dd,\t\t \n\t0x3c42b965,\t\t \n\t0x3c4e4329,\t\t \n\t0x3c5a7bf1,\t\t \n\t0x3c676e1e,\t\t \n\t0x3c7524ac,\t\t \n\t0x3c81d59f,\t\t \n\t0x3c898712,\t\t \n\t0x3c91ad39,\t\t \n\t0x3c9a4efc,\t\t \n\t0x3ca373af,\t\t \n\t0x3cad2314,\t\t \n\t0x3cb76563,\t\t \n\t0x3cc24350,\t\t \n\t0x3ccdc614,\t\t \n\t0x3cd9f773,\t\t \n\t0x3ce6e1c6,\t\t \n\t0x3cf49003,\t\t \n\t0x3d0186e2,\t\t \n\t0x3d0933ac,\t\t \n\t0x3d1154e1,\t\t \n\t0x3d19f169,\t\t \n\t0x3d231090,\t\t \n\t0x3d2cba15,\t\t \n\t0x3d36f62b,\t\t \n\t0x3d41cd81,\t\t \n\t0x3d4d494a,\t\t \n\t0x3d597345,\t\t \n\t0x3d6655c3,\t\t \n\t0x3d73fbb4,\t\t \n\t0x3d813856,\t\t \n\t0x3d88e078,\t\t \n\t0x3d90fcbf,\t\t \n\t0x3d99940e,\t\t \n\t0x3da2adad,\t\t \n\t0x3dac5156,\t\t \n\t0x3db68738,\t\t \n\t0x3dc157fb,\t\t \n\t0x3dcccccd,\t\t \n\t0x3dd8ef67,\t\t \n\t0x3de5ca15,\t\t \n\t0x3df367bf,\t\t \n\t0x3e00e9f9,\t\t \n\t0x3e088d77,\t\t \n\t0x3e10a4d3,\t\t \n\t0x3e1936ec,\t\t \n\t0x3e224b06,\t\t \n\t0x3e2be8d7,\t\t \n\t0x3e361887,\t\t \n\t0x3e40e2bb,\t\t \n\t0x3e4c509b,\t\t \n\t0x3e586bd9,\t\t \n\t0x3e653ebb,\t\t \n\t0x3e72d424,\t\t \n\t0x3e809bcc,\t\t \n\t0x3e883aa8,\t\t \n\t0x3e904d1c,\t\t \n\t0x3e98da02,\t\t \n\t0x3ea1e89b,\t\t \n\t0x3eab8097,\t\t \n\t0x3eb5aa1a,\t\t \n\t0x3ec06dc3,\t\t \n\t0x3ecbd4b4,\t\t \n\t0x3ed7e89b,\t\t \n\t0x3ee4b3b6,\t\t \n\t0x3ef240e2,\t\t \n\t0x3f004dce,\t\t \n\t0x3f07e80b,\t\t \n\t0x3f0ff59a,\t\t \n\t0x3f187d50,\t\t \n\t0x3f21866c,\t\t \n\t0x3f2b1896,\t\t \n\t0x3f353bef,\t\t \n\t0x3f3ff911,\t\t \n\t0x3f4b5918,\t\t \n\t0x3f5765ac,\t\t \n\t0x3f642905,\t\t \n\t0x3f71adf9,\t\t \n\t0x3f800000,\t\t \n\t0x3f8795a0,\t\t \n\t0x3f8f9e4d,\t\t \n\t0x3f9820d7,\t\t \n\t0x3fa12478,\t\t \n\t0x3faab0d5,\t\t \n\t0x3fb4ce08,\t\t \n\t0x3fbf84a6,\t\t \n\t0x3fcaddc8,\t\t \n\t0x3fd6e30d,\t\t \n\t0x3fe39ea9,\t\t \n\t0x3ff11b6a,\t\t \n\t0x3fff64c1,\t\t \n\t0x40074368,\t\t \n\t0x400f4735,\t\t \n\t0x4017c496,\t\t \n\t0x4020c2bf,\t\t \n\t0x402a4952,\t\t \n\t0x40346063,\t\t \n\t0x403f1082,\t\t \n\t0x404a62c2,\t\t \n\t0x405660bd,\t\t \n\t0x406314a0,\t\t \n\t0x40708933,\t\t \n\t0x407ec9e1,\t\t \n\t0x4086f161,\t\t \n\t0x408ef052,\t\t \n\t0x4097688d,\t\t \n\t0x40a06142,\t\t \n\t0x40a9e20e,\t\t \n\t0x40b3f300,\t\t \n\t0x40be9ca5,\t\t \n\t0x40c9e807,\t\t \n\t0x40d5debc,\t\t \n\t0x40e28aeb,\t\t \n\t0x40eff755,\t\t \n\t0x40fe2f5e,\t\t \n};\n\n#define MIXART_DIGITAL_LEVEL_MIN   0       \n#define MIXART_DIGITAL_LEVEL_MAX   255     \n#define MIXART_DIGITAL_ZERO_LEVEL  219     \n\n\nint mixart_update_playback_stream_level(struct snd_mixart* chip, int is_aes, int idx)\n{\n\tint err, i;\n\tint volume[2];\n\tstruct mixart_msg request;\n\tstruct mixart_set_out_stream_level_req set_level;\n\tu32 status = 0;\n\tstruct mixart_pipe *pipe;\n\n\tmemset(&set_level, 0, sizeof(set_level));\n\tset_level.nb_of_stream = 1;\n\tset_level.stream_level.desc.stream_idx = idx;\n\n\tif(is_aes) {\n\t\tpipe = &chip->pipe_out_dig;\t \n\t\tidx += MIXART_PLAYBACK_STREAMS;\n\t} else {\n\t\tpipe = &chip->pipe_out_ana;\t \n\t}\n\n\t \n\tif(pipe->status == PIPE_UNDEFINED)\n\t\treturn 0;\n\n\tset_level.stream_level.desc.uid_pipe = pipe->group_uid;\n\n\tfor(i=0; i<2; i++) {\n\t\tif(chip->digital_playback_active[idx][i])\n\t\t\tvolume[i] = chip->digital_playback_volume[idx][i];\n\t\telse\n\t\t\tvolume[i] = MIXART_DIGITAL_LEVEL_MIN;\n\t}\n\n\tset_level.stream_level.out_level.valid_mask1 = MIXART_OUT_STREAM_SET_LEVEL_LEFT_AUDIO1 | MIXART_OUT_STREAM_SET_LEVEL_RIGHT_AUDIO2;\n\tset_level.stream_level.out_level.left_to_out1_level = mixart_digital_level[volume[0]];\n\tset_level.stream_level.out_level.right_to_out2_level = mixart_digital_level[volume[1]];\n\n\trequest.message_id = MSG_STREAM_SET_OUT_STREAM_LEVEL;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &set_level;\n\trequest.size = sizeof(set_level);\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);\n\tif((err<0) || status) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error MSG_STREAM_SET_OUT_STREAM_LEVEL card(%d) status(%x)\\n\",\n\t\t\tchip->chip_idx, status);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint mixart_update_capture_stream_level(struct snd_mixart* chip, int is_aes)\n{\n\tint err, i, idx;\n\tstruct mixart_pipe *pipe;\n\tstruct mixart_msg request;\n\tstruct mixart_set_in_audio_level_req set_level;\n\tu32 status = 0;\n\n\tif(is_aes) {\n\t\tidx = 1;\n\t\tpipe = &chip->pipe_in_dig;\n\t} else {\n\t\tidx = 0;\n\t\tpipe = &chip->pipe_in_ana;\n\t}\n\n\t \n\tif(pipe->status == PIPE_UNDEFINED)\n\t\treturn 0;\n\n\tmemset(&set_level, 0, sizeof(set_level));\n\tset_level.audio_count = 2;\n\tset_level.level[0].connector = pipe->uid_left_connector;\n\tset_level.level[1].connector = pipe->uid_right_connector;\n\n\tfor(i=0; i<2; i++) {\n\t\tset_level.level[i].valid_mask1 = MIXART_AUDIO_LEVEL_DIGITAL_MASK;\n\t\tset_level.level[i].digital_level = mixart_digital_level[chip->digital_capture_volume[idx][i]];\n\t}\n\n\trequest.message_id = MSG_STREAM_SET_IN_AUDIO_LEVEL;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &set_level;\n\trequest.size = sizeof(set_level);\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);\n\tif((err<0) || status) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error MSG_STREAM_SET_IN_AUDIO_LEVEL card(%d) status(%x)\\n\",\n\t\t\tchip->chip_idx, status);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int mixart_digital_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = MIXART_DIGITAL_LEVEL_MIN;    \n\tuinfo->value.integer.max = MIXART_DIGITAL_LEVEL_MAX;    \n\treturn 0;\n}\n\n#define MIXART_VOL_REC_MASK\t1\n#define MIXART_VOL_AES_MASK\t2\n\nstatic int mixart_pcm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\tint *stored_volume;\n\tint is_capture = kcontrol->private_value & MIXART_VOL_REC_MASK;\n\tint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif(is_capture) {\n\t\tif(is_aes)\tstored_volume = chip->digital_capture_volume[1];\t \n\t\telse\t\tstored_volume = chip->digital_capture_volume[0];\t \n\t} else {\n\t\tsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\n\t\tif(is_aes)\tstored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx];  \n\t\telse\t\tstored_volume = chip->digital_playback_volume[idx];\t \n\t}\n\tucontrol->value.integer.value[0] = stored_volume[0];\n\tucontrol->value.integer.value[1] = stored_volume[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_pcm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\tint changed = 0;\n\tint is_capture = kcontrol->private_value & MIXART_VOL_REC_MASK;\n\tint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\n\tint* stored_volume;\n\tint i;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (is_capture) {\n\t\tif (is_aes)\t \n\t\t\tstored_volume = chip->digital_capture_volume[1];\n\t\telse\t\t \n\t\t\tstored_volume = chip->digital_capture_volume[0];\n\t} else {\n\t\tsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\n\t\tif (is_aes)\t \n\t\t\tstored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx];\n\t\telse\t\t \n\t\t\tstored_volume = chip->digital_playback_volume[idx];\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tint vol = ucontrol->value.integer.value[i];\n\t\tif (vol < MIXART_DIGITAL_LEVEL_MIN ||\n\t\t    vol > MIXART_DIGITAL_LEVEL_MAX)\n\t\t\tcontinue;\n\t\tif (stored_volume[i] != vol) {\n\t\t\tstored_volume[i] = vol;\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed) {\n\t\tif (is_capture)\n\t\t\tmixart_update_capture_stream_level(chip, is_aes);\n\t\telse\n\t\t\tmixart_update_playback_stream_level(chip, is_aes, idx);\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_digital, -10950, 50, 0);\n\nstatic const struct snd_kcontrol_new snd_mixart_pcm_vol =\n{\n\t.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t \n\t \n\t.info =         mixart_digital_vol_info,\t\t \n\t.get =          mixart_pcm_vol_get,\n\t.put =          mixart_pcm_vol_put,\n\t.tlv = { .p = db_scale_digital },\n};\n\n\nstatic int mixart_pcm_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\tsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif(kcontrol->private_value & MIXART_VOL_AES_MASK)\t \n\t\tidx += MIXART_PLAYBACK_STREAMS;\n\tucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];\n\tucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_pcm_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\tint i, j;\n\tsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tj = idx;\n\tif (is_aes)\n\t\tj += MIXART_PLAYBACK_STREAMS;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->digital_playback_active[j][i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->digital_playback_active[j][i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tmixart_update_playback_stream_level(chip, is_aes, idx);\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mixart_control_pcm_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t \n\t.count =        MIXART_PLAYBACK_STREAMS,\n\t.info =         mixart_sw_info,\t\t \n\t.get =          mixart_pcm_sw_get,\n\t.put =          mixart_pcm_sw_put\n};\n\nstatic int mixart_update_monitoring(struct snd_mixart* chip, int channel)\n{\n\tint err;\n\tstruct mixart_msg request;\n\tstruct mixart_set_out_audio_level audio_level;\n\tu32 resp = 0;\n\n\tif(chip->pipe_out_ana.status == PIPE_UNDEFINED)\n\t\treturn -EINVAL;  \n\n\tif(!channel)\trequest.uid = chip->pipe_out_ana.uid_left_connector;\n\telse\t\trequest.uid = chip->pipe_out_ana.uid_right_connector;\n\trequest.message_id = MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL;\n\trequest.data = &audio_level;\n\trequest.size = sizeof(audio_level);\n\n\tmemset(&audio_level, 0, sizeof(audio_level));\n\taudio_level.valid_mask1 = MIXART_AUDIO_LEVEL_MONITOR_MASK | MIXART_AUDIO_LEVEL_MUTE_M1_MASK;\n\taudio_level.monitor_level = mixart_digital_level[chip->monitoring_volume[channel!=0]];\n\taudio_level.monitor_mute1 = !chip->monitoring_active[channel!=0];\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\n\tif((err<0) || resp) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL card(%d) resp(%x)\\n\",\n\t\t\tchip->chip_idx, resp);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int mixart_monitor_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->monitoring_volume[0];\n\tucontrol->value.integer.value[1] = chip->monitoring_volume[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_monitor_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint i;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->monitoring_volume[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->monitoring_volume[i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tmixart_update_monitoring(chip, i);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mixart_control_monitor_vol = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =         \"Monitoring Volume\",\n\t.info =\t\tmixart_digital_vol_info,\t\t \n\t.get =\t\tmixart_monitor_vol_get,\n\t.put =\t\tmixart_monitor_vol_put,\n\t.tlv = { .p = db_scale_digital },\n};\n\n \n\nstatic int mixart_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->monitoring_active[0];\n\tucontrol->value.integer.value[1] = chip->monitoring_active[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int mixart_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint i;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->monitoring_active[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->monitoring_active[i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged |= (1<<i);  \n\t\t}\n\t}\n\tif (changed) {\n\t\t \n\t\tint allocate = chip->monitoring_active[0] ||\n\t\t\tchip->monitoring_active[1];\n\t\tif (allocate) {\n\t\t\t \n\t\t\tsnd_mixart_add_ref_pipe(chip, MIXART_PCM_ANALOG, 0, 1);\n\t\t\t \n\t\t\tsnd_mixart_add_ref_pipe(chip, MIXART_PCM_ANALOG, 1, 1);\n\t\t}\n\t\tif (changed & 0x01)\n\t\t\tmixart_update_monitoring(chip, 0);\n\t\tif (changed & 0x02)\n\t\t\tmixart_update_monitoring(chip, 1);\n\t\tif (!allocate) {\n\t\t\t \n\t\t\tsnd_mixart_kill_ref_pipe(chip->mgr,\n\t\t\t\t\t\t &chip->pipe_in_ana, 1);\n\t\t\t \n\t\t\tsnd_mixart_kill_ref_pipe(chip->mgr,\n\t\t\t\t\t\t &chip->pipe_out_ana, 1);\n\t\t}\n\t}\n\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn (changed != 0);\n}\n\nstatic const struct snd_kcontrol_new mixart_control_monitor_sw = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Monitoring Switch\",\n\t.info =         mixart_sw_info,\t\t \n\t.get =          mixart_monitor_sw_get,\n\t.put =          mixart_monitor_sw_put\n};\n\n\nstatic void mixart_reset_audio_levels(struct snd_mixart *chip)\n{\n\t \n\tmixart_update_analog_audio_level(chip, 0);\n\t \n\tif(chip->chip_idx < 2) {\n\t\tmixart_update_analog_audio_level(chip, 1);\n\t}\n\treturn;\n}\n\n\nint snd_mixart_create_mixer(struct mixart_mgr *mgr)\n{\n\tstruct snd_mixart *chip;\n\tint err, i;\n\n\tmutex_init(&mgr->mixer_mutex);  \n\n\tfor(i=0; i<mgr->num_cards; i++) {\n\t\tstruct snd_kcontrol_new temp;\n\t\tchip = mgr->chip[i];\n\n\t\t \n\t\ttemp = mixart_control_analog_level;\n\t\ttemp.name = \"Master Playback Volume\";\n\t\ttemp.private_value = 0;  \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_output_switch, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif(i<2) {\n\t\t\ttemp = mixart_control_analog_level;\n\t\t\ttemp.name = \"Master Capture Volume\";\n\t\t\ttemp.private_value = 1;  \n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\ttemp = snd_mixart_pcm_vol;\n\t\ttemp.name = \"PCM Playback Volume\";\n\t\ttemp.count = MIXART_PLAYBACK_STREAMS;\n\t\ttemp.private_value = 0;  \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\ttemp.name = \"PCM Capture Volume\";\n\t\ttemp.count = 1;\n\t\ttemp.private_value = MIXART_VOL_REC_MASK;  \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif(mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\n\t\t\ttemp.name = \"AES Playback Volume\";\n\t\t\ttemp.count = MIXART_PLAYBACK_STREAMS;\n\t\t\ttemp.private_value = MIXART_VOL_AES_MASK;  \n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\ttemp.name = \"AES Capture Volume\";\n\t\t\ttemp.count = 0;\n\t\t\ttemp.private_value = MIXART_VOL_REC_MASK | MIXART_VOL_AES_MASK;  \n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\ttemp = mixart_control_pcm_switch;\n\t\ttemp.name = \"PCM Playback Switch\";\n\t\ttemp.private_value = 0;  \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif(mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\n\t\t\ttemp.name = \"AES Playback Switch\";\n\t\t\ttemp.private_value = MIXART_VOL_AES_MASK;  \n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_vol, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_sw, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tmixart_reset_audio_levels(chip);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}