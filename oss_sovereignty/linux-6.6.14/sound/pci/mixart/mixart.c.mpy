{
  "module_name": "mixart.c",
  "hash_id": "ecaba6546f5ea2ff90e11b688fcc756073a4653f811a048aab8baa84b9bba788",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/mixart/mixart.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"mixart.h\"\n#include \"mixart_hwdep.h\"\n#include \"mixart_core.h\"\n#include \"mixart_mixer.h\"\n\n#define CARD_NAME \"miXart\"\n\nMODULE_AUTHOR(\"Digigram <alsa@digigram.com>\");\nMODULE_DESCRIPTION(\"Digigram \" CARD_NAME);\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;              \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;               \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;      \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Digigram \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Digigram \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Digigram \" CARD_NAME \" soundcard.\");\n\n \n\nstatic const struct pci_device_id snd_mixart_ids[] = {\n\t{ PCI_VDEVICE(MOTOROLA, 0x0003), 0, },  \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_mixart_ids);\n\n\nstatic int mixart_set_pipe_state(struct mixart_mgr *mgr,\n\t\t\t\t struct mixart_pipe *pipe, int start)\n{\n\tstruct mixart_group_state_req group_state;\n\tstruct mixart_group_state_resp group_state_resp;\n\tstruct mixart_msg request;\n\tint err;\n\tu32 system_msg_uid;\n\n\tswitch(pipe->status) {\n\tcase PIPE_RUNNING:\n\tcase PIPE_CLOCK_SET:\n\t\tif(start) return 0;  \n\t\tbreak;\n\tcase PIPE_STOPPED:\n\t\tif(!start) return 0;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error mixart_set_pipe_state called with wrong pipe->status!\\n\");\n\t\treturn -EINVAL;       \n\t}\n\n\tsystem_msg_uid = 0x12345678;  \n\n\t \n\n\trequest.message_id = MSG_SYSTEM_WAIT_SYNCHRO_CMD;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &system_msg_uid;\n\trequest.size = sizeof(system_msg_uid);\n\n\terr = snd_mixart_send_msg_wait_notif(mgr, &request, system_msg_uid);\n\tif(err) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error : MSG_SYSTEM_WAIT_SYNCHRO_CMD was not notified !\\n\");\n\t\treturn err;\n\t}\n\n\t \n\n\tmemset(&group_state, 0, sizeof(group_state));\n\tgroup_state.pipe_count = 1;\n\tgroup_state.pipe_uid = pipe->group_uid;\n\n\tif(start)\n\t\trequest.message_id = MSG_STREAM_START_STREAM_GRP_PACKET;\n\telse\n\t\trequest.message_id = MSG_STREAM_STOP_STREAM_GRP_PACKET;\n\n\trequest.uid = pipe->group_uid;  \n\trequest.data = &group_state;\n\trequest.size = sizeof(group_state);\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(group_state_resp), &group_state_resp);\n\tif (err < 0 || group_state_resp.txx_status != 0) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error MSG_STREAM_ST***_STREAM_GRP_PACKET err=%x stat=%x !\\n\",\n\t\t\terr, group_state_resp.txx_status);\n\t\treturn -EINVAL;\n\t}\n\n\tif(start) {\n\t\tu32 stat = 0;\n\n\t\tgroup_state.pipe_count = 0;  \n\n\t\terr = snd_mixart_send_msg(mgr, &request, sizeof(group_state_resp), &group_state_resp);\n\t\tif (err < 0 || group_state_resp.txx_status != 0) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error MSG_STREAM_START_STREAM_GRP_PACKET err=%x stat=%x !\\n\",\n\t\t\t\terr, group_state_resp.txx_status);\n \t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\trequest.message_id = MSG_SYSTEM_SEND_SYNCHRO_CMD;\n\t\trequest.uid = (struct mixart_uid){0,0};\n\t\trequest.data = NULL;\n\t\trequest.size = 0;\n\n\t\terr = snd_mixart_send_msg(mgr, &request, sizeof(stat), &stat);\n\t\tif (err < 0 || stat != 0) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error MSG_SYSTEM_SEND_SYNCHRO_CMD err=%x stat=%x !\\n\",\n\t\t\t\terr, stat);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpipe->status = PIPE_RUNNING;\n\t}\n\telse  \n\t\tpipe->status = PIPE_STOPPED;\n\n\treturn 0;\n}\n\n\nstatic int mixart_set_clock(struct mixart_mgr *mgr,\n\t\t\t    struct mixart_pipe *pipe, unsigned int rate)\n{\n\tstruct mixart_msg request;\n\tstruct mixart_clock_properties clock_properties;\n\tstruct mixart_clock_properties_resp clock_prop_resp;\n\tint err;\n\n\tswitch(pipe->status) {\n\tcase PIPE_CLOCK_SET:\n\t\tbreak;\n\tcase PIPE_RUNNING:\n\t\tif(rate != 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tif(rate == 0)\n\t\t\treturn 0;  \n\t\telse {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error mixart_set_clock(%d) called with wrong pipe->status !\\n\",\n\t\t\t\trate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmemset(&clock_properties, 0, sizeof(clock_properties));\n\tclock_properties.clock_generic_type = (rate != 0) ? CGT_INTERNAL_CLOCK : CGT_NO_CLOCK;\n\tclock_properties.clock_mode = CM_STANDALONE;\n\tclock_properties.frequency = rate;\n\tclock_properties.nb_callers = 1;  \n\tclock_properties.uid_caller = pipe->group_uid;\n\n\tdev_dbg(&mgr->pci->dev, \"mixart_set_clock to %d kHz\\n\", rate);\n\n\trequest.message_id = MSG_CLOCK_SET_PROPERTIES;\n\trequest.uid = mgr->uid_console_manager;\n\trequest.data = &clock_properties;\n\trequest.size = sizeof(clock_properties);\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(clock_prop_resp), &clock_prop_resp);\n\tif (err < 0 || clock_prop_resp.status != 0 || clock_prop_resp.clock_mode != CM_STANDALONE) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error MSG_CLOCK_SET_PROPERTIES err=%x stat=%x mod=%x !\\n\",\n\t\t\terr, clock_prop_resp.status, clock_prop_resp.clock_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif(rate)  pipe->status = PIPE_CLOCK_SET;\n\telse      pipe->status = PIPE_RUNNING;\n\n\treturn 0;\n}\n\n\n \nstruct mixart_pipe *\nsnd_mixart_add_ref_pipe(struct snd_mixart *chip, int pcm_number, int capture,\n\t\t\tint monitoring)\n{\n\tint stream_count;\n\tstruct mixart_pipe *pipe;\n\tstruct mixart_msg request;\n\n\tif(capture) {\n\t\tif (pcm_number == MIXART_PCM_ANALOG) {\n\t\t\tpipe = &(chip->pipe_in_ana);   \n\t\t} else {\n\t\t\tpipe = &(chip->pipe_in_dig);  \n\t\t}\n\t\trequest.message_id = MSG_STREAM_ADD_OUTPUT_GROUP;\n\t\tstream_count = MIXART_CAPTURE_STREAMS;\n\t} else {\n\t\tif (pcm_number == MIXART_PCM_ANALOG) {\n\t\t\tpipe = &(chip->pipe_out_ana);   \n\t\t} else {\n\t\t\tpipe = &(chip->pipe_out_dig);   \n\t\t}\n\t\trequest.message_id = MSG_STREAM_ADD_INPUT_GROUP;\n\t\tstream_count = MIXART_PLAYBACK_STREAMS;\n\t}\n\n\t \n\tif( (monitoring == 0) && (pipe->references >= stream_count) ) {\n\t\treturn NULL;\n\t}\n\n\t \n\tif( pipe->status == PIPE_UNDEFINED ) {\n\t\tint err, i;\n\t\tstruct {\n\t\t\tstruct mixart_streaming_group_req sgroup_req;\n\t\t\tstruct mixart_streaming_group sgroup_resp;\n\t\t} *buf;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"add_ref_pipe audio chip(%d) pcm(%d)\\n\",\n\t\t\tchip->chip_idx, pcm_number);\n\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn NULL;\n\n\t\trequest.uid = (struct mixart_uid){0,0};       \n\t\trequest.data = &buf->sgroup_req;\n\t\trequest.size = sizeof(buf->sgroup_req);\n\n\t\tmemset(&buf->sgroup_req, 0, sizeof(buf->sgroup_req));\n\n\t\tbuf->sgroup_req.stream_count = stream_count;\n\t\tbuf->sgroup_req.channel_count = 2;\n\t\tbuf->sgroup_req.latency = 256;\n\t\tbuf->sgroup_req.connector = pipe->uid_left_connector;   \n\n\t\tfor (i=0; i<stream_count; i++) {\n\t\t\tint j;\n\t\t\tstruct mixart_flowinfo *flowinfo;\n\t\t\tstruct mixart_bufferinfo *bufferinfo;\n\t\t\t\n\t\t\t \n\t\t\tbuf->sgroup_req.stream_info[i].size_max_byte_frame = 1024;\n\t\t\tbuf->sgroup_req.stream_info[i].size_max_sample_frame = 256;\n\t\t\tbuf->sgroup_req.stream_info[i].nb_bytes_max_per_sample = MIXART_FLOAT_P__4_0_TO_HEX;  \n\n\t\t\t \n\t\t\tj = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (pcm_number * (MIXART_PLAYBACK_STREAMS + MIXART_CAPTURE_STREAMS)) + i;\n\t\t\tif(capture) j += MIXART_PLAYBACK_STREAMS;  \n\n\t\t\tbuf->sgroup_req.flow_entry[i] = j;\n\n\t\t\tflowinfo = (struct mixart_flowinfo *)chip->mgr->flowinfo.area;\n\t\t\tflowinfo[j].bufferinfo_array_phy_address = (u32)chip->mgr->bufferinfo.addr + (j * sizeof(struct mixart_bufferinfo));\n\t\t\tflowinfo[j].bufferinfo_count = 1;                \n\n\t\t\tbufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;\n\t\t\tbufferinfo[j].buffer_address = 0;                \n\t\t\tbufferinfo[j].available_length = 0;              \n\n\t\t\t \n\t\t\tbufferinfo[j].buffer_id = (chip->chip_idx << MIXART_NOTIFY_CARD_OFFSET) + (pcm_number << MIXART_NOTIFY_PCM_OFFSET ) + i;\n\t\t\tif(capture) {\n\t\t\t\tbufferinfo[j].buffer_id |= MIXART_NOTIFY_CAPT_MASK;\n\t\t\t}\n\t\t}\n\n\t\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(buf->sgroup_resp), &buf->sgroup_resp);\n\t\tif((err < 0) || (buf->sgroup_resp.status != 0)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"error MSG_STREAM_ADD_**PUT_GROUP err=%x stat=%x !\\n\",\n\t\t\t\terr, buf->sgroup_resp.status);\n\t\t\tkfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tpipe->group_uid = buf->sgroup_resp.group;      \n\t\tpipe->stream_count = buf->sgroup_resp.stream_count;\n\t\t \n\n\t\tpipe->status = PIPE_STOPPED;\n\t\tkfree(buf);\n\t}\n\n\tif(monitoring)\tpipe->monitoring = 1;\n\telse\t\tpipe->references++;\n\n\treturn pipe;\n}\n\n\nint snd_mixart_kill_ref_pipe(struct mixart_mgr *mgr,\n\t\t\t     struct mixart_pipe *pipe, int monitoring)\n{\n\tint err = 0;\n\n\tif(pipe->status == PIPE_UNDEFINED)\n\t\treturn 0;\n\n\tif(monitoring)\n\t\tpipe->monitoring = 0;\n\telse\n\t\tpipe->references--;\n\n\tif((pipe->references <= 0) && (pipe->monitoring == 0)) {\n\n\t\tstruct mixart_msg request;\n\t\tstruct mixart_delete_group_resp delete_resp;\n\n\t\t \n\t\terr = mixart_set_clock( mgr, pipe, 0);\n\t\tif( err < 0 ) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"mixart_set_clock(0) return error!\\n\");\n\t\t}\n\n\t\t \n\t\terr = mixart_set_pipe_state(mgr, pipe, 0);\n\t\tif( err < 0 ) {\n\t\t\tdev_err(&mgr->pci->dev, \"error stopping pipe!\\n\");\n\t\t}\n\n\t\trequest.message_id = MSG_STREAM_DELETE_GROUP;\n\t\trequest.uid = (struct mixart_uid){0,0};\n\t\trequest.data = &pipe->group_uid;             \n\t\trequest.size = sizeof(pipe->group_uid);\n\n\t\t \n\t\terr = snd_mixart_send_msg(mgr, &request, sizeof(delete_resp), &delete_resp);\n\t\tif ((err < 0) || (delete_resp.status != 0)) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error MSG_STREAM_DELETE_GROUP err(%x), status(%x)\\n\",\n\t\t\t\terr, delete_resp.status);\n\t\t}\n\n\t\tpipe->group_uid = (struct mixart_uid){0,0};\n\t\tpipe->stream_count = 0;\n\t\tpipe->status = PIPE_UNDEFINED;\n\t}\n\n\treturn err;\n}\n\nstatic int mixart_set_stream_state(struct mixart_stream *stream, int start)\n{\n\tstruct snd_mixart *chip;\n\tstruct mixart_stream_state_req stream_state_req;\n\tstruct mixart_msg request;\n\n\tif(!stream->substream)\n\t\treturn -EINVAL;\n\n\tmemset(&stream_state_req, 0, sizeof(stream_state_req));\n\tstream_state_req.stream_count = 1;\n\tstream_state_req.stream_info.stream_desc.uid_pipe = stream->pipe->group_uid;\n\tstream_state_req.stream_info.stream_desc.stream_idx = stream->substream->number;\n\n\tif (stream->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\trequest.message_id = start ? MSG_STREAM_START_INPUT_STAGE_PACKET : MSG_STREAM_STOP_INPUT_STAGE_PACKET;\n\telse\n\t\trequest.message_id = start ? MSG_STREAM_START_OUTPUT_STAGE_PACKET : MSG_STREAM_STOP_OUTPUT_STAGE_PACKET;\n\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &stream_state_req;\n\trequest.size = sizeof(stream_state_req);\n\n\tstream->abs_period_elapsed = 0;             \n\tstream->buf_periods = 0;\n\tstream->buf_period_frag = 0;\n\n\tchip = snd_pcm_substream_chip(stream->substream);\n\n\treturn snd_mixart_send_msg_nonblock(chip->mgr, &request);\n}\n\n \n\nstatic int snd_mixart_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct mixart_stream *stream = subs->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\n\t\tdev_dbg(subs->pcm->card->dev, \"SNDRV_PCM_TRIGGER_START\\n\");\n\n\t\t \n\t\tif( mixart_set_stream_state(stream, 1) )\n\t\t\treturn -EINVAL;\n\n\t\tstream->status = MIXART_STREAM_STATUS_RUNNING;\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\n\t\t \n\t\tif( mixart_set_stream_state(stream, 0) )\n\t\t\treturn -EINVAL;\n\n\t\tstream->status = MIXART_STREAM_STATUS_OPEN;\n\n\t\tdev_dbg(subs->pcm->card->dev, \"SNDRV_PCM_TRIGGER_STOP\\n\");\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tstream->status = MIXART_STREAM_STATUS_PAUSE;\n\t\tdev_dbg(subs->pcm->card->dev, \"SNDRV_PCM_PAUSE_PUSH\\n\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tstream->status = MIXART_STREAM_STATUS_RUNNING;\n\t\tdev_dbg(subs->pcm->card->dev, \"SNDRV_PCM_PAUSE_RELEASE\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int mixart_sync_nonblock_events(struct mixart_mgr *mgr)\n{\n\tunsigned long timeout = jiffies + HZ;\n\twhile (atomic_read(&mgr->msg_processed) > 0) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"mixart: cannot process nonblock events!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_mixart_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\n\tstruct mixart_stream *stream = subs->runtime->private_data;\n\n\t \n\n\tdev_dbg(chip->card->dev, \"snd_mixart_prepare\\n\");\n\n\tmixart_sync_nonblock_events(chip->mgr);\n\n\t \n\t \n\tif(chip->mgr->ref_count_rate == 1)\n\t\tchip->mgr->sample_rate = subs->runtime->rate;\n\n\t \n\tif(stream->pipe->references == 1) {\n\t\tif( mixart_set_clock(chip->mgr, stream->pipe, subs->runtime->rate) )\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int mixart_set_format(struct mixart_stream *stream, snd_pcm_format_t format)\n{\n\tint err;\n\tstruct snd_mixart *chip;\n\tstruct mixart_msg request;\n\tstruct mixart_stream_param_desc stream_param;\n\tstruct mixart_return_uid resp;\n\n\tchip = snd_pcm_substream_chip(stream->substream);\n\n\tmemset(&stream_param, 0, sizeof(stream_param));\n\n\tstream_param.coding_type = CT_LINEAR;\n\tstream_param.number_of_channel = stream->channels;\n\n\tstream_param.sampling_freq = chip->mgr->sample_rate;\n\tif(stream_param.sampling_freq == 0)\n\t\tstream_param.sampling_freq = 44100;  \n\n\tswitch(format){\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tstream_param.sample_type = ST_INTEGER_8;\n\t\tstream_param.sample_size = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tstream_param.sample_type = ST_INTEGER_16LE;\n\t\tstream_param.sample_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tstream_param.sample_type = ST_INTEGER_16BE;\n\t\tstream_param.sample_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tstream_param.sample_type = ST_INTEGER_24LE;\n\t\tstream_param.sample_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\t\tstream_param.sample_type = ST_INTEGER_24BE;\n\t\tstream_param.sample_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_FLOAT_LE:\n\t\tstream_param.sample_type = ST_FLOATING_POINT_32LE;\n\t\tstream_param.sample_size = 32;\n\t\tbreak;\n\tcase  SNDRV_PCM_FORMAT_FLOAT_BE:\n\t\tstream_param.sample_type = ST_FLOATING_POINT_32BE;\n\t\tstream_param.sample_size = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"error mixart_set_format() : unknown format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(chip->card->dev,\n\t\t\"set SNDRV_PCM_FORMAT sample_type(%d) sample_size(%d) freq(%d) channels(%d)\\n\",\n\t\t   stream_param.sample_type, stream_param.sample_size, stream_param.sampling_freq, stream->channels);\n\n\t \n\t \n\t \n\t \n\n\tstream_param.pipe_count = 1;       \n\tstream_param.stream_count = 1;     \n\tstream_param.stream_desc.uid_pipe = stream->pipe->group_uid;\n\tstream_param.stream_desc.stream_idx = stream->substream->number;\n\n\trequest.message_id = MSG_STREAM_SET_INPUT_STAGE_PARAM;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &stream_param;\n\trequest.size = sizeof(stream_param);\n\n\terr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\n\tif((err < 0) || resp.error_code) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"MSG_STREAM_SET_INPUT_STAGE_PARAM err=%x; resp=%x\\n\",\n\t\t\terr, resp.error_code);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_mixart_hw_params(struct snd_pcm_substream *subs,\n                                struct snd_pcm_hw_params *hw)\n{\n\tstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\n\tstruct mixart_mgr *mgr = chip->mgr;\n\tstruct mixart_stream *stream = subs->runtime->private_data;\n\tsnd_pcm_format_t format;\n\tint err;\n\tint channels;\n\n\t \n\tchannels = params_channels(hw);\n\n\t \n\tformat = params_format(hw);\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\t \n\tif( stream->pcm_number <= MIXART_PCM_DIGITAL ) {\n\t\tint is_aes = stream->pcm_number > MIXART_PCM_ANALOG;\n\t\tif( subs->stream == SNDRV_PCM_STREAM_PLAYBACK )\n\t\t\tmixart_update_playback_stream_level(chip, is_aes, subs->number);\n\t\telse\n\t\t\tmixart_update_capture_stream_level( chip, is_aes);\n\t}\n\n\tstream->channels = channels;\n\n\t \n\terr = mixart_set_format(stream, format);\n\tif(err < 0) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\treturn err;\n\t}\n\n\tif (subs->runtime->buffer_changed) {\n\t\tstruct mixart_bufferinfo *bufferinfo;\n\t\tint i = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (stream->pcm_number * (MIXART_PLAYBACK_STREAMS+MIXART_CAPTURE_STREAMS)) + subs->number;\n\t\tif( subs->stream == SNDRV_PCM_STREAM_CAPTURE ) {\n\t\t\ti += MIXART_PLAYBACK_STREAMS;  \n\t\t}\n\t\t\n\t\tbufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;\n\t\tbufferinfo[i].buffer_address = subs->runtime->dma_addr;\n\t\tbufferinfo[i].available_length = subs->runtime->dma_bytes;\n\t\t \n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"snd_mixart_hw_params(pcm %d) : dma_addr(%x) dma_bytes(%x) subs-number(%d)\\n\",\n\t\t\ti, bufferinfo[i].buffer_address,\n\t\t\t\tbufferinfo[i].available_length,\n\t\t\t\tsubs->number);\n\t}\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn 0;\n}\n\nstatic int snd_mixart_hw_free(struct snd_pcm_substream *subs)\n{\n\tstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\n\tmixart_sync_nonblock_events(chip->mgr);\n\treturn 0;\n}\n\n\n\n \nstatic const struct snd_pcm_hardware snd_mixart_analog_caps =\n{\n\t.info             = ( SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats\t  = ( SNDRV_PCM_FMTBIT_U8 |\n\t\t\t      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t      SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t\t      SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE ),\n\t.rates            = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min         = 8000,\n\t.rate_max         = 48000,\n\t.channels_min     = 1,\n\t.channels_max     = 2,\n\t.buffer_bytes_max = (32*1024),\n\t.period_bytes_min = 256,                   \n\t.period_bytes_max = (16*1024),\n\t.periods_min      = 2,\n\t.periods_max      = (32*1024/256),\n};\n\nstatic const struct snd_pcm_hardware snd_mixart_digital_caps =\n{\n\t.info             = ( SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats\t  = ( SNDRV_PCM_FMTBIT_U8 |\n\t\t\t      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t      SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t\t      SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE ),\n\t.rates            = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min         = 32000,\n\t.rate_max         = 48000,\n\t.channels_min     = 1,\n\t.channels_max     = 2,\n\t.buffer_bytes_max = (32*1024),\n\t.period_bytes_min = 256,                   \n\t.period_bytes_max = (16*1024),\n\t.periods_min      = 2,\n\t.periods_max      = (32*1024/256),\n};\n\n\nstatic int snd_mixart_playback_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_mixart            *chip = snd_pcm_substream_chip(subs);\n\tstruct mixart_mgr        *mgr = chip->mgr;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct snd_pcm *pcm = subs->pcm;\n\tstruct mixart_stream     *stream;\n\tstruct mixart_pipe       *pipe;\n\tint err = 0;\n\tint pcm_number;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\tif ( pcm == chip->pcm ) {\n\t\tpcm_number = MIXART_PCM_ANALOG;\n\t\truntime->hw = snd_mixart_analog_caps;\n\t} else {\n\t\tsnd_BUG_ON(pcm != chip->pcm_dig);\n\t\tpcm_number = MIXART_PCM_DIGITAL;\n\t\truntime->hw = snd_mixart_digital_caps;\n\t}\n\tdev_dbg(chip->card->dev,\n\t\t\"snd_mixart_playback_open C%d/P%d/Sub%d\\n\",\n\t\tchip->chip_idx, pcm_number, subs->number);\n\n\t \n\tstream = &(chip->playback_stream[pcm_number][subs->number]);\n\n\tif (stream->status != MIXART_STREAM_STATUS_FREE){\n\t\t \n\t\tdev_err(chip->card->dev,\n\t\t\t\"snd_mixart_playback_open C%d/P%d/Sub%d in use\\n\",\n\t\t\tchip->chip_idx, pcm_number, subs->number);\n\t\terr = -EBUSY;\n\t\tgoto _exit_open;\n\t}\n\n\t \n\tpipe = snd_mixart_add_ref_pipe(chip, pcm_number, 0, 0);\n\n\tif (pipe == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto _exit_open;\n\t}\n\n\t \n\terr = mixart_set_pipe_state(chip->mgr, pipe, 1);\n\tif( err < 0 ) {\n\t\tdev_err(chip->card->dev, \"error starting pipe!\\n\");\n\t\tsnd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);\n\t\terr = -EINVAL;\n\t\tgoto _exit_open;\n\t}\n\n\tstream->pipe        = pipe;\n\tstream->pcm_number  = pcm_number;\n\tstream->status      = MIXART_STREAM_STATUS_OPEN;\n\tstream->substream   = subs;\n\tstream->channels    = 0;  \n\n\truntime->private_data = stream;\n\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 64);\n\n\t \n\tif(mgr->ref_count_rate++) {\n\t\tif(mgr->sample_rate) {\n\t\t\truntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\n\t\t}\n\t}\n\n _exit_open:\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn err;\n}\n\n\nstatic int snd_mixart_capture_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_mixart            *chip = snd_pcm_substream_chip(subs);\n\tstruct mixart_mgr        *mgr = chip->mgr;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct snd_pcm *pcm = subs->pcm;\n\tstruct mixart_stream     *stream;\n\tstruct mixart_pipe       *pipe;\n\tint err = 0;\n\tint pcm_number;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\tif ( pcm == chip->pcm ) {\n\t\tpcm_number = MIXART_PCM_ANALOG;\n\t\truntime->hw = snd_mixart_analog_caps;\n\t} else {\n\t\tsnd_BUG_ON(pcm != chip->pcm_dig);\n\t\tpcm_number = MIXART_PCM_DIGITAL;\n\t\truntime->hw = snd_mixart_digital_caps;\n\t}\n\n\truntime->hw.channels_min = 2;  \n\n\tdev_dbg(chip->card->dev, \"snd_mixart_capture_open C%d/P%d/Sub%d\\n\",\n\t\tchip->chip_idx, pcm_number, subs->number);\n\n\t \n\tstream = &(chip->capture_stream[pcm_number]);\n\n\tif (stream->status != MIXART_STREAM_STATUS_FREE){\n\t\t \n\t\tdev_err(chip->card->dev,\n\t\t\t\"snd_mixart_capture_open C%d/P%d/Sub%d in use\\n\",\n\t\t\tchip->chip_idx, pcm_number, subs->number);\n\t\terr = -EBUSY;\n\t\tgoto _exit_open;\n\t}\n\n\t \n\tpipe = snd_mixart_add_ref_pipe(chip, pcm_number, 1, 0);\n\n\tif (pipe == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto _exit_open;\n\t}\n\n\t \n\terr = mixart_set_pipe_state(chip->mgr, pipe, 1);\n\tif( err < 0 ) {\n\t\tdev_err(chip->card->dev, \"error starting pipe!\\n\");\n\t\tsnd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);\n\t\terr = -EINVAL;\n\t\tgoto _exit_open;\n\t}\n\n\tstream->pipe        = pipe;\n\tstream->pcm_number  = pcm_number;\n\tstream->status      = MIXART_STREAM_STATUS_OPEN;\n\tstream->substream   = subs;\n\tstream->channels    = 0;  \n\n\truntime->private_data = stream;\n\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 64);\n\n\t \n\tif(mgr->ref_count_rate++) {\n\t\tif(mgr->sample_rate) {\n\t\t\truntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\n\t\t}\n\t}\n\n _exit_open:\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn err;\n}\n\n\n\nstatic int snd_mixart_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_mixart *chip = snd_pcm_substream_chip(subs);\n\tstruct mixart_mgr *mgr = chip->mgr;\n\tstruct mixart_stream *stream = subs->runtime->private_data;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\tdev_dbg(chip->card->dev, \"snd_mixart_close C%d/P%d/Sub%d\\n\",\n\t\tchip->chip_idx, stream->pcm_number, subs->number);\n\n\t \n\tif(--mgr->ref_count_rate == 0) {\n\t\tmgr->sample_rate = 0;\n\t}\n\n\t \n\tif (snd_mixart_kill_ref_pipe(mgr, stream->pipe, 0 ) < 0) {\n\n\t\tdev_err(chip->card->dev,\n\t\t\t\"error snd_mixart_kill_ref_pipe C%dP%d\\n\",\n\t\t\tchip->chip_idx, stream->pcm_number);\n\t}\n\n\tstream->pipe      = NULL;\n\tstream->status    = MIXART_STREAM_STATUS_FREE;\n\tstream->substream = NULL;\n\n\tmutex_unlock(&mgr->setup_mutex);\n\treturn 0;\n}\n\n\nstatic snd_pcm_uframes_t snd_mixart_stream_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct mixart_stream   *stream  = runtime->private_data;\n\n\treturn (snd_pcm_uframes_t)((stream->buf_periods * runtime->period_size) + stream->buf_period_frag);\n}\n\n\n\nstatic const struct snd_pcm_ops snd_mixart_playback_ops = {\n\t.open      = snd_mixart_playback_open,\n\t.close     = snd_mixart_close,\n\t.prepare   = snd_mixart_prepare,\n\t.hw_params = snd_mixart_hw_params,\n\t.hw_free   = snd_mixart_hw_free,\n\t.trigger   = snd_mixart_trigger,\n\t.pointer   = snd_mixart_stream_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_mixart_capture_ops = {\n\t.open      = snd_mixart_capture_open,\n\t.close     = snd_mixart_close,\n\t.prepare   = snd_mixart_prepare,\n\t.hw_params = snd_mixart_hw_params,\n\t.hw_free   = snd_mixart_hw_free,\n\t.trigger   = snd_mixart_trigger,\n\t.pointer   = snd_mixart_stream_pointer,\n};\n\nstatic void preallocate_buffers(struct snd_mixart *chip, struct snd_pcm *pcm)\n{\n#if 0\n\tstruct snd_pcm_substream *subs;\n\tint stream;\n\n\tfor (stream = 0; stream < 2; stream++) {\n\t\tint idx = 0;\n\t\tfor (subs = pcm->streams[stream].substream; subs; subs = subs->next, idx++)\n\t\t\t \n\t\t\tsubs->dma_device.id = subs->pcm->device << 16 |\n\t\t\t\tsubs->stream << 8 | (subs->number + 1) |\n\t\t\t\t(chip->chip_idx + 1) << 24;\n\t}\n#endif\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->mgr->pci->dev,\n\t\t\t\t       32*1024, 32*1024);\n}\n\n \nstatic int snd_mixart_pcm_analog(struct snd_mixart *chip)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\tchar name[32];\n\n\tsprintf(name, \"miXart analog %d\", chip->chip_idx);\n\terr = snd_pcm_new(chip->card, name, MIXART_PCM_ANALOG,\n\t\t\t  MIXART_PLAYBACK_STREAMS,\n\t\t\t  MIXART_CAPTURE_STREAMS, &pcm);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot create the analog pcm %d\\n\", chip->chip_idx);\n\t\treturn err;\n\t}\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_mixart_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_mixart_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, name);\n\n\tpreallocate_buffers(chip, pcm);\n\n\tchip->pcm = pcm;\n\treturn 0;\n}\n\n\n \nstatic int snd_mixart_pcm_digital(struct snd_mixart *chip)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\tchar name[32];\n\n\tsprintf(name, \"miXart AES/EBU %d\", chip->chip_idx);\n\terr = snd_pcm_new(chip->card, name, MIXART_PCM_DIGITAL,\n\t\t\t  MIXART_PLAYBACK_STREAMS,\n\t\t\t  MIXART_CAPTURE_STREAMS, &pcm);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot create the digital pcm %d\\n\", chip->chip_idx);\n\t\treturn err;\n\t}\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_mixart_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_mixart_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, name);\n\n\tpreallocate_buffers(chip, pcm);\n\n\tchip->pcm_dig = pcm;\n\treturn 0;\n}\n\nstatic int snd_mixart_chip_free(struct snd_mixart *chip)\n{\n\tkfree(chip);\n\treturn 0;\n}\n\nstatic int snd_mixart_chip_dev_free(struct snd_device *device)\n{\n\tstruct snd_mixart *chip = device->device_data;\n\treturn snd_mixart_chip_free(chip);\n}\n\n\n \nstatic int snd_mixart_create(struct mixart_mgr *mgr, struct snd_card *card, int idx)\n{\n\tint err;\n\tstruct snd_mixart *chip;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_mixart_chip_dev_free,\n\t};\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->card = card;\n\tchip->chip_idx = idx;\n\tchip->mgr = mgr;\n\tcard->sync_irq = mgr->irq;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tsnd_mixart_chip_free(chip);\n\t\treturn err;\n\t}\n\n\tmgr->chip[idx] = chip;\n\treturn 0;\n}\n\nint snd_mixart_create_pcm(struct snd_mixart* chip)\n{\n\tint err;\n\n\terr = snd_mixart_pcm_analog(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif(chip->mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\n\n\t\terr = snd_mixart_pcm_digital(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}\n\n\n \nstatic int snd_mixart_free(struct mixart_mgr *mgr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tif (mgr->chip[i])\n\t\t\tsnd_card_free(mgr->chip[i]->card);\n\t}\n\n\t \n\tsnd_mixart_exit_mailbox(mgr);\n\n\t \n\tif (mgr->irq >= 0)\n\t\tfree_irq(mgr->irq, mgr);\n\n\t \n\tif(mgr->dsp_loaded) {\n\t\tsnd_mixart_reset_board(mgr);\n\t\tdev_dbg(&mgr->pci->dev, \"reset miXart !\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < 2; ++i)\n\t\tiounmap(mgr->mem[i].virt);\n\n\tpci_release_regions(mgr->pci);\n\n\t \n\tif(mgr->flowinfo.area) {\n\t\tsnd_dma_free_pages(&mgr->flowinfo);\n\t\tmgr->flowinfo.area = NULL;\n\t}\n\t \n\tif(mgr->bufferinfo.area) {\n\t\tsnd_dma_free_pages(&mgr->bufferinfo);\n\t\tmgr->bufferinfo.area = NULL;\n\t}\n\n\tpci_disable_device(mgr->pci);\n\tkfree(mgr);\n\treturn 0;\n}\n\n \n\n \nstatic ssize_t snd_mixart_BA0_read(struct snd_info_entry *entry,\n\t\t\t\t   void *file_private_data,\n\t\t\t\t   struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t pos)\n{\n\tstruct mixart_mgr *mgr = entry->private_data;\n\n\tcount = count & ~3;  \n\tif (copy_to_user_fromio(buf, MIXART_MEM(mgr, pos), count))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\n \nstatic ssize_t snd_mixart_BA1_read(struct snd_info_entry *entry,\n\t\t\t\t   void *file_private_data,\n\t\t\t\t   struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t pos)\n{\n\tstruct mixart_mgr *mgr = entry->private_data;\n\n\tcount = count & ~3;  \n\tif (copy_to_user_fromio(buf, MIXART_REG(mgr, pos), count))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\nstatic const struct snd_info_entry_ops snd_mixart_proc_ops_BA0 = {\n\t.read   = snd_mixart_BA0_read,\n};\n\nstatic const struct snd_info_entry_ops snd_mixart_proc_ops_BA1 = {\n\t.read   = snd_mixart_BA1_read,\n};\n\n\nstatic void snd_mixart_proc_read(struct snd_info_entry *entry, \n                                 struct snd_info_buffer *buffer)\n{\n\tstruct snd_mixart *chip = entry->private_data;        \n\tu32 ref; \n\n\tsnd_iprintf(buffer, \"Digigram miXart (alsa card %d)\\n\\n\", chip->chip_idx);\n\n\t \n\tif (chip->mgr->dsp_loaded & ( 1 << MIXART_MOTHERBOARD_ELF_INDEX)) {\n\t\tsnd_iprintf(buffer, \"- hardware -\\n\");\n\t\tswitch (chip->mgr->board_type ) {\n\t\tcase MIXART_DAUGHTER_TYPE_NONE     : snd_iprintf(buffer, \"\\tmiXart8 (no daughter board)\\n\\n\"); break;\n\t\tcase MIXART_DAUGHTER_TYPE_AES      : snd_iprintf(buffer, \"\\tmiXart8 AES/EBU\\n\\n\"); break;\n\t\tcase MIXART_DAUGHTER_TYPE_COBRANET : snd_iprintf(buffer, \"\\tmiXart8 Cobranet\\n\\n\"); break;\n\t\tdefault:                             snd_iprintf(buffer, \"\\tUNKNOWN!\\n\\n\"); break;\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"- system load -\\n\");\t \n\n\t\t \n\n\t\tref = readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_SYSTEM_LOAD_OFFSET));\n\n\t\tif (ref) {\n\t\t\tu32 mailbox   = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_MAILBX_LOAD_OFFSET)) / ref;\n\t\t\tu32 streaming = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_STREAM_LOAD_OFFSET)) / ref;\n\t\t\tu32 interr    = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_INTERR_LOAD_OFFSET)) / ref;\n\n\t\t\tsnd_iprintf(buffer, \"\\tstreaming          : %d\\n\", streaming);\n\t\t\tsnd_iprintf(buffer, \"\\tmailbox            : %d\\n\", mailbox);\n\t\t\tsnd_iprintf(buffer, \"\\tinterrupts handling : %d\\n\\n\", interr);\n\t\t}\n\t}  \n}\n\nstatic void snd_mixart_proc_init(struct snd_mixart *chip)\n{\n\tstruct snd_info_entry *entry;\n\n\t \n\tsnd_card_ro_proc_new(chip->card, \"board_info\", chip,\n\t\t\t     snd_mixart_proc_read);\n\n\tif (! snd_card_proc_new(chip->card, \"mixart_BA0\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = chip->mgr;\t\n\t\tentry->c.ops = &snd_mixart_proc_ops_BA0;\n\t\tentry->size = MIXART_BA0_SIZE;\n\t}\n\tif (! snd_card_proc_new(chip->card, \"mixart_BA1\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = chip->mgr;\n\t\tentry->c.ops = &snd_mixart_proc_ops_BA1;\n\t\tentry->size = MIXART_BA1_SIZE;\n\t}\n}\n \n\n\n \nstatic int snd_mixart_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct mixart_mgr *mgr;\n\tunsigned int i;\n\tint err;\n\tsize_t size;\n\n\t \n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (! enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_master(pci);\n\n\t \n\tif (dma_set_mask(&pci->dev, DMA_BIT_MASK(32)) < 0) {\n\t\tdev_err(&pci->dev,\n\t\t\t\"architecture does not support 32bit PCI busmaster DMA\\n\");\n\t\tpci_disable_device(pci);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\n\tif (! mgr) {\n\t\tpci_disable_device(pci);\n\t\treturn -ENOMEM;\n\t}\n\n\tmgr->pci = pci;\n\tmgr->irq = -1;\n\n\t \n\terr = pci_request_regions(pci, CARD_NAME);\n\tif (err < 0) {\n\t\tkfree(mgr);\n\t\tpci_disable_device(pci);\n\t\treturn err;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tmgr->mem[i].phys = pci_resource_start(pci, i);\n\t\tmgr->mem[i].virt = pci_ioremap_bar(pci, i);\n\t\tif (!mgr->mem[i].virt) {\n\t\t\tdev_err(&pci->dev, \"unable to remap resource 0x%lx\\n\",\n\t\t\t       mgr->mem[i].phys);\n\t\t\tsnd_mixart_free(mgr);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (request_threaded_irq(pci->irq, snd_mixart_interrupt,\n\t\t\t\t snd_mixart_threaded_irq, IRQF_SHARED,\n\t\t\t\t KBUILD_MODNAME, mgr)) {\n\t\tdev_err(&pci->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\tsnd_mixart_free(mgr);\n\t\treturn -EBUSY;\n\t}\n\tmgr->irq = pci->irq;\n\n\t \n\tmgr->msg_fifo_readptr = 0;\n\tmgr->msg_fifo_writeptr = 0;\n\n\tmutex_init(&mgr->lock);\n\tmutex_init(&mgr->msg_lock);\n\tinit_waitqueue_head(&mgr->msg_sleep);\n\tatomic_set(&mgr->msg_processed, 0);\n\n\t \n\tmutex_init(&mgr->setup_mutex);\n\n\t \n\tmgr->num_cards = MIXART_MAX_CARDS;  \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tstruct snd_card *card;\n\t\tchar tmpid[16];\n\t\tint idx;\n\n\t\tif (index[dev] < 0)\n\t\t\tidx = index[dev];\n\t\telse\n\t\t\tidx = index[dev] + i;\n\t\tsnprintf(tmpid, sizeof(tmpid), \"%s-%d\", id[dev] ? id[dev] : \"MIXART\", i);\n\t\terr = snd_card_new(&pci->dev, idx, tmpid, THIS_MODULE,\n\t\t\t\t   0, &card);\n\n\t\tif (err < 0) {\n\t\t\tdev_err(&pci->dev, \"cannot allocate the card %d\\n\", i);\n\t\t\tsnd_mixart_free(mgr);\n\t\t\treturn err;\n\t\t}\n\n\t\tstrcpy(card->driver, CARD_NAME);\n\t\tsnprintf(card->shortname, sizeof(card->shortname),\n\t\t\t \"Digigram miXart [PCM #%d]\", i);\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t\"Digigram miXart at 0x%lx & 0x%lx, irq %i [PCM #%d]\",\n\t\t\tmgr->mem[0].phys, mgr->mem[1].phys, mgr->irq, i);\n\n\t\terr = snd_mixart_create(mgr, card, i);\n\t\tif (err < 0) {\n\t\t\tsnd_card_free(card);\n\t\t\tsnd_mixart_free(mgr);\n\t\t\treturn err;\n\t\t}\n\n\t\tif(i==0) {\n\t\t\t \n\t\t\tsnd_mixart_proc_init(mgr->chip[i]);\n\t\t}\n\n\t\terr = snd_card_register(card);\n\t\tif (err < 0) {\n\t\t\tsnd_mixart_free(mgr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tmgr->board_type = MIXART_DAUGHTER_TYPE_NONE;\n\n\t \n\tsize = PAGE_ALIGN( (MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS *\n\t\t\t    sizeof(struct mixart_flowinfo)) );\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\tsize, &mgr->flowinfo) < 0) {\n\t\tsnd_mixart_free(mgr);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tmemset(mgr->flowinfo.area, 0, size);\n\n\t \n\tsize = PAGE_ALIGN( (MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS *\n\t\t\t    sizeof(struct mixart_bufferinfo)) );\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\tsize, &mgr->bufferinfo) < 0) {\n\t\tsnd_mixart_free(mgr);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tmemset(mgr->bufferinfo.area, 0, size);\n\n\t \n\terr = snd_mixart_setup_firmware(mgr);\n\tif (err < 0) {\n\t\tsnd_mixart_free(mgr);\n\t\treturn err;\n\t}\n\n\tpci_set_drvdata(pci, mgr);\n\tdev++;\n\treturn 0;\n}\n\nstatic void snd_mixart_remove(struct pci_dev *pci)\n{\n\tsnd_mixart_free(pci_get_drvdata(pci));\n}\n\nstatic struct pci_driver mixart_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_mixart_ids,\n\t.probe = snd_mixart_probe,\n\t.remove = snd_mixart_remove,\n};\n\nmodule_pci_driver(mixart_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}