{
  "module_name": "mixart_core.c",
  "hash_id": "d95a145d84f1b4dee10e6dbb74699e35414e7cd1d0c876d8e90d3480470da206",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/mixart/mixart_core.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include \"mixart.h\"\n#include \"mixart_hwdep.h\"\n#include \"mixart_core.h\"\n\n\n#define MSG_TIMEOUT_JIFFIES         (400 * HZ) / 1000  \n\n#define MSG_DESCRIPTOR_SIZE         0x24\n#define MSG_HEADER_SIZE             (MSG_DESCRIPTOR_SIZE + 4)\n\n#define MSG_TYPE_MASK               0x00000003     \n#define MSG_TYPE_NOTIFY             0              \n#define MSG_TYPE_COMMAND            1              \n#define MSG_TYPE_REQUEST            2              \n#define MSG_TYPE_ANSWER             3              \n#define MSG_CANCEL_NOTIFY_MASK      0x80000000     \n\n\nstatic int retrieve_msg_frame(struct mixart_mgr *mgr, u32 *msg_frame)\n{\n\t \n\tu32 headptr, tailptr;\n\n\ttailptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_POST_TAIL));\n\theadptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_POST_HEAD));\n\n\tif (tailptr == headptr)\n\t\treturn 0;  \n\n\tif (tailptr < MSG_OUTBOUND_POST_STACK)\n\t\treturn 0;  \n\tif (tailptr >= MSG_OUTBOUND_POST_STACK + MSG_BOUND_STACK_SIZE)\n\t\treturn 0;  \n\n\t*msg_frame = readl_be(MIXART_MEM(mgr, tailptr));\n\n\t \n\ttailptr += 4;\n\tif( tailptr >= (MSG_OUTBOUND_POST_STACK+MSG_BOUND_STACK_SIZE) )\n\t\ttailptr = MSG_OUTBOUND_POST_STACK;\n\twritel_be(tailptr, MIXART_MEM(mgr, MSG_OUTBOUND_POST_TAIL));\n\n\treturn 1;\n}\n\nstatic int get_msg(struct mixart_mgr *mgr, struct mixart_msg *resp,\n\t\t   u32 msg_frame_address )\n{\n\tu32  headptr;\n\tu32  size;\n\tint  err;\n#ifndef __BIG_ENDIAN\n\tunsigned int i;\n#endif\n\n\terr = 0;\n\n\t \n\tsize                =  readl_be(MIXART_MEM(mgr, msg_frame_address));        \n\tresp->message_id    =  readl_be(MIXART_MEM(mgr, msg_frame_address + 4));    \n\tresp->uid.object_id =  readl_be(MIXART_MEM(mgr, msg_frame_address + 8));    \n\tresp->uid.desc      =  readl_be(MIXART_MEM(mgr, msg_frame_address + 12));   \n\n\tif( (size < MSG_DESCRIPTOR_SIZE) || (resp->size < (size - MSG_DESCRIPTOR_SIZE))) {\n\t\terr = -EINVAL;\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"problem with response size = %d\\n\", size);\n\t\tgoto _clean_exit;\n\t}\n\tsize -= MSG_DESCRIPTOR_SIZE;\n\n\tmemcpy_fromio(resp->data, MIXART_MEM(mgr, msg_frame_address + MSG_HEADER_SIZE ), size);\n\tresp->size = size;\n\n\t \n#ifndef __BIG_ENDIAN\n\tsize /= 4;  \n\tfor(i=0; i < size; i++) {\n\t\t((u32*)resp->data)[i] = be32_to_cpu(((__be32*)resp->data)[i]);\n\t}\n#endif\n\n\t \n\theadptr = readl_be(MIXART_MEM(mgr, MSG_OUTBOUND_FREE_HEAD));\n\n\tif( (headptr < MSG_OUTBOUND_FREE_STACK) || ( headptr >= (MSG_OUTBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE))) {\n\t\terr = -EINVAL;\n\t\tgoto _clean_exit;\n\t}\n\n\t \n\twritel_be(msg_frame_address, MIXART_MEM(mgr, headptr));\n\n\t \n\theadptr += 4;\n\tif( headptr >= (MSG_OUTBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE) )\n\t\theadptr = MSG_OUTBOUND_FREE_STACK;\n\n\twritel_be(headptr, MIXART_MEM(mgr, MSG_OUTBOUND_FREE_HEAD));\n\n _clean_exit:\n\treturn err;\n}\n\n\n \n \nstatic int send_msg( struct mixart_mgr *mgr,\n\t\t     struct mixart_msg *msg,\n\t\t     int max_answersize,\n\t\t     int mark_pending,\n\t\t     u32 *msg_event)\n{\n\tu32 headptr, tailptr;\n\tu32 msg_frame_address;\n\tint i;\n\n\tif (snd_BUG_ON(msg->size % 4))\n\t\treturn -EINVAL;\n\n\t \n\ttailptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_FREE_TAIL));\n\theadptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_FREE_HEAD));\n\n\tif (tailptr == headptr) {\n\t\tdev_err(&mgr->pci->dev, \"error: no message frame available\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif( (tailptr < MSG_INBOUND_FREE_STACK) || (tailptr >= (MSG_INBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE))) {\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_frame_address = readl_be(MIXART_MEM(mgr, tailptr));\n\twritel(0, MIXART_MEM(mgr, tailptr));  \n\n\t \n\ttailptr += 4;\n\tif( tailptr >= (MSG_INBOUND_FREE_STACK+MSG_BOUND_STACK_SIZE) )\n\t\ttailptr = MSG_INBOUND_FREE_STACK;\n\n\twritel_be(tailptr, MIXART_MEM(mgr, MSG_INBOUND_FREE_TAIL));\n\n\t \n\n\t \n\twritel_be( msg->size + MSG_DESCRIPTOR_SIZE,      MIXART_MEM(mgr, msg_frame_address) );       \n\twritel_be( msg->message_id ,                     MIXART_MEM(mgr, msg_frame_address + 4) );   \n\twritel_be( msg->uid.object_id,                   MIXART_MEM(mgr, msg_frame_address + 8) );   \n\twritel_be( msg->uid.desc,                        MIXART_MEM(mgr, msg_frame_address + 12) );  \n\twritel_be( MSG_DESCRIPTOR_SIZE,                  MIXART_MEM(mgr, msg_frame_address + 16) );  \n\twritel_be( MSG_DESCRIPTOR_SIZE,                  MIXART_MEM(mgr, msg_frame_address + 20) );  \n\twritel_be( msg->size,                            MIXART_MEM(mgr, msg_frame_address + 24) );  \n\twritel_be( MSG_DESCRIPTOR_SIZE,                  MIXART_MEM(mgr, msg_frame_address + 28) );  \n\twritel_be( 0,                                    MIXART_MEM(mgr, msg_frame_address + 32) );  \n\twritel_be( MSG_DESCRIPTOR_SIZE + max_answersize, MIXART_MEM(mgr, msg_frame_address + 36) );  \n\n\t \n\tfor( i=0; i < msg->size; i+=4 ) {\n\t\twritel_be( *(u32*)(msg->data + i), MIXART_MEM(mgr, MSG_HEADER_SIZE + msg_frame_address + i)  );\n\t}\n\n\tif( mark_pending ) {\n\t\tif( *msg_event ) {\n\t\t\t \n\t\t\tmgr->pending_event = *msg_event;\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tmgr->pending_event = msg_frame_address;\n\n\t\t\t \n\t\t\t*msg_event = msg_frame_address;\n\t\t}\n\t}\n\n\t \n\tmsg_frame_address |= MSG_TYPE_REQUEST;\n\n\t \n\theadptr = readl_be(MIXART_MEM(mgr, MSG_INBOUND_POST_HEAD));\n\n\tif( (headptr < MSG_INBOUND_POST_STACK) || (headptr >= (MSG_INBOUND_POST_STACK+MSG_BOUND_STACK_SIZE))) {\n\t\treturn -EINVAL;\n\t}\n\n\twritel_be(msg_frame_address, MIXART_MEM(mgr, headptr));\n\n\t \n\theadptr += 4;\n\tif( headptr >= (MSG_INBOUND_POST_STACK+MSG_BOUND_STACK_SIZE) )\n\t\theadptr = MSG_INBOUND_POST_STACK;\n\n\twritel_be(headptr, MIXART_MEM(mgr, MSG_INBOUND_POST_HEAD));\n\n\treturn 0;\n}\n\n\nint snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int max_resp_size, void *resp_data)\n{\n\tstruct mixart_msg resp;\n\tu32 msg_frame = 0;  \n\tint err;\n\twait_queue_entry_t wait;\n\tlong timeout;\n\n\tinit_waitqueue_entry(&wait, current);\n\n\tmutex_lock(&mgr->msg_lock);\n\t \n\terr = send_msg(mgr, request, max_resp_size, 1, &msg_frame);   \n\tif (err) {\n\t\tmutex_unlock(&mgr->msg_lock);\n\t\treturn err;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tadd_wait_queue(&mgr->msg_sleep, &wait);\n\tmutex_unlock(&mgr->msg_lock);\n\ttimeout = schedule_timeout(MSG_TIMEOUT_JIFFIES);\n\tremove_wait_queue(&mgr->msg_sleep, &wait);\n\n\tif (! timeout) {\n\t\t \n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error: no response on msg %x\\n\", msg_frame);\n\t\treturn -EIO;\n\t}\n\n\t \n\tresp.message_id = 0;\n\tresp.uid = (struct mixart_uid){0,0};\n\tresp.data = resp_data;\n\tresp.size = max_resp_size;\n\n\tmutex_lock(&mgr->msg_lock);\n\terr = get_msg(mgr, &resp, msg_frame);\n\tmutex_unlock(&mgr->msg_lock);\n\n\tif( request->message_id != resp.message_id )\n\t\tdev_err(&mgr->pci->dev, \"RESPONSE ERROR!\\n\");\n\n\treturn err;\n}\n\n\nint snd_mixart_send_msg_wait_notif(struct mixart_mgr *mgr,\n\t\t\t\t   struct mixart_msg *request, u32 notif_event)\n{\n\tint err;\n\twait_queue_entry_t wait;\n\tlong timeout;\n\n\tif (snd_BUG_ON(!notif_event))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON((notif_event & MSG_TYPE_MASK) != MSG_TYPE_NOTIFY))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(notif_event & MSG_CANCEL_NOTIFY_MASK))\n\t\treturn -EINVAL;\n\n\tinit_waitqueue_entry(&wait, current);\n\n\tmutex_lock(&mgr->msg_lock);\n\t \n\terr = send_msg(mgr, request, MSG_DEFAULT_SIZE, 1, &notif_event);   \n\tif(err) {\n\t\tmutex_unlock(&mgr->msg_lock);\n\t\treturn err;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tadd_wait_queue(&mgr->msg_sleep, &wait);\n\tmutex_unlock(&mgr->msg_lock);\n\ttimeout = schedule_timeout(MSG_TIMEOUT_JIFFIES);\n\tremove_wait_queue(&mgr->msg_sleep, &wait);\n\n\tif (! timeout) {\n\t\t \n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error: notification %x not received\\n\", notif_event);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n\nint snd_mixart_send_msg_nonblock(struct mixart_mgr *mgr, struct mixart_msg *request)\n{\n\tu32 message_frame;\n\tint err;\n\n\t \n\tmutex_lock(&mgr->msg_lock);\n\terr = send_msg(mgr, request, MSG_DEFAULT_SIZE, 0, &message_frame);\n\tmutex_unlock(&mgr->msg_lock);\n\n\t \n\tatomic_inc(&mgr->msg_processed);\n\n\treturn err;\n}\n\n\n \nstatic u32 mixart_msg_data[MSG_DEFAULT_SIZE / 4];\n\n\nstatic void snd_mixart_process_msg(struct mixart_mgr *mgr)\n{\n\tstruct mixart_msg resp;\n\tu32 msg, addr, type;\n\tint err;\n\n\twhile (mgr->msg_fifo_readptr != mgr->msg_fifo_writeptr) {\n\t\tmsg = mgr->msg_fifo[mgr->msg_fifo_readptr];\n\t\tmgr->msg_fifo_readptr++;\n\t\tmgr->msg_fifo_readptr %= MSG_FIFO_SIZE;\n\n\t\t \n\t\taddr = msg & ~MSG_TYPE_MASK;\n\t\ttype = msg & MSG_TYPE_MASK;\n\n\t\tswitch (type) {\n\t\tcase MSG_TYPE_ANSWER:\n\t\t\t \n\t\t\tresp.message_id = 0;\n\t\t\tresp.data = mixart_msg_data;\n\t\t\tresp.size = sizeof(mixart_msg_data);\n\t\t\terr = get_msg(mgr, &resp, addr);\n\t\t\tif( err < 0 ) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t\"error(%d) reading mf %x\\n\",\n\t\t\t\t\terr, msg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(resp.message_id) {\n\t\t\tcase MSG_STREAM_START_INPUT_STAGE_PACKET:\n\t\t\tcase MSG_STREAM_START_OUTPUT_STAGE_PACKET:\n\t\t\tcase MSG_STREAM_STOP_INPUT_STAGE_PACKET:\n\t\t\tcase MSG_STREAM_STOP_OUTPUT_STAGE_PACKET:\n\t\t\t\tif(mixart_msg_data[0])\n\t\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t\t\"error MSG_STREAM_ST***_***PUT_STAGE_PACKET status=%x\\n\",\n\t\t\t\t\t\tmixart_msg_data[0]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"received mf(%x) : msg_id(%x) uid(%x, %x) size(%zd)\\n\",\n\t\t\t\t\t   msg, resp.message_id, resp.uid.object_id, resp.uid.desc, resp.size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase MSG_TYPE_NOTIFY:\n\t\t\t \n\t\tcase MSG_TYPE_COMMAND:\n\t\t\t \n\t\tdefault:\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"doesn't know what to do with message %x\\n\",\n\t\t\t\tmsg);\n\t\t}  \n\n\t\t \n\t\tatomic_dec(&mgr->msg_processed);\n\n\t}  \n}\n\n\nirqreturn_t snd_mixart_interrupt(int irq, void *dev_id)\n{\n\tstruct mixart_mgr *mgr = dev_id;\n\tu32 it_reg;\n\n\tit_reg = readl_le(MIXART_REG(mgr, MIXART_PCI_OMISR_OFFSET));\n\tif( !(it_reg & MIXART_OIDI) ) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel_le(MIXART_HOST_ALL_INTERRUPT_MASKED, MIXART_REG(mgr, MIXART_PCI_OMIMR_OFFSET));\n\n\t \n\tit_reg = readl(MIXART_REG(mgr, MIXART_PCI_ODBR_OFFSET));\n\twritel(it_reg, MIXART_REG(mgr, MIXART_PCI_ODBR_OFFSET));\n\n\t \n\twritel_le( MIXART_OIDI, MIXART_REG(mgr, MIXART_PCI_OMISR_OFFSET) );\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nirqreturn_t snd_mixart_threaded_irq(int irq, void *dev_id)\n{\n\tstruct mixart_mgr *mgr = dev_id;\n\tint err;\n\tstruct mixart_msg resp;\n\tu32 msg;\n\n\tmutex_lock(&mgr->lock);\n\t \n\twhile (retrieve_msg_frame(mgr, &msg)) {\n\n\t\tswitch (msg & MSG_TYPE_MASK) {\n\t\tcase MSG_TYPE_COMMAND:\n\t\t\tresp.message_id = 0;\n\t\t\tresp.data = mixart_msg_data;\n\t\t\tresp.size = sizeof(mixart_msg_data);\n\t\t\terr = get_msg(mgr, &resp, msg & ~MSG_TYPE_MASK);\n\t\t\tif( err < 0 ) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t\"interrupt: error(%d) reading mf %x\\n\",\n\t\t\t\t\terr, msg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(resp.message_id == MSG_SERVICES_TIMER_NOTIFY) {\n\t\t\t\tint i;\n\t\t\t\tstruct mixart_timer_notify *notify;\n\t\t\t\tnotify = (struct mixart_timer_notify *)mixart_msg_data;\n\n\t\t\t\tBUILD_BUG_ON(sizeof(notify) > sizeof(mixart_msg_data));\n\t\t\t\tif (snd_BUG_ON(notify->stream_count > ARRAY_SIZE(notify->streams)))\n\t\t\t\t\tbreak;\n\t\t\t\tfor(i=0; i<notify->stream_count; i++) {\n\n\t\t\t\t\tu32 buffer_id = notify->streams[i].buffer_id;\n\t\t\t\t\tunsigned int chip_number =  (buffer_id & MIXART_NOTIFY_CARD_MASK) >> MIXART_NOTIFY_CARD_OFFSET;  \n\t\t\t\t\tunsigned int pcm_number  =  (buffer_id & MIXART_NOTIFY_PCM_MASK ) >> MIXART_NOTIFY_PCM_OFFSET;   \n\t\t\t\t\tunsigned int sub_number  =   buffer_id & MIXART_NOTIFY_SUBS_MASK;              \n\t\t\t\t\tunsigned int is_capture  = ((buffer_id & MIXART_NOTIFY_CAPT_MASK) != 0);       \n\n\t\t\t\t\tstruct snd_mixart *chip  = mgr->chip[chip_number];\n\t\t\t\t\tstruct mixart_stream *stream;\n\n\t\t\t\t\tif ((chip_number >= mgr->num_cards) || (pcm_number >= MIXART_PCM_TOTAL) || (sub_number >= MIXART_PLAYBACK_STREAMS)) {\n\t\t\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t\t\t\"error MSG_SERVICES_TIMER_NOTIFY buffer_id (%x) pos(%d)\\n\",\n\t\t\t\t\t\t\t   buffer_id, notify->streams[i].sample_pos_low_part);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_capture)\n\t\t\t\t\t\tstream = &chip->capture_stream[pcm_number];\n\t\t\t\t\telse\n\t\t\t\t\t\tstream = &chip->playback_stream[pcm_number][sub_number];\n\n\t\t\t\t\tif (stream->substream && (stream->status == MIXART_STREAM_STATUS_RUNNING)) {\n\t\t\t\t\t\tstruct snd_pcm_runtime *runtime = stream->substream->runtime;\n\t\t\t\t\t\tint elapsed = 0;\n\t\t\t\t\t\tu64 sample_count = ((u64)notify->streams[i].sample_pos_high_part) << 32;\n\t\t\t\t\t\tsample_count |= notify->streams[i].sample_pos_low_part;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tu64 new_elapse_pos = stream->abs_period_elapsed +  runtime->period_size;\n\n\t\t\t\t\t\t\tif (new_elapse_pos > sample_count) {\n\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\telapsed = 1;\n\t\t\t\t\t\t\t\tstream->buf_periods++;\n\t\t\t\t\t\t\t\tif (stream->buf_periods >= runtime->periods)\n\t\t\t\t\t\t\t\t\tstream->buf_periods = 0;\n\n\t\t\t\t\t\t\t\tstream->abs_period_elapsed = new_elapse_pos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstream->buf_period_frag = (u32)( sample_count - stream->abs_period_elapsed );\n\n\t\t\t\t\t\tif(elapsed) {\n\t\t\t\t\t\t\tmutex_unlock(&mgr->lock);\n\t\t\t\t\t\t\tsnd_pcm_period_elapsed(stream->substream);\n\t\t\t\t\t\t\tmutex_lock(&mgr->lock);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(resp.message_id == MSG_SERVICES_REPORT_TRACES) {\n\t\t\t\tif(resp.size > 1) {\n#ifndef __BIG_ENDIAN\n\t\t\t\t\t \n\t\t\t\t\tint i;\n\t\t\t\t\tfor(i=0; i<(resp.size/4); i++) {\n\t\t\t\t\t\t((__be32*)mixart_msg_data)[i] = cpu_to_be32((mixart_msg_data)[i]);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t((char*)mixart_msg_data)[resp.size - 1] = 0;\n\t\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\t\"MIXART TRACE : %s\\n\",\n\t\t\t\t\t\t(char *)mixart_msg_data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev_dbg(&mgr->pci->dev, \"command %x not handled\\n\",\n\t\t\t\tresp.message_id);\n\t\t\tbreak;\n\n\t\tcase MSG_TYPE_NOTIFY:\n\t\t\tif(msg & MSG_CANCEL_NOTIFY_MASK) {\n\t\t\t\tmsg &= ~MSG_CANCEL_NOTIFY_MASK;\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t\"canceled notification %x !\\n\", msg);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase MSG_TYPE_ANSWER:\n\t\t\t \n\t\t\tmutex_lock(&mgr->msg_lock);\n\t\t\tif( (msg & ~MSG_TYPE_MASK) == mgr->pending_event ) {\n\t\t\t\twake_up(&mgr->msg_sleep);\n\t\t\t\tmgr->pending_event = 0;\n\t\t\t}\n\t\t\t \n\t\t\telse {\n\t\t\t\tmgr->msg_fifo[mgr->msg_fifo_writeptr] = msg;\n\t\t\t\tmgr->msg_fifo_writeptr++;\n\t\t\t\tmgr->msg_fifo_writeptr %= MSG_FIFO_SIZE;\n\t\t\t\tsnd_mixart_process_msg(mgr);\n\t\t\t}\n\t\t\tmutex_unlock(&mgr->msg_lock);\n\t\t\tbreak;\n\t\tcase MSG_TYPE_REQUEST:\n\t\tdefault:\n\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\"interrupt received request %x\\n\", msg);\n\t\t\t \n\t\t\tbreak;\n\t\t}  \n\t}  \n\n\t \n\twritel_le( MIXART_ALLOW_OUTBOUND_DOORBELL, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\n\n\tmutex_unlock(&mgr->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n\nvoid snd_mixart_init_mailbox(struct mixart_mgr *mgr)\n{\n\twritel( 0, MIXART_MEM( mgr, MSG_HOST_RSC_PROTECTION ) );\n\twritel( 0, MIXART_MEM( mgr, MSG_AGENT_RSC_PROTECTION ) );\n\n\t \n\tif(mgr->irq >= 0) {\n\t\twritel_le( MIXART_ALLOW_OUTBOUND_DOORBELL, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\n\t}\n\treturn;\n}\n\nvoid snd_mixart_exit_mailbox(struct mixart_mgr *mgr)\n{\n\t \n\twritel_le( MIXART_HOST_ALL_INTERRUPT_MASKED, MIXART_REG( mgr, MIXART_PCI_OMIMR_OFFSET));\n\treturn;\n}\n\nvoid snd_mixart_reset_board(struct mixart_mgr *mgr)\n{\n\t \n\twritel_be( 1, MIXART_REG(mgr, MIXART_BA1_BRUTAL_RESET_OFFSET) );\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}