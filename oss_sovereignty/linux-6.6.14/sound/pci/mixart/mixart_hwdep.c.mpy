{
  "module_name": "mixart_hwdep.c",
  "hash_id": "507f83adf5d96168f81e8e7a42539523bac36619d2eb233ea47da23957867319",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/mixart/mixart_hwdep.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include \"mixart.h\"\n#include \"mixart_mixer.h\"\n#include \"mixart_core.h\"\n#include \"mixart_hwdep.h\"\n\n\n \nstatic int mixart_wait_nice_for_register_value(struct mixart_mgr *mgr,\n\t\t\t\t\t       u32 offset, int is_egal,\n\t\t\t\t\t       u32 value, unsigned long timeout)\n{\n\tunsigned long end_time = jiffies + (timeout * HZ / 100);\n\tu32 read;\n\n\tdo {\t \n\t\tcond_resched();\n\n\t\tread = readl_be( MIXART_MEM( mgr, offset ));\n\t\tif(is_egal) {\n\t\t\tif(read == value) return 0;\n\t\t}\n\t\telse {  \n\t\t\tif(read != value) return 0;\n\t\t}\n\t} while ( time_after_eq(end_time, jiffies) );\n\n\treturn -EBUSY;\n}\n\n\n \nstruct snd_mixart_elf32_ehdr {\n\tu8      e_ident[16];\n\t__be16  e_type;\n\t__be16  e_machine;\n\t__be32  e_version;\n\t__be32  e_entry;\n\t__be32  e_phoff;\n\t__be32  e_shoff;\n\t__be32  e_flags;\n\t__be16  e_ehsize;\n\t__be16  e_phentsize;\n\t__be16  e_phnum;\n\t__be16  e_shentsize;\n\t__be16  e_shnum;\n\t__be16  e_shstrndx;\n};\n\nstruct snd_mixart_elf32_phdr {\n\t__be32  p_type;\n\t__be32  p_offset;\n\t__be32  p_vaddr;\n\t__be32  p_paddr;\n\t__be32  p_filesz;\n\t__be32  p_memsz;\n\t__be32  p_flags;\n\t__be32  p_align;\n};\n\nstatic int mixart_load_elf(struct mixart_mgr *mgr, const struct firmware *dsp )\n{\n\tchar                    elf32_magic_number[4] = {0x7f,'E','L','F'};\n\tstruct snd_mixart_elf32_ehdr *elf_header;\n\tint                     i;\n\n\telf_header = (struct snd_mixart_elf32_ehdr *)dsp->data;\n\tfor( i=0; i<4; i++ )\n\t\tif ( elf32_magic_number[i] != elf_header->e_ident[i] )\n\t\t\treturn -EINVAL;\n\n\tif( elf_header->e_phoff != 0 ) {\n\t\tstruct snd_mixart_elf32_phdr     elf_programheader;\n\n\t\tfor( i=0; i < be16_to_cpu(elf_header->e_phnum); i++ ) {\n\t\t\tu32 pos = be32_to_cpu(elf_header->e_phoff) + (u32)(i * be16_to_cpu(elf_header->e_phentsize));\n\n\t\t\tmemcpy( &elf_programheader, dsp->data + pos, sizeof(elf_programheader) );\n\n\t\t\tif(elf_programheader.p_type != 0) {\n\t\t\t\tif( elf_programheader.p_filesz != 0 ) {\n\t\t\t\t\tmemcpy_toio( MIXART_MEM( mgr, be32_to_cpu(elf_programheader.p_vaddr)),\n\t\t\t\t\t\t     dsp->data + be32_to_cpu( elf_programheader.p_offset ),\n\t\t\t\t\t\t     be32_to_cpu( elf_programheader.p_filesz ));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n \n#define MIXART_FIRST_ANA_AUDIO_ID       0\n#define MIXART_FIRST_DIG_AUDIO_ID       8\n\nstatic int mixart_enum_connectors(struct mixart_mgr *mgr)\n{\n\tu32 k;\n\tint err;\n\tstruct mixart_msg request;\n\tstruct mixart_enum_connector_resp *connector;\n\tstruct mixart_audio_info_req  *audio_info_req;\n\tstruct mixart_audio_info_resp *audio_info;\n\n\tconnector = kmalloc(sizeof(*connector), GFP_KERNEL);\n\taudio_info_req = kmalloc(sizeof(*audio_info_req), GFP_KERNEL);\n\taudio_info = kmalloc(sizeof(*audio_info), GFP_KERNEL);\n\tif (! connector || ! audio_info_req || ! audio_info) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\taudio_info_req->line_max_level = MIXART_FLOAT_P_22_0_TO_HEX;\n\taudio_info_req->micro_max_level = MIXART_FLOAT_M_20_0_TO_HEX;\n\taudio_info_req->cd_max_level = MIXART_FLOAT____0_0_TO_HEX;\n\n\trequest.message_id = MSG_SYSTEM_ENUM_PLAY_CONNECTOR;\n\trequest.uid = (struct mixart_uid){0,0};   \n\trequest.data = NULL;\n\trequest.size = 0;\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(*connector), connector);\n\tif((err < 0) || (connector->error_code) || (connector->uid_count > MIXART_MAX_PHYS_CONNECTORS)) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error MSG_SYSTEM_ENUM_PLAY_CONNECTOR\\n\");\n\t\terr = -EINVAL;\n\t\tgoto __error;\n\t}\n\n\tfor(k=0; k < connector->uid_count; k++) {\n\t\tstruct mixart_pipe *pipe;\n\n\t\tif(k < MIXART_FIRST_DIG_AUDIO_ID) {\n\t\t\tpipe = &mgr->chip[k/2]->pipe_out_ana;\n\t\t} else {\n\t\t\tpipe = &mgr->chip[(k-MIXART_FIRST_DIG_AUDIO_ID)/2]->pipe_out_dig;\n\t\t}\n\t\tif(k & 1) {\n\t\t\tpipe->uid_right_connector = connector->uid[k];    \n\t\t} else {\n\t\t\tpipe->uid_left_connector = connector->uid[k];     \n\t\t}\n\n\t\t \n\n\t\t \n\t\trequest.message_id = MSG_CONNECTOR_GET_AUDIO_INFO;\n\t\trequest.uid = connector->uid[k];\n\t\trequest.data = audio_info_req;\n\t\trequest.size = sizeof(*audio_info_req);\n\n\t\terr = snd_mixart_send_msg(mgr, &request, sizeof(*audio_info), audio_info);\n\t\tif( err < 0 ) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error MSG_CONNECTOR_GET_AUDIO_INFO\\n\");\n\t\t\tgoto __error;\n\t\t}\n\t\t \n\t}\n\n\trequest.message_id = MSG_SYSTEM_ENUM_RECORD_CONNECTOR;\n\trequest.uid = (struct mixart_uid){0,0};   \n\trequest.data = NULL;\n\trequest.size = 0;\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(*connector), connector);\n\tif((err < 0) || (connector->error_code) || (connector->uid_count > MIXART_MAX_PHYS_CONNECTORS)) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error MSG_SYSTEM_ENUM_RECORD_CONNECTOR\\n\");\n\t\terr = -EINVAL;\n\t\tgoto __error;\n\t}\n\n\tfor(k=0; k < connector->uid_count; k++) {\n\t\tstruct mixart_pipe *pipe;\n\n\t\tif(k < MIXART_FIRST_DIG_AUDIO_ID) {\n\t\t\tpipe = &mgr->chip[k/2]->pipe_in_ana;\n\t\t} else {\n\t\t\tpipe = &mgr->chip[(k-MIXART_FIRST_DIG_AUDIO_ID)/2]->pipe_in_dig;\n\t\t}\n\t\tif(k & 1) {\n\t\t\tpipe->uid_right_connector = connector->uid[k];    \n\t\t} else {\n\t\t\tpipe->uid_left_connector = connector->uid[k];     \n\t\t}\n\n\t\t \n\n\t\t \n\t\trequest.message_id = MSG_CONNECTOR_GET_AUDIO_INFO;\n\t\trequest.uid = connector->uid[k];\n\t\trequest.data = audio_info_req;\n\t\trequest.size = sizeof(*audio_info_req);\n\n\t\terr = snd_mixart_send_msg(mgr, &request, sizeof(*audio_info), audio_info);\n\t\tif( err < 0 ) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"error MSG_CONNECTOR_GET_AUDIO_INFO\\n\");\n\t\t\tgoto __error;\n\t\t}\n\t\t \n\t}\n\terr = 0;\n\n __error:\n\tkfree(connector);\n\tkfree(audio_info_req);\n\tkfree(audio_info);\n\n\treturn err;\n}\n\nstatic int mixart_enum_physio(struct mixart_mgr *mgr)\n{\n\tu32 k;\n\tint err;\n\tstruct mixart_msg request;\n\tstruct mixart_uid get_console_mgr;\n\tstruct mixart_return_uid console_mgr;\n\tstruct mixart_uid_enumeration phys_io;\n\n\t \n\tget_console_mgr.object_id = 0;\n\tget_console_mgr.desc = MSG_CONSOLE_MANAGER | 0;  \n\n\trequest.message_id = MSG_CONSOLE_GET_CLOCK_UID;\n\trequest.uid = get_console_mgr;\n\trequest.data = &get_console_mgr;\n\trequest.size = sizeof(get_console_mgr);\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(console_mgr), &console_mgr);\n\n\tif( (err < 0) || (console_mgr.error_code != 0) ) {\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"error MSG_CONSOLE_GET_CLOCK_UID : err=%x\\n\",\n\t\t\tconsole_mgr.error_code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmgr->uid_console_manager = console_mgr.uid;\n\n\trequest.message_id = MSG_SYSTEM_ENUM_PHYSICAL_IO;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = &console_mgr.uid;\n\trequest.size = sizeof(console_mgr.uid);\n\n\terr = snd_mixart_send_msg(mgr, &request, sizeof(phys_io), &phys_io);\n\tif( (err < 0) || ( phys_io.error_code != 0 ) ) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"error MSG_SYSTEM_ENUM_PHYSICAL_IO err(%x) error_code(%x)\\n\",\n\t\t\terr, phys_io.error_code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (phys_io.nb_uid < MIXART_MAX_CARDS * 2)\n\t\treturn -EINVAL;\n\n\tfor(k=0; k<mgr->num_cards; k++) {\n\t\tmgr->chip[k]->uid_in_analog_physio = phys_io.uid[k];\n\t\tmgr->chip[k]->uid_out_analog_physio = phys_io.uid[phys_io.nb_uid/2 + k]; \n\t}\n\n\treturn 0;\n}\n\n\nstatic int mixart_first_init(struct mixart_mgr *mgr)\n{\n\tu32 k;\n\tint err;\n\tstruct mixart_msg request;\n\n\terr = mixart_enum_connectors(mgr);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mixart_enum_physio(mgr);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\t \n\trequest.message_id = MSG_SYSTEM_SEND_SYNCHRO_CMD;\n\trequest.uid = (struct mixart_uid){0,0};\n\trequest.data = NULL;\n\trequest.size = 0;\n\t \n\terr = snd_mixart_send_msg(mgr, &request, sizeof(k), &k);\n\tif( (err < 0) || (k != 0) ) {\n\t\tdev_err(&mgr->pci->dev, \"error MSG_SYSTEM_SEND_SYNCHRO_CMD\\n\");\n\t\treturn err == 0 ? -EINVAL : err;\n\t}\n\n\treturn 0;\n}\n\n\n \n#define MIXART_MOTHERBOARD_XLX_BASE_ADDRESS   0x00600000\n\nstatic int mixart_dsp_load(struct mixart_mgr* mgr, int index, const struct firmware *dsp)\n{\n\tint           err, card_index;\n\tu32           status_xilinx, status_elf, status_daught;\n\tu32           val;\n\n\t \n\tstatus_xilinx = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\n\t \n\tstatus_elf = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\n\t \n\tstatus_daught = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\n\n\t \n\tif (status_xilinx == 5) {\n\t\tdev_err(&mgr->pci->dev, \"miXart is resetting !\\n\");\n\t\treturn -EAGAIN;  \n\t}\n\n\tswitch (index)   {\n\tcase MIXART_MOTHERBOARD_XLX_INDEX:\n\n\t\t  \n\t\tif (status_xilinx == 4) {\n\t\t\tdev_dbg(&mgr->pci->dev, \"xilinx is already loaded !\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (status_xilinx != 0) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"xilinx load error ! status = %d\\n\",\n\t\t\t\t   status_xilinx);\n\t\t\treturn -EIO;  \n\t\t}\n\n\t\t \n\t\tif (((u32*)(dsp->data))[0] == 0xffffffff)\n\t\t\treturn -EINVAL;\n\t\tif (dsp->size % 4)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\twritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\n\n\t\t \n\t\twritel_be( MIXART_MOTHERBOARD_XLX_BASE_ADDRESS, MIXART_MEM( mgr,MIXART_PSEUDOREG_MXLX_BASE_ADDR_OFFSET ));\n\t\t \n\t\twritel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_SIZE_OFFSET ));\n\n\t\t \n\t\tmemcpy_toio(  MIXART_MEM( mgr, MIXART_MOTHERBOARD_XLX_BASE_ADDRESS),  dsp->data,  dsp->size);\n    \n\t\t \n\t\twritel_be( 2, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\n\n\t\t \n\t\treturn 0;\n\n\tcase MIXART_MOTHERBOARD_ELF_INDEX:\n\n\t\tif (status_elf == 4) {\n\t\t\tdev_dbg(&mgr->pci->dev, \"elf file already loaded !\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (status_elf != 0) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"elf load error ! status = %d\\n\",\n\t\t\t\t   status_elf);\n\t\t\treturn -EIO;  \n\t\t}\n\n\t\t \n\t\terr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET, 1, 4, 500);  \n\t\tif (err < 0) {\n\t\t\tdev_err(&mgr->pci->dev, \"xilinx was not loaded or \"\n\t\t\t\t   \"could not be started\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\twritel_be( 0, MIXART_MEM( mgr, MIXART_PSEUDOREG_BOARDNUMBER ) );  \n\t\twritel_be( 0, MIXART_MEM( mgr, MIXART_FLOWTABLE_PTR ) );          \n\n\t\t \n\t\twritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\n\n\t\t \n\t\terr = mixart_load_elf( mgr, dsp );\n\t\tif (err < 0) return err;\n\n\t\t \n\t\twritel_be( 2, MIXART_MEM( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\n\n\t\t \n\t\terr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET, 1, 4, 300);  \n\t\tif (err < 0) {\n\t\t\tdev_err(&mgr->pci->dev, \"elf could not be started\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\twritel_be( (u32)mgr->flowinfo.addr, MIXART_MEM( mgr, MIXART_FLOWTABLE_PTR ) );  \n\n\t\treturn 0;   \n\n\tcase MIXART_AESEBUBOARD_XLX_INDEX:\n\tdefault:\n\n\t\t \n\t\tif (status_elf != 4 || status_xilinx != 4) {\n\t\t\tdev_err(&mgr->pci->dev, \"xilinx or elf not \"\n\t\t\t       \"successfully loaded\\n\");\n\t\t\treturn -EIO;  \n\t\t}\n\n\t\t \n\t\terr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DBRD_PRESENCE_OFFSET, 0, 0, 30);  \n\t\tif (err < 0) {\n\t\t\tdev_err(&mgr->pci->dev, \"error starting elf file\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tmgr->board_type = (DAUGHTER_TYPE_MASK & readl_be( MIXART_MEM( mgr, MIXART_PSEUDOREG_DBRD_TYPE_OFFSET)));\n\n\t\tif (mgr->board_type == MIXART_DAUGHTER_TYPE_NONE)\n\t\t\tbreak;   \n\n\t\t  \n\t\tif (mgr->board_type != MIXART_DAUGHTER_TYPE_AES )\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (status_daught != 0) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"daughter load error ! status = %d\\n\",\n\t\t\t       status_daught);\n\t\t\treturn -EIO;  \n\t\t}\n \n\t\t \n\t\tif (((u32*)(dsp->data))[0] == 0xffffffff)\n\t\t\treturn -EINVAL;\n\t\tif (dsp->size % 4)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\twritel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_SIZE_OFFSET ));\n\n\t\t \n\t\twritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\n\n\t\t \n\t\terr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET, 1, 2, 30);  \n\t\tif (err < 0) {\n\t\t\tdev_err(&mgr->pci->dev, \"daughter board load error\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tval = readl_be( MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_BASE_ADDR_OFFSET ));\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tmemcpy_toio(  MIXART_MEM( mgr, val),  dsp->data,  dsp->size);\n\n\t\t \n\t\twritel_be( 4, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\n\n\t\t \n\t\tbreak;\n\t}  \n\n         \n        err = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET, 1, 3, 300);  \n        if (err < 0) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t   \"daughter board could not be initialised\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tsnd_mixart_init_mailbox(mgr);\n\n\t \n\terr = mixart_first_init(mgr);\n        if (err < 0) {\n\t\tdev_err(&mgr->pci->dev, \"miXart could not be set up\\n\");\n\t\treturn err;\n\t}\n\n       \t \n        for (card_index = 0; card_index < mgr->num_cards; card_index++) {\n\t\tstruct snd_mixart *chip = mgr->chip[card_index];\n\n\t\terr = snd_mixart_create_pcm(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (card_index == 0) {\n\t\t\terr = snd_mixart_create_mixer(chip->mgr);\n\t\t\tif (err < 0)\n\t        \t\treturn err;\n\t\t}\n\n\t\terr = snd_card_register(chip->card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"miXart firmware downloaded and successfully set up\\n\");\n\n\treturn 0;\n}\n\n\nint snd_mixart_setup_firmware(struct mixart_mgr *mgr)\n{\n\tstatic const char * const fw_files[3] = {\n\t\t\"miXart8.xlx\", \"miXart8.elf\", \"miXart8AES.xlx\"\n\t};\n\tchar path[32];\n\n\tconst struct firmware *fw_entry;\n\tint i, err;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tsprintf(path, \"mixart/%s\", fw_files[i]);\n\t\tif (request_firmware(&fw_entry, path, &mgr->pci->dev)) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"miXart: can't load firmware %s\\n\", path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t \n\t\terr = mixart_dsp_load(mgr, i, fw_entry);\n\t\trelease_firmware(fw_entry);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmgr->dsp_loaded |= 1 << i;\n\t}\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"mixart/miXart8.xlx\");\nMODULE_FIRMWARE(\"mixart/miXart8.elf\");\nMODULE_FIRMWARE(\"mixart/miXart8AES.xlx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}