{
  "module_name": "patch_ca0132.c",
  "hash_id": "928a13cc6c85231a591094c608089c7ff1d92e3600fab13446b1bffcfdb3acde",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_ca0132.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n\n#include \"ca0132_regs.h\"\n\n \n \n\n#ifdef ENABLE_TUNING_CONTROLS\n#include <sound/tlv.h>\n#endif\n\n#define FLOAT_ZERO\t0x00000000\n#define FLOAT_ONE\t0x3f800000\n#define FLOAT_TWO\t0x40000000\n#define FLOAT_THREE     0x40400000\n#define FLOAT_FIVE\t0x40a00000\n#define FLOAT_SIX       0x40c00000\n#define FLOAT_EIGHT     0x41000000\n#define FLOAT_MINUS_5\t0xc0a00000\n\n#define UNSOL_TAG_DSP\t0x16\n\n#define DSP_DMA_WRITE_BUFLEN_INIT (1UL<<18)\n#define DSP_DMA_WRITE_BUFLEN_OVLY (1UL<<15)\n\n#define DMA_TRANSFER_FRAME_SIZE_NWORDS\t\t8\n#define DMA_TRANSFER_MAX_FRAME_SIZE_NWORDS\t32\n#define DMA_OVERLAY_FRAME_SIZE_NWORDS\t\t2\n\n#define MASTERCONTROL\t\t\t\t0x80\n#define MASTERCONTROL_ALLOC_DMA_CHAN\t\t10\n#define MASTERCONTROL_QUERY_SPEAKER_EQ_ADDRESS\t60\n\n#define WIDGET_CHIP_CTRL      0x15\n#define WIDGET_DSP_CTRL       0x16\n\n#define MEM_CONNID_MICIN1     3\n#define MEM_CONNID_MICIN2     5\n#define MEM_CONNID_MICOUT1    12\n#define MEM_CONNID_MICOUT2    14\n#define MEM_CONNID_WUH        10\n#define MEM_CONNID_DSP        16\n#define MEM_CONNID_DMIC       100\n\n#define SCP_SET    0\n#define SCP_GET    1\n\n#define EFX_FILE   \"ctefx.bin\"\n#define DESKTOP_EFX_FILE   \"ctefx-desktop.bin\"\n#define R3DI_EFX_FILE  \"ctefx-r3di.bin\"\n\n#ifdef CONFIG_SND_HDA_CODEC_CA0132_DSP\nMODULE_FIRMWARE(EFX_FILE);\nMODULE_FIRMWARE(DESKTOP_EFX_FILE);\nMODULE_FIRMWARE(R3DI_EFX_FILE);\n#endif\n\nstatic const char *const dirstr[2] = { \"Playback\", \"Capture\" };\n\n#define NUM_OF_OUTPUTS 2\nstatic const char *const out_type_str[2] = { \"Speakers\", \"Headphone\" };\nenum {\n\tSPEAKER_OUT,\n\tHEADPHONE_OUT,\n};\n\nenum {\n\tDIGITAL_MIC,\n\tLINE_MIC_IN\n};\n\n \nstatic const char *const in_src_str[3] = { \"Microphone\", \"Line In\", \"Front Microphone\" };\n#define IN_SRC_NUM_OF_INPUTS 3\nenum {\n\tREAR_MIC,\n\tREAR_LINE_IN,\n\tFRONT_MIC,\n};\n\nenum {\n#define VNODE_START_NID    0x80\n\tVNID_SPK = VNODE_START_NID,\t\t\t \n\tVNID_MIC,\n\tVNID_HP_SEL,\n\tVNID_AMIC1_SEL,\n\tVNID_HP_ASEL,\n\tVNID_AMIC1_ASEL,\n\tVNODE_END_NID,\n#define VNODES_COUNT  (VNODE_END_NID - VNODE_START_NID)\n\n#define EFFECT_START_NID    0x90\n#define OUT_EFFECT_START_NID    EFFECT_START_NID\n\tSURROUND = OUT_EFFECT_START_NID,\n\tCRYSTALIZER,\n\tDIALOG_PLUS,\n\tSMART_VOLUME,\n\tX_BASS,\n\tEQUALIZER,\n\tOUT_EFFECT_END_NID,\n#define OUT_EFFECTS_COUNT  (OUT_EFFECT_END_NID - OUT_EFFECT_START_NID)\n\n#define IN_EFFECT_START_NID  OUT_EFFECT_END_NID\n\tECHO_CANCELLATION = IN_EFFECT_START_NID,\n\tVOICE_FOCUS,\n\tMIC_SVM,\n\tNOISE_REDUCTION,\n\tIN_EFFECT_END_NID,\n#define IN_EFFECTS_COUNT  (IN_EFFECT_END_NID - IN_EFFECT_START_NID)\n\n\tVOICEFX = IN_EFFECT_END_NID,\n\tPLAY_ENHANCEMENT,\n\tCRYSTAL_VOICE,\n\tEFFECT_END_NID,\n\tOUTPUT_SOURCE_ENUM,\n\tINPUT_SOURCE_ENUM,\n\tXBASS_XOVER,\n\tEQ_PRESET_ENUM,\n\tSMART_VOLUME_ENUM,\n\tMIC_BOOST_ENUM,\n\tAE5_HEADPHONE_GAIN_ENUM,\n\tAE5_SOUND_FILTER_ENUM,\n\tZXR_HEADPHONE_GAIN,\n\tSPEAKER_CHANNEL_CFG_ENUM,\n\tSPEAKER_FULL_RANGE_FRONT,\n\tSPEAKER_FULL_RANGE_REAR,\n\tBASS_REDIRECTION,\n\tBASS_REDIRECTION_XOVER,\n#define EFFECTS_COUNT  (EFFECT_END_NID - EFFECT_START_NID)\n};\n\n \n#define EFFECT_VALS_MAX_COUNT 12\n\n \nstatic const unsigned int effect_slider_defaults[] = {67, 65, 50, 74, 50};\n \n#define EFFECT_LEVEL_SLIDERS 5\n\n \n#define DSP_CAPTURE_INIT_LATENCY        0\n#define DSP_CRYSTAL_VOICE_LATENCY       124\n#define DSP_PLAYBACK_INIT_LATENCY       13\n#define DSP_PLAY_ENHANCEMENT_LATENCY    30\n#define DSP_SPEAKER_OUT_LATENCY         7\n\nstruct ct_effect {\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\thda_nid_t nid;\n\tint mid;  \n\tint reqs[EFFECT_VALS_MAX_COUNT];  \n\tint direct;  \n\tint params;  \n\t \n\tunsigned int def_vals[EFFECT_VALS_MAX_COUNT];\n};\n\n#define EFX_DIR_OUT 0\n#define EFX_DIR_IN  1\n\nstatic const struct ct_effect ca0132_effects[EFFECTS_COUNT] = {\n\t{ .name = \"Surround\",\n\t  .nid = SURROUND,\n\t  .mid = 0x96,\n\t  .reqs = {0, 1},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 1,\n\t  .def_vals = {0x3F800000, 0x3F2B851F}\n\t},\n\t{ .name = \"Crystalizer\",\n\t  .nid = CRYSTALIZER,\n\t  .mid = 0x96,\n\t  .reqs = {7, 8},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 1,\n\t  .def_vals = {0x3F800000, 0x3F266666}\n\t},\n\t{ .name = \"Dialog Plus\",\n\t  .nid = DIALOG_PLUS,\n\t  .mid = 0x96,\n\t  .reqs = {2, 3},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 1,\n\t  .def_vals = {0x00000000, 0x3F000000}\n\t},\n\t{ .name = \"Smart Volume\",\n\t  .nid = SMART_VOLUME,\n\t  .mid = 0x96,\n\t  .reqs = {4, 5, 6},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 2,\n\t  .def_vals = {0x3F800000, 0x3F3D70A4, 0x00000000}\n\t},\n\t{ .name = \"X-Bass\",\n\t  .nid = X_BASS,\n\t  .mid = 0x96,\n\t  .reqs = {24, 23, 25},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 2,\n\t  .def_vals = {0x3F800000, 0x42A00000, 0x3F000000}\n\t},\n\t{ .name = \"Equalizer\",\n\t  .nid = EQUALIZER,\n\t  .mid = 0x96,\n\t  .reqs = {9, 10, 11, 12, 13, 14,\n\t\t\t15, 16, 17, 18, 19, 20},\n\t  .direct = EFX_DIR_OUT,\n\t  .params = 11,\n\t  .def_vals = {0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t       0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t       0x00000000, 0x00000000, 0x00000000, 0x00000000}\n\t},\n\t{ .name = \"Echo Cancellation\",\n\t  .nid = ECHO_CANCELLATION,\n\t  .mid = 0x95,\n\t  .reqs = {0, 1, 2, 3},\n\t  .direct = EFX_DIR_IN,\n\t  .params = 3,\n\t  .def_vals = {0x00000000, 0x3F3A9692, 0x00000000, 0x00000000}\n\t},\n\t{ .name = \"Voice Focus\",\n\t  .nid = VOICE_FOCUS,\n\t  .mid = 0x95,\n\t  .reqs = {6, 7, 8, 9},\n\t  .direct = EFX_DIR_IN,\n\t  .params = 3,\n\t  .def_vals = {0x3F800000, 0x3D7DF3B6, 0x41F00000, 0x41F00000}\n\t},\n\t{ .name = \"Mic SVM\",\n\t  .nid = MIC_SVM,\n\t  .mid = 0x95,\n\t  .reqs = {44, 45},\n\t  .direct = EFX_DIR_IN,\n\t  .params = 1,\n\t  .def_vals = {0x00000000, 0x3F3D70A4}\n\t},\n\t{ .name = \"Noise Reduction\",\n\t  .nid = NOISE_REDUCTION,\n\t  .mid = 0x95,\n\t  .reqs = {4, 5},\n\t  .direct = EFX_DIR_IN,\n\t  .params = 1,\n\t  .def_vals = {0x3F800000, 0x3F000000}\n\t},\n\t{ .name = \"VoiceFX\",\n\t  .nid = VOICEFX,\n\t  .mid = 0x95,\n\t  .reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18},\n\t  .direct = EFX_DIR_IN,\n\t  .params = 8,\n\t  .def_vals = {0x00000000, 0x43C80000, 0x44AF0000, 0x44FA0000,\n\t\t       0x3F800000, 0x3F800000, 0x3F800000, 0x00000000,\n\t\t       0x00000000}\n\t}\n};\n\n \n#ifdef ENABLE_TUNING_CONTROLS\n\nenum {\n#define TUNING_CTL_START_NID  0xC0\n\tWEDGE_ANGLE = TUNING_CTL_START_NID,\n\tSVM_LEVEL,\n\tEQUALIZER_BAND_0,\n\tEQUALIZER_BAND_1,\n\tEQUALIZER_BAND_2,\n\tEQUALIZER_BAND_3,\n\tEQUALIZER_BAND_4,\n\tEQUALIZER_BAND_5,\n\tEQUALIZER_BAND_6,\n\tEQUALIZER_BAND_7,\n\tEQUALIZER_BAND_8,\n\tEQUALIZER_BAND_9,\n\tTUNING_CTL_END_NID\n#define TUNING_CTLS_COUNT  (TUNING_CTL_END_NID - TUNING_CTL_START_NID)\n};\n\nstruct ct_tuning_ctl {\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\thda_nid_t parent_nid;\n\thda_nid_t nid;\n\tint mid;  \n\tint req;  \n\tint direct;  \n\tunsigned int def_val; \n};\n\nstatic const struct ct_tuning_ctl ca0132_tuning_ctls[] = {\n\t{ .name = \"Wedge Angle\",\n\t  .parent_nid = VOICE_FOCUS,\n\t  .nid = WEDGE_ANGLE,\n\t  .mid = 0x95,\n\t  .req = 8,\n\t  .direct = EFX_DIR_IN,\n\t  .def_val = 0x41F00000\n\t},\n\t{ .name = \"SVM Level\",\n\t  .parent_nid = MIC_SVM,\n\t  .nid = SVM_LEVEL,\n\t  .mid = 0x95,\n\t  .req = 45,\n\t  .direct = EFX_DIR_IN,\n\t  .def_val = 0x3F3D70A4\n\t},\n\t{ .name = \"EQ Band0\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_0,\n\t  .mid = 0x96,\n\t  .req = 11,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band1\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_1,\n\t  .mid = 0x96,\n\t  .req = 12,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band2\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_2,\n\t  .mid = 0x96,\n\t  .req = 13,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band3\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_3,\n\t  .mid = 0x96,\n\t  .req = 14,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band4\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_4,\n\t  .mid = 0x96,\n\t  .req = 15,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band5\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_5,\n\t  .mid = 0x96,\n\t  .req = 16,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band6\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_6,\n\t  .mid = 0x96,\n\t  .req = 17,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band7\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_7,\n\t  .mid = 0x96,\n\t  .req = 18,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band8\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_8,\n\t  .mid = 0x96,\n\t  .req = 19,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t},\n\t{ .name = \"EQ Band9\",\n\t  .parent_nid = EQUALIZER,\n\t  .nid = EQUALIZER_BAND_9,\n\t  .mid = 0x96,\n\t  .req = 20,\n\t  .direct = EFX_DIR_OUT,\n\t  .def_val = 0x00000000\n\t}\n};\n#endif\n\n \n#define VOICEFX_MAX_PARAM_COUNT 9\n\nstruct ct_voicefx {\n\tchar *name;\n\thda_nid_t nid;\n\tint mid;\n\tint reqs[VOICEFX_MAX_PARAM_COUNT];  \n};\n\nstruct ct_voicefx_preset {\n\tchar *name;  \n\tunsigned int vals[VOICEFX_MAX_PARAM_COUNT];\n};\n\nstatic const struct ct_voicefx ca0132_voicefx = {\n\t.name = \"VoiceFX Capture Switch\",\n\t.nid = VOICEFX,\n\t.mid = 0x95,\n\t.reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18}\n};\n\nstatic const struct ct_voicefx_preset ca0132_voicefx_presets[] = {\n\t{ .name = \"Neutral\",\n\t  .vals = { 0x00000000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x3F800000, 0x3F800000,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Female2Male\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x3F19999A, 0x3F866666,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Male2Female\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x450AC000, 0x4017AE14, 0x3F6B851F,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"ScrappyKid\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x40400000, 0x3F28F5C3,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Elderly\",\n\t  .vals = { 0x3F800000, 0x44324000, 0x44BB8000,\n\t\t    0x44E10000, 0x3FB33333, 0x3FB9999A,\n\t\t    0x3F800000, 0x3E3A2E43, 0x00000000 }\n\t},\n\t{ .name = \"Orc\",\n\t  .vals = { 0x3F800000, 0x43EA0000, 0x44A52000,\n\t\t    0x45098000, 0x3F266666, 0x3FC00000,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Elf\",\n\t  .vals = { 0x3F800000, 0x43C70000, 0x44AE6000,\n\t\t    0x45193000, 0x3F8E147B, 0x3F75C28F,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Dwarf\",\n\t  .vals = { 0x3F800000, 0x43930000, 0x44BEE000,\n\t\t    0x45007000, 0x3F451EB8, 0x3F7851EC,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"AlienBrute\",\n\t  .vals = { 0x3F800000, 0x43BFC5AC, 0x44B28FDF,\n\t\t    0x451F6000, 0x3F266666, 0x3FA7D945,\n\t\t    0x3F800000, 0x3CF5C28F, 0x00000000 }\n\t},\n\t{ .name = \"Robot\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x3FB2718B, 0x3F800000,\n\t\t    0xBC07010E, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Marine\",\n\t  .vals = { 0x3F800000, 0x43C20000, 0x44906000,\n\t\t    0x44E70000, 0x3F4CCCCD, 0x3F8A3D71,\n\t\t    0x3F0A3D71, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Emo\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x3F800000, 0x3F800000,\n\t\t    0x3E4CCCCD, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"DeepVoice\",\n\t  .vals = { 0x3F800000, 0x43A9C5AC, 0x44AA4FDF,\n\t\t    0x44FFC000, 0x3EDBB56F, 0x3F99C4CA,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t},\n\t{ .name = \"Munchkin\",\n\t  .vals = { 0x3F800000, 0x43C80000, 0x44AF0000,\n\t\t    0x44FA0000, 0x3F800000, 0x3F1A043C,\n\t\t    0x3F800000, 0x00000000, 0x00000000 }\n\t}\n};\n\n \n\n#define EQ_PRESET_MAX_PARAM_COUNT 11\n\nstruct ct_eq {\n\tchar *name;\n\thda_nid_t nid;\n\tint mid;\n\tint reqs[EQ_PRESET_MAX_PARAM_COUNT];  \n};\n\nstruct ct_eq_preset {\n\tchar *name;  \n\tunsigned int vals[EQ_PRESET_MAX_PARAM_COUNT];\n};\n\nstatic const struct ct_eq ca0132_alt_eq_enum = {\n\t.name = \"FX: Equalizer Preset Switch\",\n\t.nid = EQ_PRESET_ENUM,\n\t.mid = 0x96,\n\t.reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}\n};\n\n\nstatic const struct ct_eq_preset ca0132_alt_eq_presets[] = {\n\t{ .name = \"Flat\",\n\t .vals = { 0x00000000, 0x00000000, 0x00000000,\n\t\t   0x00000000, 0x00000000, 0x00000000,\n\t\t   0x00000000, 0x00000000, 0x00000000,\n\t\t   0x00000000, 0x00000000\t     }\n\t},\n\t{ .name = \"Acoustic\",\n\t .vals = { 0x00000000, 0x00000000, 0x3F8CCCCD,\n\t\t   0x40000000, 0x00000000, 0x00000000,\n\t\t   0x00000000, 0x00000000, 0x40000000,\n\t\t   0x40000000, 0x40000000\t     }\n\t},\n\t{ .name = \"Classical\",\n\t .vals = { 0x00000000, 0x00000000, 0x40C00000,\n\t\t   0x40C00000, 0x40466666, 0x00000000,\n\t\t   0x00000000, 0x00000000, 0x00000000,\n\t\t   0x40466666, 0x40466666\t     }\n\t},\n\t{ .name = \"Country\",\n\t .vals = { 0x00000000, 0xBF99999A, 0x00000000,\n\t\t   0x3FA66666, 0x3FA66666, 0x3F8CCCCD,\n\t\t   0x00000000, 0x00000000, 0x40000000,\n\t\t   0x40466666, 0x40800000\t     }\n\t},\n\t{ .name = \"Dance\",\n\t .vals = { 0x00000000, 0xBF99999A, 0x40000000,\n\t\t   0x40466666, 0x40866666, 0xBF99999A,\n\t\t   0xBF99999A, 0x00000000, 0x00000000,\n\t\t   0x40800000, 0x40800000\t     }\n\t},\n\t{ .name = \"Jazz\",\n\t .vals = { 0x00000000, 0x00000000, 0x00000000,\n\t\t   0x3F8CCCCD, 0x40800000, 0x40800000,\n\t\t   0x40800000, 0x00000000, 0x3F8CCCCD,\n\t\t   0x40466666, 0x40466666\t     }\n\t},\n\t{ .name = \"New Age\",\n\t .vals = { 0x00000000, 0x00000000, 0x40000000,\n\t\t   0x40000000, 0x00000000, 0x00000000,\n\t\t   0x00000000, 0x3F8CCCCD, 0x40000000,\n\t\t   0x40000000, 0x40000000\t     }\n\t},\n\t{ .name = \"Pop\",\n\t .vals = { 0x00000000, 0xBFCCCCCD, 0x00000000,\n\t\t   0x40000000, 0x40000000, 0x00000000,\n\t\t   0xBF99999A, 0xBF99999A, 0x00000000,\n\t\t   0x40466666, 0x40C00000\t     }\n\t},\n\t{ .name = \"Rock\",\n\t .vals = { 0x00000000, 0xBF99999A, 0xBF99999A,\n\t\t   0x3F8CCCCD, 0x40000000, 0xBF99999A,\n\t\t   0xBF99999A, 0x00000000, 0x00000000,\n\t\t   0x40800000, 0x40800000\t     }\n\t},\n\t{ .name = \"Vocal\",\n\t .vals = { 0x00000000, 0xC0000000, 0xBF99999A,\n\t\t   0xBF99999A, 0x00000000, 0x40466666,\n\t\t   0x40800000, 0x40466666, 0x00000000,\n\t\t   0x00000000, 0x3F8CCCCD\t     }\n\t}\n};\n\n \nenum speaker_range_reqs {\n\tSPEAKER_BASS_REDIRECT            = 0x15,\n\tSPEAKER_BASS_REDIRECT_XOVER_FREQ = 0x16,\n\t \n\tSPEAKER_FULL_RANGE_FRONT_L_R     = 0x1a,\n\tSPEAKER_FULL_RANGE_CENTER_LFE    = 0x1b,\n\tSPEAKER_FULL_RANGE_REAR_L_R      = 0x1c,\n\tSPEAKER_FULL_RANGE_SURROUND_L_R  = 0x1d,\n\tSPEAKER_BASS_REDIRECT_SUB_GAIN   = 0x1e,\n};\n\n \nenum speaker_tuning_reqs {\n\t \n\tSPEAKER_TUNING_USE_SPEAKER_EQ           = 0x1f,\n\tSPEAKER_TUNING_ENABLE_CENTER_EQ         = 0x20,\n\tSPEAKER_TUNING_FRONT_LEFT_VOL_LEVEL     = 0x21,\n\tSPEAKER_TUNING_FRONT_RIGHT_VOL_LEVEL    = 0x22,\n\tSPEAKER_TUNING_CENTER_VOL_LEVEL         = 0x23,\n\tSPEAKER_TUNING_LFE_VOL_LEVEL            = 0x24,\n\tSPEAKER_TUNING_REAR_LEFT_VOL_LEVEL      = 0x25,\n\tSPEAKER_TUNING_REAR_RIGHT_VOL_LEVEL     = 0x26,\n\tSPEAKER_TUNING_SURROUND_LEFT_VOL_LEVEL  = 0x27,\n\tSPEAKER_TUNING_SURROUND_RIGHT_VOL_LEVEL = 0x28,\n\t \n\tSPEAKER_TUNING_FRONT_LEFT_INVERT        = 0x29,\n\tSPEAKER_TUNING_FRONT_RIGHT_INVERT       = 0x2a,\n\tSPEAKER_TUNING_CENTER_INVERT            = 0x2b,\n\tSPEAKER_TUNING_LFE_INVERT               = 0x2c,\n\tSPEAKER_TUNING_REAR_LEFT_INVERT         = 0x2d,\n\tSPEAKER_TUNING_REAR_RIGHT_INVERT        = 0x2e,\n\tSPEAKER_TUNING_SURROUND_LEFT_INVERT     = 0x2f,\n\tSPEAKER_TUNING_SURROUND_RIGHT_INVERT    = 0x30,\n\t \n\tSPEAKER_TUNING_FRONT_LEFT_DELAY         = 0x31,\n\tSPEAKER_TUNING_FRONT_RIGHT_DELAY        = 0x32,\n\tSPEAKER_TUNING_CENTER_DELAY             = 0x33,\n\tSPEAKER_TUNING_LFE_DELAY                = 0x34,\n\tSPEAKER_TUNING_REAR_LEFT_DELAY          = 0x35,\n\tSPEAKER_TUNING_REAR_RIGHT_DELAY         = 0x36,\n\tSPEAKER_TUNING_SURROUND_LEFT_DELAY      = 0x37,\n\tSPEAKER_TUNING_SURROUND_RIGHT_DELAY     = 0x38,\n\t \n\tSPEAKER_TUNING_MAIN_VOLUME              = 0x39,\n\tSPEAKER_TUNING_MUTE                     = 0x3a,\n};\n\n \n#define SPEAKER_CHANNEL_CFG_COUNT 5\nenum {\n\tSPEAKER_CHANNELS_2_0,\n\tSPEAKER_CHANNELS_2_1,\n\tSPEAKER_CHANNELS_4_0,\n\tSPEAKER_CHANNELS_4_1,\n\tSPEAKER_CHANNELS_5_1,\n};\n\nstruct ca0132_alt_speaker_channel_cfg {\n\tchar *name;\n\tunsigned int val;\n};\n\nstatic const struct ca0132_alt_speaker_channel_cfg speaker_channel_cfgs[] = {\n\t{ .name = \"2.0\",\n\t  .val = FLOAT_ONE\n\t},\n\t{ .name = \"2.1\",\n\t  .val = FLOAT_TWO\n\t},\n\t{ .name = \"4.0\",\n\t  .val = FLOAT_FIVE\n\t},\n\t{ .name = \"4.1\",\n\t  .val = FLOAT_SIX\n\t},\n\t{ .name = \"5.1\",\n\t  .val = FLOAT_EIGHT\n\t}\n};\n\n \n#define DSP_VOL_OUT 0\n#define DSP_VOL_IN  1\n\nstruct ct_dsp_volume_ctl {\n\thda_nid_t vnid;\n\tint mid;  \n\tunsigned int reqs[3];  \n};\n\nstatic const struct ct_dsp_volume_ctl ca0132_alt_vol_ctls[] = {\n\t{ .vnid = VNID_SPK,\n\t  .mid = 0x32,\n\t  .reqs = {3, 4, 2}\n\t},\n\t{ .vnid = VNID_MIC,\n\t  .mid = 0x37,\n\t  .reqs = {2, 3, 1}\n\t}\n};\n\n \n#define AE_CA0113_OUT_SET_COMMANDS 6\nstruct ae_ca0113_output_set {\n\tunsigned int group[AE_CA0113_OUT_SET_COMMANDS];\n\tunsigned int target[AE_CA0113_OUT_SET_COMMANDS];\n\tunsigned int vals[NUM_OF_OUTPUTS][AE_CA0113_OUT_SET_COMMANDS];\n};\n\nstatic const struct ae_ca0113_output_set ae5_ca0113_output_presets = {\n\t.group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },\n\t.target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },\n\t\t     \n\t.vals =   { { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f },\n\t\t     \n\t\t    { 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00 } },\n};\n\nstatic const struct ae_ca0113_output_set ae7_ca0113_output_presets = {\n\t.group  = { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },\n\t.target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },\n\t\t     \n\t.vals   = { { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f },\n\t\t     \n\t\t    { 0x3f, 0x3f, 0x00, 0x00, 0x02, 0x00 } },\n};\n\n \n#define AE5_HEADPHONE_GAIN_PRESET_MAX_COMMANDS 4\nstruct ae5_headphone_gain_set {\n\tchar *name;\n\tunsigned int vals[AE5_HEADPHONE_GAIN_PRESET_MAX_COMMANDS];\n};\n\nstatic const struct ae5_headphone_gain_set ae5_headphone_gain_presets[] = {\n\t{ .name = \"Low (16-31\",\n\t  .vals = { 0xff, 0x2c, 0xf5, 0x32 }\n\t},\n\t{ .name = \"Medium (32-149\",\n\t  .vals = { 0x38, 0xa8, 0x3e, 0x4c }\n\t},\n\t{ .name = \"High (150-600\",\n\t  .vals = { 0xff, 0xff, 0xff, 0x7f }\n\t}\n};\n\nstruct ae5_filter_set {\n\tchar *name;\n\tunsigned int val;\n};\n\nstatic const struct ae5_filter_set ae5_filter_presets[] = {\n\t{ .name = \"Slow Roll Off\",\n\t  .val = 0xa0\n\t},\n\t{ .name = \"Minimum Phase\",\n\t  .val = 0xc0\n\t},\n\t{ .name = \"Fast Roll Off\",\n\t  .val = 0x80\n\t}\n};\n\n \nstruct chipio_stream_remap_data {\n\tunsigned int stream_id;\n\tunsigned int count;\n\n\tunsigned int offset[16];\n\tunsigned int value[16];\n};\n\nstatic const struct chipio_stream_remap_data stream_remap_data[] = {\n\t{ .stream_id = 0x14,\n\t  .count     = 0x04,\n\t  .offset    = { 0x00, 0x04, 0x08, 0x0c },\n\t  .value     = { 0x0001f8c0, 0x0001f9c1, 0x0001fac6, 0x0001fbc7 },\n\t},\n\t{ .stream_id = 0x0c,\n\t  .count     = 0x0c,\n\t  .offset    = { 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,\n\t\t\t 0x20, 0x24, 0x28, 0x2c },\n\t  .value     = { 0x0001e0c0, 0x0001e1c1, 0x0001e4c2, 0x0001e5c3,\n\t\t\t 0x0001e2c4, 0x0001e3c5, 0x0001e8c6, 0x0001e9c7,\n\t\t\t 0x0001ecc8, 0x0001edc9, 0x0001eaca, 0x0001ebcb },\n\t},\n\t{ .stream_id = 0x0c,\n\t  .count     = 0x08,\n\t  .offset    = { 0x08, 0x0c, 0x10, 0x14, 0x20, 0x24, 0x28, 0x2c },\n\t  .value     = { 0x000140c2, 0x000141c3, 0x000150c4, 0x000151c5,\n\t\t\t 0x000142c8, 0x000143c9, 0x000152ca, 0x000153cb },\n\t}\n};\n\nenum hda_cmd_vendor_io {\n\t \n\tVENDOR_DSPIO_SCP_WRITE_DATA_LOW      = 0x000,\n\tVENDOR_DSPIO_SCP_WRITE_DATA_HIGH     = 0x100,\n\n\tVENDOR_DSPIO_STATUS                  = 0xF01,\n\tVENDOR_DSPIO_SCP_POST_READ_DATA      = 0x702,\n\tVENDOR_DSPIO_SCP_READ_DATA           = 0xF02,\n\tVENDOR_DSPIO_DSP_INIT                = 0x703,\n\tVENDOR_DSPIO_SCP_POST_COUNT_QUERY    = 0x704,\n\tVENDOR_DSPIO_SCP_READ_COUNT          = 0xF04,\n\n\t \n\tVENDOR_CHIPIO_ADDRESS_LOW            = 0x000,\n\tVENDOR_CHIPIO_ADDRESS_HIGH           = 0x100,\n\tVENDOR_CHIPIO_STREAM_FORMAT          = 0x200,\n\tVENDOR_CHIPIO_DATA_LOW               = 0x300,\n\tVENDOR_CHIPIO_DATA_HIGH              = 0x400,\n\n\tVENDOR_CHIPIO_8051_WRITE_DIRECT      = 0x500,\n\tVENDOR_CHIPIO_8051_READ_DIRECT       = 0xD00,\n\n\tVENDOR_CHIPIO_GET_PARAMETER          = 0xF00,\n\tVENDOR_CHIPIO_STATUS                 = 0xF01,\n\tVENDOR_CHIPIO_HIC_POST_READ          = 0x702,\n\tVENDOR_CHIPIO_HIC_READ_DATA          = 0xF03,\n\n\tVENDOR_CHIPIO_8051_DATA_WRITE        = 0x707,\n\tVENDOR_CHIPIO_8051_DATA_READ         = 0xF07,\n\tVENDOR_CHIPIO_8051_PMEM_READ         = 0xF08,\n\tVENDOR_CHIPIO_8051_IRAM_WRITE        = 0x709,\n\tVENDOR_CHIPIO_8051_IRAM_READ         = 0xF09,\n\n\tVENDOR_CHIPIO_CT_EXTENSIONS_ENABLE   = 0x70A,\n\tVENDOR_CHIPIO_CT_EXTENSIONS_GET      = 0xF0A,\n\n\tVENDOR_CHIPIO_PLL_PMU_WRITE          = 0x70C,\n\tVENDOR_CHIPIO_PLL_PMU_READ           = 0xF0C,\n\tVENDOR_CHIPIO_8051_ADDRESS_LOW       = 0x70D,\n\tVENDOR_CHIPIO_8051_ADDRESS_HIGH      = 0x70E,\n\tVENDOR_CHIPIO_FLAG_SET               = 0x70F,\n\tVENDOR_CHIPIO_FLAGS_GET              = 0xF0F,\n\tVENDOR_CHIPIO_PARAM_SET              = 0x710,\n\tVENDOR_CHIPIO_PARAM_GET              = 0xF10,\n\n\tVENDOR_CHIPIO_PORT_ALLOC_CONFIG_SET  = 0x711,\n\tVENDOR_CHIPIO_PORT_ALLOC_SET         = 0x712,\n\tVENDOR_CHIPIO_PORT_ALLOC_GET         = 0xF12,\n\tVENDOR_CHIPIO_PORT_FREE_SET          = 0x713,\n\n\tVENDOR_CHIPIO_PARAM_EX_ID_GET        = 0xF17,\n\tVENDOR_CHIPIO_PARAM_EX_ID_SET        = 0x717,\n\tVENDOR_CHIPIO_PARAM_EX_VALUE_GET     = 0xF18,\n\tVENDOR_CHIPIO_PARAM_EX_VALUE_SET     = 0x718,\n\n\tVENDOR_CHIPIO_DMIC_CTL_SET           = 0x788,\n\tVENDOR_CHIPIO_DMIC_CTL_GET           = 0xF88,\n\tVENDOR_CHIPIO_DMIC_PIN_SET           = 0x789,\n\tVENDOR_CHIPIO_DMIC_PIN_GET           = 0xF89,\n\tVENDOR_CHIPIO_DMIC_MCLK_SET          = 0x78A,\n\tVENDOR_CHIPIO_DMIC_MCLK_GET          = 0xF8A,\n\n\tVENDOR_CHIPIO_EAPD_SEL_SET           = 0x78D\n};\n\n \nenum control_flag_id {\n\t \n\tCONTROL_FLAG_C_MGR                  = 0,\n\t \n\tCONTROL_FLAG_DMA                    = 1,\n\t \n\tCONTROL_FLAG_IDLE_ENABLE            = 2,\n\t \n\tCONTROL_FLAG_TRACKER                = 3,\n\t \n\tCONTROL_FLAG_SPDIF2OUT              = 4,\n\t \n\tCONTROL_FLAG_DMIC                   = 5,\n\t \n\tCONTROL_FLAG_ADC_B_96KHZ            = 6,\n\t \n\tCONTROL_FLAG_ADC_C_96KHZ            = 7,\n\t \n\tCONTROL_FLAG_DAC_96KHZ              = 8,\n\t \n\tCONTROL_FLAG_DSP_96KHZ              = 9,\n\t \n\tCONTROL_FLAG_SRC_CLOCK_196MHZ       = 10,\n\t \n\tCONTROL_FLAG_SRC_RATE_96KHZ         = 11,\n\t \n\tCONTROL_FLAG_DECODE_LOOP            = 12,\n\t \n\tCONTROL_FLAG_DAC1_DEEMPHASIS        = 13,\n\t \n\tCONTROL_FLAG_DAC2_DEEMPHASIS        = 14,\n\t \n\tCONTROL_FLAG_DAC3_DEEMPHASIS        = 15,\n\t \n\tCONTROL_FLAG_ADC_B_HIGH_PASS        = 16,\n\t \n\tCONTROL_FLAG_ADC_C_HIGH_PASS        = 17,\n\t \n\tCONTROL_FLAG_PORT_A_COMMON_MODE     = 18,\n\t \n\tCONTROL_FLAG_PORT_D_COMMON_MODE     = 19,\n\t \n\tCONTROL_FLAG_PORT_A_10KOHM_LOAD     = 20,\n\t \n\tCONTROL_FLAG_PORT_D_10KOHM_LOAD     = 21,\n\t \n\tCONTROL_FLAG_ASI_96KHZ              = 22,\n\t \n\tCONTROL_FLAG_DACS_CONTROL_PORTS     = 23,\n\t \n\tCONTROL_FLAG_CONTROL_STOP_OK_ENABLE = 24,\n\t \n\tCONTROL_FLAGS_MAX = (CONTROL_FLAG_CONTROL_STOP_OK_ENABLE+1)\n};\n\n \nenum control_param_id {\n\t \n\tCONTROL_PARAM_VIP_SOURCE               = 1,\n\t \n\tCONTROL_PARAM_SPDIF1_SOURCE            = 2,\n\t \n\tCONTROL_PARAM_PORTA_160OHM_GAIN        = 8,\n\t \n\tCONTROL_PARAM_PORTD_160OHM_GAIN        = 10,\n\n\t \n\tCONTROL_PARAM_ASI                      = 23,\n\n\t \n\n\t \n\tCONTROL_PARAM_STREAM_ID                = 24,\n\t \n\tCONTROL_PARAM_STREAM_SOURCE_CONN_POINT = 25,\n\t \n\tCONTROL_PARAM_STREAM_DEST_CONN_POINT   = 26,\n\t \n\tCONTROL_PARAM_STREAMS_CHANNELS         = 27,\n\t \n\tCONTROL_PARAM_STREAM_CONTROL           = 28,\n\n\t \n\n\t \n\tCONTROL_PARAM_CONN_POINT_ID            = 29,\n\t \n\tCONTROL_PARAM_CONN_POINT_SAMPLE_RATE   = 30,\n\n\t \n\n\t \n\tCONTROL_PARAM_NODE_ID                  = 31\n};\n\n \nenum hda_vendor_status_dspio {\n\t \n\tVENDOR_STATUS_DSPIO_OK                       = 0x00,\n\t \n\tVENDOR_STATUS_DSPIO_BUSY                     = 0x01,\n\t \n\tVENDOR_STATUS_DSPIO_SCP_COMMAND_QUEUE_FULL   = 0x02,\n\t \n\tVENDOR_STATUS_DSPIO_SCP_RESPONSE_QUEUE_EMPTY = 0x03\n};\n\n \nenum hda_vendor_status_chipio {\n\t \n\tVENDOR_STATUS_CHIPIO_OK   = 0x00,\n\t \n\tVENDOR_STATUS_CHIPIO_BUSY = 0x01\n};\n\n \nenum ca0132_sample_rate {\n\tSR_6_000        = 0x00,\n\tSR_8_000        = 0x01,\n\tSR_9_600        = 0x02,\n\tSR_11_025       = 0x03,\n\tSR_16_000       = 0x04,\n\tSR_22_050       = 0x05,\n\tSR_24_000       = 0x06,\n\tSR_32_000       = 0x07,\n\tSR_44_100       = 0x08,\n\tSR_48_000       = 0x09,\n\tSR_88_200       = 0x0A,\n\tSR_96_000       = 0x0B,\n\tSR_144_000      = 0x0C,\n\tSR_176_400      = 0x0D,\n\tSR_192_000      = 0x0E,\n\tSR_384_000      = 0x0F,\n\n\tSR_COUNT        = 0x10,\n\n\tSR_RATE_UNKNOWN = 0x1F\n};\n\nenum dsp_download_state {\n\tDSP_DOWNLOAD_FAILED = -1,\n\tDSP_DOWNLOAD_INIT   = 0,\n\tDSP_DOWNLOADING     = 1,\n\tDSP_DOWNLOADED      = 2\n};\n\n \n#define get_hdafmt_chs(fmt)\t(fmt & 0xf)\n#define get_hdafmt_bits(fmt)\t((fmt >> 4) & 0x7)\n#define get_hdafmt_rate(fmt)\t((fmt >> 8) & 0x7f)\n#define get_hdafmt_type(fmt)\t((fmt >> 15) & 0x1)\n\n \n\nstruct ca0132_spec {\n\tconst struct snd_kcontrol_new *mixers[5];\n\tunsigned int num_mixers;\n\tconst struct hda_verb *base_init_verbs;\n\tconst struct hda_verb *base_exit_verbs;\n\tconst struct hda_verb *chip_init_verbs;\n\tconst struct hda_verb *desktop_init_verbs;\n\tstruct hda_verb *spec_init_verbs;\n\tstruct auto_pin_cfg autocfg;\n\n\t \n\tstruct hda_multi_out multiout;\n\thda_nid_t out_pins[AUTO_CFG_MAX_OUTS];\n\thda_nid_t dacs[AUTO_CFG_MAX_OUTS];\n\tunsigned int num_outputs;\n\thda_nid_t input_pins[AUTO_PIN_LAST];\n\thda_nid_t adcs[AUTO_PIN_LAST];\n\thda_nid_t dig_out;\n\thda_nid_t dig_in;\n\tunsigned int num_inputs;\n\thda_nid_t shared_mic_nid;\n\thda_nid_t shared_out_nid;\n\thda_nid_t unsol_tag_hp;\n\thda_nid_t unsol_tag_front_hp;  \n\thda_nid_t unsol_tag_amic1;\n\n\t \n\tstruct mutex chipio_mutex;  \n\tu32 curr_chip_addx;\n\n\t \n\tenum dsp_download_state dsp_state;\n\tunsigned int dsp_stream_id;\n\tunsigned int wait_scp;\n\tunsigned int wait_scp_header;\n\tunsigned int wait_num_data;\n\tunsigned int scp_resp_header;\n\tunsigned int scp_resp_data[4];\n\tunsigned int scp_resp_count;\n\tbool startup_check_entered;\n\tbool dsp_reload;\n\n\t \n\tunsigned char dmic_ctl;\n\tint cur_out_type;\n\tint cur_mic_type;\n\tlong vnode_lvol[VNODES_COUNT];\n\tlong vnode_rvol[VNODES_COUNT];\n\tlong vnode_lswitch[VNODES_COUNT];\n\tlong vnode_rswitch[VNODES_COUNT];\n\tlong effects_switch[EFFECTS_COUNT];\n\tlong voicefx_val;\n\tlong cur_mic_boost;\n\t \n\tunsigned char in_enum_val;\n\tunsigned char out_enum_val;\n\tunsigned char channel_cfg_val;\n\tunsigned char speaker_range_val[2];\n\tunsigned char mic_boost_enum_val;\n\tunsigned char smart_volume_setting;\n\tunsigned char bass_redirection_val;\n\tlong bass_redirect_xover_freq;\n\tlong fx_ctl_val[EFFECT_LEVEL_SLIDERS];\n\tlong xbass_xover_freq;\n\tlong eq_preset_val;\n\tunsigned int tlv[4];\n\tstruct hda_vmaster_mute_hook vmaster_mute;\n\t \n\tunsigned char ae5_headphone_gain_val;\n\tunsigned char ae5_filter_val;\n\t \n\tunsigned char zxr_gain_set;\n\n\tstruct hda_codec *codec;\n\tstruct delayed_work unsol_hp_work;\n\tint quirk;\n\n#ifdef ENABLE_TUNING_CONTROLS\n\tlong cur_ctl_vals[TUNING_CTLS_COUNT];\n#endif\n\t \n\tbool use_pci_mmio;\n\tvoid __iomem *mem_base;\n\n\t \n\tbool use_alt_functions;\n\n\t \n\tbool use_alt_controls;\n};\n\n \nenum {\n\tQUIRK_NONE,\n\tQUIRK_ALIENWARE,\n\tQUIRK_ALIENWARE_M17XR4,\n\tQUIRK_SBZ,\n\tQUIRK_ZXR,\n\tQUIRK_ZXR_DBPRO,\n\tQUIRK_R3DI,\n\tQUIRK_R3D,\n\tQUIRK_AE5,\n\tQUIRK_AE7,\n};\n\n#ifdef CONFIG_PCI\n#define ca0132_quirk(spec)\t\t((spec)->quirk)\n#define ca0132_use_pci_mmio(spec)\t((spec)->use_pci_mmio)\n#define ca0132_use_alt_functions(spec)\t((spec)->use_alt_functions)\n#define ca0132_use_alt_controls(spec)\t((spec)->use_alt_controls)\n#else\n#define ca0132_quirk(spec)\t\t({ (void)(spec); QUIRK_NONE; })\n#define ca0132_use_alt_functions(spec)\t({ (void)(spec); false; })\n#define ca0132_use_pci_mmio(spec)\t({ (void)(spec); false; })\n#define ca0132_use_alt_controls(spec)\t({ (void)(spec); false; })\n#endif\n\nstatic const struct hda_pintbl alienware_pincfgs[] = {\n\t{ 0x0b, 0x90170110 },  \n\t{ 0x0c, 0x411111f0 },  \n\t{ 0x0d, 0x411111f0 },  \n\t{ 0x0e, 0x411111f0 },  \n\t{ 0x0f, 0x0321101f },  \n\t{ 0x10, 0x411111f0 },  \n\t{ 0x11, 0x03a11021 },  \n\t{ 0x12, 0xd5a30140 },  \n\t{ 0x13, 0x411111f0 },  \n\t{ 0x18, 0x411111f0 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl sbz_pincfgs[] = {\n\t{ 0x0b, 0x01017010 },  \n\t{ 0x0c, 0x014510f0 },  \n\t{ 0x0d, 0x014510f0 },  \n\t{ 0x0e, 0x01c510f0 },  \n\t{ 0x0f, 0x0221701f },  \n\t{ 0x10, 0x01017012 },  \n\t{ 0x11, 0x01017014 },  \n\t{ 0x12, 0x01a170f0 },  \n\t{ 0x13, 0x908700f0 },  \n\t{ 0x18, 0x50d000f0 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl zxr_pincfgs[] = {\n\t{ 0x0b, 0x01047110 },  \n\t{ 0x0c, 0x414510f0 },  \n\t{ 0x0d, 0x014510f0 },  \n\t{ 0x0e, 0x41c520f0 },  \n\t{ 0x0f, 0x0122711f },  \n\t{ 0x10, 0x01017111 },  \n\t{ 0x11, 0x01017114 },  \n\t{ 0x12, 0x01a271f0 },  \n\t{ 0x13, 0x908700f0 },  \n\t{ 0x18, 0x50d000f0 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl r3d_pincfgs[] = {\n\t{ 0x0b, 0x01014110 },  \n\t{ 0x0c, 0x014510f0 },  \n\t{ 0x0d, 0x014510f0 },  \n\t{ 0x0e, 0x01c520f0 },  \n\t{ 0x0f, 0x0221401f },  \n\t{ 0x10, 0x01016011 },  \n\t{ 0x11, 0x01011014 },  \n\t{ 0x12, 0x02a090f0 },  \n\t{ 0x13, 0x908700f0 },  \n\t{ 0x18, 0x50d000f0 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl ae5_pincfgs[] = {\n\t{ 0x0b, 0x01017010 },  \n\t{ 0x0c, 0x014510f0 },  \n\t{ 0x0d, 0x014510f0 },  \n\t{ 0x0e, 0x01c510f0 },  \n\t{ 0x0f, 0x01017114 },  \n\t{ 0x10, 0x01017012 },  \n\t{ 0x11, 0x012170ff },  \n\t{ 0x12, 0x01a170f0 },  \n\t{ 0x13, 0x908700f0 },  \n\t{ 0x18, 0x50d000f0 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl r3di_pincfgs[] = {\n\t{ 0x0b, 0x01014110 },  \n\t{ 0x0c, 0x014510f0 },  \n\t{ 0x0d, 0x014510f0 },  \n\t{ 0x0e, 0x41c520f0 },  \n\t{ 0x0f, 0x0221401f },  \n\t{ 0x10, 0x01016011 },  \n\t{ 0x11, 0x01011014 },  \n\t{ 0x12, 0x02a090f0 },  \n\t{ 0x13, 0x908700f0 },  \n\t{ 0x18, 0x500000f0 },  \n\t{}\n};\n\nstatic const struct hda_pintbl ae7_pincfgs[] = {\n\t{ 0x0b, 0x01017010 },\n\t{ 0x0c, 0x014510f0 },\n\t{ 0x0d, 0x414510f0 },\n\t{ 0x0e, 0x01c520f0 },\n\t{ 0x0f, 0x01017114 },\n\t{ 0x10, 0x01017011 },\n\t{ 0x11, 0x018170ff },\n\t{ 0x12, 0x01a170f0 },\n\t{ 0x13, 0x908700f0 },\n\t{ 0x18, 0x500000f0 },\n\t{}\n};\n\nstatic const struct snd_pci_quirk ca0132_quirks[] = {\n\tSND_PCI_QUIRK(0x1028, 0x057b, \"Alienware M17x R4\", QUIRK_ALIENWARE_M17XR4),\n\tSND_PCI_QUIRK(0x1028, 0x0685, \"Alienware 15 2015\", QUIRK_ALIENWARE),\n\tSND_PCI_QUIRK(0x1028, 0x0688, \"Alienware 17 2015\", QUIRK_ALIENWARE),\n\tSND_PCI_QUIRK(0x1028, 0x0708, \"Alienware 15 R2 2016\", QUIRK_ALIENWARE),\n\tSND_PCI_QUIRK(0x1102, 0x0010, \"Sound Blaster Z\", QUIRK_SBZ),\n\tSND_PCI_QUIRK(0x1102, 0x0023, \"Sound Blaster Z\", QUIRK_SBZ),\n\tSND_PCI_QUIRK(0x1102, 0x0027, \"Sound Blaster Z\", QUIRK_SBZ),\n\tSND_PCI_QUIRK(0x1102, 0x0033, \"Sound Blaster ZxR\", QUIRK_SBZ),\n\tSND_PCI_QUIRK(0x1458, 0xA016, \"Recon3Di\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x1458, 0xA026, \"Gigabyte G1.Sniper Z97\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x1458, 0xA036, \"Gigabyte GA-Z170X-Gaming 7\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x3842, 0x1038, \"EVGA X99 Classified\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x3842, 0x104b, \"EVGA X299 Dark\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x3842, 0x1055, \"EVGA Z390 DARK\", QUIRK_R3DI),\n\tSND_PCI_QUIRK(0x1102, 0x0013, \"Recon3D\", QUIRK_R3D),\n\tSND_PCI_QUIRK(0x1102, 0x0018, \"Recon3D\", QUIRK_R3D),\n\tSND_PCI_QUIRK(0x1102, 0x0051, \"Sound Blaster AE-5\", QUIRK_AE5),\n\tSND_PCI_QUIRK(0x1102, 0x0191, \"Sound Blaster AE-5 Plus\", QUIRK_AE5),\n\tSND_PCI_QUIRK(0x1102, 0x0081, \"Sound Blaster AE-7\", QUIRK_AE7),\n\t{}\n};\n\n \n#define MAX_QUIRK_MMIO_GPIO_SET_VALS 3\n#define MAX_QUIRK_SCP_SET_VALS 2\nstruct ca0132_alt_out_set_info {\n\tunsigned int dac2port;  \n\n\tbool has_hda_gpio;\n\tchar hda_gpio_pin;\n\tchar hda_gpio_set;\n\n\tunsigned int mmio_gpio_count;\n\tchar mmio_gpio_pin[MAX_QUIRK_MMIO_GPIO_SET_VALS];\n\tchar mmio_gpio_set[MAX_QUIRK_MMIO_GPIO_SET_VALS];\n\n\tunsigned int scp_cmds_count;\n\tunsigned int scp_cmd_mid[MAX_QUIRK_SCP_SET_VALS];\n\tunsigned int scp_cmd_req[MAX_QUIRK_SCP_SET_VALS];\n\tunsigned int scp_cmd_val[MAX_QUIRK_SCP_SET_VALS];\n\n\tbool has_chipio_write;\n\tunsigned int chipio_write_addr;\n\tunsigned int chipio_write_data;\n};\n\nstruct ca0132_alt_out_set_quirk_data {\n\tint quirk_id;\n\n\tbool has_headphone_gain;\n\tbool is_ae_series;\n\n\tstruct ca0132_alt_out_set_info out_set_info[NUM_OF_OUTPUTS];\n};\n\nstatic const struct ca0132_alt_out_set_quirk_data quirk_out_set_data[] = {\n\t{ .quirk_id = QUIRK_R3DI,\n\t  .has_headphone_gain = false,\n\t  .is_ae_series       = false,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port         = 0x24,\n\t\t  .has_hda_gpio     = true,\n\t\t  .hda_gpio_pin     = 2,\n\t\t  .hda_gpio_set     = 1,\n\t\t  .mmio_gpio_count  = 0,\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t},\n\t\t \n\t\t{ .dac2port         = 0x21,\n\t\t  .has_hda_gpio     = true,\n\t\t  .hda_gpio_pin     = 2,\n\t\t  .hda_gpio_set     = 0,\n\t\t  .mmio_gpio_count  = 0,\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t} },\n\t},\n\t{ .quirk_id = QUIRK_R3D,\n\t  .has_headphone_gain = false,\n\t  .is_ae_series       = false,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port         = 0x24,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 1,\n\t\t  .mmio_gpio_pin    = { 1 },\n\t\t  .mmio_gpio_set    = { 1 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t},\n\t\t \n\t\t{ .dac2port         = 0x21,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 1,\n\t\t  .mmio_gpio_pin    = { 1 },\n\t\t  .mmio_gpio_set    = { 0 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t} },\n\t},\n\t{ .quirk_id = QUIRK_SBZ,\n\t  .has_headphone_gain = false,\n\t  .is_ae_series       = false,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port         = 0x18,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 3,\n\t\t  .mmio_gpio_pin    = { 7, 4, 1 },\n\t\t  .mmio_gpio_set    = { 0, 1, 1 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false, },\n\t\t \n\t\t{ .dac2port         = 0x12,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 3,\n\t\t  .mmio_gpio_pin    = { 7, 4, 1 },\n\t\t  .mmio_gpio_set    = { 1, 1, 0 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t} },\n\t},\n\t{ .quirk_id = QUIRK_ZXR,\n\t  .has_headphone_gain = true,\n\t  .is_ae_series       = false,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port         = 0x24,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 3,\n\t\t  .mmio_gpio_pin    = { 2, 3, 5 },\n\t\t  .mmio_gpio_set    = { 1, 1, 0 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t},\n\t\t \n\t\t{ .dac2port         = 0x21,\n\t\t  .has_hda_gpio     = false,\n\t\t  .mmio_gpio_count  = 3,\n\t\t  .mmio_gpio_pin    = { 2, 3, 5 },\n\t\t  .mmio_gpio_set    = { 0, 1, 1 },\n\t\t  .scp_cmds_count   = 0,\n\t\t  .has_chipio_write = false,\n\t\t} },\n\t},\n\t{ .quirk_id = QUIRK_AE5,\n\t  .has_headphone_gain = true,\n\t  .is_ae_series       = true,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port          = 0xa4,\n\t\t  .has_hda_gpio      = false,\n\t\t  .mmio_gpio_count   = 0,\n\t\t  .scp_cmds_count    = 2,\n\t\t  .scp_cmd_mid       = { 0x96, 0x96 },\n\t\t  .scp_cmd_req       = { SPEAKER_TUNING_FRONT_LEFT_INVERT,\n\t\t\t\t\t SPEAKER_TUNING_FRONT_RIGHT_INVERT },\n\t\t  .scp_cmd_val       = { FLOAT_ZERO, FLOAT_ZERO },\n\t\t  .has_chipio_write  = true,\n\t\t  .chipio_write_addr = 0x0018b03c,\n\t\t  .chipio_write_data = 0x00000012\n\t\t},\n\t\t \n\t\t{ .dac2port          = 0xa1,\n\t\t  .has_hda_gpio      = false,\n\t\t  .mmio_gpio_count   = 0,\n\t\t  .scp_cmds_count    = 2,\n\t\t  .scp_cmd_mid       = { 0x96, 0x96 },\n\t\t  .scp_cmd_req       = { SPEAKER_TUNING_FRONT_LEFT_INVERT,\n\t\t\t\t\t SPEAKER_TUNING_FRONT_RIGHT_INVERT },\n\t\t  .scp_cmd_val       = { FLOAT_ONE, FLOAT_ONE },\n\t\t  .has_chipio_write  = true,\n\t\t  .chipio_write_addr = 0x0018b03c,\n\t\t  .chipio_write_data = 0x00000012\n\t\t} },\n\t},\n\t{ .quirk_id = QUIRK_AE7,\n\t  .has_headphone_gain = true,\n\t  .is_ae_series       = true,\n\t  .out_set_info = {\n\t\t \n\t\t{ .dac2port          = 0x58,\n\t\t  .has_hda_gpio      = false,\n\t\t  .mmio_gpio_count   = 1,\n\t\t  .mmio_gpio_pin     = { 0 },\n\t\t  .mmio_gpio_set     = { 1 },\n\t\t  .scp_cmds_count    = 2,\n\t\t  .scp_cmd_mid       = { 0x96, 0x96 },\n\t\t  .scp_cmd_req       = { SPEAKER_TUNING_FRONT_LEFT_INVERT,\n\t\t\t\t\t SPEAKER_TUNING_FRONT_RIGHT_INVERT },\n\t\t  .scp_cmd_val       = { FLOAT_ZERO, FLOAT_ZERO },\n\t\t  .has_chipio_write  = true,\n\t\t  .chipio_write_addr = 0x0018b03c,\n\t\t  .chipio_write_data = 0x00000000\n\t\t},\n\t\t \n\t\t{ .dac2port          = 0x58,\n\t\t  .has_hda_gpio      = false,\n\t\t  .mmio_gpio_count   = 1,\n\t\t  .mmio_gpio_pin     = { 0 },\n\t\t  .mmio_gpio_set     = { 1 },\n\t\t  .scp_cmds_count    = 2,\n\t\t  .scp_cmd_mid       = { 0x96, 0x96 },\n\t\t  .scp_cmd_req       = { SPEAKER_TUNING_FRONT_LEFT_INVERT,\n\t\t\t\t\t SPEAKER_TUNING_FRONT_RIGHT_INVERT },\n\t\t  .scp_cmd_val       = { FLOAT_ONE, FLOAT_ONE },\n\t\t  .has_chipio_write  = true,\n\t\t  .chipio_write_addr = 0x0018b03c,\n\t\t  .chipio_write_data = 0x00000010\n\t\t} },\n\t}\n};\n\n \nstatic unsigned int codec_send_command(struct hda_codec *codec, hda_nid_t nid,\n\t\tunsigned int verb, unsigned int parm, unsigned int *res)\n{\n\tunsigned int response;\n\tresponse = snd_hda_codec_read(codec, nid, 0, verb, parm);\n\t*res = response;\n\n\treturn ((response == -1) ? -1 : 0);\n}\n\nstatic int codec_set_converter_format(struct hda_codec *codec, hda_nid_t nid,\n\t\tunsigned short converter_format, unsigned int *res)\n{\n\treturn codec_send_command(codec, nid, VENDOR_CHIPIO_STREAM_FORMAT,\n\t\t\t\tconverter_format & 0xffff, res);\n}\n\nstatic int codec_set_converter_stream_channel(struct hda_codec *codec,\n\t\t\t\thda_nid_t nid, unsigned char stream,\n\t\t\t\tunsigned char channel, unsigned int *res)\n{\n\tunsigned char converter_stream_channel = 0;\n\n\tconverter_stream_channel = (stream << 4) | (channel & 0x0f);\n\treturn codec_send_command(codec, nid, AC_VERB_SET_CHANNEL_STREAMID,\n\t\t\t\tconverter_stream_channel, res);\n}\n\n \nstatic int chipio_send(struct hda_codec *codec,\n\t\t       unsigned int reg,\n\t\t       unsigned int data)\n{\n\tunsigned int res;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\t \n\tdo {\n\t\tres = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t reg, data);\n\t\tif (res == VENDOR_STATUS_CHIPIO_OK)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t} while (time_before(jiffies, timeout));\n\n\treturn -EIO;\n}\n\n \nstatic int chipio_write_address(struct hda_codec *codec,\n\t\t\t\tunsigned int chip_addx)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint res;\n\n\tif (spec->curr_chip_addx == chip_addx)\n\t\t\treturn 0;\n\n\t \n\tres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_LOW,\n\t\t\t  chip_addx & 0xffff);\n\n\tif (res != -EIO) {\n\t\t \n\t\tres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_HIGH,\n\t\t\t\t  chip_addx >> 16);\n\t}\n\n\tspec->curr_chip_addx = (res < 0) ? ~0U : chip_addx;\n\n\treturn res;\n}\n\n \nstatic int chipio_write_data(struct hda_codec *codec, unsigned int data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint res;\n\n\t \n\tres = chipio_send(codec, VENDOR_CHIPIO_DATA_LOW, data & 0xffff);\n\n\tif (res != -EIO) {\n\t\t \n\t\tres = chipio_send(codec, VENDOR_CHIPIO_DATA_HIGH,\n\t\t\t\t  data >> 16);\n\t}\n\n\t \n\tspec->curr_chip_addx = (res != -EIO) ?\n\t\t\t\t\t(spec->curr_chip_addx + 4) : ~0U;\n\treturn res;\n}\n\n \nstatic int chipio_write_data_multiple(struct hda_codec *codec,\n\t\t\t\t      const u32 *data,\n\t\t\t\t      unsigned int count)\n{\n\tint status = 0;\n\n\tif (data == NULL) {\n\t\tcodec_dbg(codec, \"chipio_write_data null ptr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((count-- != 0) && (status == 0))\n\t\tstatus = chipio_write_data(codec, *data++);\n\n\treturn status;\n}\n\n\n \nstatic int chipio_read_data(struct hda_codec *codec, unsigned int *data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint res;\n\n\t \n\tres = chipio_send(codec, VENDOR_CHIPIO_HIC_POST_READ, 0);\n\n\tif (res != -EIO) {\n\t\t \n\t\tres = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\n\t}\n\n\tif (res != -EIO) {\n\t\t \n\t\t*data = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t   VENDOR_CHIPIO_HIC_READ_DATA,\n\t\t\t\t\t   0);\n\t}\n\n\t \n\tspec->curr_chip_addx = (res != -EIO) ?\n\t\t\t\t\t(spec->curr_chip_addx + 4) : ~0U;\n\treturn res;\n}\n\n \nstatic int chipio_write(struct hda_codec *codec,\n\t\tunsigned int chip_addx, const unsigned int data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint err;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\t \n\terr = chipio_write_address(codec, chip_addx);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = chipio_write_data(codec, data);\n\tif (err < 0)\n\t\tgoto exit;\n\nexit:\n\tmutex_unlock(&spec->chipio_mutex);\n\treturn err;\n}\n\n \nstatic int chipio_write_no_mutex(struct hda_codec *codec,\n\t\tunsigned int chip_addx, const unsigned int data)\n{\n\tint err;\n\n\n\t \n\terr = chipio_write_address(codec, chip_addx);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = chipio_write_data(codec, data);\n\tif (err < 0)\n\t\tgoto exit;\n\nexit:\n\treturn err;\n}\n\n \nstatic int chipio_write_multiple(struct hda_codec *codec,\n\t\t\t\t u32 chip_addx,\n\t\t\t\t const u32 *data,\n\t\t\t\t unsigned int count)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint status;\n\n\tmutex_lock(&spec->chipio_mutex);\n\tstatus = chipio_write_address(codec, chip_addx);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = chipio_write_data_multiple(codec, data, count);\nerror:\n\tmutex_unlock(&spec->chipio_mutex);\n\n\treturn status;\n}\n\n \nstatic int chipio_read(struct hda_codec *codec,\n\t\tunsigned int chip_addx, unsigned int *data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint err;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\t \n\terr = chipio_write_address(codec, chip_addx);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = chipio_read_data(codec, data);\n\tif (err < 0)\n\t\tgoto exit;\n\nexit:\n\tmutex_unlock(&spec->chipio_mutex);\n\treturn err;\n}\n\n \nstatic void chipio_set_control_flag(struct hda_codec *codec,\n\t\t\t\t    enum control_flag_id flag_id,\n\t\t\t\t    bool flag_state)\n{\n\tunsigned int val;\n\tunsigned int flag_bit;\n\n\tflag_bit = (flag_state ? 1 : 0);\n\tval = (flag_bit << 7) | (flag_id);\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_FLAG_SET, val);\n}\n\n \nstatic void chipio_set_control_param(struct hda_codec *codec,\n\t\tenum control_param_id param_id, int param_val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint val;\n\n\tif ((param_id < 32) && (param_val < 8)) {\n\t\tval = (param_val << 5) | (param_id);\n\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t    VENDOR_CHIPIO_PARAM_SET, val);\n\t} else {\n\t\tmutex_lock(&spec->chipio_mutex);\n\t\tif (chipio_send(codec, VENDOR_CHIPIO_STATUS, 0) == 0) {\n\t\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t    VENDOR_CHIPIO_PARAM_EX_ID_SET,\n\t\t\t\t\t    param_id);\n\t\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t    VENDOR_CHIPIO_PARAM_EX_VALUE_SET,\n\t\t\t\t\t    param_val);\n\t\t}\n\t\tmutex_unlock(&spec->chipio_mutex);\n\t}\n}\n\n \nstatic void chipio_set_control_param_no_mutex(struct hda_codec *codec,\n\t\tenum control_param_id param_id, int param_val)\n{\n\tint val;\n\n\tif ((param_id < 32) && (param_val < 8)) {\n\t\tval = (param_val << 5) | (param_id);\n\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t    VENDOR_CHIPIO_PARAM_SET, val);\n\t} else {\n\t\tif (chipio_send(codec, VENDOR_CHIPIO_STATUS, 0) == 0) {\n\t\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t    VENDOR_CHIPIO_PARAM_EX_ID_SET,\n\t\t\t\t\t    param_id);\n\t\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t\t    VENDOR_CHIPIO_PARAM_EX_VALUE_SET,\n\t\t\t\t\t    param_val);\n\t\t}\n\t}\n}\n \nstatic void chipio_set_stream_source_dest(struct hda_codec *codec,\n\t\t\t\tint streamid, int source_point, int dest_point)\n{\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_ID, streamid);\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_SOURCE_CONN_POINT, source_point);\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_DEST_CONN_POINT, dest_point);\n}\n\n \nstatic void chipio_set_stream_channels(struct hda_codec *codec,\n\t\t\t\tint streamid, unsigned int channels)\n{\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_ID, streamid);\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAMS_CHANNELS, channels);\n}\n\n \nstatic void chipio_set_stream_control(struct hda_codec *codec,\n\t\t\t\tint streamid, int enable)\n{\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_ID, streamid);\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_CONTROL, enable);\n}\n\n \nstatic void chipio_get_stream_control(struct hda_codec *codec,\n\t\t\t\tint streamid, unsigned int *enable)\n{\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_STREAM_ID, streamid);\n\t*enable = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t   VENDOR_CHIPIO_PARAM_GET,\n\t\t\t   CONTROL_PARAM_STREAM_CONTROL);\n}\n\n \nstatic void chipio_set_conn_rate_no_mutex(struct hda_codec *codec,\n\t\t\t\tint connid, enum ca0132_sample_rate rate)\n{\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_CONN_POINT_ID, connid);\n\tchipio_set_control_param_no_mutex(codec,\n\t\t\tCONTROL_PARAM_CONN_POINT_SAMPLE_RATE, rate);\n}\n\n \nstatic void chipio_set_conn_rate(struct hda_codec *codec,\n\t\t\t\tint connid, enum ca0132_sample_rate rate)\n{\n\tchipio_set_control_param(codec, CONTROL_PARAM_CONN_POINT_ID, connid);\n\tchipio_set_control_param(codec, CONTROL_PARAM_CONN_POINT_SAMPLE_RATE,\n\t\t\t\t rate);\n}\n\n \nstatic void chipio_8051_write_direct(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int data)\n{\n\tunsigned int verb;\n\n\tverb = VENDOR_CHIPIO_8051_WRITE_DIRECT | data;\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, verb, addr);\n}\n\n \nstatic void chipio_8051_set_address(struct hda_codec *codec, unsigned int addr)\n{\n\tunsigned int tmp;\n\n\t \n\ttmp = addr & 0xff;\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_8051_ADDRESS_LOW, tmp);\n\n\t \n\ttmp = (addr >> 8) & 0xff;\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_8051_ADDRESS_HIGH, tmp);\n}\n\nstatic void chipio_8051_set_data(struct hda_codec *codec, unsigned int data)\n{\n\t \n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_8051_DATA_WRITE, data & 0xff);\n}\n\nstatic unsigned int chipio_8051_get_data(struct hda_codec *codec)\n{\n\treturn snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\t   VENDOR_CHIPIO_8051_DATA_READ, 0);\n}\n\n \nstatic void chipio_8051_set_data_pll(struct hda_codec *codec, unsigned int data)\n{\n\t \n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PLL_PMU_WRITE, data & 0xff);\n}\n\nstatic void chipio_8051_write_exram(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_8051_set_address(codec, addr);\n\tchipio_8051_set_data(codec, data);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void chipio_8051_write_exram_no_mutex(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int data)\n{\n\tchipio_8051_set_address(codec, addr);\n\tchipio_8051_set_data(codec, data);\n}\n\n \nstatic void chipio_8051_read_exram(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int *data)\n{\n\tchipio_8051_set_address(codec, addr);\n\t*data = chipio_8051_get_data(codec);\n}\n\nstatic void chipio_8051_write_pll_pmu(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_8051_set_address(codec, addr & 0xff);\n\tchipio_8051_set_data_pll(codec, data);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void chipio_8051_write_pll_pmu_no_mutex(struct hda_codec *codec,\n\t\tunsigned int addr, unsigned int data)\n{\n\tchipio_8051_set_address(codec, addr & 0xff);\n\tchipio_8051_set_data_pll(codec, data);\n}\n\n \nstatic void chipio_enable_clocks(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_8051_write_pll_pmu_no_mutex(codec, 0x00, 0xff);\n\tchipio_8051_write_pll_pmu_no_mutex(codec, 0x05, 0x0b);\n\tchipio_8051_write_pll_pmu_no_mutex(codec, 0x06, 0xff);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\n \nstatic int dspio_send(struct hda_codec *codec, unsigned int reg,\n\t\t      unsigned int data)\n{\n\tint res;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\t \n\tdo {\n\t\tres = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0, reg, data);\n\t\tif ((res >= 0) && (res != VENDOR_STATUS_DSPIO_BUSY))\n\t\t\treturn res;\n\t\tmsleep(20);\n\t} while (time_before(jiffies, timeout));\n\n\treturn -EIO;\n}\n\n \nstatic void dspio_write_wait(struct hda_codec *codec)\n{\n\tint status;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\tdo {\n\t\tstatus = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\n\t\t\t\t\t\tVENDOR_DSPIO_STATUS, 0);\n\t\tif ((status == VENDOR_STATUS_DSPIO_OK) ||\n\t\t    (status == VENDOR_STATUS_DSPIO_SCP_RESPONSE_QUEUE_EMPTY))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t} while (time_before(jiffies, timeout));\n}\n\n \nstatic int dspio_write(struct hda_codec *codec, unsigned int scp_data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint status;\n\n\tdspio_write_wait(codec);\n\n\tmutex_lock(&spec->chipio_mutex);\n\tstatus = dspio_send(codec, VENDOR_DSPIO_SCP_WRITE_DATA_LOW,\n\t\t\t    scp_data & 0xffff);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = dspio_send(codec, VENDOR_DSPIO_SCP_WRITE_DATA_HIGH,\n\t\t\t\t    scp_data >> 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\n\t\t\t\t    VENDOR_DSPIO_STATUS, 0);\nerror:\n\tmutex_unlock(&spec->chipio_mutex);\n\n\treturn (status == VENDOR_STATUS_DSPIO_SCP_COMMAND_QUEUE_FULL) ?\n\t\t\t-EIO : 0;\n}\n\n \nstatic int dspio_write_multiple(struct hda_codec *codec,\n\t\t\t\tunsigned int *buffer, unsigned int size)\n{\n\tint status = 0;\n\tunsigned int count;\n\n\tif (buffer == NULL)\n\t\treturn -EINVAL;\n\n\tcount = 0;\n\twhile (count < size) {\n\t\tstatus = dspio_write(codec, *buffer++);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\n\treturn status;\n}\n\nstatic int dspio_read(struct hda_codec *codec, unsigned int *data)\n{\n\tint status;\n\n\tstatus = dspio_send(codec, VENDOR_DSPIO_SCP_POST_READ_DATA, 0);\n\tif (status == -EIO)\n\t\treturn status;\n\n\tstatus = dspio_send(codec, VENDOR_DSPIO_STATUS, 0);\n\tif (status == -EIO ||\n\t    status == VENDOR_STATUS_DSPIO_SCP_RESPONSE_QUEUE_EMPTY)\n\t\treturn -EIO;\n\n\t*data = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\n\t\t\t\t   VENDOR_DSPIO_SCP_READ_DATA, 0);\n\n\treturn 0;\n}\n\nstatic int dspio_read_multiple(struct hda_codec *codec, unsigned int *buffer,\n\t\t\t       unsigned int *buf_size, unsigned int size_count)\n{\n\tint status = 0;\n\tunsigned int size = *buf_size;\n\tunsigned int count;\n\tunsigned int skip_count;\n\tunsigned int dummy;\n\n\tif (buffer == NULL)\n\t\treturn -1;\n\n\tcount = 0;\n\twhile (count < size && count < size_count) {\n\t\tstatus = dspio_read(codec, buffer++);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\n\tskip_count = count;\n\tif (status == 0) {\n\t\twhile (skip_count < size) {\n\t\t\tstatus = dspio_read(codec, &dummy);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\t\t\tskip_count++;\n\t\t}\n\t}\n\t*buf_size = count;\n\n\treturn status;\n}\n\n \nstatic inline unsigned int\nmake_scp_header(unsigned int target_id, unsigned int source_id,\n\t\tunsigned int get_flag, unsigned int req,\n\t\tunsigned int device_flag, unsigned int resp_flag,\n\t\tunsigned int error_flag, unsigned int data_size)\n{\n\tunsigned int header = 0;\n\n\theader = (data_size & 0x1f) << 27;\n\theader |= (error_flag & 0x01) << 26;\n\theader |= (resp_flag & 0x01) << 25;\n\theader |= (device_flag & 0x01) << 24;\n\theader |= (req & 0x7f) << 17;\n\theader |= (get_flag & 0x01) << 16;\n\theader |= (source_id & 0xff) << 8;\n\theader |= target_id & 0xff;\n\n\treturn header;\n}\n\n \nstatic inline void\nextract_scp_header(unsigned int header,\n\t\t   unsigned int *target_id, unsigned int *source_id,\n\t\t   unsigned int *get_flag, unsigned int *req,\n\t\t   unsigned int *device_flag, unsigned int *resp_flag,\n\t\t   unsigned int *error_flag, unsigned int *data_size)\n{\n\tif (data_size)\n\t\t*data_size = (header >> 27) & 0x1f;\n\tif (error_flag)\n\t\t*error_flag = (header >> 26) & 0x01;\n\tif (resp_flag)\n\t\t*resp_flag = (header >> 25) & 0x01;\n\tif (device_flag)\n\t\t*device_flag = (header >> 24) & 0x01;\n\tif (req)\n\t\t*req = (header >> 17) & 0x7f;\n\tif (get_flag)\n\t\t*get_flag = (header >> 16) & 0x01;\n\tif (source_id)\n\t\t*source_id = (header >> 8) & 0xff;\n\tif (target_id)\n\t\t*target_id = header & 0xff;\n}\n\n#define SCP_MAX_DATA_WORDS  (16)\n\n \nstruct scp_msg {\n\tunsigned int hdr;\n\tunsigned int data[SCP_MAX_DATA_WORDS];\n};\n\nstatic void dspio_clear_response_queue(struct hda_codec *codec)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\tunsigned int dummy = 0;\n\tint status;\n\n\t \n\tdo {\n\t\tstatus = dspio_read(codec, &dummy);\n\t} while (status == 0 && time_before(jiffies, timeout));\n}\n\nstatic int dspio_get_response_data(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int data = 0;\n\tunsigned int count;\n\n\tif (dspio_read(codec, &data) < 0)\n\t\treturn -EIO;\n\n\tif ((data & 0x00ffffff) == spec->wait_scp_header) {\n\t\tspec->scp_resp_header = data;\n\t\tspec->scp_resp_count = data >> 27;\n\t\tcount = spec->wait_num_data;\n\t\tdspio_read_multiple(codec, spec->scp_resp_data,\n\t\t\t\t    &spec->scp_resp_count, count);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int dspio_send_scp_message(struct hda_codec *codec,\n\t\t\t\t  unsigned char *send_buf,\n\t\t\t\t  unsigned int send_buf_size,\n\t\t\t\t  unsigned char *return_buf,\n\t\t\t\t  unsigned int return_buf_size,\n\t\t\t\t  unsigned int *bytes_returned)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint status;\n\tunsigned int scp_send_size = 0;\n\tunsigned int total_size;\n\tbool waiting_for_resp = false;\n\tunsigned int header;\n\tstruct scp_msg *ret_msg;\n\tunsigned int resp_src_id, resp_target_id;\n\tunsigned int data_size, src_id, target_id, get_flag, device_flag;\n\n\tif (bytes_returned)\n\t\t*bytes_returned = 0;\n\n\t \n\theader = *((unsigned int *)send_buf);\n\textract_scp_header(header, &target_id, &src_id, &get_flag, NULL,\n\t\t\t   &device_flag, NULL, NULL, &data_size);\n\tscp_send_size = data_size + 1;\n\ttotal_size = (scp_send_size * 4);\n\n\tif (send_buf_size < total_size)\n\t\treturn -EINVAL;\n\n\tif (get_flag || device_flag) {\n\t\tif (!return_buf || return_buf_size < 4 || !bytes_returned)\n\t\t\treturn -EINVAL;\n\n\t\tspec->wait_scp_header = *((unsigned int *)send_buf);\n\n\t\t \n\t\tresp_target_id = src_id;\n\t\tresp_src_id = target_id;\n\t\tspec->wait_scp_header &= 0xffff0000;\n\t\tspec->wait_scp_header |= (resp_src_id << 8) | (resp_target_id);\n\t\tspec->wait_num_data = return_buf_size/sizeof(unsigned int) - 1;\n\t\tspec->wait_scp = 1;\n\t\twaiting_for_resp = true;\n\t}\n\n\tstatus = dspio_write_multiple(codec, (unsigned int *)send_buf,\n\t\t\t\t      scp_send_size);\n\tif (status < 0) {\n\t\tspec->wait_scp = 0;\n\t\treturn status;\n\t}\n\n\tif (waiting_for_resp) {\n\t\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\t\tmemset(return_buf, 0, return_buf_size);\n\t\tdo {\n\t\t\tmsleep(20);\n\t\t} while (spec->wait_scp && time_before(jiffies, timeout));\n\t\twaiting_for_resp = false;\n\t\tif (!spec->wait_scp) {\n\t\t\tret_msg = (struct scp_msg *)return_buf;\n\t\t\tmemcpy(&ret_msg->hdr, &spec->scp_resp_header, 4);\n\t\t\tmemcpy(&ret_msg->data, spec->scp_resp_data,\n\t\t\t       spec->wait_num_data);\n\t\t\t*bytes_returned = (spec->scp_resp_count + 1) * 4;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tstatus = -EIO;\n\t\t}\n\t\tspec->wait_scp = 0;\n\t}\n\n\treturn status;\n}\n\n \nstatic int dspio_scp(struct hda_codec *codec,\n\t\tint mod_id, int src_id, int req, int dir, const void *data,\n\t\tunsigned int len, void *reply, unsigned int *reply_len)\n{\n\tint status = 0;\n\tstruct scp_msg scp_send, scp_reply;\n\tunsigned int ret_bytes, send_size, ret_size;\n\tunsigned int send_get_flag, reply_resp_flag, reply_error_flag;\n\tunsigned int reply_data_size;\n\n\tmemset(&scp_send, 0, sizeof(scp_send));\n\tmemset(&scp_reply, 0, sizeof(scp_reply));\n\n\tif ((len != 0 && data == NULL) || (len > SCP_MAX_DATA_WORDS))\n\t\treturn -EINVAL;\n\n\tif (dir == SCP_GET && reply == NULL) {\n\t\tcodec_dbg(codec, \"dspio_scp get but has no buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reply != NULL && (reply_len == NULL || (*reply_len == 0))) {\n\t\tcodec_dbg(codec, \"dspio_scp bad resp buf len parms\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tscp_send.hdr = make_scp_header(mod_id, src_id, (dir == SCP_GET), req,\n\t\t\t\t       0, 0, 0, len/sizeof(unsigned int));\n\tif (data != NULL && len > 0) {\n\t\tlen = min((unsigned int)(sizeof(scp_send.data)), len);\n\t\tmemcpy(scp_send.data, data, len);\n\t}\n\n\tret_bytes = 0;\n\tsend_size = sizeof(unsigned int) + len;\n\tstatus = dspio_send_scp_message(codec, (unsigned char *)&scp_send,\n\t\t\t\t\tsend_size, (unsigned char *)&scp_reply,\n\t\t\t\t\tsizeof(scp_reply), &ret_bytes);\n\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"dspio_scp: send scp msg failed\\n\");\n\t\treturn status;\n\t}\n\n\t \n\textract_scp_header(scp_send.hdr, NULL, NULL, &send_get_flag,\n\t\t\t   NULL, NULL, NULL, NULL, NULL);\n\textract_scp_header(scp_reply.hdr, NULL, NULL, NULL, NULL, NULL,\n\t\t\t   &reply_resp_flag, &reply_error_flag,\n\t\t\t   &reply_data_size);\n\n\tif (!send_get_flag)\n\t\treturn 0;\n\n\tif (reply_resp_flag && !reply_error_flag) {\n\t\tret_size = (ret_bytes - sizeof(scp_reply.hdr))\n\t\t\t\t\t/ sizeof(unsigned int);\n\n\t\tif (*reply_len < ret_size*sizeof(unsigned int)) {\n\t\t\tcodec_dbg(codec, \"reply too long for buf\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (ret_size != reply_data_size) {\n\t\t\tcodec_dbg(codec, \"RetLen and HdrLen .NE.\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (!reply) {\n\t\t\tcodec_dbg(codec, \"NULL reply\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t*reply_len = ret_size*sizeof(unsigned int);\n\t\t\tmemcpy(reply, scp_reply.data, *reply_len);\n\t\t}\n\t} else {\n\t\tcodec_dbg(codec, \"reply ill-formed or errflag set\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn status;\n}\n\n \nstatic int dspio_set_param(struct hda_codec *codec, int mod_id,\n\t\t\tint src_id, int req, const void *data, unsigned int len)\n{\n\treturn dspio_scp(codec, mod_id, src_id, req, SCP_SET, data, len, NULL,\n\t\t\tNULL);\n}\n\nstatic int dspio_set_uint_param(struct hda_codec *codec, int mod_id,\n\t\t\tint req, const unsigned int data)\n{\n\treturn dspio_set_param(codec, mod_id, 0x20, req, &data,\n\t\t\tsizeof(unsigned int));\n}\n\n \nstatic int dspio_alloc_dma_chan(struct hda_codec *codec, unsigned int *dma_chan)\n{\n\tint status = 0;\n\tunsigned int size = sizeof(*dma_chan);\n\n\tcodec_dbg(codec, \"     dspio_alloc_dma_chan() -- begin\\n\");\n\tstatus = dspio_scp(codec, MASTERCONTROL, 0x20,\n\t\t\tMASTERCONTROL_ALLOC_DMA_CHAN, SCP_GET, NULL, 0,\n\t\t\tdma_chan, &size);\n\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"dspio_alloc_dma_chan: SCP Failed\\n\");\n\t\treturn status;\n\t}\n\n\tif ((*dma_chan + 1) == 0) {\n\t\tcodec_dbg(codec, \"no free dma channels to allocate\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcodec_dbg(codec, \"dspio_alloc_dma_chan: chan=%d\\n\", *dma_chan);\n\tcodec_dbg(codec, \"     dspio_alloc_dma_chan() -- complete\\n\");\n\n\treturn status;\n}\n\n \nstatic int dspio_free_dma_chan(struct hda_codec *codec, unsigned int dma_chan)\n{\n\tint status = 0;\n\tunsigned int dummy = 0;\n\n\tcodec_dbg(codec, \"     dspio_free_dma_chan() -- begin\\n\");\n\tcodec_dbg(codec, \"dspio_free_dma_chan: chan=%d\\n\", dma_chan);\n\n\tstatus = dspio_scp(codec, MASTERCONTROL, 0x20,\n\t\t\tMASTERCONTROL_ALLOC_DMA_CHAN, SCP_SET, &dma_chan,\n\t\t\tsizeof(dma_chan), NULL, &dummy);\n\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"dspio_free_dma_chan: SCP Failed\\n\");\n\t\treturn status;\n\t}\n\n\tcodec_dbg(codec, \"     dspio_free_dma_chan() -- complete\\n\");\n\n\treturn status;\n}\n\n \nstatic int dsp_set_run_state(struct hda_codec *codec)\n{\n\tunsigned int dbg_ctrl_reg;\n\tunsigned int halt_state;\n\tint err;\n\n\terr = chipio_read(codec, DSP_DBGCNTL_INST_OFFSET, &dbg_ctrl_reg);\n\tif (err < 0)\n\t\treturn err;\n\n\thalt_state = (dbg_ctrl_reg & DSP_DBGCNTL_STATE_MASK) >>\n\t\t      DSP_DBGCNTL_STATE_LOBIT;\n\n\tif (halt_state != 0) {\n\t\tdbg_ctrl_reg &= ~((halt_state << DSP_DBGCNTL_SS_LOBIT) &\n\t\t\t\t  DSP_DBGCNTL_SS_MASK);\n\t\terr = chipio_write(codec, DSP_DBGCNTL_INST_OFFSET,\n\t\t\t\t   dbg_ctrl_reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdbg_ctrl_reg |= (halt_state << DSP_DBGCNTL_EXEC_LOBIT) &\n\t\t\t\tDSP_DBGCNTL_EXEC_MASK;\n\t\terr = chipio_write(codec, DSP_DBGCNTL_INST_OFFSET,\n\t\t\t\t   dbg_ctrl_reg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dsp_reset(struct hda_codec *codec)\n{\n\tunsigned int res;\n\tint retry = 20;\n\n\tcodec_dbg(codec, \"dsp_reset\\n\");\n\tdo {\n\t\tres = dspio_send(codec, VENDOR_DSPIO_DSP_INIT, 0);\n\t\tretry--;\n\t} while (res == -EIO && retry);\n\n\tif (!retry) {\n\t\tcodec_dbg(codec, \"dsp_reset timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int dsp_chip_to_dsp_addx(unsigned int chip_addx,\n\t\t\t\t\tbool *code, bool *yram)\n{\n\t*code = *yram = false;\n\n\tif (UC_RANGE(chip_addx, 1)) {\n\t\t*code = true;\n\t\treturn UC_OFF(chip_addx);\n\t} else if (X_RANGE_ALL(chip_addx, 1)) {\n\t\treturn X_OFF(chip_addx);\n\t} else if (Y_RANGE_ALL(chip_addx, 1)) {\n\t\t*yram = true;\n\t\treturn Y_OFF(chip_addx);\n\t}\n\n\treturn INVALID_CHIP_ADDRESS;\n}\n\n \nstatic bool dsp_is_dma_active(struct hda_codec *codec, unsigned int dma_chan)\n{\n\tunsigned int dma_chnlstart_reg;\n\n\tchipio_read(codec, DSPDMAC_CHNLSTART_INST_OFFSET, &dma_chnlstart_reg);\n\n\treturn ((dma_chnlstart_reg & (1 <<\n\t\t\t(DSPDMAC_CHNLSTART_EN_LOBIT + dma_chan))) != 0);\n}\n\nstatic int dsp_dma_setup_common(struct hda_codec *codec,\n\t\t\t\tunsigned int chip_addx,\n\t\t\t\tunsigned int dma_chan,\n\t\t\t\tunsigned int port_map_mask,\n\t\t\t\tbool ovly)\n{\n\tint status = 0;\n\tunsigned int chnl_prop;\n\tunsigned int dsp_addx;\n\tunsigned int active;\n\tbool code, yram;\n\n\tcodec_dbg(codec, \"-- dsp_dma_setup_common() -- Begin ---------\\n\");\n\n\tif (dma_chan >= DSPDMAC_DMA_CFG_CHANNEL_COUNT) {\n\t\tcodec_dbg(codec, \"dma chan num invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsp_is_dma_active(codec, dma_chan)) {\n\t\tcodec_dbg(codec, \"dma already active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);\n\n\tif (dsp_addx == INVALID_CHIP_ADDRESS) {\n\t\tcodec_dbg(codec, \"invalid chip addr\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchnl_prop = DSPDMAC_CHNLPROP_AC_MASK;\n\tactive = 0;\n\n\tcodec_dbg(codec, \"   dsp_dma_setup_common()    start reg pgm\\n\");\n\n\tif (ovly) {\n\t\tstatus = chipio_read(codec, DSPDMAC_CHNLPROP_INST_OFFSET,\n\t\t\t\t     &chnl_prop);\n\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"read CHNLPROP Reg fail\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tcodec_dbg(codec, \"dsp_dma_setup_common() Read CHNLPROP\\n\");\n\t}\n\n\tif (!code)\n\t\tchnl_prop &= ~(1 << (DSPDMAC_CHNLPROP_MSPCE_LOBIT + dma_chan));\n\telse\n\t\tchnl_prop |=  (1 << (DSPDMAC_CHNLPROP_MSPCE_LOBIT + dma_chan));\n\n\tchnl_prop &= ~(1 << (DSPDMAC_CHNLPROP_DCON_LOBIT + dma_chan));\n\n\tstatus = chipio_write(codec, DSPDMAC_CHNLPROP_INST_OFFSET, chnl_prop);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write CHNLPROP Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup_common()    Write CHNLPROP\\n\");\n\n\tif (ovly) {\n\t\tstatus = chipio_read(codec, DSPDMAC_ACTIVE_INST_OFFSET,\n\t\t\t\t     &active);\n\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"read ACTIVE Reg fail\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tcodec_dbg(codec, \"dsp_dma_setup_common() Read ACTIVE\\n\");\n\t}\n\n\tactive &= (~(1 << (DSPDMAC_ACTIVE_AAR_LOBIT + dma_chan))) &\n\t\tDSPDMAC_ACTIVE_AAR_MASK;\n\n\tstatus = chipio_write(codec, DSPDMAC_ACTIVE_INST_OFFSET, active);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write ACTIVE Reg fail\\n\");\n\t\treturn status;\n\t}\n\n\tcodec_dbg(codec, \"   dsp_dma_setup_common()    Write ACTIVE\\n\");\n\n\tstatus = chipio_write(codec, DSPDMAC_AUDCHSEL_INST_OFFSET(dma_chan),\n\t\t\t      port_map_mask);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write AUDCHSEL Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup_common()    Write AUDCHSEL\\n\");\n\n\tstatus = chipio_write(codec, DSPDMAC_IRQCNT_INST_OFFSET(dma_chan),\n\t\t\tDSPDMAC_IRQCNT_BICNT_MASK | DSPDMAC_IRQCNT_CICNT_MASK);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write IRQCNT Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup_common()    Write IRQCNT\\n\");\n\n\tcodec_dbg(codec,\n\t\t   \"ChipA=0x%x,DspA=0x%x,dmaCh=%u, \"\n\t\t   \"CHSEL=0x%x,CHPROP=0x%x,Active=0x%x\\n\",\n\t\t   chip_addx, dsp_addx, dma_chan,\n\t\t   port_map_mask, chnl_prop, active);\n\n\tcodec_dbg(codec, \"-- dsp_dma_setup_common() -- Complete ------\\n\");\n\n\treturn 0;\n}\n\n \nstatic int dsp_dma_setup(struct hda_codec *codec,\n\t\t\tunsigned int chip_addx,\n\t\t\tunsigned int count,\n\t\t\tunsigned int dma_chan)\n{\n\tint status = 0;\n\tbool code, yram;\n\tunsigned int dsp_addx;\n\tunsigned int addr_field;\n\tunsigned int incr_field;\n\tunsigned int base_cnt;\n\tunsigned int cur_cnt;\n\tunsigned int dma_cfg = 0;\n\tunsigned int adr_ofs = 0;\n\tunsigned int xfr_cnt = 0;\n\tconst unsigned int max_dma_count = 1 << (DSPDMAC_XFRCNT_BCNT_HIBIT -\n\t\t\t\t\t\tDSPDMAC_XFRCNT_BCNT_LOBIT + 1);\n\n\tcodec_dbg(codec, \"-- dsp_dma_setup() -- Begin ---------\\n\");\n\n\tif (count > max_dma_count) {\n\t\tcodec_dbg(codec, \"count too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);\n\tif (dsp_addx == INVALID_CHIP_ADDRESS) {\n\t\tcodec_dbg(codec, \"invalid chip addr\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tcodec_dbg(codec, \"   dsp_dma_setup()    start reg pgm\\n\");\n\n\taddr_field = dsp_addx << DSPDMAC_DMACFG_DBADR_LOBIT;\n\tincr_field   = 0;\n\n\tif (!code) {\n\t\taddr_field <<= 1;\n\t\tif (yram)\n\t\t\taddr_field |= (1 << DSPDMAC_DMACFG_DBADR_LOBIT);\n\n\t\tincr_field  = (1 << DSPDMAC_DMACFG_AINCR_LOBIT);\n\t}\n\n\tdma_cfg = addr_field + incr_field;\n\tstatus = chipio_write(codec, DSPDMAC_DMACFG_INST_OFFSET(dma_chan),\n\t\t\t\tdma_cfg);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write DMACFG Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup()    Write DMACFG\\n\");\n\n\tadr_ofs = (count - 1) << (DSPDMAC_DSPADROFS_BOFS_LOBIT +\n\t\t\t\t\t\t\t(code ? 0 : 1));\n\n\tstatus = chipio_write(codec, DSPDMAC_DSPADROFS_INST_OFFSET(dma_chan),\n\t\t\t\tadr_ofs);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write DSPADROFS Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup()    Write DSPADROFS\\n\");\n\n\tbase_cnt = (count - 1) << DSPDMAC_XFRCNT_BCNT_LOBIT;\n\n\tcur_cnt  = (count - 1) << DSPDMAC_XFRCNT_CCNT_LOBIT;\n\n\txfr_cnt = base_cnt | cur_cnt;\n\n\tstatus = chipio_write(codec,\n\t\t\t\tDSPDMAC_XFRCNT_INST_OFFSET(dma_chan), xfr_cnt);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write XFRCNT Reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"   dsp_dma_setup()    Write XFRCNT\\n\");\n\n\tcodec_dbg(codec,\n\t\t   \"ChipA=0x%x, cnt=0x%x, DMACFG=0x%x, \"\n\t\t   \"ADROFS=0x%x, XFRCNT=0x%x\\n\",\n\t\t   chip_addx, count, dma_cfg, adr_ofs, xfr_cnt);\n\n\tcodec_dbg(codec, \"-- dsp_dma_setup() -- Complete ---------\\n\");\n\n\treturn 0;\n}\n\n \nstatic int dsp_dma_start(struct hda_codec *codec,\n\t\t\t unsigned int dma_chan, bool ovly)\n{\n\tunsigned int reg = 0;\n\tint status = 0;\n\n\tcodec_dbg(codec, \"-- dsp_dma_start() -- Begin ---------\\n\");\n\n\tif (ovly) {\n\t\tstatus = chipio_read(codec,\n\t\t\t\t     DSPDMAC_CHNLSTART_INST_OFFSET, &reg);\n\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"read CHNLSTART reg fail\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tcodec_dbg(codec, \"-- dsp_dma_start()    Read CHNLSTART\\n\");\n\n\t\treg &= ~(DSPDMAC_CHNLSTART_EN_MASK |\n\t\t\t\tDSPDMAC_CHNLSTART_DIS_MASK);\n\t}\n\n\tstatus = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,\n\t\t\treg | (1 << (dma_chan + DSPDMAC_CHNLSTART_EN_LOBIT)));\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write CHNLSTART reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"-- dsp_dma_start() -- Complete ---------\\n\");\n\n\treturn status;\n}\n\n \nstatic int dsp_dma_stop(struct hda_codec *codec,\n\t\t\tunsigned int dma_chan, bool ovly)\n{\n\tunsigned int reg = 0;\n\tint status = 0;\n\n\tcodec_dbg(codec, \"-- dsp_dma_stop() -- Begin ---------\\n\");\n\n\tif (ovly) {\n\t\tstatus = chipio_read(codec,\n\t\t\t\t     DSPDMAC_CHNLSTART_INST_OFFSET, &reg);\n\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"read CHNLSTART reg fail\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tcodec_dbg(codec, \"-- dsp_dma_stop()    Read CHNLSTART\\n\");\n\t\treg &= ~(DSPDMAC_CHNLSTART_EN_MASK |\n\t\t\t\tDSPDMAC_CHNLSTART_DIS_MASK);\n\t}\n\n\tstatus = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,\n\t\t\treg | (1 << (dma_chan + DSPDMAC_CHNLSTART_DIS_LOBIT)));\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"write CHNLSTART reg fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"-- dsp_dma_stop() -- Complete ---------\\n\");\n\n\treturn status;\n}\n\n \nstatic int dsp_allocate_router_ports(struct hda_codec *codec,\n\t\t\t\t     unsigned int num_chans,\n\t\t\t\t     unsigned int ports_per_channel,\n\t\t\t\t     unsigned int start_device,\n\t\t\t\t     unsigned int *port_map)\n{\n\tint status = 0;\n\tint res;\n\tu8 val;\n\n\tstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tval = start_device << 6;\n\tval |= (ports_per_channel - 1) << 4;\n\tval |= num_chans - 1;\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PORT_ALLOC_CONFIG_SET,\n\t\t\t    val);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PORT_ALLOC_SET,\n\t\t\t    MEM_CONNID_DSP);\n\n\tstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tres = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t\tVENDOR_CHIPIO_PORT_ALLOC_GET, 0);\n\n\t*port_map = res;\n\n\treturn (res < 0) ? res : 0;\n}\n\n \nstatic int dsp_free_router_ports(struct hda_codec *codec)\n{\n\tint status = 0;\n\n\tstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PORT_FREE_SET,\n\t\t\t    MEM_CONNID_DSP);\n\n\tstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\n\n\treturn status;\n}\n\n \nstatic int dsp_allocate_ports(struct hda_codec *codec,\n\t\t\tunsigned int num_chans,\n\t\t\tunsigned int rate_multi, unsigned int *port_map)\n{\n\tint status;\n\n\tcodec_dbg(codec, \"     dsp_allocate_ports() -- begin\\n\");\n\n\tif ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {\n\t\tcodec_dbg(codec, \"bad rate multiple\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = dsp_allocate_router_ports(codec, num_chans,\n\t\t\t\t\t   rate_multi, 0, port_map);\n\n\tcodec_dbg(codec, \"     dsp_allocate_ports() -- complete\\n\");\n\n\treturn status;\n}\n\nstatic int dsp_allocate_ports_format(struct hda_codec *codec,\n\t\t\tconst unsigned short fmt,\n\t\t\tunsigned int *port_map)\n{\n\tunsigned int num_chans;\n\n\tunsigned int sample_rate_div = ((get_hdafmt_rate(fmt) >> 0) & 3) + 1;\n\tunsigned int sample_rate_mul = ((get_hdafmt_rate(fmt) >> 3) & 3) + 1;\n\tunsigned int rate_multi = sample_rate_mul / sample_rate_div;\n\n\tif ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {\n\t\tcodec_dbg(codec, \"bad rate multiple\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_chans = get_hdafmt_chs(fmt) + 1;\n\n\treturn dsp_allocate_ports(codec, num_chans, rate_multi, port_map);\n}\n\n \nstatic int dsp_free_ports(struct hda_codec *codec)\n{\n\tint status;\n\n\tcodec_dbg(codec, \"     dsp_free_ports() -- begin\\n\");\n\n\tstatus = dsp_free_router_ports(codec);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"free router ports fail\\n\");\n\t\treturn status;\n\t}\n\tcodec_dbg(codec, \"     dsp_free_ports() -- complete\\n\");\n\n\treturn status;\n}\n\n \nstruct dma_engine {\n\tstruct hda_codec *codec;\n\tunsigned short m_converter_format;\n\tstruct snd_dma_buffer *dmab;\n\tunsigned int buf_size;\n};\n\n\nenum dma_state {\n\tDMA_STATE_STOP  = 0,\n\tDMA_STATE_RUN   = 1\n};\n\nstatic int dma_convert_to_hda_format(struct hda_codec *codec,\n\t\tunsigned int sample_rate,\n\t\tunsigned short channels,\n\t\tunsigned short *hda_format)\n{\n\tunsigned int format_val;\n\n\tformat_val = snd_hdac_calc_stream_format(sample_rate,\n\t\t\t\tchannels, SNDRV_PCM_FORMAT_S32_LE, 32, 0);\n\n\tif (hda_format)\n\t\t*hda_format = (unsigned short)format_val;\n\n\treturn 0;\n}\n\n \nstatic int dma_reset(struct dma_engine *dma)\n{\n\tstruct hda_codec *codec = dma->codec;\n\tstruct ca0132_spec *spec = codec->spec;\n\tint status;\n\n\tif (dma->dmab->area)\n\t\tsnd_hda_codec_load_dsp_cleanup(codec, dma->dmab);\n\n\tstatus = snd_hda_codec_load_dsp_prepare(codec,\n\t\t\tdma->m_converter_format,\n\t\t\tdma->buf_size,\n\t\t\tdma->dmab);\n\tif (status < 0)\n\t\treturn status;\n\tspec->dsp_stream_id = status;\n\treturn 0;\n}\n\nstatic int dma_set_state(struct dma_engine *dma, enum dma_state state)\n{\n\tbool cmd;\n\n\tswitch (state) {\n\tcase DMA_STATE_STOP:\n\t\tcmd = false;\n\t\tbreak;\n\tcase DMA_STATE_RUN:\n\t\tcmd = true;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tsnd_hda_codec_load_dsp_trigger(dma->codec, cmd);\n\treturn 0;\n}\n\nstatic unsigned int dma_get_buffer_size(struct dma_engine *dma)\n{\n\treturn dma->dmab->bytes;\n}\n\nstatic unsigned char *dma_get_buffer_addr(struct dma_engine *dma)\n{\n\treturn dma->dmab->area;\n}\n\nstatic int dma_xfer(struct dma_engine *dma,\n\t\tconst unsigned int *data,\n\t\tunsigned int count)\n{\n\tmemcpy(dma->dmab->area, data, count);\n\treturn 0;\n}\n\nstatic void dma_get_converter_format(\n\t\tstruct dma_engine *dma,\n\t\tunsigned short *format)\n{\n\tif (format)\n\t\t*format = dma->m_converter_format;\n}\n\nstatic unsigned int dma_get_stream_id(struct dma_engine *dma)\n{\n\tstruct ca0132_spec *spec = dma->codec->spec;\n\n\treturn spec->dsp_stream_id;\n}\n\nstruct dsp_image_seg {\n\tu32 magic;\n\tu32 chip_addr;\n\tu32 count;\n\tu32 data[];\n};\n\nstatic const u32 g_magic_value = 0x4c46584d;\nstatic const u32 g_chip_addr_magic_value = 0xFFFFFF01;\n\nstatic bool is_valid(const struct dsp_image_seg *p)\n{\n\treturn p->magic == g_magic_value;\n}\n\nstatic bool is_hci_prog_list_seg(const struct dsp_image_seg *p)\n{\n\treturn g_chip_addr_magic_value == p->chip_addr;\n}\n\nstatic bool is_last(const struct dsp_image_seg *p)\n{\n\treturn p->count == 0;\n}\n\nstatic size_t dsp_sizeof(const struct dsp_image_seg *p)\n{\n\treturn struct_size(p, data, p->count);\n}\n\nstatic const struct dsp_image_seg *get_next_seg_ptr(\n\t\t\t\tconst struct dsp_image_seg *p)\n{\n\treturn (struct dsp_image_seg *)((unsigned char *)(p) + dsp_sizeof(p));\n}\n\n \n#define INVALID_DMA_CHANNEL (~0U)\n\n \nstatic int dspxfr_hci_write(struct hda_codec *codec,\n\t\t\tconst struct dsp_image_seg *fls)\n{\n\tint status;\n\tconst u32 *data;\n\tunsigned int count;\n\n\tif (fls == NULL || fls->chip_addr != g_chip_addr_magic_value) {\n\t\tcodec_dbg(codec, \"hci_write invalid params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcount = fls->count;\n\tdata = (u32 *)(fls->data);\n\twhile (count >= 2) {\n\t\tstatus = chipio_write(codec, data[0], data[1]);\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"hci_write chipio failed\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tcount -= 2;\n\t\tdata  += 2;\n\t}\n\treturn 0;\n}\n\n \nstatic int dspxfr_one_seg(struct hda_codec *codec,\n\t\t\tconst struct dsp_image_seg *fls,\n\t\t\tunsigned int reloc,\n\t\t\tstruct dma_engine *dma_engine,\n\t\t\tunsigned int dma_chan,\n\t\t\tunsigned int port_map_mask,\n\t\t\tbool ovly)\n{\n\tint status = 0;\n\tbool comm_dma_setup_done = false;\n\tconst unsigned int *data;\n\tunsigned int chip_addx;\n\tunsigned int words_to_write;\n\tunsigned int buffer_size_words;\n\tunsigned char *buffer_addx;\n\tunsigned short hda_format;\n\tunsigned int sample_rate_div;\n\tunsigned int sample_rate_mul;\n\tunsigned int num_chans;\n\tunsigned int hda_frame_size_words;\n\tunsigned int remainder_words;\n\tconst u32 *data_remainder;\n\tu32 chip_addx_remainder;\n\tunsigned int run_size_words;\n\tconst struct dsp_image_seg *hci_write = NULL;\n\tunsigned long timeout;\n\tbool dma_active;\n\n\tif (fls == NULL)\n\t\treturn -EINVAL;\n\tif (is_hci_prog_list_seg(fls)) {\n\t\thci_write = fls;\n\t\tfls = get_next_seg_ptr(fls);\n\t}\n\n\tif (hci_write && (!fls || is_last(fls))) {\n\t\tcodec_dbg(codec, \"hci_write\\n\");\n\t\treturn dspxfr_hci_write(codec, hci_write);\n\t}\n\n\tif (fls == NULL || dma_engine == NULL || port_map_mask == 0) {\n\t\tcodec_dbg(codec, \"Invalid Params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = fls->data;\n\tchip_addx = fls->chip_addr;\n\twords_to_write = fls->count;\n\n\tif (!words_to_write)\n\t\treturn hci_write ? dspxfr_hci_write(codec, hci_write) : 0;\n\tif (reloc)\n\t\tchip_addx = (chip_addx & (0xFFFF0000 << 2)) + (reloc << 2);\n\n\tif (!UC_RANGE(chip_addx, words_to_write) &&\n\t    !X_RANGE_ALL(chip_addx, words_to_write) &&\n\t    !Y_RANGE_ALL(chip_addx, words_to_write)) {\n\t\tcodec_dbg(codec, \"Invalid chip_addx Params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size_words = (unsigned int)dma_get_buffer_size(dma_engine) /\n\t\t\t\t\tsizeof(u32);\n\n\tbuffer_addx = dma_get_buffer_addr(dma_engine);\n\n\tif (buffer_addx == NULL) {\n\t\tcodec_dbg(codec, \"dma_engine buffer NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma_get_converter_format(dma_engine, &hda_format);\n\tsample_rate_div = ((get_hdafmt_rate(hda_format) >> 0) & 3) + 1;\n\tsample_rate_mul = ((get_hdafmt_rate(hda_format) >> 3) & 3) + 1;\n\tnum_chans = get_hdafmt_chs(hda_format) + 1;\n\n\thda_frame_size_words = ((sample_rate_div == 0) ? 0 :\n\t\t\t(num_chans * sample_rate_mul / sample_rate_div));\n\n\tif (hda_frame_size_words == 0) {\n\t\tcodec_dbg(codec, \"frmsz zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_size_words = min(buffer_size_words,\n\t\t\t\t(unsigned int)(UC_RANGE(chip_addx, 1) ?\n\t\t\t\t65536 : 32768));\n\tbuffer_size_words -= buffer_size_words % hda_frame_size_words;\n\tcodec_dbg(codec,\n\t\t   \"chpadr=0x%08x frmsz=%u nchan=%u \"\n\t\t   \"rate_mul=%u div=%u bufsz=%u\\n\",\n\t\t   chip_addx, hda_frame_size_words, num_chans,\n\t\t   sample_rate_mul, sample_rate_div, buffer_size_words);\n\n\tif (buffer_size_words < hda_frame_size_words) {\n\t\tcodec_dbg(codec, \"dspxfr_one_seg:failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tremainder_words = words_to_write % hda_frame_size_words;\n\tdata_remainder = data;\n\tchip_addx_remainder = chip_addx;\n\n\tdata += remainder_words;\n\tchip_addx += remainder_words*sizeof(u32);\n\twords_to_write -= remainder_words;\n\n\twhile (words_to_write != 0) {\n\t\trun_size_words = min(buffer_size_words, words_to_write);\n\t\tcodec_dbg(codec, \"dspxfr (seg loop)cnt=%u rs=%u remainder=%u\\n\",\n\t\t\t    words_to_write, run_size_words, remainder_words);\n\t\tdma_xfer(dma_engine, data, run_size_words*sizeof(u32));\n\t\tif (!comm_dma_setup_done) {\n\t\t\tstatus = dsp_dma_stop(codec, dma_chan, ovly);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tstatus = dsp_dma_setup_common(codec, chip_addx,\n\t\t\t\t\t\tdma_chan, port_map_mask, ovly);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tcomm_dma_setup_done = true;\n\t\t}\n\n\t\tstatus = dsp_dma_setup(codec, chip_addx,\n\t\t\t\t\t\trun_size_words, dma_chan);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = dsp_dma_start(codec, dma_chan, ovly);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tif (!dsp_is_dma_active(codec, dma_chan)) {\n\t\t\tcodec_dbg(codec, \"dspxfr:DMA did not start\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tstatus = dma_set_state(dma_engine, DMA_STATE_RUN);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tif (remainder_words != 0) {\n\t\t\tstatus = chipio_write_multiple(codec,\n\t\t\t\t\t\tchip_addx_remainder,\n\t\t\t\t\t\tdata_remainder,\n\t\t\t\t\t\tremainder_words);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tremainder_words = 0;\n\t\t}\n\t\tif (hci_write) {\n\t\t\tstatus = dspxfr_hci_write(codec, hci_write);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\thci_write = NULL;\n\t\t}\n\n\t\ttimeout = jiffies + msecs_to_jiffies(2000);\n\t\tdo {\n\t\t\tdma_active = dsp_is_dma_active(codec, dma_chan);\n\t\t\tif (!dma_active)\n\t\t\t\tbreak;\n\t\t\tmsleep(20);\n\t\t} while (time_before(jiffies, timeout));\n\t\tif (dma_active)\n\t\t\tbreak;\n\n\t\tcodec_dbg(codec, \"+++++ DMA complete\\n\");\n\t\tdma_set_state(dma_engine, DMA_STATE_STOP);\n\t\tstatus = dma_reset(dma_engine);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tdata += run_size_words;\n\t\tchip_addx += run_size_words*sizeof(u32);\n\t\twords_to_write -= run_size_words;\n\t}\n\n\tif (remainder_words != 0) {\n\t\tstatus = chipio_write_multiple(codec, chip_addx_remainder,\n\t\t\t\t\tdata_remainder, remainder_words);\n\t}\n\n\treturn status;\n}\n\n \nstatic int dspxfr_image(struct hda_codec *codec,\n\t\t\tconst struct dsp_image_seg *fls_data,\n\t\t\tunsigned int reloc,\n\t\t\tunsigned int sample_rate,\n\t\t\tunsigned short channels,\n\t\t\tbool ovly)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint status;\n\tunsigned short hda_format = 0;\n\tunsigned int response;\n\tunsigned char stream_id = 0;\n\tstruct dma_engine *dma_engine;\n\tunsigned int dma_chan;\n\tunsigned int port_map_mask;\n\n\tif (fls_data == NULL)\n\t\treturn -EINVAL;\n\n\tdma_engine = kzalloc(sizeof(*dma_engine), GFP_KERNEL);\n\tif (!dma_engine)\n\t\treturn -ENOMEM;\n\n\tdma_engine->dmab = kzalloc(sizeof(*dma_engine->dmab), GFP_KERNEL);\n\tif (!dma_engine->dmab) {\n\t\tkfree(dma_engine);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_engine->codec = codec;\n\tdma_convert_to_hda_format(codec, sample_rate, channels, &hda_format);\n\tdma_engine->m_converter_format = hda_format;\n\tdma_engine->buf_size = (ovly ? DSP_DMA_WRITE_BUFLEN_OVLY :\n\t\t\tDSP_DMA_WRITE_BUFLEN_INIT) * 2;\n\n\tdma_chan = ovly ? INVALID_DMA_CHANNEL : 0;\n\n\tstatus = codec_set_converter_format(codec, WIDGET_CHIP_CTRL,\n\t\t\t\t\thda_format, &response);\n\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"set converter format fail\\n\");\n\t\tgoto exit;\n\t}\n\n\tstatus = snd_hda_codec_load_dsp_prepare(codec,\n\t\t\t\tdma_engine->m_converter_format,\n\t\t\t\tdma_engine->buf_size,\n\t\t\t\tdma_engine->dmab);\n\tif (status < 0)\n\t\tgoto exit;\n\tspec->dsp_stream_id = status;\n\n\tif (ovly) {\n\t\tstatus = dspio_alloc_dma_chan(codec, &dma_chan);\n\t\tif (status < 0) {\n\t\t\tcodec_dbg(codec, \"alloc dmachan fail\\n\");\n\t\t\tdma_chan = INVALID_DMA_CHANNEL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tport_map_mask = 0;\n\tstatus = dsp_allocate_ports_format(codec, hda_format,\n\t\t\t\t\t&port_map_mask);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"alloc ports fail\\n\");\n\t\tgoto exit;\n\t}\n\n\tstream_id = dma_get_stream_id(dma_engine);\n\tstatus = codec_set_converter_stream_channel(codec,\n\t\t\tWIDGET_CHIP_CTRL, stream_id, 0, &response);\n\tif (status < 0) {\n\t\tcodec_dbg(codec, \"set stream chan fail\\n\");\n\t\tgoto exit;\n\t}\n\n\twhile ((fls_data != NULL) && !is_last(fls_data)) {\n\t\tif (!is_valid(fls_data)) {\n\t\t\tcodec_dbg(codec, \"FLS check fail\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\tstatus = dspxfr_one_seg(codec, fls_data, reloc,\n\t\t\t\t\tdma_engine, dma_chan,\n\t\t\t\t\tport_map_mask, ovly);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (is_hci_prog_list_seg(fls_data))\n\t\t\tfls_data = get_next_seg_ptr(fls_data);\n\n\t\tif ((fls_data != NULL) && !is_last(fls_data))\n\t\t\tfls_data = get_next_seg_ptr(fls_data);\n\t}\n\n\tif (port_map_mask != 0)\n\t\tstatus = dsp_free_ports(codec);\n\n\tif (status < 0)\n\t\tgoto exit;\n\n\tstatus = codec_set_converter_stream_channel(codec,\n\t\t\t\tWIDGET_CHIP_CTRL, 0, 0, &response);\n\nexit:\n\tif (ovly && (dma_chan != INVALID_DMA_CHANNEL))\n\t\tdspio_free_dma_chan(codec, dma_chan);\n\n\tif (dma_engine->dmab->area)\n\t\tsnd_hda_codec_load_dsp_cleanup(codec, dma_engine->dmab);\n\tkfree(dma_engine->dmab);\n\tkfree(dma_engine);\n\n\treturn status;\n}\n\n \nstatic void dspload_post_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tcodec_dbg(codec, \"---- dspload_post_setup ------\\n\");\n\tif (!ca0132_use_alt_functions(spec)) {\n\t\t \n\t\tchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);\n\t\tchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x19), 0x3f800000);\n\n\t\t \n\t\tchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x29), 0x00000002);\n\t}\n}\n\n \nstatic int dspload_image(struct hda_codec *codec,\n\t\t\tconst struct dsp_image_seg *fls,\n\t\t\tbool ovly,\n\t\t\tunsigned int reloc,\n\t\t\tbool autostart,\n\t\t\tint router_chans)\n{\n\tint status = 0;\n\tunsigned int sample_rate;\n\tunsigned short channels;\n\n\tcodec_dbg(codec, \"---- dspload_image begin ------\\n\");\n\tif (router_chans == 0) {\n\t\tif (!ovly)\n\t\t\trouter_chans = DMA_TRANSFER_FRAME_SIZE_NWORDS;\n\t\telse\n\t\t\trouter_chans = DMA_OVERLAY_FRAME_SIZE_NWORDS;\n\t}\n\n\tsample_rate = 48000;\n\tchannels = (unsigned short)router_chans;\n\n\twhile (channels > 16) {\n\t\tsample_rate *= 2;\n\t\tchannels /= 2;\n\t}\n\n\tdo {\n\t\tcodec_dbg(codec, \"Ready to program DMA\\n\");\n\t\tif (!ovly)\n\t\t\tstatus = dsp_reset(codec);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tcodec_dbg(codec, \"dsp_reset() complete\\n\");\n\t\tstatus = dspxfr_image(codec, fls, reloc, sample_rate, channels,\n\t\t\t\t      ovly);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tcodec_dbg(codec, \"dspxfr_image() complete\\n\");\n\t\tif (autostart && !ovly) {\n\t\t\tdspload_post_setup(codec);\n\t\t\tstatus = dsp_set_run_state(codec);\n\t\t}\n\n\t\tcodec_dbg(codec, \"LOAD FINISHED\\n\");\n\t} while (0);\n\n\treturn status;\n}\n\n#ifdef CONFIG_SND_HDA_CODEC_CA0132_DSP\nstatic bool dspload_is_loaded(struct hda_codec *codec)\n{\n\tunsigned int data = 0;\n\tint status = 0;\n\n\tstatus = chipio_read(codec, 0x40004, &data);\n\tif ((status < 0) || (data != 1))\n\t\treturn false;\n\n\treturn true;\n}\n#else\n#define dspload_is_loaded(codec)\tfalse\n#endif\n\nstatic bool dspload_wait_loaded(struct hda_codec *codec)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(2000);\n\n\tdo {\n\t\tif (dspload_is_loaded(codec)) {\n\t\t\tcodec_info(codec, \"ca0132 DSP downloaded and running\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(20);\n\t} while (time_before(jiffies, timeout));\n\n\tcodec_err(codec, \"ca0132 failed to download DSP\\n\");\n\treturn false;\n}\n\n \n\n \nstatic void ca0113_mmio_gpio_set(struct hda_codec *codec, unsigned int gpio_pin,\n\t\tbool enable)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned short gpio_data;\n\n\tgpio_data = gpio_pin & 0xF;\n\tgpio_data |= ((enable << 8) & 0x100);\n\n\twritew(gpio_data, spec->mem_base + 0x320);\n}\n\n \nstatic void ca0113_mmio_command_set(struct hda_codec *codec, unsigned int group,\n\t\tunsigned int target, unsigned int value)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int write_val;\n\n\twritel(0x0000007e, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\twritel(0x0000005a, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\n\twritel(0x00800005, spec->mem_base + 0x20c);\n\twritel(group, spec->mem_base + 0x804);\n\n\twritel(0x00800005, spec->mem_base + 0x20c);\n\twrite_val = (target & 0xff);\n\twrite_val |= (value << 8);\n\n\n\twritel(write_val, spec->mem_base + 0x204);\n\t \n\tmsleep(20);\n\n\treadl(spec->mem_base + 0x860);\n\treadl(spec->mem_base + 0x854);\n\treadl(spec->mem_base + 0x840);\n\n\twritel(0x00800004, spec->mem_base + 0x20c);\n\twritel(0x00000000, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n}\n\n \nstatic void ca0113_mmio_command_set_type2(struct hda_codec *codec,\n\t\tunsigned int group, unsigned int target, unsigned int value)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int write_val;\n\n\twritel(0x0000007e, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\twritel(0x0000005a, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\n\twritel(0x00800003, spec->mem_base + 0x20c);\n\twritel(group, spec->mem_base + 0x804);\n\n\twritel(0x00800005, spec->mem_base + 0x20c);\n\twrite_val = (target & 0xff);\n\twrite_val |= (value << 8);\n\n\n\twritel(write_val, spec->mem_base + 0x204);\n\tmsleep(20);\n\treadl(spec->mem_base + 0x860);\n\treadl(spec->mem_base + 0x854);\n\treadl(spec->mem_base + 0x840);\n\n\twritel(0x00800004, spec->mem_base + 0x20c);\n\twritel(0x00000000, spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n\treadl(spec->mem_base + 0x210);\n}\n\n \n\n \nstatic void ca0132_gpio_init(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\tcase QUIRK_AE5:\n\tcase QUIRK_AE7:\n\t\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, 0x790, 0x23);\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x5B);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\n \nstatic void ca0132_gpio_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DIRECTION, 0x07);\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_MASK, 0x07);\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, 0x04);\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, 0x06);\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DIRECTION, 0x1E);\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_MASK, 0x1F);\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, 0x0C);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\nenum r3di_gpio_bit {\n\t \n\tR3DI_MIC_SELECT_BIT = 1,\n\t \n\tR3DI_OUT_SELECT_BIT = 2,\n\t \n\tR3DI_GPIO_DSP_DOWNLOADING = 3,\n\t \n\tR3DI_GPIO_DSP_DOWNLOADED = 4\n};\n\nenum r3di_mic_select {\n\t \n\tR3DI_REAR_MIC = 0,\n\t \n\tR3DI_FRONT_MIC = 1\n};\n\nenum r3di_out_select {\n\t \n\tR3DI_HEADPHONE_OUT = 0,\n\t \n\tR3DI_LINE_OUT = 1\n};\nenum r3di_dsp_status {\n\t \n\tR3DI_DSP_DOWNLOADING = 0,\n\t \n\tR3DI_DSP_DOWNLOADED = 1\n};\n\n\nstatic void r3di_gpio_mic_set(struct hda_codec *codec,\n\t\tenum r3di_mic_select cur_mic)\n{\n\tunsigned int cur_gpio;\n\n\t \n\tcur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);\n\n\tswitch (cur_mic) {\n\tcase R3DI_REAR_MIC:\n\t\tcur_gpio &= ~(1 << R3DI_MIC_SELECT_BIT);\n\t\tbreak;\n\tcase R3DI_FRONT_MIC:\n\t\tcur_gpio |= (1 << R3DI_MIC_SELECT_BIT);\n\t\tbreak;\n\t}\n\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t    AC_VERB_SET_GPIO_DATA, cur_gpio);\n}\n\nstatic void r3di_gpio_dsp_status_set(struct hda_codec *codec,\n\t\tenum r3di_dsp_status dsp_status)\n{\n\tunsigned int cur_gpio;\n\n\t \n\tcur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);\n\n\tswitch (dsp_status) {\n\tcase R3DI_DSP_DOWNLOADING:\n\t\tcur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADING);\n\t\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, cur_gpio);\n\t\tbreak;\n\tcase R3DI_DSP_DOWNLOADED:\n\t\t \n\t\tcur_gpio &= ~(1 << R3DI_GPIO_DSP_DOWNLOADING);\n\n\t\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, cur_gpio);\n\n\t\tcur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADED);\n\t\tbreak;\n\t}\n\n\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t    AC_VERB_SET_GPIO_DATA, cur_gpio);\n}\n\n \nstatic int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\tstruct hda_codec *codec,\n\t\t\tunsigned int stream_tag,\n\t\t\tunsigned int format,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tsnd_hda_codec_setup_stream(codec, spec->dacs[0], stream_tag, 0, format);\n\n\treturn 0;\n}\n\nstatic int ca0132_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\tstruct hda_codec *codec,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tif (spec->dsp_state == DSP_DOWNLOADING)\n\t\treturn 0;\n\n\t \n\tif (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])\n\t\tmsleep(50);\n\n\tsnd_hda_codec_cleanup_stream(codec, spec->dacs[0]);\n\n\treturn 0;\n}\n\nstatic unsigned int ca0132_playback_pcm_delay(struct hda_pcm_stream *info,\n\t\t\tstruct hda_codec *codec,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int latency = DSP_PLAYBACK_INIT_LATENCY;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn 0;\n\n\t \n\tif (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]) {\n\t\tif ((spec->effects_switch[SURROUND - EFFECT_START_NID]) ||\n\t\t    (spec->effects_switch[DIALOG_PLUS - EFFECT_START_NID]))\n\t\t\tlatency += DSP_PLAY_ENHANCEMENT_LATENCY;\n\t}\n\n\t \n\tif (spec->cur_out_type == SPEAKER_OUT)\n\t\tlatency += DSP_SPEAKER_OUT_LATENCY;\n\n\treturn (latency * runtime->rate) / 1000;\n}\n\n \nstatic int ca0132_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t\t\tstruct hda_codec *codec,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\n}\n\nstatic int ca0132_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\tstruct hda_codec *codec,\n\t\t\tunsigned int stream_tag,\n\t\t\tunsigned int format,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\n\t\t\t\t\t     stream_tag, format, substream);\n}\n\nstatic int ca0132_dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\tstruct hda_codec *codec,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_cleanup(codec, &spec->multiout);\n}\n\nstatic int ca0132_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t\t struct hda_codec *codec,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\n}\n\n \nstatic int ca0132_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t\tstruct hda_codec *codec,\n\t\t\t\t\tunsigned int stream_tag,\n\t\t\t\t\tunsigned int format,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_setup_stream(codec, hinfo->nid,\n\t\t\t\t   stream_tag, 0, format);\n\n\treturn 0;\n}\n\nstatic int ca0132_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\tstruct hda_codec *codec,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tif (spec->dsp_state == DSP_DOWNLOADING)\n\t\treturn 0;\n\n\tsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\n\treturn 0;\n}\n\nstatic unsigned int ca0132_capture_pcm_delay(struct hda_pcm_stream *info,\n\t\t\tstruct hda_codec *codec,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int latency = DSP_CAPTURE_INIT_LATENCY;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn 0;\n\n\tif (spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID])\n\t\tlatency += DSP_CRYSTAL_VOICE_LATENCY;\n\n\treturn (latency * runtime->rate) / 1000;\n}\n\n \n\n \n#define CA0132_CODEC_VOL_MONO(xname, nid, channel, dir) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t  .name = xname, \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \\\n\t  .info = ca0132_volume_info, \\\n\t  .get = ca0132_volume_get, \\\n\t  .put = ca0132_volume_put, \\\n\t  .tlv = { .c = ca0132_volume_tlv }, \\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, 0, dir) }\n\n \n#define CA0132_ALT_CODEC_VOL_MONO(xname, nid, channel, dir) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t  .name = xname, \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \\\n\t  .info = snd_hda_mixer_amp_volume_info, \\\n\t  .get = snd_hda_mixer_amp_volume_get, \\\n\t  .put = ca0132_alt_volume_put, \\\n\t  .tlv = { .c = snd_hda_mixer_amp_tlv }, \\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, 0, dir) }\n\n#define CA0132_CODEC_MUTE_MONO(xname, nid, channel, dir) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t  .name = xname, \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .info = snd_hda_mixer_amp_switch_info, \\\n\t  .get = ca0132_switch_get, \\\n\t  .put = ca0132_switch_put, \\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, 0, dir) }\n\n \n#define CA0132_CODEC_VOL(xname, nid, dir) \\\n\tCA0132_CODEC_VOL_MONO(xname, nid, 3, dir)\n#define CA0132_ALT_CODEC_VOL(xname, nid, dir) \\\n\tCA0132_ALT_CODEC_VOL_MONO(xname, nid, 3, dir)\n#define CA0132_CODEC_MUTE(xname, nid, dir) \\\n\tCA0132_CODEC_MUTE_MONO(xname, nid, 3, dir)\n\n \n \nstatic const unsigned int float_vol_db_lookup[] = {\n0xC2B40000, 0xC2B20000, 0xC2B00000, 0xC2AE0000, 0xC2AC0000, 0xC2AA0000,\n0xC2A80000, 0xC2A60000, 0xC2A40000, 0xC2A20000, 0xC2A00000, 0xC29E0000,\n0xC29C0000, 0xC29A0000, 0xC2980000, 0xC2960000, 0xC2940000, 0xC2920000,\n0xC2900000, 0xC28E0000, 0xC28C0000, 0xC28A0000, 0xC2880000, 0xC2860000,\n0xC2840000, 0xC2820000, 0xC2800000, 0xC27C0000, 0xC2780000, 0xC2740000,\n0xC2700000, 0xC26C0000, 0xC2680000, 0xC2640000, 0xC2600000, 0xC25C0000,\n0xC2580000, 0xC2540000, 0xC2500000, 0xC24C0000, 0xC2480000, 0xC2440000,\n0xC2400000, 0xC23C0000, 0xC2380000, 0xC2340000, 0xC2300000, 0xC22C0000,\n0xC2280000, 0xC2240000, 0xC2200000, 0xC21C0000, 0xC2180000, 0xC2140000,\n0xC2100000, 0xC20C0000, 0xC2080000, 0xC2040000, 0xC2000000, 0xC1F80000,\n0xC1F00000, 0xC1E80000, 0xC1E00000, 0xC1D80000, 0xC1D00000, 0xC1C80000,\n0xC1C00000, 0xC1B80000, 0xC1B00000, 0xC1A80000, 0xC1A00000, 0xC1980000,\n0xC1900000, 0xC1880000, 0xC1800000, 0xC1700000, 0xC1600000, 0xC1500000,\n0xC1400000, 0xC1300000, 0xC1200000, 0xC1100000, 0xC1000000, 0xC0E00000,\n0xC0C00000, 0xC0A00000, 0xC0800000, 0xC0400000, 0xC0000000, 0xBF800000,\n0x00000000, 0x3F800000, 0x40000000, 0x40400000, 0x40800000, 0x40A00000,\n0x40C00000, 0x40E00000, 0x41000000, 0x41100000\n};\n\n \nstatic const unsigned int float_zero_to_one_lookup[] = {\n0x00000000, 0x3C23D70A, 0x3CA3D70A, 0x3CF5C28F, 0x3D23D70A, 0x3D4CCCCD,\n0x3D75C28F, 0x3D8F5C29, 0x3DA3D70A, 0x3DB851EC, 0x3DCCCCCD, 0x3DE147AE,\n0x3DF5C28F, 0x3E051EB8, 0x3E0F5C29, 0x3E19999A, 0x3E23D70A, 0x3E2E147B,\n0x3E3851EC, 0x3E428F5C, 0x3E4CCCCD, 0x3E570A3D, 0x3E6147AE, 0x3E6B851F,\n0x3E75C28F, 0x3E800000, 0x3E851EB8, 0x3E8A3D71, 0x3E8F5C29, 0x3E947AE1,\n0x3E99999A, 0x3E9EB852, 0x3EA3D70A, 0x3EA8F5C3, 0x3EAE147B, 0x3EB33333,\n0x3EB851EC, 0x3EBD70A4, 0x3EC28F5C, 0x3EC7AE14, 0x3ECCCCCD, 0x3ED1EB85,\n0x3ED70A3D, 0x3EDC28F6, 0x3EE147AE, 0x3EE66666, 0x3EEB851F, 0x3EF0A3D7,\n0x3EF5C28F, 0x3EFAE148, 0x3F000000, 0x3F028F5C, 0x3F051EB8, 0x3F07AE14,\n0x3F0A3D71, 0x3F0CCCCD, 0x3F0F5C29, 0x3F11EB85, 0x3F147AE1, 0x3F170A3D,\n0x3F19999A, 0x3F1C28F6, 0x3F1EB852, 0x3F2147AE, 0x3F23D70A, 0x3F266666,\n0x3F28F5C3, 0x3F2B851F, 0x3F2E147B, 0x3F30A3D7, 0x3F333333, 0x3F35C28F,\n0x3F3851EC, 0x3F3AE148, 0x3F3D70A4, 0x3F400000, 0x3F428F5C, 0x3F451EB8,\n0x3F47AE14, 0x3F4A3D71, 0x3F4CCCCD, 0x3F4F5C29, 0x3F51EB85, 0x3F547AE1,\n0x3F570A3D, 0x3F59999A, 0x3F5C28F6, 0x3F5EB852, 0x3F6147AE, 0x3F63D70A,\n0x3F666666, 0x3F68F5C3, 0x3F6B851F, 0x3F6E147B, 0x3F70A3D7, 0x3F733333,\n0x3F75C28F, 0x3F7851EC, 0x3F7AE148, 0x3F7D70A4, 0x3F800000\n};\n\n \nstatic const unsigned int float_xbass_xover_lookup[] = {\n0x41200000, 0x41A00000, 0x41F00000, 0x42200000, 0x42480000, 0x42700000,\n0x428C0000, 0x42A00000, 0x42B40000, 0x42C80000, 0x42DC0000, 0x42F00000,\n0x43020000, 0x430C0000, 0x43160000, 0x43200000, 0x432A0000, 0x43340000,\n0x433E0000, 0x43480000, 0x43520000, 0x435C0000, 0x43660000, 0x43700000,\n0x437A0000, 0x43820000, 0x43870000, 0x438C0000, 0x43910000, 0x43960000,\n0x439B0000, 0x43A00000, 0x43A50000, 0x43AA0000, 0x43AF0000, 0x43B40000,\n0x43B90000, 0x43BE0000, 0x43C30000, 0x43C80000, 0x43CD0000, 0x43D20000,\n0x43D70000, 0x43DC0000, 0x43E10000, 0x43E60000, 0x43EB0000, 0x43F00000,\n0x43F50000, 0x43FA0000, 0x43FF0000, 0x44020000, 0x44048000, 0x44070000,\n0x44098000, 0x440C0000, 0x440E8000, 0x44110000, 0x44138000, 0x44160000,\n0x44188000, 0x441B0000, 0x441D8000, 0x44200000, 0x44228000, 0x44250000,\n0x44278000, 0x442A0000, 0x442C8000, 0x442F0000, 0x44318000, 0x44340000,\n0x44368000, 0x44390000, 0x443B8000, 0x443E0000, 0x44408000, 0x44430000,\n0x44458000, 0x44480000, 0x444A8000, 0x444D0000, 0x444F8000, 0x44520000,\n0x44548000, 0x44570000, 0x44598000, 0x445C0000, 0x445E8000, 0x44610000,\n0x44638000, 0x44660000, 0x44688000, 0x446B0000, 0x446D8000, 0x44700000,\n0x44728000, 0x44750000, 0x44778000, 0x447A0000\n};\n\n \n#ifdef ENABLE_TUNING_CONTROLS\n\nstatic const unsigned int voice_focus_vals_lookup[] = {\n0x41A00000, 0x41A80000, 0x41B00000, 0x41B80000, 0x41C00000, 0x41C80000,\n0x41D00000, 0x41D80000, 0x41E00000, 0x41E80000, 0x41F00000, 0x41F80000,\n0x42000000, 0x42040000, 0x42080000, 0x420C0000, 0x42100000, 0x42140000,\n0x42180000, 0x421C0000, 0x42200000, 0x42240000, 0x42280000, 0x422C0000,\n0x42300000, 0x42340000, 0x42380000, 0x423C0000, 0x42400000, 0x42440000,\n0x42480000, 0x424C0000, 0x42500000, 0x42540000, 0x42580000, 0x425C0000,\n0x42600000, 0x42640000, 0x42680000, 0x426C0000, 0x42700000, 0x42740000,\n0x42780000, 0x427C0000, 0x42800000, 0x42820000, 0x42840000, 0x42860000,\n0x42880000, 0x428A0000, 0x428C0000, 0x428E0000, 0x42900000, 0x42920000,\n0x42940000, 0x42960000, 0x42980000, 0x429A0000, 0x429C0000, 0x429E0000,\n0x42A00000, 0x42A20000, 0x42A40000, 0x42A60000, 0x42A80000, 0x42AA0000,\n0x42AC0000, 0x42AE0000, 0x42B00000, 0x42B20000, 0x42B40000, 0x42B60000,\n0x42B80000, 0x42BA0000, 0x42BC0000, 0x42BE0000, 0x42C00000, 0x42C20000,\n0x42C40000, 0x42C60000, 0x42C80000, 0x42CA0000, 0x42CC0000, 0x42CE0000,\n0x42D00000, 0x42D20000, 0x42D40000, 0x42D60000, 0x42D80000, 0x42DA0000,\n0x42DC0000, 0x42DE0000, 0x42E00000, 0x42E20000, 0x42E40000, 0x42E60000,\n0x42E80000, 0x42EA0000, 0x42EC0000, 0x42EE0000, 0x42F00000, 0x42F20000,\n0x42F40000, 0x42F60000, 0x42F80000, 0x42FA0000, 0x42FC0000, 0x42FE0000,\n0x43000000, 0x43010000, 0x43020000, 0x43030000, 0x43040000, 0x43050000,\n0x43060000, 0x43070000, 0x43080000, 0x43090000, 0x430A0000, 0x430B0000,\n0x430C0000, 0x430D0000, 0x430E0000, 0x430F0000, 0x43100000, 0x43110000,\n0x43120000, 0x43130000, 0x43140000, 0x43150000, 0x43160000, 0x43170000,\n0x43180000, 0x43190000, 0x431A0000, 0x431B0000, 0x431C0000, 0x431D0000,\n0x431E0000, 0x431F0000, 0x43200000, 0x43210000, 0x43220000, 0x43230000,\n0x43240000, 0x43250000, 0x43260000, 0x43270000, 0x43280000, 0x43290000,\n0x432A0000, 0x432B0000, 0x432C0000, 0x432D0000, 0x432E0000, 0x432F0000,\n0x43300000, 0x43310000, 0x43320000, 0x43330000, 0x43340000\n};\n\nstatic const unsigned int mic_svm_vals_lookup[] = {\n0x00000000, 0x3C23D70A, 0x3CA3D70A, 0x3CF5C28F, 0x3D23D70A, 0x3D4CCCCD,\n0x3D75C28F, 0x3D8F5C29, 0x3DA3D70A, 0x3DB851EC, 0x3DCCCCCD, 0x3DE147AE,\n0x3DF5C28F, 0x3E051EB8, 0x3E0F5C29, 0x3E19999A, 0x3E23D70A, 0x3E2E147B,\n0x3E3851EC, 0x3E428F5C, 0x3E4CCCCD, 0x3E570A3D, 0x3E6147AE, 0x3E6B851F,\n0x3E75C28F, 0x3E800000, 0x3E851EB8, 0x3E8A3D71, 0x3E8F5C29, 0x3E947AE1,\n0x3E99999A, 0x3E9EB852, 0x3EA3D70A, 0x3EA8F5C3, 0x3EAE147B, 0x3EB33333,\n0x3EB851EC, 0x3EBD70A4, 0x3EC28F5C, 0x3EC7AE14, 0x3ECCCCCD, 0x3ED1EB85,\n0x3ED70A3D, 0x3EDC28F6, 0x3EE147AE, 0x3EE66666, 0x3EEB851F, 0x3EF0A3D7,\n0x3EF5C28F, 0x3EFAE148, 0x3F000000, 0x3F028F5C, 0x3F051EB8, 0x3F07AE14,\n0x3F0A3D71, 0x3F0CCCCD, 0x3F0F5C29, 0x3F11EB85, 0x3F147AE1, 0x3F170A3D,\n0x3F19999A, 0x3F1C28F6, 0x3F1EB852, 0x3F2147AE, 0x3F23D70A, 0x3F266666,\n0x3F28F5C3, 0x3F2B851F, 0x3F2E147B, 0x3F30A3D7, 0x3F333333, 0x3F35C28F,\n0x3F3851EC, 0x3F3AE148, 0x3F3D70A4, 0x3F400000, 0x3F428F5C, 0x3F451EB8,\n0x3F47AE14, 0x3F4A3D71, 0x3F4CCCCD, 0x3F4F5C29, 0x3F51EB85, 0x3F547AE1,\n0x3F570A3D, 0x3F59999A, 0x3F5C28F6, 0x3F5EB852, 0x3F6147AE, 0x3F63D70A,\n0x3F666666, 0x3F68F5C3, 0x3F6B851F, 0x3F6E147B, 0x3F70A3D7, 0x3F733333,\n0x3F75C28F, 0x3F7851EC, 0x3F7AE148, 0x3F7D70A4, 0x3F800000\n};\n\nstatic const unsigned int equalizer_vals_lookup[] = {\n0xC1C00000, 0xC1B80000, 0xC1B00000, 0xC1A80000, 0xC1A00000, 0xC1980000,\n0xC1900000, 0xC1880000, 0xC1800000, 0xC1700000, 0xC1600000, 0xC1500000,\n0xC1400000, 0xC1300000, 0xC1200000, 0xC1100000, 0xC1000000, 0xC0E00000,\n0xC0C00000, 0xC0A00000, 0xC0800000, 0xC0400000, 0xC0000000, 0xBF800000,\n0x00000000, 0x3F800000, 0x40000000, 0x40400000, 0x40800000, 0x40A00000,\n0x40C00000, 0x40E00000, 0x41000000, 0x41100000, 0x41200000, 0x41300000,\n0x41400000, 0x41500000, 0x41600000, 0x41700000, 0x41800000, 0x41880000,\n0x41900000, 0x41980000, 0x41A00000, 0x41A80000, 0x41B00000, 0x41B80000,\n0x41C00000\n};\n\nstatic int tuning_ctl_set(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  const unsigned int *lookup, int idx)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < TUNING_CTLS_COUNT; i++)\n\t\tif (nid == ca0132_tuning_ctls[i].nid)\n\t\t\tgoto found;\n\n\treturn -EINVAL;\nfound:\n\tsnd_hda_power_up(codec);\n\tdspio_set_param(codec, ca0132_tuning_ctls[i].mid, 0x20,\n\t\t\tca0132_tuning_ctls[i].req,\n\t\t\t&(lookup[idx]), sizeof(unsigned int));\n\tsnd_hda_power_down(codec);\n\n\treturn 1;\n}\n\nstatic int tuning_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx = nid - TUNING_CTL_START_NID;\n\n\t*valp = spec->cur_ctl_vals[idx];\n\treturn 0;\n}\n\nstatic int voice_focus_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tint chs = get_amp_channels(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 20;\n\tuinfo->value.integer.max = 180;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int voice_focus_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx;\n\n\tidx = nid - TUNING_CTL_START_NID;\n\t \n\tif (spec->cur_ctl_vals[idx] == *valp)\n\t\treturn 0;\n\n\tspec->cur_ctl_vals[idx] = *valp;\n\n\tidx = *valp - 20;\n\ttuning_ctl_set(codec, nid, voice_focus_vals_lookup, idx);\n\n\treturn 1;\n}\n\nstatic int mic_svm_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tint chs = get_amp_channels(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int mic_svm_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx;\n\n\tidx = nid - TUNING_CTL_START_NID;\n\t \n\tif (spec->cur_ctl_vals[idx] == *valp)\n\t\treturn 0;\n\n\tspec->cur_ctl_vals[idx] = *valp;\n\n\tidx = *valp;\n\ttuning_ctl_set(codec, nid, mic_svm_vals_lookup, idx);\n\n\treturn 0;\n}\n\nstatic int equalizer_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tint chs = get_amp_channels(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 48;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int equalizer_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx;\n\n\tidx = nid - TUNING_CTL_START_NID;\n\t \n\tif (spec->cur_ctl_vals[idx] == *valp)\n\t\treturn 0;\n\n\tspec->cur_ctl_vals[idx] = *valp;\n\n\tidx = *valp;\n\ttuning_ctl_set(codec, nid, equalizer_vals_lookup, idx);\n\n\treturn 1;\n}\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(voice_focus_db_scale, 2000, 100, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(eq_db_scale, -2400, 100, 0);\n\nstatic int add_tuning_control(struct hda_codec *codec,\n\t\t\t\thda_nid_t pnid, hda_nid_t nid,\n\t\t\t\tconst char *name, int dir)\n{\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint type = dir ? HDA_INPUT : HDA_OUTPUT;\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_VOLUME_MONO(namestr, nid, 1, 0, type);\n\n\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\tknew.tlv.c = 0;\n\tknew.tlv.p = 0;\n\tswitch (pnid) {\n\tcase VOICE_FOCUS:\n\t\tknew.info = voice_focus_ctl_info;\n\t\tknew.get = tuning_ctl_get;\n\t\tknew.put = voice_focus_ctl_put;\n\t\tknew.tlv.p = voice_focus_db_scale;\n\t\tbreak;\n\tcase MIC_SVM:\n\t\tknew.info = mic_svm_ctl_info;\n\t\tknew.get = tuning_ctl_get;\n\t\tknew.put = mic_svm_ctl_put;\n\t\tbreak;\n\tcase EQUALIZER:\n\t\tknew.info = equalizer_ctl_info;\n\t\tknew.get = tuning_ctl_get;\n\t\tknew.put = equalizer_ctl_put;\n\t\tknew.tlv.p = eq_db_scale;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tknew.private_value =\n\t\tHDA_COMPOSE_AMP_VAL(nid, 1, 0, type);\n\tsprintf(namestr, \"%s %s Volume\", name, dirstr[dir]);\n\treturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\n}\n\nstatic int add_tuning_ctls(struct hda_codec *codec)\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < TUNING_CTLS_COUNT; i++) {\n\t\terr = add_tuning_control(codec,\n\t\t\t\t\tca0132_tuning_ctls[i].parent_nid,\n\t\t\t\t\tca0132_tuning_ctls[i].nid,\n\t\t\t\t\tca0132_tuning_ctls[i].name,\n\t\t\t\t\tca0132_tuning_ctls[i].direct);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void ca0132_init_tuning_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint i;\n\n\t \n\tspec->cur_ctl_vals[WEDGE_ANGLE - TUNING_CTL_START_NID] = 10;\n\t \n\tspec->cur_ctl_vals[SVM_LEVEL - TUNING_CTL_START_NID] = 74;\n\n\t \n\tfor (i = 2; i < TUNING_CTLS_COUNT; i++)\n\t\tspec->cur_ctl_vals[i] = 24;\n}\n#endif  \n\n \nstatic int ca0132_select_out(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int pin_ctl;\n\tint jack_present;\n\tint auto_jack;\n\tunsigned int tmp;\n\tint err;\n\n\tcodec_dbg(codec, \"ca0132_select_out\\n\");\n\n\tsnd_hda_power_up_pm(codec);\n\n\tauto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\n\n\tif (auto_jack)\n\t\tjack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp);\n\telse\n\t\tjack_present =\n\t\t\tspec->vnode_lswitch[VNID_HP_SEL - VNODE_START_NID];\n\n\tif (jack_present)\n\t\tspec->cur_out_type = HEADPHONE_OUT;\n\telse\n\t\tspec->cur_out_type = SPEAKER_OUT;\n\n\tif (spec->cur_out_type == SPEAKER_OUT) {\n\t\tcodec_dbg(codec, \"ca0132_select_out speaker\\n\");\n\t\t \n\t\ttmp = FLOAT_ONE;\n\t\terr = dspio_set_uint_param(codec, 0x80, 0x04, tmp);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t\t \n\t\ttmp = FLOAT_ONE;\n\t\terr = dspio_set_uint_param(codec, 0x8f, 0x00, tmp);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\t \n\t\tsnd_hda_codec_write(codec, spec->out_pins[1], 0,\n\t\t\t\t    VENDOR_CHIPIO_EAPD_SEL_SET, 0x02);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    AC_VERB_SET_EAPD_BTLENABLE, 0x00);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    VENDOR_CHIPIO_EAPD_SEL_SET, 0x00);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    AC_VERB_SET_EAPD_BTLENABLE, 0x02);\n\n\t\t \n\t\tpin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,\n\t\t\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\tsnd_hda_set_pin_ctl(codec, spec->out_pins[1],\n\t\t\t\t    pin_ctl & ~PIN_HP);\n\t\t \n\t\tpin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,\n\t\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\tsnd_hda_set_pin_ctl(codec, spec->out_pins[0],\n\t\t\t\t    pin_ctl | PIN_OUT);\n\t} else {\n\t\tcodec_dbg(codec, \"ca0132_select_out hp\\n\");\n\t\t \n\t\ttmp = FLOAT_ZERO;\n\t\terr = dspio_set_uint_param(codec, 0x80, 0x04, tmp);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t\t \n\t\ttmp = FLOAT_ZERO;\n\t\terr = dspio_set_uint_param(codec, 0x8f, 0x00, tmp);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\t \n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    VENDOR_CHIPIO_EAPD_SEL_SET, 0x00);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    AC_VERB_SET_EAPD_BTLENABLE, 0x00);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[1], 0,\n\t\t\t\t    VENDOR_CHIPIO_EAPD_SEL_SET, 0x02);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\t\t    AC_VERB_SET_EAPD_BTLENABLE, 0x02);\n\n\t\t \n\t\tpin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,\n\t\t\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\tsnd_hda_set_pin_ctl(codec, spec->out_pins[0],\n\t\t\t\t    pin_ctl & ~PIN_HP);\n\t\t \n\t\tpin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,\n\t\t\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\tsnd_hda_set_pin_ctl(codec, spec->out_pins[1],\n\t\t\t\t    pin_ctl | PIN_HP);\n\t}\n\nexit:\n\tsnd_hda_power_down_pm(codec);\n\n\treturn err < 0 ? err : 0;\n}\n\nstatic int ae5_headphone_gain_set(struct hda_codec *codec, long val);\nstatic int zxr_headphone_gain_set(struct hda_codec *codec, long val);\nstatic int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);\n\nstatic void ae5_mmio_select_out(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tconst struct ae_ca0113_output_set *out_cmds;\n\tunsigned int i;\n\n\tif (ca0132_quirk(spec) == QUIRK_AE5)\n\t\tout_cmds = &ae5_ca0113_output_presets;\n\telse\n\t\tout_cmds = &ae7_ca0113_output_presets;\n\n\tfor (i = 0; i < AE_CA0113_OUT_SET_COMMANDS; i++)\n\t\tca0113_mmio_command_set(codec, out_cmds->group[i],\n\t\t\t\tout_cmds->target[i],\n\t\t\t\tout_cmds->vals[spec->cur_out_type][i]);\n}\n\nstatic int ca0132_alt_set_full_range_speaker(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint quirk = ca0132_quirk(spec);\n\tunsigned int tmp;\n\tint err;\n\n\t \n\tif (spec->channel_cfg_val == SPEAKER_CHANNELS_4_0\n\t\t\t|| spec->channel_cfg_val == SPEAKER_CHANNELS_2_0)\n\t\treturn 0;\n\n\t \n\ttmp = spec->speaker_range_val[0] ? FLOAT_ZERO : FLOAT_ONE;\n\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_FULL_RANGE_FRONT_L_R, tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ttmp = spec->speaker_range_val[1] ? FLOAT_ZERO : FLOAT_ONE;\n\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_FULL_RANGE_CENTER_LFE, tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_FULL_RANGE_REAR_L_R, tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (quirk == QUIRK_AE5 || quirk == QUIRK_AE7) {\n\t\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\t\tSPEAKER_FULL_RANGE_SURROUND_L_R, FLOAT_ONE);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_surround_set_bass_redirection(struct hda_codec *codec,\n\t\tbool val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint err;\n\n\tif (val && spec->channel_cfg_val != SPEAKER_CHANNELS_4_0 &&\n\t\t\tspec->channel_cfg_val != SPEAKER_CHANNELS_2_0)\n\t\ttmp = FLOAT_ONE;\n\telse\n\t\ttmp = FLOAT_ZERO;\n\n\terr = dspio_set_uint_param(codec, 0x96, SPEAKER_BASS_REDIRECT, tmp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (tmp) {\n\t\ttmp = float_xbass_xover_lookup[spec->xbass_xover_freq];\n\t\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\t\tSPEAKER_BASS_REDIRECT_XOVER_FREQ, tmp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ca0132_alt_select_out_get_quirk_data(struct hda_codec *codec,\n\t\tconst struct ca0132_alt_out_set_quirk_data **quirk_data)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint quirk = ca0132_quirk(spec);\n\tunsigned int i;\n\n\t*quirk_data = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(quirk_out_set_data); i++) {\n\t\tif (quirk_out_set_data[i].quirk_id == quirk) {\n\t\t\t*quirk_data = &quirk_out_set_data[i];\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ca0132_alt_select_out_quirk_set(struct hda_codec *codec)\n{\n\tconst struct ca0132_alt_out_set_quirk_data *quirk_data;\n\tconst struct ca0132_alt_out_set_info *out_info;\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int i, gpio_data;\n\tint err;\n\n\tca0132_alt_select_out_get_quirk_data(codec, &quirk_data);\n\tif (!quirk_data)\n\t\treturn 0;\n\n\tout_info = &quirk_data->out_set_info[spec->cur_out_type];\n\tif (quirk_data->is_ae_series)\n\t\tae5_mmio_select_out(codec);\n\n\tif (out_info->has_hda_gpio) {\n\t\tgpio_data = snd_hda_codec_read(codec, codec->core.afg, 0,\n\t\t\t\tAC_VERB_GET_GPIO_DATA, 0);\n\n\t\tif (out_info->hda_gpio_set)\n\t\t\tgpio_data |= (1 << out_info->hda_gpio_pin);\n\t\telse\n\t\t\tgpio_data &= ~(1 << out_info->hda_gpio_pin);\n\n\t\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t\t    AC_VERB_SET_GPIO_DATA, gpio_data);\n\t}\n\n\tif (out_info->mmio_gpio_count) {\n\t\tfor (i = 0; i < out_info->mmio_gpio_count; i++) {\n\t\t\tca0113_mmio_gpio_set(codec, out_info->mmio_gpio_pin[i],\n\t\t\t\t\tout_info->mmio_gpio_set[i]);\n\t\t}\n\t}\n\n\tif (out_info->scp_cmds_count) {\n\t\tfor (i = 0; i < out_info->scp_cmds_count; i++) {\n\t\t\terr = dspio_set_uint_param(codec,\n\t\t\t\t\tout_info->scp_cmd_mid[i],\n\t\t\t\t\tout_info->scp_cmd_req[i],\n\t\t\t\t\tout_info->scp_cmd_val[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tchipio_set_control_param(codec, 0x0d, out_info->dac2port);\n\n\tif (out_info->has_chipio_write) {\n\t\tchipio_write(codec, out_info->chipio_write_addr,\n\t\t\t\tout_info->chipio_write_data);\n\t}\n\n\tif (quirk_data->has_headphone_gain) {\n\t\tif (spec->cur_out_type != HEADPHONE_OUT) {\n\t\t\tif (quirk_data->is_ae_series)\n\t\t\t\tae5_headphone_gain_set(codec, 2);\n\t\t\telse\n\t\t\t\tzxr_headphone_gain_set(codec, 0);\n\t\t} else {\n\t\t\tif (quirk_data->is_ae_series)\n\t\t\t\tae5_headphone_gain_set(codec,\n\t\t\t\t\t\tspec->ae5_headphone_gain_val);\n\t\t\telse\n\t\t\t\tzxr_headphone_gain_set(codec,\n\t\t\t\t\t\tspec->zxr_gain_set);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ca0132_set_out_node_pincfg(struct hda_codec *codec, hda_nid_t nid,\n\t\tbool out_enable, bool hp_enable)\n{\n\tunsigned int pin_ctl;\n\n\tpin_ctl = snd_hda_codec_read(codec, nid, 0,\n\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\n\tpin_ctl = hp_enable ? pin_ctl | PIN_HP_AMP : pin_ctl & ~PIN_HP_AMP;\n\tpin_ctl = out_enable ? pin_ctl | PIN_OUT : pin_ctl & ~PIN_OUT;\n\tsnd_hda_set_pin_ctl(codec, nid, pin_ctl);\n}\n\n \nstatic int ca0132_alt_select_out(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp, outfx_set;\n\tint jack_present;\n\tint auto_jack;\n\tint err;\n\t \n\thda_nid_t headphone_nid = spec->out_pins[1];\n\n\tcodec_dbg(codec, \"%s\\n\", __func__);\n\n\tsnd_hda_power_up_pm(codec);\n\n\tauto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\n\n\t \n\tif (auto_jack) {\n\t\tjack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||\n\t\t\t   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);\n\n\t\tif (jack_present)\n\t\t\tspec->cur_out_type = HEADPHONE_OUT;\n\t\telse\n\t\t\tspec->cur_out_type = SPEAKER_OUT;\n\t} else\n\t\tspec->cur_out_type = spec->out_enum_val;\n\n\toutfx_set = spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID];\n\n\t \n\terr = dspio_set_uint_param(codec, 0x96, SPEAKER_TUNING_MUTE, FLOAT_ONE);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tif (ca0132_alt_select_out_quirk_set(codec) < 0)\n\t\tgoto exit;\n\n\tswitch (spec->cur_out_type) {\n\tcase SPEAKER_OUT:\n\t\tcodec_dbg(codec, \"%s speaker\\n\", __func__);\n\n\t\t \n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\tAC_VERB_SET_EAPD_BTLENABLE, 0x01);\n\n\t\t \n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[1], 0, 0);\n\t\t \n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[0], 1, 0);\n\t\t \n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[2], 1, 0);\n\t\t \n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[3], 1, 0);\n\n\t\t \n\t\tif (!outfx_set && spec->channel_cfg_val == SPEAKER_CHANNELS_2_0)\n\t\t\ttmp = FLOAT_EIGHT;\n\t\telse\n\t\t\ttmp = speaker_channel_cfgs[spec->channel_cfg_val].val;\n\n\t\terr = dspio_set_uint_param(codec, 0x80, 0x04, tmp);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\tbreak;\n\tcase HEADPHONE_OUT:\n\t\tcodec_dbg(codec, \"%s hp\\n\", __func__);\n\t\tsnd_hda_codec_write(codec, spec->out_pins[0], 0,\n\t\t\tAC_VERB_SET_EAPD_BTLENABLE, 0x00);\n\n\t\t \n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[0], 0, 0);\n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[2], 0, 0);\n\t\tca0132_set_out_node_pincfg(codec, spec->out_pins[3], 0, 0);\n\n\t\t \n\t\tif (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))\n\t\t\theadphone_nid = spec->out_pins[2];\n\t\telse if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))\n\t\t\theadphone_nid = spec->out_pins[1];\n\n\t\tca0132_set_out_node_pincfg(codec, headphone_nid, 1, 1);\n\n\t\tif (outfx_set)\n\t\t\terr = dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);\n\t\telse\n\t\t\terr = dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);\n\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t\tbreak;\n\t}\n\t \n\tif (outfx_set)\n\t\tca0132_effects_set(codec, X_BASS,\n\t\t\tspec->effects_switch[X_BASS - EFFECT_START_NID]);\n\n\t \n\terr = dspio_set_uint_param(codec, 0x8f, 0x01, FLOAT_ZERO);\n\tif (err < 0)\n\t\tgoto exit;\n\n\t \n\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_TUNING_USE_SPEAKER_EQ, FLOAT_ZERO);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tif (spec->cur_out_type == SPEAKER_OUT)\n\t\terr = ca0132_alt_surround_set_bass_redirection(codec,\n\t\t\t\tspec->bass_redirection_val);\n\telse\n\t\terr = ca0132_alt_surround_set_bass_redirection(codec, 0);\n\n\t \n\terr = dspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_TUNING_MUTE, FLOAT_ZERO);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tif (spec->cur_out_type == SPEAKER_OUT) {\n\t\terr = ca0132_alt_set_full_range_speaker(codec);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\tsnd_hda_power_down_pm(codec);\n\n\treturn err < 0 ? err : 0;\n}\n\nstatic void ca0132_unsol_hp_delayed(struct work_struct *work)\n{\n\tstruct ca0132_spec *spec = container_of(\n\t\tto_delayed_work(work), struct ca0132_spec, unsol_hp_work);\n\tstruct hda_jack_tbl *jack;\n\n\tif (ca0132_use_alt_functions(spec))\n\t\tca0132_alt_select_out(spec->codec);\n\telse\n\t\tca0132_select_out(spec->codec);\n\n\tjack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);\n\tif (jack) {\n\t\tjack->block_report = 0;\n\t\tsnd_hda_jack_report_sync(spec->codec);\n\t}\n}\n\nstatic void ca0132_set_dmic(struct hda_codec *codec, int enable);\nstatic int ca0132_mic_boost_set(struct hda_codec *codec, long val);\nstatic void resume_mic1(struct hda_codec *codec, unsigned int oldval);\nstatic int stop_mic1(struct hda_codec *codec);\nstatic int ca0132_cvoice_switch_set(struct hda_codec *codec);\nstatic int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val);\n\n \nstatic int ca0132_set_vipsource(struct hda_codec *codec, int val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn 0;\n\n\t \n\tif (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||\n\t    (val == 0)) {\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\t\tif (spec->cur_mic_type == DIGITAL_MIC)\n\t\t\ttmp = FLOAT_TWO;\n\t\telse\n\t\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\t\ttmp = FLOAT_ZERO;\n\t\tdspio_set_uint_param(codec, 0x80, 0x05, tmp);\n\t} else {\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);\n\t\tif (spec->cur_mic_type == DIGITAL_MIC)\n\t\t\ttmp = FLOAT_TWO;\n\t\telse\n\t\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x05, tmp);\n\t\tmsleep(20);\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);\n\t}\n\n\treturn 1;\n}\n\nstatic int ca0132_alt_set_vipsource(struct hda_codec *codec, int val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"%s\\n\", __func__);\n\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\n\t \n\tif (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||\n\t    (val == 0) || spec->in_enum_val == REAR_LINE_IN) {\n\t\tcodec_dbg(codec, \"%s: off.\", __func__);\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);\n\n\t\ttmp = FLOAT_ZERO;\n\t\tdspio_set_uint_param(codec, 0x80, 0x05, tmp);\n\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\t\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\n\n\t\tif (spec->in_enum_val == REAR_LINE_IN)\n\t\t\ttmp = FLOAT_ZERO;\n\t\telse {\n\t\t\tif (ca0132_quirk(spec) == QUIRK_SBZ)\n\t\t\t\ttmp = FLOAT_THREE;\n\t\t\telse\n\t\t\t\ttmp = FLOAT_ONE;\n\t\t}\n\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t} else {\n\t\tcodec_dbg(codec, \"%s: on.\", __func__);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);\n\t\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\t\tchipio_set_conn_rate(codec, 0x0F, SR_16_000);\n\n\t\tif (spec->effects_switch[VOICE_FOCUS - EFFECT_START_NID])\n\t\t\ttmp = FLOAT_TWO;\n\t\telse\n\t\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x05, tmp);\n\n\t\tmsleep(20);\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);\n\t}\n\n\tchipio_set_stream_control(codec, 0x03, 1);\n\tchipio_set_stream_control(codec, 0x04, 1);\n\n\treturn 1;\n}\n\n \nstatic int ca0132_select_mic(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint jack_present;\n\tint auto_jack;\n\n\tcodec_dbg(codec, \"ca0132_select_mic\\n\");\n\n\tsnd_hda_power_up_pm(codec);\n\n\tauto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];\n\n\tif (auto_jack)\n\t\tjack_present = snd_hda_jack_detect(codec, spec->unsol_tag_amic1);\n\telse\n\t\tjack_present =\n\t\t\tspec->vnode_lswitch[VNID_AMIC1_SEL - VNODE_START_NID];\n\n\tif (jack_present)\n\t\tspec->cur_mic_type = LINE_MIC_IN;\n\telse\n\t\tspec->cur_mic_type = DIGITAL_MIC;\n\n\tif (spec->cur_mic_type == DIGITAL_MIC) {\n\t\t \n\t\tchipio_set_conn_rate(codec, MEM_CONNID_DMIC, SR_32_000);\n\t\tca0132_set_dmic(codec, 1);\n\t\tca0132_mic_boost_set(codec, 0);\n\t\t \n\t\tca0132_effects_set(codec, VOICE_FOCUS,\n\t\t\t\t   spec->effects_switch\n\t\t\t\t   [VOICE_FOCUS - EFFECT_START_NID]);\n\t} else {\n\t\t \n\t\tchipio_set_conn_rate(codec, MEM_CONNID_DMIC, SR_96_000);\n\t\tca0132_set_dmic(codec, 0);\n\t\tca0132_mic_boost_set(codec, spec->cur_mic_boost);\n\t\t \n\t\tca0132_effects_set(codec, VOICE_FOCUS, 0);\n\t}\n\n\tsnd_hda_power_down_pm(codec);\n\n\treturn 0;\n}\n\n \nstatic int ca0132_alt_select_in(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\tcodec_dbg(codec, \"%s\\n\", __func__);\n\n\tsnd_hda_power_up_pm(codec);\n\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\n\tspec->cur_mic_type = spec->in_enum_val;\n\n\tswitch (spec->cur_mic_type) {\n\tcase REAR_MIC:\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\tcase QUIRK_R3D:\n\t\t\tca0113_mmio_gpio_set(codec, 0, false);\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tbreak;\n\t\tcase QUIRK_ZXR:\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tbreak;\n\t\tcase QUIRK_R3DI:\n\t\t\tr3di_gpio_mic_set(codec, R3DI_REAR_MIC);\n\t\t\ttmp = FLOAT_ONE;\n\t\t\tbreak;\n\t\tcase QUIRK_AE5:\n\t\t\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tbreak;\n\t\tcase QUIRK_AE7:\n\t\t\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN2,\n\t\t\t\t\tSR_96_000);\n\t\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT2,\n\t\t\t\t\tSR_96_000);\n\t\t\tdspio_set_uint_param(codec, 0x80, 0x01, FLOAT_ZERO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = FLOAT_ONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\t\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\tchipio_set_stream_control(codec, 0x03, 1);\n\t\tchipio_set_stream_control(codec, 0x04, 1);\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\t\tchipio_write(codec, 0x18B098, 0x0000000C);\n\t\t\tchipio_write(codec, 0x18B09C, 0x0000000C);\n\t\t\tbreak;\n\t\tcase QUIRK_ZXR:\n\t\t\tchipio_write(codec, 0x18B098, 0x0000000C);\n\t\t\tchipio_write(codec, 0x18B09C, 0x000000CC);\n\t\t\tbreak;\n\t\tcase QUIRK_AE5:\n\t\t\tchipio_write(codec, 0x18B098, 0x0000000C);\n\t\t\tchipio_write(codec, 0x18B09C, 0x0000004C);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);\n\t\tbreak;\n\tcase REAR_LINE_IN:\n\t\tca0132_mic_boost_set(codec, 0);\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\tcase QUIRK_R3D:\n\t\t\tca0113_mmio_gpio_set(codec, 0, false);\n\t\t\tbreak;\n\t\tcase QUIRK_R3DI:\n\t\t\tr3di_gpio_mic_set(codec, R3DI_REAR_MIC);\n\t\t\tbreak;\n\t\tcase QUIRK_AE5:\n\t\t\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);\n\t\t\tbreak;\n\t\tcase QUIRK_AE7:\n\t\t\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x3f);\n\t\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN2,\n\t\t\t\t\tSR_96_000);\n\t\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT2,\n\t\t\t\t\tSR_96_000);\n\t\t\tdspio_set_uint_param(codec, 0x80, 0x01, FLOAT_ZERO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\t\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\n\t\tif (ca0132_quirk(spec) == QUIRK_AE7)\n\t\t\ttmp = FLOAT_THREE;\n\t\telse\n\t\t\ttmp = FLOAT_ZERO;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\tcase QUIRK_AE5:\n\t\t\tchipio_write(codec, 0x18B098, 0x00000000);\n\t\t\tchipio_write(codec, 0x18B09C, 0x00000000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tchipio_set_stream_control(codec, 0x03, 1);\n\t\tchipio_set_stream_control(codec, 0x04, 1);\n\t\tbreak;\n\tcase FRONT_MIC:\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\tcase QUIRK_R3D:\n\t\t\tca0113_mmio_gpio_set(codec, 0, true);\n\t\t\tca0113_mmio_gpio_set(codec, 5, false);\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tbreak;\n\t\tcase QUIRK_R3DI:\n\t\t\tr3di_gpio_mic_set(codec, R3DI_FRONT_MIC);\n\t\t\ttmp = FLOAT_ONE;\n\t\t\tbreak;\n\t\tcase QUIRK_AE5:\n\t\t\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x3f);\n\t\t\ttmp = FLOAT_THREE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = FLOAT_ONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\t\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\tchipio_set_stream_control(codec, 0x03, 1);\n\t\tchipio_set_stream_control(codec, 0x04, 1);\n\n\t\tswitch (ca0132_quirk(spec)) {\n\t\tcase QUIRK_SBZ:\n\t\t\tchipio_write(codec, 0x18B098, 0x0000000C);\n\t\t\tchipio_write(codec, 0x18B09C, 0x000000CC);\n\t\t\tbreak;\n\t\tcase QUIRK_AE5:\n\t\t\tchipio_write(codec, 0x18B098, 0x0000000C);\n\t\t\tchipio_write(codec, 0x18B09C, 0x0000004C);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);\n\t\tbreak;\n\t}\n\tca0132_cvoice_switch_set(codec);\n\n\tsnd_hda_power_down_pm(codec);\n\treturn 0;\n}\n\n \nstatic bool ca0132_is_vnode_effective(struct hda_codec *codec,\n\t\t\t\t     hda_nid_t vnid,\n\t\t\t\t     hda_nid_t *shared_nid)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid;\n\n\tswitch (vnid) {\n\tcase VNID_SPK:\n\t\tnid = spec->shared_out_nid;\n\t\tbreak;\n\tcase VNID_MIC:\n\t\tnid = spec->shared_mic_nid;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (shared_nid)\n\t\t*shared_nid = nid;\n\n\treturn true;\n}\n\n \nstatic int ca0132_voicefx_set(struct hda_codec *codec, int enable)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\t \n\tif (enable) {\n\t\ttmp = spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ?\n\t\t\tFLOAT_ONE : FLOAT_ZERO;\n\t} else {\n\t\ttmp = FLOAT_ZERO;\n\t}\n\n\tdspio_set_uint_param(codec, ca0132_voicefx.mid,\n\t\t\t     ca0132_voicefx.reqs[0], tmp);\n\n\treturn 1;\n}\n\n \nstatic int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int on, tmp, channel_cfg;\n\tint num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\n\tint err = 0;\n\tint idx = nid - EFFECT_START_NID;\n\n\tif ((idx < 0) || (idx >= num_fx))\n\t\treturn 0;  \n\n\t \n\tif ((nid >= OUT_EFFECT_START_NID) && (nid < OUT_EFFECT_END_NID)) {\n\t\t \n\t\tif (!spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])\n\t\t\tval = 0;\n\t\tif (spec->cur_out_type == SPEAKER_OUT && nid == X_BASS) {\n\t\t\tchannel_cfg = spec->channel_cfg_val;\n\t\t\tif (channel_cfg != SPEAKER_CHANNELS_2_0 &&\n\t\t\t\t\tchannel_cfg != SPEAKER_CHANNELS_4_0)\n\t\t\t\tval = 0;\n\t\t}\n\t}\n\n\t \n\tif ((nid >= IN_EFFECT_START_NID) && (nid < IN_EFFECT_END_NID)) {\n\t\t \n\t\tif (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID])\n\t\t\tval = 0;\n\n\t\t \n\t\tif ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))\n\t\t\tval = 0;\n\n\t\t \n\t\tif ((nid == VOICE_FOCUS) && ca0132_use_pci_mmio(spec)\n\t\t\t\t&& (spec->cur_mic_type != REAR_LINE_IN)) {\n\t\t\tif (spec->effects_switch[CRYSTAL_VOICE -\n\t\t\t\t\t\t EFFECT_START_NID]) {\n\n\t\t\t\tif (spec->effects_switch[VOICE_FOCUS -\n\t\t\t\t\t\t\t EFFECT_START_NID]) {\n\t\t\t\t\ttmp = FLOAT_TWO;\n\t\t\t\t\tval = 1;\n\t\t\t\t} else\n\t\t\t\t\ttmp = FLOAT_ONE;\n\n\t\t\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((nid == NOISE_REDUCTION) && ca0132_use_pci_mmio(spec)\n\t\t\t\t&& (spec->cur_mic_type != REAR_LINE_IN)) {\n\t\t\tif (spec->effects_switch[CRYSTAL_VOICE -\n\t\t\t\t\t\t EFFECT_START_NID]) {\n\t\t\t\tif (spec->effects_switch[NOISE_REDUCTION -\n\t\t\t\t\t\t\t EFFECT_START_NID])\n\t\t\t\t\ttmp = FLOAT_ONE;\n\t\t\t\telse\n\t\t\t\t\ttmp = FLOAT_ZERO;\n\t\t\t} else\n\t\t\t\ttmp = FLOAT_ZERO;\n\n\t\t\tdspio_set_uint_param(codec, 0x47, 0x00, tmp);\n\t\t}\n\n\t\t \n\t\tif (ca0132_use_alt_functions(spec) &&\n\t\t\t\tspec->in_enum_val == REAR_LINE_IN)\n\t\t\tval = 0;\n\t}\n\n\tcodec_dbg(codec, \"ca0132_effect_set: nid=0x%x, val=%ld\\n\",\n\t\t    nid, val);\n\n\ton = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;\n\terr = dspio_set_uint_param(codec, ca0132_effects[idx].mid,\n\t\t\t\t   ca0132_effects[idx].reqs[0], on);\n\n\tif (err < 0)\n\t\treturn 0;  \n\n\treturn 1;\n}\n\n \nstatic int ca0132_pe_switch_set(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid;\n\tint i, ret = 0;\n\n\tcodec_dbg(codec, \"ca0132_pe_switch_set: val=%ld\\n\",\n\t\t    spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);\n\n\tif (ca0132_use_alt_functions(spec))\n\t\tca0132_alt_select_out(codec);\n\n\ti = OUT_EFFECT_START_NID - EFFECT_START_NID;\n\tnid = OUT_EFFECT_START_NID;\n\t \n\tfor (; nid < OUT_EFFECT_END_NID; nid++, i++)\n\t\tret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);\n\n\treturn ret;\n}\n\n \nstatic int stop_mic1(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int oldval = snd_hda_codec_read(codec, spec->adcs[0], 0,\n\t\t\t\t\t\t AC_VERB_GET_CONV, 0);\n\tif (oldval != 0)\n\t\tsnd_hda_codec_write(codec, spec->adcs[0], 0,\n\t\t\t\t    AC_VERB_SET_CHANNEL_STREAMID,\n\t\t\t\t    0);\n\treturn oldval;\n}\n\n \nstatic void resume_mic1(struct hda_codec *codec, unsigned int oldval)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\t \n\tif (oldval != 0)\n\t\tsnd_hda_codec_write(codec, spec->adcs[0], 0,\n\t\t\t\t    AC_VERB_SET_CHANNEL_STREAMID,\n\t\t\t\t    oldval);\n}\n\n \nstatic int ca0132_cvoice_switch_set(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid;\n\tint i, ret = 0;\n\tunsigned int oldval;\n\n\tcodec_dbg(codec, \"ca0132_cvoice_switch_set: val=%ld\\n\",\n\t\t    spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);\n\n\ti = IN_EFFECT_START_NID - EFFECT_START_NID;\n\tnid = IN_EFFECT_START_NID;\n\t \n\tfor (; nid < IN_EFFECT_END_NID; nid++, i++)\n\t\tret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);\n\n\t \n\tret |= ca0132_voicefx_set(codec, (spec->voicefx_val ? 1 : 0));\n\n\t \n\toldval = stop_mic1(codec);\n\tif (ca0132_use_alt_functions(spec))\n\t\tret |= ca0132_alt_set_vipsource(codec, 1);\n\telse\n\t\tret |= ca0132_set_vipsource(codec, 1);\n\tresume_mic1(codec, oldval);\n\treturn ret;\n}\n\nstatic int ca0132_mic_boost_set(struct hda_codec *codec, long val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint ret = 0;\n\n\tif (val)  \n\t\tret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,\n\t\t\t\t\tHDA_INPUT, 0, HDA_AMP_VOLMASK, 3);\n\telse  \n\t\tret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,\n\t\t\t\t\tHDA_INPUT, 0, HDA_AMP_VOLMASK, 0);\n\n\treturn ret;\n}\n\nstatic int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint ret = 0;\n\n\tret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,\n\t\t\t\tHDA_INPUT, 0, HDA_AMP_VOLMASK, val);\n\treturn ret;\n}\n\nstatic int ae5_headphone_gain_set(struct hda_codec *codec, long val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tca0113_mmio_command_set(codec, 0x48, 0x11 + i,\n\t\t\t\tae5_headphone_gain_presets[val].vals[i]);\n\treturn 0;\n}\n\n \nstatic int zxr_headphone_gain_set(struct hda_codec *codec, long val)\n{\n\tca0113_mmio_gpio_set(codec, 1, val);\n\n\treturn 0;\n}\n\nstatic int ca0132_vnode_switch_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\thda_nid_t shared_nid = 0;\n\tbool effective;\n\tint ret = 0;\n\tstruct ca0132_spec *spec = codec->spec;\n\tint auto_jack;\n\n\tif (nid == VNID_HP_SEL) {\n\t\tauto_jack =\n\t\t\tspec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\n\t\tif (!auto_jack) {\n\t\t\tif (ca0132_use_alt_functions(spec))\n\t\t\t\tca0132_alt_select_out(codec);\n\t\t\telse\n\t\t\t\tca0132_select_out(codec);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (nid == VNID_AMIC1_SEL) {\n\t\tauto_jack =\n\t\t\tspec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];\n\t\tif (!auto_jack)\n\t\t\tca0132_select_mic(codec);\n\t\treturn 1;\n\t}\n\n\tif (nid == VNID_HP_ASEL) {\n\t\tif (ca0132_use_alt_functions(spec))\n\t\t\tca0132_alt_select_out(codec);\n\t\telse\n\t\t\tca0132_select_out(codec);\n\t\treturn 1;\n\t}\n\n\tif (nid == VNID_AMIC1_ASEL) {\n\t\tca0132_select_mic(codec);\n\t\treturn 1;\n\t}\n\n\t \n\teffective = ca0132_is_vnode_effective(codec, nid, &shared_nid);\n\tif (effective) {\n\t\tint dir = get_amp_direction(kcontrol);\n\t\tint ch = get_amp_channels(kcontrol);\n\t\tunsigned long pval;\n\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,\n\t\t\t\t\t\t\t\t0, dir);\n\t\tret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t}\n\n\treturn ret;\n}\n \n\nstatic void ca0132_alt_bass_redirection_xover_set(struct hda_codec *codec,\n\t\tlong idx)\n{\n\tsnd_hda_power_up(codec);\n\n\tdspio_set_param(codec, 0x96, 0x20, SPEAKER_BASS_REDIRECT_XOVER_FREQ,\n\t\t\t&(float_xbass_xover_lookup[idx]), sizeof(unsigned int));\n\n\tsnd_hda_power_down(codec);\n}\n\n \n\n \n\nstatic int ca0132_alt_slider_ctl_set(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  const unsigned int *lookup, int idx)\n{\n\tint i = 0;\n\tunsigned int y;\n\t \n\tif (nid == X_BASS)\n\t\ty = 2;\n\telse\n\t\ty = 1;\n\n\tsnd_hda_power_up(codec);\n\tif (nid == XBASS_XOVER) {\n\t\tfor (i = 0; i < OUT_EFFECTS_COUNT; i++)\n\t\t\tif (ca0132_effects[i].nid == X_BASS)\n\t\t\t\tbreak;\n\n\t\tdspio_set_param(codec, ca0132_effects[i].mid, 0x20,\n\t\t\t\tca0132_effects[i].reqs[1],\n\t\t\t\t&(lookup[idx - 1]), sizeof(unsigned int));\n\t} else {\n\t\t \n\t\tfor (i = 0; i < OUT_EFFECTS_COUNT; i++)\n\t\t\tif (nid == ca0132_effects[i].nid)\n\t\t\t\tbreak;\n\n\t\tdspio_set_param(codec, ca0132_effects[i].mid, 0x20,\n\t\t\t\tca0132_effects[i].reqs[y],\n\t\t\t\t&(lookup[idx]), sizeof(unsigned int));\n\t}\n\n\tsnd_hda_power_down(codec);\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_xbass_xover_slider_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tlong *valp = ucontrol->value.integer.value;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\n\tif (nid == BASS_REDIRECTION_XOVER)\n\t\t*valp = spec->bass_redirect_xover_freq;\n\telse\n\t\t*valp = spec->xbass_xover_freq;\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_slider_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx = nid - OUT_EFFECT_START_NID;\n\n\t*valp = spec->fx_ctl_val[idx];\n\treturn 0;\n}\n\n \nstatic int ca0132_alt_xbass_xover_slider_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 1;\n\tuinfo->value.integer.max = 100;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_effect_slider_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tint chs = get_amp_channels(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 100;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_xbass_xover_slider_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tlong *cur_val;\n\tint idx;\n\n\tif (nid == BASS_REDIRECTION_XOVER)\n\t\tcur_val = &spec->bass_redirect_xover_freq;\n\telse\n\t\tcur_val = &spec->xbass_xover_freq;\n\n\t \n\tif (*cur_val == *valp)\n\t\treturn 0;\n\n\t*cur_val = *valp;\n\n\tidx = *valp;\n\tif (nid == BASS_REDIRECTION_XOVER)\n\t\tca0132_alt_bass_redirection_xover_set(codec, *cur_val);\n\telse\n\t\tca0132_alt_slider_ctl_set(codec, nid, float_xbass_xover_lookup, idx);\n\n\treturn 0;\n}\n\nstatic int ca0132_alt_effect_slider_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint idx;\n\n\tidx = nid - EFFECT_START_NID;\n\t \n\tif (spec->fx_ctl_val[idx] == *valp)\n\t\treturn 0;\n\n\tspec->fx_ctl_val[idx] = *valp;\n\n\tidx = *valp;\n\tca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);\n\n\treturn 0;\n}\n\n\n \n#define MIC_BOOST_NUM_OF_STEPS 4\n#define MIC_BOOST_ENUM_MAX_STRLEN 10\n\nstatic int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tchar *sfx = \"dB\";\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;\n\tif (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)\n\t\tuinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;\n\tsprintf(namestr, \"%d %s\", (uinfo->value.enumerated.item * 10), sfx);\n\tstrcpy(uinfo->value.enumerated.name, namestr);\n\treturn 0;\n}\n\nstatic int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;\n\treturn 0;\n}\n\nstatic int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = MIC_BOOST_NUM_OF_STEPS;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_alt_mic_boost: boost=%d\\n\",\n\t\t    sel);\n\n\tspec->mic_boost_enum_val = sel;\n\n\tif (spec->in_enum_val != REAR_LINE_IN)\n\t\tca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);\n\n\treturn 1;\n}\n\n \n#define AE5_HEADPHONE_GAIN_MAX 3\nstatic int ae5_headphone_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tchar *sfx = \" Ohms)\";\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = AE5_HEADPHONE_GAIN_MAX;\n\tif (uinfo->value.enumerated.item >= AE5_HEADPHONE_GAIN_MAX)\n\t\tuinfo->value.enumerated.item = AE5_HEADPHONE_GAIN_MAX - 1;\n\tsprintf(namestr, \"%s %s\",\n\t\tae5_headphone_gain_presets[uinfo->value.enumerated.item].name,\n\t\tsfx);\n\tstrcpy(uinfo->value.enumerated.name, namestr);\n\treturn 0;\n}\n\nstatic int ae5_headphone_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->ae5_headphone_gain_val;\n\treturn 0;\n}\n\nstatic int ae5_headphone_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = AE5_HEADPHONE_GAIN_MAX;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ae5_headphone_gain: boost=%d\\n\",\n\t\t    sel);\n\n\tspec->ae5_headphone_gain_val = sel;\n\n\tif (spec->out_enum_val == HEADPHONE_OUT)\n\t\tae5_headphone_gain_set(codec, spec->ae5_headphone_gain_val);\n\n\treturn 1;\n}\n\n \n#define AE5_SOUND_FILTER_MAX 3\n\nstatic int ae5_sound_filter_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = AE5_SOUND_FILTER_MAX;\n\tif (uinfo->value.enumerated.item >= AE5_SOUND_FILTER_MAX)\n\t\tuinfo->value.enumerated.item = AE5_SOUND_FILTER_MAX - 1;\n\tsprintf(namestr, \"%s\",\n\t\t\tae5_filter_presets[uinfo->value.enumerated.item].name);\n\tstrcpy(uinfo->value.enumerated.name, namestr);\n\treturn 0;\n}\n\nstatic int ae5_sound_filter_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->ae5_filter_val;\n\treturn 0;\n}\n\nstatic int ae5_sound_filter_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = AE5_SOUND_FILTER_MAX;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ae5_sound_filter: %s\\n\",\n\t\t\tae5_filter_presets[sel].name);\n\n\tspec->ae5_filter_val = sel;\n\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07,\n\t\t\tae5_filter_presets[sel].val);\n\n\treturn 1;\n}\n\n \nstatic int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;\n\tif (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)\n\t\tuinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\t\tin_src_str[uinfo->value.enumerated.item]);\n\treturn 0;\n}\n\nstatic int ca0132_alt_input_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->in_enum_val;\n\treturn 0;\n}\n\nstatic int ca0132_alt_input_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = IN_SRC_NUM_OF_INPUTS;\n\n\t \n\tif (ca0132_quirk(spec) == QUIRK_AE7)\n\t\titems = 2;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_alt_input_select: sel=%d, preset=%s\\n\",\n\t\t    sel, in_src_str[sel]);\n\n\tspec->in_enum_val = sel;\n\n\tca0132_alt_select_in(codec);\n\n\treturn 1;\n}\n\n \nstatic int ca0132_alt_output_select_get_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = NUM_OF_OUTPUTS;\n\tif (uinfo->value.enumerated.item >= NUM_OF_OUTPUTS)\n\t\tuinfo->value.enumerated.item = NUM_OF_OUTPUTS - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\t\tout_type_str[uinfo->value.enumerated.item]);\n\treturn 0;\n}\n\nstatic int ca0132_alt_output_select_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->out_enum_val;\n\treturn 0;\n}\n\nstatic int ca0132_alt_output_select_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = NUM_OF_OUTPUTS;\n\tunsigned int auto_jack;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_alt_output_select: sel=%d, preset=%s\\n\",\n\t\t    sel, out_type_str[sel]);\n\n\tspec->out_enum_val = sel;\n\n\tauto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\n\n\tif (!auto_jack)\n\t\tca0132_alt_select_out(codec);\n\n\treturn 1;\n}\n\n \nstatic int ca0132_alt_speaker_channel_cfg_get_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int items = SPEAKER_CHANNEL_CFG_COUNT;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = items;\n\tif (uinfo->value.enumerated.item >= items)\n\t\tuinfo->value.enumerated.item = items - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\t\tspeaker_channel_cfgs[uinfo->value.enumerated.item].name);\n\treturn 0;\n}\n\nstatic int ca0132_alt_speaker_channel_cfg_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->channel_cfg_val;\n\treturn 0;\n}\n\nstatic int ca0132_alt_speaker_channel_cfg_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = SPEAKER_CHANNEL_CFG_COUNT;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_alt_speaker_channels: sel=%d, channels=%s\\n\",\n\t\t    sel, speaker_channel_cfgs[sel].name);\n\n\tspec->channel_cfg_val = sel;\n\n\tif (spec->out_enum_val == SPEAKER_OUT)\n\t\tca0132_alt_select_out(codec);\n\n\treturn 1;\n}\n\n \n#define NUM_OF_SVM_SETTINGS 3\nstatic const char *const out_svm_set_enum_str[3] = {\"Normal\", \"Loud\", \"Night\" };\n\nstatic int ca0132_alt_svm_setting_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = NUM_OF_SVM_SETTINGS;\n\tif (uinfo->value.enumerated.item >= NUM_OF_SVM_SETTINGS)\n\t\tuinfo->value.enumerated.item = NUM_OF_SVM_SETTINGS - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\t\tout_svm_set_enum_str[uinfo->value.enumerated.item]);\n\treturn 0;\n}\n\nstatic int ca0132_alt_svm_setting_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->smart_volume_setting;\n\treturn 0;\n}\n\nstatic int ca0132_alt_svm_setting_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = NUM_OF_SVM_SETTINGS;\n\tunsigned int idx = SMART_VOLUME - EFFECT_START_NID;\n\tunsigned int tmp;\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_alt_svm_setting: sel=%d, preset=%s\\n\",\n\t\t    sel, out_svm_set_enum_str[sel]);\n\n\tspec->smart_volume_setting = sel;\n\n\tswitch (sel) {\n\tcase 0:\n\t\ttmp = FLOAT_ZERO;\n\t\tbreak;\n\tcase 1:\n\t\ttmp = FLOAT_ONE;\n\t\tbreak;\n\tcase 2:\n\t\ttmp = FLOAT_TWO;\n\t\tbreak;\n\tdefault:\n\t\ttmp = FLOAT_ZERO;\n\t\tbreak;\n\t}\n\t \n\tdspio_set_uint_param(codec, ca0132_effects[idx].mid,\n\t\t\tca0132_effects[idx].reqs[2], tmp);\n\treturn 1;\n}\n\n \nstatic int ca0132_alt_eq_preset_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = items;\n\tif (uinfo->value.enumerated.item >= items)\n\t\tuinfo->value.enumerated.item = items - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t\tca0132_alt_eq_presets[uinfo->value.enumerated.item].name);\n\treturn 0;\n}\n\nstatic int ca0132_alt_eq_preset_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->eq_preset_val;\n\treturn 0;\n}\n\nstatic int ca0132_alt_eq_preset_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint i, err = 0;\n\tint sel = ucontrol->value.enumerated.item[0];\n\tunsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);\n\n\tif (sel >= items)\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"%s: sel=%d, preset=%s\\n\", __func__, sel,\n\t\t\tca0132_alt_eq_presets[sel].name);\n\t \n\tfor (i = 0; i < EQ_PRESET_MAX_PARAM_COUNT; i++) {\n\t\terr = dspio_set_uint_param(codec, ca0132_alt_eq_enum.mid,\n\t\t\t\tca0132_alt_eq_enum.reqs[i],\n\t\t\t\tca0132_alt_eq_presets[sel].vals[i]);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tif (err >= 0)\n\t\tspec->eq_preset_val = sel;\n\n\treturn 1;\n}\n\nstatic int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int items = ARRAY_SIZE(ca0132_voicefx_presets);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = items;\n\tif (uinfo->value.enumerated.item >= items)\n\t\tuinfo->value.enumerated.item = items - 1;\n\tstrcpy(uinfo->value.enumerated.name,\n\t       ca0132_voicefx_presets[uinfo->value.enumerated.item].name);\n\treturn 0;\n}\n\nstatic int ca0132_voicefx_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->voicefx_val;\n\treturn 0;\n}\n\nstatic int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\tint i, err = 0;\n\tint sel = ucontrol->value.enumerated.item[0];\n\n\tif (sel >= ARRAY_SIZE(ca0132_voicefx_presets))\n\t\treturn 0;\n\n\tcodec_dbg(codec, \"ca0132_voicefx_put: sel=%d, preset=%s\\n\",\n\t\t    sel, ca0132_voicefx_presets[sel].name);\n\n\t \n\tfor (i = 0; i < VOICEFX_MAX_PARAM_COUNT; i++) {\n\t\terr = dspio_set_uint_param(codec, ca0132_voicefx.mid,\n\t\t\t\tca0132_voicefx.reqs[i],\n\t\t\t\tca0132_voicefx_presets[sel].vals[i]);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tif (err >= 0) {\n\t\tspec->voicefx_val = sel;\n\t\t \n\t\tca0132_voicefx_set(codec, (sel ? 1 : 0));\n\t}\n\n\treturn 1;\n}\n\nstatic int ca0132_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\t \n\tif ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {\n\t\tif (ch & 1) {\n\t\t\t*valp = spec->vnode_lswitch[nid - VNODE_START_NID];\n\t\t\tvalp++;\n\t\t}\n\t\tif (ch & 2) {\n\t\t\t*valp = spec->vnode_rswitch[nid - VNODE_START_NID];\n\t\t\tvalp++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif ((nid >= EFFECT_START_NID) && (nid < EFFECT_END_NID)) {\n\t\t*valp = spec->effects_switch[nid - EFFECT_START_NID];\n\t\treturn 0;\n\t}\n\n\t \n\tif (nid == spec->input_pins[0]) {\n\t\t*valp = spec->cur_mic_boost;\n\t\treturn 0;\n\t}\n\n\tif (nid == ZXR_HEADPHONE_GAIN) {\n\t\t*valp = spec->zxr_gain_set;\n\t\treturn 0;\n\t}\n\n\tif (nid == SPEAKER_FULL_RANGE_FRONT || nid == SPEAKER_FULL_RANGE_REAR) {\n\t\t*valp = spec->speaker_range_val[nid - SPEAKER_FULL_RANGE_FRONT];\n\t\treturn 0;\n\t}\n\n\tif (nid == BASS_REDIRECTION) {\n\t\t*valp = spec->bass_redirection_val;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ca0132_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint changed = 1;\n\n\tcodec_dbg(codec, \"ca0132_switch_put: nid=0x%x, val=%ld\\n\",\n\t\t    nid, *valp);\n\n\tsnd_hda_power_up(codec);\n\t \n\tif ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {\n\t\tif (ch & 1) {\n\t\t\tspec->vnode_lswitch[nid - VNODE_START_NID] = *valp;\n\t\t\tvalp++;\n\t\t}\n\t\tif (ch & 2) {\n\t\t\tspec->vnode_rswitch[nid - VNODE_START_NID] = *valp;\n\t\t\tvalp++;\n\t\t}\n\t\tchanged = ca0132_vnode_switch_set(kcontrol, ucontrol);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (nid == PLAY_ENHANCEMENT) {\n\t\tspec->effects_switch[nid - EFFECT_START_NID] = *valp;\n\t\tchanged = ca0132_pe_switch_set(codec);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (nid == CRYSTAL_VOICE) {\n\t\tspec->effects_switch[nid - EFFECT_START_NID] = *valp;\n\t\tchanged = ca0132_cvoice_switch_set(codec);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (((nid >= OUT_EFFECT_START_NID) && (nid < OUT_EFFECT_END_NID)) ||\n\t    ((nid >= IN_EFFECT_START_NID) && (nid < IN_EFFECT_END_NID))) {\n\t\tspec->effects_switch[nid - EFFECT_START_NID] = *valp;\n\t\tchanged = ca0132_effects_set(codec, nid, *valp);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (nid == spec->input_pins[0]) {\n\t\tspec->cur_mic_boost = *valp;\n\t\tif (ca0132_use_alt_functions(spec)) {\n\t\t\tif (spec->in_enum_val != REAR_LINE_IN)\n\t\t\t\tchanged = ca0132_mic_boost_set(codec, *valp);\n\t\t} else {\n\t\t\t \n\t\t\tif (spec->cur_mic_type != DIGITAL_MIC)\n\t\t\t\tchanged = ca0132_mic_boost_set(codec, *valp);\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tif (nid == ZXR_HEADPHONE_GAIN) {\n\t\tspec->zxr_gain_set = *valp;\n\t\tif (spec->cur_out_type == HEADPHONE_OUT)\n\t\t\tchanged = zxr_headphone_gain_set(codec, *valp);\n\t\telse\n\t\t\tchanged = 0;\n\n\t\tgoto exit;\n\t}\n\n\tif (nid == SPEAKER_FULL_RANGE_FRONT || nid == SPEAKER_FULL_RANGE_REAR) {\n\t\tspec->speaker_range_val[nid - SPEAKER_FULL_RANGE_FRONT] = *valp;\n\t\tif (spec->cur_out_type == SPEAKER_OUT)\n\t\t\tca0132_alt_set_full_range_speaker(codec);\n\n\t\tchanged = 0;\n\t}\n\n\tif (nid == BASS_REDIRECTION) {\n\t\tspec->bass_redirection_val = *valp;\n\t\tif (spec->cur_out_type == SPEAKER_OUT)\n\t\t\tca0132_alt_surround_set_bass_redirection(codec, *valp);\n\n\t\tchanged = 0;\n\t}\n\nexit:\n\tsnd_hda_power_down(codec);\n\treturn changed;\n}\n\n \n \nstatic void ca0132_alt_dsp_volume_put(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int dsp_dir;\n\tunsigned int lookup_val;\n\n\tif (nid == VNID_SPK)\n\t\tdsp_dir = DSP_VOL_OUT;\n\telse\n\t\tdsp_dir = DSP_VOL_IN;\n\n\tlookup_val = spec->vnode_lvol[nid - VNODE_START_NID];\n\n\tdspio_set_uint_param(codec,\n\t\tca0132_alt_vol_ctls[dsp_dir].mid,\n\t\tca0132_alt_vol_ctls[dsp_dir].reqs[0],\n\t\tfloat_vol_db_lookup[lookup_val]);\n\n\tlookup_val = spec->vnode_rvol[nid - VNODE_START_NID];\n\n\tdspio_set_uint_param(codec,\n\t\tca0132_alt_vol_ctls[dsp_dir].mid,\n\t\tca0132_alt_vol_ctls[dsp_dir].reqs[1],\n\t\tfloat_vol_db_lookup[lookup_val]);\n\n\tdspio_set_uint_param(codec,\n\t\tca0132_alt_vol_ctls[dsp_dir].mid,\n\t\tca0132_alt_vol_ctls[dsp_dir].reqs[2], FLOAT_ZERO);\n}\n\nstatic int ca0132_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tunsigned long pval;\n\tint err;\n\n\tswitch (nid) {\n\tcase VNID_SPK:\n\t\t \n\t\tnid = spec->shared_out_nid;\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\n\t\terr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t\tbreak;\n\tcase VNID_MIC:\n\t\t \n\t\tnid = spec->shared_mic_nid;\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\n\t\terr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t\tbreak;\n\tdefault:\n\t\terr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\n\t}\n\treturn err;\n}\n\nstatic int ca0132_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\t \n\tif (ch & 1) {\n\t\t*valp = spec->vnode_lvol[nid - VNODE_START_NID];\n\t\tvalp++;\n\t}\n\tif (ch & 2) {\n\t\t*valp = spec->vnode_rvol[nid - VNODE_START_NID];\n\t\tvalp++;\n\t}\n\treturn 0;\n}\n\nstatic int ca0132_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\thda_nid_t shared_nid = 0;\n\tbool effective;\n\tint changed = 1;\n\n\t \n\tif (ch & 1) {\n\t\tspec->vnode_lvol[nid - VNODE_START_NID] = *valp;\n\t\tvalp++;\n\t}\n\tif (ch & 2) {\n\t\tspec->vnode_rvol[nid - VNODE_START_NID] = *valp;\n\t\tvalp++;\n\t}\n\n\t \n\teffective = ca0132_is_vnode_effective(codec, nid, &shared_nid);\n\tif (effective) {\n\t\tint dir = get_amp_direction(kcontrol);\n\t\tunsigned long pval;\n\n\t\tsnd_hda_power_up(codec);\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,\n\t\t\t\t\t\t\t\t0, dir);\n\t\tchanged = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t\tsnd_hda_power_down(codec);\n\t}\n\n\treturn changed;\n}\n\n \nstatic int ca0132_alt_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\thda_nid_t vnid = 0;\n\tint changed;\n\n\tswitch (nid) {\n\tcase 0x02:\n\t\tvnid = VNID_SPK;\n\t\tbreak;\n\tcase 0x07:\n\t\tvnid = VNID_MIC;\n\t\tbreak;\n\t}\n\n\t \n\tif (ch & 1) {\n\t\tspec->vnode_lvol[vnid - VNODE_START_NID] = *valp;\n\t\tvalp++;\n\t}\n\tif (ch & 2) {\n\t\tspec->vnode_rvol[vnid - VNODE_START_NID] = *valp;\n\t\tvalp++;\n\t}\n\n\tsnd_hda_power_up(codec);\n\tca0132_alt_dsp_volume_put(codec, vnid);\n\tmutex_lock(&codec->control_mutex);\n\tchanged = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\n\tmutex_unlock(&codec->control_mutex);\n\tsnd_hda_power_down(codec);\n\n\treturn changed;\n}\n\nstatic int ca0132_volume_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t     unsigned int size, unsigned int __user *tlv)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ca0132_spec *spec = codec->spec;\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint ch = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tunsigned long pval;\n\tint err;\n\n\tswitch (nid) {\n\tcase VNID_SPK:\n\t\t \n\t\tnid = spec->shared_out_nid;\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\n\t\terr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t\tbreak;\n\tcase VNID_MIC:\n\t\t \n\t\tnid = spec->shared_mic_nid;\n\t\tmutex_lock(&codec->control_mutex);\n\t\tpval = kcontrol->private_value;\n\t\tkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\n\t\terr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\n\t\tkcontrol->private_value = pval;\n\t\tmutex_unlock(&codec->control_mutex);\n\t\tbreak;\n\tdefault:\n\t\terr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\n\t}\n\treturn err;\n}\n\n \nstatic int ca0132_alt_add_effect_slider(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t\tconst char *pfx, int dir)\n{\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint type = dir ? HDA_INPUT : HDA_OUTPUT;\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_VOLUME_MONO(namestr, nid, 1, 0, type);\n\n\tsprintf(namestr, \"FX: %s %s Volume\", pfx, dirstr[dir]);\n\n\tknew.tlv.c = NULL;\n\n\tswitch (nid) {\n\tcase XBASS_XOVER:\n\t\tknew.info = ca0132_alt_xbass_xover_slider_info;\n\t\tknew.get = ca0132_alt_xbass_xover_slider_ctl_get;\n\t\tknew.put = ca0132_alt_xbass_xover_slider_put;\n\t\tbreak;\n\tdefault:\n\t\tknew.info = ca0132_alt_effect_slider_info;\n\t\tknew.get = ca0132_alt_slider_ctl_get;\n\t\tknew.put = ca0132_alt_effect_slider_put;\n\t\tknew.private_value =\n\t\t\tHDA_COMPOSE_AMP_VAL(nid, 1, 0, type);\n\t\tbreak;\n\t}\n\n\treturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\n}\n\n \nstatic int add_fx_switch(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t const char *pfx, int dir)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint type = dir ? HDA_INPUT : HDA_OUTPUT;\n\tstruct snd_kcontrol_new knew =\n\t\tCA0132_CODEC_MUTE_MONO(namestr, nid, 1, type);\n\t \n\tif (ca0132_use_alt_controls(spec) && (nid <= IN_EFFECT_END_NID))\n\t\tsprintf(namestr, \"FX: %s %s Switch\", pfx, dirstr[dir]);\n\telse\n\t\tsprintf(namestr, \"%s %s Switch\", pfx, dirstr[dir]);\n\n\treturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\n}\n\nstatic int add_voicefx(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(ca0132_voicefx.name,\n\t\t\t\t    VOICEFX, 1, 0, HDA_INPUT);\n\tknew.info = ca0132_voicefx_info;\n\tknew.get = ca0132_voicefx_get;\n\tknew.put = ca0132_voicefx_put;\n\treturn snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));\n}\n\n \nstatic int add_ca0132_alt_eq_presets(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,\n\t\t\t\t    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ca0132_alt_eq_preset_info;\n\tknew.get = ca0132_alt_eq_preset_get;\n\tknew.put = ca0132_alt_eq_preset_put;\n\treturn snd_hda_ctl_add(codec, EQ_PRESET_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_svm_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"FX: Smart Volume Setting\",\n\t\t\t\t    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ca0132_alt_svm_setting_info;\n\tknew.get = ca0132_alt_svm_setting_get;\n\tknew.put = ca0132_alt_svm_setting_put;\n\treturn snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n\n}\n\n \nstatic int ca0132_alt_add_output_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"Output Select\",\n\t\t\t\t    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ca0132_alt_output_select_get_info;\n\tknew.get = ca0132_alt_output_select_get;\n\tknew.put = ca0132_alt_output_select_put;\n\treturn snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_speaker_channel_cfg_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"Surround Channel Config\",\n\t\t\t\t    SPEAKER_CHANNEL_CFG_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ca0132_alt_speaker_channel_cfg_get_info;\n\tknew.get = ca0132_alt_speaker_channel_cfg_get;\n\tknew.put = ca0132_alt_speaker_channel_cfg_put;\n\treturn snd_hda_ctl_add(codec, SPEAKER_CHANNEL_CFG_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_front_full_range_switch(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tCA0132_CODEC_MUTE_MONO(\"Full-Range Front Speakers\",\n\t\t\t\t    SPEAKER_FULL_RANGE_FRONT, 1, HDA_OUTPUT);\n\n\treturn snd_hda_ctl_add(codec, SPEAKER_FULL_RANGE_FRONT,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\nstatic int ca0132_alt_add_rear_full_range_switch(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tCA0132_CODEC_MUTE_MONO(\"Full-Range Rear Speakers\",\n\t\t\t\t    SPEAKER_FULL_RANGE_REAR, 1, HDA_OUTPUT);\n\n\treturn snd_hda_ctl_add(codec, SPEAKER_FULL_RANGE_REAR,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_bass_redirection_crossover(struct hda_codec *codec)\n{\n\tconst char *namestr = \"Bass Redirection Crossover\";\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_VOLUME_MONO(namestr, BASS_REDIRECTION_XOVER, 1, 0,\n\t\t\t\tHDA_OUTPUT);\n\n\tknew.tlv.c = NULL;\n\tknew.info = ca0132_alt_xbass_xover_slider_info;\n\tknew.get = ca0132_alt_xbass_xover_slider_ctl_get;\n\tknew.put = ca0132_alt_xbass_xover_slider_put;\n\n\treturn snd_hda_ctl_add(codec, BASS_REDIRECTION_XOVER,\n\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\nstatic int ca0132_alt_add_bass_redirection_switch(struct hda_codec *codec)\n{\n\tconst char *namestr = \"Bass Redirection\";\n\tstruct snd_kcontrol_new knew =\n\t\tCA0132_CODEC_MUTE_MONO(namestr, BASS_REDIRECTION, 1,\n\t\t\t\tHDA_OUTPUT);\n\n\treturn snd_hda_ctl_add(codec, BASS_REDIRECTION,\n\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_input_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"Input Source\",\n\t\t\t\t    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);\n\tknew.info = ca0132_alt_input_source_info;\n\tknew.get = ca0132_alt_input_source_get;\n\tknew.put = ca0132_alt_input_source_put;\n\treturn snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"Mic Boost Capture Switch\",\n\t\t\t\t    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);\n\tknew.info = ca0132_alt_mic_boost_info;\n\tknew.get = ca0132_alt_mic_boost_get;\n\tknew.put = ca0132_alt_mic_boost_put;\n\treturn snd_hda_ctl_add(codec, MIC_BOOST_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n\n}\n\n \nstatic int ae5_add_headphone_gain_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"AE-5: Headphone Gain\",\n\t\t\t\t    AE5_HEADPHONE_GAIN_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ae5_headphone_gain_info;\n\tknew.get = ae5_headphone_gain_get;\n\tknew.put = ae5_headphone_gain_put;\n\treturn snd_hda_ctl_add(codec, AE5_HEADPHONE_GAIN_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic int ae5_add_sound_filter_enum(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tHDA_CODEC_MUTE_MONO(\"AE-5: Sound Filter\",\n\t\t\t\t    AE5_SOUND_FILTER_ENUM, 1, 0, HDA_OUTPUT);\n\tknew.info = ae5_sound_filter_info;\n\tknew.get = ae5_sound_filter_get;\n\tknew.put = ae5_sound_filter_put;\n\treturn snd_hda_ctl_add(codec, AE5_SOUND_FILTER_ENUM,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\nstatic int zxr_add_headphone_gain_switch(struct hda_codec *codec)\n{\n\tstruct snd_kcontrol_new knew =\n\t\tCA0132_CODEC_MUTE_MONO(\"ZxR: 600 Ohm Gain\",\n\t\t\t\t    ZXR_HEADPHONE_GAIN, 1, HDA_OUTPUT);\n\n\treturn snd_hda_ctl_add(codec, ZXR_HEADPHONE_GAIN,\n\t\t\t\tsnd_ctl_new1(&knew, codec));\n}\n\n \nstatic const char * const ca0132_alt_follower_pfxs[] = {\n\t\"Front\", \"Surround\", \"Center\", \"LFE\", NULL,\n};\n\n \nstatic const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\n \nstatic void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)\n{\n\tint err = 0;\n\tstruct hda_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\n\t\tstruct hda_pcm_stream *hinfo =\n\t\t\t&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tstruct snd_pcm_chmap *chmap;\n\t\tconst struct snd_pcm_chmap_elem *elem;\n\n\t\telem = ca0132_alt_chmaps;\n\t\tif (hinfo->channels_max == 6) {\n\t\t\terr = snd_pcm_add_chmap_ctls(pcm->pcm,\n\t\t\t\t\tSNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\telem, hinfo->channels_max, 0, &chmap);\n\t\t\tif (err < 0)\n\t\t\t\tcodec_dbg(codec, \"snd_pcm_add_chmap_ctls failed!\");\n\t\t}\n\t}\n}\n\n \nstatic const struct snd_kcontrol_new ca0132_mixer[] = {\n\tCA0132_CODEC_VOL(\"Master Playback Volume\", VNID_SPK, HDA_OUTPUT),\n\tCA0132_CODEC_MUTE(\"Master Playback Switch\", VNID_SPK, HDA_OUTPUT),\n\tCA0132_CODEC_VOL(\"Capture Volume\", VNID_MIC, HDA_INPUT),\n\tCA0132_CODEC_MUTE(\"Capture Switch\", VNID_MIC, HDA_INPUT),\n\tHDA_CODEC_VOLUME(\"Analog-Mic2 Capture Volume\", 0x08, 0, HDA_INPUT),\n\tHDA_CODEC_MUTE(\"Analog-Mic2 Capture Switch\", 0x08, 0, HDA_INPUT),\n\tHDA_CODEC_VOLUME(\"What U Hear Capture Volume\", 0x0a, 0, HDA_INPUT),\n\tHDA_CODEC_MUTE(\"What U Hear Capture Switch\", 0x0a, 0, HDA_INPUT),\n\tCA0132_CODEC_MUTE_MONO(\"Mic1-Boost (30dB) Capture Switch\",\n\t\t\t       0x12, 1, HDA_INPUT),\n\tCA0132_CODEC_MUTE_MONO(\"HP/Speaker Playback Switch\",\n\t\t\t       VNID_HP_SEL, 1, HDA_OUTPUT),\n\tCA0132_CODEC_MUTE_MONO(\"AMic1/DMic Capture Switch\",\n\t\t\t       VNID_AMIC1_SEL, 1, HDA_INPUT),\n\tCA0132_CODEC_MUTE_MONO(\"HP/Speaker Auto Detect Playback Switch\",\n\t\t\t       VNID_HP_ASEL, 1, HDA_OUTPUT),\n\tCA0132_CODEC_MUTE_MONO(\"AMic1/DMic Auto Detect Capture Switch\",\n\t\t\t       VNID_AMIC1_ASEL, 1, HDA_INPUT),\n\t{ }  \n};\n\n \nstatic const struct snd_kcontrol_new desktop_mixer[] = {\n\tCA0132_ALT_CODEC_VOL(\"Front Playback Volume\", 0x02, HDA_OUTPUT),\n\tCA0132_CODEC_MUTE(\"Front Playback Switch\", VNID_SPK, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME(\"Surround Playback Volume\", 0x04, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE(\"Surround Playback Switch\", 0x04, 0, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME_MONO(\"Center Playback Volume\", 0x03, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_MONO(\"Center Playback Switch\", 0x03, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME_MONO(\"LFE Playback Volume\", 0x03, 2, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_MONO(\"LFE Playback Switch\", 0x03, 2, 0, HDA_OUTPUT),\n\tCA0132_ALT_CODEC_VOL(\"Capture Volume\", 0x07, HDA_INPUT),\n\tCA0132_CODEC_MUTE(\"Capture Switch\", VNID_MIC, HDA_INPUT),\n\tHDA_CODEC_VOLUME(\"What U Hear Capture Volume\", 0x0a, 0, HDA_INPUT),\n\tHDA_CODEC_MUTE(\"What U Hear Capture Switch\", 0x0a, 0, HDA_INPUT),\n\tCA0132_CODEC_MUTE_MONO(\"HP/Speaker Auto Detect Playback Switch\",\n\t\t\t\tVNID_HP_ASEL, 1, HDA_OUTPUT),\n\t{ }  \n};\n\n \nstatic const struct snd_kcontrol_new r3di_mixer[] = {\n\tCA0132_ALT_CODEC_VOL(\"Front Playback Volume\", 0x02, HDA_OUTPUT),\n\tCA0132_CODEC_MUTE(\"Front Playback Switch\", VNID_SPK, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME(\"Surround Playback Volume\", 0x04, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE(\"Surround Playback Switch\", 0x04, 0, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME_MONO(\"Center Playback Volume\", 0x03, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_MONO(\"Center Playback Switch\", 0x03, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_VOLUME_MONO(\"LFE Playback Volume\", 0x03, 2, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_MONO(\"LFE Playback Switch\", 0x03, 2, 0, HDA_OUTPUT),\n\tCA0132_CODEC_VOL(\"Capture Volume\", VNID_MIC, HDA_INPUT),\n\tCA0132_CODEC_MUTE(\"Capture Switch\", VNID_MIC, HDA_INPUT),\n\tHDA_CODEC_VOLUME(\"What U Hear Capture Volume\", 0x0a, 0, HDA_INPUT),\n\tHDA_CODEC_MUTE(\"What U Hear Capture Switch\", 0x0a, 0, HDA_INPUT),\n\tCA0132_CODEC_MUTE_MONO(\"HP/Speaker Auto Detect Playback Switch\",\n\t\t\t\tVNID_HP_ASEL, 1, HDA_OUTPUT),\n\t{ }  \n};\n\nstatic int ca0132_build_controls(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint i, num_fx, num_sliders;\n\tint err = 0;\n\n\t \n\tfor (i = 0; i < spec->num_mixers; i++) {\n\t\terr = snd_hda_add_new_ctls(codec, spec->mixers[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tif (ca0132_use_alt_functions(spec)) {\n\t\tsnd_hda_set_vmaster_tlv(codec, spec->dacs[0], HDA_OUTPUT,\n\t\t\t\t\tspec->tlv);\n\t\tsnd_hda_add_vmaster(codec, \"Master Playback Volume\",\n\t\t\t\t\tspec->tlv, ca0132_alt_follower_pfxs,\n\t\t\t\t\t\"Playback Volume\", 0);\n\t\terr = __snd_hda_add_vmaster(codec, \"Master Playback Switch\",\n\t\t\t\t\t    NULL, ca0132_alt_follower_pfxs,\n\t\t\t\t\t    \"Playback Switch\",\n\t\t\t\t\t    true, 0, &spec->vmaster_mute.sw_kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\n\tfor (i = 0; i < num_fx; i++) {\n\t\t \n\t\tif (ca0132_use_pci_mmio(spec)) {\n\t\t\tif (i == (ECHO_CANCELLATION - IN_EFFECT_START_NID +\n\t\t\t\t\t\tOUT_EFFECTS_COUNT))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = add_fx_switch(codec, ca0132_effects[i].nid,\n\t\t\t\t    ca0132_effects[i].name,\n\t\t\t\t    ca0132_effects[i].direct);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tif (ca0132_use_alt_controls(spec)) {\n\t\terr = ca0132_alt_add_svm_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_ca0132_alt_eq_presets(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_fx_switch(codec, PLAY_ENHANCEMENT,\n\t\t\t\t\t\"Enable OutFX\", 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_fx_switch(codec, CRYSTAL_VOICE,\n\t\t\t\t\t\"Enable InFX\", 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tnum_sliders = OUT_EFFECTS_COUNT - 1;\n\t\tfor (i = 0; i < num_sliders; i++) {\n\t\t\terr = ca0132_alt_add_effect_slider(codec,\n\t\t\t\t\t    ca0132_effects[i].nid,\n\t\t\t\t\t    ca0132_effects[i].name,\n\t\t\t\t\t    ca0132_effects[i].direct);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = ca0132_alt_add_effect_slider(codec, XBASS_XOVER,\n\t\t\t\t\t\"X-Bass Crossover\", EFX_DIR_OUT);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = add_fx_switch(codec, PLAY_ENHANCEMENT,\n\t\t\t\t\t\"PlayEnhancement\", 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_fx_switch(codec, CRYSTAL_VOICE,\n\t\t\t\t\t\"CrystalVoice\", 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = add_voicefx(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (ca0132_use_alt_functions(spec)) {\n\t\terr = ca0132_alt_add_output_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_speaker_channel_cfg_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_front_full_range_switch(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_rear_full_range_switch(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_bass_redirection_crossover(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_bass_redirection_switch(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ca0132_alt_add_mic_boost_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tif (ca0132_quirk(spec) != QUIRK_ZXR) {\n\t\t\terr = ca0132_alt_add_input_enum(codec);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_AE5:\n\tcase QUIRK_AE7:\n\t\terr = ae5_add_headphone_gain_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ae5_add_sound_filter_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\terr = zxr_add_headphone_gain_switch(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef ENABLE_TUNING_CONTROLS\n\tadd_tuning_ctls(codec);\n#endif\n\n\terr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (spec->dig_out) {\n\t\terr = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,\n\t\t\t\t\t\t    spec->dig_out);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_hda_create_spdif_share_sw(codec, &spec->multiout);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t}\n\n\tif (spec->dig_in) {\n\t\terr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (ca0132_use_alt_functions(spec))\n\t\tca0132_alt_add_chmap_ctls(codec);\n\n\treturn 0;\n}\n\nstatic int dbpro_build_controls(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint err = 0;\n\n\tif (spec->dig_out) {\n\t\terr = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,\n\t\t\t\tspec->dig_out);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (spec->dig_in) {\n\t\terr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct hda_pcm_stream ca0132_pcm_analog_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 6,\n\t.ops = {\n\t\t.prepare = ca0132_playback_pcm_prepare,\n\t\t.cleanup = ca0132_playback_pcm_cleanup,\n\t\t.get_delay = ca0132_playback_pcm_delay,\n\t},\n};\n\nstatic const struct hda_pcm_stream ca0132_pcm_analog_capture = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.ops = {\n\t\t.prepare = ca0132_capture_pcm_prepare,\n\t\t.cleanup = ca0132_capture_pcm_cleanup,\n\t\t.get_delay = ca0132_capture_pcm_delay,\n\t},\n};\n\nstatic const struct hda_pcm_stream ca0132_pcm_digital_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.ops = {\n\t\t.open = ca0132_dig_playback_pcm_open,\n\t\t.close = ca0132_dig_playback_pcm_close,\n\t\t.prepare = ca0132_dig_playback_pcm_prepare,\n\t\t.cleanup = ca0132_dig_playback_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream ca0132_pcm_digital_capture = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n};\n\nstatic int ca0132_build_pcms(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstruct hda_pcm *info;\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 Analog\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tif (ca0132_use_alt_functions(spec)) {\n\t\tinfo->own_chmap = true;\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].chmap\n\t\t\t= ca0132_alt_chmaps;\n\t}\n\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0132_pcm_analog_playback;\n\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];\n\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\n\t\tspec->multiout.max_channels;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];\n\n\t \n\tif (!ca0132_use_alt_functions(spec)) {\n\t\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 Analog Mic-In2\");\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\n\t\t\tca0132_pcm_analog_capture;\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[1];\n\t}\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 What U Hear\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[2];\n\n\tif (!spec->dig_out && !spec->dig_in)\n\t\treturn 0;\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 Digital\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm_type = HDA_PCM_TYPE_SPDIF;\n\tif (spec->dig_out) {\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\n\t\t\tca0132_pcm_digital_playback;\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;\n\t}\n\tif (spec->dig_in) {\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\n\t\t\tca0132_pcm_digital_capture;\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\n\t}\n\n\treturn 0;\n}\n\nstatic int dbpro_build_pcms(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstruct hda_pcm *info;\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 Alt Analog\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];\n\n\n\tif (!spec->dig_out && !spec->dig_in)\n\t\treturn 0;\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"CA0132 Digital\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm_type = HDA_PCM_TYPE_SPDIF;\n\tif (spec->dig_out) {\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\n\t\t\tca0132_pcm_digital_playback;\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;\n\t}\n\tif (spec->dig_in) {\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\n\t\t\tca0132_pcm_digital_capture;\n\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\n\t}\n\n\treturn 0;\n}\n\nstatic void init_output(struct hda_codec *codec, hda_nid_t pin, hda_nid_t dac)\n{\n\tif (pin) {\n\t\tsnd_hda_set_pin_ctl(codec, pin, PIN_HP);\n\t\tif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\n\t\t\tsnd_hda_codec_write(codec, pin, 0,\n\t\t\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE,\n\t\t\t\t\t    AMP_OUT_UNMUTE);\n\t}\n\tif (dac && (get_wcaps(codec, dac) & AC_WCAP_OUT_AMP))\n\t\tsnd_hda_codec_write(codec, dac, 0,\n\t\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO);\n}\n\nstatic void init_input(struct hda_codec *codec, hda_nid_t pin, hda_nid_t adc)\n{\n\tif (pin) {\n\t\tsnd_hda_set_pin_ctl(codec, pin, PIN_VREF80);\n\t\tif (get_wcaps(codec, pin) & AC_WCAP_IN_AMP)\n\t\t\tsnd_hda_codec_write(codec, pin, 0,\n\t\t\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE,\n\t\t\t\t\t    AMP_IN_UNMUTE(0));\n\t}\n\tif (adc && (get_wcaps(codec, adc) & AC_WCAP_IN_AMP)) {\n\t\tsnd_hda_codec_write(codec, adc, 0, AC_VERB_SET_AMP_GAIN_MUTE,\n\t\t\t\t    AMP_IN_UNMUTE(0));\n\n\t\t \n\t\tsnd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,\n\t\t\t\t\t HDA_AMP_VOLMASK, 0x5a);\n\t\tsnd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,\n\t\t\t\t\t HDA_AMP_MUTE, 0);\n\t}\n}\n\nstatic void refresh_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir)\n{\n\tunsigned int caps;\n\n\tcaps = snd_hda_param_read(codec, nid, dir == HDA_OUTPUT ?\n\t\t\t\t  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\n\tsnd_hda_override_amp_caps(codec, nid, dir, caps);\n}\n\n \nstatic void ca0132_set_dmic(struct hda_codec *codec, int enable)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tu8 val;\n\tunsigned int oldval;\n\n\tcodec_dbg(codec, \"ca0132_set_dmic: enable=%d\\n\", enable);\n\n\toldval = stop_mic1(codec);\n\tca0132_set_vipsource(codec, 0);\n\tif (enable) {\n\t\t \n\t\ttmp = FLOAT_TWO;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\tval = spec->dmic_ctl;\n\t\tval |= 0x80;\n\t\tsnd_hda_codec_write(codec, spec->input_pins[0], 0,\n\t\t\t\t    VENDOR_CHIPIO_DMIC_CTL_SET, val);\n\n\t\tif (!(spec->dmic_ctl & 0x20))\n\t\t\tchipio_set_control_flag(codec, CONTROL_FLAG_DMIC, 1);\n\t} else {\n\t\t \n\t\ttmp = FLOAT_ONE;\n\t\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t\tval = spec->dmic_ctl;\n\t\t \n\t\tval &= 0x5f;\n\t\tsnd_hda_codec_write(codec, spec->input_pins[0], 0,\n\t\t\t\t    VENDOR_CHIPIO_DMIC_CTL_SET, val);\n\n\t\tif (!(spec->dmic_ctl & 0x20))\n\t\t\tchipio_set_control_flag(codec, CONTROL_FLAG_DMIC, 0);\n\t}\n\tca0132_set_vipsource(codec, 1);\n\tresume_mic1(codec, oldval);\n}\n\n \nstatic void ca0132_init_dmic(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tu8 val;\n\n\t \n\n\t \n\tval = 0x01;\n\tsnd_hda_codec_write(codec, spec->input_pins[0], 0,\n\t\t\t    VENDOR_CHIPIO_DMIC_MCLK_SET, val);\n\n\t \n\tval = 0x83;\n\tsnd_hda_codec_write(codec, spec->input_pins[0], 0,\n\t\t\t    VENDOR_CHIPIO_DMIC_PIN_SET, val);\n\n\t \n\tif (ca0132_quirk(spec) == QUIRK_ALIENWARE_M17XR4)\n\t\tval = 0x33;\n\telse\n\t\tval = 0x23;\n\t \n\tspec->dmic_ctl = val;\n\tsnd_hda_codec_write(codec, spec->input_pins[0], 0,\n\t\t\t    VENDOR_CHIPIO_DMIC_CTL_SET, val);\n}\n\n \nstatic void ca0132_init_analog_mic2(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_8051_write_exram_no_mutex(codec, 0x1920, 0x00);\n\tchipio_8051_write_exram_no_mutex(codec, 0x192d, 0x00);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ca0132_refresh_widget_caps(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint i;\n\n\tcodec_dbg(codec, \"ca0132_refresh_widget_caps.\\n\");\n\tsnd_hda_codec_update_widgets(codec);\n\n\tfor (i = 0; i < spec->multiout.num_dacs; i++)\n\t\trefresh_amp_caps(codec, spec->dacs[i], HDA_OUTPUT);\n\n\tfor (i = 0; i < spec->num_outputs; i++)\n\t\trefresh_amp_caps(codec, spec->out_pins[i], HDA_OUTPUT);\n\n\tfor (i = 0; i < spec->num_inputs; i++) {\n\t\trefresh_amp_caps(codec, spec->adcs[i], HDA_INPUT);\n\t\trefresh_amp_caps(codec, spec->input_pins[i], HDA_INPUT);\n\t}\n}\n\n\n \nstatic void ca0132_alt_free_active_dma_channels(struct hda_codec *codec)\n{\n\tunsigned int i, tmp;\n\tint status;\n\n\t \n\tstatus = chipio_read(codec, DSPDMAC_CHNLSTART_MODULE_OFFSET, &tmp);\n\tif (status >= 0) {\n\t\t \n\t\ttmp = tmp & 0xfff;\n\n\t\t \n\t\tif (!tmp)\n\t\t\treturn;\n\t} else {\n\t\tcodec_dbg(codec, \"%s: Failed to read active DSP DMA channel register.\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < DSPDMAC_DMA_CFG_CHANNEL_COUNT; i++) {\n\t\tif (dsp_is_dma_active(codec, i)) {\n\t\t\tstatus = dspio_free_dma_chan(codec, i);\n\t\t\tif (status < 0)\n\t\t\t\tcodec_dbg(codec, \"%s: Failed to free active DSP DMA channel %d.\\n\",\n\t\t\t\t\t\t__func__, i);\n\t\t}\n\t}\n}\n\n \nstatic void ca0132_alt_start_dsp_audio_streams(struct hda_codec *codec)\n{\n\tstatic const unsigned int dsp_dma_stream_ids[] = { 0x0c, 0x03, 0x04 };\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int i, tmp;\n\n\t \n\tmutex_lock(&spec->chipio_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(dsp_dma_stream_ids); i++) {\n\t\tchipio_get_stream_control(codec, dsp_dma_stream_ids[i], &tmp);\n\n\t\tif (tmp) {\n\t\t\tchipio_set_stream_control(codec,\n\t\t\t\t\tdsp_dma_stream_ids[i], 0);\n\t\t}\n\t}\n\n\tmutex_unlock(&spec->chipio_mutex);\n\n\t \n\tca0132_alt_free_active_dma_channels(codec);\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\t \n\tchipio_set_stream_channels(codec, 0x0c, 6);\n\n\tfor (i = 0; i < ARRAY_SIZE(dsp_dma_stream_ids); i++) {\n\t\tchipio_set_stream_control(codec,\n\t\t\t\tdsp_dma_stream_ids[i], 1);\n\n\t\t \n\t\tmsleep(75);\n\t}\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\n \nstatic void chipio_remap_stream(struct hda_codec *codec,\n\t\tconst struct chipio_stream_remap_data *remap_data)\n{\n\tunsigned int i, stream_offset;\n\n\t \n\tchipio_8051_read_exram(codec, 0x1578 + remap_data->stream_id,\n\t\t\t&stream_offset);\n\n\t \n\tif (stream_offset == 0xff) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmsleep(25);\n\n\t\t\tchipio_8051_read_exram(codec, 0x1578 + remap_data->stream_id,\n\t\t\t\t\t&stream_offset);\n\n\t\t\tif (stream_offset != 0xff)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (stream_offset == 0xff) {\n\t\tcodec_info(codec, \"%s: Stream 0x%02x ports aren't allocated, remap failed!\\n\",\n\t\t\t\t__func__, remap_data->stream_id);\n\t\treturn;\n\t}\n\n\t \n\tstream_offset *= 0x04;\n\tstream_offset += 0x190000;\n\n\tfor (i = 0; i < remap_data->count; i++) {\n\t\tchipio_write_no_mutex(codec,\n\t\t\t\tstream_offset + remap_data->offset[i],\n\t\t\t\tremap_data->value[i]);\n\t}\n\n\t \n\tchipio_write_no_mutex(codec, 0x19042c, 0x00000001);\n}\n\n \nstatic const unsigned int sbz_default_delay_values[] = {\n\t \n\t0x394f9e38, 0x394f9e38, 0x00000000, 0x00000000, 0x00000000, 0x00000000\n};\n\nstatic const unsigned int zxr_default_delay_values[] = {\n\t \n\t0x00000000, 0x00000000, 0x3966afcd, 0x3966afcd, 0x3966afcd, 0x3966afcd\n};\n\nstatic const unsigned int ae5_default_delay_values[] = {\n\t \n\t0x00000000, 0x00000000, 0x38d1b717, 0x38d1b717, 0x38d1b717, 0x38d1b717\n};\n\n \nstatic void ca0132_alt_init_speaker_tuning(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int i, tmp, start_req, end_req;\n\tconst unsigned int *values;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tvalues = sbz_default_delay_values;\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tvalues = zxr_default_delay_values;\n\t\tbreak;\n\tcase QUIRK_AE5:\n\tcase QUIRK_AE7:\n\t\tvalues = ae5_default_delay_values;\n\t\tbreak;\n\tdefault:\n\t\tvalues = sbz_default_delay_values;\n\t\tbreak;\n\t}\n\n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, SPEAKER_TUNING_ENABLE_CENTER_EQ, tmp);\n\n\tstart_req = SPEAKER_TUNING_FRONT_LEFT_VOL_LEVEL;\n\tend_req = SPEAKER_TUNING_REAR_RIGHT_VOL_LEVEL;\n\tfor (i = start_req; i < end_req + 1; i++)\n\t\tdspio_set_uint_param(codec, 0x96, i, tmp);\n\n\tstart_req = SPEAKER_TUNING_FRONT_LEFT_INVERT;\n\tend_req = SPEAKER_TUNING_REAR_RIGHT_INVERT;\n\tfor (i = start_req; i < end_req + 1; i++)\n\t\tdspio_set_uint_param(codec, 0x96, i, tmp);\n\n\n\tfor (i = 0; i < 6; i++)\n\t\tdspio_set_uint_param(codec, 0x96,\n\t\t\t\tSPEAKER_TUNING_FRONT_LEFT_DELAY + i, values[i]);\n}\n\n \nstatic void ca0132_alt_init_analog_mics(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\t \n\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\tif (ca0132_quirk(spec) == QUIRK_R3DI) {\n\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\t\ttmp = FLOAT_ONE;\n\t} else\n\t\ttmp = FLOAT_THREE;\n\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\t \n\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);\n\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\tchipio_set_conn_rate(codec, 0x0F, SR_96_000);\n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x80, 0x01, tmp);\n}\n\n \nstatic void sbz_connect_streams(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tcodec_dbg(codec, \"Connect Streams entered, mutex locked and loaded.\\n\");\n\n\t \n\tchipio_write_no_mutex(codec, 0x18a020, 0x00000043);\n\n\t \n\tchipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);\n\tchipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);\n\tchipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);\n\tchipio_set_stream_channels(codec, 0x14, 2);\n\tchipio_set_stream_control(codec, 0x14, 1);\n\n\tcodec_dbg(codec, \"Connect Streams exited, mutex released.\\n\");\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\n \nstatic void sbz_chipio_startup_data(struct hda_codec *codec)\n{\n\tconst struct chipio_stream_remap_data *dsp_out_remap_data;\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\tcodec_dbg(codec, \"Startup Data entered, mutex locked and loaded.\\n\");\n\n\t \n\tchipio_remap_stream(codec, &stream_remap_data[0]);\n\n\t \n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tdsp_out_remap_data = &stream_remap_data[1];\n\t\tbreak;\n\n\tcase QUIRK_ZXR:\n\t\tdsp_out_remap_data = &stream_remap_data[2];\n\t\tbreak;\n\n\tdefault:\n\t\tdsp_out_remap_data = NULL;\n\t\tbreak;\n\t}\n\n\tif (dsp_out_remap_data)\n\t\tchipio_remap_stream(codec, dsp_out_remap_data);\n\n\tcodec_dbg(codec, \"Startup Data exited, mutex released.\\n\");\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\n\ttmp = FLOAT_THREE;\n\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\n\tchipio_set_stream_control(codec, 0x03, 1);\n\tchipio_set_stream_control(codec, 0x04, 1);\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tchipio_write(codec, 0x18b098, 0x0000000c);\n\t\tchipio_write(codec, 0x18b09C, 0x0000000c);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tchipio_write(codec, 0x18b098, 0x0000000c);\n\t\tchipio_write(codec, 0x18b09c, 0x0000004c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ae5_post_dsp_register_set(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tchipio_8051_write_direct(codec, 0x93, 0x10);\n\tchipio_8051_write_pll_pmu(codec, 0x44, 0xc2);\n\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0x00, spec->mem_base + 0x100);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0x00, spec->mem_base + 0x100);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0x00, spec->mem_base + 0x100);\n\twriteb(0xff, spec->mem_base + 0x304);\n\twriteb(0x00, spec->mem_base + 0x100);\n\twriteb(0xff, spec->mem_base + 0x304);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x2b, 0x3f);\n\tca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);\n\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);\n}\n\nstatic void ae5_post_dsp_param_setup(struct hda_codec *codec)\n{\n\t \n\tchipio_set_control_param(codec, 3, 0);\n\t \n\tchipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);\n\tchipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);\n\n\tchipio_8051_write_exram(codec, 0xfa92, 0x22);\n}\n\nstatic void ae5_post_dsp_pll_setup(struct hda_codec *codec)\n{\n\tchipio_8051_write_pll_pmu(codec, 0x41, 0xc8);\n\tchipio_8051_write_pll_pmu(codec, 0x45, 0xcc);\n\tchipio_8051_write_pll_pmu(codec, 0x40, 0xcb);\n\tchipio_8051_write_pll_pmu(codec, 0x43, 0xc7);\n\tchipio_8051_write_pll_pmu(codec, 0x51, 0x8d);\n}\n\nstatic void ae5_post_dsp_stream_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);\n\n\tchipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);\n\n\tchipio_set_stream_source_dest(codec, 0x5, 0x43, 0x0);\n\n\tchipio_set_stream_source_dest(codec, 0x18, 0x9, 0xd0);\n\tchipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);\n\tchipio_set_stream_channels(codec, 0x18, 6);\n\tchipio_set_stream_control(codec, 0x18, 1);\n\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);\n\n\tchipio_8051_write_pll_pmu_no_mutex(codec, 0x43, 0xc7);\n\n\tca0113_mmio_command_set(codec, 0x48, 0x01, 0x80);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ae5_post_dsp_startup_data(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_write_no_mutex(codec, 0x189000, 0x0001f101);\n\tchipio_write_no_mutex(codec, 0x189004, 0x0001f101);\n\tchipio_write_no_mutex(codec, 0x189024, 0x00014004);\n\tchipio_write_no_mutex(codec, 0x189028, 0x0002000f);\n\n\tca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);\n\tca0113_mmio_command_set(codec, 0x48, 0x0b, 0x12);\n\tca0113_mmio_command_set(codec, 0x48, 0x04, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x06, 0x48);\n\tca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);\n\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);\n\tca0113_mmio_gpio_set(codec, 0, true);\n\tca0113_mmio_gpio_set(codec, 1, true);\n\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x80);\n\n\tchipio_write_no_mutex(codec, 0x18b03c, 0x00000012);\n\n\tca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ae7_post_dsp_setup_ports(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\t \n\tchipio_remap_stream(codec, &stream_remap_data[1]);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x30, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x0d, 0x40);\n\tca0113_mmio_command_set(codec, 0x48, 0x17, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x19, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x11, 0xff);\n\tca0113_mmio_command_set(codec, 0x48, 0x12, 0xff);\n\tca0113_mmio_command_set(codec, 0x48, 0x13, 0xff);\n\tca0113_mmio_command_set(codec, 0x48, 0x14, 0x7f);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ae7_post_dsp_asi_stream_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);\n\tca0113_mmio_command_set(codec, 0x30, 0x2b, 0x00);\n\n\tchipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);\n\n\tchipio_set_stream_source_dest(codec, 0x05, 0x43, 0x00);\n\tchipio_set_stream_source_dest(codec, 0x18, 0x09, 0xd0);\n\n\tchipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);\n\tchipio_set_stream_channels(codec, 0x18, 6);\n\tchipio_set_stream_control(codec, 0x18, 1);\n\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\nstatic void ae7_post_dsp_pll_setup(struct hda_codec *codec)\n{\n\tstatic const unsigned int addr[] = {\n\t\t0x41, 0x45, 0x40, 0x43, 0x51\n\t};\n\tstatic const unsigned int data[] = {\n\t\t0xc8, 0xcc, 0xcb, 0xc7, 0x8d\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(addr); i++)\n\t\tchipio_8051_write_pll_pmu_no_mutex(codec, addr[i], data[i]);\n}\n\nstatic void ae7_post_dsp_asi_setup_ports(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstatic const unsigned int target[] = {\n\t\t0x0b, 0x04, 0x06, 0x0a, 0x0c, 0x11, 0x12, 0x13, 0x14\n\t};\n\tstatic const unsigned int data[] = {\n\t\t0x12, 0x00, 0x48, 0x05, 0x5f, 0xff, 0xff, 0xff, 0x7f\n\t};\n\tunsigned int i;\n\n\tmutex_lock(&spec->chipio_mutex);\n\n\tchipio_8051_write_pll_pmu_no_mutex(codec, 0x43, 0xc7);\n\n\tchipio_write_no_mutex(codec, 0x189000, 0x0001f101);\n\tchipio_write_no_mutex(codec, 0x189004, 0x0001f101);\n\tchipio_write_no_mutex(codec, 0x189024, 0x00014004);\n\tchipio_write_no_mutex(codec, 0x189028, 0x0002000f);\n\n\tae7_post_dsp_pll_setup(codec);\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);\n\n\tfor (i = 0; i < ARRAY_SIZE(target); i++)\n\t\tca0113_mmio_command_set(codec, 0x48, target[i], data[i]);\n\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);\n\n\tchipio_set_stream_source_dest(codec, 0x21, 0x64, 0x56);\n\tchipio_set_stream_channels(codec, 0x21, 2);\n\tchipio_set_conn_rate_no_mutex(codec, 0x56, SR_8_000);\n\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_NODE_ID, 0x09);\n\t \n\tchipio_set_control_param_no_mutex(codec, 0x20, 0x21);\n\n\tchipio_write_no_mutex(codec, 0x18b038, 0x00000088);\n\n\t \n\n\tca0113_mmio_gpio_set(codec, 0, 1);\n\tca0113_mmio_gpio_set(codec, 1, 1);\n\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x83);\n\tchipio_write_no_mutex(codec, 0x18b03c, 0x00000000);\n\tca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);\n\tca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);\n\n\tchipio_set_stream_source_dest(codec, 0x05, 0x43, 0x00);\n\tchipio_set_stream_source_dest(codec, 0x18, 0x09, 0xd0);\n\n\tchipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);\n\tchipio_set_stream_channels(codec, 0x18, 6);\n\n\t \n\tae7_post_dsp_pll_setup(codec);\n\tchipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);\n\n\tmutex_unlock(&spec->chipio_mutex);\n}\n\n \nstatic void ae7_post_dsp_asi_setup(struct hda_codec *codec)\n{\n\tchipio_8051_write_direct(codec, 0x93, 0x10);\n\n\tchipio_8051_write_pll_pmu(codec, 0x44, 0xc2);\n\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);\n\n\tchipio_set_control_param(codec, 3, 3);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);\n\tchipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);\n\tsnd_hda_codec_write(codec, 0x17, 0, 0x794, 0x00);\n\n\tchipio_8051_write_exram(codec, 0xfa92, 0x22);\n\n\tae7_post_dsp_pll_setup(codec);\n\tae7_post_dsp_asi_stream_setup(codec);\n\n\tchipio_8051_write_pll_pmu(codec, 0x43, 0xc7);\n\n\tae7_post_dsp_asi_setup_ports(codec);\n}\n\n \nstatic void ca0132_setup_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint num_fx;\n\tint idx, i;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn;\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\n\tfor (idx = 0; idx < num_fx; idx++) {\n\t\tfor (i = 0; i <= ca0132_effects[idx].params; i++) {\n\t\t\tdspio_set_uint_param(codec, ca0132_effects[idx].mid,\n\t\t\t\t\t     ca0132_effects[idx].reqs[i],\n\t\t\t\t\t     ca0132_effects[idx].def_vals[i]);\n\t\t}\n\t}\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x3C, tmp);\n\n\t \n\tdspio_set_uint_param(codec, 0x8f, 0x01, tmp);\n\n\t \n\ttmp = FLOAT_ONE;\n\tdspio_set_uint_param(codec, 0x80, 0x00, tmp);\n\tdspio_set_uint_param(codec, 0x80, 0x01, tmp);\n\n\t \n\ttmp = FLOAT_ONE;\n\tdspio_set_uint_param(codec, 0x80, 0x05, tmp);\n\n\t \n\ttmp = FLOAT_TWO;\n\tdspio_set_uint_param(codec, 0x31, 0x00, tmp);\n}\n\n \n\nstatic void r3d_setup_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint num_fx;\n\tint idx, i;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn;\n\n\tca0132_alt_init_analog_mics(codec);\n\tca0132_alt_start_dsp_audio_streams(codec);\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x3C, tmp);\n\n\t \n\ttmp = FLOAT_TWO;\n\tdspio_set_uint_param(codec, 0x31, 0x00, tmp);\n\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n\n\t \n\tdspio_set_uint_param(codec, 0x32, 0x00, tmp);\n\n\tif (ca0132_quirk(spec) == QUIRK_R3DI)\n\t\tr3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADED);\n\n\t \n\tif (ca0132_quirk(spec) == QUIRK_R3D) {\n\t\tca0113_mmio_gpio_set(codec, 2, false);\n\t\tca0113_mmio_gpio_set(codec, 4, true);\n\t}\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\n\tfor (idx = 0; idx < num_fx; idx++) {\n\t\tfor (i = 0; i <= ca0132_effects[idx].params; i++) {\n\t\t\tdspio_set_uint_param(codec,\n\t\t\t\t\tca0132_effects[idx].mid,\n\t\t\t\t\tca0132_effects[idx].reqs[i],\n\t\t\t\t\tca0132_effects[idx].def_vals[i]);\n\t\t}\n\t}\n}\n\n \nstatic void sbz_setup_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint num_fx;\n\tint idx, i;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn;\n\n\tca0132_alt_init_analog_mics(codec);\n\tca0132_alt_start_dsp_audio_streams(codec);\n\tsbz_connect_streams(codec);\n\tsbz_chipio_startup_data(codec);\n\n\t \n\ttmp = FLOAT_ONE;\n\tdspio_set_uint_param(codec, 0x37, 0x08, tmp);\n\tdspio_set_uint_param(codec, 0x37, 0x10, tmp);\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x3C, tmp);\n\n\t \n\ttmp = FLOAT_TWO;\n\tdspio_set_uint_param(codec, 0x31, 0x00, tmp);\n\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n\n\t \n\tdspio_set_uint_param(codec, 0x32, 0x00, tmp);\n\n\tca0132_alt_dsp_initial_mic_setup(codec);\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\n\tfor (idx = 0; idx < num_fx; idx++) {\n\t\tfor (i = 0; i <= ca0132_effects[idx].params; i++) {\n\t\t\tdspio_set_uint_param(codec,\n\t\t\t\t\tca0132_effects[idx].mid,\n\t\t\t\t\tca0132_effects[idx].reqs[i],\n\t\t\t\t\tca0132_effects[idx].def_vals[i]);\n\t\t}\n\t}\n\n\tca0132_alt_init_speaker_tuning(codec);\n}\n\n \nstatic void ae5_setup_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint num_fx;\n\tint idx, i;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn;\n\n\tca0132_alt_init_analog_mics(codec);\n\tca0132_alt_start_dsp_audio_streams(codec);\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x29, tmp);\n\tdspio_set_uint_param(codec, 0x96, 0x2a, tmp);\n\tdspio_set_uint_param(codec, 0x80, 0x0d, tmp);\n\tdspio_set_uint_param(codec, 0x80, 0x0e, tmp);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);\n\tca0113_mmio_gpio_set(codec, 0, false);\n\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);\n\n\t \n\ttmp = FLOAT_ONE;\n\tdspio_set_uint_param(codec, 0x37, 0x08, tmp);\n\tdspio_set_uint_param(codec, 0x37, 0x10, tmp);\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x3C, tmp);\n\n\t \n\ttmp = FLOAT_TWO;\n\tdspio_set_uint_param(codec, 0x31, 0x00, tmp);\n\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n\n\t \n\tdspio_set_uint_param(codec, 0x32, 0x00, tmp);\n\n\tca0132_alt_dsp_initial_mic_setup(codec);\n\tae5_post_dsp_register_set(codec);\n\tae5_post_dsp_param_setup(codec);\n\tae5_post_dsp_pll_setup(codec);\n\tae5_post_dsp_stream_setup(codec);\n\tae5_post_dsp_startup_data(codec);\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\n\tfor (idx = 0; idx < num_fx; idx++) {\n\t\tfor (i = 0; i <= ca0132_effects[idx].params; i++) {\n\t\t\tdspio_set_uint_param(codec,\n\t\t\t\t\tca0132_effects[idx].mid,\n\t\t\t\t\tca0132_effects[idx].reqs[i],\n\t\t\t\t\tca0132_effects[idx].def_vals[i]);\n\t\t}\n\t}\n\n\tca0132_alt_init_speaker_tuning(codec);\n}\n\n \nstatic void ae7_setup_defaults(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp;\n\tint num_fx;\n\tint idx, i;\n\n\tif (spec->dsp_state != DSP_DOWNLOADED)\n\t\treturn;\n\n\tca0132_alt_init_analog_mics(codec);\n\tca0132_alt_start_dsp_audio_streams(codec);\n\tae7_post_dsp_setup_ports(codec);\n\n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_TUNING_FRONT_LEFT_INVERT, tmp);\n\tdspio_set_uint_param(codec, 0x96,\n\t\t\tSPEAKER_TUNING_FRONT_RIGHT_INVERT, tmp);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);\n\n\t \n\tdspio_set_uint_param(codec, 0x80, 0x0d, tmp);\n\tdspio_set_uint_param(codec, 0x80, 0x0e, tmp);\n\n\tca0113_mmio_gpio_set(codec, 0, false);\n\n\t \n\ttmp = FLOAT_ONE;\n\tdspio_set_uint_param(codec, 0x37, 0x08, tmp);\n\tdspio_set_uint_param(codec, 0x37, 0x10, tmp);\n\n\t \n\ttmp = FLOAT_ZERO;\n\tdspio_set_uint_param(codec, 0x96, 0x3C, tmp);\n\n\t \n\ttmp = FLOAT_TWO;\n\tdspio_set_uint_param(codec, 0x31, 0x00, tmp);\n\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n\n\t \n\tdspio_set_uint_param(codec, 0x32, 0x00, tmp);\n\tca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);\n\n\t \n\tca0132_alt_init_analog_mics(codec);\n\n\tae7_post_dsp_asi_setup(codec);\n\n\t \n\tca0113_mmio_gpio_set(codec, 0, true);\n\tca0113_mmio_gpio_set(codec, 1, true);\n\n\t \n\tca0113_mmio_command_set(codec, 0x48, 0x0f, 0x04);\n\tca0113_mmio_command_set(codec, 0x48, 0x10, 0x04);\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x80);\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\n\tfor (idx = 0; idx < num_fx; idx++) {\n\t\tfor (i = 0; i <= ca0132_effects[idx].params; i++) {\n\t\t\tdspio_set_uint_param(codec,\n\t\t\t\t\tca0132_effects[idx].mid,\n\t\t\t\t\tca0132_effects[idx].reqs[i],\n\t\t\t\t\tca0132_effects[idx].def_vals[i]);\n\t\t}\n\t}\n\n\tca0132_alt_init_speaker_tuning(codec);\n}\n\n \nstatic void ca0132_init_flags(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tif (ca0132_use_alt_functions(spec)) {\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_DSP_96KHZ, 1);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_DAC_96KHZ, 1);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_ADC_B_96KHZ, 1);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_96KHZ, 1);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_SRC_RATE_96KHZ, 1);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_SPDIF2OUT, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_A_10KOHM_LOAD, 1);\n\t} else {\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_A_COMMON_MODE, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_D_COMMON_MODE, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_A_10KOHM_LOAD, 0);\n\t\tchipio_set_control_flag(codec,\n\t\t\t\tCONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_HIGH_PASS, 1);\n\t}\n}\n\n \nstatic void ca0132_init_params(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tif (ca0132_use_alt_functions(spec)) {\n\t\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n\t\tchipio_set_conn_rate(codec, 0x0B, SR_48_000);\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_SPDIF1_SOURCE, 0);\n\t\tchipio_set_control_param(codec, 0, 0);\n\t\tchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);\n\t}\n\n\tchipio_set_control_param(codec, CONTROL_PARAM_PORTA_160OHM_GAIN, 6);\n\tchipio_set_control_param(codec, CONTROL_PARAM_PORTD_160OHM_GAIN, 6);\n}\n\nstatic void ca0132_set_dsp_msr(struct hda_codec *codec, bool is96k)\n{\n\tchipio_set_control_flag(codec, CONTROL_FLAG_DSP_96KHZ, is96k);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_DAC_96KHZ, is96k);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_SRC_RATE_96KHZ, is96k);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_SRC_CLOCK_196MHZ, is96k);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_ADC_B_96KHZ, is96k);\n\tchipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_96KHZ, is96k);\n\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\n\tchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\n\tchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\n}\n\nstatic bool ca0132_download_dsp_images(struct hda_codec *codec)\n{\n\tbool dsp_loaded = false;\n\tstruct ca0132_spec *spec = codec->spec;\n\tconst struct dsp_image_seg *dsp_os_image;\n\tconst struct firmware *fw_entry = NULL;\n\t \n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\tcase QUIRK_R3D:\n\tcase QUIRK_AE5:\n\t\tif (request_firmware(&fw_entry, DESKTOP_EFX_FILE,\n\t\t\t\t\tcodec->card->dev) != 0)\n\t\t\tcodec_dbg(codec, \"Desktop firmware not found.\");\n\t\telse\n\t\t\tcodec_dbg(codec, \"Desktop firmware selected.\");\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tif (request_firmware(&fw_entry, R3DI_EFX_FILE,\n\t\t\t\t\tcodec->card->dev) != 0)\n\t\t\tcodec_dbg(codec, \"Recon3Di alt firmware not detected.\");\n\t\telse\n\t\t\tcodec_dbg(codec, \"Recon3Di firmware selected.\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tif (!fw_entry) {\n\t\tcodec_dbg(codec, \"Default firmware selected.\");\n\t\tif (request_firmware(&fw_entry, EFX_FILE,\n\t\t\t\t\tcodec->card->dev) != 0)\n\t\t\treturn false;\n\t}\n\n\tdsp_os_image = (struct dsp_image_seg *)(fw_entry->data);\n\tif (dspload_image(codec, dsp_os_image, 0, 0, true, 0)) {\n\t\tcodec_err(codec, \"ca0132 DSP load image failed\\n\");\n\t\tgoto exit_download;\n\t}\n\n\tdsp_loaded = dspload_wait_loaded(codec);\n\nexit_download:\n\trelease_firmware(fw_entry);\n\n\treturn dsp_loaded;\n}\n\nstatic void ca0132_download_dsp(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n#ifndef CONFIG_SND_HDA_CODEC_CA0132_DSP\n\treturn;  \n#endif\n\n\tif (spec->dsp_state == DSP_DOWNLOAD_FAILED)\n\t\treturn;  \n\n\tchipio_enable_clocks(codec);\n\tif (spec->dsp_state != DSP_DOWNLOADED) {\n\t\tspec->dsp_state = DSP_DOWNLOADING;\n\n\t\tif (!ca0132_download_dsp_images(codec))\n\t\t\tspec->dsp_state = DSP_DOWNLOAD_FAILED;\n\t\telse\n\t\t\tspec->dsp_state = DSP_DOWNLOADED;\n\t}\n\n\t \n\tif (spec->dsp_state == DSP_DOWNLOADED && !ca0132_use_alt_functions(spec))\n\t\tca0132_set_dsp_msr(codec, true);\n}\n\nstatic void ca0132_process_dsp_response(struct hda_codec *codec,\n\t\t\t\t\tstruct hda_jack_callback *callback)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tcodec_dbg(codec, \"ca0132_process_dsp_response\\n\");\n\tsnd_hda_power_up_pm(codec);\n\tif (spec->wait_scp) {\n\t\tif (dspio_get_response_data(codec) >= 0)\n\t\t\tspec->wait_scp = 0;\n\t}\n\n\tdspio_clear_response_queue(codec);\n\tsnd_hda_power_down_pm(codec);\n}\n\nstatic void hp_callback(struct hda_codec *codec, struct hda_jack_callback *cb)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstruct hda_jack_tbl *tbl;\n\n\t \n\ttbl = snd_hda_jack_tbl_get(codec, cb->nid);\n\tif (tbl)\n\t\ttbl->block_report = 1;\n\tschedule_delayed_work(&spec->unsol_hp_work, msecs_to_jiffies(500));\n}\n\nstatic void amic_callback(struct hda_codec *codec, struct hda_jack_callback *cb)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tif (ca0132_use_alt_functions(spec))\n\t\tca0132_alt_select_in(codec);\n\telse\n\t\tca0132_select_mic(codec);\n}\n\nstatic void ca0132_setup_unsol(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tsnd_hda_jack_detect_enable_callback(codec, spec->unsol_tag_hp, hp_callback);\n\tsnd_hda_jack_detect_enable_callback(codec, spec->unsol_tag_amic1,\n\t\t\t\t\t    amic_callback);\n\tsnd_hda_jack_detect_enable_callback(codec, UNSOL_TAG_DSP,\n\t\t\t\t\t    ca0132_process_dsp_response);\n\t \n\tif (ca0132_use_alt_functions(spec))\n\t\tsnd_hda_jack_detect_enable_callback(codec,\n\t\t\tspec->unsol_tag_front_hp, hp_callback);\n}\n\n \n\n \nstatic const struct hda_verb ca0132_base_init_verbs[] = {\n\t \n\t{0x15, VENDOR_CHIPIO_CT_EXTENSIONS_ENABLE, 0x1},\n\t{}\n};\n\n \nstatic const struct hda_verb ca0132_base_exit_verbs[] = {\n\t \n\t{0x01, AC_VERB_SET_POWER_STATE, 0x03},\n\t \n\t{0x15, VENDOR_CHIPIO_CT_EXTENSIONS_ENABLE, 0},\n\t{}\n};\n\n \n\nstatic const struct hda_verb ca0132_init_verbs0[] = {\n\t \n\t{0x15, 0x70D, 0xF0},\n\t{0x15, 0x70E, 0xFE},\n\t{0x15, 0x707, 0x75},\n\t{0x15, 0x707, 0xD3},\n\t{0x15, 0x707, 0x09},\n\t{0x15, 0x707, 0x53},\n\t{0x15, 0x707, 0xD4},\n\t{0x15, 0x707, 0xEF},\n\t{0x15, 0x707, 0x75},\n\t{0x15, 0x707, 0xD3},\n\t{0x15, 0x707, 0x09},\n\t{0x15, 0x707, 0x02},\n\t{0x15, 0x707, 0x37},\n\t{0x15, 0x707, 0x78},\n\t{0x15, 0x53C, 0xCE},\n\t{0x15, 0x575, 0xC9},\n\t{0x15, 0x53D, 0xCE},\n\t{0x15, 0x5B7, 0xC9},\n\t{0x15, 0x70D, 0xE8},\n\t{0x15, 0x70E, 0xFE},\n\t{0x15, 0x707, 0x02},\n\t{0x15, 0x707, 0x68},\n\t{0x15, 0x707, 0x62},\n\t{0x15, 0x53A, 0xCE},\n\t{0x15, 0x546, 0xC9},\n\t{0x15, 0x53B, 0xCE},\n\t{0x15, 0x5E8, 0xC9},\n\t{}\n};\n\n \nstatic const struct hda_verb ca0132_init_verbs1[] = {\n\t{0x15, 0x70D, 0x20},\n\t{0x15, 0x70E, 0x19},\n\t{0x15, 0x707, 0x00},\n\t{0x15, 0x539, 0xCE},\n\t{0x15, 0x546, 0xC9},\n\t{0x15, 0x70D, 0xB7},\n\t{0x15, 0x70E, 0x09},\n\t{0x15, 0x707, 0x10},\n\t{0x15, 0x70D, 0xAF},\n\t{0x15, 0x70E, 0x09},\n\t{0x15, 0x707, 0x01},\n\t{0x15, 0x707, 0x05},\n\t{0x15, 0x70D, 0x73},\n\t{0x15, 0x70E, 0x09},\n\t{0x15, 0x707, 0x14},\n\t{0x15, 0x6FF, 0xC4},\n\t{}\n};\n\nstatic void ca0132_init_chip(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tint num_fx;\n\tint i;\n\tunsigned int on;\n\n\tmutex_init(&spec->chipio_mutex);\n\n\t \n\tif (ca0132_use_alt_functions(spec)) {\n\t\tchipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);\n\t\tchipio_write_no_mutex(codec, 0x18b0a4, 0x000000c2);\n\n\t\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t    AC_VERB_SET_CODEC_RESET, 0);\n\t\tsnd_hda_codec_write(codec, codec->core.afg, 0,\n\t\t\t    AC_VERB_SET_CODEC_RESET, 0);\n\t}\n\n\tspec->cur_out_type = SPEAKER_OUT;\n\tif (!ca0132_use_alt_functions(spec))\n\t\tspec->cur_mic_type = DIGITAL_MIC;\n\telse\n\t\tspec->cur_mic_type = REAR_MIC;\n\n\tspec->cur_mic_boost = 0;\n\n\tfor (i = 0; i < VNODES_COUNT; i++) {\n\t\tspec->vnode_lvol[i] = 0x5a;\n\t\tspec->vnode_rvol[i] = 0x5a;\n\t\tspec->vnode_lswitch[i] = 0;\n\t\tspec->vnode_rswitch[i] = 0;\n\t}\n\n\t \n\tnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\n\tfor (i = 0; i < num_fx; i++) {\n\t\ton = (unsigned int)ca0132_effects[i].reqs[0];\n\t\tspec->effects_switch[i] = on ? 1 : 0;\n\t}\n\t \n\tif (ca0132_use_alt_controls(spec)) {\n\t\t \n\t\tspec->speaker_range_val[0] = 1;\n\t\tspec->speaker_range_val[1] = 1;\n\n\t\tspec->xbass_xover_freq = 8;\n\t\tfor (i = 0; i < EFFECT_LEVEL_SLIDERS; i++)\n\t\t\tspec->fx_ctl_val[i] = effect_slider_defaults[i];\n\n\t\tspec->bass_redirect_xover_freq = 8;\n\t}\n\n\tspec->voicefx_val = 0;\n\tspec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID] = 1;\n\tspec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] = 0;\n\n\t \n\tif (ca0132_quirk(spec) == QUIRK_ZXR)\n\t\tspec->in_enum_val = REAR_MIC;\n\n#ifdef ENABLE_TUNING_CONTROLS\n\tca0132_init_tuning_defaults(codec);\n#endif\n}\n\n \n \nstatic void r3di_gpio_shutdown(struct hda_codec *codec)\n{\n\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA, 0x00);\n}\n\n \nstatic void sbz_region2_exit(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++)\n\t\twriteb(0x0, spec->mem_base + 0x100);\n\tfor (i = 0; i < 8; i++)\n\t\twriteb(0xb3, spec->mem_base + 0x304);\n\n\tca0113_mmio_gpio_set(codec, 0, false);\n\tca0113_mmio_gpio_set(codec, 1, false);\n\tca0113_mmio_gpio_set(codec, 4, true);\n\tca0113_mmio_gpio_set(codec, 5, false);\n\tca0113_mmio_gpio_set(codec, 7, false);\n}\n\nstatic void sbz_set_pin_ctl_default(struct hda_codec *codec)\n{\n\tstatic const hda_nid_t pins[] = {0x0B, 0x0C, 0x0E, 0x12, 0x13};\n\tunsigned int i;\n\n\tsnd_hda_codec_write(codec, 0x11, 0,\n\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0x40);\n\n\tfor (i = 0; i < ARRAY_SIZE(pins); i++)\n\t\tsnd_hda_codec_write(codec, pins[i], 0,\n\t\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0x00);\n}\n\nstatic void ca0132_clear_unsolicited(struct hda_codec *codec)\n{\n\tstatic const hda_nid_t pins[] = {0x0B, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pins); i++) {\n\t\tsnd_hda_codec_write(codec, pins[i], 0,\n\t\t\t\tAC_VERB_SET_UNSOLICITED_ENABLE, 0x00);\n\t}\n}\n\n \nstatic void sbz_gpio_shutdown_commands(struct hda_codec *codec, int dir,\n\t\t\t\t\t\t\tint mask, int data)\n{\n\tif (dir >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DIRECTION, dir);\n\tif (mask >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_MASK, mask);\n\n\tif (data >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, data);\n}\n\nstatic void zxr_dbpro_power_state_shutdown(struct hda_codec *codec)\n{\n\tstatic const hda_nid_t pins[] = {0x05, 0x0c, 0x09, 0x0e, 0x08, 0x11, 0x01};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pins); i++)\n\t\tsnd_hda_codec_write(codec, pins[i], 0,\n\t\t\t\tAC_VERB_SET_POWER_STATE, 0x03);\n}\n\nstatic void sbz_exit_chip(struct hda_codec *codec)\n{\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\n\t \n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, -1);\n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, 0x05);\n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, 0x01);\n\n\tchipio_set_stream_control(codec, 0x14, 0);\n\tchipio_set_stream_control(codec, 0x0C, 0);\n\n\tchipio_set_conn_rate(codec, 0x41, SR_192_000);\n\tchipio_set_conn_rate(codec, 0x91, SR_192_000);\n\n\tchipio_write(codec, 0x18a020, 0x00000083);\n\n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, 0x03);\n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, 0x07);\n\tsbz_gpio_shutdown_commands(codec, 0x07, 0x07, 0x06);\n\n\tchipio_set_stream_control(codec, 0x0C, 0);\n\n\tchipio_set_control_param(codec, 0x0D, 0x24);\n\n\tca0132_clear_unsolicited(codec);\n\tsbz_set_pin_ctl_default(codec);\n\n\tsnd_hda_codec_write(codec, 0x0B, 0,\n\t\tAC_VERB_SET_EAPD_BTLENABLE, 0x00);\n\n\tsbz_region2_exit(codec);\n}\n\nstatic void r3d_exit_chip(struct hda_codec *codec)\n{\n\tca0132_clear_unsolicited(codec);\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x5b);\n}\n\nstatic void ae5_exit_chip(struct hda_codec *codec)\n{\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x32, 0x3f);\n\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x30, 0x30, 0x00);\n\tca0113_mmio_command_set(codec, 0x30, 0x2b, 0x00);\n\tca0113_mmio_command_set(codec, 0x30, 0x2d, 0x00);\n\tca0113_mmio_gpio_set(codec, 0, false);\n\tca0113_mmio_gpio_set(codec, 1, false);\n\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);\n\n\tchipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);\n\n\tchipio_set_stream_control(codec, 0x18, 0);\n\tchipio_set_stream_control(codec, 0x0c, 0);\n\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x724, 0x83);\n}\n\nstatic void ae7_exit_chip(struct hda_codec *codec)\n{\n\tchipio_set_stream_control(codec, 0x18, 0);\n\tchipio_set_stream_source_dest(codec, 0x21, 0xc8, 0xc8);\n\tchipio_set_stream_channels(codec, 0x21, 0);\n\tchipio_set_control_param(codec, CONTROL_PARAM_NODE_ID, 0x09);\n\tchipio_set_control_param(codec, 0x20, 0x01);\n\n\tchipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);\n\n\tchipio_set_stream_control(codec, 0x18, 0);\n\tchipio_set_stream_control(codec, 0x0c, 0);\n\n\tca0113_mmio_command_set(codec, 0x30, 0x2b, 0x00);\n\tsnd_hda_codec_write(codec, 0x15, 0, 0x724, 0x83);\n\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x83);\n\tca0113_mmio_command_set(codec, 0x30, 0x30, 0x00);\n\tca0113_mmio_command_set(codec, 0x30, 0x2e, 0x00);\n\tca0113_mmio_gpio_set(codec, 0, false);\n\tca0113_mmio_gpio_set(codec, 1, false);\n\tca0113_mmio_command_set(codec, 0x30, 0x32, 0x3f);\n\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);\n}\n\nstatic void zxr_exit_chip(struct hda_codec *codec)\n{\n\tchipio_set_stream_control(codec, 0x03, 0);\n\tchipio_set_stream_control(codec, 0x04, 0);\n\tchipio_set_stream_control(codec, 0x14, 0);\n\tchipio_set_stream_control(codec, 0x0C, 0);\n\n\tchipio_set_conn_rate(codec, 0x41, SR_192_000);\n\tchipio_set_conn_rate(codec, 0x91, SR_192_000);\n\n\tchipio_write(codec, 0x18a020, 0x00000083);\n\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);\n\tsnd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);\n\n\tca0132_clear_unsolicited(codec);\n\tsbz_set_pin_ctl_default(codec);\n\tsnd_hda_codec_write(codec, 0x0B, 0, AC_VERB_SET_EAPD_BTLENABLE, 0x00);\n\n\tca0113_mmio_gpio_set(codec, 5, false);\n\tca0113_mmio_gpio_set(codec, 2, false);\n\tca0113_mmio_gpio_set(codec, 3, false);\n\tca0113_mmio_gpio_set(codec, 0, false);\n\tca0113_mmio_gpio_set(codec, 4, true);\n\tca0113_mmio_gpio_set(codec, 0, true);\n\tca0113_mmio_gpio_set(codec, 5, true);\n\tca0113_mmio_gpio_set(codec, 2, false);\n\tca0113_mmio_gpio_set(codec, 3, false);\n}\n\nstatic void ca0132_exit_chip(struct hda_codec *codec)\n{\n\t \n\n\tif (dspload_is_loaded(codec))\n\t\tdsp_reset(codec);\n}\n\n \nstatic void sbz_dsp_startup_check(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int dsp_data_check[4];\n\tunsigned int cur_address = 0x390;\n\tunsigned int i;\n\tunsigned int failure = 0;\n\tunsigned int reload = 3;\n\n\tif (spec->startup_check_entered)\n\t\treturn;\n\n\tspec->startup_check_entered = true;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tchipio_read(codec, cur_address, &dsp_data_check[i]);\n\t\tcur_address += 0x4;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tif (dsp_data_check[i] == 0xa1a2a3a4)\n\t\t\tfailure = 1;\n\t}\n\n\tcodec_dbg(codec, \"Startup Check: %d \", failure);\n\tif (failure)\n\t\tcodec_info(codec, \"DSP not initialized properly. Attempting to fix.\");\n\t \n\twhile (failure && (reload != 0)) {\n\t\tcodec_info(codec, \"Reloading... Tries left: %d\", reload);\n\t\tsbz_exit_chip(codec);\n\t\tspec->dsp_state = DSP_DOWNLOAD_INIT;\n\t\tcodec->patch_ops.init(codec);\n\t\tfailure = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tchipio_read(codec, cur_address, &dsp_data_check[i]);\n\t\t\tcur_address += 0x4;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (dsp_data_check[i] == 0xa1a2a3a4)\n\t\t\t\tfailure = 1;\n\t\t}\n\t\treload--;\n\t}\n\n\tif (!failure && reload < 3)\n\t\tcodec_info(codec, \"DSP fixed.\");\n\n\tif (!failure)\n\t\treturn;\n\n\tcodec_info(codec, \"DSP failed to initialize properly. Either try a full shutdown or a suspend to clear the internal memory.\");\n}\n\n \nstatic void ca0132_alt_vol_setup(struct hda_codec *codec)\n{\n\tsnd_hda_codec_write(codec, 0x02, 0, 0x797, 0x00);\n\tsnd_hda_codec_write(codec, 0x02, 0, 0x798, 0x00);\n\tsnd_hda_codec_write(codec, 0x03, 0, 0x797, 0x00);\n\tsnd_hda_codec_write(codec, 0x03, 0, 0x798, 0x00);\n\tsnd_hda_codec_write(codec, 0x04, 0, 0x797, 0x00);\n\tsnd_hda_codec_write(codec, 0x04, 0, 0x798, 0x00);\n\tsnd_hda_codec_write(codec, 0x07, 0, 0x797, 0x00);\n\tsnd_hda_codec_write(codec, 0x07, 0, 0x798, 0x00);\n}\n\n \nstatic void sbz_pre_dsp_setup(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\twritel(0x00820680, spec->mem_base + 0x01C);\n\twritel(0x00820680, spec->mem_base + 0x01C);\n\n\tchipio_write(codec, 0x18b0a4, 0x000000c2);\n\n\tsnd_hda_codec_write(codec, 0x11, 0,\n\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0x44);\n}\n\nstatic void r3d_pre_dsp_setup(struct hda_codec *codec)\n{\n\tchipio_write(codec, 0x18b0a4, 0x000000c2);\n\n\tchipio_8051_write_exram(codec, 0x1c1e, 0x5b);\n\n\tsnd_hda_codec_write(codec, 0x11, 0,\n\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0x44);\n}\n\nstatic void r3di_pre_dsp_setup(struct hda_codec *codec)\n{\n\tchipio_write(codec, 0x18b0a4, 0x000000c2);\n\n\tchipio_8051_write_exram(codec, 0x1c1e, 0x5b);\n\tchipio_8051_write_exram(codec, 0x1920, 0x00);\n\tchipio_8051_write_exram(codec, 0x1921, 0x40);\n\n\tsnd_hda_codec_write(codec, 0x11, 0,\n\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0x04);\n}\n\n \nstatic void zxr_pre_dsp_setup(struct hda_codec *codec)\n{\n\tstatic const unsigned int addr[] = { 0x43, 0x40, 0x41, 0x42, 0x45 };\n\tstatic const unsigned int data[] = { 0x08, 0x0c, 0x0b, 0x07, 0x0d };\n\tunsigned int i;\n\n\tchipio_write(codec, 0x189000, 0x0001f100);\n\tmsleep(50);\n\tchipio_write(codec, 0x18900c, 0x0001f100);\n\tmsleep(50);\n\n\t \n\tchipio_8051_write_exram(codec, 0xfa92, 0x22);\n\n\tchipio_8051_write_pll_pmu(codec, 0x51, 0x98);\n\n\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x82);\n\tchipio_set_control_param(codec, CONTROL_PARAM_ASI, 3);\n\n\tchipio_write(codec, 0x18902c, 0x00000000);\n\tmsleep(50);\n\tchipio_write(codec, 0x18902c, 0x00000003);\n\tmsleep(50);\n\n\tfor (i = 0; i < ARRAY_SIZE(addr); i++)\n\t\tchipio_8051_write_pll_pmu(codec, addr[i], data[i]);\n}\n\n \nstatic const unsigned int ca0113_mmio_init_address_sbz[] = {\n\t0x400, 0x408, 0x40c, 0x01c, 0xc0c, 0xc00, 0xc04, 0xc0c, 0xc0c, 0xc0c,\n\t0xc0c, 0xc08, 0xc08, 0xc08, 0xc08, 0xc08, 0xc04\n};\n\nstatic const unsigned int ca0113_mmio_init_data_sbz[] = {\n\t0x00000030, 0x00000000, 0x00000003, 0x00000003, 0x00000003,\n\t0x00000003, 0x000000c1, 0x000000f1, 0x00000001, 0x000000c7,\n\t0x000000c1, 0x00000080\n};\n\nstatic const unsigned int ca0113_mmio_init_data_zxr[] = {\n\t0x00000030, 0x00000000, 0x00000000, 0x00000003, 0x00000003,\n\t0x00000003, 0x00000001, 0x000000f1, 0x00000001, 0x000000c7,\n\t0x000000c1, 0x00000080\n};\n\nstatic const unsigned int ca0113_mmio_init_address_ae5[] = {\n\t0x400, 0x42c, 0x46c, 0x4ac, 0x4ec, 0x43c, 0x47c, 0x4bc, 0x4fc, 0x408,\n\t0x100, 0x410, 0x40c, 0x100, 0x100, 0x830, 0x86c, 0x800, 0x86c, 0x800,\n\t0x804, 0x20c, 0x01c, 0xc0c, 0xc00, 0xc04, 0xc0c, 0xc0c, 0xc0c, 0xc0c,\n\t0xc08, 0xc08, 0xc08, 0xc08, 0xc08, 0xc04, 0x01c\n};\n\nstatic const unsigned int ca0113_mmio_init_data_ae5[] = {\n\t0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001,\n\t0x00000600, 0x00000014, 0x00000001, 0x0000060f, 0x0000070f,\n\t0x00000aff, 0x00000000, 0x0000006b, 0x00000001, 0x0000006b,\n\t0x00000057, 0x00800000, 0x00880680, 0x00000080, 0x00000030,\n\t0x00000000, 0x00000000, 0x00000003, 0x00000003, 0x00000003,\n\t0x00000001, 0x000000f1, 0x00000001, 0x000000c7, 0x000000c1,\n\t0x00000080, 0x00880680\n};\n\nstatic void ca0132_mmio_init_sbz(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int tmp[2], i, count, cur_addr;\n\tconst unsigned int *addr, *data;\n\n\taddr = ca0113_mmio_init_address_sbz;\n\tfor (i = 0; i < 3; i++)\n\t\twritel(0x00000000, spec->mem_base + addr[i]);\n\n\tcur_addr = i;\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_ZXR:\n\t\ttmp[0] = 0x00880480;\n\t\ttmp[1] = 0x00000080;\n\t\tbreak;\n\tcase QUIRK_SBZ:\n\t\ttmp[0] = 0x00820680;\n\t\ttmp[1] = 0x00000083;\n\t\tbreak;\n\tcase QUIRK_R3D:\n\t\ttmp[0] = 0x00880680;\n\t\ttmp[1] = 0x00000083;\n\t\tbreak;\n\tdefault:\n\t\ttmp[0] = 0x00000000;\n\t\ttmp[1] = 0x00000000;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 2; i++)\n\t\twritel(tmp[i], spec->mem_base + addr[cur_addr + i]);\n\n\tcur_addr += i;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_ZXR:\n\t\tcount = ARRAY_SIZE(ca0113_mmio_init_data_zxr);\n\t\tdata = ca0113_mmio_init_data_zxr;\n\t\tbreak;\n\tdefault:\n\t\tcount = ARRAY_SIZE(ca0113_mmio_init_data_sbz);\n\t\tdata = ca0113_mmio_init_data_sbz;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < count; i++)\n\t\twritel(data[i], spec->mem_base + addr[cur_addr + i]);\n}\n\nstatic void ca0132_mmio_init_ae5(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tconst unsigned int *addr, *data;\n\tunsigned int i, count;\n\n\taddr = ca0113_mmio_init_address_ae5;\n\tdata = ca0113_mmio_init_data_ae5;\n\tcount = ARRAY_SIZE(ca0113_mmio_init_data_ae5);\n\n\tif (ca0132_quirk(spec) == QUIRK_AE7) {\n\t\twritel(0x00000680, spec->mem_base + 0x1c);\n\t\twritel(0x00880680, spec->mem_base + 0x1c);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (i == 21 && ca0132_quirk(spec) == QUIRK_AE7) {\n\t\t\twritel(0x00800001, spec->mem_base + addr[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\twritel(data[i], spec->mem_base + addr[i]);\n\t}\n\n\tif (ca0132_quirk(spec) == QUIRK_AE5)\n\t\twritel(0x00880680, spec->mem_base + 0x1c);\n}\n\nstatic void ca0132_mmio_init(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_R3D:\n\tcase QUIRK_SBZ:\n\tcase QUIRK_ZXR:\n\t\tca0132_mmio_init_sbz(codec);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tca0132_mmio_init_ae5(codec);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const unsigned int ca0132_ae5_register_set_addresses[] = {\n\t0x304, 0x304, 0x304, 0x304, 0x100, 0x304, 0x100, 0x304, 0x100, 0x304,\n\t0x100, 0x304, 0x86c, 0x800, 0x86c, 0x800, 0x804\n};\n\nstatic const unsigned char ca0132_ae5_register_set_data[] = {\n\t0x0f, 0x0e, 0x1f, 0x0c, 0x3f, 0x08, 0x7f, 0x00, 0xff, 0x00, 0x6b,\n\t0x01, 0x6b, 0x57\n};\n\n \nstatic void ae5_register_set(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tunsigned int count = ARRAY_SIZE(ca0132_ae5_register_set_addresses);\n\tconst unsigned int *addr = ca0132_ae5_register_set_addresses;\n\tconst unsigned char *data = ca0132_ae5_register_set_data;\n\tunsigned int i, cur_addr;\n\tunsigned char tmp[3];\n\n\tif (ca0132_quirk(spec) == QUIRK_AE7)\n\t\tchipio_8051_write_pll_pmu(codec, 0x41, 0xc8);\n\n\tchipio_8051_write_direct(codec, 0x93, 0x10);\n\tchipio_8051_write_pll_pmu(codec, 0x44, 0xc2);\n\n\tif (ca0132_quirk(spec) == QUIRK_AE7) {\n\t\ttmp[0] = 0x03;\n\t\ttmp[1] = 0x03;\n\t\ttmp[2] = 0x07;\n\t} else {\n\t\ttmp[0] = 0x0f;\n\t\ttmp[1] = 0x0f;\n\t\ttmp[2] = 0x0f;\n\t}\n\n\tfor (i = cur_addr = 0; i < 3; i++, cur_addr++)\n\t\twriteb(tmp[i], spec->mem_base + addr[cur_addr]);\n\n\t \n\tfor (i = 0; cur_addr < 12; i++, cur_addr++)\n\t\twriteb(data[i], spec->mem_base + addr[cur_addr]);\n\n\tfor (; cur_addr < count; i++, cur_addr++)\n\t\twritel(data[i], spec->mem_base + addr[cur_addr]);\n\n\twritel(0x00800001, spec->mem_base + 0x20c);\n\n\tif (ca0132_quirk(spec) == QUIRK_AE7) {\n\t\tca0113_mmio_command_set_type2(codec, 0x48, 0x07, 0x83);\n\t\tca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);\n\t} else {\n\t\tca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);\n\t}\n\n\tchipio_8051_write_direct(codec, 0x90, 0x00);\n\tchipio_8051_write_direct(codec, 0x90, 0x10);\n\n\tif (ca0132_quirk(spec) == QUIRK_AE5)\n\t\tca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);\n}\n\n \nstatic void ca0132_alt_init(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tca0132_alt_vol_setup(codec);\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tcodec_dbg(codec, \"SBZ alt_init\");\n\t\tca0132_gpio_init(codec);\n\t\tsbz_pre_dsp_setup(codec);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_sequence_write(codec, spec->desktop_init_verbs);\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tcodec_dbg(codec, \"R3DI alt_init\");\n\t\tca0132_gpio_init(codec);\n\t\tca0132_gpio_setup(codec);\n\t\tr3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADING);\n\t\tr3di_pre_dsp_setup(codec);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x6FF, 0xC4);\n\t\tbreak;\n\tcase QUIRK_R3D:\n\t\tr3d_pre_dsp_setup(codec);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_sequence_write(codec, spec->desktop_init_verbs);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tca0132_gpio_init(codec);\n\t\tchipio_8051_write_pll_pmu(codec, 0x49, 0x88);\n\t\tchipio_write(codec, 0x18b030, 0x00000020);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_sequence_write(codec, spec->desktop_init_verbs);\n\t\tca0113_mmio_command_set(codec, 0x30, 0x32, 0x3f);\n\t\tbreak;\n\tcase QUIRK_AE7:\n\t\tca0132_gpio_init(codec);\n\t\tchipio_8051_write_pll_pmu(codec, 0x49, 0x88);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_sequence_write(codec, spec->desktop_init_verbs);\n\t\tchipio_write(codec, 0x18b008, 0x000000f8);\n\t\tchipio_write(codec, 0x18b008, 0x000000f0);\n\t\tchipio_write(codec, 0x18b030, 0x00000020);\n\t\tca0113_mmio_command_set(codec, 0x30, 0x32, 0x3f);\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tchipio_8051_write_pll_pmu(codec, 0x49, 0x88);\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_sequence_write(codec, spec->desktop_init_verbs);\n\t\tzxr_pre_dsp_setup(codec);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int ca0132_init(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i;\n\tbool dsp_loaded;\n\n\t \n\tif (spec->dsp_state == DSP_DOWNLOADED) {\n\t\tdsp_loaded = dspload_is_loaded(codec);\n\t\tif (!dsp_loaded) {\n\t\t\tspec->dsp_reload = true;\n\t\t\tspec->dsp_state = DSP_DOWNLOAD_INIT;\n\t\t} else {\n\t\t\tif (ca0132_quirk(spec) == QUIRK_SBZ)\n\t\t\t\tsbz_dsp_startup_check(codec);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (spec->dsp_state != DSP_DOWNLOAD_FAILED)\n\t\tspec->dsp_state = DSP_DOWNLOAD_INIT;\n\tspec->curr_chip_addx = INVALID_CHIP_ADDRESS;\n\n\tif (ca0132_use_pci_mmio(spec))\n\t\tca0132_mmio_init(codec);\n\n\tsnd_hda_power_up_pm(codec);\n\n\tif (ca0132_quirk(spec) == QUIRK_AE5 || ca0132_quirk(spec) == QUIRK_AE7)\n\t\tae5_register_set(codec);\n\n\tca0132_init_params(codec);\n\tca0132_init_flags(codec);\n\n\tsnd_hda_sequence_write(codec, spec->base_init_verbs);\n\n\tif (ca0132_use_alt_functions(spec))\n\t\tca0132_alt_init(codec);\n\n\tca0132_download_dsp(codec);\n\n\tca0132_refresh_widget_caps(codec);\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_R3DI:\n\tcase QUIRK_R3D:\n\t\tr3d_setup_defaults(codec);\n\t\tbreak;\n\tcase QUIRK_SBZ:\n\tcase QUIRK_ZXR:\n\t\tsbz_setup_defaults(codec);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tae5_setup_defaults(codec);\n\t\tbreak;\n\tcase QUIRK_AE7:\n\t\tae7_setup_defaults(codec);\n\t\tbreak;\n\tdefault:\n\t\tca0132_setup_defaults(codec);\n\t\tca0132_init_analog_mic2(codec);\n\t\tca0132_init_dmic(codec);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < spec->num_outputs; i++)\n\t\tinit_output(codec, spec->out_pins[i], spec->dacs[0]);\n\n\tinit_output(codec, cfg->dig_out_pins[0], spec->dig_out);\n\n\tfor (i = 0; i < spec->num_inputs; i++)\n\t\tinit_input(codec, spec->input_pins[i], spec->adcs[i]);\n\n\tinit_input(codec, cfg->dig_in_pin, spec->dig_in);\n\n\tif (!ca0132_use_alt_functions(spec)) {\n\t\tsnd_hda_sequence_write(codec, spec->chip_init_verbs);\n\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PARAM_EX_ID_SET, 0x0D);\n\t\tsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\n\t\t\t    VENDOR_CHIPIO_PARAM_EX_VALUE_SET, 0x20);\n\t}\n\n\tif (ca0132_quirk(spec) == QUIRK_SBZ)\n\t\tca0132_gpio_setup(codec);\n\n\tsnd_hda_sequence_write(codec, spec->spec_init_verbs);\n\tif (ca0132_use_alt_functions(spec)) {\n\t\tca0132_alt_select_out(codec);\n\t\tca0132_alt_select_in(codec);\n\t} else {\n\t\tca0132_select_out(codec);\n\t\tca0132_select_mic(codec);\n\t}\n\n\tsnd_hda_jack_report_sync(codec);\n\n\t \n\tif (spec->dsp_reload) {\n\t\tspec->dsp_reload = false;\n\t\tca0132_pe_switch_set(codec);\n\t}\n\n\tsnd_hda_power_down_pm(codec);\n\n\treturn 0;\n}\n\nstatic int dbpro_init(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int i;\n\n\tinit_output(codec, cfg->dig_out_pins[0], spec->dig_out);\n\tinit_input(codec, cfg->dig_in_pin, spec->dig_in);\n\n\tfor (i = 0; i < spec->num_inputs; i++)\n\t\tinit_input(codec, spec->input_pins[i], spec->adcs[i]);\n\n\treturn 0;\n}\n\nstatic void ca0132_free(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tcancel_delayed_work_sync(&spec->unsol_hp_work);\n\tsnd_hda_power_up(codec);\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tsbz_exit_chip(codec);\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tzxr_exit_chip(codec);\n\t\tbreak;\n\tcase QUIRK_R3D:\n\t\tr3d_exit_chip(codec);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tae5_exit_chip(codec);\n\t\tbreak;\n\tcase QUIRK_AE7:\n\t\tae7_exit_chip(codec);\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tr3di_gpio_shutdown(codec);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnd_hda_sequence_write(codec, spec->base_exit_verbs);\n\tca0132_exit_chip(codec);\n\n\tsnd_hda_power_down(codec);\n#ifdef CONFIG_PCI\n\tif (spec->mem_base)\n\t\tpci_iounmap(codec->bus->pci, spec->mem_base);\n#endif\n\tkfree(spec->spec_init_verbs);\n\tkfree(codec->spec);\n}\n\nstatic void dbpro_free(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tzxr_dbpro_power_state_shutdown(codec);\n\n\tkfree(spec->spec_init_verbs);\n\tkfree(codec->spec);\n}\n\n#ifdef CONFIG_PM\nstatic int ca0132_suspend(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tcancel_delayed_work_sync(&spec->unsol_hp_work);\n\treturn 0;\n}\n#endif\n\nstatic const struct hda_codec_ops ca0132_patch_ops = {\n\t.build_controls = ca0132_build_controls,\n\t.build_pcms = ca0132_build_pcms,\n\t.init = ca0132_init,\n\t.free = ca0132_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = ca0132_suspend,\n#endif\n};\n\nstatic const struct hda_codec_ops dbpro_patch_ops = {\n\t.build_controls = dbpro_build_controls,\n\t.build_pcms = dbpro_build_pcms,\n\t.init = dbpro_init,\n\t.free = dbpro_free,\n};\n\nstatic void ca0132_config(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tspec->dacs[0] = 0x2;\n\tspec->dacs[1] = 0x3;\n\tspec->dacs[2] = 0x4;\n\n\tspec->multiout.dac_nids = spec->dacs;\n\tspec->multiout.num_dacs = 3;\n\n\tif (!ca0132_use_alt_functions(spec))\n\t\tspec->multiout.max_channels = 2;\n\telse\n\t\tspec->multiout.max_channels = 6;\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_ALIENWARE:\n\t\tcodec_dbg(codec, \"%s: QUIRK_ALIENWARE applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, alienware_pincfgs);\n\t\tbreak;\n\tcase QUIRK_SBZ:\n\t\tcodec_dbg(codec, \"%s: QUIRK_SBZ applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, sbz_pincfgs);\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tcodec_dbg(codec, \"%s: QUIRK_ZXR applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, zxr_pincfgs);\n\t\tbreak;\n\tcase QUIRK_R3D:\n\t\tcodec_dbg(codec, \"%s: QUIRK_R3D applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, r3d_pincfgs);\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tcodec_dbg(codec, \"%s: QUIRK_R3DI applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, r3di_pincfgs);\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tcodec_dbg(codec, \"%s: QUIRK_AE5 applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, ae5_pincfgs);\n\t\tbreak;\n\tcase QUIRK_AE7:\n\t\tcodec_dbg(codec, \"%s: QUIRK_AE7 applied.\\n\", __func__);\n\t\tsnd_hda_apply_pincfgs(codec, ae7_pincfgs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_ALIENWARE:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0b;  \n\t\tspec->out_pins[1] = 0x0f;\n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = 0x0f;\n\n\t\tspec->adcs[0] = 0x7;  \n\t\tspec->adcs[1] = 0x8;  \n\t\tspec->adcs[2] = 0xa;  \n\n\t\tspec->num_inputs = 3;\n\t\tspec->input_pins[0] = 0x12;\n\t\tspec->input_pins[1] = 0x11;\n\t\tspec->input_pins[2] = 0x13;\n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = 0x11;\n\t\tbreak;\n\tcase QUIRK_SBZ:\n\tcase QUIRK_R3D:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0B;  \n\t\tspec->out_pins[1] = 0x0F;  \n\t\tspec->out_pins[2] = 0x10;  \n\t\tspec->out_pins[3] = 0x11;  \n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = spec->out_pins[1];\n\t\tspec->unsol_tag_front_hp = spec->out_pins[2];\n\n\t\tspec->adcs[0] = 0x7;  \n\t\tspec->adcs[1] = 0x8;  \n\t\tspec->adcs[2] = 0xa;  \n\n\t\tspec->num_inputs = 2;\n\t\tspec->input_pins[0] = 0x12;  \n\t\tspec->input_pins[1] = 0x13;  \n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = spec->input_pins[0];\n\n\t\t \n\t\tspec->dig_out = 0x05;\n\t\tspec->multiout.dig_out_nid = spec->dig_out;\n\t\tspec->dig_in = 0x09;\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0B;  \n\t\tspec->out_pins[1] = 0x0F;  \n\t\tspec->out_pins[2] = 0x10;  \n\t\tspec->out_pins[3] = 0x11;  \n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = spec->out_pins[1];\n\t\tspec->unsol_tag_front_hp = spec->out_pins[2];\n\n\t\tspec->adcs[0] = 0x7;  \n\t\tspec->adcs[1] = 0x8;  \n\t\tspec->adcs[2] = 0xa;  \n\n\t\tspec->num_inputs = 2;\n\t\tspec->input_pins[0] = 0x12;  \n\t\tspec->input_pins[1] = 0x13;  \n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = spec->input_pins[0];\n\t\tbreak;\n\tcase QUIRK_ZXR_DBPRO:\n\t\tspec->adcs[0] = 0x8;  \n\n\t\tspec->num_inputs = 1;\n\t\tspec->input_pins[0] = 0x11;  \n\n\t\tspec->dig_out = 0x05;\n\t\tspec->multiout.dig_out_nid = spec->dig_out;\n\n\t\tspec->dig_in = 0x09;\n\t\tbreak;\n\tcase QUIRK_AE5:\n\tcase QUIRK_AE7:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0B;  \n\t\tspec->out_pins[1] = 0x11;  \n\t\tspec->out_pins[2] = 0x10;  \n\t\tspec->out_pins[3] = 0x0F;  \n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = spec->out_pins[1];\n\t\tspec->unsol_tag_front_hp = spec->out_pins[2];\n\n\t\tspec->adcs[0] = 0x7;  \n\t\tspec->adcs[1] = 0x8;  \n\t\tspec->adcs[2] = 0xa;  \n\n\t\tspec->num_inputs = 2;\n\t\tspec->input_pins[0] = 0x12;  \n\t\tspec->input_pins[1] = 0x13;  \n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = spec->input_pins[0];\n\n\t\t \n\t\tspec->dig_out = 0x05;\n\t\tspec->multiout.dig_out_nid = spec->dig_out;\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0B;  \n\t\tspec->out_pins[1] = 0x0F;  \n\t\tspec->out_pins[2] = 0x10;  \n\t\tspec->out_pins[3] = 0x11;  \n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = spec->out_pins[1];\n\t\tspec->unsol_tag_front_hp = spec->out_pins[2];\n\n\t\tspec->adcs[0] = 0x07;  \n\t\tspec->adcs[1] = 0x08;  \n\t\tspec->adcs[2] = 0x0a;  \n\n\t\tspec->num_inputs = 2;\n\t\tspec->input_pins[0] = 0x12;  \n\t\tspec->input_pins[1] = 0x13;  \n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = spec->input_pins[0];\n\n\t\t \n\t\tspec->dig_out = 0x05;\n\t\tspec->multiout.dig_out_nid = spec->dig_out;\n\t\tbreak;\n\tdefault:\n\t\tspec->num_outputs = 2;\n\t\tspec->out_pins[0] = 0x0b;  \n\t\tspec->out_pins[1] = 0x10;  \n\t\tspec->shared_out_nid = 0x2;\n\t\tspec->unsol_tag_hp = spec->out_pins[1];\n\n\t\tspec->adcs[0] = 0x7;  \n\t\tspec->adcs[1] = 0x8;  \n\t\tspec->adcs[2] = 0xa;  \n\n\t\tspec->num_inputs = 3;\n\t\tspec->input_pins[0] = 0x12;\n\t\tspec->input_pins[1] = 0x11;\n\t\tspec->input_pins[2] = 0x13;\n\t\tspec->shared_mic_nid = 0x7;\n\t\tspec->unsol_tag_amic1 = spec->input_pins[0];\n\n\t\t \n\t\tspec->dig_out = 0x05;\n\t\tspec->multiout.dig_out_nid = spec->dig_out;\n\t\tspec->dig_in = 0x09;\n\t\tbreak;\n\t}\n}\n\nstatic int ca0132_prepare_verbs(struct hda_codec *codec)\n{\n \n#define NUM_SPEC_VERBS 2\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tspec->chip_init_verbs = ca0132_init_verbs0;\n\t \n\tif (ca0132_use_pci_mmio(spec))\n\t\tspec->desktop_init_verbs = ca0132_init_verbs1;\n\tspec->spec_init_verbs = kcalloc(NUM_SPEC_VERBS,\n\t\t\t\t\tsizeof(struct hda_verb),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!spec->spec_init_verbs)\n\t\treturn -ENOMEM;\n\n\t \n\tspec->spec_init_verbs[0].nid = 0x0b;\n\tspec->spec_init_verbs[0].param = 0x78D;\n\tspec->spec_init_verbs[0].verb = 0x00;\n\n\t \n\t \n\n\t \n\treturn 0;\n}\n\n \nstatic void sbz_detect_quirk(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec = codec->spec;\n\n\tswitch (codec->core.subsystem_id) {\n\tcase 0x11020033:\n\t\tspec->quirk = QUIRK_ZXR;\n\t\tbreak;\n\tcase 0x1102003f:\n\t\tspec->quirk = QUIRK_ZXR_DBPRO;\n\t\tbreak;\n\tdefault:\n\t\tspec->quirk = QUIRK_SBZ;\n\t\tbreak;\n\t}\n}\n\nstatic int patch_ca0132(struct hda_codec *codec)\n{\n\tstruct ca0132_spec *spec;\n\tint err;\n\tconst struct snd_pci_quirk *quirk;\n\n\tcodec_dbg(codec, \"patch_ca0132\\n\");\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tcodec->spec = spec;\n\tspec->codec = codec;\n\n\t \n\tquirk = snd_pci_quirk_lookup(codec->bus->pci, ca0132_quirks);\n\tif (quirk)\n\t\tspec->quirk = quirk->value;\n\telse\n\t\tspec->quirk = QUIRK_NONE;\n\tif (ca0132_quirk(spec) == QUIRK_SBZ)\n\t\tsbz_detect_quirk(codec);\n\n\tif (ca0132_quirk(spec) == QUIRK_ZXR_DBPRO)\n\t\tcodec->patch_ops = dbpro_patch_ops;\n\telse\n\t\tcodec->patch_ops = ca0132_patch_ops;\n\n\tcodec->pcm_format_first = 1;\n\tcodec->no_sticky_stream = 1;\n\n\n\tspec->dsp_state = DSP_DOWNLOAD_INIT;\n\tspec->num_mixers = 1;\n\n\t \n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\t\tspec->mixers[0] = desktop_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Sound Blaster Z\");\n\t\tbreak;\n\tcase QUIRK_ZXR:\n\t\tspec->mixers[0] = desktop_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Sound Blaster ZxR\");\n\t\tbreak;\n\tcase QUIRK_ZXR_DBPRO:\n\t\tbreak;\n\tcase QUIRK_R3D:\n\t\tspec->mixers[0] = desktop_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Recon3D\");\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tspec->mixers[0] = r3di_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Recon3Di\");\n\t\tbreak;\n\tcase QUIRK_AE5:\n\t\tspec->mixers[0] = desktop_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Sound BlasterX AE-5\");\n\t\tbreak;\n\tcase QUIRK_AE7:\n\t\tspec->mixers[0] = desktop_mixer;\n\t\tsnd_hda_codec_set_name(codec, \"Sound Blaster AE-7\");\n\t\tbreak;\n\tdefault:\n\t\tspec->mixers[0] = ca0132_mixer;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ca0132_quirk(spec)) {\n\tcase QUIRK_SBZ:\n\tcase QUIRK_R3D:\n\tcase QUIRK_AE5:\n\tcase QUIRK_AE7:\n\tcase QUIRK_ZXR:\n\t\tspec->use_alt_controls = true;\n\t\tspec->use_alt_functions = true;\n\t\tspec->use_pci_mmio = true;\n\t\tbreak;\n\tcase QUIRK_R3DI:\n\t\tspec->use_alt_controls = true;\n\t\tspec->use_alt_functions = true;\n\t\tspec->use_pci_mmio = false;\n\t\tbreak;\n\tdefault:\n\t\tspec->use_alt_controls = false;\n\t\tspec->use_alt_functions = false;\n\t\tspec->use_pci_mmio = false;\n\t\tbreak;\n\t}\n\n#ifdef CONFIG_PCI\n\tif (spec->use_pci_mmio) {\n\t\tspec->mem_base = pci_iomap(codec->bus->pci, 2, 0xC20);\n\t\tif (spec->mem_base == NULL) {\n\t\t\tcodec_warn(codec, \"pci_iomap failed! Setting quirk to QUIRK_NONE.\");\n\t\t\tspec->quirk = QUIRK_NONE;\n\t\t}\n\t}\n#endif\n\n\tspec->base_init_verbs = ca0132_base_init_verbs;\n\tspec->base_exit_verbs = ca0132_base_exit_verbs;\n\n\tINIT_DELAYED_WORK(&spec->unsol_hp_work, ca0132_unsol_hp_delayed);\n\n\tca0132_init_chip(codec);\n\n\tca0132_config(codec);\n\n\terr = ca0132_prepare_verbs(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);\n\tif (err < 0)\n\t\tgoto error;\n\n\tca0132_setup_unsol(codec);\n\n\treturn 0;\n\n error:\n\tca0132_free(codec);\n\treturn err;\n}\n\n \nstatic const struct hda_device_id snd_hda_id_ca0132[] = {\n\tHDA_CODEC_ENTRY(0x11020011, \"CA0132\", patch_ca0132),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_ca0132);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Creative Sound Core3D codec\");\n\nstatic struct hda_codec_driver ca0132_driver = {\n\t.id = snd_hda_id_ca0132,\n};\n\nmodule_hda_codec_driver(ca0132_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}