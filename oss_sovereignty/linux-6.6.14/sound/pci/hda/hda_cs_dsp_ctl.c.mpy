{
  "module_name": "hda_cs_dsp_ctl.c",
  "hash_id": "7881c0156c9b241f302f19efd07946b0e2048fe8c483901a54a60caf12c891a1",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_cs_dsp_ctl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <sound/soc.h>\n#include <linux/firmware/cirrus/cs_dsp.h>\n#include <linux/firmware/cirrus/wmfw.h>\n#include \"hda_cs_dsp_ctl.h\"\n\n#define ADSP_MAX_STD_CTRL_SIZE               512\n\nstruct hda_cs_dsp_coeff_ctl {\n\tstruct cs_dsp_coeff_ctl *cs_ctl;\n\tstruct snd_card *card;\n\tstruct snd_kcontrol *kctl;\n};\n\nstatic const char * const hda_cs_dsp_fw_text[HDA_CS_DSP_NUM_FW] = {\n\t[HDA_CS_DSP_FW_SPK_PROT] = \"Prot\",\n\t[HDA_CS_DSP_FW_SPK_CALI] = \"Cali\",\n\t[HDA_CS_DSP_FW_SPK_DIAG] = \"Diag\",\n\t[HDA_CS_DSP_FW_MISC] =     \"Misc\",\n};\n\nconst char * const hda_cs_dsp_fw_ids[HDA_CS_DSP_NUM_FW] = {\n\t[HDA_CS_DSP_FW_SPK_PROT] = \"spk-prot\",\n\t[HDA_CS_DSP_FW_SPK_CALI] = \"spk-cali\",\n\t[HDA_CS_DSP_FW_SPK_DIAG] = \"spk-diag\",\n\t[HDA_CS_DSP_FW_MISC] =     \"misc\",\n};\nEXPORT_SYMBOL_NS_GPL(hda_cs_dsp_fw_ids, SND_HDA_CS_DSP_CONTROLS);\n\nstatic int hda_cs_dsp_coeff_info(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_cs_dsp_coeff_ctl *ctl = (struct hda_cs_dsp_coeff_ctl *)snd_kcontrol_chip(kctl);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = cs_ctl->len;\n\n\treturn 0;\n}\n\nstatic int hda_cs_dsp_coeff_put(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_cs_dsp_coeff_ctl *ctl = (struct hda_cs_dsp_coeff_ctl *)snd_kcontrol_chip(kctl);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tchar *p = ucontrol->value.bytes.data;\n\tint ret = 0;\n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\tret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, p, cs_ctl->len);\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\treturn ret;\n}\n\nstatic int hda_cs_dsp_coeff_get(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_cs_dsp_coeff_ctl *ctl = (struct hda_cs_dsp_coeff_ctl *)snd_kcontrol_chip(kctl);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tchar *p = ucontrol->value.bytes.data;\n\tint ret;\n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\tret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, p, cs_ctl->len);\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\treturn ret;\n}\n\nstatic unsigned int wmfw_convert_flags(unsigned int in)\n{\n\tunsigned int out, rd, wr, vol;\n\n\trd = SNDRV_CTL_ELEM_ACCESS_READ;\n\twr = SNDRV_CTL_ELEM_ACCESS_WRITE;\n\tvol = SNDRV_CTL_ELEM_ACCESS_VOLATILE;\n\n\tout = 0;\n\n\tif (in) {\n\t\tout |= rd;\n\t\tif (in & WMFW_CTL_FLAG_WRITEABLE)\n\t\t\tout |= wr;\n\t\tif (in & WMFW_CTL_FLAG_VOLATILE)\n\t\t\tout |= vol;\n\t} else {\n\t\tout |= rd | wr | vol;\n\t}\n\n\treturn out;\n}\n\nstatic void hda_cs_dsp_add_kcontrol(struct hda_cs_dsp_coeff_ctl *ctl, const char *name)\n{\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tstruct snd_kcontrol_new kcontrol = {0};\n\tstruct snd_kcontrol *kctl;\n\tint ret = 0;\n\n\tif (cs_ctl->len > ADSP_MAX_STD_CTRL_SIZE) {\n\t\tdev_err(cs_ctl->dsp->dev, \"KControl %s: length %zu exceeds maximum %d\\n\", name,\n\t\t\tcs_ctl->len, ADSP_MAX_STD_CTRL_SIZE);\n\t\treturn;\n\t}\n\n\tkcontrol.name = name;\n\tkcontrol.info = hda_cs_dsp_coeff_info;\n\tkcontrol.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkcontrol.access = wmfw_convert_flags(cs_ctl->flags);\n\tkcontrol.get = hda_cs_dsp_coeff_get;\n\tkcontrol.put = hda_cs_dsp_coeff_put;\n\n\t \n\tkctl = snd_ctl_new1(&kcontrol, (void *)ctl);\n\tif (!kctl)\n\t\treturn;\n\n\tret = snd_ctl_add(ctl->card, kctl);\n\tif (ret) {\n\t\tdev_err(cs_ctl->dsp->dev, \"Failed to add KControl %s = %d\\n\", kcontrol.name, ret);\n\t\treturn;\n\t}\n\n\tdev_dbg(cs_ctl->dsp->dev, \"Added KControl: %s\\n\", kcontrol.name);\n\tctl->kctl = kctl;\n}\n\nstatic void hda_cs_dsp_control_add(struct cs_dsp_coeff_ctl *cs_ctl,\n\t\t\t\t   const struct hda_cs_dsp_ctl_info *info)\n{\n\tstruct cs_dsp *cs_dsp = cs_ctl->dsp;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tstruct hda_cs_dsp_coeff_ctl *ctl;\n\tconst char *region_name;\n\tint ret;\n\n\tregion_name = cs_dsp_mem_region_name(cs_ctl->alg_region.type);\n\tif (!region_name) {\n\t\tdev_warn(cs_dsp->dev, \"Unknown region type: %d\\n\", cs_ctl->alg_region.type);\n\t\treturn;\n\t}\n\n\tret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, \"%s %s %.12s %x\", info->device_name,\n\t\t\tcs_dsp->name, hda_cs_dsp_fw_text[info->fw_type], cs_ctl->alg_region.alg);\n\n\tif (cs_ctl->subname) {\n\t\tint avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;\n\t\tint skip = 0;\n\n\t\t \n\t\tif (cs_ctl->subname_len > avail)\n\t\t\tskip = cs_ctl->subname_len - avail;\n\n\t\tsnprintf(name + ret, SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret,\n\t\t\t \" %.*s\", cs_ctl->subname_len - skip, cs_ctl->subname + skip);\n\t}\n\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn;\n\n\tctl->cs_ctl = cs_ctl;\n\tctl->card = info->card;\n\tcs_ctl->priv = ctl;\n\n\thda_cs_dsp_add_kcontrol(ctl, name);\n}\n\nvoid hda_cs_dsp_add_controls(struct cs_dsp *dsp, const struct hda_cs_dsp_ctl_info *info)\n{\n\tstruct cs_dsp_coeff_ctl *cs_ctl;\n\n\t \n\tlockdep_assert_not_held(&dsp->pwr_lock);\n\n\tlist_for_each_entry(cs_ctl, &dsp->ctl_list, list) {\n\t\tif (cs_ctl->flags & WMFW_CTL_FLAG_SYS)\n\t\t\tcontinue;\n\n\t\tif (cs_ctl->priv)\n\t\t\tcontinue;\n\n\t\thda_cs_dsp_control_add(cs_ctl, info);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(hda_cs_dsp_add_controls, SND_HDA_CS_DSP_CONTROLS);\n\nvoid hda_cs_dsp_control_remove(struct cs_dsp_coeff_ctl *cs_ctl)\n{\n\tstruct hda_cs_dsp_coeff_ctl *ctl = cs_ctl->priv;\n\n\tkfree(ctl);\n}\nEXPORT_SYMBOL_NS_GPL(hda_cs_dsp_control_remove, SND_HDA_CS_DSP_CONTROLS);\n\nint hda_cs_dsp_write_ctl(struct cs_dsp *dsp, const char *name, int type,\n\t\t\t unsigned int alg, const void *buf, size_t len)\n{\n\tstruct cs_dsp_coeff_ctl *cs_ctl;\n\tstruct hda_cs_dsp_coeff_ctl *ctl;\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\tcs_ctl = cs_dsp_get_ctl(dsp, name, type, alg);\n\tret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, buf, len);\n\tmutex_unlock(&dsp->pwr_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0 || (cs_ctl->flags & WMFW_CTL_FLAG_SYS))\n\t\treturn 0;\n\n\tctl = cs_ctl->priv;\n\n\tsnd_ctl_notify(ctl->card, SNDRV_CTL_EVENT_MASK_VALUE, &ctl->kctl->id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(hda_cs_dsp_write_ctl, SND_HDA_CS_DSP_CONTROLS);\n\nint hda_cs_dsp_read_ctl(struct cs_dsp *dsp, const char *name, int type,\n\t\t\tunsigned int alg, void *buf, size_t len)\n{\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\tret = cs_dsp_coeff_read_ctrl(cs_dsp_get_ctl(dsp, name, type, alg), 0, buf, len);\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn ret;\n\n}\nEXPORT_SYMBOL_NS_GPL(hda_cs_dsp_read_ctl, SND_HDA_CS_DSP_CONTROLS);\n\nMODULE_DESCRIPTION(\"CS_DSP ALSA Control HDA Library\");\nMODULE_AUTHOR(\"Stefan Binding, <sbinding@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(FW_CS_DSP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}