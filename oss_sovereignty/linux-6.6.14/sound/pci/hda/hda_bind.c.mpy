{
  "module_name": "hda_bind.c",
  "hash_id": "87d05d21282ec03381b2704b59ddbdb7439841382858bc2b352008405a004375",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_bind.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/pm.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_jack.h\"\n\n \nstatic int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)\n{\n\tstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\n\tstruct hda_codec_driver *driver =\n\t\tcontainer_of(drv, struct hda_codec_driver, core);\n\tconst struct hda_device_id *list;\n\t \n\tu32 id = codec->probe_id ? codec->probe_id : codec->core.vendor_id;\n\tu32 rev_id = codec->core.revision_id;\n\n\tfor (list = driver->id; list->vendor_id; list++) {\n\t\tif (list->vendor_id == id &&\n\t\t    (!list->rev_id || list->rev_id == rev_id)) {\n\t\t\tcodec->preset = list;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)\n{\n\tstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\n\n\t \n\tif (codec->bus->shutdown)\n\t\treturn;\n\n\t \n\tif (codec->core.dev.power.power_state.event != PM_EVENT_ON)\n\t\treturn;\n\n\tif (codec->patch_ops.unsol_event)\n\t\tcodec->patch_ops.unsol_event(codec, ev);\n}\n\n \nint snd_hda_codec_set_name(struct hda_codec *codec, const char *name)\n{\n\tint err;\n\n\tif (!name)\n\t\treturn 0;\n\terr = snd_hdac_device_set_chip_name(&codec->core, name);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!*codec->card->mixername ||\n\t    codec->bus->mixer_assigned >= codec->core.addr) {\n\t\tsnprintf(codec->card->mixername,\n\t\t\t sizeof(codec->card->mixername), \"%s %s\",\n\t\t\t codec->core.vendor_name, codec->core.chip_name);\n\t\tcodec->bus->mixer_assigned = codec->core.addr;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_set_name);\n\nstatic int hda_codec_driver_probe(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\tstruct module *owner = dev->driver->owner;\n\thda_codec_patch_t patch;\n\tint err;\n\n\tif (codec->bus->core.ext_ops) {\n\t\tif (WARN_ON(!codec->bus->core.ext_ops->hdev_attach))\n\t\t\treturn -EINVAL;\n\t\treturn codec->bus->core.ext_ops->hdev_attach(&codec->core);\n\t}\n\n\tif (WARN_ON(!codec->preset))\n\t\treturn -EINVAL;\n\n\terr = snd_hda_codec_set_name(codec, codec->preset->name);\n\tif (err < 0)\n\t\tgoto error;\n\terr = snd_hdac_regmap_init(&codec->core);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (!try_module_get(owner)) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpatch = (hda_codec_patch_t)codec->preset->driver_data;\n\tif (patch) {\n\t\terr = patch(codec);\n\t\tif (err < 0)\n\t\t\tgoto error_module_put;\n\t}\n\n\terr = snd_hda_codec_build_pcms(codec);\n\tif (err < 0)\n\t\tgoto error_module;\n\terr = snd_hda_codec_build_controls(codec);\n\tif (err < 0)\n\t\tgoto error_module;\n\t \n\tif (!codec->bus->bus_probing && codec->card->registered) {\n\t\terr = snd_card_register(codec->card);\n\t\tif (err < 0)\n\t\t\tgoto error_module;\n\t\tsnd_hda_codec_register(codec);\n\t}\n\n\tcodec->core.lazy_cache = true;\n\treturn 0;\n\n error_module:\n\tif (codec->patch_ops.free)\n\t\tcodec->patch_ops.free(codec);\n error_module_put:\n\tmodule_put(owner);\n\n error:\n\tsnd_hda_codec_cleanup_for_unbind(codec);\n\tcodec->preset = NULL;\n\treturn err;\n}\n\nstatic int hda_codec_driver_remove(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\tif (codec->bus->core.ext_ops) {\n\t\tif (WARN_ON(!codec->bus->core.ext_ops->hdev_detach))\n\t\t\treturn -EINVAL;\n\t\treturn codec->bus->core.ext_ops->hdev_detach(&codec->core);\n\t}\n\n\tsnd_hda_codec_disconnect_pcms(codec);\n\tsnd_hda_jack_tbl_disconnect(codec);\n\tif (!refcount_dec_and_test(&codec->pcm_ref))\n\t\twait_event(codec->remove_sleep, !refcount_read(&codec->pcm_ref));\n\tsnd_power_sync_ref(codec->bus->card);\n\n\tif (codec->patch_ops.free)\n\t\tcodec->patch_ops.free(codec);\n\tsnd_hda_codec_cleanup_for_unbind(codec);\n\tcodec->preset = NULL;\n\tmodule_put(dev->driver->owner);\n\treturn 0;\n}\n\nstatic void hda_codec_driver_shutdown(struct device *dev)\n{\n\tsnd_hda_codec_shutdown(dev_to_hda_codec(dev));\n}\n\nint __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,\n\t\t\t       struct module *owner)\n{\n\tdrv->core.driver.name = name;\n\tdrv->core.driver.owner = owner;\n\tdrv->core.driver.bus = &snd_hda_bus_type;\n\tdrv->core.driver.probe = hda_codec_driver_probe;\n\tdrv->core.driver.remove = hda_codec_driver_remove;\n\tdrv->core.driver.shutdown = hda_codec_driver_shutdown;\n\tdrv->core.driver.pm = &hda_codec_driver_pm;\n\tdrv->core.type = HDA_DEV_LEGACY;\n\tdrv->core.match = hda_codec_match;\n\tdrv->core.unsol_event = hda_codec_unsol_event;\n\treturn driver_register(&drv->core.driver);\n}\nEXPORT_SYMBOL_GPL(__hda_codec_driver_register);\n\nvoid hda_codec_driver_unregister(struct hda_codec_driver *drv)\n{\n\tdriver_unregister(&drv->core.driver);\n}\nEXPORT_SYMBOL_GPL(hda_codec_driver_unregister);\n\nstatic inline bool codec_probed(struct hda_codec *codec)\n{\n\treturn device_attach(hda_codec_dev(codec)) > 0 && codec->preset;\n}\n\n \nstatic void request_codec_module(struct hda_codec *codec)\n{\n#ifdef MODULE\n\tchar modalias[32];\n\tconst char *mod = NULL;\n\n\tswitch (codec->probe_id) {\n\tcase HDA_CODEC_ID_GENERIC_HDMI:\n#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)\n\t\tmod = \"snd-hda-codec-hdmi\";\n#endif\n\t\tbreak;\n\tcase HDA_CODEC_ID_GENERIC:\n#if IS_MODULE(CONFIG_SND_HDA_GENERIC)\n\t\tmod = \"snd-hda-codec-generic\";\n#endif\n\t\tbreak;\n\tdefault:\n\t\tsnd_hdac_codec_modalias(&codec->core, modalias, sizeof(modalias));\n\t\tmod = modalias;\n\t\tbreak;\n\t}\n\n\tif (mod)\n\t\trequest_module(mod);\n#endif  \n}\n\n \nstatic void codec_bind_module(struct hda_codec *codec)\n{\n#ifdef MODULE\n\trequest_codec_module(codec);\n\tif (codec_probed(codec))\n\t\treturn;\n#endif\n}\n\n#if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)\n \nstatic bool is_likely_hdmi_codec(struct hda_codec *codec)\n{\n\thda_nid_t nid;\n\n\t \n\tif (!codec->wcaps)\n\t\treturn true;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int wcaps = get_wcaps(codec, nid);\n\t\tswitch (get_wcaps_type(wcaps)) {\n\t\tcase AC_WID_AUD_IN:\n\t\t\treturn false;  \n\t\tcase AC_WID_AUD_OUT:\n\t\t\tif (!(wcaps & AC_WCAP_DIGITAL))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n#else\n \n#define is_likely_hdmi_codec(codec)\tfalse\n#endif  \n\nstatic int codec_bind_generic(struct hda_codec *codec)\n{\n\tif (codec->probe_id)\n\t\treturn -ENODEV;\n\n\tif (is_likely_hdmi_codec(codec)) {\n\t\tcodec->probe_id = HDA_CODEC_ID_GENERIC_HDMI;\n\t\trequest_codec_module(codec);\n\t\tif (codec_probed(codec))\n\t\t\treturn 0;\n\t}\n\n\tcodec->probe_id = HDA_CODEC_ID_GENERIC;\n\trequest_codec_module(codec);\n\tif (codec_probed(codec))\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\n#if IS_ENABLED(CONFIG_SND_HDA_GENERIC)\n#define is_generic_config(codec) \\\n\t(codec->modelname && !strcmp(codec->modelname, \"generic\"))\n#else\n#define is_generic_config(codec)\t0\n#endif\n\n \nint snd_hda_codec_configure(struct hda_codec *codec)\n{\n\tint err;\n\n\tif (codec->configured)\n\t\treturn 0;\n\n\tif (is_generic_config(codec))\n\t\tcodec->probe_id = HDA_CODEC_ID_GENERIC;\n\telse\n\t\tcodec->probe_id = 0;\n\n\tif (!device_is_registered(&codec->core.dev)) {\n\t\terr = snd_hdac_device_register(&codec->core);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!codec->preset)\n\t\tcodec_bind_module(codec);\n\tif (!codec->preset) {\n\t\terr = codec_bind_generic(codec);\n\t\tif (err < 0) {\n\t\t\tcodec_dbg(codec, \"Unable to bind the codec\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcodec->configured = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_configure);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}