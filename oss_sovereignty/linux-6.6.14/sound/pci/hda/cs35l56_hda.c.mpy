{
  "module_name": "cs35l56_hda.c",
  "hash_id": "f7ce18247a72d60dccf0490f422abc1c1e53e6fd03ca23c39bea519f7cc1f77e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/cs35l56_hda.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include <sound/tlv.h>\n#include \"cs35l56_hda.h\"\n#include \"hda_component.h\"\n#include \"hda_cs_dsp_ctl.h\"\n#include \"hda_generic.h\"\n\n  \nstatic const struct reg_sequence cs35l56_hda_dai_config[] = {\n\t{ CS35L56_ASP1_CONTROL1,\t0x00000021 },\n\t{ CS35L56_ASP1_CONTROL2,\t0x20200200 },\n\t{ CS35L56_ASP1_CONTROL3,\t0x00000003 },\n\t{ CS35L56_ASP1_DATA_CONTROL5,\t0x00000018 },\n\t{ CS35L56_ASP1_DATA_CONTROL1,\t0x00000018 },\n\t{ CS35L56_ASP1_ENABLES1,\t0x00000000 },\n};\n\nstatic void cs35l56_hda_play(struct cs35l56_hda *cs35l56)\n{\n\tunsigned int val;\n\tint ret;\n\n\tpm_runtime_get_sync(cs35l56->base.dev);\n\tret = cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_AUDIO_PLAY);\n\tif (ret == 0) {\n\t\t \n\t\tret = regmap_read_poll_timeout(cs35l56->base.regmap,\n\t\t\t\t\t       CS35L56_TRANSDUCER_ACTUAL_PS,\n\t\t\t\t\t       val, (val == CS35L56_PS0),\n\t\t\t\t\t       CS35L56_PS0_POLL_US,\n\t\t\t\t\t       CS35L56_PS0_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tdev_warn(cs35l56->base.dev, \"PS0 wait failed: %d\\n\", ret);\n\t}\n\tregmap_set_bits(cs35l56->base.regmap, CS35L56_ASP1_ENABLES1,\n\t\t\tBIT(CS35L56_ASP_RX1_EN_SHIFT) | BIT(CS35L56_ASP_RX2_EN_SHIFT) |\n\t\t\tcs35l56->asp_tx_mask);\n\tcs35l56->playing = true;\n}\n\nstatic void cs35l56_hda_pause(struct cs35l56_hda *cs35l56)\n{\n\tcs35l56->playing = false;\n\tcs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_AUDIO_PAUSE);\n\tregmap_clear_bits(cs35l56->base.regmap, CS35L56_ASP1_ENABLES1,\n\t\t\t  BIT(CS35L56_ASP_RX1_EN_SHIFT) | BIT(CS35L56_ASP_RX2_EN_SHIFT) |\n\t\t\t  BIT(CS35L56_ASP_TX1_EN_SHIFT) | BIT(CS35L56_ASP_TX2_EN_SHIFT) |\n\t\t\t  BIT(CS35L56_ASP_TX3_EN_SHIFT) | BIT(CS35L56_ASP_TX4_EN_SHIFT));\n\n\tpm_runtime_mark_last_busy(cs35l56->base.dev);\n\tpm_runtime_put_autosuspend(cs35l56->base.dev);\n}\n\nstatic void cs35l56_hda_playback_hook(struct device *dev, int action)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l56->base.dev, \"%s()%d: action: %d\\n\", __func__, __LINE__, action);\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tif (cs35l56->playing)\n\t\t\tbreak;\n\n\t\t \n\t\tif (cs35l56->suspended) {\n\t\t\tcs35l56->playing = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcs35l56_hda_play(cs35l56);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tif (!cs35l56->playing)\n\t\t\tbreak;\n\n\t\tcs35l56_hda_pause(cs35l56);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int cs35l56_hda_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\tif (cs35l56->cs_dsp.booted)\n\t\tcs_dsp_stop(&cs35l56->cs_dsp);\n\n\treturn cs35l56_runtime_suspend_common(&cs35l56->base);\n}\n\nstatic int cs35l56_hda_runtime_resume(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = cs35l56_runtime_resume_common(&cs35l56->base, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cs35l56->cs_dsp.booted) {\n\t\tret = cs_dsp_run(&cs35l56->cs_dsp);\n\t\tif (ret) {\n\t\t\tdev_dbg(cs35l56->base.dev, \"%s: cs_dsp_run ret %d\\n\", __func__, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tcs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_ALLOW_AUTO_HIBERNATE);\n\tregmap_write(cs35l56->base.regmap, CS35L56_DSP_VIRTUAL1_MBOX_1,\n\t\t     CS35L56_MBOX_CMD_HIBERNATE_NOW);\n\n\tregcache_cache_only(cs35l56->base.regmap, true);\n\n\treturn ret;\n}\n\nstatic int cs35l56_hda_mixer_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = CS35L56_NUM_INPUT_SRC;\n\tif (uinfo->value.enumerated.item >= CS35L56_NUM_INPUT_SRC)\n\t\tuinfo->value.enumerated.item = CS35L56_NUM_INPUT_SRC - 1;\n\tstrscpy(uinfo->value.enumerated.name, cs35l56_tx_input_texts[uinfo->value.enumerated.item],\n\t\tsizeof(uinfo->value.enumerated.name));\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_mixer_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tunsigned int reg_val;\n\tint i;\n\n\tregmap_read(cs35l56->base.regmap, kcontrol->private_value, &reg_val);\n\treg_val &= CS35L56_ASP_TXn_SRC_MASK;\n\n\tfor (i = 0; i < CS35L56_NUM_INPUT_SRC; ++i) {\n\t\tif (cs35l56_tx_input_values[i] == reg_val) {\n\t\t\tucontrol->value.enumerated.item[0] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_mixer_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tunsigned int item = ucontrol->value.enumerated.item[0];\n\tbool changed;\n\n\tif (item >= CS35L56_NUM_INPUT_SRC)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits_check(cs35l56->base.regmap, kcontrol->private_value,\n\t\t\t\t CS35L56_INPUT_MASK, cs35l56_tx_input_values[item],\n\t\t\t\t &changed);\n\n\treturn changed;\n}\n\nstatic int cs35l56_hda_posture_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = CS35L56_MAIN_POSTURE_MIN;\n\tuinfo->value.integer.max = CS35L56_MAIN_POSTURE_MAX;\n\treturn 0;\n}\n\nstatic int cs35l56_hda_posture_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tunsigned int pos;\n\tint ret;\n\n\tret = regmap_read(cs35l56->base.regmap, CS35L56_MAIN_POSTURE_NUMBER, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\tucontrol->value.integer.value[0] = pos;\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_posture_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tunsigned long pos = ucontrol->value.integer.value[0];\n\tbool changed;\n\tint ret;\n\n\tif ((pos < CS35L56_MAIN_POSTURE_MIN) ||\n\t    (pos > CS35L56_MAIN_POSTURE_MAX))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits_check(cs35l56->base.regmap,\n\t\t\t\t       CS35L56_MAIN_POSTURE_NUMBER,\n\t\t\t\t       CS35L56_MAIN_POSTURE_MASK,\n\t\t\t\t       pos, &changed);\n\tif (ret)\n\t\treturn ret;\n\n\treturn changed;\n}\n\nstatic const struct {\n\tconst char *name;\n\tunsigned int reg;\n} cs35l56_hda_mixer_controls[] = {\n\t{ \"ASP1 TX1 Source\", CS35L56_ASP1TX1_INPUT },\n\t{ \"ASP1 TX2 Source\", CS35L56_ASP1TX2_INPUT },\n\t{ \"ASP1 TX3 Source\", CS35L56_ASP1TX3_INPUT },\n\t{ \"ASP1 TX4 Source\", CS35L56_ASP1TX4_INPUT },\n};\n\nstatic const DECLARE_TLV_DB_SCALE(cs35l56_hda_vol_tlv, -10000, 25, 0);\n\nstatic int cs35l56_hda_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.step = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = CS35L56_MAIN_RENDER_USER_VOLUME_MAX -\n\t\t\t\t   CS35L56_MAIN_RENDER_USER_VOLUME_MIN;\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tunsigned int raw_vol;\n\tint vol;\n\tint ret;\n\n\tret = regmap_read(cs35l56->base.regmap, CS35L56_MAIN_RENDER_USER_VOLUME, &raw_vol);\n\n\tif (ret)\n\t\treturn ret;\n\n\tvol = (s16)(raw_vol & 0xFFFF);\n\tvol >>= CS35L56_MAIN_RENDER_USER_VOLUME_SHIFT;\n\n\tif (vol & BIT(CS35L56_MAIN_RENDER_USER_VOLUME_SIGNBIT))\n\t\tvol |= ~((int)(BIT(CS35L56_MAIN_RENDER_USER_VOLUME_SIGNBIT) - 1));\n\n\tucontrol->value.integer.value[0] = vol - CS35L56_MAIN_RENDER_USER_VOLUME_MIN;\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l56_hda *cs35l56 = (struct cs35l56_hda *)kcontrol->private_data;\n\tlong vol = ucontrol->value.integer.value[0];\n\tunsigned int raw_vol;\n\tbool changed;\n\tint ret;\n\n\tif ((vol < 0) || (vol > (CS35L56_MAIN_RENDER_USER_VOLUME_MAX -\n\t\t\t\t CS35L56_MAIN_RENDER_USER_VOLUME_MIN)))\n\t\treturn -EINVAL;\n\n\traw_vol = (vol + CS35L56_MAIN_RENDER_USER_VOLUME_MIN) <<\n\t\t  CS35L56_MAIN_RENDER_USER_VOLUME_SHIFT;\n\n\tret = regmap_update_bits_check(cs35l56->base.regmap,\n\t\t\t\t       CS35L56_MAIN_RENDER_USER_VOLUME,\n\t\t\t\t       CS35L56_MAIN_RENDER_USER_VOLUME_MASK,\n\t\t\t\t       raw_vol, &changed);\n\tif (ret)\n\t\treturn ret;\n\n\treturn changed;\n}\n\nstatic void cs35l56_hda_create_controls(struct cs35l56_hda *cs35l56)\n{\n\tstruct snd_kcontrol_new ctl_template = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = cs35l56_hda_posture_info,\n\t\t.get = cs35l56_hda_posture_get,\n\t\t.put = cs35l56_hda_posture_put,\n\t};\n\tchar name[64];\n\tint i;\n\n\tsnprintf(name, sizeof(name), \"%s Posture Number\", cs35l56->amp_name);\n\tctl_template.name = name;\n\tcs35l56->posture_ctl = snd_ctl_new1(&ctl_template, cs35l56);\n\tif (snd_ctl_add(cs35l56->codec->card, cs35l56->posture_ctl))\n\t\tdev_err(cs35l56->base.dev, \"Failed to add KControl: %s\\n\", ctl_template.name);\n\n\t \n\tctl_template.info = cs35l56_hda_mixer_info;\n\tctl_template.get = cs35l56_hda_mixer_get;\n\tctl_template.put = cs35l56_hda_mixer_put;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs35l56->mixer_ctl) != ARRAY_SIZE(cs35l56_hda_mixer_controls));\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l56_hda_mixer_controls); ++i) {\n\t\tsnprintf(name, sizeof(name), \"%s %s\", cs35l56->amp_name,\n\t\t\t cs35l56_hda_mixer_controls[i].name);\n\t\tctl_template.private_value = cs35l56_hda_mixer_controls[i].reg;\n\t\tcs35l56->mixer_ctl[i] = snd_ctl_new1(&ctl_template, cs35l56);\n\t\tif (snd_ctl_add(cs35l56->codec->card, cs35l56->mixer_ctl[i])) {\n\t\t\tdev_err(cs35l56->base.dev, \"Failed to add KControl: %s\\n\",\n\t\t\t\tctl_template.name);\n\t\t}\n\t}\n\n\tctl_template.info = cs35l56_hda_vol_info;\n\tctl_template.get = cs35l56_hda_vol_get;\n\tctl_template.put = cs35l56_hda_vol_put;\n\tctl_template.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ);\n\tctl_template.tlv.p = cs35l56_hda_vol_tlv;\n\tsnprintf(name, sizeof(name), \"%s Speaker Playback Volume\", cs35l56->amp_name);\n\tctl_template.name = name;\n\tcs35l56->volume_ctl = snd_ctl_new1(&ctl_template, cs35l56);\n\tif (snd_ctl_add(cs35l56->codec->card, cs35l56->volume_ctl))\n\t\tdev_err(cs35l56->base.dev, \"Failed to add KControl: %s\\n\", ctl_template.name);\n}\n\nstatic void cs35l56_hda_remove_controls(struct cs35l56_hda *cs35l56)\n{\n\tint i;\n\n\tfor (i = ARRAY_SIZE(cs35l56->mixer_ctl) - 1; i >= 0; i--)\n\t\tsnd_ctl_remove(cs35l56->codec->card, cs35l56->mixer_ctl[i]);\n\n\tsnd_ctl_remove(cs35l56->codec->card, cs35l56->posture_ctl);\n\tsnd_ctl_remove(cs35l56->codec->card, cs35l56->volume_ctl);\n}\n\nstatic const struct cs_dsp_client_ops cs35l56_hda_client_ops = {\n\t.control_remove = hda_cs_dsp_control_remove,\n};\n\nstatic int cs35l56_hda_request_firmware_file(struct cs35l56_hda *cs35l56,\n\t\t\t\t\t     const struct firmware **firmware, char **filename,\n\t\t\t\t\t     const char *dir, const char *system_name,\n\t\t\t\t\t     const char *amp_name,\n\t\t\t\t\t     const char *filetype)\n{\n\tchar *s, c;\n\tint ret = 0;\n\n\tif (system_name && amp_name)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%scs35l56%s-%02x-dsp1-misc-%s-%s.%s\", dir,\n\t\t\t\t      cs35l56->base.secured ? \"s\" : \"\", cs35l56->base.rev,\n\t\t\t\t      system_name, amp_name, filetype);\n\telse if (system_name)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%scs35l56%s-%02x-dsp1-misc-%s.%s\", dir,\n\t\t\t\t      cs35l56->base.secured ? \"s\" : \"\", cs35l56->base.rev,\n\t\t\t\t      system_name, filetype);\n\telse\n\t\t*filename = kasprintf(GFP_KERNEL, \"%scs35l56%s-%02x-dsp1-misc.%s\", dir,\n\t\t\t\t      cs35l56->base.secured ? \"s\" : \"\", cs35l56->base.rev,\n\t\t\t\t      filetype);\n\n\tif (!*filename)\n\t\treturn -ENOMEM;\n\n\t \n\ts = *filename;\n\twhile (*s) {\n\t\tc = *s;\n\t\tif (isalnum(c))\n\t\t\t*s = tolower(c);\n\t\telse if (c != '.' && c != '/')\n\t\t\t*s = '-';\n\t\ts++;\n\t}\n\n\tret = firmware_request_nowarn(firmware, *filename, cs35l56->base.dev);\n\tif (ret) {\n\t\tdev_dbg(cs35l56->base.dev, \"Failed to request '%s'\\n\", *filename);\n\t\tkfree(*filename);\n\t\t*filename = NULL;\n\t\treturn ret;\n\t}\n\n\tdev_dbg(cs35l56->base.dev, \"Found '%s'\\n\", *filename);\n\n\treturn 0;\n}\n\nstatic const char cirrus_dir[] = \"cirrus/\";\nstatic void cs35l56_hda_request_firmware_files(struct cs35l56_hda *cs35l56,\n\t\t\t\t\t       const struct firmware **wmfw_firmware,\n\t\t\t\t\t       char **wmfw_filename,\n\t\t\t\t\t       const struct firmware **coeff_firmware,\n\t\t\t\t\t       char **coeff_filename)\n{\n\tconst char *system_name = cs35l56->system_name;\n\tconst char *amp_name = cs35l56->amp_name;\n\tint ret;\n\n\tif (system_name && amp_name) {\n\t\tif (!cs35l56_hda_request_firmware_file(cs35l56, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\t       cirrus_dir, system_name, amp_name, \"wmfw\")) {\n\t\t\tcs35l56_hda_request_firmware_file(cs35l56, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t  cirrus_dir, system_name, amp_name, \"bin\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (system_name) {\n\t\tif (!cs35l56_hda_request_firmware_file(cs35l56, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\t       cirrus_dir, system_name, NULL, \"wmfw\")) {\n\t\t\tif (amp_name)\n\t\t\t\tcs35l56_hda_request_firmware_file(cs35l56,\n\t\t\t\t\t\t\t\t  coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t\t  cirrus_dir, system_name,\n\t\t\t\t\t\t\t\t  amp_name, \"bin\");\n\t\t\tif (!*coeff_firmware)\n\t\t\t\tcs35l56_hda_request_firmware_file(cs35l56,\n\t\t\t\t\t\t\t\t  coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t\t  cirrus_dir, system_name,\n\t\t\t\t\t\t\t\t  NULL, \"bin\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tret = cs35l56_hda_request_firmware_file(cs35l56, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\tcirrus_dir, NULL, NULL, \"wmfw\");\n\tif (!ret) {\n\t\tcs35l56_hda_request_firmware_file(cs35l56, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t  cirrus_dir, NULL, NULL, \"bin\");\n\t\treturn;\n\t}\n\n\t \n\tif (system_name) {\n\t\tif (amp_name)\n\t\t\tcs35l56_hda_request_firmware_file(cs35l56, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t  cirrus_dir, system_name, amp_name, \"bin\");\n\t\tif (!*coeff_firmware)\n\t\t\tcs35l56_hda_request_firmware_file(cs35l56, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t  cirrus_dir, system_name, NULL, \"bin\");\n\t}\n\n\tif (!*coeff_firmware)\n\t\tcs35l56_hda_request_firmware_file(cs35l56, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t  cirrus_dir, NULL, NULL, \"bin\");\n}\n\nstatic void cs35l56_hda_release_firmware_files(const struct firmware *wmfw_firmware,\n\t\t\t\t\t       char *wmfw_filename,\n\t\t\t\t\t       const struct firmware *coeff_firmware,\n\t\t\t\t\t       char *coeff_filename)\n{\n\tif (wmfw_firmware)\n\t\trelease_firmware(wmfw_firmware);\n\tkfree(wmfw_filename);\n\n\tif (coeff_firmware)\n\t\trelease_firmware(coeff_firmware);\n\tkfree(coeff_filename);\n}\n\nstatic void cs35l56_hda_add_dsp_controls(struct cs35l56_hda *cs35l56)\n{\n\tstruct hda_cs_dsp_ctl_info info;\n\n\tinfo.device_name = cs35l56->amp_name;\n\tinfo.fw_type = HDA_CS_DSP_FW_MISC;\n\tinfo.card = cs35l56->codec->card;\n\n\thda_cs_dsp_add_controls(&cs35l56->cs_dsp, &info);\n}\n\nstatic int cs35l56_hda_fw_load(struct cs35l56_hda *cs35l56)\n{\n\tconst struct firmware *coeff_firmware = NULL;\n\tconst struct firmware *wmfw_firmware = NULL;\n\tchar *coeff_filename = NULL;\n\tchar *wmfw_filename = NULL;\n\tunsigned int firmware_missing;\n\tint ret = 0;\n\n\t \n\tif (cs35l56->base.fw_patched)\n\t\tcs_dsp_power_down(&cs35l56->cs_dsp);\n\n\tcs35l56->base.fw_patched = false;\n\n\tpm_runtime_get_sync(cs35l56->base.dev);\n\n\tret = regmap_read(cs35l56->base.regmap, CS35L56_PROTECTION_STATUS, &firmware_missing);\n\tif (ret) {\n\t\tdev_err(cs35l56->base.dev, \"Failed to read PROTECTION_STATUS: %d\\n\", ret);\n\t\tgoto err_pm_put;\n\t}\n\n\tfirmware_missing &= CS35L56_FIRMWARE_MISSING;\n\n\t \n\tif (cs35l56->base.secured || firmware_missing) {\n\t\tcs35l56_hda_request_firmware_files(cs35l56, &wmfw_firmware, &wmfw_filename,\n\t\t\t\t\t\t   &coeff_firmware, &coeff_filename);\n\t}\n\n\t \n\tif (!coeff_firmware && firmware_missing) {\n\t\tdev_err(cs35l56->base.dev, \".bin file required but not found\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_fw_release;\n\t}\n\n\tmutex_lock(&cs35l56->base.irq_lock);\n\n\t \n\tif (!cs35l56->base.secured && (wmfw_firmware || coeff_firmware)) {\n\t\tret = cs35l56_firmware_shutdown(&cs35l56->base);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = cs_dsp_power_up(&cs35l56->cs_dsp, wmfw_firmware, wmfw_filename,\n\t\t\t      coeff_firmware, coeff_filename, \"misc\");\n\tif (ret) {\n\t\tdev_dbg(cs35l56->base.dev, \"%s: cs_dsp_power_up ret %d\\n\", __func__, ret);\n\t\tgoto err;\n\t}\n\n\tif (wmfw_filename)\n\t\tdev_dbg(cs35l56->base.dev, \"Loaded WMFW Firmware: %s\\n\", wmfw_filename);\n\n\tif (coeff_filename)\n\t\tdev_dbg(cs35l56->base.dev, \"Loaded Coefficients: %s\\n\", coeff_filename);\n\n\tif (cs35l56->base.secured) {\n\t\tret = cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_AUDIO_REINIT);\n\t\tif (ret)\n\t\t\tgoto err_powered_up;\n\t} else if (wmfw_firmware || coeff_firmware) {\n\t\t \n\t\tcs35l56_system_reset(&cs35l56->base, false);\n\t\tregcache_mark_dirty(cs35l56->base.regmap);\n\t\tret = cs35l56_wait_for_firmware_boot(&cs35l56->base);\n\t\tif (ret)\n\t\t\tgoto err_powered_up;\n\t}\n\n\t \n\tret = cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_PREVENT_AUTO_HIBERNATE);\n\tif (ret)\n\t\tgoto err_powered_up;\n\n\tregcache_sync(cs35l56->base.regmap);\n\n\tregmap_clear_bits(cs35l56->base.regmap, CS35L56_PROTECTION_STATUS,\n\t\t\t  CS35L56_FIRMWARE_MISSING);\n\tcs35l56->base.fw_patched = true;\n\n\tret = cs_dsp_run(&cs35l56->cs_dsp);\n\tif (ret)\n\t\tdev_dbg(cs35l56->base.dev, \"%s: cs_dsp_run ret %d\\n\", __func__, ret);\n\nerr_powered_up:\n\tif (!cs35l56->base.fw_patched)\n\t\tcs_dsp_power_down(&cs35l56->cs_dsp);\nerr:\n\tmutex_unlock(&cs35l56->base.irq_lock);\nerr_fw_release:\n\tcs35l56_hda_release_firmware_files(wmfw_firmware, wmfw_filename,\n\t\t\t\t\t   coeff_firmware, coeff_filename);\nerr_pm_put:\n\tpm_runtime_put(cs35l56->base.dev);\n\n\treturn ret;\n}\n\nstatic int cs35l56_hda_bind(struct device *dev, struct device *master, void *master_data)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tint ret;\n\n\tif (!comps || cs35l56->index < 0 || cs35l56->index >= HDA_MAX_COMPONENTS)\n\t\treturn -EINVAL;\n\n\tcomps = &comps[cs35l56->index];\n\tif (comps->dev)\n\t\treturn -EBUSY;\n\n\tcomps->dev = dev;\n\tcs35l56->codec = comps->codec;\n\tstrscpy(comps->name, dev_name(dev), sizeof(comps->name));\n\tcomps->playback_hook = cs35l56_hda_playback_hook;\n\n\tret = cs35l56_hda_fw_load(cs35l56);\n\tif (ret)\n\t\treturn ret;\n\n\tcs35l56_hda_create_controls(cs35l56);\n\tcs35l56_hda_add_dsp_controls(cs35l56);\n\n#if IS_ENABLED(CONFIG_SND_DEBUG)\n\tcs35l56->debugfs_root = debugfs_create_dir(dev_name(cs35l56->base.dev), sound_debugfs_root);\n\tcs_dsp_init_debugfs(&cs35l56->cs_dsp, cs35l56->debugfs_root);\n#endif\n\n\tdev_dbg(cs35l56->base.dev, \"Bound\\n\");\n\n\treturn 0;\n}\n\nstatic void cs35l56_hda_unbind(struct device *dev, struct device *master, void *master_data)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\n\tcs35l56_hda_remove_controls(cs35l56);\n\n#if IS_ENABLED(CONFIG_SND_DEBUG)\n\tcs_dsp_cleanup_debugfs(&cs35l56->cs_dsp);\n\tdebugfs_remove_recursive(cs35l56->debugfs_root);\n#endif\n\n\tif (cs35l56->base.fw_patched)\n\t\tcs_dsp_power_down(&cs35l56->cs_dsp);\n\n\tcs_dsp_remove(&cs35l56->cs_dsp);\n\n\tif (comps[cs35l56->index].dev == dev)\n\t\tmemset(&comps[cs35l56->index], 0, sizeof(*comps));\n\n\tdev_dbg(cs35l56->base.dev, \"Unbound\\n\");\n}\n\nstatic const struct component_ops cs35l56_hda_comp_ops = {\n\t.bind = cs35l56_hda_bind,\n\t.unbind = cs35l56_hda_unbind,\n};\n\nstatic int cs35l56_hda_system_suspend(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\tif (cs35l56->playing)\n\t\tcs35l56_hda_pause(cs35l56);\n\n\tcs35l56->suspended = true;\n\n\t \n\tif (cs35l56->base.irq)\n\t\tdisable_irq(cs35l56->base.irq);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int cs35l56_hda_system_suspend_late(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\t \n\tif (cs35l56->base.reset_gpio) {\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_system_suspend_no_irq(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\t \n\tif (cs35l56->base.irq)\n\t\tenable_irq(cs35l56->base.irq);\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_system_resume_no_irq(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\t \n\tif (cs35l56->base.irq)\n\t\tdisable_irq(cs35l56->base.irq);\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_system_resume_early(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\t \n\tif (cs35l56->base.reset_gpio) {\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\n\t\t \n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 1);\n\t\tcs35l56_wait_control_port_ready();\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_system_resume(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = pm_runtime_force_resume(dev);\n\tif (cs35l56->base.irq)\n\t\tenable_irq(cs35l56->base.irq);\n\n\tif (ret)\n\t\treturn ret;\n\n\tcs35l56->suspended = false;\n\n\tret = cs35l56_is_fw_reload_needed(&cs35l56->base);\n\tdev_dbg(cs35l56->base.dev, \"fw_reload_needed: %d\\n\", ret);\n\tif (ret > 0) {\n\t\tret = cs35l56_hda_fw_load(cs35l56);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cs35l56->playing)\n\t\tcs35l56_hda_play(cs35l56);\n\n\treturn 0;\n}\n\nstatic int cs35l56_hda_read_acpi(struct cs35l56_hda *cs35l56, int id)\n{\n\tu32 values[HDA_MAX_COMPONENTS];\n\tstruct acpi_device *adev;\n\tconst char *property, *sub;\n\tsize_t nval;\n\tint i, ret;\n\n\t \n\tif (!ACPI_COMPANION(cs35l56->base.dev)) {\n\t\tadev = acpi_dev_get_first_match_dev(\"CSC3556\", NULL, -1);\n\t\tif (!adev) {\n\t\t\tdev_err(cs35l56->base.dev, \"Failed to find an ACPI device for %s\\n\",\n\t\t\t\tdev_name(cs35l56->base.dev));\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tACPI_COMPANION_SET(cs35l56->base.dev, adev);\n\t}\n\n\tproperty = \"cirrus,dev-index\";\n\tret = device_property_count_u32(cs35l56->base.dev, property);\n\tif (ret <= 0)\n\t\tgoto err;\n\n\tif (ret > ARRAY_SIZE(values)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tnval = ret;\n\n\tret = device_property_read_u32_array(cs35l56->base.dev, property, values, nval);\n\tif (ret)\n\t\tgoto err;\n\n\tcs35l56->index = -1;\n\tfor (i = 0; i < nval; i++) {\n\t\tif (values[i] == id) {\n\t\t\tcs35l56->index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (cs35l56->index == -1) {\n\t\tdev_dbg(cs35l56->base.dev, \"No index found in %s\\n\", property);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tsub = acpi_get_subsystem_id(ACPI_HANDLE(cs35l56->base.dev));\n\n\tif (IS_ERR(sub)) {\n\t\tdev_info(cs35l56->base.dev,\n\t\t\t \"Read ACPI _SUB failed(%ld): fallback to generic firmware\\n\",\n\t\t\t PTR_ERR(sub));\n\t} else {\n\t\tcs35l56->system_name = sub;\n\t}\n\n\tcs35l56->base.reset_gpio = devm_gpiod_get_index_optional(cs35l56->base.dev,\n\t\t\t\t\t\t\t\t \"reset\",\n\t\t\t\t\t\t\t\t cs35l56->index,\n\t\t\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l56->base.reset_gpio)) {\n\t\tret = PTR_ERR(cs35l56->base.reset_gpio);\n\n\t\t \n\t\tif (ret != -EBUSY)\n\t\t\treturn dev_err_probe(cs35l56->base.dev, ret, \"Failed to get reset GPIO\\n\");\n\n\t\tdev_info(cs35l56->base.dev, \"Reset GPIO busy, assume shared reset\\n\");\n\t\tcs35l56->base.reset_gpio = NULL;\n\t}\n\n\treturn 0;\n\nerr:\n\tif (ret != -ENODEV)\n\t\tdev_err(cs35l56->base.dev, \"Failed property %s: %d\\n\", property, ret);\n\n\treturn ret;\n}\n\nint cs35l56_hda_common_probe(struct cs35l56_hda *cs35l56, int id)\n{\n\tint ret;\n\n\tmutex_init(&cs35l56->base.irq_lock);\n\tdev_set_drvdata(cs35l56->base.dev, cs35l56);\n\n\tret = cs35l56_hda_read_acpi(cs35l56, id);\n\tif (ret)\n\t\tgoto err;\n\n\tcs35l56->amp_name = devm_kasprintf(cs35l56->base.dev, GFP_KERNEL, \"AMP%d\",\n\t\t\t\t\t   cs35l56->index + 1);\n\tif (!cs35l56->amp_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcs35l56_init_cs_dsp(&cs35l56->base, &cs35l56->cs_dsp);\n\tcs35l56->cs_dsp.client_ops = &cs35l56_hda_client_ops;\n\n\tif (cs35l56->base.reset_gpio) {\n\t\tdev_dbg(cs35l56->base.dev, \"Hard reset\\n\");\n\n\t\t \n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 1);\n\t}\n\n\tret = cs35l56_hw_init(&cs35l56->base);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tcs35l56_system_reset(&cs35l56->base, false);\n\tret = cs35l56_wait_for_firmware_boot(&cs35l56->base);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cs35l56_set_patch(&cs35l56->base);\n\tif (ret)\n\t\tgoto err;\n\n\tregcache_mark_dirty(cs35l56->base.regmap);\n\tregcache_sync(cs35l56->base.regmap);\n\n\t \n\tret = cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_PREVENT_AUTO_HIBERNATE);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cs_dsp_halo_init(&cs35l56->cs_dsp);\n\tif (ret) {\n\t\tdev_err_probe(cs35l56->base.dev, ret, \"cs_dsp_halo_init failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_dbg(cs35l56->base.dev, \"DSP system name: '%s', amp name: '%s'\\n\",\n\t\tcs35l56->system_name, cs35l56->amp_name);\n\n\tregmap_multi_reg_write(cs35l56->base.regmap, cs35l56_hda_dai_config,\n\t\t\t       ARRAY_SIZE(cs35l56_hda_dai_config));\n\n\t \n\tcs35l56->asp_tx_mask = BIT(cs35l56->index);\n\n\tpm_runtime_set_autosuspend_delay(cs35l56->base.dev, 3000);\n\tpm_runtime_use_autosuspend(cs35l56->base.dev);\n\tpm_runtime_set_active(cs35l56->base.dev);\n\tpm_runtime_mark_last_busy(cs35l56->base.dev);\n\tpm_runtime_enable(cs35l56->base.dev);\n\n\tret = component_add(cs35l56->base.dev, &cs35l56_hda_comp_ops);\n\tif (ret) {\n\t\tdev_err(cs35l56->base.dev, \"Register component failed: %d\\n\", ret);\n\t\tgoto pm_err;\n\t}\n\n\tcs35l56->base.init_done = true;\n\n\treturn 0;\n\npm_err:\n\tpm_runtime_disable(cs35l56->base.dev);\nerr:\n\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_hda_common_probe, SND_HDA_SCODEC_CS35L56);\n\nvoid cs35l56_hda_remove(struct device *dev)\n{\n\tstruct cs35l56_hda *cs35l56 = dev_get_drvdata(dev);\n\n\tpm_runtime_dont_use_autosuspend(cs35l56->base.dev);\n\tpm_runtime_get_sync(cs35l56->base.dev);\n\tpm_runtime_disable(cs35l56->base.dev);\n\n\tcomponent_del(cs35l56->base.dev, &cs35l56_hda_comp_ops);\n\n\tkfree(cs35l56->system_name);\n\tpm_runtime_put_noidle(cs35l56->base.dev);\n\n\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_hda_remove, SND_HDA_SCODEC_CS35L56);\n\nconst struct dev_pm_ops cs35l56_hda_pm_ops = {\n\tRUNTIME_PM_OPS(cs35l56_hda_runtime_suspend, cs35l56_hda_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(cs35l56_hda_system_suspend, cs35l56_hda_system_resume)\n\tLATE_SYSTEM_SLEEP_PM_OPS(cs35l56_hda_system_suspend_late,\n\t\t\t\t cs35l56_hda_system_resume_early)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l56_hda_system_suspend_no_irq,\n\t\t\t\t  cs35l56_hda_system_resume_no_irq)\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_hda_pm_ops, SND_HDA_SCODEC_CS35L56);\n\nMODULE_DESCRIPTION(\"CS35L56 HDA Driver\");\nMODULE_IMPORT_NS(SND_HDA_CS_DSP_CONTROLS);\nMODULE_IMPORT_NS(SND_SOC_CS35L56_SHARED);\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Simon Trimmer <simont@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(FW_CS_DSP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}