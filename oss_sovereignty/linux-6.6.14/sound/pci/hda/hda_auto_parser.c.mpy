{
  "module_name": "hda_auto_parser.c",
  "hash_id": "2e2c97902b90369ac70f805cf01d5a08adc2c690f408e33de2dafd2d8c347102",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_auto_parser.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/sort.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n\n \n\nstatic int is_in_nid_list(hda_nid_t nid, const hda_nid_t *list)\n{\n\tfor (; *list; list++)\n\t\tif (*list == nid)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstruct auto_out_pin {\n\thda_nid_t pin;\n\tshort seq;\n};\n\nstatic int compare_seq(const void *ap, const void *bp)\n{\n\tconst struct auto_out_pin *a = ap;\n\tconst struct auto_out_pin *b = bp;\n\treturn (int)(a->seq - b->seq);\n}\n\n \nstatic void sort_pins_by_sequence(hda_nid_t *pins, struct auto_out_pin *list,\n\t\t\t\t  int num_pins)\n{\n\tint i;\n\tsort(list, num_pins, sizeof(list[0]), compare_seq, NULL);\n\tfor (i = 0; i < num_pins; i++)\n\t\tpins[i] = list[i].pin;\n}\n\n\n \nstatic void add_auto_cfg_input_pin(struct hda_codec *codec, struct auto_pin_cfg *cfg,\n\t\t\t\t   hda_nid_t nid, int type)\n{\n\tif (cfg->num_inputs < AUTO_CFG_MAX_INS) {\n\t\tcfg->inputs[cfg->num_inputs].pin = nid;\n\t\tcfg->inputs[cfg->num_inputs].type = type;\n\t\tcfg->inputs[cfg->num_inputs].has_boost_on_pin =\n\t\t\tnid_has_volume(codec, nid, HDA_INPUT);\n\t\tcfg->num_inputs++;\n\t}\n}\n\nstatic int compare_input_type(const void *ap, const void *bp)\n{\n\tconst struct auto_pin_cfg_item *a = ap;\n\tconst struct auto_pin_cfg_item *b = bp;\n\tif (a->type != b->type)\n\t\treturn (int)(a->type - b->type);\n\n\t \n\tif (a->is_headset_mic && b->is_headphone_mic)\n\t\treturn -1;  \n\telse if (a->is_headphone_mic && b->is_headset_mic)\n\t\treturn 1;  \n\n\t \n\treturn (int)(b->has_boost_on_pin - a->has_boost_on_pin);\n}\n\n \nstatic void reorder_outputs(unsigned int nums, hda_nid_t *pins)\n{\n\tswitch (nums) {\n\tcase 3:\n\tcase 4:\n\t\tswap(pins[1], pins[2]);\n\t\tbreak;\n\t}\n}\n\n \nstatic bool check_pincap_validity(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t\t  unsigned int dev)\n{\n\tunsigned int pincap = snd_hda_query_pin_caps(codec, pin);\n\n\t \n\tif (!pincap)\n\t\treturn true;\n\n\tswitch (dev) {\n\tcase AC_JACK_LINE_OUT:\n\tcase AC_JACK_SPEAKER:\n\tcase AC_JACK_HP_OUT:\n\tcase AC_JACK_SPDIF_OUT:\n\tcase AC_JACK_DIG_OTHER_OUT:\n\t\treturn !!(pincap & AC_PINCAP_OUT);\n\tdefault:\n\t\treturn !!(pincap & AC_PINCAP_IN);\n\t}\n}\n\nstatic bool can_be_headset_mic(struct hda_codec *codec,\n\t\t\t       struct auto_pin_cfg_item *item,\n\t\t\t       int seq_number)\n{\n\tint attr;\n\tunsigned int def_conf;\n\tif (item->type != AUTO_PIN_MIC)\n\t\treturn false;\n\n\tif (item->is_headset_mic || item->is_headphone_mic)\n\t\treturn false;  \n\n\tdef_conf = snd_hda_codec_get_pincfg(codec, item->pin);\n\tattr = snd_hda_get_input_pin_attr(def_conf);\n\tif (attr <= INPUT_PIN_ATTR_DOCK)\n\t\treturn false;\n\n\tif (seq_number >= 0) {\n\t\tint seq = get_defcfg_sequence(def_conf);\n\t\tif (seq != seq_number)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint snd_hda_parse_pin_defcfg(struct hda_codec *codec,\n\t\t\t     struct auto_pin_cfg *cfg,\n\t\t\t     const hda_nid_t *ignore_nids,\n\t\t\t     unsigned int cond_flags)\n{\n\thda_nid_t nid;\n\tshort seq, assoc_line_out;\n\tstruct auto_out_pin line_out[ARRAY_SIZE(cfg->line_out_pins)];\n\tstruct auto_out_pin speaker_out[ARRAY_SIZE(cfg->speaker_pins)];\n\tstruct auto_out_pin hp_out[ARRAY_SIZE(cfg->hp_pins)];\n\tint i;\n\n\tif (!snd_hda_get_int_hint(codec, \"parser_flags\", &i))\n\t\tcond_flags = i;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\tmemset(line_out, 0, sizeof(line_out));\n\tmemset(speaker_out, 0, sizeof(speaker_out));\n\tmemset(hp_out, 0, sizeof(hp_out));\n\tassoc_line_out = 0;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int wid_caps = get_wcaps(codec, nid);\n\t\tunsigned int wid_type = get_wcaps_type(wid_caps);\n\t\tunsigned int def_conf;\n\t\tshort assoc, loc, conn, dev;\n\n\t\t \n\t\tif (wid_type != AC_WID_PIN)\n\t\t\tcontinue;\n\t\t \n\t\tif (ignore_nids && is_in_nid_list(nid, ignore_nids))\n\t\t\tcontinue;\n\n\t\tdef_conf = snd_hda_codec_get_pincfg(codec, nid);\n\t\tconn = get_defcfg_connect(def_conf);\n\t\tif (conn == AC_JACK_PORT_NONE)\n\t\t\tcontinue;\n\t\tloc = get_defcfg_location(def_conf);\n\t\tdev = get_defcfg_device(def_conf);\n\n\t\t \n\t\tif (dev == AC_JACK_LINE_OUT) {\n\t\t\tif (conn == AC_JACK_PORT_FIXED ||\n\t\t\t    conn == AC_JACK_PORT_BOTH)\n\t\t\t\tdev = AC_JACK_SPEAKER;\n\t\t}\n\n\t\tif (!check_pincap_validity(codec, nid, dev))\n\t\t\tcontinue;\n\n\t\tswitch (dev) {\n\t\tcase AC_JACK_LINE_OUT:\n\t\t\tseq = get_defcfg_sequence(def_conf);\n\t\t\tassoc = get_defcfg_association(def_conf);\n\n\t\t\tif (!(wid_caps & AC_WCAP_STEREO))\n\t\t\t\tif (!cfg->mono_out_pin)\n\t\t\t\t\tcfg->mono_out_pin = nid;\n\t\t\tif (!assoc)\n\t\t\t\tcontinue;\n\t\t\tif (!assoc_line_out)\n\t\t\t\tassoc_line_out = assoc;\n\t\t\telse if (assoc_line_out != assoc) {\n\t\t\t\tcodec_info(codec,\n\t\t\t\t\t   \"ignore pin 0x%x with mismatching assoc# 0x%x vs 0x%x\\n\",\n\t\t\t\t\t   nid, assoc, assoc_line_out);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cfg->line_outs >= ARRAY_SIZE(cfg->line_out_pins)) {\n\t\t\t\tcodec_info(codec,\n\t\t\t\t\t   \"ignore pin 0x%x, too many assigned pins\\n\",\n\t\t\t\t\t   nid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tline_out[cfg->line_outs].pin = nid;\n\t\t\tline_out[cfg->line_outs].seq = seq;\n\t\t\tcfg->line_outs++;\n\t\t\tbreak;\n\t\tcase AC_JACK_SPEAKER:\n\t\t\tseq = get_defcfg_sequence(def_conf);\n\t\t\tassoc = get_defcfg_association(def_conf);\n\t\t\tif (cfg->speaker_outs >= ARRAY_SIZE(cfg->speaker_pins)) {\n\t\t\t\tcodec_info(codec,\n\t\t\t\t\t   \"ignore pin 0x%x, too many assigned pins\\n\",\n\t\t\t\t\t   nid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspeaker_out[cfg->speaker_outs].pin = nid;\n\t\t\tspeaker_out[cfg->speaker_outs].seq = (assoc << 4) | seq;\n\t\t\tcfg->speaker_outs++;\n\t\t\tbreak;\n\t\tcase AC_JACK_HP_OUT:\n\t\t\tseq = get_defcfg_sequence(def_conf);\n\t\t\tassoc = get_defcfg_association(def_conf);\n\t\t\tif (cfg->hp_outs >= ARRAY_SIZE(cfg->hp_pins)) {\n\t\t\t\tcodec_info(codec,\n\t\t\t\t\t   \"ignore pin 0x%x, too many assigned pins\\n\",\n\t\t\t\t\t   nid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thp_out[cfg->hp_outs].pin = nid;\n\t\t\thp_out[cfg->hp_outs].seq = (assoc << 4) | seq;\n\t\t\tcfg->hp_outs++;\n\t\t\tbreak;\n\t\tcase AC_JACK_MIC_IN:\n\t\t\tadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_MIC);\n\t\t\tbreak;\n\t\tcase AC_JACK_LINE_IN:\n\t\t\tadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_LINE_IN);\n\t\t\tbreak;\n\t\tcase AC_JACK_CD:\n\t\t\tadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_CD);\n\t\t\tbreak;\n\t\tcase AC_JACK_AUX:\n\t\t\tadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_AUX);\n\t\t\tbreak;\n\t\tcase AC_JACK_SPDIF_OUT:\n\t\tcase AC_JACK_DIG_OTHER_OUT:\n\t\t\tif (cfg->dig_outs >= ARRAY_SIZE(cfg->dig_out_pins)) {\n\t\t\t\tcodec_info(codec,\n\t\t\t\t\t   \"ignore pin 0x%x, too many assigned pins\\n\",\n\t\t\t\t\t   nid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcfg->dig_out_pins[cfg->dig_outs] = nid;\n\t\t\tcfg->dig_out_type[cfg->dig_outs] =\n\t\t\t\t(loc == AC_JACK_LOC_HDMI) ?\n\t\t\t\tHDA_PCM_TYPE_HDMI : HDA_PCM_TYPE_SPDIF;\n\t\t\tcfg->dig_outs++;\n\t\t\tbreak;\n\t\tcase AC_JACK_SPDIF_IN:\n\t\tcase AC_JACK_DIG_OTHER_IN:\n\t\t\tcfg->dig_in_pin = nid;\n\t\t\tif (loc == AC_JACK_LOC_HDMI)\n\t\t\t\tcfg->dig_in_type = HDA_PCM_TYPE_HDMI;\n\t\t\telse\n\t\t\t\tcfg->dig_in_type = HDA_PCM_TYPE_SPDIF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (cond_flags & HDA_PINCFG_HEADSET_MIC || cond_flags & HDA_PINCFG_HEADPHONE_MIC) {\n\t\tbool hsmic = !!(cond_flags & HDA_PINCFG_HEADSET_MIC);\n\t\tbool hpmic = !!(cond_flags & HDA_PINCFG_HEADPHONE_MIC);\n\t\tfor (i = 0; (hsmic || hpmic) && (i < cfg->num_inputs); i++)\n\t\t\tif (hsmic && can_be_headset_mic(codec, &cfg->inputs[i], 0xc)) {\n\t\t\t\tcfg->inputs[i].is_headset_mic = 1;\n\t\t\t\thsmic = false;\n\t\t\t} else if (hpmic && can_be_headset_mic(codec, &cfg->inputs[i], 0xd)) {\n\t\t\t\tcfg->inputs[i].is_headphone_mic = 1;\n\t\t\t\thpmic = false;\n\t\t\t}\n\n\t\t \n\t\tfor (i = 0; (hsmic || hpmic) && (i < cfg->num_inputs); i++) {\n\t\t\tif (!can_be_headset_mic(codec, &cfg->inputs[i], -1))\n\t\t\t\tcontinue;\n\t\t\tif (hsmic) {\n\t\t\t\tcfg->inputs[i].is_headset_mic = 1;\n\t\t\t\thsmic = false;\n\t\t\t} else if (hpmic) {\n\t\t\t\tcfg->inputs[i].is_headphone_mic = 1;\n\t\t\t\thpmic = false;\n\t\t\t}\n\t\t}\n\n\t\tif (hsmic)\n\t\t\tcodec_dbg(codec, \"Told to look for a headset mic, but didn't find any.\\n\");\n\t\tif (hpmic)\n\t\t\tcodec_dbg(codec, \"Told to look for a headphone mic, but didn't find any.\\n\");\n\t}\n\n\t \n\tif (!cfg->line_outs && cfg->hp_outs > 1 &&\n\t    !(cond_flags & HDA_PINCFG_NO_HP_FIXUP)) {\n\t\ti = 0;\n\t\twhile (i < cfg->hp_outs) {\n\t\t\t \n\t\t\tif ((hp_out[i].seq & 0x0f) == 0x0f) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tline_out[cfg->line_outs++] = hp_out[i];\n\t\t\tcfg->hp_outs--;\n\t\t\tmemmove(hp_out + i, hp_out + i + 1,\n\t\t\t\tsizeof(hp_out[0]) * (cfg->hp_outs - i));\n\t\t}\n\t\tmemset(hp_out + cfg->hp_outs, 0,\n\t\t       sizeof(hp_out[0]) * (AUTO_CFG_MAX_OUTS - cfg->hp_outs));\n\t\tif (!cfg->hp_outs)\n\t\t\tcfg->line_out_type = AUTO_PIN_HP_OUT;\n\n\t}\n\n\t \n\tsort_pins_by_sequence(cfg->line_out_pins, line_out, cfg->line_outs);\n\tsort_pins_by_sequence(cfg->speaker_pins, speaker_out,\n\t\t\t      cfg->speaker_outs);\n\tsort_pins_by_sequence(cfg->hp_pins, hp_out, cfg->hp_outs);\n\n\t \n\tif (!cfg->line_outs &&\n\t    !(cond_flags & HDA_PINCFG_NO_LO_FIXUP)) {\n\t\tif (cfg->speaker_outs) {\n\t\t\tcfg->line_outs = cfg->speaker_outs;\n\t\t\tmemcpy(cfg->line_out_pins, cfg->speaker_pins,\n\t\t\t       sizeof(cfg->speaker_pins));\n\t\t\tcfg->speaker_outs = 0;\n\t\t\tmemset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));\n\t\t\tcfg->line_out_type = AUTO_PIN_SPEAKER_OUT;\n\t\t} else if (cfg->hp_outs) {\n\t\t\tcfg->line_outs = cfg->hp_outs;\n\t\t\tmemcpy(cfg->line_out_pins, cfg->hp_pins,\n\t\t\t       sizeof(cfg->hp_pins));\n\t\t\tcfg->hp_outs = 0;\n\t\t\tmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\n\t\t\tcfg->line_out_type = AUTO_PIN_HP_OUT;\n\t\t}\n\t}\n\n\treorder_outputs(cfg->line_outs, cfg->line_out_pins);\n\treorder_outputs(cfg->hp_outs, cfg->hp_pins);\n\treorder_outputs(cfg->speaker_outs, cfg->speaker_pins);\n\n\t \n\tsort(cfg->inputs, cfg->num_inputs, sizeof(cfg->inputs[0]),\n\t     compare_input_type, NULL);\n\n\t \n\tcodec_info(codec, \"autoconfig for %s: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\\n\",\n\t\t   codec->core.chip_name, cfg->line_outs, cfg->line_out_pins[0],\n\t\t   cfg->line_out_pins[1], cfg->line_out_pins[2],\n\t\t   cfg->line_out_pins[3], cfg->line_out_pins[4],\n\t\t   cfg->line_out_type == AUTO_PIN_HP_OUT ? \"hp\" :\n\t\t   (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT ?\n\t\t    \"speaker\" : \"line\"));\n\tcodec_info(codec, \"   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\\n\",\n\t\t   cfg->speaker_outs, cfg->speaker_pins[0],\n\t\t   cfg->speaker_pins[1], cfg->speaker_pins[2],\n\t\t   cfg->speaker_pins[3], cfg->speaker_pins[4]);\n\tcodec_info(codec, \"   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\\n\",\n\t\t   cfg->hp_outs, cfg->hp_pins[0],\n\t\t   cfg->hp_pins[1], cfg->hp_pins[2],\n\t\t   cfg->hp_pins[3], cfg->hp_pins[4]);\n\tcodec_info(codec, \"   mono: mono_out=0x%x\\n\", cfg->mono_out_pin);\n\tif (cfg->dig_outs)\n\t\tcodec_info(codec, \"   dig-out=0x%x/0x%x\\n\",\n\t\t\t   cfg->dig_out_pins[0], cfg->dig_out_pins[1]);\n\tcodec_info(codec, \"   inputs:\\n\");\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\tcodec_info(codec, \"     %s=0x%x\\n\",\n\t\t\t    hda_get_autocfg_input_label(codec, cfg, i),\n\t\t\t    cfg->inputs[i].pin);\n\t}\n\tif (cfg->dig_in_pin)\n\t\tcodec_info(codec, \"   dig-in=0x%x\\n\", cfg->dig_in_pin);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_parse_pin_defcfg);\n\n \nint snd_hda_get_input_pin_attr(unsigned int def_conf)\n{\n\tunsigned int loc = get_defcfg_location(def_conf);\n\tunsigned int conn = get_defcfg_connect(def_conf);\n\tif (conn == AC_JACK_PORT_NONE)\n\t\treturn INPUT_PIN_ATTR_UNUSED;\n\t \n\tif (conn == AC_JACK_PORT_FIXED || conn == AC_JACK_PORT_BOTH)\n\t\treturn INPUT_PIN_ATTR_INT;\n\tif ((loc & 0x30) == AC_JACK_LOC_INTERNAL)\n\t\treturn INPUT_PIN_ATTR_INT;\n\tif ((loc & 0x30) == AC_JACK_LOC_SEPARATE)\n\t\treturn INPUT_PIN_ATTR_DOCK;\n\tif (loc == AC_JACK_LOC_REAR)\n\t\treturn INPUT_PIN_ATTR_REAR;\n\tif (loc == AC_JACK_LOC_FRONT)\n\t\treturn INPUT_PIN_ATTR_FRONT;\n\treturn INPUT_PIN_ATTR_NORMAL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_input_pin_attr);\n\n \nstatic const char *hda_get_input_pin_label(struct hda_codec *codec,\n\t\t\t\t\t   const struct auto_pin_cfg_item *item,\n\t\t\t\t\t   hda_nid_t pin, bool check_location)\n{\n\tunsigned int def_conf;\n\tstatic const char * const mic_names[] = {\n\t\t\"Internal Mic\", \"Dock Mic\", \"Mic\", \"Rear Mic\", \"Front Mic\"\n\t};\n\tint attr;\n\n\tdef_conf = snd_hda_codec_get_pincfg(codec, pin);\n\n\tswitch (get_defcfg_device(def_conf)) {\n\tcase AC_JACK_MIC_IN:\n\t\tif (item && item->is_headset_mic)\n\t\t\treturn \"Headset Mic\";\n\t\tif (item && item->is_headphone_mic)\n\t\t\treturn \"Headphone Mic\";\n\t\tif (!check_location)\n\t\t\treturn \"Mic\";\n\t\tattr = snd_hda_get_input_pin_attr(def_conf);\n\t\tif (!attr)\n\t\t\treturn \"None\";\n\t\treturn mic_names[attr - 1];\n\tcase AC_JACK_LINE_IN:\n\t\tif (!check_location)\n\t\t\treturn \"Line\";\n\t\tattr = snd_hda_get_input_pin_attr(def_conf);\n\t\tif (!attr)\n\t\t\treturn \"None\";\n\t\tif (attr == INPUT_PIN_ATTR_DOCK)\n\t\t\treturn \"Dock Line\";\n\t\treturn \"Line\";\n\tcase AC_JACK_AUX:\n\t\treturn \"Aux\";\n\tcase AC_JACK_CD:\n\t\treturn \"CD\";\n\tcase AC_JACK_SPDIF_IN:\n\t\treturn \"SPDIF In\";\n\tcase AC_JACK_DIG_OTHER_IN:\n\t\treturn \"Digital In\";\n\tcase AC_JACK_HP_OUT:\n\t\treturn \"Headphone Mic\";\n\tdefault:\n\t\treturn \"Misc\";\n\t}\n}\n\n \nstatic int check_mic_location_need(struct hda_codec *codec,\n\t\t\t\t   const struct auto_pin_cfg *cfg,\n\t\t\t\t   int input)\n{\n\tunsigned int defc;\n\tint i, attr, attr2;\n\n\tdefc = snd_hda_codec_get_pincfg(codec, cfg->inputs[input].pin);\n\tattr = snd_hda_get_input_pin_attr(defc);\n\t \n\tif (attr <= INPUT_PIN_ATTR_NORMAL)\n\t\treturn 1;\n\n\tattr = 0;\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\tdefc = snd_hda_codec_get_pincfg(codec, cfg->inputs[i].pin);\n\t\tattr2 = snd_hda_get_input_pin_attr(defc);\n\t\tif (attr2 >= INPUT_PIN_ATTR_NORMAL) {\n\t\t\tif (attr && attr != attr2)\n\t\t\t\treturn 1;  \n\t\t\tattr = attr2;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nconst char *hda_get_autocfg_input_label(struct hda_codec *codec,\n\t\t\t\t\tconst struct auto_pin_cfg *cfg,\n\t\t\t\t\tint input)\n{\n\tint type = cfg->inputs[input].type;\n\tint has_multiple_pins = 0;\n\n\tif ((input > 0 && cfg->inputs[input - 1].type == type) ||\n\t    (input < cfg->num_inputs - 1 && cfg->inputs[input + 1].type == type))\n\t\thas_multiple_pins = 1;\n\tif (has_multiple_pins && type == AUTO_PIN_MIC)\n\t\thas_multiple_pins &= check_mic_location_need(codec, cfg, input);\n\thas_multiple_pins |= codec->force_pin_prefix;\n\treturn hda_get_input_pin_label(codec, &cfg->inputs[input],\n\t\t\t\t       cfg->inputs[input].pin,\n\t\t\t\t       has_multiple_pins);\n}\nEXPORT_SYMBOL_GPL(hda_get_autocfg_input_label);\n\n \nstatic int find_idx_in_nid_list(hda_nid_t nid, const hda_nid_t *list, int nums)\n{\n\tint i;\n\tfor (i = 0; i < nums; i++)\n\t\tif (list[i] == nid)\n\t\t\treturn i;\n\treturn -1;\n}\n\n \nstatic const char *check_output_sfx(hda_nid_t nid, const hda_nid_t *pins,\n\t\t\t\t    int num_pins, int *indexp)\n{\n\tstatic const char * const channel_sfx[] = {\n\t\t\" Front\", \" Surround\", \" CLFE\", \" Side\"\n\t};\n\tint i;\n\n\ti = find_idx_in_nid_list(nid, pins, num_pins);\n\tif (i < 0)\n\t\treturn NULL;\n\tif (num_pins == 1)\n\t\treturn \"\";\n\tif (num_pins > ARRAY_SIZE(channel_sfx)) {\n\t\tif (indexp)\n\t\t\t*indexp = i;\n\t\treturn \"\";\n\t}\n\treturn channel_sfx[i];\n}\n\nstatic const char *check_output_pfx(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tint attr = snd_hda_get_input_pin_attr(def_conf);\n\n\t \n\tswitch (attr) {\n\tcase INPUT_PIN_ATTR_DOCK:\n\t\treturn \"Dock \";\n\tcase INPUT_PIN_ATTR_FRONT:\n\t\treturn \"Front \";\n\t}\n\treturn \"\";\n}\n\nstatic int get_hp_label_index(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t      const hda_nid_t *pins, int num_pins)\n{\n\tint i, j, idx = 0;\n\n\tconst char *pfx = check_output_pfx(codec, nid);\n\n\ti = find_idx_in_nid_list(nid, pins, num_pins);\n\tif (i < 0)\n\t\treturn -1;\n\tfor (j = 0; j < i; j++)\n\t\tif (pfx == check_output_pfx(codec, pins[j]))\n\t\t\tidx++;\n\n\treturn idx;\n}\n\nstatic int fill_audio_out_name(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t       const struct auto_pin_cfg *cfg,\n\t\t\t       const char *name, char *label, int maxlen,\n\t\t\t       int *indexp)\n{\n\tunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tint attr = snd_hda_get_input_pin_attr(def_conf);\n\tconst char *pfx, *sfx = \"\";\n\n\t \n\tif (!strcmp(name, \"Line Out\") && attr == INPUT_PIN_ATTR_INT)\n\t\tname = \"Speaker\";\n\tpfx = check_output_pfx(codec, nid);\n\n\tif (cfg) {\n\t\t \n\t\tsfx = check_output_sfx(nid, cfg->line_out_pins, cfg->line_outs,\n\t\t\t\t       indexp);\n\t\tif (!sfx)\n\t\t\tsfx = check_output_sfx(nid, cfg->speaker_pins, cfg->speaker_outs,\n\t\t\t\t\t       indexp);\n\t\tif (!sfx) {\n\t\t\t \n\t\t\tint idx = get_hp_label_index(codec, nid, cfg->hp_pins,\n\t\t\t\t\t\t     cfg->hp_outs);\n\t\t\tif (idx >= 0 && indexp)\n\t\t\t\t*indexp = idx;\n\t\t\tsfx = \"\";\n\t\t}\n\t}\n\tsnprintf(label, maxlen, \"%s%s%s\", pfx, name, sfx);\n\treturn 1;\n}\n\n#define is_hdmi_cfg(conf) \\\n\t(get_defcfg_location(conf) == AC_JACK_LOC_HDMI)\n\n \nint snd_hda_get_pin_label(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  const struct auto_pin_cfg *cfg,\n\t\t\t  char *label, int maxlen, int *indexp)\n{\n\tunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tconst char *name = NULL;\n\tint i;\n\tbool hdmi;\n\n\tif (indexp)\n\t\t*indexp = 0;\n\tif (get_defcfg_connect(def_conf) == AC_JACK_PORT_NONE)\n\t\treturn 0;\n\n\tswitch (get_defcfg_device(def_conf)) {\n\tcase AC_JACK_LINE_OUT:\n\t\treturn fill_audio_out_name(codec, nid, cfg, \"Line Out\",\n\t\t\t\t\t   label, maxlen, indexp);\n\tcase AC_JACK_SPEAKER:\n\t\treturn fill_audio_out_name(codec, nid, cfg, \"Speaker\",\n\t\t\t\t\t   label, maxlen, indexp);\n\tcase AC_JACK_HP_OUT:\n\t\treturn fill_audio_out_name(codec, nid, cfg, \"Headphone\",\n\t\t\t\t\t   label, maxlen, indexp);\n\tcase AC_JACK_SPDIF_OUT:\n\tcase AC_JACK_DIG_OTHER_OUT:\n\t\thdmi = is_hdmi_cfg(def_conf);\n\t\tname = hdmi ? \"HDMI\" : \"SPDIF\";\n\t\tif (cfg && indexp)\n\t\t\tfor (i = 0; i < cfg->dig_outs; i++) {\n\t\t\t\thda_nid_t pin = cfg->dig_out_pins[i];\n\t\t\t\tunsigned int c;\n\t\t\t\tif (pin == nid)\n\t\t\t\t\tbreak;\n\t\t\t\tc = snd_hda_codec_get_pincfg(codec, pin);\n\t\t\t\tif (hdmi == is_hdmi_cfg(c))\n\t\t\t\t\t(*indexp)++;\n\t\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (cfg) {\n\t\t\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\t\t\tif (cfg->inputs[i].pin != nid)\n\t\t\t\t\tcontinue;\n\t\t\t\tname = hda_get_autocfg_input_label(codec, cfg, i);\n\t\t\t\tif (name)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!name)\n\t\t\tname = hda_get_input_pin_label(codec, NULL, nid, true);\n\t\tbreak;\n\t}\n\tif (!name)\n\t\treturn 0;\n\tstrscpy(label, name, maxlen);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_pin_label);\n\n \nint snd_hda_add_verbs(struct hda_codec *codec,\n\t\t      const struct hda_verb *list)\n{\n\tconst struct hda_verb **v;\n\tv = snd_array_new(&codec->verbs);\n\tif (!v)\n\t\treturn -ENOMEM;\n\t*v = list;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_verbs);\n\n \nvoid snd_hda_apply_verbs(struct hda_codec *codec)\n{\n\tconst struct hda_verb **v;\n\tint i;\n\n\tsnd_array_for_each(&codec->verbs, i, v)\n\t\tsnd_hda_sequence_write(codec, *v);\n}\nEXPORT_SYMBOL_GPL(snd_hda_apply_verbs);\n\n \nvoid snd_hda_apply_pincfgs(struct hda_codec *codec,\n\t\t\t   const struct hda_pintbl *cfg)\n{\n\tfor (; cfg->nid; cfg++)\n\t\tsnd_hda_codec_set_pincfg(codec, cfg->nid, cfg->val);\n}\nEXPORT_SYMBOL_GPL(snd_hda_apply_pincfgs);\n\nstatic void set_pin_targets(struct hda_codec *codec,\n\t\t\t    const struct hda_pintbl *cfg)\n{\n\tfor (; cfg->nid; cfg++)\n\t\tsnd_hda_set_pin_ctl_cache(codec, cfg->nid, cfg->val);\n}\n\nvoid __snd_hda_apply_fixup(struct hda_codec *codec, int id, int action, int depth)\n{\n\tconst char *modelname = codec->fixup_name;\n\n\twhile (id >= 0) {\n\t\tconst struct hda_fixup *fix = codec->fixup_list + id;\n\n\t\tif (++depth > 10)\n\t\t\tbreak;\n\t\tif (fix->chained_before)\n\t\t\t__snd_hda_apply_fixup(codec, fix->chain_id, action, depth + 1);\n\n\t\tswitch (fix->type) {\n\t\tcase HDA_FIXUP_PINS:\n\t\t\tif (action != HDA_FIXUP_ACT_PRE_PROBE || !fix->v.pins)\n\t\t\t\tbreak;\n\t\t\tcodec_dbg(codec, \"%s: Apply pincfg for %s\\n\",\n\t\t\t\t    codec->core.chip_name, modelname);\n\t\t\tsnd_hda_apply_pincfgs(codec, fix->v.pins);\n\t\t\tbreak;\n\t\tcase HDA_FIXUP_VERBS:\n\t\t\tif (action != HDA_FIXUP_ACT_PROBE || !fix->v.verbs)\n\t\t\t\tbreak;\n\t\t\tcodec_dbg(codec, \"%s: Apply fix-verbs for %s\\n\",\n\t\t\t\t    codec->core.chip_name, modelname);\n\t\t\tsnd_hda_add_verbs(codec, fix->v.verbs);\n\t\t\tbreak;\n\t\tcase HDA_FIXUP_FUNC:\n\t\t\tif (!fix->v.func)\n\t\t\t\tbreak;\n\t\t\tcodec_dbg(codec, \"%s: Apply fix-func for %s\\n\",\n\t\t\t\t    codec->core.chip_name, modelname);\n\t\t\tfix->v.func(codec, fix, action);\n\t\t\tbreak;\n\t\tcase HDA_FIXUP_PINCTLS:\n\t\t\tif (action != HDA_FIXUP_ACT_PROBE || !fix->v.pins)\n\t\t\t\tbreak;\n\t\t\tcodec_dbg(codec, \"%s: Apply pinctl for %s\\n\",\n\t\t\t\t    codec->core.chip_name, modelname);\n\t\t\tset_pin_targets(codec, fix->v.pins);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcodec_err(codec, \"%s: Invalid fixup type %d\\n\",\n\t\t\t\t   codec->core.chip_name, fix->type);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fix->chained || fix->chained_before)\n\t\t\tbreak;\n\t\tid = fix->chain_id;\n\t}\n}\nEXPORT_SYMBOL_GPL(__snd_hda_apply_fixup);\n\n \nvoid snd_hda_apply_fixup(struct hda_codec *codec, int action)\n{\n\tif (codec->fixup_list)\n\t\t__snd_hda_apply_fixup(codec, codec->fixup_id, action, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hda_apply_fixup);\n\n#define IGNORE_SEQ_ASSOC (~(AC_DEFCFG_SEQUENCE | AC_DEFCFG_DEF_ASSOC))\n\nstatic bool pin_config_match(struct hda_codec *codec,\n\t\t\t     const struct hda_pintbl *pins,\n\t\t\t     bool match_all_pins)\n{\n\tconst struct hda_pincfg *pin;\n\tint i;\n\n\tsnd_array_for_each(&codec->init_pins, i, pin) {\n\t\thda_nid_t nid = pin->nid;\n\t\tu32 cfg = pin->cfg;\n\t\tconst struct hda_pintbl *t_pins;\n\t\tint found;\n\n\t\tt_pins = pins;\n\t\tfound = 0;\n\t\tfor (; t_pins->nid; t_pins++) {\n\t\t\tif (t_pins->nid == nid) {\n\t\t\t\tfound = 1;\n\t\t\t\tif ((t_pins->val & IGNORE_SEQ_ASSOC) == (cfg & IGNORE_SEQ_ASSOC))\n\t\t\t\t\tbreak;\n\t\t\t\telse if ((cfg & 0xf0000000) == 0x40000000 && (t_pins->val & 0xf0000000) == 0x40000000)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (match_all_pins &&\n\t\t    !found && (cfg & 0xf0000000) != 0x40000000)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nvoid snd_hda_pick_pin_fixup(struct hda_codec *codec,\n\t\t\t    const struct snd_hda_pin_quirk *pin_quirk,\n\t\t\t    const struct hda_fixup *fixlist,\n\t\t\t    bool match_all_pins)\n{\n\tconst struct snd_hda_pin_quirk *pq;\n\n\tif (codec->fixup_id != HDA_FIXUP_ID_NOT_SET)\n\t\treturn;\n\n\tfor (pq = pin_quirk; pq->subvendor; pq++) {\n\t\tif ((codec->core.subsystem_id & 0xffff0000) != (pq->subvendor << 16))\n\t\t\tcontinue;\n\t\tif (codec->core.vendor_id != pq->codec)\n\t\t\tcontinue;\n\t\tif (pin_config_match(codec, pq->pins, match_all_pins)) {\n\t\t\tcodec->fixup_id = pq->value;\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\t\t\tcodec->fixup_name = pq->name;\n\t\t\tcodec_dbg(codec, \"%s: picked fixup %s (pin match)\\n\",\n\t\t\t\t  codec->core.chip_name, codec->fixup_name);\n#endif\n\t\t\tcodec->fixup_list = fixlist;\n\t\t\treturn;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_pick_pin_fixup);\n\n \nvoid snd_hda_pick_fixup(struct hda_codec *codec,\n\t\t\tconst struct hda_model_fixup *models,\n\t\t\tconst struct snd_pci_quirk *quirk,\n\t\t\tconst struct hda_fixup *fixlist)\n{\n\tconst struct snd_pci_quirk *q;\n\tint id = HDA_FIXUP_ID_NOT_SET;\n\tconst char *name = NULL;\n\tconst char *type = NULL;\n\tunsigned int vendor, device;\n\n\tif (codec->fixup_id != HDA_FIXUP_ID_NOT_SET)\n\t\treturn;\n\n\t \n\tif (codec->modelname && !strcmp(codec->modelname, \"nofixup\")) {\n\t\tid = HDA_FIXUP_ID_NO_FIXUP;\n\t\tfixlist = NULL;\n\t\tcodec_dbg(codec, \"%s: picked no fixup (nofixup specified)\\n\",\n\t\t\t  codec->core.chip_name);\n\t\tgoto found;\n\t}\n\n\t \n\tif (codec->modelname && models) {\n\t\twhile (models->name) {\n\t\t\tif (!strcmp(codec->modelname, models->name)) {\n\t\t\t\tid = models->id;\n\t\t\t\tname = models->name;\n\t\t\t\tcodec_dbg(codec, \"%s: picked fixup %s (model specified)\\n\",\n\t\t\t\t\t  codec->core.chip_name, codec->fixup_name);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tmodels++;\n\t\t}\n\t}\n\n\tif (!quirk)\n\t\treturn;\n\n\t \n\tif (codec->modelname &&\n\t    sscanf(codec->modelname, \"%04x:%04x\", &vendor, &device) == 2) {\n\t\tq = snd_pci_quirk_lookup_id(vendor, device, quirk);\n\t\tif (q) {\n\t\t\ttype = \"alias SSID\";\n\t\t\tgoto found_device;\n\t\t}\n\t}\n\n\t \n\tq = snd_pci_quirk_lookup(codec->bus->pci, quirk);\n\tif (q) {\n\t\ttype = \"PCI SSID\";\n\t\tgoto found_device;\n\t}\n\n\t \n\tq = snd_pci_quirk_lookup_id(codec->core.subsystem_id >> 16,\n\t\t\t\t    codec->core.subsystem_id & 0xffff,\n\t\t\t\t    quirk);\n\tif (q) {\n\t\ttype = \"codec SSID\";\n\t\tgoto found_device;\n\t}\n\n\treturn;  \n\n found_device:\n\tid = q->value;\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tname = q->name;\n#endif\n\tcodec_dbg(codec, \"%s: picked fixup %s for %s %04x:%04x\\n\",\n\t\t  codec->core.chip_name, name ? name : \"\",\n\t\t  type, q->subvendor, q->subdevice);\n found:\n\tcodec->fixup_id = id;\n\tcodec->fixup_list = fixlist;\n\tcodec->fixup_name = name;\n}\nEXPORT_SYMBOL_GPL(snd_hda_pick_fixup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}