{
  "module_name": "hda_generic.c",
  "hash_id": "45358ddf9e33355d147179d74384fd997d8f909304fd328b95b056a24d509d20",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_generic.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/leds.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/tlv.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n#include \"hda_beep.h\"\n#include \"hda_generic.h\"\n\n\n \nint snd_hda_gen_spec_init(struct hda_gen_spec *spec)\n{\n\tsnd_array_init(&spec->kctls, sizeof(struct snd_kcontrol_new), 32);\n\tsnd_array_init(&spec->paths, sizeof(struct nid_path), 8);\n\tsnd_array_init(&spec->loopback_list, sizeof(struct hda_amp_list), 8);\n\tmutex_init(&spec->pcm_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_spec_init);\n\n \nstruct snd_kcontrol_new *\nsnd_hda_gen_add_kctl(struct hda_gen_spec *spec, const char *name,\n\t\t     const struct snd_kcontrol_new *temp)\n{\n\tstruct snd_kcontrol_new *knew = snd_array_new(&spec->kctls);\n\tif (!knew)\n\t\treturn NULL;\n\t*knew = *temp;\n\tif (name)\n\t\tknew->name = kstrdup(name, GFP_KERNEL);\n\telse if (knew->name)\n\t\tknew->name = kstrdup(knew->name, GFP_KERNEL);\n\tif (!knew->name)\n\t\treturn NULL;\n\treturn knew;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_add_kctl);\n\nstatic void free_kctls(struct hda_gen_spec *spec)\n{\n\tif (spec->kctls.list) {\n\t\tstruct snd_kcontrol_new *kctl = spec->kctls.list;\n\t\tint i;\n\t\tfor (i = 0; i < spec->kctls.used; i++)\n\t\t\tkfree(kctl[i].name);\n\t}\n\tsnd_array_free(&spec->kctls);\n}\n\nstatic void snd_hda_gen_spec_free(struct hda_gen_spec *spec)\n{\n\tif (!spec)\n\t\treturn;\n\tfree_kctls(spec);\n\tsnd_array_free(&spec->paths);\n\tsnd_array_free(&spec->loopback_list);\n#ifdef CONFIG_SND_HDA_GENERIC_LEDS\n\tif (spec->led_cdevs[LED_AUDIO_MUTE])\n\t\tled_classdev_unregister(spec->led_cdevs[LED_AUDIO_MUTE]);\n\tif (spec->led_cdevs[LED_AUDIO_MICMUTE])\n\t\tled_classdev_unregister(spec->led_cdevs[LED_AUDIO_MICMUTE]);\n#endif\n}\n\n \nstatic void parse_user_hints(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint val;\n\n\tval = snd_hda_get_bool_hint(codec, \"jack_detect\");\n\tif (val >= 0)\n\t\tcodec->no_jack_detect = !val;\n\tval = snd_hda_get_bool_hint(codec, \"inv_jack_detect\");\n\tif (val >= 0)\n\t\tcodec->inv_jack_detect = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"trigger_sense\");\n\tif (val >= 0)\n\t\tcodec->no_trigger_sense = !val;\n\tval = snd_hda_get_bool_hint(codec, \"inv_eapd\");\n\tif (val >= 0)\n\t\tcodec->inv_eapd = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"pcm_format_first\");\n\tif (val >= 0)\n\t\tcodec->pcm_format_first = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"sticky_stream\");\n\tif (val >= 0)\n\t\tcodec->no_sticky_stream = !val;\n\tval = snd_hda_get_bool_hint(codec, \"spdif_status_reset\");\n\tif (val >= 0)\n\t\tcodec->spdif_status_reset = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"pin_amp_workaround\");\n\tif (val >= 0)\n\t\tcodec->pin_amp_workaround = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"single_adc_amp\");\n\tif (val >= 0)\n\t\tcodec->single_adc_amp = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"power_save_node\");\n\tif (val >= 0)\n\t\tcodec->power_save_node = !!val;\n\n\tval = snd_hda_get_bool_hint(codec, \"auto_mute\");\n\tif (val >= 0)\n\t\tspec->suppress_auto_mute = !val;\n\tval = snd_hda_get_bool_hint(codec, \"auto_mic\");\n\tif (val >= 0)\n\t\tspec->suppress_auto_mic = !val;\n\tval = snd_hda_get_bool_hint(codec, \"line_in_auto_switch\");\n\tif (val >= 0)\n\t\tspec->line_in_auto_switch = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"auto_mute_via_amp\");\n\tif (val >= 0)\n\t\tspec->auto_mute_via_amp = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"need_dac_fix\");\n\tif (val >= 0)\n\t\tspec->need_dac_fix = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"primary_hp\");\n\tif (val >= 0)\n\t\tspec->no_primary_hp = !val;\n\tval = snd_hda_get_bool_hint(codec, \"multi_io\");\n\tif (val >= 0)\n\t\tspec->no_multi_io = !val;\n\tval = snd_hda_get_bool_hint(codec, \"multi_cap_vol\");\n\tif (val >= 0)\n\t\tspec->multi_cap_vol = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"inv_dmic_split\");\n\tif (val >= 0)\n\t\tspec->inv_dmic_split = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"indep_hp\");\n\tif (val >= 0)\n\t\tspec->indep_hp = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"add_stereo_mix_input\");\n\tif (val >= 0)\n\t\tspec->add_stereo_mix_input = !!val;\n\t \n\tval = snd_hda_get_bool_hint(codec, \"add_out_jack_modes\");\n\tif (val >= 0)\n\t\tspec->add_jack_modes = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"add_in_jack_modes\");\n\tif (val >= 0)\n\t\tspec->add_jack_modes = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"add_jack_modes\");\n\tif (val >= 0)\n\t\tspec->add_jack_modes = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"power_down_unused\");\n\tif (val >= 0)\n\t\tspec->power_down_unused = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"add_hp_mic\");\n\tif (val >= 0)\n\t\tspec->hp_mic = !!val;\n\tval = snd_hda_get_bool_hint(codec, \"hp_mic_detect\");\n\tif (val >= 0)\n\t\tspec->suppress_hp_mic_detect = !val;\n\tval = snd_hda_get_bool_hint(codec, \"vmaster\");\n\tif (val >= 0)\n\t\tspec->suppress_vmaster = !val;\n\n\tif (!snd_hda_get_int_hint(codec, \"mixer_nid\", &val))\n\t\tspec->mixer_nid = val;\n}\n\n \n\n#define update_pin_ctl(codec, pin, val) \\\n\tsnd_hda_codec_write_cache(codec, pin, 0, \\\n\t\t\t\t   AC_VERB_SET_PIN_WIDGET_CONTROL, val)\n\n \nstatic inline void restore_pin_ctl(struct hda_codec *codec, hda_nid_t pin)\n{\n\tupdate_pin_ctl(codec, pin, snd_hda_codec_get_pin_target(codec, pin));\n}\n\n \nstatic void set_pin_target(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t   unsigned int val, bool do_write)\n{\n\tif (!pin)\n\t\treturn;\n\tval = snd_hda_correct_pin_ctl(codec, pin, val);\n\tsnd_hda_codec_set_pin_target(codec, pin, val);\n\tif (do_write)\n\t\tupdate_pin_ctl(codec, pin, val);\n}\n\n \nstatic void set_pin_targets(struct hda_codec *codec, int num_pins,\n\t\t\t    hda_nid_t *pins, unsigned int val)\n{\n\tint i;\n\tfor (i = 0; i < num_pins; i++)\n\t\tset_pin_target(codec, pins[i], val, false);\n}\n\n \n\n \nstatic int find_idx_in_nid_list(hda_nid_t nid, const hda_nid_t *list, int nums)\n{\n\tint i;\n\tfor (i = 0; i < nums; i++)\n\t\tif (list[i] == nid)\n\t\t\treturn i;\n\treturn -1;\n}\n\n \nstatic bool is_nid_contained(struct nid_path *path, hda_nid_t nid)\n{\n\treturn find_idx_in_nid_list(nid, path->path, path->depth) >= 0;\n}\n\nstatic struct nid_path *get_nid_path(struct hda_codec *codec,\n\t\t\t\t     hda_nid_t from_nid, hda_nid_t to_nid,\n\t\t\t\t     int anchor_nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\tint i;\n\n\tsnd_array_for_each(&spec->paths, i, path) {\n\t\tif (path->depth <= 0)\n\t\t\tcontinue;\n\t\tif ((!from_nid || path->path[0] == from_nid) &&\n\t\t    (!to_nid || path->path[path->depth - 1] == to_nid)) {\n\t\t\tif (!anchor_nid ||\n\t\t\t    (anchor_nid > 0 && is_nid_contained(path, anchor_nid)) ||\n\t\t\t    (anchor_nid < 0 && !is_nid_contained(path, anchor_nid)))\n\t\t\t\treturn path;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nint snd_hda_get_path_idx(struct hda_codec *codec, struct nid_path *path)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *array = spec->paths.list;\n\tssize_t idx;\n\n\tif (!spec->paths.used)\n\t\treturn 0;\n\tidx = path - array;\n\tif (idx < 0 || idx >= spec->paths.used)\n\t\treturn 0;\n\treturn idx + 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_path_idx);\n\n \nstruct nid_path *snd_hda_get_path_from_idx(struct hda_codec *codec, int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (idx <= 0 || idx > spec->paths.used)\n\t\treturn NULL;\n\treturn snd_array_elem(&spec->paths, idx - 1);\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_path_from_idx);\n\n \nstatic bool is_dac_already_used(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct nid_path *path;\n\tint i;\n\n\tsnd_array_for_each(&spec->paths, i, path) {\n\t\tif (path->path[0] == nid)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool is_reachable_path(struct hda_codec *codec,\n\t\t\t      hda_nid_t from_nid, hda_nid_t to_nid)\n{\n\tif (!from_nid || !to_nid)\n\t\treturn false;\n\treturn snd_hda_get_conn_index(codec, to_nid, from_nid, true) >= 0;\n}\n\n \n#define AMP_VAL_COMPARE_MASK\t(0xffff | (1U << 18) | (0x0f << 19))\n\n \nstatic bool is_ctl_used(struct hda_codec *codec, unsigned int val, int type)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct nid_path *path;\n\tint i;\n\n\tval &= AMP_VAL_COMPARE_MASK;\n\tsnd_array_for_each(&spec->paths, i, path) {\n\t\tif ((path->ctls[type] & AMP_VAL_COMPARE_MASK) == val)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool is_ctl_associated(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t      int dir, int idx, int type)\n{\n\tunsigned int val = HDA_COMPOSE_AMP_VAL(nid, 3, idx, dir);\n\treturn is_ctl_used(codec, val, type);\n}\n\nstatic void print_nid_path(struct hda_codec *codec,\n\t\t\t   const char *pfx, struct nid_path *path)\n{\n\tchar buf[40];\n\tchar *pos = buf;\n\tint i;\n\n\t*pos = 0;\n\tfor (i = 0; i < path->depth; i++)\n\t\tpos += scnprintf(pos, sizeof(buf) - (pos - buf), \"%s%02x\",\n\t\t\t\t pos != buf ? \":\" : \"\",\n\t\t\t\t path->path[i]);\n\n\tcodec_dbg(codec, \"%s path: depth=%d '%s'\\n\", pfx, path->depth, buf);\n}\n\n \nstatic bool __parse_nid_path(struct hda_codec *codec,\n\t\t\t     hda_nid_t from_nid, hda_nid_t to_nid,\n\t\t\t     int anchor_nid, struct nid_path *path,\n\t\t\t     int depth)\n{\n\tconst hda_nid_t *conn;\n\tint i, nums;\n\n\tif (to_nid == anchor_nid)\n\t\tanchor_nid = 0;  \n\telse if (to_nid == (hda_nid_t)(-anchor_nid))\n\t\treturn false;  \n\n\tnums = snd_hda_get_conn_list(codec, to_nid, &conn);\n\tfor (i = 0; i < nums; i++) {\n\t\tif (conn[i] != from_nid) {\n\t\t\t \n\t\t\tif (from_nid ||\n\t\t\t    get_wcaps_type(get_wcaps(codec, conn[i])) != AC_WID_AUD_OUT ||\n\t\t\t    is_dac_already_used(codec, conn[i]))\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (anchor_nid <= 0)\n\t\t\tgoto found;\n\t}\n\tif (depth >= MAX_NID_PATH_DEPTH)\n\t\treturn false;\n\tfor (i = 0; i < nums; i++) {\n\t\tunsigned int type;\n\t\ttype = get_wcaps_type(get_wcaps(codec, conn[i]));\n\t\tif (type == AC_WID_AUD_OUT || type == AC_WID_AUD_IN ||\n\t\t    type == AC_WID_PIN)\n\t\t\tcontinue;\n\t\tif (__parse_nid_path(codec, from_nid, conn[i],\n\t\t\t\t     anchor_nid, path, depth + 1))\n\t\t\tgoto found;\n\t}\n\treturn false;\n\n found:\n\tpath->path[path->depth] = conn[i];\n\tpath->idx[path->depth + 1] = i;\n\tif (nums > 1 && get_wcaps_type(get_wcaps(codec, to_nid)) != AC_WID_AUD_MIX)\n\t\tpath->multi[path->depth + 1] = 1;\n\tpath->depth++;\n\treturn true;\n}\n\n \nstatic bool snd_hda_parse_nid_path(struct hda_codec *codec, hda_nid_t from_nid,\n\t\t\t    hda_nid_t to_nid, int anchor_nid,\n\t\t\t    struct nid_path *path)\n{\n\tif (__parse_nid_path(codec, from_nid, to_nid, anchor_nid, path, 1)) {\n\t\tpath->path[path->depth] = to_nid;\n\t\tpath->depth++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstruct nid_path *\nsnd_hda_add_new_path(struct hda_codec *codec, hda_nid_t from_nid,\n\t\t     hda_nid_t to_nid, int anchor_nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\n\tif (from_nid && to_nid && !is_reachable_path(codec, from_nid, to_nid))\n\t\treturn NULL;\n\n\t \n\tpath = get_nid_path(codec, from_nid, to_nid, anchor_nid);\n\tif (path)\n\t\treturn path;\n\n\tpath = snd_array_new(&spec->paths);\n\tif (!path)\n\t\treturn NULL;\n\tmemset(path, 0, sizeof(*path));\n\tif (snd_hda_parse_nid_path(codec, from_nid, to_nid, anchor_nid, path))\n\t\treturn path;\n\t \n\tspec->paths.used--;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_new_path);\n\n \nstatic void invalidate_nid_path(struct hda_codec *codec, int idx)\n{\n\tstruct nid_path *path = snd_hda_get_path_from_idx(codec, idx);\n\tif (!path)\n\t\treturn;\n\tmemset(path, 0, sizeof(*path));\n}\n\n \nstatic hda_nid_t get_preferred_dac(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst hda_nid_t *list = spec->preferred_dacs;\n\n\tif (!list)\n\t\treturn 0;\n\tfor (; *list; list += 2)\n\t\tif (*list == pin)\n\t\t\treturn list[1];\n\treturn 0;\n}\n\n \nstatic hda_nid_t look_for_dac(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t      bool is_digital)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tbool cap_digital;\n\tint i;\n\n\tfor (i = 0; i < spec->num_all_dacs; i++) {\n\t\thda_nid_t nid = spec->all_dacs[i];\n\t\tif (!nid || is_dac_already_used(codec, nid))\n\t\t\tcontinue;\n\t\tcap_digital = !!(get_wcaps(codec, nid) & AC_WCAP_DIGITAL);\n\t\tif (is_digital != cap_digital)\n\t\t\tcontinue;\n\t\tif (is_reachable_path(codec, nid, pin))\n\t\t\treturn nid;\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int amp_val_replace_channels(unsigned int val, unsigned int chs)\n{\n\tval &= ~(0x3U << 16);\n\tval |= chs << 16;\n\treturn val;\n}\n\nstatic bool same_amp_caps(struct hda_codec *codec, hda_nid_t nid1,\n\t\t\t  hda_nid_t nid2, int dir)\n{\n\tif (!(get_wcaps(codec, nid1) & (1 << (dir + 1))))\n\t\treturn !(get_wcaps(codec, nid2) & (1 << (dir + 1)));\n\treturn (query_amp_caps(codec, nid1, dir) ==\n\t\tquery_amp_caps(codec, nid2, dir));\n}\n\n \nstatic hda_nid_t look_for_out_mute_nid(struct hda_codec *codec,\n\t\t\t\t       struct nid_path *path)\n{\n\tint i;\n\n\tfor (i = path->depth - 1; i >= 0; i--) {\n\t\tif (nid_has_mute(codec, path->path[i], HDA_OUTPUT))\n\t\t\treturn path->path[i];\n\t\tif (i != path->depth - 1 && i != 0 &&\n\t\t    nid_has_mute(codec, path->path[i], HDA_INPUT))\n\t\t\treturn path->path[i];\n\t}\n\treturn 0;\n}\n\n \nstatic hda_nid_t look_for_out_vol_nid(struct hda_codec *codec,\n\t\t\t\t      struct nid_path *path)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tfor (i = path->depth - 1; i >= 0; i--) {\n\t\thda_nid_t nid = path->path[i];\n\t\tif ((spec->out_vol_mask >> nid) & 1)\n\t\t\tcontinue;\n\t\tif (nid_has_volume(codec, nid, HDA_OUTPUT))\n\t\t\treturn nid;\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic bool has_amp_in(struct hda_codec *codec, struct nid_path *path, int idx)\n{\n\thda_nid_t nid = path->path[idx];\n\tunsigned int caps = get_wcaps(codec, nid);\n\tunsigned int type = get_wcaps_type(caps);\n\n\tif (!(caps & AC_WCAP_IN_AMP))\n\t\treturn false;\n\tif (type == AC_WID_PIN && idx > 0)  \n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool has_amp_out(struct hda_codec *codec, struct nid_path *path, int idx)\n{\n\thda_nid_t nid = path->path[idx];\n\tunsigned int caps = get_wcaps(codec, nid);\n\tunsigned int type = get_wcaps_type(caps);\n\n\tif (!(caps & AC_WCAP_OUT_AMP))\n\t\treturn false;\n\tif (type == AC_WID_PIN && !idx)  \n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool is_active_nid(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  unsigned int dir, unsigned int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint type = get_wcaps_type(get_wcaps(codec, nid));\n\tconst struct nid_path *path;\n\tint i, n;\n\n\tif (nid == codec->core.afg)\n\t\treturn true;\n\n\tsnd_array_for_each(&spec->paths, n, path) {\n\t\tif (!path->active)\n\t\t\tcontinue;\n\t\tif (codec->power_save_node) {\n\t\t\tif (!path->stream_enabled)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!(path->pin_enabled || path->pin_fixed) &&\n\t\t\t    type != AC_WID_AUD_OUT && type != AC_WID_AUD_IN)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < path->depth; i++) {\n\t\t\tif (path->path[i] == nid) {\n\t\t\t\tif (dir == HDA_OUTPUT || idx == -1 ||\n\t\t\t\t    path->idx[i] == idx)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n \n#define is_active_nid_for_any(codec, nid) \\\n\tis_active_nid(codec, nid, HDA_OUTPUT, -1)\n\n \nstatic int get_amp_val_to_activate(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t   int dir, unsigned int caps, bool enable)\n{\n\tunsigned int val = 0;\n\n\tif (caps & AC_AMPCAP_NUM_STEPS) {\n\t\t \n\t\tif (enable)\n\t\t\tval = (caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT;\n\t}\n\tif (caps & (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) {\n\t\tif (!enable)\n\t\t\tval |= HDA_AMP_MUTE;\n\t}\n\treturn val;\n}\n\n \nstatic bool is_stereo_amps(struct hda_codec *codec, hda_nid_t nid, int dir)\n{\n\tunsigned int wcaps = get_wcaps(codec, nid);\n\thda_nid_t conn;\n\n\tif (wcaps & AC_WCAP_STEREO)\n\t\treturn true;\n\tif (dir != HDA_INPUT || get_wcaps_type(wcaps) != AC_WID_AUD_MIX)\n\t\treturn false;\n\tif (snd_hda_get_num_conns(codec, nid) != 1)\n\t\treturn false;\n\tif (snd_hda_get_connections(codec, nid, &conn, 1) < 0)\n\t\treturn false;\n\treturn !!(get_wcaps(codec, conn) & AC_WCAP_STEREO);\n}\n\n \nstatic void init_amp(struct hda_codec *codec, hda_nid_t nid, int dir, int idx)\n{\n\tunsigned int caps = query_amp_caps(codec, nid, dir);\n\tint val = get_amp_val_to_activate(codec, nid, dir, caps, false);\n\n\tif (is_stereo_amps(codec, nid, dir))\n\t\tsnd_hda_codec_amp_init_stereo(codec, nid, dir, idx, 0xff, val);\n\telse\n\t\tsnd_hda_codec_amp_init(codec, nid, 0, dir, idx, 0xff, val);\n}\n\n \nstatic int update_amp(struct hda_codec *codec, hda_nid_t nid, int dir, int idx,\n\t\t      unsigned int mask, unsigned int val)\n{\n\tif (is_stereo_amps(codec, nid, dir))\n\t\treturn snd_hda_codec_amp_stereo(codec, nid, dir, idx,\n\t\t\t\t\t\tmask, val);\n\telse\n\t\treturn snd_hda_codec_amp_update(codec, nid, 0, dir, idx,\n\t\t\t\t\t\tmask, val);\n}\n\n \nstatic unsigned int get_amp_mask_to_modify(struct hda_codec *codec,\n\t\t\t\t\t   hda_nid_t nid, int dir, int idx,\n\t\t\t\t\t   unsigned int caps)\n{\n\tunsigned int mask = 0xff;\n\n\tif (caps & (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) {\n\t\tif (is_ctl_associated(codec, nid, dir, idx, NID_PATH_MUTE_CTL))\n\t\t\tmask &= ~0x80;\n\t}\n\tif (caps & AC_AMPCAP_NUM_STEPS) {\n\t\tif (is_ctl_associated(codec, nid, dir, idx, NID_PATH_VOL_CTL) ||\n\t\t    is_ctl_associated(codec, nid, dir, idx, NID_PATH_BOOST_CTL))\n\t\t\tmask &= ~0x7f;\n\t}\n\treturn mask;\n}\n\nstatic void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t int idx, int idx_to_check, bool enable)\n{\n\tunsigned int caps;\n\tunsigned int mask, val;\n\n\tcaps = query_amp_caps(codec, nid, dir);\n\tval = get_amp_val_to_activate(codec, nid, dir, caps, enable);\n\tmask = get_amp_mask_to_modify(codec, nid, dir, idx_to_check, caps);\n\tif (!mask)\n\t\treturn;\n\n\tval &= mask;\n\tupdate_amp(codec, nid, dir, idx, mask, val);\n}\n\nstatic void check_and_activate_amp(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t   int dir, int idx, int idx_to_check,\n\t\t\t\t   bool enable)\n{\n\t \n\tif (!enable && is_active_nid(codec, nid, dir, idx_to_check))\n\t\treturn;\n\tactivate_amp(codec, nid, dir, idx, idx_to_check, enable);\n}\n\nstatic void activate_amp_out(struct hda_codec *codec, struct nid_path *path,\n\t\t\t     int i, bool enable)\n{\n\thda_nid_t nid = path->path[i];\n\tinit_amp(codec, nid, HDA_OUTPUT, 0);\n\tcheck_and_activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);\n}\n\nstatic void activate_amp_in(struct hda_codec *codec, struct nid_path *path,\n\t\t\t    int i, bool enable, bool add_aamix)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst hda_nid_t *conn;\n\tint n, nums, idx;\n\tint type;\n\thda_nid_t nid = path->path[i];\n\n\tnums = snd_hda_get_conn_list(codec, nid, &conn);\n\tif (nums < 0)\n\t\treturn;\n\ttype = get_wcaps_type(get_wcaps(codec, nid));\n\tif (type == AC_WID_PIN ||\n\t    (type == AC_WID_AUD_IN && codec->single_adc_amp)) {\n\t\tnums = 1;\n\t\tidx = 0;\n\t} else\n\t\tidx = path->idx[i];\n\n\tfor (n = 0; n < nums; n++)\n\t\tinit_amp(codec, nid, HDA_INPUT, n);\n\n\t \n\tfor (n = 0; n < nums; n++) {\n\t\tif (n != idx) {\n\t\t\tif (conn[n] != spec->mixer_merge_nid)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!add_aamix) {\n\t\t\t\tactivate_amp(codec, nid, HDA_INPUT, n, n, false);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tcheck_and_activate_amp(codec, nid, HDA_INPUT, n, idx, enable);\n\t}\n}\n\n \nstatic hda_nid_t path_power_update(struct hda_codec *codec,\n\t\t\t\t   struct nid_path *path,\n\t\t\t\t   bool allow_powerdown)\n{\n\thda_nid_t nid, changed = 0;\n\tint i, state, power;\n\n\tfor (i = 0; i < path->depth; i++) {\n\t\tnid = path->path[i];\n\t\tif (!(get_wcaps(codec, nid) & AC_WCAP_POWER))\n\t\t\tcontinue;\n\t\tif (nid == codec->core.afg)\n\t\t\tcontinue;\n\t\tif (!allow_powerdown || is_active_nid_for_any(codec, nid))\n\t\t\tstate = AC_PWRST_D0;\n\t\telse\n\t\t\tstate = AC_PWRST_D3;\n\t\tpower = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t   AC_VERB_GET_POWER_STATE, 0);\n\t\tif (power != (state | (state << 4))) {\n\t\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_POWER_STATE, state);\n\t\t\tchanged = nid;\n\t\t\t \n#if 0  \n\t\t\tif (state == AC_PWRST_D0)\n\t\t\t\tsnd_hdac_regmap_sync_node(&codec->core, nid);\n#endif\n\t\t}\n\t}\n\treturn changed;\n}\n\n \nstatic void sync_power_state_change(struct hda_codec *codec, hda_nid_t nid)\n{\n\tif (nid) {\n\t\tmsleep(10);\n\t\tsnd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);\n\t}\n}\n\n \nvoid snd_hda_activate_path(struct hda_codec *codec, struct nid_path *path,\n\t\t\t   bool enable, bool add_aamix)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tpath->active = enable;\n\n\t \n\tif (enable && (spec->power_down_unused || codec->power_save_node))\n\t\tpath_power_update(codec, path, codec->power_save_node);\n\n\tfor (i = path->depth - 1; i >= 0; i--) {\n\t\thda_nid_t nid = path->path[i];\n\n\t\tif (enable && path->multi[i])\n\t\t\tsnd_hda_codec_write_cache(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t\t    path->idx[i]);\n\t\tif (has_amp_in(codec, path, i))\n\t\t\tactivate_amp_in(codec, path, i, enable, add_aamix);\n\t\tif (has_amp_out(codec, path, i))\n\t\t\tactivate_amp_out(codec, path, i, enable);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_activate_path);\n\n \nstatic void path_power_down_sync(struct hda_codec *codec, struct nid_path *path)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (!(spec->power_down_unused || codec->power_save_node) || path->active)\n\t\treturn;\n\tsync_power_state_change(codec, path_power_update(codec, path, true));\n}\n\n \nstatic void set_pin_eapd(struct hda_codec *codec, hda_nid_t pin, bool enable)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->own_eapd_ctl ||\n\t    !(snd_hda_query_pin_caps(codec, pin) & AC_PINCAP_EAPD))\n\t\treturn;\n\tif (spec->keep_eapd_on && !enable)\n\t\treturn;\n\tif (codec->inv_eapd)\n\t\tenable = !enable;\n\tsnd_hda_codec_write_cache(codec, pin, 0,\n\t\t\t\t   AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t\t   enable ? 0x02 : 0x00);\n}\n\n \nstatic void resume_path_from_idx(struct hda_codec *codec, int path_idx)\n{\n\tstruct nid_path *path = snd_hda_get_path_from_idx(codec, path_idx);\n\tif (path)\n\t\tsnd_hda_activate_path(codec, path, path->active, false);\n}\n\n\n \n\nstatic int hda_gen_mixer_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol);\nstatic int hda_gen_bind_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\nstatic int hda_gen_bind_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\n\nenum {\n\tHDA_CTL_WIDGET_VOL,\n\tHDA_CTL_WIDGET_MUTE,\n\tHDA_CTL_BIND_MUTE,\n};\nstatic const struct snd_kcontrol_new control_templates[] = {\n\tHDA_CODEC_VOLUME(NULL, 0, 0, 0),\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.subdevice = HDA_SUBDEV_AMP_FLAG,\n\t\t.info = snd_hda_mixer_amp_switch_info,\n\t\t.get = snd_hda_mixer_amp_switch_get,\n\t\t.put = hda_gen_mixer_mute_put,  \n\t\t.private_value = HDA_COMPOSE_AMP_VAL(0, 3, 0, 0),\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = snd_hda_mixer_amp_switch_info,\n\t\t.get = hda_gen_bind_mute_get,\n\t\t.put = hda_gen_bind_mute_put,  \n\t\t.private_value = HDA_COMPOSE_AMP_VAL(0, 3, 0, 0),\n\t},\n};\n\n \nstatic struct snd_kcontrol_new *\nadd_control(struct hda_gen_spec *spec, int type, const char *name,\n\t\t       int cidx, unsigned long val)\n{\n\tstruct snd_kcontrol_new *knew;\n\n\tknew = snd_hda_gen_add_kctl(spec, name, &control_templates[type]);\n\tif (!knew)\n\t\treturn NULL;\n\tknew->index = cidx;\n\tif (get_amp_nid_(val))\n\t\tknew->subdevice = HDA_SUBDEV_AMP_FLAG;\n\tif (knew->access == 0)\n\t\tknew->access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tknew->private_value = val;\n\treturn knew;\n}\n\nstatic int add_control_with_pfx(struct hda_gen_spec *spec, int type,\n\t\t\t\tconst char *pfx, const char *dir,\n\t\t\t\tconst char *sfx, int cidx, unsigned long val)\n{\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint len;\n\n\tlen = snprintf(name, sizeof(name), \"%s %s %s\", pfx, dir, sfx);\n\tif (snd_BUG_ON(len >= sizeof(name)))\n\t\treturn -EINVAL;\n\tif (!add_control(spec, type, name, cidx, val))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n#define add_pb_vol_ctrl(spec, type, pfx, val)\t\t\t\\\n\tadd_control_with_pfx(spec, type, pfx, \"Playback\", \"Volume\", 0, val)\n#define add_pb_sw_ctrl(spec, type, pfx, val)\t\t\t\\\n\tadd_control_with_pfx(spec, type, pfx, \"Playback\", \"Switch\", 0, val)\n#define __add_pb_vol_ctrl(spec, type, pfx, cidx, val)\t\t\t\\\n\tadd_control_with_pfx(spec, type, pfx, \"Playback\", \"Volume\", cidx, val)\n#define __add_pb_sw_ctrl(spec, type, pfx, cidx, val)\t\t\t\\\n\tadd_control_with_pfx(spec, type, pfx, \"Playback\", \"Switch\", cidx, val)\n\nstatic int add_vol_ctl(struct hda_codec *codec, const char *pfx, int cidx,\n\t\t       unsigned int chs, struct nid_path *path)\n{\n\tunsigned int val;\n\tif (!path)\n\t\treturn 0;\n\tval = path->ctls[NID_PATH_VOL_CTL];\n\tif (!val)\n\t\treturn 0;\n\tval = amp_val_replace_channels(val, chs);\n\treturn __add_pb_vol_ctrl(codec->spec, HDA_CTL_WIDGET_VOL, pfx, cidx, val);\n}\n\n \nstatic int get_default_ch_nums(struct hda_codec *codec, struct nid_path *path,\n\t\t\t       int type)\n{\n\tint chs = 1;  \n\tif (path) {\n\t\thda_nid_t nid = get_amp_nid_(path->ctls[type]);\n\t\tif (nid && (get_wcaps(codec, nid) & AC_WCAP_STEREO))\n\t\t\tchs = 3;  \n\t}\n\treturn chs;\n}\n\nstatic int add_stereo_vol(struct hda_codec *codec, const char *pfx, int cidx,\n\t\t\t  struct nid_path *path)\n{\n\tint chs = get_default_ch_nums(codec, path, NID_PATH_VOL_CTL);\n\treturn add_vol_ctl(codec, pfx, cidx, chs, path);\n}\n\n \nstatic int add_sw_ctl(struct hda_codec *codec, const char *pfx, int cidx,\n\t\t      unsigned int chs, struct nid_path *path)\n{\n\tunsigned int val;\n\tint type = HDA_CTL_WIDGET_MUTE;\n\n\tif (!path)\n\t\treturn 0;\n\tval = path->ctls[NID_PATH_MUTE_CTL];\n\tif (!val)\n\t\treturn 0;\n\tval = amp_val_replace_channels(val, chs);\n\tif (get_amp_direction_(val) == HDA_INPUT) {\n\t\thda_nid_t nid = get_amp_nid_(val);\n\t\tint nums = snd_hda_get_num_conns(codec, nid);\n\t\tif (nums > 1) {\n\t\t\ttype = HDA_CTL_BIND_MUTE;\n\t\t\tval |= nums << 19;\n\t\t}\n\t}\n\treturn __add_pb_sw_ctrl(codec->spec, type, pfx, cidx, val);\n}\n\nstatic int add_stereo_sw(struct hda_codec *codec, const char *pfx,\n\t\t\t\t  int cidx, struct nid_path *path)\n{\n\tint chs = get_default_ch_nums(codec, path, NID_PATH_MUTE_CTL);\n\treturn add_sw_ctl(codec, pfx, cidx, chs, path);\n}\n\n \nstatic void sync_auto_mute_bits(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (spec->auto_mute_via_amp) {\n\t\thda_nid_t nid = get_amp_nid(kcontrol);\n\t\tbool enabled = !((spec->mute_bits >> nid) & 1);\n\t\tucontrol->value.integer.value[0] &= enabled;\n\t\tucontrol->value.integer.value[1] &= enabled;\n\t}\n}\n\nstatic int hda_gen_mixer_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tsync_auto_mute_bits(kcontrol, ucontrol);\n\treturn snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\n}\n\n \n#define AMP_VAL_IDX_SHIFT\t19\n#define AMP_VAL_IDX_MASK\t(0x0f<<19)\n\nstatic int hda_gen_bind_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tunsigned long pval;\n\tint err;\n\n\tmutex_lock(&codec->control_mutex);\n\tpval = kcontrol->private_value;\n\tkcontrol->private_value = pval & ~AMP_VAL_IDX_MASK;  \n\terr = snd_hda_mixer_amp_switch_get(kcontrol, ucontrol);\n\tkcontrol->private_value = pval;\n\tmutex_unlock(&codec->control_mutex);\n\treturn err;\n}\n\nstatic int hda_gen_bind_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tunsigned long pval;\n\tint i, indices, err = 0, change = 0;\n\n\tsync_auto_mute_bits(kcontrol, ucontrol);\n\n\tmutex_lock(&codec->control_mutex);\n\tpval = kcontrol->private_value;\n\tindices = (pval & AMP_VAL_IDX_MASK) >> AMP_VAL_IDX_SHIFT;\n\tfor (i = 0; i < indices; i++) {\n\t\tkcontrol->private_value = (pval & ~AMP_VAL_IDX_MASK) |\n\t\t\t(i << AMP_VAL_IDX_SHIFT);\n\t\terr = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tchange |= err;\n\t}\n\tkcontrol->private_value = pval;\n\tmutex_unlock(&codec->control_mutex);\n\treturn err < 0 ? err : change;\n}\n\n \nstatic bool path_has_mixer(struct hda_codec *codec, int path_idx, int ctl_type)\n{\n\tstruct nid_path *path = snd_hda_get_path_from_idx(codec, path_idx);\n\treturn path && path->ctls[ctl_type];\n}\n\nstatic const char * const channel_name[] = {\n\t\"Front\", \"Surround\", \"CLFE\", \"Side\", \"Back\",\n};\n\n \nstatic const char *get_line_out_pfx(struct hda_codec *codec, int ch,\n\t\t\t\t    int *index, int ctl_type)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\n\t*index = 0;\n\tif (cfg->line_outs == 1 && !spec->multi_ios &&\n\t    !codec->force_pin_prefix &&\n\t    !cfg->hp_outs && !cfg->speaker_outs)\n\t\treturn spec->vmaster_mute.hook ? \"PCM\" : \"Master\";\n\n\t \n\tif (spec->multiout.num_dacs == 1 && !spec->mixer_nid &&\n\t    !codec->force_pin_prefix &&\n\t    !spec->multiout.hp_out_nid[0] && !spec->multiout.extra_out_nid[0])\n\t\treturn spec->vmaster_mute.hook ? \"PCM\" : \"Master\";\n\n\t \n\tif (ch >= cfg->line_outs)\n\t\tgoto fixed_name;\n\n\tswitch (cfg->line_out_type) {\n\tcase AUTO_PIN_SPEAKER_OUT:\n\t\t \n\t\tif (!ch && cfg->hp_outs &&\n\t\t    !path_has_mixer(codec, spec->hp_paths[0], ctl_type))\n\t\t\tbreak;\n\t\tif (cfg->line_outs == 1)\n\t\t\treturn \"Speaker\";\n\t\tif (cfg->line_outs == 2)\n\t\t\treturn ch ? \"Bass Speaker\" : \"Speaker\";\n\t\tbreak;\n\tcase AUTO_PIN_HP_OUT:\n\t\t \n\t\tif (!ch && cfg->speaker_outs &&\n\t\t    !path_has_mixer(codec, spec->speaker_paths[0], ctl_type))\n\t\t\tbreak;\n\t\t \n\t\tif (ch && spec->multi_ios)\n\t\t\tbreak;\n\t\t*index = ch;\n\t\treturn \"Headphone\";\n\tcase AUTO_PIN_LINE_OUT:\n\t\t \n\t\tif (!ch) {\n\t\t\tbool hp_lo_shared = false, spk_lo_shared = false;\n\n\t\t\tif (cfg->speaker_outs)\n\t\t\t\tspk_lo_shared = !path_has_mixer(codec,\n\t\t\t\t\t\t\t\tspec->speaker_paths[0],\tctl_type);\n\t\t\tif (cfg->hp_outs)\n\t\t\t\thp_lo_shared = !path_has_mixer(codec, spec->hp_paths[0], ctl_type);\n\t\t\tif (hp_lo_shared && spk_lo_shared)\n\t\t\t\treturn spec->vmaster_mute.hook ? \"PCM\" : \"Master\";\n\t\t\tif (hp_lo_shared)\n\t\t\t\treturn \"Headphone+LO\";\n\t\t\tif (spk_lo_shared)\n\t\t\t\treturn \"Speaker+LO\";\n\t\t}\n\t}\n\n\t \n\tif (cfg->line_outs == 1 && !spec->multi_ios)\n\t\treturn \"Line Out\";\n\n fixed_name:\n\tif (ch >= ARRAY_SIZE(channel_name)) {\n\t\tsnd_BUG();\n\t\treturn \"PCM\";\n\t}\n\n\treturn channel_name[ch];\n}\n\n \n\n \nenum {\n\t \n\tBAD_NO_PRIMARY_DAC = 0x10000,\n\t \n\tBAD_NO_DAC = 0x4000,\n\t \n\tBAD_MULTI_IO = 0x120,\n\t \n\tBAD_NO_EXTRA_DAC = 0x102,\n\t \n\tBAD_NO_EXTRA_SURR_DAC = 0x101,\n\t \n\tBAD_SHARED_SURROUND = 0x100,\n\t \n\tBAD_NO_INDEP_HP = 0x10,\n\t \n\tBAD_SHARED_CLFE = 0x10,\n\t \n\tBAD_SHARED_EXTRA_SURROUND = 0x10,\n\t \n\tBAD_SHARED_VOL = 0x10,\n};\n\n \nstatic int assign_out_path_ctls(struct hda_codec *codec, struct nid_path *path)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t nid;\n\tunsigned int val;\n\tint badness = 0;\n\n\tif (!path)\n\t\treturn BAD_SHARED_VOL * 2;\n\n\tif (path->ctls[NID_PATH_VOL_CTL] ||\n\t    path->ctls[NID_PATH_MUTE_CTL])\n\t\treturn 0;  \n\n\tnid = look_for_out_vol_nid(codec, path);\n\tif (nid) {\n\t\tval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t\tif (spec->dac_min_mute)\n\t\t\tval |= HDA_AMP_VAL_MIN_MUTE;\n\t\tif (is_ctl_used(codec, val, NID_PATH_VOL_CTL))\n\t\t\tbadness += BAD_SHARED_VOL;\n\t\telse\n\t\t\tpath->ctls[NID_PATH_VOL_CTL] = val;\n\t} else\n\t\tbadness += BAD_SHARED_VOL;\n\tnid = look_for_out_mute_nid(codec, path);\n\tif (nid) {\n\t\tunsigned int wid_type = get_wcaps_type(get_wcaps(codec, nid));\n\t\tif (wid_type == AC_WID_PIN || wid_type == AC_WID_AUD_OUT ||\n\t\t    nid_has_mute(codec, nid, HDA_OUTPUT))\n\t\t\tval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t\telse\n\t\t\tval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_INPUT);\n\t\tif (is_ctl_used(codec, val, NID_PATH_MUTE_CTL))\n\t\t\tbadness += BAD_SHARED_VOL;\n\t\telse\n\t\t\tpath->ctls[NID_PATH_MUTE_CTL] = val;\n\t} else\n\t\tbadness += BAD_SHARED_VOL;\n\treturn badness;\n}\n\nconst struct badness_table hda_main_out_badness = {\n\t.no_primary_dac = BAD_NO_PRIMARY_DAC,\n\t.no_dac = BAD_NO_DAC,\n\t.shared_primary = BAD_NO_PRIMARY_DAC,\n\t.shared_surr = BAD_SHARED_SURROUND,\n\t.shared_clfe = BAD_SHARED_CLFE,\n\t.shared_surr_main = BAD_SHARED_SURROUND,\n};\nEXPORT_SYMBOL_GPL(hda_main_out_badness);\n\nconst struct badness_table hda_extra_out_badness = {\n\t.no_primary_dac = BAD_NO_DAC,\n\t.no_dac = BAD_NO_DAC,\n\t.shared_primary = BAD_NO_EXTRA_DAC,\n\t.shared_surr = BAD_SHARED_EXTRA_SURROUND,\n\t.shared_clfe = BAD_SHARED_EXTRA_SURROUND,\n\t.shared_surr_main = BAD_NO_EXTRA_SURR_DAC,\n};\nEXPORT_SYMBOL_GPL(hda_extra_out_badness);\n\n \nstatic hda_nid_t get_primary_out(struct hda_codec *codec, int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\n\tif (cfg->line_outs > idx)\n\t\treturn spec->private_dac_nids[idx];\n\tidx -= cfg->line_outs;\n\tif (spec->multi_ios > idx)\n\t\treturn spec->multi_io[idx].dac;\n\treturn 0;\n}\n\n \nstatic inline hda_nid_t try_dac(struct hda_codec *codec,\n\t\t\t\thda_nid_t dac, hda_nid_t pin)\n{\n\treturn is_reachable_path(codec, dac, pin) ? dac : 0;\n}\n\n \nstatic int try_assign_dacs(struct hda_codec *codec, int num_outs,\n\t\t\t   const hda_nid_t *pins, hda_nid_t *dacs,\n\t\t\t   int *path_idx,\n\t\t\t   const struct badness_table *bad)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i, j;\n\tint badness = 0;\n\thda_nid_t dac;\n\n\tif (!num_outs)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_outs; i++) {\n\t\tstruct nid_path *path;\n\t\thda_nid_t pin = pins[i];\n\n\t\tif (!spec->obey_preferred_dacs) {\n\t\t\tpath = snd_hda_get_path_from_idx(codec, path_idx[i]);\n\t\t\tif (path) {\n\t\t\t\tbadness += assign_out_path_ctls(codec, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tdacs[i] = get_preferred_dac(codec, pin);\n\t\tif (dacs[i]) {\n\t\t\tif (is_dac_already_used(codec, dacs[i]))\n\t\t\t\tbadness += bad->shared_primary;\n\t\t} else if (spec->obey_preferred_dacs) {\n\t\t\tbadness += BAD_NO_PRIMARY_DAC;\n\t\t}\n\n\t\tif (!dacs[i])\n\t\t\tdacs[i] = look_for_dac(codec, pin, false);\n\t\tif (!dacs[i] && !i) {\n\t\t\t \n\t\t\tfor (j = 1; j < num_outs; j++) {\n\t\t\t\tif (is_reachable_path(codec, dacs[j], pin)) {\n\t\t\t\t\tdacs[0] = dacs[j];\n\t\t\t\t\tdacs[j] = 0;\n\t\t\t\t\tinvalidate_nid_path(codec, path_idx[j]);\n\t\t\t\t\tpath_idx[j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdac = dacs[i];\n\t\tif (!dac) {\n\t\t\tif (num_outs > 2)\n\t\t\t\tdac = try_dac(codec, get_primary_out(codec, i), pin);\n\t\t\tif (!dac)\n\t\t\t\tdac = try_dac(codec, dacs[0], pin);\n\t\t\tif (!dac)\n\t\t\t\tdac = try_dac(codec, get_primary_out(codec, i), pin);\n\t\t\tif (dac) {\n\t\t\t\tif (!i)\n\t\t\t\t\tbadness += bad->shared_primary;\n\t\t\t\telse if (i == 1)\n\t\t\t\t\tbadness += bad->shared_surr;\n\t\t\t\telse\n\t\t\t\t\tbadness += bad->shared_clfe;\n\t\t\t} else if (is_reachable_path(codec, spec->private_dac_nids[0], pin)) {\n\t\t\t\tdac = spec->private_dac_nids[0];\n\t\t\t\tbadness += bad->shared_surr_main;\n\t\t\t} else if (!i)\n\t\t\t\tbadness += bad->no_primary_dac;\n\t\t\telse\n\t\t\t\tbadness += bad->no_dac;\n\t\t}\n\t\tif (!dac)\n\t\t\tcontinue;\n\t\tpath = snd_hda_add_new_path(codec, dac, pin, -spec->mixer_nid);\n\t\tif (!path && !i && spec->mixer_nid) {\n\t\t\t \n\t\t\tpath = snd_hda_add_new_path(codec, dac, pin, 0);\n\t\t}\n\t\tif (!path) {\n\t\t\tdacs[i] = 0;\n\t\t\tbadness += bad->no_dac;\n\t\t} else {\n\t\t\t \n\t\t\tpath->active = true;\n\t\t\tpath_idx[i] = snd_hda_get_path_idx(codec, path);\n\t\t\tbadness += assign_out_path_ctls(codec, path);\n\t\t}\n\t}\n\n\treturn badness;\n}\n\n \nstatic hda_nid_t get_dac_if_single(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\thda_nid_t nid_found = 0;\n\n\tfor (i = 0; i < spec->num_all_dacs; i++) {\n\t\thda_nid_t nid = spec->all_dacs[i];\n\t\tif (!nid || is_dac_already_used(codec, nid))\n\t\t\tcontinue;\n\t\tif (is_reachable_path(codec, nid, pin)) {\n\t\t\tif (nid_found)\n\t\t\t\treturn 0;\n\t\t\tnid_found = nid;\n\t\t}\n\t}\n\treturn nid_found;\n}\n\n \nstatic bool can_be_multiio_pin(struct hda_codec *codec,\n\t\t\t       unsigned int location, hda_nid_t nid)\n{\n\tunsigned int defcfg, caps;\n\n\tdefcfg = snd_hda_codec_get_pincfg(codec, nid);\n\tif (get_defcfg_connect(defcfg) != AC_JACK_PORT_COMPLEX)\n\t\treturn false;\n\tif (location && get_defcfg_location(defcfg) != location)\n\t\treturn false;\n\tcaps = snd_hda_query_pin_caps(codec, nid);\n\tif (!(caps & AC_PINCAP_OUT))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic int count_multiio_pins(struct hda_codec *codec, hda_nid_t reference_pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int defcfg = snd_hda_codec_get_pincfg(codec, reference_pin);\n\tunsigned int location = get_defcfg_location(defcfg);\n\tint type, i;\n\tint num_pins = 0;\n\n\tfor (type = AUTO_PIN_LINE_IN; type >= AUTO_PIN_MIC; type--) {\n\t\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\t\tif (cfg->inputs[i].type != type)\n\t\t\t\tcontinue;\n\t\t\tif (can_be_multiio_pin(codec, location,\n\t\t\t\t\t       cfg->inputs[i].pin))\n\t\t\t\tnum_pins++;\n\t\t}\n\t}\n\treturn num_pins;\n}\n\n \nstatic int fill_multi_ios(struct hda_codec *codec,\n\t\t\t  hda_nid_t reference_pin,\n\t\t\t  bool hardwired)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint type, i, j, num_pins, old_pins;\n\tunsigned int defcfg = snd_hda_codec_get_pincfg(codec, reference_pin);\n\tunsigned int location = get_defcfg_location(defcfg);\n\tint badness = 0;\n\tstruct nid_path *path;\n\n\told_pins = spec->multi_ios;\n\tif (old_pins >= 2)\n\t\tgoto end_fill;\n\n\tnum_pins = count_multiio_pins(codec, reference_pin);\n\tif (num_pins < 2)\n\t\tgoto end_fill;\n\n\tfor (type = AUTO_PIN_LINE_IN; type >= AUTO_PIN_MIC; type--) {\n\t\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\t\thda_nid_t nid = cfg->inputs[i].pin;\n\t\t\thda_nid_t dac = 0;\n\n\t\t\tif (cfg->inputs[i].type != type)\n\t\t\t\tcontinue;\n\t\t\tif (!can_be_multiio_pin(codec, location, nid))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < spec->multi_ios; j++) {\n\t\t\t\tif (nid == spec->multi_io[j].pin)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < spec->multi_ios)\n\t\t\t\tcontinue;\n\n\t\t\tif (hardwired)\n\t\t\t\tdac = get_dac_if_single(codec, nid);\n\t\t\telse if (!dac)\n\t\t\t\tdac = look_for_dac(codec, nid, false);\n\t\t\tif (!dac) {\n\t\t\t\tbadness++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath = snd_hda_add_new_path(codec, dac, nid,\n\t\t\t\t\t\t    -spec->mixer_nid);\n\t\t\tif (!path) {\n\t\t\t\tbadness++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tspec->multi_io[spec->multi_ios].pin = nid;\n\t\t\tspec->multi_io[spec->multi_ios].dac = dac;\n\t\t\tspec->out_paths[cfg->line_outs + spec->multi_ios] =\n\t\t\t\tsnd_hda_get_path_idx(codec, path);\n\t\t\tspec->multi_ios++;\n\t\t\tif (spec->multi_ios >= 2)\n\t\t\t\tbreak;\n\t\t}\n\t}\n end_fill:\n\tif (badness)\n\t\tbadness = BAD_MULTI_IO;\n\tif (old_pins == spec->multi_ios) {\n\t\tif (hardwired)\n\t\t\treturn 1;  \n\t\telse\n\t\t\treturn badness;  \n\t}\n\tif (!hardwired && spec->multi_ios < 2) {\n\t\t \n\t\tspec->paths.used -= spec->multi_ios - old_pins;\n\t\tspec->multi_ios = old_pins;\n\t\treturn badness;\n\t}\n\n\t \n\tfor (i = old_pins; i < spec->multi_ios; i++) {\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->out_paths[cfg->line_outs + i]);\n\t\tbadness += assign_out_path_ctls(codec, path);\n\t}\n\n\treturn badness;\n}\n\n \nstatic bool map_singles(struct hda_codec *codec, int outs,\n\t\t\tconst hda_nid_t *pins, hda_nid_t *dacs, int *path_idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\tbool found = false;\n\tfor (i = 0; i < outs; i++) {\n\t\tstruct nid_path *path;\n\t\thda_nid_t dac;\n\t\tif (dacs[i])\n\t\t\tcontinue;\n\t\tdac = get_dac_if_single(codec, pins[i]);\n\t\tif (!dac)\n\t\t\tcontinue;\n\t\tpath = snd_hda_add_new_path(codec, dac, pins[i],\n\t\t\t\t\t    -spec->mixer_nid);\n\t\tif (!path && !i && spec->mixer_nid)\n\t\t\tpath = snd_hda_add_new_path(codec, dac, pins[i], 0);\n\t\tif (path) {\n\t\t\tdacs[i] = dac;\n\t\t\tfound = true;\n\t\t\t \n\t\t\tpath->active = true;\n\t\t\tpath_idx[i] = snd_hda_get_path_idx(codec, path);\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic inline bool has_aamix_out_paths(struct hda_gen_spec *spec)\n{\n\treturn spec->aamix_out_paths[0] || spec->aamix_out_paths[1] ||\n\t\tspec->aamix_out_paths[2];\n}\n\n \nstatic int check_aamix_out_path(struct hda_codec *codec, int path_idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\thda_nid_t path_dac, dac, pin;\n\n\tpath = snd_hda_get_path_from_idx(codec, path_idx);\n\tif (!path || !path->depth ||\n\t    is_nid_contained(path, spec->mixer_nid))\n\t\treturn 0;\n\tpath_dac = path->path[0];\n\tdac = spec->private_dac_nids[0];\n\tpin = path->path[path->depth - 1];\n\tpath = snd_hda_add_new_path(codec, dac, pin, spec->mixer_nid);\n\tif (!path) {\n\t\tif (dac != path_dac)\n\t\t\tdac = path_dac;\n\t\telse if (spec->multiout.hp_out_nid[0])\n\t\t\tdac = spec->multiout.hp_out_nid[0];\n\t\telse if (spec->multiout.extra_out_nid[0])\n\t\t\tdac = spec->multiout.extra_out_nid[0];\n\t\telse\n\t\t\tdac = 0;\n\t\tif (dac)\n\t\t\tpath = snd_hda_add_new_path(codec, dac, pin,\n\t\t\t\t\t\t    spec->mixer_nid);\n\t}\n\tif (!path)\n\t\treturn 0;\n\t \n\tpath->active = false;  \n\tpath->pin_fixed = true;  \n\treturn snd_hda_get_path_idx(codec, path);\n}\n\n \nstatic bool indep_hp_possible(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tstruct nid_path *path;\n\tint i, idx;\n\n\tif (cfg->line_out_type == AUTO_PIN_HP_OUT)\n\t\tidx = spec->out_paths[0];\n\telse\n\t\tidx = spec->hp_paths[0];\n\tpath = snd_hda_get_path_from_idx(codec, idx);\n\tif (!path)\n\t\treturn false;\n\n\t \n\tif (!spec->mixer_nid || !is_nid_contained(path, spec->mixer_nid))\n\t\treturn true;\n\n\t \n\tfor (i = 0; i < cfg->line_outs; i++) {\n\t\tif (spec->out_paths[i] == idx)\n\t\t\tbreak;\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->out_paths[i]);\n\t\tif (path && is_nid_contained(path, spec->mixer_nid))\n\t\t\treturn false;\n\t}\n\tfor (i = 0; i < cfg->speaker_outs; i++) {\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->speaker_paths[i]);\n\t\tif (path && is_nid_contained(path, spec->mixer_nid))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void refill_shared_dacs(struct hda_codec *codec, int num_outs,\n\t\t\t       hda_nid_t *dacs, int *path_idx)\n{\n\tstruct nid_path *path;\n\tint i;\n\n\tfor (i = 0; i < num_outs; i++) {\n\t\tif (dacs[i])\n\t\t\tcontinue;\n\t\tpath = snd_hda_get_path_from_idx(codec, path_idx[i]);\n\t\tif (!path)\n\t\t\tcontinue;\n\t\tdacs[i] = path->path[0];\n\t}\n}\n\n \nstatic int fill_and_eval_dacs(struct hda_codec *codec,\n\t\t\t      bool fill_hardwired,\n\t\t\t      bool fill_mio_first)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i, err, badness;\n\n\t \n\tspec->multiout.num_dacs = cfg->line_outs;\n\tspec->multiout.dac_nids = spec->private_dac_nids;\n\tmemset(spec->private_dac_nids, 0, sizeof(spec->private_dac_nids));\n\tmemset(spec->multiout.hp_out_nid, 0, sizeof(spec->multiout.hp_out_nid));\n\tmemset(spec->multiout.extra_out_nid, 0, sizeof(spec->multiout.extra_out_nid));\n\tspec->multi_ios = 0;\n\tsnd_array_free(&spec->paths);\n\n\t \n\tmemset(spec->out_paths, 0, sizeof(spec->out_paths));\n\tmemset(spec->hp_paths, 0, sizeof(spec->hp_paths));\n\tmemset(spec->speaker_paths, 0, sizeof(spec->speaker_paths));\n\tmemset(spec->aamix_out_paths, 0, sizeof(spec->aamix_out_paths));\n\tmemset(spec->digout_paths, 0, sizeof(spec->digout_paths));\n\tmemset(spec->input_paths, 0, sizeof(spec->input_paths));\n\tmemset(spec->loopback_paths, 0, sizeof(spec->loopback_paths));\n\tmemset(&spec->digin_path, 0, sizeof(spec->digin_path));\n\n\tbadness = 0;\n\n\t \n\tif (fill_hardwired) {\n\t\tbool mapped;\n\t\tdo {\n\t\t\tmapped = map_singles(codec, cfg->line_outs,\n\t\t\t\t\t     cfg->line_out_pins,\n\t\t\t\t\t     spec->private_dac_nids,\n\t\t\t\t\t     spec->out_paths);\n\t\t\tmapped |= map_singles(codec, cfg->hp_outs,\n\t\t\t\t\t      cfg->hp_pins,\n\t\t\t\t\t      spec->multiout.hp_out_nid,\n\t\t\t\t\t      spec->hp_paths);\n\t\t\tmapped |= map_singles(codec, cfg->speaker_outs,\n\t\t\t\t\t      cfg->speaker_pins,\n\t\t\t\t\t      spec->multiout.extra_out_nid,\n\t\t\t\t\t      spec->speaker_paths);\n\t\t\tif (!spec->no_multi_io &&\n\t\t\t    fill_mio_first && cfg->line_outs == 1 &&\n\t\t\t    cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\t\t\terr = fill_multi_ios(codec, cfg->line_out_pins[0], true);\n\t\t\t\tif (!err)\n\t\t\t\t\tmapped = true;\n\t\t\t}\n\t\t} while (mapped);\n\t}\n\n\tbadness += try_assign_dacs(codec, cfg->line_outs, cfg->line_out_pins,\n\t\t\t\t   spec->private_dac_nids, spec->out_paths,\n\t\t\t\t   spec->main_out_badness);\n\n\tif (!spec->no_multi_io && fill_mio_first &&\n\t    cfg->line_outs == 1 && cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\t \n\t\terr = fill_multi_ios(codec, cfg->line_out_pins[0], false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t}\n\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\n\t\terr = try_assign_dacs(codec, cfg->hp_outs, cfg->hp_pins,\n\t\t\t\t      spec->multiout.hp_out_nid,\n\t\t\t\t      spec->hp_paths,\n\t\t\t\t      spec->extra_out_badness);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbadness += err;\n\t}\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\terr = try_assign_dacs(codec, cfg->speaker_outs,\n\t\t\t\t      cfg->speaker_pins,\n\t\t\t\t      spec->multiout.extra_out_nid,\n\t\t\t\t      spec->speaker_paths,\n\t\t\t\t      spec->extra_out_badness);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbadness += err;\n\t}\n\tif (!spec->no_multi_io &&\n\t    cfg->line_outs == 1 && cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\terr = fill_multi_ios(codec, cfg->line_out_pins[0], false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbadness += err;\n\t}\n\n\tif (spec->mixer_nid) {\n\t\tspec->aamix_out_paths[0] =\n\t\t\tcheck_aamix_out_path(codec, spec->out_paths[0]);\n\t\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\t\tspec->aamix_out_paths[1] =\n\t\t\t\tcheck_aamix_out_path(codec, spec->hp_paths[0]);\n\t\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\t\tspec->aamix_out_paths[2] =\n\t\t\t\tcheck_aamix_out_path(codec, spec->speaker_paths[0]);\n\t}\n\n\tif (!spec->no_multi_io &&\n\t    cfg->hp_outs && cfg->line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\tif (count_multiio_pins(codec, cfg->hp_pins[0]) >= 2)\n\t\t\tspec->multi_ios = 1;  \n\n\t \n\tspec->multiout.num_dacs = 0;\n\tfor (i = 0; i < cfg->line_outs; i++) {\n\t\tif (spec->private_dac_nids[i])\n\t\t\tspec->multiout.num_dacs++;\n\t\telse {\n\t\t\tmemmove(spec->private_dac_nids + i,\n\t\t\t\tspec->private_dac_nids + i + 1,\n\t\t\t\tsizeof(hda_nid_t) * (cfg->line_outs - i - 1));\n\t\t\tspec->private_dac_nids[cfg->line_outs - 1] = 0;\n\t\t}\n\t}\n\n\tspec->ext_channel_count = spec->min_channel_count =\n\t\tspec->multiout.num_dacs * 2;\n\n\tif (spec->multi_ios == 2) {\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tspec->private_dac_nids[spec->multiout.num_dacs++] =\n\t\t\t\tspec->multi_io[i].dac;\n\t} else if (spec->multi_ios) {\n\t\tspec->multi_ios = 0;\n\t\tbadness += BAD_MULTI_IO;\n\t}\n\n\tif (spec->indep_hp && !indep_hp_possible(codec))\n\t\tbadness += BAD_NO_INDEP_HP;\n\n\t \n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\trefill_shared_dacs(codec, cfg->hp_outs,\n\t\t\t\t   spec->multiout.hp_out_nid,\n\t\t\t\t   spec->hp_paths);\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\trefill_shared_dacs(codec, cfg->speaker_outs,\n\t\t\t\t   spec->multiout.extra_out_nid,\n\t\t\t\t   spec->speaker_paths);\n\n\treturn badness;\n}\n\n#define DEBUG_BADNESS\n\n#ifdef DEBUG_BADNESS\n#define debug_badness(fmt, ...)\t\t\t\t\t\t\\\n\tcodec_dbg(codec, fmt, ##__VA_ARGS__)\n#else\n#define debug_badness(fmt, ...)\t\t\t\t\t\t\\\n\tdo { if (0) codec_dbg(codec, fmt, ##__VA_ARGS__); } while (0)\n#endif\n\n#ifdef DEBUG_BADNESS\nstatic inline void print_nid_path_idx(struct hda_codec *codec,\n\t\t\t\t      const char *pfx, int idx)\n{\n\tstruct nid_path *path;\n\n\tpath = snd_hda_get_path_from_idx(codec, idx);\n\tif (path)\n\t\tprint_nid_path(codec, pfx, path);\n}\n\nstatic void debug_show_configs(struct hda_codec *codec,\n\t\t\t       struct auto_pin_cfg *cfg)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstatic const char * const lo_type[3] = { \"LO\", \"SP\", \"HP\" };\n\tint i;\n\n\tdebug_badness(\"multi_outs = %x/%x/%x/%x : %x/%x/%x/%x (type %s)\\n\",\n\t\t      cfg->line_out_pins[0], cfg->line_out_pins[1],\n\t\t      cfg->line_out_pins[2], cfg->line_out_pins[3],\n\t\t      spec->multiout.dac_nids[0],\n\t\t      spec->multiout.dac_nids[1],\n\t\t      spec->multiout.dac_nids[2],\n\t\t      spec->multiout.dac_nids[3],\n\t\t      lo_type[cfg->line_out_type]);\n\tfor (i = 0; i < cfg->line_outs; i++)\n\t\tprint_nid_path_idx(codec, \"  out\", spec->out_paths[i]);\n\tif (spec->multi_ios > 0)\n\t\tdebug_badness(\"multi_ios(%d) = %x/%x : %x/%x\\n\",\n\t\t\t      spec->multi_ios,\n\t\t\t      spec->multi_io[0].pin, spec->multi_io[1].pin,\n\t\t\t      spec->multi_io[0].dac, spec->multi_io[1].dac);\n\tfor (i = 0; i < spec->multi_ios; i++)\n\t\tprint_nid_path_idx(codec, \"  mio\",\n\t\t\t\t   spec->out_paths[cfg->line_outs + i]);\n\tif (cfg->hp_outs)\n\t\tdebug_badness(\"hp_outs = %x/%x/%x/%x : %x/%x/%x/%x\\n\",\n\t\t      cfg->hp_pins[0], cfg->hp_pins[1],\n\t\t      cfg->hp_pins[2], cfg->hp_pins[3],\n\t\t      spec->multiout.hp_out_nid[0],\n\t\t      spec->multiout.hp_out_nid[1],\n\t\t      spec->multiout.hp_out_nid[2],\n\t\t      spec->multiout.hp_out_nid[3]);\n\tfor (i = 0; i < cfg->hp_outs; i++)\n\t\tprint_nid_path_idx(codec, \"  hp \", spec->hp_paths[i]);\n\tif (cfg->speaker_outs)\n\t\tdebug_badness(\"spk_outs = %x/%x/%x/%x : %x/%x/%x/%x\\n\",\n\t\t      cfg->speaker_pins[0], cfg->speaker_pins[1],\n\t\t      cfg->speaker_pins[2], cfg->speaker_pins[3],\n\t\t      spec->multiout.extra_out_nid[0],\n\t\t      spec->multiout.extra_out_nid[1],\n\t\t      spec->multiout.extra_out_nid[2],\n\t\t      spec->multiout.extra_out_nid[3]);\n\tfor (i = 0; i < cfg->speaker_outs; i++)\n\t\tprint_nid_path_idx(codec, \"  spk\", spec->speaker_paths[i]);\n\tfor (i = 0; i < 3; i++)\n\t\tprint_nid_path_idx(codec, \"  mix\", spec->aamix_out_paths[i]);\n}\n#else\n#define debug_show_configs(codec, cfg)  \n#endif\n\n \nstatic void fill_all_dac_nids(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t nid;\n\n\tspec->num_all_dacs = 0;\n\tmemset(spec->all_dacs, 0, sizeof(spec->all_dacs));\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_AUD_OUT)\n\t\t\tcontinue;\n\t\tif (spec->num_all_dacs >= ARRAY_SIZE(spec->all_dacs)) {\n\t\t\tcodec_err(codec, \"Too many DACs!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tspec->all_dacs[spec->num_all_dacs++] = nid;\n\t}\n}\n\nstatic int parse_output_paths(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tstruct auto_pin_cfg *best_cfg;\n\tunsigned int val;\n\tint best_badness = INT_MAX;\n\tint badness;\n\tbool fill_hardwired = true, fill_mio_first = true;\n\tbool best_wired = true, best_mio = true;\n\tbool hp_spk_swapped = false;\n\n\tbest_cfg = kmalloc(sizeof(*best_cfg), GFP_KERNEL);\n\tif (!best_cfg)\n\t\treturn -ENOMEM;\n\t*best_cfg = *cfg;\n\n\tfor (;;) {\n\t\tbadness = fill_and_eval_dacs(codec, fill_hardwired,\n\t\t\t\t\t     fill_mio_first);\n\t\tif (badness < 0) {\n\t\t\tkfree(best_cfg);\n\t\t\treturn badness;\n\t\t}\n\t\tdebug_badness(\"==> lo_type=%d, wired=%d, mio=%d, badness=0x%x\\n\",\n\t\t\t      cfg->line_out_type, fill_hardwired, fill_mio_first,\n\t\t\t      badness);\n\t\tdebug_show_configs(codec, cfg);\n\t\tif (badness < best_badness) {\n\t\t\tbest_badness = badness;\n\t\t\t*best_cfg = *cfg;\n\t\t\tbest_wired = fill_hardwired;\n\t\t\tbest_mio = fill_mio_first;\n\t\t}\n\t\tif (!badness)\n\t\t\tbreak;\n\t\tfill_mio_first = !fill_mio_first;\n\t\tif (!fill_mio_first)\n\t\t\tcontinue;\n\t\tfill_hardwired = !fill_hardwired;\n\t\tif (!fill_hardwired)\n\t\t\tcontinue;\n\t\tif (hp_spk_swapped)\n\t\t\tbreak;\n\t\thp_spk_swapped = true;\n\t\tif (cfg->speaker_outs > 0 &&\n\t\t    cfg->line_out_type == AUTO_PIN_HP_OUT) {\n\t\t\tcfg->hp_outs = cfg->line_outs;\n\t\t\tmemcpy(cfg->hp_pins, cfg->line_out_pins,\n\t\t\t       sizeof(cfg->hp_pins));\n\t\t\tcfg->line_outs = cfg->speaker_outs;\n\t\t\tmemcpy(cfg->line_out_pins, cfg->speaker_pins,\n\t\t\t       sizeof(cfg->speaker_pins));\n\t\t\tcfg->speaker_outs = 0;\n\t\t\tmemset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));\n\t\t\tcfg->line_out_type = AUTO_PIN_SPEAKER_OUT;\n\t\t\tfill_hardwired = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cfg->hp_outs > 0 &&\n\t\t    cfg->line_out_type == AUTO_PIN_SPEAKER_OUT) {\n\t\t\tcfg->speaker_outs = cfg->line_outs;\n\t\t\tmemcpy(cfg->speaker_pins, cfg->line_out_pins,\n\t\t\t       sizeof(cfg->speaker_pins));\n\t\t\tcfg->line_outs = cfg->hp_outs;\n\t\t\tmemcpy(cfg->line_out_pins, cfg->hp_pins,\n\t\t\t       sizeof(cfg->hp_pins));\n\t\t\tcfg->hp_outs = 0;\n\t\t\tmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\n\t\t\tcfg->line_out_type = AUTO_PIN_HP_OUT;\n\t\t\tfill_hardwired = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (badness) {\n\t\tdebug_badness(\"==> restoring best_cfg\\n\");\n\t\t*cfg = *best_cfg;\n\t\tfill_and_eval_dacs(codec, best_wired, best_mio);\n\t}\n\tdebug_badness(\"==> Best config: lo_type=%d, wired=%d, mio=%d\\n\",\n\t\t      cfg->line_out_type, best_wired, best_mio);\n\tdebug_show_configs(codec, cfg);\n\n\tif (cfg->line_out_pins[0]) {\n\t\tstruct nid_path *path;\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->out_paths[0]);\n\t\tif (path)\n\t\t\tspec->vmaster_nid = look_for_out_vol_nid(codec, path);\n\t\tif (spec->vmaster_nid) {\n\t\t\tsnd_hda_set_vmaster_tlv(codec, spec->vmaster_nid,\n\t\t\t\t\t\tHDA_OUTPUT, spec->vmaster_tlv);\n\t\t\tif (spec->dac_min_mute)\n\t\t\t\tspec->vmaster_tlv[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP] |= TLV_DB_SCALE_MUTE;\n\t\t}\n\t}\n\n\t \n\tif (spec->prefer_hp_amp || cfg->line_out_type == AUTO_PIN_HP_OUT)\n\t\tval = PIN_HP;\n\telse\n\t\tval = PIN_OUT;\n\tset_pin_targets(codec, cfg->line_outs, cfg->line_out_pins, val);\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\tset_pin_targets(codec, cfg->hp_outs, cfg->hp_pins, PIN_HP);\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\tval = spec->prefer_hp_amp ? PIN_HP : PIN_OUT;\n\t\tset_pin_targets(codec, cfg->speaker_outs,\n\t\t\t\tcfg->speaker_pins, val);\n\t}\n\n\t \n\tif (spec->indep_hp && !indep_hp_possible(codec))\n\t\tspec->indep_hp = 0;\n\n\tkfree(best_cfg);\n\treturn 0;\n}\n\n \nstatic int create_multi_out_ctls(struct hda_codec *codec,\n\t\t\t\t const struct auto_pin_cfg *cfg)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i, err, noutputs;\n\n\tnoutputs = cfg->line_outs;\n\tif (spec->multi_ios > 0 && cfg->line_outs < 3)\n\t\tnoutputs += spec->multi_ios;\n\n\tfor (i = 0; i < noutputs; i++) {\n\t\tconst char *name;\n\t\tint index;\n\t\tstruct nid_path *path;\n\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->out_paths[i]);\n\t\tif (!path)\n\t\t\tcontinue;\n\n\t\tname = get_line_out_pfx(codec, i, &index, NID_PATH_VOL_CTL);\n\t\tif (!name || !strcmp(name, \"CLFE\")) {\n\t\t\t \n\t\t\terr = add_vol_ctl(codec, \"Center\", 0, 1, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = add_vol_ctl(codec, \"LFE\", 0, 2, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = add_stereo_vol(codec, name, index, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tname = get_line_out_pfx(codec, i, &index, NID_PATH_MUTE_CTL);\n\t\tif (!name || !strcmp(name, \"CLFE\")) {\n\t\t\terr = add_sw_ctl(codec, \"Center\", 0, 1, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = add_sw_ctl(codec, \"LFE\", 0, 2, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = add_stereo_sw(codec, name, index, path);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int create_extra_out(struct hda_codec *codec, int path_idx,\n\t\t\t    const char *pfx, int cidx)\n{\n\tstruct nid_path *path;\n\tint err;\n\n\tpath = snd_hda_get_path_from_idx(codec, path_idx);\n\tif (!path)\n\t\treturn 0;\n\terr = add_stereo_vol(codec, pfx, cidx, path);\n\tif (err < 0)\n\t\treturn err;\n\terr = add_stereo_sw(codec, pfx, cidx, path);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n \nstatic int create_extra_outs(struct hda_codec *codec, int num_pins,\n\t\t\t     const int *paths, const char *pfx)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tconst char *name;\n\t\tchar tmp[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\t\tint err, idx = 0;\n\n\t\tif (num_pins == 2 && i == 1 && !strcmp(pfx, \"Speaker\"))\n\t\t\tname = \"Bass Speaker\";\n\t\telse if (num_pins >= 3) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%s %s\",\n\t\t\t\t pfx, channel_name[i]);\n\t\t\tname = tmp;\n\t\t} else {\n\t\t\tname = pfx;\n\t\t\tidx = i;\n\t\t}\n\t\terr = create_extra_out(codec, paths[i], name, idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int create_hp_out_ctls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn create_extra_outs(codec, spec->autocfg.hp_outs,\n\t\t\t\t spec->hp_paths,\n\t\t\t\t \"Headphone\");\n}\n\nstatic int create_speaker_out_ctls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn create_extra_outs(codec, spec->autocfg.speaker_outs,\n\t\t\t\t spec->speaker_paths,\n\t\t\t\t \"Speaker\");\n}\n\n \n\nstatic void call_hp_automute(struct hda_codec *codec,\n\t\t\t     struct hda_jack_callback *jack);\nstatic int indep_hp_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\n}\n\nstatic int indep_hp_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tucontrol->value.enumerated.item[0] = spec->indep_hp_enabled;\n\treturn 0;\n}\n\nstatic void update_aamix_paths(struct hda_codec *codec, bool do_mix,\n\t\t\t       int nomix_path_idx, int mix_path_idx,\n\t\t\t       int out_type);\n\nstatic int indep_hp_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tunsigned int select = ucontrol->value.enumerated.item[0];\n\tint ret = 0;\n\n\tmutex_lock(&spec->pcm_mutex);\n\tif (spec->active_streams) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (spec->indep_hp_enabled != select) {\n\t\thda_nid_t *dacp;\n\t\tif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\n\t\t\tdacp = &spec->private_dac_nids[0];\n\t\telse\n\t\t\tdacp = &spec->multiout.hp_out_nid[0];\n\n\t\t \n\t\tif (spec->have_aamix_ctl) {\n\t\t\tif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\n\t\t\t\tupdate_aamix_paths(codec, spec->aamix_mode,\n\t\t\t\t\t\t   spec->out_paths[0],\n\t\t\t\t\t\t   spec->aamix_out_paths[0],\n\t\t\t\t\t\t   spec->autocfg.line_out_type);\n\t\t\telse\n\t\t\t\tupdate_aamix_paths(codec, spec->aamix_mode,\n\t\t\t\t\t\t   spec->hp_paths[0],\n\t\t\t\t\t\t   spec->aamix_out_paths[1],\n\t\t\t\t\t\t   AUTO_PIN_HP_OUT);\n\t\t}\n\n\t\tspec->indep_hp_enabled = select;\n\t\tif (spec->indep_hp_enabled)\n\t\t\t*dacp = 0;\n\t\telse\n\t\t\t*dacp = spec->alt_dac_nid;\n\n\t\tcall_hp_automute(codec, NULL);\n\t\tret = 1;\n\t}\n unlock:\n\tmutex_unlock(&spec->pcm_mutex);\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new indep_hp_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Independent HP\",\n\t.info = indep_hp_info,\n\t.get = indep_hp_get,\n\t.put = indep_hp_put,\n};\n\n\nstatic int create_indep_hp_ctls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t dac;\n\n\tif (!spec->indep_hp)\n\t\treturn 0;\n\tif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\n\t\tdac = spec->multiout.dac_nids[0];\n\telse\n\t\tdac = spec->multiout.hp_out_nid[0];\n\tif (!dac) {\n\t\tspec->indep_hp = 0;\n\t\treturn 0;\n\t}\n\n\tspec->indep_hp_enabled = false;\n\tspec->alt_dac_nid = dac;\n\tif (!snd_hda_gen_add_kctl(spec, NULL, &indep_hp_ctl))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \n\nstatic int ch_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint chs;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = spec->multi_ios + 1;\n\tif (uinfo->value.enumerated.item > spec->multi_ios)\n\t\tuinfo->value.enumerated.item = spec->multi_ios;\n\tchs = uinfo->value.enumerated.item * 2 + spec->min_channel_count;\n\tsprintf(uinfo->value.enumerated.name, \"%dch\", chs);\n\treturn 0;\n}\n\nstatic int ch_mode_get(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tucontrol->value.enumerated.item[0] =\n\t\t(spec->ext_channel_count - spec->min_channel_count) / 2;\n\treturn 0;\n}\n\nstatic inline struct nid_path *\nget_multiio_path(struct hda_codec *codec, int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_get_path_from_idx(codec,\n\t\tspec->out_paths[spec->autocfg.line_outs + idx]);\n}\n\nstatic void update_automute_all(struct hda_codec *codec);\n\n \nstatic bool aamix_default(struct hda_gen_spec *spec)\n{\n\treturn !spec->have_aamix_ctl || spec->aamix_mode;\n}\n\nstatic int set_multi_io(struct hda_codec *codec, int idx, bool output)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t nid = spec->multi_io[idx].pin;\n\tstruct nid_path *path;\n\n\tpath = get_multiio_path(codec, idx);\n\tif (!path)\n\t\treturn -EINVAL;\n\n\tif (path->active == output)\n\t\treturn 0;\n\n\tif (output) {\n\t\tset_pin_target(codec, nid, PIN_OUT, true);\n\t\tsnd_hda_activate_path(codec, path, true, aamix_default(spec));\n\t\tset_pin_eapd(codec, nid, true);\n\t} else {\n\t\tset_pin_eapd(codec, nid, false);\n\t\tsnd_hda_activate_path(codec, path, false, aamix_default(spec));\n\t\tset_pin_target(codec, nid, spec->multi_io[idx].ctl_in, true);\n\t\tpath_power_down_sync(codec, path);\n\t}\n\n\t \n\tupdate_automute_all(codec);\n\n\treturn 0;\n}\n\nstatic int ch_mode_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i, ch;\n\n\tch = ucontrol->value.enumerated.item[0];\n\tif (ch < 0 || ch > spec->multi_ios)\n\t\treturn -EINVAL;\n\tif (ch == (spec->ext_channel_count - spec->min_channel_count) / 2)\n\t\treturn 0;\n\tspec->ext_channel_count = ch * 2 + spec->min_channel_count;\n\tfor (i = 0; i < spec->multi_ios; i++)\n\t\tset_multi_io(codec, i, i < ch);\n\tspec->multiout.max_channels = max(spec->ext_channel_count,\n\t\t\t\t\t  spec->const_channel_count);\n\tif (spec->need_dac_fix)\n\t\tspec->multiout.num_dacs = spec->multiout.max_channels / 2;\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new channel_mode_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Channel Mode\",\n\t.info = ch_mode_info,\n\t.get = ch_mode_get,\n\t.put = ch_mode_put,\n};\n\nstatic int create_multi_channel_mode(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (spec->multi_ios > 0) {\n\t\tif (!snd_hda_gen_add_kctl(spec, NULL, &channel_mode_enum))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \n\n#define loopback_mixing_info\tindep_hp_info\n\nstatic int loopback_mixing_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tucontrol->value.enumerated.item[0] = spec->aamix_mode;\n\treturn 0;\n}\n\nstatic void update_aamix_paths(struct hda_codec *codec, bool do_mix,\n\t\t\t       int nomix_path_idx, int mix_path_idx,\n\t\t\t       int out_type)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *nomix_path, *mix_path;\n\n\tnomix_path = snd_hda_get_path_from_idx(codec, nomix_path_idx);\n\tmix_path = snd_hda_get_path_from_idx(codec, mix_path_idx);\n\tif (!nomix_path || !mix_path)\n\t\treturn;\n\n\t \n\tif (out_type == AUTO_PIN_HP_OUT && spec->indep_hp_enabled &&\n\t    mix_path->path[0] != spec->alt_dac_nid)\n\t\tdo_mix = false;\n\n\tif (do_mix) {\n\t\tsnd_hda_activate_path(codec, nomix_path, false, true);\n\t\tsnd_hda_activate_path(codec, mix_path, true, true);\n\t\tpath_power_down_sync(codec, nomix_path);\n\t} else {\n\t\tsnd_hda_activate_path(codec, mix_path, false, false);\n\t\tsnd_hda_activate_path(codec, nomix_path, true, false);\n\t\tpath_power_down_sync(codec, mix_path);\n\t}\n}\n\n \nstatic void update_output_paths(struct hda_codec *codec, int num_outs,\n\t\t\t\tconst int *paths)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\tint i;\n\n\tfor (i = 0; i < num_outs; i++) {\n\t\tpath = snd_hda_get_path_from_idx(codec, paths[i]);\n\t\tif (path)\n\t\t\tsnd_hda_activate_path(codec, path, path->active,\n\t\t\t\t\t      spec->aamix_mode);\n\t}\n}\n\nstatic int loopback_mixing_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\n\tif (val == spec->aamix_mode)\n\t\treturn 0;\n\tspec->aamix_mode = val;\n\tif (has_aamix_out_paths(spec)) {\n\t\tupdate_aamix_paths(codec, val, spec->out_paths[0],\n\t\t\t\t   spec->aamix_out_paths[0],\n\t\t\t\t   cfg->line_out_type);\n\t\tupdate_aamix_paths(codec, val, spec->hp_paths[0],\n\t\t\t\t   spec->aamix_out_paths[1],\n\t\t\t\t   AUTO_PIN_HP_OUT);\n\t\tupdate_aamix_paths(codec, val, spec->speaker_paths[0],\n\t\t\t\t   spec->aamix_out_paths[2],\n\t\t\t\t   AUTO_PIN_SPEAKER_OUT);\n\t} else {\n\t\tupdate_output_paths(codec, cfg->line_outs, spec->out_paths);\n\t\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\t\tupdate_output_paths(codec, cfg->hp_outs, spec->hp_paths);\n\t\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\t\tupdate_output_paths(codec, cfg->speaker_outs,\n\t\t\t\t\t    spec->speaker_paths);\n\t}\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new loopback_mixing_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Loopback Mixing\",\n\t.info = loopback_mixing_info,\n\t.get = loopback_mixing_get,\n\t.put = loopback_mixing_put,\n};\n\nstatic int create_loopback_mixing_ctl(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (!spec->mixer_nid)\n\t\treturn 0;\n\tif (!snd_hda_gen_add_kctl(spec, NULL, &loopback_mixing_enum))\n\t\treturn -ENOMEM;\n\tspec->have_aamix_ctl = 1;\n\treturn 0;\n}\n\n \n\nstatic void call_update_outputs(struct hda_codec *codec);\n\n \nstatic void update_hp_mic(struct hda_codec *codec, int adc_mux, bool force)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tbool as_mic;\n\tunsigned int val;\n\thda_nid_t pin;\n\n\tpin = spec->hp_mic_pin;\n\tas_mic = spec->cur_mux[adc_mux] == spec->hp_mic_mux_idx;\n\n\tif (!force) {\n\t\tval = snd_hda_codec_get_pin_target(codec, pin);\n\t\tif (as_mic) {\n\t\t\tif (val & PIN_IN)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (val & PIN_OUT)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tval = snd_hda_get_default_vref(codec, pin);\n\t \n\tif (val == AC_PINCTL_VREF_HIZ && spec->shared_mic_vref_pin) {\n\t\tconst hda_nid_t vref_pin = spec->shared_mic_vref_pin;\n\t\tunsigned int vref_val = snd_hda_get_default_vref(codec, vref_pin);\n\t\tif (vref_val != AC_PINCTL_VREF_HIZ)\n\t\t\tsnd_hda_set_pin_ctl_cache(codec, vref_pin,\n\t\t\t\t\t\t  PIN_IN | (as_mic ? vref_val : 0));\n\t}\n\n\tif (!spec->hp_mic_jack_modes) {\n\t\tif (as_mic)\n\t\t\tval |= PIN_IN;\n\t\telse\n\t\t\tval = PIN_HP;\n\t\tset_pin_target(codec, pin, val, true);\n\t\tcall_hp_automute(codec, NULL);\n\t}\n}\n\n \nstatic int create_hp_mic(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int defcfg;\n\thda_nid_t nid;\n\n\tif (!spec->hp_mic) {\n\t\tif (spec->suppress_hp_mic_detect)\n\t\t\treturn 0;\n\t\t \n\t\tif (cfg->num_inputs > 1)\n\t\t\treturn 0;\n\t\telse if (cfg->num_inputs == 1) {\n\t\t\tdefcfg = snd_hda_codec_get_pincfg(codec, cfg->inputs[0].pin);\n\t\t\tif (snd_hda_get_input_pin_attr(defcfg) != INPUT_PIN_ATTR_INT)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspec->hp_mic = 0;  \n\tif (cfg->num_inputs >= AUTO_CFG_MAX_INS)\n\t\treturn 0;\n\n\tnid = 0;\n\tif (cfg->line_out_type == AUTO_PIN_HP_OUT && cfg->line_outs > 0)\n\t\tnid = cfg->line_out_pins[0];\n\telse if (cfg->hp_outs > 0)\n\t\tnid = cfg->hp_pins[0];\n\tif (!nid)\n\t\treturn 0;\n\n\tif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_IN))\n\t\treturn 0;  \n\n\tcfg->inputs[cfg->num_inputs].pin = nid;\n\tcfg->inputs[cfg->num_inputs].type = AUTO_PIN_MIC;\n\tcfg->inputs[cfg->num_inputs].is_headphone_mic = 1;\n\tcfg->num_inputs++;\n\tspec->hp_mic = 1;\n\tspec->hp_mic_pin = nid;\n\t \n\tspec->suppress_auto_mic = 1;\n\tcodec_dbg(codec, \"Enable shared I/O jack on NID 0x%x\\n\", nid);\n\treturn 0;\n}\n\n \n\nstatic int create_hp_mic_jack_mode(struct hda_codec *codec, hda_nid_t pin);\n\nstatic const char * const out_jack_texts[] = {\n\t\"Line Out\", \"Headphone Out\",\n};\n\nstatic int out_jack_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_hda_enum_helper_info(kcontrol, uinfo, 2, out_jack_texts);\n}\n\nstatic int out_jack_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tif (snd_hda_codec_get_pin_target(codec, nid) == PIN_HP)\n\t\tucontrol->value.enumerated.item[0] = 1;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\treturn 0;\n}\n\nstatic int out_jack_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int val;\n\n\tval = ucontrol->value.enumerated.item[0] ? PIN_HP : PIN_OUT;\n\tif (snd_hda_codec_get_pin_target(codec, nid) == val)\n\t\treturn 0;\n\tsnd_hda_set_pin_ctl_cache(codec, nid, val);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new out_jack_mode_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = out_jack_mode_info,\n\t.get = out_jack_mode_get,\n\t.put = out_jack_mode_put,\n};\n\nstatic bool find_kctl_name(struct hda_codec *codec, const char *name, int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct snd_kcontrol_new *kctl;\n\tint i;\n\n\tsnd_array_for_each(&spec->kctls, i, kctl) {\n\t\tif (!strcmp(kctl->name, name) && kctl->index == idx)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void get_jack_mode_name(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t       char *name, size_t name_len)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint idx = 0;\n\n\tsnd_hda_get_pin_label(codec, pin, &spec->autocfg, name, name_len, &idx);\n\tstrlcat(name, \" Jack Mode\", name_len);\n\n\tfor (; find_kctl_name(codec, name, idx); idx++)\n\t\t;\n}\n\nstatic int get_out_jack_num_items(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->add_jack_modes) {\n\t\tunsigned int pincap = snd_hda_query_pin_caps(codec, pin);\n\t\tif ((pincap & AC_PINCAP_OUT) && (pincap & AC_PINCAP_HP_DRV))\n\t\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nstatic int create_out_jack_modes(struct hda_codec *codec, int num_pins,\n\t\t\t\t hda_nid_t *pins)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\thda_nid_t pin = pins[i];\n\t\tif (pin == spec->hp_mic_pin)\n\t\t\tcontinue;\n\t\tif (get_out_jack_num_items(codec, pin) > 1) {\n\t\t\tstruct snd_kcontrol_new *knew;\n\t\t\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\t\t\tget_jack_mode_name(codec, pin, name, sizeof(name));\n\t\t\tknew = snd_hda_gen_add_kctl(spec, name,\n\t\t\t\t\t\t    &out_jack_mode_enum);\n\t\t\tif (!knew)\n\t\t\t\treturn -ENOMEM;\n\t\t\tknew->private_value = pin;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\n \n#define NUM_VREFS\t6\n\nstatic const char * const vref_texts[NUM_VREFS] = {\n\t\"Line In\", \"Mic 50pc Bias\", \"Mic 0V Bias\",\n\t\"\", \"Mic 80pc Bias\", \"Mic 100pc Bias\"\n};\n\nstatic unsigned int get_vref_caps(struct hda_codec *codec, hda_nid_t pin)\n{\n\tunsigned int pincap;\n\n\tpincap = snd_hda_query_pin_caps(codec, pin);\n\tpincap = (pincap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\n\t \n\tpincap &= ~(AC_PINCAP_VREF_GRD | AC_PINCAP_VREF_100);\n\treturn pincap;\n}\n\n \nstatic int get_vref_idx(unsigned int vref_caps, unsigned int item_idx)\n{\n\tunsigned int i, n = 0;\n\n\tfor (i = 0; i < NUM_VREFS; i++) {\n\t\tif (vref_caps & (1 << i)) {\n\t\t\tif (n == item_idx)\n\t\t\t\treturn i;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int cvt_from_vref_idx(unsigned int vref_caps, unsigned int idx)\n{\n\tunsigned int i, n = 0;\n\n\tfor (i = 0; i < NUM_VREFS; i++) {\n\t\tif (i == idx)\n\t\t\treturn n;\n\t\tif (vref_caps & (1 << i))\n\t\t\tn++;\n\t}\n\treturn 0;\n}\n\nstatic int in_jack_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\n\tsnd_hda_enum_helper_info(kcontrol, uinfo, hweight32(vref_caps),\n\t\t\t\t vref_texts);\n\t \n\tstrcpy(uinfo->value.enumerated.name,\n\t       vref_texts[get_vref_idx(vref_caps, uinfo->value.enumerated.item)]);\n\treturn 0;\n}\n\nstatic int in_jack_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\tunsigned int idx;\n\n\tidx = snd_hda_codec_get_pin_target(codec, nid) & AC_PINCTL_VREFEN;\n\tucontrol->value.enumerated.item[0] = cvt_from_vref_idx(vref_caps, idx);\n\treturn 0;\n}\n\nstatic int in_jack_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\tunsigned int val, idx;\n\n\tval = snd_hda_codec_get_pin_target(codec, nid);\n\tidx = cvt_from_vref_idx(vref_caps, val & AC_PINCTL_VREFEN);\n\tif (idx == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tval &= ~AC_PINCTL_VREFEN;\n\tval |= get_vref_idx(vref_caps, ucontrol->value.enumerated.item[0]);\n\tsnd_hda_set_pin_ctl_cache(codec, nid, val);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new in_jack_mode_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = in_jack_mode_info,\n\t.get = in_jack_mode_get,\n\t.put = in_jack_mode_put,\n};\n\nstatic int get_in_jack_num_items(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint nitems = 0;\n\tif (spec->add_jack_modes)\n\t\tnitems = hweight32(get_vref_caps(codec, pin));\n\treturn nitems ? nitems : 1;\n}\n\nstatic int create_in_jack_mode(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct snd_kcontrol_new *knew;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tunsigned int defcfg;\n\n\tif (pin == spec->hp_mic_pin)\n\t\treturn 0;  \n\n\t \n\tdefcfg = snd_hda_codec_get_pincfg(codec, pin);\n\tif (snd_hda_get_input_pin_attr(defcfg) == INPUT_PIN_ATTR_INT)\n\t\treturn 0;\n\n\t \n\tif (get_in_jack_num_items(codec, pin) <= 1)\n\t\treturn 0;\n\n\tget_jack_mode_name(codec, pin, name, sizeof(name));\n\tknew = snd_hda_gen_add_kctl(spec, name, &in_jack_mode_enum);\n\tif (!knew)\n\t\treturn -ENOMEM;\n\tknew->private_value = pin;\n\treturn 0;\n}\n\n \nstatic int hp_mic_jack_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tint out_jacks = get_out_jack_num_items(codec, nid);\n\tint in_jacks = get_in_jack_num_items(codec, nid);\n\tconst char *text = NULL;\n\tint idx;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = out_jacks + in_jacks;\n\tif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\n\t\tuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\n\tidx = uinfo->value.enumerated.item;\n\tif (idx < out_jacks) {\n\t\tif (out_jacks > 1)\n\t\t\ttext = out_jack_texts[idx];\n\t\telse\n\t\t\ttext = \"Headphone Out\";\n\t} else {\n\t\tidx -= out_jacks;\n\t\tif (in_jacks > 1) {\n\t\t\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\t\t\ttext = vref_texts[get_vref_idx(vref_caps, idx)];\n\t\t} else\n\t\t\ttext = \"Mic In\";\n\t}\n\n\tstrcpy(uinfo->value.enumerated.name, text);\n\treturn 0;\n}\n\nstatic int get_cur_hp_mic_jack_mode(struct hda_codec *codec, hda_nid_t nid)\n{\n\tint out_jacks = get_out_jack_num_items(codec, nid);\n\tint in_jacks = get_in_jack_num_items(codec, nid);\n\tunsigned int val = snd_hda_codec_get_pin_target(codec, nid);\n\tint idx = 0;\n\n\tif (val & PIN_OUT) {\n\t\tif (out_jacks > 1 && val == PIN_HP)\n\t\t\tidx = 1;\n\t} else if (val & PIN_IN) {\n\t\tidx = out_jacks;\n\t\tif (in_jacks > 1) {\n\t\t\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\t\t\tval &= AC_PINCTL_VREFEN;\n\t\t\tidx += cvt_from_vref_idx(vref_caps, val);\n\t\t}\n\t}\n\treturn idx;\n}\n\nstatic int hp_mic_jack_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tucontrol->value.enumerated.item[0] =\n\t\tget_cur_hp_mic_jack_mode(codec, nid);\n\treturn 0;\n}\n\nstatic int hp_mic_jack_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tint out_jacks = get_out_jack_num_items(codec, nid);\n\tint in_jacks = get_in_jack_num_items(codec, nid);\n\tunsigned int val, oldval, idx;\n\n\toldval = get_cur_hp_mic_jack_mode(codec, nid);\n\tidx = ucontrol->value.enumerated.item[0];\n\tif (oldval == idx)\n\t\treturn 0;\n\n\tif (idx < out_jacks) {\n\t\tif (out_jacks > 1)\n\t\t\tval = idx ? PIN_HP : PIN_OUT;\n\t\telse\n\t\t\tval = PIN_HP;\n\t} else {\n\t\tidx -= out_jacks;\n\t\tif (in_jacks > 1) {\n\t\t\tunsigned int vref_caps = get_vref_caps(codec, nid);\n\t\t\tval = snd_hda_codec_get_pin_target(codec, nid);\n\t\t\tval &= ~(AC_PINCTL_VREFEN | PIN_HP);\n\t\t\tval |= get_vref_idx(vref_caps, idx) | PIN_IN;\n\t\t} else\n\t\t\tval = snd_hda_get_default_vref(codec, nid) | PIN_IN;\n\t}\n\tsnd_hda_set_pin_ctl_cache(codec, nid, val);\n\tcall_hp_automute(codec, NULL);\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new hp_mic_jack_mode_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = hp_mic_jack_mode_info,\n\t.get = hp_mic_jack_mode_get,\n\t.put = hp_mic_jack_mode_put,\n};\n\nstatic int create_hp_mic_jack_mode(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct snd_kcontrol_new *knew;\n\n\tknew = snd_hda_gen_add_kctl(spec, \"Headphone Mic Jack Mode\",\n\t\t\t\t    &hp_mic_jack_mode_enum);\n\tif (!knew)\n\t\treturn -ENOMEM;\n\tknew->private_value = pin;\n\tspec->hp_mic_jack_modes = 1;\n\treturn 0;\n}\n\n \n\n \nstatic int add_loopback_list(struct hda_gen_spec *spec, hda_nid_t mix, int idx)\n{\n\tstruct hda_amp_list *list;\n\n\tlist = snd_array_new(&spec->loopback_list);\n\tif (!list)\n\t\treturn -ENOMEM;\n\tlist->nid = mix;\n\tlist->dir = HDA_INPUT;\n\tlist->idx = idx;\n\tspec->loopback.amplist = spec->loopback_list.list;\n\treturn 0;\n}\n\n \nstatic bool look_for_mix_leaf_ctls(struct hda_codec *codec, hda_nid_t mix_nid,\n\t\t\t\t   hda_nid_t pin, unsigned int *mix_val,\n\t\t\t\t   unsigned int *mute_val)\n{\n\tint idx, num_conns;\n\tconst hda_nid_t *list;\n\thda_nid_t nid;\n\n\tidx = snd_hda_get_conn_index(codec, mix_nid, pin, true);\n\tif (idx < 0)\n\t\treturn false;\n\n\t*mix_val = *mute_val = 0;\n\tif (nid_has_volume(codec, mix_nid, HDA_INPUT))\n\t\t*mix_val = HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT);\n\tif (nid_has_mute(codec, mix_nid, HDA_INPUT))\n\t\t*mute_val = HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT);\n\tif (*mix_val && *mute_val)\n\t\treturn true;\n\n\t \n\tnum_conns = snd_hda_get_conn_list(codec, mix_nid, &list);\n\tif (num_conns < idx)\n\t\treturn false;\n\tnid = list[idx];\n\tif (!*mix_val && nid_has_volume(codec, nid, HDA_OUTPUT) &&\n\t    !is_ctl_associated(codec, nid, HDA_OUTPUT, 0, NID_PATH_VOL_CTL))\n\t\t*mix_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\tif (!*mute_val && nid_has_mute(codec, nid, HDA_OUTPUT) &&\n\t    !is_ctl_associated(codec, nid, HDA_OUTPUT, 0, NID_PATH_MUTE_CTL))\n\t\t*mute_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\n\treturn *mix_val || *mute_val;\n}\n\n \nstatic int new_analog_input(struct hda_codec *codec, int input_idx,\n\t\t\t    hda_nid_t pin, const char *ctlname, int ctlidx,\n\t\t\t    hda_nid_t mix_nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\tunsigned int mix_val, mute_val;\n\tint err, idx;\n\n\tif (!look_for_mix_leaf_ctls(codec, mix_nid, pin, &mix_val, &mute_val))\n\t\treturn 0;\n\n\tpath = snd_hda_add_new_path(codec, pin, mix_nid, 0);\n\tif (!path)\n\t\treturn -EINVAL;\n\tprint_nid_path(codec, \"loopback\", path);\n\tspec->loopback_paths[input_idx] = snd_hda_get_path_idx(codec, path);\n\n\tidx = path->idx[path->depth - 1];\n\tif (mix_val) {\n\t\terr = __add_pb_vol_ctrl(spec, HDA_CTL_WIDGET_VOL, ctlname, ctlidx, mix_val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath->ctls[NID_PATH_VOL_CTL] = mix_val;\n\t}\n\n\tif (mute_val) {\n\t\terr = __add_pb_sw_ctrl(spec, HDA_CTL_WIDGET_MUTE, ctlname, ctlidx, mute_val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath->ctls[NID_PATH_MUTE_CTL] = mute_val;\n\t}\n\n\tpath->active = true;\n\tpath->stream_enabled = true;  \n\terr = add_loopback_list(spec, mix_nid, idx);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (spec->mixer_nid != spec->mixer_merge_nid &&\n\t    !spec->loopback_merge_path) {\n\t\tpath = snd_hda_add_new_path(codec, spec->mixer_nid,\n\t\t\t\t\t    spec->mixer_merge_nid, 0);\n\t\tif (path) {\n\t\t\tprint_nid_path(codec, \"loopback-merge\", path);\n\t\t\tpath->active = true;\n\t\t\tpath->pin_fixed = true;  \n\t\t\tpath->stream_enabled = true;  \n\t\t\tspec->loopback_merge_path =\n\t\t\t\tsnd_hda_get_path_idx(codec, path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int is_input_pin(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int pincap = snd_hda_query_pin_caps(codec, nid);\n\treturn (pincap & AC_PINCAP_IN) != 0;\n}\n\n \nstatic int fill_adc_nids(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t nid;\n\thda_nid_t *adc_nids = spec->adc_nids;\n\tint max_nums = ARRAY_SIZE(spec->adc_nids);\n\tint nums = 0;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int caps = get_wcaps(codec, nid);\n\t\tint type = get_wcaps_type(caps);\n\n\t\tif (type != AC_WID_AUD_IN || (caps & AC_WCAP_DIGITAL))\n\t\t\tcontinue;\n\t\tadc_nids[nums] = nid;\n\t\tif (++nums >= max_nums)\n\t\t\tbreak;\n\t}\n\tspec->num_adc_nids = nums;\n\n\t \n\tspec->num_all_adcs = nums;\n\tmemcpy(spec->all_adcs, spec->adc_nids, nums * sizeof(hda_nid_t));\n\n\treturn nums;\n}\n\n \nstatic int check_dyn_adc_switch(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tunsigned int ok_bits;\n\tint i, n, nums;\n\n\tnums = 0;\n\tok_bits = 0;\n\tfor (n = 0; n < spec->num_adc_nids; n++) {\n\t\tfor (i = 0; i < imux->num_items; i++) {\n\t\t\tif (!spec->input_paths[i][n])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= imux->num_items) {\n\t\t\tok_bits |= (1 << n);\n\t\t\tnums++;\n\t\t}\n\t}\n\n\tif (!ok_bits) {\n\t\t \n\t\tfor (i = 0; i < imux->num_items; i++) {\n\t\t\tfor (n = 0; n < spec->num_adc_nids; n++) {\n\t\t\t\tif (spec->input_paths[i][n]) {\n\t\t\t\t\tspec->dyn_adc_idx[i] = n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcodec_dbg(codec, \"enabling ADC switching\\n\");\n\t\tspec->dyn_adc_switch = 1;\n\t} else if (nums != spec->num_adc_nids) {\n\t\t \n\t\tnums = 0;\n\t\tfor (n = 0; n < spec->num_adc_nids; n++) {\n\t\t\tif (!(ok_bits & (1 << n)))\n\t\t\t\tcontinue;\n\t\t\tif (n != nums) {\n\t\t\t\tspec->adc_nids[nums] = spec->adc_nids[n];\n\t\t\t\tfor (i = 0; i < imux->num_items; i++) {\n\t\t\t\t\tinvalidate_nid_path(codec,\n\t\t\t\t\t\tspec->input_paths[i][nums]);\n\t\t\t\t\tspec->input_paths[i][nums] =\n\t\t\t\t\t\tspec->input_paths[i][n];\n\t\t\t\t\tspec->input_paths[i][n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnums++;\n\t\t}\n\t\tspec->num_adc_nids = nums;\n\t}\n\n\tif (imux->num_items == 1 ||\n\t    (imux->num_items == 2 && spec->hp_mic)) {\n\t\tcodec_dbg(codec, \"reducing to a single ADC\\n\");\n\t\tspec->num_adc_nids = 1;  \n\t}\n\n\t \n\tif (!spec->dyn_adc_switch && spec->multi_cap_vol)\n\t\tspec->num_adc_nids = 1;\n\n\treturn 0;\n}\n\n \nstatic int parse_capture_source(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t\tint cfg_idx, int num_adcs,\n\t\t\t\tconst char *label, int anchor)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tint imux_idx = imux->num_items;\n\tbool imux_added = false;\n\tint c;\n\n\tfor (c = 0; c < num_adcs; c++) {\n\t\tstruct nid_path *path;\n\t\thda_nid_t adc = spec->adc_nids[c];\n\n\t\tif (!is_reachable_path(codec, pin, adc))\n\t\t\tcontinue;\n\t\tpath = snd_hda_add_new_path(codec, pin, adc, anchor);\n\t\tif (!path)\n\t\t\tcontinue;\n\t\tprint_nid_path(codec, \"input\", path);\n\t\tspec->input_paths[imux_idx][c] =\n\t\t\tsnd_hda_get_path_idx(codec, path);\n\n\t\tif (!imux_added) {\n\t\t\tif (spec->hp_mic_pin == pin)\n\t\t\t\tspec->hp_mic_mux_idx = imux->num_items;\n\t\t\tspec->imux_pins[imux->num_items] = pin;\n\t\t\tsnd_hda_add_imux_item(codec, imux, label, cfg_idx, NULL);\n\t\t\timux_added = true;\n\t\t\tif (spec->dyn_adc_switch)\n\t\t\t\tspec->dyn_adc_idx[imux_idx] = c;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int fill_input_pin_labels(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i;\n\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\thda_nid_t pin = cfg->inputs[i].pin;\n\t\tconst char *label;\n\t\tint j, idx;\n\n\t\tif (!is_input_pin(codec, pin))\n\t\t\tcontinue;\n\n\t\tlabel = hda_get_autocfg_input_label(codec, cfg, i);\n\t\tidx = 0;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (spec->input_labels[j] &&\n\t\t\t    !strcmp(spec->input_labels[j], label)) {\n\t\t\t\tidx = spec->input_label_idxs[j] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspec->input_labels[i] = label;\n\t\tspec->input_label_idxs[i] = idx;\n\t}\n\n\treturn 0;\n}\n\n#define CFG_IDX_MIX\t99\t \n\nstatic int create_input_ctls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct auto_pin_cfg *cfg = &spec->autocfg;\n\thda_nid_t mixer = spec->mixer_nid;\n\tint num_adcs;\n\tint i, err;\n\tunsigned int val;\n\n\tnum_adcs = fill_adc_nids(codec);\n\tif (num_adcs < 0)\n\t\treturn 0;\n\n\terr = fill_input_pin_labels(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\thda_nid_t pin;\n\n\t\tpin = cfg->inputs[i].pin;\n\t\tif (!is_input_pin(codec, pin))\n\t\t\tcontinue;\n\n\t\tval = PIN_IN;\n\t\tif (cfg->inputs[i].type == AUTO_PIN_MIC)\n\t\t\tval |= snd_hda_get_default_vref(codec, pin);\n\t\tif (pin != spec->hp_mic_pin &&\n\t\t    !snd_hda_codec_get_pin_target(codec, pin))\n\t\t\tset_pin_target(codec, pin, val, false);\n\n\t\tif (mixer) {\n\t\t\tif (is_reachable_path(codec, pin, mixer)) {\n\t\t\t\terr = new_analog_input(codec, i, pin,\n\t\t\t\t\t\t       spec->input_labels[i],\n\t\t\t\t\t\t       spec->input_label_idxs[i],\n\t\t\t\t\t\t       mixer);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\terr = parse_capture_source(codec, pin, i, num_adcs,\n\t\t\t\t\t   spec->input_labels[i], -mixer);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (spec->add_jack_modes) {\n\t\t\terr = create_in_jack_mode(codec, pin);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (mixer && spec->add_stereo_mix_input == HDA_HINT_STEREO_MIX_ENABLE) {\n\t\terr = parse_capture_source(codec, mixer, CFG_IDX_MIX, num_adcs,\n\t\t\t\t\t   \"Stereo Mix\", 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\telse\n\t\t\tspec->suppress_auto_mic = 1;\n\t}\n\n\treturn 0;\n}\n\n\n \n\n \nstatic struct nid_path *get_input_path(struct hda_codec *codec, int adc_idx, int imux_idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (imux_idx < 0 || imux_idx >= HDA_MAX_NUM_INPUTS) {\n\t\tsnd_BUG();\n\t\treturn NULL;\n\t}\n\tif (spec->dyn_adc_switch)\n\t\tadc_idx = spec->dyn_adc_idx[imux_idx];\n\tif (adc_idx < 0 || adc_idx >= AUTO_CFG_MAX_INS) {\n\t\tsnd_BUG();\n\t\treturn NULL;\n\t}\n\treturn snd_hda_get_path_from_idx(codec, spec->input_paths[imux_idx][adc_idx]);\n}\n\nstatic int mux_select(struct hda_codec *codec, unsigned int adc_idx,\n\t\t      unsigned int idx);\n\nstatic int mux_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_input_mux_info(&spec->input_mux, uinfo);\n}\n\nstatic int mux_enum_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\t \n\tunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\n\tucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];\n\treturn 0;\n}\n\nstatic int mux_enum_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\treturn mux_select(codec, adc_idx,\n\t\t\t  ucontrol->value.enumerated.item[0]);\n}\n\nstatic const struct snd_kcontrol_new cap_src_temp = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Input Source\",\n\t.info = mux_enum_info,\n\t.get = mux_enum_get,\n\t.put = mux_enum_put,\n};\n\n \n\ntypedef int (*put_call_t)(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol);\n\n \nstatic int cap_put_caller(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol,\n\t\t\t  put_call_t func, int type)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct hda_input_mux *imux;\n\tstruct nid_path *path;\n\tint i, adc_idx, ret, err = 0;\n\n\timux = &spec->input_mux;\n\tadc_idx = kcontrol->id.index;\n\tmutex_lock(&codec->control_mutex);\n\tfor (i = 0; i < imux->num_items; i++) {\n\t\tpath = get_input_path(codec, adc_idx, i);\n\t\tif (!path || !path->ctls[type])\n\t\t\tcontinue;\n\t\tkcontrol->private_value = path->ctls[type];\n\t\tret = func(kcontrol, ucontrol);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret > 0)\n\t\t\terr = 1;\n\t}\n\tmutex_unlock(&codec->control_mutex);\n\tif (err >= 0 && spec->cap_sync_hook)\n\t\tspec->cap_sync_hook(codec, kcontrol, ucontrol);\n\treturn err;\n}\n\n \n#define cap_vol_info\t\tsnd_hda_mixer_amp_volume_info\n#define cap_vol_get\t\tsnd_hda_mixer_amp_volume_get\n#define cap_vol_tlv\t\tsnd_hda_mixer_amp_tlv\n\nstatic int cap_vol_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\treturn cap_put_caller(kcontrol, ucontrol,\n\t\t\t      snd_hda_mixer_amp_volume_put,\n\t\t\t      NID_PATH_VOL_CTL);\n}\n\nstatic const struct snd_kcontrol_new cap_vol_temp = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Volume\",\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK),\n\t.info = cap_vol_info,\n\t.get = cap_vol_get,\n\t.put = cap_vol_put,\n\t.tlv = { .c = cap_vol_tlv },\n};\n\n \n#define cap_sw_info\t\tsnd_ctl_boolean_stereo_info\n#define cap_sw_get\t\tsnd_hda_mixer_amp_switch_get\n\nstatic int cap_sw_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\treturn cap_put_caller(kcontrol, ucontrol,\n\t\t\t      snd_hda_mixer_amp_switch_put,\n\t\t\t      NID_PATH_MUTE_CTL);\n}\n\nstatic const struct snd_kcontrol_new cap_sw_temp = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Switch\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = cap_sw_info,\n\t.get = cap_sw_get,\n\t.put = cap_sw_put,\n};\n\nstatic int parse_capvol_in_path(struct hda_codec *codec, struct nid_path *path)\n{\n\thda_nid_t nid;\n\tint i, depth;\n\n\tpath->ctls[NID_PATH_VOL_CTL] = path->ctls[NID_PATH_MUTE_CTL] = 0;\n\tfor (depth = 0; depth < 3; depth++) {\n\t\tif (depth >= path->depth)\n\t\t\treturn -EINVAL;\n\t\ti = path->depth - depth - 1;\n\t\tnid = path->path[i];\n\t\tif (!path->ctls[NID_PATH_VOL_CTL]) {\n\t\t\tif (nid_has_volume(codec, nid, HDA_OUTPUT))\n\t\t\t\tpath->ctls[NID_PATH_VOL_CTL] =\n\t\t\t\t\tHDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t\t\telse if (nid_has_volume(codec, nid, HDA_INPUT)) {\n\t\t\t\tint idx = path->idx[i];\n\t\t\t\tif (!depth && codec->single_adc_amp)\n\t\t\t\t\tidx = 0;\n\t\t\t\tpath->ctls[NID_PATH_VOL_CTL] =\n\t\t\t\t\tHDA_COMPOSE_AMP_VAL(nid, 3, idx, HDA_INPUT);\n\t\t\t}\n\t\t}\n\t\tif (!path->ctls[NID_PATH_MUTE_CTL]) {\n\t\t\tif (nid_has_mute(codec, nid, HDA_OUTPUT))\n\t\t\t\tpath->ctls[NID_PATH_MUTE_CTL] =\n\t\t\t\t\tHDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t\t\telse if (nid_has_mute(codec, nid, HDA_INPUT)) {\n\t\t\t\tint idx = path->idx[i];\n\t\t\t\tif (!depth && codec->single_adc_amp)\n\t\t\t\t\tidx = 0;\n\t\t\t\tpath->ctls[NID_PATH_MUTE_CTL] =\n\t\t\t\t\tHDA_COMPOSE_AMP_VAL(nid, 3, idx, HDA_INPUT);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool is_inv_dmic_pin(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int val;\n\tint i;\n\n\tif (!spec->inv_dmic_split)\n\t\treturn false;\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\tif (cfg->inputs[i].pin != nid)\n\t\t\tcontinue;\n\t\tif (cfg->inputs[i].type != AUTO_PIN_MIC)\n\t\t\treturn false;\n\t\tval = snd_hda_codec_get_pincfg(codec, nid);\n\t\treturn snd_hda_get_input_pin_attr(val) == INPUT_PIN_ATTR_INT;\n\t}\n\treturn false;\n}\n\n \nstatic int cap_single_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint ret;\n\n\tret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (spec->cap_sync_hook)\n\t\tspec->cap_sync_hook(codec, kcontrol, ucontrol);\n\n\treturn ret;\n}\n\nstatic int add_single_cap_ctl(struct hda_codec *codec, const char *label,\n\t\t\t      int idx, bool is_switch, unsigned int ctl,\n\t\t\t      bool inv_dmic)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tchar tmpname[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint type = is_switch ? HDA_CTL_WIDGET_MUTE : HDA_CTL_WIDGET_VOL;\n\tconst char *sfx = is_switch ? \"Switch\" : \"Volume\";\n\tunsigned int chs = inv_dmic ? 1 : 3;\n\tstruct snd_kcontrol_new *knew;\n\n\tif (!ctl)\n\t\treturn 0;\n\n\tif (label)\n\t\tsnprintf(tmpname, sizeof(tmpname),\n\t\t\t \"%s Capture %s\", label, sfx);\n\telse\n\t\tsnprintf(tmpname, sizeof(tmpname),\n\t\t\t \"Capture %s\", sfx);\n\tknew = add_control(spec, type, tmpname, idx,\n\t\t\t   amp_val_replace_channels(ctl, chs));\n\tif (!knew)\n\t\treturn -ENOMEM;\n\tif (is_switch) {\n\t\tknew->put = cap_single_sw_put;\n\t\tif (spec->mic_mute_led)\n\t\t\tknew->access |= SNDRV_CTL_ELEM_ACCESS_MIC_LED;\n\t}\n\tif (!inv_dmic)\n\t\treturn 0;\n\n\t \n\tif (label)\n\t\tsnprintf(tmpname, sizeof(tmpname),\n\t\t\t \"Inverted %s Capture %s\", label, sfx);\n\telse\n\t\tsnprintf(tmpname, sizeof(tmpname),\n\t\t\t \"Inverted Capture %s\", sfx);\n\tknew = add_control(spec, type, tmpname, idx,\n\t\t\t   amp_val_replace_channels(ctl, 2));\n\tif (!knew)\n\t\treturn -ENOMEM;\n\tif (is_switch) {\n\t\tknew->put = cap_single_sw_put;\n\t\tif (spec->mic_mute_led)\n\t\t\tknew->access |= SNDRV_CTL_ELEM_ACCESS_MIC_LED;\n\t}\n\treturn 0;\n}\n\n \nstatic int create_single_cap_vol_ctl(struct hda_codec *codec, int idx,\n\t\t\t\t     unsigned int vol_ctl, unsigned int sw_ctl,\n\t\t\t\t     bool inv_dmic)\n{\n\tint err;\n\terr = add_single_cap_ctl(codec, NULL, idx, false, vol_ctl, inv_dmic);\n\tif (err < 0)\n\t\treturn err;\n\terr = add_single_cap_ctl(codec, NULL, idx, true, sw_ctl, inv_dmic);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n \nstatic int create_bind_cap_vol_ctl(struct hda_codec *codec, int idx,\n\t\t\t\t   unsigned int vol_ctl, unsigned int sw_ctl)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct snd_kcontrol_new *knew;\n\n\tif (vol_ctl) {\n\t\tknew = snd_hda_gen_add_kctl(spec, NULL, &cap_vol_temp);\n\t\tif (!knew)\n\t\t\treturn -ENOMEM;\n\t\tknew->index = idx;\n\t\tknew->private_value = vol_ctl;\n\t\tknew->subdevice = HDA_SUBDEV_AMP_FLAG;\n\t}\n\tif (sw_ctl) {\n\t\tknew = snd_hda_gen_add_kctl(spec, NULL, &cap_sw_temp);\n\t\tif (!knew)\n\t\t\treturn -ENOMEM;\n\t\tknew->index = idx;\n\t\tknew->private_value = sw_ctl;\n\t\tknew->subdevice = HDA_SUBDEV_AMP_FLAG;\n\t\tif (spec->mic_mute_led)\n\t\t\tknew->access |= SNDRV_CTL_ELEM_ACCESS_MIC_LED;\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int get_first_cap_ctl(struct hda_codec *codec, int idx, int type)\n{\n\tstruct nid_path *path;\n\tunsigned int ctl;\n\tint i;\n\n\tpath = get_input_path(codec, 0, idx);\n\tif (!path)\n\t\treturn 0;\n\tctl = path->ctls[type];\n\tif (!ctl)\n\t\treturn 0;\n\tfor (i = 0; i < idx - 1; i++) {\n\t\tpath = get_input_path(codec, 0, i);\n\t\tif (path && path->ctls[type] == ctl)\n\t\t\treturn 0;\n\t}\n\treturn ctl;\n}\n\n \nstatic int create_multi_cap_vol_ctl(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tint i, err, type;\n\n\tfor (i = 0; i < imux->num_items; i++) {\n\t\tbool inv_dmic;\n\t\tint idx;\n\n\t\tidx = imux->items[i].index;\n\t\tif (idx >= spec->autocfg.num_inputs)\n\t\t\tcontinue;\n\t\tinv_dmic = is_inv_dmic_pin(codec, spec->imux_pins[i]);\n\n\t\tfor (type = 0; type < 2; type++) {\n\t\t\terr = add_single_cap_ctl(codec,\n\t\t\t\t\t\t spec->input_labels[idx],\n\t\t\t\t\t\t spec->input_label_idxs[idx],\n\t\t\t\t\t\t type,\n\t\t\t\t\t\t get_first_cap_ctl(codec, i, type),\n\t\t\t\t\t\t inv_dmic);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int create_capture_mixers(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tint i, n, nums, err;\n\n\tif (spec->dyn_adc_switch)\n\t\tnums = 1;\n\telse\n\t\tnums = spec->num_adc_nids;\n\n\tif (!spec->auto_mic && imux->num_items > 1) {\n\t\tstruct snd_kcontrol_new *knew;\n\t\tconst char *name;\n\t\tname = nums > 1 ? \"Input Source\" : \"Capture Source\";\n\t\tknew = snd_hda_gen_add_kctl(spec, name, &cap_src_temp);\n\t\tif (!knew)\n\t\t\treturn -ENOMEM;\n\t\tknew->count = nums;\n\t}\n\n\tfor (n = 0; n < nums; n++) {\n\t\tbool multi = false;\n\t\tbool multi_cap_vol = spec->multi_cap_vol;\n\t\tbool inv_dmic = false;\n\t\tint vol, sw;\n\n\t\tvol = sw = 0;\n\t\tfor (i = 0; i < imux->num_items; i++) {\n\t\t\tstruct nid_path *path;\n\t\t\tpath = get_input_path(codec, n, i);\n\t\t\tif (!path)\n\t\t\t\tcontinue;\n\t\t\tparse_capvol_in_path(codec, path);\n\t\t\tif (!vol)\n\t\t\t\tvol = path->ctls[NID_PATH_VOL_CTL];\n\t\t\telse if (vol != path->ctls[NID_PATH_VOL_CTL]) {\n\t\t\t\tmulti = true;\n\t\t\t\tif (!same_amp_caps(codec, vol,\n\t\t\t\t    path->ctls[NID_PATH_VOL_CTL], HDA_INPUT))\n\t\t\t\t\tmulti_cap_vol = true;\n\t\t\t}\n\t\t\tif (!sw)\n\t\t\t\tsw = path->ctls[NID_PATH_MUTE_CTL];\n\t\t\telse if (sw != path->ctls[NID_PATH_MUTE_CTL]) {\n\t\t\t\tmulti = true;\n\t\t\t\tif (!same_amp_caps(codec, sw,\n\t\t\t\t    path->ctls[NID_PATH_MUTE_CTL], HDA_INPUT))\n\t\t\t\t\tmulti_cap_vol = true;\n\t\t\t}\n\t\t\tif (is_inv_dmic_pin(codec, spec->imux_pins[i]))\n\t\t\t\tinv_dmic = true;\n\t\t}\n\n\t\tif (!multi)\n\t\t\terr = create_single_cap_vol_ctl(codec, n, vol, sw,\n\t\t\t\t\t\t\tinv_dmic);\n\t\telse if (!multi_cap_vol && !inv_dmic)\n\t\t\terr = create_bind_cap_vol_ctl(codec, n, vol, sw);\n\t\telse\n\t\t\terr = create_multi_cap_vol_ctl(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic bool check_boost_vol(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t    int dir, int idx)\n{\n\tunsigned int step;\n\n\tif (!nid_has_volume(codec, nid, dir) ||\n\t    is_ctl_associated(codec, nid, dir, idx, NID_PATH_VOL_CTL) ||\n\t    is_ctl_associated(codec, nid, dir, idx, NID_PATH_BOOST_CTL))\n\t\treturn false;\n\n\tstep = (query_amp_caps(codec, nid, dir) & AC_AMPCAP_STEP_SIZE)\n\t\t>> AC_AMPCAP_STEP_SIZE_SHIFT;\n\tif (step < 0x20)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic unsigned int look_for_boost_amp(struct hda_codec *codec,\n\t\t\t\t       struct nid_path *path)\n{\n\tunsigned int val = 0;\n\thda_nid_t nid;\n\tint depth;\n\n\tfor (depth = 0; depth < 3; depth++) {\n\t\tif (depth >= path->depth - 1)\n\t\t\tbreak;\n\t\tnid = path->path[depth];\n\t\tif (depth && check_boost_vol(codec, nid, HDA_OUTPUT, 0)) {\n\t\t\tval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t\t\tbreak;\n\t\t} else if (check_boost_vol(codec, nid, HDA_INPUT,\n\t\t\t\t\t   path->idx[depth])) {\n\t\t\tval = HDA_COMPOSE_AMP_VAL(nid, 3, path->idx[depth],\n\t\t\t\t\t\t  HDA_INPUT);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic int parse_mic_boost(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tint i;\n\n\tif (!spec->num_adc_nids)\n\t\treturn 0;\n\n\tfor (i = 0; i < imux->num_items; i++) {\n\t\tstruct nid_path *path;\n\t\tunsigned int val;\n\t\tint idx;\n\t\tchar boost_label[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\t\tidx = imux->items[i].index;\n\t\tif (idx >= imux->num_items)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (cfg->inputs[idx].type > AUTO_PIN_LINE_IN)\n\t\t\tcontinue;\n\n\t\tpath = get_input_path(codec, 0, i);\n\t\tif (!path)\n\t\t\tcontinue;\n\n\t\tval = look_for_boost_amp(codec, path);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(boost_label, sizeof(boost_label),\n\t\t\t \"%s Boost Volume\", spec->input_labels[idx]);\n\t\tif (!add_control(spec, HDA_CTL_WIDGET_VOL, boost_label,\n\t\t\t\t spec->input_label_idxs[idx], val))\n\t\t\treturn -ENOMEM;\n\n\t\tpath->ctls[NID_PATH_BOOST_CTL] = val;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_HDA_GENERIC_LEDS\n \n\nstatic int create_mute_led_cdev(struct hda_codec *codec,\n\t\t\t\tint (*callback)(struct led_classdev *,\n\t\t\t\t\t\tenum led_brightness),\n\t\t\t\tbool micmute)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct led_classdev *cdev;\n\tint idx = micmute ? LED_AUDIO_MICMUTE : LED_AUDIO_MUTE;\n\tint err;\n\n\tcdev = devm_kzalloc(&codec->core.dev, sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tcdev->name = micmute ? \"hda::micmute\" : \"hda::mute\";\n\tcdev->max_brightness = 1;\n\tcdev->default_trigger = micmute ? \"audio-micmute\" : \"audio-mute\";\n\tcdev->brightness_set_blocking = callback;\n\tcdev->brightness = ledtrig_audio_get(idx);\n\tcdev->flags = LED_CORE_SUSPENDRESUME;\n\n\terr = led_classdev_register(&codec->core.dev, cdev);\n\tif (err < 0)\n\t\treturn err;\n\tspec->led_cdevs[idx] = cdev;\n\treturn 0;\n}\n\n \nint snd_hda_gen_add_mute_led_cdev(struct hda_codec *codec,\n\t\t\t\t  int (*callback)(struct led_classdev *,\n\t\t\t\t\t\t  enum led_brightness))\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\tif (callback) {\n\t\terr = create_mute_led_cdev(codec, callback, false);\n\t\tif (err) {\n\t\t\tcodec_warn(codec, \"failed to create a mute LED cdev\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (spec->vmaster_mute.hook)\n\t\tcodec_err(codec, \"vmaster hook already present before cdev!\\n\");\n\n\tspec->vmaster_mute_led = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_add_mute_led_cdev);\n\n \nint snd_hda_gen_add_micmute_led_cdev(struct hda_codec *codec,\n\t\t\t\t     int (*callback)(struct led_classdev *,\n\t\t\t\t\t\t     enum led_brightness))\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\tif (callback) {\n\t\terr = create_mute_led_cdev(codec, callback, true);\n\t\tif (err) {\n\t\t\tcodec_warn(codec, \"failed to create a mic-mute LED cdev\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tspec->mic_mute_led = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_add_micmute_led_cdev);\n#endif  \n\n \nstatic void parse_digital(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\tint i, nums;\n\thda_nid_t dig_nid, pin;\n\n\t \n\tnums = 0;\n\tfor (i = 0; i < spec->autocfg.dig_outs; i++) {\n\t\tpin = spec->autocfg.dig_out_pins[i];\n\t\tdig_nid = look_for_dac(codec, pin, true);\n\t\tif (!dig_nid)\n\t\t\tcontinue;\n\t\tpath = snd_hda_add_new_path(codec, dig_nid, pin, 0);\n\t\tif (!path)\n\t\t\tcontinue;\n\t\tprint_nid_path(codec, \"digout\", path);\n\t\tpath->active = true;\n\t\tpath->pin_fixed = true;  \n\t\tspec->digout_paths[i] = snd_hda_get_path_idx(codec, path);\n\t\tset_pin_target(codec, pin, PIN_OUT, false);\n\t\tif (!nums) {\n\t\t\tspec->multiout.dig_out_nid = dig_nid;\n\t\t\tspec->dig_out_type = spec->autocfg.dig_out_type[0];\n\t\t} else {\n\t\t\tspec->multiout.follower_dig_outs = spec->follower_dig_outs;\n\t\t\tif (nums >= ARRAY_SIZE(spec->follower_dig_outs) - 1)\n\t\t\t\tbreak;\n\t\t\tspec->follower_dig_outs[nums - 1] = dig_nid;\n\t\t}\n\t\tnums++;\n\t}\n\n\tif (spec->autocfg.dig_in_pin) {\n\t\tpin = spec->autocfg.dig_in_pin;\n\t\tfor_each_hda_codec_node(dig_nid, codec) {\n\t\t\tunsigned int wcaps = get_wcaps(codec, dig_nid);\n\t\t\tif (get_wcaps_type(wcaps) != AC_WID_AUD_IN)\n\t\t\t\tcontinue;\n\t\t\tif (!(wcaps & AC_WCAP_DIGITAL))\n\t\t\t\tcontinue;\n\t\t\tpath = snd_hda_add_new_path(codec, pin, dig_nid, 0);\n\t\t\tif (path) {\n\t\t\t\tprint_nid_path(codec, \"digin\", path);\n\t\t\t\tpath->active = true;\n\t\t\t\tpath->pin_fixed = true;  \n\t\t\t\tspec->dig_in_nid = dig_nid;\n\t\t\t\tspec->digin_path = snd_hda_get_path_idx(codec, path);\n\t\t\t\tset_pin_target(codec, pin, PIN_IN, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \n\nstatic bool dyn_adc_pcm_resetup(struct hda_codec *codec, int cur);\n\n \nstatic int mux_select(struct hda_codec *codec, unsigned int adc_idx,\n\t\t      unsigned int idx)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct hda_input_mux *imux;\n\tstruct nid_path *old_path, *path;\n\n\timux = &spec->input_mux;\n\tif (!imux->num_items)\n\t\treturn 0;\n\n\tif (idx >= imux->num_items)\n\t\tidx = imux->num_items - 1;\n\tif (spec->cur_mux[adc_idx] == idx)\n\t\treturn 0;\n\n\told_path = get_input_path(codec, adc_idx, spec->cur_mux[adc_idx]);\n\tif (!old_path)\n\t\treturn 0;\n\tif (old_path->active)\n\t\tsnd_hda_activate_path(codec, old_path, false, false);\n\n\tspec->cur_mux[adc_idx] = idx;\n\n\tif (spec->hp_mic)\n\t\tupdate_hp_mic(codec, adc_idx, false);\n\n\tif (spec->dyn_adc_switch)\n\t\tdyn_adc_pcm_resetup(codec, idx);\n\n\tpath = get_input_path(codec, adc_idx, idx);\n\tif (!path)\n\t\treturn 0;\n\tif (path->active)\n\t\treturn 0;\n\tsnd_hda_activate_path(codec, path, true, false);\n\tif (spec->cap_sync_hook)\n\t\tspec->cap_sync_hook(codec, NULL, NULL);\n\tpath_power_down_sync(codec, old_path);\n\treturn 1;\n}\n\n \nstatic hda_nid_t set_path_power(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\tint pin_state, int stream_state)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t last, changed = 0;\n\tstruct nid_path *path;\n\tint n;\n\n\tsnd_array_for_each(&spec->paths, n, path) {\n\t\tif (!path->depth)\n\t\t\tcontinue;\n\t\tif (path->path[0] == nid ||\n\t\t    path->path[path->depth - 1] == nid) {\n\t\t\tbool pin_old = path->pin_enabled;\n\t\t\tbool stream_old = path->stream_enabled;\n\n\t\t\tif (pin_state >= 0)\n\t\t\t\tpath->pin_enabled = pin_state;\n\t\t\tif (stream_state >= 0)\n\t\t\t\tpath->stream_enabled = stream_state;\n\t\t\tif ((!path->pin_fixed && path->pin_enabled != pin_old)\n\t\t\t    || path->stream_enabled != stream_old) {\n\t\t\t\tlast = path_power_update(codec, path, true);\n\t\t\t\tif (last)\n\t\t\t\t\tchanged = last;\n\t\t\t}\n\t\t}\n\t}\n\treturn changed;\n}\n\n \nstatic bool detect_pin_state(struct hda_codec *codec, hda_nid_t pin)\n{\n\tif (!is_jack_detectable(codec, pin))\n\t\treturn true;\n\treturn snd_hda_jack_detect_state(codec, pin) != HDA_JACK_NOT_PRESENT;\n}\n\n \nstatic hda_nid_t set_pin_power_jack(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t\t    int power)\n{\n\tbool on;\n\n\tif (!codec->power_save_node)\n\t\treturn 0;\n\n\ton = detect_pin_state(codec, pin);\n\n\tif (power >= 0 && on != power)\n\t\treturn 0;\n\treturn set_path_power(codec, pin, on, -1);\n}\n\nstatic void pin_power_callback(struct hda_codec *codec,\n\t\t\t       struct hda_jack_callback *jack,\n\t\t\t       bool on)\n{\n\tif (jack && jack->nid)\n\t\tsync_power_state_change(codec,\n\t\t\t\t\tset_pin_power_jack(codec, jack->nid, on));\n}\n\n \nstatic void pin_power_up_callback(struct hda_codec *codec,\n\t\t\t\t  struct hda_jack_callback *jack)\n{\n\tpin_power_callback(codec, jack, true);\n}\n\n \nstatic void pin_power_down_callback(struct hda_codec *codec,\n\t\t\t\t    struct hda_jack_callback *jack)\n{\n\tpin_power_callback(codec, jack, false);\n}\n\n \nstatic void add_pin_power_ctls(struct hda_codec *codec, int num_pins,\n\t\t\t       const hda_nid_t *pins, bool on)\n{\n\tint i;\n\thda_jack_callback_fn cb =\n\t\ton ? pin_power_up_callback : pin_power_down_callback;\n\n\tfor (i = 0; i < num_pins && pins[i]; i++) {\n\t\tif (is_jack_detectable(codec, pins[i]))\n\t\t\tsnd_hda_jack_detect_enable_callback(codec, pins[i], cb);\n\t\telse\n\t\t\tset_path_power(codec, pins[i], true, -1);\n\t}\n}\n\n \nstatic void add_all_pin_power_ctls(struct hda_codec *codec, bool on)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i;\n\n\tif (!codec->power_save_node)\n\t\treturn;\n\tadd_pin_power_ctls(codec, cfg->line_outs, cfg->line_out_pins, on);\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\tadd_pin_power_ctls(codec, cfg->hp_outs, cfg->hp_pins, on);\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\tadd_pin_power_ctls(codec, cfg->speaker_outs, cfg->speaker_pins, on);\n\tfor (i = 0; i < cfg->num_inputs; i++)\n\t\tadd_pin_power_ctls(codec, 1, &cfg->inputs[i].pin, on);\n}\n\n \nstatic void sync_pin_power_ctls(struct hda_codec *codec, int num_pins,\n\t\t\t\tconst hda_nid_t *pins)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pins && pins[i]; i++)\n\t\tif (is_jack_detectable(codec, pins[i]))\n\t\t\tset_pin_power_jack(codec, pins[i], -1);\n}\n\n \nstatic void sync_all_pin_power_ctls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i;\n\n\tif (!codec->power_save_node)\n\t\treturn;\n\tsync_pin_power_ctls(codec, cfg->line_outs, cfg->line_out_pins);\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\tsync_pin_power_ctls(codec, cfg->hp_outs, cfg->hp_pins);\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\tsync_pin_power_ctls(codec, cfg->speaker_outs, cfg->speaker_pins);\n\tfor (i = 0; i < cfg->num_inputs; i++)\n\t\tsync_pin_power_ctls(codec, 1, &cfg->inputs[i].pin);\n}\n\n \nstatic int add_fake_paths(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int num_pins, const hda_nid_t *pins)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\tint i;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tif (!pins[i])\n\t\t\tbreak;\n\t\tif (get_nid_path(codec, nid, pins[i], 0))\n\t\t\tcontinue;\n\t\tpath = snd_array_new(&spec->paths);\n\t\tif (!path)\n\t\t\treturn -ENOMEM;\n\t\tmemset(path, 0, sizeof(*path));\n\t\tpath->depth = 2;\n\t\tpath->path[0] = nid;\n\t\tpath->path[1] = pins[i];\n\t\tpath->active = true;\n\t}\n\treturn 0;\n}\n\n \nstatic int add_fake_beep_paths(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\thda_nid_t nid = spec->beep_nid;\n\tint err;\n\n\tif (!codec->power_save_node || !nid)\n\t\treturn 0;\n\terr = add_fake_paths(codec, nid, cfg->line_outs, cfg->line_out_pins);\n\tif (err < 0)\n\t\treturn err;\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\n\t\terr = add_fake_paths(codec, nid, cfg->hp_outs, cfg->hp_pins);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\terr = add_fake_paths(codec, nid, cfg->speaker_outs,\n\t\t\t\t     cfg->speaker_pins);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic void beep_power_hook(struct hda_beep *beep, bool on)\n{\n\tset_path_power(beep->codec, beep->nid, -1, on);\n}\n\n \nint snd_hda_gen_fix_pin_power(struct hda_codec *codec, hda_nid_t pin)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct nid_path *path;\n\n\tpath = snd_array_new(&spec->paths);\n\tif (!path)\n\t\treturn -ENOMEM;\n\tmemset(path, 0, sizeof(*path));\n\tpath->depth = 1;\n\tpath->path[0] = pin;\n\tpath->active = true;\n\tpath->pin_fixed = true;\n\tpath->stream_enabled = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_fix_pin_power);\n\n \n\n \nstatic bool detect_jacks(struct hda_codec *codec, int num_pins, const hda_nid_t *pins)\n{\n\tint i;\n\tbool present = false;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\thda_nid_t nid = pins[i];\n\t\tif (!nid)\n\t\t\tbreak;\n\t\t \n\t\tif (snd_hda_codec_get_pin_target(codec, nid) & AC_PINCTL_IN_EN)\n\t\t\tcontinue;\n\t\tif (snd_hda_jack_detect_state(codec, nid) == HDA_JACK_PRESENT)\n\t\t\tpresent = true;\n\t}\n\treturn present;\n}\n\n \nstatic void do_automute(struct hda_codec *codec, int num_pins, const hda_nid_t *pins,\n\t\t\tint *paths, bool mute)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\thda_nid_t nid = pins[i];\n\t\tunsigned int val, oldval;\n\t\tif (!nid)\n\t\t\tbreak;\n\n\t\toldval = snd_hda_codec_get_pin_target(codec, nid);\n\t\tif (oldval & PIN_IN)\n\t\t\tcontinue;  \n\n\t\tif (spec->auto_mute_via_amp) {\n\t\t\tstruct nid_path *path;\n\t\t\thda_nid_t mute_nid;\n\n\t\t\tpath = snd_hda_get_path_from_idx(codec, paths[i]);\n\t\t\tif (!path)\n\t\t\t\tcontinue;\n\t\t\tmute_nid = get_amp_nid_(path->ctls[NID_PATH_MUTE_CTL]);\n\t\t\tif (!mute_nid)\n\t\t\t\tcontinue;\n\t\t\tif (mute)\n\t\t\t\tspec->mute_bits |= (1ULL << mute_nid);\n\t\t\telse\n\t\t\t\tspec->mute_bits &= ~(1ULL << mute_nid);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (spec->keep_vref_in_automute)\n\t\t\t\tval = oldval & ~PIN_HP;\n\t\t\telse\n\t\t\t\tval = 0;\n\t\t\tif (!mute)\n\t\t\t\tval |= oldval;\n\t\t\t \n\t\t\tupdate_pin_ctl(codec, nid, val);\n\t\t}\n\n\t\tset_pin_eapd(codec, nid, !mute);\n\t\tif (codec->power_save_node) {\n\t\t\tbool on = !mute;\n\t\t\tif (on)\n\t\t\t\ton = detect_pin_state(codec, nid);\n\t\t\tset_path_power(codec, nid, on, -1);\n\t\t}\n\t}\n}\n\n \nvoid snd_hda_gen_update_outputs(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint *paths;\n\tint on;\n\n\t \n\tif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\n\t\tpaths = spec->out_paths;\n\telse\n\t\tpaths = spec->hp_paths;\n\tdo_automute(codec, ARRAY_SIZE(spec->autocfg.hp_pins),\n\t\t    spec->autocfg.hp_pins, paths, spec->master_mute);\n\n\tif (!spec->automute_speaker)\n\t\ton = 0;\n\telse\n\t\ton = spec->hp_jack_present | spec->line_jack_present;\n\ton |= spec->master_mute;\n\tspec->speaker_muted = on;\n\tif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\tpaths = spec->out_paths;\n\telse\n\t\tpaths = spec->speaker_paths;\n\tdo_automute(codec, ARRAY_SIZE(spec->autocfg.speaker_pins),\n\t\t    spec->autocfg.speaker_pins, paths, on);\n\n\t \n\t \n\tif (spec->autocfg.line_out_pins[0] == spec->autocfg.hp_pins[0] ||\n\t    spec->autocfg.line_out_pins[0] == spec->autocfg.speaker_pins[0])\n\t\treturn;\n\tif (!spec->automute_lo)\n\t\ton = 0;\n\telse\n\t\ton = spec->hp_jack_present;\n\ton |= spec->master_mute;\n\tspec->line_out_muted = on;\n\tpaths = spec->out_paths;\n\tdo_automute(codec, ARRAY_SIZE(spec->autocfg.line_out_pins),\n\t\t    spec->autocfg.line_out_pins, paths, on);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_update_outputs);\n\nstatic void call_update_outputs(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->automute_hook)\n\t\tspec->automute_hook(codec);\n\telse\n\t\tsnd_hda_gen_update_outputs(codec);\n\n\t \n\tif (spec->auto_mute_via_amp && !codec->bus->shutdown)\n\t\tsnd_ctl_sync_vmaster(spec->vmaster_mute.sw_kctl, false);\n}\n\n \nvoid snd_hda_gen_hp_automute(struct hda_codec *codec,\n\t\t\t     struct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t *pins = spec->autocfg.hp_pins;\n\tint num_pins = ARRAY_SIZE(spec->autocfg.hp_pins);\n\n\t \n\tif (spec->indep_hp_enabled) {\n\t\tpins++;\n\t\tnum_pins--;\n\t}\n\n\tspec->hp_jack_present = detect_jacks(codec, num_pins, pins);\n\tif (!spec->detect_hp || (!spec->automute_speaker && !spec->automute_lo))\n\t\treturn;\n\tcall_update_outputs(codec);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_hp_automute);\n\n \nvoid snd_hda_gen_line_automute(struct hda_codec *codec,\n\t\t\t       struct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\treturn;\n\t \n\tif (spec->autocfg.line_out_pins[0] == spec->autocfg.hp_pins[0])\n\t\treturn;\n\n\tspec->line_jack_present =\n\t\tdetect_jacks(codec, ARRAY_SIZE(spec->autocfg.line_out_pins),\n\t\t\t     spec->autocfg.line_out_pins);\n\tif (!spec->automute_speaker || !spec->detect_lo)\n\t\treturn;\n\tcall_update_outputs(codec);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_line_automute);\n\n \nvoid snd_hda_gen_mic_autoswitch(struct hda_codec *codec,\n\t\t\t\tstruct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tif (!spec->auto_mic)\n\t\treturn;\n\n\tfor (i = spec->am_num_entries - 1; i > 0; i--) {\n\t\thda_nid_t pin = spec->am_entry[i].pin;\n\t\t \n\t\tif (snd_hda_codec_get_pin_target(codec, pin) & AC_PINCTL_OUT_EN)\n\t\t\tcontinue;\n\t\tif (snd_hda_jack_detect_state(codec, pin) == HDA_JACK_PRESENT) {\n\t\t\tmux_select(codec, 0, spec->am_entry[i].idx);\n\t\t\treturn;\n\t\t}\n\t}\n\tmux_select(codec, 0, spec->am_entry[0].idx);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_mic_autoswitch);\n\n \nstatic void call_hp_automute(struct hda_codec *codec,\n\t\t\t     struct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->hp_automute_hook)\n\t\tspec->hp_automute_hook(codec, jack);\n\telse\n\t\tsnd_hda_gen_hp_automute(codec, jack);\n}\n\nstatic void call_line_automute(struct hda_codec *codec,\n\t\t\t       struct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->line_automute_hook)\n\t\tspec->line_automute_hook(codec, jack);\n\telse\n\t\tsnd_hda_gen_line_automute(codec, jack);\n}\n\nstatic void call_mic_autoswitch(struct hda_codec *codec,\n\t\t\t\tstruct hda_jack_callback *jack)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->mic_autoswitch_hook)\n\t\tspec->mic_autoswitch_hook(codec, jack);\n\telse\n\t\tsnd_hda_gen_mic_autoswitch(codec, jack);\n}\n\n \nstatic void update_automute_all(struct hda_codec *codec)\n{\n\tcall_hp_automute(codec, NULL);\n\tcall_line_automute(codec, NULL);\n\tcall_mic_autoswitch(codec, NULL);\n}\n\n \nstatic int automute_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstatic const char * const texts3[] = {\n\t\t\"Disabled\", \"Speaker Only\", \"Line Out+Speaker\"\n\t};\n\n\tif (spec->automute_speaker_possible && spec->automute_lo_possible)\n\t\treturn snd_hda_enum_helper_info(kcontrol, uinfo, 3, texts3);\n\treturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\n}\n\nstatic int automute_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\tunsigned int val = 0;\n\tif (spec->automute_speaker)\n\t\tval++;\n\tif (spec->automute_lo)\n\t\tval++;\n\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\nstatic int automute_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tswitch (ucontrol->value.enumerated.item[0]) {\n\tcase 0:\n\t\tif (!spec->automute_speaker && !spec->automute_lo)\n\t\t\treturn 0;\n\t\tspec->automute_speaker = 0;\n\t\tspec->automute_lo = 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (spec->automute_speaker_possible) {\n\t\t\tif (!spec->automute_lo && spec->automute_speaker)\n\t\t\t\treturn 0;\n\t\t\tspec->automute_speaker = 1;\n\t\t\tspec->automute_lo = 0;\n\t\t} else if (spec->automute_lo_possible) {\n\t\t\tif (spec->automute_lo)\n\t\t\t\treturn 0;\n\t\t\tspec->automute_lo = 1;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 2:\n\t\tif (!spec->automute_lo_possible || !spec->automute_speaker_possible)\n\t\t\treturn -EINVAL;\n\t\tif (spec->automute_speaker && spec->automute_lo)\n\t\t\treturn 0;\n\t\tspec->automute_speaker = 1;\n\t\tspec->automute_lo = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tcall_update_outputs(codec);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new automute_mode_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Auto-Mute Mode\",\n\t.info = automute_mode_info,\n\t.get = automute_mode_get,\n\t.put = automute_mode_put,\n};\n\nstatic int add_automute_mode_enum(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (!snd_hda_gen_add_kctl(spec, NULL, &automute_mode_enum))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic int check_auto_mute_availability(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint present = 0;\n\tint i, err;\n\n\tif (spec->suppress_auto_mute)\n\t\treturn 0;\n\n\tif (cfg->hp_pins[0])\n\t\tpresent++;\n\tif (cfg->line_out_pins[0])\n\t\tpresent++;\n\tif (cfg->speaker_pins[0])\n\t\tpresent++;\n\tif (present < 2)  \n\t\treturn 0;\n\n\tif (!cfg->speaker_pins[0] &&\n\t    cfg->line_out_type == AUTO_PIN_SPEAKER_OUT) {\n\t\tmemcpy(cfg->speaker_pins, cfg->line_out_pins,\n\t\t       sizeof(cfg->speaker_pins));\n\t\tcfg->speaker_outs = cfg->line_outs;\n\t}\n\n\tif (!cfg->hp_pins[0] &&\n\t    cfg->line_out_type == AUTO_PIN_HP_OUT) {\n\t\tmemcpy(cfg->hp_pins, cfg->line_out_pins,\n\t\t       sizeof(cfg->hp_pins));\n\t\tcfg->hp_outs = cfg->line_outs;\n\t}\n\n\tfor (i = 0; i < cfg->hp_outs; i++) {\n\t\thda_nid_t nid = cfg->hp_pins[i];\n\t\tif (!is_jack_detectable(codec, nid))\n\t\t\tcontinue;\n\t\tcodec_dbg(codec, \"Enable HP auto-muting on NID 0x%x\\n\", nid);\n\t\tsnd_hda_jack_detect_enable_callback(codec, nid,\n\t\t\t\t\t\t    call_hp_automute);\n\t\tspec->detect_hp = 1;\n\t}\n\n\tif (cfg->line_out_type == AUTO_PIN_LINE_OUT && cfg->line_outs) {\n\t\tif (cfg->speaker_outs)\n\t\t\tfor (i = 0; i < cfg->line_outs; i++) {\n\t\t\t\thda_nid_t nid = cfg->line_out_pins[i];\n\t\t\t\tif (!is_jack_detectable(codec, nid))\n\t\t\t\t\tcontinue;\n\t\t\t\tcodec_dbg(codec, \"Enable Line-Out auto-muting on NID 0x%x\\n\", nid);\n\t\t\t\tsnd_hda_jack_detect_enable_callback(codec, nid,\n\t\t\t\t\t\t\t\t    call_line_automute);\n\t\t\t\tspec->detect_lo = 1;\n\t\t\t}\n\t\tspec->automute_lo_possible = spec->detect_hp;\n\t}\n\n\tspec->automute_speaker_possible = cfg->speaker_outs &&\n\t\t(spec->detect_hp || spec->detect_lo);\n\n\tspec->automute_lo = spec->automute_lo_possible;\n\tspec->automute_speaker = spec->automute_speaker_possible;\n\n\tif (spec->automute_speaker_possible || spec->automute_lo_possible) {\n\t\t \n\t\terr = add_automute_mode_enum(codec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic bool auto_mic_check_imux(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tconst struct hda_input_mux *imux;\n\tint i;\n\n\timux = &spec->input_mux;\n\tfor (i = 0; i < spec->am_num_entries; i++) {\n\t\tspec->am_entry[i].idx =\n\t\t\tfind_idx_in_nid_list(spec->am_entry[i].pin,\n\t\t\t\t\t     spec->imux_pins, imux->num_items);\n\t\tif (spec->am_entry[i].idx < 0)\n\t\t\treturn false;  \n\t}\n\n\t \n\tfor (i = 1; i < spec->am_num_entries; i++)\n\t\tsnd_hda_jack_detect_enable_callback(codec,\n\t\t\t\t\t\t    spec->am_entry[i].pin,\n\t\t\t\t\t\t    call_mic_autoswitch);\n\treturn true;\n}\n\nstatic int compare_attr(const void *ap, const void *bp)\n{\n\tconst struct automic_entry *a = ap;\n\tconst struct automic_entry *b = bp;\n\treturn (int)(a->attr - b->attr);\n}\n\n \nstatic int check_auto_mic_availability(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tunsigned int types;\n\tint i, num_pins;\n\n\tif (spec->suppress_auto_mic)\n\t\treturn 0;\n\n\ttypes = 0;\n\tnum_pins = 0;\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\thda_nid_t nid = cfg->inputs[i].pin;\n\t\tunsigned int attr;\n\t\tattr = snd_hda_codec_get_pincfg(codec, nid);\n\t\tattr = snd_hda_get_input_pin_attr(attr);\n\t\tif (types & (1 << attr))\n\t\t\treturn 0;  \n\t\tswitch (attr) {\n\t\tcase INPUT_PIN_ATTR_INT:\n\t\t\tif (cfg->inputs[i].type != AUTO_PIN_MIC)\n\t\t\t\treturn 0;  \n\t\t\tbreak;\n\t\tcase INPUT_PIN_ATTR_UNUSED:\n\t\t\treturn 0;  \n\t\tdefault:\n\t\t\tif (cfg->inputs[i].type > AUTO_PIN_LINE_IN)\n\t\t\t\treturn 0;  \n\t\t\tif (!spec->line_in_auto_switch &&\n\t\t\t    cfg->inputs[i].type != AUTO_PIN_MIC)\n\t\t\t\treturn 0;  \n\t\t\tif (!is_jack_detectable(codec, nid))\n\t\t\t\treturn 0;  \n\t\t\tbreak;\n\t\t}\n\t\tif (num_pins >= MAX_AUTO_MIC_PINS)\n\t\t\treturn 0;\n\t\ttypes |= (1 << attr);\n\t\tspec->am_entry[num_pins].pin = nid;\n\t\tspec->am_entry[num_pins].attr = attr;\n\t\tnum_pins++;\n\t}\n\n\tif (num_pins < 2)\n\t\treturn 0;\n\n\tspec->am_num_entries = num_pins;\n\t \n\tsort(spec->am_entry, num_pins, sizeof(spec->am_entry[0]),\n\t     compare_attr, NULL);\n\n\tif (!auto_mic_check_imux(codec))\n\t\treturn 0;\n\n\tspec->auto_mic = 1;\n\tspec->num_adc_nids = 1;\n\tspec->cur_mux[0] = spec->am_entry[0].idx;\n\tcodec_dbg(codec, \"Enable auto-mic switch on NID 0x%x/0x%x/0x%x\\n\",\n\t\t    spec->am_entry[0].pin,\n\t\t    spec->am_entry[1].pin,\n\t\t    spec->am_entry[2].pin);\n\n\treturn 0;\n}\n\n \nunsigned int snd_hda_gen_path_power_filter(struct hda_codec *codec,\n\t\t\t\t\t\t  hda_nid_t nid,\n\t\t\t\t\t\t  unsigned int power_state)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (!spec->power_down_unused && !codec->power_save_node)\n\t\treturn power_state;\n\tif (power_state != AC_PWRST_D0 || nid == codec->core.afg)\n\t\treturn power_state;\n\tif (get_wcaps_type(get_wcaps(codec, nid)) >= AC_WID_POWER)\n\t\treturn power_state;\n\tif (is_active_nid_for_any(codec, nid))\n\t\treturn power_state;\n\treturn AC_PWRST_D3;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_path_power_filter);\n\n \nstatic void mute_all_mixer_nid(struct hda_codec *codec, hda_nid_t mix)\n{\n\tint i, nums;\n\tconst hda_nid_t *conn;\n\tbool has_amp;\n\n\tnums = snd_hda_get_conn_list(codec, mix, &conn);\n\thas_amp = nid_has_mute(codec, mix, HDA_INPUT);\n\tfor (i = 0; i < nums; i++) {\n\t\tif (has_amp)\n\t\t\tupdate_amp(codec, mix, HDA_INPUT, i,\n\t\t\t\t   0xff, HDA_AMP_MUTE);\n\t\telse if (nid_has_volume(codec, conn[i], HDA_OUTPUT))\n\t\t\tupdate_amp(codec, conn[i], HDA_OUTPUT, 0,\n\t\t\t\t   0xff, HDA_AMP_MUTE);\n\t}\n}\n\n \nvoid snd_hda_gen_stream_pm(struct hda_codec *codec, hda_nid_t nid, bool on)\n{\n\tif (codec->power_save_node)\n\t\tset_path_power(codec, nid, -1, on);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_stream_pm);\n\n \nint snd_hda_gen_parse_auto_config(struct hda_codec *codec,\n\t\t\t\t  struct auto_pin_cfg *cfg)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\tparse_user_hints(codec);\n\n\tif (spec->vmaster_mute_led || spec->mic_mute_led)\n\t\tsnd_ctl_led_request();\n\n\tif (spec->mixer_nid && !spec->mixer_merge_nid)\n\t\tspec->mixer_merge_nid = spec->mixer_nid;\n\n\tif (cfg != &spec->autocfg) {\n\t\tspec->autocfg = *cfg;\n\t\tcfg = &spec->autocfg;\n\t}\n\n\tif (!spec->main_out_badness)\n\t\tspec->main_out_badness = &hda_main_out_badness;\n\tif (!spec->extra_out_badness)\n\t\tspec->extra_out_badness = &hda_extra_out_badness;\n\n\tfill_all_dac_nids(codec);\n\n\tif (!cfg->line_outs) {\n\t\tif (cfg->dig_outs || cfg->dig_in_pin) {\n\t\t\tspec->multiout.max_channels = 2;\n\t\t\tspec->no_analog = 1;\n\t\t\tgoto dig_only;\n\t\t}\n\t\tif (!cfg->num_inputs && !cfg->dig_in_pin)\n\t\t\treturn 0;  \n\t}\n\n\tif (!spec->no_primary_hp &&\n\t    cfg->line_out_type == AUTO_PIN_SPEAKER_OUT &&\n\t    cfg->line_outs <= cfg->hp_outs) {\n\t\t \n\t\tcfg->speaker_outs = cfg->line_outs;\n\t\tmemcpy(cfg->speaker_pins, cfg->line_out_pins,\n\t\t       sizeof(cfg->speaker_pins));\n\t\tcfg->line_outs = cfg->hp_outs;\n\t\tmemcpy(cfg->line_out_pins, cfg->hp_pins, sizeof(cfg->hp_pins));\n\t\tcfg->hp_outs = 0;\n\t\tmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\n\t\tcfg->line_out_type = AUTO_PIN_HP_OUT;\n\t}\n\n\terr = parse_output_paths(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_multi_channel_mode(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_multi_out_ctls(codec, cfg);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_hp_out_ctls(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_speaker_out_ctls(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_indep_hp_ctls(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_loopback_mixing_ctl(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_hp_mic(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_input_ctls(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tadd_all_pin_power_ctls(codec, false);\n\n\tspec->const_channel_count = spec->ext_channel_count;\n\t \n\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\tspec->const_channel_count = max(spec->const_channel_count,\n\t\t\t\t\t\tcfg->speaker_outs * 2);\n\tif (cfg->line_out_type != AUTO_PIN_HP_OUT)\n\t\tspec->const_channel_count = max(spec->const_channel_count,\n\t\t\t\t\t\tcfg->hp_outs * 2);\n\tspec->multiout.max_channels = max(spec->ext_channel_count,\n\t\t\t\t\t  spec->const_channel_count);\n\n\terr = check_auto_mute_availability(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = check_dyn_adc_switch(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = check_auto_mic_availability(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!spec->auto_mic && spec->mixer_nid &&\n\t    spec->add_stereo_mix_input == HDA_HINT_STEREO_MIX_AUTO &&\n\t    spec->input_mux.num_items > 1) {\n\t\terr = parse_capture_source(codec, spec->mixer_nid,\n\t\t\t\t\t   CFG_IDX_MIX, spec->num_all_adcs,\n\t\t\t\t\t   \"Stereo Mix\", 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\n\terr = create_capture_mixers(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = parse_mic_boost(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (spec->hp_mic_pin &&\n\t    (spec->auto_mic || spec->input_mux.num_items == 1 ||\n\t     spec->add_jack_modes)) {\n\t\terr = create_hp_mic_jack_mode(codec, spec->hp_mic_pin);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (spec->add_jack_modes) {\n\t\tif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\n\t\t\terr = create_out_jack_modes(codec, cfg->line_outs,\n\t\t\t\t\t\t    cfg->line_out_pins);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\n\t\t\terr = create_out_jack_modes(codec, cfg->hp_outs,\n\t\t\t\t\t\t    cfg->hp_pins);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tadd_all_pin_power_ctls(codec, true);\n\n\t \n\tif (spec->mixer_nid)\n\t\tmute_all_mixer_nid(codec, spec->mixer_nid);\n\n dig_only:\n\tparse_digital(codec);\n\n\tif (spec->power_down_unused || codec->power_save_node) {\n\t\tif (!codec->power_filter)\n\t\t\tcodec->power_filter = snd_hda_gen_path_power_filter;\n\t\tif (!codec->patch_ops.stream_pm)\n\t\t\tcodec->patch_ops.stream_pm = snd_hda_gen_stream_pm;\n\t}\n\n\tif (!spec->no_analog && spec->beep_nid) {\n\t\terr = snd_hda_attach_beep_device(codec, spec->beep_nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (codec->beep && codec->power_save_node) {\n\t\t\terr = add_fake_beep_paths(codec);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tcodec->beep->power_hook = beep_power_hook;\n\t\t}\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_parse_auto_config);\n\n\n \n\n \nstatic const char * const follower_pfxs[] = {\n\t\"Front\", \"Surround\", \"Center\", \"LFE\", \"Side\",\n\t\"Headphone\", \"Speaker\", \"Mono\", \"Line Out\",\n\t\"CLFE\", \"Bass Speaker\", \"PCM\",\n\t\"Speaker Front\", \"Speaker Surround\", \"Speaker CLFE\", \"Speaker Side\",\n\t\"Headphone Front\", \"Headphone Surround\", \"Headphone CLFE\",\n\t\"Headphone Side\", \"Headphone+LO\", \"Speaker+LO\",\n\tNULL,\n};\n\n \nint snd_hda_gen_build_controls(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\tif (spec->kctls.used) {\n\t\terr = snd_hda_add_new_ctls(codec, spec->kctls.list);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (spec->multiout.dig_out_nid) {\n\t\terr = snd_hda_create_dig_out_ctls(codec,\n\t\t\t\t\t\t  spec->multiout.dig_out_nid,\n\t\t\t\t\t\t  spec->multiout.dig_out_nid,\n\t\t\t\t\t\t  spec->pcm_rec[1]->pcm_type);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!spec->no_analog) {\n\t\t\terr = snd_hda_create_spdif_share_sw(codec,\n\t\t\t\t\t\t\t    &spec->multiout);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tspec->multiout.share_spdif = 1;\n\t\t}\n\t}\n\tif (spec->dig_in_nid) {\n\t\terr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!spec->no_analog && !spec->suppress_vmaster &&\n\t    !snd_hda_find_mixer_ctl(codec, \"Master Playback Volume\")) {\n\t\terr = snd_hda_add_vmaster(codec, \"Master Playback Volume\",\n\t\t\t\t\t  spec->vmaster_tlv, follower_pfxs,\n\t\t\t\t\t  \"Playback Volume\", 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (!spec->no_analog && !spec->suppress_vmaster &&\n\t    !snd_hda_find_mixer_ctl(codec, \"Master Playback Switch\")) {\n\t\terr = __snd_hda_add_vmaster(codec, \"Master Playback Switch\",\n\t\t\t\t\t    NULL, follower_pfxs,\n\t\t\t\t\t    \"Playback Switch\", true,\n\t\t\t\t\t    spec->vmaster_mute_led ?\n\t\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_SPK_LED : 0,\n\t\t\t\t\t    &spec->vmaster_mute.sw_kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (spec->vmaster_mute.hook) {\n\t\t\tsnd_hda_add_vmaster_hook(codec, &spec->vmaster_mute);\n\t\t\tsnd_hda_sync_vmaster_hook(&spec->vmaster_mute);\n\t\t}\n\t}\n\n\tfree_kctls(spec);  \n\n\terr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_build_controls);\n\n\n \n\nstatic void call_pcm_playback_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   int action)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->pcm_playback_hook)\n\t\tspec->pcm_playback_hook(hinfo, codec, substream, action);\n}\n\nstatic void call_pcm_capture_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  int action)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tif (spec->pcm_capture_hook)\n\t\tspec->pcm_capture_hook(hinfo, codec, substream, action);\n}\n\n \nstatic int playback_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t     struct hda_codec *codec,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\tmutex_lock(&spec->pcm_mutex);\n\terr = snd_hda_multi_out_analog_open(codec,\n\t\t\t\t\t    &spec->multiout, substream,\n\t\t\t\t\t     hinfo);\n\tif (!err) {\n\t\tspec->active_streams |= 1 << STREAM_MULTI_OUT;\n\t\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t\t       HDA_GEN_PCM_ACT_OPEN);\n\t}\n\tmutex_unlock(&spec->pcm_mutex);\n\treturn err;\n}\n\nstatic int playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\tstruct hda_codec *codec,\n\t\t\t\tunsigned int stream_tag,\n\t\t\t\tunsigned int format,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\terr = snd_hda_multi_out_analog_prepare(codec, &spec->multiout,\n\t\t\t\t\t       stream_tag, format, substream);\n\tif (!err)\n\t\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t\t       HDA_GEN_PCM_ACT_PREPARE);\n\treturn err;\n}\n\nstatic int playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\tstruct hda_codec *codec,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err;\n\n\terr = snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\n\tif (!err)\n\t\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t\t       HDA_GEN_PCM_ACT_CLEANUP);\n\treturn err;\n}\n\nstatic int playback_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t      struct hda_codec *codec,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tmutex_lock(&spec->pcm_mutex);\n\tspec->active_streams &= ~(1 << STREAM_MULTI_OUT);\n\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t       HDA_GEN_PCM_ACT_CLOSE);\n\tmutex_unlock(&spec->pcm_mutex);\n\treturn 0;\n}\n\nstatic int capture_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t    struct hda_codec *codec,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tcall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_OPEN);\n\treturn 0;\n}\n\nstatic int capture_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t       struct hda_codec *codec,\n\t\t\t       unsigned int stream_tag,\n\t\t\t       unsigned int format,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\n\tcall_pcm_capture_hook(hinfo, codec, substream,\n\t\t\t      HDA_GEN_PCM_ACT_PREPARE);\n\treturn 0;\n}\n\nstatic int capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t       struct hda_codec *codec,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\n\tcall_pcm_capture_hook(hinfo, codec, substream,\n\t\t\t      HDA_GEN_PCM_ACT_CLEANUP);\n\treturn 0;\n}\n\nstatic int capture_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t     struct hda_codec *codec,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tcall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_CLOSE);\n\treturn 0;\n}\n\nstatic int alt_playback_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t\t struct hda_codec *codec,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint err = 0;\n\n\tmutex_lock(&spec->pcm_mutex);\n\tif (spec->indep_hp && !spec->indep_hp_enabled)\n\t\terr = -EBUSY;\n\telse\n\t\tspec->active_streams |= 1 << STREAM_INDEP_HP;\n\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t       HDA_GEN_PCM_ACT_OPEN);\n\tmutex_unlock(&spec->pcm_mutex);\n\treturn err;\n}\n\nstatic int alt_playback_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tmutex_lock(&spec->pcm_mutex);\n\tspec->active_streams &= ~(1 << STREAM_INDEP_HP);\n\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t       HDA_GEN_PCM_ACT_CLOSE);\n\tmutex_unlock(&spec->pcm_mutex);\n\treturn 0;\n}\n\nstatic int alt_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t    struct hda_codec *codec,\n\t\t\t\t    unsigned int stream_tag,\n\t\t\t\t    unsigned int format,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\n\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t       HDA_GEN_PCM_ACT_PREPARE);\n\treturn 0;\n}\n\nstatic int alt_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t    struct hda_codec *codec,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\n\tcall_pcm_playback_hook(hinfo, codec, substream,\n\t\t\t       HDA_GEN_PCM_ACT_CLEANUP);\n\treturn 0;\n}\n\n \nstatic int dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t\t struct hda_codec *codec,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\n}\n\nstatic int dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t    struct hda_codec *codec,\n\t\t\t\t    unsigned int stream_tag,\n\t\t\t\t    unsigned int format,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\n\t\t\t\t\t     stream_tag, format, substream);\n}\n\nstatic int dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t    struct hda_codec *codec,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_cleanup(codec, &spec->multiout);\n}\n\nstatic int dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\n}\n\n \n#define alt_capture_pcm_open\tcapture_pcm_open\n#define alt_capture_pcm_close\tcapture_pcm_close\n\nstatic int alt_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   unsigned int stream_tag,\n\t\t\t\t   unsigned int format,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tsnd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number + 1],\n\t\t\t\t   stream_tag, 0, format);\n\tcall_pcm_capture_hook(hinfo, codec, substream,\n\t\t\t      HDA_GEN_PCM_ACT_PREPARE);\n\treturn 0;\n}\n\nstatic int alt_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tsnd_hda_codec_cleanup_stream(codec,\n\t\t\t\t     spec->adc_nids[substream->number + 1]);\n\tcall_pcm_capture_hook(hinfo, codec, substream,\n\t\t\t      HDA_GEN_PCM_ACT_CLEANUP);\n\treturn 0;\n}\n\n \nstatic const struct hda_pcm_stream pcm_analog_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t \n\t.ops = {\n\t\t.open = playback_pcm_open,\n\t\t.close = playback_pcm_close,\n\t\t.prepare = playback_pcm_prepare,\n\t\t.cleanup = playback_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream pcm_analog_capture = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.ops = {\n\t\t.open = capture_pcm_open,\n\t\t.close = capture_pcm_close,\n\t\t.prepare = capture_pcm_prepare,\n\t\t.cleanup = capture_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream pcm_analog_alt_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.ops = {\n\t\t.open = alt_playback_pcm_open,\n\t\t.close = alt_playback_pcm_close,\n\t\t.prepare = alt_playback_pcm_prepare,\n\t\t.cleanup = alt_playback_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream pcm_analog_alt_capture = {\n\t.substreams = 2,  \n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.ops = {\n\t\t.open = alt_capture_pcm_open,\n\t\t.close = alt_capture_pcm_close,\n\t\t.prepare = alt_capture_pcm_prepare,\n\t\t.cleanup = alt_capture_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream pcm_digital_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.ops = {\n\t\t.open = dig_playback_pcm_open,\n\t\t.close = dig_playback_pcm_close,\n\t\t.prepare = dig_playback_pcm_prepare,\n\t\t.cleanup = dig_playback_pcm_cleanup\n\t},\n};\n\nstatic const struct hda_pcm_stream pcm_digital_capture = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n};\n\n \nstatic const struct hda_pcm_stream pcm_null_stream = {\n\t.substreams = 0,\n\t.channels_min = 0,\n\t.channels_max = 0,\n};\n\n \nstatic bool dyn_adc_pcm_resetup(struct hda_codec *codec, int cur)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\thda_nid_t new_adc = spec->adc_nids[spec->dyn_adc_idx[cur]];\n\n\tif (spec->cur_adc && spec->cur_adc != new_adc) {\n\t\t \n\t\t__snd_hda_codec_cleanup_stream(codec, spec->cur_adc, 1);\n\t\tspec->cur_adc = new_adc;\n\t\tsnd_hda_codec_setup_stream(codec, new_adc,\n\t\t\t\t\t   spec->cur_adc_stream_tag, 0,\n\t\t\t\t\t   spec->cur_adc_format);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int dyn_adc_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t       struct hda_codec *codec,\n\t\t\t\t       unsigned int stream_tag,\n\t\t\t\t       unsigned int format,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tspec->cur_adc = spec->adc_nids[spec->dyn_adc_idx[spec->cur_mux[0]]];\n\tspec->cur_adc_stream_tag = stream_tag;\n\tspec->cur_adc_format = format;\n\tsnd_hda_codec_setup_stream(codec, spec->cur_adc, stream_tag, 0, format);\n\tcall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_PREPARE);\n\treturn 0;\n}\n\nstatic int dyn_adc_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t       struct hda_codec *codec,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tsnd_hda_codec_cleanup_stream(codec, spec->cur_adc);\n\tspec->cur_adc = 0;\n\tcall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_CLEANUP);\n\treturn 0;\n}\n\nstatic const struct hda_pcm_stream dyn_adc_pcm_analog_capture = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.nid = 0,  \n\t.ops = {\n\t\t.prepare = dyn_adc_capture_pcm_prepare,\n\t\t.cleanup = dyn_adc_capture_pcm_cleanup\n\t},\n};\n\nstatic void fill_pcm_stream_name(char *str, size_t len, const char *sfx,\n\t\t\t\t const char *chip_name)\n{\n\tchar *p;\n\n\tif (*str)\n\t\treturn;\n\tstrscpy(str, chip_name, len);\n\n\t \n\tfor (p = strchr(str, ' '); p; p = strchr(p + 1, ' ')) {\n\t\tif (!isalnum(p[1])) {\n\t\t\t*p = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrlcat(str, sfx, len);\n}\n\n \nstatic void setup_pcm_stream(struct hda_pcm_stream *str,\n\t\t\t     const struct hda_pcm_stream *default_str,\n\t\t\t     const struct hda_pcm_stream *spec_str,\n\t\t\t     hda_nid_t nid)\n{\n\t*str = *default_str;\n\tif (nid)\n\t\tstr->nid = nid;\n\tif (spec_str) {\n\t\tif (spec_str->substreams)\n\t\t\tstr->substreams = spec_str->substreams;\n\t\tif (spec_str->channels_min)\n\t\t\tstr->channels_min = spec_str->channels_min;\n\t\tif (spec_str->channels_max)\n\t\t\tstr->channels_max = spec_str->channels_max;\n\t\tif (spec_str->rates)\n\t\t\tstr->rates = spec_str->rates;\n\t\tif (spec_str->formats)\n\t\t\tstr->formats = spec_str->formats;\n\t\tif (spec_str->maxbps)\n\t\t\tstr->maxbps = spec_str->maxbps;\n\t}\n}\n\n \nint snd_hda_gen_build_pcms(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_pcm *info;\n\tbool have_multi_adcs;\n\n\tif (spec->no_analog)\n\t\tgoto skip_analog;\n\n\tfill_pcm_stream_name(spec->stream_name_analog,\n\t\t\t     sizeof(spec->stream_name_analog),\n\t\t\t     \" Analog\", codec->core.chip_name);\n\tinfo = snd_hda_codec_pcm_new(codec, \"%s\", spec->stream_name_analog);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tspec->pcm_rec[0] = info;\n\n\tif (spec->multiout.num_dacs > 0) {\n\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t &pcm_analog_playback,\n\t\t\t\t spec->stream_analog_playback,\n\t\t\t\t spec->multiout.dac_nids[0]);\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\n\t\t\tspec->multiout.max_channels;\n\t\tif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT &&\n\t\t    spec->autocfg.line_outs == 2)\n\t\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].chmap =\n\t\t\t\tsnd_pcm_2_1_chmaps;\n\t}\n\tif (spec->num_adc_nids) {\n\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\n\t\t\t\t (spec->dyn_adc_switch ?\n\t\t\t\t  &dyn_adc_pcm_analog_capture : &pcm_analog_capture),\n\t\t\t\t spec->stream_analog_capture,\n\t\t\t\t spec->adc_nids[0]);\n\t}\n\n skip_analog:\n\t \n\tif (spec->multiout.dig_out_nid || spec->dig_in_nid) {\n\t\tfill_pcm_stream_name(spec->stream_name_digital,\n\t\t\t\t     sizeof(spec->stream_name_digital),\n\t\t\t\t     \" Digital\", codec->core.chip_name);\n\t\tinfo = snd_hda_codec_pcm_new(codec, \"%s\",\n\t\t\t\t\t     spec->stream_name_digital);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tcodec->follower_dig_outs = spec->multiout.follower_dig_outs;\n\t\tspec->pcm_rec[1] = info;\n\t\tif (spec->dig_out_type)\n\t\t\tinfo->pcm_type = spec->dig_out_type;\n\t\telse\n\t\t\tinfo->pcm_type = HDA_PCM_TYPE_SPDIF;\n\t\tif (spec->multiout.dig_out_nid)\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t\t &pcm_digital_playback,\n\t\t\t\t\t spec->stream_digital_playback,\n\t\t\t\t\t spec->multiout.dig_out_nid);\n\t\tif (spec->dig_in_nid)\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\n\t\t\t\t\t &pcm_digital_capture,\n\t\t\t\t\t spec->stream_digital_capture,\n\t\t\t\t\t spec->dig_in_nid);\n\t}\n\n\tif (spec->no_analog)\n\t\treturn 0;\n\n\t \n\thave_multi_adcs = (spec->num_adc_nids > 1) &&\n\t\t!spec->dyn_adc_switch && !spec->auto_mic;\n\t \n\tif (spec->alt_dac_nid || have_multi_adcs) {\n\t\tfill_pcm_stream_name(spec->stream_name_alt_analog,\n\t\t\t\t     sizeof(spec->stream_name_alt_analog),\n\t\t\t     \" Alt Analog\", codec->core.chip_name);\n\t\tinfo = snd_hda_codec_pcm_new(codec, \"%s\",\n\t\t\t\t\t     spec->stream_name_alt_analog);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tspec->pcm_rec[2] = info;\n\t\tif (spec->alt_dac_nid)\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t\t &pcm_analog_alt_playback,\n\t\t\t\t\t spec->stream_analog_alt_playback,\n\t\t\t\t\t spec->alt_dac_nid);\n\t\telse\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t\t &pcm_null_stream, NULL, 0);\n\t\tif (have_multi_adcs) {\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\n\t\t\t\t\t &pcm_analog_alt_capture,\n\t\t\t\t\t spec->stream_analog_alt_capture,\n\t\t\t\t\t spec->adc_nids[1]);\n\t\t\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams =\n\t\t\t\tspec->num_adc_nids - 1;\n\t\t} else {\n\t\t\tsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\n\t\t\t\t\t &pcm_null_stream, NULL, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_build_pcms);\n\n\n \n\n \nstatic void set_output_and_unmute(struct hda_codec *codec, int path_idx)\n{\n\tstruct nid_path *path;\n\thda_nid_t pin;\n\n\tpath = snd_hda_get_path_from_idx(codec, path_idx);\n\tif (!path || !path->depth)\n\t\treturn;\n\tpin = path->path[path->depth - 1];\n\trestore_pin_ctl(codec, pin);\n\tsnd_hda_activate_path(codec, path, path->active,\n\t\t\t      aamix_default(codec->spec));\n\tset_pin_eapd(codec, pin, path->active);\n}\n\n \nstatic void init_multi_out(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tfor (i = 0; i < spec->autocfg.line_outs; i++)\n\t\tset_output_and_unmute(codec, spec->out_paths[i]);\n}\n\n\nstatic void __init_extra_out(struct hda_codec *codec, int num_outs, int *paths)\n{\n\tint i;\n\n\tfor (i = 0; i < num_outs; i++)\n\t\tset_output_and_unmute(codec, paths[i]);\n}\n\n \nstatic void init_extra_out(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (spec->autocfg.line_out_type != AUTO_PIN_HP_OUT)\n\t\t__init_extra_out(codec, spec->autocfg.hp_outs, spec->hp_paths);\n\tif (spec->autocfg.line_out_type != AUTO_PIN_SPEAKER_OUT)\n\t\t__init_extra_out(codec, spec->autocfg.speaker_outs,\n\t\t\t\t spec->speaker_paths);\n}\n\n \nstatic void init_multi_io(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\n\tfor (i = 0; i < spec->multi_ios; i++) {\n\t\thda_nid_t pin = spec->multi_io[i].pin;\n\t\tstruct nid_path *path;\n\t\tpath = get_multiio_path(codec, i);\n\t\tif (!path)\n\t\t\tcontinue;\n\t\tif (!spec->multi_io[i].ctl_in)\n\t\t\tspec->multi_io[i].ctl_in =\n\t\t\t\tsnd_hda_codec_get_pin_target(codec, pin);\n\t\tsnd_hda_activate_path(codec, path, path->active,\n\t\t\t\t      aamix_default(spec));\n\t}\n}\n\nstatic void init_aamix_paths(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (!spec->have_aamix_ctl)\n\t\treturn;\n\tif (!has_aamix_out_paths(spec))\n\t\treturn;\n\tupdate_aamix_paths(codec, spec->aamix_mode, spec->out_paths[0],\n\t\t\t   spec->aamix_out_paths[0],\n\t\t\t   spec->autocfg.line_out_type);\n\tupdate_aamix_paths(codec, spec->aamix_mode, spec->hp_paths[0],\n\t\t\t   spec->aamix_out_paths[1],\n\t\t\t   AUTO_PIN_HP_OUT);\n\tupdate_aamix_paths(codec, spec->aamix_mode, spec->speaker_paths[0],\n\t\t\t   spec->aamix_out_paths[2],\n\t\t\t   AUTO_PIN_SPEAKER_OUT);\n}\n\n \nstatic void init_analog_input(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->autocfg;\n\tint i;\n\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\thda_nid_t nid = cfg->inputs[i].pin;\n\t\tif (is_input_pin(codec, nid))\n\t\t\trestore_pin_ctl(codec, nid);\n\n\t\t \n\t\tif (spec->mixer_nid) {\n\t\t\tresume_path_from_idx(codec, spec->loopback_paths[i]);\n\t\t\tresume_path_from_idx(codec, spec->loopback_merge_path);\n\t\t}\n\t}\n}\n\n \nstatic void init_input_src(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tstruct hda_input_mux *imux = &spec->input_mux;\n\tstruct nid_path *path;\n\tint i, c, nums;\n\n\tif (spec->dyn_adc_switch)\n\t\tnums = 1;\n\telse\n\t\tnums = spec->num_adc_nids;\n\n\tfor (c = 0; c < nums; c++) {\n\t\tfor (i = 0; i < imux->num_items; i++) {\n\t\t\tpath = get_input_path(codec, c, i);\n\t\t\tif (path) {\n\t\t\t\tbool active = path->active;\n\t\t\t\tif (i == spec->cur_mux[c])\n\t\t\t\t\tactive = true;\n\t\t\t\tsnd_hda_activate_path(codec, path, active, false);\n\t\t\t}\n\t\t}\n\t\tif (spec->hp_mic)\n\t\t\tupdate_hp_mic(codec, c, true);\n\t}\n\n\tif (spec->cap_sync_hook)\n\t\tspec->cap_sync_hook(codec, NULL, NULL);\n}\n\n \nstatic void init_digital(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\tint i;\n\thda_nid_t pin;\n\n\tfor (i = 0; i < spec->autocfg.dig_outs; i++)\n\t\tset_output_and_unmute(codec, spec->digout_paths[i]);\n\tpin = spec->autocfg.dig_in_pin;\n\tif (pin) {\n\t\trestore_pin_ctl(codec, pin);\n\t\tresume_path_from_idx(codec, spec->digin_path);\n\t}\n}\n\n \nstatic void clear_unsol_on_unused_pins(struct hda_codec *codec)\n{\n\tconst struct hda_pincfg *pin;\n\tint i;\n\n\tsnd_array_for_each(&codec->init_pins, i, pin) {\n\t\thda_nid_t nid = pin->nid;\n\t\tif (is_jack_detectable(codec, nid) &&\n\t\t    !snd_hda_jack_tbl_get(codec, nid))\n\t\t\tsnd_hda_codec_write_cache(codec, nid, 0,\n\t\t\t\t\tAC_VERB_SET_UNSOLICITED_ENABLE, 0);\n\t}\n}\n\n \nint snd_hda_gen_init(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\n\tif (spec->init_hook)\n\t\tspec->init_hook(codec);\n\n\tif (!spec->skip_verbs)\n\t\tsnd_hda_apply_verbs(codec);\n\n\tinit_multi_out(codec);\n\tinit_extra_out(codec);\n\tinit_multi_io(codec);\n\tinit_aamix_paths(codec);\n\tinit_analog_input(codec);\n\tinit_input_src(codec);\n\tinit_digital(codec);\n\n\tclear_unsol_on_unused_pins(codec);\n\n\tsync_all_pin_power_ctls(codec);\n\n\t \n\tupdate_automute_all(codec);\n\n\tsnd_hda_regmap_sync(codec);\n\n\tif (spec->vmaster_mute.sw_kctl && spec->vmaster_mute.hook)\n\t\tsnd_hda_sync_vmaster_hook(&spec->vmaster_mute);\n\n\thda_call_check_power_status(codec, 0x01);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_init);\n\n \nvoid snd_hda_gen_free(struct hda_codec *codec)\n{\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_FREE);\n\tsnd_hda_gen_spec_free(codec->spec);\n\tkfree(codec->spec);\n\tcodec->spec = NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_free);\n\n#ifdef CONFIG_PM\n \nint snd_hda_gen_check_power_status(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_gen_spec *spec = codec->spec;\n\treturn snd_hda_check_amp_list_power(codec, &spec->loopback, nid);\n}\nEXPORT_SYMBOL_GPL(snd_hda_gen_check_power_status);\n#endif\n\n\n \n\nstatic const struct hda_codec_ops generic_patch_ops = {\n\t.build_controls = snd_hda_gen_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = snd_hda_gen_init,\n\t.free = snd_hda_gen_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.check_power_status = snd_hda_gen_check_power_status,\n#endif\n};\n\n \nstatic int snd_hda_parse_generic_codec(struct hda_codec *codec)\n{\n\tstruct hda_gen_spec *spec;\n\tint err;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tsnd_hda_gen_spec_init(spec);\n\tcodec->spec = spec;\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->autocfg, NULL, 0);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->autocfg);\n\tif (err < 0)\n\t\tgoto error;\n\n\tcodec->patch_ops = generic_patch_ops;\n\treturn 0;\n\nerror:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\nstatic const struct hda_device_id snd_hda_id_generic[] = {\n\tHDA_CODEC_ENTRY(HDA_CODEC_ID_GENERIC, \"Generic\", snd_hda_parse_generic_codec),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_generic);\n\nstatic struct hda_codec_driver generic_driver = {\n\t.id = snd_hda_id_generic,\n};\n\nmodule_hda_codec_driver(generic_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Generic HD-audio codec parser\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}