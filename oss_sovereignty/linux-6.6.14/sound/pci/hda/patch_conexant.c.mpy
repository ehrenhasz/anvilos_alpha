{
  "module_name": "patch_conexant.c",
  "hash_id": "21993279d7ab372fcb5e88cbe675df73b3b0d53162e19abaeed5dada0db6803f",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_conexant.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_beep.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n\nstruct conexant_spec {\n\tstruct hda_gen_spec gen;\n\n\t \n\tunsigned int num_eapds;\n\thda_nid_t eapds[4];\n\tbool dynamic_eapd;\n\thda_nid_t mute_led_eapd;\n\n\tunsigned int parse_flags;  \n\n\t \n\tbool recording;\n\tbool dc_enable;\n\tunsigned int dc_input_bias;  \n\tstruct nid_path *dc_mode_path;\n\n\tint mute_led_polarity;\n\tunsigned int gpio_led;\n\tunsigned int gpio_mute_led_mask;\n\tunsigned int gpio_mic_led_mask;\n\n};\n\n\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\n \nstatic const struct snd_kcontrol_new cxt_beep_mixer[] = {\n\tHDA_CODEC_VOLUME_MONO(\"Beep Playback Volume\", 0, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_BEEP_MONO(\"Beep Playback Switch\", 0, 1, 0, HDA_OUTPUT),\n};\n\nstatic int set_beep_amp(struct conexant_spec *spec, hda_nid_t nid,\n\t\t\tint idx, int dir)\n{\n\tstruct snd_kcontrol_new *knew;\n\tunsigned int beep_amp = HDA_COMPOSE_AMP_VAL(nid, 1, idx, dir);\n\tint i;\n\n\tspec->gen.beep_nid = nid;\n\tfor (i = 0; i < ARRAY_SIZE(cxt_beep_mixer); i++) {\n\t\tknew = snd_hda_gen_add_kctl(&spec->gen, NULL,\n\t\t\t\t\t    &cxt_beep_mixer[i]);\n\t\tif (!knew)\n\t\t\treturn -ENOMEM;\n\t\tknew->private_value = beep_amp;\n\t}\n\treturn 0;\n}\n\nstatic int cx_auto_parse_beep(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\thda_nid_t nid;\n\n\tfor_each_hda_codec_node(nid, codec)\n\t\tif (get_wcaps_type(get_wcaps(codec, nid)) == AC_WID_BEEP)\n\t\t\treturn set_beep_amp(spec, nid, 0, HDA_OUTPUT);\n\treturn 0;\n}\n#else\n#define cx_auto_parse_beep(codec)\t0\n#endif\n\n \n\n \nstatic void cx_auto_parse_eapd(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\thda_nid_t nid;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\n\t\t\tcontinue;\n\t\tif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD))\n\t\t\tcontinue;\n\t\tspec->eapds[spec->num_eapds++] = nid;\n\t\tif (spec->num_eapds >= ARRAY_SIZE(spec->eapds))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (spec->num_eapds > 2)\n\t\tspec->dynamic_eapd = 1;\n}\n\nstatic void cx_auto_turn_eapd(struct hda_codec *codec, int num_pins,\n\t\t\t      const hda_nid_t *pins, bool on)\n{\n\tint i;\n\tfor (i = 0; i < num_pins; i++) {\n\t\tif (snd_hda_query_pin_caps(codec, pins[i]) & AC_PINCAP_EAPD)\n\t\t\tsnd_hda_codec_write(codec, pins[i], 0,\n\t\t\t\t\t    AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t\t\t    on ? 0x02 : 0);\n\t}\n}\n\n \nstatic void cx_auto_vmaster_hook(void *private_data, int enabled)\n{\n\tstruct hda_codec *codec = private_data;\n\tstruct conexant_spec *spec = codec->spec;\n\n\tcx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, enabled);\n}\n\n \nstatic int cx_auto_vmaster_mute_led(struct led_classdev *led_cdev,\n\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(led_cdev->dev->parent);\n\tstruct conexant_spec *spec = codec->spec;\n\n\tsnd_hda_codec_write(codec, spec->mute_led_eapd, 0,\n\t\t\t    AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t    brightness ? 0x02 : 0x00);\n\treturn 0;\n}\n\nstatic void cxt_init_gpio_led(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tunsigned int mask = spec->gpio_mute_led_mask | spec->gpio_mic_led_mask;\n\n\tif (mask) {\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\n\t\t\t\t    mask);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\n\t\t\t\t    mask);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\t\t    spec->gpio_led);\n\t}\n}\n\nstatic int cx_auto_init(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tsnd_hda_gen_init(codec);\n\tif (!spec->dynamic_eapd)\n\t\tcx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, true);\n\n\tcxt_init_gpio_led(codec);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_INIT);\n\n\treturn 0;\n}\n\nstatic void cx_auto_shutdown(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\t \n\tcx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, false);\n}\n\nstatic void cx_auto_free(struct hda_codec *codec)\n{\n\tcx_auto_shutdown(codec);\n\tsnd_hda_gen_free(codec);\n}\n\n#ifdef CONFIG_PM\nstatic int cx_auto_suspend(struct hda_codec *codec)\n{\n\tcx_auto_shutdown(codec);\n\treturn 0;\n}\n#endif\n\nstatic const struct hda_codec_ops cx_auto_patch_ops = {\n\t.build_controls = snd_hda_gen_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = cx_auto_init,\n\t.free = cx_auto_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = cx_auto_suspend,\n\t.check_power_status = snd_hda_gen_check_power_status,\n#endif\n};\n\n \nenum {\n\tCXT_PINCFG_LENOVO_X200,\n\tCXT_PINCFG_LENOVO_TP410,\n\tCXT_PINCFG_LEMOTE_A1004,\n\tCXT_PINCFG_LEMOTE_A1205,\n\tCXT_PINCFG_COMPAQ_CQ60,\n\tCXT_FIXUP_STEREO_DMIC,\n\tCXT_PINCFG_LENOVO_NOTEBOOK,\n\tCXT_FIXUP_INC_MIC_BOOST,\n\tCXT_FIXUP_HEADPHONE_MIC_PIN,\n\tCXT_FIXUP_HEADPHONE_MIC,\n\tCXT_FIXUP_GPIO1,\n\tCXT_FIXUP_ASPIRE_DMIC,\n\tCXT_FIXUP_THINKPAD_ACPI,\n\tCXT_FIXUP_OLPC_XO,\n\tCXT_FIXUP_CAP_MIX_AMP,\n\tCXT_FIXUP_TOSHIBA_P105,\n\tCXT_FIXUP_HP_530,\n\tCXT_FIXUP_CAP_MIX_AMP_5047,\n\tCXT_FIXUP_MUTE_LED_EAPD,\n\tCXT_FIXUP_HP_DOCK,\n\tCXT_FIXUP_HP_SPECTRE,\n\tCXT_FIXUP_HP_GATE_MIC,\n\tCXT_FIXUP_MUTE_LED_GPIO,\n\tCXT_FIXUP_HP_ZBOOK_MUTE_LED,\n\tCXT_FIXUP_HEADSET_MIC,\n\tCXT_FIXUP_HP_MIC_NO_PRESENCE,\n};\n\n \n#include \"thinkpad_helper.c\"\n\nstatic void cxt_fixup_stereo_dmic(struct hda_codec *codec,\n\t\t\t\t  const struct hda_fixup *fix, int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tspec->gen.inv_dmic_split = 1;\n}\n\nstatic void cxt5066_increase_mic_boost(struct hda_codec *codec,\n\t\t\t\t   const struct hda_fixup *fix, int action)\n{\n\tif (action != HDA_FIXUP_ACT_PRE_PROBE)\n\t\treturn;\n\n\tsnd_hda_override_amp_caps(codec, 0x17, HDA_OUTPUT,\n\t\t\t\t  (0x3 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t  (0x4 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t  (0x27 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t  (0 << AC_AMPCAP_MUTE_SHIFT));\n}\n\nstatic void cxt_update_headset_mode(struct hda_codec *codec)\n{\n\t \n\tint i;\n\tbool mic_mode = false;\n\tstruct conexant_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\n\n\thda_nid_t mux_pin = spec->gen.imux_pins[spec->gen.cur_mux[0]];\n\n\tfor (i = 0; i < cfg->num_inputs; i++)\n\t\tif (cfg->inputs[i].pin == mux_pin) {\n\t\t\tmic_mode = !!cfg->inputs[i].is_headphone_mic;\n\t\t\tbreak;\n\t\t}\n\n\tif (mic_mode) {\n\t\tsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x7c);  \n\t\tspec->gen.hp_jack_present = false;\n\t} else {\n\t\tsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x54);  \n\t\tspec->gen.hp_jack_present = snd_hda_jack_detect(codec, spec->gen.autocfg.hp_pins[0]);\n\t}\n\n\tsnd_hda_gen_update_outputs(codec);\n}\n\nstatic void cxt_update_headset_mode_hook(struct hda_codec *codec,\n\t\t\t\t\t struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tcxt_update_headset_mode(codec);\n}\n\nstatic void cxt_fixup_headphone_mic(struct hda_codec *codec,\n\t\t\t\t    const struct hda_fixup *fix, int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\tswitch (action) {\n\tcase HDA_FIXUP_ACT_PRE_PROBE:\n\t\tspec->parse_flags |= HDA_PINCFG_HEADPHONE_MIC;\n\t\tsnd_hdac_regmap_add_vendor_verb(&codec->core, 0x410);\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_PROBE:\n\t\tWARN_ON(spec->gen.cap_sync_hook);\n\t\tspec->gen.cap_sync_hook = cxt_update_headset_mode_hook;\n\t\tspec->gen.automute_hook = cxt_update_headset_mode;\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_INIT:\n\t\tcxt_update_headset_mode(codec);\n\t\tbreak;\n\t}\n}\n\nstatic void cxt_fixup_headset_mic(struct hda_codec *codec,\n\t\t\t\t    const struct hda_fixup *fix, int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\tswitch (action) {\n\tcase HDA_FIXUP_ACT_PRE_PROBE:\n\t\tspec->parse_flags |= HDA_PINCFG_HEADSET_MIC;\n\t\tbreak;\n\t}\n}\n\n \n\n \n\n#define update_mic_pin(codec, nid, val)\t\t\t\t\t\\\n\tsnd_hda_codec_write_cache(codec, nid, 0,\t\t\t\\\n\t\t\t\t   AC_VERB_SET_PIN_WIDGET_CONTROL, val)\n\nstatic const struct hda_input_mux olpc_xo_dc_bias = {\n\t.num_items = 3,\n\t.items = {\n\t\t{ \"Off\", PIN_IN },\n\t\t{ \"50%\", PIN_VREF50 },\n\t\t{ \"80%\", PIN_VREF80 },\n\t},\n};\n\nstatic void olpc_xo_update_mic_boost(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tint ch, val;\n\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tval = AC_AMP_SET_OUTPUT |\n\t\t\t(ch ? AC_AMP_SET_RIGHT : AC_AMP_SET_LEFT);\n\t\tif (!spec->dc_enable)\n\t\t\tval |= snd_hda_codec_amp_read(codec, 0x17, ch, HDA_OUTPUT, 0);\n\t\tsnd_hda_codec_write(codec, 0x17, 0,\n\t\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE, val);\n\t}\n}\n\nstatic void olpc_xo_update_mic_pins(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tint cur_input, val;\n\tstruct nid_path *path;\n\n\tcur_input = spec->gen.input_paths[0][spec->gen.cur_mux[0]];\n\n\t \n\tif (!spec->dc_enable) {\n\t\t \n\t\tupdate_mic_pin(codec, 0x1e, 0);\n\t\tsnd_hda_activate_path(codec, spec->dc_mode_path, false, false);\n\n\t\t \n\t\t \n\t\tupdate_mic_pin(codec, 0x1a, spec->recording ?\n\t\t\t       snd_hda_codec_get_pin_target(codec, 0x1a) : 0);\n\t\tupdate_mic_pin(codec, 0x1b, spec->recording ?\n\t\t\t       snd_hda_codec_get_pin_target(codec, 0x1b) : 0);\n\t\t \n\t\tpath = snd_hda_get_path_from_idx(codec, cur_input);\n\t\tif (path)\n\t\t\tsnd_hda_activate_path(codec, path, true, false);\n\t} else {\n\t\t \n\t\tpath = snd_hda_get_path_from_idx(codec, cur_input);\n\t\tif (path)\n\t\t\tsnd_hda_activate_path(codec, path, false, false);\n\n\t\t \n\t\tif (spec->recording)\n\t\t\tval = olpc_xo_dc_bias.items[spec->dc_input_bias].index;\n\t\telse\n\t\t\tval = 0;\n\t\tupdate_mic_pin(codec, 0x1a, val);\n\t\tupdate_mic_pin(codec, 0x1b, 0);\n\t\t \n\t\tupdate_mic_pin(codec, 0x1e, spec->recording ? PIN_IN : 0);\n\t\tsnd_hda_activate_path(codec, spec->dc_mode_path, true, false);\n\t}\n}\n\n \nstatic void olpc_xo_automic(struct hda_codec *codec,\n\t\t\t    struct hda_jack_callback *jack)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\t \n\tif (!spec->dc_enable)\n\t\tsnd_hda_gen_mic_autoswitch(codec, jack);\n\tolpc_xo_update_mic_pins(codec);\n\tif (spec->dc_enable)\n\t\tolpc_xo_update_mic_boost(codec);\n}\n\n \nstatic void olpc_xo_capture_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t struct hda_codec *codec,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\t \n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tspec->recording = 1;\n\t\tolpc_xo_update_mic_pins(codec);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tspec->recording = 0;\n\t\tolpc_xo_update_mic_pins(codec);\n\t\tbreak;\n\t}\n}\n\nstatic int olpc_xo_dc_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct conexant_spec *spec = codec->spec;\n\tucontrol->value.integer.value[0] = spec->dc_enable;\n\treturn 0;\n}\n\nstatic int olpc_xo_dc_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct conexant_spec *spec = codec->spec;\n\tint dc_enable = !!ucontrol->value.integer.value[0];\n\n\tif (dc_enable == spec->dc_enable)\n\t\treturn 0;\n\n\tspec->dc_enable = dc_enable;\n\tolpc_xo_update_mic_pins(codec);\n\tolpc_xo_update_mic_boost(codec);\n\treturn 1;\n}\n\nstatic int olpc_xo_dc_bias_enum_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct conexant_spec *spec = codec->spec;\n\tucontrol->value.enumerated.item[0] = spec->dc_input_bias;\n\treturn 0;\n}\n\nstatic int olpc_xo_dc_bias_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_hda_input_mux_info(&olpc_xo_dc_bias, uinfo);\n}\n\nstatic int olpc_xo_dc_bias_enum_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct conexant_spec *spec = codec->spec;\n\tconst struct hda_input_mux *imux = &olpc_xo_dc_bias;\n\tunsigned int idx;\n\n\tidx = ucontrol->value.enumerated.item[0];\n\tif (idx >= imux->num_items)\n\t\tidx = imux->num_items - 1;\n\tif (spec->dc_input_bias == idx)\n\t\treturn 0;\n\n\tspec->dc_input_bias = idx;\n\tif (spec->dc_enable)\n\t\tolpc_xo_update_mic_pins(codec);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new olpc_xo_mixers[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"DC Mode Enable Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = olpc_xo_dc_mode_get,\n\t\t.put = olpc_xo_dc_mode_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"DC Input Bias Enum\",\n\t\t.info = olpc_xo_dc_bias_enum_info,\n\t\t.get = olpc_xo_dc_bias_enum_get,\n\t\t.put = olpc_xo_dc_bias_enum_put,\n\t},\n\t{}\n};\n\n \nstatic int olpc_xo_mic_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct conexant_spec *spec = codec->spec;\n\tint ret = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\n\tif (ret > 0 && spec->dc_enable)\n\t\tolpc_xo_update_mic_boost(codec);\n\treturn ret;\n}\n\nstatic void cxt_fixup_olpc_xo(struct hda_codec *codec,\n\t\t\t\t    const struct hda_fixup *fix, int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tstruct snd_kcontrol_new *kctl;\n\tint i;\n\n\tif (action != HDA_FIXUP_ACT_PROBE)\n\t\treturn;\n\n\tspec->gen.mic_autoswitch_hook = olpc_xo_automic;\n\tspec->gen.pcm_capture_hook = olpc_xo_capture_hook;\n\tspec->dc_mode_path = snd_hda_add_new_path(codec, 0x1e, 0x14, 0);\n\n\tsnd_hda_add_new_ctls(codec, olpc_xo_mixers);\n\n\t \n\tsnd_hda_codec_set_pin_target(codec, 0x1a, PIN_VREF50);\n\n\t \n\tsnd_array_for_each(&spec->gen.kctls, i, kctl) {\n\t\tif (!strcmp(kctl->name, \"Mic Boost Volume\")) {\n\t\t\tkctl->put = olpc_xo_mic_boost_put;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void cxt_fixup_mute_led_eapd(struct hda_codec *codec,\n\t\t\t\t    const struct hda_fixup *fix, int action)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tspec->mute_led_eapd = 0x1b;\n\t\tspec->dynamic_eapd = true;\n\t\tsnd_hda_gen_add_mute_led_cdev(codec, cx_auto_vmaster_mute_led);\n\t}\n}\n\n \nstatic void cxt_fixup_cap_mix_amp(struct hda_codec *codec,\n\t\t\t\t  const struct hda_fixup *fix, int action)\n{\n\tsnd_hda_override_amp_caps(codec, 0x17, HDA_INPUT,\n\t\t\t\t  (0x14 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t  (0x14 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t  (0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t  (1 << AC_AMPCAP_MUTE_SHIFT));\n}\n\n \nstatic void cxt_fixup_cap_mix_amp_5047(struct hda_codec *codec,\n\t\t\t\t  const struct hda_fixup *fix, int action)\n{\n\tsnd_hda_override_amp_caps(codec, 0x10, HDA_INPUT,\n\t\t\t\t  (0x17 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t  (0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t  (0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t  (1 << AC_AMPCAP_MUTE_SHIFT));\n}\n\nstatic void cxt_fixup_hp_gate_mic_jack(struct hda_codec *codec,\n\t\t\t\t       const struct hda_fixup *fix,\n\t\t\t\t       int action)\n{\n\t \n\tif (action == HDA_FIXUP_ACT_PROBE)\n\t\tsnd_hda_jack_set_gating_jack(codec, 0x19, 0x16);\n}\n\n \nstatic void cxt_update_gpio_led(struct hda_codec *codec, unsigned int mask,\n\t\t\t\tbool led_on)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tunsigned int oldval = spec->gpio_led;\n\n\tif (spec->mute_led_polarity)\n\t\tled_on = !led_on;\n\n\tif (led_on)\n\t\tspec->gpio_led |= mask;\n\telse\n\t\tspec->gpio_led &= ~mask;\n\tcodec_dbg(codec, \"mask:%d enabled:%d gpio_led:%d\\n\",\n\t\t\tmask, led_on, spec->gpio_led);\n\tif (spec->gpio_led != oldval)\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\t\t    spec->gpio_led);\n}\n\n \nstatic int cxt_gpio_mute_update(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brightness)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(led_cdev->dev->parent);\n\tstruct conexant_spec *spec = codec->spec;\n\n\tcxt_update_gpio_led(codec, spec->gpio_mute_led_mask, brightness);\n\treturn 0;\n}\n\n \nstatic int cxt_gpio_micmute_update(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(led_cdev->dev->parent);\n\tstruct conexant_spec *spec = codec->spec;\n\n\tcxt_update_gpio_led(codec, spec->gpio_mic_led_mask, brightness);\n\treturn 0;\n}\n\nstatic void cxt_setup_mute_led(struct hda_codec *codec,\n\t\t\t       unsigned int mute, unsigned int mic_mute)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\n\tspec->gpio_led = 0;\n\tspec->mute_led_polarity = 0;\n\tif (mute) {\n\t\tsnd_hda_gen_add_mute_led_cdev(codec, cxt_gpio_mute_update);\n\t\tspec->gpio_mute_led_mask = mute;\n\t}\n\tif (mic_mute) {\n\t\tsnd_hda_gen_add_micmute_led_cdev(codec, cxt_gpio_micmute_update);\n\t\tspec->gpio_mic_led_mask = mic_mute;\n\t}\n}\n\nstatic void cxt_fixup_mute_led_gpio(struct hda_codec *codec,\n\t\t\t\tconst struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tcxt_setup_mute_led(codec, 0x01, 0x02);\n}\n\nstatic void cxt_fixup_hp_zbook_mute_led(struct hda_codec *codec,\n\t\t\t\t\tconst struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tcxt_setup_mute_led(codec, 0x10, 0x20);\n}\n\n \nstatic const struct hda_pintbl cxt_pincfg_lenovo_x200[] = {\n\t{ 0x16, 0x042140ff },  \n\t{ 0x17, 0x21a11000 },  \n\t{ 0x19, 0x2121103f },  \n\t{ 0x1c, 0x21440100 },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl cxt_pincfg_lenovo_tp410[] = {\n\t{ 0x19, 0x042110ff },  \n\t{ 0x1a, 0x21a190f0 },  \n\t{ 0x1c, 0x212140ff },  \n\t{}\n};\n\n \nstatic const struct hda_pintbl cxt_pincfg_lemote[] = {\n\t{ 0x1a, 0x90a10020 },  \n\t{ 0x1b, 0x03a11020 },  \n\t{ 0x1d, 0x400101f0 },  \n\t{ 0x1e, 0x40a701f0 },  \n\t{ 0x20, 0x404501f0 },  \n\t{ 0x22, 0x404401f0 },  \n\t{ 0x23, 0x40a701f0 },  \n\t{}\n};\n\nstatic const struct hda_fixup cxt_fixups[] = {\n\t[CXT_PINCFG_LENOVO_X200] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = cxt_pincfg_lenovo_x200,\n\t},\n\t[CXT_PINCFG_LENOVO_TP410] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = cxt_pincfg_lenovo_tp410,\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_THINKPAD_ACPI,\n\t},\n\t[CXT_PINCFG_LEMOTE_A1004] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_INC_MIC_BOOST,\n\t\t.v.pins = cxt_pincfg_lemote,\n\t},\n\t[CXT_PINCFG_LEMOTE_A1205] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = cxt_pincfg_lemote,\n\t},\n\t[CXT_PINCFG_COMPAQ_CQ60] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t \n\t\t\t{ 0x17, 0x400001f0 },\n\t\t\t{ 0x1d, 0x97a70120 },\n\t\t\t{ }\n\t\t}\n\t},\n\t[CXT_FIXUP_STEREO_DMIC] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_stereo_dmic,\n\t},\n\t[CXT_PINCFG_LENOVO_NOTEBOOK] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1a, 0x05d71030 },\n\t\t\t{ }\n\t\t},\n\t\t.chain_id = CXT_FIXUP_STEREO_DMIC,\n\t},\n\t[CXT_FIXUP_INC_MIC_BOOST] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt5066_increase_mic_boost,\n\t},\n\t[CXT_FIXUP_HEADPHONE_MIC_PIN] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_HEADPHONE_MIC,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x18, 0x03a1913d },  \n\t\t\t{ }\n\t\t}\n\t},\n\t[CXT_FIXUP_HEADPHONE_MIC] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_headphone_mic,\n\t},\n\t[CXT_FIXUP_GPIO1] = {\n\t\t.type = HDA_FIXUP_VERBS,\n\t\t.v.verbs = (const struct hda_verb[]) {\n\t\t\t{ 0x01, AC_VERB_SET_GPIO_MASK, 0x01 },\n\t\t\t{ 0x01, AC_VERB_SET_GPIO_DIRECTION, 0x01 },\n\t\t\t{ 0x01, AC_VERB_SET_GPIO_DATA, 0x01 },\n\t\t\t{ }\n\t\t},\n\t},\n\t[CXT_FIXUP_ASPIRE_DMIC] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_stereo_dmic,\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_GPIO1,\n\t},\n\t[CXT_FIXUP_THINKPAD_ACPI] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = hda_fixup_thinkpad_acpi,\n\t},\n\t[CXT_FIXUP_OLPC_XO] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_olpc_xo,\n\t},\n\t[CXT_FIXUP_CAP_MIX_AMP] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_cap_mix_amp,\n\t},\n\t[CXT_FIXUP_TOSHIBA_P105] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x10, 0x961701f0 },  \n\t\t\t{ 0x12, 0x02a1901e },  \n\t\t\t{ 0x14, 0x95a70110 },  \n\t\t\t{}\n\t\t},\n\t},\n\t[CXT_FIXUP_HP_530] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x12, 0x90a60160 },  \n\t\t\t{}\n\t\t},\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_CAP_MIX_AMP,\n\t},\n\t[CXT_FIXUP_CAP_MIX_AMP_5047] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_cap_mix_amp_5047,\n\t},\n\t[CXT_FIXUP_MUTE_LED_EAPD] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_mute_led_eapd,\n\t},\n\t[CXT_FIXUP_HP_DOCK] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x16, 0x21011020 },  \n\t\t\t{ 0x18, 0x2181103f },  \n\t\t\t{ }\n\t\t},\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_MUTE_LED_GPIO,\n\t},\n\t[CXT_FIXUP_HP_SPECTRE] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t \n\t\t\t{ 0x1d, 0x91170111 },\n\t\t\t{ }\n\t\t}\n\t},\n\t[CXT_FIXUP_HP_GATE_MIC] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_hp_gate_mic_jack,\n\t},\n\t[CXT_FIXUP_MUTE_LED_GPIO] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_mute_led_gpio,\n\t},\n\t[CXT_FIXUP_HP_ZBOOK_MUTE_LED] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_hp_zbook_mute_led,\n\t},\n\t[CXT_FIXUP_HEADSET_MIC] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cxt_fixup_headset_mic,\n\t},\n\t[CXT_FIXUP_HP_MIC_NO_PRESENCE] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1a, 0x02a1113c },\n\t\t\t{ }\n\t\t},\n\t\t.chained = true,\n\t\t.chain_id = CXT_FIXUP_HEADSET_MIC,\n\t},\n};\n\nstatic const struct snd_pci_quirk cxt5045_fixups[] = {\n\tSND_PCI_QUIRK(0x103c, 0x30d5, \"HP 530\", CXT_FIXUP_HP_530),\n\tSND_PCI_QUIRK(0x1179, 0xff31, \"Toshiba P105\", CXT_FIXUP_TOSHIBA_P105),\n\t \n\tSND_PCI_QUIRK_VENDOR(0x103c, \"HP\", CXT_FIXUP_CAP_MIX_AMP),\n\tSND_PCI_QUIRK_VENDOR(0x1631, \"Packard Bell\", CXT_FIXUP_CAP_MIX_AMP),\n\tSND_PCI_QUIRK_VENDOR(0x1734, \"Fujitsu\", CXT_FIXUP_CAP_MIX_AMP),\n\tSND_PCI_QUIRK_VENDOR(0x17aa, \"Lenovo\", CXT_FIXUP_CAP_MIX_AMP),\n\t{}\n};\n\nstatic const struct hda_model_fixup cxt5045_fixup_models[] = {\n\t{ .id = CXT_FIXUP_CAP_MIX_AMP, .name = \"cap-mix-amp\" },\n\t{ .id = CXT_FIXUP_TOSHIBA_P105, .name = \"toshiba-p105\" },\n\t{ .id = CXT_FIXUP_HP_530, .name = \"hp-530\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cxt5047_fixups[] = {\n\t \n\tSND_PCI_QUIRK_VENDOR(0x103c, \"HP\", CXT_FIXUP_CAP_MIX_AMP_5047),\n\t{}\n};\n\nstatic const struct hda_model_fixup cxt5047_fixup_models[] = {\n\t{ .id = CXT_FIXUP_CAP_MIX_AMP_5047, .name = \"cap-mix-amp\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cxt5051_fixups[] = {\n\tSND_PCI_QUIRK(0x103c, 0x360b, \"Compaq CQ60\", CXT_PINCFG_COMPAQ_CQ60),\n\tSND_PCI_QUIRK(0x17aa, 0x20f2, \"Lenovo X200\", CXT_PINCFG_LENOVO_X200),\n\t{}\n};\n\nstatic const struct hda_model_fixup cxt5051_fixup_models[] = {\n\t{ .id = CXT_PINCFG_LENOVO_X200, .name = \"lenovo-x200\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cxt5066_fixups[] = {\n\tSND_PCI_QUIRK(0x1025, 0x0543, \"Acer Aspire One 522\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK(0x1025, 0x054c, \"Acer Aspire 3830TG\", CXT_FIXUP_ASPIRE_DMIC),\n\tSND_PCI_QUIRK(0x1025, 0x054f, \"Acer Aspire 4830T\", CXT_FIXUP_ASPIRE_DMIC),\n\tSND_PCI_QUIRK(0x103c, 0x8079, \"HP EliteBook 840 G3\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x807C, \"HP EliteBook 820 G3\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x80FD, \"HP ProBook 640 G2\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x8115, \"HP Z1 Gen3\", CXT_FIXUP_HP_GATE_MIC),\n\tSND_PCI_QUIRK(0x103c, 0x814f, \"HP ZBook 15u G3\", CXT_FIXUP_MUTE_LED_GPIO),\n\tSND_PCI_QUIRK(0x103c, 0x8174, \"HP Spectre x360\", CXT_FIXUP_HP_SPECTRE),\n\tSND_PCI_QUIRK(0x103c, 0x822e, \"HP ProBook 440 G4\", CXT_FIXUP_MUTE_LED_GPIO),\n\tSND_PCI_QUIRK(0x103c, 0x828c, \"HP EliteBook 840 G4\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x8299, \"HP 800 G3 SFF\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x829a, \"HP 800 G3 DM\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x82b4, \"HP ProDesk 600 G3\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x836e, \"HP ProBook 455 G5\", CXT_FIXUP_MUTE_LED_GPIO),\n\tSND_PCI_QUIRK(0x103c, 0x837f, \"HP ProBook 470 G5\", CXT_FIXUP_MUTE_LED_GPIO),\n\tSND_PCI_QUIRK(0x103c, 0x83b2, \"HP EliteBook 840 G5\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x83b3, \"HP EliteBook 830 G5\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x83d3, \"HP ProBook 640 G4\", CXT_FIXUP_HP_DOCK),\n\tSND_PCI_QUIRK(0x103c, 0x8402, \"HP ProBook 645 G4\", CXT_FIXUP_MUTE_LED_GPIO),\n\tSND_PCI_QUIRK(0x103c, 0x8427, \"HP ZBook Studio G5\", CXT_FIXUP_HP_ZBOOK_MUTE_LED),\n\tSND_PCI_QUIRK(0x103c, 0x844f, \"HP ZBook Studio G5\", CXT_FIXUP_HP_ZBOOK_MUTE_LED),\n\tSND_PCI_QUIRK(0x103c, 0x8455, \"HP Z2 G4\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x8456, \"HP Z2 G4 SFF\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x8457, \"HP Z2 G4 mini\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x103c, 0x8458, \"HP Z2 G4 mini premium\", CXT_FIXUP_HP_MIC_NO_PRESENCE),\n\tSND_PCI_QUIRK(0x1043, 0x138d, \"Asus\", CXT_FIXUP_HEADPHONE_MIC_PIN),\n\tSND_PCI_QUIRK(0x152d, 0x0833, \"OLPC XO-1.5\", CXT_FIXUP_OLPC_XO),\n\tSND_PCI_QUIRK(0x17aa, 0x20f2, \"Lenovo T400\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x215e, \"Lenovo T410\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x215f, \"Lenovo T510\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x21ce, \"Lenovo T420\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x21cf, \"Lenovo T520\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x21d2, \"Lenovo T420s\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x21da, \"Lenovo X220\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x21db, \"Lenovo X220-tablet\", CXT_PINCFG_LENOVO_TP410),\n\tSND_PCI_QUIRK(0x17aa, 0x38af, \"Lenovo IdeaPad Z560\", CXT_FIXUP_MUTE_LED_EAPD),\n\tSND_PCI_QUIRK(0x17aa, 0x3905, \"Lenovo G50-30\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK(0x17aa, 0x390b, \"Lenovo G50-80\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK(0x17aa, 0x3975, \"Lenovo U300s\", CXT_FIXUP_STEREO_DMIC),\n\t \n\tSND_PCI_QUIRK(0x17aa, 0x3977, \"Lenovo IdeaPad U310\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK(0x17aa, 0x3978, \"Lenovo G50-70\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK(0x17aa, 0x397b, \"Lenovo S205\", CXT_FIXUP_STEREO_DMIC),\n\tSND_PCI_QUIRK_VENDOR(0x17aa, \"Thinkpad\", CXT_FIXUP_THINKPAD_ACPI),\n\tSND_PCI_QUIRK(0x1c06, 0x2011, \"Lemote A1004\", CXT_PINCFG_LEMOTE_A1004),\n\tSND_PCI_QUIRK(0x1c06, 0x2012, \"Lemote A1205\", CXT_PINCFG_LEMOTE_A1205),\n\t{}\n};\n\nstatic const struct hda_model_fixup cxt5066_fixup_models[] = {\n\t{ .id = CXT_FIXUP_STEREO_DMIC, .name = \"stereo-dmic\" },\n\t{ .id = CXT_FIXUP_GPIO1, .name = \"gpio1\" },\n\t{ .id = CXT_FIXUP_HEADPHONE_MIC_PIN, .name = \"headphone-mic-pin\" },\n\t{ .id = CXT_PINCFG_LENOVO_TP410, .name = \"tp410\" },\n\t{ .id = CXT_FIXUP_THINKPAD_ACPI, .name = \"thinkpad\" },\n\t{ .id = CXT_PINCFG_LEMOTE_A1004, .name = \"lemote-a1004\" },\n\t{ .id = CXT_PINCFG_LEMOTE_A1205, .name = \"lemote-a1205\" },\n\t{ .id = CXT_FIXUP_OLPC_XO, .name = \"olpc-xo\" },\n\t{ .id = CXT_FIXUP_MUTE_LED_EAPD, .name = \"mute-led-eapd\" },\n\t{ .id = CXT_FIXUP_HP_DOCK, .name = \"hp-dock\" },\n\t{ .id = CXT_FIXUP_MUTE_LED_GPIO, .name = \"mute-led-gpio\" },\n\t{ .id = CXT_FIXUP_HP_ZBOOK_MUTE_LED, .name = \"hp-zbook-mute-led\" },\n\t{ .id = CXT_FIXUP_HP_MIC_NO_PRESENCE, .name = \"hp-mic-fix\" },\n\t{ .id = CXT_PINCFG_LENOVO_NOTEBOOK, .name = \"lenovo-20149\" },\n\t{}\n};\n\n \nstatic void add_cx5051_fake_mutes(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec = codec->spec;\n\tstatic const hda_nid_t out_nids[] = {\n\t\t0x10, 0x11, 0\n\t};\n\tconst hda_nid_t *p;\n\n\tfor (p = out_nids; *p; p++)\n\t\tsnd_hda_override_amp_caps(codec, *p, HDA_OUTPUT,\n\t\t\t\t\t  AC_AMPCAP_MIN_MUTE |\n\t\t\t\t\t  query_amp_caps(codec, *p, HDA_OUTPUT));\n\tspec->gen.dac_min_mute = true;\n}\n\nstatic int patch_conexant_auto(struct hda_codec *codec)\n{\n\tstruct conexant_spec *spec;\n\tint err;\n\n\tcodec_info(codec, \"%s: BIOS auto-probing.\\n\", codec->core.chip_name);\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tsnd_hda_gen_spec_init(&spec->gen);\n\tcodec->spec = spec;\n\tcodec->patch_ops = cx_auto_patch_ops;\n\n\tcx_auto_parse_eapd(codec);\n\tspec->gen.own_eapd_ctl = 1;\n\n\tswitch (codec->core.vendor_id) {\n\tcase 0x14f15045:\n\t\tcodec->single_adc_amp = 1;\n\t\tspec->gen.mixer_nid = 0x17;\n\t\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\n\t\tsnd_hda_pick_fixup(codec, cxt5045_fixup_models,\n\t\t\t\t   cxt5045_fixups, cxt_fixups);\n\t\tbreak;\n\tcase 0x14f15047:\n\t\tcodec->pin_amp_workaround = 1;\n\t\tspec->gen.mixer_nid = 0x19;\n\t\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\n\t\tsnd_hda_pick_fixup(codec, cxt5047_fixup_models,\n\t\t\t\t   cxt5047_fixups, cxt_fixups);\n\t\tbreak;\n\tcase 0x14f15051:\n\t\tadd_cx5051_fake_mutes(codec);\n\t\tcodec->pin_amp_workaround = 1;\n\t\tsnd_hda_pick_fixup(codec, cxt5051_fixup_models,\n\t\t\t\t   cxt5051_fixups, cxt_fixups);\n\t\tbreak;\n\tcase 0x14f15098:\n\t\tcodec->pin_amp_workaround = 1;\n\t\tspec->gen.mixer_nid = 0x22;\n\t\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\n\t\tsnd_hda_pick_fixup(codec, cxt5066_fixup_models,\n\t\t\t\t   cxt5066_fixups, cxt_fixups);\n\t\tbreak;\n\tcase 0x14f150f2:\n\t\tcodec->power_save_node = 1;\n\t\tfallthrough;\n\tdefault:\n\t\tcodec->pin_amp_workaround = 1;\n\t\tsnd_hda_pick_fixup(codec, cxt5066_fixup_models,\n\t\t\t\t   cxt5066_fixups, cxt_fixups);\n\t\tbreak;\n\t}\n\n\tif (!spec->gen.vmaster_mute.hook && spec->dynamic_eapd)\n\t\tspec->gen.vmaster_mute.hook = cx_auto_vmaster_hook;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL,\n\t\t\t\t       spec->parse_flags);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = cx_auto_parse_beep(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tif (!codec->bus->core.sync_write) {\n\t\tcodec_info(codec,\n\t\t\t   \"Enable sync_write for stable communication\\n\");\n\t\tcodec->bus->core.sync_write = 1;\n\t\tcodec->bus->allow_bus_reset = 1;\n\t}\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tcx_auto_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_device_id snd_hda_id_conexant[] = {\n\tHDA_CODEC_ENTRY(0x14f11f86, \"CX8070\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f11f87, \"SN6140\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f12008, \"CX8200\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f120d0, \"CX11970\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f120d1, \"SN6180\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15045, \"CX20549 (Venice)\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15047, \"CX20551 (Waikiki)\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15051, \"CX20561 (Hermosa)\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15066, \"CX20582 (Pebble)\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15067, \"CX20583 (Pebble HSF)\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15068, \"CX20584\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15069, \"CX20585\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f1506c, \"CX20588\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f1506e, \"CX20590\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15097, \"CX20631\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15098, \"CX20632\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150a1, \"CX20641\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150a2, \"CX20642\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150ab, \"CX20651\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150ac, \"CX20652\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150b8, \"CX20664\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150b9, \"CX20665\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150f1, \"CX21722\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150f2, \"CX20722\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150f3, \"CX21724\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f150f4, \"CX20724\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f1510f, \"CX20751/2\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15110, \"CX20751/2\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15111, \"CX20753/4\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15113, \"CX20755\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15114, \"CX20756\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f15115, \"CX20757\", patch_conexant_auto),\n\tHDA_CODEC_ENTRY(0x14f151d7, \"CX20952\", patch_conexant_auto),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_conexant);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Conexant HD-audio codec\");\n\nstatic struct hda_codec_driver conexant_driver = {\n\t.id = snd_hda_id_conexant,\n};\n\nmodule_hda_codec_driver(conexant_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}