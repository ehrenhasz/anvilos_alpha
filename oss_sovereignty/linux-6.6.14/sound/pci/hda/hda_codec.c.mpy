{
  "module_name": "hda_codec.c",
  "hash_id": "035f4f9868be9cd596ac4c5658c2d224e53da6cf567b77bef8dbb85f2c6fb22e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_codec.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include <sound/asoundef.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n#include <sound/jack.h>\n#include \"hda_local.h\"\n#include \"hda_beep.h\"\n#include \"hda_jack.h\"\n#include <sound/hda_hwdep.h>\n#include <sound/hda_component.h>\n\n#define codec_in_pm(codec)\t\tsnd_hdac_is_in_pm(&codec->core)\n#define hda_codec_is_power_on(codec)\tsnd_hdac_is_power_on(&codec->core)\n#define codec_has_epss(codec) \\\n\t((codec)->core.power_caps & AC_PWRST_EPSS)\n#define codec_has_clkstop(codec) \\\n\t((codec)->core.power_caps & AC_PWRST_CLKSTOP)\n\n \nstatic int codec_exec_verb(struct hdac_device *dev, unsigned int cmd,\n\t\t\t   unsigned int flags, unsigned int *res)\n{\n\tstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\n\tstruct hda_bus *bus = codec->bus;\n\tint err;\n\n\tif (cmd == ~0)\n\t\treturn -1;\n\n again:\n\tsnd_hda_power_up_pm(codec);\n\tmutex_lock(&bus->core.cmd_mutex);\n\tif (flags & HDA_RW_NO_RESPONSE_FALLBACK)\n\t\tbus->no_response_fallback = 1;\n\terr = snd_hdac_bus_exec_verb_unlocked(&bus->core, codec->core.addr,\n\t\t\t\t\t      cmd, res);\n\tbus->no_response_fallback = 0;\n\tmutex_unlock(&bus->core.cmd_mutex);\n\tsnd_hda_power_down_pm(codec);\n\tif (!codec_in_pm(codec) && res && err == -EAGAIN) {\n\t\tif (bus->response_reset) {\n\t\t\tcodec_dbg(codec,\n\t\t\t\t  \"resetting BUS due to fatal communication error\\n\");\n\t\t\tsnd_hda_bus_reset(bus);\n\t\t}\n\t\tgoto again;\n\t}\n\t \n\tif (!err || codec_in_pm(codec))\n\t\tbus->response_reset = 0;\n\treturn err;\n}\n\n \nvoid snd_hda_sequence_write(struct hda_codec *codec, const struct hda_verb *seq)\n{\n\tfor (; seq->nid; seq++)\n\t\tsnd_hda_codec_write(codec, seq->nid, 0, seq->verb, seq->param);\n}\nEXPORT_SYMBOL_GPL(snd_hda_sequence_write);\n\n \nstruct hda_conn_list {\n\tstruct list_head list;\n\tint len;\n\thda_nid_t nid;\n\thda_nid_t conns[];\n};\n\n \nstatic struct hda_conn_list *\nlookup_conn_list(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_conn_list *p;\n\tlist_for_each_entry(p, &codec->conn_list, list) {\n\t\tif (p->nid == nid)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nstatic int add_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\n\t\t\t const hda_nid_t *list)\n{\n\tstruct hda_conn_list *p;\n\n\tp = kmalloc(struct_size(p, conns, len), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tp->len = len;\n\tp->nid = nid;\n\tmemcpy(p->conns, list, len * sizeof(hda_nid_t));\n\tlist_add(&p->list, &codec->conn_list);\n\treturn 0;\n}\n\nstatic void remove_conn_list(struct hda_codec *codec)\n{\n\twhile (!list_empty(&codec->conn_list)) {\n\t\tstruct hda_conn_list *p;\n\t\tp = list_first_entry(&codec->conn_list, typeof(*p), list);\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n}\n\n \nstatic int read_and_add_raw_conns(struct hda_codec *codec, hda_nid_t nid)\n{\n\thda_nid_t list[32];\n\thda_nid_t *result = list;\n\tint len;\n\n\tlen = snd_hda_get_raw_connections(codec, nid, list, ARRAY_SIZE(list));\n\tif (len == -ENOSPC) {\n\t\tlen = snd_hda_get_num_raw_conns(codec, nid);\n\t\tresult = kmalloc_array(len, sizeof(hda_nid_t), GFP_KERNEL);\n\t\tif (!result)\n\t\t\treturn -ENOMEM;\n\t\tlen = snd_hda_get_raw_connections(codec, nid, result, len);\n\t}\n\tif (len >= 0)\n\t\tlen = snd_hda_override_conn_list(codec, nid, len, result);\n\tif (result != list)\n\t\tkfree(result);\n\treturn len;\n}\n\n \nint snd_hda_get_conn_list(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  const hda_nid_t **listp)\n{\n\tbool added = false;\n\n\tfor (;;) {\n\t\tint err;\n\t\tconst struct hda_conn_list *p;\n\n\t\t \n\t\tp = lookup_conn_list(codec, nid);\n\t\tif (p) {\n\t\t\tif (listp)\n\t\t\t\t*listp = p->conns;\n\t\t\treturn p->len;\n\t\t}\n\t\tif (snd_BUG_ON(added))\n\t\t\treturn -EINVAL;\n\n\t\terr = read_and_add_raw_conns(codec, nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tadded = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_conn_list);\n\n \nint snd_hda_get_connections(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t    hda_nid_t *conn_list, int max_conns)\n{\n\tconst hda_nid_t *list;\n\tint len = snd_hda_get_conn_list(codec, nid, &list);\n\n\tif (len > 0 && conn_list) {\n\t\tif (len > max_conns) {\n\t\t\tcodec_err(codec, \"Too many connections %d for NID 0x%x\\n\",\n\t\t\t\t   len, nid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(conn_list, list, len * sizeof(hda_nid_t));\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_connections);\n\n \nint snd_hda_override_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\n\t\t\t       const hda_nid_t *list)\n{\n\tstruct hda_conn_list *p;\n\n\tp = lookup_conn_list(codec, nid);\n\tif (p) {\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n\n\treturn add_conn_list(codec, nid, len, list);\n}\nEXPORT_SYMBOL_GPL(snd_hda_override_conn_list);\n\n \nint snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,\n\t\t\t   hda_nid_t nid, int recursive)\n{\n\tconst hda_nid_t *conn;\n\tint i, nums;\n\n\tnums = snd_hda_get_conn_list(codec, mux, &conn);\n\tfor (i = 0; i < nums; i++)\n\t\tif (conn[i] == nid)\n\t\t\treturn i;\n\tif (!recursive)\n\t\treturn -1;\n\tif (recursive > 10) {\n\t\tcodec_dbg(codec, \"too deep connection for 0x%x\\n\", nid);\n\t\treturn -1;\n\t}\n\trecursive++;\n\tfor (i = 0; i < nums; i++) {\n\t\tunsigned int type = get_wcaps_type(get_wcaps(codec, conn[i]));\n\t\tif (type == AC_WID_PIN || type == AC_WID_AUD_OUT)\n\t\t\tcontinue;\n\t\tif (snd_hda_get_conn_index(codec, conn[i], nid, recursive) >= 0)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_conn_index);\n\n \nunsigned int snd_hda_get_num_devices(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int wcaps = get_wcaps(codec, nid);\n\tunsigned int parm;\n\n\tif (!codec->dp_mst || !(wcaps & AC_WCAP_DIGITAL) ||\n\t    get_wcaps_type(wcaps) != AC_WID_PIN)\n\t\treturn 0;\n\n\tparm = snd_hdac_read_parm_uncached(&codec->core, nid, AC_PAR_DEVLIST_LEN);\n\tif (parm == -1)\n\t\tparm = 0;\n\treturn parm & AC_DEV_LIST_LEN_MASK;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_num_devices);\n\n \nint snd_hda_get_devices(struct hda_codec *codec, hda_nid_t nid,\n\t\t\tu8 *dev_list, int max_devices)\n{\n\tunsigned int parm;\n\tint i, dev_len, devices;\n\n\tparm = snd_hda_get_num_devices(codec, nid);\n\tif (!parm)\t \n\t\treturn 0;\n\n\tdev_len = parm + 1;\n\tdev_len = dev_len < max_devices ? dev_len : max_devices;\n\n\tdevices = 0;\n\twhile (devices < dev_len) {\n\t\tif (snd_hdac_read(&codec->core, nid,\n\t\t\t\t  AC_VERB_GET_DEVICE_LIST, devices, &parm))\n\t\t\tbreak;  \n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tdev_list[devices] = (u8)parm;\n\t\t\tparm >>= 4;\n\t\t\tdevices++;\n\t\t\tif (devices >= dev_len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn devices;\n}\n\n \nint snd_hda_get_dev_select(struct hda_codec *codec, hda_nid_t nid)\n{\n\t \n\tif (!codec->dp_mst)\n\t\treturn 0;\n\n\treturn snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_DEVICE_SEL, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_dev_select);\n\n \nint snd_hda_set_dev_select(struct hda_codec *codec, hda_nid_t nid, int dev_id)\n{\n\tint ret, num_devices;\n\n\t \n\tif (!codec->dp_mst)\n\t\treturn 0;\n\n\t \n\tnum_devices = snd_hda_get_num_devices(codec, nid) + 1;\n\t \n\tif (num_devices == 1)\n\t\treturn 0;\n\n\t \n\tif (num_devices <= dev_id)\n\t\treturn -EINVAL;\n\n\tret = snd_hda_codec_write(codec, nid, 0,\n\t\t\tAC_VERB_SET_DEVICE_SEL, dev_id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_set_dev_select);\n\n \nstatic int read_widget_caps(struct hda_codec *codec, hda_nid_t fg_node)\n{\n\tint i;\n\thda_nid_t nid;\n\n\tcodec->wcaps = kmalloc_array(codec->core.num_nodes, 4, GFP_KERNEL);\n\tif (!codec->wcaps)\n\t\treturn -ENOMEM;\n\tnid = codec->core.start_nid;\n\tfor (i = 0; i < codec->core.num_nodes; i++, nid++)\n\t\tcodec->wcaps[i] = snd_hdac_read_parm_uncached(&codec->core,\n\t\t\t\t\tnid, AC_PAR_AUDIO_WIDGET_CAP);\n\treturn 0;\n}\n\n \nstatic int read_pin_defaults(struct hda_codec *codec)\n{\n\thda_nid_t nid;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tstruct hda_pincfg *pin;\n\t\tunsigned int wcaps = get_wcaps(codec, nid);\n\t\tunsigned int wid_type = get_wcaps_type(wcaps);\n\t\tif (wid_type != AC_WID_PIN)\n\t\t\tcontinue;\n\t\tpin = snd_array_new(&codec->init_pins);\n\t\tif (!pin)\n\t\t\treturn -ENOMEM;\n\t\tpin->nid = nid;\n\t\tpin->cfg = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t      AC_VERB_GET_CONFIG_DEFAULT, 0);\n\t\t \n\t\tpin->ctrl = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t       AC_VERB_GET_PIN_WIDGET_CONTROL,\n\t\t\t\t\t       0);\n\t}\n\treturn 0;\n}\n\n \nstatic struct hda_pincfg *look_up_pincfg(struct hda_codec *codec,\n\t\t\t\t\t struct snd_array *array,\n\t\t\t\t\t hda_nid_t nid)\n{\n\tstruct hda_pincfg *pin;\n\tint i;\n\n\tsnd_array_for_each(array, i, pin) {\n\t\tif (pin->nid == nid)\n\t\t\treturn pin;\n\t}\n\treturn NULL;\n}\n\n \nint snd_hda_add_pincfg(struct hda_codec *codec, struct snd_array *list,\n\t\t       hda_nid_t nid, unsigned int cfg)\n{\n\tstruct hda_pincfg *pin;\n\n\t \n\t \n\n\tpin = look_up_pincfg(codec, list, nid);\n\tif (!pin) {\n\t\tpin = snd_array_new(list);\n\t\tif (!pin)\n\t\t\treturn -ENOMEM;\n\t\tpin->nid = nid;\n\t}\n\tpin->cfg = cfg;\n\treturn 0;\n}\n\n \nint snd_hda_codec_set_pincfg(struct hda_codec *codec,\n\t\t\t     hda_nid_t nid, unsigned int cfg)\n{\n\treturn snd_hda_add_pincfg(codec, &codec->driver_pins, nid, cfg);\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_set_pincfg);\n\n \nunsigned int snd_hda_codec_get_pincfg(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_pincfg *pin;\n\n#ifdef CONFIG_SND_HDA_RECONFIG\n\t{\n\t\tunsigned int cfg = 0;\n\t\tmutex_lock(&codec->user_mutex);\n\t\tpin = look_up_pincfg(codec, &codec->user_pins, nid);\n\t\tif (pin)\n\t\t\tcfg = pin->cfg;\n\t\tmutex_unlock(&codec->user_mutex);\n\t\tif (cfg)\n\t\t\treturn cfg;\n\t}\n#endif\n\tpin = look_up_pincfg(codec, &codec->driver_pins, nid);\n\tif (pin)\n\t\treturn pin->cfg;\n\tpin = look_up_pincfg(codec, &codec->init_pins, nid);\n\tif (pin)\n\t\treturn pin->cfg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_get_pincfg);\n\n \nint snd_hda_codec_set_pin_target(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t unsigned int val)\n{\n\tstruct hda_pincfg *pin;\n\n\tpin = look_up_pincfg(codec, &codec->init_pins, nid);\n\tif (!pin)\n\t\treturn -EINVAL;\n\tpin->target = val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_set_pin_target);\n\n \nint snd_hda_codec_get_pin_target(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_pincfg *pin;\n\n\tpin = look_up_pincfg(codec, &codec->init_pins, nid);\n\tif (!pin)\n\t\treturn 0;\n\treturn pin->target;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_get_pin_target);\n\n \nvoid snd_hda_shutup_pins(struct hda_codec *codec)\n{\n\tconst struct hda_pincfg *pin;\n\tint i;\n\n\t \n\tif (codec->bus->shutdown)\n\t\treturn;\n\tsnd_array_for_each(&codec->init_pins, i, pin) {\n\t\t \n\t\tsnd_hda_codec_read(codec, pin->nid, 0,\n\t\t\t\t   AC_VERB_SET_PIN_WIDGET_CONTROL, 0);\n\t}\n\tcodec->pins_shutup = 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_shutup_pins);\n\n#ifdef CONFIG_PM\n \nstatic void restore_shutup_pins(struct hda_codec *codec)\n{\n\tconst struct hda_pincfg *pin;\n\tint i;\n\n\tif (!codec->pins_shutup)\n\t\treturn;\n\tif (codec->bus->shutdown)\n\t\treturn;\n\tsnd_array_for_each(&codec->init_pins, i, pin) {\n\t\tsnd_hda_codec_write(codec, pin->nid, 0,\n\t\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t    pin->ctrl);\n\t}\n\tcodec->pins_shutup = 0;\n}\n#endif\n\nstatic void hda_jackpoll_work(struct work_struct *work)\n{\n\tstruct hda_codec *codec =\n\t\tcontainer_of(work, struct hda_codec, jackpoll_work.work);\n\n\t \n\tif (!codec->jackpoll_interval && snd_hdac_is_power_on(&codec->core))\n\t\treturn;\n\n\t \n\tsnd_hda_power_up_pm(codec);\n\t \n\tif (codec->jackpoll_interval) {\n\t\tsnd_hda_jack_set_dirty_all(codec);\n\t\tsnd_hda_jack_poll_all(codec);\n\t}\n\tsnd_hda_power_down_pm(codec);\n\n\tif (!codec->jackpoll_interval)\n\t\treturn;\n\n\tschedule_delayed_work(&codec->jackpoll_work,\n\t\t\t      codec->jackpoll_interval);\n}\n\n \nstatic void free_init_pincfgs(struct hda_codec *codec)\n{\n\tsnd_array_free(&codec->driver_pins);\n#ifdef CONFIG_SND_HDA_RECONFIG\n\tsnd_array_free(&codec->user_pins);\n#endif\n\tsnd_array_free(&codec->init_pins);\n}\n\n \nstruct hda_cvt_setup {\n\thda_nid_t nid;\n\tu8 stream_tag;\n\tu8 channel_id;\n\tu16 format_id;\n\tunsigned char active;\t \n\tunsigned char dirty;\t \n};\n\n \nstatic struct hda_cvt_setup *\nget_hda_cvt_setup(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_cvt_setup *p;\n\tint i;\n\n\tsnd_array_for_each(&codec->cvt_setups, i, p) {\n\t\tif (p->nid == nid)\n\t\t\treturn p;\n\t}\n\tp = snd_array_new(&codec->cvt_setups);\n\tif (p)\n\t\tp->nid = nid;\n\treturn p;\n}\n\n \nvoid snd_hda_codec_pcm_put(struct hda_pcm *pcm)\n{\n\tif (refcount_dec_and_test(&pcm->codec->pcm_ref))\n\t\twake_up(&pcm->codec->remove_sleep);\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_pcm_put);\n\nstruct hda_pcm *snd_hda_codec_pcm_new(struct hda_codec *codec,\n\t\t\t\t      const char *fmt, ...)\n{\n\tstruct hda_pcm *pcm;\n\tva_list args;\n\n\tpcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn NULL;\n\n\tpcm->codec = codec;\n\tva_start(args, fmt);\n\tpcm->name = kvasprintf(GFP_KERNEL, fmt, args);\n\tva_end(args);\n\tif (!pcm->name) {\n\t\tkfree(pcm);\n\t\treturn NULL;\n\t}\n\n\tlist_add_tail(&pcm->list, &codec->pcm_list_head);\n\trefcount_inc(&codec->pcm_ref);\n\treturn pcm;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_pcm_new);\n\n \nvoid snd_hda_codec_disconnect_pcms(struct hda_codec *codec)\n{\n\tstruct hda_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\n\t\tif (pcm->disconnected)\n\t\t\tcontinue;\n\t\tif (pcm->pcm)\n\t\t\tsnd_device_disconnect(codec->card, pcm->pcm);\n\t\tsnd_hda_codec_pcm_put(pcm);\n\t\tpcm->disconnected = 1;\n\t}\n}\n\nstatic void codec_release_pcms(struct hda_codec *codec)\n{\n\tstruct hda_pcm *pcm, *n;\n\n\tlist_for_each_entry_safe(pcm, n, &codec->pcm_list_head, list) {\n\t\tlist_del(&pcm->list);\n\t\tif (pcm->pcm)\n\t\t\tsnd_device_free(pcm->codec->card, pcm->pcm);\n\t\tclear_bit(pcm->device, pcm->codec->bus->pcm_dev_bits);\n\t\tkfree(pcm->name);\n\t\tkfree(pcm);\n\t}\n}\n\n \nvoid snd_hda_codec_cleanup_for_unbind(struct hda_codec *codec)\n{\n\tif (codec->core.registered) {\n\t\t \n\t\tpm_runtime_get_noresume(hda_codec_dev(codec));\n\t\tpm_runtime_disable(hda_codec_dev(codec));\n\t\tcodec->core.registered = 0;\n\t}\n\n\tsnd_hda_codec_disconnect_pcms(codec);\n\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\tif (!codec->in_freeing)\n\t\tsnd_hda_ctls_clear(codec);\n\tcodec_release_pcms(codec);\n\tsnd_hda_detach_beep_device(codec);\n\tmemset(&codec->patch_ops, 0, sizeof(codec->patch_ops));\n\tsnd_hda_jack_tbl_clear(codec);\n\tcodec->proc_widget_hook = NULL;\n\tcodec->spec = NULL;\n\n\t \n\tsnd_array_free(&codec->driver_pins);\n\tsnd_array_free(&codec->cvt_setups);\n\tsnd_array_free(&codec->spdif_out);\n\tsnd_array_free(&codec->verbs);\n\tcodec->follower_dig_outs = NULL;\n\tcodec->spdif_status_reset = 0;\n\tsnd_array_free(&codec->mixers);\n\tsnd_array_free(&codec->nids);\n\tremove_conn_list(codec);\n\tsnd_hdac_regmap_exit(&codec->core);\n\tcodec->configured = 0;\n\trefcount_set(&codec->pcm_ref, 1);  \n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_cleanup_for_unbind);\n\nstatic unsigned int hda_set_power_state(struct hda_codec *codec,\n\t\t\t\tunsigned int power_state);\n\n \nvoid snd_hda_codec_display_power(struct hda_codec *codec, bool enable)\n{\n\tif (codec->display_power_control)\n\t\tsnd_hdac_display_power(&codec->bus->core, codec->addr, enable);\n}\n\n \nvoid snd_hda_codec_register(struct hda_codec *codec)\n{\n\tif (codec->core.registered)\n\t\treturn;\n\tif (device_is_registered(hda_codec_dev(codec))) {\n\t\tsnd_hda_codec_display_power(codec, true);\n\t\tpm_runtime_enable(hda_codec_dev(codec));\n\t\t \n\t\tsnd_hda_power_down(codec);\n\t\tcodec->core.registered = 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_register);\n\nstatic int snd_hda_codec_dev_register(struct snd_device *device)\n{\n\tsnd_hda_codec_register(device->device_data);\n\treturn 0;\n}\n\n \nvoid snd_hda_codec_unregister(struct hda_codec *codec)\n{\n\tcodec->in_freeing = 1;\n\t \n\tif (codec->core.type == HDA_DEV_LEGACY)\n\t\tsnd_hdac_device_unregister(&codec->core);\n\tsnd_hda_codec_display_power(codec, false);\n\n\t \n\tif (codec->core.type == HDA_DEV_LEGACY)\n\t\tput_device(hda_codec_dev(codec));\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_unregister);\n\nstatic int snd_hda_codec_dev_free(struct snd_device *device)\n{\n\tsnd_hda_codec_unregister(device->device_data);\n\treturn 0;\n}\n\nstatic void snd_hda_codec_dev_release(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\tfree_init_pincfgs(codec);\n\tsnd_hdac_device_exit(&codec->core);\n\tsnd_hda_sysfs_clear(codec);\n\tkfree(codec->modelname);\n\tkfree(codec->wcaps);\n\tkfree(codec);\n}\n\n#define DEV_NAME_LEN 31\n\n \nstruct hda_codec *\nsnd_hda_codec_device_init(struct hda_bus *bus, unsigned int codec_addr,\n\t\t\t  const char *fmt, ...)\n{\n\tva_list vargs;\n\tchar name[DEV_NAME_LEN];\n\tstruct hda_codec *codec;\n\tint err;\n\n\tif (snd_BUG_ON(!bus))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (snd_BUG_ON(codec_addr > HDA_MAX_CODEC_ADDRESS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcodec = kzalloc(sizeof(*codec), GFP_KERNEL);\n\tif (!codec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva_start(vargs, fmt);\n\tvsprintf(name, fmt, vargs);\n\tva_end(vargs);\n\n\terr = snd_hdac_device_init(&codec->core, &bus->core, name, codec_addr);\n\tif (err < 0) {\n\t\tkfree(codec);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tcodec->bus = bus;\n\tcodec->depop_delay = -1;\n\tcodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\n\tcodec->core.dev.release = snd_hda_codec_dev_release;\n\tcodec->core.type = HDA_DEV_LEGACY;\n\n\tmutex_init(&codec->spdif_mutex);\n\tmutex_init(&codec->control_mutex);\n\tsnd_array_init(&codec->mixers, sizeof(struct hda_nid_item), 32);\n\tsnd_array_init(&codec->nids, sizeof(struct hda_nid_item), 32);\n\tsnd_array_init(&codec->init_pins, sizeof(struct hda_pincfg), 16);\n\tsnd_array_init(&codec->driver_pins, sizeof(struct hda_pincfg), 16);\n\tsnd_array_init(&codec->cvt_setups, sizeof(struct hda_cvt_setup), 8);\n\tsnd_array_init(&codec->spdif_out, sizeof(struct hda_spdif_out), 16);\n\tsnd_array_init(&codec->jacktbl, sizeof(struct hda_jack_tbl), 16);\n\tsnd_array_init(&codec->verbs, sizeof(struct hda_verb *), 8);\n\tINIT_LIST_HEAD(&codec->conn_list);\n\tINIT_LIST_HEAD(&codec->pcm_list_head);\n\tINIT_DELAYED_WORK(&codec->jackpoll_work, hda_jackpoll_work);\n\trefcount_set(&codec->pcm_ref, 1);\n\tinit_waitqueue_head(&codec->remove_sleep);\n\n\treturn codec;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_device_init);\n\n \nint snd_hda_codec_new(struct hda_bus *bus, struct snd_card *card,\n\t\t      unsigned int codec_addr, struct hda_codec **codecp)\n{\n\tstruct hda_codec *codec;\n\tint ret;\n\n\tcodec = snd_hda_codec_device_init(bus, codec_addr, \"hdaudioC%dD%d\",\n\t\t\t\t\t  card->number, codec_addr);\n\tif (IS_ERR(codec))\n\t\treturn PTR_ERR(codec);\n\t*codecp = codec;\n\n\tret = snd_hda_codec_device_new(bus, card, codec_addr, *codecp, true);\n\tif (ret)\n\t\tput_device(hda_codec_dev(*codecp));\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_new);\n\nint snd_hda_codec_device_new(struct hda_bus *bus, struct snd_card *card,\n\t\t\tunsigned int codec_addr, struct hda_codec *codec,\n\t\t\tbool snddev_managed)\n{\n\tchar component[31];\n\thda_nid_t fg;\n\tint err;\n\tstatic const struct snd_device_ops dev_ops = {\n\t\t.dev_register = snd_hda_codec_dev_register,\n\t\t.dev_free = snd_hda_codec_dev_free,\n\t};\n\n\tdev_dbg(card->dev, \"%s: entry\\n\", __func__);\n\n\tif (snd_BUG_ON(!bus))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(codec_addr > HDA_MAX_CODEC_ADDRESS))\n\t\treturn -EINVAL;\n\n\tcodec->core.exec_verb = codec_exec_verb;\n\tcodec->card = card;\n\tcodec->addr = codec_addr;\n\n#ifdef CONFIG_PM\n\tcodec->power_jiffies = jiffies;\n#endif\n\n\tsnd_hda_sysfs_init(codec);\n\n\tif (codec->bus->modelname) {\n\t\tcodec->modelname = kstrdup(codec->bus->modelname, GFP_KERNEL);\n\t\tif (!codec->modelname)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfg = codec->core.afg ? codec->core.afg : codec->core.mfg;\n\terr = read_widget_caps(codec, fg);\n\tif (err < 0)\n\t\treturn err;\n\terr = read_pin_defaults(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\thda_set_power_state(codec, AC_PWRST_D0);\n\tcodec->core.dev.power.power_state = PMSG_ON;\n\n\tsnd_hda_codec_proc_new(codec);\n\n\tsnd_hda_create_hwdep(codec);\n\n\tsprintf(component, \"HDA:%08x,%08x,%08x\", codec->core.vendor_id,\n\t\tcodec->core.subsystem_id, codec->core.revision_id);\n\tsnd_component_add(card, component);\n\n\tif (snddev_managed) {\n\t\t \n\t\terr = snd_device_new(card, SNDRV_DEV_CODEC, codec, &dev_ops);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#ifdef CONFIG_PM\n\t \n\tif (codec->core.dev.power.runtime_auto)\n\t\tpm_runtime_forbid(&codec->core.dev);\n\telse\n\t\t \n\t\tpm_runtime_get_noresume(&codec->core.dev);\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_device_new);\n\n \nint snd_hda_codec_update_widgets(struct hda_codec *codec)\n{\n\thda_nid_t fg;\n\tint err;\n\n\terr = snd_hdac_refresh_widgets(&codec->core);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tkfree(codec->wcaps);\n\tfg = codec->core.afg ? codec->core.afg : codec->core.mfg;\n\terr = read_widget_caps(codec, fg);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_array_free(&codec->init_pins);\n\terr = read_pin_defaults(codec);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_update_widgets);\n\n \nstatic void update_pcm_stream_id(struct hda_codec *codec,\n\t\t\t\t struct hda_cvt_setup *p, hda_nid_t nid,\n\t\t\t\t u32 stream_tag, int channel_id)\n{\n\tunsigned int oldval, newval;\n\n\tif (p->stream_tag != stream_tag || p->channel_id != channel_id) {\n\t\toldval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\n\t\tnewval = (stream_tag << 4) | channel_id;\n\t\tif (oldval != newval)\n\t\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_CHANNEL_STREAMID,\n\t\t\t\t\t    newval);\n\t\tp->stream_tag = stream_tag;\n\t\tp->channel_id = channel_id;\n\t}\n}\n\n \nstatic void update_pcm_format(struct hda_codec *codec, struct hda_cvt_setup *p,\n\t\t\t      hda_nid_t nid, int format)\n{\n\tunsigned int oldval;\n\n\tif (p->format_id != format) {\n\t\toldval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_GET_STREAM_FORMAT, 0);\n\t\tif (oldval != format) {\n\t\t\tmsleep(1);\n\t\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_STREAM_FORMAT,\n\t\t\t\t\t    format);\n\t\t}\n\t\tp->format_id = format;\n\t}\n}\n\n \nvoid snd_hda_codec_setup_stream(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\tu32 stream_tag,\n\t\t\t\tint channel_id, int format)\n{\n\tstruct hda_codec *c;\n\tstruct hda_cvt_setup *p;\n\tint type;\n\tint i;\n\n\tif (!nid)\n\t\treturn;\n\n\tcodec_dbg(codec,\n\t\t  \"hda_codec_setup_stream: NID=0x%x, stream=0x%x, channel=%d, format=0x%x\\n\",\n\t\t  nid, stream_tag, channel_id, format);\n\tp = get_hda_cvt_setup(codec, nid);\n\tif (!p)\n\t\treturn;\n\n\tif (codec->patch_ops.stream_pm)\n\t\tcodec->patch_ops.stream_pm(codec, nid, true);\n\tif (codec->pcm_format_first)\n\t\tupdate_pcm_format(codec, p, nid, format);\n\tupdate_pcm_stream_id(codec, p, nid, stream_tag, channel_id);\n\tif (!codec->pcm_format_first)\n\t\tupdate_pcm_format(codec, p, nid, format);\n\n\tp->active = 1;\n\tp->dirty = 0;\n\n\t \n\ttype = get_wcaps_type(get_wcaps(codec, nid));\n\tlist_for_each_codec(c, codec->bus) {\n\t\tsnd_array_for_each(&c->cvt_setups, i, p) {\n\t\t\tif (!p->active && p->stream_tag == stream_tag &&\n\t\t\t    get_wcaps_type(get_wcaps(c, p->nid)) == type)\n\t\t\t\tp->dirty = 1;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_setup_stream);\n\nstatic void really_cleanup_stream(struct hda_codec *codec,\n\t\t\t\t  struct hda_cvt_setup *q);\n\n \nvoid __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t    int do_now)\n{\n\tstruct hda_cvt_setup *p;\n\n\tif (!nid)\n\t\treturn;\n\n\tif (codec->no_sticky_stream)\n\t\tdo_now = 1;\n\n\tcodec_dbg(codec, \"hda_codec_cleanup_stream: NID=0x%x\\n\", nid);\n\tp = get_hda_cvt_setup(codec, nid);\n\tif (p) {\n\t\t \n\t\tif (do_now)\n\t\t\treally_cleanup_stream(codec, p);\n\t\telse\n\t\t\tp->active = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(__snd_hda_codec_cleanup_stream);\n\nstatic void really_cleanup_stream(struct hda_codec *codec,\n\t\t\t\t  struct hda_cvt_setup *q)\n{\n\thda_nid_t nid = q->nid;\n\tif (q->stream_tag || q->channel_id)\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_CHANNEL_STREAMID, 0);\n\tif (q->format_id)\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_STREAM_FORMAT, 0\n);\n\tmemset(q, 0, sizeof(*q));\n\tq->nid = nid;\n\tif (codec->patch_ops.stream_pm)\n\t\tcodec->patch_ops.stream_pm(codec, nid, false);\n}\n\n \nstatic void purify_inactive_streams(struct hda_codec *codec)\n{\n\tstruct hda_codec *c;\n\tstruct hda_cvt_setup *p;\n\tint i;\n\n\tlist_for_each_codec(c, codec->bus) {\n\t\tsnd_array_for_each(&c->cvt_setups, i, p) {\n\t\t\tif (p->dirty)\n\t\t\t\treally_cleanup_stream(c, p);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PM\n \nstatic void hda_cleanup_all_streams(struct hda_codec *codec)\n{\n\tstruct hda_cvt_setup *p;\n\tint i;\n\n\tsnd_array_for_each(&codec->cvt_setups, i, p) {\n\t\tif (p->stream_tag)\n\t\t\treally_cleanup_stream(codec, p);\n\t}\n}\n#endif\n\n \n\n \nu32 query_amp_caps(struct hda_codec *codec, hda_nid_t nid, int direction)\n{\n\tif (!(get_wcaps(codec, nid) & AC_WCAP_AMP_OVRD))\n\t\tnid = codec->core.afg;\n\treturn snd_hda_param_read(codec, nid,\n\t\t\t\t  direction == HDA_OUTPUT ?\n\t\t\t\t  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\n}\nEXPORT_SYMBOL_GPL(query_amp_caps);\n\n \nbool snd_hda_check_amp_caps(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int dir, unsigned int bits)\n{\n\tif (!nid)\n\t\treturn false;\n\tif (get_wcaps(codec, nid) & (1 << (dir + 1)))\n\t\tif (query_amp_caps(codec, nid, dir) & bits)\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(snd_hda_check_amp_caps);\n\n \nint snd_hda_override_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t      unsigned int caps)\n{\n\tunsigned int parm;\n\n\tsnd_hda_override_wcaps(codec, nid,\n\t\t\t       get_wcaps(codec, nid) | AC_WCAP_AMP_OVRD);\n\tparm = dir == HDA_OUTPUT ? AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP;\n\treturn snd_hdac_override_parm(&codec->core, nid, parm, caps);\n}\nEXPORT_SYMBOL_GPL(snd_hda_override_amp_caps);\n\nstatic unsigned int encode_amp(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t       int ch, int dir, int idx)\n{\n\tunsigned int cmd = snd_hdac_regmap_encode_amp(nid, ch, dir, idx);\n\n\t \n\tif ((query_amp_caps(codec, nid, dir) &\n\t     (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) == AC_AMPCAP_MIN_MUTE)\n\t\tcmd |= AC_AMP_FAKE_MUTE;\n\treturn cmd;\n}\n\n \nint snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t     int ch, int dir, int idx, int mask, int val)\n{\n\tunsigned int cmd = encode_amp(codec, nid, ch, dir, idx);\n\n\treturn snd_hdac_regmap_update_raw(&codec->core, cmd, mask, val);\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_amp_update);\n\n \nint snd_hda_codec_amp_stereo(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t     int direction, int idx, int mask, int val)\n{\n\tint ch, ret = 0;\n\n\tif (snd_BUG_ON(mask & ~0xff))\n\t\tmask &= 0xff;\n\tfor (ch = 0; ch < 2; ch++)\n\t\tret |= snd_hda_codec_amp_update(codec, nid, ch, direction,\n\t\t\t\t\t\tidx, mask, val);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_amp_stereo);\n\n \nint snd_hda_codec_amp_init(struct hda_codec *codec, hda_nid_t nid, int ch,\n\t\t\t   int dir, int idx, int mask, int val)\n{\n\tunsigned int cmd = encode_amp(codec, nid, ch, dir, idx);\n\n\tif (!codec->core.regmap)\n\t\treturn -EINVAL;\n\treturn snd_hdac_regmap_update_raw_once(&codec->core, cmd, mask, val);\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_amp_init);\n\n \nint snd_hda_codec_amp_init_stereo(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t  int dir, int idx, int mask, int val)\n{\n\tint ch, ret = 0;\n\n\tif (snd_BUG_ON(mask & ~0xff))\n\t\tmask &= 0xff;\n\tfor (ch = 0; ch < 2; ch++)\n\t\tret |= snd_hda_codec_amp_init(codec, nid, ch, dir,\n\t\t\t\t\t      idx, mask, val);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_amp_init_stereo);\n\nstatic u32 get_amp_max_value(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t     unsigned int ofs)\n{\n\tu32 caps = query_amp_caps(codec, nid, dir);\n\t \n\tcaps = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\n\tif (ofs < caps)\n\t\tcaps -= ofs;\n\treturn caps;\n}\n\n \nint snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tu16 nid = get_amp_nid(kcontrol);\n\tu8 chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);\n\tif (!uinfo->value.integer.max) {\n\t\tcodec_warn(codec,\n\t\t\t   \"num_steps = 0 for NID=0x%x (ctl = %s)\\n\",\n\t\t\t   nid, kcontrol->id.name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_volume_info);\n\n\nstatic inline unsigned int\nread_amp_value(struct hda_codec *codec, hda_nid_t nid,\n\t       int ch, int dir, int idx, unsigned int ofs)\n{\n\tunsigned int val;\n\tval = snd_hda_codec_amp_read(codec, nid, ch, dir, idx);\n\tval &= HDA_AMP_VOLMASK;\n\tif (val >= ofs)\n\t\tval -= ofs;\n\telse\n\t\tval = 0;\n\treturn val;\n}\n\nstatic inline int\nupdate_amp_value(struct hda_codec *codec, hda_nid_t nid,\n\t\t int ch, int dir, int idx, unsigned int ofs,\n\t\t unsigned int val)\n{\n\tunsigned int maxval;\n\n\tif (val > 0)\n\t\tval += ofs;\n\t \n\tmaxval = get_amp_max_value(codec, nid, dir, 0);\n\tif (val > maxval)\n\t\tval = maxval;\n\treturn snd_hda_codec_amp_update(codec, nid, ch, dir, idx,\n\t\t\t\t\tHDA_AMP_VOLMASK, val);\n}\n\n \nint snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\tif (chs & 1)\n\t\t*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\n\tif (chs & 2)\n\t\t*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_volume_get);\n\n \nint snd_hda_mixer_amp_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint change = 0;\n\n\tif (chs & 1) {\n\t\tchange = update_amp_value(codec, nid, 0, dir, idx, ofs, *valp);\n\t\tvalp++;\n\t}\n\tif (chs & 2)\n\t\tchange |= update_amp_value(codec, nid, 1, dir, idx, ofs, *valp);\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_volume_put);\n\n \nstatic void get_ctl_amp_tlv(struct snd_kcontrol *kcontrol, unsigned int *tlv)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tbool min_mute = get_amp_min_mute(kcontrol);\n\tu32 caps, val1, val2;\n\n\tcaps = query_amp_caps(codec, nid, dir);\n\tval2 = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\n\tval2 = (val2 + 1) * 25;\n\tval1 = -((caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT);\n\tval1 += ofs;\n\tval1 = ((int)val1) * ((int)val2);\n\tif (min_mute || (caps & AC_AMPCAP_MIN_MUTE))\n\t\tval2 |= TLV_DB_SCALE_MUTE;\n\ttlv[SNDRV_CTL_TLVO_TYPE] = SNDRV_CTL_TLVT_DB_SCALE;\n\ttlv[SNDRV_CTL_TLVO_LEN] = 2 * sizeof(unsigned int);\n\ttlv[SNDRV_CTL_TLVO_DB_SCALE_MIN] = val1;\n\ttlv[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP] = val2;\n}\n\n \nint snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t  unsigned int size, unsigned int __user *_tlv)\n{\n\tunsigned int tlv[4];\n\n\tif (size < 4 * sizeof(unsigned int))\n\t\treturn -ENOMEM;\n\tget_ctl_amp_tlv(kcontrol, tlv);\n\tif (copy_to_user(_tlv, tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_tlv);\n\n \nvoid snd_hda_set_vmaster_tlv(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t     unsigned int *tlv)\n{\n\tu32 caps;\n\tint nums, step;\n\n\tcaps = query_amp_caps(codec, nid, dir);\n\tnums = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\n\tstep = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\n\tstep = (step + 1) * 25;\n\ttlv[SNDRV_CTL_TLVO_TYPE] = SNDRV_CTL_TLVT_DB_SCALE;\n\ttlv[SNDRV_CTL_TLVO_LEN] = 2 * sizeof(unsigned int);\n\ttlv[SNDRV_CTL_TLVO_DB_SCALE_MIN] = -nums * step;\n\ttlv[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP] = step;\n}\nEXPORT_SYMBOL_GPL(snd_hda_set_vmaster_tlv);\n\n \nstatic struct snd_kcontrol *\nfind_mixer_ctl(struct hda_codec *codec, const char *name, int dev, int idx)\n{\n\tstruct snd_ctl_elem_id id;\n\tmemset(&id, 0, sizeof(id));\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tid.device = dev;\n\tid.index = idx;\n\tif (snd_BUG_ON(strlen(name) >= sizeof(id.name)))\n\t\treturn NULL;\n\tstrcpy(id.name, name);\n\treturn snd_ctl_find_id(codec->card, &id);\n}\n\n \nstruct snd_kcontrol *snd_hda_find_mixer_ctl(struct hda_codec *codec,\n\t\t\t\t\t    const char *name)\n{\n\treturn find_mixer_ctl(codec, name, 0, 0);\n}\nEXPORT_SYMBOL_GPL(snd_hda_find_mixer_ctl);\n\nstatic int find_empty_mixer_ctl_idx(struct hda_codec *codec, const char *name,\n\t\t\t\t    int start_idx)\n{\n\tint i, idx;\n\t \n\tfor (i = 0, idx = start_idx; i < 16; i++, idx++) {\n\t\tif (!find_mixer_ctl(codec, name, 0, idx))\n\t\t\treturn idx;\n\t}\n\treturn -EBUSY;\n}\n\n \nint snd_hda_ctl_add(struct hda_codec *codec, hda_nid_t nid,\n\t\t    struct snd_kcontrol *kctl)\n{\n\tint err;\n\tunsigned short flags = 0;\n\tstruct hda_nid_item *item;\n\n\tif (kctl->id.subdevice & HDA_SUBDEV_AMP_FLAG) {\n\t\tflags |= HDA_NID_ITEM_AMP;\n\t\tif (nid == 0)\n\t\t\tnid = get_amp_nid_(kctl->private_value);\n\t}\n\tif ((kctl->id.subdevice & HDA_SUBDEV_NID_FLAG) != 0 && nid == 0)\n\t\tnid = kctl->id.subdevice & 0xffff;\n\tif (kctl->id.subdevice & (HDA_SUBDEV_NID_FLAG|HDA_SUBDEV_AMP_FLAG))\n\t\tkctl->id.subdevice = 0;\n\terr = snd_ctl_add(codec->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\titem = snd_array_new(&codec->mixers);\n\tif (!item)\n\t\treturn -ENOMEM;\n\titem->kctl = kctl;\n\titem->nid = nid;\n\titem->flags = flags;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_ctl_add);\n\n \nint snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,\n\t\t    unsigned int index, hda_nid_t nid)\n{\n\tstruct hda_nid_item *item;\n\n\tif (nid > 0) {\n\t\titem = snd_array_new(&codec->nids);\n\t\tif (!item)\n\t\t\treturn -ENOMEM;\n\t\titem->kctl = kctl;\n\t\titem->index = index;\n\t\titem->nid = nid;\n\t\treturn 0;\n\t}\n\tcodec_err(codec, \"no NID for mapping control %s:%d:%d\\n\",\n\t\t  kctl->id.name, kctl->id.index, index);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_nid);\n\n \nvoid snd_hda_ctls_clear(struct hda_codec *codec)\n{\n\tint i;\n\tstruct hda_nid_item *items = codec->mixers.list;\n\n\tfor (i = 0; i < codec->mixers.used; i++)\n\t\tsnd_ctl_remove(codec->card, items[i].kctl);\n\tsnd_array_free(&codec->mixers);\n\tsnd_array_free(&codec->nids);\n}\n\n \nint snd_hda_lock_devices(struct hda_bus *bus)\n{\n\tstruct snd_card *card = bus->card;\n\tstruct hda_codec *codec;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown)\n\t\tgoto err_unlock;\n\tcard->shutdown = 1;\n\tif (!list_empty(&card->ctl_files))\n\t\tgoto err_clear;\n\n\tlist_for_each_codec(codec, bus) {\n\t\tstruct hda_pcm *cpcm;\n\t\tlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\n\t\t\tif (!cpcm->pcm)\n\t\t\t\tcontinue;\n\t\t\tif (cpcm->pcm->streams[0].substream_opened ||\n\t\t\t    cpcm->pcm->streams[1].substream_opened)\n\t\t\t\tgoto err_clear;\n\t\t}\n\t}\n\tspin_unlock(&card->files_lock);\n\treturn 0;\n\n err_clear:\n\tcard->shutdown = 0;\n err_unlock:\n\tspin_unlock(&card->files_lock);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_lock_devices);\n\n \nvoid snd_hda_unlock_devices(struct hda_bus *bus)\n{\n\tstruct snd_card *card = bus->card;\n\n\tspin_lock(&card->files_lock);\n\tcard->shutdown = 0;\n\tspin_unlock(&card->files_lock);\n}\nEXPORT_SYMBOL_GPL(snd_hda_unlock_devices);\n\n \nint snd_hda_codec_reset(struct hda_codec *codec)\n{\n\tstruct hda_bus *bus = codec->bus;\n\n\tif (snd_hda_lock_devices(bus) < 0)\n\t\treturn -EBUSY;\n\n\t \n\tdevice_release_driver(hda_codec_dev(codec));\n\n\t \n\tsnd_hda_unlock_devices(bus);\n\treturn 0;\n}\n\ntypedef int (*map_follower_func_t)(struct hda_codec *, void *, struct snd_kcontrol *);\n\n \nstatic int map_followers(struct hda_codec *codec, const char * const *followers,\n\t\t\t const char *suffix, map_follower_func_t func, void *data)\n{\n\tstruct hda_nid_item *items;\n\tconst char * const *s;\n\tint i, err;\n\n\titems = codec->mixers.list;\n\tfor (i = 0; i < codec->mixers.used; i++) {\n\t\tstruct snd_kcontrol *sctl = items[i].kctl;\n\t\tif (!sctl || sctl->id.iface != SNDRV_CTL_ELEM_IFACE_MIXER)\n\t\t\tcontinue;\n\t\tfor (s = followers; *s; s++) {\n\t\t\tchar tmpname[sizeof(sctl->id.name)];\n\t\t\tconst char *name = *s;\n\t\t\tif (suffix) {\n\t\t\t\tsnprintf(tmpname, sizeof(tmpname), \"%s %s\",\n\t\t\t\t\t name, suffix);\n\t\t\t\tname = tmpname;\n\t\t\t}\n\t\t\tif (!strcmp(sctl->id.name, name)) {\n\t\t\t\terr = func(codec, data, sctl);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_follower_present(struct hda_codec *codec,\n\t\t\t\t  void *data, struct snd_kcontrol *sctl)\n{\n\treturn 1;\n}\n\n \nstatic int put_kctl_with_value(struct snd_kcontrol *kctl, int val)\n{\n\tstruct snd_ctl_elem_value *ucontrol;\n\tucontrol = kzalloc(sizeof(*ucontrol), GFP_KERNEL);\n\tif (!ucontrol)\n\t\treturn -ENOMEM;\n\tucontrol->value.integer.value[0] = val;\n\tucontrol->value.integer.value[1] = val;\n\tkctl->put(kctl, ucontrol);\n\tkfree(ucontrol);\n\treturn 0;\n}\n\nstruct follower_init_arg {\n\tstruct hda_codec *codec;\n\tint step;\n};\n\n \nstatic int init_follower_0dB(struct snd_kcontrol *follower,\n\t\t\t     struct snd_kcontrol *kctl,\n\t\t\t     void *_arg)\n{\n\tstruct follower_init_arg *arg = _arg;\n\tint _tlv[4];\n\tconst int *tlv = NULL;\n\tint step;\n\tint val;\n\n\tif (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (kctl->tlv.c != snd_hda_mixer_amp_tlv) {\n\t\t\tcodec_err(arg->codec,\n\t\t\t\t  \"Unexpected TLV callback for follower %s:%d\\n\",\n\t\t\t\t  kctl->id.name, kctl->id.index);\n\t\t\treturn 0;  \n\t\t}\n\t\tget_ctl_amp_tlv(kctl, _tlv);\n\t\ttlv = _tlv;\n\t} else if (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_READ)\n\t\ttlv = kctl->tlv.p;\n\n\tif (!tlv || tlv[SNDRV_CTL_TLVO_TYPE] != SNDRV_CTL_TLVT_DB_SCALE)\n\t\treturn 0;\n\n\tstep = tlv[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP];\n\tstep &= ~TLV_DB_SCALE_MUTE;\n\tif (!step)\n\t\treturn 0;\n\tif (arg->step && arg->step != step) {\n\t\tcodec_err(arg->codec,\n\t\t\t  \"Mismatching dB step for vmaster follower (%d!=%d)\\n\",\n\t\t\t  arg->step, step);\n\t\treturn 0;\n\t}\n\n\targ->step = step;\n\tval = -tlv[SNDRV_CTL_TLVO_DB_SCALE_MIN] / step;\n\tif (val > 0) {\n\t\tput_kctl_with_value(follower, val);\n\t\treturn val;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int init_follower_unmute(struct snd_kcontrol *follower,\n\t\t\t\tstruct snd_kcontrol *kctl,\n\t\t\t\tvoid *_arg)\n{\n\treturn put_kctl_with_value(follower, 1);\n}\n\nstatic int add_follower(struct hda_codec *codec,\n\t\t\tvoid *data, struct snd_kcontrol *follower)\n{\n\treturn snd_ctl_add_follower(data, follower);\n}\n\n \nint __snd_hda_add_vmaster(struct hda_codec *codec, char *name,\n\t\t\t  unsigned int *tlv, const char * const *followers,\n\t\t\t  const char *suffix, bool init_follower_vol,\n\t\t\t  unsigned int access, struct snd_kcontrol **ctl_ret)\n{\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\tif (ctl_ret)\n\t\t*ctl_ret = NULL;\n\n\terr = map_followers(codec, followers, suffix, check_follower_present, NULL);\n\tif (err != 1) {\n\t\tcodec_dbg(codec, \"No follower found for %s\\n\", name);\n\t\treturn 0;\n\t}\n\tkctl = snd_ctl_make_virtual_master(name, tlv);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->vd[0].access |= access;\n\terr = snd_hda_ctl_add(codec, 0, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = map_followers(codec, followers, suffix, add_follower, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tput_kctl_with_value(kctl, 0);\n\tif (init_follower_vol) {\n\t\tstruct follower_init_arg arg = {\n\t\t\t.codec = codec,\n\t\t\t.step = 0,\n\t\t};\n\t\tsnd_ctl_apply_vmaster_followers(kctl,\n\t\t\t\t\t\ttlv ? init_follower_0dB : init_follower_unmute,\n\t\t\t\t\t\t&arg);\n\t}\n\n\tif (ctl_ret)\n\t\t*ctl_ret = kctl;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__snd_hda_add_vmaster);\n\n \nstatic void vmaster_hook(void *private_data, int enabled)\n{\n\tstruct hda_vmaster_mute_hook *hook = private_data;\n\n\thook->hook(hook->codec, enabled);\n}\n\n \nint snd_hda_add_vmaster_hook(struct hda_codec *codec,\n\t\t\t     struct hda_vmaster_mute_hook *hook)\n{\n\tif (!hook->hook || !hook->sw_kctl)\n\t\treturn 0;\n\thook->codec = codec;\n\tsnd_ctl_add_vmaster_hook(hook->sw_kctl, vmaster_hook, hook);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_vmaster_hook);\n\n \nvoid snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)\n{\n\tif (!hook->hook || !hook->codec)\n\t\treturn;\n\t \n\tif (hook->codec->bus->shutdown)\n\t\treturn;\n\tsnd_ctl_sync_vmaster_hook(hook->sw_kctl);\n}\nEXPORT_SYMBOL_GPL(snd_hda_sync_vmaster_hook);\n\n\n \nint snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint chs = get_amp_channels(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_switch_info);\n\n \nint snd_hda_mixer_amp_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\tif (chs & 1)\n\t\t*valp++ = (snd_hda_codec_amp_read(codec, nid, 0, dir, idx) &\n\t\t\t   HDA_AMP_MUTE) ? 0 : 1;\n\tif (chs & 2)\n\t\t*valp = (snd_hda_codec_amp_read(codec, nid, 1, dir, idx) &\n\t\t\t HDA_AMP_MUTE) ? 0 : 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_switch_get);\n\n \nint snd_hda_mixer_amp_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\tint change = 0;\n\n\tif (chs & 1) {\n\t\tchange = snd_hda_codec_amp_update(codec, nid, 0, dir, idx,\n\t\t\t\t\t\t  HDA_AMP_MUTE,\n\t\t\t\t\t\t  *valp ? 0 : HDA_AMP_MUTE);\n\t\tvalp++;\n\t}\n\tif (chs & 2)\n\t\tchange |= snd_hda_codec_amp_update(codec, nid, 1, dir, idx,\n\t\t\t\t\t\t   HDA_AMP_MUTE,\n\t\t\t\t\t\t   *valp ? 0 : HDA_AMP_MUTE);\n\thda_call_check_power_status(codec, nid);\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_switch_put);\n\n \n\nstatic int snd_hda_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_hda_spdif_cmask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t   IEC958_AES0_NONAUDIO |\n\t\t\t\t\t   IEC958_AES0_CON_EMPHASIS_5015 |\n\t\t\t\t\t   IEC958_AES0_CON_NOT_COPYRIGHT;\n\tucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |\n\t\t\t\t\t   IEC958_AES1_CON_ORIGINAL;\n\treturn 0;\n}\n\nstatic int snd_hda_spdif_pmask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t   IEC958_AES0_NONAUDIO |\n\t\t\t\t\t   IEC958_AES0_PRO_EMPHASIS_5015;\n\treturn 0;\n}\n\nstatic int snd_hda_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\tstruct hda_spdif_out *spdif;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tucontrol->value.iec958.status[0] = spdif->status & 0xff;\n\tucontrol->value.iec958.status[1] = (spdif->status >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (spdif->status >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (spdif->status >> 24) & 0xff;\n\tmutex_unlock(&codec->spdif_mutex);\n\n\treturn 0;\n}\n\n \nstatic unsigned short convert_from_spdif_status(unsigned int sbits)\n{\n\tunsigned short val = 0;\n\n\tif (sbits & IEC958_AES0_PROFESSIONAL)\n\t\tval |= AC_DIG1_PROFESSIONAL;\n\tif (sbits & IEC958_AES0_NONAUDIO)\n\t\tval |= AC_DIG1_NONAUDIO;\n\tif (sbits & IEC958_AES0_PROFESSIONAL) {\n\t\tif ((sbits & IEC958_AES0_PRO_EMPHASIS) ==\n\t\t    IEC958_AES0_PRO_EMPHASIS_5015)\n\t\t\tval |= AC_DIG1_EMPHASIS;\n\t} else {\n\t\tif ((sbits & IEC958_AES0_CON_EMPHASIS) ==\n\t\t    IEC958_AES0_CON_EMPHASIS_5015)\n\t\t\tval |= AC_DIG1_EMPHASIS;\n\t\tif (!(sbits & IEC958_AES0_CON_NOT_COPYRIGHT))\n\t\t\tval |= AC_DIG1_COPYRIGHT;\n\t\tif (sbits & (IEC958_AES1_CON_ORIGINAL << 8))\n\t\t\tval |= AC_DIG1_LEVEL;\n\t\tval |= sbits & (IEC958_AES1_CON_CATEGORY << 8);\n\t}\n\treturn val;\n}\n\n \nstatic unsigned int convert_to_spdif_status(unsigned short val)\n{\n\tunsigned int sbits = 0;\n\n\tif (val & AC_DIG1_NONAUDIO)\n\t\tsbits |= IEC958_AES0_NONAUDIO;\n\tif (val & AC_DIG1_PROFESSIONAL)\n\t\tsbits |= IEC958_AES0_PROFESSIONAL;\n\tif (sbits & IEC958_AES0_PROFESSIONAL) {\n\t\tif (val & AC_DIG1_EMPHASIS)\n\t\t\tsbits |= IEC958_AES0_PRO_EMPHASIS_5015;\n\t} else {\n\t\tif (val & AC_DIG1_EMPHASIS)\n\t\t\tsbits |= IEC958_AES0_CON_EMPHASIS_5015;\n\t\tif (!(val & AC_DIG1_COPYRIGHT))\n\t\t\tsbits |= IEC958_AES0_CON_NOT_COPYRIGHT;\n\t\tif (val & AC_DIG1_LEVEL)\n\t\t\tsbits |= (IEC958_AES1_CON_ORIGINAL << 8);\n\t\tsbits |= val & (0x7f << 8);\n\t}\n\treturn sbits;\n}\n\n \nstatic void set_dig_out(struct hda_codec *codec, hda_nid_t nid,\n\t\t\tint mask, int val)\n{\n\tconst hda_nid_t *d;\n\n\tsnd_hdac_regmap_update(&codec->core, nid, AC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t       mask, val);\n\td = codec->follower_dig_outs;\n\tif (!d)\n\t\treturn;\n\tfor (; *d; d++)\n\t\tsnd_hdac_regmap_update(&codec->core, *d,\n\t\t\t\t       AC_VERB_SET_DIGI_CONVERT_1, mask, val);\n}\n\nstatic inline void set_dig_out_convert(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t       int dig1, int dig2)\n{\n\tunsigned int mask = 0;\n\tunsigned int val = 0;\n\n\tif (dig1 != -1) {\n\t\tmask |= 0xff;\n\t\tval = dig1;\n\t}\n\tif (dig2 != -1) {\n\t\tmask |= 0xff00;\n\t\tval |= dig2 << 8;\n\t}\n\tset_dig_out(codec, nid, mask, val);\n}\n\nstatic int snd_hda_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\tstruct hda_spdif_out *spdif;\n\thda_nid_t nid;\n\tunsigned short val;\n\tint change;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tnid = spdif->nid;\n\tspdif->status = ucontrol->value.iec958.status[0] |\n\t\t((unsigned int)ucontrol->value.iec958.status[1] << 8) |\n\t\t((unsigned int)ucontrol->value.iec958.status[2] << 16) |\n\t\t((unsigned int)ucontrol->value.iec958.status[3] << 24);\n\tval = convert_from_spdif_status(spdif->status);\n\tval |= spdif->ctls & 1;\n\tchange = spdif->ctls != val;\n\tspdif->ctls = val;\n\tif (change && nid != (u16)-1)\n\t\tset_dig_out_convert(codec, nid, val & 0xff, (val >> 8) & 0xff);\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn change;\n}\n\n#define snd_hda_spdif_out_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_hda_spdif_out_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\tstruct hda_spdif_out *spdif;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tucontrol->value.integer.value[0] = spdif->ctls & AC_DIG1_ENABLE;\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\n\nstatic inline void set_spdif_ctls(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t  int dig1, int dig2)\n{\n\tset_dig_out_convert(codec, nid, dig1, dig2);\n\t \n\tif ((get_wcaps(codec, nid) & AC_WCAP_OUT_AMP) &&\n\t    (dig1 & AC_DIG1_ENABLE))\n\t\tsnd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,\n\t\t\t\t\t    HDA_AMP_MUTE, 0);\n}\n\nstatic int snd_hda_spdif_out_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\tstruct hda_spdif_out *spdif;\n\thda_nid_t nid;\n\tunsigned short val;\n\tint change;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tnid = spdif->nid;\n\tval = spdif->ctls & ~AC_DIG1_ENABLE;\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= AC_DIG1_ENABLE;\n\tchange = spdif->ctls != val;\n\tspdif->ctls = val;\n\tif (change && nid != (u16)-1)\n\t\tset_spdif_ctls(codec, nid, val & 0xff, -1);\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new dig_mixes[] = {\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.info = snd_hda_spdif_mask_info,\n\t\t.get = snd_hda_spdif_cmask_get,\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PRO_MASK),\n\t\t.info = snd_hda_spdif_mask_info,\n\t\t.get = snd_hda_spdif_pmask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = snd_hda_spdif_mask_info,\n\t\t.get = snd_hda_spdif_default_get,\n\t\t.put = snd_hda_spdif_default_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, SWITCH),\n\t\t.info = snd_hda_spdif_out_switch_info,\n\t\t.get = snd_hda_spdif_out_switch_get,\n\t\t.put = snd_hda_spdif_out_switch_put,\n\t},\n\t{ }  \n};\n\n \nint snd_hda_create_dig_out_ctls(struct hda_codec *codec,\n\t\t\t\thda_nid_t associated_nid,\n\t\t\t\thda_nid_t cvt_nid,\n\t\t\t\tint type)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\tconst struct snd_kcontrol_new *dig_mix;\n\tint idx = 0;\n\tint val = 0;\n\tconst int spdif_index = 16;\n\tstruct hda_spdif_out *spdif;\n\tstruct hda_bus *bus = codec->bus;\n\n\tif (bus->primary_dig_out_type == HDA_PCM_TYPE_HDMI &&\n\t    type == HDA_PCM_TYPE_SPDIF) {\n\t\tidx = spdif_index;\n\t} else if (bus->primary_dig_out_type == HDA_PCM_TYPE_SPDIF &&\n\t\t   type == HDA_PCM_TYPE_HDMI) {\n\t\t \n\t\tfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\n\t\t\tstruct snd_ctl_elem_id id;\n\n\t\t\tkctl = find_mixer_ctl(codec, dig_mix->name, 0, 0);\n\t\t\tif (!kctl)\n\t\t\t\tbreak;\n\t\t\tid = kctl->id;\n\t\t\tid.index = spdif_index;\n\t\t\tsnd_ctl_rename_id(codec->card, &kctl->id, &id);\n\t\t}\n\t\tbus->primary_dig_out_type = HDA_PCM_TYPE_HDMI;\n\t}\n\tif (!bus->primary_dig_out_type)\n\t\tbus->primary_dig_out_type = type;\n\n\tidx = find_empty_mixer_ctl_idx(codec, \"IEC958 Playback Switch\", idx);\n\tif (idx < 0) {\n\t\tcodec_err(codec, \"too many IEC958 outputs\\n\");\n\t\treturn -EBUSY;\n\t}\n\tspdif = snd_array_new(&codec->spdif_out);\n\tif (!spdif)\n\t\treturn -ENOMEM;\n\tfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\n\t\tkctl = snd_ctl_new1(dig_mix, codec);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.index = idx;\n\t\tkctl->private_value = codec->spdif_out.used - 1;\n\t\terr = snd_hda_ctl_add(codec, associated_nid, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tspdif->nid = cvt_nid;\n\tsnd_hdac_regmap_read(&codec->core, cvt_nid,\n\t\t\t     AC_VERB_GET_DIGI_CONVERT_1, &val);\n\tspdif->ctls = val;\n\tspdif->status = convert_to_spdif_status(spdif->ctls);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_create_dig_out_ctls);\n\n \nstruct hda_spdif_out *snd_hda_spdif_out_of_nid(struct hda_codec *codec,\n\t\t\t\t\t       hda_nid_t nid)\n{\n\tstruct hda_spdif_out *spdif;\n\tint i;\n\n\tsnd_array_for_each(&codec->spdif_out, i, spdif) {\n\t\tif (spdif->nid == nid)\n\t\t\treturn spdif;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_spdif_out_of_nid);\n\n \nvoid snd_hda_spdif_ctls_unassign(struct hda_codec *codec, int idx)\n{\n\tstruct hda_spdif_out *spdif;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tspdif->nid = (u16)-1;\n\tmutex_unlock(&codec->spdif_mutex);\n}\nEXPORT_SYMBOL_GPL(snd_hda_spdif_ctls_unassign);\n\n \nvoid snd_hda_spdif_ctls_assign(struct hda_codec *codec, int idx, hda_nid_t nid)\n{\n\tstruct hda_spdif_out *spdif;\n\tunsigned short val;\n\n\tif (WARN_ON(codec->spdif_out.used <= idx))\n\t\treturn;\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_array_elem(&codec->spdif_out, idx);\n\tif (spdif->nid != nid) {\n\t\tspdif->nid = nid;\n\t\tval = spdif->ctls;\n\t\tset_spdif_ctls(codec, nid, val & 0xff, (val >> 8) & 0xff);\n\t}\n\tmutex_unlock(&codec->spdif_mutex);\n}\nEXPORT_SYMBOL_GPL(snd_hda_spdif_ctls_assign);\n\n \nstatic int spdif_share_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = mout->share_spdif;\n\treturn 0;\n}\n\nstatic int spdif_share_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\n\tmout->share_spdif = !!ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new spdif_share_sw = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"IEC958 Default PCM Playback Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = spdif_share_sw_get,\n\t.put = spdif_share_sw_put,\n};\n\n \nint snd_hda_create_spdif_share_sw(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (!mout->dig_out_nid)\n\t\treturn 0;\n\n\tkctl = snd_ctl_new1(&spdif_share_sw, mout);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\t \n\treturn snd_hda_ctl_add(codec, mout->dig_out_nid, kctl);\n}\nEXPORT_SYMBOL_GPL(snd_hda_create_spdif_share_sw);\n\n \n\n#define snd_hda_spdif_in_switch_info\tsnd_hda_spdif_out_switch_info\n\nstatic int snd_hda_spdif_in_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = codec->spdif_in_enable;\n\treturn 0;\n}\n\nstatic int snd_hda_spdif_in_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int val = !!ucontrol->value.integer.value[0];\n\tint change;\n\n\tmutex_lock(&codec->spdif_mutex);\n\tchange = codec->spdif_in_enable != val;\n\tif (change) {\n\t\tcodec->spdif_in_enable = val;\n\t\tsnd_hdac_regmap_write(&codec->core, nid,\n\t\t\t\t      AC_VERB_SET_DIGI_CONVERT_1, val);\n\t}\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn change;\n}\n\nstatic int snd_hda_spdif_in_status_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = kcontrol->private_value;\n\tunsigned int val;\n\tunsigned int sbits;\n\n\tsnd_hdac_regmap_read(&codec->core, nid,\n\t\t\t     AC_VERB_GET_DIGI_CONVERT_1, &val);\n\tsbits = convert_to_spdif_status(val);\n\tucontrol->value.iec958.status[0] = sbits;\n\tucontrol->value.iec958.status[1] = sbits >> 8;\n\tucontrol->value.iec958.status[2] = sbits >> 16;\n\tucontrol->value.iec958.status[3] = sbits >> 24;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new dig_in_ctls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, SWITCH),\n\t\t.info = snd_hda_spdif_in_switch_info,\n\t\t.get = snd_hda_spdif_in_switch_get,\n\t\t.put = snd_hda_spdif_in_switch_put,\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.info = snd_hda_spdif_mask_info,\n\t\t.get = snd_hda_spdif_in_status_get,\n\t},\n\t{ }  \n};\n\n \nint snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\tconst struct snd_kcontrol_new *dig_mix;\n\tint idx;\n\n\tidx = find_empty_mixer_ctl_idx(codec, \"IEC958 Capture Switch\", 0);\n\tif (idx < 0) {\n\t\tcodec_err(codec, \"too many IEC958 inputs\\n\");\n\t\treturn -EBUSY;\n\t}\n\tfor (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {\n\t\tkctl = snd_ctl_new1(dig_mix, codec);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tkctl->private_value = nid;\n\t\terr = snd_hda_ctl_add(codec, nid, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tcodec->spdif_in_enable =\n\t\tsnd_hda_codec_read(codec, nid, 0,\n\t\t\t\t   AC_VERB_GET_DIGI_CONVERT_1, 0) &\n\t\tAC_DIG1_ENABLE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_create_spdif_in_ctls);\n\n \nvoid snd_hda_codec_set_power_to_all(struct hda_codec *codec, hda_nid_t fg,\n\t\t\t\t    unsigned int power_state)\n{\n\thda_nid_t nid;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int wcaps = get_wcaps(codec, nid);\n\t\tunsigned int state = power_state;\n\t\tif (!(wcaps & AC_WCAP_POWER))\n\t\t\tcontinue;\n\t\tif (codec->power_filter) {\n\t\t\tstate = codec->power_filter(codec, nid, power_state);\n\t\t\tif (state != power_state && power_state == AC_PWRST_D3)\n\t\t\t\tcontinue;\n\t\t}\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,\n\t\t\t\t    state);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_set_power_to_all);\n\n \nunsigned int snd_hda_codec_eapd_power_filter(struct hda_codec *codec,\n\t\t\t\t\t     hda_nid_t nid,\n\t\t\t\t\t     unsigned int power_state)\n{\n\tif (nid == codec->core.afg || nid == codec->core.mfg)\n\t\treturn power_state;\n\tif (power_state == AC_PWRST_D3 &&\n\t    get_wcaps_type(get_wcaps(codec, nid)) == AC_WID_PIN &&\n\t    (snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD)) {\n\t\tint eapd = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t      AC_VERB_GET_EAPD_BTLENABLE, 0);\n\t\tif (eapd & 0x02)\n\t\t\treturn AC_PWRST_D0;\n\t}\n\treturn power_state;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_eapd_power_filter);\n\n \nstatic unsigned int hda_set_power_state(struct hda_codec *codec,\n\t\t\t\t\tunsigned int power_state)\n{\n\thda_nid_t fg = codec->core.afg ? codec->core.afg : codec->core.mfg;\n\tint count;\n\tunsigned int state;\n\tint flags = 0;\n\n\t \n\tif (power_state == AC_PWRST_D3) {\n\t\tif (codec->depop_delay < 0)\n\t\t\tmsleep(codec_has_epss(codec) ? 10 : 100);\n\t\telse if (codec->depop_delay > 0)\n\t\t\tmsleep(codec->depop_delay);\n\t\tflags = HDA_RW_NO_RESPONSE_FALLBACK;\n\t}\n\n\t \n\tfor (count = 0; count < 10; count++) {\n\t\tif (codec->patch_ops.set_power_state)\n\t\t\tcodec->patch_ops.set_power_state(codec, fg,\n\t\t\t\t\t\t\t power_state);\n\t\telse {\n\t\t\tstate = power_state;\n\t\t\tif (codec->power_filter)\n\t\t\t\tstate = codec->power_filter(codec, fg, state);\n\t\t\tif (state == power_state || power_state != AC_PWRST_D3)\n\t\t\t\tsnd_hda_codec_read(codec, fg, flags,\n\t\t\t\t\t\t   AC_VERB_SET_POWER_STATE,\n\t\t\t\t\t\t   state);\n\t\t\tsnd_hda_codec_set_power_to_all(codec, fg, power_state);\n\t\t}\n\t\tstate = snd_hda_sync_power_state(codec, fg, power_state);\n\t\tif (!(state & AC_PWRST_ERROR))\n\t\t\tbreak;\n\t}\n\n\treturn state;\n}\n\n \nstatic void sync_power_up_states(struct hda_codec *codec)\n{\n\thda_nid_t nid;\n\n\t \n\tif (!codec->power_filter)\n\t\treturn;\n\n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int wcaps = get_wcaps(codec, nid);\n\t\tunsigned int target;\n\t\tif (!(wcaps & AC_WCAP_POWER))\n\t\t\tcontinue;\n\t\ttarget = codec->power_filter(codec, nid, AC_PWRST_D0);\n\t\tif (target == AC_PWRST_D0)\n\t\t\tcontinue;\n\t\tif (!snd_hda_check_power_state(codec, nid, target))\n\t\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_POWER_STATE, target);\n\t}\n}\n\n#ifdef CONFIG_SND_HDA_RECONFIG\n \nstatic void hda_exec_init_verbs(struct hda_codec *codec)\n{\n\tif (codec->init_verbs.list)\n\t\tsnd_hda_sequence_write(codec, codec->init_verbs.list);\n}\n#else\nstatic inline void hda_exec_init_verbs(struct hda_codec *codec) {}\n#endif\n\n#ifdef CONFIG_PM\n \nstatic void update_power_acct(struct hda_codec *codec, bool on)\n{\n\tunsigned long delta = jiffies - codec->power_jiffies;\n\n\tif (on)\n\t\tcodec->power_on_acct += delta;\n\telse\n\t\tcodec->power_off_acct += delta;\n\tcodec->power_jiffies += delta;\n}\n\nvoid snd_hda_update_power_acct(struct hda_codec *codec)\n{\n\tupdate_power_acct(codec, hda_codec_is_power_on(codec));\n}\n\n \nstatic unsigned int hda_call_codec_suspend(struct hda_codec *codec)\n{\n\tunsigned int state;\n\n\tsnd_hdac_enter_pm(&codec->core);\n\tif (codec->patch_ops.suspend)\n\t\tcodec->patch_ops.suspend(codec);\n\tif (!codec->no_stream_clean_at_suspend)\n\t\thda_cleanup_all_streams(codec);\n\tstate = hda_set_power_state(codec, AC_PWRST_D3);\n\tupdate_power_acct(codec, true);\n\tsnd_hdac_leave_pm(&codec->core);\n\treturn state;\n}\n\n \nstatic void hda_call_codec_resume(struct hda_codec *codec)\n{\n\tsnd_hdac_enter_pm(&codec->core);\n\tif (codec->core.regmap)\n\t\tregcache_mark_dirty(codec->core.regmap);\n\n\tcodec->power_jiffies = jiffies;\n\n\thda_set_power_state(codec, AC_PWRST_D0);\n\trestore_shutup_pins(codec);\n\thda_exec_init_verbs(codec);\n\tsnd_hda_jack_set_dirty_all(codec);\n\tif (codec->patch_ops.resume)\n\t\tcodec->patch_ops.resume(codec);\n\telse {\n\t\tif (codec->patch_ops.init)\n\t\t\tcodec->patch_ops.init(codec);\n\t\tsnd_hda_regmap_sync(codec);\n\t}\n\n\tif (codec->jackpoll_interval)\n\t\thda_jackpoll_work(&codec->jackpoll_work.work);\n\telse\n\t\tsnd_hda_jack_report_sync(codec);\n\tcodec->core.dev.power.power_state = PMSG_ON;\n\tsnd_hdac_leave_pm(&codec->core);\n}\n\nstatic int hda_codec_runtime_suspend(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\tunsigned int state;\n\n\t \n\tif (!codec->card)\n\t\treturn 0;\n\n\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\n\tstate = hda_call_codec_suspend(codec);\n\tif (codec->link_down_at_suspend ||\n\t    (codec_has_clkstop(codec) && codec_has_epss(codec) &&\n\t     (state & AC_PWRST_CLK_STOP_OK)))\n\t\tsnd_hdac_codec_link_down(&codec->core);\n\tsnd_hda_codec_display_power(codec, false);\n\n\tif (codec->bus->jackpoll_in_suspend &&\n\t\t(dev->power.power_state.event != PM_EVENT_SUSPEND))\n\t\tschedule_delayed_work(&codec->jackpoll_work,\n\t\t\t\t\tcodec->jackpoll_interval);\n\treturn 0;\n}\n\nstatic int hda_codec_runtime_resume(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\t \n\tif (!codec->card)\n\t\treturn 0;\n\n\tsnd_hda_codec_display_power(codec, true);\n\tsnd_hdac_codec_link_up(&codec->core);\n\thda_call_codec_resume(codec);\n\tpm_runtime_mark_last_busy(dev);\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\nstatic int hda_codec_pm_prepare(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\tdev->power.power_state = PMSG_SUSPEND;\n\treturn pm_runtime_suspended(dev);\n}\n\nstatic void hda_codec_pm_complete(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\t \n\tif (dev->power.power_state.event == PM_EVENT_SUSPEND)\n\t\tdev->power.power_state = PMSG_RESUME;\n\n\tif (pm_runtime_suspended(dev) && (codec->jackpoll_interval ||\n\t    hda_codec_need_resume(codec) || codec->forced_resume))\n\t\tpm_request_resume(dev);\n}\n\nstatic int hda_codec_pm_suspend(struct device *dev)\n{\n\tdev->power.power_state = PMSG_SUSPEND;\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int hda_codec_pm_resume(struct device *dev)\n{\n\tdev->power.power_state = PMSG_RESUME;\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int hda_codec_pm_freeze(struct device *dev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(dev);\n\n\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\tdev->power.power_state = PMSG_FREEZE;\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int hda_codec_pm_thaw(struct device *dev)\n{\n\tdev->power.power_state = PMSG_THAW;\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int hda_codec_pm_restore(struct device *dev)\n{\n\tdev->power.power_state = PMSG_RESTORE;\n\treturn pm_runtime_force_resume(dev);\n}\n#endif  \n\n \nconst struct dev_pm_ops hda_codec_driver_pm = {\n#ifdef CONFIG_PM_SLEEP\n\t.prepare = hda_codec_pm_prepare,\n\t.complete = hda_codec_pm_complete,\n\t.suspend = hda_codec_pm_suspend,\n\t.resume = hda_codec_pm_resume,\n\t.freeze = hda_codec_pm_freeze,\n\t.thaw = hda_codec_pm_thaw,\n\t.poweroff = hda_codec_pm_suspend,\n\t.restore = hda_codec_pm_restore,\n#endif  \n\tSET_RUNTIME_PM_OPS(hda_codec_runtime_suspend, hda_codec_runtime_resume,\n\t\t\t   NULL)\n};\n\n \nvoid snd_hda_codec_shutdown(struct hda_codec *codec)\n{\n\tstruct hda_pcm *cpcm;\n\n\t \n\tif (!codec->core.registered)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\tlist_for_each_entry(cpcm, &codec->pcm_list_head, list)\n\t\tsnd_pcm_suspend_all(cpcm->pcm);\n\n\tpm_runtime_force_suspend(hda_codec_dev(codec));\n\tpm_runtime_disable(hda_codec_dev(codec));\n}\n\n \nstatic int add_std_chmaps(struct hda_codec *codec)\n{\n\tstruct hda_pcm *pcm;\n\tint str, err;\n\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\n\t\tfor (str = 0; str < 2; str++) {\n\t\t\tstruct hda_pcm_stream *hinfo = &pcm->stream[str];\n\t\t\tstruct snd_pcm_chmap *chmap;\n\t\t\tconst struct snd_pcm_chmap_elem *elem;\n\n\t\t\tif (!pcm->pcm || pcm->own_chmap || !hinfo->substreams)\n\t\t\t\tcontinue;\n\t\t\telem = hinfo->chmap ? hinfo->chmap : snd_pcm_std_chmaps;\n\t\t\terr = snd_pcm_add_chmap_ctls(pcm->pcm, str, elem,\n\t\t\t\t\t\t     hinfo->channels_max,\n\t\t\t\t\t\t     0, &chmap);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nconst struct snd_pcm_chmap_elem snd_pcm_2_1_chmaps[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_LFE, SNDRV_CHMAP_LFE } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_2_1_chmaps);\n\nint snd_hda_codec_build_controls(struct hda_codec *codec)\n{\n\tint err = 0;\n\thda_exec_init_verbs(codec);\n\t \n\tif (codec->patch_ops.init)\n\t\terr = codec->patch_ops.init(codec);\n\tif (!err && codec->patch_ops.build_controls)\n\t\terr = codec->patch_ops.build_controls(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = add_std_chmaps(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (codec->jackpoll_interval)\n\t\thda_jackpoll_work(&codec->jackpoll_work.work);\n\telse\n\t\tsnd_hda_jack_report_sync(codec);  \n\tsync_power_up_states(codec);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_build_controls);\n\n \nstatic int hda_pcm_default_open_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t      struct hda_codec *codec,\n\t\t\t\t      struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int hda_pcm_default_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   unsigned int stream_tag,\n\t\t\t\t   unsigned int format,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\n\treturn 0;\n}\n\nstatic int hda_pcm_default_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\n\treturn 0;\n}\n\nstatic int set_pcm_default_values(struct hda_codec *codec,\n\t\t\t\t  struct hda_pcm_stream *info)\n{\n\tint err;\n\n\t \n\tif (info->nid && (!info->rates || !info->formats)) {\n\t\terr = snd_hda_query_supported_pcm(codec, info->nid,\n\t\t\t\tinfo->rates ? NULL : &info->rates,\n\t\t\t\tinfo->formats ? NULL : &info->formats,\n\t\t\t\tinfo->maxbps ? NULL : &info->maxbps);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (info->ops.open == NULL)\n\t\tinfo->ops.open = hda_pcm_default_open_close;\n\tif (info->ops.close == NULL)\n\t\tinfo->ops.close = hda_pcm_default_open_close;\n\tif (info->ops.prepare == NULL) {\n\t\tif (snd_BUG_ON(!info->nid))\n\t\t\treturn -EINVAL;\n\t\tinfo->ops.prepare = hda_pcm_default_prepare;\n\t}\n\tif (info->ops.cleanup == NULL) {\n\t\tif (snd_BUG_ON(!info->nid))\n\t\t\treturn -EINVAL;\n\t\tinfo->ops.cleanup = hda_pcm_default_cleanup;\n\t}\n\treturn 0;\n}\n\n \n \nint snd_hda_codec_prepare(struct hda_codec *codec,\n\t\t\t  struct hda_pcm_stream *hinfo,\n\t\t\t  unsigned int stream,\n\t\t\t  unsigned int format,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tint ret;\n\tmutex_lock(&codec->bus->prepare_mutex);\n\tif (hinfo->ops.prepare)\n\t\tret = hinfo->ops.prepare(hinfo, codec, stream, format,\n\t\t\t\t\t substream);\n\telse\n\t\tret = -ENODEV;\n\tif (ret >= 0)\n\t\tpurify_inactive_streams(codec);\n\tmutex_unlock(&codec->bus->prepare_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_prepare);\n\n \nvoid snd_hda_codec_cleanup(struct hda_codec *codec,\n\t\t\t   struct hda_pcm_stream *hinfo,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tmutex_lock(&codec->bus->prepare_mutex);\n\tif (hinfo->ops.cleanup)\n\t\thinfo->ops.cleanup(hinfo, codec, substream);\n\tmutex_unlock(&codec->bus->prepare_mutex);\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_cleanup);\n\n \nconst char *snd_hda_pcm_type_name[HDA_PCM_NTYPES] = {\n\t\"Audio\", \"SPDIF\", \"HDMI\", \"Modem\"\n};\n\n \nstatic int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)\n{\n\t \n\t \n\tstatic const int audio_idx[HDA_PCM_NTYPES][5] = {\n\t\t[HDA_PCM_TYPE_AUDIO] = { 0, 2, 4, 5, -1 },\n\t\t[HDA_PCM_TYPE_SPDIF] = { 1, -1 },\n\t\t[HDA_PCM_TYPE_HDMI]  = { 3, 7, 8, 9, -1 },\n\t\t[HDA_PCM_TYPE_MODEM] = { 6, -1 },\n\t};\n\tint i;\n\n\tif (type >= HDA_PCM_NTYPES) {\n\t\tdev_err(bus->card->dev, \"Invalid PCM type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; audio_idx[type][i] >= 0; i++) {\n#ifndef CONFIG_SND_DYNAMIC_MINORS\n\t\tif (audio_idx[type][i] >= 8)\n\t\t\tbreak;\n#endif\n\t\tif (!test_and_set_bit(audio_idx[type][i], bus->pcm_dev_bits))\n\t\t\treturn audio_idx[type][i];\n\t}\n\n#ifdef CONFIG_SND_DYNAMIC_MINORS\n\t \n\tfor (i = 10; i < 32; i++) {\n\t\tif (!test_and_set_bit(i, bus->pcm_dev_bits))\n\t\t\treturn i;\n\t}\n#endif\n\n\tdev_warn(bus->card->dev, \"Too many %s devices\\n\",\n\t\tsnd_hda_pcm_type_name[type]);\n#ifndef CONFIG_SND_DYNAMIC_MINORS\n\tdev_warn(bus->card->dev,\n\t\t \"Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\\n\");\n#endif\n\treturn -EAGAIN;\n}\n\n \nint snd_hda_codec_parse_pcms(struct hda_codec *codec)\n{\n\tstruct hda_pcm *cpcm;\n\tint err;\n\n\tif (!list_empty(&codec->pcm_list_head))\n\t\treturn 0;  \n\n\tif (!codec->patch_ops.build_pcms)\n\t\treturn 0;\n\n\terr = codec->patch_ops.build_pcms(codec);\n\tif (err < 0) {\n\t\tcodec_err(codec, \"cannot build PCMs for #%d (error %d)\\n\",\n\t\t\t  codec->core.addr, err);\n\t\treturn err;\n\t}\n\n\tlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\n\t\tint stream;\n\n\t\tfor (stream = 0; stream < 2; stream++) {\n\t\t\tstruct hda_pcm_stream *info = &cpcm->stream[stream];\n\n\t\t\tif (!info->substreams)\n\t\t\t\tcontinue;\n\t\t\terr = set_pcm_default_values(codec, info);\n\t\t\tif (err < 0) {\n\t\t\t\tcodec_warn(codec,\n\t\t\t\t\t   \"fail to setup default for PCM %s\\n\",\n\t\t\t\t\t   cpcm->name);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_parse_pcms);\n\n \nint snd_hda_codec_build_pcms(struct hda_codec *codec)\n{\n\tstruct hda_bus *bus = codec->bus;\n\tstruct hda_pcm *cpcm;\n\tint dev, err;\n\n\terr = snd_hda_codec_parse_pcms(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\n\t\tif (cpcm->pcm)\n\t\t\tcontinue;  \n\t\tif (!cpcm->stream[0].substreams && !cpcm->stream[1].substreams)\n\t\t\tcontinue;  \n\n\t\tdev = get_empty_pcm_device(bus, cpcm->pcm_type);\n\t\tif (dev < 0) {\n\t\t\tcpcm->device = SNDRV_PCM_INVALID_DEVICE;\n\t\t\tcontinue;  \n\t\t}\n\t\tcpcm->device = dev;\n\t\terr =  snd_hda_attach_pcm_stream(bus, codec, cpcm);\n\t\tif (err < 0) {\n\t\t\tcodec_err(codec,\n\t\t\t\t  \"cannot attach PCM stream %d for codec #%d\\n\",\n\t\t\t\t  dev, codec->core.addr);\n\t\t\tcontinue;  \n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint snd_hda_add_new_ctls(struct hda_codec *codec,\n\t\t\t const struct snd_kcontrol_new *knew)\n{\n\tint err;\n\n\tfor (; knew->name; knew++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tint addr = 0, idx = 0;\n\t\tif (knew->iface == (__force snd_ctl_elem_iface_t)-1)\n\t\t\tcontinue;  \n\t\tfor (;;) {\n\t\t\tkctl = snd_ctl_new1(knew, codec);\n\t\t\tif (!kctl)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tif (addr > 0 && codec->ctl_dev_id)\n\t\t\t\tkctl->id.device = addr;\n\t\t\tif (idx > 0)\n\t\t\t\tkctl->id.index = idx;\n\t\t\terr = snd_hda_ctl_add(codec, 0, kctl);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (!addr && codec->core.addr) {\n\t\t\t\taddr = codec->core.addr;\n\t\t\t\tif (!codec->ctl_dev_id)\n\t\t\t\t\tidx += 10 * addr;\n\t\t\t} else if (!idx && !knew->index) {\n\t\t\t\tidx = find_empty_mixer_ctl_idx(codec,\n\t\t\t\t\t\t\t       knew->name, 0);\n\t\t\t\tif (idx <= 0)\n\t\t\t\t\treturn err;\n\t\t\t} else\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_new_ctls);\n\n#ifdef CONFIG_PM\n \nvoid snd_hda_codec_set_power_save(struct hda_codec *codec, int delay)\n{\n\tstruct device *dev = hda_codec_dev(codec);\n\n\tif (delay == 0 && codec->auto_runtime_pm)\n\t\tdelay = 3000;\n\n\tif (delay > 0) {\n\t\tpm_runtime_set_autosuspend_delay(dev, delay);\n\t\tpm_runtime_use_autosuspend(dev);\n\t\tpm_runtime_allow(dev);\n\t\tif (!pm_runtime_suspended(dev))\n\t\t\tpm_runtime_mark_last_busy(dev);\n\t} else {\n\t\tpm_runtime_dont_use_autosuspend(dev);\n\t\tpm_runtime_forbid(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_codec_set_power_save);\n\n \nvoid snd_hda_set_power_save(struct hda_bus *bus, int delay)\n{\n\tstruct hda_codec *c;\n\n\tlist_for_each_codec(c, bus)\n\t\tsnd_hda_codec_set_power_save(c, delay);\n}\nEXPORT_SYMBOL_GPL(snd_hda_set_power_save);\n\n \nint snd_hda_check_amp_list_power(struct hda_codec *codec,\n\t\t\t\t struct hda_loopback_check *check,\n\t\t\t\t hda_nid_t nid)\n{\n\tconst struct hda_amp_list *p;\n\tint ch, v;\n\n\tif (!check->amplist)\n\t\treturn 0;\n\tfor (p = check->amplist; p->nid; p++) {\n\t\tif (p->nid == nid)\n\t\t\tbreak;\n\t}\n\tif (!p->nid)\n\t\treturn 0;  \n\n\tfor (p = check->amplist; p->nid; p++) {\n\t\tfor (ch = 0; ch < 2; ch++) {\n\t\t\tv = snd_hda_codec_amp_read(codec, p->nid, ch, p->dir,\n\t\t\t\t\t\t   p->idx);\n\t\t\tif (!(v & HDA_AMP_MUTE) && v > 0) {\n\t\t\t\tif (!check->power_on) {\n\t\t\t\t\tcheck->power_on = 1;\n\t\t\t\t\tsnd_hda_power_up_pm(codec);\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (check->power_on) {\n\t\tcheck->power_on = 0;\n\t\tsnd_hda_power_down_pm(codec);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_check_amp_list_power);\n#endif\n\n \n\n \nint snd_hda_input_mux_info(const struct hda_input_mux *imux,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int index;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = imux->num_items;\n\tif (!imux->num_items)\n\t\treturn 0;\n\tindex = uinfo->value.enumerated.item;\n\tif (index >= imux->num_items)\n\t\tindex = imux->num_items - 1;\n\tstrcpy(uinfo->value.enumerated.name, imux->items[index].label);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_input_mux_info);\n\n \nint snd_hda_input_mux_put(struct hda_codec *codec,\n\t\t\t  const struct hda_input_mux *imux,\n\t\t\t  struct snd_ctl_elem_value *ucontrol,\n\t\t\t  hda_nid_t nid,\n\t\t\t  unsigned int *cur_val)\n{\n\tunsigned int idx;\n\n\tif (!imux->num_items)\n\t\treturn 0;\n\tidx = ucontrol->value.enumerated.item[0];\n\tif (idx >= imux->num_items)\n\t\tidx = imux->num_items - 1;\n\tif (*cur_val == idx)\n\t\treturn 0;\n\tsnd_hda_codec_write_cache(codec, nid, 0, AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t  imux->items[idx].index);\n\t*cur_val = idx;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_input_mux_put);\n\n\n \nint snd_hda_enum_helper_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo,\n\t\t\t     int num_items, const char * const *texts)\n{\n\tstatic const char * const texts_default[] = {\n\t\t\"Disabled\", \"Enabled\"\n\t};\n\n\tif (!texts || !num_items) {\n\t\tnum_items = 2;\n\t\ttexts = texts_default;\n\t}\n\n\treturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\n}\nEXPORT_SYMBOL_GPL(snd_hda_enum_helper_info);\n\n \n\n \nstatic void setup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t unsigned int stream_tag, unsigned int format)\n{\n\tstruct hda_spdif_out *spdif;\n\tunsigned int curr_fmt;\n\tbool reset;\n\n\tspdif = snd_hda_spdif_out_of_nid(codec, nid);\n\t \n\tif (WARN_ON(spdif == NULL))\n\t\treturn;\n\n\tcurr_fmt = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t      AC_VERB_GET_STREAM_FORMAT, 0);\n\treset = codec->spdif_status_reset &&\n\t\t(spdif->ctls & AC_DIG1_ENABLE) &&\n\t\tcurr_fmt != format;\n\n\t \n\tif (reset)\n\t\tset_dig_out_convert(codec, nid,\n\t\t\t\t    spdif->ctls & ~AC_DIG1_ENABLE & 0xff,\n\t\t\t\t    -1);\n\tsnd_hda_codec_setup_stream(codec, nid, stream_tag, 0, format);\n\tif (codec->follower_dig_outs) {\n\t\tconst hda_nid_t *d;\n\t\tfor (d = codec->follower_dig_outs; *d; d++)\n\t\t\tsnd_hda_codec_setup_stream(codec, *d, stream_tag, 0,\n\t\t\t\t\t\t   format);\n\t}\n\t \n\tif (reset)\n\t\tset_dig_out_convert(codec, nid,\n\t\t\t\t    spdif->ctls & 0xff, -1);\n}\n\nstatic void cleanup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid)\n{\n\tsnd_hda_codec_cleanup_stream(codec, nid);\n\tif (codec->follower_dig_outs) {\n\t\tconst hda_nid_t *d;\n\t\tfor (d = codec->follower_dig_outs; *d; d++)\n\t\t\tsnd_hda_codec_cleanup_stream(codec, *d);\n\t}\n}\n\n \nint snd_hda_multi_out_dig_open(struct hda_codec *codec,\n\t\t\t       struct hda_multi_out *mout)\n{\n\tmutex_lock(&codec->spdif_mutex);\n\tif (mout->dig_out_used == HDA_DIG_ANALOG_DUP)\n\t\t \n\t\tcleanup_dig_out_stream(codec, mout->dig_out_nid);\n\tmout->dig_out_used = HDA_DIG_EXCLUSIVE;\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_dig_open);\n\n \nint snd_hda_multi_out_dig_prepare(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout,\n\t\t\t\t  unsigned int stream_tag,\n\t\t\t\t  unsigned int format,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tmutex_lock(&codec->spdif_mutex);\n\tsetup_dig_out_stream(codec, mout->dig_out_nid, stream_tag, format);\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_dig_prepare);\n\n \nint snd_hda_multi_out_dig_cleanup(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout)\n{\n\tmutex_lock(&codec->spdif_mutex);\n\tcleanup_dig_out_stream(codec, mout->dig_out_nid);\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_dig_cleanup);\n\n \nint snd_hda_multi_out_dig_close(struct hda_codec *codec,\n\t\t\t\tstruct hda_multi_out *mout)\n{\n\tmutex_lock(&codec->spdif_mutex);\n\tmout->dig_out_used = 0;\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_dig_close);\n\n \nint snd_hda_multi_out_analog_open(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct hda_pcm_stream *hinfo)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\truntime->hw.channels_max = mout->max_channels;\n\tif (mout->dig_out_nid) {\n\t\tif (!mout->analog_rates) {\n\t\t\tmout->analog_rates = hinfo->rates;\n\t\t\tmout->analog_formats = hinfo->formats;\n\t\t\tmout->analog_maxbps = hinfo->maxbps;\n\t\t} else {\n\t\t\truntime->hw.rates = mout->analog_rates;\n\t\t\truntime->hw.formats = mout->analog_formats;\n\t\t\thinfo->maxbps = mout->analog_maxbps;\n\t\t}\n\t\tif (!mout->spdif_rates) {\n\t\t\tsnd_hda_query_supported_pcm(codec, mout->dig_out_nid,\n\t\t\t\t\t\t    &mout->spdif_rates,\n\t\t\t\t\t\t    &mout->spdif_formats,\n\t\t\t\t\t\t    &mout->spdif_maxbps);\n\t\t}\n\t\tmutex_lock(&codec->spdif_mutex);\n\t\tif (mout->share_spdif) {\n\t\t\tif ((runtime->hw.rates & mout->spdif_rates) &&\n\t\t\t    (runtime->hw.formats & mout->spdif_formats)) {\n\t\t\t\truntime->hw.rates &= mout->spdif_rates;\n\t\t\t\truntime->hw.formats &= mout->spdif_formats;\n\t\t\t\tif (mout->spdif_maxbps < hinfo->maxbps)\n\t\t\t\t\thinfo->maxbps = mout->spdif_maxbps;\n\t\t\t} else {\n\t\t\t\tmout->share_spdif = 0;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&codec->spdif_mutex);\n\t}\n\treturn snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_analog_open);\n\n \nint snd_hda_multi_out_analog_prepare(struct hda_codec *codec,\n\t\t\t\t     struct hda_multi_out *mout,\n\t\t\t\t     unsigned int stream_tag,\n\t\t\t\t     unsigned int format,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tconst hda_nid_t *nids = mout->dac_nids;\n\tint chs = substream->runtime->channels;\n\tstruct hda_spdif_out *spdif;\n\tint i;\n\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_hda_spdif_out_of_nid(codec, mout->dig_out_nid);\n\tif (mout->dig_out_nid && mout->share_spdif &&\n\t    mout->dig_out_used != HDA_DIG_EXCLUSIVE) {\n\t\tif (chs == 2 && spdif != NULL &&\n\t\t    snd_hda_is_supported_format(codec, mout->dig_out_nid,\n\t\t\t\t\t\tformat) &&\n\t\t    !(spdif->status & IEC958_AES0_NONAUDIO)) {\n\t\t\tmout->dig_out_used = HDA_DIG_ANALOG_DUP;\n\t\t\tsetup_dig_out_stream(codec, mout->dig_out_nid,\n\t\t\t\t\t     stream_tag, format);\n\t\t} else {\n\t\t\tmout->dig_out_used = 0;\n\t\t\tcleanup_dig_out_stream(codec, mout->dig_out_nid);\n\t\t}\n\t}\n\tmutex_unlock(&codec->spdif_mutex);\n\n\t \n\tsnd_hda_codec_setup_stream(codec, nids[HDA_FRONT], stream_tag,\n\t\t\t\t   0, format);\n\tif (!mout->no_share_stream &&\n\t    mout->hp_nid && mout->hp_nid != nids[HDA_FRONT])\n\t\t \n\t\tsnd_hda_codec_setup_stream(codec, mout->hp_nid, stream_tag,\n\t\t\t\t\t   0, format);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\n\t\tif (!mout->no_share_stream && mout->hp_out_nid[i])\n\t\t\tsnd_hda_codec_setup_stream(codec,\n\t\t\t\t\t\t   mout->hp_out_nid[i],\n\t\t\t\t\t\t   stream_tag, 0, format);\n\n\t \n\tfor (i = 1; i < mout->num_dacs; i++) {\n\t\tif (chs >= (i + 1) * 2)  \n\t\t\tsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\n\t\t\t\t\t\t   i * 2, format);\n\t\telse if (!mout->no_share_stream)  \n\t\t\tsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\n\t\t\t\t\t\t   0, format);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++) {\n\t\tint ch = 0;\n\t\tif (!mout->extra_out_nid[i])\n\t\t\tbreak;\n\t\tif (chs >= (i + 1) * 2)\n\t\t\tch = i * 2;\n\t\telse if (!mout->no_share_stream)\n\t\t\tbreak;\n\t\tsnd_hda_codec_setup_stream(codec, mout->extra_out_nid[i],\n\t\t\t\t\t   stream_tag, ch, format);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_analog_prepare);\n\n \nint snd_hda_multi_out_analog_cleanup(struct hda_codec *codec,\n\t\t\t\t     struct hda_multi_out *mout)\n{\n\tconst hda_nid_t *nids = mout->dac_nids;\n\tint i;\n\n\tfor (i = 0; i < mout->num_dacs; i++)\n\t\tsnd_hda_codec_cleanup_stream(codec, nids[i]);\n\tif (mout->hp_nid)\n\t\tsnd_hda_codec_cleanup_stream(codec, mout->hp_nid);\n\tfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\n\t\tif (mout->hp_out_nid[i])\n\t\t\tsnd_hda_codec_cleanup_stream(codec,\n\t\t\t\t\t\t     mout->hp_out_nid[i]);\n\tfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++)\n\t\tif (mout->extra_out_nid[i])\n\t\t\tsnd_hda_codec_cleanup_stream(codec,\n\t\t\t\t\t\t     mout->extra_out_nid[i]);\n\tmutex_lock(&codec->spdif_mutex);\n\tif (mout->dig_out_nid && mout->dig_out_used == HDA_DIG_ANALOG_DUP) {\n\t\tcleanup_dig_out_stream(codec, mout->dig_out_nid);\n\t\tmout->dig_out_used = 0;\n\t}\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_multi_out_analog_cleanup);\n\n \nunsigned int snd_hda_get_default_vref(struct hda_codec *codec, hda_nid_t pin)\n{\n\tunsigned int pincap;\n\tunsigned int oldval;\n\toldval = snd_hda_codec_read(codec, pin, 0,\n\t\t\t\t    AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\tpincap = snd_hda_query_pin_caps(codec, pin);\n\tpincap = (pincap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\n\t \n\tif ((pincap & AC_PINCAP_VREF_80) && oldval != PIN_VREF50)\n\t\treturn AC_PINCTL_VREF_80;\n\telse if (pincap & AC_PINCAP_VREF_50)\n\t\treturn AC_PINCTL_VREF_50;\n\telse if (pincap & AC_PINCAP_VREF_100)\n\t\treturn AC_PINCTL_VREF_100;\n\telse if (pincap & AC_PINCAP_VREF_GRD)\n\t\treturn AC_PINCTL_VREF_GRD;\n\treturn AC_PINCTL_VREF_HIZ;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_default_vref);\n\n \nunsigned int snd_hda_correct_pin_ctl(struct hda_codec *codec,\n\t\t\t\t     hda_nid_t pin, unsigned int val)\n{\n\tstatic const unsigned int cap_lists[][2] = {\n\t\t{ AC_PINCTL_VREF_100, AC_PINCAP_VREF_100 },\n\t\t{ AC_PINCTL_VREF_80, AC_PINCAP_VREF_80 },\n\t\t{ AC_PINCTL_VREF_50, AC_PINCAP_VREF_50 },\n\t\t{ AC_PINCTL_VREF_GRD, AC_PINCAP_VREF_GRD },\n\t};\n\tunsigned int cap;\n\n\tif (!val)\n\t\treturn 0;\n\tcap = snd_hda_query_pin_caps(codec, pin);\n\tif (!cap)\n\t\treturn val;  \n\n\tif (val & AC_PINCTL_OUT_EN) {\n\t\tif (!(cap & AC_PINCAP_OUT))\n\t\t\tval &= ~(AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);\n\t\telse if ((val & AC_PINCTL_HP_EN) && !(cap & AC_PINCAP_HP_DRV))\n\t\t\tval &= ~AC_PINCTL_HP_EN;\n\t}\n\n\tif (val & AC_PINCTL_IN_EN) {\n\t\tif (!(cap & AC_PINCAP_IN))\n\t\t\tval &= ~(AC_PINCTL_IN_EN | AC_PINCTL_VREFEN);\n\t\telse {\n\t\t\tunsigned int vcap, vref;\n\t\t\tint i;\n\t\t\tvcap = (cap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\n\t\t\tvref = val & AC_PINCTL_VREFEN;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(cap_lists); i++) {\n\t\t\t\tif (vref == cap_lists[i][0] &&\n\t\t\t\t    !(vcap & cap_lists[i][1])) {\n\t\t\t\t\tif (i == ARRAY_SIZE(cap_lists) - 1)\n\t\t\t\t\t\tvref = AC_PINCTL_VREF_HIZ;\n\t\t\t\t\telse\n\t\t\t\t\t\tvref = cap_lists[i + 1][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tval &= ~AC_PINCTL_VREFEN;\n\t\t\tval |= vref;\n\t\t}\n\t}\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_hda_correct_pin_ctl);\n\n \nint _snd_hda_set_pin_ctl(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t unsigned int val, bool cached)\n{\n\tval = snd_hda_correct_pin_ctl(codec, pin, val);\n\tsnd_hda_codec_set_pin_target(codec, pin, val);\n\tif (cached)\n\t\treturn snd_hda_codec_write_cache(codec, pin, 0,\n\t\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, val);\n\telse\n\t\treturn snd_hda_codec_write(codec, pin, 0,\n\t\t\t\t\t   AC_VERB_SET_PIN_WIDGET_CONTROL, val);\n}\nEXPORT_SYMBOL_GPL(_snd_hda_set_pin_ctl);\n\n \nint snd_hda_add_imux_item(struct hda_codec *codec,\n\t\t\t  struct hda_input_mux *imux, const char *label,\n\t\t\t  int index, int *type_idx)\n{\n\tint i, label_idx = 0;\n\tif (imux->num_items >= HDA_MAX_NUM_INPUTS) {\n\t\tcodec_err(codec, \"hda_codec: Too many imux items!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < imux->num_items; i++) {\n\t\tif (!strncmp(label, imux->items[i].label, strlen(label)))\n\t\t\tlabel_idx++;\n\t}\n\tif (type_idx)\n\t\t*type_idx = label_idx;\n\tif (label_idx > 0)\n\t\tsnprintf(imux->items[imux->num_items].label,\n\t\t\t sizeof(imux->items[imux->num_items].label),\n\t\t\t \"%s %d\", label, label_idx);\n\telse\n\t\tstrscpy(imux->items[imux->num_items].label, label,\n\t\t\tsizeof(imux->items[imux->num_items].label));\n\timux->items[imux->num_items].index = index;\n\timux->num_items++;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_add_imux_item);\n\n \nvoid snd_hda_bus_reset_codecs(struct hda_bus *bus)\n{\n\tstruct hda_codec *codec;\n\n\tlist_for_each_codec(codec, bus) {\n\t\t \n\t\tif (current_work() != &codec->jackpoll_work.work)\n\t\t\tcancel_delayed_work_sync(&codec->jackpoll_work);\n#ifdef CONFIG_PM\n\t\tif (hda_codec_is_power_on(codec)) {\n\t\t\thda_call_codec_suspend(codec);\n\t\t\thda_call_codec_resume(codec);\n\t\t}\n#endif\n\t}\n}\n\n \nvoid snd_print_pcm_bits(int pcm, char *buf, int buflen)\n{\n\tstatic const unsigned int bits[] = { 8, 16, 20, 24, 32 };\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(bits); i++)\n\t\tif (pcm & (AC_SUPPCM_BITS_8 << i))\n\t\t\tj += scnprintf(buf + j, buflen - j,  \" %d\", bits[i]);\n\n\tbuf[j] = '\\0';  \n}\nEXPORT_SYMBOL_GPL(snd_print_pcm_bits);\n\nMODULE_DESCRIPTION(\"HDA codec core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}