{
  "module_name": "tas2781_hda_i2c.c",
  "hash_id": "109d6e3a9d5ef1c9657a8502ed206bedce60477f4a50325875d148f406aeff8c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/tas2781_hda_i2c.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/crc8.h>\n#include <linux/crc32.h>\n#include <linux/efi.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/hda_codec.h>\n#include <sound/soc.h>\n#include <sound/tas2781.h>\n#include <sound/tlv.h>\n#include <sound/tas2781-tlv.h>\n\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_component.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n\n#define TASDEVICE_SPEAKER_CALIBRATION_SIZE\t20\n\n \n\n \n#define ACARD_SINGLE_RANGE_EXT_TLV(xname, xreg, xshift, xmin, xmax, xinvert, \\\n\txhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_CARD, .name = (xname),\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw_range, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = (unsigned long)&(struct soc_mixer_control) \\\n\t\t{.reg = xreg, .rreg = xreg, .shift = xshift, \\\n\t\t .rshift = xshift, .min = xmin, .max = xmax, \\\n\t\t .invert = xinvert} }\n\n \n#define ACARD_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_CARD, .name = xname, \\\n\t.info = snd_ctl_boolean_mono_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = xdata }\n\nenum calib_data {\n\tR0_VAL = 0,\n\tINV_R0,\n\tR0LOW,\n\tPOWER,\n\tTLIM,\n\tCALIB_MAX\n};\n\nstruct tas2781_hda {\n\tstruct device *dev;\n\tstruct tasdevice_priv *priv;\n\tstruct snd_kcontrol *dsp_prog_ctl;\n\tstruct snd_kcontrol *dsp_conf_ctl;\n\tstruct snd_kcontrol *prof_ctl;\n\tstruct snd_kcontrol *snd_ctls[3];\n};\n\nstatic int tas2781_get_i2c_res(struct acpi_resource *ares, void *data)\n{\n\tstruct tasdevice_priv *tas_priv = data;\n\tstruct acpi_resource_i2c_serialbus *sb;\n\n\tif (i2c_acpi_get_i2c_resource(ares, &sb)) {\n\t\tif (tas_priv->ndev < TASDEVICE_MAX_CHANNELS &&\n\t\t\tsb->slave_address != TAS2781_GLOBAL_ADDR) {\n\t\t\ttas_priv->tasdevice[tas_priv->ndev].dev_addr =\n\t\t\t\t(unsigned int)sb->slave_address;\n\t\t\ttas_priv->ndev++;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int tas2781_read_acpi(struct tasdevice_priv *p, const char *hid)\n{\n\tstruct acpi_device *adev;\n\tstruct device *physdev;\n\tLIST_HEAD(resources);\n\tconst char *sub;\n\tint ret;\n\n\tadev = acpi_dev_get_first_match_dev(hid, NULL, -1);\n\tif (!adev) {\n\t\tdev_err(p->dev,\n\t\t\t\"Failed to find an ACPI device for %s\\n\", hid);\n\t\treturn -ENODEV;\n\t}\n\n\tret = acpi_dev_get_resources(adev, &resources, tas2781_get_i2c_res, p);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tacpi_dev_free_resource_list(&resources);\n\tstrscpy(p->dev_name, hid, sizeof(p->dev_name));\n\tphysdev = get_device(acpi_get_first_physical_node(adev));\n\tacpi_dev_put(adev);\n\n\t \n\tsub = acpi_get_subsystem_id(ACPI_HANDLE(physdev));\n\tif (IS_ERR(sub))\n\t\tsub = NULL;\n\n\tp->acpi_subsystem_id = sub;\n\n\tput_device(physdev);\n\n\treturn 0;\n\nerr:\n\tdev_err(p->dev, \"read acpi error, ret: %d\\n\", ret);\n\tacpi_dev_put(adev);\n\n\treturn ret;\n}\n\nstatic void tas2781_hda_playback_hook(struct device *dev, int action)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\n\tdev_dbg(tas_hda->dev, \"%s: action = %d\\n\", __func__, action);\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_OPEN:\n\t\tpm_runtime_get_sync(dev);\n\t\tmutex_lock(&tas_hda->priv->codec_lock);\n\t\ttasdevice_tuning_switch(tas_hda->priv, 0);\n\t\tmutex_unlock(&tas_hda->priv->codec_lock);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLOSE:\n\t\tmutex_lock(&tas_hda->priv->codec_lock);\n\t\ttasdevice_tuning_switch(tas_hda->priv, 1);\n\t\tmutex_unlock(&tas_hda->priv->codec_lock);\n\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(tas_hda->dev, \"Playback action not supported: %d\\n\",\n\t\t\taction);\n\t\tbreak;\n\t}\n}\n\nstatic int tasdevice_info_profile(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tas_priv->rcabin.ncfgs - 1;\n\n\treturn 0;\n}\n\nstatic int tasdevice_get_profile_id(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = tas_priv->rcabin.profile_cfg_id;\n\n\treturn 0;\n}\n\nstatic int tasdevice_set_profile_id(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tint nr_profile = ucontrol->value.integer.value[0];\n\tint max = tas_priv->rcabin.ncfgs - 1;\n\tint val, ret = 0;\n\n\tval = clamp(nr_profile, 0, max);\n\n\tif (tas_priv->rcabin.profile_cfg_id != val) {\n\t\ttas_priv->rcabin.profile_cfg_id = val;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_info_programs(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tas_fw->nr_programs - 1;\n\n\treturn 0;\n}\n\nstatic int tasdevice_info_config(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tas_fw->nr_configurations - 1;\n\n\treturn 0;\n}\n\nstatic int tasdevice_program_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = tas_priv->cur_prog;\n\n\treturn 0;\n}\n\nstatic int tasdevice_program_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\tint nr_program = ucontrol->value.integer.value[0];\n\tint max = tas_fw->nr_programs - 1;\n\tint val, ret = 0;\n\n\tval = clamp(nr_program, 0, max);\n\n\tif (tas_priv->cur_prog != val) {\n\t\ttas_priv->cur_prog = val;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_config_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = tas_priv->cur_conf;\n\n\treturn 0;\n}\n\nstatic int tasdevice_config_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\tint nr_config = ucontrol->value.integer.value[0];\n\tint max = tas_fw->nr_configurations - 1;\n\tint val, ret = 0;\n\n\tval = clamp(nr_config, 0, max);\n\n\tif (tas_priv->cur_conf != val) {\n\t\ttas_priv->cur_conf = val;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int tas2781_digital_getvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_digital_getvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_amp_getvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_amp_getvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_digital_putvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\t \n\treturn tasdevice_digital_putvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_amp_putvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\t \n\treturn tasdevice_amp_putvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_force_fwload_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = (int)tas_priv->force_fwload_status;\n\tdev_dbg(tas_priv->dev, \"%s : Force FWload %s\\n\", __func__,\n\t\t\ttas_priv->force_fwload_status ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nstatic int tas2781_force_fwload_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tasdevice_priv *tas_priv = snd_kcontrol_chip(kcontrol);\n\tbool change, val = (bool)ucontrol->value.integer.value[0];\n\n\tif (tas_priv->force_fwload_status == val)\n\t\tchange = false;\n\telse {\n\t\tchange = true;\n\t\ttas_priv->force_fwload_status = val;\n\t}\n\tdev_dbg(tas_priv->dev, \"%s : Force FWload %s\\n\", __func__,\n\t\ttas_priv->force_fwload_status ? \"ON\" : \"OFF\");\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new tas2781_snd_controls[] = {\n\tACARD_SINGLE_RANGE_EXT_TLV(\"Speaker Analog Gain\", TAS2781_AMP_LEVEL,\n\t\t1, 0, 20, 0, tas2781_amp_getvol,\n\t\ttas2781_amp_putvol, amp_vol_tlv),\n\tACARD_SINGLE_RANGE_EXT_TLV(\"Speaker Digital Gain\", TAS2781_DVC_LVL,\n\t\t0, 0, 200, 1, tas2781_digital_getvol,\n\t\ttas2781_digital_putvol, dvc_tlv),\n\tACARD_SINGLE_BOOL_EXT(\"Speaker Force Firmware Load\", 0,\n\t\ttas2781_force_fwload_get, tas2781_force_fwload_put),\n};\n\nstatic const struct snd_kcontrol_new tas2781_prof_ctrl = {\n\t.name = \"Speaker Profile Id\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = tasdevice_info_profile,\n\t.get = tasdevice_get_profile_id,\n\t.put = tasdevice_set_profile_id,\n};\n\nstatic const struct snd_kcontrol_new tas2781_dsp_prog_ctrl = {\n\t.name = \"Speaker Program Id\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = tasdevice_info_programs,\n\t.get = tasdevice_program_get,\n\t.put = tasdevice_program_put,\n};\n\nstatic const struct snd_kcontrol_new tas2781_dsp_conf_ctrl = {\n\t.name = \"Speaker Config Id\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = tasdevice_info_config,\n\t.get = tasdevice_config_get,\n\t.put = tasdevice_config_put,\n};\n\nstatic void tas2781_apply_calib(struct tasdevice_priv *tas_priv)\n{\n\tstatic const unsigned char page_array[CALIB_MAX] = {\n\t\t0x17, 0x18, 0x18, 0x0d, 0x18\n\t};\n\tstatic const unsigned char rgno_array[CALIB_MAX] = {\n\t\t0x74, 0x0c, 0x14, 0x3c, 0x7c\n\t};\n\tunsigned char *data;\n\tint i, j, rc;\n\n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\tdata = tas_priv->cali_data.data +\n\t\t\ti * TASDEVICE_SPEAKER_CALIBRATION_SIZE;\n\t\tfor (j = 0; j < CALIB_MAX; j++) {\n\t\t\trc = tasdevice_dev_bulk_write(tas_priv, i,\n\t\t\t\tTASDEVICE_REG(0, page_array[j], rgno_array[j]),\n\t\t\t\t&(data[4 * j]), 4);\n\t\t\tif (rc < 0)\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"chn %d calib %d bulk_wr err = %d\\n\",\n\t\t\t\t\ti, j, rc);\n\t\t}\n\t}\n}\n\n \nstatic int tas2781_save_calibration(struct tasdevice_priv *tas_priv)\n{\n\tefi_guid_t efi_guid = EFI_GUID(0x02f9af02, 0x7734, 0x4233, 0xb4, 0x3d,\n\t\t0x93, 0xfe, 0x5a, 0xa3, 0x5d, 0xb3);\n\tstatic efi_char16_t efi_name[] = L\"CALI_DATA\";\n\tstruct tm *tm = &tas_priv->tm;\n\tunsigned int attr, crc;\n\tunsigned int *tmp_val;\n\tefi_status_t status;\n\n\t \n\tif (tas_priv->catlog_id == LENOVO)\n\t\tefi_guid = EFI_GUID(0x1f52d2a1, 0xbb3a, 0x457d, 0xbc, 0x09,\n\t\t\t0x43, 0xa3, 0xf4, 0x31, 0x0a, 0x92);\n\n\ttas_priv->cali_data.total_sz = 0;\n\t \n\tstatus = efi.get_variable(efi_name, &efi_guid, &attr,\n\t\t&tas_priv->cali_data.total_sz, tas_priv->cali_data.data);\n\tif (status == EFI_BUFFER_TOO_SMALL) {\n\t\t \n\t\ttas_priv->cali_data.data = devm_kzalloc(tas_priv->dev,\n\t\t\ttas_priv->cali_data.total_sz, GFP_KERNEL);\n\t\tif (!tas_priv->cali_data.data)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tstatus = efi.get_variable(efi_name, &efi_guid, &attr,\n\t\t\t&tas_priv->cali_data.total_sz,\n\t\t\ttas_priv->cali_data.data);\n\t}\n\tif (status != EFI_SUCCESS)\n\t\treturn -EINVAL;\n\n\ttmp_val = (unsigned int *)tas_priv->cali_data.data;\n\n\tcrc = crc32(~0, tas_priv->cali_data.data, 84) ^ ~0;\n\tdev_dbg(tas_priv->dev, \"cali crc 0x%08x PK tmp_val 0x%08x\\n\",\n\t\tcrc, tmp_val[21]);\n\n\tif (crc == tmp_val[21]) {\n\t\ttime64_to_tm(tmp_val[20], 0, tm);\n\t\tdev_dbg(tas_priv->dev, \"%4ld-%2d-%2d, %2d:%2d:%2d\\n\",\n\t\t\ttm->tm_year, tm->tm_mon, tm->tm_mday,\n\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\ttas2781_apply_calib(tas_priv);\n\t} else\n\t\ttas_priv->cali_data.total_sz = 0;\n\n\treturn 0;\n}\n\nstatic void tas2781_hda_remove_controls(struct tas2781_hda *tas_hda)\n{\n\tstruct hda_codec *codec = tas_hda->priv->codec;\n\n\tif (tas_hda->dsp_prog_ctl)\n\t\tsnd_ctl_remove(codec->card, tas_hda->dsp_prog_ctl);\n\n\tif (tas_hda->dsp_conf_ctl)\n\t\tsnd_ctl_remove(codec->card, tas_hda->dsp_conf_ctl);\n\n\tfor (int i = ARRAY_SIZE(tas_hda->snd_ctls) - 1; i >= 0; i--)\n\t\tif (tas_hda->snd_ctls[i])\n\t\t\tsnd_ctl_remove(codec->card, tas_hda->snd_ctls[i]);\n\n\tif (tas_hda->prof_ctl)\n\t\tsnd_ctl_remove(codec->card, tas_hda->prof_ctl);\n}\n\nstatic void tasdev_fw_ready(const struct firmware *fmw, void *context)\n{\n\tstruct tasdevice_priv *tas_priv = context;\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(tas_priv->dev);\n\tstruct hda_codec *codec = tas_priv->codec;\n\tint i, ret;\n\n\tpm_runtime_get_sync(tas_priv->dev);\n\tmutex_lock(&tas_priv->codec_lock);\n\n\tret = tasdevice_rca_parser(tas_priv, fmw);\n\tif (ret)\n\t\tgoto out;\n\n\ttas_hda->prof_ctl = snd_ctl_new1(&tas2781_prof_ctrl, tas_priv);\n\tret = snd_ctl_add(codec->card, tas_hda->prof_ctl);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"Failed to add KControl %s = %d\\n\",\n\t\t\ttas2781_prof_ctrl.name, ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tas2781_snd_controls); i++) {\n\t\ttas_hda->snd_ctls[i] = snd_ctl_new1(&tas2781_snd_controls[i],\n\t\t\ttas_priv);\n\t\tret = snd_ctl_add(codec->card, tas_hda->snd_ctls[i]);\n\t\tif (ret) {\n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"Failed to add KControl %s = %d\\n\",\n\t\t\t\ttas2781_snd_controls[i].name, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttasdevice_dsp_remove(tas_priv);\n\n\ttas_priv->fw_state = TASDEVICE_DSP_FW_PENDING;\n\tscnprintf(tas_priv->coef_binaryname, 64, \"TAS2XXX%04X.bin\",\n\t\tcodec->core.subsystem_id & 0xffff);\n\tret = tasdevice_dsp_parser(tas_priv);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"dspfw load %s error\\n\",\n\t\t\ttas_priv->coef_binaryname);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tgoto out;\n\t}\n\n\ttas_hda->dsp_prog_ctl = snd_ctl_new1(&tas2781_dsp_prog_ctrl,\n\t\ttas_priv);\n\tret = snd_ctl_add(codec->card, tas_hda->dsp_prog_ctl);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"Failed to add KControl %s = %d\\n\",\n\t\t\ttas2781_dsp_prog_ctrl.name, ret);\n\t\tgoto out;\n\t}\n\n\ttas_hda->dsp_conf_ctl = snd_ctl_new1(&tas2781_dsp_conf_ctrl,\n\t\ttas_priv);\n\tret = snd_ctl_add(codec->card, tas_hda->dsp_conf_ctl);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"Failed to add KControl %s = %d\\n\",\n\t\t\ttas2781_dsp_conf_ctrl.name, ret);\n\t\tgoto out;\n\t}\n\n\ttas_priv->fw_state = TASDEVICE_DSP_FW_ALL_OK;\n\ttasdevice_prmg_load(tas_priv, 0);\n\tif (tas_priv->fmw->nr_programs > 0)\n\t\ttas_priv->cur_prog = 0;\n\tif (tas_priv->fmw->nr_configurations > 0)\n\t\ttas_priv->cur_conf = 0;\n\n\t \n\ttas2781_save_calibration(tas_priv);\n\nout:\n\tmutex_unlock(&tas_hda->priv->codec_lock);\n\tif (fmw)\n\t\trelease_firmware(fmw);\n\tpm_runtime_mark_last_busy(tas_hda->dev);\n\tpm_runtime_put_autosuspend(tas_hda->dev);\n}\n\nstatic int tas2781_hda_bind(struct device *dev, struct device *master,\n\tvoid *master_data)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tstruct hda_codec *codec;\n\tunsigned int subid;\n\tint ret;\n\n\tif (!comps || tas_hda->priv->index < 0 ||\n\t\ttas_hda->priv->index >= HDA_MAX_COMPONENTS)\n\t\treturn -EINVAL;\n\n\tcomps = &comps[tas_hda->priv->index];\n\tif (comps->dev)\n\t\treturn -EBUSY;\n\n\tcodec = comps->codec;\n\tsubid = codec->core.subsystem_id >> 16;\n\n\tswitch (subid) {\n\tcase 0x17aa:\n\t\ttas_hda->priv->catlog_id = LENOVO;\n\t\tbreak;\n\tdefault:\n\t\ttas_hda->priv->catlog_id = OTHERS;\n\t\tbreak;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\n\tcomps->dev = dev;\n\n\tstrscpy(comps->name, dev_name(dev), sizeof(comps->name));\n\n\tret = tascodec_init(tas_hda->priv, codec, tasdev_fw_ready);\n\tif (!ret)\n\t\tcomps->playback_hook = tas2781_hda_playback_hook;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic void tas2781_hda_unbind(struct device *dev,\n\tstruct device *master, void *master_data)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tcomps = &comps[tas_hda->priv->index];\n\n\tif (comps->dev == dev) {\n\t\tcomps->dev = NULL;\n\t\tmemset(comps->name, 0, sizeof(comps->name));\n\t\tcomps->playback_hook = NULL;\n\t}\n\n\ttas2781_hda_remove_controls(tas_hda);\n\n\ttasdevice_config_info_remove(tas_hda->priv);\n\ttasdevice_dsp_remove(tas_hda->priv);\n\n\ttas_hda->priv->fw_state = TASDEVICE_DSP_FW_PENDING;\n}\n\nstatic const struct component_ops tas2781_hda_comp_ops = {\n\t.bind = tas2781_hda_bind,\n\t.unbind = tas2781_hda_unbind,\n};\n\nstatic void tas2781_hda_remove(struct device *dev)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(tas_hda->dev);\n\tpm_runtime_disable(tas_hda->dev);\n\n\tcomponent_del(tas_hda->dev, &tas2781_hda_comp_ops);\n\n\tpm_runtime_put_noidle(tas_hda->dev);\n\n\ttasdevice_remove(tas_hda->priv);\n}\n\nstatic int tas2781_hda_i2c_probe(struct i2c_client *clt)\n{\n\tstruct tas2781_hda *tas_hda;\n\tconst char *device_name;\n\tint ret;\n\n\tif (strstr(dev_name(&clt->dev), \"TIAS2781\"))\n\t\tdevice_name = \"TIAS2781\";\n\telse\n\t\treturn -ENODEV;\n\n\ttas_hda = devm_kzalloc(&clt->dev, sizeof(*tas_hda), GFP_KERNEL);\n\tif (!tas_hda)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&clt->dev, tas_hda);\n\ttas_hda->dev = &clt->dev;\n\n\ttas_hda->priv = tasdevice_kzalloc(clt);\n\tif (!tas_hda->priv)\n\t\treturn -ENOMEM;\n\n\ttas_hda->priv->irq_info.irq = clt->irq;\n\tret = tas2781_read_acpi(tas_hda->priv, device_name);\n\tif (ret)\n\t\treturn dev_err_probe(tas_hda->dev, ret,\n\t\t\t\"Platform not supported\\n\");\n\n\tret = tasdevice_init(tas_hda->priv);\n\tif (ret)\n\t\tgoto err;\n\n\tpm_runtime_set_autosuspend_delay(tas_hda->dev, 3000);\n\tpm_runtime_use_autosuspend(tas_hda->dev);\n\tpm_runtime_mark_last_busy(tas_hda->dev);\n\tpm_runtime_set_active(tas_hda->dev);\n\tpm_runtime_get_noresume(tas_hda->dev);\n\tpm_runtime_enable(tas_hda->dev);\n\n\tpm_runtime_put_autosuspend(tas_hda->dev);\n\n\ttas2781_reset(tas_hda->priv);\n\n\tret = component_add(tas_hda->dev, &tas2781_hda_comp_ops);\n\tif (ret) {\n\t\tdev_err(tas_hda->dev, \"Register component failed: %d\\n\", ret);\n\t\tpm_runtime_disable(tas_hda->dev);\n\t}\n\nerr:\n\tif (ret)\n\t\ttas2781_hda_remove(&clt->dev);\n\treturn ret;\n}\n\nstatic void tas2781_hda_i2c_remove(struct i2c_client *clt)\n{\n\ttas2781_hda_remove(&clt->dev);\n}\n\nstatic int tas2781_runtime_suspend(struct device *dev)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tint i;\n\n\tdev_dbg(tas_hda->dev, \"Runtime Suspend\\n\");\n\n\tmutex_lock(&tas_hda->priv->codec_lock);\n\n\tif (tas_hda->priv->playback_started) {\n\t\ttasdevice_tuning_switch(tas_hda->priv, 1);\n\t\ttas_hda->priv->playback_started = false;\n\t}\n\n\tfor (i = 0; i < tas_hda->priv->ndev; i++) {\n\t\ttas_hda->priv->tasdevice[i].cur_book = -1;\n\t\ttas_hda->priv->tasdevice[i].cur_prog = -1;\n\t\ttas_hda->priv->tasdevice[i].cur_conf = -1;\n\t}\n\n\tmutex_unlock(&tas_hda->priv->codec_lock);\n\n\treturn 0;\n}\n\nstatic int tas2781_runtime_resume(struct device *dev)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tunsigned long calib_data_sz =\n\t\ttas_hda->priv->ndev * TASDEVICE_SPEAKER_CALIBRATION_SIZE;\n\n\tdev_dbg(tas_hda->dev, \"Runtime Resume\\n\");\n\n\tmutex_lock(&tas_hda->priv->codec_lock);\n\n\ttasdevice_prmg_load(tas_hda->priv, tas_hda->priv->cur_prog);\n\n\t \n\tif (tas_hda->priv->cali_data.total_sz > calib_data_sz)\n\t\ttas2781_apply_calib(tas_hda->priv);\n\n\tmutex_unlock(&tas_hda->priv->codec_lock);\n\n\treturn 0;\n}\n\nstatic int tas2781_system_suspend(struct device *dev)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(tas_hda->priv->dev, \"System Suspend\\n\");\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttasdevice_tuning_switch(tas_hda->priv, 1);\n\n\t \n\treturn 0;\n}\n\nstatic int tas2781_system_resume(struct device *dev)\n{\n\tstruct tas2781_hda *tas_hda = dev_get_drvdata(dev);\n\tunsigned long calib_data_sz =\n\t\ttas_hda->priv->ndev * TASDEVICE_SPEAKER_CALIBRATION_SIZE;\n\tint i, ret;\n\n\tdev_info(tas_hda->priv->dev, \"System Resume\\n\");\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&tas_hda->priv->codec_lock);\n\n\tfor (i = 0; i < tas_hda->priv->ndev; i++) {\n\t\ttas_hda->priv->tasdevice[i].cur_book = -1;\n\t\ttas_hda->priv->tasdevice[i].cur_prog = -1;\n\t\ttas_hda->priv->tasdevice[i].cur_conf = -1;\n\t}\n\ttas2781_reset(tas_hda->priv);\n\ttasdevice_prmg_load(tas_hda->priv, tas_hda->priv->cur_prog);\n\n\t \n\tif (tas_hda->priv->cali_data.total_sz > calib_data_sz)\n\t\ttas2781_apply_calib(tas_hda->priv);\n\tmutex_unlock(&tas_hda->priv->codec_lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tas2781_hda_pm_ops = {\n\tRUNTIME_PM_OPS(tas2781_runtime_suspend, tas2781_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(tas2781_system_suspend, tas2781_system_resume)\n};\n\nstatic const struct i2c_device_id tas2781_hda_i2c_id[] = {\n\t{ \"tas2781-hda\", 0 },\n\t{}\n};\n\nstatic const struct acpi_device_id tas2781_acpi_hda_match[] = {\n\t{\"TIAS2781\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, tas2781_acpi_hda_match);\n\nstatic struct i2c_driver tas2781_hda_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"tas2781-hda\",\n\t\t.acpi_match_table = tas2781_acpi_hda_match,\n\t\t.pm\t\t= &tas2781_hda_pm_ops,\n\t},\n\t.id_table\t= tas2781_hda_i2c_id,\n\t.probe\t\t= tas2781_hda_i2c_probe,\n\t.remove\t\t= tas2781_hda_i2c_remove,\n};\nmodule_i2c_driver(tas2781_hda_i2c_driver);\n\nMODULE_DESCRIPTION(\"TAS2781 HDA Driver\");\nMODULE_AUTHOR(\"Shenghao Ding, TI, <shenghao-ding@ti.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_TAS2781_FMWLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}