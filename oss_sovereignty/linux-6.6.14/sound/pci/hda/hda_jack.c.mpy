{
  "module_name": "hda_jack.c",
  "hash_id": "615160c03a2f3024568de9429b7115b91bfb857c9cfd2a180c1e936f2e0f9f88",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_jack.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/jack.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n\n \nbool is_jack_detectable(struct hda_codec *codec, hda_nid_t nid)\n{\n\tif (codec->no_jack_detect)\n\t\treturn false;\n\tif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_PRES_DETECT))\n\t\treturn false;\n\tif (get_defcfg_misc(snd_hda_codec_get_pincfg(codec, nid)) &\n\t     AC_DEFCFG_MISC_NO_PRESENCE)\n\t\treturn false;\n\tif (!(get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) &&\n\t    !codec->jackpoll_interval)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(is_jack_detectable);\n\n \nstatic u32 read_pin_sense(struct hda_codec *codec, hda_nid_t nid, int dev_id)\n{\n\tu32 pincap;\n\tu32 val;\n\n\tif (!codec->no_trigger_sense) {\n\t\tpincap = snd_hda_query_pin_caps(codec, nid);\n\t\tif (pincap & AC_PINCAP_TRIG_REQ)  \n\t\t\tsnd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\tAC_VERB_SET_PIN_SENSE, 0);\n\t}\n\tval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t  AC_VERB_GET_PIN_SENSE, dev_id);\n\tif (codec->inv_jack_detect)\n\t\tval ^= AC_PINSENSE_PRESENCE;\n\treturn val;\n}\n\n \nstruct hda_jack_tbl *\nsnd_hda_jack_tbl_get_mst(struct hda_codec *codec, hda_nid_t nid, int dev_id)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tif (!nid || !jack)\n\t\treturn NULL;\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->nid == nid && jack->dev_id == dev_id)\n\t\t\treturn jack;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_tbl_get_mst);\n\n \nstruct hda_jack_tbl *\nsnd_hda_jack_tbl_get_from_tag(struct hda_codec *codec,\n\t\t\t      unsigned char tag, int dev_id)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tif (!tag || !jack)\n\t\treturn NULL;\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->tag == tag && jack->dev_id == dev_id)\n\t\t\treturn jack;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_tbl_get_from_tag);\n\nstatic struct hda_jack_tbl *\nany_jack_tbl_get_from_nid(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tif (!nid || !jack)\n\t\treturn NULL;\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->nid == nid)\n\t\t\treturn jack;\n\treturn NULL;\n}\n\n \nstatic struct hda_jack_tbl *\nsnd_hda_jack_tbl_new(struct hda_codec *codec, hda_nid_t nid, int dev_id)\n{\n\tstruct hda_jack_tbl *jack =\n\t\tsnd_hda_jack_tbl_get_mst(codec, nid, dev_id);\n\tstruct hda_jack_tbl *existing_nid_jack =\n\t\tany_jack_tbl_get_from_nid(codec, nid);\n\n\tWARN_ON(dev_id != 0 && !codec->dp_mst);\n\n\tif (jack)\n\t\treturn jack;\n\tjack = snd_array_new(&codec->jacktbl);\n\tif (!jack)\n\t\treturn NULL;\n\tjack->nid = nid;\n\tjack->dev_id = dev_id;\n\tjack->jack_dirty = 1;\n\tif (existing_nid_jack) {\n\t\tjack->tag = existing_nid_jack->tag;\n\n\t\t \n\t\tjack->jack_detect = existing_nid_jack->jack_detect;\n\t} else {\n\t\tjack->tag = codec->jacktbl.used;\n\t}\n\n\treturn jack;\n}\n\nvoid snd_hda_jack_tbl_disconnect(struct hda_codec *codec)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\n\t\tif (!codec->bus->shutdown && jack->jack)\n\t\t\tsnd_device_disconnect(codec->card, jack->jack);\n\t}\n}\n\nvoid snd_hda_jack_tbl_clear(struct hda_codec *codec)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\n\t\tstruct hda_jack_callback *cb, *next;\n\n\t\t \n\t\tif (!codec->bus->shutdown && jack->jack)\n\t\t\tsnd_device_free(codec->card, jack->jack);\n\n\t\tfor (cb = jack->callback; cb; cb = next) {\n\t\t\tnext = cb->next;\n\t\t\tkfree(cb);\n\t\t}\n\t}\n\tsnd_array_free(&codec->jacktbl);\n}\n\n#define get_jack_plug_state(sense) !!(sense & AC_PINSENSE_PRESENCE)\n\n \nstatic void jack_detect_update(struct hda_codec *codec,\n\t\t\t       struct hda_jack_tbl *jack)\n{\n\tif (!jack->jack_dirty)\n\t\treturn;\n\n\tif (jack->phantom_jack)\n\t\tjack->pin_sense = AC_PINSENSE_PRESENCE;\n\telse\n\t\tjack->pin_sense = read_pin_sense(codec, jack->nid,\n\t\t\t\t\t\t jack->dev_id);\n\n\t \n\tif (jack->gating_jack &&\n\t    !snd_hda_jack_detect_mst(codec, jack->gating_jack, jack->dev_id))\n\t\tjack->pin_sense &= ~AC_PINSENSE_PRESENCE;\n\n\tjack->jack_dirty = 0;\n\n\t \n\tif (jack->gated_jack) {\n\t\tstruct hda_jack_tbl *gated =\n\t\t\tsnd_hda_jack_tbl_get_mst(codec, jack->gated_jack,\n\t\t\t\t\t\t jack->dev_id);\n\t\tif (gated) {\n\t\t\tgated->jack_dirty = 1;\n\t\t\tjack_detect_update(codec, gated);\n\t\t}\n\t}\n}\n\n \nvoid snd_hda_jack_set_dirty_all(struct hda_codec *codec)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i;\n\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->nid)\n\t\t\tjack->jack_dirty = 1;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_set_dirty_all);\n\n \nu32 snd_hda_jack_pin_sense(struct hda_codec *codec, hda_nid_t nid, int dev_id)\n{\n\tstruct hda_jack_tbl *jack =\n\t\tsnd_hda_jack_tbl_get_mst(codec, nid, dev_id);\n\tif (jack) {\n\t\tjack_detect_update(codec, jack);\n\t\treturn jack->pin_sense;\n\t}\n\treturn read_pin_sense(codec, nid, dev_id);\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_pin_sense);\n\n \nint snd_hda_jack_detect_state_mst(struct hda_codec *codec,\n\t\t\t\t  hda_nid_t nid, int dev_id)\n{\n\tstruct hda_jack_tbl *jack =\n\t\tsnd_hda_jack_tbl_get_mst(codec, nid, dev_id);\n\tif (jack && jack->phantom_jack)\n\t\treturn HDA_JACK_PHANTOM;\n\telse if (snd_hda_jack_pin_sense(codec, nid, dev_id) &\n\t\t AC_PINSENSE_PRESENCE)\n\t\treturn HDA_JACK_PRESENT;\n\telse\n\t\treturn HDA_JACK_NOT_PRESENT;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_detect_state_mst);\n\nstatic struct hda_jack_callback *\nfind_callback_from_list(struct hda_jack_tbl *jack,\n\t\t\thda_jack_callback_fn func)\n{\n\tstruct hda_jack_callback *cb;\n\n\tif (!func)\n\t\treturn NULL;\n\n\tfor (cb = jack->callback; cb; cb = cb->next) {\n\t\tif (cb->func == func)\n\t\t\treturn cb;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct hda_jack_callback *\nsnd_hda_jack_detect_enable_callback_mst(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t\tint dev_id, hda_jack_callback_fn func)\n{\n\tstruct hda_jack_tbl *jack;\n\tstruct hda_jack_callback *callback = NULL;\n\tint err;\n\n\tjack = snd_hda_jack_tbl_new(codec, nid, dev_id);\n\tif (!jack)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcallback = find_callback_from_list(jack, func);\n\n\tif (func && !callback) {\n\t\tcallback = kzalloc(sizeof(*callback), GFP_KERNEL);\n\t\tif (!callback)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tcallback->func = func;\n\t\tcallback->nid = jack->nid;\n\t\tcallback->dev_id = jack->dev_id;\n\t\tcallback->next = jack->callback;\n\t\tjack->callback = callback;\n\t}\n\n\tif (jack->jack_detect)\n\t\treturn callback;  \n\tjack->jack_detect = 1;\n\tif (codec->jackpoll_interval > 0)\n\t\treturn callback;  \n\terr = snd_hda_codec_write_cache(codec, nid, 0,\n\t\t\t\t\t AC_VERB_SET_UNSOLICITED_ENABLE,\n\t\t\t\t\t AC_USRSP_EN | jack->tag);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn callback;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_detect_enable_callback_mst);\n\n \nint snd_hda_jack_detect_enable(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t       int dev_id)\n{\n\treturn PTR_ERR_OR_ZERO(snd_hda_jack_detect_enable_callback_mst(codec,\n\t\t\t\t\t\t\t\t       nid,\n\t\t\t\t\t\t\t\t       dev_id,\n\t\t\t\t\t\t\t\t       NULL));\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_detect_enable);\n\n \nint snd_hda_jack_set_gating_jack(struct hda_codec *codec, hda_nid_t gated_nid,\n\t\t\t\t hda_nid_t gating_nid)\n{\n\tstruct hda_jack_tbl *gated = snd_hda_jack_tbl_new(codec, gated_nid, 0);\n\tstruct hda_jack_tbl *gating =\n\t\tsnd_hda_jack_tbl_new(codec, gating_nid, 0);\n\n\tWARN_ON(codec->dp_mst);\n\n\tif (!gated || !gating)\n\t\treturn -EINVAL;\n\n\tgated->gating_jack = gating_nid;\n\tgating->gated_jack = gated_nid;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_set_gating_jack);\n\n \nint snd_hda_jack_bind_keymap(struct hda_codec *codec, hda_nid_t key_nid,\n\t\t\t     const struct hda_jack_keymap *keymap,\n\t\t\t     hda_nid_t jack_nid)\n{\n\tconst struct hda_jack_keymap *map;\n\tstruct hda_jack_tbl *key_gen = snd_hda_jack_tbl_get(codec, key_nid);\n\tstruct hda_jack_tbl *report_to = snd_hda_jack_tbl_get(codec, jack_nid);\n\n\tWARN_ON(codec->dp_mst);\n\n\tif (!key_gen || !report_to || !report_to->jack)\n\t\treturn -EINVAL;\n\n\tkey_gen->key_report_jack = jack_nid;\n\n\tif (keymap)\n\t\tfor (map = keymap; map->type; map++)\n\t\t\tsnd_jack_set_key(report_to->jack, map->type, map->key);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_bind_keymap);\n\n \nvoid snd_hda_jack_set_button_state(struct hda_codec *codec, hda_nid_t jack_nid,\n\t\t\t\t   int button_state)\n{\n\tstruct hda_jack_tbl *jack = snd_hda_jack_tbl_get(codec, jack_nid);\n\n\tif (!jack)\n\t\treturn;\n\n\tif (jack->key_report_jack) {\n\t\tstruct hda_jack_tbl *report_to =\n\t\t\tsnd_hda_jack_tbl_get(codec, jack->key_report_jack);\n\n\t\tif (report_to) {\n\t\t\treport_to->button_state = button_state;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tjack->button_state = button_state;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_set_button_state);\n\n \nvoid snd_hda_jack_report_sync(struct hda_codec *codec)\n{\n\tstruct hda_jack_tbl *jack;\n\tint i, state;\n\n\t \n\tjack = codec->jacktbl.list;\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->nid)\n\t\t\tjack_detect_update(codec, jack);\n\n\t \n\tjack = codec->jacktbl.list;\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++)\n\t\tif (jack->nid) {\n\t\t\tif (!jack->jack || jack->block_report)\n\t\t\t\tcontinue;\n\t\t\tstate = jack->button_state;\n\t\t\tif (get_jack_plug_state(jack->pin_sense))\n\t\t\t\tstate |= jack->type;\n\t\t\tsnd_jack_report(jack->jack, state);\n\t\t\tif (jack->button_state) {\n\t\t\t\tsnd_jack_report(jack->jack,\n\t\t\t\t\t\tstate & ~jack->button_state);\n\t\t\t\tjack->button_state = 0;  \n\t\t\t}\n\t\t}\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_report_sync);\n\n \nstatic int get_input_jack_type(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tswitch (get_defcfg_device(def_conf)) {\n\tcase AC_JACK_LINE_OUT:\n\tcase AC_JACK_SPEAKER:\n\t\treturn SND_JACK_LINEOUT;\n\tcase AC_JACK_HP_OUT:\n\t\treturn SND_JACK_HEADPHONE;\n\tcase AC_JACK_SPDIF_OUT:\n\tcase AC_JACK_DIG_OTHER_OUT:\n\t\treturn SND_JACK_AVOUT;\n\tcase AC_JACK_MIC_IN:\n\t\treturn SND_JACK_MICROPHONE;\n\tdefault:\n\t\treturn SND_JACK_LINEIN;\n\t}\n}\n\nstatic void hda_free_jack_priv(struct snd_jack *jack)\n{\n\tstruct hda_jack_tbl *jacks = jack->private_data;\n\tjacks->nid = 0;\n\tjacks->jack = NULL;\n}\n\n \nint snd_hda_jack_add_kctl_mst(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t      int dev_id, const char *name, bool phantom_jack,\n\t\t\t      int type, const struct hda_jack_keymap *keymap)\n{\n\tstruct hda_jack_tbl *jack;\n\tconst struct hda_jack_keymap *map;\n\tint err, state, buttons;\n\n\tjack = snd_hda_jack_tbl_new(codec, nid, dev_id);\n\tif (!jack)\n\t\treturn 0;\n\tif (jack->jack)\n\t\treturn 0;  \n\n\tif (!type)\n\t\ttype = get_input_jack_type(codec, nid);\n\n\tbuttons = 0;\n\tif (keymap) {\n\t\tfor (map = keymap; map->type; map++)\n\t\t\tbuttons |= map->type;\n\t}\n\n\terr = snd_jack_new(codec->card, name, type | buttons,\n\t\t\t   &jack->jack, true, phantom_jack);\n\tif (err < 0)\n\t\treturn err;\n\n\tjack->phantom_jack = !!phantom_jack;\n\tjack->type = type;\n\tjack->button_state = 0;\n\tjack->jack->private_data = jack;\n\tjack->jack->private_free = hda_free_jack_priv;\n\tif (keymap) {\n\t\tfor (map = keymap; map->type; map++)\n\t\t\tsnd_jack_set_key(jack->jack, map->type, map->key);\n\t}\n\n\tstate = snd_hda_jack_detect_mst(codec, nid, dev_id);\n\tsnd_jack_report(jack->jack, state ? jack->type : 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_add_kctl_mst);\n\nstatic int add_jack_kctl(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t const struct auto_pin_cfg *cfg,\n\t\t\t const char *base_name)\n{\n\tunsigned int def_conf, conn;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint err;\n\tbool phantom_jack;\n\n\tWARN_ON(codec->dp_mst);\n\n\tif (!nid)\n\t\treturn 0;\n\tdef_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tconn = get_defcfg_connect(def_conf);\n\tif (conn == AC_JACK_PORT_NONE)\n\t\treturn 0;\n\tphantom_jack = (conn != AC_JACK_PORT_COMPLEX) ||\n\t\t       !is_jack_detectable(codec, nid);\n\n\tif (base_name)\n\t\tstrscpy(name, base_name, sizeof(name));\n\telse\n\t\tsnd_hda_get_pin_label(codec, nid, cfg, name, sizeof(name), NULL);\n\tif (phantom_jack)\n\t\t \n\t\tstrncat(name, \" Phantom\", sizeof(name) - strlen(name) - 1);\n\terr = snd_hda_jack_add_kctl(codec, nid, name, phantom_jack, 0, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!phantom_jack)\n\t\treturn snd_hda_jack_detect_enable(codec, nid, 0);\n\treturn 0;\n}\n\n \nint snd_hda_jack_add_kctls(struct hda_codec *codec,\n\t\t\t   const struct auto_pin_cfg *cfg)\n{\n\tconst hda_nid_t *p;\n\tint i, err;\n\n\tfor (i = 0; i < cfg->num_inputs; i++) {\n\t\t \n\t\tif (cfg->inputs[i].is_headphone_mic) {\n\t\t\tif (auto_cfg_hp_outs(cfg) == 1)\n\t\t\t\terr = add_jack_kctl(codec, auto_cfg_hp_pins(cfg)[0],\n\t\t\t\t\t\t    cfg, \"Headphone Mic\");\n\t\t\telse\n\t\t\t\terr = add_jack_kctl(codec, cfg->inputs[i].pin,\n\t\t\t\t\t\t    cfg, \"Headphone Mic\");\n\t\t} else\n\t\t\terr = add_jack_kctl(codec, cfg->inputs[i].pin, cfg,\n\t\t\t\t\t    NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0, p = cfg->line_out_pins; i < cfg->line_outs; i++, p++) {\n\t\terr = add_jack_kctl(codec, *p, cfg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0, p = cfg->hp_pins; i < cfg->hp_outs; i++, p++) {\n\t\tif (*p == *cfg->line_out_pins)  \n\t\t\tbreak;\n\t\terr = add_jack_kctl(codec, *p, cfg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0, p = cfg->speaker_pins; i < cfg->speaker_outs; i++, p++) {\n\t\tif (*p == *cfg->line_out_pins)  \n\t\t\tbreak;\n\t\terr = add_jack_kctl(codec, *p, cfg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0, p = cfg->dig_out_pins; i < cfg->dig_outs; i++, p++) {\n\t\terr = add_jack_kctl(codec, *p, cfg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = add_jack_kctl(codec, cfg->dig_in_pin, cfg, NULL);\n\tif (err < 0)\n\t\treturn err;\n\terr = add_jack_kctl(codec, cfg->mono_out_pin, cfg, NULL);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_add_kctls);\n\nstatic void call_jack_callback(struct hda_codec *codec, unsigned int res,\n\t\t\t       struct hda_jack_tbl *jack)\n{\n\tstruct hda_jack_callback *cb;\n\n\tfor (cb = jack->callback; cb; cb = cb->next) {\n\t\tcb->jack = jack;\n\t\tcb->unsol_res = res;\n\t\tcb->func(codec, cb);\n\t}\n\tif (jack->gated_jack) {\n\t\tstruct hda_jack_tbl *gated =\n\t\t\tsnd_hda_jack_tbl_get_mst(codec, jack->gated_jack,\n\t\t\t\t\t\t jack->dev_id);\n\t\tif (gated) {\n\t\t\tfor (cb = gated->callback; cb; cb = cb->next) {\n\t\t\t\tcb->jack = gated;\n\t\t\t\tcb->unsol_res = res;\n\t\t\t\tcb->func(codec, cb);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid snd_hda_jack_unsol_event(struct hda_codec *codec, unsigned int res)\n{\n\tstruct hda_jack_tbl *event;\n\tint tag = (res & AC_UNSOL_RES_TAG) >> AC_UNSOL_RES_TAG_SHIFT;\n\n\tif (codec->dp_mst) {\n\t\tint dev_entry =\n\t\t\t(res & AC_UNSOL_RES_DE) >> AC_UNSOL_RES_DE_SHIFT;\n\n\t\tevent = snd_hda_jack_tbl_get_from_tag(codec, tag, dev_entry);\n\t} else {\n\t\tevent = snd_hda_jack_tbl_get_from_tag(codec, tag, 0);\n\t}\n\tif (!event)\n\t\treturn;\n\n\tif (event->key_report_jack) {\n\t\tstruct hda_jack_tbl *report_to =\n\t\t\tsnd_hda_jack_tbl_get_mst(codec, event->key_report_jack,\n\t\t\t\t\t\t event->dev_id);\n\t\tif (report_to)\n\t\t\treport_to->jack_dirty = 1;\n\t} else\n\t\tevent->jack_dirty = 1;\n\n\tcall_jack_callback(codec, res, event);\n\tsnd_hda_jack_report_sync(codec);\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_unsol_event);\n\n \nvoid snd_hda_jack_poll_all(struct hda_codec *codec)\n{\n\tstruct hda_jack_tbl *jack = codec->jacktbl.list;\n\tint i, changes = 0;\n\n\tfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\n\t\tunsigned int old_sense;\n\t\tif (!jack->nid || !jack->jack_dirty || jack->phantom_jack)\n\t\t\tcontinue;\n\t\told_sense = get_jack_plug_state(jack->pin_sense);\n\t\tjack_detect_update(codec, jack);\n\t\tif (old_sense == get_jack_plug_state(jack->pin_sense))\n\t\t\tcontinue;\n\t\tchanges = 1;\n\t\tcall_jack_callback(codec, 0, jack);\n\t}\n\tif (changes)\n\t\tsnd_hda_jack_report_sync(codec);\n}\nEXPORT_SYMBOL_GPL(snd_hda_jack_poll_all);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}