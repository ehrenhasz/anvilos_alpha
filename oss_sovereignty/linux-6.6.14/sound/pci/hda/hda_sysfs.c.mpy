{
  "module_name": "hda_sysfs.c",
  "hash_id": "7f7c3fd5f3b30569c4d9bcc68f6225e1b154afc2e67c75ebad07b45adb3748eb",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include <sound/hda_hwdep.h>\n#include <sound/minors.h>\n\n \nstruct hda_hint {\n\tconst char *key;\n\tconst char *val;\t \n};\n\n#ifdef CONFIG_PM\nstatic ssize_t power_on_acct_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tsnd_hda_update_power_acct(codec);\n\treturn sysfs_emit(buf, \"%u\\n\", jiffies_to_msecs(codec->power_on_acct));\n}\n\nstatic ssize_t power_off_acct_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tsnd_hda_update_power_acct(codec);\n\treturn sysfs_emit(buf, \"%u\\n\", jiffies_to_msecs(codec->power_off_acct));\n}\n\nstatic DEVICE_ATTR_RO(power_on_acct);\nstatic DEVICE_ATTR_RO(power_off_acct);\n#endif  \n\n#define CODEC_INFO_SHOW(type, field)\t\t\t\t\\\nstatic ssize_t type##_show(struct device *dev,\t\t\t\\\n\t\t\t   struct device_attribute *attr,\t\\\n\t\t\t   char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\t\t\\\n\treturn sysfs_emit(buf, \"0x%x\\n\", codec->field);\t\t\\\n}\n\n#define CODEC_INFO_STR_SHOW(type, field)\t\t\t\\\nstatic ssize_t type##_show(struct device *dev,\t\t\t\\\n\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\t\t\\\n\treturn sysfs_emit(buf, \"%s\\n\",\t\t\t\t\\\n\t\t\t  codec->field ? codec->field : \"\");\t\\\n}\n\nCODEC_INFO_SHOW(vendor_id, core.vendor_id);\nCODEC_INFO_SHOW(subsystem_id, core.subsystem_id);\nCODEC_INFO_SHOW(revision_id, core.revision_id);\nCODEC_INFO_SHOW(afg, core.afg);\nCODEC_INFO_SHOW(mfg, core.mfg);\nCODEC_INFO_STR_SHOW(vendor_name, core.vendor_name);\nCODEC_INFO_STR_SHOW(chip_name, core.chip_name);\nCODEC_INFO_STR_SHOW(modelname, modelname);\n\nstatic ssize_t pin_configs_show(struct hda_codec *codec,\n\t\t\t\tstruct snd_array *list,\n\t\t\t\tchar *buf)\n{\n\tconst struct hda_pincfg *pin;\n\tint i, len = 0;\n\tmutex_lock(&codec->user_mutex);\n\tsnd_array_for_each(list, i, pin) {\n\t\tlen += sysfs_emit_at(buf, len, \"0x%02x 0x%08x\\n\",\n\t\t\t\t     pin->nid, pin->cfg);\n\t}\n\tmutex_unlock(&codec->user_mutex);\n\treturn len;\n}\n\nstatic ssize_t init_pin_configs_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\treturn pin_configs_show(codec, &codec->init_pins, buf);\n}\n\nstatic ssize_t driver_pin_configs_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\treturn pin_configs_show(codec, &codec->driver_pins, buf);\n}\n\n#ifdef CONFIG_SND_HDA_RECONFIG\n\n \n\nstatic int clear_codec(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = snd_hda_codec_reset(codec);\n\tif (err < 0) {\n\t\tcodec_err(codec, \"The codec is being used, can't free.\\n\");\n\t\treturn err;\n\t}\n\tsnd_hda_sysfs_clear(codec);\n\treturn 0;\n}\n\nstatic int reconfig_codec(struct hda_codec *codec)\n{\n\tint err;\n\n\tsnd_hda_power_up(codec);\n\tcodec_info(codec, \"hda-codec: reconfiguring\\n\");\n\terr = snd_hda_codec_reset(codec);\n\tif (err < 0) {\n\t\tcodec_err(codec,\n\t\t\t   \"The codec is being used, can't reconfigure.\\n\");\n\t\tgoto error;\n\t}\n\terr = device_reprobe(hda_codec_dev(codec));\n\tif (err < 0)\n\t\tgoto error;\n\terr = snd_card_register(codec->card);\n error:\n\tsnd_hda_power_down(codec);\n\treturn err;\n}\n\n \nstatic char *kstrndup_noeol(const char *src, size_t len)\n{\n\tchar *s = kstrndup(src, len, GFP_KERNEL);\n\tchar *p;\n\tif (!s)\n\t\treturn NULL;\n\tp = strchr(s, '\\n');\n\tif (p)\n\t\t*p = 0;\n\treturn s;\n}\n\n#define CODEC_INFO_STORE(type, field)\t\t\t\t\\\nstatic ssize_t type##_store(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t    const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\t\t\\\n\tunsigned long val;\t\t\t\t\t\\\n\tint err = kstrtoul(buf, 0, &val);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\\\n\tcodec->field = val;\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\\\n}\n\n#define CODEC_INFO_STR_STORE(type, field)\t\t\t\\\nstatic ssize_t type##_store(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t    const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\t\t\\\n\tchar *s = kstrndup_noeol(buf, 64);\t\t\t\\\n\tif (!s)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\\\n\tkfree(codec->field);\t\t\t\t\t\\\n\tcodec->field = s;\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\\\n}\n\nCODEC_INFO_STORE(vendor_id, core.vendor_id);\nCODEC_INFO_STORE(subsystem_id, core.subsystem_id);\nCODEC_INFO_STORE(revision_id, core.revision_id);\nCODEC_INFO_STR_STORE(vendor_name, core.vendor_name);\nCODEC_INFO_STR_STORE(chip_name, core.chip_name);\nCODEC_INFO_STR_STORE(modelname, modelname);\n\n#define CODEC_ACTION_STORE(type)\t\t\t\t\\\nstatic ssize_t type##_store(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t    const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\t\t\\\n\tint err = 0;\t\t\t\t\t\t\\\n\tif (*buf)\t\t\t\t\t\t\\\n\t\terr = type##_codec(codec);\t\t\t\\\n\treturn err < 0 ? err : count;\t\t\t\t\\\n}\n\nCODEC_ACTION_STORE(reconfig);\nCODEC_ACTION_STORE(clear);\n\nstatic ssize_t init_verbs_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tconst struct hda_verb *v;\n\tint i, len = 0;\n\tmutex_lock(&codec->user_mutex);\n\tsnd_array_for_each(&codec->init_verbs, i, v) {\n\t\tlen += sysfs_emit_at(buf, len, \"0x%02x 0x%03x 0x%04x\\n\",\n\t\t\t\t     v->nid, v->verb, v->param);\n\t}\n\tmutex_unlock(&codec->user_mutex);\n\treturn len;\n}\n\nstatic int parse_init_verbs(struct hda_codec *codec, const char *buf)\n{\n\tstruct hda_verb *v;\n\tint nid, verb, param;\n\n\tif (sscanf(buf, \"%i %i %i\", &nid, &verb, &param) != 3)\n\t\treturn -EINVAL;\n\tif (!nid || !verb)\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->user_mutex);\n\tv = snd_array_new(&codec->init_verbs);\n\tif (!v) {\n\t\tmutex_unlock(&codec->user_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tv->nid = nid;\n\tv->verb = verb;\n\tv->param = param;\n\tmutex_unlock(&codec->user_mutex);\n\treturn 0;\n}\n\nstatic ssize_t init_verbs_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tint err = parse_init_verbs(codec, buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn count;\n}\n\nstatic ssize_t hints_show(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tconst struct hda_hint *hint;\n\tint i, len = 0;\n\tmutex_lock(&codec->user_mutex);\n\tsnd_array_for_each(&codec->hints, i, hint) {\n\t\tlen += sysfs_emit_at(buf, len, \"%s = %s\\n\",\n\t\t\t\t     hint->key, hint->val);\n\t}\n\tmutex_unlock(&codec->user_mutex);\n\treturn len;\n}\n\nstatic struct hda_hint *get_hint(struct hda_codec *codec, const char *key)\n{\n\tstruct hda_hint *hint;\n\tint i;\n\n\tsnd_array_for_each(&codec->hints, i, hint) {\n\t\tif (!strcmp(hint->key, key))\n\t\t\treturn hint;\n\t}\n\treturn NULL;\n}\n\nstatic void remove_trail_spaces(char *str)\n{\n\tchar *p;\n\tif (!*str)\n\t\treturn;\n\tp = str + strlen(str) - 1;\n\tfor (; isspace(*p); p--) {\n\t\t*p = 0;\n\t\tif (p == str)\n\t\t\treturn;\n\t}\n}\n\n#define MAX_HINTS\t1024\n\nstatic int parse_hints(struct hda_codec *codec, const char *buf)\n{\n\tchar *key, *val;\n\tstruct hda_hint *hint;\n\tint err = 0;\n\n\tbuf = skip_spaces(buf);\n\tif (!*buf || *buf == '#' || *buf == '\\n')\n\t\treturn 0;\n\tif (*buf == '=')\n\t\treturn -EINVAL;\n\tkey = kstrndup_noeol(buf, 1024);\n\tif (!key)\n\t\treturn -ENOMEM;\n\t \n\tval = strchr(key, '=');\n\tif (!val) {\n\t\tkfree(key);\n\t\treturn -EINVAL;\n\t}\n\t*val++ = 0;\n\tval = skip_spaces(val);\n\tremove_trail_spaces(key);\n\tremove_trail_spaces(val);\n\tmutex_lock(&codec->user_mutex);\n\thint = get_hint(codec, key);\n\tif (hint) {\n\t\t \n\t\tkfree(hint->key);\n\t\thint->key = key;\n\t\thint->val = val;\n\t\tgoto unlock;\n\t}\n\t \n\tif (codec->hints.used >= MAX_HINTS)\n\t\thint = NULL;\n\telse\n\t\thint = snd_array_new(&codec->hints);\n\tif (hint) {\n\t\thint->key = key;\n\t\thint->val = val;\n\t} else {\n\t\terr = -ENOMEM;\n\t}\n unlock:\n\tmutex_unlock(&codec->user_mutex);\n\tif (err)\n\t\tkfree(key);\n\treturn err;\n}\n\nstatic ssize_t hints_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tint err = parse_hints(codec, buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn count;\n}\n\nstatic ssize_t user_pin_configs_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\treturn pin_configs_show(codec, &codec->user_pins, buf);\n}\n\nstatic int parse_user_pin_configs(struct hda_codec *codec, const char *buf)\n{\n\tint nid, cfg, err;\n\n\tif (sscanf(buf, \"%i %i\", &nid, &cfg) != 2)\n\t\treturn -EINVAL;\n\tif (!nid)\n\t\treturn -EINVAL;\n\tmutex_lock(&codec->user_mutex);\n\terr = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);\n\tmutex_unlock(&codec->user_mutex);\n\treturn err;\n}\n\nstatic ssize_t user_pin_configs_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct hda_codec *codec = dev_get_drvdata(dev);\n\tint err = parse_user_pin_configs(codec, buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(init_verbs);\nstatic DEVICE_ATTR_RW(hints);\nstatic DEVICE_ATTR_RW(user_pin_configs);\nstatic DEVICE_ATTR_WO(reconfig);\nstatic DEVICE_ATTR_WO(clear);\n\n \nconst char *snd_hda_get_hint(struct hda_codec *codec, const char *key)\n{\n\tstruct hda_hint *hint = get_hint(codec, key);\n\treturn hint ? hint->val : NULL;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_hint);\n\n \nint snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)\n{\n\tconst char *p;\n\tint ret;\n\n\tmutex_lock(&codec->user_mutex);\n\tp = snd_hda_get_hint(codec, key);\n\tif (!p || !*p)\n\t\tret = -ENOENT;\n\telse {\n\t\tswitch (toupper(*p)) {\n\t\tcase 'T':  \n\t\tcase 'Y':  \n\t\tcase '1':\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&codec->user_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_bool_hint);\n\n \nint snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)\n{\n\tconst char *p;\n\tunsigned long val;\n\tint ret;\n\n\tmutex_lock(&codec->user_mutex);\n\tp = snd_hda_get_hint(codec, key);\n\tif (!p)\n\t\tret = -ENOENT;\n\telse if (kstrtoul(p, 0, &val))\n\t\tret = -EINVAL;\n\telse {\n\t\t*valp = val;\n\t\tret = 0;\n\t}\n\tmutex_unlock(&codec->user_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_hda_get_int_hint);\n#endif  \n\n \n#ifdef CONFIG_SND_HDA_RECONFIG\n#define RECONFIG_DEVICE_ATTR(name)\tDEVICE_ATTR_RW(name)\n#else\n#define RECONFIG_DEVICE_ATTR(name)\tDEVICE_ATTR_RO(name)\n#endif\nstatic RECONFIG_DEVICE_ATTR(vendor_id);\nstatic RECONFIG_DEVICE_ATTR(subsystem_id);\nstatic RECONFIG_DEVICE_ATTR(revision_id);\nstatic DEVICE_ATTR_RO(afg);\nstatic DEVICE_ATTR_RO(mfg);\nstatic RECONFIG_DEVICE_ATTR(vendor_name);\nstatic RECONFIG_DEVICE_ATTR(chip_name);\nstatic RECONFIG_DEVICE_ATTR(modelname);\nstatic DEVICE_ATTR_RO(init_pin_configs);\nstatic DEVICE_ATTR_RO(driver_pin_configs);\n\n\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\n\n \nenum {\n\tLINE_MODE_NONE,\n\tLINE_MODE_CODEC,\n\tLINE_MODE_MODEL,\n\tLINE_MODE_PINCFG,\n\tLINE_MODE_VERB,\n\tLINE_MODE_HINT,\n\tLINE_MODE_VENDOR_ID,\n\tLINE_MODE_SUBSYSTEM_ID,\n\tLINE_MODE_REVISION_ID,\n\tLINE_MODE_CHIP_NAME,\n\tNUM_LINE_MODES,\n};\n\nstatic inline int strmatch(const char *a, const char *b)\n{\n\treturn strncasecmp(a, b, strlen(b)) == 0;\n}\n\n \nstatic void parse_codec_mode(char *buf, struct hda_bus *bus,\n\t\t\t     struct hda_codec **codecp)\n{\n\tint vendorid, subid, caddr;\n\tstruct hda_codec *codec;\n\n\t*codecp = NULL;\n\tif (sscanf(buf, \"%i %i %i\", &vendorid, &subid, &caddr) == 3) {\n\t\tlist_for_each_codec(codec, bus) {\n\t\t\tif ((vendorid <= 0 || codec->core.vendor_id == vendorid) &&\n\t\t\t    (subid <= 0 || codec->core.subsystem_id == subid) &&\n\t\t\t    codec->core.addr == caddr) {\n\t\t\t\t*codecp = codec;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void parse_pincfg_mode(char *buf, struct hda_bus *bus,\n\t\t\t      struct hda_codec **codecp)\n{\n\tparse_user_pin_configs(*codecp, buf);\n}\n\nstatic void parse_verb_mode(char *buf, struct hda_bus *bus,\n\t\t\t    struct hda_codec **codecp)\n{\n\tparse_init_verbs(*codecp, buf);\n}\n\nstatic void parse_hint_mode(char *buf, struct hda_bus *bus,\n\t\t\t    struct hda_codec **codecp)\n{\n\tparse_hints(*codecp, buf);\n}\n\nstatic void parse_model_mode(char *buf, struct hda_bus *bus,\n\t\t\t     struct hda_codec **codecp)\n{\n\tkfree((*codecp)->modelname);\n\t(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);\n}\n\nstatic void parse_chip_name_mode(char *buf, struct hda_bus *bus,\n\t\t\t\t struct hda_codec **codecp)\n{\n\tsnd_hda_codec_set_name(*codecp, buf);\n}\n\n#define DEFINE_PARSE_ID_MODE(name) \\\nstatic void parse_##name##_mode(char *buf, struct hda_bus *bus, \\\n\t\t\t\t struct hda_codec **codecp) \\\n{ \\\n\tunsigned long val; \\\n\tif (!kstrtoul(buf, 0, &val)) \\\n\t\t(*codecp)->core.name = val; \\\n}\n\nDEFINE_PARSE_ID_MODE(vendor_id);\nDEFINE_PARSE_ID_MODE(subsystem_id);\nDEFINE_PARSE_ID_MODE(revision_id);\n\n\nstruct hda_patch_item {\n\tconst char *tag;\n\tconst char *alias;\n\tvoid (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);\n};\n\nstatic const struct hda_patch_item patch_items[NUM_LINE_MODES] = {\n\t[LINE_MODE_CODEC] = {\n\t\t.tag = \"[codec]\",\n\t\t.parser = parse_codec_mode,\n\t},\n\t[LINE_MODE_MODEL] = {\n\t\t.tag = \"[model]\",\n\t\t.parser = parse_model_mode,\n\t},\n\t[LINE_MODE_VERB] = {\n\t\t.tag = \"[verb]\",\n\t\t.alias = \"[init_verbs]\",\n\t\t.parser = parse_verb_mode,\n\t},\n\t[LINE_MODE_PINCFG] = {\n\t\t.tag = \"[pincfg]\",\n\t\t.alias = \"[user_pin_configs]\",\n\t\t.parser = parse_pincfg_mode,\n\t},\n\t[LINE_MODE_HINT] = {\n\t\t.tag = \"[hint]\",\n\t\t.alias = \"[hints]\",\n\t\t.parser = parse_hint_mode\n\t},\n\t[LINE_MODE_VENDOR_ID] = {\n\t\t.tag = \"[vendor_id]\",\n\t\t.parser = parse_vendor_id_mode,\n\t},\n\t[LINE_MODE_SUBSYSTEM_ID] = {\n\t\t.tag = \"[subsystem_id]\",\n\t\t.parser = parse_subsystem_id_mode,\n\t},\n\t[LINE_MODE_REVISION_ID] = {\n\t\t.tag = \"[revision_id]\",\n\t\t.parser = parse_revision_id_mode,\n\t},\n\t[LINE_MODE_CHIP_NAME] = {\n\t\t.tag = \"[chip_name]\",\n\t\t.parser = parse_chip_name_mode,\n\t},\n};\n\n \nstatic int parse_line_mode(char *buf, struct hda_bus *bus)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(patch_items); i++) {\n\t\tif (!patch_items[i].tag)\n\t\t\tcontinue;\n\t\tif (strmatch(buf, patch_items[i].tag))\n\t\t\treturn i;\n\t\tif (patch_items[i].alias && strmatch(buf, patch_items[i].alias))\n\t\t\treturn i;\n\t}\n\treturn LINE_MODE_NONE;\n}\n\n \nstatic int get_line_from_fw(char *buf, int size, size_t *fw_size_p,\n\t\t\t    const void **fw_data_p)\n{\n\tint len;\n\tsize_t fw_size = *fw_size_p;\n\tconst char *p = *fw_data_p;\n\n\twhile (isspace(*p) && fw_size) {\n\t\tp++;\n\t\tfw_size--;\n\t}\n\tif (!fw_size)\n\t\treturn 0;\n\n\tfor (len = 0; len < fw_size; len++) {\n\t\tif (!*p)\n\t\t\tbreak;\n\t\tif (*p == '\\n') {\n\t\t\tp++;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < size)\n\t\t\t*buf++ = *p++;\n\t}\n\t*buf = 0;\n\t*fw_size_p = fw_size - len;\n\t*fw_data_p = p;\n\tremove_trail_spaces(buf);\n\treturn 1;\n}\n\n \nint snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)\n{\n\tchar buf[128];\n\tstruct hda_codec *codec;\n\tint line_mode;\n\n\tline_mode = LINE_MODE_NONE;\n\tcodec = NULL;\n\twhile (get_line_from_fw(buf, sizeof(buf) - 1, &fw_size, &fw_buf)) {\n\t\tif (!*buf || *buf == '#' || *buf == '\\n')\n\t\t\tcontinue;\n\t\tif (*buf == '[')\n\t\t\tline_mode = parse_line_mode(buf, bus);\n\t\telse if (patch_items[line_mode].parser &&\n\t\t\t (codec || line_mode <= LINE_MODE_CODEC))\n\t\t\tpatch_items[line_mode].parser(buf, bus, &codec);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_load_patch);\n#endif  \n\n \nstatic struct attribute *hda_dev_attrs[] = {\n\t&dev_attr_vendor_id.attr,\n\t&dev_attr_subsystem_id.attr,\n\t&dev_attr_revision_id.attr,\n\t&dev_attr_afg.attr,\n\t&dev_attr_mfg.attr,\n\t&dev_attr_vendor_name.attr,\n\t&dev_attr_chip_name.attr,\n\t&dev_attr_modelname.attr,\n\t&dev_attr_init_pin_configs.attr,\n\t&dev_attr_driver_pin_configs.attr,\n#ifdef CONFIG_PM\n\t&dev_attr_power_on_acct.attr,\n\t&dev_attr_power_off_acct.attr,\n#endif\n#ifdef CONFIG_SND_HDA_RECONFIG\n\t&dev_attr_init_verbs.attr,\n\t&dev_attr_hints.attr,\n\t&dev_attr_user_pin_configs.attr,\n\t&dev_attr_reconfig.attr,\n\t&dev_attr_clear.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group hda_dev_attr_group = {\n\t.attrs\t= hda_dev_attrs,\n};\n\nconst struct attribute_group *snd_hda_dev_attr_groups[] = {\n\t&hda_dev_attr_group,\n\tNULL\n};\n\nvoid snd_hda_sysfs_init(struct hda_codec *codec)\n{\n\tmutex_init(&codec->user_mutex);\n#ifdef CONFIG_SND_HDA_RECONFIG\n\tsnd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);\n\tsnd_array_init(&codec->hints, sizeof(struct hda_hint), 32);\n\tsnd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);\n#endif\n}\n\nvoid snd_hda_sysfs_clear(struct hda_codec *codec)\n{\n#ifdef CONFIG_SND_HDA_RECONFIG\n\tstruct hda_hint *hint;\n\tint i;\n\n\t \n\tsnd_array_free(&codec->init_verbs);\n\t \n\tsnd_array_for_each(&codec->hints, i, hint) {\n\t\tkfree(hint->key);  \n\t}\n\tsnd_array_free(&codec->hints);\n\tsnd_array_free(&codec->user_pins);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}