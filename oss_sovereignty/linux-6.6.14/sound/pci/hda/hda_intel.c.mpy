{
  "module_name": "hda_intel.c",
  "hash_id": "fec2d8c0cd5ff387bd891fe3b0541aab8c5f32a25e3609e9f7a5865951cb919e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_intel.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <linux/clocksource.h>\n#include <linux/time.h>\n#include <linux/completion.h>\n#include <linux/acpi.h>\n#include <linux/pgtable.h>\n\n#ifdef CONFIG_X86\n \n#include <asm/set_memory.h>\n#include <asm/cpufeature.h>\n#endif\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_i915.h>\n#include <sound/intel-dsp-config.h>\n#include <linux/vgaarb.h>\n#include <linux/vga_switcheroo.h>\n#include <linux/apple-gmux.h>\n#include <linux/firmware.h>\n#include <sound/hda_codec.h>\n#include \"hda_controller.h\"\n#include \"hda_intel.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"hda_intel_trace.h\"\n\n \nenum {\n\tPOS_FIX_AUTO,\n\tPOS_FIX_LPIB,\n\tPOS_FIX_POSBUF,\n\tPOS_FIX_VIACOMBO,\n\tPOS_FIX_COMBO,\n\tPOS_FIX_SKL,\n\tPOS_FIX_FIFO,\n};\n\n \n#define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42\n#define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02\n\n \n#define NVIDIA_HDA_TRANSREG_ADDR      0x4e\n#define NVIDIA_HDA_ENABLE_COHBITS     0x0f\n#define NVIDIA_HDA_ISTRM_COH          0x4d\n#define NVIDIA_HDA_OSTRM_COH          0x4c\n#define NVIDIA_HDA_ENABLE_COHBIT      0x01\n\n \n#define INTEL_HDA_CGCTL\t 0x48\n#define INTEL_HDA_CGCTL_MISCBDCGE        (0x1 << 6)\n#define INTEL_SCH_HDA_DEVC      0x78\n#define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1<<11)\n\n \n \n#define ICH6_NUM_CAPTURE\t4\n#define ICH6_NUM_PLAYBACK\t4\n\n \n#define ULI_NUM_CAPTURE\t\t5\n#define ULI_NUM_PLAYBACK\t6\n\n \n#define ATIHDMI_NUM_CAPTURE\t0\n#define ATIHDMI_NUM_PLAYBACK\t8\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nstatic char *model[SNDRV_CARDS];\nstatic int position_fix[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = -1};\nstatic int bdl_pos_adj[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = -1};\nstatic int probe_mask[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = -1};\nstatic int probe_only[SNDRV_CARDS];\nstatic int jackpoll_ms[SNDRV_CARDS];\nstatic int single_cmd = -1;\nstatic int enable_msi = -1;\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\nstatic char *patch[SNDRV_CARDS];\n#endif\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\nstatic bool beep_mode[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] =\n\t\t\t\t\tCONFIG_SND_HDA_INPUT_BEEP_MODE};\n#endif\nstatic bool dmic_detect = 1;\nstatic bool ctl_dev_id = IS_ENABLED(CONFIG_SND_HDA_CTL_DEV_ID) ? 1 : 0;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Intel HD audio interface.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Intel HD audio interface.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Intel HD audio interface.\");\nmodule_param_array(model, charp, NULL, 0444);\nMODULE_PARM_DESC(model, \"Use the given board model.\");\nmodule_param_array(position_fix, int, NULL, 0444);\nMODULE_PARM_DESC(position_fix, \"DMA pointer read method.\"\n\t\t \"(-1 = system default, 0 = auto, 1 = LPIB, 2 = POSBUF, 3 = VIACOMBO, 4 = COMBO, 5 = SKL+, 6 = FIFO).\");\nmodule_param_array(bdl_pos_adj, int, NULL, 0644);\nMODULE_PARM_DESC(bdl_pos_adj, \"BDL position adjustment offset.\");\nmodule_param_array(probe_mask, int, NULL, 0444);\nMODULE_PARM_DESC(probe_mask, \"Bitmask to probe codecs (default = -1).\");\nmodule_param_array(probe_only, int, NULL, 0444);\nMODULE_PARM_DESC(probe_only, \"Only probing and no codec initialization.\");\nmodule_param_array(jackpoll_ms, int, NULL, 0444);\nMODULE_PARM_DESC(jackpoll_ms, \"Ms between polling for jack events (default = 0, using unsol events only)\");\nmodule_param(single_cmd, bint, 0444);\nMODULE_PARM_DESC(single_cmd, \"Use single command to communicate with codecs \"\n\t\t \"(for debugging only).\");\nmodule_param(enable_msi, bint, 0444);\nMODULE_PARM_DESC(enable_msi, \"Enable Message Signaled Interrupt (MSI)\");\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\nmodule_param_array(patch, charp, NULL, 0444);\nMODULE_PARM_DESC(patch, \"Patch file for Intel HD audio interface.\");\n#endif\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\nmodule_param_array(beep_mode, bool, NULL, 0444);\nMODULE_PARM_DESC(beep_mode, \"Select HDA Beep registration mode \"\n\t\t\t    \"(0=off, 1=on) (default=1).\");\n#endif\nmodule_param(dmic_detect, bool, 0444);\nMODULE_PARM_DESC(dmic_detect, \"Allow DSP driver selection (bypass this driver) \"\n\t\t\t     \"(0=off, 1=on) (default=1); \"\n\t\t \"deprecated, use snd-intel-dspcfg.dsp_driver option instead\");\nmodule_param(ctl_dev_id, bool, 0444);\nMODULE_PARM_DESC(ctl_dev_id, \"Use control device identifier (based on codec address).\");\n\n#ifdef CONFIG_PM\nstatic int param_set_xint(const char *val, const struct kernel_param *kp);\nstatic const struct kernel_param_ops param_ops_xint = {\n\t.set = param_set_xint,\n\t.get = param_get_int,\n};\n#define param_check_xint param_check_int\n\nstatic int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;\nmodule_param(power_save, xint, 0644);\nMODULE_PARM_DESC(power_save, \"Automatic power-saving timeout \"\n\t\t \"(in second, 0 = disable).\");\n\nstatic bool pm_blacklist = true;\nmodule_param(pm_blacklist, bool, 0644);\nMODULE_PARM_DESC(pm_blacklist, \"Enable power-management denylist\");\n\n \nstatic bool power_save_controller = 1;\nmodule_param(power_save_controller, bool, 0644);\nMODULE_PARM_DESC(power_save_controller, \"Reset controller in power save mode.\");\n#else\n#define power_save\t0\n#endif  \n\nstatic int align_buffer_size = -1;\nmodule_param(align_buffer_size, bint, 0644);\nMODULE_PARM_DESC(align_buffer_size,\n\t\t\"Force buffer and period sizes to be multiple of 128 bytes.\");\n\n#ifdef CONFIG_X86\nstatic int hda_snoop = -1;\nmodule_param_named(snoop, hda_snoop, bint, 0444);\nMODULE_PARM_DESC(snoop, \"Enable/disable snooping\");\n#else\n#define hda_snoop\t\ttrue\n#endif\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel HDA driver\");\n\n#if defined(CONFIG_PM) && defined(CONFIG_VGA_SWITCHEROO)\n#if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)\n#define SUPPORT_VGA_SWITCHEROO\n#endif\n#endif\n\n\n \n\n \nenum {\n\tAZX_DRIVER_ICH,\n\tAZX_DRIVER_PCH,\n\tAZX_DRIVER_SCH,\n\tAZX_DRIVER_SKL,\n\tAZX_DRIVER_HDMI,\n\tAZX_DRIVER_ATI,\n\tAZX_DRIVER_ATIHDMI,\n\tAZX_DRIVER_ATIHDMI_NS,\n\tAZX_DRIVER_GFHDMI,\n\tAZX_DRIVER_VIA,\n\tAZX_DRIVER_SIS,\n\tAZX_DRIVER_ULI,\n\tAZX_DRIVER_NVIDIA,\n\tAZX_DRIVER_TERA,\n\tAZX_DRIVER_CTX,\n\tAZX_DRIVER_CTHDA,\n\tAZX_DRIVER_CMEDIA,\n\tAZX_DRIVER_ZHAOXIN,\n\tAZX_DRIVER_LOONGSON,\n\tAZX_DRIVER_GENERIC,\n\tAZX_NUM_DRIVERS,  \n};\n\n#define azx_get_snoop_type(chip) \\\n\t(((chip)->driver_caps & AZX_DCAPS_SNOOP_MASK) >> 10)\n#define AZX_DCAPS_SNOOP_TYPE(type) ((AZX_SNOOP_TYPE_ ## type) << 10)\n\n \n#define AZX_DCAPS_INTEL_ICH \\\n\t(AZX_DCAPS_OLD_SSYNC | AZX_DCAPS_NO_ALIGN_BUFSIZE)\n\n \n#define AZX_DCAPS_INTEL_PCH_BASE \\\n\t(AZX_DCAPS_NO_ALIGN_BUFSIZE | AZX_DCAPS_COUNT_LPIB_DELAY |\\\n\t AZX_DCAPS_SNOOP_TYPE(SCH))\n\n \n#define AZX_DCAPS_INTEL_PCH_NOPM \\\n\t(AZX_DCAPS_INTEL_PCH_BASE | AZX_DCAPS_I915_COMPONENT)\n\n \n \n#define AZX_DCAPS_INTEL_PCH \\\n\t(AZX_DCAPS_INTEL_PCH_BASE | AZX_DCAPS_PM_RUNTIME)\n\n \n#define AZX_DCAPS_INTEL_HASWELL \\\n\t(  AZX_DCAPS_COUNT_LPIB_DELAY |\\\n\t AZX_DCAPS_PM_RUNTIME | AZX_DCAPS_I915_COMPONENT |\\\n\t AZX_DCAPS_SNOOP_TYPE(SCH))\n\n \n#define AZX_DCAPS_INTEL_BROADWELL \\\n\t(  AZX_DCAPS_POSFIX_LPIB |\\\n\t AZX_DCAPS_PM_RUNTIME | AZX_DCAPS_I915_COMPONENT |\\\n\t AZX_DCAPS_SNOOP_TYPE(SCH))\n\n#define AZX_DCAPS_INTEL_BAYTRAIL \\\n\t(AZX_DCAPS_INTEL_PCH_BASE | AZX_DCAPS_I915_COMPONENT)\n\n#define AZX_DCAPS_INTEL_BRASWELL \\\n\t(AZX_DCAPS_INTEL_PCH_BASE | AZX_DCAPS_PM_RUNTIME |\\\n\t AZX_DCAPS_I915_COMPONENT)\n\n#define AZX_DCAPS_INTEL_SKYLAKE \\\n\t(AZX_DCAPS_INTEL_PCH_BASE | AZX_DCAPS_PM_RUNTIME |\\\n\t AZX_DCAPS_SEPARATE_STREAM_TAG | AZX_DCAPS_I915_COMPONENT)\n\n#define AZX_DCAPS_INTEL_BROXTON\t\tAZX_DCAPS_INTEL_SKYLAKE\n\n \n#define AZX_DCAPS_PRESET_ATI_SB \\\n\t(AZX_DCAPS_NO_TCSEL | AZX_DCAPS_POSFIX_LPIB |\\\n\t AZX_DCAPS_SNOOP_TYPE(ATI))\n\n \n#define AZX_DCAPS_PRESET_ATI_HDMI \\\n\t(AZX_DCAPS_NO_TCSEL | AZX_DCAPS_POSFIX_LPIB|\\\n\t AZX_DCAPS_NO_MSI64)\n\n \n#define AZX_DCAPS_PRESET_ATI_HDMI_NS \\\n\t(AZX_DCAPS_PRESET_ATI_HDMI | AZX_DCAPS_SNOOP_OFF)\n\n \n#define AZX_DCAPS_PRESET_AMD_SB \\\n\t(AZX_DCAPS_NO_TCSEL | AZX_DCAPS_AMD_WORKAROUND |\\\n\t AZX_DCAPS_SNOOP_TYPE(ATI) | AZX_DCAPS_PM_RUNTIME |\\\n\t AZX_DCAPS_RETRY_PROBE)\n\n \n#define AZX_DCAPS_PRESET_NVIDIA \\\n\t(AZX_DCAPS_NO_MSI | AZX_DCAPS_CORBRP_SELF_CLEAR |\\\n\t AZX_DCAPS_SNOOP_TYPE(NVIDIA))\n\n#define AZX_DCAPS_PRESET_CTHDA \\\n\t(AZX_DCAPS_NO_MSI | AZX_DCAPS_POSFIX_LPIB |\\\n\t AZX_DCAPS_NO_64BIT |\\\n\t AZX_DCAPS_4K_BDLE_BOUNDARY | AZX_DCAPS_SNOOP_OFF)\n\n \n#ifdef SUPPORT_VGA_SWITCHEROO\n#define use_vga_switcheroo(chip)\t((chip)->use_vga_switcheroo)\n#define needs_eld_notify_link(chip)\t((chip)->bus.keep_power)\n#else\n#define use_vga_switcheroo(chip)\t0\n#define needs_eld_notify_link(chip)\tfalse\n#endif\n\nstatic const char * const driver_short_names[] = {\n\t[AZX_DRIVER_ICH] = \"HDA Intel\",\n\t[AZX_DRIVER_PCH] = \"HDA Intel PCH\",\n\t[AZX_DRIVER_SCH] = \"HDA Intel MID\",\n\t[AZX_DRIVER_SKL] = \"HDA Intel PCH\",  \n\t[AZX_DRIVER_HDMI] = \"HDA Intel HDMI\",\n\t[AZX_DRIVER_ATI] = \"HDA ATI SB\",\n\t[AZX_DRIVER_ATIHDMI] = \"HDA ATI HDMI\",\n\t[AZX_DRIVER_ATIHDMI_NS] = \"HDA ATI HDMI\",\n\t[AZX_DRIVER_GFHDMI] = \"HDA GF HDMI\",\n\t[AZX_DRIVER_VIA] = \"HDA VIA VT82xx\",\n\t[AZX_DRIVER_SIS] = \"HDA SIS966\",\n\t[AZX_DRIVER_ULI] = \"HDA ULI M5461\",\n\t[AZX_DRIVER_NVIDIA] = \"HDA NVidia\",\n\t[AZX_DRIVER_TERA] = \"HDA Teradici\", \n\t[AZX_DRIVER_CTX] = \"HDA Creative\", \n\t[AZX_DRIVER_CTHDA] = \"HDA Creative\",\n\t[AZX_DRIVER_CMEDIA] = \"HDA C-Media\",\n\t[AZX_DRIVER_ZHAOXIN] = \"HDA Zhaoxin\",\n\t[AZX_DRIVER_LOONGSON] = \"HDA Loongson\",\n\t[AZX_DRIVER_GENERIC] = \"HD-Audio Generic\",\n};\n\nstatic int azx_acquire_irq(struct azx *chip, int do_disconnect);\nstatic void set_default_power_save(struct azx *chip);\n\n \n \nstatic void update_pci_byte(struct pci_dev *pci, unsigned int reg,\n\t\t\t    unsigned char mask, unsigned char val)\n{\n\tunsigned char data;\n\n\tpci_read_config_byte(pci, reg, &data);\n\tdata &= ~mask;\n\tdata |= (val & mask);\n\tpci_write_config_byte(pci, reg, data);\n}\n\nstatic void azx_init_pci(struct azx *chip)\n{\n\tint snoop_type = azx_get_snoop_type(chip);\n\n\t \n\tif (!(chip->driver_caps & AZX_DCAPS_NO_TCSEL)) {\n\t\tdev_dbg(chip->card->dev, \"Clearing TCSEL\\n\");\n\t\tupdate_pci_byte(chip->pci, AZX_PCIREG_TCSEL, 0x07, 0);\n\t}\n\n\t \n\tif (snoop_type == AZX_SNOOP_TYPE_ATI) {\n\t\tdev_dbg(chip->card->dev, \"Setting ATI snoop: %d\\n\",\n\t\t\tazx_snoop(chip));\n\t\tupdate_pci_byte(chip->pci,\n\t\t\t\tATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 0x07,\n\t\t\t\tazx_snoop(chip) ? ATI_SB450_HDAUDIO_ENABLE_SNOOP : 0);\n\t}\n\n\t \n\tif (snoop_type == AZX_SNOOP_TYPE_NVIDIA) {\n\t\tdev_dbg(chip->card->dev, \"Setting Nvidia snoop: %d\\n\",\n\t\t\tazx_snoop(chip));\n\t\tupdate_pci_byte(chip->pci,\n\t\t\t\tNVIDIA_HDA_TRANSREG_ADDR,\n\t\t\t\t0x0f, NVIDIA_HDA_ENABLE_COHBITS);\n\t\tupdate_pci_byte(chip->pci,\n\t\t\t\tNVIDIA_HDA_ISTRM_COH,\n\t\t\t\t0x01, NVIDIA_HDA_ENABLE_COHBIT);\n\t\tupdate_pci_byte(chip->pci,\n\t\t\t\tNVIDIA_HDA_OSTRM_COH,\n\t\t\t\t0x01, NVIDIA_HDA_ENABLE_COHBIT);\n\t}\n\n\t \n\tif (snoop_type == AZX_SNOOP_TYPE_SCH) {\n\t\tunsigned short snoop;\n\t\tpci_read_config_word(chip->pci, INTEL_SCH_HDA_DEVC, &snoop);\n\t\tif ((!azx_snoop(chip) && !(snoop & INTEL_SCH_HDA_DEVC_NOSNOOP)) ||\n\t\t    (azx_snoop(chip) && (snoop & INTEL_SCH_HDA_DEVC_NOSNOOP))) {\n\t\t\tsnoop &= ~INTEL_SCH_HDA_DEVC_NOSNOOP;\n\t\t\tif (!azx_snoop(chip))\n\t\t\t\tsnoop |= INTEL_SCH_HDA_DEVC_NOSNOOP;\n\t\t\tpci_write_config_word(chip->pci, INTEL_SCH_HDA_DEVC, snoop);\n\t\t\tpci_read_config_word(chip->pci,\n\t\t\t\tINTEL_SCH_HDA_DEVC, &snoop);\n\t\t}\n\t\tdev_dbg(chip->card->dev, \"SCH snoop: %s\\n\",\n\t\t\t(snoop & INTEL_SCH_HDA_DEVC_NOSNOOP) ?\n\t\t\t\"Disabled\" : \"Enabled\");\n        }\n}\n\n \nstatic void bxt_reduce_dma_latency(struct azx *chip)\n{\n\tu32 val;\n\n\tval = azx_readl(chip, VS_EM4L);\n\tval &= (0x3 << 20);\n\tazx_writel(chip, VS_EM4L, val);\n}\n\n \nstatic int intel_get_lctl_scf(struct azx *chip)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstatic const int preferred_bits[] = { 2, 3, 1, 4, 5 };\n\tu32 val, t;\n\tint i;\n\n\tval = readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCAP);\n\n\tfor (i = 0; i < ARRAY_SIZE(preferred_bits); i++) {\n\t\tt = preferred_bits[i];\n\t\tif (val & (1 << t))\n\t\t\treturn t;\n\t}\n\n\tdev_warn(chip->card->dev, \"set audio clock frequency to 6MHz\");\n\treturn 0;\n}\n\nstatic int intel_ml_lctl_set_power(struct azx *chip, int state)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tu32 val;\n\tint timeout;\n\n\t \n\tval = readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);\n\tval &= ~AZX_ML_LCTL_SPA;\n\tval |= state << AZX_ML_LCTL_SPA_SHIFT;\n\twritel(val, bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);\n\t \n\ttimeout = 50;\n\twhile (timeout) {\n\t\tif (((readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL)) &\n\t\t    AZX_ML_LCTL_CPA) == (state << AZX_ML_LCTL_CPA_SHIFT))\n\t\t\treturn 0;\n\t\ttimeout--;\n\t\tudelay(10);\n\t}\n\n\treturn -1;\n}\n\nstatic void intel_init_lctl(struct azx *chip)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tu32 val;\n\tint ret;\n\n\t \n\tval = readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);\n\t \n\tif ((val & AZX_ML_LCTL_SCF) != 0)\n\t\treturn;\n\n\t \n\tif (((val & AZX_ML_LCTL_SPA) >> AZX_ML_LCTL_SPA_SHIFT) !=\n\t\t((val & AZX_ML_LCTL_CPA) >> AZX_ML_LCTL_CPA_SHIFT))\n\t\treturn;\n\n\t \n\tret = intel_ml_lctl_set_power(chip, 0);\n\tudelay(100);\n\tif (ret)\n\t\tgoto set_spa;\n\n\t \n\tval &= ~AZX_ML_LCTL_SCF;\n\tval |= intel_get_lctl_scf(chip);\n\twritel(val, bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);\n\nset_spa:\n\t \n\tintel_ml_lctl_set_power(chip, 1);\n\tudelay(100);\n}\n\nstatic void hda_intel_init_chip(struct azx *chip, bool full_reset)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct pci_dev *pci = chip->pci;\n\tu32 val;\n\n\tsnd_hdac_set_codec_wakeup(bus, true);\n\tif (chip->driver_type == AZX_DRIVER_SKL) {\n\t\tpci_read_config_dword(pci, INTEL_HDA_CGCTL, &val);\n\t\tval = val & ~INTEL_HDA_CGCTL_MISCBDCGE;\n\t\tpci_write_config_dword(pci, INTEL_HDA_CGCTL, val);\n\t}\n\tazx_init_chip(chip, full_reset);\n\tif (chip->driver_type == AZX_DRIVER_SKL) {\n\t\tpci_read_config_dword(pci, INTEL_HDA_CGCTL, &val);\n\t\tval = val | INTEL_HDA_CGCTL_MISCBDCGE;\n\t\tpci_write_config_dword(pci, INTEL_HDA_CGCTL, val);\n\t}\n\n\tsnd_hdac_set_codec_wakeup(bus, false);\n\n\t \n\tif (HDA_CONTROLLER_IS_APL(pci))\n\t\tbxt_reduce_dma_latency(chip);\n\n\tif (bus->mlcap != NULL)\n\t\tintel_init_lctl(chip);\n}\n\n \nstatic int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,\n\t\t\t\t   unsigned int pos)\n{\n\tstruct snd_pcm_substream *substream = azx_dev->core.substream;\n\tint stream = substream->stream;\n\tunsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);\n\tint delay;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdelay = pos - lpib_pos;\n\telse\n\t\tdelay = lpib_pos - pos;\n\tif (delay < 0) {\n\t\tif (delay >= azx_dev->core.delay_negative_threshold)\n\t\t\tdelay = 0;\n\t\telse\n\t\t\tdelay += azx_dev->core.bufsize;\n\t}\n\n\tif (delay >= azx_dev->core.period_bytes) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"Unstable LPIB (%d >= %d); disabling LPIB delay counting\\n\",\n\t\t\t delay, azx_dev->core.period_bytes);\n\t\tdelay = 0;\n\t\tchip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;\n\t\tchip->get_delay[stream] = NULL;\n\t}\n\n\treturn bytes_to_frames(substream->runtime, delay);\n}\n\nstatic int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);\n\n \nstatic int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tint ok;\n\n\tok = azx_position_ok(chip, azx_dev);\n\tif (ok == 1) {\n\t\tazx_dev->irq_pending = 0;\n\t\treturn ok;\n\t} else if (ok == 0) {\n\t\t \n\t\tazx_dev->irq_pending = 1;\n\t\tschedule_work(&hda->irq_pending_work);\n\t}\n\treturn 0;\n}\n\n#define display_power(chip, enable) \\\n\tsnd_hdac_display_power(azx_bus(chip), HDA_CODEC_IDX_CONTROLLER, enable)\n\n \nstatic int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)\n{\n\tstruct snd_pcm_substream *substream = azx_dev->core.substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint stream = substream->stream;\n\tu32 wallclk;\n\tunsigned int pos;\n\tsnd_pcm_uframes_t hwptr, target;\n\n\t \n\tif (chip->driver_type == AZX_DRIVER_LOONGSON)\n\t\treturn 1;\n\n\twallclk = azx_readl(chip, WALLCLK) - azx_dev->core.start_wallclk;\n\tif (wallclk < (azx_dev->core.period_wallclk * 2) / 3)\n\t\treturn -1;\t \n\n\tif (chip->get_position[stream])\n\t\tpos = chip->get_position[stream](chip, azx_dev);\n\telse {  \n\t\tpos = azx_get_pos_posbuf(chip, azx_dev);\n\t\tif (!pos || pos == (u32)-1) {\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"Invalid position buffer, using LPIB read method instead.\\n\");\n\t\t\tchip->get_position[stream] = azx_get_pos_lpib;\n\t\t\tif (chip->get_position[0] == azx_get_pos_lpib &&\n\t\t\t    chip->get_position[1] == azx_get_pos_lpib)\n\t\t\t\tazx_bus(chip)->use_posbuf = false;\n\t\t\tpos = azx_get_pos_lpib(chip, azx_dev);\n\t\t\tchip->get_delay[stream] = NULL;\n\t\t} else {\n\t\t\tchip->get_position[stream] = azx_get_pos_posbuf;\n\t\t\tif (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)\n\t\t\t\tchip->get_delay[stream] = azx_get_delay_from_lpib;\n\t\t}\n\t}\n\n\tif (pos >= azx_dev->core.bufsize)\n\t\tpos = 0;\n\n\tif (WARN_ONCE(!azx_dev->core.period_bytes,\n\t\t      \"hda-intel: zero azx_dev->period_bytes\"))\n\t\treturn -1;  \n\tif (wallclk < (azx_dev->core.period_wallclk * 5) / 4 &&\n\t    pos % azx_dev->core.period_bytes > azx_dev->core.period_bytes / 2)\n\t\t \n\t\treturn chip->bdl_pos_adj ? 0 : -1;\n\tazx_dev->core.start_wallclk += wallclk;\n\n\tif (azx_dev->core.no_period_wakeup)\n\t\treturn 1;  \n\n\tif (runtime->hw_ptr_base != runtime->hw_ptr_interrupt)\n\t\treturn 1;  \n\n\t \n\tpos = bytes_to_frames(runtime, pos);\n\thwptr = runtime->hw_ptr_base + pos;\n\tif (hwptr < runtime->status->hw_ptr)\n\t\thwptr += runtime->buffer_size;\n\ttarget = runtime->hw_ptr_interrupt + runtime->period_size;\n\tif (hwptr < target) {\n\t\t \n\t\treturn chip->bdl_pos_adj ? 0 : -1;\n\t}\n\n\treturn 1;  \n}\n\n \nstatic void azx_irq_pending_work(struct work_struct *work)\n{\n\tstruct hda_intel *hda = container_of(work, struct hda_intel, irq_pending_work);\n\tstruct azx *chip = &hda->chip;\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct hdac_stream *s;\n\tint pending, ok;\n\n\tif (!hda->irq_pending_warned) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\\n\",\n\t\t\t chip->card->number);\n\t\thda->irq_pending_warned = 1;\n\t}\n\n\tfor (;;) {\n\t\tpending = 0;\n\t\tspin_lock_irq(&bus->reg_lock);\n\t\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\t\tstruct azx_dev *azx_dev = stream_to_azx_dev(s);\n\t\t\tif (!azx_dev->irq_pending ||\n\t\t\t    !s->substream ||\n\t\t\t    !s->running)\n\t\t\t\tcontinue;\n\t\t\tok = azx_position_ok(chip, azx_dev);\n\t\t\tif (ok > 0) {\n\t\t\t\tazx_dev->irq_pending = 0;\n\t\t\t\tspin_unlock(&bus->reg_lock);\n\t\t\t\tsnd_pcm_period_elapsed(s->substream);\n\t\t\t\tspin_lock(&bus->reg_lock);\n\t\t\t} else if (ok < 0) {\n\t\t\t\tpending = 0;\t \n\t\t\t} else\n\t\t\t\tpending++;\n\t\t}\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t\tif (!pending)\n\t\t\treturn;\n\t\tmsleep(1);\n\t}\n}\n\n \nstatic void azx_clear_irq_pending(struct azx *chip)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct hdac_stream *s;\n\n\tspin_lock_irq(&bus->reg_lock);\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tstruct azx_dev *azx_dev = stream_to_azx_dev(s);\n\t\tazx_dev->irq_pending = 0;\n\t}\n\tspin_unlock_irq(&bus->reg_lock);\n}\n\nstatic int azx_acquire_irq(struct azx *chip, int do_disconnect)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\n\tif (request_irq(chip->pci->irq, azx_interrupt,\n\t\t\tchip->msi ? 0 : IRQF_SHARED,\n\t\t\tchip->card->irq_descr, chip)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"unable to grab IRQ %d, disabling device\\n\",\n\t\t\tchip->pci->irq);\n\t\tif (do_disconnect)\n\t\t\tsnd_card_disconnect(chip->card);\n\t\treturn -1;\n\t}\n\tbus->irq = chip->pci->irq;\n\tchip->card->sync_irq = bus->irq;\n\tpci_intx(chip->pci, !chip->msi);\n\treturn 0;\n}\n\n \nstatic unsigned int azx_via_get_position(struct azx *chip,\n\t\t\t\t\t struct azx_dev *azx_dev)\n{\n\tunsigned int link_pos, mini_pos, bound_pos;\n\tunsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;\n\tunsigned int fifo_size;\n\n\tlink_pos = snd_hdac_stream_get_pos_lpib(azx_stream(azx_dev));\n\tif (azx_dev->core.substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\treturn link_pos;\n\t}\n\n\t \n\t \n\tmod_dma_pos = le32_to_cpu(*azx_dev->core.posbuf);\n\tmod_dma_pos %= azx_dev->core.period_bytes;\n\n\tfifo_size = azx_stream(azx_dev)->fifo_size - 1;\n\n\tif (azx_dev->insufficient) {\n\t\t \n\t\tif (link_pos <= fifo_size)\n\t\t\treturn 0;\n\n\t\tazx_dev->insufficient = 0;\n\t}\n\n\tif (link_pos <= fifo_size)\n\t\tmini_pos = azx_dev->core.bufsize + link_pos - fifo_size;\n\telse\n\t\tmini_pos = link_pos - fifo_size;\n\n\t \n\tmod_mini_pos = mini_pos % azx_dev->core.period_bytes;\n\tmod_link_pos = link_pos % azx_dev->core.period_bytes;\n\tif (mod_link_pos >= fifo_size)\n\t\tbound_pos = link_pos - mod_link_pos;\n\telse if (mod_dma_pos >= mod_mini_pos)\n\t\tbound_pos = mini_pos - mod_mini_pos;\n\telse {\n\t\tbound_pos = mini_pos - mod_mini_pos + azx_dev->core.period_bytes;\n\t\tif (bound_pos >= azx_dev->core.bufsize)\n\t\t\tbound_pos = 0;\n\t}\n\n\t \n\treturn bound_pos + mod_dma_pos;\n}\n\n#define AMD_FIFO_SIZE\t32\n\n \nstatic unsigned int azx_get_pos_fifo(struct azx *chip, struct azx_dev *azx_dev)\n{\n\tstruct snd_pcm_substream *substream = azx_dev->core.substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int pos, delay;\n\n\tpos = snd_hdac_stream_get_pos_lpib(azx_stream(azx_dev));\n\tif (!runtime)\n\t\treturn pos;\n\n\truntime->delay = AMD_FIFO_SIZE;\n\tdelay = frames_to_bytes(runtime, AMD_FIFO_SIZE);\n\tif (azx_dev->insufficient) {\n\t\tif (pos < delay) {\n\t\t\tdelay = pos;\n\t\t\truntime->delay = bytes_to_frames(runtime, pos);\n\t\t} else {\n\t\t\tazx_dev->insufficient = 0;\n\t\t}\n\t}\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tif (pos < delay)\n\t\t\tpos += azx_dev->core.bufsize;\n\t\tpos -= delay;\n\t}\n\n\treturn pos;\n}\n\nstatic int azx_get_delay_from_fifo(struct azx *chip, struct azx_dev *azx_dev,\n\t\t\t\t   unsigned int pos)\n{\n\tstruct snd_pcm_substream *substream = azx_dev->core.substream;\n\n\t \n\treturn substream->runtime->delay;\n}\n\nstatic void __azx_shutdown_chip(struct azx *chip, bool skip_link_reset)\n{\n\tazx_stop_chip(chip);\n\tif (!skip_link_reset)\n\t\tazx_enter_link_reset(chip);\n\tazx_clear_irq_pending(chip);\n\tdisplay_power(chip, false);\n}\n\n#ifdef CONFIG_PM\nstatic DEFINE_MUTEX(card_list_lock);\nstatic LIST_HEAD(card_list);\n\nstatic void azx_shutdown_chip(struct azx *chip)\n{\n\t__azx_shutdown_chip(chip, false);\n}\n\nstatic void azx_add_card_list(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tmutex_lock(&card_list_lock);\n\tlist_add(&hda->list, &card_list);\n\tmutex_unlock(&card_list_lock);\n}\n\nstatic void azx_del_card_list(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tmutex_lock(&card_list_lock);\n\tlist_del_init(&hda->list);\n\tmutex_unlock(&card_list_lock);\n}\n\n \nstatic int param_set_xint(const char *val, const struct kernel_param *kp)\n{\n\tstruct hda_intel *hda;\n\tstruct azx *chip;\n\tint prev = power_save;\n\tint ret = param_set_int(val, kp);\n\n\tif (ret || prev == power_save)\n\t\treturn ret;\n\n\tmutex_lock(&card_list_lock);\n\tlist_for_each_entry(hda, &card_list, list) {\n\t\tchip = &hda->chip;\n\t\tif (!hda->probe_continued || chip->disabled)\n\t\t\tcontinue;\n\t\tsnd_hda_set_power_save(&chip->bus, power_save * 1000);\n\t}\n\tmutex_unlock(&card_list_lock);\n\treturn 0;\n}\n\n \nstatic bool azx_is_pm_ready(struct snd_card *card)\n{\n\tstruct azx *chip;\n\tstruct hda_intel *hda;\n\n\tif (!card)\n\t\treturn false;\n\tchip = card->private_data;\n\thda = container_of(chip, struct hda_intel, chip);\n\tif (chip->disabled || hda->init_failed || !chip->running)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void __azx_runtime_resume(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct hda_codec *codec;\n\tint status;\n\n\tdisplay_power(chip, true);\n\tif (hda->need_i915_power)\n\t\tsnd_hdac_i915_set_bclk(bus);\n\n\t \n\tstatus = azx_readw(chip, STATESTS);\n\n\tazx_init_pci(chip);\n\thda_intel_init_chip(chip, true);\n\n\t \n\tif (!chip->pm_prepared) {\n\t\tlist_for_each_codec(codec, &chip->bus) {\n\t\t\tif (codec->relaxed_resume)\n\t\t\t\tcontinue;\n\n\t\t\tif (codec->forced_resume || (status & (1 << codec->addr)))\n\t\t\t\tpm_request_resume(hda_codec_dev(codec));\n\t\t}\n\t}\n\n\t \n\tif (!hda->need_i915_power)\n\t\tdisplay_power(chip, false);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int azx_prepare(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\n\tchip = card->private_data;\n\tchip->pm_prepared = 1;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tflush_work(&azx_bus(chip)->unsol_work);\n\n\t \n\treturn 0;\n}\n\nstatic void azx_complete(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn;\n\n\tchip = card->private_data;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\tchip->pm_prepared = 0;\n}\n\nstatic int azx_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\tstruct hdac_bus *bus;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\n\tchip = card->private_data;\n\tbus = azx_bus(chip);\n\tazx_shutdown_chip(chip);\n\tif (bus->irq >= 0) {\n\t\tfree_irq(bus->irq, chip);\n\t\tbus->irq = -1;\n\t\tchip->card->sync_irq = -1;\n\t}\n\n\tif (chip->msi)\n\t\tpci_disable_msi(chip->pci);\n\n\ttrace_azx_suspend(chip);\n\treturn 0;\n}\n\nstatic int azx_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\n\tchip = card->private_data;\n\tif (chip->msi)\n\t\tif (pci_enable_msi(chip->pci) < 0)\n\t\t\tchip->msi = 0;\n\tif (azx_acquire_irq(chip, 1) < 0)\n\t\treturn -EIO;\n\n\t__azx_runtime_resume(chip);\n\n\ttrace_azx_resume(chip);\n\treturn 0;\n}\n\n \nstatic int azx_freeze_noirq(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip = card->private_data;\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\tif (chip->driver_type == AZX_DRIVER_SKL)\n\t\tpci_set_power_state(pci, PCI_D3hot);\n\n\treturn 0;\n}\n\nstatic int azx_thaw_noirq(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip = card->private_data;\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\tif (chip->driver_type == AZX_DRIVER_SKL)\n\t\tpci_set_power_state(pci, PCI_D0);\n\n\treturn 0;\n}\n#endif  \n\nstatic int azx_runtime_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\tchip = card->private_data;\n\n\t \n\tazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) | STATESTS_INT_MASK);\n\n\tazx_shutdown_chip(chip);\n\ttrace_azx_runtime_suspend(chip);\n\treturn 0;\n}\n\nstatic int azx_runtime_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\n\tif (!azx_is_pm_ready(card))\n\t\treturn 0;\n\tchip = card->private_data;\n\t__azx_runtime_resume(chip);\n\n\t \n\tazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) & ~STATESTS_INT_MASK);\n\n\ttrace_azx_runtime_resume(chip);\n\treturn 0;\n}\n\nstatic int azx_runtime_idle(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip;\n\tstruct hda_intel *hda;\n\n\tif (!card)\n\t\treturn 0;\n\n\tchip = card->private_data;\n\thda = container_of(chip, struct hda_intel, chip);\n\tif (chip->disabled || hda->init_failed)\n\t\treturn 0;\n\n\tif (!power_save_controller || !azx_has_pm_runtime(chip) ||\n\t    azx_bus(chip)->codec_powered || !chip->running)\n\t\treturn -EBUSY;\n\n\t \n\tif (needs_eld_notify_link(chip))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops azx_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)\n#ifdef CONFIG_PM_SLEEP\n\t.prepare = azx_prepare,\n\t.complete = azx_complete,\n\t.freeze_noirq = azx_freeze_noirq,\n\t.thaw_noirq = azx_thaw_noirq,\n#endif\n\tSET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)\n};\n\n#define AZX_PM_OPS\t&azx_pm\n#else\n#define azx_add_card_list(chip)  \n#define azx_del_card_list(chip)  \n#define AZX_PM_OPS\tNULL\n#endif  \n\n\nstatic int azx_probe_continue(struct azx *chip);\n\n#ifdef SUPPORT_VGA_SWITCHEROO\nstatic struct pci_dev *get_bound_vga(struct pci_dev *pci);\n\nstatic void azx_vs_set_state(struct pci_dev *pci,\n\t\t\t     enum vga_switcheroo_state state)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct azx *chip = card->private_data;\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct hda_codec *codec;\n\tbool disabled;\n\n\twait_for_completion(&hda->probe_wait);\n\tif (hda->init_failed)\n\t\treturn;\n\n\tdisabled = (state == VGA_SWITCHEROO_OFF);\n\tif (chip->disabled == disabled)\n\t\treturn;\n\n\tif (!hda->probe_continued) {\n\t\tchip->disabled = disabled;\n\t\tif (!disabled) {\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"Start delayed initialization\\n\");\n\t\t\tif (azx_probe_continue(chip) < 0)\n\t\t\t\tdev_err(chip->card->dev, \"initialization error\\n\");\n\t\t}\n\t} else {\n\t\tdev_info(chip->card->dev, \"%s via vga_switcheroo\\n\",\n\t\t\t disabled ? \"Disabling\" : \"Enabling\");\n\t\tif (disabled) {\n\t\t\tlist_for_each_codec(codec, &chip->bus) {\n\t\t\t\tpm_runtime_suspend(hda_codec_dev(codec));\n\t\t\t\tpm_runtime_disable(hda_codec_dev(codec));\n\t\t\t}\n\t\t\tpm_runtime_suspend(card->dev);\n\t\t\tpm_runtime_disable(card->dev);\n\t\t\t \n\t\t\tpci->current_state = PCI_D3cold;\n\t\t\tchip->disabled = true;\n\t\t\tif (snd_hda_lock_devices(&chip->bus))\n\t\t\t\tdev_warn(chip->card->dev,\n\t\t\t\t\t \"Cannot lock devices!\\n\");\n\t\t} else {\n\t\t\tsnd_hda_unlock_devices(&chip->bus);\n\t\t\tchip->disabled = false;\n\t\t\tpm_runtime_enable(card->dev);\n\t\t\tlist_for_each_codec(codec, &chip->bus) {\n\t\t\t\tpm_runtime_enable(hda_codec_dev(codec));\n\t\t\t\tpm_runtime_resume(hda_codec_dev(codec));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool azx_vs_can_switch(struct pci_dev *pci)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct azx *chip = card->private_data;\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\n\twait_for_completion(&hda->probe_wait);\n\tif (hda->init_failed)\n\t\treturn false;\n\tif (chip->disabled || !hda->probe_continued)\n\t\treturn true;\n\tif (snd_hda_lock_devices(&chip->bus))\n\t\treturn false;\n\tsnd_hda_unlock_devices(&chip->bus);\n\treturn true;\n}\n\n \nstatic void setup_vga_switcheroo_runtime_pm(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct hda_codec *codec;\n\n\tif (hda->use_vga_switcheroo && !needs_eld_notify_link(chip)) {\n\t\tlist_for_each_codec(codec, &chip->bus)\n\t\t\tcodec->auto_runtime_pm = 1;\n\t\t \n\t\tif (chip->running)\n\t\t\tset_default_power_save(chip);\n\t}\n}\n\nstatic void azx_vs_gpu_bound(struct pci_dev *pci,\n\t\t\t     enum vga_switcheroo_client_id client_id)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct azx *chip = card->private_data;\n\n\tif (client_id == VGA_SWITCHEROO_DIS)\n\t\tchip->bus.keep_power = 0;\n\tsetup_vga_switcheroo_runtime_pm(chip);\n}\n\nstatic void init_vga_switcheroo(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct pci_dev *p = get_bound_vga(chip->pci);\n\tstruct pci_dev *parent;\n\tif (p) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"Handle vga_switcheroo audio client\\n\");\n\t\thda->use_vga_switcheroo = 1;\n\n\t\t \n\t\tparent = pci_upstream_bridge(p);\n\t\tchip->bus.keep_power = parent ? !pci_pr3_present(parent) : 1;\n\t\tchip->driver_caps |= AZX_DCAPS_PM_RUNTIME;\n\t\tpci_dev_put(p);\n\t}\n}\n\nstatic const struct vga_switcheroo_client_ops azx_vs_ops = {\n\t.set_gpu_state = azx_vs_set_state,\n\t.can_switch = azx_vs_can_switch,\n\t.gpu_bound = azx_vs_gpu_bound,\n};\n\nstatic int register_vga_switcheroo(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct pci_dev *p;\n\tint err;\n\n\tif (!hda->use_vga_switcheroo)\n\t\treturn 0;\n\n\tp = get_bound_vga(chip->pci);\n\terr = vga_switcheroo_register_audio_client(chip->pci, &azx_vs_ops, p);\n\tpci_dev_put(p);\n\n\tif (err < 0)\n\t\treturn err;\n\thda->vga_switcheroo_registered = 1;\n\n\treturn 0;\n}\n#else\n#define init_vga_switcheroo(chip)\t\t \n#define register_vga_switcheroo(chip)\t\t0\n#define check_hdmi_disabled(pci)\tfalse\n#define setup_vga_switcheroo_runtime_pm(chip)\t \n#endif  \n\n \nstatic void azx_free(struct azx *chip)\n{\n\tstruct pci_dev *pci = chip->pci;\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct hdac_bus *bus = azx_bus(chip);\n\n\tif (hda->freed)\n\t\treturn;\n\n\tif (azx_has_pm_runtime(chip) && chip->running) {\n\t\tpm_runtime_get_noresume(&pci->dev);\n\t\tpm_runtime_forbid(&pci->dev);\n\t\tpm_runtime_dont_use_autosuspend(&pci->dev);\n\t}\n\n\tchip->running = 0;\n\n\tazx_del_card_list(chip);\n\n\thda->init_failed = 1;  \n\tcomplete_all(&hda->probe_wait);\n\n\tif (use_vga_switcheroo(hda)) {\n\t\tif (chip->disabled && hda->probe_continued)\n\t\t\tsnd_hda_unlock_devices(&chip->bus);\n\t\tif (hda->vga_switcheroo_registered)\n\t\t\tvga_switcheroo_unregister_client(chip->pci);\n\t}\n\n\tif (bus->chip_init) {\n\t\tazx_clear_irq_pending(chip);\n\t\tazx_stop_all_streams(chip);\n\t\tazx_stop_chip(chip);\n\t}\n\n\tif (bus->irq >= 0)\n\t\tfree_irq(bus->irq, (void*)chip);\n\n\tazx_free_stream_pages(chip);\n\tazx_free_streams(chip);\n\tsnd_hdac_bus_exit(bus);\n\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\n\trelease_firmware(chip->fw);\n#endif\n\tdisplay_power(chip, false);\n\n\tif (chip->driver_caps & AZX_DCAPS_I915_COMPONENT)\n\t\tsnd_hdac_i915_exit(bus);\n\n\thda->freed = 1;\n}\n\nstatic int azx_dev_disconnect(struct snd_device *device)\n{\n\tstruct azx *chip = device->device_data;\n\tstruct hdac_bus *bus = azx_bus(chip);\n\n\tchip->bus.shutdown = 1;\n\tcancel_work_sync(&bus->unsol_work);\n\n\treturn 0;\n}\n\nstatic int azx_dev_free(struct snd_device *device)\n{\n\tazx_free(device->device_data);\n\treturn 0;\n}\n\n#ifdef SUPPORT_VGA_SWITCHEROO\n#ifdef CONFIG_ACPI\n \nstatic bool atpx_present(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tacpi_handle dhandle, atpx_handle;\n\tacpi_status status;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\tif (dhandle) {\n\t\t\tstatus = acpi_get_handle(dhandle, \"ATPX\", &atpx_handle);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tpci_dev_put(pdev);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\tif (dhandle) {\n\t\t\tstatus = acpi_get_handle(dhandle, \"ATPX\", &atpx_handle);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tpci_dev_put(pdev);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n#else\nstatic bool atpx_present(void)\n{\n\treturn false;\n}\n#endif\n\n \nstatic struct pci_dev *get_bound_vga(struct pci_dev *pci)\n{\n\tstruct pci_dev *p;\n\n\t \n\tswitch (pci->vendor) {\n\tcase PCI_VENDOR_ID_ATI:\n\tcase PCI_VENDOR_ID_AMD:\n\t\tif (pci->devfn == 1) {\n\t\t\tp = pci_get_domain_bus_and_slot(pci_domain_nr(pci->bus),\n\t\t\t\t\t\t\tpci->bus->number, 0);\n\t\t\tif (p) {\n\t\t\t\t \n\t\t\t\tif (((p->class >> 16) == PCI_BASE_CLASS_DISPLAY) &&\n\t\t\t\t    (atpx_present() || apple_gmux_detect(NULL, NULL)))\n\t\t\t\t\treturn p;\n\t\t\t\tpci_dev_put(p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_NVIDIA:\n\t\tif (pci->devfn == 1) {\n\t\t\tp = pci_get_domain_bus_and_slot(pci_domain_nr(pci->bus),\n\t\t\t\t\t\t\tpci->bus->number, 0);\n\t\t\tif (p) {\n\t\t\t\tif ((p->class >> 16) == PCI_BASE_CLASS_DISPLAY)\n\t\t\t\t\treturn p;\n\t\t\t\tpci_dev_put(p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic bool check_hdmi_disabled(struct pci_dev *pci)\n{\n\tbool vga_inactive = false;\n\tstruct pci_dev *p = get_bound_vga(pci);\n\n\tif (p) {\n\t\tif (vga_switcheroo_get_client_state(p) == VGA_SWITCHEROO_OFF)\n\t\t\tvga_inactive = true;\n\t\tpci_dev_put(p);\n\t}\n\treturn vga_inactive;\n}\n#endif  \n\n \nstatic const struct snd_pci_quirk position_fix_list[] = {\n\tSND_PCI_QUIRK(0x1028, 0x01cc, \"Dell D820\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1028, 0x01de, \"Dell Precision 390\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x103c, 0x306d, \"HP dv3\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1043, 0x813d, \"ASUS P5AD2\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1043, 0x81b3, \"ASUS\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1043, 0x81e7, \"ASUS M2V\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x104d, 0x9069, \"Sony VPCS11V9E\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x10de, 0xcb89, \"Macbook Pro 7,1\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1297, 0x3166, \"Shuttle\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1458, 0xa022, \"ga-ma770-ud3\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1462, 0x1002, \"MSI Wind U115\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1565, 0x8218, \"Biostar Microtech\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x1849, 0x0888, \"775Dual-VSTA\", POS_FIX_LPIB),\n\tSND_PCI_QUIRK(0x8086, 0x2503, \"DG965OT AAD63733-203\", POS_FIX_LPIB),\n\t{}\n};\n\nstatic int check_position_fix(struct azx *chip, int fix)\n{\n\tconst struct snd_pci_quirk *q;\n\n\tswitch (fix) {\n\tcase POS_FIX_AUTO:\n\tcase POS_FIX_LPIB:\n\tcase POS_FIX_POSBUF:\n\tcase POS_FIX_VIACOMBO:\n\tcase POS_FIX_COMBO:\n\tcase POS_FIX_SKL:\n\tcase POS_FIX_FIFO:\n\t\treturn fix;\n\t}\n\n\tq = snd_pci_quirk_lookup(chip->pci, position_fix_list);\n\tif (q) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"position_fix set to %d for device %04x:%04x\\n\",\n\t\t\t q->value, q->subvendor, q->subdevice);\n\t\treturn q->value;\n\t}\n\n\t \n\tif (chip->driver_type == AZX_DRIVER_VIA) {\n\t\tdev_dbg(chip->card->dev, \"Using VIACOMBO position fix\\n\");\n\t\treturn POS_FIX_VIACOMBO;\n\t}\n\tif (chip->driver_caps & AZX_DCAPS_AMD_WORKAROUND) {\n\t\tdev_dbg(chip->card->dev, \"Using FIFO position fix\\n\");\n\t\treturn POS_FIX_FIFO;\n\t}\n\tif (chip->driver_caps & AZX_DCAPS_POSFIX_LPIB) {\n\t\tdev_dbg(chip->card->dev, \"Using LPIB position fix\\n\");\n\t\treturn POS_FIX_LPIB;\n\t}\n\tif (chip->driver_type == AZX_DRIVER_SKL) {\n\t\tdev_dbg(chip->card->dev, \"Using SKL position fix\\n\");\n\t\treturn POS_FIX_SKL;\n\t}\n\treturn POS_FIX_AUTO;\n}\n\nstatic void assign_position_fix(struct azx *chip, int fix)\n{\n\tstatic const azx_get_pos_callback_t callbacks[] = {\n\t\t[POS_FIX_AUTO] = NULL,\n\t\t[POS_FIX_LPIB] = azx_get_pos_lpib,\n\t\t[POS_FIX_POSBUF] = azx_get_pos_posbuf,\n\t\t[POS_FIX_VIACOMBO] = azx_via_get_position,\n\t\t[POS_FIX_COMBO] = azx_get_pos_lpib,\n\t\t[POS_FIX_SKL] = azx_get_pos_posbuf,\n\t\t[POS_FIX_FIFO] = azx_get_pos_fifo,\n\t};\n\n\tchip->get_position[0] = chip->get_position[1] = callbacks[fix];\n\n\t \n\tif (fix == POS_FIX_COMBO)\n\t\tchip->get_position[1] = NULL;\n\n\tif ((fix == POS_FIX_POSBUF || fix == POS_FIX_SKL) &&\n\t    (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)) {\n\t\tchip->get_delay[0] = chip->get_delay[1] =\n\t\t\tazx_get_delay_from_lpib;\n\t}\n\n\tif (fix == POS_FIX_FIFO)\n\t\tchip->get_delay[0] = chip->get_delay[1] =\n\t\t\tazx_get_delay_from_fifo;\n}\n\n \nstatic const struct snd_pci_quirk probe_mask_list[] = {\n\t \n\tSND_PCI_QUIRK(0x1014, 0x05b7, \"Thinkpad Z60\", 0x01),\n\tSND_PCI_QUIRK(0x17aa, 0x2010, \"Thinkpad X/T/R60\", 0x01),\n\tSND_PCI_QUIRK(0x17aa, 0x20ac, \"Thinkpad X/T/R61\", 0x01),\n\t \n\tSND_PCI_QUIRK(0x1028, 0x20ac, \"Dell Studio Desktop\", 0x01),\n\t \n\tSND_PCI_QUIRK(0x17c0, 0x4085, \"Medion MD96630\", 0x01),\n\t \n\tSND_PCI_QUIRK(0x1043, 0x1262, \"ASUS W5Fm\", 0x103),\n\tSND_PCI_QUIRK(0x1046, 0x1262, \"ASUS W5F\", 0x103),\n\tSND_PCI_QUIRK(0x1558, 0x0351, \"Schenker Dock 15\", 0x105),\n\t \n\tSND_PCI_QUIRK(0x3a21, 0x040d, \"WinFast VP200 H\", 0x101),\n\t{}\n};\n\n#define AZX_FORCE_CODEC_MASK\t0x100\n\nstatic void check_probe_mask(struct azx *chip, int dev)\n{\n\tconst struct snd_pci_quirk *q;\n\n\tchip->codec_probe_mask = probe_mask[dev];\n\tif (chip->codec_probe_mask == -1) {\n\t\tq = snd_pci_quirk_lookup(chip->pci, probe_mask_list);\n\t\tif (q) {\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"probe_mask set to 0x%x for device %04x:%04x\\n\",\n\t\t\t\t q->value, q->subvendor, q->subdevice);\n\t\t\tchip->codec_probe_mask = q->value;\n\t\t}\n\t}\n\n\t \n\tif (chip->codec_probe_mask != -1 &&\n\t    (chip->codec_probe_mask & AZX_FORCE_CODEC_MASK)) {\n\t\tazx_bus(chip)->codec_mask = chip->codec_probe_mask & 0xff;\n\t\tdev_info(chip->card->dev, \"codec_mask forced to 0x%x\\n\",\n\t\t\t (int)azx_bus(chip)->codec_mask);\n\t}\n}\n\n \nstatic const struct snd_pci_quirk msi_deny_list[] = {\n\tSND_PCI_QUIRK(0x103c, 0x2191, \"HP\", 0),  \n\tSND_PCI_QUIRK(0x103c, 0x2192, \"HP\", 0),  \n\tSND_PCI_QUIRK(0x103c, 0x21f7, \"HP\", 0),  \n\tSND_PCI_QUIRK(0x103c, 0x21fa, \"HP\", 0),  \n\tSND_PCI_QUIRK(0x1043, 0x81f2, \"ASUS\", 0),  \n\tSND_PCI_QUIRK(0x1043, 0x81f6, \"ASUS\", 0),  \n\tSND_PCI_QUIRK(0x1043, 0x822d, \"ASUS\", 0),  \n\tSND_PCI_QUIRK(0x1179, 0xfb44, \"Toshiba Satellite C870\", 0),  \n\tSND_PCI_QUIRK(0x1849, 0x0888, \"ASRock\", 0),  \n\tSND_PCI_QUIRK(0xa0a0, 0x0575, \"Aopen MZ915-M\", 0),  \n\t{}\n};\n\nstatic void check_msi(struct azx *chip)\n{\n\tconst struct snd_pci_quirk *q;\n\n\tif (enable_msi >= 0) {\n\t\tchip->msi = !!enable_msi;\n\t\treturn;\n\t}\n\tchip->msi = 1;\t \n\tq = snd_pci_quirk_lookup(chip->pci, msi_deny_list);\n\tif (q) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"msi for device %04x:%04x set to %d\\n\",\n\t\t\t q->subvendor, q->subdevice, q->value);\n\t\tchip->msi = q->value;\n\t\treturn;\n\t}\n\n\t \n\tif (chip->driver_caps & AZX_DCAPS_NO_MSI) {\n\t\tdev_info(chip->card->dev, \"Disabling MSI\\n\");\n\t\tchip->msi = 0;\n\t}\n}\n\n \nstatic void azx_check_snoop_available(struct azx *chip)\n{\n\tint snoop = hda_snoop;\n\n\tif (snoop >= 0) {\n\t\tdev_info(chip->card->dev, \"Force to %s mode by module option\\n\",\n\t\t\t snoop ? \"snoop\" : \"non-snoop\");\n\t\tchip->snoop = snoop;\n\t\tchip->uc_buffer = !snoop;\n\t\treturn;\n\t}\n\n\tsnoop = true;\n\tif (azx_get_snoop_type(chip) == AZX_SNOOP_TYPE_NONE &&\n\t    chip->driver_type == AZX_DRIVER_VIA) {\n\t\t \n\t\tu8 val;\n\t\tpci_read_config_byte(chip->pci, 0x42, &val);\n\t\tif (!(val & 0x80) && (chip->pci->revision == 0x30 ||\n\t\t\t\t      chip->pci->revision == 0x20))\n\t\t\tsnoop = false;\n\t}\n\n\tif (chip->driver_caps & AZX_DCAPS_SNOOP_OFF)\n\t\tsnoop = false;\n\n\tchip->snoop = snoop;\n\tif (!snoop) {\n\t\tdev_info(chip->card->dev, \"Force to non-snoop mode\\n\");\n\t\t \n\t\tif (chip->driver_type != AZX_DRIVER_CMEDIA)\n\t\t\tchip->uc_buffer = true;\n\t}\n}\n\nstatic void azx_probe_work(struct work_struct *work)\n{\n\tstruct hda_intel *hda = container_of(work, struct hda_intel, probe_work.work);\n\tazx_probe_continue(&hda->chip);\n}\n\nstatic int default_bdl_pos_adj(struct azx *chip)\n{\n\t \n\tif (chip->pci->vendor == PCI_VENDOR_ID_INTEL) {\n\t\tswitch (chip->pci->device) {\n\t\tcase 0x0f04:  \n\t\tcase 0x2284:  \n\t\t\treturn 32;\n\t\t}\n\t}\n\n\tswitch (chip->driver_type) {\n\t \n\tcase AZX_DRIVER_GFHDMI:\n\t\treturn 128;\n\tcase AZX_DRIVER_ICH:\n\tcase AZX_DRIVER_PCH:\n\t\treturn 1;\n\tdefault:\n\t\treturn 32;\n\t}\n}\n\n \nstatic const struct hda_controller_ops pci_hda_ops;\n\nstatic int azx_create(struct snd_card *card, struct pci_dev *pci,\n\t\t      int dev, unsigned int driver_caps,\n\t\t      struct azx **rchip)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_disconnect = azx_dev_disconnect,\n\t\t.dev_free = azx_dev_free,\n\t};\n\tstruct hda_intel *hda;\n\tstruct azx *chip;\n\tint err;\n\n\t*rchip = NULL;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\thda = devm_kzalloc(&pci->dev, sizeof(*hda), GFP_KERNEL);\n\tif (!hda)\n\t\treturn -ENOMEM;\n\n\tchip = &hda->chip;\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->ops = &pci_hda_ops;\n\tchip->driver_caps = driver_caps;\n\tchip->driver_type = driver_caps & 0xff;\n\tcheck_msi(chip);\n\tchip->dev_index = dev;\n\tif (jackpoll_ms[dev] >= 50 && jackpoll_ms[dev] <= 60000)\n\t\tchip->jackpoll_interval = msecs_to_jiffies(jackpoll_ms[dev]);\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);\n\tINIT_LIST_HEAD(&hda->list);\n\tinit_vga_switcheroo(chip);\n\tinit_completion(&hda->probe_wait);\n\n\tassign_position_fix(chip, check_position_fix(chip, position_fix[dev]));\n\n\tif (single_cmd < 0)  \n\t\tchip->fallback_to_single_cmd = 1;\n\telse  \n\t\tchip->single_cmd = single_cmd;\n\n\tazx_check_snoop_available(chip);\n\n\tif (bdl_pos_adj[dev] < 0)\n\t\tchip->bdl_pos_adj = default_bdl_pos_adj(chip);\n\telse\n\t\tchip->bdl_pos_adj = bdl_pos_adj[dev];\n\n\terr = azx_bus_init(chip, model[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!azx_snoop(chip))\n\t\tazx_bus(chip)->dma_type = SNDRV_DMA_TYPE_DEV_WC_SG;\n\n\tif (chip->driver_type == AZX_DRIVER_NVIDIA) {\n\t\tdev_dbg(chip->card->dev, \"Enable delay in RIRB handling\\n\");\n\t\tchip->bus.core.needs_damn_long_delay = 1;\n\t}\n\n\tcheck_probe_mask(chip, dev);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Error creating device [card]!\\n\");\n\t\tazx_free(chip);\n\t\treturn err;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&hda->probe_work, azx_probe_work);\n\n\t*rchip = chip;\n\n\treturn 0;\n}\n\nstatic int azx_first_init(struct azx *chip)\n{\n\tint dev = chip->dev_index;\n\tstruct pci_dev *pci = chip->pci;\n\tstruct snd_card *card = chip->card;\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tint err;\n\tunsigned short gcap;\n\tunsigned int dma_bits = 64;\n\n#if BITS_PER_LONG != 64\n\t \n\tif (chip->driver_type == AZX_DRIVER_ULI) {\n\t\tu16 tmp3;\n\t\tpci_read_config_word(pci, 0x40, &tmp3);\n\t\tpci_write_config_word(pci, 0x40, tmp3 | 0x10);\n\t\tpci_write_config_dword(pci, PCI_BASE_ADDRESS_1, 0);\n\t}\n#endif\n\t \n\tif (chip->driver_type == AZX_DRIVER_GFHDMI)\n\t\tbus->polling_mode = 1;\n\n\tif (chip->driver_type == AZX_DRIVER_LOONGSON) {\n\t\tbus->polling_mode = 1;\n\t\tbus->not_use_interrupts = 1;\n\t\tbus->access_sdnctl_in_dword = 1;\n\t}\n\n\terr = pcim_iomap_regions(pci, 1 << 0, \"ICH HD audio\");\n\tif (err < 0)\n\t\treturn err;\n\n\tbus->addr = pci_resource_start(pci, 0);\n\tbus->remap_addr = pcim_iomap_table(pci)[0];\n\n\tif (chip->driver_type == AZX_DRIVER_SKL)\n\t\tsnd_hdac_bus_parse_capabilities(bus);\n\n\t \n\tchip->gts_present = false;\n\n#ifdef CONFIG_X86\n\tif (bus->ppcap && boot_cpu_has(X86_FEATURE_ART))\n\t\tchip->gts_present = true;\n#endif\n\n\tif (chip->msi) {\n\t\tif (chip->driver_caps & AZX_DCAPS_NO_MSI64) {\n\t\t\tdev_dbg(card->dev, \"Disabling 64bit MSI\\n\");\n\t\t\tpci->no_64bit_msi = true;\n\t\t}\n\t\tif (pci_enable_msi(pci) < 0)\n\t\t\tchip->msi = 0;\n\t}\n\n\tpci_set_master(pci);\n\n\tgcap = azx_readw(chip, GCAP);\n\tdev_dbg(card->dev, \"chipset global capabilities = 0x%x\\n\", gcap);\n\n\t \n\tif (chip->pci->vendor == PCI_VENDOR_ID_AMD)\n\t\tdma_bits = 40;\n\n\t \n\tif (chip->pci->vendor == PCI_VENDOR_ID_ATI) {\n\t\tstruct pci_dev *p_smbus;\n\t\tdma_bits = 40;\n\t\tp_smbus = pci_get_device(PCI_VENDOR_ID_ATI,\n\t\t\t\t\t PCI_DEVICE_ID_ATI_SBX00_SMBUS,\n\t\t\t\t\t NULL);\n\t\tif (p_smbus) {\n\t\t\tif (p_smbus->revision < 0x30)\n\t\t\t\tgcap &= ~AZX_GCAP_64OK;\n\t\t\tpci_dev_put(p_smbus);\n\t\t}\n\t}\n\n\t \n\tif (chip->pci->vendor == PCI_VENDOR_ID_NVIDIA)\n\t\tdma_bits = 40;\n\n\t \n\tif (chip->driver_caps & AZX_DCAPS_NO_64BIT) {\n\t\tdev_dbg(card->dev, \"Disabling 64bit DMA\\n\");\n\t\tgcap &= ~AZX_GCAP_64OK;\n\t}\n\n\t \n\tif (align_buffer_size >= 0)\n\t\tchip->align_buffer_size = !!align_buffer_size;\n\telse {\n\t\tif (chip->driver_caps & AZX_DCAPS_NO_ALIGN_BUFSIZE)\n\t\t\tchip->align_buffer_size = 0;\n\t\telse\n\t\t\tchip->align_buffer_size = 1;\n\t}\n\n\t \n\tif (!(gcap & AZX_GCAP_64OK))\n\t\tdma_bits = 32;\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(dma_bits)))\n\t\tdma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32));\n\tdma_set_max_seg_size(&pci->dev, UINT_MAX);\n\n\t \n\tchip->capture_streams = (gcap >> 8) & 0x0f;\n\tchip->playback_streams = (gcap >> 12) & 0x0f;\n\tif (!chip->playback_streams && !chip->capture_streams) {\n\t\t \n\n\t\tswitch (chip->driver_type) {\n\t\tcase AZX_DRIVER_ULI:\n\t\t\tchip->playback_streams = ULI_NUM_PLAYBACK;\n\t\t\tchip->capture_streams = ULI_NUM_CAPTURE;\n\t\t\tbreak;\n\t\tcase AZX_DRIVER_ATIHDMI:\n\t\tcase AZX_DRIVER_ATIHDMI_NS:\n\t\t\tchip->playback_streams = ATIHDMI_NUM_PLAYBACK;\n\t\t\tchip->capture_streams = ATIHDMI_NUM_CAPTURE;\n\t\t\tbreak;\n\t\tcase AZX_DRIVER_GFHDMI:\n\t\tcase AZX_DRIVER_GENERIC:\n\t\tdefault:\n\t\t\tchip->playback_streams = ICH6_NUM_PLAYBACK;\n\t\t\tchip->capture_streams = ICH6_NUM_CAPTURE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tchip->capture_index_offset = 0;\n\tchip->playback_index_offset = chip->capture_streams;\n\tchip->num_streams = chip->playback_streams + chip->capture_streams;\n\n\t \n\tif (chip->num_streams > 15 &&\n\t    (chip->driver_caps & AZX_DCAPS_SEPARATE_STREAM_TAG) == 0) {\n\t\tdev_warn(chip->card->dev, \"number of I/O streams is %d, \"\n\t\t\t \"forcing separate stream tags\", chip->num_streams);\n\t\tchip->driver_caps |= AZX_DCAPS_SEPARATE_STREAM_TAG;\n\t}\n\n\t \n\terr = azx_init_streams(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = azx_alloc_stream_pages(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tazx_init_pci(chip);\n\n\tsnd_hdac_i915_set_bclk(bus);\n\n\thda_intel_init_chip(chip, (probe_only[dev] & 2) == 0);\n\n\t \n\tif (!azx_bus(chip)->codec_mask) {\n\t\tdev_err(card->dev, \"no codecs found!\\n\");\n\t\t \n\t}\n\n\tif (azx_acquire_irq(chip, 0) < 0)\n\t\treturn -EBUSY;\n\n\tstrcpy(card->driver, \"HDA-Intel\");\n\tstrscpy(card->shortname, driver_short_names[chip->driver_type],\n\t\tsizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at 0x%lx irq %i\",\n\t\t card->shortname, bus->addr, bus->irq);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\n \nstatic void azx_firmware_cb(const struct firmware *fw, void *context)\n{\n\tstruct snd_card *card = context;\n\tstruct azx *chip = card->private_data;\n\n\tif (fw)\n\t\tchip->fw = fw;\n\telse\n\t\tdev_err(card->dev, \"Cannot load firmware, continue without patching\\n\");\n\tif (!chip->disabled) {\n\t\t \n\t\tazx_probe_continue(chip);\n\t}\n}\n#endif\n\nstatic int disable_msi_reset_irq(struct azx *chip)\n{\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tint err;\n\n\tfree_irq(bus->irq, chip);\n\tbus->irq = -1;\n\tchip->card->sync_irq = -1;\n\tpci_disable_msi(chip->pci);\n\tchip->msi = 0;\n\terr = azx_acquire_irq(chip, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic const struct pci_device_id driver_denylist[] = {\n\t{ PCI_DEVICE_SUB(0x1022, 0x1487, 0x1043, 0x874f) },  \n\t{ PCI_DEVICE_SUB(0x1022, 0x1487, 0x1462, 0xcb59) },  \n\t{ PCI_DEVICE_SUB(0x1022, 0x1487, 0x1462, 0xcb60) },  \n\t{}\n};\n\nstatic const struct hda_controller_ops pci_hda_ops = {\n\t.disable_msi_reset_irq = disable_msi_reset_irq,\n\t.position_check = azx_position_check,\n};\n\nstatic DECLARE_BITMAP(probed_devs, SNDRV_CARDS);\n\nstatic int azx_probe(struct pci_dev *pci,\n\t\t     const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct hda_intel *hda;\n\tstruct azx *chip;\n\tbool schedule_probe;\n\tint dev;\n\tint err;\n\n\tif (pci_match_id(driver_denylist, pci)) {\n\t\tdev_info(&pci->dev, \"Skipping the device on the denylist\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = find_first_zero_bit(probed_devs, SNDRV_CARDS);\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tset_bit(dev, probed_devs);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (dmic_detect) {\n\t\terr = snd_intel_dsp_driver_probe(pci);\n\t\tif (err != SND_INTEL_DSP_DRIVER_ANY && err != SND_INTEL_DSP_DRIVER_LEGACY) {\n\t\t\tdev_dbg(&pci->dev, \"HDAudio driver not selected, aborting probe\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdev_warn(&pci->dev, \"dmic_detect option is deprecated, pass snd-intel-dspcfg.dsp_driver=1 option instead\\n\");\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, \"Error creating card!\\n\");\n\t\treturn err;\n\t}\n\n\terr = azx_create(card, pci, dev, pci_id->driver_data, &chip);\n\tif (err < 0)\n\t\tgoto out_free;\n\tcard->private_data = chip;\n\thda = container_of(chip, struct hda_intel, chip);\n\n\tpci_set_drvdata(pci, card);\n\n\terr = register_vga_switcheroo(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Error registering vga_switcheroo client\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_hdmi_disabled(pci)) {\n\t\tdev_info(card->dev, \"VGA controller is disabled\\n\");\n\t\tdev_info(card->dev, \"Delaying initialization\\n\");\n\t\tchip->disabled = true;\n\t}\n\n\tschedule_probe = !chip->disabled;\n\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\n\tif (patch[dev] && *patch[dev]) {\n\t\tdev_info(card->dev, \"Applying patch firmware '%s'\\n\",\n\t\t\t patch[dev]);\n\t\terr = request_firmware_nowait(THIS_MODULE, true, patch[dev],\n\t\t\t\t\t      &pci->dev, GFP_KERNEL, card,\n\t\t\t\t\t      azx_firmware_cb);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tschedule_probe = false;  \n\t}\n#endif  \n\n#ifndef CONFIG_SND_HDA_I915\n\tif (HDA_CONTROLLER_IN_GPU(pci))\n\t\tdev_err(card->dev, \"Haswell/Broadwell HDMI/DP must build in CONFIG_SND_HDA_I915\\n\");\n#endif\n\n\tif (schedule_probe)\n\t\tschedule_delayed_work(&hda->probe_work, 0);\n\n\tset_bit(dev, probed_devs);\n\tif (chip->disabled)\n\t\tcomplete_all(&hda->probe_wait);\n\treturn 0;\n\nout_free:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n#ifdef CONFIG_PM\n \nstatic const struct snd_pci_quirk power_save_denylist[] = {\n\t \n\tSND_PCI_QUIRK(0x1849, 0xc892, \"Asrock B85M-ITX\", 0),\n\t \n\tSND_PCI_QUIRK(0x1849, 0x0397, \"Asrock N68C-S UCC\", 0),\n\t \n\tSND_PCI_QUIRK(0x1849, 0x7662, \"Asrock H81M-HDS\", 0),\n\t \n\tSND_PCI_QUIRK(0x1043, 0x8733, \"Asus Prime X370-Pro\", 0),\n\t \n\tSND_PCI_QUIRK(0x1028, 0x0497, \"Dell Precision T3600\", 0),\n\t \n\t \n\tSND_PCI_QUIRK(0x1458, 0xa002, \"Gigabyte P55A-UD3 / Z87-D3HP\", 0),\n\t \n\tSND_PCI_QUIRK(0x8086, 0x2040, \"Intel DZ77BH-55K\", 0),\n\t \n\tSND_PCI_QUIRK(0x8086, 0x2057, \"Intel NUC5i7RYB\", 0),\n\t \n\tSND_PCI_QUIRK(0x8086, 0x2064, \"Intel SDP 8086:2064\", 0),\n\t \n\tSND_PCI_QUIRK(0x8086, 0x2068, \"Intel NUC7i3BNB\", 0),\n\t \n\tSND_PCI_QUIRK(0x17aa, 0x2227, \"Lenovo X1 Carbon 3rd Gen\", 0),\n\tSND_PCI_QUIRK(0x17aa, 0x316e, \"Lenovo ThinkCentre M70q\", 0),\n\t \n\tSND_PCI_QUIRK(0x17aa, 0x367b, \"Lenovo IdeaCentre B550\", 0),\n\t \n\tSND_PCI_QUIRK(0x17aa, 0x36a7, \"Lenovo C50 All in one\", 0),\n\t \n\tSND_PCI_QUIRK(0x1631, 0xe017, \"Packard Bell NEC IMEDIA 5204\", 0),\n\t \n\tSND_PCI_QUIRK(0x1734, 0x1232, \"KONTRON SinglePC\", 0),\n\t{}\n};\n#endif  \n\nstatic void set_default_power_save(struct azx *chip)\n{\n\tint val = power_save;\n\n#ifdef CONFIG_PM\n\tif (pm_blacklist) {\n\t\tconst struct snd_pci_quirk *q;\n\n\t\tq = snd_pci_quirk_lookup(chip->pci, power_save_denylist);\n\t\tif (q && val) {\n\t\t\tdev_info(chip->card->dev, \"device %04x:%04x is on the power_save denylist, forcing power_save to 0\\n\",\n\t\t\t\t q->subvendor, q->subdevice);\n\t\t\tval = 0;\n\t\t}\n\t}\n#endif  \n\tsnd_hda_set_power_save(&chip->bus, val * 1000);\n}\n\n \nstatic const unsigned int azx_max_codecs[AZX_NUM_DRIVERS] = {\n\t[AZX_DRIVER_NVIDIA] = 8,\n\t[AZX_DRIVER_TERA] = 1,\n};\n\nstatic int azx_probe_continue(struct azx *chip)\n{\n\tstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct pci_dev *pci = chip->pci;\n\tint dev = chip->dev_index;\n\tint err;\n\n\tif (chip->disabled || hda->init_failed)\n\t\treturn -EIO;\n\tif (hda->probe_retry)\n\t\tgoto probe_retry;\n\n\tto_hda_bus(bus)->bus_probing = 1;\n\thda->probe_continued = 1;\n\n\t \n\tif (chip->driver_caps & AZX_DCAPS_I915_COMPONENT) {\n\t\terr = snd_hdac_i915_init(bus);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tif (HDA_CONTROLLER_IN_GPU(pci)) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"HSW/BDW HD-audio HDMI/DP requires binding with gfx driver\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tchip->driver_caps &= ~AZX_DCAPS_I915_COMPONENT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (HDA_CONTROLLER_IN_GPU(pci))\n\t\t\thda->need_i915_power = true;\n\t}\n\n\t \n\tdisplay_power(chip, true);\n\n\terr = azx_first_init(chip);\n\tif (err < 0)\n\t\tgoto out_free;\n\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\n\tchip->beep_mode = beep_mode[dev];\n#endif\n\n\tchip->ctl_dev_id = ctl_dev_id;\n\n\t \n\tif (bus->codec_mask) {\n\t\terr = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\n\tif (chip->fw) {\n\t\terr = snd_hda_load_patch(&chip->bus, chip->fw->size,\n\t\t\t\t\t chip->fw->data);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n#ifndef CONFIG_PM\n\t\trelease_firmware(chip->fw);  \n\t\tchip->fw = NULL;\n#endif\n\t}\n#endif\n\n probe_retry:\n\tif (bus->codec_mask && !(probe_only[dev] & 1)) {\n\t\terr = azx_codec_configure(chip);\n\t\tif (err) {\n\t\t\tif ((chip->driver_caps & AZX_DCAPS_RETRY_PROBE) &&\n\t\t\t    ++hda->probe_retry < 60) {\n\t\t\t\tschedule_delayed_work(&hda->probe_work,\n\t\t\t\t\t\t      msecs_to_jiffies(1000));\n\t\t\t\treturn 0;  \n\t\t\t}\n\t\t\tdev_err(chip->card->dev, \"Cannot probe codecs, giving up\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\tsetup_vga_switcheroo_runtime_pm(chip);\n\n\tchip->running = 1;\n\tazx_add_card_list(chip);\n\n\tset_default_power_save(chip);\n\n\tif (azx_has_pm_runtime(chip)) {\n\t\tpm_runtime_use_autosuspend(&pci->dev);\n\t\tpm_runtime_allow(&pci->dev);\n\t\tpm_runtime_put_autosuspend(&pci->dev);\n\t}\n\nout_free:\n\tif (err < 0) {\n\t\tpci_set_drvdata(pci, NULL);\n\t\tsnd_card_free(chip->card);\n\t\treturn err;\n\t}\n\n\tif (!hda->need_i915_power)\n\t\tdisplay_power(chip, false);\n\tcomplete_all(&hda->probe_wait);\n\tto_hda_bus(bus)->bus_probing = 0;\n\thda->probe_retry = 0;\n\treturn 0;\n}\n\nstatic void azx_remove(struct pci_dev *pci)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct azx *chip;\n\tstruct hda_intel *hda;\n\n\tif (card) {\n\t\t \n\t\tchip = card->private_data;\n\t\thda = container_of(chip, struct hda_intel, chip);\n\t\t \n\t\tdevice_unlock(&pci->dev);\n\t\tcancel_delayed_work_sync(&hda->probe_work);\n\t\tdevice_lock(&pci->dev);\n\n\t\tclear_bit(chip->dev_index, probed_devs);\n\t\tpci_set_drvdata(pci, NULL);\n\t\tsnd_card_free(card);\n\t}\n}\n\nstatic void azx_shutdown(struct pci_dev *pci)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct azx *chip;\n\n\tif (!card)\n\t\treturn;\n\tchip = card->private_data;\n\tif (chip && chip->running)\n\t\t__azx_shutdown_chip(chip, true);\n}\n\n \nstatic const struct pci_device_id azx_ids[] = {\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CPT, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH_NOPM) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_PBG, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH_NOPM) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_PPT, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH_NOPM) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_LPT, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_9_SERIES, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_WBG_0, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_WBG_1, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_LBG_0, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_LBG_1, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_LPT_LP_0, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_LPT_LP_1, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_WPT_LP, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_SKL, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_SKL_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_KBL_H, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CNL_H, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CNL_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_H, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_RKL_S, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_S, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_CML_R, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICL_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICL_H, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICL_N, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_JSL_N, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_TGL_LP, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_TGL_H, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_DG1, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_DG2_0, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_DG2_1, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_DG2_2, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_S, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_P, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_PS, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_PX, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_M, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ADL_N, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_EHL_0, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_EHL_3, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_RPL_S, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_RPL_P_0, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_RPL_P_1, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_RPL_M, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_RPL_PX, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_MTL, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_LNL_P, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ARL_S, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_SKYLAKE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_APL, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_BROXTON) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_GML, AZX_DRIVER_SKL | AZX_DCAPS_INTEL_BROXTON) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_HSW_0, AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_HASWELL) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_HSW_2, AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_HASWELL) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_HSW_3, AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_HASWELL) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_BDW, AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_BROADWELL) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_5_3400_SERIES_0, AZX_DRIVER_SCH | AZX_DCAPS_INTEL_PCH_NOPM) },\n\t{ PCI_DEVICE_DATA(INTEL, HDA_5_3400_SERIES_1, AZX_DRIVER_SCH | AZX_DCAPS_INTEL_PCH_NOPM) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_POULSBO, AZX_DRIVER_SCH | AZX_DCAPS_INTEL_PCH_BASE |\n\t  AZX_DCAPS_POSFIX_LPIB) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_OAKTRAIL, AZX_DRIVER_SCH | AZX_DCAPS_INTEL_PCH_BASE) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_BYT, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BAYTRAIL) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_BSW, AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BRASWELL) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH6, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH7, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ESB2, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH8, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH9_0, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH9_1, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH10_0, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE_DATA(INTEL, HDA_ICH10_1, AZX_DRIVER_ICH | AZX_DCAPS_INTEL_ICH) },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_ICH | AZX_DCAPS_NO_ALIGN_BUFSIZE },\n\t \n\t{ PCI_VDEVICE(ATI, 0x437b),\n\t  .driver_data = AZX_DRIVER_ATI | AZX_DCAPS_PRESET_ATI_SB },\n\t{ PCI_VDEVICE(ATI, 0x4383),\n\t  .driver_data = AZX_DRIVER_ATI | AZX_DCAPS_PRESET_ATI_SB },\n\t \n\t{ PCI_VDEVICE(AMD, 0x780d),\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },\n\t \n\t{ PCI_VDEVICE(AMD, 0x1457),\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_AMD_SB },\n\t \n\t{ PCI_VDEVICE(AMD, 0x1487),\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_AMD_SB },\n\t \n\t{ PCI_VDEVICE(AMD, 0x157a),\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB |\n\t\t\t AZX_DCAPS_PM_RUNTIME },\n\t \n\t{ PCI_VDEVICE(AMD, 0x15e3),\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_AMD_SB },\n\t \n\t{ PCI_VDEVICE(ATI, 0x0002),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0x1308),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0x157a),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0x15b3),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0x793b),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0x7919),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0x960f),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0x970f),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0x9840),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0xaa00),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa08),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa10),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa18),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa20),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa28),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa30),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa38),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa40),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa48),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa50),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa58),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa60),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa68),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa80),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa88),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa90),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0xaa98),\n\t  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_VDEVICE(ATI, 0x9902),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0xaaa0),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0xaaa8),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0xaab0),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },\n\t{ PCI_VDEVICE(ATI, 0xaac0),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaac8),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaad8),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaae0),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaae8),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaaf0),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xaaf8),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab00),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab08),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab10),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab18),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab20),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab28),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab30),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t{ PCI_VDEVICE(ATI, 0xab38),\n\t  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS |\n\t  AZX_DCAPS_PM_RUNTIME },\n\t \n\t{ PCI_DEVICE(0x6766, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_GFHDMI | AZX_DCAPS_POSFIX_LPIB |\n\t  AZX_DCAPS_NO_MSI | AZX_DCAPS_NO_64BIT },\n\t \n\t{ PCI_VDEVICE(VIA, 0x3288), .driver_data = AZX_DRIVER_VIA },\n\t \n\t{ PCI_VDEVICE(VIA, 0x9170), .driver_data = AZX_DRIVER_GENERIC },\n\t \n\t{ PCI_VDEVICE(VIA, 0x9140), .driver_data = AZX_DRIVER_GENERIC },\n\t \n\t{ PCI_VDEVICE(SI, 0x7502), .driver_data = AZX_DRIVER_SIS },\n\t \n\t{ PCI_VDEVICE(AL, 0x5461), .driver_data = AZX_DRIVER_ULI },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_NVIDIA | AZX_DCAPS_PRESET_NVIDIA },\n\t \n\t{ PCI_DEVICE(0x6549, 0x1200),\n\t  .driver_data = AZX_DRIVER_TERA | AZX_DCAPS_NO_64BIT },\n\t{ PCI_DEVICE(0x6549, 0x2200),\n\t  .driver_data = AZX_DRIVER_TERA | AZX_DCAPS_NO_64BIT },\n\t \n\t \n\t{ PCI_VDEVICE(CREATIVE, 0x0010),\n\t  .driver_data = AZX_DRIVER_CTHDA | AZX_DCAPS_PRESET_CTHDA },\n\t{ PCI_VDEVICE(CREATIVE, 0x0012),\n\t  .driver_data = AZX_DRIVER_CTHDA | AZX_DCAPS_PRESET_CTHDA },\n#if !IS_ENABLED(CONFIG_SND_CTXFI)\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_CREATIVE, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_CTX | AZX_DCAPS_CTX_WORKAROUND |\n\t  AZX_DCAPS_NO_64BIT | AZX_DCAPS_POSFIX_LPIB },\n#else\n\t \n\t{ PCI_VDEVICE(CREATIVE, 0x0009),\n\t  .driver_data = AZX_DRIVER_CTX | AZX_DCAPS_CTX_WORKAROUND |\n\t  AZX_DCAPS_NO_64BIT | AZX_DCAPS_POSFIX_LPIB },\n#endif\n\t \n\t{ PCI_VDEVICE(CMEDIA, 0x5011),\n\t  .driver_data = AZX_DRIVER_CMEDIA |\n\t  AZX_DCAPS_NO_MSI | AZX_DCAPS_POSFIX_LPIB | AZX_DCAPS_SNOOP_OFF },\n\t \n\t{ PCI_VDEVICE(RDC, 0x3010), .driver_data = AZX_DRIVER_GENERIC },\n\t \n\t{ PCI_VDEVICE(VMWARE, 0x1977), .driver_data = AZX_DRIVER_GENERIC },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_HDMI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_ANY_ID),\n\t  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO << 8,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_HDMI },\n\t \n\t{ PCI_VDEVICE(ZHAOXIN, 0x3288), .driver_data = AZX_DRIVER_ZHAOXIN },\n\t \n\t{ PCI_VDEVICE(LOONGSON, PCI_DEVICE_ID_LOONGSON_HDA),\n\t  .driver_data = AZX_DRIVER_LOONGSON },\n\t{ PCI_VDEVICE(LOONGSON, PCI_DEVICE_ID_LOONGSON_HDMI),\n\t  .driver_data = AZX_DRIVER_LOONGSON },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, azx_ids);\n\n \nstatic struct pci_driver azx_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = azx_ids,\n\t.probe = azx_probe,\n\t.remove = azx_remove,\n\t.shutdown = azx_shutdown,\n\t.driver = {\n\t\t.pm = AZX_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(azx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}