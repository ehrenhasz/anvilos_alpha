{
  "module_name": "hda_beep.c",
  "hash_id": "1a078c6b0702552dea4e6732158c590da068ddc08917cdaed67da61e7ad215a8",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_beep.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include \"hda_beep.h\"\n#include \"hda_local.h\"\n\nenum {\n\tDIGBEEP_HZ_STEP = 46875,\t \n\tDIGBEEP_HZ_MIN = 93750,\t\t \n\tDIGBEEP_HZ_MAX = 12000000,\t \n};\n\n \nstatic void generate_tone(struct hda_beep *beep, int tone)\n{\n\tstruct hda_codec *codec = beep->codec;\n\n\tif (tone && !beep->playing) {\n\t\tsnd_hda_power_up(codec);\n\t\tif (beep->power_hook)\n\t\t\tbeep->power_hook(beep, true);\n\t\tbeep->playing = 1;\n\t}\n\tsnd_hda_codec_write(codec, beep->nid, 0,\n\t\t\t    AC_VERB_SET_BEEP_CONTROL, tone);\n\tif (!tone && beep->playing) {\n\t\tbeep->playing = 0;\n\t\tif (beep->power_hook)\n\t\t\tbeep->power_hook(beep, false);\n\t\tsnd_hda_power_down(codec);\n\t}\n}\n\nstatic void snd_hda_generate_beep(struct work_struct *work)\n{\n\tstruct hda_beep *beep =\n\t\tcontainer_of(work, struct hda_beep, beep_work);\n\n\tif (beep->enabled)\n\t\tgenerate_tone(beep, beep->tone);\n}\n\n \nstatic int beep_linear_tone(struct hda_beep *beep, int hz)\n{\n\tif (hz <= 0)\n\t\treturn 0;\n\thz *= 1000;  \n\thz = hz - DIGBEEP_HZ_MIN\n\t\t+ DIGBEEP_HZ_STEP / 2;  \n\tif (hz < 0)\n\t\thz = 0;  \n\telse if (hz >= (DIGBEEP_HZ_MAX - DIGBEEP_HZ_MIN))\n\t\thz = 1;  \n\telse {\n\t\thz /= DIGBEEP_HZ_STEP;\n\t\thz = 255 - hz;\n\t}\n\treturn hz;\n}\n\n \nstatic int beep_standard_tone(struct hda_beep *beep, int hz)\n{\n\tif (hz <= 0)\n\t\treturn 0;  \n\thz = 12000 / hz;\n\tif (hz > 0xff)\n\t\treturn 0xff;\n\tif (hz <= 0)\n\t\treturn 1;\n\treturn hz;\n}\n\nstatic int snd_hda_beep_event(struct input_dev *dev, unsigned int type,\n\t\t\t\tunsigned int code, int hz)\n{\n\tstruct hda_beep *beep = input_get_drvdata(dev);\n\n\tswitch (code) {\n\tcase SND_BELL:\n\t\tif (hz)\n\t\t\thz = 1000;\n\t\tfallthrough;\n\tcase SND_TONE:\n\t\tif (beep->linear_tone)\n\t\t\tbeep->tone = beep_linear_tone(beep, hz);\n\t\telse\n\t\t\tbeep->tone = beep_standard_tone(beep, hz);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tschedule_work(&beep->beep_work);\n\treturn 0;\n}\n\nstatic void turn_on_beep(struct hda_beep *beep)\n{\n\tif (beep->keep_power_at_enable)\n\t\tsnd_hda_power_up_pm(beep->codec);\n}\n\nstatic void turn_off_beep(struct hda_beep *beep)\n{\n\tcancel_work_sync(&beep->beep_work);\n\tif (beep->playing) {\n\t\t \n\t\tgenerate_tone(beep, 0);\n\t}\n\tif (beep->keep_power_at_enable)\n\t\tsnd_hda_power_down_pm(beep->codec);\n}\n\n \nint snd_hda_enable_beep_device(struct hda_codec *codec, int enable)\n{\n\tstruct hda_beep *beep = codec->beep;\n\tif (!beep)\n\t\treturn 0;\n\tenable = !!enable;\n\tif (beep->enabled != enable) {\n\t\tbeep->enabled = enable;\n\t\tif (enable)\n\t\t\tturn_on_beep(beep);\n\t\telse\n\t\t\tturn_off_beep(beep);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_hda_enable_beep_device);\n\nstatic int beep_dev_register(struct snd_device *device)\n{\n\tstruct hda_beep *beep = device->device_data;\n\tint err;\n\n\terr = input_register_device(beep->dev);\n\tif (!err)\n\t\tbeep->registered = true;\n\treturn err;\n}\n\nstatic int beep_dev_disconnect(struct snd_device *device)\n{\n\tstruct hda_beep *beep = device->device_data;\n\n\tif (beep->registered)\n\t\tinput_unregister_device(beep->dev);\n\telse\n\t\tinput_free_device(beep->dev);\n\tif (beep->enabled)\n\t\tturn_off_beep(beep);\n\treturn 0;\n}\n\nstatic int beep_dev_free(struct snd_device *device)\n{\n\tstruct hda_beep *beep = device->device_data;\n\n\tbeep->codec->beep = NULL;\n\tkfree(beep);\n\treturn 0;\n}\n\n \nint snd_hda_attach_beep_device(struct hda_codec *codec, int nid)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_register = beep_dev_register,\n\t\t.dev_disconnect = beep_dev_disconnect,\n\t\t.dev_free = beep_dev_free,\n\t};\n\tstruct input_dev *input_dev;\n\tstruct hda_beep *beep;\n\tint err;\n\n\tif (!snd_hda_get_bool_hint(codec, \"beep\"))\n\t\treturn 0;  \n\tif (codec->beep_mode == HDA_BEEP_MODE_OFF)\n\t\treturn 0;  \n\n\tbeep = kzalloc(sizeof(*beep), GFP_KERNEL);\n\tif (beep == NULL)\n\t\treturn -ENOMEM;\n\tsnprintf(beep->phys, sizeof(beep->phys),\n\t\t\"card%d/codec#%d/beep0\", codec->card->number, codec->addr);\n\t \n\tsnd_hda_codec_write_cache(codec, nid, 0,\n\t\tAC_VERB_SET_DIGI_CONVERT_2, 0x01);\n\n\tbeep->nid = nid;\n\tbeep->codec = codec;\n\tcodec->beep = beep;\n\n\tINIT_WORK(&beep->beep_work, &snd_hda_generate_beep);\n\tmutex_init(&beep->mutex);\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\t \n\tinput_dev->name = \"HDA Digital PCBeep\";\n\tinput_dev->phys = beep->phys;\n\tinput_dev->id.bustype = BUS_PCI;\n\tinput_dev->dev.parent = &codec->card->card_dev;\n\n\tinput_dev->id.vendor = codec->core.vendor_id >> 16;\n\tinput_dev->id.product = codec->core.vendor_id & 0xffff;\n\tinput_dev->id.version = 0x01;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_SND);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\tinput_dev->event = snd_hda_beep_event;\n\tinput_set_drvdata(input_dev, beep);\n\n\tbeep->dev = input_dev;\n\n\terr = snd_device_new(codec->card, SNDRV_DEV_JACK, beep, &ops);\n\tif (err < 0)\n\t\tgoto err_input;\n\n\treturn 0;\n\n err_input:\n\tinput_free_device(beep->dev);\n err_free:\n\tkfree(beep);\n\tcodec->beep = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(snd_hda_attach_beep_device);\n\n \nvoid snd_hda_detach_beep_device(struct hda_codec *codec)\n{\n\tif (!codec->bus->shutdown && codec->beep)\n\t\tsnd_device_free(codec->card, codec->beep);\n}\nEXPORT_SYMBOL_GPL(snd_hda_detach_beep_device);\n\nstatic bool ctl_has_mute(struct snd_kcontrol *kcontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\treturn query_amp_caps(codec, get_amp_nid(kcontrol),\n\t\t\t      get_amp_direction(kcontrol)) & AC_AMPCAP_MUTE;\n}\n\n \n\n \nint snd_hda_mixer_amp_switch_get_beep(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_beep *beep = codec->beep;\n\tint chs = get_amp_channels(kcontrol);\n\n\tif (beep && (!beep->enabled || !ctl_has_mute(kcontrol))) {\n\t\tif (chs & 1)\n\t\t\tucontrol->value.integer.value[0] = beep->enabled;\n\t\tif (chs & 2)\n\t\t\tucontrol->value.integer.value[1] = beep->enabled;\n\t\treturn 0;\n\t}\n\treturn snd_hda_mixer_amp_switch_get(kcontrol, ucontrol);\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_switch_get_beep);\n\n \nint snd_hda_mixer_amp_switch_put_beep(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hda_beep *beep = codec->beep;\n\tif (beep) {\n\t\tu8 chs = get_amp_channels(kcontrol);\n\t\tint enable = 0;\n\t\tlong *valp = ucontrol->value.integer.value;\n\t\tif (chs & 1) {\n\t\t\tenable |= *valp;\n\t\t\tvalp++;\n\t\t}\n\t\tif (chs & 2)\n\t\t\tenable |= *valp;\n\t\tsnd_hda_enable_beep_device(codec, enable);\n\t}\n\tif (!ctl_has_mute(kcontrol))\n\t\treturn 0;\n\treturn snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\n}\nEXPORT_SYMBOL_GPL(snd_hda_mixer_amp_switch_put_beep);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}