{
  "module_name": "patch_si3054.c",
  "hash_id": "ba721ddb0b00928bf2ae92a4d4b667e597115ea7c41b84737ada5cb113b40a10",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_si3054.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n\n \n#define SI3054_VERB_READ_NODE  0x900\n#define SI3054_VERB_WRITE_NODE 0x100\n\n \n#define SI3054_EXTENDED_MID    2\n#define SI3054_LINE_RATE       3\n#define SI3054_LINE_LEVEL      4\n#define SI3054_GPIO_CFG        5\n#define SI3054_GPIO_POLARITY   6\n#define SI3054_GPIO_STICKY     7\n#define SI3054_GPIO_WAKEUP     8\n#define SI3054_GPIO_STATUS     9\n#define SI3054_GPIO_CONTROL   10\n#define SI3054_MISC_AFE       11\n#define SI3054_CHIPID         12\n#define SI3054_LINE_CFG1      13\n#define SI3054_LINE_STATUS    14\n#define SI3054_DC_TERMINATION 15\n#define SI3054_LINE_CONFIG    16\n#define SI3054_CALLPROG_ATT   17\n#define SI3054_SQ_CONTROL     18\n#define SI3054_MISC_CONTROL   19\n#define SI3054_RING_CTRL1     20\n#define SI3054_RING_CTRL2     21\n\n \n#define SI3054_MEI_READY 0xf\n\n \n#define SI3054_ATAG_MASK 0x00f0\n#define SI3054_DTAG_MASK 0xf000\n\n \n#define SI3054_GPIO_OH    0x0001\n#define SI3054_GPIO_CID   0x0002\n\n \n#define SI3054_CHIPID_CODEC_REV_MASK 0x000f\n#define SI3054_CHIPID_DAA_REV_MASK   0x00f0\n#define SI3054_CHIPID_INTERNATIONAL  0x0100\n#define SI3054_CHIPID_DAA_ID         0x0f00\n#define SI3054_CHIPID_CODEC_ID      (1<<12)\n\n \n#define GET_REG(codec,reg) (snd_hda_codec_read(codec,reg,0,SI3054_VERB_READ_NODE,0))\n#define SET_REG(codec,reg,val) (snd_hda_codec_write(codec,reg,0,SI3054_VERB_WRITE_NODE,val))\n#define SET_REG_CACHE(codec,reg,val) \\\n\tsnd_hda_codec_write_cache(codec,reg,0,SI3054_VERB_WRITE_NODE,val)\n\n\nstruct si3054_spec {\n\tunsigned international;\n};\n\n\n \n\n#define PRIVATE_VALUE(reg,mask) ((reg<<16)|(mask&0xffff))\n#define PRIVATE_REG(val) ((val>>16)&0xffff)\n#define PRIVATE_MASK(val) (val&0xffff)\n\n#define si3054_switch_info\tsnd_ctl_boolean_mono_info\n\nstatic int si3054_switch_get(struct snd_kcontrol *kcontrol,\n\t\t               struct snd_ctl_elem_value *uvalue)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tu16 reg  = PRIVATE_REG(kcontrol->private_value);\n\tu16 mask = PRIVATE_MASK(kcontrol->private_value);\n\tuvalue->value.integer.value[0] = (GET_REG(codec, reg)) & mask ? 1 : 0 ;\n\treturn 0;\n}\n\nstatic int si3054_switch_put(struct snd_kcontrol *kcontrol,\n\t\t               struct snd_ctl_elem_value *uvalue)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tu16 reg  = PRIVATE_REG(kcontrol->private_value);\n\tu16 mask = PRIVATE_MASK(kcontrol->private_value);\n\tif (uvalue->value.integer.value[0])\n\t\tSET_REG_CACHE(codec, reg, (GET_REG(codec, reg)) | mask);\n\telse\n\t\tSET_REG_CACHE(codec, reg, (GET_REG(codec, reg)) & ~mask);\n\treturn 0;\n}\n\n#define SI3054_KCONTROL(kname,reg,mask) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = kname, \\\n\t.subdevice = HDA_SUBDEV_NID_FLAG | reg, \\\n\t.info = si3054_switch_info, \\\n\t.get  = si3054_switch_get, \\\n\t.put  = si3054_switch_put, \\\n\t.private_value = PRIVATE_VALUE(reg,mask), \\\n}\n\t\t\n\nstatic const struct snd_kcontrol_new si3054_modem_mixer[] = {\n\tSI3054_KCONTROL(\"Off-hook Switch\", SI3054_GPIO_CONTROL, SI3054_GPIO_OH),\n\tSI3054_KCONTROL(\"Caller ID Switch\", SI3054_GPIO_CONTROL, SI3054_GPIO_CID),\n\t{}\n};\n\nstatic int si3054_build_controls(struct hda_codec *codec)\n{\n\treturn snd_hda_add_new_ctls(codec, si3054_modem_mixer);\n}\n\n\n \n\nstatic int si3054_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t      struct hda_codec *codec,\n\t\t\t      unsigned int stream_tag,\n\t\t\t      unsigned int format,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tu16 val;\n\n\tSET_REG(codec, SI3054_LINE_RATE, substream->runtime->rate);\n\tval = GET_REG(codec, SI3054_LINE_LEVEL);\n\tval &= 0xff << (8 * (substream->stream != SNDRV_PCM_STREAM_PLAYBACK));\n\tval |= ((stream_tag & 0xf) << 4) << (8 * (substream->stream == SNDRV_PCM_STREAM_PLAYBACK));\n\tSET_REG(codec, SI3054_LINE_LEVEL, val);\n\n\tsnd_hda_codec_setup_stream(codec, hinfo->nid,\n\t\t\t\t   stream_tag, 0, format);\n\treturn 0;\n}\n\nstatic int si3054_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t   struct hda_codec *codec,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstatic const unsigned int rates[] = { 8000, 9600, 16000 };\n\tstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t\t.count = ARRAY_SIZE(rates),\n\t\t.list = rates,\n\t\t.mask = 0,\n\t};\n\tsubstream->runtime->hw.period_bytes_min = 80;\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n}\n\n\nstatic const struct hda_pcm_stream si3054_pcm = {\n\t.substreams = 1,\n\t.channels_min = 1,\n\t.channels_max = 1,\n\t.nid = 0x1,\n\t.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_KNOT,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.maxbps = 16,\n\t.ops = {\n\t\t.open = si3054_pcm_open,\n\t\t.prepare = si3054_pcm_prepare,\n\t},\n};\n\n\nstatic int si3054_build_pcms(struct hda_codec *codec)\n{\n\tstruct hda_pcm *info;\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"Si3054 Modem\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = si3054_pcm;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE]  = si3054_pcm;\n\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = codec->core.mfg;\n\tinfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = codec->core.mfg;\n\tinfo->pcm_type = HDA_PCM_TYPE_MODEM;\n\treturn 0;\n}\n\n\n \n\nstatic int si3054_init(struct hda_codec *codec)\n{\n\tstruct si3054_spec *spec = codec->spec;\n\tunsigned wait_count;\n\tu16 val;\n\n\tif (snd_hdac_regmap_add_vendor_verb(&codec->core,\n\t\t\t\t\t    SI3054_VERB_WRITE_NODE))\n\t\treturn -ENOMEM;\n\n\tsnd_hda_codec_write(codec, AC_NODE_ROOT, 0, AC_VERB_SET_CODEC_RESET, 0);\n\tsnd_hda_codec_write(codec, codec->core.mfg, 0, AC_VERB_SET_STREAM_FORMAT, 0);\n\tSET_REG(codec, SI3054_LINE_RATE, 9600);\n\tSET_REG(codec, SI3054_LINE_LEVEL, SI3054_DTAG_MASK|SI3054_ATAG_MASK);\n\tSET_REG(codec, SI3054_EXTENDED_MID, 0);\n\n\twait_count = 10;\n\tdo {\n\t\tmsleep(2);\n\t\tval = GET_REG(codec, SI3054_EXTENDED_MID);\n\t} while ((val & SI3054_MEI_READY) != SI3054_MEI_READY && wait_count--);\n\n\tif((val&SI3054_MEI_READY) != SI3054_MEI_READY) {\n\t\tcodec_err(codec, \"si3054: cannot initialize. EXT MID = %04x\\n\", val);\n\t\t \n\t\t \n\t}\n\n\tSET_REG(codec, SI3054_GPIO_POLARITY, 0xffff);\n\tSET_REG(codec, SI3054_GPIO_CFG, 0x0);\n\tSET_REG(codec, SI3054_MISC_AFE, 0);\n\tSET_REG(codec, SI3054_LINE_CFG1,0x200);\n\n\tif((GET_REG(codec,SI3054_LINE_STATUS) & (1<<6)) == 0) {\n\t\tcodec_dbg(codec,\n\t\t\t  \"Link Frame Detect(FDT) is not ready (line status: %04x)\\n\",\n\t\t\t\tGET_REG(codec,SI3054_LINE_STATUS));\n\t}\n\n\tspec->international = GET_REG(codec, SI3054_CHIPID) & SI3054_CHIPID_INTERNATIONAL;\n\n\treturn 0;\n}\n\nstatic void si3054_free(struct hda_codec *codec)\n{\n\tkfree(codec->spec);\n}\n\n\n \n\nstatic const struct hda_codec_ops si3054_patch_ops = {\n\t.build_controls = si3054_build_controls,\n\t.build_pcms = si3054_build_pcms,\n\t.init = si3054_init,\n\t.free = si3054_free,\n};\n\nstatic int patch_si3054(struct hda_codec *codec)\n{\n\tstruct si3054_spec *spec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\tcodec->spec = spec;\n\tcodec->patch_ops = si3054_patch_ops;\n\treturn 0;\n}\n\n \nstatic const struct hda_device_id snd_hda_id_si3054[] = {\n\tHDA_CODEC_ENTRY(0x163c3055, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x163c3155, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x11c13026, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x11c13055, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x11c13155, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x10573055, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x10573057, \"Si3054\", patch_si3054),\n\tHDA_CODEC_ENTRY(0x10573155, \"Si3054\", patch_si3054),\n\t \n\tHDA_CODEC_ENTRY(0x11063288, \"Si3054\", patch_si3054),\n\t \n\tHDA_CODEC_ENTRY(0x15433155, \"Si3054\", patch_si3054),\n\t \n\tHDA_CODEC_ENTRY(0x18540018, \"Si3054\", patch_si3054),\n\t{}\n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_si3054);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Si3054 HD-audio modem codec\");\n\nstatic struct hda_codec_driver si3054_driver = {\n\t.id = snd_hda_id_si3054,\n};\n\nmodule_hda_codec_driver(si3054_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}