{
  "module_name": "patch_cirrus.c",
  "hash_id": "1ad4568cf0baa9f3597182eff59e3a09d83dcf20d774e14023d6516c893b335e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_cirrus.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <linux/pci.h>\n#include <sound/tlv.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n\n \n\nstruct cs_spec {\n\tstruct hda_gen_spec gen;\n\n\tunsigned int gpio_mask;\n\tunsigned int gpio_dir;\n\tunsigned int gpio_data;\n\tunsigned int gpio_eapd_hp;  \n\tunsigned int gpio_eapd_speaker;  \n\n\t \n\tunsigned int spdif_detect:1;\n\tunsigned int spdif_present:1;\n\tunsigned int sense_b:1;\n\thda_nid_t vendor_nid;\n\n\t \n\tint (*spdif_sw_put)(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol);\n};\n\n \nenum {\n\tCS420X_MBP53,\n\tCS420X_MBP55,\n\tCS420X_IMAC27,\n\tCS420X_GPIO_13,\n\tCS420X_GPIO_23,\n\tCS420X_MBP101,\n\tCS420X_MBP81,\n\tCS420X_MBA42,\n\tCS420X_AUTO,\n\t \n\tCS420X_IMAC27_122 = CS420X_GPIO_23,\n\tCS420X_APPLE = CS420X_GPIO_13,\n};\n\n \nenum {\n\tCS421X_CDB4210,\n\tCS421X_SENSE_B,\n\tCS421X_STUMPY,\n};\n\n \n#define CS420X_VENDOR_NID\t0x11\n#define CS_DIG_OUT1_PIN_NID\t0x10\n#define CS_DIG_OUT2_PIN_NID\t0x15\n#define CS_DMIC1_PIN_NID\t0x0e\n#define CS_DMIC2_PIN_NID\t0x12\n\n \n#define IDX_SPDIF_STAT\t\t0x0000\n#define IDX_SPDIF_CTL\t\t0x0001\n#define IDX_ADC_CFG\t\t0x0002\n \n#define   CS_COEF_ADC_SZC_MASK\t\t(3 << 0)\n#define   CS_COEF_ADC_MIC_SZC_MODE\t(3 << 0)  \n#define   CS_COEF_ADC_LI_SZC_MODE\t(3 << 0)  \n \n#define   CS_COEF_ADC_MIC_PGA_MODE\t(1 << 5)  \n#define   CS_COEF_ADC_LI_PGA_MODE\t(1 << 6)  \n#define IDX_DAC_CFG\t\t0x0003\n \n#define   CS_COEF_DAC_HP_SZC_MODE\t(3 << 0)  \n#define   CS_COEF_DAC_LO_SZC_MODE\t(3 << 2)  \n#define   CS_COEF_DAC_SPK_SZC_MODE\t(3 << 4)  \n\n#define IDX_BEEP_CFG\t\t0x0004\n \n \n \n\n \n#define CS4208_VENDOR_NID\t0x24\n\n \n#define CS4210_DAC_NID\t\t0x02\n#define CS4210_ADC_NID\t\t0x03\n#define CS4210_VENDOR_NID\t0x0B\n#define CS421X_DMIC_PIN_NID\t0x09  \n#define CS421X_SPDIF_PIN_NID\t0x0A  \n\n#define CS421X_IDX_DEV_CFG\t0x01\n#define CS421X_IDX_ADC_CFG\t0x02\n#define CS421X_IDX_DAC_CFG\t0x03\n#define CS421X_IDX_SPK_CTL\t0x04\n\n \n#define CS4213_VENDOR_NID\t0x09\n\n\nstatic inline int cs_vendor_coef_get(struct hda_codec *codec, unsigned int idx)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\tsnd_hda_codec_write(codec, spec->vendor_nid, 0,\n\t\t\t    AC_VERB_SET_COEF_INDEX, idx);\n\treturn snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\t  AC_VERB_GET_PROC_COEF, 0);\n}\n\nstatic inline void cs_vendor_coef_set(struct hda_codec *codec, unsigned int idx,\n\t\t\t\t      unsigned int coef)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\tsnd_hda_codec_write(codec, spec->vendor_nid, 0,\n\t\t\t    AC_VERB_SET_COEF_INDEX, idx);\n\tsnd_hda_codec_write(codec, spec->vendor_nid, 0,\n\t\t\t    AC_VERB_SET_PROC_COEF, coef);\n}\n\n \n\nstatic void cs_automute(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\t \n\tspec->gen.master_mute = !!(spec->spdif_present && spec->sense_b);\n\n\tsnd_hda_gen_update_outputs(codec);\n\n\tif (spec->gpio_eapd_hp || spec->gpio_eapd_speaker) {\n\t\tif (spec->gen.automute_speaker)\n\t\t\tspec->gpio_data = spec->gen.hp_jack_present ?\n\t\t\t\tspec->gpio_eapd_hp : spec->gpio_eapd_speaker;\n\t\telse\n\t\t\tspec->gpio_data =\n\t\t\t\tspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\t    AC_VERB_SET_GPIO_DATA, spec->gpio_data);\n\t}\n}\n\nstatic bool is_active_pin(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int val;\n\n\tval = snd_hda_codec_get_pincfg(codec, nid);\n\treturn (get_defcfg_connect(val) != AC_JACK_PORT_NONE);\n}\n\nstatic void init_input_coef(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tunsigned int coef;\n\n\t \n\tif (spec->vendor_nid == CS420X_VENDOR_NID) {\n\t\tcoef = cs_vendor_coef_get(codec, IDX_BEEP_CFG);\n\t\tif (is_active_pin(codec, CS_DMIC2_PIN_NID))\n\t\t\tcoef |= 1 << 4;  \n\t\tif (is_active_pin(codec, CS_DMIC1_PIN_NID))\n\t\t\tcoef |= 1 << 3;  \n\n\t\tcs_vendor_coef_set(codec, IDX_BEEP_CFG, coef);\n\t}\n}\n\nstatic const struct hda_verb cs_coef_init_verbs[] = {\n\t{0x11, AC_VERB_SET_PROC_STATE, 1},\n\t{0x11, AC_VERB_SET_COEF_INDEX, IDX_DAC_CFG},\n\t{0x11, AC_VERB_SET_PROC_COEF,\n\t (0x002a  \n\t  | 0x0040  \n\t  | 0x1000  \n\t  | 0x0400  \n\t  )},\n\t \n\t{0x11, AC_VERB_SET_COEF_INDEX, IDX_ADC_CFG},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x000a},\n\t \n\t{0x11, AC_VERB_SET_COEF_INDEX, IDX_BEEP_CFG},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x0007},  \n\n\t{}  \n};\n\nstatic const struct hda_verb cs4208_coef_init_verbs[] = {\n\t{0x01, AC_VERB_SET_POWER_STATE, 0x00},  \n\t{0x24, AC_VERB_SET_PROC_STATE, 0x01},   \n\t{0x24, AC_VERB_SET_COEF_INDEX, 0x0033},\n\t{0x24, AC_VERB_SET_PROC_COEF, 0x0001},  \n\t{0x24, AC_VERB_SET_COEF_INDEX, 0x0034},\n\t{0x24, AC_VERB_SET_PROC_COEF, 0x1C01},  \n\t{}  \n};\n\n \n\nstatic const struct hda_verb cs_errata_init_verbs[] = {\n\t{0x01, AC_VERB_SET_POWER_STATE, 0x00},  \n\t{0x11, AC_VERB_SET_PROC_STATE, 0x01},   \n\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0008},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x9999},\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0017},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0xa412},\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0001},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x0009},\n\n\t{0x07, AC_VERB_SET_POWER_STATE, 0x00},  \n\t{0x08, AC_VERB_SET_POWER_STATE, 0x00},  \n\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0017},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x2412},\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0008},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x0000},\n\t{0x11, AC_VERB_SET_COEF_INDEX, 0x0001},\n\t{0x11, AC_VERB_SET_PROC_COEF, 0x0008},\n\t{0x11, AC_VERB_SET_PROC_STATE, 0x00},\n\t{}  \n};\n\n \nstatic void init_digital_coef(struct hda_codec *codec)\n{\n\tunsigned int coef;\n\n\tcoef = 0x0002;  \n\tcoef |= 0x0008;  \n\tif (is_active_pin(codec, CS_DIG_OUT2_PIN_NID))\n\t\tcoef |= 0x4000;  \n\tcs_vendor_coef_set(codec, IDX_SPDIF_CTL, coef);\n}\n\nstatic int cs_init(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\tif (spec->vendor_nid == CS420X_VENDOR_NID) {\n\t\t \n\t\tsnd_hda_sequence_write(codec, cs_errata_init_verbs);\n\t\tsnd_hda_sequence_write(codec, cs_coef_init_verbs);\n\t} else if (spec->vendor_nid == CS4208_VENDOR_NID) {\n\t\tsnd_hda_sequence_write(codec, cs4208_coef_init_verbs);\n\t}\n\n\tsnd_hda_gen_init(codec);\n\n\tif (spec->gpio_mask) {\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\n\t\t\t\t    spec->gpio_mask);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\n\t\t\t\t    spec->gpio_dir);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\t\t    spec->gpio_data);\n\t}\n\n\tif (spec->vendor_nid == CS420X_VENDOR_NID) {\n\t\tinit_input_coef(codec);\n\t\tinit_digital_coef(codec);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_build_controls(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = snd_hda_gen_build_controls(codec);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_BUILD);\n\treturn 0;\n}\n\n#define cs_free\t\tsnd_hda_gen_free\n\nstatic const struct hda_codec_ops cs_patch_ops = {\n\t.build_controls = cs_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = cs_init,\n\t.free = cs_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n};\n\nstatic int cs_parse_auto_config(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tint err;\n\tint i;\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (spec->gen.dyn_adc_switch) {\n\t\tunsigned int done = 0;\n\n\t\tfor (i = 0; i < spec->gen.input_mux.num_items; i++) {\n\t\t\tint idx = spec->gen.dyn_adc_idx[i];\n\n\t\t\tif (done & (1 << idx))\n\t\t\t\tcontinue;\n\t\t\tsnd_hda_gen_fix_pin_power(codec,\n\t\t\t\t\t\t  spec->gen.adc_nids[idx]);\n\t\t\tdone |= 1 << idx;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hda_model_fixup cs420x_models[] = {\n\t{ .id = CS420X_MBP53, .name = \"mbp53\" },\n\t{ .id = CS420X_MBP55, .name = \"mbp55\" },\n\t{ .id = CS420X_IMAC27, .name = \"imac27\" },\n\t{ .id = CS420X_IMAC27_122, .name = \"imac27_122\" },\n\t{ .id = CS420X_APPLE, .name = \"apple\" },\n\t{ .id = CS420X_MBP101, .name = \"mbp101\" },\n\t{ .id = CS420X_MBP81, .name = \"mbp81\" },\n\t{ .id = CS420X_MBA42, .name = \"mba42\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cs420x_fixup_tbl[] = {\n\tSND_PCI_QUIRK(0x10de, 0x0ac0, \"MacBookPro 5,3\", CS420X_MBP53),\n\tSND_PCI_QUIRK(0x10de, 0x0d94, \"MacBookAir 3,1(2)\", CS420X_MBP55),\n\tSND_PCI_QUIRK(0x10de, 0xcb79, \"MacBookPro 5,5\", CS420X_MBP55),\n\tSND_PCI_QUIRK(0x10de, 0xcb89, \"MacBookPro 7,1\", CS420X_MBP55),\n\t \n\t \n\n\t \n\tSND_PCI_QUIRK(0x106b, 0x0600, \"iMac 14,1\", CS420X_IMAC27_122),\n\tSND_PCI_QUIRK(0x106b, 0x0900, \"iMac 12,1\", CS420X_IMAC27_122),\n\tSND_PCI_QUIRK(0x106b, 0x1c00, \"MacBookPro 8,1\", CS420X_MBP81),\n\tSND_PCI_QUIRK(0x106b, 0x2000, \"iMac 12,2\", CS420X_IMAC27_122),\n\tSND_PCI_QUIRK(0x106b, 0x2800, \"MacBookPro 10,1\", CS420X_MBP101),\n\tSND_PCI_QUIRK(0x106b, 0x5600, \"MacBookAir 5,2\", CS420X_MBP81),\n\tSND_PCI_QUIRK(0x106b, 0x5b00, \"MacBookAir 4,2\", CS420X_MBA42),\n\tSND_PCI_QUIRK_VENDOR(0x106b, \"Apple\", CS420X_APPLE),\n\t{}  \n};\n\nstatic const struct hda_pintbl mbp53_pincfgs[] = {\n\t{ 0x09, 0x012b4050 },\n\t{ 0x0a, 0x90100141 },\n\t{ 0x0b, 0x90100140 },\n\t{ 0x0c, 0x018b3020 },\n\t{ 0x0d, 0x90a00110 },\n\t{ 0x0e, 0x400000f0 },\n\t{ 0x0f, 0x01cbe030 },\n\t{ 0x10, 0x014be060 },\n\t{ 0x12, 0x400000f0 },\n\t{ 0x15, 0x400000f0 },\n\t{}  \n};\n\nstatic const struct hda_pintbl mbp55_pincfgs[] = {\n\t{ 0x09, 0x012b4030 },\n\t{ 0x0a, 0x90100121 },\n\t{ 0x0b, 0x90100120 },\n\t{ 0x0c, 0x400000f0 },\n\t{ 0x0d, 0x90a00110 },\n\t{ 0x0e, 0x400000f0 },\n\t{ 0x0f, 0x400000f0 },\n\t{ 0x10, 0x014be040 },\n\t{ 0x12, 0x400000f0 },\n\t{ 0x15, 0x400000f0 },\n\t{}  \n};\n\nstatic const struct hda_pintbl imac27_pincfgs[] = {\n\t{ 0x09, 0x012b4050 },\n\t{ 0x0a, 0x90100140 },\n\t{ 0x0b, 0x90100142 },\n\t{ 0x0c, 0x018b3020 },\n\t{ 0x0d, 0x90a00110 },\n\t{ 0x0e, 0x400000f0 },\n\t{ 0x0f, 0x01cbe030 },\n\t{ 0x10, 0x014be060 },\n\t{ 0x12, 0x01ab9070 },\n\t{ 0x15, 0x400000f0 },\n\t{}  \n};\n\nstatic const struct hda_pintbl mbp101_pincfgs[] = {\n\t{ 0x0d, 0x40ab90f0 },\n\t{ 0x0e, 0x90a600f0 },\n\t{ 0x12, 0x50a600f0 },\n\t{}  \n};\n\nstatic const struct hda_pintbl mba42_pincfgs[] = {\n\t{ 0x09, 0x012b4030 },  \n\t{ 0x0a, 0x400000f0 },\n\t{ 0x0b, 0x90100120 },  \n\t{ 0x0c, 0x400000f0 },\n\t{ 0x0d, 0x90a00110 },  \n\t{ 0x0e, 0x400000f0 },\n\t{ 0x0f, 0x400000f0 },\n\t{ 0x10, 0x400000f0 },\n\t{ 0x12, 0x400000f0 },\n\t{ 0x15, 0x400000f0 },\n\t{}  \n};\n\nstatic const struct hda_pintbl mba6_pincfgs[] = {\n\t{ 0x10, 0x032120f0 },  \n\t{ 0x11, 0x500000f0 },\n\t{ 0x12, 0x90100010 },  \n\t{ 0x13, 0x500000f0 },\n\t{ 0x14, 0x500000f0 },\n\t{ 0x15, 0x770000f0 },\n\t{ 0x16, 0x770000f0 },\n\t{ 0x17, 0x430000f0 },\n\t{ 0x18, 0x43ab9030 },  \n\t{ 0x19, 0x770000f0 },\n\t{ 0x1a, 0x770000f0 },\n\t{ 0x1b, 0x770000f0 },\n\t{ 0x1c, 0x90a00090 },\n\t{ 0x1d, 0x500000f0 },\n\t{ 0x1e, 0x500000f0 },\n\t{ 0x1f, 0x500000f0 },\n\t{ 0x20, 0x500000f0 },\n\t{ 0x21, 0x430000f0 },\n\t{ 0x22, 0x430000f0 },\n\t{}  \n};\n\nstatic void cs420x_fixup_gpio_13(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tstruct cs_spec *spec = codec->spec;\n\n\t\tspec->gpio_eapd_hp = 2;  \n\t\tspec->gpio_eapd_speaker = 8;  \n\t\tspec->gpio_mask = spec->gpio_dir =\n\t\t\tspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\n\t}\n}\n\nstatic void cs420x_fixup_gpio_23(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tstruct cs_spec *spec = codec->spec;\n\n\t\tspec->gpio_eapd_hp = 4;  \n\t\tspec->gpio_eapd_speaker = 8;  \n\t\tspec->gpio_mask = spec->gpio_dir =\n\t\t\tspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\n\t}\n}\n\nstatic const struct hda_fixup cs420x_fixups[] = {\n\t[CS420X_MBP53] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = mbp53_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS420X_APPLE,\n\t},\n\t[CS420X_MBP55] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = mbp55_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS420X_GPIO_13,\n\t},\n\t[CS420X_IMAC27] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = imac27_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS420X_GPIO_13,\n\t},\n\t[CS420X_GPIO_13] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs420x_fixup_gpio_13,\n\t},\n\t[CS420X_GPIO_23] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs420x_fixup_gpio_23,\n\t},\n\t[CS420X_MBP101] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = mbp101_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS420X_GPIO_13,\n\t},\n\t[CS420X_MBP81] = {\n\t\t.type = HDA_FIXUP_VERBS,\n\t\t.v.verbs = (const struct hda_verb[]) {\n\t\t\t \n\t\t\t{0x11, AC_VERB_SET_COEF_INDEX, IDX_ADC_CFG},\n\t\t\t{0x11, AC_VERB_SET_PROC_COEF, 0x102a},\n\t\t\t{}\n\t\t},\n\t\t.chained = true,\n\t\t.chain_id = CS420X_GPIO_13,\n\t},\n\t[CS420X_MBA42] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = mba42_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS420X_GPIO_13,\n\t},\n};\n\nstatic struct cs_spec *cs_alloc_spec(struct hda_codec *codec, int vendor_nid)\n{\n\tstruct cs_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn NULL;\n\tcodec->spec = spec;\n\tspec->vendor_nid = vendor_nid;\n\tcodec->power_save_node = 1;\n\tsnd_hda_gen_spec_init(&spec->gen);\n\n\treturn spec;\n}\n\nstatic int patch_cs420x(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec;\n\tint err;\n\n\tspec = cs_alloc_spec(codec, CS420X_VENDOR_NID);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tcodec->patch_ops = cs_patch_ops;\n\tspec->gen.automute_hook = cs_automute;\n\tcodec->single_adc_amp = 1;\n\n\tsnd_hda_pick_fixup(codec, cs420x_models, cs420x_fixup_tbl,\n\t\t\t   cs420x_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = cs_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tcs_free(codec);\n\treturn err;\n}\n\n \nenum {\n\tCS4208_MAC_AUTO,\n\tCS4208_MBA6,\n\tCS4208_MBP11,\n\tCS4208_MACMINI,\n\tCS4208_GPIO0,\n};\n\nstatic const struct hda_model_fixup cs4208_models[] = {\n\t{ .id = CS4208_GPIO0, .name = \"gpio0\" },\n\t{ .id = CS4208_MBA6, .name = \"mba6\" },\n\t{ .id = CS4208_MBP11, .name = \"mbp11\" },\n\t{ .id = CS4208_MACMINI, .name = \"macmini\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cs4208_fixup_tbl[] = {\n\tSND_PCI_QUIRK_VENDOR(0x106b, \"Apple\", CS4208_MAC_AUTO),\n\t{}  \n};\n\n \nstatic const struct snd_pci_quirk cs4208_mac_fixup_tbl[] = {\n\tSND_PCI_QUIRK(0x106b, 0x5e00, \"MacBookPro 11,2\", CS4208_MBP11),\n\tSND_PCI_QUIRK(0x106b, 0x6c00, \"MacMini 7,1\", CS4208_MACMINI),\n\tSND_PCI_QUIRK(0x106b, 0x7100, \"MacBookAir 6,1\", CS4208_MBA6),\n\tSND_PCI_QUIRK(0x106b, 0x7200, \"MacBookAir 6,2\", CS4208_MBA6),\n\tSND_PCI_QUIRK(0x106b, 0x7b00, \"MacBookPro 12,1\", CS4208_MBP11),\n\t{}  \n};\n\nstatic void cs4208_fixup_gpio0(struct hda_codec *codec,\n\t\t\t       const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tstruct cs_spec *spec = codec->spec;\n\n\t\tspec->gpio_eapd_hp = 0;\n\t\tspec->gpio_eapd_speaker = 1;\n\t\tspec->gpio_mask = spec->gpio_dir =\n\t\t\tspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\n\t}\n}\n\nstatic const struct hda_fixup cs4208_fixups[];\n\n \nstatic void cs4208_fixup_mac(struct hda_codec *codec,\n\t\t\t     const struct hda_fixup *fix, int action)\n{\n\tif (action != HDA_FIXUP_ACT_PRE_PROBE)\n\t\treturn;\n\n\tcodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\n\tsnd_hda_pick_fixup(codec, NULL, cs4208_mac_fixup_tbl, cs4208_fixups);\n\tif (codec->fixup_id == HDA_FIXUP_ID_NOT_SET)\n\t\tcodec->fixup_id = CS4208_GPIO0;  \n\tsnd_hda_apply_fixup(codec, action);\n}\n\n \nstatic void cs4208_fixup_macmini(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tstatic const struct hda_pintbl pincfgs[] = {\n\t\t{ 0x18, 0x00ab9150 },  \n\t\t{ 0x21, 0x004be140 },  \n\t\t{ }\n\t};\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\t \n\t\tcodec->inv_jack_detect = 1;\n\t\t \n\t\tsnd_hda_apply_pincfgs(codec, pincfgs);\n\t}\n}\n\nstatic int cs4208_spdif_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct cs_spec *spec = codec->spec;\n\thda_nid_t pin = spec->gen.autocfg.dig_out_pins[0];\n\tint pinctl = ucontrol->value.integer.value[0] ? PIN_OUT : 0;\n\n\tsnd_hda_set_pin_ctl_cache(codec, pin, pinctl);\n\treturn spec->spdif_sw_put(kcontrol, ucontrol);\n}\n\n \nstatic void cs4208_fixup_spdif_switch(struct hda_codec *codec,\n\t\t\t\t      const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_BUILD) {\n\t\tstruct cs_spec *spec = codec->spec;\n\t\tstruct snd_kcontrol *kctl;\n\n\t\tif (!spec->gen.autocfg.dig_out_pins[0])\n\t\t\treturn;\n\t\tkctl = snd_hda_find_mixer_ctl(codec, \"IEC958 Playback Switch\");\n\t\tif (!kctl)\n\t\t\treturn;\n\t\tspec->spdif_sw_put = kctl->put;\n\t\tkctl->put = cs4208_spdif_sw_put;\n\t}\n}\n\nstatic const struct hda_fixup cs4208_fixups[] = {\n\t[CS4208_MBA6] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = mba6_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS4208_GPIO0,\n\t},\n\t[CS4208_MBP11] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs4208_fixup_spdif_switch,\n\t\t.chained = true,\n\t\t.chain_id = CS4208_GPIO0,\n\t},\n\t[CS4208_MACMINI] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs4208_fixup_macmini,\n\t\t.chained = true,\n\t\t.chain_id = CS4208_GPIO0,\n\t},\n\t[CS4208_GPIO0] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs4208_fixup_gpio0,\n\t},\n\t[CS4208_MAC_AUTO] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs4208_fixup_mac,\n\t},\n};\n\n \nstatic void cs4208_fix_amp_caps(struct hda_codec *codec, hda_nid_t adc)\n{\n\tunsigned int caps;\n\n\tcaps = query_amp_caps(codec, adc, HDA_INPUT);\n\tcaps &= ~(AC_AMPCAP_OFFSET);\n\tcaps |= 0x02;\n\tsnd_hda_override_amp_caps(codec, adc, HDA_INPUT, caps);\n}\n\nstatic int patch_cs4208(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec;\n\tint err;\n\n\tspec = cs_alloc_spec(codec, CS4208_VENDOR_NID);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tcodec->patch_ops = cs_patch_ops;\n\tspec->gen.automute_hook = cs_automute;\n\t \n\tspec->gen.out_vol_mask = 1ULL << 0x10;\n\n\tsnd_hda_pick_fixup(codec, cs4208_models, cs4208_fixup_tbl,\n\t\t\t   cs4208_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\tsnd_hda_override_wcaps(codec, 0x18,\n\t\t\t       get_wcaps(codec, 0x18) | AC_WCAP_STEREO);\n\tcs4208_fix_amp_caps(codec, 0x18);\n\tcs4208_fix_amp_caps(codec, 0x1b);\n\tcs4208_fix_amp_caps(codec, 0x1c);\n\n\terr = cs_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tcs_free(codec);\n\treturn err;\n}\n\n \n\n \nstatic const struct hda_model_fixup cs421x_models[] = {\n\t{ .id = CS421X_CDB4210, .name = \"cdb4210\" },\n\t{ .id = CS421X_STUMPY, .name = \"stumpy\" },\n\t{}\n};\n\nstatic const struct snd_pci_quirk cs421x_fixup_tbl[] = {\n\t \n\tSND_PCI_QUIRK(0x8086, 0x5001, \"DP45SG/CDB4210\", CS421X_CDB4210),\n\t{}  \n};\n\n \n \nstatic const struct hda_pintbl cdb4210_pincfgs[] = {\n\t{ 0x05, 0x0321401f },\n\t{ 0x06, 0x90170010 },\n\t{ 0x07, 0x03813031 },\n\t{ 0x08, 0xb7a70037 },\n\t{ 0x09, 0xb7a6003e },\n\t{ 0x0a, 0x034510f0 },\n\t{}  \n};\n\n \nstatic const struct hda_pintbl stumpy_pincfgs[] = {\n\t{ 0x05, 0x022120f0 },\n\t{ 0x06, 0x901700f0 },\n\t{ 0x07, 0x02a120f0 },\n\t{ 0x08, 0x77a70037 },\n\t{ 0x09, 0x77a6003e },\n\t{ 0x0a, 0x434510f0 },\n\t{}  \n};\n\n \nstatic void cs421x_fixup_sense_b(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tspec->sense_b = 1;\n}\n\nstatic const struct hda_fixup cs421x_fixups[] = {\n\t[CS421X_CDB4210] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = cdb4210_pincfgs,\n\t\t.chained = true,\n\t\t.chain_id = CS421X_SENSE_B,\n\t},\n\t[CS421X_SENSE_B] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = cs421x_fixup_sense_b,\n\t},\n\t[CS421X_STUMPY] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = stumpy_pincfgs,\n\t},\n};\n\nstatic const struct hda_verb cs421x_coef_init_verbs[] = {\n\t{0x0B, AC_VERB_SET_PROC_STATE, 1},\n\t{0x0B, AC_VERB_SET_COEF_INDEX, CS421X_IDX_DEV_CFG},\n\t \n\t{0x0B, AC_VERB_SET_PROC_COEF, 0x0001 },\n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, CS421X_IDX_ADC_CFG},\n\t \n\t{0x0B, AC_VERB_SET_PROC_COEF, 0x0002 },\n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, CS421X_IDX_DAC_CFG},\n\t{0x0B, AC_VERB_SET_PROC_COEF,\n\t (0x0002  \n\t  | 0x0004  \n\t  | 0x0008  \n\t  )},\n\t{}  \n};\n\n \n\nstatic const struct hda_verb cs421x_coef_init_verbs_A1_silicon_fixes[] = {\n\t{0x0B, AC_VERB_SET_PROC_STATE, 0x01},   \n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, 0x0006},\n\t{0x0B, AC_VERB_SET_PROC_COEF, 0x9999},  \n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, 0x000A},\n\t{0x0B, AC_VERB_SET_PROC_COEF, 0x14CB},  \n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, 0x0011},\n\t{0x0B, AC_VERB_SET_PROC_COEF, 0xA2D0},  \n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, 0x001A},\n\t{0x0B, AC_VERB_SET_PROC_COEF, 0x02A9},  \n\n\t{0x0B, AC_VERB_SET_COEF_INDEX, 0x001B},\n\t{0x0B, AC_VERB_SET_PROC_COEF, 0X1006},  \n\n\t{}  \n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(cs421x_speaker_boost_db_scale, 900, 300, 0);\n\nstatic int cs421x_boost_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 3;\n\treturn 0;\n}\n\nstatic int cs421x_boost_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] =\n\t\tcs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL) & 0x0003;\n\treturn 0;\n}\n\nstatic int cs421x_boost_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\n\tunsigned int vol = ucontrol->value.integer.value[0];\n\tunsigned int coef =\n\t\tcs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL);\n\tunsigned int original_coef = coef;\n\n\tcoef &= ~0x0003;\n\tcoef |= (vol & 0x0003);\n\tif (original_coef != coef) {\n\t\tcs_vendor_coef_set(codec, CS421X_IDX_SPK_CTL, coef);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new cs421x_speaker_boost_ctl = {\n\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name = \"Speaker Boost Playback Volume\",\n\t.info = cs421x_boost_vol_info,\n\t.get = cs421x_boost_vol_get,\n\t.put = cs421x_boost_vol_put,\n\t.tlv = { .p = cs421x_speaker_boost_db_scale },\n};\n\nstatic void cs4210_pinmux_init(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tunsigned int def_conf, coef;\n\n\t \n\tcoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\n\n\tif (spec->gpio_mask)\n\t\tcoef |= 0x0008;  \n\telse\n\t\tcoef &= ~0x0008;\n\n\tif (spec->sense_b)\n\t\tcoef |= 0x0010;  \n\telse\n\t\tcoef &= ~0x0010;\n\n\tcs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\n\n\tif ((spec->gpio_mask || spec->sense_b) &&\n\t    is_active_pin(codec, CS421X_DMIC_PIN_NID)) {\n\n\t\t \n\t\tdef_conf = snd_hda_codec_get_pincfg(codec, CS421X_DMIC_PIN_NID);\n\t\tdef_conf &= ~AC_DEFCFG_PORT_CONN;\n\t\tdef_conf |= (AC_JACK_PORT_NONE << AC_DEFCFG_PORT_CONN_SHIFT);\n\t\tsnd_hda_codec_set_pincfg(codec, CS421X_DMIC_PIN_NID, def_conf);\n\t}\n}\n\nstatic void cs4210_spdif_automute(struct hda_codec *codec,\n\t\t\t\t  struct hda_jack_callback *tbl)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tbool spdif_present = false;\n\thda_nid_t spdif_pin = spec->gen.autocfg.dig_out_pins[0];\n\n\t \n\tif (!spec->spdif_detect ||\n\t    spec->vendor_nid != CS4210_VENDOR_NID)\n\t\treturn;\n\n\tspdif_present = snd_hda_jack_detect(codec, spdif_pin);\n\tif (spdif_present == spec->spdif_present)\n\t\treturn;\n\n\tspec->spdif_present = spdif_present;\n\t \n\tsnd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);\n\n\tcs_automute(codec);\n}\n\nstatic void parse_cs421x_digital(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\n\tint i;\n\n\tfor (i = 0; i < cfg->dig_outs; i++) {\n\t\thda_nid_t nid = cfg->dig_out_pins[i];\n\n\t\tif (get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) {\n\t\t\tspec->spdif_detect = 1;\n\t\t\tsnd_hda_jack_detect_enable_callback(codec, nid,\n\t\t\t\t\t\t\t    cs4210_spdif_automute);\n\t\t}\n\t}\n}\n\nstatic int cs421x_init(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\n\tif (spec->vendor_nid == CS4210_VENDOR_NID) {\n\t\tsnd_hda_sequence_write(codec, cs421x_coef_init_verbs);\n\t\tsnd_hda_sequence_write(codec, cs421x_coef_init_verbs_A1_silicon_fixes);\n\t\tcs4210_pinmux_init(codec);\n\t}\n\n\tsnd_hda_gen_init(codec);\n\n\tif (spec->gpio_mask) {\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\n\t\t\t\t    spec->gpio_mask);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\n\t\t\t\t    spec->gpio_dir);\n\t\tsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\t\t    spec->gpio_data);\n\t}\n\n\tinit_input_coef(codec);\n\n\tcs4210_spdif_automute(codec, NULL);\n\n\treturn 0;\n}\n\nstatic void fix_volume_caps(struct hda_codec *codec, hda_nid_t dac)\n{\n\tunsigned int caps;\n\n\t \n\tcaps = query_amp_caps(codec, dac, HDA_OUTPUT);\n\tcaps &= ~(0x7f << AC_AMPCAP_NUM_STEPS_SHIFT);\n\tcaps |= ((caps >> AC_AMPCAP_OFFSET_SHIFT) & 0x7f)\n\t\t<< AC_AMPCAP_NUM_STEPS_SHIFT;\n\tsnd_hda_override_amp_caps(codec, dac, HDA_OUTPUT, caps);\n}\n\nstatic int cs421x_parse_auto_config(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\thda_nid_t dac = CS4210_DAC_NID;\n\tint err;\n\n\tfix_volume_caps(codec, dac);\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\tparse_cs421x_digital(codec);\n\n\tif (spec->gen.autocfg.speaker_outs &&\n\t    spec->vendor_nid == CS4210_VENDOR_NID) {\n\t\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL,\n\t\t\t\t\t  &cs421x_speaker_boost_ctl))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n \nstatic int cs421x_suspend(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec = codec->spec;\n\tunsigned int coef;\n\n\tsnd_hda_shutup_pins(codec);\n\n\tsnd_hda_codec_write(codec, CS4210_DAC_NID, 0,\n\t\t\t    AC_VERB_SET_POWER_STATE,  AC_PWRST_D3);\n\tsnd_hda_codec_write(codec, CS4210_ADC_NID, 0,\n\t\t\t    AC_VERB_SET_POWER_STATE,  AC_PWRST_D3);\n\n\tif (spec->vendor_nid == CS4210_VENDOR_NID) {\n\t\tcoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\n\t\tcoef |= 0x0004;  \n\t\tcs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct hda_codec_ops cs421x_patch_ops = {\n\t.build_controls = snd_hda_gen_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = cs421x_init,\n\t.free = cs_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = cs421x_suspend,\n#endif\n};\n\nstatic int patch_cs4210(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec;\n\tint err;\n\n\tspec = cs_alloc_spec(codec, CS4210_VENDOR_NID);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tcodec->patch_ops = cs421x_patch_ops;\n\tspec->gen.automute_hook = cs_automute;\n\n\tsnd_hda_pick_fixup(codec, cs421x_models, cs421x_fixup_tbl,\n\t\t\t   cs421x_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\t \n\tcs4210_pinmux_init(codec);\n\n\terr = cs421x_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tcs_free(codec);\n\treturn err;\n}\n\nstatic int patch_cs4213(struct hda_codec *codec)\n{\n\tstruct cs_spec *spec;\n\tint err;\n\n\tspec = cs_alloc_spec(codec, CS4213_VENDOR_NID);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tcodec->patch_ops = cs421x_patch_ops;\n\n\terr = cs421x_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tcs_free(codec);\n\treturn err;\n}\n\n \nstatic const struct hda_device_id snd_hda_id_cirrus[] = {\n\tHDA_CODEC_ENTRY(0x10134206, \"CS4206\", patch_cs420x),\n\tHDA_CODEC_ENTRY(0x10134207, \"CS4207\", patch_cs420x),\n\tHDA_CODEC_ENTRY(0x10134208, \"CS4208\", patch_cs4208),\n\tHDA_CODEC_ENTRY(0x10134210, \"CS4210\", patch_cs4210),\n\tHDA_CODEC_ENTRY(0x10134213, \"CS4213\", patch_cs4213),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_cirrus);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cirrus Logic HD-audio codec\");\n\nstatic struct hda_codec_driver cirrus_driver = {\n\t.id = snd_hda_id_cirrus,\n};\n\nmodule_hda_codec_driver(cirrus_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}