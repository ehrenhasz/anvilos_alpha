{
  "module_name": "hda_eld.c",
  "hash_id": "dea5fc12549c5ff73e9a9fab6d3e533f190a986a590ed5cdd56c508944c288a5",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_eld.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <asm/unaligned.h>\n#include <sound/hda_chmap.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n\nenum eld_versions {\n\tELD_VER_CEA_861D\t= 2,\n\tELD_VER_PARTIAL\t\t= 31,\n};\n\nenum cea_edid_versions {\n\tCEA_EDID_VER_NONE\t= 0,\n\tCEA_EDID_VER_CEA861\t= 1,\n\tCEA_EDID_VER_CEA861A\t= 2,\n\tCEA_EDID_VER_CEA861BCD\t= 3,\n\tCEA_EDID_VER_RESERVED\t= 4,\n};\n\nstatic const char * const eld_connection_type_names[4] = {\n\t\"HDMI\",\n\t\"DisplayPort\",\n\t\"2-reserved\",\n\t\"3-reserved\"\n};\n\nenum cea_audio_coding_types {\n\tAUDIO_CODING_TYPE_REF_STREAM_HEADER\t=  0,\n\tAUDIO_CODING_TYPE_LPCM\t\t\t=  1,\n\tAUDIO_CODING_TYPE_AC3\t\t\t=  2,\n\tAUDIO_CODING_TYPE_MPEG1\t\t\t=  3,\n\tAUDIO_CODING_TYPE_MP3\t\t\t=  4,\n\tAUDIO_CODING_TYPE_MPEG2\t\t\t=  5,\n\tAUDIO_CODING_TYPE_AACLC\t\t\t=  6,\n\tAUDIO_CODING_TYPE_DTS\t\t\t=  7,\n\tAUDIO_CODING_TYPE_ATRAC\t\t\t=  8,\n\tAUDIO_CODING_TYPE_SACD\t\t\t=  9,\n\tAUDIO_CODING_TYPE_EAC3\t\t\t= 10,\n\tAUDIO_CODING_TYPE_DTS_HD\t\t= 11,\n\tAUDIO_CODING_TYPE_MLP\t\t\t= 12,\n\tAUDIO_CODING_TYPE_DST\t\t\t= 13,\n\tAUDIO_CODING_TYPE_WMAPRO\t\t= 14,\n\tAUDIO_CODING_TYPE_REF_CXT\t\t= 15,\n\t \n\tAUDIO_CODING_TYPE_HE_AAC\t\t= 15,\n\tAUDIO_CODING_TYPE_HE_AAC2\t\t= 16,\n\tAUDIO_CODING_TYPE_MPEG_SURROUND\t\t= 17,\n};\n\nenum cea_audio_coding_xtypes {\n\tAUDIO_CODING_XTYPE_HE_REF_CT\t\t= 0,\n\tAUDIO_CODING_XTYPE_HE_AAC\t\t= 1,\n\tAUDIO_CODING_XTYPE_HE_AAC2\t\t= 2,\n\tAUDIO_CODING_XTYPE_MPEG_SURROUND\t= 3,\n\tAUDIO_CODING_XTYPE_FIRST_RESERVED\t= 4,\n};\n\nstatic const char * const cea_audio_coding_type_names[] = {\n\t  \"undefined\",\n\t  \"LPCM\",\n\t  \"AC-3\",\n\t  \"MPEG1\",\n\t  \"MP3\",\n\t  \"MPEG2\",\n\t  \"AAC-LC\",\n\t  \"DTS\",\n\t  \"ATRAC\",\n\t  \"DSD (One Bit Audio)\",\n\t  \"E-AC-3/DD+ (Dolby Digital Plus)\",\n\t  \"DTS-HD\",\n\t  \"MLP (Dolby TrueHD)\",\n\t  \"DST\",\n\t  \"WMAPro\",\n\t  \"HE-AAC\",\n\t  \"HE-AACv2\",\n\t  \"MPEG Surround\",\n};\n\n \n\n \nstatic const int cea_sample_sizes[4] = {\n\t0,\t \t\t \n\tAC_SUPPCM_BITS_16,\t \n\tAC_SUPPCM_BITS_20,\t \n\tAC_SUPPCM_BITS_24,\t \n};\n\n \nstatic const int cea_sampling_frequencies[8] = {\n\t0,\t\t\t \n\tSNDRV_PCM_RATE_32000,\t \n\tSNDRV_PCM_RATE_44100,\t \n\tSNDRV_PCM_RATE_48000,\t \n\tSNDRV_PCM_RATE_88200,\t \n\tSNDRV_PCM_RATE_96000,\t \n\tSNDRV_PCM_RATE_176400,\t \n\tSNDRV_PCM_RATE_192000,\t \n};\n\nstatic unsigned int hdmi_get_eld_data(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t\tint byte_index)\n{\n\tunsigned int val;\n\n\tval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\tAC_VERB_GET_HDMI_ELDD, byte_index);\n#ifdef BE_PARANOID\n\tcodec_info(codec, \"HDMI: ELD data byte %d: 0x%x\\n\", byte_index, val);\n#endif\n\treturn val;\n}\n\n#define GRAB_BITS(buf, byte, lowbit, bits) \t\t\\\n({\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(lowbit > 7);\t\t\t\\\n\tBUILD_BUG_ON(bits > 8);\t\t\t\t\\\n\tBUILD_BUG_ON(bits <= 0);\t\t\t\\\n\t\t\t\t\t\t\t\\\n\t(buf[byte] >> (lowbit)) & ((1 << (bits)) - 1);\t\\\n})\n\nstatic void hdmi_update_short_audio_desc(struct hda_codec *codec,\n\t\t\t\t\t struct cea_sad *a,\n\t\t\t\t\t const unsigned char *buf)\n{\n\tint i;\n\tint val;\n\n\tval = GRAB_BITS(buf, 1, 0, 7);\n\ta->rates = 0;\n\tfor (i = 0; i < 7; i++)\n\t\tif (val & (1 << i))\n\t\t\ta->rates |= cea_sampling_frequencies[i + 1];\n\n\ta->channels = GRAB_BITS(buf, 0, 0, 3);\n\ta->channels++;\n\n\ta->sample_bits = 0;\n\ta->max_bitrate = 0;\n\n\ta->format = GRAB_BITS(buf, 0, 3, 4);\n\tswitch (a->format) {\n\tcase AUDIO_CODING_TYPE_REF_STREAM_HEADER:\n\t\tcodec_info(codec, \"HDMI: audio coding type 0 not expected\\n\");\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_LPCM:\n\t\tval = GRAB_BITS(buf, 2, 0, 3);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tif (val & (1 << i))\n\t\t\t\ta->sample_bits |= cea_sample_sizes[i + 1];\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_AC3:\n\tcase AUDIO_CODING_TYPE_MPEG1:\n\tcase AUDIO_CODING_TYPE_MP3:\n\tcase AUDIO_CODING_TYPE_MPEG2:\n\tcase AUDIO_CODING_TYPE_AACLC:\n\tcase AUDIO_CODING_TYPE_DTS:\n\tcase AUDIO_CODING_TYPE_ATRAC:\n\t\ta->max_bitrate = GRAB_BITS(buf, 2, 0, 8);\n\t\ta->max_bitrate *= 8000;\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_SACD:\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_EAC3:\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_DTS_HD:\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_MLP:\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_DST:\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_WMAPRO:\n\t\ta->profile = GRAB_BITS(buf, 2, 0, 3);\n\t\tbreak;\n\n\tcase AUDIO_CODING_TYPE_REF_CXT:\n\t\ta->format = GRAB_BITS(buf, 2, 3, 5);\n\t\tif (a->format == AUDIO_CODING_XTYPE_HE_REF_CT ||\n\t\t    a->format >= AUDIO_CODING_XTYPE_FIRST_RESERVED) {\n\t\t\tcodec_info(codec,\n\t\t\t\t   \"HDMI: audio coding xtype %d not expected\\n\",\n\t\t\t\t   a->format);\n\t\t\ta->format = 0;\n\t\t} else\n\t\t\ta->format += AUDIO_CODING_TYPE_HE_AAC -\n\t\t\t\t     AUDIO_CODING_XTYPE_HE_AAC;\n\t\tbreak;\n\t}\n}\n\n \nint snd_hdmi_parse_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e,\n\t\t\t  const unsigned char *buf, int size)\n{\n\tint mnl;\n\tint i;\n\n\tmemset(e, 0, sizeof(*e));\n\te->eld_ver = GRAB_BITS(buf, 0, 3, 5);\n\tif (e->eld_ver != ELD_VER_CEA_861D &&\n\t    e->eld_ver != ELD_VER_PARTIAL) {\n\t\tcodec_info(codec, \"HDMI: Unknown ELD version %d\\n\", e->eld_ver);\n\t\tgoto out_fail;\n\t}\n\n\te->baseline_len = GRAB_BITS(buf, 2, 0, 8);\n\tmnl\t\t= GRAB_BITS(buf, 4, 0, 5);\n\te->cea_edid_ver\t= GRAB_BITS(buf, 4, 5, 3);\n\n\te->support_hdcp\t= GRAB_BITS(buf, 5, 0, 1);\n\te->support_ai\t= GRAB_BITS(buf, 5, 1, 1);\n\te->conn_type\t= GRAB_BITS(buf, 5, 2, 2);\n\te->sad_count\t= GRAB_BITS(buf, 5, 4, 4);\n\n\te->aud_synch_delay = GRAB_BITS(buf, 6, 0, 8) * 2;\n\te->spk_alloc\t= GRAB_BITS(buf, 7, 0, 7);\n\n\te->port_id\t  = get_unaligned_le64(buf + 8);\n\n\t \n\te->manufacture_id = get_unaligned_le16(buf + 16);\n\te->product_id\t  = get_unaligned_le16(buf + 18);\n\n\tif (mnl > ELD_MAX_MNL) {\n\t\tcodec_info(codec, \"HDMI: MNL is reserved value %d\\n\", mnl);\n\t\tgoto out_fail;\n\t} else if (ELD_FIXED_BYTES + mnl > size) {\n\t\tcodec_info(codec, \"HDMI: out of range MNL %d\\n\", mnl);\n\t\tgoto out_fail;\n\t} else\n\t\tstrscpy(e->monitor_name, buf + ELD_FIXED_BYTES, mnl + 1);\n\n\tfor (i = 0; i < e->sad_count; i++) {\n\t\tif (ELD_FIXED_BYTES + mnl + 3 * (i + 1) > size) {\n\t\t\tcodec_info(codec, \"HDMI: out of range SAD %d\\n\", i);\n\t\t\tgoto out_fail;\n\t\t}\n\t\thdmi_update_short_audio_desc(codec, e->sad + i,\n\t\t\t\t\tbuf + ELD_FIXED_BYTES + mnl + 3 * i);\n\t}\n\n\t \n\tif (!e->spk_alloc)\n\t\te->spk_alloc = 0xffff;\n\n\treturn 0;\n\nout_fail:\n\treturn -EINVAL;\n}\n\nint snd_hdmi_get_eld_size(struct hda_codec *codec, hda_nid_t nid)\n{\n\treturn snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_HDMI_DIP_SIZE,\n\t\t\t\t\t\t AC_DIPSIZE_ELD_BUF);\n}\n\nint snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,\n\t\t     unsigned char *buf, int *eld_size)\n{\n\tint i;\n\tint ret = 0;\n\tint size;\n\n\t \n\n\tsize = snd_hdmi_get_eld_size(codec, nid);\n\tif (size == 0) {\n\t\t \n\t\tcodec_info(codec, \"HDMI: ELD buf size is 0, force 128\\n\");\n\t\tsize = 128;\n\t}\n\tif (size < ELD_FIXED_BYTES || size > ELD_MAX_SIZE) {\n\t\tcodec_info(codec, \"HDMI: invalid ELD buf size %d\\n\", size);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\tunsigned int val = hdmi_get_eld_data(codec, nid, i);\n\t\t \n\t\tif (!(val & AC_ELDD_ELD_VALID)) {\n\t\t\tcodec_info(codec, \"HDMI: invalid ELD data byte %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tval &= AC_ELDD_ELD_DATA;\n\t\t \n\t\tif (!val && !i) {\n\t\t\tcodec_dbg(codec, \"HDMI: 0 ELD data\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tbuf[i] = val;\n\t}\n\n\t*eld_size = size;\nerror:\n\treturn ret;\n}\n\n \nstatic void hdmi_print_pcm_rates(int pcm, char *buf, int buflen)\n{\n\tstatic const unsigned int alsa_rates[] = {\n\t\t5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000,\n\t\t88200, 96000, 176400, 192000, 384000\n\t};\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(alsa_rates); i++)\n\t\tif (pcm & (1 << i))\n\t\t\tj += scnprintf(buf + j, buflen - j,  \" %d\",\n\t\t\t\talsa_rates[i]);\n\n\tbuf[j] = '\\0';  \n}\n\n#define SND_PRINT_RATES_ADVISED_BUFSIZE\t80\n\nstatic void hdmi_show_short_audio_desc(struct hda_codec *codec,\n\t\t\t\t       struct cea_sad *a)\n{\n\tchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\n\tchar buf2[8 + SND_PRINT_BITS_ADVISED_BUFSIZE] = \", bits =\";\n\n\tif (!a->format)\n\t\treturn;\n\n\thdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\n\n\tif (a->format == AUDIO_CODING_TYPE_LPCM)\n\t\tsnd_print_pcm_bits(a->sample_bits, buf2 + 8, sizeof(buf2) - 8);\n\telse if (a->max_bitrate)\n\t\tsnprintf(buf2, sizeof(buf2),\n\t\t\t\t\", max bitrate = %d\", a->max_bitrate);\n\telse\n\t\tbuf2[0] = '\\0';\n\n\tcodec_dbg(codec,\n\t\t  \"HDMI: supports coding type %s: channels = %d, rates =%s%s\\n\",\n\t\t  cea_audio_coding_type_names[a->format],\n\t\t  a->channels, buf, buf2);\n}\n\nvoid snd_hdmi_show_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e)\n{\n\tint i;\n\n\tcodec_dbg(codec, \"HDMI: detected monitor %s at connection type %s\\n\",\n\t\t\te->monitor_name,\n\t\t\teld_connection_type_names[e->conn_type]);\n\n\tif (e->spk_alloc) {\n\t\tchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\n\t\tsnd_hdac_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\n\t\tcodec_dbg(codec, \"HDMI: available speakers:%s\\n\", buf);\n\t}\n\n\tfor (i = 0; i < e->sad_count; i++)\n\t\thdmi_show_short_audio_desc(codec, e->sad + i);\n}\n\n#ifdef CONFIG_SND_PROC_FS\n\nstatic void hdmi_print_sad_info(int i, struct cea_sad *a,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\n\n\tsnd_iprintf(buffer, \"sad%d_coding_type\\t[0x%x] %s\\n\",\n\t\t\ti, a->format, cea_audio_coding_type_names[a->format]);\n\tsnd_iprintf(buffer, \"sad%d_channels\\t\\t%d\\n\", i, a->channels);\n\n\thdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\n\tsnd_iprintf(buffer, \"sad%d_rates\\t\\t[0x%x]%s\\n\", i, a->rates, buf);\n\n\tif (a->format == AUDIO_CODING_TYPE_LPCM) {\n\t\tsnd_print_pcm_bits(a->sample_bits, buf, sizeof(buf));\n\t\tsnd_iprintf(buffer, \"sad%d_bits\\t\\t[0x%x]%s\\n\",\n\t\t\t\t\t\t\ti, a->sample_bits, buf);\n\t}\n\n\tif (a->max_bitrate)\n\t\tsnd_iprintf(buffer, \"sad%d_max_bitrate\\t%d\\n\",\n\t\t\t\t\t\t\ti, a->max_bitrate);\n\n\tif (a->profile)\n\t\tsnd_iprintf(buffer, \"sad%d_profile\\t\\t%d\\n\", i, a->profile);\n}\n\nvoid snd_hdmi_print_eld_info(struct hdmi_eld *eld,\n\t\t\t     struct snd_info_buffer *buffer,\n\t\t\t     hda_nid_t pin_nid, int dev_id, hda_nid_t cvt_nid)\n{\n\tstruct parsed_hdmi_eld *e = &eld->info;\n\tchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\n\tint i;\n\tstatic const char * const eld_version_names[32] = {\n\t\t\"reserved\",\n\t\t\"reserved\",\n\t\t\"CEA-861D or below\",\n\t\t[3 ... 30] = \"reserved\",\n\t\t[31] = \"partial\"\n\t};\n\tstatic const char * const cea_edid_version_names[8] = {\n\t\t\"no CEA EDID Timing Extension block present\",\n\t\t\"CEA-861\",\n\t\t\"CEA-861-A\",\n\t\t\"CEA-861-B, C or D\",\n\t\t[4 ... 7] = \"reserved\"\n\t};\n\n\tsnd_iprintf(buffer, \"monitor_present\\t\\t%d\\n\", eld->monitor_present);\n\tsnd_iprintf(buffer, \"eld_valid\\t\\t%d\\n\", eld->eld_valid);\n\tsnd_iprintf(buffer, \"codec_pin_nid\\t\\t0x%x\\n\", pin_nid);\n\tsnd_iprintf(buffer, \"codec_dev_id\\t\\t0x%x\\n\", dev_id);\n\tsnd_iprintf(buffer, \"codec_cvt_nid\\t\\t0x%x\\n\", cvt_nid);\n\tif (!eld->eld_valid)\n\t\treturn;\n\tsnd_iprintf(buffer, \"monitor_name\\t\\t%s\\n\", e->monitor_name);\n\tsnd_iprintf(buffer, \"connection_type\\t\\t%s\\n\",\n\t\t\t\teld_connection_type_names[e->conn_type]);\n\tsnd_iprintf(buffer, \"eld_version\\t\\t[0x%x] %s\\n\", e->eld_ver,\n\t\t\t\t\teld_version_names[e->eld_ver]);\n\tsnd_iprintf(buffer, \"edid_version\\t\\t[0x%x] %s\\n\", e->cea_edid_ver,\n\t\t\t\tcea_edid_version_names[e->cea_edid_ver]);\n\tsnd_iprintf(buffer, \"manufacture_id\\t\\t0x%x\\n\", e->manufacture_id);\n\tsnd_iprintf(buffer, \"product_id\\t\\t0x%x\\n\", e->product_id);\n\tsnd_iprintf(buffer, \"port_id\\t\\t\\t0x%llx\\n\", (long long)e->port_id);\n\tsnd_iprintf(buffer, \"support_hdcp\\t\\t%d\\n\", e->support_hdcp);\n\tsnd_iprintf(buffer, \"support_ai\\t\\t%d\\n\", e->support_ai);\n\tsnd_iprintf(buffer, \"audio_sync_delay\\t%d\\n\", e->aud_synch_delay);\n\n\tsnd_hdac_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\n\tsnd_iprintf(buffer, \"speakers\\t\\t[0x%x]%s\\n\", e->spk_alloc, buf);\n\n\tsnd_iprintf(buffer, \"sad_count\\t\\t%d\\n\", e->sad_count);\n\n\tfor (i = 0; i < e->sad_count; i++)\n\t\thdmi_print_sad_info(i, e->sad + i, buffer);\n}\n\nvoid snd_hdmi_write_eld_info(struct hdmi_eld *eld,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct parsed_hdmi_eld *e = &eld->info;\n\tchar line[64];\n\tchar name[64];\n\tchar *sname;\n\tlong long val;\n\tunsigned int n;\n\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%s %llx\", name, &val) != 2)\n\t\t\tcontinue;\n\t\t \n\t\tif (!strcmp(name, \"monitor_present\"))\n\t\t\teld->monitor_present = val;\n\t\telse if (!strcmp(name, \"eld_valid\"))\n\t\t\teld->eld_valid = val;\n\t\telse if (!strcmp(name, \"connection_type\"))\n\t\t\te->conn_type = val;\n\t\telse if (!strcmp(name, \"port_id\"))\n\t\t\te->port_id = val;\n\t\telse if (!strcmp(name, \"support_hdcp\"))\n\t\t\te->support_hdcp = val;\n\t\telse if (!strcmp(name, \"support_ai\"))\n\t\t\te->support_ai = val;\n\t\telse if (!strcmp(name, \"audio_sync_delay\"))\n\t\t\te->aud_synch_delay = val;\n\t\telse if (!strcmp(name, \"speakers\"))\n\t\t\te->spk_alloc = val;\n\t\telse if (!strcmp(name, \"sad_count\"))\n\t\t\te->sad_count = val;\n\t\telse if (!strncmp(name, \"sad\", 3)) {\n\t\t\tsname = name + 4;\n\t\t\tn = name[3] - '0';\n\t\t\tif (name[4] >= '0' && name[4] <= '9') {\n\t\t\t\tsname++;\n\t\t\t\tn = 10 * n + name[4] - '0';\n\t\t\t}\n\t\t\tif (n >= ELD_MAX_SAD)\n\t\t\t\tcontinue;\n\t\t\tif (!strcmp(sname, \"_coding_type\"))\n\t\t\t\te->sad[n].format = val;\n\t\t\telse if (!strcmp(sname, \"_channels\"))\n\t\t\t\te->sad[n].channels = val;\n\t\t\telse if (!strcmp(sname, \"_rates\"))\n\t\t\t\te->sad[n].rates = val;\n\t\t\telse if (!strcmp(sname, \"_bits\"))\n\t\t\t\te->sad[n].sample_bits = val;\n\t\t\telse if (!strcmp(sname, \"_max_bitrate\"))\n\t\t\t\te->sad[n].max_bitrate = val;\n\t\t\telse if (!strcmp(sname, \"_profile\"))\n\t\t\t\te->sad[n].profile = val;\n\t\t\tif (n >= e->sad_count)\n\t\t\t\te->sad_count = n + 1;\n\t\t}\n\t}\n}\n#endif  \n\n \nvoid snd_hdmi_eld_update_pcm_info(struct parsed_hdmi_eld *e,\n\t\t\t      struct hda_pcm_stream *hinfo)\n{\n\tu32 rates;\n\tu64 formats;\n\tunsigned int maxbps;\n\tunsigned int channels_max;\n\tint i;\n\n\t \n\trates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000;\n\tformats = SNDRV_PCM_FMTBIT_S16_LE;\n\tmaxbps = 16;\n\tchannels_max = 2;\n\tfor (i = 0; i < e->sad_count; i++) {\n\t\tstruct cea_sad *a = &e->sad[i];\n\t\trates |= a->rates;\n\t\tif (a->channels > channels_max)\n\t\t\tchannels_max = a->channels;\n\t\tif (a->format == AUDIO_CODING_TYPE_LPCM) {\n\t\t\tif (a->sample_bits & AC_SUPPCM_BITS_20) {\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\t\tif (maxbps < 20)\n\t\t\t\t\tmaxbps = 20;\n\t\t\t}\n\t\t\tif (a->sample_bits & AC_SUPPCM_BITS_24) {\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\t\tif (maxbps < 24)\n\t\t\t\t\tmaxbps = 24;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thinfo->rates &= rates;\n\thinfo->formats &= formats;\n\thinfo->maxbps = min(hinfo->maxbps, maxbps);\n\thinfo->channels_max = min(hinfo->channels_max, channels_max);\n}\n\n\n \n\n#define ATI_VERB_SET_AUDIO_DESCRIPTOR\t0x776\n#define ATI_VERB_SET_SINK_INFO_INDEX\t0x780\n#define ATI_VERB_GET_SPEAKER_ALLOCATION\t0xf70\n#define ATI_VERB_GET_AUDIO_DESCRIPTOR\t0xf76\n#define ATI_VERB_GET_AUDIO_VIDEO_DELAY\t0xf7b\n#define ATI_VERB_GET_SINK_INFO_INDEX\t0xf80\n#define ATI_VERB_GET_SINK_INFO_DATA\t0xf81\n\n#define ATI_SPKALLOC_SPKALLOC\t\t0x007f\n#define ATI_SPKALLOC_TYPE_HDMI\t\t0x0100\n#define ATI_SPKALLOC_TYPE_DISPLAYPORT\t0x0200\n\n \n#define ATI_AUDIODESC_CHANNELS\t\t0x00000007\n#define ATI_AUDIODESC_RATES\t\t0x0000ff00\n#define ATI_AUDIODESC_LPCM_STEREO_RATES\t0xff000000\n\n \n#define ATI_DELAY_VIDEO_LATENCY\t\t0x000000ff\n#define ATI_DELAY_AUDIO_LATENCY\t\t0x0000ff00\n\nenum ati_sink_info_idx {\n\tATI_INFO_IDX_MANUFACTURER_ID\t= 0,\n\tATI_INFO_IDX_PRODUCT_ID\t\t= 1,\n\tATI_INFO_IDX_SINK_DESC_LEN\t= 2,\n\tATI_INFO_IDX_PORT_ID_LOW\t= 3,\n\tATI_INFO_IDX_PORT_ID_HIGH\t= 4,\n\tATI_INFO_IDX_SINK_DESC_FIRST\t= 5,\n\tATI_INFO_IDX_SINK_DESC_LAST\t= 22,  \n};\n\nint snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t unsigned char *buf, int *eld_size, bool rev3_or_later)\n{\n\tint spkalloc, ati_sad, aud_synch;\n\tint sink_desc_len = 0;\n\tint pos, i;\n\n\t \n\n\tspkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);\n\n\tif (spkalloc <= 0) {\n\t\tcodec_info(codec, \"HDMI ATI/AMD: no speaker allocation for ELD\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(buf, 0, ELD_FIXED_BYTES + ELD_MAX_MNL + ELD_MAX_SAD * 3);\n\n\t \n\tbuf[0] = ELD_VER_CEA_861D << 3;\n\n\t \n\tbuf[7] = spkalloc & ATI_SPKALLOC_SPKALLOC;\n\n\t \n\tif (spkalloc & ATI_SPKALLOC_TYPE_DISPLAYPORT)\n\t\tbuf[5] |= 0x04;\n\n\tpos = ELD_FIXED_BYTES;\n\n\tif (rev3_or_later) {\n\t\tint sink_info;\n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_LOW);\n\t\tsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\t\tput_unaligned_le32(sink_info, buf + 8);\n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PORT_ID_HIGH);\n\t\tsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\t\tput_unaligned_le32(sink_info, buf + 12);\n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_MANUFACTURER_ID);\n\t\tsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\t\tput_unaligned_le16(sink_info, buf + 16);\n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_PRODUCT_ID);\n\t\tsink_info = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\t\tput_unaligned_le16(sink_info, buf + 18);\n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_LEN);\n\t\tsink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\n\t\tif (sink_desc_len > ELD_MAX_MNL) {\n\t\t\tcodec_info(codec, \"HDMI ATI/AMD: Truncating HDMI sink description with length %d\\n\",\n\t\t\t\t   sink_desc_len);\n\t\t\tsink_desc_len = ELD_MAX_MNL;\n\t\t}\n\n\t\tbuf[4] |= sink_desc_len;\n\n\t\tfor (i = 0; i < sink_desc_len; i++) {\n\t\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_SINK_INFO_INDEX, ATI_INFO_IDX_SINK_DESC_FIRST + i);\n\t\t\tbuf[pos++] = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);\n\t\t}\n\t}\n\n\tfor (i = AUDIO_CODING_TYPE_LPCM; i <= AUDIO_CODING_TYPE_WMAPRO; i++) {\n\t\tif (i == AUDIO_CODING_TYPE_SACD || i == AUDIO_CODING_TYPE_DST)\n\t\t\tcontinue;  \n\n\t\tsnd_hda_codec_write(codec, nid, 0, ATI_VERB_SET_AUDIO_DESCRIPTOR, i << 3);\n\t\tati_sad = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_DESCRIPTOR, 0);\n\n\t\tif (ati_sad <= 0)\n\t\t\tcontinue;\n\n\t\tif (ati_sad & ATI_AUDIODESC_RATES) {\n\t\t\t \n\t\t\tbuf[pos++] = (ati_sad & 0x0000ff) >> 0;\n\t\t\tbuf[pos++] = (ati_sad & 0x00ff00) >> 8;\n\t\t\tbuf[pos++] = (ati_sad & 0xff0000) >> 16;\n\t\t}\n\n\t\tif (i == AUDIO_CODING_TYPE_LPCM\n\t\t    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES)\n\t\t    && (ati_sad & ATI_AUDIODESC_LPCM_STEREO_RATES) >> 16 != (ati_sad & ATI_AUDIODESC_RATES)) {\n\t\t\t \n\t\t\tbuf[pos++] = ((ati_sad & 0x000000ff) & ~ATI_AUDIODESC_CHANNELS) | 0x1;\n\t\t\t \n\t\t\tbuf[pos++] = (ati_sad & 0xff000000) >> 24;\n\t\t\tbuf[pos++] = (ati_sad & 0x00ff0000) >> 16;\n\t\t}\n\t}\n\n\tif (pos == ELD_FIXED_BYTES + sink_desc_len) {\n\t\tcodec_info(codec, \"HDMI ATI/AMD: no audio descriptors for ELD\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taud_synch = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_AUDIO_VIDEO_DELAY, 0);\n\tif ((aud_synch & ATI_DELAY_VIDEO_LATENCY) && (aud_synch & ATI_DELAY_AUDIO_LATENCY)) {\n\t\tint video_latency_hdmi = (aud_synch & ATI_DELAY_VIDEO_LATENCY);\n\t\tint audio_latency_hdmi = (aud_synch & ATI_DELAY_AUDIO_LATENCY) >> 8;\n\n\t\tif (video_latency_hdmi <= 0xfb && audio_latency_hdmi <= 0xfb &&\n\t\t    video_latency_hdmi > audio_latency_hdmi)\n\t\t\tbuf[6] = video_latency_hdmi - audio_latency_hdmi;\n\t\t \n\t}\n\n\t \n\tbuf[5] |= ((pos - ELD_FIXED_BYTES - sink_desc_len) / 3) << 4;\n\n\t \n\tpos = round_up(pos, 4);\n\n\t \n\tbuf[2] = (pos - 4) / 4;\n\n\t*eld_size = pos;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}