{
  "module_name": "patch_analog.c",
  "hash_id": "868b7226443a8666bffdf0c5382f12dbc88703f4d913b59f28aa41f2925deca3",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_analog.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_beep.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n\n\nstruct ad198x_spec {\n\tstruct hda_gen_spec gen;\n\n\t \n\tint smux_paths[4];\n\tunsigned int cur_smux;\n\thda_nid_t eapd_nid;\n\n\tunsigned int beep_amp;\t \n\tint num_smux_conns;\n};\n\n\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\n \nstatic const struct snd_kcontrol_new ad_beep_mixer[] = {\n\tHDA_CODEC_VOLUME(\"Beep Playback Volume\", 0, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_BEEP(\"Beep Playback Switch\", 0, 0, HDA_OUTPUT),\n\t{ }  \n};\n\n#define set_beep_amp(spec, nid, idx, dir) \\\n\t((spec)->beep_amp = HDA_COMPOSE_AMP_VAL(nid, 1, idx, dir))  \n#else\n#define set_beep_amp(spec, nid, idx, dir)  \n#endif\n\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\nstatic int create_beep_ctls(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\tconst struct snd_kcontrol_new *knew;\n\n\tif (!spec->beep_amp)\n\t\treturn 0;\n\n\tfor (knew = ad_beep_mixer ; knew->name; knew++) {\n\t\tint err;\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(knew, codec);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tkctl->private_value = spec->beep_amp;\n\t\terr = snd_hda_ctl_add(codec, 0, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n#else\n#define create_beep_ctls(codec)\t\t0\n#endif\n\n#ifdef CONFIG_PM\nstatic void ad198x_power_eapd_write(struct hda_codec *codec, hda_nid_t front,\n\t\t\t\thda_nid_t hp)\n{\n\tif (snd_hda_query_pin_caps(codec, front) & AC_PINCAP_EAPD)\n\t\tsnd_hda_codec_write(codec, front, 0, AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t    !codec->inv_eapd ? 0x00 : 0x02);\n\tif (snd_hda_query_pin_caps(codec, hp) & AC_PINCAP_EAPD)\n\t\tsnd_hda_codec_write(codec, hp, 0, AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t    !codec->inv_eapd ? 0x00 : 0x02);\n}\n\nstatic void ad198x_power_eapd(struct hda_codec *codec)\n{\n\t \n\tswitch (codec->core.vendor_id) {\n\tcase 0x11d41882:\n\tcase 0x11d4882a:\n\tcase 0x11d41884:\n\tcase 0x11d41984:\n\tcase 0x11d41883:\n\tcase 0x11d4184a:\n\tcase 0x11d4194a:\n\tcase 0x11d4194b:\n\tcase 0x11d41988:\n\tcase 0x11d4198b:\n\tcase 0x11d4989a:\n\tcase 0x11d4989b:\n\t\tad198x_power_eapd_write(codec, 0x12, 0x11);\n\t\tbreak;\n\tcase 0x11d41981:\n\tcase 0x11d41983:\n\t\tad198x_power_eapd_write(codec, 0x05, 0x06);\n\t\tbreak;\n\tcase 0x11d41986:\n\t\tad198x_power_eapd_write(codec, 0x1b, 0x1a);\n\t\tbreak;\n\t}\n}\n\nstatic int ad198x_suspend(struct hda_codec *codec)\n{\n\tsnd_hda_shutup_pins(codec);\n\tad198x_power_eapd(codec);\n\treturn 0;\n}\n#endif\n\n \nstatic void ad_vmaster_eapd_hook(void *private_data, int enabled)\n{\n\tstruct hda_codec *codec = private_data;\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (!spec->eapd_nid)\n\t\treturn;\n\tif (codec->inv_eapd)\n\t\tenabled = !enabled;\n\tsnd_hda_codec_write_cache(codec, spec->eapd_nid, 0,\n\t\t\t\t   AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t\t   enabled ? 0x02 : 0x00);\n}\n\n \n\nstatic int ad198x_auto_build_controls(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = snd_hda_gen_build_controls(codec);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_beep_ctls(codec);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic const struct hda_codec_ops ad198x_auto_patch_ops = {\n\t.build_controls = ad198x_auto_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = snd_hda_gen_init,\n\t.free = snd_hda_gen_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.check_power_status = snd_hda_gen_check_power_status,\n\t.suspend = ad198x_suspend,\n#endif\n};\n\n\nstatic int ad198x_parse_auto_config(struct hda_codec *codec, bool indep_hp)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\tstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\n\tint err;\n\n\tcodec->spdif_status_reset = 1;\n\tcodec->no_trigger_sense = 1;\n\tcodec->no_sticky_stream = 1;\n\n\tspec->gen.indep_hp = indep_hp;\n\tif (!spec->gen.add_stereo_mix_input)\n\t\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\n\n\terr = snd_hda_parse_pin_defcfg(codec, cfg, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_hda_gen_parse_auto_config(codec, cfg);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic int alloc_ad_spec(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tcodec->spec = spec;\n\tsnd_hda_gen_spec_init(&spec->gen);\n\tcodec->patch_ops = ad198x_auto_patch_ops;\n\treturn 0;\n}\n\n \n\n \nstatic void ad_fixup_inv_jack_detect(struct hda_codec *codec,\n\t\t\t\t     const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tcodec->inv_jack_detect = 1;\n\t\tspec->gen.keep_eapd_on = 1;\n\t\tspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\n\t\tspec->eapd_nid = 0x1b;\n\t}\n}\n\n \nstatic void ad1986a_fixup_eapd(struct hda_codec *codec,\n\t\t\t       const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tcodec->inv_eapd = 0;\n\t\tspec->gen.keep_eapd_on = 1;\n\t\tspec->eapd_nid = 0x1b;\n\t}\n}\n\n \nstatic void ad1986a_fixup_eapd_mix_in(struct hda_codec *codec,\n\t\t\t\t      const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tad1986a_fixup_eapd(codec, fix, action);\n\t\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_ENABLE;\n\t}\n}\n\nenum {\n\tAD1986A_FIXUP_INV_JACK_DETECT,\n\tAD1986A_FIXUP_ULTRA,\n\tAD1986A_FIXUP_SAMSUNG,\n\tAD1986A_FIXUP_3STACK,\n\tAD1986A_FIXUP_LAPTOP,\n\tAD1986A_FIXUP_LAPTOP_IMIC,\n\tAD1986A_FIXUP_EAPD,\n\tAD1986A_FIXUP_EAPD_MIX_IN,\n\tAD1986A_FIXUP_EASYNOTE,\n};\n\nstatic const struct hda_fixup ad1986a_fixups[] = {\n\t[AD1986A_FIXUP_INV_JACK_DETECT] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad_fixup_inv_jack_detect,\n\t},\n\t[AD1986A_FIXUP_ULTRA] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1b, 0x90170110 },  \n\t\t\t{ 0x1d, 0x90a7013e },  \n\t\t\t{}\n\t\t},\n\t},\n\t[AD1986A_FIXUP_SAMSUNG] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1b, 0x90170110 },  \n\t\t\t{ 0x1d, 0x90a7013e },  \n\t\t\t{ 0x20, 0x411111f0 },  \n\t\t\t{ 0x24, 0x411111f0 },  \n\t\t\t{}\n\t\t},\n\t},\n\t[AD1986A_FIXUP_3STACK] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1a, 0x02214021 },  \n\t\t\t{ 0x1b, 0x01014011 },  \n\t\t\t{ 0x1c, 0x01813030 },  \n\t\t\t{ 0x1d, 0x01a19020 },  \n\t\t\t{ 0x1e, 0x411111f0 },  \n\t\t\t{ 0x1f, 0x02a190f0 },  \n\t\t\t{ 0x20, 0x411111f0 },  \n\t\t\t{}\n\t\t},\n\t},\n\t[AD1986A_FIXUP_LAPTOP] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1a, 0x02214021 },  \n\t\t\t{ 0x1b, 0x90170110 },  \n\t\t\t{ 0x1c, 0x411111f0 },  \n\t\t\t{ 0x1d, 0x411111f0 },  \n\t\t\t{ 0x1e, 0x411111f0 },  \n\t\t\t{ 0x1f, 0x02a191f0 },  \n\t\t\t{ 0x20, 0x411111f0 },  \n\t\t\t{}\n\t\t},\n\t},\n\t[AD1986A_FIXUP_LAPTOP_IMIC] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1d, 0x90a7013e },  \n\t\t\t{}\n\t\t},\n\t\t.chained_before = 1,\n\t\t.chain_id = AD1986A_FIXUP_LAPTOP,\n\t},\n\t[AD1986A_FIXUP_EAPD] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1986a_fixup_eapd,\n\t},\n\t[AD1986A_FIXUP_EAPD_MIX_IN] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1986a_fixup_eapd_mix_in,\n\t},\n\t[AD1986A_FIXUP_EASYNOTE] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x1a, 0x0421402f },  \n\t\t\t{ 0x1b, 0x90170110 },  \n\t\t\t{ 0x1c, 0x411111f0 },  \n\t\t\t{ 0x1d, 0x90a70130 },  \n\t\t\t{ 0x1e, 0x411111f0 },  \n\t\t\t{ 0x1f, 0x04a19040 },  \n\t\t\t{ 0x20, 0x411111f0 },  \n\t\t\t{ 0x21, 0x411111f0 },  \n\t\t\t{ 0x22, 0x411111f0 },  \n\t\t\t{ 0x23, 0x411111f0 },  \n\t\t\t{ 0x24, 0x411111f0 },  \n\t\t\t{ 0x25, 0x411111f0 },  \n\t\t\t{}\n\t\t},\n\t\t.chained = true,\n\t\t.chain_id = AD1986A_FIXUP_EAPD_MIX_IN,\n\t},\n};\n\nstatic const struct snd_pci_quirk ad1986a_fixup_tbl[] = {\n\tSND_PCI_QUIRK(0x103c, 0x30af, \"HP B2800\", AD1986A_FIXUP_LAPTOP_IMIC),\n\tSND_PCI_QUIRK(0x1043, 0x1153, \"ASUS M9V\", AD1986A_FIXUP_LAPTOP_IMIC),\n\tSND_PCI_QUIRK(0x1043, 0x1443, \"ASUS Z99He\", AD1986A_FIXUP_EAPD),\n\tSND_PCI_QUIRK(0x1043, 0x1447, \"ASUS A8JN\", AD1986A_FIXUP_EAPD),\n\tSND_PCI_QUIRK_MASK(0x1043, 0xff00, 0x8100, \"ASUS P5\", AD1986A_FIXUP_3STACK),\n\tSND_PCI_QUIRK_MASK(0x1043, 0xff00, 0x8200, \"ASUS M2\", AD1986A_FIXUP_3STACK),\n\tSND_PCI_QUIRK(0x10de, 0xcb84, \"ASUS A8N-VM\", AD1986A_FIXUP_3STACK),\n\tSND_PCI_QUIRK(0x1179, 0xff40, \"Toshiba Satellite L40\", AD1986A_FIXUP_EAPD),\n\tSND_PCI_QUIRK(0x144d, 0xc01e, \"FSC V2060\", AD1986A_FIXUP_LAPTOP),\n\tSND_PCI_QUIRK_MASK(0x144d, 0xff00, 0xc000, \"Samsung\", AD1986A_FIXUP_SAMSUNG),\n\tSND_PCI_QUIRK(0x144d, 0xc027, \"Samsung Q1\", AD1986A_FIXUP_ULTRA),\n\tSND_PCI_QUIRK(0x1631, 0xc022, \"PackardBell EasyNote MX65\", AD1986A_FIXUP_EASYNOTE),\n\tSND_PCI_QUIRK(0x17aa, 0x2066, \"Lenovo N100\", AD1986A_FIXUP_INV_JACK_DETECT),\n\tSND_PCI_QUIRK(0x17aa, 0x1011, \"Lenovo M55\", AD1986A_FIXUP_3STACK),\n\tSND_PCI_QUIRK(0x17aa, 0x1017, \"Lenovo A60\", AD1986A_FIXUP_3STACK),\n\t{}\n};\n\nstatic const struct hda_model_fixup ad1986a_fixup_models[] = {\n\t{ .id = AD1986A_FIXUP_3STACK, .name = \"3stack\" },\n\t{ .id = AD1986A_FIXUP_LAPTOP, .name = \"laptop\" },\n\t{ .id = AD1986A_FIXUP_LAPTOP_IMIC, .name = \"laptop-imic\" },\n\t{ .id = AD1986A_FIXUP_LAPTOP_IMIC, .name = \"laptop-eapd\" },  \n\t{ .id = AD1986A_FIXUP_EAPD, .name = \"eapd\" },\n\t{}\n};\n\n \nstatic int patch_ad1986a(struct hda_codec *codec)\n{\n\tint err;\n\tstruct ad198x_spec *spec;\n\tstatic const hda_nid_t preferred_pairs[] = {\n\t\t0x1a, 0x03,\n\t\t0x1b, 0x03,\n\t\t0x1c, 0x04,\n\t\t0x1d, 0x05,\n\t\t0x1e, 0x03,\n\t\t0\n\t};\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\t \n\tcodec->inv_eapd = 1;\n\n\tspec->gen.mixer_nid = 0x07;\n\tspec->gen.beep_nid = 0x19;\n\tset_beep_amp(spec, 0x18, 0, HDA_OUTPUT);\n\n\t \n\tspec->gen.multiout.no_share_stream = 1;\n\t \n\tspec->gen.preferred_dacs = preferred_pairs;\n\n\t \n\tspec->gen.auto_mute_via_amp = 1;\n\n\tsnd_hda_pick_fixup(codec, ad1986a_fixup_models, ad1986a_fixup_tbl,\n\t\t\t   ad1986a_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = ad198x_parse_auto_config(codec, false);\n\tif (err < 0) {\n\t\tsnd_hda_gen_free(codec);\n\t\treturn err;\n\t}\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int ad1983_auto_smux_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\tstatic const char * const texts2[] = { \"PCM\", \"ADC\" };\n\tstatic const char * const texts3[] = { \"PCM\", \"ADC1\", \"ADC2\" };\n\tint num_conns = spec->num_smux_conns;\n\n\tif (num_conns == 2)\n\t\treturn snd_hda_enum_helper_info(kcontrol, uinfo, 2, texts2);\n\telse if (num_conns == 3)\n\t\treturn snd_hda_enum_helper_info(kcontrol, uinfo, 3, texts3);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int ad1983_auto_smux_enum_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->cur_smux;\n\treturn 0;\n}\n\nstatic int ad1983_auto_smux_enum_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\thda_nid_t dig_out = spec->gen.multiout.dig_out_nid;\n\tint num_conns = spec->num_smux_conns;\n\n\tif (val >= num_conns)\n\t\treturn -EINVAL;\n\tif (spec->cur_smux == val)\n\t\treturn 0;\n\tspec->cur_smux = val;\n\tsnd_hda_codec_write_cache(codec, dig_out, 0,\n\t\t\t\t  AC_VERB_SET_CONNECT_SEL, val);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new ad1983_auto_smux_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"IEC958 Playback Source\",\n\t.info = ad1983_auto_smux_enum_info,\n\t.get = ad1983_auto_smux_enum_get,\n\t.put = ad1983_auto_smux_enum_put,\n};\n\nstatic int ad1983_add_spdif_mux_ctl(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\thda_nid_t dig_out = spec->gen.multiout.dig_out_nid;\n\tint num_conns;\n\n\tif (!dig_out)\n\t\treturn 0;\n\tnum_conns = snd_hda_get_num_conns(codec, dig_out);\n\tif (num_conns != 2 && num_conns != 3)\n\t\treturn 0;\n\tspec->num_smux_conns = num_conns;\n\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &ad1983_auto_smux_mixer))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int patch_ad1983(struct hda_codec *codec)\n{\n\tstatic const hda_nid_t conn_0c[] = { 0x08 };\n\tstatic const hda_nid_t conn_0d[] = { 0x09 };\n\tstruct ad198x_spec *spec;\n\tint err;\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\tspec->gen.mixer_nid = 0x0e;\n\tspec->gen.beep_nid = 0x10;\n\tset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\n\n\t \n\tsnd_hda_override_conn_list(codec, 0x0c, ARRAY_SIZE(conn_0c), conn_0c);\n\tsnd_hda_override_conn_list(codec, 0x0d, ARRAY_SIZE(conn_0d), conn_0d);\n\n\terr = ad198x_parse_auto_config(codec, false);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ad1983_add_spdif_mux_ctl(codec);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\n\n \n\nstatic void ad1981_fixup_hp_eapd(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\n\t\tspec->eapd_nid = 0x05;\n\t}\n}\n\n \nstatic void ad1981_fixup_amp_override(struct hda_codec *codec,\n\t\t\t\t      const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tsnd_hda_override_amp_caps(codec, 0x11, HDA_INPUT,\n\t\t\t\t\t  (0x17 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t\t  (0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t\t  (0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t\t  (1 << AC_AMPCAP_MUTE_SHIFT));\n}\n\nenum {\n\tAD1981_FIXUP_AMP_OVERRIDE,\n\tAD1981_FIXUP_HP_EAPD,\n};\n\nstatic const struct hda_fixup ad1981_fixups[] = {\n\t[AD1981_FIXUP_AMP_OVERRIDE] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1981_fixup_amp_override,\n\t},\n\t[AD1981_FIXUP_HP_EAPD] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1981_fixup_hp_eapd,\n\t\t.chained = true,\n\t\t.chain_id = AD1981_FIXUP_AMP_OVERRIDE,\n\t},\n};\n\nstatic const struct snd_pci_quirk ad1981_fixup_tbl[] = {\n\tSND_PCI_QUIRK_VENDOR(0x1014, \"Lenovo\", AD1981_FIXUP_AMP_OVERRIDE),\n\tSND_PCI_QUIRK_VENDOR(0x103c, \"HP\", AD1981_FIXUP_HP_EAPD),\n\tSND_PCI_QUIRK_VENDOR(0x17aa, \"Lenovo\", AD1981_FIXUP_AMP_OVERRIDE),\n\t \n\tSND_PCI_QUIRK(0x30b0, 0x103c, \"HP nx6320\", AD1981_FIXUP_HP_EAPD),\n\t{}\n};\n\nstatic int patch_ad1981(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec;\n\tint err;\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn -ENOMEM;\n\tspec = codec->spec;\n\n\tspec->gen.mixer_nid = 0x0e;\n\tspec->gen.beep_nid = 0x10;\n\tset_beep_amp(spec, 0x0d, 0, HDA_OUTPUT);\n\n\tsnd_hda_pick_fixup(codec, NULL, ad1981_fixup_tbl, ad1981_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = ad198x_parse_auto_config(codec, false);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ad1983_add_spdif_mux_ctl(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\n\n \n\nstatic int ad1988_auto_smux_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\tstatic const char * const texts[] = {\n\t\t\"PCM\", \"ADC1\", \"ADC2\", \"ADC3\",\n\t};\n\tint num_conns = spec->num_smux_conns;\n\n\tif (num_conns > 4)\n\t\tnum_conns = 4;\n\treturn snd_hda_enum_helper_info(kcontrol, uinfo, num_conns, texts);\n}\n\nstatic int ad1988_auto_smux_enum_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->cur_smux;\n\treturn 0;\n}\n\nstatic int ad1988_auto_smux_enum_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct ad198x_spec *spec = codec->spec;\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\tstruct nid_path *path;\n\tint num_conns = spec->num_smux_conns;\n\n\tif (val >= num_conns)\n\t\treturn -EINVAL;\n\tif (spec->cur_smux == val)\n\t\treturn 0;\n\n\tmutex_lock(&codec->control_mutex);\n\tpath = snd_hda_get_path_from_idx(codec,\n\t\t\t\t\t spec->smux_paths[spec->cur_smux]);\n\tif (path)\n\t\tsnd_hda_activate_path(codec, path, false, true);\n\tpath = snd_hda_get_path_from_idx(codec, spec->smux_paths[val]);\n\tif (path)\n\t\tsnd_hda_activate_path(codec, path, true, true);\n\tspec->cur_smux = val;\n\tmutex_unlock(&codec->control_mutex);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new ad1988_auto_smux_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"IEC958 Playback Source\",\n\t.info = ad1988_auto_smux_enum_info,\n\t.get = ad1988_auto_smux_enum_get,\n\t.put = ad1988_auto_smux_enum_put,\n};\n\nstatic int ad1988_auto_init(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\tint i, err;\n\n\terr = snd_hda_gen_init(codec);\n\tif (err < 0)\n\t\treturn err;\n\tif (!spec->gen.autocfg.dig_outs)\n\t\treturn 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct nid_path *path;\n\t\tpath = snd_hda_get_path_from_idx(codec, spec->smux_paths[i]);\n\t\tif (path)\n\t\t\tsnd_hda_activate_path(codec, path, path->active, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int ad1988_add_spdif_mux_ctl(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\tint i, num_conns;\n\t \n\tstatic const struct nid_path fake_paths[4] = {\n\t\t{\n\t\t\t.depth = 3,\n\t\t\t.path = { 0x02, 0x1d, 0x1b },\n\t\t\t.idx = { 0, 0, 0 },\n\t\t\t.multi = { 0, 0, 0 },\n\t\t},\n\t\t{\n\t\t\t.depth = 4,\n\t\t\t.path = { 0x08, 0x0b, 0x1d, 0x1b },\n\t\t\t.idx = { 0, 0, 1, 0 },\n\t\t\t.multi = { 0, 1, 0, 0 },\n\t\t},\n\t\t{\n\t\t\t.depth = 4,\n\t\t\t.path = { 0x09, 0x0b, 0x1d, 0x1b },\n\t\t\t.idx = { 0, 1, 1, 0 },\n\t\t\t.multi = { 0, 1, 0, 0 },\n\t\t},\n\t\t{\n\t\t\t.depth = 4,\n\t\t\t.path = { 0x0f, 0x0b, 0x1d, 0x1b },\n\t\t\t.idx = { 0, 2, 1, 0 },\n\t\t\t.multi = { 0, 1, 0, 0 },\n\t\t},\n\t};\n\n\t \n\tif (!spec->gen.autocfg.dig_outs ||\n\t    get_wcaps_type(get_wcaps(codec, 0x1d)) != AC_WID_AUD_MIX)\n\t\treturn 0;\n\n\tnum_conns = snd_hda_get_num_conns(codec, 0x0b) + 1;\n\tif (num_conns != 3 && num_conns != 4)\n\t\treturn 0;\n\tspec->num_smux_conns = num_conns;\n\n\tfor (i = 0; i < num_conns; i++) {\n\t\tstruct nid_path *path = snd_array_new(&spec->gen.paths);\n\t\tif (!path)\n\t\t\treturn -ENOMEM;\n\t\t*path = fake_paths[i];\n\t\tif (!i)\n\t\t\tpath->active = 1;\n\t\tspec->smux_paths[i] = snd_hda_get_path_idx(codec, path);\n\t}\n\n\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &ad1988_auto_smux_mixer))\n\t\treturn -ENOMEM;\n\n\tcodec->patch_ops.init = ad1988_auto_init;\n\n\treturn 0;\n}\n\n \n\nenum {\n\tAD1988_FIXUP_6STACK_DIG,\n};\n\nstatic const struct hda_fixup ad1988_fixups[] = {\n\t[AD1988_FIXUP_6STACK_DIG] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t{ 0x11, 0x02214130 },  \n\t\t\t{ 0x12, 0x01014010 },  \n\t\t\t{ 0x14, 0x02a19122 },  \n\t\t\t{ 0x15, 0x01813021 },  \n\t\t\t{ 0x16, 0x01011012 },  \n\t\t\t{ 0x17, 0x01a19020 },  \n\t\t\t{ 0x1b, 0x0145f1f0 },  \n\t\t\t{ 0x24, 0x01016011 },  \n\t\t\t{ 0x25, 0x01012013 },  \n\t\t\t{ }\n\t\t}\n\t},\n};\n\nstatic const struct hda_model_fixup ad1988_fixup_models[] = {\n\t{ .id = AD1988_FIXUP_6STACK_DIG, .name = \"6stack-dig\" },\n\t{}\n};\n\nstatic int patch_ad1988(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec;\n\tint err;\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\tspec->gen.mixer_nid = 0x20;\n\tspec->gen.mixer_merge_nid = 0x21;\n\tspec->gen.beep_nid = 0x10;\n\tset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\n\n\tsnd_hda_pick_fixup(codec, ad1988_fixup_models, NULL, ad1988_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = ad198x_parse_auto_config(codec, true);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ad1988_add_spdif_mux_ctl(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\n\n \n\n \nstatic void ad1884_fixup_amp_override(struct hda_codec *codec,\n\t\t\t\t      const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tsnd_hda_override_amp_caps(codec, 0x20, HDA_INPUT,\n\t\t\t\t\t  (0x17 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t\t  (0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t\t  (0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t\t  (1 << AC_AMPCAP_MUTE_SHIFT));\n}\n\n \nstatic void ad1884_vmaster_hp_gpio_hook(void *private_data, int enabled)\n{\n\tstruct hda_codec *codec = private_data;\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (spec->eapd_nid)\n\t\tad_vmaster_eapd_hook(private_data, enabled);\n\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t   AC_VERB_SET_GPIO_DATA,\n\t\t\t\t   enabled ? 0x00 : 0x02);\n}\n\nstatic void ad1884_fixup_hp_eapd(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tswitch (action) {\n\tcase HDA_FIXUP_ACT_PRE_PROBE:\n\t\tspec->gen.vmaster_mute.hook = ad1884_vmaster_hp_gpio_hook;\n\t\tspec->gen.own_eapd_ctl = 1;\n\t\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t\t  AC_VERB_SET_GPIO_MASK, 0x02);\n\t\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t\t  AC_VERB_SET_GPIO_DIRECTION, 0x02);\n\t\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t\t  AC_VERB_SET_GPIO_DATA, 0x02);\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_PROBE:\n\t\tif (spec->gen.autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\t\tspec->eapd_nid = spec->gen.autocfg.line_out_pins[0];\n\t\telse\n\t\t\tspec->eapd_nid = spec->gen.autocfg.speaker_pins[0];\n\t\tbreak;\n\t}\n}\n\nstatic void ad1884_fixup_thinkpad(struct hda_codec *codec,\n\t\t\t\t  const struct hda_fixup *fix, int action)\n{\n\tstruct ad198x_spec *spec = codec->spec;\n\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n\t\tspec->gen.keep_eapd_on = 1;\n\t\tspec->gen.vmaster_mute.hook = ad_vmaster_eapd_hook;\n\t\tspec->eapd_nid = 0x12;\n\t\t \n\t\tspec->beep_amp = HDA_COMPOSE_AMP_VAL(0x20, 3, 3, HDA_INPUT);\n\t\tspec->gen.beep_nid = 0;  \n\t}\n}\n\n \nstatic const struct hda_verb ad1884_dmic_init_verbs[] = {\n\t{0x01, AC_VERB_SET_COEF_INDEX, 0x13f7},\n\t{0x01, AC_VERB_SET_PROC_COEF, 0x08},\n\t{}\n};\n\nenum {\n\tAD1884_FIXUP_AMP_OVERRIDE,\n\tAD1884_FIXUP_HP_EAPD,\n\tAD1884_FIXUP_DMIC_COEF,\n\tAD1884_FIXUP_THINKPAD,\n\tAD1884_FIXUP_HP_TOUCHSMART,\n};\n\nstatic const struct hda_fixup ad1884_fixups[] = {\n\t[AD1884_FIXUP_AMP_OVERRIDE] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1884_fixup_amp_override,\n\t},\n\t[AD1884_FIXUP_HP_EAPD] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1884_fixup_hp_eapd,\n\t\t.chained = true,\n\t\t.chain_id = AD1884_FIXUP_AMP_OVERRIDE,\n\t},\n\t[AD1884_FIXUP_DMIC_COEF] = {\n\t\t.type = HDA_FIXUP_VERBS,\n\t\t.v.verbs = ad1884_dmic_init_verbs,\n\t},\n\t[AD1884_FIXUP_THINKPAD] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = ad1884_fixup_thinkpad,\n\t\t.chained = true,\n\t\t.chain_id = AD1884_FIXUP_DMIC_COEF,\n\t},\n\t[AD1884_FIXUP_HP_TOUCHSMART] = {\n\t\t.type = HDA_FIXUP_VERBS,\n\t\t.v.verbs = ad1884_dmic_init_verbs,\n\t\t.chained = true,\n\t\t.chain_id = AD1884_FIXUP_HP_EAPD,\n\t},\n};\n\nstatic const struct snd_pci_quirk ad1884_fixup_tbl[] = {\n\tSND_PCI_QUIRK(0x103c, 0x2a82, \"HP Touchsmart\", AD1884_FIXUP_HP_TOUCHSMART),\n\tSND_PCI_QUIRK_VENDOR(0x103c, \"HP\", AD1884_FIXUP_HP_EAPD),\n\tSND_PCI_QUIRK_VENDOR(0x17aa, \"Lenovo Thinkpad\", AD1884_FIXUP_THINKPAD),\n\t{}\n};\n\n\nstatic int patch_ad1884(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec;\n\tint err;\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\tspec->gen.mixer_nid = 0x20;\n\tspec->gen.mixer_merge_nid = 0x21;\n\tspec->gen.beep_nid = 0x10;\n\tset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\n\n\tsnd_hda_pick_fixup(codec, NULL, ad1884_fixup_tbl, ad1884_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = ad198x_parse_auto_config(codec, true);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ad1983_add_spdif_mux_ctl(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\n\treturn 0;\n\n error:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\n \n\nstatic int patch_ad1882(struct hda_codec *codec)\n{\n\tstruct ad198x_spec *spec;\n\tint err;\n\n\terr = alloc_ad_spec(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\tspec->gen.mixer_nid = 0x20;\n\tspec->gen.mixer_merge_nid = 0x21;\n\tspec->gen.beep_nid = 0x10;\n\tset_beep_amp(spec, 0x10, 0, HDA_OUTPUT);\n\terr = ad198x_parse_auto_config(codec, true);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ad1988_add_spdif_mux_ctl(codec);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tsnd_hda_gen_free(codec);\n\treturn err;\n}\n\n\n \nstatic const struct hda_device_id snd_hda_id_analog[] = {\n\tHDA_CODEC_ENTRY(0x11d4184a, \"AD1884A\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d41882, \"AD1882\", patch_ad1882),\n\tHDA_CODEC_ENTRY(0x11d41883, \"AD1883\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d41884, \"AD1884\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d4194a, \"AD1984A\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d4194b, \"AD1984B\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d41981, \"AD1981\", patch_ad1981),\n\tHDA_CODEC_ENTRY(0x11d41983, \"AD1983\", patch_ad1983),\n\tHDA_CODEC_ENTRY(0x11d41984, \"AD1984\", patch_ad1884),\n\tHDA_CODEC_ENTRY(0x11d41986, \"AD1986A\", patch_ad1986a),\n\tHDA_CODEC_ENTRY(0x11d41988, \"AD1988\", patch_ad1988),\n\tHDA_CODEC_ENTRY(0x11d4198b, \"AD1988B\", patch_ad1988),\n\tHDA_CODEC_ENTRY(0x11d4882a, \"AD1882A\", patch_ad1882),\n\tHDA_CODEC_ENTRY(0x11d4989a, \"AD1989A\", patch_ad1988),\n\tHDA_CODEC_ENTRY(0x11d4989b, \"AD1989B\", patch_ad1988),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_analog);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Analog Devices HD-audio codec\");\n\nstatic struct hda_codec_driver analog_driver = {\n\t.id = snd_hda_id_analog,\n};\n\nmodule_hda_codec_driver(analog_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}