{
  "module_name": "hda_tegra.c",
  "hash_id": "1e07394037dc607659263a6d2e990ea8d905ec952d61db7cfe61d5b6d1f9b336",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n\n#include <sound/hda_codec.h>\n#include \"hda_controller.h\"\n\n \n#define HDA_BAR0           0x8000\n\n#define HDA_CFG_CMD        0x1004\n#define HDA_CFG_BAR0       0x1010\n\n#define HDA_ENABLE_IO_SPACE       (1 << 0)\n#define HDA_ENABLE_MEM_SPACE      (1 << 1)\n#define HDA_ENABLE_BUS_MASTER     (1 << 2)\n#define HDA_ENABLE_SERR           (1 << 8)\n#define HDA_DISABLE_INTR          (1 << 10)\n#define HDA_BAR0_INIT_PROGRAM     0xFFFFFFFF\n#define HDA_BAR0_FINAL_PROGRAM    (1 << 14)\n\n \n#define HDA_IPFS_CONFIG           0x180\n#define HDA_IPFS_EN_FPCI          0x1\n\n#define HDA_IPFS_FPCI_BAR0        0x80\n#define HDA_FPCI_BAR0_START       0x40\n\n#define HDA_IPFS_INTR_MASK        0x188\n#define HDA_IPFS_EN_INTR          (1 << 16)\n\n \n#define FPCI_DBG_CFG_2\t\t  0x10F4\n#define FPCI_GCAP_NSDO_SHIFT\t  18\n#define FPCI_GCAP_NSDO_MASK\t  (0x3 << FPCI_GCAP_NSDO_SHIFT)\n\n \n#define NUM_CAPTURE_SD 1\n#define NUM_PLAYBACK_SD 1\n\n \n#define TEGRA194_NUM_SDO_LINES\t  4\n\nstruct hda_tegra_soc {\n\tbool has_hda2codec_2x_reset;\n\tbool has_hda2hdmi;\n};\n\nstruct hda_tegra {\n\tstruct azx chip;\n\tstruct device *dev;\n\tstruct reset_control_bulk_data resets[3];\n\tstruct clk_bulk_data clocks[3];\n\tunsigned int nresets;\n\tunsigned int nclocks;\n\tvoid __iomem *regs;\n\tstruct work_struct probe_work;\n\tconst struct hda_tegra_soc *soc;\n};\n\n#ifdef CONFIG_PM\nstatic int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;\nmodule_param(power_save, bint, 0644);\nMODULE_PARM_DESC(power_save,\n\t\t \"Automatic power-saving timeout (in seconds, 0 = disable).\");\n#else\n#define power_save\t0\n#endif\n\nstatic const struct hda_controller_ops hda_tegra_ops;  \n\nstatic void hda_tegra_init(struct hda_tegra *hda)\n{\n\tu32 v;\n\n\t \n\tv = readl(hda->regs + HDA_IPFS_CONFIG);\n\tv |= HDA_IPFS_EN_FPCI;\n\twritel(v, hda->regs + HDA_IPFS_CONFIG);\n\n\t \n\tv = readl(hda->regs + HDA_CFG_CMD);\n\tv &= ~HDA_DISABLE_INTR;\n\tv |= HDA_ENABLE_MEM_SPACE | HDA_ENABLE_IO_SPACE |\n\t\tHDA_ENABLE_BUS_MASTER | HDA_ENABLE_SERR;\n\twritel(v, hda->regs + HDA_CFG_CMD);\n\n\twritel(HDA_BAR0_INIT_PROGRAM, hda->regs + HDA_CFG_BAR0);\n\twritel(HDA_BAR0_FINAL_PROGRAM, hda->regs + HDA_CFG_BAR0);\n\twritel(HDA_FPCI_BAR0_START, hda->regs + HDA_IPFS_FPCI_BAR0);\n\n\tv = readl(hda->regs + HDA_IPFS_INTR_MASK);\n\tv |= HDA_IPFS_EN_INTR;\n\twritel(v, hda->regs + HDA_IPFS_INTR_MASK);\n}\n\n \nstatic int __maybe_unused hda_tegra_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tint rc;\n\n\trc = pm_runtime_force_suspend(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hda_tegra_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tint rc;\n\n\trc = pm_runtime_force_resume(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hda_tegra_runtime_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip = card->private_data;\n\tstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\n\n\tif (chip && chip->running) {\n\t\t \n\t\tazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |\n\t\t\t   STATESTS_INT_MASK);\n\n\t\tazx_stop_chip(chip);\n\t\tazx_enter_link_reset(chip);\n\t}\n\tclk_bulk_disable_unprepare(hda->nclocks, hda->clocks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hda_tegra_runtime_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct azx *chip = card->private_data;\n\tstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\n\tint rc;\n\n\tif (!chip->running) {\n\t\trc = reset_control_bulk_assert(hda->nresets, hda->resets);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = clk_bulk_prepare_enable(hda->nclocks, hda->clocks);\n\tif (rc != 0)\n\t\treturn rc;\n\tif (chip->running) {\n\t\thda_tegra_init(hda);\n\t\tazx_init_chip(chip, 1);\n\t\t \n\t\tazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &\n\t\t\t   ~STATESTS_INT_MASK);\n\t} else {\n\t\tusleep_range(10, 100);\n\n\t\trc = reset_control_bulk_deassert(hda->nresets, hda->resets);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hda_tegra_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)\n\tSET_RUNTIME_PM_OPS(hda_tegra_runtime_suspend,\n\t\t\t   hda_tegra_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic int hda_tegra_dev_disconnect(struct snd_device *device)\n{\n\tstruct azx *chip = device->device_data;\n\n\tchip->bus.shutdown = 1;\n\treturn 0;\n}\n\n \nstatic int hda_tegra_dev_free(struct snd_device *device)\n{\n\tstruct azx *chip = device->device_data;\n\tstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\n\n\tcancel_work_sync(&hda->probe_work);\n\tif (azx_bus(chip)->chip_init) {\n\t\tazx_stop_all_streams(chip);\n\t\tazx_stop_chip(chip);\n\t}\n\n\tazx_free_stream_pages(chip);\n\tazx_free_streams(chip);\n\tsnd_hdac_bus_exit(azx_bus(chip));\n\n\treturn 0;\n}\n\nstatic int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)\n{\n\tstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct resource *res;\n\n\thda->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hda->regs))\n\t\treturn PTR_ERR(hda->regs);\n\n\tbus->remap_addr = hda->regs + HDA_BAR0;\n\tbus->addr = res->start + HDA_BAR0;\n\n\thda_tegra_init(hda);\n\n\treturn 0;\n}\n\nstatic int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)\n{\n\tstruct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);\n\tstruct hdac_bus *bus = azx_bus(chip);\n\tstruct snd_card *card = chip->card;\n\tint err;\n\tunsigned short gcap;\n\tint irq_id = platform_get_irq(pdev, 0);\n\tconst char *sname, *drv_name = \"tegra-hda\";\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tif (irq_id < 0)\n\t\treturn irq_id;\n\n\terr = hda_tegra_init_chip(chip, pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_irq(chip->card->dev, irq_id, azx_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (err) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"unable to request IRQ %d, disabling device\\n\",\n\t\t\tirq_id);\n\t\treturn err;\n\t}\n\tbus->irq = irq_id;\n\tbus->dma_stop_delay = 100;\n\tcard->sync_irq = bus->irq;\n\n\t \n\tif (of_device_is_compatible(np, \"nvidia,tegra194-hda\")) {\n\t\tu32 val;\n\n\t\tdev_info(card->dev, \"Override SDO lines to %u\\n\",\n\t\t\t TEGRA194_NUM_SDO_LINES);\n\n\t\tval = readl(hda->regs + FPCI_DBG_CFG_2) & ~FPCI_GCAP_NSDO_MASK;\n\t\tval |= (TEGRA194_NUM_SDO_LINES >> 1) << FPCI_GCAP_NSDO_SHIFT;\n\t\twritel(val, hda->regs + FPCI_DBG_CFG_2);\n\t}\n\n\tgcap = azx_readw(chip, GCAP);\n\tdev_dbg(card->dev, \"chipset global capabilities = 0x%x\\n\", gcap);\n\n\tchip->align_buffer_size = 1;\n\n\t \n\tchip->capture_streams = (gcap >> 8) & 0x0f;\n\n\t \n\tif (of_device_is_compatible(np, \"nvidia,tegra234-hda\"))\n\t\tchip->capture_streams = 4;\n\n\tchip->playback_streams = (gcap >> 12) & 0x0f;\n\tif (!chip->playback_streams && !chip->capture_streams) {\n\t\t \n\t\tchip->playback_streams = NUM_PLAYBACK_SD;\n\t\tchip->capture_streams = NUM_CAPTURE_SD;\n\t}\n\tchip->capture_index_offset = 0;\n\tchip->playback_index_offset = chip->capture_streams;\n\tchip->num_streams = chip->playback_streams + chip->capture_streams;\n\n\t \n\terr = azx_init_streams(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"failed to initialize streams: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = azx_alloc_stream_pages(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"failed to allocate stream pages: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tazx_init_chip(chip, 1);\n\n\t \n\tif (of_device_is_compatible(np, \"nvidia,tegra30-hda\"))\n\t\tchip->bus.core.sdo_limit = 16;\n\n\t \n\tif (!bus->codec_mask) {\n\t\tdev_err(card->dev, \"no codecs found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tstrscpy(card->driver, drv_name, sizeof(card->driver));\n\t \n\tsname = of_get_property(np, \"nvidia,model\", NULL);\n\tif (!sname)\n\t\tsname = drv_name;\n\tif (strlen(sname) > sizeof(card->shortname))\n\t\tdev_info(card->dev, \"truncating shortname for card\\n\");\n\tstrscpy(card->shortname, sname, sizeof(card->shortname));\n\n\t \n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at 0x%lx irq %i\",\n\t\t card->shortname, bus->addr, bus->irq);\n\n\treturn 0;\n}\n\n \n\nstatic void hda_tegra_probe_work(struct work_struct *work);\n\nstatic int hda_tegra_create(struct snd_card *card,\n\t\t\t    unsigned int driver_caps,\n\t\t\t    struct hda_tegra *hda)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_disconnect = hda_tegra_dev_disconnect,\n\t\t.dev_free = hda_tegra_dev_free,\n\t};\n\tstruct azx *chip;\n\tint err;\n\n\tchip = &hda->chip;\n\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->ops = &hda_tegra_ops;\n\tchip->driver_caps = driver_caps;\n\tchip->driver_type = driver_caps & 0xff;\n\tchip->dev_index = 0;\n\tchip->jackpoll_interval = msecs_to_jiffies(5000);\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\n\tchip->codec_probe_mask = -1;\n\n\tchip->single_cmd = false;\n\tchip->snoop = true;\n\n\tINIT_WORK(&hda->probe_work, hda_tegra_probe_work);\n\n\terr = azx_bus_init(chip, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->bus.core.sync_write = 0;\n\tchip->bus.core.needs_damn_long_delay = 1;\n\tchip->bus.core.aligned_mmio = 1;\n\tchip->bus.jackpoll_in_suspend = 1;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Error creating device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hda_tegra_soc tegra30_data = {\n\t.has_hda2codec_2x_reset = true,\n\t.has_hda2hdmi = true,\n};\n\nstatic const struct hda_tegra_soc tegra194_data = {\n\t.has_hda2codec_2x_reset = false,\n\t.has_hda2hdmi = true,\n};\n\nstatic const struct hda_tegra_soc tegra234_data = {\n\t.has_hda2codec_2x_reset = true,\n\t.has_hda2hdmi = false,\n};\n\nstatic const struct of_device_id hda_tegra_match[] = {\n\t{ .compatible = \"nvidia,tegra30-hda\", .data = &tegra30_data },\n\t{ .compatible = \"nvidia,tegra194-hda\", .data = &tegra194_data },\n\t{ .compatible = \"nvidia,tegra234-hda\", .data = &tegra234_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hda_tegra_match);\n\nstatic int hda_tegra_probe(struct platform_device *pdev)\n{\n\tconst unsigned int driver_flags = AZX_DCAPS_CORBRP_SELF_CLEAR |\n\t\t\t\t\t  AZX_DCAPS_PM_RUNTIME |\n\t\t\t\t\t  AZX_DCAPS_4K_BDLE_BOUNDARY;\n\tstruct snd_card *card;\n\tstruct azx *chip;\n\tstruct hda_tegra *hda;\n\tint err;\n\n\thda = devm_kzalloc(&pdev->dev, sizeof(*hda), GFP_KERNEL);\n\tif (!hda)\n\t\treturn -ENOMEM;\n\thda->dev = &pdev->dev;\n\tchip = &hda->chip;\n\n\thda->soc = of_device_get_match_data(&pdev->dev);\n\n\terr = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Error creating card!\\n\");\n\t\treturn err;\n\t}\n\n\thda->resets[hda->nresets++].id = \"hda\";\n\n\t \n\tif (hda->soc->has_hda2hdmi)\n\t\thda->resets[hda->nresets++].id = \"hda2hdmi\";\n\n\t \n\tif (hda->soc->has_hda2codec_2x_reset)\n\t\thda->resets[hda->nresets++].id = \"hda2codec_2x\";\n\n\terr = devm_reset_control_bulk_get_exclusive(&pdev->dev, hda->nresets,\n\t\t\t\t\t\t    hda->resets);\n\tif (err)\n\t\tgoto out_free;\n\n\thda->clocks[hda->nclocks++].id = \"hda\";\n\tif (hda->soc->has_hda2hdmi)\n\t\thda->clocks[hda->nclocks++].id = \"hda2hdmi\";\n\thda->clocks[hda->nclocks++].id = \"hda2codec_2x\";\n\n\terr = devm_clk_bulk_get(&pdev->dev, hda->nclocks, hda->clocks);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\terr = hda_tegra_create(card, driver_flags, hda);\n\tif (err < 0)\n\t\tgoto out_free;\n\tcard->private_data = chip;\n\n\tdev_set_drvdata(&pdev->dev, card);\n\n\tpm_runtime_enable(hda->dev);\n\tif (!azx_has_pm_runtime(chip))\n\t\tpm_runtime_forbid(hda->dev);\n\n\tschedule_work(&hda->probe_work);\n\n\treturn 0;\n\nout_free:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void hda_tegra_probe_work(struct work_struct *work)\n{\n\tstruct hda_tegra *hda = container_of(work, struct hda_tegra, probe_work);\n\tstruct azx *chip = &hda->chip;\n\tstruct platform_device *pdev = to_platform_device(hda->dev);\n\tint err;\n\n\tpm_runtime_get_sync(hda->dev);\n\terr = hda_tegra_first_init(chip, pdev);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\t \n\terr = azx_probe_codecs(chip, 8);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\terr = azx_codec_configure(chip);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\tchip->running = 1;\n\tsnd_hda_set_power_save(&chip->bus, power_save * 1000);\n\n out_free:\n\tpm_runtime_put(hda->dev);\n\treturn;  \n}\n\nstatic void hda_tegra_remove(struct platform_device *pdev)\n{\n\tsnd_card_free(dev_get_drvdata(&pdev->dev));\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic void hda_tegra_shutdown(struct platform_device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(&pdev->dev);\n\tstruct azx *chip;\n\n\tif (!card)\n\t\treturn;\n\tchip = card->private_data;\n\tif (chip && chip->running)\n\t\tazx_stop_chip(chip);\n}\n\nstatic struct platform_driver tegra_platform_hda = {\n\t.driver = {\n\t\t.name = \"tegra-hda\",\n\t\t.pm = &hda_tegra_pm,\n\t\t.of_match_table = hda_tegra_match,\n\t},\n\t.probe = hda_tegra_probe,\n\t.remove_new = hda_tegra_remove,\n\t.shutdown = hda_tegra_shutdown,\n};\nmodule_platform_driver(tegra_platform_hda);\n\nMODULE_DESCRIPTION(\"Tegra HDA bus driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}