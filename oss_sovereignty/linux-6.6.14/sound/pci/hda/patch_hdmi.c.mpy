{
  "module_name": "patch_hdmi.c",
  "hash_id": "dde1787526366587e0e797116b1575f7a75864760e5adfab03b1e86a7e3c6b8b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/asoundef.h>\n#include <sound/tlv.h>\n#include <sound/hdaudio.h>\n#include <sound/hda_i915.h>\n#include <sound/hda_chmap.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_jack.h\"\n#include \"hda_controller.h\"\n\nstatic bool static_hdmi_pcm;\nmodule_param(static_hdmi_pcm, bool, 0644);\nMODULE_PARM_DESC(static_hdmi_pcm, \"Don't restrict PCM parameters per ELD info\");\n\nstatic bool enable_acomp = true;\nmodule_param(enable_acomp, bool, 0444);\nMODULE_PARM_DESC(enable_acomp, \"Enable audio component binding (default=yes)\");\n\nstatic bool enable_silent_stream =\nIS_ENABLED(CONFIG_SND_HDA_INTEL_HDMI_SILENT_STREAM);\nmodule_param(enable_silent_stream, bool, 0644);\nMODULE_PARM_DESC(enable_silent_stream, \"Enable Silent Stream for HDMI devices\");\n\nstatic bool enable_all_pins;\nmodule_param(enable_all_pins, bool, 0444);\nMODULE_PARM_DESC(enable_all_pins, \"Forcibly enable all pins\");\n\nstruct hdmi_spec_per_cvt {\n\thda_nid_t cvt_nid;\n\tbool assigned;\t\t \n\tbool silent_stream;\t \n\tunsigned int channels_min;\n\tunsigned int channels_max;\n\tu32 rates;\n\tu64 formats;\n\tunsigned int maxbps;\n};\n\n \n#define HDA_MAX_CONNECTIONS\t32\n\nstruct hdmi_spec_per_pin {\n\thda_nid_t pin_nid;\n\tint dev_id;\n\t \n\tint pin_nid_idx;\n\tint num_mux_nids;\n\thda_nid_t mux_nids[HDA_MAX_CONNECTIONS];\n\tint mux_idx;\n\thda_nid_t cvt_nid;\n\n\tstruct hda_codec *codec;\n\tstruct hdmi_eld sink_eld;\n\tstruct mutex lock;\n\tstruct delayed_work work;\n\tstruct hdmi_pcm *pcm;  \n\tint pcm_idx;  \n\tint prev_pcm_idx;  \n\tint repoll_count;\n\tbool setup;  \n\tbool silent_stream;\n\tint channels;  \n\tbool non_pcm;\n\tbool chmap_set;\t\t \n\tunsigned char chmap[8];  \n#ifdef CONFIG_SND_PROC_FS\n\tstruct snd_info_entry *proc_entry;\n#endif\n};\n\n \nstruct hdmi_ops {\n\tint (*pin_get_eld)(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t   int dev_id, unsigned char *buf, int *eld_size);\n\n\tvoid (*pin_setup_infoframe)(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\t    int dev_id,\n\t\t\t\t    int ca, int active_channels, int conn_type);\n\n\t \n\tint (*pin_hbr_setup)(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t     int dev_id, bool hbr);\n\n\tint (*setup_stream)(struct hda_codec *codec, hda_nid_t cvt_nid,\n\t\t\t    hda_nid_t pin_nid, int dev_id, u32 stream_tag,\n\t\t\t    int format);\n\n\tvoid (*pin_cvt_fixup)(struct hda_codec *codec,\n\t\t\t      struct hdmi_spec_per_pin *per_pin,\n\t\t\t      hda_nid_t cvt_nid);\n};\n\nstruct hdmi_pcm {\n\tstruct hda_pcm *pcm;\n\tstruct snd_jack *jack;\n\tstruct snd_kcontrol *eld_ctl;\n};\n\nenum {\n\tSILENT_STREAM_OFF = 0,\n\tSILENT_STREAM_KAE,\t \n\tSILENT_STREAM_I915,\t \n};\n\nstruct hdmi_spec {\n\tstruct hda_codec *codec;\n\tint num_cvts;\n\tstruct snd_array cvts;  \n\thda_nid_t cvt_nids[4];  \n\n\t \n\tint num_pins;\n\t \n\tint num_nids;\n\t \n\tint dev_num;\n\tstruct snd_array pins;  \n\tstruct hdmi_pcm pcm_rec[8];\n\tstruct mutex pcm_lock;\n\tstruct mutex bind_lock;  \n\t \n\tunsigned long pcm_bitmap;\n\tint pcm_used;\t \n\t \n\tunsigned long pcm_in_use;\n\n\tstruct hdmi_eld temp_eld;\n\tstruct hdmi_ops ops;\n\n\tbool dyn_pin_out;\n\tbool static_pcm_mapping;\n\t \n\tbool hdmi_intr_trig_ctrl;\n\tbool nv_dp_workaround;  \n\n\tbool intel_hsw_fixup;\t \n\t \n\tstruct hda_multi_out multiout;\n\tstruct hda_pcm_stream pcm_playback;\n\n\tbool use_acomp_notifier;  \n\tbool acomp_registered;  \n\tbool force_connect;  \n\tstruct drm_audio_component_audio_ops drm_audio_ops;\n\tint (*port2pin)(struct hda_codec *, int);  \n\n\tstruct hdac_chmap chmap;\n\thda_nid_t vendor_nid;\n\tconst int *port_map;\n\tint port_num;\n\tint silent_stream_type;\n};\n\n#ifdef CONFIG_SND_HDA_COMPONENT\nstatic inline bool codec_has_acomp(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\treturn spec->use_acomp_notifier;\n}\n#else\n#define codec_has_acomp(codec)\tfalse\n#endif\n\nstruct hdmi_audio_infoframe {\n\tu8 type;  \n\tu8 ver;   \n\tu8 len;   \n\n\tu8 checksum;\n\n\tu8 CC02_CT47;\t \n\tu8 SS01_SF24;\n\tu8 CXT04;\n\tu8 CA;\n\tu8 LFEPBL01_LSV36_DM_INH7;\n};\n\nstruct dp_audio_infoframe {\n\tu8 type;  \n\tu8 len;   \n\tu8 ver;   \n\n\tu8 CC02_CT47;\t \n\tu8 SS01_SF24;\n\tu8 CXT04;\n\tu8 CA;\n\tu8 LFEPBL01_LSV36_DM_INH7;\n};\n\nunion audio_infoframe {\n\tstruct hdmi_audio_infoframe hdmi;\n\tstruct dp_audio_infoframe dp;\n\tDECLARE_FLEX_ARRAY(u8, bytes);\n};\n\n \n\n#define get_pin(spec, idx) \\\n\t((struct hdmi_spec_per_pin *)snd_array_elem(&spec->pins, idx))\n#define get_cvt(spec, idx) \\\n\t((struct hdmi_spec_per_cvt  *)snd_array_elem(&spec->cvts, idx))\n \n#define get_hdmi_pcm(spec, idx)\t(&(spec)->pcm_rec[idx])\n \n#define get_pcm_rec(spec, idx)\t(get_hdmi_pcm(spec, idx)->pcm)\n\nstatic int pin_id_to_pin_index(struct hda_codec *codec,\n\t\t\t       hda_nid_t pin_nid, int dev_id)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\tstruct hdmi_spec_per_pin *per_pin;\n\n\t \n\tif (dev_id == -1)\n\t\tdev_id = 0;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tper_pin = get_pin(spec, pin_idx);\n\t\tif ((per_pin->pin_nid == pin_nid) &&\n\t\t\t(per_pin->dev_id == dev_id))\n\t\t\treturn pin_idx;\n\t}\n\n\tcodec_warn(codec, \"HDMI: pin NID 0x%x not registered\\n\", pin_nid);\n\treturn -EINVAL;\n}\n\nstatic int hinfo_to_pcm_index(struct hda_codec *codec,\n\t\t\tstruct hda_pcm_stream *hinfo)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pcm_idx;\n\n\tfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++)\n\t\tif (get_pcm_rec(spec, pcm_idx)->stream == hinfo)\n\t\t\treturn pcm_idx;\n\n\tcodec_warn(codec, \"HDMI: hinfo %p not tied to a PCM\\n\", hinfo);\n\treturn -EINVAL;\n}\n\nstatic int hinfo_to_pin_index(struct hda_codec *codec,\n\t\t\t      struct hda_pcm_stream *hinfo)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tint pin_idx;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tper_pin = get_pin(spec, pin_idx);\n\t\tif (per_pin->pcm &&\n\t\t\tper_pin->pcm->pcm->stream == hinfo)\n\t\t\treturn pin_idx;\n\t}\n\n\tcodec_dbg(codec, \"HDMI: hinfo %p (pcm %d) not registered\\n\", hinfo,\n\t\t  hinfo_to_pcm_index(codec, hinfo));\n\treturn -EINVAL;\n}\n\nstatic struct hdmi_spec_per_pin *pcm_idx_to_pin(struct hdmi_spec *spec,\n\t\t\t\t\t\tint pcm_idx)\n{\n\tint i;\n\tstruct hdmi_spec_per_pin *per_pin;\n\n\tfor (i = 0; i < spec->num_pins; i++) {\n\t\tper_pin = get_pin(spec, i);\n\t\tif (per_pin->pcm_idx == pcm_idx)\n\t\t\treturn per_pin;\n\t}\n\treturn NULL;\n}\n\nstatic int cvt_nid_to_cvt_index(struct hda_codec *codec, hda_nid_t cvt_nid)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint cvt_idx;\n\n\tfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++)\n\t\tif (get_cvt(spec, cvt_idx)->cvt_nid == cvt_nid)\n\t\t\treturn cvt_idx;\n\n\tcodec_warn(codec, \"HDMI: cvt NID 0x%x not registered\\n\", cvt_nid);\n\treturn -EINVAL;\n}\n\nstatic int hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tstruct hdmi_eld *eld;\n\tint pcm_idx;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\n\tpcm_idx = kcontrol->private_value;\n\tmutex_lock(&spec->pcm_lock);\n\tper_pin = pcm_idx_to_pin(spec, pcm_idx);\n\tif (!per_pin) {\n\t\t \n\t\tuinfo->count = 0;\n\t\tgoto unlock;\n\t}\n\teld = &per_pin->sink_eld;\n\tuinfo->count = eld->eld_valid ? eld->eld_size : 0;\n\n unlock:\n\tmutex_unlock(&spec->pcm_lock);\n\treturn 0;\n}\n\nstatic int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tstruct hdmi_eld *eld;\n\tint pcm_idx;\n\tint err = 0;\n\n\tpcm_idx = kcontrol->private_value;\n\tmutex_lock(&spec->pcm_lock);\n\tper_pin = pcm_idx_to_pin(spec, pcm_idx);\n\tif (!per_pin) {\n\t\t \n\t\tmemset(ucontrol->value.bytes.data, 0,\n\t\t       ARRAY_SIZE(ucontrol->value.bytes.data));\n\t\tgoto unlock;\n\t}\n\n\teld = &per_pin->sink_eld;\n\tif (eld->eld_size > ARRAY_SIZE(ucontrol->value.bytes.data) ||\n\t    eld->eld_size > ELD_MAX_SIZE) {\n\t\tsnd_BUG();\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tmemset(ucontrol->value.bytes.data, 0,\n\t       ARRAY_SIZE(ucontrol->value.bytes.data));\n\tif (eld->eld_valid)\n\t\tmemcpy(ucontrol->value.bytes.data, eld->eld_buffer,\n\t\t       eld->eld_size);\n\n unlock:\n\tmutex_unlock(&spec->pcm_lock);\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new eld_bytes_ctl = {\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE |\n\t\tSNDRV_CTL_ELEM_ACCESS_SKIP_CHECK,\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"ELD\",\n\t.info = hdmi_eld_ctl_info,\n\t.get = hdmi_eld_ctl_get,\n};\n\nstatic int hdmi_create_eld_ctl(struct hda_codec *codec, int pcm_idx,\n\t\t\tint device)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct hdmi_spec *spec = codec->spec;\n\tint err;\n\n\tkctl = snd_ctl_new1(&eld_bytes_ctl, codec);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->private_value = pcm_idx;\n\tkctl->id.device = device;\n\n\t \n\terr = snd_hda_ctl_add(codec, 0, kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tget_hdmi_pcm(spec, pcm_idx)->eld_ctl = kctl;\n\treturn 0;\n}\n\n#ifdef BE_PARANOID\nstatic void hdmi_get_dip_index(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\tint *packet_index, int *byte_index)\n{\n\tint val;\n\n\tval = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t AC_VERB_GET_HDMI_DIP_INDEX, 0);\n\n\t*packet_index = val >> 5;\n\t*byte_index = val & 0x1f;\n}\n#endif\n\nstatic void hdmi_set_dip_index(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\tint packet_index, int byte_index)\n{\n\tint val;\n\n\tval = (packet_index << 5) | (byte_index & 0x1f);\n\n\tsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_INDEX, val);\n}\n\nstatic void hdmi_write_dip_byte(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\tunsigned char val)\n{\n\tsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_DATA, val);\n}\n\nstatic void hdmi_init_pin(struct hda_codec *codec, hda_nid_t pin_nid)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_out;\n\n\t \n\tif (get_wcaps(codec, pin_nid) & AC_WCAP_OUT_AMP)\n\t\tsnd_hda_codec_write(codec, pin_nid, 0,\n\t\t\t\tAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE);\n\n\tif (spec->dyn_pin_out)\n\t\t \n\t\tpin_out = 0;\n\telse\n\t\t \n\t\tpin_out = PIN_OUT;\n\n\tsnd_hda_codec_write(codec, pin_nid, 0,\n\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL, pin_out);\n}\n\n \n\n#ifdef CONFIG_SND_PROC_FS\nstatic void print_eld_info(struct snd_info_entry *entry,\n\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct hdmi_spec_per_pin *per_pin = entry->private_data;\n\n\tmutex_lock(&per_pin->lock);\n\tsnd_hdmi_print_eld_info(&per_pin->sink_eld, buffer, per_pin->pin_nid,\n\t\t\t\tper_pin->dev_id, per_pin->cvt_nid);\n\tmutex_unlock(&per_pin->lock);\n}\n\nstatic void write_eld_info(struct snd_info_entry *entry,\n\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct hdmi_spec_per_pin *per_pin = entry->private_data;\n\n\tmutex_lock(&per_pin->lock);\n\tsnd_hdmi_write_eld_info(&per_pin->sink_eld, buffer);\n\tmutex_unlock(&per_pin->lock);\n}\n\nstatic int eld_proc_new(struct hdmi_spec_per_pin *per_pin, int index)\n{\n\tchar name[32];\n\tstruct hda_codec *codec = per_pin->codec;\n\tstruct snd_info_entry *entry;\n\tint err;\n\n\tsnprintf(name, sizeof(name), \"eld#%d.%d\", codec->addr, index);\n\terr = snd_card_proc_new(codec->card, name, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_info_set_text_ops(entry, per_pin, print_eld_info);\n\tentry->c.text.write = write_eld_info;\n\tentry->mode |= 0200;\n\tper_pin->proc_entry = entry;\n\n\treturn 0;\n}\n\nstatic void eld_proc_free(struct hdmi_spec_per_pin *per_pin)\n{\n\tif (!per_pin->codec->bus->shutdown) {\n\t\tsnd_info_free_entry(per_pin->proc_entry);\n\t\tper_pin->proc_entry = NULL;\n\t}\n}\n#else\nstatic inline int eld_proc_new(struct hdmi_spec_per_pin *per_pin,\n\t\t\t       int index)\n{\n\treturn 0;\n}\nstatic inline void eld_proc_free(struct hdmi_spec_per_pin *per_pin)\n{\n}\n#endif\n\n \n\n \nstatic void hdmi_start_infoframe_trans(struct hda_codec *codec,\n\t\t\t\t       hda_nid_t pin_nid)\n{\n\thdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\n\tsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_XMIT,\n\t\t\t\t\t\tAC_DIPXMIT_BEST);\n}\n\n \nstatic void hdmi_stop_infoframe_trans(struct hda_codec *codec,\n\t\t\t\t      hda_nid_t pin_nid)\n{\n\thdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\n\tsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_XMIT,\n\t\t\t\t\t\tAC_DIPXMIT_DISABLE);\n}\n\nstatic void hdmi_debug_dip_size(struct hda_codec *codec, hda_nid_t pin_nid)\n{\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tint i;\n\tint size;\n\n\tsize = snd_hdmi_get_eld_size(codec, pin_nid);\n\tcodec_dbg(codec, \"HDMI: ELD buf size is %d\\n\", size);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tsize = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t\t\tAC_VERB_GET_HDMI_DIP_SIZE, i);\n\t\tcodec_dbg(codec, \"HDMI: DIP GP[%d] buf size is %d\\n\", i, size);\n\t}\n#endif\n}\n\nstatic void hdmi_clear_dip_buffers(struct hda_codec *codec, hda_nid_t pin_nid)\n{\n#ifdef BE_PARANOID\n\tint i, j;\n\tint size;\n\tint pi, bi;\n\tfor (i = 0; i < 8; i++) {\n\t\tsize = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t\t\tAC_VERB_GET_HDMI_DIP_SIZE, i);\n\t\tif (size == 0)\n\t\t\tcontinue;\n\n\t\thdmi_set_dip_index(codec, pin_nid, i, 0x0);\n\t\tfor (j = 1; j < 1000; j++) {\n\t\t\thdmi_write_dip_byte(codec, pin_nid, 0x0);\n\t\t\thdmi_get_dip_index(codec, pin_nid, &pi, &bi);\n\t\t\tif (pi != i)\n\t\t\t\tcodec_dbg(codec, \"dip index %d: %d != %d\\n\",\n\t\t\t\t\t\tbi, pi, i);\n\t\t\tif (bi == 0)  \n\t\t\t\tbreak;\n\t\t}\n\t\tcodec_dbg(codec,\n\t\t\t\"HDMI: DIP GP[%d] buf reported size=%d, written=%d\\n\",\n\t\t\ti, size, j);\n\t}\n#endif\n}\n\nstatic void hdmi_checksum_audio_infoframe(struct hdmi_audio_infoframe *hdmi_ai)\n{\n\tu8 *bytes = (u8 *)hdmi_ai;\n\tu8 sum = 0;\n\tint i;\n\n\thdmi_ai->checksum = 0;\n\n\tfor (i = 0; i < sizeof(*hdmi_ai); i++)\n\t\tsum += bytes[i];\n\n\thdmi_ai->checksum = -sum;\n}\n\nstatic void hdmi_fill_audio_infoframe(struct hda_codec *codec,\n\t\t\t\t      hda_nid_t pin_nid,\n\t\t\t\t      u8 *dip, int size)\n{\n\tint i;\n\n\thdmi_debug_dip_size(codec, pin_nid);\n\thdmi_clear_dip_buffers(codec, pin_nid);  \n\n\thdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\n\tfor (i = 0; i < size; i++)\n\t\thdmi_write_dip_byte(codec, pin_nid, dip[i]);\n}\n\nstatic bool hdmi_infoframe_uptodate(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\t    u8 *dip, int size)\n{\n\tu8 val;\n\tint i;\n\n\thdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\n\tif (snd_hda_codec_read(codec, pin_nid, 0, AC_VERB_GET_HDMI_DIP_XMIT, 0)\n\t\t\t\t\t\t\t    != AC_DIPXMIT_BEST)\n\t\treturn false;\n\n\tfor (i = 0; i < size; i++) {\n\t\tval = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t\t AC_VERB_GET_HDMI_DIP_DATA, 0);\n\t\tif (val != dip[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hdmi_pin_get_eld(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t    int dev_id, unsigned char *buf, int *eld_size)\n{\n\tsnd_hda_set_dev_select(codec, nid, dev_id);\n\n\treturn snd_hdmi_get_eld(codec, nid, buf, eld_size);\n}\n\nstatic void hdmi_pin_setup_infoframe(struct hda_codec *codec,\n\t\t\t\t     hda_nid_t pin_nid, int dev_id,\n\t\t\t\t     int ca, int active_channels,\n\t\t\t\t     int conn_type)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tunion audio_infoframe ai;\n\n\tmemset(&ai, 0, sizeof(ai));\n\tif ((conn_type == 0) ||  \n\t\t \n\t\t(conn_type == 1 && spec->nv_dp_workaround)) {\n\t\tstruct hdmi_audio_infoframe *hdmi_ai = &ai.hdmi;\n\n\t\tif (conn_type == 0) {  \n\t\t\thdmi_ai->type\t\t= 0x84;\n\t\t\thdmi_ai->ver\t\t= 0x01;\n\t\t\thdmi_ai->len\t\t= 0x0a;\n\t\t} else { \n\t\t\thdmi_ai->type\t\t= 0x84;\n\t\t\thdmi_ai->ver\t\t= 0x1b;\n\t\t\thdmi_ai->len\t\t= 0x11 << 2;\n\t\t}\n\t\thdmi_ai->CC02_CT47\t= active_channels - 1;\n\t\thdmi_ai->CA\t\t= ca;\n\t\thdmi_checksum_audio_infoframe(hdmi_ai);\n\t} else if (conn_type == 1) {  \n\t\tstruct dp_audio_infoframe *dp_ai = &ai.dp;\n\n\t\tdp_ai->type\t\t= 0x84;\n\t\tdp_ai->len\t\t= 0x1b;\n\t\tdp_ai->ver\t\t= 0x11 << 2;\n\t\tdp_ai->CC02_CT47\t= active_channels - 1;\n\t\tdp_ai->CA\t\t= ca;\n\t} else {\n\t\tcodec_dbg(codec, \"HDMI: unknown connection type at pin NID 0x%x\\n\", pin_nid);\n\t\treturn;\n\t}\n\n\tsnd_hda_set_dev_select(codec, pin_nid, dev_id);\n\n\t \n\tif (!hdmi_infoframe_uptodate(codec, pin_nid, ai.bytes,\n\t\t\t\t\tsizeof(ai))) {\n\t\tcodec_dbg(codec, \"%s: pin NID=0x%x channels=%d ca=0x%02x\\n\",\n\t\t\t  __func__, pin_nid, active_channels, ca);\n\t\thdmi_stop_infoframe_trans(codec, pin_nid);\n\t\thdmi_fill_audio_infoframe(codec, pin_nid,\n\t\t\t\t\t    ai.bytes, sizeof(ai));\n\t\thdmi_start_infoframe_trans(codec, pin_nid);\n\t}\n}\n\nstatic void hdmi_setup_audio_infoframe(struct hda_codec *codec,\n\t\t\t\t       struct hdmi_spec_per_pin *per_pin,\n\t\t\t\t       bool non_pcm)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdac_chmap *chmap = &spec->chmap;\n\thda_nid_t pin_nid = per_pin->pin_nid;\n\tint dev_id = per_pin->dev_id;\n\tint channels = per_pin->channels;\n\tint active_channels;\n\tstruct hdmi_eld *eld;\n\tint ca;\n\n\tif (!channels)\n\t\treturn;\n\n\tsnd_hda_set_dev_select(codec, pin_nid, dev_id);\n\n\t \n\tif (get_wcaps(codec, pin_nid) & AC_WCAP_OUT_AMP)\n\t\tsnd_hda_codec_write(codec, pin_nid, 0,\n\t\t\t\t\t    AC_VERB_SET_AMP_GAIN_MUTE,\n\t\t\t\t\t    AMP_OUT_UNMUTE);\n\n\teld = &per_pin->sink_eld;\n\n\tca = snd_hdac_channel_allocation(&codec->core,\n\t\t\teld->info.spk_alloc, channels,\n\t\t\tper_pin->chmap_set, non_pcm, per_pin->chmap);\n\n\tactive_channels = snd_hdac_get_active_channels(ca);\n\n\tchmap->ops.set_channel_count(&codec->core, per_pin->cvt_nid,\n\t\t\t\t\t\tactive_channels);\n\n\t \n\tsnd_hdac_setup_channel_mapping(&spec->chmap,\n\t\t\t\tpin_nid, non_pcm, ca, channels,\n\t\t\t\tper_pin->chmap, per_pin->chmap_set);\n\n\tspec->ops.pin_setup_infoframe(codec, pin_nid, dev_id,\n\t\t\t\t      ca, active_channels, eld->info.conn_type);\n\n\tper_pin->non_pcm = non_pcm;\n}\n\n \n\nstatic void hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll);\n\nstatic void check_presence_and_report(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t      int dev_id)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx = pin_id_to_pin_index(codec, nid, dev_id);\n\n\tif (pin_idx < 0)\n\t\treturn;\n\tmutex_lock(&spec->pcm_lock);\n\thdmi_present_sense(get_pin(spec, pin_idx), 1);\n\tmutex_unlock(&spec->pcm_lock);\n}\n\nstatic void jack_callback(struct hda_codec *codec,\n\t\t\t  struct hda_jack_callback *jack)\n{\n\t \n\tif (codec_has_acomp(codec))\n\t\treturn;\n\n\tcheck_presence_and_report(codec, jack->nid, jack->dev_id);\n}\n\nstatic void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res,\n\t\t\t\t struct hda_jack_tbl *jack)\n{\n\tjack->jack_dirty = 1;\n\n\tcodec_dbg(codec,\n\t\t\"HDMI hot plug event: Codec=%d NID=0x%x Device=%d Inactive=%d Presence_Detect=%d ELD_Valid=%d\\n\",\n\t\tcodec->addr, jack->nid, jack->dev_id, !!(res & AC_UNSOL_RES_IA),\n\t\t!!(res & AC_UNSOL_RES_PD), !!(res & AC_UNSOL_RES_ELDV));\n\n\tcheck_presence_and_report(codec, jack->nid, jack->dev_id);\n}\n\nstatic void hdmi_non_intrinsic_event(struct hda_codec *codec, unsigned int res)\n{\n\tint tag = res >> AC_UNSOL_RES_TAG_SHIFT;\n\tint subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;\n\tint cp_state = !!(res & AC_UNSOL_RES_CP_STATE);\n\tint cp_ready = !!(res & AC_UNSOL_RES_CP_READY);\n\n\tcodec_info(codec,\n\t\t\"HDMI CP event: CODEC=%d TAG=%d SUBTAG=0x%x CP_STATE=%d CP_READY=%d\\n\",\n\t\tcodec->addr,\n\t\ttag,\n\t\tsubtag,\n\t\tcp_state,\n\t\tcp_ready);\n\n\t \n\tif (cp_state) {\n\t\t;\n\t}\n\tif (cp_ready) {\n\t\t;\n\t}\n}\n\n\nstatic void hdmi_unsol_event(struct hda_codec *codec, unsigned int res)\n{\n\tint tag = res >> AC_UNSOL_RES_TAG_SHIFT;\n\tint subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;\n\tstruct hda_jack_tbl *jack;\n\n\tif (codec_has_acomp(codec))\n\t\treturn;\n\n\tif (codec->dp_mst) {\n\t\tint dev_entry =\n\t\t\t(res & AC_UNSOL_RES_DE) >> AC_UNSOL_RES_DE_SHIFT;\n\n\t\tjack = snd_hda_jack_tbl_get_from_tag(codec, tag, dev_entry);\n\t} else {\n\t\tjack = snd_hda_jack_tbl_get_from_tag(codec, tag, 0);\n\t}\n\n\tif (!jack) {\n\t\tcodec_dbg(codec, \"Unexpected HDMI event tag 0x%x\\n\", tag);\n\t\treturn;\n\t}\n\n\tif (subtag == 0)\n\t\thdmi_intrinsic_event(codec, res, jack);\n\telse\n\t\thdmi_non_intrinsic_event(codec, res);\n}\n\nstatic void haswell_verify_D0(struct hda_codec *codec,\n\t\thda_nid_t cvt_nid, hda_nid_t nid)\n{\n\tint pwr;\n\n\t \n\tif (!snd_hda_check_power_state(codec, cvt_nid, AC_PWRST_D0))\n\t\tsnd_hda_codec_write(codec, cvt_nid, 0, AC_VERB_SET_POWER_STATE, AC_PWRST_D0);\n\n\tif (!snd_hda_check_power_state(codec, nid, AC_PWRST_D0)) {\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,\n\t\t\t\t    AC_PWRST_D0);\n\t\tmsleep(40);\n\t\tpwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);\n\t\tpwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;\n\t\tcodec_dbg(codec, \"Haswell HDMI audio: Power for NID 0x%x is now D%d\\n\", nid, pwr);\n\t}\n}\n\n \n\n \n#define is_hbr_format(format) \\\n\t((format & AC_FMT_TYPE_NON_PCM) && (format & AC_FMT_CHAN_MASK) == 7)\n\nstatic int hdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t      int dev_id, bool hbr)\n{\n\tint pinctl, new_pinctl;\n\n\tif (snd_hda_query_pin_caps(codec, pin_nid) & AC_PINCAP_HBR) {\n\t\tsnd_hda_set_dev_select(codec, pin_nid, dev_id);\n\t\tpinctl = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t\t    AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\n\t\tif (pinctl < 0)\n\t\t\treturn hbr ? -EINVAL : 0;\n\n\t\tnew_pinctl = pinctl & ~AC_PINCTL_EPT;\n\t\tif (hbr)\n\t\t\tnew_pinctl |= AC_PINCTL_EPT_HBR;\n\t\telse\n\t\t\tnew_pinctl |= AC_PINCTL_EPT_NATIVE;\n\n\t\tcodec_dbg(codec,\n\t\t\t  \"hdmi_pin_hbr_setup: NID=0x%x, %spinctl=0x%x\\n\",\n\t\t\t    pin_nid,\n\t\t\t    pinctl == new_pinctl ? \"\" : \"new-\",\n\t\t\t    new_pinctl);\n\n\t\tif (pinctl != new_pinctl)\n\t\t\tsnd_hda_codec_write(codec, pin_nid, 0,\n\t\t\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t\t    new_pinctl);\n\t} else if (hbr)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\n\t\t\t      hda_nid_t pin_nid, int dev_id,\n\t\t\t      u32 stream_tag, int format)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tunsigned int param;\n\tint err;\n\n\terr = spec->ops.pin_hbr_setup(codec, pin_nid, dev_id,\n\t\t\t\t      is_hbr_format(format));\n\n\tif (err) {\n\t\tcodec_dbg(codec, \"hdmi_setup_stream: HBR is not supported\\n\");\n\t\treturn err;\n\t}\n\n\tif (spec->intel_hsw_fixup) {\n\n\t\t \n\t\tparam = snd_hda_codec_read(codec, cvt_nid, 0,\n\t\t\t\t\t   AC_VERB_GET_DIGI_CONVERT_1, 0);\n\n\t\tparam = (param >> 16) & ~(AC_DIG3_ICT);\n\n\t\t \n\t\tif (is_hbr_format(format))\n\t\t\tparam |= 0x1;\n\n\t\tsnd_hda_codec_write(codec, cvt_nid, 0,\n\t\t\t\t    AC_VERB_SET_DIGI_CONVERT_3, param);\n\t}\n\n\tsnd_hda_codec_setup_stream(codec, cvt_nid, stream_tag, 0, format);\n\treturn 0;\n}\n\n \nstatic int hdmi_choose_cvt(struct hda_codec *codec,\n\t\t\t   int pin_idx, int *cvt_id,\n\t\t\t   bool silent)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tstruct hdmi_spec_per_cvt *per_cvt = NULL;\n\tint cvt_idx, mux_idx = 0;\n\n\t \n\tif (pin_idx < 0)\n\t\tper_pin = NULL;\n\telse\n\t\tper_pin = get_pin(spec, pin_idx);\n\n\tif (per_pin && per_pin->silent_stream) {\n\t\tcvt_idx = cvt_nid_to_cvt_index(codec, per_pin->cvt_nid);\n\t\tper_cvt = get_cvt(spec, cvt_idx);\n\t\tif (per_cvt->assigned && !silent)\n\t\t\treturn -EBUSY;\n\t\tif (cvt_id)\n\t\t\t*cvt_id = cvt_idx;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\n\t\tper_cvt = get_cvt(spec, cvt_idx);\n\n\t\t \n\t\tif (per_cvt->assigned || per_cvt->silent_stream)\n\t\t\tcontinue;\n\t\tif (per_pin == NULL)\n\t\t\tbreak;\n\t\t \n\t\tfor (mux_idx = 0; mux_idx < per_pin->num_mux_nids; mux_idx++)\n\t\t\tif (per_pin->mux_nids[mux_idx] == per_cvt->cvt_nid)\n\t\t\t\tbreak;\n\t\t \n\t\tif (mux_idx == per_pin->num_mux_nids)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\t \n\tif (cvt_idx == spec->num_cvts)\n\t\treturn -EBUSY;\n\n\tif (per_pin != NULL)\n\t\tper_pin->mux_idx = mux_idx;\n\n\tif (cvt_id)\n\t\t*cvt_id = cvt_idx;\n\n\treturn 0;\n}\n\n \nstatic void intel_verify_pin_cvt_connect(struct hda_codec *codec,\n\t\t\tstruct hdmi_spec_per_pin *per_pin)\n{\n\thda_nid_t pin_nid = per_pin->pin_nid;\n\tint mux_idx, curr;\n\n\tmux_idx = per_pin->mux_idx;\n\tcurr = snd_hda_codec_read(codec, pin_nid, 0,\n\t\t\t\t\t  AC_VERB_GET_CONNECT_SEL, 0);\n\tif (curr != mux_idx)\n\t\tsnd_hda_codec_write_cache(codec, pin_nid, 0,\n\t\t\t\t\t    AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t\t    mux_idx);\n}\n\n \nstatic int intel_cvt_id_to_mux_idx(struct hdmi_spec *spec,\n\t\t\thda_nid_t cvt_nid)\n{\n\tint i;\n\n\tfor (i = 0; i < spec->num_cvts; i++)\n\t\tif (spec->cvt_nids[i] == cvt_nid)\n\t\t\treturn i;\n\treturn -EINVAL;\n}\n\n \nstatic void intel_not_share_assigned_cvt(struct hda_codec *codec,\n\t\t\t\t\t hda_nid_t pin_nid,\n\t\t\t\t\t int dev_id, int mux_idx)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\thda_nid_t nid;\n\tint cvt_idx, curr;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tint pin_idx;\n\n\t \n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tint dev_id_saved;\n\t\tint dev_num;\n\n\t\tper_pin = get_pin(spec, pin_idx);\n\t\t \n\t\tif (!per_pin->pcm)\n\t\t\tcontinue;\n\n\t\tif ((per_pin->pin_nid == pin_nid) &&\n\t\t\t(per_pin->dev_id == dev_id))\n\t\t\tcontinue;\n\n\t\t \n\t\tdev_num = snd_hda_get_num_devices(codec, per_pin->pin_nid) + 1;\n\t\tif (per_pin->dev_id >= dev_num)\n\t\t\tcontinue;\n\n\t\tnid = per_pin->pin_nid;\n\n\t\t \n\t\tdev_id_saved = snd_hda_get_dev_select(codec, nid);\n\t\tsnd_hda_set_dev_select(codec, nid, per_pin->dev_id);\n\t\tcurr = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t  AC_VERB_GET_CONNECT_SEL, 0);\n\t\tif (curr != mux_idx) {\n\t\t\tsnd_hda_set_dev_select(codec, nid, dev_id_saved);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\n\t\t\tper_cvt = get_cvt(spec, cvt_idx);\n\t\t\tif (!per_cvt->assigned) {\n\t\t\t\tcodec_dbg(codec,\n\t\t\t\t\t  \"choose cvt %d for pin NID 0x%x\\n\",\n\t\t\t\t\t  cvt_idx, nid);\n\t\t\t\tsnd_hda_codec_write_cache(codec, nid, 0,\n\t\t\t\t\t    AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t\t    cvt_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnd_hda_set_dev_select(codec, nid, dev_id_saved);\n\t}\n}\n\n \nstatic void intel_not_share_assigned_cvt_nid(struct hda_codec *codec,\n\t\t\thda_nid_t pin_nid, int dev_id, hda_nid_t cvt_nid)\n{\n\tint mux_idx;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\t \n\tmux_idx = intel_cvt_id_to_mux_idx(spec, cvt_nid);\n\tif (mux_idx >= 0)\n\t\tintel_not_share_assigned_cvt(codec, pin_nid, dev_id, mux_idx);\n}\n\n \nstatic void pin_cvt_fixup(struct hda_codec *codec,\n\t\t\t  struct hdmi_spec_per_pin *per_pin,\n\t\t\t  hda_nid_t cvt_nid)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tif (spec->ops.pin_cvt_fixup)\n\t\tspec->ops.pin_cvt_fixup(codec, per_pin, cvt_nid);\n}\n\n \nstatic int hdmi_pcm_open_no_pin(struct hda_pcm_stream *hinfo,\n\t\t\t struct hda_codec *codec,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint cvt_idx, pcm_idx;\n\tstruct hdmi_spec_per_cvt *per_cvt = NULL;\n\tint err;\n\n\tpcm_idx = hinfo_to_pcm_index(codec, hinfo);\n\tif (pcm_idx < 0)\n\t\treturn -EINVAL;\n\n\terr = hdmi_choose_cvt(codec, -1, &cvt_idx, false);\n\tif (err)\n\t\treturn err;\n\n\tper_cvt = get_cvt(spec, cvt_idx);\n\tper_cvt->assigned = true;\n\thinfo->nid = per_cvt->cvt_nid;\n\n\tpin_cvt_fixup(codec, NULL, per_cvt->cvt_nid);\n\n\tset_bit(pcm_idx, &spec->pcm_in_use);\n\t \n\n\t \n\thinfo->channels_min = per_cvt->channels_min;\n\thinfo->channels_max = per_cvt->channels_max;\n\thinfo->rates = per_cvt->rates;\n\thinfo->formats = per_cvt->formats;\n\thinfo->maxbps = per_cvt->maxbps;\n\n\t \n\truntime->hw.channels_min = hinfo->channels_min;\n\truntime->hw.channels_max = hinfo->channels_max;\n\truntime->hw.formats = hinfo->formats;\n\truntime->hw.rates = hinfo->rates;\n\n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\treturn 0;\n}\n\n \nstatic int hdmi_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t struct hda_codec *codec,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint pin_idx, cvt_idx, pcm_idx;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tstruct hdmi_eld *eld;\n\tstruct hdmi_spec_per_cvt *per_cvt = NULL;\n\tint err;\n\n\t \n\tpcm_idx = hinfo_to_pcm_index(codec, hinfo);\n\tif (pcm_idx < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&spec->pcm_lock);\n\tpin_idx = hinfo_to_pin_index(codec, hinfo);\n\t \n\tif (pin_idx < 0) {\n\t\terr = hdmi_pcm_open_no_pin(hinfo, codec, substream);\n\t\tgoto unlock;\n\t}\n\n\terr = hdmi_choose_cvt(codec, pin_idx, &cvt_idx, false);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tper_cvt = get_cvt(spec, cvt_idx);\n\t \n\tper_cvt->assigned = true;\n\n\tset_bit(pcm_idx, &spec->pcm_in_use);\n\tper_pin = get_pin(spec, pin_idx);\n\tper_pin->cvt_nid = per_cvt->cvt_nid;\n\thinfo->nid = per_cvt->cvt_nid;\n\n\t \n\tif (get_wcaps(codec, per_cvt->cvt_nid) & AC_WCAP_STRIPE)\n\t\tazx_stream(get_azx_dev(substream))->stripe = 1;\n\n\tsnd_hda_set_dev_select(codec, per_pin->pin_nid, per_pin->dev_id);\n\tsnd_hda_codec_write_cache(codec, per_pin->pin_nid, 0,\n\t\t\t    AC_VERB_SET_CONNECT_SEL,\n\t\t\t    per_pin->mux_idx);\n\n\t \n\tpin_cvt_fixup(codec, per_pin, 0);\n\n\tsnd_hda_spdif_ctls_assign(codec, pcm_idx, per_cvt->cvt_nid);\n\n\t \n\thinfo->channels_min = per_cvt->channels_min;\n\thinfo->channels_max = per_cvt->channels_max;\n\thinfo->rates = per_cvt->rates;\n\thinfo->formats = per_cvt->formats;\n\thinfo->maxbps = per_cvt->maxbps;\n\n\teld = &per_pin->sink_eld;\n\t \n\tif (!static_hdmi_pcm && eld->eld_valid) {\n\t\tsnd_hdmi_eld_update_pcm_info(&eld->info, hinfo);\n\t\tif (hinfo->channels_min > hinfo->channels_max ||\n\t\t    !hinfo->rates || !hinfo->formats) {\n\t\t\tper_cvt->assigned = false;\n\t\t\thinfo->nid = 0;\n\t\t\tsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\n\t\t\terr = -ENODEV;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\truntime->hw.channels_min = hinfo->channels_min;\n\truntime->hw.channels_max = hinfo->channels_max;\n\truntime->hw.formats = hinfo->formats;\n\truntime->hw.rates = hinfo->rates;\n\n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n unlock:\n\tmutex_unlock(&spec->pcm_lock);\n\treturn err;\n}\n\n \nstatic int hdmi_read_pin_conn(struct hda_codec *codec, int pin_idx)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\thda_nid_t pin_nid = per_pin->pin_nid;\n\tint dev_id = per_pin->dev_id;\n\tint conns;\n\n\tif (!(get_wcaps(codec, pin_nid) & AC_WCAP_CONN_LIST)) {\n\t\tcodec_warn(codec,\n\t\t\t   \"HDMI: pin NID 0x%x wcaps %#x does not support connection list\\n\",\n\t\t\t   pin_nid, get_wcaps(codec, pin_nid));\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_hda_set_dev_select(codec, pin_nid, dev_id);\n\n\tif (spec->intel_hsw_fixup) {\n\t\tconns = spec->num_cvts;\n\t\tmemcpy(per_pin->mux_nids, spec->cvt_nids,\n\t\t       sizeof(hda_nid_t) * conns);\n\t} else {\n\t\tconns = snd_hda_get_raw_connections(codec, pin_nid,\n\t\t\t\t\t\t    per_pin->mux_nids,\n\t\t\t\t\t\t    HDA_MAX_CONNECTIONS);\n\t}\n\n\t \n\tper_pin->num_mux_nids = conns;\n\n\treturn 0;\n}\n\nstatic int hdmi_find_pcm_slot(struct hdmi_spec *spec,\n\t\t\t      struct hdmi_spec_per_pin *per_pin)\n{\n\tint i;\n\n\tfor (i = 0; i < spec->pcm_used; i++) {\n\t\tif (!test_bit(i, &spec->pcm_bitmap))\n\t\t\treturn i;\n\t}\n\treturn -EBUSY;\n}\n\nstatic void hdmi_attach_hda_pcm(struct hdmi_spec *spec,\n\t\t\t\tstruct hdmi_spec_per_pin *per_pin)\n{\n\tint idx;\n\n\t \n\tif (per_pin->pcm)\n\t\treturn;\n\t \n\tidx = per_pin->prev_pcm_idx;\n\tif (idx >= 0) {\n\t\tif (!test_bit(idx, &spec->pcm_bitmap))\n\t\t\tgoto found;\n\t\tper_pin->prev_pcm_idx = -1;  \n\t}\n\tidx = hdmi_find_pcm_slot(spec, per_pin);\n\tif (idx == -EBUSY)\n\t\treturn;\n found:\n\tper_pin->pcm_idx = idx;\n\tper_pin->pcm = get_hdmi_pcm(spec, idx);\n\tset_bit(idx, &spec->pcm_bitmap);\n}\n\nstatic void hdmi_detach_hda_pcm(struct hdmi_spec *spec,\n\t\t\t\tstruct hdmi_spec_per_pin *per_pin)\n{\n\tint idx;\n\n\t \n\tif (!per_pin->pcm)\n\t\treturn;\n\tidx = per_pin->pcm_idx;\n\tper_pin->pcm_idx = -1;\n\tper_pin->prev_pcm_idx = idx;  \n\tper_pin->pcm = NULL;\n\tif (idx >= 0 && idx < spec->pcm_used)\n\t\tclear_bit(idx, &spec->pcm_bitmap);\n}\n\nstatic int hdmi_get_pin_cvt_mux(struct hdmi_spec *spec,\n\t\tstruct hdmi_spec_per_pin *per_pin, hda_nid_t cvt_nid)\n{\n\tint mux_idx;\n\n\tfor (mux_idx = 0; mux_idx < per_pin->num_mux_nids; mux_idx++)\n\t\tif (per_pin->mux_nids[mux_idx] == cvt_nid)\n\t\t\tbreak;\n\treturn mux_idx;\n}\n\nstatic bool check_non_pcm_per_cvt(struct hda_codec *codec, hda_nid_t cvt_nid);\n\nstatic void hdmi_pcm_setup_pin(struct hdmi_spec *spec,\n\t\t\t   struct hdmi_spec_per_pin *per_pin)\n{\n\tstruct hda_codec *codec = per_pin->codec;\n\tstruct hda_pcm *pcm;\n\tstruct hda_pcm_stream *hinfo;\n\tstruct snd_pcm_substream *substream;\n\tint mux_idx;\n\tbool non_pcm;\n\n\tif (per_pin->pcm_idx < 0 || per_pin->pcm_idx >= spec->pcm_used)\n\t\treturn;\n\tpcm = get_pcm_rec(spec, per_pin->pcm_idx);\n\tif (!pcm->pcm)\n\t\treturn;\n\tif (!test_bit(per_pin->pcm_idx, &spec->pcm_in_use))\n\t\treturn;\n\n\t \n\thinfo = pcm->stream;\n\tsubstream = pcm->pcm->streams[0].substream;\n\n\tper_pin->cvt_nid = hinfo->nid;\n\n\tmux_idx = hdmi_get_pin_cvt_mux(spec, per_pin, hinfo->nid);\n\tif (mux_idx < per_pin->num_mux_nids) {\n\t\tsnd_hda_set_dev_select(codec, per_pin->pin_nid,\n\t\t\t\t   per_pin->dev_id);\n\t\tsnd_hda_codec_write_cache(codec, per_pin->pin_nid, 0,\n\t\t\t\tAC_VERB_SET_CONNECT_SEL,\n\t\t\t\tmux_idx);\n\t}\n\tsnd_hda_spdif_ctls_assign(codec, per_pin->pcm_idx, hinfo->nid);\n\n\tnon_pcm = check_non_pcm_per_cvt(codec, hinfo->nid);\n\tif (substream->runtime)\n\t\tper_pin->channels = substream->runtime->channels;\n\tper_pin->setup = true;\n\tper_pin->mux_idx = mux_idx;\n\n\thdmi_setup_audio_infoframe(codec, per_pin, non_pcm);\n}\n\nstatic void hdmi_pcm_reset_pin(struct hdmi_spec *spec,\n\t\t\t   struct hdmi_spec_per_pin *per_pin)\n{\n\tif (per_pin->pcm_idx >= 0 && per_pin->pcm_idx < spec->pcm_used)\n\t\tsnd_hda_spdif_ctls_unassign(per_pin->codec, per_pin->pcm_idx);\n\n\tper_pin->chmap_set = false;\n\tmemset(per_pin->chmap, 0, sizeof(per_pin->chmap));\n\n\tper_pin->setup = false;\n\tper_pin->channels = 0;\n}\n\nstatic struct snd_jack *pin_idx_to_pcm_jack(struct hda_codec *codec,\n\t\t\t\t\t    struct hdmi_spec_per_pin *per_pin)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tif (per_pin->pcm_idx >= 0)\n\t\treturn spec->pcm_rec[per_pin->pcm_idx].jack;\n\telse\n\t\treturn NULL;\n}\n\n \nstatic void update_eld(struct hda_codec *codec,\n\t\t       struct hdmi_spec_per_pin *per_pin,\n\t\t       struct hdmi_eld *eld,\n\t\t       int repoll)\n{\n\tstruct hdmi_eld *pin_eld = &per_pin->sink_eld;\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct snd_jack *pcm_jack;\n\tbool old_eld_valid = pin_eld->eld_valid;\n\tbool eld_changed;\n\tint pcm_idx;\n\n\tif (eld->eld_valid) {\n\t\tif (eld->eld_size <= 0 ||\n\t\t    snd_hdmi_parse_eld(codec, &eld->info, eld->eld_buffer,\n\t\t\t\t       eld->eld_size) < 0) {\n\t\t\teld->eld_valid = false;\n\t\t\tif (repoll) {\n\t\t\t\tschedule_delayed_work(&per_pin->work,\n\t\t\t\t\t\t      msecs_to_jiffies(300));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!eld->eld_valid || eld->eld_size <= 0 || eld->info.sad_count <= 0) {\n\t\teld->eld_valid = false;\n\t\teld->eld_size = 0;\n\t}\n\n\t \n\tpcm_idx = per_pin->pcm_idx;\n\n\t \n\tpcm_jack = pin_idx_to_pcm_jack(codec, per_pin);\n\n\tif (!spec->static_pcm_mapping) {\n\t\tif (eld->eld_valid) {\n\t\t\thdmi_attach_hda_pcm(spec, per_pin);\n\t\t\thdmi_pcm_setup_pin(spec, per_pin);\n\t\t} else {\n\t\t\thdmi_pcm_reset_pin(spec, per_pin);\n\t\t\thdmi_detach_hda_pcm(spec, per_pin);\n\t\t}\n\t}\n\n\t \n\tif (pcm_idx == -1)\n\t\tpcm_idx = per_pin->pcm_idx;\n\tif (!pcm_jack)\n\t\tpcm_jack = pin_idx_to_pcm_jack(codec, per_pin);\n\n\tif (eld->eld_valid)\n\t\tsnd_hdmi_show_eld(codec, &eld->info);\n\n\teld_changed = (pin_eld->eld_valid != eld->eld_valid);\n\teld_changed |= (pin_eld->monitor_present != eld->monitor_present);\n\tif (!eld_changed && eld->eld_valid && pin_eld->eld_valid)\n\t\tif (pin_eld->eld_size != eld->eld_size ||\n\t\t    memcmp(pin_eld->eld_buffer, eld->eld_buffer,\n\t\t\t   eld->eld_size) != 0)\n\t\t\teld_changed = true;\n\n\tif (eld_changed) {\n\t\tpin_eld->monitor_present = eld->monitor_present;\n\t\tpin_eld->eld_valid = eld->eld_valid;\n\t\tpin_eld->eld_size = eld->eld_size;\n\t\tif (eld->eld_valid)\n\t\t\tmemcpy(pin_eld->eld_buffer, eld->eld_buffer,\n\t\t\t       eld->eld_size);\n\t\tpin_eld->info = eld->info;\n\t}\n\n\t \n\tif (eld->eld_valid && !old_eld_valid && per_pin->setup) {\n\t\tpin_cvt_fixup(codec, per_pin, 0);\n\t\thdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);\n\t}\n\n\tif (eld_changed && pcm_idx >= 0)\n\t\tsnd_ctl_notify(codec->card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &get_hdmi_pcm(spec, pcm_idx)->eld_ctl->id);\n\n\tif (eld_changed && pcm_jack)\n\t\tsnd_jack_report(pcm_jack,\n\t\t\t\t(eld->monitor_present && eld->eld_valid) ?\n\t\t\t\tSND_JACK_AVOUT : 0);\n}\n\n \nstatic void hdmi_present_sense_via_verbs(struct hdmi_spec_per_pin *per_pin,\n\t\t\t\t\t int repoll)\n{\n\tstruct hda_codec *codec = per_pin->codec;\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_eld *eld = &spec->temp_eld;\n\tstruct device *dev = hda_codec_dev(codec);\n\thda_nid_t pin_nid = per_pin->pin_nid;\n\tint dev_id = per_pin->dev_id;\n\t \n\tint present;\n\tint ret;\n\n#ifdef\tCONFIG_PM\n\tif (dev->power.runtime_status == RPM_SUSPENDING)\n\t\treturn;\n#endif\n\n\tret = snd_hda_power_up_pm(codec);\n\tif (ret < 0 && pm_runtime_suspended(dev))\n\t\tgoto out;\n\n\tpresent = snd_hda_jack_pin_sense(codec, pin_nid, dev_id);\n\n\tmutex_lock(&per_pin->lock);\n\teld->monitor_present = !!(present & AC_PINSENSE_PRESENCE);\n\tif (eld->monitor_present)\n\t\teld->eld_valid  = !!(present & AC_PINSENSE_ELDV);\n\telse\n\t\teld->eld_valid = false;\n\n\tcodec_dbg(codec,\n\t\t\"HDMI status: Codec=%d NID=0x%x Presence_Detect=%d ELD_Valid=%d\\n\",\n\t\tcodec->addr, pin_nid, eld->monitor_present, eld->eld_valid);\n\n\tif (eld->eld_valid) {\n\t\tif (spec->ops.pin_get_eld(codec, pin_nid, dev_id,\n\t\t\t\t\t  eld->eld_buffer, &eld->eld_size) < 0)\n\t\t\teld->eld_valid = false;\n\t}\n\n\tupdate_eld(codec, per_pin, eld, repoll);\n\tmutex_unlock(&per_pin->lock);\n out:\n\tsnd_hda_power_down_pm(codec);\n}\n\n#define I915_SILENT_RATE\t\t48000\n#define I915_SILENT_CHANNELS\t\t2\n#define I915_SILENT_FORMAT\t\tSNDRV_PCM_FORMAT_S16_LE\n#define I915_SILENT_FORMAT_BITS\t16\n#define I915_SILENT_FMT_MASK\t\t0xf\n\nstatic void silent_stream_enable_i915(struct hda_codec *codec,\n\t\t\t\t      struct hdmi_spec_per_pin *per_pin)\n{\n\tunsigned int format;\n\n\tsnd_hdac_sync_audio_rate(&codec->core, per_pin->pin_nid,\n\t\t\t\t per_pin->dev_id, I915_SILENT_RATE);\n\n\t \n\tformat = snd_hdac_calc_stream_format(I915_SILENT_RATE, I915_SILENT_CHANNELS,\n\t\t\t\t\t     I915_SILENT_FORMAT, I915_SILENT_FORMAT_BITS, 0);\n\tsnd_hda_codec_setup_stream(codec, per_pin->cvt_nid,\n\t\t\t\t   I915_SILENT_FMT_MASK, I915_SILENT_FMT_MASK, format);\n\tusleep_range(100, 200);\n\tsnd_hda_codec_setup_stream(codec, per_pin->cvt_nid, I915_SILENT_FMT_MASK, 0, format);\n\n\tper_pin->channels = I915_SILENT_CHANNELS;\n\thdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);\n}\n\nstatic void silent_stream_set_kae(struct hda_codec *codec,\n\t\t\t\t  struct hdmi_spec_per_pin *per_pin,\n\t\t\t\t  bool enable)\n{\n\tunsigned int param;\n\n\tcodec_dbg(codec, \"HDMI: KAE %d cvt-NID=0x%x\\n\", enable, per_pin->cvt_nid);\n\n\tparam = snd_hda_codec_read(codec, per_pin->cvt_nid, 0, AC_VERB_GET_DIGI_CONVERT_1, 0);\n\tparam = (param >> 16) & 0xff;\n\n\tif (enable)\n\t\tparam |= AC_DIG3_KAE;\n\telse\n\t\tparam &= ~AC_DIG3_KAE;\n\n\tsnd_hda_codec_write(codec, per_pin->cvt_nid, 0, AC_VERB_SET_DIGI_CONVERT_3, param);\n}\n\nstatic void silent_stream_enable(struct hda_codec *codec,\n\t\t\t\t struct hdmi_spec_per_pin *per_pin)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tint cvt_idx, pin_idx, err;\n\tint keep_power = 0;\n\n\t \n\n\terr = snd_hda_power_up_pm(codec);\n\tif (err < 0 && err != -EACCES) {\n\t\tcodec_err(codec,\n\t\t\t  \"Failed to power up codec for silent stream enable ret=[%d]\\n\", err);\n\t\tsnd_hda_power_down_pm(codec);\n\t\treturn;\n\t}\n\n\tmutex_lock(&per_pin->lock);\n\n\tif (per_pin->setup) {\n\t\tcodec_dbg(codec, \"hdmi: PCM already open, no silent stream\\n\");\n\t\terr = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\tpin_idx = pin_id_to_pin_index(codec, per_pin->pin_nid, per_pin->dev_id);\n\terr = hdmi_choose_cvt(codec, pin_idx, &cvt_idx, true);\n\tif (err) {\n\t\tcodec_err(codec, \"hdmi: no free converter to enable silent mode\\n\");\n\t\tgoto unlock_out;\n\t}\n\n\tper_cvt = get_cvt(spec, cvt_idx);\n\tper_cvt->silent_stream = true;\n\tper_pin->cvt_nid = per_cvt->cvt_nid;\n\tper_pin->silent_stream = true;\n\n\tcodec_dbg(codec, \"hdmi: enabling silent stream pin-NID=0x%x cvt-NID=0x%x\\n\",\n\t\t  per_pin->pin_nid, per_cvt->cvt_nid);\n\n\tsnd_hda_set_dev_select(codec, per_pin->pin_nid, per_pin->dev_id);\n\tsnd_hda_codec_write_cache(codec, per_pin->pin_nid, 0,\n\t\t\t\t  AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t  per_pin->mux_idx);\n\n\t \n\tpin_cvt_fixup(codec, per_pin, 0);\n\n\tswitch (spec->silent_stream_type) {\n\tcase SILENT_STREAM_KAE:\n\t\tsilent_stream_enable_i915(codec, per_pin);\n\t\tsilent_stream_set_kae(codec, per_pin, true);\n\t\tbreak;\n\tcase SILENT_STREAM_I915:\n\t\tsilent_stream_enable_i915(codec, per_pin);\n\t\tkeep_power = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n unlock_out:\n\tmutex_unlock(&per_pin->lock);\n\n\tif (err || !keep_power)\n\t\tsnd_hda_power_down_pm(codec);\n}\n\nstatic void silent_stream_disable(struct hda_codec *codec,\n\t\t\t\t  struct hdmi_spec_per_pin *per_pin)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tint cvt_idx, err;\n\n\terr = snd_hda_power_up_pm(codec);\n\tif (err < 0 && err != -EACCES) {\n\t\tcodec_err(codec,\n\t\t\t  \"Failed to power up codec for silent stream disable ret=[%d]\\n\",\n\t\t\t  err);\n\t\tsnd_hda_power_down_pm(codec);\n\t\treturn;\n\t}\n\n\tmutex_lock(&per_pin->lock);\n\tif (!per_pin->silent_stream)\n\t\tgoto unlock_out;\n\n\tcodec_dbg(codec, \"HDMI: disable silent stream on pin-NID=0x%x cvt-NID=0x%x\\n\",\n\t\t  per_pin->pin_nid, per_pin->cvt_nid);\n\n\tcvt_idx = cvt_nid_to_cvt_index(codec, per_pin->cvt_nid);\n\tif (cvt_idx >= 0 && cvt_idx < spec->num_cvts) {\n\t\tper_cvt = get_cvt(spec, cvt_idx);\n\t\tper_cvt->silent_stream = false;\n\t}\n\n\tif (spec->silent_stream_type == SILENT_STREAM_I915) {\n\t\t \n\t\tsnd_hda_power_down_pm(codec);\n\t} else if (spec->silent_stream_type == SILENT_STREAM_KAE) {\n\t\tsilent_stream_set_kae(codec, per_pin, false);\n\t}\n\n\tper_pin->cvt_nid = 0;\n\tper_pin->silent_stream = false;\n\n unlock_out:\n\tmutex_unlock(&per_pin->lock);\n\n\tsnd_hda_power_down_pm(codec);\n}\n\n \nstatic void sync_eld_via_acomp(struct hda_codec *codec,\n\t\t\t       struct hdmi_spec_per_pin *per_pin)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_eld *eld = &spec->temp_eld;\n\tbool monitor_prev, monitor_next;\n\n\tmutex_lock(&per_pin->lock);\n\teld->monitor_present = false;\n\tmonitor_prev = per_pin->sink_eld.monitor_present;\n\teld->eld_size = snd_hdac_acomp_get_eld(&codec->core, per_pin->pin_nid,\n\t\t\t\t      per_pin->dev_id, &eld->monitor_present,\n\t\t\t\t      eld->eld_buffer, ELD_MAX_SIZE);\n\teld->eld_valid = (eld->eld_size > 0);\n\tupdate_eld(codec, per_pin, eld, 0);\n\tmonitor_next = per_pin->sink_eld.monitor_present;\n\tmutex_unlock(&per_pin->lock);\n\n\tif (spec->silent_stream_type) {\n\t\tif (!monitor_prev && monitor_next)\n\t\t\tsilent_stream_enable(codec, per_pin);\n\t\telse if (monitor_prev && !monitor_next)\n\t\t\tsilent_stream_disable(codec, per_pin);\n\t}\n}\n\nstatic void hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)\n{\n\tstruct hda_codec *codec = per_pin->codec;\n\n\tif (!codec_has_acomp(codec))\n\t\thdmi_present_sense_via_verbs(per_pin, repoll);\n\telse\n\t\tsync_eld_via_acomp(codec, per_pin);\n}\n\nstatic void hdmi_repoll_eld(struct work_struct *work)\n{\n\tstruct hdmi_spec_per_pin *per_pin =\n\tcontainer_of(to_delayed_work(work), struct hdmi_spec_per_pin, work);\n\tstruct hda_codec *codec = per_pin->codec;\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hda_jack_tbl *jack;\n\n\tjack = snd_hda_jack_tbl_get_mst(codec, per_pin->pin_nid,\n\t\t\t\t\tper_pin->dev_id);\n\tif (jack)\n\t\tjack->jack_dirty = 1;\n\n\tif (per_pin->repoll_count++ > 6)\n\t\tper_pin->repoll_count = 0;\n\n\tmutex_lock(&spec->pcm_lock);\n\thdmi_present_sense(per_pin, per_pin->repoll_count);\n\tmutex_unlock(&spec->pcm_lock);\n}\n\nstatic int hdmi_add_pin(struct hda_codec *codec, hda_nid_t pin_nid)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tunsigned int caps, config;\n\tint pin_idx;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tint err;\n\tint dev_num, i;\n\n\tcaps = snd_hda_query_pin_caps(codec, pin_nid);\n\tif (!(caps & (AC_PINCAP_HDMI | AC_PINCAP_DP)))\n\t\treturn 0;\n\n\t \n\tconfig = snd_hda_codec_get_pincfg(codec, pin_nid);\n\tif (get_defcfg_connect(config) == AC_JACK_PORT_NONE &&\n\t    !spec->force_connect)\n\t\treturn 0;\n\n\t \n\tif (spec->intel_hsw_fixup) {\n\t\t \n\t\tdev_num = spec->dev_num;\n\t} else if (codec->dp_mst) {\n\t\tdev_num = snd_hda_get_num_devices(codec, pin_nid) + 1;\n\t\t \n\t\tspec->dev_num = (spec->dev_num > dev_num) ?\n\t\t\tspec->dev_num : dev_num;\n\t} else {\n\t\t \n\t\tdev_num = 1;\n\t\tspec->dev_num = 1;\n\t}\n\n\tfor (i = 0; i < dev_num; i++) {\n\t\tpin_idx = spec->num_pins;\n\t\tper_pin = snd_array_new(&spec->pins);\n\n\t\tif (!per_pin)\n\t\t\treturn -ENOMEM;\n\n\t\tper_pin->pcm = NULL;\n\t\tper_pin->pcm_idx = -1;\n\t\tper_pin->prev_pcm_idx = -1;\n\t\tper_pin->pin_nid = pin_nid;\n\t\tper_pin->pin_nid_idx = spec->num_nids;\n\t\tper_pin->dev_id = i;\n\t\tper_pin->non_pcm = false;\n\t\tsnd_hda_set_dev_select(codec, pin_nid, i);\n\t\terr = hdmi_read_pin_conn(codec, pin_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!is_jack_detectable(codec, pin_nid))\n\t\t\tcodec_warn(codec, \"HDMI: pin NID 0x%x - jack not detectable\\n\", pin_nid);\n\t\tspec->num_pins++;\n\t}\n\tspec->num_nids++;\n\n\treturn 0;\n}\n\nstatic int hdmi_add_cvt(struct hda_codec *codec, hda_nid_t cvt_nid)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tunsigned int chans;\n\tint err;\n\n\tchans = get_wcaps(codec, cvt_nid);\n\tchans = get_wcaps_channels(chans);\n\n\tper_cvt = snd_array_new(&spec->cvts);\n\tif (!per_cvt)\n\t\treturn -ENOMEM;\n\n\tper_cvt->cvt_nid = cvt_nid;\n\tper_cvt->channels_min = 2;\n\tif (chans <= 16) {\n\t\tper_cvt->channels_max = chans;\n\t\tif (chans > spec->chmap.channels_max)\n\t\t\tspec->chmap.channels_max = chans;\n\t}\n\n\terr = snd_hda_query_supported_pcm(codec, cvt_nid,\n\t\t\t\t\t  &per_cvt->rates,\n\t\t\t\t\t  &per_cvt->formats,\n\t\t\t\t\t  &per_cvt->maxbps);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (spec->num_cvts < ARRAY_SIZE(spec->cvt_nids))\n\t\tspec->cvt_nids[spec->num_cvts] = cvt_nid;\n\tspec->num_cvts++;\n\n\treturn 0;\n}\n\nstatic const struct snd_pci_quirk force_connect_list[] = {\n\tSND_PCI_QUIRK(0x103c, 0x870f, \"HP\", 1),\n\tSND_PCI_QUIRK(0x103c, 0x871a, \"HP\", 1),\n\tSND_PCI_QUIRK(0x103c, 0x8711, \"HP\", 1),\n\tSND_PCI_QUIRK(0x103c, 0x8715, \"HP\", 1),\n\tSND_PCI_QUIRK(0x1043, 0x86ae, \"ASUS\", 1),   \n\tSND_PCI_QUIRK(0x1043, 0x86c7, \"ASUS\", 1),   \n\tSND_PCI_QUIRK(0x1462, 0xec94, \"MS-7C94\", 1),\n\tSND_PCI_QUIRK(0x8086, 0x2060, \"Intel NUC5CPYB\", 1),\n\tSND_PCI_QUIRK(0x8086, 0x2081, \"Intel NUC 10\", 1),\n\t{}\n};\n\nstatic int hdmi_parse_codec(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\thda_nid_t start_nid;\n\tunsigned int caps;\n\tint i, nodes;\n\tconst struct snd_pci_quirk *q;\n\n\tnodes = snd_hda_get_sub_nodes(codec, codec->core.afg, &start_nid);\n\tif (!start_nid || nodes < 0) {\n\t\tcodec_warn(codec, \"HDMI: failed to get afg sub nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable_all_pins)\n\t\tspec->force_connect = true;\n\n\tq = snd_pci_quirk_lookup(codec->bus->pci, force_connect_list);\n\n\tif (q && q->value)\n\t\tspec->force_connect = true;\n\n\t \n\tfor (i = 0; i < nodes; i++) {\n\t\thda_nid_t nid = start_nid + i;\n\n\t\tcaps = get_wcaps(codec, nid);\n\n\t\tif (!(caps & AC_WCAP_DIGITAL))\n\t\t\tcontinue;\n\n\t\tif (get_wcaps_type(caps) == AC_WID_AUD_OUT)\n\t\t\thdmi_add_cvt(codec, nid);\n\t}\n\n\t \n\tfor (i = 0; i < nodes; i++) {\n\t\thda_nid_t nid = start_nid + i;\n\n\t\tcaps = get_wcaps(codec, nid);\n\n\t\tif (!(caps & AC_WCAP_DIGITAL))\n\t\t\tcontinue;\n\n\t\tif (get_wcaps_type(caps) == AC_WID_PIN)\n\t\t\thdmi_add_pin(codec, nid);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool check_non_pcm_per_cvt(struct hda_codec *codec, hda_nid_t cvt_nid)\n{\n\tstruct hda_spdif_out *spdif;\n\tbool non_pcm;\n\n\tmutex_lock(&codec->spdif_mutex);\n\tspdif = snd_hda_spdif_out_of_nid(codec, cvt_nid);\n\t \n\tif (WARN_ON(spdif == NULL)) {\n\t\tmutex_unlock(&codec->spdif_mutex);\n\t\treturn true;\n\t}\n\tnon_pcm = !!(spdif->status & IEC958_AES0_NONAUDIO);\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn non_pcm;\n}\n\n \n\nstatic int generic_hdmi_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t\t   unsigned int stream_tag,\n\t\t\t\t\t   unsigned int format,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\thda_nid_t cvt_nid = hinfo->nid;\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tbool non_pcm;\n\tint pinctl, stripe;\n\tint err = 0;\n\n\tmutex_lock(&spec->pcm_lock);\n\tpin_idx = hinfo_to_pin_index(codec, hinfo);\n\tif (pin_idx < 0) {\n\t\t \n\t\tpin_cvt_fixup(codec, NULL, cvt_nid);\n\t\tsnd_hda_codec_setup_stream(codec, cvt_nid,\n\t\t\t\t\tstream_tag, 0, format);\n\t\tgoto unlock;\n\t}\n\n\tper_pin = get_pin(spec, pin_idx);\n\n\t \n\tpin_cvt_fixup(codec, per_pin, 0);\n\n\t \n\t \n\tif (codec_has_acomp(codec))\n\t\tsnd_hdac_sync_audio_rate(&codec->core, per_pin->pin_nid,\n\t\t\t\t\t per_pin->dev_id, runtime->rate);\n\n\tnon_pcm = check_non_pcm_per_cvt(codec, cvt_nid);\n\tmutex_lock(&per_pin->lock);\n\tper_pin->channels = substream->runtime->channels;\n\tper_pin->setup = true;\n\n\tif (get_wcaps(codec, cvt_nid) & AC_WCAP_STRIPE) {\n\t\tstripe = snd_hdac_get_stream_stripe_ctl(&codec->bus->core,\n\t\t\t\t\t\t\tsubstream);\n\t\tsnd_hda_codec_write(codec, cvt_nid, 0,\n\t\t\t\t    AC_VERB_SET_STRIPE_CONTROL,\n\t\t\t\t    stripe);\n\t}\n\n\thdmi_setup_audio_infoframe(codec, per_pin, non_pcm);\n\tmutex_unlock(&per_pin->lock);\n\tif (spec->dyn_pin_out) {\n\t\tsnd_hda_set_dev_select(codec, per_pin->pin_nid,\n\t\t\t\t       per_pin->dev_id);\n\t\tpinctl = snd_hda_codec_read(codec, per_pin->pin_nid, 0,\n\t\t\t\t\t    AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\tsnd_hda_codec_write(codec, per_pin->pin_nid, 0,\n\t\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t    pinctl | PIN_OUT);\n\t}\n\n\t \n\terr = spec->ops.setup_stream(codec, cvt_nid, per_pin->pin_nid,\n\t\t\t\t     per_pin->dev_id, stream_tag, format);\n unlock:\n\tmutex_unlock(&spec->pcm_lock);\n\treturn err;\n}\n\nstatic int generic_hdmi_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t\t     struct hda_codec *codec,\n\t\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\n\treturn 0;\n}\n\nstatic int hdmi_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t  struct hda_codec *codec,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint cvt_idx, pin_idx, pcm_idx;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tstruct hdmi_spec_per_pin *per_pin;\n\tint pinctl;\n\tint err = 0;\n\n\tmutex_lock(&spec->pcm_lock);\n\tif (hinfo->nid) {\n\t\tpcm_idx = hinfo_to_pcm_index(codec, hinfo);\n\t\tif (snd_BUG_ON(pcm_idx < 0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tcvt_idx = cvt_nid_to_cvt_index(codec, hinfo->nid);\n\t\tif (snd_BUG_ON(cvt_idx < 0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tper_cvt = get_cvt(spec, cvt_idx);\n\t\tper_cvt->assigned = false;\n\t\thinfo->nid = 0;\n\n\t\tazx_stream(get_azx_dev(substream))->stripe = 0;\n\n\t\tsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\n\t\tclear_bit(pcm_idx, &spec->pcm_in_use);\n\t\tpin_idx = hinfo_to_pin_index(codec, hinfo);\n\t\t \n\t\tif (pin_idx < 0)\n\t\t\tgoto unlock;\n\n\t\tper_pin = get_pin(spec, pin_idx);\n\n\t\tif (spec->dyn_pin_out) {\n\t\t\tsnd_hda_set_dev_select(codec, per_pin->pin_nid,\n\t\t\t\t\t       per_pin->dev_id);\n\t\t\tpinctl = snd_hda_codec_read(codec, per_pin->pin_nid, 0,\n\t\t\t\t\tAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\t\t\tsnd_hda_codec_write(codec, per_pin->pin_nid, 0,\n\t\t\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t\t    pinctl & ~PIN_OUT);\n\t\t}\n\n\t\tmutex_lock(&per_pin->lock);\n\t\tper_pin->chmap_set = false;\n\t\tmemset(per_pin->chmap, 0, sizeof(per_pin->chmap));\n\n\t\tper_pin->setup = false;\n\t\tper_pin->channels = 0;\n\t\tmutex_unlock(&per_pin->lock);\n\t}\n\nunlock:\n\tmutex_unlock(&spec->pcm_lock);\n\n\treturn err;\n}\n\nstatic const struct hda_pcm_ops generic_ops = {\n\t.open = hdmi_pcm_open,\n\t.close = hdmi_pcm_close,\n\t.prepare = generic_hdmi_playback_pcm_prepare,\n\t.cleanup = generic_hdmi_playback_pcm_cleanup,\n};\n\nstatic int hdmi_get_spk_alloc(struct hdac_device *hdac, int pcm_idx)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\n\n\tif (!per_pin)\n\t\treturn 0;\n\n\treturn per_pin->sink_eld.info.spk_alloc;\n}\n\nstatic void hdmi_get_chmap(struct hdac_device *hdac, int pcm_idx,\n\t\t\t\t\tunsigned char *chmap)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\n\n\t \n\tif (!per_pin)\n\t\treturn;\n\n\tmemcpy(chmap, per_pin->chmap, ARRAY_SIZE(per_pin->chmap));\n}\n\nstatic void hdmi_set_chmap(struct hdac_device *hdac, int pcm_idx,\n\t\t\t\tunsigned char *chmap, int prepared)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\n\n\tif (!per_pin)\n\t\treturn;\n\tmutex_lock(&per_pin->lock);\n\tper_pin->chmap_set = true;\n\tmemcpy(per_pin->chmap, chmap, ARRAY_SIZE(per_pin->chmap));\n\tif (prepared)\n\t\thdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);\n\tmutex_unlock(&per_pin->lock);\n}\n\nstatic bool is_hdmi_pcm_attached(struct hdac_device *hdac, int pcm_idx)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\n\n\treturn per_pin ? true:false;\n}\n\nstatic int generic_hdmi_build_pcms(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint idx, pcm_num;\n\n\t \n\tpcm_num = min(spec->num_cvts, spec->num_pins);\n\tcodec_dbg(codec, \"hdmi: pcm_num set to %d\\n\", pcm_num);\n\n\tfor (idx = 0; idx < pcm_num; idx++) {\n\t\tstruct hdmi_spec_per_cvt *per_cvt;\n\t\tstruct hda_pcm *info;\n\t\tstruct hda_pcm_stream *pstr;\n\n\t\tinfo = snd_hda_codec_pcm_new(codec, \"HDMI %d\", idx);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\n\t\tspec->pcm_rec[idx].pcm = info;\n\t\tspec->pcm_used++;\n\t\tinfo->pcm_type = HDA_PCM_TYPE_HDMI;\n\t\tinfo->own_chmap = true;\n\n\t\tpstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tpstr->substreams = 1;\n\t\tpstr->ops = generic_ops;\n\n\t\tper_cvt = get_cvt(spec, 0);\n\t\tpstr->channels_min = per_cvt->channels_min;\n\t\tpstr->channels_max = per_cvt->channels_max;\n\n\t\t \n\t\tif (spec->pcm_used >= ARRAY_SIZE(spec->pcm_rec))\n\t\t\tbreak;\n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic void free_hdmi_jack_priv(struct snd_jack *jack)\n{\n\tstruct hdmi_pcm *pcm = jack->private_data;\n\n\tpcm->jack = NULL;\n}\n\nstatic int generic_hdmi_build_jack(struct hda_codec *codec, int pcm_idx)\n{\n\tchar hdmi_str[32] = \"HDMI/DP\";\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct snd_jack *jack;\n\tint pcmdev = get_pcm_rec(spec, pcm_idx)->device;\n\tint err;\n\n\tif (pcmdev > 0)\n\t\tsprintf(hdmi_str + strlen(hdmi_str), \",pcm=%d\", pcmdev);\n\n\terr = snd_jack_new(codec->card, hdmi_str, SND_JACK_AVOUT, &jack,\n\t\t\t   true, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tspec->pcm_rec[pcm_idx].jack = jack;\n\tjack->private_data = &spec->pcm_rec[pcm_idx];\n\tjack->private_free = free_hdmi_jack_priv;\n\treturn 0;\n}\n\nstatic int generic_hdmi_build_controls(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint dev, err;\n\tint pin_idx, pcm_idx;\n\n\tfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\n\t\tif (!get_pcm_rec(spec, pcm_idx)->pcm) {\n\t\t\t \n\t\t\tset_bit(pcm_idx, &spec->pcm_bitmap);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = generic_hdmi_build_jack(codec, pcm_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = snd_hda_create_dig_out_ctls(codec,\n\t\t\t\t\t  0, spec->cvt_nids[0],\n\t\t\t\t\t  HDA_PCM_TYPE_HDMI);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\n\n\t\tdev = get_pcm_rec(spec, pcm_idx)->device;\n\t\tif (dev != SNDRV_PCM_INVALID_DEVICE) {\n\t\t\t \n\t\t\terr = hdmi_create_eld_ctl(codec, pcm_idx, dev);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\t\tstruct hdmi_eld *pin_eld = &per_pin->sink_eld;\n\n\t\tif (spec->static_pcm_mapping) {\n\t\t\thdmi_attach_hda_pcm(spec, per_pin);\n\t\t\thdmi_pcm_setup_pin(spec, per_pin);\n\t\t}\n\n\t\tpin_eld->eld_valid = false;\n\t\thdmi_present_sense(per_pin, 0);\n\t}\n\n\t \n\tfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\n\t\tstruct hda_pcm *pcm;\n\n\t\tpcm = get_pcm_rec(spec, pcm_idx);\n\t\tif (!pcm || !pcm->pcm)\n\t\t\tbreak;\n\t\terr = snd_hdac_add_chmap_ctls(pcm->pcm, pcm_idx, &spec->chmap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int generic_hdmi_init_per_pins(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\n\t\tper_pin->codec = codec;\n\t\tmutex_init(&per_pin->lock);\n\t\tINIT_DELAYED_WORK(&per_pin->work, hdmi_repoll_eld);\n\t\teld_proc_new(per_pin, pin_idx);\n\t}\n\treturn 0;\n}\n\nstatic int generic_hdmi_init(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\n\tmutex_lock(&spec->bind_lock);\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\t\thda_nid_t pin_nid = per_pin->pin_nid;\n\t\tint dev_id = per_pin->dev_id;\n\n\t\tsnd_hda_set_dev_select(codec, pin_nid, dev_id);\n\t\thdmi_init_pin(codec, pin_nid);\n\t\tif (codec_has_acomp(codec))\n\t\t\tcontinue;\n\t\tsnd_hda_jack_detect_enable_callback_mst(codec, pin_nid, dev_id,\n\t\t\t\t\t\t\tjack_callback);\n\t}\n\tmutex_unlock(&spec->bind_lock);\n\treturn 0;\n}\n\nstatic void hdmi_array_init(struct hdmi_spec *spec, int nums)\n{\n\tsnd_array_init(&spec->pins, sizeof(struct hdmi_spec_per_pin), nums);\n\tsnd_array_init(&spec->cvts, sizeof(struct hdmi_spec_per_cvt), nums);\n}\n\nstatic void hdmi_array_free(struct hdmi_spec *spec)\n{\n\tsnd_array_free(&spec->pins);\n\tsnd_array_free(&spec->cvts);\n}\n\nstatic void generic_spec_free(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tif (spec) {\n\t\thdmi_array_free(spec);\n\t\tkfree(spec);\n\t\tcodec->spec = NULL;\n\t}\n\tcodec->dp_mst = false;\n}\n\nstatic void generic_hdmi_free(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx, pcm_idx;\n\n\tif (spec->acomp_registered) {\n\t\tsnd_hdac_acomp_exit(&codec->bus->core);\n\t} else if (codec_has_acomp(codec)) {\n\t\tsnd_hdac_acomp_register_notifier(&codec->bus->core, NULL);\n\t}\n\tcodec->relaxed_resume = 0;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\t\tcancel_delayed_work_sync(&per_pin->work);\n\t\teld_proc_free(per_pin);\n\t}\n\n\tfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\n\t\tif (spec->pcm_rec[pcm_idx].jack == NULL)\n\t\t\tcontinue;\n\t\tsnd_device_free(codec->card, spec->pcm_rec[pcm_idx].jack);\n\t}\n\n\tgeneric_spec_free(codec);\n}\n\n#ifdef CONFIG_PM\nstatic int generic_hdmi_suspend(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\t\tcancel_delayed_work_sync(&per_pin->work);\n\t}\n\treturn 0;\n}\n\nstatic int generic_hdmi_resume(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx;\n\n\tcodec->patch_ops.init(codec);\n\tsnd_hda_regmap_sync(codec);\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\t\thdmi_present_sense(per_pin, 1);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic const struct hda_codec_ops generic_hdmi_patch_ops = {\n\t.init\t\t\t= generic_hdmi_init,\n\t.free\t\t\t= generic_hdmi_free,\n\t.build_pcms\t\t= generic_hdmi_build_pcms,\n\t.build_controls\t\t= generic_hdmi_build_controls,\n\t.unsol_event\t\t= hdmi_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend\t\t= generic_hdmi_suspend,\n\t.resume\t\t\t= generic_hdmi_resume,\n#endif\n};\n\nstatic const struct hdmi_ops generic_standard_hdmi_ops = {\n\t.pin_get_eld\t\t\t\t= hdmi_pin_get_eld,\n\t.pin_setup_infoframe\t\t\t= hdmi_pin_setup_infoframe,\n\t.pin_hbr_setup\t\t\t\t= hdmi_pin_hbr_setup,\n\t.setup_stream\t\t\t\t= hdmi_setup_stream,\n};\n\n \nstatic int alloc_generic_hdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tspec->codec = codec;\n\tspec->ops = generic_standard_hdmi_ops;\n\tspec->dev_num = 1;\t \n\tmutex_init(&spec->pcm_lock);\n\tmutex_init(&spec->bind_lock);\n\tsnd_hdac_register_chmap_ops(&codec->core, &spec->chmap);\n\n\tspec->chmap.ops.get_chmap = hdmi_get_chmap;\n\tspec->chmap.ops.set_chmap = hdmi_set_chmap;\n\tspec->chmap.ops.is_pcm_attached = is_hdmi_pcm_attached;\n\tspec->chmap.ops.get_spk_alloc = hdmi_get_spk_alloc;\n\n\tcodec->spec = spec;\n\thdmi_array_init(spec, 4);\n\n\tcodec->patch_ops = generic_hdmi_patch_ops;\n\n\treturn 0;\n}\n\n \nstatic int patch_generic_hdmi(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = alloc_generic_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = hdmi_parse_codec(codec);\n\tif (err < 0) {\n\t\tgeneric_spec_free(codec);\n\t\treturn err;\n\t}\n\n\tgeneric_hdmi_init_per_pins(codec);\n\treturn 0;\n}\n\n \n\n \nstatic void reprogram_jack_detect(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t  int dev_id, bool use_acomp)\n{\n\tstruct hda_jack_tbl *tbl;\n\n\ttbl = snd_hda_jack_tbl_get_mst(codec, nid, dev_id);\n\tif (tbl) {\n\t\t \n\t\tunsigned int val = use_acomp ? 0 : (AC_USRSP_EN | tbl->tag);\n\t\tsnd_hda_codec_write_cache(codec, nid, 0,\n\t\t\t\t\t  AC_VERB_SET_UNSOLICITED_ENABLE, val);\n\t}\n}\n\n \nstatic void generic_acomp_notifier_set(struct drm_audio_component *acomp,\n\t\t\t\t       bool use_acomp)\n{\n\tstruct hdmi_spec *spec;\n\tint i;\n\n\tspec = container_of(acomp->audio_ops, struct hdmi_spec, drm_audio_ops);\n\tmutex_lock(&spec->bind_lock);\n\tspec->use_acomp_notifier = use_acomp;\n\tspec->codec->relaxed_resume = use_acomp;\n\tspec->codec->bus->keep_power = 0;\n\t \n\tfor (i = 0; i < spec->num_pins; i++)\n\t\treprogram_jack_detect(spec->codec,\n\t\t\t\t      get_pin(spec, i)->pin_nid,\n\t\t\t\t      get_pin(spec, i)->dev_id,\n\t\t\t\t      use_acomp);\n\tmutex_unlock(&spec->bind_lock);\n}\n\n \nstatic int generic_acomp_master_bind(struct device *dev,\n\t\t\t\t     struct drm_audio_component *acomp)\n{\n\tgeneric_acomp_notifier_set(acomp, true);\n\treturn 0;\n}\n\nstatic void generic_acomp_master_unbind(struct device *dev,\n\t\t\t\t\tstruct drm_audio_component *acomp)\n{\n\tgeneric_acomp_notifier_set(acomp, false);\n}\n\n \nstatic int match_bound_vga(struct device *dev, int subtype, void *data)\n{\n\tstruct hdac_bus *bus = data;\n\tstruct pci_dev *pci, *master;\n\n\tif (!dev_is_pci(dev) || !dev_is_pci(bus->dev))\n\t\treturn 0;\n\tmaster = to_pci_dev(bus->dev);\n\tpci = to_pci_dev(dev);\n\treturn master->bus == pci->bus;\n}\n\n \nstatic void generic_acomp_pin_eld_notify(void *audio_ptr, int port, int dev_id)\n{\n\tstruct hda_codec *codec = audio_ptr;\n\tstruct hdmi_spec *spec = codec->spec;\n\thda_nid_t pin_nid = spec->port2pin(codec, port);\n\n\tif (!pin_nid)\n\t\treturn;\n\tif (get_wcaps_type(get_wcaps(codec, pin_nid)) != AC_WID_PIN)\n\t\treturn;\n\t \n\tif (codec->core.dev.power.power_state.event == PM_EVENT_SUSPEND)\n\t\treturn;\n\n\tcheck_presence_and_report(codec, pin_nid, dev_id);\n}\n\n \nstatic void setup_drm_audio_ops(struct hda_codec *codec,\n\t\t\t\tconst struct drm_audio_component_audio_ops *ops)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tspec->drm_audio_ops.audio_ptr = codec;\n\t \n\twmb();\n\tspec->drm_audio_ops.pin2port = ops->pin2port;\n\tspec->drm_audio_ops.pin_eld_notify = ops->pin_eld_notify;\n\tspec->drm_audio_ops.master_bind = ops->master_bind;\n\tspec->drm_audio_ops.master_unbind = ops->master_unbind;\n}\n\n \nstatic void generic_acomp_init(struct hda_codec *codec,\n\t\t\t       const struct drm_audio_component_audio_ops *ops,\n\t\t\t       int (*port2pin)(struct hda_codec *, int))\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tif (!enable_acomp) {\n\t\tcodec_info(codec, \"audio component disabled by module option\\n\");\n\t\treturn;\n\t}\n\n\tspec->port2pin = port2pin;\n\tsetup_drm_audio_ops(codec, ops);\n\tif (!snd_hdac_acomp_init(&codec->bus->core, &spec->drm_audio_ops,\n\t\t\t\t match_bound_vga, 0)) {\n\t\tspec->acomp_registered = true;\n\t}\n}\n\n \n\n#define INTEL_GET_VENDOR_VERB\t0xf81\n#define INTEL_SET_VENDOR_VERB\t0x781\n#define INTEL_EN_DP12\t\t0x02\t \n#define INTEL_EN_ALL_PIN_CVTS\t0x01\t \n\nstatic void intel_haswell_enable_all_pins(struct hda_codec *codec,\n\t\t\t\t\t  bool update_tree)\n{\n\tunsigned int vendor_param;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)\n\t\treturn;\n\n\tvendor_param |= INTEL_EN_ALL_PIN_CVTS;\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_SET_VENDOR_VERB, vendor_param);\n\tif (vendor_param == -1)\n\t\treturn;\n\n\tif (update_tree)\n\t\tsnd_hda_codec_update_widgets(codec);\n}\n\nstatic void intel_haswell_fixup_enable_dp12(struct hda_codec *codec)\n{\n\tunsigned int vendor_param;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tvendor_param = snd_hda_codec_read(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\n\t\treturn;\n\n\t \n\tvendor_param |= INTEL_EN_DP12;\n\tsnd_hdac_regmap_add_vendor_verb(&codec->core, INTEL_SET_VENDOR_VERB);\n\tsnd_hda_codec_write_cache(codec, spec->vendor_nid, 0,\n\t\t\t\tINTEL_SET_VENDOR_VERB, vendor_param);\n}\n\n \nstatic void haswell_set_power_state(struct hda_codec *codec, hda_nid_t fg,\n\t\t\t\tunsigned int power_state)\n{\n\tif (power_state == AC_PWRST_D0) {\n\t\tintel_haswell_enable_all_pins(codec, false);\n\t\tintel_haswell_fixup_enable_dp12(codec);\n\t}\n\n\tsnd_hda_codec_read(codec, fg, 0, AC_VERB_SET_POWER_STATE, power_state);\n\tsnd_hda_codec_set_power_to_all(codec, fg, power_state);\n}\n\n \nstatic int intel_base_nid(struct hda_codec *codec)\n{\n\tswitch (codec->core.vendor_id) {\n\tcase 0x80860054:  \n\tcase 0x80862804:  \n\tcase 0x80862882:  \n\t\treturn 4;\n\tdefault:\n\t\treturn 5;\n\t}\n}\n\nstatic int intel_pin2port(void *audio_ptr, int pin_nid)\n{\n\tstruct hda_codec *codec = audio_ptr;\n\tstruct hdmi_spec *spec = codec->spec;\n\tint base_nid, i;\n\n\tif (!spec->port_num) {\n\t\tbase_nid = intel_base_nid(codec);\n\t\tif (WARN_ON(pin_nid < base_nid || pin_nid >= base_nid + 3))\n\t\t\treturn -1;\n\t\treturn pin_nid - base_nid + 1;\n\t}\n\n\t \n\tfor (i = 0; i < spec->port_num; i++) {\n\t\tif (pin_nid == spec->port_map[i])\n\t\t\treturn i;\n\t}\n\n\tcodec_info(codec, \"Can't find the HDMI/DP port for pin NID 0x%x\\n\", pin_nid);\n\treturn -1;\n}\n\nstatic int intel_port2pin(struct hda_codec *codec, int port)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tif (!spec->port_num) {\n\t\t \n\t\tif (port < 1 || port > 3)\n\t\t\treturn 0;\n\t\treturn port + intel_base_nid(codec) - 1;\n\t}\n\n\tif (port < 0 || port >= spec->port_num)\n\t\treturn 0;\n\treturn spec->port_map[port];\n}\n\nstatic void intel_pin_eld_notify(void *audio_ptr, int port, int pipe)\n{\n\tstruct hda_codec *codec = audio_ptr;\n\tint pin_nid;\n\tint dev_id = pipe;\n\n\tpin_nid = intel_port2pin(codec, port);\n\tif (!pin_nid)\n\t\treturn;\n\t \n\tif (codec->core.dev.power.power_state.event == PM_EVENT_SUSPEND)\n\t\treturn;\n\n\tsnd_hdac_i915_set_bclk(&codec->bus->core);\n\tcheck_presence_and_report(codec, pin_nid, dev_id);\n}\n\nstatic const struct drm_audio_component_audio_ops intel_audio_ops = {\n\t.pin2port = intel_pin2port,\n\t.pin_eld_notify = intel_pin_eld_notify,\n};\n\n \nstatic void register_i915_notifier(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\tspec->use_acomp_notifier = true;\n\tspec->port2pin = intel_port2pin;\n\tsetup_drm_audio_ops(codec, &intel_audio_ops);\n\tsnd_hdac_acomp_register_notifier(&codec->bus->core,\n\t\t\t\t\t&spec->drm_audio_ops);\n\t \n\tcodec->relaxed_resume = 1;\n}\n\n \nstatic int i915_hsw_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\n\t\t\t\t hda_nid_t pin_nid, int dev_id, u32 stream_tag,\n\t\t\t\t int format)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx = pin_id_to_pin_index(codec, pin_nid, dev_id);\n\tstruct hdmi_spec_per_pin *per_pin;\n\tint res;\n\n\tif (pin_idx < 0)\n\t\tper_pin = NULL;\n\telse\n\t\tper_pin = get_pin(spec, pin_idx);\n\n\thaswell_verify_D0(codec, cvt_nid, pin_nid);\n\n\tif (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {\n\t\tsilent_stream_set_kae(codec, per_pin, false);\n\t\t \n\t\tusleep_range(100, 200);\n\t}\n\n\tres = hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,\n\t\t\t\tstream_tag, format);\n\n\tif (spec->silent_stream_type == SILENT_STREAM_KAE && per_pin && per_pin->silent_stream) {\n\t\tusleep_range(100, 200);\n\t\tsilent_stream_set_kae(codec, per_pin, true);\n\t}\n\n\treturn res;\n}\n\n \nstatic void i915_pin_cvt_fixup(struct hda_codec *codec,\n\t\t\t       struct hdmi_spec_per_pin *per_pin,\n\t\t\t       hda_nid_t cvt_nid)\n{\n\tif (per_pin) {\n\t\thaswell_verify_D0(codec, per_pin->cvt_nid, per_pin->pin_nid);\n\t\tsnd_hda_set_dev_select(codec, per_pin->pin_nid,\n\t\t\t       per_pin->dev_id);\n\t\tintel_verify_pin_cvt_connect(codec, per_pin);\n\t\tintel_not_share_assigned_cvt(codec, per_pin->pin_nid,\n\t\t\t\t     per_pin->dev_id, per_pin->mux_idx);\n\t} else {\n\t\tintel_not_share_assigned_cvt_nid(codec, 0, 0, cvt_nid);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int i915_adlp_hdmi_suspend(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tbool silent_streams = false;\n\tint pin_idx, res;\n\n\tres = generic_hdmi_suspend(codec);\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\n\t\tif (per_pin->silent_stream) {\n\t\t\tsilent_streams = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (silent_streams && spec->silent_stream_type == SILENT_STREAM_KAE) {\n\t\t \n\t\tcodec->no_stream_clean_at_suspend = 1;\n\n\t\t \n\t\tcodec->forced_resume = 1;\n\n\t\tcodec_dbg(codec, \"HDMI: KAE active at suspend\\n\");\n\t} else {\n\t\tcodec->no_stream_clean_at_suspend = 0;\n\t\tcodec->forced_resume = 0;\n\t}\n\n\treturn res;\n}\n\nstatic int i915_adlp_hdmi_resume(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx, res;\n\n\tres = generic_hdmi_resume(codec);\n\n\t \n\tif (!codec->no_stream_clean_at_suspend)\n\t\treturn res;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\n\t\t \n\t\tif (per_pin->silent_stream) {\n\t\t\tunsigned int param;\n\n\t\t\tparam = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,\n\t\t\t\t\t\t   AC_VERB_GET_CONV, 0);\n\t\t\tif (!param) {\n\t\t\t\tcodec_dbg(codec, \"HDMI: KAE: restore stream id\\n\");\n\t\t\t\tsilent_stream_enable_i915(codec, per_pin);\n\t\t\t}\n\n\t\t\tparam = snd_hda_codec_read(codec, per_pin->cvt_nid, 0,\n\t\t\t\t\t\t   AC_VERB_GET_DIGI_CONVERT_1, 0);\n\t\t\tif (!(param & (AC_DIG3_KAE << 16))) {\n\t\t\t\tcodec_dbg(codec, \"HDMI: KAE: restore DIG3_KAE\\n\");\n\t\t\t\tsilent_stream_set_kae(codec, per_pin, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n#endif\n\n \nstatic int alloc_intel_hdmi(struct hda_codec *codec)\n{\n\tint err;\n\n\t \n\tif (!codec->bus->core.audio_component) {\n\t\tcodec_info(codec, \"No i915 binding for Intel HDMI/DP codec\\n\");\n\t\t \n\t\tcodec->probe_id = HDA_CODEC_ID_SKIP_PROBE;\n\t\treturn -ENODEV;\n\t}\n\n\terr = alloc_generic_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tcodec->patch_ops.unsol_event = NULL;\n\treturn 0;\n}\n\n \nstatic int parse_intel_hdmi(struct hda_codec *codec)\n{\n\tint err, retries = 3;\n\n\tdo {\n\t\terr = hdmi_parse_codec(codec);\n\t} while (err < 0 && retries--);\n\n\tif (err < 0) {\n\t\tgeneric_spec_free(codec);\n\t\treturn err;\n\t}\n\n\tgeneric_hdmi_init_per_pins(codec);\n\tregister_i915_notifier(codec);\n\treturn 0;\n}\n\n \nstatic int intel_hsw_common_init(struct hda_codec *codec, hda_nid_t vendor_nid,\n\t\t\t\t const int *port_map, int port_num, int dev_num,\n\t\t\t\t bool send_silent_stream)\n{\n\tstruct hdmi_spec *spec;\n\tint err;\n\n\terr = alloc_intel_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\tcodec->dp_mst = true;\n\tspec->vendor_nid = vendor_nid;\n\tspec->port_map = port_map;\n\tspec->port_num = port_num;\n\tspec->intel_hsw_fixup = true;\n\tspec->dev_num = dev_num;\n\n\tintel_haswell_enable_all_pins(codec, true);\n\tintel_haswell_fixup_enable_dp12(codec);\n\n\tcodec->display_power_control = 1;\n\n\tcodec->patch_ops.set_power_state = haswell_set_power_state;\n\tcodec->depop_delay = 0;\n\tcodec->auto_runtime_pm = 1;\n\n\tspec->ops.setup_stream = i915_hsw_setup_stream;\n\tspec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;\n\n\t \n\tif (send_silent_stream)\n\t\tspec->silent_stream_type = SILENT_STREAM_I915;\n\n\treturn parse_intel_hdmi(codec);\n}\n\nstatic int patch_i915_hsw_hdmi(struct hda_codec *codec)\n{\n\treturn intel_hsw_common_init(codec, 0x08, NULL, 0, 3,\n\t\t\t\t     enable_silent_stream);\n}\n\nstatic int patch_i915_glk_hdmi(struct hda_codec *codec)\n{\n\t \n\treturn intel_hsw_common_init(codec, 0x0b, NULL, 0, 3, false);\n}\n\nstatic int patch_i915_icl_hdmi(struct hda_codec *codec)\n{\n\t \n\tstatic const int map[] = {0x0, 0x4, 0x6, 0x8, 0xa, 0xb};\n\n\treturn intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 3,\n\t\t\t\t     enable_silent_stream);\n}\n\nstatic int patch_i915_tgl_hdmi(struct hda_codec *codec)\n{\n\t \n\tstatic const int map[] = {0x4, 0x6, 0x8, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};\n\n\treturn intel_hsw_common_init(codec, 0x02, map, ARRAY_SIZE(map), 4,\n\t\t\t\t     enable_silent_stream);\n}\n\nstatic int patch_i915_adlp_hdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint res;\n\n\tres = patch_i915_tgl_hdmi(codec);\n\tif (!res) {\n\t\tspec = codec->spec;\n\n\t\tif (spec->silent_stream_type) {\n\t\t\tspec->silent_stream_type = SILENT_STREAM_KAE;\n\n#ifdef CONFIG_PM\n\t\t\tcodec->patch_ops.resume = i915_adlp_hdmi_resume;\n\t\t\tcodec->patch_ops.suspend = i915_adlp_hdmi_suspend;\n#endif\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \nstatic int patch_i915_byt_hdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err;\n\n\terr = alloc_intel_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\n\t \n\tcodec->display_power_control = 1;\n\n\tcodec->depop_delay = 0;\n\tcodec->auto_runtime_pm = 1;\n\n\tspec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;\n\n\treturn parse_intel_hdmi(codec);\n}\n\n \nstatic int patch_i915_cpt_hdmi(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = alloc_intel_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\treturn parse_intel_hdmi(codec);\n}\n\n \n\nstatic int simple_playback_build_pcms(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hda_pcm *info;\n\tunsigned int chans;\n\tstruct hda_pcm_stream *pstr;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\n\tper_cvt = get_cvt(spec, 0);\n\tchans = get_wcaps(codec, per_cvt->cvt_nid);\n\tchans = get_wcaps_channels(chans);\n\n\tinfo = snd_hda_codec_pcm_new(codec, \"HDMI 0\");\n\tif (!info)\n\t\treturn -ENOMEM;\n\tspec->pcm_rec[0].pcm = info;\n\tinfo->pcm_type = HDA_PCM_TYPE_HDMI;\n\tpstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];\n\t*pstr = spec->pcm_playback;\n\tpstr->nid = per_cvt->cvt_nid;\n\tif (pstr->channels_max <= 2 && chans && chans <= 16)\n\t\tpstr->channels_max = chans;\n\n\treturn 0;\n}\n\n \nstatic void simple_hdmi_unsol_event(struct hda_codec *codec,\n\t\t\t\t    unsigned int res)\n{\n\tsnd_hda_jack_set_dirty_all(codec);\n\tsnd_hda_jack_report_sync(codec);\n}\n\n \n#define simple_hdmi_build_jack\tgeneric_hdmi_build_jack\n\nstatic int simple_playback_build_controls(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tint err;\n\n\tper_cvt = get_cvt(spec, 0);\n\terr = snd_hda_create_dig_out_ctls(codec, per_cvt->cvt_nid,\n\t\t\t\t\t  per_cvt->cvt_nid,\n\t\t\t\t\t  HDA_PCM_TYPE_HDMI);\n\tif (err < 0)\n\t\treturn err;\n\treturn simple_hdmi_build_jack(codec, 0);\n}\n\nstatic int simple_playback_init(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, 0);\n\thda_nid_t pin = per_pin->pin_nid;\n\n\tsnd_hda_codec_write(codec, pin, 0,\n\t\t\t    AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);\n\t \n\tif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\n\t\tsnd_hda_codec_write(codec, pin, 0, AC_VERB_SET_AMP_GAIN_MUTE,\n\t\t\t\t    AMP_OUT_UNMUTE);\n\tsnd_hda_jack_detect_enable(codec, pin, per_pin->dev_id);\n\treturn 0;\n}\n\nstatic void simple_playback_free(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\n\thdmi_array_free(spec);\n\tkfree(spec);\n}\n\n \n\n#define Nv_VERB_SET_Channel_Allocation          0xF79\n#define Nv_VERB_SET_Info_Frame_Checksum         0xF7A\n#define Nv_VERB_SET_Audio_Protection_On         0xF98\n#define Nv_VERB_SET_Audio_Protection_Off        0xF99\n\n#define nvhdmi_master_con_nid_7x\t0x04\n#define nvhdmi_master_pin_nid_7x\t0x05\n\nstatic const hda_nid_t nvhdmi_con_nids_7x[4] = {\n\t \n\t0x6, 0x8, 0xa, 0xc,\n};\n\nstatic const struct hda_verb nvhdmi_basic_init_7x_2ch[] = {\n\t \n\t{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},\n\t \n\t{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{}  \n};\n\nstatic const struct hda_verb nvhdmi_basic_init_7x_8ch[] = {\n\t \n\t{ 0x1, Nv_VERB_SET_Audio_Protection_On, 0x1},\n\t \n\t{ 0x5, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{ 0x7, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{ 0x9, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{ 0xb, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{ 0xd, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT | 0x5 },\n\t{}  \n};\n\n#ifdef LIMITED_RATE_FMT_SUPPORT\n \n#define SUPPORTED_RATES\t\tSNDRV_PCM_RATE_48000\n#define SUPPORTED_MAXBPS\t16\n#define SUPPORTED_FORMATS\tSNDRV_PCM_FMTBIT_S16_LE\n#else\n \n#define SUPPORTED_RATES \\\n\t(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\\\n\tSNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\\\n\t SNDRV_PCM_RATE_192000)\n#define SUPPORTED_MAXBPS\t24\n#define SUPPORTED_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)\n#endif\n\nstatic int nvhdmi_7x_init_2ch(struct hda_codec *codec)\n{\n\tsnd_hda_sequence_write(codec, nvhdmi_basic_init_7x_2ch);\n\treturn 0;\n}\n\nstatic int nvhdmi_7x_init_8ch(struct hda_codec *codec)\n{\n\tsnd_hda_sequence_write(codec, nvhdmi_basic_init_7x_8ch);\n\treturn 0;\n}\n\nstatic const unsigned int channels_2_6_8[] = {\n\t2, 6, 8\n};\n\nstatic const unsigned int channels_2_8[] = {\n\t2, 8\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_2_6_8_channels = {\n\t.count = ARRAY_SIZE(channels_2_6_8),\n\t.list = channels_2_6_8,\n\t.mask = 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_2_8_channels = {\n\t.count = ARRAY_SIZE(channels_2_8),\n\t.list = channels_2_8,\n\t.mask = 0,\n};\n\nstatic int simple_playback_pcm_open(struct hda_pcm_stream *hinfo,\n\t\t\t\t    struct hda_codec *codec,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tconst struct snd_pcm_hw_constraint_list *hw_constraints_channels = NULL;\n\n\tswitch (codec->preset->vendor_id) {\n\tcase 0x10de0002:\n\tcase 0x10de0003:\n\tcase 0x10de0005:\n\tcase 0x10de0006:\n\t\thw_constraints_channels = &hw_constraints_2_8_channels;\n\t\tbreak;\n\tcase 0x10de0007:\n\t\thw_constraints_channels = &hw_constraints_2_6_8_channels;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (hw_constraints_channels != NULL) {\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\thw_constraints_channels);\n\t} else {\n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\t}\n\n\treturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\n}\n\nstatic int simple_playback_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t     struct hda_codec *codec,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\n}\n\nstatic int simple_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t       struct hda_codec *codec,\n\t\t\t\t       unsigned int stream_tag,\n\t\t\t\t       unsigned int format,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\treturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\n\t\t\t\t\t     stream_tag, format, substream);\n}\n\nstatic const struct hda_pcm_stream simple_pcm_playback = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.ops = {\n\t\t.open = simple_playback_pcm_open,\n\t\t.close = simple_playback_pcm_close,\n\t\t.prepare = simple_playback_pcm_prepare\n\t},\n};\n\nstatic const struct hda_codec_ops simple_hdmi_patch_ops = {\n\t.build_controls = simple_playback_build_controls,\n\t.build_pcms = simple_playback_build_pcms,\n\t.init = simple_playback_init,\n\t.free = simple_playback_free,\n\t.unsol_event = simple_hdmi_unsol_event,\n};\n\nstatic int patch_simple_hdmi(struct hda_codec *codec,\n\t\t\t     hda_nid_t cvt_nid, hda_nid_t pin_nid)\n{\n\tstruct hdmi_spec *spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tstruct hdmi_spec_per_pin *per_pin;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tspec->codec = codec;\n\tcodec->spec = spec;\n\thdmi_array_init(spec, 1);\n\n\tspec->multiout.num_dacs = 0;   \n\tspec->multiout.max_channels = 2;\n\tspec->multiout.dig_out_nid = cvt_nid;\n\tspec->num_cvts = 1;\n\tspec->num_pins = 1;\n\tper_pin = snd_array_new(&spec->pins);\n\tper_cvt = snd_array_new(&spec->cvts);\n\tif (!per_pin || !per_cvt) {\n\t\tsimple_playback_free(codec);\n\t\treturn -ENOMEM;\n\t}\n\tper_cvt->cvt_nid = cvt_nid;\n\tper_pin->pin_nid = pin_nid;\n\tspec->pcm_playback = simple_pcm_playback;\n\n\tcodec->patch_ops = simple_hdmi_patch_ops;\n\n\treturn 0;\n}\n\nstatic void nvhdmi_8ch_7x_set_info_frame_parameters(struct hda_codec *codec,\n\t\t\t\t\t\t    int channels)\n{\n\tunsigned int chanmask;\n\tint chan = channels ? (channels - 1) : 1;\n\n\tswitch (channels) {\n\tdefault:\n\tcase 0:\n\tcase 2:\n\t\tchanmask = 0x00;\n\t\tbreak;\n\tcase 4:\n\t\tchanmask = 0x08;\n\t\tbreak;\n\tcase 6:\n\t\tchanmask = 0x0b;\n\t\tbreak;\n\tcase 8:\n\t\tchanmask = 0x13;\n\t\tbreak;\n\t}\n\n\t \n\tsnd_hda_codec_write(codec, 0x1, 0,\n\t\t\tNv_VERB_SET_Channel_Allocation, chanmask);\n\n\tsnd_hda_codec_write(codec, 0x1, 0,\n\t\t\tNv_VERB_SET_Info_Frame_Checksum,\n\t\t\t(0x71 - chan - chanmask));\n}\n\nstatic int nvhdmi_8ch_7x_pcm_close(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint i;\n\n\tsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x,\n\t\t\t0, AC_VERB_SET_CHANNEL_STREAMID, 0);\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tsnd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,\n\t\t\t\tAC_VERB_SET_CHANNEL_STREAMID, 0);\n\t\t \n\t\tsnd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,\n\t\t\t\tAC_VERB_SET_STREAM_FORMAT, 0);\n\t}\n\n\t \n\tnvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);\n\n\treturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\n}\n\nstatic int nvhdmi_8ch_7x_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t     struct hda_codec *codec,\n\t\t\t\t     unsigned int stream_tag,\n\t\t\t\t     unsigned int format,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tint chs;\n\tunsigned int dataDCC2, channel_id;\n\tint i;\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hda_spdif_out *spdif;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\n\tmutex_lock(&codec->spdif_mutex);\n\tper_cvt = get_cvt(spec, 0);\n\tspdif = snd_hda_spdif_out_of_nid(codec, per_cvt->cvt_nid);\n\n\tchs = substream->runtime->channels;\n\n\tdataDCC2 = 0x2;\n\n\t \n\tif (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE))\n\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_master_con_nid_7x,\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t\tspdif->ctls & ~AC_DIG1_ENABLE & 0xff);\n\n\t \n\tsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,\n\t\t\tAC_VERB_SET_CHANNEL_STREAMID, (stream_tag << 4) | 0x0);\n\n\t \n\tsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,\n\t\t\tAC_VERB_SET_STREAM_FORMAT, format);\n\n\t \n\t \n\tif (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE)) {\n\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_master_con_nid_7x,\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t\tspdif->ctls & 0xff);\n\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_master_con_nid_7x,\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_DIGI_CONVERT_2, dataDCC2);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (chs == 2)\n\t\t\tchannel_id = 0;\n\t\telse\n\t\t\tchannel_id = i * 2;\n\n\t\t \n\t\tif (codec->spdif_status_reset &&\n\t\t(spdif->ctls & AC_DIG1_ENABLE))\n\t\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_con_nids_7x[i],\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t\tspdif->ctls & ~AC_DIG1_ENABLE & 0xff);\n\t\t \n\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_con_nids_7x[i],\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_CHANNEL_STREAMID,\n\t\t\t\t(stream_tag << 4) | channel_id);\n\t\t \n\t\tsnd_hda_codec_write(codec,\n\t\t\t\tnvhdmi_con_nids_7x[i],\n\t\t\t\t0,\n\t\t\t\tAC_VERB_SET_STREAM_FORMAT,\n\t\t\t\tformat);\n\t\t \n\t\t \n\t\tif (codec->spdif_status_reset &&\n\t\t(spdif->ctls & AC_DIG1_ENABLE)) {\n\t\t\tsnd_hda_codec_write(codec,\n\t\t\t\t\tnvhdmi_con_nids_7x[i],\n\t\t\t\t\t0,\n\t\t\t\t\tAC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t\t\tspdif->ctls & 0xff);\n\t\t\tsnd_hda_codec_write(codec,\n\t\t\t\t\tnvhdmi_con_nids_7x[i],\n\t\t\t\t\t0,\n\t\t\t\t\tAC_VERB_SET_DIGI_CONVERT_2, dataDCC2);\n\t\t}\n\t}\n\n\tnvhdmi_8ch_7x_set_info_frame_parameters(codec, chs);\n\n\tmutex_unlock(&codec->spdif_mutex);\n\treturn 0;\n}\n\nstatic const struct hda_pcm_stream nvhdmi_pcm_playback_8ch_7x = {\n\t.substreams = 1,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t.nid = nvhdmi_master_con_nid_7x,\n\t.rates = SUPPORTED_RATES,\n\t.maxbps = SUPPORTED_MAXBPS,\n\t.formats = SUPPORTED_FORMATS,\n\t.ops = {\n\t\t.open = simple_playback_pcm_open,\n\t\t.close = nvhdmi_8ch_7x_pcm_close,\n\t\t.prepare = nvhdmi_8ch_7x_pcm_prepare\n\t},\n};\n\nstatic int patch_nvhdmi_2ch(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err = patch_simple_hdmi(codec, nvhdmi_master_con_nid_7x,\n\t\t\t\t    nvhdmi_master_pin_nid_7x);\n\tif (err < 0)\n\t\treturn err;\n\n\tcodec->patch_ops.init = nvhdmi_7x_init_2ch;\n\t \n\tspec = codec->spec;\n\tspec->pcm_playback.rates = SUPPORTED_RATES;\n\tspec->pcm_playback.maxbps = SUPPORTED_MAXBPS;\n\tspec->pcm_playback.formats = SUPPORTED_FORMATS;\n\tspec->nv_dp_workaround = true;\n\treturn 0;\n}\n\nstatic int nvhdmi_7x_8ch_build_pcms(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint err = simple_playback_build_pcms(codec);\n\tif (!err) {\n\t\tstruct hda_pcm *info = get_pcm_rec(spec, 0);\n\t\tinfo->own_chmap = true;\n\t}\n\treturn err;\n}\n\nstatic int nvhdmi_7x_8ch_build_controls(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tstruct hda_pcm *info;\n\tstruct snd_pcm_chmap *chmap;\n\tint err;\n\n\terr = simple_playback_build_controls(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tinfo = get_pcm_rec(spec, 0);\n\terr = snd_pcm_add_chmap_ctls(info->pcm,\n\t\t\t\t     SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps, 8, 0, &chmap);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (codec->preset->vendor_id) {\n\tcase 0x10de0002:\n\tcase 0x10de0003:\n\tcase 0x10de0005:\n\tcase 0x10de0006:\n\t\tchmap->channel_mask = (1U << 2) | (1U << 8);\n\t\tbreak;\n\tcase 0x10de0007:\n\t\tchmap->channel_mask = (1U << 2) | (1U << 6) | (1U << 8);\n\t}\n\treturn 0;\n}\n\nstatic int patch_nvhdmi_8ch_7x(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err = patch_nvhdmi_2ch(codec);\n\tif (err < 0)\n\t\treturn err;\n\tspec = codec->spec;\n\tspec->multiout.max_channels = 8;\n\tspec->pcm_playback = nvhdmi_pcm_playback_8ch_7x;\n\tcodec->patch_ops.init = nvhdmi_7x_init_8ch;\n\tcodec->patch_ops.build_pcms = nvhdmi_7x_8ch_build_pcms;\n\tcodec->patch_ops.build_controls = nvhdmi_7x_8ch_build_controls;\n\n\t \n\tnvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);\n\n\treturn 0;\n}\n\n \nstatic int nvhdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,\n\t\tstruct hdac_cea_channel_speaker_allocation *cap, int channels)\n{\n\tif (cap->ca_index == 0x00 && channels == 2)\n\t\treturn SNDRV_CTL_TLVT_CHMAP_FIXED;\n\n\t \n\tif (cap->channels != channels)\n\t\treturn -1;\n\n\t \n\treturn SNDRV_CTL_TLVT_CHMAP_VAR;\n}\n\nstatic int nvhdmi_chmap_validate(struct hdac_chmap *chmap,\n\t\tint ca, int chs, unsigned char *map)\n{\n\tif (ca == 0x00 && (map[0] != SNDRV_CHMAP_FL || map[1] != SNDRV_CHMAP_FR))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n \nstatic int nvhdmi_pin2port(void *audio_ptr, int pin_nid)\n{\n\treturn pin_nid - 4;\n}\n\n \nstatic int nvhdmi_port2pin(struct hda_codec *codec, int port)\n{\n\treturn port + 4;\n}\n\nstatic const struct drm_audio_component_audio_ops nvhdmi_audio_ops = {\n\t.pin2port = nvhdmi_pin2port,\n\t.pin_eld_notify = generic_acomp_pin_eld_notify,\n\t.master_bind = generic_acomp_master_bind,\n\t.master_unbind = generic_acomp_master_unbind,\n};\n\nstatic int patch_nvhdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err;\n\n\terr = alloc_generic_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\tcodec->dp_mst = true;\n\n\tspec = codec->spec;\n\n\terr = hdmi_parse_codec(codec);\n\tif (err < 0) {\n\t\tgeneric_spec_free(codec);\n\t\treturn err;\n\t}\n\n\tgeneric_hdmi_init_per_pins(codec);\n\n\tspec->dyn_pin_out = true;\n\n\tspec->chmap.ops.chmap_cea_alloc_validate_get_type =\n\t\tnvhdmi_chmap_cea_alloc_validate_get_type;\n\tspec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;\n\tspec->nv_dp_workaround = true;\n\n\tcodec->link_down_at_suspend = 1;\n\n\tgeneric_acomp_init(codec, &nvhdmi_audio_ops, nvhdmi_port2pin);\n\n\treturn 0;\n}\n\nstatic int patch_nvhdmi_legacy(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err;\n\n\terr = patch_generic_hdmi(codec);\n\tif (err)\n\t\treturn err;\n\n\tspec = codec->spec;\n\tspec->dyn_pin_out = true;\n\n\tspec->chmap.ops.chmap_cea_alloc_validate_get_type =\n\t\tnvhdmi_chmap_cea_alloc_validate_get_type;\n\tspec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;\n\tspec->nv_dp_workaround = true;\n\n\tcodec->link_down_at_suspend = 1;\n\n\treturn 0;\n}\n\n \n\n \n#define NVIDIA_AFG_NID 0x01\n\n \n#define NVIDIA_SET_HOST_INTR\t\t0xf80\n#define NVIDIA_GET_SCRATCH0\t\t0xfa6\n#define NVIDIA_SET_SCRATCH0_BYTE0\t0xfa7\n#define NVIDIA_SET_SCRATCH0_BYTE1\t0xfa8\n#define NVIDIA_SET_SCRATCH0_BYTE2\t0xfa9\n#define NVIDIA_SET_SCRATCH0_BYTE3\t0xfaa\n#define NVIDIA_SCRATCH_TRIGGER (1 << 7)\n#define NVIDIA_SCRATCH_VALID   (1 << 6)\n\n#define NVIDIA_GET_SCRATCH1\t\t0xfab\n#define NVIDIA_SET_SCRATCH1_BYTE0\t0xfac\n#define NVIDIA_SET_SCRATCH1_BYTE1\t0xfad\n#define NVIDIA_SET_SCRATCH1_BYTE2\t0xfae\n#define NVIDIA_SET_SCRATCH1_BYTE3\t0xfaf\n\n \nstatic void tegra_hdmi_set_format(struct hda_codec *codec,\n\t\t\t\t  hda_nid_t cvt_nid,\n\t\t\t\t  unsigned int format)\n{\n\tunsigned int value;\n\tunsigned int nid = NVIDIA_AFG_NID;\n\tstruct hdmi_spec *spec = codec->spec;\n\n\t \n\tif (codec->dp_mst)\n\t\tnid = cvt_nid;\n\n\t \n\tvalue = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t   NVIDIA_GET_SCRATCH0, 0);\n\tvalue = (value >> 24) & 0xff;\n\n\t \n\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t    NVIDIA_SET_SCRATCH0_BYTE0,\n\t\t\t    (format >> 0) & 0xff);\n\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t    NVIDIA_SET_SCRATCH0_BYTE1,\n\t\t\t    (format >> 8) & 0xff);\n\n\t \n\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t    NVIDIA_SET_SCRATCH0_BYTE2, 0);\n\n\t \n\tif (format == 0)\n\t\tvalue &= ~NVIDIA_SCRATCH_VALID;\n\telse\n\t\tvalue |= NVIDIA_SCRATCH_VALID;\n\n\tif (spec->hdmi_intr_trig_ctrl) {\n\t\t \n\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\tNVIDIA_SET_SCRATCH0_BYTE3, value);\n\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\tNVIDIA_SET_HOST_INTR, 0x1);\n\t} else {\n\t\t \n\t\tvalue ^= NVIDIA_SCRATCH_TRIGGER;\n\n\t\tsnd_hda_codec_write(codec, nid, 0,\n\t\t\t\tNVIDIA_SET_SCRATCH0_BYTE3, value);\n\t}\n}\n\nstatic int tegra_hdmi_pcm_prepare(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  unsigned int stream_tag,\n\t\t\t\t  unsigned int format,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tint err;\n\n\terr = generic_hdmi_playback_pcm_prepare(hinfo, codec, stream_tag,\n\t\t\t\t\t\tformat, substream);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ttegra_hdmi_set_format(codec, hinfo->nid, format);\n\n\treturn 0;\n}\n\nstatic int tegra_hdmi_pcm_cleanup(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\t \n\ttegra_hdmi_set_format(codec, hinfo->nid, 0);\n\n\treturn generic_hdmi_playback_pcm_cleanup(hinfo, codec, substream);\n}\n\nstatic struct hda_pcm *hda_find_pcm_by_type(struct hda_codec *codec, int type)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tunsigned int i;\n\n\tfor (i = 0; i < spec->num_pins; i++) {\n\t\tstruct hda_pcm *pcm = get_pcm_rec(spec, i);\n\n\t\tif (pcm->pcm_type == type)\n\t\t\treturn pcm;\n\t}\n\n\treturn NULL;\n}\n\nstatic int tegra_hdmi_build_pcms(struct hda_codec *codec)\n{\n\tstruct hda_pcm_stream *stream;\n\tstruct hda_pcm *pcm;\n\tint err;\n\n\terr = generic_hdmi_build_pcms(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm = hda_find_pcm_by_type(codec, HDA_PCM_TYPE_HDMI);\n\tif (!pcm)\n\t\treturn -ENODEV;\n\n\t \n\tstream = &pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];\n\tstream->ops.prepare = tegra_hdmi_pcm_prepare;\n\tstream->ops.cleanup = tegra_hdmi_pcm_cleanup;\n\n\treturn 0;\n}\n\nstatic int tegra_hdmi_init(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint i, err;\n\n\terr = hdmi_parse_codec(codec);\n\tif (err < 0) {\n\t\tgeneric_spec_free(codec);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < spec->num_cvts; i++)\n\t\tsnd_hda_codec_write(codec, spec->cvt_nids[i], 0,\n\t\t\t\t\tAC_VERB_SET_DIGI_CONVERT_1,\n\t\t\t\t\tAC_DIG1_ENABLE);\n\n\tgeneric_hdmi_init_per_pins(codec);\n\n\tcodec->depop_delay = 10;\n\tcodec->patch_ops.build_pcms = tegra_hdmi_build_pcms;\n\tspec->chmap.ops.chmap_cea_alloc_validate_get_type =\n\t\tnvhdmi_chmap_cea_alloc_validate_get_type;\n\tspec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;\n\n\tspec->chmap.ops.chmap_cea_alloc_validate_get_type =\n\t\tnvhdmi_chmap_cea_alloc_validate_get_type;\n\tspec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;\n\tspec->nv_dp_workaround = true;\n\n\treturn 0;\n}\n\nstatic int patch_tegra_hdmi(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = alloc_generic_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn tegra_hdmi_init(codec);\n}\n\nstatic int patch_tegra234_hdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tint err;\n\n\terr = alloc_generic_hdmi(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\tcodec->dp_mst = true;\n\tspec = codec->spec;\n\tspec->dyn_pin_out = true;\n\tspec->hdmi_intr_trig_ctrl = true;\n\n\treturn tegra_hdmi_init(codec);\n}\n\n \n\n#define is_amdhdmi_rev3_or_later(codec) \\\n\t((codec)->core.vendor_id == 0x1002aa01 && \\\n\t ((codec)->core.revision_id & 0xff00) >= 0x0300)\n#define has_amd_full_remap_support(codec) is_amdhdmi_rev3_or_later(codec)\n\n \n#define ATI_VERB_SET_CHANNEL_ALLOCATION\t0x771\n#define ATI_VERB_SET_DOWNMIX_INFO\t0x772\n#define ATI_VERB_SET_MULTICHANNEL_01\t0x777\n#define ATI_VERB_SET_MULTICHANNEL_23\t0x778\n#define ATI_VERB_SET_MULTICHANNEL_45\t0x779\n#define ATI_VERB_SET_MULTICHANNEL_67\t0x77a\n#define ATI_VERB_SET_HBR_CONTROL\t0x77c\n#define ATI_VERB_SET_MULTICHANNEL_1\t0x785\n#define ATI_VERB_SET_MULTICHANNEL_3\t0x786\n#define ATI_VERB_SET_MULTICHANNEL_5\t0x787\n#define ATI_VERB_SET_MULTICHANNEL_7\t0x788\n#define ATI_VERB_SET_MULTICHANNEL_MODE\t0x789\n#define ATI_VERB_GET_CHANNEL_ALLOCATION\t0xf71\n#define ATI_VERB_GET_DOWNMIX_INFO\t0xf72\n#define ATI_VERB_GET_MULTICHANNEL_01\t0xf77\n#define ATI_VERB_GET_MULTICHANNEL_23\t0xf78\n#define ATI_VERB_GET_MULTICHANNEL_45\t0xf79\n#define ATI_VERB_GET_MULTICHANNEL_67\t0xf7a\n#define ATI_VERB_GET_HBR_CONTROL\t0xf7c\n#define ATI_VERB_GET_MULTICHANNEL_1\t0xf85\n#define ATI_VERB_GET_MULTICHANNEL_3\t0xf86\n#define ATI_VERB_GET_MULTICHANNEL_5\t0xf87\n#define ATI_VERB_GET_MULTICHANNEL_7\t0xf88\n#define ATI_VERB_GET_MULTICHANNEL_MODE\t0xf89\n\n \n#define ATI_VERB_SET_RAMP_RATE\t\t0x770\n#define ATI_VERB_GET_RAMP_RATE\t\t0xf70\n\n#define ATI_OUT_ENABLE 0x1\n\n#define ATI_MULTICHANNEL_MODE_PAIRED\t0\n#define ATI_MULTICHANNEL_MODE_SINGLE\t1\n\n#define ATI_HBR_CAPABLE 0x01\n#define ATI_HBR_ENABLE 0x10\n\nstatic int atihdmi_pin_get_eld(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t       int dev_id, unsigned char *buf, int *eld_size)\n{\n\tWARN_ON(dev_id != 0);\n\t \n\treturn snd_hdmi_get_eld_ati(codec, nid, buf, eld_size,\n\t\t\t\t    is_amdhdmi_rev3_or_later(codec));\n}\n\nstatic void atihdmi_pin_setup_infoframe(struct hda_codec *codec,\n\t\t\t\t\thda_nid_t pin_nid, int dev_id, int ca,\n\t\t\t\t\tint active_channels, int conn_type)\n{\n\tWARN_ON(dev_id != 0);\n\tsnd_hda_codec_write(codec, pin_nid, 0, ATI_VERB_SET_CHANNEL_ALLOCATION, ca);\n}\n\nstatic int atihdmi_paired_swap_fc_lfe(int pos)\n{\n\t \n\n\tswitch (pos) {\n\t\t \n\t\tcase 2: return 3;\n\t\tcase 3: return 2;\n\t\tdefault: break;\n\t}\n\n\treturn pos;\n}\n\nstatic int atihdmi_paired_chmap_validate(struct hdac_chmap *chmap,\n\t\t\tint ca, int chs, unsigned char *map)\n{\n\tstruct hdac_cea_channel_speaker_allocation *cap;\n\tint i, j;\n\n\t \n\n\tcap = snd_hdac_get_ch_alloc_from_ca(ca);\n\tfor (i = 0; i < chs; ++i) {\n\t\tint mask = snd_hdac_chmap_to_spk_mask(map[i]);\n\t\tbool ok = false;\n\t\tbool companion_ok = false;\n\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tfor (j = 0 + i % 2; j < 8; j += 2) {\n\t\t\tint chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j);\n\t\t\tif (cap->speakers[chan_idx] == mask) {\n\t\t\t\t \n\t\t\t\tok = true;\n\n\t\t\t\tif (i % 2 == 0 && i + 1 < chs) {\n\t\t\t\t\t \n\t\t\t\t\tint comp_chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j + 1);\n\t\t\t\t\tint comp_mask_req = snd_hdac_chmap_to_spk_mask(map[i+1]);\n\t\t\t\t\tint comp_mask_act = cap->speakers[comp_chan_idx];\n\n\t\t\t\t\tif (comp_mask_req == comp_mask_act)\n\t\t\t\t\t\tcompanion_ok = true;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\n\t\tif (companion_ok)\n\t\t\ti++;  \n\t}\n\n\treturn 0;\n}\n\nstatic int atihdmi_pin_set_slot_channel(struct hdac_device *hdac,\n\t\thda_nid_t pin_nid, int hdmi_slot, int stream_channel)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tint verb;\n\tint ati_channel_setup = 0;\n\n\tif (hdmi_slot > 7)\n\t\treturn -EINVAL;\n\n\tif (!has_amd_full_remap_support(codec)) {\n\t\thdmi_slot = atihdmi_paired_swap_fc_lfe(hdmi_slot);\n\n\t\t \n\t\tif (hdmi_slot % 2 != 0 && stream_channel == 0xf)\n\t\t\treturn 0;\n\n\t\thdmi_slot -= hdmi_slot % 2;\n\n\t\tif (stream_channel != 0xf)\n\t\t\tstream_channel -= stream_channel % 2;\n\t}\n\n\tverb = ATI_VERB_SET_MULTICHANNEL_01 + hdmi_slot/2 + (hdmi_slot % 2) * 0x00e;\n\n\t \n\n\tif (stream_channel != 0xf)\n\t\tati_channel_setup = (stream_channel << 4) | ATI_OUT_ENABLE;\n\n\treturn snd_hda_codec_write(codec, pin_nid, 0, verb, ati_channel_setup);\n}\n\nstatic int atihdmi_pin_get_slot_channel(struct hdac_device *hdac,\n\t\t\t\thda_nid_t pin_nid, int asp_slot)\n{\n\tstruct hda_codec *codec = hdac_to_hda_codec(hdac);\n\tbool was_odd = false;\n\tint ati_asp_slot = asp_slot;\n\tint verb;\n\tint ati_channel_setup;\n\n\tif (asp_slot > 7)\n\t\treturn -EINVAL;\n\n\tif (!has_amd_full_remap_support(codec)) {\n\t\tati_asp_slot = atihdmi_paired_swap_fc_lfe(asp_slot);\n\t\tif (ati_asp_slot % 2 != 0) {\n\t\t\tati_asp_slot -= 1;\n\t\t\twas_odd = true;\n\t\t}\n\t}\n\n\tverb = ATI_VERB_GET_MULTICHANNEL_01 + ati_asp_slot/2 + (ati_asp_slot % 2) * 0x00e;\n\n\tati_channel_setup = snd_hda_codec_read(codec, pin_nid, 0, verb, 0);\n\n\tif (!(ati_channel_setup & ATI_OUT_ENABLE))\n\t\treturn 0xf;\n\n\treturn ((ati_channel_setup & 0xf0) >> 4) + !!was_odd;\n}\n\nstatic int atihdmi_paired_chmap_cea_alloc_validate_get_type(\n\t\tstruct hdac_chmap *chmap,\n\t\tstruct hdac_cea_channel_speaker_allocation *cap,\n\t\tint channels)\n{\n\tint c;\n\n\t \n\tint chanpairs = 0;\n\n\t \n\tif ((channels % 2) != 0)\n\t\treturn -1;\n\n\tfor (c = 0; c < 7; c += 2) {\n\t\tif (cap->speakers[c] || cap->speakers[c+1])\n\t\t\tchanpairs++;\n\t}\n\n\tif (chanpairs * 2 != channels)\n\t\treturn -1;\n\n\treturn SNDRV_CTL_TLVT_CHMAP_PAIRED;\n}\n\nstatic void atihdmi_paired_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,\n\t\tstruct hdac_cea_channel_speaker_allocation *cap,\n\t\tunsigned int *chmap, int channels)\n{\n\t \n\tint count = 0;\n\tint c;\n\n\tfor (c = 7; c >= 0; c--) {\n\t\tint chan = 7 - atihdmi_paired_swap_fc_lfe(7 - c);\n\t\tint spk = cap->speakers[chan];\n\t\tif (!spk) {\n\t\t\t \n\t\t\tif (cap->speakers[chan + (chan % 2 ? -1 : 1)])\n\t\t\t\tchmap[count++] = SNDRV_CHMAP_NA;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tchmap[count++] = snd_hdac_spk_to_chmap(spk);\n\t}\n\n\tWARN_ON(count != channels);\n}\n\nstatic int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,\n\t\t\t\t int dev_id, bool hbr)\n{\n\tint hbr_ctl, hbr_ctl_new;\n\n\tWARN_ON(dev_id != 0);\n\n\thbr_ctl = snd_hda_codec_read(codec, pin_nid, 0, ATI_VERB_GET_HBR_CONTROL, 0);\n\tif (hbr_ctl >= 0 && (hbr_ctl & ATI_HBR_CAPABLE)) {\n\t\tif (hbr)\n\t\t\thbr_ctl_new = hbr_ctl | ATI_HBR_ENABLE;\n\t\telse\n\t\t\thbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;\n\n\t\tcodec_dbg(codec,\n\t\t\t  \"atihdmi_pin_hbr_setup: NID=0x%x, %shbr-ctl=0x%x\\n\",\n\t\t\t\tpin_nid,\n\t\t\t\thbr_ctl == hbr_ctl_new ? \"\" : \"new-\",\n\t\t\t\thbr_ctl_new);\n\n\t\tif (hbr_ctl != hbr_ctl_new)\n\t\t\tsnd_hda_codec_write(codec, pin_nid, 0,\n\t\t\t\t\t\tATI_VERB_SET_HBR_CONTROL,\n\t\t\t\t\t\thbr_ctl_new);\n\n\t} else if (hbr)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int atihdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\n\t\t\t\thda_nid_t pin_nid, int dev_id,\n\t\t\t\tu32 stream_tag, int format)\n{\n\tif (is_amdhdmi_rev3_or_later(codec)) {\n\t\tint ramp_rate = 180;  \n\t\t \n\t\tif (format & AC_FMT_TYPE_NON_PCM)\n\t\t\tramp_rate = 0;\n\n\t\tsnd_hda_codec_write(codec, cvt_nid, 0, ATI_VERB_SET_RAMP_RATE, ramp_rate);\n\t}\n\n\treturn hdmi_setup_stream(codec, cvt_nid, pin_nid, dev_id,\n\t\t\t\t stream_tag, format);\n}\n\n\nstatic int atihdmi_init(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec = codec->spec;\n\tint pin_idx, err;\n\n\terr = generic_hdmi_init(codec);\n\n\tif (err)\n\t\treturn err;\n\n\tfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\n\t\tstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\n\n\t\t \n\t\tsnd_hda_codec_write(codec, per_pin->pin_nid, 0, ATI_VERB_SET_DOWNMIX_INFO, 0);\n\n\t\t \n\t\tif (has_amd_full_remap_support(codec))\n\t\t\tsnd_hda_codec_write(codec, per_pin->pin_nid, 0,\n\t\t\t\t\t    ATI_VERB_SET_MULTICHANNEL_MODE,\n\t\t\t\t\t    ATI_MULTICHANNEL_MODE_SINGLE);\n\t}\n\tcodec->auto_runtime_pm = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int atihdmi_pin2port(void *audio_ptr, int pin_nid)\n{\n\treturn pin_nid / 2 - 1;\n}\n\n \nstatic int atihdmi_port2pin(struct hda_codec *codec, int port)\n{\n\treturn port * 2 + 3;\n}\n\nstatic const struct drm_audio_component_audio_ops atihdmi_audio_ops = {\n\t.pin2port = atihdmi_pin2port,\n\t.pin_eld_notify = generic_acomp_pin_eld_notify,\n\t.master_bind = generic_acomp_master_bind,\n\t.master_unbind = generic_acomp_master_unbind,\n};\n\nstatic int patch_atihdmi(struct hda_codec *codec)\n{\n\tstruct hdmi_spec *spec;\n\tstruct hdmi_spec_per_cvt *per_cvt;\n\tint err, cvt_idx;\n\n\terr = patch_generic_hdmi(codec);\n\n\tif (err)\n\t\treturn err;\n\n\tcodec->patch_ops.init = atihdmi_init;\n\n\tspec = codec->spec;\n\n\tspec->static_pcm_mapping = true;\n\n\tspec->ops.pin_get_eld = atihdmi_pin_get_eld;\n\tspec->ops.pin_setup_infoframe = atihdmi_pin_setup_infoframe;\n\tspec->ops.pin_hbr_setup = atihdmi_pin_hbr_setup;\n\tspec->ops.setup_stream = atihdmi_setup_stream;\n\n\tspec->chmap.ops.pin_get_slot_channel = atihdmi_pin_get_slot_channel;\n\tspec->chmap.ops.pin_set_slot_channel = atihdmi_pin_set_slot_channel;\n\n\tif (!has_amd_full_remap_support(codec)) {\n\t\t \n\t\tspec->chmap.ops.chmap_cea_alloc_validate_get_type =\n\t\t\tatihdmi_paired_chmap_cea_alloc_validate_get_type;\n\t\tspec->chmap.ops.cea_alloc_to_tlv_chmap =\n\t\t\t\tatihdmi_paired_cea_alloc_to_tlv_chmap;\n\t\tspec->chmap.ops.chmap_validate = atihdmi_paired_chmap_validate;\n\t}\n\n\t \n\tfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\n\t\tper_cvt = get_cvt(spec, cvt_idx);\n\t\tper_cvt->channels_max = max(per_cvt->channels_max, 8u);\n\t\tper_cvt->rates |= SUPPORTED_RATES;\n\t\tper_cvt->formats |= SUPPORTED_FORMATS;\n\t\tper_cvt->maxbps = max(per_cvt->maxbps, 24u);\n\t}\n\n\tspec->chmap.channels_max = max(spec->chmap.channels_max, 8u);\n\n\t \n\tcodec->link_down_at_suspend = 1;\n\n\tgeneric_acomp_init(codec, &atihdmi_audio_ops, atihdmi_port2pin);\n\n\treturn 0;\n}\n\n \n#define VIAHDMI_CVT_NID\t0x02\t \n#define VIAHDMI_PIN_NID\t0x03\t \n\nstatic int patch_via_hdmi(struct hda_codec *codec)\n{\n\treturn patch_simple_hdmi(codec, VIAHDMI_CVT_NID, VIAHDMI_PIN_NID);\n}\n\nstatic int patch_gf_hdmi(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = patch_generic_hdmi(codec);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcodec->no_sticky_stream = 1;\n\treturn 0;\n}\n\n \nstatic const struct hda_device_id snd_hda_id_hdmi[] = {\nHDA_CODEC_ENTRY(0x00147a47, \"Loongson HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x1002793c, \"RS600 HDMI\",\tpatch_atihdmi),\nHDA_CODEC_ENTRY(0x10027919, \"RS600 HDMI\",\tpatch_atihdmi),\nHDA_CODEC_ENTRY(0x1002791a, \"RS690/780 HDMI\",\tpatch_atihdmi),\nHDA_CODEC_ENTRY(0x1002aa01, \"R6xx HDMI\",\tpatch_atihdmi),\nHDA_CODEC_ENTRY(0x10951390, \"SiI1390 HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x10951392, \"SiI1392 HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x17e80047, \"Chrontel HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x10de0001, \"MCP73 HDMI\",\tpatch_nvhdmi_2ch),\nHDA_CODEC_ENTRY(0x10de0002, \"MCP77/78 HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0003, \"MCP77/78 HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0004, \"GPU 04 HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0005, \"MCP77/78 HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0006, \"MCP77/78 HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0007, \"MCP79/7A HDMI\",\tpatch_nvhdmi_8ch_7x),\nHDA_CODEC_ENTRY(0x10de0008, \"GPU 08 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0009, \"GPU 09 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de000a, \"GPU 0a HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de000b, \"GPU 0b HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de000c, \"MCP89 HDMI\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de000d, \"GPU 0d HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0010, \"GPU 10 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0011, \"GPU 11 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0012, \"GPU 12 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0013, \"GPU 13 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0014, \"GPU 14 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0015, \"GPU 15 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0016, \"GPU 16 HDMI/DP\",\tpatch_nvhdmi_legacy),\n \nHDA_CODEC_ENTRY(0x10de0018, \"GPU 18 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0019, \"GPU 19 HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de001a, \"GPU 1a HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de001b, \"GPU 1b HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de001c, \"GPU 1c HDMI/DP\",\tpatch_nvhdmi_legacy),\nHDA_CODEC_ENTRY(0x10de0020, \"Tegra30 HDMI\",\tpatch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de0022, \"Tegra114 HDMI\",\tpatch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de0028, \"Tegra124 HDMI\",\tpatch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de0029, \"Tegra210 HDMI/DP\",\tpatch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de002d, \"Tegra186 HDMI/DP0\", patch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de002e, \"Tegra186 HDMI/DP1\", patch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de002f, \"Tegra194 HDMI/DP2\", patch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de0030, \"Tegra194 HDMI/DP3\", patch_tegra_hdmi),\nHDA_CODEC_ENTRY(0x10de0031, \"Tegra234 HDMI/DP\", patch_tegra234_hdmi),\nHDA_CODEC_ENTRY(0x10de0040, \"GPU 40 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0041, \"GPU 41 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0042, \"GPU 42 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0043, \"GPU 43 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0044, \"GPU 44 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0045, \"GPU 45 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0050, \"GPU 50 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0051, \"GPU 51 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0052, \"GPU 52 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0060, \"GPU 60 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0061, \"GPU 61 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0062, \"GPU 62 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0067, \"MCP67 HDMI\",\tpatch_nvhdmi_2ch),\nHDA_CODEC_ENTRY(0x10de0070, \"GPU 70 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0071, \"GPU 71 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0072, \"GPU 72 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0073, \"GPU 73 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0074, \"GPU 74 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0076, \"GPU 76 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de007b, \"GPU 7b HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de007c, \"GPU 7c HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de007d, \"GPU 7d HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de007e, \"GPU 7e HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0080, \"GPU 80 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0081, \"GPU 81 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0082, \"GPU 82 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0083, \"GPU 83 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0084, \"GPU 84 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0090, \"GPU 90 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0091, \"GPU 91 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0092, \"GPU 92 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0093, \"GPU 93 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0094, \"GPU 94 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0095, \"GPU 95 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0097, \"GPU 97 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0098, \"GPU 98 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de0099, \"GPU 99 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de009a, \"GPU 9a HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de009d, \"GPU 9d HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de009e, \"GPU 9e HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de009f, \"GPU 9f HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a0, \"GPU a0 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a3, \"GPU a3 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a4, \"GPU a4 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a5, \"GPU a5 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a6, \"GPU a6 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de00a7, \"GPU a7 HDMI/DP\",\tpatch_nvhdmi),\nHDA_CODEC_ENTRY(0x10de8001, \"MCP73 HDMI\",\tpatch_nvhdmi_2ch),\nHDA_CODEC_ENTRY(0x10de8067, \"MCP67/68 HDMI\",\tpatch_nvhdmi_2ch),\nHDA_CODEC_ENTRY(0x67663d82, \"Arise 82 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x67663d83, \"Arise 83 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x67663d84, \"Arise 84 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x67663d85, \"Arise 85 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x67663d86, \"Arise 86 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x67663d87, \"Arise 87 HDMI/DP\",\tpatch_gf_hdmi),\nHDA_CODEC_ENTRY(0x11069f80, \"VX900 HDMI/DP\",\tpatch_via_hdmi),\nHDA_CODEC_ENTRY(0x11069f81, \"VX900 HDMI/DP\",\tpatch_via_hdmi),\nHDA_CODEC_ENTRY(0x11069f84, \"VX11 HDMI/DP\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x11069f85, \"VX11 HDMI/DP\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x80860054, \"IbexPeak HDMI\",\tpatch_i915_cpt_hdmi),\nHDA_CODEC_ENTRY(0x80862800, \"Geminilake HDMI\",\tpatch_i915_glk_hdmi),\nHDA_CODEC_ENTRY(0x80862801, \"Bearlake HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x80862802, \"Cantiga HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x80862803, \"Eaglelake HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x80862804, \"IbexPeak HDMI\",\tpatch_i915_cpt_hdmi),\nHDA_CODEC_ENTRY(0x80862805, \"CougarPoint HDMI\",\tpatch_i915_cpt_hdmi),\nHDA_CODEC_ENTRY(0x80862806, \"PantherPoint HDMI\", patch_i915_cpt_hdmi),\nHDA_CODEC_ENTRY(0x80862807, \"Haswell HDMI\",\tpatch_i915_hsw_hdmi),\nHDA_CODEC_ENTRY(0x80862808, \"Broadwell HDMI\",\tpatch_i915_hsw_hdmi),\nHDA_CODEC_ENTRY(0x80862809, \"Skylake HDMI\",\tpatch_i915_hsw_hdmi),\nHDA_CODEC_ENTRY(0x8086280a, \"Broxton HDMI\",\tpatch_i915_hsw_hdmi),\nHDA_CODEC_ENTRY(0x8086280b, \"Kabylake HDMI\",\tpatch_i915_hsw_hdmi),\nHDA_CODEC_ENTRY(0x8086280c, \"Cannonlake HDMI\",\tpatch_i915_glk_hdmi),\nHDA_CODEC_ENTRY(0x8086280d, \"Geminilake HDMI\",\tpatch_i915_glk_hdmi),\nHDA_CODEC_ENTRY(0x8086280f, \"Icelake HDMI\",\tpatch_i915_icl_hdmi),\nHDA_CODEC_ENTRY(0x80862812, \"Tigerlake HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x80862814, \"DG1 HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x80862815, \"Alderlake HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x80862816, \"Rocketlake HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x80862818, \"Raptorlake HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x80862819, \"DG2 HDMI\",\tpatch_i915_tgl_hdmi),\nHDA_CODEC_ENTRY(0x8086281a, \"Jasperlake HDMI\",\tpatch_i915_icl_hdmi),\nHDA_CODEC_ENTRY(0x8086281b, \"Elkhartlake HDMI\",\tpatch_i915_icl_hdmi),\nHDA_CODEC_ENTRY(0x8086281c, \"Alderlake-P HDMI\", patch_i915_adlp_hdmi),\nHDA_CODEC_ENTRY(0x8086281d, \"Meteor Lake HDMI\",\tpatch_i915_adlp_hdmi),\nHDA_CODEC_ENTRY(0x8086281f, \"Raptor Lake P HDMI\",\tpatch_i915_adlp_hdmi),\nHDA_CODEC_ENTRY(0x80862820, \"Lunar Lake HDMI\",\tpatch_i915_adlp_hdmi),\nHDA_CODEC_ENTRY(0x80862880, \"CedarTrail HDMI\",\tpatch_generic_hdmi),\nHDA_CODEC_ENTRY(0x80862882, \"Valleyview2 HDMI\",\tpatch_i915_byt_hdmi),\nHDA_CODEC_ENTRY(0x80862883, \"Braswell HDMI\",\tpatch_i915_byt_hdmi),\nHDA_CODEC_ENTRY(0x808629fb, \"Crestline HDMI\",\tpatch_generic_hdmi),\n \nHDA_CODEC_ENTRY(HDA_CODEC_ID_GENERIC_HDMI, \"Generic HDMI\", patch_generic_hdmi),\n{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_hdmi);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"HDMI HD-audio codec\");\nMODULE_ALIAS(\"snd-hda-codec-intelhdmi\");\nMODULE_ALIAS(\"snd-hda-codec-nvhdmi\");\nMODULE_ALIAS(\"snd-hda-codec-atihdmi\");\n\nstatic struct hda_codec_driver hdmi_driver = {\n\t.id = snd_hda_id_hdmi,\n};\n\nmodule_hda_codec_driver(hdmi_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}