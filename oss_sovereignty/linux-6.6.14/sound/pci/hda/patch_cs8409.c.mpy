{
  "module_name": "patch_cs8409.c",
  "hash_id": "2856920c4bb72c0402d6e6f3764d3b2473ab5ceaa5089ab7506603d503a4418a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_cs8409.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <linux/mutex.h>\n#include <linux/iopoll.h>\n\n#include \"patch_cs8409.h\"\n\n \n\nstatic int cs8409_parse_auto_config(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tint err;\n\tint i;\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (spec->gen.dyn_adc_switch) {\n\t\tunsigned int done = 0;\n\n\t\tfor (i = 0; i < spec->gen.input_mux.num_items; i++) {\n\t\t\tint idx = spec->gen.dyn_adc_idx[i];\n\n\t\t\tif (done & (1 << idx))\n\t\t\t\tcontinue;\n\t\t\tsnd_hda_gen_fix_pin_power(codec, spec->gen.adc_nids[idx]);\n\t\t\tdone |= 1 << idx;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cs8409_disable_i2c_clock_worker(struct work_struct *work);\n\nstatic struct cs8409_spec *cs8409_alloc_spec(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn NULL;\n\tcodec->spec = spec;\n\tspec->codec = codec;\n\tcodec->power_save_node = 1;\n\tmutex_init(&spec->i2c_mux);\n\tINIT_DELAYED_WORK(&spec->i2c_clk_work, cs8409_disable_i2c_clock_worker);\n\tsnd_hda_gen_spec_init(&spec->gen);\n\n\treturn spec;\n}\n\nstatic inline int cs8409_vendor_coef_get(struct hda_codec *codec, unsigned int idx)\n{\n\tsnd_hda_codec_write(codec, CS8409_PIN_VENDOR_WIDGET, 0, AC_VERB_SET_COEF_INDEX, idx);\n\treturn snd_hda_codec_read(codec, CS8409_PIN_VENDOR_WIDGET, 0, AC_VERB_GET_PROC_COEF, 0);\n}\n\nstatic inline void cs8409_vendor_coef_set(struct hda_codec *codec, unsigned int idx,\n\t\t\t\t\t  unsigned int coef)\n{\n\tsnd_hda_codec_write(codec, CS8409_PIN_VENDOR_WIDGET, 0, AC_VERB_SET_COEF_INDEX, idx);\n\tsnd_hda_codec_write(codec, CS8409_PIN_VENDOR_WIDGET, 0, AC_VERB_SET_PROC_COEF, coef);\n}\n\n \nstatic void cs8409_disable_i2c_clock(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\n\tmutex_lock(&spec->i2c_mux);\n\tif (spec->i2c_clck_enabled) {\n\t\tcs8409_vendor_coef_set(spec->codec, 0x0,\n\t\t\t       cs8409_vendor_coef_get(spec->codec, 0x0) & 0xfffffff7);\n\t\tspec->i2c_clck_enabled = 0;\n\t}\n\tmutex_unlock(&spec->i2c_mux);\n}\n\n \nstatic void cs8409_disable_i2c_clock_worker(struct work_struct *work)\n{\n\tstruct cs8409_spec *spec = container_of(work, struct cs8409_spec, i2c_clk_work.work);\n\n\tcs8409_disable_i2c_clock(spec->codec);\n}\n\n \nstatic void cs8409_enable_i2c_clock(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\n\t \n\tcancel_delayed_work(&spec->i2c_clk_work);\n\n\tif (!spec->i2c_clck_enabled) {\n\t\tcs8409_vendor_coef_set(codec, 0x0, cs8409_vendor_coef_get(codec, 0x0) | 0x8);\n\t\tspec->i2c_clck_enabled = 1;\n\t}\n\tqueue_delayed_work(system_power_efficient_wq, &spec->i2c_clk_work, msecs_to_jiffies(25));\n}\n\n \nstatic int cs8409_i2c_wait_complete(struct hda_codec *codec)\n{\n\tunsigned int retval;\n\n\treturn read_poll_timeout(cs8409_vendor_coef_get, retval, retval & 0x18,\n\t\tCS42L42_I2C_SLEEP_US, CS42L42_I2C_TIMEOUT_US, false, codec, CS8409_I2C_STS);\n}\n\n \nstatic void cs8409_set_i2c_dev_addr(struct hda_codec *codec, unsigned int addr)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\n\tif (spec->dev_addr != addr) {\n\t\tcs8409_vendor_coef_set(codec, CS8409_I2C_ADDR, addr);\n\t\tspec->dev_addr = addr;\n\t}\n}\n\n \nstatic int cs8409_i2c_set_page(struct sub_codec *scodec, unsigned int i2c_reg)\n{\n\tstruct hda_codec *codec = scodec->codec;\n\n\tif (scodec->paged && (scodec->last_page != (i2c_reg >> 8))) {\n\t\tcs8409_vendor_coef_set(codec, CS8409_I2C_QWRITE, i2c_reg >> 8);\n\t\tif (cs8409_i2c_wait_complete(codec) < 0)\n\t\t\treturn -EIO;\n\t\tscodec->last_page = i2c_reg >> 8;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cs8409_i2c_read(struct sub_codec *scodec, unsigned int addr)\n{\n\tstruct hda_codec *codec = scodec->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int i2c_reg_data;\n\tunsigned int read_data;\n\n\tif (scodec->suspended)\n\t\treturn -EPERM;\n\n\tmutex_lock(&spec->i2c_mux);\n\tcs8409_enable_i2c_clock(codec);\n\tcs8409_set_i2c_dev_addr(codec, scodec->addr);\n\n\tif (cs8409_i2c_set_page(scodec, addr))\n\t\tgoto error;\n\n\ti2c_reg_data = (addr << 8) & 0x0ffff;\n\tcs8409_vendor_coef_set(codec, CS8409_I2C_QREAD, i2c_reg_data);\n\tif (cs8409_i2c_wait_complete(codec) < 0)\n\t\tgoto error;\n\n\t \n\tread_data = cs8409_vendor_coef_get(codec, CS8409_I2C_QREAD);\n\n\tmutex_unlock(&spec->i2c_mux);\n\n\treturn read_data & 0x0ff;\n\nerror:\n\tmutex_unlock(&spec->i2c_mux);\n\tcodec_err(codec, \"%s() Failed 0x%02x : 0x%04x\\n\", __func__, scodec->addr, addr);\n\treturn -EIO;\n}\n\n \nstatic int cs8409_i2c_bulk_read(struct sub_codec *scodec, struct cs8409_i2c_param *seq, int count)\n{\n\tstruct hda_codec *codec = scodec->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int i2c_reg_data;\n\tint i;\n\n\tif (scodec->suspended)\n\t\treturn -EPERM;\n\n\tmutex_lock(&spec->i2c_mux);\n\tcs8409_set_i2c_dev_addr(codec, scodec->addr);\n\n\tfor (i = 0; i < count; i++) {\n\t\tcs8409_enable_i2c_clock(codec);\n\t\tif (cs8409_i2c_set_page(scodec, seq[i].addr))\n\t\t\tgoto error;\n\n\t\ti2c_reg_data = (seq[i].addr << 8) & 0x0ffff;\n\t\tcs8409_vendor_coef_set(codec, CS8409_I2C_QREAD, i2c_reg_data);\n\n\t\tif (cs8409_i2c_wait_complete(codec) < 0)\n\t\t\tgoto error;\n\n\t\tseq[i].value = cs8409_vendor_coef_get(codec, CS8409_I2C_QREAD) & 0xff;\n\t}\n\n\tmutex_unlock(&spec->i2c_mux);\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&spec->i2c_mux);\n\tcodec_err(codec, \"I2C Bulk Write Failed 0x%02x\\n\", scodec->addr);\n\treturn -EIO;\n}\n\n \nstatic int cs8409_i2c_write(struct sub_codec *scodec, unsigned int addr, unsigned int value)\n{\n\tstruct hda_codec *codec = scodec->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int i2c_reg_data;\n\n\tif (scodec->suspended)\n\t\treturn -EPERM;\n\n\tmutex_lock(&spec->i2c_mux);\n\n\tcs8409_enable_i2c_clock(codec);\n\tcs8409_set_i2c_dev_addr(codec, scodec->addr);\n\n\tif (cs8409_i2c_set_page(scodec, addr))\n\t\tgoto error;\n\n\ti2c_reg_data = ((addr << 8) & 0x0ff00) | (value & 0x0ff);\n\tcs8409_vendor_coef_set(codec, CS8409_I2C_QWRITE, i2c_reg_data);\n\n\tif (cs8409_i2c_wait_complete(codec) < 0)\n\t\tgoto error;\n\n\tmutex_unlock(&spec->i2c_mux);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&spec->i2c_mux);\n\tcodec_err(codec, \"%s() Failed 0x%02x : 0x%04x\\n\", __func__, scodec->addr, addr);\n\treturn -EIO;\n}\n\n \nstatic int cs8409_i2c_bulk_write(struct sub_codec *scodec, const struct cs8409_i2c_param *seq,\n\t\t\t\t int count)\n{\n\tstruct hda_codec *codec = scodec->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int i2c_reg_data;\n\tint i;\n\n\tif (scodec->suspended)\n\t\treturn -EPERM;\n\n\tmutex_lock(&spec->i2c_mux);\n\tcs8409_set_i2c_dev_addr(codec, scodec->addr);\n\n\tfor (i = 0; i < count; i++) {\n\t\tcs8409_enable_i2c_clock(codec);\n\t\tif (cs8409_i2c_set_page(scodec, seq[i].addr))\n\t\t\tgoto error;\n\n\t\ti2c_reg_data = ((seq[i].addr << 8) & 0x0ff00) | (seq[i].value & 0x0ff);\n\t\tcs8409_vendor_coef_set(codec, CS8409_I2C_QWRITE, i2c_reg_data);\n\n\t\tif (cs8409_i2c_wait_complete(codec) < 0)\n\t\t\tgoto error;\n\t}\n\n\tmutex_unlock(&spec->i2c_mux);\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&spec->i2c_mux);\n\tcodec_err(codec, \"I2C Bulk Write Failed 0x%02x\\n\", scodec->addr);\n\treturn -EIO;\n}\n\nstatic int cs8409_init(struct hda_codec *codec)\n{\n\tint ret = snd_hda_gen_init(codec);\n\n\tif (!ret)\n\t\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_INIT);\n\n\treturn ret;\n}\n\nstatic int cs8409_build_controls(struct hda_codec *codec)\n{\n\tint err;\n\n\terr = snd_hda_gen_build_controls(codec);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_BUILD);\n\n\treturn 0;\n}\n\n \nstatic void cs8409_enable_ur(struct hda_codec *codec, int flag)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int ur_gpios = 0;\n\tint i;\n\n\tfor (i = 0; i < spec->num_scodecs; i++)\n\t\tur_gpios |= spec->scodecs[i]->irq_mask;\n\n\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_UNSOLICITED_RSP_MASK,\n\t\t\t    flag ? ur_gpios : 0);\n\n\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_UNSOLICITED_ENABLE,\n\t\t\t    flag ? AC_UNSOL_ENABLED : 0);\n}\n\nstatic void cs8409_fix_caps(struct hda_codec *codec, unsigned int nid)\n{\n\tint caps;\n\n\t \n\tcaps = snd_hdac_read_parm(&codec->core, nid, AC_PAR_PIN_CAP);\n\tif (caps >= 0)\n\t\tsnd_hdac_override_parm(&codec->core, nid, AC_PAR_PIN_CAP,\n\t\t\t\t       (caps | (AC_PINCAP_IMP_SENSE | AC_PINCAP_PRES_DETECT)));\n\n\tsnd_hda_override_wcaps(codec, nid, (get_wcaps(codec, nid) | AC_WCAP_UNSOL_CAP));\n}\n\nstatic int cs8409_spk_sw_gpio_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct cs8409_spec *spec = codec->spec;\n\n\tucontrol->value.integer.value[0] = !!(spec->gpio_data & spec->speaker_pdn_gpio);\n\treturn 0;\n}\n\nstatic int cs8409_spk_sw_gpio_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct cs8409_spec *spec = codec->spec;\n\tunsigned int gpio_data;\n\n\tgpio_data = (spec->gpio_data & ~spec->speaker_pdn_gpio) |\n\t\t(ucontrol->value.integer.value[0] ? spec->speaker_pdn_gpio : 0);\n\tif (gpio_data == spec->gpio_data)\n\t\treturn 0;\n\tspec->gpio_data = gpio_data;\n\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DATA, spec->gpio_data);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new cs8409_spk_sw_ctrl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = cs8409_spk_sw_gpio_get,\n\t.put = cs8409_spk_sw_gpio_put,\n};\n\n \n\nint cs42l42_volume_info(struct snd_kcontrol *kctrl, struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int ofs = get_amp_offset(kctrl);\n\tu8 chs = get_amp_channels(kctrl);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->value.integer.step = 1;\n\tuinfo->count = chs == 3 ? 2 : 1;\n\n\tswitch (ofs) {\n\tcase CS42L42_VOL_DAC:\n\t\tuinfo->value.integer.min = CS42L42_HP_VOL_REAL_MIN;\n\t\tuinfo->value.integer.max = CS42L42_HP_VOL_REAL_MAX;\n\t\tbreak;\n\tcase CS42L42_VOL_ADC:\n\t\tuinfo->value.integer.min = CS42L42_AMIC_VOL_REAL_MIN;\n\t\tuinfo->value.integer.max = CS42L42_AMIC_VOL_REAL_MAX;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint cs42l42_volume_get(struct snd_kcontrol *kctrl, struct snd_ctl_elem_value *uctrl)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kctrl);\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[get_amp_index(kctrl)];\n\tint chs = get_amp_channels(kctrl);\n\tunsigned int ofs = get_amp_offset(kctrl);\n\tlong *valp = uctrl->value.integer.value;\n\n\tswitch (ofs) {\n\tcase CS42L42_VOL_DAC:\n\t\tif (chs & BIT(0))\n\t\t\t*valp++ = cs42l42->vol[ofs];\n\t\tif (chs & BIT(1))\n\t\t\t*valp = cs42l42->vol[ofs+1];\n\t\tbreak;\n\tcase CS42L42_VOL_ADC:\n\t\tif (chs & BIT(0))\n\t\t\t*valp = cs42l42->vol[ofs];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void cs42l42_mute(struct sub_codec *cs42l42, int vol_type,\n\tunsigned int chs, bool mute)\n{\n\tif (mute) {\n\t\tif (vol_type == CS42L42_VOL_DAC) {\n\t\t\tif (chs & BIT(0))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_MIXER_CHA_VOL, 0x3f);\n\t\t\tif (chs & BIT(1))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_MIXER_CHB_VOL, 0x3f);\n\t\t} else if (vol_type == CS42L42_VOL_ADC) {\n\t\t\tif (chs & BIT(0))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_ADC_VOLUME, 0x9f);\n\t\t}\n\t} else {\n\t\tif (vol_type == CS42L42_VOL_DAC) {\n\t\t\tif (chs & BIT(0))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_MIXER_CHA_VOL,\n\t\t\t\t\t-(cs42l42->vol[CS42L42_DAC_CH0_VOL_OFFSET])\n\t\t\t\t\t& CS42L42_MIXER_CH_VOL_MASK);\n\t\t\tif (chs & BIT(1))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_MIXER_CHB_VOL,\n\t\t\t\t\t-(cs42l42->vol[CS42L42_DAC_CH1_VOL_OFFSET])\n\t\t\t\t\t& CS42L42_MIXER_CH_VOL_MASK);\n\t\t} else if (vol_type == CS42L42_VOL_ADC) {\n\t\t\tif (chs & BIT(0))\n\t\t\t\tcs8409_i2c_write(cs42l42, CS42L42_ADC_VOLUME,\n\t\t\t\t\tcs42l42->vol[CS42L42_ADC_VOL_OFFSET]\n\t\t\t\t\t& CS42L42_REG_AMIC_VOL_MASK);\n\t\t}\n\t}\n}\n\nint cs42l42_volume_put(struct snd_kcontrol *kctrl, struct snd_ctl_elem_value *uctrl)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kctrl);\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[get_amp_index(kctrl)];\n\tint chs = get_amp_channels(kctrl);\n\tunsigned int ofs = get_amp_offset(kctrl);\n\tlong *valp = uctrl->value.integer.value;\n\n\tswitch (ofs) {\n\tcase CS42L42_VOL_DAC:\n\t\tif (chs & BIT(0))\n\t\t\tcs42l42->vol[ofs] = *valp;\n\t\tif (chs & BIT(1)) {\n\t\t\tvalp++;\n\t\t\tcs42l42->vol[ofs + 1] = *valp;\n\t\t}\n\t\tif (spec->playback_started)\n\t\t\tcs42l42_mute(cs42l42, CS42L42_VOL_DAC, chs, false);\n\t\tbreak;\n\tcase CS42L42_VOL_ADC:\n\t\tif (chs & BIT(0))\n\t\t\tcs42l42->vol[ofs] = *valp;\n\t\tif (spec->capture_started)\n\t\t\tcs42l42_mute(cs42l42, CS42L42_VOL_ADC, chs, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void cs42l42_playback_pcm_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   int action)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42;\n\tint i;\n\tbool mute;\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tmute = false;\n\t\tspec->playback_started = 1;\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tmute = true;\n\t\tspec->playback_started = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < spec->num_scodecs; i++) {\n\t\tcs42l42 = spec->scodecs[i];\n\t\tcs42l42_mute(cs42l42, CS42L42_VOL_DAC, 0x3, mute);\n\t}\n}\n\nstatic void cs42l42_capture_pcm_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t   struct hda_codec *codec,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   int action)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42;\n\tint i;\n\tbool mute;\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tmute = false;\n\t\tspec->capture_started = 1;\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tmute = true;\n\t\tspec->capture_started = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < spec->num_scodecs; i++) {\n\t\tcs42l42 = spec->scodecs[i];\n\t\tcs42l42_mute(cs42l42, CS42L42_VOL_ADC, 0x3, mute);\n\t}\n}\n\n \nstatic void cs42l42_enable_jack_detect(struct sub_codec *cs42l42)\n{\n\tcs8409_i2c_write(cs42l42, CS42L42_HSBIAS_SC_AUTOCTL, cs42l42->hsbias_hiz);\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_WAKE_CTL, 0x00C1);\n\t \n\tusleep_range(2500, 3000);\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_WAKE_CTL, 0x00C0);\n\t \n\tcs8409_i2c_read(cs42l42, CS42L42_TSRS_PLUG_STATUS);\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_TSRS_PLUG_INT_MASK, 0xF3);\n}\n\n \nstatic void cs42l42_run_jack_detect(struct sub_codec *cs42l42)\n{\n\t \n\tcs8409_i2c_read(cs42l42, CS42L42_CODEC_STATUS);\n\tcs8409_i2c_read(cs42l42, CS42L42_DET_STATUS1);\n\tcs8409_i2c_write(cs42l42, CS42L42_TSRS_PLUG_INT_MASK, 0xFF);\n\tcs8409_i2c_read(cs42l42, CS42L42_TSRS_PLUG_STATUS);\n\n\tcs8409_i2c_write(cs42l42, CS42L42_PWR_CTL2, 0x87);\n\tcs8409_i2c_write(cs42l42, CS42L42_DAC_CTL2, 0x86);\n\tcs8409_i2c_write(cs42l42, CS42L42_MISC_DET_CTL, 0x07);\n\tcs8409_i2c_write(cs42l42, CS42L42_CODEC_INT_MASK, 0xFD);\n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL2, 0x80);\n\t \n\tusleep_range(20000, 25000);\n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL1, 0x77);\n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL2, 0xc0);\n}\n\nstatic int cs42l42_manual_hs_det(struct sub_codec *cs42l42)\n{\n\tunsigned int hs_det_status;\n\tunsigned int hs_det_comp1;\n\tunsigned int hs_det_comp2;\n\tunsigned int hs_det_sw;\n\tunsigned int hs_type;\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL2,\n\t\t\t (1 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t\t (0 << CS42L42_HSDET_SET_SHIFT) |\n\t\t\t (0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t\t (0 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL1,\n\t\t\t (CS42L42_HSDET_COMP1_LVL_VAL << CS42L42_HSDET_COMP1_LVL_SHIFT) |\n\t\t\t (CS42L42_HSDET_COMP2_LVL_VAL << CS42L42_HSDET_COMP2_LVL_SHIFT));\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HS_SWITCH_CTL, CS42L42_HSDET_SW_COMP1);\n\n\tmsleep(100);\n\n\ths_det_status = cs8409_i2c_read(cs42l42, CS42L42_HS_DET_STATUS);\n\n\ths_det_comp1 = (hs_det_status & CS42L42_HSDET_COMP1_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP1_OUT_SHIFT;\n\ths_det_comp2 = (hs_det_status & CS42L42_HSDET_COMP2_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP2_OUT_SHIFT;\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HS_SWITCH_CTL, CS42L42_HSDET_SW_COMP2);\n\n\tmsleep(100);\n\n\ths_det_status = cs8409_i2c_read(cs42l42, CS42L42_HS_DET_STATUS);\n\n\ths_det_comp1 |= ((hs_det_status & CS42L42_HSDET_COMP1_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP1_OUT_SHIFT) << 1;\n\ths_det_comp2 |= ((hs_det_status & CS42L42_HSDET_COMP2_OUT_MASK) >>\n\t\t\tCS42L42_HSDET_COMP2_OUT_SHIFT) << 1;\n\n\t \n\tswitch (hs_det_comp1) {\n\tcase CS42L42_HSDET_COMP_TYPE1:\n\t\ths_type = CS42L42_PLUG_CTIA;\n\t\ths_det_sw = CS42L42_HSDET_SW_TYPE1;\n\t\tbreak;\n\tcase CS42L42_HSDET_COMP_TYPE2:\n\t\ths_type = CS42L42_PLUG_OMTP;\n\t\ths_det_sw = CS42L42_HSDET_SW_TYPE2;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tswitch (hs_det_comp2) {\n\t\tcase CS42L42_HSDET_COMP_TYPE1:\n\t\t\ths_type = CS42L42_PLUG_CTIA;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE1;\n\t\t\tbreak;\n\t\tcase CS42L42_HSDET_COMP_TYPE2:\n\t\t\ths_type = CS42L42_PLUG_OMTP;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE2;\n\t\t\tbreak;\n\t\tcase CS42L42_HSDET_COMP_TYPE3:\n\t\t\ths_type = CS42L42_PLUG_HEADPHONE;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ths_type = CS42L42_PLUG_INVALID;\n\t\t\ths_det_sw = CS42L42_HSDET_SW_TYPE4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HS_SWITCH_CTL, hs_det_sw);\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL2,\n\t\t\t (0 << CS42L42_HSDET_CTRL_SHIFT) |\n\t\t\t (0 << CS42L42_HSDET_SET_SHIFT) |\n\t\t\t (0 << CS42L42_HSBIAS_REF_SHIFT) |\n\t\t\t (0 << CS42L42_HSDET_AUTO_TIME_SHIFT));\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL1,\n\t\t\t (CS42L42_HSDET_COMP1_LVL_DEFAULT << CS42L42_HSDET_COMP1_LVL_SHIFT) |\n\t\t\t (CS42L42_HSDET_COMP2_LVL_DEFAULT << CS42L42_HSDET_COMP2_LVL_SHIFT));\n\n\treturn hs_type;\n}\n\nstatic int cs42l42_handle_tip_sense(struct sub_codec *cs42l42, unsigned int reg_ts_status)\n{\n\tint status_changed = 0;\n\n\t \n\tswitch (reg_ts_status) {\n\tcase CS42L42_TS_PLUG:\n\t\tif (cs42l42->no_type_dect) {\n\t\t\tstatus_changed = 1;\n\t\t\tcs42l42->hp_jack_in = 1;\n\t\t\tcs42l42->mic_jack_in = 0;\n\t\t} else {\n\t\t\tcs42l42_run_jack_detect(cs42l42);\n\t\t}\n\t\tbreak;\n\n\tcase CS42L42_TS_UNPLUG:\n\t\tstatus_changed = 1;\n\t\tcs42l42->hp_jack_in = 0;\n\t\tcs42l42->mic_jack_in = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tcodec_dbg(cs42l42->codec, \"Tip Sense Detection: (%d)\\n\", reg_ts_status);\n\n\treturn status_changed;\n}\n\nstatic int cs42l42_jack_unsol_event(struct sub_codec *cs42l42)\n{\n\tint current_plug_status;\n\tint status_changed = 0;\n\tint reg_cdc_status;\n\tint reg_hs_status;\n\tint reg_ts_status;\n\tint type;\n\n\t \n\treg_cdc_status = cs8409_i2c_read(cs42l42, CS42L42_CODEC_STATUS);\n\treg_hs_status = cs8409_i2c_read(cs42l42, CS42L42_HS_DET_STATUS);\n\treg_ts_status = cs8409_i2c_read(cs42l42, CS42L42_TSRS_PLUG_STATUS);\n\n\t \n\tif (reg_cdc_status < 0 || reg_hs_status < 0 || reg_ts_status < 0)\n\t\treturn -EIO;\n\n\tcurrent_plug_status = (reg_ts_status & (CS42L42_TS_PLUG_MASK | CS42L42_TS_UNPLUG_MASK))\n\t\t\t\t>> CS42L42_TS_PLUG_SHIFT;\n\n\t \n\tif (reg_cdc_status & CS42L42_HSDET_AUTO_DONE_MASK) {\n\n\t\t \n\t\tcs8409_i2c_write(cs42l42, CS42L42_CODEC_INT_MASK, 0xFF);\n\n\t\ttype = (reg_hs_status & CS42L42_HSDET_TYPE_MASK) >> CS42L42_HSDET_TYPE_SHIFT;\n\n\t\t \n\t\tcs8409_i2c_write(cs42l42, CS42L42_HSDET_CTL2, 0x80);\n\n\t\tif (cs42l42->no_type_dect) {\n\t\t\tstatus_changed = cs42l42_handle_tip_sense(cs42l42, current_plug_status);\n\t\t} else {\n\t\t\tif (type == CS42L42_PLUG_INVALID || type == CS42L42_PLUG_HEADPHONE) {\n\t\t\t\tcodec_dbg(cs42l42->codec,\n\t\t\t\t\t  \"Auto detect value not valid (%d), running manual det\\n\",\n\t\t\t\t\t  type);\n\t\t\t\ttype = cs42l42_manual_hs_det(cs42l42);\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase CS42L42_PLUG_CTIA:\n\t\t\tcase CS42L42_PLUG_OMTP:\n\t\t\t\tstatus_changed = 1;\n\t\t\t\tcs42l42->hp_jack_in = 1;\n\t\t\t\tcs42l42->mic_jack_in = 1;\n\t\t\t\tbreak;\n\t\t\tcase CS42L42_PLUG_HEADPHONE:\n\t\t\t\tstatus_changed = 1;\n\t\t\t\tcs42l42->hp_jack_in = 1;\n\t\t\t\tcs42l42->mic_jack_in = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstatus_changed = 1;\n\t\t\t\tcs42l42->hp_jack_in = 0;\n\t\t\t\tcs42l42->mic_jack_in = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcodec_dbg(cs42l42->codec, \"Detection done (%d)\\n\", type);\n\t\t}\n\n\t\t \n\t\tcs8409_i2c_write(cs42l42, CS42L42_DAC_CTL2, 0x02);\n\t\t \n\t\tcs8409_i2c_write(cs42l42, CS42L42_TSRS_PLUG_INT_MASK, 0xF3);\n\t} else {\n\t\tstatus_changed = cs42l42_handle_tip_sense(cs42l42, current_plug_status);\n\t}\n\n\treturn status_changed;\n}\n\nstatic void cs42l42_resume(struct sub_codec *cs42l42)\n{\n\tstruct hda_codec *codec = cs42l42->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct cs8409_i2c_param irq_regs[] = {\n\t\t{ CS42L42_CODEC_STATUS, 0x00 },\n\t\t{ CS42L42_DET_INT_STATUS1, 0x00 },\n\t\t{ CS42L42_DET_INT_STATUS2, 0x00 },\n\t\t{ CS42L42_TSRS_PLUG_STATUS, 0x00 },\n\t};\n\tint fsv_old, fsv_new;\n\n\t \n\tspec->gpio_data = snd_hda_codec_read(codec, CS8409_PIN_AFG, 0, AC_VERB_GET_GPIO_DATA, 0);\n\tspec->gpio_data |= cs42l42->reset_gpio;\n\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DATA, spec->gpio_data);\n\tusleep_range(10000, 15000);\n\n\tcs42l42->suspended = 0;\n\n\t \n\tcs8409_i2c_bulk_write(cs42l42, cs42l42->init_seq, cs42l42->init_seq_num);\n\tmsleep(CS42L42_INIT_TIMEOUT_MS);\n\n\t \n\tcs8409_i2c_bulk_read(cs42l42, irq_regs, ARRAY_SIZE(irq_regs));\n\n\tfsv_old = cs8409_i2c_read(cs42l42, CS42L42_HP_CTL);\n\tif (cs42l42->full_scale_vol == CS42L42_FULL_SCALE_VOL_0DB)\n\t\tfsv_new = fsv_old & ~CS42L42_FULL_SCALE_VOL_MASK;\n\telse\n\t\tfsv_new = fsv_old & CS42L42_FULL_SCALE_VOL_MASK;\n\tif (fsv_new != fsv_old)\n\t\tcs8409_i2c_write(cs42l42, CS42L42_HP_CTL, fsv_new);\n\n\t \n\tsnd_hda_codec_allow_unsol_events(cs42l42->codec);\n\n\tcs42l42_enable_jack_detect(cs42l42);\n}\n\n#ifdef CONFIG_PM\nstatic void cs42l42_suspend(struct sub_codec *cs42l42)\n{\n\tstruct hda_codec *codec = cs42l42->codec;\n\tstruct cs8409_spec *spec = codec->spec;\n\tint reg_cdc_status = 0;\n\tconst struct cs8409_i2c_param cs42l42_pwr_down_seq[] = {\n\t\t{ CS42L42_DAC_CTL2, 0x02 },\n\t\t{ CS42L42_HS_CLAMP_DISABLE, 0x00 },\n\t\t{ CS42L42_MIXER_CHA_VOL, 0x3F },\n\t\t{ CS42L42_MIXER_ADC_VOL, 0x3F },\n\t\t{ CS42L42_MIXER_CHB_VOL, 0x3F },\n\t\t{ CS42L42_HP_CTL, 0x0F },\n\t\t{ CS42L42_ASP_RX_DAI0_EN, 0x00 },\n\t\t{ CS42L42_ASP_CLK_CFG, 0x00 },\n\t\t{ CS42L42_PWR_CTL1, 0xFE },\n\t\t{ CS42L42_PWR_CTL2, 0x8C },\n\t\t{ CS42L42_PWR_CTL1, 0xFF },\n\t};\n\n\tcs8409_i2c_bulk_write(cs42l42, cs42l42_pwr_down_seq, ARRAY_SIZE(cs42l42_pwr_down_seq));\n\n\tif (read_poll_timeout(cs8409_i2c_read, reg_cdc_status,\n\t\t\t(reg_cdc_status & 0x1), CS42L42_PDN_SLEEP_US, CS42L42_PDN_TIMEOUT_US,\n\t\t\ttrue, cs42l42, CS42L42_CODEC_STATUS) < 0)\n\t\tcodec_warn(codec, \"Timeout waiting for PDN_DONE for CS42L42\\n\");\n\n\t \n\tcs8409_i2c_write(cs42l42, CS42L42_PWR_CTL2, 0x9C);\n\tcs42l42->suspended = 1;\n\tcs42l42->last_page = 0;\n\tcs42l42->hp_jack_in = 0;\n\tcs42l42->mic_jack_in = 0;\n\n\t \n\tspec->gpio_data = snd_hda_codec_read(codec, CS8409_PIN_AFG, 0, AC_VERB_GET_GPIO_DATA, 0);\n\tspec->gpio_data &= ~cs42l42->reset_gpio;\n\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DATA, spec->gpio_data);\n}\n#endif\n\nstatic void cs8409_free(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\n\t \n\tcancel_delayed_work_sync(&spec->i2c_clk_work);\n\tcs8409_disable_i2c_clock(codec);\n\n\tsnd_hda_gen_free(codec);\n}\n\n \n\n \nstatic void cs8409_cs42l42_jack_unsol_event(struct hda_codec *codec, unsigned int res)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[CS8409_CODEC0];\n\tstruct hda_jack_tbl *jk;\n\n\t \n\tif (res & cs42l42->irq_mask)\n\t\treturn;\n\n\tif (cs42l42_jack_unsol_event(cs42l42)) {\n\t\tsnd_hda_set_pin_ctl(codec, CS8409_CS42L42_SPK_PIN_NID,\n\t\t\t\t    cs42l42->hp_jack_in ? 0 : PIN_OUT);\n\t\t \n\t\tjk = snd_hda_jack_tbl_get_mst(codec, CS8409_CS42L42_HP_PIN_NID, 0);\n\t\tif (jk)\n\t\t\tsnd_hda_jack_unsol_event(codec, (jk->tag << AC_UNSOL_RES_TAG_SHIFT) &\n\t\t\t\t\t\t\tAC_UNSOL_RES_TAG);\n\t\t \n\t\tjk = snd_hda_jack_tbl_get_mst(codec, CS8409_CS42L42_AMIC_PIN_NID, 0);\n\t\tif (jk)\n\t\t\tsnd_hda_jack_unsol_event(codec, (jk->tag << AC_UNSOL_RES_TAG_SHIFT) &\n\t\t\t\t\t\t\t AC_UNSOL_RES_TAG);\n\t}\n}\n\n#ifdef CONFIG_PM\n \nstatic int cs8409_cs42l42_suspend(struct hda_codec *codec)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tint i;\n\n\tspec->init_done = 0;\n\n\tcs8409_enable_ur(codec, 0);\n\n\tfor (i = 0; i < spec->num_scodecs; i++)\n\t\tcs42l42_suspend(spec->scodecs[i]);\n\n\t \n\tcancel_delayed_work_sync(&spec->i2c_clk_work);\n\tcs8409_disable_i2c_clock(codec);\n\n\tsnd_hda_shutup_pins(codec);\n\n\treturn 0;\n}\n#endif\n\n \nstatic void cs8409_cs42l42_hw_init(struct hda_codec *codec)\n{\n\tconst struct cs8409_cir_param *seq = cs8409_cs42l42_hw_cfg;\n\tconst struct cs8409_cir_param *seq_bullseye = cs8409_cs42l42_bullseye_atn;\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[CS8409_CODEC0];\n\n\tif (spec->gpio_mask) {\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_MASK,\n\t\t\tspec->gpio_mask);\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DIRECTION,\n\t\t\tspec->gpio_dir);\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\tspec->gpio_data);\n\t}\n\n\tfor (; seq->nid; seq++)\n\t\tcs8409_vendor_coef_set(codec, seq->cir, seq->coeff);\n\n\tif (codec->fixup_id == CS8409_BULLSEYE) {\n\t\tfor (; seq_bullseye->nid; seq_bullseye++)\n\t\t\tcs8409_vendor_coef_set(codec, seq_bullseye->cir, seq_bullseye->coeff);\n\t}\n\n\tswitch (codec->fixup_id) {\n\tcase CS8409_CYBORG:\n\tcase CS8409_WARLOCK_MLK_DUAL_MIC:\n\t\t \n\t\tcs8409_vendor_coef_set(codec, CS8409_DMIC_CFG, 0x0003);\n\t\tbreak;\n\tcase CS8409_ODIN:\n\t\t \n\t\tcs8409_vendor_coef_set(codec, CS8409_PAD_CFG_SLW_RATE_CTRL, 0xfc00);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcs42l42_resume(cs42l42);\n\n\t \n\tcs8409_enable_ur(codec, 1);\n}\n\nstatic const struct hda_codec_ops cs8409_cs42l42_patch_ops = {\n\t.build_controls = cs8409_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = cs8409_init,\n\t.free = cs8409_free,\n\t.unsol_event = cs8409_cs42l42_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = cs8409_cs42l42_suspend,\n#endif\n};\n\nstatic int cs8409_cs42l42_exec_verb(struct hdac_device *dev, unsigned int cmd, unsigned int flags,\n\t\t\t\t    unsigned int *res)\n{\n\tstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[CS8409_CODEC0];\n\n\tunsigned int nid = ((cmd >> 20) & 0x07f);\n\tunsigned int verb = ((cmd >> 8) & 0x0fff);\n\n\t \n\tswitch (nid) {\n\tcase CS8409_CS42L42_HP_PIN_NID:\n\t\tif (verb == AC_VERB_GET_PIN_SENSE) {\n\t\t\t*res = (cs42l42->hp_jack_in) ? AC_PINSENSE_PRESENCE : 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase CS8409_CS42L42_AMIC_PIN_NID:\n\t\tif (verb == AC_VERB_GET_PIN_SENSE) {\n\t\t\t*res = (cs42l42->mic_jack_in) ? AC_PINSENSE_PRESENCE : 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn spec->exec_verb(dev, cmd, flags, res);\n}\n\nvoid cs8409_cs42l42_fixups(struct hda_codec *codec, const struct hda_fixup *fix, int action)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\n\tswitch (action) {\n\tcase HDA_FIXUP_ACT_PRE_PROBE:\n\t\tsnd_hda_add_verbs(codec, cs8409_cs42l42_init_verbs);\n\t\t \n\t\tspec->exec_verb = codec->core.exec_verb;\n\t\tcodec->core.exec_verb = cs8409_cs42l42_exec_verb;\n\n\t\tspec->scodecs[CS8409_CODEC0] = &cs8409_cs42l42_codec;\n\t\tspec->num_scodecs = 1;\n\t\tspec->scodecs[CS8409_CODEC0]->codec = codec;\n\t\tcodec->patch_ops = cs8409_cs42l42_patch_ops;\n\n\t\tspec->gen.suppress_auto_mute = 1;\n\t\tspec->gen.no_primary_hp = 1;\n\t\tspec->gen.suppress_vmaster = 1;\n\n\t\tspec->speaker_pdn_gpio = 0;\n\n\t\t \n\t\tspec->gpio_dir = spec->scodecs[CS8409_CODEC0]->reset_gpio;\n\t\tspec->gpio_data = 0;\n\t\tspec->gpio_mask = 0x03f;\n\n\t\t \n\t\tsnd_hda_sequence_write(codec, cs8409_cs42l42_init_verbs);\n\n\t\tcs8409_fix_caps(codec, CS8409_CS42L42_HP_PIN_NID);\n\t\tcs8409_fix_caps(codec, CS8409_CS42L42_AMIC_PIN_NID);\n\n\t\tspec->scodecs[CS8409_CODEC0]->hsbias_hiz = 0x0020;\n\n\t\tswitch (codec->fixup_id) {\n\t\tcase CS8409_CYBORG:\n\t\t\tspec->scodecs[CS8409_CODEC0]->full_scale_vol =\n\t\t\t\tCS42L42_FULL_SCALE_VOL_MINUS6DB;\n\t\t\tspec->speaker_pdn_gpio = CS8409_CYBORG_SPEAKER_PDN;\n\t\t\tbreak;\n\t\tcase CS8409_ODIN:\n\t\t\tspec->scodecs[CS8409_CODEC0]->full_scale_vol = CS42L42_FULL_SCALE_VOL_0DB;\n\t\t\tspec->speaker_pdn_gpio = CS8409_CYBORG_SPEAKER_PDN;\n\t\t\tbreak;\n\t\tcase CS8409_WARLOCK_MLK:\n\t\tcase CS8409_WARLOCK_MLK_DUAL_MIC:\n\t\t\tspec->scodecs[CS8409_CODEC0]->full_scale_vol = CS42L42_FULL_SCALE_VOL_0DB;\n\t\t\tspec->speaker_pdn_gpio = CS8409_WARLOCK_SPEAKER_PDN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspec->scodecs[CS8409_CODEC0]->full_scale_vol =\n\t\t\t\tCS42L42_FULL_SCALE_VOL_MINUS6DB;\n\t\t\tspec->speaker_pdn_gpio = CS8409_WARLOCK_SPEAKER_PDN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spec->speaker_pdn_gpio > 0) {\n\t\t\tspec->gpio_dir |= spec->speaker_pdn_gpio;\n\t\t\tspec->gpio_data |= spec->speaker_pdn_gpio;\n\t\t}\n\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_PROBE:\n\t\t \n\t\tspec->gen.stream_analog_playback = &cs42l42_48k_pcm_analog_playback;\n\t\tspec->gen.stream_analog_capture = &cs42l42_48k_pcm_analog_capture;\n\t\t \n\t\tspec->gen.pcm_playback_hook = cs42l42_playback_pcm_hook;\n\t\tspec->gen.pcm_capture_hook = cs42l42_capture_pcm_hook;\n\t\tif (codec->fixup_id != CS8409_ODIN)\n\t\t\t \n\t\t\tsnd_hda_codec_amp_init_stereo(codec, CS8409_CS42L42_DMIC_ADC_PIN_NID,\n\t\t\t\t\t\t      HDA_INPUT, 0, 0xff, 0x19);\n\t\tsnd_hda_gen_add_kctl(&spec->gen, \"Headphone Playback Volume\",\n\t\t\t\t&cs42l42_dac_volume_mixer);\n\t\tsnd_hda_gen_add_kctl(&spec->gen, \"Mic Capture Volume\",\n\t\t\t\t&cs42l42_adc_volume_mixer);\n\t\tif (spec->speaker_pdn_gpio > 0)\n\t\t\tsnd_hda_gen_add_kctl(&spec->gen, \"Speaker Playback Switch\",\n\t\t\t\t\t     &cs8409_spk_sw_ctrl);\n\t\t \n\t\tcs8409_enable_ur(codec, 0);\n\t\tsnd_hda_codec_set_name(codec, \"CS8409/CS42L42\");\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_INIT:\n\t\tcs8409_cs42l42_hw_init(codec);\n\t\tspec->init_done = 1;\n\t\tif (spec->init_done && spec->build_ctrl_done\n\t\t\t&& !spec->scodecs[CS8409_CODEC0]->hp_jack_in)\n\t\t\tcs42l42_run_jack_detect(spec->scodecs[CS8409_CODEC0]);\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_BUILD:\n\t\tspec->build_ctrl_done = 1;\n\t\t \n\t\tif (spec->init_done && spec->build_ctrl_done\n\t\t\t&& !spec->scodecs[CS8409_CODEC0]->hp_jack_in)\n\t\t\tcs42l42_run_jack_detect(spec->scodecs[CS8409_CODEC0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\n \nstatic void dolphin_jack_unsol_event(struct hda_codec *codec, unsigned int res)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42;\n\tstruct hda_jack_tbl *jk;\n\n\tcs42l42 = spec->scodecs[CS8409_CODEC0];\n\tif (!cs42l42->suspended && (~res & cs42l42->irq_mask) &&\n\t    cs42l42_jack_unsol_event(cs42l42)) {\n\t\tjk = snd_hda_jack_tbl_get_mst(codec, DOLPHIN_HP_PIN_NID, 0);\n\t\tif (jk)\n\t\t\tsnd_hda_jack_unsol_event(codec,\n\t\t\t\t\t\t (jk->tag << AC_UNSOL_RES_TAG_SHIFT) &\n\t\t\t\t\t\t  AC_UNSOL_RES_TAG);\n\n\t\tjk = snd_hda_jack_tbl_get_mst(codec, DOLPHIN_AMIC_PIN_NID, 0);\n\t\tif (jk)\n\t\t\tsnd_hda_jack_unsol_event(codec,\n\t\t\t\t\t\t (jk->tag << AC_UNSOL_RES_TAG_SHIFT) &\n\t\t\t\t\t\t  AC_UNSOL_RES_TAG);\n\t}\n\n\tcs42l42 = spec->scodecs[CS8409_CODEC1];\n\tif (!cs42l42->suspended && (~res & cs42l42->irq_mask) &&\n\t    cs42l42_jack_unsol_event(cs42l42)) {\n\t\tjk = snd_hda_jack_tbl_get_mst(codec, DOLPHIN_LO_PIN_NID, 0);\n\t\tif (jk)\n\t\t\tsnd_hda_jack_unsol_event(codec,\n\t\t\t\t\t\t (jk->tag << AC_UNSOL_RES_TAG_SHIFT) &\n\t\t\t\t\t\t  AC_UNSOL_RES_TAG);\n\t}\n}\n\n \nstatic void dolphin_hw_init(struct hda_codec *codec)\n{\n\tconst struct cs8409_cir_param *seq = dolphin_hw_cfg;\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42;\n\tint i;\n\n\tif (spec->gpio_mask) {\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_MASK,\n\t\t\t\t    spec->gpio_mask);\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DIRECTION,\n\t\t\t\t    spec->gpio_dir);\n\t\tsnd_hda_codec_write(codec, CS8409_PIN_AFG, 0, AC_VERB_SET_GPIO_DATA,\n\t\t\t\t    spec->gpio_data);\n\t}\n\n\tfor (; seq->nid; seq++)\n\t\tcs8409_vendor_coef_set(codec, seq->cir, seq->coeff);\n\n\tfor (i = 0; i < spec->num_scodecs; i++) {\n\t\tcs42l42 = spec->scodecs[i];\n\t\tcs42l42_resume(cs42l42);\n\t}\n\n\t \n\tcs8409_enable_ur(codec, 1);\n}\n\nstatic const struct hda_codec_ops cs8409_dolphin_patch_ops = {\n\t.build_controls = cs8409_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = cs8409_init,\n\t.free = cs8409_free,\n\t.unsol_event = dolphin_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = cs8409_cs42l42_suspend,\n#endif\n};\n\nstatic int dolphin_exec_verb(struct hdac_device *dev, unsigned int cmd, unsigned int flags,\n\t\t\t     unsigned int *res)\n{\n\tstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct sub_codec *cs42l42 = spec->scodecs[CS8409_CODEC0];\n\n\tunsigned int nid = ((cmd >> 20) & 0x07f);\n\tunsigned int verb = ((cmd >> 8) & 0x0fff);\n\n\t \n\tswitch (nid) {\n\tcase DOLPHIN_HP_PIN_NID:\n\tcase DOLPHIN_LO_PIN_NID:\n\t\tif (nid == DOLPHIN_LO_PIN_NID)\n\t\t\tcs42l42 = spec->scodecs[CS8409_CODEC1];\n\t\tif (verb == AC_VERB_GET_PIN_SENSE) {\n\t\t\t*res = (cs42l42->hp_jack_in) ? AC_PINSENSE_PRESENCE : 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase DOLPHIN_AMIC_PIN_NID:\n\t\tif (verb == AC_VERB_GET_PIN_SENSE) {\n\t\t\t*res = (cs42l42->mic_jack_in) ? AC_PINSENSE_PRESENCE : 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn spec->exec_verb(dev, cmd, flags, res);\n}\n\nvoid dolphin_fixups(struct hda_codec *codec, const struct hda_fixup *fix, int action)\n{\n\tstruct cs8409_spec *spec = codec->spec;\n\tstruct snd_kcontrol_new *kctrl;\n\tint i;\n\n\tswitch (action) {\n\tcase HDA_FIXUP_ACT_PRE_PROBE:\n\t\tsnd_hda_add_verbs(codec, dolphin_init_verbs);\n\t\t \n\t\tspec->exec_verb = codec->core.exec_verb;\n\t\tcodec->core.exec_verb = dolphin_exec_verb;\n\n\t\tspec->scodecs[CS8409_CODEC0] = &dolphin_cs42l42_0;\n\t\tspec->scodecs[CS8409_CODEC0]->codec = codec;\n\t\tspec->scodecs[CS8409_CODEC1] = &dolphin_cs42l42_1;\n\t\tspec->scodecs[CS8409_CODEC1]->codec = codec;\n\t\tspec->num_scodecs = 2;\n\n\t\tcodec->patch_ops = cs8409_dolphin_patch_ops;\n\n\t\t \n\t\tspec->gpio_dir = spec->scodecs[CS8409_CODEC0]->reset_gpio |\n\t\t\t\t spec->scodecs[CS8409_CODEC1]->reset_gpio;\n\t\tspec->gpio_data = 0;\n\t\tspec->gpio_mask = 0x03f;\n\n\t\t \n\t\tsnd_hda_sequence_write(codec, dolphin_init_verbs);\n\n\t\tsnd_hda_jack_add_kctl(codec, DOLPHIN_LO_PIN_NID, \"Line Out\", true,\n\t\t\t\t      SND_JACK_HEADPHONE, NULL);\n\n\t\tsnd_hda_jack_add_kctl(codec, DOLPHIN_AMIC_PIN_NID, \"Microphone\", true,\n\t\t\t\t      SND_JACK_MICROPHONE, NULL);\n\n\t\tcs8409_fix_caps(codec, DOLPHIN_HP_PIN_NID);\n\t\tcs8409_fix_caps(codec, DOLPHIN_LO_PIN_NID);\n\t\tcs8409_fix_caps(codec, DOLPHIN_AMIC_PIN_NID);\n\n\t\tspec->scodecs[CS8409_CODEC0]->full_scale_vol = CS42L42_FULL_SCALE_VOL_MINUS6DB;\n\t\tspec->scodecs[CS8409_CODEC1]->full_scale_vol = CS42L42_FULL_SCALE_VOL_MINUS6DB;\n\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_PROBE:\n\t\t \n\t\tspec->gen.stream_analog_playback = &cs42l42_48k_pcm_analog_playback;\n\t\tspec->gen.stream_analog_capture = &cs42l42_48k_pcm_analog_capture;\n\t\t \n\t\tspec->gen.pcm_playback_hook = cs42l42_playback_pcm_hook;\n\t\tspec->gen.pcm_capture_hook = cs42l42_capture_pcm_hook;\n\t\tsnd_hda_gen_add_kctl(&spec->gen, \"Headphone Playback Volume\",\n\t\t\t\t     &cs42l42_dac_volume_mixer);\n\t\tsnd_hda_gen_add_kctl(&spec->gen, \"Mic Capture Volume\", &cs42l42_adc_volume_mixer);\n\t\tkctrl = snd_hda_gen_add_kctl(&spec->gen, \"Line Out Playback Volume\",\n\t\t\t\t\t     &cs42l42_dac_volume_mixer);\n\t\t \n\t\tkctrl->private_value = HDA_COMPOSE_AMP_VAL_OFS(DOLPHIN_HP_PIN_NID, 3, CS8409_CODEC1,\n\t\t\t\t       HDA_OUTPUT, CS42L42_VOL_DAC) | HDA_AMP_VAL_MIN_MUTE;\n\t\tcs8409_enable_ur(codec, 0);\n\t\tsnd_hda_codec_set_name(codec, \"CS8409/CS42L42\");\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_INIT:\n\t\tdolphin_hw_init(codec);\n\t\tspec->init_done = 1;\n\t\tif (spec->init_done && spec->build_ctrl_done) {\n\t\t\tfor (i = 0; i < spec->num_scodecs; i++) {\n\t\t\t\tif (!spec->scodecs[i]->hp_jack_in)\n\t\t\t\t\tcs42l42_run_jack_detect(spec->scodecs[i]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HDA_FIXUP_ACT_BUILD:\n\t\tspec->build_ctrl_done = 1;\n\t\t \n\t\tif (spec->init_done && spec->build_ctrl_done) {\n\t\t\tfor (i = 0; i < spec->num_scodecs; i++) {\n\t\t\t\tif (!spec->scodecs[i]->hp_jack_in)\n\t\t\t\t\tcs42l42_run_jack_detect(spec->scodecs[i]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int patch_cs8409(struct hda_codec *codec)\n{\n\tint err;\n\n\tif (!cs8409_alloc_spec(codec))\n\t\treturn -ENOMEM;\n\n\tsnd_hda_pick_fixup(codec, cs8409_models, cs8409_fixup_tbl, cs8409_fixups);\n\n\tcodec_dbg(codec, \"Picked ID=%d, VID=%08x, DEV=%08x\\n\", codec->fixup_id,\n\t\t\t codec->bus->pci->subsystem_vendor,\n\t\t\t codec->bus->pci->subsystem_device);\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\terr = cs8409_parse_auto_config(codec);\n\tif (err < 0) {\n\t\tcs8409_free(codec);\n\t\treturn err;\n\t}\n\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\n\treturn 0;\n}\n\nstatic const struct hda_device_id snd_hda_id_cs8409[] = {\n\tHDA_CODEC_ENTRY(0x10138409, \"CS8409\", patch_cs8409),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_cs8409);\n\nstatic struct hda_codec_driver cs8409_driver = {\n\t.id = snd_hda_id_cs8409,\n};\nmodule_hda_codec_driver(cs8409_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cirrus Logic HDA bridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}