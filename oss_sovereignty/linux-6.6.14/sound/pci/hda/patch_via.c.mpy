{
  "module_name": "patch_via.c",
  "hash_id": "2c702b5840fe2245a0419334126cde4219e9b73828fbd66bd1986ceba7a67c4d",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/patch_via.c",
  "human_readable_source": "\n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/asoundef.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n\n \n#define VT1708_HP_PIN_NID\t0x20\n#define VT1708_CD_PIN_NID\t0x24\n\nenum VIA_HDA_CODEC {\n\tUNKNOWN = -1,\n\tVT1708,\n\tVT1709_10CH,\n\tVT1709_6CH,\n\tVT1708B_8CH,\n\tVT1708B_4CH,\n\tVT1708S,\n\tVT1708BCE,\n\tVT1702,\n\tVT1718S,\n\tVT1716S,\n\tVT2002P,\n\tVT1812,\n\tVT1802,\n\tVT1705CF,\n\tVT1808,\n\tCODEC_TYPES,\n};\n\n#define VT2002P_COMPATIBLE(spec) \\\n\t((spec)->codec_type == VT2002P ||\\\n\t (spec)->codec_type == VT1812 ||\\\n\t (spec)->codec_type == VT1802)\n\nstruct via_spec {\n\tstruct hda_gen_spec gen;\n\n\t \n\tunsigned int dmic_enabled;\n\tenum VIA_HDA_CODEC codec_type;\n\n\t \n\tbool alc_mode;\n\n\t \n\tint hp_work_active;\n\tint vt1708_jack_detect;\n};\n\nstatic enum VIA_HDA_CODEC get_codec_type(struct hda_codec *codec);\nstatic void via_playback_pcm_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  int action);\n\nstatic const struct hda_codec_ops via_patch_ops;  \n\nstatic struct via_spec *via_new_spec(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (spec == NULL)\n\t\treturn NULL;\n\n\tcodec->spec = spec;\n\tsnd_hda_gen_spec_init(&spec->gen);\n\tspec->codec_type = get_codec_type(codec);\n\t \n\tif (spec->codec_type == VT1708BCE)\n\t\tspec->codec_type = VT1708S;\n\tspec->gen.indep_hp = 1;\n\tspec->gen.keep_eapd_on = 1;\n\tspec->gen.dac_min_mute = 1;\n\tspec->gen.pcm_playback_hook = via_playback_pcm_hook;\n\tspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\n\tcodec->power_save_node = 1;\n\tspec->gen.power_down_unused = 1;\n\tcodec->patch_ops = via_patch_ops;\n\treturn spec;\n}\n\nstatic enum VIA_HDA_CODEC get_codec_type(struct hda_codec *codec)\n{\n\tu32 vendor_id = codec->core.vendor_id;\n\tu16 ven_id = vendor_id >> 16;\n\tu16 dev_id = vendor_id & 0xffff;\n\tenum VIA_HDA_CODEC codec_type;\n\n\t \n\tif (ven_id != 0x1106)\n\t\tcodec_type = UNKNOWN;\n\telse if (dev_id >= 0x1708 && dev_id <= 0x170b)\n\t\tcodec_type = VT1708;\n\telse if (dev_id >= 0xe710 && dev_id <= 0xe713)\n\t\tcodec_type = VT1709_10CH;\n\telse if (dev_id >= 0xe714 && dev_id <= 0xe717)\n\t\tcodec_type = VT1709_6CH;\n\telse if (dev_id >= 0xe720 && dev_id <= 0xe723) {\n\t\tcodec_type = VT1708B_8CH;\n\t\tif (snd_hda_param_read(codec, 0x16, AC_PAR_CONNLIST_LEN) == 0x7)\n\t\t\tcodec_type = VT1708BCE;\n\t} else if (dev_id >= 0xe724 && dev_id <= 0xe727)\n\t\tcodec_type = VT1708B_4CH;\n\telse if ((dev_id & 0xfff) == 0x397\n\t\t && (dev_id >> 12) < 8)\n\t\tcodec_type = VT1708S;\n\telse if ((dev_id & 0xfff) == 0x398\n\t\t && (dev_id >> 12) < 8)\n\t\tcodec_type = VT1702;\n\telse if ((dev_id & 0xfff) == 0x428\n\t\t && (dev_id >> 12) < 8)\n\t\tcodec_type = VT1718S;\n\telse if (dev_id == 0x0433 || dev_id == 0xa721)\n\t\tcodec_type = VT1716S;\n\telse if (dev_id == 0x0441 || dev_id == 0x4441)\n\t\tcodec_type = VT1718S;\n\telse if (dev_id == 0x0438 || dev_id == 0x4438)\n\t\tcodec_type = VT2002P;\n\telse if (dev_id == 0x0448)\n\t\tcodec_type = VT1812;\n\telse if (dev_id == 0x0440)\n\t\tcodec_type = VT1708S;\n\telse if ((dev_id & 0xfff) == 0x446)\n\t\tcodec_type = VT1802;\n\telse if (dev_id == 0x4760)\n\t\tcodec_type = VT1705CF;\n\telse if (dev_id == 0x4761 || dev_id == 0x4762)\n\t\tcodec_type = VT1808;\n\telse\n\t\tcodec_type = UNKNOWN;\n\treturn codec_type;\n};\n\nstatic void analog_low_current_mode(struct hda_codec *codec);\nstatic bool is_aa_path_mute(struct hda_codec *codec);\n\n#define hp_detect_with_aa(codec) \\\n\t(snd_hda_get_bool_hint(codec, \"analog_loopback_hp_detect\") == 1 && \\\n\t !is_aa_path_mute(codec))\n\nstatic void vt1708_stop_hp_work(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tif (spec->codec_type != VT1708 || !spec->gen.autocfg.hp_outs)\n\t\treturn;\n\tif (spec->hp_work_active) {\n\t\tsnd_hda_codec_write(codec, 0x1, 0, 0xf81, 1);\n\t\tcodec->jackpoll_interval = 0;\n\t\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\t\tspec->hp_work_active = false;\n\t}\n}\n\nstatic void vt1708_update_hp_work(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tif (spec->codec_type != VT1708 || !spec->gen.autocfg.hp_outs)\n\t\treturn;\n\tif (spec->vt1708_jack_detect) {\n\t\tif (!spec->hp_work_active) {\n\t\t\tcodec->jackpoll_interval = msecs_to_jiffies(100);\n\t\t\tsnd_hda_codec_write(codec, 0x1, 0, 0xf81, 0);\n\t\t\tschedule_delayed_work(&codec->jackpoll_work, 0);\n\t\t\tspec->hp_work_active = true;\n\t\t}\n\t} else if (!hp_detect_with_aa(codec))\n\t\tvt1708_stop_hp_work(codec);\n}\n\nstatic int via_pin_power_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\n}\n\nstatic int via_pin_power_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct via_spec *spec = codec->spec;\n\n\tucontrol->value.enumerated.item[0] = spec->gen.power_down_unused;\n\treturn 0;\n}\n\nstatic int via_pin_power_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct via_spec *spec = codec->spec;\n\tbool val = !!ucontrol->value.enumerated.item[0];\n\n\tif (val == spec->gen.power_down_unused)\n\t\treturn 0;\n\t   \n\tspec->gen.power_down_unused = val;\n\tanalog_low_current_mode(codec);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new via_pin_power_ctl_enum = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Dynamic Power-Control\",\n\t.info = via_pin_power_ctl_info,\n\t.get = via_pin_power_ctl_get,\n\t.put = via_pin_power_ctl_put,\n};\n\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\n \nstatic const struct snd_kcontrol_new via_beep_mixer[] = {\n\tHDA_CODEC_VOLUME_MONO(\"Beep Playback Volume\", 0, 1, 0, HDA_OUTPUT),\n\tHDA_CODEC_MUTE_BEEP_MONO(\"Beep Playback Switch\", 0, 1, 0, HDA_OUTPUT),\n};\n\nstatic int set_beep_amp(struct via_spec *spec, hda_nid_t nid,\n\t\t\tint idx, int dir)\n{\n\tstruct snd_kcontrol_new *knew;\n\tunsigned int beep_amp = HDA_COMPOSE_AMP_VAL(nid, 1, idx, dir);\n\tint i;\n\n\tspec->gen.beep_nid = nid;\n\tfor (i = 0; i < ARRAY_SIZE(via_beep_mixer); i++) {\n\t\tknew = snd_hda_gen_add_kctl(&spec->gen, NULL,\n\t\t\t\t\t    &via_beep_mixer[i]);\n\t\tif (!knew)\n\t\t\treturn -ENOMEM;\n\t\tknew->private_value = beep_amp;\n\t}\n\treturn 0;\n}\n\nstatic int auto_parse_beep(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\thda_nid_t nid;\n\n\tfor_each_hda_codec_node(nid, codec)\n\t\tif (get_wcaps_type(get_wcaps(codec, nid)) == AC_WID_BEEP)\n\t\t\treturn set_beep_amp(spec, nid, 0, HDA_OUTPUT);\n\treturn 0;\n}\n#else\n#define auto_parse_beep(codec)\t0\n#endif\n\n \nstatic bool is_aa_path_mute(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tconst struct hda_amp_list *p;\n\tint ch, v;\n\n\tp = spec->gen.loopback.amplist;\n\tif (!p)\n\t\treturn true;\n\tfor (; p->nid; p++) {\n\t\tfor (ch = 0; ch < 2; ch++) {\n\t\t\tv = snd_hda_codec_amp_read(codec, p->nid, ch, p->dir,\n\t\t\t\t\t\t   p->idx);\n\t\t\tif (!(v & HDA_AMP_MUTE) && v > 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic void __analog_low_current_mode(struct hda_codec *codec, bool force)\n{\n\tstruct via_spec *spec = codec->spec;\n\tbool enable;\n\tunsigned int verb, parm;\n\n\tif (!codec->power_save_node)\n\t\tenable = false;\n\telse\n\t\tenable = is_aa_path_mute(codec) && !spec->gen.active_streams;\n\tif (enable == spec->alc_mode && !force)\n\t\treturn;\n\tspec->alc_mode = enable;\n\n\t \n\tswitch (spec->codec_type) {\n\tcase VT1708B_8CH:\n\tcase VT1708B_4CH:\n\t\tverb = 0xf70;\n\t\tparm = enable ? 0x02 : 0x00;  \n\t\tbreak;\n\tcase VT1708S:\n\tcase VT1718S:\n\tcase VT1716S:\n\t\tverb = 0xf73;\n\t\tparm = enable ? 0x51 : 0xe1;  \n\t\tbreak;\n\tcase VT1702:\n\t\tverb = 0xf73;\n\t\tparm = enable ? 0x01 : 0x1d;  \n\t\tbreak;\n\tcase VT2002P:\n\tcase VT1812:\n\tcase VT1802:\n\t\tverb = 0xf93;\n\t\tparm = enable ? 0x00 : 0xe0;  \n\t\tbreak;\n\tcase VT1705CF:\n\tcase VT1808:\n\t\tverb = 0xf82;\n\t\tparm = enable ? 0x00 : 0xe0;   \n\t\tbreak;\n\tdefault:\n\t\treturn;\t\t \n\t}\n\t \n\tsnd_hda_codec_write(codec, codec->core.afg, 0, verb, parm);\n}\n\nstatic void analog_low_current_mode(struct hda_codec *codec)\n{\n\treturn __analog_low_current_mode(codec, false);\n}\n\nstatic void via_playback_pcm_hook(struct hda_pcm_stream *hinfo,\n\t\t\t\t  struct hda_codec *codec,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  int action)\n{\n\tanalog_low_current_mode(codec);\n\tvt1708_update_hp_work(codec);\n}\n\nstatic void via_free(struct hda_codec *codec)\n{\n\tvt1708_stop_hp_work(codec);\n\tsnd_hda_gen_free(codec);\n}\n\n#ifdef CONFIG_PM\nstatic int via_suspend(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tvt1708_stop_hp_work(codec);\n\n\t \n\tif (spec->codec_type == VT1802)\n\t\tsnd_hda_shutup_pins(codec);\n\n\treturn 0;\n}\n\nstatic int via_resume(struct hda_codec *codec)\n{\n\t \n\tmsleep(10);\n\tcodec->patch_ops.init(codec);\n\tsnd_hda_regmap_sync(codec);\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int via_check_power_status(struct hda_codec *codec, hda_nid_t nid)\n{\n\tstruct via_spec *spec = codec->spec;\n\tanalog_low_current_mode(codec);\n\tvt1708_update_hp_work(codec);\n\treturn snd_hda_check_amp_list_power(codec, &spec->gen.loopback, nid);\n}\n#endif\n\n \n\nstatic int via_init(struct hda_codec *codec);\n\nstatic const struct hda_codec_ops via_patch_ops = {\n\t.build_controls = snd_hda_gen_build_controls,\n\t.build_pcms = snd_hda_gen_build_pcms,\n\t.init = via_init,\n\t.free = via_free,\n\t.unsol_event = snd_hda_jack_unsol_event,\n#ifdef CONFIG_PM\n\t.suspend = via_suspend,\n\t.resume = via_resume,\n\t.check_power_status = via_check_power_status,\n#endif\n};\n\n\nstatic const struct hda_verb vt1708_init_verbs[] = {\n\t \n\t{0x1, 0xf81, 0x1},\n\t{ }\n};\nstatic void vt1708_set_pinconfig_connect(struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int def_conf;\n\tunsigned char seqassoc;\n\n\tdef_conf = snd_hda_codec_get_pincfg(codec, nid);\n\tseqassoc = (unsigned char) get_defcfg_association(def_conf);\n\tseqassoc = (seqassoc << 4) | get_defcfg_sequence(def_conf);\n\tif (get_defcfg_connect(def_conf) == AC_JACK_PORT_NONE\n\t    && (seqassoc == 0xf0 || seqassoc == 0xff)) {\n\t\tdef_conf = def_conf & (~(AC_JACK_PORT_BOTH << 30));\n\t\tsnd_hda_codec_set_pincfg(codec, nid, def_conf);\n\t}\n}\n\nstatic int vt1708_jack_detect_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct via_spec *spec = codec->spec;\n\n\tif (spec->codec_type != VT1708)\n\t\treturn 0;\n\tucontrol->value.integer.value[0] = spec->vt1708_jack_detect;\n\treturn 0;\n}\n\nstatic int vt1708_jack_detect_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct via_spec *spec = codec->spec;\n\tint val;\n\n\tif (spec->codec_type != VT1708)\n\t\treturn 0;\n\tval = !!ucontrol->value.integer.value[0];\n\tif (spec->vt1708_jack_detect == val)\n\t\treturn 0;\n\tspec->vt1708_jack_detect = val;\n\tvt1708_update_hp_work(codec);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new vt1708_jack_detect_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Jack Detect\",\n\t.count = 1,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = vt1708_jack_detect_get,\n\t.put = vt1708_jack_detect_put,\n};\n\nstatic const struct badness_table via_main_out_badness = {\n\t.no_primary_dac = 0x10000,\n\t.no_dac = 0x4000,\n\t.shared_primary = 0x10000,\n\t.shared_surr = 0x20,\n\t.shared_clfe = 0x20,\n\t.shared_surr_main = 0x20,\n};\nstatic const struct badness_table via_extra_out_badness = {\n\t.no_primary_dac = 0x4000,\n\t.no_dac = 0x4000,\n\t.shared_primary = 0x12,\n\t.shared_surr = 0x20,\n\t.shared_clfe = 0x20,\n\t.shared_surr_main = 0x10,\n};\n\nstatic int via_parse_auto_config(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tint err;\n\n\tspec->gen.main_out_badness = &via_main_out_badness;\n\tspec->gen.extra_out_badness = &via_extra_out_badness;\n\n\terr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = auto_parse_beep(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &via_pin_power_ctl_enum))\n\t\treturn -ENOMEM;\n\n\t \n\tcodec->power_save_node = 0;\n\tspec->gen.power_down_unused = 0;\n\treturn 0;\n}\n\nstatic int via_init(struct hda_codec *codec)\n{\n\t \n\t__analog_low_current_mode(codec, true);\n\n\tsnd_hda_gen_init(codec);\n\n\tvt1708_update_hp_work(codec);\n\n\treturn 0;\n}\n\nstatic int vt1708_build_controls(struct hda_codec *codec)\n{\n\t \n\tint err;\n\tint old_interval = codec->jackpoll_interval;\n\tcodec->jackpoll_interval = msecs_to_jiffies(100);\n\terr = snd_hda_gen_build_controls(codec);\n\tcodec->jackpoll_interval = old_interval;\n\treturn err;\n}\n\nstatic int vt1708_build_pcms(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tint i, err;\n\n\terr = snd_hda_gen_build_pcms(codec);\n\tif (err < 0 || codec->core.vendor_id != 0x11061708)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(spec->gen.pcm_rec); i++) {\n\t\tstruct hda_pcm *info = spec->gen.pcm_rec[i];\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tif (!info->stream[SNDRV_PCM_STREAM_PLAYBACK].substreams ||\n\t\t    info->pcm_type != HDA_PCM_TYPE_AUDIO)\n\t\t\tcontinue;\n\t\tinfo->stream[SNDRV_PCM_STREAM_PLAYBACK].formats =\n\t\t\tSNDRV_PCM_FMTBIT_S16_LE;\n\t}\n\n\treturn 0;\n}\n\nstatic int patch_vt1708(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tcodec->patch_ops.build_controls = vt1708_build_controls;\n\tcodec->patch_ops.build_pcms = vt1708_build_pcms;\n\tspec->gen.mixer_nid = 0x17;\n\n\t \n\tcodec->jackpoll_interval = msecs_to_jiffies(100);\n\tspec->vt1708_jack_detect = 1;\n\n\t \n\t \n\tspec->gen.suppress_auto_mic = 1;\n\t \n\tspec->gen.auto_mute_via_amp = 1;\n\n\t \n\tvt1708_set_pinconfig_connect(codec, VT1708_HP_PIN_NID);\n\tvt1708_set_pinconfig_connect(codec, VT1708_CD_PIN_NID);\n\n\terr = snd_hda_add_verbs(codec, vt1708_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &vt1708_jack_detect_ctl)) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tcodec->jackpoll_interval = 0;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\nstatic int patch_vt1709(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x18;\n\n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\nstatic int patch_vt1708S(struct hda_codec *codec);\nstatic int patch_vt1708B(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\tif (get_codec_type(codec) == VT1708BCE)\n\t\treturn patch_vt1708S(codec);\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x16;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \nstatic const struct hda_verb vt1708S_init_verbs[] = {\n\t \n\t{0x1, 0xf98, 0x1},\n\t \n\t{0x1, 0xf88, 0xc0},\n\t{ }\n};\n\nstatic void override_mic_boost(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t       int offset, int num_steps, int step_size)\n{\n\tsnd_hda_override_wcaps(codec, pin,\n\t\t\t       get_wcaps(codec, pin) | AC_WCAP_IN_AMP);\n\tsnd_hda_override_amp_caps(codec, pin, HDA_INPUT,\n\t\t\t\t  (offset << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t  (num_steps << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t  (step_size << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t  (0 << AC_AMPCAP_MUTE_SHIFT));\n}\n\nstatic int patch_vt1708S(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x16;\n\toverride_mic_boost(codec, 0x1a, 0, 3, 40);\n\toverride_mic_boost(codec, 0x1e, 0, 3, 40);\n\n\t \n\tif (get_codec_type(codec) == VT1708BCE)\n\t\tsnd_hda_codec_set_name(codec, \"VT1708BCE\");\n\t \n\tif (codec->core.vendor_id == 0x11064397)\n\t\tsnd_hda_codec_set_name(codec, \"VT1705\");\n\n\terr = snd_hda_add_verbs(codec, vt1708S_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_verb vt1702_init_verbs[] = {\n\t \n\t{0x1, 0xF88, 0x3},\n\t \n\t{0x1, 0xF82, 0x3F},\n\t{ }\n};\n\nstatic int patch_vt1702(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x1a;\n\n\t \n\tsnd_hda_override_amp_caps(codec, 0x1A, HDA_INPUT,\n\t\t\t\t  (0x17 << AC_AMPCAP_OFFSET_SHIFT) |\n\t\t\t\t  (0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\n\t\t\t\t  (0x5 << AC_AMPCAP_STEP_SIZE_SHIFT) |\n\t\t\t\t  (1 << AC_AMPCAP_MUTE_SHIFT));\n\n\terr = snd_hda_add_verbs(codec, vt1702_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_verb vt1718S_init_verbs[] = {\n\t \n\t{0x1, 0xfb2, 0x10},\n\t \n\t{0x1, 0xf88, 0x8},\n\n\t{ }\n};\n\n \nstatic int add_secret_dac_path(struct hda_codec *codec)\n{\n\tstruct via_spec *spec = codec->spec;\n\tint i, nums;\n\thda_nid_t conn[8];\n\thda_nid_t nid;\n\n\tif (!spec->gen.mixer_nid)\n\t\treturn 0;\n\tnums = snd_hda_get_connections(codec, spec->gen.mixer_nid, conn,\n\t\t\t\t       ARRAY_SIZE(conn) - 1);\n\tif (nums < 0)\n\t\treturn nums;\n\n\tfor (i = 0; i < nums; i++) {\n\t\tif (get_wcaps_type(get_wcaps(codec, conn[i])) == AC_WID_AUD_OUT)\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor_each_hda_codec_node(nid, codec) {\n\t\tunsigned int caps = get_wcaps(codec, nid);\n\t\tif (get_wcaps_type(caps) == AC_WID_AUD_OUT &&\n\t\t    !(caps & AC_WCAP_DIGITAL)) {\n\t\t\tconn[nums++] = nid;\n\t\t\treturn snd_hda_override_conn_list(codec,\n\t\t\t\t\t\t\t  spec->gen.mixer_nid,\n\t\t\t\t\t\t\t  nums, conn);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int patch_vt1718S(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x21;\n\toverride_mic_boost(codec, 0x2b, 0, 3, 40);\n\toverride_mic_boost(codec, 0x29, 0, 3, 40);\n\tadd_secret_dac_path(codec);\n\n\terr = snd_hda_add_verbs(codec, vt1718S_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic int vt1716s_dmic_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int vt1716s_dmic_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tint index = 0;\n\n\tindex = snd_hda_codec_read(codec, 0x26, 0,\n\t\t\t\t\t       AC_VERB_GET_CONNECT_SEL, 0);\n\tif (index != -1)\n\t\t*ucontrol->value.integer.value = index;\n\n\treturn 0;\n}\n\nstatic int vt1716s_dmic_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct via_spec *spec = codec->spec;\n\tint index = *ucontrol->value.integer.value;\n\n\tsnd_hda_codec_write(codec, 0x26, 0,\n\t\t\t\t\t       AC_VERB_SET_CONNECT_SEL, index);\n\tspec->dmic_enabled = index;\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new vt1716s_dmic_mixer_vol =\n\tHDA_CODEC_VOLUME(\"Digital Mic Capture Volume\", 0x22, 0x0, HDA_INPUT);\nstatic const struct snd_kcontrol_new vt1716s_dmic_mixer_sw = {\n\t .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t .name = \"Digital Mic Capture Switch\",\n\t .subdevice = HDA_SUBDEV_NID_FLAG | 0x26,\n\t .count = 1,\n\t .info = vt1716s_dmic_info,\n\t .get = vt1716s_dmic_get,\n\t .put = vt1716s_dmic_put,\n};\n\n\n \nstatic const struct snd_kcontrol_new vt1716S_mono_out_mixer =\n\tHDA_CODEC_MUTE(\"Mono Playback Switch\", 0x2a, 0x0, HDA_OUTPUT);\n\nstatic const struct hda_verb vt1716S_init_verbs[] = {\n\t \n\t{0x1, 0xf8a, 0x80},\n\t \n\t{0x1, 0xf88, 0xc0},\n\t \n\t{0x1, 0xf90, 0x08},\n\t{ }\n};\n\nstatic int patch_vt1716S(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x16;\n\toverride_mic_boost(codec, 0x1a, 0, 3, 40);\n\toverride_mic_boost(codec, 0x1e, 0, 3, 40);\n\n\terr = snd_hda_add_verbs(codec, vt1716S_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (!snd_hda_gen_add_kctl(&spec->gen, NULL, &vt1716s_dmic_mixer_vol) ||\n\t    !snd_hda_gen_add_kctl(&spec->gen, NULL, &vt1716s_dmic_mixer_sw) ||\n\t    !snd_hda_gen_add_kctl(&spec->gen, NULL, &vt1716S_mono_out_mixer)) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_verb vt2002P_init_verbs[] = {\n\t \n\t{0x1, 0xfe0, 0x4},\n\t{0x1, 0xfe9, 0x80},\n\t{0x1, 0xfe2, 0x22},\n\t \n\t{0x1, 0xfb9, 0x24},\n\t \n\t{0x1, 0xfb8, 0x88},\n\t{ }\n};\n\nstatic const struct hda_verb vt1802_init_verbs[] = {\n\t \n\t{0x1, 0xfb9, 0x24},\n\t \n\t{0x1, 0xfb8, 0x88},\n\t{ }\n};\n\n \nenum {\n\tVIA_FIXUP_INTMIC_BOOST,\n\tVIA_FIXUP_ASUS_G75,\n\tVIA_FIXUP_POWER_SAVE,\n};\n\nstatic void via_fixup_intmic_boost(struct hda_codec *codec,\n\t\t\t\t  const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\toverride_mic_boost(codec, 0x30, 0, 2, 40);\n}\n\nstatic void via_fixup_power_save(struct hda_codec *codec,\n\t\t\t\t const struct hda_fixup *fix, int action)\n{\n\tif (action == HDA_FIXUP_ACT_PRE_PROBE)\n\t\tcodec->power_save_node = 0;\n}\n\nstatic const struct hda_fixup via_fixups[] = {\n\t[VIA_FIXUP_INTMIC_BOOST] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = via_fixup_intmic_boost,\n\t},\n\t[VIA_FIXUP_ASUS_G75] = {\n\t\t.type = HDA_FIXUP_PINS,\n\t\t.v.pins = (const struct hda_pintbl[]) {\n\t\t\t \n\t\t\t{ 0x24, 0x991301f0 },\n\t\t\t{ 0x33, 0x991301f1 },  \n\t\t\t{ }\n\t\t}\n\t},\n\t[VIA_FIXUP_POWER_SAVE] = {\n\t\t.type = HDA_FIXUP_FUNC,\n\t\t.v.func = via_fixup_power_save,\n\t},\n};\n\nstatic const struct snd_pci_quirk vt2002p_fixups[] = {\n\tSND_PCI_QUIRK(0x1043, 0x13f7, \"Asus B23E\", VIA_FIXUP_POWER_SAVE),\n\tSND_PCI_QUIRK(0x1043, 0x1487, \"Asus G75\", VIA_FIXUP_ASUS_G75),\n\tSND_PCI_QUIRK(0x1043, 0x8532, \"Asus X202E\", VIA_FIXUP_INTMIC_BOOST),\n\tSND_PCI_QUIRK_VENDOR(0x1558, \"Clevo\", VIA_FIXUP_POWER_SAVE),\n\t{}\n};\n\n \nstatic void fix_vt1802_connections(struct hda_codec *codec)\n{\n\tstatic const hda_nid_t conn_24[] = { 0x14, 0x1c };\n\tstatic const hda_nid_t conn_33[] = { 0x1c };\n\n\tsnd_hda_override_conn_list(codec, 0x24, ARRAY_SIZE(conn_24), conn_24);\n\tsnd_hda_override_conn_list(codec, 0x33, ARRAY_SIZE(conn_33), conn_33);\n}\n\n \nstatic int patch_vt2002P(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x21;\n\toverride_mic_boost(codec, 0x2b, 0, 3, 40);\n\toverride_mic_boost(codec, 0x29, 0, 3, 40);\n\tif (spec->codec_type == VT1802)\n\t\tfix_vt1802_connections(codec);\n\tadd_secret_dac_path(codec);\n\n\tsnd_hda_pick_fixup(codec, NULL, vt2002p_fixups, via_fixups);\n\tsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\n\n\tif (spec->codec_type == VT1802)\n\t\terr = snd_hda_add_verbs(codec, vt1802_init_verbs);\n\telse\n\t\terr = snd_hda_add_verbs(codec, vt2002P_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_verb vt1812_init_verbs[] = {\n\t \n\t{0x1, 0xfb9, 0x24},\n\t \n\t{0x1, 0xfb8, 0xa8},\n\t{ }\n};\n\n \nstatic int patch_vt1812(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x21;\n\toverride_mic_boost(codec, 0x2b, 0, 3, 40);\n\toverride_mic_boost(codec, 0x29, 0, 3, 40);\n\tadd_secret_dac_path(codec);\n\n\terr = snd_hda_add_verbs(codec, vt1812_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \n\nstatic const struct hda_verb vt3476_init_verbs[] = {\n\t \n\t{0x1, 0xF7B, 0x30},\n\t \n\t{0x1, 0xFB9, 0x20},\n\t \n\t{0x1, 0xFB8, 0x10},\n\t{ }\n};\n\nstatic int patch_vt3476(struct hda_codec *codec)\n{\n\tstruct via_spec *spec;\n\tint err;\n\n\t \n\tspec = via_new_spec(codec);\n\tif (spec == NULL)\n\t\treturn -ENOMEM;\n\n\tspec->gen.mixer_nid = 0x3f;\n\tadd_secret_dac_path(codec);\n\n\terr = snd_hda_add_verbs(codec, vt3476_init_verbs);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\terr = via_parse_auto_config(codec);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tvia_free(codec);\n\treturn err;\n}\n\n \nstatic const struct hda_device_id snd_hda_id_via[] = {\n\tHDA_CODEC_ENTRY(0x11061708, \"VT1708\", patch_vt1708),\n\tHDA_CODEC_ENTRY(0x11061709, \"VT1708\", patch_vt1708),\n\tHDA_CODEC_ENTRY(0x1106170a, \"VT1708\", patch_vt1708),\n\tHDA_CODEC_ENTRY(0x1106170b, \"VT1708\", patch_vt1708),\n\tHDA_CODEC_ENTRY(0x1106e710, \"VT1709 10-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e711, \"VT1709 10-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e712, \"VT1709 10-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e713, \"VT1709 10-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e714, \"VT1709 6-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e715, \"VT1709 6-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e716, \"VT1709 6-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e717, \"VT1709 6-Ch\", patch_vt1709),\n\tHDA_CODEC_ENTRY(0x1106e720, \"VT1708B 8-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e721, \"VT1708B 8-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e722, \"VT1708B 8-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e723, \"VT1708B 8-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e724, \"VT1708B 4-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e725, \"VT1708B 4-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e726, \"VT1708B 4-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x1106e727, \"VT1708B 4-Ch\", patch_vt1708B),\n\tHDA_CODEC_ENTRY(0x11060397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11061397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11062397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11063397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11064397, \"VT1705\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11065397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11066397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11067397, \"VT1708S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11060398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11061398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11062398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11063398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11064398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11065398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11066398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11067398, \"VT1702\", patch_vt1702),\n\tHDA_CODEC_ENTRY(0x11060428, \"VT1718S\", patch_vt1718S),\n\tHDA_CODEC_ENTRY(0x11064428, \"VT1718S\", patch_vt1718S),\n\tHDA_CODEC_ENTRY(0x11060441, \"VT2020\", patch_vt1718S),\n\tHDA_CODEC_ENTRY(0x11064441, \"VT1828S\", patch_vt1718S),\n\tHDA_CODEC_ENTRY(0x11060433, \"VT1716S\", patch_vt1716S),\n\tHDA_CODEC_ENTRY(0x1106a721, \"VT1716S\", patch_vt1716S),\n\tHDA_CODEC_ENTRY(0x11060438, \"VT2002P\", patch_vt2002P),\n\tHDA_CODEC_ENTRY(0x11064438, \"VT2002P\", patch_vt2002P),\n\tHDA_CODEC_ENTRY(0x11060448, \"VT1812\", patch_vt1812),\n\tHDA_CODEC_ENTRY(0x11060440, \"VT1818S\", patch_vt1708S),\n\tHDA_CODEC_ENTRY(0x11060446, \"VT1802\", patch_vt2002P),\n\tHDA_CODEC_ENTRY(0x11068446, \"VT1802\", patch_vt2002P),\n\tHDA_CODEC_ENTRY(0x11064760, \"VT1705CF\", patch_vt3476),\n\tHDA_CODEC_ENTRY(0x11064761, \"VT1708SCE\", patch_vt3476),\n\tHDA_CODEC_ENTRY(0x11064762, \"VT1808\", patch_vt3476),\n\t{}  \n};\nMODULE_DEVICE_TABLE(hdaudio, snd_hda_id_via);\n\nstatic struct hda_codec_driver via_driver = {\n\t.id = snd_hda_id_via,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VIA HD-audio codec\");\n\nmodule_hda_codec_driver(via_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}