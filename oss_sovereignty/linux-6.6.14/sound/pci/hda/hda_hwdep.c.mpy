{
  "module_name": "hda_hwdep.c",
  "hash_id": "033b75ae8281d3f950d07dc063135c334f5c8f78a227d390718c00f3250f495b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_hwdep.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/nospec.h>\n#include <sound/core.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n#include <sound/hda_hwdep.h>\n#include <sound/minors.h>\n\n \nstatic int verb_write_ioctl(struct hda_codec *codec,\n\t\t\t    struct hda_verb_ioctl __user *arg)\n{\n\tu32 verb, res;\n\n\tif (get_user(verb, &arg->verb))\n\t\treturn -EFAULT;\n\tres = snd_hda_codec_read(codec, verb >> 24, 0,\n\t\t\t\t (verb >> 8) & 0xffff, verb & 0xff);\n\tif (put_user(res, &arg->res))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int get_wcap_ioctl(struct hda_codec *codec,\n\t\t\t  struct hda_verb_ioctl __user *arg)\n{\n\tu32 verb, res;\n\t\n\tif (get_user(verb, &arg->verb))\n\t\treturn -EFAULT;\n\t \n\tverb >>= 24;\n\tif (verb < codec->core.start_nid ||\n\t    verb >= codec->core.start_nid + codec->core.num_nodes) {\n\t\tres = 0;\n\t} else {\n\t\tverb -= codec->core.start_nid;\n\t\tverb = array_index_nospec(verb, codec->core.num_nodes);\n\t\tres = codec->wcaps[verb];\n\t}\n\tif (put_user(res, &arg->res))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\n \nstatic int hda_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct hda_codec *codec = hw->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase HDA_IOCTL_PVERSION:\n\t\treturn put_user(HDA_HWDEP_VERSION, (int __user *)argp);\n\tcase HDA_IOCTL_VERB_WRITE:\n\t\treturn verb_write_ioctl(codec, argp);\n\tcase HDA_IOCTL_GET_WCAP:\n\t\treturn get_wcap_ioctl(codec, argp);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,\n\t\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\treturn hda_hwdep_ioctl(hw, file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)\n{\n#ifndef CONFIG_SND_DEBUG_VERBOSE\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n#endif\n\treturn 0;\n}\n\nint snd_hda_create_hwdep(struct hda_codec *codec)\n{\n\tchar hwname[16];\n\tstruct snd_hwdep *hwdep;\n\tint err;\n\n\tsprintf(hwname, \"HDA Codec %d\", codec->addr);\n\terr = snd_hwdep_new(codec->card, hwname, codec->addr, &hwdep);\n\tif (err < 0)\n\t\treturn err;\n\tcodec->hwdep = hwdep;\n\tsprintf(hwdep->name, \"HDA Codec %d\", codec->addr);\n\thwdep->iface = SNDRV_HWDEP_IFACE_HDA;\n\thwdep->private_data = codec;\n\thwdep->exclusive = 1;\n\n\thwdep->ops.open = hda_hwdep_open;\n\thwdep->ops.ioctl = hda_hwdep_ioctl;\n#ifdef CONFIG_COMPAT\n\thwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;\n#endif\n\n\t \n\thwdep->dev->groups = snd_hda_dev_attr_groups;\n\tdev_set_drvdata(hwdep->dev, codec);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}