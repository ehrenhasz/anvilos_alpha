{
  "module_name": "hda_proc.c",
  "hash_id": "480d1f5a2fb08c9d3c6044938943d4adae2338b23f5ab0ce4a9a2e758fd33ffc",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_proc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <linux/module.h>\n#include <sound/hda_codec.h>\n#include \"hda_local.h\"\n\nstatic int dump_coef = -1;\nmodule_param(dump_coef, int, 0644);\nMODULE_PARM_DESC(dump_coef, \"Dump processing coefficients in codec proc file (-1=auto, 0=disable, 1=enable)\");\n\n \n#define param_read(codec, nid, parm) \\\n\tsnd_hdac_read_parm_uncached(&(codec)->core, nid, parm)\n\nstatic const char *get_wid_type_name(unsigned int wid_value)\n{\n\tstatic const char * const names[16] = {\n\t\t[AC_WID_AUD_OUT] = \"Audio Output\",\n\t\t[AC_WID_AUD_IN] = \"Audio Input\",\n\t\t[AC_WID_AUD_MIX] = \"Audio Mixer\",\n\t\t[AC_WID_AUD_SEL] = \"Audio Selector\",\n\t\t[AC_WID_PIN] = \"Pin Complex\",\n\t\t[AC_WID_POWER] = \"Power Widget\",\n\t\t[AC_WID_VOL_KNB] = \"Volume Knob Widget\",\n\t\t[AC_WID_BEEP] = \"Beep Generator Widget\",\n\t\t[AC_WID_VENDOR] = \"Vendor Defined Widget\",\n\t};\n\tif (wid_value == -1)\n\t\treturn \"UNKNOWN Widget\";\n\twid_value &= 0xf;\n\tif (names[wid_value])\n\t\treturn names[wid_value];\n\telse\n\t\treturn \"UNKNOWN Widget\";\n}\n\nstatic void print_nid_array(struct snd_info_buffer *buffer,\n\t\t\t    struct hda_codec *codec, hda_nid_t nid,\n\t\t\t    struct snd_array *array)\n{\n\tint i;\n\tstruct hda_nid_item *items = array->list, *item;\n\tstruct snd_kcontrol *kctl;\n\tfor (i = 0; i < array->used; i++) {\n\t\titem = &items[i];\n\t\tif (item->nid == nid) {\n\t\t\tkctl = item->kctl;\n\t\t\tsnd_iprintf(buffer,\n\t\t\t  \"  Control: name=\\\"%s\\\", index=%i, device=%i\\n\",\n\t\t\t  kctl->id.name, kctl->id.index + item->index,\n\t\t\t  kctl->id.device);\n\t\t\tif (item->flags & HDA_NID_ITEM_AMP)\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t  \"    ControlAmp: chs=%lu, dir=%s, \"\n\t\t\t\t  \"idx=%lu, ofs=%lu\\n\",\n\t\t\t\t  get_amp_channels(kctl),\n\t\t\t\t  get_amp_direction(kctl) ? \"Out\" : \"In\",\n\t\t\t\t  get_amp_index(kctl),\n\t\t\t\t  get_amp_offset(kctl));\n\t\t}\n\t}\n}\n\nstatic void print_nid_pcms(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid)\n{\n\tint type;\n\tstruct hda_pcm *cpcm;\n\n\tlist_for_each_entry(cpcm, &codec->pcm_list_head, list) {\n\t\tfor (type = 0; type < 2; type++) {\n\t\t\tif (cpcm->stream[type].nid != nid || cpcm->pcm == NULL)\n\t\t\t\tcontinue;\n\t\t\tsnd_iprintf(buffer, \"  Device: name=\\\"%s\\\", \"\n\t\t\t\t    \"type=\\\"%s\\\", device=%i\\n\",\n\t\t\t\t    cpcm->name,\n\t\t\t\t    snd_hda_pcm_type_name[cpcm->pcm_type],\n\t\t\t\t    cpcm->pcm->device);\n\t\t}\n\t}\n}\n\nstatic void print_amp_caps(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid, int dir)\n{\n\tunsigned int caps;\n\tcaps = param_read(codec, nid, dir == HDA_OUTPUT ?\n\t\t\t  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\n\tif (caps == -1 || caps == 0) {\n\t\tsnd_iprintf(buffer, \"N/A\\n\");\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, \"ofs=0x%02x, nsteps=0x%02x, stepsize=0x%02x, \"\n\t\t    \"mute=%x\\n\",\n\t\t    caps & AC_AMPCAP_OFFSET,\n\t\t    (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT,\n\t\t    (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT,\n\t\t    (caps & AC_AMPCAP_MUTE) >> AC_AMPCAP_MUTE_SHIFT);\n}\n\n \nstatic bool is_stereo_amps(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int dir, unsigned int wcaps, int indices)\n{\n\thda_nid_t conn;\n\n\tif (wcaps & AC_WCAP_STEREO)\n\t\treturn true;\n\t \n\tif (indices != 1 || dir != HDA_INPUT ||\n\t    get_wcaps_type(wcaps) != AC_WID_AUD_MIX)\n\t\treturn false;\n\n\tif (snd_hda_get_raw_connections(codec, nid, &conn, 1) < 0)\n\t\treturn false;\n\t \n\twcaps = snd_hda_param_read(codec, conn, AC_PAR_AUDIO_WIDGET_CAP);\n\treturn !!(wcaps & AC_WCAP_STEREO);\n}\n\nstatic void print_amp_vals(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int dir, unsigned int wcaps, int indices)\n{\n\tunsigned int val;\n\tbool stereo;\n\tint i;\n\n\tstereo = is_stereo_amps(codec, nid, dir, wcaps, indices);\n\n\tdir = dir == HDA_OUTPUT ? AC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;\n\tfor (i = 0; i < indices; i++) {\n\t\tsnd_iprintf(buffer, \" [\");\n\t\tval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t AC_VERB_GET_AMP_GAIN_MUTE,\n\t\t\t\t\t AC_AMP_GET_LEFT | dir | i);\n\t\tsnd_iprintf(buffer, \"0x%02x\", val);\n\t\tif (stereo) {\n\t\t\tval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t\t AC_VERB_GET_AMP_GAIN_MUTE,\n\t\t\t\t\t\t AC_AMP_GET_RIGHT | dir | i);\n\t\t\tsnd_iprintf(buffer, \" 0x%02x\", val);\n\t\t}\n\t\tsnd_iprintf(buffer, \"]\");\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void print_pcm_rates(struct snd_info_buffer *buffer, unsigned int pcm)\n{\n\tstatic const unsigned int rates[] = {\n\t\t8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200,\n\t\t96000, 176400, 192000, 384000\n\t};\n\tint i;\n\n\tpcm &= AC_SUPPCM_RATES;\n\tsnd_iprintf(buffer, \"    rates [0x%x]:\", pcm);\n\tfor (i = 0; i < ARRAY_SIZE(rates); i++)\n\t\tif (pcm & (1 << i))\n\t\t\tsnd_iprintf(buffer,  \" %d\", rates[i]);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void print_pcm_bits(struct snd_info_buffer *buffer, unsigned int pcm)\n{\n\tchar buf[SND_PRINT_BITS_ADVISED_BUFSIZE];\n\n\tsnd_iprintf(buffer, \"    bits [0x%x]:\", (pcm >> 16) & 0xff);\n\tsnd_print_pcm_bits(pcm, buf, sizeof(buf));\n\tsnd_iprintf(buffer, \"%s\\n\", buf);\n}\n\nstatic void print_pcm_formats(struct snd_info_buffer *buffer,\n\t\t\t      unsigned int streams)\n{\n\tsnd_iprintf(buffer, \"    formats [0x%x]:\", streams & 0xf);\n\tif (streams & AC_SUPFMT_PCM)\n\t\tsnd_iprintf(buffer, \" PCM\");\n\tif (streams & AC_SUPFMT_FLOAT32)\n\t\tsnd_iprintf(buffer, \" FLOAT\");\n\tif (streams & AC_SUPFMT_AC3)\n\t\tsnd_iprintf(buffer, \" AC3\");\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void print_pcm_caps(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int pcm = param_read(codec, nid, AC_PAR_PCM);\n\tunsigned int stream = param_read(codec, nid, AC_PAR_STREAM);\n\tif (pcm == -1 || stream == -1) {\n\t\tsnd_iprintf(buffer, \"N/A\\n\");\n\t\treturn;\n\t}\n\tprint_pcm_rates(buffer, pcm);\n\tprint_pcm_bits(buffer, pcm);\n\tprint_pcm_formats(buffer, stream);\n}\n\nstatic const char *get_jack_connection(u32 cfg)\n{\n\tstatic const char * const names[16] = {\n\t\t\"Unknown\", \"1/8\", \"1/4\", \"ATAPI\",\n\t\t\"RCA\", \"Optical\",\"Digital\", \"Analog\",\n\t\t\"DIN\", \"XLR\", \"RJ11\", \"Comb\",\n\t\tNULL, NULL, NULL, \"Other\"\n\t};\n\tcfg = (cfg & AC_DEFCFG_CONN_TYPE) >> AC_DEFCFG_CONN_TYPE_SHIFT;\n\tif (names[cfg])\n\t\treturn names[cfg];\n\telse\n\t\treturn \"UNKNOWN\";\n}\n\nstatic const char *get_jack_color(u32 cfg)\n{\n\tstatic const char * const names[16] = {\n\t\t\"Unknown\", \"Black\", \"Grey\", \"Blue\",\n\t\t\"Green\", \"Red\", \"Orange\", \"Yellow\",\n\t\t\"Purple\", \"Pink\", NULL, NULL,\n\t\tNULL, NULL, \"White\", \"Other\",\n\t};\n\tcfg = (cfg & AC_DEFCFG_COLOR) >> AC_DEFCFG_COLOR_SHIFT;\n\tif (names[cfg])\n\t\treturn names[cfg];\n\telse\n\t\treturn \"UNKNOWN\";\n}\n\n \nstatic const char *get_jack_location(u32 cfg)\n{\n\tstatic const char * const bases[7] = {\n\t\t\"N/A\", \"Rear\", \"Front\", \"Left\", \"Right\", \"Top\", \"Bottom\",\n\t};\n\tstatic const unsigned char specials_idx[] = {\n\t\t0x07, 0x08,\n\t\t0x17, 0x18, 0x19,\n\t\t0x37, 0x38\n\t};\n\tstatic const char * const specials[] = {\n\t\t\"Rear Panel\", \"Drive Bar\",\n\t\t\"Riser\", \"HDMI\", \"ATAPI\",\n\t\t\"Mobile-In\", \"Mobile-Out\"\n\t};\n\tint i;\n\n\tcfg = (cfg & AC_DEFCFG_LOCATION) >> AC_DEFCFG_LOCATION_SHIFT;\n\tif ((cfg & 0x0f) < 7)\n\t\treturn bases[cfg & 0x0f];\n\tfor (i = 0; i < ARRAY_SIZE(specials_idx); i++) {\n\t\tif (cfg == specials_idx[i])\n\t\t\treturn specials[i];\n\t}\n\treturn \"UNKNOWN\";\n}\n\n \nstatic const char *get_jack_connectivity(u32 cfg)\n{\n\tstatic const char * const jack_locations[4] = {\n\t\t\"Ext\", \"Int\", \"Sep\", \"Oth\"\n\t};\n\n\treturn jack_locations[(cfg >> (AC_DEFCFG_LOCATION_SHIFT + 4)) & 3];\n}\n\n \nstatic const char *get_jack_type(u32 cfg)\n{\n\tstatic const char * const jack_types[16] = {\n\t\t\"Line Out\", \"Speaker\", \"HP Out\", \"CD\",\n\t\t\"SPDIF Out\", \"Digital Out\", \"Modem Line\", \"Modem Hand\",\n\t\t\"Line In\", \"Aux\", \"Mic\", \"Telephony\",\n\t\t\"SPDIF In\", \"Digital In\", \"Reserved\", \"Other\"\n\t};\n\n\treturn jack_types[(cfg & AC_DEFCFG_DEVICE)\n\t\t\t\t>> AC_DEFCFG_DEVICE_SHIFT];\n}\n\nstatic void print_pin_caps(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int *supports_vref)\n{\n\tstatic const char * const jack_conns[4] = {\n\t\t\"Jack\", \"N/A\", \"Fixed\", \"Both\"\n\t};\n\tunsigned int caps, val;\n\n\tcaps = param_read(codec, nid, AC_PAR_PIN_CAP);\n\tsnd_iprintf(buffer, \"  Pincap 0x%08x:\", caps);\n\tif (caps & AC_PINCAP_IN)\n\t\tsnd_iprintf(buffer, \" IN\");\n\tif (caps & AC_PINCAP_OUT)\n\t\tsnd_iprintf(buffer, \" OUT\");\n\tif (caps & AC_PINCAP_HP_DRV)\n\t\tsnd_iprintf(buffer, \" HP\");\n\tif (caps & AC_PINCAP_EAPD)\n\t\tsnd_iprintf(buffer, \" EAPD\");\n\tif (caps & AC_PINCAP_PRES_DETECT)\n\t\tsnd_iprintf(buffer, \" Detect\");\n\tif (caps & AC_PINCAP_BALANCE)\n\t\tsnd_iprintf(buffer, \" Balanced\");\n\tif (caps & AC_PINCAP_HDMI) {\n\t\t \n\t\tif ((codec->core.vendor_id >> 16) == 0x10ec)\n\t\t\tsnd_iprintf(buffer, \" R/L\");\n\t\telse {\n\t\t\tif (caps & AC_PINCAP_HBR)\n\t\t\t\tsnd_iprintf(buffer, \" HBR\");\n\t\t\tsnd_iprintf(buffer, \" HDMI\");\n\t\t}\n\t}\n\tif (caps & AC_PINCAP_DP)\n\t\tsnd_iprintf(buffer, \" DP\");\n\tif (caps & AC_PINCAP_TRIG_REQ)\n\t\tsnd_iprintf(buffer, \" Trigger\");\n\tif (caps & AC_PINCAP_IMP_SENSE)\n\t\tsnd_iprintf(buffer, \" ImpSense\");\n\tsnd_iprintf(buffer, \"\\n\");\n\tif (caps & AC_PINCAP_VREF) {\n\t\tunsigned int vref =\n\t\t\t(caps & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\n\t\tsnd_iprintf(buffer, \"    Vref caps:\");\n\t\tif (vref & AC_PINCAP_VREF_HIZ)\n\t\t\tsnd_iprintf(buffer, \" HIZ\");\n\t\tif (vref & AC_PINCAP_VREF_50)\n\t\t\tsnd_iprintf(buffer, \" 50\");\n\t\tif (vref & AC_PINCAP_VREF_GRD)\n\t\t\tsnd_iprintf(buffer, \" GRD\");\n\t\tif (vref & AC_PINCAP_VREF_80)\n\t\t\tsnd_iprintf(buffer, \" 80\");\n\t\tif (vref & AC_PINCAP_VREF_100)\n\t\t\tsnd_iprintf(buffer, \" 100\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\t*supports_vref = 1;\n\t} else\n\t\t*supports_vref = 0;\n\tif (caps & AC_PINCAP_EAPD) {\n\t\tval = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t AC_VERB_GET_EAPD_BTLENABLE, 0);\n\t\tsnd_iprintf(buffer, \"  EAPD 0x%x:\", val);\n\t\tif (val & AC_EAPDBTL_BALANCED)\n\t\t\tsnd_iprintf(buffer, \" BALANCED\");\n\t\tif (val & AC_EAPDBTL_EAPD)\n\t\t\tsnd_iprintf(buffer, \" EAPD\");\n\t\tif (val & AC_EAPDBTL_LR_SWAP)\n\t\t\tsnd_iprintf(buffer, \" R/L\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\tcaps = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONFIG_DEFAULT, 0);\n\tsnd_iprintf(buffer, \"  Pin Default 0x%08x: [%s] %s at %s %s\\n\", caps,\n\t\t    jack_conns[(caps & AC_DEFCFG_PORT_CONN) >> AC_DEFCFG_PORT_CONN_SHIFT],\n\t\t    get_jack_type(caps),\n\t\t    get_jack_connectivity(caps),\n\t\t    get_jack_location(caps));\n\tsnd_iprintf(buffer, \"    Conn = %s, Color = %s\\n\",\n\t\t    get_jack_connection(caps),\n\t\t    get_jack_color(caps));\n\t \n\tsnd_iprintf(buffer, \"    DefAssociation = 0x%x, Sequence = 0x%x\\n\",\n\t\t    (caps & AC_DEFCFG_DEF_ASSOC) >> AC_DEFCFG_ASSOC_SHIFT,\n\t\t    caps & AC_DEFCFG_SEQUENCE);\n\tif (((caps & AC_DEFCFG_MISC) >> AC_DEFCFG_MISC_SHIFT) &\n\t    AC_DEFCFG_MISC_NO_PRESENCE) {\n\t\t \n\t\tsnd_iprintf(buffer, \"    Misc = NO_PRESENCE\\n\");\n\t}\n}\n\nstatic void print_pin_ctls(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int supports_vref)\n{\n\tunsigned int pinctls;\n\n\tpinctls = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t     AC_VERB_GET_PIN_WIDGET_CONTROL, 0);\n\tsnd_iprintf(buffer, \"  Pin-ctls: 0x%02x:\", pinctls);\n\tif (pinctls & AC_PINCTL_IN_EN)\n\t\tsnd_iprintf(buffer, \" IN\");\n\tif (pinctls & AC_PINCTL_OUT_EN)\n\t\tsnd_iprintf(buffer, \" OUT\");\n\tif (pinctls & AC_PINCTL_HP_EN)\n\t\tsnd_iprintf(buffer, \" HP\");\n\tif (supports_vref) {\n\t\tint vref = pinctls & AC_PINCTL_VREFEN;\n\t\tswitch (vref) {\n\t\tcase AC_PINCTL_VREF_HIZ:\n\t\t\tsnd_iprintf(buffer, \" VREF_HIZ\");\n\t\t\tbreak;\n\t\tcase AC_PINCTL_VREF_50:\n\t\t\tsnd_iprintf(buffer, \" VREF_50\");\n\t\t\tbreak;\n\t\tcase AC_PINCTL_VREF_GRD:\n\t\t\tsnd_iprintf(buffer, \" VREF_GRD\");\n\t\t\tbreak;\n\t\tcase AC_PINCTL_VREF_80:\n\t\t\tsnd_iprintf(buffer, \" VREF_80\");\n\t\t\tbreak;\n\t\tcase AC_PINCTL_VREF_100:\n\t\t\tsnd_iprintf(buffer, \" VREF_100\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void print_vol_knob(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int cap = param_read(codec, nid, AC_PAR_VOL_KNB_CAP);\n\tsnd_iprintf(buffer, \"  Volume-Knob: delta=%d, steps=%d, \",\n\t\t    (cap >> 7) & 1, cap & 0x7f);\n\tcap = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t AC_VERB_GET_VOLUME_KNOB_CONTROL, 0);\n\tsnd_iprintf(buffer, \"direct=%d, val=%d\\n\",\n\t\t    (cap >> 7) & 1, cap & 0x7f);\n}\n\nstatic void print_audio_io(struct snd_info_buffer *buffer,\n\t\t\t   struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   unsigned int wid_type)\n{\n\tint conv = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\n\tsnd_iprintf(buffer,\n\t\t    \"  Converter: stream=%d, channel=%d\\n\",\n\t\t    (conv & AC_CONV_STREAM) >> AC_CONV_STREAM_SHIFT,\n\t\t    conv & AC_CONV_CHANNEL);\n\n\tif (wid_type == AC_WID_AUD_IN && (conv & AC_CONV_CHANNEL) == 0) {\n\t\tint sdi = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t     AC_VERB_GET_SDI_SELECT, 0);\n\t\tsnd_iprintf(buffer, \"  SDI-Select: %d\\n\",\n\t\t\t    sdi & AC_SDI_SELECT);\n\t}\n}\n\nstatic void print_digital_conv(struct snd_info_buffer *buffer,\n\t\t\t       struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int digi1 = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t\tAC_VERB_GET_DIGI_CONVERT_1, 0);\n\tunsigned char digi2 = digi1 >> 8;\n\tunsigned char digi3 = digi1 >> 16;\n\n\tsnd_iprintf(buffer, \"  Digital:\");\n\tif (digi1 & AC_DIG1_ENABLE)\n\t\tsnd_iprintf(buffer, \" Enabled\");\n\tif (digi1 & AC_DIG1_V)\n\t\tsnd_iprintf(buffer, \" Validity\");\n\tif (digi1 & AC_DIG1_VCFG)\n\t\tsnd_iprintf(buffer, \" ValidityCfg\");\n\tif (digi1 & AC_DIG1_EMPHASIS)\n\t\tsnd_iprintf(buffer, \" Preemphasis\");\n\tif (digi1 & AC_DIG1_COPYRIGHT)\n\t\tsnd_iprintf(buffer, \" Non-Copyright\");\n\tif (digi1 & AC_DIG1_NONAUDIO)\n\t\tsnd_iprintf(buffer, \" Non-Audio\");\n\tif (digi1 & AC_DIG1_PROFESSIONAL)\n\t\tsnd_iprintf(buffer, \" Pro\");\n\tif (digi1 & AC_DIG1_LEVEL)\n\t\tsnd_iprintf(buffer, \" GenLevel\");\n\tif (digi3 & AC_DIG3_KAE)\n\t\tsnd_iprintf(buffer, \" KAE\");\n\tsnd_iprintf(buffer, \"\\n\");\n\tsnd_iprintf(buffer, \"  Digital category: 0x%x\\n\",\n\t\t    digi2 & AC_DIG2_CC);\n\tsnd_iprintf(buffer, \"  IEC Coding Type: 0x%x\\n\",\n\t\t\tdigi3 & AC_DIG3_ICT);\n}\n\nstatic const char *get_pwr_state(u32 state)\n{\n\tstatic const char * const buf[] = {\n\t\t\"D0\", \"D1\", \"D2\", \"D3\", \"D3cold\"\n\t};\n\tif (state < ARRAY_SIZE(buf))\n\t\treturn buf[state];\n\treturn \"UNKNOWN\";\n}\n\nstatic void print_power_state(struct snd_info_buffer *buffer,\n\t\t\t      struct hda_codec *codec, hda_nid_t nid)\n{\n\tstatic const char * const names[] = {\n\t\t[ilog2(AC_PWRST_D0SUP)]\t\t= \"D0\",\n\t\t[ilog2(AC_PWRST_D1SUP)]\t\t= \"D1\",\n\t\t[ilog2(AC_PWRST_D2SUP)]\t\t= \"D2\",\n\t\t[ilog2(AC_PWRST_D3SUP)]\t\t= \"D3\",\n\t\t[ilog2(AC_PWRST_D3COLDSUP)]\t= \"D3cold\",\n\t\t[ilog2(AC_PWRST_S3D3COLDSUP)]\t= \"S3D3cold\",\n\t\t[ilog2(AC_PWRST_CLKSTOP)]\t= \"CLKSTOP\",\n\t\t[ilog2(AC_PWRST_EPSS)]\t\t= \"EPSS\",\n\t};\n\n\tint sup = param_read(codec, nid, AC_PAR_POWER_STATE);\n\tint pwr = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t     AC_VERB_GET_POWER_STATE, 0);\n\tif (sup != -1) {\n\t\tint i;\n\n\t\tsnd_iprintf(buffer, \"  Power states: \");\n\t\tfor (i = 0; i < ARRAY_SIZE(names); i++) {\n\t\t\tif (sup & (1U << i))\n\t\t\t\tsnd_iprintf(buffer, \" %s\", names[i]);\n\t\t}\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n\tsnd_iprintf(buffer, \"  Power: setting=%s, actual=%s\",\n\t\t    get_pwr_state(pwr & AC_PWRST_SETTING),\n\t\t    get_pwr_state((pwr & AC_PWRST_ACTUAL) >>\n\t\t\t\t  AC_PWRST_ACTUAL_SHIFT));\n\tif (pwr & AC_PWRST_ERROR)\n\t\tsnd_iprintf(buffer, \", Error\");\n\tif (pwr & AC_PWRST_CLK_STOP_OK)\n\t\tsnd_iprintf(buffer, \", Clock-stop-OK\");\n\tif (pwr & AC_PWRST_SETTING_RESET)\n\t\tsnd_iprintf(buffer, \", Setting-reset\");\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void print_unsol_cap(struct snd_info_buffer *buffer,\n\t\t\t      struct hda_codec *codec, hda_nid_t nid)\n{\n\tint unsol = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t       AC_VERB_GET_UNSOLICITED_RESPONSE, 0);\n\tsnd_iprintf(buffer,\n\t\t    \"  Unsolicited: tag=%02x, enabled=%d\\n\",\n\t\t    unsol & AC_UNSOL_TAG,\n\t\t    (unsol & AC_UNSOL_ENABLED) ? 1 : 0);\n}\n\nstatic inline bool can_dump_coef(struct hda_codec *codec)\n{\n\tswitch (dump_coef) {\n\tcase 0: return false;\n\tcase 1: return true;\n\tdefault: return codec->dump_coef;\n\t}\n}\n\nstatic void print_proc_caps(struct snd_info_buffer *buffer,\n\t\t\t    struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int i, ncoeff, oldindex;\n\tunsigned int proc_caps = param_read(codec, nid, AC_PAR_PROC_CAP);\n\tncoeff = (proc_caps & AC_PCAP_NUM_COEF) >> AC_PCAP_NUM_COEF_SHIFT;\n\tsnd_iprintf(buffer, \"  Processing caps: benign=%d, ncoeff=%d\\n\",\n\t\t    proc_caps & AC_PCAP_BENIGN, ncoeff);\n\n\tif (!can_dump_coef(codec))\n\t\treturn;\n\n\t \n\toldindex = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_COEF_INDEX, 0);\n\tfor (i = 0; i < ncoeff; i++) {\n\t\tunsigned int val;\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_COEF_INDEX, i);\n\t\tval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_PROC_COEF,\n\t\t\t\t\t 0);\n\t\tsnd_iprintf(buffer, \"    Coeff 0x%02x: 0x%04x\\n\", i, val);\n\t}\n\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_COEF_INDEX, oldindex);\n}\n\nstatic void print_conn_list(struct snd_info_buffer *buffer,\n\t\t\t    struct hda_codec *codec, hda_nid_t nid,\n\t\t\t    unsigned int wid_type, hda_nid_t *conn,\n\t\t\t    int conn_len)\n{\n\tint c, curr = -1;\n\tconst hda_nid_t *list;\n\tint cache_len;\n\n\tif (conn_len > 1 &&\n\t    wid_type != AC_WID_AUD_MIX &&\n\t    wid_type != AC_WID_VOL_KNB &&\n\t    wid_type != AC_WID_POWER)\n\t\tcurr = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t\t  AC_VERB_GET_CONNECT_SEL, 0);\n\tsnd_iprintf(buffer, \"  Connection: %d\\n\", conn_len);\n\tif (conn_len > 0) {\n\t\tsnd_iprintf(buffer, \"    \");\n\t\tfor (c = 0; c < conn_len; c++) {\n\t\t\tsnd_iprintf(buffer, \" 0x%02x\", conn[c]);\n\t\t\tif (c == curr)\n\t\t\t\tsnd_iprintf(buffer, \"*\");\n\t\t}\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n\t \n\tcache_len = snd_hda_get_conn_list(codec, nid, &list);\n\tif (cache_len >= 0 && (cache_len != conn_len ||\n\t\t\t      memcmp(list, conn, conn_len) != 0)) {\n\t\tsnd_iprintf(buffer, \"  In-driver Connection: %d\\n\", cache_len);\n\t\tif (cache_len > 0) {\n\t\t\tsnd_iprintf(buffer, \"    \");\n\t\t\tfor (c = 0; c < cache_len; c++)\n\t\t\t\tsnd_iprintf(buffer, \" 0x%02x\", list[c]);\n\t\t\tsnd_iprintf(buffer, \"\\n\");\n\t\t}\n\t}\n}\n\nstatic void print_gpio(struct snd_info_buffer *buffer,\n\t\t       struct hda_codec *codec, hda_nid_t nid)\n{\n\tunsigned int gpio =\n\t\tparam_read(codec, codec->core.afg, AC_PAR_GPIO_CAP);\n\tunsigned int enable, direction, wake, unsol, sticky, data;\n\tint i, max;\n\tsnd_iprintf(buffer, \"GPIO: io=%d, o=%d, i=%d, \"\n\t\t    \"unsolicited=%d, wake=%d\\n\",\n\t\t    gpio & AC_GPIO_IO_COUNT,\n\t\t    (gpio & AC_GPIO_O_COUNT) >> AC_GPIO_O_COUNT_SHIFT,\n\t\t    (gpio & AC_GPIO_I_COUNT) >> AC_GPIO_I_COUNT_SHIFT,\n\t\t    (gpio & AC_GPIO_UNSOLICITED) ? 1 : 0,\n\t\t    (gpio & AC_GPIO_WAKE) ? 1 : 0);\n\tmax = gpio & AC_GPIO_IO_COUNT;\n\tif (!max || max > 8)\n\t\treturn;\n\tenable = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t    AC_VERB_GET_GPIO_MASK, 0);\n\tdirection = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t       AC_VERB_GET_GPIO_DIRECTION, 0);\n\twake = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t  AC_VERB_GET_GPIO_WAKE_MASK, 0);\n\tunsol  = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t    AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK, 0);\n\tsticky = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t    AC_VERB_GET_GPIO_STICKY_MASK, 0);\n\tdata = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\t  AC_VERB_GET_GPIO_DATA, 0);\n\tfor (i = 0; i < max; ++i)\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"  IO[%d]: enable=%d, dir=%d, wake=%d, \"\n\t\t\t    \"sticky=%d, data=%d, unsol=%d\\n\", i,\n\t\t\t    (enable & (1<<i)) ? 1 : 0,\n\t\t\t    (direction & (1<<i)) ? 1 : 0,\n\t\t\t    (wake & (1<<i)) ? 1 : 0,\n\t\t\t    (sticky & (1<<i)) ? 1 : 0,\n\t\t\t    (data & (1<<i)) ? 1 : 0,\n\t\t\t    (unsol & (1<<i)) ? 1 : 0);\n\t \n\tprint_nid_array(buffer, codec, nid, &codec->mixers);\n\tprint_nid_array(buffer, codec, nid, &codec->nids);\n}\n\nstatic void print_dpmst_connections(struct snd_info_buffer *buffer, struct hda_codec *codec,\n\t\t\t\t    hda_nid_t nid, int dev_num)\n{\n\tint c, conn_len, curr, dev_id_saved;\n\thda_nid_t *conn;\n\n\tconn_len = snd_hda_get_num_raw_conns(codec, nid);\n\tif (conn_len <= 0)\n\t\treturn;\n\n\tconn = kmalloc_array(conn_len, sizeof(hda_nid_t), GFP_KERNEL);\n\tif (!conn)\n\t\treturn;\n\n\tdev_id_saved = snd_hda_get_dev_select(codec, nid);\n\n\tsnd_hda_set_dev_select(codec, nid, dev_num);\n\tcurr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONNECT_SEL, 0);\n\tif (snd_hda_get_raw_connections(codec, nid, conn, conn_len) < 0)\n\t\tgoto out;\n\n\tfor (c = 0; c < conn_len; c++) {\n\t\tsnd_iprintf(buffer, \" 0x%02x\", conn[c]);\n\t\tif (c == curr)\n\t\t\tsnd_iprintf(buffer, \"*\");\n\t}\n\nout:\n\tkfree(conn);\n\tsnd_hda_set_dev_select(codec, nid, dev_id_saved);\n}\n\nstatic void print_device_list(struct snd_info_buffer *buffer,\n\t\t\t    struct hda_codec *codec, hda_nid_t nid)\n{\n\tint i, curr = -1;\n\tu8 dev_list[AC_MAX_DEV_LIST_LEN];\n\tint devlist_len;\n\n\tdevlist_len = snd_hda_get_devices(codec, nid, dev_list,\n\t\t\t\t\tAC_MAX_DEV_LIST_LEN);\n\tsnd_iprintf(buffer, \"  Devices: %d\\n\", devlist_len);\n\tif (devlist_len <= 0)\n\t\treturn;\n\n\tcurr = snd_hda_codec_read(codec, nid, 0,\n\t\t\t\tAC_VERB_GET_DEVICE_SEL, 0);\n\n\tfor (i = 0; i < devlist_len; i++) {\n\t\tif (i == curr)\n\t\t\tsnd_iprintf(buffer, \"    *\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"     \");\n\n\t\tsnd_iprintf(buffer,\n\t\t\t\"Dev %02d: PD = %d, ELDV = %d, IA = %d, Connections [\", i,\n\t\t\t!!(dev_list[i] & AC_DE_PD),\n\t\t\t!!(dev_list[i] & AC_DE_ELDV),\n\t\t\t!!(dev_list[i] & AC_DE_IA));\n\n\t\tprint_dpmst_connections(buffer, codec, nid, i);\n\n\t\tsnd_iprintf(buffer, \" ]\\n\");\n\t}\n}\n\nstatic void print_codec_core_info(struct hdac_device *codec,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tsnd_iprintf(buffer, \"Codec: \");\n\tif (codec->vendor_name && codec->chip_name)\n\t\tsnd_iprintf(buffer, \"%s %s\\n\",\n\t\t\t    codec->vendor_name, codec->chip_name);\n\telse\n\t\tsnd_iprintf(buffer, \"Not Set\\n\");\n\tsnd_iprintf(buffer, \"Address: %d\\n\", codec->addr);\n\tif (codec->afg)\n\t\tsnd_iprintf(buffer, \"AFG Function Id: 0x%x (unsol %u)\\n\",\n\t\t\tcodec->afg_function_id, codec->afg_unsol);\n\tif (codec->mfg)\n\t\tsnd_iprintf(buffer, \"MFG Function Id: 0x%x (unsol %u)\\n\",\n\t\t\tcodec->mfg_function_id, codec->mfg_unsol);\n\tsnd_iprintf(buffer, \"Vendor Id: 0x%08x\\n\", codec->vendor_id);\n\tsnd_iprintf(buffer, \"Subsystem Id: 0x%08x\\n\", codec->subsystem_id);\n\tsnd_iprintf(buffer, \"Revision Id: 0x%x\\n\", codec->revision_id);\n\n\tif (codec->mfg)\n\t\tsnd_iprintf(buffer, \"Modem Function Group: 0x%x\\n\", codec->mfg);\n\telse\n\t\tsnd_iprintf(buffer, \"No Modem Function Group found\\n\");\n}\n\nstatic void print_codec_info(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct hda_codec *codec = entry->private_data;\n\thda_nid_t nid, fg;\n\tint i, nodes;\n\n\tprint_codec_core_info(&codec->core, buffer);\n\tfg = codec->core.afg;\n\tif (!fg)\n\t\treturn;\n\tsnd_hda_power_up(codec);\n\tsnd_iprintf(buffer, \"Default PCM:\\n\");\n\tprint_pcm_caps(buffer, codec, fg);\n\tsnd_iprintf(buffer, \"Default Amp-In caps: \");\n\tprint_amp_caps(buffer, codec, fg, HDA_INPUT);\n\tsnd_iprintf(buffer, \"Default Amp-Out caps: \");\n\tprint_amp_caps(buffer, codec, fg, HDA_OUTPUT);\n\tsnd_iprintf(buffer, \"State of AFG node 0x%02x:\\n\", fg);\n\tprint_power_state(buffer, codec, fg);\n\n\tnodes = snd_hda_get_sub_nodes(codec, fg, &nid);\n\tif (! nid || nodes < 0) {\n\t\tsnd_iprintf(buffer, \"Invalid AFG subtree\\n\");\n\t\tsnd_hda_power_down(codec);\n\t\treturn;\n\t}\n\n\tprint_gpio(buffer, codec, fg);\n\tif (codec->proc_widget_hook)\n\t\tcodec->proc_widget_hook(buffer, codec, fg);\n\n\tfor (i = 0; i < nodes; i++, nid++) {\n\t\tunsigned int wid_caps =\n\t\t\tparam_read(codec, nid, AC_PAR_AUDIO_WIDGET_CAP);\n\t\tunsigned int wid_type = get_wcaps_type(wid_caps);\n\t\thda_nid_t *conn = NULL;\n\t\tint conn_len = 0;\n\n\t\tsnd_iprintf(buffer, \"Node 0x%02x [%s] wcaps 0x%x:\", nid,\n\t\t\t    get_wid_type_name(wid_type), wid_caps);\n\t\tif (wid_caps & AC_WCAP_STEREO) {\n\t\t\tunsigned int chans = get_wcaps_channels(wid_caps);\n\t\t\tif (chans == 2)\n\t\t\t\tsnd_iprintf(buffer, \" Stereo\");\n\t\t\telse\n\t\t\t\tsnd_iprintf(buffer, \" %d-Channels\", chans);\n\t\t} else\n\t\t\tsnd_iprintf(buffer, \" Mono\");\n\t\tif (wid_caps & AC_WCAP_DIGITAL)\n\t\t\tsnd_iprintf(buffer, \" Digital\");\n\t\tif (wid_caps & AC_WCAP_IN_AMP)\n\t\t\tsnd_iprintf(buffer, \" Amp-In\");\n\t\tif (wid_caps & AC_WCAP_OUT_AMP)\n\t\t\tsnd_iprintf(buffer, \" Amp-Out\");\n\t\tif (wid_caps & AC_WCAP_STRIPE)\n\t\t\tsnd_iprintf(buffer, \" Stripe\");\n\t\tif (wid_caps & AC_WCAP_LR_SWAP)\n\t\t\tsnd_iprintf(buffer, \" R/L\");\n\t\tif (wid_caps & AC_WCAP_CP_CAPS)\n\t\t\tsnd_iprintf(buffer, \" CP\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\n\t\tprint_nid_array(buffer, codec, nid, &codec->mixers);\n\t\tprint_nid_array(buffer, codec, nid, &codec->nids);\n\t\tprint_nid_pcms(buffer, codec, nid);\n\n\t\t \n\t\tif (wid_type == AC_WID_VOL_KNB)\n\t\t\twid_caps |= AC_WCAP_CONN_LIST;\n\n\t\tif (wid_caps & AC_WCAP_CONN_LIST) {\n\t\t\tconn_len = snd_hda_get_num_raw_conns(codec, nid);\n\t\t\tif (conn_len > 0) {\n\t\t\t\tconn = kmalloc_array(conn_len,\n\t\t\t\t\t\t     sizeof(hda_nid_t),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\t\tif (!conn)\n\t\t\t\t\treturn;\n\t\t\t\tif (snd_hda_get_raw_connections(codec, nid, conn,\n\t\t\t\t\t\t\t\tconn_len) < 0)\n\t\t\t\t\tconn_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (wid_caps & AC_WCAP_IN_AMP) {\n\t\t\tsnd_iprintf(buffer, \"  Amp-In caps: \");\n\t\t\tprint_amp_caps(buffer, codec, nid, HDA_INPUT);\n\t\t\tsnd_iprintf(buffer, \"  Amp-In vals: \");\n\t\t\tif (wid_type == AC_WID_PIN ||\n\t\t\t    (codec->single_adc_amp &&\n\t\t\t     wid_type == AC_WID_AUD_IN))\n\t\t\t\tprint_amp_vals(buffer, codec, nid, HDA_INPUT,\n\t\t\t\t\t       wid_caps, 1);\n\t\t\telse\n\t\t\t\tprint_amp_vals(buffer, codec, nid, HDA_INPUT,\n\t\t\t\t\t       wid_caps, conn_len);\n\t\t}\n\t\tif (wid_caps & AC_WCAP_OUT_AMP) {\n\t\t\tsnd_iprintf(buffer, \"  Amp-Out caps: \");\n\t\t\tprint_amp_caps(buffer, codec, nid, HDA_OUTPUT);\n\t\t\tsnd_iprintf(buffer, \"  Amp-Out vals: \");\n\t\t\tif (wid_type == AC_WID_PIN &&\n\t\t\t    codec->pin_amp_workaround)\n\t\t\t\tprint_amp_vals(buffer, codec, nid, HDA_OUTPUT,\n\t\t\t\t\t       wid_caps, conn_len);\n\t\t\telse\n\t\t\t\tprint_amp_vals(buffer, codec, nid, HDA_OUTPUT,\n\t\t\t\t\t       wid_caps, 1);\n\t\t}\n\n\t\tswitch (wid_type) {\n\t\tcase AC_WID_PIN: {\n\t\t\tint supports_vref;\n\t\t\tprint_pin_caps(buffer, codec, nid, &supports_vref);\n\t\t\tprint_pin_ctls(buffer, codec, nid, supports_vref);\n\t\t\tbreak;\n\t\t}\n\t\tcase AC_WID_VOL_KNB:\n\t\t\tprint_vol_knob(buffer, codec, nid);\n\t\t\tbreak;\n\t\tcase AC_WID_AUD_OUT:\n\t\tcase AC_WID_AUD_IN:\n\t\t\tprint_audio_io(buffer, codec, nid, wid_type);\n\t\t\tif (wid_caps & AC_WCAP_DIGITAL)\n\t\t\t\tprint_digital_conv(buffer, codec, nid);\n\t\t\tif (wid_caps & AC_WCAP_FORMAT_OVRD) {\n\t\t\t\tsnd_iprintf(buffer, \"  PCM:\\n\");\n\t\t\t\tprint_pcm_caps(buffer, codec, nid);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wid_caps & AC_WCAP_UNSOL_CAP)\n\t\t\tprint_unsol_cap(buffer, codec, nid);\n\n\t\tif (wid_caps & AC_WCAP_POWER)\n\t\t\tprint_power_state(buffer, codec, nid);\n\n\t\tif (wid_caps & AC_WCAP_DELAY)\n\t\t\tsnd_iprintf(buffer, \"  Delay: %d samples\\n\",\n\t\t\t\t    (wid_caps & AC_WCAP_DELAY) >>\n\t\t\t\t    AC_WCAP_DELAY_SHIFT);\n\n\t\tif (wid_type == AC_WID_PIN && codec->dp_mst)\n\t\t\tprint_device_list(buffer, codec, nid);\n\n\t\tif (wid_caps & AC_WCAP_CONN_LIST)\n\t\t\tprint_conn_list(buffer, codec, nid, wid_type,\n\t\t\t\t\tconn, conn_len);\n\n\t\tif (wid_caps & AC_WCAP_PROC_WID)\n\t\t\tprint_proc_caps(buffer, codec, nid);\n\n\t\tif (codec->proc_widget_hook)\n\t\t\tcodec->proc_widget_hook(buffer, codec, nid);\n\n\t\tkfree(conn);\n\t}\n\tsnd_hda_power_down(codec);\n}\n\n \nint snd_hda_codec_proc_new(struct hda_codec *codec)\n{\n\tchar name[32];\n\n\tsnprintf(name, sizeof(name), \"codec#%d\", codec->core.addr);\n\treturn snd_card_ro_proc_new(codec->card, name, codec, print_codec_info);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}