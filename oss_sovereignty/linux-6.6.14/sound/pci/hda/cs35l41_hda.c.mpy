{
  "module_name": "cs35l41_hda.c",
  "hash_id": "63516087c438fb2fd3bb52895feaab0dae27ab9b914b94d9f69ba4852d637c42",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/cs35l41_hda.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <sound/hda_codec.h>\n#include <sound/soc.h>\n#include <linux/pm_runtime.h>\n#include \"hda_local.h\"\n#include \"hda_auto_parser.h\"\n#include \"hda_jack.h\"\n#include \"hda_generic.h\"\n#include \"hda_component.h\"\n#include \"cs35l41_hda.h\"\n#include \"hda_cs_dsp_ctl.h\"\n#include \"cs35l41_hda_property.h\"\n\n#define CS35L41_FIRMWARE_ROOT \"cirrus/\"\n#define CS35L41_PART \"cs35l41\"\n\n#define HALO_STATE_DSP_CTL_NAME\t\t\"HALO_STATE\"\n#define HALO_STATE_DSP_CTL_TYPE\t\t5\n#define HALO_STATE_DSP_CTL_ALG\t\t262308\n#define CAL_R_DSP_CTL_NAME\t\t\"CAL_R\"\n#define CAL_STATUS_DSP_CTL_NAME\t\t\"CAL_STATUS\"\n#define CAL_CHECKSUM_DSP_CTL_NAME\t\"CAL_CHECKSUM\"\n#define CAL_AMBIENT_DSP_CTL_NAME\t\"CAL_AMBIENT\"\n#define CAL_DSP_CTL_TYPE\t\t5\n#define CAL_DSP_CTL_ALG\t\t\t205\n\nstatic bool firmware_autostart = 1;\nmodule_param(firmware_autostart, bool, 0444);\nMODULE_PARM_DESC(firmware_autostart, \"Allow automatic firmware download on boot\"\n\t\t\t     \"(0=Disable, 1=Enable) (default=1); \");\n\nstatic const struct reg_sequence cs35l41_hda_config[] = {\n\t{ CS35L41_PLL_CLK_CTRL,\t\t0x00000430 }, \n\t{ CS35L41_DSP_CLK_CTRL,\t\t0x00000003 }, \n\t{ CS35L41_GLOBAL_CLK_CTRL,\t0x00000003 }, \n\t{ CS35L41_SP_ENABLES,\t\t0x00010000 }, \n\t{ CS35L41_SP_RATE_CTRL,\t\t0x00000021 }, \n\t{ CS35L41_SP_FORMAT,\t\t0x20200200 }, \n\t{ CS35L41_SP_HIZ_CTRL,\t\t0x00000002 }, \n\t{ CS35L41_SP_TX_WL,\t\t0x00000018 }, \n\t{ CS35L41_SP_RX_WL,\t\t0x00000018 }, \n\t{ CS35L41_DAC_PCM1_SRC,\t\t0x00000008 }, \n\t{ CS35L41_ASP_TX1_SRC,\t\t0x00000018 }, \n\t{ CS35L41_ASP_TX2_SRC,\t\t0x00000019 }, \n\t{ CS35L41_ASP_TX3_SRC,\t\t0x00000032 }, \n\t{ CS35L41_ASP_TX4_SRC,\t\t0x00000033 }, \n\t{ CS35L41_DSP1_RX1_SRC,\t\t0x00000008 }, \n\t{ CS35L41_DSP1_RX2_SRC,\t\t0x00000009 }, \n\t{ CS35L41_DSP1_RX3_SRC,         0x00000018 }, \n\t{ CS35L41_DSP1_RX4_SRC,         0x00000019 }, \n\t{ CS35L41_DSP1_RX5_SRC,         0x00000020 }, \n};\n\nstatic const struct reg_sequence cs35l41_hda_config_dsp[] = {\n\t{ CS35L41_PLL_CLK_CTRL,\t\t0x00000430 }, \n\t{ CS35L41_DSP_CLK_CTRL,\t\t0x00000003 }, \n\t{ CS35L41_GLOBAL_CLK_CTRL,\t0x00000003 }, \n\t{ CS35L41_SP_ENABLES,\t\t0x00010001 }, \n\t{ CS35L41_SP_RATE_CTRL,\t\t0x00000021 }, \n\t{ CS35L41_SP_FORMAT,\t\t0x20200200 }, \n\t{ CS35L41_SP_HIZ_CTRL,\t\t0x00000003 }, \n\t{ CS35L41_SP_TX_WL,\t\t0x00000018 }, \n\t{ CS35L41_SP_RX_WL,\t\t0x00000018 }, \n\t{ CS35L41_DAC_PCM1_SRC,\t\t0x00000032 }, \n\t{ CS35L41_ASP_TX1_SRC,\t\t0x00000018 }, \n\t{ CS35L41_ASP_TX2_SRC,\t\t0x00000019 }, \n\t{ CS35L41_ASP_TX3_SRC,\t\t0x00000028 }, \n\t{ CS35L41_ASP_TX4_SRC,\t\t0x00000029 }, \n\t{ CS35L41_DSP1_RX1_SRC,\t\t0x00000008 }, \n\t{ CS35L41_DSP1_RX2_SRC,\t\t0x00000008 }, \n\t{ CS35L41_DSP1_RX3_SRC,         0x00000018 }, \n\t{ CS35L41_DSP1_RX4_SRC,         0x00000019 }, \n\t{ CS35L41_DSP1_RX5_SRC,         0x00000029 }, \n};\n\nstatic const struct reg_sequence cs35l41_hda_unmute[] = {\n\t{ CS35L41_AMP_DIG_VOL_CTRL,\t0x00008000 }, \n\t{ CS35L41_AMP_GAIN_CTRL,\t0x00000084 }, \n};\n\nstatic const struct reg_sequence cs35l41_hda_unmute_dsp[] = {\n\t{ CS35L41_AMP_DIG_VOL_CTRL,\t0x00008000 }, \n\t{ CS35L41_AMP_GAIN_CTRL,\t0x00000233 }, \n};\n\nstatic const struct reg_sequence cs35l41_hda_mute[] = {\n\t{ CS35L41_AMP_GAIN_CTRL,\t0x00000000 }, \n\t{ CS35L41_AMP_DIG_VOL_CTRL,\t0x0000A678 }, \n};\n\nstatic void cs35l41_add_controls(struct cs35l41_hda *cs35l41)\n{\n\tstruct hda_cs_dsp_ctl_info info;\n\n\tinfo.device_name = cs35l41->amp_name;\n\tinfo.fw_type = cs35l41->firmware_type;\n\tinfo.card = cs35l41->codec->card;\n\n\thda_cs_dsp_add_controls(&cs35l41->cs_dsp, &info);\n}\n\nstatic const struct cs_dsp_client_ops client_ops = {\n\t.control_remove = hda_cs_dsp_control_remove,\n};\n\nstatic int cs35l41_request_firmware_file(struct cs35l41_hda *cs35l41,\n\t\t\t\t\t const struct firmware **firmware, char **filename,\n\t\t\t\t\t const char *dir, const char *ssid, const char *amp_name,\n\t\t\t\t\t int spkid, const char *filetype)\n{\n\tconst char * const dsp_name = cs35l41->cs_dsp.name;\n\tchar *s, c;\n\tint ret = 0;\n\n\tif (spkid > -1 && ssid && amp_name)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s-spkid%d-%s.%s\", dir, CS35L41_PART,\n\t\t\t\t      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],\n\t\t\t\t      ssid, spkid, amp_name, filetype);\n\telse if (spkid > -1 && ssid)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s-spkid%d.%s\", dir, CS35L41_PART,\n\t\t\t\t      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],\n\t\t\t\t      ssid, spkid, filetype);\n\telse if (ssid && amp_name)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s-%s.%s\", dir, CS35L41_PART,\n\t\t\t\t      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],\n\t\t\t\t      ssid, amp_name, filetype);\n\telse if (ssid)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s.%s\", dir, CS35L41_PART,\n\t\t\t\t      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],\n\t\t\t\t      ssid, filetype);\n\telse\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s.%s\", dir, CS35L41_PART,\n\t\t\t\t      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],\n\t\t\t\t      filetype);\n\n\tif (*filename == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\ts = *filename;\n\twhile (*s) {\n\t\tc = *s;\n\t\tif (isalnum(c))\n\t\t\t*s = tolower(c);\n\t\telse if (c != '.' && c != '/')\n\t\t\t*s = '-';\n\t\ts++;\n\t}\n\n\tret = firmware_request_nowarn(firmware, *filename, cs35l41->dev);\n\tif (ret != 0) {\n\t\tdev_dbg(cs35l41->dev, \"Failed to request '%s'\\n\", *filename);\n\t\tkfree(*filename);\n\t\t*filename = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cs35l41_request_firmware_files_spkid(struct cs35l41_hda *cs35l41,\n\t\t\t\t\t\tconst struct firmware **wmfw_firmware,\n\t\t\t\t\t\tchar **wmfw_filename,\n\t\t\t\t\t\tconst struct firmware **coeff_firmware,\n\t\t\t\t\t\tchar **coeff_filename)\n{\n\tint ret;\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t    cs35l41->acpi_subsystem_id, cs35l41->amp_name,\n\t\t\t\t\t    cs35l41->speaker_id, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, cs35l41->amp_name,\n\t\t\t\t\t\t    cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,\n\t\t\t\t\t    cs35l41->amp_name, -1, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, cs35l41->amp_name,\n\t\t\t\t\t\t    cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,\n\t\t\t\t\t    NULL, cs35l41->speaker_id, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id,\n\t\t\t\t\t\t    cs35l41->amp_name, cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\t \n\t\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware,\n\t\t\t\t\t\t\t    coeff_filename, CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, NULL,\n\t\t\t\t\t\t\t    cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,\n\t\t\t\t\t    NULL, -1, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, cs35l41->amp_name,\n\t\t\t\t\t\t    cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\t \n\t\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware,\n\t\t\t\t\t\t\t    coeff_filename, CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, NULL,\n\t\t\t\t\t\t\t    cs35l41->speaker_id, \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\t}\n\n\treturn ret;\ncoeff_err:\n\trelease_firmware(*wmfw_firmware);\n\tkfree(*wmfw_filename);\n\treturn ret;\n}\n\nstatic int cs35l41_fallback_firmware_file(struct cs35l41_hda *cs35l41,\n\t\t\t\t\t  const struct firmware **wmfw_firmware,\n\t\t\t\t\t  char **wmfw_filename,\n\t\t\t\t\t  const struct firmware **coeff_firmware,\n\t\t\t\t\t  char **coeff_filename)\n{\n\tint ret;\n\n\t \n\tdev_warn(cs35l41->dev, \"Falling back to default firmware.\\n\");\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, \"wmfw\");\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, \"bin\");\n\tif (ret) {\n\t\trelease_firmware(*wmfw_firmware);\n\t\tkfree(*wmfw_filename);\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tdev_warn(cs35l41->dev, \"Unable to find firmware and tuning\\n\");\n\treturn ret;\n}\n\nstatic int cs35l41_request_firmware_files(struct cs35l41_hda *cs35l41,\n\t\t\t\t\t  const struct firmware **wmfw_firmware,\n\t\t\t\t\t  char **wmfw_filename,\n\t\t\t\t\t  const struct firmware **coeff_firmware,\n\t\t\t\t\t  char **coeff_filename)\n{\n\tint ret;\n\n\tif (cs35l41->speaker_id > -1) {\n\t\tret = cs35l41_request_firmware_files_spkid(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\t\t   coeff_firmware, coeff_filename);\n\t\tgoto out;\n\t}\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,\n\t\t\t\t\t    cs35l41->amp_name, -1, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, cs35l41->amp_name,\n\t\t\t\t\t\t    -1, \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\n\t\tgoto out;\n\t}\n\n\t \n\tret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,\n\t\t\t\t\t    NULL, -1, \"wmfw\");\n\tif (!ret) {\n\t\t \n\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t    cs35l41->acpi_subsystem_id,\n\t\t\t\t\t\t    cs35l41->amp_name, -1, \"bin\");\n\t\tif (ret)\n\t\t\t \n\t\t\tret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t    CS35L41_FIRMWARE_ROOT,\n\t\t\t\t\t\t\t    cs35l41->acpi_subsystem_id, NULL, -1,\n\t\t\t\t\t\t\t    \"bin\");\n\t\tif (ret)\n\t\t\tgoto coeff_err;\n\t}\n\nout:\n\tif (ret)\n\t\t \n\t\tgoto fallback;\n\n\treturn 0;\n\ncoeff_err:\n\trelease_firmware(*wmfw_firmware);\n\tkfree(*wmfw_filename);\nfallback:\n\treturn cs35l41_fallback_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t      coeff_firmware, coeff_filename);\n}\n\n#if IS_ENABLED(CONFIG_EFI)\nstatic int cs35l41_apply_calibration(struct cs35l41_hda *cs35l41, __be32 ambient, __be32 r0,\n\t\t\t\t     __be32 status, __be32 checksum)\n{\n\tint ret;\n\n\tret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_AMBIENT_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,\n\t\t\t\t   CAL_DSP_CTL_ALG, &ambient, 4);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Cannot Write Control: %s - %d\\n\", CAL_AMBIENT_DSP_CTL_NAME,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_R_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,\n\t\t\t\t   CAL_DSP_CTL_ALG, &r0, 4);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Cannot Write Control: %s - %d\\n\", CAL_R_DSP_CTL_NAME, ret);\n\t\treturn ret;\n\t}\n\tret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_STATUS_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,\n\t\t\t\t   CAL_DSP_CTL_ALG, &status, 4);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Cannot Write Control: %s - %d\\n\", CAL_STATUS_DSP_CTL_NAME,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_CHECKSUM_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,\n\t\t\t\t   CAL_DSP_CTL_ALG, &checksum, 4);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Cannot Write Control: %s - %d\\n\", CAL_CHECKSUM_DSP_CTL_NAME,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l41_save_calibration(struct cs35l41_hda *cs35l41)\n{\n\tstatic efi_guid_t efi_guid = EFI_GUID(0x02f9af02, 0x7734, 0x4233, 0xb4, 0x3d, 0x93, 0xfe,\n\t\t\t\t\t      0x5a, 0xa3, 0x5d, 0xb3);\n\tstatic efi_char16_t efi_name[] = L\"CirrusSmartAmpCalibrationData\";\n\tconst struct cs35l41_amp_efi_data *efi_data;\n\tconst struct cs35l41_amp_cal_data *cl;\n\tunsigned long data_size = 0;\n\tefi_status_t status;\n\tint ret = 0;\n\tu8 *data = NULL;\n\tu32 attr;\n\n\t \n\tstatus = efi.get_variable(efi_name, &efi_guid, &attr, &data_size, data);\n\tif (status == EFI_BUFFER_TOO_SMALL) {\n\t\tret = -ENODEV;\n\t\t \n\t\tdata = vmalloc(data_size);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tstatus = efi.get_variable(efi_name, &efi_guid, &attr, &data_size, data);\n\t\tif (status == EFI_SUCCESS) {\n\t\t\tefi_data = (struct cs35l41_amp_efi_data *)data;\n\t\t\tdev_dbg(cs35l41->dev, \"Calibration: Size=%d, Amp Count=%d\\n\",\n\t\t\t\tefi_data->size, efi_data->count);\n\t\t\tif (efi_data->count > cs35l41->index) {\n\t\t\t\tcl = &efi_data->data[cs35l41->index];\n\t\t\t\tdev_dbg(cs35l41->dev,\n\t\t\t\t\t\"Calibration: Ambient=%02x, Status=%02x, R0=%d\\n\",\n\t\t\t\t\tcl->calAmbient, cl->calStatus, cl->calR);\n\n\t\t\t\t \n\t\t\t\tret = cs35l41_apply_calibration(cs35l41,\n\t\t\t\t\t\t\t\tcpu_to_be32(cl->calAmbient),\n\t\t\t\t\t\t\t\tcpu_to_be32(cl->calR),\n\t\t\t\t\t\t\t\tcpu_to_be32(cl->calStatus),\n\t\t\t\t\t\t\t\tcpu_to_be32(cl->calR + 1));\n\t\t\t}\n\t\t}\n\t\tvfree(data);\n\t}\n\treturn ret;\n}\n#else\nstatic int cs35l41_save_calibration(struct cs35l41_hda *cs35l41)\n{\n\tdev_warn(cs35l41->dev, \"Calibration not supported without EFI support.\\n\");\n\treturn 0;\n}\n#endif\n\nstatic int cs35l41_init_dsp(struct cs35l41_hda *cs35l41)\n{\n\tconst struct firmware *coeff_firmware = NULL;\n\tconst struct firmware *wmfw_firmware = NULL;\n\tstruct cs_dsp *dsp = &cs35l41->cs_dsp;\n\tchar *coeff_filename = NULL;\n\tchar *wmfw_filename = NULL;\n\tint ret;\n\n\tif (!cs35l41->halo_initialized) {\n\t\tcs35l41_configure_cs_dsp(cs35l41->dev, cs35l41->regmap, dsp);\n\t\tdsp->client_ops = &client_ops;\n\n\t\tret = cs_dsp_halo_init(&cs35l41->cs_dsp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcs35l41->halo_initialized = true;\n\t}\n\n\tret = cs35l41_request_firmware_files(cs35l41, &wmfw_firmware, &wmfw_filename,\n\t\t\t\t\t     &coeff_firmware, &coeff_filename);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(cs35l41->dev, \"Loading WMFW Firmware: %s\\n\", wmfw_filename);\n\tif (coeff_filename)\n\t\tdev_dbg(cs35l41->dev, \"Loading Coefficient File: %s\\n\", coeff_filename);\n\telse\n\t\tdev_warn(cs35l41->dev, \"No Coefficient File available.\\n\");\n\n\tret = cs_dsp_power_up(dsp, wmfw_firmware, wmfw_filename, coeff_firmware, coeff_filename,\n\t\t\t      hda_cs_dsp_fw_ids[cs35l41->firmware_type]);\n\tif (ret)\n\t\tgoto err_release;\n\n\tcs35l41_add_controls(cs35l41);\n\n\tret = cs35l41_save_calibration(cs35l41);\n\nerr_release:\n\trelease_firmware(wmfw_firmware);\n\trelease_firmware(coeff_firmware);\n\tkfree(wmfw_filename);\n\tkfree(coeff_filename);\n\n\treturn ret;\n}\n\nstatic void cs35l41_shutdown_dsp(struct cs35l41_hda *cs35l41)\n{\n\tstruct cs_dsp *dsp = &cs35l41->cs_dsp;\n\n\tcs_dsp_stop(dsp);\n\tcs_dsp_power_down(dsp);\n\tcs35l41->firmware_running = false;\n\tdev_dbg(cs35l41->dev, \"Unloaded Firmware\\n\");\n}\n\nstatic void cs35l41_remove_dsp(struct cs35l41_hda *cs35l41)\n{\n\tstruct cs_dsp *dsp = &cs35l41->cs_dsp;\n\n\tcancel_work_sync(&cs35l41->fw_load_work);\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\tcs35l41_shutdown_dsp(cs35l41);\n\tcs_dsp_remove(dsp);\n\tcs35l41->halo_initialized = false;\n\tmutex_unlock(&cs35l41->fw_mutex);\n}\n\n \nstatic void cs35l41_error_release(struct device *dev, struct regmap *regmap, unsigned int mask)\n{\n\tregmap_write(regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);\n\tregmap_set_bits(regmap, CS35L41_PROTECT_REL_ERR_IGN, mask);\n\tregmap_clear_bits(regmap, CS35L41_PROTECT_REL_ERR_IGN, mask);\n}\n\n \nstatic void cs35l41_irq_release(struct cs35l41_hda *cs35l41)\n{\n\tcs35l41_error_release(cs35l41->dev, cs35l41->regmap, cs35l41->irq_errors);\n\tcs35l41->irq_errors = 0;\n}\n\nstatic void cs35l41_hda_play_start(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct regmap *reg = cs35l41->regmap;\n\n\tdev_dbg(dev, \"Play (Start)\\n\");\n\n\tif (cs35l41->playback_started) {\n\t\tdev_dbg(dev, \"Playback already started.\");\n\t\treturn;\n\t}\n\n\tcs35l41->playback_started = true;\n\n\tif (cs35l41->firmware_running) {\n\t\tregmap_multi_reg_write(reg, cs35l41_hda_config_dsp,\n\t\t\t\t       ARRAY_SIZE(cs35l41_hda_config_dsp));\n\t\tregmap_update_bits(reg, CS35L41_PWR_CTRL2,\n\t\t\t\t   CS35L41_VMON_EN_MASK | CS35L41_IMON_EN_MASK,\n\t\t\t\t   1 << CS35L41_VMON_EN_SHIFT | 1 << CS35L41_IMON_EN_SHIFT);\n\t\tcs35l41_set_cspl_mbox_cmd(cs35l41->dev, reg, CSPL_MBOX_CMD_RESUME);\n\t} else {\n\t\tregmap_multi_reg_write(reg, cs35l41_hda_config, ARRAY_SIZE(cs35l41_hda_config));\n\t}\n\tregmap_update_bits(reg, CS35L41_PWR_CTRL2, CS35L41_AMP_EN_MASK, 1 << CS35L41_AMP_EN_SHIFT);\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)\n\t\tregmap_write(reg, CS35L41_GPIO1_CTRL1, 0x00008001);\n\n}\n\nstatic void cs35l41_hda_play_done(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct regmap *reg = cs35l41->regmap;\n\n\tdev_dbg(dev, \"Play (Complete)\\n\");\n\n\tcs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 1,\n\t\t\t      cs35l41->firmware_running);\n\tif (cs35l41->firmware_running) {\n\t\tregmap_multi_reg_write(reg, cs35l41_hda_unmute_dsp,\n\t\t\t\t       ARRAY_SIZE(cs35l41_hda_unmute_dsp));\n\t} else {\n\t\tregmap_multi_reg_write(reg, cs35l41_hda_unmute,\n\t\t\t\t       ARRAY_SIZE(cs35l41_hda_unmute));\n\t}\n}\n\nstatic void cs35l41_hda_pause_start(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct regmap *reg = cs35l41->regmap;\n\n\tdev_dbg(dev, \"Pause (Start)\\n\");\n\n\tregmap_multi_reg_write(reg, cs35l41_hda_mute, ARRAY_SIZE(cs35l41_hda_mute));\n\tcs35l41_global_enable(dev, reg, cs35l41->hw_cfg.bst_type, 0,\n\t\t\t      cs35l41->firmware_running);\n}\n\nstatic void cs35l41_hda_pause_done(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct regmap *reg = cs35l41->regmap;\n\n\tdev_dbg(dev, \"Pause (Complete)\\n\");\n\n\tregmap_update_bits(reg, CS35L41_PWR_CTRL2, CS35L41_AMP_EN_MASK, 0 << CS35L41_AMP_EN_SHIFT);\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)\n\t\tregmap_write(reg, CS35L41_GPIO1_CTRL1, 0x00000001);\n\tif (cs35l41->firmware_running) {\n\t\tcs35l41_set_cspl_mbox_cmd(dev, reg, CSPL_MBOX_CMD_PAUSE);\n\t\tregmap_update_bits(reg, CS35L41_PWR_CTRL2,\n\t\t\t\t   CS35L41_VMON_EN_MASK | CS35L41_IMON_EN_MASK,\n\t\t\t\t   0 << CS35L41_VMON_EN_SHIFT | 0 << CS35L41_IMON_EN_SHIFT);\n\t}\n\tcs35l41_irq_release(cs35l41);\n\tcs35l41->playback_started = false;\n}\n\nstatic void cs35l41_hda_pre_playback_hook(struct device *dev, int action)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tmutex_lock(&cs35l41->fw_mutex);\n\t\tcs35l41_hda_pause_start(dev);\n\t\tmutex_unlock(&cs35l41->fw_mutex);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nstatic void cs35l41_hda_playback_hook(struct device *dev, int action)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_OPEN:\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tmutex_lock(&cs35l41->fw_mutex);\n\t\tcs35l41_hda_play_start(dev);\n\t\tmutex_unlock(&cs35l41->fw_mutex);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLEANUP:\n\t\tmutex_lock(&cs35l41->fw_mutex);\n\t\tcs35l41_hda_pause_done(dev);\n\t\tmutex_unlock(&cs35l41->fw_mutex);\n\t\tbreak;\n\tcase HDA_GEN_PCM_ACT_CLOSE:\n\t\tmutex_lock(&cs35l41->fw_mutex);\n\t\tif (!cs35l41->firmware_running && cs35l41->request_fw_load &&\n\t\t    !cs35l41->fw_request_ongoing) {\n\t\t\tdev_info(dev, \"Requesting Firmware Load after HDA_GEN_PCM_ACT_CLOSE\\n\");\n\t\t\tcs35l41->fw_request_ongoing = true;\n\t\t\tschedule_work(&cs35l41->fw_load_work);\n\t\t}\n\t\tmutex_unlock(&cs35l41->fw_mutex);\n\n\t\t \n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_autosuspend(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void cs35l41_hda_post_playback_hook(struct device *dev, int action)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tswitch (action) {\n\tcase HDA_GEN_PCM_ACT_PREPARE:\n\t\tmutex_lock(&cs35l41->fw_mutex);\n\t\tcs35l41_hda_play_done(dev);\n\t\tmutex_unlock(&cs35l41->fw_mutex);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int cs35l41_hda_channel_map(struct device *dev, unsigned int tx_num, unsigned int *tx_slot,\n\t\t\t\t    unsigned int rx_num, unsigned int *rx_slot)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstatic const char * const channel_name[] = { \"L\", \"R\" };\n\n\tif (!cs35l41->amp_name) {\n\t\tif (*rx_slot >= ARRAY_SIZE(channel_name))\n\t\t\treturn -EINVAL;\n\n\t\tcs35l41->amp_name = devm_kasprintf(cs35l41->dev, GFP_KERNEL, \"%s%d\",\n\t\t\t\t\t\t   channel_name[*rx_slot], cs35l41->channel_index);\n\t\tif (!cs35l41->amp_name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn cs35l41_set_channels(cs35l41->dev, cs35l41->regmap, tx_num, tx_slot, rx_num,\n\t\t\t\t    rx_slot);\n}\n\nstatic int cs35l41_ready_for_reset(struct cs35l41_hda *cs35l41)\n{\n\tint ret = 0;\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\tif (cs35l41->firmware_running) {\n\n\t\tregcache_cache_only(cs35l41->regmap, false);\n\n\t\tret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);\n\t\tif (ret) {\n\t\t\tdev_warn(cs35l41->dev, \"Unable to exit Hibernate.\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tcs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);\n\t\tret = regcache_sync(cs35l41->regmap);\n\t\tcs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);\n\t\tif (ret) {\n\t\t\tdev_err(cs35l41->dev, \"Failed to restore register cache: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)\n\t\t\tcs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);\n\n\t\tcs35l41_shutdown_dsp(cs35l41);\n\t\tcs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);\n\t}\nerr:\n\tregcache_cache_only(cs35l41->regmap, true);\n\tregcache_mark_dirty(cs35l41->regmap);\n\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\treturn ret;\n}\n\nstatic int cs35l41_system_suspend_prep(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"System Suspend Prepare\\n\");\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {\n\t\tdev_err_once(cs35l41->dev, \"System Suspend not supported\\n\");\n\t\treturn 0;  \n\t}\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\tif (cs35l41->playback_started)\n\t\tcs35l41_hda_pause_start(dev);\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\treturn 0;\n}\n\nstatic int cs35l41_system_suspend(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(cs35l41->dev, \"System Suspend\\n\");\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {\n\t\tdev_err_once(cs35l41->dev, \"System Suspend not supported\\n\");\n\t\treturn 0;  \n\t}\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\tif (cs35l41->playback_started)\n\t\tcs35l41_hda_pause_done(dev);\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"System Suspend Failed, unable to runtime suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = cs35l41_ready_for_reset(cs35l41);\n\n\tif (ret)\n\t\tdev_err(dev, \"System Suspend Failed, not ready for Reset: %d\\n\", ret);\n\n\t \n\treturn ret;\n}\n\nstatic int cs35l41_system_resume(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(cs35l41->dev, \"System Resume\\n\");\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {\n\t\tdev_err_once(cs35l41->dev, \"System Resume not supported\\n\");\n\t\treturn 0;  \n\t}\n\n\tif (cs35l41->reset_gpio) {\n\t\tusleep_range(2000, 2100);\n\t\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 1);\n\t}\n\n\tusleep_range(2000, 2100);\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"System Resume Failed: Unable to runtime resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\n\tif (cs35l41->request_fw_load && !cs35l41->fw_request_ongoing) {\n\t\tcs35l41->fw_request_ongoing = true;\n\t\tschedule_work(&cs35l41->fw_load_work);\n\t}\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\treturn ret;\n}\n\nstatic int cs35l41_runtime_idle(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH)\n\t\treturn -EBUSY;  \n\treturn 0;\n}\n\nstatic int cs35l41_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdev_dbg(cs35l41->dev, \"Runtime Suspend\\n\");\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {\n\t\tdev_dbg(cs35l41->dev, \"Runtime Suspend not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\n\tif (cs35l41->firmware_running) {\n\t\tret = cs35l41_enter_hibernate(cs35l41->dev, cs35l41->regmap,\n\t\t\t\t\t      cs35l41->hw_cfg.bst_type);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tcs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);\n\t}\n\n\tregcache_cache_only(cs35l41->regmap, true);\n\tregcache_mark_dirty(cs35l41->regmap);\n\nerr:\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\treturn ret;\n}\n\nstatic int cs35l41_runtime_resume(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdev_dbg(cs35l41->dev, \"Runtime Resume\\n\");\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {\n\t\tdev_dbg(cs35l41->dev, \"Runtime Resume not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\n\tregcache_cache_only(cs35l41->regmap, false);\n\n\tif (cs35l41->firmware_running)\t{\n\t\tret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);\n\t\tif (ret) {\n\t\t\tdev_warn(cs35l41->dev, \"Unable to exit Hibernate.\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tcs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);\n\tret = regcache_sync(cs35l41->regmap);\n\tcs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Failed to restore register cache: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)\n\t\tcs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);\n\nerr:\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\treturn ret;\n}\n\nstatic int cs35l41_smart_amp(struct cs35l41_hda *cs35l41)\n{\n\t__be32 halo_sts;\n\tint ret;\n\n\tret = cs35l41_init_dsp(cs35l41);\n\tif (ret) {\n\t\tdev_warn(cs35l41->dev, \"Cannot Initialize Firmware. Error: %d\\n\", ret);\n\t\tgoto clean_dsp;\n\t}\n\n\tret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Cannot Write FS Errata: %d\\n\", ret);\n\t\tgoto clean_dsp;\n\t}\n\n\tret = cs_dsp_run(&cs35l41->cs_dsp);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Fail to start dsp: %d\\n\", ret);\n\t\tgoto clean_dsp;\n\t}\n\n\tret = read_poll_timeout(hda_cs_dsp_read_ctl, ret,\n\t\t\t\tbe32_to_cpu(halo_sts) == HALO_STATE_CODE_RUN,\n\t\t\t\t1000, 15000, false, &cs35l41->cs_dsp, HALO_STATE_DSP_CTL_NAME,\n\t\t\t\tHALO_STATE_DSP_CTL_TYPE, HALO_STATE_DSP_CTL_ALG,\n\t\t\t\t&halo_sts, sizeof(halo_sts));\n\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Timeout waiting for HALO Core to start. State: %u\\n\",\n\t\t\t halo_sts);\n\t\tgoto clean_dsp;\n\t}\n\n\tret = cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap, CSPL_MBOX_CMD_PAUSE);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Error waiting for DSP to pause: %u\\n\", ret);\n\t\tgoto clean_dsp;\n\t}\n\n\tcs35l41->firmware_running = true;\n\n\treturn 0;\n\nclean_dsp:\n\tcs35l41_shutdown_dsp(cs35l41);\n\treturn ret;\n}\n\nstatic void cs35l41_load_firmware(struct cs35l41_hda *cs35l41, bool load)\n{\n\tif (cs35l41->firmware_running && !load) {\n\t\tdev_dbg(cs35l41->dev, \"Unloading Firmware\\n\");\n\t\tcs35l41_shutdown_dsp(cs35l41);\n\t} else if (!cs35l41->firmware_running && load) {\n\t\tdev_dbg(cs35l41->dev, \"Loading Firmware\\n\");\n\t\tcs35l41_smart_amp(cs35l41);\n\t} else {\n\t\tdev_dbg(cs35l41->dev, \"Unable to Load firmware.\\n\");\n\t}\n}\n\nstatic int cs35l41_fw_load_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = cs35l41->request_fw_load;\n\treturn 0;\n}\n\nstatic void cs35l41_fw_load_work(struct work_struct *work)\n{\n\tstruct cs35l41_hda *cs35l41 = container_of(work, struct cs35l41_hda, fw_load_work);\n\n\tpm_runtime_get_sync(cs35l41->dev);\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\n\t \n\tif (cs35l41->playback_started)\n\t\tdev_err(cs35l41->dev, \"Cannot Load/Unload firmware during Playback. Retrying...\\n\");\n\telse\n\t\tcs35l41_load_firmware(cs35l41, cs35l41->request_fw_load);\n\n\tcs35l41->fw_request_ongoing = false;\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\tpm_runtime_mark_last_busy(cs35l41->dev);\n\tpm_runtime_put_autosuspend(cs35l41->dev);\n}\n\nstatic int cs35l41_fw_load_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);\n\n\tif (cs35l41->request_fw_load == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tif (cs35l41->fw_request_ongoing) {\n\t\tdev_dbg(cs35l41->dev, \"Existing request not complete\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (cs35l41->playback_started) {\n\t\tdev_err(cs35l41->dev, \"Cannot Load/Unload firmware during Playback\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcs35l41->fw_request_ongoing = true;\n\tcs35l41->request_fw_load = ucontrol->value.integer.value[0];\n\tschedule_work(&cs35l41->fw_load_work);\n\n\treturn 1;\n}\n\nstatic int cs35l41_fw_type_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = cs35l41->firmware_type;\n\n\treturn 0;\n}\n\nstatic int cs35l41_fw_type_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.enumerated.item[0] < HDA_CS_DSP_NUM_FW) {\n\t\tif (cs35l41->firmware_type != ucontrol->value.enumerated.item[0]) {\n\t\t\tcs35l41->firmware_type = ucontrol->value.enumerated.item[0];\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cs35l41_fw_type_ctl_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(hda_cs_dsp_fw_ids), hda_cs_dsp_fw_ids);\n}\n\nstatic int cs35l41_create_controls(struct cs35l41_hda *cs35l41)\n{\n\tchar fw_type_ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tchar fw_load_ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tstruct snd_kcontrol_new fw_type_ctl = {\n\t\t.name = fw_type_ctl_name,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t\t.info = cs35l41_fw_type_ctl_info,\n\t\t.get = cs35l41_fw_type_ctl_get,\n\t\t.put = cs35l41_fw_type_ctl_put,\n\t};\n\tstruct snd_kcontrol_new fw_load_ctl = {\n\t\t.name = fw_load_ctl_name,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = cs35l41_fw_load_ctl_get,\n\t\t.put = cs35l41_fw_load_ctl_put,\n\t};\n\tint ret;\n\n\tscnprintf(fw_type_ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, \"%s DSP1 Firmware Type\",\n\t\t  cs35l41->amp_name);\n\tscnprintf(fw_load_ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, \"%s DSP1 Firmware Load\",\n\t\t  cs35l41->amp_name);\n\n\tret = snd_ctl_add(cs35l41->codec->card, snd_ctl_new1(&fw_type_ctl, cs35l41));\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Failed to add KControl %s = %d\\n\", fw_type_ctl.name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(cs35l41->dev, \"Added Control %s\\n\", fw_type_ctl.name);\n\n\tret = snd_ctl_add(cs35l41->codec->card, snd_ctl_new1(&fw_load_ctl, cs35l41));\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Failed to add KControl %s = %d\\n\", fw_load_ctl.name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(cs35l41->dev, \"Added Control %s\\n\", fw_load_ctl.name);\n\n\treturn 0;\n}\n\nstatic int cs35l41_hda_bind(struct device *dev, struct device *master, void *master_data)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tunsigned int sleep_flags;\n\tint ret = 0;\n\n\tif (!comps || cs35l41->index < 0 || cs35l41->index >= HDA_MAX_COMPONENTS)\n\t\treturn -EINVAL;\n\n\tcomps = &comps[cs35l41->index];\n\tif (comps->dev)\n\t\treturn -EBUSY;\n\n\tpm_runtime_get_sync(dev);\n\n\tmutex_lock(&cs35l41->fw_mutex);\n\n\tcomps->dev = dev;\n\tif (!cs35l41->acpi_subsystem_id)\n\t\tcs35l41->acpi_subsystem_id = kasprintf(GFP_KERNEL, \"%.8x\",\n\t\t\t\t\t\t       comps->codec->core.subsystem_id);\n\tcs35l41->codec = comps->codec;\n\tstrscpy(comps->name, dev_name(dev), sizeof(comps->name));\n\n\tcs35l41->firmware_type = HDA_CS_DSP_FW_SPK_PROT;\n\n\tif (firmware_autostart) {\n\t\tdev_dbg(cs35l41->dev, \"Firmware Autostart.\\n\");\n\t\tcs35l41->request_fw_load = true;\n\t\tif (cs35l41_smart_amp(cs35l41) < 0)\n\t\t\tdev_warn(cs35l41->dev, \"Cannot Run Firmware, reverting to dsp bypass...\\n\");\n\t} else {\n\t\tdev_dbg(cs35l41->dev, \"Firmware Autostart is disabled.\\n\");\n\t}\n\n\tret = cs35l41_create_controls(cs35l41);\n\n\tcomps->playback_hook = cs35l41_hda_playback_hook;\n\tcomps->pre_playback_hook = cs35l41_hda_pre_playback_hook;\n\tcomps->post_playback_hook = cs35l41_hda_post_playback_hook;\n\n\tmutex_unlock(&cs35l41->fw_mutex);\n\n\tsleep_flags = lock_system_sleep();\n\tif (!device_link_add(&comps->codec->core.dev, cs35l41->dev, DL_FLAG_STATELESS))\n\t\tdev_warn(dev, \"Unable to create device link\\n\");\n\tunlock_system_sleep(sleep_flags);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tdev_info(cs35l41->dev,\n\t\t \"CS35L41 Bound - SSID: %s, BST: %d, VSPK: %d, CH: %c, FW EN: %d, SPKID: %d\\n\",\n\t\t cs35l41->acpi_subsystem_id, cs35l41->hw_cfg.bst_type,\n\t\t cs35l41->hw_cfg.gpio1.func == CS35l41_VSPK_SWITCH,\n\t\t cs35l41->hw_cfg.spk_pos ? 'R' : 'L',\n\t\t cs35l41->firmware_running, cs35l41->speaker_id);\n\n\treturn ret;\n}\n\nstatic void cs35l41_hda_unbind(struct device *dev, struct device *master, void *master_data)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tunsigned int sleep_flags;\n\n\tif (comps[cs35l41->index].dev == dev) {\n\t\tmemset(&comps[cs35l41->index], 0, sizeof(*comps));\n\t\tsleep_flags = lock_system_sleep();\n\t\tdevice_link_remove(&comps->codec->core.dev, cs35l41->dev);\n\t\tunlock_system_sleep(sleep_flags);\n\t}\n}\n\nstatic const struct component_ops cs35l41_hda_comp_ops = {\n\t.bind = cs35l41_hda_bind,\n\t.unbind = cs35l41_hda_unbind,\n};\n\nstatic irqreturn_t cs35l41_bst_short_err(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"LBST Error\\n\");\n\tset_bit(CS35L41_BST_SHORT_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l41_bst_dcm_uvp_err(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"DCM VBST Under Voltage Error\\n\");\n\tset_bit(CS35L41_BST_UVP_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l41_bst_ovp_err(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"VBST Over Voltage error\\n\");\n\tset_bit(CS35L41_BST_OVP_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l41_temp_err(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"Over temperature error\\n\");\n\tset_bit(CS35L41_TEMP_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l41_temp_warn(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"Over temperature warning\\n\");\n\tset_bit(CS35L41_TEMP_WARN_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l41_amp_short(int irq, void *data)\n{\n\tstruct cs35l41_hda *cs35l41 = data;\n\n\tdev_crit_ratelimited(cs35l41->dev, \"Amp short error\\n\");\n\tset_bit(CS35L41_AMP_SHORT_ERR_RLS_SHIFT, &cs35l41->irq_errors);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct cs35l41_irq cs35l41_irqs[] = {\n\tCS35L41_IRQ(BST_OVP_ERR, \"Boost Overvoltage Error\", cs35l41_bst_ovp_err),\n\tCS35L41_IRQ(BST_DCM_UVP_ERR, \"Boost Undervoltage Error\", cs35l41_bst_dcm_uvp_err),\n\tCS35L41_IRQ(BST_SHORT_ERR, \"Boost Inductor Short Error\", cs35l41_bst_short_err),\n\tCS35L41_IRQ(TEMP_WARN, \"Temperature Warning\", cs35l41_temp_warn),\n\tCS35L41_IRQ(TEMP_ERR, \"Temperature Error\", cs35l41_temp_err),\n\tCS35L41_IRQ(AMP_SHORT_ERR, \"Amp Short\", cs35l41_amp_short),\n};\n\nstatic const struct regmap_irq cs35l41_reg_irqs[] = {\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, BST_OVP_ERR),\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, BST_DCM_UVP_ERR),\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, BST_SHORT_ERR),\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, TEMP_WARN),\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, TEMP_ERR),\n\tCS35L41_REG_IRQ(IRQ1_STATUS1, AMP_SHORT_ERR),\n};\n\nstatic struct regmap_irq_chip cs35l41_regmap_irq_chip = {\n\t.name = \"cs35l41 IRQ1 Controller\",\n\t.status_base = CS35L41_IRQ1_STATUS1,\n\t.mask_base = CS35L41_IRQ1_MASK1,\n\t.ack_base = CS35L41_IRQ1_STATUS1,\n\t.num_regs = 4,\n\t.irqs = cs35l41_reg_irqs,\n\t.num_irqs = ARRAY_SIZE(cs35l41_reg_irqs),\n\t.runtime_pm = true,\n};\n\nstatic int cs35l41_hda_apply_properties(struct cs35l41_hda *cs35l41)\n{\n\tstruct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;\n\tbool using_irq = false;\n\tint irq, irq_pol;\n\tint ret;\n\tint i;\n\n\tif (!cs35l41->hw_cfg.valid)\n\t\treturn -EINVAL;\n\n\tret = cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, hw_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hw_cfg->gpio1.valid) {\n\t\tswitch (hw_cfg->gpio1.func) {\n\t\tcase CS35L41_NOT_USED:\n\t\t\tbreak;\n\t\tcase CS35l41_VSPK_SWITCH:\n\t\t\thw_cfg->gpio1.func = CS35L41_GPIO1_GPIO;\n\t\t\thw_cfg->gpio1.out_en = true;\n\t\t\tbreak;\n\t\tcase CS35l41_SYNC:\n\t\t\thw_cfg->gpio1.func = CS35L41_GPIO1_MDSYNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(cs35l41->dev, \"Invalid function %d for GPIO1\\n\",\n\t\t\t\thw_cfg->gpio1.func);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (hw_cfg->gpio2.valid) {\n\t\tswitch (hw_cfg->gpio2.func) {\n\t\tcase CS35L41_NOT_USED:\n\t\t\tbreak;\n\t\tcase CS35L41_INTERRUPT:\n\t\t\tusing_irq = true;\n\t\t\thw_cfg->gpio2.func = CS35L41_GPIO2_INT_OPEN_DRAIN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(cs35l41->dev, \"Invalid GPIO2 function %d\\n\", hw_cfg->gpio2.func);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tirq_pol = cs35l41_gpio_config(cs35l41->regmap, hw_cfg);\n\n\tif (cs35l41->irq && using_irq) {\n\t\tret = devm_regmap_add_irq_chip(cs35l41->dev, cs35l41->regmap, cs35l41->irq,\n\t\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED | irq_pol,\n\t\t\t\t\t       0, &cs35l41_regmap_irq_chip, &cs35l41->irq_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cs35l41_irqs); i++) {\n\t\t\tirq = regmap_irq_get_virq(cs35l41->irq_data, cs35l41_irqs[i].irq);\n\t\t\tif (irq < 0)\n\t\t\t\treturn irq;\n\n\t\t\tret = devm_request_threaded_irq(cs35l41->dev, irq, NULL,\n\t\t\t\t\t\t\tcs35l41_irqs[i].handler,\n\t\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | irq_pol,\n\t\t\t\t\t\t\tcs35l41_irqs[i].name, cs35l41);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn cs35l41_hda_channel_map(cs35l41->dev, 0, NULL, 1, &hw_cfg->spk_pos);\n}\n\nint cs35l41_get_speaker_id(struct device *dev, int amp_index, int num_amps, int fixed_gpio_id)\n{\n\tstruct gpio_desc *speaker_id_desc;\n\tint speaker_id = -ENODEV;\n\n\tif (fixed_gpio_id >= 0) {\n\t\tdev_dbg(dev, \"Found Fixed Speaker ID GPIO (index = %d)\\n\", fixed_gpio_id);\n\t\tspeaker_id_desc = gpiod_get_index(dev, NULL, fixed_gpio_id, GPIOD_IN);\n\t\tif (IS_ERR(speaker_id_desc)) {\n\t\t\tspeaker_id = PTR_ERR(speaker_id_desc);\n\t\t\treturn speaker_id;\n\t\t}\n\t\tspeaker_id = gpiod_get_value_cansleep(speaker_id_desc);\n\t\tgpiod_put(speaker_id_desc);\n\t\tdev_dbg(dev, \"Speaker ID = %d\\n\", speaker_id);\n\t} else {\n\t\tint base_index;\n\t\tint gpios_per_amp;\n\t\tint count;\n\t\tint tmp;\n\t\tint i;\n\n\t\tcount = gpiod_count(dev, \"spk-id\");\n\t\tif (count > 0) {\n\t\t\tspeaker_id = 0;\n\t\t\tgpios_per_amp = count / num_amps;\n\t\t\tbase_index = gpios_per_amp * amp_index;\n\n\t\t\tif (count % num_amps)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_dbg(dev, \"Found %d Speaker ID GPIOs per Amp\\n\", gpios_per_amp);\n\n\t\t\tfor (i = 0; i < gpios_per_amp; i++) {\n\t\t\t\tspeaker_id_desc = gpiod_get_index(dev, \"spk-id\", i + base_index,\n\t\t\t\t\t\t\t\t  GPIOD_IN);\n\t\t\t\tif (IS_ERR(speaker_id_desc)) {\n\t\t\t\t\tspeaker_id = PTR_ERR(speaker_id_desc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmp = gpiod_get_value_cansleep(speaker_id_desc);\n\t\t\t\tgpiod_put(speaker_id_desc);\n\t\t\t\tif (tmp < 0) {\n\t\t\t\t\tspeaker_id = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspeaker_id |= tmp << i;\n\t\t\t}\n\t\t\tdev_dbg(dev, \"Speaker ID = %d\\n\", speaker_id);\n\t\t}\n\t}\n\treturn speaker_id;\n}\n\nstatic int cs35l41_hda_read_acpi(struct cs35l41_hda *cs35l41, const char *hid, int id)\n{\n\tstruct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;\n\tu32 values[HDA_MAX_COMPONENTS];\n\tstruct acpi_device *adev;\n\tstruct device *physdev;\n\tconst char *sub;\n\tchar *property;\n\tsize_t nval;\n\tint i, ret;\n\n\tadev = acpi_dev_get_first_match_dev(hid, NULL, -1);\n\tif (!adev) {\n\t\tdev_err(cs35l41->dev, \"Failed to find an ACPI device for %s\\n\", hid);\n\t\treturn -ENODEV;\n\t}\n\n\tphysdev = get_device(acpi_get_first_physical_node(adev));\n\tacpi_dev_put(adev);\n\n\tsub = acpi_get_subsystem_id(ACPI_HANDLE(physdev));\n\tif (IS_ERR(sub))\n\t\tsub = NULL;\n\tcs35l41->acpi_subsystem_id = sub;\n\n\tret = cs35l41_add_dsd_properties(cs35l41, physdev, id, hid);\n\tif (!ret) {\n\t\tdev_info(cs35l41->dev, \"Using extra _DSD properties, bypassing _DSD in ACPI\\n\");\n\t\tgoto put_physdev;\n\t}\n\n\tproperty = \"cirrus,dev-index\";\n\tret = device_property_count_u32(physdev, property);\n\tif (ret <= 0)\n\t\tgoto err;\n\n\tif (ret > ARRAY_SIZE(values)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tnval = ret;\n\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret)\n\t\tgoto err;\n\n\tcs35l41->index = -1;\n\tfor (i = 0; i < nval; i++) {\n\t\tif (values[i] == id) {\n\t\t\tcs35l41->index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cs35l41->index == -1) {\n\t\tdev_err(cs35l41->dev, \"No index found in %s\\n\", property);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tcs35l41->reset_gpio = fwnode_gpiod_get_index(acpi_fwnode_handle(adev), \"reset\", cs35l41->index,\n\t\t\t\t\t\t     GPIOD_OUT_LOW, \"cs35l41-reset\");\n\n\tproperty = \"cirrus,speaker-position\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret)\n\t\tgoto err;\n\thw_cfg->spk_pos = values[cs35l41->index];\n\n\tcs35l41->channel_index = 0;\n\tfor (i = 0; i < cs35l41->index; i++)\n\t\tif (values[i] == hw_cfg->spk_pos)\n\t\t\tcs35l41->channel_index++;\n\n\tproperty = \"cirrus,gpio1-func\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret)\n\t\tgoto err;\n\thw_cfg->gpio1.func = values[cs35l41->index];\n\thw_cfg->gpio1.valid = true;\n\n\tproperty = \"cirrus,gpio2-func\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret)\n\t\tgoto err;\n\thw_cfg->gpio2.func = values[cs35l41->index];\n\thw_cfg->gpio2.valid = true;\n\n\tproperty = \"cirrus,boost-peak-milliamp\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret == 0)\n\t\thw_cfg->bst_ipk = values[cs35l41->index];\n\telse\n\t\thw_cfg->bst_ipk = -1;\n\n\tproperty = \"cirrus,boost-ind-nanohenry\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret == 0)\n\t\thw_cfg->bst_ind = values[cs35l41->index];\n\telse\n\t\thw_cfg->bst_ind = -1;\n\n\tproperty = \"cirrus,boost-cap-microfarad\";\n\tret = device_property_read_u32_array(physdev, property, values, nval);\n\tif (ret == 0)\n\t\thw_cfg->bst_cap = values[cs35l41->index];\n\telse\n\t\thw_cfg->bst_cap = -1;\n\n\tcs35l41->speaker_id = cs35l41_get_speaker_id(physdev, cs35l41->index, nval, -1);\n\n\tif (hw_cfg->bst_ind > 0 || hw_cfg->bst_cap > 0 || hw_cfg->bst_ipk > 0)\n\t\thw_cfg->bst_type = CS35L41_INT_BOOST;\n\telse\n\t\thw_cfg->bst_type = CS35L41_EXT_BOOST;\n\n\thw_cfg->valid = true;\n\tput_device(physdev);\n\n\treturn 0;\n\nerr:\n\tdev_err(cs35l41->dev, \"Failed property %s: %d\\n\", property, ret);\n\thw_cfg->valid = false;\n\thw_cfg->gpio1.valid = false;\n\thw_cfg->gpio2.valid = false;\nput_physdev:\n\tput_device(physdev);\n\n\treturn ret;\n}\n\nint cs35l41_hda_probe(struct device *dev, const char *device_name, int id, int irq,\n\t\t      struct regmap *regmap)\n{\n\tunsigned int int_sts, regid, reg_revid, mtl_revid, chipid, int_status;\n\tstruct cs35l41_hda *cs35l41;\n\tint ret;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs35l41_irqs) != ARRAY_SIZE(cs35l41_reg_irqs));\n\tBUILD_BUG_ON(ARRAY_SIZE(cs35l41_irqs) != CS35L41_NUM_IRQ);\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tcs35l41 = devm_kzalloc(dev, sizeof(*cs35l41), GFP_KERNEL);\n\tif (!cs35l41)\n\t\treturn -ENOMEM;\n\n\tcs35l41->dev = dev;\n\tcs35l41->irq = irq;\n\tcs35l41->regmap = regmap;\n\tdev_set_drvdata(dev, cs35l41);\n\n\tret = cs35l41_hda_read_acpi(cs35l41, device_name, id);\n\tif (ret)\n\t\treturn dev_err_probe(cs35l41->dev, ret, \"Platform not supported\\n\");\n\n\tif (IS_ERR(cs35l41->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l41->reset_gpio);\n\t\tcs35l41->reset_gpio = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_info(cs35l41->dev, \"Reset line busy, assuming shared reset\\n\");\n\t\t} else {\n\t\t\tdev_err_probe(cs35l41->dev, ret, \"Failed to get reset GPIO\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (cs35l41->reset_gpio) {\n\t\tusleep_range(2000, 2100);\n\t\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 1);\n\t}\n\n\tusleep_range(2000, 2100);\n\n\tret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS4, int_status,\n\t\t\t\t       int_status & CS35L41_OTP_BOOT_DONE, 1000, 100000);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Failed waiting for OTP_BOOT_DONE: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS3, &int_sts);\n\tif (ret || (int_sts & CS35L41_OTP_BOOT_ERR)) {\n\t\tdev_err(cs35l41->dev, \"OTP Boot status %x error: %d\\n\",\n\t\t\tint_sts & CS35L41_OTP_BOOT_ERR, ret);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l41->regmap, CS35L41_DEVID, &regid);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Get Device ID failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l41->regmap, CS35L41_REVID, &reg_revid);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Get Revision ID failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tmtl_revid = reg_revid & CS35L41_MTLREVID_MASK;\n\n\tchipid = (mtl_revid % 2) ? CS35L41R_CHIP_ID : CS35L41_CHIP_ID;\n\tif (regid != chipid) {\n\t\tdev_err(cs35l41->dev, \"CS35L41 Device ID (%X). Expected ID %X\\n\", regid, chipid);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cs35l41_register_errata_patch(cs35l41->dev, cs35l41->regmap, reg_revid);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cs35l41_otp_unpack(cs35l41->dev, cs35l41->regmap);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"OTP Unpack failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_multi_reg_write(cs35l41->regmap, cs35l41_hda_mute,\n\t\t\t\t     ARRAY_SIZE(cs35l41_hda_mute));\n\tif (ret)\n\t\tgoto err;\n\n\tINIT_WORK(&cs35l41->fw_load_work, cs35l41_fw_load_work);\n\tmutex_init(&cs35l41->fw_mutex);\n\n\tpm_runtime_set_autosuspend_delay(cs35l41->dev, 3000);\n\tpm_runtime_use_autosuspend(cs35l41->dev);\n\tpm_runtime_mark_last_busy(cs35l41->dev);\n\tpm_runtime_set_active(cs35l41->dev);\n\tpm_runtime_get_noresume(cs35l41->dev);\n\tpm_runtime_enable(cs35l41->dev);\n\n\tret = cs35l41_hda_apply_properties(cs35l41);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tpm_runtime_put_autosuspend(cs35l41->dev);\n\n\tret = component_add(cs35l41->dev, &cs35l41_hda_comp_ops);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Register component failed: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\tdev_info(cs35l41->dev, \"Cirrus Logic CS35L41 (%x), Revision: %02X\\n\", regid, reg_revid);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_dont_use_autosuspend(cs35l41->dev);\n\tpm_runtime_disable(cs35l41->dev);\n\tpm_runtime_put_noidle(cs35l41->dev);\n\nerr:\n\tif (cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type))\n\t\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 0);\n\tgpiod_put(cs35l41->reset_gpio);\n\tkfree(cs35l41->acpi_subsystem_id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l41_hda_probe, SND_HDA_SCODEC_CS35L41);\n\nvoid cs35l41_hda_remove(struct device *dev)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(cs35l41->dev);\n\tpm_runtime_dont_use_autosuspend(cs35l41->dev);\n\tpm_runtime_disable(cs35l41->dev);\n\n\tif (cs35l41->halo_initialized)\n\t\tcs35l41_remove_dsp(cs35l41);\n\n\tcomponent_del(cs35l41->dev, &cs35l41_hda_comp_ops);\n\n\tpm_runtime_put_noidle(cs35l41->dev);\n\n\tif (cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type))\n\t\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 0);\n\tgpiod_put(cs35l41->reset_gpio);\n\tkfree(cs35l41->acpi_subsystem_id);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l41_hda_remove, SND_HDA_SCODEC_CS35L41);\n\nconst struct dev_pm_ops cs35l41_hda_pm_ops = {\n\tRUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume,\n\t\t       cs35l41_runtime_idle)\n\t.prepare = cs35l41_system_suspend_prep,\n\tSYSTEM_SLEEP_PM_OPS(cs35l41_system_suspend, cs35l41_system_resume)\n};\nEXPORT_SYMBOL_NS_GPL(cs35l41_hda_pm_ops, SND_HDA_SCODEC_CS35L41);\n\nMODULE_DESCRIPTION(\"CS35L41 HDA Driver\");\nMODULE_IMPORT_NS(SND_HDA_CS_DSP_CONTROLS);\nMODULE_AUTHOR(\"Lucas Tanure, Cirrus Logic Inc, <tanureal@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(FW_CS_DSP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}