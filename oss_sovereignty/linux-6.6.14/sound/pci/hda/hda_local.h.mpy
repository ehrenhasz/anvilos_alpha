{
  "module_name": "hda_local.h",
  "hash_id": "fdf72607222265635cd5b6418efd6c1706404538f067fe8efa4a45dfca86b7e4",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/hda/hda_local.h",
  "human_readable_source": " \n \n\n#ifndef __SOUND_HDA_LOCAL_H\n#define __SOUND_HDA_LOCAL_H\n\n \n#define HDA_SUBDEV_NID_FLAG\t(1U << 31)\n#define HDA_SUBDEV_AMP_FLAG\t(1U << 30)\n\n \n#define HDA_COMPOSE_AMP_VAL_OFS(nid,chs,idx,dir,ofs)\t\t\\\n\t((nid) | ((chs)<<16) | ((dir)<<18) | ((idx)<<19) | ((ofs)<<23))\n#define HDA_AMP_VAL_MIN_MUTE (1<<29)\n#define HDA_COMPOSE_AMP_VAL(nid,chs,idx,dir) \\\n\tHDA_COMPOSE_AMP_VAL_OFS(nid, chs, idx, dir, 0)\n \n#define HDA_CODEC_VOLUME_MONO_IDX(xname, xcidx, nid, channel, xindex, dir, flags) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx,  \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t  \t    SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t  \t    SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \\\n\t  .info = snd_hda_mixer_amp_volume_info, \\\n\t  .get = snd_hda_mixer_amp_volume_get, \\\n\t  .put = snd_hda_mixer_amp_volume_put, \\\n\t  .tlv = { .c = snd_hda_mixer_amp_tlv },\t\t\\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, dir) | flags }\n \n#define HDA_CODEC_VOLUME_IDX(xname, xcidx, nid, xindex, direction) \\\n\tHDA_CODEC_VOLUME_MONO_IDX(xname, xcidx, nid, 3, xindex, direction, 0)\n \n#define HDA_CODEC_VOLUME_MONO(xname, nid, channel, xindex, direction) \\\n\tHDA_CODEC_VOLUME_MONO_IDX(xname, 0, nid, channel, xindex, direction, 0)\n \n#define HDA_CODEC_VOLUME(xname, nid, xindex, direction) \\\n\tHDA_CODEC_VOLUME_MONO(xname, nid, 3, xindex, direction)\n \n#define HDA_CODEC_VOLUME_MIN_MUTE(xname, nid, xindex, direction) \\\n\tHDA_CODEC_VOLUME_MONO_IDX(xname, 0, nid, 3, xindex, direction, \\\n\t\t\t\t  HDA_AMP_VAL_MIN_MUTE)\n \n#define HDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, channel, xindex, direction) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx, \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .info = snd_hda_mixer_amp_switch_info, \\\n\t  .get = snd_hda_mixer_amp_switch_get, \\\n\t  .put = snd_hda_mixer_amp_switch_put, \\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, direction) }\n \n#define HDA_CODEC_MUTE_IDX(xname, xcidx, nid, xindex, direction) \\\n\tHDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, 3, xindex, direction)\n \n#define HDA_CODEC_MUTE_MONO(xname, nid, channel, xindex, direction) \\\n\tHDA_CODEC_MUTE_MONO_IDX(xname, 0, nid, channel, xindex, direction)\n \n#define HDA_CODEC_MUTE(xname, nid, xindex, direction) \\\n\tHDA_CODEC_MUTE_MONO(xname, nid, 3, xindex, direction)\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\n \n#define HDA_CODEC_MUTE_BEEP_MONO_IDX(xname, xcidx, nid, channel, xindex, direction) \\\n\t{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx, \\\n\t  .subdevice = HDA_SUBDEV_AMP_FLAG, \\\n\t  .info = snd_hda_mixer_amp_switch_info, \\\n\t  .get = snd_hda_mixer_amp_switch_get_beep, \\\n\t  .put = snd_hda_mixer_amp_switch_put_beep, \\\n\t  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, direction) }\n#else\n \n#define HDA_CODEC_MUTE_BEEP_MONO_IDX(xname, xcidx, nid, ch, xidx, dir) \\\n\tHDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, ch, xidx, dir)\n#endif  \n \n#define HDA_CODEC_MUTE_BEEP_MONO(xname, nid, channel, xindex, direction) \\\n\tHDA_CODEC_MUTE_BEEP_MONO_IDX(xname, 0, nid, channel, xindex, direction)\n \n#define HDA_CODEC_MUTE_BEEP(xname, nid, xindex, direction) \\\n\tHDA_CODEC_MUTE_BEEP_MONO(xname, nid, 3, xindex, direction)\n\nextern const char *snd_hda_pcm_type_name[];\n\nint snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo);\nint snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\nint snd_hda_mixer_amp_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\nint snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t  unsigned int size, unsigned int __user *_tlv);\nint snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo);\nint snd_hda_mixer_amp_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\nint snd_hda_mixer_amp_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol);\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\nint snd_hda_mixer_amp_switch_get_beep(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol);\nint snd_hda_mixer_amp_switch_put_beep(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol);\n#endif\n \n#define snd_hda_codec_amp_read(codec, nid, ch, dir, idx) \\\n\tsnd_hdac_regmap_get_amp(&(codec)->core, nid, ch, dir, idx)\nint snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t     int ch, int dir, int idx, int mask, int val);\nint snd_hda_codec_amp_stereo(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t     int direction, int idx, int mask, int val);\nint snd_hda_codec_amp_init(struct hda_codec *codec, hda_nid_t nid, int ch,\n\t\t\t   int direction, int idx, int mask, int val);\nint snd_hda_codec_amp_init_stereo(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t  int dir, int idx, int mask, int val);\nvoid snd_hda_set_vmaster_tlv(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t     unsigned int *tlv);\nstruct snd_kcontrol *snd_hda_find_mixer_ctl(struct hda_codec *codec,\n\t\t\t\t\t    const char *name);\nint __snd_hda_add_vmaster(struct hda_codec *codec, char *name,\n\t\t\t  unsigned int *tlv, const char * const *followers,\n\t\t\t  const char *suffix, bool init_follower_vol,\n\t\t\t  unsigned int access, struct snd_kcontrol **ctl_ret);\n#define snd_hda_add_vmaster(codec, name, tlv, followers, suffix, access) \\\n\t__snd_hda_add_vmaster(codec, name, tlv, followers, suffix, true, access, NULL)\nint snd_hda_codec_reset(struct hda_codec *codec);\nvoid snd_hda_codec_disconnect_pcms(struct hda_codec *codec);\n\n#define snd_hda_regmap_sync(codec)\tsnd_hdac_regmap_sync(&(codec)->core)\n\nstruct hda_vmaster_mute_hook {\n\t \n\tstruct snd_kcontrol *sw_kctl;\n\tvoid (*hook)(void *, int);\n\t \n\tstruct hda_codec *codec;\n};\n\nint snd_hda_add_vmaster_hook(struct hda_codec *codec,\n\t\t\t     struct hda_vmaster_mute_hook *hook);\nvoid snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook);\n\n \n#define HDA_AMP_MUTE\t0x80\n#define HDA_AMP_UNMUTE\t0x00\n#define HDA_AMP_VOLMASK\t0x7f\n\n \nint snd_hda_create_dig_out_ctls(struct hda_codec *codec,\n\t\t\t\thda_nid_t associated_nid,\n\t\t\t\thda_nid_t cvt_nid, int type);\n#define snd_hda_create_spdif_out_ctls(codec, anid, cnid) \\\n\tsnd_hda_create_dig_out_ctls(codec, anid, cnid, HDA_PCM_TYPE_SPDIF)\nint snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid);\n\n \n#define HDA_MAX_NUM_INPUTS\t36\nstruct hda_input_mux_item {\n\tchar label[32];\n\tunsigned int index;\n};\nstruct hda_input_mux {\n\tunsigned int num_items;\n\tstruct hda_input_mux_item items[HDA_MAX_NUM_INPUTS];\n};\n\nint snd_hda_input_mux_info(const struct hda_input_mux *imux,\n\t\t\t   struct snd_ctl_elem_info *uinfo);\nint snd_hda_input_mux_put(struct hda_codec *codec,\n\t\t\t  const struct hda_input_mux *imux,\n\t\t\t  struct snd_ctl_elem_value *ucontrol, hda_nid_t nid,\n\t\t\t  unsigned int *cur_val);\nint snd_hda_add_imux_item(struct hda_codec *codec,\n\t\t\t  struct hda_input_mux *imux, const char *label,\n\t\t\t  int index, int *type_idx);\n\n \n\nenum { HDA_FRONT, HDA_REAR, HDA_CLFE, HDA_SIDE };  \nenum { HDA_DIG_NONE, HDA_DIG_EXCLUSIVE, HDA_DIG_ANALOG_DUP };  \n\n#define HDA_MAX_OUTS\t5\n\nstruct hda_multi_out {\n\tint num_dacs;\t\t \n\tconst hda_nid_t *dac_nids;\t \n\thda_nid_t hp_nid;\t \n\thda_nid_t hp_out_nid[HDA_MAX_OUTS];\t \n\thda_nid_t extra_out_nid[HDA_MAX_OUTS];\t \n\thda_nid_t dig_out_nid;\t \n\tconst hda_nid_t *follower_dig_outs;\n\tint max_channels;\t \n\tint dig_out_used;\t \n\tint no_share_stream;\t \n\tint share_spdif;\t \n\t \n\tunsigned int analog_rates;\n\tunsigned int analog_maxbps;\n\tu64 analog_formats;\n\tunsigned int spdif_rates;\n\tunsigned int spdif_maxbps;\n\tu64 spdif_formats;\n};\n\nint snd_hda_create_spdif_share_sw(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout);\nint snd_hda_multi_out_dig_open(struct hda_codec *codec,\n\t\t\t       struct hda_multi_out *mout);\nint snd_hda_multi_out_dig_close(struct hda_codec *codec,\n\t\t\t\tstruct hda_multi_out *mout);\nint snd_hda_multi_out_dig_prepare(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout,\n\t\t\t\t  unsigned int stream_tag,\n\t\t\t\t  unsigned int format,\n\t\t\t\t  struct snd_pcm_substream *substream);\nint snd_hda_multi_out_dig_cleanup(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout);\nint snd_hda_multi_out_analog_open(struct hda_codec *codec,\n\t\t\t\t  struct hda_multi_out *mout,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct hda_pcm_stream *hinfo);\nint snd_hda_multi_out_analog_prepare(struct hda_codec *codec,\n\t\t\t\t     struct hda_multi_out *mout,\n\t\t\t\t     unsigned int stream_tag,\n\t\t\t\t     unsigned int format,\n\t\t\t\t     struct snd_pcm_substream *substream);\nint snd_hda_multi_out_analog_cleanup(struct hda_codec *codec,\n\t\t\t\t     struct hda_multi_out *mout);\n\n \n#ifdef CONFIG_SND_PROC_FS\nint snd_hda_codec_proc_new(struct hda_codec *codec);\n#else\nstatic inline int snd_hda_codec_proc_new(struct hda_codec *codec) { return 0; }\n#endif\n\n#define SND_PRINT_BITS_ADVISED_BUFSIZE\t16\nvoid snd_print_pcm_bits(int pcm, char *buf, int buflen);\n\n \nint snd_hda_add_new_ctls(struct hda_codec *codec,\n\t\t\t const struct snd_kcontrol_new *knew);\n\n \n\nstruct hda_pintbl {\n\thda_nid_t nid;\n\tu32 val;\n};\n\nstruct hda_model_fixup {\n\tconst int id;\n\tconst char *name;\n};\n\nstruct hda_fixup {\n\tint type;\n\tbool chained:1;\t\t \n\tbool chained_before:1;\t \n\tint chain_id;\n\tunion {\n\t\tconst struct hda_pintbl *pins;\n\t\tconst struct hda_verb *verbs;\n\t\tvoid (*func)(struct hda_codec *codec,\n\t\t\t     const struct hda_fixup *fix,\n\t\t\t     int action);\n\t} v;\n};\n\nstruct snd_hda_pin_quirk {\n\tunsigned int codec;              \n\tunsigned short subvendor;\t \n\tconst struct hda_pintbl *pins;   \n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tconst char *name;\n#endif\n\tint value;\t\t\t \n};\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\n#define SND_HDA_PIN_QUIRK(_codec, _subvendor, _name, _value, _pins...) \\\n\t{ .codec = _codec,\\\n\t  .subvendor = _subvendor,\\\n\t  .name = _name,\\\n\t  .value = _value,\\\n\t  .pins = (const struct hda_pintbl[]) { _pins, {0, 0}} \\\n\t}\n#else\n\n#define SND_HDA_PIN_QUIRK(_codec, _subvendor, _name, _value, _pins...) \\\n\t{ .codec = _codec,\\\n\t  .subvendor = _subvendor,\\\n\t  .value = _value,\\\n\t  .pins = (const struct hda_pintbl[]) { _pins, {0, 0}} \\\n\t}\n\n#endif\n\n#define HDA_FIXUP_ID_NOT_SET -1\n#define HDA_FIXUP_ID_NO_FIXUP -2\n\n \nenum {\n\tHDA_FIXUP_INVALID,\n\tHDA_FIXUP_PINS,\n\tHDA_FIXUP_VERBS,\n\tHDA_FIXUP_FUNC,\n\tHDA_FIXUP_PINCTLS,\n};\n\n \nenum {\n\tHDA_FIXUP_ACT_PRE_PROBE,\n\tHDA_FIXUP_ACT_PROBE,\n\tHDA_FIXUP_ACT_INIT,\n\tHDA_FIXUP_ACT_BUILD,\n\tHDA_FIXUP_ACT_FREE,\n};\n\nint snd_hda_add_verbs(struct hda_codec *codec, const struct hda_verb *list);\nvoid snd_hda_apply_verbs(struct hda_codec *codec);\nvoid snd_hda_apply_pincfgs(struct hda_codec *codec,\n\t\t\t   const struct hda_pintbl *cfg);\nvoid snd_hda_apply_fixup(struct hda_codec *codec, int action);\nvoid __snd_hda_apply_fixup(struct hda_codec *codec, int id, int action, int depth);\nvoid snd_hda_pick_fixup(struct hda_codec *codec,\n\t\t\tconst struct hda_model_fixup *models,\n\t\t\tconst struct snd_pci_quirk *quirk,\n\t\t\tconst struct hda_fixup *fixlist);\nvoid snd_hda_pick_pin_fixup(struct hda_codec *codec,\n\t\t\t    const struct snd_hda_pin_quirk *pin_quirk,\n\t\t\t    const struct hda_fixup *fixlist,\n\t\t\t    bool match_all_pins);\n\n \n#define get_defcfg_connect(cfg) \\\n\t((cfg & AC_DEFCFG_PORT_CONN) >> AC_DEFCFG_PORT_CONN_SHIFT)\n#define get_defcfg_association(cfg) \\\n\t((cfg & AC_DEFCFG_DEF_ASSOC) >> AC_DEFCFG_ASSOC_SHIFT)\n#define get_defcfg_location(cfg) \\\n\t((cfg & AC_DEFCFG_LOCATION) >> AC_DEFCFG_LOCATION_SHIFT)\n#define get_defcfg_sequence(cfg) \\\n\t(cfg & AC_DEFCFG_SEQUENCE)\n#define get_defcfg_device(cfg) \\\n\t((cfg & AC_DEFCFG_DEVICE) >> AC_DEFCFG_DEVICE_SHIFT)\n#define get_defcfg_misc(cfg) \\\n\t((cfg & AC_DEFCFG_MISC) >> AC_DEFCFG_MISC_SHIFT)\n\n \n#define AMP_IN_MUTE(idx)\t(0x7080 | ((idx)<<8))\n#define AMP_IN_UNMUTE(idx)\t(0x7000 | ((idx)<<8))\n#define AMP_OUT_MUTE\t\t0xb080\n#define AMP_OUT_UNMUTE\t\t0xb000\n#define AMP_OUT_ZERO\t\t0xb000\n \n#define PIN_IN\t\t\t(AC_PINCTL_IN_EN)\n#define PIN_VREFHIZ\t\t(AC_PINCTL_IN_EN | AC_PINCTL_VREF_HIZ)\n#define PIN_VREF50\t\t(AC_PINCTL_IN_EN | AC_PINCTL_VREF_50)\n#define PIN_VREFGRD\t\t(AC_PINCTL_IN_EN | AC_PINCTL_VREF_GRD)\n#define PIN_VREF80\t\t(AC_PINCTL_IN_EN | AC_PINCTL_VREF_80)\n#define PIN_VREF100\t\t(AC_PINCTL_IN_EN | AC_PINCTL_VREF_100)\n#define PIN_OUT\t\t\t(AC_PINCTL_OUT_EN)\n#define PIN_HP\t\t\t(AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN)\n#define PIN_HP_AMP\t\t(AC_PINCTL_HP_EN)\n\nunsigned int snd_hda_get_default_vref(struct hda_codec *codec, hda_nid_t pin);\nunsigned int snd_hda_correct_pin_ctl(struct hda_codec *codec,\n\t\t\t\t     hda_nid_t pin, unsigned int val);\nint _snd_hda_set_pin_ctl(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t unsigned int val, bool cached);\n\n \nstatic inline int\nsnd_hda_set_pin_ctl(struct hda_codec *codec, hda_nid_t pin, unsigned int val)\n{\n\treturn _snd_hda_set_pin_ctl(codec, pin, val, false);\n}\n\n \nstatic inline int\nsnd_hda_set_pin_ctl_cache(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t  unsigned int val)\n{\n\treturn _snd_hda_set_pin_ctl(codec, pin, val, true);\n}\n\nint snd_hda_codec_get_pin_target(struct hda_codec *codec, hda_nid_t nid);\nint snd_hda_codec_set_pin_target(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t\t unsigned int val);\n\n#define for_each_hda_codec_node(nid, codec) \\\n\tfor ((nid) = (codec)->core.start_nid; (nid) < (codec)->core.end_nid; (nid)++)\n\n \nstatic inline void snd_hda_codec_allow_unsol_events(struct hda_codec *codec)\n{\n\tcodec->core.dev.power.power_state = PMSG_ON;\n}\n\n \nstatic inline u32 get_wcaps(struct hda_codec *codec, hda_nid_t nid)\n{\n\tif (nid < codec->core.start_nid ||\n\t    nid >= codec->core.start_nid + codec->core.num_nodes)\n\t\treturn 0;\n\treturn codec->wcaps[nid - codec->core.start_nid];\n}\n\n \nstatic inline int get_wcaps_type(unsigned int wcaps)\n{\n\tif (!wcaps)\n\t\treturn -1;  \n\treturn (wcaps & AC_WCAP_TYPE) >> AC_WCAP_TYPE_SHIFT;\n}\n\nstatic inline unsigned int get_wcaps_channels(u32 wcaps)\n{\n\tunsigned int chans;\n\n\tchans = (wcaps & AC_WCAP_CHAN_CNT_EXT) >> 13;\n\tchans = ((chans << 1) | 1) + 1;\n\n\treturn chans;\n}\n\nstatic inline void snd_hda_override_wcaps(struct hda_codec *codec,\n\t\t\t\t\t  hda_nid_t nid, u32 val)\n{\n\tif (nid >= codec->core.start_nid &&\n\t    nid < codec->core.start_nid + codec->core.num_nodes)\n\t\tcodec->wcaps[nid - codec->core.start_nid] = val;\n}\n\nu32 query_amp_caps(struct hda_codec *codec, hda_nid_t nid, int direction);\nint snd_hda_override_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir,\n\t\t\t      unsigned int caps);\n \nstatic inline u32\nsnd_hda_query_pin_caps(struct hda_codec *codec, hda_nid_t nid)\n{\n\treturn snd_hda_param_read(codec, nid, AC_PAR_PIN_CAP);\n\n}\n\n \nstatic inline int\nsnd_hda_override_pin_caps(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  unsigned int caps)\n{\n\treturn snd_hdac_override_parm(&codec->core, nid, AC_PAR_PIN_CAP, caps);\n}\n\nbool snd_hda_check_amp_caps(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t   int dir, unsigned int bits);\n\n#define nid_has_mute(codec, nid, dir) \\\n\tsnd_hda_check_amp_caps(codec, nid, dir, (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE))\n#define nid_has_volume(codec, nid, dir) \\\n\tsnd_hda_check_amp_caps(codec, nid, dir, AC_AMPCAP_NUM_STEPS)\n\n\n \n#define HDA_NID_ITEM_AMP\t(1<<0)\n\nstruct hda_nid_item {\n\tstruct snd_kcontrol *kctl;\n\tunsigned int index;\n\thda_nid_t nid;\n\tunsigned short flags;\n};\n\nint snd_hda_ctl_add(struct hda_codec *codec, hda_nid_t nid,\n\t\t    struct snd_kcontrol *kctl);\nint snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,\n\t\t    unsigned int index, hda_nid_t nid);\nvoid snd_hda_ctls_clear(struct hda_codec *codec);\n\n \n#ifdef CONFIG_SND_HDA_HWDEP\nint snd_hda_create_hwdep(struct hda_codec *codec);\n#else\nstatic inline int snd_hda_create_hwdep(struct hda_codec *codec) { return 0; }\n#endif\n\nvoid snd_hda_sysfs_init(struct hda_codec *codec);\nvoid snd_hda_sysfs_clear(struct hda_codec *codec);\n\nextern const struct attribute_group *snd_hda_dev_attr_groups[];\n\n#ifdef CONFIG_SND_HDA_RECONFIG\nconst char *snd_hda_get_hint(struct hda_codec *codec, const char *key);\nint snd_hda_get_bool_hint(struct hda_codec *codec, const char *key);\nint snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp);\n#else\nstatic inline\nconst char *snd_hda_get_hint(struct hda_codec *codec, const char *key)\n{\n\treturn NULL;\n}\n\nstatic inline\nint snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)\n{\n\treturn -ENOENT;\n}\n\nstatic inline\nint snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)\n{\n\treturn -ENOENT;\n}\n#endif\n\n \n\nvoid snd_hda_schedule_power_save(struct hda_codec *codec);\n\nstruct hda_amp_list {\n\thda_nid_t nid;\n\tunsigned char dir;\n\tunsigned char idx;\n};\n\nstruct hda_loopback_check {\n\tconst struct hda_amp_list *amplist;\n\tint power_on;\n};\n\nint snd_hda_check_amp_list_power(struct hda_codec *codec,\n\t\t\t\t struct hda_loopback_check *check,\n\t\t\t\t hda_nid_t nid);\n\n \nstatic inline bool\nsnd_hda_check_power_state(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t  unsigned int target_state)\n{\n\treturn snd_hdac_check_power_state(&codec->core, nid, target_state);\n}\n\nstatic inline unsigned int snd_hda_sync_power_state(struct hda_codec *codec,\n\t\t\t\t\t\t    hda_nid_t nid,\n\t\t\t\t\t\t    unsigned int target_state)\n{\n\treturn snd_hdac_sync_power_state(&codec->core, nid, target_state);\n}\nunsigned int snd_hda_codec_eapd_power_filter(struct hda_codec *codec,\n\t\t\t\t\t     hda_nid_t nid,\n\t\t\t\t\t     unsigned int power_state);\n\nvoid snd_hda_codec_shutdown(struct hda_codec *codec);\n\n \n \n#define get_amp_nid_(pv)\t((pv) & 0xffff)\n#define get_amp_nid(kc)\t\tget_amp_nid_((kc)->private_value)\n#define get_amp_channels(kc)\t(((kc)->private_value >> 16) & 0x3)\n#define get_amp_direction_(pv)\t(((pv) >> 18) & 0x1)\n#define get_amp_direction(kc)\tget_amp_direction_((kc)->private_value)\n#define get_amp_index_(pv)\t(((pv) >> 19) & 0xf)\n#define get_amp_index(kc)\tget_amp_index_((kc)->private_value)\n#define get_amp_offset(kc)\t(((kc)->private_value >> 23) & 0x3f)\n#define get_amp_min_mute(kc)\t(((kc)->private_value >> 29) & 0x1)\n\n \nint snd_hda_enum_helper_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo,\n\t\t\t     int num_items, const char * const *texts);\n#define snd_hda_enum_bool_helper_info(kcontrol, uinfo) \\\n\tsnd_hda_enum_helper_info(kcontrol, uinfo, 0, NULL)\n\n \nstruct cea_sad {\n\tint\tchannels;\n\tint\tformat;\t\t \n\tint\trates;\n\tint\tsample_bits;\t \n\tint\tmax_bitrate;\t \n\tint\tprofile;\t \n};\n\n#define ELD_FIXED_BYTES\t20\n#define ELD_MAX_SIZE    256\n#define ELD_MAX_MNL\t16\n#define ELD_MAX_SAD\t16\n\n \nstruct parsed_hdmi_eld {\n\t \n\tint\tbaseline_len;\n\tint\teld_ver;\n\tint\tcea_edid_ver;\n\tchar\tmonitor_name[ELD_MAX_MNL + 1];\n\tint\tmanufacture_id;\n\tint\tproduct_id;\n\tu64\tport_id;\n\tint\tsupport_hdcp;\n\tint\tsupport_ai;\n\tint\tconn_type;\n\tint\taud_synch_delay;\n\tint\tspk_alloc;\n\tint\tsad_count;\n\tstruct cea_sad sad[ELD_MAX_SAD];\n};\n\nstruct hdmi_eld {\n\tbool\tmonitor_present;\n\tbool\teld_valid;\n\tint\teld_size;\n\tchar    eld_buffer[ELD_MAX_SIZE];\n\tstruct parsed_hdmi_eld info;\n};\n\nint snd_hdmi_get_eld_size(struct hda_codec *codec, hda_nid_t nid);\nint snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,\n\t\t     unsigned char *buf, int *eld_size);\nint snd_hdmi_parse_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e,\n\t\t       const unsigned char *buf, int size);\nvoid snd_hdmi_show_eld(struct hda_codec *codec, struct parsed_hdmi_eld *e);\nvoid snd_hdmi_eld_update_pcm_info(struct parsed_hdmi_eld *e,\n\t\t\t      struct hda_pcm_stream *hinfo);\n\nint snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,\n\t\t\t unsigned char *buf, int *eld_size,\n\t\t\t bool rev3_or_later);\n\n#ifdef CONFIG_SND_PROC_FS\nvoid snd_hdmi_print_eld_info(struct hdmi_eld *eld,\n\t\t\t     struct snd_info_buffer *buffer,\n\t\t\t     hda_nid_t pin_nid, int dev_id, hda_nid_t cvt_nid);\nvoid snd_hdmi_write_eld_info(struct hdmi_eld *eld,\n\t\t\t     struct snd_info_buffer *buffer);\n#endif\n\n#define SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE 80\nvoid snd_print_channel_allocation(int spk_alloc, char *buf, int buflen);\n\nvoid snd_hda_codec_display_power(struct hda_codec *codec, bool enable);\n\n \n#define codec_err(codec, fmt, args...) \\\n\tdev_err(hda_codec_dev(codec), fmt, ##args)\n#define codec_warn(codec, fmt, args...) \\\n\tdev_warn(hda_codec_dev(codec), fmt, ##args)\n#define codec_info(codec, fmt, args...) \\\n\tdev_info(hda_codec_dev(codec), fmt, ##args)\n#define codec_dbg(codec, fmt, args...) \\\n\tdev_dbg(hda_codec_dev(codec), fmt, ##args)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}