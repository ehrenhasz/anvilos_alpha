{
  "module_name": "quartet.c",
  "hash_id": "1a607fe5a76416decc8017c0b34217a4420baeea4693919a1ca0809f175046ec",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/quartet.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n#include <sound/info.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include <sound/ak4113.h>\n#include \"quartet.h\"\n\nstruct qtet_spec {\n\tstruct ak4113 *ak4113;\n\tunsigned int scr;\t \n\tunsigned int mcr;\t \n\tunsigned int cpld;\t \n};\n\nstruct qtet_kcontrol_private {\n\tunsigned int bit;\n\tvoid (*set_register)(struct snd_ice1712 *ice, unsigned int val);\n\tunsigned int (*get_register)(struct snd_ice1712 *ice);\n\tconst char * const texts[2];\n};\n\nenum {\n\tIN12_SEL = 0,\n\tIN34_SEL,\n\tAIN34_SEL,\n\tCOAX_OUT,\n\tIN12_MON12,\n\tIN12_MON34,\n\tIN34_MON12,\n\tIN34_MON34,\n\tOUT12_MON34,\n\tOUT34_MON12,\n};\n\nstatic const char * const ext_clock_names[3] = {\"IEC958 In\", \"Word Clock 1xFS\",\n\t\"Word Clock 256xFS\"};\n\n \n#define AK4113_ADDR\t\t0x26\t \n\n \n#define AK4620_ADDR\t\t0x02\t \n\n\n \n\n \n#define GPIO_D0\t\t\t(1<<0)\n \n#define GPIO_D1_JACKDTC0\t(1<<1)\n \n#define GPIO_D2_JACKDTC1\t(1<<2)\n \n#define GPIO_D3\t\t\t(1<<3)\n \n#define GPIO_D4_SPI_CDTO\t(1<<4)\n \n#define GPIO_D5_SPI_CCLK\t(1<<5)\n \n#define GPIO_D6_CD\t\t(1<<6)\n \n#define GPIO_D7_DD\t\t(1<<7)\n \n#define GPIO_CPLD_CSN\t\t(1<<8)\n \n#define GPIO_CPLD_RW\t\t(1<<9)\n \n#define GPIO_SPI_CSN0\t\t(1<<10)\n \n#define GPIO_SPI_CSN1\t\t(1<<11)\n \n#define GPIO_EX_GPIOE\t\t(1<<12)\n \n#define GPIO_SCR\t\t(1<<13)\n \n#define GPIO_MCR\t\t(1<<14)\n\n#define GPIO_SPI_ALL\t\t(GPIO_D4_SPI_CDTO | GPIO_D5_SPI_CCLK |\\\n\t\tGPIO_SPI_CSN0 | GPIO_SPI_CSN1)\n\n#define GPIO_DATA_MASK\t\t(GPIO_D0 | GPIO_D1_JACKDTC0 | \\\n\t\tGPIO_D2_JACKDTC1 | GPIO_D3 | \\\n\t\tGPIO_D4_SPI_CDTO | GPIO_D5_SPI_CCLK | \\\n\t\tGPIO_D6_CD | GPIO_D7_DD)\n\n \n \n#define SCR_RELAY\t\tGPIO_D0\n \n#define SCR_PHP_V\t\tGPIO_D1_JACKDTC0\n \n#define SCR_MUTE\t\tGPIO_D2_JACKDTC1\n \n#define SCR_PHP\t\t\tGPIO_D3\n \n#define SCR_AIN12_SEL0\t\tGPIO_D4_SPI_CDTO\n#define SCR_AIN12_SEL1\t\tGPIO_D5_SPI_CCLK\n \n#define SCR_AIN34_SEL\t\tGPIO_D6_CD\n \n#define SCR_CODEC_PDN\t\tGPIO_D7_DD\n\n#define SCR_AIN12_LINE\t\t(0)\n#define SCR_AIN12_MIC\t\t(SCR_AIN12_SEL0)\n#define SCR_AIN12_LOWCUT\t(SCR_AIN12_SEL1 | SCR_AIN12_SEL0)\n\n \n \n#define MCR_IN12_MON12\t\tGPIO_D0\n \n#define MCR_IN12_MON34\t\tGPIO_D1_JACKDTC0\n \n#define MCR_IN34_MON12\t\tGPIO_D2_JACKDTC1\n \n#define MCR_IN34_MON34\t\tGPIO_D3\n \n#define MCR_OUT34_MON12\t\tGPIO_D4_SPI_CDTO\n \n#define MCR_OUT12_MON34\t\tGPIO_D5_SPI_CCLK\n\n \n \n#define CPLD_CKS0\t\tGPIO_D0\n#define CPLD_CKS1\t\tGPIO_D1_JACKDTC0\n#define CPLD_CKS2\t\tGPIO_D2_JACKDTC1\n \n#define CPLD_SYNC_SEL\t\tGPIO_D3\n \n#define CPLD_WORD_SEL\t\tGPIO_D4_SPI_CDTO\n \n#define CPLD_COAX_OUT\t\tGPIO_D5_SPI_CCLK\n \n#define CPLD_IN12_SEL\t\tGPIO_D6_CD\n \n#define CPLD_IN34_SEL\t\tGPIO_D7_DD\n\n \n#define CPLD_CKS_44100HZ\t(0)\n#define CPLD_CKS_48000HZ\t(CPLD_CKS0)\n#define CPLD_CKS_88200HZ\t(CPLD_CKS1)\n#define CPLD_CKS_96000HZ\t(CPLD_CKS1 | CPLD_CKS0)\n#define CPLD_CKS_176400HZ\t(CPLD_CKS2)\n#define CPLD_CKS_192000HZ\t(CPLD_CKS2 | CPLD_CKS0)\n\n#define CPLD_CKS_MASK\t\t(CPLD_CKS0 | CPLD_CKS1 | CPLD_CKS2)\n\n \n \n#define CPLD_EXT_SPDIF\t(0 | CPLD_SYNC_SEL)\n \n#define CPLD_EXT_WORDCLOCK_1FS\t(CPLD_CKS1 | CPLD_SYNC_SEL)\n \n#define CPLD_EXT_WORDCLOCK_256FS\t(CPLD_CKS1 | CPLD_WORD_SEL |\\\n\t\tCPLD_SYNC_SEL)\n\n#define EXT_SPDIF_TYPE\t\t\t0\n#define EXT_WORDCLOCK_1FS_TYPE\t\t1\n#define EXT_WORDCLOCK_256FS_TYPE\t2\n\n#define AK4620_DFS0\t\t(1<<0)\n#define AK4620_DFS1\t\t(1<<1)\n#define AK4620_CKS0\t\t(1<<2)\n#define AK4620_CKS1\t\t(1<<3)\n \n#define AK4620_DFS_REG\t\t0x02\n\n \n#define AK4620_DEEMVOL_REG\t0x03\n#define AK4620_SMUTE\t\t(1<<7)\n\n \nstatic char *get_binary(char *buffer, int value)\n{\n\tint i, j, pos;\n\tpos = 0;\n\tfor (i = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tif (value & (1 << (31-(i*8 + j))))\n\t\t\t\tbuffer[pos] = '1';\n\t\t\telse\n\t\t\t\tbuffer[pos] = '0';\n\t\t\tpos++;\n\t\t}\n\t\tif (i < 3) {\n\t\t\tbuffer[pos] = ' ';\n\t\t\tpos++;\n\t\t}\n\t}\n\tbuffer[pos] = '\\0';\n\treturn buffer;\n}\n\n \nstatic const unsigned int qtet_rates[] = {\n\t44100, 48000, 88200,\n\t96000, 176400, 192000,\n};\n\nstatic const unsigned int cks_vals[] = {\n\tCPLD_CKS_44100HZ, CPLD_CKS_48000HZ, CPLD_CKS_88200HZ,\n\tCPLD_CKS_96000HZ, CPLD_CKS_176400HZ, CPLD_CKS_192000HZ,\n};\n\nstatic const struct snd_pcm_hw_constraint_list qtet_rates_info = {\n\t.count = ARRAY_SIZE(qtet_rates),\n\t.list = qtet_rates,\n\t.mask = 0,\n};\n\nstatic void qtet_ak4113_write(void *private_data, unsigned char reg,\n\t\tunsigned char val)\n{\n\tsnd_vt1724_write_i2c((struct snd_ice1712 *)private_data, AK4113_ADDR,\n\t\t\treg, val);\n}\n\nstatic unsigned char qtet_ak4113_read(void *private_data, unsigned char reg)\n{\n\treturn snd_vt1724_read_i2c((struct snd_ice1712 *)private_data,\n\t\t\tAK4113_ADDR, reg);\n}\n\n\n \n\n \nstatic void qtet_akm_write(struct snd_akm4xxx *ak, int chip,\n\t\tunsigned char addr, unsigned char data)\n{\n\tunsigned int tmp, orig_dir;\n\tint idx;\n\tunsigned int addrdata;\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\n\tif (snd_BUG_ON(chip < 0 || chip >= 4))\n\t\treturn;\n\t \n\torig_dir = ice->gpio.get_dir(ice);\n\tice->gpio.set_dir(ice, orig_dir | GPIO_SPI_ALL);\n\t \n\tice->gpio.set_mask(ice, ~GPIO_SPI_ALL);\n\n\ttmp = ice->gpio.get_data(ice);\n\t \n\ttmp |= GPIO_SPI_ALL;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\t \n\tif (chip)\n\t\t \n\t\ttmp &= ~GPIO_SPI_CSN1;\n\telse\n\t\ttmp &= ~GPIO_SPI_CSN0;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\n\t \n\taddrdata = (AK4620_ADDR << 6) | 0x20 | (addr & 0x1f);\n\taddrdata = (addrdata << 8) | data;\n\tfor (idx = 15; idx >= 0; idx--) {\n\t\t \n\t\ttmp &= ~GPIO_D5_SPI_CCLK;\n\t\tice->gpio.set_data(ice, tmp);\n\t\tudelay(100);\n\t\t \n\t\tif (addrdata & (1 << idx))\n\t\t\ttmp |= GPIO_D4_SPI_CDTO;\n\t\telse\n\t\t\ttmp &= ~GPIO_D4_SPI_CDTO;\n\t\tice->gpio.set_data(ice, tmp);\n\t\tudelay(100);\n\t\t \n\t\ttmp |= GPIO_D5_SPI_CCLK;\n\t\tice->gpio.set_data(ice, tmp);\n\t\tudelay(100);\n\t}\n\t \n\ttmp |= GPIO_SPI_ALL;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\n\t \n\tice->gpio.set_mask(ice, 0xffffff);\n\t \n\tice->gpio.set_dir(ice, orig_dir);\n}\n\nstatic void qtet_akm_set_regs(struct snd_akm4xxx *ak, unsigned char addr,\n\t\tunsigned char mask, unsigned char value)\n{\n\tunsigned char tmp;\n\tint chip;\n\tfor (chip = 0; chip < ak->num_chips; chip++) {\n\t\ttmp = snd_akm4xxx_get(ak, chip, addr);\n\t\t \n\t\ttmp &= ~mask;\n\t\t \n\t\ttmp |= value;\n\t\tsnd_akm4xxx_write(ak, chip, addr, tmp);\n\t}\n}\n\n \nstatic void qtet_akm_set_rate_val(struct snd_akm4xxx *ak, unsigned int rate)\n{\n\tunsigned char ak4620_dfs;\n\n\tif (rate == 0)   \n\t\treturn;\n\n\t \n\tif (rate > 108000)\n\t\tak4620_dfs = AK4620_DFS1 | AK4620_CKS1;\n\telse if (rate > 54000)\n\t\tak4620_dfs = AK4620_DFS0 | AK4620_CKS0;\n\telse\n\t\tak4620_dfs = 0;\n\n\t \n\tqtet_akm_set_regs(ak, AK4620_DFS_REG, AK4620_DFS0 | AK4620_DFS1 |\n\t\t\tAK4620_CKS0 | AK4620_CKS1, ak4620_dfs);\n}\n\n#define AK_CONTROL(xname, xch)\t{ .name = xname, .num_channels = xch }\n\n#define PCM_12_PLAYBACK_VOLUME\t\"PCM 1/2 Playback Volume\"\n#define PCM_34_PLAYBACK_VOLUME\t\"PCM 3/4 Playback Volume\"\n#define PCM_12_CAPTURE_VOLUME\t\"PCM 1/2 Capture Volume\"\n#define PCM_34_CAPTURE_VOLUME\t\"PCM 3/4 Capture Volume\"\n\nstatic const struct snd_akm4xxx_dac_channel qtet_dac[] = {\n\tAK_CONTROL(PCM_12_PLAYBACK_VOLUME, 2),\n\tAK_CONTROL(PCM_34_PLAYBACK_VOLUME, 2),\n};\n\nstatic const struct snd_akm4xxx_adc_channel qtet_adc[] = {\n\tAK_CONTROL(PCM_12_CAPTURE_VOLUME, 2),\n\tAK_CONTROL(PCM_34_CAPTURE_VOLUME, 2),\n};\n\nstatic const struct snd_akm4xxx akm_qtet_dac = {\n\t.type = SND_AK4620,\n\t.num_dacs = 4,\t \n\t.num_adcs = 4,\t \n\t.ops = {\n\t\t.write = qtet_akm_write,\n\t\t.set_rate_val = qtet_akm_set_rate_val,\n\t},\n\t.dac_info = qtet_dac,\n\t.adc_info = qtet_adc,\n};\n\n \n\n\n \nstatic void reg_write(struct snd_ice1712 *ice, unsigned int reg,\n\t\tunsigned int data)\n{\n\tunsigned int tmp;\n\n\tmutex_lock(&ice->gpio_mutex);\n\t \n\t \n\ttmp = 0x00ffff;\n\tice->gpio.set_dir(ice, tmp);\n\t \n\tice->gpio.set_mask(ice, ~(tmp));\n\t \n\ttmp = ice->gpio.get_data(ice);\n\ttmp &= ~GPIO_DATA_MASK;\n\ttmp |= data;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\t \n\ttmp &=  ~GPIO_EX_GPIOE;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\t \n\ttmp &= ~reg;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\t \n\ttmp |= reg;\n\tice->gpio.set_data(ice, tmp);\n\tudelay(100);\n\n\t \n\ttmp |= GPIO_DATA_MASK;\n\tice->gpio.set_data(ice, tmp);\n\t \n\tice->gpio.set_mask(ice, 0xffffff);\n\t \n\tice->gpio.set_dir(ice, 0x00ff00);\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic unsigned int get_scr(struct snd_ice1712 *ice)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treturn spec->scr;\n}\n\nstatic unsigned int get_mcr(struct snd_ice1712 *ice)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treturn spec->mcr;\n}\n\nstatic unsigned int get_cpld(struct snd_ice1712 *ice)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treturn spec->cpld;\n}\n\nstatic void set_scr(struct snd_ice1712 *ice, unsigned int val)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treg_write(ice, GPIO_SCR, val);\n\tspec->scr = val;\n}\n\nstatic void set_mcr(struct snd_ice1712 *ice, unsigned int val)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treg_write(ice, GPIO_MCR, val);\n\tspec->mcr = val;\n}\n\nstatic void set_cpld(struct snd_ice1712 *ice, unsigned int val)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\treg_write(ice, GPIO_CPLD_CSN, val);\n\tspec->cpld = val;\n}\n\nstatic void proc_regs_read(struct snd_info_entry *entry,\n\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tchar bin_buffer[36];\n\n\tsnd_iprintf(buffer, \"SCR:\t%s\\n\", get_binary(bin_buffer,\n\t\t\t\tget_scr(ice)));\n\tsnd_iprintf(buffer, \"MCR:\t%s\\n\", get_binary(bin_buffer,\n\t\t\t\tget_mcr(ice)));\n\tsnd_iprintf(buffer, \"CPLD:\t%s\\n\", get_binary(bin_buffer,\n\t\t\t\tget_cpld(ice)));\n}\n\nstatic void proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_ro_proc_new(ice->card, \"quartet\", ice, proc_regs_read);\n}\n\nstatic int qtet_mute_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tval = get_scr(ice) & SCR_MUTE;\n\tucontrol->value.integer.value[0] = (val) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int qtet_mute_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old, new, smute;\n\told = get_scr(ice) & SCR_MUTE;\n\tif (ucontrol->value.integer.value[0]) {\n\t\t \n\t\tnew = 0;\n\t\t \n\t\tsmute = 0;\n\t} else {\n\t\t \n\t\tnew = SCR_MUTE;\n\t\t \n\t\tsmute = AK4620_SMUTE;\n\t}\n\tif (old != new) {\n\t\tstruct snd_akm4xxx *ak = ice->akm;\n\t\tset_scr(ice, (get_scr(ice) & ~SCR_MUTE) | new);\n\t\t \n\t\tqtet_akm_set_regs(ak, AK4620_DEEMVOL_REG, AK4620_SMUTE, smute);\n\t\treturn 1;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int qtet_ain12_enum_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] =\n\t\t{\"Line In 1/2\", \"Mic\", \"Mic + Low-cut\"};\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int qtet_ain12_sw_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val, result;\n\tval = get_scr(ice) & (SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\n\tswitch (val) {\n\tcase SCR_AIN12_LINE:\n\t\tresult = 0;\n\t\tbreak;\n\tcase SCR_AIN12_MIC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase SCR_AIN12_LOWCUT:\n\t\tresult = 2;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsnd_BUG();\n\t\tresult = 0;\n\t}\n\tucontrol->value.integer.value[0] = result;\n\treturn 0;\n}\n\nstatic int qtet_ain12_sw_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old, new, tmp, masked_old;\n\told = get_scr(ice);\n\tmasked_old = old & (SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\n\ttmp = ucontrol->value.integer.value[0];\n\tif (tmp == 2)\n\t\ttmp = 3;\t \n\ttmp <<= 4;\t \n\tif (tmp != masked_old) {\n\t\t \n\t\tswitch (tmp) {\n\t\tcase SCR_AIN12_LINE:\n\t\t\tnew = old & ~(SCR_AIN12_SEL1 | SCR_AIN12_SEL0);\n\t\t\tset_scr(ice, new);\n\t\t\t \n\t\t\tnew &= ~SCR_RELAY;\n\t\t\tset_scr(ice, new);\n\t\t\tbreak;\n\t\tcase SCR_AIN12_MIC:\n\t\t\t \n\t\t\tnew = old | SCR_RELAY;\n\t\t\tset_scr(ice, new);\n\t\t\tnew = (new & ~SCR_AIN12_SEL1) | SCR_AIN12_SEL0;\n\t\t\tset_scr(ice, new);\n\t\t\tbreak;\n\t\tcase SCR_AIN12_LOWCUT:\n\t\t\t \n\t\t\tnew = old | SCR_RELAY;\n\t\t\tset_scr(ice, new);\n\t\t\tnew |= SCR_AIN12_SEL1 | SCR_AIN12_SEL0;\n\t\t\tset_scr(ice, new);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_BUG();\n\t\t}\n\t\treturn 1;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int qtet_php_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\t \n\tval = get_scr(ice) & SCR_PHP_V;\n\tucontrol->value.integer.value[0] = val ? 1 : 0;\n\treturn 0;\n}\n\nstatic int qtet_php_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old, new;\n\told = new = get_scr(ice);\n\tif (ucontrol->value.integer.value[0]  \n\t\t\t&& (~old & SCR_PHP_V))   {\n\t\t \n\t\t \n\t\tnew = old | SCR_PHP_V;\n\t\tset_scr(ice, new);\n\t\t \n\t\tnew &= ~SCR_PHP;\n\t\tset_scr(ice, new);\n\t} else if (!ucontrol->value.integer.value[0] && (old & SCR_PHP_V)) {\n\t\t \n\t\t \n\t\t \n\t\tnew = old & ~SCR_PHP_V;\n\t\tset_scr(ice, new);\n\t\t \n\t\tnew |= SCR_PHP;\n\t\tset_scr(ice, new);\n\t}\n\tif (old != new)\n\t\treturn 1;\n\t \n\treturn 0;\n}\n\n#define PRIV_SW(xid, xbit, xreg)\t[xid] = {.bit = xbit,\\\n\t.set_register = set_##xreg,\\\n\t.get_register = get_##xreg, }\n\n\n#define PRIV_ENUM2(xid, xbit, xreg, xtext1, xtext2)\t[xid] = {.bit = xbit,\\\n\t.set_register = set_##xreg,\\\n\t.get_register = get_##xreg,\\\n\t.texts = {xtext1, xtext2} }\n\nstatic const struct qtet_kcontrol_private qtet_privates[] = {\n\tPRIV_ENUM2(IN12_SEL, CPLD_IN12_SEL, cpld, \"An In 1/2\", \"An In 3/4\"),\n\tPRIV_ENUM2(IN34_SEL, CPLD_IN34_SEL, cpld, \"An In 3/4\", \"IEC958 In\"),\n\tPRIV_ENUM2(AIN34_SEL, SCR_AIN34_SEL, scr, \"Line In 3/4\", \"Hi-Z\"),\n\tPRIV_ENUM2(COAX_OUT, CPLD_COAX_OUT, cpld, \"IEC958\", \"I2S\"),\n\tPRIV_SW(IN12_MON12, MCR_IN12_MON12, mcr),\n\tPRIV_SW(IN12_MON34, MCR_IN12_MON34, mcr),\n\tPRIV_SW(IN34_MON12, MCR_IN34_MON12, mcr),\n\tPRIV_SW(IN34_MON34, MCR_IN34_MON34, mcr),\n\tPRIV_SW(OUT12_MON34, MCR_OUT12_MON34, mcr),\n\tPRIV_SW(OUT34_MON12, MCR_OUT34_MON12, mcr),\n};\n\nstatic int qtet_enum_info(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct qtet_kcontrol_private private =\n\t\tqtet_privates[kcontrol->private_value];\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(private.texts),\n\t\t\t\t private.texts);\n}\n\nstatic int qtet_sw_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct qtet_kcontrol_private private =\n\t\tqtet_privates[kcontrol->private_value];\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] =\n\t\t(private.get_register(ice) & private.bit) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int qtet_sw_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct qtet_kcontrol_private private =\n\t\tqtet_privates[kcontrol->private_value];\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old, new;\n\told = private.get_register(ice);\n\tif (ucontrol->value.integer.value[0])\n\t\tnew = old | private.bit;\n\telse\n\t\tnew = old & ~private.bit;\n\tif (old != new) {\n\t\tprivate.set_register(ice, new);\n\t\treturn 1;\n\t}\n\t \n\treturn 0;\n}\n\n#define qtet_sw_info\tsnd_ctl_boolean_mono_info\n\n#define QTET_CONTROL(xname, xtype, xpriv)\t\\\n\t{.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\\\n\t.name = xname,\\\n\t.info = qtet_##xtype##_info,\\\n\t.get = qtet_sw_get,\\\n\t.put = qtet_sw_put,\\\n\t.private_value = xpriv }\n\nstatic const struct snd_kcontrol_new qtet_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = qtet_sw_info,\n\t\t.get = qtet_mute_get,\n\t\t.put = qtet_mute_put,\n\t\t.private_value = 0\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Phantom Power\",\n\t\t.info = qtet_sw_info,\n\t\t.get = qtet_php_get,\n\t\t.put = qtet_php_put,\n\t\t.private_value = 0\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog In 1/2 Capture Switch\",\n\t\t.info = qtet_ain12_enum_info,\n\t\t.get = qtet_ain12_sw_get,\n\t\t.put = qtet_ain12_sw_put,\n\t\t.private_value = 0\n\t},\n\tQTET_CONTROL(\"Analog In 3/4 Capture Switch\", enum, AIN34_SEL),\n\tQTET_CONTROL(\"PCM In 1/2 Capture Switch\", enum, IN12_SEL),\n\tQTET_CONTROL(\"PCM In 3/4 Capture Switch\", enum, IN34_SEL),\n\tQTET_CONTROL(\"Coax Output Source\", enum, COAX_OUT),\n\tQTET_CONTROL(\"Analog In 1/2 to Monitor 1/2\", sw, IN12_MON12),\n\tQTET_CONTROL(\"Analog In 1/2 to Monitor 3/4\", sw, IN12_MON34),\n\tQTET_CONTROL(\"Analog In 3/4 to Monitor 1/2\", sw, IN34_MON12),\n\tQTET_CONTROL(\"Analog In 3/4 to Monitor 3/4\", sw, IN34_MON34),\n\tQTET_CONTROL(\"Output 1/2 to Monitor 3/4\", sw, OUT12_MON34),\n\tQTET_CONTROL(\"Output 3/4 to Monitor 1/2\", sw, OUT34_MON12),\n};\n\nstatic const char * const follower_vols[] = {\n\tPCM_12_PLAYBACK_VOLUME,\n\tPCM_34_PLAYBACK_VOLUME,\n\tNULL\n};\n\nstatic\nDECLARE_TLV_DB_SCALE(qtet_master_db_scale, -6350, 50, 1);\n\nstatic int qtet_add_controls(struct snd_ice1712 *ice)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\tint err, i;\n\tstruct snd_kcontrol *vmaster;\n\terr = snd_ice1712_akm4xxx_build_controls(ice);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < ARRAY_SIZE(qtet_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\tsnd_ctl_new1(&qtet_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tvmaster = snd_ctl_make_virtual_master(\"Master Playback Volume\",\n\t\t\tqtet_master_db_scale);\n\tif (!vmaster)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(ice->card, vmaster);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add_followers(ice->card, vmaster, follower_vols);\n\tif (err < 0)\n\t\treturn err;\n\t \n\treturn snd_ak4113_build(spec->ak4113,\n\t\t\tice->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n}\n\nstatic inline int qtet_is_spdif_master(struct snd_ice1712 *ice)\n{\n\t \n\treturn (get_cpld(ice) & CPLD_SYNC_SEL) ? 1 : 0;\n}\n\nstatic unsigned int qtet_get_rate(struct snd_ice1712 *ice)\n{\n\tint i;\n\tunsigned char result;\n\n\tresult =  get_cpld(ice) & CPLD_CKS_MASK;\n\tfor (i = 0; i < ARRAY_SIZE(cks_vals); i++)\n\t\tif (cks_vals[i] == result)\n\t\t\treturn qtet_rates[i];\n\treturn 0;\n}\n\nstatic int get_cks_val(int rate)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(qtet_rates); i++)\n\t\tif (qtet_rates[i] == rate)\n\t\t\treturn cks_vals[i];\n\treturn 0;\n}\n\n \nstatic void qtet_set_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tunsigned int new;\n\tunsigned char val;\n\t \n\tval = inb(ICEMT1724(ice, RATE));\n\toutb(val | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\n\n\tnew =  (get_cpld(ice) & ~CPLD_CKS_MASK) | get_cks_val(rate);\n\t \n\tnew &= ~CPLD_SYNC_SEL;\n\t \n\tset_cpld(ice, new);\n}\n\nstatic inline unsigned char qtet_set_mclk(struct snd_ice1712 *ice,\n\t\tunsigned int rate)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int qtet_set_spdif_clock(struct snd_ice1712 *ice, int type)\n{\n\tunsigned int old, new;\n\n\told = new = get_cpld(ice);\n\tnew &= ~(CPLD_CKS_MASK | CPLD_WORD_SEL);\n\tswitch (type) {\n\tcase EXT_SPDIF_TYPE:\n\t\tnew |= CPLD_EXT_SPDIF;\n\t\tbreak;\n\tcase EXT_WORDCLOCK_1FS_TYPE:\n\t\tnew |= CPLD_EXT_WORDCLOCK_1FS;\n\t\tbreak;\n\tcase EXT_WORDCLOCK_256FS_TYPE:\n\t\tnew |= CPLD_EXT_WORDCLOCK_256FS;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t}\n\tif (old != new) {\n\t\tset_cpld(ice, new);\n\t\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int qtet_get_spdif_master_type(struct snd_ice1712 *ice)\n{\n\tunsigned int val;\n\tint result;\n\tval = get_cpld(ice);\n\t \n\tval &= (CPLD_CKS_MASK | CPLD_WORD_SEL | CPLD_SYNC_SEL);\n\tif (!(val & CPLD_SYNC_SEL)) {\n\t\t \n\t\tresult = -1;\n\t} else {\n\t\tswitch (val) {\n\t\tcase (CPLD_EXT_SPDIF):\n\t\t\tresult = EXT_SPDIF_TYPE;\n\t\t\tbreak;\n\t\tcase (CPLD_EXT_WORDCLOCK_1FS):\n\t\t\tresult = EXT_WORDCLOCK_1FS_TYPE;\n\t\t\tbreak;\n\t\tcase (CPLD_EXT_WORDCLOCK_256FS):\n\t\t\tresult = EXT_WORDCLOCK_256FS_TYPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsnd_BUG();\n\t\t\tresult = 0;\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstatic void qtet_ak4113_change(struct ak4113 *ak4113, unsigned char c0,\n\t\tunsigned char c1)\n{\n\tstruct snd_ice1712 *ice = ak4113->change_callback_private;\n\tint rate;\n\tif ((qtet_get_spdif_master_type(ice) == EXT_SPDIF_TYPE) &&\n\t\t\tc1) {\n\t\t \n\t\trate = snd_ak4113_external_rate(ak4113);\n\t\t \n\t\tqtet_akm_set_rate_val(ice->akm, rate);\n\t}\n}\n\n \nstatic void qtet_spdif_in_open(struct snd_ice1712 *ice,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct qtet_spec *spec = ice->spec;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint rate;\n\n\tif (qtet_get_spdif_master_type(ice) != EXT_SPDIF_TYPE)\n\t\t \n\t\treturn;\n\t \n\trate = snd_ak4113_external_rate(spec->ak4113);\n\tif (rate >= runtime->hw.rate_min && rate <= runtime->hw.rate_max) {\n\t\truntime->hw.rate_min = rate;\n\t\truntime->hw.rate_max = rate;\n\t}\n}\n\n \nstatic int qtet_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned char ak4113_init_vals[] = {\n\t\t \tAK4113_RST | AK4113_PWN |\n\t\t\tAK4113_OCKS0 | AK4113_OCKS1,\n\t\t \tAK4113_DIF_I24I2S | AK4113_VTX |\n\t\t\tAK4113_DEM_OFF | AK4113_DEAU,\n\t\t \tAK4113_OPS2 | AK4113_TXE |\n\t\t\tAK4113_XTL_24_576M,\n\t\t \tAK4113_EFH_1024LRCLK | AK4113_IPS(0),\n\t\t \t0,\n\t\t \t0,\n\t\t \t\t0,\n\t};\n\tint err;\n\tstruct qtet_spec *spec;\n\tstruct snd_akm4xxx *ak;\n\tunsigned char val;\n\n\t \n\tval = inb(ICEMT1724(ice, RATE));\n\toutb(val | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\t \n\tice->hw_rates = &qtet_rates_info;\n\tice->is_spdif_master = qtet_is_spdif_master;\n\tice->get_rate = qtet_get_rate;\n\tice->set_rate = qtet_set_rate;\n\tice->set_mclk = qtet_set_mclk;\n\tice->set_spdif_clock = qtet_set_spdif_clock;\n\tice->get_spdif_master_type = qtet_get_spdif_master_type;\n\tice->ext_clock_names = ext_clock_names;\n\tice->ext_clock_count = ARRAY_SIZE(ext_clock_names);\n\t \n\tice->spdif.ops.open = ice->pro_open = qtet_spdif_in_open;\n\tice->spec = spec;\n\n\t \n\t \n\t \n\tset_scr(ice, SCR_PHP);\n\tudelay(1);\n\t \n\tset_scr(ice, SCR_PHP | SCR_CODEC_PDN);\n\n\t \n\tset_mcr(ice, 0);\n\n\t \n\tset_cpld(ice, 0);\n\n\n\tice->num_total_dacs = 2;\n\tice->num_total_adcs = 2;\n\n\tice->akm = kcalloc(2, sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tak = ice->akm;\n\tif (!ak)\n\t\treturn -ENOMEM;\n\t \n\tice->akm_codecs = 1;\n\terr = snd_ice1712_akm4xxx_init(ak, &akm_qtet_dac, NULL, ice);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ak4113_create(ice->card,\n\t\t\tqtet_ak4113_read,\n\t\t\tqtet_ak4113_write,\n\t\t\tak4113_init_vals,\n\t\t\tice, &spec->ak4113);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tspec->ak4113->change_callback = qtet_ak4113_change;\n\tspec->ak4113->change_callback_private = ice;\n\t \n\tspec->ak4113->check_flags = 0;\n\n\tproc_init(ice);\n\n\tqtet_set_rate(ice, 44100);\n\treturn 0;\n}\n\nstatic const unsigned char qtet_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x28,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0x78,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0x00,\t \n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,   \n\t[ICE_EEP2_GPIO_DIR2]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK]   = 0xff,\t \n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0xff,\n\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,  \n\t[ICE_EEP2_GPIO_STATE1] = 0x7d,  \n\t[ICE_EEP2_GPIO_STATE2] = 0x00,  \n};\n\n \nstruct snd_ice1712_card_info snd_vt1724_qtet_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_QTET,\n\t\t.name = \"Infrasonic Quartet\",\n\t\t.model = \"quartet\",\n\t\t.chip_init = qtet_init,\n\t\t.build_controls = qtet_add_controls,\n\t\t.eeprom_size = sizeof(qtet_eeprom),\n\t\t.eeprom_data = qtet_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}