{
  "module_name": "ews.c",
  "hash_id": "957a46951103be4d6b575981f58b1ba7c838aedc3c2201db17330316283f2568",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/ews.c",
  "human_readable_source": "\n       \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/cs8427.h>\n#include <sound/asoundef.h>\n\n#include \"ice1712.h\"\n#include \"ews.h\"\n\n#define SND_CS8404\n#include <sound/cs8403.h>\n\nenum {\n\tEWS_I2C_CS8404 = 0, EWS_I2C_PCF1, EWS_I2C_PCF2,\n\tEWS_I2C_88D = 0,\n\tEWS_I2C_6FIRE = 0\n};\n\t\n\n \nstruct ews_spec {\n\tstruct snd_i2c_device *i2cdevs[3];\n};\n\n \n\n \nstatic void ewx_i2c_setlines(struct snd_i2c_bus *bus, int clk, int data)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\tunsigned char tmp = 0;\n\tif (clk)\n\t\ttmp |= ICE1712_EWX2496_SERIAL_CLOCK;\n\tif (data)\n\t\ttmp |= ICE1712_EWX2496_SERIAL_DATA;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, tmp);\n\tudelay(5);\n}\n\nstatic int ewx_i2c_getclock(struct snd_i2c_bus *bus)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\treturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & ICE1712_EWX2496_SERIAL_CLOCK ? 1 : 0;\n}\n\nstatic int ewx_i2c_getdata(struct snd_i2c_bus *bus, int ack)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\tint bit;\n\t \n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~ICE1712_EWX2496_RW);\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, 0);\n\tif (ack)\n\t\tudelay(5);\n\tbit = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & ICE1712_EWX2496_SERIAL_DATA ? 1 : 0;\n\t \n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, ICE1712_EWX2496_RW);\n\t \n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~ICE1712_EWX2496_SERIAL_CLOCK);\n\treturn bit;\n}\n\nstatic void ewx_i2c_start(struct snd_i2c_bus *bus)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\tunsigned char mask;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\t \n\tmask = ICE1712_EWX2496_RW;\n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\t\tmask |= ICE1712_EWX2496_AK4524_CS;  \n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\tmask |= ICE1712_6FIRE_AK4524_CS_MASK;  \n\t\tbreak;\n\t}\n\tsnd_ice1712_gpio_write_bits(ice, mask, mask);\n}\n\nstatic void ewx_i2c_stop(struct snd_i2c_bus *bus)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\tsnd_ice1712_restore_gpio_status(ice);\n}\n\nstatic void ewx_i2c_direction(struct snd_i2c_bus *bus, int clock, int data)\n{\n\tstruct snd_ice1712 *ice = bus->private_data;\n\tunsigned char mask = 0;\n\n\tif (clock)\n\t\tmask |= ICE1712_EWX2496_SERIAL_CLOCK;  \n\tif (data)\n\t\tmask |= ICE1712_EWX2496_SERIAL_DATA;  \n\tice->gpio.direction &= ~(ICE1712_EWX2496_SERIAL_CLOCK|ICE1712_EWX2496_SERIAL_DATA);\n\tice->gpio.direction |= mask;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, ice->gpio.direction);\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~mask);\n}\n\nstatic struct snd_i2c_bit_ops snd_ice1712_ewx_cs8427_bit_ops = {\n\t.start = ewx_i2c_start,\n\t.stop = ewx_i2c_stop,\n\t.direction = ewx_i2c_direction,\n\t.setlines = ewx_i2c_setlines,\n\t.getclock = ewx_i2c_getclock,\n\t.getdata = ewx_i2c_getdata,\n};\n\n\n \n\n \nstatic int snd_ice1712_ews88mt_chip_select(struct snd_ice1712 *ice, int chip_mask)\n{\n\tstruct ews_spec *spec = ice->spec;\n\tunsigned char data, ndata;\n\n\tif (snd_BUG_ON(chip_mask < 0 || chip_mask > 0x0f))\n\t\treturn -EINVAL;\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1)\n\t\tgoto __error;\n\tndata = (data & 0xf0) | chip_mask;\n\tif (ndata != data)\n\t\tif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF2], &ndata, 1)\n\t\t    != 1)\n\t\t\tgoto __error;\n\tsnd_i2c_unlock(ice->i2c);\n\treturn 0;\n\n     __error:\n\tsnd_i2c_unlock(ice->i2c);\n\tdev_err(ice->card->dev,\n\t\t\"AK4524 chip select failed, check cable to the front module\\n\");\n\treturn -EIO;\n}\n\n \nstatic void ews88mt_ak4524_lock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\tunsigned char tmp;\n\t \n\tif (snd_ice1712_ews88mt_chip_select(ice, ~(1 << chip) & 0x0f) < 0)\n\t\tdev_err(ice->card->dev, \"fatal error (ews88mt chip select)\\n\");\n\tsnd_ice1712_save_gpio_status(ice);\n\ttmp = ICE1712_EWS88_SERIAL_DATA |\n\t\tICE1712_EWS88_SERIAL_CLOCK |\n\t\tICE1712_EWS88_RW;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\n\t\t\t  ice->gpio.direction | tmp);\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\n}\n\n \nstatic void ews88mt_ak4524_unlock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\tsnd_ice1712_restore_gpio_status(ice);\n\tudelay(1);\n\tsnd_ice1712_ews88mt_chip_select(ice, 0x0f);\n}\n\n \nstatic void ewx2496_ak4524_lock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\tunsigned char tmp;\n\tsnd_ice1712_save_gpio_status(ice);\n\ttmp =  ICE1712_EWX2496_SERIAL_DATA |\n\t\tICE1712_EWX2496_SERIAL_CLOCK |\n\t\tICE1712_EWX2496_AK4524_CS |\n\t\tICE1712_EWX2496_RW;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\n\t\t\t  ice->gpio.direction | tmp);\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\n}\n\n \nstatic void dmx6fire_ak4524_lock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ak4xxx_private *priv = (void *)ak->private_value[0];\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\tunsigned char tmp;\n\tsnd_ice1712_save_gpio_status(ice);\n\ttmp = priv->cs_mask = priv->cs_addr = (1 << chip) & ICE1712_6FIRE_AK4524_CS_MASK;\n\ttmp |= ICE1712_6FIRE_SERIAL_DATA |\n\t\tICE1712_6FIRE_SERIAL_CLOCK |\n\t\tICE1712_6FIRE_RW;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\n\t\t\t  ice->gpio.direction | tmp);\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ~tmp);\n}\n\n \n\nstatic void snd_ice1712_ews_cs8404_spdif_write(struct snd_ice1712 *ice, unsigned char bits)\n{\n\tstruct ews_spec *spec = ice->spec;\n\tunsigned char bytes[2];\n\n\tsnd_i2c_lock(ice->i2c);\n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\t\tif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_CS8404], &bits, 1)\n\t\t    != 1)\n\t\t\tgoto _error;\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], bytes, 2)\n\t\t    != 2)\n\t\t\tgoto _error;\n\t\tif (bits != bytes[1]) {\n\t\t\tbytes[1] = bits;\n\t\t\tif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_88D],\n\t\t\t\t\t      bytes, 2) != 2)\n\t\t\t\tgoto _error;\n\t\t}\n\t\tbreak;\n\t}\n _error:\n\tsnd_i2c_unlock(ice->i2c);\n}\n\n \n\nstatic void ews88_spdif_default_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\n{\n\tsnd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_bits);\n}\n\nstatic int ews88_spdif_default_put(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\n{\n\tunsigned int val;\n\tint change;\n\n\tval = snd_cs8404_encode_spdif_bits(&ucontrol->value.iec958);\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = ice->spdif.cs8403_bits != val;\n\tice->spdif.cs8403_bits = val;\n\tif (change && ice->playback_pro_substream == NULL) {\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t\tsnd_ice1712_ews_cs8404_spdif_write(ice, val);\n\t} else {\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t}\n\treturn change;\n}\n\nstatic void ews88_spdif_stream_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\n{\n\tsnd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_stream_bits);\n}\n\nstatic int ews88_spdif_stream_put(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)\n{\n\tunsigned int val;\n\tint change;\n\n\tval = snd_cs8404_encode_spdif_bits(&ucontrol->value.iec958);\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = ice->spdif.cs8403_stream_bits != val;\n\tice->spdif.cs8403_stream_bits = val;\n\tif (change && ice->playback_pro_substream != NULL) {\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t\tsnd_ice1712_ews_cs8404_spdif_write(ice, val);\n\t} else {\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t}\n\treturn change;\n}\n\n\n \nstatic void ews88_open_spdif(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\n{\n\tice->spdif.cs8403_stream_bits = ice->spdif.cs8403_bits;\n}\n\n \nstatic void ews88_setup_spdif(struct snd_ice1712 *ice, int rate)\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n\tint change;\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\ttmp = ice->spdif.cs8403_stream_bits;\n\tif (tmp & 0x10)\t\t \n\t\ttmp &= (tmp & 0x01) ? ~0x06 : ~0x60;\n\tswitch (rate) {\n\tcase 32000: tmp |= (tmp & 0x01) ? 0x02 : 0x00; break;\n\tcase 44100: tmp |= (tmp & 0x01) ? 0x06 : 0x40; break;\n\tcase 48000: tmp |= (tmp & 0x01) ? 0x04 : 0x20; break;\n\tdefault: tmp |= (tmp & 0x01) ? 0x06 : 0x40; break;\n\t}\n\tchange = ice->spdif.cs8403_stream_bits != tmp;\n\tice->spdif.cs8403_stream_bits = tmp;\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\tif (change)\n\t\tsnd_ctl_notify(ice->card, SNDRV_CTL_EVENT_MASK_VALUE, &ice->spdif.stream_ctl->id);\n\tsnd_ice1712_ews_cs8404_spdif_write(ice, tmp);\n}\n\n\n \nstatic const struct snd_akm4xxx akm_ews88mt = {\n\t.num_adcs = 8,\n\t.num_dacs = 8,\n\t.type = SND_AK4524,\n\t.ops = {\n\t\t.lock = ews88mt_ak4524_lock,\n\t\t.unlock = ews88mt_ak4524_unlock\n\t}\n};\n\nstatic const struct snd_ak4xxx_private akm_ews88mt_priv = {\n\t.caddr = 2,\n\t.cif = 1,  \n\t.data_mask = ICE1712_EWS88_SERIAL_DATA,\n\t.clk_mask = ICE1712_EWS88_SERIAL_CLOCK,\n\t.cs_mask = 0,\n\t.cs_addr = 0,\n\t.cs_none = 0,  \n\t.add_flags = ICE1712_EWS88_RW,  \n\t.mask_flags = 0,\n};\n\nstatic const struct snd_akm4xxx akm_ewx2496 = {\n\t.num_adcs = 2,\n\t.num_dacs = 2,\n\t.type = SND_AK4524,\n\t.ops = {\n\t\t.lock = ewx2496_ak4524_lock\n\t}\n};\n\nstatic const struct snd_ak4xxx_private akm_ewx2496_priv = {\n\t.caddr = 2,\n\t.cif = 1,  \n\t.data_mask = ICE1712_EWS88_SERIAL_DATA,\n\t.clk_mask = ICE1712_EWS88_SERIAL_CLOCK,\n\t.cs_mask = ICE1712_EWX2496_AK4524_CS,\n\t.cs_addr = ICE1712_EWX2496_AK4524_CS,\n\t.cs_none = 0,\n\t.add_flags = ICE1712_EWS88_RW,  \n\t.mask_flags = 0,\n};\n\nstatic const struct snd_akm4xxx akm_6fire = {\n\t.num_adcs = 6,\n\t.num_dacs = 6,\n\t.type = SND_AK4524,\n\t.ops = {\n\t\t.lock = dmx6fire_ak4524_lock\n\t}\n};\n\nstatic const struct snd_ak4xxx_private akm_6fire_priv = {\n\t.caddr = 2,\n\t.cif = 1,  \n\t.data_mask = ICE1712_6FIRE_SERIAL_DATA,\n\t.clk_mask = ICE1712_6FIRE_SERIAL_CLOCK,\n\t.cs_mask = 0,\n\t.cs_addr = 0,  \n\t.cs_none = 0,\n\t.add_flags = ICE1712_6FIRE_RW,  \n\t.mask_flags = 0,\n};\n\n \n\n \n#define PCF9554_REG_INPUT      0\n#define PCF9554_REG_OUTPUT     1\n#define PCF9554_REG_POLARITY   2\n#define PCF9554_REG_CONFIG     3\n\nstatic int snd_ice1712_6fire_write_pca(struct snd_ice1712 *ice, unsigned char reg, unsigned char data);\n\nstatic int snd_ice1712_ews_init(struct snd_ice1712 *ice)\n{\n\tint err;\n\tstruct snd_akm4xxx *ak;\n\tstruct ews_spec *spec;\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\t\tice->num_total_dacs = 2;\n\t\tice->num_total_adcs = 2;\n\t\tbreak;\t\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\t\tice->num_total_dacs = 8;\n\t\tice->num_total_adcs = 8;\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\t \n\t\tice->num_total_dacs = 8;\n\t\tice->num_total_adcs = 8;\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\tice->num_total_dacs = 6;\n\t\tice->num_total_adcs = 6;\n\t\tbreak;\n\t}\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\t \n\terr = snd_i2c_bus_create(ice->card, \"ICE1712 GPIO 1\", NULL, &ice->i2c);\n\tif (err < 0) {\n\t\tdev_err(ice->card->dev, \"unable to create I2C bus\\n\");\n\t\treturn err;\n\t}\n\tice->i2c->private_data = ice;\n\tice->i2c->hw_ops.bit = &snd_ice1712_ewx_cs8427_bit_ops;\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\terr = snd_i2c_device_create(ice->i2c, \"PCF9554\",\n\t\t\t\t\t    ICE1712_6FIRE_PCF9554_ADDR,\n\t\t\t\t\t    &spec->i2cdevs[EWS_I2C_6FIRE]);\n\t\tif (err < 0) {\n\t\t\tdev_err(ice->card->dev,\n\t\t\t\t\"PCF9554 initialization failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_CONFIG, 0x80);\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\n\t\terr = snd_i2c_device_create(ice->i2c, \"CS8404\",\n\t\t\t\t\t    ICE1712_EWS88MT_CS8404_ADDR,\n\t\t\t\t\t    &spec->i2cdevs[EWS_I2C_CS8404]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_i2c_device_create(ice->i2c, \"PCF8574 (1st)\",\n\t\t\t\t\t    ICE1712_EWS88MT_INPUT_ADDR,\n\t\t\t\t\t    &spec->i2cdevs[EWS_I2C_PCF1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_i2c_device_create(ice->i2c, \"PCF8574 (2nd)\",\n\t\t\t\t\t    ICE1712_EWS88MT_OUTPUT_ADDR,\n\t\t\t\t\t    &spec->i2cdevs[EWS_I2C_PCF2]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\terr = snd_ice1712_ews88mt_chip_select(ice, 0x0f);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\terr = snd_i2c_device_create(ice->i2c, \"PCF8575\",\n\t\t\t\t\t    ICE1712_EWS88D_PCF_ADDR,\n\t\t\t\t\t    &spec->i2cdevs[EWS_I2C_88D]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\t\terr = snd_ice1712_init_cs8427(ice, CS8427_BASE_ADDR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_cs8427_reg_write(ice->cs8427, CS8427_REG_RECVERRMASK, CS8427_UNLOCK | CS8427_CONF | CS8427_BIP | CS8427_PAR);\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\terr = snd_ice1712_init_cs8427(ice, ICE1712_6FIRE_CS8427_ADDR);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_cs8427_reg_write(ice->cs8427, CS8427_REG_RECVERRMASK, CS8427_UNLOCK | CS8427_CONF | CS8427_BIP | CS8427_PAR);\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\t \n\t\tice->spdif.ops.open = ews88_open_spdif;\n\t\tice->spdif.ops.setup_rate = ews88_setup_spdif;\n\t\tice->spdif.ops.default_get = ews88_spdif_default_get;\n\t\tice->spdif.ops.default_put = ews88_spdif_default_put;\n\t\tice->spdif.ops.stream_get = ews88_spdif_stream_get;\n\t\tice->spdif.ops.stream_put = ews88_spdif_stream_put;\n\t\t \n\t\tsnd_ice1712_ews_cs8404_spdif_write(ice, ice->spdif.cs8403_bits);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\treturn 0;\n\t}\n\n\t \n\tak = ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tif (! ak)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\t\terr = snd_ice1712_akm4xxx_init(ak, &akm_ews88mt, &akm_ews88mt_priv, ice);\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\t\terr = snd_ice1712_akm4xxx_init(ak, &akm_ewx2496, &akm_ewx2496_priv, ice);\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\terr = snd_ice1712_akm4xxx_init(ak, &akm_6fire, &akm_6fire_priv, ice);\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\n \n\n \nstatic int snd_ice1712_ewx_io_sense_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo){\n\n\tstatic const char * const texts[2] = {\n\t\t\"+4dBu\", \"-10dBV\",\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_ice1712_ewx_io_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char mask = kcontrol->private_value & 0xff;\n\t\n\tsnd_ice1712_save_gpio_status(ice);\n\tucontrol->value.enumerated.item[0] = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA) & mask ? 1 : 0;\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn 0;\n}\n\nstatic int snd_ice1712_ewx_io_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char mask = kcontrol->private_value & 0xff;\n\tint val, nval;\n\n\tif (kcontrol->private_value & (1 << 31))\n\t\treturn -EPERM;\n\tnval = ucontrol->value.enumerated.item[0] ? mask : 0;\n\tsnd_ice1712_save_gpio_status(ice);\n\tval = snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA);\n\tnval |= val & ~mask;\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn val != nval;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_ewx2496_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input Sensitivity Switch\",\n\t\t.info = snd_ice1712_ewx_io_sense_info,\n\t\t.get = snd_ice1712_ewx_io_sense_get,\n\t\t.put = snd_ice1712_ewx_io_sense_put,\n\t\t.private_value = ICE1712_EWX2496_AIN_SEL,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Output Sensitivity Switch\",\n\t\t.info = snd_ice1712_ewx_io_sense_info,\n\t\t.get = snd_ice1712_ewx_io_sense_get,\n\t\t.put = snd_ice1712_ewx_io_sense_put,\n\t\t.private_value = ICE1712_EWX2496_AOUT_SEL,\n\t},\n};\n\n\n \n \nstatic int snd_ice1712_ews88mt_output_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tunsigned char data;\n\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\tucontrol->value.enumerated.item[0] = data & ICE1712_EWS88MT_OUTPUT_SENSE ? 1 : 0;  \n\treturn 0;\n}\n\n \nstatic int snd_ice1712_ews88mt_output_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tunsigned char data, ndata;\n\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF2], &data, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tndata = (data & ~ICE1712_EWS88MT_OUTPUT_SENSE) | (ucontrol->value.enumerated.item[0] ? ICE1712_EWS88MT_OUTPUT_SENSE : 0);\n\tif (ndata != data && snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF2],\n\t\t\t\t\t       &ndata, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn ndata != data;\n}\n\n \nstatic int snd_ice1712_ews88mt_input_sense_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tint channel = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned char data;\n\n\tif (snd_BUG_ON(channel < 0 || channel > 7))\n\t\treturn 0;\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF1], &data, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\t \n\tucontrol->value.enumerated.item[0] = data & (1 << channel) ? 0 : 1;\n\tsnd_i2c_unlock(ice->i2c);\n\treturn 0;\n}\n\n \nstatic int snd_ice1712_ews88mt_input_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tint channel = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned char data, ndata;\n\n\tif (snd_BUG_ON(channel < 0 || channel > 7))\n\t\treturn 0;\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF1], &data, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tndata = (data & ~(1 << channel)) | (ucontrol->value.enumerated.item[0] ? 0 : (1 << channel));\n\tif (ndata != data && snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF1],\n\t\t\t\t\t       &ndata, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn ndata != data;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_ews88mt_input_sense = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Input Sensitivity Switch\",\n\t.info = snd_ice1712_ewx_io_sense_info,\n\t.get = snd_ice1712_ews88mt_input_sense_get,\n\t.put = snd_ice1712_ews88mt_input_sense_put,\n\t.count = 8,\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_ews88mt_output_sense = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Output Sensitivity Switch\",\n\t.info = snd_ice1712_ewx_io_sense_info,\n\t.get = snd_ice1712_ews88mt_output_sense_get,\n\t.put = snd_ice1712_ews88mt_output_sense_put,\n};\n\n\n \n\n#define snd_ice1712_ews88d_control_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ice1712_ews88d_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\tunsigned char data[2];\n\t\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\tdata[0] = (data[shift >> 3] >> (shift & 7)) & 0x01;\n\tif (invert)\n\t\tdata[0] ^= 0x01;\n\tucontrol->value.integer.value[0] = data[0];\n\treturn 0;\n}\n\nstatic int snd_ice1712_ews88d_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct ews_spec *spec = ice->spec;\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\tunsigned char data[2], ndata[2];\n\tint change;\n\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tndata[shift >> 3] = data[shift >> 3] & ~(1 << (shift & 7));\n\tif (invert) {\n\t\tif (! ucontrol->value.integer.value[0])\n\t\t\tndata[shift >> 3] |= (1 << (shift & 7));\n\t} else {\n\t\tif (ucontrol->value.integer.value[0])\n\t\t\tndata[shift >> 3] |= (1 << (shift & 7));\n\t}\n\tchange = (data[shift >> 3] != ndata[shift >> 3]);\n\tif (change &&\n\t    snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_88D], data, 2) != 2) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn change;\n}\n\n#define EWS88D_CONTROL(xiface, xname, xshift, xinvert, xaccess) \\\n{ .iface = xiface,\\\n  .name = xname,\\\n  .access = xaccess,\\\n  .info = snd_ice1712_ews88d_control_info,\\\n  .get = snd_ice1712_ews88d_control_get,\\\n  .put = snd_ice1712_ews88d_control_put,\\\n  .private_value = xshift | (xinvert << 8),\\\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_ews88d_controls[] = {\n\tEWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, \"IEC958 Input Optical\", 0, 1, 0),  \n\tEWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, \"ADAT Output Optical\", 1, 0, 0),\n\tEWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, \"ADAT External Master Clock\", 2, 0, 0),\n\tEWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, \"Enable ADAT\", 3, 0, 0),\n\tEWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, \"ADAT Through\", 4, 1, 0),\n};\n\n\n \n\nstatic int snd_ice1712_6fire_read_pca(struct snd_ice1712 *ice, unsigned char reg)\n{\n\tunsigned char byte;\n\tstruct ews_spec *spec = ice->spec;\n\n\tsnd_i2c_lock(ice->i2c);\n\tbyte = reg;\n\tif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_6FIRE], &byte, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\tdev_err(ice->card->dev, \"cannot send pca\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbyte = 0;\n\tif (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_6FIRE], &byte, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\tdev_err(ice->card->dev, \"cannot read pca\\n\");\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn byte;\n}\n\nstatic int snd_ice1712_6fire_write_pca(struct snd_ice1712 *ice, unsigned char reg, unsigned char data)\n{\n\tunsigned char bytes[2];\n\tstruct ews_spec *spec = ice->spec;\n\n\tsnd_i2c_lock(ice->i2c);\n\tbytes[0] = reg;\n\tbytes[1] = data;\n\tif (snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_6FIRE], bytes, 2) != 2) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn 0;\n}\n\n#define snd_ice1712_6fire_control_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ice1712_6fire_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\tint data;\n\t\n\tdata = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT);\n\tif (data < 0)\n\t\treturn data;\n\tdata = (data >> shift) & 1;\n\tif (invert)\n\t\tdata ^= 1;\n\tucontrol->value.integer.value[0] = data;\n\treturn 0;\n}\n\nstatic int snd_ice1712_6fire_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value >> 8) & 1;\n\tint data, ndata;\n\t\n\tdata = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT);\n\tif (data < 0)\n\t\treturn data;\n\tndata = data & ~(1 << shift);\n\tif (ucontrol->value.integer.value[0])\n\t\tndata |= (1 << shift);\n\tif (invert)\n\t\tndata ^= (1 << shift);\n\tif (data != ndata) {\n\t\tsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_OUTPUT, (unsigned char)ndata);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ice1712_6fire_select_input_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"Internal\", \"Front Input\", \"Rear Input\", \"Wave Table\"\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\n     \nstatic int snd_ice1712_6fire_select_input_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint data;\n\t\n\tdata = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT);\n\tif (data < 0)\n\t\treturn data;\n\tucontrol->value.integer.value[0] = data & 3;\n\treturn 0;\n}\n\nstatic int snd_ice1712_6fire_select_input_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint data, ndata;\n\t\n\tdata = snd_ice1712_6fire_read_pca(ice, PCF9554_REG_OUTPUT);\n\tif (data < 0)\n\t\treturn data;\n\tndata = data & ~3;\n\tndata |= (ucontrol->value.integer.value[0] & 3);\n\tif (data != ndata) {\n\t\tsnd_ice1712_6fire_write_pca(ice, PCF9554_REG_OUTPUT, (unsigned char)ndata);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n#define DMX6FIRE_CONTROL(xname, xshift, xinvert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\\\n  .name = xname,\\\n  .info = snd_ice1712_6fire_control_info,\\\n  .get = snd_ice1712_6fire_control_get,\\\n  .put = snd_ice1712_6fire_control_put,\\\n  .private_value = xshift | (xinvert << 8),\\\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_6fire_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Input Select\",\n\t\t.info = snd_ice1712_6fire_select_input_info,\n\t\t.get = snd_ice1712_6fire_select_input_get,\n\t\t.put = snd_ice1712_6fire_select_input_put,\n\t},\n\tDMX6FIRE_CONTROL(\"Front Digital Input Switch\", 2, 1),\n\t\n\tDMX6FIRE_CONTROL(\"Optical Digital Input Switch\", 4, 0),\n\tDMX6FIRE_CONTROL(\"Phono Analog Input Switch\", 5, 0),\n\tDMX6FIRE_CONTROL(\"Breakbox LED\", 6, 0),\n};\n\n\nstatic int snd_ice1712_ews_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int idx;\n\tint err;\n\t\n\t \n\tif (ice->cs8427 == NULL) {\n\t\terr = snd_ice1712_spdif_build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\terr = snd_ice1712_akm4xxx_build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase ICE1712_SUBDEVICE_EWX2496:\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_ewx2496_controls); idx++) {\n\t\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ewx2496_controls[idx], ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88MT:\n\tcase ICE1712_SUBDEVICE_EWS88MT_NEW:\n\tcase ICE1712_SUBDEVICE_PHASE88:\n\tcase ICE1712_SUBDEVICE_TS88:\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88mt_input_sense, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88mt_output_sense, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_EWS88D:\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_ews88d_controls); idx++) {\n\t\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_ews88d_controls[idx], ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase ICE1712_SUBDEVICE_DMX6FIRE:\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_6fire_controls); idx++) {\n\t\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_6fire_controls[idx], ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n \nstruct snd_ice1712_card_info snd_ice1712_ews_cards[] = {\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_EWX2496,\n\t\t.name = \"TerraTec EWX24/96\",\n\t\t.model = \"ewx2496\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_EWS88MT,\n\t\t.name = \"TerraTec EWS88MT\",\n\t\t.model = \"ews88mt\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_EWS88MT_NEW,\n\t\t.name = \"TerraTec EWS88MT\",\n\t\t.model = \"ews88mt_new\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_PHASE88,\n\t\t.name = \"TerraTec Phase88\",\n\t\t.model = \"phase88\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_TS88,\n\t\t.name = \"terrasoniq TS88\",\n\t\t.model = \"phase88\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_EWS88D,\n\t\t.name = \"TerraTec EWS88D\",\n\t\t.model = \"ews88d\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t},\n\t{\n\t\t.subvendor = ICE1712_SUBDEVICE_DMX6FIRE,\n\t\t.name = \"TerraTec DMX6Fire\",\n\t\t.model = \"dmx6fire\",\n\t\t.chip_init = snd_ice1712_ews_init,\n\t\t.build_controls = snd_ice1712_ews_add_controls,\n\t\t.mpu401_1_name = \"MIDI-Front DMX6fire\",\n\t\t.mpu401_2_name = \"Wavetable DMX6fire\",\n\t\t.mpu401_2_info_flags = MPU401_INFO_OUTPUT,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}