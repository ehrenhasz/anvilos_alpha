{
  "module_name": "ak4xxx.c",
  "hash_id": "eab94669e9ea5cc383ef3ea873b596e943027d65540215fb95b9a60b6e57345d",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/ak4xxx.c",
  "human_readable_source": "\n       \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include \"ice1712.h\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ICEnsemble ICE17xx <-> AK4xxx AD/DA chip interface\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void snd_ice1712_akm4xxx_lock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\n\tsnd_ice1712_save_gpio_status(ice);\n}\n\nstatic void snd_ice1712_akm4xxx_unlock(struct snd_akm4xxx *ak, int chip)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\n\tsnd_ice1712_restore_gpio_status(ice);\n}\n\n \nstatic void snd_ice1712_akm4xxx_write(struct snd_akm4xxx *ak, int chip,\n\t\t\t\t      unsigned char addr, unsigned char data)\n{\n\tunsigned int tmp;\n\tint idx;\n\tunsigned int addrdata;\n\tstruct snd_ak4xxx_private *priv = (void *)ak->private_value[0];\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\n\tif (snd_BUG_ON(chip < 0 || chip >= 4))\n\t\treturn;\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\ttmp |= priv->add_flags;\n\ttmp &= ~priv->mask_flags;\n\tif (priv->cs_mask == priv->cs_addr) {\n\t\tif (priv->cif) {\n\t\t\ttmp |= priv->cs_mask;  \n\t\t}  else {\n\t\t\ttmp &= ~priv->cs_mask;  \n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(1);\n\t\t}\n\t} else {\n\t\t \n\t\ttmp &= ~priv->cs_mask;\n\t\ttmp |= priv->cs_addr;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t}\n\n\t \n\taddrdata = (priv->caddr << 6) | 0x20 | (addr & 0x1f);\n\taddrdata = (addrdata << 8) | data;\n\tfor (idx = 15; idx >= 0; idx--) {\n\t\t \n\t\ttmp &= ~priv->clk_mask;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\t \n\t\tif (addrdata & (1 << idx))\n\t\t\ttmp |= priv->data_mask;\n\t\telse\n\t\t\ttmp &= ~priv->data_mask;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\t \n\t\ttmp |= priv->clk_mask;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t}\n\n\tif (priv->cs_mask == priv->cs_addr) {\n\t\tif (priv->cif) {\n\t\t\t \n\t\t\ttmp &= ~priv->cs_mask;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(1);\n\t\t}\n\t\ttmp |= priv->cs_mask;  \n\t} else {\n\t\ttmp &= ~priv->cs_mask;\n\t\ttmp |= priv->cs_none;  \n\t}\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n}\n\n \nint snd_ice1712_akm4xxx_init(struct snd_akm4xxx *ak, const struct snd_akm4xxx *temp,\n\t\t\t     const struct snd_ak4xxx_private *_priv, struct snd_ice1712 *ice)\n{\n\tstruct snd_ak4xxx_private *priv;\n\n\tif (_priv != NULL) {\n\t\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\t\tif (priv == NULL)\n\t\t\treturn -ENOMEM;\n\t\t*priv = *_priv;\n\t} else {\n\t\tpriv = NULL;\n\t}\n\t*ak = *temp;\n\tak->card = ice->card;\n        ak->private_value[0] = (unsigned long)priv;\n\tak->private_data[0] = ice;\n\tif (ak->ops.lock == NULL)\n\t\tak->ops.lock = snd_ice1712_akm4xxx_lock;\n\tif (ak->ops.unlock == NULL)\n\t\tak->ops.unlock = snd_ice1712_akm4xxx_unlock;\n\tif (ak->ops.write == NULL)\n\t\tak->ops.write = snd_ice1712_akm4xxx_write;\n\tsnd_akm4xxx_init(ak);\n\treturn 0;\n}\n\nvoid snd_ice1712_akm4xxx_free(struct snd_ice1712 *ice)\n{\n\tunsigned int akidx;\n\tif (ice->akm == NULL)\n\t\treturn;\n\tfor (akidx = 0; akidx < ice->akm_codecs; akidx++) {\n\t\tstruct snd_akm4xxx *ak = &ice->akm[akidx];\n\t\tkfree((void*)ak->private_value[0]);\n\t}\n\tkfree(ice->akm);\n}\n\n \nint snd_ice1712_akm4xxx_build_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int akidx;\n\tint err;\n\n\tfor (akidx = 0; akidx < ice->akm_codecs; akidx++) {\n\t\tstruct snd_akm4xxx *ak = &ice->akm[akidx];\n\t\terr = snd_akm4xxx_build_controls(ak);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ice1712_akm4xxx_init);\nEXPORT_SYMBOL(snd_ice1712_akm4xxx_free);\nEXPORT_SYMBOL(snd_ice1712_akm4xxx_build_controls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}