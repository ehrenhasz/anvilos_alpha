{
  "module_name": "pontis.c",
  "hash_id": "2a883b4a9c47857c994ec46656b4955a12548321ceeb9344ef8a832619ae117a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/pontis.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"pontis.h\"\n\n \n#define WM_DEV\t\t0x34\n#define CS_DEV\t\t0x20\n\n \n#define WM_HP_ATTEN_L\t\t0x00\t \n#define WM_HP_ATTEN_R\t\t0x01\t \n#define WM_HP_MASTER\t\t0x02\t \n\t\t\t\t\t \n#define WM_DAC_ATTEN_L\t\t0x03\t \n#define WM_DAC_ATTEN_R\t\t0x04\n#define WM_DAC_MASTER\t\t0x05\n#define WM_PHASE_SWAP\t\t0x06\t \n#define WM_DAC_CTRL1\t\t0x07\n#define WM_DAC_MUTE\t\t0x08\n#define WM_DAC_CTRL2\t\t0x09\n#define WM_DAC_INT\t\t0x0a\n#define WM_ADC_INT\t\t0x0b\n#define WM_MASTER_CTRL\t\t0x0c\n#define WM_POWERDOWN\t\t0x0d\n#define WM_ADC_ATTEN_L\t\t0x0e\n#define WM_ADC_ATTEN_R\t\t0x0f\n#define WM_ALC_CTRL1\t\t0x10\n#define WM_ALC_CTRL2\t\t0x11\n#define WM_ALC_CTRL3\t\t0x12\n#define WM_NOISE_GATE\t\t0x13\n#define WM_LIMITER\t\t0x14\n#define WM_ADC_MUX\t\t0x15\n#define WM_OUT_MUX\t\t0x16\n#define WM_RESET\t\t0x17\n\n \n#define PONTIS_CS_CS\t\t(1<<4)\t \n#define PONTIS_CS_CLK\t\t(1<<5)\t \n#define PONTIS_CS_RDATA\t\t(1<<6)\t \n#define PONTIS_CS_WDATA\t\t(1<<7)\t \n\n\n \nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\n{\n\treg <<= 1;\n\treturn ((unsigned short)ice->akm[0].images[reg] << 8) |\n\t\tice->akm[0].images[reg + 1];\n}\n\n \nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\tunsigned short cval;\n\tcval = (reg << 9) | val;\n\tsnd_vt1724_write_i2c(ice, WM_DEV, cval >> 8, cval & 0xff);\n}\n\nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\twm_put_nocache(ice, reg, val);\n\treg <<= 1;\n\tice->akm[0].images[reg] = val >> 8;\n\tice->akm[0].images[reg + 1] = val;\n}\n\n \n\n#define DAC_0dB\t0xff\n#define DAC_RES\t128\n#define DAC_MIN\t(DAC_0dB - DAC_RES)\n\nstatic int wm_dac_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t \n\tuinfo->value.integer.max = DAC_RES;\t \n\treturn 0;\n}\n\nstatic int wm_dac_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\tint i;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tval = wm_get(ice, WM_DAC_ATTEN_L + i) & 0xff;\n\t\tval = val > DAC_MIN ? (val - DAC_MIN) : 0;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short oval, nval;\n\tint i, idx, change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tnval = ucontrol->value.integer.value[i];\n\t\tnval = (nval ? (nval + DAC_MIN) : 0) & 0xff;\n\t\tidx = WM_DAC_ATTEN_L + i;\n\t\toval = wm_get(ice, idx) & 0xff;\n\t\tif (oval != nval) {\n\t\t\twm_put(ice, idx, nval);\n\t\t\twm_put_nocache(ice, idx, nval | 0x100);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n\n#define ADC_0dB\t0xcf\n#define ADC_RES\t128\n#define ADC_MIN\t(ADC_0dB - ADC_RES)\n\nstatic int wm_adc_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t \n\tuinfo->value.integer.max = ADC_RES;\t \n\treturn 0;\n}\n\nstatic int wm_adc_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\tint i;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tval = wm_get(ice, WM_ADC_ATTEN_L + i) & 0xff;\n\t\tval = val > ADC_MIN ? (val - ADC_MIN) : 0;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint i, idx, change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tnvol = ucontrol->value.integer.value[i];\n\t\tnvol = nvol ? (nvol + ADC_MIN) : 0;\n\t\tidx  = WM_ADC_ATTEN_L + i;\n\t\tovol = wm_get(ice, idx) & 0xff;\n\t\tif (ovol != nvol) {\n\t\t\twm_put(ice, idx, nvol);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n#define wm_adc_mux_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_adc_mux_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint bit = kcontrol->private_value;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_ADC_MUX) & (1 << bit)) ? 1 : 0;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_mux_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint bit = kcontrol->private_value;\n\tunsigned short oval, nval;\n\tint change;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tnval = oval = wm_get(ice, WM_ADC_MUX);\n\tif (ucontrol->value.integer.value[0])\n\t\tnval |= (1 << bit);\n\telse\n\t\tnval &= ~(1 << bit);\n\tchange = nval != oval;\n\tif (change) {\n\t\twm_put(ice, WM_ADC_MUX, nval);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n#define wm_bypass_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_bypass_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_OUT_MUX) & 0x04) ? 1 : 0;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_bypass_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val, oval;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tval = oval = wm_get(ice, WM_OUT_MUX);\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= 0x04;\n\telse\n\t\tval &= ~0x04;\n\tif (val != oval) {\n\t\twm_put(ice, WM_OUT_MUX, val);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n#define wm_chswap_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_chswap_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL1) & 0xf0) != 0x90;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_chswap_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val, oval;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\toval = wm_get(ice, WM_DAC_CTRL1);\n\tval = oval & 0x0f;\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= 0x60;\n\telse\n\t\tval |= 0x90;\n\tif (val != oval) {\n\t\twm_put(ice, WM_DAC_CTRL1, val);\n\t\twm_put_nocache(ice, WM_DAC_CTRL1, val);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \nstatic void set_gpio_bit(struct snd_ice1712 *ice, unsigned int bit, int val)\n{\n\tunsigned int tmp = snd_ice1712_gpio_read(ice);\n\tif (val)\n\t\ttmp |= bit;\n\telse\n\t\ttmp &= ~bit;\n\tsnd_ice1712_gpio_write(ice, tmp);\n}\n\nstatic void spi_send_byte(struct snd_ice1712 *ice, unsigned char data)\n{\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tset_gpio_bit(ice, PONTIS_CS_CLK, 0);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, PONTIS_CS_WDATA, data & 0x80);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, PONTIS_CS_CLK, 1);\n\t\tudelay(1);\n\t\tdata <<= 1;\n\t}\n}\n\nstatic unsigned int spi_read_byte(struct snd_ice1712 *ice)\n{\n\tint i;\n\tunsigned int val = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tval <<= 1;\n\t\tset_gpio_bit(ice, PONTIS_CS_CLK, 0);\n\t\tudelay(1);\n\t\tif (snd_ice1712_gpio_read(ice) & PONTIS_CS_RDATA)\n\t\t\tval |= 1;\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, PONTIS_CS_CLK, 1);\n\t\tudelay(1);\n\t}\n\treturn val;\n}\n\n\nstatic void spi_write(struct snd_ice1712 *ice, unsigned int dev, unsigned int reg, unsigned int data)\n{\n\tsnd_ice1712_gpio_set_dir(ice, PONTIS_CS_CS|PONTIS_CS_WDATA|PONTIS_CS_CLK);\n\tsnd_ice1712_gpio_set_mask(ice, ~(PONTIS_CS_CS|PONTIS_CS_WDATA|PONTIS_CS_CLK));\n\tset_gpio_bit(ice, PONTIS_CS_CS, 0);\n\tspi_send_byte(ice, dev & ~1);  \n\tspi_send_byte(ice, reg);  \n\tspi_send_byte(ice, data);  \n\t \n\tset_gpio_bit(ice, PONTIS_CS_CS, 1);\n\tudelay(1);\n\t \n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n}\n\nstatic unsigned int spi_read(struct snd_ice1712 *ice, unsigned int dev, unsigned int reg)\n{\n\tunsigned int val;\n\tsnd_ice1712_gpio_set_dir(ice, PONTIS_CS_CS|PONTIS_CS_WDATA|PONTIS_CS_CLK);\n\tsnd_ice1712_gpio_set_mask(ice, ~(PONTIS_CS_CS|PONTIS_CS_WDATA|PONTIS_CS_CLK));\n\tset_gpio_bit(ice, PONTIS_CS_CS, 0);\n\tspi_send_byte(ice, dev & ~1);  \n\tspi_send_byte(ice, reg);  \n\t \n\tset_gpio_bit(ice, PONTIS_CS_CS, 1);\n\tudelay(1);\n\tset_gpio_bit(ice, PONTIS_CS_CS, 0);\n\tspi_send_byte(ice, dev | 1);  \n\tval = spi_read_byte(ice);\n\t \n\tset_gpio_bit(ice, PONTIS_CS_CS, 1);\n\tudelay(1);\n\t \n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n\treturn val;\n}\n\n\n \nstatic int cs_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"Coax\",\t\t \n\t\t\"Optical\",\t \n\t\t\"CD\",\t\t \n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int cs_source_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.enumerated.item[0] = ice->gpio.saved[0];\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int cs_source_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tif (ucontrol->value.enumerated.item[0] != ice->gpio.saved[0]) {\n\t\tice->gpio.saved[0] = ucontrol->value.enumerated.item[0] & 3;\n\t\tval = 0x80 | (ice->gpio.saved[0] << 3);\n\t\tspi_write(ice, CS_DEV, 0x04, val);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n\n \nstatic int pontis_gpio_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffff;  \n\treturn 0;\n}\n\nstatic int pontis_gpio_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&ice->gpio_mutex);\n\t \n\tucontrol->value.integer.value[0] = (~ice->gpio.write_mask & 0xffff) | 0x00f0;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\t\nstatic int pontis_gpio_mask_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint changed;\n\tmutex_lock(&ice->gpio_mutex);\n\t \n\tval = (~ucontrol->value.integer.value[0] & 0xffff) | 0x00f0;\n\tchanged = val != ice->gpio.write_mask;\n\tice->gpio.write_mask = val;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn changed;\n}\n\nstatic int pontis_gpio_dir_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&ice->gpio_mutex);\n\t \n\tucontrol->value.integer.value[0] = ice->gpio.direction & 0xff0f;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\t\nstatic int pontis_gpio_dir_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint changed;\n\tmutex_lock(&ice->gpio_mutex);\n\t \n\tval = ucontrol->value.integer.value[0] & 0xff0f;\n\tchanged = (val != ice->gpio.direction);\n\tice->gpio.direction = val;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn changed;\n}\n\nstatic int pontis_gpio_data_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&ice->gpio_mutex);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tucontrol->value.integer.value[0] = snd_ice1712_gpio_read(ice) & 0xffff;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int pontis_gpio_data_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val, nval;\n\tint changed = 0;\n\tmutex_lock(&ice->gpio_mutex);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tval = snd_ice1712_gpio_read(ice) & 0xffff;\n\tnval = ucontrol->value.integer.value[0] & 0xffff;\n\tif (val != nval) {\n\t\tsnd_ice1712_gpio_write(ice, nval);\n\t\tchanged = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_volume, -6400, 50, 1);\n\n \n\nstatic const struct snd_kcontrol_new pontis_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"PCM Playback Volume\",\n\t\t.info = wm_dac_vol_info,\n\t\t.get = wm_dac_vol_get,\n\t\t.put = wm_dac_vol_put,\n\t\t.tlv = { .p = db_scale_volume },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Capture Volume\",\n\t\t.info = wm_adc_vol_info,\n\t\t.get = wm_adc_vol_get,\n\t\t.put = wm_adc_vol_put,\n\t\t.tlv = { .p = db_scale_volume },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"CD Capture Switch\",\n\t\t.info = wm_adc_mux_info,\n\t\t.get = wm_adc_mux_get,\n\t\t.put = wm_adc_mux_put,\n\t\t.private_value = 0,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line Capture Switch\",\n\t\t.info = wm_adc_mux_info,\n\t\t.get = wm_adc_mux_get,\n\t\t.put = wm_adc_mux_put,\n\t\t.private_value = 1,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Bypass Switch\",\n\t\t.info = wm_bypass_info,\n\t\t.get = wm_bypass_get,\n\t\t.put = wm_bypass_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Swap Output Channels\",\n\t\t.info = wm_chswap_info,\n\t\t.get = wm_chswap_get,\n\t\t.put = wm_chswap_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"IEC958 Input Source\",\n\t\t.info = cs_source_info,\n\t\t.get = cs_source_get,\n\t\t.put = cs_source_put,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t\t.name = \"GPIO Mask\",\n\t\t.info = pontis_gpio_mask_info,\n\t\t.get = pontis_gpio_mask_get,\n\t\t.put = pontis_gpio_mask_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t\t.name = \"GPIO Direction\",\n\t\t.info = pontis_gpio_mask_info,\n\t\t.get = pontis_gpio_dir_get,\n\t\t.put = pontis_gpio_dir_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t\t.name = \"GPIO Data\",\n\t\t.info = pontis_gpio_mask_info,\n\t\t.get = pontis_gpio_data_get,\n\t\t.put = pontis_gpio_data_put,\n\t},\n};\n\n\n \nstatic void wm_proc_regs_write(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tchar line[64];\n\tunsigned int reg, val;\n\tmutex_lock(&ice->gpio_mutex);\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%x %x\", &reg, &val) != 2)\n\t\t\tcontinue;\n\t\tif (reg <= 0x17 && val <= 0xffff)\n\t\t\twm_put(ice, reg, val);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic void wm_proc_regs_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tint reg, val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (reg = 0; reg <= 0x17; reg++) {\n\t\tval = wm_get(ice, reg);\n\t\tsnd_iprintf(buffer, \"%02x = %04x\\n\", reg, val);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic void wm_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_rw_proc_new(ice->card, \"wm_codec\", ice, wm_proc_regs_read,\n\t\t\t     wm_proc_regs_write);\n}\n\nstatic void cs_proc_regs_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tint reg, val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (reg = 0; reg <= 0x26; reg++) {\n\t\tval = spi_read(ice, CS_DEV, reg);\n\t\tsnd_iprintf(buffer, \"%02x = %02x\\n\", reg, val);\n\t}\n\tval = spi_read(ice, CS_DEV, 0x7f);\n\tsnd_iprintf(buffer, \"%02x = %02x\\n\", 0x7f, val);\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic void cs_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_ro_proc_new(ice->card, \"cs_codec\", ice, cs_proc_regs_read);\n}\n\n\nstatic int pontis_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(pontis_controls); i++) {\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&pontis_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\twm_proc_init(ice);\n\tcs_proc_init(ice);\n\n\treturn 0;\n}\n\n\n \nstatic int pontis_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm_inits[] = {\n\t\t \n\t\tWM_ADC_MUX,\t0x00c0,\t \n\t\tWM_DAC_MUTE,\t0x0001,\t \n\t\tWM_DAC_CTRL1,\t0x0000,\t \n\n\t\tWM_POWERDOWN,\t0x0008,\t \n\t\tWM_RESET,\t0x0000,\t \n\t};\n\tstatic const unsigned short wm_inits2[] = {\n\t\tWM_MASTER_CTRL,\t0x0022,\t \n\t\tWM_DAC_INT,\t0x0022,\t \n\t\tWM_ADC_INT,\t0x0022,\t \n\t\tWM_DAC_CTRL1,\t0x0090,\t \n\t\tWM_OUT_MUX,\t0x0001,\t \n\t\tWM_HP_ATTEN_L,\t0x0179,\t \n\t\tWM_HP_ATTEN_R,\t0x0179,\t \n\t\tWM_DAC_ATTEN_L,\t0x0000,\t \n\t\tWM_DAC_ATTEN_L,\t0x0100,\t \n\t\tWM_DAC_ATTEN_R,\t0x0000,\t \n\t\tWM_DAC_ATTEN_R,\t0x0100,\t \n\t\t \t \n\t\tWM_PHASE_SWAP,\t0x0000,\t \n\t\tWM_DAC_CTRL2,\t0x0000,\t \n\t\tWM_ADC_ATTEN_L,\t0x0000,\t \n\t\tWM_ADC_ATTEN_R,\t0x0000,\t \n#if 0\n\t\tWM_ALC_CTRL1,\t0x007b,\t \n\t\tWM_ALC_CTRL2,\t0x0000,\t \n\t\tWM_ALC_CTRL3,\t0x0000,\t \n\t\tWM_NOISE_GATE,\t0x0000,\t \n#endif\n\t\tWM_DAC_MUTE,\t0x0000,\t \n\t\tWM_ADC_MUX,\t0x0003,\t \n\t};\n\tstatic const unsigned char cs_inits[] = {\n\t\t0x04,\t0x80,\t \n\t\t0x05,\t0x05,\t \n\t\t0x01,\t0x00,\n\t\t0x02,\t0x00,\n\t\t0x03,\t0x00,\n\t};\n\tunsigned int i;\n\n\tice->vt1720 = 1;\n\tice->num_total_dacs = 2;\n\tice->num_total_adcs = 2;\n\n\t \n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tif (! ice->akm)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\t \n\tice->gpio.saved[0] = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wm_inits); i += 2)\n\t\twm_put(ice, wm_inits[i], wm_inits[i+1]);\n\tschedule_timeout_uninterruptible(1);\n\tfor (i = 0; i < ARRAY_SIZE(wm_inits2); i += 2)\n\t\twm_put(ice, wm_inits2[i], wm_inits2[i+1]);\n\n\t \n\t \n\toutb(inb(ICEMT1724(ice, AC97_CMD)) | 0x80, ICEMT1724(ice, AC97_CMD));\n\tmdelay(5);\n\t \n\toutb(inb(ICEMT1724(ice, AC97_CMD)) & ~0x80, ICEMT1724(ice, AC97_CMD));\n\n\tfor (i = 0; i < ARRAY_SIZE(cs_inits); i += 2)\n\t\tspi_write(ice, CS_DEV, cs_inits[i], cs_inits[i+1]);\n\n\treturn 0;\n}\n\n\n \n\nstatic const unsigned char pontis_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x08,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xf8,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0x07,\n\t[ICE_EEP2_GPIO_DIR1]   = 0x00,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x00,\t \n\t[ICE_EEP2_GPIO_MASK]   = 0x0f,\t \n\t[ICE_EEP2_GPIO_MASK1]  = 0xff,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\t \n\t[ICE_EEP2_GPIO_STATE]  = 0x06,\t \n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\t \n};\n\n \nstruct snd_ice1712_card_info snd_vt1720_pontis_cards[] = {\n\t{\n\t\t.subvendor = VT1720_SUBDEVICE_PONTIS_MS300,\n\t\t.name = \"Pontis MS300\",\n\t\t.model = \"ms300\",\n\t\t.chip_init = pontis_init,\n\t\t.build_controls = pontis_add_controls,\n\t\t.eeprom_size = sizeof(pontis_eeprom),\n\t\t.eeprom_data = pontis_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}