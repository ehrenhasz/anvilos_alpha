{
  "module_name": "maya44.c",
  "hash_id": "59e2b958915cf882a233f3bba4c3a50dea349f192e79314eec37db323466e78b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/maya44.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"maya44.h\"\n\n \n#define WM8776_REG_HEADPHONE_L\t\t0x00\n#define WM8776_REG_HEADPHONE_R\t\t0x01\n#define WM8776_REG_HEADPHONE_MASTER\t0x02\n#define WM8776_REG_DAC_ATTEN_L\t\t0x03\n#define WM8776_REG_DAC_ATTEN_R\t\t0x04\n#define WM8776_REG_DAC_ATTEN_MASTER\t0x05\n#define WM8776_REG_DAC_PHASE\t\t0x06\n#define WM8776_REG_DAC_CONTROL\t\t0x07\n#define WM8776_REG_DAC_MUTE\t\t0x08\n#define WM8776_REG_DAC_DEEMPH\t\t0x09\n#define WM8776_REG_DAC_IF_CONTROL\t0x0a\n#define WM8776_REG_ADC_IF_CONTROL\t0x0b\n#define WM8776_REG_MASTER_MODE_CONTROL\t0x0c\n#define WM8776_REG_POWERDOWN\t\t0x0d\n#define WM8776_REG_ADC_ATTEN_L\t\t0x0e\n#define WM8776_REG_ADC_ATTEN_R\t\t0x0f\n#define WM8776_REG_ADC_ALC1\t\t0x10\n#define WM8776_REG_ADC_ALC2\t\t0x11\n#define WM8776_REG_ADC_ALC3\t\t0x12\n#define WM8776_REG_ADC_NOISE_GATE\t0x13\n#define WM8776_REG_ADC_LIMITER\t\t0x14\n#define WM8776_REG_ADC_MUX\t\t0x15\n#define WM8776_REG_OUTPUT_MUX\t\t0x16\n#define WM8776_REG_RESET\t\t0x17\n\n#define WM8776_NUM_REGS\t\t\t0x18\n\n \n#define WM8776_CLOCK_RATIO_128FS\t0\n#define WM8776_CLOCK_RATIO_192FS\t1\n#define WM8776_CLOCK_RATIO_256FS\t2\n#define WM8776_CLOCK_RATIO_384FS\t3\n#define WM8776_CLOCK_RATIO_512FS\t4\n#define WM8776_CLOCK_RATIO_768FS\t5\n\nenum { WM_VOL_HP, WM_VOL_DAC, WM_VOL_ADC, WM_NUM_VOLS };\nenum { WM_SW_DAC, WM_SW_BYPASS, WM_NUM_SWITCHES };\n\nstruct snd_wm8776 {\n\tunsigned char addr;\n\tunsigned short regs[WM8776_NUM_REGS];\n\tunsigned char volumes[WM_NUM_VOLS][2];\n\tunsigned int switch_bits;\n};\n\nstruct snd_maya44 {\n\tstruct snd_ice1712 *ice;\n\tstruct snd_wm8776 wm[2];\n\tstruct mutex mutex;\n};\n\n\n \nstatic void wm8776_write(struct snd_ice1712 *ice, struct snd_wm8776 *wm,\n\t\t\t unsigned char reg, unsigned short val)\n{\n\t \n\tsnd_vt1724_write_i2c(ice, wm->addr,\n\t\t\t     (reg << 1) | ((val >> 8) & 1),\n\t\t\t     val & 0xff);\n\twm->regs[reg] = val;\n}\n\n \nstatic int wm8776_write_bits(struct snd_ice1712 *ice, struct snd_wm8776 *wm,\n\t\t\t     unsigned char reg,\n\t\t\t     unsigned short mask, unsigned short val)\n{\n\tval |= wm->regs[reg] & ~mask;\n\tif (val != wm->regs[reg]) {\n\t\twm8776_write(ice, wm, reg, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n \n\nstruct maya_vol_info {\n\tunsigned int maxval;\t\t \n\tunsigned char regs[2];\t\t \n\tunsigned short mask;\t\t \n\tunsigned short offset;\t\t \n\tunsigned short mute;\t\t \n\tunsigned short update;\t\t \n\tunsigned char mux_bits[2];\t \n};\n\nstatic const struct maya_vol_info vol_info[WM_NUM_VOLS] = {\n\t[WM_VOL_HP] = {\n\t\t.maxval = 80,\n\t\t.regs = { WM8776_REG_HEADPHONE_L, WM8776_REG_HEADPHONE_R },\n\t\t.mask = 0x7f,\n\t\t.offset = 0x30,\n\t\t.mute = 0x00,\n\t\t.update = 0x180,\t \n\t},\n\t[WM_VOL_DAC] = {\n\t\t.maxval = 255,\n\t\t.regs = { WM8776_REG_DAC_ATTEN_L, WM8776_REG_DAC_ATTEN_R },\n\t\t.mask = 0xff,\n\t\t.offset = 0x01,\n\t\t.mute = 0x00,\n\t\t.update = 0x100,\t \n\t},\n\t[WM_VOL_ADC] = {\n\t\t.maxval = 91,\n\t\t.regs = { WM8776_REG_ADC_ATTEN_L, WM8776_REG_ADC_ATTEN_R },\n\t\t.mask = 0xff,\n\t\t.offset = 0xa5,\n\t\t.mute = 0xa5,\n\t\t.update = 0x100,\t \n\t\t.mux_bits = { 0x80, 0x40 },  \n\t},\n};\n\n \n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_hp, -7400, 100, 1);\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_dac, -12750, 50, 1);\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_adc, -2100, 50, 1);\n\nstatic int maya_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int idx = kcontrol->private_value;\n\tconst struct maya_vol_info *vol = &vol_info[idx];\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = vol->maxval;\n\treturn 0;\n}\n\nstatic int maya_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_wm8776 *wm =\n\t\t&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];\n\tunsigned int idx = kcontrol->private_value;\n\n\tmutex_lock(&chip->mutex);\n\tucontrol->value.integer.value[0] = wm->volumes[idx][0];\n\tucontrol->value.integer.value[1] = wm->volumes[idx][1];\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int maya_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_wm8776 *wm =\n\t\t&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];\n\tunsigned int idx = kcontrol->private_value;\n\tconst struct maya_vol_info *vol = &vol_info[idx];\n\tunsigned int val, data;\n\tint ch, changed = 0;\n\n\tmutex_lock(&chip->mutex);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tval = ucontrol->value.integer.value[ch];\n\t\tif (val > vol->maxval)\n\t\t\tval = vol->maxval;\n\t\tif (val == wm->volumes[idx][ch])\n\t\t\tcontinue;\n\t\tif (!val)\n\t\t\tdata = vol->mute;\n\t\telse\n\t\t\tdata = (val - 1) + vol->offset;\n\t\tdata |= vol->update;\n\t\tchanged |= wm8776_write_bits(chip->ice, wm, vol->regs[ch],\n\t\t\t\t\t     vol->mask | vol->update, data);\n\t\tif (vol->mux_bits[ch])\n\t\t\twm8776_write_bits(chip->ice, wm, WM8776_REG_ADC_MUX,\n\t\t\t\t\t  vol->mux_bits[ch],\n\t\t\t\t\t  val ? 0 : vol->mux_bits[ch]);\n\t\twm->volumes[idx][ch] = val;\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n\n#define COMPOSE_SW_VAL(idx, reg, mask)\t((idx) | ((reg) << 8) | ((mask) << 16))\n#define GET_SW_VAL_IDX(val)\t((val) & 0xff)\n#define GET_SW_VAL_REG(val)\t(((val) >> 8) & 0xff)\n#define GET_SW_VAL_MASK(val)\t(((val) >> 16) & 0xff)\n\n#define maya_sw_info\tsnd_ctl_boolean_mono_info\n\nstatic int maya_sw_get(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_wm8776 *wm =\n\t\t&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];\n\tunsigned int idx = GET_SW_VAL_IDX(kcontrol->private_value);\n\n\tucontrol->value.integer.value[0] = (wm->switch_bits >> idx) & 1;\n\treturn 0;\n}\n\nstatic int maya_sw_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_wm8776 *wm =\n\t\t&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];\n\tunsigned int idx = GET_SW_VAL_IDX(kcontrol->private_value);\n\tunsigned int mask, val;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\tmask = 1 << idx;\n\twm->switch_bits &= ~mask;\n\tval = ucontrol->value.integer.value[0];\n\tif (val)\n\t\twm->switch_bits |= mask;\n\tmask = GET_SW_VAL_MASK(kcontrol->private_value);\n\tchanged = wm8776_write_bits(chip->ice, wm,\n\t\t\t\t    GET_SW_VAL_REG(kcontrol->private_value),\n\t\t\t\t    mask, val ? mask : 0);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n#define GPIO_PHANTOM_OFF\t2\n#define GPIO_MIC_RELAY\t\t4\n#define GPIO_SPDIF_IN_INV\t5\n#define GPIO_MUST_BE_0\t\t7\n\n \n\n#define COMPOSE_GPIO_VAL(shift, inv)\t((shift) | ((inv) << 8))\n#define GET_GPIO_VAL_SHIFT(val)\t\t((val) & 0xff)\n#define GET_GPIO_VAL_INV(val)\t\t(((val) >> 8) & 1)\n\nstatic int maya_set_gpio_bits(struct snd_ice1712 *ice, unsigned int mask,\n\t\t\t      unsigned int bits)\n{\n\tunsigned int data;\n\tdata = snd_ice1712_gpio_read(ice);\n\tif ((data & mask) == bits)\n\t\treturn 0;\n\tsnd_ice1712_gpio_write(ice, (data & ~mask) | bits);\n\treturn 1;\n}\n\n#define maya_gpio_sw_info\tsnd_ctl_boolean_mono_info\n\nstatic int maya_gpio_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int shift = GET_GPIO_VAL_SHIFT(kcontrol->private_value);\n\tunsigned int val;\n\n\tval = (snd_ice1712_gpio_read(chip->ice) >> shift) & 1;\n\tif (GET_GPIO_VAL_INV(kcontrol->private_value))\n\t\tval = !val;\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int maya_gpio_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int shift = GET_GPIO_VAL_SHIFT(kcontrol->private_value);\n\tunsigned int val, mask;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\tmask = 1 << shift;\n\tval = ucontrol->value.integer.value[0];\n\tif (GET_GPIO_VAL_INV(kcontrol->private_value))\n\t\tval = !val;\n\tval = val ? mask : 0;\n\tchanged = maya_set_gpio_bits(chip->ice, mask, val);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n\n \n#define MAYA_LINE_IN\t1\t \n#define MAYA_MIC_IN\t3\t \n\nstatic void wm8776_select_input(struct snd_maya44 *chip, int idx, int line)\n{\n\twm8776_write_bits(chip->ice, &chip->wm[idx], WM8776_REG_ADC_MUX,\n\t\t\t  0x1f, 1 << line);\n}\n\nstatic int maya_rec_src_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = { \"Line\", \"Mic\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int maya_rec_src_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tint sel;\n\n\tif (snd_ice1712_gpio_read(chip->ice) & (1 << GPIO_MIC_RELAY))\n\t\tsel = 1;\n\telse\n\t\tsel = 0;\n\tucontrol->value.enumerated.item[0] = sel;\n\treturn 0;\n}\n\nstatic int maya_rec_src_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tint sel = ucontrol->value.enumerated.item[0];\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\tchanged = maya_set_gpio_bits(chip->ice, 1 << GPIO_MIC_RELAY,\n\t\t\t\t     sel ? (1 << GPIO_MIC_RELAY) : 0);\n\twm8776_select_input(chip, 0, sel ? MAYA_MIC_IN : MAYA_LINE_IN);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \nstatic int maya_pb_route_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"PCM Out\",  \n\t\t\"Input 1\", \"Input 2\", \"Input 3\", \"Input 4\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\n}\n\nstatic int maya_pb_route_shift(int idx)\n{\n\tstatic const unsigned char shift[10] =\n\t\t{ 8, 20, 0, 3, 11, 23, 14, 26, 17, 29 };\n\treturn shift[idx % 10];\n}\n\nstatic int maya_pb_route_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tucontrol->value.enumerated.item[0] =\n\t\tsnd_ice1724_get_route_val(chip->ice, maya_pb_route_shift(idx));\n\treturn 0;\n}\n\nstatic int maya_pb_route_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_maya44 *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\treturn snd_ice1724_put_route_val(chip->ice,\n\t\t\t\t\t ucontrol->value.enumerated.item[0],\n\t\t\t\t\t maya_pb_route_shift(idx));\n}\n\n\n \n\nstatic const struct snd_kcontrol_new maya_controls[] = {\n\t{\n\t\t.name = \"Crossmix Playback Volume\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = maya_vol_info,\n\t\t.get = maya_vol_get,\n\t\t.put = maya_vol_put,\n\t\t.tlv = { .p = db_scale_hp },\n\t\t.private_value = WM_VOL_HP,\n\t\t.count = 2,\n\t},\n\t{\n\t\t.name = \"PCM Playback Volume\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = maya_vol_info,\n\t\t.get = maya_vol_get,\n\t\t.put = maya_vol_put,\n\t\t.tlv = { .p = db_scale_dac },\n\t\t.private_value = WM_VOL_DAC,\n\t\t.count = 2,\n\t},\n\t{\n\t\t.name = \"Line Capture Volume\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = maya_vol_info,\n\t\t.get = maya_vol_get,\n\t\t.put = maya_vol_put,\n\t\t.tlv = { .p = db_scale_adc },\n\t\t.private_value = WM_VOL_ADC,\n\t\t.count = 2,\n\t},\n\t{\n\t\t.name = \"PCM Playback Switch\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = maya_sw_info,\n\t\t.get = maya_sw_get,\n\t\t.put = maya_sw_put,\n\t\t.private_value = COMPOSE_SW_VAL(WM_SW_DAC,\n\t\t\t\t\t\tWM8776_REG_OUTPUT_MUX, 0x01),\n\t\t.count = 2,\n\t},\n\t{\n\t\t.name = \"Bypass Playback Switch\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = maya_sw_info,\n\t\t.get = maya_sw_get,\n\t\t.put = maya_sw_put,\n\t\t.private_value = COMPOSE_SW_VAL(WM_SW_BYPASS,\n\t\t\t\t\t\tWM8776_REG_OUTPUT_MUX, 0x04),\n\t\t.count = 2,\n\t},\n\t{\n\t\t.name = \"Capture Source\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = maya_rec_src_info,\n\t\t.get = maya_rec_src_get,\n\t\t.put = maya_rec_src_put,\n\t},\n\t{\n\t\t.name = \"Mic Phantom Power Switch\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = maya_gpio_sw_info,\n\t\t.get = maya_gpio_sw_get,\n\t\t.put = maya_gpio_sw_put,\n\t\t.private_value = COMPOSE_GPIO_VAL(GPIO_PHANTOM_OFF, 1),\n\t},\n\t{\n\t\t.name = \"SPDIF Capture Switch\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = maya_gpio_sw_info,\n\t\t.get = maya_gpio_sw_get,\n\t\t.put = maya_gpio_sw_put,\n\t\t.private_value = COMPOSE_GPIO_VAL(GPIO_SPDIF_IN_INV, 1),\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"H/W Playback Route\",\n\t\t.info = maya_pb_route_info,\n\t\t.get = maya_pb_route_get,\n\t\t.put = maya_pb_route_put,\n\t\t.count = 4,   \n\t},\n};\n\nstatic int maya44_add_controls(struct snd_ice1712 *ice)\n{\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(maya_controls); i++) {\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&maya_controls[i],\n\t\t\t\t\t\t\t  ice->spec));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void wm8776_init(struct snd_ice1712 *ice,\n\t\t\tstruct snd_wm8776 *wm, unsigned int addr)\n{\n\tstatic const unsigned short inits_wm8776[] = {\n\t\t0x02, 0x100,  \n\t\t0x05, 0x100,  \n\t\t0x06, 0x000,  \n\t\t0x07, 0x091,  \n\t\t0x08, 0x000,  \n\t\t0x09, 0x000,  \n\t\t0x0a, 0x022,  \n\t\t0x0b, 0x022,  \n\t\t0x0c, 0x042,  \n\t\t0x0d, 0x000,  \n\t\t0x0e, 0x100,  \n\t\t0x0f, 0x100,  \n\t\t\t      \n\t\t0x11, 0x000,  \n\t\t\t      \n\t\t\t      \n\t\t0x15, 0x000,  \n\t\t0x16, 0x001,  \n\t\t0xff, 0xff\n\t};\n\n\tconst unsigned short *ptr;\n\tunsigned char reg;\n\tunsigned short data;\n\n\twm->addr = addr;\n\t \n\twm->switch_bits = (1 << WM_SW_DAC);\n\n\tptr = inits_wm8776;\n\twhile (*ptr != 0xff) {\n\t\treg = *ptr++;\n\t\tdata = *ptr++;\n\t\twm8776_write(ice, wm, reg, data);\n\t}\n}\n\n\n \nstatic void set_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tstruct snd_maya44 *chip = ice->spec;\n\tunsigned int ratio, adc_ratio, val;\n\tint i;\n\n\tswitch (rate) {\n\tcase 192000:\n\t\tratio = WM8776_CLOCK_RATIO_128FS;\n\t\tbreak;\n\tcase 176400:\n\t\tratio = WM8776_CLOCK_RATIO_128FS;\n\t\tbreak;\n\tcase 96000:\n\t\tratio = WM8776_CLOCK_RATIO_256FS;\n\t\tbreak;\n\tcase 88200:\n\t\tratio = WM8776_CLOCK_RATIO_384FS;\n\t\tbreak;\n\tcase 48000:\n\t\tratio = WM8776_CLOCK_RATIO_512FS;\n\t\tbreak;\n\tcase 44100:\n\t\tratio = WM8776_CLOCK_RATIO_512FS;\n\t\tbreak;\n\tcase 32000:\n\t\tratio = WM8776_CLOCK_RATIO_768FS;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\treturn;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn;\n\t}\n\n\t \n\tadc_ratio = ratio;\n\tif (adc_ratio < WM8776_CLOCK_RATIO_256FS)\n\t\tadc_ratio = WM8776_CLOCK_RATIO_256FS;\n\n\tval = adc_ratio;\n\tif (adc_ratio == WM8776_CLOCK_RATIO_256FS)\n\t\tval |= 8;\n\tval |= ratio << 4;\n\n\tmutex_lock(&chip->mutex);\n\tfor (i = 0; i < 2; i++)\n\t\twm8776_write_bits(ice, &chip->wm[i],\n\t\t\t\t  WM8776_REG_MASTER_MODE_CONTROL,\n\t\t\t\t  0x180, val);\n\tmutex_unlock(&chip->mutex);\n}\n\n \n\nstatic const unsigned int rates[] = {\n\t32000, 44100, 48000, 64000, 88200, 96000, 176400, 192000\n};\n\n \nstatic const struct snd_pcm_hw_constraint_list dac_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0\n};\n\n\n \nstatic const unsigned char wm8776_addr[2] = {\n\t0x34, 0x36,  \n};\n\n \nstatic int maya44_init(struct snd_ice1712 *ice)\n{\n\tint i;\n\tstruct snd_maya44 *chip;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\tmutex_init(&chip->mutex);\n\tchip->ice = ice;\n\tice->spec = chip;\n\n\t \n\tice->num_total_dacs = 4;\n\tice->num_total_adcs = 4;\n\tice->akm_codecs = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\twm8776_init(ice, &chip->wm[i], wm8776_addr[i]);\n\t\twm8776_select_input(chip, i, MAYA_LINE_IN);\n\t}\n\n\t \n\tice->hw_rates = &dac_rates;\n\n\t \n\tice->gpio.set_pro_rate = set_rate;\n\n\t \n\tice->force_rdma1 = 1;\n\n\t \n\tice->own_routing = 1;\n\n\treturn 0;\n}\n\n\n \n\nstatic const unsigned char maya44_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x45,\n\t\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\n\t\t \n\t[ICE_EEP2_I2S]         = 0xf8,\n\t\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\n\t\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0xff,\n\t[ICE_EEP2_GPIO_MASK]   = 0 ,\n\t[ICE_EEP2_GPIO_MASK1]  = 0 ,\n\t[ICE_EEP2_GPIO_MASK2]  = 0 ,\n\t[ICE_EEP2_GPIO_STATE]  = (1 << GPIO_PHANTOM_OFF) |\n\t\t\t(1 << GPIO_SPDIF_IN_INV),\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\n \nstruct snd_ice1712_card_info snd_vt1724_maya44_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_MAYA44,\n\t\t.name = \"ESI Maya44\",\n\t\t.model = \"maya44\",\n\t\t.chip_init = maya44_init,\n\t\t.build_controls = maya44_add_controls,\n\t\t.eeprom_size = sizeof(maya44_eeprom),\n\t\t.eeprom_data = maya44_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}