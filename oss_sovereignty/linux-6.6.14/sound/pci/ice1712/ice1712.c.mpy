{
  "module_name": "ice1712.c",
  "hash_id": "515169497a12181599a2a21f2c820a43d42607aede919e67317bb5cdfcd27f20",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/ice1712.c",
  "human_readable_source": "\n \n\n \n\n \n\n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/cs8427.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/asoundef.h>\n\n#include \"ice1712.h\"\n\n \n#include \"delta.h\"\n#include \"ews.h\"\n#include \"hoontech.h\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ICEnsemble ICE1712 (Envy24)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; \nstatic char *model[SNDRV_CARDS];\nstatic bool omni[SNDRV_CARDS];\t\t\t\t \nstatic int cs8427_timeout[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 500};  \nstatic int dxr_enable[SNDRV_CARDS];\t\t\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ICE1712 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ICE1712 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ICE1712 soundcard.\");\nmodule_param_array(omni, bool, NULL, 0444);\nMODULE_PARM_DESC(omni, \"Enable Midiman M-Audio Delta Omni I/O support.\");\nmodule_param_array(cs8427_timeout, int, NULL, 0444);\nMODULE_PARM_DESC(cs8427_timeout, \"Define reset timeout for cs8427 chip in msec resolution.\");\nmodule_param_array(model, charp, NULL, 0444);\nMODULE_PARM_DESC(model, \"Use the given board model.\");\nmodule_param_array(dxr_enable, int, NULL, 0444);\nMODULE_PARM_DESC(dxr_enable, \"Enable DXR support for Terratec DMX6FIRE.\");\n\n\nstatic const struct pci_device_id snd_ice1712_ids[] = {\n\t{ PCI_VDEVICE(ICE, PCI_DEVICE_ID_ICE_1712), 0 },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_ice1712_ids);\n\nstatic int snd_ice1712_build_pro_mixer(struct snd_ice1712 *ice);\nstatic int snd_ice1712_build_controls(struct snd_ice1712 *ice);\n\nstatic int PRO_RATE_LOCKED;\nstatic int PRO_RATE_RESET = 1;\nstatic unsigned int PRO_RATE_DEFAULT = 44100;\n\n \n\n \nstatic inline int is_spdif_master(struct snd_ice1712 *ice)\n{\n\treturn (inb(ICEMT(ice, RATE)) & ICE1712_SPDIF_MASTER) ? 1 : 0;\n}\n\nstatic inline int is_pro_rate_locked(struct snd_ice1712 *ice)\n{\n\treturn is_spdif_master(ice) || PRO_RATE_LOCKED;\n}\n\nstatic inline void snd_ice1712_ds_write(struct snd_ice1712 *ice, u8 channel, u8 addr, u32 data)\n{\n\toutb((channel << 4) | addr, ICEDS(ice, INDEX));\n\toutl(data, ICEDS(ice, DATA));\n}\n\nstatic inline u32 snd_ice1712_ds_read(struct snd_ice1712 *ice, u8 channel, u8 addr)\n{\n\toutb((channel << 4) | addr, ICEDS(ice, INDEX));\n\treturn inl(ICEDS(ice, DATA));\n}\n\nstatic void snd_ice1712_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t   unsigned short reg,\n\t\t\t\t   unsigned short val)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tint tm;\n\tunsigned char old_cmd = 0;\n\n\tfor (tm = 0; tm < 0x10000; tm++) {\n\t\told_cmd = inb(ICEREG(ice, AC97_CMD));\n\t\tif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\n\t\t\tcontinue;\n\t\tif (!(old_cmd & ICE1712_AC97_READY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\toutb(reg, ICEREG(ice, AC97_INDEX));\n\toutw(val, ICEREG(ice, AC97_DATA));\n\told_cmd &= ~(ICE1712_AC97_PBK_VSR | ICE1712_AC97_CAP_VSR);\n\toutb(old_cmd | ICE1712_AC97_WRITE, ICEREG(ice, AC97_CMD));\n\tfor (tm = 0; tm < 0x10000; tm++)\n\t\tif ((inb(ICEREG(ice, AC97_CMD)) & ICE1712_AC97_WRITE) == 0)\n\t\t\tbreak;\n}\n\nstatic unsigned short snd_ice1712_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t    unsigned short reg)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tint tm;\n\tunsigned char old_cmd = 0;\n\n\tfor (tm = 0; tm < 0x10000; tm++) {\n\t\told_cmd = inb(ICEREG(ice, AC97_CMD));\n\t\tif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\n\t\t\tcontinue;\n\t\tif (!(old_cmd & ICE1712_AC97_READY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\toutb(reg, ICEREG(ice, AC97_INDEX));\n\toutb(old_cmd | ICE1712_AC97_READ, ICEREG(ice, AC97_CMD));\n\tfor (tm = 0; tm < 0x10000; tm++)\n\t\tif ((inb(ICEREG(ice, AC97_CMD)) & ICE1712_AC97_READ) == 0)\n\t\t\tbreak;\n\tif (tm >= 0x10000)\t\t \n\t\treturn ~0;\n\treturn inw(ICEREG(ice, AC97_DATA));\n}\n\n \n\nstatic void snd_ice1712_pro_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t       unsigned short reg,\n\t\t\t\t       unsigned short val)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tint tm;\n\tunsigned char old_cmd = 0;\n\n\tfor (tm = 0; tm < 0x10000; tm++) {\n\t\told_cmd = inb(ICEMT(ice, AC97_CMD));\n\t\tif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\n\t\t\tcontinue;\n\t\tif (!(old_cmd & ICE1712_AC97_READY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\toutb(reg, ICEMT(ice, AC97_INDEX));\n\toutw(val, ICEMT(ice, AC97_DATA));\n\told_cmd &= ~(ICE1712_AC97_PBK_VSR | ICE1712_AC97_CAP_VSR);\n\toutb(old_cmd | ICE1712_AC97_WRITE, ICEMT(ice, AC97_CMD));\n\tfor (tm = 0; tm < 0x10000; tm++)\n\t\tif ((inb(ICEMT(ice, AC97_CMD)) & ICE1712_AC97_WRITE) == 0)\n\t\t\tbreak;\n}\n\n\nstatic unsigned short snd_ice1712_pro_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t\tunsigned short reg)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tint tm;\n\tunsigned char old_cmd = 0;\n\n\tfor (tm = 0; tm < 0x10000; tm++) {\n\t\told_cmd = inb(ICEMT(ice, AC97_CMD));\n\t\tif (old_cmd & (ICE1712_AC97_WRITE | ICE1712_AC97_READ))\n\t\t\tcontinue;\n\t\tif (!(old_cmd & ICE1712_AC97_READY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\toutb(reg, ICEMT(ice, AC97_INDEX));\n\toutb(old_cmd | ICE1712_AC97_READ, ICEMT(ice, AC97_CMD));\n\tfor (tm = 0; tm < 0x10000; tm++)\n\t\tif ((inb(ICEMT(ice, AC97_CMD)) & ICE1712_AC97_READ) == 0)\n\t\t\tbreak;\n\tif (tm >= 0x10000)\t\t \n\t\treturn ~0;\n\treturn inw(ICEMT(ice, AC97_DATA));\n}\n\n \n#define snd_ice1712_digmix_route_ac97_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ice1712_digmix_route_ac97_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = inb(ICEMT(ice, MONITOR_ROUTECTRL)) & ICE1712_ROUTE_AC97 ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_ice1712_digmix_route_ac97_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val, nval;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tval = inb(ICEMT(ice, MONITOR_ROUTECTRL));\n\tnval = val & ~ICE1712_ROUTE_AC97;\n\tif (ucontrol->value.integer.value[0])\n\t\tnval |= ICE1712_ROUTE_AC97;\n\toutb(nval, ICEMT(ice, MONITOR_ROUTECTRL));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn val != nval;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_mixer_digmix_route_ac97 = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Digital Mixer To AC97\",\n\t.info = snd_ice1712_digmix_route_ac97_info,\n\t.get = snd_ice1712_digmix_route_ac97_get,\n\t.put = snd_ice1712_digmix_route_ac97_put,\n};\n\n\n \nstatic void snd_ice1712_set_gpio_dir(struct snd_ice1712 *ice, unsigned int data)\n{\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, data);\n\tinb(ICEREG(ice, DATA));  \n}\n\nstatic unsigned int snd_ice1712_get_gpio_dir(struct snd_ice1712 *ice)\n{\n\treturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DIRECTION);\n}\n\nstatic unsigned int snd_ice1712_get_gpio_mask(struct snd_ice1712 *ice)\n{\n\treturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_WRITE_MASK);\n}\n\nstatic void snd_ice1712_set_gpio_mask(struct snd_ice1712 *ice, unsigned int data)\n{\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, data);\n\tinb(ICEREG(ice, DATA));  \n}\n\nstatic unsigned int snd_ice1712_get_gpio_data(struct snd_ice1712 *ice)\n{\n\treturn snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA);\n}\n\nstatic void snd_ice1712_set_gpio_data(struct snd_ice1712 *ice, unsigned int val)\n{\n\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, val);\n\tinb(ICEREG(ice, DATA));  \n}\n\n \n\n \nstatic int snd_ice1712_cs8427_set_input_clock(struct snd_ice1712 *ice, int spdif_clock)\n{\n\tunsigned char reg[2] = { 0x80 | 4, 0 };    \n\tunsigned char val, nval;\n\tint res = 0;\n\n\tsnd_i2c_lock(ice->i2c);\n\tif (snd_i2c_sendbytes(ice->cs8427, reg, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tif (snd_i2c_readbytes(ice->cs8427, &val, 1) != 1) {\n\t\tsnd_i2c_unlock(ice->i2c);\n\t\treturn -EIO;\n\t}\n\tnval = val & 0xf0;\n\tif (spdif_clock)\n\t\tnval |= 0x01;\n\telse\n\t\tnval |= 0x04;\n\tif (val != nval) {\n\t\treg[1] = nval;\n\t\tif (snd_i2c_sendbytes(ice->cs8427, reg, 2) != 2) {\n\t\t\tres = -EIO;\n\t\t} else {\n\t\t\tres++;\n\t\t}\n\t}\n\tsnd_i2c_unlock(ice->i2c);\n\treturn res;\n}\n\n \nstatic void open_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\n{\n\tsnd_cs8427_iec958_active(ice->cs8427, 1);\n}\n\nstatic void close_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)\n{\n\tsnd_cs8427_iec958_active(ice->cs8427, 0);\n}\n\nstatic void setup_cs8427(struct snd_ice1712 *ice, int rate)\n{\n\tsnd_cs8427_iec958_pcm(ice->cs8427, rate);\n}\n\n \nint snd_ice1712_init_cs8427(struct snd_ice1712 *ice, int addr)\n{\n\tint err;\n\n\terr = snd_cs8427_create(ice->i2c, addr,\n\t\t(ice->cs8427_timeout * HZ) / 1000, &ice->cs8427);\n\tif (err < 0) {\n\t\tdev_err(ice->card->dev, \"CS8427 initialization failed\\n\");\n\t\treturn err;\n\t}\n\tice->spdif.ops.open = open_cs8427;\n\tice->spdif.ops.close = close_cs8427;\n\tice->spdif.ops.setup_rate = setup_cs8427;\n\treturn 0;\n}\n\nstatic void snd_ice1712_set_input_clock_source(struct snd_ice1712 *ice, int spdif_is_master)\n{\n\t \n\tif (ice->cs8427)\n\t\tsnd_ice1712_cs8427_set_input_clock(ice, spdif_is_master);\n\t \n\tif (spdif_is_master) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < ice->akm_codecs; i++) {\n\t\t\tif (ice->akm[i].ops.set_rate_val)\n\t\t\t\tice->akm[i].ops.set_rate_val(&ice->akm[i], 0);\n\t\t}\n\t}\n}\n\n \n\nstatic irqreturn_t snd_ice1712_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_ice1712 *ice = dev_id;\n\tunsigned char status;\n\tint handled = 0;\n\n\twhile (1) {\n\t\tstatus = inb(ICEREG(ice, IRQSTAT));\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\tif (status & ICE1712_IRQ_MPU1) {\n\t\t\tif (ice->rmidi[0])\n\t\t\t\tsnd_mpu401_uart_interrupt(irq, ice->rmidi[0]->private_data);\n\t\t\toutb(ICE1712_IRQ_MPU1, ICEREG(ice, IRQSTAT));\n\t\t\tstatus &= ~ICE1712_IRQ_MPU1;\n\t\t}\n\t\tif (status & ICE1712_IRQ_TIMER)\n\t\t\toutb(ICE1712_IRQ_TIMER, ICEREG(ice, IRQSTAT));\n\t\tif (status & ICE1712_IRQ_MPU2) {\n\t\t\tif (ice->rmidi[1])\n\t\t\t\tsnd_mpu401_uart_interrupt(irq, ice->rmidi[1]->private_data);\n\t\t\toutb(ICE1712_IRQ_MPU2, ICEREG(ice, IRQSTAT));\n\t\t\tstatus &= ~ICE1712_IRQ_MPU2;\n\t\t}\n\t\tif (status & ICE1712_IRQ_PROPCM) {\n\t\t\tunsigned char mtstat = inb(ICEMT(ice, IRQ));\n\t\t\tif (mtstat & ICE1712_MULTI_PBKSTATUS) {\n\t\t\t\tif (ice->playback_pro_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_pro_substream);\n\t\t\t\toutb(ICE1712_MULTI_PBKSTATUS, ICEMT(ice, IRQ));\n\t\t\t}\n\t\t\tif (mtstat & ICE1712_MULTI_CAPSTATUS) {\n\t\t\t\tif (ice->capture_pro_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->capture_pro_substream);\n\t\t\t\toutb(ICE1712_MULTI_CAPSTATUS, ICEMT(ice, IRQ));\n\t\t\t}\n\t\t}\n\t\tif (status & ICE1712_IRQ_FM)\n\t\t\toutb(ICE1712_IRQ_FM, ICEREG(ice, IRQSTAT));\n\t\tif (status & ICE1712_IRQ_PBKDS) {\n\t\t\tu32 idx;\n\t\t\tu16 pbkstatus;\n\t\t\tstruct snd_pcm_substream *substream;\n\t\t\tpbkstatus = inw(ICEDS(ice, INTSTAT));\n\t\t\t \n\t\t\tfor (idx = 0; idx < 6; idx++) {\n\t\t\t\tif ((pbkstatus & (3 << (idx * 2))) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tsubstream = ice->playback_con_substream_ds[idx];\n\t\t\t\tif (substream != NULL)\n\t\t\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\t\toutw(3 << (idx * 2), ICEDS(ice, INTSTAT));\n\t\t\t}\n\t\t\toutb(ICE1712_IRQ_PBKDS, ICEREG(ice, IRQSTAT));\n\t\t}\n\t\tif (status & ICE1712_IRQ_CONCAP) {\n\t\t\tif (ice->capture_con_substream)\n\t\t\t\tsnd_pcm_period_elapsed(ice->capture_con_substream);\n\t\t\toutb(ICE1712_IRQ_CONCAP, ICEREG(ice, IRQSTAT));\n\t\t}\n\t\tif (status & ICE1712_IRQ_CONPBK) {\n\t\t\tif (ice->playback_con_substream)\n\t\t\t\tsnd_pcm_period_elapsed(ice->playback_con_substream);\n\t\t\toutb(ICE1712_IRQ_CONPBK, ICEREG(ice, IRQSTAT));\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \n\nstatic int snd_ice1712_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\tu32 tmp;\n\n\tspin_lock(&ice->reg_lock);\n\ttmp = snd_ice1712_read(ice, ICE1712_IREG_PBK_CTRL);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\ttmp |= 1;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\ttmp &= ~1;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH) {\n\t\ttmp |= 2;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE) {\n\t\ttmp &= ~2;\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_CTRL, tmp);\n\tspin_unlock(&ice->reg_lock);\n\treturn result;\n}\n\nstatic int snd_ice1712_playback_ds_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t   int cmd)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\tu32 tmp;\n\n\tspin_lock(&ice->reg_lock);\n\ttmp = snd_ice1712_ds_read(ice, substream->number * 2, ICE1712_DSC_CONTROL);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\ttmp |= 1;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\ttmp &= ~1;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH) {\n\t\ttmp |= 2;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE) {\n\t\ttmp &= ~2;\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\tsnd_ice1712_ds_write(ice, substream->number * 2, ICE1712_DSC_CONTROL, tmp);\n\tspin_unlock(&ice->reg_lock);\n\treturn result;\n}\n\nstatic int snd_ice1712_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\tu8 tmp;\n\n\tspin_lock(&ice->reg_lock);\n\ttmp = snd_ice1712_read(ice, ICE1712_IREG_CAP_CTRL);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\ttmp |= 1;\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\ttmp &= ~1;\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\tsnd_ice1712_write(ice, ICE1712_IREG_CAP_CTRL, tmp);\n\tspin_unlock(&ice->reg_lock);\n\treturn result;\n}\n\nstatic int snd_ice1712_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu32 period_size, buf_size, rate, tmp;\n\n\tperiod_size = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\n\tbuf_size = snd_pcm_lib_buffer_bytes(substream) - 1;\n\ttmp = 0x0000;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\ttmp |= 0x10;\n\tif (runtime->channels == 2)\n\t\ttmp |= 0x08;\n\trate = (runtime->rate * 8192) / 375;\n\tif (rate > 0x000fffff)\n\t\trate = 0x000fffff;\n\tspin_lock_irq(&ice->reg_lock);\n\toutb(0, ice->ddma_port + 15);\n\toutb(ICE1712_DMA_MODE_WRITE | ICE1712_DMA_AUTOINIT, ice->ddma_port + 0x0b);\n\toutl(runtime->dma_addr, ice->ddma_port + 0);\n\toutw(buf_size, ice->ddma_port + 4);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_LO, rate & 0xff);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_MID, (rate >> 8) & 0xff);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_RATE_HI, (rate >> 16) & 0xff);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_CTRL, tmp);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_COUNT_LO, period_size & 0xff);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_COUNT_HI, period_size >> 8);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_LEFT, 0);\n\tsnd_ice1712_write(ice, ICE1712_IREG_PBK_RIGHT, 0);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_ds_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu32 period_size, rate, tmp, chn;\n\n\tperiod_size = snd_pcm_lib_period_bytes(substream) - 1;\n\ttmp = 0x0064;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\ttmp &= ~0x04;\n\tif (runtime->channels == 2)\n\t\ttmp |= 0x08;\n\trate = (runtime->rate * 8192) / 375;\n\tif (rate > 0x000fffff)\n\t\trate = 0x000fffff;\n\tice->playback_con_active_buf[substream->number] = 0;\n\tice->playback_con_virt_addr[substream->number] = runtime->dma_addr;\n\tchn = substream->number * 2;\n\tspin_lock_irq(&ice->reg_lock);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_ADDR0, runtime->dma_addr);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_COUNT0, period_size);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_ADDR1, runtime->dma_addr + (runtime->periods > 1 ? period_size + 1 : 0));\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_COUNT1, period_size);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_RATE, rate);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_VOLUME, 0);\n\tsnd_ice1712_ds_write(ice, chn, ICE1712_DSC_CONTROL, tmp);\n\tif (runtime->channels == 2) {\n\t\tsnd_ice1712_ds_write(ice, chn + 1, ICE1712_DSC_RATE, rate);\n\t\tsnd_ice1712_ds_write(ice, chn + 1, ICE1712_DSC_VOLUME, 0);\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu32 period_size, buf_size;\n\tu8 tmp;\n\n\tperiod_size = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\n\tbuf_size = snd_pcm_lib_buffer_bytes(substream) - 1;\n\ttmp = 0x06;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\ttmp &= ~0x04;\n\tif (runtime->channels == 2)\n\t\ttmp &= ~0x02;\n\tspin_lock_irq(&ice->reg_lock);\n\toutl(ice->capture_con_virt_addr = runtime->dma_addr, ICEREG(ice, CONCAP_ADDR));\n\toutw(buf_size, ICEREG(ice, CONCAP_COUNT));\n\tsnd_ice1712_write(ice, ICE1712_IREG_CAP_COUNT_HI, period_size >> 8);\n\tsnd_ice1712_write(ice, ICE1712_IREG_CAP_COUNT_LO, period_size & 0xff);\n\tsnd_ice1712_write(ice, ICE1712_IREG_CAP_CTRL, tmp);\n\tspin_unlock_irq(&ice->reg_lock);\n\tsnd_ac97_set_rate(ice->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_ice1712_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsize_t ptr;\n\n\tif (!(snd_ice1712_read(ice, ICE1712_IREG_PBK_CTRL) & 1))\n\t\treturn 0;\n\tptr = runtime->buffer_size - inw(ice->ddma_port + 4);\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr == runtime->buffer_size)\n\t\tptr = 0;\n\treturn ptr;\n}\n\nstatic snd_pcm_uframes_t snd_ice1712_playback_ds_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tu8 addr;\n\tsize_t ptr;\n\n\tif (!(snd_ice1712_ds_read(ice, substream->number * 2, ICE1712_DSC_CONTROL) & 1))\n\t\treturn 0;\n\tif (ice->playback_con_active_buf[substream->number])\n\t\taddr = ICE1712_DSC_ADDR1;\n\telse\n\t\taddr = ICE1712_DSC_ADDR0;\n\tptr = snd_ice1712_ds_read(ice, substream->number * 2, addr) -\n\t\tice->playback_con_virt_addr[substream->number];\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr == substream->runtime->buffer_size)\n\t\tptr = 0;\n\treturn ptr;\n}\n\nstatic snd_pcm_uframes_t snd_ice1712_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(snd_ice1712_read(ice, ICE1712_IREG_CAP_CTRL) & 1))\n\t\treturn 0;\n\tptr = inl(ICEREG(ice, CONCAP_ADDR)) - ice->capture_con_virt_addr;\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr == substream->runtime->buffer_size)\n\t\tptr = 0;\n\treturn ptr;\n}\n\nstatic const struct snd_pcm_hardware snd_ice1712_playback = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(64*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(64*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ice1712_playback_ds = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ice1712_capture = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(64*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(64*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_ice1712_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->playback_con_substream = substream;\n\truntime->hw = snd_ice1712_playback;\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_ds_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tu32 tmp;\n\n\tice->playback_con_substream_ds[substream->number] = substream;\n\truntime->hw = snd_ice1712_playback_ds;\n\tspin_lock_irq(&ice->reg_lock);\n\ttmp = inw(ICEDS(ice, INTMASK)) & ~(1 << (substream->number * 2));\n\toutw(tmp, ICEDS(ice, INTMASK));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->capture_con_substream = substream;\n\truntime->hw = snd_ice1712_capture;\n\truntime->hw.rates = ice->ac97->rates[AC97_RATES_ADC];\n\tif (!(runtime->hw.rates & SNDRV_PCM_RATE_8000))\n\t\truntime->hw.rate_min = 48000;\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->playback_con_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_ds_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tu32 tmp;\n\n\tspin_lock_irq(&ice->reg_lock);\n\ttmp = inw(ICEDS(ice, INTMASK)) | (3 << (substream->number * 2));\n\toutw(tmp, ICEDS(ice, INTMASK));\n\tspin_unlock_irq(&ice->reg_lock);\n\tice->playback_con_substream_ds[substream->number] = NULL;\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->capture_con_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ice1712_playback_ops = {\n\t.open =\t\tsnd_ice1712_playback_open,\n\t.close =\tsnd_ice1712_playback_close,\n\t.prepare =\tsnd_ice1712_playback_prepare,\n\t.trigger =\tsnd_ice1712_playback_trigger,\n\t.pointer =\tsnd_ice1712_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ice1712_playback_ds_ops = {\n\t.open =\t\tsnd_ice1712_playback_ds_open,\n\t.close =\tsnd_ice1712_playback_ds_close,\n\t.prepare =\tsnd_ice1712_playback_ds_prepare,\n\t.trigger =\tsnd_ice1712_playback_ds_trigger,\n\t.pointer =\tsnd_ice1712_playback_ds_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ice1712_capture_ops = {\n\t.open =\t\tsnd_ice1712_capture_open,\n\t.close =\tsnd_ice1712_capture_close,\n\t.prepare =\tsnd_ice1712_capture_prepare,\n\t.trigger =\tsnd_ice1712_capture_trigger,\n\t.pointer =\tsnd_ice1712_capture_pointer,\n};\n\nstatic int snd_ice1712_pcm(struct snd_ice1712 *ice, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(ice->card, \"ICE1712 consumer\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ice1712_capture_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ICE1712 consumer\");\n\tice->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 64*1024, 64*1024);\n\n\tdev_warn(ice->card->dev,\n\t\t \"Consumer PCM code does not work well at the moment --jk\\n\");\n\n\treturn 0;\n}\n\nstatic int snd_ice1712_pcm_ds(struct snd_ice1712 *ice, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(ice->card, \"ICE1712 consumer (DS)\", device, 6, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_ds_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ICE1712 consumer (DS)\");\n\tice->pcm_ds = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\n \n\nstatic const unsigned int rates[] = { 8000, 9600, 11025, 12000, 16000, 22050, 24000,\n\t\t\t\t32000, 44100, 48000, 64000, 88200, 96000 };\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic int snd_ice1712_pro_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t   int cmd)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t{\n\t\tunsigned int what;\n\t\tunsigned int old;\n\t\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\treturn -EINVAL;\n\t\twhat = ICE1712_PLAYBACK_PAUSE;\n\t\tsnd_pcm_trigger_done(substream, substream);\n\t\tspin_lock(&ice->reg_lock);\n\t\told = inl(ICEMT(ice, PLAYBACK_CONTROL));\n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\n\t\t\told |= what;\n\t\telse\n\t\t\told &= ~what;\n\t\toutl(old, ICEMT(ice, PLAYBACK_CONTROL));\n\t\tspin_unlock(&ice->reg_lock);\n\t\tbreak;\n\t}\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t{\n\t\tunsigned int what = 0;\n\t\tunsigned int old;\n\t\tstruct snd_pcm_substream *s;\n\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == ice->playback_pro_substream) {\n\t\t\t\twhat |= ICE1712_PLAYBACK_START;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == ice->capture_pro_substream) {\n\t\t\t\twhat |= ICE1712_CAPTURE_START_SHADOW;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t}\n\t\t}\n\t\tspin_lock(&ice->reg_lock);\n\t\told = inl(ICEMT(ice, PLAYBACK_CONTROL));\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\told |= what;\n\t\telse\n\t\t\told &= ~what;\n\t\toutl(old, ICEMT(ice, PLAYBACK_CONTROL));\n\t\tspin_unlock(&ice->reg_lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void snd_ice1712_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate, int force)\n{\n\tunsigned long flags;\n\tunsigned char val, old;\n\tunsigned int i;\n\n\tswitch (rate) {\n\tcase 8000: val = 6; break;\n\tcase 9600: val = 3; break;\n\tcase 11025: val = 10; break;\n\tcase 12000: val = 2; break;\n\tcase 16000: val = 5; break;\n\tcase 22050: val = 9; break;\n\tcase 24000: val = 1; break;\n\tcase 32000: val = 4; break;\n\tcase 44100: val = 8; break;\n\tcase 48000: val = 0; break;\n\tcase 64000: val = 15; break;\n\tcase 88200: val = 11; break;\n\tcase 96000: val = 7; break;\n\tdefault:\n\t\tsnd_BUG();\n\t\tval = 0;\n\t\trate = 48000;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\tif (inb(ICEMT(ice, PLAYBACK_CONTROL)) & (ICE1712_CAPTURE_START_SHADOW|\n\t\t\t\t\t\t ICE1712_PLAYBACK_PAUSE|\n\t\t\t\t\t\t ICE1712_PLAYBACK_START)) {\n__out:\n\t\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\t\treturn;\n\t}\n\tif (!force && is_pro_rate_locked(ice))\n\t\tgoto __out;\n\n\told = inb(ICEMT(ice, RATE));\n\tif (!force && old == val)\n\t\tgoto __out;\n\n\tice->cur_rate = rate;\n\toutb(val, ICEMT(ice, RATE));\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\n\tif (ice->gpio.set_pro_rate)\n\t\tice->gpio.set_pro_rate(ice, rate);\n\tfor (i = 0; i < ice->akm_codecs; i++) {\n\t\tif (ice->akm[i].ops.set_rate_val)\n\t\t\tice->akm[i].ops.set_rate_val(&ice->akm[i], rate);\n\t}\n\tif (ice->spdif.ops.setup_rate)\n\t\tice->spdif.ops.setup_rate(ice, rate);\n}\n\nstatic int snd_ice1712_playback_pro_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->playback_pro_size = snd_pcm_lib_buffer_bytes(substream);\n\tspin_lock_irq(&ice->reg_lock);\n\toutl(substream->runtime->dma_addr, ICEMT(ice, PLAYBACK_ADDR));\n\toutw((ice->playback_pro_size >> 2) - 1, ICEMT(ice, PLAYBACK_SIZE));\n\toutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1, ICEMT(ice, PLAYBACK_COUNT));\n\tspin_unlock_irq(&ice->reg_lock);\n\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_pro_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tsnd_ice1712_set_pro_rate(ice, params_rate(hw_params), 0);\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_pro_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->capture_pro_size = snd_pcm_lib_buffer_bytes(substream);\n\tspin_lock_irq(&ice->reg_lock);\n\toutl(substream->runtime->dma_addr, ICEMT(ice, CAPTURE_ADDR));\n\toutw((ice->capture_pro_size >> 2) - 1, ICEMT(ice, CAPTURE_SIZE));\n\toutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1, ICEMT(ice, CAPTURE_COUNT));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_pro_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tsnd_ice1712_set_pro_rate(ice, params_rate(hw_params), 0);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_ice1712_playback_pro_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(inl(ICEMT(ice, PLAYBACK_CONTROL)) & ICE1712_PLAYBACK_START))\n\t\treturn 0;\n\tptr = ice->playback_pro_size - (inw(ICEMT(ice, PLAYBACK_SIZE)) << 2);\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr == substream->runtime->buffer_size)\n\t\tptr = 0;\n\treturn ptr;\n}\n\nstatic snd_pcm_uframes_t snd_ice1712_capture_pro_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(inl(ICEMT(ice, PLAYBACK_CONTROL)) & ICE1712_CAPTURE_START_SHADOW))\n\t\treturn 0;\n\tptr = ice->capture_pro_size - (inw(ICEMT(ice, CAPTURE_SIZE)) << 2);\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr == substream->runtime->buffer_size)\n\t\tptr = 0;\n\treturn ptr;\n}\n\nstatic const struct snd_pcm_hardware snd_ice1712_playback_pro = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_96000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t10,\n\t.channels_max =\t\t10,\n\t.buffer_bytes_max =\t(256*1024),\n\t.period_bytes_min =\t10 * 4 * 2,\n\t.period_bytes_max =\t131040,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ice1712_capture_pro = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_96000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t12,\n\t.channels_max =\t\t12,\n\t.buffer_bytes_max =\t(256*1024),\n\t.period_bytes_min =\t12 * 4 * 2,\n\t.period_bytes_max =\t131040,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_ice1712_playback_pro_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tice->playback_pro_substream = substream;\n\truntime->hw = snd_ice1712_playback_pro;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n\tif (is_pro_rate_locked(ice)) {\n\t\truntime->hw.rate_min = PRO_RATE_DEFAULT;\n\t\truntime->hw.rate_max = PRO_RATE_DEFAULT;\n\t}\n\n\tif (ice->spdif.ops.open)\n\t\tice->spdif.ops.open(ice, substream);\n\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_pro_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tice->capture_pro_substream = substream;\n\truntime->hw = snd_ice1712_capture_pro;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n\tif (is_pro_rate_locked(ice)) {\n\t\truntime->hw.rate_min = PRO_RATE_DEFAULT;\n\t\truntime->hw.rate_max = PRO_RATE_DEFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ice1712_playback_pro_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 0);\n\tice->playback_pro_substream = NULL;\n\tif (ice->spdif.ops.close)\n\t\tice->spdif.ops.close(ice, substream);\n\n\treturn 0;\n}\n\nstatic int snd_ice1712_capture_pro_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 0);\n\tice->capture_pro_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ice1712_playback_pro_ops = {\n\t.open =\t\tsnd_ice1712_playback_pro_open,\n\t.close =\tsnd_ice1712_playback_pro_close,\n\t.hw_params =\tsnd_ice1712_playback_pro_hw_params,\n\t.prepare =\tsnd_ice1712_playback_pro_prepare,\n\t.trigger =\tsnd_ice1712_pro_trigger,\n\t.pointer =\tsnd_ice1712_playback_pro_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ice1712_capture_pro_ops = {\n\t.open =\t\tsnd_ice1712_capture_pro_open,\n\t.close =\tsnd_ice1712_capture_pro_close,\n\t.hw_params =\tsnd_ice1712_capture_pro_hw_params,\n\t.prepare =\tsnd_ice1712_capture_pro_prepare,\n\t.trigger =\tsnd_ice1712_pro_trigger,\n\t.pointer =\tsnd_ice1712_capture_pro_pointer,\n};\n\nstatic int snd_ice1712_pcm_profi(struct snd_ice1712 *ice, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(ice->card, \"ICE1712 multi\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ice1712_playback_pro_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ice1712_capture_pro_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ICE1712 multi\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 256*1024, 256*1024);\n\n\tice->pcm_pro = pcm;\n\n\tif (ice->cs8427) {\n\t\t \n\t\terr = snd_cs8427_iec958_build(ice->cs8427,\n\t\t\t\t\t      pcm->streams[0].substream,\n\t\t\t\t\t      pcm->streams[1].substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_ice1712_build_pro_mixer(ice);\n}\n\n \n\nstatic void snd_ice1712_update_volume(struct snd_ice1712 *ice, int index)\n{\n\tunsigned int vol = ice->pro_volumes[index];\n\tunsigned short val = 0;\n\n\tval |= (vol & 0x8000) == 0 ? (96 - (vol & 0x7f)) : 0x7f;\n\tval |= ((vol & 0x80000000) == 0 ? (96 - ((vol >> 16) & 0x7f)) : 0x7f) << 8;\n\toutb(index, ICEMT(ice, MONITOR_INDEX));\n\toutw(val, ICEMT(ice, MONITOR_VOLUME));\n}\n\n#define snd_ice1712_pro_mixer_switch_info\tsnd_ctl_boolean_stereo_info\n\nstatic int snd_ice1712_pro_mixer_switch_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\n\t\tkcontrol->private_value;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tucontrol->value.integer.value[0] =\n\t\t!((ice->pro_volumes[priv_idx] >> 15) & 1);\n\tucontrol->value.integer.value[1] =\n\t\t!((ice->pro_volumes[priv_idx] >> 31) & 1);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_mixer_switch_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\n\t\tkcontrol->private_value;\n\tunsigned int nval, change;\n\n\tnval = (ucontrol->value.integer.value[0] ? 0 : 0x00008000) |\n\t       (ucontrol->value.integer.value[1] ? 0 : 0x80000000);\n\tspin_lock_irq(&ice->reg_lock);\n\tnval |= ice->pro_volumes[priv_idx] & ~0x80008000;\n\tchange = nval != ice->pro_volumes[priv_idx];\n\tice->pro_volumes[priv_idx] = nval;\n\tsnd_ice1712_update_volume(ice, priv_idx);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic int snd_ice1712_pro_mixer_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 96;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_mixer_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\n\t\tkcontrol->private_value;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tucontrol->value.integer.value[0] =\n\t\t(ice->pro_volumes[priv_idx] >> 0) & 127;\n\tucontrol->value.integer.value[1] =\n\t\t(ice->pro_volumes[priv_idx] >> 16) & 127;\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_mixer_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint priv_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) +\n\t\tkcontrol->private_value;\n\tunsigned int nval, change;\n\n\tnval = (ucontrol->value.integer.value[0] & 127) |\n\t       ((ucontrol->value.integer.value[1] & 127) << 16);\n\tspin_lock_irq(&ice->reg_lock);\n\tnval |= ice->pro_volumes[priv_idx] & ~0x007f007f;\n\tchange = nval != ice->pro_volumes[priv_idx];\n\tice->pro_volumes[priv_idx] = nval;\n\tsnd_ice1712_update_volume(ice, priv_idx);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_playback, -14400, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_ice1712_multi_playback_ctrls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Multi Playback Switch\",\n\t\t.info = snd_ice1712_pro_mixer_switch_info,\n\t\t.get = snd_ice1712_pro_mixer_switch_get,\n\t\t.put = snd_ice1712_pro_mixer_switch_put,\n\t\t.private_value = 0,\n\t\t.count = 10,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Multi Playback Volume\",\n\t\t.info = snd_ice1712_pro_mixer_volume_info,\n\t\t.get = snd_ice1712_pro_mixer_volume_get,\n\t\t.put = snd_ice1712_pro_mixer_volume_put,\n\t\t.private_value = 0,\n\t\t.count = 10,\n\t\t.tlv = { .p = db_scale_playback }\n\t},\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_multi_capture_analog_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"H/W Multi Capture Switch\",\n\t.info = snd_ice1712_pro_mixer_switch_info,\n\t.get = snd_ice1712_pro_mixer_switch_get,\n\t.put = snd_ice1712_pro_mixer_switch_put,\n\t.private_value = 10,\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"Multi \", CAPTURE, SWITCH),\n\t.info = snd_ice1712_pro_mixer_switch_info,\n\t.get = snd_ice1712_pro_mixer_switch_get,\n\t.put = snd_ice1712_pro_mixer_switch_put,\n\t.private_value = 18,\n\t.count = 2,\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_multi_capture_analog_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name = \"H/W Multi Capture Volume\",\n\t.info = snd_ice1712_pro_mixer_volume_info,\n\t.get = snd_ice1712_pro_mixer_volume_get,\n\t.put = snd_ice1712_pro_mixer_volume_put,\n\t.private_value = 10,\n\t.tlv = { .p = db_scale_playback }\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"Multi \", CAPTURE, VOLUME),\n\t.info = snd_ice1712_pro_mixer_volume_info,\n\t.get = snd_ice1712_pro_mixer_volume_get,\n\t.put = snd_ice1712_pro_mixer_volume_put,\n\t.private_value = 18,\n\t.count = 2,\n};\n\nstatic int snd_ice1712_build_pro_mixer(struct snd_ice1712 *ice)\n{\n\tstruct snd_card *card = ice->card;\n\tunsigned int idx;\n\tint err;\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_ice1712_multi_playback_ctrls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_playback_ctrls[idx], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (ice->num_total_adcs > 0) {\n\t\tstruct snd_kcontrol_new tmp = snd_ice1712_multi_capture_analog_switch;\n\t\ttmp.count = ice->num_total_adcs;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&tmp, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_capture_spdif_switch, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ice->num_total_adcs > 0) {\n\t\tstruct snd_kcontrol_new tmp = snd_ice1712_multi_capture_analog_volume;\n\t\ttmp.count = ice->num_total_adcs;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&tmp, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ice1712_multi_capture_spdif_volume, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (idx = 0; idx < 10; idx++) {\n\t\tice->pro_volumes[idx] = 0x80008000;\t \n\t\tsnd_ice1712_update_volume(ice, idx);\n\t}\n\tfor (idx = 10; idx < 10 + ice->num_total_adcs; idx++) {\n\t\tice->pro_volumes[idx] = 0x80008000;\t \n\t\tsnd_ice1712_update_volume(ice, idx);\n\t}\n\tfor (idx = 18; idx < 20; idx++) {\n\t\tice->pro_volumes[idx] = 0x80008000;\t \n\t\tsnd_ice1712_update_volume(ice, idx);\n\t}\n\treturn 0;\n}\n\nstatic void snd_ice1712_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tice->ac97 = NULL;\n}\n\nstatic int snd_ice1712_ac97_mixer(struct snd_ice1712 *ice)\n{\n\tint err, bus_num = 0;\n\tstruct snd_ac97_template ac97;\n\tstruct snd_ac97_bus *pbus;\n\tstatic const struct snd_ac97_bus_ops con_ops = {\n\t\t.write = snd_ice1712_ac97_write,\n\t\t.read = snd_ice1712_ac97_read,\n\t};\n\tstatic const struct snd_ac97_bus_ops pro_ops = {\n\t\t.write = snd_ice1712_pro_ac97_write,\n\t\t.read = snd_ice1712_pro_ac97_read,\n\t};\n\n\tif (ice_has_con_ac97(ice)) {\n\t\terr = snd_ac97_bus(ice->card, bus_num++, &con_ops, NULL, &pbus);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = ice;\n\t\tac97.private_free = snd_ice1712_mixer_free_ac97;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\n\t\tif (err < 0)\n\t\t\tdev_warn(ice->card->dev,\n\t\t\t\t \"cannot initialize ac97 for consumer, skipped\\n\");\n\t\telse {\n\t\t\treturn snd_ctl_add(ice->card,\n\t\t\tsnd_ctl_new1(&snd_ice1712_mixer_digmix_route_ac97,\n\t\t\t\t     ice));\n\t\t}\n\t}\n\n\tif (!(ice->eeprom.data[ICE_EEP1_ACLINK] & ICE1712_CFG_PRO_I2S)) {\n\t\terr = snd_ac97_bus(ice->card, bus_num, &pro_ops, NULL, &pbus);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = ice;\n\t\tac97.private_free = snd_ice1712_mixer_free_ac97;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\n\t\tif (err < 0)\n\t\t\tdev_warn(ice->card->dev,\n\t\t\t\t \"cannot initialize pro ac97, skipped\\n\");\n\t\telse\n\t\t\treturn 0;\n\t}\n\t \n\tstrcat(ice->card->mixername, \"ICE1712 - multitrack\");\n\treturn 0;\n}\n\n \n\nstatic inline unsigned int eeprom_double(struct snd_ice1712 *ice, int idx)\n{\n\treturn (unsigned int)ice->eeprom.data[idx] | ((unsigned int)ice->eeprom.data[idx + 1] << 8);\n}\n\nstatic void snd_ice1712_proc_read(struct snd_info_entry *entry,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tunsigned int idx;\n\n\tsnd_iprintf(buffer, \"%s\\n\\n\", ice->card->longname);\n\tsnd_iprintf(buffer, \"EEPROM:\\n\");\n\n\tsnd_iprintf(buffer, \"  Subvendor        : 0x%x\\n\", ice->eeprom.subvendor);\n\tsnd_iprintf(buffer, \"  Size             : %i bytes\\n\", ice->eeprom.size);\n\tsnd_iprintf(buffer, \"  Version          : %i\\n\", ice->eeprom.version);\n\tsnd_iprintf(buffer, \"  Codec            : 0x%x\\n\", ice->eeprom.data[ICE_EEP1_CODEC]);\n\tsnd_iprintf(buffer, \"  ACLink           : 0x%x\\n\", ice->eeprom.data[ICE_EEP1_ACLINK]);\n\tsnd_iprintf(buffer, \"  I2S ID           : 0x%x\\n\", ice->eeprom.data[ICE_EEP1_I2SID]);\n\tsnd_iprintf(buffer, \"  S/PDIF           : 0x%x\\n\", ice->eeprom.data[ICE_EEP1_SPDIF]);\n\tsnd_iprintf(buffer, \"  GPIO mask        : 0x%x\\n\", ice->eeprom.gpiomask);\n\tsnd_iprintf(buffer, \"  GPIO state       : 0x%x\\n\", ice->eeprom.gpiostate);\n\tsnd_iprintf(buffer, \"  GPIO direction   : 0x%x\\n\", ice->eeprom.gpiodir);\n\tsnd_iprintf(buffer, \"  AC'97 main       : 0x%x\\n\", eeprom_double(ice, ICE_EEP1_AC97_MAIN_LO));\n\tsnd_iprintf(buffer, \"  AC'97 pcm        : 0x%x\\n\", eeprom_double(ice, ICE_EEP1_AC97_PCM_LO));\n\tsnd_iprintf(buffer, \"  AC'97 record     : 0x%x\\n\", eeprom_double(ice, ICE_EEP1_AC97_REC_LO));\n\tsnd_iprintf(buffer, \"  AC'97 record src : 0x%x\\n\", ice->eeprom.data[ICE_EEP1_AC97_RECSRC]);\n\tfor (idx = 0; idx < 4; idx++)\n\t\tsnd_iprintf(buffer, \"  DAC ID #%i        : 0x%x\\n\", idx, ice->eeprom.data[ICE_EEP1_DAC_ID + idx]);\n\tfor (idx = 0; idx < 4; idx++)\n\t\tsnd_iprintf(buffer, \"  ADC ID #%i        : 0x%x\\n\", idx, ice->eeprom.data[ICE_EEP1_ADC_ID + idx]);\n\tfor (idx = 0x1c; idx < ice->eeprom.size; idx++)\n\t\tsnd_iprintf(buffer, \"  Extra #%02i        : 0x%x\\n\", idx, ice->eeprom.data[idx]);\n\n\tsnd_iprintf(buffer, \"\\nRegisters:\\n\");\n\tsnd_iprintf(buffer, \"  PSDOUT03         : 0x%04x\\n\", (unsigned)inw(ICEMT(ice, ROUTE_PSDOUT03)));\n\tsnd_iprintf(buffer, \"  CAPTURE          : 0x%08x\\n\", inl(ICEMT(ice, ROUTE_CAPTURE)));\n\tsnd_iprintf(buffer, \"  SPDOUT           : 0x%04x\\n\", (unsigned)inw(ICEMT(ice, ROUTE_SPDOUT)));\n\tsnd_iprintf(buffer, \"  RATE             : 0x%02x\\n\", (unsigned)inb(ICEMT(ice, RATE)));\n\tsnd_iprintf(buffer, \"  GPIO_DATA        : 0x%02x\\n\", (unsigned)snd_ice1712_get_gpio_data(ice));\n\tsnd_iprintf(buffer, \"  GPIO_WRITE_MASK  : 0x%02x\\n\", (unsigned)snd_ice1712_read(ice, ICE1712_IREG_GPIO_WRITE_MASK));\n\tsnd_iprintf(buffer, \"  GPIO_DIRECTION   : 0x%02x\\n\", (unsigned)snd_ice1712_read(ice, ICE1712_IREG_GPIO_DIRECTION));\n}\n\nstatic void snd_ice1712_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_ro_proc_new(ice->card, \"ice1712\", ice, snd_ice1712_proc_read);\n}\n\n \n\nstatic int snd_ice1712_eeprom_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = sizeof(struct snd_ice1712_eeprom);\n\treturn 0;\n}\n\nstatic int snd_ice1712_eeprom_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmemcpy(ucontrol->value.bytes.data, &ice->eeprom, sizeof(ice->eeprom));\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_eeprom = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"ICE1712 EEPROM\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_ice1712_eeprom_info,\n\t.get = snd_ice1712_eeprom_get\n};\n\n \nstatic int snd_ice1712_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ice1712_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.default_get)\n\t\tice->spdif.ops.default_get(ice, ucontrol);\n\treturn 0;\n}\n\nstatic int snd_ice1712_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.default_put)\n\t\treturn ice->spdif.ops.default_put(ice, ucontrol);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_spdif_default =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t.info =\t\tsnd_ice1712_spdif_info,\n\t.get =\t\tsnd_ice1712_spdif_default_get,\n\t.put =\t\tsnd_ice1712_spdif_default_put\n};\n\nstatic int snd_ice1712_spdif_maskc_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.default_get) {\n\t\tucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\n\t\t\t\t\t\t     IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t\t     IEC958_AES0_CON_NOT_COPYRIGHT |\n\t\t\t\t\t\t     IEC958_AES0_CON_EMPHASIS;\n\t\tucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |\n\t\t\t\t\t\t     IEC958_AES1_CON_CATEGORY;\n\t\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\n\t} else {\n\t\tucontrol->value.iec958.status[0] = 0xff;\n\t\tucontrol->value.iec958.status[1] = 0xff;\n\t\tucontrol->value.iec958.status[2] = 0xff;\n\t\tucontrol->value.iec958.status[3] = 0xff;\n\t\tucontrol->value.iec958.status[4] = 0xff;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ice1712_spdif_maskp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.default_get) {\n\t\tucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\n\t\t\t\t\t\t     IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t\t     IEC958_AES0_PRO_FS |\n\t\t\t\t\t\t     IEC958_AES0_PRO_EMPHASIS;\n\t\tucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE;\n\t} else {\n\t\tucontrol->value.iec958.status[0] = 0xff;\n\t\tucontrol->value.iec958.status[1] = 0xff;\n\t\tucontrol->value.iec958.status[2] = 0xff;\n\t\tucontrol->value.iec958.status[3] = 0xff;\n\t\tucontrol->value.iec958.status[4] = 0xff;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_spdif_maskc =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t.info =\t\tsnd_ice1712_spdif_info,\n\t.get =\t\tsnd_ice1712_spdif_maskc_get,\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_spdif_maskp =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PRO_MASK),\n\t.info =\t\tsnd_ice1712_spdif_info,\n\t.get =\t\tsnd_ice1712_spdif_maskp_get,\n};\n\nstatic int snd_ice1712_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.stream_get)\n\t\tice->spdif.ops.stream_get(ice, ucontrol);\n\treturn 0;\n}\n\nstatic int snd_ice1712_spdif_stream_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tif (ice->spdif.ops.stream_put)\n\t\treturn ice->spdif.ops.stream_put(ice, ucontrol);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_spdif_stream =\n{\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE),\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PCM_STREAM),\n\t.info =\t\tsnd_ice1712_spdif_info,\n\t.get =\t\tsnd_ice1712_spdif_stream_get,\n\t.put =\t\tsnd_ice1712_spdif_stream_put\n};\n\nint snd_ice1712_gpio_get(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char mask = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value & (1<<24)) ? 1 : 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tucontrol->value.integer.value[0] =\n\t\t(snd_ice1712_gpio_read(ice) & mask ? 1 : 0) ^ invert;\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn 0;\n}\n\nint snd_ice1712_gpio_put(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char mask = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value & (1<<24)) ? mask : 0;\n\tunsigned int val, nval;\n\n\tif (kcontrol->private_value & (1 << 31))\n\t\treturn -EPERM;\n\tnval = (ucontrol->value.integer.value[0] ? mask : 0) ^ invert;\n\tsnd_ice1712_save_gpio_status(ice);\n\tval = snd_ice1712_gpio_read(ice);\n\tnval |= val & ~mask;\n\tif (val != nval)\n\t\tsnd_ice1712_gpio_write(ice, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn val != nval;\n}\n\n \nstatic int snd_ice1712_pro_internal_clock_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"8000\",\t\t \n\t\t\"9600\",\t\t \n\t\t\"11025\",\t \n\t\t\"12000\",\t \n\t\t\"16000\",\t \n\t\t\"22050\",\t \n\t\t\"24000\",\t \n\t\t\"32000\",\t \n\t\t\"44100\",\t \n\t\t\"48000\",\t \n\t\t\"64000\",\t \n\t\t\"88200\",\t \n\t\t\"96000\",\t \n\t\t\"IEC958 Input\",\t \n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 14, texts);\n}\n\nstatic int snd_ice1712_pro_internal_clock_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstatic const unsigned char xlate[16] = {\n\t\t9, 6, 3, 1, 7, 4, 0, 12, 8, 5, 2, 11, 255, 255, 255, 10\n\t};\n\tunsigned char val;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tif (is_spdif_master(ice)) {\n\t\tucontrol->value.enumerated.item[0] = 13;\n\t} else {\n\t\tval = xlate[inb(ICEMT(ice, RATE)) & 15];\n\t\tif (val == 255) {\n\t\t\tsnd_BUG();\n\t\t\tval = 0;\n\t\t}\n\t\tucontrol->value.enumerated.item[0] = val;\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_internal_clock_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstatic const unsigned int xrate[13] = {\n\t\t8000, 9600, 11025, 12000, 16000, 22050, 24000,\n\t\t32000, 44100, 48000, 64000, 88200, 96000\n\t};\n\tunsigned char oval;\n\tint change = 0;\n\n\tspin_lock_irq(&ice->reg_lock);\n\toval = inb(ICEMT(ice, RATE));\n\tif (ucontrol->value.enumerated.item[0] == 13) {\n\t\toutb(oval | ICE1712_SPDIF_MASTER, ICEMT(ice, RATE));\n\t} else {\n\t\tPRO_RATE_DEFAULT = xrate[ucontrol->value.integer.value[0] % 13];\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t\tsnd_ice1712_set_pro_rate(ice, PRO_RATE_DEFAULT, 1);\n\t\tspin_lock_irq(&ice->reg_lock);\n\t}\n\tchange = inb(ICEMT(ice, RATE)) != oval;\n\tspin_unlock_irq(&ice->reg_lock);\n\n\tif ((oval & ICE1712_SPDIF_MASTER) !=\n\t    (inb(ICEMT(ice, RATE)) & ICE1712_SPDIF_MASTER))\n\t\tsnd_ice1712_set_input_clock_source(ice, is_spdif_master(ice));\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_pro_internal_clock = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Internal Clock\",\n\t.info = snd_ice1712_pro_internal_clock_info,\n\t.get = snd_ice1712_pro_internal_clock_get,\n\t.put = snd_ice1712_pro_internal_clock_put\n};\n\nstatic int snd_ice1712_pro_internal_clock_default_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"8000\",\t\t \n\t\t\"9600\",\t\t \n\t\t\"11025\",\t \n\t\t\"12000\",\t \n\t\t\"16000\",\t \n\t\t\"22050\",\t \n\t\t\"24000\",\t \n\t\t\"32000\",\t \n\t\t\"44100\",\t \n\t\t\"48000\",\t \n\t\t\"64000\",\t \n\t\t\"88200\",\t \n\t\t\"96000\",\t \n\t\t \n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 13, texts);\n}\n\nstatic int snd_ice1712_pro_internal_clock_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint val;\n\tstatic const unsigned int xrate[13] = {\n\t\t8000, 9600, 11025, 12000, 16000, 22050, 24000,\n\t\t32000, 44100, 48000, 64000, 88200, 96000\n\t};\n\n\tfor (val = 0; val < 13; val++) {\n\t\tif (xrate[val] == PRO_RATE_DEFAULT)\n\t\t\tbreak;\n\t}\n\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_internal_clock_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstatic const unsigned int xrate[13] = {\n\t\t8000, 9600, 11025, 12000, 16000, 22050, 24000,\n\t\t32000, 44100, 48000, 64000, 88200, 96000\n\t};\n\tunsigned char oval;\n\tint change = 0;\n\n\toval = PRO_RATE_DEFAULT;\n\tPRO_RATE_DEFAULT = xrate[ucontrol->value.integer.value[0] % 13];\n\tchange = PRO_RATE_DEFAULT != oval;\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_pro_internal_clock_default = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Internal Clock Default\",\n\t.info = snd_ice1712_pro_internal_clock_default_info,\n\t.get = snd_ice1712_pro_internal_clock_default_get,\n\t.put = snd_ice1712_pro_internal_clock_default_put\n};\n\n#define snd_ice1712_pro_rate_locking_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ice1712_pro_rate_locking_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = PRO_RATE_LOCKED;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_rate_locking_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change = 0, nval;\n\n\tnval = ucontrol->value.integer.value[0] ? 1 : 0;\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = PRO_RATE_LOCKED != nval;\n\tPRO_RATE_LOCKED = nval;\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_pro_rate_locking = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Rate Locking\",\n\t.info = snd_ice1712_pro_rate_locking_info,\n\t.get = snd_ice1712_pro_rate_locking_get,\n\t.put = snd_ice1712_pro_rate_locking_put\n};\n\n#define snd_ice1712_pro_rate_reset_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ice1712_pro_rate_reset_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = PRO_RATE_RESET;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_rate_reset_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change = 0, nval;\n\n\tnval = ucontrol->value.integer.value[0] ? 1 : 0;\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = PRO_RATE_RESET != nval;\n\tPRO_RATE_RESET = nval;\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_pro_rate_reset = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Rate Reset\",\n\t.info = snd_ice1712_pro_rate_reset_info,\n\t.get = snd_ice1712_pro_rate_reset_get,\n\t.put = snd_ice1712_pro_rate_reset_put\n};\n\n \nstatic int snd_ice1712_pro_route_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"PCM Out\",  \n\t\t\"H/W In 0\", \"H/W In 1\", \"H/W In 2\", \"H/W In 3\",  \n\t\t\"H/W In 4\", \"H/W In 5\", \"H/W In 6\", \"H/W In 7\",  \n\t\t\"IEC958 In L\", \"IEC958 In R\",  \n\t\t\"Digital Mixer\",  \n\t};\n\tint num_items = snd_ctl_get_ioffidx(kcontrol, &uinfo->id) < 2 ? 12 : 11;\n\treturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\n}\n\nstatic int snd_ice1712_pro_route_analog_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val, cval;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tval = inw(ICEMT(ice, ROUTE_PSDOUT03));\n\tcval = inl(ICEMT(ice, ROUTE_CAPTURE));\n\tspin_unlock_irq(&ice->reg_lock);\n\n\tval >>= ((idx % 2) * 8) + ((idx / 2) * 2);\n\tval &= 3;\n\tcval >>= ((idx / 2) * 8) + ((idx % 2) * 4);\n\tif (val == 1 && idx < 2)\n\t\tucontrol->value.enumerated.item[0] = 11;\n\telse if (val == 2)\n\t\tucontrol->value.enumerated.item[0] = (cval & 7) + 1;\n\telse if (val == 3)\n\t\tucontrol->value.enumerated.item[0] = ((cval >> 3) & 1) + 9;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_route_analog_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change, shift;\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val, old_val, nval;\n\n\t \n\tif (ucontrol->value.enumerated.item[0] >= 11)\n\t\tnval = idx < 2 ? 1 : 0;  \n\telse if (ucontrol->value.enumerated.item[0] >= 9)\n\t\tnval = 3;  \n\telse if (ucontrol->value.enumerated.item[0] >= 1)\n\t\tnval = 2;  \n\telse\n\t\tnval = 0;  \n\tshift = ((idx % 2) * 8) + ((idx / 2) * 2);\n\tspin_lock_irq(&ice->reg_lock);\n\tval = old_val = inw(ICEMT(ice, ROUTE_PSDOUT03));\n\tval &= ~(0x03 << shift);\n\tval |= nval << shift;\n\tchange = val != old_val;\n\tif (change)\n\t\toutw(val, ICEMT(ice, ROUTE_PSDOUT03));\n\tspin_unlock_irq(&ice->reg_lock);\n\tif (nval < 2)  \n\t\treturn change;\n\n\t \n\tspin_lock_irq(&ice->reg_lock);\n\tval = old_val = inl(ICEMT(ice, ROUTE_CAPTURE));\n\tshift = ((idx / 2) * 8) + ((idx % 2) * 4);\n\tif (nval == 2) {  \n\t\tnval = ucontrol->value.enumerated.item[0] - 1;\n\t\tval &= ~(0x07 << shift);\n\t\tval |= nval << shift;\n\t} else {  \n\t\tnval = (ucontrol->value.enumerated.item[0] - 9) << 3;\n\t\tval &= ~(0x08 << shift);\n\t\tval |= nval << shift;\n\t}\n\tif (val != old_val) {\n\t\tchange = 1;\n\t\toutl(val, ICEMT(ice, ROUTE_CAPTURE));\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic int snd_ice1712_pro_route_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val, cval;\n\tval = inw(ICEMT(ice, ROUTE_SPDOUT));\n\tcval = (val >> (idx * 4 + 8)) & 0x0f;\n\tval = (val >> (idx * 2)) & 0x03;\n\tif (val == 1)\n\t\tucontrol->value.enumerated.item[0] = 11;\n\telse if (val == 2)\n\t\tucontrol->value.enumerated.item[0] = (cval & 7) + 1;\n\telse if (val == 3)\n\t\tucontrol->value.enumerated.item[0] = ((cval >> 3) & 1) + 9;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_route_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change, shift;\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val, old_val, nval;\n\n\t \n\tspin_lock_irq(&ice->reg_lock);\n\tval = old_val = inw(ICEMT(ice, ROUTE_SPDOUT));\n\tif (ucontrol->value.enumerated.item[0] >= 11)\n\t\tnval = 1;\n\telse if (ucontrol->value.enumerated.item[0] >= 9)\n\t\tnval = 3;\n\telse if (ucontrol->value.enumerated.item[0] >= 1)\n\t\tnval = 2;\n\telse\n\t\tnval = 0;\n\tshift = idx * 2;\n\tval &= ~(0x03 << shift);\n\tval |= nval << shift;\n\tshift = idx * 4 + 8;\n\tif (nval == 2) {\n\t\tnval = ucontrol->value.enumerated.item[0] - 1;\n\t\tval &= ~(0x07 << shift);\n\t\tval |= nval << shift;\n\t} else if (nval == 3) {\n\t\tnval = (ucontrol->value.enumerated.item[0] - 9) << 3;\n\t\tval &= ~(0x08 << shift);\n\t\tval |= nval << shift;\n\t}\n\tchange = val != old_val;\n\tif (change)\n\t\toutw(val, ICEMT(ice, ROUTE_SPDOUT));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_mixer_pro_analog_route = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"H/W Playback Route\",\n\t.info = snd_ice1712_pro_route_info,\n\t.get = snd_ice1712_pro_route_analog_get,\n\t.put = snd_ice1712_pro_route_analog_put,\n};\n\nstatic const struct snd_kcontrol_new snd_ice1712_mixer_pro_spdif_route = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, NONE) \"Route\",\n\t.info = snd_ice1712_pro_route_info,\n\t.get = snd_ice1712_pro_route_spdif_get,\n\t.put = snd_ice1712_pro_route_spdif_put,\n\t.count = 2,\n};\n\n\nstatic int snd_ice1712_pro_volume_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_volume_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = inb(ICEMT(ice, MONITOR_RATE));\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_volume_rate_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = inb(ICEMT(ice, MONITOR_RATE)) != ucontrol->value.integer.value[0];\n\toutb(ucontrol->value.integer.value[0], ICEMT(ice, MONITOR_RATE));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_mixer_pro_volume_rate = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Volume Rate\",\n\t.info = snd_ice1712_pro_volume_rate_info,\n\t.get = snd_ice1712_pro_volume_rate_get,\n\t.put = snd_ice1712_pro_volume_rate_put\n};\n\nstatic int snd_ice1712_pro_peak_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 22;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_ice1712_pro_peak_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tfor (idx = 0; idx < 22; idx++) {\n\t\toutb(idx, ICEMT(ice, MONITOR_PEAKINDEX));\n\t\tucontrol->value.integer.value[idx] = inb(ICEMT(ice, MONITOR_PEAKDATA));\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ice1712_mixer_pro_peak = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"Multi Track Peak\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info = snd_ice1712_pro_peak_info,\n\t.get = snd_ice1712_pro_peak_get\n};\n\n \n\n \nstatic const struct snd_ice1712_card_info *card_tables[] = {\n\tsnd_ice1712_hoontech_cards,\n\tsnd_ice1712_delta_cards,\n\tsnd_ice1712_ews_cards,\n\tNULL,\n};\n\nstatic unsigned char snd_ice1712_read_i2c(struct snd_ice1712 *ice,\n\t\t\t\t\t  unsigned char dev,\n\t\t\t\t\t  unsigned char addr)\n{\n\tlong t = 0x10000;\n\n\toutb(addr, ICEREG(ice, I2C_BYTE_ADDR));\n\toutb(dev & ~ICE1712_I2C_WRITE, ICEREG(ice, I2C_DEV_ADDR));\n\twhile (t-- > 0 && (inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_BUSY)) ;\n\treturn inb(ICEREG(ice, I2C_DATA));\n}\n\nstatic int snd_ice1712_read_eeprom(struct snd_ice1712 *ice,\n\t\t\t\t   const char *modelname)\n{\n\tint dev = ICE_I2C_EEPROM_ADDR;\t \n\tunsigned int i, size;\n\tconst struct snd_ice1712_card_info * const *tbl, *c;\n\n\tif (!modelname || !*modelname) {\n\t\tice->eeprom.subvendor = 0;\n\t\tif ((inb(ICEREG(ice, I2C_CTRL)) & ICE1712_I2C_EEPROM) != 0)\n\t\t\tice->eeprom.subvendor = (snd_ice1712_read_i2c(ice, dev, 0x00) << 0) |\n\t\t\t\t(snd_ice1712_read_i2c(ice, dev, 0x01) << 8) |\n\t\t\t\t(snd_ice1712_read_i2c(ice, dev, 0x02) << 16) |\n\t\t\t\t(snd_ice1712_read_i2c(ice, dev, 0x03) << 24);\n\t\tif (ice->eeprom.subvendor == 0 ||\n\t\t    ice->eeprom.subvendor == (unsigned int)-1) {\n\t\t\t \n\t\t\tu16 vendor, device;\n\t\t\tpci_read_config_word(ice->pci, PCI_SUBSYSTEM_VENDOR_ID, &vendor);\n\t\t\tpci_read_config_word(ice->pci, PCI_SUBSYSTEM_ID, &device);\n\t\t\tice->eeprom.subvendor = ((unsigned int)swab16(vendor) << 16) | swab16(device);\n\t\t\tif (ice->eeprom.subvendor == 0 || ice->eeprom.subvendor == (unsigned int)-1) {\n\t\t\t\tdev_err(ice->card->dev,\n\t\t\t\t\t\"No valid ID is found\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t}\n\t}\n\tfor (tbl = card_tables; *tbl; tbl++) {\n\t\tfor (c = *tbl; c->subvendor; c++) {\n\t\t\tif (modelname && c->model && !strcmp(modelname, c->model)) {\n\t\t\t\tdev_info(ice->card->dev,\n\t\t\t\t\t \"Using board model %s\\n\", c->name);\n\t\t\t\tice->eeprom.subvendor = c->subvendor;\n\t\t\t} else if (c->subvendor != ice->eeprom.subvendor)\n\t\t\t\tcontinue;\n\t\t\tif (!c->eeprom_size || !c->eeprom_data)\n\t\t\t\tgoto found;\n\t\t\t \n\t\t\tdev_dbg(ice->card->dev, \"using the defined eeprom..\\n\");\n\t\t\tice->eeprom.version = 1;\n\t\t\tice->eeprom.size = c->eeprom_size + 6;\n\t\t\tmemcpy(ice->eeprom.data, c->eeprom_data, c->eeprom_size);\n\t\t\tgoto read_skipped;\n\t\t}\n\t}\n\tdev_warn(ice->card->dev, \"No matching model found for ID 0x%x\\n\",\n\t       ice->eeprom.subvendor);\n\n found:\n\tice->eeprom.size = snd_ice1712_read_i2c(ice, dev, 0x04);\n\tif (ice->eeprom.size < 6)\n\t\tice->eeprom.size = 32;  \n\telse if (ice->eeprom.size > 32) {\n\t\tdev_err(ice->card->dev,\n\t\t\t\"invalid EEPROM (size = %i)\\n\", ice->eeprom.size);\n\t\treturn -EIO;\n\t}\n\tice->eeprom.version = snd_ice1712_read_i2c(ice, dev, 0x05);\n\tif (ice->eeprom.version != 1) {\n\t\tdev_err(ice->card->dev, \"invalid EEPROM version %i\\n\",\n\t\t\t   ice->eeprom.version);\n\t\t \n\t}\n\tsize = ice->eeprom.size - 6;\n\tfor (i = 0; i < size; i++)\n\t\tice->eeprom.data[i] = snd_ice1712_read_i2c(ice, dev, i + 6);\n\n read_skipped:\n\tice->eeprom.gpiomask = ice->eeprom.data[ICE_EEP1_GPIO_MASK];\n\tice->eeprom.gpiostate = ice->eeprom.data[ICE_EEP1_GPIO_STATE];\n\tice->eeprom.gpiodir = ice->eeprom.data[ICE_EEP1_GPIO_DIR];\n\n\treturn 0;\n}\n\n\n\nstatic int snd_ice1712_chip_init(struct snd_ice1712 *ice)\n{\n\toutb(ICE1712_RESET | ICE1712_NATIVE, ICEREG(ice, CONTROL));\n\tudelay(200);\n\toutb(ICE1712_NATIVE, ICEREG(ice, CONTROL));\n\tudelay(200);\n\tif (ice->eeprom.subvendor == ICE1712_SUBDEVICE_DMX6FIRE &&\n\t    !ice->dxr_enable)\n\t\t \n\t\tice->eeprom.data[ICE_EEP1_CODEC] = 0x3a;\n\tpci_write_config_byte(ice->pci, 0x60, ice->eeprom.data[ICE_EEP1_CODEC]);\n\tpci_write_config_byte(ice->pci, 0x61, ice->eeprom.data[ICE_EEP1_ACLINK]);\n\tpci_write_config_byte(ice->pci, 0x62, ice->eeprom.data[ICE_EEP1_I2SID]);\n\tpci_write_config_byte(ice->pci, 0x63, ice->eeprom.data[ICE_EEP1_SPDIF]);\n\tif (ice->eeprom.subvendor != ICE1712_SUBDEVICE_STDSP24 &&\n\t    ice->eeprom.subvendor != ICE1712_SUBDEVICE_STAUDIO_ADCIII) {\n\t\tice->gpio.write_mask = ice->eeprom.gpiomask;\n\t\tice->gpio.direction = ice->eeprom.gpiodir;\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK,\n\t\t\t\t  ice->eeprom.gpiomask);\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION,\n\t\t\t\t  ice->eeprom.gpiodir);\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA,\n\t\t\t\t  ice->eeprom.gpiostate);\n\t} else {\n\t\tice->gpio.write_mask = 0xc0;\n\t\tice->gpio.direction = 0xff;\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, 0xc0);\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, 0xff);\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA,\n\t\t\t\t  ICE1712_STDSP24_CLOCK_BIT);\n\t}\n\tsnd_ice1712_write(ice, ICE1712_IREG_PRO_POWERDOWN, 0);\n\tif (!(ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_NO_CON_AC97)) {\n\t\toutb(ICE1712_AC97_WARM, ICEREG(ice, AC97_CMD));\n\t\tudelay(100);\n\t\toutb(0, ICEREG(ice, AC97_CMD));\n\t\tudelay(200);\n\t\tsnd_ice1712_write(ice, ICE1712_IREG_CONSUMER_POWERDOWN, 0);\n\t}\n\tsnd_ice1712_set_pro_rate(ice, 48000, 1);\n\t \n\toutb(((ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_2xMPU401) == 0 ?\n\t      ICE1712_IRQ_MPU2 : 0) |\n\t     ((ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_NO_CON_AC97) ?\n\t      ICE1712_IRQ_PBKDS | ICE1712_IRQ_CONCAP | ICE1712_IRQ_CONPBK : 0),\n\t     ICEREG(ice, IRQMASK));\n\toutb(0x00, ICEMT(ice, IRQ));\n\n\treturn 0;\n}\n\nint snd_ice1712_spdif_build_controls(struct snd_ice1712 *ice)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!ice->pcm_pro))\n\t\treturn -EIO;\n\tkctl = snd_ctl_new1(&snd_ice1712_spdif_default, ice);\n\tkctl->id.device = ice->pcm_pro->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_ice1712_spdif_maskc, ice);\n\tkctl->id.device = ice->pcm_pro->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_ice1712_spdif_maskp, ice);\n\tkctl->id.device = ice->pcm_pro->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_ice1712_spdif_stream, ice);\n\tkctl->id.device = ice->pcm_pro->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tice->spdif.stream_ctl = kctl;\n\treturn 0;\n}\n\n\nstatic int snd_ice1712_build_controls(struct snd_ice1712 *ice)\n{\n\tint err;\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_eeprom, ice));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_internal_clock, ice));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_internal_clock_default, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_rate_locking, ice));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_pro_rate_reset, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ice->num_total_dacs > 0) {\n\t\tstruct snd_kcontrol_new tmp = snd_ice1712_mixer_pro_analog_route;\n\t\ttmp.count = ice->num_total_dacs;\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&tmp, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_pro_spdif_route, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_ice1712_mixer_pro_volume_rate, ice));\n\tif (err < 0)\n\t\treturn err;\n\treturn snd_ctl_add(ice->card,\n\t\t\t   snd_ctl_new1(&snd_ice1712_mixer_pro_peak, ice));\n}\n\nstatic void snd_ice1712_free(struct snd_card *card)\n{\n\tstruct snd_ice1712 *ice = card->private_data;\n\n\tif (ice->card_info && ice->card_info->chip_exit)\n\t\tice->card_info->chip_exit(ice);\n\n\t \n\toutb(ICE1712_MULTI_CAPTURE | ICE1712_MULTI_PLAYBACK, ICEMT(ice, IRQ));\n\toutb(0xff, ICEREG(ice, IRQMASK));\n\n\tsnd_ice1712_akm4xxx_free(ice);\n}\n\nstatic int snd_ice1712_create(struct snd_card *card,\n\t\t\t      struct pci_dev *pci,\n\t\t\t      const char *modelname,\n\t\t\t      int omni,\n\t\t\t      int cs8427_timeout,\n\t\t\t      int dxr_enable)\n{\n\tstruct snd_ice1712 *ice = card->private_data;\n\tint err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(28))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 28bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tice->omni = omni ? 1 : 0;\n\tif (cs8427_timeout < 1)\n\t\tcs8427_timeout = 1;\n\telse if (cs8427_timeout > 1000)\n\t\tcs8427_timeout = 1000;\n\tice->cs8427_timeout = cs8427_timeout;\n\tice->dxr_enable = dxr_enable;\n\tspin_lock_init(&ice->reg_lock);\n\tmutex_init(&ice->gpio_mutex);\n\tmutex_init(&ice->i2c_mutex);\n\tmutex_init(&ice->open_mutex);\n\tice->gpio.set_mask = snd_ice1712_set_gpio_mask;\n\tice->gpio.get_mask = snd_ice1712_get_gpio_mask;\n\tice->gpio.set_dir = snd_ice1712_set_gpio_dir;\n\tice->gpio.get_dir = snd_ice1712_get_gpio_dir;\n\tice->gpio.set_data = snd_ice1712_set_gpio_data;\n\tice->gpio.get_data = snd_ice1712_get_gpio_data;\n\n\tice->spdif.cs8403_bits =\n\t\tice->spdif.cs8403_stream_bits = (0x01 |\t \n\t\t\t\t\t\t 0x10 |\t \n\t\t\t\t\t\t 0x20);\t \n\tice->card = card;\n\tice->pci = pci;\n\tice->irq = -1;\n\tpci_set_master(pci);\n\t \n\tpci_write_config_word(ice->pci, 0x40, 0x807f);\n\tpci_write_config_word(ice->pci, 0x42, 0x0006);\n\tsnd_ice1712_proc_init(ice);\n\n\terr = pci_request_regions(pci, \"ICE1712\");\n\tif (err < 0)\n\t\treturn err;\n\tice->port = pci_resource_start(pci, 0);\n\tice->ddma_port = pci_resource_start(pci, 1);\n\tice->dmapath_port = pci_resource_start(pci, 2);\n\tice->profi_port = pci_resource_start(pci, 3);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_ice1712_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, ice)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EIO;\n\t}\n\n\tice->irq = pci->irq;\n\tcard->sync_irq = ice->irq;\n\tcard->private_free = snd_ice1712_free;\n\n\tif (snd_ice1712_read_eeprom(ice, modelname) < 0)\n\t\treturn -EIO;\n\tif (snd_ice1712_chip_init(ice) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n \n\nstatic struct snd_ice1712_card_info no_matched;\n\nstatic int snd_ice1712_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_ice1712 *ice;\n\tint pcm_dev = 0, err;\n\tconst struct snd_ice1712_card_info * const *tbl, *c;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(*ice), &card);\n\tif (err < 0)\n\t\treturn err;\n\tice = card->private_data;\n\n\tstrcpy(card->driver, \"ICE1712\");\n\tstrcpy(card->shortname, \"ICEnsemble ICE1712\");\n\n\terr = snd_ice1712_create(card, pci, model[dev], omni[dev],\n\t\t\t\t cs8427_timeout[dev], dxr_enable[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (tbl = card_tables; *tbl; tbl++) {\n\t\tfor (c = *tbl; c->subvendor; c++) {\n\t\t\tif (c->subvendor == ice->eeprom.subvendor) {\n\t\t\t\tstrcpy(card->shortname, c->name);\n\t\t\t\tif (c->driver)  \n\t\t\t\t\tstrcpy(card->driver, c->driver);\n\t\t\t\tif (c->chip_init) {\n\t\t\t\t\terr = c->chip_init(ice);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tice->card_info = c;\n\t\t\t\tgoto __found;\n\t\t\t}\n\t\t}\n\t}\n\tc = &no_matched;\n __found:\n\n\terr = snd_ice1712_pcm_profi(ice, pcm_dev++);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ice_has_con_ac97(ice)) {\n\t\terr = snd_ice1712_pcm(ice, pcm_dev++);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_ice1712_ac97_mixer(ice);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ice1712_build_controls(ice);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (c->build_controls) {\n\t\terr = c->build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (ice_has_con_ac97(ice)) {\n\t\terr = snd_ice1712_pcm_ds(ice, pcm_dev++);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!c->no_mpu401) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_ICE1712,\n\t\t\tICEREG(ice, MPU1_CTRL),\n\t\t\tc->mpu401_1_info_flags |\n\t\t\tMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\n\t\t\t-1, &ice->rmidi[0]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (c->mpu401_1_name)\n\t\t\t \n\t\t\tsnprintf(ice->rmidi[0]->name,\n\t\t\t\t sizeof(ice->rmidi[0]->name),\n\t\t\t\t \"%s %d\", c->mpu401_1_name, card->number);\n\n\t\tif (ice->eeprom.data[ICE_EEP1_CODEC] & ICE1712_CFG_2xMPU401) {\n\t\t\t \n\t\t\terr = snd_mpu401_uart_new(card, 1, MPU401_HW_ICE1712,\n\t\t\t\tICEREG(ice, MPU2_CTRL),\n\t\t\t\tc->mpu401_2_info_flags |\n\t\t\t\tMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\n\t\t\t\t-1, &ice->rmidi[1]);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (c->mpu401_2_name)\n\t\t\t\t \n\t\t\t\tsnprintf(ice->rmidi[1]->name,\n\t\t\t\t\t sizeof(ice->rmidi[1]->name),\n\t\t\t\t\t \"%s %d\", c->mpu401_2_name,\n\t\t\t\t\t card->number);\n\t\t}\n\t}\n\n\tsnd_ice1712_set_input_clock_source(ice, 0);\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, ice->port, ice->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_ice1712_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ice1712 *ice = card->private_data;\n\n\tif (!ice->pm_suspend_enabled)\n\t\treturn 0;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tsnd_ac97_suspend(ice->ac97);\n\n\tspin_lock_irq(&ice->reg_lock);\n\tice->pm_saved_is_spdif_master = is_spdif_master(ice);\n\tice->pm_saved_spdif_ctrl = inw(ICEMT(ice, ROUTE_SPDOUT));\n\tice->pm_saved_route = inw(ICEMT(ice, ROUTE_PSDOUT03));\n\tspin_unlock_irq(&ice->reg_lock);\n\n\tif (ice->pm_suspend)\n\t\tice->pm_suspend(ice);\n\treturn 0;\n}\n\nstatic int snd_ice1712_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ice1712 *ice = card->private_data;\n\tint rate;\n\n\tif (!ice->pm_suspend_enabled)\n\t\treturn 0;\n\n\tif (ice->cur_rate)\n\t\trate = ice->cur_rate;\n\telse\n\t\trate = PRO_RATE_DEFAULT;\n\n\tif (snd_ice1712_chip_init(ice) < 0) {\n\t\tsnd_card_disconnect(card);\n\t\treturn -EIO;\n\t}\n\n\tice->cur_rate = rate;\n\n\tif (ice->pm_resume)\n\t\tice->pm_resume(ice);\n\n\tif (ice->pm_saved_is_spdif_master) {\n\t\t \n\t\tspin_lock_irq(&ice->reg_lock);\n\t\toutb(inb(ICEMT(ice, RATE)) | ICE1712_SPDIF_MASTER,\n\t\t\tICEMT(ice, RATE));\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t\tsnd_ice1712_set_input_clock_source(ice, 1);\n\t} else {\n\t\t \n\t\tsnd_ice1712_set_pro_rate(ice, rate, 1);\n\t\tsnd_ice1712_set_input_clock_source(ice, 0);\n\t}\n\n\toutw(ice->pm_saved_spdif_ctrl, ICEMT(ice, ROUTE_SPDOUT));\n\toutw(ice->pm_saved_route, ICEMT(ice, ROUTE_PSDOUT03));\n\n\tsnd_ac97_resume(ice->ac97);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_ice1712_pm, snd_ice1712_suspend, snd_ice1712_resume);\n#define SND_VT1712_PM_OPS\t&snd_ice1712_pm\n#else\n#define SND_VT1712_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver ice1712_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_ice1712_ids,\n\t.probe = snd_ice1712_probe,\n\t.driver = {\n\t\t.pm = SND_VT1712_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(ice1712_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}