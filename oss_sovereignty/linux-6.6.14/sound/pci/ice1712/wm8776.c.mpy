{
  "module_name": "wm8776.c",
  "hash_id": "7cc2cd0d0b21a0d396bbddd52d7ab1762573535cb21c15960b524a6fb61a4511",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/wm8776.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"wm8776.h\"\n\n \n\nstatic void snd_wm8776_write(struct snd_wm8776 *wm, u16 addr, u16 data)\n{\n\tu8 bus_addr = addr << 1 | data >> 8;\t \n\tu8 bus_data = data & 0xff;\t\t \n\n\tif (addr < WM8776_REG_RESET)\n\t\twm->regs[addr] = data;\n\twm->ops.write(wm, bus_addr, bus_data);\n}\n\n \n\nstatic void snd_wm8776_activate_ctl(struct snd_wm8776 *wm,\n\t\t\t\t    const char *ctl_name,\n\t\t\t\t    bool active)\n{\n\tstruct snd_card *card = wm->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\n\tkctl = snd_ctl_find_id_mixer(card, ctl_name);\n\tif (!kctl)\n\t\treturn;\n\tindex_offset = snd_ctl_get_ioff(kctl, &kctl->id);\n\tvd = &kctl->vd[index_offset];\n\tif (active)\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\telse\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\n}\n\nstatic void snd_wm8776_update_agc_ctl(struct snd_wm8776 *wm)\n{\n\tint i, flags_on = 0, flags_off = 0;\n\n\tswitch (wm->agc_mode) {\n\tcase WM8776_AGC_OFF:\n\t\tflags_off = WM8776_FLAG_LIM | WM8776_FLAG_ALC;\n\t\tbreak;\n\tcase WM8776_AGC_LIM:\n\t\tflags_off = WM8776_FLAG_ALC;\n\t\tflags_on = WM8776_FLAG_LIM;\n\t\tbreak;\n\tcase WM8776_AGC_ALC_R:\n\tcase WM8776_AGC_ALC_L:\n\tcase WM8776_AGC_ALC_STEREO:\n\t\tflags_off = WM8776_FLAG_LIM;\n\t\tflags_on = WM8776_FLAG_ALC;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < WM8776_CTL_COUNT; i++)\n\t\tif (wm->ctl[i].flags & flags_off)\n\t\t\tsnd_wm8776_activate_ctl(wm, wm->ctl[i].name, false);\n\t\telse if (wm->ctl[i].flags & flags_on)\n\t\t\tsnd_wm8776_activate_ctl(wm, wm->ctl[i].name, true);\n}\n\nstatic void snd_wm8776_set_agc(struct snd_wm8776 *wm, u16 agc, u16 nothing)\n{\n\tu16 alc1 = wm->regs[WM8776_REG_ALCCTRL1] & ~WM8776_ALC1_LCT_MASK;\n\tu16 alc2 = wm->regs[WM8776_REG_ALCCTRL2] & ~WM8776_ALC2_LCEN;\n\n\tswitch (agc) {\n\tcase 0:\t \n\t\twm->agc_mode = WM8776_AGC_OFF;\n\t\tbreak;\n\tcase 1:  \n\t\talc2 |= WM8776_ALC2_LCEN;\n\t\twm->agc_mode = WM8776_AGC_LIM;\n\t\tbreak;\n\tcase 2:  \n\t\talc1 |= WM8776_ALC1_LCSEL_ALCR;\n\t\talc2 |= WM8776_ALC2_LCEN;\n\t\twm->agc_mode = WM8776_AGC_ALC_R;\n\t\tbreak;\n\tcase 3:  \n\t\talc1 |= WM8776_ALC1_LCSEL_ALCL;\n\t\talc2 |= WM8776_ALC2_LCEN;\n\t\twm->agc_mode = WM8776_AGC_ALC_L;\n\t\tbreak;\n\tcase 4:  \n\t\talc1 |= WM8776_ALC1_LCSEL_ALCSTEREO;\n\t\talc2 |= WM8776_ALC2_LCEN;\n\t\twm->agc_mode = WM8776_AGC_ALC_STEREO;\n\t\tbreak;\n\t}\n\tsnd_wm8776_write(wm, WM8776_REG_ALCCTRL1, alc1);\n\tsnd_wm8776_write(wm, WM8776_REG_ALCCTRL2, alc2);\n\tsnd_wm8776_update_agc_ctl(wm);\n}\n\nstatic void snd_wm8776_get_agc(struct snd_wm8776 *wm, u16 *mode, u16 *nothing)\n{\n\t*mode = wm->agc_mode;\n}\n\n \n\nstatic const DECLARE_TLV_DB_SCALE(wm8776_hp_tlv, -7400, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_dac_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_adc_tlv, -10350, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_lct_tlv, -1600, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxgain_tlv, 0, 400, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_ngth_tlv, -7800, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxatten_lim_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxatten_alc_tlv, -2100, 400, 0);\n\nstatic const struct snd_wm8776_ctl snd_wm8776_default_ctl[WM8776_CTL_COUNT] = {\n\t[WM8776_CTL_DAC_VOL] = {\n\t\t.name = \"Master Playback Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_dac_tlv,\n\t\t.reg1 = WM8776_REG_DACLVOL,\n\t\t.reg2 = WM8776_REG_DACRVOL,\n\t\t.mask1 = WM8776_DACVOL_MASK,\n\t\t.mask2 = WM8776_DACVOL_MASK,\n\t\t.max = 0xff,\n\t\t.flags = WM8776_FLAG_STEREO | WM8776_FLAG_VOL_UPDATE,\n\t},\n\t[WM8776_CTL_DAC_SW] = {\n\t\t.name = \"Master Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_DACCTRL1,\n\t\t.reg2 = WM8776_REG_DACCTRL1,\n\t\t.mask1 = WM8776_DAC_PL_LL,\n\t\t.mask2 = WM8776_DAC_PL_RR,\n\t\t.flags = WM8776_FLAG_STEREO,\n\t},\n\t[WM8776_CTL_DAC_ZC_SW] = {\n\t\t.name = \"Master Zero Cross Detect Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_DACCTRL1,\n\t\t.mask1 = WM8776_DAC_DZCEN,\n\t},\n\t[WM8776_CTL_HP_VOL] = {\n\t\t.name = \"Headphone Playback Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_hp_tlv,\n\t\t.reg1 = WM8776_REG_HPLVOL,\n\t\t.reg2 = WM8776_REG_HPRVOL,\n\t\t.mask1 = WM8776_HPVOL_MASK,\n\t\t.mask2 = WM8776_HPVOL_MASK,\n\t\t.min = 0x2f,\n\t\t.max = 0x7f,\n\t\t.flags = WM8776_FLAG_STEREO | WM8776_FLAG_VOL_UPDATE,\n\t},\n\t[WM8776_CTL_HP_SW] = {\n\t\t.name = \"Headphone Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_PWRDOWN,\n\t\t.mask1 = WM8776_PWR_HPPD,\n\t\t.flags = WM8776_FLAG_INVERT,\n\t},\n\t[WM8776_CTL_HP_ZC_SW] = {\n\t\t.name = \"Headphone Zero Cross Detect Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_HPLVOL,\n\t\t.reg2 = WM8776_REG_HPRVOL,\n\t\t.mask1 = WM8776_VOL_HPZCEN,\n\t\t.mask2 = WM8776_VOL_HPZCEN,\n\t\t.flags = WM8776_FLAG_STEREO,\n\t},\n\t[WM8776_CTL_AUX_SW] = {\n\t\t.name = \"AUX Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_OUTMUX,\n\t\t.mask1 = WM8776_OUTMUX_AUX,\n\t},\n\t[WM8776_CTL_BYPASS_SW] = {\n\t\t.name = \"Bypass Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_OUTMUX,\n\t\t.mask1 = WM8776_OUTMUX_BYPASS,\n\t},\n\t[WM8776_CTL_DAC_IZD_SW] = {\n\t\t.name = \"Infinite Zero Detect Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_DACCTRL1,\n\t\t.mask1 = WM8776_DAC_IZD,\n\t},\n\t[WM8776_CTL_PHASE_SW] = {\n\t\t.name = \"Phase Invert Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_PHASESWAP,\n\t\t.reg2 = WM8776_REG_PHASESWAP,\n\t\t.mask1 = WM8776_PHASE_INVERTL,\n\t\t.mask2 = WM8776_PHASE_INVERTR,\n\t\t.flags = WM8776_FLAG_STEREO,\n\t},\n\t[WM8776_CTL_DEEMPH_SW] = {\n\t\t.name = \"Deemphasis Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_DACCTRL2,\n\t\t.mask1 = WM8776_DAC2_DEEMPH,\n\t},\n\t[WM8776_CTL_ADC_VOL] = {\n\t\t.name = \"Input Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_adc_tlv,\n\t\t.reg1 = WM8776_REG_ADCLVOL,\n\t\t.reg2 = WM8776_REG_ADCRVOL,\n\t\t.mask1 = WM8776_ADC_GAIN_MASK,\n\t\t.mask2 = WM8776_ADC_GAIN_MASK,\n\t\t.max = 0xff,\n\t\t.flags = WM8776_FLAG_STEREO | WM8776_FLAG_VOL_UPDATE,\n\t},\n\t[WM8776_CTL_ADC_SW] = {\n\t\t.name = \"Input Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.reg2 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUTEL,\n\t\t.mask2 = WM8776_ADC_MUTER,\n\t\t.flags = WM8776_FLAG_STEREO | WM8776_FLAG_INVERT,\n\t},\n\t[WM8776_CTL_INPUT1_SW] = {\n\t\t.name = \"AIN1 Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUX_AIN1,\n\t},\n\t[WM8776_CTL_INPUT2_SW] = {\n\t\t.name = \"AIN2 Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUX_AIN2,\n\t},\n\t[WM8776_CTL_INPUT3_SW] = {\n\t\t.name = \"AIN3 Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUX_AIN3,\n\t},\n\t[WM8776_CTL_INPUT4_SW] = {\n\t\t.name = \"AIN4 Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUX_AIN4,\n\t},\n\t[WM8776_CTL_INPUT5_SW] = {\n\t\t.name = \"AIN5 Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_ADCMUX,\n\t\t.mask1 = WM8776_ADC_MUX_AIN5,\n\t},\n\t[WM8776_CTL_AGC_SEL] = {\n\t\t.name = \"AGC Select Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = { \"Off\", \"Limiter\", \"ALC Right\", \"ALC Left\",\n\t\t\t\t\"ALC Stereo\" },\n\t\t.max = 5,\t \n\t\t.set = snd_wm8776_set_agc,\n\t\t.get = snd_wm8776_get_agc,\n\t},\n\t[WM8776_CTL_LIM_THR] = {\n\t\t.name = \"Limiter Threshold Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_lct_tlv,\n\t\t.reg1 = WM8776_REG_ALCCTRL1,\n\t\t.mask1 = WM8776_ALC1_LCT_MASK,\n\t\t.max = 15,\n\t\t.flags = WM8776_FLAG_LIM,\n\t},\n\t[WM8776_CTL_LIM_ATK] = {\n\t\t.name = \"Limiter Attack Time Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = { \"0.25 ms\", \"0.5 ms\", \"1 ms\", \"2 ms\", \"4 ms\",\n\t\t\t\"8 ms\", \"16 ms\", \"32 ms\", \"64 ms\", \"128 ms\", \"256 ms\" },\n\t\t.max = 11,\t \n\t\t.reg1 = WM8776_REG_ALCCTRL3,\n\t\t.mask1 = WM8776_ALC3_ATK_MASK,\n\t\t.flags = WM8776_FLAG_LIM,\n\t},\n\t[WM8776_CTL_LIM_DCY] = {\n\t\t.name = \"Limiter Decay Time Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = {\t\"1.2 ms\", \"2.4 ms\", \"4.8 ms\", \"9.6 ms\",\n\t\t\t\"19.2 ms\", \"38.4 ms\", \"76.8 ms\", \"154 ms\", \"307 ms\",\n\t\t\t\"614 ms\", \"1.23 s\" },\n\t\t.max = 11,\t \n\t\t.reg1 = WM8776_REG_ALCCTRL3,\n\t\t.mask1 = WM8776_ALC3_DCY_MASK,\n\t\t.flags = WM8776_FLAG_LIM,\n\t},\n\t[WM8776_CTL_LIM_TRANWIN] = {\n\t\t.name = \"Limiter Transient Window Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = {\t\"0 us\", \"62.5 us\", \"125 us\", \"250 us\", \"500 us\",\n\t\t\t\"1 ms\", \"2 ms\", \"4 ms\" },\n\t\t.max = 8,\t \n\t\t.reg1 = WM8776_REG_LIMITER,\n\t\t.mask1 = WM8776_LIM_TRANWIN_MASK,\n\t\t.flags = WM8776_FLAG_LIM,\n\t},\n\t[WM8776_CTL_LIM_MAXATTN] = {\n\t\t.name = \"Limiter Maximum Attenuation Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_maxatten_lim_tlv,\n\t\t.reg1 = WM8776_REG_LIMITER,\n\t\t.mask1 = WM8776_LIM_MAXATTEN_MASK,\n\t\t.min = 3,\n\t\t.max = 12,\n\t\t.flags = WM8776_FLAG_LIM | WM8776_FLAG_INVERT,\n\t},\n\t[WM8776_CTL_ALC_TGT] = {\n\t\t.name = \"ALC Target Level Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_lct_tlv,\n\t\t.reg1 = WM8776_REG_ALCCTRL1,\n\t\t.mask1 = WM8776_ALC1_LCT_MASK,\n\t\t.max = 15,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_ALC_ATK] = {\n\t\t.name = \"ALC Attack Time Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = { \"8.40 ms\", \"16.8 ms\", \"33.6 ms\", \"67.2 ms\",\n\t\t\t\"134 ms\", \"269 ms\", \"538 ms\", \"1.08 s\",\t\"2.15 s\",\n\t\t\t\"4.3 s\", \"8.6 s\" },\n\t\t.max = 11,\t \n\t\t.reg1 = WM8776_REG_ALCCTRL3,\n\t\t.mask1 = WM8776_ALC3_ATK_MASK,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_ALC_DCY] = {\n\t\t.name = \"ALC Decay Time Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = {\t\"33.5 ms\", \"67.0 ms\", \"134 ms\", \"268 ms\",\n\t\t\t\"536 ms\", \"1.07 s\", \"2.14 s\", \"4.29 s\",\t\"8.58 s\",\n\t\t\t\"17.2 s\", \"34.3 s\" },\n\t\t.max = 11,\t \n\t\t.reg1 = WM8776_REG_ALCCTRL3,\n\t\t.mask1 = WM8776_ALC3_DCY_MASK,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_ALC_MAXGAIN] = {\n\t\t.name = \"ALC Maximum Gain Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_maxgain_tlv,\n\t\t.reg1 = WM8776_REG_ALCCTRL1,\n\t\t.mask1 = WM8776_ALC1_MAXGAIN_MASK,\n\t\t.min = 1,\n\t\t.max = 7,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_ALC_MAXATTN] = {\n\t\t.name = \"ALC Maximum Attenuation Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_maxatten_alc_tlv,\n\t\t.reg1 = WM8776_REG_LIMITER,\n\t\t.mask1 = WM8776_LIM_MAXATTEN_MASK,\n\t\t.min = 10,\n\t\t.max = 15,\n\t\t.flags = WM8776_FLAG_ALC | WM8776_FLAG_INVERT,\n\t},\n\t[WM8776_CTL_ALC_HLD] = {\n\t\t.name = \"ALC Hold Time Capture Enum\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_ENUMERATED,\n\t\t.enum_names = {\t\"0 ms\", \"2.67 ms\", \"5.33 ms\", \"10.6 ms\",\n\t\t\t\"21.3 ms\", \"42.7 ms\", \"85.3 ms\", \"171 ms\", \"341 ms\",\n\t\t\t\"683 ms\", \"1.37 s\", \"2.73 s\", \"5.46 s\", \"10.9 s\",\n\t\t\t\"21.8 s\", \"43.7 s\" },\n\t\t.max = 16,\t \n\t\t.reg1 = WM8776_REG_ALCCTRL2,\n\t\t.mask1 = WM8776_ALC2_HOLD_MASK,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_NGT_SW] = {\n\t\t.name = \"Noise Gate Capture Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8776_REG_NOISEGATE,\n\t\t.mask1 = WM8776_NGAT_ENABLE,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n\t[WM8776_CTL_NGT_THR] = {\n\t\t.name = \"Noise Gate Threshold Capture Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8776_ngth_tlv,\n\t\t.reg1 = WM8776_REG_NOISEGATE,\n\t\t.mask1 = WM8776_NGAT_THR_MASK,\n\t\t.max = 7,\n\t\t.flags = WM8776_FLAG_ALC,\n\t},\n};\n\n \n\nvoid snd_wm8776_init(struct snd_wm8776 *wm)\n{\n\tint i;\n\tstatic const u16 default_values[] = {\n\t\t0x000, 0x100, 0x000,\n\t\t0x000, 0x100, 0x000,\n\t\t0x000, 0x090, 0x000, 0x000,\n\t\t0x022, 0x022, 0x022,\n\t\t0x008, 0x0cf, 0x0cf, 0x07b, 0x000,\n\t\t0x032, 0x000, 0x0a6, 0x001, 0x001\n\t};\n\n\tmemcpy(wm->ctl, snd_wm8776_default_ctl, sizeof(wm->ctl));\n\n\tsnd_wm8776_write(wm, WM8776_REG_RESET, 0x00);  \n\tudelay(10);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(default_values); i++)\n\t\tsnd_wm8776_write(wm, i, default_values[i]);\n}\n\nvoid snd_wm8776_resume(struct snd_wm8776 *wm)\n{\n\tint i;\n\n\tfor (i = 0; i < WM8776_REG_COUNT; i++)\n\t\tsnd_wm8776_write(wm, i, wm->regs[i]);\n}\n\nvoid snd_wm8776_set_power(struct snd_wm8776 *wm, u16 power)\n{\n\tsnd_wm8776_write(wm, WM8776_REG_PWRDOWN, power);\n}\n\nvoid snd_wm8776_volume_restore(struct snd_wm8776 *wm)\n{\n\tu16 val = wm->regs[WM8776_REG_DACRVOL];\n\t \n\tsnd_wm8776_write(wm, WM8776_REG_DACRVOL, val | WM8776_VOL_UPDATE);\n}\n\n \n\nstatic int snd_wm8776_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_wm8776 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = (wm->ctl[n].flags & WM8776_FLAG_STEREO) ? 2 : 1;\n\tuinfo->value.integer.min = wm->ctl[n].min;\n\tuinfo->value.integer.max = wm->ctl[n].max;\n\n\treturn 0;\n}\n\nstatic int snd_wm8776_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_wm8776 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\n\treturn snd_ctl_enum_info(uinfo, 1, wm->ctl[n].max,\n\t\t\t\t\t\twm->ctl[n].enum_names);\n}\n\nstatic int snd_wm8776_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wm8776 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\tu16 val1, val2;\n\n\tif (wm->ctl[n].get)\n\t\twm->ctl[n].get(wm, &val1, &val2);\n\telse {\n\t\tval1 = wm->regs[wm->ctl[n].reg1] & wm->ctl[n].mask1;\n\t\tval1 >>= __ffs(wm->ctl[n].mask1);\n\t\tif (wm->ctl[n].flags & WM8776_FLAG_STEREO) {\n\t\t\tval2 = wm->regs[wm->ctl[n].reg2] & wm->ctl[n].mask2;\n\t\t\tval2 >>= __ffs(wm->ctl[n].mask2);\n\t\t\tif (wm->ctl[n].flags & WM8776_FLAG_VOL_UPDATE)\n\t\t\t\tval2 &= ~WM8776_VOL_UPDATE;\n\t\t}\n\t}\n\tif (wm->ctl[n].flags & WM8776_FLAG_INVERT) {\n\t\tval1 = wm->ctl[n].max - (val1 - wm->ctl[n].min);\n\t\tif (wm->ctl[n].flags & WM8776_FLAG_STEREO)\n\t\t\tval2 = wm->ctl[n].max - (val2 - wm->ctl[n].min);\n\t}\n\tucontrol->value.integer.value[0] = val1;\n\tif (wm->ctl[n].flags & WM8776_FLAG_STEREO)\n\t\tucontrol->value.integer.value[1] = val2;\n\n\treturn 0;\n}\n\nstatic int snd_wm8776_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wm8776 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\tu16 val, regval1, regval2;\n\n\t \n\tregval1 = ucontrol->value.integer.value[0];\n\tregval2 = ucontrol->value.integer.value[1];\n\tif (wm->ctl[n].flags & WM8776_FLAG_INVERT) {\n\t\tregval1 = wm->ctl[n].max - (regval1 - wm->ctl[n].min);\n\t\tregval2 = wm->ctl[n].max - (regval2 - wm->ctl[n].min);\n\t}\n\tif (wm->ctl[n].set)\n\t\twm->ctl[n].set(wm, regval1, regval2);\n\telse {\n\t\tval = wm->regs[wm->ctl[n].reg1] & ~wm->ctl[n].mask1;\n\t\tval |= regval1 << __ffs(wm->ctl[n].mask1);\n\t\t \n\t\tif (wm->ctl[n].flags & WM8776_FLAG_STEREO &&\n\t\t\t\twm->ctl[n].reg1 == wm->ctl[n].reg2) {\n\t\t\tval &= ~wm->ctl[n].mask2;\n\t\t\tval |= regval2 << __ffs(wm->ctl[n].mask2);\n\t\t}\n\t\tsnd_wm8776_write(wm, wm->ctl[n].reg1, val);\n\t\t \n\t\tif (wm->ctl[n].flags & WM8776_FLAG_STEREO &&\n\t\t\t\twm->ctl[n].reg1 != wm->ctl[n].reg2) {\n\t\t\tval = wm->regs[wm->ctl[n].reg2] & ~wm->ctl[n].mask2;\n\t\t\tval |= regval2 << __ffs(wm->ctl[n].mask2);\n\t\t\tif (wm->ctl[n].flags & WM8776_FLAG_VOL_UPDATE)\n\t\t\t\tval |= WM8776_VOL_UPDATE;\n\t\t\tsnd_wm8776_write(wm, wm->ctl[n].reg2, val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_wm8776_add_control(struct snd_wm8776 *wm, int num)\n{\n\tstruct snd_kcontrol_new cont;\n\tstruct snd_kcontrol *ctl;\n\n\tmemset(&cont, 0, sizeof(cont));\n\tcont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tcont.private_value = num;\n\tcont.name = wm->ctl[num].name;\n\tcont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tif (wm->ctl[num].flags & WM8776_FLAG_LIM ||\n\t    wm->ctl[num].flags & WM8776_FLAG_ALC)\n\t\tcont.access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tcont.tlv.p = NULL;\n\tcont.get = snd_wm8776_ctl_get;\n\tcont.put = snd_wm8776_ctl_put;\n\n\tswitch (wm->ctl[num].type) {\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tcont.info = snd_wm8776_volume_info;\n\t\tcont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tcont.tlv.p = wm->ctl[num].tlv;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\t\twm->ctl[num].max = 1;\n\t\tif (wm->ctl[num].flags & WM8776_FLAG_STEREO)\n\t\t\tcont.info = snd_ctl_boolean_stereo_info;\n\t\telse\n\t\t\tcont.info = snd_ctl_boolean_mono_info;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tcont.info = snd_wm8776_enum_info;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctl = snd_ctl_new1(&cont, wm);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\n\treturn snd_ctl_add(wm->card, ctl);\n}\n\nint snd_wm8776_build_controls(struct snd_wm8776 *wm)\n{\n\tint err, i;\n\n\tfor (i = 0; i < WM8776_CTL_COUNT; i++)\n\t\tif (wm->ctl[i].name) {\n\t\t\terr = snd_wm8776_add_control(wm, i);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}