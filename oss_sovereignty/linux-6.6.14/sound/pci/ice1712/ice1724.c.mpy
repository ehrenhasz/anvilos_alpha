{
  "module_name": "ice1724.c",
  "hash_id": "4d51b31829297376d6b21940a5acb7199ddb6cf655cecd145c53d3c2a39e06b1",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/ice1724.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/rawmidi.h>\n#include <sound/initval.h>\n\n#include <sound/asoundef.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n\n \n#include \"amp.h\"\n#include \"revo.h\"\n#include \"aureon.h\"\n#include \"vt1720_mobo.h\"\n#include \"pontis.h\"\n#include \"prodigy192.h\"\n#include \"prodigy_hifi.h\"\n#include \"juli.h\"\n#include \"maya44.h\"\n#include \"phase.h\"\n#include \"wtm.h\"\n#include \"se.h\"\n#include \"quartet.h\"\n#include \"psc724.h\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"VIA ICEnsemble ICE1724/1720 (Envy24HT/PT)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t\t \nstatic char *model[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ICE1724 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ICE1724 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ICE1724 soundcard.\");\nmodule_param_array(model, charp, NULL, 0444);\nMODULE_PARM_DESC(model, \"Use the given board model.\");\n\n\n \nstatic const struct pci_device_id snd_vt1724_ids[] = {\n\t{ PCI_VDEVICE(ICE, PCI_DEVICE_ID_VT1724), 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_vt1724_ids);\n\n\nstatic int PRO_RATE_LOCKED;\nstatic int PRO_RATE_RESET = 1;\nstatic unsigned int PRO_RATE_DEFAULT = 44100;\n\nstatic const char * const ext_clock_names[1] = { \"IEC958 In\" };\n\n \n\n \n\n \nstatic inline int stdclock_is_spdif_master(struct snd_ice1712 *ice)\n{\n\treturn (inb(ICEMT1724(ice, RATE)) & VT1724_SPDIF_MASTER) ? 1 : 0;\n}\n\n \nstatic inline int is_pro_rate_locked(struct snd_ice1712 *ice)\n{\n\treturn (!ice->is_spdif_master(ice)) && PRO_RATE_LOCKED;\n}\n\n \n\nstatic unsigned char snd_vt1724_ac97_ready(struct snd_ice1712 *ice)\n{\n\tunsigned char old_cmd;\n\tint tm;\n\tfor (tm = 0; tm < 0x10000; tm++) {\n\t\told_cmd = inb(ICEMT1724(ice, AC97_CMD));\n\t\tif (old_cmd & (VT1724_AC97_WRITE | VT1724_AC97_READ))\n\t\t\tcontinue;\n\t\tif (!(old_cmd & VT1724_AC97_READY))\n\t\t\tcontinue;\n\t\treturn old_cmd;\n\t}\n\tdev_dbg(ice->card->dev, \"snd_vt1724_ac97_ready: timeout\\n\");\n\treturn old_cmd;\n}\n\nstatic int snd_vt1724_ac97_wait_bit(struct snd_ice1712 *ice, unsigned char bit)\n{\n\tint tm;\n\tfor (tm = 0; tm < 0x10000; tm++)\n\t\tif ((inb(ICEMT1724(ice, AC97_CMD)) & bit) == 0)\n\t\t\treturn 0;\n\tdev_dbg(ice->card->dev, \"snd_vt1724_ac97_wait_bit: timeout\\n\");\n\treturn -EIO;\n}\n\nstatic void snd_vt1724_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t  unsigned short reg,\n\t\t\t\t  unsigned short val)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tunsigned char old_cmd;\n\n\told_cmd = snd_vt1724_ac97_ready(ice);\n\told_cmd &= ~VT1724_AC97_ID_MASK;\n\told_cmd |= ac97->num;\n\toutb(reg, ICEMT1724(ice, AC97_INDEX));\n\toutw(val, ICEMT1724(ice, AC97_DATA));\n\toutb(old_cmd | VT1724_AC97_WRITE, ICEMT1724(ice, AC97_CMD));\n\tsnd_vt1724_ac97_wait_bit(ice, VT1724_AC97_WRITE);\n}\n\nstatic unsigned short snd_vt1724_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct snd_ice1712 *ice = ac97->private_data;\n\tunsigned char old_cmd;\n\n\told_cmd = snd_vt1724_ac97_ready(ice);\n\told_cmd &= ~VT1724_AC97_ID_MASK;\n\told_cmd |= ac97->num;\n\toutb(reg, ICEMT1724(ice, AC97_INDEX));\n\toutb(old_cmd | VT1724_AC97_READ, ICEMT1724(ice, AC97_CMD));\n\tif (snd_vt1724_ac97_wait_bit(ice, VT1724_AC97_READ) < 0)\n\t\treturn ~0;\n\treturn inw(ICEMT1724(ice, AC97_DATA));\n}\n\n\n \n\n \nstatic void snd_vt1724_set_gpio_dir(struct snd_ice1712 *ice, unsigned int data)\n{\n\toutl(data, ICEREG1724(ice, GPIO_DIRECTION));\n\tinw(ICEREG1724(ice, GPIO_DIRECTION));  \n}\n\n \nstatic unsigned int snd_vt1724_get_gpio_dir(struct snd_ice1712 *ice)\n{\n\treturn inl(ICEREG1724(ice, GPIO_DIRECTION));\n}\n\n \nstatic void snd_vt1724_set_gpio_mask(struct snd_ice1712 *ice, unsigned int data)\n{\n\toutw(data, ICEREG1724(ice, GPIO_WRITE_MASK));\n\tif (!ice->vt1720)  \n\t\toutb((data >> 16) & 0xff, ICEREG1724(ice, GPIO_WRITE_MASK_22));\n\tinw(ICEREG1724(ice, GPIO_WRITE_MASK));  \n}\n\nstatic unsigned int snd_vt1724_get_gpio_mask(struct snd_ice1712 *ice)\n{\n\tunsigned int mask;\n\tif (!ice->vt1720)\n\t\tmask = (unsigned int)inb(ICEREG1724(ice, GPIO_WRITE_MASK_22));\n\telse\n\t\tmask = 0;\n\tmask = (mask << 16) | inw(ICEREG1724(ice, GPIO_WRITE_MASK));\n\treturn mask;\n}\n\nstatic void snd_vt1724_set_gpio_data(struct snd_ice1712 *ice, unsigned int data)\n{\n\toutw(data, ICEREG1724(ice, GPIO_DATA));\n\tif (!ice->vt1720)\n\t\toutb(data >> 16, ICEREG1724(ice, GPIO_DATA_22));\n\tinw(ICEREG1724(ice, GPIO_DATA));  \n}\n\nstatic unsigned int snd_vt1724_get_gpio_data(struct snd_ice1712 *ice)\n{\n\tunsigned int data;\n\tif (!ice->vt1720)\n\t\tdata = (unsigned int)inb(ICEREG1724(ice, GPIO_DATA_22));\n\telse\n\t\tdata = 0;\n\tdata = (data << 16) | inw(ICEREG1724(ice, GPIO_DATA));\n\treturn data;\n}\n\n \n\nstatic void vt1724_midi_clear_rx(struct snd_ice1712 *ice)\n{\n\tunsigned int count;\n\n\tfor (count = inb(ICEREG1724(ice, MPU_RXFIFO)); count > 0; --count)\n\t\tinb(ICEREG1724(ice, MPU_DATA));\n}\n\nstatic inline struct snd_rawmidi_substream *\nget_rawmidi_substream(struct snd_ice1712 *ice, unsigned int stream)\n{\n\treturn list_first_entry(&ice->rmidi[0]->streams[stream].substreams,\n\t\t\t\tstruct snd_rawmidi_substream, list);\n}\n\nstatic void enable_midi_irq(struct snd_ice1712 *ice, u8 flag, int enable);\n\nstatic void vt1724_midi_write(struct snd_ice1712 *ice)\n{\n\tstruct snd_rawmidi_substream *s;\n\tint count, i;\n\tu8 buffer[32];\n\n\ts = get_rawmidi_substream(ice, SNDRV_RAWMIDI_STREAM_OUTPUT);\n\tcount = 31 - inb(ICEREG1724(ice, MPU_TXFIFO));\n\tif (count > 0) {\n\t\tcount = snd_rawmidi_transmit(s, buffer, count);\n\t\tfor (i = 0; i < count; ++i)\n\t\t\toutb(buffer[i], ICEREG1724(ice, MPU_DATA));\n\t}\n\t \n\tenable_midi_irq(ice, VT1724_IRQ_MPU_TX,\n\t\t\t!snd_rawmidi_transmit_empty(s));\n}\n\nstatic void vt1724_midi_read(struct snd_ice1712 *ice)\n{\n\tstruct snd_rawmidi_substream *s;\n\tint count, i;\n\tu8 buffer[32];\n\n\ts = get_rawmidi_substream(ice, SNDRV_RAWMIDI_STREAM_INPUT);\n\tcount = inb(ICEREG1724(ice, MPU_RXFIFO));\n\tif (count > 0) {\n\t\tcount = min(count, 32);\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tbuffer[i] = inb(ICEREG1724(ice, MPU_DATA));\n\t\tsnd_rawmidi_receive(s, buffer, count);\n\t}\n}\n\n \nstatic void enable_midi_irq(struct snd_ice1712 *ice, u8 flag, int enable)\n{\n\tu8 mask = inb(ICEREG1724(ice, IRQMASK));\n\tif (enable)\n\t\tmask &= ~flag;\n\telse\n\t\tmask |= flag;\n\toutb(mask, ICEREG1724(ice, IRQMASK));\n}\n\nstatic void vt1724_enable_midi_irq(struct snd_rawmidi_substream *substream,\n\t\t\t\t   u8 flag, int enable)\n{\n\tstruct snd_ice1712 *ice = substream->rmidi->private_data;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tenable_midi_irq(ice, flag, enable);\n\tspin_unlock_irq(&ice->reg_lock);\n}\n\nstatic int vt1724_midi_output_open(struct snd_rawmidi_substream *s)\n{\n\treturn 0;\n}\n\nstatic int vt1724_midi_output_close(struct snd_rawmidi_substream *s)\n{\n\treturn 0;\n}\n\nstatic void vt1724_midi_output_trigger(struct snd_rawmidi_substream *s, int up)\n{\n\tstruct snd_ice1712 *ice = s->rmidi->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\tif (up) {\n\t\tice->midi_output = 1;\n\t\tvt1724_midi_write(ice);\n\t} else {\n\t\tice->midi_output = 0;\n\t\tenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\n\t}\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n}\n\nstatic void vt1724_midi_output_drain(struct snd_rawmidi_substream *s)\n{\n\tstruct snd_ice1712 *ice = s->rmidi->private_data;\n\tunsigned long timeout;\n\n\tvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_TX, 0);\n\t \n\ttimeout = jiffies + msecs_to_jiffies(15);\n\tdo {\n\t\tif (inb(ICEREG1724(ice, MPU_CTRL)) & VT1724_MPU_TX_EMPTY)\n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after(timeout, jiffies));\n}\n\nstatic const struct snd_rawmidi_ops vt1724_midi_output_ops = {\n\t.open = vt1724_midi_output_open,\n\t.close = vt1724_midi_output_close,\n\t.trigger = vt1724_midi_output_trigger,\n\t.drain = vt1724_midi_output_drain,\n};\n\nstatic int vt1724_midi_input_open(struct snd_rawmidi_substream *s)\n{\n\tvt1724_midi_clear_rx(s->rmidi->private_data);\n\tvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_RX, 1);\n\treturn 0;\n}\n\nstatic int vt1724_midi_input_close(struct snd_rawmidi_substream *s)\n{\n\tvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_RX, 0);\n\treturn 0;\n}\n\nstatic void vt1724_midi_input_trigger(struct snd_rawmidi_substream *s, int up)\n{\n\tstruct snd_ice1712 *ice = s->rmidi->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\tif (up) {\n\t\tice->midi_input = 1;\n\t\tvt1724_midi_read(ice);\n\t} else {\n\t\tice->midi_input = 0;\n\t}\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops vt1724_midi_input_ops = {\n\t.open = vt1724_midi_input_open,\n\t.close = vt1724_midi_input_close,\n\t.trigger = vt1724_midi_input_trigger,\n};\n\n\n \n\nstatic irqreturn_t snd_vt1724_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_ice1712 *ice = dev_id;\n\tunsigned char status;\n\tunsigned char status_mask =\n\t\tVT1724_IRQ_MPU_RX | VT1724_IRQ_MPU_TX | VT1724_IRQ_MTPCM;\n\tint handled = 0;\n\tint timeout = 0;\n\n\twhile (1) {\n\t\tstatus = inb(ICEREG1724(ice, IRQSTAT));\n\t\tstatus &= status_mask;\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tspin_lock(&ice->reg_lock);\n\t\tif (++timeout > 10) {\n\t\t\tstatus = inb(ICEREG1724(ice, IRQSTAT));\n\t\t\tdev_err(ice->card->dev,\n\t\t\t\t\"Too long irq loop, status = 0x%x\\n\", status);\n\t\t\tif (status & VT1724_IRQ_MPU_TX) {\n\t\t\t\tdev_err(ice->card->dev, \"Disabling MPU_TX\\n\");\n\t\t\t\tenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\n\t\t\t}\n\t\t\tspin_unlock(&ice->reg_lock);\n\t\t\tbreak;\n\t\t}\n\t\thandled = 1;\n\t\tif (status & VT1724_IRQ_MPU_TX) {\n\t\t\tif (ice->midi_output)\n\t\t\t\tvt1724_midi_write(ice);\n\t\t\telse\n\t\t\t\tenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\n\t\t\t \n\t\t\tstatus_mask &= ~VT1724_IRQ_MPU_TX;\n\t\t}\n\t\tif (status & VT1724_IRQ_MPU_RX) {\n\t\t\tif (ice->midi_input)\n\t\t\t\tvt1724_midi_read(ice);\n\t\t\telse\n\t\t\t\tvt1724_midi_clear_rx(ice);\n\t\t}\n\t\t \n\t\toutb(status, ICEREG1724(ice, IRQSTAT));\n\t\tspin_unlock(&ice->reg_lock);\n\t\tif (status & VT1724_IRQ_MTPCM) {\n\t\t\t \n\t\t\tunsigned char mtstat = inb(ICEMT1724(ice, IRQ));\n\t\t\tif (mtstat & VT1724_MULTI_PDMA0) {\n\t\t\t\tif (ice->playback_pro_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_pro_substream);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_RDMA0) {\n\t\t\t\tif (ice->capture_pro_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->capture_pro_substream);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_PDMA1) {\n\t\t\t\tif (ice->playback_con_substream_ds[0])\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_con_substream_ds[0]);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_PDMA2) {\n\t\t\t\tif (ice->playback_con_substream_ds[1])\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_con_substream_ds[1]);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_PDMA3) {\n\t\t\t\tif (ice->playback_con_substream_ds[2])\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_con_substream_ds[2]);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_PDMA4) {\n\t\t\t\tif (ice->playback_con_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->playback_con_substream);\n\t\t\t}\n\t\t\tif (mtstat & VT1724_MULTI_RDMA1) {\n\t\t\t\tif (ice->capture_con_substream)\n\t\t\t\t\tsnd_pcm_period_elapsed(ice->capture_con_substream);\n\t\t\t}\n\t\t\t \n\t\t\toutb(mtstat, ICEMT1724(ice, IRQ));\n\t\t\t \n\t\t\tif (mtstat & VT1724_MULTI_FIFO_ERR) {\n\t\t\t\tunsigned char fstat = inb(ICEMT1724(ice, DMA_FIFO_ERR));\n\t\t\t\toutb(fstat, ICEMT1724(ice, DMA_FIFO_ERR));\n\t\t\t\toutb(VT1724_MULTI_FIFO_ERR | inb(ICEMT1724(ice, DMA_INT_MASK)), ICEMT1724(ice, DMA_INT_MASK));\n\t\t\t\t \n\t\t\t}\n\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic const unsigned int rates[] = {\n\t8000, 9600, 11025, 12000, 16000, 22050, 24000,\n\t32000, 44100, 48000, 64000, 88200, 96000,\n\t176400, 192000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates_96 = {\n\t.count = ARRAY_SIZE(rates) - 2,  \n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates_48 = {\n\t.count = ARRAY_SIZE(rates) - 5,  \n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates_192 = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nstruct vt1724_pcm_reg {\n\tunsigned int addr;\t \n\tunsigned int size;\t \n\tunsigned int count;\t \n\tunsigned int start;\t \n};\n\nstatic int snd_vt1724_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tunsigned char what;\n\tunsigned char old;\n\tstruct snd_pcm_substream *s;\n\n\twhat = 0;\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) == ice) {\n\t\t\tconst struct vt1724_pcm_reg *reg;\n\t\t\treg = s->runtime->private_data;\n\t\t\twhat |= reg->start;\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock(&ice->reg_lock);\n\t\told = inb(ICEMT1724(ice, DMA_PAUSE));\n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\n\t\t\told |= what;\n\t\telse\n\t\t\told &= ~what;\n\t\toutb(old, ICEMT1724(ice, DMA_PAUSE));\n\t\tspin_unlock(&ice->reg_lock);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tspin_lock(&ice->reg_lock);\n\t\told = inb(ICEMT1724(ice, DMA_CONTROL));\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\told |= what;\n\t\telse\n\t\t\told &= ~what;\n\t\toutb(old, ICEMT1724(ice, DMA_CONTROL));\n\t\tspin_unlock(&ice->reg_lock);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\n#define DMA_STARTS\t(VT1724_RDMA0_START|VT1724_PDMA0_START|VT1724_RDMA1_START|\\\n\tVT1724_PDMA1_START|VT1724_PDMA2_START|VT1724_PDMA3_START|VT1724_PDMA4_START)\n#define DMA_PAUSES\t(VT1724_RDMA0_PAUSE|VT1724_PDMA0_PAUSE|VT1724_RDMA1_PAUSE|\\\n\tVT1724_PDMA1_PAUSE|VT1724_PDMA2_PAUSE|VT1724_PDMA3_PAUSE|VT1724_PDMA4_PAUSE)\n\nstatic const unsigned int stdclock_rate_list[16] = {\n\t48000, 24000, 12000, 9600, 32000, 16000, 8000, 96000, 44100,\n\t22050, 11025, 88200, 176400, 0, 192000, 64000\n};\n\nstatic unsigned int stdclock_get_rate(struct snd_ice1712 *ice)\n{\n\treturn stdclock_rate_list[inb(ICEMT1724(ice, RATE)) & 15];\n}\n\nstatic void stdclock_set_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(stdclock_rate_list); i++) {\n\t\tif (stdclock_rate_list[i] == rate) {\n\t\t\toutb(i, ICEMT1724(ice, RATE));\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic unsigned char stdclock_set_mclk(struct snd_ice1712 *ice,\n\t\t\t\t       unsigned int rate)\n{\n\tunsigned char val, old;\n\t \n\tif (ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S) {\n\t\tval = old = inb(ICEMT1724(ice, I2S_FORMAT));\n\t\tif (rate > 96000)\n\t\t\tval |= VT1724_MT_I2S_MCLK_128X;  \n\t\telse\n\t\t\tval &= ~VT1724_MT_I2S_MCLK_128X;  \n\t\tif (val != old) {\n\t\t\toutb(val, ICEMT1724(ice, I2S_FORMAT));\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\nstatic int snd_vt1724_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate,\n\t\t\t\t    int force)\n{\n\tunsigned long flags;\n\tunsigned char mclk_change;\n\tunsigned int i, old_rate;\n\tbool call_set_rate = false;\n\n\tif (rate > ice->hw_rates->list[ice->hw_rates->count - 1])\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\tif ((inb(ICEMT1724(ice, DMA_CONTROL)) & DMA_STARTS) ||\n\t    (inb(ICEMT1724(ice, DMA_PAUSE)) & DMA_PAUSES)) {\n\t\t \n\t\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\t\treturn ((rate == ice->cur_rate) && !force) ? 0 : -EBUSY;\n\t}\n\tif (!force && is_pro_rate_locked(ice)) {\n\t\t \n\t\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\t\treturn (rate == ice->cur_rate) ? 0 : -EBUSY;\n\t}\n\n\tif (force || !ice->is_spdif_master(ice)) {\n\t\t \n\t\told_rate = ice->get_rate(ice);\n\t\tif (force || (old_rate != rate))\n\t\t\tcall_set_rate = true;\n\t\telse if (rate == ice->cur_rate) {\n\t\t\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tice->cur_rate = rate;\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n\n\tif (call_set_rate)\n\t\tice->set_rate(ice, rate);\n\n\t \n\tmclk_change = ice->set_mclk(ice, rate);\n\n\tif (mclk_change && ice->gpio.i2s_mclk_changed)\n\t\tice->gpio.i2s_mclk_changed(ice);\n\tif (ice->gpio.set_pro_rate)\n\t\tice->gpio.set_pro_rate(ice, rate);\n\n\t \n\tfor (i = 0; i < ice->akm_codecs; i++) {\n\t\tif (ice->akm[i].ops.set_rate_val)\n\t\t\tice->akm[i].ops.set_rate_val(&ice->akm[i], rate);\n\t}\n\tif (ice->spdif.ops.setup_rate)\n\t\tice->spdif.ops.setup_rate(ice, rate);\n\n\treturn 0;\n}\n\nstatic int snd_vt1724_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint i, chs;\n\n\tchs = params_channels(hw_params);\n\tmutex_lock(&ice->open_mutex);\n\t \n\tif (substream == ice->playback_pro_substream) {\n\t\t \n\t\tchs = chs / 2 - 1;\n\t\tfor (i = 0; i < chs; i++) {\n\t\t\tif (ice->pcm_reserved[i] &&\n\t\t\t    ice->pcm_reserved[i] != substream) {\n\t\t\t\tmutex_unlock(&ice->open_mutex);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tice->pcm_reserved[i] = substream;\n\t\t}\n\t\tfor (; i < 3; i++) {\n\t\t\tif (ice->pcm_reserved[i] == substream)\n\t\t\t\tice->pcm_reserved[i] = NULL;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t \n\t\t\tif (ice->playback_con_substream_ds[i] == substream) {\n\t\t\t\tif (ice->pcm_reserved[i] &&\n\t\t\t\t    ice->pcm_reserved[i] != substream) {\n\t\t\t\t\tmutex_unlock(&ice->open_mutex);\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tice->pcm_reserved[i] = substream;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ice->open_mutex);\n\n\treturn snd_vt1724_set_pro_rate(ice, params_rate(hw_params), 0);\n}\n\nstatic int snd_vt1724_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint i;\n\n\tmutex_lock(&ice->open_mutex);\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (ice->pcm_reserved[i] == substream)\n\t\t\tice->pcm_reserved[i] = NULL;\n\tmutex_unlock(&ice->open_mutex);\n\treturn 0;\n}\n\nstatic int snd_vt1724_playback_pro_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tunsigned char val;\n\tunsigned int size;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tval = (8 - substream->runtime->channels) >> 1;\n\toutb(val, ICEMT1724(ice, BURST));\n\n\toutl(substream->runtime->dma_addr, ICEMT1724(ice, PLAYBACK_ADDR));\n\n\tsize = (snd_pcm_lib_buffer_bytes(substream) >> 2) - 1;\n\t \n\toutw(size, ICEMT1724(ice, PLAYBACK_SIZE));\n\toutb(size >> 16, ICEMT1724(ice, PLAYBACK_SIZE) + 2);\n\tsize = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\n\t \n\toutw(size, ICEMT1724(ice, PLAYBACK_COUNT));\n\toutb(size >> 16, ICEMT1724(ice, PLAYBACK_COUNT) + 2);\n\n\tspin_unlock_irq(&ice->reg_lock);\n\n\t \n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_vt1724_playback_pro_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(inl(ICEMT1724(ice, DMA_CONTROL)) & VT1724_PDMA0_START))\n\t\treturn 0;\n#if 0  \n\tptr = inl(ICEMT1724(ice, PLAYBACK_ADDR));\n\tif (ptr < substream->runtime->dma_addr) {\n\t\tdev_dbg(ice->card->dev, \"invalid negative ptr\\n\");\n\t\treturn 0;\n\t}\n\tptr -= substream->runtime->dma_addr;\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (ptr >= substream->runtime->buffer_size) {\n\t\tdev_dbg(ice->card->dev, \"invalid ptr %d (size=%d)\\n\",\n\t\t\t   (int)ptr, (int)substream->runtime->period_size);\n\t\treturn 0;\n\t}\n#else  \n\tptr = inl(ICEMT1724(ice, PLAYBACK_SIZE)) & 0xffffff;\n\tptr = (ptr + 1) << 2;\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (!ptr)\n\t\t;\n\telse if (ptr <= substream->runtime->buffer_size)\n\t\tptr = substream->runtime->buffer_size - ptr;\n\telse {\n\t\tdev_dbg(ice->card->dev, \"invalid ptr %d (size=%d)\\n\",\n\t\t\t   (int)ptr, (int)substream->runtime->buffer_size);\n\t\tptr = 0;\n\t}\n#endif\n\treturn ptr;\n}\n\nstatic int snd_vt1724_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tconst struct vt1724_pcm_reg *reg = substream->runtime->private_data;\n\n\tspin_lock_irq(&ice->reg_lock);\n\toutl(substream->runtime->dma_addr, ice->profi_port + reg->addr);\n\toutw((snd_pcm_lib_buffer_bytes(substream) >> 2) - 1,\n\t     ice->profi_port + reg->size);\n\toutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1,\n\t     ice->profi_port + reg->count);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_vt1724_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tconst struct vt1724_pcm_reg *reg = substream->runtime->private_data;\n\tsize_t ptr;\n\n\tif (!(inl(ICEMT1724(ice, DMA_CONTROL)) & reg->start))\n\t\treturn 0;\n#if 0  \n\tptr = inl(ice->profi_port + reg->addr);\n\tptr -= substream->runtime->dma_addr;\n\treturn bytes_to_frames(substream->runtime, ptr);\n#else  \n\tptr = inw(ice->profi_port + reg->size);\n\tptr = (ptr + 1) << 2;\n\tptr = bytes_to_frames(substream->runtime, ptr);\n\tif (!ptr)\n\t\t;\n\telse if (ptr <= substream->runtime->buffer_size)\n\t\tptr = substream->runtime->buffer_size - ptr;\n\telse {\n\t\tdev_dbg(ice->card->dev, \"invalid ptr %d (size=%d)\\n\",\n\t\t\t   (int)ptr, (int)substream->runtime->buffer_size);\n\t\tptr = 0;\n\t}\n\treturn ptr;\n#endif\n}\n\nstatic const struct vt1724_pcm_reg vt1724_pdma0_reg = {\n\t.addr = VT1724_MT_PLAYBACK_ADDR,\n\t.size = VT1724_MT_PLAYBACK_SIZE,\n\t.count = VT1724_MT_PLAYBACK_COUNT,\n\t.start = VT1724_PDMA0_START,\n};\n\nstatic const struct vt1724_pcm_reg vt1724_pdma4_reg = {\n\t.addr = VT1724_MT_PDMA4_ADDR,\n\t.size = VT1724_MT_PDMA4_SIZE,\n\t.count = VT1724_MT_PDMA4_COUNT,\n\t.start = VT1724_PDMA4_START,\n};\n\nstatic const struct vt1724_pcm_reg vt1724_rdma0_reg = {\n\t.addr = VT1724_MT_CAPTURE_ADDR,\n\t.size = VT1724_MT_CAPTURE_SIZE,\n\t.count = VT1724_MT_CAPTURE_COUNT,\n\t.start = VT1724_RDMA0_START,\n};\n\nstatic const struct vt1724_pcm_reg vt1724_rdma1_reg = {\n\t.addr = VT1724_MT_RDMA1_ADDR,\n\t.size = VT1724_MT_RDMA1_SIZE,\n\t.count = VT1724_MT_RDMA1_COUNT,\n\t.start = VT1724_RDMA1_START,\n};\n\n#define vt1724_playback_pro_reg vt1724_pdma0_reg\n#define vt1724_playback_spdif_reg vt1724_pdma4_reg\n#define vt1724_capture_pro_reg vt1724_rdma0_reg\n#define vt1724_capture_spdif_reg vt1724_rdma1_reg\n\nstatic const struct snd_pcm_hardware snd_vt1724_playback_pro = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_192000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t8,\n\t.buffer_bytes_max =\t(1UL << 21),\t \n\t.period_bytes_min =\t8 * 4 * 2,\t \n\t.period_bytes_max =\t(1UL << 21),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n};\n\nstatic const struct snd_pcm_hardware snd_vt1724_spdif = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t        (SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100|\n\t\t\t\t SNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_88200|\n\t\t\t\t SNDRV_PCM_RATE_96000|SNDRV_PCM_RATE_176400|\n\t\t\t\t SNDRV_PCM_RATE_192000),\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(1UL << 18),\t \n\t.period_bytes_min =\t2 * 4 * 2,\n\t.period_bytes_max =\t(1UL << 18),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n};\n\nstatic const struct snd_pcm_hardware snd_vt1724_2ch_stereo = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_192000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(1UL << 18),\t \n\t.period_bytes_min =\t2 * 4 * 2,\n\t.period_bytes_max =\t(1UL << 18),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n};\n\n \nstatic void set_std_hw_rates(struct snd_ice1712 *ice)\n{\n\tif (ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S) {\n\t\t \n\t\t \n\t\tif ((ice->eeprom.data[ICE_EEP2_I2S] & 0x08) && !ice->vt1720)\n\t\t\tice->hw_rates = &hw_constraints_rates_192;\n\t\telse\n\t\t\tice->hw_rates = &hw_constraints_rates_96;\n\t} else {\n\t\t \n\t\tice->hw_rates = &hw_constraints_rates_48;\n\t}\n}\n\nstatic int set_rate_constraints(struct snd_ice1712 *ice,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw.rate_min = ice->hw_rates->list[0];\n\truntime->hw.rate_max = ice->hw_rates->list[ice->hw_rates->count - 1];\n\truntime->hw.rates = SNDRV_PCM_RATE_KNOT;\n\treturn snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  ice->hw_rates);\n}\n\n \nstatic void constrain_rate_if_locked(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int rate;\n\tif (is_pro_rate_locked(ice)) {\n\t\trate = ice->get_rate(ice);\n\t\tif (rate >= runtime->hw.rate_min\n\t\t    && rate <= runtime->hw.rate_max) {\n\t\t\truntime->hw.rate_min = rate;\n\t\t\truntime->hw.rate_max = rate;\n\t\t}\n\t}\n}\n\n\n \n#define VT1724_BUFFER_ALIGN\t0x20\n\nstatic int snd_vt1724_playback_pro_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tint chs, num_indeps;\n\n\truntime->private_data = (void *)&vt1724_playback_pro_reg;\n\tice->playback_pro_substream = substream;\n\truntime->hw = snd_vt1724_playback_pro;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tset_rate_constraints(ice, substream);\n\tmutex_lock(&ice->open_mutex);\n\t \n\tnum_indeps = ice->num_total_dacs / 2 - 1;\n\tfor (chs = 0; chs < num_indeps; chs++) {\n\t\tif (ice->pcm_reserved[chs])\n\t\t\tbreak;\n\t}\n\tchs = (chs + 1) * 2;\n\truntime->hw.channels_max = chs;\n\tif (chs > 2)  \n\t\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\tmutex_unlock(&ice->open_mutex);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tconstrain_rate_if_locked(substream);\n\tif (ice->pro_open)\n\t\tice->pro_open(ice, substream);\n\treturn 0;\n}\n\nstatic int snd_vt1724_capture_pro_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->private_data = (void *)&vt1724_capture_pro_reg;\n\tice->capture_pro_substream = substream;\n\truntime->hw = snd_vt1724_2ch_stereo;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tset_rate_constraints(ice, substream);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tconstrain_rate_if_locked(substream);\n\tif (ice->pro_open)\n\t\tice->pro_open(ice, substream);\n\treturn 0;\n}\n\nstatic int snd_vt1724_playback_pro_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\n\tice->playback_pro_substream = NULL;\n\n\treturn 0;\n}\n\nstatic int snd_vt1724_capture_pro_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\n\tice->capture_pro_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_vt1724_playback_pro_ops = {\n\t.open =\t\tsnd_vt1724_playback_pro_open,\n\t.close =\tsnd_vt1724_playback_pro_close,\n\t.hw_params =\tsnd_vt1724_pcm_hw_params,\n\t.hw_free =\tsnd_vt1724_pcm_hw_free,\n\t.prepare =\tsnd_vt1724_playback_pro_prepare,\n\t.trigger =\tsnd_vt1724_pcm_trigger,\n\t.pointer =\tsnd_vt1724_playback_pro_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_vt1724_capture_pro_ops = {\n\t.open =\t\tsnd_vt1724_capture_pro_open,\n\t.close =\tsnd_vt1724_capture_pro_close,\n\t.hw_params =\tsnd_vt1724_pcm_hw_params,\n\t.hw_free =\tsnd_vt1724_pcm_hw_free,\n\t.prepare =\tsnd_vt1724_pcm_prepare,\n\t.trigger =\tsnd_vt1724_pcm_trigger,\n\t.pointer =\tsnd_vt1724_pcm_pointer,\n};\n\nstatic int snd_vt1724_pcm_profi(struct snd_ice1712 *ice, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint capt, err;\n\n\tif ((ice->eeprom.data[ICE_EEP2_SYSCONF] & VT1724_CFG_ADC_MASK) ==\n\t    VT1724_CFG_ADC_NONE)\n\t\tcapt = 0;\n\telse\n\t\tcapt = 1;\n\terr = snd_pcm_new(ice->card, \"ICE1724\", device, 1, capt, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_vt1724_playback_pro_ops);\n\tif (capt)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_vt1724_capture_pro_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ICE1724\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 256*1024, 256*1024);\n\n\tice->pcm_pro = pcm;\n\n\treturn 0;\n}\n\n\n \n\n \nstatic void update_spdif_bits(struct snd_ice1712 *ice, unsigned int val)\n{\n\tunsigned char cbit, disabled;\n\n\tcbit = inb(ICEREG1724(ice, SPDIF_CFG));\n\tdisabled = cbit & ~VT1724_CFG_SPDIF_OUT_EN;\n\tif (cbit != disabled)\n\t\toutb(disabled, ICEREG1724(ice, SPDIF_CFG));\n\toutw(val, ICEMT1724(ice, SPDIF_CTRL));\n\tif (cbit != disabled)\n\t\toutb(cbit, ICEREG1724(ice, SPDIF_CFG));\n\toutw(val, ICEMT1724(ice, SPDIF_CTRL));\n}\n\n \nstatic void update_spdif_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tunsigned int val, nval;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ice->reg_lock, flags);\n\tnval = val = inw(ICEMT1724(ice, SPDIF_CTRL));\n\tnval &= ~(7 << 12);\n\tswitch (rate) {\n\tcase 44100: break;\n\tcase 48000: nval |= 2 << 12; break;\n\tcase 32000: nval |= 3 << 12; break;\n\tcase 88200: nval |= 4 << 12; break;\n\tcase 96000: nval |= 5 << 12; break;\n\tcase 192000: nval |= 6 << 12; break;\n\tcase 176400: nval |= 7 << 12; break;\n\t}\n\tif (val != nval)\n\t\tupdate_spdif_bits(ice, nval);\n\tspin_unlock_irqrestore(&ice->reg_lock, flags);\n}\n\nstatic int snd_vt1724_playback_spdif_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tif (!ice->force_pdma4)\n\t\tupdate_spdif_rate(ice, substream->runtime->rate);\n\treturn snd_vt1724_pcm_prepare(substream);\n}\n\nstatic int snd_vt1724_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->private_data = (void *)&vt1724_playback_spdif_reg;\n\tice->playback_con_substream = substream;\n\tif (ice->force_pdma4) {\n\t\truntime->hw = snd_vt1724_2ch_stereo;\n\t\tset_rate_constraints(ice, substream);\n\t} else\n\t\truntime->hw = snd_vt1724_spdif;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tconstrain_rate_if_locked(substream);\n\tif (ice->spdif.ops.open)\n\t\tice->spdif.ops.open(ice, substream);\n\treturn 0;\n}\n\nstatic int snd_vt1724_playback_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\n\tice->playback_con_substream = NULL;\n\tif (ice->spdif.ops.close)\n\t\tice->spdif.ops.close(ice, substream);\n\n\treturn 0;\n}\n\nstatic int snd_vt1724_capture_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->private_data = (void *)&vt1724_capture_spdif_reg;\n\tice->capture_con_substream = substream;\n\tif (ice->force_rdma1) {\n\t\truntime->hw = snd_vt1724_2ch_stereo;\n\t\tset_rate_constraints(ice, substream);\n\t} else\n\t\truntime->hw = snd_vt1724_spdif;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   VT1724_BUFFER_ALIGN);\n\tconstrain_rate_if_locked(substream);\n\tif (ice->spdif.ops.open)\n\t\tice->spdif.ops.open(ice, substream);\n\treturn 0;\n}\n\nstatic int snd_vt1724_capture_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\n\tice->capture_con_substream = NULL;\n\tif (ice->spdif.ops.close)\n\t\tice->spdif.ops.close(ice, substream);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_vt1724_playback_spdif_ops = {\n\t.open =\t\tsnd_vt1724_playback_spdif_open,\n\t.close =\tsnd_vt1724_playback_spdif_close,\n\t.hw_params =\tsnd_vt1724_pcm_hw_params,\n\t.hw_free =\tsnd_vt1724_pcm_hw_free,\n\t.prepare =\tsnd_vt1724_playback_spdif_prepare,\n\t.trigger =\tsnd_vt1724_pcm_trigger,\n\t.pointer =\tsnd_vt1724_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_vt1724_capture_spdif_ops = {\n\t.open =\t\tsnd_vt1724_capture_spdif_open,\n\t.close =\tsnd_vt1724_capture_spdif_close,\n\t.hw_params =\tsnd_vt1724_pcm_hw_params,\n\t.hw_free =\tsnd_vt1724_pcm_hw_free,\n\t.prepare =\tsnd_vt1724_pcm_prepare,\n\t.trigger =\tsnd_vt1724_pcm_trigger,\n\t.pointer =\tsnd_vt1724_pcm_pointer,\n};\n\n\nstatic int snd_vt1724_pcm_spdif(struct snd_ice1712 *ice, int device)\n{\n\tchar *name;\n\tstruct snd_pcm *pcm;\n\tint play, capt;\n\tint err;\n\n\tif (ice->force_pdma4 ||\n\t    (ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_OUT_INT)) {\n\t\tplay = 1;\n\t\tice->has_spdif = 1;\n\t} else\n\t\tplay = 0;\n\tif (ice->force_rdma1 ||\n\t    (ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_IN)) {\n\t\tcapt = 1;\n\t\tice->has_spdif = 1;\n\t} else\n\t\tcapt = 0;\n\tif (!play && !capt)\n\t\treturn 0;  \n\n\tif (ice->force_pdma4 || ice->force_rdma1)\n\t\tname = \"ICE1724 Secondary\";\n\telse\n\t\tname = \"ICE1724 IEC958\";\n\terr = snd_pcm_new(ice->card, name, device, play, capt, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (play)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_vt1724_playback_spdif_ops);\n\tif (capt)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_vt1724_capture_spdif_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, name);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 256*1024, 256*1024);\n\n\tice->pcm = pcm;\n\n\treturn 0;\n}\n\n\n \n\nstatic const struct vt1724_pcm_reg vt1724_playback_dma_regs[3] = {\n\t{\n\t\t.addr = VT1724_MT_PDMA1_ADDR,\n\t\t.size = VT1724_MT_PDMA1_SIZE,\n\t\t.count = VT1724_MT_PDMA1_COUNT,\n\t\t.start = VT1724_PDMA1_START,\n\t},\n\t{\n\t\t.addr = VT1724_MT_PDMA2_ADDR,\n\t\t.size = VT1724_MT_PDMA2_SIZE,\n\t\t.count = VT1724_MT_PDMA2_COUNT,\n\t\t.start = VT1724_PDMA2_START,\n\t},\n\t{\n\t\t.addr = VT1724_MT_PDMA3_ADDR,\n\t\t.size = VT1724_MT_PDMA3_SIZE,\n\t\t.count = VT1724_MT_PDMA3_COUNT,\n\t\t.start = VT1724_PDMA3_START,\n\t},\n};\n\nstatic int snd_vt1724_playback_indep_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tunsigned char val;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tval = 3 - substream->number;\n\tif (inb(ICEMT1724(ice, BURST)) < val)\n\t\toutb(val, ICEMT1724(ice, BURST));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn snd_vt1724_pcm_prepare(substream);\n}\n\nstatic int snd_vt1724_playback_indep_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tmutex_lock(&ice->open_mutex);\n\t \n\tif (ice->pcm_reserved[substream->number]) {\n\t\tmutex_unlock(&ice->open_mutex);\n\t\treturn -EBUSY;  \n\t}\n\tmutex_unlock(&ice->open_mutex);\n\truntime->private_data = (void *)&vt1724_playback_dma_regs[substream->number];\n\tice->playback_con_substream_ds[substream->number] = substream;\n\truntime->hw = snd_vt1724_2ch_stereo;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tset_rate_constraints(ice, substream);\n\treturn 0;\n}\n\nstatic int snd_vt1724_playback_indep_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\n\n\tif (PRO_RATE_RESET)\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\n\tice->playback_con_substream_ds[substream->number] = NULL;\n\tice->pcm_reserved[substream->number] = NULL;\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_vt1724_playback_indep_ops = {\n\t.open =\t\tsnd_vt1724_playback_indep_open,\n\t.close =\tsnd_vt1724_playback_indep_close,\n\t.hw_params =\tsnd_vt1724_pcm_hw_params,\n\t.hw_free =\tsnd_vt1724_pcm_hw_free,\n\t.prepare =\tsnd_vt1724_playback_indep_prepare,\n\t.trigger =\tsnd_vt1724_pcm_trigger,\n\t.pointer =\tsnd_vt1724_pcm_pointer,\n};\n\n\nstatic int snd_vt1724_pcm_indep(struct snd_ice1712 *ice, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint play;\n\tint err;\n\n\tplay = ice->num_total_dacs / 2 - 1;\n\tif (play <= 0)\n\t\treturn 0;\n\n\terr = snd_pcm_new(ice->card, \"ICE1724 Surrounds\", device, play, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_vt1724_playback_indep_ops);\n\n\tpcm->private_data = ice;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ICE1724 Surround PCM\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ice->pci->dev, 256*1024, 256*1024);\n\n\tice->pcm_ds = pcm;\n\n\treturn 0;\n}\n\n\n \n\nstatic int snd_vt1724_ac97_mixer(struct snd_ice1712 *ice)\n{\n\tint err;\n\n\tif (!(ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S)) {\n\t\tstruct snd_ac97_bus *pbus;\n\t\tstruct snd_ac97_template ac97;\n\t\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t\t.write = snd_vt1724_ac97_write,\n\t\t\t.read = snd_vt1724_ac97_read,\n\t\t};\n\n\t\t \n\t\toutb(inb(ICEMT1724(ice, AC97_CMD)) | 0x80, ICEMT1724(ice, AC97_CMD));\n\t\tmdelay(5);  \n\t\toutb(inb(ICEMT1724(ice, AC97_CMD)) & ~0x80, ICEMT1724(ice, AC97_CMD));\n\n\t\terr = snd_ac97_bus(ice->card, 0, &ops, NULL, &pbus);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = ice;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\n\t\tif (err < 0)\n\t\t\tdev_warn(ice->card->dev,\n\t\t\t\t \"cannot initialize pro ac97, skipped\\n\");\n\t\telse\n\t\t\treturn 0;\n\t}\n\t \n\tstrcat(ice->card->mixername, \"ICE1724 - multitrack\");\n\treturn 0;\n}\n\n \n\nstatic inline unsigned int eeprom_triple(struct snd_ice1712 *ice, int idx)\n{\n\treturn (unsigned int)ice->eeprom.data[idx] | \\\n\t\t((unsigned int)ice->eeprom.data[idx + 1] << 8) | \\\n\t\t((unsigned int)ice->eeprom.data[idx + 2] << 16);\n}\n\nstatic void snd_vt1724_proc_read(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tunsigned int idx;\n\n\tsnd_iprintf(buffer, \"%s\\n\\n\", ice->card->longname);\n\tsnd_iprintf(buffer, \"EEPROM:\\n\");\n\n\tsnd_iprintf(buffer, \"  Subvendor        : 0x%x\\n\", ice->eeprom.subvendor);\n\tsnd_iprintf(buffer, \"  Size             : %i bytes\\n\", ice->eeprom.size);\n\tsnd_iprintf(buffer, \"  Version          : %i\\n\", ice->eeprom.version);\n\tsnd_iprintf(buffer, \"  System Config    : 0x%x\\n\",\n\t\t    ice->eeprom.data[ICE_EEP2_SYSCONF]);\n\tsnd_iprintf(buffer, \"  ACLink           : 0x%x\\n\",\n\t\t    ice->eeprom.data[ICE_EEP2_ACLINK]);\n\tsnd_iprintf(buffer, \"  I2S              : 0x%x\\n\",\n\t\t    ice->eeprom.data[ICE_EEP2_I2S]);\n\tsnd_iprintf(buffer, \"  S/PDIF           : 0x%x\\n\",\n\t\t    ice->eeprom.data[ICE_EEP2_SPDIF]);\n\tsnd_iprintf(buffer, \"  GPIO direction   : 0x%x\\n\",\n\t\t    ice->eeprom.gpiodir);\n\tsnd_iprintf(buffer, \"  GPIO mask        : 0x%x\\n\",\n\t\t    ice->eeprom.gpiomask);\n\tsnd_iprintf(buffer, \"  GPIO state       : 0x%x\\n\",\n\t\t    ice->eeprom.gpiostate);\n\tfor (idx = 0x12; idx < ice->eeprom.size; idx++)\n\t\tsnd_iprintf(buffer, \"  Extra #%02i        : 0x%x\\n\",\n\t\t\t    idx, ice->eeprom.data[idx]);\n\n\tsnd_iprintf(buffer, \"\\nRegisters:\\n\");\n\n\tsnd_iprintf(buffer, \"  PSDOUT03 : 0x%08x\\n\",\n\t\t    (unsigned)inl(ICEMT1724(ice, ROUTE_PLAYBACK)));\n\tfor (idx = 0x0; idx < 0x20 ; idx++)\n\t\tsnd_iprintf(buffer, \"  CCS%02x    : 0x%02x\\n\",\n\t\t\t    idx, inb(ice->port+idx));\n\tfor (idx = 0x0; idx < 0x30 ; idx++)\n\t\tsnd_iprintf(buffer, \"  MT%02x     : 0x%02x\\n\",\n\t\t\t    idx, inb(ice->profi_port+idx));\n}\n\nstatic void snd_vt1724_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_ro_proc_new(ice->card, \"ice1724\", ice, snd_vt1724_proc_read);\n}\n\n \n\nstatic int snd_vt1724_eeprom_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = sizeof(struct snd_ice1712_eeprom);\n\treturn 0;\n}\n\nstatic int snd_vt1724_eeprom_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmemcpy(ucontrol->value.bytes.data, &ice->eeprom, sizeof(ice->eeprom));\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_eeprom = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.name = \"ICE1724 EEPROM\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_vt1724_eeprom_info,\n\t.get = snd_vt1724_eeprom_get\n};\n\n \nstatic int snd_vt1724_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic unsigned int encode_spdif_bits(struct snd_aes_iec958 *diga)\n{\n\tunsigned int val, rbits;\n\n\tval = diga->status[0] & 0x03;  \n\tif (val & 0x01) {\n\t\t \n\t\tif ((diga->status[0] & IEC958_AES0_PRO_EMPHASIS) ==\n\t\t    IEC958_AES0_PRO_EMPHASIS_5015)\n\t\t\tval |= 1U << 3;\n\t\trbits = (diga->status[4] >> 3) & 0x0f;\n\t\tif (rbits) {\n\t\t\tswitch (rbits) {\n\t\t\tcase 2: val |= 5 << 12; break;  \n\t\t\tcase 3: val |= 6 << 12; break;  \n\t\t\tcase 10: val |= 4 << 12; break;  \n\t\t\tcase 11: val |= 7 << 12; break;  \n\t\t\t}\n\t\t} else {\n\t\t\tswitch (diga->status[0] & IEC958_AES0_PRO_FS) {\n\t\t\tcase IEC958_AES0_PRO_FS_44100:\n\t\t\t\tbreak;\n\t\t\tcase IEC958_AES0_PRO_FS_32000:\n\t\t\t\tval |= 3U << 12;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tval |= 2U << 12;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tval |= diga->status[1] & 0x04;  \n\t\tif ((diga->status[0] & IEC958_AES0_CON_EMPHASIS) ==\n\t\t    IEC958_AES0_CON_EMPHASIS_5015)\n\t\t\tval |= 1U << 3;\n\t\tval |= (unsigned int)(diga->status[1] & 0x3f) << 4;  \n\t\tval |= (unsigned int)(diga->status[3] & IEC958_AES3_CON_FS) << 12;  \n\t}\n\treturn val;\n}\n\nstatic void decode_spdif_bits(struct snd_aes_iec958 *diga, unsigned int val)\n{\n\tmemset(diga->status, 0, sizeof(diga->status));\n\tdiga->status[0] = val & 0x03;  \n\tif (val & 0x01) {\n\t\t \n\t\tif (val & (1U << 3))\n\t\t\tdiga->status[0] |= IEC958_AES0_PRO_EMPHASIS_5015;\n\t\tswitch ((val >> 12) & 0x7) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdiga->status[0] |= IEC958_AES0_PRO_FS_32000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdiga->status[0] |= IEC958_AES0_PRO_FS_48000;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tdiga->status[0] |= val & (1U << 2);  \n\t\tif (val & (1U << 3))\n\t\t\tdiga->status[0] |= IEC958_AES0_CON_EMPHASIS_5015;\n\t\tdiga->status[1] |= (val >> 4) & 0x3f;  \n\t\tdiga->status[3] |= (val >> 12) & 0x07;  \n\t}\n}\n\nstatic int snd_vt1724_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tval = inw(ICEMT1724(ice, SPDIF_CTRL));\n\tdecode_spdif_bits(&ucontrol->value.iec958, val);\n\treturn 0;\n}\n\nstatic int snd_vt1724_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val, old;\n\n\tval = encode_spdif_bits(&ucontrol->value.iec958);\n\tspin_lock_irq(&ice->reg_lock);\n\told = inw(ICEMT1724(ice, SPDIF_CTRL));\n\tif (val != old)\n\t\tupdate_spdif_bits(ice, val);\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn val != old;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_spdif_default =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t.info =\t\tsnd_vt1724_spdif_info,\n\t.get =\t\tsnd_vt1724_spdif_default_get,\n\t.put =\t\tsnd_vt1724_spdif_default_put\n};\n\nstatic int snd_vt1724_spdif_maskc_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\n\t\t\t\t\t\t     IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t\t     IEC958_AES0_CON_NOT_COPYRIGHT |\n\t\t\t\t\t\t     IEC958_AES0_CON_EMPHASIS;\n\tucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |\n\t\t\t\t\t\t     IEC958_AES1_CON_CATEGORY;\n\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\n\treturn 0;\n}\n\nstatic int snd_vt1724_spdif_maskp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\n\t\t\t\t\t\t     IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t\t     IEC958_AES0_PRO_FS |\n\t\t\t\t\t\t     IEC958_AES0_PRO_EMPHASIS;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_spdif_maskc =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t.info =\t\tsnd_vt1724_spdif_info,\n\t.get =\t\tsnd_vt1724_spdif_maskc_get,\n};\n\nstatic const struct snd_kcontrol_new snd_vt1724_spdif_maskp =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PRO_MASK),\n\t.info =\t\tsnd_vt1724_spdif_info,\n\t.get =\t\tsnd_vt1724_spdif_maskp_get,\n};\n\n#define snd_vt1724_spdif_sw_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_vt1724_spdif_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = inb(ICEREG1724(ice, SPDIF_CFG)) &\n\t\tVT1724_CFG_SPDIF_OUT_EN ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_vt1724_spdif_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char old, val;\n\n\tspin_lock_irq(&ice->reg_lock);\n\told = val = inb(ICEREG1724(ice, SPDIF_CFG));\n\tval &= ~VT1724_CFG_SPDIF_OUT_EN;\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= VT1724_CFG_SPDIF_OUT_EN;\n\tif (old != val)\n\t\toutb(val, ICEREG1724(ice, SPDIF_CFG));\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn old != val;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_spdif_switch =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t \n\t \n\t.name =         SNDRV_CTL_NAME_IEC958(\"Output \", NONE, SWITCH),\n\t.info =\t\tsnd_vt1724_spdif_sw_info,\n\t.get =\t\tsnd_vt1724_spdif_sw_get,\n\t.put =\t\tsnd_vt1724_spdif_sw_put\n};\n\n\n#if 0  \n \n\n#define snd_vt1724_gpio_info\t\tsnd_ctl_boolean_mono_info\n\nint snd_vt1724_gpio_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value & (1<<24)) ? 1 : 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tucontrol->value.integer.value[0] =\n\t\t(snd_ice1712_gpio_read(ice) & (1 << shift) ? 1 : 0) ^ invert;\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn 0;\n}\n\nint snd_ice1712_gpio_put(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint shift = kcontrol->private_value & 0xff;\n\tint invert = (kcontrol->private_value & (1<<24)) ? mask : 0;\n\tunsigned int val, nval;\n\n\tif (kcontrol->private_value & (1 << 31))\n\t\treturn -EPERM;\n\tnval = (ucontrol->value.integer.value[0] ? (1 << shift) : 0) ^ invert;\n\tsnd_ice1712_save_gpio_status(ice);\n\tval = snd_ice1712_gpio_read(ice);\n\tnval |= val & ~(1 << shift);\n\tif (val != nval)\n\t\tsnd_ice1712_gpio_write(ice, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn val != nval;\n}\n#endif  \n\n \nstatic int snd_vt1724_pro_internal_clock_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint hw_rates_count = ice->hw_rates->count;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\n\t \n\tuinfo->value.enumerated.items = hw_rates_count;\n\t \n\tif (ice->force_rdma1 ||\n\t    (ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_IN))\n\t\tuinfo->value.enumerated.items += ice->ext_clock_count;\n\t \n\tif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\n\t\tuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\n\tif (uinfo->value.enumerated.item >= hw_rates_count)\n\t\t \n\t\tstrcpy(uinfo->value.enumerated.name,\n\t\t\t\tice->ext_clock_names[\n\t\t\t\tuinfo->value.enumerated.item - hw_rates_count]);\n\telse\n\t\t \n\t\tsprintf(uinfo->value.enumerated.name, \"%d\",\n\t\t\tice->hw_rates->list[uinfo->value.enumerated.item]);\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_internal_clock_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int i, rate;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tif (ice->is_spdif_master(ice)) {\n\t\tucontrol->value.enumerated.item[0] = ice->hw_rates->count +\n\t\t\tice->get_spdif_master_type(ice);\n\t} else {\n\t\trate = ice->get_rate(ice);\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tfor (i = 0; i < ice->hw_rates->count; i++) {\n\t\t\tif (ice->hw_rates->list[i] == rate) {\n\t\t\t\tucontrol->value.enumerated.item[0] = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic int stdclock_get_spdif_master_type(struct snd_ice1712 *ice)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int stdclock_set_spdif_clock(struct snd_ice1712 *ice, int type)\n{\n\tunsigned char oval;\n\tunsigned char i2s_oval;\n\toval = inb(ICEMT1724(ice, RATE));\n\toutb(oval | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\n\t \n\ti2s_oval = inb(ICEMT1724(ice, I2S_FORMAT));\n\toutb(i2s_oval & ~VT1724_MT_I2S_MCLK_128X, ICEMT1724(ice, I2S_FORMAT));\n\treturn 0;\n}\n\n\nstatic int snd_vt1724_pro_internal_clock_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old_rate, new_rate;\n\tunsigned int item = ucontrol->value.enumerated.item[0];\n\tunsigned int first_ext_clock = ice->hw_rates->count;\n\n\tif (item >  first_ext_clock + ice->ext_clock_count - 1)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irq(&ice->reg_lock);\n\tif (ice->is_spdif_master(ice))\n\t\told_rate = 0;\n\telse\n\t\told_rate = ice->get_rate(ice);\n\tif (item >= first_ext_clock) {\n\t\t \n\t\tice->set_spdif_clock(ice, item - first_ext_clock);\n\t\tnew_rate = 0;\n\t} else {\n\t\t \n\t\tnew_rate = ice->hw_rates->list[item];\n\t\tice->pro_rate_default = new_rate;\n\t\tspin_unlock_irq(&ice->reg_lock);\n\t\tsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 1);\n\t\tspin_lock_irq(&ice->reg_lock);\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\n\t \n\tif (old_rate != new_rate && !new_rate) {\n\t\t \n\t\tunsigned int i;\n\t\tif (ice->gpio.set_pro_rate)\n\t\t\tice->gpio.set_pro_rate(ice, 0);\n\t\tfor (i = 0; i < ice->akm_codecs; i++) {\n\t\t\tif (ice->akm[i].ops.set_rate_val)\n\t\t\t\tice->akm[i].ops.set_rate_val(&ice->akm[i], 0);\n\t\t}\n\t}\n\treturn old_rate != new_rate;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_pro_internal_clock = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Internal Clock\",\n\t.info = snd_vt1724_pro_internal_clock_info,\n\t.get = snd_vt1724_pro_internal_clock_get,\n\t.put = snd_vt1724_pro_internal_clock_put\n};\n\n#define snd_vt1724_pro_rate_locking_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_vt1724_pro_rate_locking_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = PRO_RATE_LOCKED;\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_rate_locking_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change = 0, nval;\n\n\tnval = ucontrol->value.integer.value[0] ? 1 : 0;\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = PRO_RATE_LOCKED != nval;\n\tPRO_RATE_LOCKED = nval;\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_pro_rate_locking = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Rate Locking\",\n\t.info = snd_vt1724_pro_rate_locking_info,\n\t.get = snd_vt1724_pro_rate_locking_get,\n\t.put = snd_vt1724_pro_rate_locking_put\n};\n\n#define snd_vt1724_pro_rate_reset_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_vt1724_pro_rate_reset_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = PRO_RATE_RESET ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_rate_reset_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint change = 0, nval;\n\n\tnval = ucontrol->value.integer.value[0] ? 1 : 0;\n\tspin_lock_irq(&ice->reg_lock);\n\tchange = PRO_RATE_RESET != nval;\n\tPRO_RATE_RESET = nval;\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_pro_rate_reset = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Multi Track Rate Reset\",\n\t.info = snd_vt1724_pro_rate_reset_info,\n\t.get = snd_vt1724_pro_rate_reset_get,\n\t.put = snd_vt1724_pro_rate_reset_put\n};\n\n\n \nstatic int snd_vt1724_pro_route_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"PCM Out\",  \n\t\t\"H/W In 0\", \"H/W In 1\",  \n\t\t\"IEC958 In L\", \"IEC958 In R\",  \n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 5, texts);\n}\n\nstatic inline int analog_route_shift(int idx)\n{\n\treturn (idx % 2) * 12 + ((idx / 2) * 3) + 8;\n}\n\nstatic inline int digital_route_shift(int idx)\n{\n\treturn idx * 3;\n}\n\nint snd_ice1724_get_route_val(struct snd_ice1712 *ice, int shift)\n{\n\tunsigned long val;\n\tunsigned char eitem;\n\tstatic const unsigned char xlate[8] = {\n\t\t0, 255, 1, 2, 255, 255, 3, 4,\n\t};\n\n\tval = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\n\tval >>= shift;\n\tval &= 7;  \n\teitem = xlate[val];\n\tif (eitem == 255) {\n\t\tsnd_BUG();\n\t\treturn 0;\n\t}\n\treturn eitem;\n}\n\nint snd_ice1724_put_route_val(struct snd_ice1712 *ice, unsigned int val,\n\t\t\t\t\t\t\t\tint shift)\n{\n\tunsigned int old_val, nval;\n\tint change;\n\tstatic const unsigned char xroute[8] = {\n\t\t0,  \n\t\t2,  \n\t\t3,  \n\t\t6,  \n\t\t7,  \n\t};\n\n\tnval = xroute[val % 5];\n\tval = old_val = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\n\tval &= ~(0x07 << shift);\n\tval |= nval << shift;\n\tchange = val != old_val;\n\tif (change)\n\t\toutl(val, ICEMT1724(ice, ROUTE_PLAYBACK));\n\treturn change;\n}\n\nstatic int snd_vt1724_pro_route_analog_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tucontrol->value.enumerated.item[0] =\n\t\tsnd_ice1724_get_route_val(ice, analog_route_shift(idx));\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_route_analog_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\treturn snd_ice1724_put_route_val(ice,\n\t\t\t\t\t ucontrol->value.enumerated.item[0],\n\t\t\t\t\t analog_route_shift(idx));\n}\n\nstatic int snd_vt1724_pro_route_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tucontrol->value.enumerated.item[0] =\n\t\tsnd_ice1724_get_route_val(ice, digital_route_shift(idx));\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_route_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\treturn snd_ice1724_put_route_val(ice,\n\t\t\t\t\t ucontrol->value.enumerated.item[0],\n\t\t\t\t\t digital_route_shift(idx));\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_mixer_pro_analog_route =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"H/W Playback Route\",\n\t.info = snd_vt1724_pro_route_info,\n\t.get = snd_vt1724_pro_route_analog_get,\n\t.put = snd_vt1724_pro_route_analog_put,\n};\n\nstatic const struct snd_kcontrol_new snd_vt1724_mixer_pro_spdif_route = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, NONE) \"Route\",\n\t.info = snd_vt1724_pro_route_info,\n\t.get = snd_vt1724_pro_route_spdif_get,\n\t.put = snd_vt1724_pro_route_spdif_put,\n\t.count = 2,\n};\n\n\nstatic int snd_vt1724_pro_peak_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 22;  \n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_vt1724_pro_peak_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx;\n\n\tspin_lock_irq(&ice->reg_lock);\n\tfor (idx = 0; idx < 22; idx++) {\n\t\toutb(idx, ICEMT1724(ice, MONITOR_PEAKINDEX));\n\t\tucontrol->value.integer.value[idx] =\n\t\t\tinb(ICEMT1724(ice, MONITOR_PEAKDATA));\n\t}\n\tspin_unlock_irq(&ice->reg_lock);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_vt1724_mixer_pro_peak = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"Multi Track Peak\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info = snd_vt1724_pro_peak_info,\n\t.get = snd_vt1724_pro_peak_get\n};\n\n \nstatic const unsigned char ooaoo_sq210_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x4c,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0x78,\t \n\t[ICE_EEP2_SPDIF]       = 0xc1,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0x00,\t \n\t[ICE_EEP2_GPIO_DIR1]   = 0x00,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK]   = 0xff,\n\t[ICE_EEP2_GPIO_MASK1]  = 0xff,\n\t[ICE_EEP2_GPIO_MASK2]  = 0xff,\n\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,  \n\t[ICE_EEP2_GPIO_STATE1] = 0x00,  \n\t[ICE_EEP2_GPIO_STATE2] = 0x00,  \n};\n\n\nstatic const struct snd_ice1712_card_info snd_vt1724_ooaoo_cards[] = {\n\t{\n\t\t.name = \"ooAoo SQ210a\",\n\t\t.model = \"sq210a\",\n\t\t.eeprom_size = sizeof(ooaoo_sq210_eeprom),\n\t\t.eeprom_data = ooaoo_sq210_eeprom,\n\t},\n\t{ }  \n};\n\nstatic const struct snd_ice1712_card_info *card_tables[] = {\n\tsnd_vt1724_revo_cards,\n\tsnd_vt1724_amp_cards,\n\tsnd_vt1724_aureon_cards,\n\tsnd_vt1720_mobo_cards,\n\tsnd_vt1720_pontis_cards,\n\tsnd_vt1724_prodigy_hifi_cards,\n\tsnd_vt1724_prodigy192_cards,\n\tsnd_vt1724_juli_cards,\n\tsnd_vt1724_maya44_cards,\n\tsnd_vt1724_phase_cards,\n\tsnd_vt1724_wtm_cards,\n\tsnd_vt1724_se_cards,\n\tsnd_vt1724_qtet_cards,\n\tsnd_vt1724_ooaoo_cards,\n\tsnd_vt1724_psc724_cards,\n\tNULL,\n};\n\n\n \n\nstatic void wait_i2c_busy(struct snd_ice1712 *ice)\n{\n\tint t = 0x10000;\n\twhile ((inb(ICEREG1724(ice, I2C_CTRL)) & VT1724_I2C_BUSY) && t--)\n\t\t;\n\tif (t == -1)\n\t\tdev_err(ice->card->dev, \"i2c busy timeout\\n\");\n}\n\nunsigned char snd_vt1724_read_i2c(struct snd_ice1712 *ice,\n\t\t\t\t  unsigned char dev, unsigned char addr)\n{\n\tunsigned char val;\n\n\tmutex_lock(&ice->i2c_mutex);\n\twait_i2c_busy(ice);\n\toutb(addr, ICEREG1724(ice, I2C_BYTE_ADDR));\n\toutb(dev & ~VT1724_I2C_WRITE, ICEREG1724(ice, I2C_DEV_ADDR));\n\twait_i2c_busy(ice);\n\tval = inb(ICEREG1724(ice, I2C_DATA));\n\tmutex_unlock(&ice->i2c_mutex);\n\t \n\treturn val;\n}\n\nvoid snd_vt1724_write_i2c(struct snd_ice1712 *ice,\n\t\t\t  unsigned char dev, unsigned char addr, unsigned char data)\n{\n\tmutex_lock(&ice->i2c_mutex);\n\twait_i2c_busy(ice);\n\t \n\toutb(addr, ICEREG1724(ice, I2C_BYTE_ADDR));\n\toutb(data, ICEREG1724(ice, I2C_DATA));\n\toutb(dev | VT1724_I2C_WRITE, ICEREG1724(ice, I2C_DEV_ADDR));\n\twait_i2c_busy(ice);\n\tmutex_unlock(&ice->i2c_mutex);\n}\n\nstatic int snd_vt1724_read_eeprom(struct snd_ice1712 *ice,\n\t\t\t\t  const char *modelname)\n{\n\tconst int dev = 0xa0;\t\t \n\tunsigned int i, size;\n\tconst struct snd_ice1712_card_info * const *tbl, *c;\n\n\tif (!modelname || !*modelname) {\n\t\tice->eeprom.subvendor = 0;\n\t\tif ((inb(ICEREG1724(ice, I2C_CTRL)) & VT1724_I2C_EEPROM) != 0)\n\t\t\tice->eeprom.subvendor =\n\t\t\t\t(snd_vt1724_read_i2c(ice, dev, 0x00) << 0) |\n\t\t\t\t(snd_vt1724_read_i2c(ice, dev, 0x01) << 8) |\n\t\t\t\t(snd_vt1724_read_i2c(ice, dev, 0x02) << 16) |\n\t\t\t\t(snd_vt1724_read_i2c(ice, dev, 0x03) << 24);\n\t\tif (ice->eeprom.subvendor == 0 ||\n\t\t    ice->eeprom.subvendor == (unsigned int)-1) {\n\t\t\t \n\t\t\tu16 vendor, device;\n\t\t\tpci_read_config_word(ice->pci, PCI_SUBSYSTEM_VENDOR_ID,\n\t\t\t\t\t     &vendor);\n\t\t\tpci_read_config_word(ice->pci, PCI_SUBSYSTEM_ID, &device);\n\t\t\tice->eeprom.subvendor =\n\t\t\t\t((unsigned int)swab16(vendor) << 16) | swab16(device);\n\t\t\tif (ice->eeprom.subvendor == 0 ||\n\t\t\t    ice->eeprom.subvendor == (unsigned int)-1) {\n\t\t\t\tdev_err(ice->card->dev,\n\t\t\t\t\t\"No valid ID is found\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t}\n\t}\n\tfor (tbl = card_tables; *tbl; tbl++) {\n\t\tfor (c = *tbl; c->name; c++) {\n\t\t\tif (modelname && c->model &&\n\t\t\t    !strcmp(modelname, c->model)) {\n\t\t\t\tdev_info(ice->card->dev,\n\t\t\t\t\t \"Using board model %s\\n\",\n\t\t\t\t       c->name);\n\t\t\t\tice->eeprom.subvendor = c->subvendor;\n\t\t\t} else if (c->subvendor != ice->eeprom.subvendor)\n\t\t\t\tcontinue;\n\t\t\tice->card_info = c;\n\t\t\tif (!c->eeprom_size || !c->eeprom_data)\n\t\t\t\tgoto found;\n\t\t\t \n\t\t\tdev_dbg(ice->card->dev, \"using the defined eeprom..\\n\");\n\t\t\tice->eeprom.version = 2;\n\t\t\tice->eeprom.size = c->eeprom_size + 6;\n\t\t\tmemcpy(ice->eeprom.data, c->eeprom_data, c->eeprom_size);\n\t\t\tgoto read_skipped;\n\t\t}\n\t}\n\tdev_warn(ice->card->dev, \"No matching model found for ID 0x%x\\n\",\n\t       ice->eeprom.subvendor);\n#ifdef CONFIG_PM_SLEEP\n\t \n\tice->pm_suspend_enabled = 1;\n#endif\n\n found:\n\tice->eeprom.size = snd_vt1724_read_i2c(ice, dev, 0x04);\n\tif (ice->eeprom.size < 6)\n\t\tice->eeprom.size = 32;\n\telse if (ice->eeprom.size > 32) {\n\t\tdev_err(ice->card->dev, \"Invalid EEPROM (size = %i)\\n\",\n\t\t       ice->eeprom.size);\n\t\treturn -EIO;\n\t}\n\tice->eeprom.version = snd_vt1724_read_i2c(ice, dev, 0x05);\n\tif (ice->eeprom.version != 1 && ice->eeprom.version != 2)\n\t\tdev_warn(ice->card->dev, \"Invalid EEPROM version %i\\n\",\n\t\t       ice->eeprom.version);\n\tsize = ice->eeprom.size - 6;\n\tfor (i = 0; i < size; i++)\n\t\tice->eeprom.data[i] = snd_vt1724_read_i2c(ice, dev, i + 6);\n\n read_skipped:\n\tice->eeprom.gpiomask = eeprom_triple(ice, ICE_EEP2_GPIO_MASK);\n\tice->eeprom.gpiostate = eeprom_triple(ice, ICE_EEP2_GPIO_STATE);\n\tice->eeprom.gpiodir = eeprom_triple(ice, ICE_EEP2_GPIO_DIR);\n\n\treturn 0;\n}\n\n\n\nstatic void snd_vt1724_chip_reset(struct snd_ice1712 *ice)\n{\n\toutb(VT1724_RESET , ICEREG1724(ice, CONTROL));\n\tinb(ICEREG1724(ice, CONTROL));  \n\tmsleep(10);\n\toutb(0, ICEREG1724(ice, CONTROL));\n\tinb(ICEREG1724(ice, CONTROL));  \n\tmsleep(10);\n}\n\nstatic int snd_vt1724_chip_init(struct snd_ice1712 *ice)\n{\n\toutb(ice->eeprom.data[ICE_EEP2_SYSCONF], ICEREG1724(ice, SYS_CFG));\n\toutb(ice->eeprom.data[ICE_EEP2_ACLINK], ICEREG1724(ice, AC97_CFG));\n\toutb(ice->eeprom.data[ICE_EEP2_I2S], ICEREG1724(ice, I2S_FEATURES));\n\toutb(ice->eeprom.data[ICE_EEP2_SPDIF], ICEREG1724(ice, SPDIF_CFG));\n\n\tice->gpio.write_mask = ice->eeprom.gpiomask;\n\tice->gpio.direction = ice->eeprom.gpiodir;\n\tsnd_vt1724_set_gpio_mask(ice, ice->eeprom.gpiomask);\n\tsnd_vt1724_set_gpio_dir(ice, ice->eeprom.gpiodir);\n\tsnd_vt1724_set_gpio_data(ice, ice->eeprom.gpiostate);\n\n\toutb(0, ICEREG1724(ice, POWERDOWN));\n\n\t \n\toutb(VT1724_IRQ_MPU_RX | VT1724_IRQ_MPU_TX , ICEREG1724(ice, IRQMASK));\n\n\t \n\toutb(VT1724_MULTI_FIFO_ERR, ICEMT1724(ice, DMA_INT_MASK));\n\n\treturn 0;\n}\n\nstatic int snd_vt1724_spdif_build_controls(struct snd_ice1712 *ice)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!ice->pcm))\n\t\treturn -EIO;\n\n\tif (!ice->own_routing) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\tsnd_ctl_new1(&snd_vt1724_mixer_pro_spdif_route, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_spdif_switch, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\tkctl = snd_ctl_new1(&snd_vt1724_spdif_default, ice);\n\tkctl->id.device = ice->pcm->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_vt1724_spdif_maskc, ice);\n\tkctl->id.device = ice->pcm->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_vt1724_spdif_maskp, ice);\n\tkctl->id.device = ice->pcm->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n#if 0  \n\tkctl = snd_ctl_new1(&snd_vt1724_spdif_stream, ice);\n\tkctl->id.device = ice->pcm->device;\n\terr = snd_ctl_add(ice->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tice->spdif.stream_ctl = kctl;\n#endif\n\treturn 0;\n}\n\n\nstatic int snd_vt1724_build_controls(struct snd_ice1712 *ice)\n{\n\tint err;\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_eeprom, ice));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_internal_clock, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_rate_locking, ice));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_rate_reset, ice));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!ice->own_routing && ice->num_total_dacs > 0) {\n\t\tstruct snd_kcontrol_new tmp = snd_vt1724_mixer_pro_analog_route;\n\t\ttmp.count = ice->num_total_dacs;\n\t\tif (ice->vt1720 && tmp.count > 2)\n\t\t\ttmp.count = 2;\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&tmp, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_ctl_add(ice->card,\n\t\t\t   snd_ctl_new1(&snd_vt1724_mixer_pro_peak, ice));\n}\n\nstatic void snd_vt1724_free(struct snd_card *card)\n{\n\tstruct snd_ice1712 *ice = card->private_data;\n\n\t \n\toutb(0xff, ICEMT1724(ice, DMA_INT_MASK));\n\toutb(0xff, ICEREG1724(ice, IRQMASK));\n\n\tsnd_ice1712_akm4xxx_free(ice);\n}\n\nstatic int snd_vt1724_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci,\n\t\t\t     const char *modelname)\n{\n\tstruct snd_ice1712 *ice = card->private_data;\n\tint err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tice->vt1724 = 1;\n\tspin_lock_init(&ice->reg_lock);\n\tmutex_init(&ice->gpio_mutex);\n\tmutex_init(&ice->open_mutex);\n\tmutex_init(&ice->i2c_mutex);\n\tice->gpio.set_mask = snd_vt1724_set_gpio_mask;\n\tice->gpio.get_mask = snd_vt1724_get_gpio_mask;\n\tice->gpio.set_dir = snd_vt1724_set_gpio_dir;\n\tice->gpio.get_dir = snd_vt1724_get_gpio_dir;\n\tice->gpio.set_data = snd_vt1724_set_gpio_data;\n\tice->gpio.get_data = snd_vt1724_get_gpio_data;\n\tice->card = card;\n\tice->pci = pci;\n\tice->irq = -1;\n\tpci_set_master(pci);\n\tsnd_vt1724_proc_init(ice);\n\n\terr = pci_request_regions(pci, \"ICE1724\");\n\tif (err < 0)\n\t\treturn err;\n\tice->port = pci_resource_start(pci, 0);\n\tice->profi_port = pci_resource_start(pci, 1);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_vt1724_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, ice)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EIO;\n\t}\n\n\tice->irq = pci->irq;\n\tcard->sync_irq = ice->irq;\n\tcard->private_free = snd_vt1724_free;\n\n\tsnd_vt1724_chip_reset(ice);\n\tif (snd_vt1724_read_eeprom(ice, modelname) < 0)\n\t\treturn -EIO;\n\tif (snd_vt1724_chip_init(ice) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n \n\nstatic int __snd_vt1724_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_ice1712 *ice;\n\tint pcm_dev = 0, err;\n\tconst struct snd_ice1712_card_info *c;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*ice), &card);\n\tif (err < 0)\n\t\treturn err;\n\tice = card->private_data;\n\n\tstrcpy(card->driver, \"ICE1724\");\n\tstrcpy(card->shortname, \"ICEnsemble ICE1724\");\n\n\terr = snd_vt1724_create(card, pci, model[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tice->ext_clock_count = 0;\n\n\tc = ice->card_info;\n\tif (c) {\n\t\tstrcpy(card->shortname, c->name);\n\t\tif (c->driver)  \n\t\t\tstrcpy(card->driver, c->driver);\n\t\tif (c->chip_init) {\n\t\t\terr = c->chip_init(ice);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tice->pro_rate_default = PRO_RATE_DEFAULT;\n\tif (!ice->is_spdif_master)\n\t\tice->is_spdif_master = stdclock_is_spdif_master;\n\tif (!ice->get_rate)\n\t\tice->get_rate = stdclock_get_rate;\n\tif (!ice->set_rate)\n\t\tice->set_rate = stdclock_set_rate;\n\tif (!ice->set_mclk)\n\t\tice->set_mclk = stdclock_set_mclk;\n\tif (!ice->set_spdif_clock)\n\t\tice->set_spdif_clock = stdclock_set_spdif_clock;\n\tif (!ice->get_spdif_master_type)\n\t\tice->get_spdif_master_type = stdclock_get_spdif_master_type;\n\tif (!ice->ext_clock_names)\n\t\tice->ext_clock_names = ext_clock_names;\n\tif (!ice->ext_clock_count)\n\t\tice->ext_clock_count = ARRAY_SIZE(ext_clock_names);\n\n\tif (!ice->hw_rates)\n\t\tset_std_hw_rates(ice);\n\n\terr = snd_vt1724_pcm_profi(ice, pcm_dev++);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_vt1724_pcm_spdif(ice, pcm_dev++);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_vt1724_pcm_indep(ice, pcm_dev++);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_vt1724_ac97_mixer(ice);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_vt1724_build_controls(ice);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ice->pcm && ice->has_spdif) {  \n\t\terr = snd_vt1724_spdif_build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (c && c->build_controls) {\n\t\terr = c->build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!c || !c->no_mpu401) {\n\t\tif (ice->eeprom.data[ICE_EEP2_SYSCONF] & VT1724_CFG_MPU401) {\n\t\t\tstruct snd_rawmidi *rmidi;\n\n\t\t\terr = snd_rawmidi_new(card, \"MIDI\", 0, 1, 1, &rmidi);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tice->rmidi[0] = rmidi;\n\t\t\trmidi->private_data = ice;\n\t\t\tstrcpy(rmidi->name, \"ICE1724 MIDI\");\n\t\t\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\t\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t    &vt1724_midi_output_ops);\n\t\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t    &vt1724_midi_input_ops);\n\n\t\t\t \n\t\t\toutb(VT1724_MPU_RX_FIFO | 0x1,\n\t\t\t     ICEREG1724(ice, MPU_FIFO_WM));\n\t\t\toutb(0x1, ICEREG1724(ice, MPU_FIFO_WM));\n\t\t\t \n\t\t\toutb(VT1724_MPU_UART, ICEREG1724(ice, MPU_CTRL));\n\t\t}\n\t}\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, ice->port, ice->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_vt1724_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_vt1724_probe(pci, pci_id));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_vt1724_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ice1712 *ice = card->private_data;\n\n\tif (!ice->pm_suspend_enabled)\n\t\treturn 0;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tsnd_ac97_suspend(ice->ac97);\n\n\tspin_lock_irq(&ice->reg_lock);\n\tice->pm_saved_is_spdif_master = ice->is_spdif_master(ice);\n\tice->pm_saved_spdif_ctrl = inw(ICEMT1724(ice, SPDIF_CTRL));\n\tice->pm_saved_spdif_cfg = inb(ICEREG1724(ice, SPDIF_CFG));\n\tice->pm_saved_route = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\n\tspin_unlock_irq(&ice->reg_lock);\n\n\tif (ice->pm_suspend)\n\t\tice->pm_suspend(ice);\n\treturn 0;\n}\n\nstatic int snd_vt1724_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ice1712 *ice = card->private_data;\n\n\tif (!ice->pm_suspend_enabled)\n\t\treturn 0;\n\n\tsnd_vt1724_chip_reset(ice);\n\n\tif (snd_vt1724_chip_init(ice) < 0) {\n\t\tsnd_card_disconnect(card);\n\t\treturn -EIO;\n\t}\n\n\tif (ice->pm_resume)\n\t\tice->pm_resume(ice);\n\n\tif (ice->pm_saved_is_spdif_master) {\n\t\t \n\t\tice->set_spdif_clock(ice, 0);\n\t} else {\n\t\t \n\t\tint rate;\n\t\tif (ice->cur_rate)\n\t\t\trate = ice->cur_rate;\n\t\telse\n\t\t\trate = ice->pro_rate_default;\n\t\tsnd_vt1724_set_pro_rate(ice, rate, 1);\n\t}\n\n\tupdate_spdif_bits(ice, ice->pm_saved_spdif_ctrl);\n\n\toutb(ice->pm_saved_spdif_cfg, ICEREG1724(ice, SPDIF_CFG));\n\toutl(ice->pm_saved_route, ICEMT1724(ice, ROUTE_PLAYBACK));\n\n\tsnd_ac97_resume(ice->ac97);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_vt1724_pm, snd_vt1724_suspend, snd_vt1724_resume);\n#define SND_VT1724_PM_OPS\t&snd_vt1724_pm\n#else\n#define SND_VT1724_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver vt1724_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_vt1724_ids,\n\t.probe = snd_vt1724_probe,\n\t.driver = {\n\t\t.pm = SND_VT1724_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(vt1724_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}