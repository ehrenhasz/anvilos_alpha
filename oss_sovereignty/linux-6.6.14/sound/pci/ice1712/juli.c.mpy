{
  "module_name": "juli.c",
  "hash_id": "2ce6ca4b69fb2aa77a66d8881d84c55a14ee7d11938a53477b90c2eed2187dec",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/juli.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"juli.h\"\n\nstruct juli_spec {\n\tstruct ak4114 *ak4114;\n\tunsigned int analog:1;\n};\n\n \n#define AK4114_ADDR\t\t0x20\t\t \n#define AK4358_ADDR\t\t0x22\t\t \n\n \n\n \n#define GPIO_FREQ_MASK\t\t(3<<0)\n#define GPIO_FREQ_32KHZ\t\t(0<<0)\n#define GPIO_FREQ_44KHZ\t\t(1<<0)\n#define GPIO_FREQ_48KHZ\t\t(2<<0)\n#define GPIO_MULTI_MASK\t\t(3<<2)\n#define GPIO_MULTI_4X\t\t(0<<2)\n#define GPIO_MULTI_2X\t\t(1<<2)\n#define GPIO_MULTI_1X\t\t(2<<2)\t\t \n#define GPIO_MULTI_HALF\t\t(3<<2)\n#define GPIO_INTERNAL_CLOCK\t(1<<4)\t\t \n#define GPIO_CLOCK_MASK\t\t(1<<4)\n#define GPIO_ANALOG_PRESENT\t(1<<5)\t\t \n#define GPIO_RXMCLK_SEL\t\t(1<<7)\t\t \n#define GPIO_AK5385A_CKS0\t(1<<8)\n#define GPIO_AK5385A_DFS1\t(1<<9)\n#define GPIO_AK5385A_DFS0\t(1<<10)\n#define GPIO_DIGOUT_MONITOR\t(1<<11)\t\t \n#define GPIO_DIGIN_MONITOR\t(1<<12)\t\t \n#define GPIO_ANAIN_MONITOR\t(1<<13)\t\t \n#define GPIO_AK5385A_CKS1\t(1<<14)\t\t \n#define GPIO_MUTE_CONTROL\t(1<<15)\t\t \n\n#define GPIO_RATE_MASK\t\t(GPIO_FREQ_MASK | GPIO_MULTI_MASK | \\\n\t\tGPIO_CLOCK_MASK)\n#define GPIO_AK5385A_MASK\t(GPIO_AK5385A_CKS0 | GPIO_AK5385A_DFS0 | \\\n\t\tGPIO_AK5385A_DFS1 | GPIO_AK5385A_CKS1)\n\n#define JULI_PCM_RATE\t(SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \\\n\t\tSNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 | \\\n\t\tSNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \\\n\t\tSNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)\n\n#define GPIO_RATE_16000\t\t(GPIO_FREQ_32KHZ | GPIO_MULTI_HALF | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_22050\t\t(GPIO_FREQ_44KHZ | GPIO_MULTI_HALF | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_24000\t\t(GPIO_FREQ_48KHZ | GPIO_MULTI_HALF | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_32000\t\t(GPIO_FREQ_32KHZ | GPIO_MULTI_1X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_44100\t\t(GPIO_FREQ_44KHZ | GPIO_MULTI_1X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_48000\t\t(GPIO_FREQ_48KHZ | GPIO_MULTI_1X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_64000\t\t(GPIO_FREQ_32KHZ | GPIO_MULTI_2X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_88200\t\t(GPIO_FREQ_44KHZ | GPIO_MULTI_2X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_96000\t\t(GPIO_FREQ_48KHZ | GPIO_MULTI_2X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_176400\t(GPIO_FREQ_44KHZ | GPIO_MULTI_4X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n#define GPIO_RATE_192000\t(GPIO_FREQ_48KHZ | GPIO_MULTI_4X | \\\n\t\tGPIO_INTERNAL_CLOCK)\n\n \nstatic const unsigned int juli_rates[] = {\n\t16000, 22050, 24000, 32000,\n\t44100, 48000, 64000, 88200,\n\t96000, 176400, 192000,\n};\n\nstatic const unsigned int gpio_vals[] = {\n\tGPIO_RATE_16000, GPIO_RATE_22050, GPIO_RATE_24000, GPIO_RATE_32000,\n\tGPIO_RATE_44100, GPIO_RATE_48000, GPIO_RATE_64000, GPIO_RATE_88200,\n\tGPIO_RATE_96000, GPIO_RATE_176400, GPIO_RATE_192000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list juli_rates_info = {\n\t.count = ARRAY_SIZE(juli_rates),\n\t.list = juli_rates,\n\t.mask = 0,\n};\n\nstatic int get_gpio_val(int rate)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(juli_rates); i++)\n\t\tif (juli_rates[i] == rate)\n\t\t\treturn gpio_vals[i];\n\treturn 0;\n}\n\nstatic void juli_ak4114_write(void *private_data, unsigned char reg,\n\t\t\t\tunsigned char val)\n{\n\tsnd_vt1724_write_i2c((struct snd_ice1712 *)private_data, AK4114_ADDR,\n\t\t\t\treg, val);\n}\n\nstatic unsigned char juli_ak4114_read(void *private_data, unsigned char reg)\n{\n\treturn snd_vt1724_read_i2c((struct snd_ice1712 *)private_data,\n\t\t\t\t\tAK4114_ADDR, reg);\n}\n\n \nstatic void juli_spdif_in_open(struct snd_ice1712 *ice,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct juli_spec *spec = ice->spec;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint rate;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\n\t\t\t!ice->is_spdif_master(ice))\n\t\treturn;\n\trate = snd_ak4114_external_rate(spec->ak4114);\n\tif (rate >= runtime->hw.rate_min && rate <= runtime->hw.rate_max) {\n\t\truntime->hw.rate_min = rate;\n\t\truntime->hw.rate_max = rate;\n\t}\n}\n\n \n\nstatic void juli_akm_lock(struct snd_akm4xxx *ak, int chip)\n{\n}\n\nstatic void juli_akm_unlock(struct snd_akm4xxx *ak, int chip)\n{\n}\n\nstatic void juli_akm_write(struct snd_akm4xxx *ak, int chip,\n\t\t\t   unsigned char addr, unsigned char data)\n{\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\t \n\tif (snd_BUG_ON(chip))\n\t\treturn;\n\tsnd_vt1724_write_i2c(ice, AK4358_ADDR, addr, data);\n}\n\n \nstatic void juli_akm_set_rate_val(struct snd_akm4xxx *ak, unsigned int rate)\n{\n\tunsigned char old, tmp, ak4358_dfs;\n\tunsigned int ak5385_pins, old_gpio, new_gpio;\n\tstruct snd_ice1712 *ice = ak->private_data[0];\n\tstruct juli_spec *spec = ice->spec;\n\n\tif (rate == 0)   \n\t\treturn;\n\n\t \n\tif (rate > 96000)  {\n\t\tak4358_dfs = 2;\n\t\tak5385_pins = GPIO_AK5385A_DFS1 | GPIO_AK5385A_CKS0;\n\t} else if (rate > 48000) {\n\t\tak4358_dfs = 1;\n\t\tak5385_pins = GPIO_AK5385A_DFS0;\n\t} else {\n\t\tak4358_dfs = 0;\n\t\tak5385_pins = 0;\n\t}\n\t \n\told_gpio = ice->gpio.get_data(ice);\n\tnew_gpio =  (old_gpio & ~GPIO_AK5385A_MASK) | ak5385_pins;\n\t \n\tice->gpio.set_data(ice, new_gpio);\n\n\t \n\told = inb(ICEMT1724(ice, AC97_CMD));\n\toutb(old | VT1724_AC97_COLD, ICEMT1724(ice, AC97_CMD));\n\tudelay(1);\n\toutb(old & ~VT1724_AC97_COLD, ICEMT1724(ice, AC97_CMD));\n\n\t \n\t \n\ttmp = snd_akm4xxx_get(ak, 0, 2);\n\tsnd_akm4xxx_reset(ak, 1);\n\ttmp = snd_akm4xxx_get(ak, 0, 2);\n\ttmp &= ~(0x03 << 4);\n\ttmp |= ak4358_dfs << 4;\n\tsnd_akm4xxx_set(ak, 0, 2, tmp);\n\tsnd_akm4xxx_reset(ak, 0);\n\n\t \n\tsnd_ak4114_reinit(spec->ak4114);\n}\n\n#define AK_DAC(xname, xch)\t{ .name = xname, .num_channels = xch }\n#define PCM_VOLUME\t\t\"PCM Playback Volume\"\n#define MONITOR_AN_IN_VOLUME\t\"Monitor Analog In Volume\"\n#define MONITOR_DIG_IN_VOLUME\t\"Monitor Digital In Volume\"\n#define MONITOR_DIG_OUT_VOLUME\t\"Monitor Digital Out Volume\"\n\nstatic const struct snd_akm4xxx_dac_channel juli_dac[] = {\n\tAK_DAC(PCM_VOLUME, 2),\n\tAK_DAC(MONITOR_AN_IN_VOLUME, 2),\n\tAK_DAC(MONITOR_DIG_OUT_VOLUME, 2),\n\tAK_DAC(MONITOR_DIG_IN_VOLUME, 2),\n};\n\n\nstatic const struct snd_akm4xxx akm_juli_dac = {\n\t.type = SND_AK4358,\n\t.num_dacs = 8,\t \n\t.ops = {\n\t\t.lock = juli_akm_lock,\n\t\t.unlock = juli_akm_unlock,\n\t\t.write = juli_akm_write,\n\t\t.set_rate_val = juli_akm_set_rate_val\n\t},\n\t.dac_info = juli_dac,\n};\n\n#define juli_mute_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int juli_mute_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tval = ice->gpio.get_data(ice) & (unsigned int) kcontrol->private_value;\n\tif (kcontrol->private_value == GPIO_MUTE_CONTROL)\n\t\t \n\t\tucontrol->value.integer.value[0] = (val) ? 0 : 1;\n\telse\n\t\t \n\t\tucontrol->value.integer.value[0] = (val) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int juli_mute_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned int old_gpio, new_gpio;\n\told_gpio = ice->gpio.get_data(ice);\n\tif (ucontrol->value.integer.value[0]) {\n\t\t \n\t\tif (kcontrol->private_value == GPIO_MUTE_CONTROL) {\n\t\t\t \n\t\t\tnew_gpio = old_gpio & ~GPIO_MUTE_CONTROL;\n\t\t\t \n\t\t\tsnd_akm4xxx_write(ice->akm, 0, 0x01, 0x01);\n\t\t} else\n\t\t\t \n\t\t\tnew_gpio =  old_gpio |\n\t\t\t\t(unsigned int) kcontrol->private_value;\n\t} else {\n\t\t \n\t\tif (kcontrol->private_value == GPIO_MUTE_CONTROL) {\n\t\t\t \n\t\t\tnew_gpio = old_gpio | GPIO_MUTE_CONTROL;\n\t\t\t \n\t\t\tsnd_akm4xxx_write(ice->akm, 0, 0x01, 0x03);\n\t\t} else\n\t\t\t \n\t\t\tnew_gpio =  old_gpio &\n\t\t\t\t~((unsigned int) kcontrol->private_value);\n\t}\n\t \n\tif (old_gpio != new_gpio) {\n\t\tice->gpio.set_data(ice, new_gpio);\n\t\treturn 1;\n\t}\n\t \n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new juli_mute_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = juli_mute_info,\n\t\t.get = juli_mute_get,\n\t\t.put = juli_mute_put,\n\t\t.private_value = GPIO_MUTE_CONTROL,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Monitor Analog In Switch\",\n\t\t.info = juli_mute_info,\n\t\t.get = juli_mute_get,\n\t\t.put = juli_mute_put,\n\t\t.private_value = GPIO_ANAIN_MONITOR,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Monitor Digital Out Switch\",\n\t\t.info = juli_mute_info,\n\t\t.get = juli_mute_get,\n\t\t.put = juli_mute_put,\n\t\t.private_value = GPIO_DIGOUT_MONITOR,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Monitor Digital In Switch\",\n\t\t.info = juli_mute_info,\n\t\t.get = juli_mute_get,\n\t\t.put = juli_mute_put,\n\t\t.private_value = GPIO_DIGIN_MONITOR,\n\t},\n};\n\nstatic const char * const follower_vols[] = {\n\tPCM_VOLUME,\n\tMONITOR_AN_IN_VOLUME,\n\tMONITOR_DIG_IN_VOLUME,\n\tMONITOR_DIG_OUT_VOLUME,\n\tNULL\n};\n\nstatic\nDECLARE_TLV_DB_SCALE(juli_master_db_scale, -6350, 50, 1);\n\nstatic int juli_add_controls(struct snd_ice1712 *ice)\n{\n\tstruct juli_spec *spec = ice->spec;\n\tint err;\n\tunsigned int i;\n\tstruct snd_kcontrol *vmaster;\n\n\terr = snd_ice1712_akm4xxx_build_controls(ice);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(juli_mute_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\tsnd_ctl_new1(&juli_mute_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tvmaster = snd_ctl_make_virtual_master(\"Master Playback Volume\",\n\t\t\t\t\t      juli_master_db_scale);\n\tif (!vmaster)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(ice->card, vmaster);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add_followers(ice->card, vmaster, follower_vols);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn snd_ak4114_build(spec->ak4114, NULL,\n\t\t\tice->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n}\n\n \n\n#ifdef CONFIG_PM_SLEEP\nstatic int juli_resume(struct snd_ice1712 *ice)\n{\n\tstruct snd_akm4xxx *ak = ice->akm;\n\tstruct juli_spec *spec = ice->spec;\n\t \n\tsnd_akm4xxx_reset(ak, 0);\n\t \n\tsnd_ak4114_resume(spec->ak4114);\n\treturn 0;\n}\n\nstatic int juli_suspend(struct snd_ice1712 *ice)\n{\n\tstruct snd_akm4xxx *ak = ice->akm;\n\tstruct juli_spec *spec = ice->spec;\n\t \n\tsnd_akm4xxx_reset(ak, 1);\n\tsnd_ak4114_suspend(spec->ak4114);\n\treturn 0;\n}\n#endif\n\n \n\nstatic inline int juli_is_spdif_master(struct snd_ice1712 *ice)\n{\n\treturn (ice->gpio.get_data(ice) & GPIO_INTERNAL_CLOCK) ? 0 : 1;\n}\n\nstatic unsigned int juli_get_rate(struct snd_ice1712 *ice)\n{\n\tint i;\n\tunsigned char result;\n\n\tresult =  ice->gpio.get_data(ice) & GPIO_RATE_MASK;\n\tfor (i = 0; i < ARRAY_SIZE(gpio_vals); i++)\n\t\tif (gpio_vals[i] == result)\n\t\t\treturn juli_rates[i];\n\treturn 0;\n}\n\n \nstatic void juli_set_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tunsigned int old, new;\n\tunsigned char val;\n\n\told = ice->gpio.get_data(ice);\n\tnew =  (old & ~GPIO_RATE_MASK) | get_gpio_val(rate);\n\t \n\n\tice->gpio.set_data(ice, new);\n\t \n\tval = inb(ICEMT1724(ice, RATE));\n\toutb(val | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\n}\n\nstatic inline unsigned char juli_set_mclk(struct snd_ice1712 *ice,\n\t\t\t\t\t  unsigned int rate)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int juli_set_spdif_clock(struct snd_ice1712 *ice, int type)\n{\n\tunsigned int old;\n\told = ice->gpio.get_data(ice);\n\t \n\tice->gpio.set_data(ice, (old & ~GPIO_RATE_MASK) | GPIO_MULTI_1X |\n\t\t\tGPIO_FREQ_48KHZ);\n\treturn 0;\n}\n\n \nstatic void juli_ak4114_change(struct ak4114 *ak4114, unsigned char c0,\n\t\t\t       unsigned char c1)\n{\n\tstruct snd_ice1712 *ice = ak4114->change_callback_private;\n\tint rate;\n\tif (ice->is_spdif_master(ice) && c1) {\n\t\t \n\t\trate = snd_ak4114_external_rate(ak4114);\n\t\t \n\t\tjuli_akm_set_rate_val(ice->akm, rate);\n\t}\n}\n\nstatic int juli_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned char ak4114_init_vals[] = {\n\t\t \tAK4114_RST | AK4114_PWN |\n\t\t\t\t\tAK4114_OCKS0 | AK4114_OCKS1,\n\t\t \tAK4114_DIF_I24I2S,\n\t\t \tAK4114_TX1E,\n\t\t \tAK4114_EFH_1024 | AK4114_DIT |\n\t\t\t\t\tAK4114_IPS(1),\n\t\t  0,\n\t\t  0\n\t};\n\tstatic const unsigned char ak4114_init_txcsb[] = {\n\t\t0x41, 0x02, 0x2c, 0x00, 0x00\n\t};\n\tint err;\n\tstruct juli_spec *spec;\n\tstruct snd_akm4xxx *ak;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\terr = snd_ak4114_create(ice->card,\n\t\t\t\tjuli_ak4114_read,\n\t\t\t\tjuli_ak4114_write,\n\t\t\t\tak4114_init_vals, ak4114_init_txcsb,\n\t\t\t\tice, &spec->ak4114);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tspec->ak4114->change_callback = juli_ak4114_change;\n\tspec->ak4114->change_callback_private = ice;\n\t \n\tspec->ak4114->check_flags = 0;\n\n#if 0\n \n\tspec->analog = (ice->gpio.get_data(ice) & GPIO_ANALOG_PRESENT) ? 0 : 1;\n#else\n\tspec->analog = 1;\n#endif\n\n\tif (spec->analog) {\n\t\tdev_info(ice->card->dev, \"juli@: analog I/O detected\\n\");\n\t\tice->num_total_dacs = 2;\n\t\tice->num_total_adcs = 2;\n\n\t\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\t\tak = ice->akm;\n\t\tif (!ak)\n\t\t\treturn -ENOMEM;\n\t\tice->akm_codecs = 1;\n\t\terr = snd_ice1712_akm4xxx_init(ak, &akm_juli_dac, NULL, ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tice->hw_rates = &juli_rates_info;\n\tice->is_spdif_master = juli_is_spdif_master;\n\tice->get_rate = juli_get_rate;\n\tice->set_rate = juli_set_rate;\n\tice->set_mclk = juli_set_mclk;\n\tice->set_spdif_clock = juli_set_spdif_clock;\n\n\tice->spdif.ops.open = juli_spdif_in_open;\n\n#ifdef CONFIG_PM_SLEEP\n\tice->pm_resume = juli_resume;\n\tice->pm_suspend = juli_suspend;\n\tice->pm_suspend_enabled = 1;\n#endif\n\n\treturn 0;\n}\n\n\n \n\nstatic const unsigned char juli_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x2b,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xf8,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0x9f,\t \n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x7f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x60,\t \n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,   \n\t[ICE_EEP2_GPIO_MASK2]  = 0x7f,\n\t[ICE_EEP2_GPIO_STATE]  = GPIO_FREQ_48KHZ | GPIO_MULTI_1X |\n\t       GPIO_INTERNAL_CLOCK,\t \n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\t \n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\n \nstruct snd_ice1712_card_info snd_vt1724_juli_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_JULI,\n\t\t.name = \"ESI Juli@\",\n\t\t.model = \"juli\",\n\t\t.chip_init = juli_init,\n\t\t.build_controls = juli_add_controls,\n\t\t.eeprom_size = sizeof(juli_eeprom),\n\t\t.eeprom_data = juli_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}