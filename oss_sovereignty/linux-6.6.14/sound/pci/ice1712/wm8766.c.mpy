{
  "module_name": "wm8766.c",
  "hash_id": "b34322e0e86335c9437b0820ede96419fbcb1af095ab7e9d581473e8f31faf55",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/wm8766.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"wm8766.h\"\n\n \n\nstatic void snd_wm8766_write(struct snd_wm8766 *wm, u16 addr, u16 data)\n{\n\tif (addr < WM8766_REG_COUNT)\n\t\twm->regs[addr] = data;\n\twm->ops.write(wm, addr, data);\n}\n\n \n\nstatic const DECLARE_TLV_DB_SCALE(wm8766_tlv, -12750, 50, 1);\n\nstatic const struct snd_wm8766_ctl snd_wm8766_default_ctl[WM8766_CTL_COUNT] = {\n\t[WM8766_CTL_CH1_VOL] = {\n\t\t.name = \"Channel 1 Playback Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8766_tlv,\n\t\t.reg1 = WM8766_REG_DACL1,\n\t\t.reg2 = WM8766_REG_DACR1,\n\t\t.mask1 = WM8766_VOL_MASK,\n\t\t.mask2 = WM8766_VOL_MASK,\n\t\t.max = 0xff,\n\t\t.flags = WM8766_FLAG_STEREO | WM8766_FLAG_VOL_UPDATE,\n\t},\n\t[WM8766_CTL_CH2_VOL] = {\n\t\t.name = \"Channel 2 Playback Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8766_tlv,\n\t\t.reg1 = WM8766_REG_DACL2,\n\t\t.reg2 = WM8766_REG_DACR2,\n\t\t.mask1 = WM8766_VOL_MASK,\n\t\t.mask2 = WM8766_VOL_MASK,\n\t\t.max = 0xff,\n\t\t.flags = WM8766_FLAG_STEREO | WM8766_FLAG_VOL_UPDATE,\n\t},\n\t[WM8766_CTL_CH3_VOL] = {\n\t\t.name = \"Channel 3 Playback Volume\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_INTEGER,\n\t\t.tlv = wm8766_tlv,\n\t\t.reg1 = WM8766_REG_DACL3,\n\t\t.reg2 = WM8766_REG_DACR3,\n\t\t.mask1 = WM8766_VOL_MASK,\n\t\t.mask2 = WM8766_VOL_MASK,\n\t\t.max = 0xff,\n\t\t.flags = WM8766_FLAG_STEREO | WM8766_FLAG_VOL_UPDATE,\n\t},\n\t[WM8766_CTL_CH1_SW] = {\n\t\t.name = \"Channel 1 Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_MUTE1,\n\t\t.flags = WM8766_FLAG_INVERT,\n\t},\n\t[WM8766_CTL_CH2_SW] = {\n\t\t.name = \"Channel 2 Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_MUTE2,\n\t\t.flags = WM8766_FLAG_INVERT,\n\t},\n\t[WM8766_CTL_CH3_SW] = {\n\t\t.name = \"Channel 3 Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_MUTE3,\n\t\t.flags = WM8766_FLAG_INVERT,\n\t},\n\t[WM8766_CTL_PHASE1_SW] = {\n\t\t.name = \"Channel 1 Phase Invert Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_IFCTRL,\n\t\t.mask1 = WM8766_PHASE_INVERT1,\n\t},\n\t[WM8766_CTL_PHASE2_SW] = {\n\t\t.name = \"Channel 2 Phase Invert Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_IFCTRL,\n\t\t.mask1 = WM8766_PHASE_INVERT2,\n\t},\n\t[WM8766_CTL_PHASE3_SW] = {\n\t\t.name = \"Channel 3 Phase Invert Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_IFCTRL,\n\t\t.mask1 = WM8766_PHASE_INVERT3,\n\t},\n\t[WM8766_CTL_DEEMPH1_SW] = {\n\t\t.name = \"Channel 1 Deemphasis Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_DEEMP1,\n\t},\n\t[WM8766_CTL_DEEMPH2_SW] = {\n\t\t.name = \"Channel 2 Deemphasis Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_DEEMP2,\n\t},\n\t[WM8766_CTL_DEEMPH3_SW] = {\n\t\t.name = \"Channel 3 Deemphasis Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_DEEMP3,\n\t},\n\t[WM8766_CTL_IZD_SW] = {\n\t\t.name = \"Infinite Zero Detect Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL1,\n\t\t.mask1 = WM8766_DAC_IZD,\n\t},\n\t[WM8766_CTL_ZC_SW] = {\n\t\t.name = \"Zero Cross Detect Playback Switch\",\n\t\t.type = SNDRV_CTL_ELEM_TYPE_BOOLEAN,\n\t\t.reg1 = WM8766_REG_DACCTRL2,\n\t\t.mask1 = WM8766_DAC2_ZCD,\n\t\t.flags = WM8766_FLAG_INVERT,\n\t},\n};\n\n \n\nvoid snd_wm8766_init(struct snd_wm8766 *wm)\n{\n\tint i;\n\tstatic const u16 default_values[] = {\n\t\t0x000, 0x100,\n\t\t0x120, 0x000,\n\t\t0x000, 0x100, 0x000, 0x100, 0x000,\n\t\t0x000, 0x080,\n\t};\n\n\tmemcpy(wm->ctl, snd_wm8766_default_ctl, sizeof(wm->ctl));\n\n\tsnd_wm8766_write(wm, WM8766_REG_RESET, 0x00);  \n\tudelay(10);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(default_values); i++)\n\t\tsnd_wm8766_write(wm, i, default_values[i]);\n}\n\nvoid snd_wm8766_resume(struct snd_wm8766 *wm)\n{\n\tint i;\n\n\tfor (i = 0; i < WM8766_REG_COUNT; i++)\n\t\tsnd_wm8766_write(wm, i, wm->regs[i]);\n}\n\nvoid snd_wm8766_set_if(struct snd_wm8766 *wm, u16 dac)\n{\n\tu16 val = wm->regs[WM8766_REG_IFCTRL] & ~WM8766_IF_MASK;\n\n\tdac &= WM8766_IF_MASK;\n\tsnd_wm8766_write(wm, WM8766_REG_IFCTRL, val | dac);\n}\n\nvoid snd_wm8766_volume_restore(struct snd_wm8766 *wm)\n{\n\tu16 val = wm->regs[WM8766_REG_DACR1];\n\t \n\tsnd_wm8766_write(wm, WM8766_REG_DACR1, val | WM8766_VOL_UPDATE);\n}\n\n \n\nstatic int snd_wm8766_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = (wm->ctl[n].flags & WM8766_FLAG_STEREO) ? 2 : 1;\n\tuinfo->value.integer.min = wm->ctl[n].min;\n\tuinfo->value.integer.max = wm->ctl[n].max;\n\n\treturn 0;\n}\n\nstatic int snd_wm8766_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\n\treturn snd_ctl_enum_info(uinfo, 1, wm->ctl[n].max,\n\t\t\t\t\t\twm->ctl[n].enum_names);\n}\n\nstatic int snd_wm8766_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\tu16 val1, val2;\n\n\tif (wm->ctl[n].get)\n\t\twm->ctl[n].get(wm, &val1, &val2);\n\telse {\n\t\tval1 = wm->regs[wm->ctl[n].reg1] & wm->ctl[n].mask1;\n\t\tval1 >>= __ffs(wm->ctl[n].mask1);\n\t\tif (wm->ctl[n].flags & WM8766_FLAG_STEREO) {\n\t\t\tval2 = wm->regs[wm->ctl[n].reg2] & wm->ctl[n].mask2;\n\t\t\tval2 >>= __ffs(wm->ctl[n].mask2);\n\t\t\tif (wm->ctl[n].flags & WM8766_FLAG_VOL_UPDATE)\n\t\t\t\tval2 &= ~WM8766_VOL_UPDATE;\n\t\t}\n\t}\n\tif (wm->ctl[n].flags & WM8766_FLAG_INVERT) {\n\t\tval1 = wm->ctl[n].max - (val1 - wm->ctl[n].min);\n\t\tif (wm->ctl[n].flags & WM8766_FLAG_STEREO)\n\t\t\tval2 = wm->ctl[n].max - (val2 - wm->ctl[n].min);\n\t}\n\tucontrol->value.integer.value[0] = val1;\n\tif (wm->ctl[n].flags & WM8766_FLAG_STEREO)\n\t\tucontrol->value.integer.value[1] = val2;\n\n\treturn 0;\n}\n\nstatic int snd_wm8766_ctl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_wm8766 *wm = snd_kcontrol_chip(kcontrol);\n\tint n = kcontrol->private_value;\n\tu16 val, regval1, regval2;\n\n\t \n\tregval1 = ucontrol->value.integer.value[0];\n\tregval2 = ucontrol->value.integer.value[1];\n\tif (wm->ctl[n].flags & WM8766_FLAG_INVERT) {\n\t\tregval1 = wm->ctl[n].max - (regval1 - wm->ctl[n].min);\n\t\tregval2 = wm->ctl[n].max - (regval2 - wm->ctl[n].min);\n\t}\n\tif (wm->ctl[n].set)\n\t\twm->ctl[n].set(wm, regval1, regval2);\n\telse {\n\t\tval = wm->regs[wm->ctl[n].reg1] & ~wm->ctl[n].mask1;\n\t\tval |= regval1 << __ffs(wm->ctl[n].mask1);\n\t\t \n\t\tif (wm->ctl[n].flags & WM8766_FLAG_STEREO &&\n\t\t\t\twm->ctl[n].reg1 == wm->ctl[n].reg2) {\n\t\t\tval &= ~wm->ctl[n].mask2;\n\t\t\tval |= regval2 << __ffs(wm->ctl[n].mask2);\n\t\t}\n\t\tsnd_wm8766_write(wm, wm->ctl[n].reg1, val);\n\t\t \n\t\tif (wm->ctl[n].flags & WM8766_FLAG_STEREO &&\n\t\t\t\twm->ctl[n].reg1 != wm->ctl[n].reg2) {\n\t\t\tval = wm->regs[wm->ctl[n].reg2] & ~wm->ctl[n].mask2;\n\t\t\tval |= regval2 << __ffs(wm->ctl[n].mask2);\n\t\t\tif (wm->ctl[n].flags & WM8766_FLAG_VOL_UPDATE)\n\t\t\t\tval |= WM8766_VOL_UPDATE;\n\t\t\tsnd_wm8766_write(wm, wm->ctl[n].reg2, val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_wm8766_add_control(struct snd_wm8766 *wm, int num)\n{\n\tstruct snd_kcontrol_new cont;\n\tstruct snd_kcontrol *ctl;\n\n\tmemset(&cont, 0, sizeof(cont));\n\tcont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tcont.private_value = num;\n\tcont.name = wm->ctl[num].name;\n\tcont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tif (wm->ctl[num].flags & WM8766_FLAG_LIM ||\n\t    wm->ctl[num].flags & WM8766_FLAG_ALC)\n\t\tcont.access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tcont.tlv.p = NULL;\n\tcont.get = snd_wm8766_ctl_get;\n\tcont.put = snd_wm8766_ctl_put;\n\n\tswitch (wm->ctl[num].type) {\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tcont.info = snd_wm8766_volume_info;\n\t\tcont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tcont.tlv.p = wm->ctl[num].tlv;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\t\twm->ctl[num].max = 1;\n\t\tif (wm->ctl[num].flags & WM8766_FLAG_STEREO)\n\t\t\tcont.info = snd_ctl_boolean_stereo_info;\n\t\telse\n\t\t\tcont.info = snd_ctl_boolean_mono_info;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tcont.info = snd_wm8766_enum_info;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctl = snd_ctl_new1(&cont, wm);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\twm->ctl[num].kctl = ctl;\n\n\treturn snd_ctl_add(wm->card, ctl);\n}\n\nint snd_wm8766_build_controls(struct snd_wm8766 *wm)\n{\n\tint err, i;\n\n\tfor (i = 0; i < WM8766_CTL_COUNT; i++)\n\t\tif (wm->ctl[i].name) {\n\t\t\terr = snd_wm8766_add_control(wm, i);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}