{
  "module_name": "prodigy_hifi.c",
  "hash_id": "36f7e806dadd49234c67392842b4cf1ee749c966cec11b37161965154c3edb29",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/prodigy_hifi.c",
  "human_readable_source": "\n \n\n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"prodigy_hifi.h\"\n\nstruct prodigy_hifi_spec {\n\tunsigned short master[2];\n\tunsigned short vol[8];\n};\n\n \n#define WM_DEV\t\t0x34\n\n \n#define WM_HP_ATTEN_L\t\t0x00\t \n#define WM_HP_ATTEN_R\t\t0x01\t \n#define WM_HP_MASTER\t\t0x02\t \n#define WM_DAC_ATTEN_L\t\t0x03\t \n#define WM_DAC_ATTEN_R\t\t0x04\n#define WM_DAC_MASTER\t\t0x05\n#define WM_PHASE_SWAP\t\t0x06\t \n#define WM_DAC_CTRL1\t\t0x07\n#define WM_DAC_MUTE\t\t0x08\n#define WM_DAC_CTRL2\t\t0x09\n#define WM_DAC_INT\t\t0x0a\n#define WM_ADC_INT\t\t0x0b\n#define WM_MASTER_CTRL\t\t0x0c\n#define WM_POWERDOWN\t\t0x0d\n#define WM_ADC_ATTEN_L\t\t0x0e\n#define WM_ADC_ATTEN_R\t\t0x0f\n#define WM_ALC_CTRL1\t\t0x10\n#define WM_ALC_CTRL2\t\t0x11\n#define WM_ALC_CTRL3\t\t0x12\n#define WM_NOISE_GATE\t\t0x13\n#define WM_LIMITER\t\t0x14\n#define WM_ADC_MUX\t\t0x15\n#define WM_OUT_MUX\t\t0x16\n#define WM_RESET\t\t0x17\n\n \n\n \n\n#define WM_AIN1 \"AIN1\"\n#define WM_AIN2 \"AIN2\"\n#define WM_AIN3 \"AIN3\"\n#define WM_AIN4 \"AIN4\"\n#define WM_AIN5 \"AIN5\"\n\n \n#define WM8766_SPI_CLK\t (1<<17)  \n#define WM8766_SPI_MD\t  (1<<16)  \n#define WM8766_SPI_ML\t  (1<<18)  \n\n \n#define WM8766_DAC_CTRL\t 0x02    \n#define WM8766_INT_CTRL\t 0x03    \n#define WM8766_DAC_CTRL2\t0x09\n#define WM8766_DAC_CTRL3\t0x0a\n#define WM8766_RESET\t    0x1f\n#define WM8766_LDA1\t     0x00\n#define WM8766_LDA2\t     0x04\n#define WM8766_LDA3\t     0x06\n#define WM8766_RDA1\t     0x01\n#define WM8766_RDA2\t     0x05\n#define WM8766_RDA3\t     0x07\n#define WM8766_MUTE1\t    0x0C\n#define WM8766_MUTE2\t    0x0F\n\n\n \n#define AK4396_ADDR    0x00\n#define AK4396_CSN    (1 << 8)     \n#define AK4396_CCLK   (1 << 9)     \n#define AK4396_CDTI   (1 << 10)    \n\n \n#define AK4396_CTRL1\t    0x00\n#define AK4396_CTRL2\t    0x01\n#define AK4396_CTRL3\t    0x02\n#define AK4396_LCH_ATT\t  0x03\n#define AK4396_RCH_ATT\t  0x04\n\n\n \nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\n{\n\treg <<= 1;\n\treturn ((unsigned short)ice->akm[0].images[reg] << 8) |\n\t\tice->akm[0].images[reg + 1];\n}\n\n \nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\tunsigned short cval;\n\tcval = (reg << 9) | val;\n\tsnd_vt1724_write_i2c(ice, WM_DEV, cval >> 8, cval & 0xff);\n}\n\nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\twm_put_nocache(ice, reg, val);\n\treg <<= 1;\n\tice->akm[0].images[reg] = val >> 8;\n\tice->akm[0].images[reg + 1] = val;\n}\n\n \n\nstatic void set_gpio_bit(struct snd_ice1712 *ice, unsigned int bit, int val)\n{\n\tunsigned int tmp = snd_ice1712_gpio_read(ice);\n\tif (val)\n\t\ttmp |= bit;\n\telse\n\t\ttmp &= ~bit;\n\tsnd_ice1712_gpio_write(ice, tmp);\n}\n\n \n\nstatic void wm8766_spi_send_word(struct snd_ice1712 *ice, unsigned int data)\n{\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tset_gpio_bit(ice, WM8766_SPI_CLK, 0);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, WM8766_SPI_MD, data & 0x8000);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, WM8766_SPI_CLK, 1);\n\t\tudelay(1);\n\t\tdata <<= 1;\n\t}\n}\n\nstatic void wm8766_spi_write(struct snd_ice1712 *ice, unsigned int reg,\n\t\t\t     unsigned int data)\n{\n\tunsigned int block;\n\n\tsnd_ice1712_gpio_set_dir(ice, WM8766_SPI_MD|\n\t\t\t\t\tWM8766_SPI_CLK|WM8766_SPI_ML);\n\tsnd_ice1712_gpio_set_mask(ice, ~(WM8766_SPI_MD|\n\t\t\t\t\tWM8766_SPI_CLK|WM8766_SPI_ML));\n\t \n\tset_gpio_bit(ice, WM8766_SPI_ML, 0);\n\tblock = (reg << 9) | (data & 0x1ff);\n\twm8766_spi_send_word(ice, block);  \n\t \n\tset_gpio_bit(ice, WM8766_SPI_ML, 1);\n\tudelay(1);\n\t \n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n}\n\n\n \n\nstatic void ak4396_send_word(struct snd_ice1712 *ice, unsigned int data)\n{\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tset_gpio_bit(ice, AK4396_CCLK, 0);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, AK4396_CDTI, data & 0x8000);\n\t\tudelay(1);\n\t\tset_gpio_bit(ice, AK4396_CCLK, 1);\n\t\tudelay(1);\n\t\tdata <<= 1;\n\t}\n}\n\nstatic void ak4396_write(struct snd_ice1712 *ice, unsigned int reg,\n\t\t\t unsigned int data)\n{\n\tunsigned int block;\n\n\tsnd_ice1712_gpio_set_dir(ice, AK4396_CSN|AK4396_CCLK|AK4396_CDTI);\n\tsnd_ice1712_gpio_set_mask(ice, ~(AK4396_CSN|AK4396_CCLK|AK4396_CDTI));\n\t \n\tset_gpio_bit(ice, AK4396_CSN, 0); \n\tblock =  ((AK4396_ADDR & 0x03) << 14) | (1 << 13) |\n\t\t\t((reg & 0x1f) << 8) | (data & 0xff);\n\tak4396_send_word(ice, block);  \n\t \n\tset_gpio_bit(ice, AK4396_CSN, 1);\n\tudelay(1);\n\t \n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\n}\n\n\n \n\n\n\n \n\nstatic int ak4396_dac_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;    \n\tuinfo->value.integer.max = 0xFF;  \n\treturn 0;\n}\n\nstatic int ak4396_dac_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i;\n\t\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] = spec->vol[i];\n\n\treturn 0;\n}\n\nstatic int ak4396_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i;\n\tint change = 0;\n\t\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (ucontrol->value.integer.value[i] != spec->vol[i]) {\n\t\t\tspec->vol[i] = ucontrol->value.integer.value[i];\n\t\t\tak4396_write(ice, AK4396_LCH_ATT + i,\n\t\t\t\t     spec->vol[i] & 0xff);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_dac, -12700, 100, 1);\nstatic const DECLARE_TLV_DB_LINEAR(ak4396_db_scale, TLV_DB_GAIN_MUTE, 0);\n\nstatic const struct snd_kcontrol_new prodigy_hd2_controls[] = {\n    {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name = \"Front Playback Volume\",\n\t.info = ak4396_dac_vol_info,\n\t.get = ak4396_dac_vol_get,\n\t.put = ak4396_dac_vol_put,\n\t.tlv = { .p = ak4396_db_scale },\n    },\n};\n\n\n \n\n#define WM_VOL_MAX\t255\n#define WM_VOL_MUTE\t0x8000\n\n\n#define DAC_0dB\t0xff\n#define DAC_RES\t128\n#define DAC_MIN\t(DAC_0dB - DAC_RES)\n\n\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index,\n\t\t       unsigned short vol, unsigned short master)\n{\n\tunsigned char nvol;\n\t\n\tif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\n\t\tnvol = 0;\n\telse {\n\t\tnvol = (((vol & ~WM_VOL_MUTE) * (master & ~WM_VOL_MUTE)) / 128)\n\t\t\t\t& WM_VOL_MAX;\n\t\tnvol = (nvol ? (nvol + DAC_MIN) : 0) & 0xff;\n\t}\n\t\n\twm_put(ice, index, nvol);\n\twm_put_nocache(ice, index, 0x100 | nvol);\n}\n\nstatic void wm8766_set_vol(struct snd_ice1712 *ice, unsigned int index,\n\t\t\t   unsigned short vol, unsigned short master)\n{\n\tunsigned char nvol;\n\t\n\tif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\n\t\tnvol = 0;\n\telse {\n\t\tnvol = (((vol & ~WM_VOL_MUTE) * (master & ~WM_VOL_MUTE)) / 128)\n\t\t\t\t& WM_VOL_MAX;\n\t\tnvol = (nvol ? (nvol + DAC_MIN) : 0) & 0xff;\n\t}\n\n\twm8766_spi_write(ice, index, (0x0100 | nvol));\n}\n\n\n \n\nstatic int wm_dac_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t \n\tuinfo->value.integer.max = DAC_RES;\t \n\treturn 0;\n}\n\nstatic int wm_dac_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\tspec->vol[2 + i] & ~WM_VOL_MUTE;\n\treturn 0;\n}\n\nstatic int wm_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i, idx, change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (ucontrol->value.integer.value[i] != spec->vol[2 + i]) {\n\t\t\tidx = WM_DAC_ATTEN_L + i;\n\t\t\tspec->vol[2 + i] &= WM_VOL_MUTE;\n\t\t\tspec->vol[2 + i] |= ucontrol->value.integer.value[i];\n\t\t\twm_set_vol(ice, idx, spec->vol[2 + i], spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n\n \nstatic int wm8766_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint voices = kcontrol->private_value >> 8;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = voices;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = DAC_RES;\t \n\treturn 0;\n}\n\nstatic int wm8766_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i, ofs, voices;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tfor (i = 0; i < voices; i++)\n\t\tucontrol->value.integer.value[i] = spec->vol[ofs + i];\n\treturn 0;\n}\n\nstatic int wm8766_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i, idx, ofs, voices;\n\tint change = 0;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < voices; i++) {\n\t\tif (ucontrol->value.integer.value[i] != spec->vol[ofs + i]) {\n\t\t\tidx = WM8766_LDA1 + ofs + i;\n\t\t\tspec->vol[ofs + i] &= WM_VOL_MUTE;\n\t\t\tspec->vol[ofs + i] |= ucontrol->value.integer.value[i];\n\t\t\twm8766_set_vol(ice, idx,\n\t\t\t\t       spec->vol[ofs + i], spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = DAC_RES;\n\treturn 0;\n}\n\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] = spec->master[i];\n\treturn 0;\n}\n\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint ch, change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tif (ucontrol->value.integer.value[ch] != spec->master[ch]) {\n\t\t\tspec->master[ch] = ucontrol->value.integer.value[ch];\n\n\t\t\t \n\t\t\twm_set_vol(ice, WM_DAC_ATTEN_L + ch,\n\t\t\t\t   spec->vol[2 + ch], spec->master[ch]);\n\n\t\t\twm8766_set_vol(ice, WM8766_LDA1 + ch,\n\t\t\t\t       spec->vol[0 + ch], spec->master[ch]);\n\n\t\t\twm8766_set_vol(ice, WM8766_LDA2 + ch,\n\t\t\t\t       spec->vol[4 + ch], spec->master[ch]);\n\n\t\t\twm8766_set_vol(ice, WM8766_LDA3 + ch,\n\t\t\t\t       spec->vol[6 + ch], spec->master[ch]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\t\n\treturn change;\n}\n\n\n \n\nstatic int wm_adc_mux_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[32] = {\n\t\t\"NULL\", WM_AIN1, WM_AIN2, WM_AIN1 \"+\" WM_AIN2,\n\t\tWM_AIN3, WM_AIN1 \"+\" WM_AIN3, WM_AIN2 \"+\" WM_AIN3,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN3,\n\t\tWM_AIN4, WM_AIN1 \"+\" WM_AIN4, WM_AIN2 \"+\" WM_AIN4,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN4,\n\t\tWM_AIN3 \"+\" WM_AIN4, WM_AIN1 \"+\" WM_AIN3 \"+\" WM_AIN4,\n\t\tWM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN4,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN4,\n\t\tWM_AIN5, WM_AIN1 \"+\" WM_AIN5, WM_AIN2 \"+\" WM_AIN5,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN5,\n\t\tWM_AIN3 \"+\" WM_AIN5, WM_AIN1 \"+\" WM_AIN3 \"+\" WM_AIN5,\n\t\tWM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN5,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN5,\n\t\tWM_AIN4 \"+\" WM_AIN5, WM_AIN1 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN2 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN3 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN1 \"+\" WM_AIN3 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN4 \"+\" WM_AIN5,\n\t\tWM_AIN1 \"+\" WM_AIN2 \"+\" WM_AIN3 \"+\" WM_AIN4 \"+\" WM_AIN5\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 32, texts);\n}\n\nstatic int wm_adc_mux_enum_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.enumerated.item[0] = wm_get(ice, WM_ADC_MUX) & 0x1f;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_mux_enum_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short oval, nval;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\toval = wm_get(ice, WM_ADC_MUX);\n\tnval = (oval & 0xe0) | ucontrol->value.enumerated.item[0];\n\tif (nval != oval) {\n\t\twm_put(ice, WM_ADC_MUX, nval);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n\n \n\n#define ADC_0dB\t0xcf\n#define ADC_RES\t128\n#define ADC_MIN\t(ADC_0dB - ADC_RES)\n\nstatic int wm_adc_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t \n\tuinfo->value.integer.max = ADC_RES;\t \n\treturn 0;\n}\n\nstatic int wm_adc_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\tint i;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tval = wm_get(ice, WM_ADC_ATTEN_L + i) & 0xff;\n\t\tval = val > ADC_MIN ? (val - ADC_MIN) : 0;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint i, idx, change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tnvol = ucontrol->value.integer.value[i];\n\t\tnvol = nvol ? (nvol + ADC_MIN) : 0;\n\t\tidx  = WM_ADC_ATTEN_L + i;\n\t\tovol = wm_get(ice, idx) & 0xff;\n\t\tif (ovol != nvol) {\n\t\t\twm_put(ice, idx, nvol);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n#define wm_adc_mux_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_adc_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint bit = kcontrol->private_value;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] =\n\t\t(wm_get(ice, WM_ADC_MUX) & (1 << bit)) ? 1 : 0;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint bit = kcontrol->private_value;\n\tunsigned short oval, nval;\n\tint change;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tnval = oval = wm_get(ice, WM_ADC_MUX);\n\tif (ucontrol->value.integer.value[0])\n\t\tnval |= (1 << bit);\n\telse\n\t\tnval &= ~(1 << bit);\n\tchange = nval != oval;\n\tif (change) {\n\t\twm_put(ice, WM_ADC_MUX, nval);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\n \n#define wm_bypass_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_bypass_get(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] =\n\t\t(wm_get(ice, WM_OUT_MUX) & 0x04) ? 1 : 0;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_bypass_put(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val, oval;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tval = oval = wm_get(ice, WM_OUT_MUX);\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= 0x04;\n\telse\n\t\tval &= ~0x04;\n\tif (val != oval) {\n\t\twm_put(ice, WM_OUT_MUX, val);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n \n#define wm_chswap_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int wm_chswap_get(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] =\n\t\t\t(wm_get(ice, WM_DAC_CTRL1) & 0xf0) != 0x90;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_chswap_put(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val, oval;\n\tint change = 0;\n\n\tmutex_lock(&ice->gpio_mutex);\n\toval = wm_get(ice, WM_DAC_CTRL1);\n\tval = oval & 0x0f;\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= 0x60;\n\telse\n\t\tval |= 0x90;\n\tif (val != oval) {\n\t\twm_put(ice, WM_DAC_CTRL1, val);\n\t\twm_put_nocache(ice, WM_DAC_CTRL1, val);\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn change;\n}\n\n\n \n\nstatic const struct snd_kcontrol_new prodigy_hifi_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Master Playback Volume\",\n\t\t.info = wm_master_vol_info,\n\t\t.get = wm_master_vol_get,\n\t\t.put = wm_master_vol_put,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Front Playback Volume\",\n\t\t.info = wm_dac_vol_info,\n\t\t.get = wm_dac_vol_get,\n\t\t.put = wm_dac_vol_put,\n\t\t.tlv = { .p = db_scale_wm_dac },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Rear Playback Volume\",\n\t\t.info = wm8766_vol_info,\n\t\t.get = wm8766_vol_get,\n\t\t.put = wm8766_vol_put,\n\t\t.private_value = (2 << 8) | 0,\n\t\t.tlv = { .p = db_scale_wm_dac },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Center Playback Volume\",\n\t\t.info = wm8766_vol_info,\n\t\t.get = wm8766_vol_get,\n\t\t.put = wm8766_vol_put,\n\t\t.private_value = (1 << 8) | 4,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"LFE Playback Volume\",\n\t\t.info = wm8766_vol_info,\n\t\t.get = wm8766_vol_get,\n\t\t.put = wm8766_vol_put,\n\t\t.private_value = (1 << 8) | 5,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Side Playback Volume\",\n\t\t.info = wm8766_vol_info,\n\t\t.get = wm8766_vol_get,\n\t\t.put = wm8766_vol_put,\n\t\t.private_value = (2 << 8) | 6,\n\t\t.tlv = { .p = db_scale_wm_dac },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Capture Volume\",\n\t\t.info = wm_adc_vol_info,\n\t\t.get = wm_adc_vol_get,\n\t\t.put = wm_adc_vol_put,\n\t\t.tlv = { .p = db_scale_wm_dac },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"CD Capture Switch\",\n\t\t.info = wm_adc_mux_info,\n\t\t.get = wm_adc_mux_get,\n\t\t.put = wm_adc_mux_put,\n\t\t.private_value = 0,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line Capture Switch\",\n\t\t.info = wm_adc_mux_info,\n\t\t.get = wm_adc_mux_get,\n\t\t.put = wm_adc_mux_put,\n\t\t.private_value = 1,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Bypass Switch\",\n\t\t.info = wm_bypass_info,\n\t\t.get = wm_bypass_get,\n\t\t.put = wm_bypass_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Swap Output Channels\",\n\t\t.info = wm_chswap_info,\n\t\t.get = wm_chswap_get,\n\t\t.put = wm_chswap_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Capture Source\",\n\t\t.info = wm_adc_mux_enum_info,\n\t\t.get = wm_adc_mux_enum_get,\n\t\t.put = wm_adc_mux_enum_put,\n\t},\n};\n\n \nstatic void wm_proc_regs_write(struct snd_info_entry *entry,\n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tchar line[64];\n\tunsigned int reg, val;\n\tmutex_lock(&ice->gpio_mutex);\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%x %x\", &reg, &val) != 2)\n\t\t\tcontinue;\n\t\tif (reg <= 0x17 && val <= 0xffff)\n\t\t\twm_put(ice, reg, val);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic void wm_proc_regs_read(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tint reg, val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (reg = 0; reg <= 0x17; reg++) {\n\t\tval = wm_get(ice, reg);\n\t\tsnd_iprintf(buffer, \"%02x = %04x\\n\", reg, val);\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n}\n\nstatic void wm_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_rw_proc_new(ice->card, \"wm_codec\", ice, wm_proc_regs_read,\n\t\t\t     wm_proc_regs_write);\n}\n\nstatic int prodigy_hifi_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(prodigy_hifi_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t  snd_ctl_new1(&prodigy_hifi_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\twm_proc_init(ice);\n\n\treturn 0;\n}\n\nstatic int prodigy_hd2_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(prodigy_hd2_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t  snd_ctl_new1(&prodigy_hd2_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\twm_proc_init(ice);\n\n\treturn 0;\n}\n\nstatic void wm8766_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm8766_inits[] = {\n\t\tWM8766_RESET,\t   0x0000,\n\t\tWM8766_DAC_CTRL,\t0x0120,\n\t\tWM8766_INT_CTRL,\t0x0022,  \n\t\tWM8766_DAC_CTRL2,       0x0001,\n\t\tWM8766_DAC_CTRL3,       0x0080,\n\t\tWM8766_LDA1,\t    0x0100,\n\t\tWM8766_LDA2,\t    0x0100,\n\t\tWM8766_LDA3,\t    0x0100,\n\t\tWM8766_RDA1,\t    0x0100,\n\t\tWM8766_RDA2,\t    0x0100,\n\t\tWM8766_RDA3,\t    0x0100,\n\t\tWM8766_MUTE1,\t   0x0000,\n\t\tWM8766_MUTE2,\t   0x0000,\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8766_inits); i += 2)\n\t\twm8766_spi_write(ice, wm8766_inits[i], wm8766_inits[i + 1]);\n}\n\nstatic void wm8776_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm8776_inits[] = {\n\t\t \n\t\tWM_ADC_MUX,\t0x0003,\t \n\t\t \n\t\t\n\t\tWM_DAC_MUTE,\t0x0001,\t \n\t\tWM_DAC_CTRL1,\t0x0000,\t \n\n\t\tWM_POWERDOWN,\t0x0008,\t \n\t\tWM_RESET,\t0x0000,\t \n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8776_inits); i += 2)\n\t\twm_put(ice, wm8776_inits[i], wm8776_inits[i + 1]);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int prodigy_hifi_resume(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm8776_reinit_registers[] = {\n\t\tWM_MASTER_CTRL,\n\t\tWM_DAC_INT,\n\t\tWM_ADC_INT,\n\t\tWM_OUT_MUX,\n\t\tWM_HP_ATTEN_L,\n\t\tWM_HP_ATTEN_R,\n\t\tWM_PHASE_SWAP,\n\t\tWM_DAC_CTRL2,\n\t\tWM_ADC_ATTEN_L,\n\t\tWM_ADC_ATTEN_R,\n\t\tWM_ALC_CTRL1,\n\t\tWM_ALC_CTRL2,\n\t\tWM_ALC_CTRL3,\n\t\tWM_NOISE_GATE,\n\t\tWM_ADC_MUX,\n\t\t \n\t};\n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i, ch;\n\n\tmutex_lock(&ice->gpio_mutex);\n\n\t \n\twm8776_init(ice);\n\tschedule_timeout_uninterruptible(1);\n\tfor (i = 0; i < ARRAY_SIZE(wm8776_reinit_registers); i++)\n\t\twm_put(ice, wm8776_reinit_registers[i],\n\t\t       wm_get(ice, wm8776_reinit_registers[i]));\n\n\t \n\twm8766_init(ice);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\twm_set_vol(ice, WM_DAC_ATTEN_L + ch,\n\t\t\t   spec->vol[2 + ch], spec->master[ch]);\n\n\t\twm8766_set_vol(ice, WM8766_LDA1 + ch,\n\t\t\t       spec->vol[0 + ch], spec->master[ch]);\n\n\t\twm8766_set_vol(ice, WM8766_LDA2 + ch,\n\t\t\t       spec->vol[4 + ch], spec->master[ch]);\n\n\t\twm8766_set_vol(ice, WM8766_LDA3 + ch,\n\t\t\t       spec->vol[6 + ch], spec->master[ch]);\n\t}\n\n\t \n\twm_put(ice, WM_DAC_MUTE, 0x00);\n\twm_put(ice, WM_DAC_CTRL1, 0x90);\n\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n#endif\n\n \nstatic int prodigy_hifi_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm8776_defaults[] = {\n\t\tWM_MASTER_CTRL,  0x0022,  \n\t\tWM_DAC_INT,\t0x0022,\t \n\t\tWM_ADC_INT,\t0x0022,\t \n\t\tWM_DAC_CTRL1,\t0x0090,\t \n\t\tWM_OUT_MUX,\t0x0001,\t \n\t\tWM_HP_ATTEN_L,\t0x0179,\t \n\t\tWM_HP_ATTEN_R,\t0x0179,\t \n\t\tWM_DAC_ATTEN_L,\t0x0000,\t \n\t\tWM_DAC_ATTEN_L,\t0x0100,\t \n\t\tWM_DAC_ATTEN_R,\t0x0000,\t \n\t\tWM_DAC_ATTEN_R,\t0x0100,\t \n\t\tWM_PHASE_SWAP,\t0x0000,\t \n#if 0\n\t\tWM_DAC_MASTER,\t0x0100,\t \n#endif\n\t\tWM_DAC_CTRL2,\t0x0000,\t \n\t\tWM_ADC_ATTEN_L,\t0x0000,\t \n\t\tWM_ADC_ATTEN_R,\t0x0000,\t \n#if 1\n\t\tWM_ALC_CTRL1,\t0x007b,\t \n\t\tWM_ALC_CTRL2,\t0x0000,\t \n\t\tWM_ALC_CTRL3,\t0x0000,\t \n\t\tWM_NOISE_GATE,\t0x0000,\t \n#endif\n\t\tWM_DAC_MUTE,\t0x0000,\t \n\t\tWM_ADC_MUX,\t0x0003,\t \n\t};\n\tstruct prodigy_hifi_spec *spec;\n\tunsigned int i;\n\n\tice->vt1720 = 0;\n\tice->vt1724 = 1;\n\n\tice->num_total_dacs = 8;\n\tice->num_total_adcs = 1;\n\n\t \n\tice->gpio.saved[0] = 0;\n\t \n\n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tif (! ice->akm)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\t \n\twm8776_init(ice);\n\tschedule_timeout_uninterruptible(1);\n\tfor (i = 0; i < ARRAY_SIZE(wm8776_defaults); i += 2)\n\t\twm_put(ice, wm8776_defaults[i], wm8776_defaults[i + 1]);\n\n\twm8766_init(ice);\n\n#ifdef CONFIG_PM_SLEEP\n\tice->pm_resume = &prodigy_hifi_resume;\n\tice->pm_suspend_enabled = 1;\n#endif\n\n\treturn 0;\n}\n\n\n \nstatic void ak4396_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short ak4396_inits[] = {\n\t\tAK4396_CTRL1,\t   0x87,    \n\t\tAK4396_CTRL2,\t   0x02,\n\t\tAK4396_CTRL3,\t   0x00, \n\t\tAK4396_LCH_ATT,\t 0x00,\n\t\tAK4396_RCH_ATT,\t 0x00,\n\t};\n\n\tunsigned int i;\n\n\t \n\t \n\tak4396_write(ice, AK4396_CTRL1, 0x86);\n\tmsleep(100);\n\tak4396_write(ice, AK4396_CTRL1, 0x87);\n\n\tfor (i = 0; i < ARRAY_SIZE(ak4396_inits); i += 2)\n\t\tak4396_write(ice, ak4396_inits[i], ak4396_inits[i+1]);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int prodigy_hd2_resume(struct snd_ice1712 *ice)\n{\n\t \n\tstruct prodigy_hifi_spec *spec = ice->spec;\n\tint i;\n\tmutex_lock(&ice->gpio_mutex);\n\tak4396_init(ice);\n\tfor (i = 0; i < 2; i++)\n\t\tak4396_write(ice, AK4396_LCH_ATT + i, spec->vol[i] & 0xff);\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n#endif\n\nstatic int prodigy_hd2_init(struct snd_ice1712 *ice)\n{\n\tstruct prodigy_hifi_spec *spec;\n\n\tice->vt1720 = 0;\n\tice->vt1724 = 1;\n\n\tice->num_total_dacs = 1;\n\tice->num_total_adcs = 1;\n\n\t \n\tice->gpio.saved[0] = 0;\n\t \n\n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tif (! ice->akm)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n#ifdef CONFIG_PM_SLEEP\n\tice->pm_resume = &prodigy_hd2_resume;\n\tice->pm_suspend_enabled = 1;\n#endif\n\n\tak4396_init(ice);\n\n\treturn 0;\n}\n\n\nstatic const unsigned char prodigy71hifi_eeprom[] = {\n\t0x4b,    \n\t0x80,    \n\t0xfc,    \n\t0xc3,    \n\t0xff,    \n\t0xff,    \n\t0x5f,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n};\n\nstatic const unsigned char prodigyhd2_eeprom[] = {\n\t0x4b,    \n\t0x80,    \n\t0xfc,    \n\t0xc3,    \n\t0xff,    \n\t0xff,    \n\t0x5f,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n};\n\nstatic const unsigned char fortissimo4_eeprom[] = {\n\t0x43,    \t\n\t0x80,    \n\t0xfc,    \n\t0xc1,    \n\t0xff,    \n\t0xff,    \n\t0x5f,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n\t0x00,    \n};\n\n \nstruct snd_ice1712_card_info snd_vt1724_prodigy_hifi_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PRODIGY_HIFI,\n\t\t.name = \"Audiotrak Prodigy 7.1 HiFi\",\n\t\t.model = \"prodigy71hifi\",\n\t\t.chip_init = prodigy_hifi_init,\n\t\t.build_controls = prodigy_hifi_add_controls,\n\t\t.eeprom_size = sizeof(prodigy71hifi_eeprom),\n\t\t.eeprom_data = prodigy71hifi_eeprom,\n\t\t.driver = \"Prodigy71HIFI\",\n\t},\n\t{\n\t.subvendor = VT1724_SUBDEVICE_PRODIGY_HD2,\n\t.name = \"Audiotrak Prodigy HD2\",\n\t.model = \"prodigyhd2\",\n\t.chip_init = prodigy_hd2_init,\n\t.build_controls = prodigy_hd2_add_controls,\n\t.eeprom_size = sizeof(prodigyhd2_eeprom),\n\t.eeprom_data = prodigyhd2_eeprom,\n\t.driver = \"Prodigy71HD2\",\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_FORTISSIMO4,\n\t\t.name = \"Hercules Fortissimo IV\",\n\t\t.model = \"fortissimo4\",\n\t\t.chip_init = prodigy_hifi_init,\n\t\t.build_controls = prodigy_hifi_add_controls,\n\t\t.eeprom_size = sizeof(fortissimo4_eeprom),\n\t\t.eeprom_data = fortissimo4_eeprom,\n\t\t.driver = \"Fortissimo4\",\n\t},\n\t{ }  \n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}