{
  "module_name": "se.c",
  "hash_id": "2eda887bea55dc953d5212a49717c22b3df03fb3f0b74d441151a005c03897db",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/se.c",
  "human_readable_source": "\n       \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"se.h\"\n\nstruct se_spec {\n\tstruct {\n\t\tunsigned char ch1, ch2;\n\t} vol[8];\n};\n\n \n \n \n \n\n\n \n \n \n\nstatic void se200pci_WM8740_init(struct snd_ice1712 *ice)\n{\n\t \n}\n\n\nstatic void se200pci_WM8740_set_pro_rate(struct snd_ice1712 *ice,\n\t\t\t\t\t\tunsigned int rate)\n{\n\t \n}\n\n\n \n \n \n\nstatic void se200pci_WM8766_write(struct snd_ice1712 *ice,\n\t\t\t\t\tunsigned int addr, unsigned int data)\n{\n\tunsigned int st;\n\tunsigned int bits;\n\tint i;\n\tconst unsigned int DATA  = 0x010000;\n\tconst unsigned int CLOCK = 0x020000;\n\tconst unsigned int LOAD  = 0x040000;\n\tconst unsigned int ALL_MASK = (DATA | CLOCK | LOAD);\n\n\tsnd_ice1712_save_gpio_status(ice);\n\n\tst = ((addr & 0x7f) << 9) | (data & 0x1ff);\n\tsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction | ALL_MASK);\n\tsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask & ~ALL_MASK);\n\tbits = snd_ice1712_gpio_read(ice) & ~ALL_MASK;\n\n\tsnd_ice1712_gpio_write(ice, bits);\n\tfor (i = 0; i < 16; i++) {\n\t\tudelay(1);\n\t\tbits &= ~CLOCK;\n\t\tst = (st << 1);\n\t\tif (st & 0x10000)\n\t\t\tbits |= DATA;\n\t\telse\n\t\t\tbits &= ~DATA;\n\n\t\tsnd_ice1712_gpio_write(ice, bits);\n\n\t\tudelay(1);\n\t\tbits |= CLOCK;\n\t\tsnd_ice1712_gpio_write(ice, bits);\n\t}\n\n\tudelay(1);\n\tbits |= LOAD;\n\tsnd_ice1712_gpio_write(ice, bits);\n\n\tudelay(1);\n\tbits |= (DATA | CLOCK);\n\tsnd_ice1712_gpio_write(ice, bits);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n}\n\nstatic void se200pci_WM8766_set_volume(struct snd_ice1712 *ice, int ch,\n\t\t\t\t\tunsigned int vol1, unsigned int vol2)\n{\n\tswitch (ch) {\n\tcase 0:\n\t\tse200pci_WM8766_write(ice, 0x000, vol1);\n\t\tse200pci_WM8766_write(ice, 0x001, vol2 | 0x100);\n\t\tbreak;\n\tcase 1:\n\t\tse200pci_WM8766_write(ice, 0x004, vol1);\n\t\tse200pci_WM8766_write(ice, 0x005, vol2 | 0x100);\n\t\tbreak;\n\tcase 2:\n\t\tse200pci_WM8766_write(ice, 0x006, vol1);\n\t\tse200pci_WM8766_write(ice, 0x007, vol2 | 0x100);\n\t\tbreak;\n\t}\n}\n\nstatic void se200pci_WM8766_init(struct snd_ice1712 *ice)\n{\n\tse200pci_WM8766_write(ice, 0x1f, 0x000);  \n\tudelay(10);\n\n\tse200pci_WM8766_set_volume(ice, 0, 0, 0);  \n\tse200pci_WM8766_set_volume(ice, 1, 0, 0);  \n\tse200pci_WM8766_set_volume(ice, 2, 0, 0);  \n\n\tse200pci_WM8766_write(ice, 0x03, 0x022);  \n\tse200pci_WM8766_write(ice, 0x0a, 0x080);  \n\tse200pci_WM8766_write(ice, 0x12, 0x000);  \n\tse200pci_WM8766_write(ice, 0x15, 0x000);  \n\tse200pci_WM8766_write(ice, 0x09, 0x000);  \n\n\tse200pci_WM8766_write(ice, 0x02, 0x124);  \n\tse200pci_WM8766_write(ice, 0x02, 0x120);  \n}\n\nstatic void se200pci_WM8766_set_pro_rate(struct snd_ice1712 *ice,\n\t\t\t\t\tunsigned int rate)\n{\n\tif (rate > 96000)\n\t\tse200pci_WM8766_write(ice, 0x0a, 0x000);  \n\telse\n\t\tse200pci_WM8766_write(ice, 0x0a, 0x080);  \n}\n\n\n \n \n \n\nstatic void se200pci_WM8776_write(struct snd_ice1712 *ice,\n\t\t\t\t\tunsigned int addr, unsigned int data)\n{\n\tunsigned int val;\n\n\tval = (addr << 9) | data;\n\tsnd_vt1724_write_i2c(ice, 0x34, val >> 8, val & 0xff);\n}\n\n\nstatic void se200pci_WM8776_set_output_volume(struct snd_ice1712 *ice,\n\t\t\t\t\tunsigned int vol1, unsigned int vol2)\n{\n\tse200pci_WM8776_write(ice, 0x03, vol1);\n\tse200pci_WM8776_write(ice, 0x04, vol2 | 0x100);\n}\n\nstatic void se200pci_WM8776_set_input_volume(struct snd_ice1712 *ice,\n\t\t\t\t\tunsigned int vol1, unsigned int vol2)\n{\n\tse200pci_WM8776_write(ice, 0x0e, vol1);\n\tse200pci_WM8776_write(ice, 0x0f, vol2 | 0x100);\n}\n\nstatic const char * const se200pci_sel[] = {\n\t\"LINE-IN\", \"CD-IN\", \"MIC-IN\", \"ALL-MIX\", NULL\n};\n\nstatic void se200pci_WM8776_set_input_selector(struct snd_ice1712 *ice,\n\t\t\t\t\t       unsigned int sel)\n{\n\tstatic const unsigned char vals[] = {\n\t\t \n\t\t0x10, 0x04, 0x08, 0x1c, 0x03\n\t};\n\tif (sel > 4)\n\t\tsel = 4;\n\tse200pci_WM8776_write(ice, 0x15, vals[sel]);\n}\n\nstatic void se200pci_WM8776_set_afl(struct snd_ice1712 *ice, unsigned int afl)\n{\n\t \n\tif (afl)\n\t\tse200pci_WM8776_write(ice, 0x16, 0x005);\n\telse\n\t\tse200pci_WM8776_write(ice, 0x16, 0x001);\n}\n\nstatic const char * const se200pci_agc[] = {\n\t\"Off\", \"LimiterMode\", \"ALCMode\", NULL\n};\n\nstatic void se200pci_WM8776_set_agc(struct snd_ice1712 *ice, unsigned int agc)\n{\n\t \n\tswitch (agc) {\n\tcase 0:\n\t\tse200pci_WM8776_write(ice, 0x11, 0x000);  \n\t\tbreak;\n\tcase 1:\n\t\tse200pci_WM8776_write(ice, 0x10, 0x07b);\n\t\tse200pci_WM8776_write(ice, 0x11, 0x100);  \n\t\tbreak;\n\tcase 2:\n\t\tse200pci_WM8776_write(ice, 0x10, 0x1fb);\n\t\tse200pci_WM8776_write(ice, 0x11, 0x100);  \n\t\tbreak;\n\t}\n}\n\nstatic void se200pci_WM8776_init(struct snd_ice1712 *ice)\n{\n\tint i;\n\tstatic const unsigned short default_values[] = {\n\t\t0x100, 0x100, 0x100,\n\t\t0x100, 0x100, 0x100,\n\t\t0x000, 0x090, 0x000, 0x000,\n\t\t0x022, 0x022, 0x022,\n\t\t0x008, 0x0cf, 0x0cf, 0x07b, 0x000,\n\t\t0x032, 0x000, 0x0a6, 0x001, 0x001\n\t};\n\n\tse200pci_WM8776_write(ice, 0x17, 0x000);  \n\t \n \t \n\tudelay(10);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(default_values); i++)\n\t\tse200pci_WM8776_write(ice, i, default_values[i]);\n\n\tse200pci_WM8776_set_input_selector(ice, 0);\n\tse200pci_WM8776_set_afl(ice, 0);\n\tse200pci_WM8776_set_agc(ice, 0);\n\tse200pci_WM8776_set_input_volume(ice, 0, 0);\n\tse200pci_WM8776_set_output_volume(ice, 0, 0);\n\n\t \n\tse200pci_WM8776_write(ice, 0x00, 0);\n\tse200pci_WM8776_write(ice, 0x01, 0);\n\tse200pci_WM8776_write(ice, 0x02, 0x100);\n\tse200pci_WM8776_write(ice, 0x0d, 0x080);\n}\n\nstatic void se200pci_WM8776_set_pro_rate(struct snd_ice1712 *ice,\n\t\t\t\t\t\tunsigned int rate)\n{\n\t \n}\n\n\n \n \n \n\nstatic void se200pci_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tse200pci_WM8740_set_pro_rate(ice, rate);\n\tse200pci_WM8766_set_pro_rate(ice, rate);\n\tse200pci_WM8776_set_pro_rate(ice, rate);\n}\n\nstruct se200pci_control {\n\tconst char *name;\n\tenum {\n\t\tWM8766,\n\t\tWM8776in,\n\t\tWM8776out,\n\t\tWM8776sel,\n\t\tWM8776agc,\n\t\tWM8776afl\n\t} target;\n\tenum { VOLUME1, VOLUME2, BOOLEAN, ENUM } type;\n\tint ch;\n\tconst char * const *member;\n\tconst char *comment;\n};\n\nstatic const struct se200pci_control se200pci_cont[] = {\n\t{\n\t\t.name = \"Front Playback Volume\",\n\t\t.target = WM8776out,\n\t\t.type = VOLUME1,\n\t\t.comment = \"Front(green)\"\n\t},\n\t{\n\t\t.name = \"Side Playback Volume\",\n\t\t.target = WM8766,\n\t\t.type = VOLUME1,\n\t\t.ch = 1,\n\t\t.comment = \"Surround(orange)\"\n\t},\n\t{\n\t\t.name = \"Surround Playback Volume\",\n\t\t.target = WM8766,\n\t\t.type = VOLUME1,\n\t\t.ch = 2,\n\t\t.comment = \"SurroundBack(white)\"\n\t},\n\t{\n\t\t.name = \"CLFE Playback Volume\",\n\t\t.target = WM8766,\n\t\t.type = VOLUME1,\n\t\t.ch = 0,\n\t\t.comment = \"Center(Lch)&SubWoofer(Rch)(black)\"\n\t},\n\t{\n\t\t.name = \"Capture Volume\",\n\t\t.target = WM8776in,\n\t\t.type = VOLUME2\n\t},\n\t{\n\t\t.name = \"Capture Select\",\n\t\t.target = WM8776sel,\n\t\t.type = ENUM,\n\t\t.member = se200pci_sel\n\t},\n\t{\n\t\t.name = \"AGC Capture Mode\",\n\t\t.target = WM8776agc,\n\t\t.type = ENUM,\n\t\t.member = se200pci_agc\n\t},\n\t{\n\t\t.name = \"AFL Bypass Playback Switch\",\n\t\t.target = WM8776afl,\n\t\t.type = BOOLEAN\n\t}\n};\n\nstatic int se200pci_get_enum_count(int n)\n{\n\tconst char * const *member;\n\tint c;\n\n\tmember = se200pci_cont[n].member;\n\tif (!member)\n\t\treturn 0;\n\tfor (c = 0; member[c]; c++)\n\t\t;\n\treturn c;\n}\n\nstatic int se200pci_cont_volume_info(struct snd_kcontrol *kc,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;  \n\tuinfo->value.integer.max = 0xff;  \n\treturn 0;\n}\n\n#define se200pci_cont_boolean_info\tsnd_ctl_boolean_mono_info\n\nstatic int se200pci_cont_enum_info(struct snd_kcontrol *kc,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint n, c;\n\n\tn = kc->private_value;\n\tc = se200pci_get_enum_count(n);\n\tif (!c)\n\t\treturn -EINVAL;\n\treturn snd_ctl_enum_info(uinfo, 1, c, se200pci_cont[n].member);\n}\n\nstatic int se200pci_cont_volume_get(struct snd_kcontrol *kc,\n\t\t\t\t    struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tuc->value.integer.value[0] = spec->vol[n].ch1;\n\tuc->value.integer.value[1] = spec->vol[n].ch2;\n\treturn 0;\n}\n\nstatic int se200pci_cont_boolean_get(struct snd_kcontrol *kc,\n\t\t\t\t     struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tuc->value.integer.value[0] = spec->vol[n].ch1;\n\treturn 0;\n}\n\nstatic int se200pci_cont_enum_get(struct snd_kcontrol *kc,\n\t\t\t\t  struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tuc->value.enumerated.item[0] = spec->vol[n].ch1;\n\treturn 0;\n}\n\nstatic void se200pci_cont_update(struct snd_ice1712 *ice, int n)\n{\n\tstruct se_spec *spec = ice->spec;\n\tswitch (se200pci_cont[n].target) {\n\tcase WM8766:\n\t\tse200pci_WM8766_set_volume(ice,\n\t\t\t\t\t   se200pci_cont[n].ch,\n\t\t\t\t\t   spec->vol[n].ch1,\n\t\t\t\t\t   spec->vol[n].ch2);\n\t\tbreak;\n\n\tcase WM8776in:\n\t\tse200pci_WM8776_set_input_volume(ice,\n\t\t\t\t\t\t spec->vol[n].ch1,\n\t\t\t\t\t\t spec->vol[n].ch2);\n\t\tbreak;\n\n\tcase WM8776out:\n\t\tse200pci_WM8776_set_output_volume(ice,\n\t\t\t\t\t\t  spec->vol[n].ch1,\n\t\t\t\t\t\t  spec->vol[n].ch2);\n\t\tbreak;\n\n\tcase WM8776sel:\n\t\tse200pci_WM8776_set_input_selector(ice,\n\t\t\t\t\t\t   spec->vol[n].ch1);\n\t\tbreak;\n\n\tcase WM8776agc:\n\t\tse200pci_WM8776_set_agc(ice, spec->vol[n].ch1);\n\t\tbreak;\n\n\tcase WM8776afl:\n\t\tse200pci_WM8776_set_afl(ice, spec->vol[n].ch1);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int se200pci_cont_volume_put(struct snd_kcontrol *kc,\n\t\t\t\t    struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tunsigned int vol1, vol2;\n\tint changed;\n\n\tchanged = 0;\n\tvol1 = uc->value.integer.value[0] & 0xff;\n\tvol2 = uc->value.integer.value[1] & 0xff;\n\tif (spec->vol[n].ch1 != vol1) {\n\t\tspec->vol[n].ch1 = vol1;\n\t\tchanged = 1;\n\t}\n\tif (spec->vol[n].ch2 != vol2) {\n\t\tspec->vol[n].ch2 = vol2;\n\t\tchanged = 1;\n\t}\n\tif (changed)\n\t\tse200pci_cont_update(ice, n);\n\n\treturn changed;\n}\n\nstatic int se200pci_cont_boolean_put(struct snd_kcontrol *kc,\n\t\t\t\t     struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tunsigned int vol1;\n\n\tvol1 = !!uc->value.integer.value[0];\n\tif (spec->vol[n].ch1 != vol1) {\n\t\tspec->vol[n].ch1 = vol1;\n\t\tse200pci_cont_update(ice, n);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int se200pci_cont_enum_put(struct snd_kcontrol *kc,\n\t\t\t\t  struct snd_ctl_elem_value *uc)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\n\tstruct se_spec *spec = ice->spec;\n\tint n = kc->private_value;\n\tunsigned int vol1;\n\n\tvol1 = uc->value.enumerated.item[0];\n\tif (vol1 >= se200pci_get_enum_count(n))\n\t\treturn -EINVAL;\n\tif (spec->vol[n].ch1 != vol1) {\n\t\tspec->vol[n].ch1 = vol1;\n\t\tse200pci_cont_update(ice, n);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_gain1, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_gain2, -10350, 50, 1);\n\nstatic int se200pci_add_controls(struct snd_ice1712 *ice)\n{\n\tint i;\n\tstruct snd_kcontrol_new cont;\n\tint err;\n\n\tmemset(&cont, 0, sizeof(cont));\n\tcont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tfor (i = 0; i < ARRAY_SIZE(se200pci_cont); i++) {\n\t\tcont.private_value = i;\n\t\tcont.name = se200pci_cont[i].name;\n\t\tcont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t\tcont.tlv.p = NULL;\n\t\tswitch (se200pci_cont[i].type) {\n\t\tcase VOLUME1:\n\t\tcase VOLUME2:\n\t\t\tcont.info = se200pci_cont_volume_info;\n\t\t\tcont.get = se200pci_cont_volume_get;\n\t\t\tcont.put = se200pci_cont_volume_put;\n\t\t\tcont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\t\tif (se200pci_cont[i].type == VOLUME1)\n\t\t\t\tcont.tlv.p = db_scale_gain1;\n\t\t\telse\n\t\t\t\tcont.tlv.p = db_scale_gain2;\n\t\t\tbreak;\n\t\tcase BOOLEAN:\n\t\t\tcont.info = se200pci_cont_boolean_info;\n\t\t\tcont.get = se200pci_cont_boolean_get;\n\t\t\tcont.put = se200pci_cont_boolean_put;\n\t\t\tbreak;\n\t\tcase ENUM:\n\t\t\tcont.info = se200pci_cont_enum_info;\n\t\t\tcont.get = se200pci_cont_enum_get;\n\t\t\tcont.put = se200pci_cont_enum_put;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_BUG();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&cont, ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n \n \n \n \n\n  \n\n\n \n \n \n\nstatic int se_init(struct snd_ice1712 *ice)\n{\n\tstruct se_spec *spec;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE90PCI) {\n\t\tice->num_total_dacs = 2;\n\t\tice->num_total_adcs = 0;\n\t\tice->vt1720 = 1;\n\t\treturn 0;\n\n\t} else if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI) {\n\t\tice->num_total_dacs = 8;\n\t\tice->num_total_adcs = 2;\n\t\tse200pci_WM8740_init(ice);\n\t\tse200pci_WM8766_init(ice);\n\t\tse200pci_WM8776_init(ice);\n\t\tice->gpio.set_pro_rate = se200pci_set_pro_rate;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int se_add_controls(struct snd_ice1712 *ice)\n{\n\tint err;\n\n\terr = 0;\n\t \n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI)\n\t\terr = se200pci_add_controls(ice);\n\n\treturn err;\n}\n\n\n \n \n \n\nstatic const unsigned char se200pci_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]\t= 0x4b,\t \n\t[ICE_EEP2_ACLINK]\t= 0x80,\t \n\t[ICE_EEP2_I2S]\t\t= 0x78,\t \n\t[ICE_EEP2_SPDIF]\t= 0xc3,\t \n\n\t[ICE_EEP2_GPIO_DIR]\t= 0x02,  \n\t[ICE_EEP2_GPIO_DIR1]\t= 0x00,  \n\t[ICE_EEP2_GPIO_DIR2]\t= 0x07,  \n\n\t[ICE_EEP2_GPIO_MASK]\t= 0x00,  \n\t[ICE_EEP2_GPIO_MASK1]\t= 0x00,  \n\t[ICE_EEP2_GPIO_MASK2]\t= 0x00,  \n\n\t[ICE_EEP2_GPIO_STATE]\t= 0x00,  \n\t[ICE_EEP2_GPIO_STATE1]\t= 0x00,  \n\t[ICE_EEP2_GPIO_STATE2]\t= 0x07,  \n};\n\nstatic const unsigned char se90pci_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]\t= 0x4b,\t \n\t[ICE_EEP2_ACLINK]\t= 0x80,\t \n\t[ICE_EEP2_I2S]\t\t= 0x78,\t \n\t[ICE_EEP2_SPDIF]\t= 0xc3,\t \n\n\t \n};\n\nstruct snd_ice1712_card_info snd_vt1724_se_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_SE200PCI,\n\t\t.name = \"ONKYO SE200PCI\",\n\t\t.model = \"se200pci\",\n\t\t.chip_init = se_init,\n\t\t.build_controls = se_add_controls,\n\t\t.eeprom_size = sizeof(se200pci_eeprom),\n\t\t.eeprom_data = se200pci_eeprom,\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_SE90PCI,\n\t\t.name = \"ONKYO SE90PCI\",\n\t\t.model = \"se90pci\",\n\t\t.chip_init = se_init,\n\t\t.build_controls = se_add_controls,\n\t\t.eeprom_size = sizeof(se90pci_eeprom),\n\t\t.eeprom_data = se90pci_eeprom,\n\t},\n\t{}  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}