{
  "module_name": "prodigy192.c",
  "hash_id": "69745b00005d1788110261f254b83104710a8dab5697db986f12841b34c525ab",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/prodigy192.c",
  "human_readable_source": "\n       \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"prodigy192.h\"\n#include \"stac946x.h\"\n#include <sound/tlv.h>\n\nstruct prodigy192_spec {\n\tstruct ak4114 *ak4114;\n\t \n\tstruct mutex mute_mutex;\n};\n\nstatic inline void stac9460_put(struct snd_ice1712 *ice, int reg, unsigned char val)\n{\n\tsnd_vt1724_write_i2c(ice, PRODIGY192_STAC9460_ADDR, reg, val);\n}\n\nstatic inline unsigned char stac9460_get(struct snd_ice1712 *ice, int reg)\n{\n\treturn snd_vt1724_read_i2c(ice, PRODIGY192_STAC9460_ADDR, reg);\n}\n\n \n\n \nstatic int stac9460_dac_mute(struct snd_ice1712 *ice, int idx,\n\t\tunsigned char mute)\n{\n\tunsigned char new, old;\n\tint change;\n\told = stac9460_get(ice, idx);\n\tnew = (~mute << 7 & 0x80) | (old & ~0x80);\n\tchange = (new != old);\n\tif (change)\n\t\t \n\t\tstac9460_put(ice, idx, new);\n\treturn change;\n}\n\n#define stac9460_dac_mute_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int stac9460_dac_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\tint idx;\n\n\tif (kcontrol->private_value)\n\t\tidx = STAC946X_MASTER_VOLUME;\n\telse\n\t\tidx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;\n\tval = stac9460_get(ice, idx);\n\tucontrol->value.integer.value[0] = (~val >> 7) & 0x1;\n\treturn 0;\n}\n\nstatic int stac9460_dac_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct prodigy192_spec *spec = ice->spec;\n\tint idx, change;\n\n\tif (kcontrol->private_value)\n\t\tidx = STAC946X_MASTER_VOLUME;\n\telse\n\t\tidx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;\n\t \n\tmutex_lock(&spec->mute_mutex);\n\t \n\tchange = stac9460_dac_mute(ice, idx, ucontrol->value.integer.value[0]);\n\tmutex_unlock(&spec->mute_mutex);\n\treturn change;\n}\n\n \nstatic int stac9460_dac_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\t\t\t \n\tuinfo->value.integer.max = 0x7f;\t\t \n\treturn 0;\n}\n\nstatic int stac9460_dac_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx;\n\tunsigned char vol;\n\n\tif (kcontrol->private_value)\n\t\tidx = STAC946X_MASTER_VOLUME;\n\telse\n\t\tidx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;\n\tvol = stac9460_get(ice, idx) & 0x7f;\n\tucontrol->value.integer.value[0] = 0x7f - vol;\n\n\treturn 0;\n}\n\nstatic int stac9460_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint idx;\n\tunsigned char tmp, ovol, nvol;\n\tint change;\n\n\tif (kcontrol->private_value)\n\t\tidx = STAC946X_MASTER_VOLUME;\n\telse\n\t\tidx  = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + STAC946X_LF_VOLUME;\n\tnvol = ucontrol->value.integer.value[0];\n\ttmp = stac9460_get(ice, idx);\n\tovol = 0x7f - (tmp & 0x7f);\n\tchange = (ovol != nvol);\n\tif (change) {\n\t\tovol =  (0x7f - nvol) | (tmp & 0x80);\n\t\t \n\t\tstac9460_put(ice, idx, (0x7f - nvol) | (tmp & 0x80));\n\t}\n\treturn change;\n}\n\n \n#define stac9460_adc_mute_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int stac9460_adc_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\tint i;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tval = stac9460_get(ice, STAC946X_MIC_L_VOLUME + i);\n\t\tucontrol->value.integer.value[i] = ~val>>7 & 0x1;\n\t}\n\n\treturn 0;\n}\n\nstatic int stac9460_adc_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char new, old;\n\tint i, reg;\n\tint change;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\treg = STAC946X_MIC_L_VOLUME + i;\n\t\told = stac9460_get(ice, reg);\n\t\tnew = (~ucontrol->value.integer.value[i]<<7&0x80) | (old&~0x80);\n\t\tchange = (new != old);\n\t\tif (change)\n\t\t\tstac9460_put(ice, reg, new);\n\t}\n\n\treturn change;\n}\n\n \nstatic int stac9460_adc_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = 0x0f;\t \n\treturn 0;\n}\n\nstatic int stac9460_adc_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint i, reg;\n\tunsigned char vol;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\treg = STAC946X_MIC_L_VOLUME + i;\n\t\tvol = stac9460_get(ice, reg) & 0x0f;\n\t\tucontrol->value.integer.value[i] = 0x0f - vol;\n\t}\n\n\treturn 0;\n}\n\nstatic int stac9460_adc_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint i, reg;\n\tunsigned char ovol, nvol;\n\tint change;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\treg = STAC946X_MIC_L_VOLUME + i;\n\t\tnvol = ucontrol->value.integer.value[i] & 0x0f;\n\t\tovol = 0x0f - stac9460_get(ice, reg);\n\t\tchange = ((ovol & 0x0f)  != nvol);\n\t\tif (change)\n\t\t\tstac9460_put(ice, reg, (0x0f - nvol) | (ovol & ~0x0f));\n\t}\n\n\treturn change;\n}\n\nstatic int stac9460_mic_sw_info(struct snd_kcontrol *kcontrol,\n\t       \t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"Line In\", \"Mic\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\n\nstatic int stac9460_mic_sw_get(struct snd_kcontrol *kcontrol,\n\t       \t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\t\t\n\tval = stac9460_get(ice, STAC946X_GENERAL_PURPOSE);\n\tucontrol->value.enumerated.item[0] = (val >> 7) & 0x1;\n\treturn 0;\n}\n\nstatic int stac9460_mic_sw_put(struct snd_kcontrol *kcontrol,\n\t       \t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char new, old;\n\tint change;\n\told = stac9460_get(ice, STAC946X_GENERAL_PURPOSE);\n\tnew = (ucontrol->value.enumerated.item[0] << 7 & 0x80) | (old & ~0x80);\n\tchange = (new != old);\n\tif (change)\n\t\tstac9460_put(ice, STAC946X_GENERAL_PURPOSE, new);\n\treturn change;\n}\n \nstatic void stac9460_set_rate_val(struct snd_ice1712 *ice, unsigned int rate)\n{\n\tunsigned char old, new;\n\tint idx;\n\tunsigned char changed[7];\n\tstruct prodigy192_spec *spec = ice->spec;\n\n\tif (rate == 0)   \n\t\treturn;\n\telse if (rate <= 48000)\n\t\tnew = 0x08;\t \n\telse if (rate <= 96000)\n\t\tnew = 0x11;\t \n\telse\n\t\tnew = 0x12;\t \n\told = stac9460_get(ice, STAC946X_MASTER_CLOCKING);\n\tif (old == new)\n\t\treturn;\n\t \n\t \n\tmutex_lock(&spec->mute_mutex);\n\t \n\tfor (idx = 0; idx < 7 ; ++idx)\n\t\tchanged[idx] = stac9460_dac_mute(ice,\n\t\t\t\tSTAC946X_MASTER_VOLUME + idx, 0);\n\t \n\tstac9460_put(ice, STAC946X_MASTER_CLOCKING, new);\n\tudelay(10);\n\t \n\tfor (idx = 0; idx < 7 ; ++idx) {\n\t\tif (changed[idx])\n\t\t\tstac9460_dac_mute(ice, STAC946X_MASTER_VOLUME + idx, 1);\n\t}\n\tmutex_unlock(&spec->mute_mutex);\n}\n\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_dac, -19125, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_adc, 0, 150, 0);\n\n \n\nstatic const struct snd_kcontrol_new stac_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = stac9460_dac_mute_info,\n\t\t.get = stac9460_dac_mute_get,\n\t\t.put = stac9460_dac_mute_put,\n\t\t.private_value = 1,\n\t\t.tlv = { .p = db_scale_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Master Playback Volume\",\n\t\t.info = stac9460_dac_vol_info,\n\t\t.get = stac9460_dac_vol_get,\n\t\t.put = stac9460_dac_vol_put,\n\t\t.private_value = 1,\n\t\t.tlv = { .p = db_scale_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"DAC Switch\",\n\t\t.count = 6,\n\t\t.info = stac9460_dac_mute_info,\n\t\t.get = stac9460_dac_mute_get,\n\t\t.put = stac9460_dac_mute_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"DAC Volume\",\n\t\t.count = 6,\n\t\t.info = stac9460_dac_vol_info,\n\t\t.get = stac9460_dac_vol_get,\n\t\t.put = stac9460_dac_vol_put,\n\t\t.tlv = { .p = db_scale_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC Capture Switch\",\n\t\t.count = 1,\n\t\t.info = stac9460_adc_mute_info,\n\t\t.get = stac9460_adc_mute_get,\n\t\t.put = stac9460_adc_mute_put,\n\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"ADC Capture Volume\",\n\t\t.count = 1,\n\t\t.info = stac9460_adc_vol_info,\n\t\t.get = stac9460_adc_vol_get,\n\t\t.put = stac9460_adc_vol_put,\n\t\t.tlv = { .p = db_scale_adc }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Capture Input\",\n\t\t.info = stac9460_mic_sw_info,\n\t\t.get = stac9460_mic_sw_get,\n\t\t.put = stac9460_mic_sw_put,\n\n\t},\n};\n\n \n \n#define AK4114_ADDR\t0x00  \n\n \nstatic void write_data(struct snd_ice1712 *ice, unsigned int gpio,\n\t\t       unsigned int data, int idx)\n{\n\tfor (; idx >= 0; idx--) {\n\t\t \n\t\tgpio &= ~VT1724_PRODIGY192_CCLK;\n\t\tsnd_ice1712_gpio_write(ice, gpio);\n\t\tudelay(1);\n\t\t \n\t\tif (data & (1 << idx))\n\t\t\tgpio |= VT1724_PRODIGY192_CDOUT;\n\t\telse\n\t\t\tgpio &= ~VT1724_PRODIGY192_CDOUT;\n\t\tsnd_ice1712_gpio_write(ice, gpio);\n\t\tudelay(1);\n\t\t \n\t\tgpio |= VT1724_PRODIGY192_CCLK;\n\t\tsnd_ice1712_gpio_write(ice, gpio);\n\t\tudelay(1);\n\t}\n}\n\n \nstatic unsigned char read_data(struct snd_ice1712 *ice, unsigned int gpio,\n\t\t\t       int idx)\n{\n\tunsigned char data = 0;\n\n\tfor (; idx >= 0; idx--) {\n\t\t \n\t\tgpio &= ~VT1724_PRODIGY192_CCLK;\n\t\tsnd_ice1712_gpio_write(ice, gpio);\n\t\tudelay(1);\n\t\t \n\t\tif (snd_ice1712_gpio_read(ice) & VT1724_PRODIGY192_CDIN)\n\t\t\tdata |= (1 << idx);\n\t\tudelay(1);\n\t\t \n\t\tgpio |= VT1724_PRODIGY192_CCLK;\n\t\tsnd_ice1712_gpio_write(ice, gpio);\n\t\tudelay(1);\n\t}\n\treturn data;\n}\n \nstatic unsigned int prodigy192_4wire_start(struct snd_ice1712 *ice)\n{\n\tunsigned int tmp;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\ttmp = snd_ice1712_gpio_read(ice);\n\n\ttmp |= VT1724_PRODIGY192_CCLK;  \n\ttmp &= ~VT1724_PRODIGY192_CS;  \n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\treturn tmp;\n}\n\n \nstatic void prodigy192_4wire_finish(struct snd_ice1712 *ice, unsigned int tmp)\n{\n\ttmp |= VT1724_PRODIGY192_CS;  \n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\tsnd_ice1712_restore_gpio_status(ice);\n}\n\n \nstatic void prodigy192_ak4114_write(void *private_data, unsigned char addr,\n\t\t\t       unsigned char data)\n{\n\tstruct snd_ice1712 *ice = private_data;\n\tunsigned int tmp, addrdata;\n\ttmp = prodigy192_4wire_start(ice);\n\taddrdata = (AK4114_ADDR << 6) | 0x20 | (addr & 0x1f);\n\taddrdata = (addrdata << 8) | data;\n\twrite_data(ice, tmp, addrdata, 15);\n\tprodigy192_4wire_finish(ice, tmp);\n}\n\n \nstatic unsigned char prodigy192_ak4114_read(void *private_data,\n\t\t\t\t\t    unsigned char addr)\n{\n\tstruct snd_ice1712 *ice = private_data;\n\tunsigned int tmp;\n\tunsigned char data;\n\n\ttmp = prodigy192_4wire_start(ice);\n\twrite_data(ice, tmp, (AK4114_ADDR << 6) | (addr & 0x1f), 7);\n\tdata = read_data(ice, tmp, 7);\n\tprodigy192_4wire_finish(ice, tmp);\n\treturn data;\n}\n\n\nstatic int ak4114_input_sw_info(struct snd_kcontrol *kcontrol,\n\t       \t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"Toslink\", \"Coax\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\n\nstatic int ak4114_input_sw_get(struct snd_kcontrol *kcontrol,\n\t       \t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\t\t\n\tval = prodigy192_ak4114_read(ice, AK4114_REG_IO1);\n\t \n\tucontrol->value.enumerated.item[0] = (val & AK4114_IPS0) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int ak4114_input_sw_put(struct snd_kcontrol *kcontrol,\n\t       \t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char new, old, itemvalue;\n\tint change;\n\n\told = prodigy192_ak4114_read(ice, AK4114_REG_IO1);\n\t \n\titemvalue = (ucontrol->value.enumerated.item[0]) ? 0xff : 0x00;\n\n\tnew = (itemvalue & AK4114_IPS0) | (old & ~AK4114_IPS0);\n\tchange = (new != old);\n\tif (change)\n\t\tprodigy192_ak4114_write(ice, AK4114_REG_IO1, new);\n\treturn change;\n}\n\n\nstatic const struct snd_kcontrol_new ak4114_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"MIODIO IEC958 Capture Input\",\n\t\t.info = ak4114_input_sw_info,\n\t\t.get = ak4114_input_sw_get,\n\t\t.put = ak4114_input_sw_put,\n\n\t}\n};\n\n\nstatic int prodigy192_ak4114_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned char ak4114_init_vals[] = {\n\t\tAK4114_RST | AK4114_PWN | AK4114_OCKS0 | AK4114_OCKS1,\n\t\t \n\t\tAK4114_DIF_I24I2S | AK4114_DEM0 ,\n\t\tAK4114_TX1E,\n\t\tAK4114_EFH_1024 | AK4114_DIT,  \n\t\t0,\n\t\t0\n\t};\n\tstatic const unsigned char ak4114_init_txcsb[] = {\n\t\t0x41, 0x02, 0x2c, 0x00, 0x00\n\t};\n\tstruct prodigy192_spec *spec = ice->spec;\n\tint err;\n\n\terr = snd_ak4114_create(ice->card,\n\t\t\t\t prodigy192_ak4114_read,\n\t\t\t\t prodigy192_ak4114_write,\n\t\t\t\t ak4114_init_vals, ak4114_init_txcsb,\n\t\t\t\t ice, &spec->ak4114);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tspec->ak4114->check_flags = AK4114_CHECK_NO_RATE;\n\treturn 0;\n}\n\nstatic void stac9460_proc_regs_read(struct snd_info_entry *entry,\n\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_ice1712 *ice = entry->private_data;\n\tint reg, val;\n\t \n\tfor (reg = 0; reg <= 0x15; reg++) {\n\t\tval = stac9460_get(ice, reg);\n\t\tsnd_iprintf(buffer, \"0x%02x = 0x%02x\\n\", reg, val);\n\t}\n}\n\n\nstatic void stac9460_proc_init(struct snd_ice1712 *ice)\n{\n\tsnd_card_ro_proc_new(ice->card, \"stac9460_codec\", ice,\n\t\t\t     stac9460_proc_regs_read);\n}\n\n\nstatic int prodigy192_add_controls(struct snd_ice1712 *ice)\n{\n\tstruct prodigy192_spec *spec = ice->spec;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(stac_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t  snd_ctl_new1(&stac_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (spec->ak4114) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ak4114_controls); i++) {\n\t\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t\t  snd_ctl_new1(&ak4114_controls[i],\n\t\t\t\t\t\t       ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = snd_ak4114_build(spec->ak4114,\n\t\t\t\tNULL,  \n\t\t\t\tice->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tstac9460_proc_init(ice);\n\treturn 0;\n}\n\n \nstatic int prodigy192_miodio_exists(struct snd_ice1712 *ice)\n{\n\n\tunsigned char orig_value;\n\tconst unsigned char test_data = 0xd1;\t \n\tunsigned char addr = AK4114_REG_INT0_MASK;  \n\tint exists = 0;\n\n\torig_value = prodigy192_ak4114_read(ice, addr);\n\tprodigy192_ak4114_write(ice, addr, test_data);\n\tif (prodigy192_ak4114_read(ice, addr) == test_data) {\n\t\t \n\t\t \n\t\tprodigy192_ak4114_write(ice, addr, orig_value);\n\t\texists = 1;\n\t}\n\treturn exists;\n}\n\n \nstatic int prodigy192_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short stac_inits_prodigy[] = {\n\t\tSTAC946X_RESET, 0,\n\t\tSTAC946X_MASTER_CLOCKING, 0x11,\n \n\t\t(unsigned short)-1\n\t};\n\tconst unsigned short *p;\n\tint err = 0;\n\tstruct prodigy192_spec *spec;\n\n\t \n\tice->num_total_dacs = 6;\n\tice->num_total_adcs = 2;\n\tice->vt1720 = 0;   \n\t\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\tmutex_init(&spec->mute_mutex);\n\n\t \n\tp = stac_inits_prodigy;\n\tfor (; *p != (unsigned short)-1; p += 2)\n\t\tstac9460_put(ice, p[0], p[1]);\n\tice->gpio.set_pro_rate = stac9460_set_rate_val;\n\n\t \n\tif (prodigy192_miodio_exists(ice)) {\n\t\terr = prodigy192_ak4114_init(ice);\n\t\t \n\t\tdev_dbg(ice->card->dev,\n\t\t\t\"AK4114 initialized with status %d\\n\", err);\n\t} else\n\t\tdev_dbg(ice->card->dev, \"AK4114 not found\\n\");\n\n\treturn err;\n}\n\n\n \n\nstatic const unsigned char prodigy71_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x6a,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xf8,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = ~(VT1724_PRODIGY192_CDIN >> 8) ,\n\t[ICE_EEP2_GPIO_DIR2]   = 0xbf,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x10,   \n};\n\n\n \nstruct snd_ice1712_card_info snd_vt1724_prodigy192_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PRODIGY192VE,\n\t\t.name = \"Audiotrak Prodigy 192\",\n\t\t.model = \"prodigy192\",\n\t\t.chip_init = prodigy192_init,\n\t\t.build_controls = prodigy192_add_controls,\n\t\t.eeprom_size = sizeof(prodigy71_eeprom),\n\t\t.eeprom_data = prodigy71_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}