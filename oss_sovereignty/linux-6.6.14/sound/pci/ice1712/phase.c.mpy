{
  "module_name": "phase.c",
  "hash_id": "645693f2c1841c93b8a05c5cd21d098ff8fecb53c0a62b7178909d95fd4948d2",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/phase.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"phase.h\"\n#include <sound/tlv.h>\n\n \nstruct phase28_spec {\n\tunsigned short master[2];\n\tunsigned short vol[8];\n};\n\n \n#define WM_DAC_ATTEN\t\t0x00\t \n#define WM_DAC_MASTER_ATTEN\t0x08\t \n#define WM_DAC_DIG_ATTEN\t0x09\t \n#define WM_DAC_DIG_MASTER_ATTEN\t0x11\t \n#define WM_PHASE_SWAP\t\t0x12\t \n#define WM_DAC_CTRL1\t\t0x13\t \n#define WM_MUTE\t\t\t0x14\t \n#define WM_DAC_CTRL2\t\t0x15\t \n#define WM_INT_CTRL\t\t0x16\t \n#define WM_MASTER\t\t0x17\t \n#define WM_POWERDOWN\t\t0x18\t \n#define WM_ADC_GAIN\t\t0x19\t \n#define WM_ADC_MUX\t\t0x1b\t \n#define WM_OUT_MUX1\t\t0x1c\t \n#define WM_OUT_MUX2\t\t0x1e\t \n#define WM_RESET\t\t0x1f\t \n\n\n \nstatic const unsigned char wm_vol[256] = {\n\t127, 48, 42, 39, 36, 34, 33, 31, 30, 29, 28, 27, 27, 26, 25, 25, 24,\n\t24, 23, 23, 22, 22, 21, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 18,\n\t17, 17, 17, 17, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14,\n\t14, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11,\n\t11, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9,\n\t9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n#define WM_VOL_MAX\t(sizeof(wm_vol) - 1)\n#define WM_VOL_MUTE\t0x8000\n\nstatic const struct snd_akm4xxx akm_phase22 = {\n\t.type = SND_AK4524,\n\t.num_dacs = 2,\n\t.num_adcs = 2,\n};\n\nstatic const struct snd_ak4xxx_private akm_phase22_priv = {\n\t.caddr =\t2,\n\t.cif =\t\t1,\n\t.data_mask =\t1 << 4,\n\t.clk_mask =\t1 << 5,\n\t.cs_mask =\t1 << 10,\n\t.cs_addr =\t1 << 10,\n\t.cs_none =\t0,\n\t.add_flags = \t1 << 3,\n\t.mask_flags =\t0,\n};\n\nstatic int phase22_init(struct snd_ice1712 *ice)\n{\n\tstruct snd_akm4xxx *ak;\n\tint err;\n\n\t \n\tswitch (ice->eeprom.subvendor) {\n\tcase VT1724_SUBDEVICE_PHASE22:\n\tcase VT1724_SUBDEVICE_TS22:\n\t\tice->num_total_dacs = 2;\n\t\tice->num_total_adcs = 2;\n\t\tice->vt1720 = 1;  \n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tak = ice->akm;\n\tif (!ak)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\tswitch (ice->eeprom.subvendor) {\n\tcase VT1724_SUBDEVICE_PHASE22:\n\tcase VT1724_SUBDEVICE_TS22:\n\t\terr = snd_ice1712_akm4xxx_init(ak, &akm_phase22,\n\t\t\t\t\t\t&akm_phase22_priv, ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int phase22_add_controls(struct snd_ice1712 *ice)\n{\n\tint err = 0;\n\n\tswitch (ice->eeprom.subvendor) {\n\tcase VT1724_SUBDEVICE_PHASE22:\n\tcase VT1724_SUBDEVICE_TS22:\n\t\terr = snd_ice1712_akm4xxx_build_controls(ice);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic const unsigned char phase22_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x28,   \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xf0,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0xff,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\nstatic const unsigned char phase28_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x2b,   \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xfc,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x5f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\n \nstatic void phase28_spi_write(struct snd_ice1712 *ice, unsigned int cs,\n\t\t\t\tunsigned int data, int bits)\n{\n\tunsigned int tmp;\n\tint i;\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\n\tsnd_ice1712_gpio_set_mask(ice, ~(PHASE28_WM_RW|PHASE28_SPI_MOSI|\n\t\t\t\t\tPHASE28_SPI_CLK|PHASE28_WM_CS));\n\ttmp |= PHASE28_WM_RW;\n\ttmp &= ~cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\n\tfor (i = bits - 1; i >= 0; i--) {\n\t\ttmp &= ~PHASE28_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\tif (data & (1 << i))\n\t\t\ttmp |= PHASE28_SPI_MOSI;\n\t\telse\n\t\t\ttmp &= ~PHASE28_SPI_MOSI;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\ttmp |= PHASE28_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t}\n\n\ttmp &= ~PHASE28_SPI_CLK;\n\ttmp |= cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= PHASE28_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n}\n\n \nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\n{\n\treg <<= 1;\n\treturn ((unsigned short)ice->akm[0].images[reg] << 8) |\n\t\tice->akm[0].images[reg + 1];\n}\n\n \nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\tphase28_spi_write(ice, PHASE28_WM_CS, (reg << 9) | (val & 0x1ff), 16);\n}\n\n \nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\twm_put_nocache(ice, reg, val);\n\treg <<= 1;\n\tice->akm[0].images[reg] = val >> 8;\n\tice->akm[0].images[reg + 1] = val;\n}\n\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index,\n\t\t\tunsigned short vol, unsigned short master)\n{\n\tunsigned char nvol;\n\n\tif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\n\t\tnvol = 0;\n\telse\n\t\tnvol = 127 - wm_vol[(((vol & ~WM_VOL_MUTE) *\n\t\t\t(master & ~WM_VOL_MUTE)) / 127) & WM_VOL_MAX];\n\n\twm_put(ice, index, nvol);\n\twm_put_nocache(ice, index, 0x180 | nvol);\n}\n\n \n#define wm_pcm_mute_info\tsnd_ctl_boolean_mono_info\n\nstatic int wm_pcm_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_MUTE) & 0x10) ?\n\t\t\t\t\t\t0 : 1;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_pcm_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short nval, oval;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = wm_get(ice, WM_MUTE);\n\tnval = (oval & ~0x10) | (ucontrol->value.integer.value[0] ? 0 : 0x10);\n\tchange = (nval != oval);\n\tif (change)\n\t\twm_put(ice, WM_MUTE, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = WM_VOL_MAX;\n\treturn 0;\n}\n\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] = spec->master[i] &\n\t\t\t\t\t\t\t~WM_VOL_MUTE;\n\treturn 0;\n}\n\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint ch, change = 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tunsigned int vol = ucontrol->value.integer.value[ch];\n\t\tif (vol > WM_VOL_MAX)\n\t\t\tcontinue;\n\t\tvol |= spec->master[ch] & WM_VOL_MUTE;\n\t\tif (vol != spec->master[ch]) {\n\t\t\tint dac;\n\t\t\tspec->master[ch] = vol;\n\t\t\tfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\n\t\t\t\twm_set_vol(ice, WM_DAC_ATTEN + dac + ch,\n\t\t\t\t\t   spec->vol[dac + ch],\n\t\t\t\t\t   spec->master[ch]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\nstatic int phase28_init(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm_inits_phase28[] = {\n\t\t \n\t\t0x1b, 0x044,\t \n\t\t0x1c, 0x00B,\t \n\t\t0x1d, 0x009,\t \n\n\t\t0x18, 0x000,\t \n\n\t\t0x16, 0x122,\t \n\t\t0x17, 0x022,\t \n\t\t0x00, 0,\t \n\t\t0x01, 0,\t \n\t\t0x02, 0,\t \n\t\t0x03, 0,\t \n\t\t0x04, 0,\t \n\t\t0x05, 0,\t \n\t\t0x06, 0,\t \n\t\t0x07, 0,\t \n\t\t0x08, 0x100,\t \n\t\t0x09, 0xff,\t \n\t\t0x0a, 0xff,\t \n\t\t0x0b, 0xff,\t \n\t\t0x0c, 0xff,\t \n\t\t0x0d, 0xff,\t \n\t\t0x0e, 0xff,\t \n\t\t0x0f, 0xff,\t \n\t\t0x10, 0xff,\t \n\t\t0x11, 0x1ff,\t \n\t\t0x12, 0x000,\t \n\t\t0x13, 0x090,\t \n\t\t0x14, 0x000,\t \n\t\t0x15, 0x000,\t \n\t\t0x19, 0x000,\t \n\t\t0x1a, 0x000,\t \n\t\t(unsigned short)-1\n\t};\n\n\tunsigned int tmp;\n\tstruct snd_akm4xxx *ak;\n\tstruct phase28_spec *spec;\n\tconst unsigned short *p;\n\tint i;\n\n\tice->num_total_dacs = 8;\n\tice->num_total_adcs = 2;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\t \n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tak = ice->akm;\n\tif (!ak)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\tsnd_ice1712_gpio_set_dir(ice, 0x5fffff);  \n\n\t \n\tsnd_ice1712_save_gpio_status(ice);\n\tsnd_ice1712_gpio_set_mask(ice, ~(PHASE28_WM_RESET|PHASE28_WM_CS|\n\t\t\t\t\tPHASE28_HP_SEL));\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\ttmp &= ~PHASE28_WM_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= PHASE28_WM_CS;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= PHASE28_WM_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\n\tp = wm_inits_phase28;\n\tfor (; *p != (unsigned short)-1; p += 2)\n\t\twm_put(ice, p[0], p[1]);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\tspec->master[0] = WM_VOL_MUTE;\n\tspec->master[1] = WM_VOL_MUTE;\n\tfor (i = 0; i < ice->num_total_dacs; i++) {\n\t\tspec->vol[i] = WM_VOL_MUTE;\n\t\twm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wm_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tint voices = kcontrol->private_value >> 8;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = voices;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = 0x7F;\t \n\treturn 0;\n}\n\nstatic int wm_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint i, ofs, voices;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tfor (i = 0; i < voices; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\tspec->vol[ofs+i] & ~WM_VOL_MUTE;\n\treturn 0;\n}\n\nstatic int wm_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint i, idx, ofs, voices;\n\tint change = 0;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < voices; i++) {\n\t\tunsigned int vol;\n\t\tvol = ucontrol->value.integer.value[i];\n\t\tif (vol > 0x7f)\n\t\t\tcontinue;\n\t\tvol |= spec->vol[ofs+i] & WM_VOL_MUTE;\n\t\tif (vol != spec->vol[ofs+i]) {\n\t\t\tspec->vol[ofs+i] = vol;\n\t\t\tidx  = WM_DAC_ATTEN + ofs + i;\n\t\t\twm_set_vol(ice, idx, spec->vol[ofs+i],\n\t\t\t\t   spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int wm_mute_info(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo) {\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = kcontrol->private_value >> 8;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint voices, ofs, i;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xFF;\n\n\tfor (i = 0; i < voices; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\t(spec->vol[ofs+i] & WM_VOL_MUTE) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int wm_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint change = 0, voices, ofs, i;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xFF;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < voices; i++) {\n\t\tint val = (spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\n\t\tif (ucontrol->value.integer.value[i] != val) {\n\t\t\tspec->vol[ofs + i] &= ~WM_VOL_MUTE;\n\t\t\tspec->vol[ofs + i] |=\n\t\t\t\tucontrol->value.integer.value[i] ? 0 :\n\t\t\t\tWM_VOL_MUTE;\n\t\t\twm_set_vol(ice, ofs + i, spec->vol[ofs + i],\n\t\t\t\t\tspec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define wm_master_mute_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int wm_master_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\n\tucontrol->value.integer.value[0] =\n\t\t(spec->master[0] & WM_VOL_MUTE) ? 0 : 1;\n\tucontrol->value.integer.value[1] =\n\t\t(spec->master[1] & WM_VOL_MUTE) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int wm_master_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct phase28_spec *spec = ice->spec;\n\tint change = 0, i;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < 2; i++) {\n\t\tint val = (spec->master[i] & WM_VOL_MUTE) ? 0 : 1;\n\t\tif (ucontrol->value.integer.value[i] != val) {\n\t\t\tint dac;\n\t\t\tspec->master[i] &= ~WM_VOL_MUTE;\n\t\t\tspec->master[i] |=\n\t\t\t\tucontrol->value.integer.value[i] ? 0 :\n\t\t\t\tWM_VOL_MUTE;\n\t\t\tfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\n\t\t\t\twm_set_vol(ice, WM_DAC_ATTEN + dac + i,\n\t\t\t\t\t\tspec->vol[dac + i],\n\t\t\t\t\t\tspec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define PCM_0dB 0xff\n#define PCM_RES 128\t \n#define PCM_MIN (PCM_0dB - PCM_RES)\nstatic int wm_pcm_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = PCM_RES;\t \n\treturn 0;\n}\n\nstatic int wm_pcm_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tval = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\n\tval = val > PCM_MIN ? (val - PCM_MIN) : 0;\n\tucontrol->value.integer.value[0] = val;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_pcm_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change = 0;\n\n\tnvol = ucontrol->value.integer.value[0];\n\tif (nvol > PCM_RES)\n\t\treturn -EINVAL;\n\tsnd_ice1712_save_gpio_status(ice);\n\tnvol = (nvol ? (nvol + PCM_MIN) : 0) & 0xff;\n\tovol = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\n\tif (ovol != nvol) {\n\t\twm_put(ice, WM_DAC_DIG_MASTER_ATTEN, nvol);  \n\t\t \n\t\twm_put_nocache(ice, WM_DAC_DIG_MASTER_ATTEN, nvol | 0x100);\n\t\tchange = 1;\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \n#define phase28_deemp_info\tsnd_ctl_boolean_mono_info\n\nstatic int phase28_deemp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL2) & 0xf) ==\n\t\t\t\t\t\t0xf;\n\treturn 0;\n}\n\nstatic int phase28_deemp_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint temp, temp2;\n\ttemp = wm_get(ice, WM_DAC_CTRL2);\n\ttemp2 = temp;\n\tif (ucontrol->value.integer.value[0])\n\t\ttemp |= 0xf;\n\telse\n\t\ttemp &= ~0xf;\n\tif (temp != temp2) {\n\t\twm_put(ice, WM_DAC_CTRL2, temp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int phase28_oversampling_info(struct snd_kcontrol *k,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"128x\", \"64x\"\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int phase28_oversampling_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = (wm_get(ice, WM_MASTER) & 0x8) ==\n\t\t\t\t\t\t0x8;\n\treturn 0;\n}\n\nstatic int phase28_oversampling_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint temp, temp2;\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\ttemp = wm_get(ice, WM_MASTER);\n\ttemp2 = temp;\n\n\tif (ucontrol->value.enumerated.item[0])\n\t\ttemp |= 0x8;\n\telse\n\t\ttemp &= ~0x8;\n\n\tif (temp != temp2) {\n\t\twm_put(ice, WM_MASTER, temp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_dac, -12700, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_pcm, -6400, 50, 1);\n\nstatic const struct snd_kcontrol_new phase28_dac_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = wm_master_mute_info,\n\t\t.get = wm_master_mute_get,\n\t\t.put = wm_master_mute_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Master Playback Volume\",\n\t\t.info = wm_master_vol_info,\n\t\t.get = wm_master_vol_get,\n\t\t.put = wm_master_vol_put,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Front Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 0\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Front Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 0,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Rear Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 2\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Rear Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 2,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Center Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (1 << 8) | 4\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Center Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (1 << 8) | 4,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"LFE Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (1 << 8) | 5\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"LFE Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (1 << 8) | 5,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Side Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 6\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Side Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 6,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t}\n};\n\nstatic const struct snd_kcontrol_new wm_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Switch\",\n\t\t.info = wm_pcm_mute_info,\n\t\t.get = wm_pcm_mute_get,\n\t\t.put = wm_pcm_mute_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"PCM Playback Volume\",\n\t\t.info = wm_pcm_vol_info,\n\t\t.get = wm_pcm_vol_get,\n\t\t.put = wm_pcm_vol_put,\n\t\t.tlv = { .p = db_scale_wm_pcm }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"DAC Deemphasis Switch\",\n\t\t.info = phase28_deemp_info,\n\t\t.get = phase28_deemp_get,\n\t\t.put = phase28_deemp_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC Oversampling\",\n\t\t.info = phase28_oversampling_info,\n\t\t.get = phase28_oversampling_get,\n\t\t.put = phase28_oversampling_put\n\t}\n};\n\nstatic int phase28_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int i, counts;\n\tint err;\n\n\tcounts = ARRAY_SIZE(phase28_dac_controls);\n\tfor (i = 0; i < counts; i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t\tsnd_ctl_new1(&phase28_dac_controls[i],\n\t\t\t\t\t\t\tice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm_controls); i++) {\n\t\terr = snd_ctl_add(ice->card,\n\t\t\t\t\tsnd_ctl_new1(&wm_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct snd_ice1712_card_info snd_vt1724_phase_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PHASE22,\n\t\t.name = \"Terratec PHASE 22\",\n\t\t.model = \"phase22\",\n\t\t.chip_init = phase22_init,\n\t\t.build_controls = phase22_add_controls,\n\t\t.eeprom_size = sizeof(phase22_eeprom),\n\t\t.eeprom_data = phase22_eeprom,\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PHASE28,\n\t\t.name = \"Terratec PHASE 28\",\n\t\t.model = \"phase28\",\n\t\t.chip_init = phase28_init,\n\t\t.build_controls = phase28_add_controls,\n\t\t.eeprom_size = sizeof(phase28_eeprom),\n\t\t.eeprom_data = phase28_eeprom,\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_TS22,\n\t\t.name = \"Terrasoniq TS22 PCI\",\n\t\t.model = \"TS22\",\n\t\t.chip_init = phase22_init,\n\t\t.build_controls = phase22_add_controls,\n\t\t.eeprom_size = sizeof(phase22_eeprom),\n\t\t.eeprom_data = phase22_eeprom,\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}