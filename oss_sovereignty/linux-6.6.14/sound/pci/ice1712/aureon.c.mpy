{
  "module_name": "aureon.c",
  "hash_id": "b4c420b28ddad20e32e1c2a4df6a1e0852d8bcb8d94dddd890348fe29de220f7",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ice1712/aureon.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n\n#include \"ice1712.h\"\n#include \"envy24ht.h\"\n#include \"aureon.h\"\n#include <sound/tlv.h>\n\n \nstruct aureon_spec {\n\tunsigned short stac9744[64];\n\tunsigned int cs8415_mux;\n\tunsigned short master[2];\n\tunsigned short vol[8];\n\tunsigned char pca9554_out;\n};\n\n \n#define WM_DAC_ATTEN\t\t0x00\t \n#define WM_DAC_MASTER_ATTEN\t0x08\t \n#define WM_DAC_DIG_ATTEN\t0x09\t \n#define WM_DAC_DIG_MASTER_ATTEN\t0x11\t \n#define WM_PHASE_SWAP\t\t0x12\t \n#define WM_DAC_CTRL1\t\t0x13\t \n#define WM_MUTE\t\t\t0x14\t \n#define WM_DAC_CTRL2\t\t0x15\t \n#define WM_INT_CTRL\t\t0x16\t \n#define WM_MASTER\t\t0x17\t \n#define WM_POWERDOWN\t\t0x18\t \n#define WM_ADC_GAIN\t\t0x19\t \n#define WM_ADC_MUX\t\t0x1b\t \n#define WM_OUT_MUX1\t\t0x1c\t \n#define WM_OUT_MUX2\t\t0x1e\t \n#define WM_RESET\t\t0x1f\t \n\n \n#define CS8415_CTRL1\t0x01\n#define CS8415_CTRL2\t0x02\n#define CS8415_QSUB\t\t0x14\n#define CS8415_RATIO\t0x1E\n#define CS8415_C_BUFFER\t0x20\n#define CS8415_ID\t\t0x7F\n\n \n#define PCA9554_DEV     0x40             \n#define PCA9554_IN      0x00             \n#define PCA9554_OUT     0x01             \n#define PCA9554_INVERT  0x02             \n#define PCA9554_DIR     0x03             \n\n \n\n \nstatic void aureon_pca9554_write(struct snd_ice1712 *ice, unsigned char reg,\n\t\t\t\t unsigned char data)\n{\n\tunsigned int tmp;\n\tint i, j;\n\tunsigned char dev = PCA9554_DEV;   \n\tunsigned char val = 0;\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\n\tsnd_ice1712_gpio_set_mask(ice, ~(AUREON_SPI_MOSI|AUREON_SPI_CLK|\n\t\t\t\t\t AUREON_WM_RW|AUREON_WM_CS|\n\t\t\t\t\t AUREON_CS8415_CS));\n\ttmp |= AUREON_WM_RW;\n\ttmp |= AUREON_CS8415_CS | AUREON_WM_CS;  \n\n\ttmp &= ~AUREON_SPI_MOSI;\n\ttmp &= ~AUREON_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(50);\n\n\t \n\ttmp |= AUREON_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(50);\n\ttmp |= AUREON_SPI_MOSI;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(100);\n\ttmp &= ~AUREON_SPI_MOSI;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(50);\n\ttmp &= ~AUREON_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(100);\n\t \n\tfor (j = 0; j < 3; j++) {\n\t\tswitch (j) {\n\t\tcase 0:\n\t\t\tval = dev;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval = reg;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = data;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\ttmp &= ~AUREON_SPI_CLK;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(40);\n\t\t\tif (val & (1 << i))\n\t\t\t\ttmp |= AUREON_SPI_MOSI;\n\t\t\telse\n\t\t\t\ttmp &= ~AUREON_SPI_MOSI;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(40);\n\t\t\ttmp |= AUREON_SPI_CLK;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(40);\n\t\t}\n\t\ttmp &= ~AUREON_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(40);\n\t\ttmp |= AUREON_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(40);\n\t\ttmp &= ~AUREON_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(40);\n\t}\n\ttmp &= ~AUREON_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(40);\n\ttmp &= ~AUREON_SPI_MOSI;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(40);\n\ttmp |= AUREON_SPI_CLK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(50);\n\ttmp |= AUREON_SPI_MOSI;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(100);\n}\n\nstatic int aureon_universe_inmux_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] =\n\t\t{\"Internal Aux\", \"Wavetable\", \"Rear Line-In\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int aureon_universe_inmux_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tucontrol->value.enumerated.item[0] = spec->pca9554_out;\n\treturn 0;\n}\n\nstatic int aureon_universe_inmux_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tunsigned char oval, nval;\n\tint change;\n\n\tnval = ucontrol->value.enumerated.item[0];\n\tif (nval >= 3)\n\t\treturn -EINVAL;\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = spec->pca9554_out;\n\tchange = (oval != nval);\n\tif (change) {\n\t\taureon_pca9554_write(ice, PCA9554_OUT, nval);\n\t\tspec->pca9554_out = nval;\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n\nstatic void aureon_ac97_write(struct snd_ice1712 *ice, unsigned short reg,\n\t\t\t      unsigned short val)\n{\n\tstruct aureon_spec *spec = ice->spec;\n\tunsigned int tmp;\n\n\t \n\ttmp = (snd_ice1712_gpio_read(ice) & ~0xFF) | (reg & 0x7F);\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp |= AUREON_AC97_ADDR;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp &= ~AUREON_AC97_ADDR;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\n\t \n\ttmp &= ~AUREON_AC97_DATA_MASK;\n\ttmp |= val & AUREON_AC97_DATA_MASK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp |= AUREON_AC97_DATA_LOW;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp &= ~AUREON_AC97_DATA_LOW;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\n\t \n\ttmp &= ~AUREON_AC97_DATA_MASK;\n\ttmp |= (val >> 8) & AUREON_AC97_DATA_MASK;\n\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp |= AUREON_AC97_DATA_HIGH;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp &= ~AUREON_AC97_DATA_HIGH;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\n\t \n\ttmp |= AUREON_AC97_COMMIT;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\ttmp &= ~AUREON_AC97_COMMIT;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(10);\n\n\t \n\tspec->stac9744[(reg & 0x7F) >> 1] = val;\n}\n\nstatic unsigned short aureon_ac97_read(struct snd_ice1712 *ice, unsigned short reg)\n{\n\tstruct aureon_spec *spec = ice->spec;\n\treturn spec->stac9744[(reg & 0x7F) >> 1];\n}\n\n \nstatic int aureon_ac97_init(struct snd_ice1712 *ice)\n{\n\tstruct aureon_spec *spec = ice->spec;\n\tint i;\n\tstatic const unsigned short ac97_defaults[] = {\n\t\t0x00, 0x9640,\n\t\t0x02, 0x8000,\n\t\t0x04, 0x8000,\n\t\t0x06, 0x8000,\n\t\t0x0C, 0x8008,\n\t\t0x0E, 0x8008,\n\t\t0x10, 0x8808,\n\t\t0x12, 0x8808,\n\t\t0x14, 0x8808,\n\t\t0x16, 0x8808,\n\t\t0x18, 0x8808,\n\t\t0x1C, 0x8000,\n\t\t0x26, 0x000F,\n\t\t0x28, 0x0201,\n\t\t0x2C, 0xBB80,\n\t\t0x32, 0xBB80,\n\t\t0x7C, 0x8384,\n\t\t0x7E, 0x7644,\n\t\t(unsigned short)-1\n\t};\n\tunsigned int tmp;\n\n\t \n\ttmp = (snd_ice1712_gpio_read(ice) | AUREON_AC97_RESET) & ~AUREON_AC97_DATA_MASK;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(3);\n\n\ttmp &= ~AUREON_AC97_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(3);\n\n\ttmp |= AUREON_AC97_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(3);\n\n\tmemset(&spec->stac9744, 0, sizeof(spec->stac9744));\n\tfor (i = 0; ac97_defaults[i] != (unsigned short)-1; i += 2)\n\t\tspec->stac9744[(ac97_defaults[i]) >> 1] = ac97_defaults[i+1];\n\n\t \n\taureon_ac97_write(ice, AC97_MASTER, 0x0000);\n\n\treturn 0;\n}\n\n#define AUREON_AC97_STEREO\t0x80\n\n \nstatic int aureon_ac97_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = kcontrol->private_value & AUREON_AC97_STEREO ? 2 : 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 31;\n\treturn 0;\n}\n\nstatic int aureon_ac97_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short vol;\n\n\tmutex_lock(&ice->gpio_mutex);\n\n\tvol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\n\tucontrol->value.integer.value[0] = 0x1F - (vol & 0x1F);\n\tif (kcontrol->private_value & AUREON_AC97_STEREO)\n\t\tucontrol->value.integer.value[1] = 0x1F - ((vol >> 8) & 0x1F);\n\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int aureon_ac97_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\n\tovol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\n\tnvol = (0x1F - ucontrol->value.integer.value[0]) & 0x001F;\n\tif (kcontrol->private_value & AUREON_AC97_STEREO)\n\t\tnvol |= ((0x1F - ucontrol->value.integer.value[1]) << 8) & 0x1F00;\n\tnvol |= ovol & ~0x1F1F;\n\n\tchange = (ovol != nvol);\n\tif (change)\n\t\taureon_ac97_write(ice, kcontrol->private_value & 0x7F, nvol);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define aureon_ac97_mute_info\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_ac97_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\n\tucontrol->value.integer.value[0] = aureon_ac97_read(ice,\n\t\t\tkcontrol->private_value & 0x7F) & 0x8000 ? 0 : 1;\n\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int aureon_ac97_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\n\tovol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\n\tnvol = (ucontrol->value.integer.value[0] ? 0x0000 : 0x8000) | (ovol & ~0x8000);\n\n\tchange = (ovol != nvol);\n\tif (change)\n\t\taureon_ac97_write(ice, kcontrol->private_value & 0x7F, nvol);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define aureon_ac97_micboost_info\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_ac97_micboost_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\n\tucontrol->value.integer.value[0] = aureon_ac97_read(ice, AC97_MIC) & 0x0020 ? 0 : 1;\n\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int aureon_ac97_micboost_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\n\tovol = aureon_ac97_read(ice, AC97_MIC);\n\tnvol = (ucontrol->value.integer.value[0] ? 0x0000 : 0x0020) | (ovol & ~0x0020);\n\n\tchange = (ovol != nvol);\n\tif (change)\n\t\taureon_ac97_write(ice, AC97_MIC, nvol);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \nstatic void aureon_spi_write(struct snd_ice1712 *ice, unsigned int cs, unsigned int data, int bits)\n{\n\tunsigned int tmp;\n\tint i;\n\tunsigned int mosi, clk;\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\n\t    ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) {\n\t\tsnd_ice1712_gpio_set_mask(ice, ~(PRODIGY_SPI_MOSI|PRODIGY_SPI_CLK|PRODIGY_WM_CS));\n\t\tmosi = PRODIGY_SPI_MOSI;\n\t\tclk = PRODIGY_SPI_CLK;\n\t} else {\n\t\tsnd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RW|AUREON_SPI_MOSI|AUREON_SPI_CLK|\n\t\t\t\t\t\t AUREON_WM_CS|AUREON_CS8415_CS));\n\t\tmosi = AUREON_SPI_MOSI;\n\t\tclk = AUREON_SPI_CLK;\n\n\t\ttmp |= AUREON_WM_RW;\n\t}\n\n\ttmp &= ~cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\n\tfor (i = bits - 1; i >= 0; i--) {\n\t\ttmp &= ~clk;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\tif (data & (1 << i))\n\t\t\ttmp |= mosi;\n\t\telse\n\t\t\ttmp &= ~mosi;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t\ttmp |= clk;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t}\n\n\ttmp &= ~clk;\n\ttmp |= cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= clk;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n}\n\n \nstatic void aureon_spi_read(struct snd_ice1712 *ice, unsigned int cs,\n\t\tunsigned int data, int bits, unsigned char *buffer, int size)\n{\n\tint i, j;\n\tunsigned int tmp;\n\n\ttmp = (snd_ice1712_gpio_read(ice) & ~AUREON_SPI_CLK) | AUREON_CS8415_CS|AUREON_WM_CS;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\ttmp &= ~cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\n\tfor (i = bits-1; i >= 0; i--) {\n\t\tif (data & (1 << i))\n\t\t\ttmp |= AUREON_SPI_MOSI;\n\t\telse\n\t\t\ttmp &= ~AUREON_SPI_MOSI;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\n\t\ttmp |= AUREON_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\n\t\ttmp &= ~AUREON_SPI_CLK;\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\tudelay(1);\n\t}\n\n\tfor (j = 0; j < size; j++) {\n\t\tunsigned char outdata = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\ttmp = snd_ice1712_gpio_read(ice);\n\t\t\toutdata <<= 1;\n\t\t\toutdata |= (tmp & AUREON_SPI_MISO) ? 1 : 0;\n\t\t\tudelay(1);\n\n\t\t\ttmp |= AUREON_SPI_CLK;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(1);\n\n\t\t\ttmp &= ~AUREON_SPI_CLK;\n\t\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\t\tudelay(1);\n\t\t}\n\t\tbuffer[j] = outdata;\n\t}\n\n\ttmp |= cs;\n\tsnd_ice1712_gpio_write(ice, tmp);\n}\n\nstatic unsigned char aureon_cs8415_get(struct snd_ice1712 *ice, int reg)\n{\n\tunsigned char val;\n\taureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);\n\taureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, &val, 1);\n\treturn val;\n}\n\nstatic void aureon_cs8415_read(struct snd_ice1712 *ice, int reg,\n\t\t\t\tunsigned char *buffer, int size)\n{\n\taureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);\n\taureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, buffer, size);\n}\n\nstatic void aureon_cs8415_put(struct snd_ice1712 *ice, int reg,\n\t\t\t\t\t\tunsigned char val)\n{\n\taureon_spi_write(ice, AUREON_CS8415_CS, 0x200000 | (reg << 8) | val, 24);\n}\n\n \nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\n{\n\treg <<= 1;\n\treturn ((unsigned short)ice->akm[0].images[reg] << 8) |\n\t\tice->akm[0].images[reg + 1];\n}\n\n \nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\taureon_spi_write(ice,\n\t\t\t ((ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\n\t\t\t   ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) ?\n\t\t\t PRODIGY_WM_CS : AUREON_WM_CS),\n\t\t\t(reg << 9) | (val & 0x1ff), 16);\n}\n\n \nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\n{\n\twm_put_nocache(ice, reg, val);\n\treg <<= 1;\n\tice->akm[0].images[reg] = val >> 8;\n\tice->akm[0].images[reg + 1] = val;\n}\n\n \n#define aureon_mono_bool_info\t\tsnd_ctl_boolean_mono_info\n\n \n#define aureon_ac97_mmute_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_ac97_mmute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_OUT_MUX1) >> 1) & 0x01;\n\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int aureon_ac97_mmute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\n\tovol = wm_get(ice, WM_OUT_MUX1);\n\tnvol = (ovol & ~0x02) | (ucontrol->value.integer.value[0] ? 0x02 : 0x00);\n\tchange = (ovol != nvol);\n\tif (change)\n\t\twm_put(ice, WM_OUT_MUX1, nvol);\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_dac, -10000, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_pcm, -6400, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_wm_adc, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_ac97_master, -4650, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_ac97_gain, -3450, 150, 0);\n\n#define WM_VOL_MAX\t100\n#define WM_VOL_CNT\t101\t \n#define WM_VOL_MUTE\t0x8000\n\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index, unsigned short vol, unsigned short master)\n{\n\tunsigned char nvol;\n\n\tif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE)) {\n\t\tnvol = 0;\n\t} else {\n\t\tnvol = ((vol % WM_VOL_CNT) * (master % WM_VOL_CNT)) /\n\t\t\t\t\t\t\t\tWM_VOL_MAX;\n\t\tnvol += 0x1b;\n\t}\n\n\twm_put(ice, index, nvol);\n\twm_put_nocache(ice, index, 0x180 | nvol);\n}\n\n \n#define wm_pcm_mute_info\tsnd_ctl_boolean_mono_info\n\nstatic int wm_pcm_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ice->gpio_mutex);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_MUTE) & 0x10) ? 0 : 1;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_pcm_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short nval, oval;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = wm_get(ice, WM_MUTE);\n\tnval = (oval & ~0x10) | (ucontrol->value.integer.value[0] ? 0 : 0x10);\n\tchange = (oval != nval);\n\tif (change)\n\t\twm_put(ice, WM_MUTE, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = WM_VOL_MAX;\n\treturn 0;\n}\n\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\tspec->master[i] & ~WM_VOL_MUTE;\n\treturn 0;\n}\n\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint ch, change = 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (ch = 0; ch < 2; ch++) {\n\t\tunsigned int vol = ucontrol->value.integer.value[ch];\n\t\tif (vol > WM_VOL_MAX)\n\t\t\tvol = WM_VOL_MAX;\n\t\tvol |= spec->master[ch] & WM_VOL_MUTE;\n\t\tif (vol != spec->master[ch]) {\n\t\t\tint dac;\n\t\t\tspec->master[ch] = vol;\n\t\t\tfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\n\t\t\t\twm_set_vol(ice, WM_DAC_ATTEN + dac + ch,\n\t\t\t\t\t   spec->vol[dac + ch],\n\t\t\t\t\t   spec->master[ch]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int wm_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint voices = kcontrol->private_value >> 8;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = voices;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = WM_VOL_MAX;\t \n\treturn 0;\n}\n\nstatic int wm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint i, ofs, voices;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tfor (i = 0; i < voices; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\tspec->vol[ofs+i] & ~WM_VOL_MUTE;\n\treturn 0;\n}\n\nstatic int wm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint i, idx, ofs, voices;\n\tint change = 0;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xff;\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < voices; i++) {\n\t\tunsigned int vol = ucontrol->value.integer.value[i];\n\t\tif (vol > WM_VOL_MAX)\n\t\t\tvol = WM_VOL_MAX;\n\t\tvol |= spec->vol[ofs+i] & WM_VOL_MUTE;\n\t\tif (vol != spec->vol[ofs+i]) {\n\t\t\tspec->vol[ofs+i] = vol;\n\t\t\tidx  = WM_DAC_ATTEN + ofs + i;\n\t\t\twm_set_vol(ice, idx, spec->vol[ofs + i],\n\t\t\t\t   spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int wm_mute_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = kcontrol->private_value >> 8;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint voices, ofs, i;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xFF;\n\n\tfor (i = 0; i < voices; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\t(spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int wm_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint change = 0, voices, ofs, i;\n\n\tvoices = kcontrol->private_value >> 8;\n\tofs = kcontrol->private_value & 0xFF;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < voices; i++) {\n\t\tint val = (spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\n\t\tif (ucontrol->value.integer.value[i] != val) {\n\t\t\tspec->vol[ofs + i] &= ~WM_VOL_MUTE;\n\t\t\tspec->vol[ofs + i] |=\n\t\t\t\tucontrol->value.integer.value[i] ? 0 : WM_VOL_MUTE;\n\t\t\twm_set_vol(ice, ofs + i, spec->vol[ofs + i],\n\t\t\t\t   spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define wm_master_mute_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int wm_master_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\n\tucontrol->value.integer.value[0] =\n\t\t(spec->master[0] & WM_VOL_MUTE) ? 0 : 1;\n\tucontrol->value.integer.value[1] =\n\t\t(spec->master[1] & WM_VOL_MUTE) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int wm_master_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tint change = 0, i;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < 2; i++) {\n\t\tint val = (spec->master[i] & WM_VOL_MUTE) ? 0 : 1;\n\t\tif (ucontrol->value.integer.value[i] != val) {\n\t\t\tint dac;\n\t\t\tspec->master[i] &= ~WM_VOL_MUTE;\n\t\t\tspec->master[i] |=\n\t\t\t\tucontrol->value.integer.value[i] ? 0 : WM_VOL_MUTE;\n\t\t\tfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\n\t\t\t\twm_set_vol(ice, WM_DAC_ATTEN + dac + i,\n\t\t\t\t\t   spec->vol[dac + i],\n\t\t\t\t\t   spec->master[i]);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \n#define PCM_0dB 0xff\n#define PCM_RES 128\t \n#define PCM_MIN (PCM_0dB - PCM_RES)\nstatic int wm_pcm_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = PCM_RES;\t \n\treturn 0;\n}\n\nstatic int wm_pcm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tval = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\n\tval = val > PCM_MIN ? (val - PCM_MIN) : 0;\n\tucontrol->value.integer.value[0] = val;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_pcm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short ovol, nvol;\n\tint change = 0;\n\n\tnvol = ucontrol->value.integer.value[0];\n\tif (nvol > PCM_RES)\n\t\treturn -EINVAL;\n\tsnd_ice1712_save_gpio_status(ice);\n\tnvol = (nvol ? (nvol + PCM_MIN) : 0) & 0xff;\n\tovol = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\n\tif (ovol != nvol) {\n\t\twm_put(ice, WM_DAC_DIG_MASTER_ATTEN, nvol);  \n\t\twm_put_nocache(ice, WM_DAC_DIG_MASTER_ATTEN, nvol | 0x100);  \n\t\tchange = 1;\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \n#define wm_adc_mute_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int wm_adc_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\tint i;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tval = wm_get(ice, WM_ADC_GAIN + i);\n\t\tucontrol->value.integer.value[i] = ~val>>5 & 0x1;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short new, old;\n\tint i, change = 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < 2; i++) {\n\t\told = wm_get(ice, WM_ADC_GAIN + i);\n\t\tnew = (~ucontrol->value.integer.value[i]<<5&0x20) | (old&~0x20);\n\t\tif (new != old) {\n\t\t\twm_put(ice, WM_ADC_GAIN + i, new);\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn change;\n}\n\n \nstatic int wm_adc_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = 0x1f;\t \n\treturn 0;\n}\n\nstatic int wm_adc_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint i, idx;\n\tunsigned short vol;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tidx = WM_ADC_GAIN + i;\n\t\tvol = wm_get(ice, idx) & 0x1f;\n\t\tucontrol->value.integer.value[i] = vol;\n\t}\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint i, idx;\n\tunsigned short ovol, nvol;\n\tint change = 0;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\tfor (i = 0; i < 2; i++) {\n\t\tidx  = WM_ADC_GAIN + i;\n\t\tnvol = ucontrol->value.integer.value[i] & 0x1f;\n\t\tovol = wm_get(ice, idx);\n\t\tif ((ovol & 0x1f) != nvol) {\n\t\t\twm_put(ice, idx, nvol | (ovol & ~0x1f));\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int wm_adc_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"CD\",\t\t \n\t\t\"Aux\",\t\t \n\t\t\"Line\",\t\t \n\t\t\"Mic\",\t\t \n\t\t\"AC97\"\t\t \n\t};\n\tstatic const char * const universe_texts[] = {\n\t\t\"Aux1\",\t\t \n\t\t\"CD\",\t\t \n\t\t\"Phono\",\t \n\t\t\"Line\",\t\t \n\t\t\"Aux2\",\t\t \n\t\t\"Mic\",\t\t \n\t\t\"Aux3\",\t\t \n\t\t\"AC97\"\t\t \n\t};\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE)\n\t\treturn snd_ctl_enum_info(uinfo, 2, 8, universe_texts);\n\telse\n\t\treturn snd_ctl_enum_info(uinfo, 2, 5, texts);\n}\n\nstatic int wm_adc_mux_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\n\tmutex_lock(&ice->gpio_mutex);\n\tval = wm_get(ice, WM_ADC_MUX);\n\tucontrol->value.enumerated.item[0] = val & 7;\n\tucontrol->value.enumerated.item[1] = (val >> 4) & 7;\n\tmutex_unlock(&ice->gpio_mutex);\n\treturn 0;\n}\n\nstatic int wm_adc_mux_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned short oval, nval;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = wm_get(ice, WM_ADC_MUX);\n\tnval = oval & ~0x77;\n\tnval |= ucontrol->value.enumerated.item[0] & 7;\n\tnval |= (ucontrol->value.enumerated.item[1] & 7) << 4;\n\tchange = (oval != nval);\n\tif (change)\n\t\twm_put(ice, WM_ADC_MUX, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int aureon_cs8415_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstatic const char * const aureon_texts[] = {\n\t\t\"CD\",\t\t \n\t\t\"Optical\"\t \n\t};\n\tstatic const char * const prodigy_texts[] = {\n\t\t\"CD\",\n\t\t\"Coax\"\n\t};\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71)\n\t\treturn snd_ctl_enum_info(uinfo, 1, 2, prodigy_texts);\n\telse\n\t\treturn snd_ctl_enum_info(uinfo, 1, 2, aureon_texts);\n}\n\nstatic int aureon_cs8415_mux_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\n\t \n\t \n\tucontrol->value.enumerated.item[0] = spec->cs8415_mux;\n\t \n\treturn 0;\n}\n\nstatic int aureon_cs8415_mux_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tstruct aureon_spec *spec = ice->spec;\n\tunsigned short oval, nval;\n\tint change;\n\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = aureon_cs8415_get(ice, CS8415_CTRL2);\n\tnval = oval & ~0x07;\n\tnval |= ucontrol->value.enumerated.item[0] & 7;\n\tchange = (oval != nval);\n\tif (change)\n\t\taureon_cs8415_put(ice, CS8415_CTRL2, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\tspec->cs8415_mux = ucontrol->value.enumerated.item[0];\n\treturn change;\n}\n\nstatic int aureon_cs8415_rate_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\treturn 0;\n}\n\nstatic int aureon_cs8415_rate_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char ratio;\n\tratio = aureon_cs8415_get(ice, CS8415_RATIO);\n\tucontrol->value.integer.value[0] = (int)((unsigned int)ratio * 750);\n\treturn 0;\n}\n\n \n#define aureon_cs8415_mute_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_cs8415_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tsnd_ice1712_save_gpio_status(ice);\n\tucontrol->value.integer.value[0] = (aureon_cs8415_get(ice, CS8415_CTRL1) & 0x20) ? 0 : 1;\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn 0;\n}\n\nstatic int aureon_cs8415_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tunsigned char oval, nval;\n\tint change;\n\tsnd_ice1712_save_gpio_status(ice);\n\toval = aureon_cs8415_get(ice, CS8415_CTRL1);\n\tif (ucontrol->value.integer.value[0])\n\t\tnval = oval & ~0x20;\n\telse\n\t\tnval = oval | 0x20;\n\tchange = (oval != nval);\n\tif (change)\n\t\taureon_cs8415_put(ice, CS8415_CTRL1, nval);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn change;\n}\n\n \nstatic int aureon_cs8415_qsub_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = 10;\n\treturn 0;\n}\n\nstatic int aureon_cs8415_qsub_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tsnd_ice1712_save_gpio_status(ice);\n\taureon_cs8415_read(ice, CS8415_QSUB, ucontrol->value.bytes.data, 10);\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\treturn 0;\n}\n\nstatic int aureon_cs8415_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int aureon_cs8415_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xFF, 24);\n\treturn 0;\n}\n\nstatic int aureon_cs8415_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tsnd_ice1712_save_gpio_status(ice);\n\taureon_cs8415_read(ice, CS8415_C_BUFFER, ucontrol->value.iec958.status, 24);\n\tsnd_ice1712_restore_gpio_status(ice);\n\treturn 0;\n}\n\n \nstatic int aureon_set_headphone_amp(struct snd_ice1712 *ice, int enable)\n{\n\tunsigned int tmp, tmp2;\n\n\ttmp2 = tmp = snd_ice1712_gpio_read(ice);\n\tif (enable)\n\t\tif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\n\t\t    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)\n\t\t\ttmp |= AUREON_HP_SEL;\n\t\telse\n\t\t\ttmp |= PRODIGY_HP_SEL;\n\telse\n\t\tif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\n\t\t    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)\n\t\t\ttmp &= ~AUREON_HP_SEL;\n\t\telse\n\t\t\ttmp &= ~PRODIGY_HP_SEL;\n\tif (tmp != tmp2) {\n\t\tsnd_ice1712_gpio_write(ice, tmp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int aureon_get_headphone_amp(struct snd_ice1712 *ice)\n{\n\tunsigned int tmp = snd_ice1712_gpio_read(ice);\n\n\treturn (tmp & AUREON_HP_SEL) != 0;\n}\n\n#define aureon_hpamp_info\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_hpamp_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = aureon_get_headphone_amp(ice);\n\treturn 0;\n}\n\n\nstatic int aureon_hpamp_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\treturn aureon_set_headphone_amp(ice, ucontrol->value.integer.value[0]);\n}\n\n \n\n#define aureon_deemp_info\tsnd_ctl_boolean_mono_info\n\nstatic int aureon_deemp_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL2) & 0xf) == 0xf;\n\treturn 0;\n}\n\nstatic int aureon_deemp_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tint temp, temp2;\n\ttemp2 = temp = wm_get(ice, WM_DAC_CTRL2);\n\tif (ucontrol->value.integer.value[0])\n\t\ttemp |= 0xf;\n\telse\n\t\ttemp &= ~0xf;\n\tif (temp != temp2) {\n\t\twm_put(ice, WM_DAC_CTRL2, temp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int aureon_oversampling_info(struct snd_kcontrol *k, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"128x\", \"64x\"\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int aureon_oversampling_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = (wm_get(ice, WM_MASTER) & 0x8) == 0x8;\n\treturn 0;\n}\n\nstatic int aureon_oversampling_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tint temp, temp2;\n\tstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\n\n\ttemp2 = temp = wm_get(ice, WM_MASTER);\n\n\tif (ucontrol->value.enumerated.item[0])\n\t\ttemp |= 0x8;\n\telse\n\t\ttemp &= ~0x8;\n\n\tif (temp != temp2) {\n\t\twm_put(ice, WM_MASTER, temp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct snd_kcontrol_new aureon_dac_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = wm_master_mute_info,\n\t\t.get = wm_master_mute_get,\n\t\t.put = wm_master_mute_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Master Playback Volume\",\n\t\t.info = wm_master_vol_info,\n\t\t.get = wm_master_vol_get,\n\t\t.put = wm_master_vol_put,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Front Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 0\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Front Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 0,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Rear Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 2\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Rear Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 2,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Center Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (1 << 8) | 4\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Center Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (1 << 8) | 4,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"LFE Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (1 << 8) | 5\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"LFE Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (1 << 8) | 5,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Side Playback Switch\",\n\t\t.info = wm_mute_info,\n\t\t.get = wm_mute_get,\n\t\t.put = wm_mute_put,\n\t\t.private_value = (2 << 8) | 6\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Side Playback Volume\",\n\t\t.info = wm_vol_info,\n\t\t.get = wm_vol_get,\n\t\t.put = wm_vol_put,\n\t\t.private_value = (2 << 8) | 6,\n\t\t.tlv = { .p = db_scale_wm_dac }\n\t}\n};\n\nstatic const struct snd_kcontrol_new wm_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Switch\",\n\t\t.info = wm_pcm_mute_info,\n\t\t.get = wm_pcm_mute_get,\n\t\t.put = wm_pcm_mute_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"PCM Playback Volume\",\n\t\t.info = wm_pcm_vol_info,\n\t\t.get = wm_pcm_vol_get,\n\t\t.put = wm_pcm_vol_put,\n\t\t.tlv = { .p = db_scale_wm_pcm }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Capture Switch\",\n\t\t.info = wm_adc_mute_info,\n\t\t.get = wm_adc_mute_get,\n\t\t.put = wm_adc_mute_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Capture Volume\",\n\t\t.info = wm_adc_vol_info,\n\t\t.get = wm_adc_vol_get,\n\t\t.put = wm_adc_vol_put,\n\t\t.tlv = { .p = db_scale_wm_adc }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Capture Source\",\n\t\t.info = wm_adc_mux_info,\n\t\t.get = wm_adc_mux_get,\n\t\t.put = wm_adc_mux_put,\n\t\t.private_value = 5\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"External Amplifier\",\n\t\t.info = aureon_hpamp_info,\n\t\t.get = aureon_hpamp_get,\n\t\t.put = aureon_hpamp_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"DAC Deemphasis Switch\",\n\t\t.info = aureon_deemp_info,\n\t\t.get = aureon_deemp_get,\n\t\t.put = aureon_deemp_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC Oversampling\",\n\t\t.info = aureon_oversampling_info,\n\t\t.get = aureon_oversampling_get,\n\t\t.put = aureon_oversampling_put\n\t}\n};\n\nstatic const struct snd_kcontrol_new ac97_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"AC97 Playback Switch\",\n\t\t.info = aureon_ac97_mmute_info,\n\t\t.get = aureon_ac97_mmute_get,\n\t\t.put = aureon_ac97_mmute_put,\n\t\t.private_value = AC97_MASTER\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"AC97 Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_MASTER|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_master }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"CD Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_CD\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"CD Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_CD|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Aux Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_AUX,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Aux Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_AUX|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_LINE\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Line Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_LINE|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_MIC\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Mic Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_MIC,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Boost (+20dB)\",\n\t\t.info = aureon_ac97_micboost_info,\n\t\t.get = aureon_ac97_micboost_get,\n\t\t.put = aureon_ac97_micboost_put\n\t}\n};\n\nstatic const struct snd_kcontrol_new universe_ac97_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"AC97 Playback Switch\",\n\t\t.info = aureon_ac97_mmute_info,\n\t\t.get = aureon_ac97_mmute_get,\n\t\t.put = aureon_ac97_mmute_put,\n\t\t.private_value = AC97_MASTER\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"AC97 Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_MASTER|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_master }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"CD Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_AUX\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"CD Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_AUX|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Phono Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_CD\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Phono Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_CD|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_LINE\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Line Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_LINE|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_MIC\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Mic Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_MIC,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Boost (+20dB)\",\n\t\t.info = aureon_ac97_micboost_info,\n\t\t.get = aureon_ac97_micboost_get,\n\t\t.put = aureon_ac97_micboost_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Aux Playback Switch\",\n\t\t.info = aureon_ac97_mute_info,\n\t\t.get = aureon_ac97_mute_get,\n\t\t.put = aureon_ac97_mute_put,\n\t\t.private_value = AC97_VIDEO,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t\t.name = \"Aux Playback Volume\",\n\t\t.info = aureon_ac97_vol_info,\n\t\t.get = aureon_ac97_vol_get,\n\t\t.put = aureon_ac97_vol_put,\n\t\t.private_value = AC97_VIDEO|AUREON_AC97_STEREO,\n\t\t.tlv = { .p = db_scale_ac97_gain }\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Aux Source\",\n\t\t.info = aureon_universe_inmux_info,\n\t\t.get = aureon_universe_inmux_get,\n\t\t.put = aureon_universe_inmux_put\n\t}\n\n};\n\nstatic const struct snd_kcontrol_new cs8415_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, SWITCH),\n\t\t.info = aureon_cs8415_mute_info,\n\t\t.get = aureon_cs8415_mute_get,\n\t\t.put = aureon_cs8415_mute_put\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Source\",\n\t\t.info = aureon_cs8415_mux_info,\n\t\t.get = aureon_cs8415_mux_get,\n\t\t.put = aureon_cs8415_mux_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"Q-subcode \", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = aureon_cs8415_qsub_info,\n\t\t.get = aureon_cs8415_qsub_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, MASK),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = aureon_cs8415_spdif_info,\n\t\t.get = aureon_cs8415_mask_get\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = aureon_cs8415_spdif_info,\n\t\t.get = aureon_cs8415_spdif_get\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Rate\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = aureon_cs8415_rate_info,\n\t\t.get = aureon_cs8415_rate_get\n\t}\n};\n\nstatic int aureon_add_controls(struct snd_ice1712 *ice)\n{\n\tunsigned int i, counts;\n\tint err;\n\n\tcounts = ARRAY_SIZE(aureon_dac_controls);\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY)\n\t\tcounts -= 2;  \n\tfor (i = 0; i < counts; i++) {\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&aureon_dac_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm_controls); i++) {\n\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&wm_controls[i], ice));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE) {\n\t\tfor (i = 0; i < ARRAY_SIZE(universe_ac97_controls); i++) {\n\t\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&universe_ac97_controls[i], ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\n\t\t ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ac97_controls); i++) {\n\t\t\terr = snd_ctl_add(ice->card, snd_ctl_new1(&ac97_controls[i], ice));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\n\t    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\n\t\tunsigned char id;\n\t\tsnd_ice1712_save_gpio_status(ice);\n\t\tid = aureon_cs8415_get(ice, CS8415_ID);\n\t\tsnd_ice1712_restore_gpio_status(ice);\n\t\tif (id != 0x41)\n\t\t\tdev_info(ice->card->dev,\n\t\t\t\t \"No CS8415 chip. Skipping CS8415 controls.\\n\");\n\t\telse {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(cs8415_controls); i++) {\n\t\t\t\tstruct snd_kcontrol *kctl;\n\t\t\t\tkctl = snd_ctl_new1(&cs8415_controls[i], ice);\n\t\t\t\tif (i > 1)\n\t\t\t\t\tkctl->id.device = ice->pcm->device;\n\t\t\t\terr = snd_ctl_add(ice->card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aureon_reset(struct snd_ice1712 *ice)\n{\n\tstatic const unsigned short wm_inits_aureon[] = {\n\t\t \n\t\t0x1b, 0x044,\t\t \n\t\t0x1c, 0x00B,\t\t \n\t\t0x1d, 0x009,\t\t \n\n\t\t0x18, 0x000,\t\t \n\n\t\t0x16, 0x122,\t\t \n\t\t0x17, 0x022,\t\t \n\t\t0x00, 0,\t\t \n\t\t0x01, 0,\t\t \n\t\t0x02, 0,\t\t \n\t\t0x03, 0,\t\t \n\t\t0x04, 0,\t\t \n\t\t0x05, 0,\t\t \n\t\t0x06, 0,\t\t \n\t\t0x07, 0,\t\t \n\t\t0x08, 0x100,\t\t \n\t\t0x09, 0xff,\t\t \n\t\t0x0a, 0xff,\t\t \n\t\t0x0b, 0xff,\t\t \n\t\t0x0c, 0xff,\t\t \n\t\t0x0d, 0xff,\t\t \n\t\t0x0e, 0xff,\t\t \n\t\t0x0f, 0xff,\t\t \n\t\t0x10, 0xff,\t\t \n\t\t0x11, 0x1ff,\t\t \n\t\t0x12, 0x000,\t\t \n\t\t0x13, 0x090,\t\t \n\t\t0x14, 0x000,\t\t \n\t\t0x15, 0x000,\t\t \n\t\t0x19, 0x000,\t\t \n\t\t0x1a, 0x000,\t\t \n\t\t(unsigned short)-1\n\t};\n\tstatic const unsigned short wm_inits_prodigy[] = {\n\n\t\t \n\t\t0x1b, 0x000,\t\t \n\t\t0x1c, 0x009,\t\t \n\t\t0x1d, 0x009,\t\t \n\n\t\t0x18, 0x000,\t\t \n\n\t\t0x16, 0x022,\t\t \n\t\t0x17, 0x006,\t\t \n\n\t\t0x00, 0,\t\t \n\t\t0x01, 0,\t\t \n\t\t0x02, 0,\t\t \n\t\t0x03, 0,\t\t \n\t\t0x04, 0,\t\t \n\t\t0x05, 0,\t\t \n\t\t0x06, 0,\t\t \n\t\t0x07, 0,\t\t \n\t\t0x08, 0x100,\t\t \n\n\t\t0x09, 0x7f,\t\t \n\t\t0x0a, 0x7f,\t\t \n\t\t0x0b, 0x7f,\t\t \n\t\t0x0c, 0x7f,\t\t \n\t\t0x0d, 0x7f,\t\t \n\t\t0x0e, 0x7f,\t\t \n\t\t0x0f, 0x7f,\t\t \n\t\t0x10, 0x7f,\t\t \n\t\t0x11, 0x1FF,\t\t \n\n\t\t0x12, 0x000,\t\t \n\t\t0x13, 0x090,\t\t \n\t\t0x14, 0x000,\t\t \n\t\t0x15, 0x000,\t\t \n\n\t\t0x19, 0x000,\t\t \n\t\t0x1a, 0x000,\t\t \n\t\t(unsigned short)-1\n\n\t};\n\tstatic const unsigned short cs_inits[] = {\n\t\t0x0441,  \n\t\t0x0180,  \n\t\t0x0201,  \n\t\t0x0605,  \n\t\t(unsigned short)-1\n\t};\n\tunsigned int tmp;\n\tconst unsigned short *p;\n\tint err;\n\tstruct aureon_spec *spec = ice->spec;\n\n\terr = aureon_ac97_init(ice);\n\tif (err != 0)\n\t\treturn err;\n\n\tsnd_ice1712_gpio_set_dir(ice, 0x5fffff);  \n\n\t \n\tsnd_ice1712_save_gpio_status(ice);\n\tsnd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RESET|AUREON_WM_CS|AUREON_CS8415_CS|AUREON_HP_SEL));\n\n\ttmp = snd_ice1712_gpio_read(ice);\n\ttmp &= ~AUREON_WM_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= AUREON_WM_CS | AUREON_CS8415_CS;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\ttmp |= AUREON_WM_RESET;\n\tsnd_ice1712_gpio_write(ice, tmp);\n\tudelay(1);\n\n\t \n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71 ||\n\t\tice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\n\t\tice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT)\n\t\tp = wm_inits_prodigy;\n\telse\n\t\tp = wm_inits_aureon;\n\tfor (; *p != (unsigned short)-1; p += 2)\n\t\twm_put(ice, p[0], p[1]);\n\n\t \n\tif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\n\t    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\n\t\tfor (p = cs_inits; *p != (unsigned short)-1; p++)\n\t\t\taureon_spi_write(ice, AUREON_CS8415_CS, *p | 0x200000, 24);\n\t\tspec->cs8415_mux = 1;\n\n\t\taureon_set_headphone_amp(ice, 1);\n\t}\n\n\tsnd_ice1712_restore_gpio_status(ice);\n\n\t \n\taureon_pca9554_write(ice, PCA9554_DIR, 0x00);\n\taureon_pca9554_write(ice, PCA9554_OUT, 0x00);    \n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic int aureon_resume(struct snd_ice1712 *ice)\n{\n\tstruct aureon_spec *spec = ice->spec;\n\tint err, i;\n\n\terr = aureon_reset(ice);\n\tif (err != 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < ice->num_total_dacs; i++)\n\t\twm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\n\treturn 0;\n}\n#endif\n\n \nstatic int aureon_init(struct snd_ice1712 *ice)\n{\n\tstruct aureon_spec *spec;\n\tint i, err;\n\n\tspec = kzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\tice->spec = spec;\n\n\tif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY) {\n\t\tice->num_total_dacs = 6;\n\t\tice->num_total_adcs = 2;\n\t} else {\n\t\t \n\t\tice->num_total_dacs = 8;\n\t\tice->num_total_adcs = 2;\n\t}\n\n\t \n\tice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\n\tif (!ice->akm)\n\t\treturn -ENOMEM;\n\tice->akm_codecs = 1;\n\n\terr = aureon_reset(ice);\n\tif (err != 0)\n\t\treturn err;\n\n\tspec->master[0] = WM_VOL_MUTE;\n\tspec->master[1] = WM_VOL_MUTE;\n\tfor (i = 0; i < ice->num_total_dacs; i++) {\n\t\tspec->vol[i] = WM_VOL_MUTE;\n\t\twm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\tice->pm_resume = aureon_resume;\n\tice->pm_suspend_enabled = 1;\n#endif\n\n\treturn 0;\n}\n\n\n \n\nstatic const unsigned char aureon51_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x0a,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xfc,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x5f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\nstatic const unsigned char aureon71_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x0b,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xfc,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x5f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n#define prodigy71_eeprom aureon71_eeprom\n\nstatic const unsigned char aureon71_universe_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x2b,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xfc,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x5f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n\nstatic const unsigned char prodigy71lt_eeprom[] = {\n\t[ICE_EEP2_SYSCONF]     = 0x4b,\t \n\t[ICE_EEP2_ACLINK]      = 0x80,\t \n\t[ICE_EEP2_I2S]         = 0xfc,\t \n\t[ICE_EEP2_SPDIF]       = 0xc3,\t \n\t[ICE_EEP2_GPIO_DIR]    = 0xff,\n\t[ICE_EEP2_GPIO_DIR1]   = 0xff,\n\t[ICE_EEP2_GPIO_DIR2]   = 0x5f,\n\t[ICE_EEP2_GPIO_MASK]   = 0x00,\n\t[ICE_EEP2_GPIO_MASK1]  = 0x00,\n\t[ICE_EEP2_GPIO_MASK2]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE]  = 0x00,\n\t[ICE_EEP2_GPIO_STATE1] = 0x00,\n\t[ICE_EEP2_GPIO_STATE2] = 0x00,\n};\n#define prodigy71xt_eeprom prodigy71lt_eeprom\n\n \nstruct snd_ice1712_card_info snd_vt1724_aureon_cards[] = {\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_AUREON51_SKY,\n\t\t.name = \"Terratec Aureon 5.1-Sky\",\n\t\t.model = \"aureon51\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(aureon51_eeprom),\n\t\t.eeprom_data = aureon51_eeprom,\n\t\t.driver = \"Aureon51\",\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_AUREON71_SPACE,\n\t\t.name = \"Terratec Aureon 7.1-Space\",\n\t\t.model = \"aureon71\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(aureon71_eeprom),\n\t\t.eeprom_data = aureon71_eeprom,\n\t\t.driver = \"Aureon71\",\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_AUREON71_UNIVERSE,\n\t\t.name = \"Terratec Aureon 7.1-Universe\",\n\t\t.model = \"universe\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(aureon71_universe_eeprom),\n\t\t.eeprom_data = aureon71_universe_eeprom,\n\t\t.driver = \"Aureon71Univ\",  \n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PRODIGY71,\n\t\t.name = \"Audiotrak Prodigy 7.1\",\n\t\t.model = \"prodigy71\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(prodigy71_eeprom),\n\t\t.eeprom_data = prodigy71_eeprom,\n\t\t.driver = \"Prodigy71\",  \n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PRODIGY71LT,\n\t\t.name = \"Audiotrak Prodigy 7.1 LT\",\n\t\t.model = \"prodigy71lt\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(prodigy71lt_eeprom),\n\t\t.eeprom_data = prodigy71lt_eeprom,\n\t\t.driver = \"Prodigy71LT\",\n\t},\n\t{\n\t\t.subvendor = VT1724_SUBDEVICE_PRODIGY71XT,\n\t\t.name = \"Audiotrak Prodigy 7.1 XT\",\n\t\t.model = \"prodigy71xt\",\n\t\t.chip_init = aureon_init,\n\t\t.build_controls = aureon_add_controls,\n\t\t.eeprom_size = sizeof(prodigy71xt_eeprom),\n\t\t.eeprom_data = prodigy71xt_eeprom,\n\t\t.driver = \"Prodigy71LT\",\n\t},\n\t{ }  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}