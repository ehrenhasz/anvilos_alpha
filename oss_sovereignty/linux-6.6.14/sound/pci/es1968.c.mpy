{
  "module_name": "es1968.c",
  "hash_id": "3143b38f3903ed12857f472c2cc8b6bdd5b1c1d4e619ab1e5696dc25069167aa",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/es1968.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/input.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/mpu401.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n\n#ifdef CONFIG_SND_ES1968_RADIO\n#include <media/drv-intf/tea575x.h>\n#endif\n\n#define CARD_NAME \"ESS Maestro1/2\"\n#define DRIVER_NAME \"ES1968\"\n\nMODULE_DESCRIPTION(\"ESS Maestro\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic int total_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1024 };\nstatic int pcm_substreams_p[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4 };\nstatic int pcm_substreams_c[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1 };\nstatic int clock[SNDRV_CARDS];\nstatic int use_pm[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};\nstatic int enable_mpu[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};\n#ifdef SUPPORT_JOYSTICK\nstatic bool joystick[SNDRV_CARDS];\n#endif\nstatic int radio_nr[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\nmodule_param_array(total_bufsize, int, NULL, 0444);\nMODULE_PARM_DESC(total_bufsize, \"Total buffer size in kB.\");\nmodule_param_array(pcm_substreams_p, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_substreams_p, \"PCM Playback substreams for \" CARD_NAME \" soundcard.\");\nmodule_param_array(pcm_substreams_c, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_substreams_c, \"PCM Capture substreams for \" CARD_NAME \" soundcard.\");\nmodule_param_array(clock, int, NULL, 0444);\nMODULE_PARM_DESC(clock, \"Clock on \" CARD_NAME \" soundcard.  (0 = auto-detect)\");\nmodule_param_array(use_pm, int, NULL, 0444);\nMODULE_PARM_DESC(use_pm, \"Toggle power-management.  (0 = off, 1 = on, 2 = auto)\");\nmodule_param_array(enable_mpu, int, NULL, 0444);\nMODULE_PARM_DESC(enable_mpu, \"Enable MPU401.  (0 = off, 1 = on, 2 = auto)\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_array(joystick, bool, NULL, 0444);\nMODULE_PARM_DESC(joystick, \"Enable joystick.\");\n#endif\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\n\n\n#define NR_APUS\t\t\t64\n#define NR_APU_REGS\t\t16\n\n \n#define NEC_VERSA_SUBID1\t0x80581033\n#define NEC_VERSA_SUBID2\t0x803c1033\n\n \n#define ESS_FMT_STEREO     \t0x01\n#define ESS_FMT_16BIT      \t0x02\n\n#define DAC_RUNNING\t\t1\n#define ADC_RUNNING\t\t2\n\n \n\n#define ESS_DISABLE_AUDIO\t0x8000\n#define ESS_ENABLE_SERIAL_IRQ\t0x4000\n#define IO_ADRESS_ALIAS\t\t0x0020\n#define MPU401_IRQ_ENABLE\t0x0010\n#define MPU401_IO_ENABLE\t0x0008\n#define GAME_IO_ENABLE\t\t0x0004\n#define FM_IO_ENABLE\t\t0x0002\n#define SB_IO_ENABLE\t\t0x0001\n\n \n\n#define PIC_SNOOP1\t\t0x4000\n#define PIC_SNOOP2\t\t0x2000\n#define SAFEGUARD\t\t0x0800\n#define DMA_CLEAR\t\t0x0700\n#define DMA_DDMA\t\t0x0000\n#define DMA_TDMA\t\t0x0100\n#define DMA_PCPCI\t\t0x0200\n#define POST_WRITE\t\t0x0080\n#define PCI_TIMING\t\t0x0040\n#define SWAP_LR\t\t\t0x0020\n#define SUBTR_DECODE\t\t0x0002\n\n \n\n#define SPDIF_CONFB\t\t0x0100\n#define HWV_CONFB\t\t0x0080\n#define DEBOUNCE\t\t0x0040\n#define GPIO_CONFB\t\t0x0020\n#define CHI_CONFB\t\t0x0010\n#define IDMA_CONFB\t\t0x0008\t \n#define MIDI_FIX\t\t0x0004\t \n#define IRQ_TO_ISA\t\t0x0001\t \n\n \n#define\tRINGB_2CODEC_ID_MASK\t0x0003\n#define RINGB_DIS_VALIDATION\t0x0008\n#define RINGB_EN_SPDIF\t\t0x0010\n#define\tRINGB_EN_2CODEC\t\t0x0020\n#define RINGB_SING_BIT_DUAL\t0x0040\n\n \n\n \n#define ESM_INDEX\t\t0x02\n#define ESM_DATA\t\t0x00\n\n \n#define ESM_AC97_INDEX\t\t0x30\n#define\tESM_AC97_DATA\t\t0x32\n#define ESM_RING_BUS_DEST\t0x34\n#define ESM_RING_BUS_CONTR_A\t0x36\n#define ESM_RING_BUS_CONTR_B\t0x38\n#define ESM_RING_BUS_SDO\t0x3A\n\n \n#define WC_INDEX\t\t0x10\n#define WC_DATA\t\t\t0x12\n#define WC_CONTROL\t\t0x14\n\n \n#define ASSP_INDEX\t\t0x80\n#define ASSP_MEMORY\t\t0x82\n#define ASSP_DATA\t\t0x84\n#define ASSP_CONTROL_A\t\t0xA2\n#define ASSP_CONTROL_B\t\t0xA4\n#define ASSP_CONTROL_C\t\t0xA6\n#define ASSP_HOSTW_INDEX\t0xA8\n#define ASSP_HOSTW_DATA\t\t0xAA\n#define ASSP_HOSTW_IRQ\t\t0xAC\n \n#define ESM_MPU401_PORT\t\t0x98\n \n#define ESM_PORT_HOST_IRQ\t0x18\n\n#define IDR0_DATA_PORT\t\t0x00\n#define IDR1_CRAM_POINTER\t0x01\n#define IDR2_CRAM_DATA\t\t0x02\n#define IDR3_WAVE_DATA\t\t0x03\n#define IDR4_WAVE_PTR_LOW\t0x04\n#define IDR5_WAVE_PTR_HI\t0x05\n#define IDR6_TIMER_CTRL\t\t0x06\n#define IDR7_WAVE_ROMRAM\t0x07\n\n#define WRITEABLE_MAP\t\t0xEFFFFF\n#define READABLE_MAP\t\t0x64003F\n\n \n\n#define ESM_LEGACY_AUDIO_CONTROL 0x40\n#define ESM_ACPI_COMMAND\t0x54\n#define ESM_CONFIG_A\t\t0x50\n#define ESM_CONFIG_B\t\t0x52\n#define ESM_DDMA\t\t0x60\n\n \n#define ESM_BOB_ENABLE\t\t0x0001\n#define ESM_BOB_START\t\t0x0001\n\n \n#define ESM_RESET_MAESTRO\t0x8000\n#define ESM_RESET_DIRECTSOUND   0x4000\n#define ESM_HIRQ_ClkRun\t\t0x0100\n#define ESM_HIRQ_HW_VOLUME\t0x0040\n#define ESM_HIRQ_HARPO\t\t0x0030\t \n#define ESM_HIRQ_ASSP\t\t0x0010\n#define\tESM_HIRQ_DSIE\t\t0x0004\n#define ESM_HIRQ_MPU401\t\t0x0002\n#define ESM_HIRQ_SB\t\t0x0001\n\n \n#define ESM_MPU401_IRQ\t\t0x02\n#define ESM_SB_IRQ\t\t0x01\n#define ESM_SOUND_IRQ\t\t0x04\n#define\tESM_ASSP_IRQ\t\t0x10\n#define ESM_HWVOL_IRQ\t\t0x40\n\n#define ESS_SYSCLK\t\t50000000\n#define ESM_BOB_FREQ \t\t200\n#define ESM_BOB_FREQ_MAX\t800\n\n#define ESM_FREQ_ESM1  \t\t(49152000L / 1024L)\t \n#define ESM_FREQ_ESM2  \t\t(50000000L / 1024L)\n\n \n#define ESM_APU_MODE_SHIFT\t4\n#define ESM_APU_MODE_MASK\t(0xf << 4)\n#define\tESM_APU_OFF\t\t0x00\n#define\tESM_APU_16BITLINEAR\t0x01\t \n#define\tESM_APU_16BITSTEREO\t0x02\t \n#define\tESM_APU_8BITLINEAR\t0x03\t \n#define\tESM_APU_8BITSTEREO\t0x04\t \n#define\tESM_APU_8BITDIFF\t0x05\t \n#define\tESM_APU_DIGITALDELAY\t0x06\t \n#define\tESM_APU_DUALTAP\t\t0x07\t \n#define\tESM_APU_CORRELATOR\t0x08\t \n#define\tESM_APU_INPUTMIXER\t0x09\t \n#define\tESM_APU_WAVETABLE\t0x0A\t \n#define\tESM_APU_SRCONVERTOR\t0x0B\t \n#define\tESM_APU_16BITPINGPONG\t0x0C\t \n#define\tESM_APU_RESERVED1\t0x0D\t \n#define\tESM_APU_RESERVED2\t0x0E\t \n#define\tESM_APU_RESERVED3\t0x0F\t \n\n \n#define ESM_APU_FILTER_Q_SHIFT\t\t0\n#define ESM_APU_FILTER_Q_MASK\t\t(3 << 0)\n \n#define ESM_APU_FILTER_LESSQ\t0x00\n#define ESM_APU_FILTER_MOREQ\t0x03\n\n#define ESM_APU_FILTER_TYPE_SHIFT\t2\n#define ESM_APU_FILTER_TYPE_MASK\t(3 << 2)\n#define ESM_APU_ENV_TYPE_SHIFT\t\t8\n#define ESM_APU_ENV_TYPE_MASK\t\t(3 << 8)\n#define ESM_APU_ENV_STATE_SHIFT\t\t10\n#define ESM_APU_ENV_STATE_MASK\t\t(3 << 10)\n#define ESM_APU_END_CURVE\t\t(1 << 12)\n#define ESM_APU_INT_ON_LOOP\t\t(1 << 13)\n#define ESM_APU_DMA_ENABLE\t\t(1 << 14)\n\n \n#define ESM_APU_SUBMIX_GROUP_SHIRT\t0\n#define ESM_APU_SUBMIX_GROUP_MASK\t(7 << 0)\n#define ESM_APU_SUBMIX_MODE\t\t(1 << 3)\n#define ESM_APU_6dB\t\t\t(1 << 4)\n#define ESM_APU_DUAL_EFFECT\t\t(1 << 5)\n#define ESM_APU_EFFECT_CHANNELS_SHIFT\t6\n#define ESM_APU_EFFECT_CHANNELS_MASK\t(3 << 6)\n\n \n#define ESM_APU_STEP_SIZE_MASK\t\t0x0fff\n\n \n#define ESM_APU_PHASE_SHIFT\t\t0\n#define ESM_APU_PHASE_MASK\t\t(0xff << 0)\n#define ESM_APU_WAVE64K_PAGE_SHIFT\t8\t \n#define ESM_APU_WAVE64K_PAGE_MASK\t(0xff << 8)\n\n \n \n \n\n \n#define ESM_APU_EFFECT_GAIN_SHIFT\t0\n#define ESM_APU_EFFECT_GAIN_MASK\t(0xff << 0)\n#define ESM_APU_TREMOLO_DEPTH_SHIFT\t8\n#define ESM_APU_TREMOLO_DEPTH_MASK\t(0xf << 8)\n#define ESM_APU_TREMOLO_RATE_SHIFT\t12\n#define ESM_APU_TREMOLO_RATE_MASK\t(0xf << 12)\n\n \n \n#define ESM_APU_AMPLITUDE_NOW_SHIFT\t8\n#define ESM_APU_AMPLITUDE_NOW_MASK\t(0xff << 8)\n\n \n#define ESM_APU_POLAR_PAN_SHIFT\t\t0\n#define ESM_APU_POLAR_PAN_MASK\t\t(0x3f << 0)\n \n#define\tESM_APU_PAN_CENTER_CIRCLE\t\t0x00\n#define\tESM_APU_PAN_MIDDLE_RADIUS\t\t0x01\n#define\tESM_APU_PAN_OUTSIDE_RADIUS\t\t0x02\n\n#define ESM_APU_FILTER_TUNING_SHIFT\t8\n#define ESM_APU_FILTER_TUNING_MASK\t(0xff << 8)\n\n \n#define ESM_APU_DATA_SRC_A_SHIFT\t0\n#define ESM_APU_DATA_SRC_A_MASK\t\t(0x7f << 0)\n#define ESM_APU_INV_POL_A\t\t(1 << 7)\n#define ESM_APU_DATA_SRC_B_SHIFT\t8\n#define ESM_APU_DATA_SRC_B_MASK\t\t(0x7f << 8)\n#define ESM_APU_INV_POL_B\t\t(1 << 15)\n\n#define ESM_APU_VIBRATO_RATE_SHIFT\t0\n#define ESM_APU_VIBRATO_RATE_MASK\t(0xf << 0)\n#define ESM_APU_VIBRATO_DEPTH_SHIFT\t4\n#define ESM_APU_VIBRATO_DEPTH_MASK\t(0xf << 4)\n#define ESM_APU_VIBRATO_PHASE_SHIFT\t8\n#define ESM_APU_VIBRATO_PHASE_MASK\t(0xff << 8)\n\n \n#define ESM_APU_RADIUS_SELECT\t\t(1 << 6)\n\n \n#define\tESM_APU_FILTER_2POLE_LOPASS\t0x00\n#define\tESM_APU_FILTER_2POLE_BANDPASS\t0x01\n#define\tESM_APU_FILTER_2POLE_HIPASS\t0x02\n#define\tESM_APU_FILTER_1POLE_LOPASS\t0x03\n#define\tESM_APU_FILTER_1POLE_HIPASS\t0x04\n#define\tESM_APU_FILTER_OFF\t\t0x05\n\n \n#define\tESM_APU_ATFP_AMPLITUDE\t\t\t0x00\n#define\tESM_APU_ATFP_TREMELO\t\t\t0x01\n#define\tESM_APU_ATFP_FILTER\t\t\t0x02\n#define\tESM_APU_ATFP_PAN\t\t\t0x03\n\n \n#define\tESM_APU_ATFP_FLG_OFF\t\t\t0x00\n#define\tESM_APU_ATFP_FLG_WAIT\t\t\t0x01\n#define\tESM_APU_ATFP_FLG_DONE\t\t\t0x02\n#define\tESM_APU_ATFP_FLG_INPROCESS\t\t0x03\n\n\n \n#define ESM_MEM_ALIGN\t\t0x1000\n#define ESM_MIXBUF_SIZE\t\t0x400\n\n#define ESM_MODE_PLAY\t\t0\n#define ESM_MODE_CAPTURE\t1\n\n\n \nenum snd_enum_apu_type {\n\tESM_APU_PCM_PLAY,\n\tESM_APU_PCM_CAPTURE,\n\tESM_APU_PCM_RATECONV,\n\tESM_APU_FREE\n};\n\n \nenum {\n\tTYPE_MAESTRO, TYPE_MAESTRO2, TYPE_MAESTRO2E\n};\n\n \nstruct esm_memory {\n\tstruct snd_dma_buffer buf;\n\tint empty;\t \n\tstruct list_head list;\n};\n\n \nstruct esschan {\n\tint running;\n\n\tu8 apu[4];\n\tu8 apu_mode[4];\n\n\t \n\tstruct esm_memory *memory;\n\t \n\tstruct esm_memory *mixbuf;\n\n\tunsigned int hwptr;\t \n\tunsigned int count;\t \n\tunsigned int dma_size;\t \n\tunsigned int frag_size;\t \n\tunsigned int wav_shift;\n\tu16 base[4];\t\t \n\n\t \n\tunsigned char fmt;\n\tint mode;\t \n\n\tint bob_freq;\t \n\n\tstruct snd_pcm_substream *substream;\n\n\t \n\tstruct list_head list;\n\n#ifdef CONFIG_PM_SLEEP\n\tu16 wc_map[4];\n#endif\n};\n\nstruct es1968 {\n\t \n\tint total_bufsize;\t\t\t \n\n\tint playback_streams, capture_streams;\n\n\tunsigned int clock;\t\t \n\t \n\tunsigned int in_measurement: 1;\n\tunsigned int measure_apu;\n\tunsigned int measure_lastpos;\n\tunsigned int measure_count;\n\n\t \n\tstruct snd_dma_buffer dma;\n\n\t \n\tint irq;\n\tunsigned long io_port;\n\tint type;\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tint do_pm;\t\t \n\n\t \n\tstruct list_head buf_list;\n\n\t \n\tstruct snd_ac97 *ac97;\n\tstruct snd_rawmidi *rmidi;\n\n\tspinlock_t reg_lock;\n\tunsigned int in_suspend;\n\n\t \n\tu16 maestro_map[32];\n\tint bobclient;\t\t \n\tint bob_freq;\t\t \n\tstruct mutex memory_mutex;\t \n\n\t \n\tunsigned char apu[NR_APUS];\n\n\t \n\tstruct list_head substream_list;\n\tspinlock_t substream_lock;\n\n#ifdef CONFIG_PM_SLEEP\n\tu16 apu_map[NR_APUS][NR_APU_REGS];\n#endif\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n\n#ifdef CONFIG_SND_ES1968_INPUT\n\tstruct input_dev *input_dev;\n\tchar phys[64];\t\t\t \n#else\n\tstruct snd_kcontrol *master_switch;  \n\tstruct snd_kcontrol *master_volume;\n#endif\n\tstruct work_struct hwvol_work;\n\n#ifdef CONFIG_SND_ES1968_RADIO\n\tstruct v4l2_device v4l2_dev;\n\tstruct snd_tea575x tea;\n\tunsigned int tea575x_tuner;\n#endif\n};\n\nstatic irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);\n\nstatic const struct pci_device_id snd_es1968_ids[] = {\n\t \n        { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },\n\t \n\t{ 0x125d, 0x1968, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO2 },\n\t \n        { 0x125d, 0x1978, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO2E },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_es1968_ids);\n\n \n\n \nstatic void __maestro_write(struct es1968 *chip, u16 reg, u16 data)\n{\n\toutw(reg, chip->io_port + ESM_INDEX);\n\toutw(data, chip->io_port + ESM_DATA);\n\tchip->maestro_map[reg] = data;\n}\n\nstatic inline void maestro_write(struct es1968 *chip, u16 reg, u16 data)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t__maestro_write(chip, reg, data);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\n \nstatic u16 __maestro_read(struct es1968 *chip, u16 reg)\n{\n\tif (READABLE_MAP & (1 << reg)) {\n\t\toutw(reg, chip->io_port + ESM_INDEX);\n\t\tchip->maestro_map[reg] = inw(chip->io_port + ESM_DATA);\n\t}\n\treturn chip->maestro_map[reg];\n}\n\nstatic inline u16 maestro_read(struct es1968 *chip, u16 reg)\n{\n\tunsigned long flags;\n\tu16 result;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tresult = __maestro_read(chip, reg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn result;\n}\n\n \nstatic int snd_es1968_ac97_wait(struct es1968 *chip)\n{\n\tint timeout = 100000;\n\n\twhile (timeout-- > 0) {\n\t\tif (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))\n\t\t\treturn 0;\n\t\tcond_resched();\n\t}\n\tdev_dbg(chip->card->dev, \"ac97 timeout\\n\");\n\treturn 1;  \n}\n\nstatic int snd_es1968_ac97_wait_poll(struct es1968 *chip)\n{\n\tint timeout = 100000;\n\n\twhile (timeout-- > 0) {\n\t\tif (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))\n\t\t\treturn 0;\n\t}\n\tdev_dbg(chip->card->dev, \"ac97 timeout\\n\");\n\treturn 1;  \n}\n\nstatic void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\n{\n\tstruct es1968 *chip = ac97->private_data;\n\n\tsnd_es1968_ac97_wait(chip);\n\n\t \n\toutw(val, chip->io_port + ESM_AC97_DATA);\n\t \n\toutb(reg, chip->io_port + ESM_AC97_INDEX);\n\t \n}\n\nstatic unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tu16 data = 0;\n\tstruct es1968 *chip = ac97->private_data;\n\n\tsnd_es1968_ac97_wait(chip);\n\n\toutb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);\n\t \n\n\tif (!snd_es1968_ac97_wait_poll(chip)) {\n\t\tdata = inw(chip->io_port + ESM_AC97_DATA);\n\t\t \n\t}\n\n\treturn data;\n}\n\n \nstatic void apu_index_set(struct es1968 *chip, u16 index)\n{\n\tint i;\n\t__maestro_write(chip, IDR1_CRAM_POINTER, index);\n\tfor (i = 0; i < 1000; i++)\n\t\tif (__maestro_read(chip, IDR1_CRAM_POINTER) == index)\n\t\t\treturn;\n\tdev_dbg(chip->card->dev, \"APU register select failed. (Timeout)\\n\");\n}\n\n \nstatic void apu_data_set(struct es1968 *chip, u16 data)\n{\n\tint i;\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (__maestro_read(chip, IDR0_DATA_PORT) == data)\n\t\t\treturn;\n\t\t__maestro_write(chip, IDR0_DATA_PORT, data);\n\t}\n\tdev_dbg(chip->card->dev, \"APU register set probably failed (Timeout)!\\n\");\n}\n\n \nstatic void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)\n{\n\tif (snd_BUG_ON(channel >= NR_APUS))\n\t\treturn;\n#ifdef CONFIG_PM_SLEEP\n\tchip->apu_map[channel][reg] = data;\n#endif\n\treg |= (channel << 4);\n\tapu_index_set(chip, reg);\n\tapu_data_set(chip, data);\n}\n\nstatic void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t__apu_set_register(chip, channel, reg, data);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic u16 __apu_get_register(struct es1968 *chip, u16 channel, u8 reg)\n{\n\tif (snd_BUG_ON(channel >= NR_APUS))\n\t\treturn 0;\n\treg |= (channel << 4);\n\tapu_index_set(chip, reg);\n\treturn __maestro_read(chip, IDR0_DATA_PORT);\n}\n\nstatic u16 apu_get_register(struct es1968 *chip, u16 channel, u8 reg)\n{\n\tunsigned long flags;\n\tu16 v;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tv = __apu_get_register(chip, channel, reg);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn v;\n}\n\n#if 0  \n\nstatic void assp_set_register(struct es1968 *chip, u32 reg, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toutl(reg, chip->io_port + ASSP_INDEX);\n\toutl(value, chip->io_port + ASSP_DATA);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic u32 assp_get_register(struct es1968 *chip, u32 reg)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toutl(reg, chip->io_port + ASSP_INDEX);\n\tvalue = inl(chip->io_port + ASSP_DATA);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn value;\n}\n\n#endif\n\nstatic void wave_set_register(struct es1968 *chip, u16 reg, u16 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toutw(reg, chip->io_port + WC_INDEX);\n\toutw(value, chip->io_port + WC_DATA);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic u16 wave_get_register(struct es1968 *chip, u16 reg)\n{\n\tunsigned long flags;\n\tu16 value;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\toutw(reg, chip->io_port + WC_INDEX);\n\tvalue = inw(chip->io_port + WC_DATA);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn value;\n}\n\n \n\nstatic void snd_es1968_bob_stop(struct es1968 *chip)\n{\n\tu16 reg;\n\n\treg = __maestro_read(chip, 0x11);\n\treg &= ~ESM_BOB_ENABLE;\n\t__maestro_write(chip, 0x11, reg);\n\treg = __maestro_read(chip, 0x17);\n\treg &= ~ESM_BOB_START;\n\t__maestro_write(chip, 0x17, reg);\n}\n\nstatic void snd_es1968_bob_start(struct es1968 *chip)\n{\n\tint prescale;\n\tint divide;\n\n\t \n\t \n\tfor (prescale = 5; prescale < 12; prescale++)\n\t\tif (chip->bob_freq > (ESS_SYSCLK >> (prescale + 9)))\n\t\t\tbreak;\n\n\t \n\tdivide = 1;\n\twhile ((prescale > 5) && (divide < 32)) {\n\t\tprescale--;\n\t\tdivide <<= 1;\n\t}\n\tdivide >>= 1;\n\n\t \n\tfor (; divide < 31; divide++)\n\t\tif (chip->bob_freq >\n\t\t    ((ESS_SYSCLK >> (prescale + 9)) / (divide + 1))) break;\n\n\t \n\tif (divide == 0) {\n\t\tdivide++;\n\t\tif (prescale > 5)\n\t\t\tprescale--;\n\t} else if (divide > 1)\n\t\tdivide--;\n\n\t__maestro_write(chip, 6, 0x9000 | (prescale << 5) | divide);\t \n\n\t \n\t__maestro_write(chip, 0x11, __maestro_read(chip, 0x11) | 1);\n\t__maestro_write(chip, 0x17, __maestro_read(chip, 0x17) | 1);\n}\n\n \nstatic void snd_es1968_bob_inc(struct es1968 *chip, int freq)\n{\n\tchip->bobclient++;\n\tif (chip->bobclient == 1) {\n\t\tchip->bob_freq = freq;\n\t\tsnd_es1968_bob_start(chip);\n\t} else if (chip->bob_freq < freq) {\n\t\tsnd_es1968_bob_stop(chip);\n\t\tchip->bob_freq = freq;\n\t\tsnd_es1968_bob_start(chip);\n\t}\n}\n\n \nstatic void snd_es1968_bob_dec(struct es1968 *chip)\n{\n\tchip->bobclient--;\n\tif (chip->bobclient <= 0)\n\t\tsnd_es1968_bob_stop(chip);\n\telse if (chip->bob_freq > ESM_BOB_FREQ) {\n\t\t \n\t\tint max_freq = ESM_BOB_FREQ;\n\t\tstruct esschan *es;\n\t\tlist_for_each_entry(es, &chip->substream_list, list) {\n\t\t\tif (max_freq < es->bob_freq)\n\t\t\t\tmax_freq = es->bob_freq;\n\t\t}\n\t\tif (max_freq != chip->bob_freq) {\n\t\t\tsnd_es1968_bob_stop(chip);\n\t\t\tchip->bob_freq = max_freq;\n\t\t\tsnd_es1968_bob_start(chip);\n\t\t}\n\t}\n}\n\nstatic int\nsnd_es1968_calc_bob_rate(struct es1968 *chip, struct esschan *es,\n\t\t\t struct snd_pcm_runtime *runtime)\n{\n\t \n\tint freq = runtime->rate * 4;\n\tif (es->fmt & ESS_FMT_STEREO)\n\t\tfreq <<= 1;\n\tif (es->fmt & ESS_FMT_16BIT)\n\t\tfreq <<= 1;\n\tfreq /= es->frag_size;\n\tif (freq < ESM_BOB_FREQ)\n\t\tfreq = ESM_BOB_FREQ;\n\telse if (freq > ESM_BOB_FREQ_MAX)\n\t\tfreq = ESM_BOB_FREQ_MAX;\n\treturn freq;\n}\n\n\n \n\nstatic u32 snd_es1968_compute_rate(struct es1968 *chip, u32 freq)\n{\n\tu32 rate = (freq << 16) / chip->clock;\n#if 0   \n\tif (rate > 0x10000)\n\t\trate = 0x10000;\n#endif\n\treturn rate;\n}\n\n \nstatic inline unsigned int\nsnd_es1968_get_dma_ptr(struct es1968 *chip, struct esschan *es)\n{\n\tunsigned int offset;\n\n\toffset = apu_get_register(chip, es->apu[0], 5);\n\n\toffset -= es->base[0];\n\n\treturn (offset & 0xFFFE);\t \n}\n\nstatic void snd_es1968_apu_set_freq(struct es1968 *chip, int apu, int freq)\n{\n\tapu_set_register(chip, apu, 2,\n\t\t\t   (apu_get_register(chip, apu, 2) & 0x00FF) |\n\t\t\t   ((freq & 0xff) << 8) | 0x10);\n\tapu_set_register(chip, apu, 3, freq >> 8);\n}\n\n \nstatic inline void snd_es1968_trigger_apu(struct es1968 *esm, int apu, int mode)\n{\n\t \n\t__apu_set_register(esm, apu, 0,\n\t\t\t   (__apu_get_register(esm, apu, 0) & 0xff0f) |\n\t\t\t   (mode << 4));\n}\n\nstatic void snd_es1968_pcm_start(struct es1968 *chip, struct esschan *es)\n{\n\tspin_lock(&chip->reg_lock);\n\t__apu_set_register(chip, es->apu[0], 5, es->base[0]);\n\tsnd_es1968_trigger_apu(chip, es->apu[0], es->apu_mode[0]);\n\tif (es->mode == ESM_MODE_CAPTURE) {\n\t\t__apu_set_register(chip, es->apu[2], 5, es->base[2]);\n\t\tsnd_es1968_trigger_apu(chip, es->apu[2], es->apu_mode[2]);\n\t}\n\tif (es->fmt & ESS_FMT_STEREO) {\n\t\t__apu_set_register(chip, es->apu[1], 5, es->base[1]);\n\t\tsnd_es1968_trigger_apu(chip, es->apu[1], es->apu_mode[1]);\n\t\tif (es->mode == ESM_MODE_CAPTURE) {\n\t\t\t__apu_set_register(chip, es->apu[3], 5, es->base[3]);\n\t\t\tsnd_es1968_trigger_apu(chip, es->apu[3], es->apu_mode[3]);\n\t\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n}\n\nstatic void snd_es1968_pcm_stop(struct es1968 *chip, struct esschan *es)\n{\n\tspin_lock(&chip->reg_lock);\n\tsnd_es1968_trigger_apu(chip, es->apu[0], 0);\n\tsnd_es1968_trigger_apu(chip, es->apu[1], 0);\n\tif (es->mode == ESM_MODE_CAPTURE) {\n\t\tsnd_es1968_trigger_apu(chip, es->apu[2], 0);\n\t\tsnd_es1968_trigger_apu(chip, es->apu[3], 0);\n\t}\n\tspin_unlock(&chip->reg_lock);\n}\n\n \nstatic void snd_es1968_program_wavecache(struct es1968 *chip, struct esschan *es,\n\t\t\t\t\t int channel, u32 addr, int capture)\n{\n\tu32 tmpval = (addr - 0x10) & 0xFFF8;\n\n\tif (! capture) {\n\t\tif (!(es->fmt & ESS_FMT_16BIT))\n\t\t\ttmpval |= 4;\t \n\t\tif (es->fmt & ESS_FMT_STEREO)\n\t\t\ttmpval |= 2;\t \n\t}\n\n\t \n\twave_set_register(chip, es->apu[channel] << 3, tmpval);\n\n#ifdef CONFIG_PM_SLEEP\n\tes->wc_map[channel] = tmpval;\n#endif\n}\n\n\nstatic void snd_es1968_playback_setup(struct es1968 *chip, struct esschan *es,\n\t\t\t\t      struct snd_pcm_runtime *runtime)\n{\n\tu32 pa;\n\tint high_apu = 0;\n\tint channel, apu;\n\tint i, size;\n\tunsigned long flags;\n\tu32 freq;\n\n\tsize = es->dma_size >> es->wav_shift;\n\n\tif (es->fmt & ESS_FMT_STEREO)\n\t\thigh_apu++;\n\n\tfor (channel = 0; channel <= high_apu; channel++) {\n\t\tapu = es->apu[channel];\n\n\t\tsnd_es1968_program_wavecache(chip, es, channel, es->memory->buf.addr, 0);\n\n\t\t \n\t\tpa = es->memory->buf.addr;\n\t\tpa -= chip->dma.addr;\n\t\tpa >>= 1;\t \n\n\t\tpa |= 0x00400000;\t \n\n\t\tif (es->fmt & ESS_FMT_STEREO) {\n\t\t\t \n\t\t\tif (channel)\n\t\t\t\tpa |= 0x00800000;\t \n\t\t\tif (es->fmt & ESS_FMT_16BIT)\n\t\t\t\tpa >>= 1;\n\t\t}\n\n\t\t \n\t\tes->base[channel] = pa & 0xFFFF;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tapu_set_register(chip, apu, i, 0x0000);\n\n\t\t \n\t\tapu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);\n\t\tapu_set_register(chip, apu, 5, pa & 0xFFFF);\n\t\tapu_set_register(chip, apu, 6, (pa + size) & 0xFFFF);\n\t\t \n\t\tapu_set_register(chip, apu, 7, size);\n\n\t\t \n\t\tapu_set_register(chip, apu, 8, 0x0000);\n\t\t \n\t\tapu_set_register(chip, apu, 9, 0xD000);\n\n\t\t \n\t\tapu_set_register(chip, apu, 11, 0x0000);\n\t\t \n\t\tapu_set_register(chip, apu, 0, 0x400F);\n\n\t\tif (es->fmt & ESS_FMT_16BIT)\n\t\t\tes->apu_mode[channel] = ESM_APU_16BITLINEAR;\n\t\telse\n\t\t\tes->apu_mode[channel] = ESM_APU_8BITLINEAR;\n\n\t\tif (es->fmt & ESS_FMT_STEREO) {\n\t\t\t \n\t\t\t \n\t\t\tapu_set_register(chip, apu, 10,\n\t\t\t\t\t 0x8F00 | (channel ? 0 : 0x10));\n\t\t\tes->apu_mode[channel] += 1;\t \n\t\t} else\n\t\t\tapu_set_register(chip, apu, 10, 0x8F08);\n\t}\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t \n\toutw(1, chip->io_port + 0x04);\n\t \n\toutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tfreq = runtime->rate;\n\t \n\tif (freq > 48000)\n\t\tfreq = 48000;\n\tif (freq < 4000)\n\t\tfreq = 4000;\n\n\t \n\tif (!(es->fmt & ESS_FMT_16BIT) && !(es->fmt & ESS_FMT_STEREO))\n\t\tfreq >>= 1;\n\n\tfreq = snd_es1968_compute_rate(chip, freq);\n\n\t \n\tsnd_es1968_apu_set_freq(chip, es->apu[0], freq);\n\tsnd_es1968_apu_set_freq(chip, es->apu[1], freq);\n}\n\n\nstatic void init_capture_apu(struct es1968 *chip, struct esschan *es, int channel,\n\t\t\t     unsigned int pa, unsigned int bsize,\n\t\t\t     int mode, int route)\n{\n\tint i, apu = es->apu[channel];\n\n\tes->apu_mode[channel] = mode;\n\n\t \n\tsnd_es1968_program_wavecache(chip, es, channel, pa, 1);\n\n\t \n\tpa -= chip->dma.addr;\n\tpa >>= 1;\t \n\n\t \n\tes->base[channel] = pa & 0xFFFF;\n\tpa |= 0x00400000;\t \n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tapu_set_register(chip, apu, i, 0x0000);\n\n\t \n\tapu_set_register(chip, apu, 2, 0x8);\n\n\t \n\tapu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);\n\tapu_set_register(chip, apu, 5, pa & 0xFFFF);\n\tapu_set_register(chip, apu, 6, (pa + bsize) & 0xFFFF);\n\tapu_set_register(chip, apu, 7, bsize);\n\t \n\tapu_set_register(chip, apu, 8, 0x00F0);\n\t \n\tapu_set_register(chip, apu, 9, 0x0000);\n\t \n\tapu_set_register(chip, apu, 10, 0x8F08);\n\t \n\tapu_set_register(chip, apu, 11, route);\n\t \n\tapu_set_register(chip, apu, 0, 0x400F);\n}\n\nstatic void snd_es1968_capture_setup(struct es1968 *chip, struct esschan *es,\n\t\t\t\t     struct snd_pcm_runtime *runtime)\n{\n\tint size;\n\tu32 freq;\n\tunsigned long flags;\n\n\tsize = es->dma_size >> es->wav_shift;\n\n\t \n\t \n\n\t \n\t \n\tinit_capture_apu(chip, es, 2,\n\t\t\t es->mixbuf->buf.addr, ESM_MIXBUF_SIZE/4,  \n\t\t\t ESM_APU_INPUTMIXER, 0x14);\n\t \n\tinit_capture_apu(chip, es, 0, es->memory->buf.addr, size,\n\t\t\t ESM_APU_SRCONVERTOR, es->apu[2]);\n\tif (es->fmt & ESS_FMT_STEREO) {\n\t\t \n\t\tinit_capture_apu(chip, es, 3,\n\t\t\t\t es->mixbuf->buf.addr + ESM_MIXBUF_SIZE/2,\n\t\t\t\t ESM_MIXBUF_SIZE/4,  \n\t\t\t\t ESM_APU_INPUTMIXER, 0x15);\n\t\t \n\t\tinit_capture_apu(chip, es, 1,\n\t\t\t\t es->memory->buf.addr + size*2, size,\n\t\t\t\t ESM_APU_SRCONVERTOR, es->apu[3]);\n\t}\n\n\tfreq = runtime->rate;\n\t \n\tif (freq > 47999)\n\t\tfreq = 47999;\n\tif (freq < 4000)\n\t\tfreq = 4000;\n\n\tfreq = snd_es1968_compute_rate(chip, freq);\n\n\t \n\tsnd_es1968_apu_set_freq(chip, es->apu[0], freq);\n\tsnd_es1968_apu_set_freq(chip, es->apu[1], freq);\n\n\t \n\tfreq = 0x10000;\n\tsnd_es1968_apu_set_freq(chip, es->apu[2], freq);\n\tsnd_es1968_apu_set_freq(chip, es->apu[3], freq);\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t \n\toutw(1, chip->io_port + 0x04);\n\t \n\toutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\n \n\nstatic int snd_es1968_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct esschan *es = runtime->private_data;\n\n\tes->dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tes->frag_size = snd_pcm_lib_period_bytes(substream);\n\n\tes->wav_shift = 1;  \n\tes->fmt = 0;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tes->fmt |= ESS_FMT_16BIT;\n\tif (runtime->channels > 1) {\n\t\tes->fmt |= ESS_FMT_STEREO;\n\t\tif (es->fmt & ESS_FMT_16BIT)  \n\t\t\tes->wav_shift++;\n\t}\n\tes->bob_freq = snd_es1968_calc_bob_rate(chip, es, runtime);\n\n\tswitch (es->mode) {\n\tcase ESM_MODE_PLAY:\n\t\tsnd_es1968_playback_setup(chip, es, runtime);\n\t\tbreak;\n\tcase ESM_MODE_CAPTURE:\n\t\tsnd_es1968_capture_setup(chip, es, runtime);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_es1968_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct esschan *es = substream->runtime->private_data;\n\n\tspin_lock(&chip->substream_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (es->running)\n\t\t\tbreak;\n\t\tsnd_es1968_bob_inc(chip, es->bob_freq);\n\t\tes->count = 0;\n\t\tes->hwptr = 0;\n\t\tsnd_es1968_pcm_start(chip, es);\n\t\tes->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (! es->running)\n\t\t\tbreak;\n\t\tsnd_es1968_pcm_stop(chip, es);\n\t\tes->running = 0;\n\t\tsnd_es1968_bob_dec(chip);\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->substream_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_es1968_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct esschan *es = substream->runtime->private_data;\n\tunsigned int ptr;\n\n\tptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;\n\t\n\treturn bytes_to_frames(substream->runtime, ptr % es->dma_size);\n}\n\nstatic const struct snd_pcm_hardware snd_es1968_playback = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n               \t\t         SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_es1968_capture = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\t  SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t256,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\n \n\nstatic int calc_available_memory_size(struct es1968 *chip)\n{\n\tint max_size = 0;\n\tstruct esm_memory *buf;\n\n\tmutex_lock(&chip->memory_mutex);\n\tlist_for_each_entry(buf, &chip->buf_list, list) {\n\t\tif (buf->empty && buf->buf.bytes > max_size)\n\t\t\tmax_size = buf->buf.bytes;\n\t}\n\tmutex_unlock(&chip->memory_mutex);\n\tif (max_size >= 128*1024)\n\t\tmax_size = 127*1024;\n\treturn max_size;\n}\n\n \nstatic struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)\n{\n\tstruct esm_memory *buf;\n\n\tsize = ALIGN(size, ESM_MEM_ALIGN);\n\tmutex_lock(&chip->memory_mutex);\n\tlist_for_each_entry(buf, &chip->buf_list, list) {\n\t\tif (buf->empty && buf->buf.bytes >= size)\n\t\t\tgoto __found;\n\t}\n\tmutex_unlock(&chip->memory_mutex);\n\treturn NULL;\n\n__found:\n\tif (buf->buf.bytes > size) {\n\t\tstruct esm_memory *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (chunk == NULL) {\n\t\t\tmutex_unlock(&chip->memory_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t\tchunk->buf = buf->buf;\n\t\tchunk->buf.bytes -= size;\n\t\tchunk->buf.area += size;\n\t\tchunk->buf.addr += size;\n\t\tchunk->empty = 1;\n\t\tbuf->buf.bytes = size;\n\t\tlist_add(&chunk->list, &buf->list);\n\t}\n\tbuf->empty = 0;\n\tmutex_unlock(&chip->memory_mutex);\n\treturn buf;\n}\n\n \nstatic void snd_es1968_free_memory(struct es1968 *chip, struct esm_memory *buf)\n{\n\tstruct esm_memory *chunk;\n\n\tmutex_lock(&chip->memory_mutex);\n\tbuf->empty = 1;\n\tif (buf->list.prev != &chip->buf_list) {\n\t\tchunk = list_entry(buf->list.prev, struct esm_memory, list);\n\t\tif (chunk->empty) {\n\t\t\tchunk->buf.bytes += buf->buf.bytes;\n\t\t\tlist_del(&buf->list);\n\t\t\tkfree(buf);\n\t\t\tbuf = chunk;\n\t\t}\n\t}\n\tif (buf->list.next != &chip->buf_list) {\n\t\tchunk = list_entry(buf->list.next, struct esm_memory, list);\n\t\tif (chunk->empty) {\n\t\t\tbuf->buf.bytes += chunk->buf.bytes;\n\t\t\tlist_del(&chunk->list);\n\t\t\tkfree(chunk);\n\t\t}\n\t}\n\tmutex_unlock(&chip->memory_mutex);\n}\n\nstatic void snd_es1968_free_dmabuf(struct es1968 *chip)\n{\n\tstruct list_head *p;\n\n\tif (! chip->dma.area)\n\t\treturn;\n\tsnd_dma_free_pages(&chip->dma);\n\twhile ((p = chip->buf_list.next) != &chip->buf_list) {\n\t\tstruct esm_memory *chunk = list_entry(p, struct esm_memory, list);\n\t\tlist_del(p);\n\t\tkfree(chunk);\n\t}\n}\n\nstatic int\nsnd_es1968_init_dmabuf(struct es1968 *chip)\n{\n\tint err;\n\tstruct esm_memory *chunk;\n\n\terr = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &chip->pci->dev,\n\t\t\t\t\t   chip->total_bufsize, &chip->dma);\n\tif (err < 0 || ! chip->dma.area) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"can't allocate dma pages for size %d\\n\",\n\t\t\t   chip->total_bufsize);\n\t\treturn -ENOMEM;\n\t}\n\tif ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {\n\t\tsnd_dma_free_pages(&chip->dma);\n\t\tdev_err(chip->card->dev, \"DMA buffer beyond 256MB.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&chip->buf_list);\n\t \n\tchunk = kmalloc(sizeof(*chunk), GFP_KERNEL);\n\tif (chunk == NULL) {\n\t\tsnd_es1968_free_dmabuf(chip);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(chip->dma.area, 0, ESM_MEM_ALIGN);\n\tchunk->buf = chip->dma;\n\tchunk->buf.area += ESM_MEM_ALIGN;\n\tchunk->buf.addr += ESM_MEM_ALIGN;\n\tchunk->buf.bytes -= ESM_MEM_ALIGN;\n\tchunk->empty = 1;\n\tlist_add(&chunk->list, &chip->buf_list);\n\n\treturn 0;\n}\n\n \n \nstatic int snd_es1968_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct esschan *chan = runtime->private_data;\n\tint size = params_buffer_bytes(hw_params);\n\n\tif (chan->memory) {\n\t\tif (chan->memory->buf.bytes >= size) {\n\t\t\truntime->dma_bytes = size;\n\t\t\treturn 0;\n\t\t}\n\t\tsnd_es1968_free_memory(chip, chan->memory);\n\t}\n\tchan->memory = snd_es1968_new_memory(chip, size);\n\tif (chan->memory == NULL) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"cannot allocate dma buffer: size = %d\\n\", size);\n\t\treturn -ENOMEM;\n\t}\n\tsnd_pcm_set_runtime_buffer(substream, &chan->memory->buf);\n\treturn 1;  \n}\n\n \nstatic int snd_es1968_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct esschan *chan;\n\t\n\tif (runtime->private_data == NULL)\n\t\treturn 0;\n\tchan = runtime->private_data;\n\tif (chan->memory) {\n\t\tsnd_es1968_free_memory(chip, chan->memory);\n\t\tchan->memory = NULL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_es1968_alloc_apu_pair(struct es1968 *chip, int type)\n{\n\tint apu;\n\n\tfor (apu = 0; apu < NR_APUS; apu += 2) {\n\t\tif (chip->apu[apu] == ESM_APU_FREE &&\n\t\t    chip->apu[apu + 1] == ESM_APU_FREE) {\n\t\t\tchip->apu[apu] = chip->apu[apu + 1] = type;\n\t\t\treturn apu;\n\t\t}\n\t}\n\treturn -EBUSY;\n}\n\n \nstatic void snd_es1968_free_apu_pair(struct es1968 *chip, int apu)\n{\n\tchip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;\n}\n\n\n \n\nstatic int snd_es1968_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct esschan *es;\n\tint apu1;\n\n\t \n\tapu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY);\n\tif (apu1 < 0)\n\t\treturn apu1;\n\n\tes = kzalloc(sizeof(*es), GFP_KERNEL);\n\tif (!es) {\n\t\tsnd_es1968_free_apu_pair(chip, apu1);\n\t\treturn -ENOMEM;\n\t}\n\n\tes->apu[0] = apu1;\n\tes->apu[1] = apu1 + 1;\n\tes->apu_mode[0] = 0;\n\tes->apu_mode[1] = 0;\n\tes->running = 0;\n\tes->substream = substream;\n\tes->mode = ESM_MODE_PLAY;\n\n\truntime->private_data = es;\n\truntime->hw = snd_es1968_playback;\n\truntime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =\n\t\tcalc_available_memory_size(chip);\n\n\tspin_lock_irq(&chip->substream_lock);\n\tlist_add(&es->list, &chip->substream_list);\n\tspin_unlock_irq(&chip->substream_lock);\n\n\treturn 0;\n}\n\nstatic int snd_es1968_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct esschan *es;\n\tint apu1, apu2;\n\n\tapu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_CAPTURE);\n\tif (apu1 < 0)\n\t\treturn apu1;\n\tapu2 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_RATECONV);\n\tif (apu2 < 0) {\n\t\tsnd_es1968_free_apu_pair(chip, apu1);\n\t\treturn apu2;\n\t}\n\t\n\tes = kzalloc(sizeof(*es), GFP_KERNEL);\n\tif (!es) {\n\t\tsnd_es1968_free_apu_pair(chip, apu1);\n\t\tsnd_es1968_free_apu_pair(chip, apu2);\n\t\treturn -ENOMEM;\n\t}\n\n\tes->apu[0] = apu1;\n\tes->apu[1] = apu1 + 1;\n\tes->apu[2] = apu2;\n\tes->apu[3] = apu2 + 1;\n\tes->apu_mode[0] = 0;\n\tes->apu_mode[1] = 0;\n\tes->apu_mode[2] = 0;\n\tes->apu_mode[3] = 0;\n\tes->running = 0;\n\tes->substream = substream;\n\tes->mode = ESM_MODE_CAPTURE;\n\n\t \n\tes->mixbuf = snd_es1968_new_memory(chip, ESM_MIXBUF_SIZE);\n\tif (!es->mixbuf) {\n\t\tsnd_es1968_free_apu_pair(chip, apu1);\n\t\tsnd_es1968_free_apu_pair(chip, apu2);\n\t\tkfree(es);\n                return -ENOMEM;\n        }\n\tmemset(es->mixbuf->buf.area, 0, ESM_MIXBUF_SIZE);\n\n\truntime->private_data = es;\n\truntime->hw = snd_es1968_capture;\n\truntime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =\n\t\tcalc_available_memory_size(chip) - 1024;  \n\tsnd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES);\n\n\tspin_lock_irq(&chip->substream_lock);\n\tlist_add(&es->list, &chip->substream_list);\n\tspin_unlock_irq(&chip->substream_lock);\n\n\treturn 0;\n}\n\nstatic int snd_es1968_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct esschan *es;\n\n\tif (substream->runtime->private_data == NULL)\n\t\treturn 0;\n\tes = substream->runtime->private_data;\n\tspin_lock_irq(&chip->substream_lock);\n\tlist_del(&es->list);\n\tspin_unlock_irq(&chip->substream_lock);\n\tsnd_es1968_free_apu_pair(chip, es->apu[0]);\n\tkfree(es);\n\n\treturn 0;\n}\n\nstatic int snd_es1968_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct es1968 *chip = snd_pcm_substream_chip(substream);\n\tstruct esschan *es;\n\n\tif (substream->runtime->private_data == NULL)\n\t\treturn 0;\n\tes = substream->runtime->private_data;\n\tspin_lock_irq(&chip->substream_lock);\n\tlist_del(&es->list);\n\tspin_unlock_irq(&chip->substream_lock);\n\tsnd_es1968_free_memory(chip, es->mixbuf);\n\tsnd_es1968_free_apu_pair(chip, es->apu[0]);\n\tsnd_es1968_free_apu_pair(chip, es->apu[2]);\n\tkfree(es);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_es1968_playback_ops = {\n\t.open =\t\tsnd_es1968_playback_open,\n\t.close =\tsnd_es1968_playback_close,\n\t.hw_params =\tsnd_es1968_hw_params,\n\t.hw_free =\tsnd_es1968_hw_free,\n\t.prepare =\tsnd_es1968_pcm_prepare,\n\t.trigger =\tsnd_es1968_pcm_trigger,\n\t.pointer =\tsnd_es1968_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_es1968_capture_ops = {\n\t.open =\t\tsnd_es1968_capture_open,\n\t.close =\tsnd_es1968_capture_close,\n\t.hw_params =\tsnd_es1968_hw_params,\n\t.hw_free =\tsnd_es1968_hw_free,\n\t.prepare =\tsnd_es1968_pcm_prepare,\n\t.trigger =\tsnd_es1968_pcm_trigger,\n\t.pointer =\tsnd_es1968_pcm_pointer,\n};\n\n\n \n#define CLOCK_MEASURE_BUFSIZE\t16768\t \n\nstatic void es1968_measure_clock(struct es1968 *chip)\n{\n\tint i, apu;\n\tunsigned int pa, offset, t;\n\tstruct esm_memory *memory;\n\tktime_t start_time, stop_time;\n\tktime_t diff;\n\n\tif (chip->clock == 0)\n\t\tchip->clock = 48000;  \n\n\t \n\tapu = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY);\n\tif (apu < 0) {\n\t\tdev_err(chip->card->dev, \"Hmm, cannot find empty APU pair!?\\n\");\n\t\treturn;\n\t}\n\tmemory = snd_es1968_new_memory(chip, CLOCK_MEASURE_BUFSIZE);\n\tif (!memory) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t \"cannot allocate dma buffer - using default clock %d\\n\",\n\t\t\t chip->clock);\n\t\tsnd_es1968_free_apu_pair(chip, apu);\n\t\treturn;\n\t}\n\n\tmemset(memory->buf.area, 0, CLOCK_MEASURE_BUFSIZE);\n\n\twave_set_register(chip, apu << 3, (memory->buf.addr - 0x10) & 0xfff8);\n\n\tpa = (unsigned int)((memory->buf.addr - chip->dma.addr) >> 1);\n\tpa |= 0x00400000;\t \n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tapu_set_register(chip, apu, i, 0x0000);\n\n\tapu_set_register(chip, apu, 0, 0x400f);\n\tapu_set_register(chip, apu, 4, ((pa >> 16) & 0xff) << 8);\n\tapu_set_register(chip, apu, 5, pa & 0xffff);\n\tapu_set_register(chip, apu, 6, (pa + CLOCK_MEASURE_BUFSIZE/2) & 0xffff);\n\tapu_set_register(chip, apu, 7, CLOCK_MEASURE_BUFSIZE/2);\n\tapu_set_register(chip, apu, 8, 0x0000);\n\tapu_set_register(chip, apu, 9, 0xD000);\n\tapu_set_register(chip, apu, 10, 0x8F08);\n\tapu_set_register(chip, apu, 11, 0x0000);\n\tspin_lock_irq(&chip->reg_lock);\n\toutw(1, chip->io_port + 0x04);  \n\toutw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);  \n\tspin_unlock_irq(&chip->reg_lock);\n\n\tsnd_es1968_apu_set_freq(chip, apu, ((unsigned int)48000 << 16) / chip->clock);  \n\n\tchip->in_measurement = 1;\n\tchip->measure_apu = apu;\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_es1968_bob_inc(chip, ESM_BOB_FREQ);\n\t__apu_set_register(chip, apu, 5, pa & 0xffff);\n\tsnd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);\n\tstart_time = ktime_get();\n\tspin_unlock_irq(&chip->reg_lock);\n\tmsleep(50);\n\tspin_lock_irq(&chip->reg_lock);\n\toffset = __apu_get_register(chip, apu, 5);\n\tstop_time = ktime_get();\n\tsnd_es1968_trigger_apu(chip, apu, 0);  \n\tsnd_es1968_bob_dec(chip);\n\tchip->in_measurement = 0;\n\tspin_unlock_irq(&chip->reg_lock);\n\n\t \n\toffset -= (pa & 0xffff);\n\toffset &= 0xfffe;\n\toffset += chip->measure_count * (CLOCK_MEASURE_BUFSIZE/2);\n\n\tdiff = ktime_sub(stop_time, start_time);\n\tt = ktime_to_us(diff);\n\tif (t == 0) {\n\t\tdev_err(chip->card->dev, \"?? calculation error..\\n\");\n\t} else {\n\t\toffset *= 1000;\n\t\toffset = (offset / t) * 1000 + ((offset % t) * 1000) / t;\n\t\tif (offset < 47500 || offset > 48500) {\n\t\t\tif (offset >= 40000 && offset <= 50000)\n\t\t\t\tchip->clock = (chip->clock * offset) / 48000;\n\t\t}\n\t\tdev_info(chip->card->dev, \"clocking to %d\\n\", chip->clock);\n\t}\n\tsnd_es1968_free_memory(chip, memory);\n\tsnd_es1968_free_apu_pair(chip, apu);\n}\n\n\n \n\nstatic void snd_es1968_pcm_free(struct snd_pcm *pcm)\n{\n\tstruct es1968 *esm = pcm->private_data;\n\tsnd_es1968_free_dmabuf(esm);\n\tesm->pcm = NULL;\n}\n\nstatic int\nsnd_es1968_pcm(struct es1968 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\t \n\terr = snd_es1968_init_dmabuf(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twave_set_register(chip, 0x01FC, chip->dma.addr >> 12);\n\twave_set_register(chip, 0x01FD, chip->dma.addr >> 12);\n\twave_set_register(chip, 0x01FE, chip->dma.addr >> 12);\n\twave_set_register(chip, 0x01FF, chip->dma.addr >> 12);\n\n\terr = snd_pcm_new(chip->card, \"ESS Maestro\", device,\n\t\t\t  chip->playback_streams,\n\t\t\t  chip->capture_streams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\tpcm->private_free = snd_es1968_pcm_free;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1968_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1968_capture_ops);\n\n\tpcm->info_flags = 0;\n\n\tstrcpy(pcm->name, \"ESS Maestro\");\n\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n \nstatic void snd_es1968_suppress_jitter(struct es1968 *chip, struct esschan *es)\n{\n\tunsigned int cp1;\n\tunsigned int cp2;\n\tunsigned int diff;\n\n\tcp1 = __apu_get_register(chip, 0, 5);\n\tcp2 = __apu_get_register(chip, 1, 5);\n\tdiff = (cp1 > cp2 ? cp1 - cp2 : cp2 - cp1);\n\n\tif (diff > 1)\n\t\t__maestro_write(chip, IDR0_DATA_PORT, cp1);\n}\n\n \nstatic void snd_es1968_update_pcm(struct es1968 *chip, struct esschan *es)\n{\n\tunsigned int hwptr;\n\tunsigned int diff;\n\tstruct snd_pcm_substream *subs = es->substream;\n        \n\tif (subs == NULL || !es->running)\n\t\treturn;\n\n\thwptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;\n\thwptr %= es->dma_size;\n\n\tdiff = (es->dma_size + hwptr - es->hwptr) % es->dma_size;\n\n\tes->hwptr = hwptr;\n\tes->count += diff;\n\n\tif (es->count > es->frag_size) {\n\t\tspin_unlock(&chip->substream_lock);\n\t\tsnd_pcm_period_elapsed(subs);\n\t\tspin_lock(&chip->substream_lock);\n\t\tes->count %= es->frag_size;\n\t}\n}\n\n \nstatic void es1968_update_hw_volume(struct work_struct *work)\n{\n\tstruct es1968 *chip = container_of(work, struct es1968, hwvol_work);\n\tint x, val;\n\n\t \n\tx = inb(chip->io_port + 0x1c) & 0xee;\n\t \n\toutb(0x88, chip->io_port + 0x1c);\n\toutb(0x88, chip->io_port + 0x1d);\n\toutb(0x88, chip->io_port + 0x1e);\n\toutb(0x88, chip->io_port + 0x1f);\n\n\tif (chip->in_suspend)\n\t\treturn;\n\n#ifndef CONFIG_SND_ES1968_INPUT\n\tif (! chip->master_switch || ! chip->master_volume)\n\t\treturn;\n\n\tval = snd_ac97_read(chip->ac97, AC97_MASTER);\n\tswitch (x) {\n\tcase 0x88:\n\t\t \n\t\tval ^= 0x8000;\n\t\tbreak;\n\tcase 0xaa:\n\t\t \n\t\tif ((val & 0x7f) > 0)\n\t\t\tval--;\n\t\tif ((val & 0x7f00) > 0)\n\t\t\tval -= 0x0100;\n\t\tbreak;\n\tcase 0x66:\n\t\t \n\t\tif ((val & 0x7f) < 0x1f)\n\t\t\tval++;\n\t\tif ((val & 0x7f00) < 0x1f00)\n\t\t\tval += 0x0100;\n\t\tbreak;\n\t}\n\tif (snd_ac97_update(chip->ac97, AC97_MASTER, val))\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->master_volume->id);\n#else\n\tif (!chip->input_dev)\n\t\treturn;\n\n\tval = 0;\n\tswitch (x) {\n\tcase 0x88:\n\t\t \n\t\tval = KEY_MUTE;\n\t\tbreak;\n\tcase 0xaa:\n\t\t \n\t\tval = KEY_VOLUMEUP;\n\t\tbreak;\n\tcase 0x66:\n\t\t \n\t\tval = KEY_VOLUMEDOWN;\n\t\tbreak;\n\t}\n\n\tif (val) {\n\t\tinput_report_key(chip->input_dev, val, 1);\n\t\tinput_sync(chip->input_dev);\n\t\tinput_report_key(chip->input_dev, val, 0);\n\t\tinput_sync(chip->input_dev);\n\t}\n#endif\n}\n\n \nstatic irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)\n{\n\tstruct es1968 *chip = dev_id;\n\tu32 event;\n\n\tevent = inb(chip->io_port + 0x1A);\n\tif (!event)\n\t\treturn IRQ_NONE;\n\n\toutw(inw(chip->io_port + 4) & 1, chip->io_port + 4);\n\n\tif (event & ESM_HWVOL_IRQ)\n\t\tschedule_work(&chip->hwvol_work);\n\n\t \n\toutb(0xFF, chip->io_port + 0x1A);\n\n\tif ((event & ESM_MPU401_IRQ) && chip->rmidi) {\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\t}\n\n\tif (event & ESM_SOUND_IRQ) {\n\t\tstruct esschan *es;\n\t\tspin_lock(&chip->substream_lock);\n\t\tlist_for_each_entry(es, &chip->substream_list, list) {\n\t\t\tif (es->running) {\n\t\t\t\tsnd_es1968_update_pcm(chip, es);\n\t\t\t\tif (es->fmt & ESS_FMT_STEREO)\n\t\t\t\t\tsnd_es1968_suppress_jitter(chip, es);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&chip->substream_lock);\n\t\tif (chip->in_measurement) {\n\t\t\tunsigned int curp = __apu_get_register(chip, chip->measure_apu, 5);\n\t\t\tif (curp < chip->measure_lastpos)\n\t\t\t\tchip->measure_count++;\n\t\t\tchip->measure_lastpos = curp;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int\nsnd_es1968_mixer(struct es1968 *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_es1968_ac97_write,\n\t\t.read = snd_es1968_ac97_read,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\tpbus->no_vra = 1;  \n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\n#ifndef CONFIG_SND_ES1968_INPUT\n\t \n\tchip->master_switch = snd_ctl_find_id_mixer(chip->card,\n\t\t\t\t\t\t    \"Master Playback Switch\");\n\tchip->master_volume = snd_ctl_find_id_mixer(chip->card,\n\t\t\t\t\t\t    \"Master Playback Volume\");\n#endif\n\n\treturn 0;\n}\n\n \n\nstatic void snd_es1968_ac97_reset(struct es1968 *chip)\n{\n\tunsigned long ioaddr = chip->io_port;\n\n\tunsigned short save_ringbus_a;\n\tunsigned short save_68;\n\tunsigned short w;\n\tunsigned int vend;\n\n\t \n\tsave_ringbus_a = inw(ioaddr + 0x36);\n\n\t \n\t \n\toutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\n\toutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\n\n\t \n\toutw(0x0000, ioaddr + 0x36);\n\tsave_68 = inw(ioaddr + 0x68);\n\tpci_read_config_word(chip->pci, 0x58, &w);\t \n\tpci_read_config_dword(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\n\tif (w & 1)\n\t\tsave_68 |= 0x10;\n\toutw(0xfffe, ioaddr + 0x64);\t \n\toutw(0x0001, ioaddr + 0x68);\t \n\toutw(0x0000, ioaddr + 0x60);\t \n\tudelay(20);\n\toutw(0x0001, ioaddr + 0x60);\t \n\tmsleep(20);\n\n\toutw(save_68 | 0x1, ioaddr + 0x68);\t \n\toutw((inw(ioaddr + 0x38) & 0xfffc) | 0x1, ioaddr + 0x38);\n\toutw((inw(ioaddr + 0x3a) & 0xfffc) | 0x1, ioaddr + 0x3a);\n\toutw((inw(ioaddr + 0x3c) & 0xfffc) | 0x1, ioaddr + 0x3c);\n\n\t \n\t \n\toutw(0x0000, ioaddr + 0x36);\n\toutw(0xfff7, ioaddr + 0x64);\t \n\tsave_68 = inw(ioaddr + 0x68);\n\toutw(0x0009, ioaddr + 0x68);\t \n\toutw(0x0001, ioaddr + 0x60);\t \n\tudelay(20);\n\toutw(0x0009, ioaddr + 0x60);\t \n\tmsleep(500);\n\t \n\toutw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);\n\toutw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);\n\n#if 0\t\t\t\t \n\tdev_info(chip->card->dev, \"trying software reset\\n\");\n\t \n\toutb(0x80 | 0x7c, ioaddr + 0x30);\n\tfor (w = 0;; w++) {\n\t\tif ((inw(ioaddr + 0x30) & 1) == 0) {\n\t\t\tif (inb(ioaddr + 0x32) != 0)\n\t\t\t\tbreak;\n\n\t\t\toutb(0x80 | 0x7d, ioaddr + 0x30);\n\t\t\tif (((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t    && (inb(ioaddr + 0x32) != 0))\n\t\t\t\tbreak;\n\t\t\toutb(0x80 | 0x7f, ioaddr + 0x30);\n\t\t\tif (((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t    && (inb(ioaddr + 0x32) != 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (w > 10000) {\n\t\t\toutb(inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);\t \n\t\t\tmsleep(500);\t \n\t\t\toutb(inb(ioaddr + 0x37) & ~0x08,\n\t\t\t\tioaddr + 0x37);\n\t\t\tudelay(1);\n\t\t\toutw(0x80, ioaddr + 0x30);\n\t\t\tfor (w = 0; w < 10000; w++) {\n\t\t\t\tif ((inw(ioaddr + 0x30) & 1) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (vend == NEC_VERSA_SUBID1 || vend == NEC_VERSA_SUBID2) {\n\t\t \n\t\toutw(0xf9ff, ioaddr + 0x64);\n\t\toutw(inw(ioaddr + 0x68) | 0x600, ioaddr + 0x68);\n\t\toutw(0x0209, ioaddr + 0x60);\n\t}\n\n\t \n\toutw(save_ringbus_a, ioaddr + 0x36);\n\n\t \n\toutb(inb(ioaddr+0xc0)|(1<<5), ioaddr+0xc0);\n\toutb(0xff, ioaddr+0xc3);\n\toutb(0xff, ioaddr+0xc4);\n\toutb(0xff, ioaddr+0xc6);\n\toutb(0xff, ioaddr+0xc8);\n\toutb(0x3f, ioaddr+0xcf);\n\toutb(0x3f, ioaddr+0xd0);\n}\n\nstatic void snd_es1968_reset(struct es1968 *chip)\n{\n\t \n\toutw(ESM_RESET_MAESTRO | ESM_RESET_DIRECTSOUND,\n\t     chip->io_port + ESM_PORT_HOST_IRQ);\n\tudelay(10);\n\toutw(0x0000, chip->io_port + ESM_PORT_HOST_IRQ);\n\tudelay(10);\n}\n\n \nstatic void snd_es1968_chip_init(struct es1968 *chip)\n{\n\tstruct pci_dev *pci = chip->pci;\n\tint i;\n\tunsigned long iobase  = chip->io_port;\n\tu16 w;\n\tu32 n;\n\n\t \n\t\n\t \n\tpci_read_config_word(pci, ESM_CONFIG_A, &w);\n\n\tw &= ~DMA_CLEAR;\t \n\tw &= ~(PIC_SNOOP1 | PIC_SNOOP2);\t \n\tw &= ~SAFEGUARD;\t \n\tw |= POST_WRITE;\t \n\tw |= PCI_TIMING;\t \n\t \n\tw &= ~SWAP_LR;\t\t \n\tw &= ~SUBTR_DECODE;\t \n\n\tpci_write_config_word(pci, ESM_CONFIG_A, w);\n\n\t \n\n\tpci_read_config_word(pci, ESM_CONFIG_B, &w);\n\n\tw &= ~(1 << 15);\t \n\t \n\tw &= ~(1 << 14);\t \n\n\tw &= ~SPDIF_CONFB;\t \n\tw |= HWV_CONFB;\t\t \n\tw |= DEBOUNCE;\t\t \n\tw &= ~GPIO_CONFB;\t \n\tw |= CHI_CONFB;\t\t \n\tw &= ~IDMA_CONFB;\t \n\tw &= ~MIDI_FIX;\t\t \n\tw &= ~(1 << 1);\t\t \n\tw &= ~IRQ_TO_ISA;\t \n\n\tpci_write_config_word(pci, ESM_CONFIG_B, w);\n\n\t \n\n\tpci_read_config_word(pci, ESM_DDMA, &w);\n\tw &= ~(1 << 0);\n\tpci_write_config_word(pci, ESM_DDMA, w);\n\n\t \n\n\tpci_read_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, &w);\n\n\tw |= ESS_DISABLE_AUDIO;\t \n\tw &= ~ESS_ENABLE_SERIAL_IRQ;\t \n\tw &= ~(0x1f);\t\t \n\n\tpci_write_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, w);\n\n\t \n\tpci_read_config_word(pci, 0x58, &w);\n\tw|=1<<2;\t \n\tw|=1<<3;\t \n\tw&=~(1<<11);\t \n\tpci_write_config_word(pci, 0x58, w);\n\t\n\t \n\n\tsnd_es1968_reset(chip);\n\n\t \n\n\t \n\toutw(0xC090, iobase + ESM_RING_BUS_DEST);  \n\tudelay(20);\n\toutw(0x3000, iobase + ESM_RING_BUS_CONTR_A);  \n\tudelay(20);\n\n\t \n\t \n\tsnd_es1968_ac97_reset(chip);\n\n\t \n\n\tn = inl(iobase + ESM_RING_BUS_CONTR_B);\n\tn &= ~RINGB_EN_SPDIF;\t \n\t \n\toutl(n, iobase + ESM_RING_BUS_CONTR_B);\n\n\t \n\toutb(0x88, iobase+0x1c);\n\toutb(0x88, iobase+0x1d);\n\toutb(0x88, iobase+0x1e);\n\toutb(0x88, iobase+0x1f);\n\n\t \n\n\toutb(0, iobase + ASSP_CONTROL_B);\n\toutb(3, iobase + ASSP_CONTROL_A);\t \n\toutb(0, iobase + ASSP_CONTROL_C);\t \n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\t \n\t\toutw(0x01E0 + i, iobase + WC_INDEX);\n\t\toutw(0x0000, iobase + WC_DATA);\n\n\t\t \n\t\toutw(0x01D0 + i, iobase + WC_INDEX);\n\t\toutw(0x0000, iobase + WC_DATA);\n\t}\n\twave_set_register(chip, IDR7_WAVE_ROMRAM,\n\t\t\t  (wave_get_register(chip, IDR7_WAVE_ROMRAM) & 0xFF00));\n\twave_set_register(chip, IDR7_WAVE_ROMRAM,\n\t\t\t  wave_get_register(chip, IDR7_WAVE_ROMRAM) | 0x100);\n\twave_set_register(chip, IDR7_WAVE_ROMRAM,\n\t\t\t  wave_get_register(chip, IDR7_WAVE_ROMRAM) & ~0x200);\n\twave_set_register(chip, IDR7_WAVE_ROMRAM,\n\t\t\t  wave_get_register(chip, IDR7_WAVE_ROMRAM) | ~0x400);\n\n\n\tmaestro_write(chip, IDR2_CRAM_DATA, 0x0000);\n\t \n\t \n\tmaestro_write(chip, 0x08, 0xB004);\n\tmaestro_write(chip, 0x09, 0x001B);\n\tmaestro_write(chip, 0x0A, 0x8000);\n\tmaestro_write(chip, 0x0B, 0x3F37);\n\tmaestro_write(chip, 0x0C, 0x0098);\n\n\t \n\tmaestro_write(chip, 0x0C,\n\t\t      (maestro_read(chip, 0x0C) & ~0xF000) | 0x8000);\n\t \n\tmaestro_write(chip, 0x0C,\n\t\t      (maestro_read(chip, 0x0C) & ~0x0F00) | 0x0500);\n\n\tmaestro_write(chip, 0x0D, 0x7632);\n\n\t \n\n\tw = inw(iobase + WC_CONTROL);\n\n\tw &= ~0xFA00;\t\t \n\tw |= 0xA000;\t\t \n\tw &= ~0x0200;\t\t \n\tw |= 0x0100;\t\t \n\tw |= 0x0080;\t\t \n\tw &= ~0x0060;\t\t \n\tw |= 0x0020;\t\t \n\t \n\tw &= ~0x000C;\t\t \n\t \n\tw &= ~0x0001;\t\t \n\n\toutw(w, iobase + WC_CONTROL);\n\n\t \n\tfor (i = 0; i < NR_APUS; i++) {\n\t\tfor (w = 0; w < NR_APU_REGS; w++)\n\t\t\tapu_set_register(chip, i, w, 0);\n\n\t}\n}\n\n \nstatic void snd_es1968_start_irq(struct es1968 *chip)\n{\n\tunsigned short w;\n\tw = ESM_HIRQ_DSIE | ESM_HIRQ_HW_VOLUME;\n\tif (chip->rmidi)\n\t\tw |= ESM_HIRQ_MPU401;\n\toutb(w, chip->io_port + 0x1A);\n\toutw(w, chip->io_port + ESM_PORT_HOST_IRQ);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int es1968_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct es1968 *chip = card->private_data;\n\n\tif (! chip->do_pm)\n\t\treturn 0;\n\n\tchip->in_suspend = 1;\n\tcancel_work_sync(&chip->hwvol_work);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\tsnd_es1968_bob_stop(chip);\n\treturn 0;\n}\n\nstatic int es1968_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct es1968 *chip = card->private_data;\n\tstruct esschan *es;\n\n\tif (! chip->do_pm)\n\t\treturn 0;\n\n\tsnd_es1968_chip_init(chip);\n\n\t  \n\tif (chip->dma.addr) {\n\t\t \n\t\twave_set_register(chip, 0x01FC, chip->dma.addr >> 12);\n\t}\n\n\tsnd_es1968_start_irq(chip);\n\n\t \n\tsnd_ac97_resume(chip->ac97);\n\n\tlist_for_each_entry(es, &chip->substream_list, list) {\n\t\tswitch (es->mode) {\n\t\tcase ESM_MODE_PLAY:\n\t\t\tsnd_es1968_playback_setup(chip, es, es->substream->runtime);\n\t\t\tbreak;\n\t\tcase ESM_MODE_CAPTURE:\n\t\t\tsnd_es1968_capture_setup(chip, es, es->substream->runtime);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (chip->bobclient)\n\t\tsnd_es1968_bob_start(chip);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\tchip->in_suspend = 0;\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(es1968_pm, es1968_suspend, es1968_resume);\n#define ES1968_PM_OPS\t&es1968_pm\n#else\n#define ES1968_PM_OPS\tNULL\n#endif  \n\n#ifdef SUPPORT_JOYSTICK\n#define JOYSTICK_ADDR\t0x200\nstatic int snd_es1968_create_gameport(struct es1968 *chip, int dev)\n{\n\tstruct gameport *gp;\n\tstruct resource *r;\n\tu16 val;\n\n\tif (!joystick[dev])\n\t\treturn -ENODEV;\n\n\tr = devm_request_region(&chip->pci->dev, JOYSTICK_ADDR, 8,\n\t\t\t\t\"ES1968 gameport\");\n\tif (!r)\n\t\treturn -EBUSY;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_read_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, &val);\n\tpci_write_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, val | 0x04);\n\n\tgameport_set_name(gp, \"ES1968 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->io = JOYSTICK_ADDR;\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic void snd_es1968_free_gameport(struct es1968 *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_es1968_create_gameport(struct es1968 *chip, int dev) { return -ENOSYS; }\nstatic inline void snd_es1968_free_gameport(struct es1968 *chip) { }\n#endif\n\n#ifdef CONFIG_SND_ES1968_INPUT\nstatic int snd_es1968_input_register(struct es1968 *chip)\n{\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tinput_dev = devm_input_allocate_device(&chip->pci->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(chip->phys, sizeof(chip->phys), \"pci-%s/input0\",\n\t\t pci_name(chip->pci));\n\n\tinput_dev->name = chip->card->driver;\n\tinput_dev->phys = chip->phys;\n\tinput_dev->id.bustype = BUS_PCI;\n\tinput_dev->id.vendor  = chip->pci->vendor;\n\tinput_dev->id.product = chip->pci->device;\n\tinput_dev->dev.parent = &chip->pci->dev;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(KEY_MUTE, input_dev->keybit);\n\t__set_bit(KEY_VOLUMEDOWN, input_dev->keybit);\n\t__set_bit(KEY_VOLUMEUP, input_dev->keybit);\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\tchip->input_dev = input_dev;\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_SND_ES1968_RADIO\n#define GPIO_DATA\t0x60\n#define IO_MASK\t\t4       \n#define IO_DIR\t\t8       \n\n \nstruct snd_es1968_tea575x_gpio {\n\tu8 data, clk, wren, most;\n\tchar *name;\n};\n\nstatic const struct snd_es1968_tea575x_gpio snd_es1968_tea575x_gpios[] = {\n\t{ .data = 6, .clk = 7, .wren = 8, .most = 9, .name = \"SF64-PCE2\" },\n\t{ .data = 7, .clk = 8, .wren = 6, .most = 10, .name = \"M56VAP\" },\n};\n\n#define get_tea575x_gpio(chip) \\\n\t(&snd_es1968_tea575x_gpios[(chip)->tea575x_tuner])\n\n\nstatic void snd_es1968_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\n{\n\tstruct es1968 *chip = tea->private_data;\n\tstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\tu16 val = 0;\n\n\tval |= (pins & TEA575X_DATA) ? (1 << gpio.data) : 0;\n\tval |= (pins & TEA575X_CLK)  ? (1 << gpio.clk)  : 0;\n\tval |= (pins & TEA575X_WREN) ? (1 << gpio.wren) : 0;\n\n\toutw(val, chip->io_port + GPIO_DATA);\n}\n\nstatic u8 snd_es1968_tea575x_get_pins(struct snd_tea575x *tea)\n{\n\tstruct es1968 *chip = tea->private_data;\n\tstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\tu16 val = inw(chip->io_port + GPIO_DATA);\n\tu8 ret = 0;\n\n\tif (val & (1 << gpio.data))\n\t\tret |= TEA575X_DATA;\n\tif (val & (1 << gpio.most))\n\t\tret |= TEA575X_MOST;\n\n\treturn ret;\n}\n\nstatic void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool output)\n{\n\tstruct es1968 *chip = tea->private_data;\n\tunsigned long io = chip->io_port + GPIO_DATA;\n\tu16 odir = inw(io + IO_DIR);\n\tstruct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\n\tif (output) {\n\t\toutw(~((1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren)),\n\t\t\tio + IO_MASK);\n\t\toutw(odir | (1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren),\n\t\t\tio + IO_DIR);\n\t} else {\n\t\toutw(~((1 << gpio.clk) | (1 << gpio.wren) | (1 << gpio.data) | (1 << gpio.most)),\n\t\t\tio + IO_MASK);\n\t\toutw((odir & ~((1 << gpio.data) | (1 << gpio.most)))\n\t\t\t| (1 << gpio.clk) | (1 << gpio.wren), io + IO_DIR);\n\t}\n}\n\nstatic const struct snd_tea575x_ops snd_es1968_tea_ops = {\n\t.set_pins = snd_es1968_tea575x_set_pins,\n\t.get_pins = snd_es1968_tea575x_get_pins,\n\t.set_direction = snd_es1968_tea575x_set_direction,\n};\n#endif\n\nstatic void snd_es1968_free(struct snd_card *card)\n{\n\tstruct es1968 *chip = card->private_data;\n\n\tcancel_work_sync(&chip->hwvol_work);\n\n\tif (chip->io_port) {\n\t\toutw(1, chip->io_port + 0x04);  \n\t\toutw(0, chip->io_port + ESM_PORT_HOST_IRQ);  \n\t}\n\n#ifdef CONFIG_SND_ES1968_RADIO\n\tsnd_tea575x_exit(&chip->tea);\n\tv4l2_device_unregister(&chip->v4l2_dev);\n#endif\n\n\tsnd_es1968_free_gameport(chip);\n}\n\nstruct ess_device_list {\n\tunsigned short type;\t \n\tunsigned short vendor;\t \n};\n\nstatic const struct ess_device_list pm_allowlist[] = {\n\t{ TYPE_MAESTRO2E, 0x0e11 },\t \n\t{ TYPE_MAESTRO2E, 0x1028 },\n\t{ TYPE_MAESTRO2E, 0x103c },\n\t{ TYPE_MAESTRO2E, 0x1179 },\n\t{ TYPE_MAESTRO2E, 0x14c0 },\t \n\t{ TYPE_MAESTRO2E, 0x1558 },\n\t{ TYPE_MAESTRO2E, 0x125d },\t \n\t{ TYPE_MAESTRO2, 0x125d },\t \n};\n\nstatic const struct ess_device_list mpu_denylist[] = {\n\t{ TYPE_MAESTRO2, 0x125d },\n};\n\nstatic int snd_es1968_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci,\n\t\t\t     int total_bufsize,\n\t\t\t     int play_streams,\n\t\t\t     int capt_streams,\n\t\t\t     int chip_type,\n\t\t\t     int do_pm,\n\t\t\t     int radio_nr)\n{\n\tstruct es1968 *chip = card->private_data;\n\tint i, err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(28))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 28bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tchip->type = chip_type;\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->substream_lock);\n\tINIT_LIST_HEAD(&chip->buf_list);\n\tINIT_LIST_HEAD(&chip->substream_list);\n\tmutex_init(&chip->memory_mutex);\n\tINIT_WORK(&chip->hwvol_work, es1968_update_hw_volume);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->total_bufsize = total_bufsize;\t \n\tchip->playback_streams = play_streams;\n\tchip->capture_streams = capt_streams;\n\n\terr = pci_request_regions(pci, \"ESS Maestro\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->io_port = pci_resource_start(pci, 0);\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_es1968_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_es1968_free;\n\t        \n\t \n\tfor (i = 0; i < 32; i++)\n\t\tchip->maestro_map[i] = 0;\n\n\t \n\tfor (i = 0; i < NR_APUS; i++)\n\t\tchip->apu[i] = ESM_APU_FREE;\n\n\t \n\tpci_set_master(pci);\n\n\tif (do_pm > 1) {\n\t\t \n\t\tunsigned short vend;\n\t\tpci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\n\t\tfor (i = 0; i < (int)ARRAY_SIZE(pm_allowlist); i++) {\n\t\t\tif (chip->type == pm_allowlist[i].type &&\n\t\t\t    vend == pm_allowlist[i].vendor) {\n\t\t\t\tdo_pm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (do_pm > 1) {\n\t\t\t \n\t\t\tdev_info(card->dev, \"not attempting power management.\\n\");\n\t\t\tdo_pm = 0;\n\t\t}\n\t}\n\tchip->do_pm = do_pm;\n\n\tsnd_es1968_chip_init(chip);\n\n#ifdef CONFIG_SND_ES1968_RADIO\n\t \n\tif (chip->pci->subsystem_vendor != 0x125d)\n\t\treturn 0;\n\terr = v4l2_device_register(&pci->dev, &chip->v4l2_dev);\n\tif (err < 0)\n\t\treturn err;\n\tchip->tea.v4l2_dev = &chip->v4l2_dev;\n\tchip->tea.private_data = chip;\n\tchip->tea.radio_nr = radio_nr;\n\tchip->tea.ops = &snd_es1968_tea_ops;\n\tsprintf(chip->tea.bus_info, \"PCI:%s\", pci_name(pci));\n\tfor (i = 0; i < ARRAY_SIZE(snd_es1968_tea575x_gpios); i++) {\n\t\tchip->tea575x_tuner = i;\n\t\tif (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {\n\t\t\tdev_info(card->dev, \"detected TEA575x radio type %s\\n\",\n\t\t\t\t   get_tea575x_gpio(chip)->name);\n\t\t\tstrscpy(chip->tea.card, get_tea575x_gpio(chip)->name,\n\t\t\t\tsizeof(chip->tea.card));\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n\n \nstatic int __snd_es1968_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct es1968 *chip;\n\tunsigned int i;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n                \n\tif (total_bufsize[dev] < 128)\n\t\ttotal_bufsize[dev] = 128;\n\tif (total_bufsize[dev] > 4096)\n\t\ttotal_bufsize[dev] = 4096;\n\terr = snd_es1968_create(card, pci,\n\t\t\t\ttotal_bufsize[dev] * 1024,  \n\t\t\t\tpcm_substreams_p[dev],\n\t\t\t\tpcm_substreams_c[dev],\n\t\t\t\tpci_id->driver_data,\n\t\t\t\tuse_pm[dev],\n\t\t\t\tradio_nr[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (chip->type) {\n\tcase TYPE_MAESTRO2E:\n\t\tstrcpy(card->driver, \"ES1978\");\n\t\tstrcpy(card->shortname, \"ESS ES1978 (Maestro 2E)\");\n\t\tbreak;\n\tcase TYPE_MAESTRO2:\n\t\tstrcpy(card->driver, \"ES1968\");\n\t\tstrcpy(card->shortname, \"ESS ES1968 (Maestro 2)\");\n\t\tbreak;\n\tcase TYPE_MAESTRO:\n\t\tstrcpy(card->driver, \"ESM1\");\n\t\tstrcpy(card->shortname, \"ESS Maestro 1\");\n\t\tbreak;\n\t}\n\n\terr = snd_es1968_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_es1968_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (enable_mpu[dev] == 2) {\n\t\t \n\t\tunsigned short vend;\n\t\tpci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);\n\t\tfor (i = 0; i < ARRAY_SIZE(mpu_denylist); i++) {\n\t\t\tif (chip->type == mpu_denylist[i].type &&\n\t\t\t    vend == mpu_denylist[i].vendor) {\n\t\t\t\tenable_mpu[dev] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (enable_mpu[dev]) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\t\t  chip->io_port + ESM_MPU401_PORT,\n\t\t\t\t\t  MPU401_INFO_INTEGRATED |\n\t\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t\t  -1, &chip->rmidi);\n\t\tif (err < 0)\n\t\t\tdev_warn(card->dev, \"skipping MPU-401 MIDI support..\\n\");\n\t}\n\n\tsnd_es1968_create_gameport(chip, dev);\n\n#ifdef CONFIG_SND_ES1968_INPUT\n\terr = snd_es1968_input_register(chip);\n\tif (err)\n\t\tdev_warn(card->dev,\n\t\t\t \"Input device registration failed with error %i\", err);\n#endif\n\n\tsnd_es1968_start_irq(chip);\n\n\tchip->clock = clock[dev];\n\tif (! chip->clock)\n\t\tes1968_measure_clock(chip);\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, chip->io_port, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_es1968_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_es1968_probe(pci, pci_id));\n}\n\nstatic struct pci_driver es1968_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_es1968_ids,\n\t.probe = snd_es1968_probe,\n\t.driver = {\n\t\t.pm = ES1968_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(es1968_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}